
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0395136778115504%, Tokens: 11</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</h3>
            <pre><code>1  #ifndef GTEST_SRC_GTEST_INTERNAL_INL_H_
2  #define GTEST_SRC_GTEST_INTERNAL_INL_H_
3  #if !GTEST_IMPLEMENTATION_
4  # error "gtest-internal-inl.h is part of Google Test's internal implementation."
5  # error "It must not be included except by Google Test itself."
6  #endif  
7  #ifndef _WIN32_WCE
8  # include <errno.h>
9  #endif  
10  #include <stddef.h>
11  #include <stdlib.h>  
12  #include <string.h>  
13  #include <algorithm>
14  #include <string>
15  #include <vector>
16  #include "gtest/internal/gtest-port.h"
17  #if GTEST_CAN_STREAM_RESULTS_
18  # include <arpa/inet.h>  
19  # include <netdb.h>  
20  #endif
21  #if GTEST_OS_WINDOWS
22  # include <windows.h>  
23  #endif  
24  #include "gtest/gtest.h"  
25  #include "gtest/gtest-spi.h"
26  namespace testing {
27  GTEST_DECLARE_bool_(death_test_use_fork);
28  namespace internal {
29  GTEST_API_ extern const TypeId kTestTypeIdInGoogleTest;
30  const char kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests";
31  const char kBreakOnFailureFlag[] = "break_on_failure";
32  const char kCatchExceptionsFlag[] = "catch_exceptions";
33  const char kColorFlag[] = "color";
34  const char kFilterFlag[] = "filter";
35  const char kListTestsFlag[] = "list_tests";
36  const char kOutputFlag[] = "output";
37  const char kPrintTimeFlag[] = "print_time";
38  const char kRandomSeedFlag[] = "random_seed";
39  const char kRepeatFlag[] = "repeat";
40  const char kShuffleFlag[] = "shuffle";
41  const char kStackTraceDepthFlag[] = "stack_trace_depth";
42  const char kStreamResultToFlag[] = "stream_result_to";
43  const char kThrowOnFailureFlag[] = "throw_on_failure";
44  const int kMaxRandomSeed = 99999;
45  GTEST_API_ extern bool g_help_flag;
46  GTEST_API_ TimeInMillis GetTimeInMillis();
47  GTEST_API_ bool ShouldUseColor(bool stdout_is_tty);
48  GTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);
49  GTEST_API_ std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms);
50  GTEST_API_ bool ParseInt32Flag(
51      const char* str, const char* flag, Int32* value);
52  inline int GetRandomSeedFromFlag(Int32 random_seed_flag) {
53    const unsigned int raw_seed = (random_seed_flag == 0) ?
54        static_cast<unsigned int>(GetTimeInMillis()) :
55        static_cast<unsigned int>(random_seed_flag);
56    const int normalized_seed =
57        static_cast<int>((raw_seed - 1U) %
58                         static_cast<unsigned int>(kMaxRandomSeed)) + 1;
59    return normalized_seed;
60  }
61  inline int GetNextRandomSeed(int seed) {
62    GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)
63        << "Invalid random seed " << seed << " - must be in [1, "
64        << kMaxRandomSeed << "].";
65    const int next_seed = seed + 1;
66    return (next_seed > kMaxRandomSeed) ? 1 : next_seed;
67  }
68  class GTestFlagSaver {
69   public:
70    GTestFlagSaver() {
71      also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);
72      break_on_failure_ = GTEST_FLAG(break_on_failure);
73      catch_exceptions_ = GTEST_FLAG(catch_exceptions);
74      color_ = GTEST_FLAG(color);
75      death_test_style_ = GTEST_FLAG(death_test_style);
76      death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);
77      filter_ = GTEST_FLAG(filter);
78      internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);
79      list_tests_ = GTEST_FLAG(list_tests);
80      output_ = GTEST_FLAG(output);
81      print_time_ = GTEST_FLAG(print_time);
82      random_seed_ = GTEST_FLAG(random_seed);
83      repeat_ = GTEST_FLAG(repeat);
84      shuffle_ = GTEST_FLAG(shuffle);
85      stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);
86      stream_result_to_ = GTEST_FLAG(stream_result_to);
87      throw_on_failure_ = GTEST_FLAG(throw_on_failure);
<span onclick='openModal()' class='match'>88    }
89    ~GTestFlagSaver() {
90      GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;
91      GTEST_FLAG(break_on_failure) = break_on_failure_;
92      GTEST_FLAG(catch_exceptions) = catch_exceptions_;
93      GTEST_FLAG(color) = color_;
94      GTEST_FLAG(death_test_style) = death_test_style_;
95      GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;
96      GTEST_FLAG(filter) = filter_;
97      GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;
98      GTEST_FLAG(list_tests) = list_tests_;
</span>99      GTEST_FLAG(output) = output_;
100      GTEST_FLAG(print_time) = print_time_;
101      GTEST_FLAG(random_seed) = random_seed_;
102      GTEST_FLAG(repeat) = repeat_;
103      GTEST_FLAG(shuffle) = shuffle_;
104      GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;
105      GTEST_FLAG(stream_result_to) = stream_result_to_;
106      GTEST_FLAG(throw_on_failure) = throw_on_failure_;
107    }
108   private:
109    bool also_run_disabled_tests_;
110    bool break_on_failure_;
111    bool catch_exceptions_;
112    std::string color_;
113    std::string death_test_style_;
114    bool death_test_use_fork_;
115    std::string filter_;
116    std::string internal_run_death_test_;
117    bool list_tests_;
118    std::string output_;
119    bool print_time_;
120    internal::Int32 random_seed_;
121    internal::Int32 repeat_;
122    bool shuffle_;
123    internal::Int32 stack_trace_depth_;
124    std::string stream_result_to_;
125    bool throw_on_failure_;
126  } GTEST_ATTRIBUTE_UNUSED_;
127  GTEST_API_ std::string CodePointToUtf8(UInt32 code_point);
128  GTEST_API_ std::string WideStringToUtf8(const wchar_t* str, int num_chars);
129  void WriteToShardStatusFileIfNeeded();
130  GTEST_API_ bool ShouldShard(const char* total_shards_str,
131                              const char* shard_index_str,
132                              bool in_subprocess_for_death_test);
133  GTEST_API_ Int32 Int32FromEnvOrDie(const char* env_var, Int32 default_val);
134  GTEST_API_ bool ShouldRunTestOnShard(
135      int total_shards, int shard_index, int test_id);
136  template <class Container, typename Predicate>
137  inline int CountIf(const Container& c, Predicate predicate) {
138    int count = 0;
139    for (typename Container::const_iterator it = c.begin(); it != c.end(); ++it) {
140      if (predicate(*it))
141        ++count;
142    }
143    return count;
144  }
145  template <class Container, typename Functor>
146  void ForEach(const Container& c, Functor functor) {
147    std::for_each(c.begin(), c.end(), functor);
148  }
149  template <typename E>
150  inline E GetElementOr(const std::vector<E>& v, int i, E default_value) {
151    return (i < 0 || i >= static_cast<int>(v.size())) ? default_value : v[i];
152  }
153  template <typename E>
154  void ShuffleRange(internal::Random* random, int begin, int end,
155                    std::vector<E>* v) {
156    const int size = static_cast<int>(v->size());
157    GTEST_CHECK_(0 <= begin && begin <= size)
158        << "Invalid shuffle range start " << begin << ": must be in range [0, "
159        << size << "].";
160    GTEST_CHECK_(begin <= end && end <= size)
161        << "Invalid shuffle range finish " << end << ": must be in range ["
162        << begin << ", " << size << "].";
163    for (int range_width = end - begin; range_width >= 2; range_width--) {
164      const int last_in_range = begin + range_width - 1;
165      const int selected = begin + random->Generate(range_width);
166      std::swap((*v)[selected], (*v)[last_in_range]);
167    }
168  }
169  template <typename E>
170  inline void Shuffle(internal::Random* random, std::vector<E>* v) {
171    ShuffleRange(random, 0, static_cast<int>(v->size()), v);
172  }
173  template <typename T>
174  static void Delete(T* x) {
175    delete x;
176  }
177  class TestPropertyKeyIs {
178   public:
179    explicit TestPropertyKeyIs(const std::string& key) : key_(key) {}
180    bool operator()(const TestProperty& test_property) const {
181      return test_property.key() == key_;
182    }
183   private:
184    std::string key_;
185  };
186  class GTEST_API_ UnitTestOptions {
187   public:
188    static std::string GetOutputFormat();
189    static std::string GetAbsolutePathToOutputFile();
190    static bool PatternMatchesString(const char *pattern, const char *str);
191    static bool FilterMatchesTest(const std::string &test_case_name,
192                                  const std::string &test_name);
193  #if GTEST_OS_WINDOWS
194    static int GTestShouldProcessSEH(DWORD exception_code);
195  #endif  
196    static bool MatchesFilter(const std::string& name, const char* filter);
197  };
198  GTEST_API_ FilePath GetCurrentExecutableName();
199  class OsStackTraceGetterInterface {
200   public:
201    OsStackTraceGetterInterface() {}
202    virtual ~OsStackTraceGetterInterface() {}
203    virtual string CurrentStackTrace(int max_depth, int skip_count) = 0;
204    virtual void UponLeavingGTest() = 0;
205   private:
206    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface);
207  };
208  class OsStackTraceGetter : public OsStackTraceGetterInterface {
209   public:
210    OsStackTraceGetter() : caller_frame_(NULL) {}
211    virtual string CurrentStackTrace(int max_depth, int skip_count)
212        GTEST_LOCK_EXCLUDED_(mutex_);
213    virtual void UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_);
214    static const char* const kElidedFramesMarker;
215   private:
216    Mutex mutex_;  
217    void* caller_frame_;
218    GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter);
219  };
220  struct TraceInfo {
221    const char* file;
222    int line;
223    std::string message;
224  };
225  class DefaultGlobalTestPartResultReporter
226    : public TestPartResultReporterInterface {
227   public:
228    explicit DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);
229    virtual void ReportTestPartResult(const TestPartResult& result);
230   private:
231    UnitTestImpl* const unit_test_;
232    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter);
233  };
234  class DefaultPerThreadTestPartResultReporter
235      : public TestPartResultReporterInterface {
236   public:
237    explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);
238    virtual void ReportTestPartResult(const TestPartResult& result);
239   private:
240    UnitTestImpl* const unit_test_;
241    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultPerThreadTestPartResultReporter);
242  };
243  class GTEST_API_ UnitTestImpl {
244   public:
245    explicit UnitTestImpl(UnitTest* parent);
246    virtual ~UnitTestImpl();
247    TestPartResultReporterInterface* GetGlobalTestPartResultReporter();
248    void SetGlobalTestPartResultReporter(
249        TestPartResultReporterInterface* reporter);
250    TestPartResultReporterInterface* GetTestPartResultReporterForCurrentThread();
251    void SetTestPartResultReporterForCurrentThread(
252        TestPartResultReporterInterface* reporter);
253    int successful_test_case_count() const;
254    int failed_test_case_count() const;
255    int total_test_case_count() const;
256    int test_case_to_run_count() const;
257    int successful_test_count() const;
258    int failed_test_count() const;
259    int reportable_disabled_test_count() const;
260    int disabled_test_count() const;
261    int reportable_test_count() const;
262    int total_test_count() const;
263    int test_to_run_count() const;
264    TimeInMillis start_timestamp() const { return start_timestamp_; }
265    TimeInMillis elapsed_time() const { return elapsed_time_; }
266    bool Passed() const { return !Failed(); }
267    bool Failed() const {
268      return failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();
269    }
270    const TestCase* GetTestCase(int i) const {
271      const int index = GetElementOr(test_case_indices_, i, -1);
272      return index < 0 ? NULL : test_cases_[i];
273    }
274    TestCase* GetMutableTestCase(int i) {
275      const int index = GetElementOr(test_case_indices_, i, -1);
276      return index < 0 ? NULL : test_cases_[index];
277    }
278    TestEventListeners* listeners() { return &listeners_; }
279    TestResult* current_test_result();
280    const TestResult* ad_hoc_test_result() const { return &ad_hoc_test_result_; }
281    void set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);
282    OsStackTraceGetterInterface* os_stack_trace_getter();
283    std::string CurrentOsStackTraceExceptTop(int skip_count) GTEST_NO_INLINE_;
284    TestCase* GetTestCase(const char* test_case_name,
285                          const char* type_param,
286                          Test::SetUpTestCaseFunc set_up_tc,
287                          Test::TearDownTestCaseFunc tear_down_tc);
288    void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,
289                     Test::TearDownTestCaseFunc tear_down_tc,
290                     TestInfo* test_info) {
291      if (original_working_dir_.IsEmpty()) {
292        original_working_dir_.Set(FilePath::GetCurrentDir());
293        GTEST_CHECK_(!original_working_dir_.IsEmpty())
294            << "Failed to get the current working directory.";
295      }
296      GetTestCase(test_info->test_case_name(),
297                  test_info->type_param(),
298                  set_up_tc,
299                  tear_down_tc)->AddTestInfo(test_info);
300    }
301  #if GTEST_HAS_PARAM_TEST
302    internal::ParameterizedTestCaseRegistry& parameterized_test_registry() {
303      return parameterized_test_registry_;
304    }
305  #endif  
306    void set_current_test_case(TestCase* a_current_test_case) {
307      current_test_case_ = a_current_test_case;
308    }
309    void set_current_test_info(TestInfo* a_current_test_info) {
310      current_test_info_ = a_current_test_info;
311    }
312    void RegisterParameterizedTests();
313    bool RunAllTests();
314    void ClearNonAdHocTestResult() {
315      ForEach(test_cases_, TestCase::ClearTestCaseResult);
316    }
317    void ClearAdHocTestResult() {
318      ad_hoc_test_result_.Clear();
319    }
320    void RecordProperty(const TestProperty& test_property);
321    enum ReactionToSharding {
322      HONOR_SHARDING_PROTOCOL,
323      IGNORE_SHARDING_PROTOCOL
324    };
325    int FilterTests(ReactionToSharding shard_tests);
326    void ListTestsMatchingFilter();
327    const TestCase* current_test_case() const { return current_test_case_; }
328    TestInfo* current_test_info() { return current_test_info_; }
329    const TestInfo* current_test_info() const { return current_test_info_; }
330    std::vector<Environment*>& environments() { return environments_; }
331    std::vector<TraceInfo>& gtest_trace_stack() {
332      return *(gtest_trace_stack_.pointer());
333    }
334    const std::vector<TraceInfo>& gtest_trace_stack() const {
335      return gtest_trace_stack_.get();
336    }
337  #if GTEST_HAS_DEATH_TEST
338    void InitDeathTestSubprocessControlInfo() {
339      internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());
340    }
341    const InternalRunDeathTestFlag* internal_run_death_test_flag() const {
342      return internal_run_death_test_flag_.get();
343    }
344    internal::DeathTestFactory* death_test_factory() {
345      return death_test_factory_.get();
346    }
347    void SuppressTestEventsIfInSubprocess();
348    friend class ReplaceDeathTestFactory;
349  #endif  
350    void ConfigureXmlOutput();
351  #if GTEST_CAN_STREAM_RESULTS_
352    void ConfigureStreamingOutput();
353  #endif
354    void PostFlagParsingInit();
355    int random_seed() const { return random_seed_; }
356    internal::Random* random() { return &random_; }
357    void ShuffleTests();
358    void UnshuffleTests();
359    bool catch_exceptions() const { return catch_exceptions_; }
360   private:
361    friend class ::testing::UnitTest;
362    void set_catch_exceptions(bool value) { catch_exceptions_ = value; }
363    UnitTest* const parent_;
364    internal::FilePath original_working_dir_;
365    DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_;
366    DefaultPerThreadTestPartResultReporter
367        default_per_thread_test_part_result_reporter_;
368    TestPartResultReporterInterface* global_test_part_result_repoter_;
369    internal::Mutex global_test_part_result_reporter_mutex_;
370    internal::ThreadLocal<TestPartResultReporterInterface*>
371        per_thread_test_part_result_reporter_;
372    std::vector<Environment*> environments_;
373    std::vector<TestCase*> test_cases_;
374    std::vector<int> test_case_indices_;
375  #if GTEST_HAS_PARAM_TEST
376    internal::ParameterizedTestCaseRegistry parameterized_test_registry_;
377    bool parameterized_tests_registered_;
378  #endif  
379    int last_death_test_case_;
380    TestCase* current_test_case_;
381    TestInfo* current_test_info_;
382    TestResult ad_hoc_test_result_;
383    TestEventListeners listeners_;
384    OsStackTraceGetterInterface* os_stack_trace_getter_;
385    bool post_flag_parse_init_performed_;
386    int random_seed_;
387    internal::Random random_;
388    TimeInMillis start_timestamp_;
389    TimeInMillis elapsed_time_;
390  #if GTEST_HAS_DEATH_TEST
391    internal::scoped_ptr<InternalRunDeathTestFlag> internal_run_death_test_flag_;
392    internal::scoped_ptr<internal::DeathTestFactory> death_test_factory_;
393  #endif  
394    internal::ThreadLocal<std::vector<TraceInfo> > gtest_trace_stack_;
395    bool catch_exceptions_;
396    GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl);
397  };  
398  inline UnitTestImpl* GetUnitTestImpl() {
399    return UnitTest::GetInstance()->impl();
400  }
401  #if GTEST_USES_SIMPLE_RE
402  GTEST_API_ bool IsInSet(char ch, const char* str);
403  GTEST_API_ bool IsAsciiDigit(char ch);
404  GTEST_API_ bool IsAsciiPunct(char ch);
405  GTEST_API_ bool IsRepeat(char ch);
406  GTEST_API_ bool IsAsciiWhiteSpace(char ch);
407  GTEST_API_ bool IsAsciiWordChar(char ch);
408  GTEST_API_ bool IsValidEscape(char ch);
409  GTEST_API_ bool AtomMatchesChar(bool escaped, char pattern, char ch);
410  GTEST_API_ bool ValidateRegex(const char* regex);
411  GTEST_API_ bool MatchRegexAtHead(const char* regex, const char* str);
412  GTEST_API_ bool MatchRepetitionAndRegexAtHead(
413      bool escaped, char ch, char repeat, const char* regex, const char* str);
414  GTEST_API_ bool MatchRegexAnywhere(const char* regex, const char* str);
415  #endif  
416  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, char** argv);
417  GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);
418  #if GTEST_HAS_DEATH_TEST
419  GTEST_API_ std::string GetLastErrnoDescription();
420  # if GTEST_OS_WINDOWS
421  class AutoHandle {
422   public:
423    AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}
424    explicit AutoHandle(HANDLE handle) : handle_(handle) {}
425    ~AutoHandle() { Reset(); }
426    HANDLE Get() const { return handle_; }
427    void Reset() { Reset(INVALID_HANDLE_VALUE); }
428    void Reset(HANDLE handle) {
429      if (handle != handle_) {
430        if (handle_ != INVALID_HANDLE_VALUE)
431          ::CloseHandle(handle_);
432        handle_ = handle;
433      }
434    }
435   private:
436    HANDLE handle_;
437    GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);
438  };
439  # endif  
440  template <typename Integer>
441  bool ParseNaturalNumber(const ::std::string& str, Integer* number) {
442    if (str.empty() || !IsDigit(str[0])) {
443      return false;
444    }
445    errno = 0;
446    char* end;
447  # if GTEST_OS_WINDOWS && !defined(__GNUC__)
448    typedef unsigned __int64 BiggestConvertible;
449    const BiggestConvertible parsed = _strtoui64(str.c_str(), &end, 10);
450  # else
451    typedef unsigned long long BiggestConvertible;  
452    const BiggestConvertible parsed = strtoull(str.c_str(), &end, 10);
453  # endif  
454    const bool parse_success = *end == '\0' && errno == 0;
455    GTEST_CHECK_(sizeof(Integer) <= sizeof(parsed));
456    const Integer result = static_cast<Integer>(parsed);
457    if (parse_success && static_cast<BiggestConvertible>(result) == parsed) {
458      *number = result;
459      return true;
460    }
461    return false;
462  }
463  #endif  
464  class TestResultAccessor {
465   public:
466    static void RecordProperty(TestResult* test_result,
467                               const std::string& xml_element,
468                               const TestProperty& property) {
469      test_result->RecordProperty(xml_element, property);
470    }
471    static void ClearTestPartResults(TestResult* test_result) {
472      test_result->ClearTestPartResults();
473    }
474    static const std::vector<testing::TestPartResult>& test_part_results(
475        const TestResult& test_result) {
476      return test_result.test_part_results();
477    }
478  };
479  #if GTEST_CAN_STREAM_RESULTS_
480  class StreamingListener : public EmptyTestEventListener {
481   public:
482    class AbstractSocketWriter {
483     public:
484      virtual ~AbstractSocketWriter() {}
485      virtual void Send(const string& message) = 0;
486      virtual void CloseConnection() {}
487      void SendLn(const string& message) {
488        Send(message + "\n");
489      }
490    };
491    class SocketWriter : public AbstractSocketWriter {
492     public:
493      SocketWriter(const string& host, const string& port)
494          : sockfd_(-1), host_name_(host), port_num_(port) {
495        MakeConnection();
496      }
497      virtual ~SocketWriter() {
498        if (sockfd_ != -1)
499          CloseConnection();
500      }
501      virtual void Send(const string& message) {
502        GTEST_CHECK_(sockfd_ != -1)
503            << "Send() can be called only when there is a connection.";
504        const int len = static_cast<int>(message.length());
505        if (write(sockfd_, message.c_str(), len) != len) {
506          GTEST_LOG_(WARNING)
507              << "stream_result_to: failed to stream to "
508              << host_name_ << ":" << port_num_;
509        }
510      }
511     private:
512      void MakeConnection();
513      void CloseConnection() {
514        GTEST_CHECK_(sockfd_ != -1)
515            << "CloseConnection() can be called only when there is a connection.";
516        close(sockfd_);
517        sockfd_ = -1;
518      }
519      int sockfd_;  
520      const string host_name_;
521      const string port_num_;
522      GTEST_DISALLOW_COPY_AND_ASSIGN_(SocketWriter);
523    };  
524    static string UrlEncode(const char* str);
525    StreamingListener(const string& host, const string& port)
526        : socket_writer_(new SocketWriter(host, port)) { Start(); }
527    explicit StreamingListener(AbstractSocketWriter* socket_writer)
528        : socket_writer_(socket_writer) { Start(); }
529    void OnTestProgramStart(const UnitTest& &bsol;* unit_test */) {
530      SendLn("event=TestProgramStart");
531    }
532    void OnTestProgramEnd(const UnitTest& unit_test) {
533      SendLn("event=TestProgramEnd&passed=" + FormatBool(unit_test.Passed()));
534      socket_writer_->CloseConnection();
535    }
536    void OnTestIterationStart(const UnitTest& &bsol;* unit_test */, int iteration) {
537      SendLn("event=TestIterationStart&iteration=" +
538             StreamableToString(iteration));
539    }
540    void OnTestIterationEnd(const UnitTest& unit_test, int &bsol;* iteration */) {
541      SendLn("event=TestIterationEnd&passed=" +
542             FormatBool(unit_test.Passed()) + "&elapsed_time=" +
543             StreamableToString(unit_test.elapsed_time()) + "ms");
544    }
545    void OnTestCaseStart(const TestCase& test_case) {
546      SendLn(std::string("event=TestCaseStart&name=") + test_case.name());
547    }
548    void OnTestCaseEnd(const TestCase& test_case) {
549      SendLn("event=TestCaseEnd&passed=" + FormatBool(test_case.Passed())
550             + "&elapsed_time=" + StreamableToString(test_case.elapsed_time())
551             + "ms");
552    }
553    void OnTestStart(const TestInfo& test_info) {
554      SendLn(std::string("event=TestStart&name=") + test_info.name());
555    }
556    void OnTestEnd(const TestInfo& test_info) {
557      SendLn("event=TestEnd&passed=" +
558             FormatBool((test_info.result())->Passed()) +
559             "&elapsed_time=" +
560             StreamableToString((test_info.result())->elapsed_time()) + "ms");
561    }
562    void OnTestPartResult(const TestPartResult& test_part_result) {
563      const char* file_name = test_part_result.file_name();
564      if (file_name == NULL)
565        file_name = "";
566      SendLn("event=TestPartResult&file=" + UrlEncode(file_name) +
567             "&line=" + StreamableToString(test_part_result.line_number()) +
568             "&message=" + UrlEncode(test_part_result.message()));
569    }
570   private:
571    void SendLn(const string& message) { socket_writer_->SendLn(message); }
572    void Start() { SendLn("gtest_streaming_protocol_version=1.0"); }
573    string FormatBool(bool value) { return value ? "1" : "0"; }
574    const scoped_ptr<AbstractSocketWriter> socket_writer_;
575    GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamingListener);
576  };  
577  #endif  
578  }  
579  }  
580  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
<span onclick='openModal()' class='match'>388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
</span>400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-internal-inl.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                </div>
                <div class="column column_space"><pre><code>88    }
89    ~GTestFlagSaver() {
90      GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;
91      GTEST_FLAG(break_on_failure) = break_on_failure_;
92      GTEST_FLAG(catch_exceptions) = catch_exceptions_;
93      GTEST_FLAG(color) = color_;
94      GTEST_FLAG(death_test_style) = death_test_style_;
95      GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;
96      GTEST_FLAG(filter) = filter_;
97      GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;
98      GTEST_FLAG(list_tests) = list_tests_;
</pre></code></div>
                <div class="column column_space"><pre><code>388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    