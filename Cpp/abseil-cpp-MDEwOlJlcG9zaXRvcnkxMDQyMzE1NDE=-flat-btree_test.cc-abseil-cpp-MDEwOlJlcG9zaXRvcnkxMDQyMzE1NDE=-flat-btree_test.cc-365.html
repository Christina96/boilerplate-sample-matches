
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</h3>
            <pre><code>1  #include &quot;absl/container/btree_test.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;array&gt;
4  #include &lt;cstdint&gt;
5  #include &lt;functional&gt;
6  #include &lt;iostream&gt;
7  #include &lt;iterator&gt;
8  #include &lt;limits&gt;
9  #include &lt;map&gt;
10  #include &lt;memory&gt;
11  #include &lt;numeric&gt;
12  #include &lt;stdexcept&gt;
13  #include &lt;string&gt;
14  #include &lt;type_traits&gt;
15  #include &lt;utility&gt;
16  #include &lt;vector&gt;
17  #include &quot;gmock/gmock.h&quot;
18  #include &quot;gtest/gtest.h&quot;
19  #include &quot;absl/algorithm/container.h&quot;
20  #include &quot;absl/base/internal/raw_logging.h&quot;
21  #include &quot;absl/base/macros.h&quot;
22  #include &quot;absl/container/btree_map.h&quot;
23  #include &quot;absl/container/btree_set.h&quot;
24  #include &quot;absl/container/internal/counting_allocator.h&quot;
25  #include &quot;absl/container/internal/test_instance_tracker.h&quot;
26  #include &quot;absl/flags/flag.h&quot;
27  #include &quot;absl/hash/hash_testing.h&quot;
28  #include &quot;absl/memory/memory.h&quot;
29  #include &quot;absl/random/random.h&quot;
30  #include &quot;absl/strings/str_cat.h&quot;
31  #include &quot;absl/strings/str_split.h&quot;
32  #include &quot;absl/strings/string_view.h&quot;
33  #include &quot;absl/types/compare.h&quot;
34  #include &quot;absl/types/optional.h&quot;
35  ABSL_FLAG(int, test_values, 10000, &quot;The number of values to use for tests&quot;);
36  namespace absl {
37  ABSL_NAMESPACE_BEGIN
38  namespace container_internal {
39  namespace {
40  using ::absl::test_internal::CopyableMovableInstance;
41  using ::absl::test_internal::InstanceTracker;
42  using ::absl::test_internal::MovableOnlyInstance;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::IsEmpty;
46  using ::testing::IsNull;
47  using ::testing::Pair;
48  using ::testing::SizeIs;
49  template &lt;typename T, typename U&gt;
50  void CheckPairEquals(const T &amp;x, const U &amp;y) {
51    ABSL_INTERNAL_CHECK(x == y, &quot;Values are unequal.&quot;);
52  }
53  template &lt;typename T, typename U, typename V, typename W&gt;
54  void CheckPairEquals(const std::pair&lt;T, U&gt; &amp;x, const std::pair&lt;V, W&gt; &amp;y) {
55    CheckPairEquals(x.first, y.first);
56    CheckPairEquals(x.second, y.second);
57  }
58  bool IsAssertEnabled() {
59    bool assert_enabled = false;
60    assert([&amp;]() {  
61      assert_enabled = true;
62      return true;
63    }());
64    return assert_enabled;
65  }
66  }  
67  template &lt;typename TreeType, typename CheckerType&gt;
68  class base_checker {
69   public:
70    using key_type = typename TreeType::key_type;
71    using value_type = typename TreeType::value_type;
72    using key_compare = typename TreeType::key_compare;
73    using pointer = typename TreeType::pointer;
74    using const_pointer = typename TreeType::const_pointer;
75    using reference = typename TreeType::reference;
76    using const_reference = typename TreeType::const_reference;
77    using size_type = typename TreeType::size_type;
78    using difference_type = typename TreeType::difference_type;
79    using iterator = typename TreeType::iterator;
80    using const_iterator = typename TreeType::const_iterator;
81    using reverse_iterator = typename TreeType::reverse_iterator;
82    using const_reverse_iterator = typename TreeType::const_reverse_iterator;
83   public:
84    base_checker() : const_tree_(tree_) {}
85    base_checker(const base_checker &amp;other)
86        : tree_(other.tree_), const_tree_(tree_), checker_(other.checker_) {}
87    template &lt;typename InputIterator&gt;
88    base_checker(InputIterator b, InputIterator e)
89        : tree_(b, e), const_tree_(tree_), checker_(b, e) {}
90    iterator begin() { return tree_.begin(); }
91    const_iterator begin() const { return tree_.begin(); }
92    iterator end() { return tree_.end(); }
93    const_iterator end() const { return tree_.end(); }
94    reverse_iterator rbegin() { return tree_.rbegin(); }
95    const_reverse_iterator rbegin() const { return tree_.rbegin(); }
96    reverse_iterator rend() { return tree_.rend(); }
97    const_reverse_iterator rend() const { return tree_.rend(); }
98    template &lt;typename IterType, typename CheckerIterType&gt;
99    IterType iter_check(IterType tree_iter, CheckerIterType checker_iter) const {
100      if (tree_iter == tree_.end()) {
101        ABSL_INTERNAL_CHECK(checker_iter == checker_.end(),
102                            &quot;Checker iterator not at end.&quot;);
103      } else {
104        CheckPairEquals(*tree_iter, *checker_iter);
105      }
106      return tree_iter;
107    }
108    template &lt;typename IterType, typename CheckerIterType&gt;
109    IterType riter_check(IterType tree_iter, CheckerIterType checker_iter) const {
110      if (tree_iter == tree_.rend()) {
111        ABSL_INTERNAL_CHECK(checker_iter == checker_.rend(),
112                            &quot;Checker iterator not at rend.&quot;);
113      } else {
114        CheckPairEquals(*tree_iter, *checker_iter);
115      }
116      return tree_iter;
117    }
118    void value_check(const value_type &amp;v) {
119      typename KeyOfValue&lt;typename TreeType::key_type,
120                          typename TreeType::value_type&gt;::type key_of_value;
121      const key_type &amp;key = key_of_value(v);
122      CheckPairEquals(*find(key), v);
123      lower_bound(key);
124      upper_bound(key);
125      equal_range(key);
126      contains(key);
127      count(key);
128    }
129    void erase_check(const key_type &amp;key) {
130      EXPECT_FALSE(tree_.contains(key));
131      EXPECT_EQ(tree_.find(key), const_tree_.end());
132      EXPECT_FALSE(const_tree_.contains(key));
133      EXPECT_EQ(const_tree_.find(key), tree_.end());
134      EXPECT_EQ(tree_.equal_range(key).first,
135                const_tree_.equal_range(key).second);
136    }
137    iterator lower_bound(const key_type &amp;key) {
138      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
139    }
140    const_iterator lower_bound(const key_type &amp;key) const {
141      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
142    }
143    iterator upper_bound(const key_type &amp;key) {
144      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
145    }
146    const_iterator upper_bound(const key_type &amp;key) const {
147      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
148    }
149    std::pair&lt;iterator, iterator&gt; equal_range(const key_type &amp;key) {
150      std::pair&lt;typename CheckerType::iterator, typename CheckerType::iterator&gt;
151          checker_res = checker_.equal_range(key);
152      std::pair&lt;iterator, iterator&gt; tree_res = tree_.equal_range(key);
153      iter_check(tree_res.first, checker_res.first);
154      iter_check(tree_res.second, checker_res.second);
155      return tree_res;
156    }
157    std::pair&lt;const_iterator, const_iterator&gt; equal_range(
158        const key_type &amp;key) const {
159      std::pair&lt;typename CheckerType::const_iterator,
160                typename CheckerType::const_iterator&gt;
161          checker_res = checker_.equal_range(key);
162      std::pair&lt;const_iterator, const_iterator&gt; tree_res = tree_.equal_range(key);
163      iter_check(tree_res.first, checker_res.first);
164      iter_check(tree_res.second, checker_res.second);
165      return tree_res;
166    }
167    iterator find(const key_type &amp;key) {
168      return iter_check(tree_.find(key), checker_.find(key));
169    }
170    const_iterator find(const key_type &amp;key) const {
171      return iter_check(tree_.find(key), checker_.find(key));
172    }
173    bool contains(const key_type &amp;key) const { return find(key) != end(); }
174    size_type count(const key_type &amp;key) const {
175      size_type res = checker_.count(key);
176      EXPECT_EQ(res, tree_.count(key));
177      return res;
178    }
179    base_checker &amp;operator=(const base_checker &amp;other) {
180      tree_ = other.tree_;
181      checker_ = other.checker_;
182      return *this;
183    }
184    int erase(const key_type &amp;key) {
185      int size = tree_.size();
186      int res = checker_.erase(key);
187      EXPECT_EQ(res, tree_.count(key));
188      EXPECT_EQ(res, tree_.erase(key));
189      EXPECT_EQ(tree_.count(key), 0);
190      EXPECT_EQ(tree_.size(), size - res);
191      erase_check(key);
192      return res;
193    }
194    iterator erase(iterator iter) {
195      key_type key = iter.key();
196      int size = tree_.size();
197      int count = tree_.count(key);
198      auto checker_iter = checker_.lower_bound(key);
199      for (iterator tmp(tree_.lower_bound(key)); tmp != iter; ++tmp) {
200        ++checker_iter;
201      }
202      auto checker_next = checker_iter;
203      ++checker_next;
204      checker_.erase(checker_iter);
205      iter = tree_.erase(iter);
206      EXPECT_EQ(tree_.size(), checker_.size());
207      EXPECT_EQ(tree_.size(), size - 1);
208      EXPECT_EQ(tree_.count(key), count - 1);
209      if (count == 1) {
210        erase_check(key);
211      }
212      return iter_check(iter, checker_next);
213    }
214    void erase(iterator begin, iterator end) {
215      int size = tree_.size();
216      int count = std::distance(begin, end);
217      auto checker_begin = checker_.lower_bound(begin.key());
218      for (iterator tmp(tree_.lower_bound(begin.key())); tmp != begin; ++tmp) {
219        ++checker_begin;
220      }
221      auto checker_end =
222          end == tree_.end() ? checker_.end() : checker_.lower_bound(end.key());
223      if (end != tree_.end()) {
224        for (iterator tmp(tree_.lower_bound(end.key())); tmp != end; ++tmp) {
225          ++checker_end;
226        }
227      }
228      const auto checker_ret = checker_.erase(checker_begin, checker_end);
229      const auto tree_ret = tree_.erase(begin, end);
230      EXPECT_EQ(std::distance(checker_.begin(), checker_ret),
231                std::distance(tree_.begin(), tree_ret));
232      EXPECT_EQ(tree_.size(), checker_.size());
233      EXPECT_EQ(tree_.size(), size - count);
234    }
235    void clear() {
236      tree_.clear();
237      checker_.clear();
238    }
239    void swap(base_checker &amp;other) {
240      tree_.swap(other.tree_);
241      checker_.swap(other.checker_);
242    }
243    void verify() const {
244      tree_.verify();
245      EXPECT_EQ(tree_.size(), checker_.size());
246      auto checker_iter = checker_.begin();
247      const_iterator tree_iter(tree_.begin());
248      for (; tree_iter != tree_.end(); ++tree_iter, ++checker_iter) {
249        CheckPairEquals(*tree_iter, *checker_iter);
250      }
251      for (int n = tree_.size() - 1; n &gt;= 0; --n) {
252        iter_check(tree_iter, checker_iter);
253        --tree_iter;
254        --checker_iter;
255      }
256      EXPECT_EQ(tree_iter, tree_.begin());
257      EXPECT_EQ(checker_iter, checker_.begin());
258      auto checker_riter = checker_.rbegin();
259      const_reverse_iterator tree_riter(tree_.rbegin());
260      for (; tree_riter != tree_.rend(); ++tree_riter, ++checker_riter) {
261        CheckPairEquals(*tree_riter, *checker_riter);
262      }
263      for (int n = tree_.size() - 1; n &gt;= 0; --n) {
264        riter_check(tree_riter, checker_riter);
265        --tree_riter;
266        --checker_riter;
267      }
268      EXPECT_EQ(tree_riter, tree_.rbegin());
269      EXPECT_EQ(checker_riter, checker_.rbegin());
270    }
271    const TreeType &amp;tree() const { return tree_; }
272    size_type size() const {
273      EXPECT_EQ(tree_.size(), checker_.size());
274      return tree_.size();
275    }
276    size_type max_size() const { return tree_.max_size(); }
277    bool empty() const {
278      EXPECT_EQ(tree_.empty(), checker_.empty());
279      return tree_.empty();
280    }
281   protected:
282    TreeType tree_;
283    const TreeType &amp;const_tree_;
284    CheckerType checker_;
285  };
286  namespace {
287  template &lt;typename TreeType, typename CheckerType&gt;
288  class unique_checker : public base_checker&lt;TreeType, CheckerType&gt; {
289    using super_type = base_checker&lt;TreeType, CheckerType&gt;;
290   public:
291    using iterator = typename super_type::iterator;
292    using value_type = typename super_type::value_type;
293   public:
294    unique_checker() : super_type() {}
295    unique_checker(const unique_checker &amp;other) : super_type(other) {}
296    template &lt;class InputIterator&gt;
297    unique_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
298    unique_checker &amp;operator=(const unique_checker &amp;) = default;
299    std::pair&lt;iterator, bool&gt; insert(const value_type &amp;v) {
300      int size = this-&gt;tree_.size();
301      std::pair&lt;typename CheckerType::iterator, bool&gt; checker_res =
302          this-&gt;checker_.insert(v);
303      std::pair&lt;iterator, bool&gt; tree_res = this-&gt;tree_.insert(v);
304      CheckPairEquals(*tree_res.first, *checker_res.first);
305      EXPECT_EQ(tree_res.second, checker_res.second);
306      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
307      EXPECT_EQ(this-&gt;tree_.size(), size + tree_res.second);
308      return tree_res;
<span onclick='openModal()' class='match'>309    }
310    iterator insert(iterator position, const value_type &amp;v) {
311      int size = this-&gt;tree_.size();
312      std::pair&lt;typename CheckerType::iterator, bool&gt; checker_res =
</span>313          this-&gt;checker_.insert(v);
314      iterator tree_res = this-&gt;tree_.insert(position, v);
315      CheckPairEquals(*tree_res, *checker_res.first);
316      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
317      EXPECT_EQ(this-&gt;tree_.size(), size + checker_res.second);
318      return tree_res;
319    }
320    template &lt;typename InputIterator&gt;
321    void insert(InputIterator b, InputIterator e) {
322      for (; b != e; ++b) {
323        insert(*b);
324      }
325    }
326  };
327  template &lt;typename TreeType, typename CheckerType&gt;
328  class multi_checker : public base_checker&lt;TreeType, CheckerType&gt; {
329    using super_type = base_checker&lt;TreeType, CheckerType&gt;;
330   public:
331    using iterator = typename super_type::iterator;
332    using value_type = typename super_type::value_type;
333   public:
334    multi_checker() : super_type() {}
335    multi_checker(const multi_checker &amp;other) : super_type(other) {}
336    template &lt;class InputIterator&gt;
337    multi_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
338    multi_checker &amp;operator=(const multi_checker &amp;) = default;
339    iterator insert(const value_type &amp;v) {
340      int size = this-&gt;tree_.size();
341      auto checker_res = this-&gt;checker_.insert(v);
342      iterator tree_res = this-&gt;tree_.insert(v);
343      CheckPairEquals(*tree_res, *checker_res);
344      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
345      EXPECT_EQ(this-&gt;tree_.size(), size + 1);
346      return tree_res;
347    }
348    iterator insert(iterator position, const value_type &amp;v) {
349      int size = this-&gt;tree_.size();
350      auto checker_res = this-&gt;checker_.insert(v);
351      iterator tree_res = this-&gt;tree_.insert(position, v);
352      CheckPairEquals(*tree_res, *checker_res);
353      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
354      EXPECT_EQ(this-&gt;tree_.size(), size + 1);
355      return tree_res;
356    }
357    template &lt;typename InputIterator&gt;
358    void insert(InputIterator b, InputIterator e) {
359      for (; b != e; ++b) {
360        insert(*b);
361      }
362    }
363  };
364  template &lt;typename T, typename V&gt;
365  void DoTest(const char *name, T *b, const std::vector&lt;V&gt; &amp;values) {
366    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
367    T &amp;mutable_b = *b;
368    const T &amp;const_b = *b;
369    for (int i = 0; i &lt; values.size(); ++i) {
370      mutable_b.insert(values[i]);
371      mutable_b.value_check(values[i]);
372    }
373    ASSERT_EQ(mutable_b.size(), values.size());
374    const_b.verify();
375    T b_copy(const_b);
376    EXPECT_EQ(b_copy.size(), const_b.size());
377    for (int i = 0; i &lt; values.size(); ++i) {
378      CheckPairEquals(*b_copy.find(key_of_value(values[i])), values[i]);
379    }
380    T b_range(const_b.begin(), const_b.end());
381    EXPECT_EQ(b_range.size(), const_b.size());
382    for (int i = 0; i &lt; values.size(); ++i) {
383      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
384    }
385    b_range.insert(b_copy.begin(), b_copy.end());
386    b_range.verify();
387    b_range.clear();
388    b_range.insert(b_copy.begin(), b_copy.end());
389    EXPECT_EQ(b_range.size(), b_copy.size());
390    for (int i = 0; i &lt; values.size(); ++i) {
391      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
392    }
393    b_range.operator=(b_range);
394    EXPECT_EQ(b_range.size(), b_copy.size());
395    b_range.clear();
396    b_range = b_copy;
397    EXPECT_EQ(b_range.size(), b_copy.size());
398    b_range.clear();
399    b_range.swap(b_copy);
400    EXPECT_EQ(b_copy.size(), 0);
401    EXPECT_EQ(b_range.size(), const_b.size());
402    for (int i = 0; i &lt; values.size(); ++i) {
403      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
404    }
405    b_range.swap(b_copy);
406    swap(b_range, b_copy);
407    EXPECT_EQ(b_copy.size(), 0);
408    EXPECT_EQ(b_range.size(), const_b.size());
409    for (int i = 0; i &lt; values.size(); ++i) {
410      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
411    }
412    swap(b_range, b_copy);
413    for (int i = 0; i &lt; values.size(); ++i) {
414      mutable_b.erase(key_of_value(values[i]));
415      ASSERT_EQ(mutable_b.erase(key_of_value(values[i])), 0);
416    }
417    const_b.verify();
418    EXPECT_EQ(const_b.size(), 0);
419    mutable_b = b_copy;
420    for (int i = 0; i &lt; values.size(); ++i) {
421      mutable_b.erase(mutable_b.find(key_of_value(values[i])));
422    }
423    const_b.verify();
424    EXPECT_EQ(const_b.size(), 0);
425    for (int i = 0; i &lt; values.size(); i++) {
426      mutable_b.insert(mutable_b.upper_bound(key_of_value(values[i])), values[i]);
427    }
428    const_b.verify();
429    mutable_b.erase(mutable_b.begin(), mutable_b.end());
430    EXPECT_EQ(mutable_b.size(), 0);
431    const_b.verify();
432    mutable_b = b_copy;
433    typename T::iterator mutable_iter_end = mutable_b.begin();
434    for (int i = 0; i &lt; values.size() / 2; ++i) ++mutable_iter_end;
435    mutable_b.erase(mutable_b.begin(), mutable_iter_end);
436    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 2);
437    const_b.verify();
438    mutable_b = b_copy;
439    typename T::iterator mutable_iter_begin = mutable_b.begin();
440    for (int i = 0; i &lt; values.size() / 2; ++i) ++mutable_iter_begin;
441    mutable_b.erase(mutable_iter_begin, mutable_b.end());
442    EXPECT_EQ(mutable_b.size(), values.size() / 2);
443    const_b.verify();
444    mutable_b = b_copy;
445    mutable_iter_begin = mutable_b.begin();
446    for (int i = 0; i &lt; values.size() / 4; ++i) ++mutable_iter_begin;
447    mutable_iter_end = mutable_iter_begin;
448    for (int i = 0; i &lt; values.size() / 4; ++i) ++mutable_iter_end;
449    mutable_b.erase(mutable_iter_begin, mutable_iter_end);
450    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 4);
451    const_b.verify();
452    mutable_b.clear();
453  }
454  template &lt;typename T&gt;
455  void ConstTest() {
456    using value_type = typename T::value_type;
457    typename KeyOfValue&lt;typename T::key_type, value_type&gt;::type key_of_value;
458    T mutable_b;
459    const T &amp;const_b = mutable_b;
460    value_type value = Generator&lt;value_type&gt;(2)(2);
461    mutable_b.insert(value);
462    EXPECT_TRUE(mutable_b.contains(key_of_value(value)));
463    EXPECT_NE(mutable_b.find(key_of_value(value)), const_b.end());
464    EXPECT_TRUE(const_b.contains(key_of_value(value)));
465    EXPECT_NE(const_b.find(key_of_value(value)), mutable_b.end());
466    EXPECT_EQ(*const_b.lower_bound(key_of_value(value)), value);
467    EXPECT_EQ(const_b.upper_bound(key_of_value(value)), const_b.end());
468    EXPECT_EQ(*const_b.equal_range(key_of_value(value)).first, value);
469    typename T::iterator mutable_iter(mutable_b.begin());
470    EXPECT_EQ(mutable_iter, const_b.begin());
471    EXPECT_NE(mutable_iter, const_b.end());
472    EXPECT_EQ(const_b.begin(), mutable_iter);
473    EXPECT_NE(const_b.end(), mutable_iter);
474    typename T::reverse_iterator mutable_riter(mutable_b.rbegin());
475    EXPECT_EQ(mutable_riter, const_b.rbegin());
476    EXPECT_NE(mutable_riter, const_b.rend());
477    EXPECT_EQ(const_b.rbegin(), mutable_riter);
478    EXPECT_NE(const_b.rend(), mutable_riter);
479    typename T::const_iterator const_iter(mutable_iter);
480    EXPECT_EQ(const_iter, mutable_b.begin());
481    EXPECT_NE(const_iter, mutable_b.end());
482    EXPECT_EQ(mutable_b.begin(), const_iter);
483    EXPECT_NE(mutable_b.end(), const_iter);
484    typename T::const_reverse_iterator const_riter(mutable_riter);
485    EXPECT_EQ(const_riter, mutable_b.rbegin());
486    EXPECT_NE(const_riter, mutable_b.rend());
487    EXPECT_EQ(mutable_b.rbegin(), const_riter);
488    EXPECT_NE(mutable_b.rend(), const_riter);
489    const_b.verify();
490    ASSERT_TRUE(!const_b.empty());
491    EXPECT_EQ(const_b.size(), 1);
492    EXPECT_GT(const_b.max_size(), 0);
493    EXPECT_TRUE(const_b.contains(key_of_value(value)));
494    EXPECT_EQ(const_b.count(key_of_value(value)), 1);
495  }
496  template &lt;typename T, typename C&gt;
497  void BtreeTest() {
498    ConstTest&lt;T&gt;();
499    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
500    const std::vector&lt;V&gt; random_values = GenerateValuesWithSeed&lt;V&gt;(
501        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
502        GTEST_FLAG_GET(random_seed));
503    unique_checker&lt;T, C&gt; container;
504    std::vector&lt;V&gt; sorted_values(random_values);
505    std::sort(sorted_values.begin(), sorted_values.end());
506    DoTest(&quot;sorted:    &quot;, &amp;container, sorted_values);
507    std::reverse(sorted_values.begin(), sorted_values.end());
508    DoTest(&quot;rsorted:   &quot;, &amp;container, sorted_values);
509    DoTest(&quot;random:    &quot;, &amp;container, random_values);
510  }
511  template &lt;typename T, typename C&gt;
512  void BtreeMultiTest() {
513    ConstTest&lt;T&gt;();
514    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
515    const std::vector&lt;V&gt; random_values = GenerateValuesWithSeed&lt;V&gt;(
516        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
517        GTEST_FLAG_GET(random_seed));
518    multi_checker&lt;T, C&gt; container;
519    std::vector&lt;V&gt; sorted_values(random_values);
520    std::sort(sorted_values.begin(), sorted_values.end());
521    DoTest(&quot;sorted:    &quot;, &amp;container, sorted_values);
522    std::reverse(sorted_values.begin(), sorted_values.end());
523    DoTest(&quot;rsorted:   &quot;, &amp;container, sorted_values);
524    DoTest(&quot;random:    &quot;, &amp;container, random_values);
525    std::vector&lt;V&gt; duplicate_values(random_values);
526    duplicate_values.insert(duplicate_values.end(), random_values.begin(),
527                            random_values.end());
528    DoTest(&quot;duplicates:&quot;, &amp;container, duplicate_values);
529    std::vector&lt;V&gt; identical_values(100);
530    std::fill(identical_values.begin(), identical_values.end(),
531              Generator&lt;V&gt;(2)(2));
532    DoTest(&quot;identical: &quot;, &amp;container, identical_values);
533  }
534  template &lt;typename T&gt;
535  struct PropagatingCountingAlloc : public CountingAllocator&lt;T&gt; {
536    using propagate_on_container_copy_assignment = std::true_type;
537    using propagate_on_container_move_assignment = std::true_type;
538    using propagate_on_container_swap = std::true_type;
539    using Base = CountingAllocator&lt;T&gt;;
540    using Base::Base;
541    template &lt;typename U&gt;
542    explicit PropagatingCountingAlloc(const PropagatingCountingAlloc&lt;U&gt; &amp;other)
543        : Base(other.bytes_used_) {}
544    template &lt;typename U&gt;
545    struct rebind {
546      using other = PropagatingCountingAlloc&lt;U&gt;;
547    };
548  };
549  template &lt;typename T&gt;
550  void BtreeAllocatorTest() {
551    using value_type = typename T::value_type;
552    int64_t bytes1 = 0, bytes2 = 0;
553    PropagatingCountingAlloc&lt;T&gt; allocator1(&amp;bytes1);
554    PropagatingCountingAlloc&lt;T&gt; allocator2(&amp;bytes2);
555    Generator&lt;value_type&gt; generator(1000);
556    auto unused1 = allocator1.allocate(1);
557    auto unused2 = allocator2.allocate(1);
558    {
559      T b1(typename T::key_compare(), allocator1);
560      T b2(typename T::key_compare(), allocator2);
561      int64_t original_bytes1 = bytes1;
562      b1.insert(generator(0));
563      EXPECT_GT(bytes1, original_bytes1);
564      b1 = b2;
565      EXPECT_EQ(b1.size(), 0);
566      EXPECT_EQ(b2.size(), 0);
567      EXPECT_EQ(bytes1, original_bytes1);
568      for (int i = 1; i &lt; 1000; i++) {
569        b1.insert(generator(i));
570      }
571      EXPECT_GT(bytes2, bytes1);
572    }
573    {
574      T b1(typename T::key_compare(), allocator1);
575      T b2(typename T::key_compare(), allocator2);
576      int64_t original_bytes1 = bytes1;
577      b1.insert(generator(0));
578      EXPECT_GT(bytes1, original_bytes1);
579      b1 = std::move(b2);
580      EXPECT_EQ(b1.size(), 0);
581      EXPECT_EQ(bytes1, original_bytes1);
582      for (int i = 1; i &lt; 1000; i++) {
583        b1.insert(generator(i));
584      }
585      EXPECT_GT(bytes2, bytes1);
586    }
587    {
588      T b1(typename T::key_compare(), allocator1);
589      T b2(typename T::key_compare(), allocator2);
590      int64_t original_bytes1 = bytes1;
591      b1.insert(generator(0));
592      EXPECT_GT(bytes1, original_bytes1);
593      swap(b1, b2);
594      EXPECT_EQ(b1.size(), 0);
595      EXPECT_EQ(b2.size(), 1);
596      EXPECT_GT(bytes1, original_bytes1);
597      for (int i = 1; i &lt; 1000; i++) {
598        b1.insert(generator(i));
599      }
600      EXPECT_GT(bytes2, bytes1);
601    }
602    allocator1.deallocate(unused1, 1);
603    allocator2.deallocate(unused2, 1);
604  }
605  template &lt;typename T&gt;
606  void BtreeMapTest() {
607    using value_type = typename T::value_type;
608    using mapped_type = typename T::mapped_type;
609    mapped_type m = Generator&lt;mapped_type&gt;(0)(0);
610    (void)m;
611    T b;
612    for (int i = 0; i &lt; 1000; i++) {
613      value_type v = Generator&lt;value_type&gt;(1000)(i);
614      b[v.first] = v.second;
615    }
616    EXPECT_EQ(b.size(), 1000);
617    EXPECT_EQ(b.begin()-&gt;first, Generator&lt;value_type&gt;(1000)(0).first);
618    EXPECT_EQ(b.begin()-&gt;second, Generator&lt;value_type&gt;(1000)(0).second);
619    EXPECT_EQ(b.rbegin()-&gt;first, Generator&lt;value_type&gt;(1000)(999).first);
620    EXPECT_EQ(b.rbegin()-&gt;second, Generator&lt;value_type&gt;(1000)(999).second);
621  }
622  template &lt;typename T&gt;
623  void BtreeMultiMapTest() {
624    using mapped_type = typename T::mapped_type;
625    mapped_type m = Generator&lt;mapped_type&gt;(0)(0);
626    (void)m;
627  }
628  template &lt;typename K, int N = 256&gt;
629  void SetTest() {
630    EXPECT_EQ(
631        sizeof(absl::btree_set&lt;K&gt;),
632        2 * sizeof(void *) + sizeof(typename absl::btree_set&lt;K&gt;::size_type));
633    using BtreeSet = absl::btree_set&lt;K&gt;;
634    using CountingBtreeSet =
635        absl::btree_set&lt;K, std::less&lt;K&gt;, PropagatingCountingAlloc&lt;K&gt;&gt;;
636    BtreeTest&lt;BtreeSet, std::set&lt;K&gt;&gt;();
637    BtreeAllocatorTest&lt;CountingBtreeSet&gt;();
638  }
639  template &lt;typename K, int N = 256&gt;
640  void MapTest() {
641    EXPECT_EQ(
642        sizeof(absl::btree_map&lt;K, K&gt;),
643        2 * sizeof(void *) + sizeof(typename absl::btree_map&lt;K, K&gt;::size_type));
644    using BtreeMap = absl::btree_map&lt;K, K&gt;;
645    using CountingBtreeMap =
646        absl::btree_map&lt;K, K, std::less&lt;K&gt;,
647                        PropagatingCountingAlloc&lt;std::pair&lt;const K, K&gt;&gt;&gt;;
648    BtreeTest&lt;BtreeMap, std::map&lt;K, K&gt;&gt;();
649    BtreeAllocatorTest&lt;CountingBtreeMap&gt;();
650    BtreeMapTest&lt;BtreeMap&gt;();
651  }
652  TEST(Btree, set_int32) { SetTest&lt;int32_t&gt;(); }
653  TEST(Btree, set_int64) { SetTest&lt;int64_t&gt;(); }
654  TEST(Btree, set_string) { SetTest&lt;std::string&gt;(); }
655  TEST(Btree, set_cord) { SetTest&lt;absl::Cord&gt;(); }
656  TEST(Btree, set_pair) { SetTest&lt;std::pair&lt;int, int&gt;&gt;(); }
657  TEST(Btree, map_int32) { MapTest&lt;int32_t&gt;(); }
658  TEST(Btree, map_int64) { MapTest&lt;int64_t&gt;(); }
659  TEST(Btree, map_string) { MapTest&lt;std::string&gt;(); }
660  TEST(Btree, map_cord) { MapTest&lt;absl::Cord&gt;(); }
661  TEST(Btree, map_pair) { MapTest&lt;std::pair&lt;int, int&gt;&gt;(); }
662  template &lt;typename K, int N = 256&gt;
663  void MultiSetTest() {
664    EXPECT_EQ(
665        sizeof(absl::btree_multiset&lt;K&gt;),
666        2 * sizeof(void *) + sizeof(typename absl::btree_multiset&lt;K&gt;::size_type));
667    using BtreeMSet = absl::btree_multiset&lt;K&gt;;
668    using CountingBtreeMSet =
669        absl::btree_multiset&lt;K, std::less&lt;K&gt;, PropagatingCountingAlloc&lt;K&gt;&gt;;
670    BtreeMultiTest&lt;BtreeMSet, std::multiset&lt;K&gt;&gt;();
671    BtreeAllocatorTest&lt;CountingBtreeMSet&gt;();
672  }
673  template &lt;typename K, int N = 256&gt;
674  void MultiMapTest() {
675    EXPECT_EQ(sizeof(absl::btree_multimap&lt;K, K&gt;),
676              2 * sizeof(void *) +
677                  sizeof(typename absl::btree_multimap&lt;K, K&gt;::size_type));
678    using BtreeMMap = absl::btree_multimap&lt;K, K&gt;;
679    using CountingBtreeMMap =
680        absl::btree_multimap&lt;K, K, std::less&lt;K&gt;,
681                             PropagatingCountingAlloc&lt;std::pair&lt;const K, K&gt;&gt;&gt;;
682    BtreeMultiTest&lt;BtreeMMap, std::multimap&lt;K, K&gt;&gt;();
683    BtreeMultiMapTest&lt;BtreeMMap&gt;();
684    BtreeAllocatorTest&lt;CountingBtreeMMap&gt;();
685  }
686  TEST(Btree, multiset_int32) { MultiSetTest&lt;int32_t&gt;(); }
687  TEST(Btree, multiset_int64) { MultiSetTest&lt;int64_t&gt;(); }
688  TEST(Btree, multiset_string) { MultiSetTest&lt;std::string&gt;(); }
689  TEST(Btree, multiset_cord) { MultiSetTest&lt;absl::Cord&gt;(); }
690  TEST(Btree, multiset_pair) { MultiSetTest&lt;std::pair&lt;int, int&gt;&gt;(); }
691  TEST(Btree, multimap_int32) { MultiMapTest&lt;int32_t&gt;(); }
692  TEST(Btree, multimap_int64) { MultiMapTest&lt;int64_t&gt;(); }
693  TEST(Btree, multimap_string) { MultiMapTest&lt;std::string&gt;(); }
694  TEST(Btree, multimap_cord) { MultiMapTest&lt;absl::Cord&gt;(); }
695  TEST(Btree, multimap_pair) { MultiMapTest&lt;std::pair&lt;int, int&gt;&gt;(); }
696  struct CompareIntToString {
697    bool operator()(const std::string &amp;a, const std::string &amp;b) const {
698      return a &lt; b;
699    }
700    bool operator()(const std::string &amp;a, int b) const {
701      return a &lt; absl::StrCat(b);
702    }
703    bool operator()(int a, const std::string &amp;b) const {
704      return absl::StrCat(a) &lt; b;
705    }
706    using is_transparent = void;
707  };
708  struct NonTransparentCompare {
709    template &lt;typename T, typename U&gt;
710    bool operator()(const T &amp;t, const U &amp;u) const {
711      EXPECT_TRUE((std::is_same&lt;T, U&gt;()));
712      return t &lt; u;
713    }
714  };
715  template &lt;typename T&gt;
716  bool CanEraseWithEmptyBrace(T t, decltype(t.erase({})) *) {
717    return true;
718  }
719  template &lt;typename T&gt;
720  bool CanEraseWithEmptyBrace(T, ...) {
721    return false;
722  }
723  template &lt;typename T&gt;
724  void TestHeterogeneous(T table) {
725    auto lb = table.lower_bound(&quot;3&quot;);
726    EXPECT_EQ(lb, table.lower_bound(3));
727    EXPECT_NE(lb, table.lower_bound(4));
728    EXPECT_EQ(lb, table.lower_bound({&quot;3&quot;}));
729    EXPECT_NE(lb, table.lower_bound({}));
730    auto ub = table.upper_bound(&quot;3&quot;);
731    EXPECT_EQ(ub, table.upper_bound(3));
732    EXPECT_NE(ub, table.upper_bound(5));
733    EXPECT_EQ(ub, table.upper_bound({&quot;3&quot;}));
734    EXPECT_NE(ub, table.upper_bound({}));
735    auto er = table.equal_range(&quot;3&quot;);
736    EXPECT_EQ(er, table.equal_range(3));
737    EXPECT_NE(er, table.equal_range(4));
738    EXPECT_EQ(er, table.equal_range({&quot;3&quot;}));
739    EXPECT_NE(er, table.equal_range({}));
740    auto it = table.find(&quot;3&quot;);
741    EXPECT_EQ(it, table.find(3));
742    EXPECT_NE(it, table.find(4));
743    EXPECT_EQ(it, table.find({&quot;3&quot;}));
744    EXPECT_NE(it, table.find({}));
745    EXPECT_TRUE(table.contains(3));
746    EXPECT_FALSE(table.contains(4));
747    EXPECT_TRUE(table.count({&quot;3&quot;}));
748    EXPECT_FALSE(table.contains({}));
749    EXPECT_EQ(1, table.count(3));
750    EXPECT_EQ(0, table.count(4));
751    EXPECT_EQ(1, table.count({&quot;3&quot;}));
752    EXPECT_EQ(0, table.count({}));
753    auto copy = table;
754    copy.erase(3);
755    EXPECT_EQ(table.size() - 1, copy.size());
756    copy.erase(4);
757    EXPECT_EQ(table.size() - 1, copy.size());
758    copy.erase({&quot;5&quot;});
759    EXPECT_EQ(table.size() - 2, copy.size());
760    EXPECT_FALSE(CanEraseWithEmptyBrace(table, nullptr));
761    if (std::is_class&lt;T&gt;()) TestHeterogeneous&lt;const T &amp;&gt;(table);
762  }
763  TEST(Btree, HeterogeneousLookup) {
764    TestHeterogeneous(btree_set&lt;std::string, CompareIntToString&gt;{&quot;1&quot;, &quot;3&quot;, &quot;5&quot;});
765    TestHeterogeneous(btree_map&lt;std::string, int, CompareIntToString&gt;{
766        {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}});
767    TestHeterogeneous(
768        btree_multiset&lt;std::string, CompareIntToString&gt;{&quot;1&quot;, &quot;3&quot;, &quot;5&quot;});
769    TestHeterogeneous(btree_multimap&lt;std::string, int, CompareIntToString&gt;{
770        {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}});
771    btree_map&lt;std::string, int, CompareIntToString&gt; map{
772        {&quot;&quot;, -1}, {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}};
773    EXPECT_EQ(1, map.at(1));
774    EXPECT_EQ(3, map.at({&quot;3&quot;}));
775    EXPECT_EQ(-1, map.at({}));
776    const auto &amp;cmap = map;
777    EXPECT_EQ(1, cmap.at(1));
778    EXPECT_EQ(3, cmap.at({&quot;3&quot;}));
779    EXPECT_EQ(-1, cmap.at({}));
780  }
781  TEST(Btree, NoHeterogeneousLookupWithoutAlias) {
782    using StringSet = absl::btree_set&lt;std::string, NonTransparentCompare&gt;;
783    StringSet s;
784    ASSERT_TRUE(s.insert(&quot;hello&quot;).second);
785    ASSERT_TRUE(s.insert(&quot;world&quot;).second);
786    EXPECT_TRUE(s.end() == s.find(&quot;blah&quot;));
787    EXPECT_TRUE(s.begin() == s.lower_bound(&quot;hello&quot;));
788    EXPECT_EQ(1, s.count(&quot;world&quot;));
789    EXPECT_TRUE(s.contains(&quot;hello&quot;));
790    EXPECT_TRUE(s.contains(&quot;world&quot;));
791    EXPECT_FALSE(s.contains(&quot;blah&quot;));
792    using StringMultiSet =
793        absl::btree_multiset&lt;std::string, NonTransparentCompare&gt;;
794    StringMultiSet ms;
795    ms.insert(&quot;hello&quot;);
796    ms.insert(&quot;world&quot;);
797    ms.insert(&quot;world&quot;);
798    EXPECT_TRUE(ms.end() == ms.find(&quot;blah&quot;));
799    EXPECT_TRUE(ms.begin() == ms.lower_bound(&quot;hello&quot;));
800    EXPECT_EQ(2, ms.count(&quot;world&quot;));
801    EXPECT_TRUE(ms.contains(&quot;hello&quot;));
802    EXPECT_TRUE(ms.contains(&quot;world&quot;));
803    EXPECT_FALSE(ms.contains(&quot;blah&quot;));
804  }
805  TEST(Btree, DefaultTransparent) {
806    {
807      btree_set&lt;int&gt; s = {1};
808      double d = 1.1;
809      EXPECT_EQ(s.begin(), s.find(d));
810      EXPECT_TRUE(s.contains(d));
811    }
812    {
813      btree_set&lt;std::string&gt; s = {&quot;A&quot;};
814      EXPECT_EQ(s.begin(), s.find(absl::string_view(&quot;A&quot;)));
815      EXPECT_TRUE(s.contains(absl::string_view(&quot;A&quot;)));
816    }
817  }
818  class StringLike {
819   public:
820    StringLike() = default;
821    StringLike(const char *s) : s_(s) {  
822      ++constructor_calls_;
823    }
824    bool operator&lt;(const StringLike &amp;a) const { return s_ &lt; a.s_; }
825    static void clear_constructor_call_count() { constructor_calls_ = 0; }
826    static int constructor_calls() { return constructor_calls_; }
827   private:
828    static int constructor_calls_;
829    std::string s_;
830  };
831  int StringLike::constructor_calls_ = 0;
832  TEST(Btree, HeterogeneousLookupDoesntDegradePerformance) {
833    using StringSet = absl::btree_set&lt;StringLike&gt;;
834    StringSet s;
835    for (int i = 0; i &lt; 100; ++i) {
836      ASSERT_TRUE(s.insert(absl::StrCat(i).c_str()).second);
837    }
838    StringLike::clear_constructor_call_count();
839    s.find(&quot;50&quot;);
840    ASSERT_EQ(1, StringLike::constructor_calls());
841    StringLike::clear_constructor_call_count();
842    s.contains(&quot;50&quot;);
843    ASSERT_EQ(1, StringLike::constructor_calls());
844    StringLike::clear_constructor_call_count();
845    s.count(&quot;50&quot;);
846    ASSERT_EQ(1, StringLike::constructor_calls());
847    StringLike::clear_constructor_call_count();
848    s.lower_bound(&quot;50&quot;);
849    ASSERT_EQ(1, StringLike::constructor_calls());
850    StringLike::clear_constructor_call_count();
851    s.upper_bound(&quot;50&quot;);
852    ASSERT_EQ(1, StringLike::constructor_calls());
853    StringLike::clear_constructor_call_count();
854    s.equal_range(&quot;50&quot;);
855    ASSERT_EQ(1, StringLike::constructor_calls());
856    StringLike::clear_constructor_call_count();
857    s.erase(&quot;50&quot;);
858    ASSERT_EQ(1, StringLike::constructor_calls());
859  }
860  struct SubstringLess {
861    SubstringLess() = delete;
862    explicit SubstringLess(int length) : n(length) {}
863    bool operator()(const std::string &amp;a, const std::string &amp;b) const {
864      return absl::string_view(a).substr(0, n) &lt;
865             absl::string_view(b).substr(0, n);
866    }
867    int n;
868  };
869  TEST(Btree, SwapKeyCompare) {
870    using SubstringSet = absl::btree_set&lt;std::string, SubstringLess&gt;;
871    SubstringSet s1(SubstringLess(1), SubstringSet::allocator_type());
872    SubstringSet s2(SubstringLess(2), SubstringSet::allocator_type());
873    ASSERT_TRUE(s1.insert(&quot;a&quot;).second);
874    ASSERT_FALSE(s1.insert(&quot;aa&quot;).second);
875    ASSERT_TRUE(s2.insert(&quot;a&quot;).second);
876    ASSERT_TRUE(s2.insert(&quot;aa&quot;).second);
877    ASSERT_FALSE(s2.insert(&quot;aaa&quot;).second);
878    swap(s1, s2);
879    ASSERT_TRUE(s1.insert(&quot;b&quot;).second);
880    ASSERT_TRUE(s1.insert(&quot;bb&quot;).second);
881    ASSERT_FALSE(s1.insert(&quot;bbb&quot;).second);
882    ASSERT_TRUE(s2.insert(&quot;b&quot;).second);
883    ASSERT_FALSE(s2.insert(&quot;bb&quot;).second);
884  }
885  TEST(Btree, UpperBoundRegression) {
886    using SubstringSet = absl::btree_set&lt;std::string, SubstringLess&gt;;
887    SubstringSet my_set(SubstringLess(3));
888    my_set.insert(&quot;aab&quot;);
889    my_set.insert(&quot;abb&quot;);
890    SubstringSet::iterator it = my_set.upper_bound(&quot;aaa&quot;);
891    ASSERT_TRUE(it != my_set.end());
892    EXPECT_EQ(&quot;aab&quot;, *it);
893  }
894  TEST(Btree, Comparison) {
895    const int kSetSize = 1201;
896    absl::btree_set&lt;int64_t&gt; my_set;
897    for (int i = 0; i &lt; kSetSize; ++i) {
898      my_set.insert(i);
899    }
900    absl::btree_set&lt;int64_t&gt; my_set_copy(my_set);
901    EXPECT_TRUE(my_set_copy == my_set);
902    EXPECT_TRUE(my_set == my_set_copy);
903    EXPECT_FALSE(my_set_copy != my_set);
904    EXPECT_FALSE(my_set != my_set_copy);
905    my_set.insert(kSetSize);
906    EXPECT_FALSE(my_set_copy == my_set);
907    EXPECT_FALSE(my_set == my_set_copy);
908    EXPECT_TRUE(my_set_copy != my_set);
909    EXPECT_TRUE(my_set != my_set_copy);
910    my_set.erase(kSetSize - 1);
911    EXPECT_FALSE(my_set_copy == my_set);
912    EXPECT_FALSE(my_set == my_set_copy);
913    EXPECT_TRUE(my_set_copy != my_set);
914    EXPECT_TRUE(my_set != my_set_copy);
915    absl::btree_map&lt;std::string, int64_t&gt; my_map;
916    for (int i = 0; i &lt; kSetSize; ++i) {
917      my_map[std::string(i, &#x27;a&#x27;)] = i;
918    }
919    absl::btree_map&lt;std::string, int64_t&gt; my_map_copy(my_map);
920    EXPECT_TRUE(my_map_copy == my_map);
921    EXPECT_TRUE(my_map == my_map_copy);
922    EXPECT_FALSE(my_map_copy != my_map);
923    EXPECT_FALSE(my_map != my_map_copy);
924    ++my_map_copy[std::string(7, &#x27;a&#x27;)];
925    EXPECT_FALSE(my_map_copy == my_map);
926    EXPECT_FALSE(my_map == my_map_copy);
927    EXPECT_TRUE(my_map_copy != my_map);
928    EXPECT_TRUE(my_map != my_map_copy);
929    my_map_copy = my_map;
930    my_map[&quot;hello&quot;] = kSetSize;
931    EXPECT_FALSE(my_map_copy == my_map);
932    EXPECT_FALSE(my_map == my_map_copy);
933    EXPECT_TRUE(my_map_copy != my_map);
934    EXPECT_TRUE(my_map != my_map_copy);
935    my_map.erase(std::string(kSetSize - 1, &#x27;a&#x27;));
936    EXPECT_FALSE(my_map_copy == my_map);
937    EXPECT_FALSE(my_map == my_map_copy);
938    EXPECT_TRUE(my_map_copy != my_map);
939    EXPECT_TRUE(my_map != my_map_copy);
940  }
941  TEST(Btree, RangeCtorSanity) {
942    std::vector&lt;int&gt; ivec;
943    ivec.push_back(1);
944    std::map&lt;int, int&gt; imap;
945    imap.insert(std::make_pair(1, 2));
946    absl::btree_multiset&lt;int&gt; tmset(ivec.begin(), ivec.end());
947    absl::btree_multimap&lt;int, int&gt; tmmap(imap.begin(), imap.end());
948    absl::btree_set&lt;int&gt; tset(ivec.begin(), ivec.end());
949    absl::btree_map&lt;int, int&gt; tmap(imap.begin(), imap.end());
950    EXPECT_EQ(1, tmset.size());
951    EXPECT_EQ(1, tmmap.size());
952    EXPECT_EQ(1, tset.size());
953    EXPECT_EQ(1, tmap.size());
954  }
955  }  
956  class BtreeNodePeer {
957   public:
958    template &lt;typename ValueType&gt;
959    constexpr static size_t GetTargetNodeSize(size_t target_values_per_node) {
960      return btree_node&lt;
961          set_params&lt;ValueType, std::less&lt;ValueType&gt;, std::allocator&lt;ValueType&gt;,
962                     256,  
963                     false&gt;&gt;::SizeWithNSlots(target_values_per_node);
964    }
965    template &lt;typename Btree&gt;
966    constexpr static size_t GetNumSlotsPerNode() {
967      return btree_node&lt;typename Btree::params_type&gt;::kNodeSlots;
968    }
969    template &lt;typename Btree&gt;
970    constexpr static size_t GetMaxFieldType() {
971      return std::numeric_limits&lt;
972          typename btree_node&lt;typename Btree::params_type&gt;::field_type&gt;::max();
973    }
974    template &lt;typename Btree&gt;
975    constexpr static bool UsesLinearNodeSearch() {
976      return btree_node&lt;typename Btree::params_type&gt;::use_linear_search::value;
977    }
978    template &lt;typename Btree&gt;
979    constexpr static bool FieldTypeEqualsSlotType() {
980      return std::is_same&lt;
981          typename btree_node&lt;typename Btree::params_type&gt;::field_type,
982          typename btree_node&lt;typename Btree::params_type&gt;::slot_type&gt;::value;
983    }
984  };
985  namespace {
986  class BtreeMapTest : public ::testing::Test {
987   public:
988    struct Key {};
989    struct Cmp {
990      template &lt;typename T&gt;
991      bool operator()(T, T) const {
992        return false;
993      }
994    };
995    struct KeyLin {
996      using absl_btree_prefer_linear_node_search = std::true_type;
997    };
998    struct CmpLin : Cmp {
999      using absl_btree_prefer_linear_node_search = std::true_type;
1000    };
1001    struct KeyBin {
1002      using absl_btree_prefer_linear_node_search = std::false_type;
1003    };
1004    struct CmpBin : Cmp {
1005      using absl_btree_prefer_linear_node_search = std::false_type;
1006    };
1007    template &lt;typename K, typename C&gt;
1008    static bool IsLinear() {
1009      return BtreeNodePeer::UsesLinearNodeSearch&lt;absl::btree_map&lt;K, int, C&gt;&gt;();
1010    }
1011  };
1012  TEST_F(BtreeMapTest, TestLinearSearchPreferredForKeyLinearViaAlias) {
1013    EXPECT_FALSE((IsLinear&lt;Key, Cmp&gt;()));
1014    EXPECT_TRUE((IsLinear&lt;KeyLin, Cmp&gt;()));
1015    EXPECT_TRUE((IsLinear&lt;Key, CmpLin&gt;()));
1016    EXPECT_TRUE((IsLinear&lt;KeyLin, CmpLin&gt;()));
1017  }
1018  TEST_F(BtreeMapTest, LinearChoiceTree) {
1019    EXPECT_FALSE((IsLinear&lt;Key, CmpBin&gt;()));
1020    EXPECT_FALSE((IsLinear&lt;KeyLin, CmpBin&gt;()));
1021    EXPECT_FALSE((IsLinear&lt;KeyBin, CmpBin&gt;()));
1022    EXPECT_FALSE((IsLinear&lt;int, CmpBin&gt;()));
1023    EXPECT_FALSE((IsLinear&lt;std::string, CmpBin&gt;()));
1024    EXPECT_TRUE((IsLinear&lt;Key, CmpLin&gt;()));
1025    EXPECT_TRUE((IsLinear&lt;KeyLin, CmpLin&gt;()));
1026    EXPECT_TRUE((IsLinear&lt;KeyBin, CmpLin&gt;()));
1027    EXPECT_TRUE((IsLinear&lt;int, CmpLin&gt;()));
1028    EXPECT_TRUE((IsLinear&lt;std::string, CmpLin&gt;()));
1029    EXPECT_FALSE((IsLinear&lt;Key, Cmp&gt;()));
1030    EXPECT_TRUE((IsLinear&lt;KeyLin, Cmp&gt;()));
1031    EXPECT_FALSE((IsLinear&lt;KeyBin, Cmp&gt;()));
1032    EXPECT_TRUE((IsLinear&lt;int, std::less&lt;int&gt;&gt;()));
1033    EXPECT_TRUE((IsLinear&lt;double, std::greater&lt;double&gt;&gt;()));
1034    EXPECT_FALSE((IsLinear&lt;int, Cmp&gt;()));
1035    EXPECT_FALSE((IsLinear&lt;std::string, std::less&lt;std::string&gt;&gt;()));
1036  }
1037  TEST(Btree, BtreeMapCanHoldMoveOnlyTypes) {
1038    absl::btree_map&lt;std::string, std::unique_ptr&lt;std::string&gt;&gt; m;
1039    std::unique_ptr&lt;std::string&gt; &amp;v = m[&quot;A&quot;];
1040    EXPECT_TRUE(v == nullptr);
1041    v = absl::make_unique&lt;std::string&gt;(&quot;X&quot;);
1042    auto iter = m.find(&quot;A&quot;);
1043    EXPECT_EQ(&quot;X&quot;, *iter-&gt;second);
1044  }
1045  TEST(Btree, InitializerListConstructor) {
1046    absl::btree_set&lt;std::string&gt; set({&quot;a&quot;, &quot;b&quot;});
1047    EXPECT_EQ(set.count(&quot;a&quot;), 1);
1048    EXPECT_EQ(set.count(&quot;b&quot;), 1);
1049    absl::btree_multiset&lt;int&gt; mset({1, 1, 4});
1050    EXPECT_EQ(mset.count(1), 2);
1051    EXPECT_EQ(mset.count(4), 1);
1052    absl::btree_map&lt;int, int&gt; map({{1, 5}, {2, 10}});
1053    EXPECT_EQ(map[1], 5);
1054    EXPECT_EQ(map[2], 10);
1055    absl::btree_multimap&lt;int, int&gt; mmap({{1, 5}, {1, 10}});
1056    auto range = mmap.equal_range(1);
1057    auto it = range.first;
1058    ASSERT_NE(it, range.second);
1059    EXPECT_EQ(it-&gt;second, 5);
1060    ASSERT_NE(++it, range.second);
1061    EXPECT_EQ(it-&gt;second, 10);
1062    EXPECT_EQ(++it, range.second);
1063  }
1064  TEST(Btree, InitializerListInsert) {
1065    absl::btree_set&lt;std::string&gt; set;
1066    set.insert({&quot;a&quot;, &quot;b&quot;});
1067    EXPECT_EQ(set.count(&quot;a&quot;), 1);
1068    EXPECT_EQ(set.count(&quot;b&quot;), 1);
1069    absl::btree_multiset&lt;int&gt; mset;
1070    mset.insert({1, 1, 4});
1071    EXPECT_EQ(mset.count(1), 2);
1072    EXPECT_EQ(mset.count(4), 1);
1073    absl::btree_map&lt;int, int&gt; map;
1074    map.insert({{1, 5}, {2, 10}});
1075    map.insert({3, 15});
1076    EXPECT_EQ(map[1], 5);
1077    EXPECT_EQ(map[2], 10);
1078    EXPECT_EQ(map[3], 15);
1079    absl::btree_multimap&lt;int, int&gt; mmap;
1080    mmap.insert({{1, 5}, {1, 10}});
1081    auto range = mmap.equal_range(1);
1082    auto it = range.first;
1083    ASSERT_NE(it, range.second);
1084    EXPECT_EQ(it-&gt;second, 5);
1085    ASSERT_NE(++it, range.second);
1086    EXPECT_EQ(it-&gt;second, 10);
1087    EXPECT_EQ(++it, range.second);
1088  }
1089  template &lt;typename Compare, typename Key&gt;
1090  void AssertKeyCompareStringAdapted() {
1091    using Adapted = typename key_compare_adapter&lt;Compare, Key&gt;::type;
1092    static_assert(
1093        std::is_same&lt;Adapted, StringBtreeDefaultLess&gt;::value ||
1094            std::is_same&lt;Adapted, StringBtreeDefaultGreater&gt;::value,
1095        &quot;key_compare_adapter should have string-adapted this comparator.&quot;);
1096  }
1097  template &lt;typename Compare, typename Key&gt;
1098  void AssertKeyCompareNotStringAdapted() {
1099    using Adapted = typename key_compare_adapter&lt;Compare, Key&gt;::type;
1100    static_assert(
1101        !std::is_same&lt;Adapted, StringBtreeDefaultLess&gt;::value &amp;&amp;
1102            !std::is_same&lt;Adapted, StringBtreeDefaultGreater&gt;::value,
1103        &quot;key_compare_adapter shouldn&#x27;t have string-adapted this comparator.&quot;);
1104  }
1105  TEST(Btree, KeyCompareAdapter) {
1106    AssertKeyCompareStringAdapted&lt;std::less&lt;std::string&gt;, std::string&gt;();
1107    AssertKeyCompareStringAdapted&lt;std::greater&lt;std::string&gt;, std::string&gt;();
1108    AssertKeyCompareStringAdapted&lt;std::less&lt;absl::string_view&gt;,
1109                                  absl::string_view&gt;();
1110    AssertKeyCompareStringAdapted&lt;std::greater&lt;absl::string_view&gt;,
1111                                  absl::string_view&gt;();
1112    AssertKeyCompareStringAdapted&lt;std::less&lt;absl::Cord&gt;, absl::Cord&gt;();
1113    AssertKeyCompareStringAdapted&lt;std::greater&lt;absl::Cord&gt;, absl::Cord&gt;();
1114    AssertKeyCompareNotStringAdapted&lt;std::less&lt;int&gt;, int&gt;();
1115    AssertKeyCompareNotStringAdapted&lt;std::greater&lt;int&gt;, int&gt;();
1116  }
1117  TEST(Btree, RValueInsert) {
1118    InstanceTracker tracker;
1119    absl::btree_set&lt;MovableOnlyInstance&gt; set;
1120    set.insert(MovableOnlyInstance(1));
1121    set.insert(MovableOnlyInstance(3));
1122    MovableOnlyInstance two(2);
1123    set.insert(set.find(MovableOnlyInstance(3)), std::move(two));
1124    auto it = set.find(MovableOnlyInstance(2));
1125    ASSERT_NE(it, set.end());
1126    ASSERT_NE(++it, set.end());
1127    EXPECT_EQ(it-&gt;value(), 3);
1128    absl::btree_multiset&lt;MovableOnlyInstance&gt; mset;
1129    MovableOnlyInstance zero(0);
1130    MovableOnlyInstance zero2(0);
1131    mset.insert(std::move(zero));
1132    mset.insert(mset.find(MovableOnlyInstance(0)), std::move(zero2));
1133    EXPECT_EQ(mset.count(MovableOnlyInstance(0)), 2);
1134    absl::btree_map&lt;int, MovableOnlyInstance&gt; map;
1135    std::pair&lt;const int, MovableOnlyInstance&gt; p1 = {1, MovableOnlyInstance(5)};
1136    std::pair&lt;const int, MovableOnlyInstance&gt; p2 = {2, MovableOnlyInstance(10)};
1137    std::pair&lt;const int, MovableOnlyInstance&gt; p3 = {3, MovableOnlyInstance(15)};
1138    map.insert(std::move(p1));
1139    map.insert(std::move(p3));
1140    map.insert(map.find(3), std::move(p2));
1141    ASSERT_NE(map.find(2), map.end());
1142    EXPECT_EQ(map.find(2)-&gt;second.value(), 10);
1143    absl::btree_multimap&lt;int, MovableOnlyInstance&gt; mmap;
1144    std::pair&lt;const int, MovableOnlyInstance&gt; p4 = {1, MovableOnlyInstance(5)};
1145    std::pair&lt;const int, MovableOnlyInstance&gt; p5 = {1, MovableOnlyInstance(10)};
1146    mmap.insert(std::move(p4));
1147    mmap.insert(mmap.find(1), std::move(p5));
1148    auto range = mmap.equal_range(1);
1149    auto it1 = range.first;
1150    ASSERT_NE(it1, range.second);
1151    EXPECT_EQ(it1-&gt;second.value(), 10);
1152    ASSERT_NE(++it1, range.second);
1153    EXPECT_EQ(it1-&gt;second.value(), 5);
1154    EXPECT_EQ(++it1, range.second);
1155    EXPECT_EQ(tracker.copies(), 0);
1156    EXPECT_EQ(tracker.swaps(), 0);
1157  }
1158  template &lt;typename Cmp&gt;
1159  struct CheckedCompareOptedOutCmp : Cmp, BtreeTestOnlyCheckedCompareOptOutBase {
1160    using Cmp::Cmp;
1161    CheckedCompareOptedOutCmp() {}
1162    CheckedCompareOptedOutCmp(Cmp cmp) : Cmp(std::move(cmp)) {}  
1163  };
1164  template &lt;typename Key, int TargetValuesPerNode, typename Cmp = std::less&lt;Key&gt;&gt;
1165  class SizedBtreeSet
1166      : public btree_set_container&lt;btree&lt;
1167            set_params&lt;Key, CheckedCompareOptedOutCmp&lt;Cmp&gt;, std::allocator&lt;Key&gt;,
1168                       BtreeNodePeer::GetTargetNodeSize&lt;Key&gt;(TargetValuesPerNode),
1169                       false&gt;&gt;&gt; {
1170    using Base = typename SizedBtreeSet::btree_set_container;
1171   public:
1172    SizedBtreeSet() = default;
1173    using Base::Base;
1174  };
1175  template &lt;typename Set&gt;
1176  void ExpectOperationCounts(const int expected_moves,
1177                             const int expected_comparisons,
1178                             const std::vector&lt;int&gt; &amp;values,
1179                             InstanceTracker *tracker, Set *set) {
1180    for (const int v : values) set-&gt;insert(MovableOnlyInstance(v));
1181    set-&gt;clear();
1182    EXPECT_EQ(tracker-&gt;moves(), expected_moves);
1183    EXPECT_EQ(tracker-&gt;comparisons(), expected_comparisons);
1184    EXPECT_EQ(tracker-&gt;copies(), 0);
1185    EXPECT_EQ(tracker-&gt;swaps(), 0);
1186    tracker-&gt;ResetCopiesMovesSwaps();
1187  }
1188  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
1189  constexpr bool kAsan = true;
1190  #else
1191  constexpr bool kAsan = false;
1192  #endif
1193  TEST(Btree, MovesComparisonsCopiesSwapsTracking) {
1194    if (kAsan) GTEST_SKIP() &lt;&lt; &quot;We do extra operations in ASan mode.&quot;;
1195    InstanceTracker tracker;
1196    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/4&gt; set4;
1197    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/61&gt; set61;
1198    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/100&gt; set100;
1199    std::vector&lt;int&gt; values =
1200        GenerateValuesWithSeed&lt;int&gt;(10000, 1 &lt;&lt; 22, &amp;bsol;*seed=*/23);
1201    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set4)&gt;(), 4);
1202    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set61)&gt;(), 61);
1203    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set100)&gt;(), 100);
1204    if (sizeof(void *) == 8) {
1205      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;absl::btree_set&lt;int32_t&gt;&gt;(),
1206                BtreeGenerationsEnabled() ? 60 : 61);
1207    }
1208    ExpectOperationCounts(56540, 134212, values, &amp;tracker, &amp;set4);
1209    ExpectOperationCounts(386718, 129807, values, &amp;tracker, &amp;set61);
1210    ExpectOperationCounts(586761, 130310, values, &amp;tracker, &amp;set100);
1211    std::sort(values.begin(), values.end());
1212    ExpectOperationCounts(24972, 85563, values, &amp;tracker, &amp;set4);
1213    ExpectOperationCounts(20208, 87757, values, &amp;tracker, &amp;set61);
1214    ExpectOperationCounts(20124, 96583, values, &amp;tracker, &amp;set100);
1215    std::reverse(values.begin(), values.end());
1216    ExpectOperationCounts(54949, 127531, values, &amp;tracker, &amp;set4);
1217    ExpectOperationCounts(338813, 118266, values, &amp;tracker, &amp;set61);
1218    ExpectOperationCounts(534529, 125279, values, &amp;tracker, &amp;set100);
1219  }
1220  struct MovableOnlyInstanceThreeWayCompare {
1221    absl::weak_ordering operator()(const MovableOnlyInstance &amp;a,
1222                                   const MovableOnlyInstance &amp;b) const {
1223      return a.compare(b);
1224    }
1225  };
1226  TEST(Btree, MovesComparisonsCopiesSwapsTrackingThreeWayCompare) {
1227    if (kAsan) GTEST_SKIP() &lt;&lt; &quot;We do extra operations in ASan mode.&quot;;
1228    InstanceTracker tracker;
1229    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/4,
1230                  MovableOnlyInstanceThreeWayCompare&gt;
1231        set4;
1232    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/61,
1233                  MovableOnlyInstanceThreeWayCompare&gt;
1234        set61;
1235    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/100,
1236                  MovableOnlyInstanceThreeWayCompare&gt;
1237        set100;
1238    std::vector&lt;int&gt; values =
1239        GenerateValuesWithSeed&lt;int&gt;(10000, 1 &lt;&lt; 22, &amp;bsol;*seed=*/23);
1240    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set4)&gt;(), 4);
1241    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set61)&gt;(), 61);
1242    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set100)&gt;(), 100);
1243    if (sizeof(void *) == 8) {
1244      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;absl::btree_set&lt;int32_t&gt;&gt;(),
1245                BtreeGenerationsEnabled() ? 60 : 61);
1246    }
1247    ExpectOperationCounts(56540, 124221, values, &amp;tracker, &amp;set4);
1248    ExpectOperationCounts(386718, 119816, values, &amp;tracker, &amp;set61);
1249    ExpectOperationCounts(586761, 120319, values, &amp;tracker, &amp;set100);
1250    std::sort(values.begin(), values.end());
1251    ExpectOperationCounts(24972, 85563, values, &amp;tracker, &amp;set4);
1252    ExpectOperationCounts(20208, 87757, values, &amp;tracker, &amp;set61);
1253    ExpectOperationCounts(20124, 96583, values, &amp;tracker, &amp;set100);
1254    std::reverse(values.begin(), values.end());
1255    ExpectOperationCounts(54949, 117532, values, &amp;tracker, &amp;set4);
1256    ExpectOperationCounts(338813, 108267, values, &amp;tracker, &amp;set61);
1257    ExpectOperationCounts(534529, 115280, values, &amp;tracker, &amp;set100);
1258  }
1259  struct NoDefaultCtor {
1260    int num;
1261    explicit NoDefaultCtor(int i) : num(i) {}
1262    friend bool operator&lt;(const NoDefaultCtor &amp;a, const NoDefaultCtor &amp;b) {
1263      return a.num &lt; b.num;
1264    }
1265  };
1266  TEST(Btree, BtreeMapCanHoldNoDefaultCtorTypes) {
1267    absl::btree_map&lt;NoDefaultCtor, NoDefaultCtor&gt; m;
1268    for (int i = 1; i &lt;= 99; ++i) {
1269      SCOPED_TRACE(i);
1270      EXPECT_TRUE(m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i)).second);
1271    }
1272    EXPECT_FALSE(m.emplace(NoDefaultCtor(78), NoDefaultCtor(0)).second);
1273    auto iter99 = m.find(NoDefaultCtor(99));
1274    ASSERT_NE(iter99, m.end());
1275    EXPECT_EQ(iter99-&gt;second.num, 1);
1276    auto iter1 = m.find(NoDefaultCtor(1));
1277    ASSERT_NE(iter1, m.end());
1278    EXPECT_EQ(iter1-&gt;second.num, 99);
1279    auto iter50 = m.find(NoDefaultCtor(50));
1280    ASSERT_NE(iter50, m.end());
1281    EXPECT_EQ(iter50-&gt;second.num, 50);
1282    auto iter25 = m.find(NoDefaultCtor(25));
1283    ASSERT_NE(iter25, m.end());
1284    EXPECT_EQ(iter25-&gt;second.num, 75);
1285  }
1286  TEST(Btree, BtreeMultimapCanHoldNoDefaultCtorTypes) {
1287    absl::btree_multimap&lt;NoDefaultCtor, NoDefaultCtor&gt; m;
1288    for (int i = 1; i &lt;= 99; ++i) {
1289      SCOPED_TRACE(i);
1290      m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i));
1291    }
1292    auto iter99 = m.find(NoDefaultCtor(99));
1293    ASSERT_NE(iter99, m.end());
1294    EXPECT_EQ(iter99-&gt;second.num, 1);
1295    auto iter1 = m.find(NoDefaultCtor(1));
1296    ASSERT_NE(iter1, m.end());
1297    EXPECT_EQ(iter1-&gt;second.num, 99);
1298    auto iter50 = m.find(NoDefaultCtor(50));
1299    ASSERT_NE(iter50, m.end());
1300    EXPECT_EQ(iter50-&gt;second.num, 50);
1301    auto iter25 = m.find(NoDefaultCtor(25));
1302    ASSERT_NE(iter25, m.end());
1303    EXPECT_EQ(iter25-&gt;second.num, 75);
1304  }
1305  TEST(Btree, MapAt) {
1306    absl::btree_map&lt;int, int&gt; map = {{1, 2}, {2, 4}};
1307    EXPECT_EQ(map.at(1), 2);
1308    EXPECT_EQ(map.at(2), 4);
1309    map.at(2) = 8;
1310    const absl::btree_map&lt;int, int&gt; &amp;const_map = map;
1311    EXPECT_EQ(const_map.at(1), 2);
1312    EXPECT_EQ(const_map.at(2), 8);
1313  #ifdef ABSL_HAVE_EXCEPTIONS
1314    EXPECT_THROW(map.at(3), std::out_of_range);
1315  #else
1316    EXPECT_DEATH_IF_SUPPORTED(map.at(3), &quot;absl::btree_map::at&quot;);
1317  #endif
1318  }
1319  TEST(Btree, BtreeMultisetEmplace) {
1320    const int value_to_insert = 123456;
1321    absl::btree_multiset&lt;int&gt; s;
1322    auto iter = s.emplace(value_to_insert);
1323    ASSERT_NE(iter, s.end());
1324    EXPECT_EQ(*iter, value_to_insert);
1325    iter = s.emplace(value_to_insert);
1326    ASSERT_NE(iter, s.end());
1327    EXPECT_EQ(*iter, value_to_insert);
1328    auto result = s.equal_range(value_to_insert);
1329    EXPECT_EQ(std::distance(result.first, result.second), 2);
1330  }
1331  TEST(Btree, BtreeMultisetEmplaceHint) {
1332    const int value_to_insert = 123456;
1333    absl::btree_multiset&lt;int&gt; s;
1334    auto iter = s.emplace(value_to_insert);
1335    ASSERT_NE(iter, s.end());
1336    EXPECT_EQ(*iter, value_to_insert);
1337    iter = s.emplace_hint(iter, value_to_insert);
1338    EXPECT_EQ(iter, s.lower_bound(value_to_insert));
1339    ASSERT_NE(iter, s.end());
1340    EXPECT_EQ(*iter, value_to_insert);
1341  }
1342  TEST(Btree, BtreeMultimapEmplace) {
1343    const int key_to_insert = 123456;
1344    const char value0[] = &quot;a&quot;;
1345    absl::btree_multimap&lt;int, std::string&gt; m;
1346    auto iter = m.emplace(key_to_insert, value0);
1347    ASSERT_NE(iter, m.end());
1348    EXPECT_EQ(iter-&gt;first, key_to_insert);
1349    EXPECT_EQ(iter-&gt;second, value0);
1350    const char value1[] = &quot;b&quot;;
1351    iter = m.emplace(key_to_insert, value1);
1352    ASSERT_NE(iter, m.end());
1353    EXPECT_EQ(iter-&gt;first, key_to_insert);
1354    EXPECT_EQ(iter-&gt;second, value1);
1355    auto result = m.equal_range(key_to_insert);
1356    EXPECT_EQ(std::distance(result.first, result.second), 2);
1357  }
1358  TEST(Btree, BtreeMultimapEmplaceHint) {
1359    const int key_to_insert = 123456;
1360    const char value0[] = &quot;a&quot;;
1361    absl::btree_multimap&lt;int, std::string&gt; m;
1362    auto iter = m.emplace(key_to_insert, value0);
1363    ASSERT_NE(iter, m.end());
1364    EXPECT_EQ(iter-&gt;first, key_to_insert);
1365    EXPECT_EQ(iter-&gt;second, value0);
1366    const char value1[] = &quot;b&quot;;
1367    iter = m.emplace_hint(iter, key_to_insert, value1);
1368    EXPECT_EQ(iter, m.lower_bound(key_to_insert));
1369    ASSERT_NE(iter, m.end());
1370    EXPECT_EQ(iter-&gt;first, key_to_insert);
1371    EXPECT_EQ(iter-&gt;second, value1);
1372  }
1373  TEST(Btree, ConstIteratorAccessors) {
1374    absl::btree_set&lt;int&gt; set;
1375    for (int i = 0; i &lt; 100; ++i) {
1376      set.insert(i);
1377    }
1378    auto it = set.cbegin();
1379    auto r_it = set.crbegin();
1380    for (int i = 0; i &lt; 100; ++i, ++it, ++r_it) {
1381      ASSERT_EQ(*it, i);
1382      ASSERT_EQ(*r_it, 99 - i);
1383    }
1384    EXPECT_EQ(it, set.cend());
1385    EXPECT_EQ(r_it, set.crend());
1386  }
1387  TEST(Btree, StrSplitCompatible) {
1388    const absl::btree_set&lt;std::string&gt; split_set = absl::StrSplit(&quot;a,b,c&quot;, &#x27;,&#x27;);
1389    const absl::btree_set&lt;std::string&gt; expected_set = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
1390    EXPECT_EQ(split_set, expected_set);
1391  }
1392  TEST(Btree, KeyComp) {
1393    absl::btree_set&lt;int&gt; s;
1394    EXPECT_TRUE(s.key_comp()(1, 2));
1395    EXPECT_FALSE(s.key_comp()(2, 2));
1396    EXPECT_FALSE(s.key_comp()(2, 1));
1397    absl::btree_map&lt;int, int&gt; m1;
1398    EXPECT_TRUE(m1.key_comp()(1, 2));
1399    EXPECT_FALSE(m1.key_comp()(2, 2));
1400    EXPECT_FALSE(m1.key_comp()(2, 1));
1401    absl::btree_map&lt;std::string, int&gt; m2;
1402    EXPECT_TRUE(m2.key_comp()(&quot;a&quot;, &quot;b&quot;));
1403    EXPECT_FALSE(m2.key_comp()(&quot;b&quot;, &quot;b&quot;));
1404    EXPECT_FALSE(m2.key_comp()(&quot;b&quot;, &quot;a&quot;));
1405  }
1406  TEST(Btree, ValueComp) {
1407    absl::btree_set&lt;int&gt; s;
1408    EXPECT_TRUE(s.value_comp()(1, 2));
1409    EXPECT_FALSE(s.value_comp()(2, 2));
1410    EXPECT_FALSE(s.value_comp()(2, 1));
1411    absl::btree_map&lt;int, int&gt; m1;
1412    EXPECT_TRUE(m1.value_comp()(std::make_pair(1, 0), std::make_pair(2, 0)));
1413    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(2, 0)));
1414    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(1, 0)));
1415    absl::btree_map&lt;std::string, int&gt; m2;
1416    EXPECT_TRUE(m2.value_comp()(std::make_pair(&quot;a&quot;, 0), std::make_pair(&quot;b&quot;, 0)));
1417    EXPECT_FALSE(m2.value_comp()(std::make_pair(&quot;b&quot;, 0), std::make_pair(&quot;b&quot;, 0)));
1418    EXPECT_FALSE(m2.value_comp()(std::make_pair(&quot;b&quot;, 0), std::make_pair(&quot;a&quot;, 0)));
1419  }
1420  TEST(Btree, MapValueCompProtected) {
1421    struct key_compare {
1422      bool operator()(int l, int r) const { return l &lt; r; }
1423      int id;
1424    };
1425    using value_compare = absl::btree_map&lt;int, int, key_compare&gt;::value_compare;
1426    struct value_comp_child : public value_compare {
1427      explicit value_comp_child(key_compare kc) : value_compare(kc) {}
1428      int GetId() const { return comp.id; }
1429    };
1430    value_comp_child c(key_compare{10});
1431    EXPECT_EQ(c.GetId(), 10);
1432  }
1433  TEST(Btree, DefaultConstruction) {
1434    absl::btree_set&lt;int&gt; s;
1435    absl::btree_map&lt;int, int&gt; m;
1436    absl::btree_multiset&lt;int&gt; ms;
1437    absl::btree_multimap&lt;int, int&gt; mm;
1438    EXPECT_TRUE(s.empty());
1439    EXPECT_TRUE(m.empty());
1440    EXPECT_TRUE(ms.empty());
1441    EXPECT_TRUE(mm.empty());
1442  }
1443  TEST(Btree, SwissTableHashable) {
1444    static constexpr int kValues = 10000;
1445    std::vector&lt;int&gt; values(kValues);
1446    std::iota(values.begin(), values.end(), 0);
1447    std::vector&lt;std::pair&lt;int, int&gt;&gt; map_values;
1448    for (int v : values) map_values.emplace_back(v, -v);
1449    using set = absl::btree_set&lt;int&gt;;
1450    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1451        set{},
1452        set{1},
1453        set{2},
1454        set{1, 2},
1455        set{2, 1},
1456        set(values.begin(), values.end()),
1457        set(values.rbegin(), values.rend()),
1458    }));
1459    using mset = absl::btree_multiset&lt;int&gt;;
1460    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1461        mset{},
1462        mset{1},
1463        mset{1, 1},
1464        mset{2},
1465        mset{2, 2},
1466        mset{1, 2},
1467        mset{1, 1, 2},
1468        mset{1, 2, 2},
1469        mset{1, 1, 2, 2},
1470        mset(values.begin(), values.end()),
1471        mset(values.rbegin(), values.rend()),
1472    }));
1473    using map = absl::btree_map&lt;int, int&gt;;
1474    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1475        map{},
1476        map{{1, 0}},
1477        map{{1, 1}},
1478        map{{2, 0}},
1479        map{{2, 2}},
1480        map{{1, 0}, {2, 1}},
1481        map(map_values.begin(), map_values.end()),
1482        map(map_values.rbegin(), map_values.rend()),
1483    }));
1484    using mmap = absl::btree_multimap&lt;int, int&gt;;
1485    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1486        mmap{},
1487        mmap{{1, 0}},
1488        mmap{{1, 1}},
1489        mmap{{1, 0}, {1, 1}},
1490        mmap{{1, 1}, {1, 0}},
1491        mmap{{2, 0}},
1492        mmap{{2, 2}},
1493        mmap{{1, 0}, {2, 1}},
1494        mmap(map_values.begin(), map_values.end()),
1495        mmap(map_values.rbegin(), map_values.rend()),
1496    }));
1497  }
1498  TEST(Btree, ComparableSet) {
1499    absl::btree_set&lt;int&gt; s1 = {1, 2};
1500    absl::btree_set&lt;int&gt; s2 = {2, 3};
1501    EXPECT_LT(s1, s2);
1502    EXPECT_LE(s1, s2);
1503    EXPECT_LE(s1, s1);
1504    EXPECT_GT(s2, s1);
1505    EXPECT_GE(s2, s1);
1506    EXPECT_GE(s1, s1);
1507  }
1508  TEST(Btree, ComparableSetsDifferentLength) {
1509    absl::btree_set&lt;int&gt; s1 = {1, 2};
1510    absl::btree_set&lt;int&gt; s2 = {1, 2, 3};
1511    EXPECT_LT(s1, s2);
1512    EXPECT_LE(s1, s2);
1513    EXPECT_GT(s2, s1);
1514    EXPECT_GE(s2, s1);
1515  }
1516  TEST(Btree, ComparableMultiset) {
1517    absl::btree_multiset&lt;int&gt; s1 = {1, 2};
1518    absl::btree_multiset&lt;int&gt; s2 = {2, 3};
1519    EXPECT_LT(s1, s2);
1520    EXPECT_LE(s1, s2);
1521    EXPECT_LE(s1, s1);
1522    EXPECT_GT(s2, s1);
1523    EXPECT_GE(s2, s1);
1524    EXPECT_GE(s1, s1);
1525  }
1526  TEST(Btree, ComparableMap) {
1527    absl::btree_map&lt;int, int&gt; s1 = {{1, 2}};
1528    absl::btree_map&lt;int, int&gt; s2 = {{2, 3}};
1529    EXPECT_LT(s1, s2);
1530    EXPECT_LE(s1, s2);
1531    EXPECT_LE(s1, s1);
1532    EXPECT_GT(s2, s1);
1533    EXPECT_GE(s2, s1);
1534    EXPECT_GE(s1, s1);
1535  }
1536  TEST(Btree, ComparableMultimap) {
1537    absl::btree_multimap&lt;int, int&gt; s1 = {{1, 2}};
1538    absl::btree_multimap&lt;int, int&gt; s2 = {{2, 3}};
1539    EXPECT_LT(s1, s2);
1540    EXPECT_LE(s1, s2);
1541    EXPECT_LE(s1, s1);
1542    EXPECT_GT(s2, s1);
1543    EXPECT_GE(s2, s1);
1544    EXPECT_GE(s1, s1);
1545  }
1546  TEST(Btree, ComparableSetWithCustomComparator) {
1547    absl::btree_set&lt;int, std::greater&lt;int&gt;&gt; s1 = {1, 2};
1548    absl::btree_set&lt;int, std::greater&lt;int&gt;&gt; s2 = {2, 3};
1549    EXPECT_LT(s1, s2);
1550    EXPECT_LE(s1, s2);
1551    EXPECT_LE(s1, s1);
1552    EXPECT_GT(s2, s1);
1553    EXPECT_GE(s2, s1);
1554    EXPECT_GE(s1, s1);
1555  }
1556  TEST(Btree, EraseReturnsIterator) {
1557    absl::btree_set&lt;int&gt; set = {1, 2, 3, 4, 5};
1558    auto result_it = set.erase(set.begin(), set.find(3));
1559    EXPECT_EQ(result_it, set.find(3));
1560    result_it = set.erase(set.find(5));
1561    EXPECT_EQ(result_it, set.end());
1562  }
1563  TEST(Btree, ExtractAndInsertNodeHandleSet) {
1564    absl::btree_set&lt;int&gt; src1 = {1, 2, 3, 4, 5};
1565    auto nh = src1.extract(src1.find(3));
1566    EXPECT_THAT(src1, ElementsAre(1, 2, 4, 5));
1567    absl::btree_set&lt;int&gt; other;
1568    absl::btree_set&lt;int&gt;::insert_return_type res = other.insert(std::move(nh));
1569    EXPECT_THAT(other, ElementsAre(3));
1570    EXPECT_EQ(res.position, other.find(3));
1571    EXPECT_TRUE(res.inserted);
1572    EXPECT_TRUE(res.node.empty());
1573    absl::btree_set&lt;int&gt; src2 = {3, 4};
1574    nh = src2.extract(src2.find(3));
1575    EXPECT_THAT(src2, ElementsAre(4));
1576    res = other.insert(std::move(nh));
1577    EXPECT_THAT(other, ElementsAre(3));
1578    EXPECT_EQ(res.position, other.find(3));
1579    EXPECT_FALSE(res.inserted);
1580    ASSERT_FALSE(res.node.empty());
1581    EXPECT_EQ(res.node.value(), 3);
1582  }
1583  template &lt;typename Set&gt;
1584  void TestExtractWithTrackingForSet() {
1585    InstanceTracker tracker;
1586    {
1587      Set s;
1588      const size_t kSize = 1000;
1589      while (s.size() &lt; kSize) {
1590        s.insert(MovableOnlyInstance(s.size()));
1591      }
1592      for (int i = 0; i &lt; kSize; ++i) {
1593        auto nh = s.extract(MovableOnlyInstance(i));
1594        EXPECT_EQ(s.size(), kSize - 1);
1595        EXPECT_EQ(nh.value().value(), i);
1596        s.insert(std::move(nh));
1597        EXPECT_EQ(s.size(), kSize);
1598        auto it = s.find(MovableOnlyInstance(i));
1599        nh = s.extract(it);
1600        EXPECT_EQ(s.size(), kSize - 1);
1601        EXPECT_EQ(nh.value().value(), i);
1602        s.insert(s.begin(), std::move(nh));
1603        EXPECT_EQ(s.size(), kSize);
1604      }
1605    }
1606    EXPECT_EQ(0, tracker.instances());
1607  }
1608  template &lt;typename Map&gt;
1609  void TestExtractWithTrackingForMap() {
1610    InstanceTracker tracker;
1611    {
1612      Map m;
1613      const size_t kSize = 1000;
1614      while (m.size() &lt; kSize) {
1615        m.insert(
1616            {CopyableMovableInstance(m.size()), MovableOnlyInstance(m.size())});
1617      }
1618      for (int i = 0; i &lt; kSize; ++i) {
1619        auto nh = m.extract(CopyableMovableInstance(i));
1620        EXPECT_EQ(m.size(), kSize - 1);
1621        EXPECT_EQ(nh.key().value(), i);
1622        EXPECT_EQ(nh.mapped().value(), i);
1623        m.insert(std::move(nh));
1624        EXPECT_EQ(m.size(), kSize);
1625        auto it = m.find(CopyableMovableInstance(i));
1626        nh = m.extract(it);
1627        EXPECT_EQ(m.size(), kSize - 1);
1628        EXPECT_EQ(nh.key().value(), i);
1629        EXPECT_EQ(nh.mapped().value(), i);
1630        m.insert(m.begin(), std::move(nh));
1631        EXPECT_EQ(m.size(), kSize);
1632      }
1633    }
1634    EXPECT_EQ(0, tracker.instances());
1635  }
1636  TEST(Btree, ExtractTracking) {
1637    TestExtractWithTrackingForSet&lt;absl::btree_set&lt;MovableOnlyInstance&gt;&gt;();
1638    TestExtractWithTrackingForSet&lt;absl::btree_multiset&lt;MovableOnlyInstance&gt;&gt;();
1639    TestExtractWithTrackingForMap&lt;
1640        absl::btree_map&lt;CopyableMovableInstance, MovableOnlyInstance&gt;&gt;();
1641    TestExtractWithTrackingForMap&lt;
1642        absl::btree_multimap&lt;CopyableMovableInstance, MovableOnlyInstance&gt;&gt;();
1643  }
1644  TEST(Btree, ExtractAndInsertNodeHandleMultiSet) {
1645    absl::btree_multiset&lt;int&gt; src1 = {1, 2, 3, 3, 4, 5};
1646    auto nh = src1.extract(src1.find(3));
1647    EXPECT_THAT(src1, ElementsAre(1, 2, 3, 4, 5));
1648    absl::btree_multiset&lt;int&gt; other;
1649    auto res = other.insert(std::move(nh));
1650    EXPECT_THAT(other, ElementsAre(3));
1651    EXPECT_EQ(res, other.find(3));
1652    absl::btree_multiset&lt;int&gt; src2 = {3, 4};
1653    nh = src2.extract(src2.find(3));
1654    EXPECT_THAT(src2, ElementsAre(4));
1655    res = other.insert(std::move(nh));
1656    EXPECT_THAT(other, ElementsAre(3, 3));
1657    EXPECT_EQ(res, ++other.find(3));
1658  }
1659  TEST(Btree, ExtractAndInsertNodeHandleMap) {
1660    absl::btree_map&lt;int, int&gt; src1 = {{1, 2}, {3, 4}, {5, 6}};
1661    auto nh = src1.extract(src1.find(3));
1662    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1663    absl::btree_map&lt;int, int&gt; other;
1664    absl::btree_map&lt;int, int&gt;::insert_return_type res =
1665        other.insert(std::move(nh));
1666    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1667    EXPECT_EQ(res.position, other.find(3));
1668    EXPECT_TRUE(res.inserted);
1669    EXPECT_TRUE(res.node.empty());
1670    absl::btree_map&lt;int, int&gt; src2 = {{3, 6}};
1671    nh = src2.extract(src2.find(3));
1672    EXPECT_TRUE(src2.empty());
1673    res = other.insert(std::move(nh));
1674    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1675    EXPECT_EQ(res.position, other.find(3));
1676    EXPECT_FALSE(res.inserted);
1677    ASSERT_FALSE(res.node.empty());
1678    EXPECT_EQ(res.node.key(), 3);
1679    EXPECT_EQ(res.node.mapped(), 6);
1680  }
1681  TEST(Btree, ExtractAndInsertNodeHandleMultiMap) {
1682    absl::btree_multimap&lt;int, int&gt; src1 = {{1, 2}, {3, 4}, {5, 6}};
1683    auto nh = src1.extract(src1.find(3));
1684    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1685    absl::btree_multimap&lt;int, int&gt; other;
1686    auto res = other.insert(std::move(nh));
1687    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1688    EXPECT_EQ(res, other.find(3));
1689    absl::btree_multimap&lt;int, int&gt; src2 = {{3, 6}};
1690    nh = src2.extract(src2.find(3));
1691    EXPECT_TRUE(src2.empty());
1692    res = other.insert(std::move(nh));
1693    EXPECT_THAT(other, ElementsAre(Pair(3, 4), Pair(3, 6)));
1694    EXPECT_EQ(res, ++other.begin());
1695  }
1696  TEST(Btree, ExtractMultiMapEquivalentKeys) {
1697    absl::btree_multimap&lt;std::string, int&gt; map;
1698    for (int i = 0; i &lt; 100; ++i) {
1699      for (int j = 0; j &lt; 100; ++j) {
1700        map.insert({absl::StrCat(i), j});
1701      }
1702    }
1703    for (int i = 0; i &lt; 100; ++i) {
1704      const std::string key = absl::StrCat(i);
1705      auto node_handle = map.extract(key);
1706      EXPECT_EQ(node_handle.key(), key);
1707      EXPECT_EQ(node_handle.mapped(), 0) &lt;&lt; i;
1708    }
1709    for (int i = 0; i &lt; 100; ++i) {
1710      const std::string key = absl::StrCat(i);
1711      auto node_handle = map.extract(key);
1712      EXPECT_EQ(node_handle.key(), key);
1713      EXPECT_EQ(node_handle.mapped(), 1) &lt;&lt; i;
1714    }
1715  }
1716  TEST(Btree, ExtractAndGetNextSet) {
1717    absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1718    auto it = src.find(3);
1719    auto extracted_and_next = src.extract_and_get_next(it);
1720    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1721    EXPECT_EQ(extracted_and_next.node.value(), 3);
1722    EXPECT_EQ(*extracted_and_next.next, 4);
1723  }
1724  TEST(Btree, ExtractAndGetNextMultiSet) {
1725    absl::btree_multiset&lt;int&gt; src = {1, 2, 3, 4, 5};
1726    auto it = src.find(3);
1727    auto extracted_and_next = src.extract_and_get_next(it);
1728    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1729    EXPECT_EQ(extracted_and_next.node.value(), 3);
1730    EXPECT_EQ(*extracted_and_next.next, 4);
1731  }
1732  TEST(Btree, ExtractAndGetNextMap) {
1733    absl::btree_map&lt;int, int&gt; src = {{1, 2}, {3, 4}, {5, 6}};
1734    auto it = src.find(3);
1735    auto extracted_and_next = src.extract_and_get_next(it);
1736    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1737    EXPECT_EQ(extracted_and_next.node.key(), 3);
1738    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1739    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1740  }
1741  TEST(Btree, ExtractAndGetNextMultiMap) {
1742    absl::btree_multimap&lt;int, int&gt; src = {{1, 2}, {3, 4}, {5, 6}};
1743    auto it = src.find(3);
1744    auto extracted_and_next = src.extract_and_get_next(it);
1745    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1746    EXPECT_EQ(extracted_and_next.node.key(), 3);
1747    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1748    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1749  }
1750  TEST(Btree, ExtractAndGetNextEndIter) {
1751    absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1752    auto it = src.find(5);
1753    auto extracted_and_next = src.extract_and_get_next(it);
1754    EXPECT_THAT(src, ElementsAre(1, 2, 3, 4));
1755    EXPECT_EQ(extracted_and_next.node.value(), 5);
1756    EXPECT_EQ(extracted_and_next.next, src.end());
1757  }
1758  TEST(Btree, ExtractDoesntCauseExtraMoves) {
1759  #ifdef _MSC_VER
1760    GTEST_SKIP() &lt;&lt; &quot;This test fails on MSVC.&quot;;
1761  #endif
1762    using Set = absl::btree_set&lt;MovableOnlyInstance&gt;;
1763    std::array&lt;std::function&lt;void(Set &amp;)&gt;, 3&gt; extracters = {
1764        [](Set &amp;s) { auto node = s.extract(s.begin()); },
1765        [](Set &amp;s) { auto ret = s.extract_and_get_next(s.begin()); },
1766        [](Set &amp;s) { auto node = s.extract(MovableOnlyInstance(0)); }};
1767    InstanceTracker tracker;
1768    for (int i = 0; i &lt; 3; ++i) {
1769      Set s;
1770      s.insert(MovableOnlyInstance(0));
1771      tracker.ResetCopiesMovesSwaps();
1772      extracters[i](s);
1773      EXPECT_EQ(tracker.copies(), 0) &lt;&lt; i;
1774      EXPECT_EQ(tracker.moves(), 1) &lt;&lt; i;
1775      EXPECT_EQ(tracker.swaps(), 0) &lt;&lt; i;
1776    }
1777  }
1778  struct InsertMultiHintData {
1779    int key;
1780    int not_key;
1781    bool operator==(const InsertMultiHintData other) const {
1782      return key == other.key &amp;&amp; not_key == other.not_key;
1783    }
1784  };
1785  struct InsertMultiHintDataKeyCompare {
1786    using is_transparent = void;
1787    bool operator()(const InsertMultiHintData a,
1788                    const InsertMultiHintData b) const {
1789      return a.key &lt; b.key;
1790    }
1791    bool operator()(const int a, const InsertMultiHintData b) const {
1792      return a &lt; b.key;
1793    }
1794    bool operator()(const InsertMultiHintData a, const int b) const {
1795      return a.key &lt; b;
1796    }
1797  };
1798  TEST(Btree, InsertHintNodeHandle) {
1799    {
1800      absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1801      auto nh = src.extract(src.find(3));
1802      EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1803      absl::btree_set&lt;int&gt; other = {0, 100};
1804      auto it = other.insert(other.lower_bound(3), std::move(nh));
1805      EXPECT_THAT(other, ElementsAre(0, 3, 100));
1806      EXPECT_EQ(it, other.find(3));
1807      nh = src.extract(src.find(5));
1808      it = other.insert(other.end(), std::move(nh));
1809      EXPECT_THAT(other, ElementsAre(0, 3, 5, 100));
1810      EXPECT_EQ(it, other.find(5));
1811    }
1812    absl::btree_multiset&lt;InsertMultiHintData, InsertMultiHintDataKeyCompare&gt; src =
1813        {{1, 2}, {3, 4}, {3, 5}};
1814    auto nh = src.extract(src.lower_bound(3));
1815    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 4}));
1816    absl::btree_multiset&lt;InsertMultiHintData, InsertMultiHintDataKeyCompare&gt;
1817        other = {{3, 1}, {3, 2}, {3, 3}};
1818    auto it = other.insert(--other.end(), std::move(nh));
1819    EXPECT_THAT(
1820        other, ElementsAre(InsertMultiHintData{3, 1}, InsertMultiHintData{3, 2},
1821                           InsertMultiHintData{3, 4}, InsertMultiHintData{3, 3}));
1822    EXPECT_EQ(it, --(--other.end()));
1823    nh = src.extract(src.find(3));
1824    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 5}));
1825    it = other.insert(other.begin(), std::move(nh));
1826    EXPECT_THAT(other,
1827                ElementsAre(InsertMultiHintData{3, 5}, InsertMultiHintData{3, 1},
1828                            InsertMultiHintData{3, 2}, InsertMultiHintData{3, 4},
1829                            InsertMultiHintData{3, 3}));
1830    EXPECT_EQ(it, other.begin());
1831  }
1832  struct IntCompareToCmp {
1833    absl::weak_ordering operator()(int a, int b) const {
1834      if (a &lt; b) return absl::weak_ordering::less;
1835      if (a &gt; b) return absl::weak_ordering::greater;
1836      return absl::weak_ordering::equivalent;
1837    }
1838  };
1839  TEST(Btree, MergeIntoUniqueContainers) {
1840    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1841    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1842    absl::btree_set&lt;int&gt; dst;
1843    dst.merge(src1);
1844    EXPECT_TRUE(src1.empty());
1845    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1846    dst.merge(src2);
1847    EXPECT_THAT(src2, ElementsAre(3, 4));
1848    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1849  }
1850  TEST(Btree, MergeIntoUniqueContainersWithCompareTo) {
1851    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1852    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1853    absl::btree_set&lt;int, IntCompareToCmp&gt; dst;
1854    dst.merge(src1);
1855    EXPECT_TRUE(src1.empty());
1856    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1857    dst.merge(src2);
1858    EXPECT_THAT(src2, ElementsAre(3, 4));
1859    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1860  }
1861  TEST(Btree, MergeIntoMultiContainers) {
1862    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1863    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1864    absl::btree_multiset&lt;int&gt; dst;
1865    dst.merge(src1);
1866    EXPECT_TRUE(src1.empty());
1867    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1868    dst.merge(src2);
1869    EXPECT_TRUE(src2.empty());
1870    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1871  }
1872  TEST(Btree, MergeIntoMultiContainersWithCompareTo) {
1873    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1874    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1875    absl::btree_multiset&lt;int, IntCompareToCmp&gt; dst;
1876    dst.merge(src1);
1877    EXPECT_TRUE(src1.empty());
1878    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1879    dst.merge(src2);
1880    EXPECT_TRUE(src2.empty());
1881    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1882  }
1883  TEST(Btree, MergeIntoMultiMapsWithDifferentComparators) {
1884    absl::btree_map&lt;int, int, IntCompareToCmp&gt; src1 = {{1, 1}, {2, 2}, {3, 3}};
1885    absl::btree_multimap&lt;int, int, std::greater&lt;int&gt;&gt; src2 = {
1886        {5, 5}, {4, 1}, {4, 4}, {3, 2}};
1887    absl::btree_multimap&lt;int, int&gt; dst;
1888    dst.merge(src1);
1889    EXPECT_TRUE(src1.empty());
1890    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3)));
1891    dst.merge(src2);
1892    EXPECT_TRUE(src2.empty());
1893    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(3, 2),
1894                                 Pair(4, 1), Pair(4, 4), Pair(5, 5)));
1895  }
1896  TEST(Btree, MergeIntoSetMovableOnly) {
1897    absl::btree_set&lt;MovableOnlyInstance&gt; src;
1898    src.insert(MovableOnlyInstance(1));
1899    absl::btree_multiset&lt;MovableOnlyInstance&gt; dst1;
1900    dst1.insert(MovableOnlyInstance(2));
1901    absl::btree_set&lt;MovableOnlyInstance&gt; dst2;
1902    dst1.merge(src);
1903    EXPECT_TRUE(src.empty());
1904    ASSERT_THAT(dst1, SizeIs(2));
1905    EXPECT_EQ(*dst1.begin(), MovableOnlyInstance(1));
1906    EXPECT_EQ(*std::next(dst1.begin()), MovableOnlyInstance(2));
1907    dst2.merge(dst1);
1908    EXPECT_TRUE(dst1.empty());
1909    ASSERT_THAT(dst2, SizeIs(2));
1910    EXPECT_EQ(*dst2.begin(), MovableOnlyInstance(1));
1911    EXPECT_EQ(*std::next(dst2.begin()), MovableOnlyInstance(2));
1912  }
1913  struct KeyCompareToWeakOrdering {
1914    template &lt;typename T&gt;
1915    absl::weak_ordering operator()(const T &amp;a, const T &amp;b) const {
1916      return a &lt; b ? absl::weak_ordering::less
1917                   : a == b ? absl::weak_ordering::equivalent
1918                            : absl::weak_ordering::greater;
1919    }
1920  };
1921  struct KeyCompareToStrongOrdering {
1922    template &lt;typename T&gt;
1923    absl::strong_ordering operator()(const T &amp;a, const T &amp;b) const {
1924      return a &lt; b ? absl::strong_ordering::less
1925                   : a == b ? absl::strong_ordering::equal
1926                            : absl::strong_ordering::greater;
1927    }
1928  };
1929  TEST(Btree, UserProvidedKeyCompareToComparators) {
1930    absl::btree_set&lt;int, KeyCompareToWeakOrdering&gt; weak_set = {1, 2, 3};
1931    EXPECT_TRUE(weak_set.contains(2));
1932    EXPECT_FALSE(weak_set.contains(4));
1933    absl::btree_set&lt;int, KeyCompareToStrongOrdering&gt; strong_set = {1, 2, 3};
1934    EXPECT_TRUE(strong_set.contains(2));
1935    EXPECT_FALSE(strong_set.contains(4));
1936  }
1937  TEST(Btree, TryEmplaceBasicTest) {
1938    absl::btree_map&lt;int, std::string&gt; m;
1939    m.try_emplace(1, &quot;one&quot;);
1940    EXPECT_EQ(1, m.size());
1941    const int key(42);
1942    m.try_emplace(key, 3, &#x27;a&#x27;);
1943    m.try_emplace(2, std::string(&quot;two&quot;));
1944    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1945    EXPECT_THAT(m, ElementsAreArray(std::vector&lt;std::pair&lt;int, std::string&gt;&gt;{
1946                       {1, &quot;one&quot;}, {2, &quot;two&quot;}, {42, &quot;aaa&quot;}}));
1947  }
1948  TEST(Btree, TryEmplaceWithHintWorks) {
1949    int calls = 0;
1950    auto cmp = [&amp;calls](int x, int y) {
1951      ++calls;
1952      return x &lt; y;
1953    };
1954    using Cmp = decltype(cmp);
1955    absl::btree_map&lt;int, int, CheckedCompareOptedOutCmp&lt;Cmp&gt;&gt; m(cmp);
1956    for (int i = 0; i &lt; 128; ++i) {
1957      m.emplace(i, i);
1958    }
1959    calls = 0;
1960    m.emplace(127, 127);
1961    EXPECT_GE(calls, 4);
1962    calls = 0;
1963    auto it = m.try_emplace(m.begin(), -1, -1);
1964    EXPECT_EQ(129, m.size());
1965    EXPECT_EQ(it, m.begin());
1966    EXPECT_LE(calls, 2);
1967    calls = 0;
1968    std::pair&lt;int, int&gt; pair1024 = {1024, 1024};
1969    it = m.try_emplace(m.end(), pair1024.first, pair1024.second);
1970    EXPECT_EQ(130, m.size());
1971    EXPECT_EQ(it, --m.end());
1972    EXPECT_LE(calls, 2);
1973    calls = 0;
1974    it = m.try_emplace(m.end(), 16, 17);
1975    EXPECT_EQ(130, m.size());
1976    EXPECT_GE(calls, 4);
1977    EXPECT_EQ(it, m.find(16));
1978    calls = 0;
1979    it = m.try_emplace(it, 16, 17);
1980    EXPECT_EQ(130, m.size());
1981    EXPECT_LE(calls, 2);
1982    EXPECT_EQ(it, m.find(16));
1983    m.erase(2);
1984    EXPECT_EQ(129, m.size());
1985    auto hint = m.find(3);
1986    calls = 0;
1987    m.try_emplace(hint, 2, 2);
1988    EXPECT_EQ(130, m.size());
1989    EXPECT_LE(calls, 2);
1990    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1991  }
1992  TEST(Btree, TryEmplaceWithBadHint) {
1993    absl::btree_map&lt;int, int&gt; m = {{1, 1}, {9, 9}};
1994    auto it = m.try_emplace(m.begin(), 2, 2);
1995    EXPECT_EQ(it, ++m.begin());
1996    EXPECT_THAT(m, ElementsAreArray(
1997                       std::vector&lt;std::pair&lt;int, int&gt;&gt;{{1, 1}, {2, 2}, {9, 9}}));
1998    it = m.try_emplace(++(++m.begin()), 0, 0);
1999    EXPECT_EQ(it, m.begin());
2000    EXPECT_THAT(m, ElementsAreArray(std::vector&lt;std::pair&lt;int, int&gt;&gt;{
2001                       {0, 0}, {1, 1}, {2, 2}, {9, 9}}));
2002  }
2003  TEST(Btree, TryEmplaceMaintainsSortedOrder) {
2004    absl::btree_map&lt;int, std::string&gt; m;
2005    std::pair&lt;int, std::string&gt; pair5 = {5, &quot;five&quot;};
2006    m.try_emplace(10, &quot;ten&quot;);
2007    m.try_emplace(pair5.first, pair5.second);
2008    EXPECT_EQ(2, m.size());
2009    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2010    int int100{100};
2011    m.try_emplace(int100, &quot;hundred&quot;);
2012    m.try_emplace(1, &quot;one&quot;);
2013    EXPECT_EQ(4, m.size());
2014    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2015  }
2016  TEST(Btree, TryEmplaceWithHintAndNoValueArgsWorks) {
2017    absl::btree_map&lt;int, int&gt; m;
2018    m.try_emplace(m.end(), 1);
2019    EXPECT_EQ(0, m[1]);
2020  }
2021  TEST(Btree, TryEmplaceWithHintAndMultipleValueArgsWorks) {
2022    absl::btree_map&lt;int, std::string&gt; m;
2023    m.try_emplace(m.end(), 1, 10, &#x27;a&#x27;);
2024    EXPECT_EQ(std::string(10, &#x27;a&#x27;), m[1]);
2025  }
2026  TEST(Btree, MoveAssignmentAllocatorPropagation) {
2027    InstanceTracker tracker;
2028    int64_t bytes1 = 0, bytes2 = 0;
2029    PropagatingCountingAlloc&lt;MovableOnlyInstance&gt; allocator1(&amp;bytes1);
2030    PropagatingCountingAlloc&lt;MovableOnlyInstance&gt; allocator2(&amp;bytes2);
2031    std::less&lt;MovableOnlyInstance&gt; cmp;
2032    {
2033      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2034                      PropagatingCountingAlloc&lt;MovableOnlyInstance&gt;&gt;
2035          set1(cmp, allocator1), set2(cmp, allocator2);
2036      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2037      tracker.ResetCopiesMovesSwaps();
2038      set2 = std::move(set1);
2039      EXPECT_EQ(tracker.moves(), 0);
2040    }
2041    {
2042      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2043                      CountingAllocator&lt;MovableOnlyInstance&gt;&gt;
2044          set1(cmp, allocator1), set2(cmp, allocator1);
2045      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2046      tracker.ResetCopiesMovesSwaps();
2047      set2 = std::move(set1);
2048      EXPECT_EQ(tracker.moves(), 0);
2049    }
2050    {
2051      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2052                      CountingAllocator&lt;MovableOnlyInstance&gt;&gt;
2053          set1(cmp, allocator1), set2(cmp, allocator2);
2054      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2055      tracker.ResetCopiesMovesSwaps();
2056      set2 = std::move(set1);
2057      EXPECT_GE(tracker.moves(), 100);
2058    }
2059  }
2060  TEST(Btree, EmptyTree) {
2061    absl::btree_set&lt;int&gt; s;
2062    EXPECT_TRUE(s.empty());
2063    EXPECT_EQ(s.size(), 0);
2064    EXPECT_GT(s.max_size(), 0);
2065  }
2066  bool IsEven(int k) { return k % 2 == 0; }
2067  TEST(Btree, EraseIf) {
2068    {
2069      absl::btree_set&lt;int&gt; s = {1, 3, 5, 6, 100};
2070      EXPECT_EQ(erase_if(s, [](int k) { return k &gt; 3; }), 3);
2071      EXPECT_THAT(s, ElementsAre(1, 3));
2072    }
2073    {
2074      absl::btree_multiset&lt;int&gt; s = {1, 3, 3, 5, 6, 6, 100};
2075      EXPECT_EQ(erase_if(s, [](int k) { return k &lt;= 3; }), 3);
2076      EXPECT_THAT(s, ElementsAre(5, 6, 6, 100));
2077    }
2078    {
2079      absl::btree_map&lt;int, int&gt; m = {{1, 1}, {3, 3}, {6, 6}, {100, 100}};
2080      EXPECT_EQ(
2081          erase_if(m, [](std::pair&lt;const int, int&gt; kv) { return kv.first &gt; 3; }),
2082          2);
2083      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3)));
2084    }
2085    {
2086      absl::btree_multimap&lt;int, int&gt; m = {{1, 1}, {3, 3}, {3, 6},
2087                                          {6, 6}, {6, 7}, {100, 6}};
2088      EXPECT_EQ(
2089          erase_if(m,
2090                   [](std::pair&lt;const int, int&gt; kv) { return kv.second == 6; }),
2091          3);
2092      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3), Pair(6, 7)));
2093    }
2094    {
2095      absl::btree_set&lt;int&gt; s;
2096      for (int i = 0; i &lt; 1000; ++i) s.insert(2 * i);
2097      EXPECT_EQ(erase_if(s, IsEven), 1000);
2098      EXPECT_THAT(s, IsEmpty());
2099    }
2100    {
2101      absl::btree_set&lt;int&gt; s = {1, 3, 5, 6, 100};
2102      EXPECT_EQ(erase_if(s, &amp;IsEven), 2);
2103      EXPECT_THAT(s, ElementsAre(1, 3, 5));
2104    }
2105    {
2106      absl::btree_set&lt;int&gt; s;
2107      for (int i = 0; i &lt; 1000; ++i) s.insert(i);
2108      int pred_calls = 0;
2109      EXPECT_EQ(erase_if(s,
2110                         [&amp;pred_calls](int k) {
2111                           ++pred_calls;
2112                           return k % 2;
2113                         }),
2114                500);
2115      EXPECT_THAT(s, SizeIs(500));
2116      EXPECT_EQ(pred_calls, 1000);
2117    }
2118  }
2119  TEST(Btree, InsertOrAssign) {
2120    absl::btree_map&lt;int, int&gt; m = {{1, 1}, {3, 3}};
2121    using value_type = typename decltype(m)::value_type;
2122    auto ret = m.insert_or_assign(4, 4);
2123    EXPECT_EQ(*ret.first, value_type(4, 4));
2124    EXPECT_TRUE(ret.second);
2125    ret = m.insert_or_assign(3, 100);
2126    EXPECT_EQ(*ret.first, value_type(3, 100));
2127    EXPECT_FALSE(ret.second);
2128    auto hint_ret = m.insert_or_assign(ret.first, 3, 200);
2129    EXPECT_EQ(*hint_ret, value_type(3, 200));
2130    hint_ret = m.insert_or_assign(m.find(1), 0, 1);
2131    EXPECT_EQ(*hint_ret, value_type(0, 1));
2132    hint_ret = m.insert_or_assign(m.end(), -1, 1);
2133    EXPECT_EQ(*hint_ret, value_type(-1, 1));
2134    EXPECT_THAT(m, ElementsAre(Pair(-1, 1), Pair(0, 1), Pair(1, 1), Pair(3, 200),
2135                               Pair(4, 4)));
2136  }
2137  TEST(Btree, InsertOrAssignMovableOnly) {
2138    absl::btree_map&lt;int, MovableOnlyInstance&gt; m;
2139    using value_type = typename decltype(m)::value_type;
2140    auto ret = m.insert_or_assign(4, MovableOnlyInstance(4));
2141    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(4)));
2142    EXPECT_TRUE(ret.second);
2143    ret = m.insert_or_assign(4, MovableOnlyInstance(100));
2144    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(100)));
2145    EXPECT_FALSE(ret.second);
2146    auto hint_ret = m.insert_or_assign(ret.first, 3, MovableOnlyInstance(200));
2147    EXPECT_EQ(*hint_ret, value_type(3, MovableOnlyInstance(200)));
2148    EXPECT_EQ(m.size(), 2);
2149  }
2150  TEST(Btree, BitfieldArgument) {
2151    union {
2152      int n : 1;
2153    };
2154    n = 0;
2155    absl::btree_map&lt;int, int&gt; m;
2156    m.erase(n);
2157    m.count(n);
2158    m.find(n);
2159    m.contains(n);
2160    m.equal_range(n);
2161    m.insert_or_assign(n, n);
2162    m.insert_or_assign(m.end(), n, n);
2163    m.try_emplace(n);
2164    m.try_emplace(m.end(), n);
2165    m.at(n);
2166    m[n];
2167  }
2168  TEST(Btree, SetRangeConstructorAndInsertSupportExplicitConversionComparable) {
2169    const absl::string_view names[] = {&quot;n1&quot;, &quot;n2&quot;};
2170    absl::btree_set&lt;std::string&gt; name_set1{std::begin(names), std::end(names)};
2171    EXPECT_THAT(name_set1, ElementsAreArray(names));
2172    absl::btree_set&lt;std::string&gt; name_set2;
2173    name_set2.insert(std::begin(names), std::end(names));
2174    EXPECT_THAT(name_set2, ElementsAreArray(names));
2175  }
2176  struct ConstructorCounted {
2177    explicit ConstructorCounted(int i) : i(i) { ++constructor_calls; }
2178    bool operator==(int other) const { return i == other; }
2179    int i;
2180    static int constructor_calls;
2181  };
2182  int ConstructorCounted::constructor_calls = 0;
2183  struct ConstructorCountedCompare {
2184    bool operator()(int a, const ConstructorCounted &amp;b) const { return a &lt; b.i; }
2185    bool operator()(const ConstructorCounted &amp;a, int b) const { return a.i &lt; b; }
2186    bool operator()(const ConstructorCounted &amp;a,
2187                    const ConstructorCounted &amp;b) const {
2188      return a.i &lt; b.i;
2189    }
2190    using is_transparent = void;
2191  };
2192  TEST(Btree,
2193       SetRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2194    const int i[] = {0, 1, 1};
2195    ConstructorCounted::constructor_calls = 0;
2196    absl::btree_set&lt;ConstructorCounted, ConstructorCountedCompare&gt; set{
2197        std::begin(i), std::end(i)};
2198    EXPECT_THAT(set, ElementsAre(0, 1));
2199    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2200    set.insert(std::begin(i), std::end(i));
2201    EXPECT_THAT(set, ElementsAre(0, 1));
2202    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2203  }
2204  TEST(Btree,
2205       SetRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2206    const int i[] = {0, 1};
2207    absl::btree_set&lt;std::vector&lt;void *&gt;&gt; s1{std::begin(i), std::end(i)};
2208    EXPECT_THAT(s1, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2209    absl::btree_set&lt;std::vector&lt;void *&gt;&gt; s2;
2210    s2.insert(std::begin(i), std::end(i));
2211    EXPECT_THAT(s2, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2212  }
2213  #if !defined(__GLIBCXX__) || \
2214      (defined(_GLIBCXX_RELEASE) &amp;&amp; _GLIBCXX_RELEASE &gt;= 7)
2215  TEST(Btree, MapRangeConstructorAndInsertSupportExplicitConversionComparable) {
2216    const std::pair&lt;absl::string_view, int&gt; names[] = {{&quot;n1&quot;, 1}, {&quot;n2&quot;, 2}};
2217    absl::btree_map&lt;std::string, int&gt; name_map1{std::begin(names),
2218                                                std::end(names)};
2219    EXPECT_THAT(name_map1, ElementsAre(Pair(&quot;n1&quot;, 1), Pair(&quot;n2&quot;, 2)));
2220    absl::btree_map&lt;std::string, int&gt; name_map2;
2221    name_map2.insert(std::begin(names), std::end(names));
2222    EXPECT_THAT(name_map2, ElementsAre(Pair(&quot;n1&quot;, 1), Pair(&quot;n2&quot;, 2)));
2223  }
2224  TEST(Btree,
2225       MapRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2226    const std::pair&lt;int, int&gt; i[] = {{0, 1}, {1, 2}, {1, 3}};
2227    ConstructorCounted::constructor_calls = 0;
2228    absl::btree_map&lt;ConstructorCounted, int, ConstructorCountedCompare&gt; map{
2229        std::begin(i), std::end(i)};
2230    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2231    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2232    map.insert(std::begin(i), std::end(i));
2233    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2234    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2235  }
2236  TEST(Btree,
2237       MapRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2238    const std::pair&lt;int, int&gt; i[] = {{0, 1}, {1, 2}};
2239    absl::btree_map&lt;std::vector&lt;void *&gt;, int&gt; m1{std::begin(i), std::end(i)};
2240    EXPECT_THAT(m1,
2241                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2242    absl::btree_map&lt;std::vector&lt;void *&gt;, int&gt; m2;
2243    m2.insert(std::begin(i), std::end(i));
2244    EXPECT_THAT(m2,
2245                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2246  }
2247  TEST(Btree, HeterogeneousTryEmplace) {
2248    absl::btree_map&lt;std::string, int&gt; m;
2249    std::string s = &quot;key&quot;;
2250    absl::string_view sv = s;
2251    m.try_emplace(sv, 1);
2252    EXPECT_EQ(m[s], 1);
2253    m.try_emplace(m.end(), sv, 2);
2254    EXPECT_EQ(m[s], 1);
2255  }
2256  TEST(Btree, HeterogeneousOperatorMapped) {
2257    absl::btree_map&lt;std::string, int&gt; m;
2258    std::string s = &quot;key&quot;;
2259    absl::string_view sv = s;
2260    m[sv] = 1;
2261    EXPECT_EQ(m[s], 1);
2262    m[sv] = 2;
2263    EXPECT_EQ(m[s], 2);
2264  }
2265  TEST(Btree, HeterogeneousInsertOrAssign) {
2266    absl::btree_map&lt;std::string, int&gt; m;
2267    std::string s = &quot;key&quot;;
2268    absl::string_view sv = s;
2269    m.insert_or_assign(sv, 1);
2270    EXPECT_EQ(m[s], 1);
2271    m.insert_or_assign(m.end(), sv, 2);
2272    EXPECT_EQ(m[s], 2);
2273  }
2274  #endif
2275  #if defined(__cpp_lib_launder) &amp;&amp; __cpp_lib_launder &gt;= 201606
2276  TEST(Btree, NodeHandleMutableKeyAccess) {
2277    {
2278      absl::btree_map&lt;std::string, std::string&gt; map;
2279      map[&quot;key1&quot;] = &quot;mapped&quot;;
2280      auto nh = map.extract(map.begin());
2281      nh.key().resize(3);
2282      map.insert(std::move(nh));
2283      EXPECT_THAT(map, ElementsAre(Pair(&quot;key&quot;, &quot;mapped&quot;)));
2284    }
2285    {
2286      absl::btree_multimap&lt;std::string, std::string&gt; map;
2287      map.emplace(&quot;key1&quot;, &quot;mapped&quot;);
2288      auto nh = map.extract(map.begin());
2289      nh.key().resize(3);
2290      map.insert(std::move(nh));
2291      EXPECT_THAT(map, ElementsAre(Pair(&quot;key&quot;, &quot;mapped&quot;)));
2292    }
2293  }
2294  #endif
2295  struct MultiKey {
2296    int i1;
2297    int i2;
2298  };
2299  bool operator==(const MultiKey a, const MultiKey b) {
2300    return a.i1 == b.i1 &amp;&amp; a.i2 == b.i2;
2301  }
2302  struct MultiKeyComp {
2303    using is_transparent = void;
2304    bool operator()(const MultiKey a, const MultiKey b) const {
2305      if (a.i1 != b.i1) return a.i1 &lt; b.i1;
2306      return a.i2 &lt; b.i2;
2307    }
2308    bool operator()(const int a, const MultiKey b) const { return a &lt; b.i1; }
2309    bool operator()(const MultiKey a, const int b) const { return a.i1 &lt; b; }
2310  };
2311  struct MultiKeyThreeWayComp {
2312    using is_transparent = void;
2313    absl::weak_ordering operator()(const MultiKey a, const MultiKey b) const {
2314      if (a.i1 &lt; b.i1) return absl::weak_ordering::less;
2315      if (a.i1 &gt; b.i1) return absl::weak_ordering::greater;
2316      if (a.i2 &lt; b.i2) return absl::weak_ordering::less;
2317      if (a.i2 &gt; b.i2) return absl::weak_ordering::greater;
2318      return absl::weak_ordering::equivalent;
2319    }
2320    absl::weak_ordering operator()(const int a, const MultiKey b) const {
2321      if (a &lt; b.i1) return absl::weak_ordering::less;
2322      if (a &gt; b.i1) return absl::weak_ordering::greater;
2323      return absl::weak_ordering::equivalent;
2324    }
2325    absl::weak_ordering operator()(const MultiKey a, const int b) const {
2326      if (a.i1 &lt; b) return absl::weak_ordering::less;
2327      if (a.i1 &gt; b) return absl::weak_ordering::greater;
2328      return absl::weak_ordering::equivalent;
2329    }
2330  };
2331  template &lt;typename Compare&gt;
2332  class BtreeMultiKeyTest : public ::testing::Test {};
2333  using MultiKeyComps = ::testing::Types&lt;MultiKeyComp, MultiKeyThreeWayComp&gt;;
2334  TYPED_TEST_SUITE(BtreeMultiKeyTest, MultiKeyComps);
2335  TYPED_TEST(BtreeMultiKeyTest, EqualRange) {
2336    absl::btree_set&lt;MultiKey, TypeParam&gt; set;
2337    for (int i = 0; i &lt; 100; ++i) {
2338      for (int j = 0; j &lt; 100; ++j) {
2339        set.insert({i, j});
2340      }
2341    }
2342    for (int i = 0; i &lt; 100; ++i) {
2343      auto equal_range = set.equal_range(i);
2344      EXPECT_EQ(equal_range.first-&gt;i1, i);
2345      EXPECT_EQ(equal_range.first-&gt;i2, 0) &lt;&lt; i;
2346      EXPECT_EQ(std::distance(equal_range.first, equal_range.second), 100) &lt;&lt; i;
2347    }
2348  }
2349  TYPED_TEST(BtreeMultiKeyTest, Extract) {
2350    absl::btree_set&lt;MultiKey, TypeParam&gt; set;
2351    for (int i = 0; i &lt; 100; ++i) {
2352      for (int j = 0; j &lt; 100; ++j) {
2353        set.insert({i, j});
2354      }
2355    }
2356    for (int i = 0; i &lt; 100; ++i) {
2357      auto node_handle = set.extract(i);
2358      EXPECT_EQ(node_handle.value().i1, i);
2359      EXPECT_EQ(node_handle.value().i2, 0) &lt;&lt; i;
2360    }
2361    for (int i = 0; i &lt; 100; ++i) {
2362      auto node_handle = set.extract(i);
2363      EXPECT_EQ(node_handle.value().i1, i);
2364      EXPECT_EQ(node_handle.value().i2, 1) &lt;&lt; i;
2365    }
2366  }
2367  TYPED_TEST(BtreeMultiKeyTest, Erase) {
2368    absl::btree_set&lt;MultiKey, TypeParam&gt; set = {
2369        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2370    EXPECT_EQ(set.erase(2), 2);
2371    EXPECT_THAT(set, ElementsAre(MultiKey{1, 1}, MultiKey{3, 1}));
2372  }
2373  TYPED_TEST(BtreeMultiKeyTest, Count) {
2374    const absl::btree_set&lt;MultiKey, TypeParam&gt; set = {
2375        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2376    EXPECT_EQ(set.count(2), 2);
2377  }
2378  TEST(Btree, AllocConstructor) {
2379    using Alloc = CountingAllocator&lt;int&gt;;
2380    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2381    int64_t bytes_used = 0;
2382    Alloc alloc(&amp;bytes_used);
2383    Set set(alloc);
2384    set.insert({1, 2, 3});
2385    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2386    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2387  }
2388  TEST(Btree, AllocInitializerListConstructor) {
2389    using Alloc = CountingAllocator&lt;int&gt;;
2390    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2391    int64_t bytes_used = 0;
2392    Alloc alloc(&amp;bytes_used);
2393    Set set({1, 2, 3}, alloc);
2394    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2395    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2396  }
2397  TEST(Btree, AllocRangeConstructor) {
2398    using Alloc = CountingAllocator&lt;int&gt;;
2399    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2400    int64_t bytes_used = 0;
2401    Alloc alloc(&amp;bytes_used);
2402    std::vector&lt;int&gt; v = {1, 2, 3};
2403    Set set(v.begin(), v.end(), alloc);
2404    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2405    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2406  }
2407  TEST(Btree, AllocCopyConstructor) {
2408    using Alloc = CountingAllocator&lt;int&gt;;
2409    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2410    int64_t bytes_used1 = 0;
2411    Alloc alloc1(&amp;bytes_used1);
2412    Set set1(alloc1);
2413    set1.insert({1, 2, 3});
2414    int64_t bytes_used2 = 0;
2415    Alloc alloc2(&amp;bytes_used2);
2416    Set set2(set1, alloc2);
2417    EXPECT_THAT(set1, ElementsAre(1, 2, 3));
2418    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2419    EXPECT_GT(bytes_used1, set1.size() * sizeof(int));
2420    EXPECT_EQ(bytes_used1, bytes_used2);
2421  }
2422  TEST(Btree, AllocMoveConstructor_SameAlloc) {
2423    using Alloc = CountingAllocator&lt;int&gt;;
2424    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2425    int64_t bytes_used = 0;
2426    Alloc alloc(&amp;bytes_used);
2427    Set set1(alloc);
2428    set1.insert({1, 2, 3});
2429    const int64_t original_bytes_used = bytes_used;
2430    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2431    Set set2(std::move(set1), alloc);
2432    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2433    EXPECT_EQ(bytes_used, original_bytes_used);
2434  }
2435  TEST(Btree, AllocMoveConstructor_DifferentAlloc) {
2436    using Alloc = CountingAllocator&lt;int&gt;;
2437    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2438    int64_t bytes_used1 = 0;
2439    Alloc alloc1(&amp;bytes_used1);
2440    Set set1(alloc1);
2441    set1.insert({1, 2, 3});
2442    const int64_t original_bytes_used = bytes_used1;
2443    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2444    int64_t bytes_used2 = 0;
2445    Alloc alloc2(&amp;bytes_used2);
2446    Set set2(std::move(set1), alloc2);
2447    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2448    EXPECT_EQ(bytes_used1, original_bytes_used);
2449    EXPECT_EQ(bytes_used2, original_bytes_used);
2450  }
2451  bool IntCmp(const int a, const int b) { return a &lt; b; }
2452  TEST(Btree, SupportsFunctionPtrComparator) {
2453    absl::btree_set&lt;int, decltype(IntCmp) *&gt; set(IntCmp);
2454    set.insert({1, 2, 3});
2455    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2456    EXPECT_TRUE(set.key_comp()(1, 2));
2457    EXPECT_TRUE(set.value_comp()(1, 2));
2458    absl::btree_map&lt;int, int, decltype(IntCmp) *&gt; map(&amp;IntCmp);
2459    map[1] = 1;
2460    EXPECT_THAT(map, ElementsAre(Pair(1, 1)));
2461    EXPECT_TRUE(map.key_comp()(1, 2));
2462    EXPECT_TRUE(map.value_comp()(std::make_pair(1, 1), std::make_pair(2, 2)));
2463  }
2464  template &lt;typename Compare&gt;
2465  struct TransparentPassThroughComp {
2466    using is_transparent = void;
2467    template &lt;typename T, typename U&gt;
2468    bool operator()(const T &amp;lhs, const U &amp;rhs) const {
2469      return Compare()(lhs, rhs);
2470    }
2471  };
2472  TEST(Btree,
2473       SupportsTransparentComparatorThatDoesNotImplementAllVisibleOperators) {
2474    absl::btree_set&lt;MultiKey, TransparentPassThroughComp&lt;MultiKeyComp&gt;&gt; set;
2475    set.insert(MultiKey{1, 2});
2476    EXPECT_TRUE(set.contains(1));
2477  }
2478  TEST(Btree, ConstructImplicitlyWithUnadaptedComparator) {
2479    absl::btree_set&lt;MultiKey, MultiKeyComp&gt; set = {{}, MultiKeyComp{}};
2480  }
2481  TEST(Btree, InvalidComparatorsCaught) {
2482    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2483    {
2484      struct ZeroAlwaysLessCmp {
2485        bool operator()(int lhs, int rhs) const {
2486          if (lhs == 0) return true;
2487          return lhs &lt; rhs;
2488        }
2489      };
2490      absl::btree_set&lt;int, ZeroAlwaysLessCmp&gt; set;
2491      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;is_self_equivalent&quot;);
2492    }
2493    {
2494      struct ThreeWayAlwaysLessCmp {
2495        absl::weak_ordering operator()(int, int) const {
2496          return absl::weak_ordering::less;
2497        }
2498      };
2499      absl::btree_set&lt;int, ThreeWayAlwaysLessCmp&gt; set;
2500      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;is_self_equivalent&quot;);
2501    }
2502    {
2503      struct SumGreaterZeroCmp {
2504        bool operator()(int lhs, int rhs) const {
2505          if (lhs == rhs) return false;
2506          return lhs + rhs &gt; 0;
2507        }
2508      };
2509      absl::btree_set&lt;int, SumGreaterZeroCmp&gt; set;
2510      EXPECT_DEATH(set.insert({0, 1, 2}),
2511                   R&quot;regex(\!lhs_comp_rhs \|\| !comp\(\)\(rhs, lhs\))regex&quot;);
2512    }
2513    {
2514      struct ThreeWaySumGreaterZeroCmp {
2515        absl::weak_ordering operator()(int lhs, int rhs) const {
2516          if (lhs == rhs) return absl::weak_ordering::equivalent;
2517          if (lhs + rhs &gt; 0) return absl::weak_ordering::less;
2518          if (lhs + rhs == 0) return absl::weak_ordering::equivalent;
2519          return absl::weak_ordering::greater;
2520        }
2521      };
2522      absl::btree_set&lt;int, ThreeWaySumGreaterZeroCmp&gt; set;
2523      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;lhs_comp_rhs &lt; 0 -&gt; rhs_comp_lhs &gt; 0&quot;);
2524    }
2525    struct ClockTime {
2526      absl::optional&lt;int&gt; hour;
2527      int minute;
2528    };
2529    ClockTime a = {absl::nullopt, 1};
2530    ClockTime b = {2, 5};
2531    ClockTime c = {6, 0};
2532    {
2533      struct NonTransitiveTimeCmp {
2534        bool operator()(ClockTime lhs, ClockTime rhs) const {
2535          if (lhs.hour.has_value() &amp;&amp; rhs.hour.has_value() &amp;&amp;
2536              *lhs.hour != *rhs.hour) {
2537            return *lhs.hour &lt; *rhs.hour;
2538          }
2539          return lhs.minute &lt; rhs.minute;
2540        }
2541      };
2542      NonTransitiveTimeCmp cmp;
2543      ASSERT_TRUE(cmp(a, b) &amp;&amp; cmp(b, c) &amp;&amp; !cmp(a, c));
2544      absl::btree_set&lt;ClockTime, NonTransitiveTimeCmp&gt; set;
2545      EXPECT_DEATH(set.insert({a, b, c}), &quot;is_ordered_correctly&quot;);
2546      absl::btree_multiset&lt;ClockTime, NonTransitiveTimeCmp&gt; mset;
2547      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), &quot;is_ordered_correctly&quot;);
2548    }
2549    {
2550      struct ThreeWayNonTransitiveTimeCmp {
2551        absl::weak_ordering operator()(ClockTime lhs, ClockTime rhs) const {
2552          if (lhs.hour.has_value() &amp;&amp; rhs.hour.has_value() &amp;&amp;
2553              *lhs.hour != *rhs.hour) {
2554            return *lhs.hour &lt; *rhs.hour ? absl::weak_ordering::less
2555                                         : absl::weak_ordering::greater;
2556          }
2557          return lhs.minute &lt; rhs.minute    ? absl::weak_ordering::less
2558                 : lhs.minute == rhs.minute ? absl::weak_ordering::equivalent
2559                                            : absl::weak_ordering::greater;
2560        }
2561      };
2562      ThreeWayNonTransitiveTimeCmp cmp;
2563      ASSERT_TRUE(cmp(a, b) &lt; 0 &amp;&amp; cmp(b, c) &lt; 0 &amp;&amp; cmp(a, c) &gt; 0);
2564      absl::btree_set&lt;ClockTime, ThreeWayNonTransitiveTimeCmp&gt; set;
2565      EXPECT_DEATH(set.insert({a, b, c}), &quot;is_ordered_correctly&quot;);
2566      absl::btree_multiset&lt;ClockTime, ThreeWayNonTransitiveTimeCmp&gt; mset;
2567      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), &quot;is_ordered_correctly&quot;);
2568    }
2569  }
2570  TEST(Btree, MutatedKeysCaught) {
2571    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2572    struct IntPtrCmp {
2573      bool operator()(int *lhs, int *rhs) const { return *lhs &lt; *rhs; }
2574    };
2575    {
2576      absl::btree_set&lt;int *, IntPtrCmp&gt; set;
2577      int arr[] = {0, 1, 2};
2578      set.insert({&amp;arr[0], &amp;arr[1], &amp;arr[2]});
2579      arr[0] = 100;
2580      EXPECT_DEATH(set.insert(&amp;arr[0]), &quot;is_ordered_correctly&quot;);
2581    }
2582    {
2583      absl::btree_multiset&lt;int *, IntPtrCmp&gt; set;
2584      int arr[] = {0, 1, 2};
2585      set.insert({&amp;arr[0], &amp;arr[0], &amp;arr[1], &amp;arr[1], &amp;arr[2], &amp;arr[2]});
2586      arr[0] = 100;
2587      EXPECT_DEATH(set.insert(&amp;arr[0]), &quot;is_ordered_correctly&quot;);
2588    }
2589  }
2590  #ifndef _MSC_VER
2591  TEST(Btree, InvalidIteratorUse) {
2592    if (!BtreeGenerationsEnabled())
2593      GTEST_SKIP() &lt;&lt; &quot;Generation validation for iterators is disabled.&quot;;
2594    constexpr const char *kInvalidMemoryDeathMessage =
2595        &quot;heap-use-after-free|invalidated iterator&quot;;
2596    {
2597      absl::btree_set&lt;int&gt; set;
2598      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2599      auto it = set.begin();
2600      set.erase(it++);
2601      EXPECT_DEATH(set.erase(it++), kInvalidMemoryDeathMessage);
2602    }
2603    {
2604      absl::btree_set&lt;int&gt; set;
2605      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2606      auto it = set.insert(20).first;
2607      set.insert(30);
2608      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2609    }
2610    {
2611      absl::btree_set&lt;int&gt; set;
2612      for (int i = 0; i &lt; 10000; ++i) set.insert(i);
2613      auto it = set.find(5000);
2614      ASSERT_NE(it, set.end());
2615      set.erase(1);
2616      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2617    }
2618    {
2619      absl::btree_set&lt;int&gt; set;
2620      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2621      auto it = set.insert(20).first;
2622      set.insert(30);
2623      EXPECT_DEATH(void(it == set.begin()), kInvalidMemoryDeathMessage);
2624      EXPECT_DEATH(void(set.begin() == it), kInvalidMemoryDeathMessage);
2625    }
2626  }
2627  #endif
2628  class OnlyConstructibleByAllocator {
2629    explicit OnlyConstructibleByAllocator(int i) : i_(i) {}
2630   public:
2631    OnlyConstructibleByAllocator(const OnlyConstructibleByAllocator &amp;other)
2632        : i_(other.i_) {}
2633    OnlyConstructibleByAllocator &amp;operator=(
2634        const OnlyConstructibleByAllocator &amp;other) {
2635      i_ = other.i_;
2636      return *this;
2637    }
2638    int Get() const { return i_; }
2639    bool operator==(int i) const { return i_ == i; }
2640   private:
2641    template &lt;typename T&gt;
2642    friend class OnlyConstructibleAllocator;
2643    int i_;
2644  };
2645  template &lt;typename T = OnlyConstructibleByAllocator&gt;
2646  class OnlyConstructibleAllocator : public std::allocator&lt;T&gt; {
2647   public:
2648    OnlyConstructibleAllocator() = default;
2649    template &lt;class U&gt;
2650    explicit OnlyConstructibleAllocator(const OnlyConstructibleAllocator&lt;U&gt; &amp;) {}
2651    void construct(OnlyConstructibleByAllocator *p, int i) {
2652      new (p) OnlyConstructibleByAllocator(i);
2653    }
2654    template &lt;typename Pair&gt;
2655    void construct(Pair *p, const int i) {
2656      OnlyConstructibleByAllocator only(i);
2657      new (p) Pair(std::move(only), i);
2658    }
2659    template &lt;class U&gt;
2660    struct rebind {
2661      using other = OnlyConstructibleAllocator&lt;U&gt;;
2662    };
2663  };
2664  struct OnlyConstructibleByAllocatorComp {
2665    using is_transparent = void;
2666    bool operator()(OnlyConstructibleByAllocator a,
2667                    OnlyConstructibleByAllocator b) const {
2668      return a.Get() &lt; b.Get();
2669    }
2670    bool operator()(int a, OnlyConstructibleByAllocator b) const {
2671      return a &lt; b.Get();
2672    }
2673    bool operator()(OnlyConstructibleByAllocator a, int b) const {
2674      return a.Get() &lt; b;
2675    }
2676  };
2677  TEST(Btree, OnlyConstructibleByAllocatorType) {
2678    const std::array&lt;int, 2&gt; arr = {3, 4};
2679    {
2680      absl::btree_set&lt;OnlyConstructibleByAllocator,
2681                      OnlyConstructibleByAllocatorComp,
2682                      OnlyConstructibleAllocator&lt;&gt;&gt;
2683          set;
2684      set.emplace(1);
2685      set.emplace_hint(set.end(), 2);
2686      set.insert(arr.begin(), arr.end());
2687      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2688    }
2689    {
2690      absl::btree_multiset&lt;OnlyConstructibleByAllocator,
2691                           OnlyConstructibleByAllocatorComp,
2692                           OnlyConstructibleAllocator&lt;&gt;&gt;
2693          set;
2694      set.emplace(1);
2695      set.emplace_hint(set.end(), 2);
2696      EXPECT_THAT(set, ElementsAre(1, 2));
2697    }
2698    {
2699      absl::btree_map&lt;OnlyConstructibleByAllocator, int,
2700                      OnlyConstructibleByAllocatorComp,
2701                      OnlyConstructibleAllocator&lt;&gt;&gt;
2702          map;
2703      map.emplace(1);
2704      map.emplace_hint(map.end(), 2);
2705      map.insert(arr.begin(), arr.end());
2706      EXPECT_THAT(map,
2707                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2708    }
2709    {
2710      absl::btree_multimap&lt;OnlyConstructibleByAllocator, int,
2711                           OnlyConstructibleByAllocatorComp,
2712                           OnlyConstructibleAllocator&lt;&gt;&gt;
2713          map;
2714      map.emplace(1);
2715      map.emplace_hint(map.end(), 2);
2716      EXPECT_THAT(map, ElementsAre(Pair(1, 1), Pair(2, 2)));
2717    }
2718  }
2719  class NotAssignable {
2720   public:
2721    explicit NotAssignable(int i) : i_(i) {}
2722    NotAssignable(const NotAssignable &amp;other) : i_(other.i_) {}
2723    NotAssignable &amp;operator=(NotAssignable &amp;&amp;other) = delete;
2724    int Get() const { return i_; }
2725    bool operator==(int i) const { return i_ == i; }
2726    friend bool operator&lt;(NotAssignable a, NotAssignable b) {
2727      return a.i_ &lt; b.i_;
2728    }
2729   private:
2730    int i_;
2731  };
2732  TEST(Btree, NotAssignableType) {
2733    {
2734      absl::btree_set&lt;NotAssignable&gt; set;
2735      set.emplace(1);
2736      set.emplace_hint(set.end(), 2);
2737      set.insert(NotAssignable(3));
2738      set.insert(set.end(), NotAssignable(4));
2739      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2740      set.erase(set.begin());
2741      EXPECT_THAT(set, ElementsAre(2, 3, 4));
2742    }
2743    {
2744      absl::btree_multiset&lt;NotAssignable&gt; set;
2745      set.emplace(1);
2746      set.emplace_hint(set.end(), 2);
2747      set.insert(NotAssignable(2));
2748      set.insert(set.end(), NotAssignable(3));
2749      EXPECT_THAT(set, ElementsAre(1, 2, 2, 3));
2750      set.erase(set.begin());
2751      EXPECT_THAT(set, ElementsAre(2, 2, 3));
2752    }
2753    {
2754      absl::btree_map&lt;NotAssignable, int&gt; map;
2755      map.emplace(NotAssignable(1), 1);
2756      map.emplace_hint(map.end(), NotAssignable(2), 2);
2757      map.insert({NotAssignable(3), 3});
2758      map.insert(map.end(), {NotAssignable(4), 4});
2759      EXPECT_THAT(map,
2760                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2761      map.erase(map.begin());
2762      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2763    }
2764    {
2765      absl::btree_multimap&lt;NotAssignable, int&gt; map;
2766      map.emplace(NotAssignable(1), 1);
2767      map.emplace_hint(map.end(), NotAssignable(2), 2);
2768      map.insert({NotAssignable(2), 3});
2769      map.insert(map.end(), {NotAssignable(3), 3});
2770      EXPECT_THAT(map,
2771                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2772      map.erase(map.begin());
2773      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2774    }
2775  }
2776  struct ArenaLike {
2777    void* recycled = nullptr;
2778    size_t recycled_size = 0;
2779  };
2780  template &lt;typename T&gt;
2781  class ArenaLikeAllocator : public std::allocator&lt;T&gt; {
2782   public:
2783    template &lt;typename U&gt;
2784    struct rebind {
2785      using other = ArenaLikeAllocator&lt;U&gt;;
2786    };
2787    explicit ArenaLikeAllocator(ArenaLike* arena) noexcept : arena_(arena) {}
2788    ~ArenaLikeAllocator() {
2789      if (arena_-&gt;recycled != nullptr) {
2790        delete [] static_cast&lt;T*&gt;(arena_-&gt;recycled);
2791        arena_-&gt;recycled = nullptr;
2792      }
2793    }
2794    template&lt;typename U&gt;
2795    explicit ArenaLikeAllocator(const ArenaLikeAllocator&lt;U&gt;&amp; other) noexcept
2796        : arena_(other.arena_) {}
2797    T* allocate(size_t num_objects, const void* = nullptr) {
2798      size_t size = num_objects * sizeof(T);
2799      if (arena_-&gt;recycled != nullptr &amp;&amp; arena_-&gt;recycled_size == size) {
2800        T* result = static_cast&lt;T*&gt;(arena_-&gt;recycled);
2801        arena_-&gt;recycled = nullptr;
2802        return result;
2803      }
2804      return new T[num_objects];
2805    }
2806    void deallocate(T* p, size_t num_objects) {
2807      size_t size = num_objects * sizeof(T);
2808      memset(p, 0xde, size);
2809      if (arena_-&gt;recycled == nullptr) {
2810        arena_-&gt;recycled = p;
2811        arena_-&gt;recycled_size = size;
2812      } else {
2813        delete [] p;
2814      }
2815    }
2816    ArenaLike* arena_;
2817  };
2818  TEST(Btree, ReusePoisonMemory) {
2819    using Alloc = ArenaLikeAllocator&lt;int64_t&gt;;
2820    using Set = absl::btree_set&lt;int64_t, std::less&lt;int64_t&gt;, Alloc&gt;;
2821    ArenaLike arena;
2822    Alloc alloc(&amp;arena);
2823    Set set(alloc);
2824    set.insert(0);
2825    set.erase(0);
2826    set.insert(0);
2827  }
2828  TEST(Btree, IteratorSubtraction) {
2829    absl::BitGen bitgen;
2830    std::vector&lt;int&gt; vec;
2831    for (int i = 0; i &lt; 1000000; ++i) vec.push_back(i);
2832    absl::c_shuffle(vec, bitgen);
2833    absl::btree_set&lt;int&gt; set;
2834    for (int i : vec) set.insert(i);
2835    for (int i = 0; i &lt; 1000; ++i) {
2836      size_t begin = absl::Uniform(bitgen, 0u, set.size());
2837      size_t end = absl::Uniform(bitgen, begin, set.size());
2838      ASSERT_EQ(end - begin, set.find(end) - set.find(begin))
2839          &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end;
2840    }
2841  }
2842  TEST(Btree, DereferencingEndIterator) {
2843    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2844    absl::btree_set&lt;int&gt; set;
2845    for (int i = 0; i &lt; 1000; ++i) set.insert(i);
2846    EXPECT_DEATH(*set.end(), R&quot;regex(Dereferencing end\(\) iterator)regex&quot;);
2847  }
2848  TEST(Btree, InvalidIteratorComparison) {
2849    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2850    absl::btree_set&lt;int&gt; set1, set2;
2851    for (int i = 0; i &lt; 1000; ++i) {
2852      set1.insert(i);
2853      set2.insert(i);
2854    }
2855    constexpr const char *kValueInitDeathMessage =
2856        &quot;Comparing default-constructed iterator with .*non-default-constructed &quot;
2857        &quot;iterator&quot;;
2858    typename absl::btree_set&lt;int&gt;::iterator iter1, iter2;
2859    EXPECT_EQ(iter1, iter2);
2860    EXPECT_DEATH(void(set1.begin() == iter1), kValueInitDeathMessage);
2861    EXPECT_DEATH(void(iter1 == set1.begin()), kValueInitDeathMessage);
2862    constexpr const char *kDifferentContainerDeathMessage =
2863        &quot;Comparing iterators from different containers&quot;;
2864    iter1 = set1.begin();
2865    iter2 = set2.begin();
2866    EXPECT_DEATH(void(iter1 == iter2), kDifferentContainerDeathMessage);
2867    EXPECT_DEATH(void(iter2 == iter1), kDifferentContainerDeathMessage);
2868  }
2869  TEST(Btree, InvalidPointerUse) {
2870    if (!kAsan)
2871      GTEST_SKIP() &lt;&lt; &quot;We only detect invalid pointer use in ASan mode.&quot;;
2872    absl::btree_set&lt;int&gt; set;
2873    set.insert(0);
2874    const int *ptr = &amp;*set.begin();
2875    set.insert(1);
2876    EXPECT_DEATH(std::cout &lt;&lt; *ptr, &quot;heap-use-after-free&quot;);
2877    size_t slots_per_node = BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set)&gt;();
2878    for (int i = 2; i &lt; slots_per_node - 1; ++i) set.insert(i);
2879    ptr = &amp;*set.begin();
2880    set.insert(static_cast&lt;int&gt;(slots_per_node));
2881    EXPECT_DEATH(std::cout &lt;&lt; *ptr, &quot;heap-use-after-free&quot;);
2882  }
2883  template&lt;typename Set&gt;
2884  void TestBasicFunctionality(Set set) {
2885    using value_type = typename Set::value_type;
2886    for (int i = 0; i &lt; 100; ++i) { set.insert(value_type(i)); }
2887    for (int i = 50; i &lt; 100; ++i) { set.erase(value_type(i)); }
2888    auto it = set.begin();
2889    for (int i = 0; i &lt; 50; ++i, ++it) {
2890      ASSERT_EQ(set.find(value_type(i)), it) &lt;&lt; i;
2891    }
2892  }
2893  template&lt;size_t align&gt;
2894  struct alignas(align) OveralignedKey {
2895    explicit OveralignedKey(int i) : key(i) {}
2896    bool operator&lt;(const OveralignedKey &amp;other) const { return key &lt; other.key; }
2897    int key = 0;
2898  };
2899  TEST(Btree, OveralignedKey) {
2900    TestBasicFunctionality(
2901        SizedBtreeSet&lt;OveralignedKey&lt;16&gt;, &amp;bsol;*TargetValuesPerNode=*/8&gt;());
2902    TestBasicFunctionality(
2903        SizedBtreeSet&lt;OveralignedKey&lt;16&gt;, &amp;bsol;*TargetValuesPerNode=*/9&gt;());
2904  }
2905  TEST(Btree, FieldTypeEqualsSlotType) {
2906    using set_type = absl::btree_set&lt;uint8_t&gt;;
2907    static_assert(BtreeNodePeer::FieldTypeEqualsSlotType&lt;set_type&gt;(), &quot;&quot;);
2908    TestBasicFunctionality(set_type());
2909  }
2910  }  
2911  }  
2912  ABSL_NAMESPACE_END
2913  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</h3>
            <pre><code>1  #include &quot;absl/container/btree_test.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;array&gt;
4  #include &lt;cstdint&gt;
5  #include &lt;functional&gt;
6  #include &lt;iostream&gt;
7  #include &lt;iterator&gt;
8  #include &lt;limits&gt;
9  #include &lt;map&gt;
10  #include &lt;memory&gt;
11  #include &lt;numeric&gt;
12  #include &lt;stdexcept&gt;
13  #include &lt;string&gt;
14  #include &lt;type_traits&gt;
15  #include &lt;utility&gt;
16  #include &lt;vector&gt;
17  #include &quot;gmock/gmock.h&quot;
18  #include &quot;gtest/gtest.h&quot;
19  #include &quot;absl/algorithm/container.h&quot;
20  #include &quot;absl/base/internal/raw_logging.h&quot;
21  #include &quot;absl/base/macros.h&quot;
22  #include &quot;absl/container/btree_map.h&quot;
23  #include &quot;absl/container/btree_set.h&quot;
24  #include &quot;absl/container/internal/counting_allocator.h&quot;
25  #include &quot;absl/container/internal/test_instance_tracker.h&quot;
26  #include &quot;absl/flags/flag.h&quot;
27  #include &quot;absl/hash/hash_testing.h&quot;
28  #include &quot;absl/memory/memory.h&quot;
29  #include &quot;absl/random/random.h&quot;
30  #include &quot;absl/strings/str_cat.h&quot;
31  #include &quot;absl/strings/str_split.h&quot;
32  #include &quot;absl/strings/string_view.h&quot;
33  #include &quot;absl/types/compare.h&quot;
34  #include &quot;absl/types/optional.h&quot;
35  ABSL_FLAG(int, test_values, 10000, &quot;The number of values to use for tests&quot;);
36  namespace absl {
37  ABSL_NAMESPACE_BEGIN
38  namespace container_internal {
39  namespace {
40  using ::absl::test_internal::CopyableMovableInstance;
41  using ::absl::test_internal::InstanceTracker;
42  using ::absl::test_internal::MovableOnlyInstance;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::IsEmpty;
46  using ::testing::IsNull;
47  using ::testing::Pair;
48  using ::testing::SizeIs;
49  template &lt;typename T, typename U&gt;
50  void CheckPairEquals(const T &amp;x, const U &amp;y) {
51    ABSL_INTERNAL_CHECK(x == y, &quot;Values are unequal.&quot;);
52  }
53  template &lt;typename T, typename U, typename V, typename W&gt;
54  void CheckPairEquals(const std::pair&lt;T, U&gt; &amp;x, const std::pair&lt;V, W&gt; &amp;y) {
55    CheckPairEquals(x.first, y.first);
56    CheckPairEquals(x.second, y.second);
57  }
58  bool IsAssertEnabled() {
59    bool assert_enabled = false;
60    assert([&amp;]() {  
61      assert_enabled = true;
62      return true;
63    }());
64    return assert_enabled;
65  }
66  }  
67  template &lt;typename TreeType, typename CheckerType&gt;
68  class base_checker {
69   public:
70    using key_type = typename TreeType::key_type;
71    using value_type = typename TreeType::value_type;
72    using key_compare = typename TreeType::key_compare;
73    using pointer = typename TreeType::pointer;
74    using const_pointer = typename TreeType::const_pointer;
75    using reference = typename TreeType::reference;
76    using const_reference = typename TreeType::const_reference;
77    using size_type = typename TreeType::size_type;
78    using difference_type = typename TreeType::difference_type;
79    using iterator = typename TreeType::iterator;
80    using const_iterator = typename TreeType::const_iterator;
81    using reverse_iterator = typename TreeType::reverse_iterator;
82    using const_reverse_iterator = typename TreeType::const_reverse_iterator;
83   public:
84    base_checker() : const_tree_(tree_) {}
85    base_checker(const base_checker &amp;other)
86        : tree_(other.tree_), const_tree_(tree_), checker_(other.checker_) {}
87    template &lt;typename InputIterator&gt;
88    base_checker(InputIterator b, InputIterator e)
89        : tree_(b, e), const_tree_(tree_), checker_(b, e) {}
90    iterator begin() { return tree_.begin(); }
91    const_iterator begin() const { return tree_.begin(); }
92    iterator end() { return tree_.end(); }
93    const_iterator end() const { return tree_.end(); }
94    reverse_iterator rbegin() { return tree_.rbegin(); }
95    const_reverse_iterator rbegin() const { return tree_.rbegin(); }
96    reverse_iterator rend() { return tree_.rend(); }
97    const_reverse_iterator rend() const { return tree_.rend(); }
98    template &lt;typename IterType, typename CheckerIterType&gt;
99    IterType iter_check(IterType tree_iter, CheckerIterType checker_iter) const {
100      if (tree_iter == tree_.end()) {
101        ABSL_INTERNAL_CHECK(checker_iter == checker_.end(),
102                            &quot;Checker iterator not at end.&quot;);
103      } else {
104        CheckPairEquals(*tree_iter, *checker_iter);
105      }
106      return tree_iter;
107    }
108    template &lt;typename IterType, typename CheckerIterType&gt;
109    IterType riter_check(IterType tree_iter, CheckerIterType checker_iter) const {
110      if (tree_iter == tree_.rend()) {
111        ABSL_INTERNAL_CHECK(checker_iter == checker_.rend(),
112                            &quot;Checker iterator not at rend.&quot;);
113      } else {
114        CheckPairEquals(*tree_iter, *checker_iter);
115      }
116      return tree_iter;
117    }
118    void value_check(const value_type &amp;v) {
119      typename KeyOfValue&lt;typename TreeType::key_type,
120                          typename TreeType::value_type&gt;::type key_of_value;
121      const key_type &amp;key = key_of_value(v);
122      CheckPairEquals(*find(key), v);
123      lower_bound(key);
124      upper_bound(key);
125      equal_range(key);
126      contains(key);
127      count(key);
128    }
129    void erase_check(const key_type &amp;key) {
130      EXPECT_FALSE(tree_.contains(key));
131      EXPECT_EQ(tree_.find(key), const_tree_.end());
132      EXPECT_FALSE(const_tree_.contains(key));
133      EXPECT_EQ(const_tree_.find(key), tree_.end());
134      EXPECT_EQ(tree_.equal_range(key).first,
135                const_tree_.equal_range(key).second);
136    }
137    iterator lower_bound(const key_type &amp;key) {
138      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
139    }
140    const_iterator lower_bound(const key_type &amp;key) const {
141      return iter_check(tree_.lower_bound(key), checker_.lower_bound(key));
142    }
143    iterator upper_bound(const key_type &amp;key) {
144      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
145    }
146    const_iterator upper_bound(const key_type &amp;key) const {
147      return iter_check(tree_.upper_bound(key), checker_.upper_bound(key));
148    }
149    std::pair&lt;iterator, iterator&gt; equal_range(const key_type &amp;key) {
150      std::pair&lt;typename CheckerType::iterator, typename CheckerType::iterator&gt;
151          checker_res = checker_.equal_range(key);
152      std::pair&lt;iterator, iterator&gt; tree_res = tree_.equal_range(key);
153      iter_check(tree_res.first, checker_res.first);
154      iter_check(tree_res.second, checker_res.second);
155      return tree_res;
156    }
157    std::pair&lt;const_iterator, const_iterator&gt; equal_range(
158        const key_type &amp;key) const {
159      std::pair&lt;typename CheckerType::const_iterator,
160                typename CheckerType::const_iterator&gt;
161          checker_res = checker_.equal_range(key);
162      std::pair&lt;const_iterator, const_iterator&gt; tree_res = tree_.equal_range(key);
163      iter_check(tree_res.first, checker_res.first);
164      iter_check(tree_res.second, checker_res.second);
165      return tree_res;
166    }
167    iterator find(const key_type &amp;key) {
168      return iter_check(tree_.find(key), checker_.find(key));
169    }
170    const_iterator find(const key_type &amp;key) const {
171      return iter_check(tree_.find(key), checker_.find(key));
172    }
173    bool contains(const key_type &amp;key) const { return find(key) != end(); }
174    size_type count(const key_type &amp;key) const {
175      size_type res = checker_.count(key);
176      EXPECT_EQ(res, tree_.count(key));
177      return res;
178    }
179    base_checker &amp;operator=(const base_checker &amp;other) {
180      tree_ = other.tree_;
181      checker_ = other.checker_;
182      return *this;
183    }
184    int erase(const key_type &amp;key) {
185      int size = tree_.size();
186      int res = checker_.erase(key);
187      EXPECT_EQ(res, tree_.count(key));
188      EXPECT_EQ(res, tree_.erase(key));
189      EXPECT_EQ(tree_.count(key), 0);
190      EXPECT_EQ(tree_.size(), size - res);
191      erase_check(key);
192      return res;
193    }
194    iterator erase(iterator iter) {
195      key_type key = iter.key();
196      int size = tree_.size();
197      int count = tree_.count(key);
198      auto checker_iter = checker_.lower_bound(key);
199      for (iterator tmp(tree_.lower_bound(key)); tmp != iter; ++tmp) {
200        ++checker_iter;
201      }
202      auto checker_next = checker_iter;
203      ++checker_next;
204      checker_.erase(checker_iter);
205      iter = tree_.erase(iter);
206      EXPECT_EQ(tree_.size(), checker_.size());
207      EXPECT_EQ(tree_.size(), size - 1);
208      EXPECT_EQ(tree_.count(key), count - 1);
209      if (count == 1) {
210        erase_check(key);
211      }
212      return iter_check(iter, checker_next);
213    }
214    void erase(iterator begin, iterator end) {
215      int size = tree_.size();
216      int count = std::distance(begin, end);
217      auto checker_begin = checker_.lower_bound(begin.key());
218      for (iterator tmp(tree_.lower_bound(begin.key())); tmp != begin; ++tmp) {
219        ++checker_begin;
220      }
221      auto checker_end =
222          end == tree_.end() ? checker_.end() : checker_.lower_bound(end.key());
223      if (end != tree_.end()) {
224        for (iterator tmp(tree_.lower_bound(end.key())); tmp != end; ++tmp) {
225          ++checker_end;
226        }
227      }
228      const auto checker_ret = checker_.erase(checker_begin, checker_end);
229      const auto tree_ret = tree_.erase(begin, end);
230      EXPECT_EQ(std::distance(checker_.begin(), checker_ret),
231                std::distance(tree_.begin(), tree_ret));
232      EXPECT_EQ(tree_.size(), checker_.size());
233      EXPECT_EQ(tree_.size(), size - count);
234    }
235    void clear() {
236      tree_.clear();
237      checker_.clear();
238    }
239    void swap(base_checker &amp;other) {
240      tree_.swap(other.tree_);
241      checker_.swap(other.checker_);
242    }
243    void verify() const {
244      tree_.verify();
245      EXPECT_EQ(tree_.size(), checker_.size());
246      auto checker_iter = checker_.begin();
247      const_iterator tree_iter(tree_.begin());
248      for (; tree_iter != tree_.end(); ++tree_iter, ++checker_iter) {
249        CheckPairEquals(*tree_iter, *checker_iter);
250      }
251      for (int n = tree_.size() - 1; n &gt;= 0; --n) {
252        iter_check(tree_iter, checker_iter);
253        --tree_iter;
254        --checker_iter;
255      }
256      EXPECT_EQ(tree_iter, tree_.begin());
257      EXPECT_EQ(checker_iter, checker_.begin());
258      auto checker_riter = checker_.rbegin();
259      const_reverse_iterator tree_riter(tree_.rbegin());
260      for (; tree_riter != tree_.rend(); ++tree_riter, ++checker_riter) {
261        CheckPairEquals(*tree_riter, *checker_riter);
262      }
263      for (int n = tree_.size() - 1; n &gt;= 0; --n) {
264        riter_check(tree_riter, checker_riter);
265        --tree_riter;
266        --checker_riter;
267      }
268      EXPECT_EQ(tree_riter, tree_.rbegin());
269      EXPECT_EQ(checker_riter, checker_.rbegin());
270    }
271    const TreeType &amp;tree() const { return tree_; }
272    size_type size() const {
273      EXPECT_EQ(tree_.size(), checker_.size());
274      return tree_.size();
275    }
276    size_type max_size() const { return tree_.max_size(); }
277    bool empty() const {
278      EXPECT_EQ(tree_.empty(), checker_.empty());
279      return tree_.empty();
280    }
281   protected:
282    TreeType tree_;
283    const TreeType &amp;const_tree_;
284    CheckerType checker_;
285  };
286  namespace {
287  template &lt;typename TreeType, typename CheckerType&gt;
288  class unique_checker : public base_checker&lt;TreeType, CheckerType&gt; {
289    using super_type = base_checker&lt;TreeType, CheckerType&gt;;
290   public:
291    using iterator = typename super_type::iterator;
292    using value_type = typename super_type::value_type;
293   public:
294    unique_checker() : super_type() {}
295    unique_checker(const unique_checker &amp;other) : super_type(other) {}
296    template &lt;class InputIterator&gt;
297    unique_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
298    unique_checker &amp;operator=(const unique_checker &amp;) = default;
299    std::pair&lt;iterator, bool&gt; insert(const value_type &amp;v) {
300      int size = this-&gt;tree_.size();
301      std::pair&lt;typename CheckerType::iterator, bool&gt; checker_res =
302          this-&gt;checker_.insert(v);
303      std::pair&lt;iterator, bool&gt; tree_res = this-&gt;tree_.insert(v);
304      CheckPairEquals(*tree_res.first, *checker_res.first);
305      EXPECT_EQ(tree_res.second, checker_res.second);
306      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
307      EXPECT_EQ(this-&gt;tree_.size(), size + tree_res.second);
308      return tree_res;
309    }
310    iterator insert(iterator position, const value_type &amp;v) {
311      int size = this-&gt;tree_.size();
312      std::pair&lt;typename CheckerType::iterator, bool&gt; checker_res =
313          this-&gt;checker_.insert(v);
314      iterator tree_res = this-&gt;tree_.insert(position, v);
315      CheckPairEquals(*tree_res, *checker_res.first);
316      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
317      EXPECT_EQ(this-&gt;tree_.size(), size + checker_res.second);
318      return tree_res;
319    }
320    template &lt;typename InputIterator&gt;
321    void insert(InputIterator b, InputIterator e) {
322      for (; b != e; ++b) {
323        insert(*b);
324      }
325    }
326  };
327  template &lt;typename TreeType, typename CheckerType&gt;
328  class multi_checker : public base_checker&lt;TreeType, CheckerType&gt; {
329    using super_type = base_checker&lt;TreeType, CheckerType&gt;;
330   public:
331    using iterator = typename super_type::iterator;
332    using value_type = typename super_type::value_type;
333   public:
334    multi_checker() : super_type() {}
335    multi_checker(const multi_checker &amp;other) : super_type(other) {}
336    template &lt;class InputIterator&gt;
337    multi_checker(InputIterator b, InputIterator e) : super_type(b, e) {}
338    multi_checker &amp;operator=(const multi_checker &amp;) = default;
339    iterator insert(const value_type &amp;v) {
340      int size = this-&gt;tree_.size();
341      auto checker_res = this-&gt;checker_.insert(v);
342      iterator tree_res = this-&gt;tree_.insert(v);
343      CheckPairEquals(*tree_res, *checker_res);
344      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
345      EXPECT_EQ(this-&gt;tree_.size(), size + 1);
346      return tree_res;
<span onclick='openModal()' class='match'>347    }
348    iterator insert(iterator position, const value_type &amp;v) {
349      int size = this-&gt;tree_.size();
350      auto checker_res = this-&gt;checker_.insert(v);
</span>351      iterator tree_res = this-&gt;tree_.insert(position, v);
352      CheckPairEquals(*tree_res, *checker_res);
353      EXPECT_EQ(this-&gt;tree_.size(), this-&gt;checker_.size());
354      EXPECT_EQ(this-&gt;tree_.size(), size + 1);
355      return tree_res;
356    }
357    template &lt;typename InputIterator&gt;
358    void insert(InputIterator b, InputIterator e) {
359      for (; b != e; ++b) {
360        insert(*b);
361      }
362    }
363  };
364  template &lt;typename T, typename V&gt;
365  void DoTest(const char *name, T *b, const std::vector&lt;V&gt; &amp;values) {
366    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
367    T &amp;mutable_b = *b;
368    const T &amp;const_b = *b;
369    for (int i = 0; i &lt; values.size(); ++i) {
370      mutable_b.insert(values[i]);
371      mutable_b.value_check(values[i]);
372    }
373    ASSERT_EQ(mutable_b.size(), values.size());
374    const_b.verify();
375    T b_copy(const_b);
376    EXPECT_EQ(b_copy.size(), const_b.size());
377    for (int i = 0; i &lt; values.size(); ++i) {
378      CheckPairEquals(*b_copy.find(key_of_value(values[i])), values[i]);
379    }
380    T b_range(const_b.begin(), const_b.end());
381    EXPECT_EQ(b_range.size(), const_b.size());
382    for (int i = 0; i &lt; values.size(); ++i) {
383      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
384    }
385    b_range.insert(b_copy.begin(), b_copy.end());
386    b_range.verify();
387    b_range.clear();
388    b_range.insert(b_copy.begin(), b_copy.end());
389    EXPECT_EQ(b_range.size(), b_copy.size());
390    for (int i = 0; i &lt; values.size(); ++i) {
391      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
392    }
393    b_range.operator=(b_range);
394    EXPECT_EQ(b_range.size(), b_copy.size());
395    b_range.clear();
396    b_range = b_copy;
397    EXPECT_EQ(b_range.size(), b_copy.size());
398    b_range.clear();
399    b_range.swap(b_copy);
400    EXPECT_EQ(b_copy.size(), 0);
401    EXPECT_EQ(b_range.size(), const_b.size());
402    for (int i = 0; i &lt; values.size(); ++i) {
403      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
404    }
405    b_range.swap(b_copy);
406    swap(b_range, b_copy);
407    EXPECT_EQ(b_copy.size(), 0);
408    EXPECT_EQ(b_range.size(), const_b.size());
409    for (int i = 0; i &lt; values.size(); ++i) {
410      CheckPairEquals(*b_range.find(key_of_value(values[i])), values[i]);
411    }
412    swap(b_range, b_copy);
413    for (int i = 0; i &lt; values.size(); ++i) {
414      mutable_b.erase(key_of_value(values[i]));
415      ASSERT_EQ(mutable_b.erase(key_of_value(values[i])), 0);
416    }
417    const_b.verify();
418    EXPECT_EQ(const_b.size(), 0);
419    mutable_b = b_copy;
420    for (int i = 0; i &lt; values.size(); ++i) {
421      mutable_b.erase(mutable_b.find(key_of_value(values[i])));
422    }
423    const_b.verify();
424    EXPECT_EQ(const_b.size(), 0);
425    for (int i = 0; i &lt; values.size(); i++) {
426      mutable_b.insert(mutable_b.upper_bound(key_of_value(values[i])), values[i]);
427    }
428    const_b.verify();
429    mutable_b.erase(mutable_b.begin(), mutable_b.end());
430    EXPECT_EQ(mutable_b.size(), 0);
431    const_b.verify();
432    mutable_b = b_copy;
433    typename T::iterator mutable_iter_end = mutable_b.begin();
434    for (int i = 0; i &lt; values.size() / 2; ++i) ++mutable_iter_end;
435    mutable_b.erase(mutable_b.begin(), mutable_iter_end);
436    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 2);
437    const_b.verify();
438    mutable_b = b_copy;
439    typename T::iterator mutable_iter_begin = mutable_b.begin();
440    for (int i = 0; i &lt; values.size() / 2; ++i) ++mutable_iter_begin;
441    mutable_b.erase(mutable_iter_begin, mutable_b.end());
442    EXPECT_EQ(mutable_b.size(), values.size() / 2);
443    const_b.verify();
444    mutable_b = b_copy;
445    mutable_iter_begin = mutable_b.begin();
446    for (int i = 0; i &lt; values.size() / 4; ++i) ++mutable_iter_begin;
447    mutable_iter_end = mutable_iter_begin;
448    for (int i = 0; i &lt; values.size() / 4; ++i) ++mutable_iter_end;
449    mutable_b.erase(mutable_iter_begin, mutable_iter_end);
450    EXPECT_EQ(mutable_b.size(), values.size() - values.size() / 4);
451    const_b.verify();
452    mutable_b.clear();
453  }
454  template &lt;typename T&gt;
455  void ConstTest() {
456    using value_type = typename T::value_type;
457    typename KeyOfValue&lt;typename T::key_type, value_type&gt;::type key_of_value;
458    T mutable_b;
459    const T &amp;const_b = mutable_b;
460    value_type value = Generator&lt;value_type&gt;(2)(2);
461    mutable_b.insert(value);
462    EXPECT_TRUE(mutable_b.contains(key_of_value(value)));
463    EXPECT_NE(mutable_b.find(key_of_value(value)), const_b.end());
464    EXPECT_TRUE(const_b.contains(key_of_value(value)));
465    EXPECT_NE(const_b.find(key_of_value(value)), mutable_b.end());
466    EXPECT_EQ(*const_b.lower_bound(key_of_value(value)), value);
467    EXPECT_EQ(const_b.upper_bound(key_of_value(value)), const_b.end());
468    EXPECT_EQ(*const_b.equal_range(key_of_value(value)).first, value);
469    typename T::iterator mutable_iter(mutable_b.begin());
470    EXPECT_EQ(mutable_iter, const_b.begin());
471    EXPECT_NE(mutable_iter, const_b.end());
472    EXPECT_EQ(const_b.begin(), mutable_iter);
473    EXPECT_NE(const_b.end(), mutable_iter);
474    typename T::reverse_iterator mutable_riter(mutable_b.rbegin());
475    EXPECT_EQ(mutable_riter, const_b.rbegin());
476    EXPECT_NE(mutable_riter, const_b.rend());
477    EXPECT_EQ(const_b.rbegin(), mutable_riter);
478    EXPECT_NE(const_b.rend(), mutable_riter);
479    typename T::const_iterator const_iter(mutable_iter);
480    EXPECT_EQ(const_iter, mutable_b.begin());
481    EXPECT_NE(const_iter, mutable_b.end());
482    EXPECT_EQ(mutable_b.begin(), const_iter);
483    EXPECT_NE(mutable_b.end(), const_iter);
484    typename T::const_reverse_iterator const_riter(mutable_riter);
485    EXPECT_EQ(const_riter, mutable_b.rbegin());
486    EXPECT_NE(const_riter, mutable_b.rend());
487    EXPECT_EQ(mutable_b.rbegin(), const_riter);
488    EXPECT_NE(mutable_b.rend(), const_riter);
489    const_b.verify();
490    ASSERT_TRUE(!const_b.empty());
491    EXPECT_EQ(const_b.size(), 1);
492    EXPECT_GT(const_b.max_size(), 0);
493    EXPECT_TRUE(const_b.contains(key_of_value(value)));
494    EXPECT_EQ(const_b.count(key_of_value(value)), 1);
495  }
496  template &lt;typename T, typename C&gt;
497  void BtreeTest() {
498    ConstTest&lt;T&gt;();
499    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
500    const std::vector&lt;V&gt; random_values = GenerateValuesWithSeed&lt;V&gt;(
501        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
502        GTEST_FLAG_GET(random_seed));
503    unique_checker&lt;T, C&gt; container;
504    std::vector&lt;V&gt; sorted_values(random_values);
505    std::sort(sorted_values.begin(), sorted_values.end());
506    DoTest(&quot;sorted:    &quot;, &amp;container, sorted_values);
507    std::reverse(sorted_values.begin(), sorted_values.end());
508    DoTest(&quot;rsorted:   &quot;, &amp;container, sorted_values);
509    DoTest(&quot;random:    &quot;, &amp;container, random_values);
510  }
511  template &lt;typename T, typename C&gt;
512  void BtreeMultiTest() {
513    ConstTest&lt;T&gt;();
514    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
515    const std::vector&lt;V&gt; random_values = GenerateValuesWithSeed&lt;V&gt;(
516        absl::GetFlag(FLAGS_test_values), 4 * absl::GetFlag(FLAGS_test_values),
517        GTEST_FLAG_GET(random_seed));
518    multi_checker&lt;T, C&gt; container;
519    std::vector&lt;V&gt; sorted_values(random_values);
520    std::sort(sorted_values.begin(), sorted_values.end());
521    DoTest(&quot;sorted:    &quot;, &amp;container, sorted_values);
522    std::reverse(sorted_values.begin(), sorted_values.end());
523    DoTest(&quot;rsorted:   &quot;, &amp;container, sorted_values);
524    DoTest(&quot;random:    &quot;, &amp;container, random_values);
525    std::vector&lt;V&gt; duplicate_values(random_values);
526    duplicate_values.insert(duplicate_values.end(), random_values.begin(),
527                            random_values.end());
528    DoTest(&quot;duplicates:&quot;, &amp;container, duplicate_values);
529    std::vector&lt;V&gt; identical_values(100);
530    std::fill(identical_values.begin(), identical_values.end(),
531              Generator&lt;V&gt;(2)(2));
532    DoTest(&quot;identical: &quot;, &amp;container, identical_values);
533  }
534  template &lt;typename T&gt;
535  struct PropagatingCountingAlloc : public CountingAllocator&lt;T&gt; {
536    using propagate_on_container_copy_assignment = std::true_type;
537    using propagate_on_container_move_assignment = std::true_type;
538    using propagate_on_container_swap = std::true_type;
539    using Base = CountingAllocator&lt;T&gt;;
540    using Base::Base;
541    template &lt;typename U&gt;
542    explicit PropagatingCountingAlloc(const PropagatingCountingAlloc&lt;U&gt; &amp;other)
543        : Base(other.bytes_used_) {}
544    template &lt;typename U&gt;
545    struct rebind {
546      using other = PropagatingCountingAlloc&lt;U&gt;;
547    };
548  };
549  template &lt;typename T&gt;
550  void BtreeAllocatorTest() {
551    using value_type = typename T::value_type;
552    int64_t bytes1 = 0, bytes2 = 0;
553    PropagatingCountingAlloc&lt;T&gt; allocator1(&amp;bytes1);
554    PropagatingCountingAlloc&lt;T&gt; allocator2(&amp;bytes2);
555    Generator&lt;value_type&gt; generator(1000);
556    auto unused1 = allocator1.allocate(1);
557    auto unused2 = allocator2.allocate(1);
558    {
559      T b1(typename T::key_compare(), allocator1);
560      T b2(typename T::key_compare(), allocator2);
561      int64_t original_bytes1 = bytes1;
562      b1.insert(generator(0));
563      EXPECT_GT(bytes1, original_bytes1);
564      b1 = b2;
565      EXPECT_EQ(b1.size(), 0);
566      EXPECT_EQ(b2.size(), 0);
567      EXPECT_EQ(bytes1, original_bytes1);
568      for (int i = 1; i &lt; 1000; i++) {
569        b1.insert(generator(i));
570      }
571      EXPECT_GT(bytes2, bytes1);
572    }
573    {
574      T b1(typename T::key_compare(), allocator1);
575      T b2(typename T::key_compare(), allocator2);
576      int64_t original_bytes1 = bytes1;
577      b1.insert(generator(0));
578      EXPECT_GT(bytes1, original_bytes1);
579      b1 = std::move(b2);
580      EXPECT_EQ(b1.size(), 0);
581      EXPECT_EQ(bytes1, original_bytes1);
582      for (int i = 1; i &lt; 1000; i++) {
583        b1.insert(generator(i));
584      }
585      EXPECT_GT(bytes2, bytes1);
586    }
587    {
588      T b1(typename T::key_compare(), allocator1);
589      T b2(typename T::key_compare(), allocator2);
590      int64_t original_bytes1 = bytes1;
591      b1.insert(generator(0));
592      EXPECT_GT(bytes1, original_bytes1);
593      swap(b1, b2);
594      EXPECT_EQ(b1.size(), 0);
595      EXPECT_EQ(b2.size(), 1);
596      EXPECT_GT(bytes1, original_bytes1);
597      for (int i = 1; i &lt; 1000; i++) {
598        b1.insert(generator(i));
599      }
600      EXPECT_GT(bytes2, bytes1);
601    }
602    allocator1.deallocate(unused1, 1);
603    allocator2.deallocate(unused2, 1);
604  }
605  template &lt;typename T&gt;
606  void BtreeMapTest() {
607    using value_type = typename T::value_type;
608    using mapped_type = typename T::mapped_type;
609    mapped_type m = Generator&lt;mapped_type&gt;(0)(0);
610    (void)m;
611    T b;
612    for (int i = 0; i &lt; 1000; i++) {
613      value_type v = Generator&lt;value_type&gt;(1000)(i);
614      b[v.first] = v.second;
615    }
616    EXPECT_EQ(b.size(), 1000);
617    EXPECT_EQ(b.begin()-&gt;first, Generator&lt;value_type&gt;(1000)(0).first);
618    EXPECT_EQ(b.begin()-&gt;second, Generator&lt;value_type&gt;(1000)(0).second);
619    EXPECT_EQ(b.rbegin()-&gt;first, Generator&lt;value_type&gt;(1000)(999).first);
620    EXPECT_EQ(b.rbegin()-&gt;second, Generator&lt;value_type&gt;(1000)(999).second);
621  }
622  template &lt;typename T&gt;
623  void BtreeMultiMapTest() {
624    using mapped_type = typename T::mapped_type;
625    mapped_type m = Generator&lt;mapped_type&gt;(0)(0);
626    (void)m;
627  }
628  template &lt;typename K, int N = 256&gt;
629  void SetTest() {
630    EXPECT_EQ(
631        sizeof(absl::btree_set&lt;K&gt;),
632        2 * sizeof(void *) + sizeof(typename absl::btree_set&lt;K&gt;::size_type));
633    using BtreeSet = absl::btree_set&lt;K&gt;;
634    using CountingBtreeSet =
635        absl::btree_set&lt;K, std::less&lt;K&gt;, PropagatingCountingAlloc&lt;K&gt;&gt;;
636    BtreeTest&lt;BtreeSet, std::set&lt;K&gt;&gt;();
637    BtreeAllocatorTest&lt;CountingBtreeSet&gt;();
638  }
639  template &lt;typename K, int N = 256&gt;
640  void MapTest() {
641    EXPECT_EQ(
642        sizeof(absl::btree_map&lt;K, K&gt;),
643        2 * sizeof(void *) + sizeof(typename absl::btree_map&lt;K, K&gt;::size_type));
644    using BtreeMap = absl::btree_map&lt;K, K&gt;;
645    using CountingBtreeMap =
646        absl::btree_map&lt;K, K, std::less&lt;K&gt;,
647                        PropagatingCountingAlloc&lt;std::pair&lt;const K, K&gt;&gt;&gt;;
648    BtreeTest&lt;BtreeMap, std::map&lt;K, K&gt;&gt;();
649    BtreeAllocatorTest&lt;CountingBtreeMap&gt;();
650    BtreeMapTest&lt;BtreeMap&gt;();
651  }
652  TEST(Btree, set_int32) { SetTest&lt;int32_t&gt;(); }
653  TEST(Btree, set_int64) { SetTest&lt;int64_t&gt;(); }
654  TEST(Btree, set_string) { SetTest&lt;std::string&gt;(); }
655  TEST(Btree, set_cord) { SetTest&lt;absl::Cord&gt;(); }
656  TEST(Btree, set_pair) { SetTest&lt;std::pair&lt;int, int&gt;&gt;(); }
657  TEST(Btree, map_int32) { MapTest&lt;int32_t&gt;(); }
658  TEST(Btree, map_int64) { MapTest&lt;int64_t&gt;(); }
659  TEST(Btree, map_string) { MapTest&lt;std::string&gt;(); }
660  TEST(Btree, map_cord) { MapTest&lt;absl::Cord&gt;(); }
661  TEST(Btree, map_pair) { MapTest&lt;std::pair&lt;int, int&gt;&gt;(); }
662  template &lt;typename K, int N = 256&gt;
663  void MultiSetTest() {
664    EXPECT_EQ(
665        sizeof(absl::btree_multiset&lt;K&gt;),
666        2 * sizeof(void *) + sizeof(typename absl::btree_multiset&lt;K&gt;::size_type));
667    using BtreeMSet = absl::btree_multiset&lt;K&gt;;
668    using CountingBtreeMSet =
669        absl::btree_multiset&lt;K, std::less&lt;K&gt;, PropagatingCountingAlloc&lt;K&gt;&gt;;
670    BtreeMultiTest&lt;BtreeMSet, std::multiset&lt;K&gt;&gt;();
671    BtreeAllocatorTest&lt;CountingBtreeMSet&gt;();
672  }
673  template &lt;typename K, int N = 256&gt;
674  void MultiMapTest() {
675    EXPECT_EQ(sizeof(absl::btree_multimap&lt;K, K&gt;),
676              2 * sizeof(void *) +
677                  sizeof(typename absl::btree_multimap&lt;K, K&gt;::size_type));
678    using BtreeMMap = absl::btree_multimap&lt;K, K&gt;;
679    using CountingBtreeMMap =
680        absl::btree_multimap&lt;K, K, std::less&lt;K&gt;,
681                             PropagatingCountingAlloc&lt;std::pair&lt;const K, K&gt;&gt;&gt;;
682    BtreeMultiTest&lt;BtreeMMap, std::multimap&lt;K, K&gt;&gt;();
683    BtreeMultiMapTest&lt;BtreeMMap&gt;();
684    BtreeAllocatorTest&lt;CountingBtreeMMap&gt;();
685  }
686  TEST(Btree, multiset_int32) { MultiSetTest&lt;int32_t&gt;(); }
687  TEST(Btree, multiset_int64) { MultiSetTest&lt;int64_t&gt;(); }
688  TEST(Btree, multiset_string) { MultiSetTest&lt;std::string&gt;(); }
689  TEST(Btree, multiset_cord) { MultiSetTest&lt;absl::Cord&gt;(); }
690  TEST(Btree, multiset_pair) { MultiSetTest&lt;std::pair&lt;int, int&gt;&gt;(); }
691  TEST(Btree, multimap_int32) { MultiMapTest&lt;int32_t&gt;(); }
692  TEST(Btree, multimap_int64) { MultiMapTest&lt;int64_t&gt;(); }
693  TEST(Btree, multimap_string) { MultiMapTest&lt;std::string&gt;(); }
694  TEST(Btree, multimap_cord) { MultiMapTest&lt;absl::Cord&gt;(); }
695  TEST(Btree, multimap_pair) { MultiMapTest&lt;std::pair&lt;int, int&gt;&gt;(); }
696  struct CompareIntToString {
697    bool operator()(const std::string &amp;a, const std::string &amp;b) const {
698      return a &lt; b;
699    }
700    bool operator()(const std::string &amp;a, int b) const {
701      return a &lt; absl::StrCat(b);
702    }
703    bool operator()(int a, const std::string &amp;b) const {
704      return absl::StrCat(a) &lt; b;
705    }
706    using is_transparent = void;
707  };
708  struct NonTransparentCompare {
709    template &lt;typename T, typename U&gt;
710    bool operator()(const T &amp;t, const U &amp;u) const {
711      EXPECT_TRUE((std::is_same&lt;T, U&gt;()));
712      return t &lt; u;
713    }
714  };
715  template &lt;typename T&gt;
716  bool CanEraseWithEmptyBrace(T t, decltype(t.erase({})) *) {
717    return true;
718  }
719  template &lt;typename T&gt;
720  bool CanEraseWithEmptyBrace(T, ...) {
721    return false;
722  }
723  template &lt;typename T&gt;
724  void TestHeterogeneous(T table) {
725    auto lb = table.lower_bound(&quot;3&quot;);
726    EXPECT_EQ(lb, table.lower_bound(3));
727    EXPECT_NE(lb, table.lower_bound(4));
728    EXPECT_EQ(lb, table.lower_bound({&quot;3&quot;}));
729    EXPECT_NE(lb, table.lower_bound({}));
730    auto ub = table.upper_bound(&quot;3&quot;);
731    EXPECT_EQ(ub, table.upper_bound(3));
732    EXPECT_NE(ub, table.upper_bound(5));
733    EXPECT_EQ(ub, table.upper_bound({&quot;3&quot;}));
734    EXPECT_NE(ub, table.upper_bound({}));
735    auto er = table.equal_range(&quot;3&quot;);
736    EXPECT_EQ(er, table.equal_range(3));
737    EXPECT_NE(er, table.equal_range(4));
738    EXPECT_EQ(er, table.equal_range({&quot;3&quot;}));
739    EXPECT_NE(er, table.equal_range({}));
740    auto it = table.find(&quot;3&quot;);
741    EXPECT_EQ(it, table.find(3));
742    EXPECT_NE(it, table.find(4));
743    EXPECT_EQ(it, table.find({&quot;3&quot;}));
744    EXPECT_NE(it, table.find({}));
745    EXPECT_TRUE(table.contains(3));
746    EXPECT_FALSE(table.contains(4));
747    EXPECT_TRUE(table.count({&quot;3&quot;}));
748    EXPECT_FALSE(table.contains({}));
749    EXPECT_EQ(1, table.count(3));
750    EXPECT_EQ(0, table.count(4));
751    EXPECT_EQ(1, table.count({&quot;3&quot;}));
752    EXPECT_EQ(0, table.count({}));
753    auto copy = table;
754    copy.erase(3);
755    EXPECT_EQ(table.size() - 1, copy.size());
756    copy.erase(4);
757    EXPECT_EQ(table.size() - 1, copy.size());
758    copy.erase({&quot;5&quot;});
759    EXPECT_EQ(table.size() - 2, copy.size());
760    EXPECT_FALSE(CanEraseWithEmptyBrace(table, nullptr));
761    if (std::is_class&lt;T&gt;()) TestHeterogeneous&lt;const T &amp;&gt;(table);
762  }
763  TEST(Btree, HeterogeneousLookup) {
764    TestHeterogeneous(btree_set&lt;std::string, CompareIntToString&gt;{&quot;1&quot;, &quot;3&quot;, &quot;5&quot;});
765    TestHeterogeneous(btree_map&lt;std::string, int, CompareIntToString&gt;{
766        {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}});
767    TestHeterogeneous(
768        btree_multiset&lt;std::string, CompareIntToString&gt;{&quot;1&quot;, &quot;3&quot;, &quot;5&quot;});
769    TestHeterogeneous(btree_multimap&lt;std::string, int, CompareIntToString&gt;{
770        {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}});
771    btree_map&lt;std::string, int, CompareIntToString&gt; map{
772        {&quot;&quot;, -1}, {&quot;1&quot;, 1}, {&quot;3&quot;, 3}, {&quot;5&quot;, 5}};
773    EXPECT_EQ(1, map.at(1));
774    EXPECT_EQ(3, map.at({&quot;3&quot;}));
775    EXPECT_EQ(-1, map.at({}));
776    const auto &amp;cmap = map;
777    EXPECT_EQ(1, cmap.at(1));
778    EXPECT_EQ(3, cmap.at({&quot;3&quot;}));
779    EXPECT_EQ(-1, cmap.at({}));
780  }
781  TEST(Btree, NoHeterogeneousLookupWithoutAlias) {
782    using StringSet = absl::btree_set&lt;std::string, NonTransparentCompare&gt;;
783    StringSet s;
784    ASSERT_TRUE(s.insert(&quot;hello&quot;).second);
785    ASSERT_TRUE(s.insert(&quot;world&quot;).second);
786    EXPECT_TRUE(s.end() == s.find(&quot;blah&quot;));
787    EXPECT_TRUE(s.begin() == s.lower_bound(&quot;hello&quot;));
788    EXPECT_EQ(1, s.count(&quot;world&quot;));
789    EXPECT_TRUE(s.contains(&quot;hello&quot;));
790    EXPECT_TRUE(s.contains(&quot;world&quot;));
791    EXPECT_FALSE(s.contains(&quot;blah&quot;));
792    using StringMultiSet =
793        absl::btree_multiset&lt;std::string, NonTransparentCompare&gt;;
794    StringMultiSet ms;
795    ms.insert(&quot;hello&quot;);
796    ms.insert(&quot;world&quot;);
797    ms.insert(&quot;world&quot;);
798    EXPECT_TRUE(ms.end() == ms.find(&quot;blah&quot;));
799    EXPECT_TRUE(ms.begin() == ms.lower_bound(&quot;hello&quot;));
800    EXPECT_EQ(2, ms.count(&quot;world&quot;));
801    EXPECT_TRUE(ms.contains(&quot;hello&quot;));
802    EXPECT_TRUE(ms.contains(&quot;world&quot;));
803    EXPECT_FALSE(ms.contains(&quot;blah&quot;));
804  }
805  TEST(Btree, DefaultTransparent) {
806    {
807      btree_set&lt;int&gt; s = {1};
808      double d = 1.1;
809      EXPECT_EQ(s.begin(), s.find(d));
810      EXPECT_TRUE(s.contains(d));
811    }
812    {
813      btree_set&lt;std::string&gt; s = {&quot;A&quot;};
814      EXPECT_EQ(s.begin(), s.find(absl::string_view(&quot;A&quot;)));
815      EXPECT_TRUE(s.contains(absl::string_view(&quot;A&quot;)));
816    }
817  }
818  class StringLike {
819   public:
820    StringLike() = default;
821    StringLike(const char *s) : s_(s) {  
822      ++constructor_calls_;
823    }
824    bool operator&lt;(const StringLike &amp;a) const { return s_ &lt; a.s_; }
825    static void clear_constructor_call_count() { constructor_calls_ = 0; }
826    static int constructor_calls() { return constructor_calls_; }
827   private:
828    static int constructor_calls_;
829    std::string s_;
830  };
831  int StringLike::constructor_calls_ = 0;
832  TEST(Btree, HeterogeneousLookupDoesntDegradePerformance) {
833    using StringSet = absl::btree_set&lt;StringLike&gt;;
834    StringSet s;
835    for (int i = 0; i &lt; 100; ++i) {
836      ASSERT_TRUE(s.insert(absl::StrCat(i).c_str()).second);
837    }
838    StringLike::clear_constructor_call_count();
839    s.find(&quot;50&quot;);
840    ASSERT_EQ(1, StringLike::constructor_calls());
841    StringLike::clear_constructor_call_count();
842    s.contains(&quot;50&quot;);
843    ASSERT_EQ(1, StringLike::constructor_calls());
844    StringLike::clear_constructor_call_count();
845    s.count(&quot;50&quot;);
846    ASSERT_EQ(1, StringLike::constructor_calls());
847    StringLike::clear_constructor_call_count();
848    s.lower_bound(&quot;50&quot;);
849    ASSERT_EQ(1, StringLike::constructor_calls());
850    StringLike::clear_constructor_call_count();
851    s.upper_bound(&quot;50&quot;);
852    ASSERT_EQ(1, StringLike::constructor_calls());
853    StringLike::clear_constructor_call_count();
854    s.equal_range(&quot;50&quot;);
855    ASSERT_EQ(1, StringLike::constructor_calls());
856    StringLike::clear_constructor_call_count();
857    s.erase(&quot;50&quot;);
858    ASSERT_EQ(1, StringLike::constructor_calls());
859  }
860  struct SubstringLess {
861    SubstringLess() = delete;
862    explicit SubstringLess(int length) : n(length) {}
863    bool operator()(const std::string &amp;a, const std::string &amp;b) const {
864      return absl::string_view(a).substr(0, n) &lt;
865             absl::string_view(b).substr(0, n);
866    }
867    int n;
868  };
869  TEST(Btree, SwapKeyCompare) {
870    using SubstringSet = absl::btree_set&lt;std::string, SubstringLess&gt;;
871    SubstringSet s1(SubstringLess(1), SubstringSet::allocator_type());
872    SubstringSet s2(SubstringLess(2), SubstringSet::allocator_type());
873    ASSERT_TRUE(s1.insert(&quot;a&quot;).second);
874    ASSERT_FALSE(s1.insert(&quot;aa&quot;).second);
875    ASSERT_TRUE(s2.insert(&quot;a&quot;).second);
876    ASSERT_TRUE(s2.insert(&quot;aa&quot;).second);
877    ASSERT_FALSE(s2.insert(&quot;aaa&quot;).second);
878    swap(s1, s2);
879    ASSERT_TRUE(s1.insert(&quot;b&quot;).second);
880    ASSERT_TRUE(s1.insert(&quot;bb&quot;).second);
881    ASSERT_FALSE(s1.insert(&quot;bbb&quot;).second);
882    ASSERT_TRUE(s2.insert(&quot;b&quot;).second);
883    ASSERT_FALSE(s2.insert(&quot;bb&quot;).second);
884  }
885  TEST(Btree, UpperBoundRegression) {
886    using SubstringSet = absl::btree_set&lt;std::string, SubstringLess&gt;;
887    SubstringSet my_set(SubstringLess(3));
888    my_set.insert(&quot;aab&quot;);
889    my_set.insert(&quot;abb&quot;);
890    SubstringSet::iterator it = my_set.upper_bound(&quot;aaa&quot;);
891    ASSERT_TRUE(it != my_set.end());
892    EXPECT_EQ(&quot;aab&quot;, *it);
893  }
894  TEST(Btree, Comparison) {
895    const int kSetSize = 1201;
896    absl::btree_set&lt;int64_t&gt; my_set;
897    for (int i = 0; i &lt; kSetSize; ++i) {
898      my_set.insert(i);
899    }
900    absl::btree_set&lt;int64_t&gt; my_set_copy(my_set);
901    EXPECT_TRUE(my_set_copy == my_set);
902    EXPECT_TRUE(my_set == my_set_copy);
903    EXPECT_FALSE(my_set_copy != my_set);
904    EXPECT_FALSE(my_set != my_set_copy);
905    my_set.insert(kSetSize);
906    EXPECT_FALSE(my_set_copy == my_set);
907    EXPECT_FALSE(my_set == my_set_copy);
908    EXPECT_TRUE(my_set_copy != my_set);
909    EXPECT_TRUE(my_set != my_set_copy);
910    my_set.erase(kSetSize - 1);
911    EXPECT_FALSE(my_set_copy == my_set);
912    EXPECT_FALSE(my_set == my_set_copy);
913    EXPECT_TRUE(my_set_copy != my_set);
914    EXPECT_TRUE(my_set != my_set_copy);
915    absl::btree_map&lt;std::string, int64_t&gt; my_map;
916    for (int i = 0; i &lt; kSetSize; ++i) {
917      my_map[std::string(i, &#x27;a&#x27;)] = i;
918    }
919    absl::btree_map&lt;std::string, int64_t&gt; my_map_copy(my_map);
920    EXPECT_TRUE(my_map_copy == my_map);
921    EXPECT_TRUE(my_map == my_map_copy);
922    EXPECT_FALSE(my_map_copy != my_map);
923    EXPECT_FALSE(my_map != my_map_copy);
924    ++my_map_copy[std::string(7, &#x27;a&#x27;)];
925    EXPECT_FALSE(my_map_copy == my_map);
926    EXPECT_FALSE(my_map == my_map_copy);
927    EXPECT_TRUE(my_map_copy != my_map);
928    EXPECT_TRUE(my_map != my_map_copy);
929    my_map_copy = my_map;
930    my_map[&quot;hello&quot;] = kSetSize;
931    EXPECT_FALSE(my_map_copy == my_map);
932    EXPECT_FALSE(my_map == my_map_copy);
933    EXPECT_TRUE(my_map_copy != my_map);
934    EXPECT_TRUE(my_map != my_map_copy);
935    my_map.erase(std::string(kSetSize - 1, &#x27;a&#x27;));
936    EXPECT_FALSE(my_map_copy == my_map);
937    EXPECT_FALSE(my_map == my_map_copy);
938    EXPECT_TRUE(my_map_copy != my_map);
939    EXPECT_TRUE(my_map != my_map_copy);
940  }
941  TEST(Btree, RangeCtorSanity) {
942    std::vector&lt;int&gt; ivec;
943    ivec.push_back(1);
944    std::map&lt;int, int&gt; imap;
945    imap.insert(std::make_pair(1, 2));
946    absl::btree_multiset&lt;int&gt; tmset(ivec.begin(), ivec.end());
947    absl::btree_multimap&lt;int, int&gt; tmmap(imap.begin(), imap.end());
948    absl::btree_set&lt;int&gt; tset(ivec.begin(), ivec.end());
949    absl::btree_map&lt;int, int&gt; tmap(imap.begin(), imap.end());
950    EXPECT_EQ(1, tmset.size());
951    EXPECT_EQ(1, tmmap.size());
952    EXPECT_EQ(1, tset.size());
953    EXPECT_EQ(1, tmap.size());
954  }
955  }  
956  class BtreeNodePeer {
957   public:
958    template &lt;typename ValueType&gt;
959    constexpr static size_t GetTargetNodeSize(size_t target_values_per_node) {
960      return btree_node&lt;
961          set_params&lt;ValueType, std::less&lt;ValueType&gt;, std::allocator&lt;ValueType&gt;,
962                     256,  
963                     false&gt;&gt;::SizeWithNSlots(target_values_per_node);
964    }
965    template &lt;typename Btree&gt;
966    constexpr static size_t GetNumSlotsPerNode() {
967      return btree_node&lt;typename Btree::params_type&gt;::kNodeSlots;
968    }
969    template &lt;typename Btree&gt;
970    constexpr static size_t GetMaxFieldType() {
971      return std::numeric_limits&lt;
972          typename btree_node&lt;typename Btree::params_type&gt;::field_type&gt;::max();
973    }
974    template &lt;typename Btree&gt;
975    constexpr static bool UsesLinearNodeSearch() {
976      return btree_node&lt;typename Btree::params_type&gt;::use_linear_search::value;
977    }
978    template &lt;typename Btree&gt;
979    constexpr static bool FieldTypeEqualsSlotType() {
980      return std::is_same&lt;
981          typename btree_node&lt;typename Btree::params_type&gt;::field_type,
982          typename btree_node&lt;typename Btree::params_type&gt;::slot_type&gt;::value;
983    }
984  };
985  namespace {
986  class BtreeMapTest : public ::testing::Test {
987   public:
988    struct Key {};
989    struct Cmp {
990      template &lt;typename T&gt;
991      bool operator()(T, T) const {
992        return false;
993      }
994    };
995    struct KeyLin {
996      using absl_btree_prefer_linear_node_search = std::true_type;
997    };
998    struct CmpLin : Cmp {
999      using absl_btree_prefer_linear_node_search = std::true_type;
1000    };
1001    struct KeyBin {
1002      using absl_btree_prefer_linear_node_search = std::false_type;
1003    };
1004    struct CmpBin : Cmp {
1005      using absl_btree_prefer_linear_node_search = std::false_type;
1006    };
1007    template &lt;typename K, typename C&gt;
1008    static bool IsLinear() {
1009      return BtreeNodePeer::UsesLinearNodeSearch&lt;absl::btree_map&lt;K, int, C&gt;&gt;();
1010    }
1011  };
1012  TEST_F(BtreeMapTest, TestLinearSearchPreferredForKeyLinearViaAlias) {
1013    EXPECT_FALSE((IsLinear&lt;Key, Cmp&gt;()));
1014    EXPECT_TRUE((IsLinear&lt;KeyLin, Cmp&gt;()));
1015    EXPECT_TRUE((IsLinear&lt;Key, CmpLin&gt;()));
1016    EXPECT_TRUE((IsLinear&lt;KeyLin, CmpLin&gt;()));
1017  }
1018  TEST_F(BtreeMapTest, LinearChoiceTree) {
1019    EXPECT_FALSE((IsLinear&lt;Key, CmpBin&gt;()));
1020    EXPECT_FALSE((IsLinear&lt;KeyLin, CmpBin&gt;()));
1021    EXPECT_FALSE((IsLinear&lt;KeyBin, CmpBin&gt;()));
1022    EXPECT_FALSE((IsLinear&lt;int, CmpBin&gt;()));
1023    EXPECT_FALSE((IsLinear&lt;std::string, CmpBin&gt;()));
1024    EXPECT_TRUE((IsLinear&lt;Key, CmpLin&gt;()));
1025    EXPECT_TRUE((IsLinear&lt;KeyLin, CmpLin&gt;()));
1026    EXPECT_TRUE((IsLinear&lt;KeyBin, CmpLin&gt;()));
1027    EXPECT_TRUE((IsLinear&lt;int, CmpLin&gt;()));
1028    EXPECT_TRUE((IsLinear&lt;std::string, CmpLin&gt;()));
1029    EXPECT_FALSE((IsLinear&lt;Key, Cmp&gt;()));
1030    EXPECT_TRUE((IsLinear&lt;KeyLin, Cmp&gt;()));
1031    EXPECT_FALSE((IsLinear&lt;KeyBin, Cmp&gt;()));
1032    EXPECT_TRUE((IsLinear&lt;int, std::less&lt;int&gt;&gt;()));
1033    EXPECT_TRUE((IsLinear&lt;double, std::greater&lt;double&gt;&gt;()));
1034    EXPECT_FALSE((IsLinear&lt;int, Cmp&gt;()));
1035    EXPECT_FALSE((IsLinear&lt;std::string, std::less&lt;std::string&gt;&gt;()));
1036  }
1037  TEST(Btree, BtreeMapCanHoldMoveOnlyTypes) {
1038    absl::btree_map&lt;std::string, std::unique_ptr&lt;std::string&gt;&gt; m;
1039    std::unique_ptr&lt;std::string&gt; &amp;v = m[&quot;A&quot;];
1040    EXPECT_TRUE(v == nullptr);
1041    v = absl::make_unique&lt;std::string&gt;(&quot;X&quot;);
1042    auto iter = m.find(&quot;A&quot;);
1043    EXPECT_EQ(&quot;X&quot;, *iter-&gt;second);
1044  }
1045  TEST(Btree, InitializerListConstructor) {
1046    absl::btree_set&lt;std::string&gt; set({&quot;a&quot;, &quot;b&quot;});
1047    EXPECT_EQ(set.count(&quot;a&quot;), 1);
1048    EXPECT_EQ(set.count(&quot;b&quot;), 1);
1049    absl::btree_multiset&lt;int&gt; mset({1, 1, 4});
1050    EXPECT_EQ(mset.count(1), 2);
1051    EXPECT_EQ(mset.count(4), 1);
1052    absl::btree_map&lt;int, int&gt; map({{1, 5}, {2, 10}});
1053    EXPECT_EQ(map[1], 5);
1054    EXPECT_EQ(map[2], 10);
1055    absl::btree_multimap&lt;int, int&gt; mmap({{1, 5}, {1, 10}});
1056    auto range = mmap.equal_range(1);
1057    auto it = range.first;
1058    ASSERT_NE(it, range.second);
1059    EXPECT_EQ(it-&gt;second, 5);
1060    ASSERT_NE(++it, range.second);
1061    EXPECT_EQ(it-&gt;second, 10);
1062    EXPECT_EQ(++it, range.second);
1063  }
1064  TEST(Btree, InitializerListInsert) {
1065    absl::btree_set&lt;std::string&gt; set;
1066    set.insert({&quot;a&quot;, &quot;b&quot;});
1067    EXPECT_EQ(set.count(&quot;a&quot;), 1);
1068    EXPECT_EQ(set.count(&quot;b&quot;), 1);
1069    absl::btree_multiset&lt;int&gt; mset;
1070    mset.insert({1, 1, 4});
1071    EXPECT_EQ(mset.count(1), 2);
1072    EXPECT_EQ(mset.count(4), 1);
1073    absl::btree_map&lt;int, int&gt; map;
1074    map.insert({{1, 5}, {2, 10}});
1075    map.insert({3, 15});
1076    EXPECT_EQ(map[1], 5);
1077    EXPECT_EQ(map[2], 10);
1078    EXPECT_EQ(map[3], 15);
1079    absl::btree_multimap&lt;int, int&gt; mmap;
1080    mmap.insert({{1, 5}, {1, 10}});
1081    auto range = mmap.equal_range(1);
1082    auto it = range.first;
1083    ASSERT_NE(it, range.second);
1084    EXPECT_EQ(it-&gt;second, 5);
1085    ASSERT_NE(++it, range.second);
1086    EXPECT_EQ(it-&gt;second, 10);
1087    EXPECT_EQ(++it, range.second);
1088  }
1089  template &lt;typename Compare, typename Key&gt;
1090  void AssertKeyCompareStringAdapted() {
1091    using Adapted = typename key_compare_adapter&lt;Compare, Key&gt;::type;
1092    static_assert(
1093        std::is_same&lt;Adapted, StringBtreeDefaultLess&gt;::value ||
1094            std::is_same&lt;Adapted, StringBtreeDefaultGreater&gt;::value,
1095        &quot;key_compare_adapter should have string-adapted this comparator.&quot;);
1096  }
1097  template &lt;typename Compare, typename Key&gt;
1098  void AssertKeyCompareNotStringAdapted() {
1099    using Adapted = typename key_compare_adapter&lt;Compare, Key&gt;::type;
1100    static_assert(
1101        !std::is_same&lt;Adapted, StringBtreeDefaultLess&gt;::value &amp;&amp;
1102            !std::is_same&lt;Adapted, StringBtreeDefaultGreater&gt;::value,
1103        &quot;key_compare_adapter shouldn&#x27;t have string-adapted this comparator.&quot;);
1104  }
1105  TEST(Btree, KeyCompareAdapter) {
1106    AssertKeyCompareStringAdapted&lt;std::less&lt;std::string&gt;, std::string&gt;();
1107    AssertKeyCompareStringAdapted&lt;std::greater&lt;std::string&gt;, std::string&gt;();
1108    AssertKeyCompareStringAdapted&lt;std::less&lt;absl::string_view&gt;,
1109                                  absl::string_view&gt;();
1110    AssertKeyCompareStringAdapted&lt;std::greater&lt;absl::string_view&gt;,
1111                                  absl::string_view&gt;();
1112    AssertKeyCompareStringAdapted&lt;std::less&lt;absl::Cord&gt;, absl::Cord&gt;();
1113    AssertKeyCompareStringAdapted&lt;std::greater&lt;absl::Cord&gt;, absl::Cord&gt;();
1114    AssertKeyCompareNotStringAdapted&lt;std::less&lt;int&gt;, int&gt;();
1115    AssertKeyCompareNotStringAdapted&lt;std::greater&lt;int&gt;, int&gt;();
1116  }
1117  TEST(Btree, RValueInsert) {
1118    InstanceTracker tracker;
1119    absl::btree_set&lt;MovableOnlyInstance&gt; set;
1120    set.insert(MovableOnlyInstance(1));
1121    set.insert(MovableOnlyInstance(3));
1122    MovableOnlyInstance two(2);
1123    set.insert(set.find(MovableOnlyInstance(3)), std::move(two));
1124    auto it = set.find(MovableOnlyInstance(2));
1125    ASSERT_NE(it, set.end());
1126    ASSERT_NE(++it, set.end());
1127    EXPECT_EQ(it-&gt;value(), 3);
1128    absl::btree_multiset&lt;MovableOnlyInstance&gt; mset;
1129    MovableOnlyInstance zero(0);
1130    MovableOnlyInstance zero2(0);
1131    mset.insert(std::move(zero));
1132    mset.insert(mset.find(MovableOnlyInstance(0)), std::move(zero2));
1133    EXPECT_EQ(mset.count(MovableOnlyInstance(0)), 2);
1134    absl::btree_map&lt;int, MovableOnlyInstance&gt; map;
1135    std::pair&lt;const int, MovableOnlyInstance&gt; p1 = {1, MovableOnlyInstance(5)};
1136    std::pair&lt;const int, MovableOnlyInstance&gt; p2 = {2, MovableOnlyInstance(10)};
1137    std::pair&lt;const int, MovableOnlyInstance&gt; p3 = {3, MovableOnlyInstance(15)};
1138    map.insert(std::move(p1));
1139    map.insert(std::move(p3));
1140    map.insert(map.find(3), std::move(p2));
1141    ASSERT_NE(map.find(2), map.end());
1142    EXPECT_EQ(map.find(2)-&gt;second.value(), 10);
1143    absl::btree_multimap&lt;int, MovableOnlyInstance&gt; mmap;
1144    std::pair&lt;const int, MovableOnlyInstance&gt; p4 = {1, MovableOnlyInstance(5)};
1145    std::pair&lt;const int, MovableOnlyInstance&gt; p5 = {1, MovableOnlyInstance(10)};
1146    mmap.insert(std::move(p4));
1147    mmap.insert(mmap.find(1), std::move(p5));
1148    auto range = mmap.equal_range(1);
1149    auto it1 = range.first;
1150    ASSERT_NE(it1, range.second);
1151    EXPECT_EQ(it1-&gt;second.value(), 10);
1152    ASSERT_NE(++it1, range.second);
1153    EXPECT_EQ(it1-&gt;second.value(), 5);
1154    EXPECT_EQ(++it1, range.second);
1155    EXPECT_EQ(tracker.copies(), 0);
1156    EXPECT_EQ(tracker.swaps(), 0);
1157  }
1158  template &lt;typename Cmp&gt;
1159  struct CheckedCompareOptedOutCmp : Cmp, BtreeTestOnlyCheckedCompareOptOutBase {
1160    using Cmp::Cmp;
1161    CheckedCompareOptedOutCmp() {}
1162    CheckedCompareOptedOutCmp(Cmp cmp) : Cmp(std::move(cmp)) {}  
1163  };
1164  template &lt;typename Key, int TargetValuesPerNode, typename Cmp = std::less&lt;Key&gt;&gt;
1165  class SizedBtreeSet
1166      : public btree_set_container&lt;btree&lt;
1167            set_params&lt;Key, CheckedCompareOptedOutCmp&lt;Cmp&gt;, std::allocator&lt;Key&gt;,
1168                       BtreeNodePeer::GetTargetNodeSize&lt;Key&gt;(TargetValuesPerNode),
1169                       false&gt;&gt;&gt; {
1170    using Base = typename SizedBtreeSet::btree_set_container;
1171   public:
1172    SizedBtreeSet() = default;
1173    using Base::Base;
1174  };
1175  template &lt;typename Set&gt;
1176  void ExpectOperationCounts(const int expected_moves,
1177                             const int expected_comparisons,
1178                             const std::vector&lt;int&gt; &amp;values,
1179                             InstanceTracker *tracker, Set *set) {
1180    for (const int v : values) set-&gt;insert(MovableOnlyInstance(v));
1181    set-&gt;clear();
1182    EXPECT_EQ(tracker-&gt;moves(), expected_moves);
1183    EXPECT_EQ(tracker-&gt;comparisons(), expected_comparisons);
1184    EXPECT_EQ(tracker-&gt;copies(), 0);
1185    EXPECT_EQ(tracker-&gt;swaps(), 0);
1186    tracker-&gt;ResetCopiesMovesSwaps();
1187  }
1188  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
1189  constexpr bool kAsan = true;
1190  #else
1191  constexpr bool kAsan = false;
1192  #endif
1193  TEST(Btree, MovesComparisonsCopiesSwapsTracking) {
1194    if (kAsan) GTEST_SKIP() &lt;&lt; &quot;We do extra operations in ASan mode.&quot;;
1195    InstanceTracker tracker;
1196    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/4&gt; set4;
1197    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/61&gt; set61;
1198    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/100&gt; set100;
1199    std::vector&lt;int&gt; values =
1200        GenerateValuesWithSeed&lt;int&gt;(10000, 1 &lt;&lt; 22, &amp;bsol;*seed=*/23);
1201    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set4)&gt;(), 4);
1202    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set61)&gt;(), 61);
1203    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set100)&gt;(), 100);
1204    if (sizeof(void *) == 8) {
1205      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;absl::btree_set&lt;int32_t&gt;&gt;(),
1206                BtreeGenerationsEnabled() ? 60 : 61);
1207    }
1208    ExpectOperationCounts(56540, 134212, values, &amp;tracker, &amp;set4);
1209    ExpectOperationCounts(386718, 129807, values, &amp;tracker, &amp;set61);
1210    ExpectOperationCounts(586761, 130310, values, &amp;tracker, &amp;set100);
1211    std::sort(values.begin(), values.end());
1212    ExpectOperationCounts(24972, 85563, values, &amp;tracker, &amp;set4);
1213    ExpectOperationCounts(20208, 87757, values, &amp;tracker, &amp;set61);
1214    ExpectOperationCounts(20124, 96583, values, &amp;tracker, &amp;set100);
1215    std::reverse(values.begin(), values.end());
1216    ExpectOperationCounts(54949, 127531, values, &amp;tracker, &amp;set4);
1217    ExpectOperationCounts(338813, 118266, values, &amp;tracker, &amp;set61);
1218    ExpectOperationCounts(534529, 125279, values, &amp;tracker, &amp;set100);
1219  }
1220  struct MovableOnlyInstanceThreeWayCompare {
1221    absl::weak_ordering operator()(const MovableOnlyInstance &amp;a,
1222                                   const MovableOnlyInstance &amp;b) const {
1223      return a.compare(b);
1224    }
1225  };
1226  TEST(Btree, MovesComparisonsCopiesSwapsTrackingThreeWayCompare) {
1227    if (kAsan) GTEST_SKIP() &lt;&lt; &quot;We do extra operations in ASan mode.&quot;;
1228    InstanceTracker tracker;
1229    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/4,
1230                  MovableOnlyInstanceThreeWayCompare&gt;
1231        set4;
1232    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/61,
1233                  MovableOnlyInstanceThreeWayCompare&gt;
1234        set61;
1235    SizedBtreeSet&lt;MovableOnlyInstance, &amp;bsol;*TargetValuesPerNode=*/100,
1236                  MovableOnlyInstanceThreeWayCompare&gt;
1237        set100;
1238    std::vector&lt;int&gt; values =
1239        GenerateValuesWithSeed&lt;int&gt;(10000, 1 &lt;&lt; 22, &amp;bsol;*seed=*/23);
1240    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set4)&gt;(), 4);
1241    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set61)&gt;(), 61);
1242    EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set100)&gt;(), 100);
1243    if (sizeof(void *) == 8) {
1244      EXPECT_EQ(BtreeNodePeer::GetNumSlotsPerNode&lt;absl::btree_set&lt;int32_t&gt;&gt;(),
1245                BtreeGenerationsEnabled() ? 60 : 61);
1246    }
1247    ExpectOperationCounts(56540, 124221, values, &amp;tracker, &amp;set4);
1248    ExpectOperationCounts(386718, 119816, values, &amp;tracker, &amp;set61);
1249    ExpectOperationCounts(586761, 120319, values, &amp;tracker, &amp;set100);
1250    std::sort(values.begin(), values.end());
1251    ExpectOperationCounts(24972, 85563, values, &amp;tracker, &amp;set4);
1252    ExpectOperationCounts(20208, 87757, values, &amp;tracker, &amp;set61);
1253    ExpectOperationCounts(20124, 96583, values, &amp;tracker, &amp;set100);
1254    std::reverse(values.begin(), values.end());
1255    ExpectOperationCounts(54949, 117532, values, &amp;tracker, &amp;set4);
1256    ExpectOperationCounts(338813, 108267, values, &amp;tracker, &amp;set61);
1257    ExpectOperationCounts(534529, 115280, values, &amp;tracker, &amp;set100);
1258  }
1259  struct NoDefaultCtor {
1260    int num;
1261    explicit NoDefaultCtor(int i) : num(i) {}
1262    friend bool operator&lt;(const NoDefaultCtor &amp;a, const NoDefaultCtor &amp;b) {
1263      return a.num &lt; b.num;
1264    }
1265  };
1266  TEST(Btree, BtreeMapCanHoldNoDefaultCtorTypes) {
1267    absl::btree_map&lt;NoDefaultCtor, NoDefaultCtor&gt; m;
1268    for (int i = 1; i &lt;= 99; ++i) {
1269      SCOPED_TRACE(i);
1270      EXPECT_TRUE(m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i)).second);
1271    }
1272    EXPECT_FALSE(m.emplace(NoDefaultCtor(78), NoDefaultCtor(0)).second);
1273    auto iter99 = m.find(NoDefaultCtor(99));
1274    ASSERT_NE(iter99, m.end());
1275    EXPECT_EQ(iter99-&gt;second.num, 1);
1276    auto iter1 = m.find(NoDefaultCtor(1));
1277    ASSERT_NE(iter1, m.end());
1278    EXPECT_EQ(iter1-&gt;second.num, 99);
1279    auto iter50 = m.find(NoDefaultCtor(50));
1280    ASSERT_NE(iter50, m.end());
1281    EXPECT_EQ(iter50-&gt;second.num, 50);
1282    auto iter25 = m.find(NoDefaultCtor(25));
1283    ASSERT_NE(iter25, m.end());
1284    EXPECT_EQ(iter25-&gt;second.num, 75);
1285  }
1286  TEST(Btree, BtreeMultimapCanHoldNoDefaultCtorTypes) {
1287    absl::btree_multimap&lt;NoDefaultCtor, NoDefaultCtor&gt; m;
1288    for (int i = 1; i &lt;= 99; ++i) {
1289      SCOPED_TRACE(i);
1290      m.emplace(NoDefaultCtor(i), NoDefaultCtor(100 - i));
1291    }
1292    auto iter99 = m.find(NoDefaultCtor(99));
1293    ASSERT_NE(iter99, m.end());
1294    EXPECT_EQ(iter99-&gt;second.num, 1);
1295    auto iter1 = m.find(NoDefaultCtor(1));
1296    ASSERT_NE(iter1, m.end());
1297    EXPECT_EQ(iter1-&gt;second.num, 99);
1298    auto iter50 = m.find(NoDefaultCtor(50));
1299    ASSERT_NE(iter50, m.end());
1300    EXPECT_EQ(iter50-&gt;second.num, 50);
1301    auto iter25 = m.find(NoDefaultCtor(25));
1302    ASSERT_NE(iter25, m.end());
1303    EXPECT_EQ(iter25-&gt;second.num, 75);
1304  }
1305  TEST(Btree, MapAt) {
1306    absl::btree_map&lt;int, int&gt; map = {{1, 2}, {2, 4}};
1307    EXPECT_EQ(map.at(1), 2);
1308    EXPECT_EQ(map.at(2), 4);
1309    map.at(2) = 8;
1310    const absl::btree_map&lt;int, int&gt; &amp;const_map = map;
1311    EXPECT_EQ(const_map.at(1), 2);
1312    EXPECT_EQ(const_map.at(2), 8);
1313  #ifdef ABSL_HAVE_EXCEPTIONS
1314    EXPECT_THROW(map.at(3), std::out_of_range);
1315  #else
1316    EXPECT_DEATH_IF_SUPPORTED(map.at(3), &quot;absl::btree_map::at&quot;);
1317  #endif
1318  }
1319  TEST(Btree, BtreeMultisetEmplace) {
1320    const int value_to_insert = 123456;
1321    absl::btree_multiset&lt;int&gt; s;
1322    auto iter = s.emplace(value_to_insert);
1323    ASSERT_NE(iter, s.end());
1324    EXPECT_EQ(*iter, value_to_insert);
1325    iter = s.emplace(value_to_insert);
1326    ASSERT_NE(iter, s.end());
1327    EXPECT_EQ(*iter, value_to_insert);
1328    auto result = s.equal_range(value_to_insert);
1329    EXPECT_EQ(std::distance(result.first, result.second), 2);
1330  }
1331  TEST(Btree, BtreeMultisetEmplaceHint) {
1332    const int value_to_insert = 123456;
1333    absl::btree_multiset&lt;int&gt; s;
1334    auto iter = s.emplace(value_to_insert);
1335    ASSERT_NE(iter, s.end());
1336    EXPECT_EQ(*iter, value_to_insert);
1337    iter = s.emplace_hint(iter, value_to_insert);
1338    EXPECT_EQ(iter, s.lower_bound(value_to_insert));
1339    ASSERT_NE(iter, s.end());
1340    EXPECT_EQ(*iter, value_to_insert);
1341  }
1342  TEST(Btree, BtreeMultimapEmplace) {
1343    const int key_to_insert = 123456;
1344    const char value0[] = &quot;a&quot;;
1345    absl::btree_multimap&lt;int, std::string&gt; m;
1346    auto iter = m.emplace(key_to_insert, value0);
1347    ASSERT_NE(iter, m.end());
1348    EXPECT_EQ(iter-&gt;first, key_to_insert);
1349    EXPECT_EQ(iter-&gt;second, value0);
1350    const char value1[] = &quot;b&quot;;
1351    iter = m.emplace(key_to_insert, value1);
1352    ASSERT_NE(iter, m.end());
1353    EXPECT_EQ(iter-&gt;first, key_to_insert);
1354    EXPECT_EQ(iter-&gt;second, value1);
1355    auto result = m.equal_range(key_to_insert);
1356    EXPECT_EQ(std::distance(result.first, result.second), 2);
1357  }
1358  TEST(Btree, BtreeMultimapEmplaceHint) {
1359    const int key_to_insert = 123456;
1360    const char value0[] = &quot;a&quot;;
1361    absl::btree_multimap&lt;int, std::string&gt; m;
1362    auto iter = m.emplace(key_to_insert, value0);
1363    ASSERT_NE(iter, m.end());
1364    EXPECT_EQ(iter-&gt;first, key_to_insert);
1365    EXPECT_EQ(iter-&gt;second, value0);
1366    const char value1[] = &quot;b&quot;;
1367    iter = m.emplace_hint(iter, key_to_insert, value1);
1368    EXPECT_EQ(iter, m.lower_bound(key_to_insert));
1369    ASSERT_NE(iter, m.end());
1370    EXPECT_EQ(iter-&gt;first, key_to_insert);
1371    EXPECT_EQ(iter-&gt;second, value1);
1372  }
1373  TEST(Btree, ConstIteratorAccessors) {
1374    absl::btree_set&lt;int&gt; set;
1375    for (int i = 0; i &lt; 100; ++i) {
1376      set.insert(i);
1377    }
1378    auto it = set.cbegin();
1379    auto r_it = set.crbegin();
1380    for (int i = 0; i &lt; 100; ++i, ++it, ++r_it) {
1381      ASSERT_EQ(*it, i);
1382      ASSERT_EQ(*r_it, 99 - i);
1383    }
1384    EXPECT_EQ(it, set.cend());
1385    EXPECT_EQ(r_it, set.crend());
1386  }
1387  TEST(Btree, StrSplitCompatible) {
1388    const absl::btree_set&lt;std::string&gt; split_set = absl::StrSplit(&quot;a,b,c&quot;, &#x27;,&#x27;);
1389    const absl::btree_set&lt;std::string&gt; expected_set = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
1390    EXPECT_EQ(split_set, expected_set);
1391  }
1392  TEST(Btree, KeyComp) {
1393    absl::btree_set&lt;int&gt; s;
1394    EXPECT_TRUE(s.key_comp()(1, 2));
1395    EXPECT_FALSE(s.key_comp()(2, 2));
1396    EXPECT_FALSE(s.key_comp()(2, 1));
1397    absl::btree_map&lt;int, int&gt; m1;
1398    EXPECT_TRUE(m1.key_comp()(1, 2));
1399    EXPECT_FALSE(m1.key_comp()(2, 2));
1400    EXPECT_FALSE(m1.key_comp()(2, 1));
1401    absl::btree_map&lt;std::string, int&gt; m2;
1402    EXPECT_TRUE(m2.key_comp()(&quot;a&quot;, &quot;b&quot;));
1403    EXPECT_FALSE(m2.key_comp()(&quot;b&quot;, &quot;b&quot;));
1404    EXPECT_FALSE(m2.key_comp()(&quot;b&quot;, &quot;a&quot;));
1405  }
1406  TEST(Btree, ValueComp) {
1407    absl::btree_set&lt;int&gt; s;
1408    EXPECT_TRUE(s.value_comp()(1, 2));
1409    EXPECT_FALSE(s.value_comp()(2, 2));
1410    EXPECT_FALSE(s.value_comp()(2, 1));
1411    absl::btree_map&lt;int, int&gt; m1;
1412    EXPECT_TRUE(m1.value_comp()(std::make_pair(1, 0), std::make_pair(2, 0)));
1413    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(2, 0)));
1414    EXPECT_FALSE(m1.value_comp()(std::make_pair(2, 0), std::make_pair(1, 0)));
1415    absl::btree_map&lt;std::string, int&gt; m2;
1416    EXPECT_TRUE(m2.value_comp()(std::make_pair(&quot;a&quot;, 0), std::make_pair(&quot;b&quot;, 0)));
1417    EXPECT_FALSE(m2.value_comp()(std::make_pair(&quot;b&quot;, 0), std::make_pair(&quot;b&quot;, 0)));
1418    EXPECT_FALSE(m2.value_comp()(std::make_pair(&quot;b&quot;, 0), std::make_pair(&quot;a&quot;, 0)));
1419  }
1420  TEST(Btree, MapValueCompProtected) {
1421    struct key_compare {
1422      bool operator()(int l, int r) const { return l &lt; r; }
1423      int id;
1424    };
1425    using value_compare = absl::btree_map&lt;int, int, key_compare&gt;::value_compare;
1426    struct value_comp_child : public value_compare {
1427      explicit value_comp_child(key_compare kc) : value_compare(kc) {}
1428      int GetId() const { return comp.id; }
1429    };
1430    value_comp_child c(key_compare{10});
1431    EXPECT_EQ(c.GetId(), 10);
1432  }
1433  TEST(Btree, DefaultConstruction) {
1434    absl::btree_set&lt;int&gt; s;
1435    absl::btree_map&lt;int, int&gt; m;
1436    absl::btree_multiset&lt;int&gt; ms;
1437    absl::btree_multimap&lt;int, int&gt; mm;
1438    EXPECT_TRUE(s.empty());
1439    EXPECT_TRUE(m.empty());
1440    EXPECT_TRUE(ms.empty());
1441    EXPECT_TRUE(mm.empty());
1442  }
1443  TEST(Btree, SwissTableHashable) {
1444    static constexpr int kValues = 10000;
1445    std::vector&lt;int&gt; values(kValues);
1446    std::iota(values.begin(), values.end(), 0);
1447    std::vector&lt;std::pair&lt;int, int&gt;&gt; map_values;
1448    for (int v : values) map_values.emplace_back(v, -v);
1449    using set = absl::btree_set&lt;int&gt;;
1450    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1451        set{},
1452        set{1},
1453        set{2},
1454        set{1, 2},
1455        set{2, 1},
1456        set(values.begin(), values.end()),
1457        set(values.rbegin(), values.rend()),
1458    }));
1459    using mset = absl::btree_multiset&lt;int&gt;;
1460    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1461        mset{},
1462        mset{1},
1463        mset{1, 1},
1464        mset{2},
1465        mset{2, 2},
1466        mset{1, 2},
1467        mset{1, 1, 2},
1468        mset{1, 2, 2},
1469        mset{1, 1, 2, 2},
1470        mset(values.begin(), values.end()),
1471        mset(values.rbegin(), values.rend()),
1472    }));
1473    using map = absl::btree_map&lt;int, int&gt;;
1474    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1475        map{},
1476        map{{1, 0}},
1477        map{{1, 1}},
1478        map{{2, 0}},
1479        map{{2, 2}},
1480        map{{1, 0}, {2, 1}},
1481        map(map_values.begin(), map_values.end()),
1482        map(map_values.rbegin(), map_values.rend()),
1483    }));
1484    using mmap = absl::btree_multimap&lt;int, int&gt;;
1485    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly({
1486        mmap{},
1487        mmap{{1, 0}},
1488        mmap{{1, 1}},
1489        mmap{{1, 0}, {1, 1}},
1490        mmap{{1, 1}, {1, 0}},
1491        mmap{{2, 0}},
1492        mmap{{2, 2}},
1493        mmap{{1, 0}, {2, 1}},
1494        mmap(map_values.begin(), map_values.end()),
1495        mmap(map_values.rbegin(), map_values.rend()),
1496    }));
1497  }
1498  TEST(Btree, ComparableSet) {
1499    absl::btree_set&lt;int&gt; s1 = {1, 2};
1500    absl::btree_set&lt;int&gt; s2 = {2, 3};
1501    EXPECT_LT(s1, s2);
1502    EXPECT_LE(s1, s2);
1503    EXPECT_LE(s1, s1);
1504    EXPECT_GT(s2, s1);
1505    EXPECT_GE(s2, s1);
1506    EXPECT_GE(s1, s1);
1507  }
1508  TEST(Btree, ComparableSetsDifferentLength) {
1509    absl::btree_set&lt;int&gt; s1 = {1, 2};
1510    absl::btree_set&lt;int&gt; s2 = {1, 2, 3};
1511    EXPECT_LT(s1, s2);
1512    EXPECT_LE(s1, s2);
1513    EXPECT_GT(s2, s1);
1514    EXPECT_GE(s2, s1);
1515  }
1516  TEST(Btree, ComparableMultiset) {
1517    absl::btree_multiset&lt;int&gt; s1 = {1, 2};
1518    absl::btree_multiset&lt;int&gt; s2 = {2, 3};
1519    EXPECT_LT(s1, s2);
1520    EXPECT_LE(s1, s2);
1521    EXPECT_LE(s1, s1);
1522    EXPECT_GT(s2, s1);
1523    EXPECT_GE(s2, s1);
1524    EXPECT_GE(s1, s1);
1525  }
1526  TEST(Btree, ComparableMap) {
1527    absl::btree_map&lt;int, int&gt; s1 = {{1, 2}};
1528    absl::btree_map&lt;int, int&gt; s2 = {{2, 3}};
1529    EXPECT_LT(s1, s2);
1530    EXPECT_LE(s1, s2);
1531    EXPECT_LE(s1, s1);
1532    EXPECT_GT(s2, s1);
1533    EXPECT_GE(s2, s1);
1534    EXPECT_GE(s1, s1);
1535  }
1536  TEST(Btree, ComparableMultimap) {
1537    absl::btree_multimap&lt;int, int&gt; s1 = {{1, 2}};
1538    absl::btree_multimap&lt;int, int&gt; s2 = {{2, 3}};
1539    EXPECT_LT(s1, s2);
1540    EXPECT_LE(s1, s2);
1541    EXPECT_LE(s1, s1);
1542    EXPECT_GT(s2, s1);
1543    EXPECT_GE(s2, s1);
1544    EXPECT_GE(s1, s1);
1545  }
1546  TEST(Btree, ComparableSetWithCustomComparator) {
1547    absl::btree_set&lt;int, std::greater&lt;int&gt;&gt; s1 = {1, 2};
1548    absl::btree_set&lt;int, std::greater&lt;int&gt;&gt; s2 = {2, 3};
1549    EXPECT_LT(s1, s2);
1550    EXPECT_LE(s1, s2);
1551    EXPECT_LE(s1, s1);
1552    EXPECT_GT(s2, s1);
1553    EXPECT_GE(s2, s1);
1554    EXPECT_GE(s1, s1);
1555  }
1556  TEST(Btree, EraseReturnsIterator) {
1557    absl::btree_set&lt;int&gt; set = {1, 2, 3, 4, 5};
1558    auto result_it = set.erase(set.begin(), set.find(3));
1559    EXPECT_EQ(result_it, set.find(3));
1560    result_it = set.erase(set.find(5));
1561    EXPECT_EQ(result_it, set.end());
1562  }
1563  TEST(Btree, ExtractAndInsertNodeHandleSet) {
1564    absl::btree_set&lt;int&gt; src1 = {1, 2, 3, 4, 5};
1565    auto nh = src1.extract(src1.find(3));
1566    EXPECT_THAT(src1, ElementsAre(1, 2, 4, 5));
1567    absl::btree_set&lt;int&gt; other;
1568    absl::btree_set&lt;int&gt;::insert_return_type res = other.insert(std::move(nh));
1569    EXPECT_THAT(other, ElementsAre(3));
1570    EXPECT_EQ(res.position, other.find(3));
1571    EXPECT_TRUE(res.inserted);
1572    EXPECT_TRUE(res.node.empty());
1573    absl::btree_set&lt;int&gt; src2 = {3, 4};
1574    nh = src2.extract(src2.find(3));
1575    EXPECT_THAT(src2, ElementsAre(4));
1576    res = other.insert(std::move(nh));
1577    EXPECT_THAT(other, ElementsAre(3));
1578    EXPECT_EQ(res.position, other.find(3));
1579    EXPECT_FALSE(res.inserted);
1580    ASSERT_FALSE(res.node.empty());
1581    EXPECT_EQ(res.node.value(), 3);
1582  }
1583  template &lt;typename Set&gt;
1584  void TestExtractWithTrackingForSet() {
1585    InstanceTracker tracker;
1586    {
1587      Set s;
1588      const size_t kSize = 1000;
1589      while (s.size() &lt; kSize) {
1590        s.insert(MovableOnlyInstance(s.size()));
1591      }
1592      for (int i = 0; i &lt; kSize; ++i) {
1593        auto nh = s.extract(MovableOnlyInstance(i));
1594        EXPECT_EQ(s.size(), kSize - 1);
1595        EXPECT_EQ(nh.value().value(), i);
1596        s.insert(std::move(nh));
1597        EXPECT_EQ(s.size(), kSize);
1598        auto it = s.find(MovableOnlyInstance(i));
1599        nh = s.extract(it);
1600        EXPECT_EQ(s.size(), kSize - 1);
1601        EXPECT_EQ(nh.value().value(), i);
1602        s.insert(s.begin(), std::move(nh));
1603        EXPECT_EQ(s.size(), kSize);
1604      }
1605    }
1606    EXPECT_EQ(0, tracker.instances());
1607  }
1608  template &lt;typename Map&gt;
1609  void TestExtractWithTrackingForMap() {
1610    InstanceTracker tracker;
1611    {
1612      Map m;
1613      const size_t kSize = 1000;
1614      while (m.size() &lt; kSize) {
1615        m.insert(
1616            {CopyableMovableInstance(m.size()), MovableOnlyInstance(m.size())});
1617      }
1618      for (int i = 0; i &lt; kSize; ++i) {
1619        auto nh = m.extract(CopyableMovableInstance(i));
1620        EXPECT_EQ(m.size(), kSize - 1);
1621        EXPECT_EQ(nh.key().value(), i);
1622        EXPECT_EQ(nh.mapped().value(), i);
1623        m.insert(std::move(nh));
1624        EXPECT_EQ(m.size(), kSize);
1625        auto it = m.find(CopyableMovableInstance(i));
1626        nh = m.extract(it);
1627        EXPECT_EQ(m.size(), kSize - 1);
1628        EXPECT_EQ(nh.key().value(), i);
1629        EXPECT_EQ(nh.mapped().value(), i);
1630        m.insert(m.begin(), std::move(nh));
1631        EXPECT_EQ(m.size(), kSize);
1632      }
1633    }
1634    EXPECT_EQ(0, tracker.instances());
1635  }
1636  TEST(Btree, ExtractTracking) {
1637    TestExtractWithTrackingForSet&lt;absl::btree_set&lt;MovableOnlyInstance&gt;&gt;();
1638    TestExtractWithTrackingForSet&lt;absl::btree_multiset&lt;MovableOnlyInstance&gt;&gt;();
1639    TestExtractWithTrackingForMap&lt;
1640        absl::btree_map&lt;CopyableMovableInstance, MovableOnlyInstance&gt;&gt;();
1641    TestExtractWithTrackingForMap&lt;
1642        absl::btree_multimap&lt;CopyableMovableInstance, MovableOnlyInstance&gt;&gt;();
1643  }
1644  TEST(Btree, ExtractAndInsertNodeHandleMultiSet) {
1645    absl::btree_multiset&lt;int&gt; src1 = {1, 2, 3, 3, 4, 5};
1646    auto nh = src1.extract(src1.find(3));
1647    EXPECT_THAT(src1, ElementsAre(1, 2, 3, 4, 5));
1648    absl::btree_multiset&lt;int&gt; other;
1649    auto res = other.insert(std::move(nh));
1650    EXPECT_THAT(other, ElementsAre(3));
1651    EXPECT_EQ(res, other.find(3));
1652    absl::btree_multiset&lt;int&gt; src2 = {3, 4};
1653    nh = src2.extract(src2.find(3));
1654    EXPECT_THAT(src2, ElementsAre(4));
1655    res = other.insert(std::move(nh));
1656    EXPECT_THAT(other, ElementsAre(3, 3));
1657    EXPECT_EQ(res, ++other.find(3));
1658  }
1659  TEST(Btree, ExtractAndInsertNodeHandleMap) {
1660    absl::btree_map&lt;int, int&gt; src1 = {{1, 2}, {3, 4}, {5, 6}};
1661    auto nh = src1.extract(src1.find(3));
1662    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1663    absl::btree_map&lt;int, int&gt; other;
1664    absl::btree_map&lt;int, int&gt;::insert_return_type res =
1665        other.insert(std::move(nh));
1666    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1667    EXPECT_EQ(res.position, other.find(3));
1668    EXPECT_TRUE(res.inserted);
1669    EXPECT_TRUE(res.node.empty());
1670    absl::btree_map&lt;int, int&gt; src2 = {{3, 6}};
1671    nh = src2.extract(src2.find(3));
1672    EXPECT_TRUE(src2.empty());
1673    res = other.insert(std::move(nh));
1674    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1675    EXPECT_EQ(res.position, other.find(3));
1676    EXPECT_FALSE(res.inserted);
1677    ASSERT_FALSE(res.node.empty());
1678    EXPECT_EQ(res.node.key(), 3);
1679    EXPECT_EQ(res.node.mapped(), 6);
1680  }
1681  TEST(Btree, ExtractAndInsertNodeHandleMultiMap) {
1682    absl::btree_multimap&lt;int, int&gt; src1 = {{1, 2}, {3, 4}, {5, 6}};
1683    auto nh = src1.extract(src1.find(3));
1684    EXPECT_THAT(src1, ElementsAre(Pair(1, 2), Pair(5, 6)));
1685    absl::btree_multimap&lt;int, int&gt; other;
1686    auto res = other.insert(std::move(nh));
1687    EXPECT_THAT(other, ElementsAre(Pair(3, 4)));
1688    EXPECT_EQ(res, other.find(3));
1689    absl::btree_multimap&lt;int, int&gt; src2 = {{3, 6}};
1690    nh = src2.extract(src2.find(3));
1691    EXPECT_TRUE(src2.empty());
1692    res = other.insert(std::move(nh));
1693    EXPECT_THAT(other, ElementsAre(Pair(3, 4), Pair(3, 6)));
1694    EXPECT_EQ(res, ++other.begin());
1695  }
1696  TEST(Btree, ExtractMultiMapEquivalentKeys) {
1697    absl::btree_multimap&lt;std::string, int&gt; map;
1698    for (int i = 0; i &lt; 100; ++i) {
1699      for (int j = 0; j &lt; 100; ++j) {
1700        map.insert({absl::StrCat(i), j});
1701      }
1702    }
1703    for (int i = 0; i &lt; 100; ++i) {
1704      const std::string key = absl::StrCat(i);
1705      auto node_handle = map.extract(key);
1706      EXPECT_EQ(node_handle.key(), key);
1707      EXPECT_EQ(node_handle.mapped(), 0) &lt;&lt; i;
1708    }
1709    for (int i = 0; i &lt; 100; ++i) {
1710      const std::string key = absl::StrCat(i);
1711      auto node_handle = map.extract(key);
1712      EXPECT_EQ(node_handle.key(), key);
1713      EXPECT_EQ(node_handle.mapped(), 1) &lt;&lt; i;
1714    }
1715  }
1716  TEST(Btree, ExtractAndGetNextSet) {
1717    absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1718    auto it = src.find(3);
1719    auto extracted_and_next = src.extract_and_get_next(it);
1720    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1721    EXPECT_EQ(extracted_and_next.node.value(), 3);
1722    EXPECT_EQ(*extracted_and_next.next, 4);
1723  }
1724  TEST(Btree, ExtractAndGetNextMultiSet) {
1725    absl::btree_multiset&lt;int&gt; src = {1, 2, 3, 4, 5};
1726    auto it = src.find(3);
1727    auto extracted_and_next = src.extract_and_get_next(it);
1728    EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1729    EXPECT_EQ(extracted_and_next.node.value(), 3);
1730    EXPECT_EQ(*extracted_and_next.next, 4);
1731  }
1732  TEST(Btree, ExtractAndGetNextMap) {
1733    absl::btree_map&lt;int, int&gt; src = {{1, 2}, {3, 4}, {5, 6}};
1734    auto it = src.find(3);
1735    auto extracted_and_next = src.extract_and_get_next(it);
1736    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1737    EXPECT_EQ(extracted_and_next.node.key(), 3);
1738    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1739    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1740  }
1741  TEST(Btree, ExtractAndGetNextMultiMap) {
1742    absl::btree_multimap&lt;int, int&gt; src = {{1, 2}, {3, 4}, {5, 6}};
1743    auto it = src.find(3);
1744    auto extracted_and_next = src.extract_and_get_next(it);
1745    EXPECT_THAT(src, ElementsAre(Pair(1, 2), Pair(5, 6)));
1746    EXPECT_EQ(extracted_and_next.node.key(), 3);
1747    EXPECT_EQ(extracted_and_next.node.mapped(), 4);
1748    EXPECT_THAT(*extracted_and_next.next, Pair(5, 6));
1749  }
1750  TEST(Btree, ExtractAndGetNextEndIter) {
1751    absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1752    auto it = src.find(5);
1753    auto extracted_and_next = src.extract_and_get_next(it);
1754    EXPECT_THAT(src, ElementsAre(1, 2, 3, 4));
1755    EXPECT_EQ(extracted_and_next.node.value(), 5);
1756    EXPECT_EQ(extracted_and_next.next, src.end());
1757  }
1758  TEST(Btree, ExtractDoesntCauseExtraMoves) {
1759  #ifdef _MSC_VER
1760    GTEST_SKIP() &lt;&lt; &quot;This test fails on MSVC.&quot;;
1761  #endif
1762    using Set = absl::btree_set&lt;MovableOnlyInstance&gt;;
1763    std::array&lt;std::function&lt;void(Set &amp;)&gt;, 3&gt; extracters = {
1764        [](Set &amp;s) { auto node = s.extract(s.begin()); },
1765        [](Set &amp;s) { auto ret = s.extract_and_get_next(s.begin()); },
1766        [](Set &amp;s) { auto node = s.extract(MovableOnlyInstance(0)); }};
1767    InstanceTracker tracker;
1768    for (int i = 0; i &lt; 3; ++i) {
1769      Set s;
1770      s.insert(MovableOnlyInstance(0));
1771      tracker.ResetCopiesMovesSwaps();
1772      extracters[i](s);
1773      EXPECT_EQ(tracker.copies(), 0) &lt;&lt; i;
1774      EXPECT_EQ(tracker.moves(), 1) &lt;&lt; i;
1775      EXPECT_EQ(tracker.swaps(), 0) &lt;&lt; i;
1776    }
1777  }
1778  struct InsertMultiHintData {
1779    int key;
1780    int not_key;
1781    bool operator==(const InsertMultiHintData other) const {
1782      return key == other.key &amp;&amp; not_key == other.not_key;
1783    }
1784  };
1785  struct InsertMultiHintDataKeyCompare {
1786    using is_transparent = void;
1787    bool operator()(const InsertMultiHintData a,
1788                    const InsertMultiHintData b) const {
1789      return a.key &lt; b.key;
1790    }
1791    bool operator()(const int a, const InsertMultiHintData b) const {
1792      return a &lt; b.key;
1793    }
1794    bool operator()(const InsertMultiHintData a, const int b) const {
1795      return a.key &lt; b;
1796    }
1797  };
1798  TEST(Btree, InsertHintNodeHandle) {
1799    {
1800      absl::btree_set&lt;int&gt; src = {1, 2, 3, 4, 5};
1801      auto nh = src.extract(src.find(3));
1802      EXPECT_THAT(src, ElementsAre(1, 2, 4, 5));
1803      absl::btree_set&lt;int&gt; other = {0, 100};
1804      auto it = other.insert(other.lower_bound(3), std::move(nh));
1805      EXPECT_THAT(other, ElementsAre(0, 3, 100));
1806      EXPECT_EQ(it, other.find(3));
1807      nh = src.extract(src.find(5));
1808      it = other.insert(other.end(), std::move(nh));
1809      EXPECT_THAT(other, ElementsAre(0, 3, 5, 100));
1810      EXPECT_EQ(it, other.find(5));
1811    }
1812    absl::btree_multiset&lt;InsertMultiHintData, InsertMultiHintDataKeyCompare&gt; src =
1813        {{1, 2}, {3, 4}, {3, 5}};
1814    auto nh = src.extract(src.lower_bound(3));
1815    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 4}));
1816    absl::btree_multiset&lt;InsertMultiHintData, InsertMultiHintDataKeyCompare&gt;
1817        other = {{3, 1}, {3, 2}, {3, 3}};
1818    auto it = other.insert(--other.end(), std::move(nh));
1819    EXPECT_THAT(
1820        other, ElementsAre(InsertMultiHintData{3, 1}, InsertMultiHintData{3, 2},
1821                           InsertMultiHintData{3, 4}, InsertMultiHintData{3, 3}));
1822    EXPECT_EQ(it, --(--other.end()));
1823    nh = src.extract(src.find(3));
1824    EXPECT_EQ(nh.value(), (InsertMultiHintData{3, 5}));
1825    it = other.insert(other.begin(), std::move(nh));
1826    EXPECT_THAT(other,
1827                ElementsAre(InsertMultiHintData{3, 5}, InsertMultiHintData{3, 1},
1828                            InsertMultiHintData{3, 2}, InsertMultiHintData{3, 4},
1829                            InsertMultiHintData{3, 3}));
1830    EXPECT_EQ(it, other.begin());
1831  }
1832  struct IntCompareToCmp {
1833    absl::weak_ordering operator()(int a, int b) const {
1834      if (a &lt; b) return absl::weak_ordering::less;
1835      if (a &gt; b) return absl::weak_ordering::greater;
1836      return absl::weak_ordering::equivalent;
1837    }
1838  };
1839  TEST(Btree, MergeIntoUniqueContainers) {
1840    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1841    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1842    absl::btree_set&lt;int&gt; dst;
1843    dst.merge(src1);
1844    EXPECT_TRUE(src1.empty());
1845    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1846    dst.merge(src2);
1847    EXPECT_THAT(src2, ElementsAre(3, 4));
1848    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1849  }
1850  TEST(Btree, MergeIntoUniqueContainersWithCompareTo) {
1851    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1852    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1853    absl::btree_set&lt;int, IntCompareToCmp&gt; dst;
1854    dst.merge(src1);
1855    EXPECT_TRUE(src1.empty());
1856    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1857    dst.merge(src2);
1858    EXPECT_THAT(src2, ElementsAre(3, 4));
1859    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 4, 5));
1860  }
1861  TEST(Btree, MergeIntoMultiContainers) {
1862    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1863    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1864    absl::btree_multiset&lt;int&gt; dst;
1865    dst.merge(src1);
1866    EXPECT_TRUE(src1.empty());
1867    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1868    dst.merge(src2);
1869    EXPECT_TRUE(src2.empty());
1870    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1871  }
1872  TEST(Btree, MergeIntoMultiContainersWithCompareTo) {
1873    absl::btree_set&lt;int, IntCompareToCmp&gt; src1 = {1, 2, 3};
1874    absl::btree_multiset&lt;int&gt; src2 = {3, 4, 4, 5};
1875    absl::btree_multiset&lt;int, IntCompareToCmp&gt; dst;
1876    dst.merge(src1);
1877    EXPECT_TRUE(src1.empty());
1878    EXPECT_THAT(dst, ElementsAre(1, 2, 3));
1879    dst.merge(src2);
1880    EXPECT_TRUE(src2.empty());
1881    EXPECT_THAT(dst, ElementsAre(1, 2, 3, 3, 4, 4, 5));
1882  }
1883  TEST(Btree, MergeIntoMultiMapsWithDifferentComparators) {
1884    absl::btree_map&lt;int, int, IntCompareToCmp&gt; src1 = {{1, 1}, {2, 2}, {3, 3}};
1885    absl::btree_multimap&lt;int, int, std::greater&lt;int&gt;&gt; src2 = {
1886        {5, 5}, {4, 1}, {4, 4}, {3, 2}};
1887    absl::btree_multimap&lt;int, int&gt; dst;
1888    dst.merge(src1);
1889    EXPECT_TRUE(src1.empty());
1890    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3)));
1891    dst.merge(src2);
1892    EXPECT_TRUE(src2.empty());
1893    EXPECT_THAT(dst, ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(3, 2),
1894                                 Pair(4, 1), Pair(4, 4), Pair(5, 5)));
1895  }
1896  TEST(Btree, MergeIntoSetMovableOnly) {
1897    absl::btree_set&lt;MovableOnlyInstance&gt; src;
1898    src.insert(MovableOnlyInstance(1));
1899    absl::btree_multiset&lt;MovableOnlyInstance&gt; dst1;
1900    dst1.insert(MovableOnlyInstance(2));
1901    absl::btree_set&lt;MovableOnlyInstance&gt; dst2;
1902    dst1.merge(src);
1903    EXPECT_TRUE(src.empty());
1904    ASSERT_THAT(dst1, SizeIs(2));
1905    EXPECT_EQ(*dst1.begin(), MovableOnlyInstance(1));
1906    EXPECT_EQ(*std::next(dst1.begin()), MovableOnlyInstance(2));
1907    dst2.merge(dst1);
1908    EXPECT_TRUE(dst1.empty());
1909    ASSERT_THAT(dst2, SizeIs(2));
1910    EXPECT_EQ(*dst2.begin(), MovableOnlyInstance(1));
1911    EXPECT_EQ(*std::next(dst2.begin()), MovableOnlyInstance(2));
1912  }
1913  struct KeyCompareToWeakOrdering {
1914    template &lt;typename T&gt;
1915    absl::weak_ordering operator()(const T &amp;a, const T &amp;b) const {
1916      return a &lt; b ? absl::weak_ordering::less
1917                   : a == b ? absl::weak_ordering::equivalent
1918                            : absl::weak_ordering::greater;
1919    }
1920  };
1921  struct KeyCompareToStrongOrdering {
1922    template &lt;typename T&gt;
1923    absl::strong_ordering operator()(const T &amp;a, const T &amp;b) const {
1924      return a &lt; b ? absl::strong_ordering::less
1925                   : a == b ? absl::strong_ordering::equal
1926                            : absl::strong_ordering::greater;
1927    }
1928  };
1929  TEST(Btree, UserProvidedKeyCompareToComparators) {
1930    absl::btree_set&lt;int, KeyCompareToWeakOrdering&gt; weak_set = {1, 2, 3};
1931    EXPECT_TRUE(weak_set.contains(2));
1932    EXPECT_FALSE(weak_set.contains(4));
1933    absl::btree_set&lt;int, KeyCompareToStrongOrdering&gt; strong_set = {1, 2, 3};
1934    EXPECT_TRUE(strong_set.contains(2));
1935    EXPECT_FALSE(strong_set.contains(4));
1936  }
1937  TEST(Btree, TryEmplaceBasicTest) {
1938    absl::btree_map&lt;int, std::string&gt; m;
1939    m.try_emplace(1, &quot;one&quot;);
1940    EXPECT_EQ(1, m.size());
1941    const int key(42);
1942    m.try_emplace(key, 3, &#x27;a&#x27;);
1943    m.try_emplace(2, std::string(&quot;two&quot;));
1944    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1945    EXPECT_THAT(m, ElementsAreArray(std::vector&lt;std::pair&lt;int, std::string&gt;&gt;{
1946                       {1, &quot;one&quot;}, {2, &quot;two&quot;}, {42, &quot;aaa&quot;}}));
1947  }
1948  TEST(Btree, TryEmplaceWithHintWorks) {
1949    int calls = 0;
1950    auto cmp = [&amp;calls](int x, int y) {
1951      ++calls;
1952      return x &lt; y;
1953    };
1954    using Cmp = decltype(cmp);
1955    absl::btree_map&lt;int, int, CheckedCompareOptedOutCmp&lt;Cmp&gt;&gt; m(cmp);
1956    for (int i = 0; i &lt; 128; ++i) {
1957      m.emplace(i, i);
1958    }
1959    calls = 0;
1960    m.emplace(127, 127);
1961    EXPECT_GE(calls, 4);
1962    calls = 0;
1963    auto it = m.try_emplace(m.begin(), -1, -1);
1964    EXPECT_EQ(129, m.size());
1965    EXPECT_EQ(it, m.begin());
1966    EXPECT_LE(calls, 2);
1967    calls = 0;
1968    std::pair&lt;int, int&gt; pair1024 = {1024, 1024};
1969    it = m.try_emplace(m.end(), pair1024.first, pair1024.second);
1970    EXPECT_EQ(130, m.size());
1971    EXPECT_EQ(it, --m.end());
1972    EXPECT_LE(calls, 2);
1973    calls = 0;
1974    it = m.try_emplace(m.end(), 16, 17);
1975    EXPECT_EQ(130, m.size());
1976    EXPECT_GE(calls, 4);
1977    EXPECT_EQ(it, m.find(16));
1978    calls = 0;
1979    it = m.try_emplace(it, 16, 17);
1980    EXPECT_EQ(130, m.size());
1981    EXPECT_LE(calls, 2);
1982    EXPECT_EQ(it, m.find(16));
1983    m.erase(2);
1984    EXPECT_EQ(129, m.size());
1985    auto hint = m.find(3);
1986    calls = 0;
1987    m.try_emplace(hint, 2, 2);
1988    EXPECT_EQ(130, m.size());
1989    EXPECT_LE(calls, 2);
1990    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
1991  }
1992  TEST(Btree, TryEmplaceWithBadHint) {
1993    absl::btree_map&lt;int, int&gt; m = {{1, 1}, {9, 9}};
1994    auto it = m.try_emplace(m.begin(), 2, 2);
1995    EXPECT_EQ(it, ++m.begin());
1996    EXPECT_THAT(m, ElementsAreArray(
1997                       std::vector&lt;std::pair&lt;int, int&gt;&gt;{{1, 1}, {2, 2}, {9, 9}}));
1998    it = m.try_emplace(++(++m.begin()), 0, 0);
1999    EXPECT_EQ(it, m.begin());
2000    EXPECT_THAT(m, ElementsAreArray(std::vector&lt;std::pair&lt;int, int&gt;&gt;{
2001                       {0, 0}, {1, 1}, {2, 2}, {9, 9}}));
2002  }
2003  TEST(Btree, TryEmplaceMaintainsSortedOrder) {
2004    absl::btree_map&lt;int, std::string&gt; m;
2005    std::pair&lt;int, std::string&gt; pair5 = {5, &quot;five&quot;};
2006    m.try_emplace(10, &quot;ten&quot;);
2007    m.try_emplace(pair5.first, pair5.second);
2008    EXPECT_EQ(2, m.size());
2009    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2010    int int100{100};
2011    m.try_emplace(int100, &quot;hundred&quot;);
2012    m.try_emplace(1, &quot;one&quot;);
2013    EXPECT_EQ(4, m.size());
2014    EXPECT_TRUE(std::is_sorted(m.begin(), m.end()));
2015  }
2016  TEST(Btree, TryEmplaceWithHintAndNoValueArgsWorks) {
2017    absl::btree_map&lt;int, int&gt; m;
2018    m.try_emplace(m.end(), 1);
2019    EXPECT_EQ(0, m[1]);
2020  }
2021  TEST(Btree, TryEmplaceWithHintAndMultipleValueArgsWorks) {
2022    absl::btree_map&lt;int, std::string&gt; m;
2023    m.try_emplace(m.end(), 1, 10, &#x27;a&#x27;);
2024    EXPECT_EQ(std::string(10, &#x27;a&#x27;), m[1]);
2025  }
2026  TEST(Btree, MoveAssignmentAllocatorPropagation) {
2027    InstanceTracker tracker;
2028    int64_t bytes1 = 0, bytes2 = 0;
2029    PropagatingCountingAlloc&lt;MovableOnlyInstance&gt; allocator1(&amp;bytes1);
2030    PropagatingCountingAlloc&lt;MovableOnlyInstance&gt; allocator2(&amp;bytes2);
2031    std::less&lt;MovableOnlyInstance&gt; cmp;
2032    {
2033      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2034                      PropagatingCountingAlloc&lt;MovableOnlyInstance&gt;&gt;
2035          set1(cmp, allocator1), set2(cmp, allocator2);
2036      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2037      tracker.ResetCopiesMovesSwaps();
2038      set2 = std::move(set1);
2039      EXPECT_EQ(tracker.moves(), 0);
2040    }
2041    {
2042      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2043                      CountingAllocator&lt;MovableOnlyInstance&gt;&gt;
2044          set1(cmp, allocator1), set2(cmp, allocator1);
2045      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2046      tracker.ResetCopiesMovesSwaps();
2047      set2 = std::move(set1);
2048      EXPECT_EQ(tracker.moves(), 0);
2049    }
2050    {
2051      absl::btree_set&lt;MovableOnlyInstance, std::less&lt;MovableOnlyInstance&gt;,
2052                      CountingAllocator&lt;MovableOnlyInstance&gt;&gt;
2053          set1(cmp, allocator1), set2(cmp, allocator2);
2054      for (int i = 0; i &lt; 100; ++i) set1.insert(MovableOnlyInstance(i));
2055      tracker.ResetCopiesMovesSwaps();
2056      set2 = std::move(set1);
2057      EXPECT_GE(tracker.moves(), 100);
2058    }
2059  }
2060  TEST(Btree, EmptyTree) {
2061    absl::btree_set&lt;int&gt; s;
2062    EXPECT_TRUE(s.empty());
2063    EXPECT_EQ(s.size(), 0);
2064    EXPECT_GT(s.max_size(), 0);
2065  }
2066  bool IsEven(int k) { return k % 2 == 0; }
2067  TEST(Btree, EraseIf) {
2068    {
2069      absl::btree_set&lt;int&gt; s = {1, 3, 5, 6, 100};
2070      EXPECT_EQ(erase_if(s, [](int k) { return k &gt; 3; }), 3);
2071      EXPECT_THAT(s, ElementsAre(1, 3));
2072    }
2073    {
2074      absl::btree_multiset&lt;int&gt; s = {1, 3, 3, 5, 6, 6, 100};
2075      EXPECT_EQ(erase_if(s, [](int k) { return k &lt;= 3; }), 3);
2076      EXPECT_THAT(s, ElementsAre(5, 6, 6, 100));
2077    }
2078    {
2079      absl::btree_map&lt;int, int&gt; m = {{1, 1}, {3, 3}, {6, 6}, {100, 100}};
2080      EXPECT_EQ(
2081          erase_if(m, [](std::pair&lt;const int, int&gt; kv) { return kv.first &gt; 3; }),
2082          2);
2083      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3)));
2084    }
2085    {
2086      absl::btree_multimap&lt;int, int&gt; m = {{1, 1}, {3, 3}, {3, 6},
2087                                          {6, 6}, {6, 7}, {100, 6}};
2088      EXPECT_EQ(
2089          erase_if(m,
2090                   [](std::pair&lt;const int, int&gt; kv) { return kv.second == 6; }),
2091          3);
2092      EXPECT_THAT(m, ElementsAre(Pair(1, 1), Pair(3, 3), Pair(6, 7)));
2093    }
2094    {
2095      absl::btree_set&lt;int&gt; s;
2096      for (int i = 0; i &lt; 1000; ++i) s.insert(2 * i);
2097      EXPECT_EQ(erase_if(s, IsEven), 1000);
2098      EXPECT_THAT(s, IsEmpty());
2099    }
2100    {
2101      absl::btree_set&lt;int&gt; s = {1, 3, 5, 6, 100};
2102      EXPECT_EQ(erase_if(s, &amp;IsEven), 2);
2103      EXPECT_THAT(s, ElementsAre(1, 3, 5));
2104    }
2105    {
2106      absl::btree_set&lt;int&gt; s;
2107      for (int i = 0; i &lt; 1000; ++i) s.insert(i);
2108      int pred_calls = 0;
2109      EXPECT_EQ(erase_if(s,
2110                         [&amp;pred_calls](int k) {
2111                           ++pred_calls;
2112                           return k % 2;
2113                         }),
2114                500);
2115      EXPECT_THAT(s, SizeIs(500));
2116      EXPECT_EQ(pred_calls, 1000);
2117    }
2118  }
2119  TEST(Btree, InsertOrAssign) {
2120    absl::btree_map&lt;int, int&gt; m = {{1, 1}, {3, 3}};
2121    using value_type = typename decltype(m)::value_type;
2122    auto ret = m.insert_or_assign(4, 4);
2123    EXPECT_EQ(*ret.first, value_type(4, 4));
2124    EXPECT_TRUE(ret.second);
2125    ret = m.insert_or_assign(3, 100);
2126    EXPECT_EQ(*ret.first, value_type(3, 100));
2127    EXPECT_FALSE(ret.second);
2128    auto hint_ret = m.insert_or_assign(ret.first, 3, 200);
2129    EXPECT_EQ(*hint_ret, value_type(3, 200));
2130    hint_ret = m.insert_or_assign(m.find(1), 0, 1);
2131    EXPECT_EQ(*hint_ret, value_type(0, 1));
2132    hint_ret = m.insert_or_assign(m.end(), -1, 1);
2133    EXPECT_EQ(*hint_ret, value_type(-1, 1));
2134    EXPECT_THAT(m, ElementsAre(Pair(-1, 1), Pair(0, 1), Pair(1, 1), Pair(3, 200),
2135                               Pair(4, 4)));
2136  }
2137  TEST(Btree, InsertOrAssignMovableOnly) {
2138    absl::btree_map&lt;int, MovableOnlyInstance&gt; m;
2139    using value_type = typename decltype(m)::value_type;
2140    auto ret = m.insert_or_assign(4, MovableOnlyInstance(4));
2141    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(4)));
2142    EXPECT_TRUE(ret.second);
2143    ret = m.insert_or_assign(4, MovableOnlyInstance(100));
2144    EXPECT_EQ(*ret.first, value_type(4, MovableOnlyInstance(100)));
2145    EXPECT_FALSE(ret.second);
2146    auto hint_ret = m.insert_or_assign(ret.first, 3, MovableOnlyInstance(200));
2147    EXPECT_EQ(*hint_ret, value_type(3, MovableOnlyInstance(200)));
2148    EXPECT_EQ(m.size(), 2);
2149  }
2150  TEST(Btree, BitfieldArgument) {
2151    union {
2152      int n : 1;
2153    };
2154    n = 0;
2155    absl::btree_map&lt;int, int&gt; m;
2156    m.erase(n);
2157    m.count(n);
2158    m.find(n);
2159    m.contains(n);
2160    m.equal_range(n);
2161    m.insert_or_assign(n, n);
2162    m.insert_or_assign(m.end(), n, n);
2163    m.try_emplace(n);
2164    m.try_emplace(m.end(), n);
2165    m.at(n);
2166    m[n];
2167  }
2168  TEST(Btree, SetRangeConstructorAndInsertSupportExplicitConversionComparable) {
2169    const absl::string_view names[] = {&quot;n1&quot;, &quot;n2&quot;};
2170    absl::btree_set&lt;std::string&gt; name_set1{std::begin(names), std::end(names)};
2171    EXPECT_THAT(name_set1, ElementsAreArray(names));
2172    absl::btree_set&lt;std::string&gt; name_set2;
2173    name_set2.insert(std::begin(names), std::end(names));
2174    EXPECT_THAT(name_set2, ElementsAreArray(names));
2175  }
2176  struct ConstructorCounted {
2177    explicit ConstructorCounted(int i) : i(i) { ++constructor_calls; }
2178    bool operator==(int other) const { return i == other; }
2179    int i;
2180    static int constructor_calls;
2181  };
2182  int ConstructorCounted::constructor_calls = 0;
2183  struct ConstructorCountedCompare {
2184    bool operator()(int a, const ConstructorCounted &amp;b) const { return a &lt; b.i; }
2185    bool operator()(const ConstructorCounted &amp;a, int b) const { return a.i &lt; b; }
2186    bool operator()(const ConstructorCounted &amp;a,
2187                    const ConstructorCounted &amp;b) const {
2188      return a.i &lt; b.i;
2189    }
2190    using is_transparent = void;
2191  };
2192  TEST(Btree,
2193       SetRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2194    const int i[] = {0, 1, 1};
2195    ConstructorCounted::constructor_calls = 0;
2196    absl::btree_set&lt;ConstructorCounted, ConstructorCountedCompare&gt; set{
2197        std::begin(i), std::end(i)};
2198    EXPECT_THAT(set, ElementsAre(0, 1));
2199    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2200    set.insert(std::begin(i), std::end(i));
2201    EXPECT_THAT(set, ElementsAre(0, 1));
2202    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2203  }
2204  TEST(Btree,
2205       SetRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2206    const int i[] = {0, 1};
2207    absl::btree_set&lt;std::vector&lt;void *&gt;&gt; s1{std::begin(i), std::end(i)};
2208    EXPECT_THAT(s1, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2209    absl::btree_set&lt;std::vector&lt;void *&gt;&gt; s2;
2210    s2.insert(std::begin(i), std::end(i));
2211    EXPECT_THAT(s2, ElementsAre(IsEmpty(), ElementsAre(IsNull())));
2212  }
2213  #if !defined(__GLIBCXX__) || \
2214      (defined(_GLIBCXX_RELEASE) &amp;&amp; _GLIBCXX_RELEASE &gt;= 7)
2215  TEST(Btree, MapRangeConstructorAndInsertSupportExplicitConversionComparable) {
2216    const std::pair&lt;absl::string_view, int&gt; names[] = {{&quot;n1&quot;, 1}, {&quot;n2&quot;, 2}};
2217    absl::btree_map&lt;std::string, int&gt; name_map1{std::begin(names),
2218                                                std::end(names)};
2219    EXPECT_THAT(name_map1, ElementsAre(Pair(&quot;n1&quot;, 1), Pair(&quot;n2&quot;, 2)));
2220    absl::btree_map&lt;std::string, int&gt; name_map2;
2221    name_map2.insert(std::begin(names), std::end(names));
2222    EXPECT_THAT(name_map2, ElementsAre(Pair(&quot;n1&quot;, 1), Pair(&quot;n2&quot;, 2)));
2223  }
2224  TEST(Btree,
2225       MapRangeConstructorAndInsertExplicitConvComparableLimitConstruction) {
2226    const std::pair&lt;int, int&gt; i[] = {{0, 1}, {1, 2}, {1, 3}};
2227    ConstructorCounted::constructor_calls = 0;
2228    absl::btree_map&lt;ConstructorCounted, int, ConstructorCountedCompare&gt; map{
2229        std::begin(i), std::end(i)};
2230    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2231    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2232    map.insert(std::begin(i), std::end(i));
2233    EXPECT_THAT(map, ElementsAre(Pair(0, 1), Pair(1, 2)));
2234    EXPECT_EQ(ConstructorCounted::constructor_calls, 2);
2235  }
2236  TEST(Btree,
2237       MapRangeConstructorAndInsertSupportExplicitConversionNonComparable) {
2238    const std::pair&lt;int, int&gt; i[] = {{0, 1}, {1, 2}};
2239    absl::btree_map&lt;std::vector&lt;void *&gt;, int&gt; m1{std::begin(i), std::end(i)};
2240    EXPECT_THAT(m1,
2241                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2242    absl::btree_map&lt;std::vector&lt;void *&gt;, int&gt; m2;
2243    m2.insert(std::begin(i), std::end(i));
2244    EXPECT_THAT(m2,
2245                ElementsAre(Pair(IsEmpty(), 1), Pair(ElementsAre(IsNull()), 2)));
2246  }
2247  TEST(Btree, HeterogeneousTryEmplace) {
2248    absl::btree_map&lt;std::string, int&gt; m;
2249    std::string s = &quot;key&quot;;
2250    absl::string_view sv = s;
2251    m.try_emplace(sv, 1);
2252    EXPECT_EQ(m[s], 1);
2253    m.try_emplace(m.end(), sv, 2);
2254    EXPECT_EQ(m[s], 1);
2255  }
2256  TEST(Btree, HeterogeneousOperatorMapped) {
2257    absl::btree_map&lt;std::string, int&gt; m;
2258    std::string s = &quot;key&quot;;
2259    absl::string_view sv = s;
2260    m[sv] = 1;
2261    EXPECT_EQ(m[s], 1);
2262    m[sv] = 2;
2263    EXPECT_EQ(m[s], 2);
2264  }
2265  TEST(Btree, HeterogeneousInsertOrAssign) {
2266    absl::btree_map&lt;std::string, int&gt; m;
2267    std::string s = &quot;key&quot;;
2268    absl::string_view sv = s;
2269    m.insert_or_assign(sv, 1);
2270    EXPECT_EQ(m[s], 1);
2271    m.insert_or_assign(m.end(), sv, 2);
2272    EXPECT_EQ(m[s], 2);
2273  }
2274  #endif
2275  #if defined(__cpp_lib_launder) &amp;&amp; __cpp_lib_launder &gt;= 201606
2276  TEST(Btree, NodeHandleMutableKeyAccess) {
2277    {
2278      absl::btree_map&lt;std::string, std::string&gt; map;
2279      map[&quot;key1&quot;] = &quot;mapped&quot;;
2280      auto nh = map.extract(map.begin());
2281      nh.key().resize(3);
2282      map.insert(std::move(nh));
2283      EXPECT_THAT(map, ElementsAre(Pair(&quot;key&quot;, &quot;mapped&quot;)));
2284    }
2285    {
2286      absl::btree_multimap&lt;std::string, std::string&gt; map;
2287      map.emplace(&quot;key1&quot;, &quot;mapped&quot;);
2288      auto nh = map.extract(map.begin());
2289      nh.key().resize(3);
2290      map.insert(std::move(nh));
2291      EXPECT_THAT(map, ElementsAre(Pair(&quot;key&quot;, &quot;mapped&quot;)));
2292    }
2293  }
2294  #endif
2295  struct MultiKey {
2296    int i1;
2297    int i2;
2298  };
2299  bool operator==(const MultiKey a, const MultiKey b) {
2300    return a.i1 == b.i1 &amp;&amp; a.i2 == b.i2;
2301  }
2302  struct MultiKeyComp {
2303    using is_transparent = void;
2304    bool operator()(const MultiKey a, const MultiKey b) const {
2305      if (a.i1 != b.i1) return a.i1 &lt; b.i1;
2306      return a.i2 &lt; b.i2;
2307    }
2308    bool operator()(const int a, const MultiKey b) const { return a &lt; b.i1; }
2309    bool operator()(const MultiKey a, const int b) const { return a.i1 &lt; b; }
2310  };
2311  struct MultiKeyThreeWayComp {
2312    using is_transparent = void;
2313    absl::weak_ordering operator()(const MultiKey a, const MultiKey b) const {
2314      if (a.i1 &lt; b.i1) return absl::weak_ordering::less;
2315      if (a.i1 &gt; b.i1) return absl::weak_ordering::greater;
2316      if (a.i2 &lt; b.i2) return absl::weak_ordering::less;
2317      if (a.i2 &gt; b.i2) return absl::weak_ordering::greater;
2318      return absl::weak_ordering::equivalent;
2319    }
2320    absl::weak_ordering operator()(const int a, const MultiKey b) const {
2321      if (a &lt; b.i1) return absl::weak_ordering::less;
2322      if (a &gt; b.i1) return absl::weak_ordering::greater;
2323      return absl::weak_ordering::equivalent;
2324    }
2325    absl::weak_ordering operator()(const MultiKey a, const int b) const {
2326      if (a.i1 &lt; b) return absl::weak_ordering::less;
2327      if (a.i1 &gt; b) return absl::weak_ordering::greater;
2328      return absl::weak_ordering::equivalent;
2329    }
2330  };
2331  template &lt;typename Compare&gt;
2332  class BtreeMultiKeyTest : public ::testing::Test {};
2333  using MultiKeyComps = ::testing::Types&lt;MultiKeyComp, MultiKeyThreeWayComp&gt;;
2334  TYPED_TEST_SUITE(BtreeMultiKeyTest, MultiKeyComps);
2335  TYPED_TEST(BtreeMultiKeyTest, EqualRange) {
2336    absl::btree_set&lt;MultiKey, TypeParam&gt; set;
2337    for (int i = 0; i &lt; 100; ++i) {
2338      for (int j = 0; j &lt; 100; ++j) {
2339        set.insert({i, j});
2340      }
2341    }
2342    for (int i = 0; i &lt; 100; ++i) {
2343      auto equal_range = set.equal_range(i);
2344      EXPECT_EQ(equal_range.first-&gt;i1, i);
2345      EXPECT_EQ(equal_range.first-&gt;i2, 0) &lt;&lt; i;
2346      EXPECT_EQ(std::distance(equal_range.first, equal_range.second), 100) &lt;&lt; i;
2347    }
2348  }
2349  TYPED_TEST(BtreeMultiKeyTest, Extract) {
2350    absl::btree_set&lt;MultiKey, TypeParam&gt; set;
2351    for (int i = 0; i &lt; 100; ++i) {
2352      for (int j = 0; j &lt; 100; ++j) {
2353        set.insert({i, j});
2354      }
2355    }
2356    for (int i = 0; i &lt; 100; ++i) {
2357      auto node_handle = set.extract(i);
2358      EXPECT_EQ(node_handle.value().i1, i);
2359      EXPECT_EQ(node_handle.value().i2, 0) &lt;&lt; i;
2360    }
2361    for (int i = 0; i &lt; 100; ++i) {
2362      auto node_handle = set.extract(i);
2363      EXPECT_EQ(node_handle.value().i1, i);
2364      EXPECT_EQ(node_handle.value().i2, 1) &lt;&lt; i;
2365    }
2366  }
2367  TYPED_TEST(BtreeMultiKeyTest, Erase) {
2368    absl::btree_set&lt;MultiKey, TypeParam&gt; set = {
2369        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2370    EXPECT_EQ(set.erase(2), 2);
2371    EXPECT_THAT(set, ElementsAre(MultiKey{1, 1}, MultiKey{3, 1}));
2372  }
2373  TYPED_TEST(BtreeMultiKeyTest, Count) {
2374    const absl::btree_set&lt;MultiKey, TypeParam&gt; set = {
2375        {1, 1}, {2, 1}, {2, 2}, {3, 1}};
2376    EXPECT_EQ(set.count(2), 2);
2377  }
2378  TEST(Btree, AllocConstructor) {
2379    using Alloc = CountingAllocator&lt;int&gt;;
2380    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2381    int64_t bytes_used = 0;
2382    Alloc alloc(&amp;bytes_used);
2383    Set set(alloc);
2384    set.insert({1, 2, 3});
2385    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2386    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2387  }
2388  TEST(Btree, AllocInitializerListConstructor) {
2389    using Alloc = CountingAllocator&lt;int&gt;;
2390    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2391    int64_t bytes_used = 0;
2392    Alloc alloc(&amp;bytes_used);
2393    Set set({1, 2, 3}, alloc);
2394    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2395    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2396  }
2397  TEST(Btree, AllocRangeConstructor) {
2398    using Alloc = CountingAllocator&lt;int&gt;;
2399    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2400    int64_t bytes_used = 0;
2401    Alloc alloc(&amp;bytes_used);
2402    std::vector&lt;int&gt; v = {1, 2, 3};
2403    Set set(v.begin(), v.end(), alloc);
2404    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2405    EXPECT_GT(bytes_used, set.size() * sizeof(int));
2406  }
2407  TEST(Btree, AllocCopyConstructor) {
2408    using Alloc = CountingAllocator&lt;int&gt;;
2409    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2410    int64_t bytes_used1 = 0;
2411    Alloc alloc1(&amp;bytes_used1);
2412    Set set1(alloc1);
2413    set1.insert({1, 2, 3});
2414    int64_t bytes_used2 = 0;
2415    Alloc alloc2(&amp;bytes_used2);
2416    Set set2(set1, alloc2);
2417    EXPECT_THAT(set1, ElementsAre(1, 2, 3));
2418    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2419    EXPECT_GT(bytes_used1, set1.size() * sizeof(int));
2420    EXPECT_EQ(bytes_used1, bytes_used2);
2421  }
2422  TEST(Btree, AllocMoveConstructor_SameAlloc) {
2423    using Alloc = CountingAllocator&lt;int&gt;;
2424    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2425    int64_t bytes_used = 0;
2426    Alloc alloc(&amp;bytes_used);
2427    Set set1(alloc);
2428    set1.insert({1, 2, 3});
2429    const int64_t original_bytes_used = bytes_used;
2430    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2431    Set set2(std::move(set1), alloc);
2432    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2433    EXPECT_EQ(bytes_used, original_bytes_used);
2434  }
2435  TEST(Btree, AllocMoveConstructor_DifferentAlloc) {
2436    using Alloc = CountingAllocator&lt;int&gt;;
2437    using Set = absl::btree_set&lt;int, std::less&lt;int&gt;, Alloc&gt;;
2438    int64_t bytes_used1 = 0;
2439    Alloc alloc1(&amp;bytes_used1);
2440    Set set1(alloc1);
2441    set1.insert({1, 2, 3});
2442    const int64_t original_bytes_used = bytes_used1;
2443    EXPECT_GT(original_bytes_used, set1.size() * sizeof(int));
2444    int64_t bytes_used2 = 0;
2445    Alloc alloc2(&amp;bytes_used2);
2446    Set set2(std::move(set1), alloc2);
2447    EXPECT_THAT(set2, ElementsAre(1, 2, 3));
2448    EXPECT_EQ(bytes_used1, original_bytes_used);
2449    EXPECT_EQ(bytes_used2, original_bytes_used);
2450  }
2451  bool IntCmp(const int a, const int b) { return a &lt; b; }
2452  TEST(Btree, SupportsFunctionPtrComparator) {
2453    absl::btree_set&lt;int, decltype(IntCmp) *&gt; set(IntCmp);
2454    set.insert({1, 2, 3});
2455    EXPECT_THAT(set, ElementsAre(1, 2, 3));
2456    EXPECT_TRUE(set.key_comp()(1, 2));
2457    EXPECT_TRUE(set.value_comp()(1, 2));
2458    absl::btree_map&lt;int, int, decltype(IntCmp) *&gt; map(&amp;IntCmp);
2459    map[1] = 1;
2460    EXPECT_THAT(map, ElementsAre(Pair(1, 1)));
2461    EXPECT_TRUE(map.key_comp()(1, 2));
2462    EXPECT_TRUE(map.value_comp()(std::make_pair(1, 1), std::make_pair(2, 2)));
2463  }
2464  template &lt;typename Compare&gt;
2465  struct TransparentPassThroughComp {
2466    using is_transparent = void;
2467    template &lt;typename T, typename U&gt;
2468    bool operator()(const T &amp;lhs, const U &amp;rhs) const {
2469      return Compare()(lhs, rhs);
2470    }
2471  };
2472  TEST(Btree,
2473       SupportsTransparentComparatorThatDoesNotImplementAllVisibleOperators) {
2474    absl::btree_set&lt;MultiKey, TransparentPassThroughComp&lt;MultiKeyComp&gt;&gt; set;
2475    set.insert(MultiKey{1, 2});
2476    EXPECT_TRUE(set.contains(1));
2477  }
2478  TEST(Btree, ConstructImplicitlyWithUnadaptedComparator) {
2479    absl::btree_set&lt;MultiKey, MultiKeyComp&gt; set = {{}, MultiKeyComp{}};
2480  }
2481  TEST(Btree, InvalidComparatorsCaught) {
2482    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2483    {
2484      struct ZeroAlwaysLessCmp {
2485        bool operator()(int lhs, int rhs) const {
2486          if (lhs == 0) return true;
2487          return lhs &lt; rhs;
2488        }
2489      };
2490      absl::btree_set&lt;int, ZeroAlwaysLessCmp&gt; set;
2491      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;is_self_equivalent&quot;);
2492    }
2493    {
2494      struct ThreeWayAlwaysLessCmp {
2495        absl::weak_ordering operator()(int, int) const {
2496          return absl::weak_ordering::less;
2497        }
2498      };
2499      absl::btree_set&lt;int, ThreeWayAlwaysLessCmp&gt; set;
2500      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;is_self_equivalent&quot;);
2501    }
2502    {
2503      struct SumGreaterZeroCmp {
2504        bool operator()(int lhs, int rhs) const {
2505          if (lhs == rhs) return false;
2506          return lhs + rhs &gt; 0;
2507        }
2508      };
2509      absl::btree_set&lt;int, SumGreaterZeroCmp&gt; set;
2510      EXPECT_DEATH(set.insert({0, 1, 2}),
2511                   R&quot;regex(\!lhs_comp_rhs \|\| !comp\(\)\(rhs, lhs\))regex&quot;);
2512    }
2513    {
2514      struct ThreeWaySumGreaterZeroCmp {
2515        absl::weak_ordering operator()(int lhs, int rhs) const {
2516          if (lhs == rhs) return absl::weak_ordering::equivalent;
2517          if (lhs + rhs &gt; 0) return absl::weak_ordering::less;
2518          if (lhs + rhs == 0) return absl::weak_ordering::equivalent;
2519          return absl::weak_ordering::greater;
2520        }
2521      };
2522      absl::btree_set&lt;int, ThreeWaySumGreaterZeroCmp&gt; set;
2523      EXPECT_DEATH(set.insert({0, 1, 2}), &quot;lhs_comp_rhs &lt; 0 -&gt; rhs_comp_lhs &gt; 0&quot;);
2524    }
2525    struct ClockTime {
2526      absl::optional&lt;int&gt; hour;
2527      int minute;
2528    };
2529    ClockTime a = {absl::nullopt, 1};
2530    ClockTime b = {2, 5};
2531    ClockTime c = {6, 0};
2532    {
2533      struct NonTransitiveTimeCmp {
2534        bool operator()(ClockTime lhs, ClockTime rhs) const {
2535          if (lhs.hour.has_value() &amp;&amp; rhs.hour.has_value() &amp;&amp;
2536              *lhs.hour != *rhs.hour) {
2537            return *lhs.hour &lt; *rhs.hour;
2538          }
2539          return lhs.minute &lt; rhs.minute;
2540        }
2541      };
2542      NonTransitiveTimeCmp cmp;
2543      ASSERT_TRUE(cmp(a, b) &amp;&amp; cmp(b, c) &amp;&amp; !cmp(a, c));
2544      absl::btree_set&lt;ClockTime, NonTransitiveTimeCmp&gt; set;
2545      EXPECT_DEATH(set.insert({a, b, c}), &quot;is_ordered_correctly&quot;);
2546      absl::btree_multiset&lt;ClockTime, NonTransitiveTimeCmp&gt; mset;
2547      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), &quot;is_ordered_correctly&quot;);
2548    }
2549    {
2550      struct ThreeWayNonTransitiveTimeCmp {
2551        absl::weak_ordering operator()(ClockTime lhs, ClockTime rhs) const {
2552          if (lhs.hour.has_value() &amp;&amp; rhs.hour.has_value() &amp;&amp;
2553              *lhs.hour != *rhs.hour) {
2554            return *lhs.hour &lt; *rhs.hour ? absl::weak_ordering::less
2555                                         : absl::weak_ordering::greater;
2556          }
2557          return lhs.minute &lt; rhs.minute    ? absl::weak_ordering::less
2558                 : lhs.minute == rhs.minute ? absl::weak_ordering::equivalent
2559                                            : absl::weak_ordering::greater;
2560        }
2561      };
2562      ThreeWayNonTransitiveTimeCmp cmp;
2563      ASSERT_TRUE(cmp(a, b) &lt; 0 &amp;&amp; cmp(b, c) &lt; 0 &amp;&amp; cmp(a, c) &gt; 0);
2564      absl::btree_set&lt;ClockTime, ThreeWayNonTransitiveTimeCmp&gt; set;
2565      EXPECT_DEATH(set.insert({a, b, c}), &quot;is_ordered_correctly&quot;);
2566      absl::btree_multiset&lt;ClockTime, ThreeWayNonTransitiveTimeCmp&gt; mset;
2567      EXPECT_DEATH(mset.insert({a, a, b, b, c, c}), &quot;is_ordered_correctly&quot;);
2568    }
2569  }
2570  TEST(Btree, MutatedKeysCaught) {
2571    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2572    struct IntPtrCmp {
2573      bool operator()(int *lhs, int *rhs) const { return *lhs &lt; *rhs; }
2574    };
2575    {
2576      absl::btree_set&lt;int *, IntPtrCmp&gt; set;
2577      int arr[] = {0, 1, 2};
2578      set.insert({&amp;arr[0], &amp;arr[1], &amp;arr[2]});
2579      arr[0] = 100;
2580      EXPECT_DEATH(set.insert(&amp;arr[0]), &quot;is_ordered_correctly&quot;);
2581    }
2582    {
2583      absl::btree_multiset&lt;int *, IntPtrCmp&gt; set;
2584      int arr[] = {0, 1, 2};
2585      set.insert({&amp;arr[0], &amp;arr[0], &amp;arr[1], &amp;arr[1], &amp;arr[2], &amp;arr[2]});
2586      arr[0] = 100;
2587      EXPECT_DEATH(set.insert(&amp;arr[0]), &quot;is_ordered_correctly&quot;);
2588    }
2589  }
2590  #ifndef _MSC_VER
2591  TEST(Btree, InvalidIteratorUse) {
2592    if (!BtreeGenerationsEnabled())
2593      GTEST_SKIP() &lt;&lt; &quot;Generation validation for iterators is disabled.&quot;;
2594    constexpr const char *kInvalidMemoryDeathMessage =
2595        &quot;heap-use-after-free|invalidated iterator&quot;;
2596    {
2597      absl::btree_set&lt;int&gt; set;
2598      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2599      auto it = set.begin();
2600      set.erase(it++);
2601      EXPECT_DEATH(set.erase(it++), kInvalidMemoryDeathMessage);
2602    }
2603    {
2604      absl::btree_set&lt;int&gt; set;
2605      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2606      auto it = set.insert(20).first;
2607      set.insert(30);
2608      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2609    }
2610    {
2611      absl::btree_set&lt;int&gt; set;
2612      for (int i = 0; i &lt; 10000; ++i) set.insert(i);
2613      auto it = set.find(5000);
2614      ASSERT_NE(it, set.end());
2615      set.erase(1);
2616      EXPECT_DEATH(*it, kInvalidMemoryDeathMessage);
2617    }
2618    {
2619      absl::btree_set&lt;int&gt; set;
2620      for (int i = 0; i &lt; 10; ++i) set.insert(i);
2621      auto it = set.insert(20).first;
2622      set.insert(30);
2623      EXPECT_DEATH(void(it == set.begin()), kInvalidMemoryDeathMessage);
2624      EXPECT_DEATH(void(set.begin() == it), kInvalidMemoryDeathMessage);
2625    }
2626  }
2627  #endif
2628  class OnlyConstructibleByAllocator {
2629    explicit OnlyConstructibleByAllocator(int i) : i_(i) {}
2630   public:
2631    OnlyConstructibleByAllocator(const OnlyConstructibleByAllocator &amp;other)
2632        : i_(other.i_) {}
2633    OnlyConstructibleByAllocator &amp;operator=(
2634        const OnlyConstructibleByAllocator &amp;other) {
2635      i_ = other.i_;
2636      return *this;
2637    }
2638    int Get() const { return i_; }
2639    bool operator==(int i) const { return i_ == i; }
2640   private:
2641    template &lt;typename T&gt;
2642    friend class OnlyConstructibleAllocator;
2643    int i_;
2644  };
2645  template &lt;typename T = OnlyConstructibleByAllocator&gt;
2646  class OnlyConstructibleAllocator : public std::allocator&lt;T&gt; {
2647   public:
2648    OnlyConstructibleAllocator() = default;
2649    template &lt;class U&gt;
2650    explicit OnlyConstructibleAllocator(const OnlyConstructibleAllocator&lt;U&gt; &amp;) {}
2651    void construct(OnlyConstructibleByAllocator *p, int i) {
2652      new (p) OnlyConstructibleByAllocator(i);
2653    }
2654    template &lt;typename Pair&gt;
2655    void construct(Pair *p, const int i) {
2656      OnlyConstructibleByAllocator only(i);
2657      new (p) Pair(std::move(only), i);
2658    }
2659    template &lt;class U&gt;
2660    struct rebind {
2661      using other = OnlyConstructibleAllocator&lt;U&gt;;
2662    };
2663  };
2664  struct OnlyConstructibleByAllocatorComp {
2665    using is_transparent = void;
2666    bool operator()(OnlyConstructibleByAllocator a,
2667                    OnlyConstructibleByAllocator b) const {
2668      return a.Get() &lt; b.Get();
2669    }
2670    bool operator()(int a, OnlyConstructibleByAllocator b) const {
2671      return a &lt; b.Get();
2672    }
2673    bool operator()(OnlyConstructibleByAllocator a, int b) const {
2674      return a.Get() &lt; b;
2675    }
2676  };
2677  TEST(Btree, OnlyConstructibleByAllocatorType) {
2678    const std::array&lt;int, 2&gt; arr = {3, 4};
2679    {
2680      absl::btree_set&lt;OnlyConstructibleByAllocator,
2681                      OnlyConstructibleByAllocatorComp,
2682                      OnlyConstructibleAllocator&lt;&gt;&gt;
2683          set;
2684      set.emplace(1);
2685      set.emplace_hint(set.end(), 2);
2686      set.insert(arr.begin(), arr.end());
2687      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2688    }
2689    {
2690      absl::btree_multiset&lt;OnlyConstructibleByAllocator,
2691                           OnlyConstructibleByAllocatorComp,
2692                           OnlyConstructibleAllocator&lt;&gt;&gt;
2693          set;
2694      set.emplace(1);
2695      set.emplace_hint(set.end(), 2);
2696      EXPECT_THAT(set, ElementsAre(1, 2));
2697    }
2698    {
2699      absl::btree_map&lt;OnlyConstructibleByAllocator, int,
2700                      OnlyConstructibleByAllocatorComp,
2701                      OnlyConstructibleAllocator&lt;&gt;&gt;
2702          map;
2703      map.emplace(1);
2704      map.emplace_hint(map.end(), 2);
2705      map.insert(arr.begin(), arr.end());
2706      EXPECT_THAT(map,
2707                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2708    }
2709    {
2710      absl::btree_multimap&lt;OnlyConstructibleByAllocator, int,
2711                           OnlyConstructibleByAllocatorComp,
2712                           OnlyConstructibleAllocator&lt;&gt;&gt;
2713          map;
2714      map.emplace(1);
2715      map.emplace_hint(map.end(), 2);
2716      EXPECT_THAT(map, ElementsAre(Pair(1, 1), Pair(2, 2)));
2717    }
2718  }
2719  class NotAssignable {
2720   public:
2721    explicit NotAssignable(int i) : i_(i) {}
2722    NotAssignable(const NotAssignable &amp;other) : i_(other.i_) {}
2723    NotAssignable &amp;operator=(NotAssignable &amp;&amp;other) = delete;
2724    int Get() const { return i_; }
2725    bool operator==(int i) const { return i_ == i; }
2726    friend bool operator&lt;(NotAssignable a, NotAssignable b) {
2727      return a.i_ &lt; b.i_;
2728    }
2729   private:
2730    int i_;
2731  };
2732  TEST(Btree, NotAssignableType) {
2733    {
2734      absl::btree_set&lt;NotAssignable&gt; set;
2735      set.emplace(1);
2736      set.emplace_hint(set.end(), 2);
2737      set.insert(NotAssignable(3));
2738      set.insert(set.end(), NotAssignable(4));
2739      EXPECT_THAT(set, ElementsAre(1, 2, 3, 4));
2740      set.erase(set.begin());
2741      EXPECT_THAT(set, ElementsAre(2, 3, 4));
2742    }
2743    {
2744      absl::btree_multiset&lt;NotAssignable&gt; set;
2745      set.emplace(1);
2746      set.emplace_hint(set.end(), 2);
2747      set.insert(NotAssignable(2));
2748      set.insert(set.end(), NotAssignable(3));
2749      EXPECT_THAT(set, ElementsAre(1, 2, 2, 3));
2750      set.erase(set.begin());
2751      EXPECT_THAT(set, ElementsAre(2, 2, 3));
2752    }
2753    {
2754      absl::btree_map&lt;NotAssignable, int&gt; map;
2755      map.emplace(NotAssignable(1), 1);
2756      map.emplace_hint(map.end(), NotAssignable(2), 2);
2757      map.insert({NotAssignable(3), 3});
2758      map.insert(map.end(), {NotAssignable(4), 4});
2759      EXPECT_THAT(map,
2760                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2761      map.erase(map.begin());
2762      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(3, 3), Pair(4, 4)));
2763    }
2764    {
2765      absl::btree_multimap&lt;NotAssignable, int&gt; map;
2766      map.emplace(NotAssignable(1), 1);
2767      map.emplace_hint(map.end(), NotAssignable(2), 2);
2768      map.insert({NotAssignable(2), 3});
2769      map.insert(map.end(), {NotAssignable(3), 3});
2770      EXPECT_THAT(map,
2771                  ElementsAre(Pair(1, 1), Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2772      map.erase(map.begin());
2773      EXPECT_THAT(map, ElementsAre(Pair(2, 2), Pair(2, 3), Pair(3, 3)));
2774    }
2775  }
2776  struct ArenaLike {
2777    void* recycled = nullptr;
2778    size_t recycled_size = 0;
2779  };
2780  template &lt;typename T&gt;
2781  class ArenaLikeAllocator : public std::allocator&lt;T&gt; {
2782   public:
2783    template &lt;typename U&gt;
2784    struct rebind {
2785      using other = ArenaLikeAllocator&lt;U&gt;;
2786    };
2787    explicit ArenaLikeAllocator(ArenaLike* arena) noexcept : arena_(arena) {}
2788    ~ArenaLikeAllocator() {
2789      if (arena_-&gt;recycled != nullptr) {
2790        delete [] static_cast&lt;T*&gt;(arena_-&gt;recycled);
2791        arena_-&gt;recycled = nullptr;
2792      }
2793    }
2794    template&lt;typename U&gt;
2795    explicit ArenaLikeAllocator(const ArenaLikeAllocator&lt;U&gt;&amp; other) noexcept
2796        : arena_(other.arena_) {}
2797    T* allocate(size_t num_objects, const void* = nullptr) {
2798      size_t size = num_objects * sizeof(T);
2799      if (arena_-&gt;recycled != nullptr &amp;&amp; arena_-&gt;recycled_size == size) {
2800        T* result = static_cast&lt;T*&gt;(arena_-&gt;recycled);
2801        arena_-&gt;recycled = nullptr;
2802        return result;
2803      }
2804      return new T[num_objects];
2805    }
2806    void deallocate(T* p, size_t num_objects) {
2807      size_t size = num_objects * sizeof(T);
2808      memset(p, 0xde, size);
2809      if (arena_-&gt;recycled == nullptr) {
2810        arena_-&gt;recycled = p;
2811        arena_-&gt;recycled_size = size;
2812      } else {
2813        delete [] p;
2814      }
2815    }
2816    ArenaLike* arena_;
2817  };
2818  TEST(Btree, ReusePoisonMemory) {
2819    using Alloc = ArenaLikeAllocator&lt;int64_t&gt;;
2820    using Set = absl::btree_set&lt;int64_t, std::less&lt;int64_t&gt;, Alloc&gt;;
2821    ArenaLike arena;
2822    Alloc alloc(&amp;arena);
2823    Set set(alloc);
2824    set.insert(0);
2825    set.erase(0);
2826    set.insert(0);
2827  }
2828  TEST(Btree, IteratorSubtraction) {
2829    absl::BitGen bitgen;
2830    std::vector&lt;int&gt; vec;
2831    for (int i = 0; i &lt; 1000000; ++i) vec.push_back(i);
2832    absl::c_shuffle(vec, bitgen);
2833    absl::btree_set&lt;int&gt; set;
2834    for (int i : vec) set.insert(i);
2835    for (int i = 0; i &lt; 1000; ++i) {
2836      size_t begin = absl::Uniform(bitgen, 0u, set.size());
2837      size_t end = absl::Uniform(bitgen, begin, set.size());
2838      ASSERT_EQ(end - begin, set.find(end) - set.find(begin))
2839          &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end;
2840    }
2841  }
2842  TEST(Btree, DereferencingEndIterator) {
2843    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2844    absl::btree_set&lt;int&gt; set;
2845    for (int i = 0; i &lt; 1000; ++i) set.insert(i);
2846    EXPECT_DEATH(*set.end(), R&quot;regex(Dereferencing end\(\) iterator)regex&quot;);
2847  }
2848  TEST(Btree, InvalidIteratorComparison) {
2849    if (!IsAssertEnabled()) GTEST_SKIP() &lt;&lt; &quot;Assertions not enabled.&quot;;
2850    absl::btree_set&lt;int&gt; set1, set2;
2851    for (int i = 0; i &lt; 1000; ++i) {
2852      set1.insert(i);
2853      set2.insert(i);
2854    }
2855    constexpr const char *kValueInitDeathMessage =
2856        &quot;Comparing default-constructed iterator with .*non-default-constructed &quot;
2857        &quot;iterator&quot;;
2858    typename absl::btree_set&lt;int&gt;::iterator iter1, iter2;
2859    EXPECT_EQ(iter1, iter2);
2860    EXPECT_DEATH(void(set1.begin() == iter1), kValueInitDeathMessage);
2861    EXPECT_DEATH(void(iter1 == set1.begin()), kValueInitDeathMessage);
2862    constexpr const char *kDifferentContainerDeathMessage =
2863        &quot;Comparing iterators from different containers&quot;;
2864    iter1 = set1.begin();
2865    iter2 = set2.begin();
2866    EXPECT_DEATH(void(iter1 == iter2), kDifferentContainerDeathMessage);
2867    EXPECT_DEATH(void(iter2 == iter1), kDifferentContainerDeathMessage);
2868  }
2869  TEST(Btree, InvalidPointerUse) {
2870    if (!kAsan)
2871      GTEST_SKIP() &lt;&lt; &quot;We only detect invalid pointer use in ASan mode.&quot;;
2872    absl::btree_set&lt;int&gt; set;
2873    set.insert(0);
2874    const int *ptr = &amp;*set.begin();
2875    set.insert(1);
2876    EXPECT_DEATH(std::cout &lt;&lt; *ptr, &quot;heap-use-after-free&quot;);
2877    size_t slots_per_node = BtreeNodePeer::GetNumSlotsPerNode&lt;decltype(set)&gt;();
2878    for (int i = 2; i &lt; slots_per_node - 1; ++i) set.insert(i);
2879    ptr = &amp;*set.begin();
2880    set.insert(static_cast&lt;int&gt;(slots_per_node));
2881    EXPECT_DEATH(std::cout &lt;&lt; *ptr, &quot;heap-use-after-free&quot;);
2882  }
2883  template&lt;typename Set&gt;
2884  void TestBasicFunctionality(Set set) {
2885    using value_type = typename Set::value_type;
2886    for (int i = 0; i &lt; 100; ++i) { set.insert(value_type(i)); }
2887    for (int i = 50; i &lt; 100; ++i) { set.erase(value_type(i)); }
2888    auto it = set.begin();
2889    for (int i = 0; i &lt; 50; ++i, ++it) {
2890      ASSERT_EQ(set.find(value_type(i)), it) &lt;&lt; i;
2891    }
2892  }
2893  template&lt;size_t align&gt;
2894  struct alignas(align) OveralignedKey {
2895    explicit OveralignedKey(int i) : key(i) {}
2896    bool operator&lt;(const OveralignedKey &amp;other) const { return key &lt; other.key; }
2897    int key = 0;
2898  };
2899  TEST(Btree, OveralignedKey) {
2900    TestBasicFunctionality(
2901        SizedBtreeSet&lt;OveralignedKey&lt;16&gt;, &amp;bsol;*TargetValuesPerNode=*/8&gt;());
2902    TestBasicFunctionality(
2903        SizedBtreeSet&lt;OveralignedKey&lt;16&gt;, &amp;bsol;*TargetValuesPerNode=*/9&gt;());
2904  }
2905  TEST(Btree, FieldTypeEqualsSlotType) {
2906    using set_type = absl::btree_set&lt;uint8_t&gt;;
2907    static_assert(BtreeNodePeer::FieldTypeEqualsSlotType&lt;set_type&gt;(), &quot;&quot;);
2908    TestBasicFunctionality(set_type());
2909  }
2910  }  
2911  }  
2912  ABSL_NAMESPACE_END
2913  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>309    }
310    iterator insert(iterator position, const value_type &amp;v) {
311      int size = this-&gt;tree_.size();
312      std::pair&lt;typename CheckerType::iterator, bool&gt; checker_res =
</pre></code></div>
                <div class="column column_space"><pre><code>347    }
348    iterator insert(iterator position, const value_type &amp;v) {
349      int size = this-&gt;tree_.size();
350      auto checker_res = this-&gt;checker_.insert(v);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    