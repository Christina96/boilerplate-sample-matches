
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.cpp</h3>
            <pre><code>1  #include <nano/lib/blockbuilders.hpp>
2  #include <unordered_map>
3  #include <cryptopp/osrng.h>
4  namespace
5  {
6  template <typename BLOCKTYPE>
7  void previous_hex_impl (std::string const & previous_hex, std::error_code & ec, BLOCKTYPE & block)
8  {
9  	nano::block_hash previous;
10  	if (!previous.decode_hex (previous_hex))
11  	{
12  		block->hashables.previous = previous;
13  	}
14  	else
15  	{
16  		ec = nano::error_common::bad_previous;
17  	}
18  }
19  template <typename BLOCKTYPE>
20  void account_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
21  {
22  	nano::account account;
23  	if (!account.decode_hex (account_hex))
24  	{
25  		block->hashables.account = account;
26  	}
27  	else
28  	{
29  		ec = nano::error_common::bad_account_number;
30  	}
31  }
32  template <typename BLOCKTYPE>
33  void account_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
34  {
35  	nano::account account;
36  	if (!account.decode_account (address))
37  	{
38  		block->hashables.account = account;
39  	}
40  	else
41  	{
42  		ec = nano::error_common::bad_account_number;
43  	}
44  }
45  template <typename BLOCKTYPE>
46  void representative_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
47  {
48  	nano::account account;
49  	if (!account.decode_hex (account_hex))
50  	{
51  		block->hashables.representative = account;
52  	}
53  	else
54  	{
55  		ec = nano::error_common::bad_representative_number;
56  	}
57  }
58  template <typename BLOCKTYPE>
59  void representative_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
60  {
61  	nano::account account;
62  	if (!account.decode_account (address))
63  	{
64  		block->hashables.representative = account;
65  	}
66  	else
67  	{
68  		ec = nano::error_common::bad_representative_number;
69  	}
70  }
71  template <typename BLOCKTYPE>
72  void destination_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
73  {
74  	nano::account account;
75  	if (!account.decode_hex (account_hex))
76  	{
77  		block->hashables.destination = account;
78  	}
79  	else
80  	{
81  		ec = nano::error_common::bad_account_number;
82  	}
83  }
84  template <typename BLOCKTYPE>
85  void destination_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
86  {
87  	nano::account account;
88  	if (!account.decode_account (address))
89  	{
90  		block->hashables.destination = account;
91  	}
92  	else
93  	{
94  		ec = nano::error_common::bad_account_number;
95  	}
96  }
97  template <typename BLOCKTYPE>
98  void source_hex_impl (std::string const & source_hex, std::error_code & ec, BLOCKTYPE & block)
99  {
100  	nano::block_hash source;
101  	if (!source.decode_hex (source_hex))
102  	{
103  		block->hashables.source = source;
104  	}
105  	else
106  	{
107  		ec = nano::error_common::bad_source;
108  	}
109  }
110  template <typename BLOCKTYPE>
111  void balance_dec_impl (std::string const & balance_decimal, std::error_code & ec, BLOCKTYPE & block)
112  {
113  	nano::amount balance;
114  	if (!balance.decode_dec (balance_decimal))
115  	{
116  		block->hashables.balance = balance;
117  	}
118  	else
119  	{
120  		ec = nano::error_common::bad_balance;
121  	}
122  }
123  template <typename BLOCKTYPE>
124  void balance_hex_impl (std::string const & balance_hex, std::error_code & ec, BLOCKTYPE & block)
125  {
126  	nano::amount balance;
127  	if (!balance.decode_hex (balance_hex))
128  	{
129  		block->hashables.balance = balance;
130  	}
131  	else
132  	{
133  		ec = nano::error_common::bad_balance;
134  	}
135  }
136  std::unordered_map<uint8_t, std::error_code> ec_map = {
137  	{ static_cast<uint8_t> (nano::build_flags::account_present), nano::error_common::missing_account },
138  	{ static_cast<uint8_t> (nano::build_flags::balance_present), nano::error_common::missing_balance },
139  	{ static_cast<uint8_t> (nano::build_flags::link_present), nano::error_common::missing_link },
140  	{ static_cast<uint8_t> (nano::build_flags::previous_present), nano::error_common::missing_previous },
141  	{ static_cast<uint8_t> (nano::build_flags::representative_present), nano::error_common::missing_representative },
142  	{ static_cast<uint8_t> (nano::build_flags::signature_present), nano::error_common::missing_signature },
143  	{ static_cast<uint8_t> (nano::build_flags::work_present), nano::error_common::missing_work }
144  };
145  inline signed ffs_mask (uint8_t num)
146  {
147  	for (signed i = 0; i < 8; i++)
148  	{
149  		if ((num >> i) & 1)
150  		{
151  			return 1 << i;
152  		}
153  	}
154  	return -1;
155  }
156  std::error_code check_fields_set (uint8_t block_all_flags, uint8_t build_state)
157  {
158  	std::error_code ec;
159  	uint8_t res = block_all_flags ^ build_state;
160  	if (res)
161  	{
162  		auto build_flags_mask = static_cast<uint8_t> (ffs_mask (res));
163  		debug_assert (ec_map.find (build_flags_mask) != ec_map.end ());
164  		ec = ec_map[build_flags_mask];
165  	}
166  	return ec;
167  }
168  } 
169  nano::state_block_builder::state_block_builder ()
170  {
171  	make_block ();
172  }
173  nano::state_block_builder & nano::state_block_builder::make_block ()
174  {
175  	construct_block ();
176  	return *this;
177  }
178  nano::state_block_builder & nano::state_block_builder::from (nano::state_block const & other_block)
179  {
180  	block->work = other_block.work;
181  	build_state |= build_flags::work_present;
182  	block->signature = other_block.signature;
183  	build_state |= build_flags::signature_present;
184  	block->hashables.account = other_block.hashables.account;
185  	build_state |= build_flags::account_present;
186  	block->hashables.balance = other_block.hashables.balance;
187  	build_state |= build_flags::balance_present;
188  	block->hashables.link = other_block.hashables.link;
189  	build_state |= build_flags::link_present;
190  	block->hashables.previous = other_block.hashables.previous;
191  	build_state |= build_flags::previous_present;
192  	block->hashables.representative = other_block.hashables.representative;
193  	build_state |= build_flags::representative_present;
194  	return *this;
195  }
196  void nano::state_block_builder::validate ()
197  {
198  	if (!ec)
199  	{
200  		ec = check_fields_set (required_fields, build_state);
201  	}
202  }
203  nano::state_block_builder & nano::state_block_builder::zero ()
204  {
205  	block->work = uint64_t (0);
206  	block->signature.clear ();
207  	block->hashables.account.clear ();
208  	block->hashables.balance.clear ();
209  	block->hashables.link.clear ();
210  	block->hashables.previous.clear ();
211  	block->hashables.representative.clear ();
212  	build_state = required_fields;
213  	return *this;
214  }
215  nano::state_block_builder & nano::state_block_builder::account (nano::account const & account)
216  {
217  	block->hashables.account = account;
218  	build_state |= build_flags::account_present;
219  	return *this;
220  }
221  nano::state_block_builder & nano::state_block_builder::account_hex (std::string const & account_hex)
222  {
223  	account_hex_impl (account_hex, ec, block);
224  	build_state |= build_flags::account_present;
225  	return *this;
226  }
227  nano::state_block_builder & nano::state_block_builder::account_address (std::string const & address)
228  {
229  	account_address_impl (address, ec, block);
230  	build_state |= build_flags::account_present;
231  	return *this;
232  }
233  nano::state_block_builder & nano::state_block_builder::representative (nano::account const & account)
234  {
235  	block->hashables.representative = account;
236  	build_state |= build_flags::representative_present;
237  	return *this;
238  }
239  nano::state_block_builder & nano::state_block_builder::representative_hex (std::string const & account_hex)
240  {
241  	representative_hex_impl (account_hex, ec, block);
242  	build_state |= build_flags::representative_present;
243  	return *this;
244  }
245  nano::state_block_builder & nano::state_block_builder::representative_address (std::string const & address)
246  {
247  	representative_address_impl (address, ec, block);
248  	build_state |= build_flags::representative_present;
249  	return *this;
250  }
251  nano::state_block_builder & nano::state_block_builder::previous (nano::block_hash const & previous)
252  {
253  	block->hashables.previous = previous;
254  	build_state |= build_flags::previous_present;
255  	return *this;
256  }
257  nano::state_block_builder & nano::state_block_builder::previous_hex (std::string const & previous_hex)
258  {
259  	previous_hex_impl (previous_hex, ec, block);
260  	build_state |= build_flags::previous_present;
261  	return *this;
262  }
263  nano::state_block_builder & nano::state_block_builder::balance (nano::amount const & balance)
264  {
265  	block->hashables.balance = balance;
266  	build_state |= build_flags::balance_present;
267  	return *this;
268  }
269  nano::state_block_builder & nano::state_block_builder::balance_dec (std::string const & balance_decimal)
270  {
271  	balance_dec_impl (balance_decimal, ec, block);
272  	build_state |= build_flags::balance_present;
273  	return *this;
274  }
275  nano::state_block_builder & nano::state_block_builder::balance_hex (std::string const & balance_hex)
276  {
277  	balance_hex_impl (balance_hex, ec, block);
278  	build_state |= build_flags::balance_present;
279  	return *this;
280  }
281  nano::state_block_builder & nano::state_block_builder::link (nano::link const & link)
282  {
283  	block->hashables.link = link;
284  	build_state |= build_flags::link_present;
285  	return *this;
286  }
287  nano::state_block_builder & nano::state_block_builder::link_hex (std::string const & link_hex)
288  {
289  	nano::link link;
290  	if (!link.decode_hex (link_hex))
291  	{
292  		block->hashables.link = link;
293  		build_state |= build_flags::link_present;
294  	}
295  	else
296  	{
297  		ec = nano::error_common::bad_link;
298  	}
299  	return *this;
300  }
301  nano::state_block_builder & nano::state_block_builder::link_address (std::string const & link_address)
302  {
303  	nano::link link;
304  	if (!link.decode_account (link_address))
305  	{
306  		block->hashables.link = link;
307  		build_state |= build_flags::link_present;
308  	}
309  	else
310  	{
311  		ec = nano::error_common::bad_link;
312  	}
313  	return *this;
314  }
315  nano::open_block_builder::open_block_builder ()
316  {
317  	make_block ();
318  }
319  nano::open_block_builder & nano::open_block_builder::make_block ()
320  {
321  	construct_block ();
322  	return *this;
323  }
324  void nano::open_block_builder::validate ()
325  {
326  	if (!ec)
327  	{
328  		ec = check_fields_set (required_fields, build_state);
329  	}
330  }
331  nano::open_block_builder & nano::open_block_builder::zero ()
332  {
333  	block->work = uint64_t (0);
334  	block->signature.clear ();
335  	block->hashables.account.clear ();
336  	block->hashables.representative.clear ();
337  	block->hashables.source.clear ();
338  	build_state = required_fields;
339  	return *this;
340  }
341  nano::open_block_builder & nano::open_block_builder::account (nano::account account)
342  {
343  	block->hashables.account = account;
344  	build_state |= build_flags::account_present;
345  	return *this;
346  }
347  nano::open_block_builder & nano::open_block_builder::account_hex (std::string account_hex)
348  {
349  	account_hex_impl (account_hex, ec, block);
350  	build_state |= build_flags::account_present;
351  	return *this;
352  }
353  nano::open_block_builder & nano::open_block_builder::account_address (std::string address)
354  {
355  	account_address_impl (address, ec, block);
356  	build_state |= build_flags::account_present;
357  	return *this;
358  }
359  nano::open_block_builder & nano::open_block_builder::representative (nano::account account)
360  {
361  	block->hashables.representative = account;
362  	build_state |= build_flags::representative_present;
363  	return *this;
364  }
365  nano::open_block_builder & nano::open_block_builder::representative_hex (std::string account_hex)
366  {
367  	representative_hex_impl (account_hex, ec, block);
368  	build_state |= build_flags::representative_present;
369  	return *this;
370  }
371  nano::open_block_builder & nano::open_block_builder::representative_address (std::string address)
372  {
373  	representative_address_impl (address, ec, block);
374  	build_state |= build_flags::representative_present;
375  	return *this;
376  }
377  nano::open_block_builder & nano::open_block_builder::source (nano::block_hash source)
378  {
379  	block->hashables.source = source;
380  	build_state |= build_flags::link_present;
381  	return *this;
382  }
383  nano::open_block_builder & nano::open_block_builder::source_hex (std::string source_hex)
384  {
385  	source_hex_impl (source_hex, ec, block);
386  	build_state |= build_flags::link_present;
387  	return *this;
388  }
389  nano::change_block_builder::change_block_builder ()
390  {
391  	make_block ();
392  }
393  nano::change_block_builder & nano::change_block_builder::make_block ()
394  {
395  	construct_block ();
396  	return *this;
397  }
398  void nano::change_block_builder::validate ()
399  {
400  	if (!ec)
401  	{
402  		ec = check_fields_set (required_fields, build_state);
403  	}
404  }
405  nano::change_block_builder & nano::change_block_builder::zero ()
406  {
407  	block->work = uint64_t (0);
408  	block->signature.clear ();
409  	block->hashables.previous.clear ();
410  	block->hashables.representative.clear ();
<span onclick='openModal()' class='match'>411  	build_state = required_fields;
412  	return *this;
413  }
414  nano::change_block_builder & nano::change_block_builder::representative (nano::account account)
415  {
416  	block->hashables.representative = account;
</span>417  	build_state |= build_flags::representative_present;
418  	return *this;
419  }
420  nano::change_block_builder & nano::change_block_builder::representative_hex (std::string account_hex)
421  {
422  	representative_hex_impl (account_hex, ec, block);
423  	build_state |= build_flags::representative_present;
424  	return *this;
425  }
426  nano::change_block_builder & nano::change_block_builder::representative_address (std::string address)
427  {
428  	representative_address_impl (address, ec, block);
429  	build_state |= build_flags::representative_present;
430  	return *this;
431  }
432  nano::change_block_builder & nano::change_block_builder::previous (nano::block_hash previous)
433  {
434  	block->hashables.previous = previous;
435  	build_state |= build_flags::previous_present;
436  	return *this;
437  }
438  nano::change_block_builder & nano::change_block_builder::previous_hex (std::string previous_hex)
439  {
440  	previous_hex_impl (previous_hex, ec, block);
441  	build_state |= build_flags::previous_present;
442  	return *this;
443  }
444  nano::send_block_builder::send_block_builder ()
445  {
446  	make_block ();
447  }
448  nano::send_block_builder & nano::send_block_builder::make_block ()
449  {
450  	construct_block ();
451  	return *this;
452  }
453  void nano::send_block_builder::validate ()
454  {
455  	if (!ec)
456  	{
457  		ec = check_fields_set (required_fields, build_state);
458  	}
459  }
460  nano::send_block_builder & nano::send_block_builder::zero ()
461  {
462  	block->work = uint64_t (0);
463  	block->signature.clear ();
464  	block->hashables.previous.clear ();
465  	block->hashables.destination.clear ();
466  	block->hashables.balance.clear ();
467  	build_state = required_fields;
468  	return *this;
469  }
470  nano::send_block_builder & nano::send_block_builder::destination (nano::account account)
471  {
472  	block->hashables.destination = account;
473  	build_state |= build_flags::link_present;
474  	return *this;
475  }
476  nano::send_block_builder & nano::send_block_builder::destination_hex (std::string account_hex)
477  {
478  	destination_hex_impl (account_hex, ec, block);
479  	build_state |= build_flags::link_present;
480  	return *this;
481  }
482  nano::send_block_builder & nano::send_block_builder::destination_address (std::string address)
483  {
484  	destination_address_impl (address, ec, block);
485  	build_state |= build_flags::link_present;
486  	return *this;
487  }
488  nano::send_block_builder & nano::send_block_builder::previous (nano::block_hash previous)
489  {
490  	block->hashables.previous = previous;
491  	build_state |= build_flags::previous_present;
492  	return *this;
493  }
494  nano::send_block_builder & nano::send_block_builder::previous_hex (std::string previous_hex)
495  {
496  	previous_hex_impl (previous_hex, ec, block);
497  	build_state |= build_flags::previous_present;
498  	return *this;
499  }
500  nano::send_block_builder & nano::send_block_builder::balance (nano::amount balance)
501  {
502  	block->hashables.balance = balance;
503  	build_state |= build_flags::balance_present;
504  	return *this;
505  }
506  nano::send_block_builder & nano::send_block_builder::balance_dec (std::string balance_decimal)
507  {
508  	balance_dec_impl (balance_decimal, ec, block);
509  	build_state |= build_flags::balance_present;
510  	return *this;
511  }
512  nano::send_block_builder & nano::send_block_builder::balance_hex (std::string balance_hex)
513  {
514  	balance_hex_impl (balance_hex, ec, block);
515  	build_state |= build_flags::balance_present;
516  	return *this;
517  }
518  nano::receive_block_builder::receive_block_builder ()
519  {
520  	make_block ();
521  }
522  nano::receive_block_builder & nano::receive_block_builder::make_block ()
523  {
524  	construct_block ();
525  	return *this;
526  }
527  void nano::receive_block_builder::validate ()
528  {
529  	if (!ec)
530  	{
531  		ec = check_fields_set (required_fields, build_state);
532  	}
533  }
534  nano::receive_block_builder & nano::receive_block_builder::zero ()
535  {
536  	block->work = uint64_t (0);
537  	block->signature.clear ();
538  	block->hashables.previous.clear ();
539  	block->hashables.source.clear ();
540  	build_state = required_fields;
541  	return *this;
542  }
543  nano::receive_block_builder & nano::receive_block_builder::previous (nano::block_hash previous)
544  {
545  	block->hashables.previous = previous;
546  	build_state |= build_flags::previous_present;
547  	return *this;
548  }
549  nano::receive_block_builder & nano::receive_block_builder::previous_hex (std::string previous_hex)
550  {
551  	previous_hex_impl (previous_hex, ec, block);
552  	build_state |= build_flags::previous_present;
553  	return *this;
554  }
555  nano::receive_block_builder & nano::receive_block_builder::source (nano::block_hash source)
556  {
557  	block->hashables.source = source;
558  	build_state |= build_flags::link_present;
559  	return *this;
560  }
561  nano::receive_block_builder & nano::receive_block_builder::source_hex (std::string source_hex)
562  {
563  	source_hex_impl (source_hex, ec, block);
564  	build_state |= build_flags::link_present;
565  	return *this;
566  }
567  template <typename BLOCKTYPE, typename BUILDER>
568  std::unique_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build ()
569  {
570  	if (!ec)
571  	{
572  		static_cast<BUILDER *> (this)->validate ();
573  	}
574  	debug_assert (!ec);
575  	return std::move (block);
576  }
577  template <typename BLOCKTYPE, typename BUILDER>
578  std::unique_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build (std::error_code & ec)
579  {
580  	if (!this->ec)
581  	{
582  		static_cast<BUILDER *> (this)->validate ();
583  	}
584  	ec = this->ec;
585  	return std::move (block);
586  }
587  template <typename BLOCKTYPE, typename BUILDER>
588  std::shared_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build_shared ()
589  {
590  	return std::move (build ());
591  }
592  template <typename BLOCKTYPE, typename BUILDER>
593  std::shared_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build_shared (std::error_code & ec)
594  {
595  	return std::move (build (ec));
596  }
597  template <typename BLOCKTYPE, typename BUILDER>
598  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::work (uint64_t work)
599  {
600  	block->work = work;
601  	build_state |= build_flags::work_present;
602  	return *this;
603  }
604  template <typename BLOCKTYPE, typename BUILDER>
605  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::sign (nano::raw_key const & private_key, nano::public_key const & public_key)
606  {
607  	block->signature = nano::sign_message (private_key, public_key, block->hash ());
608  	build_state |= build_flags::signature_present;
609  	return *this;
610  }
611  template <typename BLOCKTYPE, typename BUILDER>
612  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::sign_zero ()
613  {
614  	block->signature.clear ();
615  	build_state |= build_flags::signature_present;
616  	return *this;
617  }
618  template <typename BLOCKTYPE, typename BUILDER>
619  void nano::abstract_builder<BLOCKTYPE, BUILDER>::construct_block ()
620  {
621  	block = std::make_unique<BLOCKTYPE> ();
622  	ec.clear ();
623  	build_state = 0;
624  }
625  template class nano::abstract_builder<nano::open_block, nano::open_block_builder>;
626  template class nano::abstract_builder<nano::send_block, nano::send_block_builder>;
627  template class nano::abstract_builder<nano::receive_block, nano::receive_block_builder>;
628  template class nano::abstract_builder<nano::change_block, nano::change_block_builder>;
629  template class nano::abstract_builder<nano::state_block, nano::state_block_builder>;
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.cpp</h3>
            <pre><code>1  #include <nano/lib/blockbuilders.hpp>
2  #include <unordered_map>
3  #include <cryptopp/osrng.h>
4  namespace
5  {
6  template <typename BLOCKTYPE>
7  void previous_hex_impl (std::string const & previous_hex, std::error_code & ec, BLOCKTYPE & block)
8  {
9  	nano::block_hash previous;
10  	if (!previous.decode_hex (previous_hex))
11  	{
12  		block->hashables.previous = previous;
13  	}
14  	else
15  	{
16  		ec = nano::error_common::bad_previous;
17  	}
18  }
19  template <typename BLOCKTYPE>
20  void account_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
21  {
22  	nano::account account;
23  	if (!account.decode_hex (account_hex))
24  	{
25  		block->hashables.account = account;
26  	}
27  	else
28  	{
29  		ec = nano::error_common::bad_account_number;
30  	}
31  }
32  template <typename BLOCKTYPE>
33  void account_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
34  {
35  	nano::account account;
36  	if (!account.decode_account (address))
37  	{
38  		block->hashables.account = account;
39  	}
40  	else
41  	{
42  		ec = nano::error_common::bad_account_number;
43  	}
44  }
45  template <typename BLOCKTYPE>
46  void representative_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
47  {
48  	nano::account account;
49  	if (!account.decode_hex (account_hex))
50  	{
51  		block->hashables.representative = account;
52  	}
53  	else
54  	{
55  		ec = nano::error_common::bad_representative_number;
56  	}
57  }
58  template <typename BLOCKTYPE>
59  void representative_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
60  {
61  	nano::account account;
62  	if (!account.decode_account (address))
63  	{
64  		block->hashables.representative = account;
65  	}
66  	else
67  	{
68  		ec = nano::error_common::bad_representative_number;
69  	}
70  }
71  template <typename BLOCKTYPE>
72  void destination_hex_impl (std::string const & account_hex, std::error_code & ec, BLOCKTYPE & block)
73  {
74  	nano::account account;
75  	if (!account.decode_hex (account_hex))
76  	{
77  		block->hashables.destination = account;
78  	}
79  	else
80  	{
81  		ec = nano::error_common::bad_account_number;
82  	}
83  }
84  template <typename BLOCKTYPE>
85  void destination_address_impl (std::string const & address, std::error_code & ec, BLOCKTYPE & block)
86  {
87  	nano::account account;
88  	if (!account.decode_account (address))
89  	{
90  		block->hashables.destination = account;
91  	}
92  	else
93  	{
94  		ec = nano::error_common::bad_account_number;
95  	}
96  }
97  template <typename BLOCKTYPE>
98  void source_hex_impl (std::string const & source_hex, std::error_code & ec, BLOCKTYPE & block)
99  {
100  	nano::block_hash source;
101  	if (!source.decode_hex (source_hex))
102  	{
103  		block->hashables.source = source;
104  	}
105  	else
106  	{
107  		ec = nano::error_common::bad_source;
108  	}
109  }
110  template <typename BLOCKTYPE>
111  void balance_dec_impl (std::string const & balance_decimal, std::error_code & ec, BLOCKTYPE & block)
112  {
113  	nano::amount balance;
114  	if (!balance.decode_dec (balance_decimal))
115  	{
116  		block->hashables.balance = balance;
117  	}
118  	else
119  	{
120  		ec = nano::error_common::bad_balance;
121  	}
122  }
123  template <typename BLOCKTYPE>
124  void balance_hex_impl (std::string const & balance_hex, std::error_code & ec, BLOCKTYPE & block)
125  {
126  	nano::amount balance;
127  	if (!balance.decode_hex (balance_hex))
128  	{
129  		block->hashables.balance = balance;
130  	}
131  	else
132  	{
133  		ec = nano::error_common::bad_balance;
134  	}
135  }
136  std::unordered_map<uint8_t, std::error_code> ec_map = {
137  	{ static_cast<uint8_t> (nano::build_flags::account_present), nano::error_common::missing_account },
138  	{ static_cast<uint8_t> (nano::build_flags::balance_present), nano::error_common::missing_balance },
139  	{ static_cast<uint8_t> (nano::build_flags::link_present), nano::error_common::missing_link },
140  	{ static_cast<uint8_t> (nano::build_flags::previous_present), nano::error_common::missing_previous },
141  	{ static_cast<uint8_t> (nano::build_flags::representative_present), nano::error_common::missing_representative },
142  	{ static_cast<uint8_t> (nano::build_flags::signature_present), nano::error_common::missing_signature },
143  	{ static_cast<uint8_t> (nano::build_flags::work_present), nano::error_common::missing_work }
144  };
145  inline signed ffs_mask (uint8_t num)
146  {
147  	for (signed i = 0; i < 8; i++)
148  	{
149  		if ((num >> i) & 1)
150  		{
151  			return 1 << i;
152  		}
153  	}
154  	return -1;
155  }
156  std::error_code check_fields_set (uint8_t block_all_flags, uint8_t build_state)
157  {
158  	std::error_code ec;
159  	uint8_t res = block_all_flags ^ build_state;
160  	if (res)
161  	{
162  		auto build_flags_mask = static_cast<uint8_t> (ffs_mask (res));
163  		debug_assert (ec_map.find (build_flags_mask) != ec_map.end ());
164  		ec = ec_map[build_flags_mask];
165  	}
166  	return ec;
167  }
168  } 
169  nano::state_block_builder::state_block_builder ()
170  {
171  	make_block ();
172  }
173  nano::state_block_builder & nano::state_block_builder::make_block ()
174  {
175  	construct_block ();
176  	return *this;
177  }
178  nano::state_block_builder & nano::state_block_builder::from (nano::state_block const & other_block)
179  {
180  	block->work = other_block.work;
181  	build_state |= build_flags::work_present;
182  	block->signature = other_block.signature;
183  	build_state |= build_flags::signature_present;
184  	block->hashables.account = other_block.hashables.account;
185  	build_state |= build_flags::account_present;
186  	block->hashables.balance = other_block.hashables.balance;
187  	build_state |= build_flags::balance_present;
188  	block->hashables.link = other_block.hashables.link;
189  	build_state |= build_flags::link_present;
190  	block->hashables.previous = other_block.hashables.previous;
191  	build_state |= build_flags::previous_present;
192  	block->hashables.representative = other_block.hashables.representative;
193  	build_state |= build_flags::representative_present;
194  	return *this;
195  }
196  void nano::state_block_builder::validate ()
197  {
198  	if (!ec)
199  	{
200  		ec = check_fields_set (required_fields, build_state);
201  	}
202  }
203  nano::state_block_builder & nano::state_block_builder::zero ()
204  {
205  	block->work = uint64_t (0);
206  	block->signature.clear ();
207  	block->hashables.account.clear ();
208  	block->hashables.balance.clear ();
209  	block->hashables.link.clear ();
210  	block->hashables.previous.clear ();
211  	block->hashables.representative.clear ();
212  	build_state = required_fields;
213  	return *this;
214  }
215  nano::state_block_builder & nano::state_block_builder::account (nano::account const & account)
216  {
217  	block->hashables.account = account;
218  	build_state |= build_flags::account_present;
219  	return *this;
220  }
221  nano::state_block_builder & nano::state_block_builder::account_hex (std::string const & account_hex)
222  {
223  	account_hex_impl (account_hex, ec, block);
224  	build_state |= build_flags::account_present;
225  	return *this;
226  }
227  nano::state_block_builder & nano::state_block_builder::account_address (std::string const & address)
228  {
229  	account_address_impl (address, ec, block);
230  	build_state |= build_flags::account_present;
231  	return *this;
232  }
233  nano::state_block_builder & nano::state_block_builder::representative (nano::account const & account)
234  {
235  	block->hashables.representative = account;
236  	build_state |= build_flags::representative_present;
237  	return *this;
238  }
239  nano::state_block_builder & nano::state_block_builder::representative_hex (std::string const & account_hex)
240  {
241  	representative_hex_impl (account_hex, ec, block);
242  	build_state |= build_flags::representative_present;
243  	return *this;
244  }
245  nano::state_block_builder & nano::state_block_builder::representative_address (std::string const & address)
246  {
247  	representative_address_impl (address, ec, block);
248  	build_state |= build_flags::representative_present;
249  	return *this;
250  }
251  nano::state_block_builder & nano::state_block_builder::previous (nano::block_hash const & previous)
252  {
253  	block->hashables.previous = previous;
254  	build_state |= build_flags::previous_present;
255  	return *this;
256  }
257  nano::state_block_builder & nano::state_block_builder::previous_hex (std::string const & previous_hex)
258  {
259  	previous_hex_impl (previous_hex, ec, block);
260  	build_state |= build_flags::previous_present;
261  	return *this;
262  }
263  nano::state_block_builder & nano::state_block_builder::balance (nano::amount const & balance)
264  {
265  	block->hashables.balance = balance;
266  	build_state |= build_flags::balance_present;
267  	return *this;
268  }
269  nano::state_block_builder & nano::state_block_builder::balance_dec (std::string const & balance_decimal)
270  {
271  	balance_dec_impl (balance_decimal, ec, block);
272  	build_state |= build_flags::balance_present;
273  	return *this;
274  }
275  nano::state_block_builder & nano::state_block_builder::balance_hex (std::string const & balance_hex)
276  {
277  	balance_hex_impl (balance_hex, ec, block);
278  	build_state |= build_flags::balance_present;
279  	return *this;
280  }
281  nano::state_block_builder & nano::state_block_builder::link (nano::link const & link)
282  {
283  	block->hashables.link = link;
284  	build_state |= build_flags::link_present;
285  	return *this;
286  }
287  nano::state_block_builder & nano::state_block_builder::link_hex (std::string const & link_hex)
288  {
289  	nano::link link;
290  	if (!link.decode_hex (link_hex))
291  	{
292  		block->hashables.link = link;
293  		build_state |= build_flags::link_present;
294  	}
295  	else
296  	{
297  		ec = nano::error_common::bad_link;
298  	}
299  	return *this;
300  }
301  nano::state_block_builder & nano::state_block_builder::link_address (std::string const & link_address)
302  {
303  	nano::link link;
304  	if (!link.decode_account (link_address))
305  	{
306  		block->hashables.link = link;
307  		build_state |= build_flags::link_present;
308  	}
309  	else
310  	{
311  		ec = nano::error_common::bad_link;
312  	}
313  	return *this;
314  }
315  nano::open_block_builder::open_block_builder ()
316  {
317  	make_block ();
318  }
319  nano::open_block_builder & nano::open_block_builder::make_block ()
320  {
321  	construct_block ();
322  	return *this;
323  }
324  void nano::open_block_builder::validate ()
325  {
326  	if (!ec)
327  	{
328  		ec = check_fields_set (required_fields, build_state);
329  	}
330  }
331  nano::open_block_builder & nano::open_block_builder::zero ()
332  {
333  	block->work = uint64_t (0);
334  	block->signature.clear ();
335  	block->hashables.account.clear ();
336  	block->hashables.representative.clear ();
337  	block->hashables.source.clear ();
338  	build_state = required_fields;
339  	return *this;
340  }
341  nano::open_block_builder & nano::open_block_builder::account (nano::account account)
342  {
343  	block->hashables.account = account;
344  	build_state |= build_flags::account_present;
345  	return *this;
346  }
347  nano::open_block_builder & nano::open_block_builder::account_hex (std::string account_hex)
348  {
349  	account_hex_impl (account_hex, ec, block);
350  	build_state |= build_flags::account_present;
351  	return *this;
352  }
353  nano::open_block_builder & nano::open_block_builder::account_address (std::string address)
354  {
355  	account_address_impl (address, ec, block);
356  	build_state |= build_flags::account_present;
357  	return *this;
358  }
359  nano::open_block_builder & nano::open_block_builder::representative (nano::account account)
360  {
361  	block->hashables.representative = account;
362  	build_state |= build_flags::representative_present;
363  	return *this;
364  }
365  nano::open_block_builder & nano::open_block_builder::representative_hex (std::string account_hex)
366  {
367  	representative_hex_impl (account_hex, ec, block);
368  	build_state |= build_flags::representative_present;
369  	return *this;
370  }
371  nano::open_block_builder & nano::open_block_builder::representative_address (std::string address)
372  {
373  	representative_address_impl (address, ec, block);
374  	build_state |= build_flags::representative_present;
375  	return *this;
376  }
377  nano::open_block_builder & nano::open_block_builder::source (nano::block_hash source)
378  {
379  	block->hashables.source = source;
380  	build_state |= build_flags::link_present;
381  	return *this;
382  }
383  nano::open_block_builder & nano::open_block_builder::source_hex (std::string source_hex)
384  {
385  	source_hex_impl (source_hex, ec, block);
386  	build_state |= build_flags::link_present;
387  	return *this;
388  }
389  nano::change_block_builder::change_block_builder ()
390  {
391  	make_block ();
392  }
393  nano::change_block_builder & nano::change_block_builder::make_block ()
394  {
395  	construct_block ();
396  	return *this;
397  }
398  void nano::change_block_builder::validate ()
399  {
400  	if (!ec)
401  	{
402  		ec = check_fields_set (required_fields, build_state);
403  	}
404  }
405  nano::change_block_builder & nano::change_block_builder::zero ()
406  {
407  	block->work = uint64_t (0);
408  	block->signature.clear ();
409  	block->hashables.previous.clear ();
410  	block->hashables.representative.clear ();
411  	build_state = required_fields;
412  	return *this;
413  }
414  nano::change_block_builder & nano::change_block_builder::representative (nano::account account)
415  {
416  	block->hashables.representative = account;
417  	build_state |= build_flags::representative_present;
418  	return *this;
419  }
420  nano::change_block_builder & nano::change_block_builder::representative_hex (std::string account_hex)
421  {
422  	representative_hex_impl (account_hex, ec, block);
423  	build_state |= build_flags::representative_present;
424  	return *this;
425  }
426  nano::change_block_builder & nano::change_block_builder::representative_address (std::string address)
427  {
428  	representative_address_impl (address, ec, block);
429  	build_state |= build_flags::representative_present;
430  	return *this;
431  }
432  nano::change_block_builder & nano::change_block_builder::previous (nano::block_hash previous)
433  {
434  	block->hashables.previous = previous;
435  	build_state |= build_flags::previous_present;
436  	return *this;
437  }
438  nano::change_block_builder & nano::change_block_builder::previous_hex (std::string previous_hex)
439  {
440  	previous_hex_impl (previous_hex, ec, block);
441  	build_state |= build_flags::previous_present;
442  	return *this;
443  }
444  nano::send_block_builder::send_block_builder ()
445  {
446  	make_block ();
447  }
448  nano::send_block_builder & nano::send_block_builder::make_block ()
449  {
450  	construct_block ();
451  	return *this;
452  }
453  void nano::send_block_builder::validate ()
454  {
455  	if (!ec)
456  	{
457  		ec = check_fields_set (required_fields, build_state);
458  	}
459  }
460  nano::send_block_builder & nano::send_block_builder::zero ()
461  {
462  	block->work = uint64_t (0);
463  	block->signature.clear ();
464  	block->hashables.previous.clear ();
465  	block->hashables.destination.clear ();
466  	block->hashables.balance.clear ();
<span onclick='openModal()' class='match'>467  	build_state = required_fields;
468  	return *this;
469  }
470  nano::send_block_builder & nano::send_block_builder::destination (nano::account account)
471  {
472  	block->hashables.destination = account;
</span>473  	build_state |= build_flags::link_present;
474  	return *this;
475  }
476  nano::send_block_builder & nano::send_block_builder::destination_hex (std::string account_hex)
477  {
478  	destination_hex_impl (account_hex, ec, block);
479  	build_state |= build_flags::link_present;
480  	return *this;
481  }
482  nano::send_block_builder & nano::send_block_builder::destination_address (std::string address)
483  {
484  	destination_address_impl (address, ec, block);
485  	build_state |= build_flags::link_present;
486  	return *this;
487  }
488  nano::send_block_builder & nano::send_block_builder::previous (nano::block_hash previous)
489  {
490  	block->hashables.previous = previous;
491  	build_state |= build_flags::previous_present;
492  	return *this;
493  }
494  nano::send_block_builder & nano::send_block_builder::previous_hex (std::string previous_hex)
495  {
496  	previous_hex_impl (previous_hex, ec, block);
497  	build_state |= build_flags::previous_present;
498  	return *this;
499  }
500  nano::send_block_builder & nano::send_block_builder::balance (nano::amount balance)
501  {
502  	block->hashables.balance = balance;
503  	build_state |= build_flags::balance_present;
504  	return *this;
505  }
506  nano::send_block_builder & nano::send_block_builder::balance_dec (std::string balance_decimal)
507  {
508  	balance_dec_impl (balance_decimal, ec, block);
509  	build_state |= build_flags::balance_present;
510  	return *this;
511  }
512  nano::send_block_builder & nano::send_block_builder::balance_hex (std::string balance_hex)
513  {
514  	balance_hex_impl (balance_hex, ec, block);
515  	build_state |= build_flags::balance_present;
516  	return *this;
517  }
518  nano::receive_block_builder::receive_block_builder ()
519  {
520  	make_block ();
521  }
522  nano::receive_block_builder & nano::receive_block_builder::make_block ()
523  {
524  	construct_block ();
525  	return *this;
526  }
527  void nano::receive_block_builder::validate ()
528  {
529  	if (!ec)
530  	{
531  		ec = check_fields_set (required_fields, build_state);
532  	}
533  }
534  nano::receive_block_builder & nano::receive_block_builder::zero ()
535  {
536  	block->work = uint64_t (0);
537  	block->signature.clear ();
538  	block->hashables.previous.clear ();
539  	block->hashables.source.clear ();
540  	build_state = required_fields;
541  	return *this;
542  }
543  nano::receive_block_builder & nano::receive_block_builder::previous (nano::block_hash previous)
544  {
545  	block->hashables.previous = previous;
546  	build_state |= build_flags::previous_present;
547  	return *this;
548  }
549  nano::receive_block_builder & nano::receive_block_builder::previous_hex (std::string previous_hex)
550  {
551  	previous_hex_impl (previous_hex, ec, block);
552  	build_state |= build_flags::previous_present;
553  	return *this;
554  }
555  nano::receive_block_builder & nano::receive_block_builder::source (nano::block_hash source)
556  {
557  	block->hashables.source = source;
558  	build_state |= build_flags::link_present;
559  	return *this;
560  }
561  nano::receive_block_builder & nano::receive_block_builder::source_hex (std::string source_hex)
562  {
563  	source_hex_impl (source_hex, ec, block);
564  	build_state |= build_flags::link_present;
565  	return *this;
566  }
567  template <typename BLOCKTYPE, typename BUILDER>
568  std::unique_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build ()
569  {
570  	if (!ec)
571  	{
572  		static_cast<BUILDER *> (this)->validate ();
573  	}
574  	debug_assert (!ec);
575  	return std::move (block);
576  }
577  template <typename BLOCKTYPE, typename BUILDER>
578  std::unique_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build (std::error_code & ec)
579  {
580  	if (!this->ec)
581  	{
582  		static_cast<BUILDER *> (this)->validate ();
583  	}
584  	ec = this->ec;
585  	return std::move (block);
586  }
587  template <typename BLOCKTYPE, typename BUILDER>
588  std::shared_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build_shared ()
589  {
590  	return std::move (build ());
591  }
592  template <typename BLOCKTYPE, typename BUILDER>
593  std::shared_ptr<BLOCKTYPE> nano::abstract_builder<BLOCKTYPE, BUILDER>::build_shared (std::error_code & ec)
594  {
595  	return std::move (build (ec));
596  }
597  template <typename BLOCKTYPE, typename BUILDER>
598  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::work (uint64_t work)
599  {
600  	block->work = work;
601  	build_state |= build_flags::work_present;
602  	return *this;
603  }
604  template <typename BLOCKTYPE, typename BUILDER>
605  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::sign (nano::raw_key const & private_key, nano::public_key const & public_key)
606  {
607  	block->signature = nano::sign_message (private_key, public_key, block->hash ());
608  	build_state |= build_flags::signature_present;
609  	return *this;
610  }
611  template <typename BLOCKTYPE, typename BUILDER>
612  nano::abstract_builder<BLOCKTYPE, BUILDER> & nano::abstract_builder<BLOCKTYPE, BUILDER>::sign_zero ()
613  {
614  	block->signature.clear ();
615  	build_state |= build_flags::signature_present;
616  	return *this;
617  }
618  template <typename BLOCKTYPE, typename BUILDER>
619  void nano::abstract_builder<BLOCKTYPE, BUILDER>::construct_block ()
620  {
621  	block = std::make_unique<BLOCKTYPE> ();
622  	ec.clear ();
623  	build_state = 0;
624  }
625  template class nano::abstract_builder<nano::open_block, nano::open_block_builder>;
626  template class nano::abstract_builder<nano::send_block, nano::send_block_builder>;
627  template class nano::abstract_builder<nano::receive_block, nano::receive_block_builder>;
628  template class nano::abstract_builder<nano::change_block, nano::change_block_builder>;
629  template class nano::abstract_builder<nano::state_block, nano::state_block_builder>;
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockbuilders.cpp</div>
                </div>
                <div class="column column_space"><pre><code>411  	build_state = required_fields;
412  	return *this;
413  }
414  nano::change_block_builder & nano::change_block_builder::representative (nano::account account)
415  {
416  	block->hashables.representative = account;
</pre></code></div>
                <div class="column column_space"><pre><code>467  	build_state = required_fields;
468  	return *this;
469  }
470  nano::send_block_builder & nano::send_block_builder::destination (nano::account account)
471  {
472  	block->hashables.destination = account;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    