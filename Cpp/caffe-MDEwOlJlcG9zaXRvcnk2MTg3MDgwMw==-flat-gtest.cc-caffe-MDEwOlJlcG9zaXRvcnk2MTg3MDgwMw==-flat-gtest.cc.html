
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest.cc</h3>
            <pre><code>1  #include "gtest/gtest.h"
2  #include "gtest/gtest-spi.h"
3  #include <ctype.h>
4  #include <math.h>
5  #include <stdarg.h>
6  #include <stdio.h>
7  #include <stdlib.h>
8  #include <time.h>
9  #include <wchar.h>
10  #include <wctype.h>
11  #include <algorithm>
12  #include <iomanip>
13  #include <limits>
14  #include <ostream>  
15  #include <sstream>
16  #include <vector>
17  #if GTEST_OS_LINUX
18  # define GTEST_HAS_GETTIMEOFDAY_ 1
19  # include <fcntl.h>  
20  # include <limits.h>  
21  # include <sched.h>  
22  # include <strings.h>  
23  # include <sys/mman.h>  
24  # include <sys/time.h>  
25  # include <unistd.h>  
26  # include <string>
27  #elif GTEST_OS_SYMBIAN
28  # define GTEST_HAS_GETTIMEOFDAY_ 1
29  # include <sys/time.h>  
30  #elif GTEST_OS_ZOS
31  # define GTEST_HAS_GETTIMEOFDAY_ 1
32  # include <sys/time.h>  
33  # include <strings.h>  
34  #elif GTEST_OS_WINDOWS_MOBILE  
35  # include <windows.h>  
36  #elif GTEST_OS_WINDOWS  
37  # include <io.h>  
38  # include <sys/timeb.h>  
39  # include <sys/types.h>  
40  # include <sys/stat.h>  
41  # if GTEST_OS_WINDOWS_MINGW
42  #  define GTEST_HAS_GETTIMEOFDAY_ 1
43  #  include <sys/time.h>  
44  # endif  
45  # include <windows.h>  
46  #else
47  # define GTEST_HAS_GETTIMEOFDAY_ 1
48  # include <sys/time.h>  
49  # include <unistd.h>  
50  #endif  
51  #if GTEST_HAS_EXCEPTIONS
52  # include <stdexcept>
53  #endif
54  #if GTEST_CAN_STREAM_RESULTS_
55  # include <arpa/inet.h>  
56  # include <netdb.h>  
57  #endif
58  #define GTEST_IMPLEMENTATION_ 1
59  #include "src/gtest-internal-inl.h"
60  #undef GTEST_IMPLEMENTATION_
61  #if GTEST_OS_WINDOWS
62  # define vsnprintf _vsnprintf
63  #endif  
64  namespace testing {
65  using internal::CountIf;
66  using internal::ForEach;
67  using internal::GetElementOr;
68  using internal::Shuffle;
69  static const char kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*";
70  static const char kDeathTestCaseFilter[] = "*DeathTest:*DeathTest&bsol;*";
71  static const char kUniversalFilter[] = "*";
72  static const char kDefaultOutputFile[] = "test_detail.xml";
73  static const char kTestShardIndex[] = "GTEST_SHARD_INDEX";
74  static const char kTestTotalShards[] = "GTEST_TOTAL_SHARDS";
75  static const char kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE";
76  namespace internal {
77  const char kStackTraceMarker[] = "\nStack trace:\n";
78  bool g_help_flag = false;
79  }  
80  static const char* GetDefaultFilter() {
81    return kUniversalFilter;
82  }
83  GTEST_DEFINE_bool_(
84      also_run_disabled_tests,
85      internal::BoolFromGTestEnv("also_run_disabled_tests", false),
86      "Run disabled tests too, in addition to the tests normally being run.");
87  GTEST_DEFINE_bool_(
88      break_on_failure,
89      internal::BoolFromGTestEnv("break_on_failure", false),
90      "True iff a failed assertion should be a debugger break-point.");
91  GTEST_DEFINE_bool_(
92      catch_exceptions,
93      internal::BoolFromGTestEnv("catch_exceptions", true),
94      "True iff " GTEST_NAME_
95      " should catch exceptions and treat them as test failures.");
96  GTEST_DEFINE_string_(
97      color,
98      internal::StringFromGTestEnv("color", "auto"),
99      "Whether to use colors in the output.  Valid values: yes, no, "
100      "and auto.  'auto' means to use colors if the output is "
101      "being sent to a terminal and the TERM environment variable "
102      "is set to a terminal type that supports colors.");
103  GTEST_DEFINE_string_(
104      filter,
105      internal::StringFromGTestEnv("filter", GetDefaultFilter()),
106      "A colon-separated list of glob (not regex) patterns "
107      "for filtering the tests to run, optionally followed by a "
108      "'-' and a : separated list of negative patterns (tests to "
109      "exclude).  A test is run if it matches one of the positive "
110      "patterns and does not match any of the negative patterns.");
111  GTEST_DEFINE_bool_(list_tests, false,
112                     "List all tests without running them.");
113  GTEST_DEFINE_string_(
114      output,
115      internal::StringFromGTestEnv("output", ""),
116      "A format (currently must be \"xml\"), optionally followed "
117      "by a colon and an output file name or directory. A directory "
118      "is indicated by a trailing pathname separator. "
119      "Examples: \"xml:filename.xml\", \"xml::directoryname/\". "
120      "If a directory is specified, output files will be created "
121      "within that directory, with file-names based on the test "
122      "executable's name and, if necessary, made unique by adding "
123      "digits.");
124  GTEST_DEFINE_bool_(
125      print_time,
126      internal::BoolFromGTestEnv("print_time", true),
127      "True iff " GTEST_NAME_
128      " should display elapsed time in text output.");
129  GTEST_DEFINE_int32_(
130      random_seed,
131      internal::Int32FromGTestEnv("random_seed", 0),
132      "Random number seed to use when shuffling test orders.  Must be in range "
133      "[1, 99999], or 0 to use a seed based on the current time.");
134  GTEST_DEFINE_int32_(
135      repeat,
136      internal::Int32FromGTestEnv("repeat", 1),
137      "How many times to repeat each test.  Specify a negative number "
138      "for repeating forever.  Useful for shaking out flaky tests.");
139  GTEST_DEFINE_bool_(
140      show_internal_stack_frames, false,
141      "True iff " GTEST_NAME_ " should include internal stack frames when "
142      "printing test failure stack traces.");
143  GTEST_DEFINE_bool_(
144      shuffle,
145      internal::BoolFromGTestEnv("shuffle", false),
146      "True iff " GTEST_NAME_
147      " should randomize tests' order on every run.");
148  GTEST_DEFINE_int32_(
149      stack_trace_depth,
150      internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth),
151      "The maximum number of stack frames to print when an "
152      "assertion fails.  The valid range is 0 through 100, inclusive.");
153  GTEST_DEFINE_string_(
154      stream_result_to,
155      internal::StringFromGTestEnv("stream_result_to", ""),
156      "This flag specifies the host name and the port number on which to stream "
157      "test results. Example: \"localhost:555\". The flag is effective only on "
158      "Linux.");
159  GTEST_DEFINE_bool_(
160      throw_on_failure,
161      internal::BoolFromGTestEnv("throw_on_failure", false),
162      "When this flag is specified, a failed assertion will throw an exception "
163      "if exceptions are enabled or exit the program with a non-zero code "
164      "otherwise.");
165  namespace internal {
166  UInt32 Random::Generate(UInt32 range) {
167    state_ = (1103515245U*state_ + 12345U) % kMaxRange;
168    GTEST_CHECK_(range > 0)
169        << "Cannot generate a number in the range [0, 0).";
170    GTEST_CHECK_(range <= kMaxRange)
171        << "Generation of a number in [0, " << range << ") was requested, "
172        << "but this can only generate numbers in [0, " << kMaxRange << ").";
173    return state_ % range;
174  }
175  GTEST_API_ int g_init_gtest_count = 0;
176  static bool GTestIsInitialized() { return g_init_gtest_count != 0; }
177  static int SumOverTestCaseList(const std::vector<TestCase*>& case_list,
178                                 int (TestCase::*method)() const) {
179    int sum = 0;
180    for (size_t i = 0; i < case_list.size(); i++) {
181      sum += (case_list[i]->*method)();
182    }
183    return sum;
184  }
185  static bool TestCasePassed(const TestCase* test_case) {
186    return test_case->should_run() && test_case->Passed();
187  }
188  static bool TestCaseFailed(const TestCase* test_case) {
189    return test_case->should_run() && test_case->Failed();
190  }
191  static bool ShouldRunTestCase(const TestCase* test_case) {
192    return test_case->should_run();
193  }
194  AssertHelper::AssertHelper(TestPartResult::Type type,
195                             const char* file,
196                             int line,
197                             const char* message)
198      : data_(new AssertHelperData(type, file, line, message)) {
199  }
200  AssertHelper::~AssertHelper() {
201    delete data_;
202  }
203  void AssertHelper::operator=(const Message& message) const {
204    UnitTest::GetInstance()->
205      AddTestPartResult(data_->type, data_->file, data_->line,
206                        AppendUserMessage(data_->message, message),
207                        UnitTest::GetInstance()->impl()
208                        ->CurrentOsStackTraceExceptTop(1)
209                        );  
210  }
211  GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_linked_ptr_mutex);
212  std::string g_executable_path;
213  FilePath GetCurrentExecutableName() {
214    FilePath result;
215  #if GTEST_OS_WINDOWS
216    result.Set(FilePath(g_executable_path).RemoveExtension("exe"));
217  #else
218    result.Set(FilePath(g_executable_path));
219  #endif  
220    return result.RemoveDirectoryName();
221  }
222  std::string UnitTestOptions::GetOutputFormat() {
223    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
224    if (gtest_output_flag == NULL) return std::string("");
225    const char* const colon = strchr(gtest_output_flag, ':');
226    return (colon == NULL) ?
227        std::string(gtest_output_flag) :
228        std::string(gtest_output_flag, colon - gtest_output_flag);
229  }
230  std::string UnitTestOptions::GetAbsolutePathToOutputFile() {
231    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
232    if (gtest_output_flag == NULL)
233      return "";
234    const char* const colon = strchr(gtest_output_flag, ':');
235    if (colon == NULL)
236      return internal::FilePath::ConcatPaths(
237          internal::FilePath(
238              UnitTest::GetInstance()->original_working_dir()),
239          internal::FilePath(kDefaultOutputFile)).string();
240    internal::FilePath output_name(colon + 1);
241    if (!output_name.IsAbsolutePath())
242      output_name = internal::FilePath::ConcatPaths(
243          internal::FilePath(UnitTest::GetInstance()->original_working_dir()),
244          internal::FilePath(colon + 1));
245    if (!output_name.IsDirectory())
246      return output_name.string();
247    internal::FilePath result(internal::FilePath::GenerateUniqueFileName(
248        output_name, internal::GetCurrentExecutableName(),
249        GetOutputFormat().c_str()));
250    return result.string();
251  }
252  bool UnitTestOptions::PatternMatchesString(const char *pattern,
253                                             const char *str) {
254    switch (*pattern) {
255      case '\0':
256      case ':':  
257        return *str == '\0';
258      case '?':  
259        return *str != '\0' && PatternMatchesString(pattern + 1, str + 1);
260      case '*':  
261        return (*str != '\0' && PatternMatchesString(pattern, str + 1)) ||
262            PatternMatchesString(pattern + 1, str);
263      default:  
264        return *pattern == *str &&
265            PatternMatchesString(pattern + 1, str + 1);
266    }
267  }
268  bool UnitTestOptions::MatchesFilter(
269      const std::string& name, const char* filter) {
270    const char *cur_pattern = filter;
271    for (;;) {
272      if (PatternMatchesString(cur_pattern, name.c_str())) {
273        return true;
274      }
275      cur_pattern = strchr(cur_pattern, ':');
276      if (cur_pattern == NULL) {
277        return false;
278      }
279      cur_pattern++;
280    }
281  }
282  bool UnitTestOptions::FilterMatchesTest(const std::string &test_case_name,
283                                          const std::string &test_name) {
284    const std::string& full_name = test_case_name + "." + test_name.c_str();
285    const char* const p = GTEST_FLAG(filter).c_str();
286    const char* const dash = strchr(p, '-');
287    std::string positive;
288    std::string negative;
289    if (dash == NULL) {
290      positive = GTEST_FLAG(filter).c_str();  
291      negative = "";
292    } else {
293      positive = std::string(p, dash);   
294      negative = std::string(dash + 1);  
295      if (positive.empty()) {
296        positive = kUniversalFilter;
297      }
298    }
299    return (MatchesFilter(full_name, positive.c_str()) &&
300            !MatchesFilter(full_name, negative.c_str()));
301  }
302  #if GTEST_HAS_SEH
303  int UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {
304    const DWORD kCxxExceptionCode = 0xe06d7363;
305    bool should_handle = true;
306    if (!GTEST_FLAG(catch_exceptions))
307      should_handle = false;
308    else if (exception_code == EXCEPTION_BREAKPOINT)
309      should_handle = false;
310    else if (exception_code == kCxxExceptionCode)
311      should_handle = false;
312    return should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
313  }
314  #endif  
315  }  
316  ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
317      TestPartResultArray* result)
318      : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),
319        result_(result) {
320    Init();
321  }
322  ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
323      InterceptMode intercept_mode, TestPartResultArray* result)
324      : intercept_mode_(intercept_mode),
325        result_(result) {
326    Init();
327  }
328  void ScopedFakeTestPartResultReporter::Init() {
329    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
330    if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
331      old_reporter_ = impl->GetGlobalTestPartResultReporter();
332      impl->SetGlobalTestPartResultReporter(this);
333    } else {
334      old_reporter_ = impl->GetTestPartResultReporterForCurrentThread();
335      impl->SetTestPartResultReporterForCurrentThread(this);
336    }
337  }
338  ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
339    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
340    if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
341      impl->SetGlobalTestPartResultReporter(old_reporter_);
342    } else {
343      impl->SetTestPartResultReporterForCurrentThread(old_reporter_);
344    }
345  }
346  void ScopedFakeTestPartResultReporter::ReportTestPartResult(
347      const TestPartResult& result) {
348    result_->Append(result);
349  }
350  namespace internal {
351  TypeId GetTestTypeId() {
352    return GetTypeId<Test>();
353  }
354  extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();
355  AssertionResult HasOneFailure(const char* &bsol;* results_expr */,
356                                const char* &bsol;* type_expr */,
357                                const char* &bsol;* substr_expr */,
358                                const TestPartResultArray& results,
359                                TestPartResult::Type type,
360                                const string& substr) {
361    const std::string expected(type == TestPartResult::kFatalFailure ?
362                          "1 fatal failure" :
363                          "1 non-fatal failure");
364    Message msg;
365    if (results.size() != 1) {
366      msg << "Expected: " << expected << "\n"
367          << "  Actual: " << results.size() << " failures";
368      for (int i = 0; i < results.size(); i++) {
369        msg << "\n" << results.GetTestPartResult(i);
370      }
371      return AssertionFailure() << msg;
372    }
373    const TestPartResult& r = results.GetTestPartResult(0);
374    if (r.type() != type) {
375      return AssertionFailure() << "Expected: " << expected << "\n"
376                                << "  Actual:\n"
377                                << r;
378    }
379    if (strstr(r.message(), substr.c_str()) == NULL) {
380      return AssertionFailure() << "Expected: " << expected << " containing \""
381                                << substr << "\"\n"
382                                << "  Actual:\n"
383                                << r;
384    }
385    return AssertionSuccess();
386  }
387  SingleFailureChecker:: SingleFailureChecker(
388      const TestPartResultArray* results,
389      TestPartResult::Type type,
390      const string& substr)
391      : results_(results),
392        type_(type),
393        substr_(substr) {}
394  SingleFailureChecker::~SingleFailureChecker() {
395    EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);
396  }
397  DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(
398      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
399  void DefaultGlobalTestPartResultReporter::ReportTestPartResult(
400      const TestPartResult& result) {
401    unit_test_->current_test_result()->AddTestPartResult(result);
402    unit_test_->listeners()->repeater()->OnTestPartResult(result);
403  }
404  DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(
405      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
406  void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(
407      const TestPartResult& result) {
408    unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);
409  }
410  TestPartResultReporterInterface*
411  UnitTestImpl::GetGlobalTestPartResultReporter() {
412    internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
413    return global_test_part_result_repoter_;
414  }
415  void UnitTestImpl::SetGlobalTestPartResultReporter(
416      TestPartResultReporterInterface* reporter) {
417    internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
418    global_test_part_result_repoter_ = reporter;
419  }
420  TestPartResultReporterInterface*
421  UnitTestImpl::GetTestPartResultReporterForCurrentThread() {
422    return per_thread_test_part_result_reporter_.get();
423  }
424  void UnitTestImpl::SetTestPartResultReporterForCurrentThread(
425      TestPartResultReporterInterface* reporter) {
426    per_thread_test_part_result_reporter_.set(reporter);
427  }
428  int UnitTestImpl::successful_test_case_count() const {
429    return CountIf(test_cases_, TestCasePassed);
430  }
431  int UnitTestImpl::failed_test_case_count() const {
432    return CountIf(test_cases_, TestCaseFailed);
433  }
434  int UnitTestImpl::total_test_case_count() const {
435    return static_cast<int>(test_cases_.size());
436  }
437  int UnitTestImpl::test_case_to_run_count() const {
438    return CountIf(test_cases_, ShouldRunTestCase);
439  }
440  int UnitTestImpl::successful_test_count() const {
441    return SumOverTestCaseList(test_cases_, &TestCase::successful_test_count);
442  }
443  int UnitTestImpl::failed_test_count() const {
444    return SumOverTestCaseList(test_cases_, &TestCase::failed_test_count);
445  }
446  int UnitTestImpl::reportable_disabled_test_count() const {
447    return SumOverTestCaseList(test_cases_,
448                               &TestCase::reportable_disabled_test_count);
449  }
450  int UnitTestImpl::disabled_test_count() const {
451    return SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count);
452  }
453  int UnitTestImpl::reportable_test_count() const {
454    return SumOverTestCaseList(test_cases_, &TestCase::reportable_test_count);
455  }
456  int UnitTestImpl::total_test_count() const {
457    return SumOverTestCaseList(test_cases_, &TestCase::total_test_count);
458  }
459  int UnitTestImpl::test_to_run_count() const {
460    return SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count);
461  }
462  std::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {
463    (void)skip_count;
464    return "";
465  }
466  TimeInMillis GetTimeInMillis() {
467  #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)
468    const TimeInMillis kJavaEpochToWinFileTimeDelta =
469      static_cast<TimeInMillis>(116444736UL) * 100000UL;
470    const DWORD kTenthMicrosInMilliSecond = 10000;
471    SYSTEMTIME now_systime;
472    FILETIME now_filetime;
473    ULARGE_INTEGER now_int64;
474    GetSystemTime(&now_systime);
475    if (SystemTimeToFileTime(&now_systime, &now_filetime)) {
476      now_int64.LowPart = now_filetime.dwLowDateTime;
477      now_int64.HighPart = now_filetime.dwHighDateTime;
478      now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -
479        kJavaEpochToWinFileTimeDelta;
480      return now_int64.QuadPart;
481    }
482    return 0;
483  #elif GTEST_OS_WINDOWS && !GTEST_HAS_GETTIMEOFDAY_
484    __timeb64 now;
485  # ifdef _MSC_VER
486  #  pragma warning(push)          
487  #  pragma warning(disable:4996)  
488    _ftime64(&now);
489  #  pragma warning(pop)           
490  # else
491    _ftime64(&now);
492  # endif  
493    return static_cast<TimeInMillis>(now.time) * 1000 + now.millitm;
494  #elif GTEST_HAS_GETTIMEOFDAY_
495    struct timeval now;
496    gettimeofday(&now, NULL);
497    return static_cast<TimeInMillis>(now.tv_sec) * 1000 + now.tv_usec / 1000;
498  #else
499  # error "Don't know how to get the current time on your system."
500  #endif
501  }
502  #if GTEST_OS_WINDOWS_MOBILE
503  LPCWSTR String::AnsiToUtf16(const char* ansi) {
504    if (!ansi) return NULL;
505    const int length = strlen(ansi);
506    const int unicode_length =
507        MultiByteToWideChar(CP_ACP, 0, ansi, length,
508                            NULL, 0);
509    WCHAR* unicode = new WCHAR[unicode_length + 1];
510    MultiByteToWideChar(CP_ACP, 0, ansi, length,
511                        unicode, unicode_length);
512    unicode[unicode_length] = 0;
513    return unicode;
514  }
515  const char* String::Utf16ToAnsi(LPCWSTR utf16_str)  {
516    if (!utf16_str) return NULL;
517    const int ansi_length =
518        WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
519                            NULL, 0, NULL, NULL);
520    char* ansi = new char[ansi_length + 1];
521    WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
522                        ansi, ansi_length, NULL, NULL);
523    ansi[ansi_length] = 0;
524    return ansi;
525  }
526  #endif  
527  bool String::CStringEquals(const char * lhs, const char * rhs) {
528    if ( lhs == NULL ) return rhs == NULL;
529    if ( rhs == NULL ) return false;
530    return strcmp(lhs, rhs) == 0;
531  }
532  #if GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING
533  static void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,
534                                       Message* msg) {
535    for (size_t i = 0; i != length; ) {  
536      if (wstr[i] != L'\0') {
537        *msg << WideStringToUtf8(wstr + i, static_cast<int>(length - i));
538        while (i != length && wstr[i] != L'\0')
539          i++;
540      } else {
541        *msg << '\0';
542        i++;
543      }
544    }
545  }
546  #endif  
547  }  
548  Message::Message() : ss_(new ::std::stringstream) {
549    *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
550  }
551  Message& Message::operator <<(const wchar_t* wide_c_str) {
552    return *this << internal::String::ShowWideCString(wide_c_str);
553  }
554  Message& Message::operator <<(wchar_t* wide_c_str) {
555    return *this << internal::String::ShowWideCString(wide_c_str);
556  }
557  #if GTEST_HAS_STD_WSTRING
558  Message& Message::operator <<(const ::std::wstring& wstr) {
559    internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
560    return *this;
561  }
562  #endif  
563  #if GTEST_HAS_GLOBAL_WSTRING
564  Message& Message::operator <<(const ::wstring& wstr) {
565    internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
566    return *this;
567  }
568  #endif  
569  std::string Message::GetString() const {
570    return internal::StringStreamToString(ss_.get());
571  }
572  AssertionResult::AssertionResult(const AssertionResult& other)
573      : success_(other.success_),
574        message_(other.message_.get() != NULL ?
575                 new ::std::string(*other.message_) :
576                 static_cast< ::std::string*>(NULL)) {
577  }
578  AssertionResult AssertionResult::operator!() const {
579    AssertionResult negation(!success_);
580    if (message_.get() != NULL)
581      negation << *message_;
582    return negation;
583  }
584  AssertionResult AssertionSuccess() {
585    return AssertionResult(true);
586  }
587  AssertionResult AssertionFailure() {
588    return AssertionResult(false);
589  }
590  AssertionResult AssertionFailure(const Message& message) {
591    return AssertionFailure() << message;
592  }
593  namespace internal {
594  AssertionResult EqFailure(const char* expected_expression,
595                            const char* actual_expression,
596                            const std::string& expected_value,
597                            const std::string& actual_value,
598                            bool ignoring_case) {
599    Message msg;
600    msg << "Value of: " << actual_expression;
601    if (actual_value != actual_expression) {
602      msg << "\n  Actual: " << actual_value;
603    }
604    msg << "\nExpected: " << expected_expression;
605    if (ignoring_case) {
606      msg << " (ignoring case)";
607    }
608    if (expected_value != expected_expression) {
609      msg << "\nWhich is: " << expected_value;
610    }
611    return AssertionFailure() << msg;
612  }
613  std::string GetBoolAssertionFailureMessage(
614      const AssertionResult& assertion_result,
615      const char* expression_text,
616      const char* actual_predicate_value,
617      const char* expected_predicate_value) {
618    const char* actual_message = assertion_result.message();
619    Message msg;
620    msg << "Value of: " << expression_text
621        << "\n  Actual: " << actual_predicate_value;
622    if (actual_message[0] != '\0')
623      msg << " (" << actual_message << ")";
624    msg << "\nExpected: " << expected_predicate_value;
625    return msg.GetString();
626  }
627  AssertionResult DoubleNearPredFormat(const char* expr1,
628                                       const char* expr2,
629                                       const char* abs_error_expr,
630                                       double val1,
631                                       double val2,
632                                       double abs_error) {
633    const double diff = fabs(val1 - val2);
634    if (diff <= abs_error) return AssertionSuccess();
635    return AssertionFailure()
636        << "The difference between " << expr1 << " and " << expr2
637        << " is " << diff << ", which exceeds " << abs_error_expr << ", where\n"
638        << expr1 << " evaluates to " << val1 << ",\n"
639        << expr2 << " evaluates to " << val2 << ", and\n"
640        << abs_error_expr << " evaluates to " << abs_error << ".";
641  }
642  template <typename RawType>
643  AssertionResult FloatingPointLE(const char* expr1,
644                                  const char* expr2,
645                                  RawType val1,
646                                  RawType val2) {
647    if (val1 < val2) {
648      return AssertionSuccess();
649    }
650    const FloatingPoint<RawType> lhs(val1), rhs(val2);
651    if (lhs.AlmostEquals(rhs)) {
652      return AssertionSuccess();
653    }
654    ::std::stringstream val1_ss;
655    val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
656            << val1;
657    ::std::stringstream val2_ss;
658    val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
659            << val2;
660    return AssertionFailure()
661        << "Expected: (" << expr1 << ") <= (" << expr2 << ")\n"
662        << "  Actual: " << StringStreamToString(&val1_ss) << " vs "
663        << StringStreamToString(&val2_ss);
664  }
665  }  
666  AssertionResult FloatLE(const char* expr1, const char* expr2,
667                          float val1, float val2) {
668    return internal::FloatingPointLE<float>(expr1, expr2, val1, val2);
669  }
670  AssertionResult DoubleLE(const char* expr1, const char* expr2,
671                           double val1, double val2) {
672    return internal::FloatingPointLE<double>(expr1, expr2, val1, val2);
673  }
674  namespace internal {
675  AssertionResult CmpHelperEQ(const char* expected_expression,
676                              const char* actual_expression,
677                              BiggestInt expected,
678                              BiggestInt actual) {
679    if (expected == actual) {
680      return AssertionSuccess();
681    }
682    return EqFailure(expected_expression,
683                     actual_expression,
684                     FormatForComparisonFailureMessage(expected, actual),
685                     FormatForComparisonFailureMessage(actual, expected),
686                     false);
687  }
688  #define GTEST_IMPL_CMP_HELPER_(op_name, op)\
689  AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \
690                                     BiggestInt val1, BiggestInt val2) {\
691    if (val1 op val2) {\
692      return AssertionSuccess();\
693    } else {\
694      return AssertionFailure() \
695          << "Expected: (" << expr1 << ") " #op " (" << expr2\
696          << "), actual: " << FormatForComparisonFailureMessage(val1, val2)\
697          << " vs " << FormatForComparisonFailureMessage(val2, val1);\
698    }\
699  }
700  GTEST_IMPL_CMP_HELPER_(NE, !=)
701  GTEST_IMPL_CMP_HELPER_(LE, <=)
702  GTEST_IMPL_CMP_HELPER_(LT, < )
703  GTEST_IMPL_CMP_HELPER_(GE, >=)
704  GTEST_IMPL_CMP_HELPER_(GT, > )
705  #undef GTEST_IMPL_CMP_HELPER_
706  AssertionResult CmpHelperSTREQ(const char* expected_expression,
707                                 const char* actual_expression,
708                                 const char* expected,
709                                 const char* actual) {
710    if (String::CStringEquals(expected, actual)) {
711      return AssertionSuccess();
712    }
713    return EqFailure(expected_expression,
714                     actual_expression,
715                     PrintToString(expected),
716                     PrintToString(actual),
717                     false);
718  }
719  AssertionResult CmpHelperSTRCASEEQ(const char* expected_expression,
720                                     const char* actual_expression,
721                                     const char* expected,
722                                     const char* actual) {
723    if (String::CaseInsensitiveCStringEquals(expected, actual)) {
724      return AssertionSuccess();
725    }
726    return EqFailure(expected_expression,
727                     actual_expression,
728                     PrintToString(expected),
729                     PrintToString(actual),
730                     true);
731  }
732  AssertionResult CmpHelperSTRNE(const char* s1_expression,
733                                 const char* s2_expression,
734                                 const char* s1,
735                                 const char* s2) {
736    if (!String::CStringEquals(s1, s2)) {
737      return AssertionSuccess();
738    } else {
739      return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
740                                << s2_expression << "), actual: \""
741                                << s1 << "\" vs \"" << s2 << "\"";
742    }
743  }
744  AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
745                                     const char* s2_expression,
746                                     const char* s1,
747                                     const char* s2) {
748    if (!String::CaseInsensitiveCStringEquals(s1, s2)) {
749      return AssertionSuccess();
750    } else {
751      return AssertionFailure()
752          << "Expected: (" << s1_expression << ") != ("
753          << s2_expression << ") (ignoring case), actual: \""
754          << s1 << "\" vs \"" << s2 << "\"";
755    }
756  }
757  }  
758  namespace {
759  bool IsSubstringPred(const char* needle, const char* haystack) {
760    if (needle == NULL || haystack == NULL)
761      return needle == haystack;
762    return strstr(haystack, needle) != NULL;
763  }
764  bool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {
765    if (needle == NULL || haystack == NULL)
766      return needle == haystack;
767    return wcsstr(haystack, needle) != NULL;
768  }
769  template <typename StringType>
770  bool IsSubstringPred(const StringType& needle,
771                       const StringType& haystack) {
772    return haystack.find(needle) != StringType::npos;
773  }
774  template <typename StringType>
775  AssertionResult IsSubstringImpl(
776      bool expected_to_be_substring,
777      const char* needle_expr, const char* haystack_expr,
778      const StringType& needle, const StringType& haystack) {
779    if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
780      return AssertionSuccess();
781    const bool is_wide_string = sizeof(needle[0]) > 1;
782    const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
783    return AssertionFailure()
784        << "Value of: " << needle_expr << "\n"
785        << "  Actual: " << begin_string_quote << needle << "\"\n"
786        << "Expected: " << (expected_to_be_substring ? "" : "not ")
787        << "a substring of " << haystack_expr << "\n"
788        << "Which is: " << begin_string_quote << haystack << "\"";
789  }
790  }  
791  AssertionResult IsSubstring(
792      const char* needle_expr, const char* haystack_expr,
793      const char* needle, const char* haystack) {
794    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
795  }
796  AssertionResult IsSubstring(
797      const char* needle_expr, const char* haystack_expr,
798      const wchar_t* needle, const wchar_t* haystack) {
799    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
800  }
801  AssertionResult IsNotSubstring(
802      const char* needle_expr, const char* haystack_expr,
803      const char* needle, const char* haystack) {
804    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
805  }
806  AssertionResult IsNotSubstring(
807      const char* needle_expr, const char* haystack_expr,
808      const wchar_t* needle, const wchar_t* haystack) {
809    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
810  }
811  AssertionResult IsSubstring(
812      const char* needle_expr, const char* haystack_expr,
813      const ::std::string& needle, const ::std::string& haystack) {
814    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
815  }
816  AssertionResult IsNotSubstring(
817      const char* needle_expr, const char* haystack_expr,
818      const ::std::string& needle, const ::std::string& haystack) {
819    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
820  }
821  #if GTEST_HAS_STD_WSTRING
822  AssertionResult IsSubstring(
823      const char* needle_expr, const char* haystack_expr,
824      const ::std::wstring& needle, const ::std::wstring& haystack) {
825    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
826  }
827  AssertionResult IsNotSubstring(
828      const char* needle_expr, const char* haystack_expr,
829      const ::std::wstring& needle, const ::std::wstring& haystack) {
830    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
831  }
832  #endif  
833  namespace internal {
834  #if GTEST_OS_WINDOWS
835  namespace {
836  AssertionResult HRESULTFailureHelper(const char* expr,
837                                       const char* expected,
838                                       long hr) {  
839  # if GTEST_OS_WINDOWS_MOBILE
840    const char error_text[] = "";
841  # else
842    const DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |
843                         FORMAT_MESSAGE_IGNORE_INSERTS;
844    const DWORD kBufSize = 4096;
845    char error_text[kBufSize] = { '\0' };
846    DWORD message_length = ::FormatMessageA(kFlags,
847                                            0,  
848                                            hr,  
849                                            0,  
850                                            error_text,  
851                                            kBufSize,  
852                                            NULL);  
853    for (; message_length && IsSpace(error_text[message_length - 1]);
854            --message_length) {
855      error_text[message_length - 1] = '\0';
856    }
857  # endif  
858    const std::string error_hex("0x" + String::FormatHexInt(hr));
859    return ::testing::AssertionFailure()
860        << "Expected: " << expr << " " << expected << ".\n"
861        << "  Actual: " << error_hex << " " << error_text << "\n";
862  }
863  }  
864  AssertionResult IsHRESULTSuccess(const char* expr, long hr) {  
865    if (SUCCEEDED(hr)) {
866      return AssertionSuccess();
867    }
868    return HRESULTFailureHelper(expr, "succeeds", hr);
869  }
870  AssertionResult IsHRESULTFailure(const char* expr, long hr) {  
871    if (FAILED(hr)) {
872      return AssertionSuccess();
873    }
874    return HRESULTFailureHelper(expr, "fails", hr);
875  }
876  #endif  
877  const UInt32 kMaxCodePoint1 = (static_cast<UInt32>(1) <<  7) - 1;
878  const UInt32 kMaxCodePoint2 = (static_cast<UInt32>(1) << (5 + 6)) - 1;
879  const UInt32 kMaxCodePoint3 = (static_cast<UInt32>(1) << (4 + 2*6)) - 1;
880  const UInt32 kMaxCodePoint4 = (static_cast<UInt32>(1) << (3 + 3*6)) - 1;
881  inline UInt32 ChopLowBits(UInt32* bits, int n) {
882    const UInt32 low_bits = *bits & ((static_cast<UInt32>(1) << n) - 1);
883    *bits >>= n;
884    return low_bits;
885  }
886  std::string CodePointToUtf8(UInt32 code_point) {
887    if (code_point > kMaxCodePoint4) {
888      return "(Invalid Unicode 0x" + String::FormatHexInt(code_point) + ")";
889    }
890    char str[5];  
891    if (code_point <= kMaxCodePoint1) {
892      str[1] = '\0';
893      str[0] = static_cast<char>(code_point);                          
894    } else if (code_point <= kMaxCodePoint2) {
895      str[2] = '\0';
896      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
897      str[0] = static_cast<char>(0xC0 | code_point);                   
898    } else if (code_point <= kMaxCodePoint3) {
899      str[3] = '\0';
900      str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
901      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
902      str[0] = static_cast<char>(0xE0 | code_point);                   
903    } else {  
904      str[4] = '\0';
905      str[3] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
906      str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
907      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
908      str[0] = static_cast<char>(0xF0 | code_point);                   
909    }
910    return str;
911  }
912  inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {
913    return sizeof(wchar_t) == 2 &&
914        (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;
915  }
916  inline UInt32 CreateCodePointFromUtf16SurrogatePair(wchar_t first,
917                                                      wchar_t second) {
918    const UInt32 mask = (1 << 10) - 1;
919    return (sizeof(wchar_t) == 2) ?
920        (((first & mask) << 10) | (second & mask)) + 0x10000 :
921        static_cast<UInt32>(first);
922  }
923  std::string WideStringToUtf8(const wchar_t* str, int num_chars) {
924    if (num_chars == -1)
925      num_chars = static_cast<int>(wcslen(str));
926    ::std::stringstream stream;
927    for (int i = 0; i < num_chars; ++i) {
928      UInt32 unicode_code_point;
929      if (str[i] == L'\0') {
930        break;
931      } else if (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) {
932        unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],
933                                                                   str[i + 1]);
934        i++;
935      } else {
936        unicode_code_point = static_cast<UInt32>(str[i]);
937      }
938      stream << CodePointToUtf8(unicode_code_point);
939    }
940    return StringStreamToString(&stream);
941  }
942  std::string String::ShowWideCString(const wchar_t * wide_c_str) {
943    if (wide_c_str == NULL)  return "(null)";
944    return internal::WideStringToUtf8(wide_c_str, -1);
945  }
946  bool String::WideCStringEquals(const wchar_t * lhs, const wchar_t * rhs) {
947    if (lhs == NULL) return rhs == NULL;
948    if (rhs == NULL) return false;
949    return wcscmp(lhs, rhs) == 0;
950  }
951  AssertionResult CmpHelperSTREQ(const char* expected_expression,
952                                 const char* actual_expression,
953                                 const wchar_t* expected,
954                                 const wchar_t* actual) {
955    if (String::WideCStringEquals(expected, actual)) {
956      return AssertionSuccess();
957    }
958    return EqFailure(expected_expression,
959                     actual_expression,
960                     PrintToString(expected),
961                     PrintToString(actual),
962                     false);
963  }
964  AssertionResult CmpHelperSTRNE(const char* s1_expression,
965                                 const char* s2_expression,
966                                 const wchar_t* s1,
967                                 const wchar_t* s2) {
968    if (!String::WideCStringEquals(s1, s2)) {
969      return AssertionSuccess();
970    }
971    return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
972                              << s2_expression << "), actual: "
973                              << PrintToString(s1)
974                              << " vs " << PrintToString(s2);
975  }
976  bool String::CaseInsensitiveCStringEquals(const char * lhs, const char * rhs) {
977    if (lhs == NULL)
978      return rhs == NULL;
979    if (rhs == NULL)
980      return false;
981    return posix::StrCaseCmp(lhs, rhs) == 0;
982  }
983  bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
984                                                const wchar_t* rhs) {
985    if (lhs == NULL) return rhs == NULL;
986    if (rhs == NULL) return false;
987  #if GTEST_OS_WINDOWS
988    return _wcsicmp(lhs, rhs) == 0;
989  #elif GTEST_OS_LINUX && !GTEST_OS_LINUX_ANDROID
990    return wcscasecmp(lhs, rhs) == 0;
991  #else
992    wint_t left, right;
993    do {
994      left = towlower(*lhs++);
995      right = towlower(*rhs++);
996    } while (left && left == right);
997    return left == right;
998  #endif  
999  }
1000  bool String::EndsWithCaseInsensitive(
1001      const std::string& str, const std::string& suffix) {
1002    const size_t str_len = str.length();
1003    const size_t suffix_len = suffix.length();
1004    return (str_len >= suffix_len) &&
1005           CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,
1006                                        suffix.c_str());
1007  }
1008  std::string String::FormatIntWidth2(int value) {
1009    std::stringstream ss;
1010    ss << std::setfill('0') << std::setw(2) << value;
1011    return ss.str();
1012  }
1013  std::string String::FormatHexInt(int value) {
1014    std::stringstream ss;
1015    ss << std::hex << std::uppercase << value;
1016    return ss.str();
1017  }
1018  std::string String::FormatByte(unsigned char value) {
1019    std::stringstream ss;
1020    ss << std::setfill('0') << std::setw(2) << std::hex << std::uppercase
1021       << static_cast<unsigned int>(value);
1022    return ss.str();
1023  }
1024  std::string StringStreamToString(::std::stringstream* ss) {
1025    const ::std::string& str = ss->str();
1026    const char* const start = str.c_str();
1027    const char* const end = start + str.length();
1028    std::string result;
1029    result.reserve(2 * (end - start));
1030    for (const char* ch = start; ch != end; ++ch) {
1031      if (*ch == '\0') {
1032        result += "\\0";  
1033      } else {
1034        result += *ch;
1035      }
1036    }
1037    return result;
1038  }
1039  std::string AppendUserMessage(const std::string& gtest_msg,
1040                                const Message& user_msg) {
1041    const std::string user_msg_string = user_msg.GetString();
1042    if (user_msg_string.empty()) {
1043      return gtest_msg;
1044    }
1045    return gtest_msg + "\n" + user_msg_string;
1046  }
1047  }  
1048  TestResult::TestResult()
1049      : death_test_count_(0),
1050        elapsed_time_(0) {
1051  }
1052  TestResult::~TestResult() {
1053  }
1054  const TestPartResult& TestResult::GetTestPartResult(int i) const {
1055    if (i < 0 || i >= total_part_count())
1056      internal::posix::Abort();
1057    return test_part_results_.at(i);
1058  }
1059  const TestProperty& TestResult::GetTestProperty(int i) const {
1060    if (i < 0 || i >= test_property_count())
1061      internal::posix::Abort();
1062    return test_properties_.at(i);
1063  }
1064  void TestResult::ClearTestPartResults() {
1065    test_part_results_.clear();
1066  }
1067  void TestResult::AddTestPartResult(const TestPartResult& test_part_result) {
1068    test_part_results_.push_back(test_part_result);
1069  }
1070  void TestResult::RecordProperty(const std::string& xml_element,
1071                                  const TestProperty& test_property) {
1072    if (!ValidateTestProperty(xml_element, test_property)) {
1073      return;
1074    }
1075    internal::MutexLock lock(&test_properites_mutex_);
1076    const std::vector<TestProperty>::iterator property_with_matching_key =
1077        std::find_if(test_properties_.begin(), test_properties_.end(),
1078                     internal::TestPropertyKeyIs(test_property.key()));
1079    if (property_with_matching_key == test_properties_.end()) {
1080      test_properties_.push_back(test_property);
1081      return;
1082    }
1083    property_with_matching_key->SetValue(test_property.value());
1084  }
1085  static const char* const kReservedTestSuitesAttributes[] = {
1086    "disabled",
1087    "errors",
1088    "failures",
1089    "name",
1090    "random_seed",
1091    "tests",
1092    "time",
1093    "timestamp"
1094  };
1095  static const char* const kReservedTestSuiteAttributes[] = {
1096    "disabled",
1097    "errors",
1098    "failures",
1099    "name",
1100    "tests",
1101    "time"
1102  };
1103  static const char* const kReservedTestCaseAttributes[] = {
1104    "classname",
1105    "name",
1106    "status",
1107    "time",
1108    "type_param",
1109    "value_param"
1110  };
1111  template <int kSize>
1112  std::vector<std::string> ArrayAsVector(const char* const (&array)[kSize]) {
1113    return std::vector<std::string>(array, array + kSize);
1114  }
1115  static std::vector<std::string> GetReservedAttributesForElement(
1116      const std::string& xml_element) {
1117    if (xml_element == "testsuites") {
1118      return ArrayAsVector(kReservedTestSuitesAttributes);
1119    } else if (xml_element == "testsuite") {
1120      return ArrayAsVector(kReservedTestSuiteAttributes);
1121    } else if (xml_element == "testcase") {
1122      return ArrayAsVector(kReservedTestCaseAttributes);
1123    } else {
1124      GTEST_CHECK_(false) << "Unrecognized xml_element provided: " << xml_element;
1125    }
1126    return std::vector<std::string>();
1127  }
1128  static std::string FormatWordList(const std::vector<std::string>& words) {
1129    Message word_list;
1130    for (size_t i = 0; i < words.size(); ++i) {
1131      if (i > 0 && words.size() > 2) {
1132        word_list << ", ";
1133      }
1134      if (i == words.size() - 1) {
1135        word_list << "and ";
1136      }
1137      word_list << "'" << words[i] << "'";
1138    }
1139    return word_list.GetString();
1140  }
1141  bool ValidateTestPropertyName(const std::string& property_name,
1142                                const std::vector<std::string>& reserved_names) {
1143    if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=
1144            reserved_names.end()) {
1145      ADD_FAILURE() << "Reserved key used in RecordProperty(): " << property_name
1146                    << " (" << FormatWordList(reserved_names)
1147                    << " are reserved by " << GTEST_NAME_ << ")";
1148      return false;
1149    }
1150    return true;
1151  }
1152  bool TestResult::ValidateTestProperty(const std::string& xml_element,
1153                                        const TestProperty& test_property) {
1154    return ValidateTestPropertyName(test_property.key(),
1155                                    GetReservedAttributesForElement(xml_element));
1156  }
1157  void TestResult::Clear() {
1158    test_part_results_.clear();
1159    test_properties_.clear();
1160    death_test_count_ = 0;
1161    elapsed_time_ = 0;
1162  }
1163  bool TestResult::Failed() const {
1164    for (int i = 0; i < total_part_count(); ++i) {
1165      if (GetTestPartResult(i).failed())
1166        return true;
1167    }
1168    return false;
1169  }
1170  static bool TestPartFatallyFailed(const TestPartResult& result) {
1171    return result.fatally_failed();
1172  }
1173  bool TestResult::HasFatalFailure() const {
1174    return CountIf(test_part_results_, TestPartFatallyFailed) > 0;
1175  }
1176  static bool TestPartNonfatallyFailed(const TestPartResult& result) {
1177    return result.nonfatally_failed();
1178  }
1179  bool TestResult::HasNonfatalFailure() const {
1180    return CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;
1181  }
1182  int TestResult::total_part_count() const {
1183    return static_cast<int>(test_part_results_.size());
1184  }
1185  int TestResult::test_property_count() const {
1186    return static_cast<int>(test_properties_.size());
1187  }
1188  Test::Test()
1189      : gtest_flag_saver_(new internal::GTestFlagSaver) {
1190  }
1191  Test::~Test() {
1192    delete gtest_flag_saver_;
1193  }
1194  void Test::SetUp() {
1195  }
1196  void Test::TearDown() {
1197  }
1198  void Test::RecordProperty(const std::string& key, const std::string& value) {
1199    UnitTest::GetInstance()->RecordProperty(key, value);
1200  }
1201  void Test::RecordProperty(const std::string& key, int value) {
1202    Message value_message;
1203    value_message << value;
1204    RecordProperty(key, value_message.GetString().c_str());
1205  }
1206  namespace internal {
1207  void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
1208                                      const std::string& message) {
1209    UnitTest::GetInstance()->AddTestPartResult(
1210        result_type,
1211        NULL,  
1212        -1,    
1213        message,
1214        "");   
1215  }
1216  }  
1217  bool Test::HasSameFixtureClass() {
1218    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1219    const TestCase* const test_case = impl->current_test_case();
1220    const TestInfo* const first_test_info = test_case->test_info_list()[0];
1221    const internal::TypeId first_fixture_id = first_test_info->fixture_class_id_;
1222    const char* const first_test_name = first_test_info->name();
1223    const TestInfo* const this_test_info = impl->current_test_info();
1224    const internal::TypeId this_fixture_id = this_test_info->fixture_class_id_;
1225    const char* const this_test_name = this_test_info->name();
1226    if (this_fixture_id != first_fixture_id) {
1227      const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();
1228      const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();
1229      if (first_is_TEST || this_is_TEST) {
1230        const char* const TEST_name =
1231            first_is_TEST ? first_test_name : this_test_name;
1232        const char* const TEST_F_name =
1233            first_is_TEST ? this_test_name : first_test_name;
1234        ADD_FAILURE()
1235            << "All tests in the same test case must use the same test fixture\n"
1236            << "class, so mixing TEST_F and TEST in the same test case is\n"
1237            << "illegal.  In test case " << this_test_info->test_case_name()
1238            << ",\n"
1239            << "test " << TEST_F_name << " is defined using TEST_F but\n"
1240            << "test " << TEST_name << " is defined using TEST.  You probably\n"
1241            << "want to change the TEST to TEST_F or move it to another test\n"
1242            << "case.";
1243      } else {
1244        ADD_FAILURE()
1245            << "All tests in the same test case must use the same test fixture\n"
1246            << "class.  However, in test case "
1247            << this_test_info->test_case_name() << ",\n"
1248            << "you defined test " << first_test_name
1249            << " and test " << this_test_name << "\n"
1250            << "using two different test fixture classes.  This can happen if\n"
1251            << "the two classes are from different namespaces or translation\n"
1252            << "units and have the same name.  You should probably rename one\n"
1253            << "of the classes to put the tests into different test cases.";
1254      }
1255      return false;
1256    }
1257    return true;
1258  }
1259  #if GTEST_HAS_SEH
1260  static std::string* FormatSehExceptionMessage(DWORD exception_code,
1261                                                const char* location) {
1262    Message message;
1263    message << "SEH exception with code 0x" << std::setbase(16) <<
1264      exception_code << std::setbase(10) << " thrown in " << location << ".";
1265    return new std::string(message.GetString());
1266  }
1267  #endif  
1268  namespace internal {
1269  #if GTEST_HAS_EXCEPTIONS
1270  static std::string FormatCxxExceptionMessage(const char* description,
1271                                               const char* location) {
1272    Message message;
1273    if (description != NULL) {
1274      message << "C++ exception with description \"" << description << "\"";
1275    } else {
1276      message << "Unknown C++ exception";
1277    }
1278    message << " thrown in " << location << ".";
1279    return message.GetString();
1280  }
1281  static std::string PrintTestPartResultToString(
1282      const TestPartResult& test_part_result);
1283  GoogleTestFailureException::GoogleTestFailureException(
1284      const TestPartResult& failure)
1285      : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}
1286  #endif  
1287  template <class T, typename Result>
1288  Result HandleSehExceptionsInMethodIfSupported(
1289      T* object, Result (T::*method)(), const char* location) {
1290  #if GTEST_HAS_SEH
1291    __try {
1292      return (object->*method)();
1293    } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  
1294        GetExceptionCode())) {
1295      std::string* exception_message = FormatSehExceptionMessage(
1296          GetExceptionCode(), location);
1297      internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
1298                                               *exception_message);
1299      delete exception_message;
1300      return static_cast<Result>(0);
1301    }
1302  #else
1303    (void)location;
1304    return (object->*method)();
1305  #endif  
1306  }
1307  template <class T, typename Result>
1308  Result HandleExceptionsInMethodIfSupported(
1309      T* object, Result (T::*method)(), const char* location) {
1310    if (internal::GetUnitTestImpl()->catch_exceptions()) {
1311  #if GTEST_HAS_EXCEPTIONS
1312      try {
1313        return HandleSehExceptionsInMethodIfSupported(object, method, location);
1314      } catch (const internal::GoogleTestFailureException&) {  
1315        throw;
1316      } catch (const std::exception& e) {  
1317        internal::ReportFailureInUnknownLocation(
1318            TestPartResult::kFatalFailure,
1319            FormatCxxExceptionMessage(e.what(), location));
1320      } catch (...) {  
1321        internal::ReportFailureInUnknownLocation(
1322            TestPartResult::kFatalFailure,
1323            FormatCxxExceptionMessage(NULL, location));
1324      }
1325      return static_cast<Result>(0);
1326  #else
1327      return HandleSehExceptionsInMethodIfSupported(object, method, location);
1328  #endif  
1329    } else {
1330      return (object->*method)();
1331    }
1332  }
1333  }  
1334  void Test::Run() {
1335    if (!HasSameFixtureClass()) return;
1336    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1337    impl->os_stack_trace_getter()->UponLeavingGTest();
1338    internal::HandleExceptionsInMethodIfSupported(this, &Test::SetUp, "SetUp()");
1339    if (!HasFatalFailure()) {
1340      impl->os_stack_trace_getter()->UponLeavingGTest();
1341      internal::HandleExceptionsInMethodIfSupported(
1342          this, &Test::TestBody, "the test body");
1343    }
1344    impl->os_stack_trace_getter()->UponLeavingGTest();
1345    internal::HandleExceptionsInMethodIfSupported(
1346        this, &Test::TearDown, "TearDown()");
1347  }
1348  bool Test::HasFatalFailure() {
1349    return internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();
1350  }
1351  bool Test::HasNonfatalFailure() {
1352    return internal::GetUnitTestImpl()->current_test_result()->
1353        HasNonfatalFailure();
1354  }
1355  TestInfo::TestInfo(const std::string& a_test_case_name,
1356                     const std::string& a_name,
1357                     const char* a_type_param,
1358                     const char* a_value_param,
1359                     internal::TypeId fixture_class_id,
1360                     internal::TestFactoryBase* factory)
1361      : test_case_name_(a_test_case_name),
1362        name_(a_name),
1363        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
1364        value_param_(a_value_param ? new std::string(a_value_param) : NULL),
1365        fixture_class_id_(fixture_class_id),
1366        should_run_(false),
1367        is_disabled_(false),
1368        matches_filter_(false),
1369        factory_(factory),
1370        result_() {}
1371  TestInfo::~TestInfo() { delete factory_; }
1372  namespace internal {
1373  TestInfo* MakeAndRegisterTestInfo(
1374      const char* test_case_name,
1375      const char* name,
1376      const char* type_param,
1377      const char* value_param,
1378      TypeId fixture_class_id,
1379      SetUpTestCaseFunc set_up_tc,
1380      TearDownTestCaseFunc tear_down_tc,
1381      TestFactoryBase* factory) {
1382    TestInfo* const test_info =
1383        new TestInfo(test_case_name, name, type_param, value_param,
1384                     fixture_class_id, factory);
1385    GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);
1386    return test_info;
1387  }
1388  #if GTEST_HAS_PARAM_TEST
1389  void ReportInvalidTestCaseType(const char* test_case_name,
1390                                 const char* file, int line) {
1391    Message errors;
1392    errors
1393        << "Attempted redefinition of test case " << test_case_name << ".\n"
1394        << "All tests in the same test case must use the same test fixture\n"
1395        << "class.  However, in test case " << test_case_name << ", you tried\n"
1396        << "to define a test using a fixture class different from the one\n"
1397        << "used earlier. This can happen if the two fixture classes are\n"
1398        << "from different namespaces and have the same name. You should\n"
1399        << "probably rename one of the classes to put the tests into different\n"
1400        << "test cases.";
1401    fprintf(stderr, "%s %s", FormatFileLocation(file, line).c_str(),
1402            errors.GetString().c_str());
1403  }
1404  #endif  
1405  }  
1406  namespace {
1407  class TestNameIs {
1408   public:
1409    explicit TestNameIs(const char* name)
1410        : name_(name) {}
1411    bool operator()(const TestInfo * test_info) const {
1412      return test_info && test_info->name() == name_;
1413    }
1414   private:
1415    std::string name_;
1416  };
1417  }  
1418  namespace internal {
1419  void UnitTestImpl::RegisterParameterizedTests() {
1420  #if GTEST_HAS_PARAM_TEST
1421    if (!parameterized_tests_registered_) {
1422      parameterized_test_registry_.RegisterTests();
1423      parameterized_tests_registered_ = true;
1424    }
1425  #endif
1426  }
1427  }  
1428  void TestInfo::Run() {
1429    if (!should_run_) return;
1430    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1431    impl->set_current_test_info(this);
1432    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
1433    repeater->OnTestStart(*this);
1434    const TimeInMillis start = internal::GetTimeInMillis();
1435    impl->os_stack_trace_getter()->UponLeavingGTest();
1436    Test* const test = internal::HandleExceptionsInMethodIfSupported(
1437        factory_, &internal::TestFactoryBase::CreateTest,
1438        "the test fixture's constructor");
1439    if ((test != NULL) && !Test::HasFatalFailure()) {
1440      test->Run();
1441    }
1442    impl->os_stack_trace_getter()->UponLeavingGTest();
1443    internal::HandleExceptionsInMethodIfSupported(
1444        test, &Test::DeleteSelf_, "the test fixture's destructor");
1445    result_.set_elapsed_time(internal::GetTimeInMillis() - start);
1446    repeater->OnTestEnd(*this);
1447    impl->set_current_test_info(NULL);
1448  }
1449  int TestCase::successful_test_count() const {
1450    return CountIf(test_info_list_, TestPassed);
1451  }
1452  int TestCase::failed_test_count() const {
1453    return CountIf(test_info_list_, TestFailed);
1454  }
1455  int TestCase::reportable_disabled_test_count() const {
1456    return CountIf(test_info_list_, TestReportableDisabled);
1457  }
1458  int TestCase::disabled_test_count() const {
1459    return CountIf(test_info_list_, TestDisabled);
1460  }
1461  int TestCase::reportable_test_count() const {
1462    return CountIf(test_info_list_, TestReportable);
1463  }
1464  int TestCase::test_to_run_count() const {
1465    return CountIf(test_info_list_, ShouldRunTest);
1466  }
1467  int TestCase::total_test_count() const {
1468    return static_cast<int>(test_info_list_.size());
1469  }
1470  TestCase::TestCase(const char* a_name, const char* a_type_param,
1471                     Test::SetUpTestCaseFunc set_up_tc,
1472                     Test::TearDownTestCaseFunc tear_down_tc)
1473      : name_(a_name),
1474        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
1475        set_up_tc_(set_up_tc),
1476        tear_down_tc_(tear_down_tc),
1477        should_run_(false),
1478        elapsed_time_(0) {
1479  }
1480  TestCase::~TestCase() {
1481    ForEach(test_info_list_, internal::Delete<TestInfo>);
1482  }
1483  const TestInfo* TestCase::GetTestInfo(int i) const {
1484    const int index = GetElementOr(test_indices_, i, -1);
1485    return index < 0 ? NULL : test_info_list_[index];
1486  }
1487  TestInfo* TestCase::GetMutableTestInfo(int i) {
1488    const int index = GetElementOr(test_indices_, i, -1);
1489    return index < 0 ? NULL : test_info_list_[index];
1490  }
1491  void TestCase::AddTestInfo(TestInfo * test_info) {
1492    test_info_list_.push_back(test_info);
1493    test_indices_.push_back(static_cast<int>(test_indices_.size()));
1494  }
1495  void TestCase::Run() {
1496    if (!should_run_) return;
1497    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1498    impl->set_current_test_case(this);
1499    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
1500    repeater->OnTestCaseStart(*this);
1501    impl->os_stack_trace_getter()->UponLeavingGTest();
1502    internal::HandleExceptionsInMethodIfSupported(
1503        this, &TestCase::RunSetUpTestCase, "SetUpTestCase()");
1504    const internal::TimeInMillis start = internal::GetTimeInMillis();
1505    for (int i = 0; i < total_test_count(); i++) {
1506      GetMutableTestInfo(i)->Run();
1507    }
1508    elapsed_time_ = internal::GetTimeInMillis() - start;
1509    impl->os_stack_trace_getter()->UponLeavingGTest();
1510    internal::HandleExceptionsInMethodIfSupported(
1511        this, &TestCase::RunTearDownTestCase, "TearDownTestCase()");
1512    repeater->OnTestCaseEnd(*this);
1513    impl->set_current_test_case(NULL);
1514  }
1515  void TestCase::ClearResult() {
1516    ad_hoc_test_result_.Clear();
1517    ForEach(test_info_list_, TestInfo::ClearTestResult);
1518  }
1519  void TestCase::ShuffleTests(internal::Random* random) {
1520    Shuffle(random, &test_indices_);
1521  }
1522  void TestCase::UnshuffleTests() {
1523    for (size_t i = 0; i < test_indices_.size(); i++) {
1524      test_indices_[i] = static_cast<int>(i);
1525    }
1526  }
1527  static std::string FormatCountableNoun(int count,
1528                                         const char * singular_form,
1529                                         const char * plural_form) {
1530    return internal::StreamableToString(count) + " " +
1531        (count == 1 ? singular_form : plural_form);
1532  }
1533  static std::string FormatTestCount(int test_count) {
1534    return FormatCountableNoun(test_count, "test", "tests");
1535  }
1536  static std::string FormatTestCaseCount(int test_case_count) {
1537    return FormatCountableNoun(test_case_count, "test case", "test cases");
1538  }
1539  static const char * TestPartResultTypeToString(TestPartResult::Type type) {
1540    switch (type) {
1541      case TestPartResult::kSuccess:
1542        return "Success";
1543      case TestPartResult::kNonFatalFailure:
1544      case TestPartResult::kFatalFailure:
1545  #ifdef _MSC_VER
1546        return "error: ";
1547  #else
1548        return "Failure\n";
1549  #endif
1550      default:
1551        return "Unknown result type";
1552    }
1553  }
1554  namespace internal {
1555  static std::string PrintTestPartResultToString(
1556      const TestPartResult& test_part_result) {
1557    return (Message()
1558            << internal::FormatFileLocation(test_part_result.file_name(),
1559                                            test_part_result.line_number())
1560            << " " << TestPartResultTypeToString(test_part_result.type())
1561            << test_part_result.message()).GetString();
1562  }
1563  static void PrintTestPartResult(const TestPartResult& test_part_result) {
1564    const std::string& result =
1565        PrintTestPartResultToString(test_part_result);
1566    printf("%s\n", result.c_str());
1567    fflush(stdout);
1568  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1569    ::OutputDebugStringA(result.c_str());
1570    ::OutputDebugStringA("\n");
1571  #endif
1572  }
1573  enum GTestColor {
1574    COLOR_DEFAULT,
1575    COLOR_RED,
1576    COLOR_GREEN,
1577    COLOR_YELLOW
1578  };
1579  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1580  WORD GetColorAttribute(GTestColor color) {
1581    switch (color) {
1582      case COLOR_RED:    return FOREGROUND_RED;
1583      case COLOR_GREEN:  return FOREGROUND_GREEN;
1584      case COLOR_YELLOW: return FOREGROUND_RED | FOREGROUND_GREEN;
1585      default:           return 0;
1586    }
1587  }
1588  #else
1589  const char* GetAnsiColorCode(GTestColor color) {
1590    switch (color) {
1591      case COLOR_RED:     return "1";
1592      case COLOR_GREEN:   return "2";
1593      case COLOR_YELLOW:  return "3";
1594      default:            return NULL;
1595    };
1596  }
1597  #endif  
1598  bool ShouldUseColor(bool stdout_is_tty) {
1599    const char* const gtest_color = GTEST_FLAG(color).c_str();
1600    if (String::CaseInsensitiveCStringEquals(gtest_color, "auto")) {
1601  #if GTEST_OS_WINDOWS
1602      return stdout_is_tty;
1603  #else
1604      const char* const term = posix::GetEnv("TERM");
1605      const bool term_supports_color =
1606          String::CStringEquals(term, "xterm") ||
1607          String::CStringEquals(term, "xterm-color") ||
1608          String::CStringEquals(term, "xterm-256color") ||
1609          String::CStringEquals(term, "screen") ||
1610          String::CStringEquals(term, "screen-256color") ||
1611          String::CStringEquals(term, "linux") ||
1612          String::CStringEquals(term, "cygwin");
1613      return stdout_is_tty && term_supports_color;
1614  #endif  
1615    }
1616    return String::CaseInsensitiveCStringEquals(gtest_color, "yes") ||
1617        String::CaseInsensitiveCStringEquals(gtest_color, "true") ||
1618        String::CaseInsensitiveCStringEquals(gtest_color, "t") ||
1619        String::CStringEquals(gtest_color, "1");
1620  }
1621  void ColoredPrintf(GTestColor color, const char* fmt, ...) {
1622    va_list args;
1623    va_start(args, fmt);
1624  #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || GTEST_OS_IOS
1625    const bool use_color = false;
1626  #else
1627    static const bool in_color_mode =
1628        ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);
1629    const bool use_color = in_color_mode && (color != COLOR_DEFAULT);
1630  #endif  
1631    if (!use_color) {
1632      vprintf(fmt, args);
1633      va_end(args);
1634      return;
1635    }
1636  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1637    const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
1638    CONSOLE_SCREEN_BUFFER_INFO buffer_info;
1639    GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);
1640    const WORD old_color_attrs = buffer_info.wAttributes;
1641    fflush(stdout);
1642    SetConsoleTextAttribute(stdout_handle,
1643                            GetColorAttribute(color) | FOREGROUND_INTENSITY);
1644    vprintf(fmt, args);
1645    fflush(stdout);
1646    SetConsoleTextAttribute(stdout_handle, old_color_attrs);
1647  #else
1648    printf("\033[0;3%sm", GetAnsiColorCode(color));
1649    vprintf(fmt, args);
1650    printf("\033[m");  
1651  #endif  
1652    va_end(args);
1653  }
1654  static const char kTypeParamLabel[] = "TypeParam";
1655  static const char kValueParamLabel[] = "GetParam()";
1656  void PrintFullTestCommentIfPresent(const TestInfo& test_info) {
1657    const char* const type_param = test_info.type_param();
1658    const char* const value_param = test_info.value_param();
1659    if (type_param != NULL || value_param != NULL) {
1660      printf(", where ");
1661      if (type_param != NULL) {
1662        printf("%s = %s", kTypeParamLabel, type_param);
1663        if (value_param != NULL)
1664          printf(" and ");
1665      }
1666      if (value_param != NULL) {
1667        printf("%s = %s", kValueParamLabel, value_param);
1668      }
1669    }
1670  }
1671  class PrettyUnitTestResultPrinter : public TestEventListener {
1672   public:
1673    PrettyUnitTestResultPrinter() {}
1674    static void PrintTestName(const char * test_case, const char * test) {
1675      printf("%s.%s", test_case, test);
1676    }
1677    virtual void OnTestProgramStart(const UnitTest& &bsol;*unit_test*/) {}
1678    virtual void OnTestIterationStart(const UnitTest& unit_test, int iteration);
1679    virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test);
1680    virtual void OnEnvironmentsSetUpEnd(const UnitTest& &bsol;*unit_test*/) {}
1681    virtual void OnTestCaseStart(const TestCase& test_case);
1682    virtual void OnTestStart(const TestInfo& test_info);
1683    virtual void OnTestPartResult(const TestPartResult& result);
1684    virtual void OnTestEnd(const TestInfo& test_info);
1685    virtual void OnTestCaseEnd(const TestCase& test_case);
1686    virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test);
1687    virtual void OnEnvironmentsTearDownEnd(const UnitTest& &bsol;*unit_test*/) {}
1688    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1689    virtual void OnTestProgramEnd(const UnitTest& &bsol;*unit_test*/) {}
1690   private:
1691    static void PrintFailedTests(const UnitTest& unit_test);
1692  };
1693  void PrettyUnitTestResultPrinter::OnTestIterationStart(
1694      const UnitTest& unit_test, int iteration) {
1695    if (GTEST_FLAG(repeat) != 1)
1696      printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1);
1697    const char* const filter = GTEST_FLAG(filter).c_str();
1698    if (!String::CStringEquals(filter, kUniversalFilter)) {
1699      ColoredPrintf(COLOR_YELLOW,
1700                    "Note: %s filter = %s\n", GTEST_NAME_, filter);
1701    }
1702    if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {
1703      const Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
1704      ColoredPrintf(COLOR_YELLOW,
1705                    "Note: This is test shard %d of %s.\n",
1706                    static_cast<int>(shard_index) + 1,
1707                    internal::posix::GetEnv(kTestTotalShards));
1708    }
1709    if (GTEST_FLAG(shuffle)) {
1710      ColoredPrintf(COLOR_YELLOW,
1711                    "Note: Randomizing tests' orders with a seed of %d .\n",
1712                    unit_test.random_seed());
1713    }
1714    ColoredPrintf(COLOR_GREEN,  "[==========] ");
1715    printf("Running %s from %s.\n",
1716           FormatTestCount(unit_test.test_to_run_count()).c_str(),
1717           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
1718    fflush(stdout);
1719  }
1720  void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
1721      const UnitTest& &bsol;*unit_test*/) {
1722    ColoredPrintf(COLOR_GREEN,  "[----------] ");
1723    printf("Global test environment set-up.\n");
1724    fflush(stdout);
1725  }
1726  void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase& test_case) {
1727    const std::string counts =
1728        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
1729    ColoredPrintf(COLOR_GREEN, "[----------] ");
1730    printf("%s from %s", counts.c_str(), test_case.name());
1731    if (test_case.type_param() == NULL) {
1732      printf("\n");
1733    } else {
1734      printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param());
1735    }
1736    fflush(stdout);
1737  }
1738  void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo& test_info) {
1739    ColoredPrintf(COLOR_GREEN,  "[ RUN      ] ");
1740    PrintTestName(test_info.test_case_name(), test_info.name());
1741    printf("\n");
1742    fflush(stdout);
1743  }
1744  void PrettyUnitTestResultPrinter::OnTestPartResult(
1745      const TestPartResult& result) {
1746    if (result.type() == TestPartResult::kSuccess)
1747      return;
1748    PrintTestPartResult(result);
1749    fflush(stdout);
1750  }
1751  void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo& test_info) {
1752    if (test_info.result()->Passed()) {
1753      ColoredPrintf(COLOR_GREEN, "[       OK ] ");
1754    } else {
1755      ColoredPrintf(COLOR_RED, "[  FAILED  ] ");
1756    }
1757    PrintTestName(test_info.test_case_name(), test_info.name());
1758    if (test_info.result()->Failed())
1759      PrintFullTestCommentIfPresent(test_info);
1760    if (GTEST_FLAG(print_time)) {
1761      printf(" (%s ms)\n", internal::StreamableToString(
1762             test_info.result()->elapsed_time()).c_str());
1763    } else {
1764      printf("\n");
1765    }
1766    fflush(stdout);
1767  }
1768  void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase& test_case) {
1769    if (!GTEST_FLAG(print_time)) return;
1770    const std::string counts =
1771        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
1772    ColoredPrintf(COLOR_GREEN, "[----------] ");
1773    printf("%s from %s (%s ms total)\n\n",
1774           counts.c_str(), test_case.name(),
1775           internal::StreamableToString(test_case.elapsed_time()).c_str());
1776    fflush(stdout);
1777  }
1778  void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
1779      const UnitTest& &bsol;*unit_test*/) {
1780    ColoredPrintf(COLOR_GREEN,  "[----------] ");
1781    printf("Global test environment tear-down\n");
1782    fflush(stdout);
1783  }
1784  void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest& unit_test) {
1785    const int failed_test_count = unit_test.failed_test_count();
1786    if (failed_test_count == 0) {
1787      return;
1788    }
1789    for (int i = 0; i < unit_test.total_test_case_count(); ++i) {
1790      const TestCase& test_case = *unit_test.GetTestCase(i);
1791      if (!test_case.should_run() || (test_case.failed_test_count() == 0)) {
1792        continue;
1793      }
1794      for (int j = 0; j < test_case.total_test_count(); ++j) {
1795        const TestInfo& test_info = *test_case.GetTestInfo(j);
1796        if (!test_info.should_run() || test_info.result()->Passed()) {
1797          continue;
1798        }
1799        ColoredPrintf(COLOR_RED, "[  FAILED  ] ");
1800        printf("%s.%s", test_case.name(), test_info.name());
1801        PrintFullTestCommentIfPresent(test_info);
1802        printf("\n");
1803      }
1804    }
1805  }
1806  void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
1807                                                       int &bsol;*iteration*/) {
1808    ColoredPrintf(COLOR_GREEN,  "[==========] ");
1809    printf("%s from %s ran.",
1810           FormatTestCount(unit_test.test_to_run_count()).c_str(),
1811           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
1812    if (GTEST_FLAG(print_time)) {
1813      printf(" (%s ms total)",
1814             internal::StreamableToString(unit_test.elapsed_time()).c_str());
1815    }
1816    printf("\n");
1817    ColoredPrintf(COLOR_GREEN,  "[  PASSED  ] ");
1818    printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());
1819    int num_failures = unit_test.failed_test_count();
1820    if (!unit_test.Passed()) {
1821      const int failed_test_count = unit_test.failed_test_count();
1822      ColoredPrintf(COLOR_RED,  "[  FAILED  ] ");
1823      printf("%s, listed below:\n", FormatTestCount(failed_test_count).c_str());
1824      PrintFailedTests(unit_test);
1825      printf("\n%2d FAILED %s\n", num_failures,
1826                          num_failures == 1 ? "TEST" : "TESTS");
1827    }
1828    int num_disabled = unit_test.reportable_disabled_test_count();
1829    if (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) {
1830      if (!num_failures) {
1831        printf("\n");  
1832      }
1833      ColoredPrintf(COLOR_YELLOW,
1834                    "  YOU HAVE %d DISABLED %s\n\n",
1835                    num_disabled,
1836                    num_disabled == 1 ? "TEST" : "TESTS");
1837    }
1838    fflush(stdout);
1839  }
1840  class TestEventRepeater : public TestEventListener {
1841   public:
1842    TestEventRepeater() : forwarding_enabled_(true) {}
1843    virtual ~TestEventRepeater();
1844    void Append(TestEventListener *listener);
1845    TestEventListener* Release(TestEventListener* listener);
1846    bool forwarding_enabled() const { return forwarding_enabled_; }
1847    void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }
1848    virtual void OnTestProgramStart(const UnitTest& unit_test);
1849    virtual void OnTestIterationStart(const UnitTest& unit_test, int iteration);
1850    virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test);
1851    virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test);
1852    virtual void OnTestCaseStart(const TestCase& test_case);
1853    virtual void OnTestStart(const TestInfo& test_info);
1854    virtual void OnTestPartResult(const TestPartResult& result);
1855    virtual void OnTestEnd(const TestInfo& test_info);
1856    virtual void OnTestCaseEnd(const TestCase& test_case);
1857    virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test);
1858    virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test);
1859    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1860    virtual void OnTestProgramEnd(const UnitTest& unit_test);
1861   private:
1862    bool forwarding_enabled_;
1863    std::vector<TestEventListener*> listeners_;
1864    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);
1865  };
1866  TestEventRepeater::~TestEventRepeater() {
1867    ForEach(listeners_, Delete<TestEventListener>);
1868  }
1869  void TestEventRepeater::Append(TestEventListener *listener) {
1870    listeners_.push_back(listener);
1871  }
1872  TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
1873    for (size_t i = 0; i < listeners_.size(); ++i) {
1874      if (listeners_[i] == listener) {
1875        listeners_.erase(listeners_.begin() + i);
1876        return listener;
1877      }
1878    }
1879    return NULL;
1880  }
1881  #define GTEST_REPEATER_METHOD_(Name, Type) \
1882  void TestEventRepeater::Name(const Type& parameter) { \
1883    if (forwarding_enabled_) { \
1884      for (size_t i = 0; i < listeners_.size(); i++) { \
1885        listeners_[i]->Name(parameter); \
1886      } \
1887    } \
1888  }
1889  #define GTEST_REVERSE_REPEATER_METHOD_(Name, Type) \
1890  void TestEventRepeater::Name(const Type& parameter) { \
1891    if (forwarding_enabled_) { \
1892      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) { \
1893        listeners_[i]->Name(parameter); \
1894      } \
1895    } \
1896  }
1897  GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)
1898  GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)
1899  GTEST_REPEATER_METHOD_(OnTestCaseStart, TestCase)
1900  GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)
1901  GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)
1902  GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)
1903  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)
1904  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)
1905  GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)
1906  GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestCase)
1907  GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)
1908  #undef GTEST_REPEATER_METHOD_
1909  #undef GTEST_REVERSE_REPEATER_METHOD_
1910  void TestEventRepeater::OnTestIterationStart(const UnitTest& unit_test,
1911                                               int iteration) {
1912    if (forwarding_enabled_) {
1913      for (size_t i = 0; i < listeners_.size(); i++) {
1914        listeners_[i]->OnTestIterationStart(unit_test, iteration);
1915      }
1916    }
1917  }
1918  void TestEventRepeater::OnTestIterationEnd(const UnitTest& unit_test,
1919                                             int iteration) {
1920    if (forwarding_enabled_) {
1921      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) {
1922        listeners_[i]->OnTestIterationEnd(unit_test, iteration);
1923      }
1924    }
1925  }
1926  class XmlUnitTestResultPrinter : public EmptyTestEventListener {
1927   public:
1928    explicit XmlUnitTestResultPrinter(const char* output_file);
1929    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1930   private:
1931    static bool IsNormalizableWhitespace(char c) {
1932      return c == 0x9 || c == 0xA || c == 0xD;
1933    }
1934    static bool IsValidXmlCharacter(char c) {
1935      return IsNormalizableWhitespace(c) || c >= 0x20;
1936    }
1937    static std::string EscapeXml(const std::string& str, bool is_attribute);
1938    static std::string RemoveInvalidXmlCharacters(const std::string& str);
1939    static std::string EscapeXmlAttribute(const std::string& str) {
1940      return EscapeXml(str, true);
1941    }
1942    static std::string EscapeXmlText(const char* str) {
1943      return EscapeXml(str, false);
1944    }
1945    static void OutputXmlAttribute(std::ostream* stream,
1946                                   const std::string& element_name,
1947                                   const std::string& name,
1948                                   const std::string& value);
1949    static void OutputXmlCDataSection(::std::ostream* stream, const char* data);
1950    static void OutputXmlTestInfo(::std::ostream* stream,
1951                                  const char* test_case_name,
1952                                  const TestInfo& test_info);
1953    static void PrintXmlTestCase(::std::ostream* stream,
1954                                 const TestCase& test_case);
1955    static void PrintXmlUnitTest(::std::ostream* stream,
1956                                 const UnitTest& unit_test);
1957    static std::string TestPropertiesAsXmlAttributes(const TestResult& result);
1958    const std::string output_file_;
1959    GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter);
1960  };
1961  XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)
1962      : output_file_(output_file) {
1963    if (output_file_.c_str() == NULL || output_file_.empty()) {
1964      fprintf(stderr, "XML output file may not be null\n");
1965      fflush(stderr);
1966      exit(EXIT_FAILURE);
1967    }
1968  }
1969  void XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
1970                                                    int &bsol;*iteration*/) {
1971    FILE* xmlout = NULL;
1972    FilePath output_file(output_file_);
1973    FilePath output_dir(output_file.RemoveFileName());
1974    if (output_dir.CreateDirectoriesRecursively()) {
1975      xmlout = posix::FOpen(output_file_.c_str(), "w");
1976    }
1977    if (xmlout == NULL) {
1978      fprintf(stderr,
1979              "Unable to open file \"%s\"\n",
1980              output_file_.c_str());
1981      fflush(stderr);
1982      exit(EXIT_FAILURE);
1983    }
1984    std::stringstream stream;
1985    PrintXmlUnitTest(&stream, unit_test);
1986    fprintf(xmlout, "%s", StringStreamToString(&stream).c_str());
1987    fclose(xmlout);
1988  }
1989  std::string XmlUnitTestResultPrinter::EscapeXml(
1990      const std::string& str, bool is_attribute) {
1991    Message m;
1992    for (size_t i = 0; i < str.size(); ++i) {
1993      const char ch = str[i];
1994      switch (ch) {
1995        case '<':
1996          m << "&lt;";
1997          break;
1998        case '>':
1999          m << "&gt;";
2000          break;
2001        case '&':
2002          m << "&amp;";
2003          break;
2004        case '\'':
2005          if (is_attribute)
2006            m << "&apos;";
2007          else
2008            m << '\'';
2009          break;
2010        case '"':
2011          if (is_attribute)
2012            m << "&quot;";
2013          else
2014            m << '"';
2015          break;
2016        default:
2017          if (IsValidXmlCharacter(ch)) {
2018            if (is_attribute && IsNormalizableWhitespace(ch))
2019              m << "&#x" << String::FormatByte(static_cast<unsigned char>(ch))
2020                << ";";
2021            else
2022              m << ch;
2023          }
2024          break;
2025      }
2026    }
2027    return m.GetString();
2028  }
2029  std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(
2030      const std::string& str) {
2031    std::string output;
2032    output.reserve(str.size());
2033    for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)
2034      if (IsValidXmlCharacter(*it))
2035        output.push_back(*it);
2036    return output;
2037  }
2038  std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {
2039    ::std::stringstream ss;
2040    ss << ms/1000.0;
2041    return ss.str();
2042  }
2043  std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {
2044    time_t seconds = static_cast<time_t>(ms / 1000);
2045  #ifdef _MSC_VER
2046  # pragma warning(push)          
2047  # pragma warning(disable:4996)  
2048    const struct tm* const time_struct = localtime(&seconds);  
2049  # pragma warning(pop)           
2050  #else
2051    const struct tm* const time_struct = localtime(&seconds);  
2052  #endif
2053    if (time_struct == NULL)
2054      return "";  
2055    return StreamableToString(time_struct->tm_year + 1900) + "-" +
2056        String::FormatIntWidth2(time_struct->tm_mon + 1) + "-" +
2057        String::FormatIntWidth2(time_struct->tm_mday) + "T" +
2058        String::FormatIntWidth2(time_struct->tm_hour) + ":" +
2059        String::FormatIntWidth2(time_struct->tm_min) + ":" +
2060        String::FormatIntWidth2(time_struct->tm_sec);
2061  }
2062  void XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,
2063                                                       const char* data) {
2064    const char* segment = data;
2065    *stream << "<![CDATA[";
2066    for (;;) {
2067      const char* const next_segment = strstr(segment, "]]>");
2068      if (next_segment != NULL) {
2069        stream->write(
2070            segment, static_cast<std::streamsize>(next_segment - segment));
2071        *stream << "]]>]]&gt;<![CDATA[";
2072        segment = next_segment + strlen("]]>");
2073      } else {
2074        *stream << segment;
2075        break;
2076      }
2077    }
2078    *stream << "]]>";
2079  }
2080  void XmlUnitTestResultPrinter::OutputXmlAttribute(
2081      std::ostream* stream,
2082      const std::string& element_name,
2083      const std::string& name,
2084      const std::string& value) {
2085    const std::vector<std::string>& allowed_names =
2086        GetReservedAttributesForElement(element_name);
2087    GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=
2088                     allowed_names.end())
2089        << "Attribute " << name << " is not allowed for element <" << element_name
2090        << ">.";
2091    *stream << " " << name << "=\"" << EscapeXmlAttribute(value) << "\"";
2092  }
2093  void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
2094                                                   const char* test_case_name,
2095                                                   const TestInfo& test_info) {
2096    const TestResult& result = *test_info.result();
2097    const std::string kTestcase = "testcase";
2098    *stream << "    <testcase";
2099    OutputXmlAttribute(stream, kTestcase, "name", test_info.name());
2100    if (test_info.value_param() != NULL) {
2101      OutputXmlAttribute(stream, kTestcase, "value_param",
2102                         test_info.value_param());
2103    }
2104    if (test_info.type_param() != NULL) {
2105      OutputXmlAttribute(stream, kTestcase, "type_param", test_info.type_param());
2106    }
2107    OutputXmlAttribute(stream, kTestcase, "status",
2108                       test_info.should_run() ? "run" : "notrun");
2109    OutputXmlAttribute(stream, kTestcase, "time",
2110                       FormatTimeInMillisAsSeconds(result.elapsed_time()));
2111    OutputXmlAttribute(stream, kTestcase, "classname", test_case_name);
2112    *stream << TestPropertiesAsXmlAttributes(result);
2113    int failures = 0;
2114    for (int i = 0; i < result.total_part_count(); ++i) {
2115      const TestPartResult& part = result.GetTestPartResult(i);
2116      if (part.failed()) {
2117        if (++failures == 1) {
2118          *stream << ">\n";
2119        }
2120        const string location = internal::FormatCompilerIndependentFileLocation(
2121            part.file_name(), part.line_number());
2122        const string summary = location + "\n" + part.summary();
2123        *stream << "      <failure message=\""
2124                << EscapeXmlAttribute(summary.c_str())
2125                << "\" type=\"\">";
2126        const string detail = location + "\n" + part.message();
2127        OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
2128        *stream << "</failure>\n";
2129      }
2130    }
2131    if (failures == 0)
2132      *stream << " />\n";
2133    else
2134      *stream << "    </testcase>\n";
2135  }
2136  void XmlUnitTestResultPrinter::PrintXmlTestCase(std::ostream* stream,
2137                                                  const TestCase& test_case) {
2138    const std::string kTestsuite = "testsuite";
2139    *stream << "  <" << kTestsuite;
2140    OutputXmlAttribute(stream, kTestsuite, "name", test_case.name());
2141    OutputXmlAttribute(stream, kTestsuite, "tests",
2142                       StreamableToString(test_case.reportable_test_count()));
2143    OutputXmlAttribute(stream, kTestsuite, "failures",
2144                       StreamableToString(test_case.failed_test_count()));
2145    OutputXmlAttribute(
2146        stream, kTestsuite, "disabled",
2147        StreamableToString(test_case.reportable_disabled_test_count()));
2148    OutputXmlAttribute(stream, kTestsuite, "errors", "0");
2149    OutputXmlAttribute(stream, kTestsuite, "time",
2150                       FormatTimeInMillisAsSeconds(test_case.elapsed_time()));
2151    *stream << TestPropertiesAsXmlAttributes(test_case.ad_hoc_test_result())
2152            << ">\n";
2153    for (int i = 0; i < test_case.total_test_count(); ++i) {
2154      if (test_case.GetTestInfo(i)->is_reportable())
2155        OutputXmlTestInfo(stream, test_case.name(), *test_case.GetTestInfo(i));
2156    }
2157    *stream << "  </" << kTestsuite << ">\n";
2158  }
2159  void XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,
2160                                                  const UnitTest& unit_test) {
2161    const std::string kTestsuites = "testsuites";
2162    *stream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
2163    *stream << "<" << kTestsuites;
2164    OutputXmlAttribute(stream, kTestsuites, "tests",
2165                       StreamableToString(unit_test.reportable_test_count()));
2166    OutputXmlAttribute(stream, kTestsuites, "failures",
2167                       StreamableToString(unit_test.failed_test_count()));
2168    OutputXmlAttribute(
2169        stream, kTestsuites, "disabled",
2170        StreamableToString(unit_test.reportable_disabled_test_count()));
2171    OutputXmlAttribute(stream, kTestsuites, "errors", "0");
2172    OutputXmlAttribute(
2173        stream, kTestsuites, "timestamp",
2174        FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));
2175    OutputXmlAttribute(stream, kTestsuites, "time",
2176                       FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));
2177    if (GTEST_FLAG(shuffle)) {
2178      OutputXmlAttribute(stream, kTestsuites, "random_seed",
2179                         StreamableToString(unit_test.random_seed()));
2180    }
2181    *stream << TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());
2182    OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
2183    *stream << ">\n";
2184    for (int i = 0; i < unit_test.total_test_case_count(); ++i) {
2185      if (unit_test.GetTestCase(i)->reportable_test_count() > 0)
2186        PrintXmlTestCase(stream, *unit_test.GetTestCase(i));
2187    }
2188    *stream << "</" << kTestsuites << ">\n";
2189  }
2190  std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(
2191      const TestResult& result) {
2192    Message attributes;
2193    for (int i = 0; i < result.test_property_count(); ++i) {
2194      const TestProperty& property = result.GetTestProperty(i);
2195      attributes << " " << property.key() << "="
2196          << "\"" << EscapeXmlAttribute(property.value()) << "\"";
2197    }
2198    return attributes.GetString();
2199  }
2200  #if GTEST_CAN_STREAM_RESULTS_
2201  string StreamingListener::UrlEncode(const char* str) {
2202    string result;
2203    result.reserve(strlen(str) + 1);
2204    for (char ch = *str; ch != '\0'; ch = *++str) {
2205      switch (ch) {
2206        case '%':
2207        case '=':
2208        case '&':
2209        case '\n':
2210          result.append("%" + String::FormatByte(static_cast<unsigned char>(ch)));
2211          break;
2212        default:
2213          result.push_back(ch);
2214          break;
2215      }
2216    }
2217    return result;
2218  }
2219  void StreamingListener::SocketWriter::MakeConnection() {
2220    GTEST_CHECK_(sockfd_ == -1)
2221        << "MakeConnection() can't be called when there is already a connection.";
2222    addrinfo hints;
2223    memset(&hints, 0, sizeof(hints));
2224    hints.ai_family = AF_UNSPEC;    
2225    hints.ai_socktype = SOCK_STREAM;
2226    addrinfo* servinfo = NULL;
2227    const int error_num = getaddrinfo(
2228        host_name_.c_str(), port_num_.c_str(), &hints, &servinfo);
2229    if (error_num != 0) {
2230      GTEST_LOG_(WARNING) << "stream_result_to: getaddrinfo() failed: "
2231                          << gai_strerror(error_num);
2232    }
2233    for (addrinfo* cur_addr = servinfo; sockfd_ == -1 && cur_addr != NULL;
2234         cur_addr = cur_addr->ai_next) {
2235      sockfd_ = socket(
2236          cur_addr->ai_family, cur_addr->ai_socktype, cur_addr->ai_protocol);
2237      if (sockfd_ != -1) {
2238        if (connect(sockfd_, cur_addr->ai_addr, cur_addr->ai_addrlen) == -1) {
2239          close(sockfd_);
2240          sockfd_ = -1;
2241        }
2242      }
2243    }
2244    freeaddrinfo(servinfo);  
2245    if (sockfd_ == -1) {
2246      GTEST_LOG_(WARNING) << "stream_result_to: failed to connect to "
2247                          << host_name_ << ":" << port_num_;
2248    }
2249  }
2250  #endif  
2251  ScopedTrace::ScopedTrace(const char* file, int line, const Message& message)
2252      GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
2253    TraceInfo trace;
2254    trace.file = file;
2255    trace.line = line;
2256    trace.message = message.GetString();
2257    UnitTest::GetInstance()->PushGTestTrace(trace);
2258  }
2259  ScopedTrace::~ScopedTrace()
2260      GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
2261    UnitTest::GetInstance()->PopGTestTrace();
2262  }
2263  string OsStackTraceGetter::CurrentStackTrace(int &bsol;* max_depth */,
2264                                               int &bsol;* skip_count */)
2265      GTEST_LOCK_EXCLUDED_(mutex_) {
2266    return "";
2267  }
2268  void OsStackTraceGetter::UponLeavingGTest()
2269      GTEST_LOCK_EXCLUDED_(mutex_) {
2270  }
2271  const char* const
2272  OsStackTraceGetter::kElidedFramesMarker =
2273      "... " GTEST_NAME_ " internal frames ...";
2274  class ScopedPrematureExitFile {
2275   public:
2276    explicit ScopedPrematureExitFile(const char* premature_exit_filepath)
2277        : premature_exit_filepath_(premature_exit_filepath) {
2278      if (premature_exit_filepath != NULL && *premature_exit_filepath != '\0') {
2279        FILE* pfile = posix::FOpen(premature_exit_filepath, "w");
2280        fwrite("0", 1, 1, pfile);
2281        fclose(pfile);
2282      }
2283    }
2284    ~ScopedPrematureExitFile() {
2285      if (premature_exit_filepath_ != NULL && *premature_exit_filepath_ != '\0') {
2286        remove(premature_exit_filepath_);
2287      }
2288    }
2289   private:
2290    const char* const premature_exit_filepath_;
2291    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);
2292  };
2293  }  
2294  TestEventListeners::TestEventListeners()
2295      : repeater_(new internal::TestEventRepeater()),
2296        default_result_printer_(NULL),
2297        default_xml_generator_(NULL) {
2298  }
2299  TestEventListeners::~TestEventListeners() { delete repeater_; }
2300  void TestEventListeners::Append(TestEventListener* listener) {
2301    repeater_->Append(listener);
2302  }
2303  TestEventListener* TestEventListeners::Release(TestEventListener* listener) {
2304    if (listener == default_result_printer_)
2305      default_result_printer_ = NULL;
2306    else if (listener == default_xml_generator_)
2307      default_xml_generator_ = NULL;
2308    return repeater_->Release(listener);
2309  }
2310  TestEventListener* TestEventListeners::repeater() { return repeater_; }
2311  void TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {
2312    if (default_result_printer_ != listener) {
2313      delete Release(default_result_printer_);
2314      default_result_printer_ = listener;
2315      if (listener != NULL)
2316        Append(listener);
2317    }
2318  }
2319  void TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {
2320    if (default_xml_generator_ != listener) {
2321      delete Release(default_xml_generator_);
2322      default_xml_generator_ = listener;
2323      if (listener != NULL)
2324        Append(listener);
2325    }
2326  }
2327  bool TestEventListeners::EventForwardingEnabled() const {
2328    return repeater_->forwarding_enabled();
2329  }
2330  void TestEventListeners::SuppressEventForwarding() {
2331    repeater_->set_forwarding_enabled(false);
2332  }
2333  UnitTest* UnitTest::GetInstance() {
2334  #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)
2335    static UnitTest* const instance = new UnitTest;
2336    return instance;
2337  #else
2338    static UnitTest instance;
2339    return &instance;
2340  #endif  
2341  }
2342  int UnitTest::successful_test_case_count() const {
2343    return impl()->successful_test_case_count();
2344  }
2345  int UnitTest::failed_test_case_count() const {
2346    return impl()->failed_test_case_count();
2347  }
2348  int UnitTest::total_test_case_count() const {
2349    return impl()->total_test_case_count();
2350  }
2351  int UnitTest::test_case_to_run_count() const {
2352    return impl()->test_case_to_run_count();
2353  }
2354  int UnitTest::successful_test_count() const {
2355    return impl()->successful_test_count();
2356  }
2357  int UnitTest::failed_test_count() const { return impl()->failed_test_count(); }
2358  int UnitTest::reportable_disabled_test_count() const {
2359    return impl()->reportable_disabled_test_count();
2360  }
2361  int UnitTest::disabled_test_count() const {
2362    return impl()->disabled_test_count();
2363  }
2364  int UnitTest::reportable_test_count() const {
2365    return impl()->reportable_test_count();
2366  }
2367  int UnitTest::total_test_count() const { return impl()->total_test_count(); }
2368  int UnitTest::test_to_run_count() const { return impl()->test_to_run_count(); }
2369  internal::TimeInMillis UnitTest::start_timestamp() const {
2370      return impl()->start_timestamp();
2371  }
2372  internal::TimeInMillis UnitTest::elapsed_time() const {
2373    return impl()->elapsed_time();
2374  }
2375  bool UnitTest::Passed() const { return impl()->Passed(); }
2376  bool UnitTest::Failed() const { return impl()->Failed(); }
2377  const TestCase* UnitTest::GetTestCase(int i) const {
2378    return impl()->GetTestCase(i);
2379  }
2380  const TestResult& UnitTest::ad_hoc_test_result() const {
2381    return *impl()->ad_hoc_test_result();
2382  }
2383  TestCase* UnitTest::GetMutableTestCase(int i) {
2384    return impl()->GetMutableTestCase(i);
2385  }
2386  TestEventListeners& UnitTest::listeners() {
2387    return *impl()->listeners();
2388  }
2389  Environment* UnitTest::AddEnvironment(Environment* env) {
2390    if (env == NULL) {
2391      return NULL;
2392    }
2393    impl_->environments().push_back(env);
2394    return env;
2395  }
2396  void UnitTest::AddTestPartResult(
2397      TestPartResult::Type result_type,
2398      const char* file_name,
2399      int line_number,
2400      const std::string& message,
2401      const std::string& os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) {
2402    Message msg;
2403    msg << message;
2404    internal::MutexLock lock(&mutex_);
2405    if (impl_->gtest_trace_stack().size() > 0) {
2406      msg << "\n" << GTEST_NAME_ << " trace:";
2407      for (int i = static_cast<int>(impl_->gtest_trace_stack().size());
2408           i > 0; --i) {
2409        const internal::TraceInfo& trace = impl_->gtest_trace_stack()[i - 1];
2410        msg << "\n" << internal::FormatFileLocation(trace.file, trace.line)
2411            << " " << trace.message;
2412      }
2413    }
2414    if (os_stack_trace.c_str() != NULL && !os_stack_trace.empty()) {
2415      msg << internal::kStackTraceMarker << os_stack_trace;
2416    }
2417    const TestPartResult result =
2418      TestPartResult(result_type, file_name, line_number,
2419                     msg.GetString().c_str());
2420    impl_->GetTestPartResultReporterForCurrentThread()->
2421        ReportTestPartResult(result);
2422    if (result_type != TestPartResult::kSuccess) {
2423      if (GTEST_FLAG(break_on_failure)) {
2424  #if GTEST_OS_WINDOWS
2425        DebugBreak();
2426  #else
2427        *static_cast<volatile int*>(NULL) = 1;
2428  #endif  
2429      } else if (GTEST_FLAG(throw_on_failure)) {
2430  #if GTEST_HAS_EXCEPTIONS
2431        throw internal::GoogleTestFailureException(result);
2432  #else
2433        exit(1);
2434  #endif
2435      }
2436    }
2437  }
2438  void UnitTest::RecordProperty(const std::string& key,
2439                                const std::string& value) {
2440    impl_->RecordProperty(TestProperty(key, value));
2441  }
2442  int UnitTest::Run() {
2443    const bool in_death_test_child_process =
2444        internal::GTEST_FLAG(internal_run_death_test).length() > 0;
2445    const internal::ScopedPrematureExitFile premature_exit_file(
2446        in_death_test_child_process ?
2447        NULL : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE"));
2448    impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));
2449  #if GTEST_HAS_SEH
2450    if (impl()->catch_exceptions() || in_death_test_child_process) {
2451  # if !GTEST_OS_WINDOWS_MOBILE
2452      SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
2453                   SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
2454  # endif  
2455  # if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) && !GTEST_OS_WINDOWS_MOBILE
2456      _set_error_mode(_OUT_TO_STDERR);
2457  # endif
2458  # if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE
2459      if (!GTEST_FLAG(break_on_failure))
2460        _set_abort_behavior(
2461            0x0,                                    
2462            _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  
2463  # endif
2464    }
2465  #endif  
2466    return internal::HandleExceptionsInMethodIfSupported(
2467        impl(),
2468        &internal::UnitTestImpl::RunAllTests,
2469        "auxiliary test code (environments or event listeners)") ? 0 : 1;
2470  }
2471  const char* UnitTest::original_working_dir() const {
2472    return impl_->original_working_dir_.c_str();
2473  }
2474  const TestCase* UnitTest::current_test_case() const
2475      GTEST_LOCK_EXCLUDED_(mutex_) {
2476    internal::MutexLock lock(&mutex_);
2477    return impl_->current_test_case();
2478  }
2479  const TestInfo* UnitTest::current_test_info() const
2480      GTEST_LOCK_EXCLUDED_(mutex_) {
2481    internal::MutexLock lock(&mutex_);
2482    return impl_->current_test_info();
2483  }
2484  int UnitTest::random_seed() const { return impl_->random_seed(); }
2485  #if GTEST_HAS_PARAM_TEST
2486  internal::ParameterizedTestCaseRegistry&
2487      UnitTest::parameterized_test_registry()
2488          GTEST_LOCK_EXCLUDED_(mutex_) {
2489    return impl_->parameterized_test_registry();
2490  }
2491  #endif  
2492  UnitTest::UnitTest() {
2493    impl_ = new internal::UnitTestImpl(this);
2494  }
2495  UnitTest::~UnitTest() {
2496    delete impl_;
2497  }
2498  void UnitTest::PushGTestTrace(const internal::TraceInfo& trace)
2499      GTEST_LOCK_EXCLUDED_(mutex_) {
2500    internal::MutexLock lock(&mutex_);
2501    impl_->gtest_trace_stack().push_back(trace);
2502  }
2503  void UnitTest::PopGTestTrace()
2504      GTEST_LOCK_EXCLUDED_(mutex_) {
2505    internal::MutexLock lock(&mutex_);
2506    impl_->gtest_trace_stack().pop_back();
2507  }
2508  namespace internal {
2509  UnitTestImpl::UnitTestImpl(UnitTest* parent)
2510      : parent_(parent),
2511  #ifdef _MSC_VER
2512  # pragma warning(push)                    
2513  # pragma warning(disable:4355)            
2514        default_global_test_part_result_reporter_(this),
2515        default_per_thread_test_part_result_reporter_(this),
2516  # pragma warning(pop)                     
2517  #else
2518        default_global_test_part_result_reporter_(this),
2519        default_per_thread_test_part_result_reporter_(this),
2520  #endif  
2521        global_test_part_result_repoter_(
2522            &default_global_test_part_result_reporter_),
2523        per_thread_test_part_result_reporter_(
2524            &default_per_thread_test_part_result_reporter_),
2525  #if GTEST_HAS_PARAM_TEST
2526        parameterized_test_registry_(),
2527        parameterized_tests_registered_(false),
2528  #endif  
2529        last_death_test_case_(-1),
2530        current_test_case_(NULL),
2531        current_test_info_(NULL),
2532        ad_hoc_test_result_(),
2533        os_stack_trace_getter_(NULL),
2534        post_flag_parse_init_performed_(false),
2535        random_seed_(0),  
2536        random_(0),  
2537        start_timestamp_(0),
2538        elapsed_time_(0),
2539  #if GTEST_HAS_DEATH_TEST
2540        death_test_factory_(new DefaultDeathTestFactory),
2541  #endif
2542        catch_exceptions_(false) {
2543    listeners()->SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);
2544  }
2545  UnitTestImpl::~UnitTestImpl() {
2546    ForEach(test_cases_, internal::Delete<TestCase>);
2547    ForEach(environments_, internal::Delete<Environment>);
2548    delete os_stack_trace_getter_;
2549  }
2550  void UnitTestImpl::RecordProperty(const TestProperty& test_property) {
2551    std::string xml_element;
2552    TestResult* test_result;  
2553    if (current_test_info_ != NULL) {
2554      xml_element = "testcase";
2555      test_result = &(current_test_info_->result_);
2556    } else if (current_test_case_ != NULL) {
2557      xml_element = "testsuite";
2558      test_result = &(current_test_case_->ad_hoc_test_result_);
2559    } else {
2560      xml_element = "testsuites";
2561      test_result = &ad_hoc_test_result_;
2562    }
2563    test_result->RecordProperty(xml_element, test_property);
2564  }
2565  #if GTEST_HAS_DEATH_TEST
2566  void UnitTestImpl::SuppressTestEventsIfInSubprocess() {
2567    if (internal_run_death_test_flag_.get() != NULL)
2568      listeners()->SuppressEventForwarding();
2569  }
2570  #endif  
2571  void UnitTestImpl::ConfigureXmlOutput() {
2572    const std::string& output_format = UnitTestOptions::GetOutputFormat();
2573    if (output_format == "xml") {
2574      listeners()->SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(
2575          UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
2576    } else if (output_format != "") {
2577      printf("WARNING: unrecognized output format \"%s\" ignored.\n",
2578             output_format.c_str());
2579      fflush(stdout);
2580    }
2581  }
2582  #if GTEST_CAN_STREAM_RESULTS_
2583  void UnitTestImpl::ConfigureStreamingOutput() {
2584    const std::string& target = GTEST_FLAG(stream_result_to);
2585    if (!target.empty()) {
2586      const size_t pos = target.find(':');
2587      if (pos != std::string::npos) {
2588        listeners()->Append(new StreamingListener(target.substr(0, pos),
2589                                                  target.substr(pos+1)));
2590      } else {
2591        printf("WARNING: unrecognized streaming target \"%s\" ignored.\n",
2592               target.c_str());
2593        fflush(stdout);
2594      }
2595    }
2596  }
2597  #endif  
2598  void UnitTestImpl::PostFlagParsingInit() {
2599    if (!post_flag_parse_init_performed_) {
2600      post_flag_parse_init_performed_ = true;
2601  #if GTEST_HAS_DEATH_TEST
2602      InitDeathTestSubprocessControlInfo();
2603      SuppressTestEventsIfInSubprocess();
2604  #endif  
2605      RegisterParameterizedTests();
2606      ConfigureXmlOutput();
2607  #if GTEST_CAN_STREAM_RESULTS_
2608      ConfigureStreamingOutput();
2609  #endif  
2610    }
2611  }
2612  class TestCaseNameIs {
2613   public:
2614    explicit TestCaseNameIs(const std::string& name)
2615        : name_(name) {}
2616    bool operator()(const TestCase* test_case) const {
2617      return test_case != NULL && strcmp(test_case->name(), name_.c_str()) == 0;
2618    }
2619   private:
2620    std::string name_;
2621  };
2622  TestCase* UnitTestImpl::GetTestCase(const char* test_case_name,
2623                                      const char* type_param,
2624                                      Test::SetUpTestCaseFunc set_up_tc,
2625                                      Test::TearDownTestCaseFunc tear_down_tc) {
2626    const std::vector<TestCase*>::const_iterator test_case =
2627        std::find_if(test_cases_.begin(), test_cases_.end(),
2628                     TestCaseNameIs(test_case_name));
2629    if (test_case != test_cases_.end())
2630      return *test_case;
2631    TestCase* const new_test_case =
2632        new TestCase(test_case_name, type_param, set_up_tc, tear_down_tc);
2633    if (internal::UnitTestOptions::MatchesFilter(test_case_name,
2634                                                 kDeathTestCaseFilter)) {
2635      ++last_death_test_case_;
2636      test_cases_.insert(test_cases_.begin() + last_death_test_case_,
2637                         new_test_case);
2638    } else {
2639      test_cases_.push_back(new_test_case);
2640    }
<span onclick='openModal()' class='match'>2641    test_case_indices_.push_back(static_cast<int>(test_case_indices_.size()));
2642    return new_test_case;
</span>2643  }
2644  static void SetUpEnvironment(Environment* env) { env->SetUp(); }
2645  static void TearDownEnvironment(Environment* env) { env->TearDown(); }
2646  bool UnitTestImpl::RunAllTests() {
2647    if (!GTestIsInitialized()) {
2648      printf("%s",
2649             "\nThis test program did NOT call ::testing::InitGoogleTest "
2650             "before calling RUN_ALL_TESTS().  Please fix it.\n");
2651      return false;
2652    }
2653    if (g_help_flag)
2654      return true;
2655    PostFlagParsingInit();
2656    internal::WriteToShardStatusFileIfNeeded();
2657    bool in_subprocess_for_death_test = false;
2658  #if GTEST_HAS_DEATH_TEST
2659    in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);
2660  #endif  
2661    const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,
2662                                          in_subprocess_for_death_test);
2663    const bool has_tests_to_run = FilterTests(should_shard
2664                                                ? HONOR_SHARDING_PROTOCOL
2665                                                : IGNORE_SHARDING_PROTOCOL) > 0;
2666    if (GTEST_FLAG(list_tests)) {
2667      ListTestsMatchingFilter();
2668      return true;
2669    }
2670    random_seed_ = GTEST_FLAG(shuffle) ?
2671        GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;
2672    bool failed = false;
2673    TestEventListener* repeater = listeners()->repeater();
2674    start_timestamp_ = GetTimeInMillis();
2675    repeater->OnTestProgramStart(*parent_);
2676    const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);
2677    const bool forever = repeat < 0;
2678    for (int i = 0; forever || i != repeat; i++) {
2679      ClearNonAdHocTestResult();
2680      const TimeInMillis start = GetTimeInMillis();
2681      if (has_tests_to_run && GTEST_FLAG(shuffle)) {
2682        random()->Reseed(random_seed_);
2683        ShuffleTests();
2684      }
2685      repeater->OnTestIterationStart(*parent_, i);
2686      if (has_tests_to_run) {
2687        repeater->OnEnvironmentsSetUpStart(*parent_);
2688        ForEach(environments_, SetUpEnvironment);
2689        repeater->OnEnvironmentsSetUpEnd(*parent_);
2690        if (!Test::HasFatalFailure()) {
2691          for (int test_index = 0; test_index < total_test_case_count();
2692               test_index++) {
2693            GetMutableTestCase(test_index)->Run();
2694          }
2695        }
2696        repeater->OnEnvironmentsTearDownStart(*parent_);
2697        std::for_each(environments_.rbegin(), environments_.rend(),
2698                      TearDownEnvironment);
2699        repeater->OnEnvironmentsTearDownEnd(*parent_);
2700      }
2701      elapsed_time_ = GetTimeInMillis() - start;
2702      repeater->OnTestIterationEnd(*parent_, i);
2703      if (!Passed()) {
2704        failed = true;
2705      }
2706      UnshuffleTests();
2707      if (GTEST_FLAG(shuffle)) {
2708        random_seed_ = GetNextRandomSeed(random_seed_);
2709      }
2710    }
2711    repeater->OnTestProgramEnd(*parent_);
2712    return !failed;
2713  }
2714  void WriteToShardStatusFileIfNeeded() {
2715    const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);
2716    if (test_shard_file != NULL) {
2717      FILE* const file = posix::FOpen(test_shard_file, "w");
2718      if (file == NULL) {
2719        ColoredPrintf(COLOR_RED,
2720                      "Could not write to the test shard status file \"%s\" "
2721                      "specified by the %s environment variable.\n",
2722                      test_shard_file, kTestShardStatusFile);
2723        fflush(stdout);
2724        exit(EXIT_FAILURE);
2725      }
2726      fclose(file);
2727    }
2728  }
2729  bool ShouldShard(const char* total_shards_env,
2730                   const char* shard_index_env,
2731                   bool in_subprocess_for_death_test) {
2732    if (in_subprocess_for_death_test) {
2733      return false;
2734    }
2735    const Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);
2736    const Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);
2737    if (total_shards == -1 && shard_index == -1) {
2738      return false;
2739    } else if (total_shards == -1 && shard_index != -1) {
2740      const Message msg = Message()
2741        << "Invalid environment variables: you have "
2742        << kTestShardIndex << " = " << shard_index
2743        << ", but have left " << kTestTotalShards << " unset.\n";
2744      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2745      fflush(stdout);
2746      exit(EXIT_FAILURE);
2747    } else if (total_shards != -1 && shard_index == -1) {
2748      const Message msg = Message()
2749        << "Invalid environment variables: you have "
2750        << kTestTotalShards << " = " << total_shards
2751        << ", but have left " << kTestShardIndex << " unset.\n";
2752      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2753      fflush(stdout);
2754      exit(EXIT_FAILURE);
2755    } else if (shard_index < 0 || shard_index >= total_shards) {
2756      const Message msg = Message()
2757        << "Invalid environment variables: we require 0 <= "
2758        << kTestShardIndex << " < " << kTestTotalShards
2759        << ", but you have " << kTestShardIndex << "=" << shard_index
2760        << ", " << kTestTotalShards << "=" << total_shards << ".\n";
2761      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2762      fflush(stdout);
2763      exit(EXIT_FAILURE);
2764    }
2765    return total_shards > 1;
2766  }
2767  Int32 Int32FromEnvOrDie(const char* var, Int32 default_val) {
2768    const char* str_val = posix::GetEnv(var);
2769    if (str_val == NULL) {
2770      return default_val;
2771    }
2772    Int32 result;
2773    if (!ParseInt32(Message() << "The value of environment variable " << var,
2774                    str_val, &result)) {
2775      exit(EXIT_FAILURE);
2776    }
2777    return result;
2778  }
2779  bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {
2780    return (test_id % total_shards) == shard_index;
2781  }
2782  int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
2783    const Int32 total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?
2784        Int32FromEnvOrDie(kTestTotalShards, -1) : -1;
2785    const Int32 shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?
2786        Int32FromEnvOrDie(kTestShardIndex, -1) : -1;
2787    int num_runnable_tests = 0;
2788    int num_selected_tests = 0;
2789    for (size_t i = 0; i < test_cases_.size(); i++) {
2790      TestCase* const test_case = test_cases_[i];
2791      const std::string &test_case_name = test_case->name();
2792      test_case->set_should_run(false);
2793      for (size_t j = 0; j < test_case->test_info_list().size(); j++) {
2794        TestInfo* const test_info = test_case->test_info_list()[j];
2795        const std::string test_name(test_info->name());
2796        const bool is_disabled =
2797            internal::UnitTestOptions::MatchesFilter(test_case_name,
2798                                                     kDisableTestFilter) ||
2799            internal::UnitTestOptions::MatchesFilter(test_name,
2800                                                     kDisableTestFilter);
2801        test_info->is_disabled_ = is_disabled;
2802        const bool matches_filter =
2803            internal::UnitTestOptions::FilterMatchesTest(test_case_name,
2804                                                         test_name);
2805        test_info->matches_filter_ = matches_filter;
2806        const bool is_runnable =
2807            (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&
2808            matches_filter;
2809        const bool is_selected = is_runnable &&
2810            (shard_tests == IGNORE_SHARDING_PROTOCOL ||
2811             ShouldRunTestOnShard(total_shards, shard_index,
2812                                  num_runnable_tests));
2813        num_runnable_tests += is_runnable;
2814        num_selected_tests += is_selected;
2815        test_info->should_run_ = is_selected;
2816        test_case->set_should_run(test_case->should_run() || is_selected);
2817      }
2818    }
2819    return num_selected_tests;
2820  }
2821  static void PrintOnOneLine(const char* str, int max_length) {
2822    if (str != NULL) {
2823      for (int i = 0; *str != '\0'; ++str) {
2824        if (i >= max_length) {
2825          printf("...");
2826          break;
2827        }
2828        if (*str == '\n') {
2829          printf("\\n");
2830          i += 2;
2831        } else {
2832          printf("%c", *str);
2833          ++i;
2834        }
2835      }
2836    }
2837  }
2838  void UnitTestImpl::ListTestsMatchingFilter() {
2839    const int kMaxParamLength = 250;
2840    for (size_t i = 0; i < test_cases_.size(); i++) {
2841      const TestCase* const test_case = test_cases_[i];
2842      bool printed_test_case_name = false;
2843      for (size_t j = 0; j < test_case->test_info_list().size(); j++) {
2844        const TestInfo* const test_info =
2845            test_case->test_info_list()[j];
2846        if (test_info->matches_filter_) {
2847          if (!printed_test_case_name) {
2848            printed_test_case_name = true;
2849            printf("%s.", test_case->name());
2850            if (test_case->type_param() != NULL) {
2851              printf("  # %s = ", kTypeParamLabel);
2852              PrintOnOneLine(test_case->type_param(), kMaxParamLength);
2853            }
2854            printf("\n");
2855          }
2856          printf("  %s", test_info->name());
2857          if (test_info->value_param() != NULL) {
2858            printf("  # %s = ", kValueParamLabel);
2859            PrintOnOneLine(test_info->value_param(), kMaxParamLength);
2860          }
2861          printf("\n");
2862        }
2863      }
2864    }
2865    fflush(stdout);
2866  }
2867  void UnitTestImpl::set_os_stack_trace_getter(
2868      OsStackTraceGetterInterface* getter) {
2869    if (os_stack_trace_getter_ != getter) {
2870      delete os_stack_trace_getter_;
2871      os_stack_trace_getter_ = getter;
2872    }
2873  }
2874  OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
2875    if (os_stack_trace_getter_ == NULL) {
2876      os_stack_trace_getter_ = new OsStackTraceGetter;
2877    }
2878    return os_stack_trace_getter_;
2879  }
2880  TestResult* UnitTestImpl::current_test_result() {
2881    return current_test_info_ ?
2882        &(current_test_info_->result_) : &ad_hoc_test_result_;
2883  }
2884  void UnitTestImpl::ShuffleTests() {
2885    ShuffleRange(random(), 0, last_death_test_case_ + 1, &test_case_indices_);
2886    ShuffleRange(random(), last_death_test_case_ + 1,
2887                 static_cast<int>(test_cases_.size()), &test_case_indices_);
2888    for (size_t i = 0; i < test_cases_.size(); i++) {
2889      test_cases_[i]->ShuffleTests(random());
2890    }
2891  }
2892  void UnitTestImpl::UnshuffleTests() {
2893    for (size_t i = 0; i < test_cases_.size(); i++) {
2894      test_cases_[i]->UnshuffleTests();
2895      test_case_indices_[i] = static_cast<int>(i);
2896    }
2897  }
2898  std::string GetCurrentOsStackTraceExceptTop(UnitTest* &bsol;*unit_test*/,
2899                                              int skip_count) {
2900    return GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);
2901  }
2902  namespace {
2903  class ClassUniqueToAlwaysTrue {};
2904  }
2905  bool IsTrue(bool condition) { return condition; }
2906  bool AlwaysTrue() {
2907  #if GTEST_HAS_EXCEPTIONS
2908    if (IsTrue(false))
2909      throw ClassUniqueToAlwaysTrue();
2910  #endif  
2911    return true;
2912  }
2913  bool SkipPrefix(const char* prefix, const char** pstr) {
2914    const size_t prefix_len = strlen(prefix);
2915    if (strncmp(*pstr, prefix, prefix_len) == 0) {
2916      *pstr += prefix_len;
2917      return true;
2918    }
2919    return false;
2920  }
2921  const char* ParseFlagValue(const char* str,
2922                             const char* flag,
2923                             bool def_optional) {
2924    if (str == NULL || flag == NULL) return NULL;
2925    const std::string flag_str = std::string("--") + GTEST_FLAG_PREFIX_ + flag;
2926    const size_t flag_len = flag_str.length();
2927    if (strncmp(str, flag_str.c_str(), flag_len) != 0) return NULL;
2928    const char* flag_end = str + flag_len;
2929    if (def_optional && (flag_end[0] == '\0')) {
2930      return flag_end;
2931    }
2932    if (flag_end[0] != '=') return NULL;
2933    return flag_end + 1;
2934  }
2935  bool ParseBoolFlag(const char* str, const char* flag, bool* value) {
2936    const char* const value_str = ParseFlagValue(str, flag, true);
2937    if (value_str == NULL) return false;
2938    *value = !(*value_str == '0' || *value_str == 'f' || *value_str == 'F');
2939    return true;
2940  }
2941  bool ParseInt32Flag(const char* str, const char* flag, Int32* value) {
2942    const char* const value_str = ParseFlagValue(str, flag, false);
2943    if (value_str == NULL) return false;
2944    return ParseInt32(Message() << "The value of flag --" << flag,
2945                      value_str, value);
2946  }
2947  bool ParseStringFlag(const char* str, const char* flag, std::string* value) {
2948    const char* const value_str = ParseFlagValue(str, flag, false);
2949    if (value_str == NULL) return false;
2950    *value = value_str;
2951    return true;
2952  }
2953  static bool HasGoogleTestFlagPrefix(const char* str) {
2954    return (SkipPrefix("--", &str) ||
2955            SkipPrefix("-", &str) ||
2956            SkipPrefix("/", &str)) &&
2957           !SkipPrefix(GTEST_FLAG_PREFIX_ "internal_", &str) &&
2958           (SkipPrefix(GTEST_FLAG_PREFIX_, &str) ||
2959            SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &str));
2960  }
2961  static void PrintColorEncoded(const char* str) {
2962    GTestColor color = COLOR_DEFAULT;  
2963    for (;;) {
2964      const char* p = strchr(str, '@');
2965      if (p == NULL) {
2966        ColoredPrintf(color, "%s", str);
2967        return;
2968      }
2969      ColoredPrintf(color, "%s", std::string(str, p).c_str());
2970      const char ch = p[1];
2971      str = p + 2;
2972      if (ch == '@') {
2973        ColoredPrintf(color, "@");
2974      } else if (ch == 'D') {
2975        color = COLOR_DEFAULT;
2976      } else if (ch == 'R') {
2977        color = COLOR_RED;
2978      } else if (ch == 'G') {
2979        color = COLOR_GREEN;
2980      } else if (ch == 'Y') {
2981        color = COLOR_YELLOW;
2982      } else {
2983        --str;
2984      }
2985    }
2986  }
2987  static const char kColorEncodedHelpMessage[] =
2988  "This program contains tests written using " GTEST_NAME_ ". You can use the\n"
2989  "following command line flags to control its behavior:\n"
2990  "\n"
2991  "Test Selection:\n"
2992  "  @G--" GTEST_FLAG_PREFIX_ "list_tests@D\n"
2993  "      List the names of all tests instead of running them. The name of\n"
2994  "      TEST(Foo, Bar) is \"Foo.Bar\".\n"
2995  "  @G--" GTEST_FLAG_PREFIX_ "filter=@YPOSTIVE_PATTERNS"
2996      "[@G-@YNEGATIVE_PATTERNS]@D\n"
2997  "      Run only the tests whose name matches one of the positive patterns but\n"
2998  "      none of the negative patterns. '?' matches any single character; '*'\n"
2999  "      matches any substring; ':' separates two patterns.\n"
3000  "  @G--" GTEST_FLAG_PREFIX_ "also_run_disabled_tests@D\n"
3001  "      Run all disabled tests too.\n"
3002  "\n"
3003  "Test Execution:\n"
3004  "  @G--" GTEST_FLAG_PREFIX_ "repeat=@Y[COUNT]@D\n"
3005  "      Run the tests repeatedly; use a negative count to repeat forever.\n"
3006  "  @G--" GTEST_FLAG_PREFIX_ "shuffle@D\n"
3007  "      Randomize tests' orders on every iteration.\n"
3008  "  @G--" GTEST_FLAG_PREFIX_ "random_seed=@Y[NUMBER]@D\n"
3009  "      Random number seed to use for shuffling test orders (between 1 and\n"
3010  "      99999, or 0 to use a seed based on the current time).\n"
3011  "\n"
3012  "Test Output:\n"
3013  "  @G--" GTEST_FLAG_PREFIX_ "color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n"
3014  "      Enable/disable colored output. The default is @Gauto@D.\n"
3015  "  -@G-" GTEST_FLAG_PREFIX_ "print_time=0@D\n"
3016  "      Don't print the elapsed time of each test.\n"
3017  "  @G--" GTEST_FLAG_PREFIX_ "output=xml@Y[@G:@YDIRECTORY_PATH@G"
3018      GTEST_PATH_SEP_ "@Y|@G:@YFILE_PATH]@D\n"
3019  "      Generate an XML report in the given directory or with the given file\n"
3020  "      name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n"
3021  #if GTEST_CAN_STREAM_RESULTS_
3022  "  @G--" GTEST_FLAG_PREFIX_ "stream_result_to=@YHOST@G:@YPORT@D\n"
3023  "      Stream test results to the given server.\n"
3024  #endif  
3025  "\n"
3026  "Assertion Behavior:\n"
3027  #if GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS
3028  "  @G--" GTEST_FLAG_PREFIX_ "death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n"
3029  "      Set the default death test style.\n"
3030  #endif  
3031  "  @G--" GTEST_FLAG_PREFIX_ "break_on_failure@D\n"
3032  "      Turn assertion failures into debugger break-points.\n"
3033  "  @G--" GTEST_FLAG_PREFIX_ "throw_on_failure@D\n"
3034  "      Turn assertion failures into C++ exceptions.\n"
3035  "  @G--" GTEST_FLAG_PREFIX_ "catch_exceptions=0@D\n"
3036  "      Do not report exceptions as test failures. Instead, allow them\n"
3037  "      to crash the program or throw a pop-up (on Windows).\n"
3038  "\n"
3039  "Except for @G--" GTEST_FLAG_PREFIX_ "list_tests@D, you can alternatively set "
3040      "the corresponding\n"
3041  "environment variable of a flag (all letters in upper-case). For example, to\n"
3042  "disable colored text output, you can either specify @G--" GTEST_FLAG_PREFIX_
3043      "color=no@D or set\n"
3044  "the @G" GTEST_FLAG_PREFIX_UPPER_ "COLOR@D environment variable to @Gno@D.\n"
3045  "\n"
3046  "For more information, please read the " GTEST_NAME_ " documentation at\n"
3047  "@G" GTEST_PROJECT_URL_ "@D. If you find a bug in " GTEST_NAME_ "\n"
3048  "(not one in your own code or tests), please report it to\n"
3049  "@G<" GTEST_DEV_EMAIL_ ">@D.\n";
3050  template <typename CharType>
3051  void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
3052    for (int i = 1; i < *argc; i++) {
3053      const std::string arg_string = StreamableToString(argv[i]);
3054      const char* const arg = arg_string.c_str();
3055      using internal::ParseBoolFlag;
3056      using internal::ParseInt32Flag;
3057      using internal::ParseStringFlag;
3058      if (ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,
3059                        &GTEST_FLAG(also_run_disabled_tests)) ||
3060          ParseBoolFlag(arg, kBreakOnFailureFlag,
3061                        &GTEST_FLAG(break_on_failure)) ||
3062          ParseBoolFlag(arg, kCatchExceptionsFlag,
3063                        &GTEST_FLAG(catch_exceptions)) ||
3064          ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||
3065          ParseStringFlag(arg, kDeathTestStyleFlag,
3066                          &GTEST_FLAG(death_test_style)) ||
3067          ParseBoolFlag(arg, kDeathTestUseFork,
3068                        &GTEST_FLAG(death_test_use_fork)) ||
3069          ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||
3070          ParseStringFlag(arg, kInternalRunDeathTestFlag,
3071                          &GTEST_FLAG(internal_run_death_test)) ||
3072          ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||
3073          ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||
3074          ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||
3075          ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||
3076          ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||
3077          ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||
3078          ParseInt32Flag(arg, kStackTraceDepthFlag,
3079                         &GTEST_FLAG(stack_trace_depth)) ||
3080          ParseStringFlag(arg, kStreamResultToFlag,
3081                          &GTEST_FLAG(stream_result_to)) ||
3082          ParseBoolFlag(arg, kThrowOnFailureFlag,
3083                        &GTEST_FLAG(throw_on_failure))
3084          ) {
3085        for (int j = i; j != *argc; j++) {
3086          argv[j] = argv[j + 1];
3087        }
3088        (*argc)--;
3089        i--;
3090      } else if (arg_string == "--help" || arg_string == "-h" ||
3091                 arg_string == "-?" || arg_string == "/?" ||
3092                 HasGoogleTestFlagPrefix(arg)) {
3093        g_help_flag = true;
3094      }
3095    }
3096    if (g_help_flag) {
3097      PrintColorEncoded(kColorEncodedHelpMessage);
3098    }
3099  }
3100  void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
3101    ParseGoogleTestFlagsOnlyImpl(argc, argv);
3102  }
3103  void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
3104    ParseGoogleTestFlagsOnlyImpl(argc, argv);
3105  }
3106  template <typename CharType>
3107  void InitGoogleTestImpl(int* argc, CharType** argv) {
3108    g_init_gtest_count++;
3109    if (g_init_gtest_count != 1) return;
3110    if (*argc <= 0) return;
3111    internal::g_executable_path = internal::StreamableToString(argv[0]);
3112  #if GTEST_HAS_DEATH_TEST
3113    g_argvs.clear();
3114    for (int i = 0; i != *argc; i++) {
3115      g_argvs.push_back(StreamableToString(argv[i]));
3116    }
3117  #endif  
3118    ParseGoogleTestFlagsOnly(argc, argv);
3119    GetUnitTestImpl()->PostFlagParsingInit();
3120  }
3121  }  
3122  void InitGoogleTest(int* argc, char** argv) {
3123    internal::InitGoogleTestImpl(argc, argv);
3124  }
3125  void InitGoogleTest(int* argc, wchar_t** argv) {
3126    internal::InitGoogleTestImpl(argc, argv);
3127  }
3128  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest.cc</h3>
            <pre><code>1  #include "gtest/gtest.h"
2  #include "gtest/gtest-spi.h"
3  #include <ctype.h>
4  #include <math.h>
5  #include <stdarg.h>
6  #include <stdio.h>
7  #include <stdlib.h>
8  #include <time.h>
9  #include <wchar.h>
10  #include <wctype.h>
11  #include <algorithm>
12  #include <iomanip>
13  #include <limits>
14  #include <ostream>  
15  #include <sstream>
16  #include <vector>
17  #if GTEST_OS_LINUX
18  # define GTEST_HAS_GETTIMEOFDAY_ 1
19  # include <fcntl.h>  
20  # include <limits.h>  
21  # include <sched.h>  
22  # include <strings.h>  
23  # include <sys/mman.h>  
24  # include <sys/time.h>  
25  # include <unistd.h>  
26  # include <string>
27  #elif GTEST_OS_SYMBIAN
28  # define GTEST_HAS_GETTIMEOFDAY_ 1
29  # include <sys/time.h>  
30  #elif GTEST_OS_ZOS
31  # define GTEST_HAS_GETTIMEOFDAY_ 1
32  # include <sys/time.h>  
33  # include <strings.h>  
34  #elif GTEST_OS_WINDOWS_MOBILE  
35  # include <windows.h>  
36  #elif GTEST_OS_WINDOWS  
37  # include <io.h>  
38  # include <sys/timeb.h>  
39  # include <sys/types.h>  
40  # include <sys/stat.h>  
41  # if GTEST_OS_WINDOWS_MINGW
42  #  define GTEST_HAS_GETTIMEOFDAY_ 1
43  #  include <sys/time.h>  
44  # endif  
45  # include <windows.h>  
46  #else
47  # define GTEST_HAS_GETTIMEOFDAY_ 1
48  # include <sys/time.h>  
49  # include <unistd.h>  
50  #endif  
51  #if GTEST_HAS_EXCEPTIONS
52  # include <stdexcept>
53  #endif
54  #if GTEST_CAN_STREAM_RESULTS_
55  # include <arpa/inet.h>  
56  # include <netdb.h>  
57  #endif
58  #define GTEST_IMPLEMENTATION_ 1
59  #include "src/gtest-internal-inl.h"
60  #undef GTEST_IMPLEMENTATION_
61  #if GTEST_OS_WINDOWS
62  # define vsnprintf _vsnprintf
63  #endif  
64  namespace testing {
65  using internal::CountIf;
66  using internal::ForEach;
67  using internal::GetElementOr;
68  using internal::Shuffle;
69  static const char kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*";
70  static const char kDeathTestCaseFilter[] = "*DeathTest:*DeathTest&bsol;*";
71  static const char kUniversalFilter[] = "*";
72  static const char kDefaultOutputFile[] = "test_detail.xml";
73  static const char kTestShardIndex[] = "GTEST_SHARD_INDEX";
74  static const char kTestTotalShards[] = "GTEST_TOTAL_SHARDS";
75  static const char kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE";
76  namespace internal {
77  const char kStackTraceMarker[] = "\nStack trace:\n";
78  bool g_help_flag = false;
79  }  
80  static const char* GetDefaultFilter() {
81    return kUniversalFilter;
82  }
83  GTEST_DEFINE_bool_(
84      also_run_disabled_tests,
85      internal::BoolFromGTestEnv("also_run_disabled_tests", false),
86      "Run disabled tests too, in addition to the tests normally being run.");
87  GTEST_DEFINE_bool_(
88      break_on_failure,
89      internal::BoolFromGTestEnv("break_on_failure", false),
90      "True iff a failed assertion should be a debugger break-point.");
91  GTEST_DEFINE_bool_(
92      catch_exceptions,
93      internal::BoolFromGTestEnv("catch_exceptions", true),
94      "True iff " GTEST_NAME_
95      " should catch exceptions and treat them as test failures.");
96  GTEST_DEFINE_string_(
97      color,
98      internal::StringFromGTestEnv("color", "auto"),
99      "Whether to use colors in the output.  Valid values: yes, no, "
100      "and auto.  'auto' means to use colors if the output is "
101      "being sent to a terminal and the TERM environment variable "
102      "is set to a terminal type that supports colors.");
103  GTEST_DEFINE_string_(
104      filter,
105      internal::StringFromGTestEnv("filter", GetDefaultFilter()),
106      "A colon-separated list of glob (not regex) patterns "
107      "for filtering the tests to run, optionally followed by a "
108      "'-' and a : separated list of negative patterns (tests to "
109      "exclude).  A test is run if it matches one of the positive "
110      "patterns and does not match any of the negative patterns.");
111  GTEST_DEFINE_bool_(list_tests, false,
112                     "List all tests without running them.");
113  GTEST_DEFINE_string_(
114      output,
115      internal::StringFromGTestEnv("output", ""),
116      "A format (currently must be \"xml\"), optionally followed "
117      "by a colon and an output file name or directory. A directory "
118      "is indicated by a trailing pathname separator. "
119      "Examples: \"xml:filename.xml\", \"xml::directoryname/\". "
120      "If a directory is specified, output files will be created "
121      "within that directory, with file-names based on the test "
122      "executable's name and, if necessary, made unique by adding "
123      "digits.");
124  GTEST_DEFINE_bool_(
125      print_time,
126      internal::BoolFromGTestEnv("print_time", true),
127      "True iff " GTEST_NAME_
128      " should display elapsed time in text output.");
129  GTEST_DEFINE_int32_(
130      random_seed,
131      internal::Int32FromGTestEnv("random_seed", 0),
132      "Random number seed to use when shuffling test orders.  Must be in range "
133      "[1, 99999], or 0 to use a seed based on the current time.");
134  GTEST_DEFINE_int32_(
135      repeat,
136      internal::Int32FromGTestEnv("repeat", 1),
137      "How many times to repeat each test.  Specify a negative number "
138      "for repeating forever.  Useful for shaking out flaky tests.");
139  GTEST_DEFINE_bool_(
140      show_internal_stack_frames, false,
141      "True iff " GTEST_NAME_ " should include internal stack frames when "
142      "printing test failure stack traces.");
143  GTEST_DEFINE_bool_(
144      shuffle,
145      internal::BoolFromGTestEnv("shuffle", false),
146      "True iff " GTEST_NAME_
147      " should randomize tests' order on every run.");
148  GTEST_DEFINE_int32_(
149      stack_trace_depth,
150      internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth),
151      "The maximum number of stack frames to print when an "
152      "assertion fails.  The valid range is 0 through 100, inclusive.");
153  GTEST_DEFINE_string_(
154      stream_result_to,
155      internal::StringFromGTestEnv("stream_result_to", ""),
156      "This flag specifies the host name and the port number on which to stream "
157      "test results. Example: \"localhost:555\". The flag is effective only on "
158      "Linux.");
159  GTEST_DEFINE_bool_(
160      throw_on_failure,
161      internal::BoolFromGTestEnv("throw_on_failure", false),
162      "When this flag is specified, a failed assertion will throw an exception "
163      "if exceptions are enabled or exit the program with a non-zero code "
164      "otherwise.");
165  namespace internal {
166  UInt32 Random::Generate(UInt32 range) {
167    state_ = (1103515245U*state_ + 12345U) % kMaxRange;
168    GTEST_CHECK_(range > 0)
169        << "Cannot generate a number in the range [0, 0).";
170    GTEST_CHECK_(range <= kMaxRange)
171        << "Generation of a number in [0, " << range << ") was requested, "
172        << "but this can only generate numbers in [0, " << kMaxRange << ").";
173    return state_ % range;
174  }
175  GTEST_API_ int g_init_gtest_count = 0;
176  static bool GTestIsInitialized() { return g_init_gtest_count != 0; }
177  static int SumOverTestCaseList(const std::vector<TestCase*>& case_list,
178                                 int (TestCase::*method)() const) {
179    int sum = 0;
180    for (size_t i = 0; i < case_list.size(); i++) {
181      sum += (case_list[i]->*method)();
182    }
183    return sum;
184  }
185  static bool TestCasePassed(const TestCase* test_case) {
186    return test_case->should_run() && test_case->Passed();
187  }
188  static bool TestCaseFailed(const TestCase* test_case) {
189    return test_case->should_run() && test_case->Failed();
190  }
191  static bool ShouldRunTestCase(const TestCase* test_case) {
192    return test_case->should_run();
193  }
194  AssertHelper::AssertHelper(TestPartResult::Type type,
195                             const char* file,
196                             int line,
197                             const char* message)
198      : data_(new AssertHelperData(type, file, line, message)) {
199  }
200  AssertHelper::~AssertHelper() {
201    delete data_;
202  }
203  void AssertHelper::operator=(const Message& message) const {
204    UnitTest::GetInstance()->
205      AddTestPartResult(data_->type, data_->file, data_->line,
206                        AppendUserMessage(data_->message, message),
207                        UnitTest::GetInstance()->impl()
208                        ->CurrentOsStackTraceExceptTop(1)
209                        );  
210  }
211  GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_linked_ptr_mutex);
212  std::string g_executable_path;
213  FilePath GetCurrentExecutableName() {
214    FilePath result;
215  #if GTEST_OS_WINDOWS
216    result.Set(FilePath(g_executable_path).RemoveExtension("exe"));
217  #else
218    result.Set(FilePath(g_executable_path));
219  #endif  
220    return result.RemoveDirectoryName();
221  }
222  std::string UnitTestOptions::GetOutputFormat() {
223    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
224    if (gtest_output_flag == NULL) return std::string("");
225    const char* const colon = strchr(gtest_output_flag, ':');
226    return (colon == NULL) ?
227        std::string(gtest_output_flag) :
228        std::string(gtest_output_flag, colon - gtest_output_flag);
229  }
230  std::string UnitTestOptions::GetAbsolutePathToOutputFile() {
231    const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
232    if (gtest_output_flag == NULL)
233      return "";
234    const char* const colon = strchr(gtest_output_flag, ':');
235    if (colon == NULL)
236      return internal::FilePath::ConcatPaths(
237          internal::FilePath(
238              UnitTest::GetInstance()->original_working_dir()),
239          internal::FilePath(kDefaultOutputFile)).string();
240    internal::FilePath output_name(colon + 1);
241    if (!output_name.IsAbsolutePath())
242      output_name = internal::FilePath::ConcatPaths(
243          internal::FilePath(UnitTest::GetInstance()->original_working_dir()),
244          internal::FilePath(colon + 1));
245    if (!output_name.IsDirectory())
246      return output_name.string();
247    internal::FilePath result(internal::FilePath::GenerateUniqueFileName(
248        output_name, internal::GetCurrentExecutableName(),
249        GetOutputFormat().c_str()));
250    return result.string();
251  }
252  bool UnitTestOptions::PatternMatchesString(const char *pattern,
253                                             const char *str) {
254    switch (*pattern) {
255      case '\0':
256      case ':':  
257        return *str == '\0';
258      case '?':  
259        return *str != '\0' && PatternMatchesString(pattern + 1, str + 1);
260      case '*':  
261        return (*str != '\0' && PatternMatchesString(pattern, str + 1)) ||
262            PatternMatchesString(pattern + 1, str);
263      default:  
264        return *pattern == *str &&
265            PatternMatchesString(pattern + 1, str + 1);
266    }
267  }
268  bool UnitTestOptions::MatchesFilter(
269      const std::string& name, const char* filter) {
270    const char *cur_pattern = filter;
271    for (;;) {
272      if (PatternMatchesString(cur_pattern, name.c_str())) {
273        return true;
274      }
275      cur_pattern = strchr(cur_pattern, ':');
276      if (cur_pattern == NULL) {
277        return false;
278      }
279      cur_pattern++;
280    }
281  }
282  bool UnitTestOptions::FilterMatchesTest(const std::string &test_case_name,
283                                          const std::string &test_name) {
284    const std::string& full_name = test_case_name + "." + test_name.c_str();
285    const char* const p = GTEST_FLAG(filter).c_str();
286    const char* const dash = strchr(p, '-');
287    std::string positive;
288    std::string negative;
289    if (dash == NULL) {
290      positive = GTEST_FLAG(filter).c_str();  
291      negative = "";
292    } else {
293      positive = std::string(p, dash);   
294      negative = std::string(dash + 1);  
295      if (positive.empty()) {
296        positive = kUniversalFilter;
297      }
298    }
299    return (MatchesFilter(full_name, positive.c_str()) &&
300            !MatchesFilter(full_name, negative.c_str()));
301  }
302  #if GTEST_HAS_SEH
303  int UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {
304    const DWORD kCxxExceptionCode = 0xe06d7363;
305    bool should_handle = true;
306    if (!GTEST_FLAG(catch_exceptions))
307      should_handle = false;
308    else if (exception_code == EXCEPTION_BREAKPOINT)
309      should_handle = false;
310    else if (exception_code == kCxxExceptionCode)
311      should_handle = false;
312    return should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
313  }
314  #endif  
315  }  
316  ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
317      TestPartResultArray* result)
318      : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),
319        result_(result) {
320    Init();
321  }
322  ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
323      InterceptMode intercept_mode, TestPartResultArray* result)
324      : intercept_mode_(intercept_mode),
325        result_(result) {
326    Init();
327  }
328  void ScopedFakeTestPartResultReporter::Init() {
329    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
330    if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
331      old_reporter_ = impl->GetGlobalTestPartResultReporter();
332      impl->SetGlobalTestPartResultReporter(this);
333    } else {
334      old_reporter_ = impl->GetTestPartResultReporterForCurrentThread();
335      impl->SetTestPartResultReporterForCurrentThread(this);
336    }
337  }
338  ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
339    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
340    if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
341      impl->SetGlobalTestPartResultReporter(old_reporter_);
342    } else {
343      impl->SetTestPartResultReporterForCurrentThread(old_reporter_);
344    }
345  }
346  void ScopedFakeTestPartResultReporter::ReportTestPartResult(
347      const TestPartResult& result) {
348    result_->Append(result);
349  }
350  namespace internal {
351  TypeId GetTestTypeId() {
352    return GetTypeId<Test>();
353  }
354  extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();
355  AssertionResult HasOneFailure(const char* &bsol;* results_expr */,
356                                const char* &bsol;* type_expr */,
357                                const char* &bsol;* substr_expr */,
358                                const TestPartResultArray& results,
359                                TestPartResult::Type type,
360                                const string& substr) {
361    const std::string expected(type == TestPartResult::kFatalFailure ?
362                          "1 fatal failure" :
363                          "1 non-fatal failure");
364    Message msg;
365    if (results.size() != 1) {
366      msg << "Expected: " << expected << "\n"
367          << "  Actual: " << results.size() << " failures";
368      for (int i = 0; i < results.size(); i++) {
369        msg << "\n" << results.GetTestPartResult(i);
370      }
371      return AssertionFailure() << msg;
372    }
373    const TestPartResult& r = results.GetTestPartResult(0);
374    if (r.type() != type) {
375      return AssertionFailure() << "Expected: " << expected << "\n"
376                                << "  Actual:\n"
377                                << r;
378    }
379    if (strstr(r.message(), substr.c_str()) == NULL) {
380      return AssertionFailure() << "Expected: " << expected << " containing \""
381                                << substr << "\"\n"
382                                << "  Actual:\n"
383                                << r;
384    }
385    return AssertionSuccess();
386  }
387  SingleFailureChecker:: SingleFailureChecker(
388      const TestPartResultArray* results,
389      TestPartResult::Type type,
390      const string& substr)
391      : results_(results),
392        type_(type),
393        substr_(substr) {}
394  SingleFailureChecker::~SingleFailureChecker() {
395    EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);
396  }
397  DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(
398      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
399  void DefaultGlobalTestPartResultReporter::ReportTestPartResult(
400      const TestPartResult& result) {
401    unit_test_->current_test_result()->AddTestPartResult(result);
402    unit_test_->listeners()->repeater()->OnTestPartResult(result);
403  }
404  DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(
405      UnitTestImpl* unit_test) : unit_test_(unit_test) {}
406  void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(
407      const TestPartResult& result) {
408    unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);
409  }
410  TestPartResultReporterInterface*
411  UnitTestImpl::GetGlobalTestPartResultReporter() {
412    internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
413    return global_test_part_result_repoter_;
414  }
415  void UnitTestImpl::SetGlobalTestPartResultReporter(
416      TestPartResultReporterInterface* reporter) {
417    internal::MutexLock lock(&global_test_part_result_reporter_mutex_);
418    global_test_part_result_repoter_ = reporter;
419  }
420  TestPartResultReporterInterface*
421  UnitTestImpl::GetTestPartResultReporterForCurrentThread() {
422    return per_thread_test_part_result_reporter_.get();
423  }
424  void UnitTestImpl::SetTestPartResultReporterForCurrentThread(
425      TestPartResultReporterInterface* reporter) {
426    per_thread_test_part_result_reporter_.set(reporter);
427  }
428  int UnitTestImpl::successful_test_case_count() const {
429    return CountIf(test_cases_, TestCasePassed);
430  }
431  int UnitTestImpl::failed_test_case_count() const {
432    return CountIf(test_cases_, TestCaseFailed);
433  }
434  int UnitTestImpl::total_test_case_count() const {
435    return static_cast<int>(test_cases_.size());
436  }
437  int UnitTestImpl::test_case_to_run_count() const {
438    return CountIf(test_cases_, ShouldRunTestCase);
439  }
440  int UnitTestImpl::successful_test_count() const {
441    return SumOverTestCaseList(test_cases_, &TestCase::successful_test_count);
442  }
443  int UnitTestImpl::failed_test_count() const {
444    return SumOverTestCaseList(test_cases_, &TestCase::failed_test_count);
445  }
446  int UnitTestImpl::reportable_disabled_test_count() const {
447    return SumOverTestCaseList(test_cases_,
448                               &TestCase::reportable_disabled_test_count);
449  }
450  int UnitTestImpl::disabled_test_count() const {
451    return SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count);
452  }
453  int UnitTestImpl::reportable_test_count() const {
454    return SumOverTestCaseList(test_cases_, &TestCase::reportable_test_count);
455  }
456  int UnitTestImpl::total_test_count() const {
457    return SumOverTestCaseList(test_cases_, &TestCase::total_test_count);
458  }
459  int UnitTestImpl::test_to_run_count() const {
460    return SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count);
461  }
462  std::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {
463    (void)skip_count;
464    return "";
465  }
466  TimeInMillis GetTimeInMillis() {
467  #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)
468    const TimeInMillis kJavaEpochToWinFileTimeDelta =
469      static_cast<TimeInMillis>(116444736UL) * 100000UL;
470    const DWORD kTenthMicrosInMilliSecond = 10000;
471    SYSTEMTIME now_systime;
472    FILETIME now_filetime;
473    ULARGE_INTEGER now_int64;
474    GetSystemTime(&now_systime);
475    if (SystemTimeToFileTime(&now_systime, &now_filetime)) {
476      now_int64.LowPart = now_filetime.dwLowDateTime;
477      now_int64.HighPart = now_filetime.dwHighDateTime;
478      now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -
479        kJavaEpochToWinFileTimeDelta;
480      return now_int64.QuadPart;
481    }
482    return 0;
483  #elif GTEST_OS_WINDOWS && !GTEST_HAS_GETTIMEOFDAY_
484    __timeb64 now;
485  # ifdef _MSC_VER
486  #  pragma warning(push)          
487  #  pragma warning(disable:4996)  
488    _ftime64(&now);
489  #  pragma warning(pop)           
490  # else
491    _ftime64(&now);
492  # endif  
493    return static_cast<TimeInMillis>(now.time) * 1000 + now.millitm;
494  #elif GTEST_HAS_GETTIMEOFDAY_
495    struct timeval now;
496    gettimeofday(&now, NULL);
497    return static_cast<TimeInMillis>(now.tv_sec) * 1000 + now.tv_usec / 1000;
498  #else
499  # error "Don't know how to get the current time on your system."
500  #endif
501  }
502  #if GTEST_OS_WINDOWS_MOBILE
503  LPCWSTR String::AnsiToUtf16(const char* ansi) {
504    if (!ansi) return NULL;
505    const int length = strlen(ansi);
506    const int unicode_length =
507        MultiByteToWideChar(CP_ACP, 0, ansi, length,
508                            NULL, 0);
509    WCHAR* unicode = new WCHAR[unicode_length + 1];
510    MultiByteToWideChar(CP_ACP, 0, ansi, length,
511                        unicode, unicode_length);
512    unicode[unicode_length] = 0;
513    return unicode;
514  }
515  const char* String::Utf16ToAnsi(LPCWSTR utf16_str)  {
516    if (!utf16_str) return NULL;
517    const int ansi_length =
518        WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
519                            NULL, 0, NULL, NULL);
520    char* ansi = new char[ansi_length + 1];
521    WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,
522                        ansi, ansi_length, NULL, NULL);
523    ansi[ansi_length] = 0;
524    return ansi;
525  }
526  #endif  
527  bool String::CStringEquals(const char * lhs, const char * rhs) {
528    if ( lhs == NULL ) return rhs == NULL;
529    if ( rhs == NULL ) return false;
530    return strcmp(lhs, rhs) == 0;
531  }
532  #if GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING
533  static void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,
534                                       Message* msg) {
535    for (size_t i = 0; i != length; ) {  
536      if (wstr[i] != L'\0') {
537        *msg << WideStringToUtf8(wstr + i, static_cast<int>(length - i));
538        while (i != length && wstr[i] != L'\0')
539          i++;
540      } else {
541        *msg << '\0';
542        i++;
543      }
544    }
545  }
546  #endif  
547  }  
548  Message::Message() : ss_(new ::std::stringstream) {
549    *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
550  }
551  Message& Message::operator <<(const wchar_t* wide_c_str) {
552    return *this << internal::String::ShowWideCString(wide_c_str);
553  }
554  Message& Message::operator <<(wchar_t* wide_c_str) {
555    return *this << internal::String::ShowWideCString(wide_c_str);
556  }
557  #if GTEST_HAS_STD_WSTRING
558  Message& Message::operator <<(const ::std::wstring& wstr) {
559    internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
560    return *this;
561  }
562  #endif  
563  #if GTEST_HAS_GLOBAL_WSTRING
564  Message& Message::operator <<(const ::wstring& wstr) {
565    internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
566    return *this;
567  }
568  #endif  
569  std::string Message::GetString() const {
570    return internal::StringStreamToString(ss_.get());
571  }
572  AssertionResult::AssertionResult(const AssertionResult& other)
573      : success_(other.success_),
574        message_(other.message_.get() != NULL ?
575                 new ::std::string(*other.message_) :
576                 static_cast< ::std::string*>(NULL)) {
577  }
578  AssertionResult AssertionResult::operator!() const {
579    AssertionResult negation(!success_);
580    if (message_.get() != NULL)
581      negation << *message_;
582    return negation;
583  }
584  AssertionResult AssertionSuccess() {
585    return AssertionResult(true);
586  }
587  AssertionResult AssertionFailure() {
588    return AssertionResult(false);
589  }
590  AssertionResult AssertionFailure(const Message& message) {
591    return AssertionFailure() << message;
592  }
593  namespace internal {
594  AssertionResult EqFailure(const char* expected_expression,
595                            const char* actual_expression,
596                            const std::string& expected_value,
597                            const std::string& actual_value,
598                            bool ignoring_case) {
599    Message msg;
600    msg << "Value of: " << actual_expression;
601    if (actual_value != actual_expression) {
602      msg << "\n  Actual: " << actual_value;
603    }
604    msg << "\nExpected: " << expected_expression;
605    if (ignoring_case) {
606      msg << " (ignoring case)";
607    }
608    if (expected_value != expected_expression) {
609      msg << "\nWhich is: " << expected_value;
610    }
611    return AssertionFailure() << msg;
612  }
613  std::string GetBoolAssertionFailureMessage(
614      const AssertionResult& assertion_result,
615      const char* expression_text,
616      const char* actual_predicate_value,
617      const char* expected_predicate_value) {
618    const char* actual_message = assertion_result.message();
619    Message msg;
620    msg << "Value of: " << expression_text
621        << "\n  Actual: " << actual_predicate_value;
622    if (actual_message[0] != '\0')
623      msg << " (" << actual_message << ")";
624    msg << "\nExpected: " << expected_predicate_value;
625    return msg.GetString();
626  }
627  AssertionResult DoubleNearPredFormat(const char* expr1,
628                                       const char* expr2,
629                                       const char* abs_error_expr,
630                                       double val1,
631                                       double val2,
632                                       double abs_error) {
633    const double diff = fabs(val1 - val2);
634    if (diff <= abs_error) return AssertionSuccess();
635    return AssertionFailure()
636        << "The difference between " << expr1 << " and " << expr2
637        << " is " << diff << ", which exceeds " << abs_error_expr << ", where\n"
638        << expr1 << " evaluates to " << val1 << ",\n"
639        << expr2 << " evaluates to " << val2 << ", and\n"
640        << abs_error_expr << " evaluates to " << abs_error << ".";
641  }
642  template <typename RawType>
643  AssertionResult FloatingPointLE(const char* expr1,
644                                  const char* expr2,
645                                  RawType val1,
646                                  RawType val2) {
647    if (val1 < val2) {
648      return AssertionSuccess();
649    }
650    const FloatingPoint<RawType> lhs(val1), rhs(val2);
651    if (lhs.AlmostEquals(rhs)) {
652      return AssertionSuccess();
653    }
654    ::std::stringstream val1_ss;
655    val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
656            << val1;
657    ::std::stringstream val2_ss;
658    val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
659            << val2;
660    return AssertionFailure()
661        << "Expected: (" << expr1 << ") <= (" << expr2 << ")\n"
662        << "  Actual: " << StringStreamToString(&val1_ss) << " vs "
663        << StringStreamToString(&val2_ss);
664  }
665  }  
666  AssertionResult FloatLE(const char* expr1, const char* expr2,
667                          float val1, float val2) {
668    return internal::FloatingPointLE<float>(expr1, expr2, val1, val2);
669  }
670  AssertionResult DoubleLE(const char* expr1, const char* expr2,
671                           double val1, double val2) {
672    return internal::FloatingPointLE<double>(expr1, expr2, val1, val2);
673  }
674  namespace internal {
675  AssertionResult CmpHelperEQ(const char* expected_expression,
676                              const char* actual_expression,
677                              BiggestInt expected,
678                              BiggestInt actual) {
679    if (expected == actual) {
680      return AssertionSuccess();
681    }
682    return EqFailure(expected_expression,
683                     actual_expression,
684                     FormatForComparisonFailureMessage(expected, actual),
685                     FormatForComparisonFailureMessage(actual, expected),
686                     false);
687  }
688  #define GTEST_IMPL_CMP_HELPER_(op_name, op)\
689  AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \
690                                     BiggestInt val1, BiggestInt val2) {\
691    if (val1 op val2) {\
692      return AssertionSuccess();\
693    } else {\
694      return AssertionFailure() \
695          << "Expected: (" << expr1 << ") " #op " (" << expr2\
696          << "), actual: " << FormatForComparisonFailureMessage(val1, val2)\
697          << " vs " << FormatForComparisonFailureMessage(val2, val1);\
698    }\
699  }
700  GTEST_IMPL_CMP_HELPER_(NE, !=)
701  GTEST_IMPL_CMP_HELPER_(LE, <=)
702  GTEST_IMPL_CMP_HELPER_(LT, < )
703  GTEST_IMPL_CMP_HELPER_(GE, >=)
704  GTEST_IMPL_CMP_HELPER_(GT, > )
705  #undef GTEST_IMPL_CMP_HELPER_
706  AssertionResult CmpHelperSTREQ(const char* expected_expression,
707                                 const char* actual_expression,
708                                 const char* expected,
709                                 const char* actual) {
710    if (String::CStringEquals(expected, actual)) {
711      return AssertionSuccess();
712    }
713    return EqFailure(expected_expression,
714                     actual_expression,
715                     PrintToString(expected),
716                     PrintToString(actual),
717                     false);
718  }
719  AssertionResult CmpHelperSTRCASEEQ(const char* expected_expression,
720                                     const char* actual_expression,
721                                     const char* expected,
722                                     const char* actual) {
723    if (String::CaseInsensitiveCStringEquals(expected, actual)) {
724      return AssertionSuccess();
725    }
726    return EqFailure(expected_expression,
727                     actual_expression,
728                     PrintToString(expected),
729                     PrintToString(actual),
730                     true);
731  }
732  AssertionResult CmpHelperSTRNE(const char* s1_expression,
733                                 const char* s2_expression,
734                                 const char* s1,
735                                 const char* s2) {
736    if (!String::CStringEquals(s1, s2)) {
737      return AssertionSuccess();
738    } else {
739      return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
740                                << s2_expression << "), actual: \""
741                                << s1 << "\" vs \"" << s2 << "\"";
742    }
743  }
744  AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
745                                     const char* s2_expression,
746                                     const char* s1,
747                                     const char* s2) {
748    if (!String::CaseInsensitiveCStringEquals(s1, s2)) {
749      return AssertionSuccess();
750    } else {
751      return AssertionFailure()
752          << "Expected: (" << s1_expression << ") != ("
753          << s2_expression << ") (ignoring case), actual: \""
754          << s1 << "\" vs \"" << s2 << "\"";
755    }
756  }
757  }  
758  namespace {
759  bool IsSubstringPred(const char* needle, const char* haystack) {
760    if (needle == NULL || haystack == NULL)
761      return needle == haystack;
762    return strstr(haystack, needle) != NULL;
763  }
764  bool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {
765    if (needle == NULL || haystack == NULL)
766      return needle == haystack;
767    return wcsstr(haystack, needle) != NULL;
768  }
769  template <typename StringType>
770  bool IsSubstringPred(const StringType& needle,
771                       const StringType& haystack) {
772    return haystack.find(needle) != StringType::npos;
773  }
774  template <typename StringType>
775  AssertionResult IsSubstringImpl(
776      bool expected_to_be_substring,
777      const char* needle_expr, const char* haystack_expr,
778      const StringType& needle, const StringType& haystack) {
779    if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
780      return AssertionSuccess();
781    const bool is_wide_string = sizeof(needle[0]) > 1;
782    const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
783    return AssertionFailure()
784        << "Value of: " << needle_expr << "\n"
785        << "  Actual: " << begin_string_quote << needle << "\"\n"
786        << "Expected: " << (expected_to_be_substring ? "" : "not ")
787        << "a substring of " << haystack_expr << "\n"
788        << "Which is: " << begin_string_quote << haystack << "\"";
789  }
790  }  
791  AssertionResult IsSubstring(
792      const char* needle_expr, const char* haystack_expr,
793      const char* needle, const char* haystack) {
794    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
795  }
796  AssertionResult IsSubstring(
797      const char* needle_expr, const char* haystack_expr,
798      const wchar_t* needle, const wchar_t* haystack) {
799    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
800  }
801  AssertionResult IsNotSubstring(
802      const char* needle_expr, const char* haystack_expr,
803      const char* needle, const char* haystack) {
804    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
805  }
806  AssertionResult IsNotSubstring(
807      const char* needle_expr, const char* haystack_expr,
808      const wchar_t* needle, const wchar_t* haystack) {
809    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
810  }
811  AssertionResult IsSubstring(
812      const char* needle_expr, const char* haystack_expr,
813      const ::std::string& needle, const ::std::string& haystack) {
814    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
815  }
816  AssertionResult IsNotSubstring(
817      const char* needle_expr, const char* haystack_expr,
818      const ::std::string& needle, const ::std::string& haystack) {
819    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
820  }
821  #if GTEST_HAS_STD_WSTRING
822  AssertionResult IsSubstring(
823      const char* needle_expr, const char* haystack_expr,
824      const ::std::wstring& needle, const ::std::wstring& haystack) {
825    return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
826  }
827  AssertionResult IsNotSubstring(
828      const char* needle_expr, const char* haystack_expr,
829      const ::std::wstring& needle, const ::std::wstring& haystack) {
830    return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
831  }
832  #endif  
833  namespace internal {
834  #if GTEST_OS_WINDOWS
835  namespace {
836  AssertionResult HRESULTFailureHelper(const char* expr,
837                                       const char* expected,
838                                       long hr) {  
839  # if GTEST_OS_WINDOWS_MOBILE
840    const char error_text[] = "";
841  # else
842    const DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |
843                         FORMAT_MESSAGE_IGNORE_INSERTS;
844    const DWORD kBufSize = 4096;
845    char error_text[kBufSize] = { '\0' };
846    DWORD message_length = ::FormatMessageA(kFlags,
847                                            0,  
848                                            hr,  
849                                            0,  
850                                            error_text,  
851                                            kBufSize,  
852                                            NULL);  
853    for (; message_length && IsSpace(error_text[message_length - 1]);
854            --message_length) {
855      error_text[message_length - 1] = '\0';
856    }
857  # endif  
858    const std::string error_hex("0x" + String::FormatHexInt(hr));
859    return ::testing::AssertionFailure()
860        << "Expected: " << expr << " " << expected << ".\n"
861        << "  Actual: " << error_hex << " " << error_text << "\n";
862  }
863  }  
864  AssertionResult IsHRESULTSuccess(const char* expr, long hr) {  
865    if (SUCCEEDED(hr)) {
866      return AssertionSuccess();
867    }
868    return HRESULTFailureHelper(expr, "succeeds", hr);
869  }
870  AssertionResult IsHRESULTFailure(const char* expr, long hr) {  
871    if (FAILED(hr)) {
872      return AssertionSuccess();
873    }
874    return HRESULTFailureHelper(expr, "fails", hr);
875  }
876  #endif  
877  const UInt32 kMaxCodePoint1 = (static_cast<UInt32>(1) <<  7) - 1;
878  const UInt32 kMaxCodePoint2 = (static_cast<UInt32>(1) << (5 + 6)) - 1;
879  const UInt32 kMaxCodePoint3 = (static_cast<UInt32>(1) << (4 + 2*6)) - 1;
880  const UInt32 kMaxCodePoint4 = (static_cast<UInt32>(1) << (3 + 3*6)) - 1;
881  inline UInt32 ChopLowBits(UInt32* bits, int n) {
882    const UInt32 low_bits = *bits & ((static_cast<UInt32>(1) << n) - 1);
883    *bits >>= n;
884    return low_bits;
885  }
886  std::string CodePointToUtf8(UInt32 code_point) {
887    if (code_point > kMaxCodePoint4) {
888      return "(Invalid Unicode 0x" + String::FormatHexInt(code_point) + ")";
889    }
890    char str[5];  
891    if (code_point <= kMaxCodePoint1) {
892      str[1] = '\0';
893      str[0] = static_cast<char>(code_point);                          
894    } else if (code_point <= kMaxCodePoint2) {
895      str[2] = '\0';
896      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
897      str[0] = static_cast<char>(0xC0 | code_point);                   
898    } else if (code_point <= kMaxCodePoint3) {
899      str[3] = '\0';
900      str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
901      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
902      str[0] = static_cast<char>(0xE0 | code_point);                   
903    } else {  
904      str[4] = '\0';
905      str[3] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
906      str[2] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
907      str[1] = static_cast<char>(0x80 | ChopLowBits(&code_point, 6));  
908      str[0] = static_cast<char>(0xF0 | code_point);                   
909    }
910    return str;
911  }
912  inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {
913    return sizeof(wchar_t) == 2 &&
914        (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;
915  }
916  inline UInt32 CreateCodePointFromUtf16SurrogatePair(wchar_t first,
917                                                      wchar_t second) {
918    const UInt32 mask = (1 << 10) - 1;
919    return (sizeof(wchar_t) == 2) ?
920        (((first & mask) << 10) | (second & mask)) + 0x10000 :
921        static_cast<UInt32>(first);
922  }
923  std::string WideStringToUtf8(const wchar_t* str, int num_chars) {
924    if (num_chars == -1)
925      num_chars = static_cast<int>(wcslen(str));
926    ::std::stringstream stream;
927    for (int i = 0; i < num_chars; ++i) {
928      UInt32 unicode_code_point;
929      if (str[i] == L'\0') {
930        break;
931      } else if (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) {
932        unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],
933                                                                   str[i + 1]);
934        i++;
935      } else {
936        unicode_code_point = static_cast<UInt32>(str[i]);
937      }
938      stream << CodePointToUtf8(unicode_code_point);
939    }
940    return StringStreamToString(&stream);
941  }
942  std::string String::ShowWideCString(const wchar_t * wide_c_str) {
943    if (wide_c_str == NULL)  return "(null)";
944    return internal::WideStringToUtf8(wide_c_str, -1);
945  }
946  bool String::WideCStringEquals(const wchar_t * lhs, const wchar_t * rhs) {
947    if (lhs == NULL) return rhs == NULL;
948    if (rhs == NULL) return false;
949    return wcscmp(lhs, rhs) == 0;
950  }
951  AssertionResult CmpHelperSTREQ(const char* expected_expression,
952                                 const char* actual_expression,
953                                 const wchar_t* expected,
954                                 const wchar_t* actual) {
955    if (String::WideCStringEquals(expected, actual)) {
956      return AssertionSuccess();
957    }
958    return EqFailure(expected_expression,
959                     actual_expression,
960                     PrintToString(expected),
961                     PrintToString(actual),
962                     false);
963  }
964  AssertionResult CmpHelperSTRNE(const char* s1_expression,
965                                 const char* s2_expression,
966                                 const wchar_t* s1,
967                                 const wchar_t* s2) {
968    if (!String::WideCStringEquals(s1, s2)) {
969      return AssertionSuccess();
970    }
971    return AssertionFailure() << "Expected: (" << s1_expression << ") != ("
972                              << s2_expression << "), actual: "
973                              << PrintToString(s1)
974                              << " vs " << PrintToString(s2);
975  }
976  bool String::CaseInsensitiveCStringEquals(const char * lhs, const char * rhs) {
977    if (lhs == NULL)
978      return rhs == NULL;
979    if (rhs == NULL)
980      return false;
981    return posix::StrCaseCmp(lhs, rhs) == 0;
982  }
983  bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
984                                                const wchar_t* rhs) {
985    if (lhs == NULL) return rhs == NULL;
986    if (rhs == NULL) return false;
987  #if GTEST_OS_WINDOWS
988    return _wcsicmp(lhs, rhs) == 0;
989  #elif GTEST_OS_LINUX && !GTEST_OS_LINUX_ANDROID
990    return wcscasecmp(lhs, rhs) == 0;
991  #else
992    wint_t left, right;
993    do {
994      left = towlower(*lhs++);
995      right = towlower(*rhs++);
996    } while (left && left == right);
997    return left == right;
998  #endif  
999  }
1000  bool String::EndsWithCaseInsensitive(
1001      const std::string& str, const std::string& suffix) {
1002    const size_t str_len = str.length();
1003    const size_t suffix_len = suffix.length();
1004    return (str_len >= suffix_len) &&
1005           CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,
1006                                        suffix.c_str());
1007  }
1008  std::string String::FormatIntWidth2(int value) {
1009    std::stringstream ss;
1010    ss << std::setfill('0') << std::setw(2) << value;
1011    return ss.str();
1012  }
1013  std::string String::FormatHexInt(int value) {
1014    std::stringstream ss;
1015    ss << std::hex << std::uppercase << value;
1016    return ss.str();
1017  }
1018  std::string String::FormatByte(unsigned char value) {
1019    std::stringstream ss;
1020    ss << std::setfill('0') << std::setw(2) << std::hex << std::uppercase
1021       << static_cast<unsigned int>(value);
1022    return ss.str();
1023  }
1024  std::string StringStreamToString(::std::stringstream* ss) {
1025    const ::std::string& str = ss->str();
1026    const char* const start = str.c_str();
1027    const char* const end = start + str.length();
1028    std::string result;
1029    result.reserve(2 * (end - start));
1030    for (const char* ch = start; ch != end; ++ch) {
1031      if (*ch == '\0') {
1032        result += "\\0";  
1033      } else {
1034        result += *ch;
1035      }
1036    }
1037    return result;
1038  }
1039  std::string AppendUserMessage(const std::string& gtest_msg,
1040                                const Message& user_msg) {
1041    const std::string user_msg_string = user_msg.GetString();
1042    if (user_msg_string.empty()) {
1043      return gtest_msg;
1044    }
1045    return gtest_msg + "\n" + user_msg_string;
1046  }
1047  }  
1048  TestResult::TestResult()
1049      : death_test_count_(0),
1050        elapsed_time_(0) {
1051  }
1052  TestResult::~TestResult() {
1053  }
1054  const TestPartResult& TestResult::GetTestPartResult(int i) const {
1055    if (i < 0 || i >= total_part_count())
1056      internal::posix::Abort();
1057    return test_part_results_.at(i);
1058  }
1059  const TestProperty& TestResult::GetTestProperty(int i) const {
1060    if (i < 0 || i >= test_property_count())
1061      internal::posix::Abort();
1062    return test_properties_.at(i);
1063  }
1064  void TestResult::ClearTestPartResults() {
1065    test_part_results_.clear();
1066  }
1067  void TestResult::AddTestPartResult(const TestPartResult& test_part_result) {
1068    test_part_results_.push_back(test_part_result);
1069  }
1070  void TestResult::RecordProperty(const std::string& xml_element,
1071                                  const TestProperty& test_property) {
1072    if (!ValidateTestProperty(xml_element, test_property)) {
1073      return;
1074    }
1075    internal::MutexLock lock(&test_properites_mutex_);
1076    const std::vector<TestProperty>::iterator property_with_matching_key =
1077        std::find_if(test_properties_.begin(), test_properties_.end(),
1078                     internal::TestPropertyKeyIs(test_property.key()));
1079    if (property_with_matching_key == test_properties_.end()) {
1080      test_properties_.push_back(test_property);
1081      return;
1082    }
1083    property_with_matching_key->SetValue(test_property.value());
1084  }
1085  static const char* const kReservedTestSuitesAttributes[] = {
1086    "disabled",
1087    "errors",
1088    "failures",
1089    "name",
1090    "random_seed",
1091    "tests",
1092    "time",
1093    "timestamp"
1094  };
1095  static const char* const kReservedTestSuiteAttributes[] = {
1096    "disabled",
1097    "errors",
1098    "failures",
1099    "name",
1100    "tests",
1101    "time"
1102  };
1103  static const char* const kReservedTestCaseAttributes[] = {
1104    "classname",
1105    "name",
1106    "status",
1107    "time",
1108    "type_param",
1109    "value_param"
1110  };
1111  template <int kSize>
1112  std::vector<std::string> ArrayAsVector(const char* const (&array)[kSize]) {
1113    return std::vector<std::string>(array, array + kSize);
1114  }
1115  static std::vector<std::string> GetReservedAttributesForElement(
1116      const std::string& xml_element) {
1117    if (xml_element == "testsuites") {
1118      return ArrayAsVector(kReservedTestSuitesAttributes);
1119    } else if (xml_element == "testsuite") {
1120      return ArrayAsVector(kReservedTestSuiteAttributes);
1121    } else if (xml_element == "testcase") {
1122      return ArrayAsVector(kReservedTestCaseAttributes);
1123    } else {
1124      GTEST_CHECK_(false) << "Unrecognized xml_element provided: " << xml_element;
1125    }
1126    return std::vector<std::string>();
1127  }
1128  static std::string FormatWordList(const std::vector<std::string>& words) {
1129    Message word_list;
1130    for (size_t i = 0; i < words.size(); ++i) {
1131      if (i > 0 && words.size() > 2) {
1132        word_list << ", ";
1133      }
1134      if (i == words.size() - 1) {
1135        word_list << "and ";
1136      }
1137      word_list << "'" << words[i] << "'";
1138    }
1139    return word_list.GetString();
1140  }
1141  bool ValidateTestPropertyName(const std::string& property_name,
1142                                const std::vector<std::string>& reserved_names) {
1143    if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=
1144            reserved_names.end()) {
1145      ADD_FAILURE() << "Reserved key used in RecordProperty(): " << property_name
1146                    << " (" << FormatWordList(reserved_names)
1147                    << " are reserved by " << GTEST_NAME_ << ")";
1148      return false;
1149    }
1150    return true;
1151  }
1152  bool TestResult::ValidateTestProperty(const std::string& xml_element,
1153                                        const TestProperty& test_property) {
1154    return ValidateTestPropertyName(test_property.key(),
1155                                    GetReservedAttributesForElement(xml_element));
1156  }
1157  void TestResult::Clear() {
1158    test_part_results_.clear();
1159    test_properties_.clear();
1160    death_test_count_ = 0;
1161    elapsed_time_ = 0;
1162  }
1163  bool TestResult::Failed() const {
1164    for (int i = 0; i < total_part_count(); ++i) {
1165      if (GetTestPartResult(i).failed())
1166        return true;
1167    }
1168    return false;
1169  }
1170  static bool TestPartFatallyFailed(const TestPartResult& result) {
1171    return result.fatally_failed();
1172  }
1173  bool TestResult::HasFatalFailure() const {
1174    return CountIf(test_part_results_, TestPartFatallyFailed) > 0;
1175  }
1176  static bool TestPartNonfatallyFailed(const TestPartResult& result) {
1177    return result.nonfatally_failed();
1178  }
1179  bool TestResult::HasNonfatalFailure() const {
1180    return CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;
1181  }
1182  int TestResult::total_part_count() const {
1183    return static_cast<int>(test_part_results_.size());
1184  }
1185  int TestResult::test_property_count() const {
1186    return static_cast<int>(test_properties_.size());
1187  }
1188  Test::Test()
1189      : gtest_flag_saver_(new internal::GTestFlagSaver) {
1190  }
1191  Test::~Test() {
1192    delete gtest_flag_saver_;
1193  }
1194  void Test::SetUp() {
1195  }
1196  void Test::TearDown() {
1197  }
1198  void Test::RecordProperty(const std::string& key, const std::string& value) {
1199    UnitTest::GetInstance()->RecordProperty(key, value);
1200  }
1201  void Test::RecordProperty(const std::string& key, int value) {
1202    Message value_message;
1203    value_message << value;
1204    RecordProperty(key, value_message.GetString().c_str());
1205  }
1206  namespace internal {
1207  void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
1208                                      const std::string& message) {
1209    UnitTest::GetInstance()->AddTestPartResult(
1210        result_type,
1211        NULL,  
1212        -1,    
1213        message,
1214        "");   
1215  }
1216  }  
1217  bool Test::HasSameFixtureClass() {
1218    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1219    const TestCase* const test_case = impl->current_test_case();
1220    const TestInfo* const first_test_info = test_case->test_info_list()[0];
1221    const internal::TypeId first_fixture_id = first_test_info->fixture_class_id_;
1222    const char* const first_test_name = first_test_info->name();
1223    const TestInfo* const this_test_info = impl->current_test_info();
1224    const internal::TypeId this_fixture_id = this_test_info->fixture_class_id_;
1225    const char* const this_test_name = this_test_info->name();
1226    if (this_fixture_id != first_fixture_id) {
1227      const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();
1228      const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();
1229      if (first_is_TEST || this_is_TEST) {
1230        const char* const TEST_name =
1231            first_is_TEST ? first_test_name : this_test_name;
1232        const char* const TEST_F_name =
1233            first_is_TEST ? this_test_name : first_test_name;
1234        ADD_FAILURE()
1235            << "All tests in the same test case must use the same test fixture\n"
1236            << "class, so mixing TEST_F and TEST in the same test case is\n"
1237            << "illegal.  In test case " << this_test_info->test_case_name()
1238            << ",\n"
1239            << "test " << TEST_F_name << " is defined using TEST_F but\n"
1240            << "test " << TEST_name << " is defined using TEST.  You probably\n"
1241            << "want to change the TEST to TEST_F or move it to another test\n"
1242            << "case.";
1243      } else {
1244        ADD_FAILURE()
1245            << "All tests in the same test case must use the same test fixture\n"
1246            << "class.  However, in test case "
1247            << this_test_info->test_case_name() << ",\n"
1248            << "you defined test " << first_test_name
1249            << " and test " << this_test_name << "\n"
1250            << "using two different test fixture classes.  This can happen if\n"
1251            << "the two classes are from different namespaces or translation\n"
1252            << "units and have the same name.  You should probably rename one\n"
1253            << "of the classes to put the tests into different test cases.";
1254      }
1255      return false;
1256    }
1257    return true;
1258  }
1259  #if GTEST_HAS_SEH
1260  static std::string* FormatSehExceptionMessage(DWORD exception_code,
1261                                                const char* location) {
1262    Message message;
1263    message << "SEH exception with code 0x" << std::setbase(16) <<
1264      exception_code << std::setbase(10) << " thrown in " << location << ".";
1265    return new std::string(message.GetString());
1266  }
1267  #endif  
1268  namespace internal {
1269  #if GTEST_HAS_EXCEPTIONS
1270  static std::string FormatCxxExceptionMessage(const char* description,
1271                                               const char* location) {
1272    Message message;
1273    if (description != NULL) {
1274      message << "C++ exception with description \"" << description << "\"";
1275    } else {
1276      message << "Unknown C++ exception";
1277    }
1278    message << " thrown in " << location << ".";
1279    return message.GetString();
1280  }
1281  static std::string PrintTestPartResultToString(
1282      const TestPartResult& test_part_result);
1283  GoogleTestFailureException::GoogleTestFailureException(
1284      const TestPartResult& failure)
1285      : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}
1286  #endif  
1287  template <class T, typename Result>
1288  Result HandleSehExceptionsInMethodIfSupported(
1289      T* object, Result (T::*method)(), const char* location) {
1290  #if GTEST_HAS_SEH
1291    __try {
1292      return (object->*method)();
1293    } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  
1294        GetExceptionCode())) {
1295      std::string* exception_message = FormatSehExceptionMessage(
1296          GetExceptionCode(), location);
1297      internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,
1298                                               *exception_message);
1299      delete exception_message;
1300      return static_cast<Result>(0);
1301    }
1302  #else
1303    (void)location;
1304    return (object->*method)();
1305  #endif  
1306  }
1307  template <class T, typename Result>
1308  Result HandleExceptionsInMethodIfSupported(
1309      T* object, Result (T::*method)(), const char* location) {
1310    if (internal::GetUnitTestImpl()->catch_exceptions()) {
1311  #if GTEST_HAS_EXCEPTIONS
1312      try {
1313        return HandleSehExceptionsInMethodIfSupported(object, method, location);
1314      } catch (const internal::GoogleTestFailureException&) {  
1315        throw;
1316      } catch (const std::exception& e) {  
1317        internal::ReportFailureInUnknownLocation(
1318            TestPartResult::kFatalFailure,
1319            FormatCxxExceptionMessage(e.what(), location));
1320      } catch (...) {  
1321        internal::ReportFailureInUnknownLocation(
1322            TestPartResult::kFatalFailure,
1323            FormatCxxExceptionMessage(NULL, location));
1324      }
1325      return static_cast<Result>(0);
1326  #else
1327      return HandleSehExceptionsInMethodIfSupported(object, method, location);
1328  #endif  
1329    } else {
1330      return (object->*method)();
1331    }
1332  }
1333  }  
1334  void Test::Run() {
1335    if (!HasSameFixtureClass()) return;
1336    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1337    impl->os_stack_trace_getter()->UponLeavingGTest();
1338    internal::HandleExceptionsInMethodIfSupported(this, &Test::SetUp, "SetUp()");
1339    if (!HasFatalFailure()) {
1340      impl->os_stack_trace_getter()->UponLeavingGTest();
1341      internal::HandleExceptionsInMethodIfSupported(
1342          this, &Test::TestBody, "the test body");
1343    }
1344    impl->os_stack_trace_getter()->UponLeavingGTest();
1345    internal::HandleExceptionsInMethodIfSupported(
1346        this, &Test::TearDown, "TearDown()");
1347  }
1348  bool Test::HasFatalFailure() {
1349    return internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();
1350  }
1351  bool Test::HasNonfatalFailure() {
1352    return internal::GetUnitTestImpl()->current_test_result()->
1353        HasNonfatalFailure();
1354  }
1355  TestInfo::TestInfo(const std::string& a_test_case_name,
1356                     const std::string& a_name,
1357                     const char* a_type_param,
1358                     const char* a_value_param,
1359                     internal::TypeId fixture_class_id,
1360                     internal::TestFactoryBase* factory)
1361      : test_case_name_(a_test_case_name),
1362        name_(a_name),
1363        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
1364        value_param_(a_value_param ? new std::string(a_value_param) : NULL),
1365        fixture_class_id_(fixture_class_id),
1366        should_run_(false),
1367        is_disabled_(false),
1368        matches_filter_(false),
1369        factory_(factory),
1370        result_() {}
1371  TestInfo::~TestInfo() { delete factory_; }
1372  namespace internal {
1373  TestInfo* MakeAndRegisterTestInfo(
1374      const char* test_case_name,
1375      const char* name,
1376      const char* type_param,
1377      const char* value_param,
1378      TypeId fixture_class_id,
1379      SetUpTestCaseFunc set_up_tc,
1380      TearDownTestCaseFunc tear_down_tc,
1381      TestFactoryBase* factory) {
1382    TestInfo* const test_info =
1383        new TestInfo(test_case_name, name, type_param, value_param,
1384                     fixture_class_id, factory);
1385    GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);
1386    return test_info;
1387  }
1388  #if GTEST_HAS_PARAM_TEST
1389  void ReportInvalidTestCaseType(const char* test_case_name,
1390                                 const char* file, int line) {
1391    Message errors;
1392    errors
1393        << "Attempted redefinition of test case " << test_case_name << ".\n"
1394        << "All tests in the same test case must use the same test fixture\n"
1395        << "class.  However, in test case " << test_case_name << ", you tried\n"
1396        << "to define a test using a fixture class different from the one\n"
1397        << "used earlier. This can happen if the two fixture classes are\n"
1398        << "from different namespaces and have the same name. You should\n"
1399        << "probably rename one of the classes to put the tests into different\n"
1400        << "test cases.";
1401    fprintf(stderr, "%s %s", FormatFileLocation(file, line).c_str(),
1402            errors.GetString().c_str());
1403  }
1404  #endif  
1405  }  
1406  namespace {
1407  class TestNameIs {
1408   public:
1409    explicit TestNameIs(const char* name)
1410        : name_(name) {}
1411    bool operator()(const TestInfo * test_info) const {
1412      return test_info && test_info->name() == name_;
1413    }
1414   private:
1415    std::string name_;
1416  };
1417  }  
1418  namespace internal {
1419  void UnitTestImpl::RegisterParameterizedTests() {
1420  #if GTEST_HAS_PARAM_TEST
1421    if (!parameterized_tests_registered_) {
1422      parameterized_test_registry_.RegisterTests();
1423      parameterized_tests_registered_ = true;
1424    }
1425  #endif
1426  }
1427  }  
1428  void TestInfo::Run() {
1429    if (!should_run_) return;
1430    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1431    impl->set_current_test_info(this);
1432    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
1433    repeater->OnTestStart(*this);
1434    const TimeInMillis start = internal::GetTimeInMillis();
1435    impl->os_stack_trace_getter()->UponLeavingGTest();
1436    Test* const test = internal::HandleExceptionsInMethodIfSupported(
1437        factory_, &internal::TestFactoryBase::CreateTest,
1438        "the test fixture's constructor");
1439    if ((test != NULL) && !Test::HasFatalFailure()) {
1440      test->Run();
1441    }
1442    impl->os_stack_trace_getter()->UponLeavingGTest();
1443    internal::HandleExceptionsInMethodIfSupported(
1444        test, &Test::DeleteSelf_, "the test fixture's destructor");
1445    result_.set_elapsed_time(internal::GetTimeInMillis() - start);
1446    repeater->OnTestEnd(*this);
1447    impl->set_current_test_info(NULL);
1448  }
1449  int TestCase::successful_test_count() const {
1450    return CountIf(test_info_list_, TestPassed);
1451  }
1452  int TestCase::failed_test_count() const {
1453    return CountIf(test_info_list_, TestFailed);
1454  }
1455  int TestCase::reportable_disabled_test_count() const {
1456    return CountIf(test_info_list_, TestReportableDisabled);
1457  }
1458  int TestCase::disabled_test_count() const {
1459    return CountIf(test_info_list_, TestDisabled);
1460  }
1461  int TestCase::reportable_test_count() const {
1462    return CountIf(test_info_list_, TestReportable);
1463  }
1464  int TestCase::test_to_run_count() const {
1465    return CountIf(test_info_list_, ShouldRunTest);
1466  }
1467  int TestCase::total_test_count() const {
1468    return static_cast<int>(test_info_list_.size());
1469  }
1470  TestCase::TestCase(const char* a_name, const char* a_type_param,
1471                     Test::SetUpTestCaseFunc set_up_tc,
1472                     Test::TearDownTestCaseFunc tear_down_tc)
1473      : name_(a_name),
1474        type_param_(a_type_param ? new std::string(a_type_param) : NULL),
1475        set_up_tc_(set_up_tc),
1476        tear_down_tc_(tear_down_tc),
1477        should_run_(false),
1478        elapsed_time_(0) {
1479  }
1480  TestCase::~TestCase() {
1481    ForEach(test_info_list_, internal::Delete<TestInfo>);
1482  }
1483  const TestInfo* TestCase::GetTestInfo(int i) const {
1484    const int index = GetElementOr(test_indices_, i, -1);
1485    return index < 0 ? NULL : test_info_list_[index];
1486  }
1487  TestInfo* TestCase::GetMutableTestInfo(int i) {
1488    const int index = GetElementOr(test_indices_, i, -1);
1489    return index < 0 ? NULL : test_info_list_[index];
1490  }
1491  void TestCase::AddTestInfo(TestInfo * test_info) {
1492    test_info_list_.push_back(test_info);
<span onclick='openModal()' class='match'>1493    test_indices_.push_back(static_cast<int>(test_indices_.size()));
1494  }
</span>1495  void TestCase::Run() {
1496    if (!should_run_) return;
1497    internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
1498    impl->set_current_test_case(this);
1499    TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();
1500    repeater->OnTestCaseStart(*this);
1501    impl->os_stack_trace_getter()->UponLeavingGTest();
1502    internal::HandleExceptionsInMethodIfSupported(
1503        this, &TestCase::RunSetUpTestCase, "SetUpTestCase()");
1504    const internal::TimeInMillis start = internal::GetTimeInMillis();
1505    for (int i = 0; i < total_test_count(); i++) {
1506      GetMutableTestInfo(i)->Run();
1507    }
1508    elapsed_time_ = internal::GetTimeInMillis() - start;
1509    impl->os_stack_trace_getter()->UponLeavingGTest();
1510    internal::HandleExceptionsInMethodIfSupported(
1511        this, &TestCase::RunTearDownTestCase, "TearDownTestCase()");
1512    repeater->OnTestCaseEnd(*this);
1513    impl->set_current_test_case(NULL);
1514  }
1515  void TestCase::ClearResult() {
1516    ad_hoc_test_result_.Clear();
1517    ForEach(test_info_list_, TestInfo::ClearTestResult);
1518  }
1519  void TestCase::ShuffleTests(internal::Random* random) {
1520    Shuffle(random, &test_indices_);
1521  }
1522  void TestCase::UnshuffleTests() {
1523    for (size_t i = 0; i < test_indices_.size(); i++) {
1524      test_indices_[i] = static_cast<int>(i);
1525    }
1526  }
1527  static std::string FormatCountableNoun(int count,
1528                                         const char * singular_form,
1529                                         const char * plural_form) {
1530    return internal::StreamableToString(count) + " " +
1531        (count == 1 ? singular_form : plural_form);
1532  }
1533  static std::string FormatTestCount(int test_count) {
1534    return FormatCountableNoun(test_count, "test", "tests");
1535  }
1536  static std::string FormatTestCaseCount(int test_case_count) {
1537    return FormatCountableNoun(test_case_count, "test case", "test cases");
1538  }
1539  static const char * TestPartResultTypeToString(TestPartResult::Type type) {
1540    switch (type) {
1541      case TestPartResult::kSuccess:
1542        return "Success";
1543      case TestPartResult::kNonFatalFailure:
1544      case TestPartResult::kFatalFailure:
1545  #ifdef _MSC_VER
1546        return "error: ";
1547  #else
1548        return "Failure\n";
1549  #endif
1550      default:
1551        return "Unknown result type";
1552    }
1553  }
1554  namespace internal {
1555  static std::string PrintTestPartResultToString(
1556      const TestPartResult& test_part_result) {
1557    return (Message()
1558            << internal::FormatFileLocation(test_part_result.file_name(),
1559                                            test_part_result.line_number())
1560            << " " << TestPartResultTypeToString(test_part_result.type())
1561            << test_part_result.message()).GetString();
1562  }
1563  static void PrintTestPartResult(const TestPartResult& test_part_result) {
1564    const std::string& result =
1565        PrintTestPartResultToString(test_part_result);
1566    printf("%s\n", result.c_str());
1567    fflush(stdout);
1568  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1569    ::OutputDebugStringA(result.c_str());
1570    ::OutputDebugStringA("\n");
1571  #endif
1572  }
1573  enum GTestColor {
1574    COLOR_DEFAULT,
1575    COLOR_RED,
1576    COLOR_GREEN,
1577    COLOR_YELLOW
1578  };
1579  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1580  WORD GetColorAttribute(GTestColor color) {
1581    switch (color) {
1582      case COLOR_RED:    return FOREGROUND_RED;
1583      case COLOR_GREEN:  return FOREGROUND_GREEN;
1584      case COLOR_YELLOW: return FOREGROUND_RED | FOREGROUND_GREEN;
1585      default:           return 0;
1586    }
1587  }
1588  #else
1589  const char* GetAnsiColorCode(GTestColor color) {
1590    switch (color) {
1591      case COLOR_RED:     return "1";
1592      case COLOR_GREEN:   return "2";
1593      case COLOR_YELLOW:  return "3";
1594      default:            return NULL;
1595    };
1596  }
1597  #endif  
1598  bool ShouldUseColor(bool stdout_is_tty) {
1599    const char* const gtest_color = GTEST_FLAG(color).c_str();
1600    if (String::CaseInsensitiveCStringEquals(gtest_color, "auto")) {
1601  #if GTEST_OS_WINDOWS
1602      return stdout_is_tty;
1603  #else
1604      const char* const term = posix::GetEnv("TERM");
1605      const bool term_supports_color =
1606          String::CStringEquals(term, "xterm") ||
1607          String::CStringEquals(term, "xterm-color") ||
1608          String::CStringEquals(term, "xterm-256color") ||
1609          String::CStringEquals(term, "screen") ||
1610          String::CStringEquals(term, "screen-256color") ||
1611          String::CStringEquals(term, "linux") ||
1612          String::CStringEquals(term, "cygwin");
1613      return stdout_is_tty && term_supports_color;
1614  #endif  
1615    }
1616    return String::CaseInsensitiveCStringEquals(gtest_color, "yes") ||
1617        String::CaseInsensitiveCStringEquals(gtest_color, "true") ||
1618        String::CaseInsensitiveCStringEquals(gtest_color, "t") ||
1619        String::CStringEquals(gtest_color, "1");
1620  }
1621  void ColoredPrintf(GTestColor color, const char* fmt, ...) {
1622    va_list args;
1623    va_start(args, fmt);
1624  #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || GTEST_OS_IOS
1625    const bool use_color = false;
1626  #else
1627    static const bool in_color_mode =
1628        ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);
1629    const bool use_color = in_color_mode && (color != COLOR_DEFAULT);
1630  #endif  
1631    if (!use_color) {
1632      vprintf(fmt, args);
1633      va_end(args);
1634      return;
1635    }
1636  #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE
1637    const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);
1638    CONSOLE_SCREEN_BUFFER_INFO buffer_info;
1639    GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);
1640    const WORD old_color_attrs = buffer_info.wAttributes;
1641    fflush(stdout);
1642    SetConsoleTextAttribute(stdout_handle,
1643                            GetColorAttribute(color) | FOREGROUND_INTENSITY);
1644    vprintf(fmt, args);
1645    fflush(stdout);
1646    SetConsoleTextAttribute(stdout_handle, old_color_attrs);
1647  #else
1648    printf("\033[0;3%sm", GetAnsiColorCode(color));
1649    vprintf(fmt, args);
1650    printf("\033[m");  
1651  #endif  
1652    va_end(args);
1653  }
1654  static const char kTypeParamLabel[] = "TypeParam";
1655  static const char kValueParamLabel[] = "GetParam()";
1656  void PrintFullTestCommentIfPresent(const TestInfo& test_info) {
1657    const char* const type_param = test_info.type_param();
1658    const char* const value_param = test_info.value_param();
1659    if (type_param != NULL || value_param != NULL) {
1660      printf(", where ");
1661      if (type_param != NULL) {
1662        printf("%s = %s", kTypeParamLabel, type_param);
1663        if (value_param != NULL)
1664          printf(" and ");
1665      }
1666      if (value_param != NULL) {
1667        printf("%s = %s", kValueParamLabel, value_param);
1668      }
1669    }
1670  }
1671  class PrettyUnitTestResultPrinter : public TestEventListener {
1672   public:
1673    PrettyUnitTestResultPrinter() {}
1674    static void PrintTestName(const char * test_case, const char * test) {
1675      printf("%s.%s", test_case, test);
1676    }
1677    virtual void OnTestProgramStart(const UnitTest& &bsol;*unit_test*/) {}
1678    virtual void OnTestIterationStart(const UnitTest& unit_test, int iteration);
1679    virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test);
1680    virtual void OnEnvironmentsSetUpEnd(const UnitTest& &bsol;*unit_test*/) {}
1681    virtual void OnTestCaseStart(const TestCase& test_case);
1682    virtual void OnTestStart(const TestInfo& test_info);
1683    virtual void OnTestPartResult(const TestPartResult& result);
1684    virtual void OnTestEnd(const TestInfo& test_info);
1685    virtual void OnTestCaseEnd(const TestCase& test_case);
1686    virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test);
1687    virtual void OnEnvironmentsTearDownEnd(const UnitTest& &bsol;*unit_test*/) {}
1688    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1689    virtual void OnTestProgramEnd(const UnitTest& &bsol;*unit_test*/) {}
1690   private:
1691    static void PrintFailedTests(const UnitTest& unit_test);
1692  };
1693  void PrettyUnitTestResultPrinter::OnTestIterationStart(
1694      const UnitTest& unit_test, int iteration) {
1695    if (GTEST_FLAG(repeat) != 1)
1696      printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1);
1697    const char* const filter = GTEST_FLAG(filter).c_str();
1698    if (!String::CStringEquals(filter, kUniversalFilter)) {
1699      ColoredPrintf(COLOR_YELLOW,
1700                    "Note: %s filter = %s\n", GTEST_NAME_, filter);
1701    }
1702    if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {
1703      const Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
1704      ColoredPrintf(COLOR_YELLOW,
1705                    "Note: This is test shard %d of %s.\n",
1706                    static_cast<int>(shard_index) + 1,
1707                    internal::posix::GetEnv(kTestTotalShards));
1708    }
1709    if (GTEST_FLAG(shuffle)) {
1710      ColoredPrintf(COLOR_YELLOW,
1711                    "Note: Randomizing tests' orders with a seed of %d .\n",
1712                    unit_test.random_seed());
1713    }
1714    ColoredPrintf(COLOR_GREEN,  "[==========] ");
1715    printf("Running %s from %s.\n",
1716           FormatTestCount(unit_test.test_to_run_count()).c_str(),
1717           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
1718    fflush(stdout);
1719  }
1720  void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
1721      const UnitTest& &bsol;*unit_test*/) {
1722    ColoredPrintf(COLOR_GREEN,  "[----------] ");
1723    printf("Global test environment set-up.\n");
1724    fflush(stdout);
1725  }
1726  void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase& test_case) {
1727    const std::string counts =
1728        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
1729    ColoredPrintf(COLOR_GREEN, "[----------] ");
1730    printf("%s from %s", counts.c_str(), test_case.name());
1731    if (test_case.type_param() == NULL) {
1732      printf("\n");
1733    } else {
1734      printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param());
1735    }
1736    fflush(stdout);
1737  }
1738  void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo& test_info) {
1739    ColoredPrintf(COLOR_GREEN,  "[ RUN      ] ");
1740    PrintTestName(test_info.test_case_name(), test_info.name());
1741    printf("\n");
1742    fflush(stdout);
1743  }
1744  void PrettyUnitTestResultPrinter::OnTestPartResult(
1745      const TestPartResult& result) {
1746    if (result.type() == TestPartResult::kSuccess)
1747      return;
1748    PrintTestPartResult(result);
1749    fflush(stdout);
1750  }
1751  void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo& test_info) {
1752    if (test_info.result()->Passed()) {
1753      ColoredPrintf(COLOR_GREEN, "[       OK ] ");
1754    } else {
1755      ColoredPrintf(COLOR_RED, "[  FAILED  ] ");
1756    }
1757    PrintTestName(test_info.test_case_name(), test_info.name());
1758    if (test_info.result()->Failed())
1759      PrintFullTestCommentIfPresent(test_info);
1760    if (GTEST_FLAG(print_time)) {
1761      printf(" (%s ms)\n", internal::StreamableToString(
1762             test_info.result()->elapsed_time()).c_str());
1763    } else {
1764      printf("\n");
1765    }
1766    fflush(stdout);
1767  }
1768  void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase& test_case) {
1769    if (!GTEST_FLAG(print_time)) return;
1770    const std::string counts =
1771        FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
1772    ColoredPrintf(COLOR_GREEN, "[----------] ");
1773    printf("%s from %s (%s ms total)\n\n",
1774           counts.c_str(), test_case.name(),
1775           internal::StreamableToString(test_case.elapsed_time()).c_str());
1776    fflush(stdout);
1777  }
1778  void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
1779      const UnitTest& &bsol;*unit_test*/) {
1780    ColoredPrintf(COLOR_GREEN,  "[----------] ");
1781    printf("Global test environment tear-down\n");
1782    fflush(stdout);
1783  }
1784  void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest& unit_test) {
1785    const int failed_test_count = unit_test.failed_test_count();
1786    if (failed_test_count == 0) {
1787      return;
1788    }
1789    for (int i = 0; i < unit_test.total_test_case_count(); ++i) {
1790      const TestCase& test_case = *unit_test.GetTestCase(i);
1791      if (!test_case.should_run() || (test_case.failed_test_count() == 0)) {
1792        continue;
1793      }
1794      for (int j = 0; j < test_case.total_test_count(); ++j) {
1795        const TestInfo& test_info = *test_case.GetTestInfo(j);
1796        if (!test_info.should_run() || test_info.result()->Passed()) {
1797          continue;
1798        }
1799        ColoredPrintf(COLOR_RED, "[  FAILED  ] ");
1800        printf("%s.%s", test_case.name(), test_info.name());
1801        PrintFullTestCommentIfPresent(test_info);
1802        printf("\n");
1803      }
1804    }
1805  }
1806  void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
1807                                                       int &bsol;*iteration*/) {
1808    ColoredPrintf(COLOR_GREEN,  "[==========] ");
1809    printf("%s from %s ran.",
1810           FormatTestCount(unit_test.test_to_run_count()).c_str(),
1811           FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());
1812    if (GTEST_FLAG(print_time)) {
1813      printf(" (%s ms total)",
1814             internal::StreamableToString(unit_test.elapsed_time()).c_str());
1815    }
1816    printf("\n");
1817    ColoredPrintf(COLOR_GREEN,  "[  PASSED  ] ");
1818    printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());
1819    int num_failures = unit_test.failed_test_count();
1820    if (!unit_test.Passed()) {
1821      const int failed_test_count = unit_test.failed_test_count();
1822      ColoredPrintf(COLOR_RED,  "[  FAILED  ] ");
1823      printf("%s, listed below:\n", FormatTestCount(failed_test_count).c_str());
1824      PrintFailedTests(unit_test);
1825      printf("\n%2d FAILED %s\n", num_failures,
1826                          num_failures == 1 ? "TEST" : "TESTS");
1827    }
1828    int num_disabled = unit_test.reportable_disabled_test_count();
1829    if (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) {
1830      if (!num_failures) {
1831        printf("\n");  
1832      }
1833      ColoredPrintf(COLOR_YELLOW,
1834                    "  YOU HAVE %d DISABLED %s\n\n",
1835                    num_disabled,
1836                    num_disabled == 1 ? "TEST" : "TESTS");
1837    }
1838    fflush(stdout);
1839  }
1840  class TestEventRepeater : public TestEventListener {
1841   public:
1842    TestEventRepeater() : forwarding_enabled_(true) {}
1843    virtual ~TestEventRepeater();
1844    void Append(TestEventListener *listener);
1845    TestEventListener* Release(TestEventListener* listener);
1846    bool forwarding_enabled() const { return forwarding_enabled_; }
1847    void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }
1848    virtual void OnTestProgramStart(const UnitTest& unit_test);
1849    virtual void OnTestIterationStart(const UnitTest& unit_test, int iteration);
1850    virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test);
1851    virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test);
1852    virtual void OnTestCaseStart(const TestCase& test_case);
1853    virtual void OnTestStart(const TestInfo& test_info);
1854    virtual void OnTestPartResult(const TestPartResult& result);
1855    virtual void OnTestEnd(const TestInfo& test_info);
1856    virtual void OnTestCaseEnd(const TestCase& test_case);
1857    virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test);
1858    virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test);
1859    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1860    virtual void OnTestProgramEnd(const UnitTest& unit_test);
1861   private:
1862    bool forwarding_enabled_;
1863    std::vector<TestEventListener*> listeners_;
1864    GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);
1865  };
1866  TestEventRepeater::~TestEventRepeater() {
1867    ForEach(listeners_, Delete<TestEventListener>);
1868  }
1869  void TestEventRepeater::Append(TestEventListener *listener) {
1870    listeners_.push_back(listener);
1871  }
1872  TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
1873    for (size_t i = 0; i < listeners_.size(); ++i) {
1874      if (listeners_[i] == listener) {
1875        listeners_.erase(listeners_.begin() + i);
1876        return listener;
1877      }
1878    }
1879    return NULL;
1880  }
1881  #define GTEST_REPEATER_METHOD_(Name, Type) \
1882  void TestEventRepeater::Name(const Type& parameter) { \
1883    if (forwarding_enabled_) { \
1884      for (size_t i = 0; i < listeners_.size(); i++) { \
1885        listeners_[i]->Name(parameter); \
1886      } \
1887    } \
1888  }
1889  #define GTEST_REVERSE_REPEATER_METHOD_(Name, Type) \
1890  void TestEventRepeater::Name(const Type& parameter) { \
1891    if (forwarding_enabled_) { \
1892      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) { \
1893        listeners_[i]->Name(parameter); \
1894      } \
1895    } \
1896  }
1897  GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)
1898  GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)
1899  GTEST_REPEATER_METHOD_(OnTestCaseStart, TestCase)
1900  GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)
1901  GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)
1902  GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)
1903  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)
1904  GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)
1905  GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)
1906  GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestCase)
1907  GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)
1908  #undef GTEST_REPEATER_METHOD_
1909  #undef GTEST_REVERSE_REPEATER_METHOD_
1910  void TestEventRepeater::OnTestIterationStart(const UnitTest& unit_test,
1911                                               int iteration) {
1912    if (forwarding_enabled_) {
1913      for (size_t i = 0; i < listeners_.size(); i++) {
1914        listeners_[i]->OnTestIterationStart(unit_test, iteration);
1915      }
1916    }
1917  }
1918  void TestEventRepeater::OnTestIterationEnd(const UnitTest& unit_test,
1919                                             int iteration) {
1920    if (forwarding_enabled_) {
1921      for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) {
1922        listeners_[i]->OnTestIterationEnd(unit_test, iteration);
1923      }
1924    }
1925  }
1926  class XmlUnitTestResultPrinter : public EmptyTestEventListener {
1927   public:
1928    explicit XmlUnitTestResultPrinter(const char* output_file);
1929    virtual void OnTestIterationEnd(const UnitTest& unit_test, int iteration);
1930   private:
1931    static bool IsNormalizableWhitespace(char c) {
1932      return c == 0x9 || c == 0xA || c == 0xD;
1933    }
1934    static bool IsValidXmlCharacter(char c) {
1935      return IsNormalizableWhitespace(c) || c >= 0x20;
1936    }
1937    static std::string EscapeXml(const std::string& str, bool is_attribute);
1938    static std::string RemoveInvalidXmlCharacters(const std::string& str);
1939    static std::string EscapeXmlAttribute(const std::string& str) {
1940      return EscapeXml(str, true);
1941    }
1942    static std::string EscapeXmlText(const char* str) {
1943      return EscapeXml(str, false);
1944    }
1945    static void OutputXmlAttribute(std::ostream* stream,
1946                                   const std::string& element_name,
1947                                   const std::string& name,
1948                                   const std::string& value);
1949    static void OutputXmlCDataSection(::std::ostream* stream, const char* data);
1950    static void OutputXmlTestInfo(::std::ostream* stream,
1951                                  const char* test_case_name,
1952                                  const TestInfo& test_info);
1953    static void PrintXmlTestCase(::std::ostream* stream,
1954                                 const TestCase& test_case);
1955    static void PrintXmlUnitTest(::std::ostream* stream,
1956                                 const UnitTest& unit_test);
1957    static std::string TestPropertiesAsXmlAttributes(const TestResult& result);
1958    const std::string output_file_;
1959    GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter);
1960  };
1961  XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)
1962      : output_file_(output_file) {
1963    if (output_file_.c_str() == NULL || output_file_.empty()) {
1964      fprintf(stderr, "XML output file may not be null\n");
1965      fflush(stderr);
1966      exit(EXIT_FAILURE);
1967    }
1968  }
1969  void XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest& unit_test,
1970                                                    int &bsol;*iteration*/) {
1971    FILE* xmlout = NULL;
1972    FilePath output_file(output_file_);
1973    FilePath output_dir(output_file.RemoveFileName());
1974    if (output_dir.CreateDirectoriesRecursively()) {
1975      xmlout = posix::FOpen(output_file_.c_str(), "w");
1976    }
1977    if (xmlout == NULL) {
1978      fprintf(stderr,
1979              "Unable to open file \"%s\"\n",
1980              output_file_.c_str());
1981      fflush(stderr);
1982      exit(EXIT_FAILURE);
1983    }
1984    std::stringstream stream;
1985    PrintXmlUnitTest(&stream, unit_test);
1986    fprintf(xmlout, "%s", StringStreamToString(&stream).c_str());
1987    fclose(xmlout);
1988  }
1989  std::string XmlUnitTestResultPrinter::EscapeXml(
1990      const std::string& str, bool is_attribute) {
1991    Message m;
1992    for (size_t i = 0; i < str.size(); ++i) {
1993      const char ch = str[i];
1994      switch (ch) {
1995        case '<':
1996          m << "&lt;";
1997          break;
1998        case '>':
1999          m << "&gt;";
2000          break;
2001        case '&':
2002          m << "&amp;";
2003          break;
2004        case '\'':
2005          if (is_attribute)
2006            m << "&apos;";
2007          else
2008            m << '\'';
2009          break;
2010        case '"':
2011          if (is_attribute)
2012            m << "&quot;";
2013          else
2014            m << '"';
2015          break;
2016        default:
2017          if (IsValidXmlCharacter(ch)) {
2018            if (is_attribute && IsNormalizableWhitespace(ch))
2019              m << "&#x" << String::FormatByte(static_cast<unsigned char>(ch))
2020                << ";";
2021            else
2022              m << ch;
2023          }
2024          break;
2025      }
2026    }
2027    return m.GetString();
2028  }
2029  std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(
2030      const std::string& str) {
2031    std::string output;
2032    output.reserve(str.size());
2033    for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)
2034      if (IsValidXmlCharacter(*it))
2035        output.push_back(*it);
2036    return output;
2037  }
2038  std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {
2039    ::std::stringstream ss;
2040    ss << ms/1000.0;
2041    return ss.str();
2042  }
2043  std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {
2044    time_t seconds = static_cast<time_t>(ms / 1000);
2045  #ifdef _MSC_VER
2046  # pragma warning(push)          
2047  # pragma warning(disable:4996)  
2048    const struct tm* const time_struct = localtime(&seconds);  
2049  # pragma warning(pop)           
2050  #else
2051    const struct tm* const time_struct = localtime(&seconds);  
2052  #endif
2053    if (time_struct == NULL)
2054      return "";  
2055    return StreamableToString(time_struct->tm_year + 1900) + "-" +
2056        String::FormatIntWidth2(time_struct->tm_mon + 1) + "-" +
2057        String::FormatIntWidth2(time_struct->tm_mday) + "T" +
2058        String::FormatIntWidth2(time_struct->tm_hour) + ":" +
2059        String::FormatIntWidth2(time_struct->tm_min) + ":" +
2060        String::FormatIntWidth2(time_struct->tm_sec);
2061  }
2062  void XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,
2063                                                       const char* data) {
2064    const char* segment = data;
2065    *stream << "<![CDATA[";
2066    for (;;) {
2067      const char* const next_segment = strstr(segment, "]]>");
2068      if (next_segment != NULL) {
2069        stream->write(
2070            segment, static_cast<std::streamsize>(next_segment - segment));
2071        *stream << "]]>]]&gt;<![CDATA[";
2072        segment = next_segment + strlen("]]>");
2073      } else {
2074        *stream << segment;
2075        break;
2076      }
2077    }
2078    *stream << "]]>";
2079  }
2080  void XmlUnitTestResultPrinter::OutputXmlAttribute(
2081      std::ostream* stream,
2082      const std::string& element_name,
2083      const std::string& name,
2084      const std::string& value) {
2085    const std::vector<std::string>& allowed_names =
2086        GetReservedAttributesForElement(element_name);
2087    GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=
2088                     allowed_names.end())
2089        << "Attribute " << name << " is not allowed for element <" << element_name
2090        << ">.";
2091    *stream << " " << name << "=\"" << EscapeXmlAttribute(value) << "\"";
2092  }
2093  void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
2094                                                   const char* test_case_name,
2095                                                   const TestInfo& test_info) {
2096    const TestResult& result = *test_info.result();
2097    const std::string kTestcase = "testcase";
2098    *stream << "    <testcase";
2099    OutputXmlAttribute(stream, kTestcase, "name", test_info.name());
2100    if (test_info.value_param() != NULL) {
2101      OutputXmlAttribute(stream, kTestcase, "value_param",
2102                         test_info.value_param());
2103    }
2104    if (test_info.type_param() != NULL) {
2105      OutputXmlAttribute(stream, kTestcase, "type_param", test_info.type_param());
2106    }
2107    OutputXmlAttribute(stream, kTestcase, "status",
2108                       test_info.should_run() ? "run" : "notrun");
2109    OutputXmlAttribute(stream, kTestcase, "time",
2110                       FormatTimeInMillisAsSeconds(result.elapsed_time()));
2111    OutputXmlAttribute(stream, kTestcase, "classname", test_case_name);
2112    *stream << TestPropertiesAsXmlAttributes(result);
2113    int failures = 0;
2114    for (int i = 0; i < result.total_part_count(); ++i) {
2115      const TestPartResult& part = result.GetTestPartResult(i);
2116      if (part.failed()) {
2117        if (++failures == 1) {
2118          *stream << ">\n";
2119        }
2120        const string location = internal::FormatCompilerIndependentFileLocation(
2121            part.file_name(), part.line_number());
2122        const string summary = location + "\n" + part.summary();
2123        *stream << "      <failure message=\""
2124                << EscapeXmlAttribute(summary.c_str())
2125                << "\" type=\"\">";
2126        const string detail = location + "\n" + part.message();
2127        OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
2128        *stream << "</failure>\n";
2129      }
2130    }
2131    if (failures == 0)
2132      *stream << " />\n";
2133    else
2134      *stream << "    </testcase>\n";
2135  }
2136  void XmlUnitTestResultPrinter::PrintXmlTestCase(std::ostream* stream,
2137                                                  const TestCase& test_case) {
2138    const std::string kTestsuite = "testsuite";
2139    *stream << "  <" << kTestsuite;
2140    OutputXmlAttribute(stream, kTestsuite, "name", test_case.name());
2141    OutputXmlAttribute(stream, kTestsuite, "tests",
2142                       StreamableToString(test_case.reportable_test_count()));
2143    OutputXmlAttribute(stream, kTestsuite, "failures",
2144                       StreamableToString(test_case.failed_test_count()));
2145    OutputXmlAttribute(
2146        stream, kTestsuite, "disabled",
2147        StreamableToString(test_case.reportable_disabled_test_count()));
2148    OutputXmlAttribute(stream, kTestsuite, "errors", "0");
2149    OutputXmlAttribute(stream, kTestsuite, "time",
2150                       FormatTimeInMillisAsSeconds(test_case.elapsed_time()));
2151    *stream << TestPropertiesAsXmlAttributes(test_case.ad_hoc_test_result())
2152            << ">\n";
2153    for (int i = 0; i < test_case.total_test_count(); ++i) {
2154      if (test_case.GetTestInfo(i)->is_reportable())
2155        OutputXmlTestInfo(stream, test_case.name(), *test_case.GetTestInfo(i));
2156    }
2157    *stream << "  </" << kTestsuite << ">\n";
2158  }
2159  void XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,
2160                                                  const UnitTest& unit_test) {
2161    const std::string kTestsuites = "testsuites";
2162    *stream << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
2163    *stream << "<" << kTestsuites;
2164    OutputXmlAttribute(stream, kTestsuites, "tests",
2165                       StreamableToString(unit_test.reportable_test_count()));
2166    OutputXmlAttribute(stream, kTestsuites, "failures",
2167                       StreamableToString(unit_test.failed_test_count()));
2168    OutputXmlAttribute(
2169        stream, kTestsuites, "disabled",
2170        StreamableToString(unit_test.reportable_disabled_test_count()));
2171    OutputXmlAttribute(stream, kTestsuites, "errors", "0");
2172    OutputXmlAttribute(
2173        stream, kTestsuites, "timestamp",
2174        FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));
2175    OutputXmlAttribute(stream, kTestsuites, "time",
2176                       FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));
2177    if (GTEST_FLAG(shuffle)) {
2178      OutputXmlAttribute(stream, kTestsuites, "random_seed",
2179                         StreamableToString(unit_test.random_seed()));
2180    }
2181    *stream << TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());
2182    OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
2183    *stream << ">\n";
2184    for (int i = 0; i < unit_test.total_test_case_count(); ++i) {
2185      if (unit_test.GetTestCase(i)->reportable_test_count() > 0)
2186        PrintXmlTestCase(stream, *unit_test.GetTestCase(i));
2187    }
2188    *stream << "</" << kTestsuites << ">\n";
2189  }
2190  std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(
2191      const TestResult& result) {
2192    Message attributes;
2193    for (int i = 0; i < result.test_property_count(); ++i) {
2194      const TestProperty& property = result.GetTestProperty(i);
2195      attributes << " " << property.key() << "="
2196          << "\"" << EscapeXmlAttribute(property.value()) << "\"";
2197    }
2198    return attributes.GetString();
2199  }
2200  #if GTEST_CAN_STREAM_RESULTS_
2201  string StreamingListener::UrlEncode(const char* str) {
2202    string result;
2203    result.reserve(strlen(str) + 1);
2204    for (char ch = *str; ch != '\0'; ch = *++str) {
2205      switch (ch) {
2206        case '%':
2207        case '=':
2208        case '&':
2209        case '\n':
2210          result.append("%" + String::FormatByte(static_cast<unsigned char>(ch)));
2211          break;
2212        default:
2213          result.push_back(ch);
2214          break;
2215      }
2216    }
2217    return result;
2218  }
2219  void StreamingListener::SocketWriter::MakeConnection() {
2220    GTEST_CHECK_(sockfd_ == -1)
2221        << "MakeConnection() can't be called when there is already a connection.";
2222    addrinfo hints;
2223    memset(&hints, 0, sizeof(hints));
2224    hints.ai_family = AF_UNSPEC;    
2225    hints.ai_socktype = SOCK_STREAM;
2226    addrinfo* servinfo = NULL;
2227    const int error_num = getaddrinfo(
2228        host_name_.c_str(), port_num_.c_str(), &hints, &servinfo);
2229    if (error_num != 0) {
2230      GTEST_LOG_(WARNING) << "stream_result_to: getaddrinfo() failed: "
2231                          << gai_strerror(error_num);
2232    }
2233    for (addrinfo* cur_addr = servinfo; sockfd_ == -1 && cur_addr != NULL;
2234         cur_addr = cur_addr->ai_next) {
2235      sockfd_ = socket(
2236          cur_addr->ai_family, cur_addr->ai_socktype, cur_addr->ai_protocol);
2237      if (sockfd_ != -1) {
2238        if (connect(sockfd_, cur_addr->ai_addr, cur_addr->ai_addrlen) == -1) {
2239          close(sockfd_);
2240          sockfd_ = -1;
2241        }
2242      }
2243    }
2244    freeaddrinfo(servinfo);  
2245    if (sockfd_ == -1) {
2246      GTEST_LOG_(WARNING) << "stream_result_to: failed to connect to "
2247                          << host_name_ << ":" << port_num_;
2248    }
2249  }
2250  #endif  
2251  ScopedTrace::ScopedTrace(const char* file, int line, const Message& message)
2252      GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
2253    TraceInfo trace;
2254    trace.file = file;
2255    trace.line = line;
2256    trace.message = message.GetString();
2257    UnitTest::GetInstance()->PushGTestTrace(trace);
2258  }
2259  ScopedTrace::~ScopedTrace()
2260      GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
2261    UnitTest::GetInstance()->PopGTestTrace();
2262  }
2263  string OsStackTraceGetter::CurrentStackTrace(int &bsol;* max_depth */,
2264                                               int &bsol;* skip_count */)
2265      GTEST_LOCK_EXCLUDED_(mutex_) {
2266    return "";
2267  }
2268  void OsStackTraceGetter::UponLeavingGTest()
2269      GTEST_LOCK_EXCLUDED_(mutex_) {
2270  }
2271  const char* const
2272  OsStackTraceGetter::kElidedFramesMarker =
2273      "... " GTEST_NAME_ " internal frames ...";
2274  class ScopedPrematureExitFile {
2275   public:
2276    explicit ScopedPrematureExitFile(const char* premature_exit_filepath)
2277        : premature_exit_filepath_(premature_exit_filepath) {
2278      if (premature_exit_filepath != NULL && *premature_exit_filepath != '\0') {
2279        FILE* pfile = posix::FOpen(premature_exit_filepath, "w");
2280        fwrite("0", 1, 1, pfile);
2281        fclose(pfile);
2282      }
2283    }
2284    ~ScopedPrematureExitFile() {
2285      if (premature_exit_filepath_ != NULL && *premature_exit_filepath_ != '\0') {
2286        remove(premature_exit_filepath_);
2287      }
2288    }
2289   private:
2290    const char* const premature_exit_filepath_;
2291    GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);
2292  };
2293  }  
2294  TestEventListeners::TestEventListeners()
2295      : repeater_(new internal::TestEventRepeater()),
2296        default_result_printer_(NULL),
2297        default_xml_generator_(NULL) {
2298  }
2299  TestEventListeners::~TestEventListeners() { delete repeater_; }
2300  void TestEventListeners::Append(TestEventListener* listener) {
2301    repeater_->Append(listener);
2302  }
2303  TestEventListener* TestEventListeners::Release(TestEventListener* listener) {
2304    if (listener == default_result_printer_)
2305      default_result_printer_ = NULL;
2306    else if (listener == default_xml_generator_)
2307      default_xml_generator_ = NULL;
2308    return repeater_->Release(listener);
2309  }
2310  TestEventListener* TestEventListeners::repeater() { return repeater_; }
2311  void TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {
2312    if (default_result_printer_ != listener) {
2313      delete Release(default_result_printer_);
2314      default_result_printer_ = listener;
2315      if (listener != NULL)
2316        Append(listener);
2317    }
2318  }
2319  void TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {
2320    if (default_xml_generator_ != listener) {
2321      delete Release(default_xml_generator_);
2322      default_xml_generator_ = listener;
2323      if (listener != NULL)
2324        Append(listener);
2325    }
2326  }
2327  bool TestEventListeners::EventForwardingEnabled() const {
2328    return repeater_->forwarding_enabled();
2329  }
2330  void TestEventListeners::SuppressEventForwarding() {
2331    repeater_->set_forwarding_enabled(false);
2332  }
2333  UnitTest* UnitTest::GetInstance() {
2334  #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)
2335    static UnitTest* const instance = new UnitTest;
2336    return instance;
2337  #else
2338    static UnitTest instance;
2339    return &instance;
2340  #endif  
2341  }
2342  int UnitTest::successful_test_case_count() const {
2343    return impl()->successful_test_case_count();
2344  }
2345  int UnitTest::failed_test_case_count() const {
2346    return impl()->failed_test_case_count();
2347  }
2348  int UnitTest::total_test_case_count() const {
2349    return impl()->total_test_case_count();
2350  }
2351  int UnitTest::test_case_to_run_count() const {
2352    return impl()->test_case_to_run_count();
2353  }
2354  int UnitTest::successful_test_count() const {
2355    return impl()->successful_test_count();
2356  }
2357  int UnitTest::failed_test_count() const { return impl()->failed_test_count(); }
2358  int UnitTest::reportable_disabled_test_count() const {
2359    return impl()->reportable_disabled_test_count();
2360  }
2361  int UnitTest::disabled_test_count() const {
2362    return impl()->disabled_test_count();
2363  }
2364  int UnitTest::reportable_test_count() const {
2365    return impl()->reportable_test_count();
2366  }
2367  int UnitTest::total_test_count() const { return impl()->total_test_count(); }
2368  int UnitTest::test_to_run_count() const { return impl()->test_to_run_count(); }
2369  internal::TimeInMillis UnitTest::start_timestamp() const {
2370      return impl()->start_timestamp();
2371  }
2372  internal::TimeInMillis UnitTest::elapsed_time() const {
2373    return impl()->elapsed_time();
2374  }
2375  bool UnitTest::Passed() const { return impl()->Passed(); }
2376  bool UnitTest::Failed() const { return impl()->Failed(); }
2377  const TestCase* UnitTest::GetTestCase(int i) const {
2378    return impl()->GetTestCase(i);
2379  }
2380  const TestResult& UnitTest::ad_hoc_test_result() const {
2381    return *impl()->ad_hoc_test_result();
2382  }
2383  TestCase* UnitTest::GetMutableTestCase(int i) {
2384    return impl()->GetMutableTestCase(i);
2385  }
2386  TestEventListeners& UnitTest::listeners() {
2387    return *impl()->listeners();
2388  }
2389  Environment* UnitTest::AddEnvironment(Environment* env) {
2390    if (env == NULL) {
2391      return NULL;
2392    }
2393    impl_->environments().push_back(env);
2394    return env;
2395  }
2396  void UnitTest::AddTestPartResult(
2397      TestPartResult::Type result_type,
2398      const char* file_name,
2399      int line_number,
2400      const std::string& message,
2401      const std::string& os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) {
2402    Message msg;
2403    msg << message;
2404    internal::MutexLock lock(&mutex_);
2405    if (impl_->gtest_trace_stack().size() > 0) {
2406      msg << "\n" << GTEST_NAME_ << " trace:";
2407      for (int i = static_cast<int>(impl_->gtest_trace_stack().size());
2408           i > 0; --i) {
2409        const internal::TraceInfo& trace = impl_->gtest_trace_stack()[i - 1];
2410        msg << "\n" << internal::FormatFileLocation(trace.file, trace.line)
2411            << " " << trace.message;
2412      }
2413    }
2414    if (os_stack_trace.c_str() != NULL && !os_stack_trace.empty()) {
2415      msg << internal::kStackTraceMarker << os_stack_trace;
2416    }
2417    const TestPartResult result =
2418      TestPartResult(result_type, file_name, line_number,
2419                     msg.GetString().c_str());
2420    impl_->GetTestPartResultReporterForCurrentThread()->
2421        ReportTestPartResult(result);
2422    if (result_type != TestPartResult::kSuccess) {
2423      if (GTEST_FLAG(break_on_failure)) {
2424  #if GTEST_OS_WINDOWS
2425        DebugBreak();
2426  #else
2427        *static_cast<volatile int*>(NULL) = 1;
2428  #endif  
2429      } else if (GTEST_FLAG(throw_on_failure)) {
2430  #if GTEST_HAS_EXCEPTIONS
2431        throw internal::GoogleTestFailureException(result);
2432  #else
2433        exit(1);
2434  #endif
2435      }
2436    }
2437  }
2438  void UnitTest::RecordProperty(const std::string& key,
2439                                const std::string& value) {
2440    impl_->RecordProperty(TestProperty(key, value));
2441  }
2442  int UnitTest::Run() {
2443    const bool in_death_test_child_process =
2444        internal::GTEST_FLAG(internal_run_death_test).length() > 0;
2445    const internal::ScopedPrematureExitFile premature_exit_file(
2446        in_death_test_child_process ?
2447        NULL : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE"));
2448    impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));
2449  #if GTEST_HAS_SEH
2450    if (impl()->catch_exceptions() || in_death_test_child_process) {
2451  # if !GTEST_OS_WINDOWS_MOBILE
2452      SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
2453                   SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
2454  # endif  
2455  # if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) && !GTEST_OS_WINDOWS_MOBILE
2456      _set_error_mode(_OUT_TO_STDERR);
2457  # endif
2458  # if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE
2459      if (!GTEST_FLAG(break_on_failure))
2460        _set_abort_behavior(
2461            0x0,                                    
2462            _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  
2463  # endif
2464    }
2465  #endif  
2466    return internal::HandleExceptionsInMethodIfSupported(
2467        impl(),
2468        &internal::UnitTestImpl::RunAllTests,
2469        "auxiliary test code (environments or event listeners)") ? 0 : 1;
2470  }
2471  const char* UnitTest::original_working_dir() const {
2472    return impl_->original_working_dir_.c_str();
2473  }
2474  const TestCase* UnitTest::current_test_case() const
2475      GTEST_LOCK_EXCLUDED_(mutex_) {
2476    internal::MutexLock lock(&mutex_);
2477    return impl_->current_test_case();
2478  }
2479  const TestInfo* UnitTest::current_test_info() const
2480      GTEST_LOCK_EXCLUDED_(mutex_) {
2481    internal::MutexLock lock(&mutex_);
2482    return impl_->current_test_info();
2483  }
2484  int UnitTest::random_seed() const { return impl_->random_seed(); }
2485  #if GTEST_HAS_PARAM_TEST
2486  internal::ParameterizedTestCaseRegistry&
2487      UnitTest::parameterized_test_registry()
2488          GTEST_LOCK_EXCLUDED_(mutex_) {
2489    return impl_->parameterized_test_registry();
2490  }
2491  #endif  
2492  UnitTest::UnitTest() {
2493    impl_ = new internal::UnitTestImpl(this);
2494  }
2495  UnitTest::~UnitTest() {
2496    delete impl_;
2497  }
2498  void UnitTest::PushGTestTrace(const internal::TraceInfo& trace)
2499      GTEST_LOCK_EXCLUDED_(mutex_) {
2500    internal::MutexLock lock(&mutex_);
2501    impl_->gtest_trace_stack().push_back(trace);
2502  }
2503  void UnitTest::PopGTestTrace()
2504      GTEST_LOCK_EXCLUDED_(mutex_) {
2505    internal::MutexLock lock(&mutex_);
2506    impl_->gtest_trace_stack().pop_back();
2507  }
2508  namespace internal {
2509  UnitTestImpl::UnitTestImpl(UnitTest* parent)
2510      : parent_(parent),
2511  #ifdef _MSC_VER
2512  # pragma warning(push)                    
2513  # pragma warning(disable:4355)            
2514        default_global_test_part_result_reporter_(this),
2515        default_per_thread_test_part_result_reporter_(this),
2516  # pragma warning(pop)                     
2517  #else
2518        default_global_test_part_result_reporter_(this),
2519        default_per_thread_test_part_result_reporter_(this),
2520  #endif  
2521        global_test_part_result_repoter_(
2522            &default_global_test_part_result_reporter_),
2523        per_thread_test_part_result_reporter_(
2524            &default_per_thread_test_part_result_reporter_),
2525  #if GTEST_HAS_PARAM_TEST
2526        parameterized_test_registry_(),
2527        parameterized_tests_registered_(false),
2528  #endif  
2529        last_death_test_case_(-1),
2530        current_test_case_(NULL),
2531        current_test_info_(NULL),
2532        ad_hoc_test_result_(),
2533        os_stack_trace_getter_(NULL),
2534        post_flag_parse_init_performed_(false),
2535        random_seed_(0),  
2536        random_(0),  
2537        start_timestamp_(0),
2538        elapsed_time_(0),
2539  #if GTEST_HAS_DEATH_TEST
2540        death_test_factory_(new DefaultDeathTestFactory),
2541  #endif
2542        catch_exceptions_(false) {
2543    listeners()->SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);
2544  }
2545  UnitTestImpl::~UnitTestImpl() {
2546    ForEach(test_cases_, internal::Delete<TestCase>);
2547    ForEach(environments_, internal::Delete<Environment>);
2548    delete os_stack_trace_getter_;
2549  }
2550  void UnitTestImpl::RecordProperty(const TestProperty& test_property) {
2551    std::string xml_element;
2552    TestResult* test_result;  
2553    if (current_test_info_ != NULL) {
2554      xml_element = "testcase";
2555      test_result = &(current_test_info_->result_);
2556    } else if (current_test_case_ != NULL) {
2557      xml_element = "testsuite";
2558      test_result = &(current_test_case_->ad_hoc_test_result_);
2559    } else {
2560      xml_element = "testsuites";
2561      test_result = &ad_hoc_test_result_;
2562    }
2563    test_result->RecordProperty(xml_element, test_property);
2564  }
2565  #if GTEST_HAS_DEATH_TEST
2566  void UnitTestImpl::SuppressTestEventsIfInSubprocess() {
2567    if (internal_run_death_test_flag_.get() != NULL)
2568      listeners()->SuppressEventForwarding();
2569  }
2570  #endif  
2571  void UnitTestImpl::ConfigureXmlOutput() {
2572    const std::string& output_format = UnitTestOptions::GetOutputFormat();
2573    if (output_format == "xml") {
2574      listeners()->SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(
2575          UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
2576    } else if (output_format != "") {
2577      printf("WARNING: unrecognized output format \"%s\" ignored.\n",
2578             output_format.c_str());
2579      fflush(stdout);
2580    }
2581  }
2582  #if GTEST_CAN_STREAM_RESULTS_
2583  void UnitTestImpl::ConfigureStreamingOutput() {
2584    const std::string& target = GTEST_FLAG(stream_result_to);
2585    if (!target.empty()) {
2586      const size_t pos = target.find(':');
2587      if (pos != std::string::npos) {
2588        listeners()->Append(new StreamingListener(target.substr(0, pos),
2589                                                  target.substr(pos+1)));
2590      } else {
2591        printf("WARNING: unrecognized streaming target \"%s\" ignored.\n",
2592               target.c_str());
2593        fflush(stdout);
2594      }
2595    }
2596  }
2597  #endif  
2598  void UnitTestImpl::PostFlagParsingInit() {
2599    if (!post_flag_parse_init_performed_) {
2600      post_flag_parse_init_performed_ = true;
2601  #if GTEST_HAS_DEATH_TEST
2602      InitDeathTestSubprocessControlInfo();
2603      SuppressTestEventsIfInSubprocess();
2604  #endif  
2605      RegisterParameterizedTests();
2606      ConfigureXmlOutput();
2607  #if GTEST_CAN_STREAM_RESULTS_
2608      ConfigureStreamingOutput();
2609  #endif  
2610    }
2611  }
2612  class TestCaseNameIs {
2613   public:
2614    explicit TestCaseNameIs(const std::string& name)
2615        : name_(name) {}
2616    bool operator()(const TestCase* test_case) const {
2617      return test_case != NULL && strcmp(test_case->name(), name_.c_str()) == 0;
2618    }
2619   private:
2620    std::string name_;
2621  };
2622  TestCase* UnitTestImpl::GetTestCase(const char* test_case_name,
2623                                      const char* type_param,
2624                                      Test::SetUpTestCaseFunc set_up_tc,
2625                                      Test::TearDownTestCaseFunc tear_down_tc) {
2626    const std::vector<TestCase*>::const_iterator test_case =
2627        std::find_if(test_cases_.begin(), test_cases_.end(),
2628                     TestCaseNameIs(test_case_name));
2629    if (test_case != test_cases_.end())
2630      return *test_case;
2631    TestCase* const new_test_case =
2632        new TestCase(test_case_name, type_param, set_up_tc, tear_down_tc);
2633    if (internal::UnitTestOptions::MatchesFilter(test_case_name,
2634                                                 kDeathTestCaseFilter)) {
2635      ++last_death_test_case_;
2636      test_cases_.insert(test_cases_.begin() + last_death_test_case_,
2637                         new_test_case);
2638    } else {
2639      test_cases_.push_back(new_test_case);
2640    }
2641    test_case_indices_.push_back(static_cast<int>(test_case_indices_.size()));
2642    return new_test_case;
2643  }
2644  static void SetUpEnvironment(Environment* env) { env->SetUp(); }
2645  static void TearDownEnvironment(Environment* env) { env->TearDown(); }
2646  bool UnitTestImpl::RunAllTests() {
2647    if (!GTestIsInitialized()) {
2648      printf("%s",
2649             "\nThis test program did NOT call ::testing::InitGoogleTest "
2650             "before calling RUN_ALL_TESTS().  Please fix it.\n");
2651      return false;
2652    }
2653    if (g_help_flag)
2654      return true;
2655    PostFlagParsingInit();
2656    internal::WriteToShardStatusFileIfNeeded();
2657    bool in_subprocess_for_death_test = false;
2658  #if GTEST_HAS_DEATH_TEST
2659    in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);
2660  #endif  
2661    const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,
2662                                          in_subprocess_for_death_test);
2663    const bool has_tests_to_run = FilterTests(should_shard
2664                                                ? HONOR_SHARDING_PROTOCOL
2665                                                : IGNORE_SHARDING_PROTOCOL) > 0;
2666    if (GTEST_FLAG(list_tests)) {
2667      ListTestsMatchingFilter();
2668      return true;
2669    }
2670    random_seed_ = GTEST_FLAG(shuffle) ?
2671        GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;
2672    bool failed = false;
2673    TestEventListener* repeater = listeners()->repeater();
2674    start_timestamp_ = GetTimeInMillis();
2675    repeater->OnTestProgramStart(*parent_);
2676    const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);
2677    const bool forever = repeat < 0;
2678    for (int i = 0; forever || i != repeat; i++) {
2679      ClearNonAdHocTestResult();
2680      const TimeInMillis start = GetTimeInMillis();
2681      if (has_tests_to_run && GTEST_FLAG(shuffle)) {
2682        random()->Reseed(random_seed_);
2683        ShuffleTests();
2684      }
2685      repeater->OnTestIterationStart(*parent_, i);
2686      if (has_tests_to_run) {
2687        repeater->OnEnvironmentsSetUpStart(*parent_);
2688        ForEach(environments_, SetUpEnvironment);
2689        repeater->OnEnvironmentsSetUpEnd(*parent_);
2690        if (!Test::HasFatalFailure()) {
2691          for (int test_index = 0; test_index < total_test_case_count();
2692               test_index++) {
2693            GetMutableTestCase(test_index)->Run();
2694          }
2695        }
2696        repeater->OnEnvironmentsTearDownStart(*parent_);
2697        std::for_each(environments_.rbegin(), environments_.rend(),
2698                      TearDownEnvironment);
2699        repeater->OnEnvironmentsTearDownEnd(*parent_);
2700      }
2701      elapsed_time_ = GetTimeInMillis() - start;
2702      repeater->OnTestIterationEnd(*parent_, i);
2703      if (!Passed()) {
2704        failed = true;
2705      }
2706      UnshuffleTests();
2707      if (GTEST_FLAG(shuffle)) {
2708        random_seed_ = GetNextRandomSeed(random_seed_);
2709      }
2710    }
2711    repeater->OnTestProgramEnd(*parent_);
2712    return !failed;
2713  }
2714  void WriteToShardStatusFileIfNeeded() {
2715    const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);
2716    if (test_shard_file != NULL) {
2717      FILE* const file = posix::FOpen(test_shard_file, "w");
2718      if (file == NULL) {
2719        ColoredPrintf(COLOR_RED,
2720                      "Could not write to the test shard status file \"%s\" "
2721                      "specified by the %s environment variable.\n",
2722                      test_shard_file, kTestShardStatusFile);
2723        fflush(stdout);
2724        exit(EXIT_FAILURE);
2725      }
2726      fclose(file);
2727    }
2728  }
2729  bool ShouldShard(const char* total_shards_env,
2730                   const char* shard_index_env,
2731                   bool in_subprocess_for_death_test) {
2732    if (in_subprocess_for_death_test) {
2733      return false;
2734    }
2735    const Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);
2736    const Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);
2737    if (total_shards == -1 && shard_index == -1) {
2738      return false;
2739    } else if (total_shards == -1 && shard_index != -1) {
2740      const Message msg = Message()
2741        << "Invalid environment variables: you have "
2742        << kTestShardIndex << " = " << shard_index
2743        << ", but have left " << kTestTotalShards << " unset.\n";
2744      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2745      fflush(stdout);
2746      exit(EXIT_FAILURE);
2747    } else if (total_shards != -1 && shard_index == -1) {
2748      const Message msg = Message()
2749        << "Invalid environment variables: you have "
2750        << kTestTotalShards << " = " << total_shards
2751        << ", but have left " << kTestShardIndex << " unset.\n";
2752      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2753      fflush(stdout);
2754      exit(EXIT_FAILURE);
2755    } else if (shard_index < 0 || shard_index >= total_shards) {
2756      const Message msg = Message()
2757        << "Invalid environment variables: we require 0 <= "
2758        << kTestShardIndex << " < " << kTestTotalShards
2759        << ", but you have " << kTestShardIndex << "=" << shard_index
2760        << ", " << kTestTotalShards << "=" << total_shards << ".\n";
2761      ColoredPrintf(COLOR_RED, msg.GetString().c_str());
2762      fflush(stdout);
2763      exit(EXIT_FAILURE);
2764    }
2765    return total_shards > 1;
2766  }
2767  Int32 Int32FromEnvOrDie(const char* var, Int32 default_val) {
2768    const char* str_val = posix::GetEnv(var);
2769    if (str_val == NULL) {
2770      return default_val;
2771    }
2772    Int32 result;
2773    if (!ParseInt32(Message() << "The value of environment variable " << var,
2774                    str_val, &result)) {
2775      exit(EXIT_FAILURE);
2776    }
2777    return result;
2778  }
2779  bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {
2780    return (test_id % total_shards) == shard_index;
2781  }
2782  int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
2783    const Int32 total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?
2784        Int32FromEnvOrDie(kTestTotalShards, -1) : -1;
2785    const Int32 shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?
2786        Int32FromEnvOrDie(kTestShardIndex, -1) : -1;
2787    int num_runnable_tests = 0;
2788    int num_selected_tests = 0;
2789    for (size_t i = 0; i < test_cases_.size(); i++) {
2790      TestCase* const test_case = test_cases_[i];
2791      const std::string &test_case_name = test_case->name();
2792      test_case->set_should_run(false);
2793      for (size_t j = 0; j < test_case->test_info_list().size(); j++) {
2794        TestInfo* const test_info = test_case->test_info_list()[j];
2795        const std::string test_name(test_info->name());
2796        const bool is_disabled =
2797            internal::UnitTestOptions::MatchesFilter(test_case_name,
2798                                                     kDisableTestFilter) ||
2799            internal::UnitTestOptions::MatchesFilter(test_name,
2800                                                     kDisableTestFilter);
2801        test_info->is_disabled_ = is_disabled;
2802        const bool matches_filter =
2803            internal::UnitTestOptions::FilterMatchesTest(test_case_name,
2804                                                         test_name);
2805        test_info->matches_filter_ = matches_filter;
2806        const bool is_runnable =
2807            (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&
2808            matches_filter;
2809        const bool is_selected = is_runnable &&
2810            (shard_tests == IGNORE_SHARDING_PROTOCOL ||
2811             ShouldRunTestOnShard(total_shards, shard_index,
2812                                  num_runnable_tests));
2813        num_runnable_tests += is_runnable;
2814        num_selected_tests += is_selected;
2815        test_info->should_run_ = is_selected;
2816        test_case->set_should_run(test_case->should_run() || is_selected);
2817      }
2818    }
2819    return num_selected_tests;
2820  }
2821  static void PrintOnOneLine(const char* str, int max_length) {
2822    if (str != NULL) {
2823      for (int i = 0; *str != '\0'; ++str) {
2824        if (i >= max_length) {
2825          printf("...");
2826          break;
2827        }
2828        if (*str == '\n') {
2829          printf("\\n");
2830          i += 2;
2831        } else {
2832          printf("%c", *str);
2833          ++i;
2834        }
2835      }
2836    }
2837  }
2838  void UnitTestImpl::ListTestsMatchingFilter() {
2839    const int kMaxParamLength = 250;
2840    for (size_t i = 0; i < test_cases_.size(); i++) {
2841      const TestCase* const test_case = test_cases_[i];
2842      bool printed_test_case_name = false;
2843      for (size_t j = 0; j < test_case->test_info_list().size(); j++) {
2844        const TestInfo* const test_info =
2845            test_case->test_info_list()[j];
2846        if (test_info->matches_filter_) {
2847          if (!printed_test_case_name) {
2848            printed_test_case_name = true;
2849            printf("%s.", test_case->name());
2850            if (test_case->type_param() != NULL) {
2851              printf("  # %s = ", kTypeParamLabel);
2852              PrintOnOneLine(test_case->type_param(), kMaxParamLength);
2853            }
2854            printf("\n");
2855          }
2856          printf("  %s", test_info->name());
2857          if (test_info->value_param() != NULL) {
2858            printf("  # %s = ", kValueParamLabel);
2859            PrintOnOneLine(test_info->value_param(), kMaxParamLength);
2860          }
2861          printf("\n");
2862        }
2863      }
2864    }
2865    fflush(stdout);
2866  }
2867  void UnitTestImpl::set_os_stack_trace_getter(
2868      OsStackTraceGetterInterface* getter) {
2869    if (os_stack_trace_getter_ != getter) {
2870      delete os_stack_trace_getter_;
2871      os_stack_trace_getter_ = getter;
2872    }
2873  }
2874  OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
2875    if (os_stack_trace_getter_ == NULL) {
2876      os_stack_trace_getter_ = new OsStackTraceGetter;
2877    }
2878    return os_stack_trace_getter_;
2879  }
2880  TestResult* UnitTestImpl::current_test_result() {
2881    return current_test_info_ ?
2882        &(current_test_info_->result_) : &ad_hoc_test_result_;
2883  }
2884  void UnitTestImpl::ShuffleTests() {
2885    ShuffleRange(random(), 0, last_death_test_case_ + 1, &test_case_indices_);
2886    ShuffleRange(random(), last_death_test_case_ + 1,
2887                 static_cast<int>(test_cases_.size()), &test_case_indices_);
2888    for (size_t i = 0; i < test_cases_.size(); i++) {
2889      test_cases_[i]->ShuffleTests(random());
2890    }
2891  }
2892  void UnitTestImpl::UnshuffleTests() {
2893    for (size_t i = 0; i < test_cases_.size(); i++) {
2894      test_cases_[i]->UnshuffleTests();
2895      test_case_indices_[i] = static_cast<int>(i);
2896    }
2897  }
2898  std::string GetCurrentOsStackTraceExceptTop(UnitTest* &bsol;*unit_test*/,
2899                                              int skip_count) {
2900    return GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);
2901  }
2902  namespace {
2903  class ClassUniqueToAlwaysTrue {};
2904  }
2905  bool IsTrue(bool condition) { return condition; }
2906  bool AlwaysTrue() {
2907  #if GTEST_HAS_EXCEPTIONS
2908    if (IsTrue(false))
2909      throw ClassUniqueToAlwaysTrue();
2910  #endif  
2911    return true;
2912  }
2913  bool SkipPrefix(const char* prefix, const char** pstr) {
2914    const size_t prefix_len = strlen(prefix);
2915    if (strncmp(*pstr, prefix, prefix_len) == 0) {
2916      *pstr += prefix_len;
2917      return true;
2918    }
2919    return false;
2920  }
2921  const char* ParseFlagValue(const char* str,
2922                             const char* flag,
2923                             bool def_optional) {
2924    if (str == NULL || flag == NULL) return NULL;
2925    const std::string flag_str = std::string("--") + GTEST_FLAG_PREFIX_ + flag;
2926    const size_t flag_len = flag_str.length();
2927    if (strncmp(str, flag_str.c_str(), flag_len) != 0) return NULL;
2928    const char* flag_end = str + flag_len;
2929    if (def_optional && (flag_end[0] == '\0')) {
2930      return flag_end;
2931    }
2932    if (flag_end[0] != '=') return NULL;
2933    return flag_end + 1;
2934  }
2935  bool ParseBoolFlag(const char* str, const char* flag, bool* value) {
2936    const char* const value_str = ParseFlagValue(str, flag, true);
2937    if (value_str == NULL) return false;
2938    *value = !(*value_str == '0' || *value_str == 'f' || *value_str == 'F');
2939    return true;
2940  }
2941  bool ParseInt32Flag(const char* str, const char* flag, Int32* value) {
2942    const char* const value_str = ParseFlagValue(str, flag, false);
2943    if (value_str == NULL) return false;
2944    return ParseInt32(Message() << "The value of flag --" << flag,
2945                      value_str, value);
2946  }
2947  bool ParseStringFlag(const char* str, const char* flag, std::string* value) {
2948    const char* const value_str = ParseFlagValue(str, flag, false);
2949    if (value_str == NULL) return false;
2950    *value = value_str;
2951    return true;
2952  }
2953  static bool HasGoogleTestFlagPrefix(const char* str) {
2954    return (SkipPrefix("--", &str) ||
2955            SkipPrefix("-", &str) ||
2956            SkipPrefix("/", &str)) &&
2957           !SkipPrefix(GTEST_FLAG_PREFIX_ "internal_", &str) &&
2958           (SkipPrefix(GTEST_FLAG_PREFIX_, &str) ||
2959            SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &str));
2960  }
2961  static void PrintColorEncoded(const char* str) {
2962    GTestColor color = COLOR_DEFAULT;  
2963    for (;;) {
2964      const char* p = strchr(str, '@');
2965      if (p == NULL) {
2966        ColoredPrintf(color, "%s", str);
2967        return;
2968      }
2969      ColoredPrintf(color, "%s", std::string(str, p).c_str());
2970      const char ch = p[1];
2971      str = p + 2;
2972      if (ch == '@') {
2973        ColoredPrintf(color, "@");
2974      } else if (ch == 'D') {
2975        color = COLOR_DEFAULT;
2976      } else if (ch == 'R') {
2977        color = COLOR_RED;
2978      } else if (ch == 'G') {
2979        color = COLOR_GREEN;
2980      } else if (ch == 'Y') {
2981        color = COLOR_YELLOW;
2982      } else {
2983        --str;
2984      }
2985    }
2986  }
2987  static const char kColorEncodedHelpMessage[] =
2988  "This program contains tests written using " GTEST_NAME_ ". You can use the\n"
2989  "following command line flags to control its behavior:\n"
2990  "\n"
2991  "Test Selection:\n"
2992  "  @G--" GTEST_FLAG_PREFIX_ "list_tests@D\n"
2993  "      List the names of all tests instead of running them. The name of\n"
2994  "      TEST(Foo, Bar) is \"Foo.Bar\".\n"
2995  "  @G--" GTEST_FLAG_PREFIX_ "filter=@YPOSTIVE_PATTERNS"
2996      "[@G-@YNEGATIVE_PATTERNS]@D\n"
2997  "      Run only the tests whose name matches one of the positive patterns but\n"
2998  "      none of the negative patterns. '?' matches any single character; '*'\n"
2999  "      matches any substring; ':' separates two patterns.\n"
3000  "  @G--" GTEST_FLAG_PREFIX_ "also_run_disabled_tests@D\n"
3001  "      Run all disabled tests too.\n"
3002  "\n"
3003  "Test Execution:\n"
3004  "  @G--" GTEST_FLAG_PREFIX_ "repeat=@Y[COUNT]@D\n"
3005  "      Run the tests repeatedly; use a negative count to repeat forever.\n"
3006  "  @G--" GTEST_FLAG_PREFIX_ "shuffle@D\n"
3007  "      Randomize tests' orders on every iteration.\n"
3008  "  @G--" GTEST_FLAG_PREFIX_ "random_seed=@Y[NUMBER]@D\n"
3009  "      Random number seed to use for shuffling test orders (between 1 and\n"
3010  "      99999, or 0 to use a seed based on the current time).\n"
3011  "\n"
3012  "Test Output:\n"
3013  "  @G--" GTEST_FLAG_PREFIX_ "color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n"
3014  "      Enable/disable colored output. The default is @Gauto@D.\n"
3015  "  -@G-" GTEST_FLAG_PREFIX_ "print_time=0@D\n"
3016  "      Don't print the elapsed time of each test.\n"
3017  "  @G--" GTEST_FLAG_PREFIX_ "output=xml@Y[@G:@YDIRECTORY_PATH@G"
3018      GTEST_PATH_SEP_ "@Y|@G:@YFILE_PATH]@D\n"
3019  "      Generate an XML report in the given directory or with the given file\n"
3020  "      name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n"
3021  #if GTEST_CAN_STREAM_RESULTS_
3022  "  @G--" GTEST_FLAG_PREFIX_ "stream_result_to=@YHOST@G:@YPORT@D\n"
3023  "      Stream test results to the given server.\n"
3024  #endif  
3025  "\n"
3026  "Assertion Behavior:\n"
3027  #if GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS
3028  "  @G--" GTEST_FLAG_PREFIX_ "death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n"
3029  "      Set the default death test style.\n"
3030  #endif  
3031  "  @G--" GTEST_FLAG_PREFIX_ "break_on_failure@D\n"
3032  "      Turn assertion failures into debugger break-points.\n"
3033  "  @G--" GTEST_FLAG_PREFIX_ "throw_on_failure@D\n"
3034  "      Turn assertion failures into C++ exceptions.\n"
3035  "  @G--" GTEST_FLAG_PREFIX_ "catch_exceptions=0@D\n"
3036  "      Do not report exceptions as test failures. Instead, allow them\n"
3037  "      to crash the program or throw a pop-up (on Windows).\n"
3038  "\n"
3039  "Except for @G--" GTEST_FLAG_PREFIX_ "list_tests@D, you can alternatively set "
3040      "the corresponding\n"
3041  "environment variable of a flag (all letters in upper-case). For example, to\n"
3042  "disable colored text output, you can either specify @G--" GTEST_FLAG_PREFIX_
3043      "color=no@D or set\n"
3044  "the @G" GTEST_FLAG_PREFIX_UPPER_ "COLOR@D environment variable to @Gno@D.\n"
3045  "\n"
3046  "For more information, please read the " GTEST_NAME_ " documentation at\n"
3047  "@G" GTEST_PROJECT_URL_ "@D. If you find a bug in " GTEST_NAME_ "\n"
3048  "(not one in your own code or tests), please report it to\n"
3049  "@G<" GTEST_DEV_EMAIL_ ">@D.\n";
3050  template <typename CharType>
3051  void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
3052    for (int i = 1; i < *argc; i++) {
3053      const std::string arg_string = StreamableToString(argv[i]);
3054      const char* const arg = arg_string.c_str();
3055      using internal::ParseBoolFlag;
3056      using internal::ParseInt32Flag;
3057      using internal::ParseStringFlag;
3058      if (ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,
3059                        &GTEST_FLAG(also_run_disabled_tests)) ||
3060          ParseBoolFlag(arg, kBreakOnFailureFlag,
3061                        &GTEST_FLAG(break_on_failure)) ||
3062          ParseBoolFlag(arg, kCatchExceptionsFlag,
3063                        &GTEST_FLAG(catch_exceptions)) ||
3064          ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||
3065          ParseStringFlag(arg, kDeathTestStyleFlag,
3066                          &GTEST_FLAG(death_test_style)) ||
3067          ParseBoolFlag(arg, kDeathTestUseFork,
3068                        &GTEST_FLAG(death_test_use_fork)) ||
3069          ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||
3070          ParseStringFlag(arg, kInternalRunDeathTestFlag,
3071                          &GTEST_FLAG(internal_run_death_test)) ||
3072          ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||
3073          ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||
3074          ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||
3075          ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||
3076          ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||
3077          ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||
3078          ParseInt32Flag(arg, kStackTraceDepthFlag,
3079                         &GTEST_FLAG(stack_trace_depth)) ||
3080          ParseStringFlag(arg, kStreamResultToFlag,
3081                          &GTEST_FLAG(stream_result_to)) ||
3082          ParseBoolFlag(arg, kThrowOnFailureFlag,
3083                        &GTEST_FLAG(throw_on_failure))
3084          ) {
3085        for (int j = i; j != *argc; j++) {
3086          argv[j] = argv[j + 1];
3087        }
3088        (*argc)--;
3089        i--;
3090      } else if (arg_string == "--help" || arg_string == "-h" ||
3091                 arg_string == "-?" || arg_string == "/?" ||
3092                 HasGoogleTestFlagPrefix(arg)) {
3093        g_help_flag = true;
3094      }
3095    }
3096    if (g_help_flag) {
3097      PrintColorEncoded(kColorEncodedHelpMessage);
3098    }
3099  }
3100  void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
3101    ParseGoogleTestFlagsOnlyImpl(argc, argv);
3102  }
3103  void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
3104    ParseGoogleTestFlagsOnlyImpl(argc, argv);
3105  }
3106  template <typename CharType>
3107  void InitGoogleTestImpl(int* argc, CharType** argv) {
3108    g_init_gtest_count++;
3109    if (g_init_gtest_count != 1) return;
3110    if (*argc <= 0) return;
3111    internal::g_executable_path = internal::StreamableToString(argv[0]);
3112  #if GTEST_HAS_DEATH_TEST
3113    g_argvs.clear();
3114    for (int i = 0; i != *argc; i++) {
3115      g_argvs.push_back(StreamableToString(argv[i]));
3116    }
3117  #endif  
3118    ParseGoogleTestFlagsOnly(argc, argv);
3119    GetUnitTestImpl()->PostFlagParsingInit();
3120  }
3121  }  
3122  void InitGoogleTest(int* argc, char** argv) {
3123    internal::InitGoogleTestImpl(argc, argv);
3124  }
3125  void InitGoogleTest(int* argc, wchar_t** argv) {
3126    internal::InitGoogleTestImpl(argc, argv);
3127  }
3128  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest.cc</div>
                </div>
                <div class="column column_space"><pre><code>2641    test_case_indices_.push_back(static_cast<int>(test_case_indices_.size()));
2642    return new_test_case;
</pre></code></div>
                <div class="column column_space"><pre><code>1493    test_indices_.push_back(static_cast<int>(test_indices_.size()));
1494  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    