<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for material.cpp & bitboard_1.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for material.cpp & bitboard_1.cpp
      </h3>
      <h1 align="center">
        6.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>material.cpp (7.4626865%)<TH>bitboard_1.cpp (5.597015%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match112-0.html#0',2,'match112-1.html#0',3)" NAME="0">(35-43)<TD><A HREF="javascript:ZweiFrames('match112-0.html#0',2,'match112-1.html#0',3)" NAME="0">(185-186)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>material.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
  Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

#include &lt;algorithm&gt;  // For std::min
#include &lt;cassert&gt;
#include &lt;cstring&gt;

#include &quot;material.h&quot;

using namespace std;

namespace {

  // Polynomial material balance parameters

<A NAME="0"></A>  //                                  pair  pawn knight bishop rook queen
  const int LinearCoefficients[6] = { 1852, -162, -1122, -183,  249, -154 };

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match112-1.html#0',3,'match112-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  const int QuadraticCoefficientsSameSide[][PIECE_TYPE_NB] = {
    //            OUR PIECES
    // pair pawn knight bishop rook queen
    {   0                               }, // Bishop pair
    {  39,    2                         }, // Pawn
    {  35,  271,  -4                    }, // knight      OUR PIECES
    {   0,  105,   4,    0              }, // Bishop
    { -27,   -2,  46,   100,  -141      }, // Rook
    {-177,   25, 129,   142,  -137,   0 }  // Queen</B></FONT>
  };

  const int QuadraticCoefficientsOppositeSide[][PIECE_TYPE_NB] = {
    //           THEIR PIECES
    // pair pawn knight bishop rook queen
    {   0                               }, // Bishop pair
    {  37,    0                         }, // Pawn
    {  10,   62,   0                    }, // Knight      OUR PIECES
    {  57,   64,  39,     0             }, // Bishop
    {  50,   40,  23,   -22,    0       }, // Rook
    {  98,  105, -39,   141,  274,    0 }  // Queen
  };

  // Endgame evaluation and scaling functions are accessed directly and not through
  // the function maps because they correspond to more than one material hash key.
  Endgame&lt;KXK&gt;   EvaluateKXK[]   = { Endgame&lt;KXK&gt;(WHITE),   Endgame&lt;KXK&gt;(BLACK) };

  Endgame&lt;KBPsK&gt;  ScaleKBPsK[]  = { Endgame&lt;KBPsK&gt;(WHITE),  Endgame&lt;KBPsK&gt;(BLACK) };
  Endgame&lt;KQKRPs&gt; ScaleKQKRPs[] = { Endgame&lt;KQKRPs&gt;(WHITE), Endgame&lt;KQKRPs&gt;(BLACK) };
  Endgame&lt;KPsK&gt;   ScaleKPsK[]   = { Endgame&lt;KPsK&gt;(WHITE),   Endgame&lt;KPsK&gt;(BLACK) };
  Endgame&lt;KPKP&gt;   ScaleKPKP[]   = { Endgame&lt;KPKP&gt;(WHITE),   Endgame&lt;KPKP&gt;(BLACK) };

  // Helper templates used to detect a given material distribution
  template&lt;Color Us&gt; bool is_KXK(const Position&amp; pos) {
    const Color Them = (Us == WHITE ? BLACK : WHITE);
    return  !pos.count&lt;PAWN&gt;(Them)
          &amp;&amp; pos.non_pawn_material(Them) == VALUE_ZERO
          &amp;&amp; pos.non_pawn_material(Us) &gt;= RookValueMg;
  }

  template&lt;Color Us&gt; bool is_KBPsKs(const Position&amp; pos) {
    return   pos.non_pawn_material(Us) == BishopValueMg
          &amp;&amp; pos.count&lt;BISHOP&gt;(Us) == 1
          &amp;&amp; pos.count&lt;PAWN  &gt;(Us) &gt;= 1;
  }

  template&lt;Color Us&gt; bool is_KQKRPs(const Position&amp; pos) {
    const Color Them = (Us == WHITE ? BLACK : WHITE);
    return  !pos.count&lt;PAWN&gt;(Us)
          &amp;&amp; pos.non_pawn_material(Us) == QueenValueMg
          &amp;&amp; pos.count&lt;QUEEN&gt;(Us)  == 1
          &amp;&amp; pos.count&lt;ROOK&gt;(Them) == 1
          &amp;&amp; pos.count&lt;PAWN&gt;(Them) &gt;= 1;
  }

  /// imbalance() calculates the imbalance by comparing the piece count of each
  /// piece type for both colors.

  template&lt;Color Us&gt;
  int imbalance(const int pieceCount[][PIECE_TYPE_NB]) {

    const Color Them = (Us == WHITE ? BLACK : WHITE);

    int pt1, pt2, pc, v;
    int value = 0;

    // Second-degree polynomial material imbalance by Tord Romstad
    for (pt1 = NO_PIECE_TYPE; pt1 &lt;= QUEEN; ++pt1)
    {
        pc = pieceCount[Us][pt1];
        if (!pc)
            continue;

        v = LinearCoefficients[pt1];

        for (pt2 = NO_PIECE_TYPE; pt2 &lt;= pt1; ++pt2)
            v +=  QuadraticCoefficientsSameSide[pt1][pt2] * pieceCount[Us][pt2]
                + QuadraticCoefficientsOppositeSide[pt1][pt2] * pieceCount[Them][pt2];

        value += pc * v;
    }

    return value;
  }

} // namespace

namespace Material {

/// Material::probe() takes a position object as input, looks up a MaterialEntry
/// object, and returns a pointer to it. If the material configuration is not
/// already present in the table, it is computed and stored there, so we don't
/// have to recompute everything when the same material configuration occurs again.

Entry* probe(const Position&amp; pos, Table&amp; entries, Endgames&amp; endgames) {

  Key key = pos.material_key();
  Entry* e = entries[key];

  // If e-&gt;key matches the position's material hash key, it means that we
  // have analysed this material configuration before, and we can simply
  // return the information we found the last time instead of recomputing it.
  if (e-&gt;key == key)
      return e;

  std::memset(e, 0, sizeof(Entry));
  e-&gt;key = key;
  e-&gt;factor[WHITE] = e-&gt;factor[BLACK] = (uint8_t)SCALE_FACTOR_NORMAL;
  e-&gt;gamePhase = game_phase(pos);

  // Let's look if we have a specialized evaluation function for this particular
  // material configuration. Firstly we look for a fixed configuration one, then
  // for a generic one if the previous search failed.
  if (endgames.probe(key, e-&gt;evaluationFunction))
      return e;

  if (is_KXK&lt;WHITE&gt;(pos))
  {
      e-&gt;evaluationFunction = &amp;EvaluateKXK[WHITE];
      return e;
  }

  if (is_KXK&lt;BLACK&gt;(pos))
  {
      e-&gt;evaluationFunction = &amp;EvaluateKXK[BLACK];
      return e;
  }

  // OK, we didn't find any special evaluation function for the current
  // material configuration. Is there a suitable scaling function?
  //
  // We face problems when there are several conflicting applicable
  // scaling functions and we need to decide which one to use.
  EndgameBase&lt;ScaleFactor&gt;* sf;

  if (endgames.probe(key, sf))
  {
      e-&gt;scalingFunction[sf-&gt;color()] = sf;
      return e;
  }

  // Generic scaling functions that refer to more than one material
  // distribution. They should be probed after the specialized ones.
  // Note that these ones don't return after setting the function.
  if (is_KBPsKs&lt;WHITE&gt;(pos))
      e-&gt;scalingFunction[WHITE] = &amp;ScaleKBPsK[WHITE];

  if (is_KBPsKs&lt;BLACK&gt;(pos))
      e-&gt;scalingFunction[BLACK] = &amp;ScaleKBPsK[BLACK];

  if (is_KQKRPs&lt;WHITE&gt;(pos))
      e-&gt;scalingFunction[WHITE] = &amp;ScaleKQKRPs[WHITE];

  else if (is_KQKRPs&lt;BLACK&gt;(pos))
      e-&gt;scalingFunction[BLACK] = &amp;ScaleKQKRPs[BLACK];

  Value npm_w = pos.non_pawn_material(WHITE);
  Value npm_b = pos.non_pawn_material(BLACK);

  if (npm_w + npm_b == VALUE_ZERO &amp;&amp; pos.pieces(PAWN))
  {
      if (!pos.count&lt;PAWN&gt;(BLACK))
      {
          assert(pos.count&lt;PAWN&gt;(WHITE) &gt;= 2);
          e-&gt;scalingFunction[WHITE] = &amp;ScaleKPsK[WHITE];
      }
      else if (!pos.count&lt;PAWN&gt;(WHITE))
      {
          assert(pos.count&lt;PAWN&gt;(BLACK) &gt;= 2);
          e-&gt;scalingFunction[BLACK] = &amp;ScaleKPsK[BLACK];
      }
      else if (pos.count&lt;PAWN&gt;(WHITE) == 1 &amp;&amp; pos.count&lt;PAWN&gt;(BLACK) == 1)
      {
          // This is a special case because we set scaling functions
          // for both colors instead of only one.
          e-&gt;scalingFunction[WHITE] = &amp;ScaleKPKP[WHITE];
          e-&gt;scalingFunction[BLACK] = &amp;ScaleKPKP[BLACK];
      }
  }

  // No pawns makes it difficult to win, even with a material advantage. This
  // catches some trivial draws like KK, KBK and KNK and gives a very drawish
  // scale factor for cases such as KRKBP and KmmKm (except for KBBKN).
  if (!pos.count&lt;PAWN&gt;(WHITE) &amp;&amp; npm_w - npm_b &lt;= BishopValueMg)
      e-&gt;factor[WHITE] = uint8_t(npm_w &lt; RookValueMg ? SCALE_FACTOR_DRAW : npm_b &lt;= BishopValueMg ? 4 : 12);

  if (!pos.count&lt;PAWN&gt;(BLACK) &amp;&amp; npm_b - npm_w &lt;= BishopValueMg)
      e-&gt;factor[BLACK] = uint8_t(npm_b &lt; RookValueMg ? SCALE_FACTOR_DRAW : npm_w &lt;= BishopValueMg ? 4 : 12);

  if (pos.count&lt;PAWN&gt;(WHITE) == 1 &amp;&amp; npm_w - npm_b &lt;= BishopValueMg)
      e-&gt;factor[WHITE] = (uint8_t) SCALE_FACTOR_ONEPAWN;

  if (pos.count&lt;PAWN&gt;(BLACK) == 1 &amp;&amp; npm_b - npm_w &lt;= BishopValueMg)
      e-&gt;factor[BLACK] = (uint8_t) SCALE_FACTOR_ONEPAWN;

  // Compute the space weight
  if (npm_w + npm_b &gt;= 2 * QueenValueMg + 4 * RookValueMg + 2 * KnightValueMg)
  {
      int minorPieceCount =  pos.count&lt;KNIGHT&gt;(WHITE) + pos.count&lt;BISHOP&gt;(WHITE)
                           + pos.count&lt;KNIGHT&gt;(BLACK) + pos.count&lt;BISHOP&gt;(BLACK);

      e-&gt;spaceWeight = make_score(minorPieceCount * minorPieceCount, 0);
  }

  // Evaluate the material imbalance. We use PIECE_TYPE_NONE as a place holder
  // for the bishop pair &quot;extended piece&quot;, which allows us to be more flexible
  // in defining bishop pair bonuses.
  const int pieceCount[COLOR_NB][PIECE_TYPE_NB] = {
  { pos.count&lt;BISHOP&gt;(WHITE) &gt; 1, pos.count&lt;PAWN&gt;(WHITE), pos.count&lt;KNIGHT&gt;(WHITE),
    pos.count&lt;BISHOP&gt;(WHITE)    , pos.count&lt;ROOK&gt;(WHITE), pos.count&lt;QUEEN &gt;(WHITE) },
  { pos.count&lt;BISHOP&gt;(BLACK) &gt; 1, pos.count&lt;PAWN&gt;(BLACK), pos.count&lt;KNIGHT&gt;(BLACK),
    pos.count&lt;BISHOP&gt;(BLACK)    , pos.count&lt;ROOK&gt;(BLACK), pos.count&lt;QUEEN &gt;(BLACK) } };

  e-&gt;value = (int16_t)((imbalance&lt;WHITE&gt;(pieceCount) - imbalance&lt;BLACK&gt;(pieceCount)) / 16);
  return e;
}


/// Material::game_phase() calculates the phase given the current
/// position. Because the phase is strictly a function of the material, it
/// is stored in MaterialEntry.

Phase game_phase(const Position&amp; pos) {

  Value npm = pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK);

  return  npm &gt;= MidgameLimit ? PHASE_MIDGAME
        : npm &lt;= EndgameLimit ? PHASE_ENDGAME
        : Phase(((npm - EndgameLimit) * 128) / (MidgameLimit - EndgameLimit));
}

} // namespace Material
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bitboard_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
  Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad

  Stockfish is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Stockfish is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

#include &lt;algorithm&gt;
#include &lt;cstring&gt; // For memset

#include &quot;bitboard.h&quot;
#include &quot;bitcount.h&quot;
#include &quot;rkiss.h&quot;

CACHE_LINE_ALIGNMENT

Bitboard RMasks[SQUARE_NB];
Bitboard RMagics[SQUARE_NB];
Bitboard* RAttacks[SQUARE_NB];
unsigned RShifts[SQUARE_NB];

Bitboard BMasks[SQUARE_NB];
Bitboard BMagics[SQUARE_NB];
Bitboard* BAttacks[SQUARE_NB];
unsigned BShifts[SQUARE_NB];

Bitboard SquareBB[SQUARE_NB];
Bitboard FileBB[FILE_NB];
Bitboard RankBB[RANK_NB];
Bitboard AdjacentFilesBB[FILE_NB];
Bitboard InFrontBB[COLOR_NB][RANK_NB];
Bitboard StepAttacksBB[PIECE_NB][SQUARE_NB];
Bitboard BetweenBB[SQUARE_NB][SQUARE_NB];
Bitboard LineBB[SQUARE_NB][SQUARE_NB];
Bitboard DistanceRingsBB[SQUARE_NB][8];
Bitboard ForwardBB[COLOR_NB][SQUARE_NB];
Bitboard PassedPawnMask[COLOR_NB][SQUARE_NB];
Bitboard PawnAttackSpan[COLOR_NB][SQUARE_NB];
Bitboard PseudoAttacks[PIECE_TYPE_NB][SQUARE_NB];

int SquareDistance[SQUARE_NB][SQUARE_NB];

namespace {

  // De Bruijn sequences. See chessprogramming.wikispaces.com/BitScan
  const uint64_t DeBruijn_64 = 0x3F79D71B4CB0A89ULL;
  const uint32_t DeBruijn_32 = 0x783A9B23;

  CACHE_LINE_ALIGNMENT

  int MS1BTable[256];
  Square BSFTable[SQUARE_NB];
  Bitboard RTable[0x19000]; // Storage space for rook attacks
  Bitboard BTable[0x1480];  // Storage space for bishop attacks

  typedef unsigned (Fn)(Square, Bitboard);

  void init_magics(Bitboard table[], Bitboard* attacks[], Bitboard magics[],
                   Bitboard masks[], unsigned shifts[], Square deltas[], Fn index);

  FORCE_INLINE unsigned bsf_index(Bitboard b) {

    // Matt Taylor's folding for 32 bit systems, extended to 64 bits by Kim Walisch
    b ^= (b - 1);
    return Is64Bit ? (b * DeBruijn_64) &gt;&gt; 58
                   : ((unsigned(b) ^ unsigned(b &gt;&gt; 32)) * DeBruijn_32) &gt;&gt; 26;
  }
}

/// lsb()/msb() finds the least/most significant bit in a non-zero bitboard.
/// pop_lsb() finds and clears the least significant bit in a non-zero bitboard.

#ifndef USE_BSFQ

Square lsb(Bitboard b) { return BSFTable[bsf_index(b)]; }

Square pop_lsb(Bitboard* b) {

  Bitboard bb = *b;
  *b = bb &amp; (bb - 1);
  return BSFTable[bsf_index(bb)];
}

Square msb(Bitboard b) {

  unsigned b32;
  int result = 0;

  if (b &gt; 0xFFFFFFFF)
  {
      b &gt;&gt;= 32;
      result = 32;
  }

  b32 = unsigned(b);

  if (b32 &gt; 0xFFFF)
  {
      b32 &gt;&gt;= 16;
      result += 16;
  }

  if (b32 &gt; 0xFF)
  {
      b32 &gt;&gt;= 8;
      result += 8;
  }

  return Square(result + MS1BTable[b32]);
}

#endif // ifndef USE_BSFQ


/// Bitboards::pretty() returns an ASCII representation of a bitboard to be
/// printed to standard output. This is sometimes useful for debugging.

const std::string Bitboards::pretty(Bitboard b) {

  std::string s = &quot;+---+---+---+---+---+---+---+---+\n&quot;;

  for (Rank r = RANK_8; r &gt;= RANK_1; --r)
  {
      for (File f = FILE_A; f &lt;= FILE_H; ++f)
          s.append(b &amp; make_square(f, r) ? &quot;| X &quot; : &quot;|   &quot;);

      s.append(&quot;|\n+---+---+---+---+---+---+---+---+\n&quot;);
  }

  return s;
}


/// Bitboards::init() initializes various bitboard tables. It is called at
/// startup and relies on global objects to be already zero-initialized.

void Bitboards::init() {

  for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
      BSFTable[bsf_index(SquareBB[s] = 1ULL &lt;&lt; s)] = s;

  for (Bitboard b = 1; b &lt; 256; ++b)
      MS1BTable[b] = more_than_one(b) ? MS1BTable[b - 1] : lsb(b);

  for (File f = FILE_A; f &lt;= FILE_H; ++f)
      FileBB[f] = f &gt; FILE_A ? FileBB[f - 1] &lt;&lt; 1 : FileABB;

  for (Rank r = RANK_1; r &lt;= RANK_8; ++r)
      RankBB[r] = r &gt; RANK_1 ? RankBB[r - 1] &lt;&lt; 8 : Rank1BB;

  for (File f = FILE_A; f &lt;= FILE_H; ++f)
      AdjacentFilesBB[f] = (f &gt; FILE_A ? FileBB[f - 1] : 0) | (f &lt; FILE_H ? FileBB[f + 1] : 0);

  for (Rank r = RANK_1; r &lt; RANK_8; ++r)
      InFrontBB[WHITE][r] = ~(InFrontBB[BLACK][r + 1] = InFrontBB[BLACK][r] | RankBB[r]);

  for (Color c = WHITE; c &lt;= BLACK; ++c)
      for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
      {
          ForwardBB[c][s]      = InFrontBB[c][rank_of(s)] &amp; FileBB[file_of(s)];
          PawnAttackSpan[c][s] = InFrontBB[c][rank_of(s)] &amp; AdjacentFilesBB[file_of(s)];
          PassedPawnMask[c][s] = ForwardBB[c][s] | PawnAttackSpan[c][s];
      }

  for (Square s1 = SQ_A1; s1 &lt;= SQ_H8; ++s1)
      for (Square s2 = SQ_A1; s2 &lt;= SQ_H8; ++s2)
          if (s1 != s2)
          {
              SquareDistance[s1][s2] = std::max(file_distance(s1, s2), rank_distance(s1, s2));
<A NAME="0"></A>              DistanceRingsBB[s1][SquareDistance[s1][s2] - 1] |= s2;
          }

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match112-0.html#0',2,'match112-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  int steps[][9] = { {}, { 7, 9 }, { 17, 15, 10, 6, -6, -10, -15, -17 },
                     {}, {}, {}, { 9, 7, -7, -9, 8, 1, -1, -8 } };</B></FONT>

  for (Color c = WHITE; c &lt;= BLACK; ++c)
      for (PieceType pt = PAWN; pt &lt;= KING; ++pt)
          for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
              for (int i = 0; steps[pt][i]; ++i)
              {
                  Square to = s + Square(c == WHITE ? steps[pt][i] : -steps[pt][i]);

                  if (is_ok(to) &amp;&amp; square_distance(s, to) &lt; 3)
                      StepAttacksBB[make_piece(c, pt)][s] |= to;
              }

  Square RDeltas[] = { DELTA_N,  DELTA_E,  DELTA_S,  DELTA_W  };
  Square BDeltas[] = { DELTA_NE, DELTA_SE, DELTA_SW, DELTA_NW };

  init_magics(RTable, RAttacks, RMagics, RMasks, RShifts, RDeltas, magic_index&lt;ROOK&gt;);
  init_magics(BTable, BAttacks, BMagics, BMasks, BShifts, BDeltas, magic_index&lt;BISHOP&gt;);

  for (Square s1 = SQ_A1; s1 &lt;= SQ_H8; ++s1)
  {
      PseudoAttacks[QUEEN][s1]  = PseudoAttacks[BISHOP][s1] = attacks_bb&lt;BISHOP&gt;(s1, 0);
      PseudoAttacks[QUEEN][s1] |= PseudoAttacks[  ROOK][s1] = attacks_bb&lt;  ROOK&gt;(s1, 0);

      for (Square s2 = SQ_A1; s2 &lt;= SQ_H8; ++s2)
      {
          Piece pc = (PseudoAttacks[BISHOP][s1] &amp; s2) ? W_BISHOP :
                     (PseudoAttacks[ROOK][s1]   &amp; s2) ? W_ROOK   : NO_PIECE;

          if (pc == NO_PIECE)
              continue;

          LineBB[s1][s2] = (attacks_bb(pc, s1, 0) &amp; attacks_bb(pc, s2, 0)) | s1 | s2;
          BetweenBB[s1][s2] = attacks_bb(pc, s1, SquareBB[s2]) &amp; attacks_bb(pc, s2, SquareBB[s1]);
      }
  }
}


namespace {

  Bitboard sliding_attack(Square deltas[], Square sq, Bitboard occupied) {

    Bitboard attack = 0;

    for (int i = 0; i &lt; 4; ++i)
        for (Square s = sq + deltas[i];
             is_ok(s) &amp;&amp; square_distance(s, s - deltas[i]) == 1;
             s += deltas[i])
        {
            attack |= s;

            if (occupied &amp; s)
                break;
        }

    return attack;
  }


  // init_magics() computes all rook and bishop attacks at startup. Magic
  // bitboards are used to look up attacks of sliding pieces. As a reference see
  // chessprogramming.wikispaces.com/Magic+Bitboards. In particular, here we
  // use the so called &quot;fancy&quot; approach.

  void init_magics(Bitboard table[], Bitboard* attacks[], Bitboard magics[],
                   Bitboard masks[], unsigned shifts[], Square deltas[], Fn index) {

    int MagicBoosters[][8] = { {  969, 1976, 2850,  542, 2069, 2852, 1708,  164 },
                               { 3101,  552, 3555,  926,  834,   26, 2131, 1117 } };

    RKISS rk;
    Bitboard occupancy[4096], reference[4096], edges, b;
    int i, size, booster;

    // attacks[s] is a pointer to the beginning of the attacks table for square 's'
    attacks[SQ_A1] = table;

    for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
    {
        // Board edges are not considered in the relevant occupancies
        edges = ((Rank1BB | Rank8BB) &amp; ~rank_bb(s)) | ((FileABB | FileHBB) &amp; ~file_bb(s));

        // Given a square 's', the mask is the bitboard of sliding attacks from
        // 's' computed on an empty board. The index must be big enough to contain
        // all the attacks for each possible subset of the mask and so is 2 power
        // the number of 1s of the mask. Hence we deduce the size of the shift to
        // apply to the 64 or 32 bits word to get the index.
        masks[s]  = sliding_attack(deltas, s, 0) &amp; ~edges;
        shifts[s] = (Is64Bit ? 64 : 32) - popcount&lt;Max15&gt;(masks[s]);

        // Use Carry-Rippler trick to enumerate all subsets of masks[s] and
        // store the corresponding sliding attack bitboard in reference[].
        b = size = 0;
        do {
            occupancy[size] = b;
            reference[size] = sliding_attack(deltas, s, b);

            if (HasPext)
                attacks[s][_pext_u64(b, masks[s])] = reference[size];

            size++;
            b = (b - masks[s]) &amp; masks[s];
        } while (b);

        // Set the offset for the table of the next square. We have individual
        // table sizes for each square with &quot;Fancy Magic Bitboards&quot;.
        if (s &lt; SQ_H8)
            attacks[s + 1] = attacks[s] + size;

        if (HasPext)
            continue;

        booster = MagicBoosters[Is64Bit][rank_of(s)];

        // Find a magic for square 's' picking up an (almost) random number
        // until we find the one that passes the verification test.
        do {
            do magics[s] = rk.magic_rand&lt;Bitboard&gt;(booster);
            while (popcount&lt;Max15&gt;((magics[s] * masks[s]) &gt;&gt; 56) &lt; 6);

            std::memset(attacks[s], 0, size * sizeof(Bitboard));

            // A good magic must map every possible occupancy to an index that
            // looks up the correct sliding attack in the attacks[s] database.
            // Note that we build up the database for square 's' as a side
            // effect of verifying the magic.
            for (i = 0; i &lt; size; ++i)
            {
                Bitboard&amp; attack = attacks[s][index(s, occupancy[i])];

                if (attack &amp;&amp; attack != reference[i])
                    break;

                assert(reference[i]);

                attack = reference[i];
            }
        } while (i &lt; size);
    }
  }
}
</PRE>
</div>
  </div>
</body>
</html>
