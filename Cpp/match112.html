<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for material.cpp &amp; bitboard_1.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for material.cpp &amp; bitboard_1.cpp
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>material.cpp (7.4626865%)<th>bitboard_1.cpp (5.597015%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(35-43)<td><a href="#" name="0">(185-186)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>material.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;  #include &lt;cassert&gt;
2 #include &lt;cstring&gt;
3 #include "material.h"
4 using namespace std;
5 namespace {
6 <a name="0"></a>    const int LinearCoefficients[6] = { 1852, -162, -1122, -183,  249, -154 };
7 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  const int QuadraticCoefficientsSameSide[][PIECE_TYPE_NB] = {
8     {   0                               },     {  39,    2                         },     {  35,  271,  -4                    },     {   0,  105,   4,    0              },     { -27,   -2,  46,   100,  -141      },     {-177,   25, 129,   142,  -137,   0 }    };
9   const int QuadraticCoefficientsOppositeSide[][PIECE_TYPE_NB] = {
10     {   0                               },     {  37,    0                         },     {  10,   62,   0                    },     {  57,   64,  39,     0             },     {  50,   40,  23,   -22,    0       },     {  98,  105, -39,   141,  274,    0 }    };
11   Endgame&lt;KXK&gt;   EvaluateKXK[]   = { Endgame&lt;KXK&gt;(WHITE),   Endgame&lt;KXK&gt;(BLACK) };
12   Endgame&lt;KBPsK&gt;  ScaleKBPsK[]  = { Endgame&lt;KBPsK&gt;(WHITE),  Endgame&lt;KBPsK&gt;(BLACK) };
13   Endgame&lt;KQKRPs&gt; ScaleKQKRPs[] = { Endgame&lt;KQKRPs&gt;(WHITE), Endgame&lt;KQKRPs&gt;(BLACK) };
14   Endgame&lt;KPsK&gt;   ScaleKPsK[]   = { Endgame&lt;KPsK&gt;(WHITE),   Endgame&lt;KPsK&gt;(BLACK) };
15   Endgame&lt;KPKP&gt;   ScaleKPKP[]   = { Endgame&lt;KPKP&gt;(WHITE),   Endgame&lt;KPKP&gt;(BLACK) };
16   template&lt;Color Us&gt; bool is_KXK(const Position&amp; pos) {
17     const Color Them = (Us == WHITE ? BLACK : WHITE);
18     return  !pos.count&lt;PAWN&gt;(Them)
19           &amp;&amp; pos.non_pawn_material(Them) == VALUE_ZERO
20           &amp;&amp; pos.non_pawn_material(Us) &gt;= RookValueMg;
21   }
22   template&lt;Color Us&gt; bool is_KBPsKs(const Position&amp; pos) {
23     return   pos.non_pawn_material(Us) == BishopValueMg
24           &amp;&amp; pos.count&lt;BISHOP&gt;(Us) == 1
25           &amp;&amp; pos.count&lt;PAWN  &gt;(Us) &gt;= 1;
26   }
27   template&lt;Color Us&gt; bool is_KQKRPs(const Position&amp; pos) {
28     const Color Them = (Us == WHITE ? BLACK : WHITE);
29     return  !pos.count&lt;PAWN&gt;(Us)
30           &amp;&amp; pos.non_pawn_material(Us) == QueenValueMg
31           &amp;&amp; pos.count&lt;QUEEN&gt;(Us)  == 1
32           &amp;&amp; pos.count&lt;ROOK&gt;(Them) == 1
33           &amp;&amp; pos.count&lt;PAWN&gt;(Them) &gt;= 1;
34   }
35   template&lt;Color Us&gt;
36   int imbalance(const int pieceCount[][PIECE_TYPE_NB]) {
37     const Color Them = (Us == WHITE ? BLACK : WHITE);
38     int pt1, pt2, pc, v;
39     int value = 0;
40     for (pt1 = NO_PIECE_TYPE; pt1 &lt;= QUEEN; ++pt1)
41     {
42         pc = pieceCount[Us][pt1];
43         if (!pc)
44             continue;
45         v = LinearCoefficients[pt1];
46         for (pt2 = NO_PIECE_TYPE; pt2 &lt;= pt1; ++pt2)
47             v +=  QuadraticCoefficientsSameSide[pt1][pt2] * pieceCount[Us][pt2]
48                 + QuadraticCoefficientsOppositeSide[pt1][pt2] * pieceCount[Them][pt2];
49         value += pc * v;
50     }
51     return value;
52   }
53 } 
54 namespace Material {
55 Entry* probe(const Position&amp; pos, Table&amp; entries, Endgames&amp; endgames) {
56   Key key = pos.material_key();
57   Entry* e = entries[key];
58   if (e-&gt;key == key)
59       return e;
60   std::memset(e, 0, sizeof(Entry));
61   e-&gt;key = key;
62   e-&gt;factor[WHITE] = e-&gt;factor[BLACK] = (uint8_t)SCALE_FACTOR_NORMAL;
63   e-&gt;gamePhase = game_phase(pos);
64   if (endgames.probe(key, e-&gt;evaluationFunction))
65       return e;
66   if (is_KXK&lt;WHITE&gt;(pos))
67   {
68       e-&gt;evaluationFunction = &amp;EvaluateKXK[WHITE];
69       return e;
70   }
71   if (is_KXK&lt;BLACK&gt;(pos))
72   {
73       e-&gt;evaluationFunction = &amp;EvaluateKXK[BLACK];
74       return e;
75   }
76   EndgameBase&lt;ScaleFactor&gt;* sf;
77   if (endgames.probe(key, sf))
78   {
79       e-&gt;scalingFunction[sf-&gt;color()] = sf;
80       return e;
81   }
82   if (is_KBPsKs&lt;WHITE&gt;(pos))
83       e-&gt;scalingFunction[WHITE] = &amp;ScaleKBPsK[WHITE];
84   if (is_KBPsKs&lt;BLACK&gt;(pos))
85       e-&gt;scalingFunction[BLACK] = &amp;ScaleKBPsK[BLACK];
86   if (is_KQKRPs&lt;WHITE&gt;(pos))
87       e-&gt;scalingFunction[WHITE] = &amp;ScaleKQKRPs[WHITE];
88   else if (is_KQKRPs&lt;BLACK&gt;(pos))
89       e-&gt;scalingFunction[BLACK] = &amp;ScaleKQKRPs[BLACK];
90   Value npm_w = pos.non_pawn_material(WHITE);
91   Value npm_b = pos.non_pawn_material(BLACK);
92   if (npm_w + npm_b == VALUE_ZERO &amp;&amp; pos.pieces(PAWN))
93   {
94       if (!pos.count&lt;PAWN&gt;(BLACK))
95       {
96           assert(pos.count&lt;PAWN&gt;(WHITE) &gt;= 2);
97           e-&gt;scalingFunction[WHITE] = &amp;ScaleKPsK[WHITE];
98       }
99       else if (!pos.count&lt;PAWN&gt;(WHITE))
100       {
101           assert(pos.count&lt;PAWN&gt;(BLACK) &gt;= 2);
102           e-&gt;scalingFunction[BLACK] = &amp;ScaleKPsK[BLACK];
103       }
104       else if (pos.count&lt;PAWN&gt;(WHITE) == 1 &amp;&amp; pos.count&lt;PAWN&gt;(BLACK) == 1)
105       {
106           e-&gt;scalingFunction[WHITE] = &amp;ScaleKPKP[WHITE];
107           e-&gt;scalingFunction[BLACK] = &amp;ScaleKPKP[BLACK];
108       }
109   }
110   if (!pos.count&lt;PAWN&gt;(WHITE) &amp;&amp; npm_w - npm_b &lt;= BishopValueMg)
111       e-&gt;factor[WHITE] = uint8_t(npm_w &lt; RookValueMg ? SCALE_FACTOR_DRAW : npm_b &lt;= BishopValueMg ? 4 : 12);
112   if (!pos.count&lt;PAWN&gt;(BLACK) &amp;&amp; npm_b - npm_w &lt;= BishopValueMg)
113       e-&gt;factor[BLACK] = uint8_t(npm_b &lt; RookValueMg ? SCALE_FACTOR_DRAW : npm_w &lt;= BishopValueMg ? 4 : 12);
114   if (pos.count&lt;PAWN&gt;(WHITE) == 1 &amp;&amp; npm_w - npm_b &lt;= BishopValueMg)
115       e-&gt;factor[WHITE] = (uint8_t) SCALE_FACTOR_ONEPAWN;
116   if (pos.count&lt;PAWN&gt;(BLACK) == 1 &amp;&amp; npm_b - npm_w &lt;= BishopValueMg)
117       e-&gt;factor[BLACK] = (uint8_t) SCALE_FACTOR_ONEPAWN;
118   if (npm_w + npm_b &gt;= 2 * QueenValueMg + 4 * RookValueMg + 2 * KnightValueMg)
119   {
120       int minorPieceCount =  pos.count&lt;KNIGHT&gt;(WHITE) + pos.count&lt;BISHOP&gt;(WHITE)
121                            + pos.count&lt;KNIGHT&gt;(BLACK) + pos.count&lt;BISHOP&gt;(BLACK);
122       e-&gt;spaceWeight = make_score(minorPieceCount * minorPieceCount, 0);
123   }
124   const int pieceCount[COLOR_NB][PIECE_TYPE_NB] = {
125   { pos.count&lt;BISHOP&gt;(WHITE) &gt; 1, pos.count&lt;PAWN&gt;(WHITE), pos.count&lt;KNIGHT&gt;(WHITE),
126     pos.count&lt;BISHOP&gt;(WHITE)    , pos.count&lt;ROOK&gt;(WHITE), pos.count&lt;QUEEN &gt;(WHITE) },
127   { pos.count&lt;BISHOP&gt;(BLACK) &gt; 1, pos.count&lt;PAWN&gt;(BLACK), pos.count&lt;KNIGHT&gt;(BLACK),
128     pos.count&lt;BISHOP&gt;(BLACK)    , pos.count&lt;ROOK&gt;(BLACK), pos.count&lt;QUEEN &gt;(BLACK) } };
129   e-&gt;value = (int16_t)((imbalance&lt;WHITE&gt;(pieceCount) - imbalance&lt;BLACK&gt;(pieceCount)) / 16);
130   return e;
131 }
132 Phase game_phase(const Position&amp; pos) {
133   Value npm = pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK);
134   return  npm &gt;= MidgameLimit ? PHASE_MIDGAME
135         : npm &lt;= EndgameLimit ? PHASE_ENDGAME
136         : Phase(((npm - EndgameLimit) * 128) / (MidgameLimit - EndgameLimit));
137 }
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bitboard_1.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cstring&gt; 
3 #include "bitboard.h"
4 #include "bitcount.h"
5 #include "rkiss.h"
6 CACHE_LINE_ALIGNMENT
7 Bitboard RMasks[SQUARE_NB];
8 Bitboard RMagics[SQUARE_NB];
9 Bitboard* RAttacks[SQUARE_NB];
10 unsigned RShifts[SQUARE_NB];
11 Bitboard BMasks[SQUARE_NB];
12 Bitboard BMagics[SQUARE_NB];
13 Bitboard* BAttacks[SQUARE_NB];
14 unsigned BShifts[SQUARE_NB];
15 Bitboard SquareBB[SQUARE_NB];
16 Bitboard FileBB[FILE_NB];
17 Bitboard RankBB[RANK_NB];
18 Bitboard AdjacentFilesBB[FILE_NB];
19 Bitboard InFrontBB[COLOR_NB][RANK_NB];
20 Bitboard StepAttacksBB[PIECE_NB][SQUARE_NB];
21 Bitboard BetweenBB[SQUARE_NB][SQUARE_NB];
22 Bitboard LineBB[SQUARE_NB][SQUARE_NB];
23 Bitboard DistanceRingsBB[SQUARE_NB][8];
24 Bitboard ForwardBB[COLOR_NB][SQUARE_NB];
25 Bitboard PassedPawnMask[COLOR_NB][SQUARE_NB];
26 Bitboard PawnAttackSpan[COLOR_NB][SQUARE_NB];
27 Bitboard PseudoAttacks[PIECE_TYPE_NB][SQUARE_NB];
28 int SquareDistance[SQUARE_NB][SQUARE_NB];
29 namespace {
30   const uint64_t DeBruijn_64 = 0x3F79D71B4CB0A89ULL;
31   const uint32_t DeBruijn_32 = 0x783A9B23;
32   CACHE_LINE_ALIGNMENT
33   int MS1BTable[256];
34   Square BSFTable[SQUARE_NB];
35   Bitboard RTable[0x19000];   Bitboard BTable[0x1480];  
36   typedef unsigned (Fn)(Square, Bitboard);
37   void init_magics(Bitboard table[], Bitboard* attacks[], Bitboard magics[],
38                    Bitboard masks[], unsigned shifts[], Square deltas[], Fn index);
39   FORCE_INLINE unsigned bsf_index(Bitboard b) {
40     b ^= (b - 1);
41     return Is64Bit ? (b * DeBruijn_64) &gt;&gt; 58
42                    : ((unsigned(b) ^ unsigned(b &gt;&gt; 32)) * DeBruijn_32) &gt;&gt; 26;
43   }
44 }
45 #ifndef USE_BSFQ
46 Square lsb(Bitboard b) { return BSFTable[bsf_index(b)]; }
47 Square pop_lsb(Bitboard* b) {
48   Bitboard bb = *b;
49   *b = bb &amp; (bb - 1);
50   return BSFTable[bsf_index(bb)];
51 }
52 Square msb(Bitboard b) {
53   unsigned b32;
54   int result = 0;
55   if (b &gt; 0xFFFFFFFF)
56   {
57       b &gt;&gt;= 32;
58       result = 32;
59   }
60   b32 = unsigned(b);
61   if (b32 &gt; 0xFFFF)
62   {
63       b32 &gt;&gt;= 16;
64       result += 16;
65   }
66   if (b32 &gt; 0xFF)
67   {
68       b32 &gt;&gt;= 8;
69       result += 8;
70   }
71   return Square(result + MS1BTable[b32]);
72 }
73 #endif 
74 const std::string Bitboards::pretty(Bitboard b) {
75   std::string s = "+---+---+---+---+---+---+---+---+\n";
76   for (Rank r = RANK_8; r &gt;= RANK_1; --r)
77   {
78       for (File f = FILE_A; f &lt;= FILE_H; ++f)
79           s.append(b &amp; make_square(f, r) ? "| X " : "|   ");
80       s.append("|\n+---+---+---+---+---+---+---+---+\n");
81   }
82   return s;
83 }
84 void Bitboards::init() {
85   for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
86       BSFTable[bsf_index(SquareBB[s] = 1ULL &lt;&lt; s)] = s;
87   for (Bitboard b = 1; b &lt; 256; ++b)
88       MS1BTable[b] = more_than_one(b) ? MS1BTable[b - 1] : lsb(b);
89   for (File f = FILE_A; f &lt;= FILE_H; ++f)
90       FileBB[f] = f &gt; FILE_A ? FileBB[f - 1] &lt;&lt; 1 : FileABB;
91   for (Rank r = RANK_1; r &lt;= RANK_8; ++r)
92       RankBB[r] = r &gt; RANK_1 ? RankBB[r - 1] &lt;&lt; 8 : Rank1BB;
93   for (File f = FILE_A; f &lt;= FILE_H; ++f)
94       AdjacentFilesBB[f] = (f &gt; FILE_A ? FileBB[f - 1] : 0) | (f &lt; FILE_H ? FileBB[f + 1] : 0);
95   for (Rank r = RANK_1; r &lt; RANK_8; ++r)
96       InFrontBB[WHITE][r] = ~(InFrontBB[BLACK][r + 1] = InFrontBB[BLACK][r] | RankBB[r]);
97   for (Color c = WHITE; c &lt;= BLACK; ++c)
98       for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
99       {
100           ForwardBB[c][s]      = InFrontBB[c][rank_of(s)] &amp; FileBB[file_of(s)];
101           PawnAttackSpan[c][s] = InFrontBB[c][rank_of(s)] &amp; AdjacentFilesBB[file_of(s)];
102           PassedPawnMask[c][s] = ForwardBB[c][s] | PawnAttackSpan[c][s];
103       }
104   for (Square s1 = SQ_A1; s1 &lt;= SQ_H8; ++s1)
105       for (Square s2 = SQ_A1; s2 &lt;= SQ_H8; ++s2)
106           if (s1 != s2)
107           {
108               SquareDistance[s1][s2] = std::max(file_distance(s1, s2), rank_distance(s1, s2));
109 <a name="0"></a>              DistanceRingsBB[s1][SquareDistance[s1][s2] - 1] |= s2;
110           }
111 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int steps[][9] = { {}, { 7, 9 }, { 17, 15, 10, 6, -6, -10, -15, -17 },
112                      {}, {}, {}, { 9, 7, -7, -9, 8, 1, -1, -8 } };</b></font>
113   for (Color c = WHITE; c &lt;= BLACK; ++c)
114       for (PieceType pt = PAWN; pt &lt;= KING; ++pt)
115           for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
116               for (int i = 0; steps[pt][i]; ++i)
117               {
118                   Square to = s + Square(c == WHITE ? steps[pt][i] : -steps[pt][i]);
119                   if (is_ok(to) &amp;&amp; square_distance(s, to) &lt; 3)
120                       StepAttacksBB[make_piece(c, pt)][s] |= to;
121               }
122   Square RDeltas[] = { DELTA_N,  DELTA_E,  DELTA_S,  DELTA_W  };
123   Square BDeltas[] = { DELTA_NE, DELTA_SE, DELTA_SW, DELTA_NW };
124   init_magics(RTable, RAttacks, RMagics, RMasks, RShifts, RDeltas, magic_index&lt;ROOK&gt;);
125   init_magics(BTable, BAttacks, BMagics, BMasks, BShifts, BDeltas, magic_index&lt;BISHOP&gt;);
126   for (Square s1 = SQ_A1; s1 &lt;= SQ_H8; ++s1)
127   {
128       PseudoAttacks[QUEEN][s1]  = PseudoAttacks[BISHOP][s1] = attacks_bb&lt;BISHOP&gt;(s1, 0);
129       PseudoAttacks[QUEEN][s1] |= PseudoAttacks[  ROOK][s1] = attacks_bb&lt;  ROOK&gt;(s1, 0);
130       for (Square s2 = SQ_A1; s2 &lt;= SQ_H8; ++s2)
131       {
132           Piece pc = (PseudoAttacks[BISHOP][s1] &amp; s2) ? W_BISHOP :
133                      (PseudoAttacks[ROOK][s1]   &amp; s2) ? W_ROOK   : NO_PIECE;
134           if (pc == NO_PIECE)
135               continue;
136           LineBB[s1][s2] = (attacks_bb(pc, s1, 0) &amp; attacks_bb(pc, s2, 0)) | s1 | s2;
137           BetweenBB[s1][s2] = attacks_bb(pc, s1, SquareBB[s2]) &amp; attacks_bb(pc, s2, SquareBB[s1]);
138       }
139   }
140 }
141 namespace {
142   Bitboard sliding_attack(Square deltas[], Square sq, Bitboard occupied) {
143     Bitboard attack = 0;
144     for (int i = 0; i &lt; 4; ++i)
145         for (Square s = sq + deltas[i];
146              is_ok(s) &amp;&amp; square_distance(s, s - deltas[i]) == 1;
147              s += deltas[i])
148         {
149             attack |= s;
150             if (occupied &amp; s)
151                 break;
152         }
153     return attack;
154   }
155   void init_magics(Bitboard table[], Bitboard* attacks[], Bitboard magics[],
156                    Bitboard masks[], unsigned shifts[], Square deltas[], Fn index) {
157     int MagicBoosters[][8] = { {  969, 1976, 2850,  542, 2069, 2852, 1708,  164 },
158                                { 3101,  552, 3555,  926,  834,   26, 2131, 1117 } };
159     RKISS rk;
160     Bitboard occupancy[4096], reference[4096], edges, b;
161     int i, size, booster;
162     attacks[SQ_A1] = table;
163     for (Square s = SQ_A1; s &lt;= SQ_H8; ++s)
164     {
165         edges = ((Rank1BB | Rank8BB) &amp; ~rank_bb(s)) | ((FileABB | FileHBB) &amp; ~file_bb(s));
166         masks[s]  = sliding_attack(deltas, s, 0) &amp; ~edges;
167         shifts[s] = (Is64Bit ? 64 : 32) - popcount&lt;Max15&gt;(masks[s]);
168         b = size = 0;
169         do {
170             occupancy[size] = b;
171             reference[size] = sliding_attack(deltas, s, b);
172             if (HasPext)
173                 attacks[s][_pext_u64(b, masks[s])] = reference[size];
174             size++;
175             b = (b - masks[s]) &amp; masks[s];
176         } while (b);
177         if (s &lt; SQ_H8)
178             attacks[s + 1] = attacks[s] + size;
179         if (HasPext)
180             continue;
181         booster = MagicBoosters[Is64Bit][rank_of(s)];
182         do {
183             do magics[s] = rk.magic_rand&lt;Bitboard&gt;(booster);
184             while (popcount&lt;Max15&gt;((magics[s] * masks[s]) &gt;&gt; 56) &lt; 6);
185             std::memset(attacks[s], 0, size * sizeof(Bitboard));
186             for (i = 0; i &lt; size; ++i)
187             {
188                 Bitboard&amp; attack = attacks[s][index(s, occupancy[i])];
189                 if (attack &amp;&amp; attack != reference[i])
190                     break;
191                 assert(reference[i]);
192                 attack = reference[i];
193             }
194         } while (i &lt; size);
195     }
196   }
197 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
