
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphcounter.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "graphcounter.h"
3  int TD3Graph::m_numOfGraphs = 13;
4  int TD3Graph::m_graphIds[] = {6,12,14,36,38,46,78,102,140,164,166,174,238};
5  int TD3Graph::getId(const PNGraph &G, const TIntV &sg) {
6  	int id=0;
7  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[1])) id+=2;
8  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[2])) id+=4;
9  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[0])) id+=8;
10  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[2])) id+=32;
11  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[0])) id+=64;
12  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[1])) id+=128;
13  	return id;
14  }
15  int TD4Graph::m_numOfGraphs = 199;
16  int TD4Graph::m_graphIds[] = {14, 28, 30, 74, 76, 78, 90, 92, 94, 204, 206, 222, 280, 282, 286, 
17  								328, 330, 332, 334, 344, 346, 348, 350, 390, 392, 394, 396, 398, 
18  								404, 406, 408, 410, 412, 414, 454, 456, 458, 460, 462, 468, 470, 
19  								472, 474, 476, 478, 856, 858, 862, 904, 906, 908, 910, 922, 924, 
20  								926, 972, 974, 990, 2184, 2186, 2190, 2202, 2204, 2206, 2252, 2254, 
21  								2270, 2458, 2462, 2506, 2510, 2524, 2526, 3038, 4370, 4374, 4382, 
22  								4418, 4420, 4422, 4424, 4426, 4428, 4430, 4434, 4436, 4438, 4440, 
23  								4442, 4444, 4446, 4546, 4548, 4550, 4556, 4558, 4562, 4564, 4566, 
24  								4572, 4574, 4678, 4682, 4686, 4692, 4694, 4698, 4700, 4702, 4740, 
25  								4742, 4748, 4750, 4758, 4764, 4766, 4812, 4814, 4830, 4946, 4950, 
26  								4952, 4954, 4958, 4994, 4998, 5002, 5004, 5006, 5010, 5012, 5014, 
27  								5016, 5018, 5020, 5022, 5058, 5062, 5064, 5066, 5068, 5070, 5074, 
28  								5076, 5078, 5080, 5082, 5084, 5086, 6342, 6348, 6350, 6356, 6358, 
29  								6364, 6366, 6550, 6552, 6554, 6558, 6598, 6602, 6604, 6606, 6614, 
30  								6616, 6618, 6620, 6622, 6854, 6858, 6862, 6870, 6874, 6876, 6878, 
31  								7126, 7128, 7130, 7134, 13142, 13146, 13148, 13150, 13260, 13262, 
32  								13278, 14678, 14686, 14790, 14798, 14810, 14812, 14814, 15258, 
33  								15262, 15310, 15326, 31710 };
34  int TD4Graph::getId(const PNGraph &G, const TIntV &sg) {
35  	int id=0;
36  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[1])) id+=2;
37  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[2])) id+=4;
38  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[3])) id+=8;
39  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[0])) id+=16;
40  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[2])) id+=64;
41  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[3])) id+=128;
42  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[0])) id+=256;
43  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[1])) id+=512;
44  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[3])) id+=2048;
45  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[0])) id+=4096;
46  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[1])) id+=8192;
47  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[2])) id+=16384;
48  	return id;
49  }
50  TD34GraphCounter::TD34GraphCounter(int GraphSz) {
51  	IAssert(GraphSz==3 || GraphSz==4);
52  	m_subGraphSize = GraphSz;
53  	int numOfGraphs = 0;
54  	if(GraphSz==3) numOfGraphs = TD3Graph::m_numOfGraphs;
55  	else if(GraphSz==4) numOfGraphs = TD4Graph::m_numOfGraphs;
56  	for(int i=0; i<numOfGraphs; i++) {
57  		int graphId = 0;
58  		if(GraphSz==3) graphId = TD3Graph::m_graphIds[i];
59  		else if(GraphSz==4) graphId = TD4Graph::m_graphIds[i];
60  		TVec<PNGraph> isoG;
61  		TGraphEnumUtils::GetIsoGraphs(graphId, GraphSz, isoG);
62  		TVec<uint64> graphIds(isoG.Len());
63  		uint64 minGraphId = TGraphEnumUtils::GetMinAndGraphIds(isoG, graphIds);
64  		for(int j=0; j<graphIds.Len(); j++)
65  			m_graphMaps.AddDat((int)graphIds[j], (int)minGraphId);
66  		m_graphCounters.AddDat((int)minGraphId, 0);
67  	}
68  }
69  void TD34GraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
70  	int graphId = 0;
71  	if(m_subGraphSize==3) graphId = TD3Graph::getId(G, sg);
72  	else if(m_subGraphSize==4) graphId = TD4Graph::getId(G, sg);
73  	if(!m_graphMaps.IsKey(graphId)) { printf("This graph does not exist: %d\n", graphId); getchar(); return; }
74  	int minGraphId = m_graphMaps.GetDat(graphId);
75  	m_graphCounters.GetDat(minGraphId)++;
76  }
77  PNGraph TD34GraphCounter::GetGraph(const int& GraphId) const {
<span onclick='openModal()' class='match'>78    PNGraph G = TNGraph::New();
79    TGraphEnumUtils::GetGraph(GraphId, m_subGraphSize, G);
80    return G;
</span>81  }
82  void TDGraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
83  	uint64 graphId = TGraphEnumUtils::GraphId(G, sg);
84  	if(m_graphMaps.IsKey(graphId)) {
85  		TUInt64 minGraphId = m_graphMaps.GetDat(graphId);
86  		m_graphCounters.GetDat(minGraphId)++;
87  	}else{
88  		TVec<PNGraph> isoG;
89  		TGraphEnumUtils::GetIsoGraphs(graphId, sg.Len(), isoG);
90  		TVec<uint64> graphIds(isoG.Len());
91  		uint64 minGraphId = TGraphEnumUtils::GetMinAndGraphIds(isoG, graphIds);
92  		for(int j=0; j<graphIds.Len(); j++)
93  			m_graphMaps.AddDat(graphIds[j], minGraphId);
94  		m_graphCounters.AddDat(minGraphId, 1);
95  	}
96  }
97  void TDGHashGraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
98  	PNGraph indG = TNGraph::New();
99  	TGraphEnumUtils::GetIndGraph(G, sg, indG);
100  	if(m_graphs.IsKey(indG))
101  		m_graphs.GetDat(indG)++;
102  	else m_graphs.AddDat(indG, 1);
103  }
104  void TGraphEnumUtils::GetNormalizedMap(const PNGraph &G, THash<TInt,TInt> &map) {
105  	int nId=0;
106  	for(TNGraph::TNodeI it=G->BegNI(); it<G->EndNI(); it++) {
107  		map.AddDat(it.GetId(), nId);
108  		nId++;
109  	}
110  }
111  void TGraphEnumUtils::GetPermutations(TIntV &v, int start, TVec<TIntV> &perms) {
112  	int n = v.Len();
113  	if (start == n-1) perms.Add(v);
114  	else {
115  		for (int i = start; i < n; i++) {
116  			int tmp = v[i];
117  			v[i] = v[start];
118  			v[start] = tmp;
119  			GetPermutations(v, start+1, perms);
120  			v[start] = v[i];
121  			v[i] = tmp;
122  		}
123  	}
124  }
125  void TGraphEnumUtils::GetNormalizedGraph(const PNGraph &G, PNGraph &nG) {
126  	THash<TInt,TInt> map;
127  	GetNormalizedMap(G, map);
128  	for(int i=0; i<G->GetNodes(); i++) nG->AddNode(i);
129  	for(TNGraph::TEdgeI eIt=G->BegEI(); eIt<G->EndEI(); eIt++) {
130  		int srcId = eIt.GetSrcNId();
131  		int dstId = eIt.GetDstNId();
132  		int mSrcId = map.GetDat(srcId);
133  		int mDstId = map.GetDat(dstId);
134  		nG->AddEdge(mSrcId, mDstId);
135  	}
136  }
137  void TGraphEnumUtils::GetEdges(uint64 graphId, int nodes, TVec<TPair<int,int> > &edges) {
138  	for(int row=0; row<nodes; row++) {
139  		for(int col=0; col<nodes; col++) {
140  			int n = row*nodes+col;
141  			uint64 bits = graphId >> n;
142  			uint64 mask = 1;
143  			if((bits & mask)==1) edges.Add(TPair<int,int>(row, col));
144  		}
145  	}
146  }
147  void TGraphEnumUtils::GetIsoGraphs(uint64 graphId, int nodes, TVec<PNGraph> &isoG) {
148  	TIntV v(nodes); for(int i=0; i<nodes; i++) v[i]=i;
149  	TVec<TIntV> perms; GetPermutations(v, 0, perms);
150  	isoG.Gen(perms.Len());
151  	TVec<TPair<int,int> > edges;
152  	GetEdges(graphId, nodes, edges);
153  	for(int i=0; i<perms.Len(); i++) {
154  		isoG[i] = TNGraph::New();
155  		for(int j=0; j<nodes; j++) isoG[i]->AddNode(j);
156  		for(int j=0; j<edges.Len(); j++) {
157  			int srcId = edges[j].Val1;
158  			int dstId = edges[j].Val2;
159  			int pSrcId = perms[i][srcId];
160  			int pDstId = perms[i][dstId];
161  			isoG[i]->AddEdge(pSrcId, pDstId);
162  		}
163  	}
164  }
165  void TGraphEnumUtils::GetIsoGraphs(const PNGraph &G, TVec<PNGraph> &isoG) {
166  	int nodes = G->GetNodes();
167  	TIntV v(nodes); for(int i=0; i<nodes; i++) v[i]=i;
168  	TVec<TIntV> perms; GetPermutations(v, 0, perms);
169  	isoG.Gen(perms.Len());
170  	for(int i=0; i<perms.Len(); i++) {
171  		isoG[i] = TNGraph::New();
172  		for(int j=0; j<nodes; j++) isoG[i]->AddNode(j);
173  		for(TNGraph::TEdgeI eIt=G->BegEI(); eIt<G->EndEI(); eIt++) {
174  			int srcId = eIt.GetSrcNId();
175  			int dstId = eIt.GetDstNId();
176  			int pSrcId = perms[i][srcId];
177  			int pDstId = perms[i][dstId];
178  			isoG[i]->AddEdge(pSrcId, pDstId);
179  		}
180  	}
181  }
182  void TGraphEnumUtils::GetIndGraph(const PNGraph &G, const TIntV &sg, PNGraph &indG) {
183  	for(int i=0; i<sg.Len(); i++) indG->AddNode(sg[i]);
184  	for(int i=0; i<sg.Len(); i++) {
185  		int nId = sg[i];
186  		TNGraph::TNodeI nIt = G->GetNI(nId);
187  		int deg = nIt.GetOutDeg();
188  		for(int j=0; j<deg; j++) {
189  			int dstId = nIt.GetNbrNId(j);
190  			if(nId == dstId) continue;
191  			if(indG->IsNode(dstId)) indG->AddEdge(nId, dstId);
192  		}
193  	}
194  }
195  void TGraphEnumUtils::GetGraph(uint64 graphId, int nodes, PNGraph &G) {
196    G->Clr();
197  	for(int i=0; i<nodes; i++) G->AddNode(i);
198  	for(int row=0; row<nodes; row++) {
199  		for(int col=0; col<nodes; col++) {
200  			int n = row*nodes+col;
201  			uint64 bits = graphId >> n;
202  			uint64 mask = 1;
203  			if((bits & mask)==1) G->AddEdge(row, col);
204  		}
205  	}
206  }
207  uint64 TGraphEnumUtils::GraphId(const PNGraph &G) {
208  	int nodes = G->GetNodes();
209  	uint64 id=0;
210  	for(TNGraph::TEdgeI it=G->BegEI(); it<G->EndEI(); it++) {
211  		int srcId = it.GetSrcNId();
212  		int dstId = it.GetDstNId();
213  		id += TMath::Pow2(srcId*nodes + dstId);
214  	}
215  	return id;
216  }
217  uint64 TGraphEnumUtils::GraphId(const PNGraph &G, const TIntV &sg) {
218  	int nodes = sg.Len();
219  	uint64 graphId = 0;
220  	for(int i=0; i<nodes; i++) {
221  		for(int j=0; j<nodes; j++) {
222  			if(i==j) continue;
223  			if(TGraphEnumUtils::IsEdge(G, sg[i], sg[j])) graphId+=TMath::Pow2(i*nodes + j);
224  		}
225  	}
226  	return graphId;
227  }
228  uint64 TGraphEnumUtils::GetMinAndGraphIds(const TVec<PNGraph> &isoG, TVec<uint64> &graphIds) {
229  	IAssert(isoG.Len() > 0);
230  	uint64 minGraphId = GraphId(isoG[0]);
231  	graphIds.Add(minGraphId);
232  	for(int i=1; i<isoG.Len(); i++) {
233  		uint64 curGraphId = GraphId(isoG[i]);
234  		if(minGraphId > curGraphId) minGraphId=curGraphId;
235  		graphIds.Add(curGraphId);
236  	}
237  	return minGraphId;
238  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphcounter.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "graphcounter.h"
3  int TD3Graph::m_numOfGraphs = 13;
4  int TD3Graph::m_graphIds[] = {6,12,14,36,38,46,78,102,140,164,166,174,238};
5  int TD3Graph::getId(const PNGraph &G, const TIntV &sg) {
6  	int id=0;
7  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[1])) id+=2;
8  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[2])) id+=4;
9  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[0])) id+=8;
10  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[2])) id+=32;
11  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[0])) id+=64;
12  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[1])) id+=128;
13  	return id;
14  }
15  int TD4Graph::m_numOfGraphs = 199;
16  int TD4Graph::m_graphIds[] = {14, 28, 30, 74, 76, 78, 90, 92, 94, 204, 206, 222, 280, 282, 286, 
17  								328, 330, 332, 334, 344, 346, 348, 350, 390, 392, 394, 396, 398, 
18  								404, 406, 408, 410, 412, 414, 454, 456, 458, 460, 462, 468, 470, 
19  								472, 474, 476, 478, 856, 858, 862, 904, 906, 908, 910, 922, 924, 
20  								926, 972, 974, 990, 2184, 2186, 2190, 2202, 2204, 2206, 2252, 2254, 
21  								2270, 2458, 2462, 2506, 2510, 2524, 2526, 3038, 4370, 4374, 4382, 
22  								4418, 4420, 4422, 4424, 4426, 4428, 4430, 4434, 4436, 4438, 4440, 
23  								4442, 4444, 4446, 4546, 4548, 4550, 4556, 4558, 4562, 4564, 4566, 
24  								4572, 4574, 4678, 4682, 4686, 4692, 4694, 4698, 4700, 4702, 4740, 
25  								4742, 4748, 4750, 4758, 4764, 4766, 4812, 4814, 4830, 4946, 4950, 
26  								4952, 4954, 4958, 4994, 4998, 5002, 5004, 5006, 5010, 5012, 5014, 
27  								5016, 5018, 5020, 5022, 5058, 5062, 5064, 5066, 5068, 5070, 5074, 
28  								5076, 5078, 5080, 5082, 5084, 5086, 6342, 6348, 6350, 6356, 6358, 
29  								6364, 6366, 6550, 6552, 6554, 6558, 6598, 6602, 6604, 6606, 6614, 
30  								6616, 6618, 6620, 6622, 6854, 6858, 6862, 6870, 6874, 6876, 6878, 
31  								7126, 7128, 7130, 7134, 13142, 13146, 13148, 13150, 13260, 13262, 
32  								13278, 14678, 14686, 14790, 14798, 14810, 14812, 14814, 15258, 
33  								15262, 15310, 15326, 31710 };
34  int TD4Graph::getId(const PNGraph &G, const TIntV &sg) {
35  	int id=0;
36  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[1])) id+=2;
37  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[2])) id+=4;
38  	if(TGraphEnumUtils::IsEdge(G, sg[0], sg[3])) id+=8;
39  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[0])) id+=16;
40  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[2])) id+=64;
41  	if(TGraphEnumUtils::IsEdge(G, sg[1], sg[3])) id+=128;
42  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[0])) id+=256;
43  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[1])) id+=512;
44  	if(TGraphEnumUtils::IsEdge(G, sg[2], sg[3])) id+=2048;
45  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[0])) id+=4096;
46  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[1])) id+=8192;
47  	if(TGraphEnumUtils::IsEdge(G, sg[3], sg[2])) id+=16384;
48  	return id;
49  }
50  TD34GraphCounter::TD34GraphCounter(int GraphSz) {
51  	IAssert(GraphSz==3 || GraphSz==4);
52  	m_subGraphSize = GraphSz;
53  	int numOfGraphs = 0;
54  	if(GraphSz==3) numOfGraphs = TD3Graph::m_numOfGraphs;
55  	else if(GraphSz==4) numOfGraphs = TD4Graph::m_numOfGraphs;
56  	for(int i=0; i<numOfGraphs; i++) {
57  		int graphId = 0;
58  		if(GraphSz==3) graphId = TD3Graph::m_graphIds[i];
59  		else if(GraphSz==4) graphId = TD4Graph::m_graphIds[i];
60  		TVec<PNGraph> isoG;
61  		TGraphEnumUtils::GetIsoGraphs(graphId, GraphSz, isoG);
62  		TVec<uint64> graphIds(isoG.Len());
63  		uint64 minGraphId = TGraphEnumUtils::GetMinAndGraphIds(isoG, graphIds);
64  		for(int j=0; j<graphIds.Len(); j++)
65  			m_graphMaps.AddDat((int)graphIds[j], (int)minGraphId);
66  		m_graphCounters.AddDat((int)minGraphId, 0);
67  	}
68  }
69  void TD34GraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
70  	int graphId = 0;
71  	if(m_subGraphSize==3) graphId = TD3Graph::getId(G, sg);
72  	else if(m_subGraphSize==4) graphId = TD4Graph::getId(G, sg);
73  	if(!m_graphMaps.IsKey(graphId)) { printf("This graph does not exist: %d\n", graphId); getchar(); return; }
74  	int minGraphId = m_graphMaps.GetDat(graphId);
75  	m_graphCounters.GetDat(minGraphId)++;
76  }
77  PNGraph TD34GraphCounter::GetGraph(const int& GraphId) const {
78    PNGraph G = TNGraph::New();
79    TGraphEnumUtils::GetGraph(GraphId, m_subGraphSize, G);
80    return G;
81  }
82  void TDGraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
83  	uint64 graphId = TGraphEnumUtils::GraphId(G, sg);
84  	if(m_graphMaps.IsKey(graphId)) {
85  		TUInt64 minGraphId = m_graphMaps.GetDat(graphId);
86  		m_graphCounters.GetDat(minGraphId)++;
87  	}else{
88  		TVec<PNGraph> isoG;
89  		TGraphEnumUtils::GetIsoGraphs(graphId, sg.Len(), isoG);
90  		TVec<uint64> graphIds(isoG.Len());
91  		uint64 minGraphId = TGraphEnumUtils::GetMinAndGraphIds(isoG, graphIds);
92  		for(int j=0; j<graphIds.Len(); j++)
93  			m_graphMaps.AddDat(graphIds[j], minGraphId);
94  		m_graphCounters.AddDat(minGraphId, 1);
95  	}
96  }
97  void TDGHashGraphCounter::operator()(const PNGraph &G, const TIntV &sg) {
<span onclick='openModal()' class='match'>98  	PNGraph indG = TNGraph::New();
99  	TGraphEnumUtils::GetIndGraph(G, sg, indG);
100  	if(m_graphs.IsKey(indG))
</span>101  		m_graphs.GetDat(indG)++;
102  	else m_graphs.AddDat(indG, 1);
103  }
104  void TGraphEnumUtils::GetNormalizedMap(const PNGraph &G, THash<TInt,TInt> &map) {
105  	int nId=0;
106  	for(TNGraph::TNodeI it=G->BegNI(); it<G->EndNI(); it++) {
107  		map.AddDat(it.GetId(), nId);
108  		nId++;
109  	}
110  }
111  void TGraphEnumUtils::GetPermutations(TIntV &v, int start, TVec<TIntV> &perms) {
112  	int n = v.Len();
113  	if (start == n-1) perms.Add(v);
114  	else {
115  		for (int i = start; i < n; i++) {
116  			int tmp = v[i];
117  			v[i] = v[start];
118  			v[start] = tmp;
119  			GetPermutations(v, start+1, perms);
120  			v[start] = v[i];
121  			v[i] = tmp;
122  		}
123  	}
124  }
125  void TGraphEnumUtils::GetNormalizedGraph(const PNGraph &G, PNGraph &nG) {
126  	THash<TInt,TInt> map;
127  	GetNormalizedMap(G, map);
128  	for(int i=0; i<G->GetNodes(); i++) nG->AddNode(i);
129  	for(TNGraph::TEdgeI eIt=G->BegEI(); eIt<G->EndEI(); eIt++) {
130  		int srcId = eIt.GetSrcNId();
131  		int dstId = eIt.GetDstNId();
132  		int mSrcId = map.GetDat(srcId);
133  		int mDstId = map.GetDat(dstId);
134  		nG->AddEdge(mSrcId, mDstId);
135  	}
136  }
137  void TGraphEnumUtils::GetEdges(uint64 graphId, int nodes, TVec<TPair<int,int> > &edges) {
138  	for(int row=0; row<nodes; row++) {
139  		for(int col=0; col<nodes; col++) {
140  			int n = row*nodes+col;
141  			uint64 bits = graphId >> n;
142  			uint64 mask = 1;
143  			if((bits & mask)==1) edges.Add(TPair<int,int>(row, col));
144  		}
145  	}
146  }
147  void TGraphEnumUtils::GetIsoGraphs(uint64 graphId, int nodes, TVec<PNGraph> &isoG) {
148  	TIntV v(nodes); for(int i=0; i<nodes; i++) v[i]=i;
149  	TVec<TIntV> perms; GetPermutations(v, 0, perms);
150  	isoG.Gen(perms.Len());
151  	TVec<TPair<int,int> > edges;
152  	GetEdges(graphId, nodes, edges);
153  	for(int i=0; i<perms.Len(); i++) {
154  		isoG[i] = TNGraph::New();
155  		for(int j=0; j<nodes; j++) isoG[i]->AddNode(j);
156  		for(int j=0; j<edges.Len(); j++) {
157  			int srcId = edges[j].Val1;
158  			int dstId = edges[j].Val2;
159  			int pSrcId = perms[i][srcId];
160  			int pDstId = perms[i][dstId];
161  			isoG[i]->AddEdge(pSrcId, pDstId);
162  		}
163  	}
164  }
165  void TGraphEnumUtils::GetIsoGraphs(const PNGraph &G, TVec<PNGraph> &isoG) {
166  	int nodes = G->GetNodes();
167  	TIntV v(nodes); for(int i=0; i<nodes; i++) v[i]=i;
168  	TVec<TIntV> perms; GetPermutations(v, 0, perms);
169  	isoG.Gen(perms.Len());
170  	for(int i=0; i<perms.Len(); i++) {
171  		isoG[i] = TNGraph::New();
172  		for(int j=0; j<nodes; j++) isoG[i]->AddNode(j);
173  		for(TNGraph::TEdgeI eIt=G->BegEI(); eIt<G->EndEI(); eIt++) {
174  			int srcId = eIt.GetSrcNId();
175  			int dstId = eIt.GetDstNId();
176  			int pSrcId = perms[i][srcId];
177  			int pDstId = perms[i][dstId];
178  			isoG[i]->AddEdge(pSrcId, pDstId);
179  		}
180  	}
181  }
182  void TGraphEnumUtils::GetIndGraph(const PNGraph &G, const TIntV &sg, PNGraph &indG) {
183  	for(int i=0; i<sg.Len(); i++) indG->AddNode(sg[i]);
184  	for(int i=0; i<sg.Len(); i++) {
185  		int nId = sg[i];
186  		TNGraph::TNodeI nIt = G->GetNI(nId);
187  		int deg = nIt.GetOutDeg();
188  		for(int j=0; j<deg; j++) {
189  			int dstId = nIt.GetNbrNId(j);
190  			if(nId == dstId) continue;
191  			if(indG->IsNode(dstId)) indG->AddEdge(nId, dstId);
192  		}
193  	}
194  }
195  void TGraphEnumUtils::GetGraph(uint64 graphId, int nodes, PNGraph &G) {
196    G->Clr();
197  	for(int i=0; i<nodes; i++) G->AddNode(i);
198  	for(int row=0; row<nodes; row++) {
199  		for(int col=0; col<nodes; col++) {
200  			int n = row*nodes+col;
201  			uint64 bits = graphId >> n;
202  			uint64 mask = 1;
203  			if((bits & mask)==1) G->AddEdge(row, col);
204  		}
205  	}
206  }
207  uint64 TGraphEnumUtils::GraphId(const PNGraph &G) {
208  	int nodes = G->GetNodes();
209  	uint64 id=0;
210  	for(TNGraph::TEdgeI it=G->BegEI(); it<G->EndEI(); it++) {
211  		int srcId = it.GetSrcNId();
212  		int dstId = it.GetDstNId();
213  		id += TMath::Pow2(srcId*nodes + dstId);
214  	}
215  	return id;
216  }
217  uint64 TGraphEnumUtils::GraphId(const PNGraph &G, const TIntV &sg) {
218  	int nodes = sg.Len();
219  	uint64 graphId = 0;
220  	for(int i=0; i<nodes; i++) {
221  		for(int j=0; j<nodes; j++) {
222  			if(i==j) continue;
223  			if(TGraphEnumUtils::IsEdge(G, sg[i], sg[j])) graphId+=TMath::Pow2(i*nodes + j);
224  		}
225  	}
226  	return graphId;
227  }
228  uint64 TGraphEnumUtils::GetMinAndGraphIds(const TVec<PNGraph> &isoG, TVec<uint64> &graphIds) {
229  	IAssert(isoG.Len() > 0);
230  	uint64 minGraphId = GraphId(isoG[0]);
231  	graphIds.Add(minGraphId);
232  	for(int i=1; i<isoG.Len(); i++) {
233  		uint64 curGraphId = GraphId(isoG[i]);
234  		if(minGraphId > curGraphId) minGraphId=curGraphId;
235  		graphIds.Add(curGraphId);
236  	}
237  	return minGraphId;
238  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphcounter.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphcounter.cpp</div>
                </div>
                <div class="column column_space"><pre><code>78    PNGraph G = TNGraph::New();
79    TGraphEnumUtils::GetGraph(GraphId, m_subGraphSize, G);
80    return G;
</pre></code></div>
                <div class="column column_space"><pre><code>98  	PNGraph indG = TNGraph::New();
99  	TGraphEnumUtils::GetIndGraph(G, sg, indG);
100  	if(m_graphs.IsKey(indG))
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    