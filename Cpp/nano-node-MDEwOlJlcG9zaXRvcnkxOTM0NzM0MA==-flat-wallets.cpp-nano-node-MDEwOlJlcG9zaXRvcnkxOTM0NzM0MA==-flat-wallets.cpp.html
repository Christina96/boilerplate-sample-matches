
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallets.cpp</h3>
            <pre><code>1  #include <nano/secure/versioning.hpp>
2  #include <nano/test_common/system.hpp>
3  #include <nano/test_common/testutil.hpp>
4  #include <gtest/gtest.h>
5  using namespace std::chrono_literals;
6  TEST (wallets, open_create)
7  {
8  	nano::test::system system (1);
9  	bool error (false);
10  	nano::wallets wallets (error, *system.nodes[0]);
11  	ASSERT_FALSE (error);
12  	ASSERT_EQ (1, wallets.items.size ()); 
13  	auto id = nano::random_wallet_id ();
14  	ASSERT_EQ (nullptr, wallets.open (id));
15  	auto wallet (wallets.create (id));
16  	ASSERT_NE (nullptr, wallet);
17  	ASSERT_EQ (wallet, wallets.open (id));
18  }
19  TEST (wallets, open_existing)
20  {
21  	nano::test::system system (1);
22  	auto id (nano::random_wallet_id ());
23  	{
24  		bool error (false);
25  		nano::wallets wallets (error, *system.nodes[0]);
26  		ASSERT_FALSE (error);
27  		ASSERT_EQ (1, wallets.items.size ());
28  		auto wallet (wallets.create (id));
29  		ASSERT_NE (nullptr, wallet);
30  		ASSERT_EQ (wallet, wallets.open (id));
31  		nano::raw_key password;
32  		password.clear ();
33  		system.deadline_set (10s);
34  		while (password == 0)
35  		{
36  			ASSERT_NO_ERROR (system.poll ());
37  			wallet->store.password.value (password);
38  		}
39  	}
40  	{
41  		bool error (false);
42  		nano::wallets wallets (error, *system.nodes[0]);
43  		ASSERT_FALSE (error);
44  		ASSERT_EQ (2, wallets.items.size ());
45  		ASSERT_NE (nullptr, wallets.open (id));
46  	}
47  }
48  TEST (wallets, remove)
49  {
50  	nano::test::system system (1);
51  	nano::wallet_id one (1);
52  	{
53  		bool error (false);
54  		nano::wallets wallets (error, *system.nodes[0]);
55  		ASSERT_FALSE (error);
56  		ASSERT_EQ (1, wallets.items.size ());
57  		auto wallet (wallets.create (one));
58  		ASSERT_NE (nullptr, wallet);
59  		ASSERT_EQ (2, wallets.items.size ());
60  		wallets.destroy (one);
61  		ASSERT_EQ (1, wallets.items.size ());
62  	}
63  	{
64  		bool error (false);
65  		nano::wallets wallets (error, *system.nodes[0]);
66  		ASSERT_FALSE (error);
67  		ASSERT_EQ (1, wallets.items.size ());
68  	}
69  }
70  TEST (wallets, reload)
71  {
72  	nano::test::system system (1);
73  	auto & node1 (*system.nodes[0]);
74  	nano::wallet_id one (1);
75  	bool error (false);
76  	ASSERT_FALSE (error);
77  	ASSERT_EQ (1, node1.wallets.items.size ());
78  	{
79  		nano::lock_guard<nano::mutex> lock_wallet (node1.wallets.mutex);
80  		nano::inactive_node node (node1.application_path, nano::inactive_node_flag_defaults ());
81  		auto wallet (node.node->wallets.create (one));
82  		ASSERT_NE (wallet, nullptr);
83  	}
84  	ASSERT_TIMELY (5s, node1.wallets.open (one) != nullptr);
85  	ASSERT_EQ (2, node1.wallets.items.size ());
86  }
87  TEST (wallets, vote_minimum)
88  {
89  	nano::test::system system (1);
90  	auto & node1 (*system.nodes[0]);
91  	nano::keypair key1;
92  	nano::keypair key2;
93  	nano::block_builder builder;
94  	auto send1 = builder
95  				 .state ()
96  				 .account (nano::dev::genesis_key.pub)
97  				 .previous (nano::dev::genesis->hash ())
98  				 .representative (nano::dev::genesis_key.pub)
99  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.vote_minimum.number ())
100  				 .link (key1.pub)
101  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
102  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
103  				 .build ();
104  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
105  	auto open1 = builder
106  				 .state ()
107  				 .account (key1.pub)
108  				 .previous (0)
109  				 .representative (key1.pub)
110  				 .balance (node1.config.vote_minimum.number ())
111  				 .link (send1->hash ())
112  				 .sign (key1.prv, key1.pub)
113  				 .work (*system.work.generate (key1.pub))
114  				 .build ();
115  	ASSERT_EQ (nano::process_result::progress, node1.process (*open1).code);
116  	auto send2 = builder
117  				 .state ()
118  				 .account (nano::dev::genesis_key.pub)
119  				 .previous (send1->hash ())
120  				 .representative (nano::dev::genesis_key.pub)
121  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 2 * node1.config.vote_minimum.number () + 1)
122  				 .link (key2.pub)
123  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
124  				 .work (*system.work.generate (send1->hash ()))
125  				 .build ();
126  	ASSERT_EQ (nano::process_result::progress, node1.process (*send2).code);
127  	auto open2 = builder
128  				 .state ()
129  				 .account (key2.pub)
130  				 .previous (0)
131  				 .representative (key2.pub)
132  				 .balance (node1.config.vote_minimum.number () - 1)
133  				 .link (send2->hash ())
134  				 .sign (key2.prv, key2.pub)
135  				 .work (*system.work.generate (key2.pub))
136  				 .build ();
137  	ASSERT_EQ (nano::process_result::progress, node1.process (*open2).code);
138  	auto wallet (node1.wallets.items.begin ()->second);
139  	nano::unique_lock<nano::mutex> representatives_lk (wallet->representatives_mutex);
140  	ASSERT_EQ (0, wallet->representatives.size ());
141  	representatives_lk.unlock ();
142  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
143  	wallet->insert_adhoc (key1.prv);
144  	wallet->insert_adhoc (key2.prv);
145  	node1.wallets.compute_reps ();
146  	representatives_lk.lock ();
147  	ASSERT_EQ (2, wallet->representatives.size ());
148  }
149  TEST (wallets, exists)
150  {
151  	nano::test::system system (1);
152  	auto & node (*system.nodes[0]);
153  	nano::keypair key1;
154  	nano::keypair key2;
155  	{
156  		auto transaction (node.wallets.tx_begin_read ());
157  		ASSERT_FALSE (node.wallets.exists (transaction, key1.pub));
158  		ASSERT_FALSE (node.wallets.exists (transaction, key2.pub));
159  	}
160  	system.wallet (0)->insert_adhoc (key1.prv);
161  	{
162  		auto transaction (node.wallets.tx_begin_read ());
163  		ASSERT_TRUE (node.wallets.exists (transaction, key1.pub));
164  		ASSERT_FALSE (node.wallets.exists (transaction, key2.pub));
165  	}
166  	system.wallet (0)->insert_adhoc (key2.prv);
167  	{
168  		auto transaction (node.wallets.tx_begin_read ());
<span onclick='openModal()' class='match'>169  		ASSERT_TRUE (node.wallets.exists (transaction, key1.pub));
170  		ASSERT_TRUE (node.wallets.exists (transaction, key2.pub));
</span>171  	}
172  }
173  TEST (wallets, search_receivable)
174  {
175  	for (auto search_all : { false, true })
176  	{
177  		nano::test::system system;
178  		nano::node_config config = system.default_config ();
179  		config.enable_voting = false;
180  		config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
181  		nano::node_flags flags;
182  		flags.disable_search_pending = true;
183  		auto & node (*system.add_node (config, flags));
184  		nano::unique_lock<nano::mutex> lk (node.wallets.mutex);
185  		auto wallets = node.wallets.get_wallets ();
186  		lk.unlock ();
187  		ASSERT_EQ (1, wallets.size ());
188  		auto wallet_id = wallets.begin ()->first;
189  		auto wallet = wallets.begin ()->second;
190  		wallet->insert_adhoc (nano::dev::genesis_key.prv);
191  		nano::block_builder builder;
192  		auto send = builder.state ()
193  					.account (nano::dev::genesis->account ())
194  					.previous (nano::dev::genesis->hash ())
195  					.representative (nano::dev::genesis->account ())
196  					.balance (nano::dev::constants.genesis_amount - node.config.receive_minimum.number ())
197  					.link (nano::dev::genesis->account ())
198  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
199  					.work (*system.work.generate (nano::dev::genesis->hash ()))
200  					.build ();
201  		ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
202  		ASSERT_TRUE (node.active.empty ());
203  		if (search_all)
204  		{
205  			node.wallets.search_receivable_all ();
206  		}
207  		else
208  		{
209  			node.wallets.search_receivable (wallet_id);
210  		}
211  		auto election = node.active.election (send->qualified_root ());
212  		ASSERT_NE (nullptr, election);
213  		wallet->store.erase (node.wallets.tx_begin_write (), nano::dev::genesis->account ());
214  		election->force_confirm ();
215  		ASSERT_TIMELY (5s, node.block_confirmed (send->hash ()) && node.active.empty ());
216  		wallet->insert_adhoc (nano::dev::genesis_key.prv);
217  		ASSERT_EQ (2, node.ledger.cache.block_count);
218  		if (search_all)
219  		{
220  			node.wallets.search_receivable_all ();
221  		}
222  		else
223  		{
224  			node.wallets.search_receivable (wallet_id);
225  		}
226  		ASSERT_TIMELY (3s, node.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
227  		auto receive_hash = node.ledger.latest (node.store.tx_begin_read (), nano::dev::genesis->account ());
228  		auto receive = node.block (receive_hash);
229  		ASSERT_NE (nullptr, receive);
230  		ASSERT_EQ (receive->sideband ().height, 3);
231  		ASSERT_EQ (send->hash (), receive->link ().as_block_hash ());
232  	}
233  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallets.cpp</h3>
            <pre><code>1  #include <nano/secure/versioning.hpp>
2  #include <nano/test_common/system.hpp>
3  #include <nano/test_common/testutil.hpp>
4  #include <gtest/gtest.h>
5  using namespace std::chrono_literals;
6  TEST (wallets, open_create)
7  {
8  	nano::test::system system (1);
9  	bool error (false);
10  	nano::wallets wallets (error, *system.nodes[0]);
11  	ASSERT_FALSE (error);
12  	ASSERT_EQ (1, wallets.items.size ()); 
13  	auto id = nano::random_wallet_id ();
14  	ASSERT_EQ (nullptr, wallets.open (id));
15  	auto wallet (wallets.create (id));
16  	ASSERT_NE (nullptr, wallet);
17  	ASSERT_EQ (wallet, wallets.open (id));
18  }
19  TEST (wallets, open_existing)
20  {
21  	nano::test::system system (1);
22  	auto id (nano::random_wallet_id ());
23  	{
24  		bool error (false);
25  		nano::wallets wallets (error, *system.nodes[0]);
26  		ASSERT_FALSE (error);
27  		ASSERT_EQ (1, wallets.items.size ());
28  		auto wallet (wallets.create (id));
29  		ASSERT_NE (nullptr, wallet);
30  		ASSERT_EQ (wallet, wallets.open (id));
31  		nano::raw_key password;
32  		password.clear ();
33  		system.deadline_set (10s);
34  		while (password == 0)
35  		{
36  			ASSERT_NO_ERROR (system.poll ());
37  			wallet->store.password.value (password);
38  		}
39  	}
40  	{
41  		bool error (false);
42  		nano::wallets wallets (error, *system.nodes[0]);
43  		ASSERT_FALSE (error);
44  		ASSERT_EQ (2, wallets.items.size ());
45  		ASSERT_NE (nullptr, wallets.open (id));
46  	}
47  }
48  TEST (wallets, remove)
49  {
50  	nano::test::system system (1);
51  	nano::wallet_id one (1);
52  	{
53  		bool error (false);
54  		nano::wallets wallets (error, *system.nodes[0]);
55  		ASSERT_FALSE (error);
56  		ASSERT_EQ (1, wallets.items.size ());
57  		auto wallet (wallets.create (one));
58  		ASSERT_NE (nullptr, wallet);
59  		ASSERT_EQ (2, wallets.items.size ());
60  		wallets.destroy (one);
61  		ASSERT_EQ (1, wallets.items.size ());
62  	}
63  	{
64  		bool error (false);
65  		nano::wallets wallets (error, *system.nodes[0]);
66  		ASSERT_FALSE (error);
67  		ASSERT_EQ (1, wallets.items.size ());
68  	}
69  }
70  TEST (wallets, reload)
71  {
72  	nano::test::system system (1);
73  	auto & node1 (*system.nodes[0]);
74  	nano::wallet_id one (1);
75  	bool error (false);
76  	ASSERT_FALSE (error);
77  	ASSERT_EQ (1, node1.wallets.items.size ());
78  	{
79  		nano::lock_guard<nano::mutex> lock_wallet (node1.wallets.mutex);
80  		nano::inactive_node node (node1.application_path, nano::inactive_node_flag_defaults ());
81  		auto wallet (node.node->wallets.create (one));
82  		ASSERT_NE (wallet, nullptr);
83  	}
84  	ASSERT_TIMELY (5s, node1.wallets.open (one) != nullptr);
85  	ASSERT_EQ (2, node1.wallets.items.size ());
86  }
87  TEST (wallets, vote_minimum)
88  {
89  	nano::test::system system (1);
90  	auto & node1 (*system.nodes[0]);
91  	nano::keypair key1;
92  	nano::keypair key2;
93  	nano::block_builder builder;
94  	auto send1 = builder
95  				 .state ()
96  				 .account (nano::dev::genesis_key.pub)
97  				 .previous (nano::dev::genesis->hash ())
98  				 .representative (nano::dev::genesis_key.pub)
99  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.vote_minimum.number ())
100  				 .link (key1.pub)
101  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
102  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
103  				 .build ();
104  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
105  	auto open1 = builder
106  				 .state ()
107  				 .account (key1.pub)
108  				 .previous (0)
109  				 .representative (key1.pub)
110  				 .balance (node1.config.vote_minimum.number ())
111  				 .link (send1->hash ())
112  				 .sign (key1.prv, key1.pub)
113  				 .work (*system.work.generate (key1.pub))
114  				 .build ();
115  	ASSERT_EQ (nano::process_result::progress, node1.process (*open1).code);
116  	auto send2 = builder
117  				 .state ()
118  				 .account (nano::dev::genesis_key.pub)
119  				 .previous (send1->hash ())
120  				 .representative (nano::dev::genesis_key.pub)
121  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 2 * node1.config.vote_minimum.number () + 1)
122  				 .link (key2.pub)
123  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
124  				 .work (*system.work.generate (send1->hash ()))
125  				 .build ();
126  	ASSERT_EQ (nano::process_result::progress, node1.process (*send2).code);
127  	auto open2 = builder
128  				 .state ()
129  				 .account (key2.pub)
130  				 .previous (0)
131  				 .representative (key2.pub)
132  				 .balance (node1.config.vote_minimum.number () - 1)
133  				 .link (send2->hash ())
134  				 .sign (key2.prv, key2.pub)
135  				 .work (*system.work.generate (key2.pub))
136  				 .build ();
137  	ASSERT_EQ (nano::process_result::progress, node1.process (*open2).code);
138  	auto wallet (node1.wallets.items.begin ()->second);
139  	nano::unique_lock<nano::mutex> representatives_lk (wallet->representatives_mutex);
140  	ASSERT_EQ (0, wallet->representatives.size ());
141  	representatives_lk.unlock ();
142  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
143  	wallet->insert_adhoc (key1.prv);
144  	wallet->insert_adhoc (key2.prv);
145  	node1.wallets.compute_reps ();
146  	representatives_lk.lock ();
147  	ASSERT_EQ (2, wallet->representatives.size ());
148  }
149  TEST (wallets, exists)
150  {
151  	nano::test::system system (1);
152  	auto & node (*system.nodes[0]);
153  	nano::keypair key1;
154  	nano::keypair key2;
155  	{
156  		auto transaction (node.wallets.tx_begin_read ());
<span onclick='openModal()' class='match'>157  		ASSERT_FALSE (node.wallets.exists (transaction, key1.pub));
158  		ASSERT_FALSE (node.wallets.exists (transaction, key2.pub));
</span>159  	}
160  	system.wallet (0)->insert_adhoc (key1.prv);
161  	{
162  		auto transaction (node.wallets.tx_begin_read ());
163  		ASSERT_TRUE (node.wallets.exists (transaction, key1.pub));
164  		ASSERT_FALSE (node.wallets.exists (transaction, key2.pub));
165  	}
166  	system.wallet (0)->insert_adhoc (key2.prv);
167  	{
168  		auto transaction (node.wallets.tx_begin_read ());
169  		ASSERT_TRUE (node.wallets.exists (transaction, key1.pub));
170  		ASSERT_TRUE (node.wallets.exists (transaction, key2.pub));
171  	}
172  }
173  TEST (wallets, search_receivable)
174  {
175  	for (auto search_all : { false, true })
176  	{
177  		nano::test::system system;
178  		nano::node_config config = system.default_config ();
179  		config.enable_voting = false;
180  		config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
181  		nano::node_flags flags;
182  		flags.disable_search_pending = true;
183  		auto & node (*system.add_node (config, flags));
184  		nano::unique_lock<nano::mutex> lk (node.wallets.mutex);
185  		auto wallets = node.wallets.get_wallets ();
186  		lk.unlock ();
187  		ASSERT_EQ (1, wallets.size ());
188  		auto wallet_id = wallets.begin ()->first;
189  		auto wallet = wallets.begin ()->second;
190  		wallet->insert_adhoc (nano::dev::genesis_key.prv);
191  		nano::block_builder builder;
192  		auto send = builder.state ()
193  					.account (nano::dev::genesis->account ())
194  					.previous (nano::dev::genesis->hash ())
195  					.representative (nano::dev::genesis->account ())
196  					.balance (nano::dev::constants.genesis_amount - node.config.receive_minimum.number ())
197  					.link (nano::dev::genesis->account ())
198  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
199  					.work (*system.work.generate (nano::dev::genesis->hash ()))
200  					.build ();
201  		ASSERT_EQ (nano::process_result::progress, node.process (*send).code);
202  		ASSERT_TRUE (node.active.empty ());
203  		if (search_all)
204  		{
205  			node.wallets.search_receivable_all ();
206  		}
207  		else
208  		{
209  			node.wallets.search_receivable (wallet_id);
210  		}
211  		auto election = node.active.election (send->qualified_root ());
212  		ASSERT_NE (nullptr, election);
213  		wallet->store.erase (node.wallets.tx_begin_write (), nano::dev::genesis->account ());
214  		election->force_confirm ();
215  		ASSERT_TIMELY (5s, node.block_confirmed (send->hash ()) && node.active.empty ());
216  		wallet->insert_adhoc (nano::dev::genesis_key.prv);
217  		ASSERT_EQ (2, node.ledger.cache.block_count);
218  		if (search_all)
219  		{
220  			node.wallets.search_receivable_all ();
221  		}
222  		else
223  		{
224  			node.wallets.search_receivable (wallet_id);
225  		}
226  		ASSERT_TIMELY (3s, node.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
227  		auto receive_hash = node.ledger.latest (node.store.tx_begin_read (), nano::dev::genesis->account ());
228  		auto receive = node.block (receive_hash);
229  		ASSERT_NE (nullptr, receive);
230  		ASSERT_EQ (receive->sideband ().height, 3);
231  		ASSERT_EQ (send->hash (), receive->link ().as_block_hash ());
232  	}
233  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallets.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-wallets.cpp</div>
                </div>
                <div class="column column_space"><pre><code>169  		ASSERT_TRUE (node.wallets.exists (transaction, key1.pub));
170  		ASSERT_TRUE (node.wallets.exists (transaction, key2.pub));
</pre></code></div>
                <div class="column column_space"><pre><code>157  		ASSERT_FALSE (node.wallets.exists (transaction, key1.pub));
158  		ASSERT_FALSE (node.wallets.exists (transaction, key2.pub));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    