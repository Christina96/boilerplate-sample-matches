
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ccar.cpp</h3>
            <pre><code>1  void TCCAR::Calc(const TFltV&amp; Query, const TMatrix&amp; SourceL,  const TMatrix&amp; TargetL, TFltV&amp; Result,
2  		  const double&amp; Regparam, const int&amp; Cgsiter){
3  	TFltV Ones(SourceL.GetCols());
4  	Ones.PutAll(1.0);
5  	TFltV CenterS(SourceL.GetRows());
6  	SourceL.Multiply(Ones, CenterS);
7  	TLinAlg::MultiplyScalar(1.0 / SourceL.GetCols(), CenterS, CenterS);
8  	TFltV CenterT(TargetL.GetRows());
9      TargetL.Multiply(Ones, CenterT);
10  	TLinAlg::MultiplyScalar(1.0 / SourceL.GetCols(), CenterT, CenterT);
11  	TFltV CM2p(SourceL.GetCols()); 		
12  	TFltV CGpom1(TargetL.GetRows()); 
13  	TFltV CGr(TargetL.GetRows()); 
14  	TFltV CGp(TargetL.GetRows()); 
15  	TFltV CGa(TargetL.GetRows());	
16  	TFltV pom(SourceL.GetRows());
17  	TFltV cq1(SourceL.GetCols());
18  	TFltV cq(TargetL.GetRows());
19  	TLinAlg::LinComb(1, Query, -1, CenterS, pom);
20  	CenterMultiply(SourceL, pom ,cq1, CenterS, true,  Ones);
<span onclick='openModal()' class='match'>21      CenterMultiply(TargetL, cq1, cq, CenterT, false, Ones);
22  	TFltV pqy(TargetL.GetRows());
</span>23  	ConjugGrad(TargetL, cq, pqy, CenterT, Ones, Regparam, Cgsiter , CM2p, CGpom1, CGr, CGp, CGa); 
24  	double lam = sqrt(2.0 / (double)TLinAlg::DotProduct(pqy, cq));
25  	TLinAlg::LinComb(lam, pqy, 1, CenterT, Result);
26  }
27  void TCCAR::CenterMultiply(const TMatrix&amp; Matrix, const TFltV&amp; x,TFltV&amp; y, 
28          const TFltV&amp; Center, const bool&amp; transposed,  const TFltV&amp; Ones){
29  	if (transposed){
30  		Matrix.MultiplyT(x, y);
31  		TLinAlg::LinComb(1, y, -1*( TLinAlg::DotProduct(Center, x)), Ones, y);         
32  	}
33  	else{
34          Matrix.Multiply(x, y);
35  		TLinAlg::LinComb(1, y, -1*( TLinAlg::DotProduct(Ones, x)), Center, y); 
36  	}
37  }
38  void TCCAR::CenterMultiply2(const TMatrix&amp; Matrix, const TFltV&amp; x,TFltV&amp; y, 
39          const TFltV&amp; Center, const TFltV&amp; Ones, const double&amp; Regparam, TFltV&amp; CM2p){
40  	CenterMultiply(Matrix, x, CM2p, Center, true, Ones);
41  	CenterMultiply(Matrix, CM2p, y, Center, false, Ones);
42      TLinAlg::LinComb(1- Regparam, y, Regparam, x , y); 
43  }
44  void TCCAR::ConjugGrad(const TMatrix&amp; Matrix, const TFltV&amp; b, TFltV&amp; x, const TFltV&amp; Center, 
45          const TFltV&amp; Ones, const double&amp; Regparam, const double&amp; Cgsiter ,TFltV&amp; CM2p, TFltV&amp; CGpom1, 
46          TFltV&amp; CGr, TFltV&amp; CGp, TFltV&amp; CGa, const double&amp; RelErr, const TFltV&amp; x0) {
47  	x.Gen(Matrix.GetRows());
48      if (x0.Empty()) { x.PutAll(0.0); }
49      else { x = x0; }
50  	double rho, rho_new, alpha, pom3&amp;bsol;*, resid*/;
51  	int niter = 0;
52  	CenterMultiply2(Matrix, x,CGpom1, Center, Ones, Regparam, CM2p);
53  	TLinAlg::AddVec(-1.0, CGpom1, b, CGr);
54  	CGp = CGr;
55  	while (niter &lt; Cgsiter){
56  	    rho = TLinAlg::DotProduct(CGr, CGr);
57  	    CenterMultiply2(Matrix, CGp,CGa, Center, Ones, Regparam, CM2p);
58          pom3 = (TLinAlg::DotProduct(CGa, CGp));
59  		alpha = rho/pom3;
60  	    TLinAlg::AddVec(alpha, CGp, x, x);
61          TLinAlg::AddVec(-alpha, CGa, CGr, CGr);
62          rho_new = TLinAlg::DotProduct(CGr, CGr);
63          TLinAlg::AddVec(rho_new/rho, CGp, CGr,CGp);
64  		rho = rho_new;
65  	    niter++;
66  	}
67  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs.cpp</h3>
            <pre><code>1  #include &quot;paragraphs.h&quot;
2  #include &quot;helpers.h&quot;             
3  #include &quot;host.h&quot;                
4  #include &quot;mutableiterator.h&quot;     
5  #include &quot;ocrblock.h&quot;            
6  #include &quot;ocrpara.h&quot;             
7  #include &quot;ocrrow.h&quot;              
8  #include &quot;pageres.h&quot;             
9  #include &quot;paragraphs_internal.h&quot; 
10  #include &quot;pdblock.h&quot;             
11  #include &quot;polyblk.h&quot;             
12  #include &quot;ratngs.h&quot;              
13  #include &quot;rect.h&quot;                
14  #include &quot;statistc.h&quot;            
15  #include &quot;tprintf.h&quot;             
16  #include &quot;unicharset.h&quot;          
17  #include &quot;werd.h&quot;                
18  #include &lt;tesseract/pageiterator.h&gt; 
19  #include &lt;tesseract/publictypes.h&gt;  
20  #include &lt;tesseract/unichar.h&gt;      
21  #include &lt;algorithm&gt; 
22  #include &lt;cctype&gt;    
23  #include &lt;cmath&gt;     
24  #include &lt;cstdio&gt;    
25  #include &lt;cstdlib&gt;   
26  #include &lt;cstring&gt;   
27  #include &lt;memory&gt;    
28  static const char *const kRLE = &quot;\u202A&quot;; 
29  static const char *const kPDF = &quot;\u202C&quot;; 
30  namespace tesseract {
31  const ParagraphModel *kCrownLeft =
32      reinterpret_cast&lt;ParagraphModel *&gt;(static_cast&lt;uintptr_t&gt;(0xDEAD111F));
33  const ParagraphModel *kCrownRight =
34      reinterpret_cast&lt;ParagraphModel *&gt;(static_cast&lt;uintptr_t&gt;(0xDEAD888F));
35  static bool LikelyParagraphStart(const RowScratchRegisters &amp;before,
36                                   const RowScratchRegisters &amp;after,
37                                   tesseract::ParagraphJustification j);
38  static int Epsilon(int space_pix) {
39    return space_pix * 4 / 5;
40  }
41  static bool AcceptableRowArgs(int debug_level, int min_num_rows, const char *function_name,
42                                const std::vector&lt;RowScratchRegisters&gt; *rows, int row_start,
43                                int row_end) {
44    if (row_start &lt; 0 || static_cast&lt;size_t&gt;(row_end) &gt; rows-&gt;size() || row_start &gt; row_end) {
45      tprintf(&quot;Invalid arguments rows[%d, %d) while rows is of size %zu.\n&quot;, row_start, row_end,
46              rows-&gt;size());
47      return false;
48    }
49    if (row_end - row_start &lt; min_num_rows) {
50      if (debug_level &gt; 1) {
51        tprintf(&quot;# Too few rows[%d, %d) for %s.\n&quot;, row_start, row_end, function_name);
52      }
53      return false;
54    }
55    return true;
56  }
57  static void PrintTable(const std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;rows, const char *colsep) {
58    std::vector&lt;int&gt; max_col_widths;
59    for (const auto &amp;row : rows) {
60      auto num_columns = row.size();
61      for (size_t c = 0; c &lt; num_columns; c++) {
62        int num_unicodes = 0;
63        for (char i : row[c]) {
64          if ((i &amp; 0xC0) != 0x80) {
65            num_unicodes++;
66          }
67        }
68        if (c &gt;= max_col_widths.size()) {
69          max_col_widths.push_back(num_unicodes);
70        } else {
71          if (num_unicodes &gt; max_col_widths[c]) {
72            max_col_widths[c] = num_unicodes;
73          }
74        }
75      }
76    }
77    std::vector&lt;std::string&gt; col_width_patterns;
78    col_width_patterns.reserve(max_col_widths.size());
79    for (int max_col_width : max_col_widths) {
80      col_width_patterns.push_back(std::string(&quot;%-&quot;) + std::to_string(max_col_width) + &quot;s&quot;);
81    }
82    for (const auto &amp;row : rows) {
83      for (unsigned c = 0; c &lt; row.size(); c++) {
84        if (c &gt; 0) {
85          tprintf(&quot;%s&quot;, colsep);
86        }
87        tprintf(col_width_patterns[c].c_str(), row[c].c_str());
88      }
89      tprintf(&quot;\n&quot;);
90    }
91  }
92  static std::string RtlEmbed(const std::string &amp;word, bool rtlify) {
93    if (rtlify) {
94      return std::string(kRLE) + word + std::string(kPDF);
95    }
96    return word;
97  }
98  static void PrintDetectorState(const ParagraphTheory &amp;theory,
99                                 const std::vector&lt;RowScratchRegisters&gt; &amp;rows) {
100    std::vector&lt;std::vector&lt;std::string&gt;&gt; output;
101    output.emplace_back();
102    output.back().push_back(&quot;#row&quot;);
103    output.back().push_back(&quot;space&quot;);
104    output.back().push_back(&quot;..&quot;);
105    output.back().push_back(&quot;lword[widthSEL]&quot;);
106    output.back().push_back(&quot;rword[widthSEL]&quot;);
107    RowScratchRegisters::AppendDebugHeaderFields(output.back());
108    output.back().push_back(&quot;text&quot;);
109    for (unsigned i = 0; i &lt; rows.size(); i++) {
110      output.emplace_back();
111      std::vector&lt;std::string&gt; &amp;row = output.back();
112      const RowInfo &amp;ri = *rows[i].ri_;
113      row.push_back(std::to_string(i));
114      row.push_back(std::to_string(ri.average_interword_space));
115      row.emplace_back(ri.has_leaders ? &quot;..&quot; : &quot; &quot;);
116      row.push_back(RtlEmbed(ri.lword_text, !ri.ltr) + &quot;[&quot; + std::to_string(ri.lword_box.width()) +
117                    (ri.lword_likely_starts_idea ? &quot;S&quot; : &quot;s&quot;) +
118                    (ri.lword_likely_ends_idea ? &quot;E&quot; : &quot;e&quot;) +
119                    (ri.lword_indicates_list_item ? &quot;L&quot; : &quot;l&quot;) + &quot;]&quot;);
120      row.push_back(RtlEmbed(ri.rword_text, !ri.ltr) + &quot;[&quot; + std::to_string(ri.rword_box.width()) +
121                    (ri.rword_likely_starts_idea ? &quot;S&quot; : &quot;s&quot;) +
122                    (ri.rword_likely_ends_idea ? &quot;E&quot; : &quot;e&quot;) +
123                    (ri.rword_indicates_list_item ? &quot;L&quot; : &quot;l&quot;) + &quot;]&quot;);
124      rows[i].AppendDebugInfo(theory, row);
125      row.push_back(RtlEmbed(ri.text, !ri.ltr));
126    }
127    PrintTable(output, &quot; &quot;);
128    tprintf(&quot;Active Paragraph Models:\n&quot;);
129    unsigned m = 0;
130    for (const auto &amp;model : theory.models()) {
131      tprintf(&quot; %d: %s\n&quot;, ++m, model-&gt;ToString().c_str());
132    }
133  }
134  static void DebugDump(bool should_print, const char *phase, const ParagraphTheory &amp;theory,
135                        const std::vector&lt;RowScratchRegisters&gt; &amp;rows) {
136    if (!should_print) {
137      return;
138    }
139    tprintf(&quot;# %s\n&quot;, phase);
140    PrintDetectorState(theory, rows);
141  }
142  static void PrintRowRange(const std::vector&lt;RowScratchRegisters&gt; &amp;rows, int row_start,
143                            int row_end) {
144    tprintf(&quot;======================================\n&quot;);
145    for (int row = row_start; row &lt; row_end; row++) {
146      tprintf(&quot;%s\n&quot;, rows[row].ri_-&gt;text.c_str());
147    }
148    tprintf(&quot;======================================\n&quot;);
149  }
150  static bool IsLatinLetter(int ch) {
151    return (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) || (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;);
152  }
153  static bool IsDigitLike(int ch) {
154    return ch == &#x27;o&#x27; || ch == &#x27;O&#x27; || ch == &#x27;l&#x27; || ch == &#x27;I&#x27;;
155  }
156  static bool IsOpeningPunct(int ch) {
157    return strchr(&quot;&#x27;\&quot;({[&quot;, ch) != nullptr;
158  }
159  static bool IsTerminalPunct(int ch) {
160    return strchr(&quot;:&#x27;\&quot;.?!]})&quot;, ch) != nullptr;
161  }
162  static const char *SkipChars(const char *str, const char *toskip) {
163    while (*str != &#x27;\0&#x27; &amp;&amp; strchr(toskip, *str)) {
164      str++;
165    }
166    return str;
167  }
168  static const char *SkipChars(const char *str, bool (*skip)(int)) {
169    while (*str != &#x27;\0&#x27; &amp;&amp; skip(*str)) {
170      str++;
171    }
172    return str;
173  }
174  static const char *SkipOne(const char *str, const char *toskip) {
175    if (*str != &#x27;\0&#x27; &amp;&amp; strchr(toskip, *str)) {
176      return str + 1;
177    }
178    return str;
179  }
180  static bool LikelyListNumeral(const std::string &amp;word) {
181    const char *kRomans = &quot;ivxlmdIVXLMD&quot;;
182    const char *kDigits = &quot;012345789&quot;;
183    const char *kOpen = &quot;[{(&quot;;
184    const char *kSep = &quot;:;-.,&quot;;
185    const char *kClose = &quot;]})&quot;;
186    int num_segments = 0;
187    const char *pos = word.c_str();
188    while (*pos != &#x27;\0&#x27; &amp;&amp; num_segments &lt; 3) {
189      const char *numeral_start = SkipOne(SkipOne(pos, kOpen), kOpen);
190      const char *numeral_end = SkipChars(numeral_start, kRomans);
191      if (numeral_end != numeral_start) {
192      } else {
193        numeral_end = SkipChars(numeral_start, kDigits);
194        if (numeral_end == numeral_start) {
195          numeral_end = SkipChars(numeral_start, IsLatinLetter);
196          if (numeral_end - numeral_start != 1) {
197            break;
198          }
199        }
200      }
201      num_segments++;
202      pos = SkipChars(SkipChars(numeral_end, kClose), kSep);
203      if (pos == numeral_end) {
204        break;
205      }
206    }
207    return *pos == &#x27;\0&#x27;;
208  }
209  static bool LikelyListMark(const std::string &amp;word) {
210    const char *kListMarks = &quot;0Oo*.,+.&quot;;
211    return word.size() == 1 &amp;&amp; strchr(kListMarks, word[0]) != nullptr;
212  }
213  bool AsciiLikelyListItem(const std::string &amp;word) {
214    return LikelyListMark(word) || LikelyListNumeral(word);
215  }
216  static int UnicodeFor(const UNICHARSET *u, const WERD_CHOICE *werd, unsigned pos) {
217    if (!u || !werd || pos &gt; werd-&gt;length()) {
218      return 0;
219    }
220    return UNICHAR(u-&gt;id_to_unichar(werd-&gt;unichar_id(pos)), -1).first_uni();
221  }
222  class UnicodeSpanSkipper {
223  public:
224    UnicodeSpanSkipper(const UNICHARSET *unicharset, const WERD_CHOICE *word)
225        : u_(unicharset), word_(word), wordlen_(word-&gt;length()) {
226    }
227    unsigned SkipPunc(unsigned pos);
228    unsigned SkipDigits(unsigned pos);
229    unsigned SkipRomans(unsigned pos);
230    unsigned SkipAlpha(unsigned pos);
231  private:
232    const UNICHARSET *u_;
233    const WERD_CHOICE *word_;
234    unsigned wordlen_;
235  };
236  unsigned UnicodeSpanSkipper::SkipPunc(unsigned pos) {
237    while (pos &lt; wordlen_ &amp;&amp; u_-&gt;get_ispunctuation(word_-&gt;unichar_id(pos))) {
238      pos++;
239    }
240    return pos;
241  }
242  unsigned UnicodeSpanSkipper::SkipDigits(unsigned pos) {
243    while (pos &lt; wordlen_ &amp;&amp;
244           (u_-&gt;get_isdigit(word_-&gt;unichar_id(pos)) || IsDigitLike(UnicodeFor(u_, word_, pos)))) {
245      pos++;
246    }
247    return pos;
248  }
249  unsigned UnicodeSpanSkipper::SkipRomans(unsigned pos) {
250    const char *kRomans = &quot;ivxlmdIVXLMD&quot;;
251    while (pos &lt; wordlen_) {
252      int ch = UnicodeFor(u_, word_, pos);
253      if (ch &gt;= 0xF0 || strchr(kRomans, ch) == nullptr) {
254        break;
255      }
256      pos++;
257    }
258    return pos;
259  }
260  unsigned UnicodeSpanSkipper::SkipAlpha(unsigned pos) {
261    while (pos &lt; wordlen_ &amp;&amp; u_-&gt;get_isalpha(word_-&gt;unichar_id(pos))) {
262      pos++;
263    }
264    return pos;
265  }
266  static bool LikelyListMarkUnicode(int ch) {
267    if (ch &lt; 0x80) {
268      std::string single_ch;
269      single_ch += ch;
270      return LikelyListMark(single_ch);
271    }
272    switch (ch) {
273      case 0x00B0: 
274      case 0x2022: 
275      case 0x25E6: 
276      case 0x00B7: 
277      case 0x25A1: 
278      case 0x25A0: 
279      case 0x25AA: 
280      case 0x2B1D: 
281      case 0x25BA: 
282      case 0x25CF: 
283      case 0x25CB: 
284        return true;
285      default:
286        break; 
287    }
288    return false;
289  }
290  static bool UniLikelyListItem(const UNICHARSET *u, const WERD_CHOICE *werd) {
291    if (werd-&gt;length() == 1 &amp;&amp; LikelyListMarkUnicode(UnicodeFor(u, werd, 0))) {
292      return true;
293    }
294    UnicodeSpanSkipper m(u, werd);
295    int num_segments = 0;
296    unsigned pos = 0;
297    while (pos &lt; werd-&gt;length() &amp;&amp; num_segments &lt; 3) {
298      auto numeral_start = m.SkipPunc(pos);
299      if (numeral_start &gt; pos + 1) {
300        break;
301      }
302      auto numeral_end = m.SkipRomans(numeral_start);
303      if (numeral_end == numeral_start) {
304        numeral_end = m.SkipDigits(numeral_start);
305        if (numeral_end == numeral_start) {
306          numeral_end = m.SkipAlpha(numeral_start);
307          if (numeral_end - numeral_start != 1) {
308            break;
309          }
310        }
311      }
312      num_segments++;
313      pos = m.SkipPunc(numeral_end);
314      if (pos == numeral_end) {
315        break;
316      }
317    }
318    return pos == werd-&gt;length();
319  }
320  template&lt;class T&gt;
321  void push_back_new(std::vector&lt;T&gt; &amp;vector, const T &amp;data) {
322    if (std::find(vector.begin(), vector.end(), data) == vector.end()) {
323      vector.push_back(data);
324    }
325  }
326  void LeftWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &amp;utf8,
327                          bool *is_list, bool *starts_idea, bool *ends_idea) {
328    *is_list = false;
329    *starts_idea = false;
330    *ends_idea = false;
331    if (utf8.empty() || (werd != nullptr &amp;&amp; werd-&gt;empty())) { 
332      *ends_idea = true;
333      return;
334    }
335    if (unicharset &amp;&amp; werd) { 
336      if (UniLikelyListItem(unicharset, werd)) {
337        *is_list = true;
338        *starts_idea = true;
339        *ends_idea = true;
340      }
341      if (unicharset-&gt;get_isupper(werd-&gt;unichar_id(0))) {
342        *starts_idea = true;
343      }
344      if (unicharset-&gt;get_ispunctuation(werd-&gt;unichar_id(0))) {
345        *starts_idea = true;
346        *ends_idea = true;
347      }
348    } else { 
349      if (AsciiLikelyListItem(utf8)) {
350        *is_list = true;
351        *starts_idea = true;
352      }
353      int start_letter = utf8[0];
354      if (IsOpeningPunct(start_letter)) {
355        *starts_idea = true;
356      }
357      if (IsTerminalPunct(start_letter)) {
358        *ends_idea = true;
359      }
360      if (start_letter &gt;= &#x27;A&#x27; &amp;&amp; start_letter &lt;= &#x27;Z&#x27;) {
361        *starts_idea = true;
362      }
363    }
364  }
365  void RightWordAttributes(const UNICHARSET *unicharset, const WERD_CHOICE *werd, const std::string &amp;utf8,
366                           bool *is_list, bool *starts_idea, bool *ends_idea) {
367    *is_list = false;
368    *starts_idea = false;
369    *ends_idea = false;
370    if (utf8.empty() || (werd != nullptr &amp;&amp; werd-&gt;empty())) { 
371      *ends_idea = true;
372      return;
373    }
374    if (unicharset &amp;&amp; werd) { 
375      if (UniLikelyListItem(unicharset, werd)) {
376        *is_list = true;
377        *starts_idea = true;
378      }
379      UNICHAR_ID last_letter = werd-&gt;unichar_id(werd-&gt;length() - 1);
380      if (unicharset-&gt;get_ispunctuation(last_letter)) {
381        *ends_idea = true;
382      }
383    } else { 
384      if (AsciiLikelyListItem(utf8)) {
385        *is_list = true;
386        *starts_idea = true;
387      }
388      int last_letter = utf8[utf8.size() - 1];
389      if (IsOpeningPunct(last_letter) || IsTerminalPunct(last_letter)) {
390        *ends_idea = true;
391      }
392    }
393  }
394  void RowScratchRegisters::AppendDebugHeaderFields(std::vector&lt;std::string&gt; &amp;header) {
395    header.emplace_back(&quot;[lmarg,lind;rind,rmarg]&quot;);
396    header.emplace_back(&quot;model&quot;);
397  }
398  void RowScratchRegisters::AppendDebugInfo(const ParagraphTheory &amp;theory,
399                                            std::vector&lt;std::string&gt; &amp;dbg) const {
400    char s[60];
401    snprintf(s, sizeof(s), &quot;[%4d,%5d;%5d,%4d]&quot;, lmargin_, lindent_, rindent_, rmargin_);
402    dbg.emplace_back(s);
403    std::string model_string;
404    model_string += static_cast&lt;char&gt;(GetLineType());
405    model_string += &quot;:&quot;;
406    int model_numbers = 0;
407    for (const auto &amp;hypothese : hypotheses_) {
408      if (hypothese.model == nullptr) {
409        continue;
410      }
411      if (model_numbers &gt; 0) {
412        model_string += &quot;,&quot;;
413      }
414      if (StrongModel(hypothese.model)) {
415        model_string += std::to_string(1 + theory.IndexOf(hypothese.model));
416      } else if (hypothese.model == kCrownLeft) {
417        model_string += &quot;CrL&quot;;
418      } else if (hypothese.model == kCrownRight) {
419        model_string += &quot;CrR&quot;;
420      }
421      model_numbers++;
422    }
423    if (model_numbers == 0) {
424      model_string += &quot;0&quot;;
425    }
426    dbg.push_back(model_string);
427  }
428  void RowScratchRegisters::Init(const RowInfo &amp;row) {
429    ri_ = &amp;row;
430    lmargin_ = 0;
431    lindent_ = row.pix_ldistance;
432    rmargin_ = 0;
433    rindent_ = row.pix_rdistance;
434  }
435  LineType RowScratchRegisters::GetLineType() const {
436    if (hypotheses_.empty()) {
437      return LT_UNKNOWN;
438    }
439    bool has_start = false;
440    bool has_body = false;
441    for (const auto &amp;hypothese : hypotheses_) {
442      switch (hypothese.ty) {
443        case LT_START:
444          has_start = true;
445          break;
446        case LT_BODY:
447          has_body = true;
448          break;
449        default:
450          tprintf(&quot;Encountered bad value in hypothesis list: %c\n&quot;, hypothese.ty);
451          break;
452      }
453    }
454    if (has_start &amp;&amp; has_body) {
455      return LT_MULTIPLE;
456    }
457    return has_start ? LT_START : LT_BODY;
458  }
459  LineType RowScratchRegisters::GetLineType(const ParagraphModel *model) const {
460    if (hypotheses_.empty()) {
461      return LT_UNKNOWN;
462    }
463    bool has_start = false;
464    bool has_body = false;
465    for (const auto &amp;hypothese : hypotheses_) {
466      if (hypothese.model != model) {
467        continue;
468      }
469      switch (hypothese.ty) {
470        case LT_START:
471          has_start = true;
472          break;
473        case LT_BODY:
474          has_body = true;
475          break;
476        default:
477          tprintf(&quot;Encountered bad value in hypothesis list: %c\n&quot;, hypothese.ty);
478          break;
479      }
480    }
481    if (has_start &amp;&amp; has_body) {
482      return LT_MULTIPLE;
483    }
484    return has_start ? LT_START : LT_BODY;
485  }
486  void RowScratchRegisters::SetStartLine() {
487    LineType current_lt = GetLineType();
488    if (current_lt != LT_UNKNOWN &amp;&amp; current_lt != LT_START) {
489      tprintf(&quot;Trying to set a line to be START when it&#x27;s already BODY.\n&quot;);
490    }
491    if (current_lt == LT_UNKNOWN || current_lt == LT_BODY) {
492      push_back_new(hypotheses_, LineHypothesis(LT_START, nullptr));
493    }
494  }
495  void RowScratchRegisters::SetBodyLine() {
496    LineType current_lt = GetLineType();
497    if (current_lt != LT_UNKNOWN &amp;&amp; current_lt != LT_BODY) {
498      tprintf(&quot;Trying to set a line to be BODY when it&#x27;s already START.\n&quot;);
499    }
500    if (current_lt == LT_UNKNOWN || current_lt == LT_START) {
501      push_back_new(hypotheses_, LineHypothesis(LT_BODY, nullptr));
502    }
503  }
504  void RowScratchRegisters::AddStartLine(const ParagraphModel *model) {
505    push_back_new(hypotheses_, LineHypothesis(LT_START, model));
506    auto found = std::find(hypotheses_.begin(), hypotheses_.end(), LineHypothesis(LT_START, nullptr));
507    if (found != hypotheses_.end()) {
508      hypotheses_.erase(found);
509    }
510  }
511  void RowScratchRegisters::AddBodyLine(const ParagraphModel *model) {
512    push_back_new(hypotheses_, LineHypothesis(LT_BODY, model));
513    auto found = std::find(hypotheses_.begin(), hypotheses_.end(), LineHypothesis(LT_BODY, nullptr));
514    if (found != hypotheses_.end()) {
515      hypotheses_.erase(found);
516    }
517  }
518  void RowScratchRegisters::StartHypotheses(SetOfModels *models) const {
519    for (const auto &amp;hypothese : hypotheses_) {
520      if (hypothese.ty == LT_START &amp;&amp; StrongModel(hypothese.model)) {
521        push_back_new(*models, hypothese.model);
522      }
523    }
524  }
525  void RowScratchRegisters::StrongHypotheses(SetOfModels *models) const {
526    for (const auto &amp;hypothese : hypotheses_) {
527      if (StrongModel(hypothese.model)) {
528        push_back_new(*models, hypothese.model);
529      }
530    }
531  }
532  void RowScratchRegisters::NonNullHypotheses(SetOfModels *models) const {
533    for (const auto &amp;hypothese : hypotheses_) {
534      if (hypothese.model != nullptr) {
535        push_back_new(*models, hypothese.model);
536      }
537    }
538  }
539  const ParagraphModel *RowScratchRegisters::UniqueStartHypothesis() const {
540    if (hypotheses_.size() != 1 || hypotheses_[0].ty != LT_START) {
541      return nullptr;
542    }
543    return hypotheses_[0].model;
544  }
545  const ParagraphModel *RowScratchRegisters::UniqueBodyHypothesis() const {
546    if (hypotheses_.size() != 1 || hypotheses_[0].ty != LT_BODY) {
547      return nullptr;
548    }
549    return hypotheses_[0].model;
550  }
551  void RowScratchRegisters::DiscardNonMatchingHypotheses(const SetOfModels &amp;models) {
552    if (models.empty()) {
553      return;
554    }
555    for (int h = hypotheses_.size() - 1; h &gt;= 0; h--) {
556      if (!contains(models, hypotheses_[h].model)) {
557        hypotheses_.erase(hypotheses_.begin() + h);
558      }
559    }
560  }
561  struct Cluster {
562    Cluster() : center(0), count(0) {}
563    Cluster(int cen, int num) : center(cen), count(num) {}
564    int center; 
565    int count;  
566  };
567  class SimpleClusterer {
568  public:
569    explicit SimpleClusterer(int max_cluster_width) : max_cluster_width_(max_cluster_width) {}
570    void Add(int value) {
571      values_.push_back(value);
572    }
573    size_t size() const {
574      return values_.size();
575    }
576    void GetClusters(std::vector&lt;Cluster&gt; *clusters);
577  private:
578    int max_cluster_width_;
579    std::vector&lt;int&gt; values_;
580  };
581  static int ClosestCluster(const std::vector&lt;Cluster&gt; &amp;clusters, int value) {
582    unsigned best_index = 0;
583    for (unsigned i = 0; i &lt; clusters.size(); i++) {
584      if (abs(value - clusters[i].center) &lt; abs(value - clusters[best_index].center)) {
585        best_index = i;
586      }
587    }
588    return best_index;
589  }
590  void SimpleClusterer::GetClusters(std::vector&lt;Cluster&gt; *clusters) {
591    clusters-&gt;clear();
592    std::sort(values_.begin(), values_.end());
593    for (unsigned i = 0; i &lt; values_.size();) {
594      int orig_i = i;
595      int lo = values_[i];
596      int hi = lo;
597      while (++i &lt; values_.size() &amp;&amp; values_[i] &lt;= lo + max_cluster_width_) {
598        hi = values_[i];
599      }
600      clusters-&gt;push_back(Cluster((hi + lo) / 2, i - orig_i));
601    }
602  }
603  static void CalculateTabStops(std::vector&lt;RowScratchRegisters&gt; *rows, int row_start, int row_end,
604                                int tolerance, std::vector&lt;Cluster&gt; *left_tabs,
605                                std::vector&lt;Cluster&gt; *right_tabs) {
606    if (!AcceptableRowArgs(0, 1, __func__, rows, row_start, row_end)) {
607      return;
608    }
609    SimpleClusterer initial_lefts(tolerance);
610    SimpleClusterer initial_rights(tolerance);
611    std::vector&lt;Cluster&gt; initial_left_tabs;
612    std::vector&lt;Cluster&gt; initial_right_tabs;
613    for (int i = row_start; i &lt; row_end; i++) {
614      initial_lefts.Add((*rows)[i].lindent_);
615      initial_rights.Add((*rows)[i].rindent_);
616    }
617    initial_lefts.GetClusters(&amp;initial_left_tabs);
618    initial_rights.GetClusters(&amp;initial_right_tabs);
619    SimpleClusterer lefts(tolerance);
620    SimpleClusterer rights(tolerance);
621    int infrequent_enough_to_ignore = 0;
622    if (row_end - row_start &gt;= 8) {
623      infrequent_enough_to_ignore = 1;
624    }
625    if (row_end - row_start &gt;= 20) {
626      infrequent_enough_to_ignore = 2;
627    }
628    for (int i = row_start; i &lt; row_end; i++) {
629      int lidx = ClosestCluster(initial_left_tabs, (*rows)[i].lindent_);
630      int ridx = ClosestCluster(initial_right_tabs, (*rows)[i].rindent_);
631      if (initial_left_tabs[lidx].count &gt; infrequent_enough_to_ignore ||
632          initial_right_tabs[ridx].count &gt; infrequent_enough_to_ignore) {
633        lefts.Add((*rows)[i].lindent_);
634        rights.Add((*rows)[i].rindent_);
635      }
636    }
637    lefts.GetClusters(left_tabs);
638    rights.GetClusters(right_tabs);
639    if ((left_tabs-&gt;size() == 1 &amp;&amp; right_tabs-&gt;size() &gt;= 4) ||
640        (right_tabs-&gt;size() == 1 &amp;&amp; left_tabs-&gt;size() &gt;= 4)) {
641      for (int i = row_start; i &lt; row_end; i++) {
642        int lidx = ClosestCluster(initial_left_tabs, (*rows)[i].lindent_);
643        int ridx = ClosestCluster(initial_right_tabs, (*rows)[i].rindent_);
644        if (!(initial_left_tabs[lidx].count &gt; infrequent_enough_to_ignore ||
645              initial_right_tabs[ridx].count &gt; infrequent_enough_to_ignore)) {
646          lefts.Add((*rows)[i].lindent_);
647          rights.Add((*rows)[i].rindent_);
648        }
649      }
650    }
651    lefts.GetClusters(left_tabs);
652    rights.GetClusters(right_tabs);
653    if (left_tabs-&gt;size() == 3 &amp;&amp; right_tabs-&gt;size() &gt;= 4) {
654      int to_prune = -1;
655      for (int i = left_tabs-&gt;size() - 1; i &gt;= 0; i--) {
656        if (to_prune &lt; 0 || (*left_tabs)[i].count &lt; (*left_tabs)[to_prune].count) {
657          to_prune = i;
658        }
659      }
660      if (to_prune &gt;= 0 &amp;&amp; (*left_tabs)[to_prune].count &lt;= infrequent_enough_to_ignore) {
661        left_tabs-&gt;erase(left_tabs-&gt;begin() + to_prune);
662      }
663    }
664    if (right_tabs-&gt;size() == 3 &amp;&amp; left_tabs-&gt;size() &gt;= 4) {
665      int to_prune = -1;
666      for (int i = right_tabs-&gt;size() - 1; i &gt;= 0; i--) {
667        if (to_prune &lt; 0 || (*right_tabs)[i].count &lt; (*right_tabs)[to_prune].count) {
668          to_prune = i;
669        }
670      }
671      if (to_prune &gt;= 0 &amp;&amp; (*right_tabs)[to_prune].count &lt;= infrequent_enough_to_ignore) {
672        right_tabs-&gt;erase(right_tabs-&gt;begin() + to_prune);
673      }
674    }
675  }
676  static void MarkRowsWithModel(std::vector&lt;RowScratchRegisters&gt; *rows, int row_start, int row_end,
677                                const ParagraphModel *model, bool ltr, int eop_threshold) {
678    if (!AcceptableRowArgs(0, 0, __func__, rows, row_start, row_end)) {
679      return;
680    }
681    for (int row = row_start; row &lt; row_end; row++) {
682      bool valid_first = ValidFirstLine(rows, row, model);
683      bool valid_body = ValidBodyLine(rows, row, model);
684      if (valid_first &amp;&amp; !valid_body) {
685        (*rows)[row].AddStartLine(model);
686      } else if (valid_body &amp;&amp; !valid_first) {
687        (*rows)[row].AddBodyLine(model);
688      } else if (valid_body &amp;&amp; valid_first) {
689        bool after_eop = (row == row_start);
690        if (row &gt; row_start) {
691          if (eop_threshold &gt; 0) {
692            if (model-&gt;justification() == JUSTIFICATION_LEFT) {
693              after_eop = (*rows)[row - 1].rindent_ &gt; eop_threshold;
694            } else {
695              after_eop = (*rows)[row - 1].lindent_ &gt; eop_threshold;
696            }
697          } else {
698            after_eop = FirstWordWouldHaveFit((*rows)[row - 1], (*rows)[row], model-&gt;justification());
699          }
700        }
701        if (after_eop) {
702          (*rows)[row].AddStartLine(model);
703        } else {
704          (*rows)[row].AddBodyLine(model);
705        }
706      } else {
707      }
708    }
709  }
710  struct GeometricClassifierState {
711    GeometricClassifierState(int dbg_level, std::vector&lt;RowScratchRegisters&gt; *r, int r_start,
712                             int r_end)
713        : debug_level(dbg_level), rows(r), row_start(r_start), row_end(r_end) {
714      tolerance = InterwordSpace(*r, r_start, r_end);
715      CalculateTabStops(r, r_start, r_end, tolerance, &amp;left_tabs, &amp;right_tabs);
716      if (debug_level &gt;= 3) {
717        tprintf(
718            &quot;Geometry: TabStop cluster tolerance = %d; &quot;
719            &quot;%zu left tabs; %zu right tabs\n&quot;,
720            tolerance, left_tabs.size(), right_tabs.size());
721      }
722      ltr = (*r)[r_start].ri_-&gt;ltr;
723    }
724    void AssumeLeftJustification() {
725      just = tesseract::JUSTIFICATION_LEFT;
726      margin = (*rows)[row_start].lmargin_;
727    }
728    void AssumeRightJustification() {
729      just = tesseract::JUSTIFICATION_RIGHT;
730      margin = (*rows)[row_start].rmargin_;
731    }
732    const std::vector&lt;Cluster&gt; &amp;AlignTabs() const {
733      if (just == tesseract::JUSTIFICATION_RIGHT) {
734        return right_tabs;
735      }
736      return left_tabs;
737    }
738    const std::vector&lt;Cluster&gt; &amp;OffsideTabs() const {
739      if (just == tesseract::JUSTIFICATION_RIGHT) {
740        return left_tabs;
741      }
742      return right_tabs;
743    }
744    bool IsFullRow(int i) const {
745      return ClosestCluster(left_tabs, (*rows)[i].lindent_) == 0 &amp;&amp;
746             ClosestCluster(right_tabs, (*rows)[i].rindent_) == 0;
747    }
748    int AlignsideTabIndex(int row_idx) const {
749      return ClosestCluster(AlignTabs(), (*rows)[row_idx].AlignsideIndent(just));
750    }
751    bool FirstWordWouldHaveFit(int row_a, int row_b) {
752      return ::tesseract::FirstWordWouldHaveFit((*rows)[row_a], (*rows)[row_b], just);
753    }
754    void PrintRows() const {
755      PrintRowRange(*rows, row_start, row_end);
756    }
757    void Fail(int min_debug_level, const char *why) const {
758      if (debug_level &lt; min_debug_level) {
759        return;
760      }
761      tprintf(&quot;# %s\n&quot;, why);
762      PrintRows();
763    }
764    ParagraphModel Model() const {
765      return ParagraphModel(just, margin, first_indent, body_indent, tolerance);
766    }
767    int debug_level = 0;
768    std::vector&lt;RowScratchRegisters&gt; *rows;
769    int row_start = 0;
770    int row_end = 0;
771    int tolerance = 0;
772    bool ltr = false;
773    std::vector&lt;Cluster&gt; left_tabs;
774    std::vector&lt;Cluster&gt; right_tabs;
775    tesseract::ParagraphJustification just = JUSTIFICATION_UNKNOWN;
776    int margin = 0;
777    int first_indent = 0;
778    int body_indent = 0;
779    int eop_threshold = 0;
780  };
781  static void GeometricClassifyThreeTabStopTextBlock(int debug_level, GeometricClassifierState &amp;s,
782                                                     ParagraphTheory *theory) {
783    int num_rows = s.row_end - s.row_start;
784    int num_full_rows = 0;
785    int last_row_full = 0;
786    for (int i = s.row_start; i &lt; s.row_end; i++) {
787      if (s.IsFullRow(i)) {
788        num_full_rows++;
789        if (i == s.row_end - 1) {
790          last_row_full++;
791        }
792      }
793    }
794    if (num_full_rows &lt; 0.7 * num_rows) {
795      s.Fail(1, &quot;Not enough full lines to know which lines start paras.&quot;);
796      return;
797    }
798    s.eop_threshold = 0;
799    if (s.ltr) {
800      s.AssumeLeftJustification();
801    } else {
802      s.AssumeRightJustification();
803    }
804    if (debug_level &gt; 0) {
805      tprintf(
806          &quot;# Not enough variety for clear outline classification. &quot;
807          &quot;Guessing these are %s aligned based on script.\n&quot;,
808          s.ltr ? &quot;left&quot; : &quot;right&quot;);
809      s.PrintRows();
810    }
811    if (s.AlignTabs().size() == 2) { 
812      s.first_indent = s.AlignTabs()[1].center;
813      s.body_indent = s.AlignTabs()[0].center;
814    } else { 
815      if (num_rows - 1 == num_full_rows - last_row_full) {
816        const ParagraphModel *model = s.ltr ? kCrownLeft : kCrownRight;
817        (*s.rows)[s.row_start].AddStartLine(model);
818        for (int i = s.row_start + 1; i &lt; s.row_end; i++) {
819          (*s.rows)[i].AddBodyLine(model);
820        }
821        return;
822      } else {
823        s.first_indent = s.body_indent = s.AlignTabs()[0].center;
824        s.eop_threshold = (s.OffsideTabs()[0].center + s.OffsideTabs()[1].center) / 2;
825      }
826    }
827    const ParagraphModel *model = theory-&gt;AddModel(s.Model());
828    MarkRowsWithModel(s.rows, s.row_start, s.row_end, model, s.ltr, s.eop_threshold);
829    return;
830  }
831  static void GeometricClassify(int debug_level, std::vector&lt;RowScratchRegisters&gt; *rows,
832                                int row_start, int row_end, ParagraphTheory *theory) {
833    if (!AcceptableRowArgs(debug_level, 4, __func__, rows, row_start, row_end)) {
834      return;
835    }
836    if (debug_level &gt; 1) {
837      tprintf(&quot;###############################################\n&quot;);
838      tprintf(&quot;##### GeometricClassify( rows[%d:%d) )   ####\n&quot;, row_start, row_end);
839      tprintf(&quot;###############################################\n&quot;);
840    }
841    RecomputeMarginsAndClearHypotheses(rows, row_start, row_end, 10);
842    GeometricClassifierState s(debug_level, rows, row_start, row_end);
843    if (s.left_tabs.size() &gt; 2 &amp;&amp; s.right_tabs.size() &gt; 2) {
844      s.Fail(2, &quot;Too much variety for simple outline classification.&quot;);
845      return;
846    }
847    if (s.left_tabs.size() &lt;= 1 &amp;&amp; s.right_tabs.size() &lt;= 1) {
848      s.Fail(1, &quot;Not enough variety for simple outline classification.&quot;);
849      return;
850    }
851    if (s.left_tabs.size() + s.right_tabs.size() == 3) {
852      GeometricClassifyThreeTabStopTextBlock(debug_level, s, theory);
853      return;
854    }
855    if (s.right_tabs.size() &gt; 2) {
856      s.AssumeLeftJustification();
857    } else if (s.left_tabs.size() &gt; 2) {
858      s.AssumeRightJustification();
859    } else if (s.ltr) { 
860      s.AssumeLeftJustification();
861    } else {
862      s.AssumeRightJustification();
863    }
864    if (s.AlignTabs().size() == 2) {
865      int firsts[2] = {0, 0};
866      firsts[s.AlignsideTabIndex(s.row_start)]++;
867      bool jam_packed = true;
868      for (int i = s.row_start + 1; i &lt; s.row_end; i++) {
869        if (s.FirstWordWouldHaveFit(i - 1, i)) {
870          firsts[s.AlignsideTabIndex(i)]++;
871          jam_packed = false;
872        }
873      }
874      if (jam_packed &amp;&amp; s.FirstWordWouldHaveFit(s.row_end - 1, s.row_end - 1)) {
875        firsts[1 - s.AlignsideTabIndex(s.row_end - 1)]++;
876      }
877      int percent0firsts, percent1firsts;
878      percent0firsts = (100 * firsts[0]) / s.AlignTabs()[0].count;
879      percent1firsts = (100 * firsts[1]) / s.AlignTabs()[1].count;
880      if ((percent0firsts &lt; 20 &amp;&amp; 30 &lt; percent1firsts) || percent0firsts + 30 &lt; percent1firsts) {
881        s.first_indent = s.AlignTabs()[1].center;
882        s.body_indent = s.AlignTabs()[0].center;
883      } else if ((percent1firsts &lt; 20 &amp;&amp; 30 &lt; percent0firsts) ||
884                 percent1firsts + 30 &lt; percent0firsts) {
885        s.first_indent = s.AlignTabs()[0].center;
886        s.body_indent = s.AlignTabs()[1].center;
887      } else {
888        if (debug_level &gt; 1) {
889          tprintf(&quot;# Cannot determine %s indent likely to start paragraphs.\n&quot;,
890                  s.just == tesseract::JUSTIFICATION_LEFT ? &quot;left&quot; : &quot;right&quot;);
891          tprintf(&quot;# Indent of %d looks like a first line %d%% of the time.\n&quot;,
892                  s.AlignTabs()[0].center, percent0firsts);
893          tprintf(&quot;# Indent of %d looks like a first line %d%% of the time.\n&quot;,
894                  s.AlignTabs()[1].center, percent1firsts);
895          s.PrintRows();
896        }
897        return;
898      }
899    } else {
900      s.first_indent = s.body_indent = s.AlignTabs()[0].center;
901    }
902    const ParagraphModel *model = theory-&gt;AddModel(s.Model());
903    s.eop_threshold = (s.OffsideTabs()[0].center + s.OffsideTabs()[1].center) / 2;
904    if (s.AlignTabs().size() == 2) {
905      for (int i = s.row_start; i &lt; s.row_end - 1; i++) {
906        if (ValidFirstLine(s.rows, i + 1, model) &amp;&amp;
907            !NearlyEqual(s.OffsideTabs()[0].center, (*s.rows)[i].OffsideIndent(s.just),
908                         s.tolerance)) {
909          s.eop_threshold = 0;
910          break;
911        }
912      }
913    } else {
914      for (int i = s.row_start; i &lt; s.row_end - 1; i++) {
915        if (!s.FirstWordWouldHaveFit(i, i + 1) &amp;&amp;
916            !NearlyEqual(s.OffsideTabs()[0].center, (*s.rows)[i].OffsideIndent(s.just),
917                         s.tolerance)) {
918          s.eop_threshold = 0;
919          break;
920        }
921      }
922    }
923    MarkRowsWithModel(rows, row_start, row_end, model, s.ltr, s.eop_threshold);
924  }
925  const ParagraphModel *ParagraphTheory::AddModel(const ParagraphModel &amp;model) {
926    for (const auto &amp;m : *models_) {
927      if (m-&gt;Comparable(model)) {
928        return m;
929      }
930    }
931    auto *m = new ParagraphModel(model);
932    models_-&gt;push_back(m);
933    push_back_new(models_we_added_, m);
934    return m;
935  }
936  void ParagraphTheory::DiscardUnusedModels(const SetOfModels &amp;used_models) {
937    size_t w = 0;
938    for (size_t r = 0; r &lt; models_-&gt;size(); r++) {
939      ParagraphModel *m = (*models_)[r];
940      if (!contains(used_models, static_cast&lt;const ParagraphModel *&gt;(m)) &amp;&amp; contains(models_we_added_, m)) {
941        delete m;
942      } else {
943        if (r &gt; w) {
944          (*models_)[w] = m;
945        }
946        w++;
947      }
948    }
949    models_-&gt;resize(w);
950  }
951  const ParagraphModel *ParagraphTheory::Fits(const std::vector&lt;RowScratchRegisters&gt; *rows,
952                                              int start, int end) const {
953    for (const auto *model : *models_) {
954      if (model-&gt;justification() != JUSTIFICATION_CENTER &amp;&amp; RowsFitModel(rows, start, end, model)) {
955        return model;
956      }
957    }
958    return nullptr;
959  }
960  void ParagraphTheory::NonCenteredModels(SetOfModels *models) {
961    for (const auto *model : *models_) {
962      if (model-&gt;justification() != JUSTIFICATION_CENTER) {
963        push_back_new(*models, model);
964      }
965    }
966  }
967  int ParagraphTheory::IndexOf(const ParagraphModel *model) const {
968    int i = 0;
969    for (const auto *m : *models_) {
970      if (m == model) {
971        return i;
972      }
973      i++;
974    }
975    return -1;
976  }
977  bool ValidFirstLine(const std::vector&lt;RowScratchRegisters&gt; *rows, int row,
978                      const ParagraphModel *model) {
979    if (!StrongModel(model)) {
980      tprintf(&quot;ValidFirstLine() should only be called with strong models!\n&quot;);
981    }
982    return StrongModel(model) &amp;&amp; model-&gt;ValidFirstLine((*rows)[row].lmargin_, (*rows)[row].lindent_,
983                                                       (*rows)[row].rindent_, (*rows)[row].rmargin_);
984  }
985  bool ValidBodyLine(const std::vector&lt;RowScratchRegisters&gt; *rows, int row,
986                     const ParagraphModel *model) {
987    if (!StrongModel(model)) {
988      tprintf(&quot;ValidBodyLine() should only be called with strong models!\n&quot;);
989    }
990    return StrongModel(model) &amp;&amp; model-&gt;ValidBodyLine((*rows)[row].lmargin_, (*rows)[row].lindent_,
991                                                      (*rows)[row].rindent_, (*rows)[row].rmargin_);
992  }
993  bool CrownCompatible(const std::vector&lt;RowScratchRegisters&gt; *rows, int a, int b,
994                       const ParagraphModel *model) {
995    if (model != kCrownRight &amp;&amp; model != kCrownLeft) {
996      tprintf(&quot;CrownCompatible() should only be called with crown models!\n&quot;);
997      return false;
998    }
999    auto &amp;row_a = (*rows)[a];
1000    auto &amp;row_b = (*rows)[b];
1001    if (model == kCrownRight) {
1002      return NearlyEqual(row_a.rindent_ + row_a.rmargin_, row_b.rindent_ + row_b.rmargin_,
1003                         Epsilon(row_a.ri_-&gt;average_interword_space));
1004    }
1005    return NearlyEqual(row_a.lindent_ + row_a.lmargin_, row_b.lindent_ + row_b.lmargin_,
1006                       Epsilon(row_a.ri_-&gt;average_interword_space));
1007  }
1008  ParagraphModelSmearer::ParagraphModelSmearer(std::vector&lt;RowScratchRegisters&gt; *rows,
1009                                               int row_start, int row_end, ParagraphTheory *theory)
1010      : theory_(theory), rows_(rows), row_start_(row_start), row_end_(row_end) {
1011    if (!AcceptableRowArgs(0, 0, __func__, rows, row_start, row_end)) {
1012      row_start_ = 0;
1013      row_end_ = 0;
1014      return;
1015    }
1016    open_models_.resize(open_models_.size() + row_end - row_start + 2);
1017  }
1018  void ParagraphModelSmearer::CalculateOpenModels(int row_start, int row_end) {
1019    SetOfModels no_models;
1020    if (row_start &lt; row_start_) {
1021      row_start = row_start_;
1022    }
1023    if (row_end &gt; row_end_) {
1024      row_end = row_end_;
1025    }
1026    for (int row = (row_start &gt; 0) ? row_start - 1 : row_start; row &lt; row_end; row++) {
1027      if ((*rows_)[row].ri_-&gt;num_words == 0) {
1028        OpenModels(row + 1) = no_models;
1029      } else {
1030        SetOfModels &amp;opened = OpenModels(row);
1031        (*rows_)[row].StartHypotheses(&amp;opened);
1032        SetOfModels still_open;
1033        for (auto &amp;m : opened) {
1034          if (ValidFirstLine(rows_, row, m) || ValidBodyLine(rows_, row, m)) {
1035            push_back_new(still_open, m);
1036          }
1037        }
1038        OpenModels(row + 1) = still_open;
1039      }
1040    }
1041  }
1042  void ParagraphModelSmearer::Smear() {
1043    CalculateOpenModels(row_start_, row_end_);
1044    for (int i = row_start_; i &lt; row_end_; i++) {
1045      RowScratchRegisters &amp;row = (*rows_)[i];
1046      if (row.ri_-&gt;num_words == 0) {
1047        continue;
1048      }
1049      bool left_align_open = false;
1050      bool right_align_open = false;
1051      for (auto &amp;m : OpenModels(i)) {
1052        switch (m-&gt;justification()) {
1053          case JUSTIFICATION_LEFT:
1054            left_align_open = true;
1055            break;
1056          case JUSTIFICATION_RIGHT:
1057            right_align_open = true;
1058            break;
1059          default:
1060            left_align_open = right_align_open = true;
1061        }
1062      }
1063      bool likely_start;
1064      if (i == 0) {
1065        likely_start = true;
1066      } else {
1067        if ((left_align_open &amp;&amp; right_align_open) || (!left_align_open &amp;&amp; !right_align_open)) {
1068          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_LEFT) ||
1069                         LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_RIGHT);
1070        } else if (left_align_open) {
1071          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_LEFT);
1072        } else {
1073          likely_start = LikelyParagraphStart((*rows_)[i - 1], row, JUSTIFICATION_RIGHT);
1074        }
1075      }
1076      if (likely_start) {
1077        for (unsigned m = 0; m &lt; OpenModels(i).size(); m++) {
1078          if (ValidFirstLine(rows_, i, OpenModels(i)[m])) {
1079            row.AddStartLine(OpenModels(i)[m]);
1080          }
1081        }
1082      } else {
1083        SetOfModels last_line_models;
1084        if (i &gt; 0) {
1085          (*rows_)[i - 1].StrongHypotheses(&amp;last_line_models);
1086        } else {
1087          theory_-&gt;NonCenteredModels(&amp;last_line_models);
1088        }
1089        for (auto model : last_line_models) {
1090          if (ValidBodyLine(rows_, i, model)) {
1091            row.AddBodyLine(model);
1092          }
1093        }
1094      }
1095      if (row.GetLineType() == LT_UNKNOWN ||
1096          (row.GetLineType() == LT_START &amp;&amp; !row.UniqueStartHypothesis())) {
1097        SetOfModels all_models;
1098        theory_-&gt;NonCenteredModels(&amp;all_models);
1099        for (auto &amp;all_model : all_models) {
1100          if (ValidFirstLine(rows_, i, all_model)) {
1101            row.AddStartLine(all_model);
1102          }
1103        }
1104      }
1105      if (row.GetLineType() != LT_UNKNOWN) {
1106        CalculateOpenModels(i + 1, row_end_);
1107      }
1108    }
1109  }
1110  static void DiscardUnusedModels(const std::vector&lt;RowScratchRegisters&gt; &amp;rows,
1111                                  ParagraphTheory *theory) {
1112    SetOfModels used_models;
1113    for (const auto &amp;row : rows) {
1114      row.StrongHypotheses(&amp;used_models);
1115    }
1116    theory-&gt;DiscardUnusedModels(used_models);
1117  }
1118  static void DowngradeWeakestToCrowns(int debug_level, ParagraphTheory *theory,
1119                                       std::vector&lt;RowScratchRegisters&gt; *rows) {
1120    int start;
1121    for (int end = rows-&gt;size(); end &gt; 0; end = start) {
1122      const ParagraphModel *model = nullptr;
1123      while (end &gt; 0 &amp;&amp; (model = (*rows)[end - 1].UniqueBodyHypothesis()) == nullptr) {
1124        end--;
1125      }
1126      if (end == 0) {
1127        break;
1128      }
1129      start = end - 1;
1130      while (start &gt;= 0 &amp;&amp; (*rows)[start].UniqueBodyHypothesis() == model) {
1131        start--; 
1132      }
1133      if (start &gt;= 0 &amp;&amp; (*rows)[start].UniqueStartHypothesis() == model &amp;&amp; StrongModel(model) &amp;&amp;
1134          NearlyEqual(model-&gt;first_indent(), model-&gt;body_indent(), model-&gt;tolerance())) {
1135        start--;
1136      }
1137      start++;
1138      if (StrongModel(model) &amp;&amp; model-&gt;justification() == JUSTIFICATION_CENTER) {
1139        continue;
1140      }
1141      if (!StrongModel(model)) {
1142        while (start &gt; 0 &amp;&amp; CrownCompatible(rows, start - 1, start, model)) {
1143          start--;
1144        }
1145      }
1146      if (start == 0 || (!StrongModel(model)) ||
1147          (StrongModel(model) &amp;&amp; !ValidFirstLine(rows, start - 1, model))) {
1148        const ParagraphModel *crown_model = model;
1149        if (StrongModel(model)) {
1150          if (model-&gt;justification() == JUSTIFICATION_LEFT) {
1151            crown_model = kCrownLeft;
1152          } else {
1153            crown_model = kCrownRight;
1154          }
1155        }
1156        (*rows)[start].SetUnknown();
1157        (*rows)[start].AddStartLine(crown_model);
1158        for (int row = start + 1; row &lt; end; row++) {
1159          (*rows)[row].SetUnknown();
1160          (*rows)[row].AddBodyLine(crown_model);
1161        }
1162      }
1163    }
1164    DiscardUnusedModels(*rows, theory);
1165  }
1166  void RecomputeMarginsAndClearHypotheses(std::vector&lt;RowScratchRegisters&gt; *rows, int start,
1167                                          int end, int percentile) {
1168    if (!AcceptableRowArgs(0, 0, __func__, rows, start, end)) {
1169      return;
1170    }
1171    int lmin, lmax, rmin, rmax;
1172    lmin = lmax = (*rows)[start].lmargin_ + (*rows)[start].lindent_;
1173    rmin = rmax = (*rows)[start].rmargin_ + (*rows)[start].rindent_;
1174    for (int i = start; i &lt; end; i++) {
1175      RowScratchRegisters &amp;sr = (*rows)[i];
1176      sr.SetUnknown();
1177      if (sr.ri_-&gt;num_words == 0) {
1178        continue;
1179      }
1180      UpdateRange(sr.lmargin_ + sr.lindent_, &amp;lmin, &amp;lmax);
1181      UpdateRange(sr.rmargin_ + sr.rindent_, &amp;rmin, &amp;rmax);
1182    }
1183    STATS lefts(lmin, lmax);
1184    STATS rights(rmin, rmax);
1185    for (int i = start; i &lt; end; i++) {
1186      RowScratchRegisters &amp;sr = (*rows)[i];
1187      if (sr.ri_-&gt;num_words == 0) {
1188        continue;
1189      }
1190      lefts.add(sr.lmargin_ + sr.lindent_, 1);
1191      rights.add(sr.rmargin_ + sr.rindent_, 1);
1192    }
1193    int ignorable_left = lefts.ile(ClipToRange(percentile, 0, 100) / 100.0);
1194    int ignorable_right = rights.ile(ClipToRange(percentile, 0, 100) / 100.0);
1195    for (int i = start; i &lt; end; i++) {
1196      RowScratchRegisters &amp;sr = (*rows)[i];
1197      int ldelta = ignorable_left - sr.lmargin_;
1198      sr.lmargin_ += ldelta;
1199      sr.lindent_ -= ldelta;
1200      int rdelta = ignorable_right - sr.rmargin_;
1201      sr.rmargin_ += rdelta;
1202      sr.rindent_ -= rdelta;
1203    }
1204  }
1205  int InterwordSpace(const std::vector&lt;RowScratchRegisters&gt; &amp;rows, int row_start, int row_end) {
1206    if (row_end &lt; row_start + 1) {
1207      return 1;
1208    }
1209    int word_height =
1210        (rows[row_start].ri_-&gt;lword_box.height() + rows[row_end - 1].ri_-&gt;lword_box.height()) / 2;
1211    int word_width =
1212        (rows[row_start].ri_-&gt;lword_box.width() + rows[row_end - 1].ri_-&gt;lword_box.width()) / 2;
1213    STATS spacing_widths(0, 4 + word_width);
1214    for (int i = row_start; i &lt; row_end; i++) {
1215      if (rows[i].ri_-&gt;num_words &gt; 1) {
1216        spacing_widths.add(rows[i].ri_-&gt;average_interword_space, 1);
1217      }
1218    }
1219    int minimum_reasonable_space = word_height / 3;
1220    if (minimum_reasonable_space &lt; 2) {
1221      minimum_reasonable_space = 2;
1222    }
1223    int median = spacing_widths.median();
1224    return (median &gt; minimum_reasonable_space) ? median : minimum_reasonable_space;
1225  }
1226  bool FirstWordWouldHaveFit(const RowScratchRegisters &amp;before, const RowScratchRegisters &amp;after,
1227                             tesseract::ParagraphJustification justification) {
1228    if (before.ri_-&gt;num_words == 0 || after.ri_-&gt;num_words == 0) {
1229      return true;
1230    }
1231    if (justification == JUSTIFICATION_UNKNOWN) {
1232      tprintf(&quot;Don&#x27;t call FirstWordWouldHaveFit(r, s, JUSTIFICATION_UNKNOWN).\n&quot;);
1233    }
1234    int available_space;
1235    if (justification == JUSTIFICATION_CENTER) {
1236      available_space = before.lindent_ + before.rindent_;
1237    } else {
1238      available_space = before.OffsideIndent(justification);
1239    }
1240    available_space -= before.ri_-&gt;average_interword_space;
1241    if (before.ri_-&gt;ltr) {
1242      return after.ri_-&gt;lword_box.width() &lt; available_space;
1243    }
1244    return after.ri_-&gt;rword_box.width() &lt; available_space;
1245  }
1246  bool FirstWordWouldHaveFit(const RowScratchRegisters &amp;before, const RowScratchRegisters &amp;after) {
1247    if (before.ri_-&gt;num_words == 0 || after.ri_-&gt;num_words == 0) {
1248      return true;
1249    }
1250    int available_space = before.lindent_;
1251    if (before.rindent_ &gt; available_space) {
1252      available_space = before.rindent_;
1253    }
1254    available_space -= before.ri_-&gt;average_interword_space;
1255    if (before.ri_-&gt;ltr) {
1256      return after.ri_-&gt;lword_box.width() &lt; available_space;
1257    }
1258    return after.ri_-&gt;rword_box.width() &lt; available_space;
1259  }
1260  static bool TextSupportsBreak(const RowScratchRegisters &amp;before, const RowScratchRegisters &amp;after) {
1261    if (before.ri_-&gt;ltr) {
1262      return before.ri_-&gt;rword_likely_ends_idea &amp;&amp; after.ri_-&gt;lword_likely_starts_idea;
1263    } else {
1264      return before.ri_-&gt;lword_likely_ends_idea &amp;&amp; after.ri_-&gt;rword_likely_starts_idea;
1265    }
1266  }
1267  static bool LikelyParagraphStart(const RowScratchRegisters &amp;before,
1268                                   const RowScratchRegisters &amp;after,
1269                                   tesseract::ParagraphJustification j) {
1270    return before.ri_-&gt;num_words == 0 ||
1271           (FirstWordWouldHaveFit(before, after, j) &amp;&amp; TextSupportsBreak(before, after));
1272  }
1273  static ParagraphModel InternalParagraphModelByOutline(
1274      const std::vector&lt;RowScratchRegisters&gt; *rows, int start, int end, int tolerance,
1275      bool *consistent) {
1276    int ltr_line_count = 0;
1277    for (int i = start; i &lt; end; i++) {
1278      ltr_line_count += static_cast&lt;int&gt;((*rows)[i].ri_-&gt;ltr);
1279    }
1280    bool ltr = (ltr_line_count &gt;= (end - start) / 2);
1281    *consistent = true;
1282    if (!AcceptableRowArgs(0, 2, __func__, rows, start, end)) {
1283      return ParagraphModel();
1284    }
1285    int lmargin = (*rows)[start].lmargin_;
1286    int rmargin = (*rows)[start].rmargin_;
1287    int lmin, lmax, rmin, rmax, cmin, cmax;
1288    lmin = lmax = (*rows)[start + 1].lindent_;
1289    rmin = rmax = (*rows)[start + 1].rindent_;
1290    cmin = cmax = 0;
1291    for (int i = start + 1; i &lt; end; i++) {
1292      if ((*rows)[i].lmargin_ != lmargin || (*rows)[i].rmargin_ != rmargin) {
1293        tprintf(&quot;Margins don&#x27;t match! Software error.\n&quot;);
1294        *consistent = false;
1295        return ParagraphModel();
1296      }
1297      UpdateRange((*rows)[i].lindent_, &amp;lmin, &amp;lmax);
1298      UpdateRange((*rows)[i].rindent_, &amp;rmin, &amp;rmax);
1299      UpdateRange((*rows)[i].rindent_ - (*rows)[i].lindent_, &amp;cmin, &amp;cmax);
1300    }
1301    int ldiff = lmax - lmin;
1302    int rdiff = rmax - rmin;
1303    int cdiff = cmax - cmin;
1304    if (rdiff &gt; tolerance &amp;&amp; ldiff &gt; tolerance) {
1305      if (cdiff &lt; tolerance * 2) {
1306        if (end - start &lt; 3) {
1307          return ParagraphModel();
1308        }
1309        return ParagraphModel(JUSTIFICATION_CENTER, 0, 0, 0, tolerance);
1310      }
1311      *consistent = false;
1312      return ParagraphModel();
1313    }
1314    if (end - start &lt; 3) { 
1315      return ParagraphModel();
1316    }
1317    bool body_admits_left_alignment = ldiff &lt; tolerance;
1318    bool body_admits_right_alignment = rdiff &lt; tolerance;
1319    ParagraphModel left_model = ParagraphModel(JUSTIFICATION_LEFT, lmargin, (*rows)[start].lindent_,
1320                                               (lmin + lmax) / 2, tolerance);
1321    ParagraphModel right_model = ParagraphModel(JUSTIFICATION_RIGHT, rmargin, (*rows)[start].rindent_,
1322                                                (rmin + rmax) / 2, tolerance);
1323    bool text_admits_left_alignment = ltr || left_model.is_flush();
1324    bool text_admits_right_alignment = !ltr || right_model.is_flush();
1325    if (tolerance &lt; rdiff) {
1326      if (body_admits_left_alignment &amp;&amp; text_admits_left_alignment) {
1327        return left_model;
1328      }
1329      *consistent = false;
1330      return ParagraphModel();
1331    }
1332    if (tolerance &lt; ldiff) {
1333      if (body_admits_right_alignment &amp;&amp; text_admits_right_alignment) {
1334        return right_model;
1335      }
1336      *consistent = false;
1337      return ParagraphModel();
1338    }
1339    int first_left = (*rows)[start].lindent_;
1340    int first_right = (*rows)[start].rindent_;
1341    if (ltr &amp;&amp; body_admits_left_alignment &amp;&amp; (first_left &lt; lmin || first_left &gt; lmax)) {
1342      return left_model;
1343    }
1344    if (!ltr &amp;&amp; body_admits_right_alignment &amp;&amp; (first_right &lt; rmin || first_right &gt; rmax)) {
1345      return right_model;
1346    }
1347    *consistent = false;
1348    return ParagraphModel();
1349  }
1350  static ParagraphModel ParagraphModelByOutline(int debug_level,
1351                                                const std::vector&lt;RowScratchRegisters&gt; *rows,
1352                                                int start, int end, int tolerance) {
1353    bool unused_consistent;
1354    ParagraphModel retval =
1355        InternalParagraphModelByOutline(rows, start, end, tolerance, &amp;unused_consistent);
1356    if (debug_level &gt;= 2 &amp;&amp; retval.justification() == JUSTIFICATION_UNKNOWN) {
1357      tprintf(&quot;Could not determine a model for this paragraph:\n&quot;);
1358      PrintRowRange(*rows, start, end);
1359    }
1360    return retval;
1361  }
1362  bool RowsFitModel(const std::vector&lt;RowScratchRegisters&gt; *rows, int start, int end,
1363                    const ParagraphModel *model) {
1364    if (!AcceptableRowArgs(0, 1, __func__, rows, start, end)) {
1365      return false;
1366    }
1367    if (!ValidFirstLine(rows, start, model)) {
1368      return false;
1369    }
1370    for (int i = start + 1; i &lt; end; i++) {
1371      if (!ValidBodyLine(rows, i, model)) {
1372        return false;
1373      }
1374    }
1375    return true;
1376  }
1377  static void MarkStrongEvidence(std::vector&lt;RowScratchRegisters&gt; *rows, int row_start,
1378                                 int row_end) {
1379    for (int i = row_start + 1; i &lt; row_end; i++) {
1380      const RowScratchRegisters &amp;prev = (*rows)[i - 1];
1381      RowScratchRegisters &amp;curr = (*rows)[i];
1382      tesseract::ParagraphJustification typical_justification =
1383          prev.ri_-&gt;ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1384      if (!curr.ri_-&gt;rword_likely_starts_idea &amp;&amp; !curr.ri_-&gt;lword_likely_starts_idea &amp;&amp;
1385          !FirstWordWouldHaveFit(prev, curr, typical_justification)) {
1386        curr.SetBodyLine();
1387      }
1388    }
1389    {
1390      RowScratchRegisters &amp;curr = (*rows)[row_start];
1391      RowScratchRegisters &amp;next = (*rows)[row_start + 1];
1392      tesseract::ParagraphJustification j = curr.ri_-&gt;ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1393      if (curr.GetLineType() == LT_UNKNOWN &amp;&amp; !FirstWordWouldHaveFit(curr, next, j) &amp;&amp;
1394          (curr.ri_-&gt;lword_likely_starts_idea || curr.ri_-&gt;rword_likely_starts_idea)) {
1395        curr.SetStartLine();
1396      }
1397    }
1398    for (int i = row_start + 1; i &lt; row_end - 1; i++) {
1399      RowScratchRegisters &amp;prev = (*rows)[i - 1];
1400      RowScratchRegisters &amp;curr = (*rows)[i];
1401      RowScratchRegisters &amp;next = (*rows)[i + 1];
1402      tesseract::ParagraphJustification j = curr.ri_-&gt;ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1403      if (curr.GetLineType() == LT_UNKNOWN &amp;&amp; !FirstWordWouldHaveFit(curr, next, j) &amp;&amp;
1404          LikelyParagraphStart(prev, curr, j)) {
1405        curr.SetStartLine();
1406      }
1407    }
1408    { 
1409      RowScratchRegisters &amp;prev = (*rows)[row_end - 2];
1410      RowScratchRegisters &amp;curr = (*rows)[row_end - 1];
1411      tesseract::ParagraphJustification j = curr.ri_-&gt;ltr ? JUSTIFICATION_LEFT : JUSTIFICATION_RIGHT;
1412      if (curr.GetLineType() == LT_UNKNOWN &amp;&amp; !FirstWordWouldHaveFit(curr, curr, j) &amp;&amp;
1413          LikelyParagraphStart(prev, curr, j)) {
1414        curr.SetStartLine();
1415      }
1416    }
1417  }
1418  static void ModelStrongEvidence(int debug_level, std::vector&lt;RowScratchRegisters&gt; *rows,
1419                                  int row_start, int row_end, bool allow_flush_models,
1420                                  ParagraphTheory *theory) {
1421    if (!AcceptableRowArgs(debug_level, 2, __func__, rows, row_start, row_end)) {
1422      return;
1423    }
1424    int start = row_start;
1425    while (start &lt; row_end) {
1426      while (start &lt; row_end &amp;&amp; (*rows)[start].GetLineType() != LT_START) {
1427        start++;
1428      }
1429      if (start &gt;= row_end - 1) {
1430        break;
1431      }
1432      int tolerance = Epsilon((*rows)[start + 1].ri_-&gt;average_interword_space);
1433      int end = start;
1434      ParagraphModel last_model;
1435      bool next_consistent;
1436      do {
1437        ++end;
1438        if (end &lt; row_end - 1) {
1439          RowScratchRegisters &amp;next = (*rows)[end];
1440          LineType lt = next.GetLineType();
1441          next_consistent = lt == LT_BODY || (lt == LT_UNKNOWN &amp;&amp;
1442                                              !FirstWordWouldHaveFit((*rows)[end - 1], (*rows)[end]));
1443        } else {
1444          next_consistent = false;
1445        }
1446        if (next_consistent) {
1447          ParagraphModel next_model =
1448              InternalParagraphModelByOutline(rows, start, end + 1, tolerance, &amp;next_consistent);
1449          if (((*rows)[start].ri_-&gt;ltr &amp;&amp; last_model.justification() == JUSTIFICATION_LEFT &amp;&amp;
1450               next_model.justification() != JUSTIFICATION_LEFT) ||
1451              (!(*rows)[start].ri_-&gt;ltr &amp;&amp; last_model.justification() == JUSTIFICATION_RIGHT &amp;&amp;
1452               next_model.justification() != JUSTIFICATION_RIGHT)) {
1453            next_consistent = false;
1454          }
1455          last_model = next_model;
1456        } else {
1457          next_consistent = false;
1458        }
1459      } while (next_consistent &amp;&amp; end &lt; row_end);
1460      if (end &gt; start + 1) {
1461        const ParagraphModel *model = nullptr;
1462        ParagraphModel new_model = ParagraphModelByOutline(
1463            debug_level, rows, start, end, Epsilon(InterwordSpace(*rows, start, end)));
1464        if (new_model.justification() == JUSTIFICATION_UNKNOWN) {
1465        } else if (new_model.is_flush()) {
1466          if (end == start + 2) {
1467            end = start + 1;
1468          } else if (start == row_start) {
1469            if (new_model.justification() == JUSTIFICATION_LEFT) {
1470              model = kCrownLeft;
1471            } else {
1472              model = kCrownRight;
1473            }
1474          } else if (allow_flush_models) {
1475            model = theory-&gt;AddModel(new_model);
1476          }
1477        } else {
1478          model = theory-&gt;AddModel(new_model);
1479        }
1480        if (model) {
1481          (*rows)[start].AddStartLine(model);
1482          for (int i = start + 1; i &lt; end; i++) {
1483            (*rows)[i].AddBodyLine(model);
1484          }
1485        }
1486      }
1487      start = end;
1488    }
1489  }
1490  static void StrongEvidenceClassify(int debug_level, std::vector&lt;RowScratchRegisters&gt; *rows,
1491                                     int row_start, int row_end, ParagraphTheory *theory) {
1492    if (!AcceptableRowArgs(debug_level, 2, __func__, rows, row_start, row_end)) {
1493      return;
1494    }
1495    if (debug_level &gt; 1) {
1496      tprintf(&quot;#############################################\n&quot;);
1497      tprintf(&quot;# StrongEvidenceClassify( rows[%d:%d) )\n&quot;, row_start, row_end);
1498      tprintf(&quot;#############################################\n&quot;);
1499    }
1500    RecomputeMarginsAndClearHypotheses(rows, row_start, row_end, 10);
1501    MarkStrongEvidence(rows, row_start, row_end);
1502    DebugDump(debug_level &gt; 2, &quot;Initial strong signals.&quot;, *theory, *rows);
<span onclick='openModal()' class='match'>1503    ModelStrongEvidence(debug_level, rows, row_start, row_end, false, theory);
1504    DebugDump(debug_level &gt; 2, &quot;Unsmeared hypotheses.s.&quot;, *theory, *rows);
</span>1505    ParagraphModelSmearer smearer(rows, row_start, row_end, theory);
1506    smearer.Smear();
1507  }
1508  static void SeparateSimpleLeaderLines(std::vector&lt;RowScratchRegisters&gt; *rows, int row_start,
1509                                        int row_end, ParagraphTheory *theory) {
1510    for (int i = row_start + 1; i &lt; row_end - 1; i++) {
1511      if ((*rows)[i - 1].ri_-&gt;has_leaders &amp;&amp; (*rows)[i].ri_-&gt;has_leaders &amp;&amp;
1512          (*rows)[i + 1].ri_-&gt;has_leaders) {
1513        const ParagraphModel *model =
1514            theory-&gt;AddModel(ParagraphModel(JUSTIFICATION_UNKNOWN, 0, 0, 0, 0));
1515        (*rows)[i].AddStartLine(model);
1516      }
1517    }
1518  }
1519  static void ConvertHypothesizedModelRunsToParagraphs(int debug_level,
1520                                                       std::vector&lt;RowScratchRegisters&gt; &amp;rows,
1521                                                       std::vector&lt;PARA *&gt; *row_owners,
1522                                                       ParagraphTheory *theory) {
1523    int end = rows.size();
1524    int start;
1525    for (; end &gt; 0; end = start) {
1526      start = end - 1;
1527      const ParagraphModel *model = nullptr;
1528      bool single_line_paragraph = false;
1529      SetOfModels models;
1530      rows[start].NonNullHypotheses(&amp;models);
1531      if (!models.empty()) {
1532        model = models[0];
1533        if (rows[start].GetLineType(model) != LT_BODY) {
1534          single_line_paragraph = true;
1535        }
1536      }
1537      if (model &amp;&amp; !single_line_paragraph) {
1538        while (--start &gt; 0 &amp;&amp; rows[start].GetLineType(model) == LT_BODY) {
1539        }
1540        if (start &lt; 0 || rows[start].GetLineType(model) != LT_START) {
1541          model = nullptr;
1542        }
1543      }
1544      if (model == nullptr) {
1545        continue;
1546      }
1547      PARA *p = new PARA();
1548      if (model == kCrownLeft || model == kCrownRight) {
1549        p-&gt;is_very_first_or_continuation = true;
1550        for (unsigned row = end; row &lt; rows.size(); row++) {
1551          if ((*row_owners)[row] &amp;&amp;
1552              (ValidBodyLine(&amp;rows, start, (*row_owners)[row]-&gt;model) &amp;&amp;
1553               (start == 0 || ValidFirstLine(&amp;rows, start, (*row_owners)[row]-&gt;model)))) {
1554            model = (*row_owners)[row]-&gt;model;
1555            break;
1556          }
1557        }
1558        if (model == kCrownLeft) {
1559          model = theory-&gt;AddModel(ParagraphModel(JUSTIFICATION_LEFT,
1560                                                  rows[start].lmargin_ + rows[start].lindent_, 0, 0,
1561                                                  Epsilon(rows[start].ri_-&gt;average_interword_space)));
1562        } else if (model == kCrownRight) {
1563          model = theory-&gt;AddModel(ParagraphModel(JUSTIFICATION_RIGHT,
1564                                                  rows[start].rmargin_ + rows[start].rmargin_, 0, 0,
1565                                                  Epsilon(rows[start].ri_-&gt;average_interword_space)));
1566        }
1567      }
1568      rows[start].SetUnknown();
1569      rows[start].AddStartLine(model);
1570      for (int i = start + 1; i &lt; end; i++) {
1571        rows[i].SetUnknown();
1572        rows[i].AddBodyLine(model);
1573      }
1574      p-&gt;model = model;
1575      p-&gt;has_drop_cap = rows[start].ri_-&gt;has_drop_cap;
1576      p-&gt;is_list_item = model-&gt;justification() == JUSTIFICATION_RIGHT
1577                            ? rows[start].ri_-&gt;rword_indicates_list_item
1578                            : rows[start].ri_-&gt;lword_indicates_list_item;
1579      for (int row = start; row &lt; end; row++) {
1580        if ((*row_owners)[row] != nullptr) {
1581          tprintf(
1582              &quot;Memory leak! ConvertHypothesizeModelRunsToParagraphs() called &quot;
1583              &quot;more than once!\n&quot;);
1584          delete (*row_owners)[row];
1585        }
1586        (*row_owners)[row] = p;
1587      }
1588    }
1589  }
1590  struct Interval {
1591    Interval() : begin(0), end(0) {}
1592    Interval(int b, int e) : begin(b), end(e) {}
1593    int begin;
1594    int end;
1595  };
1596  static bool RowIsStranded(const std::vector&lt;RowScratchRegisters&gt; &amp;rows, int row) {
1597    SetOfModels row_models;
1598    rows[row].StrongHypotheses(&amp;row_models);
1599    for (auto &amp;row_model : row_models) {
1600      bool all_starts = rows[row].GetLineType();
1601      int run_length = 1;
1602      bool continues = true;
1603      for (int i = row - 1; i &gt;= 0 &amp;&amp; continues; i--) {
1604        SetOfModels models;
1605        rows[i].NonNullHypotheses(&amp;models);
1606        switch (rows[i].GetLineType(row_model)) {
1607          case LT_START:
1608            run_length++;
1609            break;
1610          case LT_MULTIPLE: 
1611          case LT_BODY:
1612            run_length++;
1613            all_starts = false;
1614            break;
1615          case LT_UNKNOWN: 
1616          default:
1617            continues = false;
1618        }
1619      }
1620      continues = true;
1621      for (unsigned i = row + 1; i &lt; rows.size() &amp;&amp; continues; i++) {
1622        SetOfModels models;
1623        rows[i].NonNullHypotheses(&amp;models);
1624        switch (rows[i].GetLineType(row_model)) {
1625          case LT_START:
1626            run_length++;
1627            break;
1628          case LT_MULTIPLE: 
1629          case LT_BODY:
1630            run_length++;
1631            all_starts = false;
1632            break;
1633          case LT_UNKNOWN: 
1634          default:
1635            continues = false;
1636        }
1637      }
1638      if (run_length &gt; 2 || (!all_starts &amp;&amp; run_length &gt; 1)) {
1639        return false;
1640      }
1641    }
1642    return true;
1643  }
1644  static void LeftoverSegments(const std::vector&lt;RowScratchRegisters&gt; &amp;rows,
1645                               std::vector&lt;Interval&gt; *to_fix, int row_start, int row_end) {
1646    to_fix-&gt;clear();
1647    for (int i = row_start; i &lt; row_end; i++) {
1648      bool needs_fixing = false;
1649      SetOfModels models;
1650      SetOfModels models_w_crowns;
1651      rows[i].StrongHypotheses(&amp;models);
1652      rows[i].NonNullHypotheses(&amp;models_w_crowns);
1653      if (models.empty() &amp;&amp; !models_w_crowns.empty()) {
1654        for (unsigned end = i + 1; end &lt; rows.size(); end++) {
1655          SetOfModels end_models;
1656          SetOfModels strong_end_models;
1657          rows[end].NonNullHypotheses(&amp;end_models);
1658          rows[end].StrongHypotheses(&amp;strong_end_models);
1659          if (end_models.empty()) {
1660            needs_fixing = true;
1661            break;
1662          } else if (!strong_end_models.empty()) {
1663            needs_fixing = false;
1664            break;
1665          }
1666        }
1667      } else if (models.empty() &amp;&amp; rows[i].ri_-&gt;num_words &gt; 0) {
1668        needs_fixing = true;
1669      }
1670      if (!needs_fixing &amp;&amp; !models.empty()) {
1671        needs_fixing = RowIsStranded(rows, i);
1672      }
1673      if (needs_fixing) {
1674        if (!to_fix-&gt;empty() &amp;&amp; to_fix-&gt;back().end == i - 1) {
1675          to_fix-&gt;back().end = i;
1676        } else {
1677          to_fix-&gt;push_back(Interval(i, i));
1678        }
1679      }
1680    }
1681    for (auto &amp;i : *to_fix) {
1682      i.end = i.end + 1;
1683    }
1684  }
1685  void CanonicalizeDetectionResults(std::vector&lt;PARA *&gt; *row_owners, PARA_LIST *paragraphs) {
1686    std::vector&lt;PARA *&gt; &amp;rows = *row_owners;
1687    paragraphs-&gt;clear();
1688    PARA_IT out(paragraphs);
1689    PARA *formerly_null = nullptr;
1690    for (unsigned i = 0; i &lt; rows.size(); i++) {
1691      if (rows[i] == nullptr) {
1692        if (i == 0 || rows[i - 1] != formerly_null) {
1693          rows[i] = formerly_null = new PARA();
1694        } else {
1695          rows[i] = formerly_null;
1696          continue;
1697        }
1698      } else if (i &gt; 0 &amp;&amp; rows[i - 1] == rows[i]) {
1699        continue;
1700      }
1701      out.add_after_then_move(rows[i]);
1702    }
1703  }
1704  void DetectParagraphs(int debug_level, std::vector&lt;RowInfo&gt; *row_infos,
1705                        std::vector&lt;PARA *&gt; *row_owners, PARA_LIST *paragraphs,
1706                        std::vector&lt;ParagraphModel *&gt; *models) {
1707    ParagraphTheory theory(models);
1708    row_owners-&gt;clear();
1709    row_owners-&gt;resize(row_infos-&gt;size());
1710    std::vector&lt;RowScratchRegisters&gt; rows(row_infos-&gt;size());
1711    for (unsigned i = 0; i &lt; row_infos-&gt;size(); i++) {
1712      rows[i].Init((*row_infos)[i]);
1713    }
1714    SeparateSimpleLeaderLines(&amp;rows, 0, rows.size(), &amp;theory);
1715    DebugDump(debug_level &gt; 1, &quot;End of Pass 1&quot;, theory, rows);
1716    std::vector&lt;Interval&gt; leftovers;
1717    LeftoverSegments(rows, &amp;leftovers, 0, rows.size());
1718    for (auto &amp;leftover : leftovers) {
1719      StrongEvidenceClassify(debug_level, &amp;rows, leftover.begin, leftover.end, &amp;theory);
1720      std::vector&lt;Interval&gt; leftovers2;
1721      LeftoverSegments(rows, &amp;leftovers2, leftover.begin, leftover.end);
1722      bool pass2a_was_useful =
1723          leftovers2.size() &gt; 1 ||
1724          (leftovers2.size() == 1 &amp;&amp; (leftovers2[0].begin != 0 || static_cast&lt;size_t&gt;(leftovers2[0].end) != rows.size()));
1725      if (pass2a_was_useful) {
1726        for (auto &amp;leftover2 : leftovers2) {
1727          StrongEvidenceClassify(debug_level, &amp;rows, leftover2.begin, leftover2.end, &amp;theory);
1728        }
1729      }
1730    }
1731    DebugDump(debug_level &gt; 1, &quot;End of Pass 2&quot;, theory, rows);
1732    LeftoverSegments(rows, &amp;leftovers, 0, rows.size());
1733    for (auto &amp;leftover : leftovers) {
1734      GeometricClassify(debug_level, &amp;rows, leftover.begin, leftover.end, &amp;theory);
1735    }
1736    DowngradeWeakestToCrowns(debug_level, &amp;theory, &amp;rows);
1737    DebugDump(debug_level &gt; 1, &quot;End of Pass 3&quot;, theory, rows);
1738    LeftoverSegments(rows, &amp;leftovers, 0, rows.size());
1739    for (auto &amp;leftover : leftovers) {
1740      for (int j = leftover.begin; j &lt; leftover.end; j++) {
1741        rows[j].SetUnknown();
1742      }
1743    }
1744    DebugDump(debug_level &gt; 1, &quot;End of Pass 4&quot;, theory, rows);
1745    ConvertHypothesizedModelRunsToParagraphs(debug_level, rows, row_owners, &amp;theory);
1746    DebugDump(debug_level &gt; 0, &quot;Final Paragraph Segmentation&quot;, theory, rows);
1747    CanonicalizeDetectionResults(row_owners, paragraphs);
1748  }
1749  static void InitializeTextAndBoxesPreRecognition(const MutableIterator &amp;it, RowInfo *info) {
1750    std::string fake_text;
1751    PageIterator pit(static_cast&lt;const PageIterator &amp;&gt;(it));
1752    bool first_word = true;
1753    if (!pit.Empty(RIL_WORD)) {
1754      do {
1755        fake_text += &quot;x&quot;;
1756        if (first_word) {
1757          info-&gt;lword_text += &quot;x&quot;;
1758        }
1759        info-&gt;rword_text += &quot;x&quot;;
1760        if (pit.IsAtFinalElement(RIL_WORD, RIL_SYMBOL) &amp;&amp;
1761            !pit.IsAtFinalElement(RIL_TEXTLINE, RIL_SYMBOL)) {
1762          fake_text += &quot; &quot;;
1763          info-&gt;rword_text = &quot;&quot;;
1764          first_word = false;
1765        }
1766      } while (!pit.IsAtFinalElement(RIL_TEXTLINE, RIL_SYMBOL) &amp;&amp; pit.Next(RIL_SYMBOL));
1767    }
1768    if (fake_text.empty()) {
1769      return;
1770    }
1771    int lspaces = info-&gt;pix_ldistance / info-&gt;average_interword_space;
1772    for (int i = 0; i &lt; lspaces; i++) {
1773      info-&gt;text += &#x27; &#x27;;
1774    }
1775    info-&gt;text += fake_text;
1776    PAGE_RES_IT page_res_it = *it.PageResIt();
1777    WERD_RES *word_res = page_res_it.restart_row();
1778    ROW_RES *this_row = page_res_it.row();
1779    WERD_RES *lword = nullptr;
1780    WERD_RES *rword = nullptr;
1781    info-&gt;num_words = 0;
1782    do {
1783      if (word_res) {
1784        if (!lword) {
1785          lword = word_res;
1786        }
1787        if (rword != word_res) {
1788          info-&gt;num_words++;
1789        }
1790        rword = word_res;
1791      }
1792      word_res = page_res_it.forward();
1793    } while (page_res_it.row() == this_row);
1794    if (lword) {
1795      info-&gt;lword_box = lword-&gt;word-&gt;bounding_box();
1796    }
1797    if (rword) {
1798      info-&gt;rword_box = rword-&gt;word-&gt;bounding_box();
1799    }
1800  }
1801  static void InitializeRowInfo(bool after_recognition, const MutableIterator &amp;it, RowInfo *info) {
1802    if (it.PageResIt()-&gt;row() != nullptr) {
1803      ROW *row = it.PageResIt()-&gt;row()-&gt;row;
1804      info-&gt;pix_ldistance = row-&gt;lmargin();
1805      info-&gt;pix_rdistance = row-&gt;rmargin();
1806      info-&gt;average_interword_space =
1807          row-&gt;space() &gt; 0 ? row-&gt;space() : std::max(static_cast&lt;int&gt;(row-&gt;x_height()), 1);
1808      info-&gt;pix_xheight = row-&gt;x_height();
1809      info-&gt;has_leaders = false;
1810      info-&gt;has_drop_cap = row-&gt;has_drop_cap();
1811      info-&gt;ltr = true; 
1812    } else {
1813      info-&gt;pix_ldistance = info-&gt;pix_rdistance = 0;
1814      info-&gt;average_interword_space = 1;
1815      info-&gt;pix_xheight = 1.0;
1816      info-&gt;has_leaders = false;
1817      info-&gt;has_drop_cap = false;
1818      info-&gt;ltr = true;
1819    }
1820    info-&gt;num_words = 0;
1821    info-&gt;lword_indicates_list_item = false;
1822    info-&gt;lword_likely_starts_idea = false;
1823    info-&gt;lword_likely_ends_idea = false;
1824    info-&gt;rword_indicates_list_item = false;
1825    info-&gt;rword_likely_starts_idea = false;
1826    info-&gt;rword_likely_ends_idea = false;
1827    info-&gt;has_leaders = false;
1828    info-&gt;ltr = true;
1829    if (!after_recognition) {
1830      InitializeTextAndBoxesPreRecognition(it, info);
1831      return;
1832    }
1833    info-&gt;text = &quot;&quot;;
1834    const std::unique_ptr&lt;const char[]&gt; text(it.GetUTF8Text(RIL_TEXTLINE));
1835    int trailing_ws_idx = strlen(text.get()); 
1836    while (trailing_ws_idx &gt; 0 &amp;&amp;
1837           isascii(text[trailing_ws_idx - 1]) &amp;&amp; isspace(text[trailing_ws_idx - 1])) {
1838      trailing_ws_idx--;
1839    }
1840    if (trailing_ws_idx &gt; 0) {
1841      int lspaces = info-&gt;pix_ldistance / info-&gt;average_interword_space;
1842      for (int i = 0; i &lt; lspaces; i++) {
1843        info-&gt;text += &#x27; &#x27;;
1844      }
1845      for (int i = 0; i &lt; trailing_ws_idx; i++) {
1846        info-&gt;text += text[i];
1847      }
1848    }
1849    if (info-&gt;text.empty()) {
1850      return;
1851    }
1852    PAGE_RES_IT page_res_it = *it.PageResIt();
1853    std::vector&lt;WERD_RES *&gt; werds;
1854    WERD_RES *word_res = page_res_it.restart_row();
1855    ROW_RES *this_row = page_res_it.row();
1856    int num_leaders = 0;
1857    int ltr = 0;
1858    int rtl = 0;
1859    do {
1860      if (word_res &amp;&amp; word_res-&gt;best_choice-&gt;unichar_string().length() &gt; 0) {
1861        werds.push_back(word_res);
1862        ltr += word_res-&gt;AnyLtrCharsInWord() ? 1 : 0;
1863        rtl += word_res-&gt;AnyRtlCharsInWord() ? 1 : 0;
1864        if (word_res-&gt;word-&gt;flag(W_REP_CHAR)) {
1865          num_leaders++;
1866        }
1867      }
1868      word_res = page_res_it.forward();
1869    } while (page_res_it.row() == this_row);
1870    info-&gt;ltr = ltr &gt;= rtl;
1871    info-&gt;has_leaders = num_leaders &gt; 3;
1872    info-&gt;num_words = werds.size();
1873    if (!werds.empty()) {
1874      WERD_RES *lword = werds[0], *rword = werds[werds.size() - 1];
1875      info-&gt;lword_text = lword-&gt;best_choice-&gt;unichar_string().c_str();
1876      info-&gt;rword_text = rword-&gt;best_choice-&gt;unichar_string().c_str();
1877      info-&gt;lword_box = lword-&gt;word-&gt;bounding_box();
1878      info-&gt;rword_box = rword-&gt;word-&gt;bounding_box();
1879      LeftWordAttributes(lword-&gt;uch_set, lword-&gt;best_choice, info-&gt;lword_text,
1880                         &amp;info-&gt;lword_indicates_list_item, &amp;info-&gt;lword_likely_starts_idea,
1881                         &amp;info-&gt;lword_likely_ends_idea);
1882      RightWordAttributes(rword-&gt;uch_set, rword-&gt;best_choice, info-&gt;rword_text,
1883                          &amp;info-&gt;rword_indicates_list_item, &amp;info-&gt;rword_likely_starts_idea,
1884                          &amp;info-&gt;rword_likely_ends_idea);
1885    }
1886  }
1887  void DetectParagraphs(int debug_level, bool after_text_recognition,
1888                        const MutableIterator *block_start, std::vector&lt;ParagraphModel *&gt; *models) {
1889    if (block_start-&gt;Empty(RIL_TEXTLINE)) {
1890      return;
1891    }
1892    BLOCK *block = block_start-&gt;PageResIt()-&gt;block()-&gt;block;
1893    block-&gt;para_list()-&gt;clear();
1894    bool is_image_block = block-&gt;pdblk.poly_block() &amp;&amp; !block-&gt;pdblk.poly_block()-&gt;IsText();
1895    MutableIterator row(*block_start);
1896    if (row.Empty(RIL_TEXTLINE)) {
1897      return; 
1898    }
1899    std::vector&lt;RowInfo&gt; row_infos;
1900    do {
1901      if (!row.PageResIt()-&gt;row()) {
1902        continue; 
1903      }
1904      row.PageResIt()-&gt;row()-&gt;row-&gt;set_para(nullptr);
1905      row_infos.emplace_back();
1906      RowInfo &amp;ri = row_infos.back();
1907      InitializeRowInfo(after_text_recognition, row, &amp;ri);
1908    } while (!row.IsAtFinalElement(RIL_BLOCK, RIL_TEXTLINE) &amp;&amp; row.Next(RIL_TEXTLINE));
1909    if (!row_infos.empty()) {
1910      int min_lmargin = row_infos[0].pix_ldistance;
1911      int min_rmargin = row_infos[0].pix_rdistance;
1912      for (unsigned i = 1; i &lt; row_infos.size(); i++) {
1913        if (row_infos[i].pix_ldistance &lt; min_lmargin) {
1914          min_lmargin = row_infos[i].pix_ldistance;
1915        }
1916        if (row_infos[i].pix_rdistance &lt; min_rmargin) {
1917          min_rmargin = row_infos[i].pix_rdistance;
1918        }
1919      }
1920      if (min_lmargin &gt; 0 || min_rmargin &gt; 0) {
1921        for (auto &amp;row_info : row_infos) {
1922          row_info.pix_ldistance -= min_lmargin;
1923          row_info.pix_rdistance -= min_rmargin;
1924        }
1925      }
1926    }
1927    std::vector&lt;PARA *&gt; row_owners;
1928    std::vector&lt;PARA *&gt; the_paragraphs;
1929    if (!is_image_block) {
1930      DetectParagraphs(debug_level, &amp;row_infos, &amp;row_owners, block-&gt;para_list(), models);
1931    } else {
1932      row_owners.resize(row_infos.size());
1933      CanonicalizeDetectionResults(&amp;row_owners, block-&gt;para_list());
1934    }
1935    row = *block_start;
1936    for (auto &amp;row_owner : row_owners) {
1937      while (!row.PageResIt()-&gt;row()) {
1938        row.Next(RIL_TEXTLINE);
1939      }
1940      row.PageResIt()-&gt;row()-&gt;row-&gt;set_para(row_owner);
1941      row.Next(RIL_TEXTLINE);
1942    }
1943  }
1944  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ccar.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-paragraphs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>21      CenterMultiply(TargetL, cq1, cq, CenterT, false, Ones);
22  	TFltV pqy(TargetL.GetRows());
</pre></code></div>
                <div class="column column_space"><pre><code>1503    ModelStrongEvidence(debug_level, rows, row_start, row_end, false, theory);
1504    DebugDump(debug_level &gt; 2, &quot;Unsmeared hypotheses.s.&quot;, *theory, *rows);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    