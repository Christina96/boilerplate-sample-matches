
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time.cc</h3>
            <pre><code>1  #include "absl/time/time.h"
2  #if defined(_MSC_VER)
3  #include <winsock2.h>  
4  #endif
5  #include <cstring>
6  #include <ctime>
7  #include <limits>
8  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
9  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
10  namespace cctz = absl::time_internal::cctz;
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace {
14  inline cctz::time_point<cctz::seconds> unix_epoch() {
15    return std::chrono::time_point_cast<cctz::seconds>(
16        std::chrono::system_clock::from_time_t(0));
17  }
18  inline int64_t FloorToUnit(absl::Duration d, absl::Duration unit) {
19    absl::Duration rem;
20    int64_t q = absl::IDivDuration(d, unit, &rem);
21    return (q > 0 || rem >= ZeroDuration() ||
22            q == std::numeric_limits<int64_t>::min())
23               ? q
24               : q - 1;
25  }
26  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
27  inline absl::Time::Breakdown InfiniteFutureBreakdown() {
28    absl::Time::Breakdown bd;
29    bd.year = std::numeric_limits<int64_t>::max();
30    bd.month = 12;
31    bd.day = 31;
32    bd.hour = 23;
33    bd.minute = 59;
34    bd.second = 59;
35    bd.subsecond = absl::InfiniteDuration();
36    bd.weekday = 4;
37    bd.yearday = 365;
38    bd.offset = 0;
39    bd.is_dst = false;
40    bd.zone_abbr = "-00";
41    return bd;
42  }
43  inline absl::Time::Breakdown InfinitePastBreakdown() {
44    Time::Breakdown bd;
45    bd.year = std::numeric_limits<int64_t>::min();
46    bd.month = 1;
47    bd.day = 1;
48    bd.hour = 0;
49    bd.minute = 0;
50    bd.second = 0;
51    bd.subsecond = -absl::InfiniteDuration();
52    bd.weekday = 7;
53    bd.yearday = 1;
54    bd.offset = 0;
55    bd.is_dst = false;
56    bd.zone_abbr = "-00";
57    return bd;
58  }
59  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
60  inline absl::TimeZone::CivilInfo InfiniteFutureCivilInfo() {
61    TimeZone::CivilInfo ci;
62    ci.cs = CivilSecond::max();
63    ci.subsecond = InfiniteDuration();
64    ci.offset = 0;
65    ci.is_dst = false;
66    ci.zone_abbr = "-00";
67    return ci;
68  }
69  inline absl::TimeZone::CivilInfo InfinitePastCivilInfo() {
70    TimeZone::CivilInfo ci;
71    ci.cs = CivilSecond::min();
72    ci.subsecond = -InfiniteDuration();
73    ci.offset = 0;
74    ci.is_dst = false;
75    ci.zone_abbr = "-00";
76    return ci;
77  }
78  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
79  inline absl::TimeConversion InfiniteFutureTimeConversion() {
80    absl::TimeConversion tc;
81    tc.pre = tc.trans = tc.post = absl::InfiniteFuture();
82    tc.kind = absl::TimeConversion::UNIQUE;
83    tc.normalized = true;
84    return tc;
85  }
86  inline TimeConversion InfinitePastTimeConversion() {
87    absl::TimeConversion tc;
88    tc.pre = tc.trans = tc.post = absl::InfinitePast();
89    tc.kind = absl::TimeConversion::UNIQUE;
90    tc.normalized = true;
91    return tc;
92  }
93  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
94  Time MakeTimeWithOverflow(const cctz::time_point<cctz::seconds>& sec,
95                            const cctz::civil_second& cs,
96                            const cctz::time_zone& tz,
97                            bool* normalized = nullptr) {
98    const auto max = cctz::time_point<cctz::seconds>::max();
99    const auto min = cctz::time_point<cctz::seconds>::min();
100    if (sec == max) {
101      const auto al = tz.lookup(max);
102      if (cs > al.cs) {
103        if (normalized) *normalized = true;
104        return absl::InfiniteFuture();
105      }
106    }
107    if (sec == min) {
108      const auto al = tz.lookup(min);
109      if (cs < al.cs) {
110        if (normalized) *normalized = true;
111        return absl::InfinitePast();
112      }
113    }
114    const auto hi = (sec - unix_epoch()).count();
115    return time_internal::FromUnixDuration(time_internal::MakeDuration(hi));
116  }
117  inline int MapWeekday(const cctz::weekday& wd) {
118    switch (wd) {
119      case cctz::weekday::monday:
120        return 1;
121      case cctz::weekday::tuesday:
122        return 2;
123      case cctz::weekday::wednesday:
124        return 3;
125      case cctz::weekday::thursday:
126        return 4;
127      case cctz::weekday::friday:
128        return 5;
129      case cctz::weekday::saturday:
130        return 6;
131      case cctz::weekday::sunday:
132        return 7;
133    }
134    return 1;
135  }
136  bool FindTransition(const cctz::time_zone& tz,
137                      bool (cctz::time_zone::*find_transition)(
138                          const cctz::time_point<cctz::seconds>& tp,
139                          cctz::time_zone::civil_transition* trans) const,
140                      Time t, TimeZone::CivilTransition* trans) {
141    const auto tp = unix_epoch() + cctz::seconds(ToUnixSeconds(t));
142    cctz::time_zone::civil_transition tr;
143    if (!(tz.*find_transition)(tp, &tr)) return false;
<span onclick='openModal()' class='match'>144    trans->from = CivilSecond(tr.from);
145    trans->to = CivilSecond(tr.to);
146    return true;
</span>147  }
148  }  
149  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
150  absl::Time::Breakdown Time::In(absl::TimeZone tz) const {
151    if (*this == absl::InfiniteFuture()) return InfiniteFutureBreakdown();
152    if (*this == absl::InfinitePast()) return InfinitePastBreakdown();
153    const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(rep_));
154    const auto al = cctz::time_zone(tz).lookup(tp);
155    const auto cs = al.cs;
156    const auto cd = cctz::civil_day(cs);
157    absl::Time::Breakdown bd;
158    bd.year = cs.year();
159    bd.month = cs.month();
160    bd.day = cs.day();
161    bd.hour = cs.hour();
162    bd.minute = cs.minute();
163    bd.second = cs.second();
164    bd.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(rep_));
165    bd.weekday = MapWeekday(cctz::get_weekday(cd));
166    bd.yearday = cctz::get_yearday(cd);
167    bd.offset = al.offset;
168    bd.is_dst = al.is_dst;
169    bd.zone_abbr = al.abbr;
170    return bd;
171  }
172  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
173  absl::Time FromUDate(double udate) {
174    return time_internal::FromUnixDuration(absl::Milliseconds(udate));
175  }
176  absl::Time FromUniversal(int64_t universal) {
177    return absl::UniversalEpoch() + 100 * absl::Nanoseconds(universal);
178  }
179  int64_t ToUnixNanos(Time t) {
180    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
181        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 33 == 0) {
182      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
183              1000 * 1000 * 1000) +
184             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4);
185    }
186    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Nanoseconds(1));
187  }
188  int64_t ToUnixMicros(Time t) {
189    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
190        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 43 == 0) {
191      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
192              1000 * 1000) +
193             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4000);
194    }
195    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Microseconds(1));
196  }
197  int64_t ToUnixMillis(Time t) {
198    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
199        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 53 == 0) {
200      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) * 1000) +
201             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) /
202              (4000 * 1000));
203    }
204    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Milliseconds(1));
205  }
206  int64_t ToUnixSeconds(Time t) {
207    return time_internal::GetRepHi(time_internal::ToUnixDuration(t));
208  }
209  time_t ToTimeT(Time t) { return absl::ToTimespec(t).tv_sec; }
210  double ToUDate(Time t) {
211    return absl::FDivDuration(time_internal::ToUnixDuration(t),
212                              absl::Milliseconds(1));
213  }
214  int64_t ToUniversal(absl::Time t) {
215    return absl::FloorToUnit(t - absl::UniversalEpoch(), absl::Nanoseconds(100));
216  }
217  absl::Time TimeFromTimespec(timespec ts) {
218    return time_internal::FromUnixDuration(absl::DurationFromTimespec(ts));
219  }
220  absl::Time TimeFromTimeval(timeval tv) {
221    return time_internal::FromUnixDuration(absl::DurationFromTimeval(tv));
222  }
223  timespec ToTimespec(Time t) {
224    timespec ts;
225    absl::Duration d = time_internal::ToUnixDuration(t);
226    if (!time_internal::IsInfiniteDuration(d)) {
227      ts.tv_sec = static_cast<decltype(ts.tv_sec)>(time_internal::GetRepHi(d));
228      if (ts.tv_sec == time_internal::GetRepHi(d)) {  
229        ts.tv_nsec = time_internal::GetRepLo(d) / 4;  
230        return ts;
231      }
232    }
233    if (d >= absl::ZeroDuration()) {
234      ts.tv_sec = std::numeric_limits<time_t>::max();
235      ts.tv_nsec = 1000 * 1000 * 1000 - 1;
236    } else {
237      ts.tv_sec = std::numeric_limits<time_t>::min();
238      ts.tv_nsec = 0;
239    }
240    return ts;
241  }
242  timeval ToTimeval(Time t) {
243    timeval tv;
244    timespec ts = absl::ToTimespec(t);
245    tv.tv_sec = static_cast<decltype(tv.tv_sec)>(ts.tv_sec);
246    if (tv.tv_sec != ts.tv_sec) {  
247      if (ts.tv_sec < 0) {
248        tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();
249        tv.tv_usec = 0;
250      } else {
251        tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();
252        tv.tv_usec = 1000 * 1000 - 1;
253      }
254      return tv;
255    }
256    tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  
257    return tv;
258  }
259  Time FromChrono(const std::chrono::system_clock::time_point& tp) {
260    return time_internal::FromUnixDuration(time_internal::FromChrono(
261        tp - std::chrono::system_clock::from_time_t(0)));
262  }
263  std::chrono::system_clock::time_point ToChronoTime(absl::Time t) {
264    using D = std::chrono::system_clock::duration;
265    auto d = time_internal::ToUnixDuration(t);
266    if (d < ZeroDuration()) d = Floor(d, FromChrono(D{1}));
267    return std::chrono::system_clock::from_time_t(0) +
268           time_internal::ToChronoDuration<D>(d);
269  }
270  absl::TimeZone::CivilInfo TimeZone::At(Time t) const {
271    if (t == absl::InfiniteFuture()) return InfiniteFutureCivilInfo();
272    if (t == absl::InfinitePast()) return InfinitePastCivilInfo();
273    const auto ud = time_internal::ToUnixDuration(t);
274    const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(ud));
275    const auto al = cz_.lookup(tp);
276    TimeZone::CivilInfo ci;
277    ci.cs = CivilSecond(al.cs);
278    ci.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(ud));
279    ci.offset = al.offset;
280    ci.is_dst = al.is_dst;
281    ci.zone_abbr = al.abbr;
282    return ci;
283  }
284  absl::TimeZone::TimeInfo TimeZone::At(CivilSecond ct) const {
285    const cctz::civil_second cs(ct);
286    const auto cl = cz_.lookup(cs);
287    TimeZone::TimeInfo ti;
288    switch (cl.kind) {
289      case cctz::time_zone::civil_lookup::UNIQUE:
290        ti.kind = TimeZone::TimeInfo::UNIQUE;
291        break;
292      case cctz::time_zone::civil_lookup::SKIPPED:
293        ti.kind = TimeZone::TimeInfo::SKIPPED;
294        break;
295      case cctz::time_zone::civil_lookup::REPEATED:
296        ti.kind = TimeZone::TimeInfo::REPEATED;
297        break;
298    }
299    ti.pre = MakeTimeWithOverflow(cl.pre, cs, cz_);
300    ti.trans = MakeTimeWithOverflow(cl.trans, cs, cz_);
301    ti.post = MakeTimeWithOverflow(cl.post, cs, cz_);
302    return ti;
303  }
304  bool TimeZone::NextTransition(Time t, CivilTransition* trans) const {
305    return FindTransition(cz_, &cctz::time_zone::next_transition, t, trans);
306  }
307  bool TimeZone::PrevTransition(Time t, CivilTransition* trans) const {
308    return FindTransition(cz_, &cctz::time_zone::prev_transition, t, trans);
309  }
310  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
311  absl::TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,
312                                       int min, int sec, TimeZone tz) {
313    if (year > 300000000000) return InfiniteFutureTimeConversion();
314    if (year < -300000000000) return InfinitePastTimeConversion();
315    const CivilSecond cs(year, mon, day, hour, min, sec);
316    const auto ti = tz.At(cs);
317    TimeConversion tc;
318    tc.pre = ti.pre;
319    tc.trans = ti.trans;
320    tc.post = ti.post;
321    switch (ti.kind) {
322      case TimeZone::TimeInfo::UNIQUE:
323        tc.kind = TimeConversion::UNIQUE;
324        break;
325      case TimeZone::TimeInfo::SKIPPED:
326        tc.kind = TimeConversion::SKIPPED;
327        break;
328      case TimeZone::TimeInfo::REPEATED:
329        tc.kind = TimeConversion::REPEATED;
330        break;
331    }
332    tc.normalized = false;
333    if (year != cs.year() || mon != cs.month() || day != cs.day() ||
334        hour != cs.hour() || min != cs.minute() || sec != cs.second()) {
335      tc.normalized = true;
336    }
337    return tc;
338  }
339  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
340  absl::Time FromTM(const struct tm& tm, absl::TimeZone tz) {
341    civil_year_t tm_year = tm.tm_year;
342    if (tm_year > 300000000000ll) return InfiniteFuture();
343    if (tm_year < -300000000000ll) return InfinitePast();
344    int tm_mon = tm.tm_mon;
345    if (tm_mon == std::numeric_limits<int>::max()) {
346      tm_mon -= 12;
347      tm_year += 1;
348    }
349    const auto ti = tz.At(CivilSecond(tm_year + 1900, tm_mon + 1, tm.tm_mday,
350                                      tm.tm_hour, tm.tm_min, tm.tm_sec));
351    return tm.tm_isdst == 0 ? ti.post : ti.pre;
352  }
353  struct tm ToTM(absl::Time t, absl::TimeZone tz) {
354    struct tm tm = {};
355    const auto ci = tz.At(t);
356    const auto& cs = ci.cs;
357    tm.tm_sec = cs.second();
358    tm.tm_min = cs.minute();
359    tm.tm_hour = cs.hour();
360    tm.tm_mday = cs.day();
361    tm.tm_mon = cs.month() - 1;
362    if (cs.year() < std::numeric_limits<int>::min() + 1900) {
363      tm.tm_year = std::numeric_limits<int>::min();
364    } else if (cs.year() > std::numeric_limits<int>::max()) {
365      tm.tm_year = std::numeric_limits<int>::max() - 1900;
366    } else {
367      tm.tm_year = static_cast<int>(cs.year() - 1900);
368    }
369    switch (GetWeekday(cs)) {
370      case Weekday::sunday:
371        tm.tm_wday = 0;
372        break;
373      case Weekday::monday:
374        tm.tm_wday = 1;
375        break;
376      case Weekday::tuesday:
377        tm.tm_wday = 2;
378        break;
379      case Weekday::wednesday:
380        tm.tm_wday = 3;
381        break;
382      case Weekday::thursday:
383        tm.tm_wday = 4;
384        break;
385      case Weekday::friday:
386        tm.tm_wday = 5;
387        break;
388      case Weekday::saturday:
389        tm.tm_wday = 6;
390        break;
391    }
392    tm.tm_yday = GetYearDay(cs) - 1;
393    tm.tm_isdst = ci.is_dst ? 1 : 0;
394    return tm;
395  }
396  ABSL_NAMESPACE_END
397  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time.cc</h3>
            <pre><code>1  #include "absl/time/time.h"
2  #if defined(_MSC_VER)
3  #include <winsock2.h>  
4  #endif
5  #include <cstring>
6  #include <ctime>
7  #include <limits>
8  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
9  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
10  namespace cctz = absl::time_internal::cctz;
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace {
14  inline cctz::time_point<cctz::seconds> unix_epoch() {
15    return std::chrono::time_point_cast<cctz::seconds>(
16        std::chrono::system_clock::from_time_t(0));
17  }
18  inline int64_t FloorToUnit(absl::Duration d, absl::Duration unit) {
19    absl::Duration rem;
20    int64_t q = absl::IDivDuration(d, unit, &rem);
21    return (q > 0 || rem >= ZeroDuration() ||
22            q == std::numeric_limits<int64_t>::min())
23               ? q
24               : q - 1;
25  }
26  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
27  inline absl::Time::Breakdown InfiniteFutureBreakdown() {
28    absl::Time::Breakdown bd;
29    bd.year = std::numeric_limits<int64_t>::max();
30    bd.month = 12;
31    bd.day = 31;
32    bd.hour = 23;
33    bd.minute = 59;
34    bd.second = 59;
35    bd.subsecond = absl::InfiniteDuration();
36    bd.weekday = 4;
37    bd.yearday = 365;
38    bd.offset = 0;
39    bd.is_dst = false;
40    bd.zone_abbr = "-00";
41    return bd;
42  }
43  inline absl::Time::Breakdown InfinitePastBreakdown() {
44    Time::Breakdown bd;
45    bd.year = std::numeric_limits<int64_t>::min();
46    bd.month = 1;
47    bd.day = 1;
48    bd.hour = 0;
49    bd.minute = 0;
50    bd.second = 0;
51    bd.subsecond = -absl::InfiniteDuration();
52    bd.weekday = 7;
53    bd.yearday = 1;
54    bd.offset = 0;
55    bd.is_dst = false;
56    bd.zone_abbr = "-00";
57    return bd;
58  }
59  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
60  inline absl::TimeZone::CivilInfo InfiniteFutureCivilInfo() {
61    TimeZone::CivilInfo ci;
62    ci.cs = CivilSecond::max();
63    ci.subsecond = InfiniteDuration();
64    ci.offset = 0;
65    ci.is_dst = false;
66    ci.zone_abbr = "-00";
67    return ci;
68  }
69  inline absl::TimeZone::CivilInfo InfinitePastCivilInfo() {
70    TimeZone::CivilInfo ci;
71    ci.cs = CivilSecond::min();
72    ci.subsecond = -InfiniteDuration();
73    ci.offset = 0;
74    ci.is_dst = false;
75    ci.zone_abbr = "-00";
76    return ci;
77  }
78  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
79  inline absl::TimeConversion InfiniteFutureTimeConversion() {
80    absl::TimeConversion tc;
81    tc.pre = tc.trans = tc.post = absl::InfiniteFuture();
82    tc.kind = absl::TimeConversion::UNIQUE;
83    tc.normalized = true;
84    return tc;
85  }
86  inline TimeConversion InfinitePastTimeConversion() {
87    absl::TimeConversion tc;
88    tc.pre = tc.trans = tc.post = absl::InfinitePast();
89    tc.kind = absl::TimeConversion::UNIQUE;
90    tc.normalized = true;
91    return tc;
92  }
93  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
94  Time MakeTimeWithOverflow(const cctz::time_point<cctz::seconds>& sec,
95                            const cctz::civil_second& cs,
96                            const cctz::time_zone& tz,
97                            bool* normalized = nullptr) {
98    const auto max = cctz::time_point<cctz::seconds>::max();
99    const auto min = cctz::time_point<cctz::seconds>::min();
100    if (sec == max) {
101      const auto al = tz.lookup(max);
102      if (cs > al.cs) {
103        if (normalized) *normalized = true;
104        return absl::InfiniteFuture();
105      }
106    }
107    if (sec == min) {
108      const auto al = tz.lookup(min);
109      if (cs < al.cs) {
110        if (normalized) *normalized = true;
111        return absl::InfinitePast();
112      }
113    }
114    const auto hi = (sec - unix_epoch()).count();
115    return time_internal::FromUnixDuration(time_internal::MakeDuration(hi));
116  }
117  inline int MapWeekday(const cctz::weekday& wd) {
118    switch (wd) {
119      case cctz::weekday::monday:
120        return 1;
121      case cctz::weekday::tuesday:
122        return 2;
123      case cctz::weekday::wednesday:
124        return 3;
125      case cctz::weekday::thursday:
126        return 4;
127      case cctz::weekday::friday:
128        return 5;
129      case cctz::weekday::saturday:
130        return 6;
131      case cctz::weekday::sunday:
132        return 7;
133    }
134    return 1;
135  }
136  bool FindTransition(const cctz::time_zone& tz,
137                      bool (cctz::time_zone::*find_transition)(
138                          const cctz::time_point<cctz::seconds>& tp,
139                          cctz::time_zone::civil_transition* trans) const,
140                      Time t, TimeZone::CivilTransition* trans) {
141    const auto tp = unix_epoch() + cctz::seconds(ToUnixSeconds(t));
142    cctz::time_zone::civil_transition tr;
143    if (!(tz.*find_transition)(tp, &tr)) return false;
<span onclick='openModal()' class='match'>144    trans->from = CivilSecond(tr.from);
145    trans->to = CivilSecond(tr.to);
146    return true;
</span>147  }
148  }  
149  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
150  absl::Time::Breakdown Time::In(absl::TimeZone tz) const {
151    if (*this == absl::InfiniteFuture()) return InfiniteFutureBreakdown();
152    if (*this == absl::InfinitePast()) return InfinitePastBreakdown();
153    const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(rep_));
154    const auto al = cctz::time_zone(tz).lookup(tp);
155    const auto cs = al.cs;
156    const auto cd = cctz::civil_day(cs);
157    absl::Time::Breakdown bd;
158    bd.year = cs.year();
159    bd.month = cs.month();
160    bd.day = cs.day();
161    bd.hour = cs.hour();
162    bd.minute = cs.minute();
163    bd.second = cs.second();
164    bd.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(rep_));
165    bd.weekday = MapWeekday(cctz::get_weekday(cd));
166    bd.yearday = cctz::get_yearday(cd);
167    bd.offset = al.offset;
168    bd.is_dst = al.is_dst;
169    bd.zone_abbr = al.abbr;
170    return bd;
171  }
172  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
173  absl::Time FromUDate(double udate) {
174    return time_internal::FromUnixDuration(absl::Milliseconds(udate));
175  }
176  absl::Time FromUniversal(int64_t universal) {
177    return absl::UniversalEpoch() + 100 * absl::Nanoseconds(universal);
178  }
179  int64_t ToUnixNanos(Time t) {
180    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
181        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 33 == 0) {
182      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
183              1000 * 1000 * 1000) +
184             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4);
185    }
186    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Nanoseconds(1));
187  }
188  int64_t ToUnixMicros(Time t) {
189    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
190        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 43 == 0) {
191      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
192              1000 * 1000) +
193             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4000);
194    }
195    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Microseconds(1));
196  }
197  int64_t ToUnixMillis(Time t) {
198    if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
199        time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 53 == 0) {
200      return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) * 1000) +
201             (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) /
202              (4000 * 1000));
203    }
204    return FloorToUnit(time_internal::ToUnixDuration(t), absl::Milliseconds(1));
205  }
206  int64_t ToUnixSeconds(Time t) {
207    return time_internal::GetRepHi(time_internal::ToUnixDuration(t));
208  }
209  time_t ToTimeT(Time t) { return absl::ToTimespec(t).tv_sec; }
210  double ToUDate(Time t) {
211    return absl::FDivDuration(time_internal::ToUnixDuration(t),
212                              absl::Milliseconds(1));
213  }
214  int64_t ToUniversal(absl::Time t) {
215    return absl::FloorToUnit(t - absl::UniversalEpoch(), absl::Nanoseconds(100));
216  }
217  absl::Time TimeFromTimespec(timespec ts) {
218    return time_internal::FromUnixDuration(absl::DurationFromTimespec(ts));
219  }
220  absl::Time TimeFromTimeval(timeval tv) {
221    return time_internal::FromUnixDuration(absl::DurationFromTimeval(tv));
222  }
223  timespec ToTimespec(Time t) {
224    timespec ts;
225    absl::Duration d = time_internal::ToUnixDuration(t);
226    if (!time_internal::IsInfiniteDuration(d)) {
227      ts.tv_sec = static_cast<decltype(ts.tv_sec)>(time_internal::GetRepHi(d));
228      if (ts.tv_sec == time_internal::GetRepHi(d)) {  
229        ts.tv_nsec = time_internal::GetRepLo(d) / 4;  
230        return ts;
231      }
232    }
233    if (d >= absl::ZeroDuration()) {
234      ts.tv_sec = std::numeric_limits<time_t>::max();
235      ts.tv_nsec = 1000 * 1000 * 1000 - 1;
236    } else {
237      ts.tv_sec = std::numeric_limits<time_t>::min();
238      ts.tv_nsec = 0;
239    }
240    return ts;
241  }
242  timeval ToTimeval(Time t) {
243    timeval tv;
244    timespec ts = absl::ToTimespec(t);
245    tv.tv_sec = static_cast<decltype(tv.tv_sec)>(ts.tv_sec);
246    if (tv.tv_sec != ts.tv_sec) {  
247      if (ts.tv_sec < 0) {
248        tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();
249        tv.tv_usec = 0;
250      } else {
251        tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();
252        tv.tv_usec = 1000 * 1000 - 1;
253      }
254      return tv;
255    }
256    tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  
257    return tv;
258  }
259  Time FromChrono(const std::chrono::system_clock::time_point& tp) {
260    return time_internal::FromUnixDuration(time_internal::FromChrono(
261        tp - std::chrono::system_clock::from_time_t(0)));
262  }
263  std::chrono::system_clock::time_point ToChronoTime(absl::Time t) {
264    using D = std::chrono::system_clock::duration;
265    auto d = time_internal::ToUnixDuration(t);
266    if (d < ZeroDuration()) d = Floor(d, FromChrono(D{1}));
267    return std::chrono::system_clock::from_time_t(0) +
268           time_internal::ToChronoDuration<D>(d);
269  }
270  absl::TimeZone::CivilInfo TimeZone::At(Time t) const {
271    if (t == absl::InfiniteFuture()) return InfiniteFutureCivilInfo();
272    if (t == absl::InfinitePast()) return InfinitePastCivilInfo();
273    const auto ud = time_internal::ToUnixDuration(t);
274    const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(ud));
275    const auto al = cz_.lookup(tp);
276    TimeZone::CivilInfo ci;
277    ci.cs = CivilSecond(al.cs);
278    ci.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(ud));
279    ci.offset = al.offset;
280    ci.is_dst = al.is_dst;
281    ci.zone_abbr = al.abbr;
282    return ci;
283  }
284  absl::TimeZone::TimeInfo TimeZone::At(CivilSecond ct) const {
285    const cctz::civil_second cs(ct);
286    const auto cl = cz_.lookup(cs);
287    TimeZone::TimeInfo ti;
288    switch (cl.kind) {
289      case cctz::time_zone::civil_lookup::UNIQUE:
290        ti.kind = TimeZone::TimeInfo::UNIQUE;
291        break;
292      case cctz::time_zone::civil_lookup::SKIPPED:
293        ti.kind = TimeZone::TimeInfo::SKIPPED;
294        break;
295      case cctz::time_zone::civil_lookup::REPEATED:
296        ti.kind = TimeZone::TimeInfo::REPEATED;
297        break;
298    }
299    ti.pre = MakeTimeWithOverflow(cl.pre, cs, cz_);
300    ti.trans = MakeTimeWithOverflow(cl.trans, cs, cz_);
301    ti.post = MakeTimeWithOverflow(cl.post, cs, cz_);
302    return ti;
303  }
304  bool TimeZone::NextTransition(Time t, CivilTransition* trans) const {
305    return FindTransition(cz_, &cctz::time_zone::next_transition, t, trans);
306  }
307  bool TimeZone::PrevTransition(Time t, CivilTransition* trans) const {
308    return FindTransition(cz_, &cctz::time_zone::prev_transition, t, trans);
309  }
310  ABSL_INTERNAL_DISABLE_DEPRECATED_DECLARATION_WARNING
311  absl::TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,
312                                       int min, int sec, TimeZone tz) {
313    if (year > 300000000000) return InfiniteFutureTimeConversion();
314    if (year < -300000000000) return InfinitePastTimeConversion();
315    const CivilSecond cs(year, mon, day, hour, min, sec);
316    const auto ti = tz.At(cs);
317    TimeConversion tc;
318    tc.pre = ti.pre;
319    tc.trans = ti.trans;
320    tc.post = ti.post;
321    switch (ti.kind) {
322      case TimeZone::TimeInfo::UNIQUE:
323        tc.kind = TimeConversion::UNIQUE;
324        break;
325      case TimeZone::TimeInfo::SKIPPED:
326        tc.kind = TimeConversion::SKIPPED;
327        break;
328      case TimeZone::TimeInfo::REPEATED:
329        tc.kind = TimeConversion::REPEATED;
330        break;
331    }
332    tc.normalized = false;
333    if (year != cs.year() || mon != cs.month() || day != cs.day() ||
334        hour != cs.hour() || min != cs.minute() || sec != cs.second()) {
335      tc.normalized = true;
336    }
337    return tc;
338  }
339  ABSL_INTERNAL_RESTORE_DEPRECATED_DECLARATION_WARNING
340  absl::Time FromTM(const struct tm& tm, absl::TimeZone tz) {
341    civil_year_t tm_year = tm.tm_year;
342    if (tm_year > 300000000000ll) return InfiniteFuture();
343    if (tm_year < -300000000000ll) return InfinitePast();
344    int tm_mon = tm.tm_mon;
345    if (tm_mon == std::numeric_limits<int>::max()) {
346      tm_mon -= 12;
347      tm_year += 1;
348    }
349    const auto ti = tz.At(CivilSecond(tm_year + 1900, tm_mon + 1, tm.tm_mday,
350                                      tm.tm_hour, tm.tm_min, tm.tm_sec));
351    return tm.tm_isdst == 0 ? ti.post : ti.pre;
352  }
353  struct tm ToTM(absl::Time t, absl::TimeZone tz) {
354    struct tm tm = {};
355    const auto ci = tz.At(t);
356    const auto& cs = ci.cs;
357    tm.tm_sec = cs.second();
358    tm.tm_min = cs.minute();
359    tm.tm_hour = cs.hour();
360    tm.tm_mday = cs.day();
361    tm.tm_mon = cs.month() - 1;
362    if (cs.year() < std::numeric_limits<int>::min() + 1900) {
363      tm.tm_year = std::numeric_limits<int>::min();
364    } else if (cs.year() > std::numeric_limits<int>::max()) {
365      tm.tm_year = std::numeric_limits<int>::max() - 1900;
366    } else {
367      tm.tm_year = static_cast<int>(cs.year() - 1900);
368    }
369    switch (GetWeekday(cs)) {
370      case Weekday::sunday:
371        tm.tm_wday = 0;
372        break;
373      case Weekday::monday:
374        tm.tm_wday = 1;
375        break;
376      case Weekday::tuesday:
377        tm.tm_wday = 2;
378        break;
379      case Weekday::wednesday:
380        tm.tm_wday = 3;
381        break;
382      case Weekday::thursday:
383        tm.tm_wday = 4;
384        break;
385      case Weekday::friday:
386        tm.tm_wday = 5;
387        break;
388      case Weekday::saturday:
389        tm.tm_wday = 6;
390        break;
391    }
392    tm.tm_yday = GetYearDay(cs) - 1;
393    tm.tm_isdst = ci.is_dst ? 1 : 0;
394    return tm;
395  }
396  ABSL_NAMESPACE_END
397  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time.cc</div>
                </div>
                <div class="column column_space"><pre><code>144    trans->from = CivilSecond(tr.from);
145    trans->to = CivilSecond(tr.to);
146    return true;
</pre></code></div>
                <div class="column column_space"><pre><code>144    trans->from = CivilSecond(tr.from);
145    trans->to = CivilSecond(tr.to);
146    return true;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    