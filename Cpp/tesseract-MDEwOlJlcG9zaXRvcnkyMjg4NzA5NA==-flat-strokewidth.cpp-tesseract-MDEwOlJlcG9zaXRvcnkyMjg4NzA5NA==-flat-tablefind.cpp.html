
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "strokewidth.h"
5  #include <algorithm>
6  #include <cmath>
7  #include "blobbox.h"
8  #include "colpartition.h"
9  #include "colpartitiongrid.h"
10  #include "helpers.h" 
11  #include "imagefind.h"
12  #include "linlsq.h"
13  #include "statistc.h"
14  #include "tabfind.h"
15  #include "textlineprojection.h"
16  #include "tordmain.h" 
17  namespace tesseract {
18  #ifndef GRAPHICS_DISABLED
19  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths (ScrollView)");
20  #else
21  static INT_VAR(textord_tabfind_show_strokewidths, 0, "Show stroke widths");
22  #endif
23  static BOOL_VAR(textord_tabfind_only_strokewidths, false, "Only run stroke widths");
24  const double kStrokeWidthFractionTolerance = 0.125;
25  const double kStrokeWidthTolerance = 1.5;
26  const double kStrokeWidthFractionCJK = 0.25;
27  const double kStrokeWidthCJK = 2.0;
28  const int kCJKRadius = 2;
29  const double kCJKBrokenDistanceFraction = 0.25;
30  const int kCJKMaxComponents = 8;
31  const double kCJKAspectRatio = 1.25;
32  const double kCJKAspectRatioIncrease = 1.0625;
33  const int kMaxCJKSizeRatio = 5;
34  const double kBrokenCJKIterationFraction = 0.125;
35  const double kDiacriticXPadRatio = 7.0;
36  const double kDiacriticYPadRatio = 1.75;
37  const double kMinDiacriticSizeRatio = 1.0625;
38  const double kMaxDiacriticDistanceRatio = 1.25;
39  const double kMaxDiacriticGapToBaseCharHeight = 1.0;
40  const int kLineTrapLongest = 4;
41  const int kLineTrapShortest = 2;
42  const int kMostlyOneDirRatio = 3;
43  const double kLineResidueAspectRatio = 8.0;
44  const int kLineResiduePadRatio = 3;
45  const double kLineResidueSizeRatio = 1.75;
46  const float kSizeRatioToReject = 2.0;
47  const double kNeighbourSearchFactor = 2.5;
48  const double kNoiseOverlapGrowthFactor = 4.0;
49  const double kNoiseOverlapAreaFactor = 1.0 / 512;
50  StrokeWidth::StrokeWidth(int gridsize, const ICOORD &bleft, const ICOORD &tright)
51      : BlobGrid(gridsize, bleft, tright)
52      , nontext_map_(nullptr)
53      , projection_(nullptr)
54      , denorm_(nullptr)
55      , grid_box_(bleft, tright)
56      , rerotation_(1.0f, 0.0f) {
57  }
58  StrokeWidth::~StrokeWidth() {
59  #ifndef GRAPHICS_DISABLED
60    if (widths_win_ != nullptr) {
61      widths_win_->AwaitEvent(SVET_DESTROY);
62      if (textord_tabfind_only_strokewidths) {
63        exit(0);
64      }
65      delete widths_win_;
66    }
67    delete leaders_win_;
68    delete initial_widths_win_;
69    delete chains_win_;
70    delete textlines_win_;
71    delete smoothed_win_;
72    delete diacritics_win_;
73  #endif
74  }
75  void StrokeWidth::SetNeighboursOnMediumBlobs(TO_BLOCK *block) {
76    InsertBlobList(&block->blobs);
77    BLOBNBOX_IT blob_it(&block->blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      SetNeighbours(false, false, blob_it.data());
80    }
81    Clear();
82  }
83  void StrokeWidth::FindTextlineDirectionAndFixBrokenCJK(PageSegMode pageseg_mode, bool cjk_merge,
84                                                         TO_BLOCK *input_block) {
85    InsertBlobs(input_block);
86    while (cjk_merge && FixBrokenCJK(input_block)) {
87    }
88    FindTextlineFlowDirection(pageseg_mode, false);
89    Clear();
90  }
91  static void CollectHorizVertBlobs(BLOBNBOX_LIST *input_blobs, int *num_vertical_blobs,
92                                    int *num_horizontal_blobs, BLOBNBOX_CLIST *vertical_blobs,
93                                    BLOBNBOX_CLIST *horizontal_blobs,
94                                    BLOBNBOX_CLIST *nondescript_blobs) {
95    BLOBNBOX_C_IT v_it(vertical_blobs);
96    BLOBNBOX_C_IT h_it(horizontal_blobs);
97    BLOBNBOX_C_IT n_it(nondescript_blobs);
98    BLOBNBOX_IT blob_it(input_blobs);
99    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
100      BLOBNBOX *blob = blob_it.data();
101      const TBOX &box = blob->bounding_box();
102      float y_x = static_cast<float>(box.height()) / box.width();
103      float x_y = 1.0f / y_x;
104      float ratio = x_y > y_x ? x_y : y_x;
105      bool ok_blob = ratio <= kSizeRatioToReject;
106      if (blob->UniquelyVertical()) {
107        ++*num_vertical_blobs;
108        if (ok_blob) {
109          v_it.add_after_then_move(blob);
110        }
111      } else if (blob->UniquelyHorizontal()) {
112        ++*num_horizontal_blobs;
113        if (ok_blob) {
114          h_it.add_after_then_move(blob);
115        }
116      } else if (ok_blob) {
117        n_it.add_after_then_move(blob);
118      }
119    }
120  }
121  bool StrokeWidth::TestVerticalTextDirection(double find_vertical_text_ratio, TO_BLOCK *block,
122                                              BLOBNBOX_CLIST *osd_blobs) {
123    int vertical_boxes = 0;
124    int horizontal_boxes = 0;
125    BLOBNBOX_CLIST vertical_blobs;
126    BLOBNBOX_CLIST horizontal_blobs;
127    BLOBNBOX_CLIST nondescript_blobs;
128    CollectHorizVertBlobs(&block->blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
129                          &horizontal_blobs, &nondescript_blobs);
130    CollectHorizVertBlobs(&block->large_blobs, &vertical_boxes, &horizontal_boxes, &vertical_blobs,
131                          &horizontal_blobs, &nondescript_blobs);
132    if (textord_debug_tabfind) {
133      tprintf("TextDir hbox=%d vs vbox=%d, %dH, %dV, %dN osd blobs\n", horizontal_boxes,
134              vertical_boxes, horizontal_blobs.length(), vertical_blobs.length(),
135              nondescript_blobs.length());
136    }
137    if (osd_blobs != nullptr && vertical_boxes == 0 && horizontal_boxes == 0) {
138      BLOBNBOX_C_IT osd_it(osd_blobs);
139      osd_it.add_list_after(&nondescript_blobs);
140      return false;
141    }
142    int min_vert_boxes =
143        static_cast<int>((vertical_boxes + horizontal_boxes) * find_vertical_text_ratio);
144    if (vertical_boxes >= min_vert_boxes) {
145      if (osd_blobs != nullptr) {
146        BLOBNBOX_C_IT osd_it(osd_blobs);
147        osd_it.add_list_after(&vertical_blobs);
148      }
149      return true;
150    } else {
151      if (osd_blobs != nullptr) {
152        BLOBNBOX_C_IT osd_it(osd_blobs);
153        osd_it.add_list_after(&horizontal_blobs);
154      }
155      return false;
156    }
157  }
158  void StrokeWidth::CorrectForRotation(const FCOORD &rotation, ColPartitionGrid *part_grid) {
159    Init(part_grid->gridsize(), part_grid->bleft(), part_grid->tright());
160    grid_box_ = TBOX(bleft(), tright());
161    rerotation_.set_x(rotation.x());
162    rerotation_.set_y(-rotation.y());
163  }
164  void StrokeWidth::FindLeaderPartitions(TO_BLOCK *block, ColPartitionGrid *part_grid) {
<span onclick='openModal()' class='match'>165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &leader_parts);
168    InsertBlobList(&block->blobs);
</span>169    for (ColPartition_IT it(&leader_parts); !it.empty(); it.forward()) {
170      ColPartition *part = it.extract();
171      part->ClaimBoxes();
172      MarkLeaderNeighbours(part, LR_LEFT);
173      MarkLeaderNeighbours(part, LR_RIGHT);
174      part_grid->InsertBBox(true, true, part);
175    }
176  }
177  void StrokeWidth::RemoveLineResidue(ColPartition_LIST *big_part_list) {
178    BlobGridSearch gsearch(this);
179    BLOBNBOX *bbox;
180    gsearch.StartFullSearch();
181    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
182      TBOX box = bbox->bounding_box();
183      if (box.height() < box.width() * kLineResidueAspectRatio) {
184        continue;
185      }
186      int padding = box.height() * kLineResiduePadRatio;
187      TBOX search_box = box;
188      search_box.pad(padding, padding);
189      bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
190      BlobGridSearch rsearch(this);
191      int max_height = 0;
192      BLOBNBOX *n;
193      rsearch.StartRectSearch(search_box);
194      while ((n = rsearch.NextRectSearch()) != nullptr) {
195        if (n == bbox) {
196          continue;
197        }
198        TBOX nbox = n->bounding_box();
199        if (nbox.height() > max_height) {
200          max_height = nbox.height();
201        }
202      }
203      if (debug) {
204        tprintf("Max neighbour size=%d for candidate line box at:", max_height);
205        box.print();
206      }
207      if (max_height * kLineResidueSizeRatio < box.height()) {
208  #ifndef GRAPHICS_DISABLED
209        if (leaders_win_ != nullptr) {
210          leaders_win_->Pen(ScrollView::PINK);
211          leaders_win_->Rectangle(box.left(), box.bottom(), box.right(), box.top());
212        }
213  #endif 
214        ColPartition::MakeBigPartition(bbox, big_part_list);
215      }
216    }
217  }
218  void StrokeWidth::GradeBlobsIntoPartitions(PageSegMode pageseg_mode, const FCOORD &rerotation,
219                                             TO_BLOCK *block, Image nontext_pix, const DENORM *denorm,
220                                             bool cjk_script, TextlineProjection *projection,
221                                             BLOBNBOX_LIST *diacritic_blobs,
222                                             ColPartitionGrid *part_grid,
223                                             ColPartition_LIST *big_parts) {
224    nontext_map_ = nontext_pix;
225    projection_ = projection;
226    denorm_ = denorm;
227    Clear();
228    InsertBlobs(block);
229    if (cjk_script) {
230      FixBrokenCJK(block);
231    }
232    FindTextlineFlowDirection(pageseg_mode, false);
233    projection_->ConstructProjection(block, rerotation, nontext_map_);
234  #ifndef GRAPHICS_DISABLED
235    if (textord_tabfind_show_strokewidths) {
236      ScrollView *line_blobs_win = MakeWindow(0, 0, "Initial textline Blobs");
237      projection_->PlotGradedBlobs(&block->blobs, line_blobs_win);
238      projection_->PlotGradedBlobs(&block->small_blobs, line_blobs_win);
239    }
240  #endif
241    projection_->MoveNonTextlineBlobs(&block->blobs, &block->noise_blobs);
242    projection_->MoveNonTextlineBlobs(&block->small_blobs, &block->noise_blobs);
243    Clear();
244    InsertBlobs(block);
245    FCOORD skew;
246    FindTextlineFlowDirection(pageseg_mode, true);
247    PartitionFindResult r = FindInitialPartitions(pageseg_mode, rerotation, true, block,
248                                                  diacritic_blobs, part_grid, big_parts, &skew);
249    if (r == PFR_NOISE) {
250      tprintf("Detected %d diacritics\n", diacritic_blobs->length());
251      Clear();
252      InsertBlobs(block);
253      FindTextlineFlowDirection(pageseg_mode, true);
254      r = FindInitialPartitions(pageseg_mode, rerotation, false, block, diacritic_blobs, part_grid,
255                                big_parts, &skew);
256    }
257    nontext_map_ = nullptr;
258    projection_ = nullptr;
259    denorm_ = nullptr;
260  }
261  static void PrintBoxWidths(BLOBNBOX *neighbour) {
262    const TBOX &nbox = neighbour->bounding_box();
263    tprintf("Box (%d,%d)->(%d,%d): h-width=%.1f, v-width=%.1f p-width=%1.f\n", nbox.left(),
264            nbox.bottom(), nbox.right(), nbox.top(), neighbour->horz_stroke_width(),
265            neighbour->vert_stroke_width(),
266            2.0 * neighbour->cblob()->area() / neighbour->cblob()->perimeter());
267  }
268  void StrokeWidth::HandleClick(int x, int y) {
269    BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT>::HandleClick(x, y);
270    BlobGridSearch radsearch(this);
271    radsearch.StartRadSearch(x, y, 1);
272    BLOBNBOX *neighbour;
273    FCOORD click(static_cast<float>(x), static_cast<float>(y));
274    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
275      TBOX nbox = neighbour->bounding_box();
276      if (nbox.contains(click) && neighbour->cblob() != nullptr) {
277        PrintBoxWidths(neighbour);
278        if (neighbour->neighbour(BND_LEFT) != nullptr) {
279          PrintBoxWidths(neighbour->neighbour(BND_LEFT));
280        }
281        if (neighbour->neighbour(BND_RIGHT) != nullptr) {
282          PrintBoxWidths(neighbour->neighbour(BND_RIGHT));
283        }
284        if (neighbour->neighbour(BND_ABOVE) != nullptr) {
285          PrintBoxWidths(neighbour->neighbour(BND_ABOVE));
286        }
287        if (neighbour->neighbour(BND_BELOW) != nullptr) {
288          PrintBoxWidths(neighbour->neighbour(BND_BELOW));
289        }
290        int gaps[BND_COUNT];
291        neighbour->NeighbourGaps(gaps);
292        tprintf(
293            "Left gap=%d, right=%d, above=%d, below=%d, horz=%d, vert=%d\n"
294            "Good=    %d        %d        %d        %d\n",
295            gaps[BND_LEFT], gaps[BND_RIGHT], gaps[BND_ABOVE], gaps[BND_BELOW],
296            neighbour->horz_possible(), neighbour->vert_possible(),
297            neighbour->good_stroke_neighbour(BND_LEFT), neighbour->good_stroke_neighbour(BND_RIGHT),
298            neighbour->good_stroke_neighbour(BND_ABOVE), neighbour->good_stroke_neighbour(BND_BELOW));
299        break;
300      }
301    }
302  }
303  void StrokeWidth::FindLeadersAndMarkNoise(TO_BLOCK *block, ColPartition_LIST *leader_parts) {
304    InsertBlobList(&block->small_blobs);
305    InsertBlobList(&block->noise_blobs);
306    BlobGridSearch gsearch(this);
307    BLOBNBOX *bbox;
308    gsearch.StartFullSearch();
309    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
310      SetNeighbours(true, false, bbox);
311    }
312    ColPartition_IT part_it(leader_parts);
313    gsearch.StartFullSearch();
314    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
315      if (bbox->flow() == BTFT_NONE) {
316        if (bbox->neighbour(BND_RIGHT) == nullptr && bbox->neighbour(BND_LEFT) == nullptr) {
317          continue;
318        }
319        auto *part = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
320        BLOBNBOX *blob;
321        for (blob = bbox; blob != nullptr && blob->flow() == BTFT_NONE;
322             blob = blob->neighbour(BND_RIGHT)) {
323          part->AddBox(blob);
324        }
325        for (blob = bbox->neighbour(BND_LEFT); blob != nullptr && blob->flow() == BTFT_NONE;
326             blob = blob->neighbour(BND_LEFT)) {
327          part->AddBox(blob);
328        }
329        if (part->MarkAsLeaderIfMonospaced()) {
330          part_it.add_after_then_move(part);
331        } else {
332          delete part;
333        }
334      }
335    }
336  #ifndef GRAPHICS_DISABLED
337    if (textord_tabfind_show_strokewidths) {
338      leaders_win_ = DisplayGoodBlobs("LeaderNeighbours", 0, 0);
339    }
340  #endif
341    BLOBNBOX_IT blob_it(&block->blobs);
342    BLOBNBOX_IT small_it(&block->small_blobs);
343    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
344      BLOBNBOX *blob = small_it.data();
345      if (blob->flow() != BTFT_LEADER) {
346        if (blob->flow() == BTFT_NEIGHBOURS) {
347          blob->set_flow(BTFT_NONE);
348        }
349        blob->ClearNeighbours();
350        blob_it.add_to_end(small_it.extract());
351      }
352    }
353    BLOBNBOX_IT noise_it(&block->noise_blobs);
354    for (noise_it.mark_cycle_pt(); !noise_it.cycled_list(); noise_it.forward()) {
355      BLOBNBOX *blob = noise_it.data();
356      if (blob->flow() == BTFT_LEADER || blob->joined_to_prev()) {
357        small_it.add_to_end(noise_it.extract());
358      } else if (blob->flow() == BTFT_NEIGHBOURS) {
359        blob->set_flow(BTFT_NONE);
360        blob->ClearNeighbours();
361      }
362    }
363    Clear();
364  }
365  void StrokeWidth::InsertBlobs(TO_BLOCK *block) {
366    InsertBlobList(&block->blobs);
367    InsertBlobList(&block->large_blobs);
368  }
369  void StrokeWidth::MarkLeaderNeighbours(const ColPartition *part, LeftOrRight side) {
370    const TBOX &part_box = part->bounding_box();
371    BlobGridSearch blobsearch(this);
372    BLOBNBOX *best_blob = nullptr;
373    int best_gap = 0;
374    blobsearch.StartSideSearch(side == LR_LEFT ? part_box.left() : part_box.right(),
375                               part_box.bottom(), part_box.top());
376    BLOBNBOX *blob;
377    while ((blob = blobsearch.NextSideSearch(side == LR_LEFT)) != nullptr) {
378      const TBOX &blob_box = blob->bounding_box();
379      if (!blob_box.y_overlap(part_box)) {
380        continue;
381      }
382      int x_gap = blob_box.x_gap(part_box);
383      if (x_gap > 2 * gridsize()) {
384        break;
385      } else if (best_blob == nullptr || x_gap < best_gap) {
386        best_blob = blob;
387        best_gap = x_gap;
388      }
389    }
390    if (best_blob != nullptr) {
391      if (side == LR_LEFT) {
392        best_blob->set_leader_on_right(true);
393      } else {
394        best_blob->set_leader_on_left(true);
395      }
396  #ifndef GRAPHICS_DISABLED
397      if (leaders_win_ != nullptr) {
398        leaders_win_->Pen(side == LR_LEFT ? ScrollView::RED : ScrollView::GREEN);
399        const TBOX &blob_box = best_blob->bounding_box();
400        leaders_win_->Rectangle(blob_box.left(), blob_box.bottom(), blob_box.right(), blob_box.top());
401      }
402  #endif 
403    }
404  }
405  static int UpperQuartileCJKSize(int gridsize, BLOBNBOX_LIST *blobs) {
406    STATS sizes(0, gridsize * kMaxCJKSizeRatio - 1);
407    BLOBNBOX_IT it(blobs);
408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
409      BLOBNBOX *blob = it.data();
410      int width = blob->bounding_box().width();
411      int height = blob->bounding_box().height();
412      if (width <= height * kCJKAspectRatio && height < width * kCJKAspectRatio) {
413        sizes.add(height, 1);
414      }
415    }
416    return static_cast<int>(sizes.ile(0.75f) + 0.5);
417  }
418  bool StrokeWidth::FixBrokenCJK(TO_BLOCK *block) {
419    BLOBNBOX_LIST *blobs = &block->blobs;
420    int median_height = UpperQuartileCJKSize(gridsize(), blobs);
421    int max_dist = static_cast<int>(median_height * kCJKBrokenDistanceFraction);
422    int max_height = static_cast<int>(median_height * kCJKAspectRatio);
423    int num_fixed = 0;
424    BLOBNBOX_IT blob_it(blobs);
425    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
426      BLOBNBOX *blob = blob_it.data();
427      if (blob->cblob() == nullptr || blob->cblob()->out_list()->empty()) {
428        continue;
429      }
430      TBOX bbox = blob->bounding_box();
431      bool debug = AlignedBlob::WithinTestRegion(3, bbox.left(), bbox.bottom());
432      if (debug) {
433        tprintf("Checking for Broken CJK (max size=%d):", max_height);
434        bbox.print();
435      }
436      BLOBNBOX_CLIST overlapped_blobs;
437      AccumulateOverlaps(blob, debug, max_height, max_dist, &bbox, &overlapped_blobs);
438      if (!overlapped_blobs.empty()) {
439        if (bbox.width() > bbox.height() * kCJKAspectRatio ||
440            bbox.height() > bbox.width() * kCJKAspectRatio) {
441          if (debug) {
442            tprintf("Bad final aspectratio:");
443            bbox.print();
444          }
445          continue;
446        }
447        if (overlapped_blobs.length() >= kCJKMaxComponents) {
448          if (debug) {
449            tprintf("Too many neighbours: %d\n", overlapped_blobs.length());
450          }
451          continue;
452        }
453        BLOBNBOX_C_IT n_it(&overlapped_blobs);
454        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
455          BLOBNBOX *neighbour = nullptr;
456          neighbour = n_it.data();
457          if (!blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionCJK, kStrokeWidthCJK)) {
458            break;
459          }
460        }
461        if (!n_it.cycled_list()) {
462          if (debug) {
463            tprintf("Bad stroke widths:");
464            PrintBoxWidths(blob);
465          }
466          continue; 
467        }
468        RemoveBBox(blob);
469        for (n_it.mark_cycle_pt(); !n_it.cycled_list(); n_it.forward()) {
470          BLOBNBOX *neighbour = n_it.data();
471          RemoveBBox(neighbour);
472          neighbour->set_region_type(BRT_NOISE);
473          blob->really_merge(neighbour);
474          if (rerotation_.x() != 1.0f || rerotation_.y() != 0.0f) {
475            blob->rotate_box(rerotation_);
476          }
477        }
478        InsertBBox(true, true, blob);
479        ++num_fixed;
480        if (debug) {
481          tprintf("Done! Final box:");
482          bbox.print();
483        }
484      }
485    }
486    int num_remaining = 0;
487    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
488      BLOBNBOX *blob = blob_it.data();
489      if (blob->cblob() != nullptr && !blob->cblob()->out_list()->empty()) {
490        ++num_remaining;
491      }
492    }
493    block->DeleteUnownedNoise();
494    return num_fixed > num_remaining * kBrokenCJKIterationFraction;
495  }
496  static bool AcceptableCJKMerge(const TBOX &bbox, const TBOX &nbox, bool debug, int max_size,
497                                 int max_dist, int *x_gap, int *y_gap) {
498    *x_gap = bbox.x_gap(nbox);
499    *y_gap = bbox.y_gap(nbox);
500    TBOX merged(nbox);
501    merged += bbox;
502    if (debug) {
503      tprintf("gaps = %d, %d, merged_box:", *x_gap, *y_gap);
504      merged.print();
505    }
506    if (*x_gap <= max_dist && *y_gap <= max_dist && merged.width() <= max_size &&
507        merged.height() <= max_size) {
508      double old_ratio = static_cast<double>(bbox.width()) / bbox.height();
509      if (old_ratio < 1.0) {
510        old_ratio = 1.0 / old_ratio;
511      }
512      double new_ratio = static_cast<double>(merged.width()) / merged.height();
513      if (new_ratio < 1.0) {
514        new_ratio = 1.0 / new_ratio;
515      }
516      if (new_ratio <= old_ratio * kCJKAspectRatioIncrease) {
517        return true;
518      }
519    }
520    return false;
521  }
522  void StrokeWidth::AccumulateOverlaps(const BLOBNBOX *not_this, bool debug, int max_size,
523                                       int max_dist, TBOX *bbox, BLOBNBOX_CLIST *blobs) {
524    BLOBNBOX *nearests[BND_COUNT];
525    for (auto &nearest : nearests) {
526      nearest = nullptr;
527    }
528    int x = (bbox->left() + bbox->right()) / 2;
529    int y = (bbox->bottom() + bbox->top()) / 2;
530    BlobGridSearch radsearch(this);
531    radsearch.StartRadSearch(x, y, kCJKRadius);
532    BLOBNBOX *neighbour;
533    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
534      if (neighbour == not_this) {
535        continue;
536      }
537      TBOX nbox = neighbour->bounding_box();
538      int x_gap, y_gap;
539      if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
540        *bbox += nbox;
541        blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
542        if (debug) {
543          tprintf("Added:");
544          nbox.print();
545        }
546        for (int dir = 0; dir < BND_COUNT; ++dir) {
547          if (nearests[dir] == nullptr) {
548            continue;
549          }
550          nbox = nearests[dir]->bounding_box();
551          if (AcceptableCJKMerge(*bbox, nbox, debug, max_size, max_dist, &x_gap, &y_gap)) {
552            *bbox += nbox;
553            blobs->add_sorted(SortByBoxLeft<BLOBNBOX>, true, nearests[dir]);
554            if (debug) {
555              tprintf("Added:");
556              nbox.print();
557            }
558            nearests[dir] = nullptr;
559            dir = -1; 
560          }
561        }
562      } else if (x_gap < 0 && x_gap <= y_gap) {
563        BlobNeighbourDir dir = nbox.top() > bbox->top() ? BND_ABOVE : BND_BELOW;
564        if (nearests[dir] == nullptr || y_gap < bbox->y_gap(nearests[dir]->bounding_box())) {
565          nearests[dir] = neighbour;
566        }
567      } else if (y_gap < 0 && y_gap <= x_gap) {
568        BlobNeighbourDir dir = nbox.left() > bbox->left() ? BND_RIGHT : BND_LEFT;
569        if (nearests[dir] == nullptr || x_gap < bbox->x_gap(nearests[dir]->bounding_box())) {
570          nearests[dir] = neighbour;
571        }
572      }
573      if (nearests[BND_LEFT] && nearests[BND_RIGHT] && nearests[BND_ABOVE] && nearests[BND_BELOW]) {
574        break;
575      }
576    }
577    for (auto &nearest : nearests) {
578      if (nearest == nullptr) {
579        continue;
580      }
581      const TBOX &nbox = nearest->bounding_box();
582      if (debug) {
583        tprintf("Testing for overlap with:");
584        nbox.print();
585      }
586      if (bbox->overlap(nbox)) {
587        blobs->shallow_clear();
588        if (debug) {
589          tprintf("Final box overlaps nearest\n");
590        }
591        return;
592      }
593    }
594  }
595  void StrokeWidth::FindTextlineFlowDirection(PageSegMode pageseg_mode, bool display_if_debugging) {
596    BlobGridSearch gsearch(this);
597    BLOBNBOX *bbox;
598    gsearch.StartFullSearch();
599    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
600      SetNeighbours(false, display_if_debugging, bbox);
601    }
602    gsearch.StartFullSearch();
603    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
604      SimplifyObviousNeighbours(bbox);
605    }
606    gsearch.StartFullSearch();
607    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
608      if (FindingVerticalOnly(pageseg_mode)) {
609        bbox->set_vert_possible(true);
610        bbox->set_horz_possible(false);
611      } else if (FindingHorizontalOnly(pageseg_mode)) {
612        bbox->set_vert_possible(false);
613        bbox->set_horz_possible(true);
614      } else {
615        SetNeighbourFlows(bbox);
616      }
617    }
618  #ifndef GRAPHICS_DISABLED
619    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
620        textord_tabfind_show_strokewidths > 1) {
621      initial_widths_win_ = DisplayGoodBlobs("InitialStrokewidths", 400, 0);
622    }
623  #endif
624    gsearch.StartFullSearch();
625    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
626      SmoothNeighbourTypes(pageseg_mode, false, bbox);
627    }
628    gsearch.StartFullSearch();
629    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
630      SmoothNeighbourTypes(pageseg_mode, true, bbox);
631    }
632    gsearch.StartFullSearch();
633    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
634      SmoothNeighbourTypes(pageseg_mode, true, bbox);
635    }
636  #ifndef GRAPHICS_DISABLED
637    if ((textord_tabfind_show_strokewidths && display_if_debugging) ||
638        textord_tabfind_show_strokewidths > 1) {
639      widths_win_ = DisplayGoodBlobs("ImprovedStrokewidths", 800, 0);
640    }
641  #endif
642  }
643  void StrokeWidth::SetNeighbours(bool leaders, bool activate_line_trap, BLOBNBOX *blob) {
644    int line_trap_count = 0;
645    for (int dir = 0; dir < BND_COUNT; ++dir) {
646      auto bnd = static_cast<BlobNeighbourDir>(dir);
647      line_trap_count += FindGoodNeighbour(bnd, leaders, blob);
648    }
649    if (line_trap_count > 0 && activate_line_trap) {
650      blob->ClearNeighbours();
651      const TBOX &box = blob->bounding_box();
652      blob->set_region_type(box.width() > box.height() ? BRT_HLINE : BRT_VLINE);
653    }
654  }
655  int StrokeWidth::FindGoodNeighbour(BlobNeighbourDir dir, bool leaders, BLOBNBOX *blob) {
656    TBOX blob_box = blob->bounding_box();
657    bool debug = AlignedBlob::WithinTestRegion(2, blob_box.left(), blob_box.bottom());
658    if (debug) {
659      tprintf("FGN in dir %d for blob:", dir);
660      blob_box.print();
661    }
662    int top = blob_box.top();
663    int bottom = blob_box.bottom();
664    int left = blob_box.left();
665    int right = blob_box.right();
666    int width = right - left;
667    int height = top - bottom;
668    int line_trap_max = std::max(width, height) / kLineTrapLongest;
669    int line_trap_min = std::min(width, height) * kLineTrapShortest;
670    int line_trap_count = 0;
671    int min_good_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 2 : width / 2;
672    int min_decent_overlap = (dir == BND_LEFT || dir == BND_RIGHT) ? height / 3 : width / 3;
673    if (leaders) {
674      min_good_overlap = min_decent_overlap = 1;
675    }
676    int search_pad =
677        static_cast<int>(sqrt(static_cast<double>(width * height)) * kNeighbourSearchFactor);
678    if (gridsize() > search_pad) {
679      search_pad = gridsize();
680    }
681    TBOX search_box = blob_box;
682    switch (dir) {
683      case BND_LEFT:
684        search_box.set_left(search_box.left() - search_pad);
685        break;
686      case BND_RIGHT:
687        search_box.set_right(search_box.right() + search_pad);
688        break;
689      case BND_BELOW:
690        search_box.set_bottom(search_box.bottom() - search_pad);
691        break;
692      case BND_ABOVE:
693        search_box.set_top(search_box.top() + search_pad);
694        break;
695      case BND_COUNT:
696        return 0;
697    }
698    BlobGridSearch rectsearch(this);
699    rectsearch.StartRectSearch(search_box);
700    BLOBNBOX *best_neighbour = nullptr;
701    double best_goodness = 0.0;
702    bool best_is_good = false;
703    BLOBNBOX *neighbour;
704    while ((neighbour = rectsearch.NextRectSearch()) != nullptr) {
705      TBOX nbox = neighbour->bounding_box();
706      if (neighbour == blob) {
707        continue;
708      }
709      int mid_x = (nbox.left() + nbox.right()) / 2;
710      if (mid_x < blob->left_rule() || mid_x > blob->right_rule()) {
711        continue; 
712      }
713      if (debug) {
714        tprintf("Neighbour at:");
715        nbox.print();
716      }
717      int n_width = nbox.width();
718      int n_height = nbox.height();
719      if (std::min(n_width, n_height) > line_trap_min &&
720          std::max(n_width, n_height) < line_trap_max) {
721        ++line_trap_count;
722      }
723      if (TabFind::VeryDifferentSizes(std::max(n_width, n_height), std::max(width, height)) &&
724          (((dir == BND_LEFT || dir == BND_RIGHT) && TabFind::DifferentSizes(n_height, height)) ||
725           ((dir == BND_BELOW || dir == BND_ABOVE) && TabFind::DifferentSizes(n_width, width)))) {
726        if (debug) {
727          tprintf("Bad size\n");
728        }
729        continue; 
730      }
731      int overlap;
732      int perp_overlap;
733      int gap;
734      if (dir == BND_LEFT || dir == BND_RIGHT) {
735        overlap = std::min(static_cast<int>(nbox.top()), top) -
736                  std::max(static_cast<int>(nbox.bottom()), bottom);
737        if (overlap == nbox.height() && nbox.width() > nbox.height()) {
738          perp_overlap = nbox.width();
739        } else {
740          perp_overlap = overlap;
741        }
742        gap = dir == BND_LEFT ? left - nbox.left() : nbox.right() - right;
743        if (gap <= 0) {
744          if (debug) {
745            tprintf("On wrong side\n");
746          }
747          continue; 
748        }
749        gap -= n_width;
750      } else {
751        overlap = std::min(static_cast<int>(nbox.right()), right) -
752                  std::max(static_cast<int>(nbox.left()), left);
753        if (overlap == nbox.width() && nbox.height() > nbox.width()) {
754          perp_overlap = nbox.height();
755        } else {
756          perp_overlap = overlap;
757        }
758        gap = dir == BND_BELOW ? bottom - nbox.bottom() : nbox.top() - top;
759        if (gap <= 0) {
760          if (debug) {
761            tprintf("On wrong side\n");
762          }
763          continue; 
764        }
765        gap -= n_height;
766      }
767      if (-gap > overlap) {
768        if (debug) {
769          tprintf("Overlaps wrong way\n");
770        }
771        continue; 
772      }
773      if (perp_overlap < min_decent_overlap) {
774        if (debug) {
775          tprintf("Doesn't overlap enough\n");
776        }
777        continue; 
778      }
779      bool bad_sizes =
780          TabFind::DifferentSizes(height, n_height) && TabFind::DifferentSizes(width, n_width);
781      bool is_good =
782          overlap >= min_good_overlap && !bad_sizes &&
783          blob->MatchingStrokeWidth(*neighbour, kStrokeWidthFractionTolerance, kStrokeWidthTolerance);
784      if (gap < 1) {
785        gap = 1;
786      }
787      double goodness = (1.0 + is_good) * overlap / gap;
788      if (debug) {
789        tprintf("goodness = %g vs best of %g, good=%d, overlap=%d, gap=%d\n", goodness, best_goodness,
790                is_good, overlap, gap);
791      }
792      if (goodness > best_goodness) {
793        best_neighbour = neighbour;
794        best_goodness = goodness;
795        best_is_good = is_good;
796      }
797    }
798    blob->set_neighbour(dir, best_neighbour, best_is_good);
799    return line_trap_count;
800  }
801  static void ListNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
802    for (int dir = 0; dir < BND_COUNT; ++dir) {
803      auto bnd = static_cast<BlobNeighbourDir>(dir);
804      BLOBNBOX *neighbour = blob->neighbour(bnd);
805      if (neighbour != nullptr) {
806        neighbours->add_sorted(SortByBoxLeft<BLOBNBOX>, true, neighbour);
807      }
808    }
809  }
810  static void List2ndNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
811    ListNeighbours(blob, neighbours);
812    for (int dir = 0; dir < BND_COUNT; ++dir) {
813      auto bnd = static_cast<BlobNeighbourDir>(dir);
814      BLOBNBOX *neighbour = blob->neighbour(bnd);
815      if (neighbour != nullptr) {
816        ListNeighbours(neighbour, neighbours);
817      }
818    }
819  }
820  static void List3rdNeighbours(const BLOBNBOX *blob, BLOBNBOX_CLIST *neighbours) {
821    List2ndNeighbours(blob, neighbours);
822    for (int dir = 0; dir < BND_COUNT; ++dir) {
823      auto bnd = static_cast<BlobNeighbourDir>(dir);
824      BLOBNBOX *neighbour = blob->neighbour(bnd);
825      if (neighbour != nullptr) {
826        List2ndNeighbours(neighbour, neighbours);
827      }
828    }
829  }
830  static void CountNeighbourGaps(bool debug, BLOBNBOX_CLIST *neighbours, int *pure_h_count,
831                                 int *pure_v_count) {
832    if (neighbours->length() <= kMostlyOneDirRatio) {
833      return;
834    }
835    BLOBNBOX_C_IT it(neighbours);
836    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
837      BLOBNBOX *blob = it.data();
838      int h_min, h_max, v_min, v_max;
839      blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
840      if (debug) {
841        tprintf("Hgaps [%d,%d], vgaps [%d,%d]:", h_min, h_max, v_min, v_max);
842      }
843      if (h_max < v_min || blob->leader_on_left() || blob->leader_on_right()) {
844        ++*pure_h_count;
845        if (debug) {
846          tprintf("Horz at:");
847        }
848      } else if (v_max < h_min) {
849        ++*pure_v_count;
850        if (debug) {
851          tprintf("Vert at:");
852        }
853      } else {
854        if (debug) {
855          tprintf("Neither at:");
856        }
857      }
858      if (debug) {
859        blob->bounding_box().print();
860      }
861    }
862  }
863  void StrokeWidth::SetNeighbourFlows(BLOBNBOX *blob) {
864    if (blob->DefiniteIndividualFlow()) {
865      return;
866    }
867    bool debug =
868        AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(), blob->bounding_box().bottom());
869    if (debug) {
870      tprintf("SetNeighbourFlows (current flow=%d, type=%d) on:", blob->flow(), blob->region_type());
871      blob->bounding_box().print();
872    }
873    BLOBNBOX_CLIST neighbours;
874    List3rdNeighbours(blob, &neighbours);
875    int pure_h_count = 0;
876    int pure_v_count = 0;
877    CountNeighbourGaps(debug, &neighbours, &pure_h_count, &pure_v_count);
878    if (debug) {
879      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
880      tprintf("SetFlows: h_count=%d, v_count=%d\n", pure_h_count, pure_v_count);
881    }
882    if (!neighbours.empty()) {
883      blob->set_vert_possible(true);
884      blob->set_horz_possible(true);
885      if (pure_h_count > 2 * pure_v_count) {
886        blob->set_vert_possible(false);
887      } else if (pure_v_count > 2 * pure_h_count) {
888        blob->set_horz_possible(false);
889      }
890    } else {
891      blob->set_vert_possible(false);
892      blob->set_horz_possible(false);
893    }
894  }
895  static void CountNeighbourTypes(BLOBNBOX_CLIST *neighbours, int *pure_h_count, int *pure_v_count) {
896    BLOBNBOX_C_IT it(neighbours);
897    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
898      BLOBNBOX *blob = it.data();
899      if (blob->UniquelyHorizontal()) {
900        ++*pure_h_count;
901      }
902      if (blob->UniquelyVertical()) {
903        ++*pure_v_count;
904      }
905    }
906  }
907  void StrokeWidth::SimplifyObviousNeighbours(BLOBNBOX *blob) {
908    if ((blob->bounding_box().width() > 3 * blob->area_stroke_width() &&
909         blob->bounding_box().height() > 3 * blob->area_stroke_width())) {
910      if (blob->bounding_box().width() > 4 * blob->bounding_box().height()) {
911        blob->set_neighbour(BND_ABOVE, nullptr, false);
912        blob->set_neighbour(BND_BELOW, nullptr, false);
913        return;
914      }
915      if (blob->bounding_box().height() > 4 * blob->bounding_box().width()) {
916        blob->set_neighbour(BND_LEFT, nullptr, false);
917        blob->set_neighbour(BND_RIGHT, nullptr, false);
918        return;
919      }
920    }
921    int margin = gridsize() / 2;
922    int h_min, h_max, v_min, v_max;
923    blob->MinMaxGapsClipped(&h_min, &h_max, &v_min, &v_max);
924    if ((h_max + margin < v_min && h_max < margin / 2) || blob->leader_on_left() ||
925        blob->leader_on_right()) {
926      blob->set_neighbour(BND_ABOVE, nullptr, false);
927      blob->set_neighbour(BND_BELOW, nullptr, false);
928    } else if (v_max + margin < h_min && v_max < margin / 2) {
929      blob->set_neighbour(BND_LEFT, nullptr, false);
930      blob->set_neighbour(BND_RIGHT, nullptr, false);
931    }
932  }
933  void StrokeWidth::SmoothNeighbourTypes(PageSegMode pageseg_mode, bool reset_all, BLOBNBOX *blob) {
934    if ((blob->vert_possible() && blob->horz_possible()) || reset_all) {
935      BLOBNBOX_CLIST neighbours;
936      List2ndNeighbours(blob, &neighbours);
937      int pure_h_count = 0;
938      int pure_v_count = 0;
939      CountNeighbourTypes(&neighbours, &pure_h_count, &pure_v_count);
940      if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
941                                        blob->bounding_box().bottom())) {
942        HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
943        tprintf("pure_h=%d, pure_v=%d\n", pure_h_count, pure_v_count);
944      }
945      if (pure_h_count > pure_v_count && !FindingVerticalOnly(pageseg_mode)) {
946        blob->set_vert_possible(false);
947        blob->set_horz_possible(true);
948      } else if (pure_v_count > pure_h_count && !FindingHorizontalOnly(pageseg_mode)) {
949        blob->set_horz_possible(false);
950        blob->set_vert_possible(true);
951      }
952    } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
953                                             blob->bounding_box().bottom())) {
954      HandleClick(blob->bounding_box().left() + 1, blob->bounding_box().bottom() + 1);
955      tprintf("Clean on pass 3!\n");
956    }
957  }
958  PartitionFindResult StrokeWidth::FindInitialPartitions(
959      PageSegMode pageseg_mode, const FCOORD &rerotation, bool find_problems, TO_BLOCK *block,
960      BLOBNBOX_LIST *diacritic_blobs, ColPartitionGrid *part_grid, ColPartition_LIST *big_parts,
961      FCOORD *skew_angle) {
962    if (!FindingHorizontalOnly(pageseg_mode)) {
963      FindVerticalTextChains(part_grid);
964    }
965    if (!FindingVerticalOnly(pageseg_mode)) {
966      FindHorizontalTextChains(part_grid);
967    }
968  #ifndef GRAPHICS_DISABLED
969    if (textord_tabfind_show_strokewidths) {
970      chains_win_ = MakeWindow(0, 400, "Initial text chains");
971      part_grid->DisplayBoxes(chains_win_);
972      projection_->DisplayProjection();
973    }
974  #endif
975    if (find_problems) {
976    }
977    part_grid->SplitOverlappingPartitions(big_parts);
978    EasyMerges(part_grid);
979    RemoveLargeUnusedBlobs(block, part_grid, big_parts);
980    TBOX grid_box(bleft(), tright());
981    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
982      ;
983    }
984    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
985      ;
986    }
987    int pre_overlap = part_grid->ComputeTotalOverlap(nullptr);
988    TestDiacritics(part_grid, block);
989    MergeDiacritics(block, part_grid);
990    if (find_problems && diacritic_blobs != nullptr &&
991        DetectAndRemoveNoise(pre_overlap, grid_box, block, part_grid, diacritic_blobs)) {
992      return PFR_NOISE;
993    }
994  #ifndef GRAPHICS_DISABLED
995    if (textord_tabfind_show_strokewidths) {
996      textlines_win_ = MakeWindow(400, 400, "GoodTextline blobs");
997      part_grid->DisplayBoxes(textlines_win_);
998      diacritics_win_ = DisplayDiacritics("Diacritics", 0, 0, block);
999    }
1000  #endif
1001    PartitionRemainingBlobs(pageseg_mode, part_grid);
1002    part_grid->SplitOverlappingPartitions(big_parts);
1003    EasyMerges(part_grid);
1004    while (part_grid->GridSmoothNeighbours(BTFT_CHAIN, nontext_map_, grid_box, rerotation)) {
1005      ;
1006    }
1007    while (part_grid->GridSmoothNeighbours(BTFT_NEIGHBOURS, nontext_map_, grid_box, rerotation)) {
1008      ;
1009    }
1010    while (part_grid->GridSmoothNeighbours(BTFT_STRONG_CHAIN, nontext_map_, grid_box, rerotation)) {
1011      ;
1012    }
1013  #ifndef GRAPHICS_DISABLED
1014    if (textord_tabfind_show_strokewidths) {
1015      smoothed_win_ = MakeWindow(800, 400, "Smoothed blobs");
1016      part_grid->DisplayBoxes(smoothed_win_);
1017    }
1018  #endif
1019    return PFR_OK;
1020  }
1021  bool StrokeWidth::DetectAndRemoveNoise(int pre_overlap, const TBOX &grid_box, TO_BLOCK *block,
1022                                         ColPartitionGrid *part_grid,
1023                                         BLOBNBOX_LIST *diacritic_blobs) {
1024    ColPartitionGrid *noise_grid = nullptr;
1025    int post_overlap = part_grid->ComputeTotalOverlap(&noise_grid);
1026    if (pre_overlap == 0) {
1027      pre_overlap = 1;
1028    }
1029    BLOBNBOX_IT diacritic_it(diacritic_blobs);
1030    if (noise_grid != nullptr) {
1031      if (post_overlap > pre_overlap * kNoiseOverlapGrowthFactor &&
1032          post_overlap > grid_box.area() * kNoiseOverlapAreaFactor) {
1033  #ifndef GRAPHICS_DISABLED
1034        if (textord_tabfind_show_strokewidths) {
1035          ScrollView *noise_win = MakeWindow(1000, 500, "Noise Areas");
1036          noise_grid->DisplayBoxes(noise_win);
1037        }
1038  #endif
1039        part_grid->DeleteNonLeaderParts();
1040        BLOBNBOX_IT blob_it(&block->noise_blobs);
1041        ColPartitionGridSearch rsearch(noise_grid);
1042        for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1043          BLOBNBOX *blob = blob_it.data();
1044          blob->ClearNeighbours();
1045          if (!blob->IsDiacritic() || blob->owner() != nullptr) {
1046            continue; 
1047          }
1048          TBOX search_box(blob->bounding_box());
1049          search_box.pad(gridsize(), gridsize());
1050          rsearch.StartRectSearch(search_box);
1051          ColPartition *part = rsearch.NextRectSearch();
1052          if (part != nullptr) {
1053            blob->set_owns_cblob(true);
1054            blob->compute_bounding_box();
1055            diacritic_it.add_after_then_move(blob_it.extract());
1056          }
1057        }
1058        noise_grid->DeleteParts();
1059        delete noise_grid;
1060        return true;
1061      }
1062      noise_grid->DeleteParts();
1063      delete noise_grid;
1064    }
1065    return false;
1066  }
1067  static BLOBNBOX *MutualUnusedVNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1068    BLOBNBOX *next_blob = blob->neighbour(dir);
1069    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyHorizontal()) {
1070      return nullptr;
1071    }
1072    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1073      return next_blob;
1074    }
1075    return nullptr;
1076  }
1077  void StrokeWidth::FindVerticalTextChains(ColPartitionGrid *part_grid) {
1078    PageSegMode pageseg_mode =
1079        rerotation_.y() == 0.0f ? PSM_SINGLE_BLOCK_VERT_TEXT : PSM_SINGLE_COLUMN;
1080    BlobGridSearch gsearch(this);
1081    BLOBNBOX *bbox;
1082    gsearch.StartFullSearch();
1083    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1084      BLOBNBOX *blob;
1085      if (bbox->owner() == nullptr && bbox->UniquelyVertical() &&
1086          (blob = MutualUnusedVNeighbour(bbox, BND_ABOVE)) != nullptr) {
1087        auto *part = new ColPartition(BRT_VERT_TEXT, ICOORD(0, 1));
1088        part->AddBox(bbox);
1089        while (blob != nullptr) {
1090          part->AddBox(blob);
1091          blob = MutualUnusedVNeighbour(blob, BND_ABOVE);
1092        }
1093        blob = MutualUnusedVNeighbour(bbox, BND_BELOW);
1094        while (blob != nullptr) {
1095          part->AddBox(blob);
1096          blob = MutualUnusedVNeighbour(blob, BND_BELOW);
1097        }
1098        CompletePartition(pageseg_mode, part, part_grid);
1099      }
1100    }
1101  }
1102  static BLOBNBOX *MutualUnusedHNeighbour(const BLOBNBOX *blob, BlobNeighbourDir dir) {
1103    BLOBNBOX *next_blob = blob->neighbour(dir);
1104    if (next_blob == nullptr || next_blob->owner() != nullptr || next_blob->UniquelyVertical()) {
1105      return nullptr;
1106    }
1107    if (next_blob->neighbour(DirOtherWay(dir)) == blob) {
1108      return next_blob;
1109    }
1110    return nullptr;
1111  }
1112  void StrokeWidth::FindHorizontalTextChains(ColPartitionGrid *part_grid) {
1113    PageSegMode pageseg_mode =
1114        rerotation_.y() == 0.0f ? PSM_SINGLE_COLUMN : PSM_SINGLE_BLOCK_VERT_TEXT;
1115    BlobGridSearch gsearch(this);
1116    BLOBNBOX *bbox;
1117    gsearch.StartFullSearch();
1118    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1119      BLOBNBOX *blob;
1120      if (bbox->owner() == nullptr && bbox->UniquelyHorizontal() &&
1121          (blob = MutualUnusedHNeighbour(bbox, BND_RIGHT)) != nullptr) {
1122        auto *part = new ColPartition(BRT_TEXT, ICOORD(0, 1));
1123        part->AddBox(bbox);
1124        while (blob != nullptr) {
1125          part->AddBox(blob);
1126          blob = MutualUnusedHNeighbour(blob, BND_RIGHT);
1127        }
1128        blob = MutualUnusedHNeighbour(bbox, BND_LEFT);
1129        while (blob != nullptr) {
1130          part->AddBox(blob);
1131          blob = MutualUnusedVNeighbour(blob, BND_LEFT);
1132        }
1133        CompletePartition(pageseg_mode, part, part_grid);
1134      }
1135    }
1136  }
1137  void StrokeWidth::TestDiacritics(ColPartitionGrid *part_grid, TO_BLOCK *block) {
1138    BlobGrid small_grid(gridsize(), bleft(), tright());
1139    small_grid.InsertBlobList(&block->noise_blobs);
1140    small_grid.InsertBlobList(&block->blobs);
1141    int medium_diacritics = 0;
1142    int small_diacritics = 0;
1143    BLOBNBOX_IT small_it(&block->noise_blobs);
1144    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1145      BLOBNBOX *blob = small_it.data();
1146      if (blob->owner() == nullptr && !blob->IsDiacritic() && DiacriticBlob(&small_grid, blob)) {
1147        ++small_diacritics;
1148      }
1149    }
1150    BLOBNBOX_IT blob_it(&block->blobs);
1151    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
1152      BLOBNBOX *blob = blob_it.data();
1153      if (blob->IsDiacritic()) {
1154        small_it.add_to_end(blob_it.extract());
1155        continue; 
1156      }
1157      ColPartition *part = blob->owner();
1158      if (part == nullptr && DiacriticBlob(&small_grid, blob)) {
1159        ++medium_diacritics;
1160        RemoveBBox(blob);
1161        small_it.add_to_end(blob_it.extract());
1162      } else if (part != nullptr && !part->block_owned() && part->boxes_count() < 3) {
1163        BLOBNBOX_C_IT box_it(part->boxes());
1164        for (box_it.mark_cycle_pt();
1165             !box_it.cycled_list() && DiacriticBlob(&small_grid, box_it.data()); box_it.forward()) {
1166          ;
1167        }
1168        if (box_it.cycled_list()) {
1169          while (!box_it.empty()) {
1170            BLOBNBOX *box = box_it.extract();
1171            box->set_owner(nullptr);
1172            box_it.forward();
1173            ++medium_diacritics;
1174            RemoveBBox(box);
1175          }
1176          small_it.add_to_end(blob_it.extract());
1177          part_grid->RemoveBBox(part);
1178          delete part;
1179        }
1180      } else if (AlignedBlob::WithinTestRegion(2, blob->bounding_box().left(),
1181                                               blob->bounding_box().bottom())) {
1182        tprintf("Blob not available to be a diacritic at:");
1183        blob->bounding_box().print();
1184      }
1185    }
1186    if (textord_tabfind_show_strokewidths) {
1187      tprintf("Found %d small diacritics, %d medium\n", small_diacritics, medium_diacritics);
1188    }
1189  }
1190  bool StrokeWidth::DiacriticBlob(BlobGrid *small_grid, BLOBNBOX *blob) {
1191    if (BLOBNBOX::UnMergeableType(blob->region_type()) || blob->region_type() == BRT_VERT_TEXT) {
1192      return false;
1193    }
1194    TBOX small_box(blob->bounding_box());
1195    bool debug = AlignedBlob::WithinTestRegion(2, small_box.left(), small_box.bottom());
1196    if (debug) {
1197      tprintf("Testing blob for diacriticness at:");
1198      small_box.print();
1199    }
1200    int x = (small_box.left() + small_box.right()) / 2;
1201    int y = (small_box.bottom() + small_box.top()) / 2;
1202    int grid_x, grid_y;
1203    GridCoords(x, y, &grid_x, &grid_y);
1204    int height = small_box.height();
1205    BLOBNBOX *best_x_overlap = nullptr;
1206    BLOBNBOX *best_y_overlap = nullptr;
1207    int best_total_dist = 0;
1208    int best_y_gap = 0;
1209    TBOX best_xbox;
1210    TBOX search_box(small_box);
1211    int x_pad = IntCastRounded(gridsize() * kDiacriticXPadRatio);
1212    int y_pad = IntCastRounded(gridsize() * kDiacriticYPadRatio);
1213    search_box.pad(x_pad, y_pad);
1214    BlobGridSearch rsearch(this);
1215    rsearch.SetUniqueMode(true);
1216    int min_height = height * kMinDiacriticSizeRatio;
1217    rsearch.StartRectSearch(search_box);
1218    BLOBNBOX *neighbour;
1219    while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1220      if (BLOBNBOX::UnMergeableType(neighbour->region_type()) || neighbour == blob ||
1221          neighbour->owner() == blob->owner()) {
1222        continue;
1223      }
1224      TBOX nbox = neighbour->bounding_box();
1225      if (neighbour->owner() == nullptr || neighbour->owner()->IsVerticalType() ||
1226          (neighbour->flow() != BTFT_CHAIN && neighbour->flow() != BTFT_STRONG_CHAIN)) {
1227        if (debug) {
1228          tprintf("Neighbour not strong enough:");
1229          nbox.print();
1230        }
1231        continue; 
1232      }
1233      if (nbox.height() < min_height) {
1234        if (debug) {
1235          tprintf("Neighbour not big enough:");
1236          nbox.print();
1237        }
1238        continue; 
1239      }
1240      int x_gap = small_box.x_gap(nbox);
1241      int y_gap = small_box.y_gap(nbox);
1242      int total_distance = projection_->DistanceOfBoxFromBox(small_box, nbox, true, denorm_, debug);
1243      if (debug) {
1244        tprintf("xgap=%d, y=%d, total dist=%d\n", x_gap, y_gap, total_distance);
1245      }
1246      if (total_distance > neighbour->owner()->median_height() * kMaxDiacriticDistanceRatio) {
1247        if (debug) {
1248          tprintf("Neighbour with median size %d too far away:", neighbour->owner()->median_height());
1249          neighbour->bounding_box().print();
1250        }
1251        continue; 
1252      }
1253      if (x_gap <= 0) {
1254        if (debug) {
1255          tprintf("Computing reduced box for :");
1256          nbox.print();
1257        }
1258        int left = small_box.left() - small_box.width();
1259        int right = small_box.right() + small_box.width();
1260        nbox = neighbour->BoundsWithinLimits(left, right);
1261        y_gap = small_box.y_gap(nbox);
1262        if (best_x_overlap == nullptr || y_gap < best_y_gap) {
1263          best_x_overlap = neighbour;
1264          best_xbox = nbox;
1265          best_y_gap = y_gap;
1266          if (debug) {
1267            tprintf("New best:");
1268            nbox.print();
1269          }
1270        } else if (debug) {
1271          tprintf("Shrunken box doesn't win:");
1272          nbox.print();
1273        }
1274      } else if (blob->ConfirmNoTabViolation(*neighbour)) {
1275        if (best_y_overlap == nullptr || total_distance < best_total_dist) {
1276          if (debug) {
1277            tprintf("New best y overlap:");
1278            nbox.print();
1279          }
1280          best_y_overlap = neighbour;
1281          best_total_dist = total_distance;
1282        } else if (debug) {
1283          tprintf("New y overlap box doesn't win:");
1284          nbox.print();
1285        }
1286      } else if (debug) {
1287        tprintf("Neighbour wrong side of a tab:");
1288        nbox.print();
1289      }
1290    }
1291    if (best_x_overlap != nullptr &&
1292        (best_y_overlap == nullptr || best_xbox.major_y_overlap(best_y_overlap->bounding_box()))) {
1293      blob->set_diacritic_box(best_xbox);
1294      blob->set_base_char_blob(best_x_overlap);
1295      if (debug) {
1296        tprintf("DiacriticBlob OK! (x-overlap:");
1297        small_box.print();
1298        best_xbox.print();
1299      }
1300      return true;
1301    }
1302    if (best_y_overlap != nullptr &&
1303        DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()) &&
1304        NoNoiseInBetween(small_box, best_y_overlap->bounding_box())) {
1305      blob->set_diacritic_box(best_y_overlap->bounding_box());
1306      blob->set_base_char_blob(best_y_overlap);
1307      if (debug) {
1308        tprintf("DiacriticBlob OK! (y-overlap:");
1309        small_box.print();
1310        best_y_overlap->bounding_box().print();
1311      }
1312      return true;
1313    }
1314    if (debug) {
1315      tprintf("DiacriticBlob fails:");
1316      small_box.print();
1317      tprintf("Best x+y gap = %d, y = %d\n", best_total_dist, best_y_gap);
1318      if (best_y_overlap != nullptr) {
1319        tprintf("XGapFilled=%d, NoiseBetween=%d\n",
1320                DiacriticXGapFilled(small_grid, small_box, best_y_overlap->bounding_box()),
1321                NoNoiseInBetween(small_box, best_y_overlap->bounding_box()));
1322      }
1323    }
1324    return false;
1325  }
1326  bool StrokeWidth::DiacriticXGapFilled(BlobGrid *grid, const TBOX &diacritic_box,
1327                                        const TBOX &base_box) {
1328    int max_gap = IntCastRounded(base_box.height() * kMaxDiacriticGapToBaseCharHeight);
1329    TBOX occupied_box(base_box);
1330    int diacritic_gap;
1331    while ((diacritic_gap = diacritic_box.x_gap(occupied_box)) > max_gap) {
1332      TBOX search_box(occupied_box);
1333      if (diacritic_box.left() > search_box.right()) {
1334        search_box.set_left(search_box.right());
1335        search_box.set_right(search_box.left() + max_gap);
1336      } else {
1337        search_box.set_right(search_box.left());
1338        search_box.set_left(search_box.left() - max_gap);
1339      }
1340      BlobGridSearch rsearch(grid);
1341      rsearch.StartRectSearch(search_box);
1342      BLOBNBOX *neighbour;
1343      while ((neighbour = rsearch.NextRectSearch()) != nullptr) {
1344        const TBOX &nbox = neighbour->bounding_box();
1345        if (nbox.x_gap(diacritic_box) < diacritic_gap) {
1346          if (nbox.left() < occupied_box.left()) {
1347            occupied_box.set_left(nbox.left());
1348          }
1349          if (nbox.right() > occupied_box.right()) {
1350            occupied_box.set_right(nbox.right());
1351          }
1352          break;
1353        }
1354      }
1355      if (neighbour == nullptr) {
1356        return false; 
1357      }
1358    }
1359    return true; 
1360  }
1361  void StrokeWidth::MergeDiacritics(TO_BLOCK *block, ColPartitionGrid *part_grid) {
1362    BLOBNBOX_IT small_it(&block->noise_blobs);
1363    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
1364      BLOBNBOX *blob = small_it.data();
1365      if (blob->base_char_blob() != nullptr) {
1366        ColPartition *part = blob->base_char_blob()->owner();
1367        if (part != nullptr && !part->block_owned() && blob->owner() == nullptr &&
1368            blob->IsDiacritic()) {
1369          part_grid->RemoveBBox(part);
1370          part->AddBox(blob);
1371          blob->set_region_type(part->blob_type());
1372          blob->set_flow(part->flow());
1373          blob->set_owner(part);
1374          part_grid->InsertBBox(true, true, part);
1375        }
1376        blob->set_base_char_blob(nullptr);
1377      }
1378    }
1379  }
1380  void StrokeWidth::RemoveLargeUnusedBlobs(TO_BLOCK *block, ColPartitionGrid *part_grid,
1381                                           ColPartition_LIST *big_parts) {
1382    BLOBNBOX_IT large_it(&block->large_blobs);
1383    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
1384      BLOBNBOX *blob = large_it.data();
1385      ColPartition *big_part = blob->owner();
1386      if (big_part == nullptr) {
1387        ColPartition::MakeBigPartition(blob, big_parts);
1388      }
1389    }
1390  }
1391  void StrokeWidth::PartitionRemainingBlobs(PageSegMode pageseg_mode, ColPartitionGrid *part_grid) {
1392    BlobGridSearch gsearch(this);
1393    BLOBNBOX *bbox;
1394    int prev_grid_x = -1;
1395    int prev_grid_y = -1;
1396    BLOBNBOX_CLIST cell_list;
1397    BLOBNBOX_C_IT cell_it(&cell_list);
1398    bool cell_all_noise = true;
1399    gsearch.StartFullSearch();
1400    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1401      int grid_x = gsearch.GridX();
1402      int grid_y = gsearch.GridY();
1403      if (grid_x != prev_grid_x || grid_y != prev_grid_y) {
1404        MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1405        cell_it.set_to_list(&cell_list);
1406        prev_grid_x = grid_x;
1407        prev_grid_y = grid_y;
1408        cell_all_noise = true;
1409      }
1410      if (bbox->owner() == nullptr) {
1411        cell_it.add_to_end(bbox);
1412        if (bbox->flow() != BTFT_NONTEXT) {
1413          cell_all_noise = false;
1414        }
1415      } else {
1416        cell_all_noise = false;
1417      }
1418    }
1419    MakePartitionsFromCellList(pageseg_mode, cell_all_noise, part_grid, &cell_list);
1420  }
1421  void StrokeWidth::MakePartitionsFromCellList(PageSegMode pageseg_mode, bool combine,
1422                                               ColPartitionGrid *part_grid,
1423                                               BLOBNBOX_CLIST *cell_list) {
1424    if (cell_list->empty()) {
1425      return;
1426    }
1427    BLOBNBOX_C_IT cell_it(cell_list);
1428    if (combine) {
1429      BLOBNBOX *bbox = cell_it.extract();
1430      auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1431      part->AddBox(bbox);
1432      part->set_flow(bbox->flow());
1433      for (cell_it.forward(); !cell_it.empty(); cell_it.forward()) {
1434        part->AddBox(cell_it.extract());
1435      }
1436      CompletePartition(pageseg_mode, part, part_grid);
1437    } else {
1438      for (; !cell_it.empty(); cell_it.forward()) {
1439        BLOBNBOX *bbox = cell_it.extract();
1440        auto *part = new ColPartition(bbox->region_type(), ICOORD(0, 1));
1441        part->set_flow(bbox->flow());
1442        part->AddBox(bbox);
1443        CompletePartition(pageseg_mode, part, part_grid);
1444      }
1445    }
1446  }
1447  void StrokeWidth::CompletePartition(PageSegMode pageseg_mode, ColPartition *part,
1448                                      ColPartitionGrid *part_grid) {
1449    part->ComputeLimits();
1450    TBOX box = part->bounding_box();
1451    bool debug = AlignedBlob::WithinTestRegion(2, box.left(), box.bottom());
1452    int value = projection_->EvaluateColPartition(*part, denorm_, debug);
1453    if (value > 0 && FindingVerticalOnly(pageseg_mode)) {
1454      value = part->boxes_count() == 1 ? 0 : -2;
1455    } else if (value < 0 && FindingHorizontalOnly(pageseg_mode)) {
1456      value = part->boxes_count() == 1 ? 0 : 2;
1457    }
1458    part->SetRegionAndFlowTypesFromProjectionValue(value);
1459    part->ClaimBoxes();
1460    part_grid->InsertBBox(true, true, part);
1461  }
1462  void StrokeWidth::EasyMerges(ColPartitionGrid *part_grid) {
1463    using namespace std::placeholders; 
1464    part_grid->Merges(std::bind(&StrokeWidth::OrientationSearchBox, this, _1, _2),
1465                      std::bind(&StrokeWidth::ConfirmEasyMerge, this, _1, _2));
1466  }
1467  bool StrokeWidth::OrientationSearchBox(ColPartition *part, TBOX *box) {
1468    if (part->IsVerticalType()) {
1469      box->set_top(box->top() + box->width());
1470      box->set_bottom(box->bottom() - box->width());
1471    } else {
1472      box->set_left(box->left() - box->height());
1473      box->set_right(box->right() + box->height());
1474    }
1475    return true;
1476  }
1477  bool StrokeWidth::ConfirmEasyMerge(const ColPartition *p1, const ColPartition *p2) {
1478    ASSERT_HOST(p1 != nullptr && p2 != nullptr);
1479    ASSERT_HOST(!p1->IsEmpty() && !p2->IsEmpty());
1480    if ((p1->flow() == BTFT_NONTEXT && p2->flow() >= BTFT_CHAIN) ||
1481        (p1->flow() >= BTFT_CHAIN && p2->flow() == BTFT_NONTEXT)) {
1482      return false; 
1483    }
1484    if ((p1->IsVerticalType() || p2->IsVerticalType()) && p1->HCoreOverlap(*p2) <= 0 &&
1485        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1486         !p1->bounding_box().major_overlap(p2->bounding_box()))) {
1487      return false; 
1488    }
1489    if ((p1->IsHorizontalType() || p2->IsHorizontalType()) && p1->VCoreOverlap(*p2) <= 0 &&
1490        ((!p1->IsSingleton() && !p2->IsSingleton()) ||
1491         (!p1->bounding_box().major_overlap(p2->bounding_box()) &&
1492          !p1->OKDiacriticMerge(*p2, false) && !p2->OKDiacriticMerge(*p1, false)))) {
1493      return false; 
1494    }
1495    if (!p1->ConfirmNoTabViolation(*p2)) {
1496      return false;
1497    }
1498    if (p1->flow() <= BTFT_NONTEXT && p2->flow() <= BTFT_NONTEXT) {
1499      return true;
1500    }
1501    return NoNoiseInBetween(p1->bounding_box(), p2->bounding_box());
1502  }
1503  bool StrokeWidth::NoNoiseInBetween(const TBOX &box1, const TBOX &box2) const {
1504    return ImageFind::BlankImageInBetween(box1, box2, grid_box_, rerotation_, nontext_map_);
1505  }
1506  #ifndef GRAPHICS_DISABLED
1507  ScrollView *StrokeWidth::DisplayGoodBlobs(const char *window_name, int x, int y) {
1508    auto window = MakeWindow(x, y, window_name);
1509    window->Brush(ScrollView::NONE);
1510    BlobGridSearch gsearch(this);
1511    gsearch.StartFullSearch();
1512    BLOBNBOX *bbox;
1513    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
1514      const TBOX &box = bbox->bounding_box();
1515      int left_x = box.left();
1516      int right_x = box.right();
1517      int top_y = box.top();
1518      int bottom_y = box.bottom();
1519      int goodness = bbox->GoodTextBlob();
1520      BlobRegionType blob_type = bbox->region_type();
1521      if (bbox->UniquelyVertical()) {
1522        blob_type = BRT_VERT_TEXT;
1523      }
1524      if (bbox->UniquelyHorizontal()) {
1525        blob_type = BRT_TEXT;
1526      }
1527      BlobTextFlowType flow = bbox->flow();
1528      if (flow == BTFT_NONE) {
1529        if (goodness == 0) {
1530          flow = BTFT_NEIGHBOURS;
1531        } else if (goodness == 1) {
1532          flow = BTFT_CHAIN;
1533        } else {
1534          flow = BTFT_STRONG_CHAIN;
1535        }
1536      }
1537      window->Pen(BLOBNBOX::TextlineColor(blob_type, flow));
1538      window->Rectangle(left_x, bottom_y, right_x, top_y);
1539    }
1540    window->Update();
1541    return window;
1542  }
1543  static void DrawDiacriticJoiner(const BLOBNBOX *blob, ScrollView *window) {
1544    const TBOX &blob_box(blob->bounding_box());
1545    int top = std::max(static_cast<int>(blob_box.top()), blob->base_char_top());
1546    int bottom = std::min(static_cast<int>(blob_box.bottom()), blob->base_char_bottom());
1547    int x = (blob_box.left() + blob_box.right()) / 2;
1548    window->Line(x, top, x, bottom);
1549  }
1550  ScrollView *StrokeWidth::DisplayDiacritics(const char *window_name, int x, int y, TO_BLOCK *block) {
1551    auto window = MakeWindow(x, y, window_name);
1552    window->Brush(ScrollView::NONE);
1553    BLOBNBOX_IT it(&block->blobs);
1554    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1555      BLOBNBOX *blob = it.data();
1556      if (blob->IsDiacritic()) {
1557        window->Pen(ScrollView::GREEN);
1558        DrawDiacriticJoiner(blob, window);
1559      } else {
1560        window->Pen(blob->BoxColor());
1561      }
1562      const TBOX &box = blob->bounding_box();
1563      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1564    }
1565    it.set_to_list(&block->noise_blobs);
1566    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1567      BLOBNBOX *blob = it.data();
1568      if (blob->IsDiacritic()) {
1569        window->Pen(ScrollView::GREEN);
1570        DrawDiacriticJoiner(blob, window);
1571      } else {
1572        window->Pen(ScrollView::WHITE);
1573      }
1574      const TBOX &box = blob->bounding_box();
1575      window->Rectangle(box.left(), box.bottom(), box.right(), box.top());
1576    }
1577    window->Update();
1578    return window;
1579  }
1580  #endif 
1581  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <cmath>
6  #include <utility>
7  #include "tablefind.h"
8  #include <allheaders.h>
9  #include "colpartitionset.h"
10  #include "tablerecog.h"
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, "Show table regions (ScrollView)");
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  "Debug table marking steps in detail (ScrollView)");
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  "Show page stats used in table finding (ScrollView)");
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  "Enables the table recognizer for table layout and filtering.");
51  template <typename T>
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
63    leader_and_ruling_grid_.ClearGridData(&DeleteObject<ColPartition>);
64    fragmented_text_grid_.ClearGridData(&DeleteObject<ColPartition>);
65    col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);
66    table_grid_.ClearGridData(&DeleteObject<ColSegment>);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &bottom_left,
72                         const ICOORD &top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part->blob_type() == BRT_NOISE || part->bounding_box().area() <= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part->ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part->IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part->IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part->boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob->flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part->ShallowCopy();
110            leader_part->set_flow(BTFT_LEADER);
111          }
112          leader_part->AddBox(pblob);
113        } else if (pblob->region_type() != BRT_NOISE) {
114          clean_part->AddBox(pblob);
115        }
116      }
117      clean_part->ComputeLimits();
118      ColPartition *fragmented = clean_part->CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part->ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, "Column Partitions & Neighbors");
136      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, "Fragmented Text");
142      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
<span onclick='openModal()' class='match'>145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
</span>149    MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&table_columns, &table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, "Table Columns and Regions");
158      DisplayColSegments(table_win, &table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&table_regions, &table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, "Detected Table Locations");
171        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, "Recognized Tables");
182        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, "Detected Tables");
192        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part->IsEmpty() && part->bounding_box().area() > 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part->boxes()->empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part->median_width() > 0);
252    const double kThreshold = part->median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part->boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &box = box_it.data()->bounding_box();
261        if (previous_right != INT32_MIN &&
262            box.left() - previous_right > kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part->SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast<int>(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() > kHeightRequired &&
281           part.median_width() > kWidthRequired &&
282           part.bounding_box().area() > kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &blob) const {
285    const TBOX &box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() > kHeightRequired && box.width() > kWidthRequired &&
291           box.area() > kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i < gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns->GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &new_blocks);
306        GroupColumnBlocks(&new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &src_box = src_seg->bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg->bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg->InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) < x_margin) &&
337           (abs(b1.right() - b2.right()) < x_margin) &&
338           (abs(b1.top() - b2.bottom()) < y_margin ||
339            abs(b2.top() - b1.bottom()) < y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&clean_part_grid_, all_columns);
344    SetGlobalSpacings(&clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part->bounding_box();
354      int y = part->MidY();
355      ColPartition *left_column = columns->ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns->ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column->LeftAtY(y));
359        part->set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column->RightAtY(y) - box.right());
363        part->set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor->type() == PT_PULLOUT_IMAGE ||
370            neighbor->type() == PT_FLOWING_IMAGE ||
371            neighbor->type() == PT_HEADING_IMAGE) {
372          int right = neighbor->bounding_box().right();
373          if (right < box.left()) {
374            int space = std::min(box.left() - right, part->space_to_left());
375            part->set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor->type() == PT_PULLOUT_IMAGE ||
383            neighbor->type() == PT_FLOWING_IMAGE ||
384            neighbor->type() == PT_HEADING_IMAGE) {
385          int left = neighbor->bounding_box().left();
386          if (left > box.right()) {
387            int space = std::min(left - box.right(), part->space_to_right());
388            part->set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part->SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast<int>(upper_part->bounding_box().bottom() -
396                                         part->bounding_box().bottom()));
397        part->set_space_above(space);
398      } else {
399        part->set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part->SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast<int>(part->bounding_box().bottom() -
405                                         lower_part->bounding_box().bottom()));
406        part->set_space_below(space);
407      } else {
408        part->set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part->bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast<int>(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast<int>(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part->bounding_box();
421    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
422        &clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor->bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part->median_bottom() - neighbor->median_bottom());
436        if (neighbor_box.top() < part_box.bottom() && gap < min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() < neighbor_box.bottom() &&
441                 gap < min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part->set_space_above(min_space_above);
448    part->set_space_below(min_space_below);
449    part->set_nearest_neighbor_above(above_neighbor);
450    part->set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part->IsTextType()) {
462        BLOBNBOX_C_IT it(part->boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()->bounding_box().height(), 1);
465          width_stats.add(it.data()->bounding_box().width(), 1);
466        }
467        ledding_stats.add(part->space_above(), 1);
468        ledding_stats.add(part->space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast<int>(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast<int>(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast<int>(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = "X-height (R), X-width (G), and ledding (B)";
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part->SingletonPartner(true);
499      if (upper) {
500        part->set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part->SingletonPartner(false);
503      if (lower) {
504        part->set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, "Initial Table Partitions");
513      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, "Filtered Table Partitions");
522      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, "Smoothed Table Partitions");
531      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, "Final Table Partitions");
540      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
548        &clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part->IsTextType()) { 
553        continue;
554      }
555      if (part->median_height() > kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part->set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part->IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part->boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part->bounding_box().width() <
568            kMinBoxesInTextPartition * part->median_height() &&
569        part_boxes->length() < kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part->median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part->median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob->bounding_box().left();
581      current_x1 = blob->bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap < 0) {
585          if (-gap < part->median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap > max_gap) {
593          return true;
594        }
595        if (gap > largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part->bounding_box().width() >
602            kMaxBoxesInDataPartition * part->median_height() ||
603        part_boxes->length() > kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found < min_gap;
610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&leader_and_ruling_grid_);
620    for (int direction = 0; direction < 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader->flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader->VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part->type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part->nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part->type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part->bounding_box().width() < 2 * part->bounding_box().width()) {
661        continue;
662      }
663      int mid = (part->bounding_box().left() + part->bounding_box().right()) / 2;
664      int upper_mid = (upper_part->bounding_box().left() +
665                       upper_part->bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part->bounding_box().left(),
671                            upper_part->bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part->bounding_box().right(),
676                             upper_part->bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio > upper_spacing) {
681        continue;
682      }
683      if (!part->MatchingSizes(*upper_part) ||
684          !part->MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part->space_to_left() >
689          kMaxParagraphEndingLeftSpaceMultiple * part->median_height()) {
690        continue;
691      }
692      if (upper_part->bounding_box().width() <
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part->space_to_right()) {
695        continue;
696      }
697      if (part->space_above() >= part->space_below() ||
698          part->space_above() > 2 * global_median_ledding_) {
699        continue;
700      }
701      part->clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part->IsTextType()) {
714        continue; 
715      }
716      int top = part->bounding_box().top();
717      int bottom = part->bounding_box().bottom();
718      if (top > max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom < min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header->clear_table_type();
729    }
730    if (footer) {
731      footer->clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part->type() >= PT_TABLE || part->type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part->nearest_neighbor_above();
743      ColPartition *lower_part = part->nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE) {
748        part->set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part->type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part->nearest_neighbor_above();
758      ColPartition *lower_part = part->nearest_neighbor_below();
759      if ((upper_part && upper_part->type() != PT_TABLE) &&
760          (lower_part && lower_part->type() != PT_TABLE)) {
761        part->clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg->bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rsearch(
773          &clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part->type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part->type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells && !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg->set_num_table_cells(num_table_cells);
788        seg->set_num_text_cells(num_text_cells);
789        seg->set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid->InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
804        &col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg->type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg->bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast<int>(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast<int>(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
823            &col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &neighbor_box = neighbor->bounding_box();
831          if (neighbor_box.overlap_fraction(box) >= 0.9) {
832            seg->InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor->type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) && !box.contains(neighbor_box)) {
843            seg->InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
862        &clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part->inside_table_column() || part->type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &box = part->bounding_box();
870      auto *col = new ColSegment();
871      col->InsertBox(box);
872      part->set_inside_table_column(true);
873      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> vsearch(
874          &clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor->inside_table_column()) {
880          continue;
881        }
882        if (neighbor->IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor->type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &neighbor_box = neighbor->bounding_box();
889        col->InsertBox(neighbor_box);
890        neighbor->set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part->set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
906        &col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height > 0);
911    bool *table_region = new bool[page_height];
912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()->bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i < page_height; i++) {
929        if (!table_region[i - 1] && table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] && !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg->InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
946        &table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &box = seg->bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
959            &table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &neighbor_box = neighbor->bounding_box();
967          if (neighbor_box.overlap_fraction(box) >= 0.9) {
968            seg->InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg->InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
998        &clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &part_box = part->bounding_box();
1003      if (part_box.overlap(box1) && part_box.overlap(box2) &&
1004          !part->IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&adjusted_tables);
1013    ColSegmentGridSearch gsearch(&table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &table_box = table->bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col->InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &table_box,
1042                                               const TBOX &search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i < 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &fragmented_text_grid_ : &leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part->IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &part_box = part->bounding_box();
1055        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1056          *result_box = result_box->bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &table_box,
1063                                            const TBOX &search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part->IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &part_box = part->bounding_box();
1074      if (result_box->contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box->bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &part,
1083                                        const TBOX &table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i < 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &clean_part_grid_ : &leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &extra_part_box = extra_part->bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part->IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part->space_to_right() > space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part->space_to_left() > space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right > num_extra_partitions / 2) ||
1126           (extra_space_to_left > num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box->left(), table_box->right(),
1131                                table_box->top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor->median_height();
1137      int table_top = table_box->top();
1138      const TBOX &box = neighbor->bounding_box();
1139      if (box.bottom() - table_top > max_distance) {
1140        break;
1141      }
1142      if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
1143        table_box->set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &previous_box = previous_neighbor->bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width > 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1162        &table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table->bounding_box();
1167      for (int i = 0; i < page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1171          &clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part->IsTextType()) {
1177          continue; 
1178        }
1179        if (part->flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part->bounding_box();
1183        if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part->boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob->bounding_box().left();
1192          int xend = pblob->bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i < xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i < length; i++) {
1210      if (xprojection[i] > peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value < kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value >= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i < length; i++) {
1222      xprojection[i] = (xprojection[i] >= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i < length; i++) {
1227      if (xprojection[i - 1] && !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap > largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap > kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, "Table Structure");
1245      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&good_tables);
1257    ColSegmentGridSearch gsearch(&table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &found_box = found_table->bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure->Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table->set_bounding_box(table_structure->bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win->Pen(color);
1285    win->Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &box = col->bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win->Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win->UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part->type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &box = part->bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win->Brush(ScrollView::NONE);
1316      win->Pen(color);
1317      win->Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win->UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
1338      if (upper_part) {
1339        const TBOX &upper_box = upper_part->bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win->Brush(ScrollView::NONE);
1345        win->Pen(color);
1346        win->Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part->nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &lower_box = lower_part->bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win->Brush(ScrollView::NONE);
1356        win->Pen(color);
1357        win->Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win->UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &width_cb) {
1366    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part->type() == PT_TABLE) {
1371        part->clear_table_type();
1372      }
1373    }
1374    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1375        &table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &table_box = table->bounding_box();
1380      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part->IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part->bounding_box();
1390        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition->Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &table_box = table_partition->bounding_box();
1401        int grid_x, grid_y;
1402        grid->GridCoords(table_box.left(), table_box.bottom(), &grid_x, &grid_y);
1403        table_partition->SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition->set_table_type();
1405        table_partition->set_blob_type(BRT_TEXT);
1406        table_partition->set_flow(BTFT_CHAIN);
1407        table_partition->SetBlobTypes();
1408        grid->InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ > kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
1437  }
1438  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-strokewidth.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>165    Clear();
166    ColPartition_LIST leader_parts;
167    FindLeadersAndMarkNoise(block, &leader_parts);
168    InsertBlobList(&block->blobs);
</pre></code></div>
                <div class="column column_space"><pre><code>145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    