
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.246411483253588%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "TabBar.h"
3  #include "Parameters.h"
4  #define	IDC_DRAG_TAB     1404
5  #define	IDC_DRAG_INTERDIT_TAB 1405
6  #define	IDC_DRAG_PLUS_TAB 1406
7  #define	IDC_DRAG_OUT_TAB 1407
8  bool TabBarPlus::_doDragNDrop = false;
9  bool TabBarPlus::_drawTopBar = true;
10  bool TabBarPlus::_drawInactiveTab = true;
11  bool TabBarPlus::_drawTabCloseButton = false;
12  bool TabBarPlus::_isDbClk2Close = false;
13  bool TabBarPlus::_isCtrlVertical = false;
14  bool TabBarPlus::_isCtrlMultiLine = false;
15  COLORREF TabBarPlus::_activeTextColour = ::GetSysColor(COLOR_BTNTEXT);
16  COLORREF TabBarPlus::_activeTopBarFocusedColour = RGB(250, 170, 60);
17  COLORREF TabBarPlus::_activeTopBarUnfocusedColour = RGB(250, 210, 150);
18  COLORREF TabBarPlus::_inactiveTextColour = grey;
19  COLORREF TabBarPlus::_inactiveBgColour = RGB(192, 192, 192);
20  HWND TabBarPlus::_hwndArray[nbCtrlMax] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
21  int TabBarPlus::_nbCtrl = 0;
22  void TabBar::init(HINSTANCE hInst, HWND parent, bool isVertical, bool isMultiLine)
23  {
24  	Window::init(hInst, parent);
25  	int vertical = isVertical?(TCS_VERTICAL | TCS_MULTILINE | TCS_RIGHTJUSTIFY):0;
26  	_isVertical = isVertical;
27  	_isMultiLine = isMultiLine;
28  	INITCOMMONCONTROLSEX icce{};
29  	icce.dwSize = sizeof(icce);
30  	icce.dwICC = ICC_TAB_CLASSES;
31  	InitCommonControlsEx(&icce);
32  	int multiLine = isMultiLine ? TCS_MULTILINE : 0;
33  	int style = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE |\
34  		TCS_FOCUSNEVER | TCS_TABS | WS_TABSTOP | vertical | multiLine;
35  	_hSelf = ::CreateWindowEx(
36  				0,
37  				WC_TABCONTROL,
38  				TEXT("Tab"),
39  				style,
40  				0, 0, 0, 0,
41  				_hParent,
42  				NULL,
43  				_hInst,
44  				0);
45  	if (!_hSelf)
46  	{
47  		throw std::runtime_error("TabBar::init : CreateWindowEx() function return null");
48  	}
49  }
50  void TabBar::destroy()
51  {
52  	if (_hFont)
53  	{
54  		::DeleteObject(_hFont);
55  		_hFont = nullptr;
56  	}
57  	if (_hLargeFont)
58  	{
59  		::DeleteObject(_hLargeFont);
60  		_hLargeFont = nullptr;
61  	}
62  	if (_hVerticalFont)
63  	{
64  		::DeleteObject(_hVerticalFont);
65  		_hVerticalFont = nullptr;
66  	}
67  	if (_hVerticalLargeFont)
68  	{
69  		::DeleteObject(_hVerticalLargeFont);
70  		_hVerticalLargeFont = nullptr;
71  	}
72  	::DestroyWindow(_hSelf);
73  	_hSelf = nullptr;
74  }
75  int TabBar::insertAtEnd(const TCHAR *subTabName)
76  {
77  	TCITEM tie{};
78  	tie.mask = TCIF_TEXT | TCIF_IMAGE;
79  	int index = -1;
80  	if (_hasImgLst)
81  		index = 0;
82  	tie.iImage = index;
83  	tie.pszText = (TCHAR *)subTabName;
84  	return int(::SendMessage(_hSelf, TCM_INSERTITEM, _nbItem++, reinterpret_cast<LPARAM>(&tie)));
85  }
86  void TabBar::getCurrentTitle(TCHAR *title, int titleLen)
87  {
88  	TCITEM tci{};
89  	tci.mask = TCIF_TEXT;
90  	tci.pszText = title;
91  	tci.cchTextMax = titleLen-1;
92  	::SendMessage(_hSelf, TCM_GETITEM, getCurrentTabIndex(), reinterpret_cast<LPARAM>(&tci));
93  }
94  void TabBar::setFont(const TCHAR *fontName, int fontSize)
95  {
96  	if (_hFont)
97  		::DeleteObject(_hFont);
98  	_hFont = ::CreateFont( fontSize, 0,
99  						(_isVertical) ? 900:0,
100  						(_isVertical) ? 900:0,
101  						FW_NORMAL,
102  						0, 0, 0, 0,
103  						0, 0, 0, 0,
104  						fontName);
105  	if (_hFont)
106  		::SendMessage(_hSelf, WM_SETFONT, reinterpret_cast<WPARAM>(_hFont), 0);
107  }
108  void TabBar::activateAt(int index) const
109  {
110  	if (getCurrentTabIndex() != index)
111  	{
112  		if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
113  		{
114  			::SendMessage(_hSelf, TCM_SETCURFOCUS, index, 0);
115  		}
116  		::SendMessage(_hSelf, TCM_SETCURSEL, index, 0);
117  	}
118  }
119  void TabBar::deletItemAt(size_t index)
120  {
121  	if (index == _nbItem - 1)
122  	{
123  		if (_nbItem > 1)
124  		{
125  			RECT itemRect{};
126  			::SendMessage(_hSelf, TCM_GETITEMRECT, index, reinterpret_cast<LPARAM>(&itemRect));
127  			if (itemRect.left < 5) 
128  			{
129  				int wParam = MAKEWPARAM(SB_THUMBPOSITION, index - 1);
130  				::SendMessage(_hSelf, WM_HSCROLL, wParam, 0);
131  				wParam = MAKEWPARAM(SB_ENDSCROLL, index - 1);
132  				::SendMessage(_hSelf, WM_HSCROLL, wParam, 0);
133  			}
134  		}
135  	}
136  	::SendMessage(_hSelf, TCM_DELETEITEM, index, 0);
137  	_nbItem--;
138  }
139  void TabBar::setImageList(HIMAGELIST himl)
140  {
141  	_hasImgLst = true;
142  	::SendMessage(_hSelf, TCM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(himl));
143  }
144  void TabBar::reSizeTo(RECT & rc2Ajust)
145  {
146  	RECT rowRect{};
147  	int rowCount = 0, tabsHight = 0;
148  	display(rc2Ajust.right > 10);
149  	RECT rc = rc2Ajust;
150  	Window::reSizeTo(rc);
151  	rowCount = TabCtrl_GetRowCount(_hSelf);
152  	TabCtrl_GetItemRect(_hSelf, 0, &rowRect);
153  	int larger = _isVertical ? rowRect.right : rowRect.bottom;
154  	int smaller = _isVertical ? rowRect.left : rowRect.top;
155  	int marge = 0;
156  	LONG_PTR style = ::GetWindowLongPtr(_hSelf, GWL_STYLE);
157  	if (rowCount == 1)
158  	{
159  		style &= ~TCS_BUTTONS;
160  	}
161  	else 
162  	{
163  		style |= TCS_BUTTONS;
164  		marge = (rowCount - 2) * 3; 
165  	}
166  	::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
167  	tabsHight = rowCount * (larger - smaller) + marge;
168  	tabsHight += GetSystemMetrics(_isVertical ? SM_CXEDGE : SM_CYEDGE);
169  	if (_isVertical)
170  	{
171  		rc2Ajust.left += tabsHight;
172  		rc2Ajust.right -= tabsHight;
173  	}
174  	else
175  	{
176  		rc2Ajust.top += tabsHight;
177  		rc2Ajust.bottom -= tabsHight;
178  	}
179  }
180  void TabBarPlus::destroy()
181  {
182  	TabBar::destroy();
183  	::DestroyWindow(_tooltips);
184  	_tooltips = NULL;
185  }
186  void TabBarPlus::init(HINSTANCE hInst, HWND parent, bool isVertical, bool isMultiLine)
187  {
188  	Window::init(hInst, parent);
189  	int vertical = isVertical?(TCS_VERTICAL | TCS_MULTILINE | TCS_RIGHTJUSTIFY):0;
190  	_isVertical = isVertical;
191  	_isMultiLine = isMultiLine;
192  	INITCOMMONCONTROLSEX icce{};
193  	icce.dwSize = sizeof(icce);
194  	icce.dwICC = ICC_TAB_CLASSES;
195  	InitCommonControlsEx(&icce);
196  	int multiLine = isMultiLine ? TCS_MULTILINE : 0;
197  	int style = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE | TCS_FOCUSNEVER | TCS_TABS | vertical | multiLine;
198  	style |= TCS_OWNERDRAWFIXED;
199  	_hSelf = ::CreateWindowEx(
200  				0,
201  				WC_TABCONTROL,
202  				TEXT("Tab"),
203  				style,
204  				0, 0, 0, 0,
205  				_hParent,
206  				NULL,
207  				_hInst,
208  				0);
209  	if (!_hSelf)
210  	{
211  		throw std::runtime_error("TabBarPlus::init : CreateWindowEx() function return null");
212  	}
213  	_tooltips = ::CreateWindowEx(
214  		0,
215  		TOOLTIPS_CLASS,
216  		NULL,
217  		TTS_ALWAYSTIP | TTS_NOPREFIX,
218  		0, 0, 0, 0,
219  		_hParent,
220  		NULL,
221  		_hInst,
222  		0);
223  	if (!_tooltips)
224  	{
225  		throw std::runtime_error("TabBarPlus::init : tooltip CreateWindowEx() function return null");
226  	}
227  	NppDarkMode::setDarkTooltips(_tooltips, NppDarkMode::ToolTipsType::tooltip);
228  	::SendMessage(_hSelf, TCM_SETTOOLTIPS, reinterpret_cast<WPARAM>(_tooltips), 0);
229  	if (!_hwndArray[_nbCtrl])
230  	{
231  		_hwndArray[_nbCtrl] = _hSelf;
232  		_ctrlID = _nbCtrl;
233  	}
234  	else
235  	{
236  		int i = 0;
237  		bool found = false;
238  		for ( ; i < nbCtrlMax && !found ; ++i)
239  			if (!_hwndArray[i])
240  				found = true;
241  		if (!found)
242  		{
243  			_ctrlID = -1;
244  			destroy();
245  			throw std::runtime_error("TabBarPlus::init : Tab Control error - Tab Control # is over its limit");
246  		}
247  		_hwndArray[i] = _hSelf;
248  		_ctrlID = i;
249  	}
250  	++_nbCtrl;
251  	::SetWindowLongPtr(_hSelf, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
252  	_tabBarDefaultProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSelf, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(TabBarPlus_Proc)));
253  	auto& dpiManager = NppParameters::getInstance()._dpiManager;
254  	LOGFONT lf{ NppParameters::getDefaultGUIFont() };
255  	LOGFONT lfVer{ lf };
256  	_hFont = ::CreateFontIndirect(&lf);
257  	lf.lfWeight = FW_HEAVY;
258  	lf.lfHeight = -(dpiManager.pointsToPixels(10));
259  	_hLargeFont = ::CreateFontIndirect(&lf);
260  	lfVer.lfEscapement = 900;
261  	lfVer.lfOrientation = 900;
262  	_hVerticalFont = CreateFontIndirect(&lfVer);
263  	lfVer.lfWeight = FW_HEAVY;
264  	_hVerticalLargeFont = CreateFontIndirect(&lfVer);
265  }
266  void TabBarPlus::doOwnerDrawTab()
267  {
268  	::SendMessage(_hwndArray[0], TCM_SETPADDING, 0, MAKELPARAM(6, 0));
269  	for (int i = 0 ; i < _nbCtrl ; ++i)
270  	{
271  		if (_hwndArray[i])
272  		{
273  			LONG_PTR style = ::GetWindowLongPtr(_hwndArray[i], GWL_STYLE);
274  			if (isOwnerDrawTab())
275  				style |= TCS_OWNERDRAWFIXED;
276  			else
277  				style &= ~TCS_OWNERDRAWFIXED;
278  			::SetWindowLongPtr(_hwndArray[i], GWL_STYLE, style);
279  			::InvalidateRect(_hwndArray[i], NULL, TRUE);
280  			const int paddingSizeDynamicW = NppParameters::getInstance()._dpiManager.scaleX(6);
281  			const int paddingSizePlusClosebuttonDynamicW = NppParameters::getInstance()._dpiManager.scaleX(10);
282  			::SendMessage(_hwndArray[i], TCM_SETPADDING, 0, MAKELPARAM(_drawTabCloseButton ? paddingSizePlusClosebuttonDynamicW : paddingSizeDynamicW, 0));
283  		}
284  	}
285  }
286  void TabBarPlus::setColour(COLORREF colour2Set, tabColourIndex i)
287  {
288  	switch (i)
289  	{
290  		case activeText:
291  			_activeTextColour = colour2Set;
292  			break;
293  		case activeFocusedTop:
294  			_activeTopBarFocusedColour = colour2Set;
295  			break;
296  		case activeUnfocusedTop:
297  			_activeTopBarUnfocusedColour = colour2Set;
298  			break;
299  		case inactiveText:
300  			_inactiveTextColour = colour2Set;
301  			break;
302  		case inactiveBg :
303  			_inactiveBgColour = colour2Set;
304  			break;
305  		default :
306  			return;
307  	}
308  	doOwnerDrawTab();
309  }
310  void TabBarPlus::doVertical()
311  {
312  	for (int i = 0 ; i < _nbCtrl ; ++i)
313  	{
314  		if (_hwndArray[i])
315  			SendMessage(_hwndArray[i], WM_TABSETSTYLE, isVertical(), TCS_VERTICAL);
316  	}
317  }
318  void TabBarPlus::doMultiLine()
319  {
320  	for (int i = 0 ; i < _nbCtrl ; ++i)
321  	{
322  		if (_hwndArray[i])
323  			SendMessage(_hwndArray[i], WM_TABSETSTYLE, isMultiLine(), TCS_MULTILINE);
324  	}
325  }
326  void TabBarPlus::notify(int notifyCode, int tabIndex)
327  {
328  	TBHDR nmhdr{};
329  	nmhdr._hdr.hwndFrom = _hSelf;
330  	nmhdr._hdr.code = notifyCode;
331  	nmhdr._hdr.idFrom = reinterpret_cast<UINT_PTR>(this);
332  	nmhdr._tabOrigin = tabIndex;
333  	::SendMessage(_hParent, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(&nmhdr));
334  }
335  void TabBarPlus::trackMouseEvent(DWORD event2check)
336  {
337  	TRACKMOUSEEVENT tme = {};
338  	tme.cbSize = sizeof(tme);
339  	tme.dwFlags = event2check;
340  	tme.hwndTrack = _hSelf;
341  	TrackMouseEvent(&tme);
342  }
343  LRESULT TabBarPlus::runProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
344  {
345  	switch (Message)
346  	{
347  		case WM_TABSETSTYLE:
348  		{
349  			LONG_PTR style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
350  			if (wParam > 0)
351  				style |= lParam;
352  			else
353  				style &= ~lParam;
354  			_isVertical  = ((style & TCS_VERTICAL) != 0);
355  			_isMultiLine = ((style & TCS_MULTILINE) != 0);
356  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
357  			::InvalidateRect(hwnd, NULL, TRUE);
358  			return TRUE;
359  		}
360  		case NPPM_INTERNAL_REFRESHDARKMODE:
361  		{
362  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::tabbar);
363  			return TRUE;
364  		}
365  		case WM_MOUSEWHEEL:
366  		{
367  			if (_isDragging)
368  				return TRUE;
369  			const bool isForward = ((short)HIWORD(wParam)) < 0; 
370  			const int lastTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETITEMCOUNT, 0, 0) - 1);
371  			if ((wParam & MK_CONTROL) && (wParam & MK_SHIFT))
372  			{
373  				setActiveTab((isForward ? lastTabIndex : 0));
374  			}
375  			else if ((wParam & MK_SHIFT) && _doDragNDrop)
376  			{
377  				int oldTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
378  				int newTabIndex = oldTabIndex + (isForward ? 1 : -1);
379  				if (newTabIndex < 0)
380  				{
381  					newTabIndex = lastTabIndex; 
382  				}
383  				else if (newTabIndex > lastTabIndex)
384  				{
385  					newTabIndex = 0; 
386  				}
387  				if (oldTabIndex != newTabIndex)
388  				{
389  					exchangeTabItemData(oldTabIndex, newTabIndex);
390  				}
391  			}
392  			else if (wParam & (MK_CONTROL | MK_SHIFT))
393  			{
394  				int tabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0) + (isForward ? 1 : -1));
395  				if (tabIndex < 0)
396  				{
397  					if (wParam & MK_CONTROL)
398  						tabIndex = lastTabIndex; 
399  					else
400  						return TRUE;
401  				}
402  				else if (tabIndex > lastTabIndex)
403  				{
404  					if (wParam & MK_CONTROL)
405  						tabIndex = 0; 
406  					else
407  						return TRUE;
408  				}
409  				setActiveTab(tabIndex);
410  			}
411  			else if (!_isMultiLine) 
412  			{
413  				RECT rcTabCtrl{}, rcLastTab{};
414  				::SendMessage(_hSelf, TCM_GETITEMRECT, lastTabIndex, reinterpret_cast<LPARAM>(&rcLastTab));
415  				::GetClientRect(_hSelf, &rcTabCtrl);
416  				TC_HITTESTINFO hti{};
417  				LONG xy = NppParameters::getInstance()._dpiManager.scaleX(12); 
418  				hti.pt = { xy, xy };
419  				int scrollTabIndex = static_cast<int32_t>(::SendMessage(_hSelf, TCM_HITTEST, 0, reinterpret_cast<LPARAM>(&hti)));
420  				if (scrollTabIndex < 1 && (_isVertical ? rcLastTab.bottom < rcTabCtrl.bottom : rcLastTab.right < rcTabCtrl.right)) 
421  					return TRUE;
422  				LONG maxLengthUpDownCtrl = NppParameters::getInstance()._dpiManager.scaleX(44); 
423  				if ((_isVertical ? ((rcTabCtrl.bottom - rcLastTab.bottom) < maxLengthUpDownCtrl) : ((rcTabCtrl.right - rcLastTab.right) < maxLengthUpDownCtrl)) || !isForward)
424  				{
425  					if (isForward)
426  						++scrollTabIndex;
427  					else
428  						--scrollTabIndex;
429  					if (scrollTabIndex < 0 || scrollTabIndex > lastTabIndex)
430  						return TRUE;
431  					if (_isCloseHover)
432  					{
433  						_isCloseHover = false;
434  						::InvalidateRect(_hSelf, &_currentHoverTabRect, false);
435  					}
436  					::SendMessage(_hSelf, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, scrollTabIndex), 0);
437  				}
438  			}
439  			return TRUE;
440  		}
441  		case WM_LBUTTONDOWN :
442  		{
443  			if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
444  			{
445  				int nTab = getTabIndexAt(LOWORD(lParam), HIWORD(lParam));
446  				if (nTab != -1 && nTab != static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0)))
447  				{
448  					setActiveTab(nTab);
449  				}
450  			}
451  			if (_drawTabCloseButton)
452  			{
453  				int xPos = LOWORD(lParam);
454  				int yPos = HIWORD(lParam);
455  				if (_closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical))
456  				{
457  					_whichCloseClickDown = getTabIndexAt(xPos, yPos);
458  					::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_REFRESHTABAR, 0);
459  					return TRUE;
460  				}
461  			}
462  			::CallWindowProc(_tabBarDefaultProc, hwnd, Message, wParam, lParam);
463  			int currentTabOn = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
464  			if (wParam == 2)
465  				return TRUE;
466  			if (_doDragNDrop)
467  			{
468  				_mightBeDragging = true;
469  			}
470  			notify(NM_CLICK, currentTabOn);
471  			return TRUE;
472  		}
473  		case WM_RBUTTONDOWN :	
474  		{
475  			if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
476  			{
477  				int nTab = getTabIndexAt(LOWORD(lParam), HIWORD(lParam));
478  				if (nTab != -1 && nTab != static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0)))
479  				{
480  					setActiveTab(nTab);
481  				}
482  			}
483  			::CallWindowProc(_tabBarDefaultProc, hwnd, WM_LBUTTONDOWN, wParam, lParam);
484  			return TRUE;
485  		}
486  		case WM_MOUSEMOVE :
487  		{
488  			if (_mightBeDragging && !_isDragging)
489  			{
490  				if (GetKeyState(VK_LBUTTON) >= 0)
491  				{
492  					_mightBeDragging = false;
493  					_dragCount = 0;
494  				}
495  				else if (++_dragCount > 2)
496  				{
497  					int tabSelected = static_cast<int32_t>(::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
498  					if (tabSelected >= 0)
499  					{
500  						_nSrcTab = _nTabDragged = tabSelected;
501  						_isDragging = true;
502  						if (::GetCapture() != _hSelf)
503  						{
504  							::SetCapture(hwnd);
505  						}
506  					}
507  				}
508  			}
509  			POINT p{};
510  			p.x = LOWORD(lParam);
511  			p.y = HIWORD(lParam);
512  			if (_isDragging)
513  			{
514  				exchangeItemData(p);
515  				::GetCursorPos(&_draggingPoint);
516  				draggingCursor(_draggingPoint);
517  				return TRUE;
518  			}
519  			else
520  			{
521  				bool isFromTabToTab = false;
522  				int iTabNow = getTabIndexAt(p.x, p.y); 
523  				if (_currentHoverTabItem == iTabNow && _currentHoverTabItem != -1) 
524  				{
525  				}
526  				else if (iTabNow == -1 && _currentHoverTabItem != -1) 
527  				{
528  					_currentHoverTabItem = -1;
529  					notify(TCN_MOUSELEAVING, -1);
530  				}
531  				else if (iTabNow != -1 && _currentHoverTabItem == -1) 
532  				{
533  					_currentHoverTabItem = iTabNow;
534  					notify(TCN_MOUSEHOVERING, _currentHoverTabItem);
535  				}
536  				else if (iTabNow != -1 && _currentHoverTabItem != -1 && _currentHoverTabItem != iTabNow) 
537  				{
538  					isFromTabToTab = true;
539  					_whichCloseClickDown = -1;
540  					_currentHoverTabItem = iTabNow;
541  					notify(TCN_MOUSEHOVERSWITCHING, _currentHoverTabItem);
542  				}
543  				else if (iTabNow == -1 && _currentHoverTabItem == -1) 
544  				{
545  				}
546  				if (_drawTabCloseButton)
547  				{
548  					RECT currentHoverTabRectOld = _currentHoverTabRect;
549  					bool isCloseHoverOld = _isCloseHover;
550  					if (_currentHoverTabItem != -1) 
551  					{
552  						::SendMessage(_hSelf, TCM_GETITEMRECT, _currentHoverTabItem, reinterpret_cast<LPARAM>(&_currentHoverTabRect));
553  						_isCloseHover = _closeButtonZone.isHit(p.x, p.y, _currentHoverTabRect, _isVertical);
554  					}
555  					else
556  					{
557  						SetRectEmpty(&_currentHoverTabRect);
558  						_isCloseHover = false;
559  					}
560  					if (isFromTabToTab || _isCloseHover != isCloseHoverOld)
561  					{
562  						if (isCloseHoverOld && (isFromTabToTab || !_isCloseHover))
563  							InvalidateRect(hwnd, &currentHoverTabRectOld, FALSE);
564  						if (_isCloseHover)
565  							InvalidateRect(hwnd, &_currentHoverTabRect, FALSE);
566  					}
567  					if (_isCloseHover)
568  					{
569  						trackMouseEvent(TME_LEAVE);
570  					}
571  				}
572  				trackMouseEvent(TME_LEAVE);
573  			}
574  			break;
575  		}
576  		case WM_MOUSELEAVE:
577  		{
578  			if (_isCloseHover)
579  				InvalidateRect(hwnd, &_currentHoverTabRect, FALSE);
580  			_currentHoverTabItem = -1;
581  			_whichCloseClickDown = -1;
582  			SetRectEmpty(&_currentHoverTabRect);
583  			_isCloseHover = false;
584  			notify(TCN_MOUSELEAVING, _currentHoverTabItem);
585  			break;
586  		}
587  		case WM_LBUTTONUP :
588  		{
589  			_mightBeDragging = false;
590  			_dragCount = 0;
591  			int xPos = LOWORD(lParam);
592  			int yPos = HIWORD(lParam);
593  			int currentTabOn = getTabIndexAt(xPos, yPos);
594  			if (_isDragging)
595  			{
596  				if (::GetCapture() == _hSelf)
597  				{
598  					::ReleaseCapture();
599  				}
600  				else
601  				{
602  					_isDragging = false;
603  				}
604  				notify(_isDraggingInside?TCN_TABDROPPED:TCN_TABDROPPEDOUTSIDE, currentTabOn);
605  				return TRUE;
606  			}
607  			if (_drawTabCloseButton)
608  			{
609  				if ((_whichCloseClickDown == currentTabOn) && _closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical))
610  				{
611  					notify(TCN_TABDELETE, currentTabOn);
612  					_whichCloseClickDown = -1;
613  					int nextTab = getTabIndexAt(xPos, yPos);
614  					if (nextTab != -1)
615  					{
616  						::SendMessage(_hSelf, TCM_GETITEMRECT, nextTab, reinterpret_cast<LPARAM>(&_currentHoverTabRect));
617  						_isCloseHover = _closeButtonZone.isHit(xPos, yPos, _currentHoverTabRect, _isVertical);
618  					}
619  					return TRUE;
620  				}
621  				_whichCloseClickDown = -1;
622  			}
623  			break;
624  		}
625  		case WM_CAPTURECHANGED :
626  		{
627  			if (_isDragging)
628  			{
629  				_isDragging = false;
630  				return TRUE;
631  			}
632  			break;
633  		}
634  		case WM_DRAWITEM :
635  		{
636  			drawItem((DRAWITEMSTRUCT *)lParam);
637  			return TRUE;
638  		}
639  		case WM_KEYDOWN :
640  		{
641  			if (wParam == VK_LCONTROL)
642  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_PLUS_TAB)));
643  			return TRUE;
644  		}
645  		case WM_MBUTTONUP:
646  		{
647  			int xPos = LOWORD(lParam);
648  			int yPos = HIWORD(lParam);
649  			int currentTabOn = getTabIndexAt(xPos, yPos);
650  			notify(TCN_TABDELETE, currentTabOn);
651  			return TRUE;
652  		}
653  		case WM_LBUTTONDBLCLK:
654  		{
655  			if (_isDbClk2Close)
656  			{
657  				int xPos = LOWORD(lParam);
658  				int yPos = HIWORD(lParam);
659  				int currentTabOn = getTabIndexAt(xPos, yPos);
660  				notify(TCN_TABDELETE, currentTabOn);
661  			}
662  			return TRUE;
663  		}
664  		case WM_ERASEBKGND:
665  		{
666  			if (!NppDarkMode::isEnabled())
667  			{
668  				break;
669  			}
670  			RECT rc{};
671  			GetClientRect(hwnd, &rc);
672  			FillRect((HDC)wParam, &rc, NppDarkMode::getDarkerBackgroundBrush());
673  			return 1;
674  		}
675  		case WM_PAINT:
676  		{
677  			if (!NppDarkMode::isEnabled())
678  			{
679  				break;
680  			}
681  			LONG_PTR dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
682  			if (!(dwStyle & TCS_OWNERDRAWFIXED))
683  			{
684  				break;
685  			}
686  			const bool hasMultipleLines = ((dwStyle & TCS_BUTTONS) == TCS_BUTTONS);
687  			PAINTSTRUCT ps{};
688  			HDC hdc = BeginPaint(hwnd, &ps);
689  			FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
690  			UINT id = ::GetDlgCtrlID(hwnd);
691  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
692  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
693  			if (1 != GetClipRgn(hdc, holdClip))
694  			{
695  				DeleteObject(holdClip);
696  				holdClip = nullptr;
697  			}
698  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
699  			int paddingDynamicTwoX = dpiManager.scaleX(2);
700  			int paddingDynamicTwoY = dpiManager.scaleY(2);
701  			int nTabs = TabCtrl_GetItemCount(hwnd);
702  			int nFocusTab = TabCtrl_GetCurFocus(hwnd);
703  			int nSelTab = TabCtrl_GetCurSel(hwnd);
704  			for (int i = 0; i < nTabs; ++i)
705  			{
706  				DRAWITEMSTRUCT dis = { ODT_TAB, id, (UINT)i, ODA_DRAWENTIRE, ODS_DEFAULT, hwnd, hdc, {}, 0 };
707  				TabCtrl_GetItemRect(hwnd, i, &dis.rcItem);
708  				if (i == nFocusTab)
709  				{
710  					dis.itemState |= ODS_FOCUS;
711  				}
712  				if (i == nSelTab)
713  				{
714  					dis.itemState |= ODS_SELECTED;
715  				}
716  				dis.itemState |= ODS_NOFOCUSRECT; 
717  				RECT rcIntersect{};
718  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &dis.rcItem))
719  				{
720  					if (!hasMultipleLines)
721  					{
722  						if (_isVertical)
723  						{
724  							POINT edges[] = {
725  								{dis.rcItem.left, dis.rcItem.bottom - 1},
726  								{dis.rcItem.right, dis.rcItem.bottom - 1}
727  							};
728  							if (i != nSelTab && (i != nSelTab - 1))
729  							{
730  								edges[0].x += paddingDynamicTwoX;
731  							}
732  							::Polyline(hdc, edges, _countof(edges));
733  							dis.rcItem.bottom -= 1;
734  						}
735  						else
736  						{
737  							POINT edges[] = {
738  								{dis.rcItem.right - 1, dis.rcItem.top},
739  								{dis.rcItem.right - 1, dis.rcItem.bottom}
740  							};
741  							if (i != nSelTab && (i != nSelTab - 1))
742  							{
743  								edges[0].y += paddingDynamicTwoY;
744  							}
745  							::Polyline(hdc, edges, _countof(edges));
746  							dis.rcItem.right -= 1;
747  						}
748  					}
749  					HRGN hClip = CreateRectRgnIndirect(&dis.rcItem);
750  					SelectClipRgn(hdc, hClip);
751  					drawItem(&dis, NppDarkMode::isEnabled());
752  					DeleteObject(hClip);
753  					SelectClipRgn(hdc, holdClip);
754  				}
755  			}
756  			if (!hasMultipleLines)
757  			{
758  				RECT rcFirstTab{};
759  				TabCtrl_GetItemRect(hwnd, 0, &rcFirstTab);
760  				if (_isVertical)
761  				{
762  					POINT edges[] = {
763  						{rcFirstTab.left, rcFirstTab.top},
764  						{rcFirstTab.right, rcFirstTab.top}
765  					};
766  					if (nSelTab != 0)
767  					{
768  						edges[0].x += paddingDynamicTwoX;
769  					}
770  					::Polyline(hdc, edges, _countof(edges));
771  				}
772  				else
773  				{
774  					POINT edges[] = {
775  						{rcFirstTab.left, rcFirstTab.top},
776  						{rcFirstTab.left, rcFirstTab.bottom}
777  					};
778  					if (nSelTab != 0)
779  					{
780  						edges[0].y += paddingDynamicTwoY;
781  					}
782  					::Polyline(hdc, edges, _countof(edges));
783  				}
784  			}
785  			SelectClipRgn(hdc, holdClip);
786  			if (holdClip)
787  			{
788  				DeleteObject(holdClip);
789  				holdClip = nullptr;
790  			}
791  			SelectObject(hdc, holdPen);
792  			EndPaint(hwnd, &ps);
793  			return 0;
794  		}
795  		case WM_PARENTNOTIFY:
796  		{
797  			switch (LOWORD(wParam))
798  			{
799  				case WM_CREATE:
800  				{
801  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
802  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
803  					{
804  						return 0;
805  					}
806  					break;
807  				}
808  			}
809  			return 0;
810  		}
811  	}
812  	return ::CallWindowProc(_tabBarDefaultProc, hwnd, Message, wParam, lParam);
813  }
814  void TabBarPlus::drawItem(DRAWITEMSTRUCT *pDrawItemStruct, bool isDarkMode)
815  {
816  	RECT rect = pDrawItemStruct->rcItem;
817  	int nTab = pDrawItemStruct->itemID;
818  	if (nTab < 0)
819  	{
820  		::MessageBox(NULL, TEXT("nTab < 0"), TEXT(""), MB_OK);
821  	}
822  	bool isSelected = (nTab == ::SendMessage(_hSelf, TCM_GETCURSEL, 0, 0));
823  	TCHAR label[MAX_PATH] = { '\0' };
824  	TCITEM tci{};
825  	tci.mask = TCIF_TEXT|TCIF_IMAGE;
826  	tci.pszText = label;
827  	tci.cchTextMax = MAX_PATH-1;
828  	if (!::SendMessage(_hSelf, TCM_GETITEM, nTab, reinterpret_cast<LPARAM>(&tci)))
829  	{
830  		::MessageBox(NULL, TEXT("! TCM_GETITEM"), TEXT(""), MB_OK);
831  	}
832  	const COLORREF colorActiveBg = isDarkMode ? NppDarkMode::getSofterBackgroundColor() : ::GetSysColor(COLOR_BTNFACE);
833  	const COLORREF colorInactiveBgBase = isDarkMode ? NppDarkMode::getBackgroundColor() : ::GetSysColor(COLOR_BTNFACE);
834  	COLORREF colorInactiveBg = liteGrey;
835  	COLORREF colorActiveText = ::GetSysColor(COLOR_BTNTEXT);
836  	COLORREF colorInactiveText = grey;
837  	if (!NppDarkMode::useTabTheme() && isDarkMode)
838  	{
839  		colorInactiveBg = NppDarkMode::getBackgroundColor();
840  		colorActiveText = NppDarkMode::getTextColor();
841  		colorInactiveText = NppDarkMode::getDarkerTextColor();
842  	}
843  	else
844  	{
845  		colorInactiveBg = _inactiveBgColour;
846  		colorActiveText = _activeTextColour;
847  		colorInactiveText = _inactiveTextColour;
848  	}
849  	HDC hDC = pDrawItemStruct->hDC;
850  	int nSavedDC = ::SaveDC(hDC);
851  	::SetBkMode(hDC, TRANSPARENT);
852  	HBRUSH hBrush = ::CreateSolidBrush(colorInactiveBgBase);
853  	::FillRect(hDC, &rect, hBrush);
854  	::DeleteObject((HGDIOBJ)hBrush);
855  	auto& dpiManager = NppParameters::getInstance()._dpiManager;
856  	int paddingDynamicTwoX = dpiManager.scaleX(2);
857  	int paddingDynamicTwoY = dpiManager.scaleY(2);
858  	if (isSelected && !isDarkMode)
859  	{
860  		rect.top += ::GetSystemMetrics(SM_CYEDGE);
861  		rect.bottom -= ::GetSystemMetrics(SM_CYEDGE);
862  		rect.left += ::GetSystemMetrics(SM_CXEDGE);
863  		rect.right -= ::GetSystemMetrics(SM_CXEDGE);
864  		if (_isVertical)
865  		{
866  			rect.left += _drawTopBar ? paddingDynamicTwoX : 0;
867  			rect.right -= _drawTopBar ? 0 : paddingDynamicTwoX;
868  		}
869  		else
870  		{
871  			rect.top += _drawTopBar ? paddingDynamicTwoY : 0;
872  			rect.bottom -= _drawTopBar ? 0 : paddingDynamicTwoY;
873  		}
874  	}
875  	else
876  	{
877  		if (_isVertical)
878  		{
879  			rect.left += paddingDynamicTwoX;
880  			rect.right += paddingDynamicTwoX;
881  			rect.top -= paddingDynamicTwoY;
882  			rect.bottom += paddingDynamicTwoY;
883  		}
884  		else
885  		{
886  			rect.left -= paddingDynamicTwoX;
887  			rect.right += paddingDynamicTwoX;
888  			rect.top += paddingDynamicTwoY;
889  			rect.bottom += paddingDynamicTwoY;
890  		}
891  	}
892  	const bool hasMultipleLines = ((::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS) == TCS_BUTTONS);
893  	if (hasMultipleLines)
894  	{
895  		if (_isVertical)
896  		{
897  			rect.left -= paddingDynamicTwoX;
898  		}
899  		else
900  		{
901  			rect.top -= paddingDynamicTwoY;
902  		}
903  	}
904  	const int individualColourId = getIndividualTabColour(nTab);
905  	RECT barRect = rect;
906  	if (isSelected)
907  	{
908  		hBrush = ::CreateSolidBrush(colorActiveBg);
909  		::FillRect(hDC, &pDrawItemStruct->rcItem, hBrush);
910  		::DeleteObject(static_cast<HGDIOBJ>(hBrush));
911  		if (_drawTopBar)
912  		{
913  			int topBarHeight = dpiManager.scaleX(4);
914  			if (_isVertical)
915  			{
916  				barRect.left -= (hasMultipleLines && isDarkMode) ? 0 : paddingDynamicTwoX;
917  				barRect.right = barRect.left + topBarHeight;
918  			}
919  			else
920  			{
921  				barRect.top -= (hasMultipleLines && isDarkMode) ? 0 : paddingDynamicTwoY;
922  				barRect.bottom = barRect.top + topBarHeight;
923  			}
924  			if (::SendMessage(_hParent, NPPM_INTERNAL_ISFOCUSEDTAB, 0, reinterpret_cast<LPARAM>(_hSelf)))
925  			{
926  				COLORREF topBarColour = _activeTopBarFocusedColour; 
927  				if (individualColourId != -1)
928  				{
929  					topBarColour = NppDarkMode::getIndividualTabColour(individualColourId, isDarkMode, true);
930  				}
931  				hBrush = ::CreateSolidBrush(topBarColour);
932  			}
933  			else
934  				hBrush = ::CreateSolidBrush(_activeTopBarUnfocusedColour); 
935  			::FillRect(hDC, &barRect, hBrush);
936  			::DeleteObject((HGDIOBJ)hBrush);
937  		}
938  	}
939  	else 
940  	{
941  		RECT rect = hasMultipleLines ? pDrawItemStruct->rcItem : barRect;
942  		COLORREF brushColour{};
943  		if (_drawInactiveTab && individualColourId == -1)
944  		{
945  			brushColour = colorInactiveBg;
946  		}
947  		else if (individualColourId != -1)
948  		{
949  			brushColour = NppDarkMode::getIndividualTabColour(individualColourId, isDarkMode, false);
950  		}
951  		else
952  		{
953  			brushColour = colorActiveBg;
954  		}
955  		hBrush = ::CreateSolidBrush(brushColour);
956  		::FillRect(hDC, &rect, hBrush);
957  		::DeleteObject((HGDIOBJ)hBrush);
958  	}
959  	if (isDarkMode && hasMultipleLines)
960  	{
961  		::FrameRect(hDC, &pDrawItemStruct->rcItem, NppDarkMode::getEdgeBrush());
962  	}
963  	if (_drawTabCloseButton)
964  	{
965  		int idCloseImg;
966  		if (_isCloseHover && (_currentHoverTabItem == nTab) && (_whichCloseClickDown == -1)) 
967  			idCloseImg = isDarkMode ? IDR_CLOSETAB_HOVER_DM : IDR_CLOSETAB_HOVER;
968  		else if (_isCloseHover && (_currentHoverTabItem == nTab) && (_whichCloseClickDown == _currentHoverTabItem)) 
969  			idCloseImg = isDarkMode ? IDR_CLOSETAB_PUSH_DM : IDR_CLOSETAB_PUSH;
970  		else
971  			idCloseImg = isSelected ? (isDarkMode ? IDR_CLOSETAB_DM : IDR_CLOSETAB) : (isDarkMode ? IDR_CLOSETAB_INACT_DM : IDR_CLOSETAB_INACT);
972  		HDC hdcMemory = ::CreateCompatibleDC(hDC);
973  		HBITMAP hBmp = ::LoadBitmap(_hInst, MAKEINTRESOURCE(idCloseImg));
974  		BITMAP bmp{};
975  		::GetObject(hBmp, sizeof(bmp), &bmp);
976  		_closeButtonZone._width = dpiManager.scaleX(bmp.bmWidth);
977  		_closeButtonZone._height = dpiManager.scaleY(bmp.bmHeight);
978  		RECT buttonRect = _closeButtonZone.getButtonRectFrom(rect, _isVertical);
979  		const bool isRTL = (::GetWindowLongPtr(::GetParent(_hSelf), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
980  		const int offset = isRTL && (_closeButtonZone._width == bmp.bmWidth) ? -1 : 0;
981  		::SelectObject(hdcMemory, hBmp);
982  		::StretchBlt(hDC, buttonRect.left + offset, buttonRect.top, _closeButtonZone._width, _closeButtonZone._height, hdcMemory, offset, 0, bmp.bmWidth, bmp.bmHeight, SRCCOPY);
983  		::DeleteDC(hdcMemory);
984  		::DeleteObject(hBmp);
985  	}
986  	HIMAGELIST hImgLst = (HIMAGELIST)::SendMessage(_hSelf, TCM_GETIMAGELIST, 0, 0);
987  	if (hImgLst && tci.iImage >= 0)
988  	{
989  		IMAGEINFO info{};
990  		ImageList_GetImageInfo(hImgLst, tci.iImage, &info);
991  		RECT& imageRect = info.rcImage;
992  		int fromBorder;
993  		int xPos, yPos;
994  		if (_isVertical)
995  		{
996  			fromBorder = (rect.right - rect.left - (imageRect.right - imageRect.left) + 1) / 2;
997  			xPos = rect.left + fromBorder;
998  			yPos = rect.bottom - fromBorder - (imageRect.bottom - imageRect.top);
999  			rect.bottom -= fromBorder + (imageRect.bottom - imageRect.top);
1000  		}
1001  		else
1002  		{
1003  			fromBorder = (rect.bottom - rect.top - (imageRect.bottom - imageRect.top) + 1) / 2;
1004  			yPos = rect.top + fromBorder;
1005  			xPos = rect.left + fromBorder;
1006  			rect.left += fromBorder + (imageRect.right - imageRect.left);
1007  		}
1008  		ImageList_Draw(hImgLst, tci.iImage, hDC, xPos, yPos, isSelected ? ILD_TRANSPARENT : ILD_SELECTED);
1009  	}
1010  	bool isStandardSize = (::SendMessage(_hParent, NPPM_INTERNAL_ISTABBARREDUCED, 0, 0) == TRUE);
1011  	if (isStandardSize)
1012  	{
1013  		if (_isVertical)
1014  			SelectObject(hDC, _hVerticalFont);
1015  		else
1016  			SelectObject(hDC, _hFont);
1017  	}
1018  	else
1019  	{
1020  		if (_isVertical)
1021  			SelectObject(hDC, _hVerticalLargeFont);
1022  		else
1023  			SelectObject(hDC, _hLargeFont);
1024  	}
1025  	SIZE charPixel{};
1026  	::GetTextExtentPoint(hDC, TEXT(" "), 1, &charPixel);
1027  	int spaceUnit = charPixel.cx;
1028  	TEXTMETRIC textMetrics{};
1029  	GetTextMetrics(hDC, &textMetrics);
1030  	int textHeight = textMetrics.tmHeight;
1031  	int textDescent = textMetrics.tmDescent;
1032  	int Flags = DT_SINGLELINE | DT_NOPREFIX;
1033  	TCHAR decodedLabel[MAX_PATH] = { '\0' };
1034  	const TCHAR* in = label;
1035  	TCHAR* out = decodedLabel;
1036  	while (*in != 0)
1037  		if (*in == '&')
1038  			while (*(++in) == '&')
1039  				*out++ = *in;
1040  		else
1041  			*out++ = *in++;
1042  	*out = '\0';
1043  	if (_isVertical)
1044  	{
1045  		Flags |= DT_LEFT;
1046  		Flags |= DT_BOTTOM;
1047  		rect.left += (rect.right - rect.left - textHeight) / 2;
1048  		rect.bottom += textHeight;
1049  		rect.left += textDescent / 2;
1050  		rect.right += textDescent / 2;
1051  		rect.bottom -= spaceUnit;
1052  	}
1053  	else
1054  	{
1055  		Flags |= DT_LEFT;
1056  		Flags |= DT_TOP;
1057  		const int paddingText = ((pDrawItemStruct->rcItem.bottom - pDrawItemStruct->rcItem.top) - (textHeight + textDescent)) / 2;
1058  		const int paddingDescent = !hasMultipleLines ? ((textDescent + ((isDarkMode || !isSelected) ? 1 : 0)) / 2) : 0;
1059  		rect.top = pDrawItemStruct->rcItem.top + paddingText + paddingDescent;
1060  		rect.bottom = pDrawItemStruct->rcItem.bottom - paddingText + paddingDescent;
1061  		if (isDarkMode || !isSelected || _drawTopBar)
1062  		{
1063  			rect.top += paddingDynamicTwoY;
1064  		}
1065  		rect.left += spaceUnit;
1066  	}
1067  	COLORREF textColor = isSelected ? colorActiveText : colorInactiveText;
1068  	::SetTextColor(hDC, textColor);
1069  	::DrawText(hDC, decodedLabel, lstrlen(decodedLabel), &rect, Flags);
1070  	::RestoreDC(hDC, nSavedDC);
1071  }
1072  void TabBarPlus::draggingCursor(POINT screenPoint)
1073  {
1074  	HWND hWin = ::WindowFromPoint(screenPoint);
1075  	if (_hSelf == hWin)
1076  		::SetCursor(::LoadCursor(NULL, IDC_ARROW));
1077  	else
1078  	{
1079  		TCHAR className[256] = { '\0' };
1080  		::GetClassName(hWin, className, 256);
1081  		if ((!lstrcmp(className, TEXT("Scintilla"))) || (!lstrcmp(className, WC_TABCONTROL)))
1082  		{
1083  			if (::GetKeyState(VK_LCONTROL) & 0x80000000)
1084  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_PLUS_TAB)));
1085  			else
1086  				::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_TAB)));
1087  		}
1088  		else if (isPointInParentZone(screenPoint))
1089  			::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_INTERDIT_TAB)));
1090  		else 
1091  			::SetCursor(::LoadCursor(_hInst, MAKEINTRESOURCE(IDC_DRAG_OUT_TAB)));
1092  	}
1093  }
1094  void TabBarPlus::setActiveTab(int tabIndex)
1095  {
1096  	if (::GetWindowLongPtr(_hSelf, GWL_STYLE) & TCS_BUTTONS)
1097  	{
1098  		::SendMessage(_hSelf, TCM_SETCURFOCUS, tabIndex, 0);
1099  	}
1100  	::SendMessage(_hSelf, TCM_SETCURSEL, tabIndex, 0);
1101  	notify(TCN_SELCHANGE, tabIndex);
1102  }
1103  void TabBarPlus::exchangeTabItemData(int oldTab, int newTab)
1104  {
1105  	TCITEM itemData_nDraggedTab{}, itemData_shift{};
1106  	itemData_nDraggedTab.mask = itemData_shift.mask = TCIF_IMAGE | TCIF_TEXT | TCIF_PARAM;
1107  	const int stringSize = 256;
1108  	TCHAR str1[stringSize] = { '\0' };
1109  	TCHAR str2[stringSize] = { '\0' };
1110  	itemData_nDraggedTab.pszText = str1;
1111  	itemData_nDraggedTab.cchTextMax = (stringSize);
<span onclick='openModal()' class='match'>1112  	itemData_shift.pszText = str2;
1113  	itemData_shift.cchTextMax = (stringSize);
1114  	::SendMessage(_hSelf, TCM_GETITEM, oldTab, reinterpret_cast<LPARAM>(&itemData_nDraggedTab));
1115  	if (oldTab > newTab)
1116  	{
1117  		for (int i = oldTab; i > newTab; i--)
1118  		{
</span>1119  			::SendMessage(_hSelf, TCM_GETITEM, i - 1, reinterpret_cast<LPARAM>(&itemData_shift));
1120  			::SendMessage(_hSelf, TCM_SETITEM, i, reinterpret_cast<LPARAM>(&itemData_shift));
1121  		}
1122  	}
1123  	else
1124  	{
1125  		for (int i = oldTab; i < newTab; ++i)
1126  		{
1127  			::SendMessage(_hSelf, TCM_GETITEM, i + 1, reinterpret_cast<LPARAM>(&itemData_shift));
1128  			::SendMessage(_hSelf, TCM_SETITEM, i, reinterpret_cast<LPARAM>(&itemData_shift));
1129  		}
1130  	}
1131  	::SendMessage(_hSelf, TCM_SETITEM, newTab, reinterpret_cast<LPARAM>(&itemData_nDraggedTab));
1132  	::SendMessage(_hParent, NPPM_INTERNAL_DOCORDERCHANGED, 0, oldTab);
1133  	setActiveTab(newTab);
1134  }
1135  void TabBarPlus::exchangeItemData(POINT point)
1136  {
1137  	int nTab = getTabIndexAt(point);
1138  	if (nTab != -1)
1139  	{
1140  		_isDraggingInside = true;
1141  		if (nTab != _nTabDragged)
1142  		{
1143  			if (_previousTabSwapped == nTab)
1144  			{
1145  				return;
1146  			}
1147  			exchangeTabItemData(_nTabDragged, nTab);
1148  			_previousTabSwapped = _nTabDragged;
1149  			_nTabDragged = nTab;
1150  		}
1151  		else
1152  		{
1153  			_previousTabSwapped = -1;
1154  		}
1155  	}
1156  	else
1157  	{
1158  		_previousTabSwapped = -1;
1159  		_isDraggingInside = false;
1160  	}
1161  }
1162  CloseButtonZone::CloseButtonZone()
1163  {
1164  	_width = NppParameters::getInstance()._dpiManager.scaleX(g_TabCloseBtnSize);
1165  	_height = _width;
1166  }
1167  bool CloseButtonZone::isHit(int x, int y, const RECT & tabRect, bool isVertical) const
1168  {
1169  	RECT buttonRect = getButtonRectFrom(tabRect, isVertical);
1170  	if (x >= buttonRect.left && x <= buttonRect.right && y >= buttonRect.top && y <= buttonRect.bottom)
1171  		return true;
1172  	return false;
1173  }
1174  RECT CloseButtonZone::getButtonRectFrom(const RECT & tabRect, bool isVertical) const
1175  {
1176  	RECT buttonRect{};
1177  	int fromBorder = 0;
1178  	if (isVertical)
1179  	{
1180  		fromBorder = (tabRect.right - tabRect.left - _width + 1) / 2;
1181  		buttonRect.left = tabRect.left + fromBorder;
1182  	}
1183  	else
1184  	{
1185  		fromBorder = (tabRect.bottom - tabRect.top - _height + 1) / 2;
1186  		buttonRect.left = tabRect.right - fromBorder - _width;
1187  	}
1188  	buttonRect.top = tabRect.top + fromBorder;
1189  	buttonRect.bottom = buttonRect.top + _height;
1190  	buttonRect.right = buttonRect.left + _width;
1191  	return buttonRect;
1192  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bignet.h</h3>
            <pre><code>1  template <class TNodeData, bool IsDir>
2  class TBigNet {
3  public:
4    typedef TNodeData TNodeDat;
5    typedef TBigNet<TNodeData, IsDir> TNet;
6    typedef TPt<TNet> PNet;
7  public:
8    class TNode;
9    typedef THash<TInt, TNode> TNodeH; 
10    typedef TPt<TBigNet<TNodeData, IsDir> > PBigNet;
11    typedef TVecPool<TInt> TVPool;
12    typedef TPt<TVPool> PVPool;
13    class TNode {
14    public:
15      TInt InVId;
16      TInt OutVId; 
17      TNodeDat Dat;
18    public:
19      TNode() : InVId(-1), OutVId(-1), Dat() { }
20      TNode(const int& InVecId, const int& OutVecId) : InVId(InVecId), OutVId(OutVecId), Dat() { }
21      TNode(const int& InVecId, const int& OutVecId, const TNodeDat& NodeDat) :
22        InVId(InVecId), OutVId(OutVecId), Dat(NodeDat) { }
23      TNode(const TNode& Node) : InVId(Node.InVId), OutVId(Node.OutVId), Dat(Node.Dat) { }
24      TNode(TSIn& SIn) : InVId(SIn), OutVId(SIn), Dat(SIn) { }
25      void Save(TSOut& SOut) const { SOut.Save(InVId); SOut.Save(OutVId); Dat.Save(SOut); }
26      bool IsUnused() const { return InVId==-1 && OutVId==-1; }
27    };
28    class TNodeI {
29    protected:
30      typedef typename TNodeH::TIter THashIter;
31      THashIter NodeHI;
32      TVPool *Pool;
33      int InDeg, OutDeg, *InNIdV, *OutNIdV; 
34    public:
35      inline void GetInOutNIdV();
36      int GetInVId() const { return NodeHI->Dat.InVId; }
37      int GetOutVId() const { return NodeHI->Dat.OutVId; }
38    public:
39      TNodeI() : NodeHI(), Pool(NULL), InDeg(0), OutDeg(0), InNIdV(NULL), OutNIdV(NULL) { }
40      TNodeI(const THashIter& NodeHIter, TVPool *PoolPt) : NodeHI(NodeHIter), Pool(PoolPt) { GetInOutNIdV(); }
41      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Pool(NodeI.Pool) { GetInOutNIdV(); }
42      TNodeI& operator = (const TNodeI& NI) { NodeHI=NI.NodeHI; Pool=NI.Pool; GetInOutNIdV(); return *this; }
43      TNodeI& operator++ (int) { NodeHI++; GetInOutNIdV(); return *this; }
44      bool operator < (const TNodeI& NI) const { return NodeHI < NI.NodeHI; }
45      bool operator == (const TNodeI& NI) const { return NodeHI == NI.NodeHI; }
46      int GetId() const { return NodeHI->Key(); }
47      int GetDeg() const { return GetInDeg()+(InNIdV!=OutNIdV?GetOutDeg():0); }
48      int GetInDeg() const { return InDeg; }
49      int GetOutDeg() const { return OutDeg; }
50      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
51      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
52      int GetOutNbrId(const int& NodeN) const { return NodeN<OutDeg ? OutNIdV[NodeN]:InNIdV[NodeN-OutDeg]; }
53      bool IsInNId(const int& NId) const { return BinSearch(InNIdV, InNIdV+InDeg, NId)!=NULL; }
54      bool IsOutNId(const int& NId) const { return BinSearch(OutNIdV, OutNIdV+OutDeg, NId)!=NULL; }
55      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
56      const TNodeData& operator () () const { return GetDat(); }
57      TNodeData& operator () () { return GetDat(); }
58      const TNodeData& GetDat() const { return NodeHI->Dat.Dat; }
59      TNodeData& GetDat() { return NodeHI->Dat.Dat; }
60      void Dump() const;
61      friend class TBigNet<TNodeData, IsDir>;
62    };
63    class TEdgeI {
64    private:
65      TNodeI CurNode, EndNode;
66      int CurEdge;
67    public:
68      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
69      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(0) { }
70      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
71      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode;  EndNode=EdgeI.EndNode;  CurEdge=EdgeI.CurEdge; }  return *this; }
72      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0;  CurNode++;
73        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
74      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
75      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
76      int GetId() const { return -1; }
77      int GetSrcNId() const { return CurNode.GetId(); }
78      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
79      const TNodeData& GetSrcNDat() const { return CurNode.GetNDat(); }
80      TNodeData& GetDstNDat() { return CurNode.GetOutNDat(CurEdge); }
81      friend class TNodeNet<TNodeData>;
82    };
83  protected:
84    bool IsNode(const int& NId, TNode& Node) const { return NodeH.IsKeyGetDat(NId, Node); }
85    int* GetInNIdVPt(const int& NId) const { return (int *) Pool.GetValVPt(GetNode(NId).InVId); }
86    int* GetOutNIdVPt(const int& NId) const { return (int *) Pool.GetValVPt(GetNode(NId).OutVId); }
87    static void AddSorted(int* Beg, int* End, const int& Val);
88    static const int* BinSearch(const int* Beg, const int* End, const int& Val);
89    static const int* BinSearch2(const int* Beg, const int* End, const int& Val);
90    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
91    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
92  public:
93    enum { DelNId = INT_MAX }; 
94  protected:
95    TCRef CRef;
96    TInt MxNId;
97    TB32Set Flags;
98    TVPool Pool;
99    TNodeH NodeH;
100  public:
101    TBigNet(const int& Nodes, const TSize& Edges, const bool& Sources=false);
102    TBigNet(TSIn& SIn) : MxNId(SIn), Flags(SIn), Pool(SIn), NodeH(SIn) { TBool Dir(SIn); IAssert(Dir()==IsDir); }
103    virtual ~TBigNet() { }
104    virtual void Save(TSOut& SOut) const;
105    static PBigNet New(const int& Nodes, const TSize& Edges, const bool& Sources=false) {
106      return PBigNet(new TBigNet(Nodes, Edges, Sources)); }
107    static PBigNet Load(TSIn& SIn) { return PBigNet(new TBigNet(SIn)); }
108    TBigNet& operator = (const TBigNet& Net) { if (this!=&Net) {
109      MxNId=Net.MxNId; Flags=Net.Flags; Pool=Net.Pool; NodeH=Net.NodeH; }  return *this; }
110    bool OnlySources() const { return Flags.In(gfSources); }
111    bool HasFlag(const TGraphFlag& Flag) const {
112      return HasGraphFlag(typename TBigNet, Flag) || (Flag==gfSources && OnlySources()); }
113    void DumpFlags() const;
114    int GetNodes() const { return NodeH.Len(); }
115    int GetMxNId() const { return MxNId; }
116    int AddNode(int NId, const int& InDeg, const int& OutDeg);
117    int AddNode(int NId, const int& InDeg, const int& OutDeg, const TNodeDat& NodeDat);
118    int AddNode(int NId, const TIntV& InNIdV, const TIntV& OutNIdV);
119    int AddNode(int NId, const TIntV& InNIdV, const TIntV& OutNIdV, const TNodeDat& NodeDat);
120    int AddUndirNode(int NId, const int& Deg);
121    int AddUndirNode(int NId, const int& Deg, const TNodeDat& NodeDat);
122    int AddUndirNode(int NId, const TIntV& EdgeNIdV);
123    int AddUndirNode(int NId, const TIntV& EdgeNIdV, const TNodeDat& NodeDat);
124    void SetInNIdV(int NId, const TIntV& InNIdV);
125    void SetOutNIdV(int NId, const TIntV& OutNIdV);
126    void GetInNIdV(int NId, TIntV& OutNIdV) const;
127    void GetOutNIdV(int NId, TIntV& OutNIdV) const;
128    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
129    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), (TVPool *)&Pool); }
130    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), (TVPool *)&Pool); }
131    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), (TVPool *)&Pool); }
132    TNodeDat& GetNDat(const int& NId) { return NodeH.GetDat(NId).Dat; }
133    const TNodeDat& GetNDat(const int& NId) const { return NodeH.GetDat(NId).Dat; }
134    TEdgeI BegEI() const { TNodeI NI=BegNI();  while(NI<EndNI() && NI.GetOutDeg()==0) NI++;  return TEdgeI(NI, EndNI()); }
135    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
136    TEdgeI GetEI(const int& EId) const; 
137    int IsolateNode(int NId); 
138    int DelNode(int NId); 
139    bool IsIsoNode(const int& NId) const;
140    uint GetDelEdges(); 
141    void CompactEdgePool(); 
142    ::TSize GetEdges() const { return Pool.GetVals(); }
143    int AddEdge(const int& SrcNId, const int& DstNId);
144    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& Dir=true) const;
145    void SortEdgeV();
146    void InvertFromSources(uint ExpectNodes=0); 
147    void Rewire(TRnd& Rnd = TInt::Rnd); 
148    PNGraph GetNGraph(const bool& RenumberNodes=false) const;
149    PNGraph GetSubNGraph(const TIntV& NIdV) const;
150    PBigNet GetSubGraph(const TIntV& NIdV, const bool& RenumberNodes=false) const;
151    void GetSubGraph(const TIntV& NIdV, TBigNet* NewNet, const bool& RenumberNodes=false) const;
152    int GetRndNId(TRnd& Rnd=TInt::Rnd) const { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd)); }
153    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) const { return GetNI(GetRndNId(Rnd)); }
154    void GetNIdV(TIntV& NIdV) const;
155    bool Empty() const { return GetNodes()==0; }
156    void Clr(const bool& DoDel = true) { MxNId = 0;  NodeH.Clr(DoDel); Pool.Clr(DoDel); }
157    void Reserve(const int& Nodes, const TSize& Edges);
158    void Defrag(const bool& OnlyNodeLinks = false) { }
159    bool IsOk() const;
160    void Dump(const TStr& Desc = TStr()) const;
161    void SaveForDisk(const TStr& OutFNm) const;
162    static void LoadNodeDatH(const TStr& InFNm, TNodeH& NodeH);
163    static void SaveToDisk(const TStr& InFNm, const TStr& OutFNm, const bool& SaveSparseHash);
164    friend class TPt<TBigNet>;
165  };
166  namespace TSnap {
167  template <class TNodeData, bool IsDir> struct IsDirected<TBigNet<TNodeData, IsDir> > { enum { Val = 0 }; };
168  template <class TNodeData> struct IsDirected<TBigNet<TNodeData, true> > { enum { Val = 1 }; };
169  template <class TNodeData, bool IsDir> struct IsNodeDat<TBigNet<TNodeData, IsDir> > { enum { Val = 1 }; };
170  }
171  template <class TNodeData, bool IsDir>
172  inline void TBigNet<TNodeData, IsDir>::TNodeI::GetInOutNIdV() {
173    if (NodeHI.IsEnd()) return;
174    const TNode& N = NodeHI->Dat;
175    if (! Pool->IsVId(N.InVId)) {
176      InDeg=0; OutDeg=0; }
177    else {
178      InDeg=Pool->GetVLen(N.InVId);
179      OutDeg=Pool->GetVLen(N.OutVId);
180      InNIdV=(int *)Pool->GetValVPt(N.InVId);
181      OutNIdV=(int *)Pool->GetValVPt(N.OutVId);
182    }
183  }
184  template <class TNodeData, bool IsDir>
185  void TBigNet<TNodeData, IsDir>::TNodeI::Dump() const {
186    printf("NodeId: %d\n", GetId());
187    printf("  I:%4d]", GetInDeg());
188    for (int i = 0; i < GetInDeg(); i++) { printf("  %d", GetInNId(i)); }
189    printf("\n  O:%4d]", GetOutDeg());
190    for (int i = 0; i < GetOutDeg(); i++) { printf("  %d", GetOutNId(i)); }
191    printf("\n");
192  }
193  template <class TNodeData, bool IsDir>
194  void TBigNet<TNodeData, IsDir>::AddSorted(int* Beg, int* End, const int& Val) {
195    IAssertR(*(End-1)==TInt::Mx, "Edge can not be added: no free space");
196    int Half, Len = int(End-Beg);
197    while (Len > 0) {
198      Half = Len/2;
199      int* Mid=Beg+Half;
200      if (*Mid < Val) { Beg=Mid+1; Len=Len-Half-1; } else { Len=Half; } }
201    IAssertR(*Beg != Val, "Value already existis");
202    memmove(Beg+1, Beg, sizeof(int)*(End-Beg-1));
203    *Beg = Val;
204  }
205  template <class TNodeData, bool IsDir>
206  const int* TBigNet<TNodeData, IsDir>::BinSearch(const int* Beg, const int* End, const int& Val) {
207    End--;  const int *Mid;
208    while (Beg <= End) { Mid = Beg+(End-Beg)/2;
209      if (*Mid == Val) { return Mid; }
210      else if (Val < *Mid) { End=Mid-1; } else { Beg=Mid+1; }
211    }
212    return NULL;
213  }
214  template <class TNodeData, bool IsDir>
215  const int* TBigNet<TNodeData, IsDir>::BinSearch2(const int* Beg, const int* End, const int& Val) {
216    const int* First = Beg;
217    const int* Last = End;
218    const int* Mid;
219    TSize len = End-Beg, half;
220    while (len > 0) {
221      half = len>>1;  Mid=First+half;
222      if (*Mid < Val) { First = Mid; First++; len=len-half-1; }
223      else { len=half; }
224    }
225    return First==Last ? Last-1 : First;
226  }
227  template <class TNodeData, bool IsDir>
228  TBigNet<TNodeData, IsDir>::TBigNet(const int& Nodes, const TSize& Edges, const bool& Sources) :
229  CRef(), MxNId(0), Flags(), Pool(IsDir ? 2*Edges:Edges, 10000000, true, TInt::Mx), NodeH(Nodes) {
230    if (Sources) {
231      Flags.Incl(gfSources);
232      IAssertR(! IsDir, "Jure: not clear what happens is graph is Undirected and has only sources.");
233    }
234  }
235  template <class TNodeData, bool IsDir>
236  void TBigNet<TNodeData, IsDir>::Save(TSOut& SOut) const {
237    MxNId.Save(SOut);
238    Flags.Save(SOut);
239    Pool.Save(SOut);
240    NodeH.Save(SOut);
241    TBool(IsDir).Save(SOut);
242  }
243  template <class TNodeData, bool IsDir>
244  void TBigNet<TNodeData, IsDir>::DumpFlags() const {
245    for (int i = 1; i <int(gfMx); i++) {
246      if (HasFlag(TGraphFlag(i))) { printf("  +"); }
247      else { printf("  -"); }
248      printf("%s", TSnap::GetFlagStr(TGraphFlag(i)).CStr());
249    }
250    printf("\n");
251  }
252  template <class TNodeData, bool IsDir>
253  int TBigNet<TNodeData, IsDir>::AddNode(int NId, const int& InDeg, const int& OutDeg) {
254    CAssert(IsDir);
255    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
256    else { MxNId = TMath::Mx(NId+1, MxNId()); }
257    TNode& Node = NodeH.AddDat(NId);
258    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
259    Node.InVId = Pool.AddEmptyV(InDeg);
260    Node.OutVId = Pool.AddEmptyV(OutDeg);
261    return NId;
262  }
263  template <class TNodeData, bool IsDir>
264  int TBigNet<TNodeData, IsDir>::AddNode(int NId, const int& InDeg, const int& OutDeg, const TNodeData& NodeDat) {
265    CAssert(IsDir);
266    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
267    else { MxNId = TMath::Mx(NId+1, MxNId()); }
268    TNode& Node = NodeH.AddDat(NId);
269    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
270    Node.InVId = Pool.AddEmptyV(InDeg);
271    Node.OutVId = Pool.AddEmptyV(OutDeg);
272    Node.Dat = NodeDat;
273    return NId;
274  }
275  template <class TNodeData, bool IsDir>
276  int TBigNet<TNodeData, IsDir>::AddUndirNode(int NId, const int& Deg) {
277    CAssert(! IsDir);
278    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
279    else { MxNId = TMath::Mx(NId+1, MxNId()); }
280    TNode& Node = NodeH.AddDat(NId);
281    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
282    Node.InVId = Pool.AddEmptyV(Deg);
283    Node.OutVId = Node.InVId; 
284    return NId;
285  }
286  template <class TNodeData, bool IsDir>
287  int TBigNet<TNodeData, IsDir>::AddUndirNode(int NId, const int& Deg, const TNodeData& NodeDat) {
288    CAssert(! IsDir);
289    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
290    else { MxNId = TMath::Mx(NId+1, MxNId()); }
291    TNode& Node = NodeH.AddDat(NId);
292    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
293    Node.InVId = Pool.AddEmptyV(Deg);
294    Node.OutVId = Node.InVId; 
295    Node.Dat = NodeDat;
296    return NId;
297  }
298  template <class TNodeData, bool IsDir>
299  int TBigNet<TNodeData, IsDir>::AddNode(int NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
300    CAssert(IsDir);
301    IAssert(InNIdV.IsSorted() && OutNIdV.IsSorted());
302    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
303    else { MxNId = TMath::Mx(NId+1, MxNId()); }
304    TNode& Node = NodeH.AddDat(NId);
305    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
306    Node.InVId = Pool.AddV(InNIdV);
307    Node.OutVId = Pool.AddV(OutNIdV);
308    return NId;
309  }
310  template <class TNodeData, bool IsDir>
311  int TBigNet<TNodeData, IsDir>::AddNode(int NId, const TIntV& InNIdV, const TIntV& OutNIdV, const TNodeData& NodeDat) {
312    CAssert(IsDir);
313    IAssert(InNIdV.IsSorted() && OutNIdV.IsSorted());
314    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
315    else { MxNId = TMath::Mx(NId+1, MxNId()); }
316    TNode& Node = NodeH.AddDat(NId);
317    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
318    Node.InVId = Pool.AddV(InNIdV);
319    Node.OutVId = Pool.AddV(OutNIdV);
320    Node.Dat = NodeDat;
321    return NId;
322  }
323  template <class TNodeData, bool IsDir>
324  int TBigNet<TNodeData, IsDir>::AddUndirNode(int NId, const TIntV& EdgeNIdV) {
325    CAssert(! IsDir);
326    IAssert(EdgeNIdV.IsSorted());
327    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
328    else { MxNId = TMath::Mx(NId+1, MxNId()); }
329    TNode& Node = NodeH.AddDat(NId);
330    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
331    Node.InVId = Pool.AddV(EdgeNIdV);
332    Node.OutVId = Node.InVId;
333    return NId;
334  }
335  template <class TNodeData, bool IsDir>
336  int TBigNet<TNodeData, IsDir>::AddUndirNode(int NId, const TIntV& EdgeNIdV, const TNodeData& NodeDat) {
337    CAssert(! IsDir);
338    IAssert(EdgeNIdV.IsSorted());
339    if (NId == -1) { NId = MxNId;  MxNId.Val++; }
340    else { MxNId = TMath::Mx(NId+1, MxNId()); }
341    TNode& Node = NodeH.AddDat(NId);
342    IAssertR(Node.IsUnused(), TStr::Fmt("NodeId %d already exists", NId));
343    Node.InVId = Pool.AddV(EdgeNIdV);
344    Node.OutVId = Node.InVId;
345    Node.Dat = NodeDat;
346    return NId;
347  }
348  template <class TNodeData, bool IsDir>
349  void TBigNet<TNodeData, IsDir>::SetInNIdV(int NId, const TIntV& InNIdV) {
350    TNode Node;  EAssert(IsNode(NId, Node));
351    TIntV InNodesV;  Pool.GetV(Node.InVId, InNodesV);
352    EAssert(InNIdV.Len() == InNodesV.Len());
353    memcpy(InNodesV.BegI(), InNIdV.BegI(), sizeof(TInt)*InNIdV.Len());
354  }
355  template <class TNodeData, bool IsDir>
356  void TBigNet<TNodeData, IsDir>::SetOutNIdV(int NId, const TIntV& OutNIdV) {
357    TNode Node;  EAssert(IsNode(NId, Node));
358    TIntV OutNodesV;  Pool.GetV(Node.OutVId, OutNodesV);
359    EAssert(OutNIdV.Len() == OutNodesV.Len());
360    memcpy(OutNodesV.BegI(), OutNIdV.BegI(), sizeof(TInt)*OutNIdV.Len());
361  }
362  template <class TNodeData, bool IsDir>
363  void TBigNet<TNodeData, IsDir>::GetInNIdV(int NId, TIntV& InNIdV) const {
364    TNode Node;  EAssertR(IsNode(NId, Node), TStr::Fmt("Not node: NId=%d\n", NId).CStr());
365    Pool.GetV(Node.InVId, InNIdV);
366  }
367  template <class TNodeData, bool IsDir>
368  void TBigNet<TNodeData, IsDir>::GetOutNIdV(int NId, TIntV& OutNIdV) const {
369    TNode Node;  EAssert(IsNode(NId, Node));
370    Pool.GetV(Node.OutVId, OutNIdV);
371  }
372  template <class TNodeData, bool IsDir>
373  int  TBigNet<TNodeData, IsDir>::IsolateNode(int NId) {
374    TIntV OutV;
375    int NDel = 0;
376    GetOutNIdV(NId, OutV);
377    for (int i = 0; i < OutV.Len(); i++) {
378      if (OutV[i] == DelNId) { break; } 
379      const TNode& N = NodeH.GetDat(OutV[i]);
380      int *InNIdV = (int *) Pool.GetValVPt(N.InVId);
381      const int Deg = Pool.GetVLen(N.InVId);
382      int* Val = (int *) BinSearch(InNIdV, InNIdV+Deg, NId);
383      if (Val == NULL) {
384        printf("BAD: Can't find: OUT: NId: %d -- OutNbrId: %d\n", NId, OutV[i]());
385        continue;
386      }
387      IAssert(Val != 0);
388      memcpy(Val, Val+1, sizeof(int)*int(InNIdV+Deg-Val));
389      *(InNIdV+Deg-1) = DelNId;  NDel++;
390    }
391    OutV.PutAll(DelNId);
392    if (IsDir) {
393      TIntV InV;
394      GetInNIdV(NId, InV);
395      for (int i = 0; i < InV.Len(); i++) {
396        if (InV[i] == DelNId) { break; }
397        const TNode& N = NodeH.GetDat(InV[i]);
398        int *OutNIdV = (int *) Pool.GetValVPt(N.OutVId);
399        const int Deg = Pool.GetVLen(N.OutVId);
400        int* Val = (int *) BinSearch(OutNIdV, OutNIdV+Deg, NId);
401        if (Val == NULL) {
402          printf("IN: NId: %d -- InNbrId: %d\n", NId, OutV[i]());
403          continue;
404        }
405        IAssert(Val != 0);
406        memcpy(Val, Val+1, sizeof(int)*int(OutNIdV+Deg-Val));
407        *(OutNIdV+Deg-1) = DelNId;  NDel++;
408      }
409      InV.PutAll(DelNId);
410    }
411    return NDel;
412  }
413  template <class TNodeData, bool IsDir>
414  int  TBigNet<TNodeData, IsDir>::DelNode(int NId) {
415    const int DelEdges = IsolateNode(NId);
416    NodeH.DelKey(NId);
417    return DelEdges;
418  }
419  template <class TNodeData, bool IsDir>
420  bool TBigNet<TNodeData, IsDir>::IsIsoNode(const int& NId) const {
421    if (NId == DelNId) { return true; }
422    TIntV OutV;
423    GetOutNIdV(NId, OutV);
424    if (OutV.Empty() || OutV[0] == DelNId) { return true; }
425    return false;
426  }
427  template <class TNodeData, bool IsDir>
428  uint TBigNet<TNodeData, IsDir>::GetDelEdges() {
429    uint DelEdges = 0;
430    TIntV OutV;
431    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
432      const int NId = NI.GetId();
433      GetOutNIdV(NId, OutV);
434      for (int i = 0; i < OutV.Len(); i++) {
435        if (OutV[i] == DelNId) { DelEdges++; }
436      }
437    }
438    return DelEdges;
439  }
440  template <class TNodeData, bool IsDir>
441  void TBigNet<TNodeData, IsDir>::CompactEdgePool() {
442    Pool.CompactPool(DelNId);
443  }
444  template <class TNodeData, bool IsDir>
445  int TBigNet<TNodeData, IsDir>::AddEdge(const int& SrcNId, const int& DstNId) {
446    TNode Src;  IAssert(IsNode(SrcNId, Src));
447    int* OutV = (int *)Pool.GetValVPt(Src.OutVId);
448    const int OutVLen = Pool.GetVLen(Src.OutVId);
449    Assert(BinSearch(OutV, OutV+OutVLen, DstNId)==NULL); 
450    AddSorted(OutV, OutV+OutVLen, DstNId);
451    if (! OnlySources()) {
452      TNode Dst;  IAssert(IsNode(DstNId, Dst));
453      int* InV = (int *)Pool.GetValVPt(Dst.InVId);
454      const int InVLen = Pool.GetVLen(Dst.InVId);
455      AddSorted(InV, InV+InVLen, SrcNId);
456    }
457    return -1; 
458  }
459  template <class TNodeData, bool IsDir>
460  bool TBigNet<TNodeData, IsDir>::IsEdge(const int& SrcNId, const int& DstNId, const bool& Dir) const {
461    TNode Src, Dst;
462    if (! IsNode(SrcNId, Src)) { return false; } 
463    int* OutV1 = (int *)Pool.GetValVPt(Src.OutVId);
464    const bool IsEdge = BinSearch(OutV1, OutV1+Pool.GetVLen(Src.OutVId), DstNId) != NULL;
465    if (IsEdge && OnlySources()) { return true; }
466    const bool IsDstNode = IsNode(DstNId, Dst);
467    if (! IsDstNode) { return false; } 
468    else if (IsEdge) { return true; } 
469    else if (! Dir) { 
470      int* OutV2 = (int *)Pool.GetValVPt(Dst.OutVId);
471      return BinSearch(OutV2, OutV2+Pool.GetVLen(Dst.OutVId), SrcNId) != NULL; }
472    else { return false; }
473  }
474  template <class TNodeData, bool IsDir>
475  void TBigNet<TNodeData, IsDir>::GetNIdV(TIntV& NIdV) const {
476    NIdV.Reserve(GetNodes(), 0);
477    for (typename TNodeH::TIter I = NodeH.BegI(); I < NodeH.EndI(); I++) {
478      NIdV.Add(I->Key); }
479  }
480  template <class TNodeData, bool IsDir>
481  void TBigNet<TNodeData, IsDir>::SortEdgeV() {
482    printf("Sorting Edges... ");
483    TExeTm ExeTm;
484    TIntV OutV, InV;
485    int cnt = 0;
486    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
487      const int NId = NI.GetId();
488      GetOutNIdV(NId, OutV);
489      OutV.Sort();
490      if (IsDir) {
491        GetInNIdV(NId, InV);
492        InV.Sort();
493      }
494      if (++cnt % Mega(1) == 0) { printf("\r  sort:%dm  %s", cnt/Mega(1), ExeTm.GetStr()); }
495    }
496    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
497      const int NId = NI.GetId();
498      GetOutNIdV(NId, OutV);
499      IAssert(OutV.IsSorted());
500      GetInNIdV(NId, InV);
501      IAssert(InV.IsSorted());
502      if (++cnt % Mega(1) == 0) { printf("\r  check sorted:%dm  %s", cnt/Mega(1), ExeTm.GetStr()); }
503    }
504    printf("done. [%s]\n", ExeTm.GetStr());
505  }
506  template <class TNodeData, bool IsDir>
507  void TBigNet<TNodeData, IsDir>::InvertFromSources(uint ExpectNodes) {
508    typedef THash<TInt, TInt> TDegHash;
509    typedef int* TIntPt;
510    if (ExpectNodes == 0) ExpectNodes=4*GetNodes();
511    printf("\nInverting BigNet: reserved for %s nodes\n", TInt::GetMegaStr(ExpectNodes).CStr());
512    CAssert(IsDir);
513    IAssert(OnlySources());
514    TDegHash InDegH(ExpectNodes);
515    TSize NDest=0;
516    uint c=0;  TExeTm ExeTm;
517    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, c++) {
518      for (int e = 0; e < NI.GetOutDeg(); e++) {
519        InDegH.AddDat(NI.GetOutNId(e)) += 1; }
520      if (c%100000==0) printf("\r%s h:%d [%g]    ", TInt::GetMegaStr(c).CStr(), InDegH.Len(), ExeTm.GetSecs());
521    }
522    printf("\n Resizing NodePool: %lld -> %lld\n", uint64(Pool.Reserved()), uint64(GetEdges()));
523    if (2*GetEdges() > Pool.Reserved()) {
524      Pool.Reserve(2*GetEdges()); }
525    printf("NodeH: %s nodes, InDeg: %s nodes, Reserve: %s\n", TInt::GetMegaStr(NodeH.Len()).CStr(),
526      TInt::GetMegaStr(InDegH.Len()).CStr(), TInt::GetMegaStr(ExpectNodes).CStr());
527    NodeH.Reserve(ExpectNodes);
528    for (TDegHash::TIter I = InDegH.BegI(); I < InDegH.EndI(); I++) {
529      const int NId = I->Key, InDeg = I->Dat;
530      if (! IsNode(NId)) {
531        AddNode(NId, InDeg, 0); NDest++; } 
532      else {
533        TNode& Node = GetNode(NId);
534        IAssert(Node.InVId == 0); 
535        Node.InVId = Pool.AddEmptyV(InDeg); }
536    }
537    InDegH.Clr(true);
538    printf("Added: %lld destination nodes\n", uint64(NDest));
539    printf("Graph nodes: %lld nodes\n", uint64(GetNodes()));
540    THash<TInt, int*> NIdToPtH(GetNodes());
541    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, c++)
542      NIdToPtH.AddDat(NI.GetId(), (int *)Pool.GetValVPt(NI.GetInVId()));
543    printf("Adding edges...\n");
544    c = 0;
545    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, c++) {
546      const int SrcNId = NI.GetId();
547      for (int e = 0; e < NI.GetOutDeg(); e++) {
548        TIntPt& InV = NIdToPtH.GetDat(NI.GetOutNId(e));
549        IAssert(*InV == TInt::Mx);
550        *InV = SrcNId;  InV++;
551      }
552      if (c%100000==0) printf("\r%s [%g]   ", TInt::GetMegaStr(c).CStr(), ExeTm.GetSecs());
553    }
554    printf("\nSorting in-links...\n");
555    TIntV InNIdV;  c = 0;
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, c++) {
557      Pool.GetV(NI.GetInVId(), InNIdV);
558      InNIdV.Sort();
559      if (c%100000==0) printf("\r%s [%g]    ", TInt::GetMegaStr(c).CStr(), ExeTm.GetSecs());
560    }
561    printf("\r...done [%g]\n", ExeTm.GetSecs());
562    Flags.Excl(gfSources);
563  }
564  template <class TNodeData, bool IsDir>
565  void TBigNet<TNodeData, IsDir>::Rewire(TRnd& Rnd) {
566    uint64 NDup=0, NResolve=0, NAddit=0, cnt = 0;
567    TExeTm ExeTm;
568    IAssertR(! IsDir, "Only undirected networks are supported");
569    printf("Rewiring the network... 1");
570    Pool.ShuffleAll(Rnd);  printf("[%s]\n", ExeTm.GetStr());
571    printf("  sorting edges...\n");
572    SortEdgeV(); 
573    printf(" done [%s]\n", ExeTm.GetStr());
574    printf("  removing duplicates...\n");
575    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, cnt++) {
576      const int VId = NI.GetOutVId();
577      int Len = Pool.GetVLen(VId);
578      int* V = (int *)Pool.GetValVPt(VId);
579      for (int i = 0; i < Len-1 && V[i]!=DelNId; i++) {
580        if (V[i] == V[i+1] || V[i]==NI.GetId()) {
581          memcpy(V+i, V+i+1, sizeof(int)*(Len-i-1)); i--;
582          V[Len-1] = DelNId;  NDup++;
583        }
584      }
585      if (Len > 0 && V[Len-1]==NI.GetId()) { V[Len-1] = DelNId;  NDup++; }
586      if (cnt % Mega(10) == 0) { printf(".");  fflush(stdout); }
587    }
588    printf("\n    %llu duplicate edges removed [%s]\n", NDup, ExeTm.GetStr());
589    if (OnlySources()) { return; }
590    printf("  resolving one way edges...\n"); cnt=0; fflush(stdout);
591    for (TNodeI NI = BegNI(); NI < EndNI(); NI++, cnt++) {
592      for (int e = 0; e < NI.GetOutDeg(); e++) {
593        if (NI.GetOutNId(e) == DelNId) { continue; } 
594        const int InVId = GetNode(NI.GetOutNId(e)).InVId;
595        const int InVLen = Pool.GetVLen(InVId); IAssert(InVLen>=0 && InVLen < Mega(3));
596        int* InV = (int *) Pool.GetValVPt(InVId);
597        int* Val = (int *) BinSearch2(InV, InV+InVLen, NI.GetId());
598        if (*Val == NI.GetId()) { continue; } 
599        if (InVLen>0 && InV[InVLen-1] == DelNId) { 
600          IAssert((InVLen-(Val-InV)-1) >= 0);
601          memmove(Val+1, Val, sizeof(int)*(InVLen-(Val-InV)-1));
602          *Val = NI.GetId();
603        } else { 
604          memmove(NI.OutNIdV+e, NI.OutNIdV+e+1, sizeof(int)*(NI.GetOutDeg()-e-1));
605          NI.OutNIdV[NI.GetOutDeg()-1]=DelNId;  e--;
606        }
607        NResolve++;
608      }
609      if (cnt % Mega(10) == 0) { printf(".");  fflush(stdout); }
610    }
611    printf("\n    %llu resolved edges [%s]\n", NResolve, ExeTm.GetStr());
612    printf("  filling empty edge slots...\n");
613    TIntPrV SlotNIdV;
614    THash<TInt, TInt> SlotNIdH;
615    int CumSlots=0;
616    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
617      if (NI.GetOutNId(NI.GetOutDeg()-1) == DelNId) {
618        int NSlots = 0;
619        for (int s = NI.GetOutDeg()-1; s >= 0; s--) {
620          if (NI.GetOutNId(s) == DelNId) { NSlots++; }
621          else { break; }
622        }
623        SlotNIdV.Add(TIntPr(NI.GetId(), NSlots));
624        SlotNIdH.AddDat(NI.GetId(), NSlots);
625        CumSlots+=NSlots;
626      }
627    }
628    printf("    %d nodes, with %d spokes available, %d edges\n", SlotNIdH.Len(), CumSlots, CumSlots/2);
629    TIntV NIdV;  SlotNIdH.GetKeyV(NIdV);
630    for (int ni1 = 0; ni1 < NIdV.Len(); ni1++) {
631      const int nid = NIdV[ni1];
632      if (! SlotNIdH.IsKey(nid) || SlotNIdH.GetDat(nid) == 0) { continue; }
633      const int NI1Slots = SlotNIdH.GetDat(nid);
634      if ((SlotNIdH.GetMxKeyIds() - SlotNIdH.Len())/double(SlotNIdH.GetMxKeyIds()) > 0.5) { SlotNIdH.Defrag(); }
635      TNodeI NI  = GetNI(nid);
636      for (int NTries = 0; NTries < 4*NI1Slots && NI.GetOutNId(NI.GetOutDeg()-1) == DelNId; NTries++) {
637        const int nid2 = SlotNIdH.GetKey(SlotNIdH.GetRndKeyId(Rnd));
638        if (nid == nid2) { continue; }
639        TNodeI NI2  = GetNI(nid2);
640        if (NI2.GetOutNId(NI2.GetOutDeg()-1)==DelNId && ! NI2.IsInNId(NI.GetId())) {
641          int *V1 = (int *) BinSearch2(NI.OutNIdV, NI.OutNIdV+NI.GetOutDeg(), NI2.GetId());
642          int *V2 = (int *) BinSearch2(NI2.InNIdV, NI2.InNIdV+NI2.GetInDeg(), NI.GetId());
643          if (*V1 != DelNId) { memmove(V1+1, V1, sizeof(int)*(NI.GetOutDeg()-(V1-NI.OutNIdV)-1)); }
644          if (*V2 != DelNId) { memmove(V2+1, V2, sizeof(int)*(NI2.GetInDeg()-(V2-NI2.InNIdV)-1)); }
645          *V1 = NI2.GetId();  *V2 = NI.GetId();
646          NAddit++;
647          SlotNIdH.GetDat(nid)--;  SlotNIdH.GetDat(nid2)--;
648        }
649        if (SlotNIdH.GetDat(nid2) == 0) { SlotNIdH.DelKey(nid2); continue; }
650        if (SlotNIdH.GetDat(nid) == 0) { SlotNIdH.DelKey(nid); break; }
651      }
652      if (ni1 % Mega(1) == 0) { printf(".");  fflush(stdout); }
653    }
654    printf("    %llu edges added.\nDONE. TOTAL REWIRE TIME [%s]\n\n", NAddit, ExeTm.GetStr());
655  }
656  template <class TNodeData, bool IsDir>
657  PNGraph TBigNet<TNodeData, IsDir>::GetNGraph(const bool& RenumberNodes) const {
658    IAssert(RenumberNodes == false);
659    PNGraph Graph = TNGraph::New();
660    Graph->Reserve(GetNodes(), 0);
661    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
662      Graph->AddNode(NI.GetId(), Pool, NI.GetInVId(), NI.GetOutVId());
663    }
664    return Graph;
665  }
666  template <class TNodeData, bool IsDir>
667  PNGraph TBigNet<TNodeData, IsDir>::GetSubNGraph(const TIntV& NIdV) const {
668    PNGraph Graph = TNGraph::New(NIdV.Len(), 0);
669    for (int i = 0; i < NIdV.Len(); i++) {
670      Graph->AddNode(NIdV[i]); }
671    for (int i = 0; i < NIdV.Len(); i++) {
672      const int SrcNId = NIdV[i];
673      const TNodeI NI = GetNI(SrcNId);
674      int InDeg=0, OutDeg=0;
675      for (int e = 0; e < NI.GetInDeg(); e++) { if (Graph->IsNode(NI.GetInNId(e))) InDeg++; }
676      for (int e = 0; e < NI.GetOutDeg(); e++) { if (Graph->IsNode(NI.GetOutNId(e))) OutDeg++; }
677      Graph->ReserveNIdInDeg(SrcNId, InDeg);
678      Graph->ReserveNIdOutDeg(SrcNId, OutDeg);
679    }
680    for (int i = 0; i < NIdV.Len(); i++) {
681      const int SrcNId = NIdV[i];
682      const TNodeI NI = GetNI(SrcNId);
683      for (int e = 0; e < NI.GetOutDeg(); e++) {
684        const int DstNId = NI.GetOutNId(e);
685        if (Graph->IsNode(DstNId)) {
686          Graph->AddEdge(SrcNId, DstNId); }
687      }
688    }
689    return Graph;
690  }
691  template <class TNodeData, bool IsDir>
692  TPt<TBigNet<TNodeData, IsDir> > TBigNet<TNodeData, IsDir>::GetSubGraph(const TIntV& NIdV, const bool& RenumberNodes) const {
693    const bool isDir = IsDir, onlySources = HasFlag(gfSources);
694    TSize Edges=0;
695    TSparseHash<TInt, TIntPr> NIdDegH(NIdV.Len());
696    for (int i = 0; i < NIdV.Len(); i++) { NIdDegH.AddDat(NIdV[i]); }
697    for (int i = 0; i < NIdV.Len(); i++) {
698      const TNodeI NI = GetNI(NIdV[i]);
699      int InDeg=0, OutDeg=0;
700      for (int n = 0; n < NI.GetOutDeg(); n++) {
701        if (NIdDegH.IsKey(NI.GetOutNId(n))) OutDeg++; }
702      if (! onlySources && isDir) {
703        for (int n = 0; n < NI.GetInDeg(); n++) {
704          if (NIdDegH.IsKey(NI.GetInNId(n))) InDeg++; }
705      }
706      Edges += OutDeg;
707      NIdDegH.GetDat(NIdV[i]) = TIntPr(InDeg, OutDeg);
708    }
709    typedef TBigNet<TNodeData, IsDir> TBNet;
710    TPt<TBNet> NewNetPt = TBNet::New(NIdV.Len(), Edges, HasFlag(gfDirected));
<span onclick='openModal()' class='match'>711    TBNet& NewNet = *NewNetPt;
712    NewNet.Flags = Flags;
713    if (isDir || onlySources) {
714      for (int i = 0; i < NIdV.Len(); i++) {
</span>715        const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
716        NewNet.AddNode(NIdV[i], Deg.Val1, Deg.Val2, GetNDat(NIdV[i])); } 
717    } else {
718      for (int i = 0; i < NIdV.Len(); i++) {
719        const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
720        NewNet.AddUndirNode(NIdV[i], Deg.Val2, GetNDat(NIdV[i])); } 
721    }
722    for (int i = 0; i < NIdV.Len(); i++) {
723      int NId = NIdV[i];
724      const TNodeI NI = GetNI(NId);
725      int *NIdVPt = (int *) NewNet.GetOutNIdVPt(NId);
726      int deg = 0;
727      for (int e = 0; e < NI.GetOutDeg(); e++) {
728        const int Dst = NI.GetOutNId(e);
729        if (NewNet.IsNode(Dst)) {
730          *NIdVPt = Dst;  NIdVPt++;  deg++; }
731      }
732      EAssert(deg == NIdDegH.GetDat(NId).Val2);
733      if (isDir && ! onlySources) {
734        EAssert((NI.GetInVId()==NI.GetOutVId() && NI.GetInVId()==0)
735          || (NI.GetInVId() != NI.GetOutVId()));
736        int * NIdVPt = (int *) NewNet.GetInNIdVPt(NId);
737        int deg = 0;
738        for (int e = 0; e < NI.GetInDeg(); e++) {
739          const int Dst = NI.GetInNId(e);
740          if (NewNet.IsNode(Dst)) {
741            *NIdVPt = Dst;  NIdVPt++;  deg++; }
742        }
743        EAssert(deg == NIdDegH.GetDat(NId).Val1);
744      }
745    }
746    return NewNetPt;
747  }
748  template <class TNodeData, bool IsDir>
749  void TBigNet<TNodeData, IsDir>::GetSubGraph(const TIntV& NIdV, TBigNet* NewNetPt, const bool& RenumberNodes) const {
750    printf("Set subgraph on %d nodes\n", NIdV.Len()); TExeTm ExeTm;
751    const bool isDir = IsDir, onlySources = HasFlag(gfSources);
752    TSize Edges=0;
753    THash<TInt, TIntPr> NIdDegH(NIdV.Len());
754    for (int i = 0; i < NIdV.Len(); i++) { NIdDegH.AddDat(NIdV[i]); }
755    for (int i = 0; i < NIdV.Len(); i++) {
756      const TNodeI NI = GetNI(NIdV[i]);
757      int InDeg=0, OutDeg=0;
758      for (int n = 0; n < NI.GetOutDeg(); n++) {
759        if (NIdDegH.IsKey(NI.GetOutNId(n))) OutDeg++; }
760      if (! onlySources && isDir) {
761        for (int n = 0; n < NI.GetInDeg(); n++) {
762          if (NIdDegH.IsKey(NI.GetInNId(n))) InDeg++; }
763      }
764      Edges += OutDeg;
765      NIdDegH.GetDat(NIdV[i]) = TIntPr(InDeg, OutDeg);
766    }
767    NewNetPt->Reserve(NIdV.Len(), Edges);
768    TBigNet<TNodeData, IsDir>& NewNet = *NewNetPt;
769    NewNet.Flags = Flags;
770    TIntSet NIdMap;
771    if (! RenumberNodes) {
772      if (isDir || onlySources) {
773        for (int i = 0; i < NIdV.Len(); i++) {
774          const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
775          NewNet.AddNode(NIdV[i], Deg.Val1, Deg.Val2, GetNDat(NIdV[i])); } 
776      } else {
777        for (int i = 0; i < NIdV.Len(); i++) {
778          const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
779          NewNet.AddUndirNode(NIdV[i], Deg.Val2, GetNDat(NIdV[i])); } 
780      }
781    } else { 
782      NIdMap.Gen(NIdV.Len());
783      for (int i = 0; i < NIdV.Len(); i++) { NIdMap.AddKey(NIdV[i]);  }
784      if (isDir || onlySources) {
785        for (int i = 0; i < NIdV.Len(); i++) {
786          const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
787          NewNet.AddNode(NIdMap.GetKeyId(NIdV[i]), Deg.Val1, Deg.Val2, GetNDat(NIdV[i])); } 
788      } else {
789        for (int i = 0; i < NIdV.Len(); i++) {
790          const TIntPr& Deg = NIdDegH.GetDat(NIdV[i]);
791          NewNet.AddUndirNode(NIdMap.GetKeyId(NIdV[i]), Deg.Val2, GetNDat(NIdV[i])); } 
792      }
793    }
794    for (int i = 0; i < NIdV.Len(); i++) {
795      int NId = NIdV[i];
796      const TNodeI NI = GetNI(NId);
797      int *NIdVPt = (int *) NewNet.GetOutNIdVPt(RenumberNodes?NIdMap.GetKeyId(NId):NId);
798      int deg = 0;
799      for (int e = 0; e < NI.GetOutDeg(); e++) {
800        const int Dst = RenumberNodes?NIdMap.GetKeyId(NI.GetOutNId(e)):NI.GetOutNId(e);
801        if (NewNet.IsNode(Dst)) {
802          *NIdVPt = Dst;  NIdVPt++;  deg++; }
803      }
804      EAssert(deg == NIdDegH.GetDat(NId).Val2);
805      if (isDir && ! onlySources) {
806        EAssert((NI.GetInVId()==NI.GetOutVId() && NI.GetInVId()==0)
807          || (NI.GetInVId() != NI.GetOutVId()));
808        int * NIdVPt = (int *) NewNet.GetInNIdVPt(RenumberNodes?NIdMap.GetKeyId(NId):NId);
809        int deg = 0;
810        for (int e = 0; e < NI.GetInDeg(); e++) {
811          const int Dst = RenumberNodes?NIdMap.GetKeyId(NI.GetInNId(e)):NI.GetInNId(e);
812          if (NewNet.IsNode(Dst)) {
813            *NIdVPt = Dst;  NIdVPt++;  deg++; }
814        }
815        EAssert(deg == NIdDegH.GetDat(NId).Val1);
816      }
817    }
818    printf("  %u edges [%s]\n", uint(Edges), ExeTm.GetStr());
819  }
820  template <class TNodeData, bool IsDir>
821  void TBigNet<TNodeData, IsDir>::Reserve(const int& Nodes, const TSize& Edges) {
822    NodeH.Gen(TMath::Mx(int(1.1*Nodes), 100));
823    Pool = TVPool(TMath::Mx(Edges, (TSize) Mega(1)), Mega(100), true);
824  }
825  template <class TNodeData, bool IsDir>
826  bool TBigNet<TNodeData, IsDir>::IsOk() const {
827    TIntV ValV; TExeTm ExeTm;
828    printf("Is ok network:\n  Check Vec...");
829    for (uint id = 1; id < Pool.GetVecs(); id++) {
830      Pool.GetV(id, ValV);
831      if (! ValV.Empty()) {
832        EAssert((0<=ValV[0] && ValV[0]<MxNId) || ValV[0]==DelNId);
833        try {
834        for (int i = 1; i < ValV.Len(); i++) {
835          EAssertR((ValV[i-1]<ValV[i]) || (ValV[i-1]==ValV[i] && ValV[i]==DelNId),
836            TStr::Fmt("NId1: %d NId2:%d", ValV[i-1](),ValV[i]()));
837          EAssertR((0<=ValV[i] && ValV[i]<MxNId) || ValV[i]==DelNId,
838            TStr::Fmt("NId1: %dm MxNId: %d", ValV[i](), MxNId));
839          if (! OnlySources()) {
840            EAssertR(IsNode(ValV[i]) || ValV[i]==DelNId,
841              TStr::Fmt("NId1: %dm MxNId: %d", ValV[i](), MxNId)); } 
842        }
843        } catch (PExcept Except){
844          printf("  %s\n", Except->GetStr().CStr());
845          printf("  vec id: %d, lenght: %d\n", id, ValV.Len());
846          for (int i = 1; i < ValV.Len(); i++) {
847            printf("  %d", ValV[i]());
848            if (!((ValV[i-1]<ValV[i]) || (ValV[i-1]==ValV[i] && ValV[i]==DelNId))) { printf("*"); }
849          }
850          printf("\n");
851          return false;
852        }
853      }
854      if (id % 10000 == 0) {
855        printf("\r  %dk / %dk [%s]", id/1000, Pool.GetVecs()/1000, ExeTm.GetStr()); }
856    }
857    printf("[%s]\n  Check Edges...\n", ExeTm.GetStr());
858    int ErrCnt = 0;
859    if (! OnlySources()) {
860      int Cnt=0;
861      for (TNodeI NI = BegNI(); NI < EndNI(); NI++, Cnt++) {
862        for (int e = 0; e < NI.GetInDeg(); e++) {
863          if (NI.GetInNId(e) == DelNId) { continue; } 
864      if (! IsEdge(NI.GetInNId(e), NI.GetId())) {
865        printf("\nno edge: %d --> %d", NI.GetInNId(e), NI.GetId());
866        printf("NId: %d   deg %d,%d\n", NI.GetId(), NI.GetOutDeg(), NI.GetInDeg());
867        for (int i = 0; i < NI.GetInDeg(); i++) { printf("  %d", NI.GetInNId(i)); }
868        TNodeI NI2 = GetNI(NI.GetInNId(e));
869        printf("\nNId2: %d   deg %d,%d\n", NI2.GetId(), NI2.GetOutDeg(), NI2.GetInDeg());
870        for (int j = 0; j < NI2.GetOutDeg(); j++) { printf("  %d", NI2.GetOutNId(j)); }
871        printf("\n");
872        ErrCnt++;
873      }
874      }
875        for (int e = 0; e < NI.GetOutDeg(); e++) {
876          if (NI.GetOutNId(e) == DelNId) { continue; }
877          const int InVId = GetNode(NI.GetOutNId(e)).InVId;
878          int* DstInV = (int *)Pool.GetValVPt(InVId);
879      if (BinSearch(DstInV, DstInV+Pool.GetVLen(InVId), NI.GetId()) == NULL) {
880        printf("no edge: %d --> %d", NI.GetId(), NI.GetInNId(e));
881        printf("NId: %d   deg %d,%d\n", NI.GetId(), NI.GetOutDeg(), NI.GetInDeg());
882        for (int i = 0; i < NI.GetOutDeg(); i++) { printf("  %d", NI.GetOutNId(i)); }
883        TNodeI NI2 = GetNI(NI.GetOutNId(e));
884        printf("\nNId2: %d   deg %d,%d\n", NI2.GetId(), NI2.GetOutDeg(), NI2.GetInDeg());
885        for (int j = 0; j < NI2.GetInDeg(); j++) { printf("  %d", NI2.GetInNId(j)); }
886        printf("\n");  ErrCnt++;
887      }
888      }
889      if (ErrCnt > 5) { FailR("error count too large!"); }
890        if (Cnt % 100000 == 0) {
891          printf("\r%s [%s]", TInt::GetMegaStr(Cnt).CStr(), ExeTm.GetStr()); }
892      }
893      printf("\r%s [%s]\n", TInt::GetMegaStr(Cnt).CStr(), ExeTm.GetStr());
894    }
895    return true;
896  }
897  template <class TNodeData, bool IsDir>
898  void TBigNet<TNodeData, IsDir>::Dump(const TStr& Desc) const {
899    if (! Desc.Empty()) { printf("\n%s (%d, %u):\n", Desc.CStr(), GetNodes(), GetEdges()); }
900    else { printf("\nNodes: %d,  Edges: %u\n", GetNodes(), GetEdges()); }
901    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
902      printf("%d]\n  IN %d]", NI.GetId(), NI.GetInDeg());
903      for (int i=0; i<NI.GetInDeg(); i++) { printf(" %d", NI.GetInNId(i)); }
904      if (IsDir) {
905        printf("\n  OUT %d]", NI.GetOutDeg());
906        for (int i=0; i<NI.GetOutDeg(); i++) { printf(" %d", NI.GetOutNId(i)); }
907      }
908      printf("\n");
909    }
910  }
911  template <class TNodeData, bool IsDir>
912  void TBigNet<TNodeData, IsDir>::SaveForDisk(const TStr& OutFNm) const {
913    const bool IsDirected = IsDir;
914    TFOut FOut(OutFNm);
915    FOut.Save(GetNodes());
916    FOut.Save(GetEdges());
917    FOut.Save(IsDirected);
918    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
919      FOut.Save(NI.GetId());
920      NI.GetDat().Save(FOut);
921      FOut.Save(NI.GetOutDeg());
922      for (int i = 0; i < NI.GetOutDeg(); i++) {
923        FOut.Save(NI.GetOutNId(i)); }
924      if (IsDirected) {
925        FOut.Save(NI.GetInDeg());
926        for (int i = 0; i < NI.GetInDeg(); i++) {
927          FOut.Save(NI.GetInNId(i)); }
928      }
929    }
930  }
931  template <class TNodeData, bool IsDir>
932  void TBigNet<TNodeData, IsDir>::LoadNodeDatH(const TStr& InFNm, TNodeH& NodeH) {
933    TFIn SIn(InFNm);
934    TInt MxNId(SIn);
935    TB32Set Flags(SIn);
936    printf("skipping Pool...\n");
937    TBool FastCopy(SIn);
938    uint64 _GrowBy, _MxVals, _Vals;
939    SIn.Load(_GrowBy); SIn.Load(_MxVals);  SIn.Load(_Vals);
940    TInt EmptyVal(SIn);
941    int Tmp;
942    for (TSize ValN = 0; ValN < _Vals; ValN++) { SIn.Load(Tmp); }
943    TInt MxVals(SIn), Vals(SIn);
944    uint64 Offset;
945    for (int ValN = 0; ValN < Vals; ValN++) { SIn.Load(Offset); }
946    printf("loading Hode hash table...\n");
947    NodeH.Load(SIn);
948  }
949  template <class TNodeData, bool IsDir>
950  void TBigNet<TNodeData, IsDir>::SaveToDisk(const TStr& InFNm, const TStr& OutFNm, const bool& SaveSparseHash) {
951    TFIn FIn(InFNm);
952    TFOut FOut(OutFNm);
953    { TInt MxNId(FIn);  MxNId.Save(FOut);
954    TB32Set Flags(FIn);  Flags.Save(FOut);
955    TVPool Pool(FIn);  Pool.Save(FOut); }
956    { TNodeH NodeH(FIn);
957    if (! SaveSparseHash) {
958      THash<TInt, TNode> NewH(NodeH.Len(), true);
959      for (typename TNodeH::TIter I = NodeH.BegI(); I < NodeH.EndI(); I++) {
960        NewH.AddDat(I->Key, I->Dat);
961      }
962      NewH.Save(FOut);
963    } else {
964      FailR("Not implemented");
965    } }
966  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-TabBar.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bignet.h</div>
                </div>
                <div class="column column_space"><pre><code>1112  	itemData_shift.pszText = str2;
1113  	itemData_shift.cchTextMax = (stringSize);
1114  	::SendMessage(_hSelf, TCM_GETITEM, oldTab, reinterpret_cast<LPARAM>(&itemData_nDraggedTab));
1115  	if (oldTab > newTab)
1116  	{
1117  		for (int i = oldTab; i > newTab; i--)
1118  		{
</pre></code></div>
                <div class="column column_space"><pre><code>711    TBNet& NewNet = *NewNetPt;
712    NewNet.Flags = Flags;
713    if (isDir || onlySources) {
714      for (int i = 0; i < NIdV.Len(); i++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    