
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_memory.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include "caffe/util/performance.hpp"
3  #include "caffe/mkl_memory.hpp"
4  #ifndef DLOG
5  #define DLOG LOG
6  #endif
7  namespace caffe {
8  template <typename Dtype>
9  void MKLMemoryDescriptorBase<Dtype>::create_conversions() {
10    int status;
11    this->remove_conversions();
12    if (layout_int
13        && !dnnLayoutCompare<Dtype>(layout_usr, layout_int)) {
14      CHECK(layout_usr);
15      status = dnnConversionCreate<Dtype>(&convert_to_int, layout_usr,
16              layout_int);
17      CHECK_EQ(status, E_SUCCESS)
18              << "Failed creation convert_to_int with status "
19              << status << " for buffer: " << this->name << "\n";
20      status = dnnConversionCreate<Dtype>(&convert_from_int, layout_int,
21              layout_usr);
22      CHECK_EQ(status, E_SUCCESS)
23              << "Failed creation convert_from_int with status "
24              << status << " for buffer: " << this->name << "\n";
25    }
26  }
27  #ifdef CO_SIM
28  template <typename Dtype>
29  void MKLMemoryDescriptorBase<Dtype>::convert_from_prv_cosim(void* cpu_ptr){}
30  template <typename Dtype>
31  void MKLMemoryDescriptorBase<Dtype>::create_reorder_from_prv_cosim(void* cpu_ptr){}
32  #endif
33  template <typename Dtype>
34  void MKLMemoryDescriptorBase<Dtype>::remove_conversions() {
35    int status;
36    if (this->convert_from_int) {
37      DLOG(INFO) << "convert_from_int layout already created, recreating for"
38             << this->name;
39      status = dnnDelete<Dtype>(this->convert_from_int);
40      CHECK_EQ(status, E_SUCCESS);
41    }
42    if (this->convert_to_int) {
43      DLOG(INFO) << "convert_to_int layout already created, recreating for"
44             << this->name;
45      status = dnnDelete<Dtype>(this->convert_to_int);
46      CHECK_EQ(status, E_SUCCESS);
47    }
48  }
49  template <typename Dtype>
50  void MKLMemoryDescriptorBase<Dtype>::create_internal_layout(
51      const dnnPrimitive_t primitive, dnnResourceType_t type) {
52    int status;
53    this->remove_internal_layout();
54    status = dnnLayoutCreateFromPrimitive<Dtype>(
55        &this->layout_int, primitive, type);
56    CHECK_EQ(status, E_SUCCESS)
57        << "Failed dnnLayoutCreateFromPrimitive with status "
58        << status << " for buffer: " << this->name << "\n";
59    if (this->layout_usr)
60      this->create_conversions();
61  }
62  template <typename Dtype>
63  void MKLMemoryDescriptorBase<Dtype>::create_user_layout(
64      size_t dimension,
65      const size_t size[],
66      const size_t strides[],
67      bool create_conversion_if_possible) {
68    int status;
69    this->remove_user_layout();
70    status = dnnLayoutCreate<Dtype>(
71        &this->layout_usr, dimension, size, strides);
72    CHECK_EQ(status, E_SUCCESS) << "Failed dnnLayoutCreate with status "
73        << status << " for buffer: " << this->name << "\n";
74    if (create_conversion_if_possible) {
75      if (this->layout_int) {
76        this->create_conversions();
77      }
78    } else {
79      this->remove_conversions();
80    }
81  }
82  template <typename Dtype>
83  void MKLMemoryDescriptorBase<Dtype>::remove_internal_layout() {
84    int status;
85    if (this->layout_int) {
86      DLOG(INFO) << "Internal layout already created, recreating for"
87             << this->name;
88      status = dnnLayoutDelete<Dtype>(this->layout_int);
89      CHECK_EQ(status, E_SUCCESS);
90      status = dnnReleaseBuffer<Dtype>(this->internal_ptr);
91      this->internal_ptr = NULL;
92      CHECK_EQ(status, E_SUCCESS);
93    }
94  }
95  template <typename Dtype>
96  void MKLMemoryDescriptorBase<Dtype>::remove_user_layout() {
97    int status;
98    if (this->layout_usr) {
99      DLOG(INFO) << "Internal layout already created, recreating for"
100             << this->name;
101      status = dnnLayoutDelete<Dtype>(this->layout_usr);
102      CHECK_EQ(status, E_SUCCESS);
103      status = dnnReleaseBuffer<Dtype>(this->internal_ptr);
104      this->internal_ptr = NULL;
105      CHECK_EQ(status, E_SUCCESS);
106    }
107  }
108  template <typename Dtype>
109  void MKLMemoryDescriptorBase<Dtype>::create_layouts(
110      const dnnPrimitive_t primitive, dnnResourceType_t type,
111      size_t dimension, const size_t size[], const size_t strides[]) {
112    if (this->layout_usr) {
113      DLOG(INFO) << "User layout already created, recreating for"
114                 << this->name;
115      int status = dnnLayoutDelete<Dtype>(this->layout_usr);
116      CHECK_EQ(status, E_SUCCESS);
117    }
118    this->create_internal_layout(primitive, type);
119    this->create_user_layout(dimension, size, strides);
120  }
121  template <typename Dtype>
122  void MKLMemoryDescriptorBase<Dtype>::convert_from_prv(void* cpu_ptr) {
123    CHECK(cpu_ptr);
124    if (this-> convert_from_int == NULL) {
125      this->create_conversions();
126    }
127    CHECK(this->convert_from_int);
128    int status;
129    void *convert_resources[dnnResourceNumber];
130    DLOG(INFO) << "convert priv =>           "  << this->name << " =>";
131    convert_resources[dnnResourceFrom] = this->prv_ptr();
132    convert_resources[dnnResourceTo]   = cpu_ptr;
133    PERFORMANCE_MEASUREMENT_BEGIN();
134    status = dnnExecute<Dtype>(this->convert_from_int, convert_resources);
135    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
136    CHECK_EQ(status, 0) << "Conversion from prv failed with status " << status;
137  }
138  template <typename Dtype>
139  void MKLMemoryDescriptorBase<Dtype>::convert_to_prv(void* cpu_ptr) {
140    CHECK(cpu_ptr);
141    CHECK(this->convert_to_int);
142    int status;
143    void *convert_resources[dnnResourceNumber];
144    DLOG(INFO) << "convert      => priv                                => "
145               << this->name;
146    convert_resources[dnnResourceFrom] = cpu_ptr;
147    convert_resources[dnnResourceTo]   = this->prv_ptr();
148    PERFORMANCE_MEASUREMENT_BEGIN();
149    status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
150    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
151    CHECK_EQ(status, 0) << "Conversion from prv failed with status " << status;
152  }
153  template <typename Dtype>
154  bool MKLMemoryDescriptorBase<Dtype>::layout_compare(
155    shared_ptr<PrvMemDescr> other) {
156    CHECK_EQ(other->get_descr_type(),
157                PrvMemDescr::PRV_DESCR_MKL2017);
158    shared_ptr<MKLMemoryDescriptorBase<Dtype> > other_descr =
159        boost::static_pointer_cast<MKLMemoryDescriptorBase<Dtype> >
160              (other);
161    if (dnnLayoutCompare<Dtype>(other_descr->layout_int,
162        this->layout_int))
163      return true;
164    else
165      return false;
166  }
167  template <typename Dtype>
168  void MKLMemoryDescriptorBase<Dtype>::convert_from_other(
169    shared_ptr<PrvMemDescr> other) {
170    shared_ptr<MKLMemoryDescriptorBase<Dtype> > other_descr =
171        boost::static_pointer_cast<MKLMemoryDescriptorBase<Dtype> >
172              (other);
173    DLOG(INFO) << "convert other => priv     "  << other_descr->name
174               << " => " << this->name;
175    int status;
176    dnnPrimitive_t convert;
177    status = dnnConversionCreate<Dtype>(&convert,
178      other_descr->layout_int, this->layout_int);
179    void *convert_resources[dnnResourceNumber];
180    convert_resources[dnnResourceFrom] = other_descr->prv_ptr();
181    convert_resources[dnnResourceTo]   = this->prv_ptr();
182    PERFORMANCE_MEASUREMENT_BEGIN();
183    status = dnnExecute<Dtype>(convert, convert_resources);
184    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
185    CHECK_EQ(status, 0) << "Conversion from other failed with status "
186                        << status;
187    dnnDelete<Dtype>(convert);
188  }
189  template <typename Dtype, bool is_diff>
190  Dtype* MKLMemoryDescriptor<Dtype, is_diff>::get_converted_prv(
191    Blob<Dtype>* blob, bool set_prv_ptr,
192    MKLMemoryDescriptor<Dtype, is_diff>* converted_in_fwd) {
193    if (this->convert_to_int) {
194      int status;
195      void *convert_resources[dnnResourceNumber];
196      const Dtype* prv_ptr = is_diff ?  blob->prv_diff() : blob->prv_data();
197      if (prv_ptr == NULL) {
198        if (converted_in_fwd) {
199          if (1) {
200            DLOG(INFO) << "reusing fwd               "
201                    << converted_in_fwd->name << " == " << this->name;
202            return converted_in_fwd->internal_ptr;
203          } else {
204            DLOG(INFO) << "layout doesn't match      "
205                    << converted_in_fwd->name << " != " << this->name;
206          }
207        }
208        DLOG(INFO) << "convert      => priv                                => "
209                   << this->name;
210        this->allocate();
211        convert_resources[dnnResourceFrom] =
212                is_diff ?
213                  reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_diff()))
214                : reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_data()));
215        convert_resources[dnnResourceTo] =
216                reinterpret_cast<void *>(this->internal_ptr);
217        PERFORMANCE_MEASUREMENT_BEGIN();
218        status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
219        PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
220        CHECK_EQ(status, 0) << "Conversion failed with status " << status;
221        if (set_prv_ptr) {
222          if (is_diff)
223            blob->set_prv_diff_descriptor(this->get_shared_ptr(), true);
224          else
225            blob->set_prv_data_descriptor(this->get_shared_ptr(), true);
226        }
227        return this->internal_ptr;
228      } else {
229        shared_ptr<PrvMemDescr> prv_mem_descriptor =
230            is_diff ? (blob->get_prv_diff_descriptor()) :
231              (blob->get_prv_data_descriptor());
232        CHECK_EQ(prv_mem_descriptor->get_descr_type(),
233                PrvMemDescr::PRV_DESCR_MKL2017);
234        shared_ptr<MKLMemoryDescriptor<Dtype, is_diff> > current_descr =
<span onclick='openModal()' class='match'>235          boost::static_pointer_cast<MKLMemoryDescriptor<Dtype, is_diff> >
236                (prv_mem_descriptor);
237        if (!dnnLayoutCompare<Dtype>(current_descr->layout_int,
</span>238                this->layout_int)) {
239          if (converted_in_fwd) {
240            if (1) {
241              DLOG(INFO) << "reusing fwd               "
242                      << converted_in_fwd->name << " == " << this->name;
243              return converted_in_fwd->internal_ptr;
244            } else {
245              DLOG(INFO) << "layout doesn't match      "
246                      << converted_in_fwd->name << " != " << this->name;
247            }
248          }
249          DLOG(INFO) << "convert priv => priv      "
250                  << current_descr->name << " => " << this->name;
251          if (this->convert_prv2prv) {
252            CHECK_EQ(dnnLayoutCompare<Dtype>(
253                this->descr_prv2prv_conversion->layout_int,
254                this->layout_int), 0);
255            status = 0;
256          } else {
257            status = dnnConversionCreate<Dtype>(&this->convert_prv2prv,
258                    current_descr->layout_int , this->layout_int);
259            if (status == 0)
260              this->descr_prv2prv_conversion = current_descr;
261          }
262          if (status != 0) {
263            DLOG(INFO) << "!!!! Failed creation convert_prv2prv with status "
264                    << status << "\n";
265            this->allocate();
266            convert_resources[dnnResourceFrom] = is_diff ?
267              reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_diff())) :
268              reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_data()));
269            convert_resources[dnnResourceTo] =
270              reinterpret_cast<void*>(this->internal_ptr);
271            PERFORMANCE_MEASUREMENT_BEGIN();
272            status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
273            PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
274            CHECK_EQ(status, 0) << "Conversion failed with status " << status;
275          } else {
276            this->allocate();
277            convert_resources[dnnResourceFrom] = is_diff ?
278              reinterpret_cast<void *>(const_cast<Dtype *>(blob->prv_diff())) :
279              reinterpret_cast<void *>(const_cast<Dtype *>(blob->prv_data()));
280            convert_resources[dnnResourceTo] =
281                    reinterpret_cast<void *>(this->internal_ptr);
282            PERFORMANCE_MEASUREMENT_BEGIN();
283            status = dnnExecute<Dtype>(this->convert_prv2prv, convert_resources);
284            PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
285            CHECK_EQ(status, 0) << "Conversion failed with status " << status;
286          }
287          if (set_prv_ptr) {
288            if (is_diff)
289              blob->set_prv_diff_descriptor(this->get_shared_ptr(), true);
290            else
291              blob->set_prv_data_descriptor(this->get_shared_ptr(), true);
292          }
293          return this->internal_ptr;
294        } else if (current_descr.get() != this) {
295          DLOG(INFO) << "layout OK                 "
296                  << current_descr->name << " == " << this->name;
297        }
298      }
299      return const_cast<Dtype *>(prv_ptr);
300    }
301    return (is_diff ? const_cast<Dtype *>(blob->cpu_diff()) :
302                      const_cast<Dtype *>(blob->cpu_data()));
303  }
304  template class MKLMemoryDescriptor<double, true>;
305  template class MKLMemoryDescriptor<float, true>;
306  template class MKLMemoryDescriptor<float, false>;
307  template class MKLMemoryDescriptor<double, false>;
308  template class MKLMemoryDescriptorBase<float>;
309  template class MKLMemoryDescriptorBase<double>;
310  }  
311  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_memory.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include "caffe/util/performance.hpp"
3  #include "caffe/mkl_memory.hpp"
4  #ifndef DLOG
5  #define DLOG LOG
6  #endif
7  namespace caffe {
8  template <typename Dtype>
9  void MKLMemoryDescriptorBase<Dtype>::create_conversions() {
10    int status;
11    this->remove_conversions();
12    if (layout_int
13        && !dnnLayoutCompare<Dtype>(layout_usr, layout_int)) {
14      CHECK(layout_usr);
15      status = dnnConversionCreate<Dtype>(&convert_to_int, layout_usr,
16              layout_int);
17      CHECK_EQ(status, E_SUCCESS)
18              << "Failed creation convert_to_int with status "
19              << status << " for buffer: " << this->name << "\n";
20      status = dnnConversionCreate<Dtype>(&convert_from_int, layout_int,
21              layout_usr);
22      CHECK_EQ(status, E_SUCCESS)
23              << "Failed creation convert_from_int with status "
24              << status << " for buffer: " << this->name << "\n";
25    }
26  }
27  #ifdef CO_SIM
28  template <typename Dtype>
29  void MKLMemoryDescriptorBase<Dtype>::convert_from_prv_cosim(void* cpu_ptr){}
30  template <typename Dtype>
31  void MKLMemoryDescriptorBase<Dtype>::create_reorder_from_prv_cosim(void* cpu_ptr){}
32  #endif
33  template <typename Dtype>
34  void MKLMemoryDescriptorBase<Dtype>::remove_conversions() {
35    int status;
36    if (this->convert_from_int) {
37      DLOG(INFO) << "convert_from_int layout already created, recreating for"
38             << this->name;
39      status = dnnDelete<Dtype>(this->convert_from_int);
40      CHECK_EQ(status, E_SUCCESS);
41    }
42    if (this->convert_to_int) {
43      DLOG(INFO) << "convert_to_int layout already created, recreating for"
44             << this->name;
45      status = dnnDelete<Dtype>(this->convert_to_int);
46      CHECK_EQ(status, E_SUCCESS);
47    }
48  }
49  template <typename Dtype>
50  void MKLMemoryDescriptorBase<Dtype>::create_internal_layout(
51      const dnnPrimitive_t primitive, dnnResourceType_t type) {
52    int status;
53    this->remove_internal_layout();
54    status = dnnLayoutCreateFromPrimitive<Dtype>(
55        &this->layout_int, primitive, type);
56    CHECK_EQ(status, E_SUCCESS)
57        << "Failed dnnLayoutCreateFromPrimitive with status "
58        << status << " for buffer: " << this->name << "\n";
59    if (this->layout_usr)
60      this->create_conversions();
61  }
62  template <typename Dtype>
63  void MKLMemoryDescriptorBase<Dtype>::create_user_layout(
64      size_t dimension,
65      const size_t size[],
66      const size_t strides[],
67      bool create_conversion_if_possible) {
68    int status;
69    this->remove_user_layout();
70    status = dnnLayoutCreate<Dtype>(
71        &this->layout_usr, dimension, size, strides);
72    CHECK_EQ(status, E_SUCCESS) << "Failed dnnLayoutCreate with status "
73        << status << " for buffer: " << this->name << "\n";
74    if (create_conversion_if_possible) {
75      if (this->layout_int) {
76        this->create_conversions();
77      }
78    } else {
79      this->remove_conversions();
80    }
81  }
82  template <typename Dtype>
83  void MKLMemoryDescriptorBase<Dtype>::remove_internal_layout() {
84    int status;
85    if (this->layout_int) {
86      DLOG(INFO) << "Internal layout already created, recreating for"
87             << this->name;
88      status = dnnLayoutDelete<Dtype>(this->layout_int);
89      CHECK_EQ(status, E_SUCCESS);
90      status = dnnReleaseBuffer<Dtype>(this->internal_ptr);
91      this->internal_ptr = NULL;
92      CHECK_EQ(status, E_SUCCESS);
93    }
94  }
95  template <typename Dtype>
96  void MKLMemoryDescriptorBase<Dtype>::remove_user_layout() {
97    int status;
98    if (this->layout_usr) {
99      DLOG(INFO) << "Internal layout already created, recreating for"
100             << this->name;
101      status = dnnLayoutDelete<Dtype>(this->layout_usr);
102      CHECK_EQ(status, E_SUCCESS);
103      status = dnnReleaseBuffer<Dtype>(this->internal_ptr);
104      this->internal_ptr = NULL;
105      CHECK_EQ(status, E_SUCCESS);
106    }
107  }
108  template <typename Dtype>
109  void MKLMemoryDescriptorBase<Dtype>::create_layouts(
110      const dnnPrimitive_t primitive, dnnResourceType_t type,
111      size_t dimension, const size_t size[], const size_t strides[]) {
112    if (this->layout_usr) {
113      DLOG(INFO) << "User layout already created, recreating for"
114                 << this->name;
115      int status = dnnLayoutDelete<Dtype>(this->layout_usr);
116      CHECK_EQ(status, E_SUCCESS);
117    }
118    this->create_internal_layout(primitive, type);
119    this->create_user_layout(dimension, size, strides);
120  }
121  template <typename Dtype>
122  void MKLMemoryDescriptorBase<Dtype>::convert_from_prv(void* cpu_ptr) {
123    CHECK(cpu_ptr);
124    if (this-> convert_from_int == NULL) {
125      this->create_conversions();
126    }
127    CHECK(this->convert_from_int);
128    int status;
129    void *convert_resources[dnnResourceNumber];
130    DLOG(INFO) << "convert priv =>           "  << this->name << " =>";
131    convert_resources[dnnResourceFrom] = this->prv_ptr();
132    convert_resources[dnnResourceTo]   = cpu_ptr;
133    PERFORMANCE_MEASUREMENT_BEGIN();
134    status = dnnExecute<Dtype>(this->convert_from_int, convert_resources);
135    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
136    CHECK_EQ(status, 0) << "Conversion from prv failed with status " << status;
137  }
138  template <typename Dtype>
139  void MKLMemoryDescriptorBase<Dtype>::convert_to_prv(void* cpu_ptr) {
140    CHECK(cpu_ptr);
141    CHECK(this->convert_to_int);
142    int status;
143    void *convert_resources[dnnResourceNumber];
144    DLOG(INFO) << "convert      => priv                                => "
145               << this->name;
146    convert_resources[dnnResourceFrom] = cpu_ptr;
147    convert_resources[dnnResourceTo]   = this->prv_ptr();
148    PERFORMANCE_MEASUREMENT_BEGIN();
149    status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
150    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
151    CHECK_EQ(status, 0) << "Conversion from prv failed with status " << status;
152  }
153  template <typename Dtype>
154  bool MKLMemoryDescriptorBase<Dtype>::layout_compare(
155    shared_ptr<PrvMemDescr> other) {
156    CHECK_EQ(other->get_descr_type(),
157                PrvMemDescr::PRV_DESCR_MKL2017);
158    shared_ptr<MKLMemoryDescriptorBase<Dtype> > other_descr =
159        boost::static_pointer_cast<MKLMemoryDescriptorBase<Dtype> >
160              (other);
161    if (dnnLayoutCompare<Dtype>(other_descr->layout_int,
162        this->layout_int))
163      return true;
164    else
165      return false;
166  }
167  template <typename Dtype>
168  void MKLMemoryDescriptorBase<Dtype>::convert_from_other(
169    shared_ptr<PrvMemDescr> other) {
170    shared_ptr<MKLMemoryDescriptorBase<Dtype> > other_descr =
171        boost::static_pointer_cast<MKLMemoryDescriptorBase<Dtype> >
172              (other);
173    DLOG(INFO) << "convert other => priv     "  << other_descr->name
174               << " => " << this->name;
175    int status;
176    dnnPrimitive_t convert;
177    status = dnnConversionCreate<Dtype>(&convert,
178      other_descr->layout_int, this->layout_int);
179    void *convert_resources[dnnResourceNumber];
180    convert_resources[dnnResourceFrom] = other_descr->prv_ptr();
181    convert_resources[dnnResourceTo]   = this->prv_ptr();
182    PERFORMANCE_MEASUREMENT_BEGIN();
183    status = dnnExecute<Dtype>(convert, convert_resources);
184    PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
185    CHECK_EQ(status, 0) << "Conversion from other failed with status "
186                        << status;
187    dnnDelete<Dtype>(convert);
188  }
189  template <typename Dtype, bool is_diff>
190  Dtype* MKLMemoryDescriptor<Dtype, is_diff>::get_converted_prv(
191    Blob<Dtype>* blob, bool set_prv_ptr,
192    MKLMemoryDescriptor<Dtype, is_diff>* converted_in_fwd) {
193    if (this->convert_to_int) {
194      int status;
195      void *convert_resources[dnnResourceNumber];
196      const Dtype* prv_ptr = is_diff ?  blob->prv_diff() : blob->prv_data();
197      if (prv_ptr == NULL) {
198        if (converted_in_fwd) {
199          if (1) {
200            DLOG(INFO) << "reusing fwd               "
201                    << converted_in_fwd->name << " == " << this->name;
202            return converted_in_fwd->internal_ptr;
203          } else {
204            DLOG(INFO) << "layout doesn't match      "
205                    << converted_in_fwd->name << " != " << this->name;
206          }
207        }
208        DLOG(INFO) << "convert      => priv                                => "
209                   << this->name;
210        this->allocate();
211        convert_resources[dnnResourceFrom] =
212                is_diff ?
213                  reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_diff()))
214                : reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_data()));
215        convert_resources[dnnResourceTo] =
216                reinterpret_cast<void *>(this->internal_ptr);
217        PERFORMANCE_MEASUREMENT_BEGIN();
218        status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
219        PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
220        CHECK_EQ(status, 0) << "Conversion failed with status " << status;
221        if (set_prv_ptr) {
222          if (is_diff)
223            blob->set_prv_diff_descriptor(this->get_shared_ptr(), true);
224          else
225            blob->set_prv_data_descriptor(this->get_shared_ptr(), true);
226        }
227        return this->internal_ptr;
228      } else {
229        shared_ptr<PrvMemDescr> prv_mem_descriptor =
230            is_diff ? (blob->get_prv_diff_descriptor()) :
231              (blob->get_prv_data_descriptor());
232        CHECK_EQ(prv_mem_descriptor->get_descr_type(),
233                PrvMemDescr::PRV_DESCR_MKL2017);
234        shared_ptr<MKLMemoryDescriptor<Dtype, is_diff> > current_descr =
<span onclick='openModal()' class='match'>235          boost::static_pointer_cast<MKLMemoryDescriptor<Dtype, is_diff> >
236                (prv_mem_descriptor);
237        if (!dnnLayoutCompare<Dtype>(current_descr->layout_int,
</span>238                this->layout_int)) {
239          if (converted_in_fwd) {
240            if (1) {
241              DLOG(INFO) << "reusing fwd               "
242                      << converted_in_fwd->name << " == " << this->name;
243              return converted_in_fwd->internal_ptr;
244            } else {
245              DLOG(INFO) << "layout doesn't match      "
246                      << converted_in_fwd->name << " != " << this->name;
247            }
248          }
249          DLOG(INFO) << "convert priv => priv      "
250                  << current_descr->name << " => " << this->name;
251          if (this->convert_prv2prv) {
252            CHECK_EQ(dnnLayoutCompare<Dtype>(
253                this->descr_prv2prv_conversion->layout_int,
254                this->layout_int), 0);
255            status = 0;
256          } else {
257            status = dnnConversionCreate<Dtype>(&this->convert_prv2prv,
258                    current_descr->layout_int , this->layout_int);
259            if (status == 0)
260              this->descr_prv2prv_conversion = current_descr;
261          }
262          if (status != 0) {
263            DLOG(INFO) << "!!!! Failed creation convert_prv2prv with status "
264                    << status << "\n";
265            this->allocate();
266            convert_resources[dnnResourceFrom] = is_diff ?
267              reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_diff())) :
268              reinterpret_cast<void *>(const_cast<Dtype*>(blob->cpu_data()));
269            convert_resources[dnnResourceTo] =
270              reinterpret_cast<void*>(this->internal_ptr);
271            PERFORMANCE_MEASUREMENT_BEGIN();
272            status = dnnExecute<Dtype>(this->convert_to_int, convert_resources);
273            PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
274            CHECK_EQ(status, 0) << "Conversion failed with status " << status;
275          } else {
276            this->allocate();
277            convert_resources[dnnResourceFrom] = is_diff ?
278              reinterpret_cast<void *>(const_cast<Dtype *>(blob->prv_diff())) :
279              reinterpret_cast<void *>(const_cast<Dtype *>(blob->prv_data()));
280            convert_resources[dnnResourceTo] =
281                    reinterpret_cast<void *>(this->internal_ptr);
282            PERFORMANCE_MEASUREMENT_BEGIN();
283            status = dnnExecute<Dtype>(this->convert_prv2prv, convert_resources);
284            PERFORMANCE_MEASUREMENT_END_STATIC("mkl_conversion");
285            CHECK_EQ(status, 0) << "Conversion failed with status " << status;
286          }
287          if (set_prv_ptr) {
288            if (is_diff)
289              blob->set_prv_diff_descriptor(this->get_shared_ptr(), true);
290            else
291              blob->set_prv_data_descriptor(this->get_shared_ptr(), true);
292          }
293          return this->internal_ptr;
294        } else if (current_descr.get() != this) {
295          DLOG(INFO) << "layout OK                 "
296                  << current_descr->name << " == " << this->name;
297        }
298      }
299      return const_cast<Dtype *>(prv_ptr);
300    }
301    return (is_diff ? const_cast<Dtype *>(blob->cpu_diff()) :
302                      const_cast<Dtype *>(blob->cpu_data()));
303  }
304  template class MKLMemoryDescriptor<double, true>;
305  template class MKLMemoryDescriptor<float, true>;
306  template class MKLMemoryDescriptor<float, false>;
307  template class MKLMemoryDescriptor<double, false>;
308  template class MKLMemoryDescriptorBase<float>;
309  template class MKLMemoryDescriptorBase<double>;
310  }  
311  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_memory.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_memory.cpp</div>
                </div>
                <div class="column column_space"><pre><code>235          boost::static_pointer_cast<MKLMemoryDescriptor<Dtype, is_diff> >
236                (prv_mem_descriptor);
237        if (!dnnLayoutCompare<Dtype>(current_descr->layout_int,
</pre></code></div>
                <div class="column column_space"><pre><code>235          boost::static_pointer_cast<MKLMemoryDescriptor<Dtype, is_diff> >
236                (prv_mem_descriptor);
237        if (!dnnLayoutCompare<Dtype>(current_descr->layout_int,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    