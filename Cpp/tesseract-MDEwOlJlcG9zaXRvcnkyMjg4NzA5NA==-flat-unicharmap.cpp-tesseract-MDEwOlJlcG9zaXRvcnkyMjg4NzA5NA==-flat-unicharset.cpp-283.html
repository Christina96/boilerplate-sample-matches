
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharmap.cpp</h3>
            <pre><code>1  #include &quot;unicharmap.h&quot;
2  #include &lt;tesseract/unichar.h&gt;
3  #include &lt;cassert&gt;
4  namespace tesseract {
5  UNICHARMAP::UNICHARMAP() : nodes(nullptr) {}
6  UNICHARMAP::~UNICHARMAP() {
7    delete[] nodes;
8  }
<span onclick='openModal()' class='match'>9  UNICHAR_ID UNICHARMAP::unichar_to_id(const char *const unichar_repr, int length) const {
10    UNICHARMAP_NODE *current_nodes = nodes;
</span>11    assert(*unichar_repr != &#x27;\0&#x27;);
12    assert(length &gt; 0 &amp;&amp; length &lt;= UNICHAR_LEN);
13    int index = 0;
14    if (length &lt;= 0 || unichar_repr[index] == &#x27;\0&#x27;) {
15      return INVALID_UNICHAR_ID;
16    }
17    do {
18      if (index + 1 &gt;= length || unichar_repr[index + 1] == &#x27;\0&#x27;) {
19        return current_nodes[static_cast&lt;unsigned char&gt;(unichar_repr[index])].id;
20      }
21      current_nodes = current_nodes[static_cast&lt;unsigned char&gt;(unichar_repr[index])].children;
22      ++index;
23    } while (true);
24  }
25  void UNICHARMAP::insert(const char *const unichar_repr, UNICHAR_ID id) {
26    const char *current_char = unichar_repr;
27    if (*current_char == &#x27;\0&#x27;) {
28      return;
29    }
30    UNICHARMAP_NODE **current_nodes_pointer = &amp;nodes;
31    do {
32      if (*current_nodes_pointer == nullptr) {
33        *current_nodes_pointer = new UNICHARMAP_NODE[256];
34      }
35      if (current_char[1] == &#x27;\0&#x27;) {
36        (*current_nodes_pointer)[static_cast&lt;unsigned char&gt;(*current_char)].id = id;
37        return;
38      }
39      current_nodes_pointer =
40          &amp;((*current_nodes_pointer)[static_cast&lt;unsigned char&gt;(*current_char)].children);
41      ++current_char;
42    } while (true);
43  }
44  bool UNICHARMAP::contains(const char *const unichar_repr, int length) const {
45    if (unichar_repr == nullptr || *unichar_repr == &#x27;\0&#x27;) {
46      return false;
47    }
48    if (length &lt;= 0 || length &gt; UNICHAR_LEN) {
49      return false;
50    }
51    int index = 0;
52    if (unichar_repr[index] == &#x27;\0&#x27;) {
53      return false;
54    }
55    UNICHARMAP_NODE *current_nodes = nodes;
56    while (current_nodes != nullptr &amp;&amp; index + 1 &lt; length &amp;&amp; unichar_repr[index + 1] != &#x27;\0&#x27;) {
57      current_nodes = current_nodes[static_cast&lt;unsigned char&gt;(unichar_repr[index])].children;
58      ++index;
59    }
60    return current_nodes != nullptr &amp;&amp; (index + 1 &gt;= length || unichar_repr[index + 1] == &#x27;\0&#x27;) &amp;&amp;
61           current_nodes[static_cast&lt;unsigned char&gt;(unichar_repr[index])].id &gt;= 0;
62  }
63  int UNICHARMAP::minmatch(const char *const unichar_repr) const {
64    const char *current_char = unichar_repr;
65    if (*current_char == &#x27;\0&#x27;) {
66      return 0;
67    }
68    UNICHARMAP_NODE *current_nodes = nodes;
69    while (current_nodes != nullptr &amp;&amp; *current_char != &#x27;\0&#x27;) {
70      if (current_nodes[static_cast&lt;unsigned char&gt;(*current_char)].id &gt;= 0) {
71        return current_char + 1 - unichar_repr;
72      }
73      current_nodes = current_nodes[static_cast&lt;unsigned char&gt;(*current_char)].children;
74      ++current_char;
75    }
76    return 0;
77  }
78  void UNICHARMAP::clear() {
79    delete[] nodes;
80    nodes = nullptr;
81  }
82  UNICHARMAP::UNICHARMAP_NODE::UNICHARMAP_NODE() : children(nullptr), id(-1) {}
83  UNICHARMAP::UNICHARMAP_NODE::~UNICHARMAP_NODE() {
84    delete[] children;
85  }
86  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.cpp</h3>
            <pre><code>1  #include &quot;unicharset.h&quot;
2  #include &quot;params.h&quot;
3  #include &lt;tesseract/unichar.h&gt;
4  #include &quot;serialis.h&quot;
5  #include &lt;algorithm&gt;
6  #include &lt;cassert&gt;
7  #include &lt;cstdio&gt;
8  #include &lt;cstring&gt;
9  #include &lt;iomanip&gt; 
10  #include &lt;locale&gt;  
11  #include &lt;sstream&gt; 
12  namespace tesseract {
13  static const char kSeparator = &#x27;|&#x27;;
14  static const char kNaturalFlag = &#x27;n&#x27;;
15  static const int ISALPHA_MASK = 0x1;
16  static const int ISLOWER_MASK = 0x2;
17  static const int ISUPPER_MASK = 0x4;
18  static const int ISDIGIT_MASK = 0x8;
19  static const int ISPUNCTUATION_MASK = 0x10;
20  static const int kMeanlineThreshold = 220;
21  const double kMinXHeightFraction = 0.25;
22  const double kMinCapHeightFraction = 0.05;
23  const char *UNICHARSET::kCustomLigatures[][2] = {
24      {&quot;ct&quot;, &quot;\uE003&quot;}, 
25      {&quot;ſh&quot;, &quot;\uE006&quot;}, 
26      {&quot;ſi&quot;, &quot;\uE007&quot;}, 
27      {&quot;ſl&quot;, &quot;\uE008&quot;}, 
28      {&quot;ſſ&quot;, &quot;\uE009&quot;}, 
29      {nullptr, nullptr}};
30  const char *UNICHARSET::kCleanupMaps[][2] = {
31      {&quot;\u0640&quot;, &quot;&quot;},   
32      {&quot;\ufb01&quot;, &quot;fi&quot;}, 
33      {&quot;\ufb02&quot;, &quot;fl&quot;}, 
34      {nullptr, nullptr}};
35  const char *UNICHARSET::kSpecialUnicharCodes[SPECIAL_UNICHAR_CODES_COUNT] = {
36      &quot; &quot;, &quot;Joined&quot;, &quot;|Broken|0|1&quot;};
37  const char *UNICHARSET::null_script = &quot;NULL&quot;;
38  UNICHARSET::UNICHAR_PROPERTIES::UNICHAR_PROPERTIES() {
39    Init();
40  }
41  void UNICHARSET::UNICHAR_PROPERTIES::Init() {
42    isalpha = false;
43    islower = false;
44    isupper = false;
45    isdigit = false;
46    ispunctuation = false;
47    isngram = false;
48    enabled = false;
49    SetRangesOpen();
50    script_id = 0;
51    other_case = 0;
52    mirror = 0;
53    normed = &quot;&quot;;
54    direction = UNICHARSET::U_LEFT_TO_RIGHT;
55    fragment = nullptr;
56  }
57  void UNICHARSET::UNICHAR_PROPERTIES::SetRangesOpen() {
58    min_bottom = 0;
59    max_bottom = UINT8_MAX;
60    min_top = 0;
61    max_top = UINT8_MAX;
62    width = 0.0f;
63    width_sd = 0.0f;
64    bearing = 0.0f;
65    bearing_sd = 0.0f;
66    advance = 0.0f;
67    advance_sd = 0.0f;
68  }
69  void UNICHARSET::UNICHAR_PROPERTIES::SetRangesEmpty() {
70    min_bottom = UINT8_MAX;
71    max_bottom = 0;
72    min_top = UINT8_MAX;
73    max_top = 0;
74    width = 0.0f;
75    width_sd = 0.0f;
76    bearing = 0.0f;
77    bearing_sd = 0.0f;
78    advance = 0.0f;
79    advance_sd = 0.0f;
80  }
81  bool UNICHARSET::UNICHAR_PROPERTIES::AnyRangeEmpty() const {
82    return width == 0.0f || advance == 0.0f;
83  }
84  void UNICHARSET::UNICHAR_PROPERTIES::ExpandRangesFrom(
85      const UNICHAR_PROPERTIES &amp;src) {
86    UpdateRange(src.min_bottom, &amp;min_bottom, &amp;max_bottom);
87    UpdateRange(src.max_bottom, &amp;min_bottom, &amp;max_bottom);
88    UpdateRange(src.min_top, &amp;min_top, &amp;max_top);
89    UpdateRange(src.max_top, &amp;min_top, &amp;max_top);
90    if (src.width_sd &gt; width_sd) {
91      width = src.width;
92      width_sd = src.width_sd;
93    }
94    if (src.bearing_sd &gt; bearing_sd) {
95      bearing = src.bearing;
96      bearing_sd = src.bearing_sd;
97    }
98    if (src.advance_sd &gt; advance_sd) {
99      advance = src.advance;
100      advance_sd = src.advance_sd;
101    }
102  }
103  void UNICHARSET::UNICHAR_PROPERTIES::CopyFrom(const UNICHAR_PROPERTIES &amp;src) {
104    CHAR_FRAGMENT *saved_fragment = fragment;
105    *this = src; 
106    fragment = saved_fragment;
107  }
108  UNICHARSET::UNICHARSET()
109      : ids(), script_table(nullptr), script_table_size_used(0) {
110    clear();
111    for (int i = 0; i &lt; SPECIAL_UNICHAR_CODES_COUNT; ++i) {
112      unichar_insert(kSpecialUnicharCodes[i]);
113      if (i == UNICHAR_JOINED) {
114        set_isngram(i, true);
115      }
116    }
117  }
118  UNICHARSET::~UNICHARSET() {
119    clear();
120  }
121  UNICHAR_ID
122  UNICHARSET::unichar_to_id(const char *const unichar_repr) const {
123    std::string cleaned =
124        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
125    return ids.contains(cleaned.data(), cleaned.size())
126               ? ids.unichar_to_id(cleaned.data(), cleaned.size())
127               : INVALID_UNICHAR_ID;
128  }
<span onclick='openModal()' class='match'>129  UNICHAR_ID UNICHARSET::unichar_to_id(const char *const unichar_repr,
130                                       int length) const {
131    assert(length &gt; 0 &amp;&amp; length &lt;= UNICHAR_LEN);
</span>132    std::string cleaned(unichar_repr, length);
133    if (!old_style_included_) {
134      cleaned = CleanupString(unichar_repr, length);
135    }
136    return ids.contains(cleaned.data(), cleaned.size())
137               ? ids.unichar_to_id(cleaned.data(), cleaned.size())
138               : INVALID_UNICHAR_ID;
139  }
140  int UNICHARSET::step(const char *str) const {
141    std::vector&lt;UNICHAR_ID&gt; encoding;
142    std::vector&lt;char&gt; lengths;
143    encode_string(str, true, &amp;encoding, &amp;lengths, nullptr);
144    if (encoding.empty() || encoding[0] == INVALID_UNICHAR_ID) {
145      return 0;
146    }
147    return lengths[0];
148  }
149  bool UNICHARSET::encodable_string(const char *str,
150                                    unsigned *first_bad_position) const {
151    std::vector&lt;UNICHAR_ID&gt; encoding;
152    return encode_string(str, true, &amp;encoding, nullptr, first_bad_position);
153  }
154  bool UNICHARSET::encode_string(const char *str, bool give_up_on_failure,
155                                 std::vector&lt;UNICHAR_ID&gt; *encoding,
156                                 std::vector&lt;char&gt; *lengths,
157                                 unsigned *encoded_length) const {
158    std::vector&lt;UNICHAR_ID&gt; working_encoding;
159    std::vector&lt;char&gt; working_lengths;
160    std::vector&lt;char&gt; best_lengths;
161    encoding-&gt;clear(); 
162    auto str_length = strlen(str);
163    unsigned str_pos = 0;
164    bool perfect = true;
165    while (str_pos &lt; str_length) {
166      encode_string(str, str_pos, str_length, &amp;working_encoding, &amp;working_lengths,
167                    &amp;str_pos, encoding, &amp;best_lengths);
168      if (str_pos &lt; str_length) {
169        perfect = false;
170        if (give_up_on_failure) {
171          break;
172        }
173        int step = UNICHAR::utf8_step(str + str_pos);
174        if (step == 0) {
175          step = 1;
176        }
177        encoding-&gt;push_back(INVALID_UNICHAR_ID);
178        best_lengths.push_back(step);
179        str_pos += step;
180        working_encoding = *encoding;
181        working_lengths = best_lengths;
182      }
183    }
184    if (lengths != nullptr) {
185      *lengths = best_lengths;
186    }
187    if (encoded_length != nullptr) {
188      *encoded_length = str_pos;
189    }
190    return perfect;
191  }
192  const char *UNICHARSET::id_to_unichar(UNICHAR_ID id) const {
193    if (id == INVALID_UNICHAR_ID) {
194      return INVALID_UNICHAR;
195    }
196    ASSERT_HOST(static_cast&lt;unsigned&gt;(id) &lt; this-&gt;size());
197    return unichars[id].representation;
198  }
199  const char *UNICHARSET::id_to_unichar_ext(UNICHAR_ID id) const {
200    if (id == INVALID_UNICHAR_ID) {
201      return INVALID_UNICHAR;
202    }
203    ASSERT_HOST(static_cast&lt;unsigned&gt;(id) &lt; this-&gt;size());
204    if (get_isprivate(id)) {
205      const char *ch = id_to_unichar(id);
206      for (int i = 0; kCustomLigatures[i][0] != nullptr; ++i) {
207        if (!strcmp(ch, kCustomLigatures[i][1])) {
208          return kCustomLigatures[i][0];
209        }
210      }
211    }
212    return unichars[id].representation;
213  }
214  std::string UNICHARSET::debug_utf8_str(const char *str) {
215    std::string result = str;
216    result += &quot; [&quot;;
217    int step = 1;
218    for (int i = 0; str[i] != &#x27;\0&#x27;; i += step) {
219      char hex[sizeof(int) * 2 + 1];
220      step = UNICHAR::utf8_step(str + i);
221      if (step == 0) {
222        step = 1;
223        snprintf(hex, sizeof(hex), &quot;%x&quot;, str[i]);
224      } else {
225        UNICHAR ch(str + i, step);
226        snprintf(hex, sizeof(hex), &quot;%x&quot;, ch.first_uni());
227      }
228      result += hex;
229      result += &quot; &quot;;
230    }
231    result += &quot;]&quot;;
232    return result;
233  }
234  std::string UNICHARSET::debug_str(UNICHAR_ID id) const {
235    if (id == INVALID_UNICHAR_ID) {
236      return std::string(id_to_unichar(id));
237    }
238    const CHAR_FRAGMENT *fragment = this-&gt;get_fragment(id);
239    if (fragment) {
240      return fragment-&gt;to_string();
241    }
242    const char *str = id_to_unichar(id);
243    std::string result = debug_utf8_str(str);
244    if (get_isalpha(id)) {
245      if (get_islower(id)) {
246        result += &quot;a&quot;;
247      } else if (get_isupper(id)) {
248        result += &quot;A&quot;;
249      } else {
250        result += &quot;x&quot;;
251      }
252    }
253    if (get_isdigit(id)) {
254      result += &quot;0&quot;;
255    }
256    if (get_ispunctuation(id)) {
257      result += &quot;p&quot;;
258    }
259    return result;
260  }
261  void UNICHARSET::set_normed_ids(UNICHAR_ID unichar_id) {
262    unichars[unichar_id].properties.normed_ids.clear();
263    if (unichar_id == UNICHAR_SPACE &amp;&amp; id_to_unichar(unichar_id)[0] == &#x27; &#x27;) {
264      unichars[unichar_id].properties.normed_ids.push_back(UNICHAR_SPACE);
265    } else if (!encode_string(unichars[unichar_id].properties.normed.c_str(),
266                              true, &amp;unichars[unichar_id].properties.normed_ids,
267                              nullptr, nullptr)) {
268      unichars[unichar_id].properties.normed_ids.clear();
269      unichars[unichar_id].properties.normed_ids.push_back(unichar_id);
270    }
271  }
272  bool UNICHARSET::get_isprivate(UNICHAR_ID unichar_id) const {
273    UNICHAR uc(id_to_unichar(unichar_id), -1);
274    int uni = uc.first_uni();
275    return (uni &gt;= 0xE000 &amp;&amp; uni &lt;= 0xF8FF);
276  }
277  void UNICHARSET::set_ranges_empty() {
278    for (auto &amp;uc : unichars) {
279      uc.properties.SetRangesEmpty();
280    }
281  }
282  void UNICHARSET::PartialSetPropertiesFromOther(int start_index,
283                                                 const UNICHARSET &amp;src) {
284    for (unsigned ch = start_index; ch &lt; unichars.size(); ++ch) {
285      const char *utf8 = id_to_unichar(ch);
286      UNICHAR_PROPERTIES properties;
287      if (src.GetStrProperties(utf8, &amp;properties)) {
288        const char *script = src.get_script_from_script_id(properties.script_id);
289        properties.script_id = add_script(script);
290        const char *other_case = src.id_to_unichar(properties.other_case);
291        if (contains_unichar(other_case)) {
292          properties.other_case = unichar_to_id(other_case);
293        } else {
294          properties.other_case = ch;
295        }
296        const char *mirror_str = src.id_to_unichar(properties.mirror);
297        if (contains_unichar(mirror_str)) {
298          properties.mirror = unichar_to_id(mirror_str);
299        } else {
300          properties.mirror = ch;
301        }
302        unichars[ch].properties.CopyFrom(properties);
303        set_normed_ids(ch);
304      }
305    }
306  }
307  void UNICHARSET::ExpandRangesFromOther(const UNICHARSET &amp;src) {
308    for (unsigned ch = 0; ch &lt; unichars.size(); ++ch) {
309      const char *utf8 = id_to_unichar(ch);
310      UNICHAR_PROPERTIES properties;
311      if (src.GetStrProperties(utf8, &amp;properties)) {
312        unichars[ch].properties.ExpandRangesFrom(properties);
313      }
314    }
315  }
316  void UNICHARSET::CopyFrom(const UNICHARSET &amp;src) {
317    clear();
318    for (unsigned ch = 0; ch &lt; src.unichars.size(); ++ch) {
319      const UNICHAR_PROPERTIES &amp;src_props = src.unichars[ch].properties;
320      const char *utf8 = src.id_to_unichar(ch);
321      unichar_insert_backwards_compatible(utf8);
322      unichars[ch].properties.ExpandRangesFrom(src_props);
323    }
324    PartialSetPropertiesFromOther(0, src);
325  }
326  void UNICHARSET::AppendOtherUnicharset(const UNICHARSET &amp;src) {
327    int initial_used = unichars.size();
328    for (unsigned ch = 0; ch &lt; src.unichars.size(); ++ch) {
329      const UNICHAR_PROPERTIES &amp;src_props = src.unichars[ch].properties;
330      const char *utf8 = src.id_to_unichar(ch);
331      int id = unichars.size();
332      if (contains_unichar(utf8)) {
333        id = unichar_to_id(utf8);
334        unichars[id].properties.ExpandRangesFrom(src_props);
335      } else {
336        unichar_insert_backwards_compatible(utf8);
337        unichars[id].properties.SetRangesEmpty();
338      }
339    }
340    PartialSetPropertiesFromOther(initial_used, src);
341  }
342  bool UNICHARSET::SizesDistinct(UNICHAR_ID id1, UNICHAR_ID id2) const {
343    int overlap = std::min(unichars[id1].properties.max_top,
344                           unichars[id2].properties.max_top) -
345                  std::max(unichars[id1].properties.min_top,
346                           unichars[id2].properties.min_top);
347    return overlap &lt;= 0;
348  }
349  void UNICHARSET::encode_string(const char *str, int str_index, int str_length,
350                                 std::vector&lt;UNICHAR_ID&gt; *encoding,
351                                 std::vector&lt;char&gt; *lengths,
352                                 unsigned *best_total_length,
353                                 std::vector&lt;UNICHAR_ID&gt; *best_encoding,
354                                 std::vector&lt;char&gt; *best_lengths) const {
355    if (str_index &gt; static_cast&lt;int&gt;(*best_total_length)) {
356      *best_total_length = str_index;
357      *best_encoding = *encoding;
358      if (best_lengths != nullptr) {
359        *best_lengths = *lengths;
360      }
361    }
362    if (str_index == str_length) {
363      return;
364    }
365    int encoding_index = encoding-&gt;size();
366    int length = ids.minmatch(str + str_index);
367    if (length == 0 || str_index + length &gt; str_length) {
368      return;
369    }
370    do {
371      if (ids.contains(str + str_index, length)) {
372        UNICHAR_ID id = ids.unichar_to_id(str + str_index, length);
373        encoding-&gt;push_back(id);
374        lengths-&gt;push_back(length);
375        encode_string(str, str_index + length, str_length, encoding, lengths,
376                      best_total_length, best_encoding, best_lengths);
377        if (static_cast&lt;int&gt;(*best_total_length) == str_length) {
378          return; 
379        }
380        encoding-&gt;resize(encoding_index);
381        lengths-&gt;resize(encoding_index);
382      }
383      int step = UNICHAR::utf8_step(str + str_index + length);
384      if (step == 0) {
385        step = 1;
386      }
387      length += step;
388    } while (length &lt;= UNICHAR_LEN &amp;&amp; str_index + length &lt;= str_length);
389  }
390  bool UNICHARSET::GetStrProperties(const char *utf8_str,
391                                    UNICHAR_PROPERTIES *props) const {
392    props-&gt;Init();
393    props-&gt;SetRangesEmpty();
394    int total_unicodes = 0;
395    std::vector&lt;UNICHAR_ID&gt; encoding;
396    if (!encode_string(utf8_str, true, &amp;encoding, nullptr, nullptr)) {
397      return false; 
398    }
399    for (auto it : encoding) {
400      int id = it;
401      const UNICHAR_PROPERTIES &amp;src_props = unichars[id].properties;
402      if (src_props.isalpha) {
403        props-&gt;isalpha = true;
404      }
405      if (src_props.islower) {
406        props-&gt;islower = true;
407      }
408      if (src_props.isupper) {
409        props-&gt;isupper = true;
410      }
411      if (src_props.isdigit) {
412        props-&gt;isdigit = true;
413      }
414      if (src_props.ispunctuation) {
415        props-&gt;ispunctuation = true;
416      }
417      if (src_props.isngram) {
418        props-&gt;isngram = true;
419      }
420      if (src_props.enabled) {
421        props-&gt;enabled = true;
422      }
423      UpdateRange(src_props.min_bottom, &amp;props-&gt;min_bottom, &amp;props-&gt;max_bottom);
424      UpdateRange(src_props.max_bottom, &amp;props-&gt;min_bottom, &amp;props-&gt;max_bottom);
425      UpdateRange(src_props.min_top, &amp;props-&gt;min_top, &amp;props-&gt;max_top);
426      UpdateRange(src_props.max_top, &amp;props-&gt;min_top, &amp;props-&gt;max_top);
427      float bearing = props-&gt;advance + src_props.bearing;
428      if (total_unicodes == 0 || bearing &lt; props-&gt;bearing) {
429        props-&gt;bearing = bearing;
430        props-&gt;bearing_sd = props-&gt;advance_sd + src_props.bearing_sd;
431      }
432      props-&gt;advance += src_props.advance;
433      props-&gt;advance_sd += src_props.advance_sd;
434      props-&gt;width = src_props.width;
435      props-&gt;width_sd = src_props.width_sd;
436      if (total_unicodes == 0) {
437        props-&gt;script_id = src_props.script_id;
438        props-&gt;other_case = src_props.other_case;
439        props-&gt;mirror = src_props.mirror;
440        props-&gt;direction = src_props.direction;
441      }
442      props-&gt;normed += src_props.normed;
443      ++total_unicodes;
444    }
445    if (total_unicodes &gt; 1) {
446      props-&gt;width = props-&gt;advance - props-&gt;bearing;
447      props-&gt;width_sd = props-&gt;advance_sd + props-&gt;bearing_sd;
448    }
449    return total_unicodes &gt; 0;
450  }
451  unsigned int UNICHARSET::get_properties(UNICHAR_ID id) const {
452    unsigned int properties = 0;
453    if (this-&gt;get_isalpha(id)) {
454      properties |= ISALPHA_MASK;
455    }
456    if (this-&gt;get_islower(id)) {
457      properties |= ISLOWER_MASK;
458    }
459    if (this-&gt;get_isupper(id)) {
460      properties |= ISUPPER_MASK;
461    }
462    if (this-&gt;get_isdigit(id)) {
463      properties |= ISDIGIT_MASK;
464    }
465    if (this-&gt;get_ispunctuation(id)) {
466      properties |= ISPUNCTUATION_MASK;
467    }
468    return properties;
469  }
470  char UNICHARSET::get_chartype(UNICHAR_ID id) const {
471    if (this-&gt;get_isupper(id)) {
472      return &#x27;A&#x27;;
473    }
474    if (this-&gt;get_islower(id)) {
475      return &#x27;a&#x27;;
476    }
477    if (this-&gt;get_isalpha(id)) {
478      return &#x27;x&#x27;;
479    }
480    if (this-&gt;get_isdigit(id)) {
481      return &#x27;0&#x27;;
482    }
483    if (this-&gt;get_ispunctuation(id)) {
484      return &#x27;p&#x27;;
485    }
486    return 0;
487  }
488  void UNICHARSET::unichar_insert(const char *const unichar_repr,
489                                  OldUncleanUnichars old_style) {
490    if (old_style == OldUncleanUnichars::kTrue) {
491      old_style_included_ = true;
492    }
493    std::string cleaned =
494        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
495    if (!cleaned.empty() &amp;&amp; !ids.contains(cleaned.data(), cleaned.size())) {
496      const char *str = cleaned.c_str();
497      std::vector&lt;int&gt; encoding;
498      if (!old_style_included_ &amp;&amp;
499          encode_string(str, true, &amp;encoding, nullptr, nullptr)) {
500        return;
501      }
502      unichars.emplace_back();
503      auto &amp;u = unichars.back();
504      int index = 0;
505      do {
506        if (index &gt;= UNICHAR_LEN) {
507          fprintf(stderr, &quot;Utf8 buffer too big, size&gt;%d for %s\n&quot;, UNICHAR_LEN,
508                  unichar_repr);
509          return;
510        }
511        u.representation[index++] = *str++;
512      } while (*str != &#x27;\0&#x27;);
513      u.representation[index] = &#x27;\0&#x27;;
514      this-&gt;set_script(unichars.size() - 1, null_script);
515      CHAR_FRAGMENT *frag = CHAR_FRAGMENT::parse_from_string(u.representation);
516      u.properties.fragment = frag;
517      if (frag != nullptr &amp;&amp; this-&gt;contains_unichar(frag-&gt;get_unichar())) {
518        u.properties.script_id = this-&gt;get_script(frag-&gt;get_unichar());
519      }
520      u.properties.enabled = true;
521      ids.insert(u.representation, unichars.size() - 1);
522    }
523  }
524  bool UNICHARSET::contains_unichar(const char *const unichar_repr) const {
525    std::string cleaned =
526        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
527    return ids.contains(cleaned.data(), cleaned.size());
528  }
529  bool UNICHARSET::contains_unichar(const char *const unichar_repr,
530                                    int length) const {
531    if (length == 0) {
532      return false;
533    }
534    std::string cleaned(unichar_repr, length);
535    if (!old_style_included_) {
536      cleaned = CleanupString(unichar_repr, length);
537    }
538    return ids.contains(cleaned.data(), cleaned.size());
539  }
540  bool UNICHARSET::eq(UNICHAR_ID unichar_id,
541                      const char *const unichar_repr) const {
542    return strcmp(this-&gt;id_to_unichar(unichar_id), unichar_repr) == 0;
543  }
544  bool UNICHARSET::save_to_string(std::string &amp;str) const {
545    const int kFileBufSize = 1024;
546    char buffer[kFileBufSize + 1];
547    snprintf(buffer, kFileBufSize, &quot;%zu\n&quot;, this-&gt;size());
548    str = buffer;
549    for (unsigned id = 0; id &lt; this-&gt;size(); ++id) {
550      int min_bottom, max_bottom, min_top, max_top;
551      get_top_bottom(id, &amp;min_bottom, &amp;max_bottom, &amp;min_top, &amp;max_top);
552      float width, width_sd;
553      get_width_stats(id, &amp;width, &amp;width_sd);
554      float bearing, bearing_sd;
555      get_bearing_stats(id, &amp;bearing, &amp;bearing_sd);
556      float advance, advance_sd;
557      get_advance_stats(id, &amp;advance, &amp;advance_sd);
558      unsigned int properties = this-&gt;get_properties(id);
559      if (strcmp(this-&gt;id_to_unichar(id), &quot; &quot;) == 0) {
560        snprintf(buffer, kFileBufSize, &quot;%s %x %s %d\n&quot;, &quot;NULL&quot;, properties,
561                 this-&gt;get_script_from_script_id(this-&gt;get_script(id)),
562                 this-&gt;get_other_case(id));
563        str += buffer;
564      } else {
565        std::ostringstream stream;
566        stream.imbue(std::locale::classic());
567        stream &lt;&lt; this-&gt;id_to_unichar(id) &lt;&lt; &#x27; &#x27; &lt;&lt; properties &lt;&lt; &#x27; &#x27;
568               &lt;&lt; min_bottom &lt;&lt; &#x27;,&#x27; &lt;&lt; max_bottom &lt;&lt; &#x27;,&#x27; &lt;&lt; min_top &lt;&lt; &#x27;,&#x27;
569               &lt;&lt; max_top &lt;&lt; &#x27;,&#x27; &lt;&lt; width &lt;&lt; &#x27;,&#x27; &lt;&lt; width_sd &lt;&lt; &#x27;,&#x27; &lt;&lt; bearing
570               &lt;&lt; &#x27;,&#x27; &lt;&lt; bearing_sd &lt;&lt; &#x27;,&#x27; &lt;&lt; advance &lt;&lt; &#x27;,&#x27; &lt;&lt; advance_sd &lt;&lt; &#x27; &#x27;
571               &lt;&lt; this-&gt;get_script_from_script_id(this-&gt;get_script(id)) &lt;&lt; &#x27; &#x27;
572               &lt;&lt; this-&gt;get_other_case(id) &lt;&lt; &#x27; &#x27; &lt;&lt; this-&gt;get_direction(id)
573               &lt;&lt; &#x27; &#x27; &lt;&lt; this-&gt;get_mirror(id) &lt;&lt; &#x27; &#x27;
574               &lt;&lt; this-&gt;get_normed_unichar(id) &lt;&lt; &quot;\t# &quot;
575               &lt;&lt; this-&gt;debug_str(id).c_str() &lt;&lt; &#x27;\n&#x27;;
576        str += stream.str().c_str();
577      }
578    }
579    return true;
580  }
581  class LocalFilePointer {
582  public:
583    LocalFilePointer(FILE *stream) : fp_(stream) {}
584    char *fgets(char *dst, int size) {
585      return ::fgets(dst, size, fp_);
586    }
587  private:
588    FILE *fp_;
589  };
590  bool UNICHARSET::load_from_file(FILE *file, bool skip_fragments) {
591    LocalFilePointer lfp(file);
592    using namespace std::placeholders; 
593    std::function&lt;char *(char *, int)&gt; fgets_cb =
594        std::bind(&amp;LocalFilePointer::fgets, &amp;lfp, _1, _2);
595    bool success = load_via_fgets(fgets_cb, skip_fragments);
596    return success;
597  }
598  bool UNICHARSET::load_from_file(tesseract::TFile *file, bool skip_fragments) {
599    using namespace std::placeholders; 
600    std::function&lt;char *(char *, int)&gt; fgets_cb =
601        std::bind(&amp;tesseract::TFile::FGets, file, _1, _2);
602    bool success = load_via_fgets(fgets_cb, skip_fragments);
603    return success;
604  }
605  bool UNICHARSET::load_via_fgets(
606      const std::function&lt;char *(char *, int)&gt; &amp;fgets_cb, bool skip_fragments) {
607    int unicharset_size;
608    char buffer[256];
609    this-&gt;clear();
610    if (fgets_cb(buffer, sizeof(buffer)) == nullptr ||
611        sscanf(buffer, &quot;%d&quot;, &amp;unicharset_size) != 1) {
612      return false;
613    }
614    for (UNICHAR_ID id = 0; id &lt; unicharset_size; ++id) {
615      char unichar[256];
616      unsigned int properties;
617      char script[64];
618      strncpy(script, null_script, sizeof(script) - 1);
619      int min_bottom = 0;
620      int max_bottom = UINT8_MAX;
621      int min_top = 0;
622      int max_top = UINT8_MAX;
623      float width = 0.0f;
624      float width_sd = 0.0f;
625      float bearing = 0.0f;
626      float bearing_sd = 0.0f;
627      float advance = 0.0f;
628      float advance_sd = 0.0f;
629      int direction = UNICHARSET::U_LEFT_TO_RIGHT;
630      UNICHAR_ID other_case = unicharset_size;
631      UNICHAR_ID mirror = unicharset_size;
632      if (fgets_cb(buffer, sizeof(buffer)) == nullptr) {
633        return false;
634      }
635      char normed[64];
636      normed[0] = &#x27;\0&#x27;;
637      std::istringstream stream(buffer);
638      stream.imbue(std::locale::classic());
639      stream &gt;&gt; std::setw(255) &gt;&gt; unichar &gt;&gt; std::hex &gt;&gt; properties &gt;&gt; std::dec;
640      if (stream.fail()) {
641        fprintf(stderr, &quot;%s:%u failed\n&quot;, __FILE__, __LINE__);
642        return false;
643      }
644      auto position = stream.tellg();
645      stream.seekg(position);
646      char c1, c2, c3, c4, c5, c6, c7, c8, c9;
647      stream &gt;&gt; min_bottom &gt;&gt; c1 &gt;&gt; max_bottom &gt;&gt; c2 &gt;&gt; min_top &gt;&gt; c3 &gt;&gt;
648          max_top &gt;&gt; c4 &gt;&gt; width &gt;&gt; c5 &gt;&gt; width_sd &gt;&gt; c6 &gt;&gt; bearing &gt;&gt; c7 &gt;&gt;
649          bearing_sd &gt;&gt; c8 &gt;&gt; advance &gt;&gt; c9 &gt;&gt; advance_sd &gt;&gt; std::setw(63) &gt;&gt;
650          script &gt;&gt; other_case &gt;&gt; direction &gt;&gt; mirror &gt;&gt; std::setw(63) &gt;&gt; normed;
651      if (stream.fail() || c1 != &#x27;,&#x27; || c2 != &#x27;,&#x27; || c3 != &#x27;,&#x27; || c4 != &#x27;,&#x27; ||
652          c5 != &#x27;,&#x27; || c6 != &#x27;,&#x27; || c7 != &#x27;,&#x27; || c8 != &#x27;,&#x27; || c9 != &#x27;,&#x27;) {
653        stream.clear();
654        stream.seekg(position);
655        stream &gt;&gt; min_bottom &gt;&gt; c1 &gt;&gt; max_bottom &gt;&gt; c2 &gt;&gt; min_top &gt;&gt; c3 &gt;&gt;
656            max_top &gt;&gt; c4 &gt;&gt; width &gt;&gt; c5 &gt;&gt; width_sd &gt;&gt; c6 &gt;&gt; bearing &gt;&gt; c7 &gt;&gt;
657            bearing_sd &gt;&gt; c8 &gt;&gt; advance &gt;&gt; c9 &gt;&gt; advance_sd &gt;&gt; std::setw(63) &gt;&gt;
658            script &gt;&gt; other_case &gt;&gt; direction &gt;&gt; mirror;
659        if (stream.fail() || c1 != &#x27;,&#x27; || c2 != &#x27;,&#x27; || c3 != &#x27;,&#x27; || c4 != &#x27;,&#x27; ||
660            c5 != &#x27;,&#x27; || c6 != &#x27;,&#x27; || c7 != &#x27;,&#x27; || c8 != &#x27;,&#x27; || c9 != &#x27;,&#x27;) {
661          stream.clear();
662          stream.seekg(position);
663          stream &gt;&gt; min_bottom &gt;&gt; c1 &gt;&gt; max_bottom &gt;&gt; c2 &gt;&gt; min_top &gt;&gt; c3 &gt;&gt;
664              max_top &gt;&gt; std::setw(63) &gt;&gt; script &gt;&gt; other_case &gt;&gt; direction &gt;&gt;
665              mirror;
666          if (stream.fail() || c1 != &#x27;,&#x27; || c2 != &#x27;,&#x27; || c3 != &#x27;,&#x27;) {
667            stream.clear();
668            stream.seekg(position);
669            stream &gt;&gt; min_bottom &gt;&gt; c1 &gt;&gt; max_bottom &gt;&gt; c2 &gt;&gt; min_top &gt;&gt; c3 &gt;&gt;
670                max_top &gt;&gt; std::setw(63) &gt;&gt; script &gt;&gt; other_case;
671            if (stream.fail() || c1 != &#x27;,&#x27; || c2 != &#x27;,&#x27; || c3 != &#x27;,&#x27;) {
672              stream.clear();
673              stream.seekg(position);
674              stream &gt;&gt; std::setw(63) &gt;&gt; script &gt;&gt; other_case;
675              if (stream.fail()) {
676                stream.clear();
677                stream.seekg(position);
678                stream &gt;&gt; std::setw(63) &gt;&gt; script;
679              }
680            }
681          }
682        }
683      }
684      CHAR_FRAGMENT *frag = nullptr;
685      if (skip_fragments &amp;&amp; (frag = CHAR_FRAGMENT::parse_from_string(unichar))) {
686        int num_pieces = frag-&gt;get_total();
687        delete frag;
688        if (num_pieces &gt; 1) {
689          continue;
690        }
691      }
692      if (strcmp(unichar, &quot;NULL&quot;) == 0) {
693        this-&gt;unichar_insert(&quot; &quot;);
694      } else {
695        this-&gt;unichar_insert_backwards_compatible(unichar);
696      }
697      this-&gt;set_isalpha(id, properties &amp; ISALPHA_MASK);
698      this-&gt;set_islower(id, properties &amp; ISLOWER_MASK);
699      this-&gt;set_isupper(id, properties &amp; ISUPPER_MASK);
700      this-&gt;set_isdigit(id, properties &amp; ISDIGIT_MASK);
701      this-&gt;set_ispunctuation(id, properties &amp; ISPUNCTUATION_MASK);
702      this-&gt;set_isngram(id, false);
703      this-&gt;set_script(id, script);
704      this-&gt;unichars[id].properties.enabled = true;
705      this-&gt;set_top_bottom(id, min_bottom, max_bottom, min_top, max_top);
706      this-&gt;set_width_stats(id, width, width_sd);
707      this-&gt;set_bearing_stats(id, bearing, bearing_sd);
708      this-&gt;set_advance_stats(id, advance, advance_sd);
709      this-&gt;set_direction(id, static_cast&lt;UNICHARSET::Direction&gt;(direction));
710      this-&gt;set_other_case(id, (other_case &lt; unicharset_size) ? other_case : id);
711      this-&gt;set_mirror(id, (mirror &lt; unicharset_size) ? mirror : id);
712      this-&gt;set_normed(id, normed[0] != &#x27;\0&#x27; ? normed : unichar);
713    }
714    post_load_setup();
715    return true;
716  }
717  void UNICHARSET::post_load_setup() {
718    int net_case_alphas = 0;
719    int x_height_alphas = 0;
720    int cap_height_alphas = 0;
721    top_bottom_set_ = false;
722    for (unsigned id = 0; id &lt; unichars.size(); ++id) {
723      int min_bottom = 0;
724      int max_bottom = UINT8_MAX;
725      int min_top = 0;
726      int max_top = UINT8_MAX;
727      get_top_bottom(id, &amp;min_bottom, &amp;max_bottom, &amp;min_top, &amp;max_top);
728      if (min_top &gt; 0) {
729        top_bottom_set_ = true;
730      }
731      if (get_isalpha(id)) {
732        if (get_islower(id) || get_isupper(id)) {
733          ++net_case_alphas;
734        } else {
735          --net_case_alphas;
736        }
737        if (min_top &lt; kMeanlineThreshold &amp;&amp; max_top &lt; kMeanlineThreshold) {
738          ++x_height_alphas;
739        } else if (min_top &gt; kMeanlineThreshold &amp;&amp; max_top &gt; kMeanlineThreshold) {
740          ++cap_height_alphas;
741        }
742      }
743      set_normed_ids(id);
744    }
745    script_has_upper_lower_ = net_case_alphas &gt; 0;
746    script_has_xheight_ =
747        script_has_upper_lower_ ||
748        (x_height_alphas &gt; cap_height_alphas * kMinXHeightFraction &amp;&amp;
749         cap_height_alphas &gt; x_height_alphas * kMinCapHeightFraction);
750    null_sid_ = get_script_id_from_name(null_script);
751    ASSERT_HOST(null_sid_ == 0);
752    common_sid_ = get_script_id_from_name(&quot;Common&quot;);
753    latin_sid_ = get_script_id_from_name(&quot;Latin&quot;);
754    cyrillic_sid_ = get_script_id_from_name(&quot;Cyrillic&quot;);
755    greek_sid_ = get_script_id_from_name(&quot;Greek&quot;);
756    han_sid_ = get_script_id_from_name(&quot;Han&quot;);
757    hiragana_sid_ = get_script_id_from_name(&quot;Hiragana&quot;);
758    katakana_sid_ = get_script_id_from_name(&quot;Katakana&quot;);
759    thai_sid_ = get_script_id_from_name(&quot;Thai&quot;);
760    hangul_sid_ = get_script_id_from_name(&quot;Hangul&quot;);
761    int *script_counts = new int[script_table_size_used];
762    memset(script_counts, 0, sizeof(*script_counts) * script_table_size_used);
763    for (unsigned id = 0; id &lt; unichars.size(); ++id) {
764      if (get_isalpha(id)) {
765        ++script_counts[get_script(id)];
766      }
767    }
768    default_sid_ = 0;
769    for (int s = 1; s &lt; script_table_size_used; ++s) {
770      if (script_counts[s] &gt; script_counts[default_sid_] &amp;&amp; s != common_sid_) {
771        default_sid_ = s;
772      }
773    }
774    delete[] script_counts;
775  }
776  bool UNICHARSET::major_right_to_left() const {
777    int ltr_count = 0;
778    int rtl_count = 0;
779    for (unsigned id = 0; id &lt; unichars.size(); ++id) {
780      int dir = get_direction(id);
781      if (dir == UNICHARSET::U_LEFT_TO_RIGHT) {
782        ltr_count++;
783      }
784      if (dir == UNICHARSET::U_RIGHT_TO_LEFT ||
785          dir == UNICHARSET::U_RIGHT_TO_LEFT_ARABIC ||
786          dir == UNICHARSET::U_ARABIC_NUMBER) {
787        rtl_count++;
788      }
789    }
790    return rtl_count &gt; ltr_count;
791  }
792  void UNICHARSET::set_black_and_whitelist(const char *blacklist,
793                                           const char *whitelist,
794                                           const char *unblacklist) {
795    bool def_enabled = whitelist == nullptr || whitelist[0] == &#x27;\0&#x27;;
796    for (auto &amp;uc : unichars) {
797      uc.properties.enabled = def_enabled;
798    }
799    if (!def_enabled) {
800      std::vector&lt;UNICHAR_ID&gt; encoding;
801      encode_string(whitelist, false, &amp;encoding, nullptr, nullptr);
802      for (auto it : encoding) {
803        if (it != INVALID_UNICHAR_ID) {
804          unichars[it].properties.enabled = true;
805        }
806      }
807    }
808    if (blacklist != nullptr &amp;&amp; blacklist[0] != &#x27;\0&#x27;) {
809      std::vector&lt;UNICHAR_ID&gt; encoding;
810      encode_string(blacklist, false, &amp;encoding, nullptr, nullptr);
811      for (auto it : encoding) {
812        if (it != INVALID_UNICHAR_ID) {
813          unichars[it].properties.enabled = false;
814        }
815      }
816    }
817    if (unblacklist != nullptr &amp;&amp; unblacklist[0] != &#x27;\0&#x27;) {
818      std::vector&lt;UNICHAR_ID&gt; encoding;
819      encode_string(unblacklist, false, &amp;encoding, nullptr, nullptr);
820      for (auto it : encoding) {
821        if (it != INVALID_UNICHAR_ID) {
822          unichars[it].properties.enabled = true;
823        }
824      }
825    }
826  }
827  bool UNICHARSET::AnyRepeatedUnicodes() const {
828    int start_id = 0;
829    if (has_special_codes()) {
830      start_id = SPECIAL_UNICHAR_CODES_COUNT;
831    }
832    for (unsigned id = start_id; id &lt; unichars.size(); ++id) {
833      std::vector&lt;char32&gt; unicodes = UNICHAR::UTF8ToUTF32(get_normed_unichar(id));
834      for (size_t u = 1; u &lt; unicodes.size(); ++u) {
835        if (unicodes[u - 1] == unicodes[u]) {
836          return true;
837        }
838      }
839    }
840    return false;
841  }
842  int UNICHARSET::add_script(const char *script) {
843    for (int i = 0; i &lt; script_table_size_used; ++i) {
844      if (strcmp(script, script_table[i]) == 0) {
845        return i;
846      }
847    }
848    if (script_table_size_reserved == 0) {
849      script_table_size_reserved = 8;
850      script_table = new char *[script_table_size_reserved];
851    } else if (script_table_size_used &gt;= script_table_size_reserved) {
852      assert(script_table_size_used == script_table_size_reserved);
853      script_table_size_reserved += script_table_size_reserved;
854      char **new_script_table = new char *[script_table_size_reserved];
855      memcpy(new_script_table, script_table,
856             script_table_size_used * sizeof(char *));
857      delete[] script_table;
858      script_table = new_script_table;
859    }
860    script_table[script_table_size_used] = new char[strlen(script) + 1];
861    strcpy(script_table[script_table_size_used], script);
862    return script_table_size_used++;
863  }
864  std::string CHAR_FRAGMENT::to_string(const char *unichar, int pos, int total,
865                                       bool natural) {
866    if (total == 1) {
867      return std::string(unichar);
868    }
869    std::string result;
870    result += kSeparator;
871    result += unichar;
872    char buffer[kMaxLen];
873    snprintf(buffer, kMaxLen, &quot;%c%d%c%d&quot;, kSeparator, pos,
874             natural ? kNaturalFlag : kSeparator, total);
875    result += buffer;
876    return result;
877  }
878  CHAR_FRAGMENT *CHAR_FRAGMENT::parse_from_string(const char *string) {
879    const char *ptr = string;
880    int len = strlen(string);
881    if (len &lt; kMinLen || *ptr != kSeparator) {
882      return nullptr; 
883    }
884    ptr++; 
885    int step = 0;
886    while ((ptr + step) &lt; (string + len) &amp;&amp; *(ptr + step) != kSeparator) {
887      step += UNICHAR::utf8_step(ptr + step);
888    }
889    if (step == 0 || step &gt; UNICHAR_LEN) {
890      return nullptr; 
891    }
892    char unichar[UNICHAR_LEN + 1];
893    strncpy(unichar, ptr, step);
894    unichar[step] = &#x27;\0&#x27;; 
895    ptr += step;          
896    int pos = 0;
897    int total = 0;
898    bool natural = false;
899    char *end_ptr = nullptr;
900    for (int i = 0; i &lt; 2; i++) {
901      if (ptr &gt; string + len || *ptr != kSeparator) {
902        if (i == 1 &amp;&amp; *ptr == kNaturalFlag) {
903          natural = true;
904        } else {
905          return nullptr; 
906        }
907      }
908      ptr++; 
909      i == 0 ? pos = static_cast&lt;int&gt;(strtol(ptr, &amp;end_ptr, 10))
910             : total = static_cast&lt;int&gt;(strtol(ptr, &amp;end_ptr, 10));
911      ptr = end_ptr;
912    }
913    if (ptr != string + len) {
914      return nullptr; 
915    }
916    auto *fragment = new CHAR_FRAGMENT();
917    fragment-&gt;set_all(unichar, pos, total, natural);
918    return fragment;
919  }
920  int UNICHARSET::get_script_id_from_name(const char *script_name) const {
921    for (int i = 0; i &lt; script_table_size_used; ++i) {
922      if (strcmp(script_name, script_table[i]) == 0) {
923        return i;
924      }
925    }
926    return 0; 
927  }
928  std::string UNICHARSET::CleanupString(const char *utf8_str, size_t length) {
929    std::string result;
930    result.reserve(length);
931    char ch;
932    while ((ch = *utf8_str) != &#x27;\0&#x27; &amp;&amp; length-- &gt; 0) {
933      int key_index = 0;
934      const char *key;
935      while ((key = kCleanupMaps[key_index][0]) != nullptr) {
936        int match = 0;
937        while (key[match] != &#x27;\0&#x27; &amp;&amp; key[match] == utf8_str[match]) {
938          ++match;
939        }
940        if (key[match] == &#x27;\0&#x27;) {
941          utf8_str += match;
942          break;
943        }
944        ++key_index;
945      }
946      if (key == nullptr) {
947        result.push_back(ch);
948        ++utf8_str;
949      } else {
950        result.append(kCleanupMaps[key_index][1]);
951      }
952    }
953    return result;
954  }
955  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharmap.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.cpp</div>
                </div>
                <div class="column column_space"><pre><code>9  UNICHAR_ID UNICHARMAP::unichar_to_id(const char *const unichar_repr, int length) const {
10    UNICHARMAP_NODE *current_nodes = nodes;
</pre></code></div>
                <div class="column column_space"><pre><code>129  UNICHAR_ID UNICHARSET::unichar_to_id(const char *const unichar_repr,
130                                       int length) const {
131    assert(length &gt; 0 &amp;&amp; length &lt;= UNICHAR_LEN);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    