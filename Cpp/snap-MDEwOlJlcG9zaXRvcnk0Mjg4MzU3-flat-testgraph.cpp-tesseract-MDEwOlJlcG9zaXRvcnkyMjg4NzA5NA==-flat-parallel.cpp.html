
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.448818897637794%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-testgraph.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  int main(int argc, char* argv[]) {
3    typedef PUNGraph PGraph; 
4    printf("Creating graph:\n");
5    PGraph G = PGraph::TObj::New();
6    for (int n = 0; n < 10; n++) {
7      G->AddNode(); 
8    }
9    G->AddEdge(0, 1);
10    for (int e = 0; e < 10; e++) {
11      const int NId1 = G->GetRndNId();
12      const int NId2 = G->GetRndNId();
13      if (G->AddEdge(NId1, NId2) != -2) {
14        printf("  Edge %d -- %d added\n", NId1,  NId2); }
15      else {
16        printf("  Edge %d -- %d already exists\n", NId1, NId2); }
17    }
18    IAssert(G->IsOk());
19    PGraph::TObj::TNodeI NI = G->GetNI(0);
20    printf("Delete edge %d -- %d\n", NI.GetId(), NI.GetOutNId(0));
21    G->DelEdge(NI.GetId(), NI.GetOutNId(0));
22    const int RndNId = G->GetRndNId();
23    printf("Delete node %d\n", RndNId);
24    G->DelNode(RndNId);
25    IAssert(G->IsOk());
26    printf("Graph (%d, %d)\n", G->GetNodes(), G->GetEdges());
27    for (PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
28      printf("  %d: ", NI.GetId());
29      for (int e = 0; e < NI.GetDeg(); e++) {
30        printf(" %d", NI.GetNbrNId(e)); }
31      printf("\n");
32    }
33    TIntV NIdV;
34    for (PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
35      if (NIdV.Len() < G->GetNodes()/2) { NIdV.Add(NI.GetId()); }
36    }
37    PGraph SubG = TSnap::GetSubGraph(G, NIdV);
38    { PUNGraph UNG = TSnap::ConvertGraph<PUNGraph>(SubG);
39    UNG->Dump();
40    IAssert(UNG->IsOk());
41    TSnap::ConvertSubGraph<PNGraph>(G, NIdV)->Dump(); }
42    { PNGraph NG = TSnap::ConvertGraph<PNGraph>(SubG);
43    NG->Dump();
44    IAssert(NG->IsOk());
45    TSnap::ConvertSubGraph<PNGraph>(G, NIdV)->Dump(); }
46    { PNEGraph NEG = TSnap::ConvertGraph<PNEGraph>(SubG);
47    NEG->Dump();
48    IAssert(NEG->IsOk());
49    TSnap::ConvertSubGraph<PNGraph>(G, NIdV)->Dump(); }
50    TSnap::TestAnf<PUNGraph>();
51    return 0;
52  }
53  void TestEigSvd() {
54    PNGraph G = TSnap::GenRndGnm<PNGraph>(100,1000, true);
55    PUNGraph UG = TSnap::ConvertGraph<PUNGraph>(G);
56    TSnap::SaveMatlabSparseMtx(G, "test1.mtx");
57    TSnap::SaveMatlabSparseMtx(UG, "test2.mtx");
58    TFltV SngValV; TVec<TFltV> LeftV, RightV;
59    TSnap::GetSngVec(G, 20, SngValV, LeftV, RightV);
60    printf("Singular Values:\n");
<span onclick='openModal()' class='match'>61    for (int i =0; i < SngValV.Len(); i++) {
62      printf("%d\t%f\n", i, SngValV[i]()); }
63    printf("LEFT Singular Vectors:\n");
64    for (int i=0; i < LeftV[0].Len(); i++) {
65      printf("%d\t%f\t%f\t%f\t%f\t%f\n", i, LeftV[0][i](), LeftV[1][i](), LeftV[2][i](), LeftV[3][i](), LeftV[4][i]());
66    }
</span>67    printf("RIGHT Singular Vectors:\n");
68    for (int i=0; i < RightV[0].Len(); i++) {
69      printf("%d\t%f\t%f\t%f\t%f\t%f\n", i, RightV[0][i](), RightV[1][i](), RightV[2][i](), RightV[3][i](), RightV[4][i]());
70    }
71    TFltV EigValV;
72    TVec<TFltV> EigV;
73    TSnap::GetEigVec(UG, 20, EigValV, EigV);
74    printf("Eigen Values:\n");
75    for (int i =0; i < EigValV.Len(); i++) {
76      printf("%d\t%f\n", i, EigValV[i]()); }
77    printf("Eigen Vectors %d:\n", EigV.Len());
78    for (int i =0; i < EigV[0].Len(); i++) {
79      printf("%d\t%f\t%f\t%f\t%f\t%f\n", i, EigV[0][i](), EigV[1][i](), EigV[2][i](), EigV[3][i](), EigV[4][i]());
80    }
81  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-parallel.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "parallel.h"
5  #ifdef _OPENMP
6  #  include <omp.h>
7  #endif
8  #include "functions.h" 
9  #include "networkscratch.h"
10  namespace tesseract {
11  Parallel::Parallel(const char *name, NetworkType type) : Plumbing(name) {
12    type_ = type;
13  }
14  StaticShape Parallel::OutputShape(const StaticShape &input_shape) const {
15    StaticShape result = stack_[0]->OutputShape(input_shape);
16    int stack_size = stack_.size();
17    for (int i = 1; i < stack_size; ++i) {
18      StaticShape shape = stack_[i]->OutputShape(input_shape);
19      result.set_depth(result.depth() + shape.depth());
20    }
21    return result;
22  }
23  void Parallel::Forward(bool debug, const NetworkIO &input, const TransposedArray *input_transpose,
24                         NetworkScratch *scratch, NetworkIO *output) {
25    bool parallel_debug = false;
26    if (debug && type_ != NT_PARALLEL) {
27      parallel_debug = true;
28      debug = false;
29    }
30    int stack_size = stack_.size();
31    if (type_ == NT_PAR_2D_LSTM) {
32      std::vector<NetworkScratch::IO> results(stack_size);
<span onclick='openModal()' class='match'>33      for (int i = 0; i < stack_size; ++i) {
34        results[i].Resize(input, stack_[i]->NumOutputs(), scratch);
35      }
36  #ifdef _OPENMP
37  #  pragma omp parallel for num_threads(stack_size)
38  #endif
39      for (int i = 0; i < stack_size; ++i) {
40        stack_[i]->Forward(debug, input, nullptr, scratch, results[i]);
41      }
</span>42      int out_offset = 0;
43      output->Resize(*results[0], NumOutputs());
44      for (int i = 0; i < stack_size; ++i) {
45        out_offset = output->CopyPacking(*results[i], out_offset);
46      }
47    } else {
48      NetworkScratch::IO result(input, scratch);
49      NetworkScratch::IO source_part;
50      TransposedArray *src_transpose = nullptr;
51      if (IsTraining() && type_ == NT_REPLICATED) {
52        input.Transpose(&transposed_input_);
53        src_transpose = &transposed_input_;
54      }
55      int out_offset = 0;
56      for (int i = 0; i < stack_size; ++i) {
57        stack_[i]->Forward(debug, input, src_transpose, scratch, result);
58        if (i == 0) {
59          output->Resize(*result, NumOutputs());
60        } else {
61          ASSERT_HOST(result->Width() == output->Width());
62        }
63        out_offset = output->CopyPacking(*result, out_offset);
64      }
65    }
66  #ifndef GRAPHICS_DISABLED
67    if (parallel_debug) {
68      DisplayForward(*output);
69    }
70  #endif
71  }
72  bool Parallel::Backward(bool debug, const NetworkIO &fwd_deltas, NetworkScratch *scratch,
73                          NetworkIO *back_deltas) {
74    if (debug && type_ != NT_PARALLEL) {
75  #ifndef GRAPHICS_DISABLED
76      DisplayBackward(fwd_deltas);
77  #endif
78      debug = false;
79    }
80    auto stack_size = stack_.size();
81    if (type_ == NT_PAR_2D_LSTM) {
82      std::vector<NetworkScratch::IO> in_deltas(stack_size);
83      std::vector<NetworkScratch::IO> out_deltas(stack_size);
84      int feature_offset = 0;
85      for (unsigned i = 0; i < stack_.size(); ++i) {
86        int num_features = stack_[i]->NumOutputs();
87        in_deltas[i].Resize(fwd_deltas, num_features, scratch);
88        out_deltas[i].Resize(fwd_deltas, stack_[i]->NumInputs(), scratch);
89        in_deltas[i]->CopyUnpacking(fwd_deltas, feature_offset, num_features);
90        feature_offset += num_features;
91      }
92  #ifdef _OPENMP
93  #  pragma omp parallel for num_threads(stack_size)
94  #endif
95      for (unsigned i = 0; i < stack_size; ++i) {
96        stack_[i]->Backward(debug, *in_deltas[i], scratch, i == 0 ? back_deltas : out_deltas[i]);
97      }
98      if (needs_to_backprop_) {
99        for (unsigned i = 1; i < stack_size; ++i) {
100          back_deltas->AddAllToFloat(*out_deltas[i]);
101        }
102      }
103    } else {
104      NetworkScratch::IO in_deltas(fwd_deltas, scratch);
105      NetworkScratch::IO out_deltas;
106      int feature_offset = 0;
107      for (unsigned i = 0; i < stack_.size(); ++i) {
108        int num_features = stack_[i]->NumOutputs();
109        in_deltas->CopyUnpacking(fwd_deltas, feature_offset, num_features);
110        feature_offset += num_features;
111        if (stack_[i]->Backward(debug, *in_deltas, scratch, back_deltas)) {
112          if (i == 0) {
113            out_deltas.ResizeFloat(*back_deltas, back_deltas->NumFeatures(), scratch);
114            out_deltas->CopyAll(*back_deltas);
115          } else if (back_deltas->NumFeatures() == out_deltas->NumFeatures()) {
116            out_deltas->AddAllToFloat(*back_deltas);
117          }
118        }
119      }
120      if (needs_to_backprop_) {
121        back_deltas->CopyAll(*out_deltas);
122      }
123    }
124    if (needs_to_backprop_) {
125      back_deltas->ScaleFloatBy(1.0f / stack_size);
126    }
127    return needs_to_backprop_;
128  }
129  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-testgraph.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-parallel.cpp</div>
                </div>
                <div class="column column_space"><pre><code>61    for (int i =0; i < SngValV.Len(); i++) {
62      printf("%d\t%f\n", i, SngValV[i]()); }
63    printf("LEFT Singular Vectors:\n");
64    for (int i=0; i < LeftV[0].Len(); i++) {
65      printf("%d\t%f\t%f\t%f\t%f\t%f\n", i, LeftV[0][i](), LeftV[1][i](), LeftV[2][i](), LeftV[3][i](), LeftV[4][i]());
66    }
</pre></code></div>
                <div class="column column_space"><pre><code>33      for (int i = 0; i < stack_size; ++i) {
34        results[i].Resize(input, stack_[i]->NumOutputs(), scratch);
35      }
36  #ifdef _OPENMP
37  #  pragma omp parallel for num_threads(stack_size)
38  #endif
39      for (int i = 0; i < stack_size; ++i) {
40        stack_[i]->Forward(debug, input, nullptr, scratch, results[i]);
41      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    