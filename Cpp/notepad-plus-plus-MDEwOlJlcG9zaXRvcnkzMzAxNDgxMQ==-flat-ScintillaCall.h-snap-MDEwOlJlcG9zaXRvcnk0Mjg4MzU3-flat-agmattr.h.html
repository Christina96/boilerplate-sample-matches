
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.7170263788968825%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaCall.h</h3>
            <pre><code>1  #ifndef SCINTILLACALL_H
2  #define SCINTILLACALL_H
3  namespace Scintilla {
4  enum class Message;	
5  struct TextRangeFull;
6  struct TextToFindFull;
7  struct RangeToFormatFull;
8  using FunctionDirect = intptr_t(*)(intptr_t ptr, unsigned int iMessage, uintptr_t wParam, intptr_t lParam, int *pStatus);
9  struct Failure {
10  	Scintilla::Status status;
11  	explicit Failure(Scintilla::Status status_) noexcept : status(status_) {
12  	}
13  };
14  struct Span {
15  	Position start;
16  	Position end;
17  	explicit Span(Position position) noexcept : start(position), end(position) {
18  	}
19  	Span(Position start_, Position end_) noexcept : start(start_), end(end_) {
20  	}
21  	Position Length() const noexcept {
22  		if (end > start)
23  			return end - start;
24  		else
25  			return start - end;
26  	}
27  	bool operator==(const Span &other) const noexcept {
28  		return (other.start == start) && (other.end == end);
29  	}
30  };
31  class ScintillaCall {
32  	FunctionDirect fn;
33  	intptr_t ptr;
34  	intptr_t CallPointer(Message msg, uintptr_t wParam, void *s);
35  	intptr_t CallString(Message msg, uintptr_t wParam, const char *s);
36  	std::string CallReturnString(Message msg, uintptr_t wParam);
37  public:
38  	Scintilla::Status statusLastCall;
39  	ScintillaCall() noexcept;
40  	void SetFnPtr(FunctionDirect fn_, intptr_t ptr_) noexcept;
41  	bool IsValid() const noexcept;
42  	intptr_t Call(Message msg, uintptr_t wParam=0, intptr_t lParam=0);
43  	Position LineStart(Line line);
44  	Position LineEnd(Line line);
45  	Span SelectionSpan();
46  	Span TargetSpan();
47  	void SetTarget(Span span);
48  	void ColouriseAll();
49  	char CharacterAt(Position position);
50  	int UnsignedStyleAt(Position position);
51  	std::string StringOfSpan(Span span);
52  	std::string StringOfRange(Span span);
53  	Position ReplaceTarget(std::string_view text);
54  	Position ReplaceTargetRE(std::string_view text);
55  	Position ReplaceTargetMinimal(std::string_view text);
56  	Position SearchInTarget(std::string_view text);
57  	Span SpanSearchInTarget(std::string_view text);
58  /&bsol;**\(\*\n\)
59  	void AddText(Position length, const char *text);
60  	void AddStyledText(Position length, const char *c);
61  	void InsertText(Position pos, const char *text);
62  	void ChangeInsertion(Position length, const char *text);
63  	void ClearAll();
64  	void DeleteRange(Position start, Position lengthDelete);
65  	void ClearDocumentStyle();
66  	Position Length();
67  	int CharAt(Position pos);
68  	Position CurrentPos();
69  	Position Anchor();
70  	int StyleAt(Position pos);
71  	int StyleIndexAt(Position pos);
72  	void Redo();
73  	void SetUndoCollection(bool collectUndo);
74  	void SelectAll();
75  	void SetSavePoint();
76  	Position GetStyledText(void *tr);
77  	Position GetStyledTextFull(TextRangeFull *tr);
78  	bool CanRedo();
79  	Line MarkerLineFromHandle(int markerHandle);
80  	void MarkerDeleteHandle(int markerHandle);
81  	int MarkerHandleFromLine(Line line, int which);
82  	int MarkerNumberFromLine(Line line, int which);
83  	bool UndoCollection();
84  	Scintilla::WhiteSpace ViewWS();
85  	void SetViewWS(Scintilla::WhiteSpace viewWS);
86  	Scintilla::TabDrawMode TabDrawMode();
87  	void SetTabDrawMode(Scintilla::TabDrawMode tabDrawMode);
88  	Position PositionFromPoint(int x, int y);
89  	Position PositionFromPointClose(int x, int y);
90  	void GotoLine(Line line);
91  	void GotoPos(Position caret);
92  	void SetAnchor(Position anchor);
93  	Position GetCurLine(Position length, char *text);
94  	std::string GetCurLine(Position length);
95  	Position EndStyled();
96  	void ConvertEOLs(Scintilla::EndOfLine eolMode);
97  	Scintilla::EndOfLine EOLMode();
98  	void SetEOLMode(Scintilla::EndOfLine eolMode);
99  	void StartStyling(Position start, int unused);
100  	void SetStyling(Position length, int style);
101  	bool BufferedDraw();
102  	void SetBufferedDraw(bool buffered);
103  	void SetTabWidth(int tabWidth);
104  	int TabWidth();
105  	void SetTabMinimumWidth(int pixels);
106  	int TabMinimumWidth();
107  	void ClearTabStops(Line line);
108  	void AddTabStop(Line line, int x);
109  	int GetNextTabStop(Line line, int x);
110  	void SetCodePage(int codePage);
111  	void SetFontLocale(const char *localeName);
112  	int FontLocale(char *localeName);
113  	std::string FontLocale();
114  	Scintilla::IMEInteraction IMEInteraction();
115  	void SetIMEInteraction(Scintilla::IMEInteraction imeInteraction);
116  	void MarkerDefine(int markerNumber, Scintilla::MarkerSymbol markerSymbol);
117  	void MarkerSetFore(int markerNumber, Colour fore);
118  	void MarkerSetBack(int markerNumber, Colour back);
119  	void MarkerSetBackSelected(int markerNumber, Colour back);
120  	void MarkerSetForeTranslucent(int markerNumber, ColourAlpha fore);
121  	void MarkerSetBackTranslucent(int markerNumber, ColourAlpha back);
122  	void MarkerSetBackSelectedTranslucent(int markerNumber, ColourAlpha back);
123  	void MarkerSetStrokeWidth(int markerNumber, int hundredths);
124  	void MarkerEnableHighlight(bool enabled);
125  	int MarkerAdd(Line line, int markerNumber);
126  	void MarkerDelete(Line line, int markerNumber);
127  	void MarkerDeleteAll(int markerNumber);
128  	int MarkerGet(Line line);
129  	Line MarkerNext(Line lineStart, int markerMask);
130  	Line MarkerPrevious(Line lineStart, int markerMask);
131  	void MarkerDefinePixmap(int markerNumber, const char *pixmap);
132  	void MarkerAddSet(Line line, int markerSet);
133  	void MarkerSetAlpha(int markerNumber, Scintilla::Alpha alpha);
134  	Scintilla::Layer MarkerGetLayer(int markerNumber);
135  	void MarkerSetLayer(int markerNumber, Scintilla::Layer layer);
136  	void SetMarginTypeN(int margin, Scintilla::MarginType marginType);
137  	Scintilla::MarginType MarginTypeN(int margin);
138  	void SetMarginWidthN(int margin, int pixelWidth);
139  	int MarginWidthN(int margin);
140  	void SetMarginMaskN(int margin, int mask);
141  	int MarginMaskN(int margin);
142  	void SetMarginSensitiveN(int margin, bool sensitive);
143  	bool MarginSensitiveN(int margin);
144  	void SetMarginCursorN(int margin, Scintilla::CursorShape cursor);
145  	Scintilla::CursorShape MarginCursorN(int margin);
146  	void SetMarginBackN(int margin, Colour back);
147  	Colour MarginBackN(int margin);
148  	void SetMargins(int margins);
149  	int Margins();
150  	void StyleClearAll();
151  	void StyleSetFore(int style, Colour fore);
152  	void StyleSetBack(int style, Colour back);
153  	void StyleSetBold(int style, bool bold);
154  	void StyleSetItalic(int style, bool italic);
155  	void StyleSetSize(int style, int sizePoints);
156  	void StyleSetFont(int style, const char *fontName);
157  	void StyleSetEOLFilled(int style, bool eolFilled);
158  	void StyleResetDefault();
159  	void StyleSetUnderline(int style, bool underline);
160  	Colour StyleGetFore(int style);
161  	Colour StyleGetBack(int style);
162  	bool StyleGetBold(int style);
163  	bool StyleGetItalic(int style);
164  	int StyleGetSize(int style);
165  	int StyleGetFont(int style, char *fontName);
166  	std::string StyleGetFont(int style);
167  	bool StyleGetEOLFilled(int style);
168  	bool StyleGetUnderline(int style);
169  	Scintilla::CaseVisible StyleGetCase(int style);
170  	Scintilla::CharacterSet StyleGetCharacterSet(int style);
171  	bool StyleGetVisible(int style);
172  	bool StyleGetChangeable(int style);
173  	bool StyleGetHotSpot(int style);
174  	void StyleSetCase(int style, Scintilla::CaseVisible caseVisible);
175  	void StyleSetSizeFractional(int style, int sizeHundredthPoints);
176  	int StyleGetSizeFractional(int style);
177  	void StyleSetWeight(int style, Scintilla::FontWeight weight);
178  	Scintilla::FontWeight StyleGetWeight(int style);
179  	void StyleSetCharacterSet(int style, Scintilla::CharacterSet characterSet);
180  	void StyleSetHotSpot(int style, bool hotspot);
181  	void StyleSetCheckMonospaced(int style, bool checkMonospaced);
182  	bool StyleGetCheckMonospaced(int style);
183  	void StyleSetInvisibleRepresentation(int style, const char *representation);
184  	int StyleGetInvisibleRepresentation(int style, char *representation);
185  	std::string StyleGetInvisibleRepresentation(int style);
186  	void SetElementColour(Scintilla::Element element, ColourAlpha colourElement);
187  	ColourAlpha ElementColour(Scintilla::Element element);
188  	void ResetElementColour(Scintilla::Element element);
189  	bool ElementIsSet(Scintilla::Element element);
190  	bool ElementAllowsTranslucent(Scintilla::Element element);
191  	ColourAlpha ElementBaseColour(Scintilla::Element element);
192  	void SetSelFore(bool useSetting, Colour fore);
193  	void SetSelBack(bool useSetting, Colour back);
194  	Scintilla::Alpha SelAlpha();
195  	void SetSelAlpha(Scintilla::Alpha alpha);
196  	bool SelEOLFilled();
197  	void SetSelEOLFilled(bool filled);
198  	Scintilla::Layer SelectionLayer();
199  	void SetSelectionLayer(Scintilla::Layer layer);
200  	Scintilla::Layer CaretLineLayer();
201  	void SetCaretLineLayer(Scintilla::Layer layer);
202  	bool CaretLineHighlightSubLine();
203  	void SetCaretLineHighlightSubLine(bool subLine);
204  	void SetCaretFore(Colour fore);
205  	void AssignCmdKey(int keyDefinition, int sciCommand);
206  	void ClearCmdKey(int keyDefinition);
207  	void ClearAllCmdKeys();
208  	void SetStylingEx(Position length, const char *styles);
209  	void StyleSetVisible(int style, bool visible);
210  	int CaretPeriod();
211  	void SetCaretPeriod(int periodMilliseconds);
212  	void SetWordChars(const char *characters);
213  	int WordChars(char *characters);
214  	std::string WordChars();
215  	void SetCharacterCategoryOptimization(int countCharacters);
216  	int CharacterCategoryOptimization();
217  	void BeginUndoAction();
218  	void EndUndoAction();
219  	void IndicSetStyle(int indicator, Scintilla::IndicatorStyle indicatorStyle);
220  	Scintilla::IndicatorStyle IndicGetStyle(int indicator);
221  	void IndicSetFore(int indicator, Colour fore);
222  	Colour IndicGetFore(int indicator);
223  	void IndicSetUnder(int indicator, bool under);
224  	bool IndicGetUnder(int indicator);
225  	void IndicSetHoverStyle(int indicator, Scintilla::IndicatorStyle indicatorStyle);
226  	Scintilla::IndicatorStyle IndicGetHoverStyle(int indicator);
227  	void IndicSetHoverFore(int indicator, Colour fore);
228  	Colour IndicGetHoverFore(int indicator);
229  	void IndicSetFlags(int indicator, Scintilla::IndicFlag flags);
230  	Scintilla::IndicFlag IndicGetFlags(int indicator);
231  	void IndicSetStrokeWidth(int indicator, int hundredths);
232  	int IndicGetStrokeWidth(int indicator);
233  	void SetWhitespaceFore(bool useSetting, Colour fore);
234  	void SetWhitespaceBack(bool useSetting, Colour back);
235  	void SetWhitespaceSize(int size);
236  	int WhitespaceSize();
237  	void SetLineState(Line line, int state);
238  	int LineState(Line line);
239  	int MaxLineState();
240  	bool CaretLineVisible();
241  	void SetCaretLineVisible(bool show);
242  	Colour CaretLineBack();
243  	void SetCaretLineBack(Colour back);
244  	int CaretLineFrame();
245  	void SetCaretLineFrame(int width);
246  	void StyleSetChangeable(int style, bool changeable);
247  	void AutoCShow(Position lengthEntered, const char *itemList);
248  	void AutoCCancel();
249  	bool AutoCActive();
250  	Position AutoCPosStart();
251  	void AutoCComplete();
252  	void AutoCStops(const char *characterSet);
253  	void AutoCSetSeparator(int separatorCharacter);
254  	int AutoCGetSeparator();
255  	void AutoCSelect(const char *select);
256  	void AutoCSetCancelAtStart(bool cancel);
257  	bool AutoCGetCancelAtStart();
258  	void AutoCSetFillUps(const char *characterSet);
259  	void AutoCSetChooseSingle(bool chooseSingle);
260  	bool AutoCGetChooseSingle();
261  	void AutoCSetIgnoreCase(bool ignoreCase);
262  	bool AutoCGetIgnoreCase();
263  	void UserListShow(int listType, const char *itemList);
264  	void AutoCSetAutoHide(bool autoHide);
265  	bool AutoCGetAutoHide();
266  	void AutoCSetOptions(Scintilla::AutoCompleteOption options);
267  	Scintilla::AutoCompleteOption AutoCGetOptions();
268  	void AutoCSetDropRestOfWord(bool dropRestOfWord);
269  	bool AutoCGetDropRestOfWord();
270  	void RegisterImage(int type, const char *xpmData);
271  	void ClearRegisteredImages();
272  	int AutoCGetTypeSeparator();
273  	void AutoCSetTypeSeparator(int separatorCharacter);
274  	void AutoCSetMaxWidth(int characterCount);
275  	int AutoCGetMaxWidth();
276  	void AutoCSetMaxHeight(int rowCount);
277  	int AutoCGetMaxHeight();
278  	void SetIndent(int indentSize);
279  	int Indent();
280  	void SetUseTabs(bool useTabs);
281  	bool UseTabs();
282  	void SetLineIndentation(Line line, int indentation);
283  	int LineIndentation(Line line);
284  	Position LineIndentPosition(Line line);
285  	Position Column(Position pos);
286  	Position CountCharacters(Position start, Position end);
287  	Position CountCodeUnits(Position start, Position end);
288  	void SetHScrollBar(bool visible);
289  	bool HScrollBar();
290  	void SetIndentationGuides(Scintilla::IndentView indentView);
291  	Scintilla::IndentView IndentationGuides();
292  	void SetHighlightGuide(Position column);
293  	Position HighlightGuide();
294  	Position LineEndPosition(Line line);
295  	int CodePage();
296  	Colour CaretFore();
297  	bool ReadOnly();
298  	void SetCurrentPos(Position caret);
299  	void SetSelectionStart(Position anchor);
300  	Position SelectionStart();
301  	void SetSelectionEnd(Position caret);
302  	Position SelectionEnd();
303  	void SetEmptySelection(Position caret);
304  	void SetPrintMagnification(int magnification);
305  	int PrintMagnification();
306  	void SetPrintColourMode(Scintilla::PrintOption mode);
307  	Scintilla::PrintOption PrintColourMode();
308  	Position FindText(Scintilla::FindOption searchFlags, void *ft);
309  	Position FindTextFull(Scintilla::FindOption searchFlags, TextToFindFull *ft);
310  	Position FormatRange(bool draw, void *fr);
311  	Position FormatRangeFull(bool draw, RangeToFormatFull *fr);
312  	void SetChangeHistory(Scintilla::ChangeHistoryOption changeHistory);
313  	Scintilla::ChangeHistoryOption ChangeHistory();
314  	Line FirstVisibleLine();
315  	Position GetLine(Line line, char *text);
316  	std::string GetLine(Line line);
317  	Line LineCount();
318  	void AllocateLines(Line lines);
319  	void SetMarginLeft(int pixelWidth);
320  	int MarginLeft();
321  	void SetMarginRight(int pixelWidth);
322  	int MarginRight();
323  	bool Modify();
324  	void SetSel(Position anchor, Position caret);
325  	Position GetSelText(char *text);
326  	std::string GetSelText();
327  	Position GetTextRange(void *tr);
328  	Position GetTextRangeFull(TextRangeFull *tr);
329  	void HideSelection(bool hide);
330  	bool SelectionHidden();
331  	int PointXFromPosition(Position pos);
332  	int PointYFromPosition(Position pos);
333  	Line LineFromPosition(Position pos);
334  	Position PositionFromLine(Line line);
335  	void LineScroll(Position columns, Line lines);
336  	void ScrollCaret();
337  	void ScrollRange(Position secondary, Position primary);
338  	void ReplaceSel(const char *text);
339  	void SetReadOnly(bool readOnly);
340  	void Null();
341  	bool CanPaste();
342  	bool CanUndo();
343  	void EmptyUndoBuffer();
344  	void Undo();
345  	void Cut();
346  	void Copy();
347  	void Paste();
348  	void Clear();
349  	void SetText(const char *text);
350  	Position GetText(Position length, char *text);
351  	std::string GetText(Position length);
352  	Position TextLength();
353  	void *DirectFunction();
354  	void *DirectStatusFunction();
355  	void *DirectPointer();
356  	void SetOvertype(bool overType);
357  	bool Overtype();
358  	void SetCaretWidth(int pixelWidth);
359  	int CaretWidth();
360  	void SetTargetStart(Position start);
361  	Position TargetStart();
362  	void SetTargetStartVirtualSpace(Position space);
363  	Position TargetStartVirtualSpace();
364  	void SetTargetEnd(Position end);
365  	Position TargetEnd();
366  	void SetTargetEndVirtualSpace(Position space);
367  	Position TargetEndVirtualSpace();
368  	void SetTargetRange(Position start, Position end);
<span onclick='openModal()' class='match'>369  	Position TargetText(char *text);
370  	std::string TargetText();
371  	void TargetFromSelection();
372  	void TargetWholeDocument();
373  	Position ReplaceTarget(Position length, const char *text);
374  	Position ReplaceTargetRE(Position length, const char *text);
375  	Position ReplaceTargetMinimal(Position length, const char *text);
376  	Position SearchInTarget(Position length, const char *text);
377  	void SetSearchFlags(Scintilla::FindOption searchFlags);
378  	Scintilla::FindOption SearchFlags();
379  	void CallTipShow(Position pos, const char *definition);
</span>380  	void CallTipCancel();
381  	bool CallTipActive();
382  	Position CallTipPosStart();
383  	void CallTipSetPosStart(Position posStart);
384  	void CallTipSetHlt(Position highlightStart, Position highlightEnd);
385  	void CallTipSetBack(Colour back);
386  	void CallTipSetFore(Colour fore);
387  	void CallTipSetForeHlt(Colour fore);
388  	void CallTipUseStyle(int tabSize);
389  	void CallTipSetPosition(bool above);
390  	Line VisibleFromDocLine(Line docLine);
391  	Line DocLineFromVisible(Line displayLine);
392  	Line WrapCount(Line docLine);
393  	void SetFoldLevel(Line line, Scintilla::FoldLevel level);
394  	Scintilla::FoldLevel FoldLevel(Line line);
395  	Line LastChild(Line line, Scintilla::FoldLevel level);
396  	Line FoldParent(Line line);
397  	void ShowLines(Line lineStart, Line lineEnd);
398  	void HideLines(Line lineStart, Line lineEnd);
399  	bool LineVisible(Line line);
400  	bool AllLinesVisible();
401  	void SetFoldExpanded(Line line, bool expanded);
402  	bool FoldExpanded(Line line);
403  	void ToggleFold(Line line);
404  	void ToggleFoldShowText(Line line, const char *text);
405  	void FoldDisplayTextSetStyle(Scintilla::FoldDisplayTextStyle style);
406  	Scintilla::FoldDisplayTextStyle FoldDisplayTextGetStyle();
407  	void SetDefaultFoldDisplayText(const char *text);
408  	int GetDefaultFoldDisplayText(char *text);
409  	std::string GetDefaultFoldDisplayText();
410  	void FoldLine(Line line, Scintilla::FoldAction action);
411  	void FoldChildren(Line line, Scintilla::FoldAction action);
412  	void ExpandChildren(Line line, Scintilla::FoldLevel level);
413  	void FoldAll(Scintilla::FoldAction action);
414  	void EnsureVisible(Line line);
415  	void SetAutomaticFold(Scintilla::AutomaticFold automaticFold);
416  	Scintilla::AutomaticFold AutomaticFold();
417  	void SetFoldFlags(Scintilla::FoldFlag flags);
418  	void EnsureVisibleEnforcePolicy(Line line);
419  	void SetTabIndents(bool tabIndents);
420  	bool TabIndents();
421  	void SetBackSpaceUnIndents(bool bsUnIndents);
422  	bool BackSpaceUnIndents();
423  	void SetMouseDwellTime(int periodMilliseconds);
424  	int MouseDwellTime();
425  	Position WordStartPosition(Position pos, bool onlyWordCharacters);
426  	Position WordEndPosition(Position pos, bool onlyWordCharacters);
427  	bool IsRangeWord(Position start, Position end);
428  	void SetIdleStyling(Scintilla::IdleStyling idleStyling);
429  	Scintilla::IdleStyling IdleStyling();
430  	void SetWrapMode(Scintilla::Wrap wrapMode);
431  	Scintilla::Wrap WrapMode();
432  	void SetWrapVisualFlags(Scintilla::WrapVisualFlag wrapVisualFlags);
433  	Scintilla::WrapVisualFlag WrapVisualFlags();
434  	void SetWrapVisualFlagsLocation(Scintilla::WrapVisualLocation wrapVisualFlagsLocation);
435  	Scintilla::WrapVisualLocation WrapVisualFlagsLocation();
436  	void SetWrapStartIndent(int indent);
437  	int WrapStartIndent();
438  	void SetWrapIndentMode(Scintilla::WrapIndentMode wrapIndentMode);
439  	Scintilla::WrapIndentMode WrapIndentMode();
440  	void SetLayoutCache(Scintilla::LineCache cacheMode);
441  	Scintilla::LineCache LayoutCache();
442  	void SetScrollWidth(int pixelWidth);
443  	int ScrollWidth();
444  	void SetScrollWidthTracking(bool tracking);
445  	bool ScrollWidthTracking();
446  	int TextWidth(int style, const char *text);
447  	void SetEndAtLastLine(bool endAtLastLine);
448  	bool EndAtLastLine();
449  	int TextHeight(Line line);
450  	void SetVScrollBar(bool visible);
451  	bool VScrollBar();
452  	void AppendText(Position length, const char *text);
453  	Scintilla::PhasesDraw PhasesDraw();
454  	void SetPhasesDraw(Scintilla::PhasesDraw phases);
455  	void SetFontQuality(Scintilla::FontQuality fontQuality);
456  	Scintilla::FontQuality FontQuality();
457  	void SetFirstVisibleLine(Line displayLine);
458  	void SetMultiPaste(Scintilla::MultiPaste multiPaste);
459  	Scintilla::MultiPaste MultiPaste();
460  	int Tag(int tagNumber, char *tagValue);
461  	std::string Tag(int tagNumber);
462  	void LinesJoin();
463  	void LinesSplit(int pixelWidth);
464  	void SetFoldMarginColour(bool useSetting, Colour back);
465  	void SetFoldMarginHiColour(bool useSetting, Colour fore);
466  	void SetAccessibility(Scintilla::Accessibility accessibility);
467  	Scintilla::Accessibility Accessibility();
468  	void LineDown();
469  	void LineDownExtend();
470  	void LineUp();
471  	void LineUpExtend();
472  	void CharLeft();
473  	void CharLeftExtend();
474  	void CharRight();
475  	void CharRightExtend();
476  	void WordLeft();
477  	void WordLeftExtend();
478  	void WordRight();
479  	void WordRightExtend();
480  	void Home();
481  	void HomeExtend();
482  	void LineEnd();
483  	void LineEndExtend();
484  	void DocumentStart();
485  	void DocumentStartExtend();
486  	void DocumentEnd();
487  	void DocumentEndExtend();
488  	void PageUp();
489  	void PageUpExtend();
490  	void PageDown();
491  	void PageDownExtend();
492  	void EditToggleOvertype();
493  	void Cancel();
494  	void DeleteBack();
495  	void Tab();
496  	void BackTab();
497  	void NewLine();
498  	void FormFeed();
499  	void VCHome();
500  	void VCHomeExtend();
501  	void ZoomIn();
502  	void ZoomOut();
503  	void DelWordLeft();
504  	void DelWordRight();
505  	void DelWordRightEnd();
506  	void LineCut();
507  	void LineDelete();
508  	void LineTranspose();
509  	void LineReverse();
510  	void LineDuplicate();
511  	void LowerCase();
512  	void UpperCase();
513  	void LineScrollDown();
514  	void LineScrollUp();
515  	void DeleteBackNotLine();
516  	void HomeDisplay();
517  	void HomeDisplayExtend();
518  	void LineEndDisplay();
519  	void LineEndDisplayExtend();
520  	void HomeWrap();
521  	void HomeWrapExtend();
522  	void LineEndWrap();
523  	void LineEndWrapExtend();
524  	void VCHomeWrap();
525  	void VCHomeWrapExtend();
526  	void LineCopy();
527  	void MoveCaretInsideView();
528  	Position LineLength(Line line);
529  	void BraceHighlight(Position posA, Position posB);
530  	void BraceHighlightIndicator(bool useSetting, int indicator);
531  	void BraceBadLight(Position pos);
532  	void BraceBadLightIndicator(bool useSetting, int indicator);
533  	Position BraceMatch(Position pos, int maxReStyle);
534  	Position BraceMatchNext(Position pos, Position startPos);
535  	bool ViewEOL();
536  	void SetViewEOL(bool visible);
537  	void *DocPointer();
538  	void SetDocPointer(void *doc);
539  	void SetModEventMask(Scintilla::ModificationFlags eventMask);
540  	Position EdgeColumn();
541  	void SetEdgeColumn(Position column);
542  	Scintilla::EdgeVisualStyle EdgeMode();
543  	void SetEdgeMode(Scintilla::EdgeVisualStyle edgeMode);
544  	Colour EdgeColour();
545  	void SetEdgeColour(Colour edgeColour);
546  	void MultiEdgeAddLine(Position column, Colour edgeColour);
547  	void MultiEdgeClearAll();
548  	Position MultiEdgeColumn(int which);
549  	void SearchAnchor();
550  	Position SearchNext(Scintilla::FindOption searchFlags, const char *text);
551  	Position SearchPrev(Scintilla::FindOption searchFlags, const char *text);
552  	Line LinesOnScreen();
553  	void UsePopUp(Scintilla::PopUp popUpMode);
554  	bool SelectionIsRectangle();
555  	void SetZoom(int zoomInPoints);
556  	int Zoom();
557  	void *CreateDocument(Position bytes, Scintilla::DocumentOption documentOptions);
558  	void AddRefDocument(void *doc);
559  	void ReleaseDocument(void *doc);
560  	Scintilla::DocumentOption DocumentOptions();
561  	Scintilla::ModificationFlags ModEventMask();
562  	void SetCommandEvents(bool commandEvents);
563  	bool CommandEvents();
564  	void SetFocus(bool focus);
565  	bool Focus();
566  	void SetStatus(Scintilla::Status status);
567  	Scintilla::Status Status();
568  	void SetMouseDownCaptures(bool captures);
569  	bool MouseDownCaptures();
570  	void SetMouseWheelCaptures(bool captures);
571  	bool MouseWheelCaptures();
572  	void SetCursor(Scintilla::CursorShape cursorType);
573  	Scintilla::CursorShape Cursor();
574  	void SetControlCharSymbol(int symbol);
575  	int ControlCharSymbol();
576  	void WordPartLeft();
577  	void WordPartLeftExtend();
578  	void WordPartRight();
579  	void WordPartRightExtend();
580  	void SetVisiblePolicy(Scintilla::VisiblePolicy visiblePolicy, int visibleSlop);
581  	void DelLineLeft();
582  	void DelLineRight();
583  	void SetXOffset(int xOffset);
584  	int XOffset();
585  	void ChooseCaretX();
586  	void GrabFocus();
587  	void SetXCaretPolicy(Scintilla::CaretPolicy caretPolicy, int caretSlop);
588  	void SetYCaretPolicy(Scintilla::CaretPolicy caretPolicy, int caretSlop);
589  	void SetPrintWrapMode(Scintilla::Wrap wrapMode);
590  	Scintilla::Wrap PrintWrapMode();
591  	void SetHotspotActiveFore(bool useSetting, Colour fore);
592  	Colour HotspotActiveFore();
593  	void SetHotspotActiveBack(bool useSetting, Colour back);
594  	Colour HotspotActiveBack();
595  	void SetHotspotActiveUnderline(bool underline);
596  	bool HotspotActiveUnderline();
597  	void SetHotspotSingleLine(bool singleLine);
598  	bool HotspotSingleLine();
599  	void ParaDown();
600  	void ParaDownExtend();
601  	void ParaUp();
602  	void ParaUpExtend();
603  	Position PositionBefore(Position pos);
604  	Position PositionAfter(Position pos);
605  	Position PositionRelative(Position pos, Position relative);
606  	Position PositionRelativeCodeUnits(Position pos, Position relative);
607  	void CopyRange(Position start, Position end);
608  	void CopyText(Position length, const char *text);
609  	void SetSelectionMode(Scintilla::SelectionMode selectionMode);
610  	Scintilla::SelectionMode SelectionMode();
611  	bool MoveExtendsSelection();
612  	Position GetLineSelStartPosition(Line line);
613  	Position GetLineSelEndPosition(Line line);
614  	void LineDownRectExtend();
615  	void LineUpRectExtend();
616  	void CharLeftRectExtend();
617  	void CharRightRectExtend();
618  	void HomeRectExtend();
619  	void VCHomeRectExtend();
620  	void LineEndRectExtend();
621  	void PageUpRectExtend();
622  	void PageDownRectExtend();
623  	void StutteredPageUp();
624  	void StutteredPageUpExtend();
625  	void StutteredPageDown();
626  	void StutteredPageDownExtend();
627  	void WordLeftEnd();
628  	void WordLeftEndExtend();
629  	void WordRightEnd();
630  	void WordRightEndExtend();
631  	void SetWhitespaceChars(const char *characters);
632  	int WhitespaceChars(char *characters);
633  	std::string WhitespaceChars();
634  	void SetPunctuationChars(const char *characters);
635  	int PunctuationChars(char *characters);
636  	std::string PunctuationChars();
637  	void SetCharsDefault();
638  	int AutoCGetCurrent();
639  	int AutoCGetCurrentText(char *text);
640  	std::string AutoCGetCurrentText();
641  	void AutoCSetCaseInsensitiveBehaviour(Scintilla::CaseInsensitiveBehaviour behaviour);
642  	Scintilla::CaseInsensitiveBehaviour AutoCGetCaseInsensitiveBehaviour();
643  	void AutoCSetMulti(Scintilla::MultiAutoComplete multi);
644  	Scintilla::MultiAutoComplete AutoCGetMulti();
645  	void AutoCSetOrder(Scintilla::Ordering order);
646  	Scintilla::Ordering AutoCGetOrder();
647  	void Allocate(Position bytes);
648  	Position TargetAsUTF8(char *s);
649  	std::string TargetAsUTF8();
650  	void SetLengthForEncode(Position bytes);
651  	Position EncodedFromUTF8(const char *utf8, char *encoded);
652  	std::string EncodedFromUTF8(const char *utf8);
653  	Position FindColumn(Line line, Position column);
654  	Scintilla::CaretSticky CaretSticky();
655  	void SetCaretSticky(Scintilla::CaretSticky useCaretStickyBehaviour);
656  	void ToggleCaretSticky();
657  	void SetPasteConvertEndings(bool convert);
658  	bool PasteConvertEndings();
659  	void ReplaceRectangular(Position length, const char *text);
660  	void SelectionDuplicate();
661  	void SetCaretLineBackAlpha(Scintilla::Alpha alpha);
662  	Scintilla::Alpha CaretLineBackAlpha();
663  	void SetCaretStyle(Scintilla::CaretStyle caretStyle);
664  	Scintilla::CaretStyle CaretStyle();
665  	void SetIndicatorCurrent(int indicator);
666  	int IndicatorCurrent();
667  	void SetIndicatorValue(int value);
668  	int IndicatorValue();
669  	void IndicatorFillRange(Position start, Position lengthFill);
670  	void IndicatorClearRange(Position start, Position lengthClear);
671  	int IndicatorAllOnFor(Position pos);
672  	int IndicatorValueAt(int indicator, Position pos);
673  	Position IndicatorStart(int indicator, Position pos);
674  	Position IndicatorEnd(int indicator, Position pos);
675  	void SetPositionCache(int size);
676  	int PositionCache();
677  	void SetLayoutThreads(int threads);
678  	int LayoutThreads();
679  	void CopyAllowLine();
680  	void *CharacterPointer();
681  	void *RangePointer(Position start, Position lengthRange);
682  	Position GapPosition();
683  	void IndicSetAlpha(int indicator, Scintilla::Alpha alpha);
684  	Scintilla::Alpha IndicGetAlpha(int indicator);
685  	void IndicSetOutlineAlpha(int indicator, Scintilla::Alpha alpha);
686  	Scintilla::Alpha IndicGetOutlineAlpha(int indicator);
687  	void SetExtraAscent(int extraAscent);
688  	int ExtraAscent();
689  	void SetExtraDescent(int extraDescent);
690  	int ExtraDescent();
691  	int MarkerSymbolDefined(int markerNumber);
692  	void MarginSetText(Line line, const char *text);
693  	int MarginGetText(Line line, char *text);
694  	std::string MarginGetText(Line line);
695  	void MarginSetStyle(Line line, int style);
696  	int MarginGetStyle(Line line);
697  	void MarginSetStyles(Line line, const char *styles);
698  	int MarginGetStyles(Line line, char *styles);
699  	std::string MarginGetStyles(Line line);
700  	void MarginTextClearAll();
701  	void MarginSetStyleOffset(int style);
702  	int MarginGetStyleOffset();
703  	void SetMarginOptions(Scintilla::MarginOption marginOptions);
704  	Scintilla::MarginOption MarginOptions();
705  	void AnnotationSetText(Line line, const char *text);
706  	int AnnotationGetText(Line line, char *text);
707  	std::string AnnotationGetText(Line line);
708  	void AnnotationSetStyle(Line line, int style);
709  	int AnnotationGetStyle(Line line);
710  	void AnnotationSetStyles(Line line, const char *styles);
711  	int AnnotationGetStyles(Line line, char *styles);
712  	std::string AnnotationGetStyles(Line line);
713  	int AnnotationGetLines(Line line);
714  	void AnnotationClearAll();
715  	void AnnotationSetVisible(Scintilla::AnnotationVisible visible);
716  	Scintilla::AnnotationVisible AnnotationGetVisible();
717  	void AnnotationSetStyleOffset(int style);
718  	int AnnotationGetStyleOffset();
719  	void ReleaseAllExtendedStyles();
720  	int AllocateExtendedStyles(int numberStyles);
721  	void AddUndoAction(int token, Scintilla::UndoFlags flags);
722  	Position CharPositionFromPoint(int x, int y);
723  	Position CharPositionFromPointClose(int x, int y);
724  	void SetMouseSelectionRectangularSwitch(bool mouseSelectionRectangularSwitch);
725  	bool MouseSelectionRectangularSwitch();
726  	void SetMultipleSelection(bool multipleSelection);
727  	bool MultipleSelection();
728  	void SetAdditionalSelectionTyping(bool additionalSelectionTyping);
729  	bool AdditionalSelectionTyping();
730  	void SetAdditionalCaretsBlink(bool additionalCaretsBlink);
731  	bool AdditionalCaretsBlink();
732  	void SetAdditionalCaretsVisible(bool additionalCaretsVisible);
733  	bool AdditionalCaretsVisible();
734  	int Selections();
735  	bool SelectionEmpty();
736  	void ClearSelections();
737  	void SetSelection(Position caret, Position anchor);
738  	void AddSelection(Position caret, Position anchor);
739  	void DropSelectionN(int selection);
740  	void SetMainSelection(int selection);
741  	int MainSelection();
742  	void SetSelectionNCaret(int selection, Position caret);
743  	Position SelectionNCaret(int selection);
744  	void SetSelectionNAnchor(int selection, Position anchor);
745  	Position SelectionNAnchor(int selection);
746  	void SetSelectionNCaretVirtualSpace(int selection, Position space);
747  	Position SelectionNCaretVirtualSpace(int selection);
748  	void SetSelectionNAnchorVirtualSpace(int selection, Position space);
749  	Position SelectionNAnchorVirtualSpace(int selection);
750  	void SetSelectionNStart(int selection, Position anchor);
751  	Position SelectionNStart(int selection);
752  	Position SelectionNStartVirtualSpace(int selection);
753  	void SetSelectionNEnd(int selection, Position caret);
754  	Position SelectionNEndVirtualSpace(int selection);
755  	Position SelectionNEnd(int selection);
756  	void SetRectangularSelectionCaret(Position caret);
757  	Position RectangularSelectionCaret();
758  	void SetRectangularSelectionAnchor(Position anchor);
759  	Position RectangularSelectionAnchor();
760  	void SetRectangularSelectionCaretVirtualSpace(Position space);
761  	Position RectangularSelectionCaretVirtualSpace();
762  	void SetRectangularSelectionAnchorVirtualSpace(Position space);
763  	Position RectangularSelectionAnchorVirtualSpace();
764  	void SetVirtualSpaceOptions(Scintilla::VirtualSpace virtualSpaceOptions);
765  	Scintilla::VirtualSpace VirtualSpaceOptions();
766  	void SetRectangularSelectionModifier(int modifier);
767  	int RectangularSelectionModifier();
768  	void SetAdditionalSelFore(Colour fore);
769  	void SetAdditionalSelBack(Colour back);
770  	void SetAdditionalSelAlpha(Scintilla::Alpha alpha);
771  	Scintilla::Alpha AdditionalSelAlpha();
772  	void SetAdditionalCaretFore(Colour fore);
773  	Colour AdditionalCaretFore();
774  	void RotateSelection();
775  	void SwapMainAnchorCaret();
776  	void MultipleSelectAddNext();
777  	void MultipleSelectAddEach();
778  	int ChangeLexerState(Position start, Position end);
779  	Line ContractedFoldNext(Line lineStart);
780  	void VerticalCentreCaret();
781  	void MoveSelectedLinesUp();
782  	void MoveSelectedLinesDown();
783  	void SetIdentifier(int identifier);
784  	int Identifier();
785  	void RGBAImageSetWidth(int width);
786  	void RGBAImageSetHeight(int height);
787  	void RGBAImageSetScale(int scalePercent);
788  	void MarkerDefineRGBAImage(int markerNumber, const char *pixels);
789  	void RegisterRGBAImage(int type, const char *pixels);
790  	void ScrollToStart();
791  	void ScrollToEnd();
792  	void SetTechnology(Scintilla::Technology technology);
793  	Scintilla::Technology Technology();
794  	void *CreateLoader(Position bytes, Scintilla::DocumentOption documentOptions);
795  	void FindIndicatorShow(Position start, Position end);
796  	void FindIndicatorFlash(Position start, Position end);
797  	void FindIndicatorHide();
798  	void VCHomeDisplay();
799  	void VCHomeDisplayExtend();
800  	bool CaretLineVisibleAlways();
801  	void SetCaretLineVisibleAlways(bool alwaysVisible);
802  	void SetLineEndTypesAllowed(Scintilla::LineEndType lineEndBitSet);
803  	Scintilla::LineEndType LineEndTypesAllowed();
804  	Scintilla::LineEndType LineEndTypesActive();
805  	void SetRepresentation(const char *encodedCharacter, const char *representation);
806  	int Representation(const char *encodedCharacter, char *representation);
807  	std::string Representation(const char *encodedCharacter);
808  	void ClearRepresentation(const char *encodedCharacter);
809  	void ClearAllRepresentations();
810  	void SetRepresentationAppearance(const char *encodedCharacter, Scintilla::RepresentationAppearance appearance);
811  	Scintilla::RepresentationAppearance RepresentationAppearance(const char *encodedCharacter);
812  	void SetRepresentationColour(const char *encodedCharacter, ColourAlpha colour);
813  	ColourAlpha RepresentationColour(const char *encodedCharacter);
814  	void EOLAnnotationSetText(Line line, const char *text);
815  	int EOLAnnotationGetText(Line line, char *text);
816  	std::string EOLAnnotationGetText(Line line);
817  	void EOLAnnotationSetStyle(Line line, int style);
818  	int EOLAnnotationGetStyle(Line line);
819  	void EOLAnnotationClearAll();
820  	void EOLAnnotationSetVisible(Scintilla::EOLAnnotationVisible visible);
821  	Scintilla::EOLAnnotationVisible EOLAnnotationGetVisible();
822  	void EOLAnnotationSetStyleOffset(int style);
823  	int EOLAnnotationGetStyleOffset();
824  	bool SupportsFeature(Scintilla::Supports feature);
825  	Scintilla::LineCharacterIndexType LineCharacterIndex();
826  	void AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
827  	void ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
828  	Line LineFromIndexPosition(Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex);
829  	Position IndexPositionFromLine(Line line, Scintilla::LineCharacterIndexType lineCharacterIndex);
830  	void StartRecord();
831  	void StopRecord();
832  	int Lexer();
833  	void Colourise(Position start, Position end);
834  	void SetProperty(const char *key, const char *value);
835  	void SetKeyWords(int keyWordSet, const char *keyWords);
836  	int Property(const char *key, char *value);
837  	std::string Property(const char *key);
838  	int PropertyExpanded(const char *key, char *value);
839  	std::string PropertyExpanded(const char *key);
840  	int PropertyInt(const char *key, int defaultValue);
841  	int LexerLanguage(char *language);
842  	std::string LexerLanguage();
843  	void *PrivateLexerCall(int operation, void *pointer);
844  	int PropertyNames(char *names);
845  	std::string PropertyNames();
846  	Scintilla::TypeProperty PropertyType(const char *name);
847  	int DescribeProperty(const char *name, char *description);
848  	std::string DescribeProperty(const char *name);
849  	int DescribeKeyWordSets(char *descriptions);
850  	std::string DescribeKeyWordSets();
851  	Scintilla::LineEndType LineEndTypesSupported();
852  	int AllocateSubStyles(int styleBase, int numberStyles);
853  	int SubStylesStart(int styleBase);
854  	int SubStylesLength(int styleBase);
855  	int StyleFromSubStyle(int subStyle);
856  	int PrimaryStyleFromStyle(int style);
857  	void FreeSubStyles();
858  	void SetIdentifiers(int style, const char *identifiers);
859  	int DistanceToSecondaryStyles();
860  	int SubStyleBases(char *styles);
861  	std::string SubStyleBases();
862  	int NamedStyles();
863  	int NameOfStyle(int style, char *name);
864  	std::string NameOfStyle(int style);
865  	int TagsOfStyle(int style, char *tags);
866  	std::string TagsOfStyle(int style);
867  	int DescriptionOfStyle(int style, char *description);
868  	std::string DescriptionOfStyle(int style);
869  	void SetILexer(void *ilexer);
870  	Scintilla::Bidirectional Bidirectional();
871  	void SetBidirectional(Scintilla::Bidirectional bidirectional);
872  };
873  }
874  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</h3>
            <pre><code>1  #ifndef yanglib_agmattr1_h
2  #define yanglib_agmattr1_h
3  #include "Snap.h"
4  class TCesnaUtil {
5  public:
6  template<class PGraph>
7  static double GetConductance(const PGraph& Graph, const TIntSet& CmtyS, const int Edges) {
8    const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
9    int Edges2;
10    if (GraphType) { Edges2 = Edges >= 0 ? Edges : Graph->GetEdges(); }
11    else { Edges2 = Edges >= 0 ? 2 * Edges : Graph->GetEdges(); }
12    int Vol = 0,  Cut = 0; 
13    double Phi = 0.0;
14    for (int i = 0; i < CmtyS.Len(); i++) {
15      if (! Graph->IsNode(CmtyS[i])) { continue; }
16      typename PGraph::TObj::TNodeI  NI = Graph->GetNI(CmtyS[i]);
17      for (int e = 0; e < NI.GetOutDeg(); e++) {
18        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
19      }
20      Vol += NI.GetOutDeg();
21    }
22    if (Vol != Edges2) {
23      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
24      else if (Vol == 0) { Phi = 0.0; }
25      else { Phi = Cut / double(Vol); }
26    } else {
27      if (Vol == Edges2) { Phi = 1.0; }
28    }
29    return Phi;
30  }
31  template<class PGraph>
32    static void GenHoldOutPairs(const PGraph& G, TVec<TIntSet>& HoldOutSet, double HOFrac, TRnd& Rnd)  {
33      TIntPrV EdgeV(G->GetEdges(), 0);
34      for (typename PGraph::TObj::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
35        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
36      }
37      EdgeV.Shuffle(Rnd);
38      const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
39      HoldOutSet.Gen(G->GetNodes());
40      int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
41      if (GraphType) { HOTotal *= 2;}
42      int HOCnt = 0;
43      int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
44      printf("holding out %d edges...\n", HOEdges);
45      for (int he = 0; he < (int) HOEdges; he++) {
46        HoldOutSet[EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
47        if (! GraphType) { HoldOutSet[EdgeV[he].Val2].AddKey(EdgeV[he].Val1); }
48        HOCnt++;
49      }
50      printf("%d Edges hold out\n", HOCnt);
51      while(HOCnt++ < HOTotal) {
52        int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
53        int DstNID = Rnd.GetUniDevInt(G->GetNodes());
54        if (SrcNID == DstNID) { continue; }
55        HoldOutSet[SrcNID].AddKey(DstNID);
56        if (! GraphType) { HoldOutSet[DstNID].AddKey(SrcNID); }
57      }
58    }
59  template<class PGraph>
60    static void GetNbhCom(const PGraph& Graph, const int NID, TIntSet& NBCmtyS) {
61      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NID);
62      NBCmtyS.Gen(NI.GetDeg());
63      NBCmtyS.AddKey(NID);
64      for (int e = 0; e < NI.GetDeg(); e++) {
65        NBCmtyS.AddKey(NI.GetNbrNId(e));
66      }
67    }
68  template<class PGraph>
69    static void GetNIdPhiV(const PGraph& G, TFltIntPrV& NIdPhiV) {
70      NIdPhiV.Gen(G->GetNodes(), 0);
71      const int Edges = G->GetEdges();
72      TExeTm RunTm;
73      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
74        TIntSet NBCmty(NI.GetDeg() + 1);
75        double Phi;
76        if (NI.GetDeg() < 5) { 
77          Phi = 1.0; 
78        } else {
79          TCesnaUtil::GetNbhCom<PGraph>(G, NI.GetId(), NBCmty);
80          Phi = TCesnaUtil::GetConductance(G, NBCmty, Edges);
81        }
82        NIdPhiV.Add(TFltIntPr(Phi, NI.GetId()));
83      }
84      printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
85      fflush(stdout);
86    }
87    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& NodeNameH, const TSsFmt Sep = ssfTabSep) {
88      NIDAttrH.Clr();
89      NIDAttrH.Gen(NIDV.Len());
90      printf("nodes in the graph:%d\n", NIDV.Len());
91      for (int u = 0; u < NIDV.Len(); u++) { NIDAttrH.AddDat(NIDV[u]).Gen(0, 0); }
92      TSsParser Ss(InFNm, ssfTabSep);
93      while (Ss.Next()) {
94        TStr NodeName = Ss.GetFld(0);
95        TInt NID = NodeName.GetInt();
96        if (NodeNameH.Len() > 0 && ! NodeNameH.IsKey(NodeName)) { continue; }
97        if (NodeNameH.Len() > 0) { 
98          IAssertR(NodeNameH.IsKey(NodeName), TStr::Fmt("NodeName:%s", NodeName.CStr())); 
99          NID = NodeNameH.GetKeyId(NodeName);
100        }
101        if (! NIDAttrH.IsKey(NID)) { 
102          continue; } 
103        IAssertR(! NIDAttrH.GetDat(NID).IsIn(Ss.GetInt(1)), TStr::Fmt("NIdx:%d NID:%s, K:%d", NID.Val, NodeName.CStr(), Ss.GetInt(1)));
104        NIDAttrH.GetDat(NID).Add(Ss.GetInt(1));
105      }
106      printf("%s nodes, %s lines read \n",  TUInt64::GetStr(NIDAttrH.Len()).CStr(), TUInt64::GetStr(Ss.GetLineNo()).CStr());
107    }
108    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH) {
109      TStrHash<TInt> TmpH;
110      LoadNIDAttrHFromNIDKH(NIDV, InFNm, NIDAttrH, TmpH);
111    }
112    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
113      FILE* F = fopen(FNm.CStr(), "wt");
114      for (int u = 0; u < NIDAttrH.Len(); u++) {
115        int NID = NIDAttrH.GetKey(u);
116        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
117        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
118          int KID = NIDAttrH[u][k];
119          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
120          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
121        }
122      }
123      fclose(F);
124    }
125    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
126      TStrHash<TInt> TmpH;
127      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
128    }
129    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH) {
130      TStrHash<TInt> TmpH1, TmpH2;
131      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
132    }
133    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
134      FILE* F = fopen(FNm.CStr(), "wt");
135      for (int u = 0; u < NIDAttrH.Len(); u++) {
136        int NID = NIDAttrH.GetKey(u);
137        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
138        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
139          int KID = NIDAttrH[u][k];
140          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
141          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
142        }
143      }
144      fclose(F);
145    }
146    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
147      TStrHash<TInt> TmpH;
148      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
149    }
150    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH) {
151      TStrHash<TInt> TmpH1, TmpH2;
152      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
153    }
154    static int GetAttrs(const THash<TInt, TIntV>& NIDAttrH) {
155      int Attrs = 0;
156      for (int u = 0; u < NIDAttrH.Len(); u++) {
157        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
158          if (NIDAttrH[u][k] >= Attrs) { Attrs = NIDAttrH[u][k] + 1; }
159        }
160      }
161      return Attrs;
162    }
163    static void DumpNIDAttrHToMetis(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TIntV& NIDV) {
164      int AttrCnt = 0;
165      for (int u = 1; u < NIDV.Len(); u++) {
166        if (! NIDAttrH.IsKey(NIDV[u])) { continue; }
167        AttrCnt += NIDAttrH.GetDat(NIDV[u]).Len();
168      }
169      IAssert (NIDV[0] == -1);
170      FILE* F = fopen(FNm.CStr(), "wt");
171      fprintf(F, "%d %d\n", NIDV.Len() - 1, AttrCnt);
172      int TmpCnt = 0;
173      for (int u = 1; u < NIDV.Len(); u++) {
174        if (NIDAttrH.IsKey(NIDV[u])) {  
175          for (int k = 0; k < NIDAttrH.GetDat(NIDV[u]).Len(); k++) {
176            if (k > 0) { fprintf(F, " "); }
177            fprintf(F, "%d", NIDAttrH.GetDat(NIDV[u])[k].Val + 1);
178            TmpCnt++;
179          }
180        }
181        fprintf(F, "\n");
182      }
183      fclose(F);
184      IAssert(AttrCnt == TmpCnt);
185    }
186    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const TIntStrH& OldNameH, TIntStrH& NewNameH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
187      TIntH KIDCntH;
188      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
189        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
190          KIDCntH.AddDat(OldNIDAttrH[u][k])++;
191        }
192      }
193      KIDCntH.SortByDat(false);
194      TIntSet SelectedK(KIDCntH.Len());
195      for (int c = 0; c < KIDCntH.Len(); c++) {
196        double Frac = (double) KIDCntH[c].Val / (double) OldNIDAttrH.Len();
197        if (KIDCntH[c].Val < MinCnt) { continue; }
198        if (Frac > MaxFrac || Frac < MinFrac) { continue; }
199        SelectedK.AddKey(KIDCntH.GetKey(c));
200      }
201      printf("%d attributes selected from %d\n", SelectedK.Len(), KIDCntH.Len());
202      NewNIDAttrH.Gen(OldNIDAttrH.Len());
203      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
204        int NID = OldNIDAttrH.GetKey(u);
205        TIntV& AttrV = NewNIDAttrH.AddDat(NID);
206        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
207          if (! SelectedK.IsKey(OldNIDAttrH[u][k])) { continue; }
208          AttrV.Add(SelectedK.GetKeyId(OldNIDAttrH[u][k]));
209        }
210      }
211      if (! OldNameH.Empty()) {
212        NewNameH.Gen(SelectedK.Len());
213        for (int k = 0; k < SelectedK.Len(); k++) {
214          int OldKID = SelectedK.GetKey(k);
215          if (OldNameH.IsKey(OldKID)) {
216            NewNameH.AddDat(k, OldNameH.GetDat(OldKID));
217          }
218        }
219        printf("%d attributes names copied\n", NewNameH.Len());
220      }
221    }
222    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
223      TIntStrH TmpH1, TmpH2;
224      FilterLowEntropy(OldNIDAttrH, NewNIDAttrH, TmpH1, TmpH2, MinFrac, MaxFrac, MinCnt);
225    }
226  };
227  class TCesna { 
228  private:
229    PUNGraph G; 
230    TVec<TIntSet> X; 
231    TVec<TIntFltH> F; 
232    TVec<TFltV> W; 
233    TInt Attrs; 
234    TRnd Rnd; 
235    TIntSet NIDToIdx; 
236    TFlt RegCoef; 
237    TFltV SumFV; 
238    TInt NumComs; 
239    TVec<TIntSet> HOVIDSV; 
240    TVec<TIntSet> HOKIDSV; 
241  public:
242    TFlt MinVal; 
243    TFlt MaxVal; 
244    TFlt MinValW; 
245    TFlt MaxValW; 
246    TFlt NegWgt; 
247    TFlt LassoCoef; 
248    TFlt WeightAttr; 
249    TFlt PNoCom; 
250    TBool DoParallel; 
251    TCesna() { G = TUNGraph::New(10, -1); }
252    TCesna(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
253      MinVal(0.0), MaxVal(10.0), MinValW(-10.0), MaxValW(10.0), NegWgt(1.0), LassoCoef(1.0), WeightAttr(1.0) { SetGraph(GraphPt, NIDAttrH); NeighborComInit(InitComs); }
254    void Save(TSOut& SOut) {
255      G->Save(SOut);
256      X.Save(SOut);
257      F.Save(SOut);
258      W.Save(SOut);
259      Attrs.Save(SOut);
260      NIDToIdx.Save(SOut);
261      RegCoef.Save(SOut);
262      LassoCoef.Save(SOut);
263      SumFV.Save(SOut);
264      NumComs.Save(SOut);
265      HOVIDSV.Save(SOut);
266      HOKIDSV.Save(SOut);
267      MinVal.Save(SOut);
268      MaxVal.Save(SOut);
269      MinValW.Save(SOut);
270      MaxValW.Save(SOut);
271      NegWgt.Save(SOut);
272      PNoCom.Save(SOut);
273    }
274    void Load(TSIn& SIn, const int& RndSeed = 0) {
275      G->Load(SIn);
276      X.Load(SIn);
277      F.Load(SIn);
278      W.Load(SIn);
279      Attrs.Load(SIn);
280      NIDToIdx.Load(SIn);
281      RegCoef.Load(SIn);
282      LassoCoef.Load(SIn);
283      SumFV.Load(SIn);
284      NumComs.Load(SIn);
285      HOVIDSV.Load(SIn);
286      HOKIDSV.Load(SIn);
287      MinVal.Load(SIn);
288      MaxVal.Load(SIn);
289      MinValW.Load(SIn);
290      MaxValW.Load(SIn);
291      NegWgt.Load(SIn);
292      PNoCom.Load(SIn);
293    }
294    void SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH);
295    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
296    double GetRegCoef() { return RegCoef; }
297    void SetWeightAttr(const double _WeightAttr) { IAssert (_WeightAttr <= 1.0 && _WeightAttr >= 0.0); WeightAttr = _WeightAttr; }
298    double GetWeightAttr() { return WeightAttr; }
299    void SetLassoCoef(const double _LassoCoef) { LassoCoef = _LassoCoef; }
300    int GetAttrs() { return Attrs; }
301    double GetComFromNID(const int& NID, const int& CID) {
302      int NIdx = NIDToIdx.GetKeyId(NID);
303      if (F[NIdx].IsKey(CID)) {
304        return F[NIdx].GetDat(CID);
305      } else {
306        return 0.0;
307      }
308    }
309    double GetLassoCoef() { return LassoCoef; }
310    void InitW() { 
311      W.Gen(Attrs);
312      for (int k = 0; k < Attrs; k++) {
313        W[k].Gen(NumComs + 1);
314      }
315    }
316    void SetAttrHoldOut(const int NID, const int KID) {
317      int NIdx = NIDToIdx.GetKeyId(NID);
318      HOKIDSV[NIdx].AddKey(KID);
319    }
320    void SetAttrHoldOutForOneNode(const int NID) {
321      for (int k = 0; k < Attrs; k++) {
322        SetAttrHoldOut(NID, k);
323      }
324    }
325    void GetW(TVec<TFltV>& _W) { _W = W; }
326    void SetW(TVec<TFltV>& _W) { W = _W; }
327    void RandomInit(const int InitComs);
328    void NeighborComInit(const int InitComs);
329    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
330    int GetNumComs() { return NumComs; }
331    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
332    double Likelihood(const bool DoParallel = false);
333    double LikelihoodForRow(const int UID);
334    double LikelihoodForRow(const int UID, const TIntFltH& FU);
335    double LikelihoodAttrKForRow(const int UID, const int K) { return LikelihoodAttrKForRow(UID, K, F[UID]); }
336    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU) { return LikelihoodAttrKForRow(UID, K, FU, W[K]); }
337    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK);
338    double LikelihoodForWK(const int K, const TFltV& WK) {
339      double L = 0.0;
340      for (int u = 0; u < F.Len(); u++) {
341        if (HOKIDSV[u].IsKey(K)) { continue; }
342        L += LikelihoodAttrKForRow(u, K, F[u], WK);
343      }
344      for (int c = 0; c < WK.Len() - 1; c++) {
345        L -= LassoCoef * fabs(WK[c]);
346      } 
347      return L;
348    }
349    double LikelihoodForWK(const int K) { return LikelihoodForWK(K, W[K]); }
350    double LikelihoodAttr() {
351      double L = 0.0;
352      for (int k = 0; k < Attrs; k++) {
353        for (int u = 0; u < F.Len(); u++) {
354          if (HOKIDSV[u].IsKey(k)) { continue; }
355          L += LikelihoodAttrKForRow(u, k, F[u], W[k]);
356        }
357      }
358      return L;
359    }
360    double LikelihoodGraph() {
361      double L = Likelihood();
362      if (RegCoef > 0.0) { 
363        for (int u = 0; u < F.Len(); u++) {
364          L += RegCoef * Sum(F[u]);
365        }
366      }
367      if (RegCoef < 0.0) { 
368        for (int u = 0; u < F.Len(); u++) {
369          L -= RegCoef * Norm2(F[u]);
370        }
371      }
372      return L - WeightAttr * LikelihoodAttr();
373    }
374    void GenHoldOutAttr(const double HOFrac, TVec<TIntSet>& HOSetV) {
375      HOSetV.Gen(F.Len());
376      int HoldOutCnt = (int) ceil(HOFrac * G->GetNodes() * Attrs);
377      TIntPrSet NIDKIDSet(HoldOutCnt);
378      int Cnt = 0;
379      for (int h = 0; h < 10 * HoldOutCnt; h++) {
380        int UID = Rnd.GetUniDevInt(F.Len());
381        int KID = Rnd.GetUniDevInt(Attrs);
382        if (! NIDKIDSet.IsKey(TIntPr(UID, KID))) { 
383          NIDKIDSet.AddKey(TIntPr(UID, KID)); 
384          HOSetV[UID].AddKey(KID);
385          Cnt++;
386        }
387        if (Cnt >= HoldOutCnt) { break; }
388      }
389      printf("%d hold out pairs generated for attributes\n", Cnt);
390    }
391    void SetHoldOut(const double HOFrac) { 
392      TVec<TIntSet> HoldOut; 
393      TCesnaUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); 
394      GenHoldOutAttr(HOFrac, HOKIDSV);
395      HOVIDSV = HoldOut; 
396    }
397    void GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
398    void GradientForWK(TFltV& GradV, const int K) {
399      GradV.Gen(NumComs + 1);
400      for (int u = 0; u < F.Len(); u++) {
401        if (HOKIDSV[u].IsKey(K)) { continue; }
402        double Pred = PredictAttrK(u, K);
403        for (TIntFltH::TIter CI = F[u].BegI(); CI < F[u].EndI(); CI++) { 
404          GradV[CI.GetKey()] += (GetAttr(u, K) - Pred) * GetCom(u, CI.GetKey());
405        }
406        GradV[NumComs] += (GetAttr(u, K) - Pred);
407      }
408      for (int c = 0; c < GradV.Len() - 1; c++) {
409        GradV[c] -= LassoCoef * TMath::Sign(GetW(c, K));
410      }
411    }
412    void GetCmtyVV(TVec<TIntV>& CmtyVV);
413    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz = 3);
414    void GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3) {
415      TVec<TFltV> TmpV;
416      GetCmtyVV(CmtyVV, TmpV, Thres, MinSz); 
417    }
418    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck) {
419      GetCmtyVV(CmtyVV, Wck, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
420    }
421    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV);
422    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
423    int FindComs(TIntV& ComsV, const bool UseBIC = false, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1);
<span onclick='openModal()' class='match'>424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
</span>425    void DisplayAttrs(const int TopK, const TStrHash<TInt>& NodeNameH) {
426      for (int u = 0; u < X.Len(); u++) {
427        if (NodeNameH.Len() > 0) {
428          printf("NID: %s\t Attrs: ", NodeNameH.GetKey(NIDToIdx[u]));
429        } else {
430          printf("NID: %d\t Attrs: ", NIDToIdx[u].Val);
431        }
432        for (int k = 0; k < X[u].Len(); k++) {
433          printf("%d, ", X[u][k].Val);
434        }
435        printf("\n");
436        if (u >= TopK) { break; }
437      }
438    }
439    double LikelihoodHoldOut();
440    double GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
441    double GetStepSizeByLineSearchForWK(const int K, const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10) {
442      double StepSize = 1.0;
443      double InitLikelihood = LikelihoodForWK(K);
444      TFltV NewVarV(DeltaV.Len());
445      IAssert(DeltaV.Len() == NumComs + 1);
446      for(int iter = 0; iter < MaxIter; iter++) {
447        for (int c = 0; c < DeltaV.Len(); c++){
448          double NewVal = W[K][c] + StepSize * DeltaV[c];
449          if (NewVal < MinValW) { NewVal = MinValW; }
450          if (NewVal > MaxValW) { NewVal = MaxValW; }
451          NewVarV[c] = NewVal;
452        }
453        if (LikelihoodForWK(K, NewVarV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
454          StepSize *= Beta;
455        } else {
456          break;
457        }
458        if (iter == MaxIter - 1) { 
459          StepSize = 0.0;
460          break;
461        }
462      }
463      return StepSize;
464    }
465    int GetPositiveW() {
466      int PosCnt = 0;
467      for (int c = 0; c < NumComs; c++) {
468        for (int k = 0; k < Attrs; k++) {
469          if (GetW(c, k) > 0.0) { PosCnt++; }
470        }
471      }
472      return PosCnt;
473    }
474    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
475    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
476    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
477      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
478      if (ChunkSize == 0) { ChunkSize = 1; }
479      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
480    }
481    double inline GetCom(const int& NID, const int& CID) {
482      if (F[NID].IsKey(CID)) {
483        return F[NID].GetDat(CID);
484      } else {
485        return 0.0;
486      }
487    }
488    double inline GetAttr(const int& NID, const int& K) {
489      if (X[NID].IsKey(K)) {
490        return 1.0;
491      } else {
492        return 0.0;
493      }
494    }
495    void inline AddCom(const int& NID, const int& CID, const double& Val) {
496      if (F[NID].IsKey(CID)) {
497        SumFV[CID] -= F[NID].GetDat(CID);
498      }
499      F[NID].AddDat(CID) = Val;
500      SumFV[CID] += Val;
501    }
502    void inline DelCom(const int& NID, const int& CID) {
503      if (F[NID].IsKey(CID)) {
504        SumFV[CID] -= F[NID].GetDat(CID);
505        F[NID].DelKey(CID);
506      }
507    }
508    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
509      double DP = 0;
510      if (UV.Len() > VV.Len()) {
511        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
512          if (VV.IsKey(HI.GetKey())) { 
513            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
514          }
515        }
516      } else {
517        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
518          if (UV.IsKey(HI.GetKey())) { 
519            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
520          }
521        }
522      }
523      return DP;
524    }
525    double inline DotProduct(const int& UID, const int& VID) {
526      return DotProduct(F[UID], F[VID]);
527    }
528    double inline Prediction(const TIntFltH& FU, const TIntFltH& FV) {
529      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, FV);
530      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
531      return exp(- DP);
532    }
533    double inline PredictAttrK(const TIntFltH& FU, const TFltV& WK) {
534      double DP = 0.0;
535      for (TIntFltH::TIter FI = FU.BegI(); FI < FU.EndI(); FI++) {
536        DP += FI.GetDat() * WK[FI.GetKey()];
537      }
538      DP += WK.Last();
539      return Sigmoid(DP);
540    }
541    double inline PredictAttrK(const TIntFltH& FU, const int K) {
542      return PredictAttrK(FU, W[K]);
543    }
544    double inline PredictAttrK(const int UID, const int K) {
545      return PredictAttrK(F[UID], W[K]);
546    }
547    double inline GetW(const int CID, const int K) {
548      return W[K][CID];
549    }
550    double inline Prediction(const int& UID, const int& VID) {
551      return Prediction(F[UID], F[VID]);
552    }
553    double inline Sum(const TIntFltH& UV) {
554      double N = 0.0;
555      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
556        N += HI.GetDat();
557      }
558      return N;
559    }
560    double inline Norm2(const TIntFltH& UV) {
561      double N = 0.0;
562      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
563        N += HI.GetDat() * HI.GetDat();
564      }
565      return N;
566    }
567    double inline Sigmoid(const double X) {
568      return 1.0 / ( 1.0 + exp(-X));
569    }
570  };
571  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaCall.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</div>
                </div>
                <div class="column column_space"><pre><code>369  	Position TargetText(char *text);
370  	std::string TargetText();
371  	void TargetFromSelection();
372  	void TargetWholeDocument();
373  	Position ReplaceTarget(Position length, const char *text);
374  	Position ReplaceTargetRE(Position length, const char *text);
375  	Position ReplaceTargetMinimal(Position length, const char *text);
376  	Position SearchInTarget(Position length, const char *text);
377  	void SetSearchFlags(Scintilla::FindOption searchFlags);
378  	Scintilla::FindOption SearchFlags();
379  	void CallTipShow(Position pos, const char *definition);
</pre></code></div>
                <div class="column column_space"><pre><code>424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    