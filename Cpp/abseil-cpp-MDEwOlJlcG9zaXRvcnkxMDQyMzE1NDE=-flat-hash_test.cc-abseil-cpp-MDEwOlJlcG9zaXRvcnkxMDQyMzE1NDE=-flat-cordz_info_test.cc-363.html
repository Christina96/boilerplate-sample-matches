
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</h3>
            <pre><code>1  #include &quot;absl/hash/hash.h&quot;
2  #include &lt;algorithm&gt;
3  #include &lt;array&gt;
4  #include &lt;bitset&gt;
5  #include &lt;cstdint&gt;
6  #include &lt;cstring&gt;
7  #include &lt;deque&gt;
8  #include &lt;forward_list&gt;
9  #include &lt;functional&gt;
10  #include &lt;initializer_list&gt;
11  #include &lt;iterator&gt;
12  #include &lt;limits&gt;
13  #include &lt;list&gt;
14  #include &lt;map&gt;
15  #include &lt;memory&gt;
16  #include &lt;numeric&gt;
17  #include &lt;random&gt;
18  #include &lt;set&gt;
19  #include &lt;string&gt;
20  #include &lt;tuple&gt;
21  #include &lt;type_traits&gt;
22  #include &lt;unordered_map&gt;
23  #include &lt;unordered_set&gt;
24  #include &lt;utility&gt;
25  #include &lt;vector&gt;
26  #include &quot;gmock/gmock.h&quot;
27  #include &quot;gtest/gtest.h&quot;
28  #include &quot;absl/container/btree_map.h&quot;
29  #include &quot;absl/container/btree_set.h&quot;
30  #include &quot;absl/container/flat_hash_map.h&quot;
31  #include &quot;absl/container/flat_hash_set.h&quot;
32  #include &quot;absl/container/node_hash_map.h&quot;
33  #include &quot;absl/container/node_hash_set.h&quot;
34  #include &quot;absl/hash/hash_testing.h&quot;
35  #include &quot;absl/hash/internal/hash_test.h&quot;
36  #include &quot;absl/hash/internal/spy_hash_state.h&quot;
37  #include &quot;absl/meta/type_traits.h&quot;
38  #include &quot;absl/numeric/int128.h&quot;
39  #include &quot;absl/strings/cord_test_helpers.h&quot;
40  #ifdef ABSL_HAVE_STD_STRING_VIEW
41  #include &lt;string_view&gt;
42  #endif
43  namespace {
44  using ::absl::hash_test_internal::is_hashable;
45  using ::absl::hash_test_internal::TypeErasedContainer;
46  using ::absl::hash_test_internal::TypeErasedValue;
47  template &lt;typename T&gt;
48  using TypeErasedVector = TypeErasedContainer&lt;std::vector&lt;T&gt;&gt;;
49  using absl::Hash;
50  using absl::hash_internal::SpyHashState;
51  template &lt;typename T&gt;
52  class HashValueIntTest : public testing::Test {
53  };
54  TYPED_TEST_SUITE_P(HashValueIntTest);
55  template &lt;typename T&gt;
56  SpyHashState SpyHash(const T&amp; value) {
57    return SpyHashState::combine(SpyHashState(), value);
58  }
59  TYPED_TEST_P(HashValueIntTest, BasicUsage) {
60    EXPECT_TRUE((is_hashable&lt;TypeParam&gt;::value));
61    TypeParam n = 42;
62    EXPECT_EQ(SpyHash(n), SpyHash(TypeParam{42}));
63    EXPECT_NE(SpyHash(n), SpyHash(TypeParam{0}));
64    EXPECT_NE(SpyHash(std::numeric_limits&lt;TypeParam&gt;::max()),
65              SpyHash(std::numeric_limits&lt;TypeParam&gt;::min()));
66  }
67  TYPED_TEST_P(HashValueIntTest, FastPath) {
68    TypeParam n = 42;
69    EXPECT_EQ(absl::Hash&lt;TypeParam&gt;{}(n),
70              absl::Hash&lt;std::tuple&lt;TypeParam&gt;&gt;{}(std::tuple&lt;TypeParam&gt;(n)));
71  }
72  REGISTER_TYPED_TEST_SUITE_P(HashValueIntTest, BasicUsage, FastPath);
73  using IntTypes = testing::Types&lt;unsigned char, char, int, int32_t, int64_t,
74                                  uint32_t, uint64_t, size_t&gt;;
75  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashValueIntTest, IntTypes);
76  enum LegacyEnum { kValue1, kValue2, kValue3 };
77  enum class EnumClass { kValue4, kValue5, kValue6 };
78  TEST(HashValueTest, EnumAndBool) {
79    EXPECT_TRUE((is_hashable&lt;LegacyEnum&gt;::value));
80    EXPECT_TRUE((is_hashable&lt;EnumClass&gt;::value));
81    EXPECT_TRUE((is_hashable&lt;bool&gt;::value));
82    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
83        LegacyEnum::kValue1, LegacyEnum::kValue2, LegacyEnum::kValue3)));
84    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
85        EnumClass::kValue4, EnumClass::kValue5, EnumClass::kValue6)));
86    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
87        std::make_tuple(true, false)));
88  }
89  TEST(HashValueTest, FloatingPoint) {
90    EXPECT_TRUE((is_hashable&lt;float&gt;::value));
91    EXPECT_TRUE((is_hashable&lt;double&gt;::value));
92    EXPECT_TRUE((is_hashable&lt;long double&gt;::value));
93    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
94        std::make_tuple(42.f, 0.f, -0.f, std::numeric_limits&lt;float&gt;::infinity(),
95                        -std::numeric_limits&lt;float&gt;::infinity())));
96    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
97        std::make_tuple(42., 0., -0., std::numeric_limits&lt;double&gt;::infinity(),
98                        -std::numeric_limits&lt;double&gt;::infinity())));
99    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
100        .5L, 1.L, 2.L, 4.L, 42.L, 0.L, -0.L,
101        17 * static_cast&lt;long double&gt;(std::numeric_limits&lt;double&gt;::max()),
102        std::numeric_limits&lt;long double&gt;::infinity(),
103        -std::numeric_limits&lt;long double&gt;::infinity())));
104  }
105  TEST(HashValueTest, Pointer) {
106    EXPECT_TRUE((is_hashable&lt;int*&gt;::value));
107    EXPECT_TRUE((is_hashable&lt;int(*)(char, float)&gt;::value));
108    EXPECT_TRUE((is_hashable&lt;void(*)(int, int, ...)&gt;::value));
109    int i;
110    int* ptr = &amp;i;
111    int* n = nullptr;
112    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
113        std::make_tuple(&amp;i, ptr, nullptr, ptr + 1, n)));
114  }
115  TEST(HashValueTest, PointerAlignment) {
116    constexpr size_t kTotalSize = 1 &lt;&lt; 20;
<span onclick='openModal()' class='match'>117    std::unique_ptr&lt;char[]&gt; data(new char[kTotalSize]);
118    constexpr size_t kLog2NumValues = 5;
</span>119    constexpr size_t kNumValues = 1 &lt;&lt; kLog2NumValues;
120    for (size_t align = 1; align &lt; kTotalSize / kNumValues;
121         align &lt; 8 ? align += 1 : align &lt; 1024 ? align += 8 : align += 32) {
122      SCOPED_TRACE(align);
123      ASSERT_LE(align * kNumValues, kTotalSize);
124      size_t bits_or = 0;
125      size_t bits_and = ~size_t{};
126      for (size_t i = 0; i &lt; kNumValues; ++i) {
127        size_t hash = absl::Hash&lt;void*&gt;()(data.get() + i * align);
128        bits_or |= hash;
129        bits_and &amp;= hash;
130      }
131      constexpr size_t kMask = (1 &lt;&lt; (kLog2NumValues + 7)) - 1;
132      size_t stuck_bits = (~bits_or | bits_and) &amp; kMask;
133      EXPECT_EQ(stuck_bits, 0u) &lt;&lt; &quot;0x&quot; &lt;&lt; std::hex &lt;&lt; stuck_bits;
134    }
135  }
136  TEST(HashValueTest, PointerToMember) {
137    struct Bass {
138      void q() {}
139    };
140    struct A : Bass {
141      virtual ~A() = default;
142      virtual void vfa() {}
143      static auto pq() -&gt; void (A::*)() { return &amp;A::q; }
144    };
145    struct B : Bass {
146      virtual ~B() = default;
147      virtual void vfb() {}
148      static auto pq() -&gt; void (B::*)() { return &amp;B::q; }
149    };
150    struct Foo : A, B {
151      void f1() {}
152      void f2() const {}
153      int g1() &amp; { return 0; }
154      int g2() const &amp; { return 0; }
155      int g3() &amp;&amp; { return 0; }
156      int g4() const &amp;&amp; { return 0; }
157      int h1() &amp; { return 0; }
158      int h2() const &amp; { return 0; }
159      int h3() &amp;&amp; { return 0; }
160      int h4() const &amp;&amp; { return 0; }
161      int a;
162      int b;
163      const int c = 11;
164      const int d = 22;
165    };
166    EXPECT_TRUE((is_hashable&lt;float Foo::*&gt;::value));
167    EXPECT_TRUE((is_hashable&lt;double (Foo::*)(int, int)&amp;&amp;&gt;::value));
168    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
169        std::make_tuple(&amp;Foo::a, &amp;Foo::b, static_cast&lt;int Foo::*&gt;(nullptr))));
170    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
171        std::make_tuple(&amp;Foo::c, &amp;Foo::d, static_cast&lt;const int Foo::*&gt;(nullptr),
172                        &amp;Foo::a, &amp;Foo::b)));
173    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
174        &amp;Foo::f1, static_cast&lt;void (Foo::*)()&gt;(nullptr))));
175    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
176        &amp;Foo::f2, static_cast&lt;void (Foo::*)() const&gt;(nullptr))));
177    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
178        &amp;Foo::g1, &amp;Foo::h1, static_cast&lt;int (Foo::*)() &amp;&gt;(nullptr))));
179    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
180        &amp;Foo::g2, &amp;Foo::h2, static_cast&lt;int (Foo::*)() const &amp;&gt;(nullptr))));
181    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
182        &amp;Foo::g3, &amp;Foo::h3, static_cast&lt;int (Foo::*)() &amp;&amp;&gt;(nullptr))));
183    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
184        &amp;Foo::g4, &amp;Foo::h4, static_cast&lt;int (Foo::*)() const &amp;&amp;&gt;(nullptr))));
185    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
186        std::make_tuple(static_cast&lt;void (Foo::*)()&gt;(&amp;Foo::vfa),
187                        static_cast&lt;void (Foo::*)()&gt;(&amp;Foo::vfb),
188                        static_cast&lt;void (Foo::*)()&gt;(nullptr))));
189    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
190        std::make_tuple(static_cast&lt;void (Foo::*)()&gt;(Foo::A::pq()),
191                        static_cast&lt;void (Foo::*)()&gt;(Foo::B::pq()),
192                        static_cast&lt;void (Foo::*)()&gt;(nullptr))));
193  }
194  TEST(HashValueTest, PairAndTuple) {
195    EXPECT_TRUE((is_hashable&lt;std::pair&lt;int, int&gt;&gt;::value));
196    EXPECT_TRUE((is_hashable&lt;std::pair&lt;const int&amp;, const int&amp;&gt;&gt;::value));
197    EXPECT_TRUE((is_hashable&lt;std::tuple&lt;int&amp;, int&amp;&gt;&gt;::value));
198    EXPECT_TRUE((is_hashable&lt;std::tuple&lt;int&amp;&amp;, int&amp;&amp;&gt;&gt;::value));
199    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
200        std::make_pair(0, 42), std::make_pair(0, 42), std::make_pair(42, 0),
201        std::make_pair(0, 0), std::make_pair(42, 42), std::make_pair(1, 42))));
202    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
203        std::make_tuple(std::make_tuple(0, 0, 0), std::make_tuple(0, 0, 42),
204                        std::make_tuple(0, 23, 0), std::make_tuple(17, 0, 0),
205                        std::make_tuple(42, 0, 0), std::make_tuple(3, 9, 9),
206                        std::make_tuple(0, 0, -42))));
207    int a = 0, b = 1, c = 17, d = 23;
208    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
209        std::tie(a, a), std::tie(a, b), std::tie(b, c), std::tie(c, d))));
210    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
211        std::forward_as_tuple(0, 0, 0), std::forward_as_tuple(0, 0, 42),
212        std::forward_as_tuple(0, 23, 0), std::forward_as_tuple(17, 0, 0),
213        std::forward_as_tuple(42, 0, 0), std::forward_as_tuple(3, 9, 9),
214        std::forward_as_tuple(0, 0, -42))));
215  }
216  TEST(HashValueTest, CombineContiguousWorks) {
217    std::vector&lt;std::tuple&lt;int&gt;&gt; v1 = {std::make_tuple(1), std::make_tuple(3)};
218    std::vector&lt;std::tuple&lt;int&gt;&gt; v2 = {std::make_tuple(1), std::make_tuple(2)};
219    auto vh1 = SpyHash(v1);
220    auto vh2 = SpyHash(v2);
221    EXPECT_NE(vh1, vh2);
222  }
223  struct DummyDeleter {
224    template &lt;typename T&gt;
225    void operator() (T* ptr) {}
226  };
227  struct SmartPointerEq {
228    template &lt;typename T, typename U&gt;
229    bool operator()(const T&amp; t, const U&amp; u) const {
230      return GetPtr(t) == GetPtr(u);
231    }
232    template &lt;typename T&gt;
233    static auto GetPtr(const T&amp; t) -&gt; decltype(&amp;*t) {
234      return t ? &amp;*t : nullptr;
235    }
236    static std::nullptr_t GetPtr(std::nullptr_t) { return nullptr; }
237  };
238  TEST(HashValueTest, SmartPointers) {
239    EXPECT_TRUE((is_hashable&lt;std::unique_ptr&lt;int&gt;&gt;::value));
240    EXPECT_TRUE((is_hashable&lt;std::unique_ptr&lt;int, DummyDeleter&gt;&gt;::value));
241    EXPECT_TRUE((is_hashable&lt;std::shared_ptr&lt;int&gt;&gt;::value));
242    int i, j;
243    std::unique_ptr&lt;int, DummyDeleter&gt; unique1(&amp;i);
244    std::unique_ptr&lt;int, DummyDeleter&gt; unique2(&amp;i);
245    std::unique_ptr&lt;int, DummyDeleter&gt; unique_other(&amp;j);
246    std::unique_ptr&lt;int, DummyDeleter&gt; unique_null;
247    std::shared_ptr&lt;int&gt; shared1(&amp;i, DummyDeleter());
248    std::shared_ptr&lt;int&gt; shared2(&amp;i, DummyDeleter());
249    std::shared_ptr&lt;int&gt; shared_other(&amp;j, DummyDeleter());
250    std::shared_ptr&lt;int&gt; shared_null;
251    ASSERT_TRUE(SmartPointerEq{}(unique1, shared1));
252    ASSERT_FALSE(SmartPointerEq{}(unique1, shared_other));
253    ASSERT_TRUE(SmartPointerEq{}(unique_null, nullptr));
254    ASSERT_FALSE(SmartPointerEq{}(shared2, nullptr));
255    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
256        std::forward_as_tuple(&amp;i, nullptr,                    
257                              unique1, unique2, unique_null,  
258                              absl::make_unique&lt;int&gt;(),       
259                              shared1, shared2, shared_null,  
260                              std::make_shared&lt;int&gt;()),
261        SmartPointerEq{}));
262  }
263  TEST(HashValueTest, FunctionPointer) {
264    using Func = int (*)();
265    EXPECT_TRUE(is_hashable&lt;Func&gt;::value);
266    Func p1 = [] { return 2; }, p2 = [] { return 1; };
267    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
268        std::make_tuple(p1, p2, nullptr)));
269  }
270  struct WrapInTuple {
271    template &lt;typename T&gt;
272    std::tuple&lt;int, T, size_t&gt; operator()(const T&amp; t) const {
273      return std::make_tuple(7, t, 0xdeadbeef);
274    }
275  };
276  absl::Cord FlatCord(absl::string_view sv) {
277    absl::Cord c(sv);
278    c.Flatten();
279    return c;
280  }
281  absl::Cord FragmentedCord(absl::string_view sv) {
282    if (sv.size() &lt; 2) {
283      return absl::Cord(sv);
284    }
285    size_t halfway = sv.size() / 2;
286    std::vector&lt;absl::string_view&gt; parts = {sv.substr(0, halfway),
287                                            sv.substr(halfway)};
288    return absl::MakeFragmentedCord(parts);
289  }
290  TEST(HashValueTest, Strings) {
291    EXPECT_TRUE((is_hashable&lt;std::string&gt;::value));
292    const std::string small = &quot;foo&quot;;
293    const std::string dup = &quot;foofoo&quot;;
294    const std::string large = std::string(2048, &#x27;x&#x27;);  
295    const std::string huge = std::string(5000, &#x27;a&#x27;);   
296    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
297        std::string(), absl::string_view(), absl::Cord(),                     
298        std::string(&quot;&quot;), absl::string_view(&quot;&quot;), absl::Cord(&quot;&quot;),               
299        std::string(small), absl::string_view(small), absl::Cord(small),      
300        std::string(dup), absl::string_view(dup), absl::Cord(dup),            
301        std::string(large), absl::string_view(large), absl::Cord(large),      
302        std::string(huge), absl::string_view(huge), FlatCord(huge),           
303        FragmentedCord(huge))));
304    const WrapInTuple t{};
305    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(  
306        t(std::string()), t(absl::string_view()), t(absl::Cord()),            
307        t(std::string(&quot;&quot;)), t(absl::string_view(&quot;&quot;)), t(absl::Cord(&quot;&quot;)),      
308        t(std::string(small)), t(absl::string_view(small)),                   
309            t(absl::Cord(small)),                                             
310        t(std::string(dup)), t(absl::string_view(dup)), t(absl::Cord(dup)),   
311        t(std::string(large)), t(absl::string_view(large)),                   
312            t(absl::Cord(large)),                                             
313        t(std::string(huge)), t(absl::string_view(huge)),                     
314            t(FlatCord(huge)), t(FragmentedCord(huge)))));
315    EXPECT_NE(SpyHash(static_cast&lt;const char*&gt;(&quot;ABC&quot;)),
316              SpyHash(absl::string_view(&quot;ABC&quot;)));
317  }
318  TEST(HashValueTest, WString) {
319    EXPECT_TRUE((is_hashable&lt;std::wstring&gt;::value));
320    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
321        std::wstring(), std::wstring(L&quot;ABC&quot;), std::wstring(L&quot;ABC&quot;),
322        std::wstring(L&quot;Some other different string&quot;),
323        std::wstring(L&quot;Iñtërnâtiônàlizætiøn&quot;))));
324  }
325  TEST(HashValueTest, U16String) {
326    EXPECT_TRUE((is_hashable&lt;std::u16string&gt;::value));
327    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
328        std::u16string(), std::u16string(u&quot;ABC&quot;), std::u16string(u&quot;ABC&quot;),
329        std::u16string(u&quot;Some other different string&quot;),
330        std::u16string(u&quot;Iñtërnâtiônàlizætiøn&quot;))));
331  }
332  TEST(HashValueTest, U32String) {
333    EXPECT_TRUE((is_hashable&lt;std::u32string&gt;::value));
334    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
335        std::u32string(), std::u32string(U&quot;ABC&quot;), std::u32string(U&quot;ABC&quot;),
336        std::u32string(U&quot;Some other different string&quot;),
337        std::u32string(U&quot;Iñtërnâtiônàlizætiøn&quot;))));
338  }
339  TEST(HashValueTest, WStringView) {
340  #ifndef ABSL_HAVE_STD_STRING_VIEW
341    GTEST_SKIP();
342  #else
343    EXPECT_TRUE((is_hashable&lt;std::wstring_view&gt;::value));
344    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
345        std::wstring_view(), std::wstring_view(L&quot;ABC&quot;), std::wstring_view(L&quot;ABC&quot;),
346        std::wstring_view(L&quot;Some other different string_view&quot;),
347        std::wstring_view(L&quot;Iñtërnâtiônàlizætiøn&quot;))));
348  #endif
349  }
350  TEST(HashValueTest, U16StringView) {
351  #ifndef ABSL_HAVE_STD_STRING_VIEW
352    GTEST_SKIP();
353  #else
354    EXPECT_TRUE((is_hashable&lt;std::u16string_view&gt;::value));
355    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
356        std::make_tuple(std::u16string_view(), std::u16string_view(u&quot;ABC&quot;),
357                        std::u16string_view(u&quot;ABC&quot;),
358                        std::u16string_view(u&quot;Some other different string_view&quot;),
359                        std::u16string_view(u&quot;Iñtërnâtiônàlizætiøn&quot;))));
360  #endif
361  }
362  TEST(HashValueTest, U32StringView) {
363  #ifndef ABSL_HAVE_STD_STRING_VIEW
364    GTEST_SKIP();
365  #else
366    EXPECT_TRUE((is_hashable&lt;std::u32string_view&gt;::value));
367    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
368        std::make_tuple(std::u32string_view(), std::u32string_view(U&quot;ABC&quot;),
369                        std::u32string_view(U&quot;ABC&quot;),
370                        std::u32string_view(U&quot;Some other different string_view&quot;),
371                        std::u32string_view(U&quot;Iñtërnâtiônàlizætiøn&quot;))));
372  #endif
373  }
374  TEST(HashValueTest, StdArray) {
375    EXPECT_TRUE((is_hashable&lt;std::array&lt;int, 3&gt;&gt;::value));
376    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
377        std::make_tuple(std::array&lt;int, 3&gt;{}, std::array&lt;int, 3&gt;{{0, 23, 42}})));
378  }
379  TEST(HashValueTest, StdBitset) {
380    EXPECT_TRUE((is_hashable&lt;std::bitset&lt;257&gt;&gt;::value));
381    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
382        {std::bitset&lt;2&gt;(&quot;00&quot;), std::bitset&lt;2&gt;(&quot;01&quot;), std::bitset&lt;2&gt;(&quot;10&quot;),
383         std::bitset&lt;2&gt;(&quot;11&quot;)}));
384    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
385        {std::bitset&lt;5&gt;(&quot;10101&quot;), std::bitset&lt;5&gt;(&quot;10001&quot;), std::bitset&lt;5&gt;()}));
386    constexpr int kNumBits = 256;
387    std::array&lt;std::string, 6&gt; bit_strings;
388    bit_strings.fill(std::string(kNumBits, &#x27;1&#x27;));
389    bit_strings[1][0] = &#x27;0&#x27;;
390    bit_strings[2][1] = &#x27;0&#x27;;
391    bit_strings[3][kNumBits / 3] = &#x27;0&#x27;;
392    bit_strings[4][kNumBits - 2] = &#x27;0&#x27;;
393    bit_strings[5][kNumBits - 1] = &#x27;0&#x27;;
394    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
395        {std::bitset&lt;kNumBits&gt;(bit_strings[0].c_str()),
396         std::bitset&lt;kNumBits&gt;(bit_strings[1].c_str()),
397         std::bitset&lt;kNumBits&gt;(bit_strings[2].c_str()),
398         std::bitset&lt;kNumBits&gt;(bit_strings[3].c_str()),
399         std::bitset&lt;kNumBits&gt;(bit_strings[4].c_str()),
400         std::bitset&lt;kNumBits&gt;(bit_strings[5].c_str())}));
401  }  
402  struct Private {
403    int i;
404    template &lt;typename H&gt;
405    friend H AbslHashValue(H h, Private p) {
406      return H::combine(std::move(h), std::abs(p.i));
407    }
408    friend bool operator==(Private a, Private b) {
409      return std::abs(a.i) == std::abs(b.i);
410    }
411    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, Private p) {
412      return o &lt;&lt; p.i;
413    }
414  };
415  class PiecewiseHashTester {
416   public:
417    explicit PiecewiseHashTester(absl::string_view buf)
418        : buf_(buf), piecewise_(false), split_locations_() {}
419    PiecewiseHashTester(absl::string_view buf, std::set&lt;size_t&gt; split_locations)
420        : buf_(buf),
421          piecewise_(true),
422          split_locations_(std::move(split_locations)) {}
423    template &lt;typename H&gt;
424    friend H AbslHashValue(H h, const PiecewiseHashTester&amp; p) {
425      if (!p.piecewise_) {
426        return H::combine_contiguous(std::move(h), p.buf_.data(), p.buf_.size());
427      }
428      absl::hash_internal::PiecewiseCombiner combiner;
429      if (p.split_locations_.empty()) {
430        h = combiner.add_buffer(std::move(h), p.buf_.data(), p.buf_.size());
431        return combiner.finalize(std::move(h));
432      }
433      size_t begin = 0;
434      for (size_t next : p.split_locations_) {
435        absl::string_view chunk = p.buf_.substr(begin, next - begin);
436        h = combiner.add_buffer(std::move(h), chunk.data(), chunk.size());
437        begin = next;
438      }
439      absl::string_view last_chunk = p.buf_.substr(begin);
440      if (!last_chunk.empty()) {
441        h = combiner.add_buffer(std::move(h), last_chunk.data(),
442                                last_chunk.size());
443      }
444      return combiner.finalize(std::move(h));
445    }
446   private:
447    absl::string_view buf_;
448    bool piecewise_;
449    std::set&lt;size_t&gt; split_locations_;
450  };
451  struct DummyFooBar {
452    template &lt;typename H&gt;
453    friend H AbslHashValue(H h, const DummyFooBar&amp;) {
454      const char* foo = &quot;foo&quot;;
455      const char* bar = &quot;bar&quot;;
456      h = H::combine_contiguous(std::move(h), foo, 3);
457      h = H::combine_contiguous(std::move(h), bar, 3);
458      return h;
459    }
460  };
461  TEST(HashValueTest, CombinePiecewiseBuffer) {
462    absl::Hash&lt;PiecewiseHashTester&gt; hash;
463    EXPECT_EQ(hash(PiecewiseHashTester(&quot;&quot;)), hash(PiecewiseHashTester(&quot;&quot;, {})));
464    EXPECT_EQ(hash(PiecewiseHashTester(&quot;foobar&quot;)),
465              hash(PiecewiseHashTester(&quot;foobar&quot;, {})));
466    EXPECT_EQ(hash(PiecewiseHashTester(&quot;foobar&quot;)),
467              hash(PiecewiseHashTester(&quot;foobar&quot;, {3})));
468    EXPECT_NE(hash(PiecewiseHashTester(&quot;foobar&quot;, {3})),
469              absl::Hash&lt;DummyFooBar&gt;()(DummyFooBar{}));
470    for (size_t big_buffer_size : {1024u * 2 + 512u, 1024u * 3}) {
471      SCOPED_TRACE(big_buffer_size);
472      std::string big_buffer;
473      for (size_t i = 0; i &lt; big_buffer_size; ++i) {
474        big_buffer.push_back(32 + (i * (i / 3)) % 64);
475      }
476      auto big_buffer_hash = hash(PiecewiseHashTester(big_buffer));
477      const int possible_breaks = 9;
478      size_t breaks[possible_breaks] = {1,    512,  1023, 1024, 1025,
479                                        1536, 2047, 2048, 2049};
480      for (unsigned test_mask = 0; test_mask &lt; (1u &lt;&lt; possible_breaks);
481           ++test_mask) {
482        SCOPED_TRACE(test_mask);
483        std::set&lt;size_t&gt; break_locations;
484        for (int j = 0; j &lt; possible_breaks; ++j) {
485          if (test_mask &amp; (1u &lt;&lt; j)) {
486            break_locations.insert(breaks[j]);
487          }
488        }
489        EXPECT_EQ(
490            hash(PiecewiseHashTester(big_buffer, std::move(break_locations))),
491            big_buffer_hash);
492      }
493    }
494  }
495  TEST(HashValueTest, PrivateSanity) {
496    EXPECT_TRUE(is_hashable&lt;Private&gt;::value);
497    EXPECT_NE(SpyHash(Private{0}), SpyHash(Private{1}));
498    EXPECT_EQ(SpyHash(Private{1}), SpyHash(Private{1}));
499  }
500  TEST(HashValueTest, Optional) {
501    EXPECT_TRUE(is_hashable&lt;absl::optional&lt;Private&gt;&gt;::value);
502    using O = absl::optional&lt;Private&gt;;
503    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
504        std::make_tuple(O{}, O{{1}}, O{{-1}}, O{{10}})));
505  }
506  TEST(HashValueTest, Variant) {
507    using V = absl::variant&lt;Private, std::string&gt;;
508    EXPECT_TRUE(is_hashable&lt;V&gt;::value);
509    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
510        V(Private{1}), V(Private{-1}), V(Private{2}), V(&quot;ABC&quot;), V(&quot;BCD&quot;))));
511  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
512    struct S {};
513    EXPECT_FALSE(is_hashable&lt;absl::variant&lt;S&gt;&gt;::value);
514  #endif
515  }
516  TEST(HashValueTest, ReferenceWrapper) {
517    EXPECT_TRUE(is_hashable&lt;std::reference_wrapper&lt;Private&gt;&gt;::value);
518    Private p1{1}, p10{10};
519    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
520        p1, p10, std::ref(p1), std::ref(p10), std::cref(p1), std::cref(p10))));
521    EXPECT_TRUE(is_hashable&lt;std::reference_wrapper&lt;int&gt;&gt;::value);
522    int one = 1, ten = 10;
523    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(std::make_tuple(
524        one, ten, std::ref(one), std::ref(ten), std::cref(one), std::cref(ten))));
525    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
526        std::make_tuple(std::tuple&lt;std::reference_wrapper&lt;int&gt;&gt;(std::ref(one)),
527                        std::tuple&lt;std::reference_wrapper&lt;int&gt;&gt;(std::ref(ten)),
528                        std::tuple&lt;int&gt;(one), std::tuple&lt;int&gt;(ten))));
529  }
530  template &lt;typename T, typename = void&gt;
531  struct IsHashCallable : std::false_type {};
532  template &lt;typename T&gt;
533  struct IsHashCallable&lt;T, absl::void_t&lt;decltype(std::declval&lt;absl::Hash&lt;T&gt;&gt;()(
534                              std::declval&lt;const T&amp;&gt;()))&gt;&gt; : std::true_type {};
535  template &lt;typename T, typename = void&gt;
536  struct IsAggregateInitializable : std::false_type {};
537  template &lt;typename T&gt;
538  struct IsAggregateInitializable&lt;T, absl::void_t&lt;decltype(T{})&gt;&gt;
539      : std::true_type {};
540  TEST(IsHashableTest, ValidHash) {
541    EXPECT_TRUE((is_hashable&lt;int&gt;::value));
542    EXPECT_TRUE(std::is_default_constructible&lt;absl::Hash&lt;int&gt;&gt;::value);
543    EXPECT_TRUE(std::is_copy_constructible&lt;absl::Hash&lt;int&gt;&gt;::value);
544    EXPECT_TRUE(std::is_move_constructible&lt;absl::Hash&lt;int&gt;&gt;::value);
545    EXPECT_TRUE(absl::is_copy_assignable&lt;absl::Hash&lt;int&gt;&gt;::value);
546    EXPECT_TRUE(absl::is_move_assignable&lt;absl::Hash&lt;int&gt;&gt;::value);
547    EXPECT_TRUE(IsHashCallable&lt;int&gt;::value);
548    EXPECT_TRUE(IsAggregateInitializable&lt;absl::Hash&lt;int&gt;&gt;::value);
549  }
550  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
551  TEST(IsHashableTest, PoisonHash) {
552    struct X {};
553    EXPECT_FALSE((is_hashable&lt;X&gt;::value));
554    EXPECT_FALSE(std::is_default_constructible&lt;absl::Hash&lt;X&gt;&gt;::value);
555    EXPECT_FALSE(std::is_copy_constructible&lt;absl::Hash&lt;X&gt;&gt;::value);
556    EXPECT_FALSE(std::is_move_constructible&lt;absl::Hash&lt;X&gt;&gt;::value);
557    EXPECT_FALSE(absl::is_copy_assignable&lt;absl::Hash&lt;X&gt;&gt;::value);
558    EXPECT_FALSE(absl::is_move_assignable&lt;absl::Hash&lt;X&gt;&gt;::value);
559    EXPECT_FALSE(IsHashCallable&lt;X&gt;::value);
560  #if !defined(__GNUC__) || defined(__clang__)
561    EXPECT_FALSE(IsAggregateInitializable&lt;absl::Hash&lt;X&gt;&gt;::value);
562  #endif
563  }
564  #endif  
565  struct NoOp {
566    template &lt;typename HashCode&gt;
567    friend HashCode AbslHashValue(HashCode h, NoOp n) {
568      return h;
569    }
570  };
571  struct EmptyCombine {
572    template &lt;typename HashCode&gt;
573    friend HashCode AbslHashValue(HashCode h, EmptyCombine e) {
574      return HashCode::combine(std::move(h));
575    }
576  };
577  template &lt;typename Int&gt;
578  struct CombineIterative {
579    template &lt;typename HashCode&gt;
580    friend HashCode AbslHashValue(HashCode h, CombineIterative c) {
581      for (int i = 0; i &lt; 5; ++i) {
582        h = HashCode::combine(std::move(h), Int(i));
583      }
584      return h;
585    }
586  };
587  template &lt;typename Int&gt;
588  struct CombineVariadic {
589    template &lt;typename HashCode&gt;
590    friend HashCode AbslHashValue(HashCode h, CombineVariadic c) {
591      return HashCode::combine(std::move(h), Int(0), Int(1), Int(2), Int(3),
592                               Int(4));
593    }
594  };
595  enum class InvokeTag {
596    kUniquelyRepresented,
597    kHashValue,
598  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
599    kLegacyHash,
600  #endif  
601    kStdHash,
602    kNone
603  };
604  template &lt;InvokeTag T&gt;
605  using InvokeTagConstant = std::integral_constant&lt;InvokeTag, T&gt;;
606  template &lt;InvokeTag... Tags&gt;
607  struct MinTag;
608  template &lt;InvokeTag a, InvokeTag b, InvokeTag... Tags&gt;
609  struct MinTag&lt;a, b, Tags...&gt; : MinTag&lt;(a &lt; b ? a : b), Tags...&gt; {};
610  template &lt;InvokeTag a&gt;
611  struct MinTag&lt;a&gt; : InvokeTagConstant&lt;a&gt; {};
612  template &lt;InvokeTag... Tags&gt;
613  struct CustomHashType {
614    explicit CustomHashType(size_t val) : value(val) {}
615    size_t value;
616  };
617  template &lt;InvokeTag allowed, InvokeTag... tags&gt;
618  struct EnableIfContained
619      : std::enable_if&lt;absl::disjunction&lt;
620            std::integral_constant&lt;bool, allowed == tags&gt;...&gt;::value&gt; {};
621  template &lt;
622      typename H, InvokeTag... Tags,
623      typename = typename EnableIfContained&lt;InvokeTag::kHashValue, Tags...&gt;::type&gt;
624  H AbslHashValue(H state, CustomHashType&lt;Tags...&gt; t) {
625    static_assert(MinTag&lt;Tags...&gt;::value == InvokeTag::kHashValue, &quot;&quot;);
626    return H::combine(std::move(state),
627                      t.value + static_cast&lt;int&gt;(InvokeTag::kHashValue));
628  }
629  }  
630  namespace absl {
631  ABSL_NAMESPACE_BEGIN
632  namespace hash_internal {
633  template &lt;InvokeTag... Tags&gt;
634  struct is_uniquely_represented&lt;
635      CustomHashType&lt;Tags...&gt;,
636      typename EnableIfContained&lt;InvokeTag::kUniquelyRepresented, Tags...&gt;::type&gt;
637      : std::true_type {};
638  }  
639  ABSL_NAMESPACE_END
640  }  
641  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
642  namespace ABSL_INTERNAL_LEGACY_HASH_NAMESPACE {
643  template &lt;InvokeTag... Tags&gt;
644  struct hash&lt;CustomHashType&lt;Tags...&gt;&gt; {
645    template &lt;InvokeTag... TagsIn, typename = typename EnableIfContained&lt;
646                                       InvokeTag::kLegacyHash, TagsIn...&gt;::type&gt;
647    size_t operator()(CustomHashType&lt;TagsIn...&gt; t) const {
648      static_assert(MinTag&lt;Tags...&gt;::value == InvokeTag::kLegacyHash, &quot;&quot;);
649      return t.value + static_cast&lt;int&gt;(InvokeTag::kLegacyHash);
650    }
651  };
652  }  
653  #endif  
654  namespace std {
655  template &lt;InvokeTag... Tags&gt;  
656  struct hash&lt;CustomHashType&lt;Tags...&gt;&gt; {
657    template &lt;InvokeTag... TagsIn, typename = typename EnableIfContained&lt;
658                                       InvokeTag::kStdHash, TagsIn...&gt;::type&gt;
659    size_t operator()(CustomHashType&lt;TagsIn...&gt; t) const {
660      static_assert(MinTag&lt;Tags...&gt;::value == InvokeTag::kStdHash, &quot;&quot;);
661      return t.value + static_cast&lt;int&gt;(InvokeTag::kStdHash);
662    }
663  };
664  }  
665  namespace {
666  template &lt;typename... T&gt;
667  void TestCustomHashType(InvokeTagConstant&lt;InvokeTag::kNone&gt;, T...) {
668    using type = CustomHashType&lt;T::value...&gt;;
669    SCOPED_TRACE(testing::PrintToString(std::vector&lt;InvokeTag&gt;{T::value...}));
670    EXPECT_TRUE(is_hashable&lt;type&gt;());
671    EXPECT_TRUE(is_hashable&lt;const type&gt;());
672    EXPECT_TRUE(is_hashable&lt;const type&amp;&gt;());
673    const size_t offset = static_cast&lt;int&gt;(std::min({T::value...}));
674    EXPECT_EQ(SpyHash(type(7)), SpyHash(size_t{7 + offset}));
675  }
676  void TestCustomHashType(InvokeTagConstant&lt;InvokeTag::kNone&gt;) {
677  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
678    using type = CustomHashType&lt;&gt;;
679    EXPECT_FALSE(is_hashable&lt;type&gt;());
680    EXPECT_FALSE(is_hashable&lt;const type&gt;());
681    EXPECT_FALSE(is_hashable&lt;const type&amp;&gt;());
682  #endif  
683  }
684  template &lt;InvokeTag Tag, typename... T&gt;
685  void TestCustomHashType(InvokeTagConstant&lt;Tag&gt; tag, T... t) {
686    constexpr auto next = static_cast&lt;InvokeTag&gt;(static_cast&lt;int&gt;(Tag) + 1);
687    TestCustomHashType(InvokeTagConstant&lt;next&gt;(), tag, t...);
688    TestCustomHashType(InvokeTagConstant&lt;next&gt;(), t...);
689  }
690  TEST(HashTest, CustomHashType) {
691    TestCustomHashType(InvokeTagConstant&lt;InvokeTag{}&gt;());
692  }
693  TEST(HashTest, NoOpsAreEquivalent) {
694    EXPECT_EQ(Hash&lt;NoOp&gt;()({}), Hash&lt;NoOp&gt;()({}));
695    EXPECT_EQ(Hash&lt;NoOp&gt;()({}), Hash&lt;EmptyCombine&gt;()({}));
696  }
697  template &lt;typename T&gt;
698  class HashIntTest : public testing::Test {
699  };
700  TYPED_TEST_SUITE_P(HashIntTest);
701  TYPED_TEST_P(HashIntTest, BasicUsage) {
702    EXPECT_NE(Hash&lt;NoOp&gt;()({}), Hash&lt;TypeParam&gt;()(0));
703    EXPECT_NE(Hash&lt;NoOp&gt;()({}),
704              Hash&lt;TypeParam&gt;()(std::numeric_limits&lt;TypeParam&gt;::max()));
705    if (std::numeric_limits&lt;TypeParam&gt;::min() != 0) {
706      EXPECT_NE(Hash&lt;NoOp&gt;()({}),
707                Hash&lt;TypeParam&gt;()(std::numeric_limits&lt;TypeParam&gt;::min()));
708    }
709    EXPECT_EQ(Hash&lt;CombineIterative&lt;TypeParam&gt;&gt;()({}),
710              Hash&lt;CombineVariadic&lt;TypeParam&gt;&gt;()({}));
711  }
712  REGISTER_TYPED_TEST_SUITE_P(HashIntTest, BasicUsage);
713  using IntTypes = testing::Types&lt;unsigned char, char, int, int32_t, int64_t,
714                                  uint32_t, uint64_t, size_t&gt;;
715  INSTANTIATE_TYPED_TEST_SUITE_P(My, HashIntTest, IntTypes);
716  struct StructWithPadding {
717    char c;
718    int i;
719    template &lt;typename H&gt;
720    friend H AbslHashValue(H hash_state, const StructWithPadding&amp; s) {
721      return H::combine(std::move(hash_state), s.c, s.i);
722    }
723  };
724  static_assert(sizeof(StructWithPadding) &gt; sizeof(char) + sizeof(int),
725                &quot;StructWithPadding doesn&#x27;t have padding&quot;);
726  static_assert(std::is_standard_layout&lt;StructWithPadding&gt;::value, &quot;&quot;);
727  template &lt;typename T&gt;
728  struct ArraySlice {
729    T* begin;
730    T* end;
731    template &lt;typename H&gt;
732    friend H AbslHashValue(H hash_state, const ArraySlice&amp; slice) {
733      for (auto t = slice.begin; t != slice.end; ++t) {
734        hash_state = H::combine(std::move(hash_state), *t);
735      }
736      return hash_state;
737    }
738  };
739  TEST(HashTest, HashNonUniquelyRepresentedType) {
740    static const size_t kNumStructs = 10;
741    unsigned char buffer1[kNumStructs * sizeof(StructWithPadding)];
742    std::memset(buffer1, 0, sizeof(buffer1));
743    auto* s1 = reinterpret_cast&lt;StructWithPadding*&gt;(buffer1);
744    unsigned char buffer2[kNumStructs * sizeof(StructWithPadding)];
745    std::memset(buffer2, 255, sizeof(buffer2));
746    auto* s2 = reinterpret_cast&lt;StructWithPadding*&gt;(buffer2);
747    for (size_t i = 0; i &lt; kNumStructs; ++i) {
748      SCOPED_TRACE(i);
749      s1[i].c = s2[i].c = static_cast&lt;char&gt;(&#x27;0&#x27; + i);
750      s1[i].i = s2[i].i = static_cast&lt;int&gt;(i);
751      ASSERT_FALSE(memcmp(buffer1 + i * sizeof(StructWithPadding),
752                          buffer2 + i * sizeof(StructWithPadding),
753                          sizeof(StructWithPadding)) == 0)
754          &lt;&lt; &quot;Bug in test code: objects do not have unequal&quot;
755          &lt;&lt; &quot; object representations&quot;;
756    }
757    EXPECT_EQ(Hash&lt;StructWithPadding&gt;()(s1[0]), Hash&lt;StructWithPadding&gt;()(s2[0]));
758    EXPECT_EQ(Hash&lt;ArraySlice&lt;StructWithPadding&gt;&gt;()({s1, s1 + kNumStructs}),
759              Hash&lt;ArraySlice&lt;StructWithPadding&gt;&gt;()({s2, s2 + kNumStructs}));
760  }
761  TEST(HashTest, StandardHashContainerUsage) {
762    std::unordered_map&lt;int, std::string, Hash&lt;int&gt;&gt; map = {{0, &quot;foo&quot;},
763                                                           {42, &quot;bar&quot;}};
764    EXPECT_NE(map.find(0), map.end());
765    EXPECT_EQ(map.find(1), map.end());
766    EXPECT_NE(map.find(0u), map.end());
767  }
768  struct ConvertibleFromNoOp {
769    ConvertibleFromNoOp(NoOp) {}  
770    template &lt;typename H&gt;
771    friend H AbslHashValue(H hash_state, ConvertibleFromNoOp) {
772      return H::combine(std::move(hash_state), 1);
773    }
774  };
775  TEST(HashTest, HeterogeneousCall) {
776    EXPECT_NE(Hash&lt;ConvertibleFromNoOp&gt;()(NoOp()),
777              Hash&lt;NoOp&gt;()(NoOp()));
778  }
779  TEST(IsUniquelyRepresentedTest, SanityTest) {
780    using absl::hash_internal::is_uniquely_represented;
781    EXPECT_TRUE(is_uniquely_represented&lt;unsigned char&gt;::value);
782    EXPECT_TRUE(is_uniquely_represented&lt;int&gt;::value);
783    EXPECT_FALSE(is_uniquely_represented&lt;bool&gt;::value);
784    EXPECT_FALSE(is_uniquely_represented&lt;int*&gt;::value);
785  }
786  struct IntAndString {
787    int i;
788    std::string s;
789    template &lt;typename H&gt;
790    friend H AbslHashValue(H hash_state, IntAndString int_and_string) {
791      return H::combine(std::move(hash_state), int_and_string.s,
792                        int_and_string.i);
793    }
794  };
795  TEST(HashTest, SmallValueOn64ByteBoundary) {
796    Hash&lt;IntAndString&gt;()(IntAndString{0, std::string(63, &#x27;0&#x27;)});
797  }
798  TEST(HashTest, TypeErased) {
799    EXPECT_TRUE((is_hashable&lt;TypeErasedValue&lt;size_t&gt;&gt;::value));
800    EXPECT_TRUE((is_hashable&lt;std::pair&lt;TypeErasedValue&lt;size_t&gt;, int&gt;&gt;::value));
801    EXPECT_EQ(SpyHash(TypeErasedValue&lt;size_t&gt;(7)), SpyHash(size_t{7}));
802    EXPECT_NE(SpyHash(TypeErasedValue&lt;size_t&gt;(7)), SpyHash(size_t{13}));
803    EXPECT_EQ(SpyHash(std::make_pair(TypeErasedValue&lt;size_t&gt;(7), 17)),
804              SpyHash(std::make_pair(size_t{7}, 17)));
805    absl::flat_hash_set&lt;absl::flat_hash_set&lt;int&gt;&gt; ss = {{1, 2}, {3, 4}};
806    TypeErasedContainer&lt;absl::flat_hash_set&lt;absl::flat_hash_set&lt;int&gt;&gt;&gt; es = {
807        absl::flat_hash_set&lt;int&gt;{1, 2}, {3, 4}};
808    absl::flat_hash_set&lt;TypeErasedContainer&lt;absl::flat_hash_set&lt;int&gt;&gt;&gt; se = {
809        {1, 2}, {3, 4}};
810    EXPECT_EQ(SpyHash(ss), SpyHash(es));
811    EXPECT_EQ(SpyHash(ss), SpyHash(se));
812  }
813  struct ValueWithBoolConversion {
814    operator bool() const { return false; }
815    int i;
816  };
817  }  
818  namespace std {
819  template &lt;&gt;
820  struct hash&lt;ValueWithBoolConversion&gt; {
821    size_t operator()(ValueWithBoolConversion v) {
822      return static_cast&lt;size_t&gt;(v.i);
823    }
824  };
825  }  
826  namespace {
827  TEST(HashTest, DoesNotUseImplicitConversionsToBool) {
828    EXPECT_NE(absl::Hash&lt;ValueWithBoolConversion&gt;()(ValueWithBoolConversion{0}),
829              absl::Hash&lt;ValueWithBoolConversion&gt;()(ValueWithBoolConversion{1}));
830  }
831  TEST(HashOf, MatchesHashForSingleArgument) {
832    std::string s = &quot;forty two&quot;;
833    double d = 42.0;
834    std::tuple&lt;int, int&gt; t{4, 2};
835    int i = 42;
836    int neg_i = -42;
837    int16_t i16 = 42;
838    int16_t neg_i16 = -42;
839    int8_t i8 = 42;
840    int8_t neg_i8 = -42;
841    EXPECT_EQ(absl::HashOf(s), absl::Hash&lt;std::string&gt;{}(s));
842    EXPECT_EQ(absl::HashOf(d), absl::Hash&lt;double&gt;{}(d));
843    EXPECT_EQ(absl::HashOf(t), (absl::Hash&lt;std::tuple&lt;int, int&gt;&gt;{}(t)));
844    EXPECT_EQ(absl::HashOf(i), absl::Hash&lt;int&gt;{}(i));
845    EXPECT_EQ(absl::HashOf(neg_i), absl::Hash&lt;int&gt;{}(neg_i));
846    EXPECT_EQ(absl::HashOf(i16), absl::Hash&lt;int16_t&gt;{}(i16));
847    EXPECT_EQ(absl::HashOf(neg_i16), absl::Hash&lt;int16_t&gt;{}(neg_i16));
848    EXPECT_EQ(absl::HashOf(i8), absl::Hash&lt;int8_t&gt;{}(i8));
849    EXPECT_EQ(absl::HashOf(neg_i8), absl::Hash&lt;int8_t&gt;{}(neg_i8));
850  }
851  TEST(HashOf, MatchesHashOfTupleForMultipleArguments) {
852    std::string hello = &quot;hello&quot;;
853    std::string world = &quot;world&quot;;
854    EXPECT_EQ(absl::HashOf(), absl::HashOf(std::make_tuple()));
855    EXPECT_EQ(absl::HashOf(hello), absl::HashOf(std::make_tuple(hello)));
856    EXPECT_EQ(absl::HashOf(hello, world),
857              absl::HashOf(std::make_tuple(hello, world)));
858  }
859  template &lt;typename T&gt;
860  std::true_type HashOfExplicitParameter(decltype(absl::HashOf&lt;T&gt;(0))) {
861    return {};
862  }
863  template &lt;typename T&gt;
864  std::false_type HashOfExplicitParameter(size_t) {
865    return {};
866  }
867  TEST(HashOf, CantPassExplicitTemplateParameters) {
868    EXPECT_FALSE(HashOfExplicitParameter&lt;int&gt;(0));
869  }
870  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</h3>
            <pre><code>1  #include &quot;absl/strings/internal/cordz_info.h&quot;
2  #include &lt;vector&gt;
3  #include &quot;gmock/gmock.h&quot;
4  #include &quot;gtest/gtest.h&quot;
5  #include &quot;absl/base/config.h&quot;
6  #include &quot;absl/debugging/stacktrace.h&quot;
7  #include &quot;absl/debugging/symbolize.h&quot;
8  #include &quot;absl/strings/cordz_test_helpers.h&quot;
9  #include &quot;absl/strings/internal/cord_rep_flat.h&quot;
10  #include &quot;absl/strings/internal/cordz_handle.h&quot;
11  #include &quot;absl/strings/internal/cordz_statistics.h&quot;
12  #include &quot;absl/strings/internal/cordz_update_tracker.h&quot;
13  #include &quot;absl/strings/str_cat.h&quot;
14  #include &quot;absl/types/span.h&quot;
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace cord_internal {
18  namespace {
19  using ::testing::ElementsAre;
20  using ::testing::Eq;
21  using ::testing::HasSubstr;
22  using ::testing::Ne;
23  using ::testing::SizeIs;
24  auto constexpr kUnknownMethod = CordzUpdateTracker::kUnknown;
25  auto constexpr kTrackCordMethod = CordzUpdateTracker::kConstructorString;
26  auto constexpr kChildMethod = CordzUpdateTracker::kConstructorCord;
27  auto constexpr kUpdateMethod = CordzUpdateTracker::kAppendString;
28  std::vector&lt;const CordzHandle*&gt; DeleteQueue() {
29    return CordzHandle::DiagnosticsGetDeleteQueue();
30  }
31  std::string FormatStack(absl::Span&lt;void* const&gt; raw_stack) {
32    static constexpr size_t buf_size = 1 &lt;&lt; 14;
<span onclick='openModal()' class='match'>33    std::unique_ptr&lt;char[]&gt; buf(new char[buf_size]);
34    std::string output;
</span>35    for (void* stackp : raw_stack) {
36      if (absl::Symbolize(stackp, buf.get(), buf_size)) {
37        absl::StrAppend(&amp;output, &quot;    &quot;, buf.get(), &quot;\n&quot;);
38      }
39    }
40    return output;
41  }
42  TEST(CordzInfoTest, TrackCord) {
43    TestCordData data;
44    CordzInfo::TrackCord(data.data, kTrackCordMethod);
45    CordzInfo* info = data.data.cordz_info();
46    ASSERT_THAT(info, Ne(nullptr));
47    EXPECT_FALSE(info-&gt;is_snapshot());
48    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
49    EXPECT_THAT(info-&gt;GetCordRepForTesting(), Eq(data.rep.rep));
50    info-&gt;Untrack();
51  }
52  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSampling) {
53    CordzSamplingIntervalHelper sample_none(99999);
54    TestCordData parent, child;
55    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
56    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
57  }
58  TEST(CordzInfoTest, MaybeTrackChildCordWithSampling) {
59    CordzSamplingIntervalHelper sample_all(1);
60    TestCordData parent, child;
61    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
62    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
63  }
64  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingParentSampled) {
65    CordzSamplingIntervalHelper sample_none(99999);
66    TestCordData parent, child;
67    CordzInfo::TrackCord(parent.data, kTrackCordMethod);
68    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
69    CordzInfo* parent_info = parent.data.cordz_info();
70    CordzInfo* child_info = child.data.cordz_info();
71    ASSERT_THAT(child_info, Ne(nullptr));
72    EXPECT_THAT(child_info-&gt;GetCordRepForTesting(), Eq(child.rep.rep));
73    EXPECT_THAT(child_info-&gt;GetParentStack(), parent_info-&gt;GetStack());
74    parent_info-&gt;Untrack();
75    child_info-&gt;Untrack();
76  }
77  TEST(CordzInfoTest, MaybeTrackChildCordWithoutSamplingChildSampled) {
78    CordzSamplingIntervalHelper sample_none(99999);
79    TestCordData parent, child;
80    CordzInfo::TrackCord(child.data, kTrackCordMethod);
81    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
82    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
83  }
84  TEST(CordzInfoTest, MaybeTrackChildCordWithSamplingChildSampled) {
85    CordzSamplingIntervalHelper sample_all(1);
86    TestCordData parent, child;
87    CordzInfo::TrackCord(child.data, kTrackCordMethod);
88    CordzInfo::MaybeTrackCord(child.data, parent.data, kTrackCordMethod);
89    EXPECT_THAT(child.data.cordz_info(), Eq(nullptr));
90  }
91  TEST(CordzInfoTest, UntrackCord) {
92    TestCordData data;
93    CordzInfo::TrackCord(data.data, kTrackCordMethod);
94    CordzInfo* info = data.data.cordz_info();
95    info-&gt;Untrack();
96    EXPECT_THAT(DeleteQueue(), SizeIs(0u));
97  }
98  TEST(CordzInfoTest, UntrackCordWithSnapshot) {
99    TestCordData data;
100    CordzInfo::TrackCord(data.data, kTrackCordMethod);
101    CordzInfo* info = data.data.cordz_info();
102    CordzSnapshot snapshot;
103    info-&gt;Untrack();
104    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
105    EXPECT_THAT(info-&gt;GetCordRepForTesting(), Eq(data.rep.rep));
106    EXPECT_THAT(DeleteQueue(), ElementsAre(info, &amp;snapshot));
107  }
108  TEST(CordzInfoTest, SetCordRep) {
109    TestCordData data;
110    CordzInfo::TrackCord(data.data, kTrackCordMethod);
111    CordzInfo* info = data.data.cordz_info();
112    TestCordRep rep;
113    info-&gt;Lock(CordzUpdateTracker::kAppendCord);
114    info-&gt;SetCordRep(rep.rep);
115    info-&gt;Unlock();
116    EXPECT_THAT(info-&gt;GetCordRepForTesting(), Eq(rep.rep));
117    info-&gt;Untrack();
118  }
119  TEST(CordzInfoTest, SetCordRepNullUntracksCordOnUnlock) {
120    TestCordData data;
121    CordzInfo::TrackCord(data.data, kTrackCordMethod);
122    CordzInfo* info = data.data.cordz_info();
123    info-&gt;Lock(CordzUpdateTracker::kAppendString);
124    info-&gt;SetCordRep(nullptr);
125    EXPECT_THAT(info-&gt;GetCordRepForTesting(), Eq(nullptr));
126    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(info));
127    info-&gt;Unlock();
128    EXPECT_THAT(CordzInfo::Head(CordzSnapshot()), Eq(nullptr));
129  }
130  TEST(CordzInfoTest, RefCordRep) {
131    TestCordData data;
132    CordzInfo::TrackCord(data.data, kTrackCordMethod);
133    CordzInfo* info = data.data.cordz_info();
134    size_t refcount = data.rep.rep-&gt;refcount.Get();
135    EXPECT_THAT(info-&gt;RefCordRep(), Eq(data.rep.rep));
136    EXPECT_THAT(data.rep.rep-&gt;refcount.Get(), Eq(refcount + 1));
137    CordRep::Unref(data.rep.rep);
138    info-&gt;Untrack();
139  }
140  #if GTEST_HAS_DEATH_TEST
141  TEST(CordzInfoTest, SetCordRepRequiresMutex) {
142    TestCordData data;
143    CordzInfo::TrackCord(data.data, kTrackCordMethod);
144    CordzInfo* info = data.data.cordz_info();
145    TestCordRep rep;
146    EXPECT_DEBUG_DEATH(info-&gt;SetCordRep(rep.rep), &quot;.*&quot;);
147    info-&gt;Untrack();
148  }
149  #endif  
150  TEST(CordzInfoTest, TrackUntrackHeadFirstV2) {
151    CordzSnapshot snapshot;
152    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
153    TestCordData data;
154    CordzInfo::TrackCord(data.data, kTrackCordMethod);
155    CordzInfo* info1 = data.data.cordz_info();
156    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
157    EXPECT_THAT(info1-&gt;Next(snapshot), Eq(nullptr));
158    TestCordData data2;
159    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
160    CordzInfo* info2 = data2.data.cordz_info();
161    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
162    EXPECT_THAT(info2-&gt;Next(snapshot), Eq(info1));
163    EXPECT_THAT(info1-&gt;Next(snapshot), Eq(nullptr));
164    info2-&gt;Untrack();
165    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
166    EXPECT_THAT(info1-&gt;Next(snapshot), Eq(nullptr));
167    info1-&gt;Untrack();
168    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
169  }
170  TEST(CordzInfoTest, TrackUntrackTailFirstV2) {
171    CordzSnapshot snapshot;
172    EXPECT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
173    TestCordData data;
174    CordzInfo::TrackCord(data.data, kTrackCordMethod);
175    CordzInfo* info1 = data.data.cordz_info();
176    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info1));
177    EXPECT_THAT(info1-&gt;Next(snapshot), Eq(nullptr));
178    TestCordData data2;
179    CordzInfo::TrackCord(data2.data, kTrackCordMethod);
180    CordzInfo* info2 = data2.data.cordz_info();
181    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
182    EXPECT_THAT(info2-&gt;Next(snapshot), Eq(info1));
183    EXPECT_THAT(info1-&gt;Next(snapshot), Eq(nullptr));
184    info1-&gt;Untrack();
185    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(info2));
186    EXPECT_THAT(info2-&gt;Next(snapshot), Eq(nullptr));
187    info2-&gt;Untrack();
188    ASSERT_THAT(CordzInfo::Head(snapshot), Eq(nullptr));
189  }
190  TEST(CordzInfoTest, StackV2) {
191    TestCordData data;
192    static constexpr int kMaxStackDepth = 50;
193    CordzInfo::TrackCord(data.data, kTrackCordMethod);
194    CordzInfo* info = data.data.cordz_info();
195    std::vector&lt;void*&gt; local_stack;
196    local_stack.resize(kMaxStackDepth);
197    local_stack.resize(static_cast&lt;size_t&gt;(
198        absl::GetStackTrace(local_stack.data(), kMaxStackDepth,
199                            1)));
200    std::string got_stack = FormatStack(info-&gt;GetStack());
201    std::string expected_stack = FormatStack(local_stack);
202    EXPECT_THAT(got_stack, HasSubstr(expected_stack));
203    info-&gt;Untrack();
204  }
205  CordzInfo* TrackChildCord(InlineData&amp; data, const InlineData&amp; parent) {
206    CordzInfo::TrackCord(data, parent, kChildMethod);
207    return data.cordz_info();
208  }
209  CordzInfo* TrackParentCord(InlineData&amp; data) {
210    CordzInfo::TrackCord(data, kTrackCordMethod);
211    return data.cordz_info();
212  }
213  TEST(CordzInfoTest, GetStatistics) {
214    TestCordData data;
215    CordzInfo* info = TrackParentCord(data.data);
216    CordzStatistics statistics = info-&gt;GetCordzStatistics();
217    EXPECT_THAT(statistics.size, Eq(data.rep.rep-&gt;length));
218    EXPECT_THAT(statistics.method, Eq(kTrackCordMethod));
219    EXPECT_THAT(statistics.parent_method, Eq(kUnknownMethod));
220    EXPECT_THAT(statistics.update_tracker.Value(kTrackCordMethod), Eq(1));
221    info-&gt;Untrack();
222  }
223  TEST(CordzInfoTest, LockCountsMethod) {
224    TestCordData data;
225    CordzInfo* info = TrackParentCord(data.data);
226    info-&gt;Lock(kUpdateMethod);
227    info-&gt;Unlock();
228    info-&gt;Lock(kUpdateMethod);
229    info-&gt;Unlock();
230    CordzStatistics statistics = info-&gt;GetCordzStatistics();
231    EXPECT_THAT(statistics.update_tracker.Value(kUpdateMethod), Eq(2));
232    info-&gt;Untrack();
233  }
234  TEST(CordzInfoTest, FromParent) {
235    TestCordData parent;
236    TestCordData child;
237    CordzInfo* info_parent = TrackParentCord(parent.data);
238    CordzInfo* info_child = TrackChildCord(child.data, parent.data);
239    std::string stack = FormatStack(info_parent-&gt;GetStack());
240    std::string parent_stack = FormatStack(info_child-&gt;GetParentStack());
241    EXPECT_THAT(stack, Eq(parent_stack));
242    CordzStatistics statistics = info_child-&gt;GetCordzStatistics();
243    EXPECT_THAT(statistics.size, Eq(child.rep.rep-&gt;length));
244    EXPECT_THAT(statistics.method, Eq(kChildMethod));
245    EXPECT_THAT(statistics.parent_method, Eq(kTrackCordMethod));
246    EXPECT_THAT(statistics.update_tracker.Value(kChildMethod), Eq(1));
247    info_parent-&gt;Untrack();
248    info_child-&gt;Untrack();
249  }
250  }  
251  }  
252  ABSL_NAMESPACE_END
253  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>117    std::unique_ptr&lt;char[]&gt; data(new char[kTotalSize]);
118    constexpr size_t kLog2NumValues = 5;
</pre></code></div>
                <div class="column column_space"><pre><code>33    std::unique_ptr&lt;char[]&gt; buf(new char[buf_size]);
34    std::string output;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    