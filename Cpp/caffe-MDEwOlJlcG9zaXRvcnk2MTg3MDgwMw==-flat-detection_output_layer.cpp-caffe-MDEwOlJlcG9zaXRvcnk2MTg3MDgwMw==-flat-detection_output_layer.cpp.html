
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 59, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <fstream>  
3  #include <map>
4  #include <string>
5  #include <utility>
6  #include <vector>
7  #include "boost/filesystem.hpp"
8  #include "boost/foreach.hpp"
9  #include "caffe/layers/detection_output_layer.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void DetectionOutputLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
13        const vector<Blob<Dtype>*>& top) {
14    const DetectionOutputParameter& detection_output_param =
15        this->layer_param_.detection_output_param();
16    CHECK(detection_output_param.has_num_classes()) << "Must specify num_classes";
17    num_classes_ = detection_output_param.num_classes();
18    share_location_ = detection_output_param.share_location();
19    num_loc_classes_ = share_location_ ? 1 : num_classes_;
20    background_label_id_ = detection_output_param.background_label_id();
21    code_type_ = detection_output_param.code_type();
22    variance_encoded_in_target_ =
23        detection_output_param.variance_encoded_in_target();
24    keep_top_k_ = detection_output_param.keep_top_k();
25    confidence_threshold_ = detection_output_param.has_confidence_threshold() ?
26        detection_output_param.confidence_threshold() : -FLT_MAX;
27    nms_threshold_ = detection_output_param.nms_param().nms_threshold();
28    CHECK_GE(nms_threshold_, 0.) << "nms_threshold must be non negative.";
29    eta_ = detection_output_param.nms_param().eta();
30    CHECK_GT(eta_, 0.);
31    CHECK_LE(eta_, 1.);
32    top_k_ = -1;
33    if (detection_output_param.nms_param().has_top_k()) {
34      top_k_ = detection_output_param.nms_param().top_k();
35    }
36    const SaveOutputParameter& save_output_param =
37        detection_output_param.save_output_param();
38    output_directory_ = save_output_param.output_directory();
39    if (!output_directory_.empty()) {
40      if (boost::filesystem::is_directory(output_directory_)
41  #ifdef USE_MLSL
42          && mn::is_root() == true
43  #endif
44         )
45        boost::filesystem::remove_all(output_directory_);
46  #ifdef USE_MLSL
47      if(mn::is_root() == true){
48  #endif
49      boost::filesystem::create_directories(output_directory_);
50      if(!boost::filesystem::is_directory(output_directory_))
51        LOG(FATAL) << "Failed to create directory: " << output_directory_;
52  #ifdef USE_MLSL
53      }
54  #endif
55    }
56    output_name_prefix_ = save_output_param.output_name_prefix();
57    need_save_ = output_directory_ == "" ? false : true;
58    output_format_ = save_output_param.output_format();
59    if (save_output_param.has_label_map_file()) {
60      string label_map_file = save_output_param.label_map_file();
61      if (label_map_file.empty()) {
62        LOG(WARNING) << "Provide label_map_file if output results to files.";
63        need_save_ = false;
64      } else {
65        LabelMap label_map;
66        CHECK(ReadProtoFromTextFile(label_map_file, &label_map))
67            << "Failed to read label map file: " << label_map_file;
68        CHECK(MapLabelToName(label_map, true, &label_to_name_))
69            << "Failed to convert label to name.";
70        CHECK(MapLabelToDisplayName(label_map, true, &label_to_display_name_))
71            << "Failed to convert label to display name.";
72      }
73    } else {
74      need_save_ = false;
75    }
76    if (save_output_param.has_name_size_file()) {
77      string name_size_file = save_output_param.name_size_file();
78      if (name_size_file.empty()) {
79        LOG(WARNING) << "Provide name_size_file if output results to files.";
80        need_save_ = false;
81      } else {
82        std::ifstream infile(name_size_file.c_str());
83        CHECK(infile.good())
84            << "Failed to open name size file: " << name_size_file;
85        string name;
86        int height, width;
87        while (infile >> name >> height >> width) {
88          names_.push_back(name);
89          sizes_.push_back(std::make_pair(height, width));
90        }
91        infile.close();
92        if (save_output_param.has_num_test_image()) {
93          num_test_image_ = save_output_param.num_test_image();
94        } else {
95          num_test_image_ = names_.size();
96        }
97        CHECK_LE(num_test_image_, names_.size());
98      }
99    } else {
100      need_save_ = false;
101    }
102    has_resize_ = save_output_param.has_resize_param();
103    if (has_resize_) {
104      resize_param_ = save_output_param.resize_param();
105    }
106    name_count_ = 0;
107    visualize_ = detection_output_param.visualize();
108    if (visualize_) {
109      visualize_threshold_ = 0.6;
110      if (detection_output_param.has_visualize_threshold()) {
111        visualize_threshold_ = detection_output_param.visualize_threshold();
112      }
113      data_transformer_.reset(
114          new DataTransformer<Dtype>(this->layer_param_.transform_param(),
115                                     this->phase_));
116      data_transformer_->InitRand();
117      save_file_ = detection_output_param.save_file();
118    }
119    bbox_preds_.ReshapeLike(*(bottom[0]));
120    if (!share_location_) {
121      bbox_permute_.ReshapeLike(*(bottom[0]));
122    }
123    conf_permute_.ReshapeLike(*(bottom[1]));
124  }
125  template <typename Dtype>
126  void DetectionOutputLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
127        const vector<Blob<Dtype>*>& top) {
128    if (need_save_) {
129      CHECK_LE(name_count_, names_.size());
130      if (name_count_ % num_test_image_ == 0) {
131        if (output_format_ == "VOC") {
132  #ifdef USE_MLSL
133          mn::barrier();
134  #endif
135          boost::filesystem::path output_directory(output_directory_);
136          for (map<int, string>::iterator it = label_to_name_.begin();
137               it != label_to_name_.end(); ++it) {
138            if (it->first == background_label_id_) {
139              continue;
140            }
141            std::ofstream outfile;
142            boost::filesystem::path file(
143                output_name_prefix_ + it->second + ".txt");
144            boost::filesystem::path out_file = output_directory / file;
145            outfile.open(out_file.string().c_str(), std::ofstream::out);
146          }
147        }
148      }
149    }
150    CHECK_EQ(bottom[0]->num(), bottom[1]->num());
151    if (bbox_preds_.num() != bottom[0]->num() ||
152        bbox_preds_.count(1) != bottom[0]->count(1)) {
153      bbox_preds_.ReshapeLike(*(bottom[0]));
154    }
155    if (!share_location_ && (bbox_permute_.num() != bottom[0]->num() ||
156        bbox_permute_.count(1) != bottom[0]->count(1))) {
157      bbox_permute_.ReshapeLike(*(bottom[0]));
158    }
159    if (conf_permute_.num() != bottom[1]->num() ||
160        conf_permute_.count(1) != bottom[1]->count(1)) {
161      conf_permute_.ReshapeLike(*(bottom[1]));
162    }
163    num_priors_ = bottom[2]->height() / 4;
164    CHECK_EQ(num_priors_ * num_loc_classes_ * 4, bottom[0]->channels())
165        << "Number of priors must match number of location predictions.";
166    CHECK_EQ(num_priors_ * num_classes_, bottom[1]->channels())
167        << "Number of priors must match number of confidence predictions.";
168    vector<int> top_shape(2, 1);
169    top_shape.push_back(1);
170    top_shape.push_back(7);
171    top[0]->Reshape(top_shape);
172  }
173  template <typename Dtype>
174  void DetectionOutputLayer<Dtype>::Forward_cpu(
175      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
176    const Dtype* loc_data = bottom[0]->cpu_data();
177    const Dtype* conf_data = bottom[1]->cpu_data();
178    const Dtype* prior_data = bottom[2]->cpu_data();
179    const int num = bottom[0]->num();
180    vector<LabelBBox> all_loc_preds;
181    GetLocPredictions(loc_data, num, num_priors_, num_loc_classes_,
182                      share_location_, &all_loc_preds);
183    vector<map<int, vector<float> > > all_conf_scores;
184    GetConfidenceScores(conf_data, num, num_priors_, num_classes_,
185                        &all_conf_scores);
186    vector<NormalizedBBox> prior_bboxes(num_priors_);
187    vector<vector<float> > prior_variances(num_priors_);
188    GetPriorBBoxes(prior_data, num_priors_, &prior_bboxes, &prior_variances);
189    vector<LabelBBox> all_decode_bboxes;
190    const bool clip_bbox = false;
191    DecodeBBoxesAll(all_loc_preds, prior_bboxes, prior_variances, num,
192                    share_location_, num_loc_classes_, background_label_id_,
193                    code_type_, variance_encoded_in_target_, clip_bbox,
194                    &all_decode_bboxes);
195    int num_kept = 0;
196    vector<map<int, vector<int> > > all_indices(num);
197  #ifdef _OPENMP
198    #pragma omp parallel for
199  #endif
200    for (int i = 0; i < num; ++i) {
201      const LabelBBox& decode_bboxes = all_decode_bboxes[i];
202      const map<int, vector<float> >& conf_scores = all_conf_scores[i];
203      map<int, vector<int> > indices;
204      int num_det = 0;
205      for (int c = 0; c < num_classes_; ++c) {
206        if (c == background_label_id_) {
207          continue;
208        }
209        if (conf_scores.find(c) == conf_scores.end()) {
210          LOG(FATAL) << "Could not find confidence predictions for label " << c;
211        }
212        const vector<float>& scores = conf_scores.find(c)->second;
213        int label = share_location_ ? -1 : c;
214        if (decode_bboxes.find(label) == decode_bboxes.end()) {
215          LOG(FATAL) << "Could not find location predictions for label " << label;
216          continue;
217        }
218        const vector<NormalizedBBox>& bboxes = decode_bboxes.find(label)->second;
219        ApplyNMSFast(bboxes, scores, confidence_threshold_, nms_threshold_, eta_,
220            top_k_, &(indices[c]));
221        num_det += indices[c].size();
222      }
223      int num_to_add = 0;
224      if (keep_top_k_ > -1 && num_det > keep_top_k_) {
225        vector<pair<float, pair<int, int> > > score_index_pairs;
226        for (map<int, vector<int> >::iterator it = indices.begin();
227             it != indices.end(); ++it) {
228          int label = it->first;
229          const vector<int>& label_indices = it->second;
230          if (conf_scores.find(label) == conf_scores.end()) {
231            LOG(FATAL) << "Could not find location predictions for " << label;
232            continue;
233          }
234          const vector<float>& scores = conf_scores.find(label)->second;
235          for (int j = 0; j < label_indices.size(); ++j) {
236            int idx = label_indices[j];
237            CHECK_LT(idx, scores.size());
238            score_index_pairs.push_back(std::make_pair(
239                    scores[idx], std::make_pair(label, idx)));
240          }
241        }
242        std::sort(score_index_pairs.begin(), score_index_pairs.end(),
243                  SortScorePairDescend<pair<int, int> >);
244        score_index_pairs.resize(keep_top_k_);
245        map<int, vector<int> > new_indices;
246        for (int j = 0; j < score_index_pairs.size(); ++j) {
247          int label = score_index_pairs[j].second.first;
248          int idx = score_index_pairs[j].second.second;
249          new_indices[label].push_back(idx);
250        }
251        all_indices[i] = new_indices;
252        num_to_add = keep_top_k_;
253      } else {
254        all_indices[i] = indices;
255        num_to_add = num_det;
256      }
257  #ifdef _OPENMP
258      #pragma omp atomic
259  #endif
260      num_kept += num_to_add;
261    }
262    vector<int> top_shape(2, 1);
263    top_shape.push_back(num_kept);
264    top_shape.push_back(7);
265    Dtype* top_data;
266    if (num_kept == 0) {
267      LOG(INFO) << "Couldn't find any detections";
268      top_shape[2] = num;
269      top[0]->Reshape(top_shape);
270      top_data = top[0]->mutable_cpu_data();
271      caffe_set<Dtype>(top[0]->count(), -1, top_data);
272      for (int i = 0; i < num; ++i) {
273        top_data[0] = i;
274        top_data += 7;
275      }
276    } else {
277      top[0]->Reshape(top_shape);
278      top_data = top[0]->mutable_cpu_data();
279    }
280    int count = 0;
281    boost::filesystem::path output_directory(output_directory_);
282    for (int i = 0; i < num; ++i) {
283      const map<int, vector<float> >& conf_scores = all_conf_scores[i];
284      const LabelBBox& decode_bboxes = all_decode_bboxes[i];
285      for (map<int, vector<int> >::iterator it = all_indices[i].begin();
286           it != all_indices[i].end(); ++it) {
287        int label = it->first;
288        if (conf_scores.find(label) == conf_scores.end()) {
289          LOG(FATAL) << "Could not find confidence predictions for " << label;
290          continue;
291        }
292        const vector<float>& scores = conf_scores.find(label)->second;
293        int loc_label = share_location_ ? -1 : label;
294        if (decode_bboxes.find(loc_label) == decode_bboxes.end()) {
295          LOG(FATAL) << "Could not find location predictions for " << loc_label;
296          continue;
297        }
298        const vector<NormalizedBBox>& bboxes =
299            decode_bboxes.find(loc_label)->second;
300        vector<int>& indices = it->second;
301        if (need_save_) {
302          CHECK(label_to_name_.find(label) != label_to_name_.end())
303            << "Cannot find label: " << label << " in the label map.";
304          CHECK_LT(name_count_, names_.size());
305        }
306        for (int j = 0; j < indices.size(); ++j) {
307          int idx = indices[j];
308          top_data[count * 7] = i;
309          top_data[count * 7 + 1] = label;
310          top_data[count * 7 + 2] = scores[idx];
311          const NormalizedBBox& bbox = bboxes[idx];
312          top_data[count * 7 + 3] = bbox.xmin();
313          top_data[count * 7 + 4] = bbox.ymin();
314          top_data[count * 7 + 5] = bbox.xmax();
315          top_data[count * 7 + 6] = bbox.ymax();
316          if (need_save_) {
317            NormalizedBBox out_bbox;
318            OutputBBox(bbox, sizes_[name_count_], has_resize_, resize_param_,
319                       &out_bbox);
320            float score = top_data[count * 7 + 2];
321            float xmin = out_bbox.xmin();
322            float ymin = out_bbox.ymin();
323            float xmax = out_bbox.xmax();
324            float ymax = out_bbox.ymax();
325            ptree pt_xmin, pt_ymin, pt_width, pt_height;
326            pt_xmin.put<float>("", round(xmin * 100) / 100.);
327            pt_ymin.put<float>("", round(ymin * 100) / 100.);
328            pt_width.put<float>("", round((xmax - xmin) * 100) / 100.);
329            pt_height.put<float>("", round((ymax - ymin) * 100) / 100.);
330            ptree cur_bbox;
331            cur_bbox.push_back(std::make_pair("", pt_xmin));
332            cur_bbox.push_back(std::make_pair("", pt_ymin));
333            cur_bbox.push_back(std::make_pair("", pt_width));
334            cur_bbox.push_back(std::make_pair("", pt_height));
335            ptree cur_det;
336            cur_det.put("image_id", names_[name_count_]);
337            if (output_format_ == "ILSVRC") {
338              cur_det.put<int>("category_id", label);
339            } else {
340              cur_det.put("category_id", label_to_name_[label].c_str());
341            }
342            cur_det.add_child("bbox", cur_bbox);
343            cur_det.put<float>("score", score);
344            detections_.push_back(std::make_pair("", cur_det));
345          }
346          ++count;
347        }
348      }
349      if (need_save_) {
350        ++name_count_;
351        if (name_count_ % num_test_image_ == 0) {
352          if (output_format_ == "VOC") {
353            map<string, std::ofstream*> outfiles;
354            for (int c = 0; c < num_classes_; ++c) {
355              if (c == background_label_id_) {
356                continue;
357              }
358              string label_name = label_to_name_[c];
359              boost::filesystem::path file(
360                  output_name_prefix_ + label_name + ".txt");
361              boost::filesystem::path out_file = output_directory / file;
362              outfiles[label_name] = new std::ofstream(out_file.string().c_str(),
363                  std::ofstream::out);
364            }
365            BOOST_FOREACH(ptree::value_type &det, detections_.get_child("")) {
366              ptree pt = det.second;
367              string label_name = pt.get<string>("category_id");
368              if (outfiles.find(label_name) == outfiles.end()) {
369                std::cout << "Cannot find " << label_name << std::endl;
370                continue;
371              }
372              string image_name = pt.get<string>("image_id");
373              float score = pt.get<float>("score");
374              vector<int> bbox;
375              BOOST_FOREACH(ptree::value_type &elem, pt.get_child("bbox")) {
376                bbox.push_back(static_cast<int>(elem.second.get_value<float>()));
377              }
378              *(outfiles[label_name]) << image_name;
379              *(outfiles[label_name]) << " " << score;
380              *(outfiles[label_name]) << " " << bbox[0] << " " << bbox[1];
381              *(outfiles[label_name]) << " " << bbox[0] + bbox[2];
382              *(outfiles[label_name]) << " " << bbox[1] + bbox[3];
383              *(outfiles[label_name]) << std::endl;
384            }
385            for (int c = 0; c < num_classes_; ++c) {
386              if (c == background_label_id_) {
387                continue;
388              }
389              string label_name = label_to_name_[c];
390              outfiles[label_name]->flush();
391              outfiles[label_name]->close();
392              delete outfiles[label_name];
393            }
394          } else if (output_format_ == "COCO") {
<span onclick='openModal()' class='match'>395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + ".json");
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp("\"(null|true|false|-?[0-9]+(\\.[0-9]+)?)\"");
</span>401            ptree output;
402            output.add_child("detections", detections_);
403            std::stringstream ss;
404            write_json(ss, output);
405            std::string rv = boost::regex_replace(ss.str(), exp, "$1");
406            outfile << rv.substr(rv.find("["), rv.rfind("]") - rv.find("["))
407                << std::endl << "]" << std::endl;
408          } else if (output_format_ == "ILSVRC") {
409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + ".txt");
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &det, detections_.get_child("")) {
415              ptree pt = det.second;
416              int label = pt.get<int>("category_id");
417              string image_name = pt.get<string>("image_id");
418              float score = pt.get<float>("score");
419              vector<int> bbox;
420              BOOST_FOREACH(ptree::value_type &elem, pt.get_child("bbox")) {
421                bbox.push_back(static_cast<int>(elem.second.get_value<float>()));
422              }
423              outfile << image_name << " " << label << " " << score;
424              outfile << " " << bbox[0] << " " << bbox[1];
425              outfile << " " << bbox[0] + bbox[2];
426              outfile << " " << bbox[1] + bbox[3];
427              outfile << std::endl;
428            }
429          }
430          name_count_ = 0;
431          detections_.clear();
432        }
433      }
434    }
435    if (visualize_) {
436  #ifdef USE_OPENCV
437      vector<cv::Mat> cv_imgs;
438      this->data_transformer_->TransformInv(bottom[3], &cv_imgs);
439      vector<cv::Scalar> colors = GetColors(label_to_display_name_.size());
440      VisualizeBBox(cv_imgs, top[0], visualize_threshold_, colors,
441          label_to_display_name_, save_file_);
442  #endif  
443    }
444  }
445  #ifdef CPU_ONLY
446  STUB_GPU_FORWARD(DetectionOutputLayer, Forward);
447  #endif
448  INSTANTIATE_CLASS(DetectionOutputLayer);
449  REGISTER_LAYER_CLASS(DetectionOutput);
450  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <fstream>  
3  #include <map>
4  #include <string>
5  #include <utility>
6  #include <vector>
7  #include "boost/filesystem.hpp"
8  #include "boost/foreach.hpp"
9  #include "caffe/layers/detection_output_layer.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void DetectionOutputLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
13        const vector<Blob<Dtype>*>& top) {
14    const DetectionOutputParameter& detection_output_param =
15        this->layer_param_.detection_output_param();
16    CHECK(detection_output_param.has_num_classes()) << "Must specify num_classes";
17    num_classes_ = detection_output_param.num_classes();
18    share_location_ = detection_output_param.share_location();
19    num_loc_classes_ = share_location_ ? 1 : num_classes_;
20    background_label_id_ = detection_output_param.background_label_id();
21    code_type_ = detection_output_param.code_type();
22    variance_encoded_in_target_ =
23        detection_output_param.variance_encoded_in_target();
24    keep_top_k_ = detection_output_param.keep_top_k();
25    confidence_threshold_ = detection_output_param.has_confidence_threshold() ?
26        detection_output_param.confidence_threshold() : -FLT_MAX;
27    nms_threshold_ = detection_output_param.nms_param().nms_threshold();
28    CHECK_GE(nms_threshold_, 0.) << "nms_threshold must be non negative.";
29    eta_ = detection_output_param.nms_param().eta();
30    CHECK_GT(eta_, 0.);
31    CHECK_LE(eta_, 1.);
32    top_k_ = -1;
33    if (detection_output_param.nms_param().has_top_k()) {
34      top_k_ = detection_output_param.nms_param().top_k();
35    }
36    const SaveOutputParameter& save_output_param =
37        detection_output_param.save_output_param();
38    output_directory_ = save_output_param.output_directory();
39    if (!output_directory_.empty()) {
40      if (boost::filesystem::is_directory(output_directory_)
41  #ifdef USE_MLSL
42          && mn::is_root() == true
43  #endif
44         )
45        boost::filesystem::remove_all(output_directory_);
46  #ifdef USE_MLSL
47      if(mn::is_root() == true){
48  #endif
49      boost::filesystem::create_directories(output_directory_);
50      if(!boost::filesystem::is_directory(output_directory_))
51        LOG(FATAL) << "Failed to create directory: " << output_directory_;
52  #ifdef USE_MLSL
53      }
54  #endif
55    }
56    output_name_prefix_ = save_output_param.output_name_prefix();
57    need_save_ = output_directory_ == "" ? false : true;
58    output_format_ = save_output_param.output_format();
59    if (save_output_param.has_label_map_file()) {
60      string label_map_file = save_output_param.label_map_file();
61      if (label_map_file.empty()) {
62        LOG(WARNING) << "Provide label_map_file if output results to files.";
63        need_save_ = false;
64      } else {
65        LabelMap label_map;
66        CHECK(ReadProtoFromTextFile(label_map_file, &label_map))
67            << "Failed to read label map file: " << label_map_file;
68        CHECK(MapLabelToName(label_map, true, &label_to_name_))
69            << "Failed to convert label to name.";
70        CHECK(MapLabelToDisplayName(label_map, true, &label_to_display_name_))
71            << "Failed to convert label to display name.";
72      }
73    } else {
74      need_save_ = false;
75    }
76    if (save_output_param.has_name_size_file()) {
77      string name_size_file = save_output_param.name_size_file();
78      if (name_size_file.empty()) {
79        LOG(WARNING) << "Provide name_size_file if output results to files.";
80        need_save_ = false;
81      } else {
82        std::ifstream infile(name_size_file.c_str());
83        CHECK(infile.good())
84            << "Failed to open name size file: " << name_size_file;
85        string name;
86        int height, width;
87        while (infile >> name >> height >> width) {
88          names_.push_back(name);
89          sizes_.push_back(std::make_pair(height, width));
90        }
91        infile.close();
92        if (save_output_param.has_num_test_image()) {
93          num_test_image_ = save_output_param.num_test_image();
94        } else {
95          num_test_image_ = names_.size();
96        }
97        CHECK_LE(num_test_image_, names_.size());
98      }
99    } else {
100      need_save_ = false;
101    }
102    has_resize_ = save_output_param.has_resize_param();
103    if (has_resize_) {
104      resize_param_ = save_output_param.resize_param();
105    }
106    name_count_ = 0;
107    visualize_ = detection_output_param.visualize();
108    if (visualize_) {
109      visualize_threshold_ = 0.6;
110      if (detection_output_param.has_visualize_threshold()) {
111        visualize_threshold_ = detection_output_param.visualize_threshold();
112      }
113      data_transformer_.reset(
114          new DataTransformer<Dtype>(this->layer_param_.transform_param(),
115                                     this->phase_));
116      data_transformer_->InitRand();
117      save_file_ = detection_output_param.save_file();
118    }
119    bbox_preds_.ReshapeLike(*(bottom[0]));
120    if (!share_location_) {
121      bbox_permute_.ReshapeLike(*(bottom[0]));
122    }
123    conf_permute_.ReshapeLike(*(bottom[1]));
124  }
125  template <typename Dtype>
126  void DetectionOutputLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
127        const vector<Blob<Dtype>*>& top) {
128    if (need_save_) {
129      CHECK_LE(name_count_, names_.size());
130      if (name_count_ % num_test_image_ == 0) {
131        if (output_format_ == "VOC") {
132  #ifdef USE_MLSL
133          mn::barrier();
134  #endif
135          boost::filesystem::path output_directory(output_directory_);
136          for (map<int, string>::iterator it = label_to_name_.begin();
137               it != label_to_name_.end(); ++it) {
138            if (it->first == background_label_id_) {
139              continue;
140            }
141            std::ofstream outfile;
142            boost::filesystem::path file(
143                output_name_prefix_ + it->second + ".txt");
144            boost::filesystem::path out_file = output_directory / file;
145            outfile.open(out_file.string().c_str(), std::ofstream::out);
146          }
147        }
148      }
149    }
150    CHECK_EQ(bottom[0]->num(), bottom[1]->num());
151    if (bbox_preds_.num() != bottom[0]->num() ||
152        bbox_preds_.count(1) != bottom[0]->count(1)) {
153      bbox_preds_.ReshapeLike(*(bottom[0]));
154    }
155    if (!share_location_ && (bbox_permute_.num() != bottom[0]->num() ||
156        bbox_permute_.count(1) != bottom[0]->count(1))) {
157      bbox_permute_.ReshapeLike(*(bottom[0]));
158    }
159    if (conf_permute_.num() != bottom[1]->num() ||
160        conf_permute_.count(1) != bottom[1]->count(1)) {
161      conf_permute_.ReshapeLike(*(bottom[1]));
162    }
163    num_priors_ = bottom[2]->height() / 4;
164    CHECK_EQ(num_priors_ * num_loc_classes_ * 4, bottom[0]->channels())
165        << "Number of priors must match number of location predictions.";
166    CHECK_EQ(num_priors_ * num_classes_, bottom[1]->channels())
167        << "Number of priors must match number of confidence predictions.";
168    vector<int> top_shape(2, 1);
169    top_shape.push_back(1);
170    top_shape.push_back(7);
171    top[0]->Reshape(top_shape);
172  }
173  template <typename Dtype>
174  void DetectionOutputLayer<Dtype>::Forward_cpu(
175      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
176    const Dtype* loc_data = bottom[0]->cpu_data();
177    const Dtype* conf_data = bottom[1]->cpu_data();
178    const Dtype* prior_data = bottom[2]->cpu_data();
179    const int num = bottom[0]->num();
180    vector<LabelBBox> all_loc_preds;
181    GetLocPredictions(loc_data, num, num_priors_, num_loc_classes_,
182                      share_location_, &all_loc_preds);
183    vector<map<int, vector<float> > > all_conf_scores;
184    GetConfidenceScores(conf_data, num, num_priors_, num_classes_,
185                        &all_conf_scores);
186    vector<NormalizedBBox> prior_bboxes(num_priors_);
187    vector<vector<float> > prior_variances(num_priors_);
188    GetPriorBBoxes(prior_data, num_priors_, &prior_bboxes, &prior_variances);
189    vector<LabelBBox> all_decode_bboxes;
190    const bool clip_bbox = false;
191    DecodeBBoxesAll(all_loc_preds, prior_bboxes, prior_variances, num,
192                    share_location_, num_loc_classes_, background_label_id_,
193                    code_type_, variance_encoded_in_target_, clip_bbox,
194                    &all_decode_bboxes);
195    int num_kept = 0;
196    vector<map<int, vector<int> > > all_indices(num);
197  #ifdef _OPENMP
198    #pragma omp parallel for
199  #endif
200    for (int i = 0; i < num; ++i) {
201      const LabelBBox& decode_bboxes = all_decode_bboxes[i];
202      const map<int, vector<float> >& conf_scores = all_conf_scores[i];
203      map<int, vector<int> > indices;
204      int num_det = 0;
205      for (int c = 0; c < num_classes_; ++c) {
206        if (c == background_label_id_) {
207          continue;
208        }
209        if (conf_scores.find(c) == conf_scores.end()) {
210          LOG(FATAL) << "Could not find confidence predictions for label " << c;
211        }
212        const vector<float>& scores = conf_scores.find(c)->second;
213        int label = share_location_ ? -1 : c;
214        if (decode_bboxes.find(label) == decode_bboxes.end()) {
215          LOG(FATAL) << "Could not find location predictions for label " << label;
216          continue;
217        }
218        const vector<NormalizedBBox>& bboxes = decode_bboxes.find(label)->second;
219        ApplyNMSFast(bboxes, scores, confidence_threshold_, nms_threshold_, eta_,
220            top_k_, &(indices[c]));
221        num_det += indices[c].size();
222      }
223      int num_to_add = 0;
224      if (keep_top_k_ > -1 && num_det > keep_top_k_) {
225        vector<pair<float, pair<int, int> > > score_index_pairs;
226        for (map<int, vector<int> >::iterator it = indices.begin();
227             it != indices.end(); ++it) {
228          int label = it->first;
229          const vector<int>& label_indices = it->second;
230          if (conf_scores.find(label) == conf_scores.end()) {
231            LOG(FATAL) << "Could not find location predictions for " << label;
232            continue;
233          }
234          const vector<float>& scores = conf_scores.find(label)->second;
235          for (int j = 0; j < label_indices.size(); ++j) {
236            int idx = label_indices[j];
237            CHECK_LT(idx, scores.size());
238            score_index_pairs.push_back(std::make_pair(
239                    scores[idx], std::make_pair(label, idx)));
240          }
241        }
242        std::sort(score_index_pairs.begin(), score_index_pairs.end(),
243                  SortScorePairDescend<pair<int, int> >);
244        score_index_pairs.resize(keep_top_k_);
245        map<int, vector<int> > new_indices;
246        for (int j = 0; j < score_index_pairs.size(); ++j) {
247          int label = score_index_pairs[j].second.first;
248          int idx = score_index_pairs[j].second.second;
249          new_indices[label].push_back(idx);
250        }
251        all_indices[i] = new_indices;
252        num_to_add = keep_top_k_;
253      } else {
254        all_indices[i] = indices;
255        num_to_add = num_det;
256      }
257  #ifdef _OPENMP
258      #pragma omp atomic
259  #endif
260      num_kept += num_to_add;
261    }
262    vector<int> top_shape(2, 1);
263    top_shape.push_back(num_kept);
264    top_shape.push_back(7);
265    Dtype* top_data;
266    if (num_kept == 0) {
267      LOG(INFO) << "Couldn't find any detections";
268      top_shape[2] = num;
269      top[0]->Reshape(top_shape);
270      top_data = top[0]->mutable_cpu_data();
271      caffe_set<Dtype>(top[0]->count(), -1, top_data);
272      for (int i = 0; i < num; ++i) {
273        top_data[0] = i;
274        top_data += 7;
275      }
276    } else {
277      top[0]->Reshape(top_shape);
278      top_data = top[0]->mutable_cpu_data();
279    }
280    int count = 0;
281    boost::filesystem::path output_directory(output_directory_);
282    for (int i = 0; i < num; ++i) {
283      const map<int, vector<float> >& conf_scores = all_conf_scores[i];
284      const LabelBBox& decode_bboxes = all_decode_bboxes[i];
285      for (map<int, vector<int> >::iterator it = all_indices[i].begin();
286           it != all_indices[i].end(); ++it) {
287        int label = it->first;
288        if (conf_scores.find(label) == conf_scores.end()) {
289          LOG(FATAL) << "Could not find confidence predictions for " << label;
290          continue;
291        }
292        const vector<float>& scores = conf_scores.find(label)->second;
293        int loc_label = share_location_ ? -1 : label;
294        if (decode_bboxes.find(loc_label) == decode_bboxes.end()) {
295          LOG(FATAL) << "Could not find location predictions for " << loc_label;
296          continue;
297        }
298        const vector<NormalizedBBox>& bboxes =
299            decode_bboxes.find(loc_label)->second;
300        vector<int>& indices = it->second;
301        if (need_save_) {
302          CHECK(label_to_name_.find(label) != label_to_name_.end())
303            << "Cannot find label: " << label << " in the label map.";
304          CHECK_LT(name_count_, names_.size());
305        }
306        for (int j = 0; j < indices.size(); ++j) {
307          int idx = indices[j];
308          top_data[count * 7] = i;
309          top_data[count * 7 + 1] = label;
310          top_data[count * 7 + 2] = scores[idx];
311          const NormalizedBBox& bbox = bboxes[idx];
312          top_data[count * 7 + 3] = bbox.xmin();
313          top_data[count * 7 + 4] = bbox.ymin();
314          top_data[count * 7 + 5] = bbox.xmax();
315          top_data[count * 7 + 6] = bbox.ymax();
316          if (need_save_) {
317            NormalizedBBox out_bbox;
318            OutputBBox(bbox, sizes_[name_count_], has_resize_, resize_param_,
319                       &out_bbox);
320            float score = top_data[count * 7 + 2];
321            float xmin = out_bbox.xmin();
322            float ymin = out_bbox.ymin();
323            float xmax = out_bbox.xmax();
324            float ymax = out_bbox.ymax();
325            ptree pt_xmin, pt_ymin, pt_width, pt_height;
326            pt_xmin.put<float>("", round(xmin * 100) / 100.);
327            pt_ymin.put<float>("", round(ymin * 100) / 100.);
328            pt_width.put<float>("", round((xmax - xmin) * 100) / 100.);
329            pt_height.put<float>("", round((ymax - ymin) * 100) / 100.);
330            ptree cur_bbox;
331            cur_bbox.push_back(std::make_pair("", pt_xmin));
332            cur_bbox.push_back(std::make_pair("", pt_ymin));
333            cur_bbox.push_back(std::make_pair("", pt_width));
334            cur_bbox.push_back(std::make_pair("", pt_height));
335            ptree cur_det;
336            cur_det.put("image_id", names_[name_count_]);
337            if (output_format_ == "ILSVRC") {
338              cur_det.put<int>("category_id", label);
339            } else {
340              cur_det.put("category_id", label_to_name_[label].c_str());
341            }
342            cur_det.add_child("bbox", cur_bbox);
343            cur_det.put<float>("score", score);
344            detections_.push_back(std::make_pair("", cur_det));
345          }
346          ++count;
347        }
348      }
349      if (need_save_) {
350        ++name_count_;
351        if (name_count_ % num_test_image_ == 0) {
352          if (output_format_ == "VOC") {
353            map<string, std::ofstream*> outfiles;
354            for (int c = 0; c < num_classes_; ++c) {
355              if (c == background_label_id_) {
356                continue;
357              }
358              string label_name = label_to_name_[c];
359              boost::filesystem::path file(
360                  output_name_prefix_ + label_name + ".txt");
361              boost::filesystem::path out_file = output_directory / file;
362              outfiles[label_name] = new std::ofstream(out_file.string().c_str(),
363                  std::ofstream::out);
364            }
365            BOOST_FOREACH(ptree::value_type &det, detections_.get_child("")) {
366              ptree pt = det.second;
367              string label_name = pt.get<string>("category_id");
368              if (outfiles.find(label_name) == outfiles.end()) {
369                std::cout << "Cannot find " << label_name << std::endl;
370                continue;
371              }
372              string image_name = pt.get<string>("image_id");
373              float score = pt.get<float>("score");
374              vector<int> bbox;
375              BOOST_FOREACH(ptree::value_type &elem, pt.get_child("bbox")) {
376                bbox.push_back(static_cast<int>(elem.second.get_value<float>()));
377              }
378              *(outfiles[label_name]) << image_name;
379              *(outfiles[label_name]) << " " << score;
380              *(outfiles[label_name]) << " " << bbox[0] << " " << bbox[1];
381              *(outfiles[label_name]) << " " << bbox[0] + bbox[2];
382              *(outfiles[label_name]) << " " << bbox[1] + bbox[3];
383              *(outfiles[label_name]) << std::endl;
384            }
385            for (int c = 0; c < num_classes_; ++c) {
386              if (c == background_label_id_) {
387                continue;
388              }
389              string label_name = label_to_name_[c];
390              outfiles[label_name]->flush();
391              outfiles[label_name]->close();
392              delete outfiles[label_name];
393            }
394          } else if (output_format_ == "COCO") {
395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + ".json");
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp("\"(null|true|false|-?[0-9]+(\\.[0-9]+)?)\"");
401            ptree output;
402            output.add_child("detections", detections_);
403            std::stringstream ss;
404            write_json(ss, output);
405            std::string rv = boost::regex_replace(ss.str(), exp, "$1");
406            outfile << rv.substr(rv.find("["), rv.rfind("]") - rv.find("["))
407                << std::endl << "]" << std::endl;
408          } else if (output_format_ == "ILSVRC") {
<span onclick='openModal()' class='match'>409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + ".txt");
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &det, detections_.get_child("")) {
</span>415              ptree pt = det.second;
416              int label = pt.get<int>("category_id");
417              string image_name = pt.get<string>("image_id");
418              float score = pt.get<float>("score");
419              vector<int> bbox;
420              BOOST_FOREACH(ptree::value_type &elem, pt.get_child("bbox")) {
421                bbox.push_back(static_cast<int>(elem.second.get_value<float>()));
422              }
423              outfile << image_name << " " << label << " " << score;
424              outfile << " " << bbox[0] << " " << bbox[1];
425              outfile << " " << bbox[0] + bbox[2];
426              outfile << " " << bbox[1] + bbox[3];
427              outfile << std::endl;
428            }
429          }
430          name_count_ = 0;
431          detections_.clear();
432        }
433      }
434    }
435    if (visualize_) {
436  #ifdef USE_OPENCV
437      vector<cv::Mat> cv_imgs;
438      this->data_transformer_->TransformInv(bottom[3], &cv_imgs);
439      vector<cv::Scalar> colors = GetColors(label_to_display_name_.size());
440      VisualizeBBox(cv_imgs, top[0], visualize_threshold_, colors,
441          label_to_display_name_, save_file_);
442  #endif  
443    }
444  }
445  #ifdef CPU_ONLY
446  STUB_GPU_FORWARD(DetectionOutputLayer, Forward);
447  #endif
448  INSTANTIATE_CLASS(DetectionOutputLayer);
449  REGISTER_LAYER_CLASS(DetectionOutput);
450  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-detection_output_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>395            boost::filesystem::path output_directory(output_directory_);
396            boost::filesystem::path file(output_name_prefix_ + ".json");
397            boost::filesystem::path out_file = output_directory / file;
398            std::ofstream outfile;
399            outfile.open(out_file.string().c_str(), std::ofstream::out);
400            boost::regex exp("\"(null|true|false|-?[0-9]+(\\.[0-9]+)?)\"");
</pre></code></div>
                <div class="column column_space"><pre><code>409            boost::filesystem::path output_directory(output_directory_);
410            boost::filesystem::path file(output_name_prefix_ + ".txt");
411            boost::filesystem::path out_file = output_directory / file;
412            std::ofstream outfile;
413            outfile.open(out_file.string().c_str(), std::ofstream::out);
414            BOOST_FOREACH(ptree::value_type &det, detections_.get_child("")) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    