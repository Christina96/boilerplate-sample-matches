
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.0746268656716418%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</h3>
            <pre><code>1  #ifndef SPARSEVECTOR_H
2  #define SPARSEVECTOR_H
3  namespace Scintilla::Internal {
4  template <typename T>
5  class SparseVector {
6  private:
7  	Partitioning<Sci::Position> starts;
8  	SplitVector<T> values;
9  	T empty;	
10  	void ClearValue(Sci::Position partition) noexcept {
11  		values.SetValueAt(partition, T());
12  	}
13  public:
14  	SparseVector() : empty() {
15  		starts = Partitioning<Sci::Position>(8);
16  		values = SplitVector<T>();
17  		values.InsertEmpty(0, 2);
18  	}
19  	Sci::Position Length() const noexcept {
20  		return starts.Length();
21  	}
22  	Sci::Position Elements() const noexcept {
23  		return starts.Partitions();
24  	}
25  	Sci::Position PositionOfElement(Sci::Position element) const noexcept {
26  		return starts.PositionFromPartition(element);
27  	}
28  	Sci::Position ElementFromPosition(Sci::Position position) const noexcept {
29  		if (position < Length()) {
30  			return starts.PartitionFromPosition(position);
31  		} else {
32  			return starts.Partitions();
33  		}
34  	}
35  	const T& ValueAt(Sci::Position position) const noexcept {
36  		assert(position <= Length());
37  		const Sci::Position partition = ElementFromPosition(position);
38  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
39  		if (startPartition == position) {
40  			return values.ValueAt(partition);
41  		} else {
42  			return empty;
43  		}
44  	}
45  	T Extract(Sci::Position position) {
46  		assert(position <= Length());
47  		const Sci::Position partition = ElementFromPosition(position);
48  		assert(partition >= 0);
49  		assert(partition <= starts.Partitions());
50  		assert(starts.PositionFromPartition(partition) == position);
51  		T value = std::move(values.operator[](partition));
52  		if ((partition > 0) && (partition < starts.Partitions())) {
53  			starts.RemovePartition(partition);
54  			values.Delete(partition);
55  		}
56  		Check();
57  		return value;
58  	}
59  	template <typename ParamType>
60  	void SetValueAt(Sci::Position position, ParamType &&value) {
61  		assert(position <= Length());
62  		const Sci::Position partition = ElementFromPosition(position);
<span onclick='openModal()' class='match'>63  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
64  		if (value == T()) {
65  			if (position == 0 || position == Length()) {
66  				ClearValue(partition);
67  			} else if (position == startPartition) {
</span>68  				ClearValue(partition);
69  				starts.RemovePartition(partition);
70  				values.Delete(partition);
71  			}
72  		} else {
73  			if (position == startPartition) {
74  				ClearValue(partition);
75  				values.SetValueAt(partition, std::forward<ParamType>(value));
76  			} else {
77  				starts.InsertPartition(partition + 1, position);
78  				values.Insert(partition + 1, std::forward<ParamType>(value));
79  			}
80  		}
81  	}
82  	void InsertSpace(Sci::Position position, Sci::Position insertLength) {
83  		assert(position <= Length());
84  		const Sci::Position partition = starts.PartitionFromPosition(position);
85  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
86  		if (startPartition == position) {
87  			const bool positionOccupied = values.ValueAt(partition) != T();
88  			if (partition == 0) {
89  				if (positionOccupied) {
90  					starts.InsertPartition(1, 0);
91  					values.InsertEmpty(0, 1);
92  				}
93  				starts.InsertText(partition, insertLength);
94  			} else {
95  				if (positionOccupied) {
96  					starts.InsertText(partition - 1, insertLength);
97  				} else {
98  					starts.InsertText(partition, insertLength);
99  				}
100  			}
101  		} else {
102  			starts.InsertText(partition, insertLength);
103  		}
104  	}
105  	void DeletePosition(Sci::Position position) {
106  		assert(position < Length());
107  		Sci::Position partition = starts.PartitionFromPosition(position);
108  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
109  		if (startPartition == position) {
110  			if (partition == 0) {
111  				ClearValue(0);
112  				if (starts.PositionFromPartition(1) == 1) {
113  					if (Elements() > 1) {
114  						starts.RemovePartition(partition + 1);
115  						values.Delete(partition);
116  					}
117  				}
118  			} else if (partition == starts.Partitions()) {
119  				ClearValue(partition);
120  				throw std::runtime_error("SparseVector: deleting end partition.");
121  			} else {
122  				ClearValue(partition);
123  				starts.RemovePartition(partition);
124  				values.Delete(partition);
125  				partition--;
126  			}
127  		}
128  		starts.InsertText(partition, -1);
129  		Check();
130  	}
131  	void DeleteAll() {
132  		starts = Partitioning<Sci::Position>(8);
133  		values = SplitVector<T>();
134  		values.InsertEmpty(0, 2);
135  	}
136  	void DeleteRange(Sci::Position position, Sci::Position deleteLength) {
137  		if (position > Length() || (deleteLength == 0)) {
138  			return;
139  		}
140  		const Sci::Position positionEnd = position + deleteLength;
141  		assert(positionEnd <= Length());
142  		if (position == 0) {
143  			while ((Elements() > 1) && (starts.PositionFromPartition(1) <= deleteLength)) {
144  				starts.RemovePartition(1);
145  				values.Delete(0);
146  			}
147  			starts.InsertText(0, -deleteLength);
148  			if (Length() == 0) {
149  				ClearValue(0);
150  			}
151  		} else {
152  			const Sci::Position partition = starts.PartitionFromPosition(position);
153  			const bool atPartitionStart = position == starts.PositionFromPartition(partition);
154  			const Sci::Position partitionDelete = partition + (atPartitionStart ? 0 : 1);
155  			assert(partitionDelete > 0);
156  			for (;;) {
157  				const Sci::Position positionAtIndex = starts.PositionFromPartition(partitionDelete);
158  				assert(position <= positionAtIndex);
159  				if (positionAtIndex >= positionEnd) {
160  					break;
161  				}
162  				assert(partitionDelete <= Elements());
163  				starts.RemovePartition(partitionDelete);
164  				values.Delete(partitionDelete);
165  			}
166  			starts.InsertText(partition - (atPartitionStart ? 1 : 0), -deleteLength);
167  		}
168  		Check();
169  	}
170  	Sci::Position PositionNext(Sci::Position start) const noexcept {
171  		const Sci::Position element = ElementFromPosition(start);
172  		if (element < Elements()) {
173  			return PositionOfElement(element + 1);
174  		}
175  		return Length() + 1;	
176  	}
177  	Sci::Position IndexAfter(Sci::Position position) const noexcept {
178  		assert(position < Length());
179  		if (position < 0)
180  			return 0;
181  		const Sci::Position partition = starts.PartitionFromPosition(position);
182  		return partition + 1;
183  	}
184  	void Check() const {
185  #ifdef CHECK_CORRECTNESS
186  		starts.Check();
187  		if (starts.Partitions() != values.Length() - 1) {
188  			throw std::runtime_error("SparseVector: Partitions and values different lengths.");
189  		}
190  #endif
191  	}
192  };
193  }
194  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gnuplot.h</h3>
            <pre><code>1  #ifndef gnuplot_h
2  #define gnuplot_h
3  typedef enum {
4    gpsNoAuto, gpsAuto, gpsLog, gpsLog2X, gpsLog2Y, gpsLog2XY, gpsLog10X,
5    gpsLog10Y, gpsLog10XY
6  } TGpScaleTy;
7  typedef enum {
8    gpwUndef, gpwLines, gpwPoints, gpwLinesPoints, gpwImpulses, gpwDots,
9    gpwSteps, gpwFSteps, gpwHiSteps, gpwBoxes, gpwErrBars, gpwFilledCurves, gpwMax
10  } TGpSeriesTy;
11  class TGnuPlot {
12  public:
13    static TStr GnuPlotPath;
14    static TStr GnuPlotFNm;
15    static TStr DefPlotFNm;
16    static TStr DefDataFNm;
17  private:
18    class TGpSeries {
19    public:
20      TGpSeriesTy SeriesTy;
21      TFltKdV XYValV;
22      TFltV ZValV; 
23      TStr Label, WithStyle, DataFNm;
24      int XCol, YCol, ZCol;
25    public:
26      TGpSeries() : SeriesTy(gpwLines), XYValV(), ZValV(), Label(), WithStyle(), DataFNm(), XCol(0), YCol(0), ZCol(0) { }
27      TGpSeries(const TGpSeries& Gps);
28      TGpSeries& operator = (const TGpSeries& Gps);
29      bool operator < (const TGpSeries& Gps) const;
30      bool SaveXVals() const { return (YCol-XCol)==1; }
31    };
32    class TGpSeriesCmp {
33    private:
34      const TVec<TGpSeries>& SeriesV;
35    public:
36      TGpSeriesCmp(const TVec<TGpSeries>& _SeriesV) : SeriesV(_SeriesV) { }
37      bool operator () (const int& Left, const int& Right) const {
38        return SeriesV[Left] > SeriesV[Right]; }
39    };
40  private:
41    static int Tics42;        
42    TStr DataFNm, PlotFNm;
43    TStr Title, LblX, LblY;
44    TGpScaleTy ScaleTy;
45    TFltPr YRange, XRange;
46    bool SetGrid, SetPause;
47    TVec<TGpSeries> SeriesV;
48    TStrV MoreCmds;
49  public:
50    static int GetTics42();
51  public:
52    TStr GetSeriesPlotStr(const int& PlotN);
53    int IsSameXCol(const int& CurId, const int& PrevId) const;
54    void CreatePlotFile(const TStr& Comment = TStr());
55    void RunGnuPlot() const;
56  public:
57    TGnuPlot(const TStr& FileNm="gplot", const TStr& PlotTitle=TStr(), const bool& Grid=true);
58    TGnuPlot(const TStr& DataFileNm, const TStr& PlotFileNm, const TStr& PlotTitle, const bool& Grid);
59    TGnuPlot(const TGnuPlot& GnuPlot);
60    TGnuPlot& operator = (const TGnuPlot& GnuPlot);
61    void SetTitle(const TStr& PlotTitle) { Title = PlotTitle; }
62    void SetXLabel(const TStr& XLabel) { LblX = XLabel; }
63    void SetYLabel(const TStr& YLabel) { LblY = YLabel; }
64    void SetXYLabel(const TStr& XLabel, const TStr& YLabel) { LblX = XLabel;  LblY = YLabel; }
65    void SetDataPlotFNm(const TStr& DatFNm, const TStr& PltFNm) { DataFNm = DatFNm;  PlotFNm = PltFNm; }
66    void ShowGrid(const bool& Show) { SetGrid = Show; }
67    void Pause(const bool& DoPause) { SetPause = DoPause; }
68    void SetScale(const TGpScaleTy& GpScaleTy) { ScaleTy = GpScaleTy;}
69    void SetXRange(const double& Min, const double& Max) { XRange = TFltPr(Min, Max); }
70    void SetYRange(const double& Min, const double& Max) { YRange = TFltPr(Min, Max); }
71    void AddCmd(const TStr& Cmd) { MoreCmds.Add(Cmd); }
72    TStr GetLineStyle(const int& PlotId) const { return SeriesV[PlotId].WithStyle; }
73    void SetLineStyle(const int& PlotId, const TStr& StyleStr) { SeriesV[PlotId].WithStyle = StyleStr; }
74    int AddFunc(const TStr& FuncStr, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
75    int AddPlot(const TIntV& YValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
76    int AddPlot(const TFltV& YValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
77    int AddPlot(const TFltV& XValV, const TFltV& YValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
78    int AddPlot(const TIntPrV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
79    int AddPlot(const TFltPrV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
80    int AddPlot(const TIntKdV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
81    int AddPlot(const TFltKdV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
82    int AddPlot(const TIntFltKdV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
83    int AddPlot(const TIntFltPrV& XYValV, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
84    int AddPlot(const TStr& DataFNm, const int& ColY, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
85    int AddPlot(const TStr& DataFNm, const int& ColX, const int& ColY, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr());
86    template<class TKey, class TDat, class THashFunc>
87    int AddPlot(const THash<TKey, TDat, THashFunc>& XYValH, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr(), const bool& ExpBucket = false);
88    template<class TKey, class THashFunc>
89    int AddPlot(const THash<TKey, TMom, THashFunc>& ValMomH, const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& Label=TStr(), const TStr& Style=TStr(),
90      bool PlotAvg=true, bool PlotMed=true, bool PlotMin=false, bool PlotMax=false, bool PlotSDev=false, bool PlotStdErr=false, const bool& ExpBucket=false);
91    int AddErrBar(const TFltTrV& XYDValV, const TStr& Label=TStr());
92    int AddErrBar(const TFltTrV& XYDValV, const TStr& DatLabel, const TStr& ErrLabel);
93    int AddErrBar(const TFltV& YValV, const TFltV& DeltaYV, const TStr& Label=TStr());
94    int AddErrBar(const TFltV& XValV, const TFltV& YValV, const TFltV& DeltaYV, const TStr& Label=TStr());
95    int AddErrBar(const TFltPrV& XYValV, const TFltV& DeltaYV, const TStr& Label=TStr());
96    int AddErrBar(const TFltKdV& XYValV, const TFltV& DeltaYV, const TStr& Label=TStr());
97    int AddErrBar(const TFltPrV& XYValV, const TFltV& DeltaYV, const TStr& DatLabel, const TStr& ErrLabel);
98    int AddLinFit(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const TStr& Style=TStr());
99    int AddPwrFit(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const TStr& Style=TStr());
100    int AddPwrFit1(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const TStr& Style=TStr());
101    int AddPwrFit2(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const double& MinX=-1.0, const TStr& Style=TStr());
102    int AddPwrFit3(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const double& MinX=-1.0, const TStr& Style=TStr());
103    int AddPwrFit3(const int& PlotId, const TGpSeriesTy& SeriesTy, const double& MinX, const TStr& Style, double& Intercept, double& Slope, double& R2);
104    int AddLogFit(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const TStr& Style=TStr());
105    int AddExpFit(const int& PlotId, const TGpSeriesTy& SeriesTy=gpwLines, const double& FitXOffset=0.0, const TStr& Style=TStr());
106    void SavePng(const int& SizeX=1000, const int& SizeY=800, const TStr& Comment=TStr()) {
107      SavePng(PlotFNm.GetFPath()+PlotFNm.GetFMid()+".png", SizeX, SizeY, Comment); }
108    void SavePng(const TStr& FNm, const int& SizeX=1000, const int& SizeY=800, const TStr& Comment=TStr(), const TStr& Terminal=TStr());
109    void SaveEps(const int& FontSz=30, const TStr& Comment=TStr()) {
110      SaveEps(PlotFNm.GetFPath()+PlotFNm.GetFMid()+".eps", FontSz, Comment); }
111    void SaveEps(const TStr& FNm, const int& FontSz=30, const TStr& Comment=TStr());
112    void Plot(const TStr& Comment=TStr()) { CreatePlotFile(Comment);  RunGnuPlot(); }
113    static void MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV,
114      const double& BinFactor = 2, const double& MinYVal = 1);
115    static void MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV,
116      const double& BinFactor = 2, const double& MinYVal = 1);
117    static void LoadTs(const TStr& FNm, TStrV& ColNmV, TVec<TFltKdV>& ColV);
118    static TStr GetScaleStr(const TGpScaleTy& ScaleTy);
119    static TStr GetSeriesTyStr(const TGpSeriesTy& SeriesTy);
120    static void SaveTs(const TIntKdV& KdV, const TStr& FNm, const TStr& HeadLn = TStr());
121    static void SaveTs(const TIntFltKdV& KdV, const TStr& FNm, const TStr& HeadLn = TStr());
122    template <class TVal1, class TVal2>
123    static void SaveTs(const TVec<TPair<TVal1, TVal2> >& ValV, const TStr& FNm, const TStr& HeadLn = TStr());
124    template <class TVal1, class TVal2, class TVal3>
125    static void SaveTs(const TVec<TTriple<TVal1, TVal2, TVal3> >& ValV, const TStr& FNm, const TStr& HeadLn = TStr());
126    template <class TVal, int Vals>
127    static void SaveTs(const TVec<TTuple<TVal, Vals> >& ValV, const TStr& FNm, const TStr& HeadLn = TStr());
128    static void Test();
129    template <class TVal1>
130    static void PlotValV(const TVec<TVal1>& ValV, const TStr& OutFNmPref, const TStr& Desc="",
131      const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false,
132      const TGpSeriesTy& SeriesTy=gpwLinesPoints);
133    template <class TVal1, class TVal2>
134    static void PlotValV(const TVec<TPair<TVal1, TVal2> >& ValV, const TStr& OutFNmPref, const TStr& Desc="",
135     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false, 
136     const TGpSeriesTy& SeriesTy=gpwLinesPoints);
137    template <class TVal1, class TVal2, class TVal3>
138    static void PlotValV(const TVec<TTriple<TVal1, TVal2, TVal3> >& ValV, const TStr& OutFNmPref, const TStr& Desc="",
139     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false,
140     const TGpSeriesTy& SeriesTy=gpwLinesPoints, const TStr& ErrBarStr = "");
141    template <class TVal1, class TVal2>
142    static void PlotValV(const TVec<TPair<TVal1, TVal2> >& ValV1, const TStr& Name1,
143      const TVec<TPair<TVal1, TVal2> >& ValV2, const TStr& Name2, const TStr& OutFNmPref, const TStr& Desc="",
144     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false, 
145     const TGpSeriesTy& SeriesTy=gpwLinesPoints);
146    template <class TKey, class TVal, class THashFunc>
147    static void PlotValRank(const THash<TKey, TVal, THashFunc>& ValCntH, const TStr& OutFNmPref, const TStr& Desc="",
148      const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false,
149      const TGpSeriesTy& SeriesTy=gpwLinesPoints);
150    template <class TKey, class TVal, class THashFunc>
151    static void PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH, const TStr& OutFNmPref, const TStr& Desc="",
152     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const bool& PowerFit=false, 
153     const TGpSeriesTy& SeriesTy=gpwLinesPoints, const bool& PlotCCDF=false, const bool& ExpBucket=false);
154    template <class TKey, class TVal, class THashFunc>
155    static void PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH1, const TStr& Label1, 
156      const THash<TKey, TVal, THashFunc>& ValCntH2, const TStr& Label2, 
157      const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel, const TStr& YLabel, 
158      const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints);
159    template <class TKey, class TVal, class THashFunc>
160    static void PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH1, const TStr& Label1, 
161      const THash<TKey, TVal, THashFunc>& ValCntH2, const TStr& Label2, 
162      const THash<TKey, TVal, THashFunc>& ValCntH3, const TStr& Label3, 
163      const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel, const TStr& YLabel, 
164      const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints);
165    template <class TVal1>
166    static void PlotValMomH(const THash<TVal1, TMom>& ValMomH, const TStr& OutFNmPref, const TStr& Desc="",
167     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints,
168     bool PlotAvg=true, bool PlotMed=true, bool PlotMin=false, bool PlotMax=false, bool PlotSDev=false, bool PlotStdErr=true, bool PlotScatter=false);
169    template <class TVal1>
170    static void PlotValMomH(const THash<TVal1, TMom>& ValMomH1, const TStr& Label1, const THash<TVal1, TMom>& ValMomH2, const TStr& Label2,
171     const TStr& OutFNmPref, const TStr& Desc="",
172     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints,
173     bool PlotAvg=true, bool PlotMed=true, bool PlotMin=false, bool PlotMax=false, bool PlotSDev=false, bool PlotStdErr=true, bool PlotScatter=false);
174    template <class TVal2>
175    static void PlotValOverTm(const TVec<TPair<TSecTm, TVal2> >& ValV, const TStr& OutFNmPref, const TStr& Desc="",
176     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints);
177    template <class TVal2>
178    static void PlotCntOverTm(const THash<TSecTm, TVal2>& CntH, const TStr& OutFNmPref, const TStr& Desc="",
179     const TStr& XLabel="", const TStr& YLabel="", const TGpScaleTy& ScaleTy=gpsAuto, const TGpSeriesTy& SeriesTy=gpwLinesPoints);
180  };
181  template <class TVal1, class TVal2>
182  void TGnuPlot::SaveTs(const TVec<TPair<TVal1, TVal2> >& ValV, const TStr& FNm, const TStr& HeadLn) {
183    FILE *F = fopen(FNm.CStr(), "wt");
184    EAssert(F);
185    if (! HeadLn.Empty()) { fprintf(F, "# %s\n", HeadLn.CStr()); }
186    for (int i = 0; i < ValV.Len(); i++) {
187      fprintf(F, "%g\t%g\n", double(ValV[i].Val1), double(ValV[i].Val2)); }
188    fclose(F);
189  }
190  template <class TVal1, class TVal2, class TVal3>
191  void TGnuPlot::SaveTs(const TVec<TTriple<TVal1, TVal2, TVal3> >& ValV, const TStr& FNm, const TStr& HeadLn) {
192    FILE *F = fopen(FNm.CStr(), "wt");
193    EAssert(F);
194    if (! HeadLn.Empty()) { fprintf(F, "# %s\n", HeadLn.CStr()); }
195    for (int i = 0; i < ValV.Len(); i++) {
196      fprintf(F, "%g\t%g\t%g\n", double(ValV[i].Val1), double(ValV[i].Val2), double(ValV[i].Val3)); }
197    fclose(F);
198  }
199  template <class TVal, int Vals>
200  void TGnuPlot::SaveTs(const TVec<TTuple<TVal, Vals> >& ValV, const TStr& FNm, const TStr& HeadLn) {
201    FILE *F = fopen(FNm.CStr(), "wt");
202    EAssert(F);
203    if (! HeadLn.Empty()) { fprintf(F, "# %s\n", HeadLn.CStr()); }
204    for (int i = 0; i < ValV.Len(); i++) {
205      fprintf(F, "%g", double(ValV[i][0]));
206      for (int v = 1; v < Vals; v++) {
207        fprintf(F, "\t%g", double(ValV[i][v])); }
208      fprintf(F, "\n");
209    }
210    fclose(F);
211  }
212  template<class TKey, class TDat, class THashFunc>
213  int TGnuPlot::AddPlot(const THash<TKey, TDat, THashFunc>& XYValH, const TGpSeriesTy& SeriesTy, const TStr& Label, const TStr& Style, const bool& ExpBucket) {
214    TFltPrV XYFltValV(XYValH.Len(), 0);  
215    for (int k = XYValH.FFirstKeyId();  XYValH.FNextKeyId(k); ) { 
216      XYFltValV.Add(TFltPr(TFlt(XYValH.GetKey(k)), TFlt(XYValH[k]))); 
217    }  
218    XYFltValV.Sort();
219    if (ExpBucket) {
220      TFltPrV BucketV;
221      TGnuPlot::MakeExpBins(XYFltValV, BucketV);
222      BucketV.Swap(XYFltValV);
223    }
224    return AddPlot(XYFltValV, SeriesTy, Label, Style); 
225  }
226  template<class TKey, class THashFunc>
227  int TGnuPlot::AddPlot(const THash<TKey, TMom, THashFunc>& ValMomH, const TGpSeriesTy& SeriesTy, const TStr& Label, const TStr& Style, bool PlotAvg, bool PlotMed, bool PlotMin, bool PlotMax, bool PlotSDev, bool PlotStdErr, const bool& ExpBucket) {
228    TFltTrV AvgV, StdErrV;
229    TFltPrV AvgV2, MedV, MinV, MaxV, BucketV;
230    for (int i = ValMomH.FFirstKeyId(); ValMomH.FNextKeyId(i); ) {
231      TMom Mom(ValMomH[i]);
232      if (! Mom.IsDef()) { Mom.Def(); }
<span onclick='openModal()' class='match'>233      const double x = ValMomH.GetKey(i);
234      if (PlotAvg) { 
235        if (PlotSDev) { 
236          AvgV.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev())); } 
237        else if (PlotStdErr) {
</span>238          StdErrV.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev()/sqrt((double)Mom.GetVals()))); 
239        } else {
240          AvgV2.Add(TFltPr(x, Mom.GetMean()));
241        }
242      }
243      if (PlotMed) { MedV.Add(TFltPr(x, Mom.GetMedian())); }
244      if (PlotMin) { MinV.Add(TFltPr(x, Mom.GetMn())); }
245      if (PlotMax) { MaxV.Add(TFltPr(x, Mom.GetMx())); }
246    }
247    AvgV.Sort();  AvgV2.Sort();
248    MedV.Sort();  MinV.Sort();  MaxV.Sort(); 
249    int PlotId=0;
250    if (ExpBucket) {
251      if (! AvgV2.Empty()) { TGnuPlot::MakeExpBins(AvgV2, BucketV);  BucketV.Swap(AvgV2); }
252      if (! MedV.Empty()) { TGnuPlot::MakeExpBins(MedV, BucketV);  BucketV.Swap(MedV); }
253      if (! MinV.Empty()) { TGnuPlot::MakeExpBins(MinV, BucketV);  BucketV.Swap(MinV); }
254      if (! MaxV.Empty()) { TGnuPlot::MakeExpBins(MaxV, BucketV);  BucketV.Swap(MaxV); }
255    }
256    if (! AvgV.Empty()) { PlotId = AddErrBar(AvgV, Label+" Average", Label+" StdDev"); }
257    if (! AvgV2.Empty()) { PlotId = AddPlot(AvgV2, SeriesTy, Label+" Average", Style); }
258    if (! MedV.Empty()) { PlotId = AddPlot(MedV, SeriesTy, Label+" Median", Style); }
259    if (! MinV.Empty()) { PlotId = AddPlot(MinV, SeriesTy, Label+" Min", Style); }
260    if (! MaxV.Empty()) { PlotId = AddPlot(MaxV, SeriesTy, Label+" Max", Style); }
261    if (! StdErrV.Empty()) { PlotId = AddErrBar(StdErrV, Label+" Average", Label+" StdErr"); }
262    return PlotId;
263  }
264  template <class TVal1, class TVal2>
265  void TGnuPlot::PlotValV(const TVec<TPair<TVal1, TVal2> >& ValV, const TStr& OutFNmPref, const TStr& Desc,
266                          const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const bool& PowerFit, const TGpSeriesTy& SeriesTy) {
267    TFltKdV IdCntV(ValV.Len(), 0);
268    for (int i = 0; i < ValV.Len(); i++) {
269      IdCntV.Add(TFltKd(double(ValV[i].Val1), double(ValV[i].Val2))); }
270    if (IdCntV.Empty()) { printf("*** Empty plot %s\n", OutFNmPref.CStr());  return; }
271    IdCntV.Sort();
272    TGnuPlot GP(OutFNmPref, Desc);
273    GP.SetXYLabel(XLabel, YLabel);
274    GP.SetScale(ScaleTy);
275    const int Id = GP.AddPlot(IdCntV, SeriesTy);
276    if (PowerFit) { 
277      GP.AddPwrFit3(Id);
278      double MaxY = IdCntV.Last().Dat, MinY = IdCntV[0].Dat;
279      if (MaxY < MinY) { Swap(MaxY, MinY); }
280      GP.AddCmd(TStr::Fmt("set yrange[%f:]", MinY));
281    }
282    GP.SavePng();
283  }
284  template <class TVal1, class TVal2, class TVal3>
285  void TGnuPlot::PlotValV(const TVec<TTriple<TVal1, TVal2, TVal3> >& ValV, const TStr& OutFNmPref, const TStr& Desc,
286                          const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const bool& PowerFit,
287                          const TGpSeriesTy& SeriesTy, const TStr& ErrBarStr) {
288    TFltKdV IdCntV(ValV.Len(), 0);
289    TFltV DeltaYV(ValV.Len(), 0);
290    for (int i = 0; i < ValV.Len(); i++) {
291      IdCntV.Add(TFltKd(double(ValV[i].Val1), double(ValV[i].Val2)));
292      DeltaYV.Add(double(ValV[i].Val3));
293    }
294    if (IdCntV.Empty()) { printf("*** Empty plot %s\n", OutFNmPref.CStr());  return; }
295    IdCntV.Sort();
296    TGnuPlot GP(OutFNmPref, Desc);
297    GP.SetXYLabel(XLabel, YLabel);
298    GP.SetScale(ScaleTy);
299    const int Id = GP.AddPlot(IdCntV, SeriesTy);
300    GP.AddErrBar(IdCntV, DeltaYV, ErrBarStr);
301    if (PowerFit) {
302      GP.AddPwrFit3(Id);
303      double MaxY = IdCntV.Last().Dat, MinY = IdCntV[0].Dat;
304      if (MaxY < MinY) { Swap(MaxY, MinY); }
305      GP.AddCmd(TStr::Fmt("set yrange[%f:]", MinY));
306    }
307    GP.SavePng();
308  }
309  template <class TVal1, class TVal2>
310  void TGnuPlot::PlotValV(const TVec<TPair<TVal1, TVal2> >& ValV1, const TStr& Name1,
311                          const TVec<TPair<TVal1, TVal2> >& ValV2, const TStr& Name2,
312                          const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel, const TStr& YLabel,
313                          const TGpScaleTy& ScaleTy, const bool& PowerFit, const TGpSeriesTy& SeriesTy) {
314    TFltKdV IdCntV1(ValV1.Len(), 0), IdCntV2(ValV2.Len(), 0);
315    for (int i = 0; i < ValV1.Len(); i++) {
316      IdCntV1.Add(TFltKd(double(ValV1[i].Val1), double(ValV1[i].Val2))); }
317    for (int i = 0; i < ValV2.Len(); i++) {
318      IdCntV2.Add(TFltKd(double(ValV2[i].Val1), double(ValV2[i].Val2))); }
319    if (IdCntV1.Empty() || IdCntV2.Empty()) { printf("*** Empty plot %s\n", OutFNmPref.CStr());  return; }
320    IdCntV1.Sort();
321    IdCntV2.Sort();
322    TGnuPlot GP(OutFNmPref, Desc);
323    GP.SetXYLabel(XLabel, YLabel);
324    GP.SetScale(ScaleTy);
325    { const int Id = GP.AddPlot(IdCntV1, SeriesTy, Name1);
326    if (PowerFit) { 
327      GP.AddPwrFit3(Id);
328      double MaxY = IdCntV1.Last().Dat, MinY = IdCntV1[0].Dat;
329      if (MaxY < MinY) { Swap(MaxY, MinY); }
330      GP.AddCmd(TStr::Fmt("set yrange[%f:]", MinY));
331    } }
332    { const int Id = GP.AddPlot(IdCntV2, SeriesTy, Name2);
333    if (PowerFit) { 
334      GP.AddPwrFit3(Id);
335      double MaxY = IdCntV2.Last().Dat, MinY = IdCntV2[0].Dat;
336      if (MaxY < MinY) { Swap(MaxY, MinY); }
337      GP.AddCmd(TStr::Fmt("set yrange[%f:]", MinY));
338    } }
339    GP.SavePng();
340  }
341  template <class TVal1>
342  void TGnuPlot::PlotValV(const TVec<TVal1>& ValV, const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel,
343                          const TStr& YLabel, const TGpScaleTy& ScaleTy, const bool& PowerFit, const TGpSeriesTy& SeriesTy) {
344    TFltKdV IdCntV(ValV.Len(), 0);
345    for (int i = 0; i < ValV.Len(); i++) {
346      IdCntV.Add(TFltKd(double(i+1), double(ValV[i]))); }
347    if (IdCntV.Empty()) { printf("*** Empty plot %s\n", OutFNmPref.CStr());  return; }
348    IdCntV.Sort();
349    TGnuPlot GP(OutFNmPref, Desc);
350    GP.SetXYLabel(XLabel, YLabel);
351    GP.SetScale(ScaleTy);
352    const int Id = GP.AddPlot(IdCntV, SeriesTy);
353    if (PowerFit) { 
354      GP.AddPwrFit3(Id);
355      double MaxY = IdCntV.Last().Dat, MinY = IdCntV[0].Dat;
356      if (MaxY < MinY) { Swap(MaxY, MinY); }
357      GP.AddCmd(TStr::Fmt("set yrange[%f:]", MinY));
358    }
359    GP.SavePng();
360  }
361  template <class TKey, class TVal, class THashFunc>
362  void TGnuPlot::PlotValRank(const THash<TKey, TVal, THashFunc>& ValCntH, const TStr& OutFNmPref, const TStr& Desc,
363                             const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const bool& PowerFit, const TGpSeriesTy& SeriesTy) {
364    TFltPrV IdCntV(ValCntH.Len(), 0);
365    TFltV ValV(ValCntH.Len(), 0);
366    for (int i = ValCntH.FFirstKeyId(); ValCntH.FNextKeyId(i); ) {
367      ValV.Add(double(ValCntH[i])); }
368    ValV.Sort(false);
369    for (int i = 0; i < ValV.Len(); i++) {
370      IdCntV.Add(TFltPr(i+1, ValV[i]));
371    }
372    PlotValV(IdCntV, OutFNmPref, Desc, XLabel, YLabel, ScaleTy, PowerFit, SeriesTy);
373  }
374  template <class TKey, class TVal, class THashFunc>
375  void TGnuPlot::PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH, const TStr& OutFNmPref, const TStr& Desc,
376                             const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const bool& PowerFit,
377                             const TGpSeriesTy& SeriesTy, const bool& PlotCCDF, const bool& ExpBucket) {
378    TFltPrV IdCntV(ValCntH.Len(), 0), BucketV;
379    for (int i = ValCntH.FFirstKeyId(); ValCntH.FNextKeyId(i); ) {
380      IdCntV.Add(TFltPr(double(ValCntH.GetKey(i)), double(ValCntH[i]))); }
381    IdCntV.Sort();
382    if (ExpBucket) {
383      TGnuPlot::MakeExpBins(IdCntV, BucketV);
384      BucketV.Swap(IdCntV);
385    }
386    if (PlotCCDF) {
387      TFltPrV NCdfV = IdCntV;
388      for (int i = NCdfV.Len()-2; i >= 0; i--) {
389        NCdfV[i].Val2 = NCdfV[i].Val2 + NCdfV[i+1].Val2;
390      }
391      PlotValV(NCdfV, OutFNmPref, Desc, "NCDF "+XLabel, "NCDF "+YLabel, ScaleTy, PowerFit, SeriesTy);
392    } else {
393      PlotValV(IdCntV, OutFNmPref, Desc, XLabel, YLabel, ScaleTy, PowerFit, SeriesTy);
394    }
395  }
396  template <class TKey, class TVal, class THashFunc>
397  void TGnuPlot::PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH1, const TStr& Label1,
398                             const THash<TKey, TVal, THashFunc>& ValCntH2, const TStr& Label2,
399                             const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel, const TStr& YLabel,
400                             const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy) {
401    PlotValCntH(ValCntH1, Label1, ValCntH2, Label2, THash<TKey, TVal, THashFunc>(), "", OutFNmPref, Desc, XLabel, YLabel,
402                ScaleTy, SeriesTy);
403  }
404  template <class TKey, class TVal, class THashFunc>
405  void TGnuPlot::PlotValCntH(const THash<TKey, TVal, THashFunc>& ValCntH1, const TStr& Label1,
406                             const THash<TKey, TVal, THashFunc>& ValCntH2, const TStr& Label2,
407                             const THash<TKey, TVal, THashFunc>& ValCntH3, const TStr& Label3,
408                             const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel, const TStr& YLabel,
409                             const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy) {
410    TFltPrV IdCntV1(ValCntH1.Len(), 0), IdCntV2(ValCntH2.Len(), 0), IdCntV3(ValCntH3.Len(), 0);
411    for (int i = ValCntH1.FFirstKeyId(); ValCntH1.FNextKeyId(i); ) {
412      IdCntV1.Add(TFltPr(double(ValCntH1.GetKey(i)), double(ValCntH1[i]))); }
413    for (int i = ValCntH2.FFirstKeyId(); ValCntH2.FNextKeyId(i); ) {
414      IdCntV2.Add(TFltPr(double(ValCntH2.GetKey(i)), double(ValCntH2[i]))); }
415    for (int i = ValCntH3.FFirstKeyId(); ValCntH3.FNextKeyId(i); ) {
416      IdCntV3.Add(TFltPr(double(ValCntH3.GetKey(i)), double(ValCntH3[i]))); }
417    IdCntV1.Sort();
418    IdCntV2.Sort();
419    IdCntV3.Sort();
420    TGnuPlot GP(OutFNmPref, Desc);
421    GP.SetXYLabel(XLabel, YLabel);
422    GP.SetScale(ScaleTy);
423    if (! IdCntV1.Empty()) { GP.AddPlot(IdCntV1, SeriesTy, Label1); }
424    if (! IdCntV2.Empty()) { GP.AddPlot(IdCntV2, SeriesTy, Label2); }
425    if (! IdCntV3.Empty()) { GP.AddPlot(IdCntV3, SeriesTy, Label3); }
426    GP.SavePng();
427  }
428  template <class TVal1>
429  void TGnuPlot::PlotValMomH(const THash<TVal1, TMom>& ValMomH, const TStr& OutFNmPref, const TStr& Desc,
430                             const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy,
431                             bool PlotAvg, bool PlotMed, bool PlotMin, bool PlotMax, bool PlotSDev, bool PlotStdErr,
432                             bool PlotScatter) {
433    TFltTrV AvgV, StdErrV;
434    TFltPrV AvgV2, MedV, MinV, MaxV;
435    TFltPrV ScatterV;
436    for (int i = ValMomH.FFirstKeyId(); ValMomH.FNextKeyId(i); ) {
437      TMom Mom(ValMomH[i]);
438      if (! Mom.IsDef()) { Mom.Def(); }
439      const double x = ValMomH.GetKey(i);
440      if (PlotAvg) { 
441        if (PlotSDev) { 
442          AvgV.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev())); } 
443        else { 
444          AvgV2.Add(TFltPr(x, Mom.GetMean())); 
445        }
446        if (PlotStdErr) {
447          StdErrV.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev()/sqrt((double)Mom.GetVals()))); 
448        }
449      }
450      if (PlotMed) { MedV.Add(TFltPr(x, Mom.GetMedian())); }
451      if (PlotMin) { MinV.Add(TFltPr(x, Mom.GetMn())); }
452      if (PlotMax) { MaxV.Add(TFltPr(x, Mom.GetMx())); }
453      if (PlotScatter) {
454        THashSet<TFlt> PointSet;
455        for (int xi = 0; xi < ValMomH[i].GetVals(); xi++) {
456          PointSet.AddKey(ValMomH[i].GetVal(xi)); }
457        for (int xi = 0; xi < PointSet.Len(); xi++) {
458          ScatterV.Add(TFltPr(x, PointSet[xi]));  }
459      }
460    }
461    AvgV.Sort();  AvgV2.Sort();
462    MedV.Sort();  MinV.Sort();  MaxV.Sort();  StdErrV.Sort();
463    TGnuPlot GP(OutFNmPref, Desc);
464    GP.SetScale(ScaleTy);
465    GP.SetXYLabel(XLabel, YLabel);
466    if (! ScatterV.Empty()) { GP.AddPlot(ScatterV, gpwPoints, "Scatter"); }
467    if (! AvgV.Empty()) { GP.AddErrBar(AvgV, "Average", "StdDev"); }
468    if (! AvgV2.Empty()) { GP.AddPlot(AvgV2, SeriesTy, "Average"); }
469    if (! MedV.Empty()) { GP.AddPlot(MedV, SeriesTy, "Median"); }
470    if (! MinV.Empty()) { GP.AddPlot(MinV, SeriesTy, "Min"); }
471    if (! MaxV.Empty()) { GP.AddPlot(MaxV, SeriesTy, "Max"); }
472    if (! StdErrV.Empty()) { GP.AddErrBar(StdErrV, "Standard error"); }
473    GP.SavePng();
474  }
475  template <class TVal1>
476  void TGnuPlot::PlotValMomH(const THash<TVal1, TMom>& ValMomH1, const TStr& Label1,
477                             const THash<TVal1, TMom>& ValMomH2, const TStr& Label2,
478                             const TStr& OutFNmPref, const TStr& Desc, const TStr& XLabel,
479                             const TStr& YLabel, const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy, bool PlotAvg,
480                             bool PlotMed, bool PlotMin, bool PlotMax, bool PlotSDev, bool PlotStdErr, bool PlotScatter) {
481    TFltTrV AvgV1, AvgV2, StdErrV1, StdErrV2;
482    TFltPrV AvgVM1, MedV1, MinV1, MaxV1;
483    TFltPrV AvgVM2, MedV2, MinV2, MaxV2;
484    TFltPrV ScatterV1, ScatterV2;
485    for (int i = ValMomH1.FFirstKeyId(); ValMomH1.FNextKeyId(i); ) {
486      TMom Mom(ValMomH1[i]);
487      if (! Mom.IsDef()) { Mom.Def(); }
488      const double x = ValMomH1.GetKey(i);
489      if (PlotAvg) {
490        if (PlotSDev) {
491          AvgV1.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev())); } 
492        else {
493          AvgVM1.Add(TFltPr(x, Mom.GetMean()));
494        }
495        if (PlotStdErr) {
496          StdErrV1.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev()/sqrt((double)Mom.GetVals())));
497        }
498      }
499      if (PlotMed) { MedV1.Add(TFltPr(x, Mom.GetMedian())); }
500      if (PlotMin) { MinV1.Add(TFltPr(x, Mom.GetMn())); }
501      if (PlotMax) { MaxV1.Add(TFltPr(x, Mom.GetMx())); }
502      if (PlotScatter) {
503        THashSet<TFlt> PointSet;
504        for (int xi = 0; xi < ValMomH1[i].GetVals(); xi++) {
505          PointSet.AddKey(ValMomH1[i].GetVal(xi)); }
506        for (int xi = 0; xi < PointSet.Len(); xi++) {
507          ScatterV1.Add(TFltPr(x, PointSet[xi]));  }
508      }
509    }
510    AvgV1.Sort();  AvgVM1.Sort(); MedV1.Sort();  MinV1.Sort();  MaxV1.Sort();  StdErrV1.Sort();
511    for (int i = ValMomH2.FFirstKeyId(); ValMomH2.FNextKeyId(i); ) {
512      TMom Mom(ValMomH2[i]);
513      if (! Mom.IsDef()) { Mom.Def(); }
514      const double x = ValMomH2.GetKey(i);
515      if (PlotAvg) {
516        if (PlotSDev) {
517          AvgV2.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev())); } 
518        else {
519          AvgVM2.Add(TFltPr(x, Mom.GetMean()));
520        }
521        if (PlotStdErr) {
522          StdErrV2.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev()/sqrt((double)Mom.GetVals())));
523        }
524      }
525      if (PlotMed) { MedV2.Add(TFltPr(x, Mom.GetMedian())); }
526      if (PlotMin) { MinV2.Add(TFltPr(x, Mom.GetMn())); }
527      if (PlotMax) { MaxV2.Add(TFltPr(x, Mom.GetMx())); }
528      if (PlotScatter) {
529        THashSet<TFlt> PointSet;
530        for (int xi = 0; xi < ValMomH2[i].GetVals(); xi++) {
531          PointSet.AddKey(ValMomH2[i].GetVal(xi)); }
532        for (int xi = 0; xi < PointSet.Len(); xi++) {
533          ScatterV2.Add(TFltPr(x, PointSet[xi]));  }
534      }
535    }
536    AvgV2.Sort();  AvgVM2.Sort(); MedV2.Sort();  MinV2.Sort();  MaxV2.Sort();  StdErrV2.Sort();
537    TGnuPlot GP(OutFNmPref, Desc);
538    GP.SetScale(ScaleTy);
539    GP.SetXYLabel(XLabel, YLabel);
540    if (! ScatterV1.Empty()) { GP.AddPlot(ScatterV1, gpwPoints, Label1+": Scatter"); }
541    if (! AvgV1.Empty()) { GP.AddErrBar(AvgV1, Label1+": Average", Label1+": StdDev"); }
542    if (! AvgVM1.Empty()) { GP.AddPlot(AvgVM1, SeriesTy, Label1+": Average"); }
543    if (! MedV1.Empty()) { GP.AddPlot(MedV1, SeriesTy, Label1+": Median"); }
544    if (! MinV1.Empty()) { GP.AddPlot(MinV1, SeriesTy, Label1+": Min"); }
545    if (! MaxV1.Empty()) { GP.AddPlot(MaxV1, SeriesTy, Label1+": Max"); }
546    if (! StdErrV1.Empty()) { GP.AddErrBar(StdErrV1, Label1+": Std error"); }
547    if (! ScatterV2.Empty()) { GP.AddPlot(ScatterV2, gpwPoints, Label2+": Scatter"); }
548    if (! AvgV2.Empty()) { GP.AddErrBar(AvgV2, Label2+": Average", Label2+": StdDev"); }
549    if (! AvgVM2.Empty()) { GP.AddPlot(AvgVM2, SeriesTy, Label2+": Average"); }
550    if (! MedV2.Empty()) { GP.AddPlot(MedV2, SeriesTy, Label2+": Median"); }
551    if (! MinV2.Empty()) { GP.AddPlot(MinV2, SeriesTy, Label2+": Min"); }
552    if (! MaxV2.Empty()) { GP.AddPlot(MaxV2, SeriesTy, Label2+": Max"); }
553    if (! StdErrV2.Empty()) { GP.AddErrBar(StdErrV2, Label2+": Std error"); }
554    GP.SavePng();
555  }
556  template <class TVal2>
557  void TGnuPlot::PlotValOverTm(const TVec<TPair<TSecTm, TVal2> >& ValV, const TStr& OutFNmPref, const TStr& Desc,
558                               const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy) {
559    if (ValV.Empty()) { printf("*** Empty plot %s\n", OutFNmPref.CStr());  return; }
560    TVec<TPair<TSecTm, TVal2> > TmpV = ValV;
561    TmpV.Sort();
562    TGnuPlot GP(OutFNmPref, Desc);
563    GP.SetXYLabel(XLabel, YLabel);
564    GP.SetScale(ScaleTy);
565    GP.AddCmd("set xdata time");
566    GP.AddCmd("set timefmt \"%Y-%m-%d-%H:%M:%S\"");
567    GP.AddCmd("set format x \"%Y-%m-%d\\n%H:%M:%S\"");
568    time_t ltime;  time(&ltime);
569    char* TimeStr = ctime(&ltime);  TimeStr[strlen(TimeStr) - 1] = 0;
570    FILE *F = fopen(GP.DataFNm.CStr(), "wt");
571    fprintf(F, "#\n");
572    fprintf(F, "# %s (%s)\n", Desc.CStr(), TimeStr);
573    fprintf(F, "#\n");
574    fprintf(F, "#Time\t%s\n", XLabel.CStr());
575    for (int i = 0; i < TmpV.Len(); i++) {
576      fprintf(F, "%s\t%g\n", TmpV[i].Val1.GetYmdTmStr2().CStr(), double(TmpV[i].Val2()));
577    }
578    fclose(F);
579    GP.AddPlot(GP.DataFNm, 1, 2);
580    GP.SavePng();
581  }
582  template <class TVal2>
583  void TGnuPlot::PlotCntOverTm(const THash<TSecTm, TVal2>& CntH, const TStr& OutFNmPref, const TStr& Desc,
584                               const TStr& XLabel, const TStr& YLabel, const TGpScaleTy& ScaleTy, const TGpSeriesTy& SeriesTy) {
585    TVec<TPair<TSecTm, TVal2> > TmpV;
586    CntH.GetKeyDatPrV(TmpV);
587    PlotValOverTm(TmpV, OutFNmPref, Desc, XLabel, YLabel, ScaleTy, SeriesTy);
588  }
589  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gnuplot.h</div>
                </div>
                <div class="column column_space"><pre><code>63  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
64  		if (value == T()) {
65  			if (position == 0 || position == Length()) {
66  				ClearValue(partition);
67  			} else if (position == startPartition) {
</pre></code></div>
                <div class="column column_space"><pre><code>233      const double x = ValMomH.GetKey(i);
234      if (PlotAvg) { 
235        if (PlotSDev) { 
236          AvgV.Add(TFltTr(x, Mom.GetMean(), Mom.GetSDev())); } 
237        else if (PlotStdErr) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    