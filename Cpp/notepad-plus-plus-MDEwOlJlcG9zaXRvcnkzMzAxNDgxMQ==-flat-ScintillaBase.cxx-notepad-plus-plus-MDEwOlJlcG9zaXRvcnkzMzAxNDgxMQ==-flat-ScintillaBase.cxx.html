
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaBase.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <stdexcept>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <memory>
15  #include "ScintillaTypes.h"
16  #include "ScintillaMessages.h"
17  #include "ScintillaStructures.h"
18  #include "ILoader.h"
19  #include "ILexer.h"
20  #include "Debugging.h"
21  #include "Geometry.h"
22  #include "Platform.h"
23  #include "CharacterCategoryMap.h"
24  #include "Position.h"
25  #include "UniqueString.h"
26  #include "SplitVector.h"
27  #include "Partitioning.h"
28  #include "RunStyles.h"
29  #include "ContractionState.h"
30  #include "CellBuffer.h"
31  #include "CallTip.h"
32  #include "KeyMap.h"
33  #include "Indicator.h"
34  #include "LineMarker.h"
35  #include "Style.h"
36  #include "ViewStyle.h"
37  #include "CharClassify.h"
38  #include "Decoration.h"
39  #include "CaseFolder.h"
40  #include "Document.h"
41  #include "Selection.h"
42  #include "PositionCache.h"
43  #include "EditModel.h"
44  #include "MarginView.h"
45  #include "EditView.h"
46  #include "Editor.h"
47  #include "AutoComplete.h"
48  #include "ScintillaBase.h"
49  using namespace Scintilla;
50  using namespace Scintilla::Internal;
51  ScintillaBase::ScintillaBase() {
52  	displayPopupMenu = PopUp::All;
53  	listType = 0;
54  	maxListWidth = 0;
55  	multiAutoCMode = MultiAutoComplete::Once;
56  }
57  ScintillaBase::~ScintillaBase() {
58  }
59  void ScintillaBase::Finalise() {
60  	Editor::Finalise();
61  	popup.Destroy();
62  }
63  void ScintillaBase::InsertCharacter(std::string_view sv, CharacterSource charSource) {
64  	const bool acActive = ac.Active();
65  	const bool isFillUp = acActive && ac.IsFillUpChar(sv[0]);
66  	if (!isFillUp) {
67  		Editor::InsertCharacter(sv, charSource);
68  	}
69  	if (acActive && ac.Active()) { 
70  		AutoCompleteCharacterAdded(sv[0]);
71  		if (isFillUp) {
72  			Editor::InsertCharacter(sv, charSource);
73  		}
74  	}
75  }
76  void ScintillaBase::Command(int cmdId) {
77  	switch (cmdId) {
78  	case idAutoComplete:  	
79  		break;
80  	case idCallTip:  	
81  		break;
82  	case idcmdUndo:
83  		WndProc(Message::Undo, 0, 0);
84  		break;
85  	case idcmdRedo:
86  		WndProc(Message::Redo, 0, 0);
87  		break;
88  	case idcmdCut:
89  		WndProc(Message::Cut, 0, 0);
90  		break;
91  	case idcmdCopy:
92  		WndProc(Message::Copy, 0, 0);
93  		break;
94  	case idcmdPaste:
95  		WndProc(Message::Paste, 0, 0);
96  		break;
97  	case idcmdDelete:
98  		WndProc(Message::Clear, 0, 0);
99  		break;
100  	case idcmdSelectAll:
101  		WndProc(Message::SelectAll, 0, 0);
102  		break;
103  	}
104  }
105  int ScintillaBase::KeyCommand(Message iMessage) {
106  	if (ac.Active()) {
107  		switch (iMessage) {
108  		case Message::LineDown:
109  			AutoCompleteMove(1);
110  			return 0;
111  		case Message::LineUp:
112  			AutoCompleteMove(-1);
113  			return 0;
114  		case Message::PageDown:
115  			AutoCompleteMove(ac.lb->GetVisibleRows());
116  			return 0;
117  		case Message::PageUp:
118  			AutoCompleteMove(-ac.lb->GetVisibleRows());
119  			return 0;
120  		case Message::VCHome:
121  			AutoCompleteMove(-5000);
122  			return 0;
123  		case Message::LineEnd:
124  			AutoCompleteMove(5000);
125  			return 0;
126  		case Message::DeleteBack:
127  			DelCharBack(true);
128  			AutoCompleteCharacterDeleted();
129  			EnsureCaretVisible();
130  			return 0;
131  		case Message::DeleteBackNotLine:
132  			DelCharBack(false);
133  			AutoCompleteCharacterDeleted();
134  			EnsureCaretVisible();
135  			return 0;
136  		case Message::Tab:
137  			AutoCompleteCompleted(0, CompletionMethods::Tab);
138  			return 0;
139  		case Message::NewLine:
140  			AutoCompleteCompleted(0, CompletionMethods::Newline);
141  			return 0;
142  		default:
143  			AutoCompleteCancel();
144  		}
145  	}
146  	if (ct.inCallTipMode) {
147  		if (
148  		    (iMessage != Message::CharLeft) &&
149  		    (iMessage != Message::CharLeftExtend) &&
150  		    (iMessage != Message::CharRight) &&
151  		    (iMessage != Message::CharRightExtend) &&
152  		    (iMessage != Message::EditToggleOvertype) &&
153  		    (iMessage != Message::DeleteBack) &&
154  		    (iMessage != Message::DeleteBackNotLine)
155  		) {
156  			ct.CallTipCancel();
157  		}
158  		if ((iMessage == Message::DeleteBack) || (iMessage == Message::DeleteBackNotLine)) {
159  			if (sel.MainCaret() <= ct.posStartCallTip) {
160  				ct.CallTipCancel();
161  			}
162  		}
163  	}
164  	return Editor::KeyCommand(iMessage);
165  }
166  void ScintillaBase::ListNotify(ListBoxEvent *plbe) {
167  	switch (plbe->event) {
168  	case ListBoxEvent::EventType::selectionChange:
169  		AutoCompleteSelection();
170  		break;
171  	case ListBoxEvent::EventType::doubleClick:
172  		AutoCompleteCompleted(0, CompletionMethods::DoubleClick);
173  		break;
174  	}
175  }
176  void ScintillaBase::AutoCompleteInsert(Sci::Position startPos, Sci::Position removeLen, std::string_view text) {
177  	UndoGroup ug(pdoc);
178  	if (multiAutoCMode == MultiAutoComplete::Once) {
179  		pdoc->DeleteChars(startPos, removeLen);
180  		const Sci::Position lengthInserted = pdoc->InsertString(startPos, text);
181  		SetEmptySelection(startPos + lengthInserted);
182  	} else {
183  		for (size_t r=0; r<sel.Count(); r++) {
184  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
185  				sel.Range(r).End().Position())) {
186  				Sci::Position positionInsert = sel.Range(r).Start().Position();
187  				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
188  				if (positionInsert - removeLen >= 0) {
189  					positionInsert -= removeLen;
190  					pdoc->DeleteChars(positionInsert, removeLen);
191  				}
192  				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, text);
193  				if (lengthInserted > 0) {
194  					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
195  					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
196  				}
197  				sel.Range(r).ClearVirtualSpace();
198  			}
199  		}
200  	}
201  }
202  void ScintillaBase::AutoCompleteStart(Sci::Position lenEntered, const char *list) {
203  	ct.CallTipCancel();
204  	if (ac.chooseSingle && (listType == 0)) {
205  		if (list && !strchr(list, ac.GetSeparator())) {
206  			const std::string_view item(list);
207  			const std::string_view choice = item.substr(0, item.find_first_of(ac.GetTypesep()));
208  			if (ac.ignoreCase) {
209  				AutoCompleteInsert(sel.MainCaret() - lenEntered, lenEntered, choice);
210  			} else {
211  				AutoCompleteInsert(sel.MainCaret(), 0, choice.substr(lenEntered));
212  			}
213  			const Sci::Position firstPos = sel.MainCaret() - lenEntered;
214  			const std::string selected(choice);
215  			AutoCompleteNotifyCompleted('\0', CompletionMethods::SingleChoice, firstPos, selected.c_str());
216  			ac.Cancel();
217  			return;
218  		}
219  	}
220  	const ListOptions options{
221  		vs.ElementColour(Element::List),
222  		vs.ElementColour(Element::ListBack),
223  		vs.ElementColour(Element::ListSelected),
224  		vs.ElementColour(Element::ListSelectedBack),
225  		ac.options,
226  	};
227  	ac.Start(wMain, idAutoComplete, sel.MainCaret(), PointMainCaret(),
228  				lenEntered, vs.lineHeight, IsUnicodeMode(), technology, options);
229  	const PRectangle rcClient = GetClientRectangle();
230  	Point pt = LocationFromPosition(sel.MainCaret() - lenEntered);
231  	PRectangle rcPopupBounds = wMain.GetMonitorRect(pt);
232  	if (rcPopupBounds.Height() == 0)
233  		rcPopupBounds = rcClient;
234  	int heightLB = ac.heightLBDefault;
235  	int widthLB = ac.widthLBDefault;
236  	if (pt.x >= rcClient.right - widthLB) {
237  		HorizontalScrollTo(static_cast<int>(xOffset + pt.x - rcClient.right + widthLB));
238  		Redraw();
239  		pt = PointMainCaret();
240  	}
241  	if (wMargin.Created()) {
242  		pt = pt + GetVisibleOriginInMain();
243  	}
244  	PRectangle rcac;
245  	rcac.left = pt.x - ac.lb->CaretFromEdge();
246  	if (pt.y >= rcPopupBounds.bottom - heightLB &&  
247  	        pt.y >= (rcPopupBounds.bottom + rcPopupBounds.top) / 2) { 
248  		rcac.top = pt.y - heightLB;
249  		if (rcac.top < rcPopupBounds.top) {
250  			heightLB -= static_cast<int>(rcPopupBounds.top - rcac.top);
251  			rcac.top = rcPopupBounds.top;
252  		}
253  	} else {
254  		rcac.top = pt.y + vs.lineHeight;
255  	}
256  	rcac.right = rcac.left + widthLB;
257  	rcac.bottom = static_cast<XYPOSITION>(std::min(static_cast<int>(rcac.top) + heightLB, static_cast<int>(rcPopupBounds.bottom)));
258  	ac.lb->SetPositionRelative(rcac, &wMain);
259  	ac.lb->SetFont(vs.styles[StyleDefault].font.get());
260  	const int aveCharWidth = static_cast<int>(vs.styles[StyleDefault].aveCharWidth);
261  	ac.lb->SetAverageCharWidth(aveCharWidth);
262  	ac.lb->SetDelegate(this);
263  	ac.SetList(list ? list : "");
264  	PRectangle rcList = ac.lb->GetDesiredRect();
265  	const int heightAlloced = static_cast<int>(rcList.bottom - rcList.top);
266  	widthLB = std::max(widthLB, static_cast<int>(rcList.right - rcList.left));
267  	if (maxListWidth != 0)
268  		widthLB = std::min(widthLB, aveCharWidth*maxListWidth);
269  	rcList.left = pt.x - ac.lb->CaretFromEdge();
270  	rcList.right = rcList.left + widthLB;
271  	if (((pt.y + vs.lineHeight) >= (rcPopupBounds.bottom - heightAlloced)) &&  
272  	        ((pt.y + vs.lineHeight / 2) >= (rcPopupBounds.bottom + rcPopupBounds.top) / 2)) { 
273  		rcList.top = pt.y - heightAlloced;
274  	} else {
275  		rcList.top = pt.y + vs.lineHeight;
276  	}
277  	rcList.bottom = rcList.top + heightAlloced;
278  	ac.lb->SetPositionRelative(rcList, &wMain);
279  	ac.Show(true);
280  	if (lenEntered != 0) {
281  		AutoCompleteMoveToCurrentWord();
282  	}
283  }
284  void ScintillaBase::AutoCompleteCancel() {
285  	if (ac.Active()) {
286  		NotificationData scn = {};
287  		scn.nmhdr.code = Notification::AutoCCancelled;
288  		scn.wParam = 0;
289  		scn.listType = 0;
290  		NotifyParent(scn);
291  	}
292  	ac.Cancel();
293  }
294  void ScintillaBase::AutoCompleteMove(int delta) {
295  	ac.Move(delta);
296  }
297  void ScintillaBase::AutoCompleteMoveToCurrentWord() {
298  	std::string wordCurrent = RangeText(ac.posStart - ac.startLen, sel.MainCaret());
299  	ac.Select(wordCurrent.c_str());
300  }
301  void ScintillaBase::AutoCompleteSelection() {
302  	const int item = ac.GetSelection();
303  	std::string selected;
304  	if (item != -1) {
305  		selected = ac.GetValue(item);
306  	}
307  	NotificationData scn = {};
308  	scn.nmhdr.code = Notification::AutoCSelectionChange;
309  	scn.message = static_cast<Message>(0);
310  	scn.wParam = listType;
311  	scn.listType = listType;
312  	const Sci::Position firstPos = ac.posStart - ac.startLen;
313  	scn.position = firstPos;
314  	scn.lParam = firstPos;
315  	scn.text = selected.c_str();
316  	NotifyParent(scn);
317  }
318  void ScintillaBase::AutoCompleteCharacterAdded(char ch) {
319  	if (ac.IsFillUpChar(ch)) {
320  		AutoCompleteCompleted(ch, CompletionMethods::FillUp);
321  	} else if (ac.IsStopChar(ch)) {
322  		AutoCompleteCancel();
323  	} else {
324  		AutoCompleteMoveToCurrentWord();
325  	}
326  }
327  void ScintillaBase::AutoCompleteCharacterDeleted() {
328  	if (sel.MainCaret() < ac.posStart - ac.startLen) {
329  		AutoCompleteCancel();
330  	} else if (ac.cancelAtStartPos && (sel.MainCaret() <= ac.posStart)) {
331  		AutoCompleteCancel();
332  	} else {
333  		AutoCompleteMoveToCurrentWord();
334  	}
335  	NotificationData scn = {};
336  	scn.nmhdr.code = Notification::AutoCCharDeleted;
337  	scn.wParam = 0;
338  	scn.listType = 0;
339  	NotifyParent(scn);
340  }
341  void ScintillaBase::AutoCompleteNotifyCompleted(char ch, CompletionMethods completionMethod, Sci::Position firstPos, const char *text) {
342  	NotificationData scn = {};
343  	scn.nmhdr.code = Notification::AutoCCompleted;
344  	scn.message = static_cast<Message>(0);
345  	scn.ch = ch;
346  	scn.listCompletionMethod = completionMethod;
347  	scn.wParam = listType;
348  	scn.listType = listType;
349  	scn.position = firstPos;
350  	scn.lParam = firstPos;
351  	scn.text = text;
352  	NotifyParent(scn);
353  }
354  void ScintillaBase::AutoCompleteCompleted(char ch, CompletionMethods completionMethod) {
355  	const int item = ac.GetSelection();
356  	if (item == -1) {
357  		AutoCompleteCancel();
358  		return;
359  	}
360  	const std::string selected = ac.GetValue(item);
361  	ac.Show(false);
362  	NotificationData scn = {};
363  	scn.nmhdr.code = listType > 0 ? Notification::UserListSelection : Notification::AutoCSelection;
364  	scn.message = static_cast<Message>(0);
365  	scn.ch = ch;
366  	scn.listCompletionMethod = completionMethod;
367  	scn.wParam = listType;
368  	scn.listType = listType;
369  	const Sci::Position firstPos = ac.posStart - ac.startLen;
370  	scn.position = firstPos;
371  	scn.lParam = firstPos;
372  	scn.text = selected.c_str();
373  	NotifyParent(scn);
374  	if (!ac.Active())
375  		return;
376  	ac.Cancel();
377  	if (listType > 0)
378  		return;
379  	Sci::Position endPos = sel.MainCaret();
380  	if (ac.dropRestOfWord)
381  		endPos = pdoc->ExtendWordSelect(endPos, 1, true);
382  	if (endPos < firstPos)
383  		return;
384  	AutoCompleteInsert(firstPos, endPos - firstPos, selected);
385  	SetLastXChosen();
386  	AutoCompleteNotifyCompleted(ch, completionMethod, firstPos, selected.c_str());
387  }
388  int ScintillaBase::AutoCompleteGetCurrent() const {
389  	if (!ac.Active())
390  		return -1;
391  	return ac.GetSelection();
392  }
393  int ScintillaBase::AutoCompleteGetCurrentText(char *buffer) const {
394  	if (ac.Active()) {
395  		const int item = ac.GetSelection();
396  		if (item != -1) {
397  			const std::string selected = ac.GetValue(item);
398  			if (buffer)
399  				memcpy(buffer, selected.c_str(), selected.length()+1);
400  			return static_cast<int>(selected.length());
401  		}
402  	}
403  	if (buffer)
404  		*buffer = '\0';
405  	return 0;
406  }
407  void ScintillaBase::CallTipShow(Point pt, const char *defn) {
408  	ac.Cancel();
409  	const int ctStyle = ct.UseStyleCallTip() ? StyleCallTip : StyleDefault;
410  	const Style &style = vs.styles[ctStyle];
411  	if (ct.UseStyleCallTip()) {
412  		ct.SetForeBack(style.fore, style.back);
413  	}
414  	if (wMargin.Created()) {
415  		pt = pt + GetVisibleOriginInMain();
416  	}
417  	AutoSurface surfaceMeasure(this);
418  	PRectangle rc = ct.CallTipStart(sel.MainCaret(), pt,
419  		vs.lineHeight,
420  		defn,
421  		CodePage(),
422  		surfaceMeasure,
423  		style.font);
424  	const PRectangle rcClient = GetClientRectangle();
425  	const int offset = vs.lineHeight + static_cast<int>(rc.Height());
426  	if (rc.bottom > rcClient.bottom && rc.Height() < rcClient.Height()) {
427  		rc.top -= offset;
428  		rc.bottom -= offset;
429  	}
430  	if (rc.top < rcClient.top && rc.Height() < rcClient.Height()) {
431  		rc.top += offset;
432  		rc.bottom += offset;
433  	}
434  	CreateCallTipWindow(rc);
435  	ct.wCallTip.SetPositionRelative(rc, &wMain);
436  	ct.wCallTip.Show();
437  }
438  void ScintillaBase::CallTipClick() {
439  	NotificationData scn = {};
440  	scn.nmhdr.code = Notification::CallTipClick;
441  	scn.position = ct.clickPlace;
442  	NotifyParent(scn);
443  }
444  bool ScintillaBase::ShouldDisplayPopup(Point ptInWindowCoordinates) const {
445  	return (displayPopupMenu == PopUp::All ||
446  		(displayPopupMenu == PopUp::Text && !PointInSelMargin(ptInWindowCoordinates)));
447  }
448  void ScintillaBase::ContextMenu(Point pt) {
449  	if (displayPopupMenu != PopUp::Never) {
450  		const bool writable = !WndProc(Message::GetReadOnly, 0, 0);
451  		popup.CreatePopUp();
452  		AddToPopUp("Undo", idcmdUndo, writable && pdoc->CanUndo());
453  		AddToPopUp("Redo", idcmdRedo, writable && pdoc->CanRedo());
454  		AddToPopUp("");
455  		AddToPopUp("Cut", idcmdCut, writable && !sel.Empty());
456  		AddToPopUp("Copy", idcmdCopy, !sel.Empty());
457  		AddToPopUp("Paste", idcmdPaste, writable && WndProc(Message::CanPaste, 0, 0));
458  		AddToPopUp("Delete", idcmdDelete, writable && !sel.Empty());
459  		AddToPopUp("");
460  		AddToPopUp("Select All", idcmdSelectAll);
461  		popup.Show(pt, wMain);
462  	}
463  }
464  void ScintillaBase::CancelModes() {
465  	AutoCompleteCancel();
466  	ct.CallTipCancel();
467  	Editor::CancelModes();
468  }
469  void ScintillaBase::ButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
470  	CancelModes();
471  	Editor::ButtonDownWithModifiers(pt, curTime, modifiers);
472  }
473  void ScintillaBase::RightButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
474  	CancelModes();
475  	Editor::RightButtonDownWithModifiers(pt, curTime, modifiers);
476  }
477  namespace Scintilla::Internal {
478  class LexState : public LexInterface {
479  public:
480  	explicit LexState(Document *pdoc_) noexcept;
481  	const char *DescribeWordListSets();
482  	void SetWordList(int n, const char *wl);
483  	int GetIdentifier() const;
484  	const char *GetName() const;
485  	void *PrivateCall(int operation, void *pointer);
486  	const char *PropertyNames();
487  	TypeProperty PropertyType(const char *name);
488  	const char *DescribeProperty(const char *name);
489  	void PropSet(const char *key, const char *val);
490  	const char *PropGet(const char *key) const;
491  	int PropGetInt(const char *key, int defaultValue=0) const;
492  	LineEndType LineEndTypesSupported() override;
493  	int AllocateSubStyles(int styleBase, int numberStyles);
494  	int SubStylesStart(int styleBase);
495  	int SubStylesLength(int styleBase);
496  	int StyleFromSubStyle(int subStyle);
497  	int PrimaryStyleFromStyle(int style);
498  	void FreeSubStyles();
499  	void SetIdentifiers(int style, const char *identifiers);
500  	int DistanceToSecondaryStyles();
501  	const char *GetSubStyleBases();
502  	int NamedStyles();
503  	const char *NameOfStyle(int style);
504  	const char *TagsOfStyle(int style);
505  	const char *DescriptionOfStyle(int style);
506  };
507  }
508  LexState::LexState(Document *pdoc_) noexcept : LexInterface(pdoc_) {
509  }
510  LexState *ScintillaBase::DocumentLexState() {
511  	if (!pdoc->GetLexInterface()) {
512  		pdoc->SetLexInterface(std::make_unique<LexState>(pdoc));
513  	}
514  	return dynamic_cast<LexState *>(pdoc->GetLexInterface());
515  }
516  const char *LexState::DescribeWordListSets() {
517  	if (instance) {
518  		return instance->DescribeWordListSets();
519  	} else {
520  		return nullptr;
521  	}
522  }
523  void LexState::SetWordList(int n, const char *wl) {
524  	if (instance) {
525  		const Sci_Position firstModification = instance->WordListSet(n, wl);
526  		if (firstModification >= 0) {
527  			pdoc->ModifiedAt(firstModification);
528  		}
529  	}
530  }
531  int LexState::GetIdentifier() const {
532  	if (instance) {
533  		return instance->GetIdentifier();
534  	}
535  	return 0;
536  }
537  const char *LexState::GetName() const {
538  	if (instance) {
539  		return instance->GetName();
540  	}
541  	return "";
542  }
543  void *LexState::PrivateCall(int operation, void *pointer) {
544  	if (instance) {
545  		return instance->PrivateCall(operation, pointer);
546  	} else {
547  		return nullptr;
548  	}
549  }
550  const char *LexState::PropertyNames() {
551  	if (instance) {
552  		return instance->PropertyNames();
553  	} else {
554  		return nullptr;
555  	}
556  }
557  TypeProperty LexState::PropertyType(const char *name) {
558  	if (instance) {
559  		return static_cast<TypeProperty>(instance->PropertyType(name));
560  	} else {
561  		return TypeProperty::Boolean;
562  	}
563  }
564  const char *LexState::DescribeProperty(const char *name) {
565  	if (instance) {
566  		return instance->DescribeProperty(name);
567  	} else {
568  		return nullptr;
569  	}
570  }
571  void LexState::PropSet(const char *key, const char *val) {
572  	if (instance) {
573  		const Sci_Position firstModification = instance->PropertySet(key, val);
574  		if (firstModification >= 0) {
575  			pdoc->ModifiedAt(firstModification);
576  		}
577  	}
578  }
579  const char *LexState::PropGet(const char *key) const {
580  	if (instance) {
581  		return instance->PropertyGet(key);
582  	} else {
583  		return nullptr;
584  	}
585  }
586  int LexState::PropGetInt(const char *key, int defaultValue) const {
587  	if (instance) {
588  		const char *value = instance->PropertyGet(key);
589  		if (value && *value) {
590  			return atoi(value);
591  		}
592  	}
593  	return defaultValue;
594  }
595  LineEndType LexState::LineEndTypesSupported() {
596  	if (instance) {
597  		return static_cast<LineEndType>(instance->LineEndTypesSupported());
598  	}
599  	return LineEndType::Default;
600  }
601  int LexState::AllocateSubStyles(int styleBase, int numberStyles) {
602  	if (instance) {
603  		return instance->AllocateSubStyles(styleBase, numberStyles);
604  	}
605  	return -1;
606  }
607  int LexState::SubStylesStart(int styleBase) {
608  	if (instance) {
609  		return instance->SubStylesStart(styleBase);
610  	}
<span onclick='openModal()' class='match'>611  	return -1;
612  }
613  int LexState::SubStylesLength(int styleBase) {
614  	if (instance) {
615  		return instance->SubStylesLength(styleBase);
616  	}
617  	return 0;
</span>618  }
619  int LexState::StyleFromSubStyle(int subStyle) {
620  	if (instance) {
621  		return instance->StyleFromSubStyle(subStyle);
622  	}
623  	return 0;
624  }
625  int LexState::PrimaryStyleFromStyle(int style) {
626  	if (instance) {
627  		return instance->PrimaryStyleFromStyle(style);
628  	}
629  	return 0;
630  }
631  void LexState::FreeSubStyles() {
632  	if (instance) {
633  		instance->FreeSubStyles();
634  	}
635  }
636  void LexState::SetIdentifiers(int style, const char *identifiers) {
637  	if (instance) {
638  		instance->SetIdentifiers(style, identifiers);
639  		pdoc->ModifiedAt(0);
640  	}
641  }
642  int LexState::DistanceToSecondaryStyles() {
643  	if (instance) {
644  		return instance->DistanceToSecondaryStyles();
645  	}
646  	return 0;
647  }
648  const char *LexState::GetSubStyleBases() {
649  	if (instance) {
650  		return instance->GetSubStyleBases();
651  	}
652  	return "";
653  }
654  int LexState::NamedStyles() {
655  	if (instance) {
656  		return instance->NamedStyles();
657  	} else {
658  		return -1;
659  	}
660  }
661  const char *LexState::NameOfStyle(int style) {
662  	if (instance) {
663  		return instance->NameOfStyle(style);
664  	} else {
665  		return nullptr;
666  	}
667  }
668  const char *LexState::TagsOfStyle(int style) {
669  	if (instance) {
670  		return instance->TagsOfStyle(style);
671  	} else {
672  		return nullptr;
673  	}
674  }
675  const char *LexState::DescriptionOfStyle(int style) {
676  	if (instance) {
677  		return instance->DescriptionOfStyle(style);
678  	} else {
679  		return nullptr;
680  	}
681  }
682  void ScintillaBase::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
683  	if (!DocumentLexState()->UseContainerLexing()) {
684  		const Sci::Line lineEndStyled =
685  			pdoc->SciLineFromPosition(pdoc->GetEndStyled());
686  		const Sci::Position endStyled =
687  			pdoc->LineStart(lineEndStyled);
688  		DocumentLexState()->Colourise(endStyled, endStyleNeeded);
689  		return;
690  	}
691  	Editor::NotifyStyleToNeeded(endStyleNeeded);
692  }
693  sptr_t ScintillaBase::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
694  	switch (iMessage) {
695  	case Message::AutoCShow:
696  		listType = 0;
697  		AutoCompleteStart(PositionFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
698  		break;
699  	case Message::AutoCCancel:
700  		ac.Cancel();
701  		break;
702  	case Message::AutoCActive:
703  		return ac.Active();
704  	case Message::AutoCPosStart:
705  		return ac.posStart;
706  	case Message::AutoCComplete:
707  		AutoCompleteCompleted(0, CompletionMethods::Command);
708  		break;
709  	case Message::AutoCSetSeparator:
710  		ac.SetSeparator(static_cast<char>(wParam));
711  		break;
712  	case Message::AutoCGetSeparator:
713  		return ac.GetSeparator();
714  	case Message::AutoCStops:
715  		ac.SetStopChars(ConstCharPtrFromSPtr(lParam));
716  		break;
717  	case Message::AutoCSelect:
718  		ac.Select(ConstCharPtrFromSPtr(lParam));
719  		break;
720  	case Message::AutoCGetCurrent:
721  		return AutoCompleteGetCurrent();
722  	case Message::AutoCGetCurrentText:
723  		return AutoCompleteGetCurrentText(CharPtrFromSPtr(lParam));
724  	case Message::AutoCSetCancelAtStart:
725  		ac.cancelAtStartPos = wParam != 0;
726  		break;
727  	case Message::AutoCGetCancelAtStart:
728  		return ac.cancelAtStartPos;
729  	case Message::AutoCSetFillUps:
730  		ac.SetFillUpChars(ConstCharPtrFromSPtr(lParam));
731  		break;
732  	case Message::AutoCSetChooseSingle:
733  		ac.chooseSingle = wParam != 0;
734  		break;
735  	case Message::AutoCGetChooseSingle:
736  		return ac.chooseSingle;
737  	case Message::AutoCSetIgnoreCase:
738  		ac.ignoreCase = wParam != 0;
739  		break;
740  	case Message::AutoCGetIgnoreCase:
741  		return ac.ignoreCase;
742  	case Message::AutoCSetCaseInsensitiveBehaviour:
743  		ac.ignoreCaseBehaviour = static_cast<CaseInsensitiveBehaviour>(wParam);
744  		break;
745  	case Message::AutoCGetCaseInsensitiveBehaviour:
746  		return static_cast<sptr_t>(ac.ignoreCaseBehaviour);
747  	case Message::AutoCSetMulti:
748  		multiAutoCMode = static_cast<MultiAutoComplete>(wParam);
749  		break;
750  	case Message::AutoCGetMulti:
751  		return static_cast<sptr_t>(multiAutoCMode);
752  	case Message::AutoCSetOrder:
753  		ac.autoSort = static_cast<Ordering>(wParam);
754  		break;
755  	case Message::AutoCGetOrder:
756  		return static_cast<sptr_t>(ac.autoSort);
757  	case Message::UserListShow:
758  		listType = static_cast<int>(wParam);
759  		AutoCompleteStart(0, ConstCharPtrFromSPtr(lParam));
760  		break;
761  	case Message::AutoCSetAutoHide:
762  		ac.autoHide = wParam != 0;
763  		break;
764  	case Message::AutoCGetAutoHide:
765  		return ac.autoHide;
766  	case Message::AutoCSetOptions:
767  		ac.options = static_cast<AutoCompleteOption>(wParam);
768  		break;
769  	case Message::AutoCGetOptions:
770  		return static_cast<sptr_t>(ac.options);
771  	case Message::AutoCSetDropRestOfWord:
772  		ac.dropRestOfWord = wParam != 0;
773  		break;
774  	case Message::AutoCGetDropRestOfWord:
775  		return ac.dropRestOfWord;
776  	case Message::AutoCSetMaxHeight:
777  		ac.lb->SetVisibleRows(static_cast<int>(wParam));
778  		break;
779  	case Message::AutoCGetMaxHeight:
780  		return ac.lb->GetVisibleRows();
781  	case Message::AutoCSetMaxWidth:
782  		maxListWidth = static_cast<int>(wParam);
783  		break;
784  	case Message::AutoCGetMaxWidth:
785  		return maxListWidth;
786  	case Message::RegisterImage:
787  		ac.lb->RegisterImage(static_cast<int>(wParam), ConstCharPtrFromSPtr(lParam));
788  		break;
789  	case Message::RegisterRGBAImage:
790  		ac.lb->RegisterRGBAImage(static_cast<int>(wParam), static_cast<int>(sizeRGBAImage.x), static_cast<int>(sizeRGBAImage.y),
791  			ConstUCharPtrFromSPtr(lParam));
792  		break;
793  	case Message::ClearRegisteredImages:
794  		ac.lb->ClearRegisteredImages();
795  		break;
796  	case Message::AutoCSetTypeSeparator:
797  		ac.SetTypesep(static_cast<char>(wParam));
798  		break;
799  	case Message::AutoCGetTypeSeparator:
800  		return ac.GetTypesep();
801  	case Message::CallTipShow:
802  		CallTipShow(LocationFromPosition(wParam),
803  			ConstCharPtrFromSPtr(lParam));
804  		break;
805  	case Message::CallTipCancel:
806  		ct.CallTipCancel();
807  		break;
808  	case Message::CallTipActive:
809  		return ct.inCallTipMode;
810  	case Message::CallTipPosStart:
811  		return ct.posStartCallTip;
812  	case Message::CallTipSetPosStart:
813  		ct.posStartCallTip = wParam;
814  		break;
815  	case Message::CallTipSetHlt:
816  		ct.SetHighlight(wParam, lParam);
817  		break;
818  	case Message::CallTipSetBack:
819  		ct.colourBG = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
820  		vs.styles[StyleCallTip].back = ct.colourBG;
821  		InvalidateStyleRedraw();
822  		break;
823  	case Message::CallTipSetFore:
824  		ct.colourUnSel = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
825  		vs.styles[StyleCallTip].fore = ct.colourUnSel;
826  		InvalidateStyleRedraw();
827  		break;
828  	case Message::CallTipSetForeHlt:
829  		ct.colourSel = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
830  		InvalidateStyleRedraw();
831  		break;
832  	case Message::CallTipUseStyle:
833  		ct.SetTabSize(static_cast<int>(wParam));
834  		InvalidateStyleRedraw();
835  		break;
836  	case Message::CallTipSetPosition:
837  		ct.SetPosition(wParam != 0);
838  		InvalidateStyleRedraw();
839  		break;
840  	case Message::UsePopUp:
841  		displayPopupMenu = static_cast<PopUp>(wParam);
842  		break;
843  	case Message::GetLexer:
844  		return DocumentLexState()->GetIdentifier();
845  	case Message::SetILexer:
846  		DocumentLexState()->SetInstance(static_cast<ILexer5 *>(PtrFromSPtr(lParam)));
847  		return 0;
848  	case Message::Colourise:
849  		if (DocumentLexState()->UseContainerLexing()) {
850  			pdoc->ModifiedAt(PositionFromUPtr(wParam));
851  			NotifyStyleToNeeded((lParam == -1) ? pdoc->Length() : lParam);
852  		} else {
853  			DocumentLexState()->Colourise(PositionFromUPtr(wParam), lParam);
854  		}
855  		Redraw();
856  		break;
857  	case Message::SetProperty:
858  		DocumentLexState()->PropSet(ConstCharPtrFromUPtr(wParam),
859  		          ConstCharPtrFromSPtr(lParam));
860  		break;
861  	case Message::GetProperty:
862  		return StringResult(lParam, DocumentLexState()->PropGet(ConstCharPtrFromUPtr(wParam)));
863  	case Message::GetPropertyExpanded:
864  		return StringResult(lParam, DocumentLexState()->PropGet(ConstCharPtrFromUPtr(wParam)));
865  	case Message::GetPropertyInt:
866  		return DocumentLexState()->PropGetInt(ConstCharPtrFromUPtr(wParam), static_cast<int>(lParam));
867  	case Message::SetKeyWords:
868  		DocumentLexState()->SetWordList(static_cast<int>(wParam), ConstCharPtrFromSPtr(lParam));
869  		break;
870  	case Message::GetLexerLanguage:
871  		return StringResult(lParam, DocumentLexState()->GetName());
872  	case Message::PrivateLexerCall:
873  		return reinterpret_cast<sptr_t>(
874  			DocumentLexState()->PrivateCall(static_cast<int>(wParam), PtrFromSPtr(lParam)));
875  #ifdef INCLUDE_DEPRECATED_FEATURES
876  	case SCI_GETSTYLEBITSNEEDED:
877  		return 8;
878  #endif
879  	case Message::PropertyNames:
880  		return StringResult(lParam, DocumentLexState()->PropertyNames());
881  	case Message::PropertyType:
882  		return static_cast<sptr_t>(DocumentLexState()->PropertyType(ConstCharPtrFromUPtr(wParam)));
883  	case Message::DescribeProperty:
884  		return StringResult(lParam,
885  				    DocumentLexState()->DescribeProperty(ConstCharPtrFromUPtr(wParam)));
886  	case Message::DescribeKeyWordSets:
887  		return StringResult(lParam, DocumentLexState()->DescribeWordListSets());
888  	case Message::GetLineEndTypesSupported:
889  		return static_cast<sptr_t>(DocumentLexState()->LineEndTypesSupported());
890  	case Message::AllocateSubStyles:
891  		return DocumentLexState()->AllocateSubStyles(static_cast<int>(wParam), static_cast<int>(lParam));
892  	case Message::GetSubStylesStart:
893  		return DocumentLexState()->SubStylesStart(static_cast<int>(wParam));
894  	case Message::GetSubStylesLength:
895  		return DocumentLexState()->SubStylesLength(static_cast<int>(wParam));
896  	case Message::GetStyleFromSubStyle:
897  		return DocumentLexState()->StyleFromSubStyle(static_cast<int>(wParam));
898  	case Message::GetPrimaryStyleFromStyle:
899  		return DocumentLexState()->PrimaryStyleFromStyle(static_cast<int>(wParam));
900  	case Message::FreeSubStyles:
901  		DocumentLexState()->FreeSubStyles();
902  		break;
903  	case Message::SetIdentifiers:
904  		DocumentLexState()->SetIdentifiers(static_cast<int>(wParam),
905  						   ConstCharPtrFromSPtr(lParam));
906  		break;
907  	case Message::DistanceToSecondaryStyles:
908  		return DocumentLexState()->DistanceToSecondaryStyles();
909  	case Message::GetSubStyleBases:
910  		return StringResult(lParam, DocumentLexState()->GetSubStyleBases());
911  	case Message::GetNamedStyles:
912  		return DocumentLexState()->NamedStyles();
913  	case Message::NameOfStyle:
914  		return StringResult(lParam, DocumentLexState()->
915  				    NameOfStyle(static_cast<int>(wParam)));
916  	case Message::TagsOfStyle:
917  		return StringResult(lParam, DocumentLexState()->
918  				    TagsOfStyle(static_cast<int>(wParam)));
919  	case Message::DescriptionOfStyle:
920  		return StringResult(lParam, DocumentLexState()->
921  				    DescriptionOfStyle(static_cast<int>(wParam)));
922  	default:
923  		return Editor::WndProc(iMessage, wParam, lParam);
924  	}
925  	return 0;
926  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaBase.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <stdexcept>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <set>
12  #include <optional>
13  #include <algorithm>
14  #include <memory>
15  #include "ScintillaTypes.h"
16  #include "ScintillaMessages.h"
17  #include "ScintillaStructures.h"
18  #include "ILoader.h"
19  #include "ILexer.h"
20  #include "Debugging.h"
21  #include "Geometry.h"
22  #include "Platform.h"
23  #include "CharacterCategoryMap.h"
24  #include "Position.h"
25  #include "UniqueString.h"
26  #include "SplitVector.h"
27  #include "Partitioning.h"
28  #include "RunStyles.h"
29  #include "ContractionState.h"
30  #include "CellBuffer.h"
31  #include "CallTip.h"
32  #include "KeyMap.h"
33  #include "Indicator.h"
34  #include "LineMarker.h"
35  #include "Style.h"
36  #include "ViewStyle.h"
37  #include "CharClassify.h"
38  #include "Decoration.h"
39  #include "CaseFolder.h"
40  #include "Document.h"
41  #include "Selection.h"
42  #include "PositionCache.h"
43  #include "EditModel.h"
44  #include "MarginView.h"
45  #include "EditView.h"
46  #include "Editor.h"
47  #include "AutoComplete.h"
48  #include "ScintillaBase.h"
49  using namespace Scintilla;
50  using namespace Scintilla::Internal;
51  ScintillaBase::ScintillaBase() {
52  	displayPopupMenu = PopUp::All;
53  	listType = 0;
54  	maxListWidth = 0;
55  	multiAutoCMode = MultiAutoComplete::Once;
56  }
57  ScintillaBase::~ScintillaBase() {
58  }
59  void ScintillaBase::Finalise() {
60  	Editor::Finalise();
61  	popup.Destroy();
62  }
63  void ScintillaBase::InsertCharacter(std::string_view sv, CharacterSource charSource) {
64  	const bool acActive = ac.Active();
65  	const bool isFillUp = acActive && ac.IsFillUpChar(sv[0]);
66  	if (!isFillUp) {
67  		Editor::InsertCharacter(sv, charSource);
68  	}
69  	if (acActive && ac.Active()) { 
70  		AutoCompleteCharacterAdded(sv[0]);
71  		if (isFillUp) {
72  			Editor::InsertCharacter(sv, charSource);
73  		}
74  	}
75  }
76  void ScintillaBase::Command(int cmdId) {
77  	switch (cmdId) {
78  	case idAutoComplete:  	
79  		break;
80  	case idCallTip:  	
81  		break;
82  	case idcmdUndo:
83  		WndProc(Message::Undo, 0, 0);
84  		break;
85  	case idcmdRedo:
86  		WndProc(Message::Redo, 0, 0);
87  		break;
88  	case idcmdCut:
89  		WndProc(Message::Cut, 0, 0);
90  		break;
91  	case idcmdCopy:
92  		WndProc(Message::Copy, 0, 0);
93  		break;
94  	case idcmdPaste:
95  		WndProc(Message::Paste, 0, 0);
96  		break;
97  	case idcmdDelete:
98  		WndProc(Message::Clear, 0, 0);
99  		break;
100  	case idcmdSelectAll:
101  		WndProc(Message::SelectAll, 0, 0);
102  		break;
103  	}
104  }
105  int ScintillaBase::KeyCommand(Message iMessage) {
106  	if (ac.Active()) {
107  		switch (iMessage) {
108  		case Message::LineDown:
109  			AutoCompleteMove(1);
110  			return 0;
111  		case Message::LineUp:
112  			AutoCompleteMove(-1);
113  			return 0;
114  		case Message::PageDown:
115  			AutoCompleteMove(ac.lb->GetVisibleRows());
116  			return 0;
117  		case Message::PageUp:
118  			AutoCompleteMove(-ac.lb->GetVisibleRows());
119  			return 0;
120  		case Message::VCHome:
121  			AutoCompleteMove(-5000);
122  			return 0;
123  		case Message::LineEnd:
124  			AutoCompleteMove(5000);
125  			return 0;
126  		case Message::DeleteBack:
127  			DelCharBack(true);
128  			AutoCompleteCharacterDeleted();
129  			EnsureCaretVisible();
130  			return 0;
131  		case Message::DeleteBackNotLine:
132  			DelCharBack(false);
133  			AutoCompleteCharacterDeleted();
134  			EnsureCaretVisible();
135  			return 0;
136  		case Message::Tab:
137  			AutoCompleteCompleted(0, CompletionMethods::Tab);
138  			return 0;
139  		case Message::NewLine:
140  			AutoCompleteCompleted(0, CompletionMethods::Newline);
141  			return 0;
142  		default:
143  			AutoCompleteCancel();
144  		}
145  	}
146  	if (ct.inCallTipMode) {
147  		if (
148  		    (iMessage != Message::CharLeft) &&
149  		    (iMessage != Message::CharLeftExtend) &&
150  		    (iMessage != Message::CharRight) &&
151  		    (iMessage != Message::CharRightExtend) &&
152  		    (iMessage != Message::EditToggleOvertype) &&
153  		    (iMessage != Message::DeleteBack) &&
154  		    (iMessage != Message::DeleteBackNotLine)
155  		) {
156  			ct.CallTipCancel();
157  		}
158  		if ((iMessage == Message::DeleteBack) || (iMessage == Message::DeleteBackNotLine)) {
159  			if (sel.MainCaret() <= ct.posStartCallTip) {
160  				ct.CallTipCancel();
161  			}
162  		}
163  	}
164  	return Editor::KeyCommand(iMessage);
165  }
166  void ScintillaBase::ListNotify(ListBoxEvent *plbe) {
167  	switch (plbe->event) {
168  	case ListBoxEvent::EventType::selectionChange:
169  		AutoCompleteSelection();
170  		break;
171  	case ListBoxEvent::EventType::doubleClick:
172  		AutoCompleteCompleted(0, CompletionMethods::DoubleClick);
173  		break;
174  	}
175  }
176  void ScintillaBase::AutoCompleteInsert(Sci::Position startPos, Sci::Position removeLen, std::string_view text) {
177  	UndoGroup ug(pdoc);
178  	if (multiAutoCMode == MultiAutoComplete::Once) {
179  		pdoc->DeleteChars(startPos, removeLen);
180  		const Sci::Position lengthInserted = pdoc->InsertString(startPos, text);
181  		SetEmptySelection(startPos + lengthInserted);
182  	} else {
183  		for (size_t r=0; r<sel.Count(); r++) {
184  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
185  				sel.Range(r).End().Position())) {
186  				Sci::Position positionInsert = sel.Range(r).Start().Position();
187  				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
188  				if (positionInsert - removeLen >= 0) {
189  					positionInsert -= removeLen;
190  					pdoc->DeleteChars(positionInsert, removeLen);
191  				}
192  				const Sci::Position lengthInserted = pdoc->InsertString(positionInsert, text);
193  				if (lengthInserted > 0) {
194  					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
195  					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
196  				}
197  				sel.Range(r).ClearVirtualSpace();
198  			}
199  		}
200  	}
201  }
202  void ScintillaBase::AutoCompleteStart(Sci::Position lenEntered, const char *list) {
203  	ct.CallTipCancel();
204  	if (ac.chooseSingle && (listType == 0)) {
205  		if (list && !strchr(list, ac.GetSeparator())) {
206  			const std::string_view item(list);
207  			const std::string_view choice = item.substr(0, item.find_first_of(ac.GetTypesep()));
208  			if (ac.ignoreCase) {
209  				AutoCompleteInsert(sel.MainCaret() - lenEntered, lenEntered, choice);
210  			} else {
211  				AutoCompleteInsert(sel.MainCaret(), 0, choice.substr(lenEntered));
212  			}
213  			const Sci::Position firstPos = sel.MainCaret() - lenEntered;
214  			const std::string selected(choice);
215  			AutoCompleteNotifyCompleted('\0', CompletionMethods::SingleChoice, firstPos, selected.c_str());
216  			ac.Cancel();
217  			return;
218  		}
219  	}
220  	const ListOptions options{
221  		vs.ElementColour(Element::List),
222  		vs.ElementColour(Element::ListBack),
223  		vs.ElementColour(Element::ListSelected),
224  		vs.ElementColour(Element::ListSelectedBack),
225  		ac.options,
226  	};
227  	ac.Start(wMain, idAutoComplete, sel.MainCaret(), PointMainCaret(),
228  				lenEntered, vs.lineHeight, IsUnicodeMode(), technology, options);
229  	const PRectangle rcClient = GetClientRectangle();
230  	Point pt = LocationFromPosition(sel.MainCaret() - lenEntered);
231  	PRectangle rcPopupBounds = wMain.GetMonitorRect(pt);
232  	if (rcPopupBounds.Height() == 0)
233  		rcPopupBounds = rcClient;
234  	int heightLB = ac.heightLBDefault;
235  	int widthLB = ac.widthLBDefault;
236  	if (pt.x >= rcClient.right - widthLB) {
237  		HorizontalScrollTo(static_cast<int>(xOffset + pt.x - rcClient.right + widthLB));
238  		Redraw();
239  		pt = PointMainCaret();
240  	}
241  	if (wMargin.Created()) {
242  		pt = pt + GetVisibleOriginInMain();
243  	}
244  	PRectangle rcac;
245  	rcac.left = pt.x - ac.lb->CaretFromEdge();
246  	if (pt.y >= rcPopupBounds.bottom - heightLB &&  
247  	        pt.y >= (rcPopupBounds.bottom + rcPopupBounds.top) / 2) { 
248  		rcac.top = pt.y - heightLB;
249  		if (rcac.top < rcPopupBounds.top) {
250  			heightLB -= static_cast<int>(rcPopupBounds.top - rcac.top);
251  			rcac.top = rcPopupBounds.top;
252  		}
253  	} else {
254  		rcac.top = pt.y + vs.lineHeight;
255  	}
256  	rcac.right = rcac.left + widthLB;
257  	rcac.bottom = static_cast<XYPOSITION>(std::min(static_cast<int>(rcac.top) + heightLB, static_cast<int>(rcPopupBounds.bottom)));
258  	ac.lb->SetPositionRelative(rcac, &wMain);
259  	ac.lb->SetFont(vs.styles[StyleDefault].font.get());
260  	const int aveCharWidth = static_cast<int>(vs.styles[StyleDefault].aveCharWidth);
261  	ac.lb->SetAverageCharWidth(aveCharWidth);
262  	ac.lb->SetDelegate(this);
263  	ac.SetList(list ? list : "");
264  	PRectangle rcList = ac.lb->GetDesiredRect();
265  	const int heightAlloced = static_cast<int>(rcList.bottom - rcList.top);
266  	widthLB = std::max(widthLB, static_cast<int>(rcList.right - rcList.left));
267  	if (maxListWidth != 0)
268  		widthLB = std::min(widthLB, aveCharWidth*maxListWidth);
269  	rcList.left = pt.x - ac.lb->CaretFromEdge();
270  	rcList.right = rcList.left + widthLB;
271  	if (((pt.y + vs.lineHeight) >= (rcPopupBounds.bottom - heightAlloced)) &&  
272  	        ((pt.y + vs.lineHeight / 2) >= (rcPopupBounds.bottom + rcPopupBounds.top) / 2)) { 
273  		rcList.top = pt.y - heightAlloced;
274  	} else {
275  		rcList.top = pt.y + vs.lineHeight;
276  	}
277  	rcList.bottom = rcList.top + heightAlloced;
278  	ac.lb->SetPositionRelative(rcList, &wMain);
279  	ac.Show(true);
280  	if (lenEntered != 0) {
281  		AutoCompleteMoveToCurrentWord();
282  	}
283  }
284  void ScintillaBase::AutoCompleteCancel() {
285  	if (ac.Active()) {
286  		NotificationData scn = {};
287  		scn.nmhdr.code = Notification::AutoCCancelled;
288  		scn.wParam = 0;
289  		scn.listType = 0;
290  		NotifyParent(scn);
291  	}
292  	ac.Cancel();
293  }
294  void ScintillaBase::AutoCompleteMove(int delta) {
295  	ac.Move(delta);
296  }
297  void ScintillaBase::AutoCompleteMoveToCurrentWord() {
298  	std::string wordCurrent = RangeText(ac.posStart - ac.startLen, sel.MainCaret());
299  	ac.Select(wordCurrent.c_str());
300  }
301  void ScintillaBase::AutoCompleteSelection() {
302  	const int item = ac.GetSelection();
303  	std::string selected;
304  	if (item != -1) {
305  		selected = ac.GetValue(item);
306  	}
307  	NotificationData scn = {};
308  	scn.nmhdr.code = Notification::AutoCSelectionChange;
309  	scn.message = static_cast<Message>(0);
310  	scn.wParam = listType;
311  	scn.listType = listType;
312  	const Sci::Position firstPos = ac.posStart - ac.startLen;
313  	scn.position = firstPos;
314  	scn.lParam = firstPos;
315  	scn.text = selected.c_str();
316  	NotifyParent(scn);
317  }
318  void ScintillaBase::AutoCompleteCharacterAdded(char ch) {
319  	if (ac.IsFillUpChar(ch)) {
320  		AutoCompleteCompleted(ch, CompletionMethods::FillUp);
321  	} else if (ac.IsStopChar(ch)) {
322  		AutoCompleteCancel();
323  	} else {
324  		AutoCompleteMoveToCurrentWord();
325  	}
326  }
327  void ScintillaBase::AutoCompleteCharacterDeleted() {
328  	if (sel.MainCaret() < ac.posStart - ac.startLen) {
329  		AutoCompleteCancel();
330  	} else if (ac.cancelAtStartPos && (sel.MainCaret() <= ac.posStart)) {
331  		AutoCompleteCancel();
332  	} else {
333  		AutoCompleteMoveToCurrentWord();
334  	}
335  	NotificationData scn = {};
336  	scn.nmhdr.code = Notification::AutoCCharDeleted;
337  	scn.wParam = 0;
338  	scn.listType = 0;
339  	NotifyParent(scn);
340  }
341  void ScintillaBase::AutoCompleteNotifyCompleted(char ch, CompletionMethods completionMethod, Sci::Position firstPos, const char *text) {
342  	NotificationData scn = {};
343  	scn.nmhdr.code = Notification::AutoCCompleted;
344  	scn.message = static_cast<Message>(0);
345  	scn.ch = ch;
346  	scn.listCompletionMethod = completionMethod;
347  	scn.wParam = listType;
348  	scn.listType = listType;
349  	scn.position = firstPos;
350  	scn.lParam = firstPos;
351  	scn.text = text;
352  	NotifyParent(scn);
353  }
354  void ScintillaBase::AutoCompleteCompleted(char ch, CompletionMethods completionMethod) {
355  	const int item = ac.GetSelection();
356  	if (item == -1) {
357  		AutoCompleteCancel();
358  		return;
359  	}
360  	const std::string selected = ac.GetValue(item);
361  	ac.Show(false);
362  	NotificationData scn = {};
363  	scn.nmhdr.code = listType > 0 ? Notification::UserListSelection : Notification::AutoCSelection;
364  	scn.message = static_cast<Message>(0);
365  	scn.ch = ch;
366  	scn.listCompletionMethod = completionMethod;
367  	scn.wParam = listType;
368  	scn.listType = listType;
369  	const Sci::Position firstPos = ac.posStart - ac.startLen;
370  	scn.position = firstPos;
371  	scn.lParam = firstPos;
372  	scn.text = selected.c_str();
373  	NotifyParent(scn);
374  	if (!ac.Active())
375  		return;
376  	ac.Cancel();
377  	if (listType > 0)
378  		return;
379  	Sci::Position endPos = sel.MainCaret();
380  	if (ac.dropRestOfWord)
381  		endPos = pdoc->ExtendWordSelect(endPos, 1, true);
382  	if (endPos < firstPos)
383  		return;
384  	AutoCompleteInsert(firstPos, endPos - firstPos, selected);
385  	SetLastXChosen();
386  	AutoCompleteNotifyCompleted(ch, completionMethod, firstPos, selected.c_str());
387  }
388  int ScintillaBase::AutoCompleteGetCurrent() const {
389  	if (!ac.Active())
390  		return -1;
391  	return ac.GetSelection();
392  }
393  int ScintillaBase::AutoCompleteGetCurrentText(char *buffer) const {
394  	if (ac.Active()) {
395  		const int item = ac.GetSelection();
396  		if (item != -1) {
397  			const std::string selected = ac.GetValue(item);
398  			if (buffer)
399  				memcpy(buffer, selected.c_str(), selected.length()+1);
400  			return static_cast<int>(selected.length());
401  		}
402  	}
403  	if (buffer)
404  		*buffer = '\0';
405  	return 0;
406  }
407  void ScintillaBase::CallTipShow(Point pt, const char *defn) {
408  	ac.Cancel();
409  	const int ctStyle = ct.UseStyleCallTip() ? StyleCallTip : StyleDefault;
410  	const Style &style = vs.styles[ctStyle];
411  	if (ct.UseStyleCallTip()) {
412  		ct.SetForeBack(style.fore, style.back);
413  	}
414  	if (wMargin.Created()) {
415  		pt = pt + GetVisibleOriginInMain();
416  	}
417  	AutoSurface surfaceMeasure(this);
418  	PRectangle rc = ct.CallTipStart(sel.MainCaret(), pt,
419  		vs.lineHeight,
420  		defn,
421  		CodePage(),
422  		surfaceMeasure,
423  		style.font);
424  	const PRectangle rcClient = GetClientRectangle();
425  	const int offset = vs.lineHeight + static_cast<int>(rc.Height());
426  	if (rc.bottom > rcClient.bottom && rc.Height() < rcClient.Height()) {
427  		rc.top -= offset;
428  		rc.bottom -= offset;
429  	}
430  	if (rc.top < rcClient.top && rc.Height() < rcClient.Height()) {
431  		rc.top += offset;
432  		rc.bottom += offset;
433  	}
434  	CreateCallTipWindow(rc);
435  	ct.wCallTip.SetPositionRelative(rc, &wMain);
436  	ct.wCallTip.Show();
437  }
438  void ScintillaBase::CallTipClick() {
439  	NotificationData scn = {};
440  	scn.nmhdr.code = Notification::CallTipClick;
441  	scn.position = ct.clickPlace;
442  	NotifyParent(scn);
443  }
444  bool ScintillaBase::ShouldDisplayPopup(Point ptInWindowCoordinates) const {
445  	return (displayPopupMenu == PopUp::All ||
446  		(displayPopupMenu == PopUp::Text && !PointInSelMargin(ptInWindowCoordinates)));
447  }
448  void ScintillaBase::ContextMenu(Point pt) {
449  	if (displayPopupMenu != PopUp::Never) {
450  		const bool writable = !WndProc(Message::GetReadOnly, 0, 0);
451  		popup.CreatePopUp();
452  		AddToPopUp("Undo", idcmdUndo, writable && pdoc->CanUndo());
453  		AddToPopUp("Redo", idcmdRedo, writable && pdoc->CanRedo());
454  		AddToPopUp("");
455  		AddToPopUp("Cut", idcmdCut, writable && !sel.Empty());
456  		AddToPopUp("Copy", idcmdCopy, !sel.Empty());
457  		AddToPopUp("Paste", idcmdPaste, writable && WndProc(Message::CanPaste, 0, 0));
458  		AddToPopUp("Delete", idcmdDelete, writable && !sel.Empty());
459  		AddToPopUp("");
460  		AddToPopUp("Select All", idcmdSelectAll);
461  		popup.Show(pt, wMain);
462  	}
463  }
464  void ScintillaBase::CancelModes() {
465  	AutoCompleteCancel();
466  	ct.CallTipCancel();
467  	Editor::CancelModes();
468  }
469  void ScintillaBase::ButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
470  	CancelModes();
471  	Editor::ButtonDownWithModifiers(pt, curTime, modifiers);
472  }
473  void ScintillaBase::RightButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
474  	CancelModes();
475  	Editor::RightButtonDownWithModifiers(pt, curTime, modifiers);
476  }
477  namespace Scintilla::Internal {
478  class LexState : public LexInterface {
479  public:
480  	explicit LexState(Document *pdoc_) noexcept;
481  	const char *DescribeWordListSets();
482  	void SetWordList(int n, const char *wl);
483  	int GetIdentifier() const;
484  	const char *GetName() const;
485  	void *PrivateCall(int operation, void *pointer);
486  	const char *PropertyNames();
487  	TypeProperty PropertyType(const char *name);
488  	const char *DescribeProperty(const char *name);
489  	void PropSet(const char *key, const char *val);
490  	const char *PropGet(const char *key) const;
491  	int PropGetInt(const char *key, int defaultValue=0) const;
492  	LineEndType LineEndTypesSupported() override;
493  	int AllocateSubStyles(int styleBase, int numberStyles);
494  	int SubStylesStart(int styleBase);
495  	int SubStylesLength(int styleBase);
496  	int StyleFromSubStyle(int subStyle);
497  	int PrimaryStyleFromStyle(int style);
498  	void FreeSubStyles();
499  	void SetIdentifiers(int style, const char *identifiers);
500  	int DistanceToSecondaryStyles();
501  	const char *GetSubStyleBases();
502  	int NamedStyles();
503  	const char *NameOfStyle(int style);
504  	const char *TagsOfStyle(int style);
505  	const char *DescriptionOfStyle(int style);
506  };
507  }
508  LexState::LexState(Document *pdoc_) noexcept : LexInterface(pdoc_) {
509  }
510  LexState *ScintillaBase::DocumentLexState() {
511  	if (!pdoc->GetLexInterface()) {
512  		pdoc->SetLexInterface(std::make_unique<LexState>(pdoc));
513  	}
514  	return dynamic_cast<LexState *>(pdoc->GetLexInterface());
515  }
516  const char *LexState::DescribeWordListSets() {
517  	if (instance) {
518  		return instance->DescribeWordListSets();
519  	} else {
520  		return nullptr;
521  	}
522  }
523  void LexState::SetWordList(int n, const char *wl) {
524  	if (instance) {
525  		const Sci_Position firstModification = instance->WordListSet(n, wl);
526  		if (firstModification >= 0) {
527  			pdoc->ModifiedAt(firstModification);
528  		}
529  	}
530  }
531  int LexState::GetIdentifier() const {
532  	if (instance) {
533  		return instance->GetIdentifier();
534  	}
535  	return 0;
536  }
537  const char *LexState::GetName() const {
538  	if (instance) {
539  		return instance->GetName();
540  	}
541  	return "";
542  }
543  void *LexState::PrivateCall(int operation, void *pointer) {
544  	if (instance) {
545  		return instance->PrivateCall(operation, pointer);
546  	} else {
547  		return nullptr;
548  	}
549  }
550  const char *LexState::PropertyNames() {
551  	if (instance) {
552  		return instance->PropertyNames();
553  	} else {
554  		return nullptr;
555  	}
556  }
557  TypeProperty LexState::PropertyType(const char *name) {
558  	if (instance) {
559  		return static_cast<TypeProperty>(instance->PropertyType(name));
560  	} else {
561  		return TypeProperty::Boolean;
562  	}
563  }
564  const char *LexState::DescribeProperty(const char *name) {
565  	if (instance) {
566  		return instance->DescribeProperty(name);
567  	} else {
568  		return nullptr;
569  	}
570  }
571  void LexState::PropSet(const char *key, const char *val) {
572  	if (instance) {
573  		const Sci_Position firstModification = instance->PropertySet(key, val);
574  		if (firstModification >= 0) {
575  			pdoc->ModifiedAt(firstModification);
576  		}
577  	}
578  }
579  const char *LexState::PropGet(const char *key) const {
580  	if (instance) {
581  		return instance->PropertyGet(key);
582  	} else {
583  		return nullptr;
584  	}
585  }
586  int LexState::PropGetInt(const char *key, int defaultValue) const {
587  	if (instance) {
588  		const char *value = instance->PropertyGet(key);
589  		if (value && *value) {
590  			return atoi(value);
591  		}
592  	}
593  	return defaultValue;
594  }
595  LineEndType LexState::LineEndTypesSupported() {
596  	if (instance) {
597  		return static_cast<LineEndType>(instance->LineEndTypesSupported());
598  	}
599  	return LineEndType::Default;
600  }
601  int LexState::AllocateSubStyles(int styleBase, int numberStyles) {
602  	if (instance) {
603  		return instance->AllocateSubStyles(styleBase, numberStyles);
604  	}
<span onclick='openModal()' class='match'>605  	return -1;
606  }
607  int LexState::SubStylesStart(int styleBase) {
608  	if (instance) {
609  		return instance->SubStylesStart(styleBase);
610  	}
611  	return -1;
</span>612  }
613  int LexState::SubStylesLength(int styleBase) {
614  	if (instance) {
615  		return instance->SubStylesLength(styleBase);
616  	}
617  	return 0;
618  }
619  int LexState::StyleFromSubStyle(int subStyle) {
620  	if (instance) {
621  		return instance->StyleFromSubStyle(subStyle);
622  	}
623  	return 0;
624  }
625  int LexState::PrimaryStyleFromStyle(int style) {
626  	if (instance) {
627  		return instance->PrimaryStyleFromStyle(style);
628  	}
629  	return 0;
630  }
631  void LexState::FreeSubStyles() {
632  	if (instance) {
633  		instance->FreeSubStyles();
634  	}
635  }
636  void LexState::SetIdentifiers(int style, const char *identifiers) {
637  	if (instance) {
638  		instance->SetIdentifiers(style, identifiers);
639  		pdoc->ModifiedAt(0);
640  	}
641  }
642  int LexState::DistanceToSecondaryStyles() {
643  	if (instance) {
644  		return instance->DistanceToSecondaryStyles();
645  	}
646  	return 0;
647  }
648  const char *LexState::GetSubStyleBases() {
649  	if (instance) {
650  		return instance->GetSubStyleBases();
651  	}
652  	return "";
653  }
654  int LexState::NamedStyles() {
655  	if (instance) {
656  		return instance->NamedStyles();
657  	} else {
658  		return -1;
659  	}
660  }
661  const char *LexState::NameOfStyle(int style) {
662  	if (instance) {
663  		return instance->NameOfStyle(style);
664  	} else {
665  		return nullptr;
666  	}
667  }
668  const char *LexState::TagsOfStyle(int style) {
669  	if (instance) {
670  		return instance->TagsOfStyle(style);
671  	} else {
672  		return nullptr;
673  	}
674  }
675  const char *LexState::DescriptionOfStyle(int style) {
676  	if (instance) {
677  		return instance->DescriptionOfStyle(style);
678  	} else {
679  		return nullptr;
680  	}
681  }
682  void ScintillaBase::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
683  	if (!DocumentLexState()->UseContainerLexing()) {
684  		const Sci::Line lineEndStyled =
685  			pdoc->SciLineFromPosition(pdoc->GetEndStyled());
686  		const Sci::Position endStyled =
687  			pdoc->LineStart(lineEndStyled);
688  		DocumentLexState()->Colourise(endStyled, endStyleNeeded);
689  		return;
690  	}
691  	Editor::NotifyStyleToNeeded(endStyleNeeded);
692  }
693  sptr_t ScintillaBase::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
694  	switch (iMessage) {
695  	case Message::AutoCShow:
696  		listType = 0;
697  		AutoCompleteStart(PositionFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
698  		break;
699  	case Message::AutoCCancel:
700  		ac.Cancel();
701  		break;
702  	case Message::AutoCActive:
703  		return ac.Active();
704  	case Message::AutoCPosStart:
705  		return ac.posStart;
706  	case Message::AutoCComplete:
707  		AutoCompleteCompleted(0, CompletionMethods::Command);
708  		break;
709  	case Message::AutoCSetSeparator:
710  		ac.SetSeparator(static_cast<char>(wParam));
711  		break;
712  	case Message::AutoCGetSeparator:
713  		return ac.GetSeparator();
714  	case Message::AutoCStops:
715  		ac.SetStopChars(ConstCharPtrFromSPtr(lParam));
716  		break;
717  	case Message::AutoCSelect:
718  		ac.Select(ConstCharPtrFromSPtr(lParam));
719  		break;
720  	case Message::AutoCGetCurrent:
721  		return AutoCompleteGetCurrent();
722  	case Message::AutoCGetCurrentText:
723  		return AutoCompleteGetCurrentText(CharPtrFromSPtr(lParam));
724  	case Message::AutoCSetCancelAtStart:
725  		ac.cancelAtStartPos = wParam != 0;
726  		break;
727  	case Message::AutoCGetCancelAtStart:
728  		return ac.cancelAtStartPos;
729  	case Message::AutoCSetFillUps:
730  		ac.SetFillUpChars(ConstCharPtrFromSPtr(lParam));
731  		break;
732  	case Message::AutoCSetChooseSingle:
733  		ac.chooseSingle = wParam != 0;
734  		break;
735  	case Message::AutoCGetChooseSingle:
736  		return ac.chooseSingle;
737  	case Message::AutoCSetIgnoreCase:
738  		ac.ignoreCase = wParam != 0;
739  		break;
740  	case Message::AutoCGetIgnoreCase:
741  		return ac.ignoreCase;
742  	case Message::AutoCSetCaseInsensitiveBehaviour:
743  		ac.ignoreCaseBehaviour = static_cast<CaseInsensitiveBehaviour>(wParam);
744  		break;
745  	case Message::AutoCGetCaseInsensitiveBehaviour:
746  		return static_cast<sptr_t>(ac.ignoreCaseBehaviour);
747  	case Message::AutoCSetMulti:
748  		multiAutoCMode = static_cast<MultiAutoComplete>(wParam);
749  		break;
750  	case Message::AutoCGetMulti:
751  		return static_cast<sptr_t>(multiAutoCMode);
752  	case Message::AutoCSetOrder:
753  		ac.autoSort = static_cast<Ordering>(wParam);
754  		break;
755  	case Message::AutoCGetOrder:
756  		return static_cast<sptr_t>(ac.autoSort);
757  	case Message::UserListShow:
758  		listType = static_cast<int>(wParam);
759  		AutoCompleteStart(0, ConstCharPtrFromSPtr(lParam));
760  		break;
761  	case Message::AutoCSetAutoHide:
762  		ac.autoHide = wParam != 0;
763  		break;
764  	case Message::AutoCGetAutoHide:
765  		return ac.autoHide;
766  	case Message::AutoCSetOptions:
767  		ac.options = static_cast<AutoCompleteOption>(wParam);
768  		break;
769  	case Message::AutoCGetOptions:
770  		return static_cast<sptr_t>(ac.options);
771  	case Message::AutoCSetDropRestOfWord:
772  		ac.dropRestOfWord = wParam != 0;
773  		break;
774  	case Message::AutoCGetDropRestOfWord:
775  		return ac.dropRestOfWord;
776  	case Message::AutoCSetMaxHeight:
777  		ac.lb->SetVisibleRows(static_cast<int>(wParam));
778  		break;
779  	case Message::AutoCGetMaxHeight:
780  		return ac.lb->GetVisibleRows();
781  	case Message::AutoCSetMaxWidth:
782  		maxListWidth = static_cast<int>(wParam);
783  		break;
784  	case Message::AutoCGetMaxWidth:
785  		return maxListWidth;
786  	case Message::RegisterImage:
787  		ac.lb->RegisterImage(static_cast<int>(wParam), ConstCharPtrFromSPtr(lParam));
788  		break;
789  	case Message::RegisterRGBAImage:
790  		ac.lb->RegisterRGBAImage(static_cast<int>(wParam), static_cast<int>(sizeRGBAImage.x), static_cast<int>(sizeRGBAImage.y),
791  			ConstUCharPtrFromSPtr(lParam));
792  		break;
793  	case Message::ClearRegisteredImages:
794  		ac.lb->ClearRegisteredImages();
795  		break;
796  	case Message::AutoCSetTypeSeparator:
797  		ac.SetTypesep(static_cast<char>(wParam));
798  		break;
799  	case Message::AutoCGetTypeSeparator:
800  		return ac.GetTypesep();
801  	case Message::CallTipShow:
802  		CallTipShow(LocationFromPosition(wParam),
803  			ConstCharPtrFromSPtr(lParam));
804  		break;
805  	case Message::CallTipCancel:
806  		ct.CallTipCancel();
807  		break;
808  	case Message::CallTipActive:
809  		return ct.inCallTipMode;
810  	case Message::CallTipPosStart:
811  		return ct.posStartCallTip;
812  	case Message::CallTipSetPosStart:
813  		ct.posStartCallTip = wParam;
814  		break;
815  	case Message::CallTipSetHlt:
816  		ct.SetHighlight(wParam, lParam);
817  		break;
818  	case Message::CallTipSetBack:
819  		ct.colourBG = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
820  		vs.styles[StyleCallTip].back = ct.colourBG;
821  		InvalidateStyleRedraw();
822  		break;
823  	case Message::CallTipSetFore:
824  		ct.colourUnSel = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
825  		vs.styles[StyleCallTip].fore = ct.colourUnSel;
826  		InvalidateStyleRedraw();
827  		break;
828  	case Message::CallTipSetForeHlt:
829  		ct.colourSel = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
830  		InvalidateStyleRedraw();
831  		break;
832  	case Message::CallTipUseStyle:
833  		ct.SetTabSize(static_cast<int>(wParam));
834  		InvalidateStyleRedraw();
835  		break;
836  	case Message::CallTipSetPosition:
837  		ct.SetPosition(wParam != 0);
838  		InvalidateStyleRedraw();
839  		break;
840  	case Message::UsePopUp:
841  		displayPopupMenu = static_cast<PopUp>(wParam);
842  		break;
843  	case Message::GetLexer:
844  		return DocumentLexState()->GetIdentifier();
845  	case Message::SetILexer:
846  		DocumentLexState()->SetInstance(static_cast<ILexer5 *>(PtrFromSPtr(lParam)));
847  		return 0;
848  	case Message::Colourise:
849  		if (DocumentLexState()->UseContainerLexing()) {
850  			pdoc->ModifiedAt(PositionFromUPtr(wParam));
851  			NotifyStyleToNeeded((lParam == -1) ? pdoc->Length() : lParam);
852  		} else {
853  			DocumentLexState()->Colourise(PositionFromUPtr(wParam), lParam);
854  		}
855  		Redraw();
856  		break;
857  	case Message::SetProperty:
858  		DocumentLexState()->PropSet(ConstCharPtrFromUPtr(wParam),
859  		          ConstCharPtrFromSPtr(lParam));
860  		break;
861  	case Message::GetProperty:
862  		return StringResult(lParam, DocumentLexState()->PropGet(ConstCharPtrFromUPtr(wParam)));
863  	case Message::GetPropertyExpanded:
864  		return StringResult(lParam, DocumentLexState()->PropGet(ConstCharPtrFromUPtr(wParam)));
865  	case Message::GetPropertyInt:
866  		return DocumentLexState()->PropGetInt(ConstCharPtrFromUPtr(wParam), static_cast<int>(lParam));
867  	case Message::SetKeyWords:
868  		DocumentLexState()->SetWordList(static_cast<int>(wParam), ConstCharPtrFromSPtr(lParam));
869  		break;
870  	case Message::GetLexerLanguage:
871  		return StringResult(lParam, DocumentLexState()->GetName());
872  	case Message::PrivateLexerCall:
873  		return reinterpret_cast<sptr_t>(
874  			DocumentLexState()->PrivateCall(static_cast<int>(wParam), PtrFromSPtr(lParam)));
875  #ifdef INCLUDE_DEPRECATED_FEATURES
876  	case SCI_GETSTYLEBITSNEEDED:
877  		return 8;
878  #endif
879  	case Message::PropertyNames:
880  		return StringResult(lParam, DocumentLexState()->PropertyNames());
881  	case Message::PropertyType:
882  		return static_cast<sptr_t>(DocumentLexState()->PropertyType(ConstCharPtrFromUPtr(wParam)));
883  	case Message::DescribeProperty:
884  		return StringResult(lParam,
885  				    DocumentLexState()->DescribeProperty(ConstCharPtrFromUPtr(wParam)));
886  	case Message::DescribeKeyWordSets:
887  		return StringResult(lParam, DocumentLexState()->DescribeWordListSets());
888  	case Message::GetLineEndTypesSupported:
889  		return static_cast<sptr_t>(DocumentLexState()->LineEndTypesSupported());
890  	case Message::AllocateSubStyles:
891  		return DocumentLexState()->AllocateSubStyles(static_cast<int>(wParam), static_cast<int>(lParam));
892  	case Message::GetSubStylesStart:
893  		return DocumentLexState()->SubStylesStart(static_cast<int>(wParam));
894  	case Message::GetSubStylesLength:
895  		return DocumentLexState()->SubStylesLength(static_cast<int>(wParam));
896  	case Message::GetStyleFromSubStyle:
897  		return DocumentLexState()->StyleFromSubStyle(static_cast<int>(wParam));
898  	case Message::GetPrimaryStyleFromStyle:
899  		return DocumentLexState()->PrimaryStyleFromStyle(static_cast<int>(wParam));
900  	case Message::FreeSubStyles:
901  		DocumentLexState()->FreeSubStyles();
902  		break;
903  	case Message::SetIdentifiers:
904  		DocumentLexState()->SetIdentifiers(static_cast<int>(wParam),
905  						   ConstCharPtrFromSPtr(lParam));
906  		break;
907  	case Message::DistanceToSecondaryStyles:
908  		return DocumentLexState()->DistanceToSecondaryStyles();
909  	case Message::GetSubStyleBases:
910  		return StringResult(lParam, DocumentLexState()->GetSubStyleBases());
911  	case Message::GetNamedStyles:
912  		return DocumentLexState()->NamedStyles();
913  	case Message::NameOfStyle:
914  		return StringResult(lParam, DocumentLexState()->
915  				    NameOfStyle(static_cast<int>(wParam)));
916  	case Message::TagsOfStyle:
917  		return StringResult(lParam, DocumentLexState()->
918  				    TagsOfStyle(static_cast<int>(wParam)));
919  	case Message::DescriptionOfStyle:
920  		return StringResult(lParam, DocumentLexState()->
921  				    DescriptionOfStyle(static_cast<int>(wParam)));
922  	default:
923  		return Editor::WndProc(iMessage, wParam, lParam);
924  	}
925  	return 0;
926  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaBase.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaBase.cxx</div>
                </div>
                <div class="column column_space"><pre><code>611  	return -1;
612  }
613  int LexState::SubStylesLength(int styleBase) {
614  	if (instance) {
615  		return instance->SubStylesLength(styleBase);
616  	}
617  	return 0;
</pre></code></div>
                <div class="column column_space"><pre><code>605  	return -1;
606  }
607  int LexState::SubStylesStart(int styleBase) {
608  	if (instance) {
609  		return instance->SubStylesStart(styleBase);
610  	}
611  	return -1;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    