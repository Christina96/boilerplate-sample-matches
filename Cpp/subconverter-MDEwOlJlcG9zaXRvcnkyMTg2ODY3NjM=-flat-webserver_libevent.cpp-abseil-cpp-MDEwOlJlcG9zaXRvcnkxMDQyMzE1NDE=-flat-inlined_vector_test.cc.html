
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.272727272727273%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webserver_libevent.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <cstdint>
3  #include <iostream>
4  #include <evhttp.h>
5  #include <atomic>
6  #ifdef MALLOC_TRIM
7  #include <malloc.h>
8  #endif 
9  #include <string>
10  #include <vector>
11  #include <map>
12  #include <algorithm>
13  #include <string.h>
14  #include <pthread.h>
15  #include <thread>
16  #include <functional>
17  #include "../utils/base64/base64.h"
18  #include "../utils/file_extra.h"
19  #include "../utils/logger.h"
20  #include "../utils/stl_extra.h"
21  #include "../utils/string.h"
22  #include "../utils/urlencode.h"
23  #include "socket.h"
24  #include "webserver.h"
25  template <typename Lambda, class Ret, class... Args, class Pointer = Ret (*)(Args...)>
26  Pointer deduced_wrap(
27      const std::function<Ret(Args...)> &func)
28  {
29      static auto saved = func;
30      static Pointer p = [](Args... args) {
31          return saved(std::forward<Args>(args)...);
32      };
33      return p;
34  }
35  template <typename Lambda>
36  auto *wrap(Lambda &&func)
37  {
38      return deduced_wrap<Lambda>(std::function{func});
39  }
40  struct MIME_type
41  {
42      std::string extension;
43      std::string mimetype;
44  };
45  MIME_type mime_types[] = {{"html htm shtml","text/html"},
46                            {"css",           "text/css"},
47                            {"jpeg jpg",      "image/jpeg"},
48                            {"js",            "application/javascript"},
49                            {"txt",           "text/plain"},
50                            {"png",           "image/png"},
<span onclick='openModal()' class='match'>51                            {"ico",           "image/x-icon"},
52                            {"svg svgz",      "image/svg+xml"},
53                            {"woff",          "application/font-woff"},
54                            {"json",          "application/json"}};
</span>55  bool matchSpaceSeparatedList(const std::string& source, const std::string &target)
56  {
57      string_size pos_begin = 0, pos_end, total = source.size();
58      while(pos_begin < total)
59      {
60          pos_end = source.find(' ', pos_begin);
61          if(pos_end == source.npos)
62              pos_end = total;
63          if(source.compare(pos_begin, pos_end - pos_begin, target) == 0)
64              return true;
65          pos_begin = pos_end + 1;
66      }
67      return false;
68  }
69  std::string checkMIMEType(const std::string &filename)
70  {
71      string_size name_begin = 0, name_end = 0;
72      name_begin = filename.rfind('/');
73      if(name_begin == filename.npos)
74          name_begin = 0;
75      name_end = filename.rfind('.');
76      if(name_end == filename.npos || name_end < name_begin || name_end == filename.size() - 1)
77          return "application/octet-stream";
78      std::string extension = filename.substr(name_end + 1);
79      for(MIME_type &x : mime_types)
80          if(matchSpaceSeparatedList(x.extension, extension))
81              return x.mimetype;
82      return "application/octet-stream";
83  }
84  int WebServer::serveFile(const std::string &filename, std::string &content_type, std::string &return_data)
85  {
86      std::string realname = serve_file_root + filename;
87      if(filename.compare("/") == 0)
88          realname += "index.html";
89      if(!fileExist(realname))
90          return 1;
91      return_data = fileGet(realname, false);
92      content_type = checkMIMEType(realname);
93      writeLog(0, "file-server: serving '" + filename + "' type '" + content_type + "'", LOG_LEVEL_INFO);
94      return 0;
95  }
96  const char *request_header_blacklist[] = {"host", "accept", "accept-encoding"};
97  static inline void buffer_cleanup(struct evbuffer *eb)
98  {
99      (void)eb;
100  #ifdef MALLOC_TRIM
101      malloc_trim(0);
102  #endif 
103  }
104  inline int WebServer::process_request(Request &request, Response &response, std::string &return_data)
105  {
106      writeLog(0, "handle_cmd:    " + request.method + " handle_uri:    " + request.url, LOG_LEVEL_VERBOSE);
107      string_size pos = request.url.find("?");
108      if(pos != request.url.npos)
109      {
110          request.argument = request.url.substr(pos + 1);
111          request.url.erase(pos);
112      }
113      if(request.method == "OPTIONS")
114      {
115          for(responseRoute &x : responses)
116              if(matchSpaceSeparatedList(replaceAllDistinct(request.postdata, ",", ""), x.method) && x.path == request.url)
117                  return 1;
118          return -1;
119      }
120      for(responseRoute &x : responses)
121      {
122          if(x.method == request.method && x.path == request.url)
123          {
124              response_callback &rc = x.rc;
125              try
126              {
127                  return_data = rc(request, response);
128                  response.content_type = x.content_type;
129              }
130              catch(std::exception &e)
131              {
132                  return_data = "Internal server error while processing request path '" + request.url + "' with arguments '" + request.argument + "'!";
133                  return_data += "\n  exception: ";
134                  return_data += type(e);
135                  return_data += "\n  what(): ";
136                  return_data += e.what();
137                  response.content_type = "text/plain";
138                  response.status_code = 500;
139                  writeLog(0, return_data, LOG_LEVEL_ERROR);
140              }
141              return 0;
142          }
143      }
144      auto iter = redirect_map.find(request.url);
145      if(iter != redirect_map.end())
146      {
147          return_data = iter->second;
148          if(request.argument.size())
149          {
150              if(return_data.find("?") != return_data.npos)
151                  return_data += "&" + request.argument;
152              else
153                  return_data += "?" + request.argument;
154          }
155          return 2;
156      }
157      if(serve_file)
158      {
159          if(request.method.compare("GET") == 0 && serveFile(request.url, response.content_type, return_data) == 0)
160              return 0;
161      }
162      return -1;
163  }
164  void WebServer::on_request(evhttp_request *req, void *args)
165  {
166      (void)args;
167      static std::string auth_token = "Basic " + base64Encode(auth_user + ":" + auth_password);
168      const char *req_content_type = evhttp_find_header(req->input_headers, "Content-Type"), *req_ac_method = evhttp_find_header(req->input_headers, "Access-Control-Request-Method");
169      const char *uri = req->uri, *internal_flag = evhttp_find_header(req->input_headers, "SubConverter-Request");
170      char *client_ip;
171      u_short client_port;
172      evhttp_connection_get_peer(evhttp_request_get_connection(req), &client_ip, &client_port);
173      writeLog(0, "Accept connection from client " + std::string(client_ip) + ":" + std::to_string(client_port), LOG_LEVEL_DEBUG);
174      if (internal_flag != nullptr)
175      {
176          evhttp_send_error(req, 500, "Loop request detected!");
177          return;
178      }
179      if (require_auth)
180      {
181          const char *auth = evhttp_find_header(req->input_headers, "Authorization");
182          if (auth == nullptr || auth_token != auth)
183          {
184              evhttp_add_header(req->output_headers, "WWW-Authenticate", ("Basic realm=\"" + auth_realm + "\"").data());
185              auto buffer = evhttp_request_get_output_buffer(req);
186              evbuffer_add_printf(buffer, "Unauthorized");
187              evhttp_send_reply(req, 401, nullptr, buffer);
188              buffer_cleanup(buffer);
189              return;
190          }
191      }
192      Request request;
193      Response response;
194      size_t buffer_len = evbuffer_get_length(req->input_buffer);
195      if (buffer_len != 0)
196      {
197          request.postdata.assign(reinterpret_cast<char*>(evbuffer_pullup(req->input_buffer, -1)), buffer_len);
198          if(req_content_type != nullptr && strcmp(req_content_type, "application/x-www-form-urlencoded") == 0)
199              request.postdata = urlDecode(request.postdata);
200      }
201      else if (req_ac_method != nullptr)
202      {
203          request.postdata.assign(req_ac_method);
204      }
205      switch (req->type)
206      {
207          case EVHTTP_REQ_GET: request.method = "GET"; break;
208          case EVHTTP_REQ_POST: request.method = "POST"; break;
209          case EVHTTP_REQ_OPTIONS: request.method = "OPTIONS"; break;
210          case EVHTTP_REQ_PUT: request.method = "PUT"; break;
211          case EVHTTP_REQ_PATCH: request.method = "PATCH"; break;
212          case EVHTTP_REQ_DELETE: request.method = "DELETE"; break;
213          case EVHTTP_REQ_HEAD: request.method = "HEAD"; break;
214          default: break;
215      }
216      request.url = uri;
217      struct evkeyval* kv = req->input_headers->tqh_first;
218      while (kv)
219      {
220          if(std::none_of(std::begin(request_header_blacklist), std::end(request_header_blacklist), [&](auto x){ return strcasecmp(kv->key, x) == 0; }))
221              request.headers.emplace(kv->key, kv->value);
222          kv = kv->next.tqe_next;
223      }
224      request.headers.emplace("X-Client-IP", client_ip);
225      std::string return_data;
226      int retVal = process_request(request, response, return_data);
227      std::string &content_type = response.content_type;
228      auto *output_buffer = evhttp_request_get_output_buffer(req);
229      if (!output_buffer)
230      {
231          evhttp_send_error(req, HTTP_INTERNAL, nullptr);
232          return;
233      }
234      for (auto &x : response.headers)
235          evhttp_add_header(req->output_headers, x.first.data(), x.second.data());
236      switch (retVal)
237      {
238      case 1: 
239          evhttp_add_header(req->output_headers, "Access-Control-Allow-Origin", "*");
240          evhttp_add_header(req->output_headers, "Access-Control-Allow-Headers", "*");
241          evhttp_send_reply(req, response.status_code, nullptr, nullptr);
242          break;
243      case 2: 
244          evhttp_add_header(req->output_headers, "Location", return_data.c_str());
245          evhttp_send_reply(req, HTTP_MOVETEMP, nullptr, nullptr);
246          break;
247      case 0: 
248          if (content_type.size())
249              evhttp_add_header(req->output_headers, "Content-Type", content_type.c_str());
250          evhttp_add_header(req->output_headers, "Access-Control-Allow-Origin", "*");
251          evhttp_add_header(req->output_headers, "Connection", "close");
252          evbuffer_add(output_buffer, return_data.data(), return_data.size());
253          evhttp_send_reply(req, response.status_code, nullptr, output_buffer);
254          break;
255      case -1: 
256          return_data = "File not found.";
257          evbuffer_add(output_buffer, return_data.data(), return_data.size());
258          evhttp_send_reply(req, HTTP_NOTFOUND, nullptr, output_buffer);
259          break;
260      default: 
261          evhttp_send_error(req, HTTP_INTERNAL, nullptr);
262      }
263      buffer_cleanup(output_buffer);
264  }
265  int WebServer::start_web_server(void *argv)
266  {
267      struct listener_args *args = reinterpret_cast<listener_args*>(argv);
268      std::string listen_address = args->listen_address;
269      int port = args->port;
270      if (!event_init())
271      {
272          writeLog(0, "Failed to init libevent.", LOG_LEVEL_FATAL);
273          return -1;
274      }
275      const char *SrvAddress = listen_address.c_str();
276      std::uint16_t SrvPort = port;
277      std::unique_ptr<evhttp, decltype(&evhttp_free)> server(evhttp_start(SrvAddress, SrvPort), &evhttp_free);
278      if (!server)
279      {
280          writeLog(0, "Failed to init http server.", LOG_LEVEL_FATAL);
281          return -1;
282      }
283      auto call_on_request = [&](evhttp_request *req, void *args) { on_request(req, args); };
284      evhttp_set_allowed_methods(server.get(), EVHTTP_REQ_GET | EVHTTP_REQ_POST | EVHTTP_REQ_OPTIONS | EVHTTP_REQ_PUT | EVHTTP_REQ_PATCH | EVHTTP_REQ_DELETE | EVHTTP_REQ_HEAD);
285      evhttp_set_gencb(server.get(), wrap(call_on_request), nullptr);
286      evhttp_set_timeout(server.get(), 30);
287      if (event_dispatch() == -1)
288      {
289          writeLog(0, "Failed to run message loop.", LOG_LEVEL_FATAL);
290          return -1;
291      }
292      return 0;
293  }
294  void* httpserver_dispatch(void *arg)
295  {
296      event_base_dispatch(reinterpret_cast<event_base*>(arg));
297      event_base_free(reinterpret_cast<event_base*>(arg)); 
298      return nullptr;
299  }
300  int httpserver_bindsocket(std::string listen_address, int listen_port, int backlog)
301  {
302      SOCKET nfd;
303      nfd = socket(AF_INET, SOCK_STREAM, 0);
304      if (nfd <= 0)
305          return -1;
306      int one = 1;
307      if (setsockopt(nfd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(int)) < 0)
308      {
309          closesocket(nfd);
310          return -1;
311      }
312  #ifdef SO_NOSIGPIPE
313      if (setsockopt(nfd, SOL_SOCKET, SO_NOSIGPIPE, (char *)&one, sizeof(int)) < 0)
314      {
315          closesocket(nfd);
316          return -1;
317      }
318  #endif
319      struct sockaddr_in addr;
320      memset(&addr, 0, sizeof(addr));
321      addr.sin_family = AF_INET;
322      addr.sin_addr.s_addr = inet_addr(listen_address.data());
323      addr.sin_port = htons(listen_port);
324      if (::bind(nfd, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0 || listen(nfd, backlog) < 0)
325      {
326          closesocket(nfd);
327          return -1;
328      }
329      unsigned long ul = 1;
330      ioctlsocket(nfd, FIONBIO, &ul); 
331      return nfd;
332  }
333  int WebServer::start_web_server_multi(void *argv)
334  {
335      struct listener_args *args = reinterpret_cast<listener_args*>(argv);
336      std::string listen_address = args->listen_address;
337      int port = args->port, nthreads = args->max_workers, max_conn = args->max_conn;
338      auto call_on_request = [&](evhttp_request *req, void *args) { on_request(req, args); };
339      int nfd = httpserver_bindsocket(listen_address, port, max_conn);
340      if (nfd < 0)
341          return -1;
342      pthread_t ths[nthreads];
343      struct event_base *base[nthreads];
344      for (int i = 0; i < nthreads; i++)
345      {
346          base[i] = event_init();
347          if (base[i] == nullptr)
348              return -1;
349          struct evhttp *httpd = evhttp_new(base[i]);
350          if (httpd == nullptr)
351              return -1;
352          if (evhttp_accept_socket(httpd, nfd) != 0)
353              return -1;
354          evhttp_set_allowed_methods(httpd, EVHTTP_REQ_GET | EVHTTP_REQ_POST | EVHTTP_REQ_OPTIONS | EVHTTP_REQ_PUT | EVHTTP_REQ_PATCH | EVHTTP_REQ_DELETE | EVHTTP_REQ_HEAD);
355          evhttp_set_gencb(httpd, wrap(call_on_request), nullptr);
356          evhttp_set_timeout(httpd, 30);
357          if (pthread_create(&ths[i], nullptr, httpserver_dispatch, base[i]) != 0)
358              return -1;
359      }
360      while (!SERVER_EXIT_FLAG)
361      {
362          if (args->looper_callback != nullptr)
363              args->looper_callback();
364          std::this_thread::sleep_for(std::chrono::milliseconds(args->looper_interval)); 
365      }
366      for (int i = 0; i < nthreads; i++)
367          event_base_loopbreak(base[i]); 
368      shutdown(nfd, SD_BOTH); 
369      closesocket(nfd); 
370      return 0;
371  }
372  void WebServer::stop_web_server()
373  {
374      SERVER_EXIT_FLAG = true;
375  }
376  void WebServer::append_response(const std::string &method, const std::string &uri, const std::string &content_type, response_callback response)
377  {
378      responseRoute rr;
379      rr.method = method;
380      rr.path = uri;
381      rr.content_type = content_type;
382      rr.rc = response;
383      responses.emplace_back(std::move(rr));
384  }
385  void WebServer::append_redirect(const std::string &uri, const std::string &target)
386  {
387      redirect_map[uri] = target;
388  }
389  void WebServer::reset_redirect()
390  {
391      eraseElements(redirect_map);
392  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_test.cc</h3>
            <pre><code>1  #include "absl/container/inlined_vector.h"
2  #include <algorithm>
3  #include <cstddef>
4  #include <forward_list>
5  #include <iterator>
6  #include <list>
7  #include <memory>
8  #include <scoped_allocator>
9  #include <sstream>
10  #include <stdexcept>
11  #include <string>
12  #include <utility>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/attributes.h"
17  #include "absl/base/internal/exception_testing.h"
18  #include "absl/base/macros.h"
19  #include "absl/base/options.h"
20  #include "absl/container/internal/counting_allocator.h"
21  #include "absl/container/internal/test_instance_tracker.h"
22  #include "absl/hash/hash_testing.h"
23  #include "absl/log/check.h"
24  #include "absl/memory/memory.h"
25  #include "absl/strings/str_cat.h"
26  namespace {
27  using absl::container_internal::CountingAllocator;
28  using absl::test_internal::CopyableMovableInstance;
29  using absl::test_internal::CopyableOnlyInstance;
30  using absl::test_internal::InstanceTracker;
31  using testing::AllOf;
32  using testing::Each;
33  using testing::ElementsAre;
34  using testing::ElementsAreArray;
35  using testing::Eq;
36  using testing::Gt;
37  using testing::Pointee;
38  using testing::Pointwise;
39  using testing::PrintToString;
40  using testing::SizeIs;
41  using IntVec = absl::InlinedVector<int, 8>;
42  MATCHER_P(CapacityIs, n, "") {
43    return testing::ExplainMatchResult(n, arg.capacity(), result_listener);
44  }
45  MATCHER_P(ValueIs, e, "") {
46    return testing::ExplainMatchResult(e, arg.value(), result_listener);
47  }
48  template <typename T>
49  class InstanceTest : public ::testing::Test {};
50  TYPED_TEST_SUITE_P(InstanceTest);
51  class RefCounted {
52   public:
53    RefCounted(int value, int* count) : value_(value), count_(count) { Ref(); }
54    RefCounted(const RefCounted& v) : value_(v.value_), count_(v.count_) {
55      Ref();
56    }
57    ~RefCounted() {
58      Unref();
59      count_ = nullptr;
60    }
61    friend void swap(RefCounted& a, RefCounted& b) {
62      using std::swap;
63      swap(a.value_, b.value_);
64      swap(a.count_, b.count_);
65    }
66    RefCounted& operator=(RefCounted v) {
67      using std::swap;
68      swap(*this, v);
69      return *this;
70    }
71    void Ref() const {
72      CHECK_NE(count_, nullptr);
73      ++(*count_);
74    }
75    void Unref() const {
76      --(*count_);
77      CHECK_GE(*count_, 0);
78    }
79    int value_;
80    int* count_;
81  };
82  using RefCountedVec = absl::InlinedVector<RefCounted, 8>;
83  class Dynamic {
84   public:
85    virtual ~Dynamic() {}
86  };
87  using DynamicVec = absl::InlinedVector<Dynamic, 8>;
88  template <typename Container>
89  static void Fill(Container* v, size_t len, int offset = 0) {
90    for (size_t i = 0; i < len; i++) {
91      v->push_back(static_cast<int>(i) + offset);
92    }
93  }
94  static IntVec Fill(size_t len, int offset = 0) {
95    IntVec v;
96    Fill(&v, len, offset);
97    return v;
98  }
99  TEST(IntVec, SimpleOps) {
100    for (size_t len = 0; len < 20; len++) {
101      IntVec v;
102      const IntVec& cv = v;  
103      Fill(&v, len);
104      EXPECT_EQ(len, v.size());
105      EXPECT_LE(len, v.capacity());
106      for (size_t i = 0; i < len; i++) {
107        EXPECT_EQ(static_cast<int>(i), v[i]);
108        EXPECT_EQ(static_cast<int>(i), v.at(i));
109      }
110      EXPECT_EQ(v.begin(), v.data());
111      EXPECT_EQ(cv.begin(), cv.data());
112      size_t counter = 0;
113      for (IntVec::iterator iter = v.begin(); iter != v.end(); ++iter) {
114        EXPECT_EQ(static_cast<int>(counter), *iter);
115        counter++;
116      }
117      EXPECT_EQ(counter, len);
118      counter = 0;
119      for (IntVec::const_iterator iter = v.begin(); iter != v.end(); ++iter) {
120        EXPECT_EQ(static_cast<int>(counter), *iter);
121        counter++;
122      }
123      EXPECT_EQ(counter, len);
124      counter = 0;
125      for (IntVec::const_iterator iter = v.cbegin(); iter != v.cend(); ++iter) {
126        EXPECT_EQ(static_cast<int>(counter), *iter);
127        counter++;
128      }
129      EXPECT_EQ(counter, len);
130      if (len > 0) {
131        EXPECT_EQ(0, v.front());
132        EXPECT_EQ(static_cast<int>(len - 1), v.back());
133        v.pop_back();
134        EXPECT_EQ(len - 1, v.size());
135        for (size_t i = 0; i < v.size(); ++i) {
136          EXPECT_EQ(static_cast<int>(i), v[i]);
137          EXPECT_EQ(static_cast<int>(i), v.at(i));
138        }
139      }
140    }
141  }
142  TEST(IntVec, PopBackNoOverflow) {
143    IntVec v = {1};
144    v.pop_back();
145    EXPECT_EQ(v.size(), 0u);
146  }
147  TEST(IntVec, AtThrows) {
148    IntVec v = {1, 2, 3};
149    EXPECT_EQ(v.at(2), 3);
150    ABSL_BASE_INTERNAL_EXPECT_FAIL(v.at(3), std::out_of_range,
151                                   "failed bounds check");
152  }
153  TEST(IntVec, ReverseIterator) {
154    for (size_t len = 0; len < 20; len++) {
155      IntVec v;
156      Fill(&v, len);
157      size_t counter = len;
158      for (IntVec::reverse_iterator iter = v.rbegin(); iter != v.rend(); ++iter) {
159        counter--;
160        EXPECT_EQ(static_cast<int>(counter), *iter);
161      }
162      EXPECT_EQ(counter, 0u);
163      counter = len;
164      for (IntVec::const_reverse_iterator iter = v.rbegin(); iter != v.rend();
165           ++iter) {
166        counter--;
167        EXPECT_EQ(static_cast<int>(counter), *iter);
168      }
169      EXPECT_EQ(counter, 0u);
170      counter = len;
171      for (IntVec::const_reverse_iterator iter = v.crbegin(); iter != v.crend();
172           ++iter) {
173        counter--;
174        EXPECT_EQ(static_cast<int>(counter), *iter);
175      }
176      EXPECT_EQ(counter, 0u);
177    }
178  }
179  TEST(IntVec, Erase) {
180    for (size_t len = 1; len < 20; len++) {
181      for (size_t i = 0; i < len; ++i) {
182        IntVec v;
183        Fill(&v, len);
184        v.erase(v.begin() + i);
185        EXPECT_EQ(len - 1, v.size());
186        for (size_t j = 0; j < i; ++j) {
187          EXPECT_EQ(static_cast<int>(j), v[j]);
188        }
189        for (size_t j = i; j < len - 1; ++j) {
190          EXPECT_EQ(static_cast<int>(j + 1), v[j]);
191        }
192      }
193    }
194  }
195  TEST(IntVec, Hardened) {
196    IntVec v;
197    Fill(&v, 10);
198    EXPECT_EQ(v[9], 9);
199  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
200    EXPECT_DEATH_IF_SUPPORTED(v[10], "");
201    EXPECT_DEATH_IF_SUPPORTED(v[static_cast<size_t>(-1)], "");
202    EXPECT_DEATH_IF_SUPPORTED(v.resize(v.max_size() + 1), "");
203  #endif
204  }
205  TEST(UniquePtr, MoveConstruct) {
206    for (size_t size = 0; size < 16; ++size) {
207      SCOPED_TRACE(size);
208      absl::InlinedVector<std::unique_ptr<size_t>, 2> a;
209      for (size_t i = 0; i < size; ++i) {
210        a.push_back(std::make_unique<size_t>(i));
211      }
212      absl::InlinedVector<std::unique_ptr<size_t>, 2> b(std::move(a));
213      ASSERT_THAT(b, SizeIs(size));
214      for (size_t i = 0; i < size; ++i) {
215        ASSERT_THAT(b[i], Pointee(i));
216      }
217    }
218  }
219  TEST(UniquePtr, MoveAssign) {
220    for (size_t size = 0; size < 16; ++size) {
221      SCOPED_TRACE(size);
222      absl::InlinedVector<std::unique_ptr<size_t>, 2> a;
223      for (size_t i = 0; i < size; ++i) {
224        a.push_back(std::make_unique<size_t>(i));
225      }
226      absl::InlinedVector<std::unique_ptr<size_t>, 2> b;
227      b = std::move(a);
228      ASSERT_THAT(b, SizeIs(size));
229      for (size_t i = 0; i < size; ++i) {
230        ASSERT_THAT(b[i], Pointee(i));
231      }
232    }
233  }
234  TEST(RefCountedVec, EraseBeginEnd) {
235    for (size_t len = 1; len < 20; ++len) {
236      for (size_t erase_begin = 0; erase_begin < len; ++erase_begin) {
237        for (size_t erase_end = erase_begin; erase_end <= len; ++erase_end) {
238          std::vector<int> counts(len, 0);
239          RefCountedVec v;
240          for (size_t i = 0; i < len; ++i) {
241            v.push_back(RefCounted(static_cast<int>(i), &counts[i]));
242          }
243          size_t erase_len = erase_end - erase_begin;
244          v.erase(v.begin() + erase_begin, v.begin() + erase_end);
245          EXPECT_EQ(len - erase_len, v.size());
246          for (size_t i = 0; i < erase_begin; ++i) {
247            EXPECT_EQ(static_cast<int>(i), v[i].value_);
248          }
249          for (size_t i = erase_begin; i < v.size(); ++i) {
250            EXPECT_EQ(static_cast<int>(i + erase_len), v[i].value_);
251          }
252          for (size_t i = 0; i < erase_begin; ++i) {
253            EXPECT_EQ(1, counts[i]);
254          }
255          for (size_t i = erase_begin; i < erase_end; ++i) {
256            EXPECT_EQ(0, counts[i]);
257          }
258          for (size_t i = erase_end; i < len; ++i) {
259            EXPECT_EQ(1, counts[i]);
260          }
261        }
262      }
263    }
264  }
265  struct NoDefaultCtor {
266    explicit NoDefaultCtor(int) {}
267  };
268  struct NoCopy {
269    NoCopy() {}
270    NoCopy(const NoCopy&) = delete;
271  };
272  struct NoAssign {
273    NoAssign() {}
274    NoAssign& operator=(const NoAssign&) = delete;
275  };
276  struct MoveOnly {
277    MoveOnly() {}
278    MoveOnly(MoveOnly&&) = default;
279    MoveOnly& operator=(MoveOnly&&) = default;
280  };
281  TEST(InlinedVectorTest, NoDefaultCtor) {
282    absl::InlinedVector<NoDefaultCtor, 1> v(10, NoDefaultCtor(2));
283    (void)v;
284  }
285  TEST(InlinedVectorTest, NoCopy) {
286    absl::InlinedVector<NoCopy, 1> v(10);
287    (void)v;
288  }
289  TEST(InlinedVectorTest, NoAssign) {
290    absl::InlinedVector<NoAssign, 1> v(10);
291    (void)v;
292  }
293  TEST(InlinedVectorTest, MoveOnly) {
294    absl::InlinedVector<MoveOnly, 2> v;
295    v.push_back(MoveOnly{});
296    v.push_back(MoveOnly{});
297    v.push_back(MoveOnly{});
298    v.erase(v.begin());
299    v.push_back(MoveOnly{});
300    v.erase(v.begin(), v.begin() + 1);
301    v.insert(v.begin(), MoveOnly{});
302    v.emplace(v.begin());
303    v.emplace(v.begin(), MoveOnly{});
304  }
305  TEST(InlinedVectorTest, Noexcept) {
306    EXPECT_TRUE(std::is_nothrow_move_constructible<IntVec>::value);
307    EXPECT_TRUE((std::is_nothrow_move_constructible<
308                 absl::InlinedVector<MoveOnly, 2>>::value));
309    struct MoveCanThrow {
310      MoveCanThrow(MoveCanThrow&&) {}
311    };
312    EXPECT_EQ(absl::default_allocator_is_nothrow::value,
313              (std::is_nothrow_move_constructible<
314                  absl::InlinedVector<MoveCanThrow, 2>>::value));
315  }
316  TEST(InlinedVectorTest, EmplaceBack) {
317    absl::InlinedVector<std::pair<std::string, int>, 1> v;
318    auto& inlined_element = v.emplace_back("answer", 42);
319    EXPECT_EQ(&inlined_element, &v[0]);
320    EXPECT_EQ(inlined_element.first, "answer");
321    EXPECT_EQ(inlined_element.second, 42);
322    auto& allocated_element = v.emplace_back("taxicab", 1729);
323    EXPECT_EQ(&allocated_element, &v[1]);
324    EXPECT_EQ(allocated_element.first, "taxicab");
325    EXPECT_EQ(allocated_element.second, 1729);
326  }
327  TEST(InlinedVectorTest, ShrinkToFitGrowingVector) {
328    absl::InlinedVector<std::pair<std::string, int>, 1> v;
329    v.shrink_to_fit();
330    EXPECT_EQ(v.capacity(), 1u);
331    v.emplace_back("answer", 42);
332    v.shrink_to_fit();
333    EXPECT_EQ(v.capacity(), 1u);
334    v.emplace_back("taxicab", 1729);
335    EXPECT_GE(v.capacity(), 2u);
336    v.shrink_to_fit();
337    EXPECT_EQ(v.capacity(), 2u);
338    v.reserve(100);
339    EXPECT_GE(v.capacity(), 100u);
340    v.shrink_to_fit();
341    EXPECT_EQ(v.capacity(), 2u);
342  }
343  TEST(InlinedVectorTest, ShrinkToFitEdgeCases) {
344    {
345      absl::InlinedVector<std::pair<std::string, int>, 1> v;
346      v.emplace_back("answer", 42);
347      v.emplace_back("taxicab", 1729);
348      EXPECT_GE(v.capacity(), 2u);
349      v.pop_back();
350      v.shrink_to_fit();
351      EXPECT_EQ(v.capacity(), 1u);
352      EXPECT_EQ(v[0].first, "answer");
353      EXPECT_EQ(v[0].second, 42);
354    }
<span onclick='openModal()' class='match'>355    {
356      absl::InlinedVector<std::string, 2> v(100);
357      v.resize(0);
358      v.shrink_to_fit();
359      EXPECT_EQ(v.capacity(), 2u);  
360    }
361    {
362      absl::InlinedVector<std::string, 2> v(100);
363      v.resize(1);
364      v.shrink_to_fit();
365      EXPECT_EQ(v.capacity(), 2u);  
366    }
367    {
368      absl::InlinedVector<std::string, 2> v(100);
369      v.resize(2);
370      v.shrink_to_fit();
371      EXPECT_EQ(v.capacity(), 2u);
372    }
373    {
374      absl::InlinedVector<std::string, 2> v(100);
375      v.resize(3);
376      v.shrink_to_fit();
377      EXPECT_EQ(v.capacity(), 3u);
378    }
379  }
</span>380  TEST(IntVec, Insert) {
381    for (size_t len = 0; len < 20; len++) {
382      for (ptrdiff_t pos = 0; pos <= static_cast<ptrdiff_t>(len); pos++) {
383        {
384          std::vector<int> std_v;
385          Fill(&std_v, len);
386          IntVec v;
387          Fill(&v, len);
388          std_v.insert(std_v.begin() + pos, 9999);
389          IntVec::iterator it = v.insert(v.cbegin() + pos, 9999);
390          EXPECT_THAT(v, ElementsAreArray(std_v));
391          EXPECT_EQ(it, v.cbegin() + pos);
392        }
393        {
394          std::vector<int> std_v;
395          Fill(&std_v, len);
396          IntVec v;
397          Fill(&v, len);
398          IntVec::size_type n = 5;
399          std_v.insert(std_v.begin() + pos, n, 9999);
400          IntVec::iterator it = v.insert(v.cbegin() + pos, n, 9999);
401          EXPECT_THAT(v, ElementsAreArray(std_v));
402          EXPECT_EQ(it, v.cbegin() + pos);
403        }
404        {
405          std::vector<int> std_v;
406          Fill(&std_v, len);
407          IntVec v;
408          Fill(&v, len);
409          const std::vector<int> input = {9999, 8888, 7777};
410          std_v.insert(std_v.begin() + pos, input.cbegin(), input.cend());
411          IntVec::iterator it =
412              v.insert(v.cbegin() + pos, input.cbegin(), input.cend());
413          EXPECT_THAT(v, ElementsAreArray(std_v));
414          EXPECT_EQ(it, v.cbegin() + pos);
415        }
416        {
417          std::vector<int> std_v;
418          Fill(&std_v, len);
419          IntVec v;
420          Fill(&v, len);
421          const std::forward_list<int> input = {9999, 8888, 7777};
422          std_v.insert(std_v.begin() + pos, input.cbegin(), input.cend());
423          IntVec::iterator it =
424              v.insert(v.cbegin() + pos, input.cbegin(), input.cend());
425          EXPECT_THAT(v, ElementsAreArray(std_v));
426          EXPECT_EQ(it, v.cbegin() + pos);
427        }
428        {
429          std::vector<int> std_v;
430          Fill(&std_v, len);
431          IntVec v;
432          Fill(&v, len);
433          std_v.insert(std_v.begin() + pos, {9999, 8888, 7777});
434          std::istringstream input("9999 8888 7777");
435          IntVec::iterator it =
436              v.insert(v.cbegin() + pos, std::istream_iterator<int>(input),
437                       std::istream_iterator<int>());
438          EXPECT_THAT(v, ElementsAreArray(std_v));
439          EXPECT_EQ(it, v.cbegin() + pos);
440        }
441        {
442          std::vector<int> std_v;
443          Fill(&std_v, len);
444          IntVec v;
445          Fill(&v, len);
446          std_v.insert(std_v.begin() + pos, {9999, 8888});
447          IntVec::iterator it = v.insert(v.cbegin() + pos, {9999, 8888});
448          EXPECT_THAT(v, ElementsAreArray(std_v));
449          EXPECT_EQ(it, v.cbegin() + pos);
450        }
451      }
452    }
453  }
454  TEST(RefCountedVec, InsertConstructorDestructor) {
455    for (size_t len = 0; len < 20; len++) {
456      SCOPED_TRACE(len);
457      for (size_t pos = 0; pos <= len; pos++) {
458        SCOPED_TRACE(pos);
459        std::vector<int> counts(len, 0);
460        int inserted_count = 0;
461        RefCountedVec v;
462        for (size_t i = 0; i < len; ++i) {
463          SCOPED_TRACE(i);
464          v.push_back(RefCounted(static_cast<int>(i), &counts[i]));
465        }
466        EXPECT_THAT(counts, Each(Eq(1)));
467        RefCounted insert_element(9999, &inserted_count);
468        EXPECT_EQ(1, inserted_count);
469        v.insert(v.begin() + pos, insert_element);
470        EXPECT_EQ(2, inserted_count);
471        EXPECT_THAT(counts, Each(Eq(1)));
472        EXPECT_EQ(2, inserted_count);
473      }
474    }
475  }
476  TEST(IntVec, Resize) {
477    for (size_t len = 0; len < 20; len++) {
478      IntVec v;
479      Fill(&v, len);
480      static const int kResizeElem = 1000000;
481      for (size_t k = 0; k < 10; k++) {
482        v.resize(len + k, kResizeElem);
483        EXPECT_EQ(len + k, v.size());
484        EXPECT_LE(len + k, v.capacity());
485        for (size_t i = 0; i < len + k; i++) {
486          if (i < len) {
487            EXPECT_EQ(static_cast<int>(i), v[i]);
488          } else {
489            EXPECT_EQ(kResizeElem, v[i]);
490          }
491        }
492        v.resize(len, kResizeElem);
493        EXPECT_EQ(len, v.size());
494        EXPECT_LE(len, v.capacity());
495        for (size_t i = 0; i < len; i++) {
496          EXPECT_EQ(static_cast<int>(i), v[i]);
497        }
498      }
499    }
500  }
501  TEST(IntVec, InitWithLength) {
502    for (size_t len = 0; len < 20; len++) {
503      IntVec v(len, 7);
504      EXPECT_EQ(len, v.size());
505      EXPECT_LE(len, v.capacity());
506      for (size_t i = 0; i < len; i++) {
507        EXPECT_EQ(7, v[i]);
508      }
509    }
510  }
511  TEST(IntVec, CopyConstructorAndAssignment) {
512    for (size_t len = 0; len < 20; len++) {
513      IntVec v;
514      Fill(&v, len);
515      EXPECT_EQ(len, v.size());
516      EXPECT_LE(len, v.capacity());
517      IntVec v2(v);
518      EXPECT_TRUE(v == v2) << PrintToString(v) << PrintToString(v2);
519      for (size_t start_len = 0; start_len < 20; start_len++) {
520        IntVec v3;
521        Fill(&v3, start_len, 99);  
522        v3 = v;
523        EXPECT_TRUE(v == v3) << PrintToString(v) << PrintToString(v3);
524      }
525    }
526  }
527  TEST(IntVec, AliasingCopyAssignment) {
528    for (size_t len = 0; len < 20; ++len) {
529      IntVec original;
530      Fill(&original, len);
531      IntVec dup = original;
532      dup = *&dup;
533      EXPECT_EQ(dup, original);
534    }
535  }
536  TEST(IntVec, MoveConstructorAndAssignment) {
537    for (size_t len = 0; len < 20; len++) {
538      IntVec v_in;
539      const size_t inlined_capacity = v_in.capacity();
540      Fill(&v_in, len);
541      EXPECT_EQ(len, v_in.size());
542      EXPECT_LE(len, v_in.capacity());
543      {
544        IntVec v_temp(v_in);
545        auto* old_data = v_temp.data();
546        IntVec v_out(std::move(v_temp));
547        EXPECT_TRUE(v_in == v_out) << PrintToString(v_in) << PrintToString(v_out);
548        if (v_in.size() > inlined_capacity) {
549          EXPECT_TRUE(v_out.data() == old_data);
550        } else {
551          EXPECT_FALSE(v_out.data() == old_data);
552        }
553      }
554      for (size_t start_len = 0; start_len < 20; start_len++) {
555        IntVec v_out;
556        Fill(&v_out, start_len, 99);  
557        IntVec v_temp(v_in);
558        auto* old_data = v_temp.data();
559        v_out = std::move(v_temp);
560        EXPECT_TRUE(v_in == v_out) << PrintToString(v_in) << PrintToString(v_out);
561        if (v_in.size() > inlined_capacity) {
562          EXPECT_TRUE(v_out.data() == old_data);
563        } else {
564          EXPECT_FALSE(v_out.data() == old_data);
565        }
566      }
567    }
568  }
569  class NotTriviallyDestructible {
570   public:
571    NotTriviallyDestructible() : p_(new int(1)) {}
572    explicit NotTriviallyDestructible(int i) : p_(new int(i)) {}
573    NotTriviallyDestructible(const NotTriviallyDestructible& other)
574        : p_(new int(*other.p_)) {}
575    NotTriviallyDestructible& operator=(const NotTriviallyDestructible& other) {
576      p_ = absl::make_unique<int>(*other.p_);
577      return *this;
578    }
579    bool operator==(const NotTriviallyDestructible& other) const {
580      return *p_ == *other.p_;
581    }
582   private:
583    std::unique_ptr<int> p_;
584  };
585  TEST(AliasingTest, Emplace) {
586    for (size_t i = 2; i < 20; ++i) {
587      absl::InlinedVector<NotTriviallyDestructible, 10> vec;
588      for (size_t j = 0; j < i; ++j) {
589        vec.push_back(NotTriviallyDestructible(static_cast<int>(j)));
590      }
591      vec.emplace(vec.begin(), vec[0]);
592      EXPECT_EQ(vec[0], vec[1]);
593      vec.emplace(vec.begin() + i / 2, vec[i / 2]);
594      EXPECT_EQ(vec[i / 2], vec[i / 2 + 1]);
595      vec.emplace(vec.end() - 1, vec.back());
596      EXPECT_EQ(vec[vec.size() - 2], vec.back());
597    }
598  }
599  TEST(AliasingTest, InsertWithCount) {
600    for (size_t i = 1; i < 20; ++i) {
601      absl::InlinedVector<NotTriviallyDestructible, 10> vec;
602      for (size_t j = 0; j < i; ++j) {
603        vec.push_back(NotTriviallyDestructible(static_cast<int>(j)));
604      }
605      for (size_t n = 0; n < 5; ++n) {
606        vec.insert(vec.begin(), n, vec.back());
607        auto b = vec.begin();
608        EXPECT_TRUE(
609            std::all_of(b, b + n, [&vec](const NotTriviallyDestructible& x) {
610              return x == vec.back();
611            }));
612        auto m_idx = vec.size() / 2;
613        vec.insert(vec.begin() + m_idx, n, vec.back());
614        auto m = vec.begin() + m_idx;
615        EXPECT_TRUE(
616            std::all_of(m, m + n, [&vec](const NotTriviallyDestructible& x) {
617              return x == vec.back();
618            }));
619        auto old_e = vec.size() - 1;
620        auto val = vec[old_e];
621        vec.insert(vec.end(), n, vec[old_e]);
622        auto e = vec.begin() + old_e;
623        EXPECT_TRUE(std::all_of(
624            e, e + n,
625            [&val](const NotTriviallyDestructible& x) { return x == val; }));
626      }
627    }
628  }
629  TEST(OverheadTest, Storage) {
630    struct T { void* val; };
631    size_t expected_overhead = sizeof(T);
632    EXPECT_EQ((2 * expected_overhead),
633              sizeof(absl::InlinedVector<T, 1>) - sizeof(T[1]));
634    EXPECT_EQ(expected_overhead,
635              sizeof(absl::InlinedVector<T, 2>) - sizeof(T[2]));
636    EXPECT_EQ(expected_overhead,
637              sizeof(absl::InlinedVector<T, 3>) - sizeof(T[3]));
638    EXPECT_EQ(expected_overhead,
639              sizeof(absl::InlinedVector<T, 4>) - sizeof(T[4]));
640    EXPECT_EQ(expected_overhead,
641              sizeof(absl::InlinedVector<T, 5>) - sizeof(T[5]));
642    EXPECT_EQ(expected_overhead,
643              sizeof(absl::InlinedVector<T, 6>) - sizeof(T[6]));
644    EXPECT_EQ(expected_overhead,
645              sizeof(absl::InlinedVector<T, 7>) - sizeof(T[7]));
646    EXPECT_EQ(expected_overhead,
647              sizeof(absl::InlinedVector<T, 8>) - sizeof(T[8]));
648  }
649  TEST(IntVec, Clear) {
650    for (size_t len = 0; len < 20; len++) {
651      SCOPED_TRACE(len);
652      IntVec v;
653      Fill(&v, len);
654      v.clear();
655      EXPECT_EQ(0u, v.size());
656      EXPECT_EQ(v.begin(), v.end());
657    }
658  }
659  TEST(IntVec, Reserve) {
660    for (size_t len = 0; len < 20; len++) {
661      IntVec v;
662      Fill(&v, len);
663      for (size_t newlen = 0; newlen < 100; newlen++) {
664        const int* start_rep = v.data();
665        v.reserve(newlen);
666        const int* final_rep = v.data();
667        if (newlen <= len) {
668          EXPECT_EQ(start_rep, final_rep);
669        }
670        EXPECT_LE(newlen, v.capacity());
671        while (v.size() < newlen) {
672          v.push_back(0);
673        }
674        EXPECT_EQ(final_rep, v.data());
675      }
676    }
677  }
678  TEST(StringVec, SelfRefPushBack) {
679    std::vector<std::string> std_v;
680    absl::InlinedVector<std::string, 4> v;
681    const std::string s = "A quite long string to ensure heap.";
682    std_v.push_back(s);
683    v.push_back(s);
684    for (int i = 0; i < 20; ++i) {
685      EXPECT_THAT(v, ElementsAreArray(std_v));
686      v.push_back(v.back());
687      std_v.push_back(std_v.back());
688    }
689    EXPECT_THAT(v, ElementsAreArray(std_v));
690  }
691  TEST(StringVec, SelfRefPushBackWithMove) {
692    std::vector<std::string> std_v;
693    absl::InlinedVector<std::string, 4> v;
694    const std::string s = "A quite long string to ensure heap.";
695    std_v.push_back(s);
696    v.push_back(s);
697    for (int i = 0; i < 20; ++i) {
698      EXPECT_EQ(v.back(), std_v.back());
699      v.push_back(std::move(v.back()));
700      std_v.push_back(std::move(std_v.back()));
701    }
702    EXPECT_EQ(v.back(), std_v.back());
703  }
704  TEST(StringVec, SelfMove) {
705    const std::string s = "A quite long string to ensure heap.";
706    for (int len = 0; len < 20; len++) {
707      SCOPED_TRACE(len);
708      absl::InlinedVector<std::string, 8> v;
709      for (int i = 0; i < len; ++i) {
710        SCOPED_TRACE(i);
711        v.push_back(s);
712      }
713      v = std::move(*(&v));
714      std::vector<std::string> copy(v.begin(), v.end());
715    }
716  }
717  TEST(IntVec, Swap) {
718    for (size_t l1 = 0; l1 < 20; l1++) {
719      SCOPED_TRACE(l1);
720      for (size_t l2 = 0; l2 < 20; l2++) {
721        SCOPED_TRACE(l2);
722        IntVec a = Fill(l1, 0);
723        IntVec b = Fill(l2, 100);
724        {
725          using std::swap;
726          swap(a, b);
727        }
728        EXPECT_EQ(l1, b.size());
729        EXPECT_EQ(l2, a.size());
730        for (size_t i = 0; i < l1; i++) {
731          SCOPED_TRACE(i);
732          EXPECT_EQ(static_cast<int>(i), b[i]);
733        }
734        for (size_t i = 0; i < l2; i++) {
735          SCOPED_TRACE(i);
736          EXPECT_EQ(100 + static_cast<int>(i), a[i]);
737        }
738      }
739    }
740  }
741  TYPED_TEST_P(InstanceTest, Swap) {
742    using Instance = TypeParam;
743    using InstanceVec = absl::InlinedVector<Instance, 8>;
744    for (size_t l1 = 0; l1 < 20; l1++) {
745      SCOPED_TRACE(l1);
746      for (size_t l2 = 0; l2 < 20; l2++) {
747        SCOPED_TRACE(l2);
748        InstanceTracker tracker;
749        InstanceVec a, b;
750        const size_t inlined_capacity = a.capacity();
751        auto min_len = std::min(l1, l2);
752        auto max_len = std::max(l1, l2);
753        for (size_t i = 0; i < l1; i++)
754          a.push_back(Instance(static_cast<int>(i)));
755        for (size_t i = 0; i < l2; i++)
756          b.push_back(Instance(100 + static_cast<int>(i)));
757        EXPECT_EQ(tracker.instances(), static_cast<int>(l1 + l2));
758        tracker.ResetCopiesMovesSwaps();
759        {
760          using std::swap;
761          swap(a, b);
762        }
763        EXPECT_EQ(tracker.instances(), static_cast<int>(l1 + l2));
764        if (a.size() > inlined_capacity && b.size() > inlined_capacity) {
765          EXPECT_EQ(tracker.swaps(), 0);  
766          EXPECT_EQ(tracker.moves(), 0);
767        } else if (a.size() <= inlined_capacity && b.size() <= inlined_capacity) {
768          EXPECT_EQ(tracker.swaps(), static_cast<int>(min_len));
769          EXPECT_EQ((tracker.moves() ? tracker.moves() : tracker.copies()),
770                    static_cast<int>(max_len - min_len));
771        } else {
772          EXPECT_EQ(tracker.swaps(), 0);
773          EXPECT_EQ((tracker.moves() ? tracker.moves() : tracker.copies()),
774                    static_cast<int>(min_len));
775        }
776        EXPECT_EQ(l1, b.size());
777        EXPECT_EQ(l2, a.size());
778        for (size_t i = 0; i < l1; i++) {
779          EXPECT_EQ(static_cast<int>(i), b[i].value());
780        }
781        for (size_t i = 0; i < l2; i++) {
782          EXPECT_EQ(100 + static_cast<int>(i), a[i].value());
783        }
784      }
785    }
786  }
787  TEST(IntVec, EqualAndNotEqual) {
788    IntVec a, b;
789    EXPECT_TRUE(a == b);
790    EXPECT_FALSE(a != b);
791    a.push_back(3);
792    EXPECT_FALSE(a == b);
793    EXPECT_TRUE(a != b);
794    b.push_back(3);
795    EXPECT_TRUE(a == b);
796    EXPECT_FALSE(a != b);
797    b.push_back(7);
798    EXPECT_FALSE(a == b);
799    EXPECT_TRUE(a != b);
800    a.push_back(6);
801    EXPECT_FALSE(a == b);
802    EXPECT_TRUE(a != b);
803    a.clear();
804    b.clear();
805    for (size_t i = 0; i < 100; i++) {
806      a.push_back(static_cast<int>(i));
807      b.push_back(static_cast<int>(i));
808      EXPECT_TRUE(a == b);
809      EXPECT_FALSE(a != b);
810      b[i] = b[i] + 1;
811      EXPECT_FALSE(a == b);
812      EXPECT_TRUE(a != b);
813      b[i] = b[i] - 1;  
814      EXPECT_TRUE(a == b);
815      EXPECT_FALSE(a != b);
816    }
817  }
818  TEST(IntVec, RelationalOps) {
819    IntVec a, b;
820    EXPECT_FALSE(a < b);
821    EXPECT_FALSE(b < a);
822    EXPECT_FALSE(a > b);
823    EXPECT_FALSE(b > a);
824    EXPECT_TRUE(a <= b);
825    EXPECT_TRUE(b <= a);
826    EXPECT_TRUE(a >= b);
827    EXPECT_TRUE(b >= a);
828    b.push_back(3);
829    EXPECT_TRUE(a < b);
830    EXPECT_FALSE(b < a);
831    EXPECT_FALSE(a > b);
832    EXPECT_TRUE(b > a);
833    EXPECT_TRUE(a <= b);
834    EXPECT_FALSE(b <= a);
835    EXPECT_FALSE(a >= b);
836    EXPECT_TRUE(b >= a);
837  }
838  TYPED_TEST_P(InstanceTest, CountConstructorsDestructors) {
839    using Instance = TypeParam;
840    using InstanceVec = absl::InlinedVector<Instance, 8>;
841    InstanceTracker tracker;
842    for (size_t len = 0; len < 20; len++) {
843      SCOPED_TRACE(len);
844      tracker.ResetCopiesMovesSwaps();
845      InstanceVec v;
846      const size_t inlined_capacity = v.capacity();
847      for (size_t i = 0; i < len; i++) {
848        v.push_back(Instance(static_cast<int>(i)));
849      }
850      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
851      EXPECT_GE(tracker.copies() + tracker.moves(),
852                static_cast<int>(len));  
853      tracker.ResetCopiesMovesSwaps();
854      tracker.ResetCopiesMovesSwaps();
855      v.resize(len + 10, Instance(100));
856      EXPECT_EQ(tracker.instances(), static_cast<int>(len) + 10);
857      if (len <= inlined_capacity && len + 10 > inlined_capacity) {
858        EXPECT_EQ(tracker.copies() + tracker.moves(), 10 + static_cast<int>(len));
859      } else {
860        EXPECT_GE(tracker.copies() + tracker.moves(),
861                  10);  
862      }
863      tracker.ResetCopiesMovesSwaps();
864      v.resize(len, Instance(100));
865      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
866      EXPECT_EQ(tracker.copies(), 0);
867      EXPECT_EQ(tracker.moves(), 0);
868      SCOPED_TRACE("reserve");
869      v.reserve(len + 1000);
870      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
871      EXPECT_EQ(tracker.copies() + tracker.moves(), static_cast<int>(len));
872      if (len > 0) {
873        tracker.ResetCopiesMovesSwaps();
874        v.pop_back();
875        EXPECT_EQ(tracker.instances(), static_cast<int>(len) - 1);
876        EXPECT_EQ(tracker.copies(), 0);
877        EXPECT_EQ(tracker.moves(), 0);
878        if (!v.empty()) {
879          tracker.ResetCopiesMovesSwaps();
880          v.erase(v.begin());
881          EXPECT_EQ(tracker.instances(), static_cast<int>(len) - 2);
882          EXPECT_EQ(tracker.copies() + tracker.moves(),
883                    static_cast<int>(len) - 2);
884        }
885      }
886      tracker.ResetCopiesMovesSwaps();
887      int instances_before_empty_erase = tracker.instances();
888      v.erase(v.begin(), v.begin());
889      EXPECT_EQ(tracker.instances(), instances_before_empty_erase);
890      EXPECT_EQ(tracker.copies() + tracker.moves(), 0);
891    }
892  }
893  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnCopyConstruction) {
894    using Instance = TypeParam;
895    using InstanceVec = absl::InlinedVector<Instance, 8>;
896    InstanceTracker tracker;
897    for (int len = 0; len < 20; len++) {
898      SCOPED_TRACE(len);
899      tracker.ResetCopiesMovesSwaps();
900      InstanceVec v;
901      for (int i = 0; i < len; i++) {
902        v.push_back(Instance(i));
903      }
904      EXPECT_EQ(tracker.instances(), len);
905      EXPECT_GE(tracker.copies() + tracker.moves(),
906                len);  
907      tracker.ResetCopiesMovesSwaps();
908      {  
909        InstanceVec v_copy(v);
910        EXPECT_EQ(tracker.instances(), len + len);
911        EXPECT_EQ(tracker.copies(), len);
912        EXPECT_EQ(tracker.moves(), 0);
913      }
914      EXPECT_EQ(tracker.instances(), len);
915    }
916  }
917  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnMoveConstruction) {
918    using Instance = TypeParam;
919    using InstanceVec = absl::InlinedVector<Instance, 8>;
920    InstanceTracker tracker;
921    for (int len = 0; len < 20; len++) {
922      SCOPED_TRACE(len);
923      tracker.ResetCopiesMovesSwaps();
924      InstanceVec v;
925      const size_t inlined_capacity = v.capacity();
926      for (int i = 0; i < len; i++) {
927        v.push_back(Instance(i));
928      }
929      EXPECT_EQ(tracker.instances(), len);
930      EXPECT_GE(tracker.copies() + tracker.moves(),
931                len);  
932      tracker.ResetCopiesMovesSwaps();
933      {
934        InstanceVec v_copy(std::move(v));
935        if (static_cast<size_t>(len) > inlined_capacity) {
936          EXPECT_EQ(tracker.instances(), len);
937          EXPECT_EQ(tracker.live_instances(), len);
938          EXPECT_EQ(v.size(), 0u);  
939          EXPECT_EQ(tracker.copies(), 0);
940          EXPECT_EQ(tracker.moves(), 0);
941        } else {
942          EXPECT_EQ(tracker.instances(), len + len);
943          if (Instance::supports_move()) {
944            EXPECT_EQ(tracker.live_instances(), len);
945            EXPECT_EQ(tracker.copies(), 0);
946            EXPECT_EQ(tracker.moves(), len);
947          } else {
948            EXPECT_EQ(tracker.live_instances(), len + len);
949            EXPECT_EQ(tracker.copies(), len);
950            EXPECT_EQ(tracker.moves(), 0);
951          }
952        }
953        EXPECT_EQ(tracker.swaps(), 0);
954      }
955    }
956  }
957  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnAssignment) {
958    using Instance = TypeParam;
959    using InstanceVec = absl::InlinedVector<Instance, 8>;
960    InstanceTracker tracker;
961    for (int len = 0; len < 20; len++) {
962      SCOPED_TRACE(len);
963      for (int longorshort = 0; longorshort <= 1; ++longorshort) {
964        SCOPED_TRACE(longorshort);
965        tracker.ResetCopiesMovesSwaps();
966        InstanceVec longer, shorter;
967        for (int i = 0; i < len; i++) {
968          longer.push_back(Instance(i));
969          shorter.push_back(Instance(i));
970        }
971        longer.push_back(Instance(len));
972        EXPECT_EQ(tracker.instances(), len + len + 1);
973        EXPECT_GE(tracker.copies() + tracker.moves(),
974                  len + len + 1);  
975        tracker.ResetCopiesMovesSwaps();
976        if (longorshort) {
977          shorter = longer;
978          EXPECT_EQ(tracker.instances(), (len + 1) + (len + 1));
979          EXPECT_GE(tracker.copies() + tracker.moves(),
980                    len + 1);  
981        } else {
982          longer = shorter;
983          EXPECT_EQ(tracker.instances(), len + len);
984          EXPECT_EQ(tracker.copies() + tracker.moves(), len);
985        }
986      }
987    }
988  }
989  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnMoveAssignment) {
990    using Instance = TypeParam;
991    using InstanceVec = absl::InlinedVector<Instance, 8>;
992    InstanceTracker tracker;
993    for (int len = 0; len < 20; len++) {
994      SCOPED_TRACE(len);
995      for (int longorshort = 0; longorshort <= 1; ++longorshort) {
996        SCOPED_TRACE(longorshort);
997        tracker.ResetCopiesMovesSwaps();
998        InstanceVec longer, shorter;
999        const size_t inlined_capacity = longer.capacity();
1000        for (int i = 0; i < len; i++) {
1001          longer.push_back(Instance(i));
1002          shorter.push_back(Instance(i));
1003        }
1004        longer.push_back(Instance(len));
1005        EXPECT_EQ(tracker.instances(), len + len + 1);
1006        EXPECT_GE(tracker.copies() + tracker.moves(),
1007                  len + len + 1);  
1008        tracker.ResetCopiesMovesSwaps();
1009        int src_len;
1010        if (longorshort) {
1011          src_len = len + 1;
1012          shorter = std::move(longer);
1013        } else {
1014          src_len = len;
1015          longer = std::move(shorter);
1016        }
1017        if (static_cast<size_t>(src_len) > inlined_capacity) {
1018          EXPECT_EQ(tracker.instances(), src_len);
1019          EXPECT_EQ(tracker.live_instances(), src_len);
1020          EXPECT_EQ(tracker.copies(), 0);
1021          EXPECT_EQ(tracker.moves(), 0);
1022        } else {
1023          EXPECT_EQ(tracker.instances(), src_len + src_len);
1024          if (Instance::supports_move()) {
1025            EXPECT_EQ(tracker.copies(), 0);
1026            EXPECT_EQ(tracker.moves(), src_len);
1027            EXPECT_EQ(tracker.live_instances(), src_len);
1028          } else {
1029            EXPECT_EQ(tracker.copies(), src_len);
1030            EXPECT_EQ(tracker.moves(), 0);
1031            EXPECT_EQ(tracker.live_instances(), src_len + src_len);
1032          }
1033        }
1034        EXPECT_EQ(tracker.swaps(), 0);
1035      }
1036    }
1037  }
1038  TEST(CountElemAssign, SimpleTypeWithInlineBacking) {
1039    const size_t inlined_capacity = absl::InlinedVector<int, 2>().capacity();
1040    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1041      SCOPED_TRACE(original_size);
1042      std::vector<int> original_contents(original_size, 12345);
1043      absl::InlinedVector<int, 2> v(original_contents.begin(),
1044                                    original_contents.end());
1045      v.assign(2, 123);
1046      EXPECT_THAT(v, AllOf(SizeIs(2u), ElementsAre(123, 123)));
1047      if (original_size <= inlined_capacity) {
1048        EXPECT_EQ(v.capacity(), inlined_capacity);
1049      }
1050    }
1051  }
1052  TEST(CountElemAssign, SimpleTypeWithAllocation) {
1053    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1054      SCOPED_TRACE(original_size);
1055      std::vector<int> original_contents(original_size, 12345);
1056      absl::InlinedVector<int, 2> v(original_contents.begin(),
1057                                    original_contents.end());
1058      v.assign(3, 123);
1059      EXPECT_THAT(v, AllOf(SizeIs(3u), ElementsAre(123, 123, 123)));
1060      EXPECT_LE(v.size(), v.capacity());
1061    }
1062  }
1063  TYPED_TEST_P(InstanceTest, CountElemAssignInlineBacking) {
1064    using Instance = TypeParam;
1065    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1066      SCOPED_TRACE(original_size);
1067      std::vector<Instance> original_contents(original_size, Instance(12345));
1068      absl::InlinedVector<Instance, 2> v(original_contents.begin(),
1069                                         original_contents.end());
1070      v.assign(2, Instance(123));
1071      EXPECT_THAT(v, AllOf(SizeIs(2u), ElementsAre(ValueIs(123), ValueIs(123))));
1072      if (original_size <= 2) {
1073        EXPECT_EQ(2u, v.capacity());
1074      }
1075    }
1076  }
1077  template <typename Instance>
1078  void InstanceCountElemAssignWithAllocationTest() {
1079    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1080      SCOPED_TRACE(original_size);
1081      std::vector<Instance> original_contents(original_size, Instance(12345));
1082      absl::InlinedVector<Instance, 2> v(original_contents.begin(),
1083                                         original_contents.end());
1084      v.assign(3, Instance(123));
1085      EXPECT_THAT(v, AllOf(SizeIs(3u), ElementsAre(ValueIs(123), ValueIs(123),
1086                                                   ValueIs(123))));
1087      EXPECT_LE(v.size(), v.capacity());
1088    }
1089  }
1090  TEST(CountElemAssign, WithAllocationCopyableInstance) {
1091    InstanceCountElemAssignWithAllocationTest<CopyableOnlyInstance>();
1092  }
1093  TEST(CountElemAssign, WithAllocationCopyableMovableInstance) {
1094    InstanceCountElemAssignWithAllocationTest<CopyableMovableInstance>();
1095  }
1096  TEST(RangedConstructor, SimpleType) {
1097    std::vector<int> source_v = {4, 5, 6};
1098    absl::InlinedVector<int, 4> v(source_v.begin(), source_v.end());
1099    EXPECT_EQ(3u, v.size());
1100    EXPECT_EQ(4u,
1101              v.capacity());  
1102    EXPECT_EQ(4, v[0]);
1103    EXPECT_EQ(5, v[1]);
1104    EXPECT_EQ(6, v[2]);
1105    absl::InlinedVector<int, 2> realloc_v(source_v.begin(), source_v.end());
1106    EXPECT_EQ(3u, realloc_v.size());
1107    EXPECT_LT(2u, realloc_v.capacity());
1108    EXPECT_EQ(4, realloc_v[0]);
1109    EXPECT_EQ(5, realloc_v[1]);
1110    EXPECT_EQ(6, realloc_v[2]);
1111  }
1112  template <typename Instance, typename SourceContainer, int inlined_capacity>
1113  void InstanceRangedConstructorTestForContainer() {
1114    InstanceTracker tracker;
1115    SourceContainer source_v = {Instance(0), Instance(1)};
1116    tracker.ResetCopiesMovesSwaps();
1117    absl::InlinedVector<Instance, inlined_capacity> v(source_v.begin(),
1118                                                      source_v.end());
1119    EXPECT_EQ(2u, v.size());
1120    EXPECT_LT(1u, v.capacity());
1121    EXPECT_EQ(0, v[0].value());
1122    EXPECT_EQ(1, v[1].value());
1123    EXPECT_EQ(tracker.copies(), 2);
1124    EXPECT_EQ(tracker.moves(), 0);
1125  }
1126  template <typename Instance, int inlined_capacity>
1127  void InstanceRangedConstructorTestWithCapacity() {
1128    {
1129      SCOPED_TRACE("std::list");
1130      InstanceRangedConstructorTestForContainer<Instance, std::list<Instance>,
1131                                                inlined_capacity>();
1132      {
1133        SCOPED_TRACE("const std::list");
1134        InstanceRangedConstructorTestForContainer<
1135            Instance, const std::list<Instance>, inlined_capacity>();
1136      }
1137      {
1138        SCOPED_TRACE("std::vector");
1139        InstanceRangedConstructorTestForContainer<Instance, std::vector<Instance>,
1140                                                  inlined_capacity>();
1141      }
1142      {
1143        SCOPED_TRACE("const std::vector");
1144        InstanceRangedConstructorTestForContainer<
1145            Instance, const std::vector<Instance>, inlined_capacity>();
1146      }
1147    }
1148  }
1149  TYPED_TEST_P(InstanceTest, RangedConstructor) {
1150    using Instance = TypeParam;
1151    SCOPED_TRACE("capacity=1");
1152    InstanceRangedConstructorTestWithCapacity<Instance, 1>();
1153    SCOPED_TRACE("capacity=2");
1154    InstanceRangedConstructorTestWithCapacity<Instance, 2>();
1155  }
1156  TEST(RangedConstructor, ElementsAreConstructed) {
1157    std::vector<std::string> source_v = {"cat", "dog"};
1158    absl::InlinedVector<std::string, 1> v(source_v.begin(), source_v.end());
1159    EXPECT_EQ("cat", v[0]);
1160    EXPECT_EQ("dog", v[1]);
1161  }
1162  TEST(RangedAssign, SimpleType) {
1163    const size_t inlined_capacity = absl::InlinedVector<int, 3>().capacity();
1164    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1165      SCOPED_TRACE(original_size);
1166      std::vector<int> original_contents(original_size, 12345);
1167      for (size_t target_size = 0; target_size <= 5; ++target_size) {
1168        SCOPED_TRACE(target_size);
1169        std::vector<int> new_contents;
1170        for (size_t i = 0; i < target_size; ++i) {
1171          new_contents.push_back(static_cast<int>(i + 3));
1172        }
1173        absl::InlinedVector<int, 3> v(original_contents.begin(),
1174                                      original_contents.end());
1175        v.assign(new_contents.begin(), new_contents.end());
1176        EXPECT_EQ(new_contents.size(), v.size());
1177        EXPECT_LE(new_contents.size(), v.capacity());
1178        if (target_size <= inlined_capacity &&
1179            original_size <= inlined_capacity) {
1180          EXPECT_EQ(v.capacity(), inlined_capacity);
1181        }
1182        EXPECT_THAT(v, ElementsAreArray(new_contents));
1183      }
1184    }
1185  }
1186  template <typename Instance>
1187  static bool InstanceValuesEqual(const Instance& lhs, const Instance& rhs) {
1188    return lhs.value() == rhs.value();
1189  }
1190  template <typename Instance, typename SourceContainer>
1191  void InstanceRangedAssignTestForContainer() {
1192    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1193      SCOPED_TRACE(original_size);
1194      std::vector<Instance> original_contents(original_size, Instance(12345));
1195      for (size_t target_size = 0; target_size <= 5; ++target_size) {
1196        SCOPED_TRACE(target_size);
1197        std::vector<Instance> new_contents_in;
1198        for (size_t i = 0; i < target_size; ++i) {
1199          new_contents_in.push_back(Instance(static_cast<int>(i) + 3));
1200        }
1201        SourceContainer new_contents(new_contents_in.begin(),
1202                                     new_contents_in.end());
1203        absl::InlinedVector<Instance, 3> v(original_contents.begin(),
1204                                           original_contents.end());
1205        v.assign(new_contents.begin(), new_contents.end());
1206        EXPECT_EQ(new_contents.size(), v.size());
1207        EXPECT_LE(new_contents.size(), v.capacity());
1208        if (target_size <= 3 && original_size <= 3) {
1209          EXPECT_EQ(3u, v.capacity());
1210        }
1211        EXPECT_TRUE(std::equal(v.begin(), v.end(), new_contents.begin(),
1212                               InstanceValuesEqual<Instance>));
1213      }
1214    }
1215  }
1216  TYPED_TEST_P(InstanceTest, RangedAssign) {
1217    using Instance = TypeParam;
1218    SCOPED_TRACE("std::list");
1219    InstanceRangedAssignTestForContainer<Instance, std::list<Instance>>();
1220    SCOPED_TRACE("const std::list");
1221    InstanceRangedAssignTestForContainer<Instance, const std::list<Instance>>();
1222    SCOPED_TRACE("std::vector");
1223    InstanceRangedAssignTestForContainer<Instance, std::vector<Instance>>();
1224    SCOPED_TRACE("const std::vector");
1225    InstanceRangedAssignTestForContainer<Instance, const std::vector<Instance>>();
1226  }
1227  TEST(InitializerListConstructor, SimpleTypeWithInlineBacking) {
1228    EXPECT_THAT((absl::InlinedVector<int, 4>{4, 5, 6}),
1229                AllOf(SizeIs(3u), CapacityIs(4u), ElementsAre(4, 5, 6)));
1230  }
1231  TEST(InitializerListConstructor, SimpleTypeWithReallocationRequired) {
1232    EXPECT_THAT((absl::InlinedVector<int, 2>{4, 5, 6}),
1233                AllOf(SizeIs(3u), CapacityIs(Gt(2u)), ElementsAre(4, 5, 6)));
1234  }
1235  TEST(InitializerListConstructor, DisparateTypesInList) {
1236    EXPECT_THAT((absl::InlinedVector<int, 2>{-7, 8ULL}), ElementsAre(-7, 8));
1237    EXPECT_THAT((absl::InlinedVector<std::string, 2>{"foo", std::string("bar")}),
1238                ElementsAre("foo", "bar"));
1239  }
1240  TEST(InitializerListConstructor, ComplexTypeWithInlineBacking) {
1241    const size_t inlined_capacity =
1242        absl::InlinedVector<CopyableMovableInstance, 1>().capacity();
1243    EXPECT_THAT(
1244        (absl::InlinedVector<CopyableMovableInstance, 1>{
1245            CopyableMovableInstance(0)}),
1246        AllOf(SizeIs(1u), CapacityIs(inlined_capacity), ElementsAre(ValueIs(0))));
1247  }
1248  TEST(InitializerListConstructor, ComplexTypeWithReallocationRequired) {
1249    EXPECT_THAT((absl::InlinedVector<CopyableMovableInstance, 1>{
1250                    CopyableMovableInstance(0), CopyableMovableInstance(1)}),
1251                AllOf(SizeIs(2u), CapacityIs(Gt(1u)),
1252                      ElementsAre(ValueIs(0), ValueIs(1))));
1253  }
1254  TEST(InitializerListAssign, SimpleTypeFitsInlineBacking) {
1255    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1256      SCOPED_TRACE(original_size);
1257      absl::InlinedVector<int, 2> v1(original_size, 12345);
1258      const size_t original_capacity_v1 = v1.capacity();
1259      v1.assign({3});
1260      EXPECT_THAT(v1, AllOf(SizeIs(1u), CapacityIs(original_capacity_v1),
1261                            ElementsAre(3)));
1262      absl::InlinedVector<int, 2> v2(original_size, 12345);
1263      const size_t original_capacity_v2 = v2.capacity();
1264      v2 = {3};
1265      EXPECT_THAT(v2, AllOf(SizeIs(1u), CapacityIs(original_capacity_v2),
1266                            ElementsAre(3)));
1267    }
1268  }
1269  TEST(InitializerListAssign, SimpleTypeDoesNotFitInlineBacking) {
1270    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1271      SCOPED_TRACE(original_size);
1272      absl::InlinedVector<int, 2> v1(original_size, 12345);
1273      v1.assign({3, 4, 5});
1274      EXPECT_THAT(v1, AllOf(SizeIs(3u), ElementsAre(3, 4, 5)));
1275      EXPECT_LE(3u, v1.capacity());
1276      absl::InlinedVector<int, 2> v2(original_size, 12345);
1277      v2 = {3, 4, 5};
1278      EXPECT_THAT(v2, AllOf(SizeIs(3u), ElementsAre(3, 4, 5)));
1279      EXPECT_LE(3u, v2.capacity());
1280    }
1281  }
1282  TEST(InitializerListAssign, DisparateTypesInList) {
1283    absl::InlinedVector<int, 2> v_int1;
1284    v_int1.assign({-7, 8ULL});
1285    EXPECT_THAT(v_int1, ElementsAre(-7, 8));
1286    absl::InlinedVector<int, 2> v_int2;
1287    v_int2 = {-7, 8ULL};
1288    EXPECT_THAT(v_int2, ElementsAre(-7, 8));
1289    absl::InlinedVector<std::string, 2> v_string1;
1290    v_string1.assign({"foo", std::string("bar")});
1291    EXPECT_THAT(v_string1, ElementsAre("foo", "bar"));
1292    absl::InlinedVector<std::string, 2> v_string2;
1293    v_string2 = {"foo", std::string("bar")};
1294    EXPECT_THAT(v_string2, ElementsAre("foo", "bar"));
1295  }
1296  TYPED_TEST_P(InstanceTest, InitializerListAssign) {
1297    using Instance = TypeParam;
1298    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1299      SCOPED_TRACE(original_size);
1300      absl::InlinedVector<Instance, 2> v(original_size, Instance(12345));
1301      const size_t original_capacity = v.capacity();
1302      v.assign({Instance(3)});
1303      EXPECT_THAT(v, AllOf(SizeIs(1u), CapacityIs(original_capacity),
1304                           ElementsAre(ValueIs(3))));
1305    }
1306    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1307      SCOPED_TRACE(original_size);
1308      absl::InlinedVector<Instance, 2> v(original_size, Instance(12345));
1309      v.assign({Instance(3), Instance(4), Instance(5)});
1310      EXPECT_THAT(
1311          v, AllOf(SizeIs(3u), ElementsAre(ValueIs(3), ValueIs(4), ValueIs(5))));
1312      EXPECT_LE(3u, v.capacity());
1313    }
1314  }
1315  REGISTER_TYPED_TEST_SUITE_P(InstanceTest, Swap, CountConstructorsDestructors,
1316                              CountConstructorsDestructorsOnCopyConstruction,
1317                              CountConstructorsDestructorsOnMoveConstruction,
1318                              CountConstructorsDestructorsOnAssignment,
1319                              CountConstructorsDestructorsOnMoveAssignment,
1320                              CountElemAssignInlineBacking, RangedConstructor,
1321                              RangedAssign, InitializerListAssign);
1322  using InstanceTypes =
1323      ::testing::Types<CopyableOnlyInstance, CopyableMovableInstance>;
1324  INSTANTIATE_TYPED_TEST_SUITE_P(InstanceTestOnTypes, InstanceTest,
1325                                 InstanceTypes);
1326  TEST(DynamicVec, DynamicVecCompiles) {
1327    DynamicVec v;
1328    (void)v;
1329  }
1330  TEST(AllocatorSupportTest, Constructors) {
1331    using MyAlloc = CountingAllocator<int>;
1332    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1333    const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
1334    int64_t allocated = 0;
1335    MyAlloc alloc(&allocated);
1336    { AllocVec ABSL_ATTRIBUTE_UNUSED v; }
1337    { AllocVec ABSL_ATTRIBUTE_UNUSED v(alloc); }
1338    { AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + ABSL_ARRAYSIZE(ia), alloc); }
1339    { AllocVec ABSL_ATTRIBUTE_UNUSED v({1, 2, 3}, alloc); }
1340    AllocVec v2;
1341    { AllocVec ABSL_ATTRIBUTE_UNUSED v(v2, alloc); }
1342    { AllocVec ABSL_ATTRIBUTE_UNUSED v(std::move(v2), alloc); }
1343  }
1344  TEST(AllocatorSupportTest, CountAllocations) {
1345    using MyAlloc = CountingAllocator<int>;
1346    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1347    const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
1348    int64_t allocated = 0;
1349    MyAlloc alloc(&allocated);
1350    {
1351      AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + 4, alloc);
1352      EXPECT_THAT(allocated, Eq(0));
1353    }
1354    EXPECT_THAT(allocated, Eq(0));
1355    {
1356      AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + ABSL_ARRAYSIZE(ia), alloc);
1357      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(v.size() * sizeof(int))));
1358    }
1359    EXPECT_THAT(allocated, Eq(0));
1360    {
1361      AllocVec v(4, 1, alloc);
1362      EXPECT_THAT(allocated, Eq(0));
1363      int64_t allocated2 = 0;
1364      MyAlloc alloc2(&allocated2);
1365      AllocVec v2(v, alloc2);
1366      EXPECT_THAT(allocated2, Eq(0));
1367      int64_t allocated3 = 0;
1368      MyAlloc alloc3(&allocated3);
1369      AllocVec v3(std::move(v), alloc3);
1370      EXPECT_THAT(allocated3, Eq(0));
1371    }
1372    EXPECT_THAT(allocated, 0);
1373    {
1374      AllocVec v(8, 2, alloc);
1375      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(v.size() * sizeof(int))));
1376      int64_t allocated2 = 0;
1377      MyAlloc alloc2(&allocated2);
1378      AllocVec v2(v, alloc2);
1379      EXPECT_THAT(allocated2, Eq(static_cast<int64_t>(v2.size() * sizeof(int))));
1380      int64_t allocated3 = 0;
1381      MyAlloc alloc3(&allocated3);
1382      AllocVec v3(std::move(v), alloc3);
1383      EXPECT_THAT(allocated3, Eq(static_cast<int64_t>(v3.size() * sizeof(int))));
1384    }
1385    EXPECT_EQ(allocated, 0);
1386    {
1387      AllocVec v(8, 2, alloc);
1388      EXPECT_EQ(allocated, static_cast<int64_t>(8 * sizeof(int)));
1389      v.resize(5);
1390      EXPECT_EQ(allocated, static_cast<int64_t>(8 * sizeof(int)));
1391      v.shrink_to_fit();
1392      EXPECT_EQ(allocated, static_cast<int64_t>(5 * sizeof(int)));
1393      v.resize(4);
1394      EXPECT_EQ(allocated, static_cast<int64_t>(5 * sizeof(int)));
1395      v.shrink_to_fit();
1396      EXPECT_EQ(allocated, 0);
1397    }
1398  }
1399  TEST(AllocatorSupportTest, SwapBothAllocated) {
1400    using MyAlloc = CountingAllocator<int>;
1401    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1402    int64_t allocated1 = 0;
1403    int64_t allocated2 = 0;
1404    {
1405      const int ia1[] = {0, 1, 2, 3, 4, 5, 6, 7};
1406      const int ia2[] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
1407      MyAlloc a1(&allocated1);
1408      MyAlloc a2(&allocated2);
1409      AllocVec v1(ia1, ia1 + ABSL_ARRAYSIZE(ia1), a1);
1410      AllocVec v2(ia2, ia2 + ABSL_ARRAYSIZE(ia2), a2);
1411      EXPECT_LT(v1.capacity(), v2.capacity());
1412      EXPECT_THAT(allocated1,
1413                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1414      EXPECT_THAT(allocated2,
1415                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1416      v1.swap(v2);
1417      EXPECT_THAT(v1, ElementsAreArray(ia2));
1418      EXPECT_THAT(v2, ElementsAreArray(ia1));
1419      EXPECT_THAT(allocated1,
1420                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1421      EXPECT_THAT(allocated2,
1422                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1423    }
1424    EXPECT_THAT(allocated1, 0);
1425    EXPECT_THAT(allocated2, 0);
1426  }
1427  TEST(AllocatorSupportTest, SwapOneAllocated) {
1428    using MyAlloc = CountingAllocator<int>;
1429    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1430    int64_t allocated1 = 0;
1431    int64_t allocated2 = 0;
1432    {
1433      const int ia1[] = {0, 1, 2, 3, 4, 5, 6, 7};
1434      const int ia2[] = {0, 1, 2, 3};
1435      MyAlloc a1(&allocated1);
1436      MyAlloc a2(&allocated2);
1437      AllocVec v1(ia1, ia1 + ABSL_ARRAYSIZE(ia1), a1);
1438      AllocVec v2(ia2, ia2 + ABSL_ARRAYSIZE(ia2), a2);
1439      EXPECT_THAT(allocated1,
1440                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1441      EXPECT_THAT(allocated2, Eq(0));
1442      v1.swap(v2);
1443      EXPECT_THAT(v1, ElementsAreArray(ia2));
1444      EXPECT_THAT(v2, ElementsAreArray(ia1));
1445      EXPECT_THAT(allocated1,
1446                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1447      EXPECT_THAT(allocated2, Eq(0));
1448      EXPECT_TRUE(v2.get_allocator() == a1);
1449      EXPECT_TRUE(v1.get_allocator() == a2);
1450    }
1451    EXPECT_THAT(allocated1, 0);
1452    EXPECT_THAT(allocated2, 0);
1453  }
1454  TEST(AllocatorSupportTest, ScopedAllocatorWorksInlined) {
1455    using StdVector = std::vector<int, CountingAllocator<int>>;
1456    using Alloc = CountingAllocator<StdVector>;
1457    using ScopedAlloc = std::scoped_allocator_adaptor<Alloc>;
1458    using AllocVec = absl::InlinedVector<StdVector, 1, ScopedAlloc>;
1459    int64_t total_allocated_byte_count = 0;
1460    AllocVec inlined_case(ScopedAlloc(Alloc(+&total_allocated_byte_count)));
1461    inlined_case.emplace_back();
1462    int64_t absl_responsible_for_count = total_allocated_byte_count;
1463  #if !defined(_MSC_VER)
1464    EXPECT_EQ(absl_responsible_for_count, 0);
1465  #endif  
1466    inlined_case[0].emplace_back();
1467    EXPECT_GT(total_allocated_byte_count, absl_responsible_for_count);
1468    inlined_case.clear();
1469    inlined_case.shrink_to_fit();
1470    EXPECT_EQ(total_allocated_byte_count, 0);
1471  }
1472  TEST(AllocatorSupportTest, ScopedAllocatorWorksAllocated) {
1473    using StdVector = std::vector<int, CountingAllocator<int>>;
1474    using Alloc = CountingAllocator<StdVector>;
1475    using ScopedAlloc = std::scoped_allocator_adaptor<Alloc>;
1476    using AllocVec = absl::InlinedVector<StdVector, 1, ScopedAlloc>;
1477    int64_t total_allocated_byte_count = 0;
1478    AllocVec allocated_case(ScopedAlloc(Alloc(+&total_allocated_byte_count)));
1479    allocated_case.emplace_back();
1480    allocated_case.emplace_back();
1481    int64_t absl_responsible_for_count = total_allocated_byte_count;
1482    EXPECT_GT(absl_responsible_for_count, 0);
1483    allocated_case[1].emplace_back();
1484    EXPECT_GT(total_allocated_byte_count, absl_responsible_for_count);
1485    allocated_case.clear();
1486    allocated_case.shrink_to_fit();
1487    EXPECT_EQ(total_allocated_byte_count, 0);
1488  }
1489  TEST(AllocatorSupportTest, SizeAllocConstructor) {
1490    constexpr size_t inlined_size = 4;
1491    using Alloc = CountingAllocator<int>;
1492    using AllocVec = absl::InlinedVector<int, inlined_size, Alloc>;
1493    {
1494      auto len = inlined_size / 2;
1495      int64_t allocated = 0;
1496      auto v = AllocVec(len, Alloc(&allocated));
1497      EXPECT_THAT(allocated, Eq(0));
1498      EXPECT_THAT(v, AllOf(SizeIs(len), Each(0)));
1499    }
1500    {
1501      auto len = inlined_size * 2;
1502      int64_t allocated = 0;
1503      auto v = AllocVec(len, Alloc(&allocated));
1504      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(len * sizeof(int))));
1505      EXPECT_THAT(v, AllOf(SizeIs(len), Each(0)));
1506    }
1507  }
1508  TEST(InlinedVectorTest, MinimumAllocatorCompilesUsingTraits) {
1509    using T = int;
1510    using A = std::allocator<T>;
1511    using ATraits = absl::allocator_traits<A>;
1512    struct MinimumAllocator {
1513      using value_type = T;
1514      value_type* allocate(size_t n) {
1515        A a;
1516        return ATraits::allocate(a, n);
1517      }
1518      void deallocate(value_type* p, size_t n) {
1519        A a;
1520        ATraits::deallocate(a, p, n);
1521      }
1522    };
1523    absl::InlinedVector<T, 1, MinimumAllocator> vec;
1524    vec.emplace_back();
1525    vec.resize(0);
1526  }
1527  TEST(InlinedVectorTest, AbslHashValueWorks) {
1528    using V = absl::InlinedVector<int, 4>;
1529    std::vector<V> cases;
1530    for (size_t i = 0; i < 10; ++i) {
1531      V v;
1532      for (int j = 0; j < static_cast<int>(i); ++j) {
1533        v.push_back(j);
1534      }
1535      cases.push_back(v);
1536      v.resize(i % 4);
1537      cases.push_back(v);
1538    }
1539    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(cases));
1540  }
1541  class MoveConstructibleOnlyInstance
1542      : public absl::test_internal::BaseCountedInstance {
1543   public:
1544    explicit MoveConstructibleOnlyInstance(int x) : BaseCountedInstance(x) {}
1545    MoveConstructibleOnlyInstance(MoveConstructibleOnlyInstance&& other) =
1546        default;
1547    MoveConstructibleOnlyInstance& operator=(
1548        MoveConstructibleOnlyInstance&& other) = delete;
1549  };
1550  MATCHER(HasValue, "") {
1551    return ::testing::get<0>(arg).value() == ::testing::get<1>(arg);
1552  }
1553  TEST(NonAssignableMoveAssignmentTest, AllocatedToInline) {
1554    using X = MoveConstructibleOnlyInstance;
1555    InstanceTracker tracker;
1556    absl::InlinedVector<X, 2> inlined;
1557    inlined.emplace_back(1);
1558    absl::InlinedVector<X, 2> allocated;
1559    allocated.emplace_back(1);
1560    allocated.emplace_back(2);
1561    allocated.emplace_back(3);
1562    tracker.ResetCopiesMovesSwaps();
1563    inlined = std::move(allocated);
1564    EXPECT_EQ(tracker.moves(), 0);
1565    EXPECT_EQ(tracker.live_instances(), 3);
1566    EXPECT_THAT(inlined, Pointwise(HasValue(), {1, 2, 3}));
1567  }
1568  TEST(NonAssignableMoveAssignmentTest, InlineToAllocated) {
1569    using X = MoveConstructibleOnlyInstance;
1570    InstanceTracker tracker;
1571    absl::InlinedVector<X, 2> inlined;
1572    inlined.emplace_back(1);
1573    absl::InlinedVector<X, 2> allocated;
1574    allocated.emplace_back(1);
1575    allocated.emplace_back(2);
1576    allocated.emplace_back(3);
1577    tracker.ResetCopiesMovesSwaps();
1578    allocated = std::move(inlined);
1579    EXPECT_EQ(tracker.moves(), 1);
1580    EXPECT_EQ(tracker.live_instances(), 1);
1581    EXPECT_THAT(allocated, Pointwise(HasValue(), {1}));
1582  }
1583  TEST(NonAssignableMoveAssignmentTest, InlineToInline) {
1584    using X = MoveConstructibleOnlyInstance;
1585    InstanceTracker tracker;
1586    absl::InlinedVector<X, 2> inlined_a;
1587    inlined_a.emplace_back(1);
1588    absl::InlinedVector<X, 2> inlined_b;
1589    inlined_b.emplace_back(1);
1590    tracker.ResetCopiesMovesSwaps();
1591    inlined_a = std::move(inlined_b);
1592    EXPECT_EQ(tracker.moves(), 1);
1593    EXPECT_EQ(tracker.live_instances(), 1);
1594    EXPECT_THAT(inlined_a, Pointwise(HasValue(), {1}));
1595  }
1596  TEST(NonAssignableMoveAssignmentTest, AllocatedToAllocated) {
1597    using X = MoveConstructibleOnlyInstance;
1598    InstanceTracker tracker;
1599    absl::InlinedVector<X, 2> allocated_a;
1600    allocated_a.emplace_back(1);
1601    allocated_a.emplace_back(2);
1602    allocated_a.emplace_back(3);
1603    absl::InlinedVector<X, 2> allocated_b;
1604    allocated_b.emplace_back(4);
1605    allocated_b.emplace_back(5);
1606    allocated_b.emplace_back(6);
1607    allocated_b.emplace_back(7);
1608    tracker.ResetCopiesMovesSwaps();
1609    allocated_a = std::move(allocated_b);
1610    EXPECT_EQ(tracker.moves(), 0);
1611    EXPECT_EQ(tracker.live_instances(), 4);
1612    EXPECT_THAT(allocated_a, Pointwise(HasValue(), {4, 5, 6, 7}));
1613  }
1614  TEST(NonAssignableMoveAssignmentTest, AssignThis) {
1615    using X = MoveConstructibleOnlyInstance;
1616    InstanceTracker tracker;
1617    absl::InlinedVector<X, 2> v;
1618    v.emplace_back(1);
1619    v.emplace_back(2);
1620    v.emplace_back(3);
1621    tracker.ResetCopiesMovesSwaps();
1622    v = std::move(*std::addressof(v));
1623    EXPECT_EQ(tracker.moves(), 0);
1624    EXPECT_EQ(tracker.live_instances(), 3);
1625    EXPECT_THAT(v, Pointwise(HasValue(), {1, 2, 3}));
1626  }
1627  class NonSwappableInstance : public absl::test_internal::BaseCountedInstance {
1628   public:
1629    explicit NonSwappableInstance(int x) : BaseCountedInstance(x) {}
1630    NonSwappableInstance(const NonSwappableInstance& other) = default;
1631    NonSwappableInstance& operator=(const NonSwappableInstance& other) = default;
1632    NonSwappableInstance(NonSwappableInstance&& other) = default;
1633    NonSwappableInstance& operator=(NonSwappableInstance&& other) = default;
1634  };
1635  void swap(NonSwappableInstance&, NonSwappableInstance&) = delete;
1636  TEST(NonSwappableSwapTest, InlineAndAllocatedTransferStorageAndMove) {
1637    using X = NonSwappableInstance;
1638    InstanceTracker tracker;
1639    absl::InlinedVector<X, 2> inlined;
1640    inlined.emplace_back(1);
1641    absl::InlinedVector<X, 2> allocated;
1642    allocated.emplace_back(1);
1643    allocated.emplace_back(2);
1644    allocated.emplace_back(3);
1645    tracker.ResetCopiesMovesSwaps();
1646    inlined.swap(allocated);
1647    EXPECT_EQ(tracker.moves(), 1);
1648    EXPECT_EQ(tracker.live_instances(), 4);
1649    EXPECT_THAT(inlined, Pointwise(HasValue(), {1, 2, 3}));
1650  }
1651  TEST(NonSwappableSwapTest, InlineAndInlineMoveIndividualElements) {
1652    using X = NonSwappableInstance;
1653    InstanceTracker tracker;
1654    absl::InlinedVector<X, 2> inlined_a;
1655    inlined_a.emplace_back(1);
1656    absl::InlinedVector<X, 2> inlined_b;
1657    inlined_b.emplace_back(2);
1658    tracker.ResetCopiesMovesSwaps();
1659    inlined_a.swap(inlined_b);
1660    EXPECT_EQ(tracker.moves(), 3);
1661    EXPECT_EQ(tracker.live_instances(), 2);
1662    EXPECT_THAT(inlined_a, Pointwise(HasValue(), {2}));
1663    EXPECT_THAT(inlined_b, Pointwise(HasValue(), {1}));
1664  }
1665  TEST(NonSwappableSwapTest, AllocatedAndAllocatedOnlyTransferStorage) {
1666    using X = NonSwappableInstance;
1667    InstanceTracker tracker;
1668    absl::InlinedVector<X, 2> allocated_a;
1669    allocated_a.emplace_back(1);
1670    allocated_a.emplace_back(2);
1671    allocated_a.emplace_back(3);
1672    absl::InlinedVector<X, 2> allocated_b;
1673    allocated_b.emplace_back(4);
1674    allocated_b.emplace_back(5);
1675    allocated_b.emplace_back(6);
1676    allocated_b.emplace_back(7);
1677    tracker.ResetCopiesMovesSwaps();
1678    allocated_a.swap(allocated_b);
1679    EXPECT_EQ(tracker.moves(), 0);
1680    EXPECT_EQ(tracker.live_instances(), 7);
1681    EXPECT_THAT(allocated_a, Pointwise(HasValue(), {4, 5, 6, 7}));
1682    EXPECT_THAT(allocated_b, Pointwise(HasValue(), {1, 2, 3}));
1683  }
1684  TEST(NonSwappableSwapTest, SwapThis) {
1685    using X = NonSwappableInstance;
1686    InstanceTracker tracker;
1687    absl::InlinedVector<X, 2> v;
1688    v.emplace_back(1);
1689    v.emplace_back(2);
1690    v.emplace_back(3);
1691    tracker.ResetCopiesMovesSwaps();
1692    v.swap(v);
1693    EXPECT_EQ(tracker.moves(), 0);
1694    EXPECT_EQ(tracker.live_instances(), 3);
1695    EXPECT_THAT(v, Pointwise(HasValue(), {1, 2, 3}));
1696  }
1697  template <size_t N>
1698  using CharVec = absl::InlinedVector<char, N>;
1699  template <typename T>
1700  struct MySpan {
1701    T* data;
1702    size_t size;
1703  };
1704  TEST(StorageTest, InlinedCapacityAutoIncrease) {
1705    EXPECT_GT(CharVec<1>().capacity(), 1);
1706    EXPECT_EQ(CharVec<1>().capacity(), sizeof(MySpan<char>));
1707    EXPECT_EQ(CharVec<1>().capacity(), CharVec<2>().capacity());
1708    EXPECT_EQ(sizeof(CharVec<1>), sizeof(CharVec<2>));
1709    EXPECT_GT((absl::InlinedVector<int, 1>().capacity()), 1);
1710    EXPECT_EQ((absl::InlinedVector<int, 1>().capacity()),
1711              sizeof(MySpan<int>) / sizeof(int));
1712  }
1713  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-webserver_libevent.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>51                            {"ico",           "image/x-icon"},
52                            {"svg svgz",      "image/svg+xml"},
53                            {"woff",          "application/font-woff"},
54                            {"json",          "application/json"}};
</pre></code></div>
                <div class="column column_space"><pre><code>355    {
356      absl::InlinedVector<std::string, 2> v(100);
357      v.resize(0);
358      v.shrink_to_fit();
359      EXPECT_EQ(v.capacity(), 2u);  
360    }
361    {
362      absl::InlinedVector<std::string, 2> v(100);
363      v.resize(1);
364      v.shrink_to_fit();
365      EXPECT_EQ(v.capacity(), 2u);  
366    }
367    {
368      absl::InlinedVector<std::string, 2> v(100);
369      v.resize(2);
370      v.shrink_to_fit();
371      EXPECT_EQ(v.capacity(), 2u);
372    }
373    {
374      absl::InlinedVector<std::string, 2> v(100);
375      v.resize(3);
376      v.shrink_to_fit();
377      EXPECT_EQ(v.capacity(), 3u);
378    }
379  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    