
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</h3>
            <pre><code>1  #include "absl/strings/numbers.h"
2  #include <sys/types.h>
3  #include <cfenv>  
4  #include <cfloat>
5  #include <cinttypes>
6  #include <climits>
7  #include <cmath>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstdlib>
12  #include <cstring>
13  #include <limits>
14  #include <numeric>
15  #include <random>
16  #include <set>
17  #include <string>
18  #include <vector>
19  #include "gmock/gmock.h"
20  #include "gtest/gtest.h"
21  #include "absl/log/log.h"
22  #include "absl/random/distributions.h"
23  #include "absl/random/random.h"
24  #include "absl/strings/internal/numbers_test_common.h"
25  #include "absl/strings/internal/ostringstream.h"
26  #include "absl/strings/internal/pow10_helper.h"
27  #include "absl/strings/str_cat.h"
28  namespace {
29  using absl::SimpleAtoi;
30  using absl::SimpleHexAtoi;
31  using absl::numbers_internal::kSixDigitsToBufferSize;
32  using absl::numbers_internal::safe_strto32_base;
33  using absl::numbers_internal::safe_strto64_base;
34  using absl::numbers_internal::safe_strtou32_base;
35  using absl::numbers_internal::safe_strtou64_base;
36  using absl::numbers_internal::SixDigitsToBuffer;
37  using absl::strings_internal::Itoa;
38  using absl::strings_internal::strtouint32_test_cases;
39  using absl::strings_internal::strtouint64_test_cases;
40  using testing::Eq;
41  using testing::MatchesRegex;
42  const int kFloatNumCases = 5000000;
43  std::string PerfectDtoa(double d) {
44    if (d == 0) return "0";
45    if (d < 0) return "-" + PerfectDtoa(-d);
46    int64_t mantissa, exp = 0;
47    while (d >= 1ULL << 63) ++exp, d *= 0.5;
48    while ((mantissa = d) != d) --exp, d *= 2.0;
49    constexpr int maxlen = 1100;  
50    char buf[maxlen + 5];
51    for (int64_t num = mantissa, pos = maxlen; --pos >= 0;) {
52      buf[pos] = '0' + (num % 10);
53      num /= 10;
54    }
55    char* begin = &buf[0];
56    char* end = buf + maxlen;
57    for (int i = 0; i != exp; i += (exp > 0) ? 1 : -1) {
58      int carry = 0;
59      for (char* p = end; --p != begin;) {
60        int dig = *p - '0';
61        dig = dig * (exp > 0 ? 2 : 5) + carry;
62        carry = dig / 10;
63        dig %= 10;
64        *p = '0' + dig;
65      }
66    }
67    if (exp < 0) {
68      memmove(end + 1 + exp, end + exp, 1 - exp);
69      end[exp] = '.';
70      ++end;
71    }
72    while (*begin == '0' && begin[1] != '.') ++begin;
73    return {begin, end};
74  }
75  TEST(ToString, PerfectDtoa) {
76    EXPECT_THAT(PerfectDtoa(1), Eq("1"));
77    EXPECT_THAT(PerfectDtoa(0.1),
78                Eq("0.1000000000000000055511151231257827021181583404541015625"));
79    EXPECT_THAT(PerfectDtoa(1e24), Eq("999999999999999983222784"));
80    EXPECT_THAT(PerfectDtoa(5e-324), MatchesRegex("0.0000.*625"));
81    for (int i = 0; i < 100; ++i) {
82      for (double multiplier :
83           {1e-300, 1e-200, 1e-100, 0.1, 1.0, 10.0, 1e100, 1e300}) {
84        double d = multiplier * i;
85        std::string s = PerfectDtoa(d);
86        EXPECT_DOUBLE_EQ(d, strtod(s.c_str(), nullptr));
87      }
88    }
89  }
90  template <typename integer>
91  struct MyInteger {
92    integer i;
93    explicit constexpr MyInteger(integer i) : i(i) {}
94    constexpr operator integer() const { return i; }
95    constexpr MyInteger operator+(MyInteger other) const { return i + other.i; }
96    constexpr MyInteger operator-(MyInteger other) const { return i - other.i; }
97    constexpr MyInteger operator*(MyInteger other) const { return i * other.i; }
98    constexpr MyInteger operator/(MyInteger other) const { return i / other.i; }
99    constexpr bool operator<(MyInteger other) const { return i < other.i; }
100    constexpr bool operator<=(MyInteger other) const { return i <= other.i; }
101    constexpr bool operator==(MyInteger other) const { return i == other.i; }
102    constexpr bool operator>=(MyInteger other) const { return i >= other.i; }
103    constexpr bool operator>(MyInteger other) const { return i > other.i; }
104    constexpr bool operator!=(MyInteger other) const { return i != other.i; }
105    integer as_integer() const { return i; }
106  };
107  typedef MyInteger<int64_t> MyInt64;
108  typedef MyInteger<uint64_t> MyUInt64;
109  void CheckInt32(int32_t x) {
110    char buffer[absl::numbers_internal::kFastToBufferSize];
111    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
112    std::string expected = std::to_string(x);
113    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
114    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
115    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
116  }
117  void CheckInt64(int64_t x) {
118    char buffer[absl::numbers_internal::kFastToBufferSize + 3];
119    buffer[0] = '*';
120    buffer[23] = '*';
121    buffer[24] = '*';
122    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
123    std::string expected = std::to_string(x);
124    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
125    EXPECT_EQ(buffer[0], '*');
126    EXPECT_EQ(buffer[23], '*');
127    EXPECT_EQ(buffer[24], '*');
128    char* my_actual =
129        absl::numbers_internal::FastIntToBuffer(MyInt64(x), &buffer[1]);
130    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
131  }
132  void CheckUInt32(uint32_t x) {
133    char buffer[absl::numbers_internal::kFastToBufferSize];
134    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
135    std::string expected = std::to_string(x);
136    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
137    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
138    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
139  }
140  void CheckUInt64(uint64_t x) {
141    char buffer[absl::numbers_internal::kFastToBufferSize + 1];
142    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
143    std::string expected = std::to_string(x);
144    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
145    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
146    EXPECT_EQ(expected, std::string(&buffer[1], generic_actual))
147        << " Input " << x;
148    char* my_actual =
149        absl::numbers_internal::FastIntToBuffer(MyUInt64(x), &buffer[1]);
150    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
151  }
152  void CheckHex64(uint64_t v) {
153    char expected[16 + 1];
154    std::string actual = absl::StrCat(absl::Hex(v, absl::kZeroPad16));
155    snprintf(expected, sizeof(expected), "%016" PRIx64, static_cast<uint64_t>(v));
156    EXPECT_EQ(expected, actual) << " Input " << v;
157    actual = absl::StrCat(absl::Hex(v, absl::kSpacePad16));
158    snprintf(expected, sizeof(expected), "%16" PRIx64, static_cast<uint64_t>(v));
159    EXPECT_EQ(expected, actual) << " Input " << v;
160  }
161  TEST(Numbers, TestFastPrints) {
162    for (int i = -100; i <= 100; i++) {
163      CheckInt32(i);
164      CheckInt64(i);
165    }
166    for (int i = 0; i <= 100; i++) {
167      CheckUInt32(i);
168      CheckUInt64(i);
169    }
170    CheckInt32(INT_MIN);
171    CheckInt32(INT_MAX);
172    CheckInt64(LONG_MIN);
173    CheckInt64(uint64_t{1000000000});
174    CheckInt64(uint64_t{9999999999});
175    CheckInt64(uint64_t{100000000000000});
176    CheckInt64(uint64_t{999999999999999});
177    CheckInt64(uint64_t{1000000000000000000});
178    CheckInt64(uint64_t{1199999999999999999});
179    CheckInt64(int64_t{-700000000000000000});
180    CheckInt64(LONG_MAX);
181    CheckUInt32(std::numeric_limits<uint32_t>::max());
182    CheckUInt64(uint64_t{1000000000});
183    CheckUInt64(uint64_t{9999999999});
184    CheckUInt64(uint64_t{100000000000000});
185    CheckUInt64(uint64_t{999999999999999});
186    CheckUInt64(uint64_t{1000000000000000000});
187    CheckUInt64(uint64_t{1199999999999999999});
188    CheckUInt64(std::numeric_limits<uint64_t>::max());
189    for (int i = 0; i < 10000; i++) {
190      CheckHex64(i);
191    }
192    CheckHex64(uint64_t{0x123456789abcdef0});
193  }
194  template <typename int_type, typename in_val_type>
195  void VerifySimpleAtoiGood(in_val_type in_value, int_type exp_value) {
196    std::string s;
197    absl::strings_internal::OStringStream(&s) << in_value;
198    int_type x = static_cast<int_type>(~exp_value);
199    EXPECT_TRUE(SimpleAtoi(s, &x))
200        << "in_value=" << in_value << " s=" << s << " x=" << x;
201    EXPECT_EQ(exp_value, x);
202    x = static_cast<int_type>(~exp_value);
203    EXPECT_TRUE(SimpleAtoi(s.c_str(), &x));
204    EXPECT_EQ(exp_value, x);
205  }
206  template <typename int_type, typename in_val_type>
207  void VerifySimpleAtoiBad(in_val_type in_value) {
208    std::string s;
209    absl::strings_internal::OStringStream(&s) << in_value;
210    int_type x;
211    EXPECT_FALSE(SimpleAtoi(s, &x));
212    EXPECT_FALSE(SimpleAtoi(s.c_str(), &x));
213  }
214  TEST(NumbersTest, Atoi) {
215    VerifySimpleAtoiGood<int32_t>(0, 0);
216    VerifySimpleAtoiGood<int32_t>(42, 42);
217    VerifySimpleAtoiGood<int32_t>(-42, -42);
218    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
219                                  std::numeric_limits<int32_t>::min());
220    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
221                                  std::numeric_limits<int32_t>::max());
222    VerifySimpleAtoiGood<uint32_t>(0, 0);
223    VerifySimpleAtoiGood<uint32_t>(42, 42);
224    VerifySimpleAtoiBad<uint32_t>(-42);
225    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
226    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
227                                   std::numeric_limits<int32_t>::max());
228    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
229                                   std::numeric_limits<uint32_t>::max());
230    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
231    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
232    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
233    VerifySimpleAtoiGood<int64_t>(0, 0);
234    VerifySimpleAtoiGood<int64_t>(42, 42);
235    VerifySimpleAtoiGood<int64_t>(-42, -42);
236    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
237                                  std::numeric_limits<int32_t>::min());
238    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
239                                  std::numeric_limits<int32_t>::max());
240    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
241                                  std::numeric_limits<uint32_t>::max());
242    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
243                                  std::numeric_limits<int64_t>::min());
244    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
245                                  std::numeric_limits<int64_t>::max());
246    VerifySimpleAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
247    VerifySimpleAtoiGood<uint64_t>(0, 0);
248    VerifySimpleAtoiGood<uint64_t>(42, 42);
249    VerifySimpleAtoiBad<uint64_t>(-42);
250    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
251    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
252                                   std::numeric_limits<int32_t>::max());
253    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
254                                   std::numeric_limits<uint32_t>::max());
255    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
256    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
257                                   std::numeric_limits<int64_t>::max());
<span onclick='openModal()' class='match'>258    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
259                                   std::numeric_limits<uint64_t>::max());
260    VerifySimpleAtoiGood<absl::uint128>(0, 0);
</span>261    VerifySimpleAtoiGood<absl::uint128>(42, 42);
262    VerifySimpleAtoiBad<absl::uint128>(-42);
263    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
264    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
265                                        std::numeric_limits<int32_t>::max());
266    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
267                                        std::numeric_limits<uint32_t>::max());
268    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
269    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
270                                        std::numeric_limits<int64_t>::max());
271    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
272                                        std::numeric_limits<uint64_t>::max());
273    VerifySimpleAtoiGood<absl::uint128>(
274        std::numeric_limits<absl::uint128>::max(),
275        std::numeric_limits<absl::uint128>::max());
276    VerifySimpleAtoiGood<absl::int128>(0, 0);
277    VerifySimpleAtoiGood<absl::int128>(42, 42);
278    VerifySimpleAtoiGood<absl::int128>(-42, -42);
279    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::min(),
280                                        std::numeric_limits<int32_t>::min());
281    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::max(),
282                                        std::numeric_limits<int32_t>::max());
283    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint32_t>::max(),
284                                        std::numeric_limits<uint32_t>::max());
285    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::min(),
286                                        std::numeric_limits<int64_t>::min());
287    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::max(),
288                                        std::numeric_limits<int64_t>::max());
289    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint64_t>::max(),
290                                        std::numeric_limits<uint64_t>::max());
291    VerifySimpleAtoiGood<absl::int128>(
292        std::numeric_limits<absl::int128>::min(),
293        std::numeric_limits<absl::int128>::min());
294    VerifySimpleAtoiGood<absl::int128>(
295        std::numeric_limits<absl::int128>::max(),
296        std::numeric_limits<absl::int128>::max());
297    VerifySimpleAtoiBad<absl::int128>(std::numeric_limits<absl::uint128>::max());
298    VerifySimpleAtoiGood<int>(-42, -42);
299    VerifySimpleAtoiGood<int32_t>(-42, -42);
300    VerifySimpleAtoiGood<uint32_t>(42, 42);
301    VerifySimpleAtoiGood<unsigned int>(42, 42);
302    VerifySimpleAtoiGood<int64_t>(-42, -42);
303    VerifySimpleAtoiGood<long>(-42, -42);  
304    VerifySimpleAtoiGood<uint64_t>(42, 42);
305    VerifySimpleAtoiGood<size_t>(42, 42);
306    VerifySimpleAtoiGood<std::string::size_type>(42, 42);
307  }
308  TEST(NumbersTest, Atod) {
309  #if !defined(DBL_TRUE_MIN)
310    static constexpr double DBL_TRUE_MIN =
311        4.940656458412465441765687928682213723650598026143247644255856825e-324;
312  #endif
313  #if !defined(FLT_TRUE_MIN)
314    static constexpr float FLT_TRUE_MIN =
315        1.401298464324817070923729583289916131280261941876515771757068284e-45f;
316  #endif
317    double d;
318    float f;
319    EXPECT_TRUE(absl::SimpleAtod("NaN", &d));
320    EXPECT_TRUE(std::isnan(d));
321    EXPECT_TRUE(absl::SimpleAtod("nAN", &d));
322    EXPECT_TRUE(std::isnan(d));
323    EXPECT_TRUE(absl::SimpleAtod("-nan", &d));
324    EXPECT_TRUE(std::isnan(d));
325    EXPECT_TRUE(absl::SimpleAtod("inf", &d));
326    EXPECT_TRUE(std::isinf(d) && (d > 0));
327    EXPECT_TRUE(absl::SimpleAtod("+Infinity", &d));
328    EXPECT_TRUE(std::isinf(d) && (d > 0));
329    EXPECT_TRUE(absl::SimpleAtod("-INF", &d));
330    EXPECT_TRUE(std::isinf(d) && (d < 0));
331    EXPECT_TRUE(absl::SimpleAtod("1.7976931348623157e+308", &d));
332    EXPECT_EQ(d, 1.7976931348623157e+308);
333    EXPECT_TRUE(absl::SimpleAtod("5e308", &d));
334    EXPECT_TRUE(std::isinf(d) && (d > 0));
335    EXPECT_TRUE(absl::SimpleAtof("3.4028234663852886e+38", &f));
336    EXPECT_EQ(f, 3.4028234663852886e+38f);
337    EXPECT_TRUE(absl::SimpleAtof("7e38", &f));
338    EXPECT_TRUE(std::isinf(f) && (f > 0));
339    EXPECT_TRUE(absl::SimpleAtod("1e308", &d));
340    EXPECT_EQ(d, 1e308);
341    EXPECT_FALSE(std::isinf(d));
342    EXPECT_TRUE(absl::SimpleAtod("1e309", &d));
343    EXPECT_TRUE(std::isinf(d));
344    EXPECT_TRUE(absl::SimpleAtof("1e38", &f));
345    EXPECT_EQ(f, 1e38f);
346    EXPECT_FALSE(std::isinf(f));
347    EXPECT_TRUE(absl::SimpleAtof("1e39", &f));
348    EXPECT_TRUE(std::isinf(f));
349    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e307", &d));
350    EXPECT_EQ(d, 9.999999999999999999e307);
351    EXPECT_FALSE(std::isinf(d));
352    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e308", &d));
353    EXPECT_TRUE(std::isinf(d));
354    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e37", &f));
355    EXPECT_EQ(f, 9.999999999999999999e37f);
356    EXPECT_FALSE(std::isinf(f));
357    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e38", &f));
358    EXPECT_TRUE(std::isinf(f));
359    EXPECT_TRUE(absl::SimpleAtod("2.2250738585072014e-308", &d));
360    EXPECT_EQ(d, 2.2250738585072014e-308);
361    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-324", &d));
362    EXPECT_EQ(d, 4.9406564584124654e-324);
363    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-325", &d));
364    EXPECT_EQ(d, 0);
365    EXPECT_TRUE(absl::SimpleAtof("1.1754943508222875e-38", &f));
366    EXPECT_EQ(f, 1.1754943508222875e-38f);
367    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-45", &f));
368    EXPECT_EQ(f, 1.4012984643248171e-45f);
369    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-46", &f));
370    EXPECT_EQ(f, 0);
371    EXPECT_TRUE(absl::SimpleAtod("1e-307", &d));
372    EXPECT_EQ(d, 1e-307);
373    EXPECT_GE(d, DBL_MIN);
374    EXPECT_LT(d, DBL_MIN * 10);
375    EXPECT_TRUE(absl::SimpleAtod("1e-323", &d));
376    EXPECT_EQ(d, 1e-323);
377    EXPECT_GE(d, DBL_TRUE_MIN);
378    EXPECT_LT(d, DBL_TRUE_MIN * 10);
379    EXPECT_TRUE(absl::SimpleAtod("1e-324", &d));
380    EXPECT_EQ(d, 0);
381    EXPECT_TRUE(absl::SimpleAtof("1e-37", &f));
382    EXPECT_EQ(f, 1e-37f);
383    EXPECT_GE(f, FLT_MIN);
384    EXPECT_LT(f, FLT_MIN * 10);
385    EXPECT_TRUE(absl::SimpleAtof("1e-45", &f));
386    EXPECT_EQ(f, 1e-45f);
387    EXPECT_GE(f, FLT_TRUE_MIN);
388    EXPECT_LT(f, FLT_TRUE_MIN * 10);
389    EXPECT_TRUE(absl::SimpleAtof("1e-46", &f));
390    EXPECT_EQ(f, 0);
391    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-308", &d));
392    EXPECT_EQ(d, 9.999999999999999999e-308);
393    EXPECT_GE(d, DBL_MIN);
394    EXPECT_LT(d, DBL_MIN * 10);
395    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-324", &d));
396    EXPECT_EQ(d, 9.999999999999999999e-324);
397    EXPECT_GE(d, DBL_TRUE_MIN);
398    EXPECT_LT(d, DBL_TRUE_MIN * 10);
399    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-325", &d));
400    EXPECT_EQ(d, 0);
401    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-38", &f));
402    EXPECT_EQ(f, 9.999999999999999999e-38f);
403    EXPECT_GE(f, FLT_MIN);
404    EXPECT_LT(f, FLT_MIN * 10);
405    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-46", &f));
406    EXPECT_EQ(f, 9.999999999999999999e-46f);
407    EXPECT_GE(f, FLT_TRUE_MIN);
408    EXPECT_LT(f, FLT_TRUE_MIN * 10);
409    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-47", &f));
410    EXPECT_EQ(f, 0);
411    EXPECT_TRUE(absl::SimpleAtod("  \t\r\n  2.718", &d));
412    EXPECT_EQ(d, 2.718);
413    EXPECT_TRUE(absl::SimpleAtod("  3.141  ", &d));
414    EXPECT_EQ(d, 3.141);
415    EXPECT_FALSE(absl::SimpleAtod("n 0", &d));
416    EXPECT_FALSE(absl::SimpleAtod("0n ", &d));
417    EXPECT_TRUE(absl::SimpleAtod("000123", &d));
418    EXPECT_EQ(d, 123);
419    EXPECT_TRUE(absl::SimpleAtod("000.456", &d));
420    EXPECT_EQ(d, 0.456);
421    EXPECT_TRUE(absl::SimpleAtod(".5", &d));
422    EXPECT_EQ(d, 0.5);
423    EXPECT_TRUE(absl::SimpleAtod("-.707", &d));
424    EXPECT_EQ(d, -0.707);
425    EXPECT_TRUE(absl::SimpleAtod("+6.0221408e+23", &d));
426    EXPECT_EQ(d, 6.0221408e+23);
427    EXPECT_FALSE(absl::SimpleAtod("123_456", &d));
428    EXPECT_TRUE(absl::SimpleAtod("8.9", &d));
429    EXPECT_FALSE(absl::SimpleAtod("8,9", &d));
430    EXPECT_TRUE(absl::SimpleAtod("4503599627370497.5", &d));
431    EXPECT_EQ(d, 4503599627370497.5);
432    EXPECT_TRUE(absl::SimpleAtod("1e+23", &d));
433    EXPECT_EQ(d, 1e+23);
434    EXPECT_TRUE(absl::SimpleAtod("9223372036854775807", &d));
435    EXPECT_EQ(d, 9223372036854775807);
436    EXPECT_TRUE(absl::SimpleAtof("0.0625", &f));
437    EXPECT_EQ(f, 0.0625f);
438    EXPECT_TRUE(absl::SimpleAtof("20040229.0", &f));
439    EXPECT_EQ(f, 20040229.0f);
440    EXPECT_TRUE(absl::SimpleAtof("2147483647.0", &f));
441    EXPECT_EQ(f, 2147483647.0f);
442    EXPECT_TRUE(absl::SimpleAtod("122.416294033786585", &d));
443    EXPECT_EQ(d, 122.416294033786585);
444    EXPECT_TRUE(absl::SimpleAtof("122.416294033786585", &f));
445    EXPECT_EQ(f, 122.416294033786585f);
446  }
447  TEST(NumbersTest, Prefixes) {
448    double d;
449    EXPECT_FALSE(absl::SimpleAtod("++1", &d));
450    EXPECT_FALSE(absl::SimpleAtod("+-1", &d));
451    EXPECT_FALSE(absl::SimpleAtod("-+1", &d));
452    EXPECT_FALSE(absl::SimpleAtod("--1", &d));
453    EXPECT_TRUE(absl::SimpleAtod("-1", &d));
454    EXPECT_EQ(d, -1.);
455    EXPECT_TRUE(absl::SimpleAtod("+1", &d));
456    EXPECT_EQ(d, +1.);
457    float f;
458    EXPECT_FALSE(absl::SimpleAtof("++1", &f));
459    EXPECT_FALSE(absl::SimpleAtof("+-1", &f));
460    EXPECT_FALSE(absl::SimpleAtof("-+1", &f));
461    EXPECT_FALSE(absl::SimpleAtof("--1", &f));
462    EXPECT_TRUE(absl::SimpleAtof("-1", &f));
463    EXPECT_EQ(f, -1.f);
464    EXPECT_TRUE(absl::SimpleAtof("+1", &f));
465    EXPECT_EQ(f, +1.f);
466  }
467  TEST(NumbersTest, Atoenum) {
468    enum E01 {
469      E01_zero = 0,
470      E01_one = 1,
471    };
472    VerifySimpleAtoiGood<E01>(E01_zero, E01_zero);
473    VerifySimpleAtoiGood<E01>(E01_one, E01_one);
474    enum E_101 {
475      E_101_minusone = -1,
476      E_101_zero = 0,
477      E_101_one = 1,
478    };
479    VerifySimpleAtoiGood<E_101>(E_101_minusone, E_101_minusone);
480    VerifySimpleAtoiGood<E_101>(E_101_zero, E_101_zero);
481    VerifySimpleAtoiGood<E_101>(E_101_one, E_101_one);
482    enum E_bigint {
483      E_bigint_zero = 0,
484      E_bigint_one = 1,
485      E_bigint_max31 = static_cast<int32_t>(0x7FFFFFFF),
486    };
487    VerifySimpleAtoiGood<E_bigint>(E_bigint_zero, E_bigint_zero);
488    VerifySimpleAtoiGood<E_bigint>(E_bigint_one, E_bigint_one);
489    VerifySimpleAtoiGood<E_bigint>(E_bigint_max31, E_bigint_max31);
490    enum E_fullint {
491      E_fullint_zero = 0,
492      E_fullint_one = 1,
493      E_fullint_max31 = static_cast<int32_t>(0x7FFFFFFF),
494      E_fullint_min32 = INT32_MIN,
495    };
496    VerifySimpleAtoiGood<E_fullint>(E_fullint_zero, E_fullint_zero);
497    VerifySimpleAtoiGood<E_fullint>(E_fullint_one, E_fullint_one);
498    VerifySimpleAtoiGood<E_fullint>(E_fullint_max31, E_fullint_max31);
499    VerifySimpleAtoiGood<E_fullint>(E_fullint_min32, E_fullint_min32);
500    enum E_biguint {
501      E_biguint_zero = 0,
502      E_biguint_one = 1,
503      E_biguint_max31 = static_cast<uint32_t>(0x7FFFFFFF),
504      E_biguint_max32 = static_cast<uint32_t>(0xFFFFFFFF),
505    };
506    VerifySimpleAtoiGood<E_biguint>(E_biguint_zero, E_biguint_zero);
507    VerifySimpleAtoiGood<E_biguint>(E_biguint_one, E_biguint_one);
508    VerifySimpleAtoiGood<E_biguint>(E_biguint_max31, E_biguint_max31);
509    VerifySimpleAtoiGood<E_biguint>(E_biguint_max32, E_biguint_max32);
510  }
511  template <typename int_type, typename in_val_type>
512  void VerifySimpleHexAtoiGood(in_val_type in_value, int_type exp_value) {
513    std::string s;
514    absl::strings_internal::OStringStream strm(&s);
515    if (in_value >= 0) {
516      strm << std::hex << in_value;
517    } else {
518      strm << "-" << std::hex << -absl::uint128(in_value);
519    }
520    int_type x = static_cast<int_type>(~exp_value);
521    EXPECT_TRUE(SimpleHexAtoi(s, &x))
522        << "in_value=" << std::hex << in_value << " s=" << s << " x=" << x;
523    EXPECT_EQ(exp_value, x);
524    x = static_cast<int_type>(~exp_value);
525    EXPECT_TRUE(SimpleHexAtoi(
526        s.c_str(), &x));  
527    EXPECT_EQ(exp_value, x);
528  }
529  template <typename int_type, typename in_val_type>
530  void VerifySimpleHexAtoiBad(in_val_type in_value) {
531    std::string s;
532    absl::strings_internal::OStringStream strm(&s);
533    if (in_value >= 0) {
534      strm << std::hex << in_value;
535    } else {
536      strm << "-" << std::hex << -absl::uint128(in_value);
537    }
538    int_type x;
539    EXPECT_FALSE(SimpleHexAtoi(s, &x));
540    EXPECT_FALSE(SimpleHexAtoi(
541        s.c_str(), &x));  
542  }
543  TEST(NumbersTest, HexAtoi) {
544    VerifySimpleHexAtoiGood<int32_t>(0, 0);
545    VerifySimpleHexAtoiGood<int32_t>(0x42, 0x42);
546    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
547    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
548                                     std::numeric_limits<int32_t>::min());
549    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
550                                     std::numeric_limits<int32_t>::max());
551    VerifySimpleHexAtoiGood<uint32_t>(0, 0);
552    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
553    VerifySimpleHexAtoiBad<uint32_t>(-0x42);
554    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
555    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
556                                      std::numeric_limits<int32_t>::max());
557    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
558                                      std::numeric_limits<uint32_t>::max());
559    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
560    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
561    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
562    VerifySimpleHexAtoiGood<int64_t>(0, 0);
563    VerifySimpleHexAtoiGood<int64_t>(0x42, 0x42);
564    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
565    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
566                                     std::numeric_limits<int32_t>::min());
567    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
568                                     std::numeric_limits<int32_t>::max());
569    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
570                                     std::numeric_limits<uint32_t>::max());
571    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
572                                     std::numeric_limits<int64_t>::min());
573    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
574                                     std::numeric_limits<int64_t>::max());
575    VerifySimpleHexAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
576    VerifySimpleHexAtoiGood<uint64_t>(0, 0);
577    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
578    VerifySimpleHexAtoiBad<uint64_t>(-0x42);
579    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
580    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
581                                      std::numeric_limits<int32_t>::max());
582    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
583                                      std::numeric_limits<uint32_t>::max());
584    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
585    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
586                                      std::numeric_limits<int64_t>::max());
587    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
588                                      std::numeric_limits<uint64_t>::max());
589    VerifySimpleHexAtoiGood<absl::uint128>(0, 0);
590    VerifySimpleHexAtoiGood<absl::uint128>(0x42, 0x42);
591    VerifySimpleHexAtoiBad<absl::uint128>(-0x42);
592    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
593    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
594                                           std::numeric_limits<int32_t>::max());
595    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
596                                           std::numeric_limits<uint32_t>::max());
597    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
598    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
599                                           std::numeric_limits<int64_t>::max());
600    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
601                                           std::numeric_limits<uint64_t>::max());
602    VerifySimpleHexAtoiGood<absl::uint128>(
603        std::numeric_limits<absl::uint128>::max(),
604        std::numeric_limits<absl::uint128>::max());
605    VerifySimpleHexAtoiGood<int>(-0x42, -0x42);
606    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
607    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
608    VerifySimpleHexAtoiGood<unsigned int>(0x42, 0x42);
609    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
610    VerifySimpleHexAtoiGood<long>(-0x42, -0x42);  
611    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
612    VerifySimpleHexAtoiGood<size_t>(0x42, 0x42);
613    VerifySimpleHexAtoiGood<std::string::size_type>(0x42, 0x42);
614    int32_t value;
615    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
616    EXPECT_EQ(0x34234324, value);
617    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
618    EXPECT_EQ(0x34234324, value);
619    EXPECT_TRUE(safe_strto32_base(" \t\n 34234324", &value, 16));
620    EXPECT_EQ(0x34234324, value);
621    EXPECT_TRUE(safe_strto32_base("34234324 \t\n ", &value, 16));
622    EXPECT_EQ(0x34234324, value);
623  }
624  TEST(stringtest, safe_strto32_base) {
625    int32_t value;
626    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
627    EXPECT_EQ(0x34234324, value);
628    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
629    EXPECT_EQ(0x34234324, value);
630    EXPECT_TRUE(safe_strto32_base("34234324", &value, 16));
631    EXPECT_EQ(0x34234324, value);
632    EXPECT_TRUE(safe_strto32_base("0", &value, 16));
633    EXPECT_EQ(0, value);
634    EXPECT_TRUE(safe_strto32_base(" \t\n -0x34234324", &value, 16));
635    EXPECT_EQ(-0x34234324, value);
636    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 16));
637    EXPECT_EQ(-0x34234324, value);
638    EXPECT_TRUE(safe_strto32_base("7654321", &value, 8));
639    EXPECT_EQ(07654321, value);
640    EXPECT_TRUE(safe_strto32_base("-01234", &value, 8));
641    EXPECT_EQ(-01234, value);
642    EXPECT_FALSE(safe_strto32_base("1834", &value, 8));
643    EXPECT_TRUE(safe_strto32_base("0", &value, 0));
644    EXPECT_EQ(0, value);
645    EXPECT_TRUE(safe_strto32_base("077", &value, 0));
646    EXPECT_EQ(077, value);  
647    EXPECT_FALSE(safe_strto32_base("088", &value, 0));
648    EXPECT_FALSE(safe_strto32_base("0xG", &value, 0));
649    EXPECT_TRUE(safe_strto32_base("34234324", &value, 10));
650    EXPECT_EQ(34234324, value);
651    EXPECT_TRUE(safe_strto32_base("0", &value, 10));
652    EXPECT_EQ(0, value);
653    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 10));
654    EXPECT_EQ(-34234324, value);
655    EXPECT_TRUE(safe_strto32_base("34234324 \n\t ", &value, 10));
656    EXPECT_EQ(34234324, value);
657    EXPECT_FALSE(safe_strto32_base("", &value, 10));
658    EXPECT_FALSE(safe_strto32_base("  ", &value, 10));
659    EXPECT_FALSE(safe_strto32_base("abc", &value, 10));
660    EXPECT_FALSE(safe_strto32_base("34234324a", &value, 10));
661    EXPECT_FALSE(safe_strto32_base("34234.3", &value, 10));
662    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
663    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
664    EXPECT_TRUE(safe_strto32_base(std::string("0x1234"), &value, 16));
665    EXPECT_EQ(0x1234, value);
666    EXPECT_TRUE(safe_strto32_base("1234", &value, 10));
667    EXPECT_EQ(1234, value);
668  }
669  TEST(stringtest, safe_strto32_range) {
670    int32_t value;
671    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
672    EXPECT_EQ(std::numeric_limits<int32_t>::max(), value);
673    EXPECT_TRUE(safe_strto32_base("-2147483648", &value, 10));
674    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
675    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
676    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
677  }
678  TEST(stringtest, safe_strto64_range) {
679    int64_t value;
680    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
681    EXPECT_EQ(std::numeric_limits<int64_t>::max(), value);
682    EXPECT_TRUE(safe_strto64_base("-9223372036854775808", &value, 10));
683    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
684    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
685    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
686  }
687  TEST(stringtest, safe_strto32_leading_substring) {
688    int32_t value;
689    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 10));
690    EXPECT_EQ(4069, value);
691    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 8));
692    EXPECT_EQ(0406, value);
693    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 10));
694    EXPECT_EQ(4069, value);
695    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 16));
696    EXPECT_EQ(0x4069ba, value);
697    EXPECT_FALSE(safe_strto32_base("@@@", &value, 10));
698    EXPECT_EQ(0, value);  
699  }
700  TEST(stringtest, safe_strto64_leading_substring) {
701    int64_t value;
702    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 10));
703    EXPECT_EQ(4069, value);
704    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 8));
705    EXPECT_EQ(0406, value);
706    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 10));
707    EXPECT_EQ(4069, value);
708    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 16));
709    EXPECT_EQ(0x4069ba, value);
710    EXPECT_FALSE(safe_strto64_base("@@@", &value, 10));
711    EXPECT_EQ(0, value);  
712  }
713  TEST(stringtest, safe_strto64_base) {
714    int64_t value;
715    EXPECT_TRUE(safe_strto64_base("0x3423432448783446", &value, 16));
716    EXPECT_EQ(int64_t{0x3423432448783446}, value);
717    EXPECT_TRUE(safe_strto64_base("3423432448783446", &value, 16));
718    EXPECT_EQ(int64_t{0x3423432448783446}, value);
719    EXPECT_TRUE(safe_strto64_base("0", &value, 16));
720    EXPECT_EQ(0, value);
721    EXPECT_TRUE(safe_strto64_base(" \t\n -0x3423432448783446", &value, 16));
722    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
723    EXPECT_TRUE(safe_strto64_base(" \t\n -3423432448783446", &value, 16));
724    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
725    EXPECT_TRUE(safe_strto64_base("123456701234567012", &value, 8));
726    EXPECT_EQ(int64_t{0123456701234567012}, value);
727    EXPECT_TRUE(safe_strto64_base("-017777777777777", &value, 8));
728    EXPECT_EQ(int64_t{-017777777777777}, value);
729    EXPECT_FALSE(safe_strto64_base("19777777777777", &value, 8));
730    EXPECT_TRUE(safe_strto64_base("0", &value, 0));
731    EXPECT_EQ(0, value);
732    EXPECT_TRUE(safe_strto64_base("077", &value, 0));
733    EXPECT_EQ(077, value);  
734    EXPECT_FALSE(safe_strto64_base("088", &value, 0));
735    EXPECT_FALSE(safe_strto64_base("0xG", &value, 0));
736    EXPECT_TRUE(safe_strto64_base("34234324487834466", &value, 10));
737    EXPECT_EQ(int64_t{34234324487834466}, value);
738    EXPECT_TRUE(safe_strto64_base("0", &value, 10));
739    EXPECT_EQ(0, value);
740    EXPECT_TRUE(safe_strto64_base(" \t\n -34234324487834466", &value, 10));
741    EXPECT_EQ(int64_t{-34234324487834466}, value);
742    EXPECT_TRUE(safe_strto64_base("34234324487834466 \n\t ", &value, 10));
743    EXPECT_EQ(int64_t{34234324487834466}, value);
744    EXPECT_FALSE(safe_strto64_base("", &value, 10));
745    EXPECT_FALSE(safe_strto64_base("  ", &value, 10));
746    EXPECT_FALSE(safe_strto64_base("abc", &value, 10));
747    EXPECT_FALSE(safe_strto64_base("34234324487834466a", &value, 10));
748    EXPECT_FALSE(safe_strto64_base("34234487834466.3", &value, 10));
749    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
750    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
751    EXPECT_TRUE(safe_strto64_base(std::string("0x1234"), &value, 16));
752    EXPECT_EQ(0x1234, value);
753    EXPECT_TRUE(safe_strto64_base("1234", &value, 10));
754    EXPECT_EQ(1234, value);
755  }
756  const size_t kNumRandomTests = 10000;
757  template <typename IntType>
758  void test_random_integer_parse_base(bool (*parse_func)(absl::string_view,
759                                                         IntType* value,
760                                                         int base)) {
761    using RandomEngine = std::minstd_rand0;
762    std::random_device rd;
763    RandomEngine rng(rd());
764    std::uniform_int_distribution<IntType> random_int(
765        std::numeric_limits<IntType>::min());
766    std::uniform_int_distribution<int> random_base(2, 35);
767    for (size_t i = 0; i < kNumRandomTests; i++) {
768      IntType value = random_int(rng);
769      int base = random_base(rng);
770      std::string str_value;
771      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
772      IntType parsed_value;
773      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
774      EXPECT_EQ(parsed_value, value);
775      EXPECT_FALSE(
776          parse_func(absl::StrCat(std::numeric_limits<IntType>::max(), value),
777                     &parsed_value, base));
778      if (std::numeric_limits<IntType>::min() < 0) {
779        EXPECT_FALSE(
780            parse_func(absl::StrCat(std::numeric_limits<IntType>::min(), value),
781                       &parsed_value, base));
782      } else {
783        EXPECT_FALSE(parse_func(absl::StrCat("-", value), &parsed_value, base));
784      }
785    }
786  }
787  TEST(stringtest, safe_strto32_random) {
788    test_random_integer_parse_base<int32_t>(&safe_strto32_base);
789  }
790  TEST(stringtest, safe_strto64_random) {
791    test_random_integer_parse_base<int64_t>(&safe_strto64_base);
792  }
793  TEST(stringtest, safe_strtou32_random) {
794    test_random_integer_parse_base<uint32_t>(&safe_strtou32_base);
795  }
796  TEST(stringtest, safe_strtou64_random) {
797    test_random_integer_parse_base<uint64_t>(&safe_strtou64_base);
798  }
799  TEST(stringtest, safe_strtou128_random) {
800    using RandomEngine = std::minstd_rand0;
801    using IntType = absl::uint128;
802    constexpr auto parse_func = &absl::numbers_internal::safe_strtou128_base;
803    std::random_device rd;
804    RandomEngine rng(rd());
805    std::uniform_int_distribution<uint64_t> random_uint64(
806        std::numeric_limits<uint64_t>::min());
807    std::uniform_int_distribution<int> random_base(2, 35);
808    for (size_t i = 0; i < kNumRandomTests; i++) {
809      IntType value = random_uint64(rng);
810      value = (value << 64) + random_uint64(rng);
811      int base = random_base(rng);
812      std::string str_value;
813      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
814      IntType parsed_value;
815      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
816      EXPECT_EQ(parsed_value, value);
817      std::string s;
818      absl::strings_internal::OStringStream(&s)
819          << std::numeric_limits<IntType>::max() << value;
820      EXPECT_FALSE(parse_func(s, &parsed_value, base));
821      s.clear();
822      absl::strings_internal::OStringStream(&s) << "-" << value;
823      EXPECT_FALSE(parse_func(s, &parsed_value, base));
824    }
825  }
826  TEST(stringtest, safe_strto128_random) {
827    using RandomEngine = std::minstd_rand0;
828    using IntType = absl::int128;
829    constexpr auto parse_func = &absl::numbers_internal::safe_strto128_base;
830    std::random_device rd;
831    RandomEngine rng(rd());
832    std::uniform_int_distribution<int64_t> random_int64(
833        std::numeric_limits<int64_t>::min());
834    std::uniform_int_distribution<uint64_t> random_uint64(
835        std::numeric_limits<uint64_t>::min());
836    std::uniform_int_distribution<int> random_base(2, 35);
837    for (size_t i = 0; i < kNumRandomTests; ++i) {
838      int64_t high = random_int64(rng);
839      uint64_t low = random_uint64(rng);
840      IntType value = absl::MakeInt128(high, low);
841      int base = random_base(rng);
842      std::string str_value;
843      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
844      IntType parsed_value;
845      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
846      EXPECT_EQ(parsed_value, value);
847      std::string s;
848      absl::strings_internal::OStringStream(&s)
849          << std::numeric_limits<IntType>::max() << value;
850      EXPECT_FALSE(parse_func(s, &parsed_value, base));
851      s.clear();
852      absl::strings_internal::OStringStream(&s)
853          << std::numeric_limits<IntType>::min() << value;
854      EXPECT_FALSE(parse_func(s, &parsed_value, base));
855    }
856  }
857  TEST(stringtest, safe_strtou32_base) {
858    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
859      const auto& e = strtouint32_test_cases()[i];
860      uint32_t value;
861      EXPECT_EQ(e.expect_ok, safe_strtou32_base(e.str, &value, e.base))
862          << "str=\"" << e.str << "\" base=" << e.base;
863      if (e.expect_ok) {
864        EXPECT_EQ(e.expected, value) << "i=" << i << " str=\"" << e.str
865                                     << "\" base=" << e.base;
866      }
867    }
868  }
869  TEST(stringtest, safe_strtou32_base_length_delimited) {
870    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
871      const auto& e = strtouint32_test_cases()[i];
872      std::string tmp(e.str);
873      tmp.append("12");  
874      uint32_t value;
875      EXPECT_EQ(e.expect_ok,
876                safe_strtou32_base(absl::string_view(tmp.data(), strlen(e.str)),
877                                   &value, e.base))
878          << "str=\"" << e.str << "\" base=" << e.base;
879      if (e.expect_ok) {
880        EXPECT_EQ(e.expected, value) << "i=" << i << " str=" << e.str
881                                     << " base=" << e.base;
882      }
883    }
884  }
885  TEST(stringtest, safe_strtou64_base) {
886    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
887      const auto& e = strtouint64_test_cases()[i];
888      uint64_t value;
889      EXPECT_EQ(e.expect_ok, safe_strtou64_base(e.str, &value, e.base))
890          << "str=\"" << e.str << "\" base=" << e.base;
891      if (e.expect_ok) {
892        EXPECT_EQ(e.expected, value) << "str=" << e.str << " base=" << e.base;
893      }
894    }
895  }
896  TEST(stringtest, safe_strtou64_base_length_delimited) {
897    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
898      const auto& e = strtouint64_test_cases()[i];
899      std::string tmp(e.str);
900      tmp.append("12");  
901      uint64_t value;
902      EXPECT_EQ(e.expect_ok,
903                safe_strtou64_base(absl::string_view(tmp.data(), strlen(e.str)),
904                                   &value, e.base))
905          << "str=\"" << e.str << "\" base=" << e.base;
906      if (e.expect_ok) {
907        EXPECT_EQ(e.expected, value) << "str=\"" << e.str << "\" base=" << e.base;
908      }
909    }
910  }
911  #if defined(__GLIBC__) || defined(__BIONIC__)
912  #define ABSL_HAVE_FEENABLEEXCEPT 1
913  #define ABSL_HAVE_FEDISABLEEXCEPT 1
914  #endif
915  class SimpleDtoaTest : public testing::Test {
916   protected:
917    void SetUp() override {
918      feholdexcept(&fp_env_);
919  #ifdef ABSL_HAVE_FEENABLEEXCEPT
920      feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
921  #endif
922    }
923    void TearDown() override {
924  #ifdef ABSL_HAVE_FEDISABLEEXCEPT
925      fedisableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
926  #endif
927      fesetenv(&fp_env_);
928    }
929    std::string ToNineDigits(double value) {
930      char buffer[16];  
931      snprintf(buffer, sizeof(buffer), "%.9g", value);
932      return buffer;
933    }
934    fenv_t fp_env_;
935  };
936  template <typename R>
937  void ExhaustiveFloat(uint32_t cases, R&& runnable) {
938    runnable(0.0f);
939    runnable(-0.0f);
940    if (cases >= 2e9) {  
941      for (float f = 0; f < std::numeric_limits<float>::max(); ) {
942        f = nextafterf(f, std::numeric_limits<float>::max());
943        runnable(-f);
944        runnable(f);
945      }
946      return;
947    }
948    std::set<float> floats = {3.4028234e38f};
949    for (float f : {1.0, 3.14159265, 2.718281828, 1 / 2.718281828}) {
950      for (float testf = f; testf != 0; testf *= 0.1f) floats.insert(testf);
951      for (float testf = f; testf != 0; testf *= 0.5f) floats.insert(testf);
952      for (float testf = f; testf < 3e38f / 2; testf *= 2.0f)
953        floats.insert(testf);
954      for (float testf = f; testf < 3e38f / 10; testf *= 10) floats.insert(testf);
955    }
956    float last = *floats.begin();
957    runnable(last);
958    runnable(-last);
959    int iters_per_float = cases / floats.size();
960    if (iters_per_float == 0) iters_per_float = 1;
961    for (float f : floats) {
962      if (f == last) continue;
963      float testf = std::nextafter(last, std::numeric_limits<float>::max());
964      runnable(testf);
965      runnable(-testf);
966      last = testf;
967      if (f == last) continue;
968      double step = (double{f} - last) / iters_per_float;
969      for (double d = last + step; d < f; d += step) {
970        testf = d;
971        if (testf != last) {
972          runnable(testf);
973          runnable(-testf);
974          last = testf;
975        }
976      }
977      testf = std::nextafter(f, 0.0f);
978      if (testf > last) {
979        runnable(testf);
980        runnable(-testf);
981        last = testf;
982      }
983      if (f != last) {
984        runnable(f);
985        runnable(-f);
986        last = f;
987      }
988    }
989  }
990  TEST_F(SimpleDtoaTest, ExhaustiveDoubleToSixDigits) {
991    uint64_t test_count = 0;
992    std::vector<double> mismatches;
993    auto checker = [&](double d) {
994      if (d != d) return;  
995      ++test_count;
996      char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
997      SixDigitsToBuffer(d, sixdigitsbuf);
998      char snprintfbuf[kSixDigitsToBufferSize] = {0};
999      snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1000      if (strcmp(sixdigitsbuf, snprintfbuf) != 0) {
1001        mismatches.push_back(d);
1002        if (mismatches.size() < 10) {
1003          LOG(ERROR) << "Six-digit failure with double.  d=" << d
1004                     << " sixdigits=" << sixdigitsbuf
1005                     << " printf(%g)=" << snprintfbuf;
1006        }
1007      }
1008    };
1009    checker(5e-324);
1010    checker(1e-308);
1011    checker(1.0);
1012    checker(1.000005);
1013    checker(1.7976931348623157e308);
1014    checker(0.00390625);
1015  #ifndef _MSC_VER
1016    checker(0.001953125);
1017  #endif
1018    checker(0.005859375);
1019    checker(1.089095e-15);
1020    checker(3.274195e-55);
1021    checker(6.534355e-146);
1022    checker(2.920845e+234);
1023    if (mismatches.empty()) {
1024      test_count = 0;
1025      ExhaustiveFloat(kFloatNumCases, checker);
1026      test_count = 0;
1027      std::vector<int> digit_testcases{
1028          100000, 100001, 100002, 100005, 100010, 100020, 100050, 100100,  
1029          195312, 195313,  
1030          200000, 500000, 800000,  
1031          585937, 585938,  
1032          900000, 990000, 999000, 999900, 999990, 999996, 999997, 999998, 999999};
1033      if (kFloatNumCases >= 1e9) {
1034        constexpr int min_mantissa = 100000, max_mantissa = 999999;
1035        digit_testcases.resize(max_mantissa - min_mantissa + 1);
1036        std::iota(digit_testcases.begin(), digit_testcases.end(), min_mantissa);
1037      }
1038      for (int exponent = -324; exponent <= 308; ++exponent) {
1039        double powten = absl::strings_internal::Pow10(exponent);
1040        if (powten == 0) powten = 5e-324;
1041        if (kFloatNumCases >= 1e9) {
1042          char buf[kSixDigitsToBufferSize];
1043          LOG(INFO) << "Exp " << exponent << " powten=" << powten << "(" << powten
1044                    << ") ("
1045                    << absl::string_view(buf, SixDigitsToBuffer(powten, buf))
1046                    << ")";
1047        }
1048        for (int digits : digit_testcases) {
1049          if (exponent == 308 && digits >= 179769) break;  
1050          double digiform = (digits + 0.5) * 0.00001;
1051          double testval = digiform * powten;
1052          double pretestval = nextafter(testval, 0);
1053          double posttestval = nextafter(testval, 1.7976931348623157e308);
1054          checker(testval);
1055          checker(pretestval);
1056          checker(posttestval);
1057        }
1058      }
1059    } else {
1060      EXPECT_EQ(mismatches.size(), 0);
1061      for (size_t i = 0; i < mismatches.size(); ++i) {
1062        if (i > 100) i = mismatches.size() - 1;
1063        double d = mismatches[i];
1064        char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
1065        SixDigitsToBuffer(d, sixdigitsbuf);
1066        char snprintfbuf[kSixDigitsToBufferSize] = {0};
1067        snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1068        double before = nextafter(d, 0.0);
1069        double after = nextafter(d, 1.7976931348623157e308);
1070        char b1[32], b2[kSixDigitsToBufferSize];
1071        LOG(ERROR) << "Mismatch #" << i << "  d=" << d << " (" << ToNineDigits(d)
1072                   << ") sixdigits='" << sixdigitsbuf << "' snprintf='"
1073                   << snprintfbuf << "' Before.=" << PerfectDtoa(before) << " "
1074                   << (SixDigitsToBuffer(before, b2), b2) << " vs snprintf="
1075                   << (snprintf(b1, sizeof(b1), "%g", before), b1)
1076                   << " Perfect=" << PerfectDtoa(d) << " "
1077                   << (SixDigitsToBuffer(d, b2), b2)
1078                   << " vs snprintf=" << (snprintf(b1, sizeof(b1), "%g", d), b1)
1079                   << " After.=." << PerfectDtoa(after) << " "
1080                   << (SixDigitsToBuffer(after, b2), b2) << " vs snprintf="
1081                   << (snprintf(b1, sizeof(b1), "%g", after), b1);
1082      }
1083    }
1084  }
1085  TEST(StrToInt32, Partial) {
1086    struct Int32TestLine {
1087      std::string input;
1088      bool status;
1089      int32_t value;
1090    };
1091    const int32_t int32_min = std::numeric_limits<int32_t>::min();
1092    const int32_t int32_max = std::numeric_limits<int32_t>::max();
1093    Int32TestLine int32_test_line[] = {
1094        {"", false, 0},
1095        {" ", false, 0},
1096        {"-", false, 0},
1097        {"123@@@", false, 123},
1098        {absl::StrCat(int32_min, int32_max), false, int32_min},
1099        {absl::StrCat(int32_max, int32_max), false, int32_max},
1100    };
1101    for (const Int32TestLine& test_line : int32_test_line) {
1102      int32_t value = -2;
1103      bool status = safe_strto32_base(test_line.input, &value, 10);
1104      EXPECT_EQ(test_line.status, status) << test_line.input;
1105      EXPECT_EQ(test_line.value, value) << test_line.input;
1106      value = -2;
1107      status = safe_strto32_base(test_line.input, &value, 10);
1108      EXPECT_EQ(test_line.status, status) << test_line.input;
1109      EXPECT_EQ(test_line.value, value) << test_line.input;
1110      value = -2;
1111      status = safe_strto32_base(absl::string_view(test_line.input), &value, 10);
1112      EXPECT_EQ(test_line.status, status) << test_line.input;
1113      EXPECT_EQ(test_line.value, value) << test_line.input;
1114    }
1115  }
1116  TEST(StrToUint32, Partial) {
1117    struct Uint32TestLine {
1118      std::string input;
1119      bool status;
1120      uint32_t value;
1121    };
1122    const uint32_t uint32_max = std::numeric_limits<uint32_t>::max();
1123    Uint32TestLine uint32_test_line[] = {
1124        {"", false, 0},
1125        {" ", false, 0},
1126        {"-", false, 0},
1127        {"123@@@", false, 123},
1128        {absl::StrCat(uint32_max, uint32_max), false, uint32_max},
1129    };
1130    for (const Uint32TestLine& test_line : uint32_test_line) {
1131      uint32_t value = 2;
1132      bool status = safe_strtou32_base(test_line.input, &value, 10);
1133      EXPECT_EQ(test_line.status, status) << test_line.input;
1134      EXPECT_EQ(test_line.value, value) << test_line.input;
1135      value = 2;
1136      status = safe_strtou32_base(test_line.input, &value, 10);
1137      EXPECT_EQ(test_line.status, status) << test_line.input;
1138      EXPECT_EQ(test_line.value, value) << test_line.input;
1139      value = 2;
1140      status = safe_strtou32_base(absl::string_view(test_line.input), &value, 10);
1141      EXPECT_EQ(test_line.status, status) << test_line.input;
1142      EXPECT_EQ(test_line.value, value) << test_line.input;
1143    }
1144  }
1145  TEST(StrToInt64, Partial) {
1146    struct Int64TestLine {
1147      std::string input;
1148      bool status;
1149      int64_t value;
1150    };
1151    const int64_t int64_min = std::numeric_limits<int64_t>::min();
1152    const int64_t int64_max = std::numeric_limits<int64_t>::max();
1153    Int64TestLine int64_test_line[] = {
1154        {"", false, 0},
1155        {" ", false, 0},
1156        {"-", false, 0},
1157        {"123@@@", false, 123},
1158        {absl::StrCat(int64_min, int64_max), false, int64_min},
1159        {absl::StrCat(int64_max, int64_max), false, int64_max},
1160    };
1161    for (const Int64TestLine& test_line : int64_test_line) {
1162      int64_t value = -2;
1163      bool status = safe_strto64_base(test_line.input, &value, 10);
1164      EXPECT_EQ(test_line.status, status) << test_line.input;
1165      EXPECT_EQ(test_line.value, value) << test_line.input;
1166      value = -2;
1167      status = safe_strto64_base(test_line.input, &value, 10);
1168      EXPECT_EQ(test_line.status, status) << test_line.input;
1169      EXPECT_EQ(test_line.value, value) << test_line.input;
1170      value = -2;
1171      status = safe_strto64_base(absl::string_view(test_line.input), &value, 10);
1172      EXPECT_EQ(test_line.status, status) << test_line.input;
1173      EXPECT_EQ(test_line.value, value) << test_line.input;
1174    }
1175  }
1176  TEST(StrToUint64, Partial) {
1177    struct Uint64TestLine {
1178      std::string input;
1179      bool status;
1180      uint64_t value;
1181    };
1182    const uint64_t uint64_max = std::numeric_limits<uint64_t>::max();
1183    Uint64TestLine uint64_test_line[] = {
1184        {"", false, 0},
1185        {" ", false, 0},
1186        {"-", false, 0},
1187        {"123@@@", false, 123},
1188        {absl::StrCat(uint64_max, uint64_max), false, uint64_max},
1189    };
1190    for (const Uint64TestLine& test_line : uint64_test_line) {
1191      uint64_t value = 2;
1192      bool status = safe_strtou64_base(test_line.input, &value, 10);
1193      EXPECT_EQ(test_line.status, status) << test_line.input;
1194      EXPECT_EQ(test_line.value, value) << test_line.input;
1195      value = 2;
1196      status = safe_strtou64_base(test_line.input, &value, 10);
1197      EXPECT_EQ(test_line.status, status) << test_line.input;
1198      EXPECT_EQ(test_line.value, value) << test_line.input;
1199      value = 2;
1200      status = safe_strtou64_base(absl::string_view(test_line.input), &value, 10);
1201      EXPECT_EQ(test_line.status, status) << test_line.input;
1202      EXPECT_EQ(test_line.value, value) << test_line.input;
1203    }
1204  }
1205  TEST(StrToInt32Base, PrefixOnly) {
1206    struct Int32TestLine {
1207      std::string input;
1208      bool status;
1209      int32_t value;
1210    };
1211    Int32TestLine int32_test_line[] = {
1212      { "", false, 0 },
1213      { "-", false, 0 },
1214      { "-0", true, 0 },
1215      { "0", true, 0 },
1216      { "0x", false, 0 },
1217      { "-0x", false, 0 },
1218    };
1219    const int base_array[] = { 0, 2, 8, 10, 16 };
1220    for (const Int32TestLine& line : int32_test_line) {
1221      for (const int base : base_array) {
1222        int32_t value = 2;
1223        bool status = safe_strto32_base(line.input.c_str(), &value, base);
1224        EXPECT_EQ(line.status, status) << line.input << " " << base;
1225        EXPECT_EQ(line.value, value) << line.input << " " << base;
1226        value = 2;
1227        status = safe_strto32_base(line.input, &value, base);
1228        EXPECT_EQ(line.status, status) << line.input << " " << base;
1229        EXPECT_EQ(line.value, value) << line.input << " " << base;
1230        value = 2;
1231        status = safe_strto32_base(absl::string_view(line.input), &value, base);
1232        EXPECT_EQ(line.status, status) << line.input << " " << base;
1233        EXPECT_EQ(line.value, value) << line.input << " " << base;
1234      }
1235    }
1236  }
1237  TEST(StrToUint32Base, PrefixOnly) {
1238    struct Uint32TestLine {
1239      std::string input;
1240      bool status;
1241      uint32_t value;
1242    };
1243    Uint32TestLine uint32_test_line[] = {
1244      { "", false, 0 },
1245      { "0", true, 0 },
1246      { "0x", false, 0 },
1247    };
1248    const int base_array[] = { 0, 2, 8, 10, 16 };
1249    for (const Uint32TestLine& line : uint32_test_line) {
1250      for (const int base : base_array) {
1251        uint32_t value = 2;
1252        bool status = safe_strtou32_base(line.input.c_str(), &value, base);
1253        EXPECT_EQ(line.status, status) << line.input << " " << base;
1254        EXPECT_EQ(line.value, value) << line.input << " " << base;
1255        value = 2;
1256        status = safe_strtou32_base(line.input, &value, base);
1257        EXPECT_EQ(line.status, status) << line.input << " " << base;
1258        EXPECT_EQ(line.value, value) << line.input << " " << base;
1259        value = 2;
1260        status = safe_strtou32_base(absl::string_view(line.input), &value, base);
1261        EXPECT_EQ(line.status, status) << line.input << " " << base;
1262        EXPECT_EQ(line.value, value) << line.input << " " << base;
1263      }
1264    }
1265  }
1266  TEST(StrToInt64Base, PrefixOnly) {
1267    struct Int64TestLine {
1268      std::string input;
1269      bool status;
1270      int64_t value;
1271    };
1272    Int64TestLine int64_test_line[] = {
1273      { "", false, 0 },
1274      { "-", false, 0 },
1275      { "-0", true, 0 },
1276      { "0", true, 0 },
1277      { "0x", false, 0 },
1278      { "-0x", false, 0 },
1279    };
1280    const int base_array[] = { 0, 2, 8, 10, 16 };
1281    for (const Int64TestLine& line : int64_test_line) {
1282      for (const int base : base_array) {
1283        int64_t value = 2;
1284        bool status = safe_strto64_base(line.input.c_str(), &value, base);
1285        EXPECT_EQ(line.status, status) << line.input << " " << base;
1286        EXPECT_EQ(line.value, value) << line.input << " " << base;
1287        value = 2;
1288        status = safe_strto64_base(line.input, &value, base);
1289        EXPECT_EQ(line.status, status) << line.input << " " << base;
1290        EXPECT_EQ(line.value, value) << line.input << " " << base;
1291        value = 2;
1292        status = safe_strto64_base(absl::string_view(line.input), &value, base);
1293        EXPECT_EQ(line.status, status) << line.input << " " << base;
1294        EXPECT_EQ(line.value, value) << line.input << " " << base;
1295      }
1296    }
1297  }
1298  TEST(StrToUint64Base, PrefixOnly) {
1299    struct Uint64TestLine {
1300      std::string input;
1301      bool status;
1302      uint64_t value;
1303    };
1304    Uint64TestLine uint64_test_line[] = {
1305      { "", false, 0 },
1306      { "0", true, 0 },
1307      { "0x", false, 0 },
1308    };
1309    const int base_array[] = { 0, 2, 8, 10, 16 };
1310    for (const Uint64TestLine& line : uint64_test_line) {
1311      for (const int base : base_array) {
1312        uint64_t value = 2;
1313        bool status = safe_strtou64_base(line.input.c_str(), &value, base);
1314        EXPECT_EQ(line.status, status) << line.input << " " << base;
1315        EXPECT_EQ(line.value, value) << line.input << " " << base;
1316        value = 2;
1317        status = safe_strtou64_base(line.input, &value, base);
1318        EXPECT_EQ(line.status, status) << line.input << " " << base;
1319        EXPECT_EQ(line.value, value) << line.input << " " << base;
1320        value = 2;
1321        status = safe_strtou64_base(absl::string_view(line.input), &value, base);
1322        EXPECT_EQ(line.status, status) << line.input << " " << base;
1323        EXPECT_EQ(line.value, value) << line.input << " " << base;
1324      }
1325    }
1326  }
1327  void TestFastHexToBufferZeroPad16(uint64_t v) {
1328    char buf[16];
1329    auto digits = absl::numbers_internal::FastHexToBufferZeroPad16(v, buf);
1330    absl::string_view res(buf, 16);
1331    char buf2[17];
1332    snprintf(buf2, sizeof(buf2), "%016" PRIx64, v);
1333    EXPECT_EQ(res, buf2) << v;
1334    size_t expected_digits = snprintf(buf2, sizeof(buf2), "%" PRIx64, v);
1335    EXPECT_EQ(digits, expected_digits) << v;
1336  }
1337  TEST(FastHexToBufferZeroPad16, Smoke) {
1338    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::min());
1339    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::max());
1340    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::min());
1341    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::max());
1342    absl::BitGen rng;
1343    for (int i = 0; i < 100000; ++i) {
1344      TestFastHexToBufferZeroPad16(
1345          absl::LogUniform(rng, std::numeric_limits<uint64_t>::min(),
1346                           std::numeric_limits<uint64_t>::max()));
1347    }
1348  }
1349  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</h3>
            <pre><code>1  #include "absl/strings/numbers.h"
2  #include <sys/types.h>
3  #include <cfenv>  
4  #include <cfloat>
5  #include <cinttypes>
6  #include <climits>
7  #include <cmath>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstdlib>
12  #include <cstring>
13  #include <limits>
14  #include <numeric>
15  #include <random>
16  #include <set>
17  #include <string>
18  #include <vector>
19  #include "gmock/gmock.h"
20  #include "gtest/gtest.h"
21  #include "absl/log/log.h"
22  #include "absl/random/distributions.h"
23  #include "absl/random/random.h"
24  #include "absl/strings/internal/numbers_test_common.h"
25  #include "absl/strings/internal/ostringstream.h"
26  #include "absl/strings/internal/pow10_helper.h"
27  #include "absl/strings/str_cat.h"
28  namespace {
29  using absl::SimpleAtoi;
30  using absl::SimpleHexAtoi;
31  using absl::numbers_internal::kSixDigitsToBufferSize;
32  using absl::numbers_internal::safe_strto32_base;
33  using absl::numbers_internal::safe_strto64_base;
34  using absl::numbers_internal::safe_strtou32_base;
35  using absl::numbers_internal::safe_strtou64_base;
36  using absl::numbers_internal::SixDigitsToBuffer;
37  using absl::strings_internal::Itoa;
38  using absl::strings_internal::strtouint32_test_cases;
39  using absl::strings_internal::strtouint64_test_cases;
40  using testing::Eq;
41  using testing::MatchesRegex;
42  const int kFloatNumCases = 5000000;
43  std::string PerfectDtoa(double d) {
44    if (d == 0) return "0";
45    if (d < 0) return "-" + PerfectDtoa(-d);
46    int64_t mantissa, exp = 0;
47    while (d >= 1ULL << 63) ++exp, d *= 0.5;
48    while ((mantissa = d) != d) --exp, d *= 2.0;
49    constexpr int maxlen = 1100;  
50    char buf[maxlen + 5];
51    for (int64_t num = mantissa, pos = maxlen; --pos >= 0;) {
52      buf[pos] = '0' + (num % 10);
53      num /= 10;
54    }
55    char* begin = &buf[0];
56    char* end = buf + maxlen;
57    for (int i = 0; i != exp; i += (exp > 0) ? 1 : -1) {
58      int carry = 0;
59      for (char* p = end; --p != begin;) {
60        int dig = *p - '0';
61        dig = dig * (exp > 0 ? 2 : 5) + carry;
62        carry = dig / 10;
63        dig %= 10;
64        *p = '0' + dig;
65      }
66    }
67    if (exp < 0) {
68      memmove(end + 1 + exp, end + exp, 1 - exp);
69      end[exp] = '.';
70      ++end;
71    }
72    while (*begin == '0' && begin[1] != '.') ++begin;
73    return {begin, end};
74  }
75  TEST(ToString, PerfectDtoa) {
76    EXPECT_THAT(PerfectDtoa(1), Eq("1"));
77    EXPECT_THAT(PerfectDtoa(0.1),
78                Eq("0.1000000000000000055511151231257827021181583404541015625"));
79    EXPECT_THAT(PerfectDtoa(1e24), Eq("999999999999999983222784"));
80    EXPECT_THAT(PerfectDtoa(5e-324), MatchesRegex("0.0000.*625"));
81    for (int i = 0; i < 100; ++i) {
82      for (double multiplier :
83           {1e-300, 1e-200, 1e-100, 0.1, 1.0, 10.0, 1e100, 1e300}) {
84        double d = multiplier * i;
85        std::string s = PerfectDtoa(d);
86        EXPECT_DOUBLE_EQ(d, strtod(s.c_str(), nullptr));
87      }
88    }
89  }
90  template <typename integer>
91  struct MyInteger {
92    integer i;
93    explicit constexpr MyInteger(integer i) : i(i) {}
94    constexpr operator integer() const { return i; }
95    constexpr MyInteger operator+(MyInteger other) const { return i + other.i; }
96    constexpr MyInteger operator-(MyInteger other) const { return i - other.i; }
97    constexpr MyInteger operator*(MyInteger other) const { return i * other.i; }
98    constexpr MyInteger operator/(MyInteger other) const { return i / other.i; }
99    constexpr bool operator<(MyInteger other) const { return i < other.i; }
100    constexpr bool operator<=(MyInteger other) const { return i <= other.i; }
101    constexpr bool operator==(MyInteger other) const { return i == other.i; }
102    constexpr bool operator>=(MyInteger other) const { return i >= other.i; }
103    constexpr bool operator>(MyInteger other) const { return i > other.i; }
104    constexpr bool operator!=(MyInteger other) const { return i != other.i; }
105    integer as_integer() const { return i; }
106  };
107  typedef MyInteger<int64_t> MyInt64;
108  typedef MyInteger<uint64_t> MyUInt64;
109  void CheckInt32(int32_t x) {
110    char buffer[absl::numbers_internal::kFastToBufferSize];
111    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
112    std::string expected = std::to_string(x);
113    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
114    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
115    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
116  }
117  void CheckInt64(int64_t x) {
118    char buffer[absl::numbers_internal::kFastToBufferSize + 3];
119    buffer[0] = '*';
120    buffer[23] = '*';
121    buffer[24] = '*';
122    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
123    std::string expected = std::to_string(x);
124    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
125    EXPECT_EQ(buffer[0], '*');
126    EXPECT_EQ(buffer[23], '*');
127    EXPECT_EQ(buffer[24], '*');
128    char* my_actual =
129        absl::numbers_internal::FastIntToBuffer(MyInt64(x), &buffer[1]);
130    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
131  }
132  void CheckUInt32(uint32_t x) {
133    char buffer[absl::numbers_internal::kFastToBufferSize];
134    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
135    std::string expected = std::to_string(x);
136    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
137    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
138    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
139  }
140  void CheckUInt64(uint64_t x) {
141    char buffer[absl::numbers_internal::kFastToBufferSize + 1];
142    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
143    std::string expected = std::to_string(x);
144    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
145    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
146    EXPECT_EQ(expected, std::string(&buffer[1], generic_actual))
147        << " Input " << x;
148    char* my_actual =
149        absl::numbers_internal::FastIntToBuffer(MyUInt64(x), &buffer[1]);
150    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
151  }
152  void CheckHex64(uint64_t v) {
153    char expected[16 + 1];
154    std::string actual = absl::StrCat(absl::Hex(v, absl::kZeroPad16));
155    snprintf(expected, sizeof(expected), "%016" PRIx64, static_cast<uint64_t>(v));
156    EXPECT_EQ(expected, actual) << " Input " << v;
157    actual = absl::StrCat(absl::Hex(v, absl::kSpacePad16));
158    snprintf(expected, sizeof(expected), "%16" PRIx64, static_cast<uint64_t>(v));
159    EXPECT_EQ(expected, actual) << " Input " << v;
160  }
161  TEST(Numbers, TestFastPrints) {
162    for (int i = -100; i <= 100; i++) {
163      CheckInt32(i);
164      CheckInt64(i);
165    }
166    for (int i = 0; i <= 100; i++) {
167      CheckUInt32(i);
168      CheckUInt64(i);
169    }
170    CheckInt32(INT_MIN);
171    CheckInt32(INT_MAX);
172    CheckInt64(LONG_MIN);
173    CheckInt64(uint64_t{1000000000});
174    CheckInt64(uint64_t{9999999999});
175    CheckInt64(uint64_t{100000000000000});
176    CheckInt64(uint64_t{999999999999999});
177    CheckInt64(uint64_t{1000000000000000000});
178    CheckInt64(uint64_t{1199999999999999999});
179    CheckInt64(int64_t{-700000000000000000});
180    CheckInt64(LONG_MAX);
181    CheckUInt32(std::numeric_limits<uint32_t>::max());
182    CheckUInt64(uint64_t{1000000000});
183    CheckUInt64(uint64_t{9999999999});
184    CheckUInt64(uint64_t{100000000000000});
185    CheckUInt64(uint64_t{999999999999999});
186    CheckUInt64(uint64_t{1000000000000000000});
187    CheckUInt64(uint64_t{1199999999999999999});
188    CheckUInt64(std::numeric_limits<uint64_t>::max());
189    for (int i = 0; i < 10000; i++) {
190      CheckHex64(i);
191    }
192    CheckHex64(uint64_t{0x123456789abcdef0});
193  }
194  template <typename int_type, typename in_val_type>
195  void VerifySimpleAtoiGood(in_val_type in_value, int_type exp_value) {
196    std::string s;
197    absl::strings_internal::OStringStream(&s) << in_value;
198    int_type x = static_cast<int_type>(~exp_value);
199    EXPECT_TRUE(SimpleAtoi(s, &x))
200        << "in_value=" << in_value << " s=" << s << " x=" << x;
201    EXPECT_EQ(exp_value, x);
202    x = static_cast<int_type>(~exp_value);
203    EXPECT_TRUE(SimpleAtoi(s.c_str(), &x));
204    EXPECT_EQ(exp_value, x);
205  }
206  template <typename int_type, typename in_val_type>
207  void VerifySimpleAtoiBad(in_val_type in_value) {
208    std::string s;
209    absl::strings_internal::OStringStream(&s) << in_value;
210    int_type x;
211    EXPECT_FALSE(SimpleAtoi(s, &x));
212    EXPECT_FALSE(SimpleAtoi(s.c_str(), &x));
213  }
214  TEST(NumbersTest, Atoi) {
215    VerifySimpleAtoiGood<int32_t>(0, 0);
216    VerifySimpleAtoiGood<int32_t>(42, 42);
217    VerifySimpleAtoiGood<int32_t>(-42, -42);
218    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
219                                  std::numeric_limits<int32_t>::min());
220    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
221                                  std::numeric_limits<int32_t>::max());
222    VerifySimpleAtoiGood<uint32_t>(0, 0);
223    VerifySimpleAtoiGood<uint32_t>(42, 42);
224    VerifySimpleAtoiBad<uint32_t>(-42);
225    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
<span onclick='openModal()' class='match'>226    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
227                                   std::numeric_limits<int32_t>::max());
228    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
</span>229                                   std::numeric_limits<uint32_t>::max());
230    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
231    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
232    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
233    VerifySimpleAtoiGood<int64_t>(0, 0);
234    VerifySimpleAtoiGood<int64_t>(42, 42);
235    VerifySimpleAtoiGood<int64_t>(-42, -42);
236    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
237                                  std::numeric_limits<int32_t>::min());
238    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
239                                  std::numeric_limits<int32_t>::max());
240    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
241                                  std::numeric_limits<uint32_t>::max());
242    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
243                                  std::numeric_limits<int64_t>::min());
244    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
245                                  std::numeric_limits<int64_t>::max());
246    VerifySimpleAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
247    VerifySimpleAtoiGood<uint64_t>(0, 0);
248    VerifySimpleAtoiGood<uint64_t>(42, 42);
249    VerifySimpleAtoiBad<uint64_t>(-42);
250    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
251    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
252                                   std::numeric_limits<int32_t>::max());
253    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
254                                   std::numeric_limits<uint32_t>::max());
255    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
256    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
257                                   std::numeric_limits<int64_t>::max());
258    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
259                                   std::numeric_limits<uint64_t>::max());
260    VerifySimpleAtoiGood<absl::uint128>(0, 0);
261    VerifySimpleAtoiGood<absl::uint128>(42, 42);
262    VerifySimpleAtoiBad<absl::uint128>(-42);
263    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
264    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
265                                        std::numeric_limits<int32_t>::max());
266    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
267                                        std::numeric_limits<uint32_t>::max());
268    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
269    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
270                                        std::numeric_limits<int64_t>::max());
271    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
272                                        std::numeric_limits<uint64_t>::max());
273    VerifySimpleAtoiGood<absl::uint128>(
274        std::numeric_limits<absl::uint128>::max(),
275        std::numeric_limits<absl::uint128>::max());
276    VerifySimpleAtoiGood<absl::int128>(0, 0);
277    VerifySimpleAtoiGood<absl::int128>(42, 42);
278    VerifySimpleAtoiGood<absl::int128>(-42, -42);
279    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::min(),
280                                        std::numeric_limits<int32_t>::min());
281    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::max(),
282                                        std::numeric_limits<int32_t>::max());
283    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint32_t>::max(),
284                                        std::numeric_limits<uint32_t>::max());
285    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::min(),
286                                        std::numeric_limits<int64_t>::min());
287    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::max(),
288                                        std::numeric_limits<int64_t>::max());
289    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint64_t>::max(),
290                                        std::numeric_limits<uint64_t>::max());
291    VerifySimpleAtoiGood<absl::int128>(
292        std::numeric_limits<absl::int128>::min(),
293        std::numeric_limits<absl::int128>::min());
294    VerifySimpleAtoiGood<absl::int128>(
295        std::numeric_limits<absl::int128>::max(),
296        std::numeric_limits<absl::int128>::max());
297    VerifySimpleAtoiBad<absl::int128>(std::numeric_limits<absl::uint128>::max());
298    VerifySimpleAtoiGood<int>(-42, -42);
299    VerifySimpleAtoiGood<int32_t>(-42, -42);
300    VerifySimpleAtoiGood<uint32_t>(42, 42);
301    VerifySimpleAtoiGood<unsigned int>(42, 42);
302    VerifySimpleAtoiGood<int64_t>(-42, -42);
303    VerifySimpleAtoiGood<long>(-42, -42);  
304    VerifySimpleAtoiGood<uint64_t>(42, 42);
305    VerifySimpleAtoiGood<size_t>(42, 42);
306    VerifySimpleAtoiGood<std::string::size_type>(42, 42);
307  }
308  TEST(NumbersTest, Atod) {
309  #if !defined(DBL_TRUE_MIN)
310    static constexpr double DBL_TRUE_MIN =
311        4.940656458412465441765687928682213723650598026143247644255856825e-324;
312  #endif
313  #if !defined(FLT_TRUE_MIN)
314    static constexpr float FLT_TRUE_MIN =
315        1.401298464324817070923729583289916131280261941876515771757068284e-45f;
316  #endif
317    double d;
318    float f;
319    EXPECT_TRUE(absl::SimpleAtod("NaN", &d));
320    EXPECT_TRUE(std::isnan(d));
321    EXPECT_TRUE(absl::SimpleAtod("nAN", &d));
322    EXPECT_TRUE(std::isnan(d));
323    EXPECT_TRUE(absl::SimpleAtod("-nan", &d));
324    EXPECT_TRUE(std::isnan(d));
325    EXPECT_TRUE(absl::SimpleAtod("inf", &d));
326    EXPECT_TRUE(std::isinf(d) && (d > 0));
327    EXPECT_TRUE(absl::SimpleAtod("+Infinity", &d));
328    EXPECT_TRUE(std::isinf(d) && (d > 0));
329    EXPECT_TRUE(absl::SimpleAtod("-INF", &d));
330    EXPECT_TRUE(std::isinf(d) && (d < 0));
331    EXPECT_TRUE(absl::SimpleAtod("1.7976931348623157e+308", &d));
332    EXPECT_EQ(d, 1.7976931348623157e+308);
333    EXPECT_TRUE(absl::SimpleAtod("5e308", &d));
334    EXPECT_TRUE(std::isinf(d) && (d > 0));
335    EXPECT_TRUE(absl::SimpleAtof("3.4028234663852886e+38", &f));
336    EXPECT_EQ(f, 3.4028234663852886e+38f);
337    EXPECT_TRUE(absl::SimpleAtof("7e38", &f));
338    EXPECT_TRUE(std::isinf(f) && (f > 0));
339    EXPECT_TRUE(absl::SimpleAtod("1e308", &d));
340    EXPECT_EQ(d, 1e308);
341    EXPECT_FALSE(std::isinf(d));
342    EXPECT_TRUE(absl::SimpleAtod("1e309", &d));
343    EXPECT_TRUE(std::isinf(d));
344    EXPECT_TRUE(absl::SimpleAtof("1e38", &f));
345    EXPECT_EQ(f, 1e38f);
346    EXPECT_FALSE(std::isinf(f));
347    EXPECT_TRUE(absl::SimpleAtof("1e39", &f));
348    EXPECT_TRUE(std::isinf(f));
349    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e307", &d));
350    EXPECT_EQ(d, 9.999999999999999999e307);
351    EXPECT_FALSE(std::isinf(d));
352    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e308", &d));
353    EXPECT_TRUE(std::isinf(d));
354    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e37", &f));
355    EXPECT_EQ(f, 9.999999999999999999e37f);
356    EXPECT_FALSE(std::isinf(f));
357    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e38", &f));
358    EXPECT_TRUE(std::isinf(f));
359    EXPECT_TRUE(absl::SimpleAtod("2.2250738585072014e-308", &d));
360    EXPECT_EQ(d, 2.2250738585072014e-308);
361    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-324", &d));
362    EXPECT_EQ(d, 4.9406564584124654e-324);
363    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-325", &d));
364    EXPECT_EQ(d, 0);
365    EXPECT_TRUE(absl::SimpleAtof("1.1754943508222875e-38", &f));
366    EXPECT_EQ(f, 1.1754943508222875e-38f);
367    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-45", &f));
368    EXPECT_EQ(f, 1.4012984643248171e-45f);
369    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-46", &f));
370    EXPECT_EQ(f, 0);
371    EXPECT_TRUE(absl::SimpleAtod("1e-307", &d));
372    EXPECT_EQ(d, 1e-307);
373    EXPECT_GE(d, DBL_MIN);
374    EXPECT_LT(d, DBL_MIN * 10);
375    EXPECT_TRUE(absl::SimpleAtod("1e-323", &d));
376    EXPECT_EQ(d, 1e-323);
377    EXPECT_GE(d, DBL_TRUE_MIN);
378    EXPECT_LT(d, DBL_TRUE_MIN * 10);
379    EXPECT_TRUE(absl::SimpleAtod("1e-324", &d));
380    EXPECT_EQ(d, 0);
381    EXPECT_TRUE(absl::SimpleAtof("1e-37", &f));
382    EXPECT_EQ(f, 1e-37f);
383    EXPECT_GE(f, FLT_MIN);
384    EXPECT_LT(f, FLT_MIN * 10);
385    EXPECT_TRUE(absl::SimpleAtof("1e-45", &f));
386    EXPECT_EQ(f, 1e-45f);
387    EXPECT_GE(f, FLT_TRUE_MIN);
388    EXPECT_LT(f, FLT_TRUE_MIN * 10);
389    EXPECT_TRUE(absl::SimpleAtof("1e-46", &f));
390    EXPECT_EQ(f, 0);
391    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-308", &d));
392    EXPECT_EQ(d, 9.999999999999999999e-308);
393    EXPECT_GE(d, DBL_MIN);
394    EXPECT_LT(d, DBL_MIN * 10);
395    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-324", &d));
396    EXPECT_EQ(d, 9.999999999999999999e-324);
397    EXPECT_GE(d, DBL_TRUE_MIN);
398    EXPECT_LT(d, DBL_TRUE_MIN * 10);
399    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-325", &d));
400    EXPECT_EQ(d, 0);
401    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-38", &f));
402    EXPECT_EQ(f, 9.999999999999999999e-38f);
403    EXPECT_GE(f, FLT_MIN);
404    EXPECT_LT(f, FLT_MIN * 10);
405    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-46", &f));
406    EXPECT_EQ(f, 9.999999999999999999e-46f);
407    EXPECT_GE(f, FLT_TRUE_MIN);
408    EXPECT_LT(f, FLT_TRUE_MIN * 10);
409    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-47", &f));
410    EXPECT_EQ(f, 0);
411    EXPECT_TRUE(absl::SimpleAtod("  \t\r\n  2.718", &d));
412    EXPECT_EQ(d, 2.718);
413    EXPECT_TRUE(absl::SimpleAtod("  3.141  ", &d));
414    EXPECT_EQ(d, 3.141);
415    EXPECT_FALSE(absl::SimpleAtod("n 0", &d));
416    EXPECT_FALSE(absl::SimpleAtod("0n ", &d));
417    EXPECT_TRUE(absl::SimpleAtod("000123", &d));
418    EXPECT_EQ(d, 123);
419    EXPECT_TRUE(absl::SimpleAtod("000.456", &d));
420    EXPECT_EQ(d, 0.456);
421    EXPECT_TRUE(absl::SimpleAtod(".5", &d));
422    EXPECT_EQ(d, 0.5);
423    EXPECT_TRUE(absl::SimpleAtod("-.707", &d));
424    EXPECT_EQ(d, -0.707);
425    EXPECT_TRUE(absl::SimpleAtod("+6.0221408e+23", &d));
426    EXPECT_EQ(d, 6.0221408e+23);
427    EXPECT_FALSE(absl::SimpleAtod("123_456", &d));
428    EXPECT_TRUE(absl::SimpleAtod("8.9", &d));
429    EXPECT_FALSE(absl::SimpleAtod("8,9", &d));
430    EXPECT_TRUE(absl::SimpleAtod("4503599627370497.5", &d));
431    EXPECT_EQ(d, 4503599627370497.5);
432    EXPECT_TRUE(absl::SimpleAtod("1e+23", &d));
433    EXPECT_EQ(d, 1e+23);
434    EXPECT_TRUE(absl::SimpleAtod("9223372036854775807", &d));
435    EXPECT_EQ(d, 9223372036854775807);
436    EXPECT_TRUE(absl::SimpleAtof("0.0625", &f));
437    EXPECT_EQ(f, 0.0625f);
438    EXPECT_TRUE(absl::SimpleAtof("20040229.0", &f));
439    EXPECT_EQ(f, 20040229.0f);
440    EXPECT_TRUE(absl::SimpleAtof("2147483647.0", &f));
441    EXPECT_EQ(f, 2147483647.0f);
442    EXPECT_TRUE(absl::SimpleAtod("122.416294033786585", &d));
443    EXPECT_EQ(d, 122.416294033786585);
444    EXPECT_TRUE(absl::SimpleAtof("122.416294033786585", &f));
445    EXPECT_EQ(f, 122.416294033786585f);
446  }
447  TEST(NumbersTest, Prefixes) {
448    double d;
449    EXPECT_FALSE(absl::SimpleAtod("++1", &d));
450    EXPECT_FALSE(absl::SimpleAtod("+-1", &d));
451    EXPECT_FALSE(absl::SimpleAtod("-+1", &d));
452    EXPECT_FALSE(absl::SimpleAtod("--1", &d));
453    EXPECT_TRUE(absl::SimpleAtod("-1", &d));
454    EXPECT_EQ(d, -1.);
455    EXPECT_TRUE(absl::SimpleAtod("+1", &d));
456    EXPECT_EQ(d, +1.);
457    float f;
458    EXPECT_FALSE(absl::SimpleAtof("++1", &f));
459    EXPECT_FALSE(absl::SimpleAtof("+-1", &f));
460    EXPECT_FALSE(absl::SimpleAtof("-+1", &f));
461    EXPECT_FALSE(absl::SimpleAtof("--1", &f));
462    EXPECT_TRUE(absl::SimpleAtof("-1", &f));
463    EXPECT_EQ(f, -1.f);
464    EXPECT_TRUE(absl::SimpleAtof("+1", &f));
465    EXPECT_EQ(f, +1.f);
466  }
467  TEST(NumbersTest, Atoenum) {
468    enum E01 {
469      E01_zero = 0,
470      E01_one = 1,
471    };
472    VerifySimpleAtoiGood<E01>(E01_zero, E01_zero);
473    VerifySimpleAtoiGood<E01>(E01_one, E01_one);
474    enum E_101 {
475      E_101_minusone = -1,
476      E_101_zero = 0,
477      E_101_one = 1,
478    };
479    VerifySimpleAtoiGood<E_101>(E_101_minusone, E_101_minusone);
480    VerifySimpleAtoiGood<E_101>(E_101_zero, E_101_zero);
481    VerifySimpleAtoiGood<E_101>(E_101_one, E_101_one);
482    enum E_bigint {
483      E_bigint_zero = 0,
484      E_bigint_one = 1,
485      E_bigint_max31 = static_cast<int32_t>(0x7FFFFFFF),
486    };
487    VerifySimpleAtoiGood<E_bigint>(E_bigint_zero, E_bigint_zero);
488    VerifySimpleAtoiGood<E_bigint>(E_bigint_one, E_bigint_one);
489    VerifySimpleAtoiGood<E_bigint>(E_bigint_max31, E_bigint_max31);
490    enum E_fullint {
491      E_fullint_zero = 0,
492      E_fullint_one = 1,
493      E_fullint_max31 = static_cast<int32_t>(0x7FFFFFFF),
494      E_fullint_min32 = INT32_MIN,
495    };
496    VerifySimpleAtoiGood<E_fullint>(E_fullint_zero, E_fullint_zero);
497    VerifySimpleAtoiGood<E_fullint>(E_fullint_one, E_fullint_one);
498    VerifySimpleAtoiGood<E_fullint>(E_fullint_max31, E_fullint_max31);
499    VerifySimpleAtoiGood<E_fullint>(E_fullint_min32, E_fullint_min32);
500    enum E_biguint {
501      E_biguint_zero = 0,
502      E_biguint_one = 1,
503      E_biguint_max31 = static_cast<uint32_t>(0x7FFFFFFF),
504      E_biguint_max32 = static_cast<uint32_t>(0xFFFFFFFF),
505    };
506    VerifySimpleAtoiGood<E_biguint>(E_biguint_zero, E_biguint_zero);
507    VerifySimpleAtoiGood<E_biguint>(E_biguint_one, E_biguint_one);
508    VerifySimpleAtoiGood<E_biguint>(E_biguint_max31, E_biguint_max31);
509    VerifySimpleAtoiGood<E_biguint>(E_biguint_max32, E_biguint_max32);
510  }
511  template <typename int_type, typename in_val_type>
512  void VerifySimpleHexAtoiGood(in_val_type in_value, int_type exp_value) {
513    std::string s;
514    absl::strings_internal::OStringStream strm(&s);
515    if (in_value >= 0) {
516      strm << std::hex << in_value;
517    } else {
518      strm << "-" << std::hex << -absl::uint128(in_value);
519    }
520    int_type x = static_cast<int_type>(~exp_value);
521    EXPECT_TRUE(SimpleHexAtoi(s, &x))
522        << "in_value=" << std::hex << in_value << " s=" << s << " x=" << x;
523    EXPECT_EQ(exp_value, x);
524    x = static_cast<int_type>(~exp_value);
525    EXPECT_TRUE(SimpleHexAtoi(
526        s.c_str(), &x));  
527    EXPECT_EQ(exp_value, x);
528  }
529  template <typename int_type, typename in_val_type>
530  void VerifySimpleHexAtoiBad(in_val_type in_value) {
531    std::string s;
532    absl::strings_internal::OStringStream strm(&s);
533    if (in_value >= 0) {
534      strm << std::hex << in_value;
535    } else {
536      strm << "-" << std::hex << -absl::uint128(in_value);
537    }
538    int_type x;
539    EXPECT_FALSE(SimpleHexAtoi(s, &x));
540    EXPECT_FALSE(SimpleHexAtoi(
541        s.c_str(), &x));  
542  }
543  TEST(NumbersTest, HexAtoi) {
544    VerifySimpleHexAtoiGood<int32_t>(0, 0);
545    VerifySimpleHexAtoiGood<int32_t>(0x42, 0x42);
546    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
547    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
548                                     std::numeric_limits<int32_t>::min());
549    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
550                                     std::numeric_limits<int32_t>::max());
551    VerifySimpleHexAtoiGood<uint32_t>(0, 0);
552    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
553    VerifySimpleHexAtoiBad<uint32_t>(-0x42);
554    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
555    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
556                                      std::numeric_limits<int32_t>::max());
557    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
558                                      std::numeric_limits<uint32_t>::max());
559    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
560    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
561    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
562    VerifySimpleHexAtoiGood<int64_t>(0, 0);
563    VerifySimpleHexAtoiGood<int64_t>(0x42, 0x42);
564    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
565    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
566                                     std::numeric_limits<int32_t>::min());
567    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
568                                     std::numeric_limits<int32_t>::max());
569    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
570                                     std::numeric_limits<uint32_t>::max());
571    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
572                                     std::numeric_limits<int64_t>::min());
573    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
574                                     std::numeric_limits<int64_t>::max());
575    VerifySimpleHexAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
576    VerifySimpleHexAtoiGood<uint64_t>(0, 0);
577    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
578    VerifySimpleHexAtoiBad<uint64_t>(-0x42);
579    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
580    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
581                                      std::numeric_limits<int32_t>::max());
582    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
583                                      std::numeric_limits<uint32_t>::max());
584    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
585    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
586                                      std::numeric_limits<int64_t>::max());
587    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
588                                      std::numeric_limits<uint64_t>::max());
589    VerifySimpleHexAtoiGood<absl::uint128>(0, 0);
590    VerifySimpleHexAtoiGood<absl::uint128>(0x42, 0x42);
591    VerifySimpleHexAtoiBad<absl::uint128>(-0x42);
592    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
593    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
594                                           std::numeric_limits<int32_t>::max());
595    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
596                                           std::numeric_limits<uint32_t>::max());
597    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
598    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
599                                           std::numeric_limits<int64_t>::max());
600    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
601                                           std::numeric_limits<uint64_t>::max());
602    VerifySimpleHexAtoiGood<absl::uint128>(
603        std::numeric_limits<absl::uint128>::max(),
604        std::numeric_limits<absl::uint128>::max());
605    VerifySimpleHexAtoiGood<int>(-0x42, -0x42);
606    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
607    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
608    VerifySimpleHexAtoiGood<unsigned int>(0x42, 0x42);
609    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
610    VerifySimpleHexAtoiGood<long>(-0x42, -0x42);  
611    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
612    VerifySimpleHexAtoiGood<size_t>(0x42, 0x42);
613    VerifySimpleHexAtoiGood<std::string::size_type>(0x42, 0x42);
614    int32_t value;
615    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
616    EXPECT_EQ(0x34234324, value);
617    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
618    EXPECT_EQ(0x34234324, value);
619    EXPECT_TRUE(safe_strto32_base(" \t\n 34234324", &value, 16));
620    EXPECT_EQ(0x34234324, value);
621    EXPECT_TRUE(safe_strto32_base("34234324 \t\n ", &value, 16));
622    EXPECT_EQ(0x34234324, value);
623  }
624  TEST(stringtest, safe_strto32_base) {
625    int32_t value;
626    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
627    EXPECT_EQ(0x34234324, value);
628    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
629    EXPECT_EQ(0x34234324, value);
630    EXPECT_TRUE(safe_strto32_base("34234324", &value, 16));
631    EXPECT_EQ(0x34234324, value);
632    EXPECT_TRUE(safe_strto32_base("0", &value, 16));
633    EXPECT_EQ(0, value);
634    EXPECT_TRUE(safe_strto32_base(" \t\n -0x34234324", &value, 16));
635    EXPECT_EQ(-0x34234324, value);
636    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 16));
637    EXPECT_EQ(-0x34234324, value);
638    EXPECT_TRUE(safe_strto32_base("7654321", &value, 8));
639    EXPECT_EQ(07654321, value);
640    EXPECT_TRUE(safe_strto32_base("-01234", &value, 8));
641    EXPECT_EQ(-01234, value);
642    EXPECT_FALSE(safe_strto32_base("1834", &value, 8));
643    EXPECT_TRUE(safe_strto32_base("0", &value, 0));
644    EXPECT_EQ(0, value);
645    EXPECT_TRUE(safe_strto32_base("077", &value, 0));
646    EXPECT_EQ(077, value);  
647    EXPECT_FALSE(safe_strto32_base("088", &value, 0));
648    EXPECT_FALSE(safe_strto32_base("0xG", &value, 0));
649    EXPECT_TRUE(safe_strto32_base("34234324", &value, 10));
650    EXPECT_EQ(34234324, value);
651    EXPECT_TRUE(safe_strto32_base("0", &value, 10));
652    EXPECT_EQ(0, value);
653    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 10));
654    EXPECT_EQ(-34234324, value);
655    EXPECT_TRUE(safe_strto32_base("34234324 \n\t ", &value, 10));
656    EXPECT_EQ(34234324, value);
657    EXPECT_FALSE(safe_strto32_base("", &value, 10));
658    EXPECT_FALSE(safe_strto32_base("  ", &value, 10));
659    EXPECT_FALSE(safe_strto32_base("abc", &value, 10));
660    EXPECT_FALSE(safe_strto32_base("34234324a", &value, 10));
661    EXPECT_FALSE(safe_strto32_base("34234.3", &value, 10));
662    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
663    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
664    EXPECT_TRUE(safe_strto32_base(std::string("0x1234"), &value, 16));
665    EXPECT_EQ(0x1234, value);
666    EXPECT_TRUE(safe_strto32_base("1234", &value, 10));
667    EXPECT_EQ(1234, value);
668  }
669  TEST(stringtest, safe_strto32_range) {
670    int32_t value;
671    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
672    EXPECT_EQ(std::numeric_limits<int32_t>::max(), value);
673    EXPECT_TRUE(safe_strto32_base("-2147483648", &value, 10));
674    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
675    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
676    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
677  }
678  TEST(stringtest, safe_strto64_range) {
679    int64_t value;
680    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
681    EXPECT_EQ(std::numeric_limits<int64_t>::max(), value);
682    EXPECT_TRUE(safe_strto64_base("-9223372036854775808", &value, 10));
683    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
684    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
685    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
686  }
687  TEST(stringtest, safe_strto32_leading_substring) {
688    int32_t value;
689    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 10));
690    EXPECT_EQ(4069, value);
691    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 8));
692    EXPECT_EQ(0406, value);
693    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 10));
694    EXPECT_EQ(4069, value);
695    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 16));
696    EXPECT_EQ(0x4069ba, value);
697    EXPECT_FALSE(safe_strto32_base("@@@", &value, 10));
698    EXPECT_EQ(0, value);  
699  }
700  TEST(stringtest, safe_strto64_leading_substring) {
701    int64_t value;
702    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 10));
703    EXPECT_EQ(4069, value);
704    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 8));
705    EXPECT_EQ(0406, value);
706    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 10));
707    EXPECT_EQ(4069, value);
708    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 16));
709    EXPECT_EQ(0x4069ba, value);
710    EXPECT_FALSE(safe_strto64_base("@@@", &value, 10));
711    EXPECT_EQ(0, value);  
712  }
713  TEST(stringtest, safe_strto64_base) {
714    int64_t value;
715    EXPECT_TRUE(safe_strto64_base("0x3423432448783446", &value, 16));
716    EXPECT_EQ(int64_t{0x3423432448783446}, value);
717    EXPECT_TRUE(safe_strto64_base("3423432448783446", &value, 16));
718    EXPECT_EQ(int64_t{0x3423432448783446}, value);
719    EXPECT_TRUE(safe_strto64_base("0", &value, 16));
720    EXPECT_EQ(0, value);
721    EXPECT_TRUE(safe_strto64_base(" \t\n -0x3423432448783446", &value, 16));
722    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
723    EXPECT_TRUE(safe_strto64_base(" \t\n -3423432448783446", &value, 16));
724    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
725    EXPECT_TRUE(safe_strto64_base("123456701234567012", &value, 8));
726    EXPECT_EQ(int64_t{0123456701234567012}, value);
727    EXPECT_TRUE(safe_strto64_base("-017777777777777", &value, 8));
728    EXPECT_EQ(int64_t{-017777777777777}, value);
729    EXPECT_FALSE(safe_strto64_base("19777777777777", &value, 8));
730    EXPECT_TRUE(safe_strto64_base("0", &value, 0));
731    EXPECT_EQ(0, value);
732    EXPECT_TRUE(safe_strto64_base("077", &value, 0));
733    EXPECT_EQ(077, value);  
734    EXPECT_FALSE(safe_strto64_base("088", &value, 0));
735    EXPECT_FALSE(safe_strto64_base("0xG", &value, 0));
736    EXPECT_TRUE(safe_strto64_base("34234324487834466", &value, 10));
737    EXPECT_EQ(int64_t{34234324487834466}, value);
738    EXPECT_TRUE(safe_strto64_base("0", &value, 10));
739    EXPECT_EQ(0, value);
740    EXPECT_TRUE(safe_strto64_base(" \t\n -34234324487834466", &value, 10));
741    EXPECT_EQ(int64_t{-34234324487834466}, value);
742    EXPECT_TRUE(safe_strto64_base("34234324487834466 \n\t ", &value, 10));
743    EXPECT_EQ(int64_t{34234324487834466}, value);
744    EXPECT_FALSE(safe_strto64_base("", &value, 10));
745    EXPECT_FALSE(safe_strto64_base("  ", &value, 10));
746    EXPECT_FALSE(safe_strto64_base("abc", &value, 10));
747    EXPECT_FALSE(safe_strto64_base("34234324487834466a", &value, 10));
748    EXPECT_FALSE(safe_strto64_base("34234487834466.3", &value, 10));
749    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
750    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
751    EXPECT_TRUE(safe_strto64_base(std::string("0x1234"), &value, 16));
752    EXPECT_EQ(0x1234, value);
753    EXPECT_TRUE(safe_strto64_base("1234", &value, 10));
754    EXPECT_EQ(1234, value);
755  }
756  const size_t kNumRandomTests = 10000;
757  template <typename IntType>
758  void test_random_integer_parse_base(bool (*parse_func)(absl::string_view,
759                                                         IntType* value,
760                                                         int base)) {
761    using RandomEngine = std::minstd_rand0;
762    std::random_device rd;
763    RandomEngine rng(rd());
764    std::uniform_int_distribution<IntType> random_int(
765        std::numeric_limits<IntType>::min());
766    std::uniform_int_distribution<int> random_base(2, 35);
767    for (size_t i = 0; i < kNumRandomTests; i++) {
768      IntType value = random_int(rng);
769      int base = random_base(rng);
770      std::string str_value;
771      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
772      IntType parsed_value;
773      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
774      EXPECT_EQ(parsed_value, value);
775      EXPECT_FALSE(
776          parse_func(absl::StrCat(std::numeric_limits<IntType>::max(), value),
777                     &parsed_value, base));
778      if (std::numeric_limits<IntType>::min() < 0) {
779        EXPECT_FALSE(
780            parse_func(absl::StrCat(std::numeric_limits<IntType>::min(), value),
781                       &parsed_value, base));
782      } else {
783        EXPECT_FALSE(parse_func(absl::StrCat("-", value), &parsed_value, base));
784      }
785    }
786  }
787  TEST(stringtest, safe_strto32_random) {
788    test_random_integer_parse_base<int32_t>(&safe_strto32_base);
789  }
790  TEST(stringtest, safe_strto64_random) {
791    test_random_integer_parse_base<int64_t>(&safe_strto64_base);
792  }
793  TEST(stringtest, safe_strtou32_random) {
794    test_random_integer_parse_base<uint32_t>(&safe_strtou32_base);
795  }
796  TEST(stringtest, safe_strtou64_random) {
797    test_random_integer_parse_base<uint64_t>(&safe_strtou64_base);
798  }
799  TEST(stringtest, safe_strtou128_random) {
800    using RandomEngine = std::minstd_rand0;
801    using IntType = absl::uint128;
802    constexpr auto parse_func = &absl::numbers_internal::safe_strtou128_base;
803    std::random_device rd;
804    RandomEngine rng(rd());
805    std::uniform_int_distribution<uint64_t> random_uint64(
806        std::numeric_limits<uint64_t>::min());
807    std::uniform_int_distribution<int> random_base(2, 35);
808    for (size_t i = 0; i < kNumRandomTests; i++) {
809      IntType value = random_uint64(rng);
810      value = (value << 64) + random_uint64(rng);
811      int base = random_base(rng);
812      std::string str_value;
813      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
814      IntType parsed_value;
815      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
816      EXPECT_EQ(parsed_value, value);
817      std::string s;
818      absl::strings_internal::OStringStream(&s)
819          << std::numeric_limits<IntType>::max() << value;
820      EXPECT_FALSE(parse_func(s, &parsed_value, base));
821      s.clear();
822      absl::strings_internal::OStringStream(&s) << "-" << value;
823      EXPECT_FALSE(parse_func(s, &parsed_value, base));
824    }
825  }
826  TEST(stringtest, safe_strto128_random) {
827    using RandomEngine = std::minstd_rand0;
828    using IntType = absl::int128;
829    constexpr auto parse_func = &absl::numbers_internal::safe_strto128_base;
830    std::random_device rd;
831    RandomEngine rng(rd());
832    std::uniform_int_distribution<int64_t> random_int64(
833        std::numeric_limits<int64_t>::min());
834    std::uniform_int_distribution<uint64_t> random_uint64(
835        std::numeric_limits<uint64_t>::min());
836    std::uniform_int_distribution<int> random_base(2, 35);
837    for (size_t i = 0; i < kNumRandomTests; ++i) {
838      int64_t high = random_int64(rng);
839      uint64_t low = random_uint64(rng);
840      IntType value = absl::MakeInt128(high, low);
841      int base = random_base(rng);
842      std::string str_value;
843      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
844      IntType parsed_value;
845      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
846      EXPECT_EQ(parsed_value, value);
847      std::string s;
848      absl::strings_internal::OStringStream(&s)
849          << std::numeric_limits<IntType>::max() << value;
850      EXPECT_FALSE(parse_func(s, &parsed_value, base));
851      s.clear();
852      absl::strings_internal::OStringStream(&s)
853          << std::numeric_limits<IntType>::min() << value;
854      EXPECT_FALSE(parse_func(s, &parsed_value, base));
855    }
856  }
857  TEST(stringtest, safe_strtou32_base) {
858    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
859      const auto& e = strtouint32_test_cases()[i];
860      uint32_t value;
861      EXPECT_EQ(e.expect_ok, safe_strtou32_base(e.str, &value, e.base))
862          << "str=\"" << e.str << "\" base=" << e.base;
863      if (e.expect_ok) {
864        EXPECT_EQ(e.expected, value) << "i=" << i << " str=\"" << e.str
865                                     << "\" base=" << e.base;
866      }
867    }
868  }
869  TEST(stringtest, safe_strtou32_base_length_delimited) {
870    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
871      const auto& e = strtouint32_test_cases()[i];
872      std::string tmp(e.str);
873      tmp.append("12");  
874      uint32_t value;
875      EXPECT_EQ(e.expect_ok,
876                safe_strtou32_base(absl::string_view(tmp.data(), strlen(e.str)),
877                                   &value, e.base))
878          << "str=\"" << e.str << "\" base=" << e.base;
879      if (e.expect_ok) {
880        EXPECT_EQ(e.expected, value) << "i=" << i << " str=" << e.str
881                                     << " base=" << e.base;
882      }
883    }
884  }
885  TEST(stringtest, safe_strtou64_base) {
886    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
887      const auto& e = strtouint64_test_cases()[i];
888      uint64_t value;
889      EXPECT_EQ(e.expect_ok, safe_strtou64_base(e.str, &value, e.base))
890          << "str=\"" << e.str << "\" base=" << e.base;
891      if (e.expect_ok) {
892        EXPECT_EQ(e.expected, value) << "str=" << e.str << " base=" << e.base;
893      }
894    }
895  }
896  TEST(stringtest, safe_strtou64_base_length_delimited) {
897    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
898      const auto& e = strtouint64_test_cases()[i];
899      std::string tmp(e.str);
900      tmp.append("12");  
901      uint64_t value;
902      EXPECT_EQ(e.expect_ok,
903                safe_strtou64_base(absl::string_view(tmp.data(), strlen(e.str)),
904                                   &value, e.base))
905          << "str=\"" << e.str << "\" base=" << e.base;
906      if (e.expect_ok) {
907        EXPECT_EQ(e.expected, value) << "str=\"" << e.str << "\" base=" << e.base;
908      }
909    }
910  }
911  #if defined(__GLIBC__) || defined(__BIONIC__)
912  #define ABSL_HAVE_FEENABLEEXCEPT 1
913  #define ABSL_HAVE_FEDISABLEEXCEPT 1
914  #endif
915  class SimpleDtoaTest : public testing::Test {
916   protected:
917    void SetUp() override {
918      feholdexcept(&fp_env_);
919  #ifdef ABSL_HAVE_FEENABLEEXCEPT
920      feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
921  #endif
922    }
923    void TearDown() override {
924  #ifdef ABSL_HAVE_FEDISABLEEXCEPT
925      fedisableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
926  #endif
927      fesetenv(&fp_env_);
928    }
929    std::string ToNineDigits(double value) {
930      char buffer[16];  
931      snprintf(buffer, sizeof(buffer), "%.9g", value);
932      return buffer;
933    }
934    fenv_t fp_env_;
935  };
936  template <typename R>
937  void ExhaustiveFloat(uint32_t cases, R&& runnable) {
938    runnable(0.0f);
939    runnable(-0.0f);
940    if (cases >= 2e9) {  
941      for (float f = 0; f < std::numeric_limits<float>::max(); ) {
942        f = nextafterf(f, std::numeric_limits<float>::max());
943        runnable(-f);
944        runnable(f);
945      }
946      return;
947    }
948    std::set<float> floats = {3.4028234e38f};
949    for (float f : {1.0, 3.14159265, 2.718281828, 1 / 2.718281828}) {
950      for (float testf = f; testf != 0; testf *= 0.1f) floats.insert(testf);
951      for (float testf = f; testf != 0; testf *= 0.5f) floats.insert(testf);
952      for (float testf = f; testf < 3e38f / 2; testf *= 2.0f)
953        floats.insert(testf);
954      for (float testf = f; testf < 3e38f / 10; testf *= 10) floats.insert(testf);
955    }
956    float last = *floats.begin();
957    runnable(last);
958    runnable(-last);
959    int iters_per_float = cases / floats.size();
960    if (iters_per_float == 0) iters_per_float = 1;
961    for (float f : floats) {
962      if (f == last) continue;
963      float testf = std::nextafter(last, std::numeric_limits<float>::max());
964      runnable(testf);
965      runnable(-testf);
966      last = testf;
967      if (f == last) continue;
968      double step = (double{f} - last) / iters_per_float;
969      for (double d = last + step; d < f; d += step) {
970        testf = d;
971        if (testf != last) {
972          runnable(testf);
973          runnable(-testf);
974          last = testf;
975        }
976      }
977      testf = std::nextafter(f, 0.0f);
978      if (testf > last) {
979        runnable(testf);
980        runnable(-testf);
981        last = testf;
982      }
983      if (f != last) {
984        runnable(f);
985        runnable(-f);
986        last = f;
987      }
988    }
989  }
990  TEST_F(SimpleDtoaTest, ExhaustiveDoubleToSixDigits) {
991    uint64_t test_count = 0;
992    std::vector<double> mismatches;
993    auto checker = [&](double d) {
994      if (d != d) return;  
995      ++test_count;
996      char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
997      SixDigitsToBuffer(d, sixdigitsbuf);
998      char snprintfbuf[kSixDigitsToBufferSize] = {0};
999      snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1000      if (strcmp(sixdigitsbuf, snprintfbuf) != 0) {
1001        mismatches.push_back(d);
1002        if (mismatches.size() < 10) {
1003          LOG(ERROR) << "Six-digit failure with double.  d=" << d
1004                     << " sixdigits=" << sixdigitsbuf
1005                     << " printf(%g)=" << snprintfbuf;
1006        }
1007      }
1008    };
1009    checker(5e-324);
1010    checker(1e-308);
1011    checker(1.0);
1012    checker(1.000005);
1013    checker(1.7976931348623157e308);
1014    checker(0.00390625);
1015  #ifndef _MSC_VER
1016    checker(0.001953125);
1017  #endif
1018    checker(0.005859375);
1019    checker(1.089095e-15);
1020    checker(3.274195e-55);
1021    checker(6.534355e-146);
1022    checker(2.920845e+234);
1023    if (mismatches.empty()) {
1024      test_count = 0;
1025      ExhaustiveFloat(kFloatNumCases, checker);
1026      test_count = 0;
1027      std::vector<int> digit_testcases{
1028          100000, 100001, 100002, 100005, 100010, 100020, 100050, 100100,  
1029          195312, 195313,  
1030          200000, 500000, 800000,  
1031          585937, 585938,  
1032          900000, 990000, 999000, 999900, 999990, 999996, 999997, 999998, 999999};
1033      if (kFloatNumCases >= 1e9) {
1034        constexpr int min_mantissa = 100000, max_mantissa = 999999;
1035        digit_testcases.resize(max_mantissa - min_mantissa + 1);
1036        std::iota(digit_testcases.begin(), digit_testcases.end(), min_mantissa);
1037      }
1038      for (int exponent = -324; exponent <= 308; ++exponent) {
1039        double powten = absl::strings_internal::Pow10(exponent);
1040        if (powten == 0) powten = 5e-324;
1041        if (kFloatNumCases >= 1e9) {
1042          char buf[kSixDigitsToBufferSize];
1043          LOG(INFO) << "Exp " << exponent << " powten=" << powten << "(" << powten
1044                    << ") ("
1045                    << absl::string_view(buf, SixDigitsToBuffer(powten, buf))
1046                    << ")";
1047        }
1048        for (int digits : digit_testcases) {
1049          if (exponent == 308 && digits >= 179769) break;  
1050          double digiform = (digits + 0.5) * 0.00001;
1051          double testval = digiform * powten;
1052          double pretestval = nextafter(testval, 0);
1053          double posttestval = nextafter(testval, 1.7976931348623157e308);
1054          checker(testval);
1055          checker(pretestval);
1056          checker(posttestval);
1057        }
1058      }
1059    } else {
1060      EXPECT_EQ(mismatches.size(), 0);
1061      for (size_t i = 0; i < mismatches.size(); ++i) {
1062        if (i > 100) i = mismatches.size() - 1;
1063        double d = mismatches[i];
1064        char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
1065        SixDigitsToBuffer(d, sixdigitsbuf);
1066        char snprintfbuf[kSixDigitsToBufferSize] = {0};
1067        snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1068        double before = nextafter(d, 0.0);
1069        double after = nextafter(d, 1.7976931348623157e308);
1070        char b1[32], b2[kSixDigitsToBufferSize];
1071        LOG(ERROR) << "Mismatch #" << i << "  d=" << d << " (" << ToNineDigits(d)
1072                   << ") sixdigits='" << sixdigitsbuf << "' snprintf='"
1073                   << snprintfbuf << "' Before.=" << PerfectDtoa(before) << " "
1074                   << (SixDigitsToBuffer(before, b2), b2) << " vs snprintf="
1075                   << (snprintf(b1, sizeof(b1), "%g", before), b1)
1076                   << " Perfect=" << PerfectDtoa(d) << " "
1077                   << (SixDigitsToBuffer(d, b2), b2)
1078                   << " vs snprintf=" << (snprintf(b1, sizeof(b1), "%g", d), b1)
1079                   << " After.=." << PerfectDtoa(after) << " "
1080                   << (SixDigitsToBuffer(after, b2), b2) << " vs snprintf="
1081                   << (snprintf(b1, sizeof(b1), "%g", after), b1);
1082      }
1083    }
1084  }
1085  TEST(StrToInt32, Partial) {
1086    struct Int32TestLine {
1087      std::string input;
1088      bool status;
1089      int32_t value;
1090    };
1091    const int32_t int32_min = std::numeric_limits<int32_t>::min();
1092    const int32_t int32_max = std::numeric_limits<int32_t>::max();
1093    Int32TestLine int32_test_line[] = {
1094        {"", false, 0},
1095        {" ", false, 0},
1096        {"-", false, 0},
1097        {"123@@@", false, 123},
1098        {absl::StrCat(int32_min, int32_max), false, int32_min},
1099        {absl::StrCat(int32_max, int32_max), false, int32_max},
1100    };
1101    for (const Int32TestLine& test_line : int32_test_line) {
1102      int32_t value = -2;
1103      bool status = safe_strto32_base(test_line.input, &value, 10);
1104      EXPECT_EQ(test_line.status, status) << test_line.input;
1105      EXPECT_EQ(test_line.value, value) << test_line.input;
1106      value = -2;
1107      status = safe_strto32_base(test_line.input, &value, 10);
1108      EXPECT_EQ(test_line.status, status) << test_line.input;
1109      EXPECT_EQ(test_line.value, value) << test_line.input;
1110      value = -2;
1111      status = safe_strto32_base(absl::string_view(test_line.input), &value, 10);
1112      EXPECT_EQ(test_line.status, status) << test_line.input;
1113      EXPECT_EQ(test_line.value, value) << test_line.input;
1114    }
1115  }
1116  TEST(StrToUint32, Partial) {
1117    struct Uint32TestLine {
1118      std::string input;
1119      bool status;
1120      uint32_t value;
1121    };
1122    const uint32_t uint32_max = std::numeric_limits<uint32_t>::max();
1123    Uint32TestLine uint32_test_line[] = {
1124        {"", false, 0},
1125        {" ", false, 0},
1126        {"-", false, 0},
1127        {"123@@@", false, 123},
1128        {absl::StrCat(uint32_max, uint32_max), false, uint32_max},
1129    };
1130    for (const Uint32TestLine& test_line : uint32_test_line) {
1131      uint32_t value = 2;
1132      bool status = safe_strtou32_base(test_line.input, &value, 10);
1133      EXPECT_EQ(test_line.status, status) << test_line.input;
1134      EXPECT_EQ(test_line.value, value) << test_line.input;
1135      value = 2;
1136      status = safe_strtou32_base(test_line.input, &value, 10);
1137      EXPECT_EQ(test_line.status, status) << test_line.input;
1138      EXPECT_EQ(test_line.value, value) << test_line.input;
1139      value = 2;
1140      status = safe_strtou32_base(absl::string_view(test_line.input), &value, 10);
1141      EXPECT_EQ(test_line.status, status) << test_line.input;
1142      EXPECT_EQ(test_line.value, value) << test_line.input;
1143    }
1144  }
1145  TEST(StrToInt64, Partial) {
1146    struct Int64TestLine {
1147      std::string input;
1148      bool status;
1149      int64_t value;
1150    };
1151    const int64_t int64_min = std::numeric_limits<int64_t>::min();
1152    const int64_t int64_max = std::numeric_limits<int64_t>::max();
1153    Int64TestLine int64_test_line[] = {
1154        {"", false, 0},
1155        {" ", false, 0},
1156        {"-", false, 0},
1157        {"123@@@", false, 123},
1158        {absl::StrCat(int64_min, int64_max), false, int64_min},
1159        {absl::StrCat(int64_max, int64_max), false, int64_max},
1160    };
1161    for (const Int64TestLine& test_line : int64_test_line) {
1162      int64_t value = -2;
1163      bool status = safe_strto64_base(test_line.input, &value, 10);
1164      EXPECT_EQ(test_line.status, status) << test_line.input;
1165      EXPECT_EQ(test_line.value, value) << test_line.input;
1166      value = -2;
1167      status = safe_strto64_base(test_line.input, &value, 10);
1168      EXPECT_EQ(test_line.status, status) << test_line.input;
1169      EXPECT_EQ(test_line.value, value) << test_line.input;
1170      value = -2;
1171      status = safe_strto64_base(absl::string_view(test_line.input), &value, 10);
1172      EXPECT_EQ(test_line.status, status) << test_line.input;
1173      EXPECT_EQ(test_line.value, value) << test_line.input;
1174    }
1175  }
1176  TEST(StrToUint64, Partial) {
1177    struct Uint64TestLine {
1178      std::string input;
1179      bool status;
1180      uint64_t value;
1181    };
1182    const uint64_t uint64_max = std::numeric_limits<uint64_t>::max();
1183    Uint64TestLine uint64_test_line[] = {
1184        {"", false, 0},
1185        {" ", false, 0},
1186        {"-", false, 0},
1187        {"123@@@", false, 123},
1188        {absl::StrCat(uint64_max, uint64_max), false, uint64_max},
1189    };
1190    for (const Uint64TestLine& test_line : uint64_test_line) {
1191      uint64_t value = 2;
1192      bool status = safe_strtou64_base(test_line.input, &value, 10);
1193      EXPECT_EQ(test_line.status, status) << test_line.input;
1194      EXPECT_EQ(test_line.value, value) << test_line.input;
1195      value = 2;
1196      status = safe_strtou64_base(test_line.input, &value, 10);
1197      EXPECT_EQ(test_line.status, status) << test_line.input;
1198      EXPECT_EQ(test_line.value, value) << test_line.input;
1199      value = 2;
1200      status = safe_strtou64_base(absl::string_view(test_line.input), &value, 10);
1201      EXPECT_EQ(test_line.status, status) << test_line.input;
1202      EXPECT_EQ(test_line.value, value) << test_line.input;
1203    }
1204  }
1205  TEST(StrToInt32Base, PrefixOnly) {
1206    struct Int32TestLine {
1207      std::string input;
1208      bool status;
1209      int32_t value;
1210    };
1211    Int32TestLine int32_test_line[] = {
1212      { "", false, 0 },
1213      { "-", false, 0 },
1214      { "-0", true, 0 },
1215      { "0", true, 0 },
1216      { "0x", false, 0 },
1217      { "-0x", false, 0 },
1218    };
1219    const int base_array[] = { 0, 2, 8, 10, 16 };
1220    for (const Int32TestLine& line : int32_test_line) {
1221      for (const int base : base_array) {
1222        int32_t value = 2;
1223        bool status = safe_strto32_base(line.input.c_str(), &value, base);
1224        EXPECT_EQ(line.status, status) << line.input << " " << base;
1225        EXPECT_EQ(line.value, value) << line.input << " " << base;
1226        value = 2;
1227        status = safe_strto32_base(line.input, &value, base);
1228        EXPECT_EQ(line.status, status) << line.input << " " << base;
1229        EXPECT_EQ(line.value, value) << line.input << " " << base;
1230        value = 2;
1231        status = safe_strto32_base(absl::string_view(line.input), &value, base);
1232        EXPECT_EQ(line.status, status) << line.input << " " << base;
1233        EXPECT_EQ(line.value, value) << line.input << " " << base;
1234      }
1235    }
1236  }
1237  TEST(StrToUint32Base, PrefixOnly) {
1238    struct Uint32TestLine {
1239      std::string input;
1240      bool status;
1241      uint32_t value;
1242    };
1243    Uint32TestLine uint32_test_line[] = {
1244      { "", false, 0 },
1245      { "0", true, 0 },
1246      { "0x", false, 0 },
1247    };
1248    const int base_array[] = { 0, 2, 8, 10, 16 };
1249    for (const Uint32TestLine& line : uint32_test_line) {
1250      for (const int base : base_array) {
1251        uint32_t value = 2;
1252        bool status = safe_strtou32_base(line.input.c_str(), &value, base);
1253        EXPECT_EQ(line.status, status) << line.input << " " << base;
1254        EXPECT_EQ(line.value, value) << line.input << " " << base;
1255        value = 2;
1256        status = safe_strtou32_base(line.input, &value, base);
1257        EXPECT_EQ(line.status, status) << line.input << " " << base;
1258        EXPECT_EQ(line.value, value) << line.input << " " << base;
1259        value = 2;
1260        status = safe_strtou32_base(absl::string_view(line.input), &value, base);
1261        EXPECT_EQ(line.status, status) << line.input << " " << base;
1262        EXPECT_EQ(line.value, value) << line.input << " " << base;
1263      }
1264    }
1265  }
1266  TEST(StrToInt64Base, PrefixOnly) {
1267    struct Int64TestLine {
1268      std::string input;
1269      bool status;
1270      int64_t value;
1271    };
1272    Int64TestLine int64_test_line[] = {
1273      { "", false, 0 },
1274      { "-", false, 0 },
1275      { "-0", true, 0 },
1276      { "0", true, 0 },
1277      { "0x", false, 0 },
1278      { "-0x", false, 0 },
1279    };
1280    const int base_array[] = { 0, 2, 8, 10, 16 };
1281    for (const Int64TestLine& line : int64_test_line) {
1282      for (const int base : base_array) {
1283        int64_t value = 2;
1284        bool status = safe_strto64_base(line.input.c_str(), &value, base);
1285        EXPECT_EQ(line.status, status) << line.input << " " << base;
1286        EXPECT_EQ(line.value, value) << line.input << " " << base;
1287        value = 2;
1288        status = safe_strto64_base(line.input, &value, base);
1289        EXPECT_EQ(line.status, status) << line.input << " " << base;
1290        EXPECT_EQ(line.value, value) << line.input << " " << base;
1291        value = 2;
1292        status = safe_strto64_base(absl::string_view(line.input), &value, base);
1293        EXPECT_EQ(line.status, status) << line.input << " " << base;
1294        EXPECT_EQ(line.value, value) << line.input << " " << base;
1295      }
1296    }
1297  }
1298  TEST(StrToUint64Base, PrefixOnly) {
1299    struct Uint64TestLine {
1300      std::string input;
1301      bool status;
1302      uint64_t value;
1303    };
1304    Uint64TestLine uint64_test_line[] = {
1305      { "", false, 0 },
1306      { "0", true, 0 },
1307      { "0x", false, 0 },
1308    };
1309    const int base_array[] = { 0, 2, 8, 10, 16 };
1310    for (const Uint64TestLine& line : uint64_test_line) {
1311      for (const int base : base_array) {
1312        uint64_t value = 2;
1313        bool status = safe_strtou64_base(line.input.c_str(), &value, base);
1314        EXPECT_EQ(line.status, status) << line.input << " " << base;
1315        EXPECT_EQ(line.value, value) << line.input << " " << base;
1316        value = 2;
1317        status = safe_strtou64_base(line.input, &value, base);
1318        EXPECT_EQ(line.status, status) << line.input << " " << base;
1319        EXPECT_EQ(line.value, value) << line.input << " " << base;
1320        value = 2;
1321        status = safe_strtou64_base(absl::string_view(line.input), &value, base);
1322        EXPECT_EQ(line.status, status) << line.input << " " << base;
1323        EXPECT_EQ(line.value, value) << line.input << " " << base;
1324      }
1325    }
1326  }
1327  void TestFastHexToBufferZeroPad16(uint64_t v) {
1328    char buf[16];
1329    auto digits = absl::numbers_internal::FastHexToBufferZeroPad16(v, buf);
1330    absl::string_view res(buf, 16);
1331    char buf2[17];
1332    snprintf(buf2, sizeof(buf2), "%016" PRIx64, v);
1333    EXPECT_EQ(res, buf2) << v;
1334    size_t expected_digits = snprintf(buf2, sizeof(buf2), "%" PRIx64, v);
1335    EXPECT_EQ(digits, expected_digits) << v;
1336  }
1337  TEST(FastHexToBufferZeroPad16, Smoke) {
1338    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::min());
1339    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::max());
1340    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::min());
1341    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::max());
1342    absl::BitGen rng;
1343    for (int i = 0; i < 100000; ++i) {
1344      TestFastHexToBufferZeroPad16(
1345          absl::LogUniform(rng, std::numeric_limits<uint64_t>::min(),
1346                           std::numeric_limits<uint64_t>::max()));
1347    }
1348  }
1349  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>258    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
259                                   std::numeric_limits<uint64_t>::max());
260    VerifySimpleAtoiGood<absl::uint128>(0, 0);
</pre></code></div>
                <div class="column column_space"><pre><code>226    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
227                                   std::numeric_limits<int32_t>::max());
228    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    