
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.208425720620843%, Tokens: 14</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-source_location.hpp</h3>
            <pre><code>1  #ifndef BOOST_ASSERT_SOURCE_LOCATION_HPP_INCLUDED
2  #define BOOST_ASSERT_SOURCE_LOCATION_HPP_INCLUDED
3  #include <boost/current_function.hpp>
4  #include <boost/config.hpp>
5  #include <boost/config/workaround.hpp>
6  #include <boost/cstdint.hpp>
7  #include <iosfwd>
8  #include <string>
9  #include <cstdio>
10  #include <cstring>
11  #if defined(__cpp_lib_source_location) && __cpp_lib_source_location >= 201907L
12  # include <source_location>
13  #endif
14  namespace boost
15  {
16  struct source_location
17  {
18  private:
19      char const * file_;
20      char const * function_;
21      boost::uint_least32_t line_;
22      boost::uint_least32_t column_;
23  public:
24      BOOST_CONSTEXPR source_location() BOOST_NOEXCEPT: file_( "" ), function_( "" ), line_( 0 ), column_( 0 )
25      {
26      }
27      BOOST_CONSTEXPR source_location( char const * file, boost::uint_least32_t ln, char const * function, boost::uint_least32_t col = 0 ) BOOST_NOEXCEPT: file_( file ), function_( function ), line_( ln ), column_( col )
28      {
29      }
30  #if defined(__cpp_lib_source_location) && __cpp_lib_source_location >= 201907L
31      BOOST_CONSTEXPR source_location( std::source_location const& loc ) BOOST_NOEXCEPT: file_( loc.file_name() ), function_( loc.function_name() ), line_( loc.line() ), column_( loc.column() )
32      {
33      }
34  #endif
35      BOOST_CONSTEXPR char const * file_name() const BOOST_NOEXCEPT
36      {
37          return file_;
38      }
<span onclick='openModal()' class='match'>39      BOOST_CONSTEXPR char const * function_name() const BOOST_NOEXCEPT
40      {
41          return function_;
42      }
43      BOOST_CONSTEXPR boost::uint_least32_t line() const BOOST_NOEXCEPT
44      {
45          return line_;
46      }
47      BOOST_CONSTEXPR boost::uint_least32_t column() const BOOST_NOEXCEPT
48      {
49          return column_;
50      }
51  #if defined(BOOST_MSVC)
52  # pragma warning( push )
53  # pragma warning( disable: 4996 )
54  #endif
55  #if ( defined(_MSC_VER) && _MSC_VER < 1900 ) || ( defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR) )
56  # define BOOST_ASSERT_SNPRINTF(buffer, format, arg) std::sprintf(buffer, format, arg)
57  #else
58  # define BOOST_ASSERT_SNPRINTF(buffer, format, arg) std::snprintf(buffer, sizeof(buffer)/sizeof(buffer[0]), format, arg)
59  #endif
60      std::string to_string() const
61      {
</span>62          unsigned long ln = line();
63          if( ln == 0 )
64          {
65              return "(unknown source location)";
66          }
67          std::string r = file_name();
68          char buffer[ 16 ];
69          BOOST_ASSERT_SNPRINTF( buffer, ":%lu", ln );
70          r += buffer;
71          unsigned long co = column();
72          if( co )
73          {
74              BOOST_ASSERT_SNPRINTF( buffer, ":%lu", co );
75              r += buffer;
76          }
77          char const* fn = function_name();
78          if( *fn != 0 )
79          {
80              r += " in function '";
81              r += fn;
82              r += '\'';
83          }
84          return r;
85      }
86  #undef BOOST_ASSERT_SNPRINTF
87  #if defined(BOOST_MSVC)
88  # pragma warning( pop )
89  #endif
90      inline friend bool operator==( source_location const& s1, source_location const& s2 ) BOOST_NOEXCEPT
91      {
92          return std::strcmp( s1.file_, s2.file_ ) == 0 && std::strcmp( s1.function_, s2.function_ ) == 0 && s1.line_ == s2.line_ && s1.column_ == s2.column_;
93      }
94      inline friend bool operator!=( source_location const& s1, source_location const& s2 ) BOOST_NOEXCEPT
95      {
96          return !( s1 == s2 );
97      }
98  };
99  template<class E, class T> std::basic_ostream<E, T> & operator<<( std::basic_ostream<E, T> & os, source_location const & loc )
100  {
101      os << loc.to_string();
102      return os;
103  }
104  } 
105  #if defined(BOOST_DISABLE_CURRENT_LOCATION)
106  # define BOOST_CURRENT_LOCATION ::boost::source_location()
107  #elif defined(BOOST_MSVC) && BOOST_MSVC >= 1926
108  # define BOOST_CURRENT_LOCATION ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION(), __builtin_COLUMN())
109  #elif defined(BOOST_MSVC)
110  # define BOOST_CURRENT_LOCATION_IMPL_1(x) BOOST_CURRENT_LOCATION_IMPL_2(x)
111  # define BOOST_CURRENT_LOCATION_IMPL_2(x) (x##0 / 10)
112  # define BOOST_CURRENT_LOCATION ::boost::source_location(__FILE__, BOOST_CURRENT_LOCATION_IMPL_1(__LINE__), "")
113  #elif defined(__cpp_lib_source_location) && __cpp_lib_source_location >= 201907L
114  # define BOOST_CURRENT_LOCATION ::boost::source_location(::std::source_location::current())
115  #elif defined(BOOST_CLANG) && BOOST_CLANG_VERSION >= 90000
116  # define BOOST_CURRENT_LOCATION ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION(), __builtin_COLUMN())
117  #elif defined(BOOST_GCC) && BOOST_GCC >= 70000
118  # define BOOST_CURRENT_LOCATION ::boost::source_location(__builtin_FILE(), __builtin_LINE(), __builtin_FUNCTION())
119  #elif defined(BOOST_GCC) && BOOST_GCC >= 50000
120  # define BOOST_CURRENT_LOCATION ::boost::source_location(__FILE__, __LINE__, __PRETTY_FUNCTION__)
121  #else
122  # define BOOST_CURRENT_LOCATION ::boost::source_location(__FILE__, __LINE__, "")
123  #endif
124  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_INTERNAL_CORD_REP_RING_H_
2  #define ABSL_STRINGS_INTERNAL_CORD_REP_RING_H_
3  #include <cassert>
4  #include <cstddef>
5  #include <cstdint>
6  #include <iosfwd>
7  #include <limits>
8  #include <memory>
9  #include "absl/container/internal/layout.h"
10  #include "absl/strings/internal/cord_internal.h"
11  #include "absl/strings/internal/cord_rep_flat.h"
12  namespace absl {
13  ABSL_NAMESPACE_BEGIN
14  namespace cord_internal {
15  class CordRepRing : public CordRep {
16   public:
17    using pos_type = size_t;
18    using index_type = uint32_t;
19    using offset_type = uint32_t;
20    struct Position {
21      index_type index;
22      size_t offset;
23    };
24    static constexpr size_t kMaxCapacity = (std::numeric_limits<uint32_t>::max)();
25    CordRepRing() = delete;
26    CordRepRing(const CordRepRing&) = delete;
27    CordRepRing& operator=(const CordRepRing&) = delete;
28    bool IsValid(std::ostream& output) const;
29    static constexpr size_t AllocSize(size_t capacity);
30    static constexpr size_t Distance(pos_type pos, pos_type end_pos);
31    static CordRepRing* Create(CordRep* child, size_t extra = 0);
<span onclick='openModal()' class='match'>32    index_type head() const { return head_; }
33    index_type tail() const { return tail_; }
34    index_type capacity() const { return capacity_; }
35    index_type entries() const { return entries(head_, tail_); }
</span>36    pos_type begin_pos() const { return begin_pos_; }
37    index_type entries(index_type head, index_type tail) const {
38      assert(head < capacity_ && tail < capacity_);
39      return tail - head + ((tail > head) ? 0 : capacity_);
40    }
41    pos_type const& entry_end_pos(index_type index) const {
42      assert(IsValidIndex(index));
43      return Layout::Partial().Pointer<0>(data_)[index];
44    }
45    CordRep* const& entry_child(index_type index) const {
46      assert(IsValidIndex(index));
47      return Layout::Partial(capacity()).Pointer<1>(data_)[index];
48    }
49    offset_type const& entry_data_offset(index_type index) const {
50      assert(IsValidIndex(index));
51      return Layout::Partial(capacity(), capacity()).Pointer<2>(data_)[index];
52    }
53    static CordRepRing* Append(CordRepRing* rep, CordRep* child);
54    static CordRepRing* Append(CordRepRing* rep, string_view data,
55                               size_t extra = 0);
56    static CordRepRing* Prepend(CordRepRing* rep, CordRep* child);
57    static CordRepRing* Prepend(CordRepRing* rep, string_view data,
58                                size_t extra = 0);
59    Span<char> GetAppendBuffer(size_t size);
60    Span<char> GetPrependBuffer(size_t size);
61    static CordRepRing* SubRing(CordRepRing* r, size_t offset, size_t len,
62                                size_t extra = 0);
63    static CordRepRing* RemoveSuffix(CordRepRing* r, size_t len,
64                                     size_t extra = 0);
65    static CordRepRing* RemovePrefix(CordRepRing* r, size_t len,
66                                     size_t extra = 0);
67    char GetCharacter(size_t offset) const;
68    bool IsFlat(absl::string_view* fragment) const;
69    bool IsFlat(size_t offset, size_t len, absl::string_view* fragment) const;
70    void SetCapacityForTesting(size_t capacity);
71    static const char* GetLeafData(const CordRep* rep);
72    static const char* GetRepData(const CordRep* rep);
73    inline index_type advance(index_type index) const;
74    inline index_type advance(index_type index, index_type n) const;
75    inline index_type retreat(index_type index) const;
76    inline index_type retreat(index_type index, index_type n) const;
77    pos_type const& entry_begin_pos(index_type index) const {
78      return (index == head_) ? begin_pos_ : entry_end_pos(retreat(index));
79    }
80    size_t entry_start_offset(index_type index) const {
81      return Distance(begin_pos_, entry_begin_pos(index));
82    }
83    size_t entry_end_offset(index_type index) const {
84      return Distance(begin_pos_, entry_end_pos(index));
85    }
86    size_t entry_length(index_type index) const {
87      return Distance(entry_begin_pos(index), entry_end_pos(index));
88    }
89    absl::string_view entry_data(index_type index) const;
90    inline Position Find(size_t offset) const;
91    inline Position Find(index_type head, size_t offset) const;
92    inline Position FindTail(size_t offset) const;
93    inline Position FindTail(index_type head, size_t offset) const;
94    template <typename F>
95    void ForEach(index_type head, index_type tail, F&& f) const {
96      index_type n1 = (tail > head) ? tail : capacity_;
97      for (index_type i = head; i < n1; ++i) f(i);
98      if (tail <= head) {
99        for (index_type i = 0; i < tail; ++i) f(i);
100      }
101    }
102    template <typename F>
103    void ForEach(F&& f) const {
104      ForEach(head_, tail_, std::forward<F>(f));
105    }
106    friend std::ostream& operator<<(std::ostream& s, const CordRepRing& rep);
107   private:
108    enum class AddMode { kAppend, kPrepend };
109    using Layout = container_internal::Layout<pos_type, CordRep*, offset_type>;
110    class Filler;
111    class Transaction;
112    class CreateTransaction;
113    static constexpr size_t kLayoutAlignment = Layout::Partial().Alignment();
114    explicit CordRepRing(index_type capacity) : capacity_(capacity) {}
115    bool IsValidIndex(index_type index) const;
116    static CordRepRing* Validate(CordRepRing* rep, const char* file = nullptr,
117                                 int line = 0);
118    static CordRepRing* New(size_t capacity, size_t extra);
119    static void Delete(CordRepRing* rep);
120    static void Destroy(CordRepRing* rep);
121    pos_type* entry_end_pos() {
122      return Layout::Partial().Pointer<0>(data_);
123    }
124    CordRep** entry_child() {
125      return Layout::Partial(capacity()).Pointer<1>(data_);
126    }
127    offset_type* entry_data_offset() {
128      return Layout::Partial(capacity(), capacity()).Pointer<2>(data_);
129    }
130    Position FindSlow(index_type head, size_t offset) const;
131    Position FindTailSlow(index_type head, size_t offset) const;
132    template <bool wrap>
133    index_type FindBinary(index_type head, index_type tail, size_t offset) const;
134    template <bool ref>
135    void Fill(const CordRepRing* src, index_type head, index_type tail);
136    static CordRepRing* Copy(CordRepRing* rep, index_type head, index_type tail,
137                             size_t extra = 0);
138    static CordRepRing* Mutable(CordRepRing* rep, size_t extra);
139    static CordRepRing* AppendSlow(CordRepRing* rep, CordRep* child);
140    static CordRepRing* AppendLeaf(CordRepRing* rep, CordRep* child,
141                                   size_t offset, size_t length);
142    static CordRepRing* PrependLeaf(CordRepRing* rep, CordRep* child,
143                                    size_t offset, size_t length);
144    static CordRepRing* PrependSlow(CordRepRing* rep, CordRep* child);
145    static CordRepRing* CreateSlow(CordRep* child, size_t extra);
146    static CordRepRing* CreateFromLeaf(CordRep* child, size_t offset,
147                                       size_t length, size_t extra);
148    template <AddMode mode>
149    static CordRepRing* AddRing(CordRepRing* rep, CordRepRing* ring,
150                                size_t offset, size_t len);
151    void AddDataOffset(index_type index, size_t n);
152    void SubLength(index_type index, size_t n);
153    index_type head_;
154    index_type tail_;
155    index_type capacity_;
156    pos_type begin_pos_;
157    alignas(kLayoutAlignment) char data_[kLayoutAlignment];
158    friend struct CordRep;
159  };
160  constexpr size_t CordRepRing::AllocSize(size_t capacity) {
161    return sizeof(CordRepRing) - sizeof(data_) +
162           Layout(capacity, capacity, capacity).AllocSize();
163  }
164  inline constexpr size_t CordRepRing::Distance(pos_type pos, pos_type end_pos) {
165    return (end_pos - pos);
166  }
167  inline const char* CordRepRing::GetLeafData(const CordRep* rep) {
168    return rep->tag != EXTERNAL ? rep->flat()->Data() : rep->external()->base;
169  }
170  inline const char* CordRepRing::GetRepData(const CordRep* rep) {
171    if (rep->tag >= FLAT) return rep->flat()->Data();
172    if (rep->tag == EXTERNAL) return rep->external()->base;
173    return GetLeafData(rep->substring()->child) + rep->substring()->start;
174  }
175  inline CordRepRing::index_type CordRepRing::advance(index_type index) const {
176    assert(index < capacity_);
177    return ++index == capacity_ ? 0 : index;
178  }
179  inline CordRepRing::index_type CordRepRing::advance(index_type index,
180                                                      index_type n) const {
181    assert(index < capacity_ && n <= capacity_);
182    return (index += n) >= capacity_ ? index - capacity_ : index;
183  }
184  inline CordRepRing::index_type CordRepRing::retreat(index_type index) const {
185    assert(index < capacity_);
186    return (index > 0 ? index : capacity_) - 1;
187  }
188  inline CordRepRing::index_type CordRepRing::retreat(index_type index,
189                                                      index_type n) const {
190    assert(index < capacity_ && n <= capacity_);
191    return index >= n ? index - n : capacity_ - n + index;
192  }
193  inline absl::string_view CordRepRing::entry_data(index_type index) const {
194    size_t data_offset = entry_data_offset(index);
195    return {GetRepData(entry_child(index)) + data_offset, entry_length(index)};
196  }
197  inline bool CordRepRing::IsValidIndex(index_type index) const {
198    if (index >= capacity_) return false;
199    return (tail_ > head_) ? (index >= head_ && index < tail_)
200                           : (index >= head_ || index < tail_);
201  }
202  #ifndef EXTRA_CORD_RING_VALIDATION
203  inline CordRepRing* CordRepRing::Validate(CordRepRing* rep,
204                                            const char* &bsol;*file*/, int &bsol;*line*/) {
205    return rep;
206  }
207  #endif
208  inline CordRepRing::Position CordRepRing::Find(size_t offset) const {
209    assert(offset < length);
210    return (offset == 0) ? Position{head_, 0} : FindSlow(head_, offset);
211  }
212  inline CordRepRing::Position CordRepRing::Find(index_type head,
213                                                 size_t offset) const {
214    assert(offset < length);
215    assert(IsValidIndex(head) && offset >= entry_start_offset(head));
216    return (offset == 0) ? Position{head_, 0} : FindSlow(head, offset);
217  }
218  inline CordRepRing::Position CordRepRing::FindTail(size_t offset) const {
219    assert(offset > 0 && offset <= length);
220    return (offset == length) ? Position{tail_, 0} : FindTailSlow(head_, offset);
221  }
222  inline CordRepRing::Position CordRepRing::FindTail(index_type head,
223                                                     size_t offset) const {
224    assert(offset > 0 && offset <= length);
225    assert(IsValidIndex(head) && offset >= entry_start_offset(head) + 1);
226    return (offset == length) ? Position{tail_, 0} : FindTailSlow(head, offset);
227  }
228  inline CordRepRing* CordRep::ring() {
229    assert(IsRing());
230    return static_cast<CordRepRing*>(this);
231  }
232  inline const CordRepRing* CordRep::ring() const {
233    assert(IsRing());
234    return static_cast<const CordRepRing*>(this);
235  }
236  inline bool CordRepRing::IsFlat(absl::string_view* fragment) const {
237    if (entries() == 1) {
238      if (fragment) *fragment = entry_data(head());
239      return true;
240    }
241    return false;
242  }
243  inline bool CordRepRing::IsFlat(size_t offset, size_t len,
244                                  absl::string_view* fragment) const {
245    const Position pos = Find(offset);
246    const absl::string_view data = entry_data(pos.index);
247    if (data.length() >= len && data.length() - len >= pos.offset) {
248      if (fragment) *fragment = data.substr(pos.offset, len);
249      return true;
250    }
251    return false;
252  }
253  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep);
254  }  
255  ABSL_NAMESPACE_END
256  }  
257  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-source_location.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.h</div>
                <div class="column column_space"><pre><code>39      BOOST_CONSTEXPR char const * function_name() const BOOST_NOEXCEPT
40      {
41          return function_;
42      }
43      BOOST_CONSTEXPR boost::uint_least32_t line() const BOOST_NOEXCEPT
44      {
45          return line_;
46      }
47      BOOST_CONSTEXPR boost::uint_least32_t column() const BOOST_NOEXCEPT
48      {
49          return column_;
50      }
51  #if defined(BOOST_MSVC)
52  # pragma warning( push )
53  # pragma warning( disable: 4996 )
54  #endif
55  #if ( defined(_MSC_VER) && _MSC_VER < 1900 ) || ( defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR) )
56  # define BOOST_ASSERT_SNPRINTF(buffer, format, arg) std::sprintf(buffer, format, arg)
57  #else
58  # define BOOST_ASSERT_SNPRINTF(buffer, format, arg) std::snprintf(buffer, sizeof(buffer)/sizeof(buffer[0]), format, arg)
59  #endif
60      std::string to_string() const
61      {
</pre></code></div>
                <div class="column column_space"><pre><code>32    index_type head() const { return head_; }
33    index_type tail() const { return tail_; }
34    index_type capacity() const { return capacity_; }
35    index_type entries() const { return entries(head_, tail_); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    