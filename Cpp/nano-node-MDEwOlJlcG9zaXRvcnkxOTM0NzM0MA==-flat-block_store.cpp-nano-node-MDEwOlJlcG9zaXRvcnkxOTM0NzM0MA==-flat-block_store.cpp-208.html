
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/lmdbconfig.hpp&gt;
3  #include &lt;nano/lib/logger_mt.hpp&gt;
4  #include &lt;nano/lib/stats.hpp&gt;
5  #include &lt;nano/lib/utility.hpp&gt;
6  #include &lt;nano/lib/work.hpp&gt;
7  #include &lt;nano/node/common.hpp&gt;
8  #include &lt;nano/node/lmdb/lmdb.hpp&gt;
9  #include &lt;nano/node/rocksdb/rocksdb.hpp&gt;
10  #include &lt;nano/secure/ledger.hpp&gt;
11  #include &lt;nano/secure/utility.hpp&gt;
12  #include &lt;nano/secure/versioning.hpp&gt;
13  #include &lt;nano/test_common/system.hpp&gt;
14  #include &lt;nano/test_common/testutil.hpp&gt;
15  #include &lt;gtest/gtest.h&gt;
16  #include &lt;boost/filesystem.hpp&gt;
17  #include &lt;cstdlib&gt;
18  #include &lt;fstream&gt;
19  #include &lt;unordered_set&gt;
20  #include &lt;vector&gt;
21  using namespace std::chrono_literals;
22  namespace nano
23  {
24  namespace lmdb
25  {
26  	void modify_account_info_to_v14 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction_a, nano::account const &amp; account_a, uint64_t confirmation_height, nano::block_hash const &amp; rep_block);
27  	void modify_confirmation_height_to_v15 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height);
28  	void write_sideband_v14 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a, MDB_dbi db_a);
29  	void write_sideband_v15 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a);
30  	void write_block_w_sideband_v18 (nano::lmdb::store &amp; store_a, MDB_dbi database, nano::write_transaction &amp; transaction_a, nano::block const &amp; block_a);
31  }
32  }
33  TEST (block_store, construction)
34  {
35  	nano::logger_mt logger;
36  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
37  	ASSERT_TRUE (!store-&gt;init_error ());
38  }
39  TEST (block_store, block_details)
40  {
41  	nano::block_details details_send (nano::epoch::epoch_0, true, false, false);
42  	ASSERT_TRUE (details_send.is_send);
43  	ASSERT_FALSE (details_send.is_receive);
44  	ASSERT_FALSE (details_send.is_epoch);
45  	ASSERT_EQ (nano::epoch::epoch_0, details_send.epoch);
46  	nano::block_details details_receive (nano::epoch::epoch_1, false, true, false);
47  	ASSERT_FALSE (details_receive.is_send);
48  	ASSERT_TRUE (details_receive.is_receive);
49  	ASSERT_FALSE (details_receive.is_epoch);
50  	ASSERT_EQ (nano::epoch::epoch_1, details_receive.epoch);
51  	nano::block_details details_epoch (nano::epoch::epoch_2, false, false, true);
52  	ASSERT_FALSE (details_epoch.is_send);
53  	ASSERT_FALSE (details_epoch.is_receive);
54  	ASSERT_TRUE (details_epoch.is_epoch);
55  	ASSERT_EQ (nano::epoch::epoch_2, details_epoch.epoch);
56  	nano::block_details details_none (nano::epoch::unspecified, false, false, false);
57  	ASSERT_FALSE (details_none.is_send);
58  	ASSERT_FALSE (details_none.is_receive);
59  	ASSERT_FALSE (details_none.is_epoch);
60  	ASSERT_EQ (nano::epoch::unspecified, details_none.epoch);
61  }
62  TEST (block_store, block_details_serialization)
63  {
64  	nano::block_details details1;
65  	details1.epoch = nano::epoch::epoch_2;
66  	details1.is_epoch = false;
67  	details1.is_receive = true;
68  	details1.is_send = false;
69  	std::vector&lt;uint8_t&gt; vector;
70  	{
71  		nano::vectorstream stream1 (vector);
72  		details1.serialize (stream1);
73  	}
74  	nano::bufferstream stream2 (vector.data (), vector.size ());
75  	nano::block_details details2;
76  	ASSERT_FALSE (details2.deserialize (stream2));
77  	ASSERT_EQ (details1, details2);
78  }
79  TEST (block_store, sideband_serialization)
80  {
81  	nano::block_sideband sideband1;
82  	sideband1.account = 1;
83  	sideband1.balance = 2;
84  	sideband1.height = 3;
85  	sideband1.successor = 4;
86  	sideband1.timestamp = 5;
87  	std::vector&lt;uint8_t&gt; vector;
88  	{
89  		nano::vectorstream stream1 (vector);
90  		sideband1.serialize (stream1, nano::block_type::receive);
91  	}
92  	nano::bufferstream stream2 (vector.data (), vector.size ());
93  	nano::block_sideband sideband2;
94  	ASSERT_FALSE (sideband2.deserialize (stream2, nano::block_type::receive));
95  	ASSERT_EQ (sideband1.account, sideband2.account);
96  	ASSERT_EQ (sideband1.balance, sideband2.balance);
97  	ASSERT_EQ (sideband1.height, sideband2.height);
98  	ASSERT_EQ (sideband1.successor, sideband2.successor);
99  	ASSERT_EQ (sideband1.timestamp, sideband2.timestamp);
100  }
101  TEST (block_store, add_item)
102  {
103  	nano::logger_mt logger;
104  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
105  	ASSERT_TRUE (!store-&gt;init_error ());
106  	nano::block_builder builder;
107  	auto block = builder
108  				 .open ()
109  				 .source (0)
110  				 .representative (1)
111  				 .account (0)
112  				 .sign (nano::keypair ().prv, 0)
113  				 .work (0)
114  				 .build ();
115  	block-&gt;sideband_set ({});
116  	auto hash1 (block-&gt;hash ());
117  	auto transaction (store-&gt;tx_begin_write ());
118  	auto latest1 (store-&gt;block.get (transaction, hash1));
119  	ASSERT_EQ (nullptr, latest1);
120  	ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
121  	store-&gt;block.put (transaction, hash1, *block);
122  	auto latest2 (store-&gt;block.get (transaction, hash1));
123  	ASSERT_NE (nullptr, latest2);
124  	ASSERT_EQ (*block, *latest2);
125  	ASSERT_TRUE (store-&gt;block.exists (transaction, hash1));
126  	ASSERT_FALSE (store-&gt;block.exists (transaction, hash1.number () - 1));
127  	store-&gt;block.del (transaction, hash1);
128  	auto latest3 (store-&gt;block.get (transaction, hash1));
129  	ASSERT_EQ (nullptr, latest3);
130  }
131  TEST (block_store, clear_successor)
132  {
133  	nano::logger_mt logger;
134  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
135  	ASSERT_TRUE (!store-&gt;init_error ());
136  	nano::block_builder builder;
137  	auto block1 = builder
138  				  .open ()
139  				  .source (0)
140  				  .representative (1)
141  				  .account (0)
142  				  .sign (nano::keypair ().prv, 0)
143  				  .work (0)
144  				  .build ();
145  	block1-&gt;sideband_set ({});
146  	auto transaction (store-&gt;tx_begin_write ());
147  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
148  	auto block2 = builder
149  				  .open ()
150  				  .source (0)
151  				  .representative (2)
152  				  .account (0)
153  				  .sign (nano::keypair ().prv, 0)
154  				  .work (0)
155  				  .build ();
156  	block2-&gt;sideband_set ({});
157  	store-&gt;block.put (transaction, block2-&gt;hash (), *block2);
158  	auto block2_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
159  	ASSERT_NE (nullptr, block2_store);
160  	ASSERT_EQ (0, block2_store-&gt;sideband ().successor.number ());
161  	auto modified_sideband = block2_store-&gt;sideband ();
162  	modified_sideband.successor = block2-&gt;hash ();
163  	block1-&gt;sideband_set (modified_sideband);
164  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
165  	{
166  		auto block1_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
167  		ASSERT_NE (nullptr, block1_store);
168  		ASSERT_EQ (block2-&gt;hash (), block1_store-&gt;sideband ().successor);
169  	}
170  	store-&gt;block.successor_clear (transaction, block1-&gt;hash ());
171  	{
172  		auto block1_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
173  		ASSERT_NE (nullptr, block1_store);
174  		ASSERT_EQ (0, block1_store-&gt;sideband ().successor.number ());
175  	}
176  }
177  TEST (block_store, add_nonempty_block)
178  {
179  	nano::logger_mt logger;
180  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
181  	ASSERT_TRUE (!store-&gt;init_error ());
182  	nano::keypair key1;
183  	nano::block_builder builder;
184  	auto block = builder
185  				 .open ()
186  				 .source (0)
187  				 .representative (1)
188  				 .account (0)
189  				 .sign (nano::keypair ().prv, 0)
190  				 .work (0)
191  				 .build ();
192  	block-&gt;sideband_set ({});
193  	auto hash1 (block-&gt;hash ());
194  	block-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash1);
195  	auto transaction (store-&gt;tx_begin_write ());
196  	auto latest1 (store-&gt;block.get (transaction, hash1));
197  	ASSERT_EQ (nullptr, latest1);
198  	store-&gt;block.put (transaction, hash1, *block);
199  	auto latest2 (store-&gt;block.get (transaction, hash1));
200  	ASSERT_NE (nullptr, latest2);
201  	ASSERT_EQ (*block, *latest2);
202  }
203  TEST (block_store, add_two_items)
204  {
205  	nano::logger_mt logger;
206  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
207  	ASSERT_TRUE (!store-&gt;init_error ());
208  	nano::keypair key1;
209  	nano::block_builder builder;
210  	auto block = builder
211  				 .open ()
212  				 .source (0)
213  				 .representative (1)
214  				 .account (1)
215  				 .sign (nano::keypair ().prv, 0)
216  				 .work (0)
217  				 .build ();
218  	block-&gt;sideband_set ({});
219  	auto hash1 (block-&gt;hash ());
220  	block-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash1);
221  	auto transaction (store-&gt;tx_begin_write ());
222  	auto latest1 (store-&gt;block.get (transaction, hash1));
223  	ASSERT_EQ (nullptr, latest1);
224  	auto block2 = builder
225  				  .open ()
226  				  .source (0)
227  				  .representative (1)
228  				  .account (3)
229  				  .sign (nano::keypair ().prv, 0)
230  				  .work (0)
231  				  .build ();
232  	block2-&gt;sideband_set ({});
233  	block2-&gt;hashables.account = 3;
234  	auto hash2 (block2-&gt;hash ());
235  	block2-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash2);
236  	auto latest2 (store-&gt;block.get (transaction, hash2));
237  	ASSERT_EQ (nullptr, latest2);
238  	store-&gt;block.put (transaction, hash1, *block);
239  	store-&gt;block.put (transaction, hash2, *block2);
240  	auto latest3 (store-&gt;block.get (transaction, hash1));
241  	ASSERT_NE (nullptr, latest3);
242  	ASSERT_EQ (*block, *latest3);
243  	auto latest4 (store-&gt;block.get (transaction, hash2));
244  	ASSERT_NE (nullptr, latest4);
245  	ASSERT_EQ (*block2, *latest4);
246  	ASSERT_FALSE (*latest3 == *latest4);
247  }
248  TEST (block_store, add_receive)
249  {
250  	nano::logger_mt logger;
251  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
252  	ASSERT_TRUE (!store-&gt;init_error ());
253  	nano::keypair key1;
254  	nano::keypair key2;
255  	nano::block_builder builder;
256  	auto block1 = builder
257  				  .open ()
258  				  .source (0)
259  				  .representative (1)
260  				  .account (0)
261  				  .sign (nano::keypair ().prv, 0)
262  				  .work (0)
263  				  .build ();
264  	block1-&gt;sideband_set ({});
265  	auto transaction (store-&gt;tx_begin_write ());
266  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
267  	auto block = builder
268  				 .receive ()
269  				 .previous (block1-&gt;hash ())
270  				 .source (1)
271  				 .sign (nano::keypair ().prv, 2)
272  				 .work (3)
273  				 .build ();
274  	block-&gt;sideband_set ({});
275  	nano::block_hash hash1 (block-&gt;hash ());
276  	auto latest1 (store-&gt;block.get (transaction, hash1));
277  	ASSERT_EQ (nullptr, latest1);
278  	store-&gt;block.put (transaction, hash1, *block);
279  	auto latest2 (store-&gt;block.get (transaction, hash1));
280  	ASSERT_NE (nullptr, latest2);
281  	ASSERT_EQ (*block, *latest2);
282  }
283  TEST (block_store, add_pending)
284  {
285  	nano::logger_mt logger;
286  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
287  	ASSERT_TRUE (!store-&gt;init_error ());
288  	nano::keypair key1;
289  	nano::pending_key key2 (0, 0);
290  	nano::pending_info pending1;
291  	auto transaction (store-&gt;tx_begin_write ());
292  	ASSERT_TRUE (store-&gt;pending.get (transaction, key2, pending1));
293  	store-&gt;pending.put (transaction, key2, pending1);
294  	nano::pending_info pending2;
295  	ASSERT_FALSE (store-&gt;pending.get (transaction, key2, pending2));
296  	ASSERT_EQ (pending1, pending2);
297  	store-&gt;pending.del (transaction, key2);
298  	ASSERT_TRUE (store-&gt;pending.get (transaction, key2, pending2));
299  }
300  TEST (block_store, pending_iterator)
301  {
302  	nano::logger_mt logger;
303  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
304  	ASSERT_TRUE (!store-&gt;init_error ());
305  	auto transaction (store-&gt;tx_begin_write ());
306  	ASSERT_EQ (store-&gt;pending.end (), store-&gt;pending.begin (transaction));
307  	store-&gt;pending.put (transaction, nano::pending_key (1, 2), { 2, 3, nano::epoch::epoch_1 });
308  	auto current (store-&gt;pending.begin (transaction));
309  	ASSERT_NE (store-&gt;pending.end (), current);
310  	nano::pending_key key1 (current-&gt;first);
311  	ASSERT_EQ (nano::account (1), key1.account);
312  	ASSERT_EQ (nano::block_hash (2), key1.hash);
313  	nano::pending_info pending (current-&gt;second);
314  	ASSERT_EQ (nano::account (2), pending.source);
315  	ASSERT_EQ (nano::amount (3), pending.amount);
316  	ASSERT_EQ (nano::epoch::epoch_1, pending.epoch);
317  }
318  TEST (block_store, pending_iterator_comparison)
319  {
320  	nano::logger_mt logger;
321  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
322  	ASSERT_TRUE (!store-&gt;init_error ());
323  	nano::stats stats;
324  	auto transaction (store-&gt;tx_begin_write ());
325  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (1)), nano::pending_info (nano::account (10), nano::amount (1), nano::epoch::epoch_0));
326  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (4)), nano::pending_info (nano::account (10), nano::amount (0), nano::epoch::epoch_0));
327  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (2)), nano::pending_info (nano::account (10), nano::amount (2), nano::epoch::epoch_1));
328  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (3)), nano::pending_info (nano::account (10), nano::amount (3), nano::epoch::epoch_1));
329  	{
330  		size_t count = 0;
331  		nano::account begin (3);
332  		nano::account end (begin.number () + 1);
333  		for (auto i (store-&gt;pending.begin (transaction, nano::pending_key (begin, 0))), n (store-&gt;pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
334  		{
335  			nano::pending_key key (i-&gt;first);
336  			ASSERT_EQ (key.account, begin);
337  			ASSERT_LT (count, 3);
338  		}
339  		ASSERT_EQ (count, 2);
340  	}
341  	{
342  		size_t count = 0;
343  		nano::account begin (2);
344  		nano::account end (begin.number () + 1);
345  		for (auto i (store-&gt;pending.begin (transaction, nano::pending_key (begin, 0))), n (store-&gt;pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
346  		{
347  			nano::pending_key key (i-&gt;first);
348  			ASSERT_EQ (key.account, begin);
349  			ASSERT_LT (count, 3);
350  		}
351  		ASSERT_EQ (count, 2);
352  	}
353  }
354  TEST (block_store, genesis)
355  {
356  	nano::logger_mt logger;
357  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
358  	ASSERT_TRUE (!store-&gt;init_error ());
359  	nano::ledger_cache ledger_cache;
360  	auto transaction (store-&gt;tx_begin_write ());
361  	store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
362  	nano::account_info info;
363  	ASSERT_FALSE (store-&gt;account.get (transaction, nano::dev::genesis-&gt;account (), info));
364  	ASSERT_EQ (nano::dev::genesis-&gt;hash (), info.head);
365  	auto block1 (store-&gt;block.get (transaction, info.head));
366  	ASSERT_NE (nullptr, block1);
367  	auto receive1 (dynamic_cast&lt;nano::open_block *&gt; (block1.get ()));
368  	ASSERT_NE (nullptr, receive1);
369  	ASSERT_LE (info.modified, nano::seconds_since_epoch ());
370  	ASSERT_EQ (info.block_count, 1);
371  	nano::confirmation_height_info confirmation_height_info;
372  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, nano::dev::genesis-&gt;account (), confirmation_height_info));
373  	ASSERT_EQ (confirmation_height_info.height, 1);
374  	ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
375  	auto dev_pub_text (nano::dev::genesis_key.pub.to_string ());
376  	auto dev_pub_account (nano::dev::genesis_key.pub.to_account ());
377  	auto dev_prv_text (nano::dev::genesis_key.prv.to_string ());
378  	ASSERT_EQ (nano::dev::genesis-&gt;account (), nano::dev::genesis_key.pub);
379  }
380  TEST (block_store, empty_accounts)
381  {
382  	nano::logger_mt logger;
383  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
384  	ASSERT_TRUE (!store-&gt;init_error ());
385  	auto transaction (store-&gt;tx_begin_read ());
386  	auto begin (store-&gt;account.begin (transaction));
387  	auto end (store-&gt;account.end ());
388  	ASSERT_EQ (end, begin);
389  }
390  TEST (block_store, one_block)
391  {
392  	nano::logger_mt logger;
393  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
394  	ASSERT_TRUE (!store-&gt;init_error ());
395  	nano::block_builder builder;
396  	auto block1 = builder
397  				  .open ()
398  				  .source (0)
399  				  .representative (1)
400  				  .account (0)
401  				  .sign (nano::keypair ().prv, 0)
402  				  .work (0)
403  				  .build ();
404  	block1-&gt;sideband_set ({});
405  	auto transaction (store-&gt;tx_begin_write ());
406  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
407  	ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
408  }
409  TEST (block_store, empty_bootstrap)
410  {
411  	nano::test::system system{};
412  	nano::logger_mt logger;
413  	nano::unchecked_map unchecked{ system.stats, false };
414  	size_t count = 0;
415  	unchecked.for_each ([&amp;count] (nano::unchecked_key const &amp; key, nano::unchecked_info const &amp; info) {
416  		++count;
417  	});
418  	ASSERT_EQ (count, 0);
419  }
420  TEST (block_store, unchecked_begin_search)
421  {
422  	nano::logger_mt logger;
423  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
424  	ASSERT_TRUE (!store-&gt;init_error ());
425  	nano::keypair key0;
426  	nano::block_builder builder;
427  	auto block1 = builder
428  				  .send ()
429  				  .previous (0)
430  				  .destination (1)
431  				  .balance (2)
432  				  .sign (key0.prv, key0.pub)
433  				  .work (3)
434  				  .build ();
435  	auto block2 = builder
436  				  .send ()
437  				  .previous (5)
438  				  .destination (6)
439  				  .balance (7)
440  				  .sign (key0.prv, key0.pub)
441  				  .work (8)
442  				  .build ();
443  }
444  TEST (block_store, frontier_retrieval)
445  {
446  	nano::logger_mt logger;
447  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
448  	ASSERT_TRUE (!store-&gt;init_error ());
449  	nano::account account1{};
450  	nano::account_info info1 (0, 0, 0, 0, 0, 0, nano::epoch::epoch_0);
451  	auto transaction (store-&gt;tx_begin_write ());
452  	store-&gt;confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
453  	store-&gt;account.put (transaction, account1, info1);
454  	nano::account_info info2;
455  	store-&gt;account.get (transaction, account1, info2);
456  	ASSERT_EQ (info1, info2);
457  }
458  TEST (block_store, one_account)
459  {
460  	nano::logger_mt logger;
461  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
462  	ASSERT_TRUE (!store-&gt;init_error ());
463  	nano::account account{};
464  	nano::block_hash hash (0);
465  	auto transaction (store-&gt;tx_begin_write ());
466  	store-&gt;confirmation_height.put (transaction, account, { 20, nano::block_hash (15) });
467  	store-&gt;account.put (transaction, account, { hash, account, hash, 42, 100, 200, nano::epoch::epoch_0 });
468  	auto begin (store-&gt;account.begin (transaction));
469  	auto end (store-&gt;account.end ());
470  	ASSERT_NE (end, begin);
471  	ASSERT_EQ (account, nano::account (begin-&gt;first));
472  	nano::account_info info (begin-&gt;second);
473  	ASSERT_EQ (hash, info.head);
474  	ASSERT_EQ (42, info.balance.number ());
475  	ASSERT_EQ (100, info.modified);
476  	ASSERT_EQ (200, info.block_count);
477  	nano::confirmation_height_info confirmation_height_info;
478  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account, confirmation_height_info));
479  	ASSERT_EQ (20, confirmation_height_info.height);
480  	ASSERT_EQ (nano::block_hash (15), confirmation_height_info.frontier);
481  	++begin;
482  	ASSERT_EQ (end, begin);
483  }
484  TEST (block_store, two_block)
485  {
486  	nano::logger_mt logger;
487  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
488  	ASSERT_TRUE (!store-&gt;init_error ());
489  	nano::block_builder builder;
490  	auto block1 = builder
491  				  .open ()
492  				  .source (0)
493  				  .representative (1)
494  				  .account (1)
495  				  .sign (nano::keypair ().prv, 0)
496  				  .work (0)
497  				  .build ();
498  	block1-&gt;sideband_set ({});
499  	block1-&gt;hashables.account = 1;
500  	std::vector&lt;nano::block_hash&gt; hashes;
501  	std::vector&lt;nano::open_block&gt; blocks;
502  	hashes.push_back (block1-&gt;hash ());
503  	blocks.push_back (*block1);
504  	auto transaction (store-&gt;tx_begin_write ());
505  	store-&gt;block.put (transaction, hashes[0], *block1);
506  	auto block2 = builder
507  				  .open ()
508  				  .source (0)
509  				  .representative (1)
510  				  .account (2)
511  				  .sign (nano::keypair ().prv, 0)
512  				  .work (0)
513  				  .build ();
514  	block2-&gt;sideband_set ({});
515  	hashes.push_back (block2-&gt;hash ());
516  	blocks.push_back (*block2);
517  	store-&gt;block.put (transaction, hashes[1], *block2);
518  	ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
519  	ASSERT_TRUE (store-&gt;block.exists (transaction, block2-&gt;hash ()));
520  }
521  TEST (block_store, two_account)
522  {
523  	nano::logger_mt logger;
524  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
525  	ASSERT_TRUE (!store-&gt;init_error ());
526  	nano::account account1 (1);
527  	nano::block_hash hash1 (2);
528  	nano::account account2 (3);
529  	nano::block_hash hash2 (4);
530  	auto transaction (store-&gt;tx_begin_write ());
531  	store-&gt;confirmation_height.put (transaction, account1, { 20, nano::block_hash (10) });
532  	store-&gt;account.put (transaction, account1, { hash1, account1, hash1, 42, 100, 300, nano::epoch::epoch_0 });
533  	store-&gt;confirmation_height.put (transaction, account2, { 30, nano::block_hash (20) });
534  	store-&gt;account.put (transaction, account2, { hash2, account2, hash2, 84, 200, 400, nano::epoch::epoch_0 });
535  	auto begin (store-&gt;account.begin (transaction));
536  	auto end (store-&gt;account.end ());
537  	ASSERT_NE (end, begin);
538  	ASSERT_EQ (account1, nano::account (begin-&gt;first));
539  	nano::account_info info1 (begin-&gt;second);
540  	ASSERT_EQ (hash1, info1.head);
541  	ASSERT_EQ (42, info1.balance.number ());
542  	ASSERT_EQ (100, info1.modified);
543  	ASSERT_EQ (300, info1.block_count);
544  	nano::confirmation_height_info confirmation_height_info;
545  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
546  	ASSERT_EQ (20, confirmation_height_info.height);
547  	ASSERT_EQ (nano::block_hash (10), confirmation_height_info.frontier);
548  	++begin;
549  	ASSERT_NE (end, begin);
550  	ASSERT_EQ (account2, nano::account (begin-&gt;first));
551  	nano::account_info info2 (begin-&gt;second);
552  	ASSERT_EQ (hash2, info2.head);
553  	ASSERT_EQ (84, info2.balance.number ());
554  	ASSERT_EQ (200, info2.modified);
555  	ASSERT_EQ (400, info2.block_count);
556  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
557  	ASSERT_EQ (30, confirmation_height_info.height);
558  	ASSERT_EQ (nano::block_hash (20), confirmation_height_info.frontier);
559  	++begin;
560  	ASSERT_EQ (end, begin);
561  }
562  TEST (block_store, latest_find)
563  {
564  	nano::logger_mt logger;
565  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
566  	ASSERT_TRUE (!store-&gt;init_error ());
567  	nano::account account1 (1);
568  	nano::block_hash hash1 (2);
569  	nano::account account2 (3);
570  	nano::block_hash hash2 (4);
571  	auto transaction (store-&gt;tx_begin_write ());
572  	store-&gt;confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
573  	store-&gt;account.put (transaction, account1, { hash1, account1, hash1, 100, 0, 300, nano::epoch::epoch_0 });
574  	store-&gt;confirmation_height.put (transaction, account2, { 0, nano::block_hash (0) });
575  	store-&gt;account.put (transaction, account2, { hash2, account2, hash2, 200, 0, 400, nano::epoch::epoch_0 });
576  	auto first (store-&gt;account.begin (transaction));
577  	auto second (store-&gt;account.begin (transaction));
578  	++second;
579  	auto find1 (store-&gt;account.begin (transaction, 1));
580  	ASSERT_EQ (first, find1);
581  	auto find2 (store-&gt;account.begin (transaction, 3));
582  	ASSERT_EQ (second, find2);
583  	auto find3 (store-&gt;account.begin (transaction, 2));
584  	ASSERT_EQ (second, find3);
585  }
586  namespace nano
587  {
588  namespace lmdb
589  {
590  	TEST (mdb_block_store, supported_version_upgrades)
591  	{
592  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
593  		{
594  			GTEST_SKIP ();
595  		}
596  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
597  		nano::logger_mt logger;
598  		{
599  			nano::lmdb::store store (logger, path, nano::dev::constants);
600  			nano::stats stats;
601  			nano::ledger ledger (store, stats, nano::dev::constants);
602  			auto transaction (store.tx_begin_write ());
603  			store.initialize (transaction, ledger.cache, nano::dev::constants);
604  			store.version.put (transaction, store.version_minimum - 1);
605  		}
606  		{
607  			nano::lmdb::store store (logger, path, nano::dev::constants);
608  			ASSERT_TRUE (store.init_error ());
609  		}
610  		auto path1 (nano::unique_path () / &quot;data.ldb&quot;);
611  		{
612  			nano::lmdb::store store (logger, path1, nano::dev::constants);
613  			nano::stats stats;
614  			nano::ledger ledger (store, stats, nano::dev::constants);
615  			auto transaction (store.tx_begin_write ());
616  			store.initialize (transaction, ledger.cache, nano::dev::constants);
617  			store.version.put (transaction, store.version_minimum);
618  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
619  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;accounts_v1&quot;, MDB_CREATE,
620  			&amp;store.account_store.accounts_v1_handle));
621  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
622  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis-&gt;account (), 1,
623  			nano::dev::genesis-&gt;hash ());
624  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
625  		}
626  		{
627  			nano::lmdb::store store (logger, path1, nano::dev::constants);
628  			ASSERT_FALSE (store.init_error ());
629  		}
630  	}
631  }
632  }
633  TEST (mdb_block_store, bad_path)
634  {
635  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
636  	{
637  		GTEST_SKIP ();
638  	}
639  	nano::logger_mt logger;
640  	nano::lmdb::store store (logger, boost::filesystem::path (&quot;&amp;bsol;&amp;bsol;/&quot;), nano::dev::constants);
641  	ASSERT_TRUE (store.init_error ());
642  }
643  TEST (block_store, DISABLED_already_open) 
644  {
645  	auto path (nano::unique_path ());
646  	boost::filesystem::create_directories (path.parent_path ());
647  	nano::set_secure_perm_directory (path.parent_path ());
648  	std::ofstream file;
649  	file.open (path.string ().c_str ());
650  	ASSERT_TRUE (file.is_open ());
651  	nano::logger_mt logger;
652  	auto store = nano::make_store (logger, path, nano::dev::constants);
653  	ASSERT_TRUE (store-&gt;init_error ());
654  }
655  TEST (block_store, roots)
656  {
657  	nano::logger_mt logger;
658  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
659  	ASSERT_TRUE (!store-&gt;init_error ());
660  	nano::block_builder builder;
661  	auto send_block = builder
662  					  .send ()
663  					  .previous (0)
664  					  .destination (1)
665  					  .balance (2)
666  					  .sign (nano::keypair ().prv, 4)
667  					  .work (5)
668  					  .build ();
669  	ASSERT_EQ (send_block-&gt;hashables.previous, send_block-&gt;root ().as_block_hash ());
670  	auto change_block = builder
671  						.change ()
672  						.previous (0)
673  						.representative (1)
674  						.sign (nano::keypair ().prv, 3)
675  						.work (4)
676  						.build ();
677  	ASSERT_EQ (change_block-&gt;hashables.previous, change_block-&gt;root ().as_block_hash ());
678  	auto receive_block = builder
679  						 .receive ()
680  						 .previous (0)
681  						 .source (1)
682  						 .sign (nano::keypair ().prv, 3)
683  						 .work (4)
684  						 .build ();
685  	ASSERT_EQ (receive_block-&gt;hashables.previous, receive_block-&gt;root ().as_block_hash ());
686  	auto open_block = builder
687  					  .open ()
688  					  .source (0)
689  					  .representative (1)
690  					  .account (2)
691  					  .sign (nano::keypair ().prv, 4)
692  					  .work (5)
693  					  .build ();
694  	ASSERT_EQ (open_block-&gt;hashables.account, open_block-&gt;root ().as_account ());
695  }
696  TEST (block_store, pending_exists)
697  {
698  	nano::logger_mt logger;
699  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
700  	ASSERT_TRUE (!store-&gt;init_error ());
701  	nano::pending_key two (2, 0);
702  	nano::pending_info pending;
703  	auto transaction (store-&gt;tx_begin_write ());
704  	store-&gt;pending.put (transaction, two, pending);
705  	nano::pending_key one (1, 0);
706  	ASSERT_FALSE (store-&gt;pending.exists (transaction, one));
707  }
708  TEST (block_store, latest_exists)
709  {
710  	nano::logger_mt logger;
711  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
712  	ASSERT_TRUE (!store-&gt;init_error ());
713  	nano::account two (2);
714  	nano::account_info info;
715  	auto transaction (store-&gt;tx_begin_write ());
716  	store-&gt;confirmation_height.put (transaction, two, { 0, nano::block_hash (0) });
717  	store-&gt;account.put (transaction, two, info);
718  	nano::account one (1);
719  	ASSERT_FALSE (store-&gt;account.exists (transaction, one));
720  }
721  TEST (block_store, large_iteration)
722  {
723  	nano::logger_mt logger;
724  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
725  	ASSERT_TRUE (!store-&gt;init_error ());
726  	std::unordered_set&lt;nano::account&gt; accounts1;
727  	for (auto i (0); i &lt; 1000; ++i)
728  	{
729  		auto transaction (store-&gt;tx_begin_write ());
730  		nano::account account;
731  		nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
732  		accounts1.insert (account);
733  		store-&gt;confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
734  		store-&gt;account.put (transaction, account, nano::account_info ());
735  	}
736  	std::unordered_set&lt;nano::account&gt; accounts2;
737  	nano::account previous{};
738  	auto transaction (store-&gt;tx_begin_read ());
739  	for (auto i (store-&gt;account.begin (transaction, 0)), n (store-&gt;account.end ()); i != n; ++i)
740  	{
741  		nano::account current (i-&gt;first);
742  		ASSERT_GT (current.number (), previous.number ());
743  		accounts2.insert (current);
744  		previous = current;
745  	}
746  	ASSERT_EQ (accounts1, accounts2);
747  	std::unordered_set&lt;nano::account&gt; accounts3;
748  	previous = std::numeric_limits&lt;nano::uint256_t&gt;::max ();
749  	for (auto i (store-&gt;account.rbegin (transaction)), n (store-&gt;account.end ()); i != n; --i)
750  	{
751  		nano::account current (i-&gt;first);
752  		ASSERT_LT (current.number (), previous.number ());
753  		accounts3.insert (current);
754  		previous = current;
755  	}
756  	ASSERT_EQ (accounts1, accounts3);
757  }
758  TEST (block_store, frontier)
759  {
760  	nano::logger_mt logger;
761  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
762  	ASSERT_TRUE (!store-&gt;init_error ());
763  	auto transaction (store-&gt;tx_begin_write ());
764  	nano::block_hash hash (100);
765  	nano::account account (200);
766  	ASSERT_TRUE (store-&gt;frontier.get (transaction, hash).is_zero ());
767  	store-&gt;frontier.put (transaction, hash, account);
768  	ASSERT_EQ (account, store-&gt;frontier.get (transaction, hash));
769  	store-&gt;frontier.del (transaction, hash);
770  	ASSERT_TRUE (store-&gt;frontier.get (transaction, hash).is_zero ());
771  }
772  TEST (block_store, block_replace)
773  {
774  	nano::logger_mt logger;
775  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
776  	ASSERT_TRUE (!store-&gt;init_error ());
777  	nano::block_builder builder;
778  	auto send1 = builder
779  				 .send ()
780  				 .previous (0)
781  				 .destination (0)
782  				 .balance (0)
783  				 .sign (nano::keypair ().prv, 0)
784  				 .work (1)
785  				 .build ();
786  	send1-&gt;sideband_set ({});
787  	auto send2 = builder
788  				 .send ()
789  				 .previous (0)
790  				 .destination (0)
791  				 .balance (0)
792  				 .sign (nano::keypair ().prv, 0)
793  				 .work (2)
794  				 .build ();
795  	send2-&gt;sideband_set ({});
796  	auto transaction (store-&gt;tx_begin_write ());
797  	store-&gt;block.put (transaction, 0, *send1);
798  	store-&gt;block.put (transaction, 0, *send2);
799  	auto block3 (store-&gt;block.get (transaction, 0));
800  	ASSERT_NE (nullptr, block3);
801  	ASSERT_EQ (2, block3-&gt;block_work ());
802  }
803  TEST (block_store, block_count)
804  {
805  	nano::logger_mt logger;
806  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
807  	ASSERT_TRUE (!store-&gt;init_error ());
808  	{
809  		auto transaction (store-&gt;tx_begin_write ());
810  		ASSERT_EQ (0, store-&gt;block.count (transaction));
811  		nano::block_builder builder;
812  		auto block = builder
813  					 .open ()
814  					 .source (0)
815  					 .representative (1)
816  					 .account (0)
817  					 .sign (nano::keypair ().prv, 0)
818  					 .work (0)
819  					 .build ();
820  		block-&gt;sideband_set ({});
821  		auto hash1 (block-&gt;hash ());
822  		store-&gt;block.put (transaction, hash1, *block);
823  	}
824  	auto transaction (store-&gt;tx_begin_read ());
825  	ASSERT_EQ (1, store-&gt;block.count (transaction));
826  }
827  TEST (block_store, account_count)
828  {
829  	nano::logger_mt logger;
830  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
831  	ASSERT_TRUE (!store-&gt;init_error ());
832  	{
833  		auto transaction (store-&gt;tx_begin_write ());
834  		ASSERT_EQ (0, store-&gt;account.count (transaction));
835  		nano::account account (200);
836  		store-&gt;confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
837  		store-&gt;account.put (transaction, account, nano::account_info ());
838  	}
839  	auto transaction (store-&gt;tx_begin_read ());
840  	ASSERT_EQ (1, store-&gt;account.count (transaction));
841  }
842  TEST (block_store, cemented_count_cache)
843  {
844  	nano::logger_mt logger;
845  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
846  	ASSERT_TRUE (!store-&gt;init_error ());
847  	auto transaction (store-&gt;tx_begin_write ());
848  	nano::ledger_cache ledger_cache;
849  	store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
850  	ASSERT_EQ (1, ledger_cache.cemented_count);
851  }
852  TEST (block_store, block_random)
853  {
854  	nano::logger_mt logger;
855  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
856  	{
857  		nano::ledger_cache ledger_cache;
858  		auto transaction (store-&gt;tx_begin_write ());
859  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
860  	}
861  	auto transaction (store-&gt;tx_begin_read ());
862  	auto block (store-&gt;block.random (transaction));
863  	ASSERT_NE (nullptr, block);
864  	ASSERT_EQ (*block, *nano::dev::genesis);
865  }
866  TEST (block_store, pruned_random)
867  {
868  	nano::logger_mt logger;
869  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
870  	ASSERT_TRUE (!store-&gt;init_error ());
871  	nano::block_builder builder;
872  	auto block = builder
873  				 .open ()
874  				 .source (0)
875  				 .representative (1)
876  				 .account (0)
877  				 .sign (nano::keypair ().prv, 0)
878  				 .work (0)
879  				 .build ();
880  	block-&gt;sideband_set ({});
881  	auto hash1 (block-&gt;hash ());
882  	{
883  		nano::ledger_cache ledger_cache;
884  		auto transaction (store-&gt;tx_begin_write ());
885  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
886  		store-&gt;pruned.put (transaction, hash1);
887  	}
888  	auto transaction (store-&gt;tx_begin_read ());
889  	auto random_hash (store-&gt;pruned.random (transaction));
890  	ASSERT_EQ (hash1, random_hash);
891  }
892  TEST (block_store, state_block)
893  {
894  	nano::logger_mt logger;
895  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
896  	ASSERT_FALSE (store-&gt;init_error ());
897  	nano::keypair key1;
898  	nano::block_builder builder;
899  	auto block1 = builder
900  				  .state ()
901  				  .account (1)
902  				  .previous (nano::dev::genesis-&gt;hash ())
903  				  .representative (3)
904  				  .balance (4)
905  				  .link (6)
906  				  .sign (key1.prv, key1.pub)
907  				  .work (7)
908  				  .build ();
909  	block1-&gt;sideband_set ({});
910  	{
911  		nano::ledger_cache ledger_cache;
912  		auto transaction (store-&gt;tx_begin_write ());
913  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
914  		ASSERT_EQ (nano::block_type::state, block1-&gt;type ());
915  		store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
916  		ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
917  		auto block2 (store-&gt;block.get (transaction, block1-&gt;hash ()));
918  		ASSERT_NE (nullptr, block2);
919  		ASSERT_EQ (*block1, *block2);
920  	}
921  	{
922  		auto transaction (store-&gt;tx_begin_write ());
923  		auto count (store-&gt;block.count (transaction));
924  		ASSERT_EQ (2, count);
925  		store-&gt;block.del (transaction, block1-&gt;hash ());
926  		ASSERT_FALSE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
927  	}
928  	auto transaction (store-&gt;tx_begin_read ());
929  	auto count2 (store-&gt;block.count (transaction));
930  	ASSERT_EQ (1, count2);
931  }
932  TEST (mdb_block_store, sideband_height)
933  {
934  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
935  	{
936  		GTEST_SKIP ();
937  	}
938  	nano::logger_mt logger;
939  	nano::keypair key1;
940  	nano::keypair key2;
941  	nano::keypair key3;
942  	nano::lmdb::store store (logger, nano::unique_path () / &quot;data.ldb&quot;, nano::dev::constants);
943  	ASSERT_FALSE (store.init_error ());
944  	nano::stats stats;
945  	nano::ledger ledger (store, stats, nano::dev::constants);
946  	nano::block_builder builder;
947  	auto transaction (store.tx_begin_write ());
948  	store.initialize (transaction, ledger.cache, nano::dev::constants);
949  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
950  	auto send = builder
951  				.send ()
952  				.previous (nano::dev::genesis-&gt;hash ())
953  				.destination (nano::dev::genesis_key.pub)
954  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
955  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
956  				.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
957  				.build ();
958  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
959  	auto receive = builder
960  				   .receive ()
961  				   .previous (send-&gt;hash ())
962  				   .source (send-&gt;hash ())
963  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
964  				   .work (*pool.generate (send-&gt;hash ()))
965  				   .build ();
966  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
967  	auto change = builder
968  				  .change ()
969  				  .previous (receive-&gt;hash ())
970  				  .representative (0)
971  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
972  				  .work (*pool.generate (receive-&gt;hash ()))
973  				  .build ();
974  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
975  	auto state_send1 = builder
976  					   .state ()
977  					   .account (nano::dev::genesis_key.pub)
978  					   .previous (change-&gt;hash ())
979  					   .representative (0)
980  					   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
981  					   .link (key1.pub)
982  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
983  					   .work (*pool.generate (change-&gt;hash ()))
984  					   .build ();
985  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send1).code);
986  	auto state_send2 = builder
987  					   .state ()
988  					   .account (nano::dev::genesis_key.pub)
989  					   .previous (state_send1-&gt;hash ())
990  					   .representative (0)
991  					   .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
992  					   .link (key2.pub)
993  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
994  					   .work (*pool.generate (state_send1-&gt;hash ()))
995  					   .build ();
996  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
997  	auto state_send3 = builder
998  					   .state ()
999  					   .account (nano::dev::genesis_key.pub)
1000  					   .previous (state_send2-&gt;hash ())
1001  					   .representative (0)
1002  					   .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1003  					   .link (key3.pub)
1004  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1005  					   .work (*pool.generate (state_send2-&gt;hash ()))
1006  					   .build ();
1007  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send3).code);
1008  	auto state_open = builder
1009  					  .state ()
1010  					  .account (key1.pub)
1011  					  .previous (0)
1012  					  .representative (0)
1013  					  .balance (nano::Gxrb_ratio)
1014  					  .link (state_send1-&gt;hash ())
1015  					  .sign (key1.prv, key1.pub)
1016  					  .work (*pool.generate (key1.pub))
1017  					  .build ();
1018  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1019  	auto epoch = builder
1020  				 .state ()
1021  				 .account (key1.pub)
1022  				 .previous (state_open-&gt;hash ())
1023  				 .representative (0)
1024  				 .balance (nano::Gxrb_ratio)
1025  				 .link (ledger.epoch_link (nano::epoch::epoch_1))
1026  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				 .work (*pool.generate (state_open-&gt;hash ()))
1028  				 .build ();
1029  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1030  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch-&gt;hash ()));
1031  	auto epoch_open = builder
1032  					  .state ()
1033  					  .account (key2.pub)
1034  					  .previous (0)
1035  					  .representative (0)
1036  					  .balance (0)
1037  					  .link (ledger.epoch_link (nano::epoch::epoch_1))
1038  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1039  					  .work (*pool.generate (key2.pub))
1040  					  .build ();
1041  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_open).code);
1042  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch_open-&gt;hash ()));
1043  	auto state_receive = builder
1044  						 .state ()
1045  						 .account (key2.pub)
1046  						 .previous (epoch_open-&gt;hash ())
1047  						 .representative (0)
1048  						 .balance (nano::Gxrb_ratio)
1049  						 .link (state_send2-&gt;hash ())
1050  						 .sign (key2.prv, key2.pub)
1051  						 .work (*pool.generate (epoch_open-&gt;hash ()))
1052  						 .build ();
1053  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1054  	auto open = builder
1055  				.open ()
1056  				.source (state_send3-&gt;hash ())
1057  				.representative (nano::dev::genesis_key.pub)
1058  				.account (key3.pub)
1059  				.sign (key3.prv, key3.pub)
1060  				.work (*pool.generate (key3.pub))
1061  				.build ();
1062  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1063  	auto block1 (store.block.get (transaction, nano::dev::genesis-&gt;hash ()));
1064  	ASSERT_EQ (block1-&gt;sideband ().height, 1);
1065  	auto block2 (store.block.get (transaction, send-&gt;hash ()));
1066  	ASSERT_EQ (block2-&gt;sideband ().height, 2);
1067  	auto block3 (store.block.get (transaction, receive-&gt;hash ()));
1068  	ASSERT_EQ (block3-&gt;sideband ().height, 3);
1069  	auto block4 (store.block.get (transaction, change-&gt;hash ()));
1070  	ASSERT_EQ (block4-&gt;sideband ().height, 4);
1071  	auto block5 (store.block.get (transaction, state_send1-&gt;hash ()));
1072  	ASSERT_EQ (block5-&gt;sideband ().height, 5);
1073  	auto block6 (store.block.get (transaction, state_send2-&gt;hash ()));
1074  	ASSERT_EQ (block6-&gt;sideband ().height, 6);
1075  	auto block7 (store.block.get (transaction, state_send3-&gt;hash ()));
1076  	ASSERT_EQ (block7-&gt;sideband ().height, 7);
1077  	auto block8 (store.block.get (transaction, state_open-&gt;hash ()));
1078  	ASSERT_EQ (block8-&gt;sideband ().height, 1);
1079  	auto block9 (store.block.get (transaction, epoch-&gt;hash ()));
1080  	ASSERT_EQ (block9-&gt;sideband ().height, 2);
1081  	auto block10 (store.block.get (transaction, epoch_open-&gt;hash ()));
1082  	ASSERT_EQ (block10-&gt;sideband ().height, 1);
1083  	auto block11 (store.block.get (transaction, state_receive-&gt;hash ()));
1084  	ASSERT_EQ (block11-&gt;sideband ().height, 2);
1085  	auto block12 (store.block.get (transaction, open-&gt;hash ()));
1086  	ASSERT_EQ (block12-&gt;sideband ().height, 1);
1087  }
1088  TEST (block_store, peers)
1089  {
1090  	nano::logger_mt logger;
1091  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1092  	ASSERT_TRUE (!store-&gt;init_error ());
1093  	nano::endpoint_key endpoint (boost::asio::ip::address_v6::any ().to_bytes (), 100);
1094  	{
1095  		auto transaction (store-&gt;tx_begin_write ());
1096  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint));
1097  		ASSERT_EQ (store-&gt;peer.count (transaction), 0);
1098  		store-&gt;peer.put (transaction, endpoint);
1099  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint));
1100  	}
1101  	{
1102  		auto transaction (store-&gt;tx_begin_read ());
1103  		ASSERT_EQ (store-&gt;peer.count (transaction), 1);
1104  	}
1105  	nano::endpoint_key endpoint1 (boost::asio::ip::address_v6::any ().to_bytes (), 101);
1106  	{
1107  		auto transaction (store-&gt;tx_begin_write ());
1108  		store-&gt;peer.put (transaction, endpoint1);
1109  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint1)); 
1110  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint)); 
1111  	}
1112  	{
1113  		auto transaction (store-&gt;tx_begin_read ());
1114  		ASSERT_EQ (store-&gt;peer.count (transaction), 2);
1115  	}
1116  	{
1117  		auto transaction (store-&gt;tx_begin_write ());
1118  		store-&gt;peer.del (transaction, endpoint1);
1119  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint1)); 
1120  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint)); 
1121  	}
1122  	{
1123  		auto transaction (store-&gt;tx_begin_read ());
1124  		ASSERT_EQ (store-&gt;peer.count (transaction), 1);
1125  	}
1126  	{
1127  		auto transaction (store-&gt;tx_begin_write ());
1128  		store-&gt;peer.del (transaction, endpoint);
1129  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint));
1130  	}
1131  	{
1132  		auto transaction (store-&gt;tx_begin_read ());
1133  		ASSERT_EQ (store-&gt;peer.count (transaction), 0);
1134  	}
1135  }
1136  TEST (block_store, endpoint_key_byte_order)
1137  {
1138  	boost::asio::ip::address_v6 address (boost::asio::ip::make_address_v6 (&quot;::ffff:127.0.0.1&quot;));
1139  	uint16_t port = 100;
1140  	nano::endpoint_key endpoint_key (address.to_bytes (), port);
1141  	std::vector&lt;uint8_t&gt; bytes;
1142  	{
1143  		nano::vectorstream stream (bytes);
1144  		nano::write (stream, endpoint_key);
1145  	}
1146  	ASSERT_EQ (bytes.size (), 18);
1147  	ASSERT_EQ (bytes[10], 0xff);
1148  	ASSERT_EQ (bytes[11], 0xff);
1149  	ASSERT_EQ (bytes[12], 127);
1150  	ASSERT_EQ (bytes[bytes.size () - 2], 0);
1151  	ASSERT_EQ (bytes.back (), 100);
1152  	nano::bufferstream stream1 (bytes.data (), bytes.size ());
1153  	nano::endpoint_key endpoint_key1;
1154  	nano::read (stream1, endpoint_key1);
1155  	ASSERT_EQ (address.to_bytes (), endpoint_key1.address_bytes ());
1156  	ASSERT_EQ (port, endpoint_key1.port ());
1157  }
1158  TEST (block_store, online_weight)
1159  {
1160  	nano::logger_mt logger;
1161  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1162  	ASSERT_FALSE (store-&gt;init_error ());
1163  	{
1164  		auto transaction (store-&gt;tx_begin_write ());
1165  		ASSERT_EQ (0, store-&gt;online_weight.count (transaction));
1166  		ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.begin (transaction));
1167  		ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.rbegin (transaction));
1168  		store-&gt;online_weight.put (transaction, 1, 2);
1169  		store-&gt;online_weight.put (transaction, 3, 4);
1170  	}
1171  	{
1172  		auto transaction (store-&gt;tx_begin_write ());
1173  		ASSERT_EQ (2, store-&gt;online_weight.count (transaction));
1174  		auto item (store-&gt;online_weight.begin (transaction));
1175  		ASSERT_NE (store-&gt;online_weight.end (), item);
1176  		ASSERT_EQ (1, item-&gt;first);
1177  		ASSERT_EQ (2, item-&gt;second.number ());
1178  		auto item_last (store-&gt;online_weight.rbegin (transaction));
1179  		ASSERT_NE (store-&gt;online_weight.end (), item_last);
1180  		ASSERT_EQ (3, item_last-&gt;first);
1181  		ASSERT_EQ (4, item_last-&gt;second.number ());
1182  		store-&gt;online_weight.del (transaction, 1);
1183  		ASSERT_EQ (1, store-&gt;online_weight.count (transaction));
1184  		ASSERT_EQ (store-&gt;online_weight.begin (transaction), store-&gt;online_weight.rbegin (transaction));
1185  		store-&gt;online_weight.del (transaction, 3);
1186  	}
1187  	auto transaction (store-&gt;tx_begin_read ());
1188  	ASSERT_EQ (0, store-&gt;online_weight.count (transaction));
1189  	ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.begin (transaction));
1190  	ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.rbegin (transaction));
1191  }
1192  TEST (block_store, pruned_blocks)
1193  {
1194  	nano::logger_mt logger;
1195  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1196  	ASSERT_TRUE (!store-&gt;init_error ());
1197  	nano::keypair key1;
1198  	nano::block_builder builder;
1199  	auto block1 = builder
1200  				  .open ()
1201  				  .source (0)
1202  				  .representative (1)
1203  				  .account (key1.pub)
1204  				  .sign (key1.prv, key1.pub)
1205  				  .work (0)
1206  				  .build ();
1207  	auto hash1 (block1-&gt;hash ());
1208  	{
1209  		auto transaction (store-&gt;tx_begin_write ());
1210  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash1));
1211  		ASSERT_EQ (store-&gt;pruned.count (transaction), 0);
1212  		store-&gt;pruned.put (transaction, hash1);
1213  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1));
1214  	}
1215  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 1);
1216  	auto block2 = builder
1217  				  .open ()
1218  				  .source (1)
1219  				  .representative (2)
1220  				  .account (key1.pub)
1221  				  .sign (key1.prv, key1.pub)
1222  				  .work (0)
1223  				  .build ();
1224  	block2-&gt;sideband_set ({});
1225  	auto hash2 (block2-&gt;hash ());
1226  	{
1227  		auto transaction (store-&gt;tx_begin_write ());
1228  		store-&gt;pruned.put (transaction, hash2);
1229  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash2)); 
1230  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash2));
1231  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1)); 
1232  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
1233  	}
1234  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 2);
1235  	{
1236  		auto transaction (store-&gt;tx_begin_write ());
1237  		store-&gt;pruned.del (transaction, hash2);
1238  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash2)); 
1239  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash2)); 
1240  		store-&gt;block.put (transaction, hash2, *block2); 
1241  		ASSERT_TRUE (store-&gt;block.exists (transaction, hash2));
1242  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1)); 
1243  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
1244  	}
1245  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 1);
1246  	{
1247  		auto transaction (store-&gt;tx_begin_write ());
1248  		store-&gt;pruned.del (transaction, hash1);
1249  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash1));
1250  	}
1251  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 0);
1252  }
1253  namespace nano
1254  {
1255  namespace lmdb
1256  {
1257  	TEST (mdb_block_store, upgrade_v14_v15)
1258  	{
1259  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1260  		{
1261  			GTEST_SKIP ();
1262  		}
1263  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1264  		nano::block_builder builder;
1265  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1266  		auto send = builder
1267  					.send ()
1268  					.previous (nano::dev::genesis-&gt;hash ())
1269  					.destination (nano::dev::genesis_key.pub)
1270  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1271  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  					.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1273  					.build ();
1274  		auto epoch = builder
1275  					 .state ()
1276  					 .account (nano::dev::genesis_key.pub)
1277  					 .previous (send-&gt;hash ())
1278  					 .representative (nano::dev::genesis_key.pub)
1279  					 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1280  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1281  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1282  					 .work (*pool.generate (send-&gt;hash ()))
1283  					 .build ();
1284  		auto state_send = builder
1285  						  .state ()
1286  						  .account (nano::dev::genesis_key.pub)
1287  						  .previous (epoch-&gt;hash ())
1288  						  .representative (nano::dev::genesis_key.pub)
1289  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1290  						  .link (nano::dev::genesis_key.pub)
1291  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1292  						  .work (*pool.generate (epoch-&gt;hash ()))
1293  						  .build ();
1294  		{
1295  			nano::logger_mt logger;
1296  			nano::lmdb::store store (logger, path, nano::dev::constants);
1297  			nano::stats stats;
1298  			nano::ledger ledger (store, stats, nano::dev::constants);
1299  			auto transaction (store.tx_begin_write ());
1300  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1301  			auto account_info = ledger.account_info (transaction, nano::dev::genesis-&gt;account ());
1302  			ASSERT_TRUE (account_info);
1303  			nano::confirmation_height_info confirmation_height_info;
1304  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (),
1305  			confirmation_height_info));
1306  			ASSERT_EQ (confirmation_height_info.height, 1);
1307  			ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
1308  			ASSERT_FALSE (
1309  			mdb_dbi_open (store.env.tx (transaction), &quot;state_v1&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_v1_handle));
1310  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;accounts_v1&quot;, MDB_CREATE,
1311  			&amp;store.account_store.accounts_v1_handle));
1312  			ASSERT_FALSE (
1313  			mdb_dbi_open (store.env.tx (transaction), &quot;pending_v1&quot;, MDB_CREATE, &amp;store.pending_store.pending_v1_handle));
1314  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1315  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1316  			ASSERT_FALSE (
1317  			mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE,
1318  			&amp;store.block_store.state_blocks_handle));
1319  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1320  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1321  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1322  			store.version.put (transaction, 14);
1323  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
1324  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis-&gt;account (),
1325  			confirmation_height_info.height, state_send-&gt;hash ());
1326  			store.pending.del (transaction, nano::pending_key (nano::dev::genesis-&gt;account (), state_send-&gt;hash ()));
1327  			write_sideband_v14 (store, transaction, *state_send, store.block_store.state_blocks_v1_handle);
1328  			write_sideband_v14 (store, transaction, *epoch, store.block_store.state_blocks_v1_handle);
1329  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1330  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1331  			store.block.del (transaction, state_send-&gt;hash ());
1332  			store.block.del (transaction, epoch-&gt;hash ());
1333  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v0_handle,
1334  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, send-&gt;hash ())),
1335  			nano::mdb_val (
1336  			nano::pending_info_v14 (nano::dev::genesis-&gt;account (), nano::Gxrb_ratio,
1337  			nano::epoch::epoch_0)),
1338  			0));
1339  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v1_handle,
1340  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ())),
1341  			nano::mdb_val (
1342  			nano::pending_info_v14 (nano::dev::genesis-&gt;account (), nano::Gxrb_ratio,
1343  			nano::epoch::epoch_1)),
1344  			0));
1345  			nano::mdb_val value;
1346  			ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1347  			nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1348  			nano::account_info info;
1349  			ASSERT_NE (value.size (), info.db_size ());
1350  			store.account.del (transaction, nano::dev::genesis-&gt;account ());
1351  			ASSERT_TRUE (mdb_get (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle,
1352  			nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1353  		}
1354  		nano::logger_mt logger;
1355  		nano::lmdb::store store (logger, path, nano::dev::constants);
1356  		ASSERT_FALSE (store.init_error ());
1357  		auto transaction (store.tx_begin_read ());
1358  		nano::mdb_val value;
1359  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_handle,
1360  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1361  		nano::account_info info (value);
1362  		ASSERT_EQ (value.size (), info.db_size ());
1363  		nano::confirmation_height_info confirmation_height_info;
1364  		ASSERT_FALSE (
1365  		store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (),
1366  		confirmation_height_info));
1367  		ASSERT_EQ (confirmation_height_info.height, 1);
1368  		ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
1369  		auto error_get_accounts_v1 (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1370  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1371  		ASSERT_NE (error_get_accounts_v1, MDB_SUCCESS);
1372  		auto error_get_pending_v1 (mdb_get (store.env.tx (transaction), store.pending_store.pending_v1_handle, nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ())), value));
1373  		ASSERT_NE (error_get_pending_v1, MDB_SUCCESS);
1374  		auto error_get_state_v1 (
1375  		mdb_get (store.env.tx (transaction), store.block_store.state_blocks_v1_handle, nano::mdb_val (state_send-&gt;hash ()),
1376  		value));
1377  		ASSERT_NE (error_get_state_v1, MDB_SUCCESS);
1378  		auto block = store.block.get (transaction, state_send-&gt;hash ());
1379  		ASSERT_NE (block, nullptr);
1380  		ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1381  		block = store.block.get (transaction, send-&gt;hash ());
1382  		ASSERT_NE (block, nullptr);
1383  		ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1384  		ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1385  		nano::pending_info pending_info;
1386  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, send-&gt;hash ()), pending_info);
1387  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_0);
1388  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ()),
1389  		pending_info);
1390  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_1);
1391  		ASSERT_LT (14, store.version.get (transaction));
1392  	}
1393  	TEST (mdb_block_store, upgrade_v15_v16)
1394  	{
1395  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1396  		{
1397  			GTEST_SKIP ();
1398  		}
1399  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1400  		nano::mdb_val value;
1401  		{
1402  			nano::logger_mt logger;
1403  			nano::lmdb::store store (logger, path, nano::dev::constants);
1404  			nano::stats stats;
1405  			nano::ledger ledger (store, stats, nano::dev::constants);
1406  			auto transaction (store.tx_begin_write ());
1407  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1408  			auto txn = store.env.tx (transaction);
1409  			ASSERT_FALSE (
1410  			mdb_dbi_open (txn, &quot;representation&quot;, MDB_CREATE, &amp;store.account_store.representation_handle));
1411  			auto weight = ledger.cache.rep_weights.representation_get (nano::dev::genesis-&gt;account ());
1412  			ASSERT_EQ (MDB_SUCCESS, mdb_put (txn, store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis-&gt;account ()), nano::mdb_val (nano::uint128_union (weight)), 0));
1413  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1414  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1415  			store.version.put (transaction, 15);
1416  			ASSERT_EQ (MDB_SUCCESS, mdb_get (store.env.tx (transaction), store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1417  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
1418  		}
1419  		nano::logger_mt logger;
1420  		nano::lmdb::store store (logger, path, nano::dev::constants);
1421  		ASSERT_FALSE (store.init_error ());
1422  		auto transaction (store.tx_begin_read ());
1423  		auto error_get_representation (mdb_get (store.env.tx (transaction), store.account_store.representation_handle,
1424  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1425  		ASSERT_NE (MDB_SUCCESS, error_get_representation);
1426  		ASSERT_EQ (store.account_store.representation_handle, 0);
1427  		ASSERT_LT (15, store.version.get (transaction));
1428  	}
1429  	TEST (mdb_block_store, upgrade_v16_v17)
1430  	{
1431  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1432  		{
1433  			GTEST_SKIP ();
1434  		}
1435  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1436  		nano::block_builder builder;
1437  		auto block1 = builder
1438  					  .state ()
1439  					  .account (nano::dev::genesis_key.pub)
1440  					  .previous (nano::dev::genesis-&gt;hash ())
1441  					  .representative (nano::dev::genesis_key.pub)
1442  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1443  					  .link (nano::dev::genesis_key.pub)
1444  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1445  					  .work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1446  					  .build ();
1447  		auto block2 = builder
1448  					  .state ()
1449  					  .account (nano::dev::genesis_key.pub)
1450  					  .previous (block1-&gt;hash ())
1451  					  .representative (nano::dev::genesis_key.pub)
1452  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
1453  					  .link (nano::dev::genesis_key.pub)
1454  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1455  					  .work (*pool.generate (block1-&gt;hash ()))
1456  					  .build ();
1457  		auto block3 = builder
1458  					  .state ()
1459  					  .account (nano::dev::genesis_key.pub)
1460  					  .previous (block2-&gt;hash ())
1461  					  .representative (nano::dev::genesis_key.pub)
1462  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 2)
1463  					  .link (nano::dev::genesis_key.pub)
1464  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1465  					  .work (*pool.generate (block2-&gt;hash ()))
1466  					  .build ();
1467  		auto code = [&amp;block1, &amp;block2, &amp;block3] (auto confirmation_height, nano::block_hash const &amp; expected_cemented_frontier) {
1468  			auto path (nano::unique_path () / &quot;data.ldb&quot;);
1469  			nano::mdb_val value;
1470  			{
1471  				nano::logger_mt logger;
1472  				nano::lmdb::store store (logger, path, nano::dev::constants);
1473  				nano::stats stats;
1474  				nano::ledger ledger (store, stats, nano::dev::constants);
1475  				auto transaction (store.tx_begin_write ());
1476  				store.initialize (transaction, ledger.cache, nano::dev::constants);
1477  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1478  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1479  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
1480  				modify_confirmation_height_to_v15 (store, transaction, nano::dev::genesis-&gt;account (), confirmation_height);
1481  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1482  				write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1483  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1484  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block1);
1485  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block2);
1486  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block3);
1487  				store.version.put (transaction, 16);
1488  			}
1489  			nano::logger_mt logger;
1490  			nano::lmdb::store store (logger, path, nano::dev::constants);
1491  			ASSERT_FALSE (store.init_error ());
1492  			auto transaction (store.tx_begin_read ());
1493  			nano::confirmation_height_info confirmation_height_info;
1494  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (), confirmation_height_info));
1495  			ASSERT_EQ (confirmation_height_info.height, confirmation_height);
1496  			ASSERT_EQ (confirmation_height_info.frontier, expected_cemented_frontier);
1497  			ASSERT_LT (16, store.version.get (transaction));
1498  		};
1499  		code (0, nano::block_hash (0));
1500  		code (1, nano::dev::genesis-&gt;hash ());
1501  		code (2, block1-&gt;hash ());
1502  		code (3, block2-&gt;hash ());
1503  		code (4, block3-&gt;hash ());
1504  	}
1505  	TEST (mdb_block_store, upgrade_v17_v18)
1506  	{
1507  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1508  		{
1509  			GTEST_SKIP ();
1510  		}
1511  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1512  		nano::block_builder builder;
1513  		nano::keypair key1;
1514  		nano::keypair key2;
1515  		nano::keypair key3;
1516  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1517  		auto send_zero = builder
1518  						 .send ()
1519  						 .previous (nano::dev::genesis-&gt;hash ())
1520  						 .destination (nano::dev::genesis_key.pub)
1521  						 .balance (nano::dev::constants.genesis_amount)
1522  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1523  						 .work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1524  						 .build ();
1525  		auto state_receive_zero = builder
1526  								  .state ()
1527  								  .account (nano::dev::genesis_key.pub)
1528  								  .previous (send_zero-&gt;hash ())
1529  								  .representative (nano::dev::genesis_key.pub)
1530  								  .balance (nano::dev::constants.genesis_amount)
1531  								  .link (send_zero-&gt;hash ())
1532  								  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1533  								  .work (*pool.generate (send_zero-&gt;hash ()))
1534  								  .build ();
1535  		auto epoch = builder
1536  					 .state ()
1537  					 .account (nano::dev::genesis_key.pub)
1538  					 .previous (state_receive_zero-&gt;hash ())
1539  					 .representative (nano::dev::genesis_key.pub)
1540  					 .balance (nano::dev::constants.genesis_amount)
1541  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1542  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1543  					 .work (*pool.generate (state_receive_zero-&gt;hash ()))
1544  					 .build ();
1545  		auto state_send = builder
1546  						  .state ()
1547  						  .account (nano::dev::genesis_key.pub)
1548  						  .previous (epoch-&gt;hash ())
1549  						  .representative (nano::dev::genesis_key.pub)
1550  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1551  						  .link (nano::dev::genesis_key.pub)
1552  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1553  						  .work (*pool.generate (epoch-&gt;hash ()))
1554  						  .build ();
1555  		auto state_receive = builder
1556  							 .state ()
1557  							 .account (nano::dev::genesis_key.pub)
1558  							 .previous (state_send-&gt;hash ())
1559  							 .representative (nano::dev::genesis_key.pub)
1560  							 .balance (nano::dev::constants.genesis_amount)
1561  							 .link (state_send-&gt;hash ())
1562  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1563  							 .work (*pool.generate (state_send-&gt;hash ()))
1564  							 .build ();
1565  		auto state_change = builder
1566  							.state ()
1567  							.account (nano::dev::genesis_key.pub)
1568  							.previous (state_receive-&gt;hash ())
1569  							.representative (nano::dev::genesis_key.pub)
1570  							.balance (nano::dev::constants.genesis_amount)
1571  							.link (0)
1572  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1573  							.work (*pool.generate (state_receive-&gt;hash ()))
1574  							.build ();
1575  		auto state_send_change = builder
1576  								 .state ()
1577  								 .account (nano::dev::genesis_key.pub)
1578  								 .previous (state_change-&gt;hash ())
1579  								 .representative (key1.pub)
1580  								 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1581  								 .link (key1.pub)
1582  								 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1583  								 .work (*pool.generate (state_change-&gt;hash ()))
1584  								 .build ();
1585  		auto epoch_first = builder
1586  						   .state ()
1587  						   .account (key1.pub)
1588  						   .previous (0)
1589  						   .representative (0)
1590  						   .balance (0)
1591  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1592  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1593  						   .work (*pool.generate (key1.pub))
1594  						   .build ();
1595  		auto state_receive2 = builder
1596  							  .state ()
1597  							  .account (key1.pub)
1598  							  .previous (epoch_first-&gt;hash ())
1599  							  .representative (key1.pub)
1600  							  .balance (nano::Gxrb_ratio)
1601  							  .link (state_send_change-&gt;hash ())
1602  							  .sign (key1.prv, key1.pub)
1603  							  .work (*pool.generate (epoch_first-&gt;hash ()))
1604  							  .build ();
1605  		auto state_send2 = builder
1606  						   .state ()
1607  						   .account (nano::dev::genesis_key.pub)
1608  						   .previous (state_send_change-&gt;hash ())
1609  						   .representative (key1.pub)
1610  						   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1611  						   .link (key2.pub)
1612  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1613  						   .work (*pool.generate (state_send_change-&gt;hash ()))
1614  						   .build ();
1615  		auto state_open = builder
1616  						  .state ()
1617  						  .account (key2.pub)
1618  						  .previous (0)
1619  						  .representative (key2.pub)
1620  						  .balance (nano::Gxrb_ratio)
1621  						  .link (state_send2-&gt;hash ())
1622  						  .sign (key2.prv, key2.pub)
1623  						  .work (*pool.generate (key2.pub))
1624  						  .build ();
1625  		auto state_send_epoch_link = builder
1626  									 .state ()
1627  									 .account (key2.pub)
1628  									 .previous (state_open-&gt;hash ())
1629  									 .representative (key2.pub)
1630  									 .balance (0)
1631  									 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1632  									 .sign (key2.prv, key2.pub)
1633  									 .work (*pool.generate (state_open-&gt;hash ()))
1634  									 .build ();
1635  		{
1636  			nano::logger_mt logger;
1637  			nano::lmdb::store store (logger, path, nano::dev::constants);
1638  			auto transaction (store.tx_begin_write ());
1639  			nano::stats stats;
1640  			nano::ledger ledger (store, stats, nano::dev::constants);
1641  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1642  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_zero).code);
1643  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive_zero).code);
1644  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1645  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1646  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1647  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_change).code);
1648  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_change).code);
1649  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_first).code);
1650  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive2).code);
1651  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
1652  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1653  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_epoch_link).code);
1654  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1655  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1656  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1657  			store.version.put (transaction, 17);
1658  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_receive);
1659  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *epoch_first);
1660  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send2);
1661  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send_epoch_link);
1662  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1663  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send_zero);
1664  			write_sideband_v15 (store, transaction, *state_receive_zero);
1665  			write_sideband_v15 (store, transaction, *epoch);
1666  			write_sideband_v15 (store, transaction, *state_send);
1667  			write_sideband_v15 (store, transaction, *state_change);
1668  			write_sideband_v15 (store, transaction, *state_send_change);
1669  			write_sideband_v15 (store, transaction, *state_receive2);
1670  			write_sideband_v15 (store, transaction, *state_open);
1671  			store.block.del (transaction, state_receive_zero-&gt;hash ());
1672  			store.block.del (transaction, epoch-&gt;hash ());
1673  			store.block.del (transaction, state_send-&gt;hash ());
1674  			store.block.del (transaction, state_change-&gt;hash ());
1675  			store.block.del (transaction, state_send_change-&gt;hash ());
1676  			store.block.del (transaction, state_receive2-&gt;hash ());
1677  			store.block.del (transaction, state_open-&gt;hash ());
1678  		}
1679  		nano::logger_mt logger;
1680  		nano::lmdb::store store (logger, path, nano::dev::constants);
1681  		ASSERT_FALSE (store.init_error ());
1682  		auto transaction (store.tx_begin_read ());
1683  		nano::mdb_val value;
1684  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.block_store.blocks_handle, nano::mdb_val (state_send-&gt;hash ()), value));
1685  		ASSERT_EQ (value.size (), sizeof (nano::block_type) + nano::state_block::size + nano::block_sideband::size (nano::block_type::state));
1686  		{
1687  			auto block = store.block.get (transaction, send_zero-&gt;hash ());
1688  			ASSERT_NE (block, nullptr);
1689  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1690  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1691  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1692  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1693  		}
1694  		{
1695  			auto block = store.block.get (transaction, state_receive_zero-&gt;hash ());
1696  			ASSERT_NE (block, nullptr);
1697  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1698  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1699  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1700  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1701  		}
1702  		{
1703  			auto block = store.block.get (transaction, epoch-&gt;hash ());
1704  			ASSERT_NE (block, nullptr);
1705  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1706  			ASSERT_TRUE (block-&gt;sideband ().details.is_epoch);
1707  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1708  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1709  		}
1710  		{
1711  			auto block = store.block.get (transaction, state_send-&gt;hash ());
1712  			ASSERT_NE (block, nullptr);
1713  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1714  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1715  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1716  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1717  		}
1718  		{
1719  			auto block = store.block.get (transaction, state_receive-&gt;hash ());
1720  			ASSERT_NE (block, nullptr);
1721  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1722  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1723  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1724  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1725  		}
1726  		{
1727  			auto block = store.block.get (transaction, state_change-&gt;hash ());
1728  			ASSERT_NE (block, nullptr);
1729  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1730  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1731  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1732  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1733  		}
1734  		{
1735  			auto block = store.block.get (transaction, state_send_change-&gt;hash ());
1736  			ASSERT_NE (block, nullptr);
1737  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1738  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1739  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1740  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1741  		}
1742  		{
1743  			auto block = store.block.get (transaction, epoch_first-&gt;hash ());
1744  			ASSERT_NE (block, nullptr);
1745  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_2);
1746  			ASSERT_TRUE (block-&gt;sideband ().details.is_epoch);
1747  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1748  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1749  		}
1750  		{
1751  			auto block = store.block.get (transaction, state_receive2-&gt;hash ());
1752  			ASSERT_NE (block, nullptr);
1753  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_2);
1754  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1755  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1756  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1757  		}
1758  		{
1759  			auto block = store.block.get (transaction, state_send2-&gt;hash ());
1760  			ASSERT_NE (block, nullptr);
1761  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1762  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1763  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1764  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1765  		}
1766  		{
1767  			auto block = store.block.get (transaction, state_open-&gt;hash ());
1768  			ASSERT_NE (block, nullptr);
1769  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1770  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1771  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1772  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1773  		}
1774  		{
1775  			auto block = store.block.get (transaction, state_send_epoch_link-&gt;hash ());
1776  			ASSERT_NE (block, nullptr);
1777  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1778  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1779  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1780  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1781  		}
1782  		ASSERT_LT (17, store.version.get (transaction));
1783  	}
1784  	TEST (mdb_block_store, upgrade_v18_v19)
1785  	{
1786  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1787  		{
1788  			GTEST_SKIP ();
1789  		}
1790  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1791  		nano::keypair key1;
1792  		nano::block_builder builder;
1793  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1794  		auto send = builder
1795  					.send ()
1796  					.previous (nano::dev::genesis-&gt;hash ())
1797  					.destination (nano::dev::genesis_key.pub)
1798  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1799  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1800  					.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1801  					.build ();
1802  		auto receive = builder
1803  					   .receive ()
1804  					   .previous (send-&gt;hash ())
1805  					   .source (send-&gt;hash ())
1806  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1807  					   .work (*pool.generate (send-&gt;hash ()))
1808  					   .build ();
1809  		auto change = builder
1810  					  .change ()
1811  					  .previous (receive-&gt;hash ())
1812  					  .representative (0)
1813  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1814  					  .work (*pool.generate (receive-&gt;hash ()))
1815  					  .build ();
1816  		auto state_epoch = builder
1817  						   .state ()
1818  						   .account (nano::dev::genesis_key.pub)
1819  						   .previous (change-&gt;hash ())
1820  						   .representative (0)
1821  						   .balance (nano::dev::constants.genesis_amount)
1822  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1823  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  						   .work (*pool.generate (change-&gt;hash ()))
1825  						   .build ();
1826  		auto state_send = builder
1827  						  .state ()
1828  						  .account (nano::dev::genesis_key.pub)
1829  						  .previous (state_epoch-&gt;hash ())
1830  						  .representative (0)
1831  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1832  						  .link (key1.pub)
1833  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1834  						  .work (*pool.generate (state_epoch-&gt;hash ()))
1835  						  .build ();
1836  		auto state_open = builder
1837  						  .state ()
1838  						  .account (key1.pub)
1839  						  .previous (0)
1840  						  .representative (0)
1841  						  .balance (nano::Gxrb_ratio)
1842  						  .link (state_send-&gt;hash ())
1843  						  .sign (key1.prv, key1.pub)
1844  						  .work (*pool.generate (key1.pub))
1845  						  .build ();
1846  		{
1847  			nano::logger_mt logger;
1848  			nano::lmdb::store store (logger, path, nano::dev::constants);
1849  			nano::stats stats;
1850  			nano::ledger ledger (store, stats, nano::dev::constants);
1851  			auto transaction (store.tx_begin_write ());
1852  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1853  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1854  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
1855  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
1856  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_epoch).code);
1857  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1858  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1859  			auto txn = store.env.tx (transaction);
1860  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1861  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;receive&quot;, MDB_CREATE, &amp;store.block_store.receive_blocks_handle));
1862  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1863  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;change&quot;, MDB_CREATE, &amp;store.block_store.change_blocks_handle));
1864  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1865  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1866  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1867  			write_block_w_sideband_v18 (store, store.block_store.receive_blocks_handle, transaction, *receive);
1868  			write_block_w_sideband_v18 (store, store.block_store.change_blocks_handle, transaction, *change);
1869  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_epoch);
1870  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send);
1871  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_open);
1872  			store.version.put (transaction, 18);
1873  		}
1874  		nano::logger_mt logger;
1875  		nano::lmdb::store store (logger, path, nano::dev::constants);
1876  		ASSERT_FALSE (store.init_error ());
1877  		auto transaction (store.tx_begin_read ());
1878  		ASSERT_EQ (store.block_store.send_blocks_handle, 0);
1879  		ASSERT_EQ (store.block_store.receive_blocks_handle, 0);
1880  		ASSERT_EQ (store.block_store.change_blocks_handle, 0);
1881  		ASSERT_EQ (store.block_store.open_blocks_handle, 0);
1882  		ASSERT_EQ (store.block_store.state_blocks_handle, 0);
1883  		ASSERT_TRUE (store.block.get (transaction, send-&gt;hash ()));
1884  		ASSERT_TRUE (store.block.get (transaction, receive-&gt;hash ()));
1885  		ASSERT_TRUE (store.block.get (transaction, change-&gt;hash ()));
1886  		ASSERT_TRUE (store.block.get (transaction, nano::dev::genesis-&gt;hash ()));
1887  		auto state_epoch_disk (store.block.get (transaction, state_epoch-&gt;hash ()));
1888  		ASSERT_NE (nullptr, state_epoch_disk);
1889  		ASSERT_EQ (nano::epoch::epoch_1, state_epoch_disk-&gt;sideband ().details.epoch);
1890  		ASSERT_EQ (nano::epoch::epoch_0, state_epoch_disk-&gt;sideband ().source_epoch); 
1891  		ASSERT_TRUE (store.block.get (transaction, state_send-&gt;hash ()));
1892  		auto state_send_disk (store.block.get (transaction, state_send-&gt;hash ()));
1893  		ASSERT_NE (nullptr, state_send_disk);
1894  		ASSERT_EQ (nano::epoch::epoch_1, state_send_disk-&gt;sideband ().details.epoch);
1895  		ASSERT_EQ (nano::epoch::epoch_0, state_send_disk-&gt;sideband ().source_epoch); 
1896  		ASSERT_TRUE (store.block.get (transaction, state_open-&gt;hash ()));
1897  		auto state_open_disk (store.block.get (transaction, state_open-&gt;hash ()));
1898  		ASSERT_NE (nullptr, state_open_disk);
1899  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk-&gt;sideband ().details.epoch);
1900  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk-&gt;sideband ().source_epoch);
1901  		ASSERT_EQ (7, store.count (transaction, store.block_store.blocks_handle));
1902  		ASSERT_LT (18, store.version.get (transaction));
1903  	}
1904  	TEST (mdb_block_store, upgrade_v19_v20)
1905  	{
1906  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1907  		{
1908  			GTEST_SKIP ();
1909  		}
1910  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1911  		nano::logger_mt logger;
1912  		nano::stats stats;
1913  		{
1914  			nano::lmdb::store store (logger, path, nano::dev::constants);
1915  			nano::ledger ledger (store, stats, nano::dev::constants);
1916  			auto transaction (store.tx_begin_write ());
1917  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1918  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.pruned_store.pruned_handle, 1));
1919  			store.version.put (transaction, 19);
1920  		}
1921  		nano::lmdb::store store (logger, path, nano::dev::constants);
1922  		ASSERT_FALSE (store.init_error ());
1923  		ASSERT_NE (store.pruned_store.pruned_handle, 0);
1924  		auto transaction (store.tx_begin_read ());
1925  		ASSERT_LT (19, store.version.get (transaction));
1926  	}
1927  	TEST (mdb_block_store, upgrade_v20_v21)
1928  	{
1929  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1930  		{
1931  			GTEST_SKIP ();
1932  		}
1933  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1934  		nano::logger_mt logger;
1935  		nano::stats stats;
1936  		{
1937  			nano::lmdb::store store (logger, path, nano::dev::constants);
1938  			nano::ledger ledger (store, stats, nano::dev::constants);
1939  			auto transaction (store.tx_begin_write ());
1940  			store.initialize (transaction, ledger.cache, ledger.constants);
1941  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.final_vote_store.final_votes_handle, 1));
1942  			store.version.put (transaction, 20);
1943  		}
1944  		nano::lmdb::store store (logger, path, nano::dev::constants);
1945  		ASSERT_FALSE (store.init_error ());
1946  		ASSERT_NE (store.final_vote_store.final_votes_handle, 0);
1947  		auto transaction (store.tx_begin_read ());
1948  		ASSERT_LT (19, store.version.get (transaction));
1949  	}
1950  	TEST (mdb_block_store, upgrade_v21_v22)
1951  	{
1952  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1953  		{
1954  			GTEST_SKIP ();
1955  		}
1956  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1957  		nano::logger_mt logger;
1958  		nano::stats stats;
1959  		auto const check_correct_state = [&amp;] () {
1960  			nano::lmdb::store store (logger, path, nano::dev::constants);
1961  			auto transaction (store.tx_begin_write ());
1962  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1963  			MDB_dbi unchecked_handle{ 0 };
1964  			ASSERT_EQ (MDB_NOTFOUND, mdb_dbi_open (store.env.tx (transaction), &quot;unchecked&quot;, 0, &amp;unchecked_handle));
1965  		};
1966  		check_correct_state ();
1967  		{
1968  			nano::lmdb::store store (logger, path, nano::dev::constants);
1969  			auto transaction (store.tx_begin_write ());
1970  			store.version.put (transaction, 21);
1971  			MDB_dbi unchecked_handle{ 0 };
1972  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;unchecked&quot;, MDB_CREATE, &amp;unchecked_handle));
1973  			ASSERT_EQ (store.version.get (transaction), 21);
1974  		}
1975  		check_correct_state ();
1976  	}
1977  }
1978  namespace rocksdb
1979  {
1980  	TEST (rocksdb_block_store, upgrade_v21_v22)
1981  	{
1982  		if (!nano::rocksdb_config::using_rocksdb_in_tests ())
1983  		{
1984  			GTEST_SKIP ();
1985  		}
1986  		auto const path = nano::unique_path () / &quot;rocksdb&quot;;
1987  		nano::logger_mt logger;
1988  		nano::stats stats;
1989  		auto const check_correct_state = [&amp;] () {
1990  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1991  			auto transaction (store.tx_begin_write ());
1992  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1993  			ASSERT_FALSE (store.column_family_exists (&quot;unchecked&quot;));
1994  		};
1995  		check_correct_state ();
1996  		{
1997  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1998  			::rocksdb::ColumnFamilyOptions new_cf_options;
1999  			::rocksdb::ColumnFamilyHandle * new_cf_handle;
2000  			::rocksdb::Status status = store.db-&gt;CreateColumnFamily (new_cf_options, &quot;unchecked&quot;, &amp;new_cf_handle);
2001  			store.handles.emplace_back (new_cf_handle);
2002  			ASSERT_TRUE (status.ok ());
2003  			auto transaction (store.tx_begin_write ());
2004  			store.version.put (transaction, 21);
2005  			ASSERT_EQ (store.version.get (transaction), 21);
2006  		}
2007  		check_correct_state ();
2008  	}
2009  }
2010  }
2011  TEST (mdb_block_store, upgrade_backup)
2012  {
2013  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2014  	{
2015  		GTEST_SKIP ();
2016  	}
2017  	auto dir (nano::unique_path ());
2018  	namespace fs = boost::filesystem;
2019  	fs::create_directory (dir);
2020  	auto path = dir / &quot;data.ldb&quot;;
2021  	auto get_backup_path = [&amp;dir] () {
2022  		for (fs::directory_iterator itr (dir); itr != fs::directory_iterator (); ++itr)
2023  		{
2024  			if (itr-&gt;path ().filename ().string ().find (&quot;data_backup_&quot;) != std::string::npos)
2025  			{
2026  				return itr-&gt;path ();
2027  			}
2028  		}
2029  		return dir;
2030  	};
2031  	{
2032  		nano::logger_mt logger;
2033  		nano::lmdb::store store (logger, path, nano::dev::constants);
2034  		auto transaction (store.tx_begin_write ());
2035  		store.version.put (transaction, 14);
2036  	}
2037  	ASSERT_EQ (get_backup_path ().string (), dir.string ());
2038  	nano::logger_mt logger;
2039  	nano::lmdb::store store (logger, path, nano::dev::constants, nano::txn_tracking_config{}, std::chrono::seconds (5), nano::lmdb_config{}, true);
2040  	ASSERT_FALSE (store.init_error ());
2041  	auto transaction (store.tx_begin_read ());
2042  	ASSERT_LT (14, store.version.get (transaction));
2043  	ASSERT_NE (get_backup_path ().string (), dir.string ());
2044  }
2045  TEST (block_store, confirmation_height)
2046  {
2047  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2048  	{
2049  		GTEST_SKIP ();
2050  	}
2051  	auto path (nano::unique_path ());
2052  	nano::logger_mt logger;
2053  	auto store = nano::make_store (logger, path, nano::dev::constants);
2054  	nano::account account1{};
2055  	nano::account account2{ 1 };
2056  	nano::account account3{ 2 };
2057  	nano::block_hash cemented_frontier1 (3);
2058  	nano::block_hash cemented_frontier2 (4);
2059  	nano::block_hash cemented_frontier3 (5);
2060  	{
2061  		auto transaction (store-&gt;tx_begin_write ());
2062  		store-&gt;confirmation_height.put (transaction, account1, { 500, cemented_frontier1 });
2063  		store-&gt;confirmation_height.put (transaction, account2, { std::numeric_limits&lt;uint64_t&gt;::max (), cemented_frontier2 });
2064  		store-&gt;confirmation_height.put (transaction, account3, { 10, cemented_frontier3 });
<span onclick='openModal()' class='match'>2065  		nano::confirmation_height_info confirmation_height_info;
2066  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
2067  		ASSERT_EQ (confirmation_height_info.height, 500);
</span>2068  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier1);
2069  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
2070  		ASSERT_EQ (confirmation_height_info.height, std::numeric_limits&lt;uint64_t&gt;::max ());
2071  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier2);
2072  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account3, confirmation_height_info));
2073  		ASSERT_EQ (confirmation_height_info.height, 10);
2074  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier3);
2075  		store-&gt;confirmation_height.clear (transaction);
2076  	}
2077  	auto transaction (store-&gt;tx_begin_read ());
2078  	ASSERT_EQ (store-&gt;confirmation_height.count (transaction), 0);
2079  	nano::confirmation_height_info confirmation_height_info;
2080  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
2081  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
2082  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account3, confirmation_height_info));
2083  }
2084  TEST (block_store, final_vote)
2085  {
2086  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2087  	{
2088  		GTEST_SKIP ();
2089  	}
2090  	auto path (nano::unique_path ());
2091  	nano::logger_mt logger;
2092  	auto store = nano::make_store (logger, path, nano::dev::constants);
2093  	{
2094  		auto qualified_root = nano::dev::genesis-&gt;qualified_root ();
2095  		auto transaction (store-&gt;tx_begin_write ());
2096  		store-&gt;final_vote.put (transaction, qualified_root, nano::block_hash (2));
2097  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2098  		store-&gt;final_vote.clear (transaction);
2099  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 0);
2100  		store-&gt;final_vote.put (transaction, qualified_root, nano::block_hash (2));
2101  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2102  		store-&gt;final_vote.clear (transaction, qualified_root.previous ());
2103  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2104  		store-&gt;final_vote.clear (transaction, qualified_root.root ());
2105  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 0);
2106  	}
2107  }
2108  TEST (block_store, incompatible_version)
2109  {
2110  	auto path (nano::unique_path ());
2111  	nano::logger_mt logger;
2112  	{
2113  		auto store = nano::make_store (logger, path, nano::dev::constants);
2114  		ASSERT_FALSE (store-&gt;init_error ());
2115  		auto transaction (store-&gt;tx_begin_write ());
2116  		store-&gt;version.put (transaction, std::numeric_limits&lt;int&gt;::max ());
2117  	}
2118  	{
2119  		auto store = nano::make_store (logger, path, nano::dev::constants, true);
2120  		ASSERT_TRUE (store-&gt;init_error ());
2121  		auto transaction = store-&gt;tx_begin_read ();
2122  		auto version_l = store-&gt;version.get (transaction);
2123  		ASSERT_EQ (version_l, std::numeric_limits&lt;int&gt;::max ());
2124  	}
2125  }
2126  TEST (block_store, reset_renew_existing_transaction)
2127  {
2128  	nano::logger_mt logger;
2129  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2130  	ASSERT_TRUE (!store-&gt;init_error ());
2131  	nano::keypair key1;
2132  	nano::block_builder builder;
2133  	auto block = builder
2134  				 .open ()
2135  				 .source (0)
2136  				 .representative (1)
2137  				 .account (1)
2138  				 .sign (nano::keypair ().prv, 0)
2139  				 .work (0)
2140  				 .build ();
2141  	block-&gt;sideband_set ({});
2142  	auto hash1 (block-&gt;hash ());
2143  	auto read_transaction = store-&gt;tx_begin_read ();
2144  	auto block_non_existing (store-&gt;block.get (read_transaction, hash1));
2145  	ASSERT_EQ (nullptr, block_non_existing);
2146  	read_transaction.reset ();
2147  	{
2148  		auto write_transaction (store-&gt;tx_begin_write ());
2149  		store-&gt;block.put (write_transaction, hash1, *block);
2150  	}
2151  	read_transaction.renew ();
2152  	auto block_existing (store-&gt;block.get (read_transaction, hash1));
2153  	ASSERT_NE (nullptr, block_existing);
2154  }
2155  TEST (block_store, rocksdb_force_test_env_variable)
2156  {
2157  	nano::logger_mt logger;
2158  	constexpr auto env_var = &quot;TEST_USE_ROCKSDB&quot;;
2159  	auto value = std::getenv (env_var);
2160  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2161  	auto mdb_cast = dynamic_cast&lt;nano::lmdb::store *&gt; (store.get ());
2162  	if (value &amp;&amp; boost::lexical_cast&lt;int&gt; (value) == 1)
2163  	{
2164  		ASSERT_NE (boost::polymorphic_downcast&lt;nano::rocksdb::store *&gt; (store.get ()), nullptr);
2165  	}
2166  	else
2167  	{
2168  		ASSERT_NE (mdb_cast, nullptr);
2169  	}
2170  }
2171  namespace nano
2172  {
2173  TEST (rocksdb_block_store, tombstone_count)
2174  {
2175  	if (!nano::rocksdb_config::using_rocksdb_in_tests ())
2176  	{
2177  		GTEST_SKIP ();
2178  	}
2179  	nano::test::system system;
2180  	nano::logger_mt logger;
2181  	auto store = std::make_unique&lt;nano::rocksdb::store&gt; (logger, nano::unique_path () / &quot;rocksdb&quot;, nano::dev::constants);
2182  	ASSERT_TRUE (!store-&gt;init_error ());
2183  	nano::block_builder builder;
2184  	auto block = builder
2185  				 .send ()
2186  				 .previous (0)
2187  				 .destination (1)
2188  				 .balance (2)
2189  				 .sign (nano::keypair ().prv, 4)
2190  				 .work (5)
2191  				 .build_shared ();
2192  	nano::account account{ 1 };
2193  	store-&gt;account.put (store-&gt;tx_begin_write (), account, nano::account_info{});
2194  	auto check_block_is_listed = [&amp;] (nano::transaction const &amp; transaction_a) {
2195  		return store-&gt;account.exists (transaction_a, account);
2196  	};
2197  	ASSERT_TIMELY (5s, check_block_is_listed (store-&gt;tx_begin_read ()));
2198  	ASSERT_EQ (store-&gt;tombstone_map.at (nano::tables::accounts).num_since_last_flush.load (), 0);
2199  	store-&gt;account.del (store-&gt;tx_begin_write (), account);
2200  	ASSERT_TIMELY (5s, store-&gt;tombstone_map.at (nano::tables::accounts).num_since_last_flush.load () == 1);
2201  }
2202  }
2203  namespace nano
2204  {
2205  namespace lmdb
2206  {
2207  	void write_sideband_v14 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a, MDB_dbi db_a)
2208  	{
2209  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2210  		ASSERT_NE (block, nullptr);
2211  		nano::block_sideband_v14 sideband_v14 (block-&gt;type (), block-&gt;sideband ().account, block-&gt;sideband ().successor, block-&gt;sideband ().balance, block-&gt;sideband ().timestamp, block-&gt;sideband ().height);
2212  		std::vector&lt;uint8_t&gt; data;
2213  		{
2214  			nano::vectorstream stream (data);
2215  			block_a.serialize (stream);
2216  			sideband_v14.serialize (stream);
2217  		}
2218  		MDB_val val{ data.size (), data.data () };
2219  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), block-&gt;sideband ().details.epoch == nano::epoch::epoch_0 ? store_a.block_store.state_blocks_v0_handle : store_a.block_store.state_blocks_v1_handle, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2220  	}
2221  	void write_sideband_v15 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a)
2222  	{
2223  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2224  		ASSERT_NE (block, nullptr);
2225  		ASSERT_LE (block-&gt;sideband ().details.epoch, nano::epoch::max);
2226  		nano::block_sideband_v18 sideband_v15 (block-&gt;sideband ().account, block-&gt;sideband ().successor, block-&gt;sideband ().balance, block-&gt;sideband ().timestamp, block-&gt;sideband ().height, block-&gt;sideband ().details.epoch, false, false, false);
2227  		std::vector&lt;uint8_t&gt; data;
2228  		{
2229  			nano::vectorstream stream (data);
2230  			block_a.serialize (stream);
2231  			sideband_v15.serialize (stream, block_a.type ());
2232  		}
2233  		MDB_val val{ data.size (), data.data () };
2234  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), store_a.block_store.state_blocks_handle, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2235  	}
2236  	void write_block_w_sideband_v18 (nano::lmdb::store &amp; store_a, MDB_dbi database, nano::write_transaction &amp; transaction_a, nano::block const &amp; block_a)
2237  	{
2238  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2239  		ASSERT_NE (block, nullptr);
2240  		auto new_sideband (block-&gt;sideband ());
2241  		nano::block_sideband_v18 sideband_v18 (new_sideband.account, new_sideband.successor, new_sideband.balance, new_sideband.height, new_sideband.timestamp, new_sideband.details.epoch, new_sideband.details.is_send, new_sideband.details.is_receive, new_sideband.details.is_epoch);
2242  		std::vector&lt;uint8_t&gt; data;
2243  		{
2244  			nano::vectorstream stream (data);
2245  			block-&gt;serialize (stream);
2246  			sideband_v18.serialize (stream, block-&gt;type ());
2247  		}
2248  		MDB_val val{ data.size (), data.data () };
2249  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), database, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2250  		store_a.del (transaction_a, nano::tables::blocks, nano::mdb_val (block_a.hash ()));
2251  	}
2252  	void modify_account_info_to_v14 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height, nano::block_hash const &amp; rep_block)
2253  	{
2254  		nano::account_info info;
2255  		ASSERT_FALSE (store.account.get (transaction, account, info));
2256  		nano::account_info_v14 account_info_v14 (info.head, rep_block, info.open_block, info.balance, info.modified, info.block_count, confirmation_height, info.epoch ());
2257  		auto status (mdb_put (store.env.tx (transaction), info.epoch () == nano::epoch::epoch_0 ? store.account_store.accounts_v0_handle : store.account_store.accounts_v1_handle, nano::mdb_val (account), nano::mdb_val (account_info_v14), 0));
2258  		ASSERT_EQ (status, 0);
2259  	}
2260  	void modify_confirmation_height_to_v15 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height)
2261  	{
2262  		auto status (mdb_put (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle, nano::mdb_val (account), nano::mdb_val (confirmation_height), 0));
2263  		ASSERT_EQ (status, 0);
2264  	}
2265  }
2266  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/lmdbconfig.hpp&gt;
3  #include &lt;nano/lib/logger_mt.hpp&gt;
4  #include &lt;nano/lib/stats.hpp&gt;
5  #include &lt;nano/lib/utility.hpp&gt;
6  #include &lt;nano/lib/work.hpp&gt;
7  #include &lt;nano/node/common.hpp&gt;
8  #include &lt;nano/node/lmdb/lmdb.hpp&gt;
9  #include &lt;nano/node/rocksdb/rocksdb.hpp&gt;
10  #include &lt;nano/secure/ledger.hpp&gt;
11  #include &lt;nano/secure/utility.hpp&gt;
12  #include &lt;nano/secure/versioning.hpp&gt;
13  #include &lt;nano/test_common/system.hpp&gt;
14  #include &lt;nano/test_common/testutil.hpp&gt;
15  #include &lt;gtest/gtest.h&gt;
16  #include &lt;boost/filesystem.hpp&gt;
17  #include &lt;cstdlib&gt;
18  #include &lt;fstream&gt;
19  #include &lt;unordered_set&gt;
20  #include &lt;vector&gt;
21  using namespace std::chrono_literals;
22  namespace nano
23  {
24  namespace lmdb
25  {
26  	void modify_account_info_to_v14 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction_a, nano::account const &amp; account_a, uint64_t confirmation_height, nano::block_hash const &amp; rep_block);
27  	void modify_confirmation_height_to_v15 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height);
28  	void write_sideband_v14 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a, MDB_dbi db_a);
29  	void write_sideband_v15 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a);
30  	void write_block_w_sideband_v18 (nano::lmdb::store &amp; store_a, MDB_dbi database, nano::write_transaction &amp; transaction_a, nano::block const &amp; block_a);
31  }
32  }
33  TEST (block_store, construction)
34  {
35  	nano::logger_mt logger;
36  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
37  	ASSERT_TRUE (!store-&gt;init_error ());
38  }
39  TEST (block_store, block_details)
40  {
41  	nano::block_details details_send (nano::epoch::epoch_0, true, false, false);
42  	ASSERT_TRUE (details_send.is_send);
43  	ASSERT_FALSE (details_send.is_receive);
44  	ASSERT_FALSE (details_send.is_epoch);
45  	ASSERT_EQ (nano::epoch::epoch_0, details_send.epoch);
46  	nano::block_details details_receive (nano::epoch::epoch_1, false, true, false);
47  	ASSERT_FALSE (details_receive.is_send);
48  	ASSERT_TRUE (details_receive.is_receive);
49  	ASSERT_FALSE (details_receive.is_epoch);
50  	ASSERT_EQ (nano::epoch::epoch_1, details_receive.epoch);
51  	nano::block_details details_epoch (nano::epoch::epoch_2, false, false, true);
52  	ASSERT_FALSE (details_epoch.is_send);
53  	ASSERT_FALSE (details_epoch.is_receive);
54  	ASSERT_TRUE (details_epoch.is_epoch);
55  	ASSERT_EQ (nano::epoch::epoch_2, details_epoch.epoch);
56  	nano::block_details details_none (nano::epoch::unspecified, false, false, false);
57  	ASSERT_FALSE (details_none.is_send);
58  	ASSERT_FALSE (details_none.is_receive);
59  	ASSERT_FALSE (details_none.is_epoch);
60  	ASSERT_EQ (nano::epoch::unspecified, details_none.epoch);
61  }
62  TEST (block_store, block_details_serialization)
63  {
64  	nano::block_details details1;
65  	details1.epoch = nano::epoch::epoch_2;
66  	details1.is_epoch = false;
67  	details1.is_receive = true;
68  	details1.is_send = false;
69  	std::vector&lt;uint8_t&gt; vector;
70  	{
71  		nano::vectorstream stream1 (vector);
72  		details1.serialize (stream1);
73  	}
74  	nano::bufferstream stream2 (vector.data (), vector.size ());
75  	nano::block_details details2;
76  	ASSERT_FALSE (details2.deserialize (stream2));
77  	ASSERT_EQ (details1, details2);
78  }
79  TEST (block_store, sideband_serialization)
80  {
81  	nano::block_sideband sideband1;
82  	sideband1.account = 1;
83  	sideband1.balance = 2;
84  	sideband1.height = 3;
85  	sideband1.successor = 4;
86  	sideband1.timestamp = 5;
87  	std::vector&lt;uint8_t&gt; vector;
88  	{
89  		nano::vectorstream stream1 (vector);
90  		sideband1.serialize (stream1, nano::block_type::receive);
91  	}
92  	nano::bufferstream stream2 (vector.data (), vector.size ());
93  	nano::block_sideband sideband2;
94  	ASSERT_FALSE (sideband2.deserialize (stream2, nano::block_type::receive));
95  	ASSERT_EQ (sideband1.account, sideband2.account);
96  	ASSERT_EQ (sideband1.balance, sideband2.balance);
97  	ASSERT_EQ (sideband1.height, sideband2.height);
98  	ASSERT_EQ (sideband1.successor, sideband2.successor);
99  	ASSERT_EQ (sideband1.timestamp, sideband2.timestamp);
100  }
101  TEST (block_store, add_item)
102  {
103  	nano::logger_mt logger;
104  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
105  	ASSERT_TRUE (!store-&gt;init_error ());
106  	nano::block_builder builder;
107  	auto block = builder
108  				 .open ()
109  				 .source (0)
110  				 .representative (1)
111  				 .account (0)
112  				 .sign (nano::keypair ().prv, 0)
113  				 .work (0)
114  				 .build ();
115  	block-&gt;sideband_set ({});
116  	auto hash1 (block-&gt;hash ());
117  	auto transaction (store-&gt;tx_begin_write ());
118  	auto latest1 (store-&gt;block.get (transaction, hash1));
119  	ASSERT_EQ (nullptr, latest1);
120  	ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
121  	store-&gt;block.put (transaction, hash1, *block);
122  	auto latest2 (store-&gt;block.get (transaction, hash1));
123  	ASSERT_NE (nullptr, latest2);
124  	ASSERT_EQ (*block, *latest2);
125  	ASSERT_TRUE (store-&gt;block.exists (transaction, hash1));
126  	ASSERT_FALSE (store-&gt;block.exists (transaction, hash1.number () - 1));
127  	store-&gt;block.del (transaction, hash1);
128  	auto latest3 (store-&gt;block.get (transaction, hash1));
129  	ASSERT_EQ (nullptr, latest3);
130  }
131  TEST (block_store, clear_successor)
132  {
133  	nano::logger_mt logger;
134  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
135  	ASSERT_TRUE (!store-&gt;init_error ());
136  	nano::block_builder builder;
137  	auto block1 = builder
138  				  .open ()
139  				  .source (0)
140  				  .representative (1)
141  				  .account (0)
142  				  .sign (nano::keypair ().prv, 0)
143  				  .work (0)
144  				  .build ();
145  	block1-&gt;sideband_set ({});
146  	auto transaction (store-&gt;tx_begin_write ());
147  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
148  	auto block2 = builder
149  				  .open ()
150  				  .source (0)
151  				  .representative (2)
152  				  .account (0)
153  				  .sign (nano::keypair ().prv, 0)
154  				  .work (0)
155  				  .build ();
156  	block2-&gt;sideband_set ({});
157  	store-&gt;block.put (transaction, block2-&gt;hash (), *block2);
158  	auto block2_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
159  	ASSERT_NE (nullptr, block2_store);
160  	ASSERT_EQ (0, block2_store-&gt;sideband ().successor.number ());
161  	auto modified_sideband = block2_store-&gt;sideband ();
162  	modified_sideband.successor = block2-&gt;hash ();
163  	block1-&gt;sideband_set (modified_sideband);
164  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
165  	{
166  		auto block1_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
167  		ASSERT_NE (nullptr, block1_store);
168  		ASSERT_EQ (block2-&gt;hash (), block1_store-&gt;sideband ().successor);
169  	}
170  	store-&gt;block.successor_clear (transaction, block1-&gt;hash ());
171  	{
172  		auto block1_store (store-&gt;block.get (transaction, block1-&gt;hash ()));
173  		ASSERT_NE (nullptr, block1_store);
174  		ASSERT_EQ (0, block1_store-&gt;sideband ().successor.number ());
175  	}
176  }
177  TEST (block_store, add_nonempty_block)
178  {
179  	nano::logger_mt logger;
180  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
181  	ASSERT_TRUE (!store-&gt;init_error ());
182  	nano::keypair key1;
183  	nano::block_builder builder;
184  	auto block = builder
185  				 .open ()
186  				 .source (0)
187  				 .representative (1)
188  				 .account (0)
189  				 .sign (nano::keypair ().prv, 0)
190  				 .work (0)
191  				 .build ();
192  	block-&gt;sideband_set ({});
193  	auto hash1 (block-&gt;hash ());
194  	block-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash1);
195  	auto transaction (store-&gt;tx_begin_write ());
196  	auto latest1 (store-&gt;block.get (transaction, hash1));
197  	ASSERT_EQ (nullptr, latest1);
198  	store-&gt;block.put (transaction, hash1, *block);
199  	auto latest2 (store-&gt;block.get (transaction, hash1));
200  	ASSERT_NE (nullptr, latest2);
201  	ASSERT_EQ (*block, *latest2);
202  }
203  TEST (block_store, add_two_items)
204  {
205  	nano::logger_mt logger;
206  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
207  	ASSERT_TRUE (!store-&gt;init_error ());
208  	nano::keypair key1;
209  	nano::block_builder builder;
210  	auto block = builder
211  				 .open ()
212  				 .source (0)
213  				 .representative (1)
214  				 .account (1)
215  				 .sign (nano::keypair ().prv, 0)
216  				 .work (0)
217  				 .build ();
218  	block-&gt;sideband_set ({});
219  	auto hash1 (block-&gt;hash ());
220  	block-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash1);
221  	auto transaction (store-&gt;tx_begin_write ());
222  	auto latest1 (store-&gt;block.get (transaction, hash1));
223  	ASSERT_EQ (nullptr, latest1);
224  	auto block2 = builder
225  				  .open ()
226  				  .source (0)
227  				  .representative (1)
228  				  .account (3)
229  				  .sign (nano::keypair ().prv, 0)
230  				  .work (0)
231  				  .build ();
232  	block2-&gt;sideband_set ({});
233  	block2-&gt;hashables.account = 3;
234  	auto hash2 (block2-&gt;hash ());
235  	block2-&gt;signature = nano::sign_message (key1.prv, key1.pub, hash2);
236  	auto latest2 (store-&gt;block.get (transaction, hash2));
237  	ASSERT_EQ (nullptr, latest2);
238  	store-&gt;block.put (transaction, hash1, *block);
239  	store-&gt;block.put (transaction, hash2, *block2);
240  	auto latest3 (store-&gt;block.get (transaction, hash1));
241  	ASSERT_NE (nullptr, latest3);
242  	ASSERT_EQ (*block, *latest3);
243  	auto latest4 (store-&gt;block.get (transaction, hash2));
244  	ASSERT_NE (nullptr, latest4);
245  	ASSERT_EQ (*block2, *latest4);
246  	ASSERT_FALSE (*latest3 == *latest4);
247  }
248  TEST (block_store, add_receive)
249  {
250  	nano::logger_mt logger;
251  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
252  	ASSERT_TRUE (!store-&gt;init_error ());
253  	nano::keypair key1;
254  	nano::keypair key2;
255  	nano::block_builder builder;
256  	auto block1 = builder
257  				  .open ()
258  				  .source (0)
259  				  .representative (1)
260  				  .account (0)
261  				  .sign (nano::keypair ().prv, 0)
262  				  .work (0)
263  				  .build ();
264  	block1-&gt;sideband_set ({});
265  	auto transaction (store-&gt;tx_begin_write ());
266  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
267  	auto block = builder
268  				 .receive ()
269  				 .previous (block1-&gt;hash ())
270  				 .source (1)
271  				 .sign (nano::keypair ().prv, 2)
272  				 .work (3)
273  				 .build ();
274  	block-&gt;sideband_set ({});
275  	nano::block_hash hash1 (block-&gt;hash ());
276  	auto latest1 (store-&gt;block.get (transaction, hash1));
277  	ASSERT_EQ (nullptr, latest1);
278  	store-&gt;block.put (transaction, hash1, *block);
279  	auto latest2 (store-&gt;block.get (transaction, hash1));
280  	ASSERT_NE (nullptr, latest2);
281  	ASSERT_EQ (*block, *latest2);
282  }
283  TEST (block_store, add_pending)
284  {
285  	nano::logger_mt logger;
286  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
287  	ASSERT_TRUE (!store-&gt;init_error ());
288  	nano::keypair key1;
289  	nano::pending_key key2 (0, 0);
290  	nano::pending_info pending1;
291  	auto transaction (store-&gt;tx_begin_write ());
292  	ASSERT_TRUE (store-&gt;pending.get (transaction, key2, pending1));
293  	store-&gt;pending.put (transaction, key2, pending1);
294  	nano::pending_info pending2;
295  	ASSERT_FALSE (store-&gt;pending.get (transaction, key2, pending2));
296  	ASSERT_EQ (pending1, pending2);
297  	store-&gt;pending.del (transaction, key2);
298  	ASSERT_TRUE (store-&gt;pending.get (transaction, key2, pending2));
299  }
300  TEST (block_store, pending_iterator)
301  {
302  	nano::logger_mt logger;
303  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
304  	ASSERT_TRUE (!store-&gt;init_error ());
305  	auto transaction (store-&gt;tx_begin_write ());
306  	ASSERT_EQ (store-&gt;pending.end (), store-&gt;pending.begin (transaction));
307  	store-&gt;pending.put (transaction, nano::pending_key (1, 2), { 2, 3, nano::epoch::epoch_1 });
308  	auto current (store-&gt;pending.begin (transaction));
309  	ASSERT_NE (store-&gt;pending.end (), current);
310  	nano::pending_key key1 (current-&gt;first);
311  	ASSERT_EQ (nano::account (1), key1.account);
312  	ASSERT_EQ (nano::block_hash (2), key1.hash);
313  	nano::pending_info pending (current-&gt;second);
314  	ASSERT_EQ (nano::account (2), pending.source);
315  	ASSERT_EQ (nano::amount (3), pending.amount);
316  	ASSERT_EQ (nano::epoch::epoch_1, pending.epoch);
317  }
318  TEST (block_store, pending_iterator_comparison)
319  {
320  	nano::logger_mt logger;
321  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
322  	ASSERT_TRUE (!store-&gt;init_error ());
323  	nano::stats stats;
324  	auto transaction (store-&gt;tx_begin_write ());
325  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (1)), nano::pending_info (nano::account (10), nano::amount (1), nano::epoch::epoch_0));
326  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (3), nano::block_hash (4)), nano::pending_info (nano::account (10), nano::amount (0), nano::epoch::epoch_0));
327  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (2)), nano::pending_info (nano::account (10), nano::amount (2), nano::epoch::epoch_1));
328  	store-&gt;pending.put (transaction, nano::pending_key (nano::account (2), nano::block_hash (3)), nano::pending_info (nano::account (10), nano::amount (3), nano::epoch::epoch_1));
329  	{
330  		size_t count = 0;
331  		nano::account begin (3);
332  		nano::account end (begin.number () + 1);
333  		for (auto i (store-&gt;pending.begin (transaction, nano::pending_key (begin, 0))), n (store-&gt;pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
334  		{
335  			nano::pending_key key (i-&gt;first);
336  			ASSERT_EQ (key.account, begin);
337  			ASSERT_LT (count, 3);
338  		}
339  		ASSERT_EQ (count, 2);
340  	}
341  	{
342  		size_t count = 0;
343  		nano::account begin (2);
344  		nano::account end (begin.number () + 1);
345  		for (auto i (store-&gt;pending.begin (transaction, nano::pending_key (begin, 0))), n (store-&gt;pending.begin (transaction, nano::pending_key (end, 0))); i != n; ++i, ++count)
346  		{
347  			nano::pending_key key (i-&gt;first);
348  			ASSERT_EQ (key.account, begin);
349  			ASSERT_LT (count, 3);
350  		}
351  		ASSERT_EQ (count, 2);
352  	}
353  }
354  TEST (block_store, genesis)
355  {
356  	nano::logger_mt logger;
357  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
358  	ASSERT_TRUE (!store-&gt;init_error ());
359  	nano::ledger_cache ledger_cache;
360  	auto transaction (store-&gt;tx_begin_write ());
361  	store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
362  	nano::account_info info;
363  	ASSERT_FALSE (store-&gt;account.get (transaction, nano::dev::genesis-&gt;account (), info));
364  	ASSERT_EQ (nano::dev::genesis-&gt;hash (), info.head);
365  	auto block1 (store-&gt;block.get (transaction, info.head));
366  	ASSERT_NE (nullptr, block1);
367  	auto receive1 (dynamic_cast&lt;nano::open_block *&gt; (block1.get ()));
368  	ASSERT_NE (nullptr, receive1);
369  	ASSERT_LE (info.modified, nano::seconds_since_epoch ());
370  	ASSERT_EQ (info.block_count, 1);
371  	nano::confirmation_height_info confirmation_height_info;
372  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, nano::dev::genesis-&gt;account (), confirmation_height_info));
373  	ASSERT_EQ (confirmation_height_info.height, 1);
374  	ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
375  	auto dev_pub_text (nano::dev::genesis_key.pub.to_string ());
376  	auto dev_pub_account (nano::dev::genesis_key.pub.to_account ());
377  	auto dev_prv_text (nano::dev::genesis_key.prv.to_string ());
378  	ASSERT_EQ (nano::dev::genesis-&gt;account (), nano::dev::genesis_key.pub);
379  }
380  TEST (block_store, empty_accounts)
381  {
382  	nano::logger_mt logger;
383  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
384  	ASSERT_TRUE (!store-&gt;init_error ());
385  	auto transaction (store-&gt;tx_begin_read ());
386  	auto begin (store-&gt;account.begin (transaction));
387  	auto end (store-&gt;account.end ());
388  	ASSERT_EQ (end, begin);
389  }
390  TEST (block_store, one_block)
391  {
392  	nano::logger_mt logger;
393  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
394  	ASSERT_TRUE (!store-&gt;init_error ());
395  	nano::block_builder builder;
396  	auto block1 = builder
397  				  .open ()
398  				  .source (0)
399  				  .representative (1)
400  				  .account (0)
401  				  .sign (nano::keypair ().prv, 0)
402  				  .work (0)
403  				  .build ();
404  	block1-&gt;sideband_set ({});
405  	auto transaction (store-&gt;tx_begin_write ());
406  	store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
407  	ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
408  }
409  TEST (block_store, empty_bootstrap)
410  {
411  	nano::test::system system{};
412  	nano::logger_mt logger;
413  	nano::unchecked_map unchecked{ system.stats, false };
414  	size_t count = 0;
415  	unchecked.for_each ([&amp;count] (nano::unchecked_key const &amp; key, nano::unchecked_info const &amp; info) {
416  		++count;
417  	});
418  	ASSERT_EQ (count, 0);
419  }
420  TEST (block_store, unchecked_begin_search)
421  {
422  	nano::logger_mt logger;
423  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
424  	ASSERT_TRUE (!store-&gt;init_error ());
425  	nano::keypair key0;
426  	nano::block_builder builder;
427  	auto block1 = builder
428  				  .send ()
429  				  .previous (0)
430  				  .destination (1)
431  				  .balance (2)
432  				  .sign (key0.prv, key0.pub)
433  				  .work (3)
434  				  .build ();
435  	auto block2 = builder
436  				  .send ()
437  				  .previous (5)
438  				  .destination (6)
439  				  .balance (7)
440  				  .sign (key0.prv, key0.pub)
441  				  .work (8)
442  				  .build ();
443  }
444  TEST (block_store, frontier_retrieval)
445  {
446  	nano::logger_mt logger;
447  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
448  	ASSERT_TRUE (!store-&gt;init_error ());
449  	nano::account account1{};
450  	nano::account_info info1 (0, 0, 0, 0, 0, 0, nano::epoch::epoch_0);
451  	auto transaction (store-&gt;tx_begin_write ());
452  	store-&gt;confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
453  	store-&gt;account.put (transaction, account1, info1);
454  	nano::account_info info2;
455  	store-&gt;account.get (transaction, account1, info2);
456  	ASSERT_EQ (info1, info2);
457  }
458  TEST (block_store, one_account)
459  {
460  	nano::logger_mt logger;
461  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
462  	ASSERT_TRUE (!store-&gt;init_error ());
463  	nano::account account{};
464  	nano::block_hash hash (0);
465  	auto transaction (store-&gt;tx_begin_write ());
466  	store-&gt;confirmation_height.put (transaction, account, { 20, nano::block_hash (15) });
467  	store-&gt;account.put (transaction, account, { hash, account, hash, 42, 100, 200, nano::epoch::epoch_0 });
468  	auto begin (store-&gt;account.begin (transaction));
469  	auto end (store-&gt;account.end ());
470  	ASSERT_NE (end, begin);
471  	ASSERT_EQ (account, nano::account (begin-&gt;first));
472  	nano::account_info info (begin-&gt;second);
473  	ASSERT_EQ (hash, info.head);
474  	ASSERT_EQ (42, info.balance.number ());
475  	ASSERT_EQ (100, info.modified);
476  	ASSERT_EQ (200, info.block_count);
<span onclick='openModal()' class='match'>477  	nano::confirmation_height_info confirmation_height_info;
478  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account, confirmation_height_info));
479  	ASSERT_EQ (20, confirmation_height_info.height);
</span>480  	ASSERT_EQ (nano::block_hash (15), confirmation_height_info.frontier);
481  	++begin;
482  	ASSERT_EQ (end, begin);
483  }
484  TEST (block_store, two_block)
485  {
486  	nano::logger_mt logger;
487  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
488  	ASSERT_TRUE (!store-&gt;init_error ());
489  	nano::block_builder builder;
490  	auto block1 = builder
491  				  .open ()
492  				  .source (0)
493  				  .representative (1)
494  				  .account (1)
495  				  .sign (nano::keypair ().prv, 0)
496  				  .work (0)
497  				  .build ();
498  	block1-&gt;sideband_set ({});
499  	block1-&gt;hashables.account = 1;
500  	std::vector&lt;nano::block_hash&gt; hashes;
501  	std::vector&lt;nano::open_block&gt; blocks;
502  	hashes.push_back (block1-&gt;hash ());
503  	blocks.push_back (*block1);
504  	auto transaction (store-&gt;tx_begin_write ());
505  	store-&gt;block.put (transaction, hashes[0], *block1);
506  	auto block2 = builder
507  				  .open ()
508  				  .source (0)
509  				  .representative (1)
510  				  .account (2)
511  				  .sign (nano::keypair ().prv, 0)
512  				  .work (0)
513  				  .build ();
514  	block2-&gt;sideband_set ({});
515  	hashes.push_back (block2-&gt;hash ());
516  	blocks.push_back (*block2);
517  	store-&gt;block.put (transaction, hashes[1], *block2);
518  	ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
519  	ASSERT_TRUE (store-&gt;block.exists (transaction, block2-&gt;hash ()));
520  }
521  TEST (block_store, two_account)
522  {
523  	nano::logger_mt logger;
524  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
525  	ASSERT_TRUE (!store-&gt;init_error ());
526  	nano::account account1 (1);
527  	nano::block_hash hash1 (2);
528  	nano::account account2 (3);
529  	nano::block_hash hash2 (4);
530  	auto transaction (store-&gt;tx_begin_write ());
531  	store-&gt;confirmation_height.put (transaction, account1, { 20, nano::block_hash (10) });
532  	store-&gt;account.put (transaction, account1, { hash1, account1, hash1, 42, 100, 300, nano::epoch::epoch_0 });
533  	store-&gt;confirmation_height.put (transaction, account2, { 30, nano::block_hash (20) });
534  	store-&gt;account.put (transaction, account2, { hash2, account2, hash2, 84, 200, 400, nano::epoch::epoch_0 });
535  	auto begin (store-&gt;account.begin (transaction));
536  	auto end (store-&gt;account.end ());
537  	ASSERT_NE (end, begin);
538  	ASSERT_EQ (account1, nano::account (begin-&gt;first));
539  	nano::account_info info1 (begin-&gt;second);
540  	ASSERT_EQ (hash1, info1.head);
541  	ASSERT_EQ (42, info1.balance.number ());
542  	ASSERT_EQ (100, info1.modified);
543  	ASSERT_EQ (300, info1.block_count);
544  	nano::confirmation_height_info confirmation_height_info;
545  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
546  	ASSERT_EQ (20, confirmation_height_info.height);
547  	ASSERT_EQ (nano::block_hash (10), confirmation_height_info.frontier);
548  	++begin;
549  	ASSERT_NE (end, begin);
550  	ASSERT_EQ (account2, nano::account (begin-&gt;first));
551  	nano::account_info info2 (begin-&gt;second);
552  	ASSERT_EQ (hash2, info2.head);
553  	ASSERT_EQ (84, info2.balance.number ());
554  	ASSERT_EQ (200, info2.modified);
555  	ASSERT_EQ (400, info2.block_count);
556  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
557  	ASSERT_EQ (30, confirmation_height_info.height);
558  	ASSERT_EQ (nano::block_hash (20), confirmation_height_info.frontier);
559  	++begin;
560  	ASSERT_EQ (end, begin);
561  }
562  TEST (block_store, latest_find)
563  {
564  	nano::logger_mt logger;
565  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
566  	ASSERT_TRUE (!store-&gt;init_error ());
567  	nano::account account1 (1);
568  	nano::block_hash hash1 (2);
569  	nano::account account2 (3);
570  	nano::block_hash hash2 (4);
571  	auto transaction (store-&gt;tx_begin_write ());
572  	store-&gt;confirmation_height.put (transaction, account1, { 0, nano::block_hash (0) });
573  	store-&gt;account.put (transaction, account1, { hash1, account1, hash1, 100, 0, 300, nano::epoch::epoch_0 });
574  	store-&gt;confirmation_height.put (transaction, account2, { 0, nano::block_hash (0) });
575  	store-&gt;account.put (transaction, account2, { hash2, account2, hash2, 200, 0, 400, nano::epoch::epoch_0 });
576  	auto first (store-&gt;account.begin (transaction));
577  	auto second (store-&gt;account.begin (transaction));
578  	++second;
579  	auto find1 (store-&gt;account.begin (transaction, 1));
580  	ASSERT_EQ (first, find1);
581  	auto find2 (store-&gt;account.begin (transaction, 3));
582  	ASSERT_EQ (second, find2);
583  	auto find3 (store-&gt;account.begin (transaction, 2));
584  	ASSERT_EQ (second, find3);
585  }
586  namespace nano
587  {
588  namespace lmdb
589  {
590  	TEST (mdb_block_store, supported_version_upgrades)
591  	{
592  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
593  		{
594  			GTEST_SKIP ();
595  		}
596  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
597  		nano::logger_mt logger;
598  		{
599  			nano::lmdb::store store (logger, path, nano::dev::constants);
600  			nano::stats stats;
601  			nano::ledger ledger (store, stats, nano::dev::constants);
602  			auto transaction (store.tx_begin_write ());
603  			store.initialize (transaction, ledger.cache, nano::dev::constants);
604  			store.version.put (transaction, store.version_minimum - 1);
605  		}
606  		{
607  			nano::lmdb::store store (logger, path, nano::dev::constants);
608  			ASSERT_TRUE (store.init_error ());
609  		}
610  		auto path1 (nano::unique_path () / &quot;data.ldb&quot;);
611  		{
612  			nano::lmdb::store store (logger, path1, nano::dev::constants);
613  			nano::stats stats;
614  			nano::ledger ledger (store, stats, nano::dev::constants);
615  			auto transaction (store.tx_begin_write ());
616  			store.initialize (transaction, ledger.cache, nano::dev::constants);
617  			store.version.put (transaction, store.version_minimum);
618  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
619  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;accounts_v1&quot;, MDB_CREATE,
620  			&amp;store.account_store.accounts_v1_handle));
621  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
622  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis-&gt;account (), 1,
623  			nano::dev::genesis-&gt;hash ());
624  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
625  		}
626  		{
627  			nano::lmdb::store store (logger, path1, nano::dev::constants);
628  			ASSERT_FALSE (store.init_error ());
629  		}
630  	}
631  }
632  }
633  TEST (mdb_block_store, bad_path)
634  {
635  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
636  	{
637  		GTEST_SKIP ();
638  	}
639  	nano::logger_mt logger;
640  	nano::lmdb::store store (logger, boost::filesystem::path (&quot;&amp;bsol;&amp;bsol;/&quot;), nano::dev::constants);
641  	ASSERT_TRUE (store.init_error ());
642  }
643  TEST (block_store, DISABLED_already_open) 
644  {
645  	auto path (nano::unique_path ());
646  	boost::filesystem::create_directories (path.parent_path ());
647  	nano::set_secure_perm_directory (path.parent_path ());
648  	std::ofstream file;
649  	file.open (path.string ().c_str ());
650  	ASSERT_TRUE (file.is_open ());
651  	nano::logger_mt logger;
652  	auto store = nano::make_store (logger, path, nano::dev::constants);
653  	ASSERT_TRUE (store-&gt;init_error ());
654  }
655  TEST (block_store, roots)
656  {
657  	nano::logger_mt logger;
658  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
659  	ASSERT_TRUE (!store-&gt;init_error ());
660  	nano::block_builder builder;
661  	auto send_block = builder
662  					  .send ()
663  					  .previous (0)
664  					  .destination (1)
665  					  .balance (2)
666  					  .sign (nano::keypair ().prv, 4)
667  					  .work (5)
668  					  .build ();
669  	ASSERT_EQ (send_block-&gt;hashables.previous, send_block-&gt;root ().as_block_hash ());
670  	auto change_block = builder
671  						.change ()
672  						.previous (0)
673  						.representative (1)
674  						.sign (nano::keypair ().prv, 3)
675  						.work (4)
676  						.build ();
677  	ASSERT_EQ (change_block-&gt;hashables.previous, change_block-&gt;root ().as_block_hash ());
678  	auto receive_block = builder
679  						 .receive ()
680  						 .previous (0)
681  						 .source (1)
682  						 .sign (nano::keypair ().prv, 3)
683  						 .work (4)
684  						 .build ();
685  	ASSERT_EQ (receive_block-&gt;hashables.previous, receive_block-&gt;root ().as_block_hash ());
686  	auto open_block = builder
687  					  .open ()
688  					  .source (0)
689  					  .representative (1)
690  					  .account (2)
691  					  .sign (nano::keypair ().prv, 4)
692  					  .work (5)
693  					  .build ();
694  	ASSERT_EQ (open_block-&gt;hashables.account, open_block-&gt;root ().as_account ());
695  }
696  TEST (block_store, pending_exists)
697  {
698  	nano::logger_mt logger;
699  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
700  	ASSERT_TRUE (!store-&gt;init_error ());
701  	nano::pending_key two (2, 0);
702  	nano::pending_info pending;
703  	auto transaction (store-&gt;tx_begin_write ());
704  	store-&gt;pending.put (transaction, two, pending);
705  	nano::pending_key one (1, 0);
706  	ASSERT_FALSE (store-&gt;pending.exists (transaction, one));
707  }
708  TEST (block_store, latest_exists)
709  {
710  	nano::logger_mt logger;
711  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
712  	ASSERT_TRUE (!store-&gt;init_error ());
713  	nano::account two (2);
714  	nano::account_info info;
715  	auto transaction (store-&gt;tx_begin_write ());
716  	store-&gt;confirmation_height.put (transaction, two, { 0, nano::block_hash (0) });
717  	store-&gt;account.put (transaction, two, info);
718  	nano::account one (1);
719  	ASSERT_FALSE (store-&gt;account.exists (transaction, one));
720  }
721  TEST (block_store, large_iteration)
722  {
723  	nano::logger_mt logger;
724  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
725  	ASSERT_TRUE (!store-&gt;init_error ());
726  	std::unordered_set&lt;nano::account&gt; accounts1;
727  	for (auto i (0); i &lt; 1000; ++i)
728  	{
729  		auto transaction (store-&gt;tx_begin_write ());
730  		nano::account account;
731  		nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
732  		accounts1.insert (account);
733  		store-&gt;confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
734  		store-&gt;account.put (transaction, account, nano::account_info ());
735  	}
736  	std::unordered_set&lt;nano::account&gt; accounts2;
737  	nano::account previous{};
738  	auto transaction (store-&gt;tx_begin_read ());
739  	for (auto i (store-&gt;account.begin (transaction, 0)), n (store-&gt;account.end ()); i != n; ++i)
740  	{
741  		nano::account current (i-&gt;first);
742  		ASSERT_GT (current.number (), previous.number ());
743  		accounts2.insert (current);
744  		previous = current;
745  	}
746  	ASSERT_EQ (accounts1, accounts2);
747  	std::unordered_set&lt;nano::account&gt; accounts3;
748  	previous = std::numeric_limits&lt;nano::uint256_t&gt;::max ();
749  	for (auto i (store-&gt;account.rbegin (transaction)), n (store-&gt;account.end ()); i != n; --i)
750  	{
751  		nano::account current (i-&gt;first);
752  		ASSERT_LT (current.number (), previous.number ());
753  		accounts3.insert (current);
754  		previous = current;
755  	}
756  	ASSERT_EQ (accounts1, accounts3);
757  }
758  TEST (block_store, frontier)
759  {
760  	nano::logger_mt logger;
761  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
762  	ASSERT_TRUE (!store-&gt;init_error ());
763  	auto transaction (store-&gt;tx_begin_write ());
764  	nano::block_hash hash (100);
765  	nano::account account (200);
766  	ASSERT_TRUE (store-&gt;frontier.get (transaction, hash).is_zero ());
767  	store-&gt;frontier.put (transaction, hash, account);
768  	ASSERT_EQ (account, store-&gt;frontier.get (transaction, hash));
769  	store-&gt;frontier.del (transaction, hash);
770  	ASSERT_TRUE (store-&gt;frontier.get (transaction, hash).is_zero ());
771  }
772  TEST (block_store, block_replace)
773  {
774  	nano::logger_mt logger;
775  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
776  	ASSERT_TRUE (!store-&gt;init_error ());
777  	nano::block_builder builder;
778  	auto send1 = builder
779  				 .send ()
780  				 .previous (0)
781  				 .destination (0)
782  				 .balance (0)
783  				 .sign (nano::keypair ().prv, 0)
784  				 .work (1)
785  				 .build ();
786  	send1-&gt;sideband_set ({});
787  	auto send2 = builder
788  				 .send ()
789  				 .previous (0)
790  				 .destination (0)
791  				 .balance (0)
792  				 .sign (nano::keypair ().prv, 0)
793  				 .work (2)
794  				 .build ();
795  	send2-&gt;sideband_set ({});
796  	auto transaction (store-&gt;tx_begin_write ());
797  	store-&gt;block.put (transaction, 0, *send1);
798  	store-&gt;block.put (transaction, 0, *send2);
799  	auto block3 (store-&gt;block.get (transaction, 0));
800  	ASSERT_NE (nullptr, block3);
801  	ASSERT_EQ (2, block3-&gt;block_work ());
802  }
803  TEST (block_store, block_count)
804  {
805  	nano::logger_mt logger;
806  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
807  	ASSERT_TRUE (!store-&gt;init_error ());
808  	{
809  		auto transaction (store-&gt;tx_begin_write ());
810  		ASSERT_EQ (0, store-&gt;block.count (transaction));
811  		nano::block_builder builder;
812  		auto block = builder
813  					 .open ()
814  					 .source (0)
815  					 .representative (1)
816  					 .account (0)
817  					 .sign (nano::keypair ().prv, 0)
818  					 .work (0)
819  					 .build ();
820  		block-&gt;sideband_set ({});
821  		auto hash1 (block-&gt;hash ());
822  		store-&gt;block.put (transaction, hash1, *block);
823  	}
824  	auto transaction (store-&gt;tx_begin_read ());
825  	ASSERT_EQ (1, store-&gt;block.count (transaction));
826  }
827  TEST (block_store, account_count)
828  {
829  	nano::logger_mt logger;
830  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
831  	ASSERT_TRUE (!store-&gt;init_error ());
832  	{
833  		auto transaction (store-&gt;tx_begin_write ());
834  		ASSERT_EQ (0, store-&gt;account.count (transaction));
835  		nano::account account (200);
836  		store-&gt;confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
837  		store-&gt;account.put (transaction, account, nano::account_info ());
838  	}
839  	auto transaction (store-&gt;tx_begin_read ());
840  	ASSERT_EQ (1, store-&gt;account.count (transaction));
841  }
842  TEST (block_store, cemented_count_cache)
843  {
844  	nano::logger_mt logger;
845  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
846  	ASSERT_TRUE (!store-&gt;init_error ());
847  	auto transaction (store-&gt;tx_begin_write ());
848  	nano::ledger_cache ledger_cache;
849  	store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
850  	ASSERT_EQ (1, ledger_cache.cemented_count);
851  }
852  TEST (block_store, block_random)
853  {
854  	nano::logger_mt logger;
855  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
856  	{
857  		nano::ledger_cache ledger_cache;
858  		auto transaction (store-&gt;tx_begin_write ());
859  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
860  	}
861  	auto transaction (store-&gt;tx_begin_read ());
862  	auto block (store-&gt;block.random (transaction));
863  	ASSERT_NE (nullptr, block);
864  	ASSERT_EQ (*block, *nano::dev::genesis);
865  }
866  TEST (block_store, pruned_random)
867  {
868  	nano::logger_mt logger;
869  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
870  	ASSERT_TRUE (!store-&gt;init_error ());
871  	nano::block_builder builder;
872  	auto block = builder
873  				 .open ()
874  				 .source (0)
875  				 .representative (1)
876  				 .account (0)
877  				 .sign (nano::keypair ().prv, 0)
878  				 .work (0)
879  				 .build ();
880  	block-&gt;sideband_set ({});
881  	auto hash1 (block-&gt;hash ());
882  	{
883  		nano::ledger_cache ledger_cache;
884  		auto transaction (store-&gt;tx_begin_write ());
885  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
886  		store-&gt;pruned.put (transaction, hash1);
887  	}
888  	auto transaction (store-&gt;tx_begin_read ());
889  	auto random_hash (store-&gt;pruned.random (transaction));
890  	ASSERT_EQ (hash1, random_hash);
891  }
892  TEST (block_store, state_block)
893  {
894  	nano::logger_mt logger;
895  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
896  	ASSERT_FALSE (store-&gt;init_error ());
897  	nano::keypair key1;
898  	nano::block_builder builder;
899  	auto block1 = builder
900  				  .state ()
901  				  .account (1)
902  				  .previous (nano::dev::genesis-&gt;hash ())
903  				  .representative (3)
904  				  .balance (4)
905  				  .link (6)
906  				  .sign (key1.prv, key1.pub)
907  				  .work (7)
908  				  .build ();
909  	block1-&gt;sideband_set ({});
910  	{
911  		nano::ledger_cache ledger_cache;
912  		auto transaction (store-&gt;tx_begin_write ());
913  		store-&gt;initialize (transaction, ledger_cache, nano::dev::constants);
914  		ASSERT_EQ (nano::block_type::state, block1-&gt;type ());
915  		store-&gt;block.put (transaction, block1-&gt;hash (), *block1);
916  		ASSERT_TRUE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
917  		auto block2 (store-&gt;block.get (transaction, block1-&gt;hash ()));
918  		ASSERT_NE (nullptr, block2);
919  		ASSERT_EQ (*block1, *block2);
920  	}
921  	{
922  		auto transaction (store-&gt;tx_begin_write ());
923  		auto count (store-&gt;block.count (transaction));
924  		ASSERT_EQ (2, count);
925  		store-&gt;block.del (transaction, block1-&gt;hash ());
926  		ASSERT_FALSE (store-&gt;block.exists (transaction, block1-&gt;hash ()));
927  	}
928  	auto transaction (store-&gt;tx_begin_read ());
929  	auto count2 (store-&gt;block.count (transaction));
930  	ASSERT_EQ (1, count2);
931  }
932  TEST (mdb_block_store, sideband_height)
933  {
934  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
935  	{
936  		GTEST_SKIP ();
937  	}
938  	nano::logger_mt logger;
939  	nano::keypair key1;
940  	nano::keypair key2;
941  	nano::keypair key3;
942  	nano::lmdb::store store (logger, nano::unique_path () / &quot;data.ldb&quot;, nano::dev::constants);
943  	ASSERT_FALSE (store.init_error ());
944  	nano::stats stats;
945  	nano::ledger ledger (store, stats, nano::dev::constants);
946  	nano::block_builder builder;
947  	auto transaction (store.tx_begin_write ());
948  	store.initialize (transaction, ledger.cache, nano::dev::constants);
949  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
950  	auto send = builder
951  				.send ()
952  				.previous (nano::dev::genesis-&gt;hash ())
953  				.destination (nano::dev::genesis_key.pub)
954  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
955  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
956  				.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
957  				.build ();
958  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
959  	auto receive = builder
960  				   .receive ()
961  				   .previous (send-&gt;hash ())
962  				   .source (send-&gt;hash ())
963  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
964  				   .work (*pool.generate (send-&gt;hash ()))
965  				   .build ();
966  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
967  	auto change = builder
968  				  .change ()
969  				  .previous (receive-&gt;hash ())
970  				  .representative (0)
971  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
972  				  .work (*pool.generate (receive-&gt;hash ()))
973  				  .build ();
974  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
975  	auto state_send1 = builder
976  					   .state ()
977  					   .account (nano::dev::genesis_key.pub)
978  					   .previous (change-&gt;hash ())
979  					   .representative (0)
980  					   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
981  					   .link (key1.pub)
982  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
983  					   .work (*pool.generate (change-&gt;hash ()))
984  					   .build ();
985  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send1).code);
986  	auto state_send2 = builder
987  					   .state ()
988  					   .account (nano::dev::genesis_key.pub)
989  					   .previous (state_send1-&gt;hash ())
990  					   .representative (0)
991  					   .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
992  					   .link (key2.pub)
993  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
994  					   .work (*pool.generate (state_send1-&gt;hash ()))
995  					   .build ();
996  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
997  	auto state_send3 = builder
998  					   .state ()
999  					   .account (nano::dev::genesis_key.pub)
1000  					   .previous (state_send2-&gt;hash ())
1001  					   .representative (0)
1002  					   .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1003  					   .link (key3.pub)
1004  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1005  					   .work (*pool.generate (state_send2-&gt;hash ()))
1006  					   .build ();
1007  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send3).code);
1008  	auto state_open = builder
1009  					  .state ()
1010  					  .account (key1.pub)
1011  					  .previous (0)
1012  					  .representative (0)
1013  					  .balance (nano::Gxrb_ratio)
1014  					  .link (state_send1-&gt;hash ())
1015  					  .sign (key1.prv, key1.pub)
1016  					  .work (*pool.generate (key1.pub))
1017  					  .build ();
1018  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1019  	auto epoch = builder
1020  				 .state ()
1021  				 .account (key1.pub)
1022  				 .previous (state_open-&gt;hash ())
1023  				 .representative (0)
1024  				 .balance (nano::Gxrb_ratio)
1025  				 .link (ledger.epoch_link (nano::epoch::epoch_1))
1026  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				 .work (*pool.generate (state_open-&gt;hash ()))
1028  				 .build ();
1029  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1030  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch-&gt;hash ()));
1031  	auto epoch_open = builder
1032  					  .state ()
1033  					  .account (key2.pub)
1034  					  .previous (0)
1035  					  .representative (0)
1036  					  .balance (0)
1037  					  .link (ledger.epoch_link (nano::epoch::epoch_1))
1038  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1039  					  .work (*pool.generate (key2.pub))
1040  					  .build ();
1041  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_open).code);
1042  	ASSERT_EQ (nano::epoch::epoch_1, store.block.version (transaction, epoch_open-&gt;hash ()));
1043  	auto state_receive = builder
1044  						 .state ()
1045  						 .account (key2.pub)
1046  						 .previous (epoch_open-&gt;hash ())
1047  						 .representative (0)
1048  						 .balance (nano::Gxrb_ratio)
1049  						 .link (state_send2-&gt;hash ())
1050  						 .sign (key2.prv, key2.pub)
1051  						 .work (*pool.generate (epoch_open-&gt;hash ()))
1052  						 .build ();
1053  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1054  	auto open = builder
1055  				.open ()
1056  				.source (state_send3-&gt;hash ())
1057  				.representative (nano::dev::genesis_key.pub)
1058  				.account (key3.pub)
1059  				.sign (key3.prv, key3.pub)
1060  				.work (*pool.generate (key3.pub))
1061  				.build ();
1062  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1063  	auto block1 (store.block.get (transaction, nano::dev::genesis-&gt;hash ()));
1064  	ASSERT_EQ (block1-&gt;sideband ().height, 1);
1065  	auto block2 (store.block.get (transaction, send-&gt;hash ()));
1066  	ASSERT_EQ (block2-&gt;sideband ().height, 2);
1067  	auto block3 (store.block.get (transaction, receive-&gt;hash ()));
1068  	ASSERT_EQ (block3-&gt;sideband ().height, 3);
1069  	auto block4 (store.block.get (transaction, change-&gt;hash ()));
1070  	ASSERT_EQ (block4-&gt;sideband ().height, 4);
1071  	auto block5 (store.block.get (transaction, state_send1-&gt;hash ()));
1072  	ASSERT_EQ (block5-&gt;sideband ().height, 5);
1073  	auto block6 (store.block.get (transaction, state_send2-&gt;hash ()));
1074  	ASSERT_EQ (block6-&gt;sideband ().height, 6);
1075  	auto block7 (store.block.get (transaction, state_send3-&gt;hash ()));
1076  	ASSERT_EQ (block7-&gt;sideband ().height, 7);
1077  	auto block8 (store.block.get (transaction, state_open-&gt;hash ()));
1078  	ASSERT_EQ (block8-&gt;sideband ().height, 1);
1079  	auto block9 (store.block.get (transaction, epoch-&gt;hash ()));
1080  	ASSERT_EQ (block9-&gt;sideband ().height, 2);
1081  	auto block10 (store.block.get (transaction, epoch_open-&gt;hash ()));
1082  	ASSERT_EQ (block10-&gt;sideband ().height, 1);
1083  	auto block11 (store.block.get (transaction, state_receive-&gt;hash ()));
1084  	ASSERT_EQ (block11-&gt;sideband ().height, 2);
1085  	auto block12 (store.block.get (transaction, open-&gt;hash ()));
1086  	ASSERT_EQ (block12-&gt;sideband ().height, 1);
1087  }
1088  TEST (block_store, peers)
1089  {
1090  	nano::logger_mt logger;
1091  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1092  	ASSERT_TRUE (!store-&gt;init_error ());
1093  	nano::endpoint_key endpoint (boost::asio::ip::address_v6::any ().to_bytes (), 100);
1094  	{
1095  		auto transaction (store-&gt;tx_begin_write ());
1096  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint));
1097  		ASSERT_EQ (store-&gt;peer.count (transaction), 0);
1098  		store-&gt;peer.put (transaction, endpoint);
1099  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint));
1100  	}
1101  	{
1102  		auto transaction (store-&gt;tx_begin_read ());
1103  		ASSERT_EQ (store-&gt;peer.count (transaction), 1);
1104  	}
1105  	nano::endpoint_key endpoint1 (boost::asio::ip::address_v6::any ().to_bytes (), 101);
1106  	{
1107  		auto transaction (store-&gt;tx_begin_write ());
1108  		store-&gt;peer.put (transaction, endpoint1);
1109  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint1)); 
1110  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint)); 
1111  	}
1112  	{
1113  		auto transaction (store-&gt;tx_begin_read ());
1114  		ASSERT_EQ (store-&gt;peer.count (transaction), 2);
1115  	}
1116  	{
1117  		auto transaction (store-&gt;tx_begin_write ());
1118  		store-&gt;peer.del (transaction, endpoint1);
1119  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint1)); 
1120  		ASSERT_TRUE (store-&gt;peer.exists (transaction, endpoint)); 
1121  	}
1122  	{
1123  		auto transaction (store-&gt;tx_begin_read ());
1124  		ASSERT_EQ (store-&gt;peer.count (transaction), 1);
1125  	}
1126  	{
1127  		auto transaction (store-&gt;tx_begin_write ());
1128  		store-&gt;peer.del (transaction, endpoint);
1129  		ASSERT_FALSE (store-&gt;peer.exists (transaction, endpoint));
1130  	}
1131  	{
1132  		auto transaction (store-&gt;tx_begin_read ());
1133  		ASSERT_EQ (store-&gt;peer.count (transaction), 0);
1134  	}
1135  }
1136  TEST (block_store, endpoint_key_byte_order)
1137  {
1138  	boost::asio::ip::address_v6 address (boost::asio::ip::make_address_v6 (&quot;::ffff:127.0.0.1&quot;));
1139  	uint16_t port = 100;
1140  	nano::endpoint_key endpoint_key (address.to_bytes (), port);
1141  	std::vector&lt;uint8_t&gt; bytes;
1142  	{
1143  		nano::vectorstream stream (bytes);
1144  		nano::write (stream, endpoint_key);
1145  	}
1146  	ASSERT_EQ (bytes.size (), 18);
1147  	ASSERT_EQ (bytes[10], 0xff);
1148  	ASSERT_EQ (bytes[11], 0xff);
1149  	ASSERT_EQ (bytes[12], 127);
1150  	ASSERT_EQ (bytes[bytes.size () - 2], 0);
1151  	ASSERT_EQ (bytes.back (), 100);
1152  	nano::bufferstream stream1 (bytes.data (), bytes.size ());
1153  	nano::endpoint_key endpoint_key1;
1154  	nano::read (stream1, endpoint_key1);
1155  	ASSERT_EQ (address.to_bytes (), endpoint_key1.address_bytes ());
1156  	ASSERT_EQ (port, endpoint_key1.port ());
1157  }
1158  TEST (block_store, online_weight)
1159  {
1160  	nano::logger_mt logger;
1161  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1162  	ASSERT_FALSE (store-&gt;init_error ());
1163  	{
1164  		auto transaction (store-&gt;tx_begin_write ());
1165  		ASSERT_EQ (0, store-&gt;online_weight.count (transaction));
1166  		ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.begin (transaction));
1167  		ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.rbegin (transaction));
1168  		store-&gt;online_weight.put (transaction, 1, 2);
1169  		store-&gt;online_weight.put (transaction, 3, 4);
1170  	}
1171  	{
1172  		auto transaction (store-&gt;tx_begin_write ());
1173  		ASSERT_EQ (2, store-&gt;online_weight.count (transaction));
1174  		auto item (store-&gt;online_weight.begin (transaction));
1175  		ASSERT_NE (store-&gt;online_weight.end (), item);
1176  		ASSERT_EQ (1, item-&gt;first);
1177  		ASSERT_EQ (2, item-&gt;second.number ());
1178  		auto item_last (store-&gt;online_weight.rbegin (transaction));
1179  		ASSERT_NE (store-&gt;online_weight.end (), item_last);
1180  		ASSERT_EQ (3, item_last-&gt;first);
1181  		ASSERT_EQ (4, item_last-&gt;second.number ());
1182  		store-&gt;online_weight.del (transaction, 1);
1183  		ASSERT_EQ (1, store-&gt;online_weight.count (transaction));
1184  		ASSERT_EQ (store-&gt;online_weight.begin (transaction), store-&gt;online_weight.rbegin (transaction));
1185  		store-&gt;online_weight.del (transaction, 3);
1186  	}
1187  	auto transaction (store-&gt;tx_begin_read ());
1188  	ASSERT_EQ (0, store-&gt;online_weight.count (transaction));
1189  	ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.begin (transaction));
1190  	ASSERT_EQ (store-&gt;online_weight.end (), store-&gt;online_weight.rbegin (transaction));
1191  }
1192  TEST (block_store, pruned_blocks)
1193  {
1194  	nano::logger_mt logger;
1195  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
1196  	ASSERT_TRUE (!store-&gt;init_error ());
1197  	nano::keypair key1;
1198  	nano::block_builder builder;
1199  	auto block1 = builder
1200  				  .open ()
1201  				  .source (0)
1202  				  .representative (1)
1203  				  .account (key1.pub)
1204  				  .sign (key1.prv, key1.pub)
1205  				  .work (0)
1206  				  .build ();
1207  	auto hash1 (block1-&gt;hash ());
1208  	{
1209  		auto transaction (store-&gt;tx_begin_write ());
1210  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash1));
1211  		ASSERT_EQ (store-&gt;pruned.count (transaction), 0);
1212  		store-&gt;pruned.put (transaction, hash1);
1213  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1));
1214  	}
1215  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 1);
1216  	auto block2 = builder
1217  				  .open ()
1218  				  .source (1)
1219  				  .representative (2)
1220  				  .account (key1.pub)
1221  				  .sign (key1.prv, key1.pub)
1222  				  .work (0)
1223  				  .build ();
1224  	block2-&gt;sideband_set ({});
1225  	auto hash2 (block2-&gt;hash ());
1226  	{
1227  		auto transaction (store-&gt;tx_begin_write ());
1228  		store-&gt;pruned.put (transaction, hash2);
1229  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash2)); 
1230  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash2));
1231  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1)); 
1232  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
1233  	}
1234  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 2);
1235  	{
1236  		auto transaction (store-&gt;tx_begin_write ());
1237  		store-&gt;pruned.del (transaction, hash2);
1238  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash2)); 
1239  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash2)); 
1240  		store-&gt;block.put (transaction, hash2, *block2); 
1241  		ASSERT_TRUE (store-&gt;block.exists (transaction, hash2));
1242  		ASSERT_TRUE (store-&gt;pruned.exists (transaction, hash1)); 
1243  		ASSERT_FALSE (store-&gt;block.exists (transaction, hash1));
1244  	}
1245  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 1);
1246  	{
1247  		auto transaction (store-&gt;tx_begin_write ());
1248  		store-&gt;pruned.del (transaction, hash1);
1249  		ASSERT_FALSE (store-&gt;pruned.exists (transaction, hash1));
1250  	}
1251  	ASSERT_EQ (store-&gt;pruned.count (store-&gt;tx_begin_read ()), 0);
1252  }
1253  namespace nano
1254  {
1255  namespace lmdb
1256  {
1257  	TEST (mdb_block_store, upgrade_v14_v15)
1258  	{
1259  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1260  		{
1261  			GTEST_SKIP ();
1262  		}
1263  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1264  		nano::block_builder builder;
1265  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1266  		auto send = builder
1267  					.send ()
1268  					.previous (nano::dev::genesis-&gt;hash ())
1269  					.destination (nano::dev::genesis_key.pub)
1270  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1271  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  					.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1273  					.build ();
1274  		auto epoch = builder
1275  					 .state ()
1276  					 .account (nano::dev::genesis_key.pub)
1277  					 .previous (send-&gt;hash ())
1278  					 .representative (nano::dev::genesis_key.pub)
1279  					 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1280  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1281  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1282  					 .work (*pool.generate (send-&gt;hash ()))
1283  					 .build ();
1284  		auto state_send = builder
1285  						  .state ()
1286  						  .account (nano::dev::genesis_key.pub)
1287  						  .previous (epoch-&gt;hash ())
1288  						  .representative (nano::dev::genesis_key.pub)
1289  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1290  						  .link (nano::dev::genesis_key.pub)
1291  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1292  						  .work (*pool.generate (epoch-&gt;hash ()))
1293  						  .build ();
1294  		{
1295  			nano::logger_mt logger;
1296  			nano::lmdb::store store (logger, path, nano::dev::constants);
1297  			nano::stats stats;
1298  			nano::ledger ledger (store, stats, nano::dev::constants);
1299  			auto transaction (store.tx_begin_write ());
1300  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1301  			auto account_info = ledger.account_info (transaction, nano::dev::genesis-&gt;account ());
1302  			ASSERT_TRUE (account_info);
1303  			nano::confirmation_height_info confirmation_height_info;
1304  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (),
1305  			confirmation_height_info));
1306  			ASSERT_EQ (confirmation_height_info.height, 1);
1307  			ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
1308  			ASSERT_FALSE (
1309  			mdb_dbi_open (store.env.tx (transaction), &quot;state_v1&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_v1_handle));
1310  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;accounts_v1&quot;, MDB_CREATE,
1311  			&amp;store.account_store.accounts_v1_handle));
1312  			ASSERT_FALSE (
1313  			mdb_dbi_open (store.env.tx (transaction), &quot;pending_v1&quot;, MDB_CREATE, &amp;store.pending_store.pending_v1_handle));
1314  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1315  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1316  			ASSERT_FALSE (
1317  			mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE,
1318  			&amp;store.block_store.state_blocks_handle));
1319  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1320  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1321  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1322  			store.version.put (transaction, 14);
1323  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
1324  			modify_account_info_to_v14 (store, transaction, nano::dev::genesis-&gt;account (),
1325  			confirmation_height_info.height, state_send-&gt;hash ());
1326  			store.pending.del (transaction, nano::pending_key (nano::dev::genesis-&gt;account (), state_send-&gt;hash ()));
1327  			write_sideband_v14 (store, transaction, *state_send, store.block_store.state_blocks_v1_handle);
1328  			write_sideband_v14 (store, transaction, *epoch, store.block_store.state_blocks_v1_handle);
1329  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1330  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1331  			store.block.del (transaction, state_send-&gt;hash ());
1332  			store.block.del (transaction, epoch-&gt;hash ());
1333  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v0_handle,
1334  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, send-&gt;hash ())),
1335  			nano::mdb_val (
1336  			nano::pending_info_v14 (nano::dev::genesis-&gt;account (), nano::Gxrb_ratio,
1337  			nano::epoch::epoch_0)),
1338  			0));
1339  			ASSERT_FALSE (mdb_put (store.env.tx (transaction), store.pending_store.pending_v1_handle,
1340  			nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ())),
1341  			nano::mdb_val (
1342  			nano::pending_info_v14 (nano::dev::genesis-&gt;account (), nano::Gxrb_ratio,
1343  			nano::epoch::epoch_1)),
1344  			0));
1345  			nano::mdb_val value;
1346  			ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1347  			nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1348  			nano::account_info info;
1349  			ASSERT_NE (value.size (), info.db_size ());
1350  			store.account.del (transaction, nano::dev::genesis-&gt;account ());
1351  			ASSERT_TRUE (mdb_get (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle,
1352  			nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1353  		}
1354  		nano::logger_mt logger;
1355  		nano::lmdb::store store (logger, path, nano::dev::constants);
1356  		ASSERT_FALSE (store.init_error ());
1357  		auto transaction (store.tx_begin_read ());
1358  		nano::mdb_val value;
1359  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.account_store.accounts_handle,
1360  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1361  		nano::account_info info (value);
1362  		ASSERT_EQ (value.size (), info.db_size ());
1363  		nano::confirmation_height_info confirmation_height_info;
1364  		ASSERT_FALSE (
1365  		store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (),
1366  		confirmation_height_info));
1367  		ASSERT_EQ (confirmation_height_info.height, 1);
1368  		ASSERT_EQ (confirmation_height_info.frontier, nano::dev::genesis-&gt;hash ());
1369  		auto error_get_accounts_v1 (mdb_get (store.env.tx (transaction), store.account_store.accounts_v1_handle,
1370  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1371  		ASSERT_NE (error_get_accounts_v1, MDB_SUCCESS);
1372  		auto error_get_pending_v1 (mdb_get (store.env.tx (transaction), store.pending_store.pending_v1_handle, nano::mdb_val (nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ())), value));
1373  		ASSERT_NE (error_get_pending_v1, MDB_SUCCESS);
1374  		auto error_get_state_v1 (
1375  		mdb_get (store.env.tx (transaction), store.block_store.state_blocks_v1_handle, nano::mdb_val (state_send-&gt;hash ()),
1376  		value));
1377  		ASSERT_NE (error_get_state_v1, MDB_SUCCESS);
1378  		auto block = store.block.get (transaction, state_send-&gt;hash ());
1379  		ASSERT_NE (block, nullptr);
1380  		ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1381  		block = store.block.get (transaction, send-&gt;hash ());
1382  		ASSERT_NE (block, nullptr);
1383  		ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1384  		ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1385  		nano::pending_info pending_info;
1386  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, send-&gt;hash ()), pending_info);
1387  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_0);
1388  		store.pending.get (transaction, nano::pending_key (nano::dev::genesis_key.pub, state_send-&gt;hash ()),
1389  		pending_info);
1390  		ASSERT_EQ (pending_info.epoch, nano::epoch::epoch_1);
1391  		ASSERT_LT (14, store.version.get (transaction));
1392  	}
1393  	TEST (mdb_block_store, upgrade_v15_v16)
1394  	{
1395  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1396  		{
1397  			GTEST_SKIP ();
1398  		}
1399  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1400  		nano::mdb_val value;
1401  		{
1402  			nano::logger_mt logger;
1403  			nano::lmdb::store store (logger, path, nano::dev::constants);
1404  			nano::stats stats;
1405  			nano::ledger ledger (store, stats, nano::dev::constants);
1406  			auto transaction (store.tx_begin_write ());
1407  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1408  			auto txn = store.env.tx (transaction);
1409  			ASSERT_FALSE (
1410  			mdb_dbi_open (txn, &quot;representation&quot;, MDB_CREATE, &amp;store.account_store.representation_handle));
1411  			auto weight = ledger.cache.rep_weights.representation_get (nano::dev::genesis-&gt;account ());
1412  			ASSERT_EQ (MDB_SUCCESS, mdb_put (txn, store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis-&gt;account ()), nano::mdb_val (nano::uint128_union (weight)), 0));
1413  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1414  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1415  			store.version.put (transaction, 15);
1416  			ASSERT_EQ (MDB_SUCCESS, mdb_get (store.env.tx (transaction), store.account_store.representation_handle, nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1417  			store.confirmation_height.del (transaction, nano::dev::genesis-&gt;account ());
1418  		}
1419  		nano::logger_mt logger;
1420  		nano::lmdb::store store (logger, path, nano::dev::constants);
1421  		ASSERT_FALSE (store.init_error ());
1422  		auto transaction (store.tx_begin_read ());
1423  		auto error_get_representation (mdb_get (store.env.tx (transaction), store.account_store.representation_handle,
1424  		nano::mdb_val (nano::dev::genesis-&gt;account ()), value));
1425  		ASSERT_NE (MDB_SUCCESS, error_get_representation);
1426  		ASSERT_EQ (store.account_store.representation_handle, 0);
1427  		ASSERT_LT (15, store.version.get (transaction));
1428  	}
1429  	TEST (mdb_block_store, upgrade_v16_v17)
1430  	{
1431  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1432  		{
1433  			GTEST_SKIP ();
1434  		}
1435  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1436  		nano::block_builder builder;
1437  		auto block1 = builder
1438  					  .state ()
1439  					  .account (nano::dev::genesis_key.pub)
1440  					  .previous (nano::dev::genesis-&gt;hash ())
1441  					  .representative (nano::dev::genesis_key.pub)
1442  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1443  					  .link (nano::dev::genesis_key.pub)
1444  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1445  					  .work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1446  					  .build ();
1447  		auto block2 = builder
1448  					  .state ()
1449  					  .account (nano::dev::genesis_key.pub)
1450  					  .previous (block1-&gt;hash ())
1451  					  .representative (nano::dev::genesis_key.pub)
1452  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
1453  					  .link (nano::dev::genesis_key.pub)
1454  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1455  					  .work (*pool.generate (block1-&gt;hash ()))
1456  					  .build ();
1457  		auto block3 = builder
1458  					  .state ()
1459  					  .account (nano::dev::genesis_key.pub)
1460  					  .previous (block2-&gt;hash ())
1461  					  .representative (nano::dev::genesis_key.pub)
1462  					  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 2)
1463  					  .link (nano::dev::genesis_key.pub)
1464  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1465  					  .work (*pool.generate (block2-&gt;hash ()))
1466  					  .build ();
1467  		auto code = [&amp;block1, &amp;block2, &amp;block3] (auto confirmation_height, nano::block_hash const &amp; expected_cemented_frontier) {
1468  			auto path (nano::unique_path () / &quot;data.ldb&quot;);
1469  			nano::mdb_val value;
1470  			{
1471  				nano::logger_mt logger;
1472  				nano::lmdb::store store (logger, path, nano::dev::constants);
1473  				nano::stats stats;
1474  				nano::ledger ledger (store, stats, nano::dev::constants);
1475  				auto transaction (store.tx_begin_write ());
1476  				store.initialize (transaction, ledger.cache, nano::dev::constants);
1477  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block1).code);
1478  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block2).code);
1479  				ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *block3).code);
1480  				modify_confirmation_height_to_v15 (store, transaction, nano::dev::genesis-&gt;account (), confirmation_height);
1481  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1482  				write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1483  				ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1484  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block1);
1485  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block2);
1486  				write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *block3);
1487  				store.version.put (transaction, 16);
1488  			}
1489  			nano::logger_mt logger;
1490  			nano::lmdb::store store (logger, path, nano::dev::constants);
1491  			ASSERT_FALSE (store.init_error ());
1492  			auto transaction (store.tx_begin_read ());
1493  			nano::confirmation_height_info confirmation_height_info;
1494  			ASSERT_FALSE (store.confirmation_height.get (transaction, nano::dev::genesis-&gt;account (), confirmation_height_info));
1495  			ASSERT_EQ (confirmation_height_info.height, confirmation_height);
1496  			ASSERT_EQ (confirmation_height_info.frontier, expected_cemented_frontier);
1497  			ASSERT_LT (16, store.version.get (transaction));
1498  		};
1499  		code (0, nano::block_hash (0));
1500  		code (1, nano::dev::genesis-&gt;hash ());
1501  		code (2, block1-&gt;hash ());
1502  		code (3, block2-&gt;hash ());
1503  		code (4, block3-&gt;hash ());
1504  	}
1505  	TEST (mdb_block_store, upgrade_v17_v18)
1506  	{
1507  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1508  		{
1509  			GTEST_SKIP ();
1510  		}
1511  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1512  		nano::block_builder builder;
1513  		nano::keypair key1;
1514  		nano::keypair key2;
1515  		nano::keypair key3;
1516  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1517  		auto send_zero = builder
1518  						 .send ()
1519  						 .previous (nano::dev::genesis-&gt;hash ())
1520  						 .destination (nano::dev::genesis_key.pub)
1521  						 .balance (nano::dev::constants.genesis_amount)
1522  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1523  						 .work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1524  						 .build ();
1525  		auto state_receive_zero = builder
1526  								  .state ()
1527  								  .account (nano::dev::genesis_key.pub)
1528  								  .previous (send_zero-&gt;hash ())
1529  								  .representative (nano::dev::genesis_key.pub)
1530  								  .balance (nano::dev::constants.genesis_amount)
1531  								  .link (send_zero-&gt;hash ())
1532  								  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1533  								  .work (*pool.generate (send_zero-&gt;hash ()))
1534  								  .build ();
1535  		auto epoch = builder
1536  					 .state ()
1537  					 .account (nano::dev::genesis_key.pub)
1538  					 .previous (state_receive_zero-&gt;hash ())
1539  					 .representative (nano::dev::genesis_key.pub)
1540  					 .balance (nano::dev::constants.genesis_amount)
1541  					 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1542  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1543  					 .work (*pool.generate (state_receive_zero-&gt;hash ()))
1544  					 .build ();
1545  		auto state_send = builder
1546  						  .state ()
1547  						  .account (nano::dev::genesis_key.pub)
1548  						  .previous (epoch-&gt;hash ())
1549  						  .representative (nano::dev::genesis_key.pub)
1550  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1551  						  .link (nano::dev::genesis_key.pub)
1552  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1553  						  .work (*pool.generate (epoch-&gt;hash ()))
1554  						  .build ();
1555  		auto state_receive = builder
1556  							 .state ()
1557  							 .account (nano::dev::genesis_key.pub)
1558  							 .previous (state_send-&gt;hash ())
1559  							 .representative (nano::dev::genesis_key.pub)
1560  							 .balance (nano::dev::constants.genesis_amount)
1561  							 .link (state_send-&gt;hash ())
1562  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1563  							 .work (*pool.generate (state_send-&gt;hash ()))
1564  							 .build ();
1565  		auto state_change = builder
1566  							.state ()
1567  							.account (nano::dev::genesis_key.pub)
1568  							.previous (state_receive-&gt;hash ())
1569  							.representative (nano::dev::genesis_key.pub)
1570  							.balance (nano::dev::constants.genesis_amount)
1571  							.link (0)
1572  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1573  							.work (*pool.generate (state_receive-&gt;hash ()))
1574  							.build ();
1575  		auto state_send_change = builder
1576  								 .state ()
1577  								 .account (nano::dev::genesis_key.pub)
1578  								 .previous (state_change-&gt;hash ())
1579  								 .representative (key1.pub)
1580  								 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1581  								 .link (key1.pub)
1582  								 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1583  								 .work (*pool.generate (state_change-&gt;hash ()))
1584  								 .build ();
1585  		auto epoch_first = builder
1586  						   .state ()
1587  						   .account (key1.pub)
1588  						   .previous (0)
1589  						   .representative (0)
1590  						   .balance (0)
1591  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1592  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1593  						   .work (*pool.generate (key1.pub))
1594  						   .build ();
1595  		auto state_receive2 = builder
1596  							  .state ()
1597  							  .account (key1.pub)
1598  							  .previous (epoch_first-&gt;hash ())
1599  							  .representative (key1.pub)
1600  							  .balance (nano::Gxrb_ratio)
1601  							  .link (state_send_change-&gt;hash ())
1602  							  .sign (key1.prv, key1.pub)
1603  							  .work (*pool.generate (epoch_first-&gt;hash ()))
1604  							  .build ();
1605  		auto state_send2 = builder
1606  						   .state ()
1607  						   .account (nano::dev::genesis_key.pub)
1608  						   .previous (state_send_change-&gt;hash ())
1609  						   .representative (key1.pub)
1610  						   .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio * 2)
1611  						   .link (key2.pub)
1612  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1613  						   .work (*pool.generate (state_send_change-&gt;hash ()))
1614  						   .build ();
1615  		auto state_open = builder
1616  						  .state ()
1617  						  .account (key2.pub)
1618  						  .previous (0)
1619  						  .representative (key2.pub)
1620  						  .balance (nano::Gxrb_ratio)
1621  						  .link (state_send2-&gt;hash ())
1622  						  .sign (key2.prv, key2.pub)
1623  						  .work (*pool.generate (key2.pub))
1624  						  .build ();
1625  		auto state_send_epoch_link = builder
1626  									 .state ()
1627  									 .account (key2.pub)
1628  									 .previous (state_open-&gt;hash ())
1629  									 .representative (key2.pub)
1630  									 .balance (0)
1631  									 .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_2))
1632  									 .sign (key2.prv, key2.pub)
1633  									 .work (*pool.generate (state_open-&gt;hash ()))
1634  									 .build ();
1635  		{
1636  			nano::logger_mt logger;
1637  			nano::lmdb::store store (logger, path, nano::dev::constants);
1638  			auto transaction (store.tx_begin_write ());
1639  			nano::stats stats;
1640  			nano::ledger ledger (store, stats, nano::dev::constants);
1641  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1642  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_zero).code);
1643  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive_zero).code);
1644  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch).code);
1645  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1646  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive).code);
1647  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_change).code);
1648  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_change).code);
1649  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *epoch_first).code);
1650  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_receive2).code);
1651  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send2).code);
1652  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1653  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send_epoch_link).code);
1654  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1655  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1656  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1657  			store.version.put (transaction, 17);
1658  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_receive);
1659  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *epoch_first);
1660  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send2);
1661  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send_epoch_link);
1662  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1663  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send_zero);
1664  			write_sideband_v15 (store, transaction, *state_receive_zero);
1665  			write_sideband_v15 (store, transaction, *epoch);
1666  			write_sideband_v15 (store, transaction, *state_send);
1667  			write_sideband_v15 (store, transaction, *state_change);
1668  			write_sideband_v15 (store, transaction, *state_send_change);
1669  			write_sideband_v15 (store, transaction, *state_receive2);
1670  			write_sideband_v15 (store, transaction, *state_open);
1671  			store.block.del (transaction, state_receive_zero-&gt;hash ());
1672  			store.block.del (transaction, epoch-&gt;hash ());
1673  			store.block.del (transaction, state_send-&gt;hash ());
1674  			store.block.del (transaction, state_change-&gt;hash ());
1675  			store.block.del (transaction, state_send_change-&gt;hash ());
1676  			store.block.del (transaction, state_receive2-&gt;hash ());
1677  			store.block.del (transaction, state_open-&gt;hash ());
1678  		}
1679  		nano::logger_mt logger;
1680  		nano::lmdb::store store (logger, path, nano::dev::constants);
1681  		ASSERT_FALSE (store.init_error ());
1682  		auto transaction (store.tx_begin_read ());
1683  		nano::mdb_val value;
1684  		ASSERT_FALSE (mdb_get (store.env.tx (transaction), store.block_store.blocks_handle, nano::mdb_val (state_send-&gt;hash ()), value));
1685  		ASSERT_EQ (value.size (), sizeof (nano::block_type) + nano::state_block::size + nano::block_sideband::size (nano::block_type::state));
1686  		{
1687  			auto block = store.block.get (transaction, send_zero-&gt;hash ());
1688  			ASSERT_NE (block, nullptr);
1689  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1690  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1691  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1692  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1693  		}
1694  		{
1695  			auto block = store.block.get (transaction, state_receive_zero-&gt;hash ());
1696  			ASSERT_NE (block, nullptr);
1697  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_0);
1698  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1699  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1700  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1701  		}
1702  		{
1703  			auto block = store.block.get (transaction, epoch-&gt;hash ());
1704  			ASSERT_NE (block, nullptr);
1705  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1706  			ASSERT_TRUE (block-&gt;sideband ().details.is_epoch);
1707  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1708  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1709  		}
1710  		{
1711  			auto block = store.block.get (transaction, state_send-&gt;hash ());
1712  			ASSERT_NE (block, nullptr);
1713  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1714  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1715  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1716  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1717  		}
1718  		{
1719  			auto block = store.block.get (transaction, state_receive-&gt;hash ());
1720  			ASSERT_NE (block, nullptr);
1721  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1722  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1723  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1724  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1725  		}
1726  		{
1727  			auto block = store.block.get (transaction, state_change-&gt;hash ());
1728  			ASSERT_NE (block, nullptr);
1729  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1730  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1731  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1732  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1733  		}
1734  		{
1735  			auto block = store.block.get (transaction, state_send_change-&gt;hash ());
1736  			ASSERT_NE (block, nullptr);
1737  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1738  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1739  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1740  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1741  		}
1742  		{
1743  			auto block = store.block.get (transaction, epoch_first-&gt;hash ());
1744  			ASSERT_NE (block, nullptr);
1745  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_2);
1746  			ASSERT_TRUE (block-&gt;sideband ().details.is_epoch);
1747  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1748  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1749  		}
1750  		{
1751  			auto block = store.block.get (transaction, state_receive2-&gt;hash ());
1752  			ASSERT_NE (block, nullptr);
1753  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_2);
1754  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1755  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1756  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1757  		}
1758  		{
1759  			auto block = store.block.get (transaction, state_send2-&gt;hash ());
1760  			ASSERT_NE (block, nullptr);
1761  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1762  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1763  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1764  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1765  		}
1766  		{
1767  			auto block = store.block.get (transaction, state_open-&gt;hash ());
1768  			ASSERT_NE (block, nullptr);
1769  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1770  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1771  			ASSERT_FALSE (block-&gt;sideband ().details.is_send);
1772  			ASSERT_TRUE (block-&gt;sideband ().details.is_receive);
1773  		}
1774  		{
1775  			auto block = store.block.get (transaction, state_send_epoch_link-&gt;hash ());
1776  			ASSERT_NE (block, nullptr);
1777  			ASSERT_EQ (block-&gt;sideband ().details.epoch, nano::epoch::epoch_1);
1778  			ASSERT_FALSE (block-&gt;sideband ().details.is_epoch);
1779  			ASSERT_TRUE (block-&gt;sideband ().details.is_send);
1780  			ASSERT_FALSE (block-&gt;sideband ().details.is_receive);
1781  		}
1782  		ASSERT_LT (17, store.version.get (transaction));
1783  	}
1784  	TEST (mdb_block_store, upgrade_v18_v19)
1785  	{
1786  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1787  		{
1788  			GTEST_SKIP ();
1789  		}
1790  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1791  		nano::keypair key1;
1792  		nano::block_builder builder;
1793  		nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits&lt;unsigned&gt;::max () };
1794  		auto send = builder
1795  					.send ()
1796  					.previous (nano::dev::genesis-&gt;hash ())
1797  					.destination (nano::dev::genesis_key.pub)
1798  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1799  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1800  					.work (*pool.generate (nano::dev::genesis-&gt;hash ()))
1801  					.build ();
1802  		auto receive = builder
1803  					   .receive ()
1804  					   .previous (send-&gt;hash ())
1805  					   .source (send-&gt;hash ())
1806  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1807  					   .work (*pool.generate (send-&gt;hash ()))
1808  					   .build ();
1809  		auto change = builder
1810  					  .change ()
1811  					  .previous (receive-&gt;hash ())
1812  					  .representative (0)
1813  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1814  					  .work (*pool.generate (receive-&gt;hash ()))
1815  					  .build ();
1816  		auto state_epoch = builder
1817  						   .state ()
1818  						   .account (nano::dev::genesis_key.pub)
1819  						   .previous (change-&gt;hash ())
1820  						   .representative (0)
1821  						   .balance (nano::dev::constants.genesis_amount)
1822  						   .link (nano::dev::network_params.ledger.epochs.link (nano::epoch::epoch_1))
1823  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  						   .work (*pool.generate (change-&gt;hash ()))
1825  						   .build ();
1826  		auto state_send = builder
1827  						  .state ()
1828  						  .account (nano::dev::genesis_key.pub)
1829  						  .previous (state_epoch-&gt;hash ())
1830  						  .representative (0)
1831  						  .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1832  						  .link (key1.pub)
1833  						  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1834  						  .work (*pool.generate (state_epoch-&gt;hash ()))
1835  						  .build ();
1836  		auto state_open = builder
1837  						  .state ()
1838  						  .account (key1.pub)
1839  						  .previous (0)
1840  						  .representative (0)
1841  						  .balance (nano::Gxrb_ratio)
1842  						  .link (state_send-&gt;hash ())
1843  						  .sign (key1.prv, key1.pub)
1844  						  .work (*pool.generate (key1.pub))
1845  						  .build ();
1846  		{
1847  			nano::logger_mt logger;
1848  			nano::lmdb::store store (logger, path, nano::dev::constants);
1849  			nano::stats stats;
1850  			nano::ledger ledger (store, stats, nano::dev::constants);
1851  			auto transaction (store.tx_begin_write ());
1852  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1853  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1854  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
1855  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *change).code);
1856  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_epoch).code);
1857  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_send).code);
1858  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *state_open).code);
1859  			auto txn = store.env.tx (transaction);
1860  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;open&quot;, MDB_CREATE, &amp;store.block_store.open_blocks_handle));
1861  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;receive&quot;, MDB_CREATE, &amp;store.block_store.receive_blocks_handle));
1862  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;send&quot;, MDB_CREATE, &amp;store.block_store.send_blocks_handle));
1863  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;change&quot;, MDB_CREATE, &amp;store.block_store.change_blocks_handle));
1864  			ASSERT_FALSE (mdb_dbi_open (txn, &quot;state_blocks&quot;, MDB_CREATE, &amp;store.block_store.state_blocks_handle));
1865  			write_block_w_sideband_v18 (store, store.block_store.open_blocks_handle, transaction, *nano::dev::genesis);
1866  			write_block_w_sideband_v18 (store, store.block_store.send_blocks_handle, transaction, *send);
1867  			write_block_w_sideband_v18 (store, store.block_store.receive_blocks_handle, transaction, *receive);
1868  			write_block_w_sideband_v18 (store, store.block_store.change_blocks_handle, transaction, *change);
1869  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_epoch);
1870  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_send);
1871  			write_block_w_sideband_v18 (store, store.block_store.state_blocks_handle, transaction, *state_open);
1872  			store.version.put (transaction, 18);
1873  		}
1874  		nano::logger_mt logger;
1875  		nano::lmdb::store store (logger, path, nano::dev::constants);
1876  		ASSERT_FALSE (store.init_error ());
1877  		auto transaction (store.tx_begin_read ());
1878  		ASSERT_EQ (store.block_store.send_blocks_handle, 0);
1879  		ASSERT_EQ (store.block_store.receive_blocks_handle, 0);
1880  		ASSERT_EQ (store.block_store.change_blocks_handle, 0);
1881  		ASSERT_EQ (store.block_store.open_blocks_handle, 0);
1882  		ASSERT_EQ (store.block_store.state_blocks_handle, 0);
1883  		ASSERT_TRUE (store.block.get (transaction, send-&gt;hash ()));
1884  		ASSERT_TRUE (store.block.get (transaction, receive-&gt;hash ()));
1885  		ASSERT_TRUE (store.block.get (transaction, change-&gt;hash ()));
1886  		ASSERT_TRUE (store.block.get (transaction, nano::dev::genesis-&gt;hash ()));
1887  		auto state_epoch_disk (store.block.get (transaction, state_epoch-&gt;hash ()));
1888  		ASSERT_NE (nullptr, state_epoch_disk);
1889  		ASSERT_EQ (nano::epoch::epoch_1, state_epoch_disk-&gt;sideband ().details.epoch);
1890  		ASSERT_EQ (nano::epoch::epoch_0, state_epoch_disk-&gt;sideband ().source_epoch); 
1891  		ASSERT_TRUE (store.block.get (transaction, state_send-&gt;hash ()));
1892  		auto state_send_disk (store.block.get (transaction, state_send-&gt;hash ()));
1893  		ASSERT_NE (nullptr, state_send_disk);
1894  		ASSERT_EQ (nano::epoch::epoch_1, state_send_disk-&gt;sideband ().details.epoch);
1895  		ASSERT_EQ (nano::epoch::epoch_0, state_send_disk-&gt;sideband ().source_epoch); 
1896  		ASSERT_TRUE (store.block.get (transaction, state_open-&gt;hash ()));
1897  		auto state_open_disk (store.block.get (transaction, state_open-&gt;hash ()));
1898  		ASSERT_NE (nullptr, state_open_disk);
1899  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk-&gt;sideband ().details.epoch);
1900  		ASSERT_EQ (nano::epoch::epoch_1, state_open_disk-&gt;sideband ().source_epoch);
1901  		ASSERT_EQ (7, store.count (transaction, store.block_store.blocks_handle));
1902  		ASSERT_LT (18, store.version.get (transaction));
1903  	}
1904  	TEST (mdb_block_store, upgrade_v19_v20)
1905  	{
1906  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1907  		{
1908  			GTEST_SKIP ();
1909  		}
1910  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1911  		nano::logger_mt logger;
1912  		nano::stats stats;
1913  		{
1914  			nano::lmdb::store store (logger, path, nano::dev::constants);
1915  			nano::ledger ledger (store, stats, nano::dev::constants);
1916  			auto transaction (store.tx_begin_write ());
1917  			store.initialize (transaction, ledger.cache, nano::dev::constants);
1918  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.pruned_store.pruned_handle, 1));
1919  			store.version.put (transaction, 19);
1920  		}
1921  		nano::lmdb::store store (logger, path, nano::dev::constants);
1922  		ASSERT_FALSE (store.init_error ());
1923  		ASSERT_NE (store.pruned_store.pruned_handle, 0);
1924  		auto transaction (store.tx_begin_read ());
1925  		ASSERT_LT (19, store.version.get (transaction));
1926  	}
1927  	TEST (mdb_block_store, upgrade_v20_v21)
1928  	{
1929  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1930  		{
1931  			GTEST_SKIP ();
1932  		}
1933  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1934  		nano::logger_mt logger;
1935  		nano::stats stats;
1936  		{
1937  			nano::lmdb::store store (logger, path, nano::dev::constants);
1938  			nano::ledger ledger (store, stats, nano::dev::constants);
1939  			auto transaction (store.tx_begin_write ());
1940  			store.initialize (transaction, ledger.cache, ledger.constants);
1941  			ASSERT_FALSE (mdb_drop (store.env.tx (transaction), store.final_vote_store.final_votes_handle, 1));
1942  			store.version.put (transaction, 20);
1943  		}
1944  		nano::lmdb::store store (logger, path, nano::dev::constants);
1945  		ASSERT_FALSE (store.init_error ());
1946  		ASSERT_NE (store.final_vote_store.final_votes_handle, 0);
1947  		auto transaction (store.tx_begin_read ());
1948  		ASSERT_LT (19, store.version.get (transaction));
1949  	}
1950  	TEST (mdb_block_store, upgrade_v21_v22)
1951  	{
1952  		if (nano::rocksdb_config::using_rocksdb_in_tests ())
1953  		{
1954  			GTEST_SKIP ();
1955  		}
1956  		auto path (nano::unique_path () / &quot;data.ldb&quot;);
1957  		nano::logger_mt logger;
1958  		nano::stats stats;
1959  		auto const check_correct_state = [&amp;] () {
1960  			nano::lmdb::store store (logger, path, nano::dev::constants);
1961  			auto transaction (store.tx_begin_write ());
1962  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1963  			MDB_dbi unchecked_handle{ 0 };
1964  			ASSERT_EQ (MDB_NOTFOUND, mdb_dbi_open (store.env.tx (transaction), &quot;unchecked&quot;, 0, &amp;unchecked_handle));
1965  		};
1966  		check_correct_state ();
1967  		{
1968  			nano::lmdb::store store (logger, path, nano::dev::constants);
1969  			auto transaction (store.tx_begin_write ());
1970  			store.version.put (transaction, 21);
1971  			MDB_dbi unchecked_handle{ 0 };
1972  			ASSERT_FALSE (mdb_dbi_open (store.env.tx (transaction), &quot;unchecked&quot;, MDB_CREATE, &amp;unchecked_handle));
1973  			ASSERT_EQ (store.version.get (transaction), 21);
1974  		}
1975  		check_correct_state ();
1976  	}
1977  }
1978  namespace rocksdb
1979  {
1980  	TEST (rocksdb_block_store, upgrade_v21_v22)
1981  	{
1982  		if (!nano::rocksdb_config::using_rocksdb_in_tests ())
1983  		{
1984  			GTEST_SKIP ();
1985  		}
1986  		auto const path = nano::unique_path () / &quot;rocksdb&quot;;
1987  		nano::logger_mt logger;
1988  		nano::stats stats;
1989  		auto const check_correct_state = [&amp;] () {
1990  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1991  			auto transaction (store.tx_begin_write ());
1992  			ASSERT_EQ (store.version.get (transaction), store.version_current);
1993  			ASSERT_FALSE (store.column_family_exists (&quot;unchecked&quot;));
1994  		};
1995  		check_correct_state ();
1996  		{
1997  			nano::rocksdb::store store (logger, path, nano::dev::constants);
1998  			::rocksdb::ColumnFamilyOptions new_cf_options;
1999  			::rocksdb::ColumnFamilyHandle * new_cf_handle;
2000  			::rocksdb::Status status = store.db-&gt;CreateColumnFamily (new_cf_options, &quot;unchecked&quot;, &amp;new_cf_handle);
2001  			store.handles.emplace_back (new_cf_handle);
2002  			ASSERT_TRUE (status.ok ());
2003  			auto transaction (store.tx_begin_write ());
2004  			store.version.put (transaction, 21);
2005  			ASSERT_EQ (store.version.get (transaction), 21);
2006  		}
2007  		check_correct_state ();
2008  	}
2009  }
2010  }
2011  TEST (mdb_block_store, upgrade_backup)
2012  {
2013  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2014  	{
2015  		GTEST_SKIP ();
2016  	}
2017  	auto dir (nano::unique_path ());
2018  	namespace fs = boost::filesystem;
2019  	fs::create_directory (dir);
2020  	auto path = dir / &quot;data.ldb&quot;;
2021  	auto get_backup_path = [&amp;dir] () {
2022  		for (fs::directory_iterator itr (dir); itr != fs::directory_iterator (); ++itr)
2023  		{
2024  			if (itr-&gt;path ().filename ().string ().find (&quot;data_backup_&quot;) != std::string::npos)
2025  			{
2026  				return itr-&gt;path ();
2027  			}
2028  		}
2029  		return dir;
2030  	};
2031  	{
2032  		nano::logger_mt logger;
2033  		nano::lmdb::store store (logger, path, nano::dev::constants);
2034  		auto transaction (store.tx_begin_write ());
2035  		store.version.put (transaction, 14);
2036  	}
2037  	ASSERT_EQ (get_backup_path ().string (), dir.string ());
2038  	nano::logger_mt logger;
2039  	nano::lmdb::store store (logger, path, nano::dev::constants, nano::txn_tracking_config{}, std::chrono::seconds (5), nano::lmdb_config{}, true);
2040  	ASSERT_FALSE (store.init_error ());
2041  	auto transaction (store.tx_begin_read ());
2042  	ASSERT_LT (14, store.version.get (transaction));
2043  	ASSERT_NE (get_backup_path ().string (), dir.string ());
2044  }
2045  TEST (block_store, confirmation_height)
2046  {
2047  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2048  	{
2049  		GTEST_SKIP ();
2050  	}
2051  	auto path (nano::unique_path ());
2052  	nano::logger_mt logger;
2053  	auto store = nano::make_store (logger, path, nano::dev::constants);
2054  	nano::account account1{};
2055  	nano::account account2{ 1 };
2056  	nano::account account3{ 2 };
2057  	nano::block_hash cemented_frontier1 (3);
2058  	nano::block_hash cemented_frontier2 (4);
2059  	nano::block_hash cemented_frontier3 (5);
2060  	{
2061  		auto transaction (store-&gt;tx_begin_write ());
2062  		store-&gt;confirmation_height.put (transaction, account1, { 500, cemented_frontier1 });
2063  		store-&gt;confirmation_height.put (transaction, account2, { std::numeric_limits&lt;uint64_t&gt;::max (), cemented_frontier2 });
2064  		store-&gt;confirmation_height.put (transaction, account3, { 10, cemented_frontier3 });
2065  		nano::confirmation_height_info confirmation_height_info;
2066  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
2067  		ASSERT_EQ (confirmation_height_info.height, 500);
2068  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier1);
2069  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
2070  		ASSERT_EQ (confirmation_height_info.height, std::numeric_limits&lt;uint64_t&gt;::max ());
2071  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier2);
2072  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account3, confirmation_height_info));
2073  		ASSERT_EQ (confirmation_height_info.height, 10);
2074  		ASSERT_EQ (confirmation_height_info.frontier, cemented_frontier3);
2075  		store-&gt;confirmation_height.clear (transaction);
2076  	}
2077  	auto transaction (store-&gt;tx_begin_read ());
2078  	ASSERT_EQ (store-&gt;confirmation_height.count (transaction), 0);
2079  	nano::confirmation_height_info confirmation_height_info;
2080  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
2081  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account2, confirmation_height_info));
2082  	ASSERT_TRUE (store-&gt;confirmation_height.get (transaction, account3, confirmation_height_info));
2083  }
2084  TEST (block_store, final_vote)
2085  {
2086  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2087  	{
2088  		GTEST_SKIP ();
2089  	}
2090  	auto path (nano::unique_path ());
2091  	nano::logger_mt logger;
2092  	auto store = nano::make_store (logger, path, nano::dev::constants);
2093  	{
2094  		auto qualified_root = nano::dev::genesis-&gt;qualified_root ();
2095  		auto transaction (store-&gt;tx_begin_write ());
2096  		store-&gt;final_vote.put (transaction, qualified_root, nano::block_hash (2));
2097  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2098  		store-&gt;final_vote.clear (transaction);
2099  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 0);
2100  		store-&gt;final_vote.put (transaction, qualified_root, nano::block_hash (2));
2101  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2102  		store-&gt;final_vote.clear (transaction, qualified_root.previous ());
2103  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 1);
2104  		store-&gt;final_vote.clear (transaction, qualified_root.root ());
2105  		ASSERT_EQ (store-&gt;final_vote.count (transaction), 0);
2106  	}
2107  }
2108  TEST (block_store, incompatible_version)
2109  {
2110  	auto path (nano::unique_path ());
2111  	nano::logger_mt logger;
2112  	{
2113  		auto store = nano::make_store (logger, path, nano::dev::constants);
2114  		ASSERT_FALSE (store-&gt;init_error ());
2115  		auto transaction (store-&gt;tx_begin_write ());
2116  		store-&gt;version.put (transaction, std::numeric_limits&lt;int&gt;::max ());
2117  	}
2118  	{
2119  		auto store = nano::make_store (logger, path, nano::dev::constants, true);
2120  		ASSERT_TRUE (store-&gt;init_error ());
2121  		auto transaction = store-&gt;tx_begin_read ();
2122  		auto version_l = store-&gt;version.get (transaction);
2123  		ASSERT_EQ (version_l, std::numeric_limits&lt;int&gt;::max ());
2124  	}
2125  }
2126  TEST (block_store, reset_renew_existing_transaction)
2127  {
2128  	nano::logger_mt logger;
2129  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2130  	ASSERT_TRUE (!store-&gt;init_error ());
2131  	nano::keypair key1;
2132  	nano::block_builder builder;
2133  	auto block = builder
2134  				 .open ()
2135  				 .source (0)
2136  				 .representative (1)
2137  				 .account (1)
2138  				 .sign (nano::keypair ().prv, 0)
2139  				 .work (0)
2140  				 .build ();
2141  	block-&gt;sideband_set ({});
2142  	auto hash1 (block-&gt;hash ());
2143  	auto read_transaction = store-&gt;tx_begin_read ();
2144  	auto block_non_existing (store-&gt;block.get (read_transaction, hash1));
2145  	ASSERT_EQ (nullptr, block_non_existing);
2146  	read_transaction.reset ();
2147  	{
2148  		auto write_transaction (store-&gt;tx_begin_write ());
2149  		store-&gt;block.put (write_transaction, hash1, *block);
2150  	}
2151  	read_transaction.renew ();
2152  	auto block_existing (store-&gt;block.get (read_transaction, hash1));
2153  	ASSERT_NE (nullptr, block_existing);
2154  }
2155  TEST (block_store, rocksdb_force_test_env_variable)
2156  {
2157  	nano::logger_mt logger;
2158  	constexpr auto env_var = &quot;TEST_USE_ROCKSDB&quot;;
2159  	auto value = std::getenv (env_var);
2160  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
2161  	auto mdb_cast = dynamic_cast&lt;nano::lmdb::store *&gt; (store.get ());
2162  	if (value &amp;&amp; boost::lexical_cast&lt;int&gt; (value) == 1)
2163  	{
2164  		ASSERT_NE (boost::polymorphic_downcast&lt;nano::rocksdb::store *&gt; (store.get ()), nullptr);
2165  	}
2166  	else
2167  	{
2168  		ASSERT_NE (mdb_cast, nullptr);
2169  	}
2170  }
2171  namespace nano
2172  {
2173  TEST (rocksdb_block_store, tombstone_count)
2174  {
2175  	if (!nano::rocksdb_config::using_rocksdb_in_tests ())
2176  	{
2177  		GTEST_SKIP ();
2178  	}
2179  	nano::test::system system;
2180  	nano::logger_mt logger;
2181  	auto store = std::make_unique&lt;nano::rocksdb::store&gt; (logger, nano::unique_path () / &quot;rocksdb&quot;, nano::dev::constants);
2182  	ASSERT_TRUE (!store-&gt;init_error ());
2183  	nano::block_builder builder;
2184  	auto block = builder
2185  				 .send ()
2186  				 .previous (0)
2187  				 .destination (1)
2188  				 .balance (2)
2189  				 .sign (nano::keypair ().prv, 4)
2190  				 .work (5)
2191  				 .build_shared ();
2192  	nano::account account{ 1 };
2193  	store-&gt;account.put (store-&gt;tx_begin_write (), account, nano::account_info{});
2194  	auto check_block_is_listed = [&amp;] (nano::transaction const &amp; transaction_a) {
2195  		return store-&gt;account.exists (transaction_a, account);
2196  	};
2197  	ASSERT_TIMELY (5s, check_block_is_listed (store-&gt;tx_begin_read ()));
2198  	ASSERT_EQ (store-&gt;tombstone_map.at (nano::tables::accounts).num_since_last_flush.load (), 0);
2199  	store-&gt;account.del (store-&gt;tx_begin_write (), account);
2200  	ASSERT_TIMELY (5s, store-&gt;tombstone_map.at (nano::tables::accounts).num_since_last_flush.load () == 1);
2201  }
2202  }
2203  namespace nano
2204  {
2205  namespace lmdb
2206  {
2207  	void write_sideband_v14 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a, MDB_dbi db_a)
2208  	{
2209  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2210  		ASSERT_NE (block, nullptr);
2211  		nano::block_sideband_v14 sideband_v14 (block-&gt;type (), block-&gt;sideband ().account, block-&gt;sideband ().successor, block-&gt;sideband ().balance, block-&gt;sideband ().timestamp, block-&gt;sideband ().height);
2212  		std::vector&lt;uint8_t&gt; data;
2213  		{
2214  			nano::vectorstream stream (data);
2215  			block_a.serialize (stream);
2216  			sideband_v14.serialize (stream);
2217  		}
2218  		MDB_val val{ data.size (), data.data () };
2219  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), block-&gt;sideband ().details.epoch == nano::epoch::epoch_0 ? store_a.block_store.state_blocks_v0_handle : store_a.block_store.state_blocks_v1_handle, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2220  	}
2221  	void write_sideband_v15 (nano::lmdb::store &amp; store_a, nano::transaction &amp; transaction_a, nano::block const &amp; block_a)
2222  	{
2223  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2224  		ASSERT_NE (block, nullptr);
2225  		ASSERT_LE (block-&gt;sideband ().details.epoch, nano::epoch::max);
2226  		nano::block_sideband_v18 sideband_v15 (block-&gt;sideband ().account, block-&gt;sideband ().successor, block-&gt;sideband ().balance, block-&gt;sideband ().timestamp, block-&gt;sideband ().height, block-&gt;sideband ().details.epoch, false, false, false);
2227  		std::vector&lt;uint8_t&gt; data;
2228  		{
2229  			nano::vectorstream stream (data);
2230  			block_a.serialize (stream);
2231  			sideband_v15.serialize (stream, block_a.type ());
2232  		}
2233  		MDB_val val{ data.size (), data.data () };
2234  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), store_a.block_store.state_blocks_handle, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2235  	}
2236  	void write_block_w_sideband_v18 (nano::lmdb::store &amp; store_a, MDB_dbi database, nano::write_transaction &amp; transaction_a, nano::block const &amp; block_a)
2237  	{
2238  		auto block = store_a.block.get (transaction_a, block_a.hash ());
2239  		ASSERT_NE (block, nullptr);
2240  		auto new_sideband (block-&gt;sideband ());
2241  		nano::block_sideband_v18 sideband_v18 (new_sideband.account, new_sideband.successor, new_sideband.balance, new_sideband.height, new_sideband.timestamp, new_sideband.details.epoch, new_sideband.details.is_send, new_sideband.details.is_receive, new_sideband.details.is_epoch);
2242  		std::vector&lt;uint8_t&gt; data;
2243  		{
2244  			nano::vectorstream stream (data);
2245  			block-&gt;serialize (stream);
2246  			sideband_v18.serialize (stream, block-&gt;type ());
2247  		}
2248  		MDB_val val{ data.size (), data.data () };
2249  		ASSERT_FALSE (mdb_put (store_a.env.tx (transaction_a), database, nano::mdb_val (block_a.hash ()), &amp;val, 0));
2250  		store_a.del (transaction_a, nano::tables::blocks, nano::mdb_val (block_a.hash ()));
2251  	}
2252  	void modify_account_info_to_v14 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height, nano::block_hash const &amp; rep_block)
2253  	{
2254  		nano::account_info info;
2255  		ASSERT_FALSE (store.account.get (transaction, account, info));
2256  		nano::account_info_v14 account_info_v14 (info.head, rep_block, info.open_block, info.balance, info.modified, info.block_count, confirmation_height, info.epoch ());
2257  		auto status (mdb_put (store.env.tx (transaction), info.epoch () == nano::epoch::epoch_0 ? store.account_store.accounts_v0_handle : store.account_store.accounts_v1_handle, nano::mdb_val (account), nano::mdb_val (account_info_v14), 0));
2258  		ASSERT_EQ (status, 0);
2259  	}
2260  	void modify_confirmation_height_to_v15 (nano::lmdb::store &amp; store, nano::transaction const &amp; transaction, nano::account const &amp; account, uint64_t confirmation_height)
2261  	{
2262  		auto status (mdb_put (store.env.tx (transaction), store.confirmation_height_store.confirmation_height_handle, nano::mdb_val (account), nano::mdb_val (confirmation_height), 0));
2263  		ASSERT_EQ (status, 0);
2264  	}
2265  }
2266  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2065  		nano::confirmation_height_info confirmation_height_info;
2066  		ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account1, confirmation_height_info));
2067  		ASSERT_EQ (confirmation_height_info.height, 500);
</pre></code></div>
                <div class="column column_space"><pre><code>477  	nano::confirmation_height_info confirmation_height_info;
478  	ASSERT_FALSE (store-&gt;confirmation_height.get (transaction, account, confirmation_height_info));
479  	ASSERT_EQ (20, confirmation_height_info.height);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    