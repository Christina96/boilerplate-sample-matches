
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.784399649430324%, Tokens: 14</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-substitute.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_SUBSTITUTE_H_
2  #define ABSL_STRINGS_SUBSTITUTE_H_
3  #include <cstring>
4  #include <string>
5  #include <type_traits>
6  #include <vector>
7  #include "absl/base/macros.h"
8  #include "absl/base/port.h"
9  #include "absl/strings/ascii.h"
10  #include "absl/strings/escaping.h"
11  #include "absl/strings/internal/stringify_sink.h"
12  #include "absl/strings/numbers.h"
13  #include "absl/strings/str_cat.h"
14  #include "absl/strings/str_split.h"
15  #include "absl/strings/string_view.h"
16  #include "absl/strings/strip.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace substitute_internal {
20  class Arg {
21   public:
22    Arg(const char* value)  
23        : piece_(absl::NullSafeStringView(value)) {}
24    template <typename Allocator>
25    Arg(  
26        const std::basic_string<char, std::char_traits<char>, Allocator>&
27            value) noexcept
28        : piece_(value) {}
29    Arg(absl::string_view value)  
30        : piece_(value) {}
31    Arg(char value)  
32        : piece_(scratch_, 1) {
33      scratch_[0] = value;
34    }
35    Arg(short value)  
36        : piece_(scratch_,
37                 static_cast<size_t>(
38                     numbers_internal::FastIntToBuffer(value, scratch_) -
39                     scratch_)) {}
40    Arg(unsigned short value)  
41        : piece_(scratch_,
42                 static_cast<size_t>(
43                     numbers_internal::FastIntToBuffer(value, scratch_) -
44                     scratch_)) {}
45    Arg(int value)  
46        : piece_(scratch_,
47                 static_cast<size_t>(
48                     numbers_internal::FastIntToBuffer(value, scratch_) -
49                     scratch_)) {}
50    Arg(unsigned int value)  
51        : piece_(scratch_,
52                 static_cast<size_t>(
53                     numbers_internal::FastIntToBuffer(value, scratch_) -
54                     scratch_)) {}
55    Arg(long value)  
56        : piece_(scratch_,
57                 static_cast<size_t>(
58                     numbers_internal::FastIntToBuffer(value, scratch_) -
59                     scratch_)) {}
60    Arg(unsigned long value)  
61        : piece_(scratch_,
62                 static_cast<size_t>(
63                     numbers_internal::FastIntToBuffer(value, scratch_) -
64                     scratch_)) {}
65    Arg(long long value)  
66        : piece_(scratch_,
67                 static_cast<size_t>(
68                     numbers_internal::FastIntToBuffer(value, scratch_) -
69                     scratch_)) {}
70    Arg(unsigned long long value)  
71        : piece_(scratch_,
72                 static_cast<size_t>(
73                     numbers_internal::FastIntToBuffer(value, scratch_) -
74                     scratch_)) {}
75    Arg(float value)  
76        : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {
77    }
78    Arg(double value)  
79        : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {
80    }
81    Arg(bool value)  
82        : piece_(value ? "true" : "false") {}
83    template <typename T, typename = typename std::enable_if<
84                              strings_internal::HasAbslStringify<T>::value>::type>
85    Arg(  
86        const T& v, strings_internal::StringifySink&& sink = {})
87        : piece_(strings_internal::ExtractStringification(sink, v)) {}
88    Arg(Hex hex);  
89    Arg(Dec dec);  
90    template <typename T,
91              absl::enable_if_t<
92                  std::is_class<T>::value &&
93                  (std::is_same<T, std::vector<bool>::reference>::value ||
94                   std::is_same<T, std::vector<bool>::const_reference>::value)>* =
95                  nullptr>
96    Arg(T value)  
97        : Arg(static_cast<bool>(value)) {}
98    Arg(const void* value);  
99    template <typename T,
100              typename = typename std::enable_if<
101                  std::is_enum<T>{} && !std::is_convertible<T, int>{} &&
102                  !strings_internal::HasAbslStringify<T>::value>::type>
103    Arg(T value)  
104        : Arg(static_cast<typename std::underlying_type<T>::type>(value)) {}
105    Arg(const Arg&) = delete;
106    Arg& operator=(const Arg&) = delete;
107    absl::string_view piece() const { return piece_; }
108   private:
109    absl::string_view piece_;
110    char scratch_[numbers_internal::kFastToBufferSize];
111  };
112  void SubstituteAndAppendArray(std::string* output, absl::string_view format,
113                                const absl::string_view* args_array,
114                                size_t num_args);
115  #if defined(ABSL_BAD_CALL_IF)
116  constexpr int CalculateOneBit(const char* format) {
117    return (*format < '0' || *format > '9') ? (*format == '$' ? 0 : -1)
118                                            : (1 << (*format - '0'));
119  }
120  constexpr const char* SkipNumber(const char* format) {
121    return !*format ? format : (format + 1);
122  }
123  constexpr int PlaceholderBitmask(const char* format) {
124    return !*format
125               ? 0
126               : *format != '$' ? PlaceholderBitmask(format + 1)
127                                : (CalculateOneBit(format + 1) |
128                                   PlaceholderBitmask(SkipNumber(format + 1)));
129  }
130  #endif  
131  }  
132  inline void SubstituteAndAppend(std::string* output, absl::string_view format) {
133    substitute_internal::SubstituteAndAppendArray(output, format, nullptr, 0);
134  }
135  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
136                                  const substitute_internal::Arg& a0) {
137    const absl::string_view args[] = {a0.piece()};
138    substitute_internal::SubstituteAndAppendArray(output, format, args,
139                                                  ABSL_ARRAYSIZE(args));
140  }
141  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
142                                  const substitute_internal::Arg& a0,
143                                  const substitute_internal::Arg& a1) {
144    const absl::string_view args[] = {a0.piece(), a1.piece()};
145    substitute_internal::SubstituteAndAppendArray(output, format, args,
146                                                  ABSL_ARRAYSIZE(args));
147  }
148  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
149                                  const substitute_internal::Arg& a0,
150                                  const substitute_internal::Arg& a1,
151                                  const substitute_internal::Arg& a2) {
152    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece()};
153    substitute_internal::SubstituteAndAppendArray(output, format, args,
154                                                  ABSL_ARRAYSIZE(args));
155  }
156  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
157                                  const substitute_internal::Arg& a0,
158                                  const substitute_internal::Arg& a1,
159                                  const substitute_internal::Arg& a2,
160                                  const substitute_internal::Arg& a3) {
161    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
162                                      a3.piece()};
163    substitute_internal::SubstituteAndAppendArray(output, format, args,
164                                                  ABSL_ARRAYSIZE(args));
165  }
166  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
167                                  const substitute_internal::Arg& a0,
168                                  const substitute_internal::Arg& a1,
169                                  const substitute_internal::Arg& a2,
170                                  const substitute_internal::Arg& a3,
171                                  const substitute_internal::Arg& a4) {
172    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
173                                      a3.piece(), a4.piece()};
174    substitute_internal::SubstituteAndAppendArray(output, format, args,
175                                                  ABSL_ARRAYSIZE(args));
176  }
177  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
178                                  const substitute_internal::Arg& a0,
179                                  const substitute_internal::Arg& a1,
180                                  const substitute_internal::Arg& a2,
181                                  const substitute_internal::Arg& a3,
182                                  const substitute_internal::Arg& a4,
183                                  const substitute_internal::Arg& a5) {
184    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
185                                      a3.piece(), a4.piece(), a5.piece()};
186    substitute_internal::SubstituteAndAppendArray(output, format, args,
187                                                  ABSL_ARRAYSIZE(args));
188  }
189  inline void SubstituteAndAppend(std::string* output, absl::string_view format,
190                                  const substitute_internal::Arg& a0,
191                                  const substitute_internal::Arg& a1,
192                                  const substitute_internal::Arg& a2,
193                                  const substitute_internal::Arg& a3,
194                                  const substitute_internal::Arg& a4,
195                                  const substitute_internal::Arg& a5,
196                                  const substitute_internal::Arg& a6) {
197    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
198                                      a3.piece(), a4.piece(), a5.piece(),
199                                      a6.piece()};
200    substitute_internal::SubstituteAndAppendArray(output, format, args,
201                                                  ABSL_ARRAYSIZE(args));
202  }
203  inline void SubstituteAndAppend(
204      std::string* output, absl::string_view format,
205      const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
206      const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
207      const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
208      const substitute_internal::Arg& a6, const substitute_internal::Arg& a7) {
209    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
210                                      a3.piece(), a4.piece(), a5.piece(),
211                                      a6.piece(), a7.piece()};
212    substitute_internal::SubstituteAndAppendArray(output, format, args,
213                                                  ABSL_ARRAYSIZE(args));
214  }
215  inline void SubstituteAndAppend(
216      std::string* output, absl::string_view format,
217      const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
218      const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
219      const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
220      const substitute_internal::Arg& a6, const substitute_internal::Arg& a7,
221      const substitute_internal::Arg& a8) {
222    const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
223                                      a3.piece(), a4.piece(), a5.piece(),
224                                      a6.piece(), a7.piece(), a8.piece()};
225    substitute_internal::SubstituteAndAppendArray(output, format, args,
226                                                  ABSL_ARRAYSIZE(args));
227  }
228  inline void SubstituteAndAppend(
229      std::string* output, absl::string_view format,
230      const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
231      const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
232      const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
233      const substitute_internal::Arg& a6, const substitute_internal::Arg& a7,
234      const substitute_internal::Arg& a8, const substitute_internal::Arg& a9) {
235    const absl::string_view args[] = {
236        a0.piece(), a1.piece(), a2.piece(), a3.piece(), a4.piece(),
237        a5.piece(), a6.piece(), a7.piece(), a8.piece(), a9.piece()};
238    substitute_internal::SubstituteAndAppendArray(output, format, args,
239                                                  ABSL_ARRAYSIZE(args));
240  }
241  #if defined(ABSL_BAD_CALL_IF)
<span onclick='openModal()' class='match'>242  void SubstituteAndAppend(std::string* output, const char* format)
243      ABSL_BAD_CALL_IF(
244          substitute_internal::PlaceholderBitmask(format) != 0,
245          "There were no substitution arguments "
246          "but this format string either has a $[0-9] in it or contains "
247          "an unescaped $ character (use $$ instead)");
248  void SubstituteAndAppend(std::string* output, const char* format,
249                           const substitute_internal::Arg& a0)
250      ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1,
251                       "There was 1 substitution argument given, but "
252                       "this format string is missing its $0, contains "
253                       "one of $1-$9, or contains an unescaped $ character (use "
254                       "$$ instead)");
255  void SubstituteAndAppend(std::string* output, const char* format,
256                           const substitute_internal::Arg& a0,
257                           const substitute_internal::Arg& a1)
258      ABSL_BAD_CALL_IF(
259          substitute_internal::PlaceholderBitmask(format) != 3,
260          "There were 2 substitution arguments given, but this format string is "
261          "missing its $0/$1, contains one of $2-$9, or contains an "
262          "unescaped $ character (use $$ instead)");
263  void SubstituteAndAppend(std::string* output, const char* format,
264                           const substitute_internal::Arg& a0,
265                           const substitute_internal::Arg& a1,
266                           const substitute_internal::Arg& a2)
</span>267      ABSL_BAD_CALL_IF(
268          substitute_internal::PlaceholderBitmask(format) != 7,
269          "There were 3 substitution arguments given, but "
270          "this format string is missing its $0/$1/$2, contains one of "
271          "$3-$9, or contains an unescaped $ character (use $$ instead)");
272  void SubstituteAndAppend(std::string* output, const char* format,
273                           const substitute_internal::Arg& a0,
274                           const substitute_internal::Arg& a1,
275                           const substitute_internal::Arg& a2,
276                           const substitute_internal::Arg& a3)
277      ABSL_BAD_CALL_IF(
278          substitute_internal::PlaceholderBitmask(format) != 15,
279          "There were 4 substitution arguments given, but "
280          "this format string is missing its $0-$3, contains one of "
281          "$4-$9, or contains an unescaped $ character (use $$ instead)");
282  void SubstituteAndAppend(std::string* output, const char* format,
283                           const substitute_internal::Arg& a0,
284                           const substitute_internal::Arg& a1,
285                           const substitute_internal::Arg& a2,
286                           const substitute_internal::Arg& a3,
287                           const substitute_internal::Arg& a4)
288      ABSL_BAD_CALL_IF(
289          substitute_internal::PlaceholderBitmask(format) != 31,
290          "There were 5 substitution arguments given, but "
291          "this format string is missing its $0-$4, contains one of "
292          "$5-$9, or contains an unescaped $ character (use $$ instead)");
293  void SubstituteAndAppend(std::string* output, const char* format,
294                           const substitute_internal::Arg& a0,
295                           const substitute_internal::Arg& a1,
296                           const substitute_internal::Arg& a2,
297                           const substitute_internal::Arg& a3,
298                           const substitute_internal::Arg& a4,
299                           const substitute_internal::Arg& a5)
300      ABSL_BAD_CALL_IF(
301          substitute_internal::PlaceholderBitmask(format) != 63,
302          "There were 6 substitution arguments given, but "
303          "this format string is missing its $0-$5, contains one of "
304          "$6-$9, or contains an unescaped $ character (use $$ instead)");
305  void SubstituteAndAppend(
306      std::string* output, const char* format, const substitute_internal::Arg& a0,
307      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
308      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
309      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6)
310      ABSL_BAD_CALL_IF(
311          substitute_internal::PlaceholderBitmask(format) != 127,
312          "There were 7 substitution arguments given, but "
313          "this format string is missing its $0-$6, contains one of "
314          "$7-$9, or contains an unescaped $ character (use $$ instead)");
315  void SubstituteAndAppend(
316      std::string* output, const char* format, const substitute_internal::Arg& a0,
317      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
318      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
319      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
320      const substitute_internal::Arg& a7)
321      ABSL_BAD_CALL_IF(
322          substitute_internal::PlaceholderBitmask(format) != 255,
323          "There were 8 substitution arguments given, but "
324          "this format string is missing its $0-$7, contains one of "
325          "$8-$9, or contains an unescaped $ character (use $$ instead)");
326  void SubstituteAndAppend(
327      std::string* output, const char* format, const substitute_internal::Arg& a0,
328      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
329      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
330      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
331      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8)
332      ABSL_BAD_CALL_IF(
333          substitute_internal::PlaceholderBitmask(format) != 511,
334          "There were 9 substitution arguments given, but "
335          "this format string is missing its $0-$8, contains a $9, or "
336          "contains an unescaped $ character (use $$ instead)");
337  void SubstituteAndAppend(
338      std::string* output, const char* format, const substitute_internal::Arg& a0,
339      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
340      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
341      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
342      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
343      const substitute_internal::Arg& a9)
344      ABSL_BAD_CALL_IF(
345          substitute_internal::PlaceholderBitmask(format) != 1023,
346          "There were 10 substitution arguments given, but this "
347          "format string either doesn't contain all of $0 through $9 or "
348          "contains an unescaped $ character (use $$ instead)");
349  #endif  
350  ABSL_MUST_USE_RESULT inline std::string Substitute(absl::string_view format) {
351    std::string result;
352    SubstituteAndAppend(&result, format);
353    return result;
354  }
355  ABSL_MUST_USE_RESULT inline std::string Substitute(
356      absl::string_view format, const substitute_internal::Arg& a0) {
357    std::string result;
358    SubstituteAndAppend(&result, format, a0);
359    return result;
360  }
361  ABSL_MUST_USE_RESULT inline std::string Substitute(
362      absl::string_view format, const substitute_internal::Arg& a0,
363      const substitute_internal::Arg& a1) {
364    std::string result;
365    SubstituteAndAppend(&result, format, a0, a1);
366    return result;
367  }
368  ABSL_MUST_USE_RESULT inline std::string Substitute(
369      absl::string_view format, const substitute_internal::Arg& a0,
370      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2) {
371    std::string result;
372    SubstituteAndAppend(&result, format, a0, a1, a2);
373    return result;
374  }
375  ABSL_MUST_USE_RESULT inline std::string Substitute(
376      absl::string_view format, const substitute_internal::Arg& a0,
377      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
378      const substitute_internal::Arg& a3) {
379    std::string result;
380    SubstituteAndAppend(&result, format, a0, a1, a2, a3);
381    return result;
382  }
383  ABSL_MUST_USE_RESULT inline std::string Substitute(
384      absl::string_view format, const substitute_internal::Arg& a0,
385      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
386      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4) {
387    std::string result;
388    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4);
389    return result;
390  }
391  ABSL_MUST_USE_RESULT inline std::string Substitute(
392      absl::string_view format, const substitute_internal::Arg& a0,
393      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
394      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
395      const substitute_internal::Arg& a5) {
396    std::string result;
397    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5);
398    return result;
399  }
400  ABSL_MUST_USE_RESULT inline std::string Substitute(
401      absl::string_view format, const substitute_internal::Arg& a0,
402      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
403      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
404      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6) {
405    std::string result;
406    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6);
407    return result;
408  }
409  ABSL_MUST_USE_RESULT inline std::string Substitute(
410      absl::string_view format, const substitute_internal::Arg& a0,
411      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
412      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
413      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
414      const substitute_internal::Arg& a7) {
415    std::string result;
416    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7);
417    return result;
418  }
419  ABSL_MUST_USE_RESULT inline std::string Substitute(
420      absl::string_view format, const substitute_internal::Arg& a0,
421      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
422      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
423      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
424      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8) {
425    std::string result;
426    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7, a8);
427    return result;
428  }
429  ABSL_MUST_USE_RESULT inline std::string Substitute(
430      absl::string_view format, const substitute_internal::Arg& a0,
431      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
432      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
433      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
434      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
435      const substitute_internal::Arg& a9) {
436    std::string result;
437    SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
438    return result;
439  }
440  #if defined(ABSL_BAD_CALL_IF)
441  std::string Substitute(const char* format)
442      ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 0,
443                       "There were no substitution arguments "
444                       "but this format string either has a $[0-9] in it or "
445                       "contains an unescaped $ character (use $$ instead)");
446  std::string Substitute(const char* format, const substitute_internal::Arg& a0)
447      ABSL_BAD_CALL_IF(
448          substitute_internal::PlaceholderBitmask(format) != 1,
449          "There was 1 substitution argument given, but "
450          "this format string is missing its $0, contains one of $1-$9, "
451          "or contains an unescaped $ character (use $$ instead)");
452  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
453                         const substitute_internal::Arg& a1)
454      ABSL_BAD_CALL_IF(
455          substitute_internal::PlaceholderBitmask(format) != 3,
456          "There were 2 substitution arguments given, but "
457          "this format string is missing its $0/$1, contains one of "
458          "$2-$9, or contains an unescaped $ character (use $$ instead)");
459  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
460                         const substitute_internal::Arg& a1,
461                         const substitute_internal::Arg& a2)
462      ABSL_BAD_CALL_IF(
463          substitute_internal::PlaceholderBitmask(format) != 7,
464          "There were 3 substitution arguments given, but "
465          "this format string is missing its $0/$1/$2, contains one of "
466          "$3-$9, or contains an unescaped $ character (use $$ instead)");
467  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
468                         const substitute_internal::Arg& a1,
469                         const substitute_internal::Arg& a2,
470                         const substitute_internal::Arg& a3)
471      ABSL_BAD_CALL_IF(
472          substitute_internal::PlaceholderBitmask(format) != 15,
473          "There were 4 substitution arguments given, but "
474          "this format string is missing its $0-$3, contains one of "
475          "$4-$9, or contains an unescaped $ character (use $$ instead)");
476  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
477                         const substitute_internal::Arg& a1,
478                         const substitute_internal::Arg& a2,
479                         const substitute_internal::Arg& a3,
480                         const substitute_internal::Arg& a4)
481      ABSL_BAD_CALL_IF(
482          substitute_internal::PlaceholderBitmask(format) != 31,
483          "There were 5 substitution arguments given, but "
484          "this format string is missing its $0-$4, contains one of "
485          "$5-$9, or contains an unescaped $ character (use $$ instead)");
486  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
487                         const substitute_internal::Arg& a1,
488                         const substitute_internal::Arg& a2,
489                         const substitute_internal::Arg& a3,
490                         const substitute_internal::Arg& a4,
491                         const substitute_internal::Arg& a5)
492      ABSL_BAD_CALL_IF(
493          substitute_internal::PlaceholderBitmask(format) != 63,
494          "There were 6 substitution arguments given, but "
495          "this format string is missing its $0-$5, contains one of "
496          "$6-$9, or contains an unescaped $ character (use $$ instead)");
497  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
498                         const substitute_internal::Arg& a1,
499                         const substitute_internal::Arg& a2,
500                         const substitute_internal::Arg& a3,
501                         const substitute_internal::Arg& a4,
502                         const substitute_internal::Arg& a5,
503                         const substitute_internal::Arg& a6)
504      ABSL_BAD_CALL_IF(
505          substitute_internal::PlaceholderBitmask(format) != 127,
506          "There were 7 substitution arguments given, but "
507          "this format string is missing its $0-$6, contains one of "
508          "$7-$9, or contains an unescaped $ character (use $$ instead)");
509  std::string Substitute(const char* format, const substitute_internal::Arg& a0,
510                         const substitute_internal::Arg& a1,
511                         const substitute_internal::Arg& a2,
512                         const substitute_internal::Arg& a3,
513                         const substitute_internal::Arg& a4,
514                         const substitute_internal::Arg& a5,
515                         const substitute_internal::Arg& a6,
516                         const substitute_internal::Arg& a7)
517      ABSL_BAD_CALL_IF(
518          substitute_internal::PlaceholderBitmask(format) != 255,
519          "There were 8 substitution arguments given, but "
520          "this format string is missing its $0-$7, contains one of "
521          "$8-$9, or contains an unescaped $ character (use $$ instead)");
522  std::string Substitute(
523      const char* format, const substitute_internal::Arg& a0,
524      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
525      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
526      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
527      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8)
528      ABSL_BAD_CALL_IF(
529          substitute_internal::PlaceholderBitmask(format) != 511,
530          "There were 9 substitution arguments given, but "
531          "this format string is missing its $0-$8, contains a $9, or "
532          "contains an unescaped $ character (use $$ instead)");
533  std::string Substitute(
534      const char* format, const substitute_internal::Arg& a0,
535      const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
536      const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
537      const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
538      const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
539      const substitute_internal::Arg& a9)
540      ABSL_BAD_CALL_IF(
541          substitute_internal::PlaceholderBitmask(format) != 1023,
542          "There were 10 substitution arguments given, but this "
543          "format string either doesn't contain all of $0 through $9 or "
544          "contains an unescaped $ character (use $$ instead)");
545  #endif  
546  ABSL_NAMESPACE_END
547  }  
548  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.h</h3>
            <pre><code>1  #ifndef TESSERACT_TEXTORD_COLPARTITION_H_
2  #define TESSERACT_TEXTORD_COLPARTITION_H_
3  #include "bbgrid.h"
4  #include "blobbox.h" 
5  #include "ocrblock.h"
6  #include "rect.h" 
7  #include "scrollview.h"
8  #include "tabfind.h"   
9  #include "tabvector.h" 
10  #include <algorithm>
11  namespace tesseract {
12  const int kRGBRMSColors = 4;
13  class ColPartition;
14  class ColPartitionSet;
15  class ColPartitionGrid;
16  class WorkingPartSet;
17  class WorkingPartSet_LIST;
18  enum ColumnSpanningType {
19    CST_NOISE,   
20    CST_FLOWING, 
21    CST_HEADING, 
22    CST_PULLOUT, 
23    CST_COUNT    
24  };
25  ELIST2IZEH(ColPartition)
26  CLISTIZEH(ColPartition)
27  class TESS_API ColPartition : public ELIST2_LINK {
28  public:
29    ColPartition() = default;
30    ColPartition(BlobRegionType blob_type, const ICOORD &vertical);
31    static ColPartition *MakeLinePartition(BlobRegionType blob_type,
32                                           const ICOORD &vertical, int left,
33                                           int bottom, int right, int top);
34    static ColPartition *FakePartition(const TBOX &box, PolyBlockType block_type,
35                                       BlobRegionType blob_type,
36                                       BlobTextFlowType flow);
37    static ColPartition *MakeBigPartition(BLOBNBOX *box,
38                                          ColPartition_LIST *big_part_list);
39    ~ColPartition();
40    const TBOX &bounding_box() const {
41      return bounding_box_;
42    }
43    int left_margin() const {
44      return left_margin_;
45    }
46    void set_left_margin(int margin) {
47      left_margin_ = margin;
48    }
49    int right_margin() const {
50      return right_margin_;
51    }
52    void set_right_margin(int margin) {
53      right_margin_ = margin;
54    }
55    int median_top() const {
56      return median_top_;
57    }
58    int median_bottom() const {
59      return median_bottom_;
60    }
61    int median_left() const {
62      return median_left_;
63    }
64    int median_right() const {
65      return median_right_;
66    }
67    int median_height() const {
68      return median_height_;
69    }
70    void set_median_height(int height) {
71      median_height_ = height;
72    }
73    int median_width() const {
74      return median_width_;
75    }
76    void set_median_width(int width) {
77      median_width_ = width;
78    }
79    BlobRegionType blob_type() const {
80      return blob_type_;
81    }
82    void set_blob_type(BlobRegionType t) {
83      blob_type_ = t;
84    }
85    BlobTextFlowType flow() const {
86      return flow_;
87    }
88    void set_flow(BlobTextFlowType f) {
89      flow_ = f;
90    }
91    int good_blob_score() const {
92      return good_blob_score_;
93    }
94    bool good_width() const {
95      return good_width_;
96    }
97    bool good_column() const {
98      return good_column_;
99    }
100    bool left_key_tab() const {
101      return left_key_tab_;
102    }
103    int left_key() const {
104      return left_key_;
105    }
106    bool right_key_tab() const {
107      return right_key_tab_;
108    }
109    int right_key() const {
110      return right_key_;
111    }
112    PolyBlockType type() const {
113      return type_;
114    }
115    void set_type(PolyBlockType t) {
116      type_ = t;
117    }
118    BLOBNBOX_CLIST *boxes() {
119      return &boxes_;
120    }
121    int boxes_count() const {
122      return boxes_.length();
123    }
124    void set_vertical(const ICOORD &v) {
125      vertical_ = v;
126    }
127    ColPartition_CLIST *upper_partners() {
128      return &upper_partners_;
129    }
130    ColPartition_CLIST *lower_partners() {
131      return &lower_partners_;
132    }
133    void set_working_set(WorkingPartSet *working_set) {
134      working_set_ = working_set;
135    }
136    bool block_owned() const {
137      return block_owned_;
138    }
139    void set_block_owned(bool owned) {
140      block_owned_ = owned;
141    }
142    bool desperately_merged() const {
143      return desperately_merged_;
144    }
145    ColPartitionSet *column_set() const {
146      return column_set_;
147    }
148    void set_side_step(int step) {
149      side_step_ = step;
150    }
151    int bottom_spacing() const {
152      return bottom_spacing_;
153    }
154    void set_bottom_spacing(int spacing) {
155      bottom_spacing_ = spacing;
156    }
157    int top_spacing() const {
158      return top_spacing_;
159    }
160    void set_top_spacing(int spacing) {
161      top_spacing_ = spacing;
162    }
163    void set_table_type() {
164      if (type_ != PT_TABLE) {
165        type_before_table_ = type_;
166        type_ = PT_TABLE;
167      }
168    }
169    void clear_table_type() {
170      if (type_ == PT_TABLE) {
171        type_ = type_before_table_;
172      }
173    }
174    bool inside_table_column() {
175      return inside_table_column_;
176    }
177    void set_inside_table_column(bool val) {
178      inside_table_column_ = val;
179    }
180    ColPartition *nearest_neighbor_above() const {
181      return nearest_neighbor_above_;
182    }
183    void set_nearest_neighbor_above(ColPartition *part) {
184      nearest_neighbor_above_ = part;
185    }
186    ColPartition *nearest_neighbor_below() const {
187      return nearest_neighbor_below_;
188    }
189    void set_nearest_neighbor_below(ColPartition *part) {
190      nearest_neighbor_below_ = part;
191    }
192    int space_above() const {
193      return space_above_;
194    }
195    void set_space_above(int space) {
196      space_above_ = space;
197    }
198    int space_below() const {
199      return space_below_;
200    }
201    void set_space_below(int space) {
202      space_below_ = space;
203    }
204    int space_to_left() const {
205      return space_to_left_;
206    }
207    void set_space_to_left(int space) {
208      space_to_left_ = space;
209    }
210    int space_to_right() const {
211      return space_to_right_;
212    }
213    void set_space_to_right(int space) {
214      space_to_right_ = space;
215    }
216    uint8_t *color1() {
217      return color1_;
218    }
219    uint8_t *color2() {
220      return color2_;
221    }
222    bool owns_blobs() const {
223      return owns_blobs_;
224    }
225    void set_owns_blobs(bool owns_blobs) {
226      ASSERT_HOST(boxes_.empty());
227      owns_blobs_ = owns_blobs;
228    }
229    int MidY() const {
230      return (bounding_box_.top() + bounding_box_.bottom()) / 2;
231    }
232    int MedianY() const {
233      return (median_top_ + median_bottom_) / 2;
234    }
235    int MidX() const {
236      return (bounding_box_.left() + bounding_box_.right()) / 2;
237    }
238    int SortKey(int x, int y) const {
239      return TabVector::SortKey(vertical_, x, y);
240    }
241    int XAtY(int sort_key, int y) const {
242      return TabVector::XAtY(vertical_, sort_key, y);
243    }
244    int KeyWidth(int left_key, int right_key) const {
245      return (right_key - left_key) / vertical_.y();
246    }
247    int ColumnWidth() const {
248      return KeyWidth(left_key_, right_key_);
249    }
250    int BoxLeftKey() const {
251      return SortKey(bounding_box_.left(), MidY());
252    }
253    int BoxRightKey() const {
254      return SortKey(bounding_box_.right(), MidY());
255    }
256    int LeftAtY(int y) const {
257      return XAtY(left_key_, y);
258    }
259    int RightAtY(int y) const {
260      return XAtY(right_key_, y);
261    }
262    bool IsLeftOf(const ColPartition &other) const {
263      return bounding_box_.right() < other.bounding_box_.right();
264    }
265    bool ColumnContains(int x, int y) const {
266      return LeftAtY(y) - 1 <= x && x <= RightAtY(y) + 1;
267    }
268    bool IsEmpty() const {
269      return boxes_.empty();
270    }
271    bool IsSingleton() const {
272      return boxes_.singleton();
273    }
274    bool HOverlaps(const ColPartition &other) const {
275      return bounding_box_.x_overlap(other.bounding_box_);
276    }
277    bool VOverlaps(const ColPartition &other) const {
278      return bounding_box_.y_gap(other.bounding_box_) < 0;
279    }
280    int VCoreOverlap(const ColPartition &other) const {
281      if (median_bottom_ == INT32_MAX || other.median_bottom_ == INT32_MAX) {
282        return 0;
283      }
284      return std::min(median_top_, other.median_top_) -
285             std::max(median_bottom_, other.median_bottom_);
286    }
287    int HCoreOverlap(const ColPartition &other) const {
288      return std::min(median_right_, other.median_right_) -
289             std::max(median_left_, other.median_left_);
290    }
291    bool VSignificantCoreOverlap(const ColPartition &other) const {
292      if (median_bottom_ == INT32_MAX || other.median_bottom_ == INT32_MAX) {
293        return false;
294      }
295      int overlap = VCoreOverlap(other);
296      int height = std::min(median_top_ - median_bottom_,
297                            other.median_top_ - other.median_bottom_);
298      return overlap * 3 > height;
299    }
300    bool WithinSameMargins(const ColPartition &other) const {
301      return left_margin_ <= other.bounding_box_.left() &&
302             bounding_box_.left() >= other.left_margin_ &&
303             bounding_box_.right() <= other.right_margin_ &&
304             right_margin_ >= other.bounding_box_.right();
305    }
306    bool TypesMatch(const ColPartition &other) const {
307      return TypesMatch(blob_type_, other.blob_type_);
308    }
309    static bool TypesMatch(BlobRegionType type1, BlobRegionType type2) {
310      return (type1 == type2 || type1 == BRT_UNKNOWN || type2 == BRT_UNKNOWN) &&
311             !BLOBNBOX::IsLineType(type1) && !BLOBNBOX::IsLineType(type2);
312    }
313    static bool TypesSimilar(PolyBlockType type1, PolyBlockType type2) {
314      return (type1 == type2 ||
315              (type1 == PT_FLOWING_TEXT && type2 == PT_INLINE_EQUATION) ||
316              (type2 == PT_FLOWING_TEXT && type1 == PT_INLINE_EQUATION));
317    }
318    bool IsLineType() const {
319      return PTIsLineType(type_);
320    }
321    bool IsImageType() const {
322      return PTIsImageType(type_);
323    }
324    bool IsTextType() const {
325      return PTIsTextType(type_);
326    }
327    bool IsPulloutType() const {
328      return PTIsPulloutType(type_);
329    }
330    bool IsVerticalType() const {
331      return blob_type_ == BRT_VERT_TEXT || blob_type_ == BRT_VLINE;
332    }
333    bool IsHorizontalType() const {
334      return blob_type_ == BRT_TEXT || blob_type_ == BRT_HLINE;
335    }
336    bool IsUnMergeableType() const {
337      return BLOBNBOX::UnMergeableType(blob_type_) || type_ == PT_NOISE;
338    }
339    bool IsVerticalLine() const {
340      return IsVerticalType() && IsLineType();
341    }
342    bool IsHorizontalLine() const {
343      return IsHorizontalType() && IsLineType();
344    }
345    void AddBox(BLOBNBOX *box);
346    void RemoveBox(BLOBNBOX *box);
347    BLOBNBOX *BiggestBox();
348    TBOX BoundsWithoutBox(BLOBNBOX *box);
349    void ClaimBoxes();
350    void DisownBoxes();
351    void DisownBoxesNoAssert();
352    bool ReleaseNonLeaderBoxes();
353    void DeleteBoxes();
354    void ReflectInYAxis();
355    bool IsLegal();
356    bool MatchingColumns(const ColPartition &other) const;
357    bool MatchingTextColor(const ColPartition &other) const;
358    bool MatchingSizes(const ColPartition &other) const;
359    bool ConfirmNoTabViolation(const ColPartition &other) const;
360    bool MatchingStrokeWidth(const ColPartition &other,
361                             double fractional_tolerance,
362                             double constant_tolerance) const;
363    bool OKDiacriticMerge(const ColPartition &candidate, bool debug) const;
364    void SetLeftTab(const TabVector *tab_vector);
365    void SetRightTab(const TabVector *tab_vector);
366    void CopyLeftTab(const ColPartition &src, bool take_box);
367    void CopyRightTab(const ColPartition &src, bool take_box);
<span onclick='openModal()' class='match'>368    int LeftBlobRule() const;
369    int RightBlobRule() const;
370    float SpecialBlobsDensity(const BlobSpecialTextType type) const;
371    int SpecialBlobsCount(const BlobSpecialTextType type);
372    void SetSpecialBlobsDensity(const BlobSpecialTextType type,
373                                const float density);
374    void ComputeSpecialBlobsDensity();
375    void AddPartner(bool upper, ColPartition *partner);
376    void RemovePartner(bool upper, ColPartition *partner);
377    ColPartition *SingletonPartner(bool upper);
378    void Absorb(ColPartition *other, const WidthCallback &cb);
379    bool OKMergeOverlap(const ColPartition &merge1, const ColPartition &merge2,
</span>380                        int ok_box_overlap, bool debug);
381    BLOBNBOX *OverlapSplitBlob(const TBOX &box);
382    ColPartition *SplitAtBlob(BLOBNBOX *split_blob);
383    ColPartition *SplitAt(int split_x);
384    void ComputeLimits();
385    int CountOverlappingBoxes(const TBOX &box);
386    void SetPartitionType(int resolution, ColPartitionSet *columns);
387    PolyBlockType PartitionType(ColumnSpanningType flow) const;
388    void ColumnRange(int resolution, ColPartitionSet *columns, int *first_col,
389                     int *last_col);
390    void SetColumnGoodness(const WidthCallback &cb);
391    bool MarkAsLeaderIfMonospaced();
392    void SetRegionAndFlowTypesFromProjectionValue(int value);
393    void SetBlobTypes();
394    bool HasGoodBaseline();
395    void AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
396                         int resolution, ColPartition_LIST *used_parts,
397                         WorkingPartSet_LIST *working_set);
398    static void LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
399                                  int resolution, ColPartition_LIST *block_parts,
400                                  ColPartition_LIST *used_parts,
401                                  BLOCK_LIST *completed_blocks,
402                                  TO_BLOCK_LIST *to_blocks);
403    static TO_BLOCK *MakeBlock(const ICOORD &bleft, const ICOORD &tright,
404                               ColPartition_LIST *block_parts,
405                               ColPartition_LIST *used_parts);
406    static TO_BLOCK *MakeVerticalTextBlock(const ICOORD &bleft,
407                                           const ICOORD &tright,
408                                           ColPartition_LIST *block_parts,
409                                           ColPartition_LIST *used_parts);
410    TO_ROW *MakeToRow();
411    ColPartition *ShallowCopy() const;
412    ColPartition *CopyButDontOwnBlobs();
413  #ifndef GRAPHICS_DISABLED
414    ScrollView::Color BoxColor() const;
415  #endif 
416    void Print() const;
417    void PrintColors();
418    void SmoothPartnerRun(int working_set_count);
419    void RefinePartners(PolyBlockType type, bool get_desperate,
420                        ColPartitionGrid *grid);
421    bool IsInSameColumnAs(const ColPartition &part) const;
422    static int SortByBBox(const void *p1, const void *p2) {
423      const ColPartition *part1 = *static_cast<const ColPartition *const *>(p1);
424      const ColPartition *part2 = *static_cast<const ColPartition *const *>(p2);
425      int mid_y1 = part1->bounding_box_.y_middle();
426      int mid_y2 = part2->bounding_box_.y_middle();
427      if ((part2->bounding_box_.bottom() <= mid_y1 &&
428           mid_y1 <= part2->bounding_box_.top()) ||
429          (part1->bounding_box_.bottom() <= mid_y2 &&
430           mid_y2 <= part1->bounding_box_.top())) {
431        return part1->bounding_box_.x_middle() - part2->bounding_box_.x_middle();
432      }
433      return mid_y2 - mid_y1;
434    }
435    void set_first_column(int column) {
436      first_column_ = column;
437    }
438    void set_last_column(int column) {
439      last_column_ = column;
440    }
441  private:
442    void RefinePartnersInternal(bool upper, bool get_desperate,
443                                ColPartitionGrid *grid);
444    void RefinePartnersByType(bool upper, ColPartition_CLIST *partners);
445    void RefinePartnerShortcuts(bool upper, ColPartition_CLIST *partners);
446    void RefineTextPartnersByMerge(bool upper, bool desperate,
447                                   ColPartition_CLIST *partners,
448                                   ColPartitionGrid *grid);
449    void RefinePartnersByOverlap(bool upper, ColPartition_CLIST *partners);
450    bool ThisPartitionBetter(BLOBNBOX *bbox, const ColPartition &other);
451    static void SmoothSpacings(int resolution, int page_height,
452                               ColPartition_LIST *parts);
453    static bool OKSpacingBlip(int resolution, int median_spacing,
454                              ColPartition **parts, int offset);
455    bool SpacingEqual(int spacing, int resolution) const;
456    bool SpacingsEqual(const ColPartition &other, int resolution) const;
457    bool SummedSpacingOK(const ColPartition &other, int spacing,
458                         int resolution) const;
459    int BottomSpacingMargin(int resolution) const;
460    int TopSpacingMargin(int resolution) const;
461    bool SizesSimilar(const ColPartition &other) const;
462    static void LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start, ICOORD *end);
463    static void RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
464                             ICOORD *end);
465    int left_margin_ = 0;
466    int right_margin_ = 0;
467    TBOX bounding_box_;
468    int median_bottom_ = 0;
469    int median_top_ = 0;
470    int median_height_ = 0;
471    int median_left_ = 0;
472    int median_right_ = 0;
473    int median_width_ = 0;
474    BlobRegionType blob_type_ = BRT_UNKNOWN;
475    BlobTextFlowType flow_ = BTFT_NONE; 
476    int good_blob_score_ = 0;
477    bool good_width_ = false;
478    bool good_column_ = false;
479    bool left_key_tab_ = false;
480    bool right_key_tab_ = false;
481    int left_key_ = 0;
482    int right_key_ = 0;
483    PolyBlockType type_ = PT_UNKNOWN;
484    ICOORD vertical_;
485    BLOBNBOX_CLIST boxes_;
486    ColPartition_CLIST upper_partners_;
487    ColPartition_CLIST lower_partners_;
488    WorkingPartSet *working_set_ = nullptr;
489    ColPartitionSet *column_set_ = nullptr;
490    bool last_add_was_vertical_ = false;
491    bool block_owned_ = false;
492    bool desperately_merged_ = false;
493    bool owns_blobs_ = true; 
494    int first_column_ = -1;
495    int last_column_ = -1;
496    int side_step_ = 0;      
497    int top_spacing_ = 0;    
498    int bottom_spacing_ = 0; 
499    ColPartition *nearest_neighbor_above_ = nullptr;
500    ColPartition *nearest_neighbor_below_ = nullptr;
501    int space_above_ = 0;    
502    int space_below_ = 0;    
503    int space_to_left_ = 0;  
504    int space_to_right_ = 0; 
505    uint8_t color1_[kRGBRMSColors];
506    uint8_t color2_[kRGBRMSColors];
507    float special_blobs_densities_[BSTT_COUNT];
508    PolyBlockType type_before_table_ = PT_UNKNOWN;
509    bool inside_table_column_ = false;
510  };
511  using ColPartitionGridSearch =
512      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT>;
513  } 
514  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-substitute.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.h</div>
                <div class="column column_space"><pre><code>242  void SubstituteAndAppend(std::string* output, const char* format)
243      ABSL_BAD_CALL_IF(
244          substitute_internal::PlaceholderBitmask(format) != 0,
245          "There were no substitution arguments "
246          "but this format string either has a $[0-9] in it or contains "
247          "an unescaped $ character (use $$ instead)");
248  void SubstituteAndAppend(std::string* output, const char* format,
249                           const substitute_internal::Arg& a0)
250      ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1,
251                       "There was 1 substitution argument given, but "
252                       "this format string is missing its $0, contains "
253                       "one of $1-$9, or contains an unescaped $ character (use "
254                       "$$ instead)");
255  void SubstituteAndAppend(std::string* output, const char* format,
256                           const substitute_internal::Arg& a0,
257                           const substitute_internal::Arg& a1)
258      ABSL_BAD_CALL_IF(
259          substitute_internal::PlaceholderBitmask(format) != 3,
260          "There were 2 substitution arguments given, but this format string is "
261          "missing its $0/$1, contains one of $2-$9, or contains an "
262          "unescaped $ character (use $$ instead)");
263  void SubstituteAndAppend(std::string* output, const char* format,
264                           const substitute_internal::Arg& a0,
265                           const substitute_internal::Arg& a1,
266                           const substitute_internal::Arg& a2)
</pre></code></div>
                <div class="column column_space"><pre><code>368    int LeftBlobRule() const;
369    int RightBlobRule() const;
370    float SpecialBlobsDensity(const BlobSpecialTextType type) const;
371    int SpecialBlobsCount(const BlobSpecialTextType type);
372    void SetSpecialBlobsDensity(const BlobSpecialTextType type,
373                                const float density);
374    void ComputeSpecialBlobsDensity();
375    void AddPartner(bool upper, ColPartition *partner);
376    void RemovePartner(bool upper, ColPartition *partner);
377    ColPartition *SingletonPartner(bool upper);
378    void Absorb(ColPartition *other, const WidthCallback &cb);
379    bool OKMergeOverlap(const ColPartition &merge1, const ColPartition &merge2,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    