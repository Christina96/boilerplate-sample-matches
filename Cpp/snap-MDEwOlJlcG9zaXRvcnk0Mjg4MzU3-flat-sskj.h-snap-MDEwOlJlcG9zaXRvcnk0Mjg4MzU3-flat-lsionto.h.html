
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.104408352668213%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sskj.h</h3>
            <pre><code>1  #ifndef sskj_h
2  #define sskj_h
3  #include "base.h"
4  typedef enum {
5    hlctSpace, hlctAlpha, hlctNum, hlctSym,
6    hlctLTag, hlctRTag, hlctEof} TSskjLxChTy;
7  class TSskjLxChDef{
8  private:
9    TIntV ChTyV;
10    TChV UcChV;
11    TStrStrH EscStrH;
12    void SetUcCh(const TStr& Str);
13    void SetChTy(const TSskjLxChTy& ChTy, const TStr& Str);
14    void SetEscStr(const TStr& SrcStr, const TStr& DstStr);
15  public:
16    TSskjLxChDef();
17    TSskjLxChDef& operator=(const TSskjLxChDef&){Fail; return *this;}
<span onclick='openModal()' class='match'>18    int GetChTy(const char& Ch){return ChTyV[Ch-TCh::Mn];}
19    bool IsEoln(const char& Ch){return (Ch==CrCh)||(Ch==LfCh);}
</span>20    bool IsWs(const char& Ch){
21      return (Ch==' ')||(Ch==TabCh)||(Ch==CrCh)||(Ch==LfCh);}
22    bool IsSpace(const char& Ch){return ChTyV[Ch-TCh::Mn]==hlctSpace;}
23    bool IsAlpha(const char& Ch){return ChTyV[Ch-TCh::Mn]==hlctAlpha;}
24    bool IsNum(const char& Ch){return ChTyV[Ch-TCh::Mn]==hlctNum;}
25    bool IsAlNum(const char& Ch){
26      return (ChTyV[Ch-TCh::Mn]==hlctAlpha)||(ChTyV[Ch-TCh::Mn]==hlctNum);}
27    bool IsSym(const char& Ch){return ChTyV[Ch-TCh::Mn]==hlctSym;}
28    char GetUc(const char& Ch){return UcChV[Ch-TCh::Mn];}
29    TStr GetEscStr(const TStr& Str);
30  };
31  typedef enum {
32    hlsyUndef, hlsyStr, hlsyNum, hlsySSym,
33    hlsyTag, hlsyEof} TSskjLxSym;
34  class TSskjLx{
35  private:
36    static TSskjLxChDef ChDef;
37    PSIn SIn;
38    TChA ChStack;
39    char Ch;
40    void PutCh(const char& _Ch){ChStack.Push(Ch); Ch=_Ch;}
41    void PutStr(const TStr& Str){
42      for (int ChN=Str.Len()-1; ChN>=0; ChN--){PutCh(Str[ChN]);}}
43    void GetCh();
44  public:
45    TSskjLxSym Sym;
46    TChA Str;
47    TChA UcStr;
48  public:
49    TSskjLx(const PSIn& _SIn):
50      SIn(_SIn), ChStack(), Ch(' '),
51      Sym(hlsyUndef), Str(), UcStr(){}
52    TSskjLx& operator=(const TSskjLx&){Fail; return *this;}
53    TSskjLxSym GetSym();
54  };
55  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</h3>
            <pre><code>1  #ifndef LSIONTO_H
2  #define LSIONTO_H
3  #include "mine.h"
4  #include "graph.h"
5  ClassTPV(TOntoConcept, POntoConcept, TOntoConceptV) 
6  private:
7      TInt Id;
8      TStr CptNm;
9      TIntV DIdV;
10      TBool IsValid;
11      PBowSpV ConceptSpV;
12      PBowSpV SvmKeyWdSpV;
13      TIntFltKdV MedoidDIdWgtV;
14      PSVMModel CptMd;
15      TFlt Compactness;
16      TFlt Clarity;
17  private:
18      void GenMedoid(PBowDocWgtBs BowDocWgtBs);
19      UndefCopyAssign(TOntoConcept);
20  public:
21      TOntoConcept(): Id(-1), CptNm("New Concept") { }
22      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
23          const int _Id, const TIntV& _DIdV);
24      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
25          const int _Id, const TIntV& _DIdV) { 
26              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _DIdV); }
27      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
28          const int _Id, const TStr& _CptNm, const TIntV& _DIdV);
29      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
30          const int _Id, const TStr& _CptNm, const TIntV& _DIdV) { 
31              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _CptNm, _DIdV); }
32      int GetId() const { return Id; }
33      TStr GetName() const { return CptNm; }
34      void SetName(const TStr& NewCptNm) { CptNm = NewCptNm; }
35      bool IsCentroidValid() const { return IsValid; }
36      PBowSpV GetCentroidSpV() const { return ConceptSpV; }
37      void ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs);
38      PBowSpV GetSvmSpV() const { return SvmKeyWdSpV; }
39      void SetSvmSpV(PBowSpV NewSvmSpV) { SvmKeyWdSpV = NewSvmSpV; }
40      int GetDocs() const { return DIdV.Len(); }
41      int GetDId(const int& DIdN) const { return DIdV[DIdN]; }
42      void GetDIdV(TIntV& _DIdV) const { _DIdV=DIdV; }
43      TIntV& GetDIdVRef() { return DIdV; }
44      void SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV);
45      void AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
46      void AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
47      void DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
48      bool DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
49      TStr GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
50        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
51        const bool& ShowWeights = false, const bool& UseMedoidP = false) const;
52      TStr GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
53        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
54        const bool& ShowWeights = false) const;
55      void CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
56          const double& SvmC = 1.0, const double& SvmJ = 5.0, 
57          const int& SvmTime = -1);
58      bool IsCptMd() const { return !CptMd.Empty(); }
59      void CfyDocSpV(PBowSpV DocSpV, bool& IsDocInCpt, double& Prob) { 
60          IsDocInCpt = CptMd->GetCfyBool(DocSpV); Prob = CptMd->GetProbCfy(DocSpV); }
61      void SetCompactness(const double& NewVal) { Compactness = NewVal; }
62      double GetCompactness() const { return Compactness; }
63      void SetClarity(const double& NewVal) { Clarity = NewVal; }
64      double GetClarity() const { return Clarity; }
65  };
66  ClassTV(TOntoRltType, TOntoRltTypeV) 
67  private:
68      TStr TypeNm;
69      TBool Directed;
70      TBool Transitive;
71  public:
72      static TStr SubCptOfRltStr;
73      static TStr SimilarRltStr;
74  public:
75      TOntoRltType(): TypeNm("") {}
76      TOntoRltType(const TStr& _TypeNm, const bool& _Directed, const bool& _Transitive):
77          TypeNm(_TypeNm), Directed(_Directed), Transitive(_Transitive) { }
78      const TStr& GetName() const { return TypeNm; }
79      bool IsType(const TStr& RltTypeNm) const { return (RltTypeNm == TypeNm); }
80      bool IsDir() const { return Directed; }
81      bool IsTransitive() const { return Transitive; }
82  };
83  ClassTP(TUniqueId, PUniqueId)
84  private:
85      TInt IdCounter;
86  public:
87      TUniqueId(const int& StartId = 0): IdCounter(StartId) { };
88      static PUniqueId New(const int& StartId = 0) { return new TUniqueId(StartId); }
89      TUniqueId(TSIn& SIn): IdCounter(SIn) { }
90      static PUniqueId Load(TSIn &SIn) { return new TUniqueId(SIn); }
91      void Save(TSOut& SOut) const { IdCounter.Save(SOut); }
92      int GetNextId() { const int NextId = IdCounter; IdCounter++; return NextId; }
93  };
94  typedef enum { osatKMeans, osatCat, osatLwOntoCfier } TOntoSuggestAlgType;
95  class TOntoAlg {
96  public:
97      static void SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
98          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
99          TOntoConceptV& NewConceptV); 
100      static void SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
101          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV);
102      static void SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
103          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
104          PUniqueId UniqueId, TOntoConceptV& NewConceptV);
105  };
106  ClassTP(TOntoExport, POntoExport)
107  public:
108      virtual void StartExport() {};
109      virtual void EndExport() {};
110      virtual void PutCpt(const int& CptId, const TStr CptNm, 
111          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
112          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
113          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {};
114      virtual bool IsCptSubCptLink() { return false; }
115      virtual bool IsCptSuperCptLink() { return false; }
116      virtual bool IsCptDocLink() { return false; }
117      virtual bool IsCptAlwaysSvm() { return false; }
118      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
119          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {};
120      virtual bool IsDocCptLink() { return false; }
121      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
122          const bool& TransitiveP) {};
123      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
124          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {};
125      virtual bool IsRlt() { return false; }
126  };
127  class TOntoExportPTO: TOntoExport {
128  private:
129      PSOut SOut;
130      bool DigLibP; 
131      TStr BowFNmStr;
132      TStr GetUri(const int& Id, const TStr& Nm);
133  public:
134      TOntoExportPTO(PSOut _SOut, const bool& _DigLibP, const TStr& _BowFNmStr):
135          SOut(_SOut), DigLibP(_DigLibP), BowFNmStr(_BowFNmStr) { }
136      static POntoExport New(PSOut SOut, const bool& DigLibP, const TStr& BowFNmStr) { 
137          return new TOntoExportPTO(SOut, DigLibP, BowFNmStr); }
138      virtual void StartExport();
139      virtual void EndExport();
140      virtual void PutCpt(const int& CptId, const TStr CptNm, 
141          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
142          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
143          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
144      virtual bool IsCptSubCptLink() { return false; }
145      virtual bool IsCptSuperCptLink() { return true; }
146      virtual bool IsCptDocLink() { return DigLibP; }
147      virtual bool IsCptAlwaysSvm() { return false; }
148      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
149          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
150      virtual bool IsDocCptLink() { return true; }
151  };
152  class TOntoExportProlog: TOntoExport {
153  private:
154      PSOut SOut;
<span onclick='openModal()' class='match'>155      TStr GetCptLabel(const int& CptId) { return TStr::Fmt("c%d", CptId); }
156      TStr GetInstLabel(const int& InstId) { return TStr::Fmt("id%d", InstId); }
</span>157  public:
158      TOntoExportProlog(PSOut _SOut): SOut(_SOut) { }
159      static POntoExport New(PSOut SOut) { return new TOntoExportProlog(SOut); }
160      virtual void StartExport();
161      virtual void EndExport();
162      virtual void PutCpt(const int& CptId, const TStr CptNm, 
163          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
164          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
165          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
166      virtual bool IsCptSubCptLink() { return false; }
167      virtual bool IsCptSuperCptLink() { return true; }
168      virtual bool IsCptDocLink() { return false; }
169      virtual bool IsCptAlwaysSvm() { return false; }
170      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
171          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
172      virtual bool IsDocCptLink() { return true; }
173  };
174  class TOntoExportOWL: TOntoExport {
175  private:
176      PSOut SOut;
177      TBool StoreDocsP;
178      TBool StoreAbstractsP;
179      TStr GetUri(const int& Id, const TStr& Nm);
180  public:
181      TOntoExportOWL(PSOut _SOut, const bool& _StoreDocsP, const bool& _StoreAbstractsP): 
182        SOut(_SOut), StoreDocsP(_StoreDocsP), StoreAbstractsP(_StoreAbstractsP) { }
183      static POntoExport New(PSOut SOut, const bool& StoreDocsP, const bool& StoreAbstractsP) { 
184          return new TOntoExportOWL(SOut, StoreDocsP, StoreAbstractsP); }
185      virtual void StartExport();
186      virtual void EndExport();
187      virtual void PutCpt(const int& CptId, const TStr CptNm, 
188          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
189          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
190          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
191      virtual bool IsCptSubCptLink() { return false; }
192      virtual bool IsCptSuperCptLink() { return true; }
193      virtual bool IsCptDocLink() { return false; }
194      virtual bool IsCptAlwaysSvm() { return false; }
195      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
196          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
197      virtual bool IsDocCptLink() { return true; }
198      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
199          const bool& TransitiveP);
200      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
201          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm);
202      virtual bool IsRlt() { return true; }
203  };
204  ClassTP(TOntology, POntology)
205  private:
206      PBowDocBs BowDocBs;
207      PBowDocWgtBs BowDocWgtBs;
208      PBowSim BowSim;
209      TOntoConceptV ConceptV;
210      TOntoRltTypeV RltTypeV;
211      PGraph OntoGraph;
212      PUniqueId UniqueId;
213  private:
214      void GenerateEmptyOnto();
215      TIntH CptIdPosH;
216      void RefreshCptIdPosH();
217      void ReconnectToRoot();
218      void AddRltsFromList(TIntStrPrV& InRltV, 
219          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
220      void AddSonDIdV(const int& CptId, TIntV& SonDIdV);
221      void CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV);
222      void Export(POntoExport OntoExport);
223      UndefDefaultCopyAssign(TOntology);
224  public:
225      TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs,
226          const TBowSimType& BowSimType);
227      static POntology New(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
228          const TBowSimType& BowSimType) { 
229              return new TOntology(_BowDocBs, _BowDocWgtBs, BowSimType); }
230      PBowDocBs GetBowDocBs() const { return BowDocBs; }
231      PBowDocWgtBs GetBowDocWgtBs() const { return BowDocWgtBs; }
232      int GetConcepts() const { return ConceptV.Len(); }
233      int GetCptId(const int& CptIdN) const { return ConceptV[CptIdN]->GetId(); }
234      POntoConcept GetConcept(const int& CptId) const {
235          IAssertR(IsCptId(CptId), "There is no such concept!"); 
236          return ConceptV[CptIdPosH.GetDat(CptId)]; }
237      void GetCptIdV(TIntV& CptIdV);
238      bool IsCptId(const int& CptId) const { return CptIdPosH.IsKey(CptId); }
239      bool IsRootCpt(const int& CptId) const { return CptId == 0; }
240      POntoConcept GetRootCpt() const { return GetConcept(0); }
241      TStr GetCptName(const int& CptId) const { return GetConcept(CptId)->GetName(); }
242      void SetCptName(const int& CptId, const TStr& NewName);
243      int GetCptDocs(const int& CptId) const { return GetConcept(CptId)->GetDocs(); }
244      void GetCptDIdV(const int& CptId, TIntV& DIdV) const {
245          GetConcept(CptId)->GetDIdV(DIdV); }
246      void SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP);
247      TStr GetCptKeyWdStr(const int& CptId, const int WordN, const bool& UseMedoidP) const {
248          return GetConcept(CptId)->GetKeyWdStr(BowDocBs, WordN, 1.0, ", ", false, UseMedoidP); }
249      TStr GetCptSvmKeyWdStr(const int& CptId, const int WordN) const {
250          return GetConcept(CptId)->GetSvmKeyWdStr(BowDocBs, WordN); }
251      void GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV);
252      double GetCptCompactness(const int& CptId) const {
253          return GetConcept(CptId)->GetCompactness(); }
254      double GetCptClarity(const int& CptId) const {
255          return GetConcept(CptId)->GetClarity(); }
256      void CalcCptMd(const int& CptId, const double& SvmC, 
257          const double& SvmJ, const int& SvmTime);
258      void CfyDId(const int& DId, TIntFltKdV& CfyResV);
259      void IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV);
260      void IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP);
261      void AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP);
262      void ReCalcWgtBs() { BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF); }
263      void ResetAllCptKeyWd();
264      void GetSubCptIdV(const int& CptId, TIntV& SubCptIdV);
265      void GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV);
266      bool HasSuperCpt(const int& CptId) { TIntV SuperCptIdV; 
267          GetSuperCptIdV(CptId, SuperCptIdV); return (SuperCptIdV.Len() > 0); }
268      int GetCptUnusedDocs(const int& CptId) {
269          TIntV DIdV; GetCptUnusedDIdV(CptId, DIdV); return DIdV.Len(); }
270      void GetCptUnusedDIdV(const int& CptId, TIntV& UnusedDIdV);
271      void GetCptContextDIdV(const int& CptId, TIntV& ContextDIdV, 
272          const bool& AddSonDIdP = true);
273      void GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV);
274      void GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV);
275      void AddUpDIdV(const int& CptId, const TIntV& SubDIdV);
276      void DelUpDIdV(const int& CptId, const TIntV& SubDIdV);
277      void DelDownDIdV(const int& CptId, const TIntV& SubDIdV);
278      void DelDownDId(const int& CptId, const int& DId);
279      void GetCptInRltV(const int& CptId, TIntStrPrV& InRltV);
280      void GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV);
281      void GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV);
282      void GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
283          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
284      int GetRltTypes() const { return RltTypeV.Len(); }
285      int GetRltTypeN(const TStr& RltTypeNm) const;
286      bool IsRltType(const TStr& RltTypeNm) const { 
287          return GetRltTypeN(RltTypeNm) != -1; }
288      const TStr& GetRltTypeNm(const int& RltTypeN) const { 
289          return RltTypeV[RltTypeN].GetName(); }
290      bool IsRltDir(const TStr& RltTypeNm) const {
291          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
292          return RltTypeV[GetRltTypeN(RltTypeNm)].IsDir(); }
293      bool IsRltTransitive(const TStr& RltTypeNm) const  {
294          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
295          return RltTypeV[GetRltTypeN(RltTypeNm)].IsTransitive(); }
296      bool IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
297      void AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
298      bool DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
299      void SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType,
300          const int& NewConceptN, TOntoConceptV& NewConceptV);
301      void SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType,
302          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
303      void SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
304          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
305      POntoConcept GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV);
306      POntoConcept GenSubconcept(const TIntV& NewCptDIdV);
307      void SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
308          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV,
309          TIntV& SuggestVocNV);
310      void AddConcept(const POntoConcept& NewCpt, const int& FatherCptId);
311      void BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV);
312      void DeleteConcept(const int& CptId, const bool& DoRedirect);
313      void PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId); 
314      void UniteConcepts(const int& CptId1, const int& CptId2);
315      void CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP);
316      void NewConcept();
317      void ExtractKeywords(const int& CptId);
318      void CalcCptCompactness(const int& CptId);
319      void CalcCptClarity(const int& CptId);
320      PGraph GetGraph() const { return OntoGraph; }
321      void PrepareGraph(const int& SelectedCptId);
322      void PlaceGraph();
323      void SaveTxtStat(const TStr& FNm) { }
324      void ExportPTO(const TStr& FNm, const bool& DigLibP);
325      void ExportProlog(const TStr& FNm);
326      void ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP);
327      static POntology ImportPTO(const TStr& RdfFNm, const TStr& BowFNm);
328  };
329  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sskj.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</div>
                </div>
                <div class="column column_space"><pre><code>18    int GetChTy(const char& Ch){return ChTyV[Ch-TCh::Mn];}
19    bool IsEoln(const char& Ch){return (Ch==CrCh)||(Ch==LfCh);}
</pre></code></div>
                <div class="column column_space"><pre><code>155      TStr GetCptLabel(const int& CptId) { return TStr::Fmt("c%d", CptId); }
156      TStr GetInstLabel(const int& InstId) { return TStr::Fmt("id%d", InstId); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    