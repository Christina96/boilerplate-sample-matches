<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Section.cpp & Dimensions.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Section.cpp & Dimensions.cpp
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Section.cpp (4.971319%)<TH>Dimensions.cpp (1.9847329%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(267-275)<TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(172-182)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-1.html#1',3)" NAME="1">(23-39)<TD><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-1.html#1',3)" NAME="1">(33-49)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Section.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;nix/Section.hpp&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;nix/Block.hpp&gt;
#include &lt;nix/File.hpp&gt;
#include &lt;nix/DataArray.hpp&gt;
#include &lt;nix/util/util.hpp&gt;
using namespace nix;
<A NAME="1"></A>
Section::Section()
    : NamedEntity()
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1747-1.html#1',3,'match1747-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
}
Section::Section(std::nullptr_t ptr)
    : NamedEntity()
{
}
Section::Section(const Section &amp;other)
    : NamedEntity(other.impl())
{
}
Section::Section(const std::shared_ptr&lt;base::ISection&gt; &amp;p_impl)</B></FONT>
    : NamedEntity(p_impl)
{
}
Section::Section(std::shared_ptr&lt;base::ISection&gt; &amp;&amp;ptr)
    : NamedEntity(std::move(ptr))
{
}
void Section::link(const Section &amp;link) {
    if (!link) {
        backend()-&gt;link(none);
    } else {
        backend()-&gt;link(link.id());
    }
}
bool Section::hasSection(const Section &amp;section) const {
    if (!util::checkEntityInput(section, false)) {
        return false;
    }
    return backend()-&gt;hasSection(section.id());
}
bool Section::deleteSection(const Section &amp;section) {
    if (!util::checkEntityInput(section, false)) {
        return false;
    }
    return backend()-&gt;deleteSection(section.id());
}
std::vector&lt;Section&gt; Section::sections(const util::Filter&lt;Section&gt;::type &amp;filter) const {
    auto f = [this] (ndsize_t i) { return getSection(i); };
    return getEntities&lt;Section&gt;(f, sectionCount(), filter);
}
void addChildrenIfNotMaxDepth(std::tuple&lt;Section, size_t&gt;&amp; current,
                              std::list&lt;std::tuple&lt;Section, size_t&gt;&gt; &amp;todo,
                              size_t max_depth) {
    if (std::get&lt;1&gt;(current) &lt; max_depth) {
        size_t next_depth = std::get&lt;1&gt;(current) + 1;
        for (const auto &amp;s : std::get&lt;0&gt;(current).sections()) {
            todo.emplace_back(s, next_depth);
        }
    }
}
std::vector&lt;Section&gt; Section::findSections(const util::Filter&lt;Section&gt;::type &amp;filter,
                                           size_t max_depth) const {
    std::vector&lt;Section&gt; results;
    std::list&lt;std::tuple&lt;Section, size_t&gt;&gt; todo;
    std::tuple&lt;Section, size_t&gt; current = std::make_tuple(*this, 0);
    addChildrenIfNotMaxDepth(current, todo, max_depth);
    while (todo.size() &gt; 0) {
        current = todo.front();
        todo.pop_front();
        if (filter(std::get&lt;0&gt;(current))) {
            results.push_back(std::get&lt;0&gt;(current));
        }
        addChildrenIfNotMaxDepth(current, todo, max_depth);
    }
    return results;
}
static inline auto erase_section_with_id(std::vector&lt;Section&gt; &amp;sections, const std::string &amp;my_id)
    -&gt; decltype(sections.size())
{
    sections.erase(remove_if(sections.begin(),
                             sections.end(),
                             [&amp;my_id](const Section &amp;section) {
                                 return my_id == section.id();
                             }),
                   sections.end());
    return sections.size();
}
std::vector&lt;Section&gt; Section::findRelated(const util::Filter&lt;Section&gt;::type &amp;filter) const
{
    std::vector&lt;Section&gt; results = findDownstream(filter);
    const std::string &amp;my_id = id();
    auto results_size = erase_section_with_id(results, my_id);
    if (results_size == 0) {
        results = findAmongParents(filter);
    }
    results_size = erase_section_with_id(results, my_id);
    if (results_size == 0) {
        results = findSideways(filter, id());
    }
    return results;
}
bool Section::hasProperty(const Property &amp;property) const {
    if (property == none || !property.isValidEntity()) {
        return false;
    }
    return backend()-&gt;hasProperty(property.id());
}
std::vector&lt;Property&gt; Section::properties(const util::Filter&lt;Property&gt;::type &amp;filter) const {
    auto f = [this] (ndsize_t i) { return getProperty(i); };
    return getEntities&lt;Property&gt;(f,
            propertyCount(),
            filter);
}
bool Section::deleteProperty(const Property &amp;property) {
    if (property == none || !property.isValidEntity()) {
        return false;
    }
    return backend()-&gt;deleteProperty(property.id());
}
std::vector&lt;Property&gt; Section::inheritedProperties() const {
    std::vector&lt;Property&gt; own = properties();
    if (link() == none)
        return own;
    const std::vector&lt;Property&gt; linked = link().properties();
    copy_if (linked.begin(), linked.end(),
             back_inserter(own),
             [&amp;own](const Property &amp;linked_prop) {
                 return find_if (own.begin(), own.end(),
                                [&amp;linked_prop](const Property &amp;own_prop) {
                                    return linked_prop.name() == own_prop.name();
                                }) == own.end();
             });
    return own;
}
size_t Section::tree_depth() const{
  const std::vector&lt;Section&gt; children = sections();
  size_t depth = 0;
  if (children.size() &gt; 0) {
      for (auto &amp;child : children) {
          depth = std::max(depth, child.tree_depth());
      }
      depth += 1;
  }
  return depth;
}
std::vector&lt;Section&gt; Section::findDownstream(const std::function&lt;bool(Section)&gt; &amp;filter) const {
    std::vector&lt;Section&gt; results;
    size_t max_depth = tree_depth();
    size_t actual_depth = 1;
    while (results.size() == 0 &amp;&amp; actual_depth &lt;= max_depth) {
        results = findSections(filter, actual_depth);
        actual_depth += 1;
    }
    return results;
}
std::vector&lt;Section&gt; Section::findAmongParents(const std::function&lt;bool(Section)&gt; &amp;filter) const {
    std::vector&lt;Section&gt; results;
    Section p = parent();
    if (p == none) {
        return results;
    }
    if (filter(p)) {
        results.push_back(p);
        return results;
    } else {
        return p.findAmongParents(filter);
    }
}
std::vector&lt;Section&gt; Section::findSideways(const std::function&lt;bool(Section)&gt; &amp;filter, const std::string &amp;caller_id) const{
    std::vector&lt;Section&gt; results;
    Section p = parent();
    if (p != none) {
        results = p.findSections(filter,1);
        if (results.size() &gt; 0) {
            results.erase(remove_if(results.begin(),
                                    results.end(),
                                    [&amp;caller_id](const Section &amp;section) {
                                        return section.id() == caller_id;
                                    }),
                          results.end());
            return results;
        }
        return p.findSideways(filter, caller_id);
    }
    return results;
}
std::ostream&amp; nix::operator&lt;&lt;(std::ostream &amp;out, const Section &amp;ent) {
    out &lt;&lt; &quot;Section: {name = &quot; &lt;&lt; ent.name();
<A NAME="0"></A>    out &lt;&lt; &quot;, type = &quot; &lt;&lt; ent.type();
    out &lt;&lt; &quot;, id = &quot; &lt;&lt; ent.id() &lt;&lt; &quot;}&quot;;
    return out;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1747-1.html#0',3,'match1747-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
void Section::repository(const std::string &amp;repository) {
    util::checkEmptyString(repository, &quot;repository&quot;);
    backend()-&gt;repository(repository);
}
void Section::link(const std::string &amp;id) {
    util::checkEmptyString(id, &quot;link&quot;);</B></FONT>
    backend()-&gt;link(id);
}
Section Section::createSection(const std::string &amp;name, const std::string &amp;type) {
    util::checkEntityNameAndType(name, type);
    if (backend()-&gt;hasSection(name)) {
        throw DuplicateName(&quot;createSection&quot;);
    }
    return backend()-&gt;createSection(name, type);
}
Property Section::createProperty(const std::string &amp;name, const DataType &amp;dtype) {
    util::checkEntityName(name);
    if (backend()-&gt;hasProperty(name)) {
        throw DuplicateName(&quot;hasProperty&quot;);
    }
    return backend()-&gt;createProperty(name, dtype);
}
Property Section::createProperty(const std::string &amp;name, const std::vector&lt;Variant&gt; &amp;values) {
    if (values.size() &lt; 1)
        throw std::runtime_error(&quot;Trying to create a property without a value!&quot;);
    util::checkEntityName(name);
    if (backend()-&gt;hasProperty(name)) {
        throw DuplicateName(&quot;hasProperty&quot;);
    }
    return backend()-&gt;createProperty(name, values);
}
Property Section::createProperty(const std::string &amp;name, const Variant &amp;value) {
    util::checkEntityName(name);
    if (backend()-&gt;hasProperty(name)){
        throw DuplicateName(&quot;Property with that name already exists!&quot;);
    }
    return backend()-&gt;createProperty(name, value);
}
Section Section::getSection(ndsize_t index) const {
    if (index &gt;= backend()-&gt;sectionCount()) {
        throw OutOfBounds(&quot;Section::getSection: index is out of bounds!&quot;);
    }
    return backend()-&gt;getSection(index);
}
std::vector&lt;nix::DataArray&gt; Section::referringDataArrays() const {
    std::vector&lt;nix::DataArray&gt; arrays;
    nix::File f = backend()-&gt;parentFile();
    for (auto b : f.blocks()) {
        std::vector&lt;nix::DataArray&gt; temp = referringDataArrays(b);
        arrays.insert(arrays.end(), temp.begin(), temp.end());
    }
    return arrays;
}
std::vector&lt;nix::DataArray&gt; Section::referringDataArrays(const Block &amp;b) const {
    std::vector&lt;nix::DataArray&gt; arrays;
    if (b) {
        arrays = b.dataArrays(nix::util::MetadataFilter&lt;nix::DataArray&gt;(id()));
    }
    return arrays;
}
std::vector&lt;nix::Tag&gt; Section::referringTags() const {
    std::vector&lt;nix::Tag&gt; tags;
    nix::File f = backend()-&gt;parentFile();
    for (auto b : f.blocks()) {
        std::vector&lt;nix::Tag&gt; temp = referringTags(b);
        tags.insert(tags.end(), temp.begin(), temp.end());
    }
    return tags;
}
std::vector&lt;nix::Tag&gt; Section::referringTags(const Block &amp;b) const {
    std::vector&lt;nix::Tag&gt; tags;
    if (b) {
        tags = b.tags(nix::util::MetadataFilter&lt;nix::Tag&gt;(id()));
    }
    return tags;
}
std::vector&lt;nix::MultiTag&gt; Section::referringMultiTags() const {
    std::vector&lt;nix::MultiTag&gt; tags;
    nix::File f = backend()-&gt;parentFile();
    for (auto b : f.blocks()) {
        std::vector&lt;nix::MultiTag&gt; temp = referringMultiTags(b);
        tags.insert(tags.end(), temp.begin(), temp.end());
    }
    return tags;
}
std::vector&lt;nix::MultiTag&gt; Section::referringMultiTags(const Block &amp;b) const {
    std::vector&lt;nix::MultiTag&gt; tags;
    if (b) {
        tags = b.multiTags(nix::util::MetadataFilter&lt;nix::MultiTag&gt;(id()));
    }
    return tags;
}
std::vector&lt;nix::Source&gt; Section::referringSources() const {
    std::vector&lt;nix::Source&gt; srcs;
    nix::File f = backend()-&gt;parentFile();
    for (auto b : f.blocks()) {
        std::vector&lt;nix::Source&gt; temp = referringSources(b);
        srcs.insert(srcs.end(), temp.begin(), temp.end());
    }
    return srcs;
}
std::vector&lt;nix::Source&gt; Section::referringSources(const Block &amp;b) const {
    std::vector&lt;nix::Source&gt; srcs;
    if (b) {
        srcs = b.findSources(nix::util::MetadataFilter&lt;nix::Source&gt;(id()));
    }
    return srcs;
}
std::vector&lt;nix::Block&gt; Section::referringBlocks() const {
    nix::File f = backend()-&gt;parentFile();
    return f.blocks(nix::util::MetadataFilter&lt;nix::Block&gt;(id()));
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Dimensions.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;nix/Dimensions.hpp&gt;
#include &lt;cmath&gt;
#include &lt;nix/DataArray.hpp&gt;
#include &lt;nix/util/util.hpp&gt;
#include &lt;nix/Exception.hpp&gt;
using namespace std;
using namespace nix;
using namespace nix::base;
Dimension::Dimension()
    : ImplContainer()
{
}
<A NAME="1"></A>
Dimension::Dimension(const shared_ptr&lt;IDimension&gt; &amp;p_impl)
    : ImplContainer(p_impl)
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
}
Dimension::Dimension(shared_ptr&lt;IDimension&gt; &amp;&amp;ptr)
    : ImplContainer(std::move(ptr))
{
}
Dimension::Dimension(const Dimension &amp;other)
    : ImplContainer(other)
{
}
Dimension::Dimension(const SampledDimension &amp;other)</B></FONT>
    : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
{
}
Dimension::Dimension(const RangeDimension &amp;other)
    : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
{
}
Dimension::Dimension(const SetDimension &amp;other)
    : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
{
}
Dimension::Dimension(const DataFrameDimension &amp;other)
    : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
{
}
SetDimension Dimension::asSetDimension() const {
    if (dimensionType() != DimensionType::Set) {
        throw IncompatibleDimensions(&quot;Dimension is not of type Set and thus cannot be cast to this type&quot;, &quot;asSetDimension&quot;);
    }
    return SetDimension(std::dynamic_pointer_cast&lt;base::ISetDimension&gt;(impl()));
}
SampledDimension Dimension::asSampledDimension() const {
    if (dimensionType() != DimensionType::Sample) {
        throw IncompatibleDimensions(&quot;Dimension is not of type Sample and thus cannot be cast to this type&quot;, &quot;asSampledDimension&quot;);
    }
    return SampledDimension(std::dynamic_pointer_cast&lt;base::ISampledDimension&gt;(impl()));
}
RangeDimension Dimension::asRangeDimension() const {
    if (dimensionType() != DimensionType::Range) {
        throw IncompatibleDimensions(&quot;Dimension is not of type Range and thus cannot be cast to this type&quot;, &quot;asRangeDimension&quot;);
    }
    return RangeDimension(std::dynamic_pointer_cast&lt;base::IRangeDimension&gt;(impl()));
}
DataFrameDimension Dimension::asDataFrameDimension() const {
    if (dimensionType() != DimensionType::DataFrame) {
        throw IncompatibleDimensions(&quot;Dimension is not of type DataFrame and thus cannot be cast to this type&quot;, &quot;asDataFrameDimension&quot;);
    }
    return DataFrameDimension(std::dynamic_pointer_cast&lt;base::IDataFrameDimension&gt;(impl()));
}
Dimension&amp; Dimension::operator=(const SampledDimension &amp;other) {
    shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
Dimension&amp; Dimension::operator=(const RangeDimension &amp;other) {
    shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
Dimension&amp; Dimension::operator=(const SetDimension &amp;other) {
    shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
Dimension&amp; Dimension::operator=(const DataFrameDimension &amp;other) {
    shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
SampledDimension::SampledDimension()
    : ImplContainer()
{
}
SampledDimension::SampledDimension(const std::shared_ptr&lt;ISampledDimension&gt; &amp;p_impl)
    : ImplContainer(p_impl)
{
}
SampledDimension::SampledDimension(std::shared_ptr&lt;ISampledDimension&gt; &amp;&amp;ptr)
    : ImplContainer(std::move(ptr))
{
}
<A NAME="0"></A>SampledDimension::SampledDimension(const SampledDimension &amp;other)
    : ImplContainer(other)
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
void SampledDimension::label(const std::string &amp;label) {
    util::checkEmptyString(label, &quot;label&quot;);
    backend()-&gt;label(label);
}
void SampledDimension::unit(const std::string &amp;unit) {
    util::checkEmptyString(unit, &quot;unit&quot;);</B></FONT>
    if (!(util::isSIUnit(unit))) {
        throw InvalidUnit(&quot;Unit is not a SI unit. Note: so far, only atomic SI units are supported.&quot;,
                          &quot;SampledDimension::unit(const string &amp;unit)&quot;);
    }
    backend()-&gt;unit(unit);
}
void SampledDimension::samplingInterval(double interval) {
    if (interval &lt;= 0.0) {
        throw std::runtime_error(&quot;SampledDimenion::samplingInterval: Sampling intervals must be larger than 0.0!&quot;);
    }
    backend()-&gt;samplingInterval(interval);
}
boost::optional&lt;ndsize_t&gt; getSampledIndex(const double position, const double offset, const double sampling_interval, const PositionMatch match) {
    boost::optional&lt;ndsize_t&gt; index;
    if (position &lt; offset &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
        return index;
    }
    double tmp;
    if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
        tmp = ceil((position - offset) / sampling_interval);
        if (tmp &lt; 0.0) {
            tmp = 0.0;
        }
        bool equals = fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
    } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
        tmp = floor((position - offset) / sampling_interval);
        bool equals = fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        if (match == PositionMatch::Less &amp;&amp; equals) { 
            if (tmp &gt;= 1) {
                index = static_cast&lt;ndsize_t&gt;(tmp - 1);
            } 
        } else {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    } else {
        tmp = round((position - offset) / sampling_interval);
        if (fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    }
    return index;
}
ndsize_t SampledDimension::indexOf(const double position) const {
    boost::optional&lt;ndsize_t&gt; index = indexOf(position, PositionMatch::GreaterOrEqual);
    if (!index) {
        throw nix::OutOfBounds(&quot;SampledDimension::indexOf: An invalid position was encountered! position &lt; offset?&quot;);
    }
    return *index;   
}
boost::optional&lt;ndsize_t&gt; SampledDimension::indexOf(const double position, const PositionMatch match) const {
    double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    boost::optional&lt;ndsize_t&gt; index = getSampledIndex(position, offset, sampling_interval, match);
    return index;
}
std::pair&lt;ndsize_t, ndsize_t&gt; SampledDimension::indexOf(const double start, const double end) const {
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; pair = indexOf(start, end, RangeMatch::Inclusive);
    if (!pair) {
        throw nix::OutOfBounds(&quot;SampledDimension::indexOf: An invalid range was encountered!&quot;);
    }
    return *pair;
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(const double start, const double end, const RangeMatch range_matching) const {
    double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    return indexOf(start, end, sampling_interval, offset, range_matching);
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(double start, double end, const double sampling_interval, 
                                                                         const double offset, const RangeMatch match) const {
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
    PositionMatch pos_match = match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less;
    if (start &gt; end) {
        return indices;
    }
    boost::optional&lt;ndsize_t&gt; si = getSampledIndex(start, offset, sampling_interval, PositionMatch::GreaterOrEqual);
    boost::optional&lt;ndsize_t&gt; ei = getSampledIndex(end, offset, sampling_interval, pos_match);
    if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
        indices = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
    }
    return indices;
}
std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; SampledDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                                      const std::vector&lt;double&gt; &amp;end_positions,
                                                                                      const RangeMatch range_matching) const {
    if (start_positions.size() != end_positions.size()) {
        throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
    }
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
    double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    for (size_t i = 0; i &lt; start_positions.size(); ++i) {
        indices.push_back(indexOf(start_positions[i], end_positions[i], sampling_interval, offset, range_matching));
    }
    return indices;
}
std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                     const std::vector&lt;double&gt; &amp;end_positions) const {
    if (start_positions.size() != end_positions.size()) {
        throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
    }
    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
    double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; pair;
    for (size_t i = 0; i &lt; start_positions.size(); ++i) {
        pair = indexOf(start_positions[i], end_positions[i], sampling_interval, offset, RangeMatch::Inclusive);
        if (!pair) {
            throw nix::OutOfBounds(&quot;SampledDimension::indexOf: an invalid range was encountered&quot;);
        }
        indices.push_back(*pair);
    }
    return indices;
}
double SampledDimension::positionAt(const ndsize_t index) const {
    double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    return index * sampling_interval + offset;
}
vector&lt;double&gt; SampledDimension::axis(const ndsize_t count, const ndsize_t startIndex) const {
    size_t cnt = check::fits_in_size_t(count, &quot;Axis count exceeds memory (size larger than current system supports)&quot;);
    vector&lt;double&gt; axis(cnt);
    double offset =  backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
    double sampling_interval = backend()-&gt;samplingInterval();
    for (size_t i = 0; i &lt; axis.size(); ++i) {
        double dbl = check::converts_to_double(i, &quot;SampledDimension::axis conversion to double failed!&quot;);
        axis[i] = (dbl + startIndex) * sampling_interval + offset;
    }
    return axis;
}
SampledDimension&amp; SampledDimension::operator=(const SampledDimension &amp;other) {
    shared_ptr&lt;ISampledDimension&gt; tmp(other.impl());
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
SampledDimension&amp; SampledDimension::operator=(const Dimension &amp;other) {
    shared_ptr&lt;ISampledDimension&gt; tmp(dynamic_pointer_cast&lt;ISampledDimension&gt;(other.impl()));
    if (other.dimensionType() != DimensionType::Sample) {
        throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
                                          + &quot; to a SampledDimension&quot;, &quot;SampledDimension::operator=&quot;);
    }
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
SetDimension::SetDimension()
    : ImplContainer()
{
}
SetDimension::SetDimension(const std::shared_ptr&lt;ISetDimension&gt; &amp;p_impl)
    : ImplContainer(p_impl)
{
}
SetDimension::SetDimension(std::shared_ptr&lt;ISetDimension&gt; &amp;&amp;ptr)
    : ImplContainer(std::move(ptr))
{
}
SetDimension::SetDimension(const SetDimension &amp;other)
    : ImplContainer(other)
{
}
boost::optional&lt;ndsize_t&gt; getSetIndex(const double position, std::vector&lt;std::string&gt; labels, const PositionMatch match) {
    boost::optional&lt;ndsize_t&gt; index;
    if (position &lt; 0 &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
        return index;
    }
    double tmp;
    if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
        tmp = ceil(position);
        if (tmp &lt; 0.0) {
            tmp = 0.0;
        }
        bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
    } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
        tmp = floor(position);
        bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        if (match == PositionMatch::Less &amp;&amp; equals) { 
            if (tmp &gt;= 1) {
                index = static_cast&lt;ndsize_t&gt;(tmp - 1);
            } 
        } else {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    } else {
        tmp = round(position);
        if (fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    }
    ndsize_t label_count = labels.size();
    if (index &amp;&amp; label_count &gt; 0 &amp;&amp; *index &gt; label_count - 1) {
        if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
            index = label_count - 1;
        } else {
            index = boost::none;
        }
    }
    return index;
}
boost::optional&lt;ndsize_t&gt; SetDimension::indexOf(const double position, const PositionMatch match) const {
    std::vector&lt;std::string&gt; lbls = labels();
    return getSetIndex(position, lbls, match);
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SetDimension::indexOf(double start, double end, std::vector&lt;std::string&gt; &amp;set_labels, const RangeMatch match) const {
    if (set_labels.size() == 0) {
        set_labels = labels();
    } 
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; index;
    if (start &gt; end) {
        return index;
    }
    PositionMatch end_match = match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less;
    boost::optional&lt;ndsize_t&gt; si = getSetIndex(start, set_labels, PositionMatch::GreaterOrEqual);
    boost::optional&lt;ndsize_t&gt; ei = getSetIndex(end, set_labels, end_match);
    if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
        index = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);    
    }
    return index;
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SetDimension::indexOf(const double start, const double end, const RangeMatch match) const {
    std::vector&lt;std::string&gt; set_labels = labels();
    return indexOf(start, end, set_labels, match);
}
std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; SetDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                                  const std::vector&lt;double&gt; &amp;end_positions,
                                                                                  const RangeMatch match) const {
    if (start_positions.size() != end_positions.size()) {
        throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
    }
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
    std::vector&lt;std::string&gt; set_labels = labels();
    for (size_t i = 0; i &lt; start_positions.size(); ++i) {
        indices.push_back(indexOf(start_positions[i], end_positions[i], set_labels, match));
    }
    return indices;
}
SetDimension&amp; SetDimension::operator=(const SetDimension &amp;other) {
    shared_ptr&lt;ISetDimension&gt; tmp(other.impl());
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
SetDimension&amp; SetDimension::operator=(const Dimension &amp;other) {
    shared_ptr&lt;ISetDimension&gt; tmp(dynamic_pointer_cast&lt;ISetDimension&gt;(other.impl()));
    if (other.dimensionType() != DimensionType::Set) {
        throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
                                          + &quot; to a SetDimension&quot;, &quot;SetDimension::operator=&quot;);
    }
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
RangeDimension::RangeDimension()
    : ImplContainer()
{
}
RangeDimension::RangeDimension(const DataArray &amp;array)
    : ImplContainer()
{
    if (array.dataExtent().size() &gt; 1) {
        throw InvalidRank(&quot;Error creating RangeDimension with DataArray: array must be 1-D!&quot;);
    }
}
RangeDimension::RangeDimension(const std::shared_ptr&lt;IRangeDimension&gt; &amp;p_impl)
    : ImplContainer(p_impl)
{
}
RangeDimension::RangeDimension(std::shared_ptr&lt;IRangeDimension&gt; &amp;&amp;ptr)
    : ImplContainer(std::move(ptr))
{
}
RangeDimension::RangeDimension(const RangeDimension &amp;other)
    : ImplContainer(other)
{
}
void RangeDimension::label(const std::string &amp;label) {
    util::checkEmptyString(label, &quot;label&quot;);
    backend()-&gt;label(label);
}
void RangeDimension::unit(const std::string &amp;unit) {
    util::checkEmptyString(unit, &quot;unit&quot;);
    if (!(util::isSIUnit(unit))) {
        throw InvalidUnit(&quot;Unit is not an atomic SI. Note: So far composite units are not supported&quot;, &quot;RangeDimension::unit(const string &amp;unit)&quot;);
    }
    backend()-&gt;unit(unit);
}
void RangeDimension::ticks(const std::vector&lt;double&gt; &amp;ticks) {
    if (!std::is_sorted(ticks.begin(), ticks.end())) {
        std::string caller = &quot;Range::ticks()&quot;;
        throw UnsortedTicks(caller);
    }
    backend()-&gt;ticks(ticks);
}
double RangeDimension::tickAt(const ndsize_t index) const {
    vector&lt;double&gt; ticks = this-&gt;ticks(index, 1);
    return ticks[0];
}
PositionInRange RangeDimension::positionInRange(const double position) const {
    PositionInRange result;
    vector&lt;double&gt; ticks = this-&gt;ticks();
    if (ticks.size() == 0) {
        result = PositionInRange::NoRange;
    } else if (position &lt; *ticks.begin()) {
        result = PositionInRange::Less;
    } else if (position &gt; *prev(ticks.end())) {
        result = PositionInRange::Greater;
    } else {
        result = PositionInRange::InRange;
    }
    return result;
}
boost::optional&lt;ndsize_t&gt; getIndex(const double position, std::vector&lt;double&gt; &amp;ticks, PositionMatch matching) {
    boost::optional&lt;ndsize_t&gt; idx;
    if (ticks.size() == 0)
        return idx;
    if (position &lt; *ticks.begin()) {
        if (matching == PositionMatch::Greater || matching == PositionMatch::GreaterOrEqual)
            idx = 0;
        return idx;
    } else if (position &gt; *prev(ticks.end())) {
        if (matching == PositionMatch::Less || matching == PositionMatch::LessOrEqual)
            idx =  prev(ticks.end()) - ticks.begin();
        return idx;
    }
    std::vector&lt;double&gt;::iterator lower = std::lower_bound(ticks.begin(), ticks.end(), position);
    if (matching == PositionMatch::Greater || matching == PositionMatch::GreaterOrEqual) {
        idx = lower - ticks.begin();
        if (matching == PositionMatch::Greater &amp;&amp; *lower == position) {
            if ((lower + 1) &lt; ticks.end()) {
                idx = lower + 1 - ticks.begin();
            } else {
                idx = boost::none;
            }
        }
    } else if (matching == PositionMatch::LessOrEqual &amp;&amp; *lower &gt; position) {
        if (lower - 1 &gt;= ticks.begin()) {
            idx = lower - 1 - ticks.begin();
        } else {
            idx = boost::none;
        }
    } else if (matching == PositionMatch::Less &amp;&amp; *lower &gt;= position) {
        if ((lower - 1) &gt;= ticks.begin()) {
            idx = lower - 1 - ticks.begin();
        } else {
            idx = boost::none;
        }
    } else {         if (lower != ticks.end() &amp;&amp; *lower == position) {
            idx = lower - ticks.begin();
        }
    }
    return idx;
}
boost::optional&lt;ndsize_t&gt; RangeDimension::indexOf(const double position, PositionMatch matching) const {
    vector&lt;double&gt; ticks = this-&gt;ticks();
    boost::optional&lt;ndsize_t&gt; index = getIndex(position, ticks, matching);
    return index;
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; RangeDimension::indexOf(double start, double end,
                                                                       std::vector&lt;double&gt; ticks,
                                                                       RangeMatch match) const {
    if (ticks.size() == 0) {
        ticks = this-&gt;ticks();
    }
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
    if (start &gt; end){
        return range;
    }
    boost::optional&lt;ndsize_t&gt; si = getIndex(start, ticks, PositionMatch::GreaterOrEqual);
    if (!si) {
        return range;
    }
    PositionMatch endMatching = (match == RangeMatch::Inclusive) ? PositionMatch::LessOrEqual : PositionMatch::Less;
    boost::optional&lt;ndsize_t&gt; ei = getIndex(end, ticks, endMatching);
    if (ei &amp;&amp; *si &lt;= *ei) {
        range = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
    }
    return range;
}
ndsize_t RangeDimension::indexOf(const double position, bool less_or_equal) const {
    vector&lt;double&gt; ticks = this-&gt;ticks();
    PositionMatch matching = less_or_equal ? PositionMatch::LessOrEqual : PositionMatch::GreaterOrEqual;
    boost::optional&lt;ndsize_t&gt; index = getIndex(position, ticks, matching);
    if (index)
        return *index;
    else
        throw nix::OutOfBounds(&quot;RangeDimension::indexOf: Position is out of bounds.&quot;);
}
pair&lt;ndsize_t, ndsize_t&gt; RangeDimension::indexOf(const double start, const double end) const {
    vector&lt;double&gt; ticks = this-&gt;ticks();
    boost::optional&lt;ndsize_t&gt; si = getIndex(start, ticks, PositionMatch::GreaterOrEqual);
    boost::optional&lt;ndsize_t&gt; ei = getIndex(end, ticks, PositionMatch::LessOrEqual);
    if (!ei || !si) {
        throw nix::OutOfBounds(&quot;RangeDimension::indexOf: start or end of range are out of Bounds!&quot;);
    }
    return std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
}
std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; RangeDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                   const std::vector&lt;double&gt; &amp;end_positions,
                                                                   bool strict, RangeMatch match) const {
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; optionalIndices;
    optionalIndices = indexOf(start_positions, end_positions, match);
    std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
    for(auto o: optionalIndices) {
        if (o) {
            indices.push_back(*o);
        } else if(strict) {
            throw nix::OutOfBounds(&quot;RangeDimension::indexOf: an invalid range was encountered.&quot;);
        }
    }
    return indices;
}
std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; RangeDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                                    const std::vector&lt;double&gt; &amp;end_positions,
                                                                                    RangeMatch match) const {
    if (start_positions.size() != end_positions.size()) {
        throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
    }
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
    vector&lt;double&gt; ticks = this-&gt;ticks();
    for (size_t i = 0; i &lt; start_positions.size(); ++i) {
        boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
        range = this-&gt;indexOf(start_positions[i], end_positions[i], ticks, match);
        indices.push_back(range);
    }
    return indices;
}
vector&lt;double&gt; RangeDimension::axis(const ndsize_t count, const ndsize_t startIndex) const {
    size_t cnt = check::fits_in_size_t(count, &quot;Axis count exceeds memory (size larger than current system supports)&quot;);
    vector&lt;double&gt; ticks = this-&gt;ticks(startIndex, cnt);
    return ticks;
}
RangeDimension&amp; RangeDimension::operator=(const RangeDimension &amp;other) {
    shared_ptr&lt;IRangeDimension&gt; tmp(other.impl());
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
RangeDimension&amp; RangeDimension::operator=(const Dimension &amp;other) {
    shared_ptr&lt;IRangeDimension&gt; tmp(dynamic_pointer_cast&lt;IRangeDimension&gt;(other.impl()));
    if (other.dimensionType() != DimensionType::Range) {
        throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
                                          + &quot; to a RangeDimension&quot;, &quot;RangeDimension::operator=&quot;);
    }
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
DataFrameDimension::DataFrameDimension()
    : ImplContainer()
{
}
DataFrameDimension::DataFrameDimension(const std::shared_ptr&lt;IDataFrameDimension&gt; &amp;p_impl)
    : ImplContainer(p_impl)
{
}
DataFrameDimension::DataFrameDimension(std::shared_ptr&lt;IDataFrameDimension&gt; &amp;&amp;ptr)
    : ImplContainer(std::move(ptr))
{
}
DataFrameDimension::DataFrameDimension(const DataFrameDimension &amp;other)
    : ImplContainer(other)
{
}
boost::optional&lt;ndsize_t&gt; getDataFrameIndex(const double position, const ndsize_t tick_count, const PositionMatch match) {
    boost::optional&lt;ndsize_t&gt; index;
    if (position &lt; 0 &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
        return index;
    }
    double tmp;
    if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
        tmp = ceil(position);
        if (tmp &lt; 0.0) {
            tmp = 0.0;
        }
        bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
    } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
        tmp = floor(position);
        bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
        if (match == PositionMatch::Less &amp;&amp; equals) { 
            if (tmp &gt;= 1) {
                index = static_cast&lt;ndsize_t&gt;(tmp - 1);
            } 
        } else {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    } else {
        tmp = round(position);
        if (fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
            index = static_cast&lt;ndsize_t&gt;(tmp);
        }
    }
    if (index &amp;&amp; tick_count &gt; 0 &amp;&amp; *index &gt; tick_count - 1) {
        if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
            index = tick_count - 1;
        } else {
            index = boost::none;
        }
    }
    return index;
}
boost::optional&lt;ndsize_t&gt; DataFrameDimension::indexOf(const double position, const PositionMatch pos_match) const {
    ndsize_t tick_count = this-&gt;size();
    return getDataFrameIndex(position, tick_count, pos_match);
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; DataFrameDimension::indexOf(double start, double end, ndsize_t tick_count, const RangeMatch match) const {
    boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; index;
    if (start &gt; end) {
        return index;
    }
    PositionMatch end_match = (match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less);
    boost::optional&lt;ndsize_t&gt; si = getDataFrameIndex(start, tick_count, PositionMatch::GreaterOrEqual);
    boost::optional&lt;ndsize_t&gt; ei = getDataFrameIndex(end, tick_count, end_match);
    if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
        index = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);    
    }
    return index;
}
boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; DataFrameDimension::indexOf(double start, double end, const RangeMatch match) const {
    ndsize_t tick_count = this-&gt;size();
    return indexOf(start, end, tick_count, match);
}
std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; DataFrameDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
                                                                                        const std::vector&lt;double&gt; &amp;end_positions,
                                                                                        const RangeMatch match) const {
    if (start_positions.size() != end_positions.size()) {
        throw runtime_error(&quot;DataFrameDimension::IndexOf - Number of start and end positions must match!&quot;);
    }
    ndsize_t tick_count = this-&gt;size();
    std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
    for (size_t i = 0; i &lt; start_positions.size(); ++i) {
        indices.push_back(indexOf(start_positions[i], end_positions[i], tick_count, match));
    }
    return indices;
}
DataFrameDimension&amp; DataFrameDimension::operator=(const DataFrameDimension &amp;other) {
    shared_ptr&lt;IDataFrameDimension&gt; tmp(other.impl());
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
DataFrameDimension&amp; DataFrameDimension::operator=(const Dimension &amp;other) {
    shared_ptr&lt;IDataFrameDimension&gt; tmp(dynamic_pointer_cast&lt;IDataFrameDimension&gt;(other.impl()));
    if (other.dimensionType() != DimensionType::DataFrame) {
        throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
                                          + &quot; to a DataFrameDimension&quot;, &quot;DataFrameDimension::operator=&quot;);
    }
    if (impl() != tmp) {
        std::swap(impl(), tmp);
    }
    return *this;
}
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
