<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Section.cpp & Dimensions.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Section.cpp & Dimensions.cpp
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Section.cpp (4.971319%)<TH>Dimensions.cpp (1.9847329%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(267-275)<TD><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-1.html#0',3)" NAME="0">(172-182)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-1.html#1',3)" NAME="1">(23-39)<TD><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-1.html#1',3)" NAME="1">(33-49)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Section.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #include &lt;nix/Section.hpp&gt;
2 #include &lt;list&gt;
3 #include &lt;algorithm&gt;
4 #include &lt;iterator&gt;
5 #include &lt;nix/Block.hpp&gt;
6 #include &lt;nix/File.hpp&gt;
7 #include &lt;nix/DataArray.hpp&gt;
8 #include &lt;nix/util/util.hpp&gt;
9 using namespace nix;
10 <A NAME="1"></A>
11 Section::Section()
12     : NamedEntity()
13 <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1747-1.html#1',3,'match1747-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
14 }
15 Section::Section(std::nullptr_t ptr)
16     : NamedEntity()
17 {
18 }
19 Section::Section(const Section &amp;other)
20     : NamedEntity(other.impl())
21 {
22 }
23 Section::Section(const std::shared_ptr&lt;base::ISection&gt; &amp;p_impl)</B></FONT>
24     : NamedEntity(p_impl)
25 {
26 }
27 Section::Section(std::shared_ptr&lt;base::ISection&gt; &amp;&amp;ptr)
28     : NamedEntity(std::move(ptr))
29 {
30 }
31 void Section::link(const Section &amp;link) {
32     if (!link) {
33         backend()-&gt;link(none);
34     } else {
35         backend()-&gt;link(link.id());
36     }
37 }
38 bool Section::hasSection(const Section &amp;section) const {
39     if (!util::checkEntityInput(section, false)) {
40         return false;
41     }
42     return backend()-&gt;hasSection(section.id());
43 }
44 bool Section::deleteSection(const Section &amp;section) {
45     if (!util::checkEntityInput(section, false)) {
46         return false;
47     }
48     return backend()-&gt;deleteSection(section.id());
49 }
50 std::vector&lt;Section&gt; Section::sections(const util::Filter&lt;Section&gt;::type &amp;filter) const {
51     auto f = [this] (ndsize_t i) { return getSection(i); };
52     return getEntities&lt;Section&gt;(f, sectionCount(), filter);
53 }
54 void addChildrenIfNotMaxDepth(std::tuple&lt;Section, size_t&gt;&amp; current,
55                               std::list&lt;std::tuple&lt;Section, size_t&gt;&gt; &amp;todo,
56                               size_t max_depth) {
57     if (std::get&lt;1&gt;(current) &lt; max_depth) {
58         size_t next_depth = std::get&lt;1&gt;(current) + 1;
59         for (const auto &amp;s : std::get&lt;0&gt;(current).sections()) {
60             todo.emplace_back(s, next_depth);
61         }
62     }
63 }
64 std::vector&lt;Section&gt; Section::findSections(const util::Filter&lt;Section&gt;::type &amp;filter,
65                                            size_t max_depth) const {
66     std::vector&lt;Section&gt; results;
67     std::list&lt;std::tuple&lt;Section, size_t&gt;&gt; todo;
68     std::tuple&lt;Section, size_t&gt; current = std::make_tuple(*this, 0);
69     addChildrenIfNotMaxDepth(current, todo, max_depth);
70     while (todo.size() &gt; 0) {
71         current = todo.front();
72         todo.pop_front();
73         if (filter(std::get&lt;0&gt;(current))) {
74             results.push_back(std::get&lt;0&gt;(current));
75         }
76         addChildrenIfNotMaxDepth(current, todo, max_depth);
77     }
78     return results;
79 }
80 static inline auto erase_section_with_id(std::vector&lt;Section&gt; &amp;sections, const std::string &amp;my_id)
81     -&gt; decltype(sections.size())
82 {
83     sections.erase(remove_if(sections.begin(),
84                              sections.end(),
85                              [&amp;my_id](const Section &amp;section) {
86                                  return my_id == section.id();
87                              }),
88                    sections.end());
89     return sections.size();
90 }
91 std::vector&lt;Section&gt; Section::findRelated(const util::Filter&lt;Section&gt;::type &amp;filter) const
92 {
93     std::vector&lt;Section&gt; results = findDownstream(filter);
94     const std::string &amp;my_id = id();
95     auto results_size = erase_section_with_id(results, my_id);
96     if (results_size == 0) {
97         results = findAmongParents(filter);
98     }
99     results_size = erase_section_with_id(results, my_id);
100     if (results_size == 0) {
101         results = findSideways(filter, id());
102     }
103     return results;
104 }
105 bool Section::hasProperty(const Property &amp;property) const {
106     if (property == none || !property.isValidEntity()) {
107         return false;
108     }
109     return backend()-&gt;hasProperty(property.id());
110 }
111 std::vector&lt;Property&gt; Section::properties(const util::Filter&lt;Property&gt;::type &amp;filter) const {
112     auto f = [this] (ndsize_t i) { return getProperty(i); };
113     return getEntities&lt;Property&gt;(f,
114             propertyCount(),
115             filter);
116 }
117 bool Section::deleteProperty(const Property &amp;property) {
118     if (property == none || !property.isValidEntity()) {
119         return false;
120     }
121     return backend()-&gt;deleteProperty(property.id());
122 }
123 std::vector&lt;Property&gt; Section::inheritedProperties() const {
124     std::vector&lt;Property&gt; own = properties();
125     if (link() == none)
126         return own;
127     const std::vector&lt;Property&gt; linked = link().properties();
128     copy_if (linked.begin(), linked.end(),
129              back_inserter(own),
130              [&amp;own](const Property &amp;linked_prop) {
131                  return find_if (own.begin(), own.end(),
132                                 [&amp;linked_prop](const Property &amp;own_prop) {
133                                     return linked_prop.name() == own_prop.name();
134                                 }) == own.end();
135              });
136     return own;
137 }
138 size_t Section::tree_depth() const{
139   const std::vector&lt;Section&gt; children = sections();
140   size_t depth = 0;
141   if (children.size() &gt; 0) {
142       for (auto &amp;child : children) {
143           depth = std::max(depth, child.tree_depth());
144       }
145       depth += 1;
146   }
147   return depth;
148 }
149 std::vector&lt;Section&gt; Section::findDownstream(const std::function&lt;bool(Section)&gt; &amp;filter) const {
150     std::vector&lt;Section&gt; results;
151     size_t max_depth = tree_depth();
152     size_t actual_depth = 1;
153     while (results.size() == 0 &amp;&amp; actual_depth &lt;= max_depth) {
154         results = findSections(filter, actual_depth);
155         actual_depth += 1;
156     }
157     return results;
158 }
159 std::vector&lt;Section&gt; Section::findAmongParents(const std::function&lt;bool(Section)&gt; &amp;filter) const {
160     std::vector&lt;Section&gt; results;
161     Section p = parent();
162     if (p == none) {
163         return results;
164     }
165     if (filter(p)) {
166         results.push_back(p);
167         return results;
168     } else {
169         return p.findAmongParents(filter);
170     }
171 }
172 std::vector&lt;Section&gt; Section::findSideways(const std::function&lt;bool(Section)&gt; &amp;filter, const std::string &amp;caller_id) const{
173     std::vector&lt;Section&gt; results;
174     Section p = parent();
175     if (p != none) {
176         results = p.findSections(filter,1);
177         if (results.size() &gt; 0) {
178             results.erase(remove_if(results.begin(),
179                                     results.end(),
180                                     [&amp;caller_id](const Section &amp;section) {
181                                         return section.id() == caller_id;
182                                     }),
183                           results.end());
184             return results;
185         }
186         return p.findSideways(filter, caller_id);
187     }
188     return results;
189 }
190 std::ostream&amp; nix::operator&lt;&lt;(std::ostream &amp;out, const Section &amp;ent) {
191     out &lt;&lt; &quot;Section: {name = &quot; &lt;&lt; ent.name();
192 <A NAME="0"></A>    out &lt;&lt; &quot;, type = &quot; &lt;&lt; ent.type();
193     out &lt;&lt; &quot;, id = &quot; &lt;&lt; ent.id() &lt;&lt; &quot;}&quot;;
194     return out;
195 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1747-1.html#0',3,'match1747-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
196 void Section::repository(const std::string &amp;repository) {
197     util::checkEmptyString(repository, &quot;repository&quot;);
198     backend()-&gt;repository(repository);
199 }
200 void Section::link(const std::string &amp;id) {
201     util::checkEmptyString(id, &quot;link&quot;);</B></FONT>
202     backend()-&gt;link(id);
203 }
204 Section Section::createSection(const std::string &amp;name, const std::string &amp;type) {
205     util::checkEntityNameAndType(name, type);
206     if (backend()-&gt;hasSection(name)) {
207         throw DuplicateName(&quot;createSection&quot;);
208     }
209     return backend()-&gt;createSection(name, type);
210 }
211 Property Section::createProperty(const std::string &amp;name, const DataType &amp;dtype) {
212     util::checkEntityName(name);
213     if (backend()-&gt;hasProperty(name)) {
214         throw DuplicateName(&quot;hasProperty&quot;);
215     }
216     return backend()-&gt;createProperty(name, dtype);
217 }
218 Property Section::createProperty(const std::string &amp;name, const std::vector&lt;Variant&gt; &amp;values) {
219     if (values.size() &lt; 1)
220         throw std::runtime_error(&quot;Trying to create a property without a value!&quot;);
221     util::checkEntityName(name);
222     if (backend()-&gt;hasProperty(name)) {
223         throw DuplicateName(&quot;hasProperty&quot;);
224     }
225     return backend()-&gt;createProperty(name, values);
226 }
227 Property Section::createProperty(const std::string &amp;name, const Variant &amp;value) {
228     util::checkEntityName(name);
229     if (backend()-&gt;hasProperty(name)){
230         throw DuplicateName(&quot;Property with that name already exists!&quot;);
231     }
232     return backend()-&gt;createProperty(name, value);
233 }
234 Section Section::getSection(ndsize_t index) const {
235     if (index &gt;= backend()-&gt;sectionCount()) {
236         throw OutOfBounds(&quot;Section::getSection: index is out of bounds!&quot;);
237     }
238     return backend()-&gt;getSection(index);
239 }
240 std::vector&lt;nix::DataArray&gt; Section::referringDataArrays() const {
241     std::vector&lt;nix::DataArray&gt; arrays;
242     nix::File f = backend()-&gt;parentFile();
243     for (auto b : f.blocks()) {
244         std::vector&lt;nix::DataArray&gt; temp = referringDataArrays(b);
245         arrays.insert(arrays.end(), temp.begin(), temp.end());
246     }
247     return arrays;
248 }
249 std::vector&lt;nix::DataArray&gt; Section::referringDataArrays(const Block &amp;b) const {
250     std::vector&lt;nix::DataArray&gt; arrays;
251     if (b) {
252         arrays = b.dataArrays(nix::util::MetadataFilter&lt;nix::DataArray&gt;(id()));
253     }
254     return arrays;
255 }
256 std::vector&lt;nix::Tag&gt; Section::referringTags() const {
257     std::vector&lt;nix::Tag&gt; tags;
258     nix::File f = backend()-&gt;parentFile();
259     for (auto b : f.blocks()) {
260         std::vector&lt;nix::Tag&gt; temp = referringTags(b);
261         tags.insert(tags.end(), temp.begin(), temp.end());
262     }
263     return tags;
264 }
265 std::vector&lt;nix::Tag&gt; Section::referringTags(const Block &amp;b) const {
266     std::vector&lt;nix::Tag&gt; tags;
267     if (b) {
268         tags = b.tags(nix::util::MetadataFilter&lt;nix::Tag&gt;(id()));
269     }
270     return tags;
271 }
272 std::vector&lt;nix::MultiTag&gt; Section::referringMultiTags() const {
273     std::vector&lt;nix::MultiTag&gt; tags;
274     nix::File f = backend()-&gt;parentFile();
275     for (auto b : f.blocks()) {
276         std::vector&lt;nix::MultiTag&gt; temp = referringMultiTags(b);
277         tags.insert(tags.end(), temp.begin(), temp.end());
278     }
279     return tags;
280 }
281 std::vector&lt;nix::MultiTag&gt; Section::referringMultiTags(const Block &amp;b) const {
282     std::vector&lt;nix::MultiTag&gt; tags;
283     if (b) {
284         tags = b.multiTags(nix::util::MetadataFilter&lt;nix::MultiTag&gt;(id()));
285     }
286     return tags;
287 }
288 std::vector&lt;nix::Source&gt; Section::referringSources() const {
289     std::vector&lt;nix::Source&gt; srcs;
290     nix::File f = backend()-&gt;parentFile();
291     for (auto b : f.blocks()) {
292         std::vector&lt;nix::Source&gt; temp = referringSources(b);
293         srcs.insert(srcs.end(), temp.begin(), temp.end());
294     }
295     return srcs;
296 }
297 std::vector&lt;nix::Source&gt; Section::referringSources(const Block &amp;b) const {
298     std::vector&lt;nix::Source&gt; srcs;
299     if (b) {
300         srcs = b.findSources(nix::util::MetadataFilter&lt;nix::Source&gt;(id()));
301     }
302     return srcs;
303 }
304 std::vector&lt;nix::Block&gt; Section::referringBlocks() const {
305     nix::File f = backend()-&gt;parentFile();
306     return f.blocks(nix::util::MetadataFilter&lt;nix::Block&gt;(id()));
307 }
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Dimensions.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #include &lt;nix/Dimensions.hpp&gt;
2 #include &lt;cmath&gt;
3 #include &lt;nix/DataArray.hpp&gt;
4 #include &lt;nix/util/util.hpp&gt;
5 #include &lt;nix/Exception.hpp&gt;
6 using namespace std;
7 using namespace nix;
8 using namespace nix::base;
9 Dimension::Dimension()
10     : ImplContainer()
11 {
12 }
13 <A NAME="1"></A>
14 Dimension::Dimension(const shared_ptr&lt;IDimension&gt; &amp;p_impl)
15     : ImplContainer(p_impl)
16 <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1747-0.html#1',2,'match1747-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
17 }
18 Dimension::Dimension(shared_ptr&lt;IDimension&gt; &amp;&amp;ptr)
19     : ImplContainer(std::move(ptr))
20 {
21 }
22 Dimension::Dimension(const Dimension &amp;other)
23     : ImplContainer(other)
24 {
25 }
26 Dimension::Dimension(const SampledDimension &amp;other)</B></FONT>
27     : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
28 {
29 }
30 Dimension::Dimension(const RangeDimension &amp;other)
31     : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
32 {
33 }
34 Dimension::Dimension(const SetDimension &amp;other)
35     : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
36 {
37 }
38 Dimension::Dimension(const DataFrameDimension &amp;other)
39     : ImplContainer(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()))
40 {
41 }
42 SetDimension Dimension::asSetDimension() const {
43     if (dimensionType() != DimensionType::Set) {
44         throw IncompatibleDimensions(&quot;Dimension is not of type Set and thus cannot be cast to this type&quot;, &quot;asSetDimension&quot;);
45     }
46     return SetDimension(std::dynamic_pointer_cast&lt;base::ISetDimension&gt;(impl()));
47 }
48 SampledDimension Dimension::asSampledDimension() const {
49     if (dimensionType() != DimensionType::Sample) {
50         throw IncompatibleDimensions(&quot;Dimension is not of type Sample and thus cannot be cast to this type&quot;, &quot;asSampledDimension&quot;);
51     }
52     return SampledDimension(std::dynamic_pointer_cast&lt;base::ISampledDimension&gt;(impl()));
53 }
54 RangeDimension Dimension::asRangeDimension() const {
55     if (dimensionType() != DimensionType::Range) {
56         throw IncompatibleDimensions(&quot;Dimension is not of type Range and thus cannot be cast to this type&quot;, &quot;asRangeDimension&quot;);
57     }
58     return RangeDimension(std::dynamic_pointer_cast&lt;base::IRangeDimension&gt;(impl()));
59 }
60 DataFrameDimension Dimension::asDataFrameDimension() const {
61     if (dimensionType() != DimensionType::DataFrame) {
62         throw IncompatibleDimensions(&quot;Dimension is not of type DataFrame and thus cannot be cast to this type&quot;, &quot;asDataFrameDimension&quot;);
63     }
64     return DataFrameDimension(std::dynamic_pointer_cast&lt;base::IDataFrameDimension&gt;(impl()));
65 }
66 Dimension&amp; Dimension::operator=(const SampledDimension &amp;other) {
67     shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
68     if (impl() != tmp) {
69         std::swap(impl(), tmp);
70     }
71     return *this;
72 }
73 Dimension&amp; Dimension::operator=(const RangeDimension &amp;other) {
74     shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
75     if (impl() != tmp) {
76         std::swap(impl(), tmp);
77     }
78     return *this;
79 }
80 Dimension&amp; Dimension::operator=(const SetDimension &amp;other) {
81     shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
82     if (impl() != tmp) {
83         std::swap(impl(), tmp);
84     }
85     return *this;
86 }
87 Dimension&amp; Dimension::operator=(const DataFrameDimension &amp;other) {
88     shared_ptr&lt;IDimension&gt; tmp(dynamic_pointer_cast&lt;IDimension&gt;(other.impl()));
89     if (impl() != tmp) {
90         std::swap(impl(), tmp);
91     }
92     return *this;
93 }
94 SampledDimension::SampledDimension()
95     : ImplContainer()
96 {
97 }
98 SampledDimension::SampledDimension(const std::shared_ptr&lt;ISampledDimension&gt; &amp;p_impl)
99     : ImplContainer(p_impl)
100 {
101 }
102 SampledDimension::SampledDimension(std::shared_ptr&lt;ISampledDimension&gt; &amp;&amp;ptr)
103     : ImplContainer(std::move(ptr))
104 {
105 }
106 <A NAME="0"></A>SampledDimension::SampledDimension(const SampledDimension &amp;other)
107     : ImplContainer(other)
108 {
109 <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1747-0.html#0',2,'match1747-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
110 void SampledDimension::label(const std::string &amp;label) {
111     util::checkEmptyString(label, &quot;label&quot;);
112     backend()-&gt;label(label);
113 }
114 void SampledDimension::unit(const std::string &amp;unit) {
115     util::checkEmptyString(unit, &quot;unit&quot;);</B></FONT>
116     if (!(util::isSIUnit(unit))) {
117         throw InvalidUnit(&quot;Unit is not a SI unit. Note: so far, only atomic SI units are supported.&quot;,
118                           &quot;SampledDimension::unit(const string &amp;unit)&quot;);
119     }
120     backend()-&gt;unit(unit);
121 }
122 void SampledDimension::samplingInterval(double interval) {
123     if (interval &lt;= 0.0) {
124         throw std::runtime_error(&quot;SampledDimenion::samplingInterval: Sampling intervals must be larger than 0.0!&quot;);
125     }
126     backend()-&gt;samplingInterval(interval);
127 }
128 boost::optional&lt;ndsize_t&gt; getSampledIndex(const double position, const double offset, const double sampling_interval, const PositionMatch match) {
129     boost::optional&lt;ndsize_t&gt; index;
130     if (position &lt; offset &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
131         return index;
132     }
133     double tmp;
134     if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
135         tmp = ceil((position - offset) / sampling_interval);
136         if (tmp &lt; 0.0) {
137             tmp = 0.0;
138         }
139         bool equals = fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
140         index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
141     } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
142         tmp = floor((position - offset) / sampling_interval);
143         bool equals = fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
144         if (match == PositionMatch::Less &amp;&amp; equals) { 
145             if (tmp &gt;= 1) {
146                 index = static_cast&lt;ndsize_t&gt;(tmp - 1);
147             } 
148         } else {
149             index = static_cast&lt;ndsize_t&gt;(tmp);
150         }
151     } else {
152         tmp = round((position - offset) / sampling_interval);
153         if (fabs(tmp * sampling_interval + offset - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
154             index = static_cast&lt;ndsize_t&gt;(tmp);
155         }
156     }
157     return index;
158 }
159 ndsize_t SampledDimension::indexOf(const double position) const {
160     boost::optional&lt;ndsize_t&gt; index = indexOf(position, PositionMatch::GreaterOrEqual);
161     if (!index) {
162         throw nix::OutOfBounds(&quot;SampledDimension::indexOf: An invalid position was encountered! position &lt; offset?&quot;);
163     }
164     return *index;   
165 }
166 boost::optional&lt;ndsize_t&gt; SampledDimension::indexOf(const double position, const PositionMatch match) const {
167     double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
168     double sampling_interval = backend()-&gt;samplingInterval();
169     boost::optional&lt;ndsize_t&gt; index = getSampledIndex(position, offset, sampling_interval, match);
170     return index;
171 }
172 std::pair&lt;ndsize_t, ndsize_t&gt; SampledDimension::indexOf(const double start, const double end) const {
173     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; pair = indexOf(start, end, RangeMatch::Inclusive);
174     if (!pair) {
175         throw nix::OutOfBounds(&quot;SampledDimension::indexOf: An invalid range was encountered!&quot;);
176     }
177     return *pair;
178 }
179 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(const double start, const double end, const RangeMatch range_matching) const {
180     double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
181     double sampling_interval = backend()-&gt;samplingInterval();
182     return indexOf(start, end, sampling_interval, offset, range_matching);
183 }
184 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(double start, double end, const double sampling_interval, 
185                                                                          const double offset, const RangeMatch match) const {
186     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
187     PositionMatch pos_match = match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less;
188     if (start &gt; end) {
189         return indices;
190     }
191     boost::optional&lt;ndsize_t&gt; si = getSampledIndex(start, offset, sampling_interval, PositionMatch::GreaterOrEqual);
192     boost::optional&lt;ndsize_t&gt; ei = getSampledIndex(end, offset, sampling_interval, pos_match);
193     if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
194         indices = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
195     }
196     return indices;
197 }
198 std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; SampledDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
199                                                                                       const std::vector&lt;double&gt; &amp;end_positions,
200                                                                                       const RangeMatch range_matching) const {
201     if (start_positions.size() != end_positions.size()) {
202         throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
203     }
204     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
205     double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
206     double sampling_interval = backend()-&gt;samplingInterval();
207     for (size_t i = 0; i &lt; start_positions.size(); ++i) {
208         indices.push_back(indexOf(start_positions[i], end_positions[i], sampling_interval, offset, range_matching));
209     }
210     return indices;
211 }
212 std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SampledDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
213                                                                      const std::vector&lt;double&gt; &amp;end_positions) const {
214     if (start_positions.size() != end_positions.size()) {
215         throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
216     }
217     std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
218     double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
219     double sampling_interval = backend()-&gt;samplingInterval();
220     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; pair;
221     for (size_t i = 0; i &lt; start_positions.size(); ++i) {
222         pair = indexOf(start_positions[i], end_positions[i], sampling_interval, offset, RangeMatch::Inclusive);
223         if (!pair) {
224             throw nix::OutOfBounds(&quot;SampledDimension::indexOf: an invalid range was encountered&quot;);
225         }
226         indices.push_back(*pair);
227     }
228     return indices;
229 }
230 double SampledDimension::positionAt(const ndsize_t index) const {
231     double offset = backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
232     double sampling_interval = backend()-&gt;samplingInterval();
233     return index * sampling_interval + offset;
234 }
235 vector&lt;double&gt; SampledDimension::axis(const ndsize_t count, const ndsize_t startIndex) const {
236     size_t cnt = check::fits_in_size_t(count, &quot;Axis count exceeds memory (size larger than current system supports)&quot;);
237     vector&lt;double&gt; axis(cnt);
238     double offset =  backend()-&gt;offset() ? *(backend()-&gt;offset()) : 0.0;
239     double sampling_interval = backend()-&gt;samplingInterval();
240     for (size_t i = 0; i &lt; axis.size(); ++i) {
241         double dbl = check::converts_to_double(i, &quot;SampledDimension::axis conversion to double failed!&quot;);
242         axis[i] = (dbl + startIndex) * sampling_interval + offset;
243     }
244     return axis;
245 }
246 SampledDimension&amp; SampledDimension::operator=(const SampledDimension &amp;other) {
247     shared_ptr&lt;ISampledDimension&gt; tmp(other.impl());
248     if (impl() != tmp) {
249         std::swap(impl(), tmp);
250     }
251     return *this;
252 }
253 SampledDimension&amp; SampledDimension::operator=(const Dimension &amp;other) {
254     shared_ptr&lt;ISampledDimension&gt; tmp(dynamic_pointer_cast&lt;ISampledDimension&gt;(other.impl()));
255     if (other.dimensionType() != DimensionType::Sample) {
256         throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
257                                           + &quot; to a SampledDimension&quot;, &quot;SampledDimension::operator=&quot;);
258     }
259     if (impl() != tmp) {
260         std::swap(impl(), tmp);
261     }
262     return *this;
263 }
264 SetDimension::SetDimension()
265     : ImplContainer()
266 {
267 }
268 SetDimension::SetDimension(const std::shared_ptr&lt;ISetDimension&gt; &amp;p_impl)
269     : ImplContainer(p_impl)
270 {
271 }
272 SetDimension::SetDimension(std::shared_ptr&lt;ISetDimension&gt; &amp;&amp;ptr)
273     : ImplContainer(std::move(ptr))
274 {
275 }
276 SetDimension::SetDimension(const SetDimension &amp;other)
277     : ImplContainer(other)
278 {
279 }
280 boost::optional&lt;ndsize_t&gt; getSetIndex(const double position, std::vector&lt;std::string&gt; labels, const PositionMatch match) {
281     boost::optional&lt;ndsize_t&gt; index;
282     if (position &lt; 0 &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
283         return index;
284     }
285     double tmp;
286     if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
287         tmp = ceil(position);
288         if (tmp &lt; 0.0) {
289             tmp = 0.0;
290         }
291         bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
292         index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
293     } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
294         tmp = floor(position);
295         bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
296         if (match == PositionMatch::Less &amp;&amp; equals) { 
297             if (tmp &gt;= 1) {
298                 index = static_cast&lt;ndsize_t&gt;(tmp - 1);
299             } 
300         } else {
301             index = static_cast&lt;ndsize_t&gt;(tmp);
302         }
303     } else {
304         tmp = round(position);
305         if (fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
306             index = static_cast&lt;ndsize_t&gt;(tmp);
307         }
308     }
309     ndsize_t label_count = labels.size();
310     if (index &amp;&amp; label_count &gt; 0 &amp;&amp; *index &gt; label_count - 1) {
311         if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
312             index = label_count - 1;
313         } else {
314             index = boost::none;
315         }
316     }
317     return index;
318 }
319 boost::optional&lt;ndsize_t&gt; SetDimension::indexOf(const double position, const PositionMatch match) const {
320     std::vector&lt;std::string&gt; lbls = labels();
321     return getSetIndex(position, lbls, match);
322 }
323 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SetDimension::indexOf(double start, double end, std::vector&lt;std::string&gt; &amp;set_labels, const RangeMatch match) const {
324     if (set_labels.size() == 0) {
325         set_labels = labels();
326     } 
327     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; index;
328     if (start &gt; end) {
329         return index;
330     }
331     PositionMatch end_match = match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less;
332     boost::optional&lt;ndsize_t&gt; si = getSetIndex(start, set_labels, PositionMatch::GreaterOrEqual);
333     boost::optional&lt;ndsize_t&gt; ei = getSetIndex(end, set_labels, end_match);
334     if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
335         index = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);    
336     }
337     return index;
338 }
339 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; SetDimension::indexOf(const double start, const double end, const RangeMatch match) const {
340     std::vector&lt;std::string&gt; set_labels = labels();
341     return indexOf(start, end, set_labels, match);
342 }
343 std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; SetDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
344                                                                                   const std::vector&lt;double&gt; &amp;end_positions,
345                                                                                   const RangeMatch match) const {
346     if (start_positions.size() != end_positions.size()) {
347         throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
348     }
349     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
350     std::vector&lt;std::string&gt; set_labels = labels();
351     for (size_t i = 0; i &lt; start_positions.size(); ++i) {
352         indices.push_back(indexOf(start_positions[i], end_positions[i], set_labels, match));
353     }
354     return indices;
355 }
356 SetDimension&amp; SetDimension::operator=(const SetDimension &amp;other) {
357     shared_ptr&lt;ISetDimension&gt; tmp(other.impl());
358     if (impl() != tmp) {
359         std::swap(impl(), tmp);
360     }
361     return *this;
362 }
363 SetDimension&amp; SetDimension::operator=(const Dimension &amp;other) {
364     shared_ptr&lt;ISetDimension&gt; tmp(dynamic_pointer_cast&lt;ISetDimension&gt;(other.impl()));
365     if (other.dimensionType() != DimensionType::Set) {
366         throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
367                                           + &quot; to a SetDimension&quot;, &quot;SetDimension::operator=&quot;);
368     }
369     if (impl() != tmp) {
370         std::swap(impl(), tmp);
371     }
372     return *this;
373 }
374 RangeDimension::RangeDimension()
375     : ImplContainer()
376 {
377 }
378 RangeDimension::RangeDimension(const DataArray &amp;array)
379     : ImplContainer()
380 {
381     if (array.dataExtent().size() &gt; 1) {
382         throw InvalidRank(&quot;Error creating RangeDimension with DataArray: array must be 1-D!&quot;);
383     }
384 }
385 RangeDimension::RangeDimension(const std::shared_ptr&lt;IRangeDimension&gt; &amp;p_impl)
386     : ImplContainer(p_impl)
387 {
388 }
389 RangeDimension::RangeDimension(std::shared_ptr&lt;IRangeDimension&gt; &amp;&amp;ptr)
390     : ImplContainer(std::move(ptr))
391 {
392 }
393 RangeDimension::RangeDimension(const RangeDimension &amp;other)
394     : ImplContainer(other)
395 {
396 }
397 void RangeDimension::label(const std::string &amp;label) {
398     util::checkEmptyString(label, &quot;label&quot;);
399     backend()-&gt;label(label);
400 }
401 void RangeDimension::unit(const std::string &amp;unit) {
402     util::checkEmptyString(unit, &quot;unit&quot;);
403     if (!(util::isSIUnit(unit))) {
404         throw InvalidUnit(&quot;Unit is not an atomic SI. Note: So far composite units are not supported&quot;, &quot;RangeDimension::unit(const string &amp;unit)&quot;);
405     }
406     backend()-&gt;unit(unit);
407 }
408 void RangeDimension::ticks(const std::vector&lt;double&gt; &amp;ticks) {
409     if (!std::is_sorted(ticks.begin(), ticks.end())) {
410         std::string caller = &quot;Range::ticks()&quot;;
411         throw UnsortedTicks(caller);
412     }
413     backend()-&gt;ticks(ticks);
414 }
415 double RangeDimension::tickAt(const ndsize_t index) const {
416     vector&lt;double&gt; ticks = this-&gt;ticks(index, 1);
417     return ticks[0];
418 }
419 PositionInRange RangeDimension::positionInRange(const double position) const {
420     PositionInRange result;
421     vector&lt;double&gt; ticks = this-&gt;ticks();
422     if (ticks.size() == 0) {
423         result = PositionInRange::NoRange;
424     } else if (position &lt; *ticks.begin()) {
425         result = PositionInRange::Less;
426     } else if (position &gt; *prev(ticks.end())) {
427         result = PositionInRange::Greater;
428     } else {
429         result = PositionInRange::InRange;
430     }
431     return result;
432 }
433 boost::optional&lt;ndsize_t&gt; getIndex(const double position, std::vector&lt;double&gt; &amp;ticks, PositionMatch matching) {
434     boost::optional&lt;ndsize_t&gt; idx;
435     if (ticks.size() == 0)
436         return idx;
437     if (position &lt; *ticks.begin()) {
438         if (matching == PositionMatch::Greater || matching == PositionMatch::GreaterOrEqual)
439             idx = 0;
440         return idx;
441     } else if (position &gt; *prev(ticks.end())) {
442         if (matching == PositionMatch::Less || matching == PositionMatch::LessOrEqual)
443             idx =  prev(ticks.end()) - ticks.begin();
444         return idx;
445     }
446     std::vector&lt;double&gt;::iterator lower = std::lower_bound(ticks.begin(), ticks.end(), position);
447     if (matching == PositionMatch::Greater || matching == PositionMatch::GreaterOrEqual) {
448         idx = lower - ticks.begin();
449         if (matching == PositionMatch::Greater &amp;&amp; *lower == position) {
450             if ((lower + 1) &lt; ticks.end()) {
451                 idx = lower + 1 - ticks.begin();
452             } else {
453                 idx = boost::none;
454             }
455         }
456     } else if (matching == PositionMatch::LessOrEqual &amp;&amp; *lower &gt; position) {
457         if (lower - 1 &gt;= ticks.begin()) {
458             idx = lower - 1 - ticks.begin();
459         } else {
460             idx = boost::none;
461         }
462     } else if (matching == PositionMatch::Less &amp;&amp; *lower &gt;= position) {
463         if ((lower - 1) &gt;= ticks.begin()) {
464             idx = lower - 1 - ticks.begin();
465         } else {
466             idx = boost::none;
467         }
468     } else {         if (lower != ticks.end() &amp;&amp; *lower == position) {
469             idx = lower - ticks.begin();
470         }
471     }
472     return idx;
473 }
474 boost::optional&lt;ndsize_t&gt; RangeDimension::indexOf(const double position, PositionMatch matching) const {
475     vector&lt;double&gt; ticks = this-&gt;ticks();
476     boost::optional&lt;ndsize_t&gt; index = getIndex(position, ticks, matching);
477     return index;
478 }
479 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; RangeDimension::indexOf(double start, double end,
480                                                                        std::vector&lt;double&gt; ticks,
481                                                                        RangeMatch match) const {
482     if (ticks.size() == 0) {
483         ticks = this-&gt;ticks();
484     }
485     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
486     if (start &gt; end){
487         return range;
488     }
489     boost::optional&lt;ndsize_t&gt; si = getIndex(start, ticks, PositionMatch::GreaterOrEqual);
490     if (!si) {
491         return range;
492     }
493     PositionMatch endMatching = (match == RangeMatch::Inclusive) ? PositionMatch::LessOrEqual : PositionMatch::Less;
494     boost::optional&lt;ndsize_t&gt; ei = getIndex(end, ticks, endMatching);
495     if (ei &amp;&amp; *si &lt;= *ei) {
496         range = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
497     }
498     return range;
499 }
500 ndsize_t RangeDimension::indexOf(const double position, bool less_or_equal) const {
501     vector&lt;double&gt; ticks = this-&gt;ticks();
502     PositionMatch matching = less_or_equal ? PositionMatch::LessOrEqual : PositionMatch::GreaterOrEqual;
503     boost::optional&lt;ndsize_t&gt; index = getIndex(position, ticks, matching);
504     if (index)
505         return *index;
506     else
507         throw nix::OutOfBounds(&quot;RangeDimension::indexOf: Position is out of bounds.&quot;);
508 }
509 pair&lt;ndsize_t, ndsize_t&gt; RangeDimension::indexOf(const double start, const double end) const {
510     vector&lt;double&gt; ticks = this-&gt;ticks();
511     boost::optional&lt;ndsize_t&gt; si = getIndex(start, ticks, PositionMatch::GreaterOrEqual);
512     boost::optional&lt;ndsize_t&gt; ei = getIndex(end, ticks, PositionMatch::LessOrEqual);
513     if (!ei || !si) {
514         throw nix::OutOfBounds(&quot;RangeDimension::indexOf: start or end of range are out of Bounds!&quot;);
515     }
516     return std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);
517 }
518 std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; RangeDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
519                                                                    const std::vector&lt;double&gt; &amp;end_positions,
520                                                                    bool strict, RangeMatch match) const {
521     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; optionalIndices;
522     optionalIndices = indexOf(start_positions, end_positions, match);
523     std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; indices;
524     for(auto o: optionalIndices) {
525         if (o) {
526             indices.push_back(*o);
527         } else if(strict) {
528             throw nix::OutOfBounds(&quot;RangeDimension::indexOf: an invalid range was encountered.&quot;);
529         }
530     }
531     return indices;
532 }
533 std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; RangeDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
534                                                                                     const std::vector&lt;double&gt; &amp;end_positions,
535                                                                                     RangeMatch match) const {
536     if (start_positions.size() != end_positions.size()) {
537         throw runtime_error(&quot;Dimension::IndexOf - Number of start and end positions must match!&quot;);
538     }
539     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
540     vector&lt;double&gt; ticks = this-&gt;ticks();
541     for (size_t i = 0; i &lt; start_positions.size(); ++i) {
542         boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
543         range = this-&gt;indexOf(start_positions[i], end_positions[i], ticks, match);
544         indices.push_back(range);
545     }
546     return indices;
547 }
548 vector&lt;double&gt; RangeDimension::axis(const ndsize_t count, const ndsize_t startIndex) const {
549     size_t cnt = check::fits_in_size_t(count, &quot;Axis count exceeds memory (size larger than current system supports)&quot;);
550     vector&lt;double&gt; ticks = this-&gt;ticks(startIndex, cnt);
551     return ticks;
552 }
553 RangeDimension&amp; RangeDimension::operator=(const RangeDimension &amp;other) {
554     shared_ptr&lt;IRangeDimension&gt; tmp(other.impl());
555     if (impl() != tmp) {
556         std::swap(impl(), tmp);
557     }
558     return *this;
559 }
560 RangeDimension&amp; RangeDimension::operator=(const Dimension &amp;other) {
561     shared_ptr&lt;IRangeDimension&gt; tmp(dynamic_pointer_cast&lt;IRangeDimension&gt;(other.impl()));
562     if (other.dimensionType() != DimensionType::Range) {
563         throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
564                                           + &quot; to a RangeDimension&quot;, &quot;RangeDimension::operator=&quot;);
565     }
566     if (impl() != tmp) {
567         std::swap(impl(), tmp);
568     }
569     return *this;
570 }
571 DataFrameDimension::DataFrameDimension()
572     : ImplContainer()
573 {
574 }
575 DataFrameDimension::DataFrameDimension(const std::shared_ptr&lt;IDataFrameDimension&gt; &amp;p_impl)
576     : ImplContainer(p_impl)
577 {
578 }
579 DataFrameDimension::DataFrameDimension(std::shared_ptr&lt;IDataFrameDimension&gt; &amp;&amp;ptr)
580     : ImplContainer(std::move(ptr))
581 {
582 }
583 DataFrameDimension::DataFrameDimension(const DataFrameDimension &amp;other)
584     : ImplContainer(other)
585 {
586 }
587 boost::optional&lt;ndsize_t&gt; getDataFrameIndex(const double position, const ndsize_t tick_count, const PositionMatch match) {
588     boost::optional&lt;ndsize_t&gt; index;
589     if (position &lt; 0 &amp;&amp; (match != PositionMatch::Greater &amp;&amp; match != PositionMatch::GreaterOrEqual)) {
590         return index;
591     }
592     double tmp;
593     if (match == PositionMatch::Greater || match == PositionMatch::GreaterOrEqual) {
594         tmp = ceil(position);
595         if (tmp &lt; 0.0) {
596             tmp = 0.0;
597         }
598         bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
599         index = (match == PositionMatch::Greater &amp;&amp; equals) ? static_cast&lt;ndsize_t&gt;(tmp + 1) : static_cast&lt;ndsize_t&gt;(tmp);
600     } else if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
601         tmp = floor(position);
602         bool equals = fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon();
603         if (match == PositionMatch::Less &amp;&amp; equals) { 
604             if (tmp &gt;= 1) {
605                 index = static_cast&lt;ndsize_t&gt;(tmp - 1);
606             } 
607         } else {
608             index = static_cast&lt;ndsize_t&gt;(tmp);
609         }
610     } else {
611         tmp = round(position);
612         if (fabs(tmp - position) &lt;= numeric_limits&lt;double&gt;::epsilon()) {
613             index = static_cast&lt;ndsize_t&gt;(tmp);
614         }
615     }
616     if (index &amp;&amp; tick_count &gt; 0 &amp;&amp; *index &gt; tick_count - 1) {
617         if (match == PositionMatch::Less || match == PositionMatch::LessOrEqual) {
618             index = tick_count - 1;
619         } else {
620             index = boost::none;
621         }
622     }
623     return index;
624 }
625 boost::optional&lt;ndsize_t&gt; DataFrameDimension::indexOf(const double position, const PositionMatch pos_match) const {
626     ndsize_t tick_count = this-&gt;size();
627     return getDataFrameIndex(position, tick_count, pos_match);
628 }
629 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; DataFrameDimension::indexOf(double start, double end, ndsize_t tick_count, const RangeMatch match) const {
630     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; index;
631     if (start &gt; end) {
632         return index;
633     }
634     PositionMatch end_match = (match == RangeMatch::Inclusive ? PositionMatch::LessOrEqual : PositionMatch::Less);
635     boost::optional&lt;ndsize_t&gt; si = getDataFrameIndex(start, tick_count, PositionMatch::GreaterOrEqual);
636     boost::optional&lt;ndsize_t&gt; ei = getDataFrameIndex(end, tick_count, end_match);
637     if (si &amp;&amp; ei &amp;&amp; *si &lt;= *ei) {
638         index = std::pair&lt;ndsize_t, ndsize_t&gt;(*si, *ei);    
639     }
640     return index;
641 }
642 boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; DataFrameDimension::indexOf(double start, double end, const RangeMatch match) const {
643     ndsize_t tick_count = this-&gt;size();
644     return indexOf(start, end, tick_count, match);
645 }
646 std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; DataFrameDimension::indexOf(const std::vector&lt;double&gt; &amp;start_positions,
647                                                                                         const std::vector&lt;double&gt; &amp;end_positions,
648                                                                                         const RangeMatch match) const {
649     if (start_positions.size() != end_positions.size()) {
650         throw runtime_error(&quot;DataFrameDimension::IndexOf - Number of start and end positions must match!&quot;);
651     }
652     ndsize_t tick_count = this-&gt;size();
653     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; indices;
654     for (size_t i = 0; i &lt; start_positions.size(); ++i) {
655         indices.push_back(indexOf(start_positions[i], end_positions[i], tick_count, match));
656     }
657     return indices;
658 }
659 DataFrameDimension&amp; DataFrameDimension::operator=(const DataFrameDimension &amp;other) {
660     shared_ptr&lt;IDataFrameDimension&gt; tmp(other.impl());
661     if (impl() != tmp) {
662         std::swap(impl(), tmp);
663     }
664     return *this;
665 }
666 DataFrameDimension&amp; DataFrameDimension::operator=(const Dimension &amp;other) {
667     shared_ptr&lt;IDataFrameDimension&gt; tmp(dynamic_pointer_cast&lt;IDataFrameDimension&gt;(other.impl()));
668     if (other.dimensionType() != DimensionType::DataFrame) {
669         throw nix::IncompatibleDimensions(&quot;Cannot assign dimension of type &quot; + nix::util::dimTypeToStr(other.dimensionType())
670                                           + &quot; to a DataFrameDimension&quot;, &quot;DataFrameDimension::operator=&quot;);
671     }
672     if (impl() != tmp) {
673         std::swap(impl(), tmp);
674     }
675     return *this;
676 }
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
