
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.900816802800467%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.h</h3>
            <pre><code>1  #ifndef google_h
2  #define google_h
3  #include "net.h"
4  #include "mine.h"
5  ClassTPV(TGgSchRef, PGgSchRef, TGgSchRefV)
6  public:
7    TStr TitleStr;
8    TStrV AuthNmV;
9    TStr PubNm;
10    TStr YearStr;
11    TInt Citations;
12    TStr CitedByUrlStr;
13    UndefCopyAssign(TGgSchRef);
14  public:
15    TGgSchRef():
16      TitleStr(), AuthNmV(), PubNm(), YearStr(), Citations(), CitedByUrlStr(){}
17    TGgSchRef(
18     const TStr& _TitleStr, const TStrV& _AuthNmV,
19     const TStr& _PubNm, const TStr& _YearStr,
20     const int& _Citations, const TStr& _CitedByUrlStr):
21      TitleStr(_TitleStr), AuthNmV(_AuthNmV),
22      PubNm(_PubNm), YearStr(_YearStr),
23      Citations(_Citations), CitedByUrlStr(_CitedByUrlStr){}
24    static PGgSchRef New(
<span onclick='openModal()' class='match'>25     const TStr& TitleStr, const TStrV& AuthNmV,
26     const TStr& PubNm, const TStr& YearStr,
27     const int& Citations, const TStr& CitedByUrlStr){
28      return new TGgSchRef(TitleStr, AuthNmV, PubNm, YearStr, Citations, CitedByUrlStr);}
</span>29    ~TGgSchRef(){}
30    TGgSchRef(TSIn& SIn):
31      TitleStr(SIn), AuthNmV(SIn),
32      PubNm(SIn), YearStr(SIn),
33      Citations(SIn), CitedByUrlStr(SIn){}
34    static PGgSchRef Load(TSIn& SIn){return new TGgSchRef(SIn);}
35    void Save(TSOut& SOut){
36      TitleStr.Save(SOut); AuthNmV.Save(SOut);
37      PubNm.Save(SOut); YearStr.Save(SOut);
38      Citations.Save(SOut), CitedByUrlStr.Save(SOut);}
39    TMd5Sig GetMd5Sig() const;
40    static void GetAuthNmVPubStr(
41     const TStr& AuthVPubStr, TStrV& AuthNmV, TStr& PubNm, TStr& PubYearStr);
42    void SaveXml(FILE* fOut, const int& RefN=-1);
43  };
44  ClassTPV(TGgSchRSet, PGgSchRSet, TGgSchRSetV)
45  private:
46    TStr UrlStr;
47    TStr NextUrlStr;
48    TStr QueryStr;
49    TInt AllHits;
50    TGgSchRefV RefV;
51    UndefAssign(TGgSchRSet);
52  public:
53    TGgSchRSet():
54      UrlStr(), NextUrlStr(), QueryStr(), AllHits(), RefV(){}
55    TGgSchRSet(const TGgSchRSet& RSet):
56      UrlStr(RSet.UrlStr), NextUrlStr(RSet.NextUrlStr),
57      QueryStr(RSet.QueryStr), AllHits(RSet.AllHits), RefV(RSet.RefV){}
58    static PGgSchRSet New(){return new TGgSchRSet();}
59    static PGgSchRSet NewScholar(const TStr& UrlStr, const TStr& HtmlStr);
60    static PGgSchRSet NewScholar(const PWebPg& WebPg);
61    static PGgSchRSet New(const PGgSchRSet& RSet){
62      return new TGgSchRSet(*RSet);}
63    ~TGgSchRSet(){}
64    TGgSchRSet(TSIn& SIn):
65      UrlStr(SIn), NextUrlStr(SIn), QueryStr(SIn),
66      AllHits(SIn), RefV(SIn){}
67    static PGgSchRSet Load(TSIn& SIn){return new TGgSchRSet(SIn);}
68    void Save(TSOut& SOut){
69      UrlStr.Save(SOut); NextUrlStr.Save(SOut); QueryStr.Save(SOut);
70      AllHits.Save(SOut); RefV.Save(SOut);}
71    void PutUrlStr(const TStr& _UrlStr){UrlStr=_UrlStr;}
72    TStr GetUrlStr() const {return UrlStr;}
73    void PutNextUrlStr(const TStr& _NextUrlStr){NextUrlStr=_NextUrlStr;}
74    TStr GetNextUrlStr() const {return NextUrlStr;}
75    void PutQueryStr(const TStr& _QueryStr){QueryStr=_QueryStr;}
76    TStr GetQueryStr() const {return QueryStr;}
77    void PutAllHits(const int& _AllHits){AllHits=_AllHits;}
78    int GetAllHits() const {return AllHits;}
79    const TGgSchRefV& GetRefV() const {return RefV;}
80    int GetHits() const {return RefV.Len();}
81    void AddHit(const PGgSchRef& Ref){
82      RefV.Add(Ref);}
83    PGgSchRef GetHit(const int& HitN) const {
84      return RefV[HitN];}
85    void Merge(const PGgSchRSet& RSet);
86    void Trunc(const int& MxHits){
87      RefV.Trunc(MxHits);}
88    PBowDocBs GetBowDocBs() const;
89    static PGgSchRSet LoadBin(const TStr& FNm){
90      TFIn SIn(FNm); return Load(SIn);}
91    static void SaveBin(const TStr& FNm, const PGgSchRSet& GgSchRSet);
92    void SaveBin(const TStr& FNm){
93      TFOut SOut(FNm); Save(SOut);}
94    static void SaveXml(const TStr& FNm, const PGgSchRSet& GgSchRSet);
95    void SaveXml(const TStr& FNm);
96    static void LoadRSetsBin(const TStr& FNm, TGgSchRSetV& SchRSetV);
97    static void SaveRSetsBin(const TStr& FNm, TGgSchRSetV& SchRSetV);
98  };
99  ClassTP(TGgSchBs, PGgSchBs)
100  private:
101    THash<TMd5Sig, PGgSchRef> RefMd5ToRefH; 
102    THash<TMd5Sig, TMd5SigV> RefMd5ToRefMd5VH; 
103    THash<TMd5Sig, TBool> RefMd5ToRefCiteCrawlPH; 
104    TStrBoolH AuthNmToCrawlPH; 
105    TStrBoolH PubNmToCrawlPH; 
106  public:
107    TGgSchBs():
108      RefMd5ToRefH(), RefMd5ToRefMd5VH(), RefMd5ToRefCiteCrawlPH(),
109      AuthNmToCrawlPH(), PubNmToCrawlPH(){}
110    static PGgSchBs New(){return new TGgSchBs();}
111    TGgSchBs(TSIn& SIn):
112      RefMd5ToRefH(SIn), RefMd5ToRefMd5VH(SIn), RefMd5ToRefCiteCrawlPH(SIn),
113      AuthNmToCrawlPH(SIn), PubNmToCrawlPH(SIn){}
114    static PGgSchBs Load(TSIn& SIn){return new TGgSchBs(SIn);}
115    void Save(TSOut& SOut){
116      RefMd5ToRefH.Save(SOut); RefMd5ToRefMd5VH.Save(SOut);
117      RefMd5ToRefCiteCrawlPH.Save(SOut);
118      AuthNmToCrawlPH.Save(SOut); PubNmToCrawlPH.Save(SOut);}
119    void AddRef(const PGgSchRef& Ref);
120    void AddRSet(const PGgSchRSet& RSet);
121    TStr GetAuthNmToCrawl() const;
122    void SetAuthCrawled(const TStr& AuthNm);
123    int GetRefs() const {return RefMd5ToRefH.Len();}
124    PGgSchRef GetRef(const int& RefN) const {return RefMd5ToRefH[RefN];}
125    static PGgSchBs LoadBin(const TStr& FNm){
126      TFIn SIn(FNm); return Load(SIn);}
127    void SaveBin(const TStr& FNm){
128      TFOut SOut(FNm); Save(SOut);}
129    void SaveXml(const TStr& FNm);
130  };
131  ClassTPV(TRSet, PRSet, TRSetV)
132  private:
133    TStr UrlStr;
134    TStr NextUrlStr;
135    TStr QueryStr;
136    TInt AllHits;
137    TStrQuV UrlTitleSrcCtxQuV;
138    UndefAssign(TRSet);
139  public:
140    TRSet():
141      UrlStr(), NextUrlStr(), QueryStr(), AllHits(), UrlTitleSrcCtxQuV(){}
142    TRSet(const TRSet& RSet):
143      UrlStr(RSet.UrlStr), NextUrlStr(RSet.NextUrlStr),
144      QueryStr(RSet.QueryStr), AllHits(RSet.AllHits),
145      UrlTitleSrcCtxQuV(RSet.UrlTitleSrcCtxQuV){}
146    static PRSet New(){return new TRSet();}
147    static PRSet NewWeb(const TStr& UrlStr, const TStr& HtmlStr);
148    static PRSet NewWeb(const PWebPg& WebPg);
149    static PRSet NewNews(const TStr& UrlStr, const TStr& HtmlStr);
150    static PRSet NewNews(const PWebPg& WebPg);
151    static PRSet New(const PRSet& RSet){
152      return new TRSet(*RSet);}
153    ~TRSet(){}
154    TRSet(TSIn& SIn):
155      UrlStr(SIn), NextUrlStr(SIn), QueryStr(SIn),
156      AllHits(SIn), UrlTitleSrcCtxQuV(SIn){}
157    static PRSet Load(TSIn& SIn){return new TRSet(SIn);}
158    void Save(TSOut& SOut){
159      UrlStr.Save(SOut); NextUrlStr.Save(SOut); QueryStr.Save(SOut);
160      AllHits.Save(SOut); UrlTitleSrcCtxQuV.Save(SOut);}
161    void PutUrlStr(const TStr& _UrlStr){UrlStr=_UrlStr;}
162    TStr GetUrlStr() const {return UrlStr;}
163    void PutNextUrlStr(const TStr& _NextUrlStr){NextUrlStr=_NextUrlStr;}
164    TStr GetNextUrlStr() const {return NextUrlStr;}
165    void PutQueryStr(const TStr& _QueryStr){QueryStr=_QueryStr;}
166    TStr GetQueryStr() const {return QueryStr;}
167    void PutAllHits(const int& _AllHits){AllHits=_AllHits;}
168    int GetAllHits() const {return AllHits;}
169    const TStrQuV& GetUrlTitleSrcCtxQuV() const {return UrlTitleSrcCtxQuV;}
170    int GetHits() const {return UrlTitleSrcCtxQuV.Len();}
171    int GetHitN(const TStr& UrlStr, const bool& LcP=true) const;
172    void AddHit(const TStr& UrlStr, const TStr& TitleStr, const TStr& SrcNm, const TStr& CtxStr){
173      UrlTitleSrcCtxQuV.Add(TStrQu(UrlStr, TitleStr, SrcNm, CtxStr));}
174    void GetHit(const int& HitN, TStr& UrlStr, TStr& TitleStr, TStr& SrcNm, TStr& CtxStr) const {
175      UrlStr=UrlTitleSrcCtxQuV[HitN].Val1;
176      TitleStr=UrlTitleSrcCtxQuV[HitN].Val2;
177      SrcNm=UrlTitleSrcCtxQuV[HitN].Val3;
178      CtxStr=UrlTitleSrcCtxQuV[HitN].Val4;}
179    TStr GetHitUrlStr(const int& HitN) const {return UrlTitleSrcCtxQuV[HitN].Val1;}
180    TStr GetHitTitleStr(const int& HitN) const {return UrlTitleSrcCtxQuV[HitN].Val2;}
181    TStr GetHitSrcNm(const int& HitN) const {return UrlTitleSrcCtxQuV[HitN].Val3;}
182    TStr GetHitCtxStr(const int& HitN) const {return UrlTitleSrcCtxQuV[HitN].Val4;}
183    void Merge(const PRSet& RSet);
184    void Trunc(const int& MxHits){
185      UrlTitleSrcCtxQuV.Trunc(MxHits);}
186    PBowDocBs GetBowDocBs() const;
187    static PRSet LoadBin(const TStr& FNm){
188      TFIn SIn(FNm); return Load(SIn);}
189    static void SaveBin(const TStr& FNm, const PRSet& RSet);
190    void SaveBin(const TStr& FNm){
191      TFOut SOut(FNm); Save(SOut);}
192    static void SaveXml(const TStr& FNm, const PRSet& RSet);
193    void SaveXml(const TStr& FNm);
194    static void LoadRSetsBin(const TStr& FNm, TRSetV& RSetV);
195    static void SaveRSetsBin(const TStr& FNm, TRSetV& RSetV);
196  };
197  class TGgWebFetchSaver: public TWebPgFetch{
198  private:
199    TWebPgV WebPgV;
200    UndefDefaultCopyAssign(TGgWebFetchSaver);
201  public:
202    TGgWebFetchSaver(const int& _MxConns):
203      TWebPgFetch(){PutMxConns(_MxConns);}
204    void OnFetch(const int&, const PWebPg& WebPg);
205    void OnError(const int&, const TStr& MsgStr);
206    int GetWebPgs() const {return WebPgV.Len();}
207    PWebPg GetWebPg(const int& WebPgN) const {return WebPgV[WebPgN];}
208    PWebPg GetWebPg(const TStr& UrlStr) const;
209  };
210  ClassTPV(TGgFCrawl, PGgFCrawl, TGgFCrawlV)
211  private:
212    bool Ok;
213    TStr SrcUrlStr;
214    PWebPg SrcWebPg;
215    int SrcDId;
216    PRSet DstRSet;
217    THash<TStr, PWebPg> UrlStrToWebPgH;
218    PBowDocBs BowDocBs;
219    double SumSim;
220    TFltIntKdV SimDIdKdV;
221    UndefCopyAssign(TGgFCrawl);
222  public:
223    TGgFCrawl(): Ok(false){}
224    static PGgFCrawl New(){return new TGgFCrawl();}
225    bool IsOk() const {return Ok;}
226    static PGgFCrawl GetFCrawl(
227     const TStr& UrlStr, const int& MxCands=-1, const TStr& ProxyStr="");
228    void SaveXml(const TStr& FNm, const bool& SaveDocP=false);
229    void SaveTxt(const TStr& FNm);
230  };
231  ClassTPV(TGgCtxGraph, PGgCtxGraph, TGgCtxGraphV)
232  private:
233    bool Ok;
234    TStr FocusUrlStr;
235    PWebPg FocusWebPg;
236    TStrPrV InUrlCtxStrPrV;
237    TStrPrV OutUrlCtxStrPrV;
238    UndefCopyAssign(TGgCtxGraph);
239  public:
240    TGgCtxGraph(): Ok(false){}
241    static PGgCtxGraph New(){return new TGgCtxGraph();}
242    bool IsOk() const {return Ok;}
243    static PGgCtxGraph GetCtxGraph(const TStr& UrlStr);
244    void SaveXml(const TStr& FNm, const bool& SaveDocP=false);
245    void SaveTxt(const TStr& FNm);
246  };
247  #ifdef MIHA_BLAZ_DOTNET_PROXY
248  extern "C" __declspec(dllimport) char* fetchWebPage(const char* Url, const char* Proxy);
249  #endif
250  ClassTP(TGg, PGg)
251  public:
252    static TStr GetWebSearchUrlStr(const TStr& QueryStr);
253    static TStr GetNewsSearchUrlStr(const TStr& QueryStr);
254    static TStr GetScholarSearchUrlStr(const TStr& QueryStr);
255    static TStr GetScholarAuthorSearchUrlStr(const TStr& QueryStr);
256    static TStr GetScholarPublicationSearchUrlStr(const TStr& QueryStr);
257    static PRSet WebSearch(const TStr& QueryStr, const int& MxHits=-1,
258     const PNotify& Notify=NULL, const TStr& ProxyStr="");
259    static PRSet WebSearchExternal(
260     const TStr& QueryStr, const int& MxHits=-1, const PNotify& Notify=NULL,
261     const TStr& ProxyStr = "");
262  #ifdef MIHA_BLAZ_DOTNET_PROXY
263    static PRSet WebSearchProxy(const TStr& QueryStr, const int& MxHits=-1,
264     const PNotify& Notify=NULL, const TStr& ProxyStr="");
265  #endif
266    static PRSet NewsSearch(const TStr& QueryStr, const PNotify& Notify=NULL);
267    static PGgSchRSet _ScholarSearch(const TStr& SearchUrlStr, const PNotify& Notify=NULL);
268    static PGgSchRSet ScholarSearch(const TStr& QueryStr, const PNotify& Notify=NULL);
269    static PGgSchRSet ScholarAuthorSearch(const TStr& AuthorNm, const PNotify& Notify=NULL);
270    static PGgSchRSet ScholarPublicationSearch(const TStr& PublicationNm, const PNotify& Notify=NULL);
271  };
272  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</h3>
            <pre><code>1  #ifndef MMNET_H
2  #define MMNET_H
3  class TMMNet;
4  typedef TPt<TMMNet> PMMNet;
5  class TModeNet;
6  class TCrossNet;
7  class TModeNet : public TNEANet {
8  public:
9    typedef TModeNet TNetMM;
10  public:
11    class TNodeI : public TNEANet::TNodeI {
12    public:
13      TNodeI() : TNEANet::TNodeI() { }
14      TNodeI(const THashIter& NodeHIter, const TModeNet* GraphPt) : TNEANet::TNodeI(NodeHIter, GraphPt) { }
15      TNodeI(const TNodeI& NodeI) : TNEANet::TNodeI(NodeI) { }
16      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
17      TNodeI& operator++ (int) { NodeHI++; return *this; }
18      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
19      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
20      void GetNeighborsByCrossNet(TStr& Name, TIntV& Neighbors, const bool isOutEId=false) {
21          const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetNeighborsByCrossNet(GetId(), Name, Neighbors, isOutEId); }
22      void GetCrossNetNames(TStrV& Names) { const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetCrossNetNames(Names); }
23      friend class TModeNet;
24    };
25  private:
26    TInt ModeId;
27    TMMNet *MMNet; 
28    THash<TStr, TBool> NeighborTypes; 
29  public:
30    TModeNet() : TNEANet(), ModeId(-1), MMNet(), NeighborTypes() { }
31    TModeNet(const int& TypeId) : TNEANet(), ModeId(TypeId), MMNet(), NeighborTypes() { }
32    explicit TModeNet(const int& Nodes, const int& Edges) : TNEANet(Nodes, Edges),
33      ModeId(-1), MMNet(), NeighborTypes(){ }
34    explicit TModeNet(const int& Nodes, const int& Edges, const int& TypeId) : TNEANet(Nodes, Edges),
35      ModeId(TypeId), MMNet(), NeighborTypes() { }
36    TModeNet(const TModeNet& Graph) :  TNEANet(true, Graph), ModeId(Graph.ModeId), MMNet(Graph.MMNet), NeighborTypes(Graph.NeighborTypes) { }
37    TModeNet(TSIn& SIn) : TNEANet(SIn), ModeId(SIn), MMNet(), NeighborTypes(SIn) { }
38  private:
39    TModeNet(const TModeNet& Graph, bool isSubModeGraph) : TNEANet(Graph, isSubModeGraph), ModeId(Graph.ModeId), MMNet(), NeighborTypes() {}
40  public:
41    void Save(TSOut& SOut) const {
42      TNEANet::Save(SOut); ModeId.Save(SOut); NeighborTypes.Save(SOut); SOut.Flush(); }
43    void LoadShM(TShMIn & ShMIn) {
44      TNEANet::LoadNetworkShM(ShMIn);
45      ModeId = TInt(ShMIn);
46      MMNet = NULL;
47      NeighborTypes.LoadShM(ShMIn);
48    }
49    void DelNode(const int& NId);
50    void GetCrossNetNames(TStrV& Names) const { NeighborTypes.GetKeyV(Names); }
51    void GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId=false) const;
52    TNodeI BegMMNI() const { return TNodeI(NodeH.BegI(), this); }
53    TNodeI EndMMNI() const { return TNodeI(NodeH.EndI(), this); }
54    TNodeI GetMMNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
55    void Clr();
56    TModeNet& operator = (const TModeNet& Graph) { 
57      if (this!=&Graph) {
58        MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH;
59        KeyToIndexTypeN=Graph.KeyToIndexTypeN; KeyToIndexTypeE=Graph.KeyToIndexTypeE;
60        KeyToDenseN = Graph.KeyToDenseN; KeyToDenseE = Graph.KeyToDenseE;
61        IntDefaultsN=Graph.IntDefaultsN; IntDefaultsE=Graph.IntDefaultsE; StrDefaultsN=Graph.StrDefaultsN; StrDefaultsE=Graph.StrDefaultsE;
62        FltDefaultsN=Graph.FltDefaultsN; FltDefaultsE=Graph.FltDefaultsE; VecOfIntVecsN=Graph.VecOfIntVecsN; VecOfIntVecsE=Graph.VecOfIntVecsE;
63        VecOfStrVecsN=Graph.VecOfStrVecsN; VecOfStrVecsE=Graph.VecOfStrVecsE; VecOfFltVecsN=Graph.VecOfFltVecsN; VecOfFltVecsE=Graph.VecOfFltVecsE;
64        VecOfIntVecVecsN=Graph.VecOfIntVecVecsN; VecOfIntVecVecsE=Graph.VecOfIntVecVecsE; 
65        VecOfIntHashVecsN = Graph.VecOfIntHashVecsN; VecOfIntHashVecsE = Graph.VecOfIntHashVecsE; SAttrN=Graph.SAttrN; SAttrE=Graph.SAttrE;
66        ModeId=Graph.ModeId; MMNet=Graph.MMNet; NeighborTypes=Graph.NeighborTypes;
67      }
68      return *this; 
69    }
70  private:
71    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const int linkId, const bool sameMode, bool isDir);
72    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const TStr& linkName, const bool sameMode, bool isDir);
73    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir);
74    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir);
75    TStr GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const;
76    void SetParentPointer(TMMNet* parent);
77    int AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir);
78    int AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense=true);
79    int AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs);
80    void RemoveCrossNets(TModeNet& Result, TStrV& CrossNets);
81    int DelNbrType(const TStr& CrossName);
82    int GetAttrTypeN(const TStr& attr) const;
83    void ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir);
84  public:
85    friend class TMMNet;
86    friend class TCrossNet;
87  };
88  class TCrossNet {
89  public:
90    class TCrossEdge {
91    private:
92      TInt EId;
93      TInt SrcNId, DstNId;
94    public:
95      TCrossEdge() : EId(-1), SrcNId(-1), DstNId(-1) { }
96      TCrossEdge(const int& Id, const int& SourceNId, const int& DestNId) :
97        EId(Id), SrcNId(SourceNId), DstNId(DestNId) { }
98      TCrossEdge(const TCrossEdge& MultiEdge) : EId(MultiEdge.EId), SrcNId(MultiEdge.SrcNId),
99          DstNId(MultiEdge.DstNId) { }
100      TCrossEdge(TSIn& SIn) : EId(SIn), SrcNId(SIn), DstNId(SIn) { }
101      void Save(TSOut& SOut) const { EId.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
102      int GetId() const { return EId; }
103      int GetSrcNId() const { return SrcNId; }
104      int GetDstNId() const { return DstNId; }
105      size_t GetMemUsed() const { return EId.GetMemUsed() + SrcNId.GetMemUsed() + DstNId.GetMemUsed(); }
106      friend class TCrossNet;
107    };
108    class TCrossEdgeI {
109    private:
110      typedef THash<TInt, TCrossEdge>::TIter THashIter;
111      THashIter CrossHI;
112      const TCrossNet *Graph;
113    public:
114      TCrossEdgeI() : CrossHI(), Graph(NULL) { }
115      TCrossEdgeI(const THashIter& CrossHIter, const TCrossNet *GraphPt) : CrossHI(CrossHIter), Graph(GraphPt) { }
116      TCrossEdgeI(const TCrossEdgeI& EdgeI) : CrossHI(EdgeI.CrossHI), Graph(EdgeI.Graph) { }
117      TCrossEdgeI& operator = (const TCrossEdgeI& EdgeI) { if (this!=&EdgeI) { CrossHI=EdgeI.CrossHI; Graph=EdgeI.Graph; }  return *this; }
118      TCrossEdgeI& operator++ (int) { CrossHI++; return *this; }
119      bool operator < (const TCrossEdgeI& EdgeI) const { return CrossHI < EdgeI.CrossHI; }
120      bool operator == (const TCrossEdgeI& EdgeI) const { return CrossHI == EdgeI.CrossHI; }
121      int GetId() const { return CrossHI.GetDat().GetId(); }
122      int GetSrcNId() const { return CrossHI.GetDat().GetSrcNId(); }
123      int GetDstNId() const { return CrossHI.GetDat().GetDstNId(); }
124      int GetSrcModeId() const { return Graph->GetMode1(); }
125      int GetDstModeId() const { return Graph->GetMode2(); }
126      bool IsDirected() const { return Graph->IsDirected(); }
127      friend class TCrossNet;
128    };
129    class TAIntI {
130    private:
131      typedef TIntV::TIter TIntVecIter;
132      TIntVecIter HI;
133      TStr attr;
134      const TCrossNet *Graph;
135    public:
136      TAIntI() : HI(), attr(), Graph(NULL) { }
137      TAIntI(const TIntVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
138      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
139      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
140      bool operator < (const TAIntI& I) const { return HI < I.HI; }
141      bool operator == (const TAIntI& I) const { return HI == I.HI; }
142      TInt GetDat() const { return HI[0]; }
143      bool IsDeleted() const { return GetDat() == Graph->GetIntAttrDefaultE(attr); };
144      TAIntI& operator++(int) { HI++; return *this; }
145      friend class TCrossNet;
146    };
147    class TAStrI {
148    private:
149      typedef TStrV::TIter TStrVecIter;
150      TStrVecIter HI;
151      TStr attr;
152      const TCrossNet *Graph;
153    public:
154      TAStrI() : HI(), attr(), Graph(NULL) { }
155      TAStrI(const TStrVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
156      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
157      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
158      bool operator < (const TAStrI& I) const { return HI < I.HI; }
159      bool operator == (const TAStrI& I) const { return HI == I.HI; }
160      TStr GetDat() const { return HI[0]; }
161      bool IsDeleted() const { return GetDat() == Graph->GetStrAttrDefaultE(attr); };
162      TAStrI& operator++(int) { HI++; return *this; }
163      friend class TCrossNet;
164    };
165    class TAFltI {
166    private:
167      typedef TFltV::TIter TFltVecIter;
168      TFltVecIter HI;
169      TStr attr;
170      const TCrossNet *Graph;
171    public:
172      TAFltI() : HI(), attr(), Graph(NULL) { }
173      TAFltI(const TFltVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
174      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
175      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
176      bool operator < (const TAFltI& I) const { return HI < I.HI; }
177      bool operator == (const TAFltI& I) const { return HI == I.HI; }
178      TFlt GetDat() const { return HI[0]; }
179      bool IsDeleted() const { return GetDat() == Graph->GetFltAttrDefaultE(attr); };
180      TAFltI& operator++(int) { HI++; return *this; }
181      friend class TCrossNet;
182    };
183  private:
184    class TLoadVecInit {
185    public:
186      TLoadVecInit() {}
187      template<typename TElem>
188      void operator() (TVec<TElem>* Node, TShMIn& ShMIn) {
189        Node->LoadShM(ShMIn);
190      }
191    };
192  private:
193    THash<TInt,TCrossEdge> CrossH; 
194    TInt MxEId;
195    TInt Mode1; 
196    TInt Mode2; 
197    TBool IsDirect;
198    TInt CrossNetId;
199    TMMNet* Net;
200    TStrIntPrH KeyToIndexTypeE;
201    THash<TStr, TInt> IntDefaultsE;
202    THash<TStr, TStr> StrDefaultsE;
203    THash<TStr, TFlt> FltDefaultsE;
204    TVec<TIntV> VecOfIntVecsE;
205    TVec<TStrV> VecOfStrVecsE;
206    TVec<TFltV> VecOfFltVecsE;
207    enum { IntType, StrType, FltType };
208  public:
209    TCrossNet() : CrossH(), MxEId(0), Mode1(-1), Mode2(-1), IsDirect(), CrossNetId(), Net(), KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(),
210      FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
211    TCrossNet(TInt MId1, TInt MId2, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(true),CrossNetId(LId), Net(),
212      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
213    TCrossNet(TInt MId1, TInt MId2, TBool IsDir, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(IsDir),CrossNetId(LId), Net(),
214      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
215    TCrossNet(TSIn& SIn) : CrossH(SIn), MxEId(SIn), Mode1(SIn), Mode2(SIn), IsDirect(SIn), CrossNetId(SIn), Net(),
216      KeyToIndexTypeE(SIn), IntDefaultsE(SIn), StrDefaultsE(SIn), FltDefaultsE(SIn), VecOfIntVecsE(SIn), VecOfStrVecsE(SIn), VecOfFltVecsE(SIn) {}
217    TCrossNet(const TCrossNet& OtherTCrossNet) : CrossH(OtherTCrossNet.CrossH), MxEId(OtherTCrossNet.MxEId), Mode1(OtherTCrossNet.Mode1),
218      Mode2(OtherTCrossNet.Mode2), IsDirect(OtherTCrossNet.IsDirect), CrossNetId(OtherTCrossNet.CrossNetId),Net(OtherTCrossNet.Net), KeyToIndexTypeE(OtherTCrossNet.KeyToIndexTypeE), 
219      IntDefaultsE(OtherTCrossNet.IntDefaultsE), StrDefaultsE(OtherTCrossNet.StrDefaultsE), FltDefaultsE(OtherTCrossNet.FltDefaultsE), VecOfIntVecsE(OtherTCrossNet.VecOfIntVecsE),
220      VecOfStrVecsE(OtherTCrossNet.VecOfStrVecsE), VecOfFltVecsE(OtherTCrossNet.VecOfFltVecsE) {}
221    TCrossNet& operator=(const TCrossNet& OtherTCrossNet) {
222      CrossH = OtherTCrossNet.CrossH;
223      MxEId = OtherTCrossNet.MxEId;
224      Mode1 = OtherTCrossNet.Mode1;
225      Mode2 = OtherTCrossNet.Mode2;
226      CrossNetId = OtherTCrossNet.CrossNetId;
227      IsDirect = OtherTCrossNet.IsDirect;
228      Net = OtherTCrossNet.Net;
229      KeyToIndexTypeE = OtherTCrossNet.KeyToIndexTypeE;
230      IntDefaultsE = OtherTCrossNet.IntDefaultsE;
231      StrDefaultsE = OtherTCrossNet.StrDefaultsE;
232      FltDefaultsE = OtherTCrossNet.FltDefaultsE;
233      VecOfIntVecsE = OtherTCrossNet.VecOfIntVecsE;
234      VecOfStrVecsE = OtherTCrossNet.VecOfStrVecsE;
235      VecOfFltVecsE = OtherTCrossNet.VecOfFltVecsE;
236      return *this;
237    }
238  private:
239    void SetParentPointer(TMMNet* parent);
240    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
241    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
242    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
243    int GetAttrTypeE(const TStr& attr) const;
244    TCrossEdge& GetEdge(int eid) { return CrossH[eid]; }
245  public:
246    bool IsEdge(const int& EId) const { return CrossH.IsKey(EId); }
247    int GetMxEId() const { return MxEId; }
248    int GetEdges() const { return CrossH.Len(); }
249    void Clr();
250    int AddEdge(const int& sourceNId, const int& destNId, int EId=-1);
251    TCrossEdgeI GetEdgeI(const int& EId) const { return TCrossEdgeI(CrossH.GetI(EId), this); }
252    TCrossEdgeI BegEdgeI() const { return TCrossEdgeI(CrossH.BegI(), this); }
253    TCrossEdgeI EndEdgeI() const { return TCrossEdgeI(CrossH.EndI(), this); }
254    int DelEdge(const int& EId);
255    int GetMode1() const { return Mode1; }
256    int GetMode2() const {return Mode2; }
257    void Save(TSOut& SOut) const { CrossH.Save(SOut); MxEId.Save(SOut); Mode1.Save(SOut); Mode2.Save(SOut); IsDirect.Save(SOut); CrossNetId.Save(SOut); 
258      KeyToIndexTypeE.Save(SOut); IntDefaultsE.Save(SOut); StrDefaultsE.Save(SOut); FltDefaultsE.Save(SOut); VecOfIntVecsE.Save(SOut);
259      VecOfStrVecsE.Save(SOut); VecOfFltVecsE.Save(SOut); SOut.Flush(); }
260    void LoadShM(TShMIn& ShMIn) {
261      CrossH.LoadShM(ShMIn);
262      MxEId = TInt(ShMIn);
263      Mode1 = TInt(ShMIn);
264      Mode2 = TInt(ShMIn);
265      IsDirect = TBool(ShMIn);
266      CrossNetId = TInt(ShMIn);
267      Net = NULL;
268      KeyToIndexTypeE.LoadShM(ShMIn);
269      IntDefaultsE.LoadShM(ShMIn);
270      StrDefaultsE.LoadShM(ShMIn);
271      FltDefaultsE.LoadShM(ShMIn);
272      TLoadVecInit VecFn;
273      VecOfIntVecsE.LoadShM(ShMIn, VecFn);
274      VecOfStrVecsE.Load(ShMIn);
275      VecOfFltVecsE.Load(ShMIn);
276    }
277    bool IsDirected() const { return IsDirect;}
278    void AttrNameEI(const TInt& EId, TStrV& Names) const {
279      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
280    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
281    void AttrValueEI(const TInt& EId, TStrV& Values) const {
282      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
283    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
284    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
285      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
286    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
287    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
288      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
289    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const;
290    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
291      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
292    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
293    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
294      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
295    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
296    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
297      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
298    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
299    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
300      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
301    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const;
302    int AddIntAttrDatE(const TCrossEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeI.GetId(), value, attr); }
303    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
304    int AddStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeI.GetId(), value, attr); }
305    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
306    int AddFltAttrDatE(const TCrossEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeI.GetId(), value, attr); }
307    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
308    TInt GetIntAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetIntAttrDatE(EdgeI.GetId(), attr); }
309    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
310    TStr GetStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetStrAttrDatE(EdgeI.GetId(), attr); }
311    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
312    TFlt GetFltAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetFltAttrDatE(EdgeI.GetId(), attr); }
313    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
314    TAIntI BegEAIntI(const TStr& attr) const {
315      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
316    }
317    TAIntI EndEAIntI(const TStr& attr) const {
318      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
319    }
320    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
321      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
322    }
323    TAStrI BegEAStrI(const TStr& attr) const {
324      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);   }
325    TAStrI EndEAStrI(const TStr& attr) const {
326      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
327    }
328    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
329      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
330    }
331    TAFltI BegEAFltI(const TStr& attr) const {
332      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
333    }
334    TAFltI EndEAFltI(const TStr& attr) const {
335      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
336    }
337    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
338      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
339    }
340    int DelAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return DelAttrDatE(EdgeI.GetId(), attr); } 
341    int DelAttrDatE(const int& EId, const TStr& attr); 
342    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
343    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
344    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
345    int DelAttrE(const TStr& attr);
346    bool IsAttrDeletedE(const int& EId, const TStr& attr) const;
347    bool IsIntAttrDeletedE(const int& EId, const TStr& attr) const;
348    bool IsStrAttrDeletedE(const int& EId, const TStr& attr) const;
349    bool IsFltAttrDeletedE(const int& EId, const TStr& attr) const;
350    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
351    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
352    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
353    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
354    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
355    friend class TMMNet;
356    friend class TModeNet;
357  };
358  class TMMNet {
359  public:
360    class TModeNetI {
361    protected:
362      typedef THash<TInt, TModeNet>::TIter THashIter;
363      THashIter ModeNetHI;
364      const TMMNet *Graph;
365    public:
366      TModeNetI() : ModeNetHI(), Graph(NULL) { }
367      TModeNetI(const THashIter& ModeNetHIter, const TMMNet* GraphPt) : ModeNetHI(ModeNetHIter), Graph(GraphPt) { }
368      TModeNetI(const TModeNetI& ModeNetI) : ModeNetHI(ModeNetI.ModeNetHI), Graph(ModeNetI.Graph) { }
369      TModeNetI& operator = (const TModeNetI& ModeNetI) { ModeNetHI = ModeNetI.ModeNetHI; Graph=ModeNetI.Graph; return *this; }
370      TModeNetI& operator++ (int) { ModeNetHI++; return *this; }
371      bool operator < (const TModeNetI& ModeNetI) const { return ModeNetHI < ModeNetI.ModeNetHI; }
372      bool operator == (const TModeNetI& ModeNetI) const { return ModeNetHI == ModeNetI.ModeNetHI; }
373      int GetModeId() { return ModeNetHI.GetKey(); }
374      TStr GetModeName() { return Graph->GetModeName(ModeNetHI.GetKey()); }
375      TModeNet& GetModeNet() { return Graph->GetModeNetById(GetModeId()); }
376      friend class TMMNet;
377    };
378    class TCrossNetI {
379    protected:
380      typedef THash<TInt, TCrossNet>::TIter THashIter;
381      THashIter CrossNetHI;
382      const TMMNet *Graph;
383    public:
384      TCrossNetI() : CrossNetHI(), Graph(NULL) { }
385      TCrossNetI(const THashIter& CrossNetHIter, const TMMNet* GraphPt) : CrossNetHI(CrossNetHIter), Graph(GraphPt) { }
386      TCrossNetI(const TCrossNetI& CrossNetI) : CrossNetHI(CrossNetI.CrossNetHI), Graph(CrossNetI.Graph) { }
387      TCrossNetI& operator = (const TCrossNetI& CrossNetI) { CrossNetHI = CrossNetI.CrossNetHI; Graph=CrossNetI.Graph; return *this; }
388      TCrossNetI& operator++ (int) { CrossNetHI++; return *this; }
389      bool operator < (const TCrossNetI& CrossNetI) const { return CrossNetHI < CrossNetI.CrossNetHI; }
390      bool operator == (const TCrossNetI& CrossNetI) const { return CrossNetHI == CrossNetI.CrossNetHI; }
391      int GetCrossId() { return CrossNetHI.GetKey(); }
392      TStr GetCrossName() { return Graph->GetCrossName(CrossNetHI.GetKey()); }
393      TCrossNet& GetCrossNet() { return Graph->GetCrossNetById(GetCrossId()); }
394      friend class TMMNet;
395    };
396  public:
397    TCRef CRef; 
398  private:
399    TInt MxModeId; 
400    TInt MxCrossNetId; 
401    THash<TInt, TModeNet> TModeNetH;
402    THash<TInt, TCrossNet> TCrossNetH;
403    THash<TInt,TStr> ModeIdToNameH;
404    THash<TStr,TInt> ModeNameToIdH;
405    THash<TInt,TStr> CrossIdToNameH;
406    THash<TStr,TInt> CrossNameToIdH;
407  public:
408    friend class TCrossNet;
409    friend class TModeNet;
410  private:
411    class TModeNetInit {
412    public:
413      TModeNetInit() {}
414      void operator() (TModeNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
415    };
416    class TCrossNetInit {
417    public:
418      TCrossNetInit() {}
419      void operator() (TCrossNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
420    };
421  private:
422    void LoadNetworkShM(TShMIn& ShMIn);
423  public:
424    TMMNet() : CRef(), MxModeId(0), MxCrossNetId(0), TModeNetH(), TCrossNetH(), ModeIdToNameH(), ModeNameToIdH(), CrossIdToNameH(), CrossNameToIdH() {}
425    TMMNet(const TMMNet& OtherTMMNet) : MxModeId(OtherTMMNet.MxModeId), MxCrossNetId(OtherTMMNet.MxCrossNetId), TModeNetH(OtherTMMNet.TModeNetH), 
426      TCrossNetH(OtherTMMNet.TCrossNetH), ModeIdToNameH(OtherTMMNet.ModeIdToNameH), ModeNameToIdH(OtherTMMNet.ModeNameToIdH), CrossIdToNameH(OtherTMMNet.CrossIdToNameH), CrossNameToIdH(OtherTMMNet.CrossNameToIdH) {}
427    TMMNet(TSIn& SIn) : MxModeId(SIn), MxCrossNetId(SIn), TModeNetH(SIn), TCrossNetH(SIn), ModeIdToNameH(SIn), ModeNameToIdH(SIn), CrossIdToNameH(SIn), CrossNameToIdH(SIn) { 
428      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
429        it.GetDat().SetParentPointer(this);
430      }
431      for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
432        it.GetDat().SetParentPointer(this);
433      }
434    }
435    int AddModeNet(const TStr& ModeName);
436    int DelModeNet(const TInt& ModeId); 
437    int DelModeNet(const TStr& ModeName);
438    int AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir=true);
439    int AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir=true);
440    int DelCrossNet(const TInt& CrossNetId);
441    int DelCrossNet(const TStr& CrossNet);
442    void Save(TSOut& SOut) const { MxModeId.Save(SOut); MxCrossNetId.Save(SOut); TModeNetH.Save(SOut); 
443      TCrossNetH.Save(SOut); ModeIdToNameH.Save(SOut); ModeNameToIdH.Save(SOut); CrossIdToNameH.Save(SOut);
444      CrossNameToIdH.Save(SOut); SOut.Flush(); }
445    static PMMNet Load(TSIn& SIn) { return PMMNet(new TMMNet(SIn)); }
446    static PMMNet LoadShM(TShMIn& ShMIn) {
447      TMMNet* Network = new TMMNet();
448      Network->LoadNetworkShM(ShMIn);
449      return PMMNet(Network);
450    }
451    static PMMNet New() { return PMMNet(new TMMNet()); }
452    void ConvertToSparse() {
453      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
454        it.GetDat().ConvertToSparse();
455      }
456    }
457    int GetModeId(const TStr& ModeName) const { if (ModeNameToIdH.IsKey(ModeName)) { return ModeNameToIdH.GetDat(ModeName); } else { return -1; }  }
458    TStr GetModeName(const TInt& ModeId) const { if (ModeIdToNameH.IsKey(ModeId)) { return ModeIdToNameH.GetDat(ModeId); } else {return TStr::GetNullStr();} }
459    int GetCrossId(const TStr& CrossName) const { if (CrossNameToIdH.IsKey(CrossName)) { return CrossNameToIdH.GetDat(CrossName); } else { return -1; }   }
460    TStr GetCrossName(const TInt& CrossId) const { if (CrossIdToNameH.IsKey(CrossId)) { return CrossIdToNameH.GetDat(CrossId); } else { return TStr::GetNullStr(); }  }
461    TModeNet& GetModeNetByName(const TStr& ModeName) const;
462    TModeNet& GetModeNetById(const TInt& ModeId) const;
<span onclick='openModal()' class='match'>463    TCrossNet& GetCrossNetByName(const TStr& CrossName) const;
464    TCrossNet& GetCrossNetById(const TInt& CrossId) const;
465    TCrossNetI GetCrossNetI(const int& Id) const { return TCrossNetI(TCrossNetH.GetI(Id), this); }
</span>466    TCrossNetI BegCrossNetI() const { return TCrossNetI(TCrossNetH.BegI(), this); }
467    TCrossNetI EndCrossNetI() const { return TCrossNetI(TCrossNetH.EndI(), this); }
468    TModeNetI GetModeNetI(const int& Id) const { return TModeNetI(TModeNetH.GetI(Id), this); }
469    TModeNetI BegModeNetI() const { return TModeNetI(TModeNetH.BegI(), this); }
470    TModeNetI EndModeNetI() const { return TModeNetI(TModeNetH.EndI(), this); }
471    int GetModeNets() { return TModeNetH.Len(); }
472    int GetCrossNets() { return TCrossNetH.Len(); }
473    PMMNet GetSubgraphByCrossNet(TStrV& CrossNetTypes);
474    PMMNet GetSubgraphByModeNet(TStrV& ModeNetTypes);
475    PNEANet ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap);
476    PNEANet ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap);
477    #ifdef GCC_ATOMIC
478    PNEANetMP ToNetworkMP(TStrV& CrossNetNames);
479    #endif 
480  private:
481    void ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir);
482    int AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet);
483    int AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet);
484    int AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId);
485    int AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId);
486    void GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxVal) const;
487  };
488  namespace TSnap {
489  template <> struct IsMultiGraph<TModeNet> { enum { Val = 1 }; };
490  template <> struct IsDirected<TModeNet> { enum { Val = 1 }; };
491  }
492  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-googlex.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</div>
                <div class="column column_space"><pre><code>25     const TStr& TitleStr, const TStrV& AuthNmV,
26     const TStr& PubNm, const TStr& YearStr,
27     const int& Citations, const TStr& CitedByUrlStr){
28      return new TGgSchRef(TitleStr, AuthNmV, PubNm, YearStr, Citations, CitedByUrlStr);}
</pre></code></div>
                <div class="column column_space"><pre><code>463    TCrossNet& GetCrossNetByName(const TStr& CrossName) const;
464    TCrossNet& GetCrossNetById(const TInt& CrossId) const;
465    TCrossNetI GetCrossNetI(const int& Id) const { return TCrossNetI(TCrossNetH.GetI(Id), this); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    