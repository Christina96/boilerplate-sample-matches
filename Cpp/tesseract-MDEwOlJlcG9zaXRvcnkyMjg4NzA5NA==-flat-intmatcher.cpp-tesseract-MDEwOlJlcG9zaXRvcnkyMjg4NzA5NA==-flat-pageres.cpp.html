
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.504885993485342%, Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intmatcher.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "intmatcher.h"
5  #include "classify.h"
6  #include "float2int.h"
7  #include "fontinfo.h"
8  #include "intproto.h"
9  #include "scrollview.h"
10  #include "shapetable.h"
11  #include "helpers.h"
12  #include <cassert>
13  #include <cmath>
14  namespace tesseract {
15  const float IntegerMatcher::kSEExponentialMultiplier = 0.0f;
16  const float IntegerMatcher::kSimilarityCenter = 0.0075f;
17  static const uint8_t offset_table[] = {
18      255, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
19      0,   1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0,
20      1,   0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1,
21      0,   3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
22      2,   0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,
23      0,   1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
24      1,   0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1,
25      0,   2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
26      3,   0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
27  static const uint8_t next_table[] = {
28      0,    0,    0,    0x2,  0,    0x4,  0x4,  0x6,  0,    0x8,  0x8,  0x0a, 0x08, 0x0c, 0x0c, 0x0e,
29      0,    0x10, 0x10, 0x12, 0x10, 0x14, 0x14, 0x16, 0x10, 0x18, 0x18, 0x1a, 0x18, 0x1c, 0x1c, 0x1e,
30      0,    0x20, 0x20, 0x22, 0x20, 0x24, 0x24, 0x26, 0x20, 0x28, 0x28, 0x2a, 0x28, 0x2c, 0x2c, 0x2e,
31      0x20, 0x30, 0x30, 0x32, 0x30, 0x34, 0x34, 0x36, 0x30, 0x38, 0x38, 0x3a, 0x38, 0x3c, 0x3c, 0x3e,
32      0,    0x40, 0x40, 0x42, 0x40, 0x44, 0x44, 0x46, 0x40, 0x48, 0x48, 0x4a, 0x48, 0x4c, 0x4c, 0x4e,
33      0x40, 0x50, 0x50, 0x52, 0x50, 0x54, 0x54, 0x56, 0x50, 0x58, 0x58, 0x5a, 0x58, 0x5c, 0x5c, 0x5e,
34      0x40, 0x60, 0x60, 0x62, 0x60, 0x64, 0x64, 0x66, 0x60, 0x68, 0x68, 0x6a, 0x68, 0x6c, 0x6c, 0x6e,
35      0x60, 0x70, 0x70, 0x72, 0x70, 0x74, 0x74, 0x76, 0x70, 0x78, 0x78, 0x7a, 0x78, 0x7c, 0x7c, 0x7e,
36      0,    0x80, 0x80, 0x82, 0x80, 0x84, 0x84, 0x86, 0x80, 0x88, 0x88, 0x8a, 0x88, 0x8c, 0x8c, 0x8e,
37      0x80, 0x90, 0x90, 0x92, 0x90, 0x94, 0x94, 0x96, 0x90, 0x98, 0x98, 0x9a, 0x98, 0x9c, 0x9c, 0x9e,
38      0x80, 0xa0, 0xa0, 0xa2, 0xa0, 0xa4, 0xa4, 0xa6, 0xa0, 0xa8, 0xa8, 0xaa, 0xa8, 0xac, 0xac, 0xae,
39      0xa0, 0xb0, 0xb0, 0xb2, 0xb0, 0xb4, 0xb4, 0xb6, 0xb0, 0xb8, 0xb8, 0xba, 0xb8, 0xbc, 0xbc, 0xbe,
40      0x80, 0xc0, 0xc0, 0xc2, 0xc0, 0xc4, 0xc4, 0xc6, 0xc0, 0xc8, 0xc8, 0xca, 0xc8, 0xcc, 0xcc, 0xce,
41      0xc0, 0xd0, 0xd0, 0xd2, 0xd0, 0xd4, 0xd4, 0xd6, 0xd0, 0xd8, 0xd8, 0xda, 0xd8, 0xdc, 0xdc, 0xde,
42      0xc0, 0xe0, 0xe0, 0xe2, 0xe0, 0xe4, 0xe4, 0xe6, 0xe0, 0xe8, 0xe8, 0xea, 0xe8, 0xec, 0xec, 0xee,
43      0xe0, 0xf0, 0xf0, 0xf2, 0xf0, 0xf4, 0xf4, 0xf6, 0xf0, 0xf8, 0xf8, 0xfa, 0xf8, 0xfc, 0xfc, 0xfe};
44  static void HeapSort(int n, int ra[], int rb[]) {
45    int i, rra, rrb;
46    int l, j, ir;
47    l = (n >> 1) + 1;
48    ir = n;
49    for (;;) {
50      if (l > 1) {
51        rra = ra[--l];
52        rrb = rb[l];
53      } else {
54        rra = ra[ir];
55        rrb = rb[ir];
56        ra[ir] = ra[1];
57        rb[ir] = rb[1];
58        if (--ir == 1) {
59          ra[1] = rra;
60          rb[1] = rrb;
61          return;
62        }
63      }
64      i = l;
65      j = l << 1;
66      while (j <= ir) {
67        if (j < ir && ra[j] < ra[j + 1]) {
68          ++j;
69        }
70        if (rra < ra[j]) {
71          ra[i] = ra[j];
72          rb[i] = rb[j];
73          j += (i = j);
74        } else {
75          j = ir + 1;
76        }
77      }
78      ra[i] = rra;
79      rb[i] = rrb;
80    }
81  }
82  class ClassPruner {
83  public:
84    ClassPruner(int max_classes) {
85      max_classes_ = max_classes;
86      rounded_classes_ =
87          RoundUp(max_classes, WERDS_PER_CP_VECTOR * BITS_PER_WERD / NUM_BITS_PER_CLASS);
88      class_count_ = new int[rounded_classes_];
89      norm_count_ = new int[rounded_classes_];
90      sort_key_ = new int[rounded_classes_ + 1];
91      sort_index_ = new int[rounded_classes_ + 1];
92      for (int i = 0; i < rounded_classes_; i++) {
93        class_count_[i] = 0;
94      }
95      pruning_threshold_ = 0;
96      num_features_ = 0;
97      num_classes_ = 0;
98    }
99    ~ClassPruner() {
100      delete[] class_count_;
101      delete[] norm_count_;
102      delete[] sort_key_;
103      delete[] sort_index_;
104    }
105    void ComputeScores(const INT_TEMPLATES_STRUCT *int_templates, int num_features,
106                       const INT_FEATURE_STRUCT *features) {
107      num_features_ = num_features;
108      auto num_pruners = int_templates->NumClassPruners;
109      for (int f = 0; f < num_features; ++f) {
110        const INT_FEATURE_STRUCT *feature = &features[f];
111        int x = feature->X * NUM_CP_BUCKETS >> 8;
112        int y = feature->Y * NUM_CP_BUCKETS >> 8;
113        int theta = feature->Theta * NUM_CP_BUCKETS >> 8;
114        int class_id = 0;
115        for (unsigned pruner_set = 0; pruner_set < num_pruners; ++pruner_set) {
116          const uint32_t *pruner_word_ptr = int_templates->ClassPruners[pruner_set]->p[x][y][theta];
<span onclick='openModal()' class='match'>117          for (int word = 0; word < WERDS_PER_CP_VECTOR; ++word) {
118            uint32_t pruner_word = *pruner_word_ptr++;
119            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
120            pruner_word >>= NUM_BITS_PER_CLASS;
121            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
122            pruner_word >>= NUM_BITS_PER_CLASS;
123            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
124            pruner_word >>= NUM_BITS_PER_CLASS;
125            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
126            pruner_word >>= NUM_BITS_PER_CLASS;
127            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
128            pruner_word >>= NUM_BITS_PER_CLASS;
129            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
</span>130            pruner_word >>= NUM_BITS_PER_CLASS;
131            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
132            pruner_word >>= NUM_BITS_PER_CLASS;
133            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
134            pruner_word >>= NUM_BITS_PER_CLASS;
135            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
136            pruner_word >>= NUM_BITS_PER_CLASS;
137            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
138            pruner_word >>= NUM_BITS_PER_CLASS;
139            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
140            pruner_word >>= NUM_BITS_PER_CLASS;
141            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
142            pruner_word >>= NUM_BITS_PER_CLASS;
143            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
144            pruner_word >>= NUM_BITS_PER_CLASS;
145            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
146            pruner_word >>= NUM_BITS_PER_CLASS;
147            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
148            pruner_word >>= NUM_BITS_PER_CLASS;
149            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
150          }
151        }
152      }
153    }
154    void AdjustForExpectedNumFeatures(const uint16_t *expected_num_features, int cutoff_strength) {
155      for (int class_id = 0; class_id < max_classes_; ++class_id) {
156        if (num_features_ < expected_num_features[class_id]) {
157          int deficit = expected_num_features[class_id] - num_features_;
158          class_count_[class_id] -=
159              class_count_[class_id] * deficit / (num_features_ * cutoff_strength + deficit);
160        }
161      }
162    }
163    void DisableDisabledClasses(const UNICHARSET &unicharset) {
164      for (int class_id = 0; class_id < max_classes_; ++class_id) {
165        if (!unicharset.get_enabled(class_id)) {
166          class_count_[class_id] = 0; 
167        }
168      }
169    }
170    void DisableFragments(const UNICHARSET &unicharset) {
171      for (int class_id = 0; class_id < max_classes_; ++class_id) {
172        if (unicharset.get_fragment(class_id)) {
173          class_count_[class_id] = 0;
174        }
175      }
176    }
177    void NormalizeForXheight(int norm_multiplier, const uint8_t *normalization_factors) {
178      for (int class_id = 0; class_id < max_classes_; class_id++) {
179        norm_count_[class_id] =
180            class_count_[class_id] - ((norm_multiplier * normalization_factors[class_id]) >> 8);
181      }
182    }
183    void NoNormalization() {
184      for (int class_id = 0; class_id < max_classes_; class_id++) {
185        norm_count_[class_id] = class_count_[class_id];
186      }
187    }
188    void PruneAndSort(int pruning_factor, int keep_this, bool max_of_non_fragments,
189                      const UNICHARSET &unicharset) {
190      int max_count = 0;
191      for (int c = 0; c < max_classes_; ++c) {
192        if (norm_count_[c] > max_count &&
193            (!max_of_non_fragments || !unicharset.get_fragment(c))) {
194          max_count = norm_count_[c];
195        }
196      }
197      pruning_threshold_ = (max_count * pruning_factor) >> 8;
198      if (pruning_threshold_ < 1) {
199        pruning_threshold_ = 1;
200      }
201      num_classes_ = 0;
202      for (int class_id = 0; class_id < max_classes_; class_id++) {
203        if (norm_count_[class_id] >= pruning_threshold_ || class_id == keep_this) {
204          ++num_classes_;
205          sort_index_[num_classes_] = class_id;
206          sort_key_[num_classes_] = norm_count_[class_id];
207        }
208      }
209      if (num_classes_ > 1) {
210        HeapSort(num_classes_, sort_key_, sort_index_);
211      }
212    }
213    void DebugMatch(const Classify &classify, const INT_TEMPLATES_STRUCT *int_templates,
214                    const INT_FEATURE_STRUCT *features) const {
215      int num_pruners = int_templates->NumClassPruners;
216      int max_num_classes = int_templates->NumClasses;
217      for (int f = 0; f < num_features_; ++f) {
218        const INT_FEATURE_STRUCT *feature = &features[f];
219        tprintf("F=%3d(%d,%d,%d),", f, feature->X, feature->Y, feature->Theta);
220        int x = feature->X * NUM_CP_BUCKETS >> 8;
221        int y = feature->Y * NUM_CP_BUCKETS >> 8;
222        int theta = feature->Theta * NUM_CP_BUCKETS >> 8;
223        int class_id = 0;
224        for (int pruner_set = 0; pruner_set < num_pruners; ++pruner_set) {
225          const uint32_t *pruner_word_ptr = int_templates->ClassPruners[pruner_set]->p[x][y][theta];
226          for (int word = 0; word < WERDS_PER_CP_VECTOR; ++word) {
227            uint32_t pruner_word = *pruner_word_ptr++;
228            for (int word_class = 0; word_class < 16 && class_id < max_num_classes;
229                 ++word_class, ++class_id) {
230              if (norm_count_[class_id] >= pruning_threshold_) {
231                tprintf(" %s=%d,", classify.ClassIDToDebugStr(int_templates, class_id, 0).c_str(),
232                        pruner_word & CLASS_PRUNER_CLASS_MASK);
233              }
234              pruner_word >>= NUM_BITS_PER_CLASS;
235            }
236          }
237          tprintf("\n");
238        }
239      }
240    }
241    void SummarizeResult(const Classify &classify, const INT_TEMPLATES_STRUCT *int_templates,
242                         const uint16_t *expected_num_features, int norm_multiplier,
243                         const uint8_t *normalization_factors) const {
244      tprintf("CP:%d classes, %d features:\n", num_classes_, num_features_);
245      for (int i = 0; i < num_classes_; ++i) {
246        int class_id = sort_index_[num_classes_ - i];
247        std::string class_string = classify.ClassIDToDebugStr(int_templates, class_id, 0);
248        tprintf(
249            "%s:Initial=%d, E=%d, Xht-adj=%d, N=%d, Rat=%.2f\n", class_string.c_str(),
250            class_count_[class_id], expected_num_features[class_id],
251            (norm_multiplier * normalization_factors[class_id]) >> 8, sort_key_[num_classes_ - i],
252            100.0 - 100.0 * sort_key_[num_classes_ - i] / (CLASS_PRUNER_CLASS_MASK * num_features_));
253      }
254    }
255    int SetupResults(std::vector<CP_RESULT_STRUCT> *results) const {
256      results->clear();
257      results->resize(num_classes_);
258      for (int c = 0; c < num_classes_; ++c) {
259        (*results)[c].Class = sort_index_[num_classes_ - c];
260        (*results)[c].Rating =
261            1.0f - sort_key_[num_classes_ - c] /
262                       (static_cast<float>(CLASS_PRUNER_CLASS_MASK) * num_features_);
263      }
264      return num_classes_;
265    }
266  private:
267    int *class_count_;
268    int *norm_count_;
269    int *sort_key_;
270    int *sort_index_;
271    int max_classes_;
272    int rounded_classes_;
273    int pruning_threshold_;
274    int num_features_;
275    int num_classes_;
276  };
277  int Classify::PruneClasses(const INT_TEMPLATES_STRUCT *int_templates, int num_features,
278                             int keep_this, const INT_FEATURE_STRUCT *features,
279                             const uint8_t *normalization_factors,
280                             const uint16_t *expected_num_features,
281                             std::vector<CP_RESULT_STRUCT> *results) {
282    ClassPruner pruner(int_templates->NumClasses);
283    pruner.ComputeScores(int_templates, num_features, features);
284    pruner.AdjustForExpectedNumFeatures(expected_num_features, classify_cp_cutoff_strength);
285    if (shape_table_ == nullptr) {
286      pruner.DisableDisabledClasses(unicharset);
287    }
288    if (disable_character_fragments && shape_table_ == nullptr) {
289      pruner.DisableFragments(unicharset);
290    }
291    if (normalization_factors != nullptr) {
292      pruner.NormalizeForXheight(classify_class_pruner_multiplier, normalization_factors);
293    } else {
294      pruner.NoNormalization();
295    }
296    pruner.PruneAndSort(classify_class_pruner_threshold, keep_this, shape_table_ == nullptr,
297                        unicharset);
298    if (classify_debug_level > 2) {
299      pruner.DebugMatch(*this, int_templates, features);
300    }
301    if (classify_debug_level > 1) {
302      pruner.SummarizeResult(*this, int_templates, expected_num_features,
303                             classify_class_pruner_multiplier, normalization_factors);
304    }
305    return pruner.SetupResults(results);
306  }
307  void IntegerMatcher::Match(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask, BIT_VECTOR ConfigMask,
308                             int16_t NumFeatures, const INT_FEATURE_STRUCT *Features,
309                             UnicharRating *Result, int AdaptFeatureThreshold, int Debug,
310                             bool SeparateDebugWindows) {
311    auto *tables = new ScratchEvidence();
312    int Feature;
313    if (MatchDebuggingOn(Debug)) {
314      tprintf("Integer Matcher -------------------------------------------\n");
315    }
316    tables->Clear(ClassTemplate);
317    Result->feature_misses = 0;
318    for (Feature = 0; Feature < NumFeatures; Feature++) {
319      int csum = UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature,
320                                        &Features[Feature], tables, Debug);
321      if (csum == 0) {
322        ++Result->feature_misses;
323      }
324    }
325  #ifndef GRAPHICS_DISABLED
326    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
327      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
328    }
329    if (DisplayProtoMatchesOn(Debug)) {
330      DisplayProtoDebugInfo(ClassTemplate, ConfigMask, *tables, SeparateDebugWindows);
331    }
332    if (DisplayFeatureMatchesOn(Debug)) {
333      DisplayFeatureDebugInfo(ClassTemplate, ProtoMask, ConfigMask, NumFeatures, Features,
334                              AdaptFeatureThreshold, Debug, SeparateDebugWindows);
335    }
336  #endif
337    tables->UpdateSumOfProtoEvidences(ClassTemplate, ConfigMask);
338    tables->NormalizeSums(ClassTemplate, NumFeatures);
339    FindBestMatch(ClassTemplate, *tables, Result);
340  #ifndef GRAPHICS_DISABLED
341    if (PrintMatchSummaryOn(Debug)) {
342      Result->Print();
343    }
344    if (MatchDebuggingOn(Debug)) {
345      tprintf("Match Complete --------------------------------------------\n");
346    }
347  #endif
348    delete tables;
349  }
350  int IntegerMatcher::FindGoodProtos(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
351                                     BIT_VECTOR ConfigMask, int16_t NumFeatures,
352                                     INT_FEATURE_ARRAY Features, PROTO_ID *ProtoArray,
353                                     int AdaptProtoThreshold, int Debug) {
354    auto *tables = new ScratchEvidence();
355    int NumGoodProtos = 0;
356    if (MatchDebuggingOn(Debug)) {
357      tprintf("Find Good Protos -------------------------------------------\n");
358    }
359    tables->Clear(ClassTemplate);
360    for (int Feature = 0; Feature < NumFeatures; Feature++) {
361      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &(Features[Feature]),
362                             tables, Debug);
363    }
364  #ifndef GRAPHICS_DISABLED
365    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
366      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
367    }
368  #endif
369    for (int proto = 0; proto < ClassTemplate->NumProtos; proto++) {
370      int Temp = 0;
371      for (uint8_t i = 0; i < MAX_PROTO_INDEX && i < ClassTemplate->ProtoLengths[proto]; i++) {
372        Temp += tables->proto_evidence_[proto][i];
373      }
374      Temp /= ClassTemplate->ProtoLengths[proto];
375      if (Temp >= AdaptProtoThreshold) {
376        *ProtoArray = proto;
377        ProtoArray++;
378        NumGoodProtos++;
379      }
380    }
381    if (MatchDebuggingOn(Debug)) {
382      tprintf("Match Complete --------------------------------------------\n");
383    }
384    delete tables;
385    return NumGoodProtos;
386  }
387  int IntegerMatcher::FindBadFeatures(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
388                                      BIT_VECTOR ConfigMask, int16_t NumFeatures,
389                                      INT_FEATURE_ARRAY Features, FEATURE_ID *FeatureArray,
390                                      int AdaptFeatureThreshold, int Debug) {
391    auto *tables = new ScratchEvidence();
392    int NumBadFeatures = 0;
393    if (MatchDebuggingOn(Debug)) {
394      tprintf("Find Bad Features -------------------------------------------\n");
395    }
396    tables->Clear(ClassTemplate);
397    for (int Feature = 0; Feature < NumFeatures; Feature++) {
398      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &Features[Feature],
399                             tables, Debug);
400      int best = 0;
401      assert(ClassTemplate->NumConfigs < MAX_NUM_CONFIGS);
402      for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
403        if (tables->feature_evidence_[i] > best) {
404          best = tables->feature_evidence_[i];
405        }
406      }
407      if (best < AdaptFeatureThreshold) {
408        *FeatureArray = Feature;
409        FeatureArray++;
410        NumBadFeatures++;
411      }
412    }
413  #ifndef GRAPHICS_DISABLED
414    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
415      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
416    }
417  #endif
418    if (MatchDebuggingOn(Debug)) {
419      tprintf("Match Complete --------------------------------------------\n");
420    }
421    delete tables;
422    return NumBadFeatures;
423  }
424  IntegerMatcher::IntegerMatcher(tesseract::IntParam *classify_debug_level)
425      : classify_debug_level_(classify_debug_level) {
426    for (int i = 0; i < SE_TABLE_SIZE; i++) {
427      uint32_t IntSimilarity = i << (27 - SE_TABLE_BITS);
428      double Similarity = (static_cast<double>(IntSimilarity)) / 65536.0 / 65536.0;
429      double evidence = Similarity / kSimilarityCenter;
430      evidence = 255.0 / (evidence * evidence + 1.0);
431      if (kSEExponentialMultiplier > 0.0) {
432        double scale =
433            1.0 - std::exp(-kSEExponentialMultiplier) *
434                      exp(kSEExponentialMultiplier * (static_cast<double>(i) / SE_TABLE_SIZE));
435        evidence *= ClipToRange(scale, 0.0, 1.0);
436      }
437      similarity_evidence_table_[i] = static_cast<uint8_t>(evidence + 0.5);
438    }
439    evidence_table_mask_ = ((1 << kEvidenceTableBits) - 1) << (9 - kEvidenceTableBits);
440    mult_trunc_shift_bits_ = (14 - kIntEvidenceTruncBits);
441    table_trunc_shift_bits_ = (27 - SE_TABLE_BITS - (mult_trunc_shift_bits_ << 1));
442    evidence_mult_mask_ = ((1 << kIntEvidenceTruncBits) - 1);
443  }
444  void ScratchEvidence::Clear(const INT_CLASS_STRUCT *class_template) {
445    memset(sum_feature_evidence_, 0, class_template->NumConfigs * sizeof(sum_feature_evidence_[0]));
446    memset(proto_evidence_, 0, class_template->NumProtos * sizeof(proto_evidence_[0]));
447  }
448  void ScratchEvidence::ClearFeatureEvidence(const INT_CLASS_STRUCT *class_template) {
449    memset(feature_evidence_, 0, class_template->NumConfigs * sizeof(feature_evidence_[0]));
450  }
451  static void IMDebugConfiguration(int FeatureNum, uint16_t ActualProtoNum, uint8_t Evidence,
452                                   uint32_t ConfigWord) {
453    tprintf("F = %3d, P = %3d, E = %3d, Configs = ", FeatureNum, static_cast<int>(ActualProtoNum),
454            static_cast<int>(Evidence));
455    while (ConfigWord) {
456      if (ConfigWord & 1) {
457        tprintf("1");
458      } else {
459        tprintf("0");
460      }
461      ConfigWord >>= 1;
462    }
463    tprintf("\n");
464  }
465  static void IMDebugConfigurationSum(int FeatureNum, uint8_t *FeatureEvidence, int32_t ConfigCount) {
466    tprintf("F=%3d, C=", FeatureNum);
467    for (int ConfigNum = 0; ConfigNum < ConfigCount; ConfigNum++) {
468      tprintf("%4d", FeatureEvidence[ConfigNum]);
469    }
470    tprintf("\n");
471  }
472  int IntegerMatcher::UpdateTablesForFeature(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
473                                             BIT_VECTOR ConfigMask, int FeatureNum,
474                                             const INT_FEATURE_STRUCT *Feature,
475                                             ScratchEvidence *tables, int Debug) {
476    uint32_t ConfigWord;
477    uint32_t ProtoWord;
478    uint32_t ProtoNum;
479    uint32_t ActualProtoNum;
480    uint8_t proto_byte;
481    int32_t proto_word_offset;
482    int32_t proto_offset;
483    PROTO_SET_STRUCT *ProtoSet;
484    uint32_t *ProtoPrunerPtr;
485    INT_PROTO_STRUCT *Proto;
486    int ProtoSetIndex;
487    uint8_t Evidence;
488    uint32_t XFeatureAddress;
489    uint32_t YFeatureAddress;
490    uint32_t ThetaFeatureAddress;
491    tables->ClearFeatureEvidence(ClassTemplate);
492    XFeatureAddress = ((Feature->X >> 2) << 1);
493    YFeatureAddress = (NUM_PP_BUCKETS << 1) + ((Feature->Y >> 2) << 1);
494    ThetaFeatureAddress = (NUM_PP_BUCKETS << 2) + ((Feature->Theta >> 2) << 1);
495    for (ProtoSetIndex = 0, ActualProtoNum = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
496         ProtoSetIndex++) {
497      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
498      ProtoPrunerPtr = reinterpret_cast<uint32_t *>((*ProtoSet).ProtoPruner);
499      for (ProtoNum = 0; ProtoNum < PROTOS_PER_PROTO_SET; ProtoNum += (PROTOS_PER_PROTO_SET >> 1),
500          ActualProtoNum += (PROTOS_PER_PROTO_SET >> 1), ProtoMask++, ProtoPrunerPtr++) {
501        ProtoWord = *(ProtoPrunerPtr + XFeatureAddress);
502        ProtoWord &= *(ProtoPrunerPtr + YFeatureAddress);
503        ProtoWord &= *(ProtoPrunerPtr + ThetaFeatureAddress);
504        ProtoWord &= *ProtoMask;
505        if (ProtoWord != 0) {
506          proto_byte = ProtoWord & 0xff;
507          ProtoWord >>= 8;
508          proto_word_offset = 0;
509          while (ProtoWord != 0 || proto_byte != 0) {
510            while (proto_byte == 0) {
511              proto_byte = ProtoWord & 0xff;
512              ProtoWord >>= 8;
513              proto_word_offset += 8;
514            }
515            proto_offset = offset_table[proto_byte] + proto_word_offset;
516            proto_byte = next_table[proto_byte];
517            Proto = &(ProtoSet->Protos[ProtoNum + proto_offset]);
518            ConfigWord = Proto->Configs[0];
519            int32_t A3 = (((Proto->A * (Feature->X - 128)) * 2) - (Proto->B * (Feature->Y - 128)) +
520                          (Proto->C * 512));
521            int32_t M3 = ((static_cast<int8_t>(Feature->Theta - Proto->Angle)) * kIntThetaFudge) * 2;
522            if (A3 < 0) {
523              A3 = ~A3;
524            }
525            if (M3 < 0) {
526              M3 = ~M3;
527            }
528            A3 >>= mult_trunc_shift_bits_;
529            M3 >>= mult_trunc_shift_bits_;
530            if (static_cast<uint32_t>(A3) > evidence_mult_mask_) {
531              A3 = evidence_mult_mask_;
532            }
533            if (static_cast<uint32_t>(M3) > evidence_mult_mask_) {
534              M3 = evidence_mult_mask_;
535            }
536            uint32_t A4 = (A3 * A3) + (M3 * M3);
537            A4 >>= table_trunc_shift_bits_;
538            if (A4 > evidence_table_mask_) {
539              Evidence = 0;
540            } else {
541              Evidence = similarity_evidence_table_[A4];
542            }
543            if (PrintFeatureMatchesOn(Debug)) {
544              IMDebugConfiguration(FeatureNum, ActualProtoNum + proto_offset, Evidence, ConfigWord);
545            }
546            ConfigWord &= *ConfigMask;
547            uint8_t feature_evidence_index = 0;
548            uint8_t config_byte = 0;
549            while (ConfigWord != 0 || config_byte != 0) {
550              while (config_byte == 0) {
551                config_byte = ConfigWord & 0xff;
552                ConfigWord >>= 8;
553                feature_evidence_index += 8;
554              }
555              const uint8_t config_offset = offset_table[config_byte] + feature_evidence_index - 8;
556              config_byte = next_table[config_byte];
557              if (Evidence > tables->feature_evidence_[config_offset]) {
558                tables->feature_evidence_[config_offset] = Evidence;
559              }
560            }
561            uint8_t ProtoIndex = ClassTemplate->ProtoLengths[ActualProtoNum + proto_offset];
562            if (ProtoIndex > MAX_PROTO_INDEX) {
563              ProtoIndex = MAX_PROTO_INDEX;
564            }
565            uint8_t *UINT8Pointer = &(tables->proto_evidence_[ActualProtoNum + proto_offset][0]);
566            for (; Evidence > 0 && ProtoIndex > 0; ProtoIndex--, UINT8Pointer++) {
567              if (Evidence > *UINT8Pointer) {
568                uint8_t Temp = *UINT8Pointer;
569                *UINT8Pointer = Evidence;
570                Evidence = Temp;
571              }
572            }
573          }
574        }
575      }
576    }
577    if (PrintFeatureMatchesOn(Debug)) {
578      IMDebugConfigurationSum(FeatureNum, tables->feature_evidence_, ClassTemplate->NumConfigs);
579    }
580    int *IntPointer = tables->sum_feature_evidence_;
581    uint8_t *UINT8Pointer = tables->feature_evidence_;
582    int SumOverConfigs = 0;
583    for (int ConfigNum = ClassTemplate->NumConfigs; ConfigNum > 0; ConfigNum--) {
584      int evidence = *UINT8Pointer++;
585      SumOverConfigs += evidence;
586      *IntPointer++ += evidence;
587    }
588    return SumOverConfigs;
589  }
590  #ifndef GRAPHICS_DISABLED
591  void IntegerMatcher::DebugFeatureProtoError(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
592                                              BIT_VECTOR ConfigMask, const ScratchEvidence &tables,
593                                              int16_t NumFeatures, int Debug) {
594    float ProtoConfigs[MAX_NUM_CONFIGS];
595    int ConfigNum;
596    uint32_t ConfigWord;
597    int ProtoSetIndex;
598    uint16_t ProtoNum;
599    uint8_t ProtoWordNum;
600    PROTO_SET_STRUCT *ProtoSet;
601    uint16_t ActualProtoNum;
602    if (PrintMatchSummaryOn(Debug)) {
603      tprintf("Configuration Mask:\n");
604      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
605        tprintf("%1d", (((*ConfigMask) >> ConfigNum) & 1));
606      }
607      tprintf("\n");
608      tprintf("Feature Error for Configurations:\n");
609      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
610        tprintf(" %5.1f", 100.0 * (1.0 - static_cast<float>(tables.sum_feature_evidence_[ConfigNum]) /
611                                             NumFeatures / 256.0));
612      }
613      tprintf("\n\n\n");
614    }
615    if (PrintMatchSummaryOn(Debug)) {
616      tprintf("Proto Mask:\n");
617      for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
618        ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
619        for (ProtoWordNum = 0; ProtoWordNum < 2; ProtoWordNum++, ProtoMask++) {
620          ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
621          for (ProtoNum = 0; ((ProtoNum < (PROTOS_PER_PROTO_SET >> 1)) &&
622                              (ActualProtoNum < ClassTemplate->NumProtos));
623               ProtoNum++, ActualProtoNum++) {
624            tprintf("%1d", (((*ProtoMask) >> ProtoNum) & 1));
625          }
626          tprintf("\n");
627        }
628      }
629      tprintf("\n");
630    }
631    for (int i = 0; i < ClassTemplate->NumConfigs; i++) {
632      ProtoConfigs[i] = 0;
633    }
634    if (PrintProtoMatchesOn(Debug)) {
635      tprintf("Proto Evidence:\n");
636      for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
637        ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
638        ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
639        for (ProtoNum = 0;
640             ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < ClassTemplate->NumProtos));
641             ProtoNum++, ActualProtoNum++) {
642          tprintf("P %3d =", ActualProtoNum);
643          int temp = 0;
644          for (uint8_t j = 0; j < ClassTemplate->ProtoLengths[ActualProtoNum]; j++) {
645            uint8_t data = tables.proto_evidence_[ActualProtoNum][j];
646            tprintf(" %d", data);
647            temp += data;
648          }
649          tprintf(" = %6.4f%%\n", temp / 256.0 / ClassTemplate->ProtoLengths[ActualProtoNum]);
650          ConfigWord = ProtoSet->Protos[ProtoNum].Configs[0];
651          ConfigNum = 0;
652          while (ConfigWord) {
653            tprintf("%5d", ConfigWord & 1 ? temp : 0);
654            if (ConfigWord & 1) {
655              ProtoConfigs[ConfigNum] += temp;
656            }
657            ConfigNum++;
658            ConfigWord >>= 1;
659          }
660          tprintf("\n");
661        }
662      }
663    }
664    if (PrintMatchSummaryOn(Debug)) {
665      tprintf("Proto Error for Configurations:\n");
666      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
667        tprintf(" %5.1f", 100.0 * (1.0 - ProtoConfigs[ConfigNum] /
668                                             ClassTemplate->ConfigLengths[ConfigNum] / 256.0));
669      }
670      tprintf("\n\n");
671    }
672    if (PrintProtoMatchesOn(Debug)) {
673      tprintf("Proto Sum for Configurations:\n");
674      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
675        tprintf(" %4.1f", ProtoConfigs[ConfigNum] / 256.0);
676      }
677      tprintf("\n\n");
678      tprintf("Proto Length for Configurations:\n");
679      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
680        tprintf(" %4.1f", static_cast<float>(ClassTemplate->ConfigLengths[ConfigNum]));
681      }
682      tprintf("\n\n");
683    }
684  }
685  void IntegerMatcher::DisplayProtoDebugInfo(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ConfigMask,
686                                             const ScratchEvidence &tables,
687                                             bool SeparateDebugWindows) {
688    uint16_t ProtoNum;
689    uint16_t ActualProtoNum;
690    PROTO_SET_STRUCT *ProtoSet;
691    int ProtoSetIndex;
692    InitIntMatchWindowIfReqd();
693    if (SeparateDebugWindows) {
694      InitFeatureDisplayWindowIfReqd();
695      InitProtoDisplayWindowIfReqd();
696    }
697    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
698      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
699      ActualProtoNum = ProtoSetIndex * PROTOS_PER_PROTO_SET;
700      for (ProtoNum = 0;
701           ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < ClassTemplate->NumProtos));
702           ProtoNum++, ActualProtoNum++) {
703        int temp = 0;
704        for (uint8_t i = 0; i < ClassTemplate->ProtoLengths[ActualProtoNum]; i++) {
705          temp += tables.proto_evidence_[ActualProtoNum][i];
706        }
707        temp /= ClassTemplate->ProtoLengths[ActualProtoNum];
708        if ((ProtoSet->Protos[ProtoNum]).Configs[0] & (*ConfigMask)) {
709          DisplayIntProto(ClassTemplate, ActualProtoNum, temp / 255.0);
710        }
711      }
712    }
713  }
714  void IntegerMatcher::DisplayFeatureDebugInfo(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
715                                               BIT_VECTOR ConfigMask, int16_t NumFeatures,
716                                               const INT_FEATURE_STRUCT *Features,
717                                               int AdaptFeatureThreshold, int Debug,
718                                               bool SeparateDebugWindows) {
719    auto *tables = new ScratchEvidence();
720    tables->Clear(ClassTemplate);
721    InitIntMatchWindowIfReqd();
722    if (SeparateDebugWindows) {
723      InitFeatureDisplayWindowIfReqd();
724      InitProtoDisplayWindowIfReqd();
725    }
726    for (int Feature = 0; Feature < NumFeatures; Feature++) {
727      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &Features[Feature],
728                             tables, 0);
729      int best = 0;
730      assert(ClassTemplate->NumConfigs < MAX_NUM_CONFIGS);
731      for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
732        if (tables->feature_evidence_[i] > best) {
733          best = tables->feature_evidence_[i];
734        }
735      }
736      if (ClipMatchEvidenceOn(Debug)) {
737        if (best < AdaptFeatureThreshold) {
738          DisplayIntFeature(&Features[Feature], 0.0);
739        } else {
740          DisplayIntFeature(&Features[Feature], 1.0);
741        }
742      } else {
743        DisplayIntFeature(&Features[Feature], best / 255.0);
744      }
745    }
746    delete tables;
747  }
748  #endif
749  void ScratchEvidence::UpdateSumOfProtoEvidences(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ConfigMask) {
750    int *IntPointer;
751    uint32_t ConfigWord;
752    int ProtoSetIndex;
753    uint16_t ProtoNum;
754    PROTO_SET_STRUCT *ProtoSet;
755    int NumProtos;
756    uint16_t ActualProtoNum;
757    NumProtos = ClassTemplate->NumProtos;
758    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
759      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
760      ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
761      for (ProtoNum = 0; ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < NumProtos));
762           ProtoNum++, ActualProtoNum++) {
763        int temp = 0;
764        for (uint8_t i = 0; i < MAX_PROTO_INDEX && i < ClassTemplate->ProtoLengths[ActualProtoNum];
765             i++) {
766          temp += proto_evidence_[ActualProtoNum][i];
767        }
768        ConfigWord = ProtoSet->Protos[ProtoNum].Configs[0];
769        ConfigWord &= *ConfigMask;
770        IntPointer = sum_feature_evidence_;
771        while (ConfigWord) {
772          if (ConfigWord & 1) {
773            *IntPointer += temp;
774          }
775          IntPointer++;
776          ConfigWord >>= 1;
777        }
778      }
779    }
780  }
781  void ScratchEvidence::NormalizeSums(INT_CLASS_STRUCT *ClassTemplate, int16_t NumFeatures) {
782    for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
783      sum_feature_evidence_[i] =
784          (sum_feature_evidence_[i] << 8) / (NumFeatures + ClassTemplate->ConfigLengths[i]);
785    }
786  }
787  int IntegerMatcher::FindBestMatch(INT_CLASS_STRUCT *class_template, const ScratchEvidence &tables,
788                                    UnicharRating *result) {
789    int best_match = 0;
790    result->config = 0;
791    result->fonts.clear();
792    result->fonts.reserve(class_template->NumConfigs);
793    for (int c = 0; c < MAX_NUM_CONFIGS && c < class_template->NumConfigs; ++c) {
794      int rating = tables.sum_feature_evidence_[c];
795      if (*classify_debug_level_ > 2) {
796        tprintf("Config %d, rating=%d\n", c, rating);
797      }
798      if (rating > best_match) {
799        result->config = c;
800        best_match = rating;
801      }
802      result->fonts.emplace_back(c, rating);
803    }
804    result->rating = best_match / 65536.0f;
805    return best_match;
806  }
807  float IntegerMatcher::ApplyCNCorrection(float rating, int blob_length, int normalization_factor,
808                                          int matcher_multiplier) {
809    int divisor = blob_length + matcher_multiplier;
810    return divisor == 0
811               ? 1.0f
812               : (rating * blob_length + matcher_multiplier * normalization_factor / 256.0f) /
813                     divisor;
814  }
815  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.cpp</h3>
            <pre><code>1  #include "pageres.h"
2  #include "blamer.h"   
3  #include "blobs.h"    
4  #include "boxword.h"  
5  #include "errcode.h"  
6  #include "ocrblock.h" 
7  #include "ocrrow.h"   
8  #include "pdblock.h"  
9  #include "polyblk.h"  
10  #include "seam.h"     
11  #include "stepblob.h" 
12  #include "tprintf.h"  
13  #include <tesseract/publictypes.h> 
14  #include <cassert> 
15  #include <cstdint> 
16  #include <cstring> 
17  struct Pix;
18  namespace tesseract {
19  static const double kStopperAmbiguityThresholdGain = 8.0;
20  static const double kStopperAmbiguityThresholdOffset = 1.5;
21  const int kWordrecMaxNumJoinChunks = 4;
22  const double kMaxWordSizeRatio = 1.25;
23  const double kMaxLineSizeRatio = 1.25;
24  const double kMaxWordGapRatio = 2.0;
25  static double StopperAmbigThreshold(double f1, double f2) {
26    return (f2 - f1) * kStopperAmbiguityThresholdGain -
27           kStopperAmbiguityThresholdOffset;
28  }
29  PAGE_RES::PAGE_RES(bool merge_similar_words, BLOCK_LIST *the_block_list,
30                     WERD_CHOICE **prev_word_best_choice_ptr) {
31    Init();
32    BLOCK_IT block_it(the_block_list);
33    BLOCK_RES_IT block_res_it(&block_res_list);
34    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
35      block_res_it.add_to_end(
36          new BLOCK_RES(merge_similar_words, block_it.data()));
37    }
38    prev_word_best_choice = prev_word_best_choice_ptr;
39  }
40  BLOCK_RES::BLOCK_RES(bool merge_similar_words, BLOCK *the_block) {
41    ROW_IT row_it(the_block->row_list());
42    ROW_RES_IT row_res_it(&row_res_list);
43    char_count = 0;
44    rej_count = 0;
45    font_class = -1; 
46    x_height = -1.0;
47    font_assigned = false;
48    row_count = 0;
49    block = the_block;
50    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
51      row_res_it.add_to_end(new ROW_RES(merge_similar_words, row_it.data()));
52    }
53  }
54  ROW_RES::ROW_RES(bool merge_similar_words, ROW *the_row) {
55    WERD_IT word_it(the_row->word_list());
56    WERD_RES_IT word_res_it(&word_res_list);
57    WERD_RES *combo = nullptr; 
58    WERD *copy_word;
59    char_count = 0;
60    rej_count = 0;
61    whole_word_rej_count = 0;
62    row = the_row;
63    bool add_next_word = false;
64    TBOX union_box;
65    float line_height =
66        the_row->x_height() + the_row->ascenders() - the_row->descenders();
67    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
68      auto *word_res = new WERD_RES(word_it.data());
69      word_res->x_height = the_row->x_height();
70      if (add_next_word) {
71        ASSERT_HOST(combo != nullptr);
72        word_res->part_of_combo = true;
73        combo->copy_on(word_res);
74      } else if (merge_similar_words) {
75        union_box = word_res->word->bounding_box();
76        add_next_word = !word_res->word->flag(W_REP_CHAR) &&
77                        union_box.height() <= line_height * kMaxWordSizeRatio;
78        word_res->odd_size = !add_next_word;
79      }
80      WERD *next_word = word_it.data_relative(1);
81      if (merge_similar_words) {
82        if (add_next_word && !next_word->flag(W_REP_CHAR)) {
83          TBOX next_box = next_word->bounding_box();
84          int prev_right = union_box.right();
85          union_box += next_box;
86          if (next_box.height() > line_height * kMaxWordSizeRatio ||
87              union_box.height() > line_height * kMaxLineSizeRatio ||
88              next_box.left() > prev_right + line_height * kMaxWordGapRatio) {
89            add_next_word = false;
90          }
91        }
92        next_word->set_flag(W_FUZZY_NON, add_next_word);
93      } else {
94        add_next_word = next_word->flag(W_FUZZY_NON);
95      }
96      if (add_next_word) {
97        if (combo == nullptr) {
98          copy_word = new WERD;
99          *copy_word = *(word_it.data()); 
100          combo = new WERD_RES(copy_word);
101          combo->x_height = the_row->x_height();
102          combo->combination = true;
103          word_res_it.add_to_end(combo);
104        }
105        word_res->part_of_combo = true;
106      } else {
107        combo = nullptr;
108      }
109      word_res_it.add_to_end(word_res);
110    }
111  }
112  WERD_RES &WERD_RES::operator=(const WERD_RES &source) {
113    this->ELIST_LINK::operator=(source);
114    Clear();
115    if (source.combination) {
116      word = new WERD;
117      *word = *(source.word); 
118    } else {
119      word = source.word; 
120    }
121    if (source.bln_boxes != nullptr) {
122      bln_boxes = new tesseract::BoxWord(*source.bln_boxes);
123    }
124    if (source.chopped_word != nullptr) {
125      chopped_word = new TWERD(*source.chopped_word);
126    }
127    if (source.rebuild_word != nullptr) {
128      rebuild_word = new TWERD(*source.rebuild_word);
129    }
130    blob_row = source.blob_row;
131    denorm = source.denorm;
132    if (source.box_word != nullptr) {
133      box_word = new tesseract::BoxWord(*source.box_word);
134    }
135    best_state = source.best_state;
136    correct_text = source.correct_text;
137    blob_widths = source.blob_widths;
138    blob_gaps = source.blob_gaps;
139    WERD_CHOICE_IT wc_it(const_cast<WERD_CHOICE_LIST *>(&source.best_choices));
140    WERD_CHOICE_IT wc_dest_it(&best_choices);
141    for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
142      const WERD_CHOICE *choice = wc_it.data();
143      wc_dest_it.add_after_then_move(new WERD_CHOICE(*choice));
144    }
145    if (!wc_dest_it.empty()) {
146      wc_dest_it.move_to_first();
147      best_choice = wc_dest_it.data();
148    } else {
149      best_choice = nullptr;
150    }
151    if (source.raw_choice != nullptr) {
152      raw_choice = new WERD_CHOICE(*source.raw_choice);
153    } else {
154      raw_choice = nullptr;
155    }
156    if (source.ep_choice != nullptr) {
157      ep_choice = new WERD_CHOICE(*source.ep_choice);
158    } else {
159      ep_choice = nullptr;
160    }
161    reject_map = source.reject_map;
162    combination = source.combination;
163    part_of_combo = source.part_of_combo;
164    CopySimpleFields(source);
165    if (source.blamer_bundle != nullptr) {
166      blamer_bundle = new BlamerBundle(*(source.blamer_bundle));
167    }
168    return *this;
169  }
<span onclick='openModal()' class='match'>170  void WERD_RES::CopySimpleFields(const WERD_RES &source) {
171    tess_failed = source.tess_failed;
172    tess_accepted = source.tess_accepted;
173    tess_would_adapt = source.tess_would_adapt;
174    done = source.done;
175    unlv_crunch_mode = source.unlv_crunch_mode;
176    small_caps = source.small_caps;
177    odd_size = source.odd_size;
178    fontinfo = source.fontinfo;
179    fontinfo2 = source.fontinfo2;
180    fontinfo_id_count = source.fontinfo_id_count;
181    fontinfo_id2_count = source.fontinfo_id2_count;
182    x_height = source.x_height;
183    caps_height = source.caps_height;
184    baseline_shift = source.baseline_shift;
185    guessed_x_ht = source.guessed_x_ht;
186    guessed_caps_ht = source.guessed_caps_ht;
187    reject_spaces = source.reject_spaces;
188    uch_set = source.uch_set;
189    tesseract = source.tesseract;
</span>190  }
191  void WERD_RES::InitForRetryRecognition(const WERD_RES &source) {
192    word = source.word;
193    CopySimpleFields(source);
194    if (source.blamer_bundle != nullptr) {
195      blamer_bundle = new BlamerBundle();
196      blamer_bundle->CopyTruth(*source.blamer_bundle);
197    }
198  }
199  bool WERD_RES::SetupForRecognition(const UNICHARSET &unicharset_in,
200                                     tesseract::Tesseract *tess, Image pix,
201                                     int norm_mode, const TBOX *norm_box,
202                                     bool numeric_mode, bool use_body_size,
203                                     bool allow_detailed_fx, ROW *row,
204                                     const BLOCK *block) {
205    auto norm_mode_hint = static_cast<tesseract::OcrEngineMode>(norm_mode);
206    tesseract = tess;
207    POLY_BLOCK *pb = block != nullptr ? block->pdblk.poly_block() : nullptr;
208    if ((norm_mode_hint != tesseract::OEM_LSTM_ONLY &&
209         word->cblob_list()->empty()) ||
210        (pb != nullptr && !pb->IsText())) {
211      SetupFake(unicharset_in);
212      word->set_flag(W_REP_CHAR, false);
213      return false;
214    }
215    ClearResults();
216    SetupWordScript(unicharset_in);
217    chopped_word = TWERD::PolygonalCopy(allow_detailed_fx, word);
218    float word_xheight =
219        use_body_size && row != nullptr && row->body_size() > 0.0f
220            ? row->body_size()
221            : x_height;
222    chopped_word->BLNormalize(block, row, pix, word->flag(W_INVERSE),
223                              word_xheight, baseline_shift, numeric_mode,
224                              norm_mode_hint, norm_box, &denorm);
225    blob_row = row;
226    SetupBasicsFromChoppedWord(unicharset_in);
227    SetupBlamerBundle();
228    int num_blobs = chopped_word->NumBlobs();
229    ratings = new MATRIX(num_blobs, kWordrecMaxNumJoinChunks);
230    tess_failed = false;
231    return true;
232  }
233  void WERD_RES::SetupBasicsFromChoppedWord(const UNICHARSET &unicharset_in) {
234    bln_boxes = tesseract::BoxWord::CopyFromNormalized(chopped_word);
235    start_seam_list(chopped_word, &seam_array);
236    SetupBlobWidthsAndGaps();
237    ClearWordChoices();
238  }
239  void WERD_RES::SetupFake(const UNICHARSET &unicharset_in) {
240    ClearResults();
241    SetupWordScript(unicharset_in);
242    chopped_word = new TWERD;
243    rebuild_word = new TWERD;
244    bln_boxes = new tesseract::BoxWord;
245    box_word = new tesseract::BoxWord;
246    int blob_count = word->cblob_list()->length();
247    if (blob_count > 0) {
248      auto **fake_choices = new BLOB_CHOICE *[blob_count];
249      C_BLOB_IT b_it(word->cblob_list());
250      int blob_id = 0;
251      for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
252        TBOX box = b_it.data()->bounding_box();
253        box_word->InsertBox(box_word->length(), box);
254        fake_choices[blob_id++] = new BLOB_CHOICE;
255      }
256      FakeClassifyWord(blob_count, fake_choices);
257      delete[] fake_choices;
258    } else {
259      auto *word = new WERD_CHOICE(&unicharset_in);
260      word->make_bad();
261      LogNewRawChoice(word);
262      LogNewCookedChoice(1, false, word);
263    }
264    tess_failed = true;
265    done = true;
266  }
267  void WERD_RES::SetupWordScript(const UNICHARSET &uch) {
268    uch_set = &uch;
269    int script = uch.default_sid();
270    word->set_script_id(script);
271    word->set_flag(W_SCRIPT_HAS_XHEIGHT, uch.script_has_xheight());
272    word->set_flag(W_SCRIPT_IS_LATIN, script == uch.latin_sid());
273  }
274  void WERD_RES::SetupBlamerBundle() {
275    if (blamer_bundle != nullptr) {
276      blamer_bundle->SetupNormTruthWord(denorm);
277    }
278  }
279  void WERD_RES::SetupBlobWidthsAndGaps() {
280    blob_widths.clear();
281    blob_gaps.clear();
282    int num_blobs = chopped_word->NumBlobs();
283    for (int b = 0; b < num_blobs; ++b) {
284      TBLOB *blob = chopped_word->blobs[b];
285      TBOX box = blob->bounding_box();
286      blob_widths.push_back(box.width());
287      if (b + 1 < num_blobs) {
288        blob_gaps.push_back(chopped_word->blobs[b + 1]->bounding_box().left() -
289                            box.right());
290      }
291    }
292  }
293  void WERD_RES::InsertSeam(int blob_number, SEAM *seam) {
294    seam->PrepareToInsertSeam(seam_array, chopped_word->blobs, blob_number, true);
295    seam_array.insert(seam_array.begin() + blob_number, seam);
296    if (ratings != nullptr) {
297      ratings = ratings->ConsumeAndMakeBigger(blob_number);
298      if (raw_choice != nullptr) {
299        raw_choice->UpdateStateForSplit(blob_number);
300      }
301      WERD_CHOICE_IT wc_it(&best_choices);
302      for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
303        WERD_CHOICE *choice = wc_it.data();
304        choice->UpdateStateForSplit(blob_number);
305      }
306      SetupBlobWidthsAndGaps();
307    }
308  }
309  bool WERD_RES::AlternativeChoiceAdjustmentsWorseThan(float threshold) const {
310    WERD_CHOICE_IT wc_it(const_cast<WERD_CHOICE_LIST *>(&best_choices));
311    for (wc_it.forward(); !wc_it.at_first(); wc_it.forward()) {
312      WERD_CHOICE *choice = wc_it.data();
313      if (choice->adjust_factor() <= threshold) {
314        return false;
315      }
316    }
317    return true;
318  }
319  bool WERD_RES::IsAmbiguous() {
320    return !best_choices.singleton() || best_choice->dangerous_ambig_found();
321  }
322  bool WERD_RES::StatesAllValid() {
323    unsigned ratings_dim = ratings->dimension();
324    if (raw_choice->TotalOfStates() != ratings_dim) {
325      tprintf("raw_choice has total of states = %u vs ratings dim of %u\n",
326              raw_choice->TotalOfStates(), ratings_dim);
327      return false;
328    }
329    WERD_CHOICE_IT it(&best_choices);
330    unsigned index = 0;
331    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), ++index) {
332      WERD_CHOICE *choice = it.data();
333      if (choice->TotalOfStates() != ratings_dim) {
334        tprintf("Cooked #%u has total of states = %u vs ratings dim of %u\n",
335                index, choice->TotalOfStates(), ratings_dim);
336        return false;
337      }
338    }
339    return true;
340  }
341  void WERD_RES::DebugWordChoices(bool debug, const char *word_to_debug) {
342    if (debug || (word_to_debug != nullptr && *word_to_debug != '\0' &&
343                  best_choice != nullptr &&
344                  best_choice->unichar_string() == std::string(word_to_debug))) {
345      if (raw_choice != nullptr) {
346        raw_choice->print("\nBest Raw Choice");
347      }
348      WERD_CHOICE_IT it(&best_choices);
349      int index = 0;
350      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), ++index) {
351        WERD_CHOICE *choice = it.data();
352        std::string label;
353        label += "\nCooked Choice #" + std::to_string(index);
354        choice->print(label.c_str());
355      }
356    }
357  }
358  void WERD_RES::DebugTopChoice(const char *msg) const {
359    tprintf("Best choice: accepted=%d, adaptable=%d, done=%d : ", tess_accepted,
360            tess_would_adapt, done);
361    if (best_choice == nullptr) {
362      tprintf("<Null choice>\n");
363    } else {
364      best_choice->print(msg);
365    }
366  }
367  void WERD_RES::FilterWordChoices(int debug_level) {
368    if (best_choice == nullptr || best_choices.singleton()) {
369      return;
370    }
371    if (debug_level >= 2) {
372      best_choice->print("\nFiltering against best choice");
373    }
374    WERD_CHOICE_IT it(&best_choices);
375    int index = 0;
376    for (it.forward(); !it.at_first(); it.forward(), ++index) {
377      WERD_CHOICE *choice = it.data();
378      float threshold = StopperAmbigThreshold(best_choice->adjust_factor(),
379                                              choice->adjust_factor());
380      unsigned i = 0, j = 0, chunk = 0;
381      auto choice_chunk = choice->state(0), best_chunk = best_choice->state(0);
382      while (i < choice->length() && j < best_choice->length()) {
383        if (choice->unichar_id(i) != best_choice->unichar_id(j) &&
384            choice->certainty(i) - best_choice->certainty(j) < threshold) {
385          if (debug_level >= 2) {
386            choice->print("WorstCertaintyDiffWorseThan");
387            tprintf(
388                "i %u j %u Choice->Blob[i].Certainty %.4g"
389                " WorstOtherChoiceCertainty %g Threshold %g\n",
390                i, j, choice->certainty(i), best_choice->certainty(j), threshold);
391            tprintf("Discarding bad choice #%d\n", index);
392          }
393          delete it.extract();
394          break;
395        }
396        ++chunk;
397        while (choice_chunk < chunk && ++i < choice->length()) {
398          choice_chunk += choice->state(i);
399        }
400        while (best_chunk < chunk && ++j < best_choice->length()) {
401          best_chunk += best_choice->state(j);
402        }
403      }
404    }
405  }
406  void WERD_RES::ComputeAdaptionThresholds(float certainty_scale,
407                                           float min_rating, float max_rating,
408                                           float rating_margin,
409                                           float *thresholds) {
410    int chunk = 0;
411    int end_chunk = best_choice->state(0);
412    int end_raw_chunk = raw_choice->state(0);
413    int raw_blob = 0;
414    for (unsigned i = 0; i < best_choice->length(); i++, thresholds++) {
415      float avg_rating = 0.0f;
416      int num_error_chunks = 0;
417      while (chunk < end_chunk) {
418        if (chunk >= end_raw_chunk) {
419          ++raw_blob;
420          end_raw_chunk += raw_choice->state(raw_blob);
421        }
422        if (best_choice->unichar_id(i) != raw_choice->unichar_id(raw_blob)) {
423          avg_rating += raw_choice->certainty(raw_blob);
424          ++num_error_chunks;
425        }
426        ++chunk;
427      }
428      if (num_error_chunks > 0) {
429        avg_rating /= num_error_chunks;
430        *thresholds = (avg_rating / -certainty_scale) * (1.0 - rating_margin);
431      } else {
432        *thresholds = max_rating;
433      }
434      if (*thresholds > max_rating) {
435        *thresholds = max_rating;
436      }
437      if (*thresholds < min_rating) {
438        *thresholds = min_rating;
439      }
440    }
441  }
442  bool WERD_RES::LogNewRawChoice(WERD_CHOICE *word_choice) {
443    if (raw_choice == nullptr || word_choice->rating() < raw_choice->rating()) {
444      delete raw_choice;
445      raw_choice = new WERD_CHOICE(*word_choice);
446      raw_choice->set_permuter(TOP_CHOICE_PERM);
447      return true;
448    }
449    return false;
450  }
451  bool WERD_RES::LogNewCookedChoice(int max_num_choices, bool debug,
452                                    WERD_CHOICE *word_choice) {
453    if (best_choice != nullptr) {
454      float max_certainty_delta = StopperAmbigThreshold(
455          best_choice->adjust_factor(), word_choice->adjust_factor());
456      if (max_certainty_delta > -kStopperAmbiguityThresholdOffset) {
457        max_certainty_delta = -kStopperAmbiguityThresholdOffset;
458      }
459      if (word_choice->certainty() - best_choice->certainty() <
460          max_certainty_delta) {
461        if (debug) {
462          std::string bad_string;
463          word_choice->string_and_lengths(&bad_string, nullptr);
464          tprintf(
465              "Discarding choice \"%s\" with an overly low certainty"
466              " %.3f vs best choice certainty %.3f (Threshold: %.3f)\n",
467              bad_string.c_str(), word_choice->certainty(),
468              best_choice->certainty(),
469              max_certainty_delta + best_choice->certainty());
470        }
471        delete word_choice;
472        return false;
473      }
474    }
475    WERD_CHOICE_IT it(&best_choices);
476    const std::string &new_str = word_choice->unichar_string();
477    bool inserted = false;
478    int num_choices = 0;
479    if (!it.empty()) {
480      do {
481        WERD_CHOICE *choice = it.data();
482        if (choice->rating() > word_choice->rating() && !inserted) {
483          it.add_before_stay_put(word_choice);
484          inserted = true;
485          if (num_choices == 0) {
486            best_choice = word_choice; 
487          }
488          ++num_choices;
489        }
490        if (choice->unichar_string() == new_str) {
491          if (inserted) {
492            delete it.extract();
493          } else {
494            if (debug) {
495              tprintf("Discarding duplicate choice \"%s\", rating %g vs %g\n",
496                      new_str.c_str(), word_choice->rating(), choice->rating());
497            }
498            delete word_choice;
499            return false;
500          }
501        } else {
502          ++num_choices;
503          if (num_choices > max_num_choices) {
504            delete it.extract();
505          }
506        }
507        it.forward();
508      } while (!it.at_first());
509    }
510    if (!inserted && num_choices < max_num_choices) {
511      it.add_to_end(word_choice);
512      inserted = true;
513      if (num_choices == 0) {
514        best_choice = word_choice; 
515      }
516    }
517    if (debug) {
518      if (inserted) {
519        tprintf("New %s", best_choice == word_choice ? "Best" : "Secondary");
520      } else {
521        tprintf("Poor");
522      }
523      word_choice->print(" Word Choice");
524    }
525    if (!inserted) {
526      delete word_choice;
527      return false;
528    }
529    return true;
530  }
531  template <class T>
532  static void MovePointerData(T **dest, T **src) {
533    delete *dest;
534    *dest = *src;
535    *src = nullptr;
536  }
537  void WERD_RES::PrintBestChoices() const {
538    std::string alternates_str;
539    WERD_CHOICE_IT it(const_cast<WERD_CHOICE_LIST *>(&best_choices));
540    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
541      if (!it.at_first()) {
542        alternates_str += "\", \"";
543      }
544      alternates_str += it.data()->unichar_string();
545    }
546    tprintf("Alternates for \"%s\": {\"%s\"}\n",
547            best_choice->unichar_string().c_str(), alternates_str.c_str());
548  }
549  int WERD_RES::GetBlobsWidth(int start_blob, int last_blob) const {
550    int result = 0;
551    for (int b = start_blob; b <= last_blob; ++b) {
552      result += blob_widths[b];
553      if (b < last_blob) {
554        result += blob_gaps[b];
555      }
556    }
557    return result;
558  }
559  int WERD_RES::GetBlobsGap(unsigned blob_index) const {
560    if (blob_index >= blob_gaps.size()) {
561      return 0;
562    }
563    return blob_gaps[blob_index];
564  }
565  BLOB_CHOICE *WERD_RES::GetBlobChoice(unsigned index) const {
566    if (index >= best_choice->length()) {
567      return nullptr;
568    }
569    BLOB_CHOICE_LIST *choices = GetBlobChoices(index);
570    return FindMatchingChoice(best_choice->unichar_id(index), choices);
571  }
572  BLOB_CHOICE_LIST *WERD_RES::GetBlobChoices(int index) const {
573    return best_choice->blob_choices(index, ratings);
574  }
575  void WERD_RES::ConsumeWordResults(WERD_RES *word) {
576    denorm = word->denorm;
577    blob_row = word->blob_row;
578    MovePointerData(&chopped_word, &word->chopped_word);
579    MovePointerData(&rebuild_word, &word->rebuild_word);
580    MovePointerData(&box_word, &word->box_word);
581    for (auto data : seam_array) {
582      delete data;
583    }
584    seam_array = word->seam_array;
585    word->seam_array.clear();
586    best_state = word->best_state;
587    word->best_state.clear();
588    correct_text = word->correct_text;
589    word->correct_text.clear();
590    blob_widths = word->blob_widths;
591    word->blob_widths.clear();
592    blob_gaps = word->blob_gaps;
593    word->blob_gaps.clear();
594    if (ratings != nullptr) {
595      ratings->delete_matrix_pointers();
596    }
597    MovePointerData(&ratings, &word->ratings);
598    best_choice = word->best_choice;
599    MovePointerData(&raw_choice, &word->raw_choice);
600    best_choices.clear();
601    WERD_CHOICE_IT wc_it(&best_choices);
602    wc_it.add_list_after(&word->best_choices);
603    reject_map = word->reject_map;
604    if (word->blamer_bundle != nullptr) {
605      assert(blamer_bundle != nullptr);
606      blamer_bundle->CopyResults(*(word->blamer_bundle));
607    }
608    CopySimpleFields(*word);
609  }
610  void WERD_RES::ReplaceBestChoice(WERD_CHOICE *choice) {
611    best_choice = choice;
612    RebuildBestState();
613    SetupBoxWord();
614    reject_map.initialise(best_state.size());
615    done = tess_accepted = tess_would_adapt = true;
616    SetScriptPositions();
617  }
618  void WERD_RES::RebuildBestState() {
619    ASSERT_HOST(best_choice != nullptr);
620    delete rebuild_word;
621    rebuild_word = new TWERD;
622    if (seam_array.empty()) {
623      start_seam_list(chopped_word, &seam_array);
624    }
625    best_state.clear();
626    int start = 0;
627    for (unsigned i = 0; i < best_choice->length(); ++i) {
628      int length = best_choice->state(i);
629      best_state.push_back(length);
630      if (length > 1) {
631        SEAM::JoinPieces(seam_array, chopped_word->blobs, start,
632                         start + length - 1);
633      }
634      TBLOB *blob = chopped_word->blobs[start];
635      rebuild_word->blobs.push_back(new TBLOB(*blob));
636      if (length > 1) {
637        SEAM::BreakPieces(seam_array, chopped_word->blobs, start,
638                          start + length - 1);
639      }
640      start += length;
641    }
642  }
643  void WERD_RES::CloneChoppedToRebuild() {
644    delete rebuild_word;
645    rebuild_word = new TWERD(*chopped_word);
646    SetupBoxWord();
647    auto word_len = box_word->length();
648    best_state.reserve(word_len);
649    correct_text.reserve(word_len);
650    for (unsigned i = 0; i < word_len; ++i) {
651      best_state.push_back(1);
652      correct_text.emplace_back("");
653    }
654  }
655  void WERD_RES::SetupBoxWord() {
656    delete box_word;
657    rebuild_word->ComputeBoundingBoxes();
658    box_word = tesseract::BoxWord::CopyFromNormalized(rebuild_word);
659    box_word->ClipToOriginalWord(denorm.block(), word);
660  }
661  void WERD_RES::SetScriptPositions() {
662    best_choice->SetScriptPositions(small_caps, chopped_word);
663  }
664  void WERD_RES::SetAllScriptPositions(tesseract::ScriptPos position) {
665    raw_choice->SetAllScriptPositions(position);
666    WERD_CHOICE_IT wc_it(&best_choices);
667    for (wc_it.mark_cycle_pt(); !wc_it.cycled_list(); wc_it.forward()) {
668      wc_it.data()->SetAllScriptPositions(position);
669    }
670  }
671  void WERD_RES::FakeClassifyWord(unsigned blob_count, BLOB_CHOICE **choices) {
672    ASSERT_HOST(box_word != nullptr);
673    ASSERT_HOST(blob_count == box_word->length());
674    ClearWordChoices();
675    ClearRatings();
676    ratings = new MATRIX(blob_count, 1);
677    for (unsigned c = 0; c < blob_count; ++c) {
678      auto *choice_list = new BLOB_CHOICE_LIST;
679      BLOB_CHOICE_IT choice_it(choice_list);
680      choice_it.add_after_then_move(choices[c]);
681      ratings->put(c, c, choice_list);
682    }
683    FakeWordFromRatings(TOP_CHOICE_PERM);
684    reject_map.initialise(blob_count);
685    best_state.clear();
686    best_state.resize(blob_count, 1);
687    done = true;
688  }
689  void WERD_RES::FakeWordFromRatings(PermuterType permuter) {
690    int num_blobs = ratings->dimension();
691    auto *word_choice = new WERD_CHOICE(uch_set, num_blobs);
692    word_choice->set_permuter(permuter);
693    for (int b = 0; b < num_blobs; ++b) {
694      UNICHAR_ID unichar_id = UNICHAR_SPACE;
695      float rating = WERD_CHOICE::kBadRating;
696      float certainty = -FLT_MAX;
697      BLOB_CHOICE_LIST *choices = ratings->get(b, b);
698      if (choices != nullptr && !choices->empty()) {
699        BLOB_CHOICE_IT bc_it(choices);
700        BLOB_CHOICE *choice = bc_it.data();
701        unichar_id = choice->unichar_id();
702        rating = choice->rating();
703        certainty = choice->certainty();
704      }
705      word_choice->append_unichar_id_space_allocated(unichar_id, 1, rating,
706                                                     certainty);
707    }
708    LogNewRawChoice(word_choice);
709    LogNewCookedChoice(1, false, word_choice);
710  }
711  void WERD_RES::BestChoiceToCorrectText() {
712    correct_text.clear();
713    ASSERT_HOST(best_choice != nullptr);
714    for (unsigned i = 0; i < best_choice->length(); ++i) {
715      UNICHAR_ID choice_id = best_choice->unichar_id(i);
716      const char *blob_choice = uch_set->id_to_unichar(choice_id);
717      correct_text.emplace_back(blob_choice);
718    }
719  }
720  bool WERD_RES::ConditionalBlobMerge(
721      const std::function<UNICHAR_ID(UNICHAR_ID, UNICHAR_ID)> &class_cb,
722      const std::function<bool(const TBOX &, const TBOX &)> &box_cb) {
723    ASSERT_HOST(best_choice->empty() || ratings != nullptr);
724    bool modified = false;
725    for (unsigned i = 0; i + 1 < best_choice->length(); ++i) {
726      UNICHAR_ID new_id =
727          class_cb(best_choice->unichar_id(i), best_choice->unichar_id(i + 1));
728      if (new_id != INVALID_UNICHAR_ID &&
729          (box_cb == nullptr ||
730           box_cb(box_word->BlobBox(i), box_word->BlobBox(i + 1)))) {
731        best_choice->set_unichar_id(new_id, i);
732        modified = true;
733        MergeAdjacentBlobs(i);
734        const MATRIX_COORD &coord = best_choice->MatrixCoord(i);
735        if (!coord.Valid(*ratings)) {
736          ratings->IncreaseBandSize(coord.row + 1 - coord.col);
737        }
738        BLOB_CHOICE_LIST *blob_choices = GetBlobChoices(i);
739        if (FindMatchingChoice(new_id, blob_choices) == nullptr) {
740          auto *blob_choice = new BLOB_CHOICE;
741          blob_choice->set_unichar_id(new_id);
742          BLOB_CHOICE_IT bc_it(blob_choices);
743          bc_it.add_before_then_move(blob_choice);
744        }
745      }
746    }
747    return modified;
748  }
749  void WERD_RES::MergeAdjacentBlobs(unsigned index) {
750    if (reject_map.length() == best_choice->length()) {
751      reject_map.remove_pos(index);
752    }
753    best_choice->remove_unichar_id(index + 1);
754    rebuild_word->MergeBlobs(index, index + 2);
755    box_word->MergeBoxes(index, index + 2);
756    if (index + 1 < best_state.size()) {
757      best_state[index] += best_state[index + 1];
758      best_state.erase(best_state.begin() + index + 1);
759    }
760  }
761  static int is_simple_quote(const char *signed_str, int length) {
762    const auto *str = reinterpret_cast<const unsigned char *>(signed_str);
763    return (length == 1 && (*str == '\'' || *str == '`')) ||
764           (length == 3 &&
765            ((*str == 0xe2 && *(str + 1) == 0x80 && *(str + 2) == 0x98) ||
766             (*str == 0xe2 && *(str + 1) == 0x80 && *(str + 2) == 0x99)));
767  }
768  UNICHAR_ID WERD_RES::BothQuotes(UNICHAR_ID id1, UNICHAR_ID id2) {
769    const char *ch = uch_set->id_to_unichar(id1);
770    const char *next_ch = uch_set->id_to_unichar(id2);
771    if (is_simple_quote(ch, strlen(ch)) &&
772        is_simple_quote(next_ch, strlen(next_ch))) {
773      return uch_set->unichar_to_id("\"");
774    }
775    return INVALID_UNICHAR_ID;
776  }
777  void WERD_RES::fix_quotes() {
778    if (!uch_set->contains_unichar("\"") ||
779        !uch_set->get_enabled(uch_set->unichar_to_id("\""))) {
780      return; 
781    }
782    using namespace std::placeholders; 
783    ConditionalBlobMerge(std::bind(&WERD_RES::BothQuotes, this, _1, _2), nullptr);
784  }
785  UNICHAR_ID WERD_RES::BothHyphens(UNICHAR_ID id1, UNICHAR_ID id2) {
786    const char *ch = uch_set->id_to_unichar(id1);
787    const char *next_ch = uch_set->id_to_unichar(id2);
788    if (strlen(ch) == 1 && strlen(next_ch) == 1 && (*ch == '-' || *ch == '~') &&
789        (*next_ch == '-' || *next_ch == '~')) {
790      return uch_set->unichar_to_id("-");
791    }
792    return INVALID_UNICHAR_ID;
793  }
794  bool WERD_RES::HyphenBoxesOverlap(const TBOX &box1, const TBOX &box2) {
795    return box1.right() >= box2.left();
796  }
797  void WERD_RES::fix_hyphens() {
798    if (!uch_set->contains_unichar("-") ||
799        !uch_set->get_enabled(uch_set->unichar_to_id("-"))) {
800      return; 
801    }
802    using namespace std::placeholders; 
803    ConditionalBlobMerge(std::bind(&WERD_RES::BothHyphens, this, _1, _2),
804                         std::bind(&WERD_RES::HyphenBoxesOverlap, this, _1, _2));
805  }
806  UNICHAR_ID WERD_RES::BothSpaces(UNICHAR_ID id1, UNICHAR_ID id2) {
807    if (id1 == id2 && id1 == uch_set->unichar_to_id(" ")) {
808      return id1;
809    } else {
810      return INVALID_UNICHAR_ID;
811    }
812  }
813  void WERD_RES::merge_tess_fails() {
814    using namespace std::placeholders; 
815    if (ConditionalBlobMerge(std::bind(&WERD_RES::BothSpaces, this, _1, _2),
816                             nullptr)) {
817      unsigned len = best_choice->length();
818      ASSERT_HOST(reject_map.length() == len);
819      ASSERT_HOST(box_word->length() == len);
820    }
821  }
822  bool WERD_RES::PiecesAllNatural(int start, int count) const {
823    for (int index = start; index < start + count - 1; ++index) {
824      if (index >= 0 && static_cast<size_t>(index) < seam_array.size()) {
825        SEAM *seam = seam_array[index];
826        if (seam != nullptr && seam->HasAnySplits()) {
827          return false;
828        }
829      }
830    }
831    return true;
832  }
833  WERD_RES::~WERD_RES() {
834    Clear();
835  }
836  void WERD_RES::Clear() {
837    if (combination) {
838      delete word;
839    }
840    word = nullptr;
841    delete blamer_bundle;
842    blamer_bundle = nullptr;
843    ClearResults();
844  }
845  void WERD_RES::ClearResults() {
846    done = false;
847    fontinfo = nullptr;
848    fontinfo2 = nullptr;
849    fontinfo_id_count = 0;
850    fontinfo_id2_count = 0;
851    delete bln_boxes;
852    bln_boxes = nullptr;
853    blob_row = nullptr;
854    delete chopped_word;
855    chopped_word = nullptr;
856    delete rebuild_word;
857    rebuild_word = nullptr;
858    delete box_word;
859    box_word = nullptr;
860    best_state.clear();
861    correct_text.clear();
862    for (auto data : seam_array) {
863      delete data;
864    }
865    seam_array.clear();
866    blob_widths.clear();
867    blob_gaps.clear();
868    ClearRatings();
869    ClearWordChoices();
870    if (blamer_bundle != nullptr) {
871      blamer_bundle->ClearResults();
872    }
873  }
874  void WERD_RES::ClearWordChoices() {
875    best_choice = nullptr;
876    delete raw_choice;
877    raw_choice = nullptr;
878    best_choices.clear();
879    delete ep_choice;
880    ep_choice = nullptr;
881  }
882  void WERD_RES::ClearRatings() {
883    if (ratings != nullptr) {
884      ratings->delete_matrix_pointers();
885      delete ratings;
886      ratings = nullptr;
887    }
888  }
889  int PAGE_RES_IT::cmp(const PAGE_RES_IT &other) const {
890    ASSERT_HOST(page_res == other.page_res);
891    if (other.block_res == nullptr) {
892      if (block_res == nullptr) {
893        return 0;
894      }
895      return -1;
896    }
897    if (block_res == nullptr) {
898      return 1; 
899    }
900    if (block_res == other.block_res) {
901      if (other.row_res == nullptr || row_res == nullptr) {
902        return 0;
903      }
904      if (row_res == other.row_res) {
905        ASSERT_HOST(other.word_res != nullptr && word_res != nullptr);
906        if (word_res == other.word_res) {
907          return 0;
908        }
909        WERD_RES_IT word_res_it(&row_res->word_res_list);
910        for (word_res_it.mark_cycle_pt(); !word_res_it.cycled_list();
911             word_res_it.forward()) {
912          if (word_res_it.data() == word_res) {
913            return -1;
914          } else if (word_res_it.data() == other.word_res) {
915            return 1;
916          }
917        }
918        ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
919      }
920      ROW_RES_IT row_res_it(&block_res->row_res_list);
921      for (row_res_it.mark_cycle_pt(); !row_res_it.cycled_list();
922           row_res_it.forward()) {
923        if (row_res_it.data() == row_res) {
924          return -1;
925        } else if (row_res_it.data() == other.row_res) {
926          return 1;
927        }
928      }
929      ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
930    }
931    BLOCK_RES_IT block_res_it(&page_res->block_res_list);
932    for (block_res_it.mark_cycle_pt(); !block_res_it.cycled_list();
933         block_res_it.forward()) {
934      if (block_res_it.data() == block_res) {
935        return -1;
936      } else if (block_res_it.data() == other.block_res) {
937        return 1;
938      }
939    }
940    ASSERT_HOST("Error: Incomparable PAGE_RES_ITs" == nullptr);
941    return 0;
942  }
943  WERD_RES *PAGE_RES_IT::InsertSimpleCloneWord(const WERD_RES &clone_res,
944                                               WERD *new_word) {
945    auto *new_res = new WERD_RES(new_word);
946    new_res->CopySimpleFields(clone_res);
947    new_res->combination = true;
948    WERD_RES_IT wr_it(&row()->word_res_list);
949    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
950      WERD_RES *word = wr_it.data();
951      if (word == word_res) {
952        break;
953      }
954    }
955    ASSERT_HOST(!wr_it.cycled_list());
956    wr_it.add_before_then_move(new_res);
957    if (wr_it.at_first()) {
958      ResetWordIterator();
959    }
960    return new_res;
961  }
962  static void ComputeBlobEnds(const WERD_RES &word, const TBOX &clip_box,
963                              C_BLOB_LIST *next_word_blobs,
964                              std::vector<int> *blob_ends) {
965    C_BLOB_IT blob_it(word.word->cblob_list());
966    for (int length : word.best_state) {
967      TBOX blob_box = blob_it.data()->bounding_box();
968      blob_it.forward();
969      for (int b = 1; b < length; ++b) {
970        blob_box += blob_it.data()->bounding_box();
971        blob_it.forward();
972      }
973      int blob_end = INT32_MAX;
974      if (!blob_it.at_first() || next_word_blobs != nullptr) {
975        if (blob_it.at_first()) {
976          blob_it.set_to_list(next_word_blobs);
977        }
978        blob_end = (blob_box.right() + blob_it.data()->bounding_box().left()) / 2;
979      }
980      blob_end = ClipToRange<int>(blob_end, clip_box.left(), clip_box.right());
981      blob_ends->push_back(blob_end);
982    }
983    blob_ends->back() = clip_box.right();
984  }
985  static TBOX ComputeWordBounds(const tesseract::PointerVector<WERD_RES> &words,
986                                int w_index, TBOX prev_box, WERD_RES_IT w_it) {
987    constexpr int kSignificantOverlapFraction = 4;
988    TBOX clipped_box;
989    TBOX current_box = words[w_index]->word->bounding_box();
990    TBOX next_box;
991    if (static_cast<size_t>(w_index + 1) < words.size() &&
992        words[w_index + 1] != nullptr && words[w_index + 1]->word != nullptr) {
993      next_box = words[w_index + 1]->word->bounding_box();
994    }
995    for (w_it.forward(); !w_it.at_first() && w_it.data()->part_of_combo;
996         w_it.forward()) {
997      if (w_it.data() == nullptr || w_it.data()->word == nullptr) {
998        continue;
999      }
1000      TBOX w_box = w_it.data()->word->bounding_box();
1001      int height_limit = std::min<int>(w_box.height(), w_box.width() / 2);
1002      int width_limit = w_box.width() / kSignificantOverlapFraction;
1003      int min_significant_overlap = std::max(height_limit, width_limit);
1004      int overlap = w_box.intersection(current_box).width();
1005      int prev_overlap = w_box.intersection(prev_box).width();
1006      int next_overlap = w_box.intersection(next_box).width();
1007      if (overlap > min_significant_overlap) {
1008        if (prev_overlap > min_significant_overlap) {
1009          clipped_box.set_left(current_box.left());
1010        } else if (next_overlap > min_significant_overlap) {
1011          clipped_box.set_right(current_box.right());
1012        } else {
1013          clipped_box += w_box;
1014        }
1015      }
1016    }
1017    if (clipped_box.height() <= 0) {
1018      clipped_box.set_top(current_box.top());
1019      clipped_box.set_bottom(current_box.bottom());
1020    }
1021    if (clipped_box.width() <= 0) {
1022      clipped_box = current_box;
1023    }
1024    return clipped_box;
1025  }
1026  static TBOX MoveAndClipBlob(C_BLOB_IT *src_it, C_BLOB_IT *dest_it,
1027                              const TBOX &clip_box) {
1028    C_BLOB *src_blob = src_it->extract();
1029    TBOX box = src_blob->bounding_box();
1030    if (!clip_box.contains(box)) {
1031      int left =
1032          ClipToRange<int>(box.left(), clip_box.left(), clip_box.right() - 1);
1033      int right =
1034          ClipToRange<int>(box.right(), clip_box.left() + 1, clip_box.right());
1035      int top =
1036          ClipToRange<int>(box.top(), clip_box.bottom() + 1, clip_box.top());
1037      int bottom =
1038          ClipToRange<int>(box.bottom(), clip_box.bottom(), clip_box.top() - 1);
1039      box = TBOX(left, bottom, right, top);
1040      delete src_blob;
1041      src_blob = C_BLOB::FakeBlob(box);
1042    }
1043    dest_it->add_after_then_move(src_blob);
1044    return box;
1045  }
1046  void PAGE_RES_IT::ReplaceCurrentWord(
1047      tesseract::PointerVector<WERD_RES> *words) {
1048    if (words->empty()) {
1049      DeleteCurrentWord();
1050      return;
1051    }
1052    WERD_RES *input_word = word();
1053    if (input_word->word->flag(W_BOL)) {
1054      (*words)[0]->word->set_flag(W_BOL, true);
1055    } else {
1056      (*words)[0]->word->set_blanks(input_word->word->space());
1057    }
1058    words->back()->word->set_flag(W_EOL, input_word->word->flag(W_EOL));
1059    WERD_IT w_it(row()->row->word_list());
1060    if (!input_word->combination) {
1061      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
1062        WERD *word = w_it.data();
1063        if (word == input_word->word) {
1064          break;
1065        }
1066      }
1067      ASSERT_HOST(!w_it.cycled_list());
1068    }
1069    WERD_RES_IT wr_it(&row()->word_res_list);
1070    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1071      WERD_RES *word = wr_it.data();
1072      if (word == input_word) {
1073        break;
1074      }
1075    }
1076    ASSERT_HOST(!wr_it.cycled_list());
1077    C_BLOB_IT src_b_it(input_word->word->cblob_list());
1078    src_b_it.sort(&C_BLOB::SortByXMiddle);
1079    C_BLOB_IT rej_b_it(input_word->word->rej_cblob_list());
1080    rej_b_it.sort(&C_BLOB::SortByXMiddle);
1081    TBOX clip_box;
1082    for (size_t w = 0; w < words->size(); ++w) {
1083      WERD_RES *word_w = (*words)[w];
1084      clip_box = ComputeWordBounds(*words, w, clip_box, wr_it_of_current_word);
1085      std::vector<int> blob_ends;
1086      C_BLOB_LIST *next_word_blobs =
1087          w + 1 < words->size() ? (*words)[w + 1]->word->cblob_list() : nullptr;
1088      ComputeBlobEnds(*word_w, clip_box, next_word_blobs, &blob_ends);
1089      C_BLOB_LIST fake_blobs;
1090      C_BLOB_IT fake_b_it(&fake_blobs);
1091      fake_b_it.add_list_after(word_w->word->cblob_list());
1092      fake_b_it.move_to_first();
1093      word_w->word->cblob_list()->clear();
1094      C_BLOB_IT dest_it(word_w->word->cblob_list());
1095      auto *box_word = new tesseract::BoxWord;
1096      for (size_t i = 0; i < blob_ends.size(); ++i, fake_b_it.forward()) {
1097        int end_x = blob_ends[i];
1098        TBOX blob_box;
1099        while (!src_b_it.empty() &&
1100               src_b_it.data()->bounding_box().x_middle() < end_x) {
1101          blob_box += MoveAndClipBlob(&src_b_it, &dest_it, clip_box);
1102          src_b_it.forward();
1103        }
1104        while (!rej_b_it.empty() &&
1105               rej_b_it.data()->bounding_box().x_middle() < end_x) {
1106          blob_box += MoveAndClipBlob(&rej_b_it, &dest_it, clip_box);
1107          rej_b_it.forward();
1108        }
1109        if (blob_box.null_box()) {
1110          blob_box = MoveAndClipBlob(&fake_b_it, &dest_it, clip_box);
1111        }
1112        box_word->InsertBox(i, blob_box);
1113      }
1114      delete word_w->box_word;
1115      word_w->box_word = box_word;
1116      if (!input_word->combination) {
1117        w_it.add_before_stay_put(word_w->word);
1118        word_w->combination = false;
1119      }
1120      (*words)[w] = nullptr; 
1121      wr_it.add_before_stay_put(word_w);
1122    }
1123    words->clear();
1124    if (!input_word->combination) {
1125      delete w_it.extract();
1126    }
1127    delete wr_it.extract();
1128    ResetWordIterator();
1129  }
1130  void PAGE_RES_IT::DeleteCurrentWord() {
1131    ASSERT_HOST(!word_res->part_of_combo);
1132    if (!word_res->combination) {
1133      WERD_IT w_it(row()->row->word_list());
1134      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
1135        if (w_it.data() == word_res->word) {
1136          break;
1137        }
1138      }
1139      ASSERT_HOST(!w_it.cycled_list());
1140      delete w_it.extract();
1141    }
1142    WERD_RES_IT wr_it(&row()->word_res_list);
1143    for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1144      if (wr_it.data() == word_res) {
1145        word_res = nullptr;
1146        break;
1147      }
1148    }
1149    ASSERT_HOST(!wr_it.cycled_list());
1150    delete wr_it.extract();
1151    ResetWordIterator();
1152  }
1153  void PAGE_RES_IT::MakeCurrentWordFuzzy() {
1154    WERD *real_word = word_res->word;
1155    if (!real_word->flag(W_FUZZY_SP) && !real_word->flag(W_FUZZY_NON)) {
1156      real_word->set_flag(W_FUZZY_SP, true);
1157      if (word_res->combination) {
1158        WERD_RES_IT wr_it(&row()->word_res_list);
1159        for (wr_it.mark_cycle_pt();
1160             !wr_it.cycled_list() && wr_it.data() != word_res; wr_it.forward()) {
1161        }
1162        wr_it.forward();
1163        ASSERT_HOST(wr_it.data()->part_of_combo);
1164        real_word = wr_it.data()->word;
1165        ASSERT_HOST(!real_word->flag(W_FUZZY_SP) &&
1166                    !real_word->flag(W_FUZZY_NON));
1167        real_word->set_flag(W_FUZZY_SP, true);
1168      }
1169    }
1170  }
1171  WERD_RES *PAGE_RES_IT::start_page(bool empty_ok) {
1172    block_res_it.set_to_list(&page_res->block_res_list);
1173    block_res_it.mark_cycle_pt();
1174    prev_block_res = nullptr;
1175    prev_row_res = nullptr;
1176    prev_word_res = nullptr;
1177    block_res = nullptr;
1178    row_res = nullptr;
1179    word_res = nullptr;
1180    next_block_res = nullptr;
1181    next_row_res = nullptr;
1182    next_word_res = nullptr;
1183    internal_forward(true, empty_ok);
1184    return internal_forward(false, empty_ok);
1185  }
1186  void PAGE_RES_IT::ResetWordIterator() {
1187    if (row_res == next_row_res) {
1188      word_res_it.move_to_first();
1189      for (word_res_it.mark_cycle_pt();
1190           !word_res_it.cycled_list() && word_res_it.data() != next_word_res;
1191           word_res_it.forward()) {
1192        if (!word_res_it.data()->part_of_combo) {
1193          if (prev_row_res == row_res) {
1194            prev_word_res = word_res;
1195          }
1196          word_res = word_res_it.data();
1197        }
1198      }
1199      ASSERT_HOST(!word_res_it.cycled_list());
1200      wr_it_of_next_word = word_res_it;
1201      word_res_it.forward();
1202    } else {
1203      WERD_RES_IT wr_it(&row_res->word_res_list);
1204      for (wr_it.mark_cycle_pt(); !wr_it.cycled_list(); wr_it.forward()) {
1205        if (!wr_it.data()->part_of_combo) {
1206          if (prev_row_res == row_res) {
1207            prev_word_res = word_res;
1208          }
1209          word_res = wr_it.data();
1210        }
1211      }
1212    }
1213  }
1214  WERD_RES *PAGE_RES_IT::internal_forward(bool new_block, bool empty_ok) {
1215    bool new_row = false;
1216    prev_block_res = block_res;
1217    prev_row_res = row_res;
1218    prev_word_res = word_res;
1219    block_res = next_block_res;
1220    row_res = next_row_res;
1221    word_res = next_word_res;
1222    wr_it_of_current_word = wr_it_of_next_word;
1223    next_block_res = nullptr;
1224    next_row_res = nullptr;
1225    next_word_res = nullptr;
1226    while (!block_res_it.cycled_list()) {
1227      if (new_block) {
1228        new_block = false;
1229        row_res_it.set_to_list(&block_res_it.data()->row_res_list);
1230        row_res_it.mark_cycle_pt();
1231        if (row_res_it.empty() && empty_ok) {
1232          next_block_res = block_res_it.data();
1233          break;
1234        }
1235        new_row = true;
1236      }
1237      while (!row_res_it.cycled_list()) {
1238        if (new_row) {
1239          new_row = false;
1240          word_res_it.set_to_list(&row_res_it.data()->word_res_list);
1241          word_res_it.mark_cycle_pt();
1242        }
1243        while (!word_res_it.cycled_list() && word_res_it.data()->part_of_combo) {
1244          word_res_it.forward();
1245        }
1246        if (!word_res_it.cycled_list()) {
1247          next_block_res = block_res_it.data();
1248          next_row_res = row_res_it.data();
1249          next_word_res = word_res_it.data();
1250          wr_it_of_next_word = word_res_it;
1251          word_res_it.forward();
1252          goto foundword;
1253        }
1254        row_res_it.forward();
1255        new_row = true;
1256      }
1257      block_res_it.forward();
1258      new_block = true;
1259    }
1260  foundword:
1261    if (page_res != nullptr && page_res->prev_word_best_choice != nullptr) {
1262      *page_res->prev_word_best_choice = (new_block || prev_word_res == nullptr)
1263                                             ? nullptr
1264                                             : prev_word_res->best_choice;
1265    }
1266    return word_res;
1267  }
1268  WERD_RES *PAGE_RES_IT::restart_row() {
1269    ROW_RES *row = this->row();
1270    if (!row) {
1271      return nullptr;
1272    }
1273    for (restart_page(); this->row() != row; forward()) {
1274    }
1275    return word();
1276  }
1277  WERD_RES *PAGE_RES_IT::forward_paragraph() {
1278    while (block_res == next_block_res &&
1279           (next_row_res != nullptr && next_row_res->row != nullptr &&
1280            row_res->row->para() == next_row_res->row->para())) {
1281      internal_forward(false, true);
1282    }
1283    return internal_forward(false, true);
1284  }
1285  WERD_RES *PAGE_RES_IT::forward_block() {
1286    while (block_res == next_block_res) {
1287      internal_forward(false, true);
1288    }
1289    return internal_forward(false, true);
1290  }
1291  void PAGE_RES_IT::rej_stat_word() {
1292    int16_t chars_in_word;
1293    int16_t rejects_in_word = 0;
1294    chars_in_word = word_res->reject_map.length();
1295    page_res->char_count += chars_in_word;
1296    block_res->char_count += chars_in_word;
1297    row_res->char_count += chars_in_word;
1298    rejects_in_word = word_res->reject_map.reject_count();
1299    page_res->rej_count += rejects_in_word;
1300    block_res->rej_count += rejects_in_word;
1301    row_res->rej_count += rejects_in_word;
1302    if (chars_in_word == rejects_in_word) {
1303      row_res->whole_word_rej_count += rejects_in_word;
1304    }
1305  }
1306  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intmatcher.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pageres.cpp</div>
                </div>
                <div class="column column_space"><pre><code>117          for (int word = 0; word < WERDS_PER_CP_VECTOR; ++word) {
118            uint32_t pruner_word = *pruner_word_ptr++;
119            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
120            pruner_word >>= NUM_BITS_PER_CLASS;
121            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
122            pruner_word >>= NUM_BITS_PER_CLASS;
123            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
124            pruner_word >>= NUM_BITS_PER_CLASS;
125            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
126            pruner_word >>= NUM_BITS_PER_CLASS;
127            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
128            pruner_word >>= NUM_BITS_PER_CLASS;
129            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
</pre></code></div>
                <div class="column column_space"><pre><code>170  void WERD_RES::CopySimpleFields(const WERD_RES &source) {
171    tess_failed = source.tess_failed;
172    tess_accepted = source.tess_accepted;
173    tess_would_adapt = source.tess_would_adapt;
174    done = source.done;
175    unlv_crunch_mode = source.unlv_crunch_mode;
176    small_caps = source.small_caps;
177    odd_size = source.odd_size;
178    fontinfo = source.fontinfo;
179    fontinfo2 = source.fontinfo2;
180    fontinfo_id_count = source.fontinfo_id_count;
181    fontinfo_id2_count = source.fontinfo_id2_count;
182    x_height = source.x_height;
183    caps_height = source.caps_height;
184    baseline_shift = source.baseline_shift;
185    guessed_x_ht = source.guessed_x_ht;
186    guessed_caps_ht = source.guessed_caps_ht;
187    reject_spaces = source.reject_spaces;
188    uch_set = source.uch_set;
189    tesseract = source.tesseract;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    