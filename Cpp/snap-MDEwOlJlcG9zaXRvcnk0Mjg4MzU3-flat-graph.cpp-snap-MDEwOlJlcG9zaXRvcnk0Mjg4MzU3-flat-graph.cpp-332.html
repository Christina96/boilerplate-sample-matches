
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;graph.h&quot;
3  TStr TVrtx::VIdNm=&quot;VId&quot;;
4  TStr TVrtx::PpNm=&quot;Pp&quot;;
5  TStr TVrtx::VNmNm=&quot;VNm&quot;;
6  TStr TVrtx::DNmNm=&quot;DNm&quot;;
7  TStr TVrtx::BriefNm=&quot;Brief&quot;;
8  TStr TVrtx::MarkNm=&quot;Mark&quot;;
9  TStr TVrtx::WgtNm=&quot;Wgt&quot;;
10  TStr TVrtx::HitsHubWNm=&quot;HitsHubW&quot;;
11  TStr TVrtx::HitsAuthWNm=&quot;HitsAuthW&quot;;
12  TStr TVrtx::PageRankWNm=&quot;PageRankW&quot;;
13  TStr TVrtx::XNm=&quot;X&quot;;
14  TStr TVrtx::YNm=&quot;Y&quot;;
15  TStr TVrtx::ZNm=&quot;Z&quot;;
16  TStr TVrtx::ColorNm=&quot;Color&quot;;
17  TStr TVrtx::ShapeNm=&quot;Shape&quot;;
18  TStr TVrtx::RectNm=&quot;Rect&quot;;
19  TStr TVrtx::RectX1Nm=&quot;Rect|X1&quot;; TStr TVrtx::X1Nm=&quot;X1&quot;;
20  TStr TVrtx::RectY1Nm=&quot;Rect|Y1&quot;; TStr TVrtx::Y1Nm=&quot;Y1&quot;;
21  TStr TVrtx::RectX2Nm=&quot;Rect|X2&quot;; TStr TVrtx::X2Nm=&quot;X2&quot;;
22  TStr TVrtx::RectY2Nm=&quot;Rect|Y2&quot;; TStr TVrtx::Y2Nm=&quot;Y2&quot;;
23  TStr TVrtx::DmNm=&quot;Dm&quot;;
24  void TVrtx::PutRect(const TGksRect&amp; Rect){
25    GetPp()-&gt;PutValInt(RectX1Nm, Rect.GetX1());
26    GetPp()-&gt;PutValInt(RectY1Nm, Rect.GetY1());
27    GetPp()-&gt;PutValInt(RectX2Nm, Rect.GetX2());
28    GetPp()-&gt;PutValInt(RectY2Nm, Rect.GetY2());
29  }
30  TGksRect TVrtx::GetRect() const {
31    int X1=GetPp()-&gt;GetValInt(RectX1Nm);
32    int Y1=GetPp()-&gt;GetValInt(RectY1Nm);
33    int X2=GetPp()-&gt;GetValInt(RectX2Nm);
34    int Y2=GetPp()-&gt;GetValInt(RectY2Nm);
35    return TGksRect(X1, Y1, X2, Y2);
36  }
37  bool TVrtx::IsInRect(const double&amp; X, const double&amp; Y) const {
38    TGksRect Rect=TVrtx::GetRect();
39    return Rect.IsIn(int(X), int(Y));
40  }
41  PPp TVrtx::GetDrawPp(){
42    PPp Pp=TPp::GetSetPp(&quot;Draw&quot;);
43    Pp-&gt;AddPpStr(DNmNm, &quot;&quot;, &quot;&quot;);
44    Pp-&gt;AddPpFlt(XNm, &quot;&quot;, TFlt::Mn, TFlt::Mx, 0);
45    Pp-&gt;AddPpFlt(YNm, &quot;&quot;, TFlt::Mn, TFlt::Mx, 0);
46    Pp-&gt;AddPpInt(BriefNm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
47    Pp-&gt;AddPpStr(ShapeNm, &quot;&quot;, &quot;&quot;);
48    PPp RectPp=TPp::GetSetPp(RectNm);
49    RectPp-&gt;AddPpInt(X1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
50    RectPp-&gt;AddPpInt(Y1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
51    RectPp-&gt;AddPpInt(X2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
52    RectPp-&gt;AddPpInt(Y2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
53    Pp-&gt;AddPp(RectPp);
54    return Pp;
55  }
56  PVrtx TVrtx::LoadXml(const PXmlTok&amp; XmlTok){
57    int VId=XmlTok-&gt;GetIntArgVal(VIdNm);
58    TStr VNm=XmlTok-&gt;GetStrArgVal(VNmNm, &quot;&quot;);
59    int Mark=XmlTok-&gt;GetIntArgVal(MarkNm, 0);
60    double Wgt=XmlTok-&gt;GetFltArgVal(WgtNm, 0);
61    double HitsHubW=XmlTok-&gt;GetFltArgVal(HitsHubWNm, 0);
62    double HitsAuthW=XmlTok-&gt;GetFltArgVal(HitsAuthWNm, 0);
63    double PageRankW=XmlTok-&gt;GetFltArgVal(PageRankWNm, 0);
64    double X=XmlTok-&gt;GetFltArgVal(XNm, 0);
65    double Y=XmlTok-&gt;GetFltArgVal(YNm, 0);
66    double Z=XmlTok-&gt;GetFltArgVal(ZNm, 0);
67    PPp Pp;
68    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
69    Vrtx-&gt;PutMark(Mark); Vrtx-&gt;PutWgt(Wgt);
70    Vrtx-&gt;PutHitsHubW(HitsHubW); Vrtx-&gt;PutHitsAuthW(HitsAuthW);
71    Vrtx-&gt;PutPageRankW(PageRankW);
72    Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y); Vrtx-&gt;PutZ(Z);
73    return Vrtx;
74  }
75  PXmlTok TVrtx::GetXmlTok() const {
76    PXmlTok VrtxTok=TXmlTok::New(TGraph::VrtxNm);
77    VrtxTok-&gt;AddArg(VIdNm, GetVId());
78    if (!GetVNm().Empty()){VrtxTok-&gt;AddArg(VNmNm, GetVNm());}
79    if (GetMark()!=0){VrtxTok-&gt;AddArg(MarkNm, GetMark());}
80    if (GetWgt()!=0){VrtxTok-&gt;AddArg(WgtNm, GetWgt());}
81    if (GetHitsHubW()!=0){VrtxTok-&gt;AddArg(HitsHubWNm, GetHitsHubW());}
82    if (GetHitsAuthW()!=0){VrtxTok-&gt;AddArg(HitsAuthWNm, GetHitsAuthW());}
83    if (GetPageRankW()!=0){VrtxTok-&gt;AddArg(PageRankWNm, GetPageRankW());}
84    if (GetX()!=0){VrtxTok-&gt;AddArg(XNm, GetX());}
85    if (GetY()!=0){VrtxTok-&gt;AddArg(YNm, GetY());}
86    if (GetZ()!=0){VrtxTok-&gt;AddArg(ZNm, GetZ());}
87    return VrtxTok;
88  }
89  PVrtx TVrtx::LoadTxt(TILx&amp; Lx){
90    Lx.GetSym(syLBracket);
91    int VId=Lx.GetVarInt(VIdNm, false);
92    TStr VNm; int Mark=0; double Wgt=0;
93    double HitsHubW=0; double HitsAuthW=0; double PageRankW=0;
94    double X=0; double Y=0; double Z=0; PPp Pp;
95    if (Lx.IsVar(VNmNm)){VNm=Lx.GetVarStr(VNmNm, false);}
96    VNm=TXmlLx::GetPlainStrFromXmlStr(VNm);
97    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
98    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
99    if (Lx.IsVar(HitsHubWNm)){HitsHubW=Lx.GetVarFlt(HitsHubWNm, false);}
100    if (Lx.IsVar(HitsAuthWNm)){HitsAuthW=Lx.GetVarFlt(HitsAuthWNm, false);}
101    if (Lx.IsVar(PageRankWNm)){PageRankW=Lx.GetVarFlt(PageRankWNm, false);}
102    if (Lx.IsVar(XNm)){X=Lx.GetVarFlt(XNm, false);}
103    if (Lx.IsVar(YNm)){Y=Lx.GetVarFlt(YNm, false);}
104    if (Lx.IsVar(ZNm)){Z=Lx.GetVarFlt(ZNm, false);}
105    if (Lx.IsVar(PpNm)){
106      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
107    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
108    Vrtx-&gt;PutMark(Mark); Vrtx-&gt;PutWgt(Wgt);
109    Vrtx-&gt;PutHitsHubW(HitsHubW); Vrtx-&gt;PutHitsAuthW(HitsAuthW);
110    Vrtx-&gt;PutPageRankW(PageRankW);
111    Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y); Vrtx-&gt;PutZ(Z);
112    Lx.GetSym(syRBracket);
113    return Vrtx;
114  }
115  void TVrtx::SaveTxt(TOLx&amp; Lx) const {
116    Lx.PutSym(syLBracket);
117    Lx.PutVarInt(VIdNm, GetVId(), false);
118    TStr XmlVNm=TXmlLx::GetXmlStrFromPlainStr(GetVNm());
119    if (!GetVNm().Empty()){Lx.PutVarStr(VNmNm, XmlVNm, false);}
120    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
121    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
122    if (GetHitsHubW()!=0){Lx.PutVarFlt(HitsHubWNm, GetHitsHubW(), false);}
123    if (GetHitsAuthW()!=0){Lx.PutVarFlt(HitsAuthWNm, GetHitsAuthW(), false);}
124    if (GetPageRankW()!=0){Lx.PutVarFlt(PageRankWNm, GetPageRankW(), false);}
125    if (GetX()!=0){Lx.PutVarFlt(XNm, GetX(), false);}
126    if (GetY()!=0){Lx.PutVarFlt(YNm, GetY(), false);}
127    if (GetZ()!=0){Lx.PutVarFlt(ZNm, GetZ(), false);}
128    if (!GetPp().Empty()){
129      Lx.PutIdStr(PpNm); Lx.PutSym(syColon); GetPp()-&gt;SaveTxt(Lx);}
130    Lx.PutSym(syRBracket);
131  }
132  void TGVrtx::DefVrtx(const PGraph&amp; Graph){
133    if (VId==-1){VId=Graph-&gt;GetNewVId();}
134    Graph-&gt;DefVId(VId);
135  }
136  TStr TEdge::EIdNm=&quot;EId&quot;;
137  TStr TEdge::VId1Nm=&quot;VId1&quot;;
138  TStr TEdge::VId2Nm=&quot;VId2&quot;;
139  TStr TEdge::PpNm=&quot;Pp&quot;;
140  TStr TEdge::DirPNm=&quot;Dir&quot;;
141  TStr TEdge::ENmNm=&quot;ENm&quot;;
142  TStr TEdge::MarkNm=&quot;Mark&quot;;
143  TStr TEdge::WgtNm=&quot;Wgt&quot;;
144  TStr TEdge::WidthNm=&quot;Width&quot;;
145  TStr TEdge::DNmNm=&quot;DNm&quot;;
146  TStr TEdge::BriefNm=&quot;Brief&quot;;
147  TStr TEdge::RectNm=&quot;Rect&quot;;
148  TStr TEdge::RectX1Nm=&quot;Rect|X1&quot;; TStr TEdge::X1Nm=&quot;X1&quot;;
149  TStr TEdge::RectY1Nm=&quot;Rect|Y1&quot;; TStr TEdge::Y1Nm=&quot;Y1&quot;;
150  TStr TEdge::RectX2Nm=&quot;Rect|X2&quot;; TStr TEdge::X2Nm=&quot;X2&quot;;
151  TStr TEdge::RectY2Nm=&quot;Rect|Y2&quot;; TStr TEdge::Y2Nm=&quot;Y2&quot;;
152  TStr TEdge::DmNm=&quot;Dm&quot;;
153  void TEdge::PutRect(const TGksRect&amp; Rect){
154    GetPp()-&gt;PutValInt(RectX1Nm, Rect.GetX1());
155    GetPp()-&gt;PutValInt(RectY1Nm, Rect.GetY1());
156    GetPp()-&gt;PutValInt(RectX2Nm, Rect.GetX2());
157    GetPp()-&gt;PutValInt(RectY2Nm, Rect.GetY2());
158  }
159  TGksRect TEdge::GetRect() const {
160    int X1=GetPp()-&gt;GetValInt(RectX1Nm);
161    int Y1=GetPp()-&gt;GetValInt(RectY1Nm);
162    int X2=GetPp()-&gt;GetValInt(RectX2Nm);
163    int Y2=GetPp()-&gt;GetValInt(RectY2Nm);
164    return TGksRect(X1, Y1, X2, Y2);
165  }
166  bool TEdge::IsInRect(const double&amp; X, const double&amp; Y) const {
167    TGksRect Rect=TEdge::GetRect();
168    return Rect.IsIn(int(X), int(Y));
169  }
170  PPp TEdge::GetDrawPp(){
171    PPp Pp=TPp::GetSetPp(&quot;Draw&quot;);
172    Pp-&gt;AddPpStr(DNmNm, &quot;&quot;, &quot;&quot;);
173    Pp-&gt;AddPpInt(BriefNm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
174    PPp RectPp=TPp::GetSetPp(RectNm);
175    RectPp-&gt;AddPpInt(X1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
176    RectPp-&gt;AddPpInt(Y1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
177    RectPp-&gt;AddPpInt(X2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
178    RectPp-&gt;AddPpInt(Y2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
179    Pp-&gt;AddPp(RectPp);
180    return Pp;
181  }
182  PEdge TEdge::LoadXml(const PXmlTok&amp; XmlTok){
183    int EId=XmlTok-&gt;GetIntArgVal(EIdNm);
184    int VId1=XmlTok-&gt;GetIntArgVal(VId1Nm);
185    int VId2=XmlTok-&gt;GetIntArgVal(VId2Nm);
186    bool DirP=XmlTok-&gt;GetBoolArgVal(DirPNm, true);
187    TStr ENm=XmlTok-&gt;GetStrArgVal(ENmNm, &quot;&quot;);
188    int Mark=XmlTok-&gt;GetIntArgVal(MarkNm, 0);
189    double Wgt=XmlTok-&gt;GetFltArgVal(WgtNm, 0);
190    int Width=int(XmlTok-&gt;GetFltArgVal(WidthNm, 0));
191    PPp Pp;
192    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
193    Edge-&gt;PutMark(Mark);
194    Edge-&gt;PutWgt(Wgt);
195    Edge-&gt;PutWidth(Width);
196    return Edge;
197  }
198  PXmlTok TEdge::GetXmlTok() const {
199    PXmlTok EdgeTok=TXmlTok::New(TGraph::EdgeNm);
200    EdgeTok-&gt;AddArg(EIdNm, GetEId());
201    EdgeTok-&gt;AddArg(VId1Nm, GetVId1());
202    EdgeTok-&gt;AddArg(VId2Nm, GetVId2());
203    if (!IsDir()){EdgeTok-&gt;AddArg(DirPNm, IsDir());}
204    if (!GetENm().Empty()){EdgeTok-&gt;AddArg(ENmNm, GetENm());}
205    if (GetMark()!=0){EdgeTok-&gt;AddArg(MarkNm, GetMark());}
206    if (GetWgt()!=0){EdgeTok-&gt;AddArg(WgtNm, GetWgt());}
207    if (GetWidth()!=0){EdgeTok-&gt;AddArg(WidthNm, GetWidth());}
208    return EdgeTok;
209  }
210  PEdge TEdge::LoadTxt(TILx&amp; Lx){
211    Lx.GetSym(syLBracket);
212    int EId=Lx.GetVarInt(EIdNm, false);
213    int VId1=Lx.GetVarInt(VId1Nm, false);
214    int VId2=Lx.GetVarInt(VId2Nm, false);
215    bool DirP=true; TStr ENm; int Mark=0; double Wgt=0; int Width=0; PPp Pp;
216    if (Lx.IsVar(DirPNm)){DirP=Lx.GetVarBool(DirPNm, false);}
217    if (Lx.IsVar(ENmNm)){ENm=Lx.GetVarStr(ENmNm, false);}
218    ENm=TXmlLx::GetPlainStrFromXmlStr(ENm);
219    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
220    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
221    if (Lx.IsVar(WidthNm)){Width=Lx.GetVarInt(WidthNm, false);}
222    if (Lx.IsVar(PpNm)){
223      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
224    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
225    Edge-&gt;PutMark(Mark); Edge-&gt;PutWgt(Wgt); Edge-&gt;PutWidth(Width);
226    Lx.GetSym(syRBracket);
227    return Edge;
228  }
229  void TEdge::SaveTxt(TOLx&amp; Lx) const {
230    Lx.PutSym(syLBracket);
231    Lx.PutVarInt(EIdNm, GetEId(), false);
232    Lx.PutVarInt(VId1Nm, GetVId1(), false);
233    Lx.PutVarInt(VId2Nm, GetVId2(), false);
234    if (!IsDir()){Lx.PutVarBool(DirPNm, IsDir(), false);}
235    TStr XmlENm=TXmlLx::GetXmlStrFromPlainStr(GetENm());
236    if (!GetENm().Empty()){Lx.PutVarStr(ENmNm, XmlENm(), false);}
237    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
238    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
239    if (GetWidth()!=0){Lx.PutVarInt(WidthNm, GetWidth(), false);}
240    if (!GetPp().Empty()){GetPp()-&gt;SaveTxt(Lx);}
241    Lx.PutSym(syRBracket);
242  }
243  TGEdge::TGEdge(const int&amp; _EId, const int&amp; _VId1, const int&amp; _VId2,
244   const bool&amp; _DirP, const TStr&amp; _ENm, const PPp&amp; _Pp):
245    TEdge(), EId(_EId), VId1(_VId1), VId2(_VId2),
246    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
247  }
248  TGEdge::TGEdge(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2,
249   const TStr&amp; _ENm, const bool&amp; _DirP, const PPp&amp; _Pp):
250    TEdge(), EId(-1), VId1(Vrtx1-&gt;GetVId()), VId2(Vrtx2-&gt;GetVId()),
251    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
252  }
253  void TGEdge::DefEdge(const PGraph&amp; Graph){
254    if (EId==-1){EId=Graph-&gt;GetNewEId();}
255    Graph-&gt;DefEId(EId);
256  }
257  TStr TGraph::PpNm=&quot;Pp&quot;;
258  TStr TGraph::VrtxNm=&quot;Vrtx&quot;;
259  TStr TGraph::EdgeNm=&quot;Edge&quot;;
260  TStr TGraph::GNmNm=&quot;GNm&quot;;
261  TStr TGraph::DNmNm=&quot;DNm&quot;;
262  TStr TGraph::BriefNm=&quot;Brief&quot;;
263  const TStr TGraph::FExt=&quot;.Graph&quot;;
264  const TStr TGraph::HitsFExt=&quot;.Hits&quot;;
265  const TStr TGraph::PageRankFExt=&quot;.PageRank&quot;;
266  THash&lt;TStr, TGraph::TGraphNewF&gt; TGraph::TypeToNewFH(10);
267  THash&lt;TStr, TGraph::TGraphLoadF&gt; TGraph::TypeToLoadFH(10);
268  PGraph TGraph::New(const TStr&amp; TypeNm){
269    TStr FinalTypeNm=TypeNm;
270    if (TypeNm.Empty()){FinalTypeNm=TTypeNm&lt;TGGraph&gt;();}
271    TGraphNewF NewF=TypeToNewFH.GetDat(FinalTypeNm);
272    return (*NewF())();
273  }
274  PGraph TGraph::Load(TSIn&amp; SIn){
275    TStr TypeNm(SIn);
276    TGraphLoadF LoadF=TypeToLoadFH.GetDat(TypeNm);
277    return (*LoadF())(SIn);
278  }
279  bool TGraph::Reg(
280   const TStr&amp; TypeNm, const TGraphNewF&amp; NewF, const TGraphLoadF&amp; LoadF){
281    IAssert(!TypeToNewFH.IsKey(TypeNm));
282    IAssert(!TypeToLoadFH.IsKey(TypeNm));
283    TypeToNewFH.AddDat(TypeNm, NewF);
284    TypeToLoadFH.AddDat(TypeNm, LoadF);
285    return true;
286  }
287  void TGraph::_GetMnMxXY(
288   double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const {
289    MnX=0; MxX=0; MnY=0; MxY=0;
290    int VrtxP=FFirstVrtx(); PVrtx Vrtx; bool First=true;
291    while (FNextVrtx(VrtxP, Vrtx)){
292      if (First){
293        MnX=Vrtx-&gt;GetX(); MxX=Vrtx-&gt;GetX();
294        MnY=Vrtx-&gt;GetY(); MxY=Vrtx-&gt;GetY();
295        First=false;
296      } else {
297        if (Vrtx-&gt;GetX()&lt;MnX){MnX=Vrtx-&gt;GetX();}
298        if (Vrtx-&gt;GetX()&gt;MxX){MxX=Vrtx-&gt;GetX();}
299        if (Vrtx-&gt;GetY()&lt;MnY){MnY=Vrtx-&gt;GetY();}
300        if (Vrtx-&gt;GetY()&gt;MxY){MxY=Vrtx-&gt;GetY();}
301      }
302    }
303  }
304  void TGraph::_AddBorders(const double&amp; BorderFac,
305   double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const {
306    if (MxX-MnX==0){MnX-=BorderFac; MxX+=BorderFac;}
307    else {MnX-=(MxX-MnX)*BorderFac; MxX+=(MxX-MnX)*BorderFac;}
308    if (MxY-MnY==0){MnY-=BorderFac; MxY+=BorderFac;}
309    else {MnY-=(MxY-MnY)*BorderFac; MxY+=(MxY-MnY)*BorderFac;}
310  }
311  void TGraph::RescaleXY(const double&amp; BorderFac, const PVrtx&amp; CenterVrtx) const {
312    double MnX; double MnY; double MxX; double MxY;
313    _GetMnMxXY(MnX, MnY, MxX, MxY);
314    if (!CenterVrtx.Empty()){
315      double CenterX=CenterVrtx-&gt;GetX();
316      double CenterY=CenterVrtx-&gt;GetY();
317      if (MxX-CenterX&gt;CenterX-MnX){MnX=CenterX-(MxX-CenterX);}
318      else {MxX=CenterX+(CenterX-MnX);}
319      if (MxY-CenterY&gt;CenterY-MnY){MnY=CenterY-(MxY-CenterY);}
320      else {MxY=CenterY+(CenterY-MnY);}
321    }
322    _AddBorders(BorderFac, MnX, MnY, MxX, MxY);
323    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
324    while (FNextVrtx(VrtxP, Vrtx)){
325      Vrtx-&gt;PutX((Vrtx-&gt;GetX()-MnX)/(MxX-MnX));
326      Vrtx-&gt;PutY((Vrtx-&gt;GetY()-MnY)/(MxY-MnY));
327    }
328  }
329  void TGraph::RescaleXY(const double&amp; MnX, const double&amp; MnY,
330   const double&amp; MxX, const double&amp; MxY) const {
331    if ((fabs(MxX-MnX)&lt;0.01)||(fabs(MxY-MnY)&lt;0.01)){return;}
332    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
333    while (FNextVrtx(VrtxP, Vrtx)){
334      Vrtx-&gt;PutX((Vrtx-&gt;GetX()-MnX)/(MxX-MnX));
335      Vrtx-&gt;PutY((Vrtx-&gt;GetY()-MnY)/(MxY-MnY));
336    }
337  }
338  int TGraph::_IsEdgeXYInts(
339   const PVrtx&amp; Vrtx0, const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const {
340    double dx1=Vrtx1-&gt;GetX()-Vrtx0-&gt;GetX();
341    double dy1=Vrtx1-&gt;GetY()-Vrtx0-&gt;GetY();
342    double dx2=Vrtx2-&gt;GetX()-Vrtx0-&gt;GetX();
343    double dy2=Vrtx2-&gt;GetY()-Vrtx0-&gt;GetY();
344    if (dx1*dy2&gt;dy1*dx2){return +1;}
345    if (dx1*dy2&lt;dy1*dx2){return -1;}
346    if ((dx1*dx2&lt;0)||(dy1*dy2&lt;0)){return -1;}
347    if ((dx1*dx1+dy1*dy1)&lt;(dx2*dx2+dy2*dy2)){return +1;}
348    return 0;
349  }
350  bool TGraph::IsEdgeXYInts(const PEdge&amp; Edge1, const PEdge&amp; Edge2) const {
351    PVrtx V11=GetVrtx(Edge1-&gt;GetVId1());
352    PVrtx V12=GetVrtx(Edge1-&gt;GetVId2());
353    PVrtx V21=GetVrtx(Edge2-&gt;GetVId1());
354    PVrtx V22=GetVrtx(Edge2-&gt;GetVId2());
355    return
356     ((_IsEdgeXYInts(V11, V12, V21)*_IsEdgeXYInts(V11, V12, V22))&lt;=0)&amp;&amp;
357     ((_IsEdgeXYInts(V21, V22, V11)*_IsEdgeXYInts(V21, V22, V12))&lt;=0);
358  }
359  double TGraph::GetVrtxXYLen(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const {
360    double Len=
361     TMath::Sqr(Vrtx2-&gt;GetX()-Vrtx1-&gt;GetX())+
362     TMath::Sqr(Vrtx2-&gt;GetY()-Vrtx1-&gt;GetY());
363    Len=sqrt(Len);
364    return Len;
365  }
366  double TGraph::GetEdgeXYLen(const PEdge&amp; Edge) const {
367    PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
368    PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
369    return GetVrtxXYLen(Vrtx1, Vrtx2);
370  }
371  double TGraph::GetSumEdgeXYLen() const {
<span onclick='openModal()' class='match'>372    double SumLen=0;
373    int EdgeP=FFirstEdge(); PEdge Edge;
374    while (FNextEdge(EdgeP, Edge)){
375      SumLen+=GetEdgeXYLen(Edge);
</span>376    }
377    return SumLen;
378  }
379  void TGraph::PlaceRndXY(TRnd&amp; Rnd) const {
380    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
381    while (FNextVrtx(VrtxP, Vrtx)){
382      Vrtx-&gt;PutX(Rnd.GetUniDev());
383      Vrtx-&gt;PutY(Rnd.GetUniDev());
384    }
385  }
386  void TGraph::PlaceBestRndXY(const int&amp; Tries, TRnd&amp; Rnd) const {
387    int BestSeed; double BestLen=-1;
388    for (int TryN=0; TryN&lt;Tries; TryN++){
389      int CurSeed=Rnd.GetSeed();
390      PlaceRndXY(Rnd);
391      double CurLen=GetSumEdgeXYLen();
392      if (TryN==0){
393        BestSeed=CurSeed; BestLen=CurLen;
394      } else
395      if (CurLen&lt;BestLen){
396        BestSeed=CurSeed; BestLen=CurLen;
397      }
398    }
399    Rnd.PutSeed(BestSeed);
400    PlaceRndXY(Rnd);
401  }
402  double TGraph::GetSimAnnXYEnergy(
403   const double&amp; NodeDistrWgt, const double&amp; BorderWgt,
404   const double&amp; EdgeLenWgt, const double&amp; EdgeCrossWgt,
405   const double&amp; NodeEdgeDistWgt, const bool&amp; UseNodeEdgeDist) const {
406    double Energy=0;
407    if (NodeDistrWgt!=0){
408      int Vrtx1P=FFirstVrtx(); PVrtx Vrtx1;
409      while (FNextVrtx(Vrtx1P, Vrtx1)){
410        int Vrtx2P=FFirstVrtx(); PVrtx Vrtx2;
411        while (FNextVrtx(Vrtx2P, Vrtx2)){
412          double EuclDist=
413           sqrt(TMath::Sqr(Vrtx1-&gt;GetX()-Vrtx2-&gt;GetX())+
414           TMath::Sqr(Vrtx1-&gt;GetY()-Vrtx2-&gt;GetY()));
415          if (EuclDist&gt;0){
416            Energy+=NodeDistrWgt/TMath::Sqr(EuclDist);}
417        }
418      }
419    }
420    if (BorderWgt!=0){
421      double Vrtxs=GetVrtxs();
422      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
423      while (FNextVrtx(VrtxP, Vrtx)){
424        double Right=1-Vrtx-&gt;GetX();
425        double Left=Vrtx-&gt;GetX();
426        double Top=Vrtx-&gt;GetY();
427        double Bottom=1-Vrtx-&gt;GetY();
428        if (Right&gt;0){Energy+=BorderWgt*TMath::Sqr(Right)*TMath::Sqr(Vrtxs);}
429        if (Left&gt;0){Energy+=BorderWgt*TMath::Sqr(Left)*TMath::Sqr(Vrtxs);}
430        if (Top&gt;0){Energy+=BorderWgt*TMath::Sqr(Top)*TMath::Sqr(Vrtxs);}
431        if (Bottom&gt;0){Energy+=BorderWgt*TMath::Sqr(Bottom)*TMath::Sqr(Vrtxs);}
432      }
433    }
434    if (EdgeLenWgt!=0){
435      double Vrtxs=GetVrtxs();
436      int EdgeP=FFirstEdge(); PEdge Edge;
437      while (FNextEdge(EdgeP, Edge)){
438        Energy+=EdgeLenWgt*TMath::Sqr(GetEdgeXYLen(Edge))*TMath::Sqr(Vrtxs);
439      }
440    }
441    if (EdgeCrossWgt!=0){
442      int Edge1P=FFirstEdge(); PEdge Edge1;
443      while (FNextEdge(Edge1P, Edge1)){
444        int Edge2P=Edge1P; PEdge Edge2;
445        while (FNextEdge(Edge2P, Edge2)){
446          if (&amp;Edge1!=&amp;Edge2){
447            if
448             ((Edge1-&gt;GetVId1()!=Edge2-&gt;GetVId1())&amp;&amp;
449             (Edge1-&gt;GetVId1()!=Edge2-&gt;GetVId2())&amp;&amp;
450             (Edge1-&gt;GetVId2()!=Edge2-&gt;GetVId1())&amp;&amp;
451             (Edge1-&gt;GetVId2()!=Edge2-&gt;GetVId2())){
452              if (IsEdgeXYInts(Edge1, Edge2)){
453                Energy+=EdgeCrossWgt;
454              }
455            }
456          }
457        }
458      }
459    }
460    if ((UseNodeEdgeDist)&amp;&amp;(NodeEdgeDistWgt!=0)){
461      int EdgeP=FFirstEdge(); PEdge Edge;
462      while (FNextEdge(EdgeP, Edge)){
463        double EdgeLen=GetEdgeXYLen(Edge);
464        PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
465        PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
466        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
467        while (FNextVrtx(VrtxP, Vrtx)){
468          if ((&amp;Vrtx!=&amp;Vrtx1)&amp;&amp;(&amp;Vrtx!=&amp;Vrtx2)){
469            double VrtxLen=GetVrtxXYLen(Vrtx, Vrtx1)+GetVrtxXYLen(Vrtx, Vrtx2);
470            if (EdgeLen!=VrtxLen){
471              Energy+=(NodeEdgeDistWgt/fabs(EdgeLen-VrtxLen));
472            }
473          }
474        }
475      }
476    }
477    return Energy;
478  }
479  double TGraph::GetSimAnnXYEnergy(
480   const PXmlDoc&amp; CfgXmlDoc, const bool&amp; UseNodeEdgeDist) const {
481    double NodeDistrWgt=10; 
482    double BorderWgt=20; 
483    double EdgeLenWgt=10; 
484    double EdgeCrossWgt=1000; 
485    double NodeEdgeDistWgt=10; 
486    if (!CfgXmlDoc.Empty()){
487      NodeDistrWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeDistrWgt&quot;, &quot;Val&quot;, NodeDistrWgt);
488      BorderWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|BorderWgt&quot;, &quot;Val&quot;, BorderWgt);
489      EdgeLenWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeLenWgt&quot;, &quot;Val&quot;, EdgeLenWgt);
490      EdgeCrossWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeCrossWgt&quot;, &quot;Val&quot;, EdgeCrossWgt);
491      NodeEdgeDistWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeEdgeDistWgt&quot;, &quot;Val&quot;, NodeEdgeDistWgt);
492    }
493    return GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt, EdgeCrossWgt,
494     NodeEdgeDistWgt, UseNodeEdgeDist);
495  }
496  void TGraph::PlaceSimAnnXY(
497   TRnd&amp; Rnd, const PGks&amp; Gks, const PXmlDoc&amp; CfgXmlDoc, const PNotify&amp; Notify,
498   const int&amp; _TempStages, const int&amp; _TempStageTrys, const int&amp; Secs) const {
499    int Trys=1; 
500    double StartTemp=1000; 
501    double TempFact=0.95; 
502    int TempStages=_TempStages; 
503    int TempStageTrys=_TempStageTrys; 
504    int FineTuningTrys=3000; 
505    if (!CfgXmlDoc.Empty()){
506      Trys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|Trys&quot;, &quot;Val&quot;, Trys);
507      StartTemp=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|StartTemp&quot;, &quot;Val&quot;, StartTemp);
508      TempFact=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|TempFact&quot;, &quot;Val&quot;, TempFact);
509      TempStages=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|TempStages&quot;, &quot;Val&quot;, TempStages);
510      TempStageTrys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|TempStageTrys&quot;, &quot;Val&quot;, TempStageTrys);
511      FineTuningTrys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|FineTuningTrys&quot;, &quot;Val&quot;, FineTuningTrys);
512    }
513    double NodeDistrWgt=10; 
514    double BorderWgt=25; 
515    double EdgeLenWgt=10; 
516    double EdgeCrossWgt=1000; 
517    double NodeEdgeDistWgt=10; 
518    if (!CfgXmlDoc.Empty()){
519      NodeDistrWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeDistrWgt&quot;, &quot;Val&quot;, NodeDistrWgt);
520      BorderWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|BorderWgt&quot;, &quot;Val&quot;, BorderWgt);
521      EdgeLenWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeLenWgt&quot;, &quot;Val&quot;, EdgeLenWgt);
522      EdgeCrossWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeCrossWgt&quot;, &quot;Val&quot;, EdgeCrossWgt);
523      NodeEdgeDistWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeEdgeDistWgt&quot;, &quot;Val&quot;, NodeEdgeDistWgt);
524    }
525    TSecTm StartTm=TSecTm::GetCurTm();
526    double MnEnergy=TFlt::Mx; 
527    typedef TPair&lt;PVrtx, TFltPr&gt; TVrtxXYPrPr;
528    TVec&lt;TVrtxXYPrPr&gt; VrtxXYPrPrV;
529    for (int TryN=0; TryN&lt;Trys; TryN++){
530      PlaceRndXY(Rnd); 
531      double Energy=TFlt::Mx; 
532      double Temp=StartTemp; 
533      double PrevEnergy=TFlt::Mx; 
534      for (int TempStageN=0; TempStageN&lt;TempStages; TempStageN++){
535        TNotify::OnStatus(Notify,
536         TInt::GetStr(1+TempStageN)+&quot;/&quot;+TInt::GetStr(TempStages)+&quot;\r&quot;);
537        for (int TempStageTryN=0; TempStageTryN&lt;TempStageTrys; TempStageTryN++){
538          PVrtx Vrtx=GetRndVrtx(Rnd); 
539          double PrevX=Vrtx-&gt;GetX();
540          double PrevY=Vrtx-&gt;GetY();
541          double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), Temp/StartTemp, 0, 1);
542          double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), Temp/StartTemp, 0, 1);
543          NewX=TFlt::GetInRng(NewX, 0, 1);
544          NewY=TFlt::GetInRng(NewY, 0, 1);
545          Vrtx-&gt;PutX(NewX);
546          Vrtx-&gt;PutY(NewY);
547          Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
548           EdgeCrossWgt, NodeEdgeDistWgt, false);
549          if (Energy&lt;PrevEnergy){
550            PrevEnergy=Energy;  
551          } else {
552            double MetrPrb=exp((PrevEnergy-Energy)/Temp);
553            double MetrRnd=Rnd.GetUniDev();
554            if (MetrRnd&gt;=MetrPrb){
555              Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
556            } else {
557              PrevEnergy=Energy; 
558            }
559          }
560        }
561        Temp*=TempFact; 
562        if (!Gks.Empty()){
563          Gks-&gt;Clr();
564          Draw(Gks, true);
565        }
566      }
567      if (Energy&lt;MnEnergy){
568        MnEnergy=Energy;
569        VrtxXYPrPrV.Gen(GetVrtxs(), 0);
570        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
571        while (FNextVrtx(VrtxP, Vrtx)){
572          TFltPr XYPr(Vrtx-&gt;GetX(), Vrtx-&gt;GetY()); 
573          TVrtxXYPrPr VrtxXYPrPr(Vrtx, XYPr); 
574          VrtxXYPrPrV.Add(VrtxXYPrPr);
575        }
576      }
577      TSecTm CurTm=TSecTm::GetCurTm();
578      if (Secs!=-1){
579        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
580      }
581    }
582    for (int VrtxXYPrPrN=0; VrtxXYPrPrN&lt;VrtxXYPrPrV.Len(); VrtxXYPrPrN++){
583      PVrtx Vrtx=VrtxXYPrPrV[VrtxXYPrPrN].Val1;
584      TFltPr XYPr=VrtxXYPrPrV[VrtxXYPrPrN].Val2;
585      double X=XYPr.Val1; double Y=XYPr.Val2;
586      Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y);
587    }
588    double PrevEnergy=TFlt::Mx; 
589    for (int FineTuningTryN=0; FineTuningTryN&lt;FineTuningTrys; FineTuningTryN++){
590      PVrtx Vrtx=GetRndVrtx(Rnd); 
591      double PrevX=Vrtx-&gt;GetX();
592      double PrevY=Vrtx-&gt;GetY();
593      double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), 0.001, 0, 1);
594      double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), 0.001, 0, 1);
595      Vrtx-&gt;PutX(NewX);
596      Vrtx-&gt;PutY(NewY);
597      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
598       EdgeCrossWgt, NodeEdgeDistWgt, true);
599      if (Energy&lt;PrevEnergy){
600        PrevEnergy=Energy;  
601      } else {
602        Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
603      }
604      if (FineTuningTryN%100==0){Draw(Gks, true);}
605      TSecTm CurTm=TSecTm::GetCurTm();
606      if (Secs!=-1){
607        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
608      }
609    }
610  }
611  void TGraph::PlaceFineTuning(
612   TRnd&amp; Rnd, const PGks&amp; Gks, const PNotify&amp; Notify, const int&amp; Secs) const {
613    int FineTuningTrys=3000; 
614    double NodeDistrWgt=10; 
615    double BorderWgt=25; 
616    double EdgeLenWgt=10; 
617    double EdgeCrossWgt=1000; 
618    double NodeEdgeDistWgt=10; 
619    TSecTm StartTm=TSecTm::GetCurTm();
620    double PrevEnergy=TFlt::Mx; 
621    for (int FineTuningTryN=0; FineTuningTryN&lt;FineTuningTrys; FineTuningTryN++){
622      PVrtx Vrtx=GetRndVrtx(Rnd); 
623      double PrevX=Vrtx-&gt;GetX();
624      double PrevY=Vrtx-&gt;GetY();
625      double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), 0.001, 0, 1);
626      double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), 0.001, 0, 1);
627      Vrtx-&gt;PutX(NewX);
628      Vrtx-&gt;PutY(NewY);
629      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
630       EdgeCrossWgt, NodeEdgeDistWgt, true);
631      if (Energy&lt;PrevEnergy){
632        PrevEnergy=Energy;  
633      } else {
634        Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
635      }
636      if (FineTuningTryN%100==0){Draw(Gks, true);}
637      TSecTm CurTm=TSecTm::GetCurTm();
638      if (Secs!=-1){
639        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
640      }
641    }
642  }
643  void TGraph::PlaceCircle() const {
644    double Vrtxs=GetVrtxs();
645    double AngStep=0; if (Vrtxs&gt;0){AngStep=2*TMath::Pi/Vrtxs;}
646    double Ang=0;
647    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
648    while (FNextVrtx(VrtxP, Vrtx)){
649      TGksPPoint PPoint(1, Ang);
650      TGksVPoint VPoint=PPoint.GetVPoint();
651      Vrtx-&gt;PutXY(VPoint.X, VPoint.Y);
652      Ang+=AngStep;
653    }
654  }
655  void TGraph::PlaceTreeAsStar(
656   const PVrtx&amp; HomeVrtx, const int&amp; Lev,
657   const double&amp; HomeX, const double&amp; HomeY,
658   const double&amp; MnAng, const double&amp; MxAng) const {
659    HomeVrtx-&gt;PutXY(HomeX, HomeY);
660    if (HomeVrtx-&gt;GetOutEIds()&gt;0){
661      double HalfAngStep=((MxAng-MnAng)/HomeVrtx-&gt;GetOutEIds())/2;
662      double Ang=MnAng;
663      for (int EIdN=0; EIdN&lt;HomeVrtx-&gt;GetOutEIds(); EIdN++){
664        PEdge Edge=GetEdge(HomeVrtx-&gt;GetOutEId(EIdN));
665        PVrtx NextVrtx=GetVrtx(Edge-&gt;GetOtherVId(HomeVrtx));
666        Ang+=HalfAngStep;
667        TGksPPoint PPoint(Lev+1, Ang);
668        TGksVPoint VPoint=PPoint.GetVPoint();
669        PlaceTreeAsStar(NextVrtx, Lev+1,
670         VPoint.X, VPoint.Y, Ang-HalfAngStep, Ang+HalfAngStep);
671        Ang+=HalfAngStep;
672      }
673    }
674  }
675  void TGraph::PlaceTreeAsStar() const {
676    PVrtx RootVrtx;
677    IAssert(IsTree(RootVrtx));
678    PlaceTreeAsStar(RootVrtx, 0, 0, 0, 0, 2*TMath::Pi);
679  }
680  void TGraph::PlaceGraphAsStar(const PVrtx&amp; HomeVrtx, const TStr&amp; DrawENm) const {
681      ClrVrtxMarks();
682      TVec&lt;TPair&lt;PVrtx,TFltPr&gt; &gt; LevVrtxV;
683      LevVrtxV.Add(TPair&lt;PVrtx,TFltPr&gt;(HomeVrtx, TFltPr(0.0, 2*TMath::Pi)));
684      HomeVrtx-&gt;SetMark();
685      int Level = 0;
686      while (!LevVrtxV.Empty()) {
687          for (int VrtxN = 0; VrtxN &lt; LevVrtxV.Len(); VrtxN++) {
688              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
689              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
690              const double Ang = MnAng + ((MxAng - MnAng)/2);
691              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
692              TGksPPoint PPoint(Level, Ang);
693              TGksVPoint VPoint=PPoint.GetVPoint();
694              Vrtx-&gt;PutXY(VPoint.X, VPoint.Y);
695          }
696          TVec&lt;TPair&lt;PVrtx,TFltPr&gt; &gt; NextLevVrtxV;
697          for (int VrtxN = 0; VrtxN &lt; LevVrtxV.Len(); VrtxN++) {
698              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
699              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
700              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
701              TVec&lt;PVrtx&gt; NextVrtxV;
702              const int EIds = Vrtx-&gt;GetInEIds();
703              for (int EIdN = 0; EIdN &lt; EIds; EIdN++) {
704                  PEdge Edge = GetEdge(Vrtx-&gt;GetInEId(EIdN));
705                  PVrtx NextVrtx = GetVrtx(Edge-&gt;GetOtherVId(Vrtx));
706                  if ((!NextVrtx-&gt;IsMark()) &amp;&amp; 
707                      (DrawENm.Empty() || (Edge-&gt;GetENm() == DrawENm))) {
708                          NextVrtxV.Add(NextVrtx);
709                  }
710              }
711              if (!NextVrtxV.Empty()) {
712                  double AngStep=(MxAng - MnAng)/NextVrtxV.Len();
713                  double Ang=MnAng;
714                  for (int VIdN=0; VIdN &lt; NextVrtxV.Len(); VIdN++){
715                      PVrtx NextVrtx=NextVrtxV[VIdN];
716                      const double NextMnAng = Ang;
717                      const double NextMxAng = Ang + AngStep;
718                      NextLevVrtxV.Add(TPair&lt;PVrtx,TFltPr&gt;(NextVrtx, TFltPr(NextMnAng, NextMxAng)));
719                      NextVrtx-&gt;SetMark();
720                      Ang += AngStep;
721                  }
722              }
723          }
724          Level++; LevVrtxV = NextLevVrtxV;
725      }
726  }
727  void TGraph::SetEdgeWidth(const int&amp; Intvs) const {
728    IAssert(Intvs&gt;0);
729    double MnWgt=TFlt::Mx; double MxWgt=TFlt::Mn;
730    {int EdgeP=FFirstEdge(); PEdge Edge;
731    while (FNextEdge(EdgeP, Edge)){
732      double Wgt=Edge-&gt;GetWgt();
733      MnWgt=TFlt::GetMn(MnWgt, Wgt);
734      MxWgt=TFlt::GetMx(MxWgt, Wgt);
735    }}
736    {int EdgeP=FFirstEdge(); PEdge Edge;
737    while (FNextEdge(EdgeP, Edge)){
738      double Wgt=Edge-&gt;GetWgt();
739      int Width=1;
740      if (MxWgt&gt;MnWgt){
741        Width=int(1+Intvs*((Wgt-MnWgt)/(MxWgt-MnWgt)));}
742      if (Width&gt;Intvs){Width=Intvs;} 
743      Edge-&gt;PutWidth(Width);
744    }}
745  }
746  void TGraph::Draw(const PGks&amp; Gks, const bool&amp; SimpleP,
747   const bool&amp; DrawEdgesP, const int&amp; FontSize,
748   const int&amp; EdgeFontSize, const int&amp; MxLnLen) const {
749    if (Gks.Empty()){return;}
750    TGksColor EdgeLineColor=TGksColor(0, 128, 0);
751    TGksColor EdgeBoxColor=TGksColor(0, 128, 0);
752    TGksColor NodeBoxColor=TGksColor(0, 0, 255);
753    TGksColor SelNodeBoxColor=TGksColor(255, 0, 0);
754    Gks-&gt;Clr();
755    Gks-&gt;SetPen(TGksPen::New(EdgeLineColor, gpmCopy, gpsSolid, 1));
756    Gks-&gt;SetBrush(TGksBrush::New(TGksColor::GetWhite(), gbsSolid));
757    Gks-&gt;SetFont(TGksFont::New(&quot;Tahoma&quot;, EdgeFontSize, TGksColor::GetBlack()));
758    if (DrawEdgesP){
759      {int PrevWidth=1;
760      int EdgeP=FFirstEdge(); PEdge Edge;
761      while (FNextEdge(EdgeP, Edge)){
762        PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
763        PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
764        bool DirP=Edge-&gt;IsDir();
765        int X1=Gks-&gt;GetVToPX(Vrtx1-&gt;GetX());
766        int Y1=Gks-&gt;GetVToPY(Vrtx1-&gt;GetY());
767        int X2=Gks-&gt;GetVToPX(Vrtx2-&gt;GetX());
768        int Y2=Gks-&gt;GetVToPY(Vrtx2-&gt;GetY());
769        int Width=TInt::GetMx(1, Edge-&gt;GetWidth());
770        if (Width!=PrevWidth){
771          PrevWidth=Width;
772          Gks-&gt;SetPen(TGksPen::New(TGksColor::GetGreen(), gpmCopy, gpsSolid, Width+1));
773        }
774        if (IsVrtxsEdge(Vrtx2-&gt;GetVId(), Vrtx1-&gt;GetVId(), true)){
775          if (DirP){Gks-&gt;DirLine(X1, Y1, X2, Y2, true, false, 10, 0.15);}
776          else {Gks-&gt;DirLine(X1, Y1, X2, Y2, false, false, 10, 0.15);}
777        } else {
778          if (DirP){Gks-&gt;DirLine(X1, Y1, X2, Y2, true, false, 10, 0.25);}
779          else {Gks-&gt;DirLine(X1, Y1, X2, Y2, false, false, 10, 0.25);}
780        }
781      }}
782      if (EdgeFontSize&gt;0){
783        Gks-&gt;SetPen(TGksPen::New(EdgeBoxColor, gpmCopy, gpsSolid, 2));
784        int EdgeP=FFirstEdge(); PEdge Edge;
785        while (FNextEdge(EdgeP, Edge)){
786          PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
787          PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
788          int X1=Gks-&gt;GetVToPX(Vrtx1-&gt;GetX());
789          int Y1=Gks-&gt;GetVToPY(Vrtx1-&gt;GetY());
790          int X2=Gks-&gt;GetVToPX(Vrtx2-&gt;GetX());
791          int Y2=Gks-&gt;GetVToPY(Vrtx2-&gt;GetY());
792          TStr Nm=(SimpleP) ? Edge-&gt;GetENm() : Edge-&gt;GetDNm();
793          if ((!Nm.Empty())&amp;&amp;(Nm[0]!=&#x27;_&#x27;)){
794            if (IsVrtxsEdge(Vrtx2-&gt;GetVId(), Vrtx1-&gt;GetVId(), true)){
795              TGksRect Rect=Gks-&gt;TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.60), int(Y1+(Y2-Y1)*0.60));
796            } else {
797              TGksRect Rect=Gks-&gt;TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.5), int(Y1+(Y2-Y1)*0.5));
798            }
799          }
800        }
801      }
802    }
803    TStr BoldVNm;
804    if (GetPp()-&gt;IsPp(&quot;BoldVNm&quot;)){
805      BoldVNm=GetPp()-&gt;GetValStr(&quot;BoldVNm&quot;);}
806    Gks-&gt;SetFont(TGksFont::New(&quot;Tahoma&quot;, FontSize, TGksColor::GetBlack(), TFSet(gfsBold)));
807    Gks-&gt;SetPen(TGksPen::New(TGksColor::GetBlue(), gpmCopy, gpsSolid, 1));
808    if (SimpleP){
809      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
810      while (FNextVrtx(VrtxP, Vrtx)){
811        TStr VNm=Vrtx-&gt;GetVNm();
812        if ((!VNm.Empty())&amp;&amp;(VNm[0]!=&#x27;_&#x27;)){
813          int X=Gks-&gt;GetVToPX(Vrtx-&gt;GetX());
814          int Y=Gks-&gt;GetVToPY(Vrtx-&gt;GetY());
815          TGksTxtBoxType TxtBoxType=gtbtRoundRect;
816          TGksColor Color=TGksColor::GetBlue();
817          if (Vrtx-&gt;GetColor()!=0){
818            Color.PutArgbVal(Vrtx-&gt;GetColor());}
819          if (VNm==BoldVNm){
820            Gks-&gt;SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 5));
821          } else {
822            Gks-&gt;SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 2));
823          }
824          if (MxLnLen!=-1){
825            TChA ChA=VNm; int LnChN=0;
826            for (int ChN=0; ChN&lt;ChA.Len(); ChN++){
827              if ((LnChN&gt;MxLnLen)&amp;&amp;(ChA[ChN]==&#x27; &#x27;)){ChA[ChN]=&#x27;\\&#x27;; LnChN=0;}
828              LnChN++;
829            }
830            VNm=ChA;
831          }
832          TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, VNm, X, Y);
833          Vrtx-&gt;PutRect(Rect);
834        }
835      }
836    } else {
837      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
838      while (FNextVrtx(VrtxP, Vrtx)){
839        TStr DNm=Vrtx-&gt;GetDNm();
840        int Brief=Vrtx-&gt;GetBrief();
841        int X=Gks-&gt;GetVToPX(Vrtx-&gt;GetX());
842        int Y=Gks-&gt;GetVToPY(Vrtx-&gt;GetY());
843        TGksTxtBoxType TxtBoxType=gtbtRect;
844        if (DNm==BoldVNm){
845          Gks-&gt;SetPen(TGksPen::New(SelNodeBoxColor, gpmCopy, gpsSolid, 2));
846        } else {
847          Gks-&gt;SetPen(TGksPen::New(NodeBoxColor, gpmCopy, gpsSolid, 2));
848        }
849        if (Brief==0){
850          TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, DNm, X, Y);
851          Vrtx-&gt;PutRect(Rect);
852        } else {
853          if (DNm.IsChIn(&#x27;#&#x27;)){
854            TStr TxtStr1; TStr TxtStr2;
855            DNm.SplitOnCh(TxtStr1, &#x27;#&#x27;, TxtStr2);
856            TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, TxtStr1, X, Y);
857            Vrtx-&gt;PutRect(Rect);
858          } else {
859            TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, DNm, X, Y);
860            Vrtx-&gt;PutRect(Rect);
861          }
862        }
863      }
864    }
865  }
866  void TGraph::_DrawTxtTree(const PVrtx&amp; Vrtx, TChAV&amp; LnV) const {
867    TStr VNm=
868     TStr::GetStr(Vrtx-&gt;GetVNm(), &quot;[%5s]-&quot;)+
869     TFlt::GetStr(Vrtx-&gt;GetWgt(), &quot;{%+4.2f}&quot;);
870    if (Vrtx-&gt;NoOutEIds()){
871      LnV.Add(VNm);
872      LnV.Add();
873    } else {
874      int VrtxLnN=LnV.Len(); TIntV OutLnNV; TStrV OutENmV;
875      for (int OutEIdN=0; OutEIdN&lt;Vrtx-&gt;GetOutEIds(); OutEIdN++){
876        PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(OutEIdN));
877        PVrtx OutVrtx=GetVrtx(Edge-&gt;GetOutVId());
878        OutENmV.Add();
879        OutLnNV.Add(LnV.Len());
880        _DrawTxtTree(OutVrtx, LnV);
881      }
882      int VrtxLevChN=0;
883      {for (int OutLnNN=0; OutLnNN&lt;OutLnNV.Len(); OutLnNN++){
884        int OutLnN=OutLnNV[OutLnNN];
885        VrtxLevChN=TInt::GetMx(VrtxLevChN, LnV[OutLnN].Len());
886      }}
887      LnV[VrtxLnN].AddChTo(&#x27;-&#x27;, VrtxLevChN);
888      LnV[VrtxLnN]+=&quot;-&quot;; LnV[VrtxLnN]+=OutENmV[0];
889      LnV[VrtxLnN]+=&quot;-+-&quot;; LnV[VrtxLnN]+=VNm;
890      {for (int OutLnNN=1; OutLnNN&lt;OutLnNV.Len(); OutLnNN++){
891        int OutLnN=OutLnNV[OutLnNN];
892        LnV[OutLnN].AddChTo(&#x27;-&#x27;, VrtxLevChN);
893        LnV[OutLnN]+=&quot;-&quot;; LnV[OutLnN]+=OutENmV[OutLnNN];
894        LnV[OutLnN]+=&quot;-+ &quot;;
895        for (int GapLnN=OutLnNV[OutLnNN-1]+1; GapLnN&lt;OutLnN; GapLnN++){
896          LnV[GapLnN].AddChTo(&#x27; &#x27;, VrtxLevChN+OutENmV[OutLnNN].Len()+1);
897          LnV[GapLnN]+=&quot; | &quot;;
898        }
899      }}
900    }
901  }
902  void TGraph::DrawTxtTree(const PSOut&amp; SOut) const {
903    PVrtx RootVrtx; IAssert(IsTree(RootVrtx));
904    TChAV LnV;
905    _DrawTxtTree(RootVrtx, LnV);
906    for (int LnN=0; LnN&lt;LnV.Len(); LnN++){
907      SOut-&gt;PutStr(LnV[LnN]); SOut-&gt;PutLn();
908    }
909  }
910  bool TGraph::IsVrtxAt(
911   const PGks&amp; &amp;bsol;*Gks*/, const int&amp; X, const int&amp; Y, PVrtx&amp; Vrtx) const {
912    int VrtxP=FFirstVrtx();
913    while (FNextVrtx(VrtxP, Vrtx)){
914      if (Vrtx-&gt;IsInRect(X, Y)){return true;}}
915    return false;
916  }
917  bool TGraph::IsEdgeAt(
918   const PGks&amp; &amp;bsol;*Gks*/, const int&amp; X, const int&amp; Y, PEdge&amp; Edge) const {
919    int EdgeP=FFirstEdge();
920    while (FNextEdge(EdgeP, Edge)){
921      if (Edge-&gt;IsInRect(X, Y)){return true;}}
922    return false;
923  }
924  bool TGraph::IsDir() const {
925    int EdgeP=FFirstEdge(); PEdge Edge;
926    while (FNextEdge(EdgeP, Edge)){
927      if (!Edge-&gt;IsDir()){return false;}}
928    return true;
929  }
930  bool TGraph::_IsDag(const PVrtx&amp; Vrtx, const int&amp; Mark) const {
931    if (Vrtx-&gt;GetMark()==Mark){printf(&quot;[Bad:%d]&quot;, Vrtx-&gt;GetVId()); return false;}
932    if (!Vrtx-&gt;IsMark()){
933      Vrtx-&gt;PutMark(Mark);
934      for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
935        PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
936        PVrtx Vrtx=GetVrtx(Edge-&gt;GetOutVId());
937        if (!_IsDag(Vrtx, Mark)){return false;}
938      }
939    }
940    return true;
941  }
942  bool TGraph::IsDag() const {
943    if (!IsDir()){return false;}
944    ClrVrtxMarks();
945    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int Mark=0;
946    while (FNextVrtx(VrtxP, Vrtx)){
947      if (!_IsDag(Vrtx, ++Mark)){return false;}
948    }
949    return true;
950  }
951  bool TGraph::IsTree(PVrtx&amp; RootVrtx) const {
952    if (!IsDir()){return false;}
953    if (!IsDag()){return false;}
954    RootVrtx=NULL;
955    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
956    while (FNextVrtx(VrtxP, Vrtx)){
957      if (Vrtx-&gt;GetInEIds()==0){
958        if (RootVrtx.Empty()){RootVrtx=Vrtx;} else {return false;}
959      }
960    }
961    return !Vrtx.Empty();
962  }
963  void TGraph::GetLeafVIdV(const int&amp; RootVId, TIntV&amp; VIdV) const {
964    IAssert(IsDag());
965    VIdV.Clr();
966    TIntQ VIdQ; VIdQ.Push(RootVId);
967    do {
968      int VId=VIdQ.Top(); VIdQ.Pop();
969      PVrtx Vrtx=GetVrtx(VId);
970      if (Vrtx-&gt;NoOutEIds()){
971        VIdV.Add(VId);
972      } else {
973        for (int OutEIdN=0; OutEIdN&lt;Vrtx-&gt;GetOutEIds(); OutEIdN++){
974          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(OutEIdN));
975          PVrtx OutVrtx=GetVrtx(Edge-&gt;GetOutVId());
976          VIdQ.Push(OutVrtx-&gt;GetVId());
977        }
978      }
979    } while (!VIdQ.Empty());
980  }
981  void TGraph::GetHitsW() const {
982    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
983    while (FNextVrtx(VrtxP, Vrtx)){
984      Vrtx-&gt;PutHitsHubW(1); Vrtx-&gt;PutHitsAuthW(1);}}
985    double EpsChange=1/double(GetVrtxs());
986    double MxChange; double SumChange=0;
987    TFltV PrevHubWV(GetVrtxs()); TFltV PrevAuthWV(GetVrtxs());
988    int IterN=0; printf(&quot;\n&quot;);
989    do {
990      MxChange=0; SumChange=0;
991      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
992      while (FNextVrtx(VrtxP, Vrtx)){
993        double AuthW=0;
994        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetInEIds(); EIdN++){
995          PEdge Edge=GetEdge(Vrtx-&gt;GetInEId(EIdN));
996          PVrtx SrcVrtx=GetVrtx(Edge-&gt;GetInVId());
997          AuthW+=SrcVrtx-&gt;GetHitsHubW();
998        }
999        Vrtx-&gt;PutHitsAuthW(AuthW);
1000      }}
1001      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1002      while (FNextVrtx(VrtxP, Vrtx)){
1003        double HubW=0;
1004        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
1005          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
1006          PVrtx DstVrtx=GetVrtx(Edge-&gt;GetOutVId());
1007          HubW+=DstVrtx-&gt;GetHitsAuthW();
1008        }
1009        Vrtx-&gt;PutHitsHubW(HubW);
1010      }}
1011      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1012      while (FNextVrtx(VrtxP, Vrtx)){
1013        Vrtx-&gt;PutHitsAuthW(log(1+Vrtx-&gt;GetHitsAuthW()));}}
1014      double SumSqrAuthW=0;
1015      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1016      while (FNextVrtx(VrtxP, Vrtx)){
1017        SumSqrAuthW+=TMath::Sqr(Vrtx-&gt;GetHitsAuthW());}}
1018      double SqrtSumSqrAuthW=sqrt(SumSqrAuthW);
1019      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1020      while (FNextVrtx(VrtxP, Vrtx)){
1021        double AuthW=Vrtx-&gt;GetHitsAuthW()/SqrtSumSqrAuthW;
1022        Vrtx-&gt;PutHitsAuthW(AuthW);}}
1023      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1024      while (FNextVrtx(VrtxP, Vrtx)){
1025        Vrtx-&gt;PutHitsHubW(log(1+Vrtx-&gt;GetHitsHubW()));}}
1026      double SumSqrHubW=0;
1027      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1028      while (FNextVrtx(VrtxP, Vrtx)){
1029        SumSqrHubW+=TMath::Sqr(Vrtx-&gt;GetHitsHubW());}}
1030      double SqrtSumSqrHubW=sqrt(SumSqrHubW);
1031      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1032      while (FNextVrtx(VrtxP, Vrtx)){
1033        double HubW=Vrtx-&gt;GetHitsHubW()/SqrtSumSqrHubW;
1034        Vrtx-&gt;PutHitsHubW(HubW);}}
1035      {int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1036      while (FNextVrtx(VrtxP, Vrtx)){
1037        double HubWChange=fabs(Vrtx-&gt;GetHitsHubW()-PrevHubWV[VrtxN]);
1038        double AuthWChange=fabs(Vrtx-&gt;GetHitsAuthW()-PrevAuthWV[VrtxN]);
1039        if (HubWChange&gt;MxChange){MxChange=HubWChange;}
1040        if (AuthWChange&gt;MxChange){MxChange=AuthWChange;}
1041        SumChange+=HubWChange; SumChange+=AuthWChange;
1042        PrevHubWV[VrtxN]=Vrtx-&gt;GetHitsHubW();
1043        PrevAuthWV[VrtxN]=Vrtx-&gt;GetHitsAuthW();
1044        VrtxN++;
1045      }}
1046      IterN++;
1047      printf(&quot;Iteration: %d   Max. Change: %g   Eps. Change: %g\n&quot;,
1048       IterN, MxChange, EpsChange);
1049    } while (IterN&lt;20); 
1050  }
1051  void TGraph::GetTopHitsVrtxV(
1052   TVrtxV&amp; TopHubVrtxV, TVrtxV&amp; TopAuthVrtxV) const {
1053    typedef TKeyDat&lt;TFlt, PVrtx&gt; TWgtVrtxKd;
1054    TVec&lt;TWgtVrtxKd&gt; WgtVrtxKdV;
1055    TopHubVrtxV.Gen(GetVrtxs(), 0);
1056    TopAuthVrtxV.Gen(GetVrtxs(), 0);
1057    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1058    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1059    while (FNextVrtx(VrtxP, Vrtx)){
1060      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx-&gt;GetHitsHubW(), Vrtx));}}
1061    WgtVrtxKdV.Sort(false);
1062    for (int VrtxN=0; VrtxN&lt;WgtVrtxKdV.Len(); VrtxN++){
1063      TopHubVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}
1064    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1065    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1066    while (FNextVrtx(VrtxP, Vrtx)){
1067      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx-&gt;GetHitsAuthW(), Vrtx));}}
1068    WgtVrtxKdV.Sort(false);
1069    {for (int VrtxN=0; VrtxN&lt;WgtVrtxKdV.Len(); VrtxN++){
1070      TopAuthVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}}
1071  }
1072  void TGraph::GetConnVrtxV(PVrtx&amp; RootVrtx, TVrtxV&amp; ConnVrtxV) const {
1073    ConnVrtxV.Clr();
1074    ClrVrtxMarks();
1075    TQQueue&lt;PVrtx&gt; VrtxQ;
1076    VrtxQ.Push(RootVrtx);
1077    while (!VrtxQ.Empty()){
1078      PVrtx Vrtx=VrtxQ.Top(); VrtxQ.Pop();
1079      if (!Vrtx-&gt;IsMark()){
1080        ConnVrtxV.Add(Vrtx);
1081        Vrtx-&gt;PutMark(true);
1082        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
1083          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
1084          VrtxQ.Push(GetVrtx(Edge-&gt;GetVId1()));
1085          VrtxQ.Push(GetVrtx(Edge-&gt;GetVId2()));
1086        }
1087      }
1088    }
1089  }
1090  PGraph TGraph::GetRndGraph(
1091   TRnd&amp; Rnd, const int&amp; Vrtxs, const int&amp; Edges,
1092   const bool&amp; DirEdgeP, const int&amp; EdgeToSameVrtxP){
1093    IAssert((Vrtxs&gt;=0)&amp;&amp;(Edges&gt;=0));
1094    PGraph Graph=New();
1095    for (int VrtxN=0; VrtxN&lt;Vrtxs; VrtxN++){
1096      PVrtx Vrtx=PVrtx(new TGVrtx()); Graph-&gt;AddVrtx(Vrtx);}
1097    int EdgeN=0;
1098    while (Graph-&gt;GetEdges()&lt;Edges){
1099      PVrtx Vrtx1=Graph-&gt;GetRndVrtx(Rnd);
1100      PVrtx Vrtx2=Graph-&gt;GetRndVrtx(Rnd);
1101      while ((!EdgeToSameVrtxP)&amp;&amp;(Vrtx1==Vrtx2)){
1102        IAssert(Vrtxs&gt;1); Vrtx2=Graph-&gt;GetRndVrtx(Rnd);}
1103      PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, TStr::GetNullStr(), DirEdgeP));
1104      Graph-&gt;AddEdge(Edge); EdgeN++;
1105    }
1106    return Graph;
1107  }
1108  PGraph TGraph::LoadXml(const PXmlDoc&amp; XmlDoc, const TStr&amp; TypeNm){
1109    PXmlTok GraphTok=XmlDoc-&gt;GetTok();
1110    EAssertR(GraphTok-&gt;IsTag(&quot;Graph&quot;), &quot;Bad root XML tag (&lt;Graph&gt; expected).&quot;);
1111    int GraphSubToks=GraphTok-&gt;GetSubToks();
1112    TStr FinalTypeNm=TypeNm;
1113    if (FinalTypeNm.Empty()){
1114      FinalTypeNm=XmlDoc-&gt;GetTok()-&gt;GetArgVal(&quot;TypeNm&quot;, &quot;&quot;);}
1115    PGraph Graph=New(FinalTypeNm);
1116    for (int GraphTokN=0; GraphTokN&lt;GraphSubToks; GraphTokN++){
1117      PXmlTok Tok=GraphTok-&gt;GetSubTok(GraphTokN);
1118      if (Tok-&gt;IsTag(TGraph::VrtxNm)){
1119        PVrtx Vrtx=TVrtx::LoadXml(Tok);
1120        Graph-&gt;AddVrtx(Vrtx);
1121      }
1122    }
1123    {for (int GraphTokN=0; GraphTokN&lt;GraphSubToks; GraphTokN++){
1124      PXmlTok Tok=GraphTok-&gt;GetSubTok(GraphTokN);
1125      if (Tok-&gt;IsTag(TGraph::EdgeNm)){
1126        PEdge Edge=TEdge::LoadXml(Tok);
1127        Graph-&gt;AddEdge(Edge);
1128      }
1129    }}
1130    return Graph;
1131  }
1132  PXmlDoc TGraph::GetXmlDoc() const {
1133    PXmlTok GraphTok=TXmlTok::New(&quot;Graph&quot;);
1134    GraphTok-&gt;AddArg(&quot;TypeNm&quot;, GetTypeNm());
1135    for (int PpN=0; PpN&lt;GetPps(); PpN++){
1136      GraphTok-&gt;AddArg(PpNm, GetPp(PpN)-&gt;GetStr());
1137    }
1138    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1139    while (FNextVrtx(VrtxP, Vrtx)){
1140      PXmlTok VrtxTok=Vrtx-&gt;GetXmlTok();
1141      GraphTok-&gt;AddSubTok(VrtxTok);
1142    }
1143    int EdgeP=FFirstEdge(); PEdge Edge;
1144    while (FNextEdge(EdgeP, Edge)){
1145      PXmlTok EdgeTok=Edge-&gt;GetXmlTok();
1146      GraphTok-&gt;AddSubTok(EdgeTok);
1147    }
1148    PXmlDoc GraphDoc=TXmlDoc::New(GraphTok);
1149    return GraphDoc;
1150  }
1151  PGraph TGraph::LoadTxt(const PSIn&amp; SIn, const TStr&amp; TypeNm){
1152    TILx Lx(SIn, TFSet()|iloCmtAlw|iloSigNum);
1153    TStr FinalTypeNm=TypeNm;
1154    if (Lx.GetSym(syIdStr, syLBracket)==syIdStr){
1155      if (FinalTypeNm.Empty()){FinalTypeNm=Lx.Str;}
1156      Lx.GetSym(syColon); Lx.GetSym(syLBracket);
1157    }
1158    PGraph Graph=New(FinalTypeNm);
1159    while (Lx.GetSym(syIdStr, syRBracket)==syIdStr){
1160      TStr Tag=Lx.Str;
1161      Lx.GetSym(syColon);
1162      if (Tag==PpNm){
1163        PPp Pp=TPp::LoadTxt(Lx);
1164        Graph-&gt;AddPp(Pp);
1165      } else
1166      if (Tag==VrtxNm){
1167        PVrtx Vrtx=TVrtx::LoadTxt(Lx);
1168        Graph-&gt;AddVrtx(Vrtx);
1169      } else
1170      if (Tag==EdgeNm){
1171        PEdge Edge=TEdge::LoadTxt(Lx);
1172        Graph-&gt;AddEdge(Edge);
1173      } else {
1174        Fail;
1175      }
1176    }
1177    return Graph;
1178  }
1179  void TGraph::SaveTxt(const PSOut&amp; SOut) const {
1180    TOLx Lx(SOut, TFSet()|oloCmtAlw|oloFrcEoln|oloSigNum);
1181    Lx.PutVar(GetTypeNm(), true, true);
1182    for (int PpN=0; PpN&lt;GetPps(); PpN++){
1183      Lx.PutIdStr(PpNm); Lx.PutSym(syColon);
1184      GetPp(PpN)-&gt;SaveTxt(Lx); Lx.PutLn();
1185    }
1186    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1187    while (FNextVrtx(VrtxP, Vrtx)){
1188      Lx.PutIdStr(VrtxNm); Lx.PutSym(syColon);
1189      Vrtx-&gt;SaveTxt(Lx); Lx.PutLn();
1190    }
1191    int EdgeP=FFirstEdge(); PEdge Edge;
1192    while (FNextEdge(EdgeP, Edge)){
1193      Lx.PutIdStr(EdgeNm); Lx.PutSym(syColon);
1194      Edge-&gt;SaveTxt(Lx); Lx.PutLn();
1195    }
1196    Lx.PutVarEnd(true, true);
1197  }
1198  void TGraph::SaveTxtTab(const TStr&amp; FNm) const {
1199    TFOut TabFOut(FNm); FILE* fTab=TabFOut.GetFileId();
1200    fprintf(fTab, &quot;VH\tVId\tName\tX\tY\n&quot;);
1201    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1202    while (FNextVrtx(VrtxP, Vrtx)){
1203      fprintf(fTab, &quot;V\t%d\t%s\t%g\t%g\n&quot;,
1204       Vrtx-&gt;GetVId(), Vrtx-&gt;GetVNm().CStr(), Vrtx-&gt;GetX(), Vrtx-&gt;GetY());
1205    }
1206    fprintf(fTab, &quot;EH\tEId\tVId1\tVId2\tDir\tName\tWidth\n&quot;);
1207    int EdgeP=FFirstEdge(); PEdge Edge;
1208    while (FNextEdge(EdgeP, Edge)){
1209      fprintf(fTab, &quot;E\t%d\t%d\t%d\t%s\t%s\t%d\n&quot;,
1210       Edge-&gt;GetEId(), Edge-&gt;GetVId1(), Edge-&gt;GetVId2(),
1211       TBool::GetStr(Edge-&gt;IsDir()).CStr(), Edge-&gt;GetENm().CStr(),
1212       Edge-&gt;GetWidth());
1213    }
1214  }
1215  void TGraph::SaveTxtPajek(const TStr&amp; FNm) const {
1216    PSOut SOut=TFOut::New(FNm);
1217    SOut-&gt;PutStr(&quot;*vertices &quot;);
1218    int Vrtxs=GetVrtxs();
1219    SOut-&gt;PutStr(TInt::GetStr(Vrtxs));
1220    SOut-&gt;PutDosLn();
1221    TIntIntH VIdToVrtxNH(Vrtxs);
1222    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1223    while (FNextVrtx(VrtxP, Vrtx)){
1224      VrtxN++;
1225      VIdToVrtxNH.AddDat(Vrtx-&gt;GetVId(), VrtxN);
1226      SOut-&gt;PutStr(TInt::GetStr(VrtxN));
1227      SOut-&gt;PutStr(TStr(&quot; \&quot;&quot;)+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;);
1228      SOut-&gt;PutDosLn();
1229    }
1230    SOut-&gt;PutStr(&quot;*arcs&quot;); SOut-&gt;PutDosLn();
1231    int EdgeP=FFirstEdge(); PEdge Edge;
1232    while (FNextEdge(EdgeP, Edge)){
1233      int VId1=Edge-&gt;GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1234      int VId2=Edge-&gt;GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1235      SOut-&gt;PutStr(TInt::GetStr(VrtxN1)+&quot; &quot;+TInt::GetStr(VrtxN2));
1236      SOut-&gt;PutDosLn();
1237    }
1238  }
1239  void TGraph::SaveTxtMatlab(const TStr&amp; FNm) const {
1240    PSOut VrtxSOut=TFOut::New(TStr::PutFExt(FNm, &quot;.vrtx-names.dat&quot;));
1241    int Vrtxs=GetVrtxs(); TIntIntH VIdToVrtxNH(Vrtxs);
1242    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1243    while (FNextVrtx(VrtxP, Vrtx)){
1244      VrtxN++;
1245      VIdToVrtxNH.AddDat(Vrtx-&gt;GetVId(), VrtxN);
1246      VrtxSOut-&gt;PutStrLn(Vrtx-&gt;GetVNm());
1247    }
1248    PSOut EdgeSOut=TFOut::New(FNm);
1249    int EdgeP=FFirstEdge(); PEdge Edge;
1250    while (FNextEdge(EdgeP, Edge)){
1251      int VId1=Edge-&gt;GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1252      int VId2=Edge-&gt;GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1253      const double Wgt = Edge-&gt;GetWgt();
1254      EdgeSOut-&gt;PutStrLn(TStr::Fmt(&quot;%d %d %g&quot;, 
1255          TInt::GetMn(VrtxN1, VrtxN2), TInt::GetMx(VrtxN1, VrtxN2), Wgt));
1256    }
1257  }
1258  void TGraph::SaveTxtHits(const TStr&amp; FNm, const int&amp; TopN) const {
1259    TVrtxV HubVrtxV; TVrtxV AuthVrtxV;
1260    GetTopHitsVrtxV(HubVrtxV, AuthVrtxV);
1261    PSOut SOut=TFOut::New(FNm);
1262    int HubVrtxs=(TopN==-1) ? HubVrtxV.Len() : TInt::GetMn(TopN, HubVrtxV.Len());
1263    SOut-&gt;PutStr(&quot;---Hubs---------------------------&quot;); SOut-&gt;PutLn();
1264    for (int VrtxN=0; VrtxN&lt;HubVrtxs; VrtxN++){
1265      PVrtx Vrtx=HubVrtxV[VrtxN];
1266      TStr RankStr=TInt::GetStr(1+VrtxN, &quot;%d.&quot;);
1267      TStr WgtStr=TFlt::GetStr(Vrtx-&gt;GetHitsHubW(), &quot;%0.4g&quot;);
1268      TStr InStr=TStr(&quot;in:&quot;)+TInt::GetStr(Vrtx-&gt;GetInEIds(), &quot;%2d&quot;);
1269      TStr OutStr=TStr(&quot;out:&quot;)+TInt::GetStr(Vrtx-&gt;GetOutEIds(), &quot;%2d&quot;);
1270      TStr Str=RankStr+&quot; &quot;+WgtStr+&quot; -&gt; &quot;+InStr+&quot; &quot;+OutStr+&quot; \&quot;&quot;+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;;
1271      SOut-&gt;PutStr(Str); SOut-&gt;PutLn();
1272    }
1273    int AuthVrtxs=(TopN==-1) ? AuthVrtxV.Len() : TInt::GetMn(TopN, AuthVrtxV.Len());
1274    SOut-&gt;PutStr(&quot;---Authorities--------------------&quot;); SOut-&gt;PutLn();
1275    {for (int VrtxN=0; VrtxN&lt;AuthVrtxs; VrtxN++){
1276      PVrtx Vrtx=AuthVrtxV[VrtxN];
1277      TStr RankStr=TInt::GetStr(1+VrtxN, &quot;%d. &quot;);
1278      TStr WgtStr=TFlt::GetStr(Vrtx-&gt;GetHitsAuthW(), &quot;%0.4g&quot;);
1279      TStr InStr=TStr(&quot;in:&quot;)+TInt::GetStr(Vrtx-&gt;GetInEIds(), &quot;%2d&quot;);
1280      TStr OutStr=TStr(&quot;out:&quot;)+TInt::GetStr(Vrtx-&gt;GetOutEIds(), &quot;%2d&quot;);
1281      TStr Str=RankStr+&quot; &quot;+WgtStr+&quot; -&gt; &quot;+InStr+&quot; &quot;+OutStr+&quot; \&quot;&quot;+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;;
1282      SOut-&gt;PutStr(Str); SOut-&gt;PutLn();
1283    }}
1284  }
1285  void TGraph::_SaveTxtSparseNbrs(const int&amp; SrcVId,
1286   const int&amp; Lev, const int&amp; MxLev, TIntFltH&amp; VIdToWgtH) const {
1287    if (Lev&lt;=MxLev){
1288      PVrtx SrcVrtx=GetVrtx(SrcVId);
1289      for (int EIdN=0; EIdN&lt;SrcVrtx-&gt;GetOutEIds(); EIdN++){
1290        PEdge Edge=GetEdge(SrcVrtx-&gt;GetOutEId(EIdN));
1291        int DstVId=Edge-&gt;GetOtherVId(SrcVrtx);
1292        VIdToWgtH.AddDat(DstVId)+=1.0/(Lev+1);
1293        _SaveTxtSparseNbrs(DstVId, Lev+1, MxLev, VIdToWgtH);
1294      }
1295    }
1296  }
1297  void TGraph::SaveTxtSparseNbrs(
1298   const TStr&amp; VarIdFNm, const TStr&amp; TupIdFNm, const TStr&amp; TupVarValFNm,
1299   const int&amp; MxLev) const {
1300    {PSOut VarIdSOut=TFOut::New(VarIdFNm);
1301    PSOut TupIdSOut=TFOut::New(TupIdFNm);
1302    PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1303    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1304    while (FNextVrtx(VrtxP, Vrtx)){
1305      TStr NrVNm=Vrtx-&gt;GetVNm(); NrVNm.ChangeChAll(&#x27;&quot;&#x27;, &#x27;\&#x27;&#x27;);
1306      TChA ChA;
1307      ChA+=TInt::GetStr(Vrtx-&gt;GetVId()); ChA+=&#x27;:&#x27;;
1308      ChA+=&#x27;&quot;&#x27;; ChA+=NrVNm; ChA+=&#x27;&quot;&#x27;; ChA+=&#x27;\n&#x27;;
1309      TupIdSOut-&gt;PutStr(ChA);
1310      VarIdSOut-&gt;PutStr(ChA);
1311    }}
1312    {PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1313    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1314    while (FNextVrtx(VrtxP, Vrtx)){
1315      int VId=Vrtx-&gt;GetVId();
1316      TIntFltH VIdToWgtH;
1317      VIdToWgtH.AddDat(VId, 1);
1318      _SaveTxtSparseNbrs(VId, 1, MxLev, VIdToWgtH);
1319      TIntFltPrV VIdWgtPrV; VIdToWgtH.GetKeyDatPrV(VIdWgtPrV);
1320      VIdWgtPrV.Sort();
1321      TChA ChA;
1322      ChA+=TInt::GetStr(VId);
1323      for (int VIdN=0; VIdN&lt;VIdWgtPrV.Len(); VIdN++){
1324        ChA+=&#x27; &#x27;; ChA+=TInt::GetStr(VIdWgtPrV[VIdN].Val1);
1325        ChA+=&#x27;:&#x27;; ChA+=TFlt::GetStr(VIdWgtPrV[VIdN].Val2, &quot;%.3f&quot;);
1326      }
1327      ChA+=&#x27;\n&#x27;;
1328      TupVarValSOut-&gt;PutStr(ChA);
1329    }}
1330  }
1331  bool TGGraph::IsReg=TGGraph::MkReg();
1332  int TGGraph::AddVrtx(const PVrtx&amp; Vrtx){
1333    Vrtx-&gt;DefVrtx(this);
1334    int VId=Vrtx-&gt;GetVId();
1335    TStr VNm=Vrtx-&gt;GetVNm();
1336    IAssert(!VIdToVrtxH.IsKey(VId));
1337    VIdToVrtxH.AddDat(VId, Vrtx);
1338    if (!VNm.Empty()){VNmToVIdH.AddDat(VNm, VId);}
1339    return VId;
1340  }
1341  void TGGraph::DelVrtx(const PVrtx&amp; Vrtx){
1342    while (Vrtx-&gt;GetInEIds()&gt;0){
1343      DelEdge(Vrtx-&gt;GetInEId(0));}
1344    while (Vrtx-&gt;GetOutEIds()&gt;0){
1345      DelEdge(Vrtx-&gt;GetOutEId(0));}
1346    VIdToVrtxH.DelKey(Vrtx-&gt;GetVId());
1347    if (!Vrtx-&gt;GetVNm().Empty()){VNmToVIdH.DelKey(Vrtx-&gt;GetVNm());}
1348  }
1349  bool TGGraph::IsVrtx(const TStr&amp; VNm, PVrtx&amp; Vrtx) const {
1350    int VNmToVIdP;
1351    if (VNmToVIdH.IsKey(VNm, VNmToVIdP)){
1352      Vrtx=GetVrtx(VNmToVIdH[VNmToVIdP]); return true;}
1353    else {return false;}
1354  }
1355  bool TGGraph::FNextVrtx(int&amp; VrtxP, PVrtx&amp; Vrtx) const {
1356    if (VIdToVrtxH.FNextKeyId(VrtxP)){
1357      Vrtx=VIdToVrtxH[VrtxP]; return true;}
1358    else {return false;}
1359  }
1360  void TGGraph::ClrVrtxMarks() const {
1361    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1362    while (FNextVrtx(VrtxP, Vrtx)){
1363      Vrtx-&gt;ClrMark();}
1364  }
1365  int TGGraph::AddEdge(const PEdge&amp; Edge){
1366    Edge-&gt;DefEdge(this);
1367    int EId=Edge-&gt;GetEId();
1368    int VId1=Edge-&gt;GetVId1();
1369    int VId2=Edge-&gt;GetVId2();
1370    bool DirP=Edge-&gt;IsDir();
1371    TStr ENm=Edge-&gt;GetENm();
1372    IAssert(!EIdToEdgeH.IsKey(EId));
1373    IAssert(VIdToVrtxH.IsKey(VId1));
1374    IAssert(VIdToVrtxH.IsKey(VId2));
1375    DefEId(EId);
1376    EIdToEdgeH.AddDat(EId, Edge);
1377    if (!ENm.Empty()){ENmToEIdH.AddDat(ENm, EId);}
1378    VIdToVrtxH.GetDat(VId1)-&gt;AddOutEId(EId);
1379    VIdToVrtxH.GetDat(VId2)-&gt;AddInEId(EId);
1380    if (!DirP){
1381      VIdToVrtxH.GetDat(VId1)-&gt;AddInEId(EId);
1382      VIdToVrtxH.GetDat(VId2)-&gt;AddOutEId(EId);
1383    }
1384    return EId;
1385  }
1386  void TGGraph::DelEdge(const PEdge&amp; Edge){
1387    int EId=Edge-&gt;GetEId();
1388    int VId1=Edge-&gt;GetVId1();
1389    int VId2=Edge-&gt;GetVId2();
1390    GetVrtx(VId1)-&gt;DelEId(EId);
1391    GetVrtx(VId2)-&gt;DelEId(EId);
1392    EIdToEdgeH.DelKey(Edge-&gt;GetEId());
1393    if (!Edge-&gt;GetENm().Empty()){
1394      if (ENmToEIdH.IsKey(Edge-&gt;GetENm())){
1395        ENmToEIdH.DelKey(Edge-&gt;GetENm());}
1396    }
1397  }
1398  bool TGGraph::IsEdge(const TStr&amp; ENm, PEdge&amp; Edge) const {
1399    int ENmToEIdP;
1400    if (ENmToEIdH.IsKey(ENm, ENmToEIdP)){
1401      Edge=GetEdge(ENmToEIdH[ENmToEIdP]); return true;}
1402    else {return false;}
1403  }
1404  bool TGGraph::FNextEdge(int&amp; EdgeP, PEdge&amp; Edge) const {
1405    if (EIdToEdgeH.FNextKeyId(EdgeP)){
1406      Edge=EIdToEdgeH[EdgeP]; return true;}
1407    else {return false;}
1408  }
1409  bool TGGraph::IsVrtxsEdge(
1410   const int&amp; VId1, const int&amp; VId2, const bool&amp; DirP, PEdge&amp; Edge) const {
1411    PVrtx Vrtx1=GetVrtx(VId1);
1412    PVrtx Vrtx2=GetVrtx(VId2);
1413    for (int EIdN=0; EIdN&lt;Vrtx1-&gt;GetOutEIds(); EIdN++){
1414      Edge=GetEdge(Vrtx1-&gt;GetOutEId(EIdN));
1415      if (VId2==Edge-&gt;GetOtherVId(Vrtx1)){return true;}
1416    }
1417    if (!DirP){
1418      for (int EIdN=0; EIdN&lt;Vrtx2-&gt;GetOutEIds(); EIdN++){
1419        Edge=GetEdge(Vrtx2-&gt;GetOutEId(EIdN));
1420        if (VId1==Edge-&gt;GetOtherVId(Vrtx2)){return true;}
1421      }
1422    }
1423    return false;
1424  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;graph.h&quot;
3  TStr TVrtx::VIdNm=&quot;VId&quot;;
4  TStr TVrtx::PpNm=&quot;Pp&quot;;
5  TStr TVrtx::VNmNm=&quot;VNm&quot;;
6  TStr TVrtx::DNmNm=&quot;DNm&quot;;
7  TStr TVrtx::BriefNm=&quot;Brief&quot;;
8  TStr TVrtx::MarkNm=&quot;Mark&quot;;
9  TStr TVrtx::WgtNm=&quot;Wgt&quot;;
10  TStr TVrtx::HitsHubWNm=&quot;HitsHubW&quot;;
11  TStr TVrtx::HitsAuthWNm=&quot;HitsAuthW&quot;;
12  TStr TVrtx::PageRankWNm=&quot;PageRankW&quot;;
13  TStr TVrtx::XNm=&quot;X&quot;;
14  TStr TVrtx::YNm=&quot;Y&quot;;
15  TStr TVrtx::ZNm=&quot;Z&quot;;
16  TStr TVrtx::ColorNm=&quot;Color&quot;;
17  TStr TVrtx::ShapeNm=&quot;Shape&quot;;
18  TStr TVrtx::RectNm=&quot;Rect&quot;;
19  TStr TVrtx::RectX1Nm=&quot;Rect|X1&quot;; TStr TVrtx::X1Nm=&quot;X1&quot;;
20  TStr TVrtx::RectY1Nm=&quot;Rect|Y1&quot;; TStr TVrtx::Y1Nm=&quot;Y1&quot;;
21  TStr TVrtx::RectX2Nm=&quot;Rect|X2&quot;; TStr TVrtx::X2Nm=&quot;X2&quot;;
22  TStr TVrtx::RectY2Nm=&quot;Rect|Y2&quot;; TStr TVrtx::Y2Nm=&quot;Y2&quot;;
23  TStr TVrtx::DmNm=&quot;Dm&quot;;
24  void TVrtx::PutRect(const TGksRect&amp; Rect){
25    GetPp()-&gt;PutValInt(RectX1Nm, Rect.GetX1());
26    GetPp()-&gt;PutValInt(RectY1Nm, Rect.GetY1());
27    GetPp()-&gt;PutValInt(RectX2Nm, Rect.GetX2());
28    GetPp()-&gt;PutValInt(RectY2Nm, Rect.GetY2());
29  }
30  TGksRect TVrtx::GetRect() const {
31    int X1=GetPp()-&gt;GetValInt(RectX1Nm);
32    int Y1=GetPp()-&gt;GetValInt(RectY1Nm);
33    int X2=GetPp()-&gt;GetValInt(RectX2Nm);
34    int Y2=GetPp()-&gt;GetValInt(RectY2Nm);
35    return TGksRect(X1, Y1, X2, Y2);
36  }
37  bool TVrtx::IsInRect(const double&amp; X, const double&amp; Y) const {
38    TGksRect Rect=TVrtx::GetRect();
39    return Rect.IsIn(int(X), int(Y));
40  }
41  PPp TVrtx::GetDrawPp(){
42    PPp Pp=TPp::GetSetPp(&quot;Draw&quot;);
43    Pp-&gt;AddPpStr(DNmNm, &quot;&quot;, &quot;&quot;);
44    Pp-&gt;AddPpFlt(XNm, &quot;&quot;, TFlt::Mn, TFlt::Mx, 0);
45    Pp-&gt;AddPpFlt(YNm, &quot;&quot;, TFlt::Mn, TFlt::Mx, 0);
46    Pp-&gt;AddPpInt(BriefNm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
47    Pp-&gt;AddPpStr(ShapeNm, &quot;&quot;, &quot;&quot;);
48    PPp RectPp=TPp::GetSetPp(RectNm);
49    RectPp-&gt;AddPpInt(X1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
50    RectPp-&gt;AddPpInt(Y1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
51    RectPp-&gt;AddPpInt(X2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
52    RectPp-&gt;AddPpInt(Y2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
53    Pp-&gt;AddPp(RectPp);
54    return Pp;
55  }
56  PVrtx TVrtx::LoadXml(const PXmlTok&amp; XmlTok){
57    int VId=XmlTok-&gt;GetIntArgVal(VIdNm);
58    TStr VNm=XmlTok-&gt;GetStrArgVal(VNmNm, &quot;&quot;);
59    int Mark=XmlTok-&gt;GetIntArgVal(MarkNm, 0);
60    double Wgt=XmlTok-&gt;GetFltArgVal(WgtNm, 0);
61    double HitsHubW=XmlTok-&gt;GetFltArgVal(HitsHubWNm, 0);
62    double HitsAuthW=XmlTok-&gt;GetFltArgVal(HitsAuthWNm, 0);
63    double PageRankW=XmlTok-&gt;GetFltArgVal(PageRankWNm, 0);
64    double X=XmlTok-&gt;GetFltArgVal(XNm, 0);
65    double Y=XmlTok-&gt;GetFltArgVal(YNm, 0);
66    double Z=XmlTok-&gt;GetFltArgVal(ZNm, 0);
67    PPp Pp;
68    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
69    Vrtx-&gt;PutMark(Mark); Vrtx-&gt;PutWgt(Wgt);
70    Vrtx-&gt;PutHitsHubW(HitsHubW); Vrtx-&gt;PutHitsAuthW(HitsAuthW);
71    Vrtx-&gt;PutPageRankW(PageRankW);
72    Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y); Vrtx-&gt;PutZ(Z);
73    return Vrtx;
74  }
75  PXmlTok TVrtx::GetXmlTok() const {
76    PXmlTok VrtxTok=TXmlTok::New(TGraph::VrtxNm);
77    VrtxTok-&gt;AddArg(VIdNm, GetVId());
78    if (!GetVNm().Empty()){VrtxTok-&gt;AddArg(VNmNm, GetVNm());}
79    if (GetMark()!=0){VrtxTok-&gt;AddArg(MarkNm, GetMark());}
80    if (GetWgt()!=0){VrtxTok-&gt;AddArg(WgtNm, GetWgt());}
81    if (GetHitsHubW()!=0){VrtxTok-&gt;AddArg(HitsHubWNm, GetHitsHubW());}
82    if (GetHitsAuthW()!=0){VrtxTok-&gt;AddArg(HitsAuthWNm, GetHitsAuthW());}
83    if (GetPageRankW()!=0){VrtxTok-&gt;AddArg(PageRankWNm, GetPageRankW());}
84    if (GetX()!=0){VrtxTok-&gt;AddArg(XNm, GetX());}
85    if (GetY()!=0){VrtxTok-&gt;AddArg(YNm, GetY());}
86    if (GetZ()!=0){VrtxTok-&gt;AddArg(ZNm, GetZ());}
87    return VrtxTok;
88  }
89  PVrtx TVrtx::LoadTxt(TILx&amp; Lx){
90    Lx.GetSym(syLBracket);
91    int VId=Lx.GetVarInt(VIdNm, false);
92    TStr VNm; int Mark=0; double Wgt=0;
93    double HitsHubW=0; double HitsAuthW=0; double PageRankW=0;
94    double X=0; double Y=0; double Z=0; PPp Pp;
95    if (Lx.IsVar(VNmNm)){VNm=Lx.GetVarStr(VNmNm, false);}
96    VNm=TXmlLx::GetPlainStrFromXmlStr(VNm);
97    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
98    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
99    if (Lx.IsVar(HitsHubWNm)){HitsHubW=Lx.GetVarFlt(HitsHubWNm, false);}
100    if (Lx.IsVar(HitsAuthWNm)){HitsAuthW=Lx.GetVarFlt(HitsAuthWNm, false);}
101    if (Lx.IsVar(PageRankWNm)){PageRankW=Lx.GetVarFlt(PageRankWNm, false);}
102    if (Lx.IsVar(XNm)){X=Lx.GetVarFlt(XNm, false);}
103    if (Lx.IsVar(YNm)){Y=Lx.GetVarFlt(YNm, false);}
104    if (Lx.IsVar(ZNm)){Z=Lx.GetVarFlt(ZNm, false);}
105    if (Lx.IsVar(PpNm)){
106      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
107    PVrtx Vrtx=PVrtx(new TGVrtx(VId, VNm, Pp));
108    Vrtx-&gt;PutMark(Mark); Vrtx-&gt;PutWgt(Wgt);
109    Vrtx-&gt;PutHitsHubW(HitsHubW); Vrtx-&gt;PutHitsAuthW(HitsAuthW);
110    Vrtx-&gt;PutPageRankW(PageRankW);
111    Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y); Vrtx-&gt;PutZ(Z);
112    Lx.GetSym(syRBracket);
113    return Vrtx;
114  }
115  void TVrtx::SaveTxt(TOLx&amp; Lx) const {
116    Lx.PutSym(syLBracket);
117    Lx.PutVarInt(VIdNm, GetVId(), false);
118    TStr XmlVNm=TXmlLx::GetXmlStrFromPlainStr(GetVNm());
119    if (!GetVNm().Empty()){Lx.PutVarStr(VNmNm, XmlVNm, false);}
120    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
121    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
122    if (GetHitsHubW()!=0){Lx.PutVarFlt(HitsHubWNm, GetHitsHubW(), false);}
123    if (GetHitsAuthW()!=0){Lx.PutVarFlt(HitsAuthWNm, GetHitsAuthW(), false);}
124    if (GetPageRankW()!=0){Lx.PutVarFlt(PageRankWNm, GetPageRankW(), false);}
125    if (GetX()!=0){Lx.PutVarFlt(XNm, GetX(), false);}
126    if (GetY()!=0){Lx.PutVarFlt(YNm, GetY(), false);}
127    if (GetZ()!=0){Lx.PutVarFlt(ZNm, GetZ(), false);}
128    if (!GetPp().Empty()){
129      Lx.PutIdStr(PpNm); Lx.PutSym(syColon); GetPp()-&gt;SaveTxt(Lx);}
130    Lx.PutSym(syRBracket);
131  }
132  void TGVrtx::DefVrtx(const PGraph&amp; Graph){
133    if (VId==-1){VId=Graph-&gt;GetNewVId();}
134    Graph-&gt;DefVId(VId);
135  }
136  TStr TEdge::EIdNm=&quot;EId&quot;;
137  TStr TEdge::VId1Nm=&quot;VId1&quot;;
138  TStr TEdge::VId2Nm=&quot;VId2&quot;;
139  TStr TEdge::PpNm=&quot;Pp&quot;;
140  TStr TEdge::DirPNm=&quot;Dir&quot;;
141  TStr TEdge::ENmNm=&quot;ENm&quot;;
142  TStr TEdge::MarkNm=&quot;Mark&quot;;
143  TStr TEdge::WgtNm=&quot;Wgt&quot;;
144  TStr TEdge::WidthNm=&quot;Width&quot;;
145  TStr TEdge::DNmNm=&quot;DNm&quot;;
146  TStr TEdge::BriefNm=&quot;Brief&quot;;
147  TStr TEdge::RectNm=&quot;Rect&quot;;
148  TStr TEdge::RectX1Nm=&quot;Rect|X1&quot;; TStr TEdge::X1Nm=&quot;X1&quot;;
149  TStr TEdge::RectY1Nm=&quot;Rect|Y1&quot;; TStr TEdge::Y1Nm=&quot;Y1&quot;;
150  TStr TEdge::RectX2Nm=&quot;Rect|X2&quot;; TStr TEdge::X2Nm=&quot;X2&quot;;
151  TStr TEdge::RectY2Nm=&quot;Rect|Y2&quot;; TStr TEdge::Y2Nm=&quot;Y2&quot;;
152  TStr TEdge::DmNm=&quot;Dm&quot;;
153  void TEdge::PutRect(const TGksRect&amp; Rect){
154    GetPp()-&gt;PutValInt(RectX1Nm, Rect.GetX1());
155    GetPp()-&gt;PutValInt(RectY1Nm, Rect.GetY1());
156    GetPp()-&gt;PutValInt(RectX2Nm, Rect.GetX2());
157    GetPp()-&gt;PutValInt(RectY2Nm, Rect.GetY2());
158  }
159  TGksRect TEdge::GetRect() const {
160    int X1=GetPp()-&gt;GetValInt(RectX1Nm);
161    int Y1=GetPp()-&gt;GetValInt(RectY1Nm);
162    int X2=GetPp()-&gt;GetValInt(RectX2Nm);
163    int Y2=GetPp()-&gt;GetValInt(RectY2Nm);
164    return TGksRect(X1, Y1, X2, Y2);
165  }
166  bool TEdge::IsInRect(const double&amp; X, const double&amp; Y) const {
167    TGksRect Rect=TEdge::GetRect();
168    return Rect.IsIn(int(X), int(Y));
169  }
170  PPp TEdge::GetDrawPp(){
171    PPp Pp=TPp::GetSetPp(&quot;Draw&quot;);
172    Pp-&gt;AddPpStr(DNmNm, &quot;&quot;, &quot;&quot;);
173    Pp-&gt;AddPpInt(BriefNm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
174    PPp RectPp=TPp::GetSetPp(RectNm);
175    RectPp-&gt;AddPpInt(X1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
176    RectPp-&gt;AddPpInt(Y1Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
177    RectPp-&gt;AddPpInt(X2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
178    RectPp-&gt;AddPpInt(Y2Nm, &quot;&quot;, TInt::Mn, TInt::Mx, 0);
179    Pp-&gt;AddPp(RectPp);
180    return Pp;
181  }
182  PEdge TEdge::LoadXml(const PXmlTok&amp; XmlTok){
183    int EId=XmlTok-&gt;GetIntArgVal(EIdNm);
184    int VId1=XmlTok-&gt;GetIntArgVal(VId1Nm);
185    int VId2=XmlTok-&gt;GetIntArgVal(VId2Nm);
186    bool DirP=XmlTok-&gt;GetBoolArgVal(DirPNm, true);
187    TStr ENm=XmlTok-&gt;GetStrArgVal(ENmNm, &quot;&quot;);
188    int Mark=XmlTok-&gt;GetIntArgVal(MarkNm, 0);
189    double Wgt=XmlTok-&gt;GetFltArgVal(WgtNm, 0);
190    int Width=int(XmlTok-&gt;GetFltArgVal(WidthNm, 0));
191    PPp Pp;
192    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
193    Edge-&gt;PutMark(Mark);
194    Edge-&gt;PutWgt(Wgt);
195    Edge-&gt;PutWidth(Width);
196    return Edge;
197  }
198  PXmlTok TEdge::GetXmlTok() const {
199    PXmlTok EdgeTok=TXmlTok::New(TGraph::EdgeNm);
200    EdgeTok-&gt;AddArg(EIdNm, GetEId());
201    EdgeTok-&gt;AddArg(VId1Nm, GetVId1());
202    EdgeTok-&gt;AddArg(VId2Nm, GetVId2());
203    if (!IsDir()){EdgeTok-&gt;AddArg(DirPNm, IsDir());}
204    if (!GetENm().Empty()){EdgeTok-&gt;AddArg(ENmNm, GetENm());}
205    if (GetMark()!=0){EdgeTok-&gt;AddArg(MarkNm, GetMark());}
206    if (GetWgt()!=0){EdgeTok-&gt;AddArg(WgtNm, GetWgt());}
207    if (GetWidth()!=0){EdgeTok-&gt;AddArg(WidthNm, GetWidth());}
208    return EdgeTok;
209  }
210  PEdge TEdge::LoadTxt(TILx&amp; Lx){
211    Lx.GetSym(syLBracket);
212    int EId=Lx.GetVarInt(EIdNm, false);
213    int VId1=Lx.GetVarInt(VId1Nm, false);
214    int VId2=Lx.GetVarInt(VId2Nm, false);
215    bool DirP=true; TStr ENm; int Mark=0; double Wgt=0; int Width=0; PPp Pp;
216    if (Lx.IsVar(DirPNm)){DirP=Lx.GetVarBool(DirPNm, false);}
217    if (Lx.IsVar(ENmNm)){ENm=Lx.GetVarStr(ENmNm, false);}
218    ENm=TXmlLx::GetPlainStrFromXmlStr(ENm);
219    if (Lx.IsVar(MarkNm)){Mark=Lx.GetVarInt(MarkNm, false);}
220    if (Lx.IsVar(WgtNm)){Wgt=Lx.GetVarFlt(WgtNm, false);}
221    if (Lx.IsVar(WidthNm)){Width=Lx.GetVarInt(WidthNm, false);}
222    if (Lx.IsVar(PpNm)){
223      Lx.GetIdStr(PpNm); Lx.GetSym(syColon); Pp=TPp::LoadTxt(Lx);}
224    PEdge Edge=PEdge(new TGEdge(EId, VId1, VId2, DirP, ENm, Pp));
225    Edge-&gt;PutMark(Mark); Edge-&gt;PutWgt(Wgt); Edge-&gt;PutWidth(Width);
226    Lx.GetSym(syRBracket);
227    return Edge;
228  }
229  void TEdge::SaveTxt(TOLx&amp; Lx) const {
230    Lx.PutSym(syLBracket);
231    Lx.PutVarInt(EIdNm, GetEId(), false);
232    Lx.PutVarInt(VId1Nm, GetVId1(), false);
233    Lx.PutVarInt(VId2Nm, GetVId2(), false);
234    if (!IsDir()){Lx.PutVarBool(DirPNm, IsDir(), false);}
235    TStr XmlENm=TXmlLx::GetXmlStrFromPlainStr(GetENm());
236    if (!GetENm().Empty()){Lx.PutVarStr(ENmNm, XmlENm(), false);}
237    if (GetMark()!=0){Lx.PutVarInt(MarkNm, GetMark(), false);}
238    if (GetWgt()!=0){Lx.PutVarFlt(WgtNm, GetWgt(), false);}
239    if (GetWidth()!=0){Lx.PutVarInt(WidthNm, GetWidth(), false);}
240    if (!GetPp().Empty()){GetPp()-&gt;SaveTxt(Lx);}
241    Lx.PutSym(syRBracket);
242  }
243  TGEdge::TGEdge(const int&amp; _EId, const int&amp; _VId1, const int&amp; _VId2,
244   const bool&amp; _DirP, const TStr&amp; _ENm, const PPp&amp; _Pp):
245    TEdge(), EId(_EId), VId1(_VId1), VId2(_VId2),
246    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
247  }
248  TGEdge::TGEdge(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2,
249   const TStr&amp; _ENm, const bool&amp; _DirP, const PPp&amp; _Pp):
250    TEdge(), EId(-1), VId1(Vrtx1-&gt;GetVId()), VId2(Vrtx2-&gt;GetVId()),
251    DirP(_DirP), ENm(_ENm), DNm(TStr()), Mark(0), Wgt(0), Width(0), Pp(_Pp){
252  }
253  void TGEdge::DefEdge(const PGraph&amp; Graph){
254    if (EId==-1){EId=Graph-&gt;GetNewEId();}
255    Graph-&gt;DefEId(EId);
256  }
257  TStr TGraph::PpNm=&quot;Pp&quot;;
258  TStr TGraph::VrtxNm=&quot;Vrtx&quot;;
259  TStr TGraph::EdgeNm=&quot;Edge&quot;;
260  TStr TGraph::GNmNm=&quot;GNm&quot;;
261  TStr TGraph::DNmNm=&quot;DNm&quot;;
262  TStr TGraph::BriefNm=&quot;Brief&quot;;
263  const TStr TGraph::FExt=&quot;.Graph&quot;;
264  const TStr TGraph::HitsFExt=&quot;.Hits&quot;;
265  const TStr TGraph::PageRankFExt=&quot;.PageRank&quot;;
266  THash&lt;TStr, TGraph::TGraphNewF&gt; TGraph::TypeToNewFH(10);
267  THash&lt;TStr, TGraph::TGraphLoadF&gt; TGraph::TypeToLoadFH(10);
268  PGraph TGraph::New(const TStr&amp; TypeNm){
269    TStr FinalTypeNm=TypeNm;
270    if (TypeNm.Empty()){FinalTypeNm=TTypeNm&lt;TGGraph&gt;();}
271    TGraphNewF NewF=TypeToNewFH.GetDat(FinalTypeNm);
272    return (*NewF())();
273  }
274  PGraph TGraph::Load(TSIn&amp; SIn){
275    TStr TypeNm(SIn);
276    TGraphLoadF LoadF=TypeToLoadFH.GetDat(TypeNm);
277    return (*LoadF())(SIn);
278  }
279  bool TGraph::Reg(
280   const TStr&amp; TypeNm, const TGraphNewF&amp; NewF, const TGraphLoadF&amp; LoadF){
281    IAssert(!TypeToNewFH.IsKey(TypeNm));
282    IAssert(!TypeToLoadFH.IsKey(TypeNm));
283    TypeToNewFH.AddDat(TypeNm, NewF);
284    TypeToLoadFH.AddDat(TypeNm, LoadF);
285    return true;
286  }
287  void TGraph::_GetMnMxXY(
288   double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const {
289    MnX=0; MxX=0; MnY=0; MxY=0;
290    int VrtxP=FFirstVrtx(); PVrtx Vrtx; bool First=true;
291    while (FNextVrtx(VrtxP, Vrtx)){
292      if (First){
293        MnX=Vrtx-&gt;GetX(); MxX=Vrtx-&gt;GetX();
294        MnY=Vrtx-&gt;GetY(); MxY=Vrtx-&gt;GetY();
295        First=false;
296      } else {
297        if (Vrtx-&gt;GetX()&lt;MnX){MnX=Vrtx-&gt;GetX();}
298        if (Vrtx-&gt;GetX()&gt;MxX){MxX=Vrtx-&gt;GetX();}
299        if (Vrtx-&gt;GetY()&lt;MnY){MnY=Vrtx-&gt;GetY();}
300        if (Vrtx-&gt;GetY()&gt;MxY){MxY=Vrtx-&gt;GetY();}
301      }
302    }
303  }
304  void TGraph::_AddBorders(const double&amp; BorderFac,
305   double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const {
306    if (MxX-MnX==0){MnX-=BorderFac; MxX+=BorderFac;}
307    else {MnX-=(MxX-MnX)*BorderFac; MxX+=(MxX-MnX)*BorderFac;}
308    if (MxY-MnY==0){MnY-=BorderFac; MxY+=BorderFac;}
309    else {MnY-=(MxY-MnY)*BorderFac; MxY+=(MxY-MnY)*BorderFac;}
310  }
311  void TGraph::RescaleXY(const double&amp; BorderFac, const PVrtx&amp; CenterVrtx) const {
312    double MnX; double MnY; double MxX; double MxY;
313    _GetMnMxXY(MnX, MnY, MxX, MxY);
314    if (!CenterVrtx.Empty()){
315      double CenterX=CenterVrtx-&gt;GetX();
316      double CenterY=CenterVrtx-&gt;GetY();
317      if (MxX-CenterX&gt;CenterX-MnX){MnX=CenterX-(MxX-CenterX);}
318      else {MxX=CenterX+(CenterX-MnX);}
319      if (MxY-CenterY&gt;CenterY-MnY){MnY=CenterY-(MxY-CenterY);}
320      else {MxY=CenterY+(CenterY-MnY);}
321    }
322    _AddBorders(BorderFac, MnX, MnY, MxX, MxY);
323    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
324    while (FNextVrtx(VrtxP, Vrtx)){
325      Vrtx-&gt;PutX((Vrtx-&gt;GetX()-MnX)/(MxX-MnX));
326      Vrtx-&gt;PutY((Vrtx-&gt;GetY()-MnY)/(MxY-MnY));
327    }
328  }
329  void TGraph::RescaleXY(const double&amp; MnX, const double&amp; MnY,
330   const double&amp; MxX, const double&amp; MxY) const {
331    if ((fabs(MxX-MnX)&lt;0.01)||(fabs(MxY-MnY)&lt;0.01)){return;}
332    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
333    while (FNextVrtx(VrtxP, Vrtx)){
334      Vrtx-&gt;PutX((Vrtx-&gt;GetX()-MnX)/(MxX-MnX));
335      Vrtx-&gt;PutY((Vrtx-&gt;GetY()-MnY)/(MxY-MnY));
336    }
337  }
338  int TGraph::_IsEdgeXYInts(
339   const PVrtx&amp; Vrtx0, const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const {
340    double dx1=Vrtx1-&gt;GetX()-Vrtx0-&gt;GetX();
341    double dy1=Vrtx1-&gt;GetY()-Vrtx0-&gt;GetY();
342    double dx2=Vrtx2-&gt;GetX()-Vrtx0-&gt;GetX();
343    double dy2=Vrtx2-&gt;GetY()-Vrtx0-&gt;GetY();
344    if (dx1*dy2&gt;dy1*dx2){return +1;}
345    if (dx1*dy2&lt;dy1*dx2){return -1;}
346    if ((dx1*dx2&lt;0)||(dy1*dy2&lt;0)){return -1;}
347    if ((dx1*dx1+dy1*dy1)&lt;(dx2*dx2+dy2*dy2)){return +1;}
348    return 0;
349  }
350  bool TGraph::IsEdgeXYInts(const PEdge&amp; Edge1, const PEdge&amp; Edge2) const {
351    PVrtx V11=GetVrtx(Edge1-&gt;GetVId1());
352    PVrtx V12=GetVrtx(Edge1-&gt;GetVId2());
353    PVrtx V21=GetVrtx(Edge2-&gt;GetVId1());
354    PVrtx V22=GetVrtx(Edge2-&gt;GetVId2());
355    return
356     ((_IsEdgeXYInts(V11, V12, V21)*_IsEdgeXYInts(V11, V12, V22))&lt;=0)&amp;&amp;
357     ((_IsEdgeXYInts(V21, V22, V11)*_IsEdgeXYInts(V21, V22, V12))&lt;=0);
358  }
359  double TGraph::GetVrtxXYLen(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const {
360    double Len=
361     TMath::Sqr(Vrtx2-&gt;GetX()-Vrtx1-&gt;GetX())+
362     TMath::Sqr(Vrtx2-&gt;GetY()-Vrtx1-&gt;GetY());
363    Len=sqrt(Len);
364    return Len;
365  }
366  double TGraph::GetEdgeXYLen(const PEdge&amp; Edge) const {
367    PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
368    PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
369    return GetVrtxXYLen(Vrtx1, Vrtx2);
370  }
371  double TGraph::GetSumEdgeXYLen() const {
372    double SumLen=0;
373    int EdgeP=FFirstEdge(); PEdge Edge;
374    while (FNextEdge(EdgeP, Edge)){
375      SumLen+=GetEdgeXYLen(Edge);
376    }
377    return SumLen;
378  }
379  void TGraph::PlaceRndXY(TRnd&amp; Rnd) const {
380    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
381    while (FNextVrtx(VrtxP, Vrtx)){
382      Vrtx-&gt;PutX(Rnd.GetUniDev());
383      Vrtx-&gt;PutY(Rnd.GetUniDev());
384    }
385  }
386  void TGraph::PlaceBestRndXY(const int&amp; Tries, TRnd&amp; Rnd) const {
387    int BestSeed; double BestLen=-1;
388    for (int TryN=0; TryN&lt;Tries; TryN++){
389      int CurSeed=Rnd.GetSeed();
390      PlaceRndXY(Rnd);
391      double CurLen=GetSumEdgeXYLen();
392      if (TryN==0){
393        BestSeed=CurSeed; BestLen=CurLen;
394      } else
395      if (CurLen&lt;BestLen){
396        BestSeed=CurSeed; BestLen=CurLen;
397      }
398    }
399    Rnd.PutSeed(BestSeed);
400    PlaceRndXY(Rnd);
401  }
402  double TGraph::GetSimAnnXYEnergy(
403   const double&amp; NodeDistrWgt, const double&amp; BorderWgt,
404   const double&amp; EdgeLenWgt, const double&amp; EdgeCrossWgt,
405   const double&amp; NodeEdgeDistWgt, const bool&amp; UseNodeEdgeDist) const {
406    double Energy=0;
407    if (NodeDistrWgt!=0){
408      int Vrtx1P=FFirstVrtx(); PVrtx Vrtx1;
409      while (FNextVrtx(Vrtx1P, Vrtx1)){
410        int Vrtx2P=FFirstVrtx(); PVrtx Vrtx2;
411        while (FNextVrtx(Vrtx2P, Vrtx2)){
412          double EuclDist=
413           sqrt(TMath::Sqr(Vrtx1-&gt;GetX()-Vrtx2-&gt;GetX())+
414           TMath::Sqr(Vrtx1-&gt;GetY()-Vrtx2-&gt;GetY()));
415          if (EuclDist&gt;0){
416            Energy+=NodeDistrWgt/TMath::Sqr(EuclDist);}
417        }
418      }
419    }
420    if (BorderWgt!=0){
421      double Vrtxs=GetVrtxs();
422      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
423      while (FNextVrtx(VrtxP, Vrtx)){
424        double Right=1-Vrtx-&gt;GetX();
425        double Left=Vrtx-&gt;GetX();
426        double Top=Vrtx-&gt;GetY();
427        double Bottom=1-Vrtx-&gt;GetY();
428        if (Right&gt;0){Energy+=BorderWgt*TMath::Sqr(Right)*TMath::Sqr(Vrtxs);}
429        if (Left&gt;0){Energy+=BorderWgt*TMath::Sqr(Left)*TMath::Sqr(Vrtxs);}
430        if (Top&gt;0){Energy+=BorderWgt*TMath::Sqr(Top)*TMath::Sqr(Vrtxs);}
431        if (Bottom&gt;0){Energy+=BorderWgt*TMath::Sqr(Bottom)*TMath::Sqr(Vrtxs);}
432      }
433    }
434    if (EdgeLenWgt!=0){
435      double Vrtxs=GetVrtxs();
436      int EdgeP=FFirstEdge(); PEdge Edge;
437      while (FNextEdge(EdgeP, Edge)){
438        Energy+=EdgeLenWgt*TMath::Sqr(GetEdgeXYLen(Edge))*TMath::Sqr(Vrtxs);
439      }
440    }
441    if (EdgeCrossWgt!=0){
442      int Edge1P=FFirstEdge(); PEdge Edge1;
443      while (FNextEdge(Edge1P, Edge1)){
444        int Edge2P=Edge1P; PEdge Edge2;
445        while (FNextEdge(Edge2P, Edge2)){
446          if (&amp;Edge1!=&amp;Edge2){
447            if
448             ((Edge1-&gt;GetVId1()!=Edge2-&gt;GetVId1())&amp;&amp;
449             (Edge1-&gt;GetVId1()!=Edge2-&gt;GetVId2())&amp;&amp;
450             (Edge1-&gt;GetVId2()!=Edge2-&gt;GetVId1())&amp;&amp;
451             (Edge1-&gt;GetVId2()!=Edge2-&gt;GetVId2())){
452              if (IsEdgeXYInts(Edge1, Edge2)){
453                Energy+=EdgeCrossWgt;
454              }
455            }
456          }
457        }
458      }
459    }
460    if ((UseNodeEdgeDist)&amp;&amp;(NodeEdgeDistWgt!=0)){
461      int EdgeP=FFirstEdge(); PEdge Edge;
462      while (FNextEdge(EdgeP, Edge)){
463        double EdgeLen=GetEdgeXYLen(Edge);
464        PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
465        PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
466        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
467        while (FNextVrtx(VrtxP, Vrtx)){
468          if ((&amp;Vrtx!=&amp;Vrtx1)&amp;&amp;(&amp;Vrtx!=&amp;Vrtx2)){
469            double VrtxLen=GetVrtxXYLen(Vrtx, Vrtx1)+GetVrtxXYLen(Vrtx, Vrtx2);
470            if (EdgeLen!=VrtxLen){
471              Energy+=(NodeEdgeDistWgt/fabs(EdgeLen-VrtxLen));
472            }
473          }
474        }
475      }
476    }
477    return Energy;
478  }
479  double TGraph::GetSimAnnXYEnergy(
480   const PXmlDoc&amp; CfgXmlDoc, const bool&amp; UseNodeEdgeDist) const {
481    double NodeDistrWgt=10; 
482    double BorderWgt=20; 
483    double EdgeLenWgt=10; 
484    double EdgeCrossWgt=1000; 
485    double NodeEdgeDistWgt=10; 
486    if (!CfgXmlDoc.Empty()){
487      NodeDistrWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeDistrWgt&quot;, &quot;Val&quot;, NodeDistrWgt);
488      BorderWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|BorderWgt&quot;, &quot;Val&quot;, BorderWgt);
489      EdgeLenWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeLenWgt&quot;, &quot;Val&quot;, EdgeLenWgt);
490      EdgeCrossWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeCrossWgt&quot;, &quot;Val&quot;, EdgeCrossWgt);
491      NodeEdgeDistWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeEdgeDistWgt&quot;, &quot;Val&quot;, NodeEdgeDistWgt);
492    }
493    return GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt, EdgeCrossWgt,
494     NodeEdgeDistWgt, UseNodeEdgeDist);
495  }
496  void TGraph::PlaceSimAnnXY(
497   TRnd&amp; Rnd, const PGks&amp; Gks, const PXmlDoc&amp; CfgXmlDoc, const PNotify&amp; Notify,
498   const int&amp; _TempStages, const int&amp; _TempStageTrys, const int&amp; Secs) const {
499    int Trys=1; 
500    double StartTemp=1000; 
501    double TempFact=0.95; 
502    int TempStages=_TempStages; 
503    int TempStageTrys=_TempStageTrys; 
504    int FineTuningTrys=3000; 
505    if (!CfgXmlDoc.Empty()){
506      Trys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|Trys&quot;, &quot;Val&quot;, Trys);
507      StartTemp=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|StartTemp&quot;, &quot;Val&quot;, StartTemp);
508      TempFact=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|TempFact&quot;, &quot;Val&quot;, TempFact);
509      TempStages=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|TempStages&quot;, &quot;Val&quot;, TempStages);
510      TempStageTrys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|TempStageTrys&quot;, &quot;Val&quot;, TempStageTrys);
511      FineTuningTrys=CfgXmlDoc-&gt;GetTagTokIntArgVal(&quot;Config|FineTuningTrys&quot;, &quot;Val&quot;, FineTuningTrys);
512    }
513    double NodeDistrWgt=10; 
514    double BorderWgt=25; 
515    double EdgeLenWgt=10; 
516    double EdgeCrossWgt=1000; 
517    double NodeEdgeDistWgt=10; 
518    if (!CfgXmlDoc.Empty()){
519      NodeDistrWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeDistrWgt&quot;, &quot;Val&quot;, NodeDistrWgt);
520      BorderWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|BorderWgt&quot;, &quot;Val&quot;, BorderWgt);
521      EdgeLenWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeLenWgt&quot;, &quot;Val&quot;, EdgeLenWgt);
522      EdgeCrossWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|EdgeCrossWgt&quot;, &quot;Val&quot;, EdgeCrossWgt);
523      NodeEdgeDistWgt=CfgXmlDoc-&gt;GetTagTokFltArgVal(&quot;Config|NodeEdgeDistWgt&quot;, &quot;Val&quot;, NodeEdgeDistWgt);
524    }
525    TSecTm StartTm=TSecTm::GetCurTm();
526    double MnEnergy=TFlt::Mx; 
527    typedef TPair&lt;PVrtx, TFltPr&gt; TVrtxXYPrPr;
528    TVec&lt;TVrtxXYPrPr&gt; VrtxXYPrPrV;
529    for (int TryN=0; TryN&lt;Trys; TryN++){
530      PlaceRndXY(Rnd); 
531      double Energy=TFlt::Mx; 
532      double Temp=StartTemp; 
533      double PrevEnergy=TFlt::Mx; 
534      for (int TempStageN=0; TempStageN&lt;TempStages; TempStageN++){
535        TNotify::OnStatus(Notify,
536         TInt::GetStr(1+TempStageN)+&quot;/&quot;+TInt::GetStr(TempStages)+&quot;\r&quot;);
537        for (int TempStageTryN=0; TempStageTryN&lt;TempStageTrys; TempStageTryN++){
538          PVrtx Vrtx=GetRndVrtx(Rnd); 
539          double PrevX=Vrtx-&gt;GetX();
540          double PrevY=Vrtx-&gt;GetY();
541          double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), Temp/StartTemp, 0, 1);
542          double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), Temp/StartTemp, 0, 1);
543          NewX=TFlt::GetInRng(NewX, 0, 1);
544          NewY=TFlt::GetInRng(NewY, 0, 1);
545          Vrtx-&gt;PutX(NewX);
546          Vrtx-&gt;PutY(NewY);
547          Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
548           EdgeCrossWgt, NodeEdgeDistWgt, false);
549          if (Energy&lt;PrevEnergy){
550            PrevEnergy=Energy;  
551          } else {
552            double MetrPrb=exp((PrevEnergy-Energy)/Temp);
553            double MetrRnd=Rnd.GetUniDev();
554            if (MetrRnd&gt;=MetrPrb){
555              Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
556            } else {
557              PrevEnergy=Energy; 
558            }
559          }
560        }
561        Temp*=TempFact; 
562        if (!Gks.Empty()){
563          Gks-&gt;Clr();
564          Draw(Gks, true);
565        }
566      }
567      if (Energy&lt;MnEnergy){
568        MnEnergy=Energy;
569        VrtxXYPrPrV.Gen(GetVrtxs(), 0);
570        int VrtxP=FFirstVrtx(); PVrtx Vrtx;
571        while (FNextVrtx(VrtxP, Vrtx)){
572          TFltPr XYPr(Vrtx-&gt;GetX(), Vrtx-&gt;GetY()); 
573          TVrtxXYPrPr VrtxXYPrPr(Vrtx, XYPr); 
574          VrtxXYPrPrV.Add(VrtxXYPrPr);
575        }
576      }
577      TSecTm CurTm=TSecTm::GetCurTm();
578      if (Secs!=-1){
579        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
580      }
581    }
582    for (int VrtxXYPrPrN=0; VrtxXYPrPrN&lt;VrtxXYPrPrV.Len(); VrtxXYPrPrN++){
583      PVrtx Vrtx=VrtxXYPrPrV[VrtxXYPrPrN].Val1;
584      TFltPr XYPr=VrtxXYPrPrV[VrtxXYPrPrN].Val2;
585      double X=XYPr.Val1; double Y=XYPr.Val2;
586      Vrtx-&gt;PutX(X); Vrtx-&gt;PutY(Y);
587    }
588    double PrevEnergy=TFlt::Mx; 
589    for (int FineTuningTryN=0; FineTuningTryN&lt;FineTuningTrys; FineTuningTryN++){
590      PVrtx Vrtx=GetRndVrtx(Rnd); 
591      double PrevX=Vrtx-&gt;GetX();
592      double PrevY=Vrtx-&gt;GetY();
593      double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), 0.001, 0, 1);
594      double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), 0.001, 0, 1);
595      Vrtx-&gt;PutX(NewX);
596      Vrtx-&gt;PutY(NewY);
597      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
598       EdgeCrossWgt, NodeEdgeDistWgt, true);
599      if (Energy&lt;PrevEnergy){
600        PrevEnergy=Energy;  
601      } else {
602        Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
603      }
604      if (FineTuningTryN%100==0){Draw(Gks, true);}
605      TSecTm CurTm=TSecTm::GetCurTm();
606      if (Secs!=-1){
607        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
608      }
609    }
610  }
611  void TGraph::PlaceFineTuning(
612   TRnd&amp; Rnd, const PGks&amp; Gks, const PNotify&amp; Notify, const int&amp; Secs) const {
613    int FineTuningTrys=3000; 
614    double NodeDistrWgt=10; 
615    double BorderWgt=25; 
616    double EdgeLenWgt=10; 
617    double EdgeCrossWgt=1000; 
618    double NodeEdgeDistWgt=10; 
619    TSecTm StartTm=TSecTm::GetCurTm();
620    double PrevEnergy=TFlt::Mx; 
621    for (int FineTuningTryN=0; FineTuningTryN&lt;FineTuningTrys; FineTuningTryN++){
622      PVrtx Vrtx=GetRndVrtx(Rnd); 
623      double PrevX=Vrtx-&gt;GetX();
624      double PrevY=Vrtx-&gt;GetY();
625      double NewX=Rnd.GetNrmDev(Vrtx-&gt;GetX(), 0.001, 0, 1);
626      double NewY=Rnd.GetNrmDev(Vrtx-&gt;GetY(), 0.001, 0, 1);
627      Vrtx-&gt;PutX(NewX);
628      Vrtx-&gt;PutY(NewY);
629      double Energy=GetSimAnnXYEnergy(NodeDistrWgt, BorderWgt, EdgeLenWgt,
630       EdgeCrossWgt, NodeEdgeDistWgt, true);
631      if (Energy&lt;PrevEnergy){
632        PrevEnergy=Energy;  
633      } else {
634        Vrtx-&gt;PutX(PrevX); Vrtx-&gt;PutY(PrevY); 
635      }
636      if (FineTuningTryN%100==0){Draw(Gks, true);}
637      TSecTm CurTm=TSecTm::GetCurTm();
638      if (Secs!=-1){
639        if (TSecTm::GetDSecs(StartTm, CurTm)&gt;uint(Secs)){break;}
640      }
641    }
642  }
643  void TGraph::PlaceCircle() const {
644    double Vrtxs=GetVrtxs();
645    double AngStep=0; if (Vrtxs&gt;0){AngStep=2*TMath::Pi/Vrtxs;}
<span onclick='openModal()' class='match'>646    double Ang=0;
647    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
648    while (FNextVrtx(VrtxP, Vrtx)){
649      TGksPPoint PPoint(1, Ang);
</span>650      TGksVPoint VPoint=PPoint.GetVPoint();
651      Vrtx-&gt;PutXY(VPoint.X, VPoint.Y);
652      Ang+=AngStep;
653    }
654  }
655  void TGraph::PlaceTreeAsStar(
656   const PVrtx&amp; HomeVrtx, const int&amp; Lev,
657   const double&amp; HomeX, const double&amp; HomeY,
658   const double&amp; MnAng, const double&amp; MxAng) const {
659    HomeVrtx-&gt;PutXY(HomeX, HomeY);
660    if (HomeVrtx-&gt;GetOutEIds()&gt;0){
661      double HalfAngStep=((MxAng-MnAng)/HomeVrtx-&gt;GetOutEIds())/2;
662      double Ang=MnAng;
663      for (int EIdN=0; EIdN&lt;HomeVrtx-&gt;GetOutEIds(); EIdN++){
664        PEdge Edge=GetEdge(HomeVrtx-&gt;GetOutEId(EIdN));
665        PVrtx NextVrtx=GetVrtx(Edge-&gt;GetOtherVId(HomeVrtx));
666        Ang+=HalfAngStep;
667        TGksPPoint PPoint(Lev+1, Ang);
668        TGksVPoint VPoint=PPoint.GetVPoint();
669        PlaceTreeAsStar(NextVrtx, Lev+1,
670         VPoint.X, VPoint.Y, Ang-HalfAngStep, Ang+HalfAngStep);
671        Ang+=HalfAngStep;
672      }
673    }
674  }
675  void TGraph::PlaceTreeAsStar() const {
676    PVrtx RootVrtx;
677    IAssert(IsTree(RootVrtx));
678    PlaceTreeAsStar(RootVrtx, 0, 0, 0, 0, 2*TMath::Pi);
679  }
680  void TGraph::PlaceGraphAsStar(const PVrtx&amp; HomeVrtx, const TStr&amp; DrawENm) const {
681      ClrVrtxMarks();
682      TVec&lt;TPair&lt;PVrtx,TFltPr&gt; &gt; LevVrtxV;
683      LevVrtxV.Add(TPair&lt;PVrtx,TFltPr&gt;(HomeVrtx, TFltPr(0.0, 2*TMath::Pi)));
684      HomeVrtx-&gt;SetMark();
685      int Level = 0;
686      while (!LevVrtxV.Empty()) {
687          for (int VrtxN = 0; VrtxN &lt; LevVrtxV.Len(); VrtxN++) {
688              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
689              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
690              const double Ang = MnAng + ((MxAng - MnAng)/2);
691              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
692              TGksPPoint PPoint(Level, Ang);
693              TGksVPoint VPoint=PPoint.GetVPoint();
694              Vrtx-&gt;PutXY(VPoint.X, VPoint.Y);
695          }
696          TVec&lt;TPair&lt;PVrtx,TFltPr&gt; &gt; NextLevVrtxV;
697          for (int VrtxN = 0; VrtxN &lt; LevVrtxV.Len(); VrtxN++) {
698              const double MnAng = LevVrtxV[VrtxN].Val2.Val1;
699              const double MxAng = LevVrtxV[VrtxN].Val2.Val2;
700              PVrtx Vrtx = LevVrtxV[VrtxN].Val1;
701              TVec&lt;PVrtx&gt; NextVrtxV;
702              const int EIds = Vrtx-&gt;GetInEIds();
703              for (int EIdN = 0; EIdN &lt; EIds; EIdN++) {
704                  PEdge Edge = GetEdge(Vrtx-&gt;GetInEId(EIdN));
705                  PVrtx NextVrtx = GetVrtx(Edge-&gt;GetOtherVId(Vrtx));
706                  if ((!NextVrtx-&gt;IsMark()) &amp;&amp; 
707                      (DrawENm.Empty() || (Edge-&gt;GetENm() == DrawENm))) {
708                          NextVrtxV.Add(NextVrtx);
709                  }
710              }
711              if (!NextVrtxV.Empty()) {
712                  double AngStep=(MxAng - MnAng)/NextVrtxV.Len();
713                  double Ang=MnAng;
714                  for (int VIdN=0; VIdN &lt; NextVrtxV.Len(); VIdN++){
715                      PVrtx NextVrtx=NextVrtxV[VIdN];
716                      const double NextMnAng = Ang;
717                      const double NextMxAng = Ang + AngStep;
718                      NextLevVrtxV.Add(TPair&lt;PVrtx,TFltPr&gt;(NextVrtx, TFltPr(NextMnAng, NextMxAng)));
719                      NextVrtx-&gt;SetMark();
720                      Ang += AngStep;
721                  }
722              }
723          }
724          Level++; LevVrtxV = NextLevVrtxV;
725      }
726  }
727  void TGraph::SetEdgeWidth(const int&amp; Intvs) const {
728    IAssert(Intvs&gt;0);
729    double MnWgt=TFlt::Mx; double MxWgt=TFlt::Mn;
730    {int EdgeP=FFirstEdge(); PEdge Edge;
731    while (FNextEdge(EdgeP, Edge)){
732      double Wgt=Edge-&gt;GetWgt();
733      MnWgt=TFlt::GetMn(MnWgt, Wgt);
734      MxWgt=TFlt::GetMx(MxWgt, Wgt);
735    }}
736    {int EdgeP=FFirstEdge(); PEdge Edge;
737    while (FNextEdge(EdgeP, Edge)){
738      double Wgt=Edge-&gt;GetWgt();
739      int Width=1;
740      if (MxWgt&gt;MnWgt){
741        Width=int(1+Intvs*((Wgt-MnWgt)/(MxWgt-MnWgt)));}
742      if (Width&gt;Intvs){Width=Intvs;} 
743      Edge-&gt;PutWidth(Width);
744    }}
745  }
746  void TGraph::Draw(const PGks&amp; Gks, const bool&amp; SimpleP,
747   const bool&amp; DrawEdgesP, const int&amp; FontSize,
748   const int&amp; EdgeFontSize, const int&amp; MxLnLen) const {
749    if (Gks.Empty()){return;}
750    TGksColor EdgeLineColor=TGksColor(0, 128, 0);
751    TGksColor EdgeBoxColor=TGksColor(0, 128, 0);
752    TGksColor NodeBoxColor=TGksColor(0, 0, 255);
753    TGksColor SelNodeBoxColor=TGksColor(255, 0, 0);
754    Gks-&gt;Clr();
755    Gks-&gt;SetPen(TGksPen::New(EdgeLineColor, gpmCopy, gpsSolid, 1));
756    Gks-&gt;SetBrush(TGksBrush::New(TGksColor::GetWhite(), gbsSolid));
757    Gks-&gt;SetFont(TGksFont::New(&quot;Tahoma&quot;, EdgeFontSize, TGksColor::GetBlack()));
758    if (DrawEdgesP){
759      {int PrevWidth=1;
760      int EdgeP=FFirstEdge(); PEdge Edge;
761      while (FNextEdge(EdgeP, Edge)){
762        PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
763        PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
764        bool DirP=Edge-&gt;IsDir();
765        int X1=Gks-&gt;GetVToPX(Vrtx1-&gt;GetX());
766        int Y1=Gks-&gt;GetVToPY(Vrtx1-&gt;GetY());
767        int X2=Gks-&gt;GetVToPX(Vrtx2-&gt;GetX());
768        int Y2=Gks-&gt;GetVToPY(Vrtx2-&gt;GetY());
769        int Width=TInt::GetMx(1, Edge-&gt;GetWidth());
770        if (Width!=PrevWidth){
771          PrevWidth=Width;
772          Gks-&gt;SetPen(TGksPen::New(TGksColor::GetGreen(), gpmCopy, gpsSolid, Width+1));
773        }
774        if (IsVrtxsEdge(Vrtx2-&gt;GetVId(), Vrtx1-&gt;GetVId(), true)){
775          if (DirP){Gks-&gt;DirLine(X1, Y1, X2, Y2, true, false, 10, 0.15);}
776          else {Gks-&gt;DirLine(X1, Y1, X2, Y2, false, false, 10, 0.15);}
777        } else {
778          if (DirP){Gks-&gt;DirLine(X1, Y1, X2, Y2, true, false, 10, 0.25);}
779          else {Gks-&gt;DirLine(X1, Y1, X2, Y2, false, false, 10, 0.25);}
780        }
781      }}
782      if (EdgeFontSize&gt;0){
783        Gks-&gt;SetPen(TGksPen::New(EdgeBoxColor, gpmCopy, gpsSolid, 2));
784        int EdgeP=FFirstEdge(); PEdge Edge;
785        while (FNextEdge(EdgeP, Edge)){
786          PVrtx Vrtx1=GetVrtx(Edge-&gt;GetVId1());
787          PVrtx Vrtx2=GetVrtx(Edge-&gt;GetVId2());
788          int X1=Gks-&gt;GetVToPX(Vrtx1-&gt;GetX());
789          int Y1=Gks-&gt;GetVToPY(Vrtx1-&gt;GetY());
790          int X2=Gks-&gt;GetVToPX(Vrtx2-&gt;GetX());
791          int Y2=Gks-&gt;GetVToPY(Vrtx2-&gt;GetY());
792          TStr Nm=(SimpleP) ? Edge-&gt;GetENm() : Edge-&gt;GetDNm();
793          if ((!Nm.Empty())&amp;&amp;(Nm[0]!=&#x27;_&#x27;)){
794            if (IsVrtxsEdge(Vrtx2-&gt;GetVId(), Vrtx1-&gt;GetVId(), true)){
795              TGksRect Rect=Gks-&gt;TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.60), int(Y1+(Y2-Y1)*0.60));
796            } else {
797              TGksRect Rect=Gks-&gt;TxtBox(gtbtRoundRect, Nm, int(X1+(X2-X1)*0.5), int(Y1+(Y2-Y1)*0.5));
798            }
799          }
800        }
801      }
802    }
803    TStr BoldVNm;
804    if (GetPp()-&gt;IsPp(&quot;BoldVNm&quot;)){
805      BoldVNm=GetPp()-&gt;GetValStr(&quot;BoldVNm&quot;);}
806    Gks-&gt;SetFont(TGksFont::New(&quot;Tahoma&quot;, FontSize, TGksColor::GetBlack(), TFSet(gfsBold)));
807    Gks-&gt;SetPen(TGksPen::New(TGksColor::GetBlue(), gpmCopy, gpsSolid, 1));
808    if (SimpleP){
809      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
810      while (FNextVrtx(VrtxP, Vrtx)){
811        TStr VNm=Vrtx-&gt;GetVNm();
812        if ((!VNm.Empty())&amp;&amp;(VNm[0]!=&#x27;_&#x27;)){
813          int X=Gks-&gt;GetVToPX(Vrtx-&gt;GetX());
814          int Y=Gks-&gt;GetVToPY(Vrtx-&gt;GetY());
815          TGksTxtBoxType TxtBoxType=gtbtRoundRect;
816          TGksColor Color=TGksColor::GetBlue();
817          if (Vrtx-&gt;GetColor()!=0){
818            Color.PutArgbVal(Vrtx-&gt;GetColor());}
819          if (VNm==BoldVNm){
820            Gks-&gt;SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 5));
821          } else {
822            Gks-&gt;SetPen(TGksPen::New(Color, gpmCopy, gpsSolid, 2));
823          }
824          if (MxLnLen!=-1){
825            TChA ChA=VNm; int LnChN=0;
826            for (int ChN=0; ChN&lt;ChA.Len(); ChN++){
827              if ((LnChN&gt;MxLnLen)&amp;&amp;(ChA[ChN]==&#x27; &#x27;)){ChA[ChN]=&#x27;\\&#x27;; LnChN=0;}
828              LnChN++;
829            }
830            VNm=ChA;
831          }
832          TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, VNm, X, Y);
833          Vrtx-&gt;PutRect(Rect);
834        }
835      }
836    } else {
837      int VrtxP=FFirstVrtx(); PVrtx Vrtx;
838      while (FNextVrtx(VrtxP, Vrtx)){
839        TStr DNm=Vrtx-&gt;GetDNm();
840        int Brief=Vrtx-&gt;GetBrief();
841        int X=Gks-&gt;GetVToPX(Vrtx-&gt;GetX());
842        int Y=Gks-&gt;GetVToPY(Vrtx-&gt;GetY());
843        TGksTxtBoxType TxtBoxType=gtbtRect;
844        if (DNm==BoldVNm){
845          Gks-&gt;SetPen(TGksPen::New(SelNodeBoxColor, gpmCopy, gpsSolid, 2));
846        } else {
847          Gks-&gt;SetPen(TGksPen::New(NodeBoxColor, gpmCopy, gpsSolid, 2));
848        }
849        if (Brief==0){
850          TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, DNm, X, Y);
851          Vrtx-&gt;PutRect(Rect);
852        } else {
853          if (DNm.IsChIn(&#x27;#&#x27;)){
854            TStr TxtStr1; TStr TxtStr2;
855            DNm.SplitOnCh(TxtStr1, &#x27;#&#x27;, TxtStr2);
856            TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, TxtStr1, X, Y);
857            Vrtx-&gt;PutRect(Rect);
858          } else {
859            TGksRect Rect=Gks-&gt;TxtBox(TxtBoxType, DNm, X, Y);
860            Vrtx-&gt;PutRect(Rect);
861          }
862        }
863      }
864    }
865  }
866  void TGraph::_DrawTxtTree(const PVrtx&amp; Vrtx, TChAV&amp; LnV) const {
867    TStr VNm=
868     TStr::GetStr(Vrtx-&gt;GetVNm(), &quot;[%5s]-&quot;)+
869     TFlt::GetStr(Vrtx-&gt;GetWgt(), &quot;{%+4.2f}&quot;);
870    if (Vrtx-&gt;NoOutEIds()){
871      LnV.Add(VNm);
872      LnV.Add();
873    } else {
874      int VrtxLnN=LnV.Len(); TIntV OutLnNV; TStrV OutENmV;
875      for (int OutEIdN=0; OutEIdN&lt;Vrtx-&gt;GetOutEIds(); OutEIdN++){
876        PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(OutEIdN));
877        PVrtx OutVrtx=GetVrtx(Edge-&gt;GetOutVId());
878        OutENmV.Add();
879        OutLnNV.Add(LnV.Len());
880        _DrawTxtTree(OutVrtx, LnV);
881      }
882      int VrtxLevChN=0;
883      {for (int OutLnNN=0; OutLnNN&lt;OutLnNV.Len(); OutLnNN++){
884        int OutLnN=OutLnNV[OutLnNN];
885        VrtxLevChN=TInt::GetMx(VrtxLevChN, LnV[OutLnN].Len());
886      }}
887      LnV[VrtxLnN].AddChTo(&#x27;-&#x27;, VrtxLevChN);
888      LnV[VrtxLnN]+=&quot;-&quot;; LnV[VrtxLnN]+=OutENmV[0];
889      LnV[VrtxLnN]+=&quot;-+-&quot;; LnV[VrtxLnN]+=VNm;
890      {for (int OutLnNN=1; OutLnNN&lt;OutLnNV.Len(); OutLnNN++){
891        int OutLnN=OutLnNV[OutLnNN];
892        LnV[OutLnN].AddChTo(&#x27;-&#x27;, VrtxLevChN);
893        LnV[OutLnN]+=&quot;-&quot;; LnV[OutLnN]+=OutENmV[OutLnNN];
894        LnV[OutLnN]+=&quot;-+ &quot;;
895        for (int GapLnN=OutLnNV[OutLnNN-1]+1; GapLnN&lt;OutLnN; GapLnN++){
896          LnV[GapLnN].AddChTo(&#x27; &#x27;, VrtxLevChN+OutENmV[OutLnNN].Len()+1);
897          LnV[GapLnN]+=&quot; | &quot;;
898        }
899      }}
900    }
901  }
902  void TGraph::DrawTxtTree(const PSOut&amp; SOut) const {
903    PVrtx RootVrtx; IAssert(IsTree(RootVrtx));
904    TChAV LnV;
905    _DrawTxtTree(RootVrtx, LnV);
906    for (int LnN=0; LnN&lt;LnV.Len(); LnN++){
907      SOut-&gt;PutStr(LnV[LnN]); SOut-&gt;PutLn();
908    }
909  }
910  bool TGraph::IsVrtxAt(
911   const PGks&amp; &amp;bsol;*Gks*/, const int&amp; X, const int&amp; Y, PVrtx&amp; Vrtx) const {
912    int VrtxP=FFirstVrtx();
913    while (FNextVrtx(VrtxP, Vrtx)){
914      if (Vrtx-&gt;IsInRect(X, Y)){return true;}}
915    return false;
916  }
917  bool TGraph::IsEdgeAt(
918   const PGks&amp; &amp;bsol;*Gks*/, const int&amp; X, const int&amp; Y, PEdge&amp; Edge) const {
919    int EdgeP=FFirstEdge();
920    while (FNextEdge(EdgeP, Edge)){
921      if (Edge-&gt;IsInRect(X, Y)){return true;}}
922    return false;
923  }
924  bool TGraph::IsDir() const {
925    int EdgeP=FFirstEdge(); PEdge Edge;
926    while (FNextEdge(EdgeP, Edge)){
927      if (!Edge-&gt;IsDir()){return false;}}
928    return true;
929  }
930  bool TGraph::_IsDag(const PVrtx&amp; Vrtx, const int&amp; Mark) const {
931    if (Vrtx-&gt;GetMark()==Mark){printf(&quot;[Bad:%d]&quot;, Vrtx-&gt;GetVId()); return false;}
932    if (!Vrtx-&gt;IsMark()){
933      Vrtx-&gt;PutMark(Mark);
934      for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
935        PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
936        PVrtx Vrtx=GetVrtx(Edge-&gt;GetOutVId());
937        if (!_IsDag(Vrtx, Mark)){return false;}
938      }
939    }
940    return true;
941  }
942  bool TGraph::IsDag() const {
943    if (!IsDir()){return false;}
944    ClrVrtxMarks();
945    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int Mark=0;
946    while (FNextVrtx(VrtxP, Vrtx)){
947      if (!_IsDag(Vrtx, ++Mark)){return false;}
948    }
949    return true;
950  }
951  bool TGraph::IsTree(PVrtx&amp; RootVrtx) const {
952    if (!IsDir()){return false;}
953    if (!IsDag()){return false;}
954    RootVrtx=NULL;
955    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
956    while (FNextVrtx(VrtxP, Vrtx)){
957      if (Vrtx-&gt;GetInEIds()==0){
958        if (RootVrtx.Empty()){RootVrtx=Vrtx;} else {return false;}
959      }
960    }
961    return !Vrtx.Empty();
962  }
963  void TGraph::GetLeafVIdV(const int&amp; RootVId, TIntV&amp; VIdV) const {
964    IAssert(IsDag());
965    VIdV.Clr();
966    TIntQ VIdQ; VIdQ.Push(RootVId);
967    do {
968      int VId=VIdQ.Top(); VIdQ.Pop();
969      PVrtx Vrtx=GetVrtx(VId);
970      if (Vrtx-&gt;NoOutEIds()){
971        VIdV.Add(VId);
972      } else {
973        for (int OutEIdN=0; OutEIdN&lt;Vrtx-&gt;GetOutEIds(); OutEIdN++){
974          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(OutEIdN));
975          PVrtx OutVrtx=GetVrtx(Edge-&gt;GetOutVId());
976          VIdQ.Push(OutVrtx-&gt;GetVId());
977        }
978      }
979    } while (!VIdQ.Empty());
980  }
981  void TGraph::GetHitsW() const {
982    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
983    while (FNextVrtx(VrtxP, Vrtx)){
984      Vrtx-&gt;PutHitsHubW(1); Vrtx-&gt;PutHitsAuthW(1);}}
985    double EpsChange=1/double(GetVrtxs());
986    double MxChange; double SumChange=0;
987    TFltV PrevHubWV(GetVrtxs()); TFltV PrevAuthWV(GetVrtxs());
988    int IterN=0; printf(&quot;\n&quot;);
989    do {
990      MxChange=0; SumChange=0;
991      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
992      while (FNextVrtx(VrtxP, Vrtx)){
993        double AuthW=0;
994        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetInEIds(); EIdN++){
995          PEdge Edge=GetEdge(Vrtx-&gt;GetInEId(EIdN));
996          PVrtx SrcVrtx=GetVrtx(Edge-&gt;GetInVId());
997          AuthW+=SrcVrtx-&gt;GetHitsHubW();
998        }
999        Vrtx-&gt;PutHitsAuthW(AuthW);
1000      }}
1001      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1002      while (FNextVrtx(VrtxP, Vrtx)){
1003        double HubW=0;
1004        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
1005          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
1006          PVrtx DstVrtx=GetVrtx(Edge-&gt;GetOutVId());
1007          HubW+=DstVrtx-&gt;GetHitsAuthW();
1008        }
1009        Vrtx-&gt;PutHitsHubW(HubW);
1010      }}
1011      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1012      while (FNextVrtx(VrtxP, Vrtx)){
1013        Vrtx-&gt;PutHitsAuthW(log(1+Vrtx-&gt;GetHitsAuthW()));}}
1014      double SumSqrAuthW=0;
1015      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1016      while (FNextVrtx(VrtxP, Vrtx)){
1017        SumSqrAuthW+=TMath::Sqr(Vrtx-&gt;GetHitsAuthW());}}
1018      double SqrtSumSqrAuthW=sqrt(SumSqrAuthW);
1019      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1020      while (FNextVrtx(VrtxP, Vrtx)){
1021        double AuthW=Vrtx-&gt;GetHitsAuthW()/SqrtSumSqrAuthW;
1022        Vrtx-&gt;PutHitsAuthW(AuthW);}}
1023      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1024      while (FNextVrtx(VrtxP, Vrtx)){
1025        Vrtx-&gt;PutHitsHubW(log(1+Vrtx-&gt;GetHitsHubW()));}}
1026      double SumSqrHubW=0;
1027      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1028      while (FNextVrtx(VrtxP, Vrtx)){
1029        SumSqrHubW+=TMath::Sqr(Vrtx-&gt;GetHitsHubW());}}
1030      double SqrtSumSqrHubW=sqrt(SumSqrHubW);
1031      {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1032      while (FNextVrtx(VrtxP, Vrtx)){
1033        double HubW=Vrtx-&gt;GetHitsHubW()/SqrtSumSqrHubW;
1034        Vrtx-&gt;PutHitsHubW(HubW);}}
1035      {int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1036      while (FNextVrtx(VrtxP, Vrtx)){
1037        double HubWChange=fabs(Vrtx-&gt;GetHitsHubW()-PrevHubWV[VrtxN]);
1038        double AuthWChange=fabs(Vrtx-&gt;GetHitsAuthW()-PrevAuthWV[VrtxN]);
1039        if (HubWChange&gt;MxChange){MxChange=HubWChange;}
1040        if (AuthWChange&gt;MxChange){MxChange=AuthWChange;}
1041        SumChange+=HubWChange; SumChange+=AuthWChange;
1042        PrevHubWV[VrtxN]=Vrtx-&gt;GetHitsHubW();
1043        PrevAuthWV[VrtxN]=Vrtx-&gt;GetHitsAuthW();
1044        VrtxN++;
1045      }}
1046      IterN++;
1047      printf(&quot;Iteration: %d   Max. Change: %g   Eps. Change: %g\n&quot;,
1048       IterN, MxChange, EpsChange);
1049    } while (IterN&lt;20); 
1050  }
1051  void TGraph::GetTopHitsVrtxV(
1052   TVrtxV&amp; TopHubVrtxV, TVrtxV&amp; TopAuthVrtxV) const {
1053    typedef TKeyDat&lt;TFlt, PVrtx&gt; TWgtVrtxKd;
1054    TVec&lt;TWgtVrtxKd&gt; WgtVrtxKdV;
1055    TopHubVrtxV.Gen(GetVrtxs(), 0);
1056    TopAuthVrtxV.Gen(GetVrtxs(), 0);
1057    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1058    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1059    while (FNextVrtx(VrtxP, Vrtx)){
1060      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx-&gt;GetHitsHubW(), Vrtx));}}
1061    WgtVrtxKdV.Sort(false);
1062    for (int VrtxN=0; VrtxN&lt;WgtVrtxKdV.Len(); VrtxN++){
1063      TopHubVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}
1064    WgtVrtxKdV.Gen(GetVrtxs(), 0);
1065    {int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1066    while (FNextVrtx(VrtxP, Vrtx)){
1067      WgtVrtxKdV.Add(TWgtVrtxKd(Vrtx-&gt;GetHitsAuthW(), Vrtx));}}
1068    WgtVrtxKdV.Sort(false);
1069    {for (int VrtxN=0; VrtxN&lt;WgtVrtxKdV.Len(); VrtxN++){
1070      TopAuthVrtxV.Add(WgtVrtxKdV[VrtxN].Dat);}}
1071  }
1072  void TGraph::GetConnVrtxV(PVrtx&amp; RootVrtx, TVrtxV&amp; ConnVrtxV) const {
1073    ConnVrtxV.Clr();
1074    ClrVrtxMarks();
1075    TQQueue&lt;PVrtx&gt; VrtxQ;
1076    VrtxQ.Push(RootVrtx);
1077    while (!VrtxQ.Empty()){
1078      PVrtx Vrtx=VrtxQ.Top(); VrtxQ.Pop();
1079      if (!Vrtx-&gt;IsMark()){
1080        ConnVrtxV.Add(Vrtx);
1081        Vrtx-&gt;PutMark(true);
1082        for (int EIdN=0; EIdN&lt;Vrtx-&gt;GetOutEIds(); EIdN++){
1083          PEdge Edge=GetEdge(Vrtx-&gt;GetOutEId(EIdN));
1084          VrtxQ.Push(GetVrtx(Edge-&gt;GetVId1()));
1085          VrtxQ.Push(GetVrtx(Edge-&gt;GetVId2()));
1086        }
1087      }
1088    }
1089  }
1090  PGraph TGraph::GetRndGraph(
1091   TRnd&amp; Rnd, const int&amp; Vrtxs, const int&amp; Edges,
1092   const bool&amp; DirEdgeP, const int&amp; EdgeToSameVrtxP){
1093    IAssert((Vrtxs&gt;=0)&amp;&amp;(Edges&gt;=0));
1094    PGraph Graph=New();
1095    for (int VrtxN=0; VrtxN&lt;Vrtxs; VrtxN++){
1096      PVrtx Vrtx=PVrtx(new TGVrtx()); Graph-&gt;AddVrtx(Vrtx);}
1097    int EdgeN=0;
1098    while (Graph-&gt;GetEdges()&lt;Edges){
1099      PVrtx Vrtx1=Graph-&gt;GetRndVrtx(Rnd);
1100      PVrtx Vrtx2=Graph-&gt;GetRndVrtx(Rnd);
1101      while ((!EdgeToSameVrtxP)&amp;&amp;(Vrtx1==Vrtx2)){
1102        IAssert(Vrtxs&gt;1); Vrtx2=Graph-&gt;GetRndVrtx(Rnd);}
1103      PEdge Edge=PEdge(new TGEdge(Vrtx1, Vrtx2, TStr::GetNullStr(), DirEdgeP));
1104      Graph-&gt;AddEdge(Edge); EdgeN++;
1105    }
1106    return Graph;
1107  }
1108  PGraph TGraph::LoadXml(const PXmlDoc&amp; XmlDoc, const TStr&amp; TypeNm){
1109    PXmlTok GraphTok=XmlDoc-&gt;GetTok();
1110    EAssertR(GraphTok-&gt;IsTag(&quot;Graph&quot;), &quot;Bad root XML tag (&lt;Graph&gt; expected).&quot;);
1111    int GraphSubToks=GraphTok-&gt;GetSubToks();
1112    TStr FinalTypeNm=TypeNm;
1113    if (FinalTypeNm.Empty()){
1114      FinalTypeNm=XmlDoc-&gt;GetTok()-&gt;GetArgVal(&quot;TypeNm&quot;, &quot;&quot;);}
1115    PGraph Graph=New(FinalTypeNm);
1116    for (int GraphTokN=0; GraphTokN&lt;GraphSubToks; GraphTokN++){
1117      PXmlTok Tok=GraphTok-&gt;GetSubTok(GraphTokN);
1118      if (Tok-&gt;IsTag(TGraph::VrtxNm)){
1119        PVrtx Vrtx=TVrtx::LoadXml(Tok);
1120        Graph-&gt;AddVrtx(Vrtx);
1121      }
1122    }
1123    {for (int GraphTokN=0; GraphTokN&lt;GraphSubToks; GraphTokN++){
1124      PXmlTok Tok=GraphTok-&gt;GetSubTok(GraphTokN);
1125      if (Tok-&gt;IsTag(TGraph::EdgeNm)){
1126        PEdge Edge=TEdge::LoadXml(Tok);
1127        Graph-&gt;AddEdge(Edge);
1128      }
1129    }}
1130    return Graph;
1131  }
1132  PXmlDoc TGraph::GetXmlDoc() const {
1133    PXmlTok GraphTok=TXmlTok::New(&quot;Graph&quot;);
1134    GraphTok-&gt;AddArg(&quot;TypeNm&quot;, GetTypeNm());
1135    for (int PpN=0; PpN&lt;GetPps(); PpN++){
1136      GraphTok-&gt;AddArg(PpNm, GetPp(PpN)-&gt;GetStr());
1137    }
1138    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1139    while (FNextVrtx(VrtxP, Vrtx)){
1140      PXmlTok VrtxTok=Vrtx-&gt;GetXmlTok();
1141      GraphTok-&gt;AddSubTok(VrtxTok);
1142    }
1143    int EdgeP=FFirstEdge(); PEdge Edge;
1144    while (FNextEdge(EdgeP, Edge)){
1145      PXmlTok EdgeTok=Edge-&gt;GetXmlTok();
1146      GraphTok-&gt;AddSubTok(EdgeTok);
1147    }
1148    PXmlDoc GraphDoc=TXmlDoc::New(GraphTok);
1149    return GraphDoc;
1150  }
1151  PGraph TGraph::LoadTxt(const PSIn&amp; SIn, const TStr&amp; TypeNm){
1152    TILx Lx(SIn, TFSet()|iloCmtAlw|iloSigNum);
1153    TStr FinalTypeNm=TypeNm;
1154    if (Lx.GetSym(syIdStr, syLBracket)==syIdStr){
1155      if (FinalTypeNm.Empty()){FinalTypeNm=Lx.Str;}
1156      Lx.GetSym(syColon); Lx.GetSym(syLBracket);
1157    }
1158    PGraph Graph=New(FinalTypeNm);
1159    while (Lx.GetSym(syIdStr, syRBracket)==syIdStr){
1160      TStr Tag=Lx.Str;
1161      Lx.GetSym(syColon);
1162      if (Tag==PpNm){
1163        PPp Pp=TPp::LoadTxt(Lx);
1164        Graph-&gt;AddPp(Pp);
1165      } else
1166      if (Tag==VrtxNm){
1167        PVrtx Vrtx=TVrtx::LoadTxt(Lx);
1168        Graph-&gt;AddVrtx(Vrtx);
1169      } else
1170      if (Tag==EdgeNm){
1171        PEdge Edge=TEdge::LoadTxt(Lx);
1172        Graph-&gt;AddEdge(Edge);
1173      } else {
1174        Fail;
1175      }
1176    }
1177    return Graph;
1178  }
1179  void TGraph::SaveTxt(const PSOut&amp; SOut) const {
1180    TOLx Lx(SOut, TFSet()|oloCmtAlw|oloFrcEoln|oloSigNum);
1181    Lx.PutVar(GetTypeNm(), true, true);
1182    for (int PpN=0; PpN&lt;GetPps(); PpN++){
1183      Lx.PutIdStr(PpNm); Lx.PutSym(syColon);
1184      GetPp(PpN)-&gt;SaveTxt(Lx); Lx.PutLn();
1185    }
1186    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1187    while (FNextVrtx(VrtxP, Vrtx)){
1188      Lx.PutIdStr(VrtxNm); Lx.PutSym(syColon);
1189      Vrtx-&gt;SaveTxt(Lx); Lx.PutLn();
1190    }
1191    int EdgeP=FFirstEdge(); PEdge Edge;
1192    while (FNextEdge(EdgeP, Edge)){
1193      Lx.PutIdStr(EdgeNm); Lx.PutSym(syColon);
1194      Edge-&gt;SaveTxt(Lx); Lx.PutLn();
1195    }
1196    Lx.PutVarEnd(true, true);
1197  }
1198  void TGraph::SaveTxtTab(const TStr&amp; FNm) const {
1199    TFOut TabFOut(FNm); FILE* fTab=TabFOut.GetFileId();
1200    fprintf(fTab, &quot;VH\tVId\tName\tX\tY\n&quot;);
1201    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1202    while (FNextVrtx(VrtxP, Vrtx)){
1203      fprintf(fTab, &quot;V\t%d\t%s\t%g\t%g\n&quot;,
1204       Vrtx-&gt;GetVId(), Vrtx-&gt;GetVNm().CStr(), Vrtx-&gt;GetX(), Vrtx-&gt;GetY());
1205    }
1206    fprintf(fTab, &quot;EH\tEId\tVId1\tVId2\tDir\tName\tWidth\n&quot;);
1207    int EdgeP=FFirstEdge(); PEdge Edge;
1208    while (FNextEdge(EdgeP, Edge)){
1209      fprintf(fTab, &quot;E\t%d\t%d\t%d\t%s\t%s\t%d\n&quot;,
1210       Edge-&gt;GetEId(), Edge-&gt;GetVId1(), Edge-&gt;GetVId2(),
1211       TBool::GetStr(Edge-&gt;IsDir()).CStr(), Edge-&gt;GetENm().CStr(),
1212       Edge-&gt;GetWidth());
1213    }
1214  }
1215  void TGraph::SaveTxtPajek(const TStr&amp; FNm) const {
1216    PSOut SOut=TFOut::New(FNm);
1217    SOut-&gt;PutStr(&quot;*vertices &quot;);
1218    int Vrtxs=GetVrtxs();
1219    SOut-&gt;PutStr(TInt::GetStr(Vrtxs));
1220    SOut-&gt;PutDosLn();
1221    TIntIntH VIdToVrtxNH(Vrtxs);
1222    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1223    while (FNextVrtx(VrtxP, Vrtx)){
1224      VrtxN++;
1225      VIdToVrtxNH.AddDat(Vrtx-&gt;GetVId(), VrtxN);
1226      SOut-&gt;PutStr(TInt::GetStr(VrtxN));
1227      SOut-&gt;PutStr(TStr(&quot; \&quot;&quot;)+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;);
1228      SOut-&gt;PutDosLn();
1229    }
1230    SOut-&gt;PutStr(&quot;*arcs&quot;); SOut-&gt;PutDosLn();
1231    int EdgeP=FFirstEdge(); PEdge Edge;
1232    while (FNextEdge(EdgeP, Edge)){
1233      int VId1=Edge-&gt;GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1234      int VId2=Edge-&gt;GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1235      SOut-&gt;PutStr(TInt::GetStr(VrtxN1)+&quot; &quot;+TInt::GetStr(VrtxN2));
1236      SOut-&gt;PutDosLn();
1237    }
1238  }
1239  void TGraph::SaveTxtMatlab(const TStr&amp; FNm) const {
1240    PSOut VrtxSOut=TFOut::New(TStr::PutFExt(FNm, &quot;.vrtx-names.dat&quot;));
1241    int Vrtxs=GetVrtxs(); TIntIntH VIdToVrtxNH(Vrtxs);
1242    int VrtxP=FFirstVrtx(); PVrtx Vrtx; int VrtxN=0;
1243    while (FNextVrtx(VrtxP, Vrtx)){
1244      VrtxN++;
1245      VIdToVrtxNH.AddDat(Vrtx-&gt;GetVId(), VrtxN);
1246      VrtxSOut-&gt;PutStrLn(Vrtx-&gt;GetVNm());
1247    }
1248    PSOut EdgeSOut=TFOut::New(FNm);
1249    int EdgeP=FFirstEdge(); PEdge Edge;
1250    while (FNextEdge(EdgeP, Edge)){
1251      int VId1=Edge-&gt;GetVId1(); int VrtxN1=VIdToVrtxNH.GetDat(VId1);
1252      int VId2=Edge-&gt;GetVId2(); int VrtxN2=VIdToVrtxNH.GetDat(VId2);
1253      const double Wgt = Edge-&gt;GetWgt();
1254      EdgeSOut-&gt;PutStrLn(TStr::Fmt(&quot;%d %d %g&quot;, 
1255          TInt::GetMn(VrtxN1, VrtxN2), TInt::GetMx(VrtxN1, VrtxN2), Wgt));
1256    }
1257  }
1258  void TGraph::SaveTxtHits(const TStr&amp; FNm, const int&amp; TopN) const {
1259    TVrtxV HubVrtxV; TVrtxV AuthVrtxV;
1260    GetTopHitsVrtxV(HubVrtxV, AuthVrtxV);
1261    PSOut SOut=TFOut::New(FNm);
1262    int HubVrtxs=(TopN==-1) ? HubVrtxV.Len() : TInt::GetMn(TopN, HubVrtxV.Len());
1263    SOut-&gt;PutStr(&quot;---Hubs---------------------------&quot;); SOut-&gt;PutLn();
1264    for (int VrtxN=0; VrtxN&lt;HubVrtxs; VrtxN++){
1265      PVrtx Vrtx=HubVrtxV[VrtxN];
1266      TStr RankStr=TInt::GetStr(1+VrtxN, &quot;%d.&quot;);
1267      TStr WgtStr=TFlt::GetStr(Vrtx-&gt;GetHitsHubW(), &quot;%0.4g&quot;);
1268      TStr InStr=TStr(&quot;in:&quot;)+TInt::GetStr(Vrtx-&gt;GetInEIds(), &quot;%2d&quot;);
1269      TStr OutStr=TStr(&quot;out:&quot;)+TInt::GetStr(Vrtx-&gt;GetOutEIds(), &quot;%2d&quot;);
1270      TStr Str=RankStr+&quot; &quot;+WgtStr+&quot; -&gt; &quot;+InStr+&quot; &quot;+OutStr+&quot; \&quot;&quot;+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;;
1271      SOut-&gt;PutStr(Str); SOut-&gt;PutLn();
1272    }
1273    int AuthVrtxs=(TopN==-1) ? AuthVrtxV.Len() : TInt::GetMn(TopN, AuthVrtxV.Len());
1274    SOut-&gt;PutStr(&quot;---Authorities--------------------&quot;); SOut-&gt;PutLn();
1275    {for (int VrtxN=0; VrtxN&lt;AuthVrtxs; VrtxN++){
1276      PVrtx Vrtx=AuthVrtxV[VrtxN];
1277      TStr RankStr=TInt::GetStr(1+VrtxN, &quot;%d. &quot;);
1278      TStr WgtStr=TFlt::GetStr(Vrtx-&gt;GetHitsAuthW(), &quot;%0.4g&quot;);
1279      TStr InStr=TStr(&quot;in:&quot;)+TInt::GetStr(Vrtx-&gt;GetInEIds(), &quot;%2d&quot;);
1280      TStr OutStr=TStr(&quot;out:&quot;)+TInt::GetStr(Vrtx-&gt;GetOutEIds(), &quot;%2d&quot;);
1281      TStr Str=RankStr+&quot; &quot;+WgtStr+&quot; -&gt; &quot;+InStr+&quot; &quot;+OutStr+&quot; \&quot;&quot;+Vrtx-&gt;GetVNm()+&quot;\&quot;&quot;;
1282      SOut-&gt;PutStr(Str); SOut-&gt;PutLn();
1283    }}
1284  }
1285  void TGraph::_SaveTxtSparseNbrs(const int&amp; SrcVId,
1286   const int&amp; Lev, const int&amp; MxLev, TIntFltH&amp; VIdToWgtH) const {
1287    if (Lev&lt;=MxLev){
1288      PVrtx SrcVrtx=GetVrtx(SrcVId);
1289      for (int EIdN=0; EIdN&lt;SrcVrtx-&gt;GetOutEIds(); EIdN++){
1290        PEdge Edge=GetEdge(SrcVrtx-&gt;GetOutEId(EIdN));
1291        int DstVId=Edge-&gt;GetOtherVId(SrcVrtx);
1292        VIdToWgtH.AddDat(DstVId)+=1.0/(Lev+1);
1293        _SaveTxtSparseNbrs(DstVId, Lev+1, MxLev, VIdToWgtH);
1294      }
1295    }
1296  }
1297  void TGraph::SaveTxtSparseNbrs(
1298   const TStr&amp; VarIdFNm, const TStr&amp; TupIdFNm, const TStr&amp; TupVarValFNm,
1299   const int&amp; MxLev) const {
1300    {PSOut VarIdSOut=TFOut::New(VarIdFNm);
1301    PSOut TupIdSOut=TFOut::New(TupIdFNm);
1302    PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1303    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1304    while (FNextVrtx(VrtxP, Vrtx)){
1305      TStr NrVNm=Vrtx-&gt;GetVNm(); NrVNm.ChangeChAll(&#x27;&quot;&#x27;, &#x27;\&#x27;&#x27;);
1306      TChA ChA;
1307      ChA+=TInt::GetStr(Vrtx-&gt;GetVId()); ChA+=&#x27;:&#x27;;
1308      ChA+=&#x27;&quot;&#x27;; ChA+=NrVNm; ChA+=&#x27;&quot;&#x27;; ChA+=&#x27;\n&#x27;;
1309      TupIdSOut-&gt;PutStr(ChA);
1310      VarIdSOut-&gt;PutStr(ChA);
1311    }}
1312    {PSOut TupVarValSOut=TFOut::New(TupVarValFNm);
1313    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1314    while (FNextVrtx(VrtxP, Vrtx)){
1315      int VId=Vrtx-&gt;GetVId();
1316      TIntFltH VIdToWgtH;
1317      VIdToWgtH.AddDat(VId, 1);
1318      _SaveTxtSparseNbrs(VId, 1, MxLev, VIdToWgtH);
1319      TIntFltPrV VIdWgtPrV; VIdToWgtH.GetKeyDatPrV(VIdWgtPrV);
1320      VIdWgtPrV.Sort();
1321      TChA ChA;
1322      ChA+=TInt::GetStr(VId);
1323      for (int VIdN=0; VIdN&lt;VIdWgtPrV.Len(); VIdN++){
1324        ChA+=&#x27; &#x27;; ChA+=TInt::GetStr(VIdWgtPrV[VIdN].Val1);
1325        ChA+=&#x27;:&#x27;; ChA+=TFlt::GetStr(VIdWgtPrV[VIdN].Val2, &quot;%.3f&quot;);
1326      }
1327      ChA+=&#x27;\n&#x27;;
1328      TupVarValSOut-&gt;PutStr(ChA);
1329    }}
1330  }
1331  bool TGGraph::IsReg=TGGraph::MkReg();
1332  int TGGraph::AddVrtx(const PVrtx&amp; Vrtx){
1333    Vrtx-&gt;DefVrtx(this);
1334    int VId=Vrtx-&gt;GetVId();
1335    TStr VNm=Vrtx-&gt;GetVNm();
1336    IAssert(!VIdToVrtxH.IsKey(VId));
1337    VIdToVrtxH.AddDat(VId, Vrtx);
1338    if (!VNm.Empty()){VNmToVIdH.AddDat(VNm, VId);}
1339    return VId;
1340  }
1341  void TGGraph::DelVrtx(const PVrtx&amp; Vrtx){
1342    while (Vrtx-&gt;GetInEIds()&gt;0){
1343      DelEdge(Vrtx-&gt;GetInEId(0));}
1344    while (Vrtx-&gt;GetOutEIds()&gt;0){
1345      DelEdge(Vrtx-&gt;GetOutEId(0));}
1346    VIdToVrtxH.DelKey(Vrtx-&gt;GetVId());
1347    if (!Vrtx-&gt;GetVNm().Empty()){VNmToVIdH.DelKey(Vrtx-&gt;GetVNm());}
1348  }
1349  bool TGGraph::IsVrtx(const TStr&amp; VNm, PVrtx&amp; Vrtx) const {
1350    int VNmToVIdP;
1351    if (VNmToVIdH.IsKey(VNm, VNmToVIdP)){
1352      Vrtx=GetVrtx(VNmToVIdH[VNmToVIdP]); return true;}
1353    else {return false;}
1354  }
1355  bool TGGraph::FNextVrtx(int&amp; VrtxP, PVrtx&amp; Vrtx) const {
1356    if (VIdToVrtxH.FNextKeyId(VrtxP)){
1357      Vrtx=VIdToVrtxH[VrtxP]; return true;}
1358    else {return false;}
1359  }
1360  void TGGraph::ClrVrtxMarks() const {
1361    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
1362    while (FNextVrtx(VrtxP, Vrtx)){
1363      Vrtx-&gt;ClrMark();}
1364  }
1365  int TGGraph::AddEdge(const PEdge&amp; Edge){
1366    Edge-&gt;DefEdge(this);
1367    int EId=Edge-&gt;GetEId();
1368    int VId1=Edge-&gt;GetVId1();
1369    int VId2=Edge-&gt;GetVId2();
1370    bool DirP=Edge-&gt;IsDir();
1371    TStr ENm=Edge-&gt;GetENm();
1372    IAssert(!EIdToEdgeH.IsKey(EId));
1373    IAssert(VIdToVrtxH.IsKey(VId1));
1374    IAssert(VIdToVrtxH.IsKey(VId2));
1375    DefEId(EId);
1376    EIdToEdgeH.AddDat(EId, Edge);
1377    if (!ENm.Empty()){ENmToEIdH.AddDat(ENm, EId);}
1378    VIdToVrtxH.GetDat(VId1)-&gt;AddOutEId(EId);
1379    VIdToVrtxH.GetDat(VId2)-&gt;AddInEId(EId);
1380    if (!DirP){
1381      VIdToVrtxH.GetDat(VId1)-&gt;AddInEId(EId);
1382      VIdToVrtxH.GetDat(VId2)-&gt;AddOutEId(EId);
1383    }
1384    return EId;
1385  }
1386  void TGGraph::DelEdge(const PEdge&amp; Edge){
1387    int EId=Edge-&gt;GetEId();
1388    int VId1=Edge-&gt;GetVId1();
1389    int VId2=Edge-&gt;GetVId2();
1390    GetVrtx(VId1)-&gt;DelEId(EId);
1391    GetVrtx(VId2)-&gt;DelEId(EId);
1392    EIdToEdgeH.DelKey(Edge-&gt;GetEId());
1393    if (!Edge-&gt;GetENm().Empty()){
1394      if (ENmToEIdH.IsKey(Edge-&gt;GetENm())){
1395        ENmToEIdH.DelKey(Edge-&gt;GetENm());}
1396    }
1397  }
1398  bool TGGraph::IsEdge(const TStr&amp; ENm, PEdge&amp; Edge) const {
1399    int ENmToEIdP;
1400    if (ENmToEIdH.IsKey(ENm, ENmToEIdP)){
1401      Edge=GetEdge(ENmToEIdH[ENmToEIdP]); return true;}
1402    else {return false;}
1403  }
1404  bool TGGraph::FNextEdge(int&amp; EdgeP, PEdge&amp; Edge) const {
1405    if (EIdToEdgeH.FNextKeyId(EdgeP)){
1406      Edge=EIdToEdgeH[EdgeP]; return true;}
1407    else {return false;}
1408  }
1409  bool TGGraph::IsVrtxsEdge(
1410   const int&amp; VId1, const int&amp; VId2, const bool&amp; DirP, PEdge&amp; Edge) const {
1411    PVrtx Vrtx1=GetVrtx(VId1);
1412    PVrtx Vrtx2=GetVrtx(VId2);
1413    for (int EIdN=0; EIdN&lt;Vrtx1-&gt;GetOutEIds(); EIdN++){
1414      Edge=GetEdge(Vrtx1-&gt;GetOutEId(EIdN));
1415      if (VId2==Edge-&gt;GetOtherVId(Vrtx1)){return true;}
1416    }
1417    if (!DirP){
1418      for (int EIdN=0; EIdN&lt;Vrtx2-&gt;GetOutEIds(); EIdN++){
1419        Edge=GetEdge(Vrtx2-&gt;GetOutEId(EIdN));
1420        if (VId1==Edge-&gt;GetOtherVId(Vrtx2)){return true;}
1421      }
1422    }
1423    return false;
1424  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.cpp</div>
                </div>
                <div class="column column_space"><pre><code>372    double SumLen=0;
373    int EdgeP=FFirstEdge(); PEdge Edge;
374    while (FNextEdge(EdgeP, Edge)){
375      SumLen+=GetEdgeXYLen(Edge);
</pre></code></div>
                <div class="column column_space"><pre><code>646    double Ang=0;
647    int VrtxP=FFirstVrtx(); PVrtx Vrtx;
648    while (FNextVrtx(VrtxP, Vrtx)){
649      TGksPPoint PPoint(1, Ang);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    