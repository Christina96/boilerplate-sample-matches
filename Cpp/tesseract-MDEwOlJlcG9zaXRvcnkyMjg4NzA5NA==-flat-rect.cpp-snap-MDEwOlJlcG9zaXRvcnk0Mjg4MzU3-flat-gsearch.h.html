
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.595529920692141%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rect.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "rect.h"
5  #include "serialis.h" 
6  namespace tesseract {
7  TBOX::TBOX(           
8      const ICOORD pt1, 
9      const ICOORD pt2  
10  ) {
11    if (pt1.x() <= pt2.x()) {
12      if (pt1.y() <= pt2.y()) {
13        bot_left = pt1;
14        top_right = pt2;
15      } else {
16        bot_left = ICOORD(pt1.x(), pt2.y());
17        top_right = ICOORD(pt2.x(), pt1.y());
18      }
19    } else {
20      if (pt1.y() <= pt2.y()) {
21        bot_left = ICOORD(pt2.x(), pt1.y());
22        top_right = ICOORD(pt1.x(), pt2.y());
23      } else {
24        bot_left = pt2;
25        top_right = pt1;
26      }
27    }
28  }
29  bool TBOX::DeSerialize(TFile *f) {
30    return bot_left.DeSerialize(f) && top_right.DeSerialize(f);
31  }
32  bool TBOX::Serialize(TFile *f) const {
33    return bot_left.Serialize(f) && top_right.Serialize(f);
34  }
35  void TBOX::rotate_large(const FCOORD &vec) {
36    ICOORD top_left(bot_left.x(), top_right.y());
37    ICOORD bottom_right(top_right.x(), bot_left.y());
38    top_left.rotate(vec);
39    bottom_right.rotate(vec);
40    rotate(vec);
41    TBOX box2(top_left, bottom_right);
42    *this += box2;
43  }
44  TBOX TBOX::intersection( 
45      const TBOX &box) const {
46    TDimension left;
47    TDimension bottom;
48    TDimension right;
49    TDimension top;
50    if (overlap(box)) {
51      if (box.bot_left.x() > bot_left.x()) {
52        left = box.bot_left.x();
53      } else {
54        left = bot_left.x();
55      }
56      if (box.top_right.x() < top_right.x()) {
57        right = box.top_right.x();
58      } else {
59        right = top_right.x();
60      }
61      if (box.bot_left.y() > bot_left.y()) {
62        bottom = box.bot_left.y();
63      } else {
64        bottom = bot_left.y();
65      }
66      if (box.top_right.y() < top_right.y()) {
67        top = box.top_right.y();
68      } else {
69        top = top_right.y();
70      }
71    } else {
72      left = INT16_MAX;
73      bottom = INT16_MAX;
74      top = -INT16_MAX;
75      right = -INT16_MAX;
76    }
77    return TBOX(left, bottom, right, top);
78  }
79  TBOX TBOX::bounding_union( 
80      const TBOX &box) const {
81    ICOORD bl; 
82    ICOORD tr; 
83    if (box.bot_left.x() < bot_left.x()) {
84      bl.set_x(box.bot_left.x());
85    } else {
86      bl.set_x(bot_left.x());
87    }
88    if (box.top_right.x() > top_right.x()) {
89      tr.set_x(box.top_right.x());
90    } else {
91      tr.set_x(top_right.x());
92    }
93    if (box.bot_left.y() < bot_left.y()) {
94      bl.set_y(box.bot_left.y());
95    } else {
96      bl.set_y(bot_left.y());
97    }
98    if (box.top_right.y() > top_right.y()) {
99      tr.set_y(box.top_right.y());
100    } else {
101      tr.set_y(top_right.y());
102    }
103    return TBOX(bl, tr);
104  }
105  #ifndef GRAPHICS_DISABLED
106  void TBOX::plot(                    
107      ScrollView *fd,                 
108      ScrollView::Color fill_colour,  
109      ScrollView::Color border_colour 
110      ) const {
111    fd->Brush(fill_colour);
112    fd->Pen(border_colour);
113    plot(fd);
114  }
115  #endif
116  void TBOX::print_to_str(std::string &str) const {
117    str += "(" + std::to_string(left());
118    str += "," + std::to_string(bottom());
119    str += ")->(" + std::to_string(right());
120    str += "," + std::to_string(top());
121    str += ')';
122  }
123  bool TBOX::Serialize(FILE *fp) const {
124    if (!bot_left.Serialize(fp)) {
125      return false;
126    }
127    if (!top_right.Serialize(fp)) {
128      return false;
129    }
130    return true;
131  }
132  bool TBOX::DeSerialize(bool swap, FILE *fp) {
133    if (!bot_left.DeSerialize(swap, fp)) {
134      return false;
135    }
136    if (!top_right.DeSerialize(swap, fp)) {
137      return false;
138    }
139    return true;
140  }
141  TBOX &operator+=( 
142      TBOX &op1,    
143      const TBOX &op2) {
144    if (op2.bot_left.x() < op1.bot_left.x()) {
145      op1.bot_left.set_x(op2.bot_left.x());
146    }
147    if (op2.top_right.x() > op1.top_right.x()) {
148      op1.top_right.set_x(op2.top_right.x());
149    }
150    if (op2.bot_left.y() < op1.bot_left.y()) {
151      op1.bot_left.set_y(op2.bot_left.y());
152    }
153    if (op2.top_right.y() > op1.top_right.y()) {
154      op1.top_right.set_y(op2.top_right.y());
155    }
156    return op1;
157  }
158  TBOX &operator&=(TBOX &op1, const TBOX &op2) {
159    if (op1.overlap(op2)) {
160      if (op2.bot_left.x() > op1.bot_left.x()) {
161        op1.bot_left.set_x(op2.bot_left.x());
162      }
163      if (op2.top_right.x() < op1.top_right.x()) {
164        op1.top_right.set_x(op2.top_right.x());
165      }
166      if (op2.bot_left.y() > op1.bot_left.y()) {
167        op1.bot_left.set_y(op2.bot_left.y());
168      }
169      if (op2.top_right.y() < op1.top_right.y()) {
170        op1.top_right.set_y(op2.top_right.y());
171      }
172    } else {
173      op1.bot_left.set_x(INT16_MAX);
174      op1.bot_left.set_y(INT16_MAX);
175      op1.top_right.set_x(-INT16_MAX);
176      op1.top_right.set_y(-INT16_MAX);
177    }
178    return op1;
179  }
<span onclick='openModal()' class='match'>180  bool TBOX::x_almost_equal(const TBOX &box, int tolerance) const {
181    return (abs(left() - box.left()) <= tolerance && abs(right() - box.right()) <= tolerance);
182  }
183  bool TBOX::almost_equal(const TBOX &box, int tolerance) const {
</span>184    return (abs(left() - box.left()) <= tolerance && abs(right() - box.right()) <= tolerance &&
185            abs(top() - box.top()) <= tolerance && abs(bottom() - box.bottom()) <= tolerance);
186  }
187  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.h</h3>
            <pre><code>1  #ifndef SEARCH_H
2  #define SEARCH_H
3  class TGixConst {
4  public:
5      static TStr WdGixFNm;
6      static TStr WdGixDatFNm;
7      static TStr WdGixMDSFNm;
8      static TStr WdGixBsFNm;
9      static TStr TrGixFNm;
10      static TStr TrGixDatFNm;
11      static TStr TrGixDocBsFNm;
12      static TStr TrGixSentBsFNm;
13      static TStr TrGixTrAttrBsFNm;
14      static TStr MWdGixFNm;
15      static TStr MWdGixDatFNm;
16      static TStr MWdGixDocBsFNm;
17      static TStr MWdGixBsFNm;
18  };
19  #pragma pack(push, 1) 
20  ClassTV(TWdGixItem, TWdGixItemV)
21  private:
22      static int TitleBit;
23      static int NmObjBit;
24      static int AnchorBit;
25      static int EmphBit;
26  private:
27      uchar Seg;
28      uint Addr;
29      uchar Wgt; 
30      uchar WdPos; 
31      TB8Set FSet; 
32  public:
33      TWdGixItem() { }
34      TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
35          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP);
36      TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
37          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP,
38          const bool& AnchorP, const bool& EmphP);
39      TWdGixItem(TSIn& SIn);
40      void Save(TSOut& SOut) const;
41      bool operator==(const TWdGixItem& Item) const;
42      bool operator<(const TWdGixItem& Item) const;
43      uchar GetSeg() const { return Seg; }
44      uint GetAddr() const { return Addr; }
45      TBlobPt GetBlobPt() const { return TBlobPt(Seg, Addr); }
46      uchar GetWgt() const { return Wgt; }
47      uchar GetWdPos() const { return WdPos; }
48      bool IsTitle() const { return FSet.GetBit(TitleBit); }
49      bool IsNmObj() const { return FSet.GetBit(NmObjBit); }
50      bool IsAnchor() const { return FSet.GetBit(AnchorBit); }
51      bool IsEmph() const { return FSet.GetBit(EmphBit); }
52  };
53  #pragma pack(pop)
54  ClassTP(TWdGix, PWdGix)
55  private:
56      typedef TInt TWdGixKey;
57      typedef TGixItemSet<TWdGixKey, TWdGixItem> TWGixItemSet;
58      typedef TPt<TWGixItemSet> PWGixItemSet;
59      typedef TGix<TWdGixKey, TWdGixItem> TWGix;
60      typedef TPt<TWGix> PWGix;
61      typedef TGixExpItem<TWdGixKey, TWdGixItem> TWGixExpItem;
62      typedef TPt<TWGixExpItem> PWGixExpItem;
63  private:
64      TFAccess FAccess; 
65      TStr FPath; 
66      PStemmer Stemmer;
67      PSwSet SwSet;
68      TStrHash<TInt> WordH;
69      PWGix WGix;
70      TStrH TitleTagH;
71      TStrH NmObjTagH;
72      TStrH EmphTagH;
73      void LoadTags();
74  public:
75      TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize);
76      static PWdGix New(const TStr& FPath, const TFAccess& FAccess,
77          const int64& CacheSize) { return new TWdGix(FPath, FAccess, CacheSize); }
78      ~TWdGix();
79      void AddHtml(const TStr& DocStr, const TBlobPt& BlobPt, const uchar& Wgt = 0);
80      bool Search(const TStr& QueryStr, TWdGixItemV& ResItemV);
81  };
82  ClassTP(TWdGixMDS, PWdGixMDS)
83  private:
84      typedef TPair<TUCh, TUInt> TAddrPr;
85  private:
86      THash<TAddrPr, TUInt64> AddrPrToDateH;
87  public:
88      TWdGixMDS() { }
89      static PWdGixMDS New() { return new TWdGixMDS; }
90      TWdGixMDS(TSIn& SIn) { AddrPrToDateH.Load(SIn); }
91      static PWdGixMDS Load(TSIn& SIn) { return new TWdGixMDS(SIn); }
92      void Save(TSOut& SOut) const { AddrPrToDateH.Save(SOut); }
93      void AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime);
94      uint64 GetDateMSecs(const TBlobPt& DocBlobPt) const;
95      TTm GetDateTTm(const TBlobPt& DocBlobPt) const;
96      static PWdGixMDS LoadBin(const TStr& FNm) {
97          TFIn FIn(FNm); return new TWdGixMDS(FIn); }
98      void SaveBin(const TStr& FNm) const { TFOut FOut(FNm); Save(FOut); }
99  };
100  ClassTP(TWdGixRSet, PWdGixRSet)
101  private:
102      TStr QueryStr;
103      TInt AllDocs;
104      TInt Offset;
105      TStrV DocTitleV;
106      TStrV DocStrV;
107      TVec<TStrV> CatNmVV;
108      TTmV DateTimeV;
109  public:
110      TWdGixRSet(const TStr& _QueryStr, const int& _AllDocs, const int& _Offset):
111        QueryStr(_QueryStr), AllDocs(_AllDocs), Offset(_Offset) { };
112      static PWdGixRSet New(const TStr& QueryStr, const int& AllDocs,
113        const int& Offset) { return new TWdGixRSet(QueryStr, AllDocs, Offset); }
114      void AddDoc(const TStr& DocTitle, const TStr& DocStr,
115          const TStrV& CatNmV, const TTm& DateTime = TTm());
116      TStr GetQueryStr() const { return QueryStr; }
117      int GetAllDocs() const { return AllDocs; }
118      int GetOffset() const { return Offset; }
119      int GetDocs() const { return DocStrV.Len(); }
120      const TStr& GetDocTitle(const int DocN) const { return DocTitleV[DocN]; }
121      const TStr& GetDocStr(const int DocN) const { return DocStrV[DocN]; }
122      const TStrV& GetDocStrV() const { return DocStrV; }
123      const TStrV& GetDocCatNmV(const int DocN) const { return CatNmVV[DocN]; }
124      const TTm& GetDocDateTime(const int DocN) const { return DateTimeV[DocN]; }
125      void SortByDate(const bool& Asc = true);
126      void PrintRes(PNotify Notify = TStdNotify::New());
127      PBowDocBs GenBowDocBs() const;
128  };
129  class TWdGixRankFun {
130  public:
131      virtual ~TWdGixRankFun(){}
132      virtual double operator()(const TTm& DateTime, const int& Wgt,
133          const int& Count, const bool& TitleP, const bool& NmObjP,
134          const bool& AnchorP, const bool& EmphP) = 0;
135  };
136  class TWdGixRankFunTime: public TWdGixRankFun {
137  public:
138      TWdGixRankFunTime() { }
139      double operator()(const TTm& DateTime, const int& Wgt,
140          const int& Count, const bool& TitleP, const bool& NmObjP,
141          const bool& AnchorP, const bool& EmphP) {
142              return double(TTm::GetMSecsFromTm(DateTime));
143      }
144  };
145  class TWdGixRankFunWgt: public TWdGixRankFun {
146  public:
147      TWdGixRankFunWgt() { }
148      double operator()(const TTm& DateTime, const int& Wgt,
149          const int& Count, const bool& TitleP, const bool& NmObjP,
150          const bool& AnchorP, const bool& EmphP) {
151              return double(Wgt);
152      }
153  };
154  class TWdGixRankFunCount: public TWdGixRankFun {
155  public:
156      TWdGixRankFunCount() { }
157      double operator()(const TTm& DateTime, const int& Wgt,
158          const int& Count, const bool& TitleP, const bool& NmObjP,
159          const bool& AnchorP, const bool& EmphP) {
160              return double(Count);
161      }
162  };
163  class TWdGixRankFunRnd: public TWdGixRankFun {
164  private:
165      TRnd Rnd;
166  public:
167      TWdGixRankFunRnd(const int& Seed = 1): Rnd(Seed) { }
168      double operator()(const TTm& DateTime, const int& Wgt,
169          const int& Count, const bool& TitleP, const bool& NmObjP,
170          const bool& AnchorP, const bool& EmphP) {
171              return Rnd.GetUniDev();
172      }
173  };
174  typedef enum { wgbgNone, wgbgName, wgbgDate, wgbgDateTime } TWdGixBsGrouping;
175  ClassTP(TWdGixBs, PWdGixBs)
176  private:
177      typedef TKeyDat<TFlt, TWdGixItem> TWgtWdGixItemKd;
178      typedef TVec<TWgtWdGixItemKd> TWgtWdGixItemKdV;
179  private:
180      TFAccess FAccess; 
181      TStr FPath; 
182      PBlobBs DocBBs; 
183      PWdGixMDS WdGixMDS; 
184      PWdGix WdGix; 
185      void Filter(const TWgtWdGixItemKdV& InItemV,
186          const TWdGixBsGrouping& Grouping,
187          TWgtWdGixItemKdV& OutItemV);
188  public:
189      TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize);
190      static PWdGixBs New(const TStr& FPath, const TFAccess& FAccess,
191          const int64& CacheSize) { return new TWdGixBs(FPath, FAccess, CacheSize); }
192      ~TWdGixBs();
193      void AddDoc(const TStr& DocTitle, const TStr& DocStr,
194          const TStrV& CatNmV = TStrV(), const TTm& DateTime = TTm(),
195          const uchar& Wgt = 0);
196      void AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
197          const TStr& DocIndexStr, const TStrV& CatNmV = TStrV(),
198          const TTm& DateTime = TTm(), const uchar& Wgt = 0);
199      void GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
200          TStr& DocStr, TStrV& CatNmV) const;
201      TStr GetDocTitle(const TBlobPt& BlobPt) const;
202      TStr GetDocStr(const TBlobPt& BlobPt) const;
203      TStrV GetDocCatNmV(const TBlobPt& BlobPt) const;
204      PWdGixRSet SearchDoc(
205          const TStr& QueryStr, const TWdGixBsGrouping& Grouping &bsol;*= wgbgNone*/,
206          TWdGixRankFun& RankFun &bsol;*= TWdGixRankFunTime()*/, const int& Docs = -1,
207          const int& Offset = 0, const TTm& MnDate = TTm(), const TTm& MxDate = TTm());
208      void AddReuters(const TStr& XmlFNm);
209      void IndexReuters(const TStr& FPath);
210      void AddNmEn(const TStr& XmlFNm);
211      void IndexNmEnBs(const TStr& FNm);
212      void IndexNyt(const TStr& XmlFNm);
213  };
214  ClassTP(TSearchTopics, PSearchTopics)
215  public:
216      TStrV TopicV;
217      TStrV FrameV;
218      TFltVV TopicFrameFqVV;
219  public:
220      TSearchTopics(PWdGixRSet RSet, const int& Topics);
221      static PSearchTopics New(PWdGixRSet RSet, const int& Topics) {
222          return new TSearchTopics(RSet, Topics); }
223  };
224  ClassTV(TTrGixItem, TTrGixItemV)
225  private:
226      typedef struct {
227          unsigned int Subject:2;
228          unsigned int Predicat:2;
229          unsigned int Object:2;
230      } TTrGixItemMerge;
231      typedef struct {
232          unsigned int Type:4;
233          unsigned int Pos:4;
234          unsigned int Full:1;
235          unsigned int Stem:1;
236          unsigned int Hyper:4;
237      } TTrGixItemWdInfoBits;
238      typedef union {
239          TTrGixItemWdInfoBits Bits;
240          short Short;
241      } TTrGixItemWdInfo;
242  private:
243      TTrGixItemWdInfo GetWdInfo() const {
244          TTrGixItemWdInfo Info; Info.Short = WdInfo; return Info; }
245      void ClrMergeInfo() { &bsol;*MergeInfo.Subject = MergeInfo.Predicat = MergeInfo.Object = 0;*/ }
246  private:
247      uchar Seg;
248      uint Addr;
249      int SubjectId;
250      int PredicatId;
251      int ObjectId;
252      int WdId;
253      short WdInfo;
254  public:
255      TTrGixItem() { ClrMergeInfo(); }
256      TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId, const int& _PredicatId,
257          const int& _ObjectId, const int& _WdId, const uchar& Type, const uchar& Pos,
258          const bool& Full, const bool& Stem, const uchar& Hyper);
259      TTrGixItem(TSIn& SIn);
260      void Save(TSOut& SOut) const;
261      bool operator==(const TTrGixItem& Item) const;
262      bool operator<(const TTrGixItem& Item) const;
263      uchar GetSeg() const { return Seg; }
264      uint GetAddr() const { return Addr; }
265      TBlobPt GetBlobPt() const { return TBlobPt(Seg, Addr); }
266      int GetSubjectId() const { return SubjectId; }
267      int GetPredicatId() const { return PredicatId; }
268      int GetObjectId() const { return ObjectId; }
269      TIntTr GetIdTr() const { return TIntTr(SubjectId, PredicatId, ObjectId); }
270      void SetWordInfo(const uchar& Type, const uchar& Pos,
271          const bool& Full, const bool& Stem, const uchar& Hyper);
272      int GetWdId() const { return WdId; }
273      uchar GetWdType() const { return GetWdInfo().Bits.Type; }
274      uchar GetWdPos() const { return GetWdInfo().Bits.Pos; }
275      bool GetWdFull() const { return (GetWdInfo().Bits.Full == 1); }
276      bool GetWdStem() const { return (GetWdInfo().Bits.Stem == 1); }
277      uchar GetWdHyper() const { return GetWdInfo().Bits.Hyper; }
278  };
279  ClassTP(TTrGix, PTrGix)
280  private:
281      typedef TIntChPr TTrGixKey;
282      typedef TGixItemSet<TTrGixKey, TTrGixItem> TTGixItemSet;
283      typedef TPt<TTGixItemSet> PTGixItemSet;
284      typedef TGix<TTrGixKey, TTrGixItem> TTGix;
285      typedef TPt<TTGix> PTGix;
286      typedef TGixExpItem<TTrGixKey, TTrGixItem> TTGixExpItem;
287      typedef TPt<TTGixExpItem> PTGixExpItem;
288      static char SubjectType;
289      static char SubjectWdType;
290      static char SubjectAttrWdType;
291      static char SubjectStemType;
292      static char SubjectAttrStemType;
293      static char PredicatType;
294      static char PredicatWdType;
295      static char PredicatAttrWdType;
296      static char PredicatStemType;
297      static char PredicatAttrStemType;
298      static char ObjectType;
299      static char ObjectWdType;
300      static char ObjectAttrWdType;
301      static char ObjectStemType;
302      static char ObjectAttrStemType;
303  private:
304      TFAccess FAccess; 
305      TStr FPath; 
306      PStemmer Stemmer;
307      TStrHash<TInt> WordH;
308      PTGix Gix;
309      void AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
310          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt);
311      void AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
312          const int& SubjectWId, const int& PredicatWId, const int& ObjectWId,
313          const TBlobPt& BlobPt);
314      PTGixExpItem GetExactExp(const TStr& Str, const char& Type);
315      PTGixExpItem GetPartExp(const TStr& Str, const char& WdType, const char& StemType);
316  public:
317      TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize);
318      static PTrGix New(const TStr& FPath, const TFAccess& FAccess,
319          const int64& CacheSize) { return new TTrGix(FPath, FAccess, CacheSize); }
320      ~TTrGix();
321      int GetWordId(const TStr& WordStr, const bool& AddIfNotExistP);
322      TStr GetWordStr(const int& WId) const;
323      void GetWordIdV(const TStr& Str, TIntPrV& WordStemIdV,
324          const bool& AddIfNotExistP);
325      void GetWordIdV(const TStrV& WordStrV, TIntPrV& WordStemIdV,
326          const bool& AddIfNotExistP);
327      void AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
328          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
329          const TStrV& ObjectAttrV, const TBlobPt& BlobPt);
330      bool SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
331          const TStr& ObjectStr, TTrGixItemV& ResItemV);
332      bool SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
333          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP);
334  };
335  ClassTP(TTrGixRSet, PTrGixRSet)
336  private:
337      TStr SubjectStr;
338      TStr PredicatStr;
339      TStr ObjectStr;
340      TInt AllTrs;
341      TInt Offset;
342      TStrTrV TrStrV;
343      TVec<TBlobPtV> TrAttrBlobPtVV;
344  public:
345      TTrGixRSet(const TStr& _SubjectStr, const TStr& _PredicatStr,
346          const TStr& _ObjectStr, const int& _AllTrs, const int& _Offset):
347              SubjectStr(_SubjectStr), PredicatStr(_PredicatStr),
348              ObjectStr(_ObjectStr), AllTrs(_AllTrs), Offset(_Offset) { };
349      static PTrGixRSet New(const TStr& SubjectStr, const TStr& PredicatStr,
350          const TStr& ObjectStr, const int& AllTrs, const int& Offset) {
351              return new TTrGixRSet(SubjectStr, PredicatStr, ObjectStr, AllTrs, Offset); }
352      void AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV);
353      TStr GetSubjectStr() const { return SubjectStr; }
354      TStr GetPredicatStr() const { return PredicatStr; }
355      TStr GetObjectStr() const { return ObjectStr; }
356      int GetAllTrs() const { return AllTrs; }
357      int GetOffset() const { return Offset; }
358      bool Empty() const { return TrStrV.Empty(); }
359      int GetTrs() const { return TrStrV.Len(); }
360      int GetTrCount(const int& TrN) const { return TrAttrBlobPtVV[TrN].Len(); }
361      const TStrTr& GetTr(const int& TrN) const { return TrStrV[TrN]; }
362      const TStr& GetTrSubjectStr(const int& TrN) const { return TrStrV[TrN].Val1; }
363      const TStr& GetTrPredicatStr(const int& TrN) const { return TrStrV[TrN].Val2; }
364      const TStr& GetTrObjectStr(const int& TrN) const { return TrStrV[TrN].Val3; }
<span onclick='openModal()' class='match'>365      int GetTrAttrBlobPts(const int& TrN) const { return TrAttrBlobPtVV[TrN].Len(); }
366      TBlobPt GetBlobPt(const int& TrN, const int& AttrBlobPtN) const {
</span>367          return TrAttrBlobPtVV[TrN][AttrBlobPtN]; }
368      bool IsSubjectFree() const { return SubjectStr.Empty(); }
369      void GetSubjectV(TStrIntKdV& SubjectStrWgtV);
370      bool IsPredicatFree() const { return PredicatStr.Empty(); }
371      void GetPredicatV(TStrIntKdV& PredicatStrWgtV);
372      bool IsObjectFree() const { return ObjectStr.Empty(); }
373      void GetObjectV(TStrIntKdV& ObjectStrWgtV);
374      void PrintRes(const bool& PrintSentsP = false, PNotify Notify = TStdNotify::New()) const;
375  };
376  class TTrGixRankFun {
377  public:
378      virtual double operator()(const int& Count) = 0;
379  };
380  class TTrGixRankFunCount: public TTrGixRankFun {
381  public:
382      TTrGixRankFunCount() { }
383      double operator()(const int& Count) { return double(Count); }
384  };
385  ClassTP(TTrGixBs, PTrGixBs)
386  private:
387      TFAccess FAccess; 
388      TStr FPath; 
389      PBlobBs DocBBs; 
390      PBlobBs SentBBs; 
391      PBlobBs TrAttrBBs; 
392      PTrGix TrGix; 
393      void GetAttrV(PXmlTok XmlTok, TStrV& AttrV);
394  public:
395      TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize);
396      static PTrGixBs New(const TStr& FPath, const TFAccess& FAccess,
397          const int64& CacheSize) { return new TTrGixBs(FPath, FAccess, CacheSize); }
398      ~TTrGixBs();
399      TBlobPt AddDoc(const TStr& DocTitle, const TStr& DocStr = TStr(),
400          const TStrV& CatNmV = TStrV());
401      TBlobPt AddSent(const TStr& SentStr);
402      TBlobPt AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
403          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
404          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt);
405      void AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
406          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
407          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt);
408      void GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle,
409          TStr& DocStr, TStrV& CatNmV) const;
410      TStr GetDocTitle(const TBlobPt& DocBlobPt) const;
411      TStr GetDocStr(const TBlobPt& DocBlobPt) const;
412      TStrV GetDocCatNmV(const TBlobPt& DocBlobPt) const;
413      TStr GetSentStr(const TBlobPt& SentBlobPt);
414      void GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr, TStrV& SubjectAttrV,
415          TStr& PredicatStr, TStrV& PredicatAttrV, TStr& ObjectStr, TStrV& ObjectAttrV,
416          TBlobPt& SentBlobPt, TBlobPt& DocBlobPt);
417      PTrGixRSet SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
418          const TStr& ObjectStr, TTrGixRankFun& RankFun &bsol;*= TTrGixRankFunCount()*/,
419          const int& Docs = -1, const int& Offset = 0, const bool& ExactP = false);
420      void AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut);
421      void IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm = "", const int& MxTrs = -1);
422  };
423  ClassHdTP(TMWdGix, PMWdGix);
424  ClassTV(TMWdGixItem, TMWdGixItemV)
425  private:
426      uchar Seg;
427      uint Addr;
428      uchar WdFq; 
429      ushort DocWds; 
430      TFlt Wgt;
431  public:
432      TMWdGixItem() { }
433      TMWdGixItem(const TMWdGixItem& Item1, const TMWdGixItem& Item2):
434          Seg(Item1.Seg), Addr(Item1.Addr), WdFq(0), DocWds(0),
435          Wgt(Item1.GetWgt() + Item2.GetWgt()) { }
436      TMWdGixItem(const TBlobPt& BlobPt, const uchar& _WdFq, const uchar& _DocWds):
437          Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdFq(_WdFq), DocWds(_DocWds) { }
438      TMWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _WdFq,
439          const uchar& _DocWds): Seg(_Seg), Addr(_Addr), WdFq(_WdFq), DocWds(_DocWds) { }
440      TMWdGixItem(TSIn& SIn);
441      void Save(TSOut& SOut) const;
442      bool operator==(const TMWdGixItem& Item) const;
443      bool operator<(const TMWdGixItem& Item) const;
444      uchar GetSeg() const { return Seg; }
445      uint GetAddr() const { return Addr; }
446      TBlobPt GetBlobPt() const { return TBlobPt(Seg, Addr); }
447      uchar GetWdFq() const { return WdFq; }
448      ushort GetDocWds() const { return DocWds; }
449      void PutWgt(const double& _Wgt) { Wgt = _Wgt; }
450      double GetWgt() const { return Wgt; }
451  };
452  ClassTP(TMWdGixRankFun, PMWdGixRankFun)
453  public:
454      virtual ~TMWdGixRankFun(){}
455      virtual double WdRank(const int& WdFq, const int& DocWds,
456          const int& WdDocFq, const int& Docs, const double& AvgDocWds) const = 0;
457  };
458  class TMWdGixRankFunOkapiBM25 : public TMWdGixRankFun {
459  private:
460      TFlt k, b;
461  public:
462      TMWdGixRankFunOkapiBM25(const double& _k = 2.0, const double _b = 0.75): k(_k), b(_b) { }
463      static PMWdGixRankFun New(const double& k = 2.0, const double b = 0.75) {
464          return new TMWdGixRankFunOkapiBM25(k, b); }
465      double WdRank(const int& WdFq, const int& DocWds, const int& WdDocFq,
466              const int& Docs, const double& AvgDocWds) const {
467          if (WdDocFq == 0 || DocWds == 0) { return 0.0; }
468          const double IDF = log(double(Docs) / double(WdDocFq));
469          const double DocLenNm = AvgDocWds / double(DocWds);
470          return IDF * DocLenNm * double(WdFq);
471      }
472  };
473  class TMWdGixDefMerger {
474  private:
475      PMWdGix MWdGix;
476      PMWdGixRankFun RankFun;
477  public:
478      TMWdGixDefMerger(PMWdGix _MWdGix, const PMWdGixRankFun& _RankFun):
479        MWdGix(_MWdGix), RankFun(_RankFun) { }
480      void Union(TMWdGixItemV& MainV, const TMWdGixItemV& JoinV) const;
481      void Minus(const TMWdGixItemV& MainV, const TMWdGixItemV& JoinV,
482          TMWdGixItemV& ResV) const { MainV.Minus(JoinV, ResV); }
483      void Def(const TInt& Key, TMWdGixItemV& ItemV) const;
484  };
485  ClassTP(TMWdGix, PMWdGix)
486  private:
487      typedef TInt TMWdGixKey;
488      typedef TGixItemSet<TMWdGixKey, TMWdGixItem> TMWGixItemSet;
489      typedef TPt<TMWGixItemSet> PMWGixItemSet;
490      typedef TGix<TMWdGixKey, TMWdGixItem> TMWGix;
491      typedef TPt<TMWGix> PMWGix;
492      typedef TGixExpItem<TMWdGixKey, TMWdGixItem, TMWdGixDefMerger> TMWGixExpItem;
493      typedef TPt<TMWGixExpItem> PMWGixExpItem;
494  private:
495      TFAccess FAccess; 
496      TStr FPath; 
497      TStrHash<TInt> WordH;
498      TInt AllDocs;
499      TInt AllWords;
500      PMWGix MWGix;
501  public:
502      TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize);
503      static PMWdGix New(const TStr& FPath, const TFAccess& FAccess,
504          const int64& CacheSize) { return new TMWdGix(FPath, FAccess, CacheSize); }
505      ~TMWdGix();
506      int GetWdFq(const int& WId) const { return WordH[WId]; }
507      int GetAllDocs() const { return AllDocs; }
508      int GetAllWords() const { return AllWords; }
509      double GetAvgDocWds() const { return double(AllWords) / double(AllDocs); }
510      void AddHtml(const TStr& DocStr, const TBlobPt& BlobPt);
511      bool Search(const TStr& QueryStr, TMWdGixItemV& ResItemV,
512          const TMWdGixDefMerger& Merger);
513  };
514  ClassTP(TMWdGixRSet, PMWdGixRSet)
515  private:
516      TStr QueryStr;
517      TStr QueryLang;
518      TStrStrH LangQueryH;
519      TInt AllDocs;
520      TInt Offset;
521      TStrV DocTitleV;
522      TStrV DocStrV;
523      TStrV DocLangV;
524      TVec<TStrV> KeyWdVV;
525      TStr GetMainPara(const TStr& QueryStr, const TStr& FullStr);
526  public:
527      TMWdGixRSet(const TStr& _QueryStr, const TStr& _QueryLang,
528          const TStrStrH& _LangQueryH, const int& _AllDocs,
529          const int& _Offset): QueryStr(_QueryStr), QueryLang(_QueryLang),
530              LangQueryH(_LangQueryH), AllDocs(_AllDocs), Offset(_Offset) { };
531      static PMWdGixRSet New(const TStr& QueryStr, const TStr& QueryLang,
532          const TStrStrH& LangQueryH, const int& AllDocs, const int& Offset) {
533              return new TMWdGixRSet(QueryStr, QueryLang, LangQueryH, AllDocs, Offset); }
534      void AddDoc(const TStr& DocTitle, const TStr& DocStr,
535          const TStr& DocLang, const TStrV& KeyWdV);
536      TStr GetQueryStr() const { return QueryStr; }
537      TStr GetQueryLang() const { return QueryLang; }
538      int GetAllDocs() const { return AllDocs; }
539      int GetOffset() const { return Offset; }
540      int GetDocs() const { return DocStrV.Len(); }
541      const TStr& GetDocTitle(const int DocN) const { return DocTitleV[DocN]; }
542      const TStr& GetDocStr(const int DocN) const { return DocStrV[DocN]; }
543      const TStr& GetDocLang(const int DocN) const { return DocLangV[DocN]; }
544      const TStrV& GetDocKeyWdV(const int DocN) const { return KeyWdVV[DocN]; }
545      void PrintRes(PNotify Notify = TStdNotify::New());
546      TStr GetWsXml(const TStrPrStrH& EurovocH) const;
547  };
548  ClassTP(TMWdGixBs, PMWdGixBs)
549  private:
550      typedef TPair<TInt, TMWdGixItem> TMWdGixIntItemPr;
551      typedef TKeyDat<TFlt, TMWdGixIntItemPr> TWgtMWdGixIntItemKd;
552      typedef TVec<TWgtMWdGixIntItemKd> TWgtMWdGixIntItemKdV;
553  private:
554      TFAccess FAccess; 
555      TStr FPath; 
556      int64 CacheSize; 
557      PBlobBs DocBBs; 
558      THash<TStr, PMWdGix> LangMWdGixH; 
559      PAlignPairBs AlignPairBs; 
560      TAlignPairMapCcar AlignPairMap; 
561      void InitGixs(const TFAccess& GixFAccess) {
562          int LangId = AlignPairBs->FFirstLangId();
563          while (AlignPairBs->FNextLangId(LangId)) {
564              const TStr& Lang = AlignPairBs->GetLang(LangId);
565              LangMWdGixH.AddDat(Lang) =
566                  TMWdGix::New(FPath + "/" + Lang, GixFAccess, CacheSize);
567          }
568      }
569  public:
570      TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize);
571      static PMWdGixBs New(const TStr& FPath, const TFAccess& FAccess,
572          const int64& CacheSize) { return new TMWdGixBs(FPath, FAccess, CacheSize); }
573      ~TMWdGixBs();
574      void AddDoc(const TStr& DocTitle, const TStr& DocStr,
575          const TStr& DocLang, const TStrV& KeyWdV);
576      void GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
577          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const;
578      PMWdGixRSet SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
579          const TStrV& TargetLangV, const int& Docs &bsol;*= 10*/, const int& Offset &bsol;*= 0*/,
580          PMWdGixRankFun& RankFun &bsol;*= TMWdGixRankFunOkapiBM25::New()*/);
581      bool IsLang(const TStr& Lang) const { return AlignPairBs->IsLang(Lang); }
582      void AddAcquis(const TStr& XmlFNm, const TStr& Lang);
583      void IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
584          const int& MxDocs, const int64& IndexCacheSize);
585  };
586  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rect.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.h</div>
                </div>
                <div class="column column_space"><pre><code>180  bool TBOX::x_almost_equal(const TBOX &box, int tolerance) const {
181    return (abs(left() - box.left()) <= tolerance && abs(right() - box.right()) <= tolerance);
182  }
183  bool TBOX::almost_equal(const TBOX &box, int tolerance) const {
</pre></code></div>
                <div class="column column_space"><pre><code>365      int GetTrAttrBlobPts(const int& TrN) const { return TrAttrBlobPtVV[TrN].Len(); }
366      TBlobPt GetBlobPt(const int& TrN, const int& AttrBlobPtN) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    