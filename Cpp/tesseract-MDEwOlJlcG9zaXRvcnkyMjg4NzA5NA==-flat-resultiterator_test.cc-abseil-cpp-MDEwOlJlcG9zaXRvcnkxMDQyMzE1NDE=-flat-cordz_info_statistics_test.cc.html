
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.2123893805309733%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</h3>
            <pre><code>1  #include <allheaders.h>
2  #include <tesseract/baseapi.h>
3  #include <tesseract/resultiterator.h>
4  #include <string>
5  #include "scrollview.h"
6  #include "include_gunit.h"
7  #include "log.h" 
8  namespace tesseract {
9  class ResultIteratorTest : public testing::Test {
10  protected:
11    std::string TestDataNameToPath(const std::string &name) {
12      return file::JoinPath(TESTING_DIR, name);
13    }
14    std::string TessdataPath() {
15      return file::JoinPath(TESSDATA_DIR, "");
16    }
17    std::string OutputNameToPath(const std::string &name) {
18      file::MakeTmpdir();
19      return file::JoinPath(FLAGS_test_tmpdir, name);
20    }
21    ResultIteratorTest() {
22      src_pix_ = nullptr;
23    }
24    ~ResultIteratorTest() override = default;
25    void SetImage(const char *filename) {
26      src_pix_ = pixRead(TestDataNameToPath(filename).c_str());
27      api_.Init(TessdataPath().c_str(), "eng", tesseract::OEM_TESSERACT_ONLY);
28      api_.SetPageSegMode(tesseract::PSM_AUTO);
29      api_.SetImage(src_pix_);
30      src_pix_.destroy();
31      src_pix_ = api_.GetInputImage();
32    }
33    void VerifyRebuild(int max_diff, PageIteratorLevel level, PageIterator *it) {
34      it->Begin();
35      int width = pixGetWidth(src_pix_);
36      int height = pixGetHeight(src_pix_);
37      int depth = pixGetDepth(src_pix_);
38      Image pix = pixCreate(width, height, depth);
39      EXPECT_TRUE(depth == 1 || depth == 8);
40      if (depth == 8) {
41        pixSetAll(pix);
42      }
43      do {
44        int left, top, right, bottom;
45        PageIteratorLevel im_level = level;
46        if (!it->BoundingBox(level, &left, &top, &right, &bottom)) {
47          im_level = tesseract::RIL_BLOCK;
48          EXPECT_TRUE(it->BoundingBox(im_level, &left, &top, &right, &bottom));
49        }
50        LOG(INFO) << "BBox: [L:" << left << ", T:" << top << ", R:" << right << ", B:" << bottom
51                  << "]"
52                  << "\n";
53        Image block_pix;
54        if (depth == 1) {
55          block_pix = it->GetBinaryImage(im_level);
56          pixRasterop(pix, left, top, right - left, bottom - top, PIX_SRC ^ PIX_DST, block_pix, 0, 0);
57        } else {
58          block_pix = it->GetImage(im_level, 2, src_pix_, &left, &top);
59          pixRasterop(pix, left, top, pixGetWidth(block_pix), pixGetHeight(block_pix),
60                      PIX_SRC & PIX_DST, block_pix, 0, 0);
61        }
62        CHECK(block_pix != nullptr);
63        block_pix.destroy();
64      } while (it->Next(level));
65      pixRasterop(pix, 0, 0, width, height, PIX_SRC ^ PIX_DST, src_pix_, 0, 0);
66      if (depth == 8) {
67        Image binary_pix = pixThresholdToBinary(pix, 128);
68        pix.destroy();
69        pixInvert(binary_pix, binary_pix);
70        pix = binary_pix;
71      }
72      l_int32 pixcount;
73      pixCountPixels(pix, &pixcount, nullptr);
74      if (pixcount > max_diff) {
75        std::string outfile = OutputNameToPath("failedxor.png");
76        LOG(INFO) << "outfile = " << outfile << "\n";
77        pixWrite(outfile.c_str(), pix, IFF_PNG);
78      }
79      pix.destroy();
80      LOG(INFO) << "At level " << level << ": pix diff = " << pixcount << "\n";
81      EXPECT_LE(pixcount, max_diff);
82    }
83    void VerifyIteratorText(const std::string &truth, PageIteratorLevel level, ResultIterator *it) {
84      LOG(INFO) << "Text Test Level " << level << "\n";
85      it->Begin();
86      std::string result;
87      do {
88        char *text = it->GetUTF8Text(level);
89        result += text;
90        delete[] text;
<span onclick='openModal()' class='match'>91        if ((level == tesseract::RIL_WORD || level == tesseract::RIL_SYMBOL) &&
92            it->IsAtFinalElement(tesseract::RIL_WORD, level)) {
93          if (it->IsAtFinalElement(tesseract::RIL_TEXTLINE, level)) {
94            result += '\n';
95          } else {
96            result += ' ';
97          }
</span>98          if (it->IsAtFinalElement(tesseract::RIL_PARA, level) &&
99              !(it->IsAtFinalElement(tesseract::RIL_BLOCK, level))) {
100            result += '\n';
101          }
102        }
103      } while (it->Next(level));
104      EXPECT_STREQ(truth.c_str(), result.c_str()) << "Rebuild failed at Text Level " << level;
105    }
106    void VerifyRebuilds(int block_limit, int para_limit, int line_limit, int word_limit,
107                        int symbol_limit, PageIterator *it, PageIteratorLevel maxlevel=tesseract::RIL_SYMBOL) {
108      VerifyRebuild(block_limit, tesseract::RIL_BLOCK, it);
109      VerifyRebuild(para_limit, tesseract::RIL_PARA, it);
110      VerifyRebuild(line_limit, tesseract::RIL_TEXTLINE, it);
111      VerifyRebuild(word_limit, tesseract::RIL_WORD, it);
112      if (maxlevel == tesseract::RIL_SYMBOL) {
113        VerifyRebuild(symbol_limit, maxlevel, it);
114      }
115    }
116    void VerifyAllText(const std::string &truth, ResultIterator *it) {
117      VerifyIteratorText(truth, tesseract::RIL_BLOCK, it);
118      VerifyIteratorText(truth, tesseract::RIL_PARA, it);
119      VerifyIteratorText(truth, tesseract::RIL_TEXTLINE, it);
120      VerifyIteratorText(truth, tesseract::RIL_WORD, it);
121      VerifyIteratorText(truth, tesseract::RIL_SYMBOL, it);
122    }
123    void ExpectTextlineReadingOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
124                                    int num_words, int *expected_reading_order,
125                                    int num_reading_order_entries) const {
126      std::vector<StrongScriptDirection> gv_word_dirs;
127      for (int i = 0; i < num_words; i++) {
128        gv_word_dirs.push_back(word_dirs[i]);
129      }
130      std::vector<int> calculated_order;
131      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &calculated_order);
132      std::vector<int> correct_order(expected_reading_order,
133                                     expected_reading_order + num_reading_order_entries);
134      EXPECT_EQ(correct_order, calculated_order);
135    }
136    void VerifySaneTextlineOrder(bool in_ltr_context, const StrongScriptDirection *word_dirs,
137                                 int num_words) const {
138      std::vector<StrongScriptDirection> gv_word_dirs;
139      for (int i = 0; i < num_words; i++) {
140        gv_word_dirs.push_back(word_dirs[i]);
141      }
142      std::vector<int> output;
143      ResultIterator::CalculateTextlineOrder(in_ltr_context, gv_word_dirs, &output);
144      ASSERT_GE(output.size(), num_words);
145      std::vector<int> output_copy(output);
146      std::sort(output_copy.begin(), output_copy.end());
147      bool sane = true;
148      unsigned j = 0;
149      while (j < output_copy.size() && output_copy[j] < 0) {
150        j++;
151      }
152      for (int i = 0; i < num_words; i++, j++) {
153        if (output_copy[j] != i) {
154          sane = false;
155          break;
156        }
157      }
158      if (j != output_copy.size()) {
159        sane = false;
160      }
161      if (!sane) {
162        std::vector<int> empty;
163        EXPECT_EQ(output, empty) << " permutation of 0.." << num_words - 1 << " not found in "
164                                 << (in_ltr_context ? "ltr" : "rtl") << " context.";
165      }
166    }
167    Image src_pix_; 
168    std::string ocr_text_;
169    tesseract::TessBaseAPI api_;
170  };
171  TEST_F(ResultIteratorTest, EasyTest) {
172    SetImage("phototest.tif");
173    PageIterator *p_it = api_.AnalyseLayout();
174    EXPECT_FALSE(p_it == nullptr);
175    EXPECT_TRUE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
176    EXPECT_FALSE(p_it->Next(tesseract::RIL_BLOCK));
177    EXPECT_FALSE(p_it->IsAtBeginningOf(tesseract::RIL_BLOCK));
178    LOG(INFO) << "Verifying image rebuilds 1 (pageiterator)"
179              << "\n";
180    VerifyRebuilds(10, 10, 0, 0, 0, p_it);
181    delete p_it;
182    char *result = api_.GetUTF8Text();
183    ocr_text_ = result;
184    delete[] result;
185    ResultIterator *r_it = api_.GetIterator();
186    LOG(INFO) << "Verifying image rebuilds 2a (resultiterator)"
187              << "\n";
188    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
189    LOG(INFO) << "Verifying text rebuilds 1 (resultiterator)"
190              << "\n";
191    VerifyAllText(ocr_text_, r_it);
192    LOG(INFO) << "Verifying image rebuilds 2b (resultiterator)"
193              << "\n";
194    VerifyRebuilds(8, 8, 0, 0, 40, r_it, tesseract::RIL_WORD);
195    r_it->Begin();
196    int x1, y1, x2, y2;
197    r_it->Baseline(tesseract::RIL_TEXTLINE, &x1, &y1, &x2, &y2);
198    LOG(INFO) << "Baseline ("
199       << x1 << ',' << y1 << ")->(" << x2 << ',' << y2 << ")\n";
200    EXPECT_GE(x2, x1 + 400);
201    int x3 = 200 - x1;
202    int y3 = 116 - y1;
203    x2 -= x1;
204    y2 -= y1;
205    int product = x2 * y3 - x3 * y2;
206    EXPECT_LE(abs(product), x2);
207    do {
208      float confidence = r_it->Confidence(tesseract::RIL_WORD);
209  #ifndef DISABLED_LEGACY_ENGINE
210      int pointsize, font_id;
211      bool bold, italic, underlined, monospace, serif, smallcaps;
212      const char *font = r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif,
213                                                  &smallcaps, &pointsize, &font_id);
214      EXPECT_GE(confidence, 80.0f);
215  #endif
216      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
217  #ifdef DISABLED_LEGACY_ENGINE
218      LOG(INFO) << "Word " << word_str << ", conf " << confidence << "\n";
219  #else
220      LOG(INFO) << "Word " << word_str << " in font " << font
221        << ", id " << font_id << ", size " << pointsize
222        << ", conf " << confidence << "\n";
223  #endif 
224      delete[] word_str;
225  #ifndef DISABLED_LEGACY_ENGINE
226      EXPECT_FALSE(bold);
227      EXPECT_FALSE(italic);
228      EXPECT_FALSE(underlined);
229      EXPECT_FALSE(monospace);
230      EXPECT_FALSE(serif);
231      EXPECT_GE(pointsize, 11.16 - 1.50);
232      EXPECT_LE(pointsize, 11.16 + 1.50);
233  #endif 
234    } while (r_it->Next(tesseract::RIL_WORD));
235    delete r_it;
236  }
237  TEST_F(ResultIteratorTest, ComplexTest) {
238    SetImage("8087_054.3B.tif");
239    PageIterator *it = api_.AnalyseLayout();
240    EXPECT_FALSE(it == nullptr);
241    VerifyRebuilds(2073, 2073, 2080, 2081, 2090, it);
242    delete it;
243  }
244  TEST_F(ResultIteratorTest, GreyTest) {
245    SetImage("8087_054.3G.tif");
246    PageIterator *it = api_.AnalyseLayout();
247    EXPECT_FALSE(it == nullptr);
248    VerifyRebuilds(600, 600, 600, 600, 600, it);
249    delete it;
250  }
251  TEST_F(ResultIteratorTest, SmallCapDropCapTest) {
252  #ifdef DISABLED_LEGACY_ENGINE
253    GTEST_SKIP();
254  #else
255    SetImage("8071_093.3B.tif");
256    char *result = api_.GetUTF8Text();
257    delete[] result;
258    ResultIterator *r_it = api_.GetIterator();
259    int found_dropcaps = 0;
260    int found_smallcaps = 0;
261    int false_positives = 0;
262    do {
263      bool bold, italic, underlined, monospace, serif, smallcaps;
264      int pointsize, font_id;
265      r_it->WordFontAttributes(&bold, &italic, &underlined, &monospace, &serif, &smallcaps,
266                               &pointsize, &font_id);
267      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
268      if (word_str != nullptr) {
269        LOG(INFO) << "Word " << word_str
270          << " is " << (smallcaps ? "SMALLCAPS" : "Normal") << "\n";
271        if (r_it->SymbolIsDropcap()) {
272          ++found_dropcaps;
273        }
274        if (strcmp(word_str, "SHE") == 0 || strcmp(word_str, "MOPED") == 0 ||
275            strcmp(word_str, "RALPH") == 0 || strcmp(word_str, "KINNEY") == 0 || 
276            strcmp(word_str, "BENNETT") == 0) {
277          EXPECT_TRUE(smallcaps) << word_str;
278          ++found_smallcaps;
279        } else {
280          if (smallcaps) {
281            ++false_positives;
282          }
283        }
284        ResultIterator s_it(*r_it);
285        while (s_it.Next(tesseract::RIL_SYMBOL) && !s_it.IsAtBeginningOf(tesseract::RIL_WORD)) {
286          if (s_it.SymbolIsDropcap()) {
287            char *sym_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
288            LOG(ERROR) << "Symbol " << sym_str << " of word " << word_str << " is dropcap";
289            delete[] sym_str;
290          }
291          EXPECT_FALSE(s_it.SymbolIsDropcap());
292        }
293        delete[] word_str;
294      }
295    } while (r_it->Next(tesseract::RIL_WORD));
296    delete r_it;
297    EXPECT_EQ(1, found_dropcaps);
298    EXPECT_GE(4, found_smallcaps);
299    EXPECT_LE(false_positives, 3);
300  #endif 
301  }
302  #if 0
303  TEST_F(ResultIteratorTest, SubSuperTest) {
304    SetImage("0146_281.3B.tif");
305    char* result = api_.GetUTF8Text();
306    delete [] result;
307    ResultIterator* r_it = api_.GetIterator();
308    const char kAllowedSupers[] = "O0123456789-";
309    int found_subs = 0;
310    int found_supers = 0;
311    int found_normal = 0;
312    do {
313      if (r_it->SymbolIsSubscript()) {
314        ++found_subs;
315      } else if (r_it->SymbolIsSuperscript()) {
316        result = r_it->GetUTF8Text(tesseract::RIL_SYMBOL);
317        if (strchr(kAllowedSupers, result[0]) == nullptr) {
318          char* word = r_it->GetUTF8Text(tesseract::RIL_WORD);
319          LOG(ERROR) << "Char " << result << " in word " << word << " is unexpected super!";
320          delete [] word;
321          EXPECT_TRUE(strchr(kAllowedSupers, result[0]) != nullptr);
322        }
323        delete [] result;
324        ++found_supers;
325      } else {
326        ++found_normal;
327      }
328    } while (r_it->Next(tesseract::RIL_SYMBOL));
329    delete r_it;
330    LOG(INFO) << "Subs = " << found_subs << ", supers= " << found_supers
331      << ", normal = " << found_normal << "\n";
332    EXPECT_GE(found_subs, 25);
333    EXPECT_GE(found_supers, 25);
334    EXPECT_GE(found_normal, 1350);
335  }
336  #endif
337  static const StrongScriptDirection dL = DIR_LEFT_TO_RIGHT;
338  static const StrongScriptDirection dR = DIR_RIGHT_TO_LEFT;
339  static const StrongScriptDirection dN = DIR_NEUTRAL;
340  TEST_F(ResultIteratorTest, DualStartTextlineOrderTest) {
341    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dR, dR, dR};
342    int reading_order_rtl_context[] = {7, 6, 5, 4, ResultIterator::kMinorRunStart,
343                                       0, 1, 2, 3, ResultIterator::kMinorRunEnd};
344    int reading_order_ltr_context[] = {
345        0, 1, 2, 3, 4, ResultIterator::kMinorRunStart, 7, 6, 5, ResultIterator::kMinorRunEnd};
346    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
347                               countof(reading_order_ltr_context));
348    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
349                               countof(reading_order_rtl_context));
350  }
351  TEST_F(ResultIteratorTest, LeftwardTextlineOrderTest) {
352    const StrongScriptDirection word_dirs[] = {dL, dL, dN, dL, dN, dN, dL, dL};
353    int reading_order_ltr_context[] = {0, 1, 2, 3, 4, 5, 6, 7};
354    int reading_order_rtl_context[] = {ResultIterator::kMinorRunStart, 0, 1, 2, 3, 4, 5, 6, 7,
355                                       ResultIterator::kMinorRunEnd};
356    ExpectTextlineReadingOrder(true, word_dirs, countof(word_dirs), reading_order_ltr_context,
357                               countof(reading_order_ltr_context));
358    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
359                               countof(reading_order_rtl_context));
360  }
361  TEST_F(ResultIteratorTest, RightwardTextlineOrderTest) {
362    const StrongScriptDirection word_dirs[] = {dR, dR, dN, dR, dN, dN, dR, dR};
363    int reading_order_rtl_context[] = {7, 6, 5, 4, 3, 2, 1, 0};
364    ExpectTextlineReadingOrder(false, word_dirs, countof(word_dirs), reading_order_rtl_context,
365                               countof(reading_order_rtl_context));
366  }
367  TEST_F(ResultIteratorTest, TextlineOrderSanityCheck) {
368    const int kNumWords(7);
369    const int kNumCombos = 1 << (2 * kNumWords); 
370    StrongScriptDirection word_dirs[kNumWords];
371    for (int i = 0; i < kNumCombos; i++) {
372      int tmp = i;
373      for (auto &word_dir : word_dirs) {
374        word_dir = static_cast<StrongScriptDirection>(tmp % 4);
375        tmp = tmp / 4;
376      }
377      VerifySaneTextlineOrder(true, word_dirs, kNumWords);
378      VerifySaneTextlineOrder(false, word_dirs, kNumWords);
379    }
380  }
381  TEST_F(ResultIteratorTest, DISABLED_NonNullChoicesTest) {
382    SetImage("5318c4b679264.jpg");
383    char *result = api_.GetUTF8Text();
384    delete[] result;
385    ResultIterator *r_it = api_.GetIterator();
386    do {
387      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
388      if (word_str != nullptr) {
389        LOG(INFO) << "Word " << word_str << ":\n";
390        ResultIterator s_it = *r_it;
391        do {
392          tesseract::ChoiceIterator c_it(s_it);
393          do {
394            const char *char_str = c_it.GetUTF8Text();
395            if (char_str == nullptr) {
396              LOG(INFO) << "Null char choice"
397                        << "\n";
398            } else {
399              LOG(INFO) << "Char choice " << char_str << "\n";
400            }
401            CHECK(char_str != nullptr);
402          } while (c_it.Next());
403        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
404                 s_it.Next(tesseract::RIL_SYMBOL));
405        delete[] word_str;
406      }
407    } while (r_it->Next(tesseract::RIL_WORD));
408    delete r_it;
409  }
410  TEST_F(ResultIteratorTest, NonNullConfidencesTest) {
411    SetImage("trainingitalline.tif");
412    api_.SetPageSegMode(tesseract::PSM_SINGLE_BLOCK);
413    char *result = api_.GetUTF8Text();
414    delete[] result;
415    ResultIterator *r_it = api_.GetIterator();
416    do {
417      char *word_str = r_it->GetUTF8Text(tesseract::RIL_WORD);
418      if (word_str != nullptr) {
419        EXPECT_FALSE(r_it->Empty(tesseract::RIL_WORD));
420        EXPECT_FALSE(r_it->Empty(tesseract::RIL_SYMBOL));
421        ResultIterator s_it = *r_it;
422        do {
423          const char *char_str = s_it.GetUTF8Text(tesseract::RIL_SYMBOL);
424          CHECK(char_str != nullptr);
425          float confidence = s_it.Confidence(tesseract::RIL_SYMBOL);
426          LOG(INFO) << "Char " << char_str << " has confidence " << confidence << "\n";
427          delete[] char_str;
428        } while (!s_it.IsAtFinalElement(tesseract::RIL_WORD, tesseract::RIL_SYMBOL) &&
429                 s_it.Next(tesseract::RIL_SYMBOL));
430        delete[] word_str;
431      } else {
432        LOG(INFO) << "Empty word found"
433                  << "\n";
434      }
435    } while (r_it->Next(tesseract::RIL_WORD));
436    delete r_it;
437  }
438  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_statistics_test.cc</h3>
            <pre><code>1  #include <iostream>
2  #include <random>
3  #include <vector>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/base/config.h"
7  #include "absl/crc/internal/crc_cord_state.h"
8  #include "absl/strings/cord.h"
9  #include "absl/strings/internal/cord_internal.h"
10  #include "absl/strings/internal/cord_rep_btree.h"
11  #include "absl/strings/internal/cord_rep_crc.h"
12  #include "absl/strings/internal/cord_rep_flat.h"
13  #include "absl/strings/internal/cord_rep_ring.h"
14  #include "absl/strings/internal/cordz_info.h"
15  #include "absl/strings/internal/cordz_sample_token.h"
16  #include "absl/strings/internal/cordz_statistics.h"
17  #include "absl/strings/internal/cordz_update_scope.h"
18  #include "absl/strings/internal/cordz_update_tracker.h"
19  #include "absl/synchronization/internal/thread_pool.h"
20  #include "absl/synchronization/notification.h"
21  namespace absl {
22  ABSL_NAMESPACE_BEGIN
23  namespace cord_internal {
24  inline void PrintTo(const CordzStatistics& stats, std::ostream* s) {
25    if (s) *s << "CordzStatistics{...}";
26  }
27  namespace {
28  using ::testing::Ge;
29  CordRepFlat* Flat(size_t size) {
30    assert(size >= kMinFlatSize);
31    size = RoundUpForTag(size);
32    CordRepFlat* flat = CordRepFlat::New(size - kFlatOverhead);
33    flat->tag = AllocatedSizeToTag(size);
34    flat->length = size - kFlatOverhead;
35    return flat;
36  }
37  CordRepExternal* External(size_t length = 512) {
38    return static_cast<CordRepExternal*>(
39        NewExternalRep(absl::string_view("", length), [](absl::string_view) {}));
40  }
41  CordRepSubstring* Substring(CordRep* rep) {
42    auto* substring = new CordRepSubstring;
43    substring->length = rep->length - 1;
44    substring->tag = SUBSTRING;
45    substring->child = rep;
46    return substring;
47  }
48  struct RefHelper {
49    std::vector<CordRep*> refs;
50    ~RefHelper() {
51      for (CordRep* rep : refs) {
52        CordRep::Unref(rep);
53      }
54    }
55    template <typename T>
56    T* NeedsUnref(T* rep) {
57      refs.push_back(rep);
58      return rep;
59    }
60    template <typename T>
61    T* Ref(T* rep, size_t n = 1) {
62      while (n--) {
63        NeedsUnref(CordRep::Ref(rep));
64      }
65      return rep;
66    }
67  };
68  template <typename T>
69  size_t SizeOf(const T* rep) {
70    return sizeof(T);
71  }
72  template <>
73  size_t SizeOf(const CordRepFlat* rep) {
74    return rep->AllocatedSize();
75  }
76  template <>
77  size_t SizeOf(const CordRepExternal* rep) {
78    return sizeof(CordRepExternalImpl<intptr_t>) + rep->length;
79  }
80  template <>
81  size_t SizeOf(const CordRepRing* rep) {
82    return CordRepRing::AllocSize(rep->capacity());
83  }
84  double FairShareImpl(CordRep* rep, size_t ref) {
85    double self = 0.0, children = 0.0;
86    ref *= rep->refcount.Get();
87    if (rep->tag >= FLAT) {
88      self = SizeOf(rep->flat());
89    } else if (rep->tag == EXTERNAL) {
90      self = SizeOf(rep->external());
91    } else if (rep->tag == SUBSTRING) {
92      self = SizeOf(rep->substring());
93      children = FairShareImpl(rep->substring()->child, ref);
94    } else if (rep->tag == BTREE) {
95      self = SizeOf(rep->btree());
96      for (CordRep*edge : rep->btree()->Edges()) {
97        children += FairShareImpl(edge, ref);
98      }
99    } else if (rep->tag == RING) {
100      self = SizeOf(rep->ring());
101      rep->ring()->ForEach([&](CordRepRing::index_type i) {
102        self += FairShareImpl(rep->ring()->entry_child(i), 1);
103      });
104    } else {
105      assert(false);
106    }
107    return self / ref + children;
108  }
109  size_t FairShare(CordRep* rep, size_t ref = 1) {
110    return static_cast<size_t>(FairShareImpl(rep, ref));
111  }
112  CordzStatistics SampleCord(CordRep* rep) {
113    InlineData cord(rep);
114    CordzInfo::TrackCord(cord, CordzUpdateTracker::kUnknown);
115    CordzStatistics stats = cord.cordz_info()->GetCordzStatistics();
116    cord.cordz_info()->Untrack();
117    return stats;
118  }
119  MATCHER_P(EqStatistics, stats, "Statistics equal expected values") {
120    bool ok = true;
121  #define STATS_MATCHER_EXPECT_EQ(member)                              \
122    if (stats.member != arg.member) {                                  \
123      *result_listener << "\n    stats." << #member                    \
124                       << ": actual = " << arg.member << ", expected " \
125                       << stats.member;                                \
126      ok = false;                                                      \
127    }
128    STATS_MATCHER_EXPECT_EQ(size);
129    STATS_MATCHER_EXPECT_EQ(node_count);
130    STATS_MATCHER_EXPECT_EQ(node_counts.flat);
131    STATS_MATCHER_EXPECT_EQ(node_counts.flat_64);
132    STATS_MATCHER_EXPECT_EQ(node_counts.flat_128);
133    STATS_MATCHER_EXPECT_EQ(node_counts.flat_256);
134    STATS_MATCHER_EXPECT_EQ(node_counts.flat_512);
135    STATS_MATCHER_EXPECT_EQ(node_counts.flat_1k);
136    STATS_MATCHER_EXPECT_EQ(node_counts.external);
137    STATS_MATCHER_EXPECT_EQ(node_counts.concat);
138    STATS_MATCHER_EXPECT_EQ(node_counts.substring);
139    STATS_MATCHER_EXPECT_EQ(node_counts.ring);
140    STATS_MATCHER_EXPECT_EQ(node_counts.btree);
141    STATS_MATCHER_EXPECT_EQ(estimated_memory_usage);
142    STATS_MATCHER_EXPECT_EQ(estimated_fair_share_memory_usage);
143  #undef STATS_MATCHER_EXPECT_EQ
144    return ok;
145  }
146  TEST(CordzInfoStatisticsTest, Flat) {
147    RefHelper ref;
148    auto* flat = ref.NeedsUnref(Flat(512));
149    CordzStatistics expected;
150    expected.size = flat->length;
151    expected.estimated_memory_usage = SizeOf(flat);
152    expected.estimated_fair_share_memory_usage = expected.estimated_memory_usage;
153    expected.node_count = 1;
154    expected.node_counts.flat = 1;
155    expected.node_counts.flat_512 = 1;
156    EXPECT_THAT(SampleCord(flat), EqStatistics(expected));
157  }
158  TEST(CordzInfoStatisticsTest, SharedFlat) {
159    RefHelper ref;
160    auto* flat = ref.Ref(ref.NeedsUnref(Flat(64)));
161    CordzStatistics expected;
162    expected.size = flat->length;
163    expected.estimated_memory_usage = SizeOf(flat);
164    expected.estimated_fair_share_memory_usage = SizeOf(flat) / 2;
165    expected.node_count = 1;
166    expected.node_counts.flat = 1;
167    expected.node_counts.flat_64 = 1;
168    EXPECT_THAT(SampleCord(flat), EqStatistics(expected));
169  }
170  TEST(CordzInfoStatisticsTest, External) {
171    RefHelper ref;
172    auto* external = ref.NeedsUnref(External());
173    CordzStatistics expected;
174    expected.size = external->length;
175    expected.estimated_memory_usage = SizeOf(external);
176    expected.estimated_fair_share_memory_usage = SizeOf(external);
177    expected.node_count = 1;
178    expected.node_counts.external = 1;
179    EXPECT_THAT(SampleCord(external), EqStatistics(expected));
180  }
181  TEST(CordzInfoStatisticsTest, SharedExternal) {
182    RefHelper ref;
183    auto* external = ref.Ref(ref.NeedsUnref(External()));
184    CordzStatistics expected;
185    expected.size = external->length;
186    expected.estimated_memory_usage = SizeOf(external);
187    expected.estimated_fair_share_memory_usage = SizeOf(external) / 2;
188    expected.node_count = 1;
189    expected.node_counts.external = 1;
190    EXPECT_THAT(SampleCord(external), EqStatistics(expected));
191  }
192  TEST(CordzInfoStatisticsTest, Substring) {
193    RefHelper ref;
194    auto* flat = Flat(1024);
195    auto* substring = ref.NeedsUnref(Substring(flat));
196    CordzStatistics expected;
197    expected.size = substring->length;
198    expected.estimated_memory_usage = SizeOf(substring) + SizeOf(flat);
199    expected.estimated_fair_share_memory_usage = expected.estimated_memory_usage;
200    expected.node_count = 2;
201    expected.node_counts.flat = 1;
202    expected.node_counts.flat_1k = 1;
203    expected.node_counts.substring = 1;
204    EXPECT_THAT(SampleCord(substring), EqStatistics(expected));
205  }
206  TEST(CordzInfoStatisticsTest, SharedSubstring) {
207    RefHelper ref;
208    auto* flat = ref.Ref(Flat(511), 2);
209    auto* substring = ref.Ref(ref.NeedsUnref(Substring(flat)));
210    CordzStatistics expected;
211    expected.size = substring->length;
212    expected.estimated_memory_usage = SizeOf(flat) + SizeOf(substring);
213    expected.estimated_fair_share_memory_usage =
214        SizeOf(substring) / 2 + SizeOf(flat) / 6;
215    expected.node_count = 2;
216    expected.node_counts.flat = 1;
217    expected.node_counts.flat_512 = 1;
218    expected.node_counts.substring = 1;
219    EXPECT_THAT(SampleCord(substring), EqStatistics(expected));
220  }
221  TEST(CordzInfoStatisticsTest, Ring) {
222    RefHelper ref;
223    auto* flat1 = Flat(240);
224    auto* flat2 = Flat(2000);
225    auto* flat3 = Flat(70);
226    auto* external = External(3000);
227    CordRepRing* ring = CordRepRing::Create(flat1);
228    ring = CordRepRing::Append(ring, flat2);
229    ring = CordRepRing::Append(ring, flat3);
230    ring = ref.NeedsUnref(CordRepRing::Append(ring, external));
231    CordzStatistics expected;
232    expected.size = ring->length;
233    expected.estimated_memory_usage = SizeOf(ring) + SizeOf(flat1) +
234                                      SizeOf(flat2) + SizeOf(flat3) +
235                                      SizeOf(external);
236    expected.estimated_fair_share_memory_usage = expected.estimated_memory_usage;
237    expected.node_count = 5;
238    expected.node_counts.flat = 3;
239    expected.node_counts.flat_128 = 1;
240    expected.node_counts.flat_256 = 1;
241    expected.node_counts.external = 1;
242    expected.node_counts.ring = 1;
243    EXPECT_THAT(SampleCord(ring), EqStatistics(expected));
244  }
245  TEST(CordzInfoStatisticsTest, SharedSubstringRing) {
246    RefHelper ref;
247    auto* flat1 = ref.Ref(Flat(240));
248    auto* flat2 = Flat(200);
249    auto* flat3 = Flat(70);
250    auto* external = ref.Ref(External(3000), 5);
251    CordRepRing* ring = CordRepRing::Create(flat1);
252    ring = CordRepRing::Append(ring, flat2);
253    ring = CordRepRing::Append(ring, flat3);
254    ring = ref.Ref(CordRepRing::Append(ring, external), 4);
255    auto* substring = ref.Ref(ref.NeedsUnref(Substring(ring)));
256    CordzStatistics expected;
257    expected.size = substring->length;
258    expected.estimated_memory_usage = SizeOf(ring) + SizeOf(flat1) +
259                                      SizeOf(flat2) + SizeOf(flat3) +
260                                      SizeOf(external) + SizeOf(substring);
261    expected.estimated_fair_share_memory_usage = FairShare(substring);
262    expected.node_count = 6;
263    expected.node_counts.flat = 3;
264    expected.node_counts.flat_128 = 1;
265    expected.node_counts.flat_256 = 2;
266    expected.node_counts.external = 1;
267    expected.node_counts.ring = 1;
268    expected.node_counts.substring = 1;
269    EXPECT_THAT(SampleCord(substring), EqStatistics(expected));
270  }
271  TEST(CordzInfoStatisticsTest, BtreeLeaf) {
272    ASSERT_THAT(CordRepBtree::kMaxCapacity, Ge(3u));
273    RefHelper ref;
274    auto* flat1 = Flat(2000);
275    auto* flat2 = Flat(200);
276    auto* substr = Substring(flat2);
277    auto* external = External(3000);
278    CordRepBtree* tree = CordRepBtree::Create(flat1);
279    tree = CordRepBtree::Append(tree, substr);
280    tree = CordRepBtree::Append(tree, external);
281    size_t flat3_count = CordRepBtree::kMaxCapacity - 3;
282    size_t flat3_size = 0;
283    for (size_t i = 0; i < flat3_count; ++i) {
284      auto* flat3 = Flat(70);
285      flat3_size += SizeOf(flat3);
286      tree = CordRepBtree::Append(tree, flat3);
287    }
288    ref.NeedsUnref(tree);
289    CordzStatistics expected;
290    expected.size = tree->length;
291    expected.estimated_memory_usage = SizeOf(tree) + SizeOf(flat1) +
292                                      SizeOf(flat2) + SizeOf(substr) +
293                                      flat3_size + SizeOf(external);
294    expected.estimated_fair_share_memory_usage = expected.estimated_memory_usage;
295    expected.node_count = 1 + 3 + 1 + flat3_count;
296    expected.node_counts.flat = 2 + flat3_count;
297    expected.node_counts.flat_128 = flat3_count;
298    expected.node_counts.flat_256 = 1;
299    expected.node_counts.external = 1;
300    expected.node_counts.substring = 1;
301    expected.node_counts.btree = 1;
302    EXPECT_THAT(SampleCord(tree), EqStatistics(expected));
303  }
304  TEST(CordzInfoStatisticsTest, BtreeNodeShared) {
305    RefHelper ref;
306    static constexpr int leaf_count = 3;
307    const size_t flat3_count = CordRepBtree::kMaxCapacity - 3;
308    ASSERT_THAT(flat3_count, Ge(0u));
309    CordRepBtree* tree = nullptr;
310    size_t mem_size = 0;
311    for (int i = 0; i < leaf_count; ++i) {
312      auto* flat1 = ref.Ref(Flat(2000), 9);
313      mem_size += SizeOf(flat1);
314      if (i == 0) {
315        tree = CordRepBtree::Create(flat1);
316      } else {
317        tree = CordRepBtree::Append(tree, flat1);
318      }
319      auto* flat2 = Flat(200);
320      auto* substr = Substring(flat2);
321      mem_size += SizeOf(flat2) + SizeOf(substr);
322      tree = CordRepBtree::Append(tree, substr);
323      auto* external = External(30);
324      mem_size += SizeOf(external);
325      tree = CordRepBtree::Append(tree, external);
326      for (size_t i = 0; i < flat3_count; ++i) {
327        auto* flat3 = Flat(70);
328        mem_size += SizeOf(flat3);
329        tree = CordRepBtree::Append(tree, flat3);
330      }
331      if (i == 0) {
332        mem_size += SizeOf(tree);
333      } else {
334        mem_size += SizeOf(tree->Edges().back()->btree());
335      }
336    }
337    ref.NeedsUnref(tree);
338    ref.Ref(tree, 1);
339    ref.Ref(tree->Edges().front(), 4);
340    CordzStatistics expected;
341    expected.size = tree->length;
342    expected.estimated_memory_usage = SizeOf(tree) + mem_size;
343    expected.estimated_fair_share_memory_usage = FairShare(tree);
344    expected.node_count = 1 + leaf_count * (1 + 3 + 1 + flat3_count);
345    expected.node_counts.flat = leaf_count * (2 + flat3_count);
346    expected.node_counts.flat_128 = leaf_count * flat3_count;
347    expected.node_counts.flat_256 = leaf_count;
348    expected.node_counts.external = leaf_count;
349    expected.node_counts.substring = leaf_count;
350    expected.node_counts.btree = 1 + leaf_count;
351    EXPECT_THAT(SampleCord(tree), EqStatistics(expected));
352  }
353  TEST(CordzInfoStatisticsTest, Crc) {
354    RefHelper ref;
355    auto* left = Flat(1000);
356    auto* crc =
357        ref.NeedsUnref(CordRepCrc::New(left, crc_internal::CrcCordState()));
358    CordzStatistics expected;
359    expected.size = left->length;
360    expected.estimated_memory_usage = SizeOf(crc) + SizeOf(left);
361    expected.estimated_fair_share_memory_usage = expected.estimated_memory_usage;
362    expected.node_count = 2;
363    expected.node_counts.flat = 1;
364    expected.node_counts.flat_1k = 1;
365    expected.node_counts.crc = 1;
366    EXPECT_THAT(SampleCord(crc), EqStatistics(expected));
367  }
368  TEST(CordzInfoStatisticsTest, ThreadSafety) {
369    Notification stop;
370    static constexpr int kNumThreads = 8;
371    int64_t sampled_node_count = 0;
372    {
373      absl::synchronization_internal::ThreadPool pool(kNumThreads);
374      pool.Schedule([&]() {
375        while (!stop.HasBeenNotified()) {
376          absl::SleepFor(absl::Microseconds(10));
377          CordzSampleToken token;
378          for (const CordzInfo& cord_info : token) {
379            CordzStatistics stats = cord_info.GetCordzStatistics();
380            sampled_node_count += stats.node_count;
381          }
382        }
383      });
384      for (int i = 0; i < kNumThreads; ++i) {
385        pool.Schedule([&]() {
386          InlineData cords[2];
387          std::minstd_rand gen;
388          std::uniform_int_distribution<int> coin_toss(0, 1);
389          while (!stop.HasBeenNotified()) {
390            for (InlineData& cord : cords) {
391              if (coin_toss(gen) != 0) {
392                if (cord.is_tree()) {
393                  if (coin_toss(gen) != 0) {
394                    CordzInfo::MaybeUntrackCord(cord.cordz_info());
395                  } else {
396                    CordzUpdateScope scope(cord.cordz_info(),
397                                           CordzUpdateTracker::kUnknown);
398                    scope.SetCordRep(nullptr);
399                  }
400                  CordRep::Unref(cord.as_tree());
401                  cord.set_inline_size(0);
402                } else {
403                  CordRep* rep = Flat(256);
<span onclick='openModal()' class='match'>404                  if (coin_toss(gen) != 0) {
405                    if (coin_toss(gen) != 0) {
406                      rep = CordRepRing::Create(rep);
407                    } else {
408                      rep = CordRepBtree::Create(rep);
409                    }
</span>410                  }
411                  cord.make_tree(rep);
412                  if (coin_toss(gen) != 0) {
413                    CordzInfo::TrackCord(cord, CordzUpdateTracker::kUnknown);
414                  }
415                }
416              }
417            }
418          }
419          for (InlineData& cord : cords) {
420            if (cord.is_tree()) {
421              CordzInfo::MaybeUntrackCord(cord.cordz_info());
422              CordRep::Unref(cord.as_tree());
423            }
424          }
425        });
426      }
427      absl::SleepFor(absl::Seconds(1));
428      stop.Notify();
429    }
430    std::cout << "Sampled " << sampled_node_count << " nodes\n";
431  }
432  }  
433  }  
434  ABSL_NAMESPACE_END
435  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-resultiterator_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cordz_info_statistics_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>91        if ((level == tesseract::RIL_WORD || level == tesseract::RIL_SYMBOL) &&
92            it->IsAtFinalElement(tesseract::RIL_WORD, level)) {
93          if (it->IsAtFinalElement(tesseract::RIL_TEXTLINE, level)) {
94            result += '\n';
95          } else {
96            result += ' ';
97          }
</pre></code></div>
                <div class="column column_space"><pre><code>404                  if (coin_toss(gen) != 0) {
405                    if (coin_toss(gen) != 0) {
406                      rep = CordRepRing::Create(rep);
407                    } else {
408                      rep = CordRepBtree::Create(rep);
409                    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    