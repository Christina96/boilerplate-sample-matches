<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_FncKuhnTucker.cpp &amp; ibex_FncActiveCtrs.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_FncKuhnTucker.cpp &amp; ibex_FncActiveCtrs.cpp
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_FncKuhnTucker.cpp (4.5614033%)<th>ibex_FncActiveCtrs.cpp (3.5519125%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(126-139)<td><a href="#" name="0">(193-200)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_FncKuhnTucker.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdlib.h&gt;
2 #include &lt;cassert&gt;
3 #include "ibex_FncKuhnTucker.h"
4 using namespace std;
5 namespace ibex {
6 FncKuhnTucker::FncKuhnTucker(const NormalizedSystem&amp; sys, Function&amp; _df, Function** _dg, const IntervalVector&amp; current_box, const BitSet* _active) :
7 								Fnc(1,1), sys(sys), n(sys.nb_var), nb_mult(0), 								act(NULL), df(_df), nothing(BitSet::empty(1)) {
8 	assert(sys.goal);
9 	try {
10 		if (_active)
11 			act = new FncActiveCtrs(sys,current_box,*_active,true);
12 		else
13 			act = new FncActiveCtrs(sys,current_box,true);
14 		dg.resize(act-&gt;active_ctr.size());
15 		unsigned int i=0; 		for (BitSet::const_iterator c=act-&gt;active_ctr.begin(); c!=act-&gt;active_ctr.end(); ++c) {
16 			dg.set_ref(i++,*_dg[c]);
17 		}
18 		(int&amp;) nb_mult = act-&gt;image_dim() +1 ; 
19 	} catch (FncActiveCtrs::NothingActive&amp;) {
20 		(int&amp;) nb_mult = 1 ; 	}
21 	(int&amp;) _nb_var = n + nb_mult;
22 	(Dim&amp;) _image_dim = Dim(_nb_var, 1);
23 }
24 FncKuhnTucker::~FncKuhnTucker() {
25 	if (act) delete act;
26 }
27 IntervalVector FncKuhnTucker::multiplier_domain() const {
28 	IntervalVector box(nb_mult, Interval(0,1));
29 	if (act &amp;&amp; !act-&gt;eq.empty())
30 		box.put(act-&gt;ineq.size()+1,IntervalVector(act-&gt;eq.size(),Interval(-1,1)));
31 	return box;
32 }
33 IntervalVector FncKuhnTucker::eval_vector(const IntervalVector&amp; x_lambda, const BitSet&amp; components) const {
34 	if (components.size()!=n+nb_mult) {
35 		not_implemented("FncKuhnTucker: 'eval_vector' for selected components");
36 	}
37 	IntervalVector res(n+nb_mult);
38 	IntervalVector x=x_lambda.subvector(0,n-1);
39 	int lambda0=n;	
40 	int l=lambda0; 
41 	IntervalVector grad=x_lambda[l] * df.eval_vector(x); 
42 	res[lambda0] = x_lambda[lambda0] - 1.0; 
43 	if (!act) {
44 		res.put(0,grad);
45 		return res;
46 	}
47 	l++;
48 	IntervalVector gx=((Fnc*) act)-&gt;eval_vector(x);
49 	IntervalMatrix dgx=((Fnc*) act)-&gt;jacobian(x);
50 	for (BitSet::const_iterator i=act-&gt;ineq.begin(); i!=act-&gt;ineq.end(); ++i) {
51 		grad +=  x_lambda[l] * dgx[l-n-1];
52 		res[l] = x_lambda[l] * gx[l-n-1]; 		res[lambda0] += x_lambda[l];
53 		l++;
54 	}
55 	for (BitSet::const_iterator i=act-&gt;eq.begin(); i!=act-&gt;eq.end(); ++i) {
56 		grad +=  x_lambda[l] * dgx[l-n-1];
57 		res[l] = gx[l-n-1];
58 		res[lambda0] += sqr(x_lambda[l]);
59 		l++;
60 	}
61 	for (BitSet::const_iterator v=act-&gt;active_left_bound.begin(); v!=act-&gt;active_left_bound.end(); ++v) {
62 		grad[v] -= x_lambda[l];
63 		res[l] = x_lambda[l] * gx[l-n-1];
64 		res[lambda0] += x_lambda[l];
65 		l++;
66 	}
67 <a name="0"></a>	for (BitSet::const_iterator v=act-&gt;active_right_bound.begin(); v!=act-&gt;active_right_bound.end(); ++v) {
68 		grad[v] += x_lambda[l];
69 		res[l] = x_lambda[l] * gx[l-n-1];
70 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		res[lambda0] += x_lambda[l];
71 		l++;
72 	}
73 	assert(l==nb_mult+n);
74 	res.put(0, grad);
75 	return res;
76 }
77 void FncKuhnTucker::jacobian(const IntervalVector&amp; x_lambda, IntervalMatrix&amp; J, const BitSet&amp; components, int v) const {
78 	if (components.size()!=n+nb_mult) {</b></font>
79 		not_implemented("FncKuhnTucker: 'jacobian' for selected components");
80 	}
81 	IntervalVector x=x_lambda.subvector(0,n-1);
82 	int lambda0=n;	
83 	int l=lambda0; 
84 	IntervalMatrix hessian(n,n);
85 	if (v==-1 || v&lt;n) hessian = x_lambda[l] * df.jacobian(x,v); 	if (v==-1 || v==l) J.put(0, l, df.eval_vector(x), false);
86 	if (v==-1) {
87 		J[lambda0].put(0,Vector::zeros(n));
88 		J[lambda0][lambda0]=1.0;
89 	} else if (v&lt;n)
90 		J[lambda0][v] = 0;
91 	else if (v==lambda0)
92 		J[lambda0][lambda0]=1.0;
93 	if (!act) {
94 		if (v==-1 || v&lt;n)
95 			J.put(0,0,hessian);
96 		return;
97 	}
98 	l++;
99 	IntervalVector gx;
100 	if ((v==-1 || v&gt;=n) &amp;&amp; !act-&gt;ineq.empty())
101 		gx = sys.f_ctrs.eval_vector(x,act-&gt;active_ctr.compose(act-&gt;ineq));
102 	IntervalVector dgi(n); 
103 	for (BitSet::const_iterator i=act-&gt;ineq.begin(); i!=act-&gt;ineq.end(); ++i) {
104 		if (v==-1) {
105 			hessian += x_lambda[l] * dg[i].jacobian(x);
106 			dgi=dg[i].eval_vector(x);
107 			J.put(0, l, dgi, false);
108 			J.put(l, 0, (x_lambda[l]*dgi), true);
109 			J.put(l, n, Vector::zeros(nb_mult), true);
110 			J[l][l] = gx[l-n-1]; 			J[lambda0][l] = 1.0;
111 		} else if (v==l) {
112 			J.put(0, l, dg[i].eval_vector(x), false);
113 			J[l][l] = gx[l-n-1];
114 			J[lambda0][l] = 1.0;
115 		} else if (v&lt;n) {
116 			hessian += x_lambda[l] * dg[i].jacobian(x,v);
117 			J[l][v] = x_lambda[l]*dg[i].eval(v,x);
118 		} else {
119 			J[l][v] = 0;
120 		}
121 		l++;
122 	}
123 	for (BitSet::const_iterator i=act-&gt;eq.begin(); i!=act-&gt;eq.end(); ++i) {
124 		if (v==-1) {
125 			hessian += x_lambda[l] * dg[i].jacobian(x,v);
126 			dgi=dg[i].eval_vector(x);
127 			J.put(0, l, dgi, false);
128 			J.put(l, 0, dgi, true);
129 			J.put(l, n, Vector::zeros(nb_mult), true);
130 			J[lambda0][l] = 2*x_lambda[l];
131 		} else if (v==l) {
132 			J.put(0, l, dg[i].eval_vector(x), false);
133 			J[l][l] = 0;
134 			J[lambda0][l] = 2*x_lambda[l];
135 		} else if (v&lt;n) {
136 			hessian += x_lambda[l] * dg[i].jacobian(x,v);
137 			J[l][v] = dg[i].eval(v,x);
138 		} else {
139 			J[l][v] = 0;
140 		}
141 		l++;
142 	}
143 	for (BitSet::const_iterator i=act-&gt;active_left_bound.begin(); i!=act-&gt;active_left_bound.end(); ++i) {
144 		if (v==-1) {
145 			dgi=Vector::zeros(n);
146 			dgi[i]=-1.0;
147 			J.put(0, l, dgi, false);
148 			J.put(l, 0, (x_lambda[l]*dgi), true);
149 			J.put(l, n, Vector::zeros(nb_mult), true);
150 			J[l][l] = -x[i]+sys.box[i].lb();
151 			J[lambda0][l] = 1.0;
152 		} else if (v==l) {
153 			dgi=Vector::zeros(n);
154 			dgi[i]=-1.0;
155 			J.put(0, l, dgi, false);
156 			J[l][l] = -x[i]+sys.box[i].lb();
157 			J[lambda0][l] = 1.0;
158 		} else if (v&lt;n) {
159 			J[l][v] = (v==i? -x_lambda[l] : 0);
160 		} else {
161 			J[l][v] = 0;
162 		}
163 		l++;
164 	}
165 	for (BitSet::const_iterator i=act-&gt;active_right_bound.begin(); i!=act-&gt;active_right_bound.end(); ++i) {
166 		if (v==-1) {
167 			dgi=Vector::zeros(n);
168 			dgi[i]=1.0;
169 			J.put(0, l, dgi, false);
170 			J.put(l, 0, (x_lambda[l]*dgi), true);
171 			J.put(l, n, Vector::zeros(nb_mult), true);
172 			J[l][l] = x[i]-sys.box[i].ub();
173 			J[lambda0][l] = 1.0;
174 		} else if (v==l) {
175 			dgi=Vector::zeros(n);
176 			dgi[i]=1.0;
177 			J.put(0, l, dgi, false);
178 			J[l][l] = x[i]-sys.box[i].ub();
179 			J[lambda0][l] = 1.0;
180 		} else if (v&lt;n) {
181 			J[l][v] = (v==i? x_lambda[l] : 0);
182 		} else {
183 			J[l][v] = 0;
184 		}
185 		l++;
186 	}
187 	assert(l==nb_mult+n);
188 	if (v==-1 || v&lt;n)
189 		J.put(0,0,hessian);
190 }
} </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_FncActiveCtrs.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_FncActiveCtrs.h"
2 #include "ibex_Linear.h"
3 using namespace std;
4 namespace ibex {
5 FncActiveCtrs::FncActiveCtrs(const System&amp; sys, const IntervalVector&amp; box, const BitSet* _active, bool ineq_first, const Function* df) :
6 								Fnc(sys.nb_var,1), 								sys(sys), ineq_first(ineq_first),
7 								active_ctr(_active? *_active : sys.active_ctrs(box)),
8 								eq(BitSet::empty(sys.f_ctrs.image_dim())),
9 								ineq(BitSet::empty(sys.f_ctrs.image_dim())),
10 								active_left_bound(BitSet::empty(sys.nb_var)),
11 								active_right_bound(BitSet::empty(sys.nb_var)),
12 								LICQ(true 								fact(NULL) {
13 	int m=0; 
14 	{
15 		unsigned int i=0; 		for (BitSet::const_iterator c=active_ctr.begin(); c!=active_ctr.end(); ++c, ++i) {
16 			if (sys.ops[c]==EQ) ((BitSet&amp;) eq).add(i);
17 			else ((BitSet&amp;) ineq).add(i);
18 		}
19 	}
20 	if (!active_ctr.empty())
21 		fact=new FncProj(sys.f_ctrs,active_ctr,df);
22 	m+=active_ctr.size();
23 	for (int j=0; j&lt;sys.box.size(); j++) {
24 		if (box[j].lb() &lt;= sys.box[j].lb()) {
25 			((BitSet&amp;) active_left_bound).add(j);
26 			m++;
27 		}
28 		if (box[j].ub() &gt;= sys.box[j].ub()) {
29 			if (active_left_bound[j]) LICQ=false;
30 			((BitSet&amp;) active_right_bound).add(j);
31 			m++;
32 		}
33 	}
34 	if (m==0) {
35 		if (fact) delete fact; 		throw NothingActive(); 	}
36 	(Dim&amp;) _image_dim = Dim(m, 1);
37 	if (m &gt; sys.nb_var)
38 		LICQ = false;
39 }
40 FncActiveCtrs::FncActiveCtrs(const System&amp; sys, const Vector&amp; pt, double activation_threshold, bool ineq_first, const Function* df) :
41 		Fnc(sys.nb_var,1), 		sys(sys), ineq_first(ineq_first),
42 		active_ctr(BitSet::empty(sys.f_ctrs.image_dim())),
43 		eq(BitSet::empty(sys.f_ctrs.image_dim())),
44 		ineq(BitSet::empty(sys.f_ctrs.image_dim())),
45 		active_left_bound(BitSet::empty(sys.nb_var)),
46 		active_right_bound(BitSet::empty(sys.nb_var)),
47 		LICQ(true 
48 	int m=0; 
49 	if (sys.nb_ctr&gt;0) {
50 		for (int i=0; i&lt;sys.f_ctrs.image_dim(); i++) {
51 			if (sys.ops[i]==EQ) {
52 				((BitSet&amp;) active_ctr).add(i);
53 				((BitSet&amp;) eq).add(m++);
54 			}
55 			else {
56 				if (sys.f_ctrs.eval(i,pt).mag() &lt; activation_threshold) {
57 					((BitSet&amp;) active_ctr).add(i);
58 					((BitSet&amp;) ineq).add(m++);
59 				}
60 			}
61 		}
62 	}
63 	if (!active_ctr.empty())
64 		fact=new FncProj(sys.f_ctrs,active_ctr,df);
65 	for (int j=0; j&lt;sys.box.size(); j++) {
66 		if (pt[j]-activation_threshold &lt;= sys.box[j].lb()) {
67 			((BitSet&amp;) active_left_bound).add(j);
68 			m++;
69 		}
70 		if (pt[j]+activation_threshold &gt;= sys.box[j].ub()) {
71 			if (active_left_bound[j]) LICQ=false;
72 			((BitSet&amp;) active_right_bound).add(j);
73 			m++;
74 		}
75 	}
76 	if (m==0) {
77 		if (fact) delete fact; 		throw NothingActive(); 	}
78 	(Dim&amp;) _image_dim = Dim(m, 1);
79 	if (m &gt; sys.nb_var)
80 		LICQ = false;
81 }
82 FncActiveCtrs::~FncActiveCtrs() {
83 	if (fact)
84 		delete fact;
85 }
86 IntervalVector FncActiveCtrs::eval_vector(const IntervalVector&amp; box, const BitSet&amp; components) const {
87 	if (active_ctr.empty() &amp;&amp; active_left_bound.empty() &amp;&amp; active_right_bound.empty())
88 		ibex_error("[FncActivation] nothing active.");
89 		//return IntervalVector(); 
90 	IntervalVector res(components.size());
91 	BitSet fcomp=BitSet::empty(active_ctr.empty()? 1 : active_ctr.size());
92 	BitSet lcomp=BitSet::empty(active_left_bound.empty()? 1 : active_left_bound.size());
93 	BitSet rcomp=BitSet::empty(active_right_bound.empty()? 1 : active_right_bound.size());
94 	BitSet::const_iterator i=components.begin();
95 	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()) {
96 		fcomp.add(i);
97 		++i;
98 	}
99 	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()+active_left_bound.size()) {
100 		lcomp.add(i-active_ctr.size());
101 		++i;
102 	}
103 	while (i!=components.end()) {
104 		assert(i&lt;active_ctr.size()+active_left_bound.size()+active_right_bound.size());
105 		rcomp.add(i-active_ctr.size()-active_left_bound.size());
106 		++i;
107 	}
108 	int j=0; 
109 	if (!fcomp.empty()) {
110 		if (ineq_first) {
111 			IntervalVector fcompeval=fact-&gt;eval_vector(box,fcomp);
112 			if (!ineq.empty()) res.put(j,fcompeval[ineq]);
113 			if (!eq.empty())   res.put(j+ineq.size(),fcompeval[eq]);
114 		} else {
115 			res.put(j,fact-&gt;eval_vector(box,fcomp));
116 		}
117 	}
118 	j+=fcomp.size();
119 	BitSet l=active_left_bound.compose(lcomp);
120 	for (BitSet::const_iterator v=l.begin(); v!=l.end(); ++v) {
121 		res[j++]=sys.box[v].lb()-box[v];
122 	}
123 <a name="0"></a>	BitSet r=active_right_bound.compose(rcomp);
124 	for (BitSet::const_iterator v=r.begin(); v!=r.end(); ++v) {
125 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		res[j++]=box[v]-sys.box[v].ub();
126 	}
127 	return res;
128 }
129 void FncActiveCtrs::jacobian(const IntervalVector&amp; box, IntervalMatrix&amp; J, const BitSet&amp; components, int v) const {
130 	if (active_ctr.empty() &amp;&amp; active_left_bound.empty() &amp;&amp; active_right_bound.empty())</b></font>
131 		ibex_error("[FncActivation] nothing active_ctr.");
132 	BitSet fcomp=BitSet::empty(active_ctr.empty()? 1 : active_ctr.size());
133 	BitSet lcomp=BitSet::empty(active_left_bound.empty()? 1 : active_left_bound.size());
134 	BitSet rcomp=BitSet::empty(active_right_bound.empty()? 1 : active_right_bound.size());
135 	BitSet::const_iterator i=components.begin();
136 	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()) {
137 		fcomp.add(i);
138 		++i;
139 	}
140 	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()+active_left_bound.size()) {
141 		lcomp.add(i-active_ctr.size());
142 		++i;
143 	}
144 	while (i!=components.end()) {
145 		assert(i&lt;active_ctr.size()+active_left_bound.size()+active_right_bound.size());
146 		rcomp.add(i-active_ctr.size()-active_left_bound.size());
147 		++i;
148 	}
149 	int j=0; 
150 	if (!fcomp.empty()) {
151 		if (ineq_first) {
152 			IntervalMatrix fcompjacob=((Fnc*) fact)-&gt;jacobian(box,fcomp,v);
153 			if (!ineq.empty()) J.put(j,0,fcompjacob[ineq]);
154 			if (!eq.empty())   J.put(j+ineq.size(),0,fcompjacob[eq]);
155 		} else {
156 			J.put(j,0,((Fnc*) fact)-&gt;jacobian(box,fcomp,v));
157 		}
158 	}
159 	j+=fcomp.size();
160 	BitSet l=active_left_bound.compose(lcomp);
161 	for (BitSet::const_iterator i=l.begin(); i!=l.end(); ++i) {
162 		if (v==-1) {
163 			J.row(j)=Vector::zeros(_nb_var);
164 			J[j][i]=-1;
165 		} else if (v==i)
166 			J[j][v]=-1;
167 		else
168 			J[j][v]=0;
169 		j++;
170 	}
171 	BitSet r=active_right_bound.compose(rcomp);
172 	for (BitSet::const_iterator i=r.begin(); i!=r.end(); ++i) {
173 		if (v==-1) {
174 			J.row(j)=Vector::zeros(_nb_var);
175 			J[j][i]=1;
176 		} else if (v==i)
177 			J[j][v]=1;
178 		else
179 			J[j][v]=0;
180 		j++;
181 	}
182 }
183 Interval FncActiveCtrs::eval(const IntervalVector&amp; box) const {
184 	assert(image_dim()==1);
185 	return FncActiveCtrs::eval_vector(box,BitSet::all(1))[0];
186 }
187 bool FncActiveCtrs::rejection_test(const IntervalVector&amp; x) const {
188 	assert(sys.goal);
189 	int n=sys.nb_var;
190 	int m=active_ctr.size() + 1; 
191 	IntervalMatrix B(n, m);
192 	B.put(0, 0, sys.goal-&gt;gradient(x), false); 
193 	if (fact)
194 		B.put(0, 1,((Fnc*) fact)-&gt;jacobian(x).transpose());
195 	const IntervalMatrix* B2;
196 	int N = n - active_left_bound.size() - active_right_bound.size();
197 	if (m&gt;N) {
198 		return false;
199 	}
200 	if (N==n) {
201 		B2=&amp;B; 	} else {
202 		B2 = new IntervalMatrix(N,m);
203 		int i2=0; 		for (int i=0; i&lt;n; i++) {
204 			if (!active_left_bound[i] &amp;&amp; !active_right_bound[i])
205 				((IntervalMatrix*) B2)-&gt;set_row(i2++,B.row(i));
206 		}
207 		assert(i2==N);
208 	}
209 	if (eq.empty()) { 		for (int j=0; j&lt;N; j++) {
210 			bool sign;
211 			if ((*B2)[j][0].lb()&gt;0)
212 				sign=true;
213 			else if ((*B2)[j][0].ub()&lt;0)
214 				sign=false;
215 			else
216 				continue;
217 			int i=0;
218 			for (; i&lt;m; i++) {
219 				if (sign) {
220 					if ((*B2)[j][i].lb()&lt;=0) break;
221 				} else {
222 					if ((*B2)[j][i].ub()&gt;=0) break;
223 				}
224 			}
225 			if (i==m) { 				if (N&lt;n) delete B2;
226 				return true; 			}
227 		}
228 	}
229 	bool res;
230 	if (full_rank(*B2))
231 		res = true;
232 	else
233 		res = false;
234 	if (N&lt;n) delete B2;
235 	return res;
236 }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
