<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ibex_FncKuhnTucker.cpp &amp; ibex_FncActiveCtrs.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_FncKuhnTucker.cpp &amp; ibex_FncActiveCtrs.cpp
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_FncKuhnTucker.cpp (4.5614033%)<th>ibex_FncActiveCtrs.cpp (3.5519125%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(126-139)<td><a href="#" name="0">(193-200)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_FncKuhnTucker.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
//============================================================================
//                                  I B E X
// File        : ibex_FncKuhnTucker.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Apr 26, 2017
// Last Update : Jul 11, 2019
//============================================================================

#include &lt;stdlib.h&gt;
#include &lt;cassert&gt;

#include "ibex_FncKuhnTucker.h"

using namespace std;

namespace ibex {

FncKuhnTucker::FncKuhnTucker(const NormalizedSystem&amp; sys, Function&amp; _df, Function** _dg, const IntervalVector&amp; current_box, const BitSet* _active) :
								Fnc(1,1), sys(sys), n(sys.nb_var), nb_mult(0), // **tmp**
								act(NULL), df(_df), nothing(BitSet::empty(1)) {

	assert(sys.goal);

	try {
		// ***************************************************
		// Unfortunately, if we want to give the symbolic
		// derivatives of contraints to FncActiveCtrs, we have
		// to build again a matrix-valued function from _dg
		// (not done).
		// ***************************************************
		if (_active)
			act = new FncActiveCtrs(sys,current_box,*_active,true);
		else
			act = new FncActiveCtrs(sys,current_box,true);

		dg.resize(act-&gt;active_ctr.size());

		unsigned int i=0; // index of a constraint in the active set
		for (BitSet::const_iterator c=act-&gt;active_ctr.begin(); c!=act-&gt;active_ctr.end(); ++c) {
			dg.set_ref(i++,*_dg[c]);
		}

		(int&amp;) nb_mult = act-&gt;image_dim() +1 ; // +1 because of objective

	} catch (FncActiveCtrs::NothingActive&amp;) {
		(int&amp;) nb_mult = 1 ; // objective
	}

	(int&amp;) _nb_var = n + nb_mult;

	(Dim&amp;) _image_dim = Dim(_nb_var, 1);
}

FncKuhnTucker::~FncKuhnTucker() {
	if (act) delete act;
}

IntervalVector FncKuhnTucker::multiplier_domain() const {
	IntervalVector box(nb_mult, Interval(0,1));

	if (act &amp;&amp; !act-&gt;eq.empty())
		box.put(act-&gt;ineq.size()+1,IntervalVector(act-&gt;eq.size(),Interval(-1,1)));

	return box;
}

IntervalVector FncKuhnTucker::eval_vector(const IntervalVector&amp; x_lambda, const BitSet&amp; components) const {

	if (components.size()!=n+nb_mult) {
		// TODO
		not_implemented("FncKuhnTucker: 'eval_vector' for selected components");
		//J.resize(n+nb_mult,n+nb_mult);
	}

	IntervalVector res(n+nb_mult);

	IntervalVector x=x_lambda.subvector(0,n-1);

	int lambda0=n;	// The index of lambda0 in the box x_lambda is nb_var.

	int l=lambda0; // multipliers indices counter. The first multiplier is lambda0.

	// vector corresponding to the "gradient expression" lambda_0*dg + lambda_1*dg_1 + ... (init
	IntervalVector grad=x_lambda[l] * df.eval_vector(x); // init

	// normalization equation lambda_0 + ... = 1.0
	res[lambda0] = x_lambda[lambda0] - 1.0; // init

	if (!act) {
		res.put(0,grad);
		return res;
	}


	l++;

	IntervalVector gx=((Fnc*) act)-&gt;eval_vector(x);
	IntervalMatrix dgx=((Fnc*) act)-&gt;jacobian(x);

	for (BitSet::const_iterator i=act-&gt;ineq.begin(); i!=act-&gt;ineq.end(); ++i) {
		grad +=  x_lambda[l] * dgx[l-n-1];
		res[l] = x_lambda[l] * gx[l-n-1]; // maybe a counter for inequalities would be clearer
		res[lambda0] += x_lambda[l];
		l++;
	}

	for (BitSet::const_iterator i=act-&gt;eq.begin(); i!=act-&gt;eq.end(); ++i) {
		grad +=  x_lambda[l] * dgx[l-n-1];
		res[l] = gx[l-n-1];
		res[lambda0] += sqr(x_lambda[l]);
		l++;
	}

	for (BitSet::const_iterator v=act-&gt;active_left_bound.begin(); v!=act-&gt;active_left_bound.end(); ++v) {
		grad[v] -= x_lambda[l];
		res[l] = x_lambda[l] * gx[l-n-1];
		res[lambda0] += x_lambda[l];
		l++;
	}

<a name="0"></a>	for (BitSet::const_iterator v=act-&gt;active_right_bound.begin(); v!=act-&gt;active_right_bound.end(); ++v) {
		grad[v] += x_lambda[l];
		res[l] = x_lambda[l] * gx[l-n-1];
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		res[lambda0] += x_lambda[l];
		l++;
	}

	assert(l==nb_mult+n);

	res.put(0, grad);

	return res;
}

void FncKuhnTucker::jacobian(const IntervalVector&amp; x_lambda, IntervalMatrix&amp; J, const BitSet&amp; components, int v) const {

	if (components.size()!=n+nb_mult) {</b></font>
		not_implemented("FncKuhnTucker: 'jacobian' for selected components");
		//J.resize(n+nb_mult,n+nb_mult);
	}

	IntervalVector x=x_lambda.subvector(0,n-1);

	int lambda0=n;	// The index of lambda0 in the box x_lambda is nb_var.

	int l=lambda0; // mutipliers indices counter. The first multiplier is lambda0.

	// matrix corresponding to the "Hessian expression" lambda_0*d^2f+lambda_1*d^2g_1+...=0
	IntervalMatrix hessian(n,n);
	if (v==-1 || v&lt;n) hessian = x_lambda[l] * df.jacobian(x,v); // init
	if (v==-1 || v==l) J.put(0, l, df.eval_vector(x), false);

	// normalization equation (init)
	if (v==-1) {
		J[lambda0].put(0,Vector::zeros(n));
		J[lambda0][lambda0]=1.0;
	} else if (v&lt;n)
		J[lambda0][v] = 0;
	else if (v==lambda0)
		J[lambda0][lambda0]=1.0;

	if (!act) {
		if (v==-1 || v&lt;n)
			J.put(0,0,hessian);
		return;
	}

	l++;

	IntervalVector gx;
	if ((v==-1 || v&gt;=n) &amp;&amp; !act-&gt;ineq.empty())
		gx = sys.f_ctrs.eval_vector(x,act-&gt;active_ctr.compose(act-&gt;ineq));

	IntervalVector dgi(n); // store dg_i([x]) (used in several places)

	for (BitSet::const_iterator i=act-&gt;ineq.begin(); i!=act-&gt;ineq.end(); ++i) {
		if (v==-1) {
			hessian += x_lambda[l] * dg[i].jacobian(x);
			dgi=dg[i].eval_vector(x);
			J.put(0, l, dgi, false);
			J.put(l, 0, (x_lambda[l]*dgi), true);
			J.put(l, n, Vector::zeros(nb_mult), true);
			J[l][l] = gx[l-n-1]; // maybe a counter for inequalities would be clearer
			J[lambda0][l] = 1.0;
		} else if (v==l) {
			J.put(0, l, dg[i].eval_vector(x), false);
			J[l][l] = gx[l-n-1];
			J[lambda0][l] = 1.0;
		} else if (v&lt;n) {
			hessian += x_lambda[l] * dg[i].jacobian(x,v);
			J[l][v] = x_lambda[l]*dg[i].eval(v,x);
		} else {
			J[l][v] = 0;
		}

		l++;
	}

	for (BitSet::const_iterator i=act-&gt;eq.begin(); i!=act-&gt;eq.end(); ++i) {
		if (v==-1) {
			hessian += x_lambda[l] * dg[i].jacobian(x,v);
			dgi=dg[i].eval_vector(x);
			J.put(0, l, dgi, false);
			J.put(l, 0, dgi, true);
			J.put(l, n, Vector::zeros(nb_mult), true);
			J[lambda0][l] = 2*x_lambda[l];
		} else if (v==l) {
			J.put(0, l, dg[i].eval_vector(x), false);
			J[l][l] = 0;
			J[lambda0][l] = 2*x_lambda[l];
		} else if (v&lt;n) {
			hessian += x_lambda[l] * dg[i].jacobian(x,v);
			J[l][v] = dg[i].eval(v,x);
		} else {
			J[l][v] = 0;
		}

		l++;
	}

	for (BitSet::const_iterator i=act-&gt;active_left_bound.begin(); i!=act-&gt;active_left_bound.end(); ++i) {
		// this constraint does not contribute to the "Hessian expression"
		if (v==-1) {
			dgi=Vector::zeros(n);
			dgi[i]=-1.0;
			J.put(0, l, dgi, false);

			J.put(l, 0, (x_lambda[l]*dgi), true);
			J.put(l, n, Vector::zeros(nb_mult), true);
			J[l][l] = -x[i]+sys.box[i].lb();
			J[lambda0][l] = 1.0;
		} else if (v==l) {
			dgi=Vector::zeros(n);
			dgi[i]=-1.0;
			J.put(0, l, dgi, false);
			J[l][l] = -x[i]+sys.box[i].lb();
			J[lambda0][l] = 1.0;
		} else if (v&lt;n) {
			J[l][v] = (v==i? -x_lambda[l] : 0);
		} else {
			J[l][v] = 0;
		}


		l++;
	}

	for (BitSet::const_iterator i=act-&gt;active_right_bound.begin(); i!=act-&gt;active_right_bound.end(); ++i) {
		// this constraint does not contribute to the "Hessian expression"
		if (v==-1) {
			dgi=Vector::zeros(n);
			dgi[i]=1.0;
			J.put(0, l, dgi, false);

			J.put(l, 0, (x_lambda[l]*dgi), true);
			J.put(l, n, Vector::zeros(nb_mult), true);
			J[l][l] = x[i]-sys.box[i].ub();

			J[lambda0][l] = 1.0;
		} else if (v==l) {
			dgi=Vector::zeros(n);
			dgi[i]=1.0;
			J.put(0, l, dgi, false);
			J[l][l] = x[i]-sys.box[i].ub();
			J[lambda0][l] = 1.0;

		} else if (v&lt;n) {
			J[l][v] = (v==i? x_lambda[l] : 0);
		} else {
			J[l][v] = 0;
		}


		l++;
	}

	assert(l==nb_mult+n);

	if (v==-1 || v&lt;n)
		J.put(0,0,hessian);
}


} /* namespace ibex */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_FncActiveCtrs.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* ============================================================================
 * I B E X - ibex_FncActiveCtrs.cpp
 * ============================================================================
 * Copyright   : IMT Atlantique (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Jun, 16 2017
 * Last update : Jul, 11 2019
 * ---------------------------------------------------------------------------- */

#include "ibex_FncActiveCtrs.h"
#include "ibex_Linear.h"

using namespace std;

namespace ibex {

FncActiveCtrs::FncActiveCtrs(const System&amp; sys, const IntervalVector&amp; box, const BitSet* _active, bool ineq_first, const Function* df) :
								Fnc(sys.nb_var,1), // **tmp**
								sys(sys), ineq_first(ineq_first),
								active_ctr(_active? *_active : sys.active_ctrs(box)),
								eq(BitSet::empty(sys.f_ctrs.image_dim())),
								ineq(BitSet::empty(sys.f_ctrs.image_dim())),
								active_left_bound(BitSet::empty(sys.nb_var)),
								active_right_bound(BitSet::empty(sys.nb_var)),
								LICQ(true /* by default */),
								fact(NULL) {

	int m=0; // total number of active constraints (ineq, eq, left and right bounds)

	{
		unsigned int i=0; // index of a constraint in the active set
		for (BitSet::const_iterator c=active_ctr.begin(); c!=active_ctr.end(); ++c, ++i) {
			if (sys.ops[c]==EQ) ((BitSet&amp;) eq).add(i);
			else ((BitSet&amp;) ineq).add(i);
			//cout &lt;&lt; " constraint n°" &lt;&lt; c &lt;&lt; " active\n";
		}
	}

	if (!active_ctr.empty())
		fact=new FncProj(sys.f_ctrs,active_ctr,df);

	m+=active_ctr.size();

	for (int j=0; j&lt;sys.box.size(); j++) {
		if (box[j].lb() &lt;= sys.box[j].lb()) {
			((BitSet&amp;) active_left_bound).add(j);
			//cout &lt;&lt; " left bound n°" &lt;&lt; j &lt;&lt; " active\n";
			m++;
		}
		if (box[j].ub() &gt;= sys.box[j].ub()) {
			if (active_left_bound[j]) LICQ=false;
			((BitSet&amp;) active_right_bound).add(j);
			//cout &lt;&lt; " right bound n°" &lt;&lt; j &lt;&lt; " active\n";
			m++;
		}

	}

	if (m==0) {
		if (fact) delete fact; // would leak otherwise (other members should be automatically deleted)
		throw NothingActive(); // otherwise the function would be "undefined"
	}

	(Dim&amp;) _image_dim = Dim(m, 1);

	if (m &gt; sys.nb_var)
		LICQ = false;

}

FncActiveCtrs::FncActiveCtrs(const System&amp; sys, const Vector&amp; pt, double activation_threshold, bool ineq_first, const Function* df) :
		Fnc(sys.nb_var,1), // **tmp**
		sys(sys), ineq_first(ineq_first),
		active_ctr(BitSet::empty(sys.f_ctrs.image_dim())),
		eq(BitSet::empty(sys.f_ctrs.image_dim())),
		ineq(BitSet::empty(sys.f_ctrs.image_dim())),
		active_left_bound(BitSet::empty(sys.nb_var)),
		active_right_bound(BitSet::empty(sys.nb_var)),
		LICQ(true /* by default */), fact(NULL) {

	int m=0; // total number of active constraints (ineq, eq, left and right bounds)

	if (sys.nb_ctr&gt;0) {
		for (int i=0; i&lt;sys.f_ctrs.image_dim(); i++) {
			if (sys.ops[i]==EQ) {
				((BitSet&amp;) active_ctr).add(i);
				((BitSet&amp;) eq).add(m++);
			}
			else {
				if (sys.f_ctrs.eval(i,pt).mag() &lt; activation_threshold) {
					//cout &lt;&lt; " activate inequality n°" &lt;&lt; i &lt;&lt; endl;
					((BitSet&amp;) active_ctr).add(i);
					((BitSet&amp;) ineq).add(m++);
				}
			}
		}
	}

	if (!active_ctr.empty())
		fact=new FncProj(sys.f_ctrs,active_ctr,df);

	for (int j=0; j&lt;sys.box.size(); j++) {
		if (pt[j]-activation_threshold &lt;= sys.box[j].lb()) {
			((BitSet&amp;) active_left_bound).add(j);
			//cout &lt;&lt; " left bound n°" &lt;&lt; j &lt;&lt; " active\n";
			m++;
		}
		if (pt[j]+activation_threshold &gt;= sys.box[j].ub()) {
			if (active_left_bound[j]) LICQ=false;
			((BitSet&amp;) active_right_bound).add(j);
			//cout &lt;&lt; " right bound n°" &lt;&lt; j &lt;&lt; " active\n";
			m++;
		}

	}

	if (m==0) {
		if (fact) delete fact; // would leak otherwise (other members should be automatically deleted)
		throw NothingActive(); // otherwise the function would be "undefined"
	}

	(Dim&amp;) _image_dim = Dim(m, 1);

	if (m &gt; sys.nb_var)
		LICQ = false;

}

FncActiveCtrs::~FncActiveCtrs() {
	if (fact)
		delete fact;
}

IntervalVector FncActiveCtrs::eval_vector(const IntervalVector&amp; box, const BitSet&amp; components) const {

	if (active_ctr.empty() &amp;&amp; active_left_bound.empty() &amp;&amp; active_right_bound.empty())
		// should not happen because of the etxception thrown by the construtor
		ibex_error("[FncActivation] nothing active.");
		//return IntervalVector(); // alternative answer (but dangerous)

	IntervalVector res(components.size());

	// ------------- subcomponents ------------------------
	BitSet fcomp=BitSet::empty(active_ctr.empty()? 1 : active_ctr.size());
	BitSet lcomp=BitSet::empty(active_left_bound.empty()? 1 : active_left_bound.size());
	BitSet rcomp=BitSet::empty(active_right_bound.empty()? 1 : active_right_bound.size());

	BitSet::const_iterator i=components.begin();

	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()) {
		fcomp.add(i);
		++i;
	}

	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()+active_left_bound.size()) {
		lcomp.add(i-active_ctr.size());
		++i;
	}

	while (i!=components.end()) {
		assert(i&lt;active_ctr.size()+active_left_bound.size()+active_right_bound.size());
		rcomp.add(i-active_ctr.size()-active_left_bound.size());
		++i;
	}
	// ----------------------------------------------------

	int j=0; // index for the components of resulting vector

	if (!fcomp.empty()) {
		if (ineq_first) {
			IntervalVector fcompeval=fact-&gt;eval_vector(box,fcomp);
			if (!ineq.empty()) res.put(j,fcompeval[ineq]);
			if (!eq.empty())   res.put(j+ineq.size(),fcompeval[eq]);
		} else {
			res.put(j,fact-&gt;eval_vector(box,fcomp));
		}
	}

	j+=fcomp.size();

	BitSet l=active_left_bound.compose(lcomp);

	for (BitSet::const_iterator v=l.begin(); v!=l.end(); ++v) {
		res[j++]=sys.box[v].lb()-box[v];
	}

<a name="0"></a>	BitSet r=active_right_bound.compose(rcomp);

	for (BitSet::const_iterator v=r.begin(); v!=r.end(); ++v) {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		res[j++]=box[v]-sys.box[v].ub();
	}

	return res;
}

void FncActiveCtrs::jacobian(const IntervalVector&amp; box, IntervalMatrix&amp; J, const BitSet&amp; components, int v) const {
	if (active_ctr.empty() &amp;&amp; active_left_bound.empty() &amp;&amp; active_right_bound.empty())</b></font>
		// should not happen because of the etxception thrown by the construtor
		ibex_error("[FncActivation] nothing active_ctr.");

	// following block is copy/paste from eval_vector...
	// ------------- subcomponents ------------------------
	BitSet fcomp=BitSet::empty(active_ctr.empty()? 1 : active_ctr.size());
	BitSet lcomp=BitSet::empty(active_left_bound.empty()? 1 : active_left_bound.size());
	BitSet rcomp=BitSet::empty(active_right_bound.empty()? 1 : active_right_bound.size());

	BitSet::const_iterator i=components.begin();

	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()) {
		fcomp.add(i);
		++i;
	}

	while (i!=components.end() &amp;&amp; i&lt;active_ctr.size()+active_left_bound.size()) {
		lcomp.add(i-active_ctr.size());
		++i;
	}

	while (i!=components.end()) {
		assert(i&lt;active_ctr.size()+active_left_bound.size()+active_right_bound.size());
		rcomp.add(i-active_ctr.size()-active_left_bound.size());
		++i;
	}
	// ----------------------------------------------------

	int j=0; // index for the components of resulting vector

	if (!fcomp.empty()) {
		if (ineq_first) {
			IntervalMatrix fcompjacob=((Fnc*) fact)-&gt;jacobian(box,fcomp,v);
			if (!ineq.empty()) J.put(j,0,fcompjacob[ineq]);
			if (!eq.empty())   J.put(j+ineq.size(),0,fcompjacob[eq]);
		} else {
			J.put(j,0,((Fnc*) fact)-&gt;jacobian(box,fcomp,v));
		}
	}

	j+=fcomp.size();

	BitSet l=active_left_bound.compose(lcomp);

	for (BitSet::const_iterator i=l.begin(); i!=l.end(); ++i) {
		if (v==-1) {
			J.row(j)=Vector::zeros(_nb_var);
			J[j][i]=-1;
		} else if (v==i)
			J[j][v]=-1;
		else
			J[j][v]=0;
		j++;
	}

	BitSet r=active_right_bound.compose(rcomp);

	for (BitSet::const_iterator i=r.begin(); i!=r.end(); ++i) {
		if (v==-1) {
			J.row(j)=Vector::zeros(_nb_var);
			J[j][i]=1;
		} else if (v==i)
			J[j][v]=1;
		else
			J[j][v]=0;
		j++;
	}
}

Interval FncActiveCtrs::eval(const IntervalVector&amp; box) const {
	assert(image_dim()==1);
	return FncActiveCtrs::eval_vector(box,BitSet::all(1))[0];
}


bool FncActiveCtrs::rejection_test(const IntervalVector&amp; x) const {

	assert(sys.goal);

	int n=sys.nb_var;

	int m=active_ctr.size() + 1; // +1 because we add the gradient of f

	// Calculate gradients of f and in/equalities
	// and store them in a matrix B
	IntervalMatrix B(n, m);

	// Gradient of objective
	B.put(0, 0, sys.goal-&gt;gradient(x), false); // init

	if (fact)
		// Gradients of active constraints
		// note: the order does not matter here (ineq_first ignored)
		B.put(0, 1,((Fnc*) fact)-&gt;jacobian(x).transpose());

	// To be more efficient, we know that if the jth
	// column is a bound constraint on the ith variable,
	// the rank of the matrix is the same as the matrix
	// obtained by removing the ith row and jth column.
	const IntervalMatrix* B2;

	// final number of rows
	int N = n - active_left_bound.size() - active_right_bound.size();

	if (m&gt;N) {
		// if m&gt;N: cannot be of rank m --&gt; skip this test
		return false;
	}

	if (N==n) {
		B2=&amp;B; // useless to build B a second time.
	} else {
		B2 = new IntervalMatrix(N,m);
		int i2=0; // counts rows of B2
		for (int i=0; i&lt;n; i++) {
			if (!active_left_bound[i] &amp;&amp; !active_right_bound[i])
				((IntervalMatrix*) B2)-&gt;set_row(i2++,B.row(i));
		}
		assert(i2==N);
	}

	// multiplier sign test
	if (eq.empty()) { // works with inequalities only
		for (int j=0; j&lt;N; j++) {
			bool sign;

			if ((*B2)[j][0].lb()&gt;0)
				sign=true;
			else if ((*B2)[j][0].ub()&lt;0)
				sign=false;
			else
				continue;

			int i=0;
			for (; i&lt;m; i++) {
				if (sign) {
					if ((*B2)[j][i].lb()&lt;=0) break;
				} else {
					if ((*B2)[j][i].ub()&gt;=0) break;
				}
			}
			if (i==m) { // the whole column has the same sign
				if (N&lt;n) delete B2;
				return true; // Rejected!
			}
		}
	}

	bool res;

	// rank check
	if (full_rank(*B2))
		// the matrix is rank M+1
		res = true;
	else
		res = false;

	if (N&lt;n) delete B2;

	return res;
}

} /* namespace ibex */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
