
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.102803738317757%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.h</h3>
            <pre><code>1  #pragma once
2  #include <mutex>
3  #include "Utf8_16.h"
4  class Notepad_plus;
5  class Buffer;
6  typedef Buffer* BufferID;	
7  #define BUFFER_INVALID	reinterpret_cast<BufferID>(0)
8  typedef sptr_t Document;
9  enum DocFileStatus {
10  	DOC_REGULAR    = 0x01, 
11  	DOC_UNNAMED    = 0x02, 
12  	DOC_DELETED    = 0x04, 
13  	DOC_MODIFIED   = 0x08, 
14  	DOC_NEEDRELOAD = 0x10  
15  };
16  enum BufferStatusInfo {
17  	BufferChangeNone		= 0x000,  
18  	BufferChangeLanguage	= 0x001,  
19  	BufferChangeDirty		= 0x002,  
20  	BufferChangeFormat		= 0x004,  
21  	BufferChangeUnicode		= 0x008,  
22  	BufferChangeReadonly	= 0x010,  
23  	BufferChangeStatus		= 0x020,  
24  	BufferChangeTimestamp	= 0x040,  
25  	BufferChangeFilename	= 0x080,  
26  	BufferChangeRecentTag	= 0x100,  
27  	BufferChangeLexing		= 0x200,  
28  	BufferChangeMask		= 0x3FF   
29  };
30  enum SavingStatus {
31  	SaveOK             = 0,
32  	SaveOpenFailed     = 1,
33  	SaveWritingFailed  = 2
34  };
35  const TCHAR UNTITLED_STR[] = TEXT("new ");
36  class FileManager final {
37  public:
38  	void init(Notepad_plus* pNotepadPlus, ScintillaEditView* pscratchTilla);
39  	void checkFilesystemChanges(bool bCheckOnlyCurrentBuffer);
40  	size_t getNbBuffers() const { return _nbBufs; };
41  	size_t getNbDirtyBuffers() const;
42  	int getBufferIndexByID(BufferID id);
43  	Buffer * getBufferByIndex(size_t index);
44  	Buffer * getBufferByID(BufferID id) {return id;}
45  	void beNotifiedOfBufferChange(Buffer * theBuf, int mask);
46  	void closeBuffer(BufferID, ScintillaEditView * identifer);		
47  	void addBufferReference(BufferID id, ScintillaEditView * identifer);	
48  	BufferID loadFile(const TCHAR * filename, Document doc = static_cast<Document>(NULL), int encoding = -1, const TCHAR *backupFileName = nullptr, FILETIME fileNameTimestamp = {});	
49  	BufferID newEmptyDocument();
50  	BufferID bufferFromDocument(Document doc,  bool dontIncrease = false, bool dontRef = false);
51  	BufferID getBufferFromName(const TCHAR * name);
52  	BufferID getBufferFromDocument(Document doc);
53  	void setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat);
54  	bool reloadBuffer(BufferID id);
55  	bool reloadBufferDeferred(BufferID id);
56  	SavingStatus saveBuffer(BufferID id, const TCHAR* filename, bool isCopy = false);
57  	bool backupCurrentBuffer();
58  	bool deleteBufferBackup(BufferID id);
59  	bool deleteFile(BufferID id);
60  	bool moveFile(BufferID id, const TCHAR * newFilename);
61  	bool createEmptyFile(const TCHAR * path);
62  	static FileManager& getInstance() {
63  		static FileManager instance;
64  		return instance;
65  	};
66  	int getFileNameFromBuffer(BufferID id, TCHAR * fn2copy);
67  	size_t docLength(Buffer * buffer) const;
68  	size_t nextUntitledNewNumber() const;
69  private:
70  	struct LoadedFileFormat {
71  		LoadedFileFormat() = default;
72  		LangType _language = L_TEXT;
73  		int _encoding = 0;
74  		EolType _eolFormat = EolType::osdefault;
75  	};
76  	FileManager() = default;
77  	~FileManager();
78  	FileManager(const FileManager&) = delete;
79  	FileManager& operator=(const FileManager&) = delete;
80  	FileManager(FileManager&&) = delete;
81  	FileManager& operator=(FileManager&&) = delete;
82  	int detectCodepage(char* buf, size_t len);
83  	bool loadFileData(Document doc, int64_t fileSize, const TCHAR* filename, char* buffer, Utf8_16_Read* UnicodeConvertor, LoadedFileFormat& fileFormat);
84  	LangType detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen);
85  	Notepad_plus* _pNotepadPlus = nullptr;
86  	ScintillaEditView* _pscratchTilla = nullptr;
87  	Document _scratchDocDefault = 0;
88  	std::vector<Buffer*> _buffers;
89  	BufferID _nextBufferID = 0;
90  	size_t _nbBufs = 0;
91  };
92  #define MainFileManager FileManager::getInstance()
93  class Buffer final {
94  	friend class FileManager;
95  public:
96  	Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile);
97  	void setFileName(const TCHAR *fn);
98  	const TCHAR * getFullPathName() const { return _fullPathName.c_str(); }
99  	const TCHAR * getFileName() const { return _fileName; }
100  	BufferID getID() const { return _id; }
101  	void increaseRecentTag() {
102  		_recentTag = ++_recentTagCtr;
103  		doNotify(BufferChangeRecentTag);
104  	}
105  	long getRecentTag() const { return _recentTag; }
106  	bool checkFileState();
107  	bool isDirty() const { return _isDirty; }
108  	bool isReadOnly() const { return (_isUserReadOnly || _isFileReadOnly); }
109  	bool isUntitled() const { return ((_currentStatus & DOC_UNNAMED) == DOC_UNNAMED); }
110  	bool getFileReadOnly() const { return _isFileReadOnly; }
111  	void setFileReadOnly(bool ro) {
112  		_isFileReadOnly = ro;
113  		doNotify(BufferChangeReadonly);
114  	}
115  	bool getUserReadOnly() const { return _isUserReadOnly; }
116  	void setUserReadOnly(bool ro) {
117  		_isUserReadOnly = ro;
118  		doNotify(BufferChangeReadonly);
119  	}
120  	EolType getEolFormat() const { return _eolFormat; }
121  	void setEolFormat(EolType format) {
122  		_eolFormat = format;
123  		doNotify(BufferChangeFormat);
124  	}
125  	LangType getLangType() const { return _lang; }
126  	void setLangType(LangType lang, const TCHAR * userLangName = TEXT(""));
<span onclick='openModal()' class='match'>127  	UniMode getUnicodeMode() const { return _unicodeMode; }
128  	void setUnicodeMode(UniMode mode);
129  	int getEncoding() const { return _encoding; }
</span>130  	void setEncoding(int encoding);
131  	DocFileStatus getStatus() const { return _currentStatus; }
132  	Document getDocument() { return _doc; }
133  	void setDirty(bool dirty);
134  	void setPosition(const Position & pos, ScintillaEditView * identifier);
135  	Position & getPosition(ScintillaEditView * identifier);
136  	void setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier);
137  	const std::vector<size_t> & getHeaderLineState(const ScintillaEditView * identifier) const;
138  	bool isUserDefineLangExt() const { return (_userLangExt[0] != '\0'); }
139  	const TCHAR * getUserDefineLangName() const	{ return _userLangExt.c_str(); }
140  	const TCHAR * getCommentLineSymbol() const {
141  		Lang *l = getCurrentLang();
142  		if (!l)
143  			return NULL;
144  		return l->_pCommentLineSymbol;
145  	}
146  	const TCHAR * getCommentStart() const {
147  		Lang *l = getCurrentLang();
148  		if (!l)
149  			return NULL;
150  		return l->_pCommentStart;
151  	}
152  	const TCHAR * getCommentEnd() const {
153  		Lang *l = getCurrentLang();
154  		if (!l)
155  			return NULL;
156  		return l->_pCommentEnd;
157  	}
158  	bool getNeedsLexing() const { return _needLexer; }
159  	void setNeedsLexing(bool lex) {
160  		_needLexer = lex;
161  		doNotify(BufferChangeLexing);
162  	}
163  	int addReference(ScintillaEditView * identifier);		
164  	int removeReference(ScintillaEditView * identifier);		
165  	void setHideLineChanged(bool isHide, size_t location);
166  	void setDeferredReload();
167  	bool getNeedReload() const { return _needReloading; }
168  	void setNeedReload(bool reload) { _needReloading = reload; }
169  	size_t docLength() const {
170  		assert(_pManager != nullptr);
171  		return _pManager->docLength(_id);
172  	}
173  	int64_t getFileLength() const; 
174  	enum fileTimeType { ft_created, ft_modified, ft_accessed };
175  	generic_string getFileTime(fileTimeType ftt) const;
176  	Lang * getCurrentLang() const;
177  	bool isModified() const { return _isModified; }
178  	void setModifiedStatus(bool isModified) { _isModified = isModified; }
179  	generic_string getBackupFileName() const { return _backupFileName; }
180  	void setBackupFileName(const generic_string& fileName) { _backupFileName = fileName; }
181  	FILETIME getLastModifiedTimestamp() const { return _timeStamp; }
182  	bool isLoadedDirty() const { return _isLoadedDirty; }
183  	void setLoadedDirty(bool val) {	_isLoadedDirty = val; }
184  	bool isUnsync() const { return _isUnsync; }
185  	void setUnsync(bool val) { _isUnsync = val; }
186  	bool isSavePointDirty() const { return _isSavePointDirty; }
187  	void setSavePointDirty(bool val) { _isSavePointDirty = val; }
188  	bool isLargeFile() const { return _isLargeFile; }
189  	void startMonitoring() {
190  		_isMonitoringOn = true;
191  		_eventHandle = ::CreateEvent(nullptr, TRUE, FALSE, nullptr);
192  	};
193  	HANDLE getMonitoringEvent() const { return _eventHandle; };
194  	void stopMonitoring() {
195  		_isMonitoringOn = false;
196  		::SetEvent(_eventHandle);
197  		::CloseHandle(_eventHandle);
198  	};
199  	bool isMonitoringOn() const { return _isMonitoringOn; };
200  	void updateTimeStamp();
201  	void reload();
202  	void setMapPosition(const MapPosition & mapPosition) { _mapPosition = mapPosition; };
203  	MapPosition getMapPosition() const { return _mapPosition; };
204  	void langHasBeenSetFromMenu() { _hasLangBeenSetFromMenu = true; };
205  	bool allowBraceMach() const;
206  	bool allowAutoCompletion() const;
207  	bool allowSmartHilite() const;
208  	bool allowClickableLink() const;
209  	void setDocColorId(int idx) {
210  		_docColorId = idx;
211  	};
212  	int getDocColorId() {
213  		return _docColorId;
214  	};
215  private:
216  	int indexOfReference(const ScintillaEditView * identifier) const;
217  	void setStatus(DocFileStatus status) {
218  		_currentStatus = status;
219  		doNotify(BufferChangeStatus);
220  	}
221  	void doNotify(int mask);
222  	Buffer(const Buffer&) = delete;
223  	Buffer& operator = (const Buffer&) = delete;
224  private:
225  	FileManager * _pManager = nullptr;
226  	bool _canNotify = false; 
227  	int _references = 0; 
228  	BufferID _id = nullptr;
229  	Document _doc;	
230  	LangType _lang = L_TEXT;
231  	generic_string _userLangExt; 
232  	bool _isDirty = false;
233  	EolType _eolFormat = EolType::osdefault;
234  	UniMode _unicodeMode = uniUTF8;
235  	int _encoding = -1;
236  	bool _isUserReadOnly = false;
237  	bool _needLexer = false; 
238  	std::vector<ScintillaEditView *> _referees; 
239  	std::vector<Position> _positions;
240  	std::vector<std::vector<size_t>> _foldStates;
241  	DocFileStatus _currentStatus = DOC_REGULAR;
242  	FILETIME _timeStamp = {}; 
243  	bool _isFileReadOnly = false;
244  	generic_string _fullPathName;
245  	TCHAR * _fileName = nullptr; 
246  	bool _needReloading = false; 
247  	long _recentTag = -1;
248  	static long _recentTagCtr;
249  	int _docColorId = -1;
250  	generic_string _backupFileName;
251  	bool _isModified = false;
252  	bool _isLoadedDirty = false; 
253  	bool _isUnsync = false; 
254  	bool _isLargeFile = false; 
255  	bool _isSavePointDirty = false; 
256  	HANDLE _eventHandle = nullptr;
257  	bool _isMonitoringOn = false;
258  	bool _hasLangBeenSetFromMenu = false;
259  	MapPosition _mapPosition;
260  	std::mutex _reloadFromDiskRequestGuard;
261  };
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-errors.cpp</h3>
            <pre><code>1  #include <nano/lib/errors.hpp>
2  #include <nano/lib/utility.hpp>
3  #include <boost/system/error_code.hpp>
4  std::string nano::error_common_messages::message (int ev) const
5  {
6  	switch (static_cast<nano::error_common> (ev))
7  	{
8  		case nano::error_common::generic:
9  			return "Unknown error";
10  		case nano::error_common::access_denied:
11  			return "Access denied";
12  		case nano::error_common::missing_account:
13  			return "Missing account";
14  		case nano::error_common::missing_balance:
15  			return "Missing balance";
16  		case nano::error_common::missing_link:
17  			return "Missing link, source or destination";
18  		case nano::error_common::missing_previous:
19  			return "Missing previous";
20  		case nano::error_common::missing_representative:
21  			return "Missing representative";
22  		case nano::error_common::missing_signature:
23  			return "Missing signature";
24  		case nano::error_common::missing_work:
25  			return "Missing work";
26  		case nano::error_common::exception:
27  			return "Exception thrown";
28  		case nano::error_common::account_exists:
29  			return "Account already exists";
30  		case nano::error_common::account_not_found:
31  			return "Account not found";
32  		case nano::error_common::account_not_found_wallet:
33  			return "Account not found in wallet";
34  		case nano::error_common::bad_account_number:
35  			return "Bad account number";
36  		case nano::error_common::bad_balance:
37  			return "Bad balance";
38  		case nano::error_common::bad_link:
39  			return "Bad link value";
40  		case nano::error_common::bad_previous:
41  			return "Bad previous hash";
42  		case nano::error_common::bad_representative_number:
43  			return "Bad representative";
44  		case nano::error_common::bad_source:
45  			return "Bad source";
46  		case nano::error_common::bad_signature:
47  			return "Bad signature";
48  		case nano::error_common::bad_private_key:
49  			return "Bad private key";
50  		case nano::error_common::bad_public_key:
51  			return "Bad public key";
52  		case nano::error_common::bad_seed:
53  			return "Bad seed";
54  		case nano::error_common::bad_threshold:
55  			return "Bad threshold number";
56  		case nano::error_common::bad_wallet_number:
57  			return "Bad wallet number";
58  		case nano::error_common::bad_work_format:
59  			return "Bad work";
60  		case nano::error_common::disabled_local_work_generation:
61  			return "Local work generation is disabled";
62  		case nano::error_common::disabled_work_generation:
63  			return "Work generation is disabled";
64  		case nano::error_common::failure_work_generation:
65  			return "Work generation cancellation or failure";
66  		case nano::error_common::insufficient_balance:
67  			return "Insufficient balance";
68  		case nano::error_common::invalid_amount:
69  			return "Invalid amount number";
70  		case nano::error_common::invalid_amount_big:
71  			return "Amount too big";
72  		case nano::error_common::invalid_count:
73  			return "Invalid count";
74  		case nano::error_common::invalid_ip_address:
75  			return "Invalid IP address";
76  		case nano::error_common::invalid_port:
77  			return "Invalid port";
78  		case nano::error_common::invalid_index:
79  			return "Invalid index";
80  		case nano::error_common::invalid_type_conversion:
81  			return "Invalid type conversion";
82  		case nano::error_common::invalid_work:
83  			return "Invalid work";
84  		case nano::error_common::is_not_state_block:
85  			return "Must be a state block";
86  		case nano::error_common::numeric_conversion:
87  			return "Numeric conversion error";
88  		case nano::error_common::tracking_not_enabled:
89  			return "Database transaction tracking is not enabled in the config";
90  		case nano::error_common::wallet_lmdb_max_dbs:
91  			return "Failed to create wallet. Increase lmdb_max_dbs in node config";
92  		case nano::error_common::wallet_locked:
93  			return "Wallet is locked";
94  		case nano::error_common::wallet_not_found:
95  			return "Wallet not found";
96  	}
97  	return "Invalid error code";
98  }
99  std::string nano::error_blocks_messages::message (int ev) const
100  {
101  	switch (static_cast<nano::error_blocks> (ev))
102  	{
103  		case nano::error_blocks::generic:
104  			return "Unknown error";
105  		case nano::error_blocks::bad_hash_number:
106  			return "Bad hash number";
107  		case nano::error_blocks::invalid_block:
108  			return "Block is invalid";
109  		case nano::error_blocks::invalid_block_hash:
110  			return "Invalid block hash";
111  		case nano::error_blocks::invalid_type:
112  			return "Invalid block type";
113  		case nano::error_blocks::not_found:
114  			return "Block not found";
115  		case nano::error_blocks::work_low:
116  			return "Block work is less than threshold";
117  	}
118  	return "Invalid error code";
119  }
120  std::string nano::error_rpc_messages::message (int ev) const
121  {
122  	switch (static_cast<nano::error_rpc> (ev))
123  	{
124  		case nano::error_rpc::generic:
125  			return "Unknown error";
126  		case nano::error_rpc::empty_response:
127  			return "Empty response";
128  		case nano::error_rpc::bad_destination:
129  			return "Bad destination account";
130  		case nano::error_rpc::bad_difficulty_format:
131  			return "Bad difficulty";
132  		case nano::error_rpc::bad_key:
133  			return "Bad key";
134  		case nano::error_rpc::bad_link:
135  			return "Bad link number";
136  		case nano::error_rpc::bad_multiplier_format:
137  			return "Bad multiplier";
138  		case nano::error_rpc::bad_previous:
139  			return "Bad previous";
140  		case nano::error_rpc::bad_representative_number:
141  			return "Bad representative number";
142  		case nano::error_rpc::bad_source:
143  			return "Bad source";
144  		case nano::error_rpc::bad_timeout:
145  			return "Bad timeout number";
146  		case nano::error_rpc::bad_work_version:
147  			return "Bad work version";
148  		case nano::error_rpc::block_create_balance_mismatch:
149  			return "Balance mismatch for previous block";
150  		case nano::error_rpc::block_create_key_required:
151  			return "Private key or local wallet and account required";
152  		case nano::error_rpc::block_create_public_key_mismatch:
153  			return "Incorrect key for given account";
154  		case nano::error_rpc::block_create_requirements_state:
155  			return "Previous, representative, final balance and link (source or destination) are required";
156  		case nano::error_rpc::block_create_requirements_open:
157  			return "Representative account and source hash required";
158  		case nano::error_rpc::block_create_requirements_receive:
159  			return "Previous hash and source hash required";
160  		case nano::error_rpc::block_create_requirements_change:
161  			return "Representative account and previous hash required";
162  		case nano::error_rpc::block_create_requirements_send:
163  			return "Destination account, previous hash, current balance and amount required";
164  		case nano::error_rpc::block_root_mismatch:
165  			return "Root mismatch for block";
166  		case nano::error_rpc::block_work_enough:
167  			return "Provided work is already enough for given difficulty";
168  		case nano::error_rpc::block_work_version_mismatch:
169  			return "Work version mismatch for block";
170  		case nano::error_rpc::confirmation_height_not_processing:
171  			return "There are no blocks currently being processed for adding confirmation height";
172  		case nano::error_rpc::confirmation_not_found:
173  			return "Active confirmation not found";
174  		case nano::error_rpc::difficulty_limit:
175  			return "Difficulty above config limit or below publish threshold";
176  		case nano::error_rpc::disabled_bootstrap_lazy:
177  			return "Lazy bootstrap is disabled";
178  		case nano::error_rpc::disabled_bootstrap_legacy:
179  			return "Legacy bootstrap is disabled";
180  		case nano::error_rpc::invalid_balance:
181  			return "Invalid balance number";
182  		case nano::error_rpc::invalid_destinations:
183  			return "Invalid destinations number";
184  		case nano::error_rpc::invalid_epoch:
185  			return "Invalid epoch number";
186  		case nano::error_rpc::invalid_epoch_signer:
187  			return "Incorrect epoch signer";
188  		case nano::error_rpc::invalid_offset:
189  			return "Invalid offset";
190  		case nano::error_rpc::invalid_missing_type:
191  			return "Invalid or missing type argument";
192  		case nano::error_rpc::invalid_root:
193  			return "Invalid root hash";
194  		case nano::error_rpc::invalid_sources:
195  			return "Invalid sources number";
196  		case nano::error_rpc::invalid_subtype:
197  			return "Invalid block subtype";
198  		case nano::error_rpc::invalid_subtype_balance:
199  			return "Invalid block balance for given subtype";
200  		case nano::error_rpc::invalid_subtype_epoch_link:
201  			return "Invalid epoch link";
202  		case nano::error_rpc::invalid_subtype_previous:
203  			return "Invalid previous block for given subtype";
204  		case nano::error_rpc::invalid_timestamp:
205  			return "Invalid timestamp";
206  		case nano::error_rpc::invalid_threads_count:
207  			return "Invalid threads count";
208  		case nano::error_rpc::peer_not_found:
209  			return "Peer not found";
210  		case nano::error_rpc::pruning_disabled:
211  			return "Pruning is disabled";
212  		case nano::error_rpc::requires_port_and_address:
213  			return "Both port and address required";
214  		case nano::error_rpc::rpc_control_disabled:
215  			return "RPC control is disabled";
216  		case nano::error_rpc::sign_hash_disabled:
217  			return "Signing by block hash is disabled";
218  		case nano::error_rpc::source_not_found:
219  			return "Source not found";
220  		case nano::error_rpc::stopped:
221  			return "Stopped";
222  	}
223  	return "Invalid error code";
224  }
225  std::string nano::error_process_messages::message (int ev) const
226  {
227  	switch (static_cast<nano::error_process> (ev))
228  	{
229  		case nano::error_process::generic:
230  			return "Unknown error";
231  		case nano::error_process::bad_signature:
232  			return "Bad signature";
233  		case nano::error_process::old:
234  			return "Old block";
235  		case nano::error_process::negative_spend:
236  			return "Negative spend";
237  		case nano::error_process::fork:
238  			return "Fork";
239  		case nano::error_process::unreceivable:
240  			return "Unreceivable";
241  		case nano::error_process::gap_previous:
242  			return "Gap previous block";
243  		case nano::error_process::gap_source:
244  			return "Gap source block";
245  		case nano::error_process::gap_epoch_open_pending:
246  			return "Gap pending for open epoch block";
247  		case nano::error_process::opened_burn_account:
248  			return "Block attempts to open the burn account";
249  		case nano::error_process::balance_mismatch:
250  			return "Balance and amount delta do not match";
251  		case nano::error_process::block_position:
252  			return "This block cannot follow the previous block";
253  		case nano::error_process::insufficient_work:
254  			return "Block work is insufficient";
255  		case nano::error_process::other:
256  			return "Error processing block";
257  	}
258  	return "Invalid error code";
259  }
260  std::string nano::error_config_messages::message (int ev) const
261  {
262  	switch (static_cast<nano::error_config> (ev))
263  	{
264  		case nano::error_config::generic:
265  			return "Unknown error";
266  		case nano::error_config::invalid_value:
267  			return "Invalid configuration value";
268  		case nano::error_config::missing_value:
269  			return "Missing value in configuration";
270  	}
271  	return "Invalid error code";
272  }
273  #if defined(NANO_USE_BOOST_TO_STD_ERROR_BRIDGE)
<span onclick='openModal()' class='match'>274  char const * nano::error_conversion::detail::generic_category::name () const noexcept
275  {
276  	return boost::system::generic_category ().name ();
277  }
278  std::string nano::error_conversion::detail::generic_category::message (int value) const
279  {
280  	return boost::system::generic_category ().message (value);
281  }
</span>282  std::error_category const & nano::error_conversion::generic_category ()
283  {
284  	static detail::generic_category instance;
285  	return instance;
286  }
287  std::error_code nano::error_conversion::convert (boost::system::error_code const & error)
288  {
289  	if (error.category () == boost::system::generic_category ())
290  	{
291  		return std::error_code (error.value (),
292  		nano::error_conversion::generic_category ());
293  	}
294  	debug_assert (false);
295  	return nano::error_common::invalid_type_conversion;
296  }
297  #endif
298  nano::error::error (std::error_code code_a)
299  {
300  	code = code_a;
301  }
302  #if defined(NANO_USE_BOOST_TO_STD_ERROR_BRIDGE)
303  nano::error::error (boost::system::error_code const & code_a)
304  {
305  	code = std::make_error_code (static_cast<std::errc> (code_a.value ()));
306  }
307  #endif
308  nano::error::error (std::string message_a)
309  {
310  	code = nano::error_common::generic;
311  	message = std::move (message_a);
312  }
313  nano::error::error (std::exception const & exception_a)
314  {
315  	code = nano::error_common::exception;
316  	message = exception_a.what ();
317  }
318  nano::error & nano::error::operator= (nano::error const & err_a)
319  {
320  	code = err_a.code;
321  	message = err_a.message;
322  	return *this;
323  }
324  nano::error & nano::error::operator= (nano::error && err_a)
325  {
326  	code = err_a.code;
327  	message = std::move (err_a.message);
328  	return *this;
329  }
330  nano::error & nano::error::operator= (std::error_code const code_a)
331  {
332  	code = code_a;
333  	message.clear ();
334  	return *this;
335  }
336  #if defined(NANO_USE_BOOST_TO_STD_ERROR_BRIDGE)
337  nano::error & nano::error::operator= (boost::system::error_code const & code_a)
338  {
339  	code = nano::error_conversion::convert (code_a);
340  	message.clear ();
341  	return *this;
342  }
343  nano::error & nano::error::operator= (boost::system::errc::errc_t const & code_a)
344  {
345  	code = nano::error_conversion::convert (boost::system::errc::make_error_code (code_a));
346  	message.clear ();
347  	return *this;
348  }
349  #endif
350  nano::error & nano::error::operator= (std::string message_a)
351  {
352  	code = nano::error_common::generic;
353  	message = std::move (message_a);
354  	return *this;
355  }
356  nano::error & nano::error::operator= (std::exception const & exception_a)
357  {
358  	code = nano::error_common::exception;
359  	message = exception_a.what ();
360  	return *this;
361  }
362  bool nano::error::operator== (std::error_code const code_a) const
363  {
364  	return code == code_a;
365  }
366  #if defined(NANO_USE_BOOST_TO_STD_ERROR_BRIDGE)
367  bool nano::error::operator== (boost::system::error_code const code_a) const
368  {
369  	return code.value () == code_a.value ();
370  }
371  #endif
372  nano::error & nano::error::then (std::function<nano::error &()> next)
373  {
374  	return code ? *this : next ();
375  }
376  nano::error::operator std::error_code () const
377  {
378  	return code;
379  }
380  int nano::error::error_code_as_int () const
381  {
382  	return code.value ();
383  }
384  nano::error::operator bool () const
385  {
386  	return code.value () != 0;
387  }
388  nano::error::operator std::string () const
389  {
390  	return get_message ();
391  }
392  std::string nano::error::get_message () const
393  {
394  	std::string res = message;
395  	if (code && res.empty ())
396  	{
397  		res = code.message ();
398  	}
399  	return res;
400  }
401  nano::error & nano::error::on_error (std::string message_a)
402  {
403  	if (code)
404  	{
405  		message = std::move (message_a);
406  	}
407  	return *this;
408  }
409  nano::error & nano::error::on_error (std::error_code code_a, std::string message_a)
410  {
411  	if (code == code_a)
412  	{
413  		message = std::move (message_a);
414  	}
415  	return *this;
416  }
417  nano::error & nano::error::set (std::string message_a, std::error_code code_a)
418  {
419  	message = std::move (message_a);
420  	code = code_a;
421  	return *this;
422  }
423  nano::error & nano::error::set_message (std::string message_a)
424  {
425  	if (!code)
426  	{
427  		code = nano::error_common::generic;
428  	}
429  	message = std::move (message_a);
430  	return *this;
431  }
432  nano::error & nano::error::clear ()
433  {
434  	code.clear ();
435  	message.clear ();
436  	return *this;
437  }
438  #if defined(NANO_USE_BOOST_TO_STD_ERROR_BRIDGE)
439  namespace std
440  {
441  std::error_code make_error_code (boost::system::errc::errc_t const & e)
442  {
443  	return std::error_code (static_cast<int> (e), ::nano::error_conversion::generic_category ());
444  }
445  }
446  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-errors.cpp</div>
                </div>
                <div class="column column_space"><pre><code>127  	UniMode getUnicodeMode() const { return _unicodeMode; }
128  	void setUnicodeMode(UniMode mode);
129  	int getEncoding() const { return _encoding; }
</pre></code></div>
                <div class="column column_space"><pre><code>274  char const * nano::error_conversion::detail::generic_category::name () const noexcept
275  {
276  	return boost::system::generic_category ().name ();
277  }
278  std::string nano::error_conversion::detail::generic_category::message (int value) const
279  {
280  	return boost::system::generic_category ().message (value);
281  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    