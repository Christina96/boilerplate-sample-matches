
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/qt/qt.hpp>
3  #include <boost/foreach.hpp>
4  #include <boost/property_tree/json_parser.hpp>
5  #include <boost/property_tree/ptree.hpp>
6  #include <cmath>
7  #include <iomanip>
8  #include <sstream>
9  namespace
10  {
11  void show_line_error (QLineEdit & line)
12  {
13  	line.setStyleSheet ("QLineEdit { color: red }");
14  }
15  void show_line_ok (QLineEdit & line)
16  {
17  	line.setStyleSheet ("QLineEdit { color: black }");
18  }
19  void show_label_error (QLabel & label)
20  {
21  	label.setStyleSheet ("QLabel { color: red }");
22  }
23  void show_label_ok (QLabel & label)
24  {
25  	label.setStyleSheet ("QLabel { color: black }");
26  }
27  void show_button_error (QPushButton & button)
28  {
29  	button.setStyleSheet ("QPushButton { color: red }");
30  }
31  void show_button_ok (QPushButton & button)
32  {
33  	button.setStyleSheet ("QPushButton { color: black }");
34  }
35  void show_button_success (QPushButton & button)
36  {
37  	button.setStyleSheet ("QPushButton { color: blue }");
38  }
39  }
40  bool nano_qt::eventloop_processor::event (QEvent * event_a)
41  {
42  	debug_assert (dynamic_cast<nano_qt::eventloop_event *> (event_a) != nullptr);
43  	static_cast<nano_qt::eventloop_event *> (event_a)->action ();
44  	return true;
45  }
46  nano_qt::eventloop_event::eventloop_event (std::function<void ()> const & action_a) :
47  	QEvent (QEvent::Type::User),
48  	action (action_a)
49  {
50  }
51  nano_qt::self_pane::self_pane (nano_qt::wallet & wallet_a, nano::account const & account_a) :
52  	window (new QWidget),
53  	layout (new QVBoxLayout),
54  	self_layout (new QHBoxLayout),
55  	self_window (new QWidget),
56  	your_account_label (new QLabel ("Your Nano account:")),
57  	account_window (new QWidget),
58  	account_layout (new QHBoxLayout),
59  	account_text (new QLineEdit),
60  	copy_button (new QPushButton ("Copy")),
61  	balance_window (new QWidget),
62  	balance_layout (new QHBoxLayout),
63  	balance_label (new QLabel),
64  	wallet (wallet_a)
65  {
66  	your_account_label->setStyleSheet ("font-weight: bold;");
67  	std::string network = wallet.node.network_params.network.get_current_network_as_string ();
68  	if (!network.empty ())
69  	{
70  		network[0] = std::toupper (network[0]);
71  	}
72  	version = new QLabel (boost::str (boost::format ("%1% %2% network") % NANO_VERSION_STRING % network).c_str ());
73  	self_layout->addWidget (your_account_label);
74  	self_layout->addStretch ();
75  	self_layout->addWidget (version);
76  	self_layout->setContentsMargins (0, 0, 0, 0);
77  	self_window->setLayout (self_layout);
78  	account_text->setReadOnly (true);
79  	account_text->setStyleSheet ("QLineEdit{ background: #ddd; }");
80  	account_layout->addWidget (account_text, 9);
81  	account_layout->addWidget (copy_button, 1);
82  	account_layout->setContentsMargins (0, 0, 0, 0);
83  	account_window->setLayout (account_layout);
84  	layout->addWidget (self_window);
85  	layout->addWidget (account_window);
86  	balance_label->setStyleSheet ("font-weight: bold;");
87  	balance_layout->addWidget (balance_label);
88  	balance_layout->addStretch ();
89  	balance_layout->setContentsMargins (0, 0, 0, 0);
90  	balance_window->setLayout (balance_layout);
91  	layout->addWidget (balance_window);
92  	layout->setContentsMargins (5, 5, 5, 5);
93  	window->setLayout (layout);
94  	QObject::connect (copy_button, &QPushButton::clicked, [this] () {
95  		this->wallet.application.clipboard ()->setText (QString (this->wallet.account.to_account ().c_str ()));
96  		copy_button->setText ("Copied!");
97  		this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (2), [this] () {
98  			this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
99  				copy_button->setText ("Copy");
100  			}));
101  		});
102  	});
103  }
104  void nano_qt::self_pane::set_balance_text (std::pair<nano::uint128_t, nano::uint128_t> balance_a)
105  {
106  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance_a.first));
107  	if (!balance_a.second.is_zero ())
108  	{
109  		final_text += "\nReady to receive: " + wallet.format_balance (balance_a.second);
110  	}
111  	wallet.self.balance_label->setText (QString (final_text.c_str ()));
112  }
113  nano_qt::accounts::accounts (nano_qt::wallet & wallet_a) :
114  	wallet_balance_label (new QLabel),
115  	window (new QWidget),
116  	layout (new QVBoxLayout),
117  	model (new QStandardItemModel),
118  	view (new QTableView),
119  	use_account (new QPushButton ("Use account")),
120  	create_account (new QPushButton ("Create account")),
121  	import_wallet (new QPushButton ("Import wallet")),
122  	backup_seed (new QPushButton ("Copy wallet seed to clipboard")),
123  	separator (new QFrame),
124  	account_key_line (new QLineEdit),
125  	account_key_button (new QPushButton ("Import adhoc key")),
126  	back (new QPushButton ("Back")),
127  	wallet (wallet_a)
128  {
129  	separator->setFrameShape (QFrame::HLine);
130  	separator->setFrameShadow (QFrame::Sunken);
131  	model->setHorizontalHeaderItem (0, new QStandardItem ("Balance"));
132  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
133  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
134  	view->setModel (model);
135  	view->verticalHeader ()->hide ();
136  	view->setContextMenuPolicy (Qt::ContextMenuPolicy::CustomContextMenu);
137  	view->horizontalHeader ()->setStretchLastSection (true);
138  	layout->addWidget (wallet_balance_label);
139  	layout->addWidget (view);
140  	layout->addWidget (use_account);
141  	layout->addWidget (create_account);
142  	layout->addWidget (import_wallet);
143  	layout->addWidget (backup_seed);
144  	layout->addWidget (separator);
145  	layout->addWidget (account_key_line);
146  	layout->addWidget (account_key_button);
147  	layout->addWidget (back);
148  	window->setLayout (layout);
149  	QObject::connect (use_account, &QPushButton::released, [this] () {
150  		auto selection (view->selectionModel ()->selection ().indexes ());
151  		if (selection.size () == 1)
152  		{
153  			auto error (this->wallet.account.decode_account (model->item (selection[0].row (), 1)->text ().toStdString ()));
154  			(void)error;
155  			debug_assert (!error);
156  			this->wallet.refresh ();
157  		}
158  	});
159  	QObject::connect (account_key_button, &QPushButton::released, [this] () {
160  		QString key_text_wide (account_key_line->text ());
161  		std::string key_text (key_text_wide.toLocal8Bit ());
162  		nano::raw_key key;
163  		if (!key.decode_hex (key_text))
164  		{
165  			show_line_ok (*account_key_line);
166  			account_key_line->clear ();
167  			this->wallet.wallet_m->insert_adhoc (key);
168  			this->wallet.accounts.refresh ();
169  			this->wallet.accounts.refresh_wallet_balance ();
170  			this->wallet.history.refresh ();
171  		}
172  		else
173  		{
174  			show_line_error (*account_key_line);
175  		}
176  	});
177  	QObject::connect (back, &QPushButton::clicked, [this] () {
178  		this->wallet.pop_main_stack ();
179  	});
180  	QObject::connect (create_account, &QPushButton::released, [this] () {
181  		{
182  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
183  			if (this->wallet.wallet_m->store.valid_password (transaction))
184  			{
185  				this->wallet.wallet_m->deterministic_insert (transaction);
186  				show_button_success (*create_account);
187  				create_account->setText ("New account was created");
188  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
189  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
190  						show_button_ok (*create_account);
191  						create_account->setText ("Create account");
192  					}));
193  				});
194  			}
195  			else
196  			{
197  				show_button_error (*create_account);
198  				create_account->setText ("Wallet is locked, unlock it to create account");
199  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
200  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
201  						show_button_ok (*create_account);
202  						create_account->setText ("Create account");
203  					}));
204  				});
205  			}
206  		}
207  		refresh ();
208  	});
209  	QObject::connect (import_wallet, &QPushButton::released, [this] () {
210  		this->wallet.push_main_stack (this->wallet.import.window);
211  	});
212  	QObject::connect (backup_seed, &QPushButton::released, [this] () {
213  		nano::raw_key seed;
214  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
215  		if (this->wallet.wallet_m->store.valid_password (transaction))
216  		{
217  			this->wallet.wallet_m->store.seed (seed, transaction);
218  			this->wallet.application.clipboard ()->setText (QString (seed.to_string ().c_str ()));
219  			show_button_success (*backup_seed);
220  			backup_seed->setText ("Seed was copied to clipboard");
221  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
222  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
223  					show_button_ok (*backup_seed);
224  					backup_seed->setText ("Copy wallet seed to clipboard");
225  				}));
226  			});
227  		}
228  		else
229  		{
230  			this->wallet.application.clipboard ()->setText ("");
231  			show_button_error (*backup_seed);
232  			backup_seed->setText ("Wallet is locked, unlock it to enable the backup");
233  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
234  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
235  					show_button_ok (*backup_seed);
236  					backup_seed->setText ("Copy wallet seed to clipboard");
237  				}));
238  			});
239  		}
240  	});
241  	QObject::connect (account_key_line, &QLineEdit::textChanged, [this] (const QString & value) {
242  		auto pos = account_key_line->cursorPosition ();
243  		account_key_line->setText (value.trimmed ());
244  		account_key_line->setCursorPosition (pos);
245  	});
246  	refresh_wallet_balance ();
247  }
248  void nano_qt::accounts::refresh_wallet_balance ()
249  {
250  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
251  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
252  	nano::uint128_t balance (0);
253  	nano::uint128_t pending (0);
254  	for (auto i (this->wallet.wallet_m->store.begin (transaction)), j (this->wallet.wallet_m->store.end ()); i != j; ++i)
255  	{
256  		nano::public_key const & key (i->first);
257  		balance = balance + (this->wallet.node.ledger.account_balance (block_transaction, key));
258  		pending = pending + (this->wallet.node.ledger.account_receivable (block_transaction, key));
259  	}
260  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance));
261  	if (!pending.is_zero ())
262  	{
263  		final_text += "\nReady to receive: " + wallet.format_balance (pending);
264  	}
265  	wallet_balance_label->setText (QString (final_text.c_str ()));
266  	this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (60), [this] () {
267  		this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
268  			refresh_wallet_balance ();
269  		}));
270  	});
271  }
272  void nano_qt::accounts::refresh ()
273  {
274  	model->removeRows (0, model->rowCount ());
275  	auto transaction (wallet.wallet_m->wallets.tx_begin_read ());
276  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
277  	QBrush brush;
278  	for (auto i (wallet.wallet_m->store.begin (transaction)), j (wallet.wallet_m->store.end ()); i != j; ++i)
279  	{
280  		nano::public_key key (i->first);
281  		auto balance_amount (wallet.node.ledger.account_balance (block_transaction, key));
282  		bool display (true);
283  		switch (wallet.wallet_m->store.key_type (i->second))
284  		{
285  			case nano::key_type::adhoc:
286  			{
287  				brush.setColor ("red");
288  				display = !balance_amount.is_zero ();
289  				break;
290  			}
291  			default:
292  			{
293  				brush.setColor ("black");
294  				break;
295  			}
296  		}
297  		if (display)
298  		{
299  			QList<QStandardItem *> items;
300  			std::string balance = wallet.format_balance (balance_amount);
301  			items.push_back (new QStandardItem (balance.c_str ()));
302  			auto account (new QStandardItem (QString (key.to_account ().c_str ())));
303  			account->setForeground (brush);
304  			items.push_back (account);
305  			model->appendRow (items);
306  		}
307  	}
308  }
309  nano_qt::import::import (nano_qt::wallet & wallet_a) :
310  	window (new QWidget),
311  	layout (new QVBoxLayout),
312  	seed_label (new QLabel ("Seed:")),
313  	seed (new QLineEdit),
314  	clear_label (new QLabel ("Modifying seed clears existing keys\nType 'clear keys' below to confirm:")),
315  	clear_line (new QLineEdit),
316  	import_seed (new QPushButton ("Import seed")),
317  	separator (new QFrame),
318  	filename_label (new QLabel ("Path to file:")),
319  	filename (new QLineEdit),
320  	password_label (new QLabel ("Password:")),
321  	password (new QLineEdit),
322  	perform (new QPushButton ("Import")),
323  	back (new QPushButton ("Back")),
324  	wallet (wallet_a)
325  {
326  	layout->addWidget (seed_label);
327  	layout->addWidget (seed);
328  	layout->addWidget (clear_label);
329  	layout->addWidget (clear_line);
330  	clear_line->setPlaceholderText ("clear keys");
331  	layout->addWidget (import_seed);
332  	layout->addWidget (separator);
333  	layout->addWidget (filename_label);
334  	layout->addWidget (filename);
335  	layout->addWidget (password_label);
336  	layout->addWidget (password);
337  	layout->addWidget (perform);
338  	layout->addStretch ();
339  	layout->addWidget (back);
340  	window->setLayout (layout);
341  	QObject::connect (perform, &QPushButton::released, [this] () {
342  		std::ifstream stream;
343  		stream.open (filename->text ().toStdString ().c_str ());
344  		if (!stream.fail ())
345  		{
346  			show_line_ok (*filename);
347  			std::stringstream contents;
348  			contents << stream.rdbuf ();
349  			if (!this->wallet.wallet_m->import (contents.str (), password->text ().toStdString ().c_str ()))
350  			{
351  				show_line_ok (*password);
352  				this->wallet.accounts.refresh ();
353  				password->clear ();
354  				filename->clear ();
355  			}
356  			else
357  			{
358  				show_line_error (*password);
359  			}
360  		}
361  		else
362  		{
363  			show_line_error (*filename);
364  		}
365  	});
366  	QObject::connect (back, &QPushButton::released, [this] () {
367  		this->wallet.pop_main_stack ();
368  	});
369  	QObject::connect (import_seed, &QPushButton::released, [this] () {
370  		if (clear_line->text ().toStdString () == "clear keys")
371  		{
372  			show_line_ok (*clear_line);
373  			nano::raw_key seed_l;
374  			if (!seed_l.decode_hex (seed->text ().toStdString ()))
375  			{
376  				bool successful (false);
377  				{
378  					auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
379  					if (this->wallet.wallet_m->store.valid_password (transaction))
380  					{
381  						this->wallet.account = this->wallet.wallet_m->change_seed (transaction, seed_l);
382  						successful = true;
383  						if (this->wallet.node.bootstrap_initiator.in_progress ())
384  						{
385  							this->wallet.needs_deterministic_restore = true;
386  						}
387  					}
388  					else
389  					{
390  						show_line_error (*seed);
391  						show_button_error (*import_seed);
392  						import_seed->setText ("Wallet is locked, unlock it to enable the import");
393  						this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (10), [this] () {
394  							this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
395  								show_line_ok (*seed);
396  								show_button_ok (*import_seed);
397  								import_seed->setText ("Import seed");
398  							}));
399  						});
400  					}
401  				}
402  				if (successful)
403  				{
404  					seed->clear ();
405  					clear_line->clear ();
406  					show_line_ok (*seed);
407  					show_button_success (*import_seed);
408  					import_seed->setText ("Successful import of seed");
409  					this->wallet.refresh ();
410  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
411  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
412  							show_button_ok (*import_seed);
413  							import_seed->setText ("Import seed");
414  						}));
415  					});
416  				}
417  			}
418  			else
419  			{
420  				show_line_error (*seed);
421  				show_button_error (*import_seed);
422  				if (seed->text ().toStdString ().size () != 64)
423  				{
424  					import_seed->setText ("Incorrect seed, length must be 64");
425  				}
426  				else
427  				{
428  					import_seed->setText ("Incorrect seed. Only HEX characters allowed");
429  				}
430  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
431  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
432  						show_button_ok (*import_seed);
433  						import_seed->setText ("Import seed");
434  					}));
435  				});
436  			}
437  		}
438  		else
439  		{
440  			show_line_error (*clear_line);
441  			show_button_error (*import_seed);
442  			import_seed->setText ("Type words 'clear keys'");
443  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
444  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
445  					show_button_ok (*import_seed);
446  					import_seed->setText ("Import seed");
447  				}));
448  			});
449  		}
450  	});
451  	QObject::connect (seed, &QLineEdit::textChanged, [this] (const QString & value) {
452  		auto pos = seed->cursorPosition ();
453  		seed->setText (value.trimmed ());
454  		seed->setCursorPosition (pos);
455  	});
456  	QObject::connect (filename, &QLineEdit::textChanged, [this] (const QString & value) {
457  		auto pos = filename->cursorPosition ();
458  		filename->setText (value.trimmed ());
459  		filename->setCursorPosition (pos);
460  	});
461  }
462  nano_qt::history::history (nano::ledger & ledger_a, nano::account const & account_a, nano_qt::wallet & wallet_a) :
463  	window (new QWidget),
464  	layout (new QVBoxLayout),
465  	model (new QStandardItemModel),
466  	view (new QTableView),
467  	tx_window (new QWidget),
468  	tx_layout (new QHBoxLayout),
469  	tx_label (new QLabel ("Account history count:")),
470  	tx_count (new QSpinBox),
471  	ledger (ledger_a),
472  	account (account_a),
473  	wallet (wallet_a)
474  { &bsol;*
475  	tx_count->setRange (1, 256);
476  	tx_layout->addWidget (tx_label);
477  	tx_layout->addWidget (tx_count);
478  	tx_layout->setContentsMargins (0, 0, 0, 0);
479  	tx_window->setLayout (tx_layout);*/
480  	model->setHorizontalHeaderItem (0, new QStandardItem ("Type"));
481  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
482  	model->setHorizontalHeaderItem (2, new QStandardItem ("Amount"));
483  	model->setHorizontalHeaderItem (3, new QStandardItem ("Hash"));
484  	view->setModel (model);
485  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
486  	view->verticalHeader ()->hide ();
487  	view->horizontalHeader ()->setStretchLastSection (true);
488  	layout->addWidget (view);
489  	layout->setContentsMargins (0, 0, 0, 0);
490  	window->setLayout (layout);
491  	tx_count->setValue (32);
492  }
493  namespace
494  {
495  class short_text_visitor : public nano::block_visitor
496  {
497  public:
498  	short_text_visitor (nano::transaction const & transaction_a, nano::ledger & ledger_a) :
499  		transaction (transaction_a),
500  		ledger (ledger_a)
501  	{
502  	}
503  	void send_block (nano::send_block const & block_a)
504  	{
505  		type = "Send";
506  		account = block_a.hashables.destination;
507  		bool error_or_pruned (false);
508  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
509  		if (error_or_pruned)
510  		{
511  			type = "Send (pruned)";
512  		}
513  	}
514  	void receive_block (nano::receive_block const & block_a)
515  	{
516  		type = "Receive";
517  		bool error_or_pruned (false);
518  		account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
519  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
520  		if (error_or_pruned)
521  		{
522  			type = "Receive (pruned)";
523  		}
524  	}
525  	void open_block (nano::open_block const & block_a)
526  	{
527  		type = "Receive";
528  		if (block_a.hashables.source != ledger.constants.genesis->account ())
529  		{
530  			bool error_or_pruned (false);
531  			account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
532  			amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
533  			if (error_or_pruned)
534  			{
535  				type = "Receive (pruned)";
536  			}
537  		}
538  		else
539  		{
540  			account = ledger.constants.genesis->account ();
541  			amount = nano::dev::constants.genesis_amount;
542  		}
543  	}
544  	void change_block (nano::change_block const & block_a)
545  	{
546  		type = "Change";
547  		amount = 0;
548  		account = block_a.hashables.representative;
549  	}
550  	void state_block (nano::state_block const & block_a)
551  	{
552  		auto balance (block_a.hashables.balance.number ());
553  		bool error_or_pruned (false);
554  		auto previous_balance (ledger.balance_safe (transaction, block_a.hashables.previous, error_or_pruned));
555  		if (error_or_pruned)
556  		{
557  			type = "Unknown (pruned)";
558  			amount = 0;
559  			account = block_a.hashables.account;
560  		}
561  		else if (balance < previous_balance)
562  		{
563  			type = "Send";
564  			amount = previous_balance - balance;
565  			account = block_a.hashables.link.as_account ();
566  		}
567  		else
568  		{
569  			if (block_a.hashables.link.is_zero ())
570  			{
571  				type = "Change";
572  				account = block_a.hashables.representative;
573  			}
574  			else if (balance == previous_balance && ledger.is_epoch_link (block_a.hashables.link))
575  			{
576  				type = "Epoch";
577  				account = ledger.epoch_signer (block_a.hashables.link);
578  			}
579  			else
580  			{
581  				type = "Receive";
582  				account = ledger.account_safe (transaction, block_a.hashables.link.as_block_hash (), error_or_pruned);
583  				if (error_or_pruned)
584  				{
585  					type = "Receive (pruned)";
586  				}
587  			}
588  			amount = balance - previous_balance;
589  		}
590  	}
591  	nano::transaction const & transaction;
592  	nano::ledger & ledger;
593  	std::string type;
594  	nano::uint128_t amount;
595  	nano::account account;
596  };
597  }
598  void nano_qt::history::refresh ()
599  {
600  	auto transaction (ledger.store.tx_begin_read ());
601  	model->removeRows (0, model->rowCount ());
602  	auto hash (ledger.latest (transaction, account));
603  	short_text_visitor visitor (transaction, ledger);
604  	for (auto i (0), n (tx_count->value ()); i < n && !hash.is_zero (); ++i)
605  	{
606  		QList<QStandardItem *> items;
607  		auto block (ledger.store.block.get (transaction, hash));
608  		if (block != nullptr)
609  		{
610  			block->visit (visitor);
611  			items.push_back (new QStandardItem (QString (visitor.type.c_str ())));
612  			items.push_back (new QStandardItem (QString (visitor.account.to_account ().c_str ())));
613  			auto balanceItem = new QStandardItem (QString (wallet.format_balance (visitor.amount).c_str ()));
614  			balanceItem->setData (Qt::AlignRight, Qt::TextAlignmentRole);
615  			items.push_back (balanceItem);
616  			items.push_back (new QStandardItem (QString (hash.to_string ().c_str ())));
617  			hash = block->previous ();
618  			model->appendRow (items);
619  		}
620  	}
621  }
622  nano_qt::block_viewer::block_viewer (nano_qt::wallet & wallet_a) :
623  	window (new QWidget),
624  	layout (new QVBoxLayout),
625  	hash_label (new QLabel ("Hash:")),
626  	hash (new QLineEdit),
627  	block_label (new QLabel ("Block:")),
628  	block (new QPlainTextEdit),
629  	successor_label (new QLabel ("Successor:")),
630  	successor (new QLineEdit),
631  	retrieve (new QPushButton ("Retrieve")),
632  	rebroadcast (new QPushButton ("Rebroadcast")),
633  	back (new QPushButton ("Back")),
634  	wallet (wallet_a)
635  {
636  	layout->addWidget (hash_label);
637  	layout->addWidget (hash);
638  	layout->addWidget (block_label);
639  	layout->addWidget (block);
640  	layout->addWidget (successor_label);
641  	layout->addWidget (successor);
642  	layout->addWidget (retrieve);
643  	layout->addWidget (rebroadcast);
644  	layout->addStretch ();
645  	layout->addWidget (back);
646  	window->setLayout (layout);
647  	QObject::connect (back, &QPushButton::released, [this] () {
648  		this->wallet.pop_main_stack ();
649  	});
650  	QObject::connect (retrieve, &QPushButton::released, [this] () {
651  		nano::block_hash hash_l;
652  		if (!hash_l.decode_hex (hash->text ().toStdString ()))
653  		{
654  			auto transaction (this->wallet.node.store.tx_begin_read ());
655  			auto block_l (this->wallet.node.store.block.get (transaction, hash_l));
656  			if (block_l != nullptr)
657  			{
658  				std::string contents;
659  				block_l->serialize_json (contents);
660  				block->setPlainText (contents.c_str ());
661  				auto successor_l (this->wallet.node.store.block.successor (transaction, hash_l));
662  				successor->setText (successor_l.to_string ().c_str ());
663  			}
664  			else
665  			{
666  				block->setPlainText ("Block not found");
667  			}
668  		}
669  		else
670  		{
671  			block->setPlainText ("Bad block hash");
672  		}
673  	});
674  	QObject::connect (rebroadcast, &QPushButton::released, [this] () {
675  		nano::block_hash block;
676  		auto error (block.decode_hex (hash->text ().toStdString ()));
677  		if (!error)
678  		{
679  			auto transaction (this->wallet.node.store.tx_begin_read ());
680  			if (this->wallet.node.store.block.exists (transaction, block))
681  			{
682  				rebroadcast->setEnabled (false);
683  				this->wallet.node.background ([this, block] () {
684  					rebroadcast_action (block);
685  				});
686  			}
687  		}
688  	});
689  	QObject::connect (hash, &QLineEdit::textChanged, [this] (const QString & value) {
690  		auto pos = hash->cursorPosition ();
691  		hash->setText (value.trimmed ());
692  		hash->setCursorPosition (pos);
693  	});
694  	rebroadcast->setToolTip ("Rebroadcast block into the network");
695  }
696  void nano_qt::block_viewer::rebroadcast_action (nano::block_hash const & hash_a)
697  {
698  	auto done (true);
699  	auto transaction (wallet.node.ledger.store.tx_begin_read ());
700  	auto block (wallet.node.store.block.get (transaction, hash_a));
701  	if (block != nullptr)
702  	{
703  		wallet.node.network.flood_block (block);
704  		auto successor (wallet.node.store.block.successor (transaction, hash_a));
705  		if (!successor.is_zero ())
706  		{
707  			done = false;
708  			wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (1), [this, successor] () {
709  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this, successor] () {
710  					rebroadcast_action (successor);
711  				}));
712  			});
713  		}
714  	}
715  	if (done)
716  	{
717  		rebroadcast->setEnabled (true);
718  	}
719  }
720  nano_qt::account_viewer::account_viewer (nano_qt::wallet & wallet_a) :
721  	window (new QWidget),
722  	layout (new QVBoxLayout),
723  	account_label (new QLabel ("Account:")),
724  	account_line (new QLineEdit),
725  	refresh (new QPushButton ("Refresh")),
726  	balance_window (new QWidget),
727  	balance_layout (new QHBoxLayout),
728  	balance_label (new QLabel),
729  	history (wallet_a.node.ledger, account, wallet_a),
730  	back (new QPushButton ("Back")),
731  	account (wallet_a.account),
732  	wallet (wallet_a)
733  {
734  	layout->addWidget (account_label);
735  	layout->addWidget (account_line);
736  	layout->addWidget (refresh);
737  	balance_layout->addWidget (balance_label);
738  	balance_layout->addStretch ();
739  	balance_layout->setContentsMargins (0, 0, 0, 0);
740  	balance_window->setLayout (balance_layout);
741  	layout->addWidget (balance_window);
742  	layout->addWidget (history.window);
743  	layout->addWidget (back);
744  	window->setLayout (layout);
745  	QObject::connect (back, &QPushButton::released, [this] () {
746  		this->wallet.pop_main_stack ();
747  	});
748  	QObject::connect (refresh, &QPushButton::released, [this] () {
749  		account.clear ();
750  		if (!account.decode_account (account_line->text ().toStdString ()))
751  		{
752  			show_line_ok (*account_line);
753  			this->history.refresh ();
754  			auto balance (this->wallet.node.balance_pending (account, false));
755  			auto final_text (std::string ("Balance (NANO): ") + wallet.format_balance (balance.first));
756  			if (!balance.second.is_zero ())
757  			{
758  				final_text += "\nReady to receive: " + wallet.format_balance (balance.second);
759  			}
760  			balance_label->setText (QString (final_text.c_str ()));
761  		}
762  		else
763  		{
764  			show_line_error (*account_line);
765  			balance_label->clear ();
766  		}
767  	});
768  	QObject::connect (account_line, &QLineEdit::textChanged, [this] (const QString & value) {
769  		auto pos = account_line->cursorPosition ();
770  		account_line->setText (value.trimmed ());
771  		account_line->setCursorPosition (pos);
772  	});
773  }
774  nano_qt::stats_viewer::stats_viewer (nano_qt::wallet & wallet_a) :
775  	window (new QWidget),
776  	layout (new QVBoxLayout),
777  	refresh (new QPushButton ("Refresh")),
778  	clear (new QPushButton ("Clear Statistics")),
779  	model (new QStandardItemModel),
780  	view (new QTableView),
781  	back (new QPushButton ("Back")),
782  	wallet (wallet_a)
783  {
784  	model->setHorizontalHeaderItem (0, new QStandardItem ("Last updated"));
785  	model->setHorizontalHeaderItem (1, new QStandardItem ("Type"));
786  	model->setHorizontalHeaderItem (2, new QStandardItem ("Detail"));
787  	model->setHorizontalHeaderItem (3, new QStandardItem ("Direction"));
788  	model->setHorizontalHeaderItem (4, new QStandardItem ("Value"));
789  	view->setModel (model);
790  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
791  	view->verticalHeader ()->hide ();
792  	view->horizontalHeader ()->setStretchLastSection (true);
793  	layout->setContentsMargins (0, 0, 0, 0);
794  	layout->addWidget (view);
795  	layout->addWidget (refresh);
796  	layout->addWidget (clear);
797  	layout->addWidget (back);
798  	window->setLayout (layout);
799  	QObject::connect (back, &QPushButton::released, [this] () {
800  		this->wallet.pop_main_stack ();
801  	});
802  	QObject::connect (refresh, &QPushButton::released, [this] () {
803  		refresh_stats ();
804  	});
805  	QObject::connect (clear, &QPushButton::released, [this] () {
806  		this->wallet.node.stats.clear ();
807  		refresh_stats ();
808  	});
809  	refresh_stats ();
810  }
811  void nano_qt::stats_viewer::refresh_stats ()
812  {
813  	model->removeRows (0, model->rowCount ());
814  	auto sink = wallet.node.stats.log_sink_json ();
815  	wallet.node.stats.log_counters (*sink);
816  	auto json = static_cast<boost::property_tree::ptree *> (sink->to_object ());
817  	if (json)
818  	{
819  		BOOST_FOREACH (boost::property_tree::ptree::value_type const & child, json->get_child ("entries"))
820  		{
821  			auto time = child.second.get<std::string> ("time");
822  			auto type = child.second.get<std::string> ("type");
823  			auto detail = child.second.get<std::string> ("detail");
824  			auto dir = child.second.get<std::string> ("dir");
825  			auto value = child.second.get<std::string> ("value", "0");
826  			if (detail == "all")
827  			{
828  				detail = "total";
829  			}
830  			if (type == "traffic_tcp")
831  			{
832  				std::vector<std::string> const units = { " bytes", " KB", " MB", " GB", " TB", " PB" };
833  				double bytes = std::stod (value);
834  				auto index = bytes == 0 ? 0 : std::min (units.size () - 1, static_cast<size_t> (std::floor (std::log2 (bytes) / 10)));
835  				std::string unit = units[index];
836  				bytes /= std::pow (1024, index);
837  				int precision = index < 2 ? 0 : 2;
838  				std::stringstream numstream;
839  				numstream << std::fixed << std::setprecision (precision) << bytes;
840  				value = numstream.str () + unit;
841  			}
842  			QList<QStandardItem *> items;
843  			items.push_back (new QStandardItem (QString (time.c_str ())));
844  			items.push_back (new QStandardItem (QString (type.c_str ())));
845  			items.push_back (new QStandardItem (QString (detail.c_str ())));
846  			items.push_back (new QStandardItem (QString (dir.c_str ())));
847  			items.push_back (new QStandardItem (QString (value.c_str ())));
848  			model->appendRow (items);
849  		}
850  	}
851  }
852  nano_qt::status::status (nano_qt::wallet & wallet_a) :
853  	wallet (wallet_a)
854  {
855  	wallet.status->setToolTip ("Wallet status, block count (blocks downloaded)");
856  	active.insert (nano_qt::status_types::nominal);
857  	set_text ();
858  }
859  void nano_qt::status::erase (nano_qt::status_types status_a)
860  {
861  	debug_assert (status_a != nano_qt::status_types::nominal);
862  	auto erased (active.erase (status_a));
863  	(void)erased;
864  	set_text ();
865  }
866  void nano_qt::status::insert (nano_qt::status_types status_a)
867  {
868  	debug_assert (status_a != nano_qt::status_types::nominal);
869  	active.insert (status_a);
870  	set_text ();
871  }
872  void nano_qt::status::set_text ()
873  {
874  	wallet.status->setText (text ().c_str ());
875  	wallet.status->setStyleSheet ((std::string ("QLabel {") + color () + "}").c_str ());
876  }
877  std::string nano_qt::status::text ()
878  {
879  	debug_assert (!active.empty ());
880  	std::string result;
881  	size_t unchecked (0);
882  	size_t cemented (0);
883  	std::string count_string;
884  	{
885  		auto size (wallet.wallet_m->wallets.node.ledger.cache.block_count.load ());
886  		unchecked = wallet.wallet_m->wallets.node.unchecked.count ();
887  		cemented = wallet.wallet_m->wallets.node.ledger.cache.cemented_count.load ();
888  		count_string = std::to_string (size);
889  	}
890  	switch (*active.begin ())
891  	{
892  		case nano_qt::status_types::disconnected:
893  			result = "Status: Disconnected";
894  			break;
895  		case nano_qt::status_types::working:
896  			result = "Status: Generating proof of work";
897  			break;
898  		case nano_qt::status_types::synchronizing:
899  			result = "Status: Synchronizing";
900  			break;
901  		case nano_qt::status_types::locked:
902  			result = "Status: Wallet locked";
903  			break;
904  		case nano_qt::status_types::vulnerable:
905  			result = "Status: Wallet password empty";
906  			break;
907  		case nano_qt::status_types::active:
908  			result = "Status: Wallet active";
909  			break;
910  		case nano_qt::status_types::nominal:
911  			result = "Status: Running";
912  			break;
913  		default:
914  			debug_assert (false);
915  			break;
916  	}
917  	result += ", Blocks: ";
918  	count_string += ", Unchecked: " + std::to_string (unchecked);
919  	count_string += ", Cemented: " + std::to_string (cemented);
920  	if (wallet.node.flags.enable_pruning)
921  	{
922  		count_string += ", Full: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.block_count - wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
923  		count_string += ", Pruned: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
924  	}
925  	result += count_string.c_str ();
926  	return result;
927  }
928  std::string nano_qt::status::color ()
929  {
930  	debug_assert (!active.empty ());
931  	std::string result;
932  	switch (*active.begin ())
933  	{
934  		case nano_qt::status_types::disconnected:
935  			result = "color: red";
936  			break;
937  		case nano_qt::status_types::working:
938  			result = "color: blue";
939  			break;
940  		case nano_qt::status_types::synchronizing:
941  			result = "color: blue";
942  			break;
943  		case nano_qt::status_types::locked:
944  			result = "color: orange";
945  			break;
946  		case nano_qt::status_types::vulnerable:
947  			result = "color: blue";
948  			break;
949  		case nano_qt::status_types::active:
950  			result = "color: black";
951  			break;
952  		case nano_qt::status_types::nominal:
953  			result = "color: black";
954  			break;
955  		default:
956  			debug_assert (false);
957  			break;
958  	}
959  	return result;
960  }
961  nano_qt::wallet::wallet (QApplication & application_a, nano_qt::eventloop_processor & processor_a, nano::node & node_a, std::shared_ptr<nano::wallet> const & wallet_a, nano::account & account_a) :
962  	rendering_ratio (nano::Mxrb_ratio),
963  	node (node_a),
964  	wallet_m (wallet_a),
965  	account (account_a),
966  	processor (processor_a),
967  	history (node.ledger, account, *this),
968  	accounts (*this),
969  	self (*this, account_a),
970  	settings (*this),
971  	advanced (*this),
972  	block_creation (*this),
973  	block_entry (*this),
974  	block_viewer (*this),
975  	account_viewer (*this),
976  	stats_viewer (*this),
977  	import (*this),
978  	application (application_a),
979  	status (new QLabel),
980  	main_stack (new QStackedWidget),
981  	client_window (new QWidget),
982  	client_layout (new QVBoxLayout),
983  	entry_window (new QWidget),
984  	entry_window_layout (new QVBoxLayout),
985  	separator (new QFrame),
986  	account_history_label (new QLabel ("Account history:")),
987  	send_blocks (new QPushButton ("Send")),
988  	settings_button (new QPushButton ("Settings")),
989  	accounts_button (new QPushButton ("Accounts")),
990  	show_advanced (new QPushButton ("Advanced")),
991  	send_blocks_window (new QWidget),
992  	send_blocks_layout (new QVBoxLayout),
993  	send_account_label (new QLabel ("Destination account:")),
994  	send_account (new QLineEdit),
995  	send_count_label (new QLabel ("Amount:")),
996  	send_count (new QLineEdit),
997  	send_blocks_send (new QPushButton ("Send")),
998  	send_blocks_back (new QPushButton ("Back")),
999  	active_status (*this),
1000  	needs_deterministic_restore (false)
1001  {
1002  	update_connected ();
1003  	empty_password ();
1004  	settings.update_locked (true, true);
1005  	send_blocks_layout->addWidget (send_account_label);
1006  	send_account->setPlaceholderText (node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1007  	send_blocks_layout->addWidget (send_account);
1008  	send_blocks_layout->addWidget (send_count_label);
1009  	send_count->setPlaceholderText ("0");
1010  	send_blocks_layout->addWidget (send_count);
1011  	send_blocks_layout->addWidget (send_blocks_send);
1012  	send_blocks_layout->addStretch ();
1013  	send_blocks_layout->addWidget (send_blocks_back);
1014  	send_blocks_layout->setContentsMargins (0, 0, 0, 0);
1015  	send_blocks_window->setLayout (send_blocks_layout);
1016  	entry_window_layout->addWidget (account_history_label);
1017  	entry_window_layout->addWidget (history.window);
1018  	entry_window_layout->addWidget (send_blocks);
1019  	entry_window_layout->addWidget (settings_button);
1020  	entry_window_layout->addWidget (accounts_button);
1021  	entry_window_layout->addWidget (show_advanced);
1022  	entry_window_layout->setContentsMargins (0, 0, 0, 0);
1023  	entry_window_layout->setSpacing (5);
1024  	entry_window->setLayout (entry_window_layout);
1025  	main_stack->addWidget (entry_window);
1026  	status->setContentsMargins (5, 5, 5, 5);
1027  	status->setAlignment (Qt::AlignHCenter);
1028  	separator->setFrameShape (QFrame::HLine);
1029  	separator->setFrameShadow (QFrame::Sunken);
1030  	client_layout->addWidget (status);
1031  	client_layout->addWidget (self.window);
1032  	client_layout->addWidget (separator);
1033  	client_layout->addWidget (main_stack);
1034  	client_layout->setSpacing (0);
1035  	client_layout->setContentsMargins (0, 0, 0, 0);
1036  	client_window->setLayout (client_layout);
1037  	client_window->resize (620, 640);
1038  	client_window->setStyleSheet ("\
1039  		QLineEdit { padding: 3px; } \
1040  	");
1041  	QObject::connect (send_account, &QLineEdit::textChanged, [this] (const QString & value) {
1042  		auto pos = send_account->cursorPosition ();
1043  		send_account->setText (value.trimmed ());
1044  		send_account->setCursorPosition (pos);
1045  	});
1046  	QObject::connect (send_count, &QLineEdit::textChanged, [this] (const QString & value) {
1047  		auto pos = send_count->cursorPosition ();
1048  		send_count->setText (value.trimmed ());
1049  		send_count->setCursorPosition (pos);
1050  	});
1051  	refresh ();
1052  }
1053  void nano_qt::wallet::ongoing_refresh ()
1054  {
1055  	std::weak_ptr<nano_qt::wallet> wallet_w (shared_from_this ());
1056  	if (needs_balance_refresh)
1057  	{
1058  		needs_balance_refresh = false;
1059  		auto balance_l (node.balance_pending (account, false));
1060  		application.postEvent (&processor, new eventloop_event ([wallet_w, balance_l] () {
1061  			if (auto this_l = wallet_w.lock ())
1062  			{
1063  				this_l->self.set_balance_text (balance_l);
1064  			}
1065  		}));
1066  	}
1067  	application.postEvent (&processor, new eventloop_event ([wallet_w] () {
1068  		if (auto this_l = wallet_w.lock ())
1069  		{
1070  			this_l->active_status.set_text ();
1071  		}
1072  	}));
1073  	node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [wallet_w] () {
1074  		if (auto wallet_l = wallet_w.lock ())
1075  		{
1076  			wallet_l->ongoing_refresh ();
1077  		}
1078  	});
1079  }
1080  void nano_qt::wallet::start ()
1081  {
1082  	ongoing_refresh ();
1083  	std::weak_ptr<nano_qt::wallet> this_w (shared_from_this ());
1084  	QObject::connect (settings_button, &QPushButton::released, [this_w] () {
1085  		if (auto this_l = this_w.lock ())
1086  		{
1087  			this_l->settings.activate ();
1088  		}
1089  	});
1090  	QObject::connect (accounts_button, &QPushButton::released, [this_w] () {
1091  		if (auto this_l = this_w.lock ())
1092  		{
1093  			this_l->push_main_stack (this_l->accounts.window);
1094  		}
1095  	});
1096  	QObject::connect (show_advanced, &QPushButton::released, [this_w] () {
1097  		if (auto this_l = this_w.lock ())
1098  		{
1099  			this_l->push_main_stack (this_l->advanced.window);
1100  		}
1101  	});
1102  	QObject::connect (send_blocks_send, &QPushButton::released, [this_w] () {
1103  		if (auto this_l = this_w.lock ())
1104  		{
1105  			show_line_ok (*this_l->send_count);
1106  			show_line_ok (*this_l->send_account);
1107  			nano::amount amount;
1108  			if (!amount.decode_dec (this_l->send_count->text ().toStdString (), this_l->rendering_ratio))
1109  			{
1110  				nano::uint128_t actual (amount.number ());
1111  				QString account_text (this_l->send_account->text ());
1112  				std::string account_text_narrow (account_text.toLocal8Bit ());
1113  				nano::account account_l;
1114  				auto parse_error (account_l.decode_account (account_text_narrow));
1115  				if (!parse_error)
1116  				{
1117  					auto balance (this_l->node.balance (this_l->account));
1118  					if (actual <= balance)
1119  					{
1120  						auto transaction (this_l->wallet_m->wallets.tx_begin_read ());
1121  						if (this_l->wallet_m->store.valid_password (transaction))
1122  						{
1123  							this_l->send_blocks_send->setEnabled (false);
1124  							this_l->node.background ([this_w, account_l, actual] () {
1125  								if (auto this_l = this_w.lock ())
1126  								{
1127  									this_l->wallet_m->send_async (this_l->account, account_l, actual, [this_w] (std::shared_ptr<nano::block> const & block_a) {
1128  										if (auto this_l = this_w.lock ())
1129  										{
1130  											auto succeeded (block_a != nullptr);
1131  											this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, succeeded] () {
1132  												if (auto this_l = this_w.lock ())
1133  												{
1134  													this_l->send_blocks_send->setEnabled (true);
1135  													if (succeeded)
1136  													{
1137  														this_l->send_count->clear ();
1138  														this_l->send_account->clear ();
1139  														this_l->accounts.refresh ();
1140  													}
1141  													else
1142  													{
1143  														show_line_error (*this_l->send_count);
1144  													}
1145  												}
1146  											}));
1147  										}
1148  									});
1149  								}
1150  							});
1151  						}
1152  						else
1153  						{
1154  							show_button_error (*this_l->send_blocks_send);
1155  							this_l->send_blocks_send->setText ("Wallet is locked, unlock it to send");
1156  							this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1157  								if (auto this_l = this_w.lock ())
1158  								{
1159  									this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1160  										if (auto this_l = this_w.lock ())
1161  										{
1162  											show_button_ok (*this_l->send_blocks_send);
1163  											this_l->send_blocks_send->setText ("Send");
1164  										}
1165  									}));
1166  								}
1167  							});
1168  						}
1169  					}
1170  					else
1171  					{
1172  						show_line_error (*this_l->send_count);
1173  						show_button_error (*this_l->send_blocks_send);
1174  						this_l->send_blocks_send->setText ("Not enough balance");
1175  						this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1176  							if (auto this_l = this_w.lock ())
1177  							{
1178  								this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1179  									if (auto this_l = this_w.lock ())
1180  									{
1181  										show_button_ok (*this_l->send_blocks_send);
1182  										this_l->send_blocks_send->setText ("Send");
1183  									}
1184  								}));
1185  							}
1186  						});
1187  					}
1188  				}
1189  				else
1190  				{
1191  					show_line_error (*this_l->send_account);
1192  					show_button_error (*this_l->send_blocks_send);
1193  					this_l->send_blocks_send->setText ("Bad destination account");
1194  					this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1195  						if (auto this_l = this_w.lock ())
1196  						{
1197  							this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1198  								if (auto this_l = this_w.lock ())
1199  								{
1200  									show_button_ok (*this_l->send_blocks_send);
1201  									this_l->send_blocks_send->setText ("Send");
1202  								}
1203  							}));
1204  						}
1205  					});
1206  				}
1207  			}
1208  			else
1209  			{
1210  				show_line_error (*this_l->send_count);
1211  				show_button_error (*this_l->send_blocks_send);
1212  				this_l->send_blocks_send->setText ("Bad amount number");
1213  				this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1214  					if (auto this_l = this_w.lock ())
1215  					{
1216  						this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1217  							if (auto this_l = this_w.lock ())
1218  							{
1219  								show_button_ok (*this_l->send_blocks_send);
1220  								this_l->send_blocks_send->setText ("Send");
1221  							}
1222  						}));
1223  					}
1224  				});
1225  			}
1226  		}
1227  	});
1228  	QObject::connect (send_blocks_back, &QPushButton::released, [this_w] () {
1229  		if (auto this_l = this_w.lock ())
1230  		{
1231  			this_l->pop_main_stack ();
1232  		}
1233  	});
1234  	QObject::connect (send_blocks, &QPushButton::released, [this_w] () {
1235  		if (auto this_l = this_w.lock ())
1236  		{
1237  			this_l->push_main_stack (this_l->send_blocks_window);
1238  		}
1239  	});
1240  	node.observers.blocks.add ([this_w] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::uint128_t const & amount_a, bool, bool) {
1241  		if (auto this_l = this_w.lock ())
1242  		{
1243  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, status_a, account_a] () {
1244  				if (auto this_l = this_w.lock ())
1245  				{
1246  					if (this_l->wallet_m->exists (account_a))
1247  					{
1248  						this_l->accounts.refresh ();
1249  					}
1250  					if (account_a == this_l->account)
1251  					{
1252  						this_l->history.refresh ();
1253  					}
1254  				}
1255  			}));
1256  		}
1257  	});
1258  	node.observers.account_balance.add ([this_w] (nano::account const & account_a, bool is_pending) {
1259  		if (auto this_l = this_w.lock ())
1260  		{
1261  			this_l->needs_balance_refresh = this_l->needs_balance_refresh || account_a == this_l->account;
1262  		}
1263  	});
1264  	node.observers.wallet.add ([this_w] (bool active_a) {
1265  		if (auto this_l = this_w.lock ())
1266  		{
1267  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1268  				if (auto this_l = this_w.lock ())
1269  				{
1270  					if (active_a)
1271  					{
1272  						this_l->active_status.insert (nano_qt::status_types::active);
1273  					}
1274  					else
1275  					{
1276  						this_l->active_status.erase (nano_qt::status_types::active);
1277  					}
1278  				}
1279  			}));
1280  		}
1281  	});
1282  	node.observers.endpoint.add ([this_w] (std::shared_ptr<nano::transport::channel> const &) {
1283  		if (auto this_l = this_w.lock ())
1284  		{
1285  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1286  				if (auto this_l = this_w.lock ())
1287  				{
1288  					this_l->update_connected ();
1289  				}
1290  			}));
1291  		}
1292  	});
1293  	node.observers.disconnect.add ([this_w] () {
1294  		if (auto this_l = this_w.lock ())
1295  		{
1296  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1297  				if (auto this_l = this_w.lock ())
1298  				{
1299  					this_l->update_connected ();
1300  				}
1301  			}));
1302  		}
1303  	});
1304  	node.bootstrap_initiator.add_observer ([this_w] (bool active_a) {
1305  		if (auto this_l = this_w.lock ())
1306  		{
1307  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1308  				if (auto this_l = this_w.lock ())
1309  				{
1310  					if (active_a)
1311  					{
1312  						this_l->active_status.insert (nano_qt::status_types::synchronizing);
1313  					}
1314  					else
1315  					{
1316  						this_l->active_status.erase (nano_qt::status_types::synchronizing);
1317  						if (this_l->needs_deterministic_restore)
1318  						{
1319  							this_l->needs_deterministic_restore = false;
1320  							auto transaction (this_l->wallet_m->wallets.tx_begin_write ());
1321  							this_l->wallet_m->deterministic_restore (transaction);
1322  						}
1323  					}
1324  				}
1325  			}));
1326  		}
1327  	});
1328  	node.work.work_observers.add ([this_w] (bool working) {
1329  		if (auto this_l = this_w.lock ())
1330  		{
1331  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, working] () {
1332  				if (auto this_l = this_w.lock ())
1333  				{
1334  					if (working)
1335  					{
1336  						this_l->active_status.insert (nano_qt::status_types::working);
1337  					}
1338  					else
1339  					{
1340  						this_l->active_status.erase (nano_qt::status_types::working);
1341  					}
1342  				}
1343  			}));
1344  		}
1345  	});
1346  	wallet_m->lock_observer = [this_w] (bool invalid, bool vulnerable) {
1347  		if (auto this_l = this_w.lock ())
1348  		{
1349  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, invalid, vulnerable] () {
1350  				if (auto this_l = this_w.lock ())
1351  				{
1352  					this_l->settings.update_locked (invalid, vulnerable);
1353  				}
1354  			}));
1355  		}
1356  	};
1357  	settings_button->setToolTip ("Unlock wallet, set password, change representative");
1358  }
1359  void nano_qt::wallet::refresh ()
1360  {
1361  	{
1362  		auto transaction (wallet_m->wallets.tx_begin_read ());
1363  		debug_assert (wallet_m->store.exists (transaction, account));
1364  	}
1365  	self.account_text->setText (QString (account.to_account ().c_str ()));
1366  	needs_balance_refresh = true;
1367  	accounts.refresh ();
1368  	history.refresh ();
1369  	account_viewer.history.refresh ();
1370  	settings.refresh_representative ();
1371  }
1372  void nano_qt::wallet::update_connected ()
1373  {
1374  	if (node.network.empty ())
1375  	{
1376  		active_status.insert (nano_qt::status_types::disconnected);
1377  	}
1378  	else
1379  	{
1380  		active_status.erase (nano_qt::status_types::disconnected);
1381  	}
1382  }
1383  void nano_qt::wallet::empty_password ()
1384  {
1385  	this->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (3), [this] () {
1386  		auto transaction (wallet_m->wallets.tx_begin_write ());
1387  		wallet_m->enter_password (transaction, std::string (""));
1388  	});
1389  }
1390  void nano_qt::wallet::change_rendering_ratio (nano::uint128_t const & rendering_ratio_a)
1391  {
1392  	application.postEvent (&processor, new eventloop_event ([this, rendering_ratio_a] () {
1393  		this->rendering_ratio = rendering_ratio_a;
1394  		auto balance_l (this->node.balance_pending (account, false));
1395  		this->self.set_balance_text (balance_l);
1396  		this->refresh ();
1397  	}));
1398  }
1399  std::string nano_qt::wallet::format_balance (nano::uint128_t const & balance) const
1400  {
1401  	auto balance_str = nano::amount (balance).format_balance (rendering_ratio, 3, false);
1402  	auto unit = std::string ("nano");
1403  	if (rendering_ratio == nano::raw_ratio)
1404  	{
1405  		unit = std::string ("raw");
1406  	}
1407  	return balance_str + " " + unit;
1408  }
1409  void nano_qt::wallet::push_main_stack (QWidget * widget_a)
1410  {
1411  	main_stack->addWidget (widget_a);
1412  	main_stack->setCurrentIndex (main_stack->count () - 1);
1413  }
1414  void nano_qt::wallet::pop_main_stack ()
1415  {
1416  	main_stack->removeWidget (main_stack->currentWidget ());
1417  }
1418  nano_qt::settings::settings (nano_qt::wallet & wallet_a) :
1419  	window (new QWidget),
1420  	layout (new QVBoxLayout),
1421  	password (new QLineEdit),
1422  	lock_toggle (new QPushButton ("Unlock")),
1423  	sep1 (new QFrame),
1424  	new_password (new QLineEdit),
1425  	retype_password (new QLineEdit),
1426  	change (new QPushButton ("Set/Change password")),
1427  	sep2 (new QFrame),
1428  	representative (new QLabel ("Account representative:")),
1429  	current_representative (new QLabel),
1430  	new_representative (new QLineEdit),
1431  	change_rep (new QPushButton ("Change representative")),
1432  	back (new QPushButton ("Back")),
1433  	wallet (wallet_a)
1434  {
1435  	password->setPlaceholderText ("Password");
1436  	password->setEchoMode (QLineEdit::EchoMode::Password);
1437  	layout->addWidget (password);
1438  	layout->addWidget (lock_toggle);
1439  	sep1->setFrameShape (QFrame::HLine);
1440  	sep1->setFrameShadow (QFrame::Sunken);
1441  	layout->addWidget (sep1);
1442  	new_password->setEchoMode (QLineEdit::EchoMode::Password);
1443  	new_password->setPlaceholderText ("New password");
1444  	layout->addWidget (new_password);
1445  	retype_password->setEchoMode (QLineEdit::EchoMode::Password);
1446  	retype_password->setPlaceholderText ("Retype password");
1447  	layout->addWidget (retype_password);
1448  	layout->addWidget (change);
1449  	sep2->setFrameShape (QFrame::HLine);
1450  	sep2->setFrameShadow (QFrame::Sunken);
1451  	layout->addWidget (sep2);
1452  	layout->addWidget (representative);
1453  	current_representative->setTextInteractionFlags (Qt::TextSelectableByMouse);
1454  	layout->addWidget (current_representative);
1455  	new_representative->setPlaceholderText (wallet.node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1456  	layout->addWidget (new_representative);
1457  	layout->addWidget (change_rep);
1458  	layout->addStretch ();
1459  	layout->addWidget (back);
1460  	window->setLayout (layout);
1461  	QObject::connect (change, &QPushButton::released, [this] () {
1462  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1463  		if (this->wallet.wallet_m->store.valid_password (transaction))
1464  		{
1465  			if (new_password->text ().isEmpty ())
1466  			{
1467  				new_password->clear ();
1468  				new_password->setPlaceholderText ("Empty Password - try again: New password");
1469  				retype_password->clear ();
1470  				retype_password->setPlaceholderText ("Empty Password - try again: Retype password");
1471  			}
1472  			else
1473  			{
1474  				if (new_password->text () == retype_password->text ())
1475  				{
1476  					this->wallet.wallet_m->store.rekey (transaction, std::string (new_password->text ().toLocal8Bit ()));
1477  					new_password->clear ();
1478  					retype_password->clear ();
1479  					retype_password->setPlaceholderText ("Retype password");
1480  					show_button_success (*change);
1481  					change->setText ("Password was changed");
1482  					this->wallet.node.logger.try_log ("Wallet password changed");
1483  					update_locked (false, false);
1484  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1485  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1486  							show_button_ok (*change);
1487  							change->setText ("Set/Change password");
1488  						}));
1489  					});
1490  				}
1491  				else
1492  				{
1493  					retype_password->clear ();
1494  					retype_password->setPlaceholderText ("Password mismatch");
1495  				}
1496  			}
1497  		}
1498  		else
1499  		{
1500  			show_button_error (*change);
1501  			change->setText ("Wallet is locked, unlock it");
1502  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1503  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1504  					show_button_ok (*change);
1505  					change->setText ("Set/Change password");
1506  				}));
1507  			});
1508  		}
1509  	});
1510  	QObject::connect (change_rep, &QPushButton::released, [this] () {
1511  		nano::account representative_l;
1512  		if (!representative_l.decode_account (new_representative->text ().toStdString ()))
1513  		{
1514  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1515  			if (this->wallet.wallet_m->store.valid_password (transaction))
1516  			{
1517  				change_rep->setEnabled (false);
1518  				{
1519  					auto transaction_l (this->wallet.wallet_m->wallets.tx_begin_write ());
1520  					this->wallet.wallet_m->store.representative_set (transaction_l, representative_l);
1521  				}
1522  				this->wallet.wallet_m->change_sync (this->wallet.account, representative_l);
1523  				change_rep->setEnabled (true);
1524  				show_button_success (*change_rep);
1525  				change_rep->setText ("Representative was changed");
1526  				current_representative->setText (QString (representative_l.to_account ().c_str ()));
1527  				new_representative->clear ();
1528  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1529  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1530  						show_button_ok (*change_rep);
1531  						change_rep->setText ("Change representative");
1532  					}));
1533  				});
1534  			}
1535  			else
1536  			{
1537  				show_button_error (*change_rep);
1538  				change_rep->setText ("Wallet is locked, unlock it");
1539  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1540  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1541  						show_button_ok (*change_rep);
1542  						change_rep->setText ("Change representative");
1543  					}));
1544  				});
1545  			}
1546  		}
1547  		else
1548  		{
1549  			show_line_error (*new_representative);
1550  			show_button_error (*change_rep);
1551  			change_rep->setText ("Invalid account");
1552  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1553  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1554  					show_line_ok (*new_representative);
1555  					show_button_ok (*change_rep);
1556  					change_rep->setText ("Change representative");
1557  				}));
1558  			});
1559  		}
1560  	});
1561  	QObject::connect (back, &QPushButton::released, [this] () {
1562  		debug_assert (this->wallet.main_stack->currentWidget () == window);
1563  		this->wallet.pop_main_stack ();
1564  	});
1565  	QObject::connect (lock_toggle, &QPushButton::released, [this] () {
1566  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1567  		if (this->wallet.wallet_m->store.valid_password (transaction))
1568  		{
1569  			nano::raw_key empty;
1570  			empty.clear ();
1571  			this->wallet.wallet_m->store.password.value_set (empty);
1572  			update_locked (true, true);
1573  			lock_toggle->setText ("Unlock");
1574  			this->wallet.node.logger.try_log ("Wallet locked");
1575  			password->setEnabled (1);
1576  		}
1577  		else
1578  		{
1579  			if (!this->wallet.wallet_m->enter_password (transaction, std::string (password->text ().toLocal8Bit ())))
1580  			{
1581  				password->clear ();
1582  				lock_toggle->setText ("Lock");
1583  				password->setDisabled (1);
1584  			}
1585  			else
1586  			{
1587  				show_line_error (*password);
1588  				show_button_error (*lock_toggle);
1589  				lock_toggle->setText ("Invalid password");
1590  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1591  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1592  						show_line_ok (*password);
1593  						show_button_ok (*lock_toggle);
1594  						auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1595  						if (!this->wallet.wallet_m->store.valid_password (transaction))
1596  						{
1597  							lock_toggle->setText ("Unlock");
1598  						}
1599  					}));
1600  				});
1601  			}
1602  		}
1603  	});
1604  	QObject::connect (new_representative, &QLineEdit::textChanged, [this] (const QString & value) {
1605  		auto pos = new_representative->cursorPosition ();
1606  		new_representative->setText (value.trimmed ());
1607  		new_representative->setCursorPosition (pos);
1608  	});
1609  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1610  	if (this->wallet.wallet_m->store.valid_password (transaction))
1611  	{
1612  		lock_toggle->setText ("Lock");
1613  		password->setDisabled (1);
1614  	}
1615  	representative->setToolTip ("In the infrequent case where the network needs to make a global decision,\nyour wallet software performs a balance-weighted vote to determine\nthe outcome. Since not everyone can remain online and perform this duty,\nyour wallet names a representative that can vote with, but cannot spend,\nyour balance.");
1616  	refresh_representative ();
1617  }
1618  void nano_qt::settings::refresh_representative ()
1619  {
1620  	auto transaction (this->wallet.wallet_m->wallets.node.store.tx_begin_read ());
1621  	nano::account_info info;
1622  	auto error (wallet.node.store.account.get (transaction, this->wallet.account, info));
1623  	if (!error)
1624  	{
1625  		current_representative->setText (QString (info.representative.to_account ().c_str ()));
1626  	}
1627  	else
1628  	{
1629  		auto wallet_transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1630  		current_representative->setText (this->wallet.wallet_m->store.representative (wallet_transaction).to_account ().c_str ());
1631  	}
1632  }
1633  void nano_qt::settings::activate ()
1634  {
1635  	this->wallet.push_main_stack (window);
1636  }
1637  void nano_qt::settings::update_locked (bool invalid, bool vulnerable)
1638  {
1639  	if (invalid)
1640  	{
1641  		this->wallet.active_status.insert (nano_qt::status_types::locked);
1642  	}
1643  	else
1644  	{
1645  		this->wallet.active_status.erase (nano_qt::status_types::locked);
1646  	}
1647  	if (vulnerable)
1648  	{
1649  		this->wallet.active_status.insert (nano_qt::status_types::vulnerable);
1650  	}
1651  	else
1652  	{
1653  		this->wallet.active_status.erase (nano_qt::status_types::vulnerable);
1654  	}
1655  }
1656  nano_qt::advanced_actions::advanced_actions (nano_qt::wallet & wallet_a) :
1657  	window (new QWidget),
1658  	layout (new QVBoxLayout),
1659  	show_ledger (new QPushButton ("Ledger")),
1660  	show_peers (new QPushButton ("Peers")),
1661  	search_for_receivables (new QPushButton ("Search for receivables")),
1662  	bootstrap (new QPushButton ("Initiate bootstrap")),
1663  	wallet_refresh (new QPushButton ("Refresh Wallet")),
1664  	create_block (new QPushButton ("Create Block")),
1665  	enter_block (new QPushButton ("Enter Block")),
1666  	block_viewer (new QPushButton ("Block Viewer")),
1667  	account_viewer (new QPushButton ("Account Viewer")),
1668  	stats_viewer (new QPushButton ("Node Statistics")),
1669  	scale_window (new QWidget),
1670  	scale_layout (new QHBoxLayout),
1671  	scale_label (new QLabel ("Scale:")),
1672  	ratio_group (new QButtonGroup),
1673  	nano_unit (new QRadioButton ("nano")),
1674  	raw_unit (new QRadioButton ("raw")),
1675  	back (new QPushButton ("Back")),
1676  	ledger_window (new QWidget),
1677  	ledger_layout (new QVBoxLayout),
1678  	ledger_model (new QStandardItemModel),
1679  	ledger_view (new QTableView),
1680  	ledger_refresh (new QPushButton ("Refresh")),
1681  	ledger_back (new QPushButton ("Back")),
1682  	peers_window (new QWidget),
1683  	peers_layout (new QVBoxLayout),
1684  	peers_model (new QStandardItemModel),
1685  	peers_view (new QTableView),
1686  	peer_summary_layout (new QHBoxLayout),
1687  	bootstrap_label (new QLabel ("IPV6:port \"::ffff:192.168.0.1:7075\"")),
1688  	peer_count_label (new QLabel ("")),
1689  	bootstrap_line (new QLineEdit),
1690  	peers_bootstrap (new QPushButton ("Initiate Bootstrap")),
1691  	peers_refresh (new QPushButton ("Refresh")),
1692  	peers_back (new QPushButton ("Back")),
1693  	wallet (wallet_a)
1694  {
1695  	ratio_group->addButton (nano_unit);
1696  	ratio_group->setId (nano_unit, ratio_group->buttons ().size () - 1);
1697  	ratio_group->addButton (raw_unit);
1698  	ratio_group->setId (raw_unit, ratio_group->buttons ().size () - 1);
1699  	scale_layout->addWidget (scale_label);
1700  	scale_layout->addWidget (nano_unit);
1701  	scale_layout->addWidget (raw_unit);
1702  	scale_window->setLayout (scale_layout);
1703  	ledger_model->setHorizontalHeaderItem (0, new QStandardItem ("Account"));
1704  	ledger_model->setHorizontalHeaderItem (1, new QStandardItem ("Balance"));
1705  	ledger_model->setHorizontalHeaderItem (2, new QStandardItem ("Block"));
1706  	ledger_view->setModel (ledger_model);
1707  	ledger_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1708  	ledger_view->verticalHeader ()->hide ();
1709  	ledger_view->horizontalHeader ()->setStretchLastSection (true);
1710  	ledger_layout->addWidget (ledger_view);
1711  	ledger_layout->addWidget (ledger_refresh);
1712  	ledger_layout->addWidget (ledger_back);
1713  	ledger_layout->setContentsMargins (0, 0, 0, 0);
1714  	ledger_window->setLayout (ledger_layout);
1715  	peers_model->setHorizontalHeaderItem (0, new QStandardItem ("IPv6 address:port"));
1716  	peers_model->setHorizontalHeaderItem (1, new QStandardItem ("Net version"));
1717  	peers_model->setHorizontalHeaderItem (2, new QStandardItem ("Node ID"));
1718  	peers_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1719  	peers_view->verticalHeader ()->hide ();
1720  	peers_view->setModel (peers_model);
1721  	peers_view->setColumnWidth (0, 220);
1722  	peers_view->setSortingEnabled (true);
1723  	peers_view->horizontalHeader ()->setStretchLastSection (true);
1724  	peers_layout->addWidget (peers_view);
1725  	peer_summary_layout->addWidget (bootstrap_label);
1726  	peer_summary_layout->addStretch ();
1727  	peer_summary_layout->addWidget (peer_count_label);
1728  	peers_layout->addLayout (peer_summary_layout);
1729  	peers_layout->addWidget (bootstrap_line);
1730  	peers_layout->addWidget (peers_bootstrap);
1731  	peers_layout->addWidget (peers_refresh);
1732  	peers_layout->addWidget (peers_back);
1733  	peers_layout->setContentsMargins (0, 0, 0, 0);
1734  	peers_window->setLayout (peers_layout);
1735  	layout->addWidget (show_ledger);
1736  	layout->addWidget (show_peers);
1737  	layout->addWidget (search_for_receivables);
1738  	layout->addWidget (bootstrap);
1739  	layout->addWidget (wallet_refresh);
1740  	layout->addWidget (create_block);
1741  	layout->addWidget (enter_block);
1742  	layout->addWidget (block_viewer);
1743  	layout->addWidget (account_viewer);
1744  	layout->addWidget (stats_viewer);
1745  	layout->addWidget (scale_window);
1746  	layout->addStretch ();
1747  	layout->addWidget (back);
1748  	window->setLayout (layout);
1749  	QObject::connect (nano_unit, &QRadioButton::toggled, [this] () {
1750  		if (nano_unit->isChecked ())
1751  		{
1752  			this->wallet.change_rendering_ratio (nano::Mxrb_ratio);
1753  			QSettings ().setValue (saved_ratio_key, ratio_group->id (nano_unit));
1754  		}
1755  	});
1756  	QObject::connect (raw_unit, &QRadioButton::toggled, [this] () {
1757  		if (raw_unit->isChecked ())
1758  		{
1759  			this->wallet.change_rendering_ratio (nano::raw_ratio);
1760  			QSettings ().setValue (saved_ratio_key, ratio_group->id (raw_unit));
1761  		}
1762  	});
1763  	auto selected_ratio_button = ratio_group->button (QSettings ().value (saved_ratio_key).toInt ());
1764  	if (selected_ratio_button == nullptr)
1765  	{
1766  		selected_ratio_button = nano_unit;
1767  	}
1768  	debug_assert (selected_ratio_button != nullptr);
1769  	selected_ratio_button->click ();
1770  	QSettings ().setValue (saved_ratio_key, ratio_group->id (selected_ratio_button));
1771  	QObject::connect (wallet_refresh, &QPushButton::released, [this] () {
1772  		this->wallet.accounts.refresh ();
1773  		this->wallet.accounts.refresh_wallet_balance ();
1774  	});
1775  	QObject::connect (show_peers, &QPushButton::released, [this] () {
1776  		refresh_peers ();
1777  		this->wallet.push_main_stack (peers_window);
1778  	});
1779  	QObject::connect (show_ledger, &QPushButton::released, [this] () {
1780  		this->wallet.push_main_stack (ledger_window);
1781  	});
1782  	QObject::connect (back, &QPushButton::released, [this] () {
1783  		this->wallet.pop_main_stack ();
1784  	});
1785  	QObject::connect (peers_back, &QPushButton::released, [this] () {
1786  		this->wallet.pop_main_stack ();
1787  	});
1788  	QObject::connect (peers_bootstrap, &QPushButton::released, [this] () {
1789  		nano::endpoint endpoint;
1790  		auto error (nano::parse_endpoint (bootstrap_line->text ().toStdString (), endpoint));
1791  		if (!error)
1792  		{
1793  			show_line_ok (*bootstrap_line);
1794  			bootstrap_line->clear ();
1795  			this->wallet.node.bootstrap_initiator.bootstrap (endpoint);
1796  		}
1797  		else
1798  		{
1799  			show_line_error (*bootstrap_line);
1800  		}
1801  	});
1802  	QObject::connect (peers_refresh, &QPushButton::released, [this] () {
1803  		refresh_peers ();
1804  	});
1805  	QObject::connect (ledger_refresh, &QPushButton::released, [this] () {
1806  		refresh_ledger ();
1807  	});
1808  	QObject::connect (ledger_back, &QPushButton::released, [this] () {
1809  		this->wallet.pop_main_stack ();
1810  	});
1811  	QObject::connect (search_for_receivables, &QPushButton::released, [this] () {
1812  		std::thread ([this] { this->wallet.wallet_m->search_receivable (this->wallet.wallet_m->wallets.tx_begin_read ()); }).detach ();
1813  	});
1814  	QObject::connect (bootstrap, &QPushButton::released, [this] () {
1815  		std::thread ([this] { this->wallet.node.bootstrap_initiator.bootstrap (); }).detach ();
1816  	});
1817  	QObject::connect (create_block, &QPushButton::released, [this] () {
1818  		this->wallet.push_main_stack (this->wallet.block_creation.window);
1819  	});
1820  	QObject::connect (enter_block, &QPushButton::released, [this] () {
1821  		this->wallet.push_main_stack (this->wallet.block_entry.window);
1822  	});
1823  	QObject::connect (block_viewer, &QPushButton::released, [this] () {
1824  		this->wallet.push_main_stack (this->wallet.block_viewer.window);
1825  	});
1826  	QObject::connect (account_viewer, &QPushButton::released, [this] () {
1827  		this->wallet.push_main_stack (this->wallet.account_viewer.window);
1828  	});
1829  	QObject::connect (stats_viewer, &QPushButton::released, [this] () {
1830  		this->wallet.push_main_stack (this->wallet.stats_viewer.window);
1831  		this->wallet.stats_viewer.refresh_stats ();
1832  	});
1833  	bootstrap->setToolTip ("Multi-connection bootstrap to random peers");
1834  	search_for_receivables->setToolTip ("Search for ready to be received blocks");
1835  	create_block->setToolTip ("Create block in JSON format");
1836  	enter_block->setToolTip ("Enter block in JSON format");
1837  }
1838  void nano_qt::advanced_actions::refresh_peers ()
1839  {
1840  	peers_model->removeRows (0, peers_model->rowCount ());
1841  	auto list (wallet.node.network.list (std::numeric_limits<size_t>::max ()));
1842  	std::sort (list.begin (), list.end (), [] (auto const & lhs, auto const & rhs) {
1843  		return lhs->get_endpoint () < rhs->get_endpoint ();
1844  	});
1845  	for (auto i (list.begin ()), n (list.end ()); i != n; ++i)
1846  	{
1847  		std::stringstream endpoint;
1848  		auto channel (*i);
1849  		endpoint << channel->to_string ();
1850  		QString qendpoint (endpoint.str ().c_str ());
1851  		QList<QStandardItem *> items;
1852  		items.push_back (new QStandardItem (qendpoint));
1853  		auto version = new QStandardItem ();
1854  		version->setData (QVariant (channel->get_network_version ()), Qt::DisplayRole);
1855  		items.push_back (version);
1856  		QString node_id ("");
1857  		auto node_id_l (channel->get_node_id_optional ());
1858  		if (node_id_l.is_initialized ())
1859  		{
1860  			node_id = node_id_l.get ().to_account ().c_str ();
1861  		}
1862  		items.push_back (new QStandardItem (node_id));
1863  		peers_model->appendRow (items);
1864  	}
1865  	peer_count_label->setText (QString ("%1 peers").arg (peers_model->rowCount ()));
1866  }
1867  void nano_qt::advanced_actions::refresh_ledger ()
1868  {
1869  	ledger_model->removeRows (0, ledger_model->rowCount ());
1870  	auto transaction (wallet.node.store.tx_begin_read ());
1871  	for (auto i (wallet.node.ledger.store.account.begin (transaction)), j (wallet.node.ledger.store.account.end ()); i != j; ++i)
1872  	{
1873  		QList<QStandardItem *> items;
1874  		items.push_back (new QStandardItem (QString (i->first.to_account ().c_str ())));
1875  		nano::account_info const & info (i->second);
1876  		std::string balance;
1877  		nano::amount (info.balance.number () / wallet.rendering_ratio).encode_dec (balance);
1878  		items.push_back (new QStandardItem (QString (balance.c_str ())));
1879  		std::string block_hash;
1880  		info.head.encode_hex (block_hash);
1881  		items.push_back (new QStandardItem (QString (block_hash.c_str ())));
1882  		ledger_model->appendRow (items);
1883  	}
1884  }
1885  void nano_qt::advanced_actions::refresh_stats ()
1886  {
1887  	wallet.stats_viewer.refresh_stats ();
1888  }
1889  nano_qt::block_entry::block_entry (nano_qt::wallet & wallet_a) :
1890  	window (new QWidget),
1891  	layout (new QVBoxLayout),
1892  	block (new QPlainTextEdit),
1893  	status (new QLabel),
1894  	process (new QPushButton ("Process")),
1895  	back (new QPushButton ("Back")),
1896  	wallet (wallet_a)
1897  {
1898  	layout->addWidget (block);
1899  	layout->addWidget (status);
1900  	layout->addWidget (process);
1901  	layout->addWidget (back);
1902  	window->setLayout (layout);
1903  	QObject::connect (process, &QPushButton::released, [this] () {
1904  		auto string (block->toPlainText ().toStdString ());
1905  		try
1906  		{
1907  			boost::property_tree::ptree tree;
1908  			std::stringstream istream (string);
1909  			boost::property_tree::read_json (istream, tree);
1910  			auto block_l (nano::deserialize_block_json (tree));
1911  			if (block_l != nullptr)
1912  			{
1913  				show_label_ok (*status);
1914  				this->status->setText ("");
1915  				if (!this->wallet.node.network_params.work.validate_entry (*block_l))
1916  				{
1917  					this->wallet.node.process_active (std::move (block_l));
1918  				}
1919  				else
1920  				{
1921  					show_label_error (*status);
1922  					this->status->setText ("Invalid work");
1923  				}
1924  			}
1925  			else
1926  			{
1927  				show_label_error (*status);
1928  				this->status->setText ("Unable to parse block");
1929  			}
1930  		}
1931  		catch (std::runtime_error const &)
1932  		{
1933  			show_label_error (*status);
1934  			this->status->setText ("Unable to parse block");
1935  		}
1936  	});
1937  	QObject::connect (back, &QPushButton::released, [this] () {
1938  		this->wallet.pop_main_stack ();
1939  	});
1940  }
1941  nano_qt::block_creation::block_creation (nano_qt::wallet & wallet_a) :
1942  	window (new QWidget),
1943  	layout (new QVBoxLayout),
1944  	group (new QButtonGroup),
1945  	button_layout (new QHBoxLayout),
1946  	send (new QRadioButton ("Send")),
1947  	receive (new QRadioButton ("Receive")),
1948  	change (new QRadioButton ("Change")),
1949  	open (new QRadioButton ("Open")),
1950  	account_label (new QLabel ("Account:")),
1951  	account (new QLineEdit),
1952  	source_label (new QLabel ("Source:")),
1953  	source (new QLineEdit),
1954  	amount_label (new QLabel ("Amount:")),
1955  	amount (new QLineEdit),
1956  	destination_label (new QLabel ("Destination:")),
1957  	destination (new QLineEdit),
1958  	representative_label (new QLabel ("Representative:")),
1959  	representative (new QLineEdit),
1960  	block (new QPlainTextEdit),
1961  	status (new QLabel),
1962  	create (new QPushButton ("Create")),
1963  	back (new QPushButton ("Back")),
1964  	wallet (wallet_a)
1965  {
1966  	group->addButton (send);
1967  	group->addButton (receive);
1968  	group->addButton (change);
1969  	group->addButton (open);
1970  	group->setId (send, 0);
1971  	group->setId (receive, 1);
1972  	group->setId (change, 2);
1973  	group->setId (open, 3);
1974  	button_layout->addWidget (send);
1975  	button_layout->addWidget (receive);
1976  	button_layout->addWidget (open);
1977  	button_layout->addWidget (change);
1978  	layout->addLayout (button_layout);
1979  	layout->addWidget (account_label);
1980  	layout->addWidget (account);
1981  	layout->addWidget (source_label);
1982  	layout->addWidget (source);
1983  	layout->addWidget (amount_label);
1984  	layout->addWidget (amount);
1985  	layout->addWidget (destination_label);
1986  	layout->addWidget (destination);
1987  	layout->addWidget (representative_label);
1988  	layout->addWidget (representative);
1989  	layout->addWidget (block);
1990  	layout->addWidget (status);
1991  	layout->addWidget (create);
1992  	layout->addWidget (back);
1993  	window->setLayout (layout);
1994  	QObject::connect (send, &QRadioButton::toggled, [this] (bool on) {
1995  		if (on)
1996  		{
1997  			deactivate_all ();
1998  			activate_send ();
1999  		}
2000  	});
2001  	QObject::connect (receive, &QRadioButton::toggled, [this] (bool on) {
2002  		if (on)
2003  		{
2004  			deactivate_all ();
2005  			activate_receive ();
2006  		}
2007  	});
2008  	QObject::connect (open, &QRadioButton::toggled, [this] (bool on) {
2009  		if (on)
2010  		{
2011  			deactivate_all ();
2012  			activate_open ();
2013  		}
2014  	});
2015  	QObject::connect (change, &QRadioButton::toggled, [this] (bool on) {
2016  		if (on)
2017  		{
2018  			deactivate_all ();
2019  			activate_change ();
2020  		}
2021  	});
2022  	QObject::connect (create, &QPushButton::released, [this] () {
2023  		switch (group->checkedId ())
2024  		{
2025  			case 0:
2026  				create_send ();
2027  				break;
2028  			case 1:
2029  				create_receive ();
2030  				break;
2031  			case 2:
2032  				create_change ();
2033  				break;
2034  			case 3:
2035  				create_open ();
2036  				break;
2037  			default:
2038  				debug_assert (false);
2039  				break;
2040  		}
2041  	});
2042  	QObject::connect (back, &QPushButton::released, [this] () {
2043  		this->wallet.pop_main_stack ();
2044  	});
2045  	QObject::connect (account, &QLineEdit::textChanged, [this] (const QString & value) {
2046  		auto pos = account->cursorPosition ();
2047  		account->setText (value.trimmed ());
2048  		account->setCursorPosition (pos);
2049  	});
2050  	QObject::connect (destination, &QLineEdit::textChanged, [this] (const QString & value) {
2051  		auto pos = destination->cursorPosition ();
2052  		destination->setText (value.trimmed ());
2053  		destination->setCursorPosition (pos);
2054  	});
2055  	QObject::connect (amount, &QLineEdit::textChanged, [this] (const QString & value) {
2056  		auto pos = amount->cursorPosition ();
2057  		amount->setText (value.trimmed ());
2058  		amount->setCursorPosition (pos);
2059  	});
2060  	QObject::connect (source, &QLineEdit::textChanged, [this] (const QString & value) {
2061  		auto pos = source->cursorPosition ();
2062  		source->setText (value.trimmed ());
2063  		source->setCursorPosition (pos);
2064  	});
2065  	QObject::connect (representative, &QLineEdit::textChanged, [this] (const QString & value) {
2066  		auto pos = representative->cursorPosition ();
2067  		representative->setText (value.trimmed ());
2068  		representative->setCursorPosition (pos);
2069  	});
2070  	send->click ();
2071  }
2072  void nano_qt::block_creation::deactivate_all ()
2073  {
2074  	account_label->hide ();
2075  	account->hide ();
2076  	source_label->hide ();
2077  	source->hide ();
2078  	amount_label->hide ();
2079  	amount->hide ();
2080  	destination_label->hide ();
2081  	destination->hide ();
2082  	representative_label->hide ();
2083  	representative->hide ();
2084  }
2085  void nano_qt::block_creation::activate_send ()
2086  {
2087  	account_label->show ();
2088  	account->show ();
2089  	amount_label->show ();
2090  	amount->show ();
2091  	destination_label->show ();
2092  	destination->show ();
2093  }
2094  void nano_qt::block_creation::activate_receive ()
2095  {
2096  	source_label->show ();
2097  	source->show ();
2098  }
2099  void nano_qt::block_creation::activate_open ()
2100  {
2101  	source_label->show ();
2102  	source->show ();
2103  	representative_label->show ();
2104  	representative->show ();
2105  }
2106  void nano_qt::block_creation::activate_change ()
2107  {
2108  	account_label->show ();
2109  	account->show ();
2110  	representative_label->show ();
2111  	representative->show ();
2112  }
2113  void nano_qt::block_creation::create_send ()
2114  {
2115  	nano::account account_l;
2116  	auto error (account_l.decode_account (account->text ().toStdString ()));
2117  	if (!error)
2118  	{
2119  		nano::amount amount_l;
2120  		error = amount_l.decode_dec (amount->text ().toStdString ());
2121  		if (!error)
2122  		{
2123  			nano::account destination_l;
2124  			error = destination_l.decode_account (destination->text ().toStdString ());
2125  			if (!error)
2126  			{
2127  				auto transaction (wallet.node.wallets.tx_begin_read ());
2128  				auto block_transaction (wallet.node.store.tx_begin_read ());
2129  				nano::raw_key key;
2130  				if (!wallet.wallet_m->store.fetch (transaction, account_l, key))
2131  				{
2132  					auto balance (wallet.node.ledger.account_balance (block_transaction, account_l));
2133  					if (amount_l.number () <= balance)
2134  					{
2135  						nano::account_info info;
2136  						auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2137  						(void)error;
2138  						debug_assert (!error);
2139  						nano::state_block send (account_l, info.head, info.representative, balance - amount_l.number (), destination_l, key, account_l, 0);
2140  						nano::block_details details;
2141  						details.is_send = true;
2142  						details.epoch = info.epoch ();
2143  						auto const required_difficulty{ wallet.node.network_params.work.threshold (send.work_version (), details) };
2144  						if (wallet.node.work_generate_blocking (send, required_difficulty).is_initialized ())
2145  						{
2146  							std::string block_l;
2147  							send.serialize_json (block_l);
2148  							block->setPlainText (QString (block_l.c_str ()));
2149  							show_label_ok (*status);
2150  							status->setText ("Created block");
2151  						}
2152  						else
2153  						{
2154  							debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (send.work_version ()));
2155  							show_label_error (*status);
2156  							if (wallet.node.work_generation_enabled ())
2157  							{
2158  								status->setText ("Work generation failure");
2159  							}
2160  							else
2161  							{
2162  								status->setText ("Work generation is disabled");
2163  							}
2164  						}
2165  					}
2166  					else
2167  					{
2168  						show_label_error (*status);
2169  						status->setText ("Insufficient balance");
2170  					}
2171  				}
2172  				else
2173  				{
2174  					show_label_error (*status);
2175  					status->setText ("Account is not in wallet");
2176  				}
2177  			}
2178  			else
2179  			{
2180  				show_label_error (*status);
2181  				status->setText ("Unable to decode destination");
2182  			}
2183  		}
2184  		else
2185  		{
2186  			show_label_error (*status);
2187  			status->setText ("Unable to decode amount");
2188  		}
2189  	}
2190  	else
2191  	{
2192  		show_label_error (*status);
2193  		status->setText ("Unable to decode account");
2194  	}
2195  }
2196  void nano_qt::block_creation::create_receive ()
2197  {
2198  	nano::block_hash source_l;
2199  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2200  	if (!error)
2201  	{
2202  		auto transaction (wallet.node.wallets.tx_begin_read ());
2203  		auto block_transaction (wallet.node.store.tx_begin_read ());
2204  		auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2205  		if (block_l != nullptr)
2206  		{
2207  			auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2208  			if (!destination.is_zero ())
2209  			{
2210  				nano::pending_key pending_key (destination, source_l);
2211  				nano::pending_info pending;
2212  				if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2213  				{
2214  					nano::account_info info;
2215  					auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2216  					if (!error)
2217  					{
2218  						nano::raw_key key;
2219  						auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2220  						if (!error)
2221  						{
2222  							nano::state_block receive (pending_key.account, info.head, info.representative, info.balance.number () + pending.amount.number (), source_l, key, pending_key.account, 0);
2223  							nano::block_details details;
2224  							details.is_receive = true;
2225  							details.epoch = std::max (info.epoch (), pending.epoch);
2226  							auto required_difficulty{ wallet.node.network_params.work.threshold (receive.work_version (), details) };
2227  							if (wallet.node.work_generate_blocking (receive, required_difficulty).is_initialized ())
2228  							{
2229  								std::string block_l;
2230  								receive.serialize_json (block_l);
2231  								block->setPlainText (QString (block_l.c_str ()));
2232  								show_label_ok (*status);
2233  								status->setText ("Created block");
2234  							}
2235  							else
2236  							{
2237  								debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (receive.work_version ()));
2238  								show_label_error (*status);
2239  								if (wallet.node.work_generation_enabled ())
2240  								{
2241  									status->setText ("Work generation failure");
2242  								}
2243  								else
2244  								{
<span onclick='openModal()' class='match'>2245  									status->setText ("Work generation is disabled");
2246  								}
2247  							}
2248  						}
2249  						else
2250  						{
2251  							show_label_error (*status);
2252  							status->setText ("Account is not in wallet");
2253  						}
</span>2254  					}
2255  					else
2256  					{
2257  						show_label_error (*status);
2258  						status->setText ("Account not yet open");
2259  					}
2260  				}
2261  				else
2262  				{
2263  					show_label_error (*status);
2264  					status->setText ("Source block is not ready to be received");
2265  				}
2266  			}
2267  			else
2268  			{
2269  				show_label_error (*status);
2270  				status->setText ("Source is not a send block");
2271  			}
2272  		}
2273  		else
2274  		{
2275  			show_label_error (*status);
2276  			status->setText ("Source block not found");
2277  		}
2278  	}
2279  	else
2280  	{
2281  		show_label_error (*status);
2282  		status->setText ("Unable to decode source");
2283  	}
2284  }
2285  void nano_qt::block_creation::create_change ()
2286  {
2287  	nano::account account_l;
2288  	auto error (account_l.decode_account (account->text ().toStdString ()));
2289  	if (!error)
2290  	{
2291  		nano::account representative_l;
2292  		error = representative_l.decode_account (representative->text ().toStdString ());
2293  		if (!error)
2294  		{
2295  			auto transaction (wallet.node.wallets.tx_begin_read ());
2296  			auto block_transaction (wallet.node.store.tx_begin_read ());
2297  			nano::account_info info;
2298  			auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2299  			if (!error)
2300  			{
2301  				nano::raw_key key;
2302  				auto error (wallet.wallet_m->store.fetch (transaction, account_l, key));
2303  				if (!error)
2304  				{
2305  					nano::state_block change (account_l, info.head, representative_l, info.balance, 0, key, account_l, 0);
2306  					nano::block_details details;
2307  					details.epoch = info.epoch ();
2308  					auto const required_difficulty{ wallet.node.network_params.work.threshold (change.work_version (), details) };
2309  					if (wallet.node.work_generate_blocking (change, required_difficulty).is_initialized ())
2310  					{
2311  						std::string block_l;
2312  						change.serialize_json (block_l);
2313  						block->setPlainText (QString (block_l.c_str ()));
2314  						show_label_ok (*status);
2315  						status->setText ("Created block");
2316  					}
2317  					else
2318  					{
2319  						debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (change.work_version ()));
2320  						show_label_error (*status);
2321  						if (wallet.node.work_generation_enabled ())
2322  						{
2323  							status->setText ("Work generation failure");
2324  						}
2325  						else
2326  						{
2327  							status->setText ("Work generation is disabled");
2328  						}
2329  					}
2330  				}
2331  				else
2332  				{
2333  					show_label_error (*status);
2334  					status->setText ("Account is not in wallet");
2335  				}
2336  			}
2337  			else
2338  			{
2339  				show_label_error (*status);
2340  				status->setText ("Account not yet open");
2341  			}
2342  		}
2343  		else
2344  		{
2345  			show_label_error (*status);
2346  			status->setText ("Unable to decode representative");
2347  		}
2348  	}
2349  	else
2350  	{
2351  		show_label_error (*status);
2352  		status->setText ("Unable to decode account");
2353  	}
2354  }
2355  void nano_qt::block_creation::create_open ()
2356  {
2357  	nano::block_hash source_l;
2358  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2359  	if (!error)
2360  	{
2361  		nano::account representative_l;
2362  		error = representative_l.decode_account (representative->text ().toStdString ());
2363  		if (!error)
2364  		{
2365  			auto transaction (wallet.node.wallets.tx_begin_read ());
2366  			auto block_transaction (wallet.node.store.tx_begin_read ());
2367  			auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2368  			if (block_l != nullptr)
2369  			{
2370  				auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2371  				if (!destination.is_zero ())
2372  				{
2373  					nano::pending_key pending_key (destination, source_l);
2374  					nano::pending_info pending;
2375  					if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2376  					{
2377  						nano::account_info info;
2378  						auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2379  						if (error)
2380  						{
2381  							nano::raw_key key;
2382  							auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2383  							if (!error)
2384  							{
2385  								nano::state_block open (pending_key.account, 0, representative_l, pending.amount, source_l, key, pending_key.account, 0);
2386  								nano::block_details details;
2387  								details.is_receive = true;
2388  								details.epoch = pending.epoch;
2389  								auto const required_difficulty{ wallet.node.network_params.work.threshold (open.work_version (), details) };
2390  								if (wallet.node.work_generate_blocking (open, required_difficulty).is_initialized ())
2391  								{
2392  									std::string block_l;
2393  									open.serialize_json (block_l);
2394  									block->setPlainText (QString (block_l.c_str ()));
2395  									show_label_ok (*status);
2396  									status->setText ("Created block");
2397  								}
2398  								else
2399  								{
2400  									debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (open.work_version ()));
2401  									show_label_error (*status);
2402  									if (wallet.node.work_generation_enabled ())
2403  									{
2404  										status->setText ("Work generation failure");
2405  									}
2406  									else
2407  									{
2408  										status->setText ("Work generation is disabled");
2409  									}
2410  								}
2411  							}
2412  							else
2413  							{
2414  								show_label_error (*status);
2415  								status->setText ("Account is not in wallet");
2416  							}
2417  						}
2418  						else
2419  						{
2420  							show_label_error (*status);
2421  							status->setText ("Account already open");
2422  						}
2423  					}
2424  					else
2425  					{
2426  						show_label_error (*status);
2427  						status->setText ("Source block is not ready to be received");
2428  					}
2429  				}
2430  				else
2431  				{
2432  					show_label_error (*status);
2433  					status->setText ("Source is not a send block");
2434  				}
2435  			}
2436  			else
2437  			{
2438  				show_label_error (*status);
2439  				status->setText ("Source block not found");
2440  			}
2441  		}
2442  		else
2443  		{
2444  			show_label_error (*status);
2445  			status->setText ("Unable to decode representative");
2446  		}
2447  	}
2448  	else
2449  	{
2450  		show_label_error (*status);
2451  		status->setText ("Unable to decode source");
2452  	}
2453  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/qt/qt.hpp>
3  #include <boost/foreach.hpp>
4  #include <boost/property_tree/json_parser.hpp>
5  #include <boost/property_tree/ptree.hpp>
6  #include <cmath>
7  #include <iomanip>
8  #include <sstream>
9  namespace
10  {
11  void show_line_error (QLineEdit & line)
12  {
13  	line.setStyleSheet ("QLineEdit { color: red }");
14  }
15  void show_line_ok (QLineEdit & line)
16  {
17  	line.setStyleSheet ("QLineEdit { color: black }");
18  }
19  void show_label_error (QLabel & label)
20  {
21  	label.setStyleSheet ("QLabel { color: red }");
22  }
23  void show_label_ok (QLabel & label)
24  {
25  	label.setStyleSheet ("QLabel { color: black }");
26  }
27  void show_button_error (QPushButton & button)
28  {
29  	button.setStyleSheet ("QPushButton { color: red }");
30  }
31  void show_button_ok (QPushButton & button)
32  {
33  	button.setStyleSheet ("QPushButton { color: black }");
34  }
35  void show_button_success (QPushButton & button)
36  {
37  	button.setStyleSheet ("QPushButton { color: blue }");
38  }
39  }
40  bool nano_qt::eventloop_processor::event (QEvent * event_a)
41  {
42  	debug_assert (dynamic_cast<nano_qt::eventloop_event *> (event_a) != nullptr);
43  	static_cast<nano_qt::eventloop_event *> (event_a)->action ();
44  	return true;
45  }
46  nano_qt::eventloop_event::eventloop_event (std::function<void ()> const & action_a) :
47  	QEvent (QEvent::Type::User),
48  	action (action_a)
49  {
50  }
51  nano_qt::self_pane::self_pane (nano_qt::wallet & wallet_a, nano::account const & account_a) :
52  	window (new QWidget),
53  	layout (new QVBoxLayout),
54  	self_layout (new QHBoxLayout),
55  	self_window (new QWidget),
56  	your_account_label (new QLabel ("Your Nano account:")),
57  	account_window (new QWidget),
58  	account_layout (new QHBoxLayout),
59  	account_text (new QLineEdit),
60  	copy_button (new QPushButton ("Copy")),
61  	balance_window (new QWidget),
62  	balance_layout (new QHBoxLayout),
63  	balance_label (new QLabel),
64  	wallet (wallet_a)
65  {
66  	your_account_label->setStyleSheet ("font-weight: bold;");
67  	std::string network = wallet.node.network_params.network.get_current_network_as_string ();
68  	if (!network.empty ())
69  	{
70  		network[0] = std::toupper (network[0]);
71  	}
72  	version = new QLabel (boost::str (boost::format ("%1% %2% network") % NANO_VERSION_STRING % network).c_str ());
73  	self_layout->addWidget (your_account_label);
74  	self_layout->addStretch ();
75  	self_layout->addWidget (version);
76  	self_layout->setContentsMargins (0, 0, 0, 0);
77  	self_window->setLayout (self_layout);
78  	account_text->setReadOnly (true);
79  	account_text->setStyleSheet ("QLineEdit{ background: #ddd; }");
80  	account_layout->addWidget (account_text, 9);
81  	account_layout->addWidget (copy_button, 1);
82  	account_layout->setContentsMargins (0, 0, 0, 0);
83  	account_window->setLayout (account_layout);
84  	layout->addWidget (self_window);
85  	layout->addWidget (account_window);
86  	balance_label->setStyleSheet ("font-weight: bold;");
87  	balance_layout->addWidget (balance_label);
88  	balance_layout->addStretch ();
89  	balance_layout->setContentsMargins (0, 0, 0, 0);
90  	balance_window->setLayout (balance_layout);
91  	layout->addWidget (balance_window);
92  	layout->setContentsMargins (5, 5, 5, 5);
93  	window->setLayout (layout);
94  	QObject::connect (copy_button, &QPushButton::clicked, [this] () {
95  		this->wallet.application.clipboard ()->setText (QString (this->wallet.account.to_account ().c_str ()));
96  		copy_button->setText ("Copied!");
97  		this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (2), [this] () {
98  			this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
99  				copy_button->setText ("Copy");
100  			}));
101  		});
102  	});
103  }
104  void nano_qt::self_pane::set_balance_text (std::pair<nano::uint128_t, nano::uint128_t> balance_a)
105  {
106  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance_a.first));
107  	if (!balance_a.second.is_zero ())
108  	{
109  		final_text += "\nReady to receive: " + wallet.format_balance (balance_a.second);
110  	}
111  	wallet.self.balance_label->setText (QString (final_text.c_str ()));
112  }
113  nano_qt::accounts::accounts (nano_qt::wallet & wallet_a) :
114  	wallet_balance_label (new QLabel),
115  	window (new QWidget),
116  	layout (new QVBoxLayout),
117  	model (new QStandardItemModel),
118  	view (new QTableView),
119  	use_account (new QPushButton ("Use account")),
120  	create_account (new QPushButton ("Create account")),
121  	import_wallet (new QPushButton ("Import wallet")),
122  	backup_seed (new QPushButton ("Copy wallet seed to clipboard")),
123  	separator (new QFrame),
124  	account_key_line (new QLineEdit),
125  	account_key_button (new QPushButton ("Import adhoc key")),
126  	back (new QPushButton ("Back")),
127  	wallet (wallet_a)
128  {
129  	separator->setFrameShape (QFrame::HLine);
130  	separator->setFrameShadow (QFrame::Sunken);
131  	model->setHorizontalHeaderItem (0, new QStandardItem ("Balance"));
132  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
133  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
134  	view->setModel (model);
135  	view->verticalHeader ()->hide ();
136  	view->setContextMenuPolicy (Qt::ContextMenuPolicy::CustomContextMenu);
137  	view->horizontalHeader ()->setStretchLastSection (true);
138  	layout->addWidget (wallet_balance_label);
139  	layout->addWidget (view);
140  	layout->addWidget (use_account);
141  	layout->addWidget (create_account);
142  	layout->addWidget (import_wallet);
143  	layout->addWidget (backup_seed);
144  	layout->addWidget (separator);
145  	layout->addWidget (account_key_line);
146  	layout->addWidget (account_key_button);
147  	layout->addWidget (back);
148  	window->setLayout (layout);
149  	QObject::connect (use_account, &QPushButton::released, [this] () {
150  		auto selection (view->selectionModel ()->selection ().indexes ());
151  		if (selection.size () == 1)
152  		{
153  			auto error (this->wallet.account.decode_account (model->item (selection[0].row (), 1)->text ().toStdString ()));
154  			(void)error;
155  			debug_assert (!error);
156  			this->wallet.refresh ();
157  		}
158  	});
159  	QObject::connect (account_key_button, &QPushButton::released, [this] () {
160  		QString key_text_wide (account_key_line->text ());
161  		std::string key_text (key_text_wide.toLocal8Bit ());
162  		nano::raw_key key;
163  		if (!key.decode_hex (key_text))
164  		{
165  			show_line_ok (*account_key_line);
166  			account_key_line->clear ();
167  			this->wallet.wallet_m->insert_adhoc (key);
168  			this->wallet.accounts.refresh ();
169  			this->wallet.accounts.refresh_wallet_balance ();
170  			this->wallet.history.refresh ();
171  		}
172  		else
173  		{
174  			show_line_error (*account_key_line);
175  		}
176  	});
177  	QObject::connect (back, &QPushButton::clicked, [this] () {
178  		this->wallet.pop_main_stack ();
179  	});
180  	QObject::connect (create_account, &QPushButton::released, [this] () {
181  		{
182  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
183  			if (this->wallet.wallet_m->store.valid_password (transaction))
184  			{
185  				this->wallet.wallet_m->deterministic_insert (transaction);
186  				show_button_success (*create_account);
187  				create_account->setText ("New account was created");
188  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
189  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
190  						show_button_ok (*create_account);
191  						create_account->setText ("Create account");
192  					}));
193  				});
194  			}
195  			else
196  			{
197  				show_button_error (*create_account);
198  				create_account->setText ("Wallet is locked, unlock it to create account");
199  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
200  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
201  						show_button_ok (*create_account);
202  						create_account->setText ("Create account");
203  					}));
204  				});
205  			}
206  		}
207  		refresh ();
208  	});
209  	QObject::connect (import_wallet, &QPushButton::released, [this] () {
210  		this->wallet.push_main_stack (this->wallet.import.window);
211  	});
212  	QObject::connect (backup_seed, &QPushButton::released, [this] () {
213  		nano::raw_key seed;
214  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
215  		if (this->wallet.wallet_m->store.valid_password (transaction))
216  		{
217  			this->wallet.wallet_m->store.seed (seed, transaction);
218  			this->wallet.application.clipboard ()->setText (QString (seed.to_string ().c_str ()));
219  			show_button_success (*backup_seed);
220  			backup_seed->setText ("Seed was copied to clipboard");
221  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
222  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
223  					show_button_ok (*backup_seed);
224  					backup_seed->setText ("Copy wallet seed to clipboard");
225  				}));
226  			});
227  		}
228  		else
229  		{
230  			this->wallet.application.clipboard ()->setText ("");
231  			show_button_error (*backup_seed);
232  			backup_seed->setText ("Wallet is locked, unlock it to enable the backup");
233  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
234  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
235  					show_button_ok (*backup_seed);
236  					backup_seed->setText ("Copy wallet seed to clipboard");
237  				}));
238  			});
239  		}
240  	});
241  	QObject::connect (account_key_line, &QLineEdit::textChanged, [this] (const QString & value) {
242  		auto pos = account_key_line->cursorPosition ();
243  		account_key_line->setText (value.trimmed ());
244  		account_key_line->setCursorPosition (pos);
245  	});
246  	refresh_wallet_balance ();
247  }
248  void nano_qt::accounts::refresh_wallet_balance ()
249  {
250  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
251  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
252  	nano::uint128_t balance (0);
253  	nano::uint128_t pending (0);
254  	for (auto i (this->wallet.wallet_m->store.begin (transaction)), j (this->wallet.wallet_m->store.end ()); i != j; ++i)
255  	{
256  		nano::public_key const & key (i->first);
257  		balance = balance + (this->wallet.node.ledger.account_balance (block_transaction, key));
258  		pending = pending + (this->wallet.node.ledger.account_receivable (block_transaction, key));
259  	}
260  	auto final_text (std::string ("Balance: ") + wallet.format_balance (balance));
261  	if (!pending.is_zero ())
262  	{
263  		final_text += "\nReady to receive: " + wallet.format_balance (pending);
264  	}
265  	wallet_balance_label->setText (QString (final_text.c_str ()));
266  	this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (60), [this] () {
267  		this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
268  			refresh_wallet_balance ();
269  		}));
270  	});
271  }
272  void nano_qt::accounts::refresh ()
273  {
274  	model->removeRows (0, model->rowCount ());
275  	auto transaction (wallet.wallet_m->wallets.tx_begin_read ());
276  	auto block_transaction (this->wallet.node.store.tx_begin_read ());
277  	QBrush brush;
278  	for (auto i (wallet.wallet_m->store.begin (transaction)), j (wallet.wallet_m->store.end ()); i != j; ++i)
279  	{
280  		nano::public_key key (i->first);
281  		auto balance_amount (wallet.node.ledger.account_balance (block_transaction, key));
282  		bool display (true);
283  		switch (wallet.wallet_m->store.key_type (i->second))
284  		{
285  			case nano::key_type::adhoc:
286  			{
287  				brush.setColor ("red");
288  				display = !balance_amount.is_zero ();
289  				break;
290  			}
291  			default:
292  			{
293  				brush.setColor ("black");
294  				break;
295  			}
296  		}
297  		if (display)
298  		{
299  			QList<QStandardItem *> items;
300  			std::string balance = wallet.format_balance (balance_amount);
301  			items.push_back (new QStandardItem (balance.c_str ()));
302  			auto account (new QStandardItem (QString (key.to_account ().c_str ())));
303  			account->setForeground (brush);
304  			items.push_back (account);
305  			model->appendRow (items);
306  		}
307  	}
308  }
309  nano_qt::import::import (nano_qt::wallet & wallet_a) :
310  	window (new QWidget),
311  	layout (new QVBoxLayout),
312  	seed_label (new QLabel ("Seed:")),
313  	seed (new QLineEdit),
314  	clear_label (new QLabel ("Modifying seed clears existing keys\nType 'clear keys' below to confirm:")),
315  	clear_line (new QLineEdit),
316  	import_seed (new QPushButton ("Import seed")),
317  	separator (new QFrame),
318  	filename_label (new QLabel ("Path to file:")),
319  	filename (new QLineEdit),
320  	password_label (new QLabel ("Password:")),
321  	password (new QLineEdit),
322  	perform (new QPushButton ("Import")),
323  	back (new QPushButton ("Back")),
324  	wallet (wallet_a)
325  {
326  	layout->addWidget (seed_label);
327  	layout->addWidget (seed);
328  	layout->addWidget (clear_label);
329  	layout->addWidget (clear_line);
330  	clear_line->setPlaceholderText ("clear keys");
331  	layout->addWidget (import_seed);
332  	layout->addWidget (separator);
333  	layout->addWidget (filename_label);
334  	layout->addWidget (filename);
335  	layout->addWidget (password_label);
336  	layout->addWidget (password);
337  	layout->addWidget (perform);
338  	layout->addStretch ();
339  	layout->addWidget (back);
340  	window->setLayout (layout);
341  	QObject::connect (perform, &QPushButton::released, [this] () {
342  		std::ifstream stream;
343  		stream.open (filename->text ().toStdString ().c_str ());
344  		if (!stream.fail ())
345  		{
346  			show_line_ok (*filename);
347  			std::stringstream contents;
348  			contents << stream.rdbuf ();
349  			if (!this->wallet.wallet_m->import (contents.str (), password->text ().toStdString ().c_str ()))
350  			{
351  				show_line_ok (*password);
352  				this->wallet.accounts.refresh ();
353  				password->clear ();
354  				filename->clear ();
355  			}
356  			else
357  			{
358  				show_line_error (*password);
359  			}
360  		}
361  		else
362  		{
363  			show_line_error (*filename);
364  		}
365  	});
366  	QObject::connect (back, &QPushButton::released, [this] () {
367  		this->wallet.pop_main_stack ();
368  	});
369  	QObject::connect (import_seed, &QPushButton::released, [this] () {
370  		if (clear_line->text ().toStdString () == "clear keys")
371  		{
372  			show_line_ok (*clear_line);
373  			nano::raw_key seed_l;
374  			if (!seed_l.decode_hex (seed->text ().toStdString ()))
375  			{
376  				bool successful (false);
377  				{
378  					auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
379  					if (this->wallet.wallet_m->store.valid_password (transaction))
380  					{
381  						this->wallet.account = this->wallet.wallet_m->change_seed (transaction, seed_l);
382  						successful = true;
383  						if (this->wallet.node.bootstrap_initiator.in_progress ())
384  						{
385  							this->wallet.needs_deterministic_restore = true;
386  						}
387  					}
388  					else
389  					{
390  						show_line_error (*seed);
391  						show_button_error (*import_seed);
392  						import_seed->setText ("Wallet is locked, unlock it to enable the import");
393  						this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (10), [this] () {
394  							this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
395  								show_line_ok (*seed);
396  								show_button_ok (*import_seed);
397  								import_seed->setText ("Import seed");
398  							}));
399  						});
400  					}
401  				}
402  				if (successful)
403  				{
404  					seed->clear ();
405  					clear_line->clear ();
406  					show_line_ok (*seed);
407  					show_button_success (*import_seed);
408  					import_seed->setText ("Successful import of seed");
409  					this->wallet.refresh ();
410  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
411  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
412  							show_button_ok (*import_seed);
413  							import_seed->setText ("Import seed");
414  						}));
415  					});
416  				}
417  			}
418  			else
419  			{
420  				show_line_error (*seed);
421  				show_button_error (*import_seed);
422  				if (seed->text ().toStdString ().size () != 64)
423  				{
424  					import_seed->setText ("Incorrect seed, length must be 64");
425  				}
426  				else
427  				{
428  					import_seed->setText ("Incorrect seed. Only HEX characters allowed");
429  				}
430  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
431  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
432  						show_button_ok (*import_seed);
433  						import_seed->setText ("Import seed");
434  					}));
435  				});
436  			}
437  		}
438  		else
439  		{
440  			show_line_error (*clear_line);
441  			show_button_error (*import_seed);
442  			import_seed->setText ("Type words 'clear keys'");
443  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
444  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
445  					show_button_ok (*import_seed);
446  					import_seed->setText ("Import seed");
447  				}));
448  			});
449  		}
450  	});
451  	QObject::connect (seed, &QLineEdit::textChanged, [this] (const QString & value) {
452  		auto pos = seed->cursorPosition ();
453  		seed->setText (value.trimmed ());
454  		seed->setCursorPosition (pos);
455  	});
456  	QObject::connect (filename, &QLineEdit::textChanged, [this] (const QString & value) {
457  		auto pos = filename->cursorPosition ();
458  		filename->setText (value.trimmed ());
459  		filename->setCursorPosition (pos);
460  	});
461  }
462  nano_qt::history::history (nano::ledger & ledger_a, nano::account const & account_a, nano_qt::wallet & wallet_a) :
463  	window (new QWidget),
464  	layout (new QVBoxLayout),
465  	model (new QStandardItemModel),
466  	view (new QTableView),
467  	tx_window (new QWidget),
468  	tx_layout (new QHBoxLayout),
469  	tx_label (new QLabel ("Account history count:")),
470  	tx_count (new QSpinBox),
471  	ledger (ledger_a),
472  	account (account_a),
473  	wallet (wallet_a)
474  { &bsol;*
475  	tx_count->setRange (1, 256);
476  	tx_layout->addWidget (tx_label);
477  	tx_layout->addWidget (tx_count);
478  	tx_layout->setContentsMargins (0, 0, 0, 0);
479  	tx_window->setLayout (tx_layout);*/
480  	model->setHorizontalHeaderItem (0, new QStandardItem ("Type"));
481  	model->setHorizontalHeaderItem (1, new QStandardItem ("Account"));
482  	model->setHorizontalHeaderItem (2, new QStandardItem ("Amount"));
483  	model->setHorizontalHeaderItem (3, new QStandardItem ("Hash"));
484  	view->setModel (model);
485  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
486  	view->verticalHeader ()->hide ();
487  	view->horizontalHeader ()->setStretchLastSection (true);
488  	layout->addWidget (view);
489  	layout->setContentsMargins (0, 0, 0, 0);
490  	window->setLayout (layout);
491  	tx_count->setValue (32);
492  }
493  namespace
494  {
495  class short_text_visitor : public nano::block_visitor
496  {
497  public:
498  	short_text_visitor (nano::transaction const & transaction_a, nano::ledger & ledger_a) :
499  		transaction (transaction_a),
500  		ledger (ledger_a)
501  	{
502  	}
503  	void send_block (nano::send_block const & block_a)
504  	{
505  		type = "Send";
506  		account = block_a.hashables.destination;
507  		bool error_or_pruned (false);
508  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
509  		if (error_or_pruned)
510  		{
511  			type = "Send (pruned)";
512  		}
513  	}
514  	void receive_block (nano::receive_block const & block_a)
515  	{
516  		type = "Receive";
517  		bool error_or_pruned (false);
518  		account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
519  		amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
520  		if (error_or_pruned)
521  		{
522  			type = "Receive (pruned)";
523  		}
524  	}
525  	void open_block (nano::open_block const & block_a)
526  	{
527  		type = "Receive";
528  		if (block_a.hashables.source != ledger.constants.genesis->account ())
529  		{
530  			bool error_or_pruned (false);
531  			account = ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned);
532  			amount = ledger.amount_safe (transaction, block_a.hash (), error_or_pruned);
533  			if (error_or_pruned)
534  			{
535  				type = "Receive (pruned)";
536  			}
537  		}
538  		else
539  		{
540  			account = ledger.constants.genesis->account ();
541  			amount = nano::dev::constants.genesis_amount;
542  		}
543  	}
544  	void change_block (nano::change_block const & block_a)
545  	{
546  		type = "Change";
547  		amount = 0;
548  		account = block_a.hashables.representative;
549  	}
550  	void state_block (nano::state_block const & block_a)
551  	{
552  		auto balance (block_a.hashables.balance.number ());
553  		bool error_or_pruned (false);
554  		auto previous_balance (ledger.balance_safe (transaction, block_a.hashables.previous, error_or_pruned));
555  		if (error_or_pruned)
556  		{
557  			type = "Unknown (pruned)";
558  			amount = 0;
559  			account = block_a.hashables.account;
560  		}
561  		else if (balance < previous_balance)
562  		{
563  			type = "Send";
564  			amount = previous_balance - balance;
565  			account = block_a.hashables.link.as_account ();
566  		}
567  		else
568  		{
569  			if (block_a.hashables.link.is_zero ())
570  			{
571  				type = "Change";
572  				account = block_a.hashables.representative;
573  			}
574  			else if (balance == previous_balance && ledger.is_epoch_link (block_a.hashables.link))
575  			{
576  				type = "Epoch";
577  				account = ledger.epoch_signer (block_a.hashables.link);
578  			}
579  			else
580  			{
581  				type = "Receive";
582  				account = ledger.account_safe (transaction, block_a.hashables.link.as_block_hash (), error_or_pruned);
583  				if (error_or_pruned)
584  				{
585  					type = "Receive (pruned)";
586  				}
587  			}
588  			amount = balance - previous_balance;
589  		}
590  	}
591  	nano::transaction const & transaction;
592  	nano::ledger & ledger;
593  	std::string type;
594  	nano::uint128_t amount;
595  	nano::account account;
596  };
597  }
598  void nano_qt::history::refresh ()
599  {
600  	auto transaction (ledger.store.tx_begin_read ());
601  	model->removeRows (0, model->rowCount ());
602  	auto hash (ledger.latest (transaction, account));
603  	short_text_visitor visitor (transaction, ledger);
604  	for (auto i (0), n (tx_count->value ()); i < n && !hash.is_zero (); ++i)
605  	{
606  		QList<QStandardItem *> items;
607  		auto block (ledger.store.block.get (transaction, hash));
608  		if (block != nullptr)
609  		{
610  			block->visit (visitor);
611  			items.push_back (new QStandardItem (QString (visitor.type.c_str ())));
612  			items.push_back (new QStandardItem (QString (visitor.account.to_account ().c_str ())));
613  			auto balanceItem = new QStandardItem (QString (wallet.format_balance (visitor.amount).c_str ()));
614  			balanceItem->setData (Qt::AlignRight, Qt::TextAlignmentRole);
615  			items.push_back (balanceItem);
616  			items.push_back (new QStandardItem (QString (hash.to_string ().c_str ())));
617  			hash = block->previous ();
618  			model->appendRow (items);
619  		}
620  	}
621  }
622  nano_qt::block_viewer::block_viewer (nano_qt::wallet & wallet_a) :
623  	window (new QWidget),
624  	layout (new QVBoxLayout),
625  	hash_label (new QLabel ("Hash:")),
626  	hash (new QLineEdit),
627  	block_label (new QLabel ("Block:")),
628  	block (new QPlainTextEdit),
629  	successor_label (new QLabel ("Successor:")),
630  	successor (new QLineEdit),
631  	retrieve (new QPushButton ("Retrieve")),
632  	rebroadcast (new QPushButton ("Rebroadcast")),
633  	back (new QPushButton ("Back")),
634  	wallet (wallet_a)
635  {
636  	layout->addWidget (hash_label);
637  	layout->addWidget (hash);
638  	layout->addWidget (block_label);
639  	layout->addWidget (block);
640  	layout->addWidget (successor_label);
641  	layout->addWidget (successor);
642  	layout->addWidget (retrieve);
643  	layout->addWidget (rebroadcast);
644  	layout->addStretch ();
645  	layout->addWidget (back);
646  	window->setLayout (layout);
647  	QObject::connect (back, &QPushButton::released, [this] () {
648  		this->wallet.pop_main_stack ();
649  	});
650  	QObject::connect (retrieve, &QPushButton::released, [this] () {
651  		nano::block_hash hash_l;
652  		if (!hash_l.decode_hex (hash->text ().toStdString ()))
653  		{
654  			auto transaction (this->wallet.node.store.tx_begin_read ());
655  			auto block_l (this->wallet.node.store.block.get (transaction, hash_l));
656  			if (block_l != nullptr)
657  			{
658  				std::string contents;
659  				block_l->serialize_json (contents);
660  				block->setPlainText (contents.c_str ());
661  				auto successor_l (this->wallet.node.store.block.successor (transaction, hash_l));
662  				successor->setText (successor_l.to_string ().c_str ());
663  			}
664  			else
665  			{
666  				block->setPlainText ("Block not found");
667  			}
668  		}
669  		else
670  		{
671  			block->setPlainText ("Bad block hash");
672  		}
673  	});
674  	QObject::connect (rebroadcast, &QPushButton::released, [this] () {
675  		nano::block_hash block;
676  		auto error (block.decode_hex (hash->text ().toStdString ()));
677  		if (!error)
678  		{
679  			auto transaction (this->wallet.node.store.tx_begin_read ());
680  			if (this->wallet.node.store.block.exists (transaction, block))
681  			{
682  				rebroadcast->setEnabled (false);
683  				this->wallet.node.background ([this, block] () {
684  					rebroadcast_action (block);
685  				});
686  			}
687  		}
688  	});
689  	QObject::connect (hash, &QLineEdit::textChanged, [this] (const QString & value) {
690  		auto pos = hash->cursorPosition ();
691  		hash->setText (value.trimmed ());
692  		hash->setCursorPosition (pos);
693  	});
694  	rebroadcast->setToolTip ("Rebroadcast block into the network");
695  }
696  void nano_qt::block_viewer::rebroadcast_action (nano::block_hash const & hash_a)
697  {
698  	auto done (true);
699  	auto transaction (wallet.node.ledger.store.tx_begin_read ());
700  	auto block (wallet.node.store.block.get (transaction, hash_a));
701  	if (block != nullptr)
702  	{
703  		wallet.node.network.flood_block (block);
704  		auto successor (wallet.node.store.block.successor (transaction, hash_a));
705  		if (!successor.is_zero ())
706  		{
707  			done = false;
708  			wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (1), [this, successor] () {
709  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this, successor] () {
710  					rebroadcast_action (successor);
711  				}));
712  			});
713  		}
714  	}
715  	if (done)
716  	{
717  		rebroadcast->setEnabled (true);
718  	}
719  }
720  nano_qt::account_viewer::account_viewer (nano_qt::wallet & wallet_a) :
721  	window (new QWidget),
722  	layout (new QVBoxLayout),
723  	account_label (new QLabel ("Account:")),
724  	account_line (new QLineEdit),
725  	refresh (new QPushButton ("Refresh")),
726  	balance_window (new QWidget),
727  	balance_layout (new QHBoxLayout),
728  	balance_label (new QLabel),
729  	history (wallet_a.node.ledger, account, wallet_a),
730  	back (new QPushButton ("Back")),
731  	account (wallet_a.account),
732  	wallet (wallet_a)
733  {
734  	layout->addWidget (account_label);
735  	layout->addWidget (account_line);
736  	layout->addWidget (refresh);
737  	balance_layout->addWidget (balance_label);
738  	balance_layout->addStretch ();
739  	balance_layout->setContentsMargins (0, 0, 0, 0);
740  	balance_window->setLayout (balance_layout);
741  	layout->addWidget (balance_window);
742  	layout->addWidget (history.window);
743  	layout->addWidget (back);
744  	window->setLayout (layout);
745  	QObject::connect (back, &QPushButton::released, [this] () {
746  		this->wallet.pop_main_stack ();
747  	});
748  	QObject::connect (refresh, &QPushButton::released, [this] () {
749  		account.clear ();
750  		if (!account.decode_account (account_line->text ().toStdString ()))
751  		{
752  			show_line_ok (*account_line);
753  			this->history.refresh ();
754  			auto balance (this->wallet.node.balance_pending (account, false));
755  			auto final_text (std::string ("Balance (NANO): ") + wallet.format_balance (balance.first));
756  			if (!balance.second.is_zero ())
757  			{
758  				final_text += "\nReady to receive: " + wallet.format_balance (balance.second);
759  			}
760  			balance_label->setText (QString (final_text.c_str ()));
761  		}
762  		else
763  		{
764  			show_line_error (*account_line);
765  			balance_label->clear ();
766  		}
767  	});
768  	QObject::connect (account_line, &QLineEdit::textChanged, [this] (const QString & value) {
769  		auto pos = account_line->cursorPosition ();
770  		account_line->setText (value.trimmed ());
771  		account_line->setCursorPosition (pos);
772  	});
773  }
774  nano_qt::stats_viewer::stats_viewer (nano_qt::wallet & wallet_a) :
775  	window (new QWidget),
776  	layout (new QVBoxLayout),
777  	refresh (new QPushButton ("Refresh")),
778  	clear (new QPushButton ("Clear Statistics")),
779  	model (new QStandardItemModel),
780  	view (new QTableView),
781  	back (new QPushButton ("Back")),
782  	wallet (wallet_a)
783  {
784  	model->setHorizontalHeaderItem (0, new QStandardItem ("Last updated"));
785  	model->setHorizontalHeaderItem (1, new QStandardItem ("Type"));
786  	model->setHorizontalHeaderItem (2, new QStandardItem ("Detail"));
787  	model->setHorizontalHeaderItem (3, new QStandardItem ("Direction"));
788  	model->setHorizontalHeaderItem (4, new QStandardItem ("Value"));
789  	view->setModel (model);
790  	view->setEditTriggers (QAbstractItemView::NoEditTriggers);
791  	view->verticalHeader ()->hide ();
792  	view->horizontalHeader ()->setStretchLastSection (true);
793  	layout->setContentsMargins (0, 0, 0, 0);
794  	layout->addWidget (view);
795  	layout->addWidget (refresh);
796  	layout->addWidget (clear);
797  	layout->addWidget (back);
798  	window->setLayout (layout);
799  	QObject::connect (back, &QPushButton::released, [this] () {
800  		this->wallet.pop_main_stack ();
801  	});
802  	QObject::connect (refresh, &QPushButton::released, [this] () {
803  		refresh_stats ();
804  	});
805  	QObject::connect (clear, &QPushButton::released, [this] () {
806  		this->wallet.node.stats.clear ();
807  		refresh_stats ();
808  	});
809  	refresh_stats ();
810  }
811  void nano_qt::stats_viewer::refresh_stats ()
812  {
813  	model->removeRows (0, model->rowCount ());
814  	auto sink = wallet.node.stats.log_sink_json ();
815  	wallet.node.stats.log_counters (*sink);
816  	auto json = static_cast<boost::property_tree::ptree *> (sink->to_object ());
817  	if (json)
818  	{
819  		BOOST_FOREACH (boost::property_tree::ptree::value_type const & child, json->get_child ("entries"))
820  		{
821  			auto time = child.second.get<std::string> ("time");
822  			auto type = child.second.get<std::string> ("type");
823  			auto detail = child.second.get<std::string> ("detail");
824  			auto dir = child.second.get<std::string> ("dir");
825  			auto value = child.second.get<std::string> ("value", "0");
826  			if (detail == "all")
827  			{
828  				detail = "total";
829  			}
830  			if (type == "traffic_tcp")
831  			{
832  				std::vector<std::string> const units = { " bytes", " KB", " MB", " GB", " TB", " PB" };
833  				double bytes = std::stod (value);
834  				auto index = bytes == 0 ? 0 : std::min (units.size () - 1, static_cast<size_t> (std::floor (std::log2 (bytes) / 10)));
835  				std::string unit = units[index];
836  				bytes /= std::pow (1024, index);
837  				int precision = index < 2 ? 0 : 2;
838  				std::stringstream numstream;
839  				numstream << std::fixed << std::setprecision (precision) << bytes;
840  				value = numstream.str () + unit;
841  			}
842  			QList<QStandardItem *> items;
843  			items.push_back (new QStandardItem (QString (time.c_str ())));
844  			items.push_back (new QStandardItem (QString (type.c_str ())));
845  			items.push_back (new QStandardItem (QString (detail.c_str ())));
846  			items.push_back (new QStandardItem (QString (dir.c_str ())));
847  			items.push_back (new QStandardItem (QString (value.c_str ())));
848  			model->appendRow (items);
849  		}
850  	}
851  }
852  nano_qt::status::status (nano_qt::wallet & wallet_a) :
853  	wallet (wallet_a)
854  {
855  	wallet.status->setToolTip ("Wallet status, block count (blocks downloaded)");
856  	active.insert (nano_qt::status_types::nominal);
857  	set_text ();
858  }
859  void nano_qt::status::erase (nano_qt::status_types status_a)
860  {
861  	debug_assert (status_a != nano_qt::status_types::nominal);
862  	auto erased (active.erase (status_a));
863  	(void)erased;
864  	set_text ();
865  }
866  void nano_qt::status::insert (nano_qt::status_types status_a)
867  {
868  	debug_assert (status_a != nano_qt::status_types::nominal);
869  	active.insert (status_a);
870  	set_text ();
871  }
872  void nano_qt::status::set_text ()
873  {
874  	wallet.status->setText (text ().c_str ());
875  	wallet.status->setStyleSheet ((std::string ("QLabel {") + color () + "}").c_str ());
876  }
877  std::string nano_qt::status::text ()
878  {
879  	debug_assert (!active.empty ());
880  	std::string result;
881  	size_t unchecked (0);
882  	size_t cemented (0);
883  	std::string count_string;
884  	{
885  		auto size (wallet.wallet_m->wallets.node.ledger.cache.block_count.load ());
886  		unchecked = wallet.wallet_m->wallets.node.unchecked.count ();
887  		cemented = wallet.wallet_m->wallets.node.ledger.cache.cemented_count.load ();
888  		count_string = std::to_string (size);
889  	}
890  	switch (*active.begin ())
891  	{
892  		case nano_qt::status_types::disconnected:
893  			result = "Status: Disconnected";
894  			break;
895  		case nano_qt::status_types::working:
896  			result = "Status: Generating proof of work";
897  			break;
898  		case nano_qt::status_types::synchronizing:
899  			result = "Status: Synchronizing";
900  			break;
901  		case nano_qt::status_types::locked:
902  			result = "Status: Wallet locked";
903  			break;
904  		case nano_qt::status_types::vulnerable:
905  			result = "Status: Wallet password empty";
906  			break;
907  		case nano_qt::status_types::active:
908  			result = "Status: Wallet active";
909  			break;
910  		case nano_qt::status_types::nominal:
911  			result = "Status: Running";
912  			break;
913  		default:
914  			debug_assert (false);
915  			break;
916  	}
917  	result += ", Blocks: ";
918  	count_string += ", Unchecked: " + std::to_string (unchecked);
919  	count_string += ", Cemented: " + std::to_string (cemented);
920  	if (wallet.node.flags.enable_pruning)
921  	{
922  		count_string += ", Full: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.block_count - wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
923  		count_string += ", Pruned: " + std::to_string (wallet.wallet_m->wallets.node.ledger.cache.pruned_count);
924  	}
925  	result += count_string.c_str ();
926  	return result;
927  }
928  std::string nano_qt::status::color ()
929  {
930  	debug_assert (!active.empty ());
931  	std::string result;
932  	switch (*active.begin ())
933  	{
934  		case nano_qt::status_types::disconnected:
935  			result = "color: red";
936  			break;
937  		case nano_qt::status_types::working:
938  			result = "color: blue";
939  			break;
940  		case nano_qt::status_types::synchronizing:
941  			result = "color: blue";
942  			break;
943  		case nano_qt::status_types::locked:
944  			result = "color: orange";
945  			break;
946  		case nano_qt::status_types::vulnerable:
947  			result = "color: blue";
948  			break;
949  		case nano_qt::status_types::active:
950  			result = "color: black";
951  			break;
952  		case nano_qt::status_types::nominal:
953  			result = "color: black";
954  			break;
955  		default:
956  			debug_assert (false);
957  			break;
958  	}
959  	return result;
960  }
961  nano_qt::wallet::wallet (QApplication & application_a, nano_qt::eventloop_processor & processor_a, nano::node & node_a, std::shared_ptr<nano::wallet> const & wallet_a, nano::account & account_a) :
962  	rendering_ratio (nano::Mxrb_ratio),
963  	node (node_a),
964  	wallet_m (wallet_a),
965  	account (account_a),
966  	processor (processor_a),
967  	history (node.ledger, account, *this),
968  	accounts (*this),
969  	self (*this, account_a),
970  	settings (*this),
971  	advanced (*this),
972  	block_creation (*this),
973  	block_entry (*this),
974  	block_viewer (*this),
975  	account_viewer (*this),
976  	stats_viewer (*this),
977  	import (*this),
978  	application (application_a),
979  	status (new QLabel),
980  	main_stack (new QStackedWidget),
981  	client_window (new QWidget),
982  	client_layout (new QVBoxLayout),
983  	entry_window (new QWidget),
984  	entry_window_layout (new QVBoxLayout),
985  	separator (new QFrame),
986  	account_history_label (new QLabel ("Account history:")),
987  	send_blocks (new QPushButton ("Send")),
988  	settings_button (new QPushButton ("Settings")),
989  	accounts_button (new QPushButton ("Accounts")),
990  	show_advanced (new QPushButton ("Advanced")),
991  	send_blocks_window (new QWidget),
992  	send_blocks_layout (new QVBoxLayout),
993  	send_account_label (new QLabel ("Destination account:")),
994  	send_account (new QLineEdit),
995  	send_count_label (new QLabel ("Amount:")),
996  	send_count (new QLineEdit),
997  	send_blocks_send (new QPushButton ("Send")),
998  	send_blocks_back (new QPushButton ("Back")),
999  	active_status (*this),
1000  	needs_deterministic_restore (false)
1001  {
1002  	update_connected ();
1003  	empty_password ();
1004  	settings.update_locked (true, true);
1005  	send_blocks_layout->addWidget (send_account_label);
1006  	send_account->setPlaceholderText (node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1007  	send_blocks_layout->addWidget (send_account);
1008  	send_blocks_layout->addWidget (send_count_label);
1009  	send_count->setPlaceholderText ("0");
1010  	send_blocks_layout->addWidget (send_count);
1011  	send_blocks_layout->addWidget (send_blocks_send);
1012  	send_blocks_layout->addStretch ();
1013  	send_blocks_layout->addWidget (send_blocks_back);
1014  	send_blocks_layout->setContentsMargins (0, 0, 0, 0);
1015  	send_blocks_window->setLayout (send_blocks_layout);
1016  	entry_window_layout->addWidget (account_history_label);
1017  	entry_window_layout->addWidget (history.window);
1018  	entry_window_layout->addWidget (send_blocks);
1019  	entry_window_layout->addWidget (settings_button);
1020  	entry_window_layout->addWidget (accounts_button);
1021  	entry_window_layout->addWidget (show_advanced);
1022  	entry_window_layout->setContentsMargins (0, 0, 0, 0);
1023  	entry_window_layout->setSpacing (5);
1024  	entry_window->setLayout (entry_window_layout);
1025  	main_stack->addWidget (entry_window);
1026  	status->setContentsMargins (5, 5, 5, 5);
1027  	status->setAlignment (Qt::AlignHCenter);
1028  	separator->setFrameShape (QFrame::HLine);
1029  	separator->setFrameShadow (QFrame::Sunken);
1030  	client_layout->addWidget (status);
1031  	client_layout->addWidget (self.window);
1032  	client_layout->addWidget (separator);
1033  	client_layout->addWidget (main_stack);
1034  	client_layout->setSpacing (0);
1035  	client_layout->setContentsMargins (0, 0, 0, 0);
1036  	client_window->setLayout (client_layout);
1037  	client_window->resize (620, 640);
1038  	client_window->setStyleSheet ("\
1039  		QLineEdit { padding: 3px; } \
1040  	");
1041  	QObject::connect (send_account, &QLineEdit::textChanged, [this] (const QString & value) {
1042  		auto pos = send_account->cursorPosition ();
1043  		send_account->setText (value.trimmed ());
1044  		send_account->setCursorPosition (pos);
1045  	});
1046  	QObject::connect (send_count, &QLineEdit::textChanged, [this] (const QString & value) {
1047  		auto pos = send_count->cursorPosition ();
1048  		send_count->setText (value.trimmed ());
1049  		send_count->setCursorPosition (pos);
1050  	});
1051  	refresh ();
1052  }
1053  void nano_qt::wallet::ongoing_refresh ()
1054  {
1055  	std::weak_ptr<nano_qt::wallet> wallet_w (shared_from_this ());
1056  	if (needs_balance_refresh)
1057  	{
1058  		needs_balance_refresh = false;
1059  		auto balance_l (node.balance_pending (account, false));
1060  		application.postEvent (&processor, new eventloop_event ([wallet_w, balance_l] () {
1061  			if (auto this_l = wallet_w.lock ())
1062  			{
1063  				this_l->self.set_balance_text (balance_l);
1064  			}
1065  		}));
1066  	}
1067  	application.postEvent (&processor, new eventloop_event ([wallet_w] () {
1068  		if (auto this_l = wallet_w.lock ())
1069  		{
1070  			this_l->active_status.set_text ();
1071  		}
1072  	}));
1073  	node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [wallet_w] () {
1074  		if (auto wallet_l = wallet_w.lock ())
1075  		{
1076  			wallet_l->ongoing_refresh ();
1077  		}
1078  	});
1079  }
1080  void nano_qt::wallet::start ()
1081  {
1082  	ongoing_refresh ();
1083  	std::weak_ptr<nano_qt::wallet> this_w (shared_from_this ());
1084  	QObject::connect (settings_button, &QPushButton::released, [this_w] () {
1085  		if (auto this_l = this_w.lock ())
1086  		{
1087  			this_l->settings.activate ();
1088  		}
1089  	});
1090  	QObject::connect (accounts_button, &QPushButton::released, [this_w] () {
1091  		if (auto this_l = this_w.lock ())
1092  		{
1093  			this_l->push_main_stack (this_l->accounts.window);
1094  		}
1095  	});
1096  	QObject::connect (show_advanced, &QPushButton::released, [this_w] () {
1097  		if (auto this_l = this_w.lock ())
1098  		{
1099  			this_l->push_main_stack (this_l->advanced.window);
1100  		}
1101  	});
1102  	QObject::connect (send_blocks_send, &QPushButton::released, [this_w] () {
1103  		if (auto this_l = this_w.lock ())
1104  		{
1105  			show_line_ok (*this_l->send_count);
1106  			show_line_ok (*this_l->send_account);
1107  			nano::amount amount;
1108  			if (!amount.decode_dec (this_l->send_count->text ().toStdString (), this_l->rendering_ratio))
1109  			{
1110  				nano::uint128_t actual (amount.number ());
1111  				QString account_text (this_l->send_account->text ());
1112  				std::string account_text_narrow (account_text.toLocal8Bit ());
1113  				nano::account account_l;
1114  				auto parse_error (account_l.decode_account (account_text_narrow));
1115  				if (!parse_error)
1116  				{
1117  					auto balance (this_l->node.balance (this_l->account));
1118  					if (actual <= balance)
1119  					{
1120  						auto transaction (this_l->wallet_m->wallets.tx_begin_read ());
1121  						if (this_l->wallet_m->store.valid_password (transaction))
1122  						{
1123  							this_l->send_blocks_send->setEnabled (false);
1124  							this_l->node.background ([this_w, account_l, actual] () {
1125  								if (auto this_l = this_w.lock ())
1126  								{
1127  									this_l->wallet_m->send_async (this_l->account, account_l, actual, [this_w] (std::shared_ptr<nano::block> const & block_a) {
1128  										if (auto this_l = this_w.lock ())
1129  										{
1130  											auto succeeded (block_a != nullptr);
1131  											this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, succeeded] () {
1132  												if (auto this_l = this_w.lock ())
1133  												{
1134  													this_l->send_blocks_send->setEnabled (true);
1135  													if (succeeded)
1136  													{
1137  														this_l->send_count->clear ();
1138  														this_l->send_account->clear ();
1139  														this_l->accounts.refresh ();
1140  													}
1141  													else
1142  													{
1143  														show_line_error (*this_l->send_count);
1144  													}
1145  												}
1146  											}));
1147  										}
1148  									});
1149  								}
1150  							});
1151  						}
1152  						else
1153  						{
1154  							show_button_error (*this_l->send_blocks_send);
1155  							this_l->send_blocks_send->setText ("Wallet is locked, unlock it to send");
1156  							this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1157  								if (auto this_l = this_w.lock ())
1158  								{
1159  									this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1160  										if (auto this_l = this_w.lock ())
1161  										{
1162  											show_button_ok (*this_l->send_blocks_send);
1163  											this_l->send_blocks_send->setText ("Send");
1164  										}
1165  									}));
1166  								}
1167  							});
1168  						}
1169  					}
1170  					else
1171  					{
1172  						show_line_error (*this_l->send_count);
1173  						show_button_error (*this_l->send_blocks_send);
1174  						this_l->send_blocks_send->setText ("Not enough balance");
1175  						this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1176  							if (auto this_l = this_w.lock ())
1177  							{
1178  								this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1179  									if (auto this_l = this_w.lock ())
1180  									{
1181  										show_button_ok (*this_l->send_blocks_send);
1182  										this_l->send_blocks_send->setText ("Send");
1183  									}
1184  								}));
1185  							}
1186  						});
1187  					}
1188  				}
1189  				else
1190  				{
1191  					show_line_error (*this_l->send_account);
1192  					show_button_error (*this_l->send_blocks_send);
1193  					this_l->send_blocks_send->setText ("Bad destination account");
1194  					this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1195  						if (auto this_l = this_w.lock ())
1196  						{
1197  							this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1198  								if (auto this_l = this_w.lock ())
1199  								{
1200  									show_button_ok (*this_l->send_blocks_send);
1201  									this_l->send_blocks_send->setText ("Send");
1202  								}
1203  							}));
1204  						}
1205  					});
1206  				}
1207  			}
1208  			else
1209  			{
1210  				show_line_error (*this_l->send_count);
1211  				show_button_error (*this_l->send_blocks_send);
1212  				this_l->send_blocks_send->setText ("Bad amount number");
1213  				this_l->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this_w] () {
1214  					if (auto this_l = this_w.lock ())
1215  					{
1216  						this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1217  							if (auto this_l = this_w.lock ())
1218  							{
1219  								show_button_ok (*this_l->send_blocks_send);
1220  								this_l->send_blocks_send->setText ("Send");
1221  							}
1222  						}));
1223  					}
1224  				});
1225  			}
1226  		}
1227  	});
1228  	QObject::connect (send_blocks_back, &QPushButton::released, [this_w] () {
1229  		if (auto this_l = this_w.lock ())
1230  		{
1231  			this_l->pop_main_stack ();
1232  		}
1233  	});
1234  	QObject::connect (send_blocks, &QPushButton::released, [this_w] () {
1235  		if (auto this_l = this_w.lock ())
1236  		{
1237  			this_l->push_main_stack (this_l->send_blocks_window);
1238  		}
1239  	});
1240  	node.observers.blocks.add ([this_w] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::uint128_t const & amount_a, bool, bool) {
1241  		if (auto this_l = this_w.lock ())
1242  		{
1243  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, status_a, account_a] () {
1244  				if (auto this_l = this_w.lock ())
1245  				{
1246  					if (this_l->wallet_m->exists (account_a))
1247  					{
1248  						this_l->accounts.refresh ();
1249  					}
1250  					if (account_a == this_l->account)
1251  					{
1252  						this_l->history.refresh ();
1253  					}
1254  				}
1255  			}));
1256  		}
1257  	});
1258  	node.observers.account_balance.add ([this_w] (nano::account const & account_a, bool is_pending) {
1259  		if (auto this_l = this_w.lock ())
1260  		{
1261  			this_l->needs_balance_refresh = this_l->needs_balance_refresh || account_a == this_l->account;
1262  		}
1263  	});
1264  	node.observers.wallet.add ([this_w] (bool active_a) {
1265  		if (auto this_l = this_w.lock ())
1266  		{
1267  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1268  				if (auto this_l = this_w.lock ())
1269  				{
1270  					if (active_a)
1271  					{
1272  						this_l->active_status.insert (nano_qt::status_types::active);
1273  					}
1274  					else
1275  					{
1276  						this_l->active_status.erase (nano_qt::status_types::active);
1277  					}
1278  				}
1279  			}));
1280  		}
1281  	});
1282  	node.observers.endpoint.add ([this_w] (std::shared_ptr<nano::transport::channel> const &) {
1283  		if (auto this_l = this_w.lock ())
1284  		{
1285  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1286  				if (auto this_l = this_w.lock ())
1287  				{
1288  					this_l->update_connected ();
1289  				}
1290  			}));
1291  		}
1292  	});
1293  	node.observers.disconnect.add ([this_w] () {
1294  		if (auto this_l = this_w.lock ())
1295  		{
1296  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w] () {
1297  				if (auto this_l = this_w.lock ())
1298  				{
1299  					this_l->update_connected ();
1300  				}
1301  			}));
1302  		}
1303  	});
1304  	node.bootstrap_initiator.add_observer ([this_w] (bool active_a) {
1305  		if (auto this_l = this_w.lock ())
1306  		{
1307  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, active_a] () {
1308  				if (auto this_l = this_w.lock ())
1309  				{
1310  					if (active_a)
1311  					{
1312  						this_l->active_status.insert (nano_qt::status_types::synchronizing);
1313  					}
1314  					else
1315  					{
1316  						this_l->active_status.erase (nano_qt::status_types::synchronizing);
1317  						if (this_l->needs_deterministic_restore)
1318  						{
1319  							this_l->needs_deterministic_restore = false;
1320  							auto transaction (this_l->wallet_m->wallets.tx_begin_write ());
1321  							this_l->wallet_m->deterministic_restore (transaction);
1322  						}
1323  					}
1324  				}
1325  			}));
1326  		}
1327  	});
1328  	node.work.work_observers.add ([this_w] (bool working) {
1329  		if (auto this_l = this_w.lock ())
1330  		{
1331  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, working] () {
1332  				if (auto this_l = this_w.lock ())
1333  				{
1334  					if (working)
1335  					{
1336  						this_l->active_status.insert (nano_qt::status_types::working);
1337  					}
1338  					else
1339  					{
1340  						this_l->active_status.erase (nano_qt::status_types::working);
1341  					}
1342  				}
1343  			}));
1344  		}
1345  	});
1346  	wallet_m->lock_observer = [this_w] (bool invalid, bool vulnerable) {
1347  		if (auto this_l = this_w.lock ())
1348  		{
1349  			this_l->application.postEvent (&this_l->processor, new eventloop_event ([this_w, invalid, vulnerable] () {
1350  				if (auto this_l = this_w.lock ())
1351  				{
1352  					this_l->settings.update_locked (invalid, vulnerable);
1353  				}
1354  			}));
1355  		}
1356  	};
1357  	settings_button->setToolTip ("Unlock wallet, set password, change representative");
1358  }
1359  void nano_qt::wallet::refresh ()
1360  {
1361  	{
1362  		auto transaction (wallet_m->wallets.tx_begin_read ());
1363  		debug_assert (wallet_m->store.exists (transaction, account));
1364  	}
1365  	self.account_text->setText (QString (account.to_account ().c_str ()));
1366  	needs_balance_refresh = true;
1367  	accounts.refresh ();
1368  	history.refresh ();
1369  	account_viewer.history.refresh ();
1370  	settings.refresh_representative ();
1371  }
1372  void nano_qt::wallet::update_connected ()
1373  {
1374  	if (node.network.empty ())
1375  	{
1376  		active_status.insert (nano_qt::status_types::disconnected);
1377  	}
1378  	else
1379  	{
1380  		active_status.erase (nano_qt::status_types::disconnected);
1381  	}
1382  }
1383  void nano_qt::wallet::empty_password ()
1384  {
1385  	this->node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (3), [this] () {
1386  		auto transaction (wallet_m->wallets.tx_begin_write ());
1387  		wallet_m->enter_password (transaction, std::string (""));
1388  	});
1389  }
1390  void nano_qt::wallet::change_rendering_ratio (nano::uint128_t const & rendering_ratio_a)
1391  {
1392  	application.postEvent (&processor, new eventloop_event ([this, rendering_ratio_a] () {
1393  		this->rendering_ratio = rendering_ratio_a;
1394  		auto balance_l (this->node.balance_pending (account, false));
1395  		this->self.set_balance_text (balance_l);
1396  		this->refresh ();
1397  	}));
1398  }
1399  std::string nano_qt::wallet::format_balance (nano::uint128_t const & balance) const
1400  {
1401  	auto balance_str = nano::amount (balance).format_balance (rendering_ratio, 3, false);
1402  	auto unit = std::string ("nano");
1403  	if (rendering_ratio == nano::raw_ratio)
1404  	{
1405  		unit = std::string ("raw");
1406  	}
1407  	return balance_str + " " + unit;
1408  }
1409  void nano_qt::wallet::push_main_stack (QWidget * widget_a)
1410  {
1411  	main_stack->addWidget (widget_a);
1412  	main_stack->setCurrentIndex (main_stack->count () - 1);
1413  }
1414  void nano_qt::wallet::pop_main_stack ()
1415  {
1416  	main_stack->removeWidget (main_stack->currentWidget ());
1417  }
1418  nano_qt::settings::settings (nano_qt::wallet & wallet_a) :
1419  	window (new QWidget),
1420  	layout (new QVBoxLayout),
1421  	password (new QLineEdit),
1422  	lock_toggle (new QPushButton ("Unlock")),
1423  	sep1 (new QFrame),
1424  	new_password (new QLineEdit),
1425  	retype_password (new QLineEdit),
1426  	change (new QPushButton ("Set/Change password")),
1427  	sep2 (new QFrame),
1428  	representative (new QLabel ("Account representative:")),
1429  	current_representative (new QLabel),
1430  	new_representative (new QLineEdit),
1431  	change_rep (new QPushButton ("Change representative")),
1432  	back (new QPushButton ("Back")),
1433  	wallet (wallet_a)
1434  {
1435  	password->setPlaceholderText ("Password");
1436  	password->setEchoMode (QLineEdit::EchoMode::Password);
1437  	layout->addWidget (password);
1438  	layout->addWidget (lock_toggle);
1439  	sep1->setFrameShape (QFrame::HLine);
1440  	sep1->setFrameShadow (QFrame::Sunken);
1441  	layout->addWidget (sep1);
1442  	new_password->setEchoMode (QLineEdit::EchoMode::Password);
1443  	new_password->setPlaceholderText ("New password");
1444  	layout->addWidget (new_password);
1445  	retype_password->setEchoMode (QLineEdit::EchoMode::Password);
1446  	retype_password->setPlaceholderText ("Retype password");
1447  	layout->addWidget (retype_password);
1448  	layout->addWidget (change);
1449  	sep2->setFrameShape (QFrame::HLine);
1450  	sep2->setFrameShadow (QFrame::Sunken);
1451  	layout->addWidget (sep2);
1452  	layout->addWidget (representative);
1453  	current_representative->setTextInteractionFlags (Qt::TextSelectableByMouse);
1454  	layout->addWidget (current_representative);
1455  	new_representative->setPlaceholderText (wallet.node.network_params.ledger.zero_key.pub.to_account ().c_str ());
1456  	layout->addWidget (new_representative);
1457  	layout->addWidget (change_rep);
1458  	layout->addStretch ();
1459  	layout->addWidget (back);
1460  	window->setLayout (layout);
1461  	QObject::connect (change, &QPushButton::released, [this] () {
1462  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1463  		if (this->wallet.wallet_m->store.valid_password (transaction))
1464  		{
1465  			if (new_password->text ().isEmpty ())
1466  			{
1467  				new_password->clear ();
1468  				new_password->setPlaceholderText ("Empty Password - try again: New password");
1469  				retype_password->clear ();
1470  				retype_password->setPlaceholderText ("Empty Password - try again: Retype password");
1471  			}
1472  			else
1473  			{
1474  				if (new_password->text () == retype_password->text ())
1475  				{
1476  					this->wallet.wallet_m->store.rekey (transaction, std::string (new_password->text ().toLocal8Bit ()));
1477  					new_password->clear ();
1478  					retype_password->clear ();
1479  					retype_password->setPlaceholderText ("Retype password");
1480  					show_button_success (*change);
1481  					change->setText ("Password was changed");
1482  					this->wallet.node.logger.try_log ("Wallet password changed");
1483  					update_locked (false, false);
1484  					this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1485  						this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1486  							show_button_ok (*change);
1487  							change->setText ("Set/Change password");
1488  						}));
1489  					});
1490  				}
1491  				else
1492  				{
1493  					retype_password->clear ();
1494  					retype_password->setPlaceholderText ("Password mismatch");
1495  				}
1496  			}
1497  		}
1498  		else
1499  		{
1500  			show_button_error (*change);
1501  			change->setText ("Wallet is locked, unlock it");
1502  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1503  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1504  					show_button_ok (*change);
1505  					change->setText ("Set/Change password");
1506  				}));
1507  			});
1508  		}
1509  	});
1510  	QObject::connect (change_rep, &QPushButton::released, [this] () {
1511  		nano::account representative_l;
1512  		if (!representative_l.decode_account (new_representative->text ().toStdString ()))
1513  		{
1514  			auto transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1515  			if (this->wallet.wallet_m->store.valid_password (transaction))
1516  			{
1517  				change_rep->setEnabled (false);
1518  				{
1519  					auto transaction_l (this->wallet.wallet_m->wallets.tx_begin_write ());
1520  					this->wallet.wallet_m->store.representative_set (transaction_l, representative_l);
1521  				}
1522  				this->wallet.wallet_m->change_sync (this->wallet.account, representative_l);
1523  				change_rep->setEnabled (true);
1524  				show_button_success (*change_rep);
1525  				change_rep->setText ("Representative was changed");
1526  				current_representative->setText (QString (representative_l.to_account ().c_str ()));
1527  				new_representative->clear ();
1528  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1529  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1530  						show_button_ok (*change_rep);
1531  						change_rep->setText ("Change representative");
1532  					}));
1533  				});
1534  			}
1535  			else
1536  			{
1537  				show_button_error (*change_rep);
1538  				change_rep->setText ("Wallet is locked, unlock it");
1539  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1540  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1541  						show_button_ok (*change_rep);
1542  						change_rep->setText ("Change representative");
1543  					}));
1544  				});
1545  			}
1546  		}
1547  		else
1548  		{
1549  			show_line_error (*new_representative);
1550  			show_button_error (*change_rep);
1551  			change_rep->setText ("Invalid account");
1552  			this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1553  				this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1554  					show_line_ok (*new_representative);
1555  					show_button_ok (*change_rep);
1556  					change_rep->setText ("Change representative");
1557  				}));
1558  			});
1559  		}
1560  	});
1561  	QObject::connect (back, &QPushButton::released, [this] () {
1562  		debug_assert (this->wallet.main_stack->currentWidget () == window);
1563  		this->wallet.pop_main_stack ();
1564  	});
1565  	QObject::connect (lock_toggle, &QPushButton::released, [this] () {
1566  		auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1567  		if (this->wallet.wallet_m->store.valid_password (transaction))
1568  		{
1569  			nano::raw_key empty;
1570  			empty.clear ();
1571  			this->wallet.wallet_m->store.password.value_set (empty);
1572  			update_locked (true, true);
1573  			lock_toggle->setText ("Unlock");
1574  			this->wallet.node.logger.try_log ("Wallet locked");
1575  			password->setEnabled (1);
1576  		}
1577  		else
1578  		{
1579  			if (!this->wallet.wallet_m->enter_password (transaction, std::string (password->text ().toLocal8Bit ())))
1580  			{
1581  				password->clear ();
1582  				lock_toggle->setText ("Lock");
1583  				password->setDisabled (1);
1584  			}
1585  			else
1586  			{
1587  				show_line_error (*password);
1588  				show_button_error (*lock_toggle);
1589  				lock_toggle->setText ("Invalid password");
1590  				this->wallet.node.workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::seconds (5), [this] () {
1591  					this->wallet.application.postEvent (&this->wallet.processor, new eventloop_event ([this] () {
1592  						show_line_ok (*password);
1593  						show_button_ok (*lock_toggle);
1594  						auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1595  						if (!this->wallet.wallet_m->store.valid_password (transaction))
1596  						{
1597  							lock_toggle->setText ("Unlock");
1598  						}
1599  					}));
1600  				});
1601  			}
1602  		}
1603  	});
1604  	QObject::connect (new_representative, &QLineEdit::textChanged, [this] (const QString & value) {
1605  		auto pos = new_representative->cursorPosition ();
1606  		new_representative->setText (value.trimmed ());
1607  		new_representative->setCursorPosition (pos);
1608  	});
1609  	auto transaction (this->wallet.wallet_m->wallets.tx_begin_write ());
1610  	if (this->wallet.wallet_m->store.valid_password (transaction))
1611  	{
1612  		lock_toggle->setText ("Lock");
1613  		password->setDisabled (1);
1614  	}
1615  	representative->setToolTip ("In the infrequent case where the network needs to make a global decision,\nyour wallet software performs a balance-weighted vote to determine\nthe outcome. Since not everyone can remain online and perform this duty,\nyour wallet names a representative that can vote with, but cannot spend,\nyour balance.");
1616  	refresh_representative ();
1617  }
1618  void nano_qt::settings::refresh_representative ()
1619  {
1620  	auto transaction (this->wallet.wallet_m->wallets.node.store.tx_begin_read ());
1621  	nano::account_info info;
1622  	auto error (wallet.node.store.account.get (transaction, this->wallet.account, info));
1623  	if (!error)
1624  	{
1625  		current_representative->setText (QString (info.representative.to_account ().c_str ()));
1626  	}
1627  	else
1628  	{
1629  		auto wallet_transaction (this->wallet.wallet_m->wallets.tx_begin_read ());
1630  		current_representative->setText (this->wallet.wallet_m->store.representative (wallet_transaction).to_account ().c_str ());
1631  	}
1632  }
1633  void nano_qt::settings::activate ()
1634  {
1635  	this->wallet.push_main_stack (window);
1636  }
1637  void nano_qt::settings::update_locked (bool invalid, bool vulnerable)
1638  {
1639  	if (invalid)
1640  	{
1641  		this->wallet.active_status.insert (nano_qt::status_types::locked);
1642  	}
1643  	else
1644  	{
1645  		this->wallet.active_status.erase (nano_qt::status_types::locked);
1646  	}
1647  	if (vulnerable)
1648  	{
1649  		this->wallet.active_status.insert (nano_qt::status_types::vulnerable);
1650  	}
1651  	else
1652  	{
1653  		this->wallet.active_status.erase (nano_qt::status_types::vulnerable);
1654  	}
1655  }
1656  nano_qt::advanced_actions::advanced_actions (nano_qt::wallet & wallet_a) :
1657  	window (new QWidget),
1658  	layout (new QVBoxLayout),
1659  	show_ledger (new QPushButton ("Ledger")),
1660  	show_peers (new QPushButton ("Peers")),
1661  	search_for_receivables (new QPushButton ("Search for receivables")),
1662  	bootstrap (new QPushButton ("Initiate bootstrap")),
1663  	wallet_refresh (new QPushButton ("Refresh Wallet")),
1664  	create_block (new QPushButton ("Create Block")),
1665  	enter_block (new QPushButton ("Enter Block")),
1666  	block_viewer (new QPushButton ("Block Viewer")),
1667  	account_viewer (new QPushButton ("Account Viewer")),
1668  	stats_viewer (new QPushButton ("Node Statistics")),
1669  	scale_window (new QWidget),
1670  	scale_layout (new QHBoxLayout),
1671  	scale_label (new QLabel ("Scale:")),
1672  	ratio_group (new QButtonGroup),
1673  	nano_unit (new QRadioButton ("nano")),
1674  	raw_unit (new QRadioButton ("raw")),
1675  	back (new QPushButton ("Back")),
1676  	ledger_window (new QWidget),
1677  	ledger_layout (new QVBoxLayout),
1678  	ledger_model (new QStandardItemModel),
1679  	ledger_view (new QTableView),
1680  	ledger_refresh (new QPushButton ("Refresh")),
1681  	ledger_back (new QPushButton ("Back")),
1682  	peers_window (new QWidget),
1683  	peers_layout (new QVBoxLayout),
1684  	peers_model (new QStandardItemModel),
1685  	peers_view (new QTableView),
1686  	peer_summary_layout (new QHBoxLayout),
1687  	bootstrap_label (new QLabel ("IPV6:port \"::ffff:192.168.0.1:7075\"")),
1688  	peer_count_label (new QLabel ("")),
1689  	bootstrap_line (new QLineEdit),
1690  	peers_bootstrap (new QPushButton ("Initiate Bootstrap")),
1691  	peers_refresh (new QPushButton ("Refresh")),
1692  	peers_back (new QPushButton ("Back")),
1693  	wallet (wallet_a)
1694  {
1695  	ratio_group->addButton (nano_unit);
1696  	ratio_group->setId (nano_unit, ratio_group->buttons ().size () - 1);
1697  	ratio_group->addButton (raw_unit);
1698  	ratio_group->setId (raw_unit, ratio_group->buttons ().size () - 1);
1699  	scale_layout->addWidget (scale_label);
1700  	scale_layout->addWidget (nano_unit);
1701  	scale_layout->addWidget (raw_unit);
1702  	scale_window->setLayout (scale_layout);
1703  	ledger_model->setHorizontalHeaderItem (0, new QStandardItem ("Account"));
1704  	ledger_model->setHorizontalHeaderItem (1, new QStandardItem ("Balance"));
1705  	ledger_model->setHorizontalHeaderItem (2, new QStandardItem ("Block"));
1706  	ledger_view->setModel (ledger_model);
1707  	ledger_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1708  	ledger_view->verticalHeader ()->hide ();
1709  	ledger_view->horizontalHeader ()->setStretchLastSection (true);
1710  	ledger_layout->addWidget (ledger_view);
1711  	ledger_layout->addWidget (ledger_refresh);
1712  	ledger_layout->addWidget (ledger_back);
1713  	ledger_layout->setContentsMargins (0, 0, 0, 0);
1714  	ledger_window->setLayout (ledger_layout);
1715  	peers_model->setHorizontalHeaderItem (0, new QStandardItem ("IPv6 address:port"));
1716  	peers_model->setHorizontalHeaderItem (1, new QStandardItem ("Net version"));
1717  	peers_model->setHorizontalHeaderItem (2, new QStandardItem ("Node ID"));
1718  	peers_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
1719  	peers_view->verticalHeader ()->hide ();
1720  	peers_view->setModel (peers_model);
1721  	peers_view->setColumnWidth (0, 220);
1722  	peers_view->setSortingEnabled (true);
1723  	peers_view->horizontalHeader ()->setStretchLastSection (true);
1724  	peers_layout->addWidget (peers_view);
1725  	peer_summary_layout->addWidget (bootstrap_label);
1726  	peer_summary_layout->addStretch ();
1727  	peer_summary_layout->addWidget (peer_count_label);
1728  	peers_layout->addLayout (peer_summary_layout);
1729  	peers_layout->addWidget (bootstrap_line);
1730  	peers_layout->addWidget (peers_bootstrap);
1731  	peers_layout->addWidget (peers_refresh);
1732  	peers_layout->addWidget (peers_back);
1733  	peers_layout->setContentsMargins (0, 0, 0, 0);
1734  	peers_window->setLayout (peers_layout);
1735  	layout->addWidget (show_ledger);
1736  	layout->addWidget (show_peers);
1737  	layout->addWidget (search_for_receivables);
1738  	layout->addWidget (bootstrap);
1739  	layout->addWidget (wallet_refresh);
1740  	layout->addWidget (create_block);
1741  	layout->addWidget (enter_block);
1742  	layout->addWidget (block_viewer);
1743  	layout->addWidget (account_viewer);
1744  	layout->addWidget (stats_viewer);
1745  	layout->addWidget (scale_window);
1746  	layout->addStretch ();
1747  	layout->addWidget (back);
1748  	window->setLayout (layout);
1749  	QObject::connect (nano_unit, &QRadioButton::toggled, [this] () {
1750  		if (nano_unit->isChecked ())
1751  		{
1752  			this->wallet.change_rendering_ratio (nano::Mxrb_ratio);
1753  			QSettings ().setValue (saved_ratio_key, ratio_group->id (nano_unit));
1754  		}
1755  	});
1756  	QObject::connect (raw_unit, &QRadioButton::toggled, [this] () {
1757  		if (raw_unit->isChecked ())
1758  		{
1759  			this->wallet.change_rendering_ratio (nano::raw_ratio);
1760  			QSettings ().setValue (saved_ratio_key, ratio_group->id (raw_unit));
1761  		}
1762  	});
1763  	auto selected_ratio_button = ratio_group->button (QSettings ().value (saved_ratio_key).toInt ());
1764  	if (selected_ratio_button == nullptr)
1765  	{
1766  		selected_ratio_button = nano_unit;
1767  	}
1768  	debug_assert (selected_ratio_button != nullptr);
1769  	selected_ratio_button->click ();
1770  	QSettings ().setValue (saved_ratio_key, ratio_group->id (selected_ratio_button));
1771  	QObject::connect (wallet_refresh, &QPushButton::released, [this] () {
1772  		this->wallet.accounts.refresh ();
1773  		this->wallet.accounts.refresh_wallet_balance ();
1774  	});
1775  	QObject::connect (show_peers, &QPushButton::released, [this] () {
1776  		refresh_peers ();
1777  		this->wallet.push_main_stack (peers_window);
1778  	});
1779  	QObject::connect (show_ledger, &QPushButton::released, [this] () {
1780  		this->wallet.push_main_stack (ledger_window);
1781  	});
1782  	QObject::connect (back, &QPushButton::released, [this] () {
1783  		this->wallet.pop_main_stack ();
1784  	});
1785  	QObject::connect (peers_back, &QPushButton::released, [this] () {
1786  		this->wallet.pop_main_stack ();
1787  	});
1788  	QObject::connect (peers_bootstrap, &QPushButton::released, [this] () {
1789  		nano::endpoint endpoint;
1790  		auto error (nano::parse_endpoint (bootstrap_line->text ().toStdString (), endpoint));
1791  		if (!error)
1792  		{
1793  			show_line_ok (*bootstrap_line);
1794  			bootstrap_line->clear ();
1795  			this->wallet.node.bootstrap_initiator.bootstrap (endpoint);
1796  		}
1797  		else
1798  		{
1799  			show_line_error (*bootstrap_line);
1800  		}
1801  	});
1802  	QObject::connect (peers_refresh, &QPushButton::released, [this] () {
1803  		refresh_peers ();
1804  	});
1805  	QObject::connect (ledger_refresh, &QPushButton::released, [this] () {
1806  		refresh_ledger ();
1807  	});
1808  	QObject::connect (ledger_back, &QPushButton::released, [this] () {
1809  		this->wallet.pop_main_stack ();
1810  	});
1811  	QObject::connect (search_for_receivables, &QPushButton::released, [this] () {
1812  		std::thread ([this] { this->wallet.wallet_m->search_receivable (this->wallet.wallet_m->wallets.tx_begin_read ()); }).detach ();
1813  	});
1814  	QObject::connect (bootstrap, &QPushButton::released, [this] () {
1815  		std::thread ([this] { this->wallet.node.bootstrap_initiator.bootstrap (); }).detach ();
1816  	});
1817  	QObject::connect (create_block, &QPushButton::released, [this] () {
1818  		this->wallet.push_main_stack (this->wallet.block_creation.window);
1819  	});
1820  	QObject::connect (enter_block, &QPushButton::released, [this] () {
1821  		this->wallet.push_main_stack (this->wallet.block_entry.window);
1822  	});
1823  	QObject::connect (block_viewer, &QPushButton::released, [this] () {
1824  		this->wallet.push_main_stack (this->wallet.block_viewer.window);
1825  	});
1826  	QObject::connect (account_viewer, &QPushButton::released, [this] () {
1827  		this->wallet.push_main_stack (this->wallet.account_viewer.window);
1828  	});
1829  	QObject::connect (stats_viewer, &QPushButton::released, [this] () {
1830  		this->wallet.push_main_stack (this->wallet.stats_viewer.window);
1831  		this->wallet.stats_viewer.refresh_stats ();
1832  	});
1833  	bootstrap->setToolTip ("Multi-connection bootstrap to random peers");
1834  	search_for_receivables->setToolTip ("Search for ready to be received blocks");
1835  	create_block->setToolTip ("Create block in JSON format");
1836  	enter_block->setToolTip ("Enter block in JSON format");
1837  }
1838  void nano_qt::advanced_actions::refresh_peers ()
1839  {
1840  	peers_model->removeRows (0, peers_model->rowCount ());
1841  	auto list (wallet.node.network.list (std::numeric_limits<size_t>::max ()));
1842  	std::sort (list.begin (), list.end (), [] (auto const & lhs, auto const & rhs) {
1843  		return lhs->get_endpoint () < rhs->get_endpoint ();
1844  	});
1845  	for (auto i (list.begin ()), n (list.end ()); i != n; ++i)
1846  	{
1847  		std::stringstream endpoint;
1848  		auto channel (*i);
1849  		endpoint << channel->to_string ();
1850  		QString qendpoint (endpoint.str ().c_str ());
1851  		QList<QStandardItem *> items;
1852  		items.push_back (new QStandardItem (qendpoint));
1853  		auto version = new QStandardItem ();
1854  		version->setData (QVariant (channel->get_network_version ()), Qt::DisplayRole);
1855  		items.push_back (version);
1856  		QString node_id ("");
1857  		auto node_id_l (channel->get_node_id_optional ());
1858  		if (node_id_l.is_initialized ())
1859  		{
1860  			node_id = node_id_l.get ().to_account ().c_str ();
1861  		}
1862  		items.push_back (new QStandardItem (node_id));
1863  		peers_model->appendRow (items);
1864  	}
1865  	peer_count_label->setText (QString ("%1 peers").arg (peers_model->rowCount ()));
1866  }
1867  void nano_qt::advanced_actions::refresh_ledger ()
1868  {
1869  	ledger_model->removeRows (0, ledger_model->rowCount ());
1870  	auto transaction (wallet.node.store.tx_begin_read ());
1871  	for (auto i (wallet.node.ledger.store.account.begin (transaction)), j (wallet.node.ledger.store.account.end ()); i != j; ++i)
1872  	{
1873  		QList<QStandardItem *> items;
1874  		items.push_back (new QStandardItem (QString (i->first.to_account ().c_str ())));
1875  		nano::account_info const & info (i->second);
1876  		std::string balance;
1877  		nano::amount (info.balance.number () / wallet.rendering_ratio).encode_dec (balance);
1878  		items.push_back (new QStandardItem (QString (balance.c_str ())));
1879  		std::string block_hash;
1880  		info.head.encode_hex (block_hash);
1881  		items.push_back (new QStandardItem (QString (block_hash.c_str ())));
1882  		ledger_model->appendRow (items);
1883  	}
1884  }
1885  void nano_qt::advanced_actions::refresh_stats ()
1886  {
1887  	wallet.stats_viewer.refresh_stats ();
1888  }
1889  nano_qt::block_entry::block_entry (nano_qt::wallet & wallet_a) :
1890  	window (new QWidget),
1891  	layout (new QVBoxLayout),
1892  	block (new QPlainTextEdit),
1893  	status (new QLabel),
1894  	process (new QPushButton ("Process")),
1895  	back (new QPushButton ("Back")),
1896  	wallet (wallet_a)
1897  {
1898  	layout->addWidget (block);
1899  	layout->addWidget (status);
1900  	layout->addWidget (process);
1901  	layout->addWidget (back);
1902  	window->setLayout (layout);
1903  	QObject::connect (process, &QPushButton::released, [this] () {
1904  		auto string (block->toPlainText ().toStdString ());
1905  		try
1906  		{
1907  			boost::property_tree::ptree tree;
1908  			std::stringstream istream (string);
1909  			boost::property_tree::read_json (istream, tree);
1910  			auto block_l (nano::deserialize_block_json (tree));
1911  			if (block_l != nullptr)
1912  			{
1913  				show_label_ok (*status);
1914  				this->status->setText ("");
1915  				if (!this->wallet.node.network_params.work.validate_entry (*block_l))
1916  				{
1917  					this->wallet.node.process_active (std::move (block_l));
1918  				}
1919  				else
1920  				{
1921  					show_label_error (*status);
1922  					this->status->setText ("Invalid work");
1923  				}
1924  			}
1925  			else
1926  			{
1927  				show_label_error (*status);
1928  				this->status->setText ("Unable to parse block");
1929  			}
1930  		}
1931  		catch (std::runtime_error const &)
1932  		{
1933  			show_label_error (*status);
1934  			this->status->setText ("Unable to parse block");
1935  		}
1936  	});
1937  	QObject::connect (back, &QPushButton::released, [this] () {
1938  		this->wallet.pop_main_stack ();
1939  	});
1940  }
1941  nano_qt::block_creation::block_creation (nano_qt::wallet & wallet_a) :
1942  	window (new QWidget),
1943  	layout (new QVBoxLayout),
1944  	group (new QButtonGroup),
1945  	button_layout (new QHBoxLayout),
1946  	send (new QRadioButton ("Send")),
1947  	receive (new QRadioButton ("Receive")),
1948  	change (new QRadioButton ("Change")),
1949  	open (new QRadioButton ("Open")),
1950  	account_label (new QLabel ("Account:")),
1951  	account (new QLineEdit),
1952  	source_label (new QLabel ("Source:")),
1953  	source (new QLineEdit),
1954  	amount_label (new QLabel ("Amount:")),
1955  	amount (new QLineEdit),
1956  	destination_label (new QLabel ("Destination:")),
1957  	destination (new QLineEdit),
1958  	representative_label (new QLabel ("Representative:")),
1959  	representative (new QLineEdit),
1960  	block (new QPlainTextEdit),
1961  	status (new QLabel),
1962  	create (new QPushButton ("Create")),
1963  	back (new QPushButton ("Back")),
1964  	wallet (wallet_a)
1965  {
1966  	group->addButton (send);
1967  	group->addButton (receive);
1968  	group->addButton (change);
1969  	group->addButton (open);
1970  	group->setId (send, 0);
1971  	group->setId (receive, 1);
1972  	group->setId (change, 2);
1973  	group->setId (open, 3);
1974  	button_layout->addWidget (send);
1975  	button_layout->addWidget (receive);
1976  	button_layout->addWidget (open);
1977  	button_layout->addWidget (change);
1978  	layout->addLayout (button_layout);
1979  	layout->addWidget (account_label);
1980  	layout->addWidget (account);
1981  	layout->addWidget (source_label);
1982  	layout->addWidget (source);
1983  	layout->addWidget (amount_label);
1984  	layout->addWidget (amount);
1985  	layout->addWidget (destination_label);
1986  	layout->addWidget (destination);
1987  	layout->addWidget (representative_label);
1988  	layout->addWidget (representative);
1989  	layout->addWidget (block);
1990  	layout->addWidget (status);
1991  	layout->addWidget (create);
1992  	layout->addWidget (back);
1993  	window->setLayout (layout);
1994  	QObject::connect (send, &QRadioButton::toggled, [this] (bool on) {
1995  		if (on)
1996  		{
1997  			deactivate_all ();
1998  			activate_send ();
1999  		}
2000  	});
2001  	QObject::connect (receive, &QRadioButton::toggled, [this] (bool on) {
2002  		if (on)
2003  		{
2004  			deactivate_all ();
2005  			activate_receive ();
2006  		}
2007  	});
2008  	QObject::connect (open, &QRadioButton::toggled, [this] (bool on) {
2009  		if (on)
2010  		{
2011  			deactivate_all ();
2012  			activate_open ();
2013  		}
2014  	});
2015  	QObject::connect (change, &QRadioButton::toggled, [this] (bool on) {
2016  		if (on)
2017  		{
2018  			deactivate_all ();
2019  			activate_change ();
2020  		}
2021  	});
2022  	QObject::connect (create, &QPushButton::released, [this] () {
2023  		switch (group->checkedId ())
2024  		{
2025  			case 0:
2026  				create_send ();
2027  				break;
2028  			case 1:
2029  				create_receive ();
2030  				break;
2031  			case 2:
2032  				create_change ();
2033  				break;
2034  			case 3:
2035  				create_open ();
2036  				break;
2037  			default:
2038  				debug_assert (false);
2039  				break;
2040  		}
2041  	});
2042  	QObject::connect (back, &QPushButton::released, [this] () {
2043  		this->wallet.pop_main_stack ();
2044  	});
2045  	QObject::connect (account, &QLineEdit::textChanged, [this] (const QString & value) {
2046  		auto pos = account->cursorPosition ();
2047  		account->setText (value.trimmed ());
2048  		account->setCursorPosition (pos);
2049  	});
2050  	QObject::connect (destination, &QLineEdit::textChanged, [this] (const QString & value) {
2051  		auto pos = destination->cursorPosition ();
2052  		destination->setText (value.trimmed ());
2053  		destination->setCursorPosition (pos);
2054  	});
2055  	QObject::connect (amount, &QLineEdit::textChanged, [this] (const QString & value) {
2056  		auto pos = amount->cursorPosition ();
2057  		amount->setText (value.trimmed ());
2058  		amount->setCursorPosition (pos);
2059  	});
2060  	QObject::connect (source, &QLineEdit::textChanged, [this] (const QString & value) {
2061  		auto pos = source->cursorPosition ();
2062  		source->setText (value.trimmed ());
2063  		source->setCursorPosition (pos);
2064  	});
2065  	QObject::connect (representative, &QLineEdit::textChanged, [this] (const QString & value) {
2066  		auto pos = representative->cursorPosition ();
2067  		representative->setText (value.trimmed ());
2068  		representative->setCursorPosition (pos);
2069  	});
2070  	send->click ();
2071  }
2072  void nano_qt::block_creation::deactivate_all ()
2073  {
2074  	account_label->hide ();
2075  	account->hide ();
2076  	source_label->hide ();
2077  	source->hide ();
2078  	amount_label->hide ();
2079  	amount->hide ();
2080  	destination_label->hide ();
2081  	destination->hide ();
2082  	representative_label->hide ();
2083  	representative->hide ();
2084  }
2085  void nano_qt::block_creation::activate_send ()
2086  {
2087  	account_label->show ();
2088  	account->show ();
2089  	amount_label->show ();
2090  	amount->show ();
2091  	destination_label->show ();
2092  	destination->show ();
2093  }
2094  void nano_qt::block_creation::activate_receive ()
2095  {
2096  	source_label->show ();
2097  	source->show ();
2098  }
2099  void nano_qt::block_creation::activate_open ()
2100  {
2101  	source_label->show ();
2102  	source->show ();
2103  	representative_label->show ();
2104  	representative->show ();
2105  }
2106  void nano_qt::block_creation::activate_change ()
2107  {
2108  	account_label->show ();
2109  	account->show ();
2110  	representative_label->show ();
2111  	representative->show ();
2112  }
2113  void nano_qt::block_creation::create_send ()
2114  {
2115  	nano::account account_l;
2116  	auto error (account_l.decode_account (account->text ().toStdString ()));
2117  	if (!error)
2118  	{
2119  		nano::amount amount_l;
2120  		error = amount_l.decode_dec (amount->text ().toStdString ());
2121  		if (!error)
2122  		{
2123  			nano::account destination_l;
2124  			error = destination_l.decode_account (destination->text ().toStdString ());
2125  			if (!error)
2126  			{
2127  				auto transaction (wallet.node.wallets.tx_begin_read ());
2128  				auto block_transaction (wallet.node.store.tx_begin_read ());
2129  				nano::raw_key key;
2130  				if (!wallet.wallet_m->store.fetch (transaction, account_l, key))
2131  				{
2132  					auto balance (wallet.node.ledger.account_balance (block_transaction, account_l));
2133  					if (amount_l.number () <= balance)
2134  					{
2135  						nano::account_info info;
2136  						auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2137  						(void)error;
2138  						debug_assert (!error);
2139  						nano::state_block send (account_l, info.head, info.representative, balance - amount_l.number (), destination_l, key, account_l, 0);
2140  						nano::block_details details;
2141  						details.is_send = true;
2142  						details.epoch = info.epoch ();
2143  						auto const required_difficulty{ wallet.node.network_params.work.threshold (send.work_version (), details) };
2144  						if (wallet.node.work_generate_blocking (send, required_difficulty).is_initialized ())
2145  						{
2146  							std::string block_l;
2147  							send.serialize_json (block_l);
2148  							block->setPlainText (QString (block_l.c_str ()));
2149  							show_label_ok (*status);
2150  							status->setText ("Created block");
2151  						}
2152  						else
2153  						{
2154  							debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (send.work_version ()));
2155  							show_label_error (*status);
2156  							if (wallet.node.work_generation_enabled ())
2157  							{
2158  								status->setText ("Work generation failure");
2159  							}
2160  							else
2161  							{
2162  								status->setText ("Work generation is disabled");
2163  							}
2164  						}
2165  					}
2166  					else
2167  					{
2168  						show_label_error (*status);
2169  						status->setText ("Insufficient balance");
2170  					}
2171  				}
2172  				else
2173  				{
2174  					show_label_error (*status);
2175  					status->setText ("Account is not in wallet");
2176  				}
2177  			}
2178  			else
2179  			{
2180  				show_label_error (*status);
2181  				status->setText ("Unable to decode destination");
2182  			}
2183  		}
2184  		else
2185  		{
2186  			show_label_error (*status);
2187  			status->setText ("Unable to decode amount");
2188  		}
2189  	}
2190  	else
2191  	{
2192  		show_label_error (*status);
2193  		status->setText ("Unable to decode account");
2194  	}
2195  }
2196  void nano_qt::block_creation::create_receive ()
2197  {
2198  	nano::block_hash source_l;
2199  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2200  	if (!error)
2201  	{
2202  		auto transaction (wallet.node.wallets.tx_begin_read ());
2203  		auto block_transaction (wallet.node.store.tx_begin_read ());
2204  		auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2205  		if (block_l != nullptr)
2206  		{
2207  			auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2208  			if (!destination.is_zero ())
2209  			{
2210  				nano::pending_key pending_key (destination, source_l);
2211  				nano::pending_info pending;
2212  				if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2213  				{
2214  					nano::account_info info;
2215  					auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2216  					if (!error)
2217  					{
2218  						nano::raw_key key;
2219  						auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2220  						if (!error)
2221  						{
2222  							nano::state_block receive (pending_key.account, info.head, info.representative, info.balance.number () + pending.amount.number (), source_l, key, pending_key.account, 0);
2223  							nano::block_details details;
2224  							details.is_receive = true;
2225  							details.epoch = std::max (info.epoch (), pending.epoch);
2226  							auto required_difficulty{ wallet.node.network_params.work.threshold (receive.work_version (), details) };
2227  							if (wallet.node.work_generate_blocking (receive, required_difficulty).is_initialized ())
2228  							{
2229  								std::string block_l;
2230  								receive.serialize_json (block_l);
2231  								block->setPlainText (QString (block_l.c_str ()));
2232  								show_label_ok (*status);
2233  								status->setText ("Created block");
2234  							}
2235  							else
2236  							{
2237  								debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (receive.work_version ()));
2238  								show_label_error (*status);
2239  								if (wallet.node.work_generation_enabled ())
2240  								{
2241  									status->setText ("Work generation failure");
2242  								}
2243  								else
2244  								{
2245  									status->setText ("Work generation is disabled");
2246  								}
2247  							}
2248  						}
2249  						else
2250  						{
2251  							show_label_error (*status);
2252  							status->setText ("Account is not in wallet");
2253  						}
2254  					}
2255  					else
2256  					{
2257  						show_label_error (*status);
2258  						status->setText ("Account not yet open");
2259  					}
2260  				}
2261  				else
2262  				{
2263  					show_label_error (*status);
2264  					status->setText ("Source block is not ready to be received");
2265  				}
2266  			}
2267  			else
2268  			{
2269  				show_label_error (*status);
2270  				status->setText ("Source is not a send block");
2271  			}
2272  		}
2273  		else
2274  		{
2275  			show_label_error (*status);
2276  			status->setText ("Source block not found");
2277  		}
2278  	}
2279  	else
2280  	{
2281  		show_label_error (*status);
2282  		status->setText ("Unable to decode source");
2283  	}
2284  }
2285  void nano_qt::block_creation::create_change ()
2286  {
2287  	nano::account account_l;
2288  	auto error (account_l.decode_account (account->text ().toStdString ()));
2289  	if (!error)
2290  	{
2291  		nano::account representative_l;
2292  		error = representative_l.decode_account (representative->text ().toStdString ());
2293  		if (!error)
2294  		{
2295  			auto transaction (wallet.node.wallets.tx_begin_read ());
2296  			auto block_transaction (wallet.node.store.tx_begin_read ());
2297  			nano::account_info info;
2298  			auto error (wallet.node.store.account.get (block_transaction, account_l, info));
2299  			if (!error)
2300  			{
2301  				nano::raw_key key;
2302  				auto error (wallet.wallet_m->store.fetch (transaction, account_l, key));
2303  				if (!error)
2304  				{
2305  					nano::state_block change (account_l, info.head, representative_l, info.balance, 0, key, account_l, 0);
2306  					nano::block_details details;
2307  					details.epoch = info.epoch ();
2308  					auto const required_difficulty{ wallet.node.network_params.work.threshold (change.work_version (), details) };
2309  					if (wallet.node.work_generate_blocking (change, required_difficulty).is_initialized ())
2310  					{
2311  						std::string block_l;
2312  						change.serialize_json (block_l);
2313  						block->setPlainText (QString (block_l.c_str ()));
2314  						show_label_ok (*status);
2315  						status->setText ("Created block");
2316  					}
2317  					else
2318  					{
2319  						debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (change.work_version ()));
2320  						show_label_error (*status);
2321  						if (wallet.node.work_generation_enabled ())
2322  						{
2323  							status->setText ("Work generation failure");
2324  						}
2325  						else
2326  						{
2327  							status->setText ("Work generation is disabled");
2328  						}
2329  					}
2330  				}
2331  				else
2332  				{
2333  					show_label_error (*status);
2334  					status->setText ("Account is not in wallet");
2335  				}
2336  			}
2337  			else
2338  			{
2339  				show_label_error (*status);
2340  				status->setText ("Account not yet open");
2341  			}
2342  		}
2343  		else
2344  		{
2345  			show_label_error (*status);
2346  			status->setText ("Unable to decode representative");
2347  		}
2348  	}
2349  	else
2350  	{
2351  		show_label_error (*status);
2352  		status->setText ("Unable to decode account");
2353  	}
2354  }
2355  void nano_qt::block_creation::create_open ()
2356  {
2357  	nano::block_hash source_l;
2358  	auto error (source_l.decode_hex (source->text ().toStdString ()));
2359  	if (!error)
2360  	{
2361  		nano::account representative_l;
2362  		error = representative_l.decode_account (representative->text ().toStdString ());
2363  		if (!error)
2364  		{
2365  			auto transaction (wallet.node.wallets.tx_begin_read ());
2366  			auto block_transaction (wallet.node.store.tx_begin_read ());
2367  			auto block_l (wallet.node.store.block.get (block_transaction, source_l));
2368  			if (block_l != nullptr)
2369  			{
2370  				auto const & destination (wallet.node.ledger.block_destination (block_transaction, *block_l));
2371  				if (!destination.is_zero ())
2372  				{
2373  					nano::pending_key pending_key (destination, source_l);
2374  					nano::pending_info pending;
2375  					if (!wallet.node.store.pending.get (block_transaction, pending_key, pending))
2376  					{
2377  						nano::account_info info;
2378  						auto error (wallet.node.store.account.get (block_transaction, pending_key.account, info));
2379  						if (error)
2380  						{
2381  							nano::raw_key key;
2382  							auto error (wallet.wallet_m->store.fetch (transaction, pending_key.account, key));
2383  							if (!error)
2384  							{
2385  								nano::state_block open (pending_key.account, 0, representative_l, pending.amount, source_l, key, pending_key.account, 0);
2386  								nano::block_details details;
2387  								details.is_receive = true;
2388  								details.epoch = pending.epoch;
2389  								auto const required_difficulty{ wallet.node.network_params.work.threshold (open.work_version (), details) };
2390  								if (wallet.node.work_generate_blocking (open, required_difficulty).is_initialized ())
2391  								{
2392  									std::string block_l;
2393  									open.serialize_json (block_l);
2394  									block->setPlainText (QString (block_l.c_str ()));
2395  									show_label_ok (*status);
2396  									status->setText ("Created block");
2397  								}
2398  								else
2399  								{
2400  									debug_assert (required_difficulty <= wallet.node.max_work_generate_difficulty (open.work_version ()));
2401  									show_label_error (*status);
2402  									if (wallet.node.work_generation_enabled ())
2403  									{
2404  										status->setText ("Work generation failure");
2405  									}
2406  									else
2407  									{
<span onclick='openModal()' class='match'>2408  										status->setText ("Work generation is disabled");
2409  									}
2410  								}
2411  							}
2412  							else
2413  							{
2414  								show_label_error (*status);
2415  								status->setText ("Account is not in wallet");
2416  							}
</span>2417  						}
2418  						else
2419  						{
2420  							show_label_error (*status);
2421  							status->setText ("Account already open");
2422  						}
2423  					}
2424  					else
2425  					{
2426  						show_label_error (*status);
2427  						status->setText ("Source block is not ready to be received");
2428  					}
2429  				}
2430  				else
2431  				{
2432  					show_label_error (*status);
2433  					status->setText ("Source is not a send block");
2434  				}
2435  			}
2436  			else
2437  			{
2438  				show_label_error (*status);
2439  				status->setText ("Source block not found");
2440  			}
2441  		}
2442  		else
2443  		{
2444  			show_label_error (*status);
2445  			status->setText ("Unable to decode representative");
2446  		}
2447  	}
2448  	else
2449  	{
2450  		show_label_error (*status);
2451  		status->setText ("Unable to decode source");
2452  	}
2453  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>2245  									status->setText ("Work generation is disabled");
2246  								}
2247  							}
2248  						}
2249  						else
2250  						{
2251  							show_label_error (*status);
2252  							status->setText ("Account is not in wallet");
2253  						}
</pre></code></div>
                <div class="column column_space"><pre><code>2408  										status->setText ("Work generation is disabled");
2409  									}
2410  								}
2411  							}
2412  							else
2413  							{
2414  								show_label_error (*status);
2415  								status->setText ("Account is not in wallet");
2416  							}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    