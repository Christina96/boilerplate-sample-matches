<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for BaseTestDataAccess.cpp & BaseTestDimension.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for BaseTestDataAccess.cpp & BaseTestDimension.cpp
      </h3>
      <h1 align="center">
        15.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>BaseTestDataAccess.cpp (13.787375%)<TH>BaseTestDimension.cpp (17.043121%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(37-67)<TD><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-1.html#0',3)" NAME="0">(247-299)</A><TD ALIGN=center><FONT COLOR="#ff0000">48</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-1.html#1',3)" NAME="1">(936-953)<TD><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-1.html#1',3)" NAME="1">(901-916)</A><TD ALIGN=center><FONT COLOR="#8f0000">27</FONT>
<TR onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-1.html#2',3)" NAME="2">(652-661)<TD><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-1.html#2',3)" NAME="2">(206-213)</A><TD ALIGN=center><FONT COLOR="#640000">19</FONT>
<TR onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-1.html#3',3)" NAME="3">(236-309)<TD><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-1.html#3',3)" NAME="3">(746-767)</A><TD ALIGN=center><FONT COLOR="#640000">19</FONT>
<TR onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-1.html#4',3)" NAME="4">(398-412)<TD><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-1.html#4',3)" NAME="4">(538-555)</A><TD ALIGN=center><FONT COLOR="#550000">16</FONT>
<TR onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-1.html#5',3)" NAME="5">(90-100)<TD><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-1.html#5',3)" NAME="5">(770-783)</A><TD ALIGN=center><FONT COLOR="#450000">13</FONT>
<TR onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-1.html#6',3)" NAME="6">(767-779)<TD><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-1.html#6',3)" NAME="6">(606-616)</A><TD ALIGN=center><FONT COLOR="#3f0000">12</FONT>
<TR onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-1.html#7',3)" NAME="7">(175-183)<TD><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-1.html#7',3)" NAME="7">(887-895)</A><TD ALIGN=center><FONT COLOR="#3f0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDataAccess.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #ifdef _MSC_VER
2 #pragma warning(push)
3 #pragma warning(disable: 4996)
4 #endif
5 #include &lt;iostream&gt;
6 #include &lt;sstream&gt;
7 #include &lt;iterator&gt;
8 #include &lt;stdexcept&gt;
9 #include &lt;nix/hydra/multiArray.hpp&gt;
10 #include &lt;nix/util/dataAccess.hpp&gt;
11 #include &lt;cppunit/extensions/HelperMacros.h&gt;
12 #include &lt;cppunit/CompilerOutputter.h&gt;
13 #include &lt;cppunit/TestResult.h&gt;
14 #include &lt;cppunit/TestResultCollector.h&gt;
15 #include &lt;cppunit/TestRunner.h&gt;
16 #include &lt;cppunit/BriefTestProgressListener.h&gt;
17 #include &quot;BaseTestDataAccess.hpp&quot;
18 using namespace nix;
19 using namespace std;
20 using namespace boost;
21 <A NAME="0"></A>void BaseTestDataAccess::testPositionToIndexRangeDimension() {
22     string unit = &quot;ms&quot;;
23     string invalid_unit = &quot;kV&quot;;
24 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match943-1.html#0',3,'match943-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    string scaled_unit = &quot;s&quot;;
25     CPPUNIT_ASSERT_THROW(util::positionToIndex(5.0, invalid_unit, rangeDim), nix::IncompatibleDimensions);
26     CPPUNIT_ASSERT(*util::positionToIndex(5.0, unit, PositionMatch::Less, rangeDim) == 3);
27     CPPUNIT_ASSERT(*util::positionToIndex(0.005, scaled_unit, PositionMatch::Less, rangeDim) == 3);
28     CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Less, rangeDim));
29     CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::LessOrEqual, rangeDim));
30     CPPUNIT_ASSERT(!util::positionToIndex(1.0, unit, PositionMatch::Equal, rangeDim));
31     CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
32     CPPUNIT_ASSERT(*(util::positionToIndex(1.0, unit, PositionMatch::Greater, rangeDim)) == 0);
33     CPPUNIT_ASSERT(!util::positionToIndex(1.2, unit, PositionMatch::Less, rangeDim));
34     CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::LessOrEqual, rangeDim));
35     CPPUNIT_ASSERT(util::positionToIndex(1.2, unit, PositionMatch::Equal, rangeDim));
36     CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 0);
37     CPPUNIT_ASSERT(*(util::positionToIndex(1.2, unit, PositionMatch::Greater, rangeDim)) == 1);
38     CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Less, rangeDim) == 2);
39     CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::LessOrEqual, rangeDim) == 3);
40     CPPUNIT_ASSERT(*util::positionToIndex(4.5, unit, PositionMatch::Equal, rangeDim) == 3);
41     CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::GreaterOrEqual, rangeDim)) == 3);
42     CPPUNIT_ASSERT(*(util::positionToIndex(4.5, unit, PositionMatch::Greater, rangeDim)) == 4);
43     CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::Less, rangeDim) == 4);
44     CPPUNIT_ASSERT(*util::positionToIndex(7.0, unit, PositionMatch::LessOrEqual, rangeDim) == 4);
45     CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Equal, rangeDim));
46     CPPUNIT_ASSERT(!(util::positionToIndex(7.0, unit, PositionMatch::GreaterOrEqual, rangeDim)));
47     CPPUNIT_ASSERT(!util::positionToIndex(7.0, unit, PositionMatch::Greater, rangeDim));
48     CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 1.2}, {1.4}, {unit, unit}, RangeMatch::Inclusive, rangeDim), std::runtime_error);</B></FONT>
49     vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Inclusive, rangeDim);
50     CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
51     range = util::positionToIndex({0.0}, {7.0}, {unit}, RangeMatch::Exclusive, rangeDim);
52     CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 4);
53     range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Inclusive, rangeDim);
54     CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 4);
55     range = util::positionToIndex({2.0}, {6.7}, {unit}, RangeMatch::Exclusive, rangeDim);
56     CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 1 &amp;&amp; (*range[0]).second == 3);
57     range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Inclusive, rangeDim);
58     CPPUNIT_ASSERT(range[0] &amp;&amp; (*range[0]).first == 0 &amp;&amp; (*range[0]).second == 0);
59     range = util::positionToIndex({1.2}, {1.2}, {unit}, RangeMatch::Exclusive, rangeDim);
60     CPPUNIT_ASSERT(!range[0]);
61 }
62 void BaseTestDataAccess::testPositionToIndexRangeDimensionOld() {
63     string unit = &quot;ms&quot;;
64 <A NAME="5"></A>    string invalid_unit = &quot;kV&quot;;
65     string scaled_unit = &quot;s&quot;;
66 <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match943-1.html#5',3,'match943-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    CPPUNIT_ASSERT_THROW(util::positionToIndex(0.001, invalid_unit, rangeDim), nix::IncompatibleDimensions);
67     CPPUNIT_ASSERT_THROW(util::positionToIndex(8.0, unit, rangeDim), nix::OutOfBounds);
68     CPPUNIT_ASSERT(util::positionToIndex(0.001, unit, rangeDim) == 0);
69     CPPUNIT_ASSERT(util::positionToIndex(0.001, scaled_unit, rangeDim) == 0);
70     CPPUNIT_ASSERT_THROW(util::positionToIndex(0.008, scaled_unit, rangeDim), nix::OutOfBounds);
71     CPPUNIT_ASSERT(util::positionToIndex(3.4, unit, rangeDim) == 2);
72     CPPUNIT_ASSERT(util::positionToIndex(3.6, unit, rangeDim) == 3);
73     CPPUNIT_ASSERT(util::positionToIndex(4.0, unit, rangeDim) == 3);
74     CPPUNIT_ASSERT(util::positionToIndex(0.0034, scaled_unit, rangeDim) == 2);
75     vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; range = util::positionToIndex({0.001}, {3.4}, {unit}, rangeDim);</B></FONT>
76     CPPUNIT_ASSERT(range[0].first == 0 &amp;&amp; range[0].second == 2);
77     CPPUNIT_ASSERT_THROW(util::positionToIndex({0.001, 2.0}, {3.4}, {unit}, rangeDim), std::runtime_error);
78     CPPUNIT_ASSERT_THROW(util::positionToIndex({7.5}, {8.0}, {unit}, rangeDim), nix::OutOfBounds);
79 }
80 void BaseTestDataAccess::testGetDimensionUnit() {
81     std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
82                                      {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
83     DataFrame df = block.createDataFrame(&quot;test&quot;, &quot;test&quot;, cols);
84     data_array.appendDataFrameDimension(df);
85     data_array.appendDataFrameDimension(df, 1);
86     std::string unit = &quot;ms&quot;;
87     std::string no_unit = &quot;none&quot;;
88     std::vector&lt;Dimension&gt; dims = data_array.dimensions();
89     CPPUNIT_ASSERT(dims.size() == 6);
90     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[0]), no_unit);
91     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[1]), unit);
92     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[2]), unit);
93     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[3]), cols[0].unit);
94     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[4]), no_unit);
95     CPPUNIT_ASSERT_EQUAL(util::getDimensionUnit(dims[5]), no_unit);
96 }
97 void BaseTestDataAccess::testPositionToIndexSampledDimension() {
98     string unit = &quot;ms&quot;;
99     string invalid_unit = &quot;kV&quot;;
100     string scaled_unit = &quot;s&quot;;
101     CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, invalid_unit, sampledDim), nix::IncompatibleDimensions);
102     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, unit, sampledDim));
103     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(1.0, scaled_unit, sampledDim));
104     sampledDim.unit(nix::none);
105     CPPUNIT_ASSERT_THROW(util::positionToIndex(1.0, unit, sampledDim), nix::IncompatibleDimensions);
106     sampledDim.unit(unit);
107     vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Inclusive, sampledDim);
108     CPPUNIT_ASSERT(ranges.size() == 3);
109     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 10);
110     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 2 &amp;&amp; (*ranges[1]).second == 2);
111     CPPUNIT_ASSERT(!ranges[2]);
112     ranges = util::positionToIndex({0.0, 2.0, 10.0}, {10.0, 2.0, 5.0}, {unit, unit, unit}, RangeMatch::Exclusive, sampledDim);
113     CPPUNIT_ASSERT(ranges.size() == 3);
114     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 9);
115     CPPUNIT_ASSERT(!ranges[1]);
116     CPPUNIT_ASSERT(!ranges[2]); }
117 void BaseTestDataAccess::testPositionToIndexSampledDimensionOld() {
118     string unit = &quot;ms&quot;;
119     string invalid_unit = &quot;kV&quot;;
120     string scaled_unit = &quot;s&quot;;
121     CPPUNIT_ASSERT(util::positionToIndex(-8.0, unit, sampledDim) == 0);
122     CPPUNIT_ASSERT_THROW(util::positionToIndex(0.005, invalid_unit, sampledDim), nix::IncompatibleDimensions);
123     CPPUNIT_ASSERT(util::positionToIndex(5.0, unit, sampledDim) == 5);
124     CPPUNIT_ASSERT(util::positionToIndex(0.005, scaled_unit, sampledDim) == 5);
125     CPPUNIT_ASSERT_THROW(util::positionToIndex({},{1.0}, {unit}, sampledDim), std::runtime_error);
126     CPPUNIT_ASSERT_THROW(util::positionToIndex({0.0, 1.0}, {3.5, 0.5}, {unit, unit}, sampledDim), nix::OutOfBounds);
127     CPPUNIT_ASSERT(util::positionToIndex({0.0, 0.5}, {3.5, 1.0}, {unit, unit}, sampledDim).size() == 2);
128     vector&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = util::positionToIndex({0.0}, {0.0}, {unit}, sampledDim);
129     CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 0);
130 }
131 <A NAME="7"></A>
132 void BaseTestDataAccess::testPositionToIndexSetDimensionOld() {
133 <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match943-1.html#7',3,'match943-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::string unit = &quot;ms&quot;;
134     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(-5.9, &quot;none&quot;, setDim));     CPPUNIT_ASSERT_THROW(util::positionToIndex(5.8, &quot;none&quot;, setDim), nix::OutOfBounds);     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(0.5, &quot;none&quot;, setDim));
135     CPPUNIT_ASSERT(util::positionToIndex(0.5, &quot;none&quot;, setDim) == 1);
136     std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
137     CPPUNIT_ASSERT_THROW(util::positionToIndex({10}, {1.}, {&quot;none&quot;}, setDim), nix::OutOfBounds);</B></FONT>
138     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex({1}, {10.}, {&quot;none&quot;}, setDim));
139     int pos = -1;
140     CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(pos, &quot;Does not convert seamlessly to double!&quot;));
141     ndsize_t large_pos = pow(10, 16);
142     CPPUNIT_ASSERT_NO_THROW(check::converts_to_double(large_pos, &quot;Does not convert seamlessly to double!&quot;));
143     large_pos = pow(10, 16);
144     large_pos += 1;
145     CPPUNIT_ASSERT_THROW(check::converts_to_double(large_pos, &quot;Does not convert seamlessly to double!&quot;), nix::OutOfBounds);
146 }
147 void BaseTestDataAccess::testPositionToIndexSetDimension() {
148     CPPUNIT_ASSERT(!util::positionToIndex(5.8, PositionMatch::Equal, setDim));
149     CPPUNIT_ASSERT_THROW(util::positionToIndex({5.0, 0.}, {10.5}, RangeMatch::Inclusive, setDim), std::runtime_error);
150     vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Inclusive, setDim);
151     CPPUNIT_ASSERT(ranges.size() == 2);
152     CPPUNIT_ASSERT(!ranges[0]);
153     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 1);
154     ranges = util::positionToIndex({5.0, 0.}, {10.5, 1.0}, RangeMatch::Exclusive, setDim);
155     CPPUNIT_ASSERT(ranges.size() == 2);
156     CPPUNIT_ASSERT(!ranges[0]);
157     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 0);   
158 }
159 void BaseTestDataAccess::testPositionToIndexDataFrameDimension() {
160     CPPUNIT_ASSERT_NO_THROW(util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim));     boost::optional&lt;ndsize_t&gt; pos = util::positionToIndex(12.2, PositionMatch::GreaterOrEqual, dfDim);
161     CPPUNIT_ASSERT(!pos);
162     CPPUNIT_ASSERT_THROW(util::positionToIndex({1.0, 2.0}, {0.0}, RangeMatch::Exclusive, dfDim), std::runtime_error);
163     vector&lt;optional&lt;pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = util::positionToIndex({0.0, 12.0, 5.0}, {9.0, 15.0, 0.0}, RangeMatch::Exclusive, dfDim);
164     CPPUNIT_ASSERT(ranges.size() == 3);
165     CPPUNIT_ASSERT(ranges[0]);
166     CPPUNIT_ASSERT(!ranges[1]);
167     CPPUNIT_ASSERT(!ranges[2]);
168 }
169 void BaseTestDataAccess::testOffsetAndCount() {
170     NDSize offsets, counts;
171 <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match943-1.html#3',3,'match943-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    util::getOffsetAndCount(position_tag, data_array, offsets, counts);
172     CPPUNIT_ASSERT(offsets.size() == 4);
173     CPPUNIT_ASSERT(counts.size() == 4);
174     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
175     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);
176     util::getOffsetAndCount(position_tag, data_array, offsets, counts, RangeMatch::Exclusive);
177     CPPUNIT_ASSERT(offsets.size() == 4);
178     CPPUNIT_ASSERT(counts.size() == 4);
179     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
180     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);
181     position_tag.units(std::vector&lt;std::string&gt;());
182     util::getOffsetAndCount(position_tag, data_array, offsets, counts);
183     CPPUNIT_ASSERT(position_tag.units().size() == 0);
184     CPPUNIT_ASSERT(offsets.size() == 4);
185     CPPUNIT_ASSERT(counts.size() == 4);
186     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
187     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 1 &amp;&amp; counts[2] == 1 &amp;&amp; counts[3] == 1);
188     util::getOffsetAndCount(segment_tag, data_array, offsets, counts);
189     CPPUNIT_ASSERT(offsets.size() == 4);
190     CPPUNIT_ASSERT(counts.size() == 4);
191     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
192     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2);
193     util::getOffsetAndCount(segment_tag, data_array, offsets, counts, RangeMatch::Exclusive);
194     CPPUNIT_ASSERT(offsets.size() == 4);
195     CPPUNIT_ASSERT(counts.size() == 4);
196     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 2 &amp;&amp; offsets[2] == 2);
197     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2);
198     CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, -1, offsets, counts), nix::OutOfBounds);     CPPUNIT_ASSERT_THROW(util::getOffsetAndCount(multi_tag, data_array, 3, offsets, counts), nix::OutOfBounds); 
199     util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
200     CPPUNIT_ASSERT(offsets.size() == 4);
201     CPPUNIT_ASSERT(counts.size() == 4);
202     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
203     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 7 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 3);
204     util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts, RangeMatch::Exclusive);
205     CPPUNIT_ASSERT(offsets.size() == 4);
206     CPPUNIT_ASSERT(counts.size() == 4);
207     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 3 &amp;&amp; offsets[2] == 2 &amp;&amp; offsets[3] == 1);
208     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 6 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 2);
209     util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
210     CPPUNIT_ASSERT(offsets.size() == 4);
211     CPPUNIT_ASSERT(counts.size() == 4);
212     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
213     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 4 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 7);
214     util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts, RangeMatch::Exclusive);</B></FONT>
215     CPPUNIT_ASSERT(offsets.size() == 4);
216     CPPUNIT_ASSERT(counts.size() == 4);
217     CPPUNIT_ASSERT(offsets[0] == 0 &amp;&amp; offsets[1] == 8 &amp;&amp; offsets[2] == 1 &amp;&amp; offsets[3] == 1);
218     CPPUNIT_ASSERT(counts[0] == 1 &amp;&amp; counts[1] == 3 &amp;&amp; counts[2] == 2 &amp;&amp; counts[3] == 6);
219 }
220 void BaseTestDataAccess::testPositionInData() {
221     NDSize offsets, counts;
222     util::getOffsetAndCount(multi_tag, data_array, 0, offsets, counts);
223     CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
224     CPPUNIT_ASSERT(util::positionAndExtentInData(data_array, offsets, counts));
225     util::getOffsetAndCount(multi_tag, data_array, 1, offsets, counts);
226     CPPUNIT_ASSERT(util::positionInData(data_array, offsets));
227     CPPUNIT_ASSERT(!util::positionAndExtentInData(data_array, offsets, counts));
228 }
229 void BaseTestDataAccess::testRetrieveData() {
230     std::vector&lt;ndsize_t&gt; position_indices(1, 0);
231     CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 1), nix::OutOfBounds);
232     position_indices[0] = 10;
233     CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);
234     position_indices[0] = 0;
235     std::vector&lt;DataView&gt; views;
236     views = util::taggedData(multi_tag, position_indices, 0, RangeMatch::Inclusive);
237     CPPUNIT_ASSERT(views.size() == 1);
238     nix::DataView v = util::taggedData(multi_tag, 0, 0, RangeMatch::Inclusive);
239     CPPUNIT_ASSERT_EQUAL(v.dataExtent(), views[0].dataExtent());
240     std::vector&lt;ndsize_t&gt; temp;
241     std::vector&lt;DataView&gt; slices = util::taggedData(mtag2, temp, 0, RangeMatch::Inclusive);
242     CPPUNIT_ASSERT(slices.size() == mtag2.positions().dataExtent()[0]);
243     CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, 0));
244     CPPUNIT_ASSERT_NO_THROW(util::retrieveData(mtag2, 0, mtag2.references()[0]));
245     slices = util::taggedData(pointmtag, temp, 0, RangeMatch::Inclusive);
246     CPPUNIT_ASSERT(slices.size() == pointmtag.positions().dataExtent()[0]);
247     DataView data_view = views[0];
248     NDSize data_size = data_view.dataExtent();
249     CPPUNIT_ASSERT(data_size.size() == 4);
250     CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 3);
251     position_indices[0] = 1;
252     CPPUNIT_ASSERT_THROW(util::taggedData(multi_tag, position_indices, 0), nix::OutOfBounds);
253     data_view = util::taggedData(position_tag, 0, RangeMatch::Inclusive);
254     data_size = data_view.dataExtent();
255     CPPUNIT_ASSERT(data_size.size() == 4);
256     CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 1 &amp;&amp; data_size[2] == 1 &amp;&amp; data_size[3] == 1);
257     data_view = util::taggedData(segment_tag, 0, RangeMatch::Inclusive);
258     data_size = data_view.dataExtent();
259     CPPUNIT_ASSERT(data_size.size() == 4);
260     CPPUNIT_ASSERT(data_size[0] == 1 &amp;&amp; data_size[1] == 7 &amp;&amp; data_size[2] == 2 &amp;&amp; data_size[3] == 2);
261     DataView times_view = util::taggedData(times_tag, 0, RangeMatch::Inclusive);
262     data_size = times_view.dataExtent();
263     std::vector&lt;double&gt; times(data_size.size());
264     times_view.getData(times);
265     RangeDimension dim = times_tag.references()[0].dimensions()[0].asRangeDimension();
266     CPPUNIT_ASSERT(data_size.size() == 1);
267     CPPUNIT_ASSERT(data_size[0] == 77);
268 }
269 void BaseTestDataAccess::testTagFeatureData() {
270     DataArray number_feat = block.createDataArray(&quot;number feature&quot;, &quot;test&quot;, nix::DataType::Double, {1});
271     std::vector&lt;double&gt; number = {10.0};
272     number_feat.setData(number);
273     DataArray ramp_feat = block.createDataArray(&quot;ramp feature&quot;, &quot;test&quot;, nix::DataType::Double, {10});
274     ramp_feat.label(&quot;voltage&quot;);
275     ramp_feat.unit(&quot;mV&quot;);
276     SampledDimension dim = ramp_feat.appendSampledDimension(1.0);
277     dim.unit(&quot;ms&quot;);
278     std::vector&lt;double&gt; ramp_data = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
279     ramp_feat.setData(ramp_data);
280     Tag pos_tag = block.createTag(&quot;feature test&quot;, &quot;test&quot;, {5.0});
281 <A NAME="4"></A>    pos_tag.units({&quot;ms&quot;});
282     Feature f1 = pos_tag.createFeature(number_feat, nix::LinkType::Untagged);
283 <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match943-1.html#4',3,'match943-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    Feature f2 = pos_tag.createFeature(ramp_feat, nix::LinkType::Tagged);
284     Feature f3 = pos_tag.createFeature(ramp_feat, nix::LinkType::Untagged);
285     DataView data1 = util::featureData(pos_tag, 0);
286     DataView data2 = util::featureData(pos_tag, 1);
287     DataView data3 = util::featureData(pos_tag, 2);
288     CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
289     CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
290     CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
291     CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());
292     data1 = util::featureData(pos_tag, f1);
293     data2 = util::featureData(pos_tag, f2);
294     data3 = util::featureData(pos_tag, f3);</B></FONT>
295     CPPUNIT_ASSERT(pos_tag.featureCount() == 3);
296     CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
297     CPPUNIT_ASSERT(data2.dataExtent().nelms() == 1);
298     CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());
299     pos_tag.extent({2.0});
300     data1 = util::featureData(pos_tag, 0);
301     data2 = util::featureData(pos_tag, 1);
302     data3 = util::featureData(pos_tag, 2);
303     CPPUNIT_ASSERT(data1.dataExtent().nelms() == 1);
304     CPPUNIT_ASSERT(data2.dataExtent().nelms() == 2);
305     CPPUNIT_ASSERT(data3.dataExtent().nelms() == ramp_data.size());
306     pos_tag.deleteFeature(f1.id());
307     pos_tag.deleteFeature(f2.id());
308     pos_tag.deleteFeature(f3.id());
309     block.deleteDataArray(number_feat.id());
310     block.deleteDataArray(ramp_feat.id());
311     block.deleteTag(pos_tag);
312 }
313 void BaseTestDataAccess::testMultiTagFeatureData() {
314     DataArray index_data = block.createDataArray(&quot;indexed feature data&quot;, &quot;test&quot;, nix::DataType::Double, {10, 10});
315     SampledDimension dim1 = index_data.appendSampledDimension(1.0);
316     dim1.unit(&quot;ms&quot;);
317     SampledDimension dim2 = index_data.appendSampledDimension(1.0);
318     dim2.unit(&quot;ms&quot;);
319     typedef boost::multi_array&lt;double, 2&gt; two_d_array;
320     typedef two_d_array::index index;
321     two_d_array data1(boost::extents[10][10]);
322     index value;
323     double total = 0.0;
324     for(index i = 0; i != 10; ++i) {
325         value = 100 * i;
326         for(index j = 0; j != 10; ++j) {
327             data1[i][j] = static_cast&lt;double&gt;(value++);
328             total += data1[i][j];
329         }
330     }
331     index_data.setData(data1);
332     DataArray tagged_data = block.createDataArray(&quot;tagged feature data&quot;, &quot;test&quot;, nix::DataType::Double, {10, 20, 10, 10});
333     dim1 = tagged_data.appendSampledDimension(1.0);
334     dim1.unit(&quot;ms&quot;);
335     dim2 = tagged_data.appendSampledDimension(1.0);
336     dim2.unit(&quot;ms&quot;);
337     SampledDimension dim3;
338     dim3 = tagged_data.appendSampledDimension(1.0);
339     dim3.unit(&quot;ms&quot;);
340     SetDimension dim4 = tagged_data.appendSetDimension();
341     typedef boost::multi_array&lt;double, 4&gt; four_d_array;
342     typedef four_d_array::index four_d_index;
343     four_d_array data2(boost::extents[10][20][10][10]);
344     for(four_d_index i = 0; i != 2; ++i) {
345         value = 100 * i;
346         for(four_d_index j = 0; j != 20; ++j) {
347             for(four_d_index k = 0; k != 10; ++k) {
348                 for (four_d_index l = 0; l != 10; ++l) {
349                     data2[i][j][k][l] = static_cast&lt;double&gt;(value++);
350                 }
351             }
352         }
353     }
354     tagged_data.setData(data2);
355     Feature index_feature = multi_tag.createFeature(index_data, nix::LinkType::Indexed);
356     Feature tagged_feature = multi_tag.createFeature(tagged_data, nix::LinkType::Tagged);
357     Feature untagged_feature = multi_tag.createFeature(index_data, nix::LinkType::Untagged);
358     std::vector&lt;ndsize_t&gt; indices(1, 0);
359     CPPUNIT_ASSERT(multi_tag.featureCount() == 3);
360     DataView data_view = util::retrieveFeatureData(multi_tag, 1, 0);
361     CPPUNIT_ASSERT(data_view.dataExtent().size()  == 2);
362     CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 10);
363     CPPUNIT_ASSERT_THROW(util::retrieveFeatureData(multi_tag, 10, 0), nix::OutOfBounds);
364     CPPUNIT_ASSERT_NO_THROW(util::retrieveFeatureData(multi_tag, 1, index_feature));
365     data_view = util::featureData(multi_tag, indices, 0)[0];
366     NDSize data_size = data_view.dataExtent();
367     CPPUNIT_ASSERT(data_size.size() == 2);
368     CPPUNIT_ASSERT(data_size.nelms() == 10);
369     double sum = 0.;
370     double temp;
371     NDSize offset(data_view.dataExtent().size(), 0);
372     for (size_t i = 0; i &lt; data_size[1]; ++i){
373         offset[1] = i;
374         data_view.getData&lt;double&gt;(temp, offset);
375         sum += temp;
376     }
377     CPPUNIT_ASSERT(sum == 45);
378     indices[0] = 1;
379     data_view = util::featureData(multi_tag, indices, 0)[0];
380     sum = 0;
381     for (size_t i = 0; i &lt; data_view.dataExtent()[1]; ++i){
382         offset[1] = i;
383         data_view.getData&lt;double&gt;(temp, offset);
384         sum += temp;
385     }
386     CPPUNIT_ASSERT(sum == 1045);
387     indices[0] = 0;
388     data_view = util::featureData(multi_tag, indices, 2)[0];
389     CPPUNIT_ASSERT(data_view.dataExtent().nelms() == 100);
390     indices[0] = 1;
391     data_view = util::featureData(multi_tag, indices, 2)[0];
392     data_size = data_view.dataExtent();
393     CPPUNIT_ASSERT(data_size.nelms() == 100);
394     sum = 0;
395     for (size_t i = 0; i &lt; data_size[0]; ++i) {
396         offset[0] = i;
397         for (size_t j = 0; j &lt; data_size[1]; ++j) {
398             offset[1] = j;
399             data_view.getData&lt;double&gt;(temp, offset);
400             sum += temp;
401         }
402     }
403     CPPUNIT_ASSERT(sum == total);
404     indices[0] = 0;
405     data_view = util::featureData(multi_tag, indices, 1)[0];
406     data_size = data_view.dataExtent();
407     CPPUNIT_ASSERT(data_size.size() == 4);
408     data_view = util::featureData(multi_tag, indices, tagged_feature)[0];
409     data_size = data_view.dataExtent();
410     CPPUNIT_ASSERT(data_size.size() == 4);
411     indices[0] = 1;
412     data_view = util::featureData(multi_tag, indices, 1)[0];
413     data_size = data_view.dataExtent();
414     CPPUNIT_ASSERT(data_size.size() == 4);
415     indices[0] = 2;
416     CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 1), nix::OutOfBounds);
417     CPPUNIT_ASSERT_THROW(util::featureData(multi_tag, indices, 3), nix::OutOfBounds);
418     std::vector&lt;nix::DataView&gt; views = util::featureData(multi_tag, {0, 1}, 0);
419     CPPUNIT_ASSERT(views.size() == 2);
420     CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));
421     CPPUNIT_ASSERT(views[0].dataExtent() == NDSize({1, 10}));
422     indices.clear();
423     views = util::featureData(multi_tag, indices, 0);
424     CPPUNIT_ASSERT(views.size() == multi_tag.positionCount());
425     multi_tag.deleteFeature(index_feature.id());
426     multi_tag.deleteFeature(tagged_feature.id());
427     multi_tag.deleteFeature(untagged_feature.id());
428     block.deleteDataArray(tagged_data.id());
429     block.deleteDataArray(index_data.id());
430 }
431 void BaseTestDataAccess::testMultiTagUnitSupport() {
432     std::vector&lt;std::string&gt; valid_units{&quot;none&quot;,&quot;ms&quot;,&quot;ms&quot;};
433     std::vector&lt;std::string&gt; invalid_units{&quot;mV&quot;, &quot;Ohm&quot;, &quot;muV&quot;};
434     std::vector&lt;ndsize_t&gt; position_indices(1);
435     MultiTag testTag = block.createMultiTag(&quot;test&quot;, &quot;testTag&quot;, multi_tag.positions());
436     testTag.units(valid_units);
437     testTag.addReference(data_array);
438     position_indices[0] = 0;
439     CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
440     testTag.units(nix::none);
441     CPPUNIT_ASSERT_NO_THROW(util::retrieveData(testTag, position_indices, 0));
442     testTag.units(invalid_units);
443     CPPUNIT_ASSERT_THROW(util::taggedData(testTag, position_indices, 0), nix::IncompatibleDimensions);
444 }
445 void BaseTestDataAccess::testDataView() {
446     NDSize zcount = {2, 5, 2, 5};
447     NDSize zoffset = {0, 5, 2, 2};
448     DataView io = DataView(data_array, zcount, zoffset);
449     CPPUNIT_ASSERT_EQUAL(zcount, io.dataExtent());
450     CPPUNIT_ASSERT_EQUAL(data_array.dataType(), io.dataType());
451     typedef boost::multi_array&lt;double, 4&gt; array_type;
452     array_type data(boost::extents[2][5][2][5]);
453     io.getData(data);
454     const array_type::size_type *ext = data.shape();
455     for (size_t i = 0; i &lt; 4; i++) {
456         CPPUNIT_ASSERT_EQUAL(static_cast&lt;array_type::size_type &gt;(zcount[i]), ext[i]);
457     }
458     array_type ref;
459     data_array.getData(ref);
460     for(size_t i = 0; i &lt; zcount[0]; ++i) {
461         for(size_t j = 0; j &lt; zcount[1]; ++j) {
462             for(size_t k = 0; k &lt; zcount[2]; ++k) {
463                 for (size_t l = 0; l &lt; zcount[3]; ++l) {
464                     CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
465                                                  data[i][j][k][l],
466                                                  std::numeric_limits&lt;double&gt;::epsilon());
467                     data[i][j][k][l] = 0.0;
468                 }
469             }
470         }
471     }
472     io.setData(data, {0, 0, 0, 0});
473     data_array.getData(ref);
474     for(size_t i = 0; i &lt; zcount[0]; ++i) {
475         for(size_t j = 0; j &lt; zcount[1]; ++j) {
476             for(size_t k = 0; k &lt; zcount[2]; ++k) {
477                 for (size_t l = 0; l &lt; zcount[3]; ++l) {
478                     CPPUNIT_ASSERT_DOUBLES_EQUAL(ref[i + 0][j + 5][k + 2][l + 2],
479                                                  0.0,
480                                                  std::numeric_limits&lt;double&gt;::epsilon());
481                 }
482             }
483 <A NAME="2"></A>        }
484     }
485 <FONT color="#980517"><A HREF="javascript:ZweiFrames('match943-1.html#2',3,'match943-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    double val = 0.0;
486     CPPUNIT_ASSERT_THROW(io.getData(val, {}, {0, 0, 3, 2}), OutOfBounds);
487     array_type r2d2(boost::extents[3][3][3][3]);
488     CPPUNIT_ASSERT_THROW(io.getData(r2d2, {3, 3, 3, 3}, {}), OutOfBounds);
489     CPPUNIT_ASSERT_THROW(io.dataExtent(zcount), std::runtime_error);
490     CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0, 0, 0}, {1, 1, 1}), IncompatibleDimensions);
491     CPPUNIT_ASSERT_THROW(DataView(data_array, {0, 0, 0}, {1, 1}), IncompatibleDimensions);</B></FONT>
492 }
493 void BaseTestDataAccess::testDataSlice() {
494     nix::Block b = file.createBlock(&quot;slicing data&quot;, &quot;nix.test&quot;);
495     std::vector&lt;double&gt; time(1000);
496     std::vector&lt;double&gt; voltage;
497     double interval = 0.01;
498     double pi = 3.1415;
499     double freq = 1.5;
500     std::iota(time.begin(), time.end(), 0.);
501     std::transform(time.begin(), time.end(), time.begin(),
502                    [interval](double t){ return t * interval; });
503     std::transform(time.begin(), time.end(), std::back_inserter(voltage),
504                    [pi, freq](double t) { return std::sin(t * freq * 2 * pi); });
505     nix::DataArray oned_array = b.createDataArray(&quot;sinewave&quot;, &quot;nix.sampled&quot;, nix::DataType::Double, {voltage.size()});
506     oned_array.setData(voltage);
507     oned_array.label(&quot;voltage&quot;);
508     oned_array.unit(&quot;mV&quot;);
509     nix::SampledDimension dim = oned_array.appendSampledDimension(interval);
510     dim.label(&quot;time&quot;);
511     dim.unit(&quot;s&quot;);
512     typedef boost::multi_array&lt;double, 2&gt; array_type_2d;
513     typedef array_type_2d::index index;
514     array_type_2d data(boost::extents[10][time.size()]);
515     for(index i = 0; i &lt; 10; ++i) {
516         for (size_t j = 0; j &lt; time.size(); ++j) {
517             data[i][j] = std::sin(time[j] * freq * 2 * pi + (i*2*pi/10));
518         }
519     }
520     nix::NDSize data_shape(2, 10);      data_shape[1] = time.size();
521     nix::DataArray twod_array = b.createDataArray(&quot;2d sinewaves&quot;, &quot;nix.test&quot;, nix::DataType::Double, data_shape);
522     twod_array.setData(data);
523     twod_array.label(&quot;voltage&quot;);
524     twod_array.unit(&quot;mV&quot;);
525     twod_array.appendSetDimension();
526     dim = twod_array.appendSampledDimension(interval);
527     dim.label(&quot;time&quot;);
528     dim.unit(&quot;s&quot;);
529     std::vector&lt;double&gt; ticks(10);
530     for(size_t i = 0; i &lt; 10; ++i) {
531         ticks[i] = i * pi;
532     }
533     nix::DataArray twod_array2 = b.createDataArray(&quot;2d sinewaves 2&quot;, &quot;nix.test&quot;, nix::DataType::Double, data_shape);
534     twod_array2.setData(data);
535     twod_array2.label(&quot;voltage&quot;);
536     twod_array2.unit(&quot;mV&quot;);
537     RangeDimension rangeDim = twod_array2.appendRangeDimension(ticks);
538     rangeDim.label(&quot;time&quot;);
539     rangeDim.unit(&quot;s&quot;);
540     dim = twod_array2.appendSampledDimension(interval);
541     dim.label(&quot;time&quot;);
542     dim.unit(&quot;s&quot;);
543     nix::DataArray no_array;
544     CPPUNIT_ASSERT_THROW(util::dataSlice(no_array, {1, 2}, {2,3}), nix::UninitializedEntity);
545     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2}, {2, 3}), std::invalid_argument);     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1}, {2}, {&quot;ms&quot;, &quot;mV&quot;}), std::invalid_argument);     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1, 2, 3}, {1, 2}), std::invalid_argument);     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;mV&quot;}), nix::IncompatibleDimensions);     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;ks&quot;}), nix::OutOfBounds);     CPPUNIT_ASSERT_THROW(util::dataSlice(oned_array, {1.0}, {0.0}), std::invalid_argument); 
546     CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}));
547     CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;s&quot;}));
548     CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {1.0}, {&quot;ms&quot;}));
549     CPPUNIT_ASSERT_NO_THROW(util::dataSlice(oned_array, {0.0}, {0.001}, {&quot;ks&quot;}));
550     nix::DataView slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Inclusive);
551     CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
552     CPPUNIT_ASSERT(slice.dataExtent()[0] == 101);
553     slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Inclusive);
554     CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 101);
555     slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {&quot;none&quot;, &quot;s&quot;}, RangeMatch::Inclusive);
556     CPPUNIT_ASSERT(slice.dataExtent()[0] == 10 &amp;&amp; slice.dataExtent()[1] == 101);
557     slice = util::dataSlice(oned_array, {0.0}, {1.0}, {}, RangeMatch::Exclusive);
558     CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
559     CPPUNIT_ASSERT(slice.dataExtent()[0] == 100);
560     slice = util::dataSlice(oned_array, {1.0}, {1.0}, {}, RangeMatch::Exclusive);
561     CPPUNIT_ASSERT(slice.dataExtent().size() == 1);
562     CPPUNIT_ASSERT(slice.dataExtent()[0] == 1);
563 <A NAME="6"></A>    slice = util::dataSlice(twod_array2, {3.14, 1.0}, {9.6, 2.0}, {}, RangeMatch::Exclusive);
564     CPPUNIT_ASSERT(slice.dataExtent()[0] == 3 &amp;&amp; slice.dataExtent()[1] == 100);
565 <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match943-1.html#6',3,'match943-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    slice = util::dataSlice(twod_array, {0., 0.0}, {9.0, 1.0}, {&quot;none&quot;, &quot;s&quot;}, RangeMatch::Exclusive);
566     CPPUNIT_ASSERT(slice.dataExtent()[0] == 9 &amp;&amp; slice.dataExtent()[1] == 100);
567     b.deleteDataArray(oned_array);
568     b.deleteDataArray(twod_array);
569     file.deleteBlock(b);
570 }
571 void BaseTestDataAccess::testFlexibleTagging() {
572     nix::Block b = file.createBlock(&quot;flexible tagging&quot;, &quot;nix.test&quot;);
573     std::vector&lt;double&gt; data(1000, 0.0);</B></FONT>
574     for (size_t i = 0; i &lt;data.size(); ++i) {
575         data[i] = 3.14 * 1;
576     }
577     typedef boost::multi_array&lt;int, 2&gt; array_type_2d;
578     typedef array_type_2d::index index;
579     nix::NDSize data_shape_2d(2, 0);
580     data_shape_2d[0] = 100;
581     data_shape_2d[1] = 10;
582     array_type_2d data2d(boost::extents[data_shape_2d[0]][data_shape_2d[1]]);
583     for(index i = 0; i &lt; 100; ++i) {
584         for(index j = 0; j &lt; 10; ++j) {
585             data2d[i][j] = std::rand() % 100 + 1;
586         }
587     }
588     typedef boost::multi_array&lt;int, 3&gt; array_type_3d;
589     typedef array_type_3d::index index3;
590     nix::NDSize data_shape_3d(3, 0);
591     data_shape_3d[0] = 100;
592     data_shape_3d[1] = 10;
593     data_shape_3d[2] = 5;
594     array_type_3d data3d(boost::extents[100][10][5]);
595     for(index3 i = 0; i &lt; 100; ++i) {
596         for(index3 j = 0; j &lt; 10; ++j) {
597             for(index3 k = 0; k &lt; 5; ++k) {
598                 data3d[i][j][k] = std::rand() % 100 + 1;
599             }
600         }
601     }
602     nix::DataArray array = b.createDataArray(&quot;1d random data&quot;, &quot;nix.sampled&quot;, data);
603     nix::SampledDimension dim = array.appendSampledDimension(0.1);
604     dim.label(&quot;time&quot;);
605     dim.unit(&quot;s&quot;);
606     nix::DataArray array2d = b.createDataArray(&quot;2d random data&quot;, &quot;nix.sampled.2d&quot;, data2d);
607     dim = array2d.appendSampledDimension(1.);
608     dim.label(&quot;time&quot;);
609     dim.unit(&quot;s&quot;);
610     array2d.appendSetDimension();
611     nix::DataArray array3d = b.createDataArray(&quot;3d random data&quot;, &quot;nix.sampled.3d&quot;, data3d);
612     dim = array3d.appendSampledDimension(1.);
613     dim.label(&quot;time&quot;);
614     dim.unit(&quot;s&quot;);
615     array3d.appendSetDimension();
616     array3d.appendSetDimension();
617     nix::Tag tag = b.createTag(&quot;1stTag&quot;, &quot;nix.segment&quot;, {25, 0});
618     tag.extent({50, 5});
619     tag.units({&quot;s&quot;});
620     tag.addReference(array);
621     tag.addReference(array2d);
622     tag.addReference(array3d);
623     nix::DataView view = tag.taggedData(&quot;1d random data&quot;);
624     nix::NDSize exp_shape({500});
625     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
626     view = tag.taggedData(&quot;2d random data&quot;);
627     exp_shape = {50, 5};
628     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
629     view = tag.taggedData(&quot;3d random data&quot;);
630     exp_shape = {50, 5, 4};
631     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
632     nix::Tag ndTag = b.createTag(&quot;2ndTag&quot;, &quot;nix.points&quot;, {25, 0, 0});
633     ndTag.addReference(array);
634     ndTag.addReference(array2d);
635     ndTag.addReference(array3d);
636     view = ndTag.taggedData(&quot;1d random data&quot;);
637     exp_shape = {1};
638     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
639     view = ndTag.taggedData(&quot;2d random data&quot;);
640     exp_shape = {1, 1};
641     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
642     view = ndTag.taggedData(&quot;3d random data&quot;);
643     exp_shape = {1, 1, 1};
644     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
645     nix::Tag rdTag = b.createTag(&quot;3rdTag11&quot;, &quot;nix.points&quot;, {25, 0, 0});
646     rdTag.extent({0.0, 0.0, 0.0});
647     rdTag.addReference(array);
648     rdTag.addReference(array2d);
649     rdTag.addReference(array3d);
650     view = rdTag.taggedData(&quot;1d random data&quot;);
651     exp_shape = {1};
652     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
653     view = rdTag.taggedData(&quot;2d random data&quot;);
654     exp_shape = {1, 1};
655     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
656     view = rdTag.taggedData(&quot;3d random data&quot;);
657     exp_shape = {1, 1, 1};
658     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
659     nix::Tag failTag = b.createTag(&quot;failing tag&quot;, &quot;nix.points&quot;, {25, 0, 0});
660     failTag.extent({0.0, 0.0});     failTag.addReference(array);
661     failTag.addReference(array2d);
662     failTag.addReference(array3d);
663     CPPUNIT_ASSERT_THROW(failTag.taggedData(&quot;3d random data&quot;), nix::IncompatibleDimensions);
664     typedef boost::multi_array&lt;double, 2&gt; pos_type;
665     typedef pos_type::index index4;
666     pos_type pos_data(boost::extents[5][2]);
667     pos_type ext_data(boost::extents[5][2]);
668     for(index4 i = 0; i &lt; 5; ++i) {
669         pos_data[i][0] = i * 15.0 + 5.00;
670         ext_data[i][0] = 10.0;
671         pos_data[i][1] = 1.0;
672         ext_data[i][1] = 2.0;
673     }
674     nix::DataArray positions = b.createDataArray(&quot;mtag positions&quot;, &quot;nix.positions.2d&quot;, pos_data);
675     positions.appendSetDimension();
676     positions.appendSetDimension();
677     nix::DataArray extents = b.createDataArray(&quot;mtag_extents&quot;, &quot;nix.extents.2d&quot;, ext_data);
678     extents.appendSetDimension();
679     extents.appendSetDimension();
680     nix::MultiTag mtag = b.createMultiTag(&quot;mtag&quot;, &quot;segments&quot;, positions);
681     mtag.extents(extents);
682     mtag.addReference(array);
683     mtag.addReference(array2d);
684     mtag.addReference(array3d);
685     view = mtag.taggedData(0, &quot;1d random data&quot;);
686     exp_shape = {100};
687     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
688     view = mtag.taggedData(0, &quot;2d random data&quot;);
689     exp_shape = {10, 2};
690     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
691     view = mtag.taggedData(0, &quot;3d random data&quot;);
692     exp_shape = {10, 2, 4};
693     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
694 <A NAME="1"></A>
695 <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match943-1.html#1',3,'match943-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
696                                      {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
697     nix::DataFrame df = b.createDataFrame(&quot;conditions&quot;, &quot;test&quot;, cols);
698     std::vector&lt;nix::Variant&gt; vals(2);
699     df.rows(10);
700     for (int i = 0; i &lt; 10; ++i) {
701         vals[0].set(i * 2.5);
702         vals[1].set(&quot;test&quot;);
703         df.writeRow(i, vals);
704     }
705     array3d.deleteDimensions();
706     dim = array3d.appendSampledDimension(1.);
707     dim.label(&quot;time&quot;);
708     dim.unit(&quot;s&quot;);
709     array3d.appendDataFrameDimension(df);
710     array3d.appendSetDimension();
711     nix::Tag dfTag = b.createTag(&quot;dftest&quot;, &quot;dftest&quot;, {25, 0});</B></FONT>
712     dfTag.extent({50, 5});
713     dfTag.addReference(array3d);
714     view = dfTag.taggedData(&quot;3d random data&quot;);
715     exp_shape = {50, 5, 4};
716     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
717     dfTag.position({25});
718     dfTag.extent({50});
719     view = dfTag.taggedData(&quot;3d random data&quot;);
720     exp_shape = {50, 9, 4};
721     CPPUNIT_ASSERT(view.dataExtent() == exp_shape);
722     file.deleteBlock(b);
723 }
724 #ifdef _MSC_VER
725 #pragma warning(pop)
726 #endif
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BaseTestDimension.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #include &lt;limits&gt;
2 #include &lt;sstream&gt;
3 #include &lt;iostream&gt;
4 #include &lt;iterator&gt;
5 #include &lt;stdexcept&gt;
6 #include &lt;nix/util/util.hpp&gt;
7 #include &lt;nix/valid/validate.hpp&gt;
8 #include &quot;BaseTestDimension.hpp&quot;
9 #include &lt;cppunit/extensions/HelperMacros.h&gt;
10 #include &lt;cppunit/CompilerOutputter.h&gt;
11 #include &lt;cppunit/TestResult.h&gt;
12 #include &lt;cppunit/TestResultCollector.h&gt;
13 #include &lt;cppunit/TestRunner.h&gt;
14 #include &lt;cppunit/BriefTestProgressListener.h&gt;
15 #include &lt;boost/math/constants/constants.hpp&gt;
16 using namespace nix;
17 using namespace valid;
18 void BaseTestDimension::testValidate() {
19     Dimension d = data_array.appendSetDimension();
20     valid::Result result = validate(d);
21     CPPUNIT_ASSERT(result.getErrors().size() == 0);
22     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
23 }
24 void BaseTestDimension::testSetValidate() {
25     SetDimension d = data_array.appendSetDimension();
26     valid::Result result = validate(d);
27     CPPUNIT_ASSERT(result.getErrors().size() == 0);
28     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
29 }
30 void BaseTestDimension::testRangeValidate() {
31     std::vector&lt;double&gt; ticks;
32     for (size_t i = 0; i &lt; 5; i++) {
33         ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
34     }
35     RangeDimension d = data_array.appendRangeDimension(ticks);
36     valid::Result result = validate(d);
37     CPPUNIT_ASSERT(result.getErrors().size() == 0);
38     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
39 }
40 void BaseTestDimension::testSampleValidate() {
41     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
42     SampledDimension d = data_array.appendSampledDimension(samplingInterval);
43     valid::Result result = validate(d);
44     CPPUNIT_ASSERT(result.getErrors().size() == 0);
45     CPPUNIT_ASSERT(result.getWarnings().size() == 0);
46 }
47 void BaseTestDimension::testIndex() {
48     Dimension sd = data_array.appendSetDimension();
49     CPPUNIT_ASSERT(data_array.dimensionCount() == 1 &amp;&amp; sd.index() == 1);
50     data_array.deleteDimensions();
51     CPPUNIT_ASSERT(data_array.dimensionCount() == 0);
52 }
53 void BaseTestDimension::testSampledDimLabel() {
54     std::string label = &quot;aLabel&quot;;
55     std::string other_label = &quot;anotherLabel&quot;;
56     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
57     Dimension d = data_array.appendSampledDimension(samplingInterval);
58     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
59     SampledDimension sd;
60     sd = d;
61     sd.label(label);
62     CPPUNIT_ASSERT(*(sd.label()) == label);
63     sd.label(other_label);
64     CPPUNIT_ASSERT(*(sd.label()) == other_label);
65     CPPUNIT_ASSERT_NO_THROW(sd.label(none));
66     CPPUNIT_ASSERT(sd.label() == none);
67     data_array.deleteDimensions();
68 }
69 void BaseTestDimension::testSampledDimUnit() {
70     std::string invalidUnit = &quot;invalidunit&quot;;
71     std::string validUnit = &quot;mV^2&quot;;
72     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
73     Dimension d = data_array.appendSampledDimension(samplingInterval);
74     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
75     SampledDimension sd;
76     sd = d;
77     CPPUNIT_ASSERT_THROW(sd.unit(invalidUnit), InvalidUnit);
78     CPPUNIT_ASSERT_NO_THROW(sd.unit(validUnit));
79     CPPUNIT_ASSERT(*(sd.unit()) == validUnit);
80     CPPUNIT_ASSERT_NO_THROW(sd.unit(boost::none));
81     CPPUNIT_ASSERT(sd.unit() == boost::none);
82     data_array.deleteDimensions();
83 }
84 void BaseTestDimension::testSampledDimSamplingInterval() {
85     double impossible_sampling_interval = -1.0;
86     double invalid_sampling_interval = 0.0;
87     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
88     Dimension d = data_array.appendSampledDimension(samplingInterval);
89     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
90     SampledDimension sd;
91     sd = d;
92     CPPUNIT_ASSERT(sd.samplingInterval() == boost::math::constants::pi&lt;double&gt;());
93     CPPUNIT_ASSERT_THROW(sd.samplingInterval(impossible_sampling_interval), std::runtime_error);
94     CPPUNIT_ASSERT_THROW(sd.samplingInterval(invalid_sampling_interval), std::runtime_error);
95     CPPUNIT_ASSERT_NO_THROW(sd.samplingInterval(samplingInterval));
96     CPPUNIT_ASSERT(sd.samplingInterval() == samplingInterval);
97     data_array.deleteDimensions();
98 }
99 void BaseTestDimension::testSampledDimOffset() {
100     double offset = 1.0;
101     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
102     Dimension d = data_array.appendSampledDimension(samplingInterval);
103     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
104     SampledDimension sd;
105     sd = d;
106     CPPUNIT_ASSERT_NO_THROW(sd.offset(offset));
107     CPPUNIT_ASSERT(*(sd.offset()) == offset);
108     CPPUNIT_ASSERT_NO_THROW(sd.offset(boost::none));
109     CPPUNIT_ASSERT(sd.offset() == boost::none);
110     data_array.deleteDimensions();
111 }
112 void BaseTestDimension::testSampledDimIndexOfOld() {
113     double offset = 1.0;
114     double samplingInterval = 1.0;
115     Dimension d = data_array.appendSampledDimension(samplingInterval);
116     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
117     SampledDimension sd;
118     sd = d;
119     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
120     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0));
121     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
122     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(10000000));
123     CPPUNIT_ASSERT(sd.indexOf(-0.5) == 0);
124     CPPUNIT_ASSERT(sd.indexOf(1.0) == 1);
125     CPPUNIT_ASSERT(sd.indexOf(2.4) == 3);      CPPUNIT_ASSERT(sd.indexOf(4.28) == 5);
126     CPPUNIT_ASSERT(sd.indexOf(6.99) == 7);
127     CPPUNIT_ASSERT(sd.indexOf(7.0) == 7);
128     sd.offset(offset);
129     CPPUNIT_ASSERT(*(sd.offset()) == offset);
130     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
131     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.5));
132     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0));
133     CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
134     CPPUNIT_ASSERT(sd.indexOf(0.0) == 0);
135     CPPUNIT_ASSERT(sd.indexOf(2.0) == 1);
136     CPPUNIT_ASSERT(sd.indexOf(6.28) == 6);
137     CPPUNIT_ASSERT(sd.indexOf(3.75) == 3);
138     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.25, 1.01));
139     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(0.0, 1.01));
140     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(1.0, 1.01));
141     CPPUNIT_ASSERT_THROW(sd.indexOf(1.01, 0.0), nix::OutOfBounds);
142     CPPUNIT_ASSERT_THROW(sd.indexOf(-1.0, -.05), nix::OutOfBounds);      std::pair&lt;ndsize_t, ndsize_t&gt; range = sd.indexOf(-1.0, 5.0);
143     CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
144     range = sd.indexOf(1.0, 5.0);
145     CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
146     CPPUNIT_ASSERT_THROW(sd.indexOf(5.0, 1.0), nix::OutOfBounds);
147     range = sd.indexOf(1.5, 3.2);
148 <A NAME="2"></A>    CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2);     range = sd.indexOf(1.5, 3.7);
149     CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 2); <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#2',2,'match943-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    range = sd.indexOf(1.5, 4.0);
150     CPPUNIT_ASSERT(range.first == 1 &amp;&amp; range.second == 3); 
151     CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9}), std::runtime_error);        
152     CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, 20.0, 40.0}, {10.9, 12., 1.}), nix::OutOfBounds);
153     CPPUNIT_ASSERT_NO_THROW(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}));
154     CPPUNIT_ASSERT(sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.}).size() == 3);</B></FONT>
155     std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0}, {10.9, 20., 40.});
156     CPPUNIT_ASSERT(ranges.size() == 3);
157     CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 9);
158     CPPUNIT_ASSERT(sd.positionAt(ranges[0].first) == 1.0 &amp;&amp; sd.positionAt(ranges[0].second) == 10.); 
159     CPPUNIT_ASSERT(ranges[1].first == 11 &amp;&amp; ranges[1].second == 19);
160     CPPUNIT_ASSERT(sd.positionAt(ranges[1].first) == 12 &amp;&amp; sd.positionAt(ranges[1].second) == 20); 
161     CPPUNIT_ASSERT(ranges[2].first == 0 &amp;&amp; ranges[2].second == 39);
162     CPPUNIT_ASSERT(sd.positionAt(ranges[2].first) == 1. &amp;&amp; sd.positionAt(ranges[2].second) == 40); 
163     sd.offset(-1.0);
164     CPPUNIT_ASSERT(*(sd.offset()) == -1.0);
165     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-3.14));
166     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-1.5));
167     CPPUNIT_ASSERT_NO_THROW(sd.indexOf(-0.5));
168     CPPUNIT_ASSERT(sd.indexOf(-3.14) == 0);
169     CPPUNIT_ASSERT(sd.indexOf(-0.5) == 1);
170     CPPUNIT_ASSERT(sd.indexOf(-1.0) == 0);
171     CPPUNIT_ASSERT(sd.indexOf(0.5) == 2);
172     data_array.deleteDimensions();
173 }
174 void BaseTestDimension::testSampledDimIndexOf() {
175     double samplingInterval = 1.;
176     Dimension d = data_array.appendSampledDimension(samplingInterval);
177 <A NAME="0"></A>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
178     SampledDimension sd;
179 <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#0',2,'match943-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    sd = d;
180     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
181     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
182     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
183     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
184     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
185     CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
186     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual));
187     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal));
188     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
189     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));
190     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Less));
191     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
192     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
193     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
194     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));
195     sd.offset(1.0);
196     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
197     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
198     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
199     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual));
200     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater));
201     CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Less));
202     CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::LessOrEqual));
203     CPPUNIT_ASSERT(!sd.indexOf(0.0, PositionMatch::Equal));
204     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual));
205     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater));
206     CPPUNIT_ASSERT(!sd.indexOf(1.0, PositionMatch::Less));
207     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::LessOrEqual));
208     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Equal));
209     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::GreaterOrEqual));
210     CPPUNIT_ASSERT(sd.indexOf(1.0, PositionMatch::Greater));
211     sd.offset(-1.0);
212     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Less));
213     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::LessOrEqual));
214     CPPUNIT_ASSERT(!sd.indexOf(-3.14, PositionMatch::Equal));
215     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::GreaterOrEqual) == 0) ;
216     CPPUNIT_ASSERT(sd.indexOf(-3.14, PositionMatch::Greater) &amp;&amp; *sd.indexOf(-3.14, PositionMatch::Greater) == 0);
217     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Less) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Less) == 0);
218     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::LessOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::LessOrEqual) == 1);
219     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Equal) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Equal) == 1);
220     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::GreaterOrEqual) &amp;&amp; *sd.indexOf(0.0, PositionMatch::GreaterOrEqual) == 1);
221     CPPUNIT_ASSERT(sd.indexOf(0.0, PositionMatch::Greater) &amp;&amp; *sd.indexOf(0.0, PositionMatch::Greater) == 2);</B></FONT>
222     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
223     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 1 &amp;&amp; (*range).second == 1);
224     range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);    
225     CPPUNIT_ASSERT(!range);
226     range = sd.indexOf(-1.5, 2.0, RangeMatch::Inclusive);
227     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
228     range = sd.indexOf(-1.5, 2.0, RangeMatch::Exclusive);
229     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
230     range = sd.indexOf(2., -2.0, RangeMatch::Inclusive);
231     CPPUNIT_ASSERT(!range);     range = sd.indexOf(2., -2.0, RangeMatch::Exclusive);
232     CPPUNIT_ASSERT(!range);     range = sd.indexOf(2.0, 2.0, RangeMatch::Inclusive);
233     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 3);
234     range = sd.indexOf(2., 2.0, RangeMatch::Exclusive);
235     CPPUNIT_ASSERT(!range);
236     CPPUNIT_ASSERT_THROW(sd.indexOf({1.0, 20.0, 40.0}, {10.9, 12.}, RangeMatch::Exclusive), std::runtime_error);
237     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Inclusive);
238     CPPUNIT_ASSERT(ranges.size() == 4);
239     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
240                    sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
241     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 21 &amp;&amp; 
242                    sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 20);
243     CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 41 &amp;&amp; 
244                    sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 40);
245     CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 6 &amp;&amp; (*ranges[3]).second == 6 &amp;&amp; 
246                    sd.positionAt((*ranges[3]).first) == 5 &amp;&amp; sd.positionAt((*ranges[3]).second) == 5);
247     ranges = sd.indexOf({1.0, 12.0, 1.0, 5.0}, {10.9, 20.0, 40.0, 5.0}, RangeMatch::Exclusive);
248     CPPUNIT_ASSERT(ranges.size() == 4);
249     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 2 &amp;&amp; (*ranges[0]).second == 11 &amp;&amp; 
250                    sd.positionAt((*ranges[0]).first) &gt;= 1.0 &amp;&amp; sd.positionAt((*ranges[0]).second) &lt;= 10.9);
251     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 13 &amp;&amp; (*ranges[1]).second == 20 &amp;&amp; 
252                    sd.positionAt((*ranges[1]).first) == 12 &amp;&amp; sd.positionAt((*ranges[1]).second) == 19);
253     CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 2 &amp;&amp; (*ranges[2]).second == 40 &amp;&amp; 
254                    sd.positionAt((*ranges[2]).first) == 1.0 &amp;&amp; sd.positionAt((*ranges[2]).second) == 39);
255     CPPUNIT_ASSERT(!ranges[3]);
256     data_array.deleteDimensions();
257 }
258 void BaseTestDimension::testSampledDimPositionAt() {
259     double offset = 1.0;
260     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
261     Dimension d = data_array.appendSampledDimension(samplingInterval);
262     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
263     SampledDimension sd;
264     sd = d;
265     sd.offset(offset);
266     CPPUNIT_ASSERT(sd.positionAt(0) == offset);
267     CPPUNIT_ASSERT_DOUBLES_EQUAL(
268         200 * samplingInterval + offset,
269         sd.positionAt(200),
270         std::numeric_limits&lt;double&gt;::round_error());
271     CPPUNIT_ASSERT(sd[0] == offset);
272     CPPUNIT_ASSERT_DOUBLES_EQUAL(
273         200 * samplingInterval + offset,
274         sd[200],
275         std::numeric_limits&lt;double&gt;::round_error());
276     data_array.deleteDimensions();
277 }
278 void BaseTestDimension::testSampledDimAxis() {
279     double offset = 1.0;
280     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
281     Dimension d = data_array.appendSampledDimension(samplingInterval);
282     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
283     SampledDimension sd;
284     sd = d;
285     sd.offset(offset);
286     std::vector&lt;double&gt; axis = sd.axis(100);
287     CPPUNIT_ASSERT(axis.size() == 100);
288     CPPUNIT_ASSERT(axis[0] == offset);
289     CPPUNIT_ASSERT_DOUBLES_EQUAL(
290         99 * samplingInterval + offset,
291         axis.back(),
292         std::numeric_limits&lt;double&gt;::round_error());
293     axis = sd.axis(100, 10);
294     CPPUNIT_ASSERT_DOUBLES_EQUAL(
295         10 * samplingInterval + offset,
296         axis[0],
297         std::numeric_limits&lt;double&gt;::round_error());
298     CPPUNIT_ASSERT_DOUBLES_EQUAL(
299         109 * samplingInterval + offset,
300         axis.back(),
301         std::numeric_limits&lt;double&gt;::round_error());
302     data_array.deleteDimensions();
303 }
304 void BaseTestDimension::testSampledDimOperators() {
305     double samplingInterval = boost::math::constants::pi&lt;double&gt;();
306     Dimension d = data_array.appendSampledDimension(samplingInterval);
307     Dimension d2 = data_array.appendSampledDimension(samplingInterval);
308     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Sample);
309     CPPUNIT_ASSERT(d2.dimensionType() == DimensionType::Sample);
310     CPPUNIT_ASSERT_THROW(d.asRangeDimension(), nix::IncompatibleDimensions);
311     CPPUNIT_ASSERT_THROW(d.asSetDimension(), nix::IncompatibleDimensions);
312     SampledDimension sd1, sd2, sd3;
313     sd1 = d;
314     sd2 = d2;
315     sd3 = data_array.getDimension(d.index());
316     CPPUNIT_ASSERT(sd1.index() == d.index() &amp;&amp; sd2.index() == d2.index());
317     CPPUNIT_ASSERT(sd1 != sd2);
318     CPPUNIT_ASSERT(sd1 != sd3);
319     data_array.deleteDimensions();
320     Dimension dim = data_array.appendSetDimension();
321     CPPUNIT_ASSERT_THROW(dim.asSampledDimension(), IncompatibleDimensions);
322     SampledDimension sampled = data_array.appendSampledDimension(samplingInterval);
323     RangeDimension range = data_array.appendRangeDimension(std::vector&lt;double&gt;({1, 2}));
324     SetDimension set = data_array.appendSetDimension();
325     std::stringstream s_stream, r_stream, set_stream;
326     s_stream &lt;&lt; sampled.dimensionType();
327     r_stream &lt;&lt; range.dimensionType();
328     set_stream &lt;&lt; set.dimensionType();
329     CPPUNIT_ASSERT(s_stream.str() == &quot;Sample&quot;);
330     CPPUNIT_ASSERT(set_stream.str() == &quot;Set&quot;);
331     CPPUNIT_ASSERT(r_stream.str() == &quot;Range&quot;);
332     CPPUNIT_ASSERT(d != none);
333     CPPUNIT_ASSERT(sampled != none);
334     CPPUNIT_ASSERT(range != none);
335     CPPUNIT_ASSERT(set != none);
336     SampledDimension sd4;
337     CPPUNIT_ASSERT_THROW(sd4 = range, nix::IncompatibleDimensions);
338     CPPUNIT_ASSERT_NO_THROW(sd4 = sampled);
339     RangeDimension rd;
340     CPPUNIT_ASSERT_THROW(rd = sampled, nix::IncompatibleDimensions);
341     CPPUNIT_ASSERT_NO_THROW(rd = range);
342     SetDimension st;
343     CPPUNIT_ASSERT_THROW(st = sampled, nix::IncompatibleDimensions);
344     CPPUNIT_ASSERT_NO_THROW(st = set);
345     d = none; sampled = none; range = none; set = none;
346     CPPUNIT_ASSERT(d == none);
347     CPPUNIT_ASSERT(sampled == none);
348     CPPUNIT_ASSERT(range == none);
349     CPPUNIT_ASSERT(set == none);
350 }
351 void BaseTestDimension::testSetDimLabels() {
352     std::vector&lt;std::string&gt; labels = {&quot;label_a&quot;, &quot;label_b&quot;,&quot;label_c&quot;,&quot;label_d&quot;,&quot;label_e&quot;};
353     std::vector&lt;std::string&gt; new_labels = {&quot;new label_a&quot;, &quot;new label_b&quot;,&quot;new label_c&quot;};
354     Dimension d = data_array.appendSetDimension();
355     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);
356     SetDimension sd;
357     sd = d;
358     CPPUNIT_ASSERT(sd);
359     sd.labels(labels);
360     std::vector&lt;std::string&gt; retrieved_labels = sd.labels();
361     CPPUNIT_ASSERT(retrieved_labels.size() == labels.size());
362     for (size_t i = 0; i &lt; labels.size(); i++){
363         CPPUNIT_ASSERT(labels[i] == retrieved_labels[i]);
364     }
365     sd.labels(new_labels);
366     retrieved_labels = sd.labels();
367     CPPUNIT_ASSERT(retrieved_labels.size() == new_labels.size());
368     for (size_t i = 0; i &lt; new_labels.size(); i++){
369         CPPUNIT_ASSERT(new_labels[i] == retrieved_labels[i]);
370     }
371     sd.labels(boost::none);
372     retrieved_labels = sd.labels();
373     CPPUNIT_ASSERT_EQUAL(static_cast&lt;size_t&gt;(0), retrieved_labels.size());
374     data_array.deleteDimensions();
375 }
376 void BaseTestDimension::testSetDimIndexOf() {
377     std::vector&lt;std::string&gt; labels = {&quot;label_a&quot;, &quot;label_b&quot;,&quot;label_c&quot;,&quot;label_d&quot;,&quot;label_e&quot;};
378     Dimension d = data_array.appendSetDimension();
379     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Set);
380     SetDimension sd;
381     sd = d;
382     sd.labels(labels);
383     boost::optional&lt;ndsize_t&gt; index;
384     index = sd.indexOf(-1.0, PositionMatch::Less);
385     CPPUNIT_ASSERT(!index);
386     index = sd.indexOf(-1.0, PositionMatch::LessOrEqual);
387     CPPUNIT_ASSERT(!index);
388     index = sd.indexOf(-1.0, PositionMatch::Equal);
389     CPPUNIT_ASSERT(!index);
390     index = sd.indexOf(-1.0, PositionMatch::GreaterOrEqual);
391     CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
392     index = sd.indexOf(-1.0, PositionMatch::Greater);
393     CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
394     index = sd.indexOf(0.0, PositionMatch::Less);
395     CPPUNIT_ASSERT(!index);
396     index = sd.indexOf(0.0, PositionMatch::LessOrEqual);
397     CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
398     index = sd.indexOf(0.0, PositionMatch::Equal);
399     CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
400     index = sd.indexOf(0.0000001, PositionMatch::Equal);
401     CPPUNIT_ASSERT(!index);
402     index = sd.indexOf(0.0, PositionMatch::GreaterOrEqual);
403     CPPUNIT_ASSERT(index &amp;&amp; *index == 0);
404     index = sd.indexOf(0.0, PositionMatch::Greater);
405     CPPUNIT_ASSERT(index &amp;&amp; *index == 1);
406     index = sd.indexOf(4.0, PositionMatch::Less);
407     CPPUNIT_ASSERT(index &amp;&amp; *index == 3);
408     index = sd.indexOf(4.0, PositionMatch::LessOrEqual);
409     CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
410     index = sd.indexOf(4.0, PositionMatch::Equal);
411     CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
412     index = sd.indexOf(4.0, PositionMatch::GreaterOrEqual);
413     CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
414     index = sd.indexOf(4.0, PositionMatch::Greater);
415     CPPUNIT_ASSERT(!index);
416     index = sd.indexOf(5.0, PositionMatch::Less);
417     CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
418     index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
419 <A NAME="4"></A>    CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
420     index = sd.indexOf(5.0, PositionMatch::Equal);
421     CPPUNIT_ASSERT(!index);
422 <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#4',2,'match943-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
423     CPPUNIT_ASSERT(!index);
424     index = sd.indexOf(5.0, PositionMatch::Greater);
425     CPPUNIT_ASSERT(!index);
426     sd.labels(boost::none);
427     index = sd.indexOf(5.0, PositionMatch::Less);
428     CPPUNIT_ASSERT(index &amp;&amp; *index == 4);
429     index = sd.indexOf(5.0, PositionMatch::LessOrEqual);
430     CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
431     index = sd.indexOf(5.0, PositionMatch::Equal);
432     CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
433     index = sd.indexOf(5.0, PositionMatch::GreaterOrEqual);
434     CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
435     index = sd.indexOf(5.0, PositionMatch::Greater);
436     CPPUNIT_ASSERT(index &amp;&amp; *index == 6);
437     index = sd.indexOf(5.5, PositionMatch::Less);</B></FONT>
438     CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
439     index = sd.indexOf(5.5, PositionMatch::LessOrEqual);
440     CPPUNIT_ASSERT(index &amp;&amp; *index == 5);
441     index = sd.indexOf(5.5, PositionMatch::Equal);
442     CPPUNIT_ASSERT(!index);
443     index = sd.indexOf(5.5, PositionMatch::GreaterOrEqual);
444     CPPUNIT_ASSERT(index &amp;&amp; *index == 6);
445     index = sd.indexOf(5.5, PositionMatch::Greater);
446     CPPUNIT_ASSERT(index &amp;&amp; *index == 6);
447     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
448     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
449     range = sd.indexOf(0.0, 0.0, RangeMatch::Exclusive);
450     CPPUNIT_ASSERT(!range);
451     range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
452     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
453     range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
454     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
455     range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
456     CPPUNIT_ASSERT(!range);
457     range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
458     CPPUNIT_ASSERT(!range);
459     sd.labels(labels);
460     range = sd.indexOf(0.0, 0.0, RangeMatch::Inclusive);
461     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
462     range = sd.indexOf(1.0, 1.0, RangeMatch::Exclusive);
463     CPPUNIT_ASSERT(!range);
464     range = sd.indexOf(0.0, 3.0, RangeMatch::Inclusive);
465     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
466     range = sd.indexOf(0.0, 3.0, RangeMatch::Exclusive);
467     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
468     range = sd.indexOf(3.0, 0.0, RangeMatch::Inclusive);
469     CPPUNIT_ASSERT(!range);
470     range = sd.indexOf(3.0, 0.0, RangeMatch::Exclusive);
471     CPPUNIT_ASSERT(!range);
472     range = sd.indexOf(0.0, 7.0, RangeMatch::Inclusive);
473     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 4);
474     range = sd.indexOf(3.0, 7.0, RangeMatch::Exclusive);
475     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
476     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
477     CPPUNIT_ASSERT_THROW(sd.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
478     ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
479     CPPUNIT_ASSERT(ranges.size() == 4);
480     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
481     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
482 <A NAME="6"></A>    CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
483     CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);
484 <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#6',2,'match943-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    ranges = sd.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
485     CPPUNIT_ASSERT(ranges.size() == 4);
486     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
487     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
488     CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 4);
489     CPPUNIT_ASSERT(!ranges[3]);
490 }
491 void BaseTestDimension::testRangeDimLabel() {
492     std::string label = &quot;aLabel&quot;;
493     std::string other_label = &quot;anotherLabel&quot;;</B></FONT>
494     std::vector&lt;double&gt; ticks;
495     for (size_t i = 0; i &lt; 5; i++) {
496         ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
497     }
498     Dimension d = data_array.appendRangeDimension(ticks);
499     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
500     RangeDimension rd;
501     rd = d;
502     rd.label(label);
503     CPPUNIT_ASSERT(*(rd.label()) == label);
504     rd.label(other_label);
505     CPPUNIT_ASSERT(*(rd.label()) == other_label);
506     rd.label(none);
507     CPPUNIT_ASSERT(rd.label() == none);
508     data_array.deleteDimensions();
509 }
510 void BaseTestDimension::testRangeDimUnit() {
511     std::string invalidUnit = &quot;invalidunit&quot;;
512     std::string validUnit = &quot;ms&quot;;
513     std::vector&lt;double&gt; ticks;
514     for (size_t i = 0; i &lt; 5; i++) {
515         ticks.push_back(i * boost::math::constants::pi&lt;double&gt;());
516     }
517     Dimension d = data_array.appendRangeDimension(ticks);
518     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
519     RangeDimension rd;
520     rd = d;
521     CPPUNIT_ASSERT_THROW(rd.unit(invalidUnit), InvalidUnit);
522     CPPUNIT_ASSERT_NO_THROW(rd.unit(validUnit));
523     CPPUNIT_ASSERT(*(rd.unit()) == validUnit);
524     CPPUNIT_ASSERT_NO_THROW(rd.unit(none));
525     CPPUNIT_ASSERT(rd.unit() == none);
526     data_array.deleteDimensions();
527 }
528 void BaseTestDimension::testRangeTicks() {
529     std::vector&lt;double&gt; ticks = {1.0, 2.0, 3.4, 42.0};
530     std::vector&lt;double&gt; new_ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
531     std::vector&lt;double&gt; unordered_ticks = {-20.0, -100.0, 10.0, -10.0, 0.0};
532     std::vector&lt;double&gt; double_ticks = {-20.0, -10.0, 10.0, -10.0, -20.0};
533     Dimension d = data_array.appendRangeDimension(ticks);
534     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
535     RangeDimension rd;
536     rd = d;
537     CPPUNIT_ASSERT(rd.ticks().size() == ticks.size());
538     std::vector&lt;double&gt; retrieved_ticks = rd.ticks();
539     CPPUNIT_ASSERT(retrieved_ticks.size() == ticks.size());
540     for (size_t i = 0; i &lt; ticks.size(); i++) {
541         CPPUNIT_ASSERT(ticks[i] == retrieved_ticks[i]);
542     }
543     CPPUNIT_ASSERT_THROW(rd.ticks(unordered_ticks), UnsortedTicks);
544     CPPUNIT_ASSERT_THROW(rd.ticks(double_ticks), UnsortedTicks);
545     rd.ticks(new_ticks);
546     retrieved_ticks = rd.ticks();
547     CPPUNIT_ASSERT(retrieved_ticks.size() == new_ticks.size());
548     for (size_t i = 0; i &lt; new_ticks.size(); i++) {
549         CPPUNIT_ASSERT(new_ticks[i] == retrieved_ticks[i]);
550     }
551     ticks.resize(100);
552     for (size_t i = 0; i &lt; 100; ++i) {
553         ticks[i] = i * 3.14;
554     }
555     rd.ticks(ticks);
556     CPPUNIT_ASSERT(rd.ticks(0, 10).size() == 10);
557     CPPUNIT_ASSERT(rd.ticks(1, 99).size() == 99);
558     CPPUNIT_ASSERT(rd.ticks(10, 1)[0] == 10 * 3.14);
559     CPPUNIT_ASSERT(rd.ticks(20, 1)[0] == 20 * 3.14);
560     CPPUNIT_ASSERT_THROW(rd.ticks(0, ticks.size() + 10), nix::OutOfBounds);
561     CPPUNIT_ASSERT_THROW(rd.ticks(20, ticks.size() - 10), nix::OutOfBounds);
562     data_array.deleteDimensions();
563 }
564 void BaseTestDimension::testRangeDimIndexOfOld() {
565     std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
566     Dimension d = data_array.appendRangeDimension(ticks);
567     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
568     RangeDimension rd;
569     rd = d;
570     CPPUNIT_ASSERT(rd.indexOf(-100.) == 0);
571     CPPUNIT_ASSERT(rd.indexOf(-50.) == 0);
572     CPPUNIT_ASSERT(rd.indexOf(-70.) == 0);
573     CPPUNIT_ASSERT(rd.indexOf(-10.0) == 1);
574     CPPUNIT_ASSERT(rd.indexOf(-5.0) == 1);
575     CPPUNIT_ASSERT(rd.indexOf(5.0) == 2);
576     CPPUNIT_ASSERT_NO_THROW(rd.indexOf(257.28));
577     CPPUNIT_ASSERT_THROW(rd.indexOf(257.28, false), nix::OutOfBounds);
578     CPPUNIT_ASSERT_THROW(rd.indexOf(-257.28), nix::OutOfBounds);
579     CPPUNIT_ASSERT_NO_THROW(rd.indexOf(-257.28, false));
580     CPPUNIT_ASSERT_THROW(rd.indexOf(110., 120.), nix::OutOfBounds);
581     CPPUNIT_ASSERT_THROW(rd.indexOf(-120., -110.), nix::OutOfBounds);
582     std::pair&lt;ndsize_t, ndsize_t&gt; range = rd.indexOf(-100., 100.);
583     CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
584     range = rd.indexOf(-200., 200.);
585     CPPUNIT_ASSERT(range.first == 0 &amp;&amp; range.second == 4);
586     CPPUNIT_ASSERT_THROW(rd.indexOf({-100.0, -90, 0.0}, {10.}), std::runtime_error);
587     CPPUNIT_ASSERT_NO_THROW(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}));
588     CPPUNIT_ASSERT(rd.indexOf({-100.0, 20.0, 40.0}, {-45, 120., 100.}, false).size() == 3);
589     data_array.deleteDimensions();
590 }
591 void BaseTestDimension::testRangeDimIndexOf() {
592     std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
593     Dimension d = data_array.appendRangeDimension(ticks);
594     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
595 <A NAME="3"></A>    RangeDimension rd;
596     rd = d;
597 <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#3',2,'match943-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
598     CPPUNIT_ASSERT(*rd.indexOf(-110., PositionMatch::GreaterOrEqual) == 0);
599     CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::LessOrEqual));
600     CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Less));
601     CPPUNIT_ASSERT(!rd.indexOf(-110., PositionMatch::Equal));
602     CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::GreaterOrEqual) == 0);
603     CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Greater) == 1);
604     CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::LessOrEqual) == 0);
605     CPPUNIT_ASSERT(!rd.indexOf(-100., PositionMatch::Less));
606     CPPUNIT_ASSERT(*rd.indexOf(-100., PositionMatch::Equal) == 0);
607     CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::GreaterOrEqual) == 1);
608     CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Greater) == 1);
609     CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::LessOrEqual) == 0);
610     CPPUNIT_ASSERT(*rd.indexOf(-50., PositionMatch::Less) == 0);
611     CPPUNIT_ASSERT(!rd.indexOf(-50., PositionMatch::Equal));
612     CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::GreaterOrEqual) == 3);
613     CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Greater) == 3);
614     CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::LessOrEqual) == 2);
615 <A NAME="5"></A>    CPPUNIT_ASSERT(*rd.indexOf(7., PositionMatch::Less) == 2);</B></FONT>
616     CPPUNIT_ASSERT(!rd.indexOf(7., PositionMatch::Equal));
617 <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#5',2,'match943-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::GreaterOrEqual) == 3);
618     CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Greater) == 4);
619     CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::LessOrEqual) == 3);
620     CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Less) == 2);
621     CPPUNIT_ASSERT(*rd.indexOf(10., PositionMatch::Equal) == 3);
622     CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::GreaterOrEqual));
623     CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Greater));
624     CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::LessOrEqual) == 4);
625     CPPUNIT_ASSERT(*rd.indexOf(110., PositionMatch::Less) == 4);
626     CPPUNIT_ASSERT(!rd.indexOf(110., PositionMatch::Equal));
627     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range;
628     range = rd.indexOf(40., 100., {}, RangeMatch::Inclusive);</B></FONT>
629     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
630     range = rd.indexOf(40., 100., {}, RangeMatch::Exclusive);
631     CPPUNIT_ASSERT(!range);
632     range = rd.indexOf(-100., -45., {}, RangeMatch::Inclusive);
633     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
634     range = rd.indexOf(-100., -45., {}, RangeMatch::Exclusive);
635     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
636     range = rd.indexOf(10., 120., {}, RangeMatch::Inclusive);
637     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
638     range = rd.indexOf(10., 120., {}, RangeMatch::Exclusive);
639     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 4);
640     range = rd.indexOf(100., 120., {}, RangeMatch::Inclusive);
641     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
642     range = rd.indexOf(100., 120., {}, RangeMatch::Exclusive);
643     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 4 &amp;&amp; (*range).second == 4);
644     range = rd.indexOf(110., 150., {}, RangeMatch::Exclusive);
645     CPPUNIT_ASSERT(!range);
646     range = rd.indexOf(100., -100., {}, RangeMatch::Inclusive);
647     CPPUNIT_ASSERT(!range);
648     range = rd.indexOf(100., -100., {}, RangeMatch::Exclusive);
649     CPPUNIT_ASSERT(!range);
650     range = rd.indexOf(100., -100., rd.ticks(), RangeMatch::Exclusive);
651     CPPUNIT_ASSERT(!range);
652     std::vector&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; ranges;
653     ranges = rd.indexOf({40., -100.}, {100., 100.}, true, RangeMatch::Inclusive);
654     CPPUNIT_ASSERT(ranges.size() == 2);
655     CPPUNIT_ASSERT(ranges[0].first == 4 &amp;&amp; ranges[0].second == 4);
656     CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
657     CPPUNIT_ASSERT_THROW(rd.indexOf({40., -100., -100.}, {100., 100., 101.}, true, RangeMatch::Exclusive), nix::OutOfBounds);
658     ranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, false, RangeMatch::Exclusive);
659     CPPUNIT_ASSERT(ranges.size() == 2);
660     CPPUNIT_ASSERT(ranges[0].first == 0 &amp;&amp; ranges[0].second == 3);
661     CPPUNIT_ASSERT(ranges[1].first == 0 &amp;&amp; ranges[1].second == 4);
662     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; optranges;
663     optranges = rd.indexOf({40., -100.}, {100., 100.}, RangeMatch::Inclusive);
664     CPPUNIT_ASSERT(optranges.size() == 2);
665     CPPUNIT_ASSERT(optranges[0] &amp;&amp; (*optranges[0]).first == 4 &amp;&amp; (*optranges[0]).second == 4);
666     CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 4);
667     optranges = rd.indexOf({40., -100., -100.}, {100., 100., 101.}, RangeMatch::Exclusive);
668     CPPUNIT_ASSERT(optranges.size() == 3);
669     CPPUNIT_ASSERT(!optranges[0]);
670     CPPUNIT_ASSERT(optranges[1] &amp;&amp; (*optranges[1]).first == 0 &amp;&amp; (*optranges[1]).second == 3);
671     CPPUNIT_ASSERT(optranges[2] &amp;&amp; (*optranges[2]).first == 0 &amp;&amp; (*optranges[2]).second == 4);
672     data_array.deleteDimensions();
673 }
674 void BaseTestDimension::testRangeDimTickAt() {
675     std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
676     Dimension d = data_array.appendRangeDimension(ticks);
677     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
678     RangeDimension rd;
679     rd = d;
680     CPPUNIT_ASSERT(rd.tickAt(0) == -100.);
681     CPPUNIT_ASSERT(rd.tickAt(4) == 100.);
682     CPPUNIT_ASSERT_THROW(rd.tickAt(10), OutOfBounds);
683     CPPUNIT_ASSERT(rd[0] == -100.);
684     CPPUNIT_ASSERT(rd[4] == 100.);
685     CPPUNIT_ASSERT_THROW(rd[10], OutOfBounds);
686     data_array.deleteDimensions();
687 }
688 void BaseTestDimension::testRangeDimAxis() {
689     std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
690     Dimension d = data_array.appendRangeDimension(ticks);
691     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
692     RangeDimension rd;
693     rd = d;
694     std::vector&lt;double&gt; axis = rd.axis(2);
695     CPPUNIT_ASSERT(axis.size() == 2);
696     CPPUNIT_ASSERT(axis[0] == -100.0);
697     CPPUNIT_ASSERT(axis[1] == -10.0);
698     axis = rd.axis(2, 2);
699     CPPUNIT_ASSERT(axis.size() == 2);
700     CPPUNIT_ASSERT(axis[0] == 0.0);
701     CPPUNIT_ASSERT(axis[1] == 10.0);
702     CPPUNIT_ASSERT_THROW(rd.axis(10), OutOfBounds);
703     CPPUNIT_ASSERT_THROW(rd.axis(2, 10), OutOfBounds);
704     CPPUNIT_ASSERT_THROW(rd.axis(std::numeric_limits&lt;ndsize_t&gt;::max(), static_cast&lt;size_t&gt;(1)), OutOfBounds);
705 }
706 void BaseTestDimension::testRangeDimPositionInRange() {
707 <A NAME="7"></A>    std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
708     Dimension d = data_array.appendRangeDimension(ticks);
709 <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#7',2,'match943-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT(d.dimensionType() == DimensionType::Range);
710     RangeDimension rd = d.asRangeDimension();
711     CPPUNIT_ASSERT(rd.positionInRange(-99.0) == nix::PositionInRange::InRange);
712     CPPUNIT_ASSERT(rd.positionInRange(99.0) == nix::PositionInRange::InRange);
713     CPPUNIT_ASSERT(rd.positionInRange(100.1) == nix::PositionInRange::Greater);
714     CPPUNIT_ASSERT(rd.positionInRange(-100.1) == nix::PositionInRange::Less);
715     rd.ticks({});</B></FONT>
716     CPPUNIT_ASSERT(rd.positionInRange(0.1) == nix::PositionInRange::NoRange);
717 }
718 <A NAME="1"></A>
719 void BaseTestDimension::testDataFrameDimIndexOf() {
720 <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match943-0.html#1',2,'match943-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    std::vector&lt;nix::Column&gt; cols = {{&quot;current&quot;, &quot;nA&quot;, nix::DataType::Double},
721                                      {&quot;note&quot;, &quot;&quot;, nix::DataType::String}};
722     nix::DataFrame df = block.createDataFrame(&quot;conditions&quot;, &quot;test&quot;, cols);
723     std::vector&lt;nix::Variant&gt; vals(2);
724     df.rows(10);
725     for (int i = 0; i &lt; 10; ++i) {
726         vals[0].set(i * 2.5);
727         vals[1].set(&quot;test&quot;);
728         df.writeRow(i, vals);
729     }
730     Dimension d = data_array.appendDataFrameDimension(df, 0);
731     CPPUNIT_ASSERT(d.dimensionType() == DimensionType::DataFrame);
732     DataFrameDimension dfDim;
733     dfDim = d;</B></FONT>
734     boost::optional&lt;ndsize_t&gt; pos = dfDim.indexOf(12.2, PositionMatch::GreaterOrEqual);
735     CPPUNIT_ASSERT(!pos);
736     pos = dfDim.indexOf(12.2, PositionMatch::Greater);
737     CPPUNIT_ASSERT(!pos);
738     pos = dfDim.indexOf(12.2, PositionMatch::Equal);
739     CPPUNIT_ASSERT(!pos);
740     pos = dfDim.indexOf(12.2, PositionMatch::LessOrEqual);
741     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
742     pos = dfDim.indexOf(12.2, PositionMatch::Less);
743     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
744     pos = dfDim.indexOf(9, PositionMatch::Greater);
745     CPPUNIT_ASSERT(!pos);
746     pos = dfDim.indexOf(9, PositionMatch::GreaterOrEqual);
747     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
748     pos = dfDim.indexOf(9, PositionMatch::Equal);
749     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
750     pos = dfDim.indexOf(9, PositionMatch::LessOrEqual);
751     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 9);
752     pos = dfDim.indexOf(9, PositionMatch::Less);
753     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 8);
754     pos = dfDim.indexOf(5, PositionMatch::Greater);
755     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 6);
756     pos = dfDim.indexOf(5, PositionMatch::GreaterOrEqual);
757     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
758     pos = dfDim.indexOf(5, PositionMatch::Equal);
759     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
760     pos = dfDim.indexOf(5, PositionMatch::LessOrEqual);
761     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 5);
762     pos = dfDim.indexOf(5, PositionMatch::Less);
763     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 4);
764     pos = dfDim.indexOf(0.5, PositionMatch::Greater);
765     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
766     pos = dfDim.indexOf(0.5, PositionMatch::GreaterOrEqual);
767     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 1);
768     pos = dfDim.indexOf(0.5, PositionMatch::Equal);
769     CPPUNIT_ASSERT(!pos);
770     pos = dfDim.indexOf(0.5, PositionMatch::LessOrEqual);
771     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
772     pos = dfDim.indexOf(0.5, PositionMatch::Less);
773     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
774     pos = dfDim.indexOf(-0.5, PositionMatch::Greater);
775     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
776     pos = dfDim.indexOf(-0.5, PositionMatch::GreaterOrEqual);
777     CPPUNIT_ASSERT(pos &amp;&amp; *pos == 0);
778     pos = dfDim.indexOf(-0.5, PositionMatch::Equal);
779     CPPUNIT_ASSERT(!pos);
780     pos = dfDim.indexOf(-0.5, PositionMatch::LessOrEqual);
781     CPPUNIT_ASSERT(!pos);
782     pos = dfDim.indexOf(-0.5, PositionMatch::Less);
783     CPPUNIT_ASSERT(!pos);
784     boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt; range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
785     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
786     range = dfDim.indexOf(0.0, 0.0, RangeMatch::Exclusive);
787     CPPUNIT_ASSERT(!range);
788     range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
789     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
790     range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
791     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
792     range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
793     CPPUNIT_ASSERT(!range);
794     range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
795     CPPUNIT_ASSERT(!range);
796     range = dfDim.indexOf(0.0, 0.0, RangeMatch::Inclusive);
797     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 0);
798     range = dfDim.indexOf(1.0, 1.0, RangeMatch::Exclusive);
799     CPPUNIT_ASSERT(!range);
800     range = dfDim.indexOf(0.0, 3.0, RangeMatch::Inclusive);
801     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 3);
802     range = dfDim.indexOf(0.0, 3.0, RangeMatch::Exclusive);
803     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 2);
804     range = dfDim.indexOf(3.0, 0.0, RangeMatch::Inclusive);
805     CPPUNIT_ASSERT(!range);
806     range = dfDim.indexOf(3.0, 0.0, RangeMatch::Exclusive);
807     CPPUNIT_ASSERT(!range);
808     range = dfDim.indexOf(0.0, 9.0, RangeMatch::Inclusive);
809     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 0 &amp;&amp; (*range).second == 9);
810     range = dfDim.indexOf(3.0, 9.0, RangeMatch::Exclusive);
811     CPPUNIT_ASSERT(range &amp;&amp; (*range).first == 3 &amp;&amp; (*range).second == 8);
812     std::vector&lt;boost::optional&lt;std::pair&lt;ndsize_t, ndsize_t&gt;&gt;&gt; ranges;
813     CPPUNIT_ASSERT_THROW(dfDim.indexOf({0.0, -1.0, 1.0}, {1.0, 2.0}, RangeMatch::Inclusive), std::runtime_error);
814     ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Inclusive);
815     CPPUNIT_ASSERT(ranges.size() == 4);
816     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 1);
817     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 4);
818     CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 9);
819     CPPUNIT_ASSERT(ranges[3] &amp;&amp; (*ranges[3]).first == 1 &amp;&amp; (*ranges[3]).second == 1);
820     ranges = dfDim.indexOf({0.0, -1.0, 1.0, 1.0}, {1.0, 4.0, 9.0, 1.0}, RangeMatch::Exclusive);
821     CPPUNIT_ASSERT(ranges.size() == 4);
822     CPPUNIT_ASSERT(ranges[0] &amp;&amp; (*ranges[0]).first == 0 &amp;&amp; (*ranges[0]).second == 0);
823     CPPUNIT_ASSERT(ranges[1] &amp;&amp; (*ranges[1]).first == 0 &amp;&amp; (*ranges[1]).second == 3);
824     CPPUNIT_ASSERT(ranges[2] &amp;&amp; (*ranges[2]).first == 1 &amp;&amp; (*ranges[2]).second == 8);
825     CPPUNIT_ASSERT(!ranges[3]);
826 }
827 void BaseTestDimension::testAsDimensionMethods() {
828     std::vector&lt;double&gt; ticks = {-100.0, -10.0, 0.0, 10.0, 100.0};
829     Dimension x;
830     Dimension d = data_array.appendRangeDimension(ticks);
831     CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
832     CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
833     x = d;
834     CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Range);
835     std::stringstream sa_str;
836     sa_str &lt;&lt; x.dimensionType();
837     CPPUNIT_ASSERT(sa_str.str() == &quot;Range&quot;);
838     data_array.deleteDimensions();
839     d = data_array.appendSampledDimension(0.1);
840     CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
841     CPPUNIT_ASSERT_THROW(d.asSetDimension(), IncompatibleDimensions);
842     x = d;
843     CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Sample);
844     std::stringstream range_str;
845     range_str &lt;&lt; x.dimensionType();
846     CPPUNIT_ASSERT(range_str.str() == &quot;Sample&quot;);
847     data_array.deleteDimensions();
848     d = data_array.appendSetDimension();
849     CPPUNIT_ASSERT_THROW(d.asRangeDimension(), IncompatibleDimensions);
850     CPPUNIT_ASSERT_THROW(d.asSampledDimension(), IncompatibleDimensions);
851     x = d;
852     CPPUNIT_ASSERT(x.dimensionType() == DimensionType::Set);
853     std::stringstream set_str;
854     set_str &lt;&lt; x.dimensionType();
855     CPPUNIT_ASSERT(set_str.str() == &quot;Set&quot;);
856 }
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
