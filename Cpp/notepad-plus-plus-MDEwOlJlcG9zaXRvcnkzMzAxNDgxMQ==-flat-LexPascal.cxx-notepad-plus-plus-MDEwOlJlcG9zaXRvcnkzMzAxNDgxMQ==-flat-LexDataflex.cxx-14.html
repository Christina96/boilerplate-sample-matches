
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPascal.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static void GetRangeLowered(Sci_PositionU start,
20  		Sci_PositionU end,
21  		Accessor &amp;styler,
22  		char *s,
23  		Sci_PositionU len) {
24  	Sci_PositionU i = 0;
25  	while ((i &lt; end - start + 1) &amp;&amp; (i &lt; len-1)) {
26  		s[i] = static_cast&lt;char&gt;(tolower(styler[start + i]));
27  		i++;
28  	}
29  	s[i] = &#x27;\0&#x27;;
30  }
31  static void GetForwardRangeLowered(Sci_PositionU start,
32  		CharacterSet &amp;charSet,
33  		Accessor &amp;styler,
34  		char *s,
35  		Sci_PositionU len) {
36  	Sci_PositionU i = 0;
37  	while ((i &lt; len-1) &amp;&amp; charSet.Contains(styler.SafeGetCharAt(start + i))) {
38  		s[i] = static_cast&lt;char&gt;(tolower(styler.SafeGetCharAt(start + i)));
39  		i++;
40  	}
41  	s[i] = &#x27;\0&#x27;;
42  }
43  enum {
44  	stateInAsm = 0x1000,
45  	stateInProperty = 0x2000,
46  	stateInExport = 0x4000,
47  	stateFoldInPreprocessor = 0x0100,
48  	stateFoldInRecord = 0x0200,
49  	stateFoldInPreprocessorLevelMask = 0x00FF,
50  	stateFoldMaskAll = 0x0FFF
51  };
52  static void ClassifyPascalWord(WordList *keywordlists[], StyleContext &amp;sc, int &amp;curLineState, bool bSmartHighlighting) {
53  	WordList&amp; keywords = *keywordlists[0];
54  	char s[100];
55  	sc.GetCurrentLowered(s, sizeof(s));
56  	if (keywords.InList(s)) {
57  		if (curLineState &amp; stateInAsm) {
58  			if (strcmp(s, &quot;end&quot;) == 0 &amp;&amp; sc.GetRelative(-4) != &#x27;@&#x27;) {
59  				curLineState &amp;= ~stateInAsm;
60  				sc.ChangeState(SCE_PAS_WORD);
61  			} else {
62  				sc.ChangeState(SCE_PAS_ASM);
63  			}
64  		} else {
65  			bool ignoreKeyword = false;
66  			if (strcmp(s, &quot;asm&quot;) == 0) {
67  				curLineState |= stateInAsm;
68  			} else if (bSmartHighlighting) {
69  				if (strcmp(s, &quot;property&quot;) == 0) {
70  					curLineState |= stateInProperty;
71  				} else if (strcmp(s, &quot;exports&quot;) == 0) {
72  					curLineState |= stateInExport;
73  				} else if (!(curLineState &amp; (stateInProperty | stateInExport)) &amp;&amp; strcmp(s, &quot;index&quot;) == 0) {
74  					ignoreKeyword = true;
75  				} else if (!(curLineState &amp; stateInExport) &amp;&amp; strcmp(s, &quot;name&quot;) == 0) {
76  					ignoreKeyword = true;
77  				} else if (!(curLineState &amp; stateInProperty) &amp;&amp;
78  					(strcmp(s, &quot;read&quot;) == 0 || strcmp(s, &quot;write&quot;) == 0 ||
79  					 strcmp(s, &quot;default&quot;) == 0 || strcmp(s, &quot;nodefault&quot;) == 0 ||
80  					 strcmp(s, &quot;stored&quot;) == 0 || strcmp(s, &quot;implements&quot;) == 0 ||
81  					 strcmp(s, &quot;readonly&quot;) == 0 || strcmp(s, &quot;writeonly&quot;) == 0 ||
82  					 strcmp(s, &quot;add&quot;) == 0 || strcmp(s, &quot;remove&quot;) == 0)) {
83  					ignoreKeyword = true;
84  				}
85  			}
86  			if (!ignoreKeyword) {
87  				sc.ChangeState(SCE_PAS_WORD);
88  			}
89  		}
90  	} else if (curLineState &amp; stateInAsm) {
91  		sc.ChangeState(SCE_PAS_ASM);
92  	}
93  	sc.SetState(SCE_PAS_DEFAULT);
94  }
95  static void ColourisePascalDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
96  		Accessor &amp;styler) {
97  	bool bSmartHighlighting = styler.GetPropertyInt(&quot;lexer.pascal.smart.highlighting&quot;, 1) != 0;
98  	CharacterSet setWordStart(CharacterSet::setAlpha, &quot;_&quot;, 0x80, true);
99  	CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_&quot;, 0x80, true);
100  	CharacterSet setNumber(CharacterSet::setDigits, &quot;.-+eE&quot;);
101  	CharacterSet setHexNumber(CharacterSet::setDigits, &quot;abcdefABCDEF&quot;);
102  	CharacterSet setOperator(CharacterSet::setNone, &quot;#$&amp;&#x27;()*+,-./:;&lt;=&gt;@[]^{}&quot;);
103  	Sci_Position curLine = styler.GetLine(startPos);
104  	int curLineState = curLine &gt; 0 ? styler.GetLineState(curLine - 1) : 0;
105  	StyleContext sc(startPos, length, initStyle, styler);
106  	for (; sc.More(); sc.Forward()) {
107  		if (sc.atLineEnd) {
108  			curLine = styler.GetLine(sc.currentPos);
109  			styler.SetLineState(curLine, curLineState);
110  		}
111  		switch (sc.state) {
112  			case SCE_PAS_NUMBER:
113  				if (!setNumber.Contains(sc.ch) || (sc.ch == &#x27;.&#x27; &amp;&amp; sc.chNext == &#x27;.&#x27;)) {
114  					sc.SetState(SCE_PAS_DEFAULT);
115  				} else if (sc.ch == &#x27;-&#x27; || sc.ch == &#x27;+&#x27;) {
116  					if (sc.chPrev != &#x27;E&#x27; &amp;&amp; sc.chPrev != &#x27;e&#x27;) {
117  						sc.SetState(SCE_PAS_DEFAULT);
118  					}
119  				}
120  				break;
121  			case SCE_PAS_IDENTIFIER:
122  				if (!setWord.Contains(sc.ch)) {
123  					ClassifyPascalWord(keywordlists, sc, curLineState, bSmartHighlighting);
124  				}
125  				break;
126  			case SCE_PAS_HEXNUMBER:
127  				if (!setHexNumber.Contains(sc.ch)) {
128  					sc.SetState(SCE_PAS_DEFAULT);
129  				}
130  				break;
131  			case SCE_PAS_COMMENT:
132  			case SCE_PAS_PREPROCESSOR:
133  				if (sc.ch == &#x27;}&#x27;) {
134  					sc.ForwardSetState(SCE_PAS_DEFAULT);
135  				}
136  				break;
137  			case SCE_PAS_COMMENT2:
138  			case SCE_PAS_PREPROCESSOR2:
139  				if (sc.Match(&#x27;*&#x27;, &#x27;)&#x27;)) {
140  					sc.Forward();
141  					sc.ForwardSetState(SCE_PAS_DEFAULT);
142  				}
143  				break;
144  			case SCE_PAS_COMMENTLINE:
145  				if (sc.atLineStart) {
146  					sc.SetState(SCE_PAS_DEFAULT);
147  				}
148  				break;
149  			case SCE_PAS_STRING:
150  				if (sc.atLineEnd) {
151  					sc.ChangeState(SCE_PAS_STRINGEOL);
152  				} else if (sc.ch == &#x27;\&#x27;&#x27; &amp;&amp; sc.chNext == &#x27;\&#x27;&#x27;) {
153  					sc.Forward();
154  				} else if (sc.ch == &#x27;\&#x27;&#x27;) {
155  					sc.ForwardSetState(SCE_PAS_DEFAULT);
156  				}
157  				break;
158  			case SCE_PAS_STRINGEOL:
159  				if (sc.atLineStart) {
160  					sc.SetState(SCE_PAS_DEFAULT);
161  				}
162  				break;
163  			case SCE_PAS_CHARACTER:
164  				if (!setHexNumber.Contains(sc.ch) &amp;&amp; sc.ch != &#x27;$&#x27;) {
165  					sc.SetState(SCE_PAS_DEFAULT);
166  				}
167  				break;
168  			case SCE_PAS_OPERATOR:
169  				if (bSmartHighlighting &amp;&amp; sc.chPrev == &#x27;;&#x27;) {
170  					curLineState &amp;= ~(stateInProperty | stateInExport);
171  				}
172  				sc.SetState(SCE_PAS_DEFAULT);
173  				break;
174  			case SCE_PAS_ASM:
175  				sc.SetState(SCE_PAS_DEFAULT);
176  				break;
177  		}
178  		if (sc.state == SCE_PAS_DEFAULT) {
179  			if (IsADigit(sc.ch) &amp;&amp; !(curLineState &amp; stateInAsm)) {
180  				sc.SetState(SCE_PAS_NUMBER);
181  			} else if (setWordStart.Contains(sc.ch)) {
182  				sc.SetState(SCE_PAS_IDENTIFIER);
183  			} else if (sc.ch == &#x27;$&#x27; &amp;&amp; !(curLineState &amp; stateInAsm)) {
184  				sc.SetState(SCE_PAS_HEXNUMBER);
185  			} else if (sc.Match(&#x27;{&#x27;, &#x27;$&#x27;)) {
186  				sc.SetState(SCE_PAS_PREPROCESSOR);
187  			} else if (sc.ch == &#x27;{&#x27;) {
188  				sc.SetState(SCE_PAS_COMMENT);
189  			} else if (sc.Match(&quot;(*$&quot;)) {
190  				sc.SetState(SCE_PAS_PREPROCESSOR2);
191  			} else if (sc.Match(&#x27;(&#x27;, &#x27;*&#x27;)) {
192  				sc.SetState(SCE_PAS_COMMENT2);
193  				sc.Forward();	
194  			} else if (sc.Match(&#x27;/&#x27;, &#x27;/&#x27;)) {
195  				sc.SetState(SCE_PAS_COMMENTLINE);
196  			} else if (sc.ch == &#x27;\&#x27;&#x27;) {
197  				sc.SetState(SCE_PAS_STRING);
198  			} else if (sc.ch == &#x27;#&#x27;) {
199  				sc.SetState(SCE_PAS_CHARACTER);
200  			} else if (setOperator.Contains(sc.ch) &amp;&amp; !(curLineState &amp; stateInAsm)) {
201  				sc.SetState(SCE_PAS_OPERATOR);
202  			} else if (curLineState &amp; stateInAsm) {
203  				sc.SetState(SCE_PAS_ASM);
204  			}
205  		}
206  	}
207  	if (sc.state == SCE_PAS_IDENTIFIER &amp;&amp; setWord.Contains(sc.chPrev)) {
208  		ClassifyPascalWord(keywordlists, sc, curLineState, bSmartHighlighting);
209  	}
210  	sc.Complete();
211  }
212  static bool IsStreamCommentStyle(int style) {
213  	return style == SCE_PAS_COMMENT || style == SCE_PAS_COMMENT2;
214  }
215  static bool IsCommentLine(Sci_Position line, Accessor &amp;styler) {
216  	Sci_Position pos = styler.LineStart(line);
217  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
218  	for (Sci_Position i = pos; i &lt; eolPos; i++) {
219  		char ch = styler[i];
220  		char chNext = styler.SafeGetCharAt(i + 1);
221  		int style = styler.StyleAt(i);
222  		if (ch == &#x27;/&#x27; &amp;&amp; chNext == &#x27;/&#x27; &amp;&amp; style == SCE_PAS_COMMENTLINE) {
223  			return true;
224  		} else if (!IsASpaceOrTab(ch)) {
225  			return false;
226  		}
227  	}
228  	return false;
229  }
230  static unsigned int GetFoldInPreprocessorLevelFlag(int lineFoldStateCurrent) {
231  	return lineFoldStateCurrent &amp; stateFoldInPreprocessorLevelMask;
232  }
233  static void SetFoldInPreprocessorLevelFlag(int &amp;lineFoldStateCurrent, unsigned int nestLevel) {
234  	lineFoldStateCurrent &amp;= ~stateFoldInPreprocessorLevelMask;
235  	lineFoldStateCurrent |= nestLevel &amp; stateFoldInPreprocessorLevelMask;
236  }
237  static void ClassifyPascalPreprocessorFoldPoint(int &amp;levelCurrent, int &amp;lineFoldStateCurrent,
238  		Sci_PositionU startPos, Accessor &amp;styler) {
239  	CharacterSet setWord(CharacterSet::setAlpha);
240  	char s[11];	
241  	GetForwardRangeLowered(startPos, setWord, styler, s, sizeof(s));
242  	unsigned int nestLevel = GetFoldInPreprocessorLevelFlag(lineFoldStateCurrent);
243  	if (strcmp(s, &quot;if&quot;) == 0 ||
244  		strcmp(s, &quot;ifdef&quot;) == 0 ||
245  		strcmp(s, &quot;ifndef&quot;) == 0 ||
246  		strcmp(s, &quot;ifopt&quot;) == 0 ||
247  		strcmp(s, &quot;region&quot;) == 0) {
248  		nestLevel++;
<span onclick='openModal()' class='match'>249  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
250  		lineFoldStateCurrent |= stateFoldInPreprocessor;
251  		levelCurrent++;
252  	} else if (strcmp(s, &quot;endif&quot;) == 0 ||
</span>253  		strcmp(s, &quot;ifend&quot;) == 0 ||
254  		strcmp(s, &quot;endregion&quot;) == 0) {
255  		nestLevel--;
256  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
257  		if (nestLevel == 0) {
258  			lineFoldStateCurrent &amp;= ~stateFoldInPreprocessor;
259  		}
260  		levelCurrent--;
261  		if (levelCurrent &lt; SC_FOLDLEVELBASE) {
262  			levelCurrent = SC_FOLDLEVELBASE;
263  		}
264  	}
265  }
266  static Sci_PositionU SkipWhiteSpace(Sci_PositionU currentPos, Sci_PositionU endPos,
267  		Accessor &amp;styler, bool includeChars = false) {
268  	CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_&quot;);
269  	Sci_PositionU j = currentPos + 1;
270  	char ch = styler.SafeGetCharAt(j);
271  	while ((j &lt; endPos) &amp;&amp; (IsASpaceOrTab(ch) || ch == &#x27;\r&#x27; || ch == &#x27;\n&#x27; ||
272  		IsStreamCommentStyle(styler.StyleAt(j)) || (includeChars &amp;&amp; setWord.Contains(ch)))) {
273  		j++;
274  		ch = styler.SafeGetCharAt(j);
275  	}
276  	return j;
277  }
278  static void ClassifyPascalWordFoldPoint(int &amp;levelCurrent, int &amp;lineFoldStateCurrent,
279  		Sci_Position startPos, Sci_PositionU endPos,
280  		Sci_PositionU lastStart, Sci_PositionU currentPos, Accessor &amp;styler) {
281  	char s[100];
282  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
283  	if (strcmp(s, &quot;record&quot;) == 0) {
284  		lineFoldStateCurrent |= stateFoldInRecord;
285  		levelCurrent++;
286  	} else if (strcmp(s, &quot;begin&quot;) == 0 ||
287  		strcmp(s, &quot;asm&quot;) == 0 ||
288  		strcmp(s, &quot;try&quot;) == 0 ||
289  		(strcmp(s, &quot;case&quot;) == 0 &amp;&amp; !(lineFoldStateCurrent &amp; stateFoldInRecord))) {
290  		levelCurrent++;
291  	} else if (strcmp(s, &quot;class&quot;) == 0 || strcmp(s, &quot;object&quot;) == 0) {
292  		bool ignoreKeyword = false;
293  		Sci_PositionU j = SkipWhiteSpace(currentPos, endPos, styler);
294  		if (j &lt; endPos) {
295  			CharacterSet setWordStart(CharacterSet::setAlpha, &quot;_&quot;);
296  			CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_&quot;);
297  			if (styler.SafeGetCharAt(j) == &#x27;;&#x27;) {
298  				ignoreKeyword = true;
299  			} else if (strcmp(s, &quot;class&quot;) == 0) {
300  				if (styler.SafeGetCharAt(j) == &#x27;(&#x27;) {
301  					j = SkipWhiteSpace(j, endPos, styler, true);
302  					if (j &lt; endPos &amp;&amp; styler.SafeGetCharAt(j) == &#x27;)&#x27;) {
303  						j = SkipWhiteSpace(j, endPos, styler);
304  						if (j &lt; endPos &amp;&amp; styler.SafeGetCharAt(j) == &#x27;;&#x27;) {
305  							ignoreKeyword = true;
306  						}
307  					}
308  				} else if (setWordStart.Contains(styler.SafeGetCharAt(j))) {
309  					char s2[11];	
310  					GetForwardRangeLowered(j, setWord, styler, s2, sizeof(s2));
311  					if (strcmp(s2, &quot;procedure&quot;) == 0 ||
312  						strcmp(s2, &quot;function&quot;) == 0 ||
313  						strcmp(s2, &quot;of&quot;) == 0 ||
314  						strcmp(s2, &quot;var&quot;) == 0 ||
315  						strcmp(s2, &quot;property&quot;) == 0 ||
316  						strcmp(s2, &quot;operator&quot;) == 0) {
317  						ignoreKeyword = true;
318  					}
319  				}
320  			}
321  		}
322  		if (!ignoreKeyword) {
323  			levelCurrent++;
324  		}
325  	} else if (strcmp(s, &quot;interface&quot;) == 0) {
326  		bool ignoreKeyword = true;
327  		Sci_Position j = lastStart - 1;
328  		char ch = styler.SafeGetCharAt(j);
329  		while ((j &gt;= startPos) &amp;&amp; (IsASpaceOrTab(ch) || ch == &#x27;\r&#x27; || ch == &#x27;\n&#x27; ||
330  			IsStreamCommentStyle(styler.StyleAt(j)))) {
331  			j--;
332  			ch = styler.SafeGetCharAt(j);
333  		}
334  		if (j &gt;= startPos &amp;&amp; styler.SafeGetCharAt(j) == &#x27;=&#x27;) {
335  			ignoreKeyword = false;
336  		}
337  		if (!ignoreKeyword) {
338  			Sci_PositionU k = SkipWhiteSpace(currentPos, endPos, styler);
339  			if (k &lt; endPos &amp;&amp; styler.SafeGetCharAt(k) == &#x27;;&#x27;) {
340  				ignoreKeyword = true;
341  			}
342  		}
343  		if (!ignoreKeyword) {
344  			levelCurrent++;
345  		}
346  	} else if (strcmp(s, &quot;dispinterface&quot;) == 0) {
347  		bool ignoreKeyword = false;
348  		Sci_PositionU j = SkipWhiteSpace(currentPos, endPos, styler);
349  		if (j &lt; endPos &amp;&amp; styler.SafeGetCharAt(j) == &#x27;;&#x27;) {
350  			ignoreKeyword = true;
351  		}
352  		if (!ignoreKeyword) {
353  			levelCurrent++;
354  		}
355  	} else if (strcmp(s, &quot;end&quot;) == 0) {
356  		lineFoldStateCurrent &amp;= ~stateFoldInRecord;
357  		levelCurrent--;
358  		if (levelCurrent &lt; SC_FOLDLEVELBASE) {
359  			levelCurrent = SC_FOLDLEVELBASE;
360  		}
361  	}
362  }
363  static void FoldPascalDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
364  		Accessor &amp;styler) {
365  	bool foldComment = styler.GetPropertyInt(&quot;fold.comment&quot;) != 0;
366  	bool foldPreprocessor = styler.GetPropertyInt(&quot;fold.preprocessor&quot;) != 0;
367  	bool foldCompact = styler.GetPropertyInt(&quot;fold.compact&quot;, 1) != 0;
368  	Sci_PositionU endPos = startPos + length;
369  	int visibleChars = 0;
370  	Sci_Position lineCurrent = styler.GetLine(startPos);
371  	int levelPrev = styler.LevelAt(lineCurrent) &amp; SC_FOLDLEVELNUMBERMASK;
372  	int levelCurrent = levelPrev;
373  	int lineFoldStateCurrent = lineCurrent &gt; 0 ? styler.GetLineState(lineCurrent - 1) &amp; stateFoldMaskAll : 0;
374  	char chNext = styler[startPos];
375  	int styleNext = styler.StyleAt(startPos);
376  	int style = initStyle;
377  	Sci_Position lastStart = 0;
378  	CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_&quot;, 0x80, true);
379  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
380  		char ch = chNext;
381  		chNext = styler.SafeGetCharAt(i + 1);
382  		int stylePrev = style;
383  		style = styleNext;
384  		styleNext = styler.StyleAt(i + 1);
385  		bool atEOL = (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
386  		if (foldComment &amp;&amp; IsStreamCommentStyle(style)) {
387  			if (!IsStreamCommentStyle(stylePrev)) {
388  				levelCurrent++;
389  			} else if (!IsStreamCommentStyle(styleNext) &amp;&amp; !atEOL) {
390  				levelCurrent--;
391  			}
392  		}
393  		if (foldComment &amp;&amp; atEOL &amp;&amp; IsCommentLine(lineCurrent, styler))
394  		{
395  			if (!IsCommentLine(lineCurrent - 1, styler)
396  			    &amp;&amp; IsCommentLine(lineCurrent + 1, styler))
397  				levelCurrent++;
398  			else if (IsCommentLine(lineCurrent - 1, styler)
399  			         &amp;&amp; !IsCommentLine(lineCurrent+1, styler))
400  				levelCurrent--;
401  		}
402  		if (foldPreprocessor) {
403  			if (style == SCE_PAS_PREPROCESSOR &amp;&amp; ch == &#x27;{&#x27; &amp;&amp; chNext == &#x27;$&#x27;) {
404  				ClassifyPascalPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 2, styler);
405  			} else if (style == SCE_PAS_PREPROCESSOR2 &amp;&amp; ch == &#x27;(&#x27; &amp;&amp; chNext == &#x27;*&#x27;
406  			           &amp;&amp; styler.SafeGetCharAt(i + 2) == &#x27;$&#x27;) {
407  				ClassifyPascalPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 3, styler);
408  			}
409  		}
410  		if (stylePrev != SCE_PAS_WORD &amp;&amp; style == SCE_PAS_WORD)
411  		{
412  			lastStart = i;
413  		}
414  		if (stylePrev == SCE_PAS_WORD &amp;&amp; !(lineFoldStateCurrent &amp; stateFoldInPreprocessor)) {
415  			if(setWord.Contains(ch) &amp;&amp; !setWord.Contains(chNext)) {
416  				ClassifyPascalWordFoldPoint(levelCurrent, lineFoldStateCurrent, startPos, endPos, lastStart, i, styler);
417  			}
418  		}
419  		if (!IsASpace(ch))
420  			visibleChars++;
421  		if (atEOL) {
422  			int lev = levelPrev;
423  			if (visibleChars == 0 &amp;&amp; foldCompact)
424  				lev |= SC_FOLDLEVELWHITEFLAG;
425  			if ((levelCurrent &gt; levelPrev) &amp;&amp; (visibleChars &gt; 0))
426  				lev |= SC_FOLDLEVELHEADERFLAG;
427  			if (lev != styler.LevelAt(lineCurrent)) {
428  				styler.SetLevel(lineCurrent, lev);
429  			}
430  			int newLineState = (styler.GetLineState(lineCurrent) &amp; ~stateFoldMaskAll) | lineFoldStateCurrent;
431  			styler.SetLineState(lineCurrent, newLineState);
432  			lineCurrent++;
433  			levelPrev = levelCurrent;
434  			visibleChars = 0;
435  		}
436  	}
437  	int lev = levelPrev;
438  	if (visibleChars == 0 &amp;&amp; foldCompact)
439  		lev |= SC_FOLDLEVELWHITEFLAG;
440  	styler.SetLevel(lineCurrent, lev);
441  }
442  static const char * const pascalWordListDesc[] = {
443  	&quot;Keywords&quot;,
444  	0
445  };
446  LexerModule lmPascal(SCLEX_PASCAL, ColourisePascalDoc, &quot;pascal&quot;, FoldPascalDoc, pascalWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexDataflex.cxx</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &lt;string.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdarg.h&gt;
5  #include &lt;assert.h&gt;
6  #include &lt;ctype.h&gt;
7  #include &lt;string&gt;
8  #include &lt;string_view&gt;
9  #include &quot;ILexer.h&quot;
10  #include &quot;Scintilla.h&quot;
11  #include &quot;SciLexer.h&quot;
12  #include &quot;WordList.h&quot;
13  #include &quot;LexAccessor.h&quot;
14  #include &quot;Accessor.h&quot;
15  #include &quot;StyleContext.h&quot;
16  #include &quot;CharacterSet.h&quot;
17  #include &quot;LexerModule.h&quot;
18  using namespace Lexilla;
19  static void GetRangeLowered(Sci_PositionU start,
20  		Sci_PositionU end,
21  		Accessor &amp;styler,
22  		char *s,
23  		Sci_PositionU len) {
24  	Sci_PositionU i = 0;
25  	while ((i &lt; end - start + 1) &amp;&amp; (i &lt; len-1)) {
26  		s[i] = static_cast&lt;char&gt;(tolower(styler[start + i]));
27  		i++;
28  	}
29  	s[i] = &#x27;\0&#x27;;
30  }
31  static void GetForwardRangeLowered(Sci_PositionU start,
32  		CharacterSet &amp;charSet,
33  		Accessor &amp;styler,
34  		char *s,
35  		Sci_PositionU len) {
36  	Sci_PositionU i = 0;
37  	while ((i &lt; len-1) &amp;&amp; charSet.Contains(styler.SafeGetCharAt(start + i))) {
38  		s[i] = static_cast&lt;char&gt;(tolower(styler.SafeGetCharAt(start + i)));
39  		i++;
40  	}
41  	s[i] = &#x27;\0&#x27;;
42  }
43  enum {
44  	stateInICode = 0x1000,
45  	stateSingleQuoteOpen = 0x2000,
46  	stateDoubleQuoteOpen = 0x4000,
47  	stateFoldInPreprocessor = 0x0100,
48  	stateFoldInCaseStatement = 0x0200,
49  	stateFoldInPreprocessorLevelMask = 0x00FF,
50  	stateFoldMaskAll = 0x0FFF
51  };
52  static bool IsFirstDataFlexWord(Sci_Position pos, Accessor &amp;styler) {
53  	Sci_Position line = styler.GetLine(pos);
54  	Sci_Position start_pos = styler.LineStart(line);
55  	for (Sci_Position i = start_pos; i &lt; pos; i++) {
56  		char ch = styler.SafeGetCharAt(i);
57  		if (!(ch == &#x27; &#x27; || ch == &#x27;\t&#x27;))
58  			return false;
59  	}
60  	return true;
61  }
62  inline bool IsADataFlexField(int ch) {
63  	return (ch == &#x27;.&#x27;);
64  }
65  static void ClassifyDataFlexWord(WordList *keywordlists[], StyleContext &amp;sc, Accessor &amp;styler) {
66  	WordList&amp; keywords = *keywordlists[0];
67  	WordList&amp; scopeOpen   = *keywordlists[1];
68  	WordList&amp; scopeClosed = *keywordlists[2];
69  	WordList&amp; operators   = *keywordlists[3];
70  	char s[100];
71  	int oldState;
72  	int newState;
73  	size_t tokenlen;
74      oldState = sc.state;
75  	newState = oldState;
76  	sc.GetCurrentLowered(s, sizeof(s));
77  	tokenlen = strnlen(s,sizeof(s));
78  	if (keywords.InList(s)) {
79          if (!IsADataFlexField(sc.GetRelative(-static_cast&lt;int&gt;(tokenlen+1)))) {
80  	      newState = SCE_DF_WORD;
81  	    }
82  	}
83  	if (oldState == newState) {
84  		if ((scopeOpen.InList(s) || scopeClosed.InList(s)) &amp;&amp; (strcmp(s, &quot;for&quot;) != 0) &amp;&amp; (strcmp(s, &quot;repeat&quot;) != 0)) {
85  			if (!IsADataFlexField(sc.GetRelative(-static_cast&lt;int&gt;(tokenlen+1)))) {
86  				newState = SCE_DF_SCOPEWORD;
87  			}
88  		} 
89  		if (strcmp(s, &quot;if&quot;) == 0 ||  
90  			strcmp(s, &quot;ifnot&quot;) == 0 ||
91  			strcmp(s, &quot;case&quot;) == 0 ||
92  			strcmp(s, &quot;else&quot;) == 0 ) {
93  				newState = SCE_DF_SCOPEWORD;
94  		} 
95  	}
96  	if (oldState != newState &amp;&amp; newState == SCE_DF_WORD) {
97  		if ( (strcmp(s, &quot;for&quot;) == 0) &amp;&amp; (IsFirstDataFlexWord(sc.currentPos-3, styler)) ) {   
98  				newState = SCE_DF_SCOPEWORD;
99  		} 
100  	}
101  	if (oldState != newState &amp;&amp; newState == SCE_DF_WORD) {
102  		if ( (strcmp(s, &quot;repeat&quot;) == 0) &amp;&amp; (IsFirstDataFlexWord(sc.currentPos-6, styler)) ) {   
103  				newState = SCE_DF_SCOPEWORD;
104  		} 
105  	}
106  	if (oldState == newState)  {
107  	  if (operators.InList(s)) {
108  		  newState = SCE_DF_OPERATOR;
109  		} 
110  	}
111  	if (oldState != newState) {
112  		sc.ChangeState(newState);
113  	}
114  	sc.SetState(SCE_DF_DEFAULT);
115  }
116  static void ColouriseDataFlexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
117  		Accessor &amp;styler) {
118  			CharacterSet setWordStart(CharacterSet::setAlpha, &quot;_$#@&quot;, 0x80, true);
119  			CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_$#@&quot;, 0x80, true);
120  	CharacterSet setNumber(CharacterSet::setDigits, &quot;.-+eE&quot;);
121  	CharacterSet setHexNumber(CharacterSet::setDigits, &quot;abcdefABCDEF&quot;);
122  	CharacterSet setOperator(CharacterSet::setNone, &quot;*+-/&lt;=&gt;^&quot;);
123  	Sci_Position curLine = styler.GetLine(startPos);
124  	int curLineState = curLine &gt; 0 ? styler.GetLineState(curLine - 1) : 0;
125  	StyleContext sc(startPos, length, initStyle, styler);
126  	for (; sc.More(); sc.Forward()) {
127  		if (sc.atLineEnd) {
128  			curLine = styler.GetLine(sc.currentPos);
129  			styler.SetLineState(curLine, curLineState);
130  		}
131  		switch (sc.state) {
132  			case SCE_DF_NUMBER:
133  				if (!setNumber.Contains(sc.ch) || (sc.ch == &#x27;.&#x27; &amp;&amp; sc.chNext == &#x27;.&#x27;)) {
134  					sc.SetState(SCE_DF_DEFAULT);
135  				} else if (sc.ch == &#x27;-&#x27; || sc.ch == &#x27;+&#x27;) {
136  					if (sc.chPrev != &#x27;E&#x27; &amp;&amp; sc.chPrev != &#x27;e&#x27;) {
137  						sc.SetState(SCE_DF_DEFAULT);
138  					}
139  				}
140  				break;
141  			case SCE_DF_IDENTIFIER:
142  				if (!setWord.Contains(sc.ch)) {
143  					ClassifyDataFlexWord(keywordlists, sc, styler);
144  				}
145  				break;
146  			case SCE_DF_HEXNUMBER:
147  				if (!(setHexNumber.Contains(sc.ch) || sc.ch == &#x27;I&#x27;) ) { 
148  					sc.SetState(SCE_DF_DEFAULT);
149  				}
150  				break;
151  			case SCE_DF_METATAG:
152  				if (sc.atLineStart || sc.chPrev == &#x27;}&#x27;) {
153  					sc.SetState(SCE_DF_DEFAULT);
154  				}
155  				break;
156  			case SCE_DF_PREPROCESSOR:
157  				if (sc.atLineStart || IsASpaceOrTab(sc.ch)) {
158  					sc.SetState(SCE_DF_DEFAULT);
159  				}
160  				break;
161  			case SCE_DF_IMAGE:
162  				if (sc.atLineStart &amp;&amp; sc.Match(&quot;&amp;bsol;*&quot;)) {
163  					sc.Forward();  
164  					sc.ForwardSetState(SCE_DF_DEFAULT);
165  				}
166  				break;
167  			case SCE_DF_PREPROCESSOR2:
168  				break;
169  			case SCE_DF_COMMENTLINE:
170  				if (sc.atLineStart) {
171  					sc.SetState(SCE_DF_DEFAULT);
172  				}
173  				break;
174  			case SCE_DF_STRING:
175  				if (sc.atLineEnd) {
176  					sc.ChangeState(SCE_DF_STRINGEOL);
177  				} else if (sc.ch == &#x27;\&#x27;&#x27; &amp;&amp; sc.chNext == &#x27;\&#x27;&#x27;) {
178  					sc.Forward();
179  				} else if (sc.ch == &#x27;\&quot;&#x27; &amp;&amp; sc.chNext == &#x27;\&quot;&#x27;) {
180  					sc.Forward();
181  				} else if (sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27;) {
182  					if (sc.ch == &#x27;\&#x27;&#x27; &amp;&amp; (curLineState &amp; stateSingleQuoteOpen) ) {
183   				    curLineState &amp;= ~(stateSingleQuoteOpen);
184  					sc.ForwardSetState(SCE_DF_DEFAULT);
185  					}
186  					else if (sc.ch == &#x27;\&quot;&#x27; &amp;&amp; (curLineState &amp; stateDoubleQuoteOpen) ) {
187   				    curLineState &amp;= ~(stateDoubleQuoteOpen);
188  					sc.ForwardSetState(SCE_DF_DEFAULT);
189  					}
190  				}
191  				break;
192  			case SCE_DF_STRINGEOL:
193  				if (sc.atLineStart) {
194  					sc.SetState(SCE_DF_DEFAULT);
195  				}
196  				break;
197  			case SCE_DF_SCOPEWORD:
198  				break;
199  			case SCE_DF_OPERATOR:
200  				sc.SetState(SCE_DF_DEFAULT);
201  				break;
202  			case SCE_DF_ICODE:
203  				if (sc.atLineStart || IsASpace(sc.ch) || isoperator(sc.ch)) {
204  				sc.SetState(SCE_DF_DEFAULT);
205  				}
206  				break;
207  		}
208  		if (sc.state == SCE_DF_DEFAULT) {
209  			if (IsADigit(sc.ch)) {
210  				sc.SetState(SCE_DF_NUMBER);
211  			} else if (sc.Match(&#x27;/&#x27;, &#x27;/&#x27;) || sc.Match(&quot;#REM&quot;)) {
212  				sc.SetState(SCE_DF_COMMENTLINE);
213  			} else if ((sc.ch == &#x27;#&#x27; &amp;&amp; !sc.Match(&quot;#REM&quot;)) &amp;&amp; IsFirstDataFlexWord(sc.currentPos, styler)) {
214  				sc.SetState(SCE_DF_PREPROCESSOR);
215  			} else if ((sc.ch == &#x27;$&#x27; &amp;&amp; ((!setWord.Contains(sc.chPrev)) || sc.chPrev == &#x27;I&#x27; ) ) || (sc.Match(&quot;|CI$&quot;)) ) {
216  				sc.SetState(SCE_DF_HEXNUMBER); 
217  			} else if (setWordStart.Contains(sc.ch)) {
218  				sc.SetState(SCE_DF_IDENTIFIER);
219  			} else if (sc.ch == &#x27;{&#x27;) {
220  				sc.SetState(SCE_DF_METATAG);
221  			} else if (sc.ch == &#x27;/&#x27; &amp;&amp; setWord.Contains(sc.chNext) &amp;&amp;  sc.atLineStart) {
222  				sc.SetState(SCE_DF_IMAGE);
223  			} else if (sc.ch == &#x27;\&#x27;&#x27; || sc.ch == &#x27;\&quot;&#x27;) {
224  				if (sc.ch == &#x27;\&#x27;&#x27; &amp;&amp; !(curLineState &amp; stateDoubleQuoteOpen)) {
225  				  curLineState |= stateSingleQuoteOpen;
226  				} else if (sc.ch == &#x27;\&quot;&#x27; &amp;&amp; !(curLineState &amp; stateSingleQuoteOpen)) {
227  				  curLineState |= stateDoubleQuoteOpen;
228  				}
229  			    sc.SetState(SCE_DF_STRING);
230  			} else if (setOperator.Contains(sc.ch)) {
231  				sc.SetState(SCE_DF_OPERATOR);
232  			} else if ((sc.ch == &#x27;!&#x27;) &amp;&amp; !(sc.ch == &#x27;!&#x27; &amp;&amp; ((sc.chNext == &#x27;\&quot;&#x27;) || (sc.ch == &#x27;\&#x27;&#x27;)) )) {
233  				sc.SetState(SCE_DF_ICODE);
234  			}
235  		}
236  	}
237  	if (sc.state == SCE_DF_IDENTIFIER &amp;&amp; setWord.Contains(sc.chPrev)) {
238  		ClassifyDataFlexWord(keywordlists, sc, styler);
239  	}
240  	sc.Complete();
241  }
242  static bool IsStreamCommentStyle(int style) {
243  	return style == SCE_DF_IMAGE;
244  }
245  static bool IsCommentLine(Sci_Position line, Accessor &amp;styler) {
246  	Sci_Position pos = styler.LineStart(line);
247  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
248  	for (Sci_Position i = pos; i &lt; eolPos; i++) {
249  		char ch = styler[i];
250  		char chNext = styler.SafeGetCharAt(i + 1);
251  		int style = styler.StyleAt(i);
252  		if (ch == &#x27;/&#x27; &amp;&amp; chNext == &#x27;/&#x27; &amp;&amp; style == SCE_DF_COMMENTLINE) {
253  			return true;
254  		} else if (!IsASpaceOrTab(ch)) {
255  			return false;
256  		}
257  	}
258  	return false;
259  }
260  static unsigned int GetFoldInPreprocessorLevelFlag(int lineFoldStateCurrent) {
261  	return lineFoldStateCurrent &amp; stateFoldInPreprocessorLevelMask;
262  }
263  static void SetFoldInPreprocessorLevelFlag(int &amp;lineFoldStateCurrent, unsigned int nestLevel) {
264  	lineFoldStateCurrent &amp;= ~stateFoldInPreprocessorLevelMask;
265  	lineFoldStateCurrent |= nestLevel &amp; stateFoldInPreprocessorLevelMask;
266  }
267  static int ClassifyDataFlexPreprocessorFoldPoint(int &amp;levelCurrent, int &amp;lineFoldStateCurrent,
268  		Sci_PositionU startPos, Accessor &amp;styler) {
269  	CharacterSet setWord(CharacterSet::setAlpha);
270  	char s[100];	
271  	GetForwardRangeLowered(startPos, setWord, styler, s, sizeof(s));
272  	size_t iLen = strnlen(s,sizeof(s));
273  	size_t iWordSize = 0;
274  	unsigned int nestLevel = GetFoldInPreprocessorLevelFlag(lineFoldStateCurrent);
275  	if (strcmp(s, &quot;command&quot;) == 0 ||
276  		strcmp(s, &quot;header&quot;) == 0) {
277  		nestLevel++;
<span onclick='openModal()' class='match'>278  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
279  		lineFoldStateCurrent |= stateFoldInPreprocessor;
280  		levelCurrent++;
281  		iWordSize = iLen;
</span>282  	} else if (strcmp(s, &quot;endcommand&quot;) == 0 ||
283  		strcmp(s, &quot;endheader&quot;) == 0) {
284  		nestLevel--;
285  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
286  		if (nestLevel == 0) {
287  			lineFoldStateCurrent &amp;= ~stateFoldInPreprocessor;
288  		}
289  		levelCurrent--;
290  		iWordSize = iLen;
291  		if (levelCurrent &lt; SC_FOLDLEVELBASE) {
292  			levelCurrent = SC_FOLDLEVELBASE;
293  		}
294  	}
295  	return static_cast&lt;int&gt;(iWordSize);
296  }
297  static void ClassifyDataFlexWordFoldPoint(int &amp;levelCurrent, int &amp;lineFoldStateCurrent,
298  		Sci_PositionU lastStart, Sci_PositionU currentPos, WordList *[], Accessor &amp;styler) {
299  	char s[100];
300  	bool foldPRN = styler.GetPropertyInt(&quot;fold.dataflex.compilerlist&quot;,0) != 0;
301  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
302  	if (strcmp(s, &quot;case&quot;) == 0) {
303  		lineFoldStateCurrent |= stateFoldInCaseStatement;
304  	} else if (strcmp(s, &quot;begin&quot;) == 0) {
305  		levelCurrent++;
306  	} else if (strcmp(s, &quot;for&quot;) == 0 ||
307  		strcmp(s, &quot;while&quot;) == 0 ||
308  		strcmp(s, &quot;repeat&quot;) == 0 ||
309  		strcmp(s, &quot;for_all&quot;) == 0 ||
310  		strcmp(s, &quot;struct&quot;) == 0 ||
311  		strcmp(s, &quot;type&quot;) == 0 ||
312  		strcmp(s, &quot;begin_row&quot;) == 0 ||
313  		strcmp(s, &quot;item_list&quot;) == 0 ||
314  		strcmp(s, &quot;begin_constraints&quot;) == 0 ||
315  		strcmp(s, &quot;begin_transaction&quot;) == 0 ||
316  		strcmp(s, &quot;enum_list&quot;) == 0 ||
317  		strcmp(s, &quot;class&quot;) == 0 || 
318  		strcmp(s, &quot;object&quot;) == 0 ||
319  		strcmp(s, &quot;cd_popup_object&quot;) == 0 ||
320  		strcmp(s, &quot;procedure&quot;) == 0 ||
321  		strcmp(s, &quot;procedure_section&quot;) == 0 ||
322  		strcmp(s, &quot;function&quot;) == 0 ) {
323  			if ((IsFirstDataFlexWord(lastStart, styler )) || foldPRN) {
324  			levelCurrent++;
325  			}
326  	} else if (strcmp(s, &quot;end&quot;) == 0) {  
327  		levelCurrent--;
328  		if (levelCurrent &lt; SC_FOLDLEVELBASE) {
329  			levelCurrent = SC_FOLDLEVELBASE;
330  		}
331  	} else if (strcmp(s, &quot;loop&quot;) == 0 ||
332  				   strcmp(s, &quot;until&quot;) == 0 ||
333  				   strcmp(s, &quot;end_class&quot;) == 0 ||
334  				   strcmp(s, &quot;end_object&quot;) == 0 ||
335  				   strcmp(s, &quot;cd_end_object&quot;) == 0 ||
336  				   strcmp(s, &quot;end_procedure&quot;) == 0 ||
337  				   strcmp(s, &quot;end_function&quot;) == 0 ||
338  				   strcmp(s, &quot;end_for_all&quot;) == 0 ||
339  				   strcmp(s, &quot;end_struct&quot;) == 0 ||
340  				   strcmp(s, &quot;end_type&quot;) == 0 ||
341  				   strcmp(s, &quot;end_row&quot;) == 0 ||
342  				   strcmp(s, &quot;end_item_list&quot;) == 0 ||
343  				   strcmp(s, &quot;end_constraints&quot;) == 0 ||
344  				   strcmp(s, &quot;end_transaction&quot;) == 0 ||
345  				   strcmp(s, &quot;end_enum_list&quot;) == 0 ) {
346  			if ((IsFirstDataFlexWord(lastStart, styler )) || foldPRN) {
347  				levelCurrent--;
348  				if (levelCurrent &lt; SC_FOLDLEVELBASE) {
349  					levelCurrent = SC_FOLDLEVELBASE;
350  				}
351  			}
352  	}
353  }
354  static void ClassifyDataFlexMetaDataFoldPoint(int &amp;levelCurrent, 
355  		Sci_PositionU lastStart, Sci_PositionU currentPos, WordList *[], Accessor &amp;styler) {
356  	char s[100];
357  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
358      if (strcmp(s, &quot;#beginsection&quot;) == 0) {
359  		levelCurrent++;
360  	} else if (strcmp(s, &quot;#endsection&quot;) == 0) {
361  			levelCurrent--;
362  			if (levelCurrent &lt; SC_FOLDLEVELBASE) {
363  				levelCurrent = SC_FOLDLEVELBASE;
364  			}
365  	}
366  }
367  static void FoldDataFlexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
368  		Accessor &amp;styler) {
369  	bool foldComment = styler.GetPropertyInt(&quot;fold.comment&quot;) != 0;
370  	bool foldPreprocessor = styler.GetPropertyInt(&quot;fold.preprocessor&quot;) != 0;
371  	bool foldCompact = styler.GetPropertyInt(&quot;fold.compact&quot;, 1) != 0;
372  	Sci_PositionU endPos = startPos + length;
373  	int visibleChars = 0;
374  	Sci_Position lineCurrent = styler.GetLine(startPos);
375  	int levelPrev = styler.LevelAt(lineCurrent) &amp; SC_FOLDLEVELNUMBERMASK;
376  	int levelCurrent = levelPrev;
377  	int lineFoldStateCurrent = lineCurrent &gt; 0 ? styler.GetLineState(lineCurrent - 1) &amp; stateFoldMaskAll : 0;
378  	char chNext = styler[startPos];
379  	int styleNext = styler.StyleAt(startPos);
380  	int style = initStyle;
381  	int iWordSize;
382  	Sci_Position lastStart = 0;
383  	CharacterSet setWord(CharacterSet::setAlphaNum, &quot;_$#@&quot;, 0x80, true);
384  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
385  		char ch = chNext;
386  		chNext = styler.SafeGetCharAt(i + 1);
387  		int stylePrev = style;
388  		style = styleNext;
389  		styleNext = styler.StyleAt(i + 1);
390  		bool atEOL = (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
391  		if (foldComment &amp;&amp; IsStreamCommentStyle(style)) {
392  			if (!IsStreamCommentStyle(stylePrev)) {
393  				levelCurrent++;
394  			} else if (!IsStreamCommentStyle(styleNext)) {
395  				levelCurrent--;
396  			}
397  		}
398  		if (foldComment &amp;&amp; atEOL &amp;&amp; IsCommentLine(lineCurrent, styler))
399  		{
400  			if (!IsCommentLine(lineCurrent - 1, styler)
401  			    &amp;&amp; IsCommentLine(lineCurrent + 1, styler))
402  				levelCurrent++;
403  			else if (IsCommentLine(lineCurrent - 1, styler)
404  			         &amp;&amp; !IsCommentLine(lineCurrent+1, styler))
405  				levelCurrent--;
406  		}
407  		if (foldPreprocessor) {
408  			if (style == SCE_DF_PREPROCESSOR) {
409  				iWordSize = ClassifyDataFlexPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 1, styler);
410  				i = i + iWordSize;
411  			}
412  		}
413  		if (stylePrev != SCE_DF_SCOPEWORD &amp;&amp; style == SCE_DF_SCOPEWORD)
414  		{
415  			lastStart = i;
416  		}
417  		if (stylePrev == SCE_DF_SCOPEWORD) {
418  			if(setWord.Contains(ch) &amp;&amp; !setWord.Contains(chNext)) {
419  				ClassifyDataFlexWordFoldPoint(levelCurrent, lineFoldStateCurrent, lastStart, i, keywordlists, styler);
420  			}
421  		}
422  		if (stylePrev == SCE_DF_METATAG &amp;&amp; ch == &#x27;#&#x27;)
423  		{
424  			lastStart = i;
425  		}
426  		if (stylePrev == SCE_DF_METATAG) {
427  			if(setWord.Contains(ch) &amp;&amp; !setWord.Contains(chNext)) {
428  				ClassifyDataFlexMetaDataFoldPoint(levelCurrent, lastStart, i, keywordlists, styler);
429  			}
430  		}
431  		if (!IsASpace(ch))
432  			visibleChars++;
433  		if (atEOL) {
434  			int lev = levelPrev;
435  			if (visibleChars == 0 &amp;&amp; foldCompact)
436  				lev |= SC_FOLDLEVELWHITEFLAG;
437  			if ((levelCurrent &gt; levelPrev) &amp;&amp; (visibleChars &gt; 0))
438  				lev |= SC_FOLDLEVELHEADERFLAG;
439  			if (lev != styler.LevelAt(lineCurrent)) {
440  				styler.SetLevel(lineCurrent, lev);
441  			}
442  			int newLineState = (styler.GetLineState(lineCurrent) &amp; ~stateFoldMaskAll) | lineFoldStateCurrent;
443  			styler.SetLineState(lineCurrent, newLineState);
444  			lineCurrent++;
445  			levelPrev = levelCurrent;
446  			visibleChars = 0;
447  		}
448  	}
449  	int lev = levelPrev;
450  	if (visibleChars == 0 &amp;&amp; foldCompact)
451  		lev |= SC_FOLDLEVELWHITEFLAG;
452  	styler.SetLevel(lineCurrent, lev);
453  }
454  static const char * const dataflexWordListDesc[] = {
455  	&quot;Keywords&quot;,
456  	&quot;Scope open&quot;,
457  	&quot;Scope close&quot;,
458  	&quot;Operators&quot;,
459  	0
460  };
461  LexerModule lmDataflex(SCLEX_DATAFLEX, ColouriseDataFlexDoc, &quot;dataflex&quot;, FoldDataFlexDoc, dataflexWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPascal.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexDataflex.cxx</div>
                </div>
                <div class="column column_space"><pre><code>249  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
250  		lineFoldStateCurrent |= stateFoldInPreprocessor;
251  		levelCurrent++;
252  	} else if (strcmp(s, &quot;endif&quot;) == 0 ||
</pre></code></div>
                <div class="column column_space"><pre><code>278  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
279  		lineFoldStateCurrent |= stateFoldInPreprocessor;
280  		levelCurrent++;
281  		iWordSize = iLen;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    