
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-spinlock_test_common.cc</h3>
            <pre><code>1  #include <cstdint>
2  #include <limits>
3  #include <random>
4  #include <thread>  
5  #include <type_traits>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/attributes.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/low_level_scheduling.h"
11  #include "absl/base/internal/scheduling_mode.h"
12  #include "absl/base/internal/spinlock.h"
13  #include "absl/base/internal/sysinfo.h"
14  #include "absl/base/macros.h"
15  #include "absl/synchronization/blocking_counter.h"
16  #include "absl/synchronization/notification.h"
17  constexpr uint32_t kNumThreads = 10;
18  constexpr int32_t kIters = 1000;
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace base_internal {
22  struct SpinLockTest {
23    static uint32_t EncodeWaitCycles(int64_t wait_start_time,
24                                     int64_t wait_end_time) {
25      return SpinLock::EncodeWaitCycles(wait_start_time, wait_end_time);
26    }
27    static int64_t DecodeWaitCycles(uint32_t lock_value) {
28      return SpinLock::DecodeWaitCycles(lock_value);
29    }
30  };
31  namespace {
32  static constexpr size_t kArrayLength = 10;
33  static uint32_t values[kArrayLength];
34  ABSL_CONST_INIT static SpinLock static_cooperative_spinlock(
35      absl::kConstInit, base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
36  ABSL_CONST_INIT static SpinLock static_noncooperative_spinlock(
37      absl::kConstInit, base_internal::SCHEDULE_KERNEL_ONLY);
38  static uint32_t Hash32(uint32_t a, uint32_t c) {
39    uint32_t b = 0x9e3779b9UL;  
40    a -= b; a -= c; a ^= (c >> 13);
41    b -= c; b -= a; b ^= (a << 8);
42    c -= a; c -= b; c ^= (b >> 13);
43    a -= b; a -= c; a ^= (c >> 12);
44    b -= c; b -= a; b ^= (a << 16);
45    c -= a; c -= b; c ^= (b >> 5);
46    a -= b; a -= c; a ^= (c >> 3);
47    b -= c; b -= a; b ^= (a << 10);
48    c -= a; c -= b; c ^= (b >> 15);
49    return c;
50  }
51  static void TestFunction(uint32_t thread_salt, SpinLock* spinlock) {
52    for (int i = 0; i < kIters; i++) {
53      SpinLockHolder h(spinlock);
54      for (size_t j = 0; j < kArrayLength; j++) {
55        const size_t index = (j + thread_salt) % kArrayLength;
56        values[index] = Hash32(values[index], thread_salt);
57        std::this_thread::yield();
58      }
59    }
60  }
61  static void ThreadedTest(SpinLock* spinlock) {
62    std::vector<std::thread> threads;
63    threads.reserve(kNumThreads);
64    for (uint32_t i = 0; i < kNumThreads; ++i) {
65      threads.push_back(std::thread(TestFunction, i, spinlock));
66    }
67    for (auto& thread : threads) {
68      thread.join();
69    }
70    SpinLockHolder h(spinlock);
71    for (size_t i = 1; i < kArrayLength; i++) {
72      EXPECT_EQ(values[0], values[i]);
73    }
74  }
75  #ifndef ABSL_HAVE_THREAD_SANITIZER
76  static_assert(std::is_trivially_destructible<SpinLock>(), "");
77  #endif
78  TEST(SpinLock, StackNonCooperativeDisablesScheduling) {
79    SpinLock spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
80    spinlock.Lock();
81    EXPECT_FALSE(base_internal::SchedulingGuard::ReschedulingIsAllowed());
82    spinlock.Unlock();
83  }
84  TEST(SpinLock, StaticNonCooperativeDisablesScheduling) {
85    static_noncooperative_spinlock.Lock();
86    EXPECT_FALSE(base_internal::SchedulingGuard::ReschedulingIsAllowed());
87    static_noncooperative_spinlock.Unlock();
88  }
89  TEST(SpinLock, WaitCyclesEncoding) {
90    const int kProfileTimestampShift = 7;
91    const int kLockwordReservedShift = 3;
92    const uint32_t kSpinLockSleeper = 8;
93    const int kMaxCyclesShift =
94      32 - kLockwordReservedShift + kProfileTimestampShift;
95    const int64_t kMaxCycles = (int64_t{1} << kMaxCyclesShift) - 1;
96    const uint32_t kLockwordReservedMask = (1 << kLockwordReservedShift) - 1;
97    const int64_t kProfileTimestampMask = (1 << kProfileTimestampShift) - 1;
98    std::default_random_engine generator;
99    std::uniform_int_distribution<int64_t> time_distribution(
100        0, std::numeric_limits<int64_t>::max() >> 3);
101    std::uniform_int_distribution<int64_t> cycle_distribution(0, kMaxCycles);
102    for (int i = 0; i < 100; i++) {
103      int64_t start_time = time_distribution(generator);
104      int64_t cycles = cycle_distribution(generator);
105      int64_t end_time = start_time + cycles;
106      uint32_t lock_value = SpinLockTest::EncodeWaitCycles(start_time, end_time);
107      EXPECT_EQ(0u, lock_value & kLockwordReservedMask);
108      int64_t decoded = SpinLockTest::DecodeWaitCycles(lock_value);
109      EXPECT_EQ(0, decoded & kProfileTimestampMask);
110      EXPECT_EQ(cycles & ~kProfileTimestampMask, decoded);
111    }
112    int64_t start_time = time_distribution(generator);
113    EXPECT_EQ(kSpinLockSleeper,
114              SpinLockTest::EncodeWaitCycles(start_time, start_time));
115    EXPECT_EQ(0, SpinLockTest::DecodeWaitCycles(0));
116    EXPECT_EQ(0, SpinLockTest::DecodeWaitCycles(kLockwordReservedMask));
117    EXPECT_EQ(kMaxCycles & ~kProfileTimestampMask,
118              SpinLockTest::DecodeWaitCycles(~kLockwordReservedMask));
119    int64_t sleeper_cycles =
120        kSpinLockSleeper << (kProfileTimestampShift - kLockwordReservedShift);
121    uint32_t sleeper_value =
122        SpinLockTest::EncodeWaitCycles(start_time, start_time + sleeper_cycles);
123    EXPECT_NE(sleeper_value, kSpinLockSleeper);
124    uint32_t max_value =
125      SpinLockTest::EncodeWaitCycles(start_time, start_time + kMaxCycles);
126    int64_t max_value_decoded = SpinLockTest::DecodeWaitCycles(max_value);
127    int64_t expected_max_value_decoded = kMaxCycles & ~kProfileTimestampMask;
128    EXPECT_EQ(expected_max_value_decoded, max_value_decoded);
129    const int64_t step = (1 << kProfileTimestampShift);
130    uint32_t after_max_value =
131      SpinLockTest::EncodeWaitCycles(start_time, start_time + kMaxCycles + step);
132    int64_t after_max_value_decoded =
133        SpinLockTest::DecodeWaitCycles(after_max_value);
134    EXPECT_EQ(expected_max_value_decoded, after_max_value_decoded);
135    uint32_t before_max_value = SpinLockTest::EncodeWaitCycles(
136        start_time, start_time + kMaxCycles - step);
137    int64_t before_max_value_decoded =
138        SpinLockTest::DecodeWaitCycles(before_max_value);
139    EXPECT_GT(expected_max_value_decoded, before_max_value_decoded);
140  }
141  TEST(SpinLockWithThreads, StackSpinLock) {
142    SpinLock spinlock;
143    ThreadedTest(&spinlock);
144  }
145  TEST(SpinLockWithThreads, StackCooperativeSpinLock) {
146    SpinLock spinlock(base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
147    ThreadedTest(&spinlock);
148  }
149  TEST(SpinLockWithThreads, StackNonCooperativeSpinLock) {
150    SpinLock spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
151    ThreadedTest(&spinlock);
152  }
153  TEST(SpinLockWithThreads, StaticCooperativeSpinLock) {
154    ThreadedTest(&static_cooperative_spinlock);
155  }
<span onclick='openModal()' class='match'>156  TEST(SpinLockWithThreads, StaticNonCooperativeSpinLock) {
157    ThreadedTest(&static_noncooperative_spinlock);
158  }
159  TEST(SpinLockWithThreads, DoesNotDeadlock) {
160    struct Helper {
</span>161      static void NotifyThenLock(Notification* locked, SpinLock* spinlock,
162                                 BlockingCounter* b) {
163        locked->WaitForNotification();  
164        b->DecrementCount();
165        SpinLockHolder l(spinlock);
166      }
167      static void LockThenWait(Notification* locked, SpinLock* spinlock,
168                               BlockingCounter* b) {
169        SpinLockHolder l(spinlock);
170        locked->Notify();
171        b->Wait();
172      }
173      static void DeadlockTest(SpinLock* spinlock, int num_spinners) {
174        Notification locked;
175        BlockingCounter counter(num_spinners);
176        std::vector<std::thread> threads;
177        threads.push_back(
178            std::thread(Helper::LockThenWait, &locked, spinlock, &counter));
179        for (int i = 0; i < num_spinners; ++i) {
180          threads.push_back(
181              std::thread(Helper::NotifyThenLock, &locked, spinlock, &counter));
182        }
183        for (auto& thread : threads) {
184          thread.join();
185        }
186      }
187    };
188    SpinLock stack_cooperative_spinlock(
189        base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
190    SpinLock stack_noncooperative_spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
191    Helper::DeadlockTest(&stack_cooperative_spinlock,
192                         base_internal::NumCPUs() * 2);
193    Helper::DeadlockTest(&stack_noncooperative_spinlock,
194                         base_internal::NumCPUs() * 2);
195    Helper::DeadlockTest(&static_cooperative_spinlock,
196                         base_internal::NumCPUs() * 2);
197    Helper::DeadlockTest(&static_noncooperative_spinlock,
198                         base_internal::NumCPUs() * 2);
199  }
200  }  
201  }  
202  ABSL_NAMESPACE_END
203  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-spinlock_test_common.cc</h3>
            <pre><code>1  #include <cstdint>
2  #include <limits>
3  #include <random>
4  #include <thread>  
5  #include <type_traits>
6  #include <vector>
7  #include "gtest/gtest.h"
8  #include "absl/base/attributes.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/low_level_scheduling.h"
11  #include "absl/base/internal/scheduling_mode.h"
12  #include "absl/base/internal/spinlock.h"
13  #include "absl/base/internal/sysinfo.h"
14  #include "absl/base/macros.h"
15  #include "absl/synchronization/blocking_counter.h"
16  #include "absl/synchronization/notification.h"
17  constexpr uint32_t kNumThreads = 10;
18  constexpr int32_t kIters = 1000;
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace base_internal {
22  struct SpinLockTest {
23    static uint32_t EncodeWaitCycles(int64_t wait_start_time,
24                                     int64_t wait_end_time) {
25      return SpinLock::EncodeWaitCycles(wait_start_time, wait_end_time);
26    }
27    static int64_t DecodeWaitCycles(uint32_t lock_value) {
28      return SpinLock::DecodeWaitCycles(lock_value);
29    }
30  };
31  namespace {
32  static constexpr size_t kArrayLength = 10;
33  static uint32_t values[kArrayLength];
34  ABSL_CONST_INIT static SpinLock static_cooperative_spinlock(
35      absl::kConstInit, base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
36  ABSL_CONST_INIT static SpinLock static_noncooperative_spinlock(
37      absl::kConstInit, base_internal::SCHEDULE_KERNEL_ONLY);
38  static uint32_t Hash32(uint32_t a, uint32_t c) {
39    uint32_t b = 0x9e3779b9UL;  
40    a -= b; a -= c; a ^= (c >> 13);
41    b -= c; b -= a; b ^= (a << 8);
42    c -= a; c -= b; c ^= (b >> 13);
43    a -= b; a -= c; a ^= (c >> 12);
44    b -= c; b -= a; b ^= (a << 16);
45    c -= a; c -= b; c ^= (b >> 5);
46    a -= b; a -= c; a ^= (c >> 3);
47    b -= c; b -= a; b ^= (a << 10);
48    c -= a; c -= b; c ^= (b >> 15);
49    return c;
50  }
51  static void TestFunction(uint32_t thread_salt, SpinLock* spinlock) {
52    for (int i = 0; i < kIters; i++) {
53      SpinLockHolder h(spinlock);
54      for (size_t j = 0; j < kArrayLength; j++) {
55        const size_t index = (j + thread_salt) % kArrayLength;
56        values[index] = Hash32(values[index], thread_salt);
57        std::this_thread::yield();
58      }
59    }
60  }
61  static void ThreadedTest(SpinLock* spinlock) {
62    std::vector<std::thread> threads;
63    threads.reserve(kNumThreads);
64    for (uint32_t i = 0; i < kNumThreads; ++i) {
65      threads.push_back(std::thread(TestFunction, i, spinlock));
66    }
67    for (auto& thread : threads) {
68      thread.join();
69    }
70    SpinLockHolder h(spinlock);
71    for (size_t i = 1; i < kArrayLength; i++) {
72      EXPECT_EQ(values[0], values[i]);
73    }
74  }
75  #ifndef ABSL_HAVE_THREAD_SANITIZER
76  static_assert(std::is_trivially_destructible<SpinLock>(), "");
77  #endif
78  TEST(SpinLock, StackNonCooperativeDisablesScheduling) {
79    SpinLock spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
80    spinlock.Lock();
81    EXPECT_FALSE(base_internal::SchedulingGuard::ReschedulingIsAllowed());
82    spinlock.Unlock();
83  }
84  TEST(SpinLock, StaticNonCooperativeDisablesScheduling) {
85    static_noncooperative_spinlock.Lock();
86    EXPECT_FALSE(base_internal::SchedulingGuard::ReschedulingIsAllowed());
87    static_noncooperative_spinlock.Unlock();
88  }
89  TEST(SpinLock, WaitCyclesEncoding) {
90    const int kProfileTimestampShift = 7;
91    const int kLockwordReservedShift = 3;
92    const uint32_t kSpinLockSleeper = 8;
93    const int kMaxCyclesShift =
94      32 - kLockwordReservedShift + kProfileTimestampShift;
95    const int64_t kMaxCycles = (int64_t{1} << kMaxCyclesShift) - 1;
96    const uint32_t kLockwordReservedMask = (1 << kLockwordReservedShift) - 1;
97    const int64_t kProfileTimestampMask = (1 << kProfileTimestampShift) - 1;
98    std::default_random_engine generator;
99    std::uniform_int_distribution<int64_t> time_distribution(
100        0, std::numeric_limits<int64_t>::max() >> 3);
101    std::uniform_int_distribution<int64_t> cycle_distribution(0, kMaxCycles);
102    for (int i = 0; i < 100; i++) {
103      int64_t start_time = time_distribution(generator);
104      int64_t cycles = cycle_distribution(generator);
105      int64_t end_time = start_time + cycles;
106      uint32_t lock_value = SpinLockTest::EncodeWaitCycles(start_time, end_time);
107      EXPECT_EQ(0u, lock_value & kLockwordReservedMask);
108      int64_t decoded = SpinLockTest::DecodeWaitCycles(lock_value);
109      EXPECT_EQ(0, decoded & kProfileTimestampMask);
110      EXPECT_EQ(cycles & ~kProfileTimestampMask, decoded);
111    }
112    int64_t start_time = time_distribution(generator);
113    EXPECT_EQ(kSpinLockSleeper,
114              SpinLockTest::EncodeWaitCycles(start_time, start_time));
115    EXPECT_EQ(0, SpinLockTest::DecodeWaitCycles(0));
116    EXPECT_EQ(0, SpinLockTest::DecodeWaitCycles(kLockwordReservedMask));
117    EXPECT_EQ(kMaxCycles & ~kProfileTimestampMask,
118              SpinLockTest::DecodeWaitCycles(~kLockwordReservedMask));
119    int64_t sleeper_cycles =
120        kSpinLockSleeper << (kProfileTimestampShift - kLockwordReservedShift);
121    uint32_t sleeper_value =
122        SpinLockTest::EncodeWaitCycles(start_time, start_time + sleeper_cycles);
123    EXPECT_NE(sleeper_value, kSpinLockSleeper);
124    uint32_t max_value =
125      SpinLockTest::EncodeWaitCycles(start_time, start_time + kMaxCycles);
126    int64_t max_value_decoded = SpinLockTest::DecodeWaitCycles(max_value);
127    int64_t expected_max_value_decoded = kMaxCycles & ~kProfileTimestampMask;
128    EXPECT_EQ(expected_max_value_decoded, max_value_decoded);
129    const int64_t step = (1 << kProfileTimestampShift);
130    uint32_t after_max_value =
131      SpinLockTest::EncodeWaitCycles(start_time, start_time + kMaxCycles + step);
132    int64_t after_max_value_decoded =
133        SpinLockTest::DecodeWaitCycles(after_max_value);
134    EXPECT_EQ(expected_max_value_decoded, after_max_value_decoded);
135    uint32_t before_max_value = SpinLockTest::EncodeWaitCycles(
136        start_time, start_time + kMaxCycles - step);
137    int64_t before_max_value_decoded =
138        SpinLockTest::DecodeWaitCycles(before_max_value);
139    EXPECT_GT(expected_max_value_decoded, before_max_value_decoded);
140  }
141  TEST(SpinLockWithThreads, StackSpinLock) {
142    SpinLock spinlock;
143    ThreadedTest(&spinlock);
144  }
145  TEST(SpinLockWithThreads, StackCooperativeSpinLock) {
146    SpinLock spinlock(base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
147    ThreadedTest(&spinlock);
148  }
149  TEST(SpinLockWithThreads, StackNonCooperativeSpinLock) {
150    SpinLock spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
151    ThreadedTest(&spinlock);
152  }
153  TEST(SpinLockWithThreads, StaticCooperativeSpinLock) {
154    ThreadedTest(&static_cooperative_spinlock);
155  }
<span onclick='openModal()' class='match'>156  TEST(SpinLockWithThreads, StaticNonCooperativeSpinLock) {
157    ThreadedTest(&static_noncooperative_spinlock);
158  }
159  TEST(SpinLockWithThreads, DoesNotDeadlock) {
160    struct Helper {
</span>161      static void NotifyThenLock(Notification* locked, SpinLock* spinlock,
162                                 BlockingCounter* b) {
163        locked->WaitForNotification();  
164        b->DecrementCount();
165        SpinLockHolder l(spinlock);
166      }
167      static void LockThenWait(Notification* locked, SpinLock* spinlock,
168                               BlockingCounter* b) {
169        SpinLockHolder l(spinlock);
170        locked->Notify();
171        b->Wait();
172      }
173      static void DeadlockTest(SpinLock* spinlock, int num_spinners) {
174        Notification locked;
175        BlockingCounter counter(num_spinners);
176        std::vector<std::thread> threads;
177        threads.push_back(
178            std::thread(Helper::LockThenWait, &locked, spinlock, &counter));
179        for (int i = 0; i < num_spinners; ++i) {
180          threads.push_back(
181              std::thread(Helper::NotifyThenLock, &locked, spinlock, &counter));
182        }
183        for (auto& thread : threads) {
184          thread.join();
185        }
186      }
187    };
188    SpinLock stack_cooperative_spinlock(
189        base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL);
190    SpinLock stack_noncooperative_spinlock(base_internal::SCHEDULE_KERNEL_ONLY);
191    Helper::DeadlockTest(&stack_cooperative_spinlock,
192                         base_internal::NumCPUs() * 2);
193    Helper::DeadlockTest(&stack_noncooperative_spinlock,
194                         base_internal::NumCPUs() * 2);
195    Helper::DeadlockTest(&static_cooperative_spinlock,
196                         base_internal::NumCPUs() * 2);
197    Helper::DeadlockTest(&static_noncooperative_spinlock,
198                         base_internal::NumCPUs() * 2);
199  }
200  }  
201  }  
202  ABSL_NAMESPACE_END
203  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-spinlock_test_common.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-spinlock_test_common.cc</div>
                </div>
                <div class="column column_space"><pre><code>156  TEST(SpinLockWithThreads, StaticNonCooperativeSpinLock) {
157    ThreadedTest(&static_noncooperative_spinlock);
158  }
159  TEST(SpinLockWithThreads, DoesNotDeadlock) {
160    struct Helper {
</pre></code></div>
                <div class="column column_space"><pre><code>156  TEST(SpinLockWithThreads, StaticNonCooperativeSpinLock) {
157    ThreadedTest(&static_noncooperative_spinlock);
158  }
159  TEST(SpinLockWithThreads, DoesNotDeadlock) {
160    struct Helper {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    