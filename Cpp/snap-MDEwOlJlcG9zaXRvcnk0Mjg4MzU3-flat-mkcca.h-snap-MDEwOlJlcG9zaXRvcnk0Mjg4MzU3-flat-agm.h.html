
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.492635024549918%, Tokens: 18</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mkcca.h</h3>
            <pre><code>1  #ifndef MKCCA_H
2  #define MKCCA_H
3  #include "mine.h"
4  class TMKCCASemSpace: TSemSpace {
5  private:
6      static bool IsReg;
7      static bool MkReg(){return TSemSpace::Reg(TTypeNm<TMKCCASemSpace>(), &Load);}
8  private:
9      static void ConjugGrad(const TMatrix& Matrix, const TFltV& b, TFltV& x, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TFltV& CGpom1, TFltV& CGr, TFltV& CGp, TFltV& CGa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z,
10          const int& CGMxIter = 20, const double& RelErr = TFlt::EpsHalf,
11          const TFltV& x0 = TFltV());
12  	static void ConjugGrad2(const TMatrix& Matrix, const TFltV& b, TFltV& x, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TFltV& CGpom1, TFltV& CGr, TFltV& CGp, TFltV& CGa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z,
13          const int& CGMxIter = 20, const double& RelErr = TFlt::EpsHalf,
14          const TFltV& x0 = TFltV());
<span onclick='openModal()' class='match'>15      static void CalcKCCA(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
16          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
17          TVec<TVec<TFltV> >& AlphaVV);
18  	static void CalcKCCA2(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
19          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
</span>20          TVec<TVec<TFltV> >& AlphaVV);
21  	static void CenterMultiply3(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z);
22  	static void CenterMultiply2(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones,const int& LangN,  const double& Kapa, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1, TFltV& CM2z);
23  	static void CenterMultiply(const TMatrix& Matrix, const TFltV& x,TFltV& y, const TFltVV& Vekt, const TFltV& Koef, const TFltV& Ones, const int& LangN, TVec<TFltV>& CMpom, TFltV& CMpom2, TFltV& CMy1);
24  private:
25  public:
26  	TMKCCASemSpace();
27      static PSemSpace New() {
28          return new TMKCCASemSpace(); }
29      TMKCCASemSpace(TSIn &SIn): TSemSpace(SIn) { }
30      static PSemSpace Load(TSIn &SIn) { return new TMKCCASemSpace(SIn); }
31      void Save(TSOut &SOut) const { }
32      PBowDocBs Project(PBowDocBs BowDocBs, 
33          PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV, 
34          const int& Dim, const bool& Normalize) { return TBowDocBs::New(); }
35      PBowSpV ProjectSpV(PBowSpV SpV, const int& Dim, 
36          const bool& Normalize) { return TBowSpV::New(); }
37      void ProjectSpV(PBowSpV SpV, const int& Dim, 
38          const bool& Normalize, TIntFltPrV& ProjSpV) { }
39      void GetBasisV(const int& VecN, TFltV& VecV) { }
40      int GetDim() { return 0; }
41      static void Calc(const TVec<PBowDocBs>& BowDocBsV, TVec<PSemSpace>& SemSpaceV, const TStrV& InBowFNmV, const int& trainsize,
42          const int& Dims = 100, const double& Kapa = 0.5, const int& CGMxIter = 20,  const int& HorstMxIter = 20);
43  };
44  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.h</h3>
            <pre><code>1  #ifndef snap_agm_h
2  #define snap_agm_h
3  #include "Snap.h"
4  class TAGM {
5  public:
6    static void RndConnectInsideCommunity(PUNGraph& Graph, const TIntV& CmtyV, const double& Prob, TRnd& Rnd);
7    static PUNGraph GenAGM(TVec<TIntV >& CmtyVV, const double& DensityCoef, const double& ScaleCoef, TRnd& Rnd=TInt::Rnd);
8    static PUNGraph GenAGM(TVec<TIntV>& CmtyVV, const double& DensityCoef, const int TargetEdges, TRnd& Rnd);
9    static PUNGraph GenAGM(TVec<TIntV>& CmtyVV, const TFltV& CProbV, TRnd& Rnd, const double PNoCom = -1.0);
10  };
11  class TAGMUtil {
12  public:
13    static void GenPLSeq(TIntV& SzSeq,const int& SeqLen, const double& Alpha, TRnd& Rnd, const int& Min, const int& Max);
14    static void ConnectCmtyVV(TVec<TIntV>& CmtyVV, const TIntPrV& CIDSzPrV, const TIntPrV& NIDMemPrV, TRnd& Rnd);
<span onclick='openModal()' class='match'>15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
16    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const TIntV& NIDV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
</span>17    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
18    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV);
19    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntV>& CmtyVV, const TIntV& NIDV);
20    static void GetNodeMembership(TIntH& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
21    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const TVec<TIntSet>& CmtyVV);
22    static void GetNodeMembership(THash<TInt,TIntSet >& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
23    static void GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const THash<TInt,TIntV >& CmtyVH);
24    static void GetNodeMembership(THash<TInt,TIntV >& NIDComVH, const TVec<TIntV >& CmtyVV);
25    static void LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV);
26    static void LoadCmtyVV(const TStr& InFNm, TVec<TIntV>& CmtyVV, TStrHash<TInt>& StrToNIdH, const int BeginCol, const int MinSz = 3, const TSsFmt Sep = ssfTabSep);
27    static void DumpCmtyVV(const TStr& OutFNm, const TVec<TIntV>& CmtyVV);
28    static void DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH);
29    static int TotalMemberships(const TVec<TIntV>& CmtyVV);
30    static void RewireCmtyVV(const TVec<TIntV>& CmtyVVIn, TVec<TIntV>& CmtyVVOut, TRnd& Rnd);
31    static void RewireCmtyNID(THash<TInt,TIntV >& CmtyVH, TRnd& Rnd);
32    static int Intersection(const TIntV& C1, const TIntV& C2);
33    static void GetIntersection(const THashSet<TInt>& A, const THashSet<TInt>& B, THashSet<TInt>& C);
34    static int Intersection(const THashSet<TInt>& A, const THashSet<TInt>& B);
35    static double GetConductance(const PUNGraph& Graph, const TIntSet& CmtyS, const int Edges);
36    static void GetNbhCom(const PUNGraph& Graph, const int NID, TIntSet& NBCmtyS);
37    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz) {
38      THash<TInt, TStr> TmpH;
39      SaveGephi(OutFNm, G, CmtyVVAtr, MaxSz, MinSz, TmpH);
40    }
41    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz, const THash<TInt, TStr>& NIDNameH) { 
42      THash<TInt, TIntTr> TmpH; 
43      SaveGephi(OutFNm, G, CmtyVVAtr, MaxSz, MinSz, NIDNameH, TmpH);
44    }
45    static void SaveGephi(const TStr& OutFNm, const PUNGraph& G, const TVec<TIntV >& CmtyVVAtr, const double MaxSz, const double MinSz, const THash<TInt, TStr>& NIDNameH, const THash<TInt, TIntTr >& NIDColorH);
46    static void SaveBipartiteGephi(const TStr& OutFNm, const TIntV& NIDV, const TVec<TIntV>& CmtyVV, const double MaxSz, const double MinSz, const TIntStrH& NIDNameH, const THash<TInt, TIntTr >& NIDColorH, const THash<TInt, TIntTr >& CIDColorH);
47    static int FindComsByAGM(const PUNGraph& Graph, const int InitComs, const int MaxIter, const int RndSeed, const double RegGap, const double PNoCom = 0.0, const TStr PltFPrx = TStr());
48    template <class PGraph>
49    static PGraph LoadEdgeListStr(const TStr& InFNm, TIntStrH& NIDNameH, const int& SrcColId = 0, const int& DstColId = 1, const TSsFmt SsFmt = ssfTabSep) {
50      TSsParser Ss(InFNm, SsFmt);
51      PGraph Graph = PGraph::TObj::New();
52      TStrHash<TInt> StrSet(Mega(1), true);
53      while (Ss.Next()) {
54        const int SrcNId = StrSet.AddKey(Ss[SrcColId]);
55        const int DstNId = StrSet.AddKey(Ss[DstColId]);
56        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
57        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
58        Graph->AddEdge(SrcNId, DstNId);
59      }
60      NIDNameH.Gen(StrSet.Len());
61      for (int s = 0; s < StrSet.Len(); s++) { NIDNameH.AddDat(s, StrSet.GetKey(s)); }
62      IAssert(NIDNameH.Len() == Graph->GetNodes());
63      Graph->Defrag();
64      return Graph;
65    }
66    template <class PGraph>
67    static PGraph LoadEdgeListStr(const TStr& InFNm, TStrHash<TInt>& NodeNameH, const int& SrcColId = 0, const int& DstColId = 1, const TSsFmt SsFmt = ssfTabSep) {
68      TSsParser Ss(InFNm, SsFmt);
69      PGraph Graph = PGraph::TObj::New();
70      TStrHash<TInt> StrSet(Mega(1), true);
71      while (Ss.Next()) {
72        const int SrcNId = StrSet.AddKey(Ss[SrcColId]);
73        const int DstNId = StrSet.AddKey(Ss[DstColId]);
74        if (! Graph->IsNode(SrcNId)) { Graph->AddNode(SrcNId); }
75        if (! Graph->IsNode(DstNId)) { Graph->AddNode(DstNId); }
76        Graph->AddEdge(SrcNId, DstNId);
77      }
78      NodeNameH = StrSet;
79      NodeNameH.Pack();
80      Graph->Defrag();
81      return Graph;
82    }
83    template<class PGraph>
84    static void GVizComGraph(const PGraph& Graph,const TVec<TIntV >& CmtyVV, const TStr& OutFNm, const TStr& Desc = TStr()){
85      TStrV Colors = TStrV::GetV("red","blue","green","pink","cyan");
86      TStrV Shapes = TStrV::GetV("ellipse","triangle","square","pentagon","hexagon");
87      THash<TInt,TIntV> NIDComVH;
88      GetNodeMembership(NIDComVH,CmtyVV);
89      const TStr Ext = OutFNm.GetFExt();
90      const TStr GraphFNm = OutFNm.GetSubStr(0, OutFNm.Len() - Ext.Len()) + "dot";
91      const bool IsDir = HasGraphFlag(typename PGraph::TObj, gfDirected);
92      FILE *F = fopen(GraphFNm.CStr(), "wt");
93      if (! Desc.Empty()) fprintf(F, "&bsol;*****\n%s\n*****/\n\n", Desc.CStr());
94      if (IsDir) { fprintf(F, "digraph G {\n"); } else { fprintf(F, "graph G {\n"); }
95      fprintf(F, "  graph [splines=false overlap=false]\n"); 
96      fprintf(F, "  node  [width=0.3, height=0.3]\n");
97      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
98        int NID = NI.GetId();
99        TIntV& CIDV = NIDComVH.GetDat(NID);
100        IAssert(CIDV.Len()>0);
101        TStr ShapeNm = Shapes[(CIDV.Len()-1) % Shapes.Len()];
102        TStr ColorNm = Colors[CIDV[0] % Colors.Len()];
103        TStr NodeComLabel = TStr::Fmt("%d(",NID);
104        for(int i=0;i<CIDV.Len();i++) {
105          TStr TmpStr = TStr::Fmt("%d",int(CIDV[i]));
106          NodeComLabel += TmpStr;
107          if(i<CIDV.Len()-1){NodeComLabel+=",";}
108        }
109        NodeComLabel += ")";
110        fprintf(F, "  %d [style=filled, shape=\"%s\" fillcolor=\"%s\" label=\"%s\"];\n", NI.GetId(), ShapeNm.CStr(),ColorNm.CStr(), NodeComLabel.CStr()); 
111      }
112      for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
113        if (NI.GetOutDeg()==0 && NI.GetInDeg()==0  ) { 
114          fprintf(F, "%d;\n", NI.GetId()); }
115        else {
116          for (int e = 0; e < NI.GetOutDeg(); e++) {
117            if (! IsDir && NI.GetId() > NI.GetOutNId(e)) { continue; }
118            fprintf(F, "  %d %s %d;\n", NI.GetId(), IsDir?"->":"--", NI.GetOutNId(e)); 
119          }
120        }
121      }
122      if (! Desc.Empty()) {
123        fprintf(F, "  label = \"\\n%s\\n\";", Desc.CStr());
124        fprintf(F, "  fontsize=24;\n");
125      }
126      fprintf(F, "}\n");
127      fclose(F);
128      TSnap::TSnapDetail::GVizDoLayout(GraphFNm, OutFNm, gvlNeato);
129    }
130  };
131  class TLogRegPredict;
132  typedef TPt<TLogRegPredict> PLogRegPredict;
133  class TLogRegFit {
134  private:
135    TVec<TFltV> X;
136    TFltV Y;
137    TFltV Theta;
138    int M; 
139  public:
140    TLogRegFit() {}
141    ~TLogRegFit() {}
142    PLogRegPredict CalcLogRegGradient(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm = TStr(), const double& ChangeEps = 0.01, const int& MaxStep = 200, const bool InterceptPt = false);
143    PLogRegPredict CalcLogRegNewton(const TVec<TFltV>& XPt, const TFltV& yPt, const TStr& PlotNm = TStr(), const double& ChangeEps = 0.01, const int& MaxStep = 200, const bool InterceptPt = false);
144    int MLEGradient(const double& ChangeEps, const int& MaxStep, const TStr PlotNm);
145    int MLENewton(const double& ChangeEps, const int& MaxStep, const TStr PlotNm);
146    double GetStepSizeByLineSearch(const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta);
147    double Likelihood(const TFltV& NewTheta);
148    double Likelihood() { return Likelihood(Theta); }
149    void Gradient(TFltV& GradV);
150    void Hessian(TFltVV& HVV);
151    void GetNewtonStep(TFltVV& HVV, const TFltV& GradV, TFltV& DeltaLV);
152  };
153  class TLogRegPredict {
154  private: 
155      TCRef CRef;
156  private:
157      TFltV Theta;
158  public:
159      TLogRegPredict(const TFltV& _bb): Theta(_bb) { };
160      TLogRegPredict(TSIn& SIn) { Theta.Load(SIn); };
161      static PLogRegPredict Load(TSIn& SIn) { return new TLogRegPredict(SIn); };
162      void Save(TSOut& SOut) const { Theta.Save(SOut); };
163      UndefDefaultCopyAssign(TLogRegPredict);
164  public:    
165    static void GetCfy(const TVec<TFltV>& X, TFltV& OutV, const TFltV& NewTheta);
166    static double GetCfy(const TFltV& AttrV, const TFltV& NewTheta);
167    double GetCfy(const TFltV& AttrV) { return GetCfy(AttrV, Theta); }
168    void GetTheta(TFltV& _Theta) { _Theta = Theta; }
169    void GetCfy(const TVec<TFltV>& X, TFltV& OutV) { GetCfy(X, OutV, Theta); }
170    void PrintTheta() { for (int t = 0; t < Theta.Len(); t++) { printf("Theta[%d] = %f\n", t, Theta[t].Val); } }
171    friend class TPt<TLogRegPredict>;
172  };
173  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mkcca.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agm.h</div>
                <div class="column column_space"><pre><code>15      static void CalcKCCA(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
16          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
17          TVec<TVec<TFltV> >& AlphaVV);
18  	static void CalcKCCA2(const TVec<TBowMatrix>& BowMatrixV, const int& Dims, 
19          const double& Kapa, const int& CGMxIter, const int& HorstMxIter, 
</pre></code></div>
                <div class="column column_space"><pre><code>15    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const PUNGraph& Graph, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
16    static void GenCmtyVVFromPL(TVec<TIntV>& CmtyVV, const TIntV& NIDV, const int& Nodes, const int& Coms, const double& ComSzAlpha, const double& MemAlpha, const int& MinSz, const int& MaxSz, const int& MinK, const int& MaxK, TRnd& Rnd);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    