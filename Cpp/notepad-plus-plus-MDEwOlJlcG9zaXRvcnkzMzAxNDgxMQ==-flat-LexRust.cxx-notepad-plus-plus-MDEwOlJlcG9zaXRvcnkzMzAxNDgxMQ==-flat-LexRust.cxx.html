
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "PropSetSimple.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  static const int NUM_RUST_KEYWORD_LISTS = 7;
26  static const int MAX_RUST_IDENT_CHARS = 1023;
27  static bool IsStreamCommentStyle(int style) {
28  	return style == SCE_RUST_COMMENTBLOCK ||
29  		   style == SCE_RUST_COMMENTBLOCKDOC;
30  }
31  struct OptionsRust {
32  	bool fold;
33  	bool foldSyntaxBased;
34  	bool foldComment;
35  	bool foldCommentMultiline;
36  	bool foldCommentExplicit;
37  	std::string foldExplicitStart;
38  	std::string foldExplicitEnd;
39  	bool foldExplicitAnywhere;
40  	bool foldCompact;
41  	int  foldAtElseInt;
42  	bool foldAtElse;
43  	OptionsRust() {
44  		fold = false;
45  		foldSyntaxBased = true;
46  		foldComment = false;
47  		foldCommentMultiline = true;
48  		foldCommentExplicit = true;
49  		foldExplicitStart = "";
50  		foldExplicitEnd   = "";
51  		foldExplicitAnywhere = false;
52  		foldCompact = true;
53  		foldAtElseInt = -1;
54  		foldAtElse = false;
55  	}
56  };
57  static const char * const rustWordLists[NUM_RUST_KEYWORD_LISTS + 1] = {
58  			"Primary keywords and identifiers",
59  			"Built in types",
60  			"Other keywords",
61  			"Keywords 4",
62  			"Keywords 5",
63  			"Keywords 6",
64  			"Keywords 7",
65  			0,
66  		};
67  struct OptionSetRust : public OptionSet<OptionsRust> {
68  	OptionSetRust() {
69  		DefineProperty("fold", &OptionsRust::fold);
70  		DefineProperty("fold.comment", &OptionsRust::foldComment);
71  		DefineProperty("fold.compact", &OptionsRust::foldCompact);
72  		DefineProperty("fold.at.else", &OptionsRust::foldAtElse);
73  		DefineProperty("fold.rust.syntax.based", &OptionsRust::foldSyntaxBased,
74  			"Set this property to 0 to disable syntax based folding.");
75  		DefineProperty("fold.rust.comment.multiline", &OptionsRust::foldCommentMultiline,
76  			"Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
77  		DefineProperty("fold.rust.comment.explicit", &OptionsRust::foldCommentExplicit,
78  			"Set this property to 0 to disable folding explicit fold points when fold.comment=1.");
79  		DefineProperty("fold.rust.explicit.start", &OptionsRust::foldExplicitStart,
80  			"The string to use for explicit fold start points, replacing the standard 
81  		DefineProperty("fold.rust.explicit.end", &OptionsRust::foldExplicitEnd,
82  			"The string to use for explicit fold end points, replacing the standard 
83  		DefineProperty("fold.rust.explicit.anywhere", &OptionsRust::foldExplicitAnywhere,
84  			"Set this property to 1 to enable explicit fold points anywhere, not just in line comments.");
85  		DefineProperty("lexer.rust.fold.at.else", &OptionsRust::foldAtElseInt,
86  			"This option enables Rust folding on a \"} else {\" line of an if statement.");
87  		DefineWordListSets(rustWordLists);
88  	}
89  };
90  class LexerRust : public DefaultLexer {
91  	WordList keywords[NUM_RUST_KEYWORD_LISTS];
92  	OptionsRust options;
93  	OptionSetRust osRust;
94  public:
95  	LexerRust() : DefaultLexer("rust", SCLEX_RUST) {
96  	}
97  	virtual ~LexerRust() {
98  	}
99  	void SCI_METHOD Release() override {
100  		delete this;
101  	}
102  	int SCI_METHOD Version() const override {
103  		return lvRelease5;
104  	}
105  	const char * SCI_METHOD PropertyNames() override {
106  		return osRust.PropertyNames();
107  	}
108  	int SCI_METHOD PropertyType(const char *name) override {
109  		return osRust.PropertyType(name);
110  	}
111  	const char * SCI_METHOD DescribeProperty(const char *name) override {
112  		return osRust.DescribeProperty(name);
113  	}
114  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
115  	const char * SCI_METHOD PropertyGet(const char *key) override {
116  		return osRust.PropertyGet(key);
117  	}
118  	const char * SCI_METHOD DescribeWordListSets() override {
119  		return osRust.DescribeWordListSets();
120  	}
121  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
122  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
123  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
124  	void * SCI_METHOD PrivateCall(int, void *) override {
125  		return 0;
126  	}
127  	static ILexer5 *LexerFactoryRust() {
128  		return new LexerRust();
129  	}
130  };
131  Sci_Position SCI_METHOD LexerRust::PropertySet(const char *key, const char *val) {
132  	if (osRust.PropertySet(&options, key, val)) {
133  		return 0;
134  	}
135  	return -1;
136  }
137  Sci_Position SCI_METHOD LexerRust::WordListSet(int n, const char *wl) {
138  	Sci_Position firstModification = -1;
139  	if (n < NUM_RUST_KEYWORD_LISTS) {
140  		WordList *wordListN = &keywords[n];
141  		WordList wlNew;
142  		wlNew.Set(wl);
143  		if (*wordListN != wlNew) {
144  			wordListN->Set(wl);
145  			firstModification = 0;
146  		}
147  	}
148  	return firstModification;
149  }
150  static bool IsWhitespace(int c) {
151      return c == ' ' || c == '\t' || c == '\r' || c == '\n';
152  }
153  static bool IsIdentifierStart(int ch) {
154  	return (IsASCII(ch) && (isalpha(ch) || ch == '_')) || !IsASCII(ch);
155  }
156  static bool IsIdentifierContinue(int ch) {
157  	return (IsASCII(ch) && (isalnum(ch) || ch == '_')) || !IsASCII(ch);
158  }
159  static void ScanWhitespace(Accessor& styler, Sci_Position& pos, Sci_Position max) {
160  	while (IsWhitespace(styler.SafeGetCharAt(pos, '\0')) && pos < max) {
161  		if (pos == styler.LineEnd(styler.GetLine(pos)))
162  			styler.SetLineState(styler.GetLine(pos), 0);
163  		pos++;
164  	}
165  	styler.ColourTo(pos-1, SCE_RUST_DEFAULT);
166  }
167  static void GrabString(char* s, Accessor& styler, Sci_Position start, Sci_Position len) {
168  	for (Sci_Position ii = 0; ii < len; ii++)
169  		s[ii] = styler[ii + start];
170  	s[len] = '\0';
171  }
172  static void ScanIdentifier(Accessor& styler, Sci_Position& pos, WordList *keywords) {
173  	Sci_Position start = pos;
174  	while (IsIdentifierContinue(styler.SafeGetCharAt(pos, '\0')))
175  		pos++;
176  	if (styler.SafeGetCharAt(pos, '\0') == '!') {
177  		pos++;
178  		styler.ColourTo(pos - 1, SCE_RUST_MACRO);
179  	} else {
180  		char s[MAX_RUST_IDENT_CHARS + 1];
181  		Sci_Position len = pos - start;
182  		len = len > MAX_RUST_IDENT_CHARS ? MAX_RUST_IDENT_CHARS : len;
183  		GrabString(s, styler, start, len);
184  		bool keyword = false;
185  		for (int ii = 0; ii < NUM_RUST_KEYWORD_LISTS; ii++) {
186  			if (keywords[ii].InList(s)) {
187  				styler.ColourTo(pos - 1, SCE_RUST_WORD + ii);
188  				keyword = true;
189  				break;
190  			}
191  		}
192  		if (!keyword) {
193  			styler.ColourTo(pos - 1, SCE_RUST_IDENTIFIER);
194  		}
195  	}
196  }
197  static bool ScanDigits(Accessor& styler, Sci_Position& pos, int base) {
198  	Sci_Position old_pos = pos;
199  	for (;;) {
200  		int c = styler.SafeGetCharAt(pos, '\0');
201  		if (IsADigit(c, base) || c == '_')
202  			pos++;
203  		else
204  			break;
205  	}
206  	return old_pos != pos;
207  }
208  static void ScanNumber(Accessor& styler, Sci_Position& pos) {
209  	int base = 10;
210  	int c = styler.SafeGetCharAt(pos, '\0');
211  	int n = styler.SafeGetCharAt(pos + 1, '\0');
212  	bool error = false;
213  	if (c == '0' && n == 'x') {
214  		pos += 2;
215  		base = 16;
216  	} else if (c == '0' && n == 'b') {
217  		pos += 2;
218  		base = 2;
219  	} else if (c == '0' && n == 'o') {
220  		pos += 2;
221  		base = 8;
222  	}
223  	error |= !ScanDigits(styler, pos, base);
224  	c = styler.SafeGetCharAt(pos, '\0');
225  	if (c == 'u' || c == 'i') {
226  		pos++;
227  		c = styler.SafeGetCharAt(pos, '\0');
228  		n = styler.SafeGetCharAt(pos + 1, '\0');
229  		if (c == '8') {
230  			pos++;
231  		} else if (c == '1' && n == '6') {
232  			pos += 2;
233  		} else if (c == '3' && n == '2') {
234  			pos += 2;
235  		} else if (c == '6' && n == '4') {
236  			pos += 2;
237  		} else if (styler.Match(pos, "128")) {
238  			pos += 3;
239  		} else if (styler.Match(pos, "size")) {
240  			pos += 4;
241  		} else {
242  			error = true;
243  		}
244  	} else if (!error) {
245  		n = styler.SafeGetCharAt(pos + 1, '\0');
246  		if (c == '.' && !(IsIdentifierStart(n) || n == '.')) {
247  			error |= base != 10;
248  			pos++;
249  			ScanDigits(styler, pos, 10);
250  		}
251  		c = styler.SafeGetCharAt(pos, '\0');
252  		if (c == 'e' || c == 'E') {
253  			error |= base != 10;
254  			pos++;
255  			c = styler.SafeGetCharAt(pos, '\0');
256  			if (c == '-' || c == '+')
257  				pos++;
258  			error |= !ScanDigits(styler, pos, 10);
259  		}
260  		c = styler.SafeGetCharAt(pos, '\0');
261  		if (c == 'f') {
262  			error |= base != 10;
263  			pos++;
264  			c = styler.SafeGetCharAt(pos, '\0');
265  			n = styler.SafeGetCharAt(pos + 1, '\0');
266  			if (c == '3' && n == '2') {
267  				pos += 2;
268  			} else if (c == '6' && n == '4') {
269  				pos += 2;
270  			} else {
271  				error = true;
272  			}
273  		}
274  	}
275  	if (error)
276  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
277  	else
278  		styler.ColourTo(pos - 1, SCE_RUST_NUMBER);
279  }
280  static bool IsOneCharOperator(int c) {
281  	return c == ';' || c == ',' || c == '(' || c == ')'
282  	    || c == '{' || c == '}' || c == '[' || c == ']'
283  	    || c == '@' || c == '#' || c == '~' || c == '+'
284  	    || c == '*' || c == '/' || c == '^' || c == '%'
285  	    || c == '.' || c == ':' || c == '!' || c == '<'
286  	    || c == '>' || c == '=' || c == '-' || c == '&'
287  	    || c == '|' || c == '$' || c == '?';
288  }
289  static bool IsTwoCharOperator(int c, int n) {
290  	return (c == '.' && n == '.') || (c == ':' && n == ':')
291  	    || (c == '!' && n == '=') || (c == '<' && n == '<')
292  	    || (c == '<' && n == '=') || (c == '>' && n == '>')
293  	    || (c == '>' && n == '=') || (c == '=' && n == '=')
294  	    || (c == '=' && n == '>') || (c == '-' && n == '>')
295  	    || (c == '&' && n == '&') || (c == '|' && n == '|')
296  	    || (c == '-' && n == '=') || (c == '&' && n == '=')
297  	    || (c == '|' && n == '=') || (c == '+' && n == '=')
298  	    || (c == '*' && n == '=') || (c == '/' && n == '=')
299  	    || (c == '^' && n == '=') || (c == '%' && n == '=');
300  }
301  static bool IsThreeCharOperator(int c, int n, int n2) {
302  	return (c == '<' && n == '<' && n2 == '=')
303  	    || (c == '>' && n == '>' && n2 == '=');
304  }
305  static bool IsValidCharacterEscape(int c) {
306  	return c == 'n'  || c == 'r' || c == 't' || c == '\\'
307  	    || c == '\'' || c == '"' || c == '0';
308  }
309  static bool IsValidStringEscape(int c) {
310  	return IsValidCharacterEscape(c) || c == '\n' || c == '\r';
311  }
312  static bool ScanNumericEscape(Accessor &styler, Sci_Position& pos, Sci_Position num_digits, bool stop_asap) {
313  	for (;;) {
314  		int c = styler.SafeGetCharAt(pos, '\0');
315  		if (!IsADigit(c, 16))
316  			break;
317  		num_digits--;
318  		pos++;
319  		if (num_digits == 0 && stop_asap)
320  			return true;
321  	}
322  	if (num_digits == 0) {
323  		return true;
324  	} else {
325  		return false;
326  	}
327  }
328  static void ScanCharacterLiteralOrLifetime(Accessor &styler, Sci_Position& pos, bool ascii_only) {
329  	pos++;
330  	int c = styler.SafeGetCharAt(pos, '\0');
331  	int n = styler.SafeGetCharAt(pos + 1, '\0');
332  	bool done = false;
333  	bool valid_lifetime = !ascii_only && IsIdentifierStart(c);
334  	bool valid_char = true;
335  	bool first = true;
336  	while (!done) {
337  		switch (c) {
338  			case '\\':
339  				done = true;
340  				if (IsValidCharacterEscape(n)) {
341  					pos += 2;
342  				} else if (n == 'x') {
343  					pos += 2;
344  					valid_char = ScanNumericEscape(styler, pos, 2, false);
345  				} else if (n == 'u' && !ascii_only) {
346  					pos += 2;
347  					if (styler.SafeGetCharAt(pos, '\0') != '{') {
348  						valid_char = ScanNumericEscape(styler, pos, 4, false);
349  					} else {
350  						int n_digits = 0;
351  						while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
352  						}
353  						if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
354  							pos++;
355  						else
356  							valid_char = false;
357  					}
358  				} else if (n == 'U' && !ascii_only) {
359  					pos += 2;
360  					valid_char = ScanNumericEscape(styler, pos, 8, false);
361  				} else {
362  					valid_char = false;
363  				}
364  				break;
365  			case '\'':
366  				valid_char = !first;
367  				done = true;
368  				break;
369  			case '\t':
370  			case '\n':
371  			case '\r':
372  			case '\0':
373  				valid_char = false;
374  				done = true;
375  				break;
376  			default:
377  				if (ascii_only && !IsASCII((char)c)) {
378  					done = true;
379  					valid_char = false;
380  				} else if (!IsIdentifierContinue(c) && !first) {
381  					done = true;
382  				} else {
383  					pos++;
384  				}
385  				break;
386  		}
387  		c = styler.SafeGetCharAt(pos, '\0');
388  		n = styler.SafeGetCharAt(pos + 1, '\0');
389  		first = false;
390  	}
391  	if (styler.SafeGetCharAt(pos, '\0') == '\'') {
392  		valid_lifetime = false;
393  	} else {
394  		valid_char = false;
395  	}
396  	if (valid_lifetime) {
397  		styler.ColourTo(pos - 1, SCE_RUST_LIFETIME);
398  	} else if (valid_char) {
399  		pos++;
400  		styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTECHARACTER : SCE_RUST_CHARACTER);
401  	} else {
402  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
403  	}
404  }
405  enum CommentState {
406  	UnknownComment,
407  	DocComment,
408  	NotDocComment
409  };
410  static void ResumeBlockComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state, int level) {
<span onclick='openModal()' class='match'>411  	int c = styler.SafeGetCharAt(pos, '\0');
412  	bool maybe_doc_comment = false;
413  	if (c == '*') {
</span>414  		int n = styler.SafeGetCharAt(pos + 1, '\0');
415  		if (n != '*' && n != '/') {
416  			maybe_doc_comment = true;
417  		}
418  	} else if (c == '!') {
419  		maybe_doc_comment = true;
420  	}
421  	for (;;) {
422  		int n = styler.SafeGetCharAt(pos + 1, '\0');
423  		if (pos == styler.LineEnd(styler.GetLine(pos)))
424  			styler.SetLineState(styler.GetLine(pos), level);
425  		if (c == '*') {
426  			pos++;
427  			if (n == '/') {
428  				pos++;
429  				level--;
430  				if (level == 0) {
431  					styler.SetLineState(styler.GetLine(pos), 0);
432  					if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
433  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
434  					else
435  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
436  					break;
437  				}
438  			}
439  		} else if (c == '/') {
440  			pos++;
441  			if (n == '*') {
442  				pos++;
443  				level++;
444  			}
445  		}
446  		else if (pos < max) {
447  			pos++;
448  		}
449  		if (pos >= max) {
450  			if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
451  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
452  			else
453  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
454  			break;
455  		}
456  		c = styler.SafeGetCharAt(pos, '\0');
457  	}
458  }
459  static void ResumeLineComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state) {
460  	bool maybe_doc_comment = false;
461  	int c = styler.SafeGetCharAt(pos, '\0');
462  	if (c == '/') {
463  		if (pos < max) {
464  			pos++;
465  			c = styler.SafeGetCharAt(pos, '\0');
466  			if (c != '/') {
467  				maybe_doc_comment = true;
468  			}
469  		}
470  	} else if (c == '!') {
471  		maybe_doc_comment = true;
472  	}
473  	pos = styler.LineEnd(styler.GetLine(pos));
474  	styler.SetLineState(styler.GetLine(pos), SCE_RUST_DEFAULT);
475  	if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
476  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINEDOC);
477  	else
478  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINE);
479  }
480  static void ScanComments(Accessor &styler, Sci_Position& pos, Sci_Position max) {
481  	pos++;
482  	int c = styler.SafeGetCharAt(pos, '\0');
483  	pos++;
484  	if (c == '/')
485  		ResumeLineComment(styler, pos, max, UnknownComment);
486  	else if (c == '*')
487  		ResumeBlockComment(styler, pos, max, UnknownComment, 1);
488  }
489  static void ResumeString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
490  	int c = styler.SafeGetCharAt(pos, '\0');
491  	bool error = false;
492  	while (c != '"' && !error) {
493  		if (pos >= max) {
494  			error = true;
495  			break;
496  		}
497  		if (pos == styler.LineEnd(styler.GetLine(pos)))
498  			styler.SetLineState(styler.GetLine(pos), 0);
499  		if (c == '\\') {
500  			int n = styler.SafeGetCharAt(pos + 1, '\0');
501  			if (IsValidStringEscape(n)) {
502  				pos += 2;
503  			} else if (n == 'x') {
504  				pos += 2;
505  				error = !ScanNumericEscape(styler, pos, 2, true);
506  			} else if (n == 'u' && !ascii_only) {
507  				pos += 2;
508  				if (styler.SafeGetCharAt(pos, '\0') != '{') {
509  					error = !ScanNumericEscape(styler, pos, 4, true);
510  				} else {
511  					int n_digits = 0;
512  					while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
513  					}
514  					if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
515  						pos++;
516  					else
517  						error = true;
518  				}
519  			} else if (n == 'U' && !ascii_only) {
520  				pos += 2;
521  				error = !ScanNumericEscape(styler, pos, 8, true);
522  			} else {
523  				pos += 1;
524  				error = true;
525  			}
526  		} else {
527  			if (ascii_only && !IsASCII((char)c))
528  				error = true;
529  			else
530  				pos++;
531  		}
532  		c = styler.SafeGetCharAt(pos, '\0');
533  	}
534  	if (!error)
535  		pos++;
536  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRING : SCE_RUST_STRING);
537  }
538  static void ResumeRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, int num_hashes, bool ascii_only) {
539  	for (;;) {
540  		if (pos == styler.LineEnd(styler.GetLine(pos)))
541  			styler.SetLineState(styler.GetLine(pos), num_hashes);
542  		int c = styler.SafeGetCharAt(pos, '\0');
543  		if (c == '"') {
544  			pos++;
545  			int trailing_num_hashes = 0;
546  			while (styler.SafeGetCharAt(pos, '\0') == '#' && trailing_num_hashes < num_hashes) {
547  				trailing_num_hashes++;
548  				pos++;
549  			}
550  			if (trailing_num_hashes == num_hashes) {
551  				styler.SetLineState(styler.GetLine(pos), 0);
552  				break;
553  			}
554  		} else if (pos >= max) {
555  			break;
556  		} else {
557  			if (ascii_only && !IsASCII((char)c))
558  				break;
559  			pos++;
560  		}
561  	}
562  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRINGR : SCE_RUST_STRINGR);
563  }
564  static void ScanRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
565  	pos++;
566  	int num_hashes = 0;
567  	while (styler.SafeGetCharAt(pos, '\0') == '#') {
568  		num_hashes++;
569  		pos++;
570  	}
571  	if (styler.SafeGetCharAt(pos, '\0') != '"') {
572  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
573  	} else {
574  		pos++;
575  		ResumeRawString(styler, pos, max, num_hashes, ascii_only);
576  	}
577  }
578  void SCI_METHOD LexerRust::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
579  	PropSetSimple props;
580  	Accessor styler(pAccess, &props);
581  	Sci_Position pos = startPos;
582  	Sci_Position max = pos + length;
583  	styler.StartAt(pos);
584  	styler.StartSegment(pos);
585  	if (initStyle == SCE_RUST_COMMENTBLOCK || initStyle == SCE_RUST_COMMENTBLOCKDOC) {
586  		ResumeBlockComment(styler, pos, max, initStyle == SCE_RUST_COMMENTBLOCKDOC ? DocComment : NotDocComment, styler.GetLineState(styler.GetLine(pos) - 1));
587  	} else if (initStyle == SCE_RUST_COMMENTLINE || initStyle == SCE_RUST_COMMENTLINEDOC) {
588  		ResumeLineComment(styler, pos, max, initStyle == SCE_RUST_COMMENTLINEDOC ? DocComment : NotDocComment);
589  	} else if (initStyle == SCE_RUST_STRING) {
590  		ResumeString(styler, pos, max, false);
591  	} else if (initStyle == SCE_RUST_BYTESTRING) {
592  		ResumeString(styler, pos, max, true);
593  	} else if (initStyle == SCE_RUST_STRINGR) {
594  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), false);
595  	} else if (initStyle == SCE_RUST_BYTESTRINGR) {
596  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), true);
597  	}
598  	while (pos < max) {
599  		int c = styler.SafeGetCharAt(pos, '\0');
600  		int n = styler.SafeGetCharAt(pos + 1, '\0');
601  		int n2 = styler.SafeGetCharAt(pos + 2, '\0');
602  		if (pos == 0 && c == '#' && n == '!' && n2 != '[') {
603  			pos += 2;
604  			ResumeLineComment(styler, pos, max, NotDocComment);
605  		} else if (IsWhitespace(c)) {
606  			ScanWhitespace(styler, pos, max);
607  		} else if (c == '/' && (n == '/' || n == '*')) {
608  			ScanComments(styler, pos, max);
609  		} else if (c == 'r' && (n == '#' || n == '"')) {
610  			ScanRawString(styler, pos, max, false);
611  		} else if (c == 'b' && n == 'r' && (n2 == '#' || n2 == '"')) {
612  			pos++;
613  			ScanRawString(styler, pos, max, true);
614  		} else if (c == 'b' && n == '"') {
615  			pos += 2;
616  			ResumeString(styler, pos, max, true);
617  		} else if (c == 'b' && n == '\'') {
618  			pos++;
619  			ScanCharacterLiteralOrLifetime(styler, pos, true);
620  		} else if (IsIdentifierStart(c)) {
621  			ScanIdentifier(styler, pos, keywords);
622  		} else if (IsADigit(c)) {
623  			ScanNumber(styler, pos);
624  		} else if (IsThreeCharOperator(c, n, n2)) {
625  			pos += 3;
626  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
627  		} else if (IsTwoCharOperator(c, n)) {
628  			pos += 2;
629  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
630  		} else if (IsOneCharOperator(c)) {
631  			pos++;
632  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
633  		} else if (c == '\'') {
634  			ScanCharacterLiteralOrLifetime(styler, pos, false);
635  		} else if (c == '"') {
636  			pos++;
637  			ResumeString(styler, pos, max, false);
638  		} else {
639  			pos++;
640  			styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
641  		}
642  	}
643  	styler.ColourTo(pos - 1, SCE_RUST_DEFAULT);
644  	styler.Flush();
645  }
646  void SCI_METHOD LexerRust::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
647  	if (!options.fold)
648  		return;
649  	LexAccessor styler(pAccess);
650  	Sci_PositionU endPos = startPos + length;
651  	int visibleChars = 0;
652  	bool inLineComment = false;
653  	Sci_Position lineCurrent = styler.GetLine(startPos);
654  	int levelCurrent = SC_FOLDLEVELBASE;
655  	if (lineCurrent > 0)
656  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
660  	char chNext = styler[startPos];
661  	int styleNext = styler.StyleAt(startPos);
662  	int style = initStyle;
663  	const bool userDefinedFoldMarkers = !options.foldExplicitStart.empty() && !options.foldExplicitEnd.empty();
664  	for (Sci_PositionU i = startPos; i < endPos; i++) {
665  		char ch = chNext;
666  		chNext = styler.SafeGetCharAt(i + 1);
667  		int stylePrev = style;
668  		style = styleNext;
669  		styleNext = styler.StyleAt(i + 1);
670  		bool atEOL = i == (lineStartNext-1);
671  		if ((style == SCE_RUST_COMMENTLINE) || (style == SCE_RUST_COMMENTLINEDOC))
672  			inLineComment = true;
673  		if (options.foldComment && options.foldCommentMultiline && IsStreamCommentStyle(style) && !inLineComment) {
674  			if (!IsStreamCommentStyle(stylePrev)) {
675  				levelNext++;
676  			} else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
677  				levelNext--;
678  			}
679  		}
680  		if (options.foldComment && options.foldCommentExplicit && ((style == SCE_RUST_COMMENTLINE) || options.foldExplicitAnywhere)) {
681  			if (userDefinedFoldMarkers) {
682  				if (styler.Match(i, options.foldExplicitStart.c_str())) {
683  					levelNext++;
684  				} else if (styler.Match(i, options.foldExplicitEnd.c_str())) {
685  					levelNext--;
686  				}
687  			} else {
688  				if ((ch == '/') && (chNext == '/')) {
689  					char chNext2 = styler.SafeGetCharAt(i + 2);
690  					if (chNext2 == '{') {
691  						levelNext++;
692  					} else if (chNext2 == '}') {
693  						levelNext--;
694  					}
695  				}
696  			}
697  		}
698  		if (options.foldSyntaxBased && (style == SCE_RUST_OPERATOR)) {
699  			if (ch == '{') {
700  				if (levelMinCurrent > levelNext) {
701  					levelMinCurrent = levelNext;
702  				}
703  				levelNext++;
704  			} else if (ch == '}') {
705  				levelNext--;
706  			}
707  		}
708  		if (!IsASpace(ch))
709  			visibleChars++;
710  		if (atEOL || (i == endPos-1)) {
711  			int levelUse = levelCurrent;
712  			if (options.foldSyntaxBased && options.foldAtElse) {
713  				levelUse = levelMinCurrent;
714  			}
715  			int lev = levelUse | levelNext << 16;
716  			if (visibleChars == 0 && options.foldCompact)
717  				lev |= SC_FOLDLEVELWHITEFLAG;
718  			if (levelUse < levelNext)
719  				lev |= SC_FOLDLEVELHEADERFLAG;
720  			if (lev != styler.LevelAt(lineCurrent)) {
721  				styler.SetLevel(lineCurrent, lev);
722  			}
723  			lineCurrent++;
724  			lineStartNext = styler.LineStart(lineCurrent+1);
725  			levelCurrent = levelNext;
726  			levelMinCurrent = levelCurrent;
727  			if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
728  				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
729  			}
730  			visibleChars = 0;
731  			inLineComment = false;
732  		}
733  	}
734  }
735  LexerModule lmRust(SCLEX_RUST, LexerRust::LexerFactoryRust, "rust", rustWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "PropSetSimple.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  static const int NUM_RUST_KEYWORD_LISTS = 7;
26  static const int MAX_RUST_IDENT_CHARS = 1023;
27  static bool IsStreamCommentStyle(int style) {
28  	return style == SCE_RUST_COMMENTBLOCK ||
29  		   style == SCE_RUST_COMMENTBLOCKDOC;
30  }
31  struct OptionsRust {
32  	bool fold;
33  	bool foldSyntaxBased;
34  	bool foldComment;
35  	bool foldCommentMultiline;
36  	bool foldCommentExplicit;
37  	std::string foldExplicitStart;
38  	std::string foldExplicitEnd;
39  	bool foldExplicitAnywhere;
40  	bool foldCompact;
41  	int  foldAtElseInt;
42  	bool foldAtElse;
43  	OptionsRust() {
44  		fold = false;
45  		foldSyntaxBased = true;
46  		foldComment = false;
47  		foldCommentMultiline = true;
48  		foldCommentExplicit = true;
49  		foldExplicitStart = "";
50  		foldExplicitEnd   = "";
51  		foldExplicitAnywhere = false;
52  		foldCompact = true;
53  		foldAtElseInt = -1;
54  		foldAtElse = false;
55  	}
56  };
57  static const char * const rustWordLists[NUM_RUST_KEYWORD_LISTS + 1] = {
58  			"Primary keywords and identifiers",
59  			"Built in types",
60  			"Other keywords",
61  			"Keywords 4",
62  			"Keywords 5",
63  			"Keywords 6",
64  			"Keywords 7",
65  			0,
66  		};
67  struct OptionSetRust : public OptionSet<OptionsRust> {
68  	OptionSetRust() {
69  		DefineProperty("fold", &OptionsRust::fold);
70  		DefineProperty("fold.comment", &OptionsRust::foldComment);
71  		DefineProperty("fold.compact", &OptionsRust::foldCompact);
72  		DefineProperty("fold.at.else", &OptionsRust::foldAtElse);
73  		DefineProperty("fold.rust.syntax.based", &OptionsRust::foldSyntaxBased,
74  			"Set this property to 0 to disable syntax based folding.");
75  		DefineProperty("fold.rust.comment.multiline", &OptionsRust::foldCommentMultiline,
76  			"Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
77  		DefineProperty("fold.rust.comment.explicit", &OptionsRust::foldCommentExplicit,
78  			"Set this property to 0 to disable folding explicit fold points when fold.comment=1.");
79  		DefineProperty("fold.rust.explicit.start", &OptionsRust::foldExplicitStart,
80  			"The string to use for explicit fold start points, replacing the standard 
81  		DefineProperty("fold.rust.explicit.end", &OptionsRust::foldExplicitEnd,
82  			"The string to use for explicit fold end points, replacing the standard 
83  		DefineProperty("fold.rust.explicit.anywhere", &OptionsRust::foldExplicitAnywhere,
84  			"Set this property to 1 to enable explicit fold points anywhere, not just in line comments.");
85  		DefineProperty("lexer.rust.fold.at.else", &OptionsRust::foldAtElseInt,
86  			"This option enables Rust folding on a \"} else {\" line of an if statement.");
87  		DefineWordListSets(rustWordLists);
88  	}
89  };
90  class LexerRust : public DefaultLexer {
91  	WordList keywords[NUM_RUST_KEYWORD_LISTS];
92  	OptionsRust options;
93  	OptionSetRust osRust;
94  public:
95  	LexerRust() : DefaultLexer("rust", SCLEX_RUST) {
96  	}
97  	virtual ~LexerRust() {
98  	}
99  	void SCI_METHOD Release() override {
100  		delete this;
101  	}
102  	int SCI_METHOD Version() const override {
103  		return lvRelease5;
104  	}
105  	const char * SCI_METHOD PropertyNames() override {
106  		return osRust.PropertyNames();
107  	}
108  	int SCI_METHOD PropertyType(const char *name) override {
109  		return osRust.PropertyType(name);
110  	}
111  	const char * SCI_METHOD DescribeProperty(const char *name) override {
112  		return osRust.DescribeProperty(name);
113  	}
114  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
115  	const char * SCI_METHOD PropertyGet(const char *key) override {
116  		return osRust.PropertyGet(key);
117  	}
118  	const char * SCI_METHOD DescribeWordListSets() override {
119  		return osRust.DescribeWordListSets();
120  	}
121  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
122  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
123  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
124  	void * SCI_METHOD PrivateCall(int, void *) override {
125  		return 0;
126  	}
127  	static ILexer5 *LexerFactoryRust() {
128  		return new LexerRust();
129  	}
130  };
131  Sci_Position SCI_METHOD LexerRust::PropertySet(const char *key, const char *val) {
132  	if (osRust.PropertySet(&options, key, val)) {
133  		return 0;
134  	}
135  	return -1;
136  }
137  Sci_Position SCI_METHOD LexerRust::WordListSet(int n, const char *wl) {
138  	Sci_Position firstModification = -1;
139  	if (n < NUM_RUST_KEYWORD_LISTS) {
140  		WordList *wordListN = &keywords[n];
141  		WordList wlNew;
142  		wlNew.Set(wl);
143  		if (*wordListN != wlNew) {
144  			wordListN->Set(wl);
145  			firstModification = 0;
146  		}
147  	}
148  	return firstModification;
149  }
150  static bool IsWhitespace(int c) {
151      return c == ' ' || c == '\t' || c == '\r' || c == '\n';
152  }
153  static bool IsIdentifierStart(int ch) {
154  	return (IsASCII(ch) && (isalpha(ch) || ch == '_')) || !IsASCII(ch);
155  }
156  static bool IsIdentifierContinue(int ch) {
157  	return (IsASCII(ch) && (isalnum(ch) || ch == '_')) || !IsASCII(ch);
158  }
159  static void ScanWhitespace(Accessor& styler, Sci_Position& pos, Sci_Position max) {
160  	while (IsWhitespace(styler.SafeGetCharAt(pos, '\0')) && pos < max) {
161  		if (pos == styler.LineEnd(styler.GetLine(pos)))
162  			styler.SetLineState(styler.GetLine(pos), 0);
163  		pos++;
164  	}
165  	styler.ColourTo(pos-1, SCE_RUST_DEFAULT);
166  }
167  static void GrabString(char* s, Accessor& styler, Sci_Position start, Sci_Position len) {
168  	for (Sci_Position ii = 0; ii < len; ii++)
169  		s[ii] = styler[ii + start];
170  	s[len] = '\0';
171  }
172  static void ScanIdentifier(Accessor& styler, Sci_Position& pos, WordList *keywords) {
173  	Sci_Position start = pos;
174  	while (IsIdentifierContinue(styler.SafeGetCharAt(pos, '\0')))
175  		pos++;
176  	if (styler.SafeGetCharAt(pos, '\0') == '!') {
177  		pos++;
178  		styler.ColourTo(pos - 1, SCE_RUST_MACRO);
179  	} else {
180  		char s[MAX_RUST_IDENT_CHARS + 1];
181  		Sci_Position len = pos - start;
182  		len = len > MAX_RUST_IDENT_CHARS ? MAX_RUST_IDENT_CHARS : len;
183  		GrabString(s, styler, start, len);
184  		bool keyword = false;
185  		for (int ii = 0; ii < NUM_RUST_KEYWORD_LISTS; ii++) {
186  			if (keywords[ii].InList(s)) {
187  				styler.ColourTo(pos - 1, SCE_RUST_WORD + ii);
188  				keyword = true;
189  				break;
190  			}
191  		}
192  		if (!keyword) {
193  			styler.ColourTo(pos - 1, SCE_RUST_IDENTIFIER);
194  		}
195  	}
196  }
197  static bool ScanDigits(Accessor& styler, Sci_Position& pos, int base) {
198  	Sci_Position old_pos = pos;
199  	for (;;) {
200  		int c = styler.SafeGetCharAt(pos, '\0');
201  		if (IsADigit(c, base) || c == '_')
202  			pos++;
203  		else
204  			break;
205  	}
206  	return old_pos != pos;
207  }
208  static void ScanNumber(Accessor& styler, Sci_Position& pos) {
209  	int base = 10;
210  	int c = styler.SafeGetCharAt(pos, '\0');
211  	int n = styler.SafeGetCharAt(pos + 1, '\0');
212  	bool error = false;
213  	if (c == '0' && n == 'x') {
214  		pos += 2;
215  		base = 16;
216  	} else if (c == '0' && n == 'b') {
217  		pos += 2;
218  		base = 2;
219  	} else if (c == '0' && n == 'o') {
220  		pos += 2;
221  		base = 8;
222  	}
223  	error |= !ScanDigits(styler, pos, base);
224  	c = styler.SafeGetCharAt(pos, '\0');
225  	if (c == 'u' || c == 'i') {
226  		pos++;
227  		c = styler.SafeGetCharAt(pos, '\0');
228  		n = styler.SafeGetCharAt(pos + 1, '\0');
229  		if (c == '8') {
230  			pos++;
231  		} else if (c == '1' && n == '6') {
232  			pos += 2;
233  		} else if (c == '3' && n == '2') {
234  			pos += 2;
235  		} else if (c == '6' && n == '4') {
236  			pos += 2;
237  		} else if (styler.Match(pos, "128")) {
238  			pos += 3;
239  		} else if (styler.Match(pos, "size")) {
240  			pos += 4;
241  		} else {
242  			error = true;
243  		}
244  	} else if (!error) {
245  		n = styler.SafeGetCharAt(pos + 1, '\0');
246  		if (c == '.' && !(IsIdentifierStart(n) || n == '.')) {
247  			error |= base != 10;
248  			pos++;
249  			ScanDigits(styler, pos, 10);
250  		}
251  		c = styler.SafeGetCharAt(pos, '\0');
252  		if (c == 'e' || c == 'E') {
253  			error |= base != 10;
254  			pos++;
255  			c = styler.SafeGetCharAt(pos, '\0');
256  			if (c == '-' || c == '+')
257  				pos++;
258  			error |= !ScanDigits(styler, pos, 10);
259  		}
260  		c = styler.SafeGetCharAt(pos, '\0');
261  		if (c == 'f') {
262  			error |= base != 10;
263  			pos++;
264  			c = styler.SafeGetCharAt(pos, '\0');
265  			n = styler.SafeGetCharAt(pos + 1, '\0');
266  			if (c == '3' && n == '2') {
267  				pos += 2;
268  			} else if (c == '6' && n == '4') {
269  				pos += 2;
270  			} else {
271  				error = true;
272  			}
273  		}
274  	}
275  	if (error)
276  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
277  	else
278  		styler.ColourTo(pos - 1, SCE_RUST_NUMBER);
279  }
280  static bool IsOneCharOperator(int c) {
281  	return c == ';' || c == ',' || c == '(' || c == ')'
282  	    || c == '{' || c == '}' || c == '[' || c == ']'
283  	    || c == '@' || c == '#' || c == '~' || c == '+'
284  	    || c == '*' || c == '/' || c == '^' || c == '%'
285  	    || c == '.' || c == ':' || c == '!' || c == '<'
286  	    || c == '>' || c == '=' || c == '-' || c == '&'
287  	    || c == '|' || c == '$' || c == '?';
288  }
289  static bool IsTwoCharOperator(int c, int n) {
290  	return (c == '.' && n == '.') || (c == ':' && n == ':')
291  	    || (c == '!' && n == '=') || (c == '<' && n == '<')
292  	    || (c == '<' && n == '=') || (c == '>' && n == '>')
293  	    || (c == '>' && n == '=') || (c == '=' && n == '=')
294  	    || (c == '=' && n == '>') || (c == '-' && n == '>')
295  	    || (c == '&' && n == '&') || (c == '|' && n == '|')
296  	    || (c == '-' && n == '=') || (c == '&' && n == '=')
297  	    || (c == '|' && n == '=') || (c == '+' && n == '=')
298  	    || (c == '*' && n == '=') || (c == '/' && n == '=')
299  	    || (c == '^' && n == '=') || (c == '%' && n == '=');
300  }
301  static bool IsThreeCharOperator(int c, int n, int n2) {
302  	return (c == '<' && n == '<' && n2 == '=')
303  	    || (c == '>' && n == '>' && n2 == '=');
304  }
305  static bool IsValidCharacterEscape(int c) {
306  	return c == 'n'  || c == 'r' || c == 't' || c == '\\'
307  	    || c == '\'' || c == '"' || c == '0';
308  }
309  static bool IsValidStringEscape(int c) {
310  	return IsValidCharacterEscape(c) || c == '\n' || c == '\r';
311  }
312  static bool ScanNumericEscape(Accessor &styler, Sci_Position& pos, Sci_Position num_digits, bool stop_asap) {
313  	for (;;) {
314  		int c = styler.SafeGetCharAt(pos, '\0');
315  		if (!IsADigit(c, 16))
316  			break;
317  		num_digits--;
318  		pos++;
319  		if (num_digits == 0 && stop_asap)
320  			return true;
321  	}
322  	if (num_digits == 0) {
323  		return true;
324  	} else {
325  		return false;
326  	}
327  }
328  static void ScanCharacterLiteralOrLifetime(Accessor &styler, Sci_Position& pos, bool ascii_only) {
329  	pos++;
330  	int c = styler.SafeGetCharAt(pos, '\0');
331  	int n = styler.SafeGetCharAt(pos + 1, '\0');
332  	bool done = false;
333  	bool valid_lifetime = !ascii_only && IsIdentifierStart(c);
334  	bool valid_char = true;
335  	bool first = true;
336  	while (!done) {
337  		switch (c) {
338  			case '\\':
339  				done = true;
340  				if (IsValidCharacterEscape(n)) {
341  					pos += 2;
342  				} else if (n == 'x') {
343  					pos += 2;
344  					valid_char = ScanNumericEscape(styler, pos, 2, false);
345  				} else if (n == 'u' && !ascii_only) {
346  					pos += 2;
347  					if (styler.SafeGetCharAt(pos, '\0') != '{') {
348  						valid_char = ScanNumericEscape(styler, pos, 4, false);
349  					} else {
350  						int n_digits = 0;
351  						while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
352  						}
353  						if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
354  							pos++;
355  						else
356  							valid_char = false;
357  					}
358  				} else if (n == 'U' && !ascii_only) {
359  					pos += 2;
360  					valid_char = ScanNumericEscape(styler, pos, 8, false);
361  				} else {
362  					valid_char = false;
363  				}
364  				break;
365  			case '\'':
366  				valid_char = !first;
367  				done = true;
368  				break;
369  			case '\t':
370  			case '\n':
371  			case '\r':
372  			case '\0':
373  				valid_char = false;
374  				done = true;
375  				break;
376  			default:
377  				if (ascii_only && !IsASCII((char)c)) {
378  					done = true;
379  					valid_char = false;
380  				} else if (!IsIdentifierContinue(c) && !first) {
381  					done = true;
382  				} else {
383  					pos++;
384  				}
385  				break;
386  		}
387  		c = styler.SafeGetCharAt(pos, '\0');
388  		n = styler.SafeGetCharAt(pos + 1, '\0');
389  		first = false;
390  	}
391  	if (styler.SafeGetCharAt(pos, '\0') == '\'') {
392  		valid_lifetime = false;
393  	} else {
394  		valid_char = false;
395  	}
396  	if (valid_lifetime) {
397  		styler.ColourTo(pos - 1, SCE_RUST_LIFETIME);
398  	} else if (valid_char) {
399  		pos++;
400  		styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTECHARACTER : SCE_RUST_CHARACTER);
401  	} else {
402  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
403  	}
404  }
405  enum CommentState {
406  	UnknownComment,
407  	DocComment,
408  	NotDocComment
409  };
410  static void ResumeBlockComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state, int level) {
411  	int c = styler.SafeGetCharAt(pos, '\0');
412  	bool maybe_doc_comment = false;
413  	if (c == '*') {
414  		int n = styler.SafeGetCharAt(pos + 1, '\0');
415  		if (n != '*' && n != '/') {
416  			maybe_doc_comment = true;
417  		}
418  	} else if (c == '!') {
419  		maybe_doc_comment = true;
420  	}
421  	for (;;) {
422  		int n = styler.SafeGetCharAt(pos + 1, '\0');
423  		if (pos == styler.LineEnd(styler.GetLine(pos)))
424  			styler.SetLineState(styler.GetLine(pos), level);
425  		if (c == '*') {
426  			pos++;
427  			if (n == '/') {
428  				pos++;
429  				level--;
430  				if (level == 0) {
431  					styler.SetLineState(styler.GetLine(pos), 0);
432  					if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
433  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
434  					else
435  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
436  					break;
437  				}
438  			}
439  		} else if (c == '/') {
440  			pos++;
441  			if (n == '*') {
442  				pos++;
443  				level++;
444  			}
445  		}
446  		else if (pos < max) {
447  			pos++;
448  		}
449  		if (pos >= max) {
450  			if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
451  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
452  			else
453  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
454  			break;
455  		}
456  		c = styler.SafeGetCharAt(pos, '\0');
457  	}
458  }
459  static void ResumeLineComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state) {
460  	bool maybe_doc_comment = false;
461  	int c = styler.SafeGetCharAt(pos, '\0');
462  	if (c == '/') {
463  		if (pos < max) {
464  			pos++;
465  			c = styler.SafeGetCharAt(pos, '\0');
466  			if (c != '/') {
467  				maybe_doc_comment = true;
468  			}
469  		}
470  	} else if (c == '!') {
471  		maybe_doc_comment = true;
472  	}
473  	pos = styler.LineEnd(styler.GetLine(pos));
474  	styler.SetLineState(styler.GetLine(pos), SCE_RUST_DEFAULT);
475  	if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
476  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINEDOC);
477  	else
478  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINE);
479  }
480  static void ScanComments(Accessor &styler, Sci_Position& pos, Sci_Position max) {
481  	pos++;
482  	int c = styler.SafeGetCharAt(pos, '\0');
483  	pos++;
484  	if (c == '/')
485  		ResumeLineComment(styler, pos, max, UnknownComment);
486  	else if (c == '*')
487  		ResumeBlockComment(styler, pos, max, UnknownComment, 1);
488  }
489  static void ResumeString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
<span onclick='openModal()' class='match'>490  	int c = styler.SafeGetCharAt(pos, '\0');
491  	bool error = false;
492  	while (c != '"' && !error) {
</span>493  		if (pos >= max) {
494  			error = true;
495  			break;
496  		}
497  		if (pos == styler.LineEnd(styler.GetLine(pos)))
498  			styler.SetLineState(styler.GetLine(pos), 0);
499  		if (c == '\\') {
500  			int n = styler.SafeGetCharAt(pos + 1, '\0');
501  			if (IsValidStringEscape(n)) {
502  				pos += 2;
503  			} else if (n == 'x') {
504  				pos += 2;
505  				error = !ScanNumericEscape(styler, pos, 2, true);
506  			} else if (n == 'u' && !ascii_only) {
507  				pos += 2;
508  				if (styler.SafeGetCharAt(pos, '\0') != '{') {
509  					error = !ScanNumericEscape(styler, pos, 4, true);
510  				} else {
511  					int n_digits = 0;
512  					while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
513  					}
514  					if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
515  						pos++;
516  					else
517  						error = true;
518  				}
519  			} else if (n == 'U' && !ascii_only) {
520  				pos += 2;
521  				error = !ScanNumericEscape(styler, pos, 8, true);
522  			} else {
523  				pos += 1;
524  				error = true;
525  			}
526  		} else {
527  			if (ascii_only && !IsASCII((char)c))
528  				error = true;
529  			else
530  				pos++;
531  		}
532  		c = styler.SafeGetCharAt(pos, '\0');
533  	}
534  	if (!error)
535  		pos++;
536  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRING : SCE_RUST_STRING);
537  }
538  static void ResumeRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, int num_hashes, bool ascii_only) {
539  	for (;;) {
540  		if (pos == styler.LineEnd(styler.GetLine(pos)))
541  			styler.SetLineState(styler.GetLine(pos), num_hashes);
542  		int c = styler.SafeGetCharAt(pos, '\0');
543  		if (c == '"') {
544  			pos++;
545  			int trailing_num_hashes = 0;
546  			while (styler.SafeGetCharAt(pos, '\0') == '#' && trailing_num_hashes < num_hashes) {
547  				trailing_num_hashes++;
548  				pos++;
549  			}
550  			if (trailing_num_hashes == num_hashes) {
551  				styler.SetLineState(styler.GetLine(pos), 0);
552  				break;
553  			}
554  		} else if (pos >= max) {
555  			break;
556  		} else {
557  			if (ascii_only && !IsASCII((char)c))
558  				break;
559  			pos++;
560  		}
561  	}
562  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRINGR : SCE_RUST_STRINGR);
563  }
564  static void ScanRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
565  	pos++;
566  	int num_hashes = 0;
567  	while (styler.SafeGetCharAt(pos, '\0') == '#') {
568  		num_hashes++;
569  		pos++;
570  	}
571  	if (styler.SafeGetCharAt(pos, '\0') != '"') {
572  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
573  	} else {
574  		pos++;
575  		ResumeRawString(styler, pos, max, num_hashes, ascii_only);
576  	}
577  }
578  void SCI_METHOD LexerRust::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
579  	PropSetSimple props;
580  	Accessor styler(pAccess, &props);
581  	Sci_Position pos = startPos;
582  	Sci_Position max = pos + length;
583  	styler.StartAt(pos);
584  	styler.StartSegment(pos);
585  	if (initStyle == SCE_RUST_COMMENTBLOCK || initStyle == SCE_RUST_COMMENTBLOCKDOC) {
586  		ResumeBlockComment(styler, pos, max, initStyle == SCE_RUST_COMMENTBLOCKDOC ? DocComment : NotDocComment, styler.GetLineState(styler.GetLine(pos) - 1));
587  	} else if (initStyle == SCE_RUST_COMMENTLINE || initStyle == SCE_RUST_COMMENTLINEDOC) {
588  		ResumeLineComment(styler, pos, max, initStyle == SCE_RUST_COMMENTLINEDOC ? DocComment : NotDocComment);
589  	} else if (initStyle == SCE_RUST_STRING) {
590  		ResumeString(styler, pos, max, false);
591  	} else if (initStyle == SCE_RUST_BYTESTRING) {
592  		ResumeString(styler, pos, max, true);
593  	} else if (initStyle == SCE_RUST_STRINGR) {
594  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), false);
595  	} else if (initStyle == SCE_RUST_BYTESTRINGR) {
596  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), true);
597  	}
598  	while (pos < max) {
599  		int c = styler.SafeGetCharAt(pos, '\0');
600  		int n = styler.SafeGetCharAt(pos + 1, '\0');
601  		int n2 = styler.SafeGetCharAt(pos + 2, '\0');
602  		if (pos == 0 && c == '#' && n == '!' && n2 != '[') {
603  			pos += 2;
604  			ResumeLineComment(styler, pos, max, NotDocComment);
605  		} else if (IsWhitespace(c)) {
606  			ScanWhitespace(styler, pos, max);
607  		} else if (c == '/' && (n == '/' || n == '*')) {
608  			ScanComments(styler, pos, max);
609  		} else if (c == 'r' && (n == '#' || n == '"')) {
610  			ScanRawString(styler, pos, max, false);
611  		} else if (c == 'b' && n == 'r' && (n2 == '#' || n2 == '"')) {
612  			pos++;
613  			ScanRawString(styler, pos, max, true);
614  		} else if (c == 'b' && n == '"') {
615  			pos += 2;
616  			ResumeString(styler, pos, max, true);
617  		} else if (c == 'b' && n == '\'') {
618  			pos++;
619  			ScanCharacterLiteralOrLifetime(styler, pos, true);
620  		} else if (IsIdentifierStart(c)) {
621  			ScanIdentifier(styler, pos, keywords);
622  		} else if (IsADigit(c)) {
623  			ScanNumber(styler, pos);
624  		} else if (IsThreeCharOperator(c, n, n2)) {
625  			pos += 3;
626  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
627  		} else if (IsTwoCharOperator(c, n)) {
628  			pos += 2;
629  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
630  		} else if (IsOneCharOperator(c)) {
631  			pos++;
632  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
633  		} else if (c == '\'') {
634  			ScanCharacterLiteralOrLifetime(styler, pos, false);
635  		} else if (c == '"') {
636  			pos++;
637  			ResumeString(styler, pos, max, false);
638  		} else {
639  			pos++;
640  			styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
641  		}
642  	}
643  	styler.ColourTo(pos - 1, SCE_RUST_DEFAULT);
644  	styler.Flush();
645  }
646  void SCI_METHOD LexerRust::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
647  	if (!options.fold)
648  		return;
649  	LexAccessor styler(pAccess);
650  	Sci_PositionU endPos = startPos + length;
651  	int visibleChars = 0;
652  	bool inLineComment = false;
653  	Sci_Position lineCurrent = styler.GetLine(startPos);
654  	int levelCurrent = SC_FOLDLEVELBASE;
655  	if (lineCurrent > 0)
656  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
660  	char chNext = styler[startPos];
661  	int styleNext = styler.StyleAt(startPos);
662  	int style = initStyle;
663  	const bool userDefinedFoldMarkers = !options.foldExplicitStart.empty() && !options.foldExplicitEnd.empty();
664  	for (Sci_PositionU i = startPos; i < endPos; i++) {
665  		char ch = chNext;
666  		chNext = styler.SafeGetCharAt(i + 1);
667  		int stylePrev = style;
668  		style = styleNext;
669  		styleNext = styler.StyleAt(i + 1);
670  		bool atEOL = i == (lineStartNext-1);
671  		if ((style == SCE_RUST_COMMENTLINE) || (style == SCE_RUST_COMMENTLINEDOC))
672  			inLineComment = true;
673  		if (options.foldComment && options.foldCommentMultiline && IsStreamCommentStyle(style) && !inLineComment) {
674  			if (!IsStreamCommentStyle(stylePrev)) {
675  				levelNext++;
676  			} else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
677  				levelNext--;
678  			}
679  		}
680  		if (options.foldComment && options.foldCommentExplicit && ((style == SCE_RUST_COMMENTLINE) || options.foldExplicitAnywhere)) {
681  			if (userDefinedFoldMarkers) {
682  				if (styler.Match(i, options.foldExplicitStart.c_str())) {
683  					levelNext++;
684  				} else if (styler.Match(i, options.foldExplicitEnd.c_str())) {
685  					levelNext--;
686  				}
687  			} else {
688  				if ((ch == '/') && (chNext == '/')) {
689  					char chNext2 = styler.SafeGetCharAt(i + 2);
690  					if (chNext2 == '{') {
691  						levelNext++;
692  					} else if (chNext2 == '}') {
693  						levelNext--;
694  					}
695  				}
696  			}
697  		}
698  		if (options.foldSyntaxBased && (style == SCE_RUST_OPERATOR)) {
699  			if (ch == '{') {
700  				if (levelMinCurrent > levelNext) {
701  					levelMinCurrent = levelNext;
702  				}
703  				levelNext++;
704  			} else if (ch == '}') {
705  				levelNext--;
706  			}
707  		}
708  		if (!IsASpace(ch))
709  			visibleChars++;
710  		if (atEOL || (i == endPos-1)) {
711  			int levelUse = levelCurrent;
712  			if (options.foldSyntaxBased && options.foldAtElse) {
713  				levelUse = levelMinCurrent;
714  			}
715  			int lev = levelUse | levelNext << 16;
716  			if (visibleChars == 0 && options.foldCompact)
717  				lev |= SC_FOLDLEVELWHITEFLAG;
718  			if (levelUse < levelNext)
719  				lev |= SC_FOLDLEVELHEADERFLAG;
720  			if (lev != styler.LevelAt(lineCurrent)) {
721  				styler.SetLevel(lineCurrent, lev);
722  			}
723  			lineCurrent++;
724  			lineStartNext = styler.LineStart(lineCurrent+1);
725  			levelCurrent = levelNext;
726  			levelMinCurrent = levelCurrent;
727  			if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
728  				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
729  			}
730  			visibleChars = 0;
731  			inLineComment = false;
732  		}
733  	}
734  }
735  LexerModule lmRust(SCLEX_RUST, LexerRust::LexerFactoryRust, "rust", rustWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</div>
                </div>
                <div class="column column_space"><pre><code>411  	int c = styler.SafeGetCharAt(pos, '\0');
412  	bool maybe_doc_comment = false;
413  	if (c == '*') {
</pre></code></div>
                <div class="column column_space"><pre><code>490  	int c = styler.SafeGetCharAt(pos, '\0');
491  	bool error = false;
492  	while (c != '"' && !error) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    