
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</h3>
            <pre><code>1  #include "gridvcl.h"
2  void __fastcall TVclStrGrid::OnGridKeyDown(
3   TObject *Sender, WORD &Key, TShiftState Shift){
4    if (Key==27){
5      int ColN; int RowN;
6      if (IsSelCell(ColN, RowN)){
7        PutVal(ColN, RowN, PrevSelValStr);
8      }
9    }
10    if (Key==' '){
11      int ColN; int RowN;
12      if (IsSelCell(ColN, RowN)){
13        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
14        if (VarType==gvtBool){ 
15          ActValCheckBox->Checked=!ActValCheckBox->Checked;
16        } else
17        if (VarType==gvtStrV){ 
18          if (ActValComboBox->Items->Count>0){
19            ActValComboBox->ItemIndex=
20             (ActValComboBox->ItemIndex+1)%ActValComboBox->Items->Count;
21            OnActValChange(ActValComboBox);
22          }
23        }
24      }
25    }
26  }
27  void __fastcall TVclStrGrid::OnGridMouseDown(
28   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
29    int ColN; int RowN; StrGrid->MouseToCell(X, Y, ColN, RowN);
30    SelCell(ColN, RowN);
31  }
32  void __fastcall TVclStrGrid::OnGridMouseUp(
33   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
34    SyncToGui();
35  }
36  void __fastcall TVclStrGrid::OnGridSelectCell(
37   TObject *Sender, int ACol, int ARow, bool &CanSelect){
38    CanSelect=SelCell(ACol, ARow);
39    SyncToGui();
40  }
41  void __fastcall TVclStrGrid::OnGridSetEditText(
42   TObject *Sender, int ACol, int ARow, const AnsiString Value){
43    _OnGridSetEditText(ACol, ARow, Value.c_str());
44  }
45  void __fastcall TVclStrGrid::OnGridGetEditMask(
46   TObject *Sender, int ColN, int RowN, AnsiString& MaskStr){
47    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
48    if (VarType==gvtStrMask){
49      MaskStr="#0.9;1; ";
50    } else {
51      MaskStr="";
52    }
53  }
54  void __fastcall TVclStrGrid::OnGridTopLeftChanged(TObject *Sender){
55    SyncToGui();
56  }
57  void __fastcall TVclStrGrid::OnActValChange(TObject *Sender){
58    TStr ValStr;
59    if (Sender==ActValEd){
60      ValStr=ActValEd->Text.c_str();
61      int ColN; int RowN;
62      if (IsSelCell(ColN, RowN)){
63        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
64      }
65    } else
66    if (Sender==ActValCheckBox){
67      ValStr=TBool::GetYesNoStr(ActValCheckBox->Checked);
68    } else
69    if (Sender==GridValCheckBox){
70      ValStr=TBool::GetYesNoStr(GridValCheckBox->Checked);
71    } else
72    if (Sender==ActValComboBox){
73      ValStr=ActValComboBox->Text.c_str();
74    } else
75    if (Sender==GridValComboBox){
76      ValStr=GridValComboBox->Text.c_str();
77    } else
78    if (Sender==ActExtValEd){
79      ValStr=ActExtValEd->Text.c_str();
80    } else {
81      Fail;
82    }
83    int ColN; int RowN;
84    if (IsSelCell(ColN, RowN)){
85      PutVal(ColN, RowN, ValStr);
86    }
87  }
88  void __fastcall TVclStrGrid::OnActExtEdBtClick(TObject *Sender){
89    TStr ExtNm=ActExtEdBt->Caption.c_str();
90    TExtGetStrF ExtGetStrF;
91    if (IsExtGetStrF(ExtNm, ExtGetStrF)){
92      int ColN; int RowN;
93      if (IsSelCell(ColN, RowN)){
94        TStr PrevValStr=GetVal(ColN, RowN);
95        TStr NewValStr; bool OkP;
96        (*ExtGetStrF())(false, PrevValStr, NewValStr, OkP);
97        if (OkP){
98          ActExtValEd->Text=NewValStr.CStr();
99        }
100      }
101    }
102  }
103  void TVclStrGrid::EnableCtrl(TControl* Control, const bool& VisibleP){
104    if (Control!=NULL){
105      if (!Control->Enabled){Control->Enabled=true;}
106      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
107    }
108  }
109  void TVclStrGrid::DisableCtrl(TControl* Control, const bool& VisibleP){
110    if (Control!=NULL){
111      if (Control->Enabled){Control->Enabled=false;}
112      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
113    }
114  }
115  void TVclStrGrid::InitGrid(){
116    IAssert(StrGrid!=NULL);
117    StrGrid->ScrollBars=ssBoth;
118    StrGrid->Options.Clear();
119    StrGrid->Options<<goFixedVertLine<<goFixedHorzLine;
120    StrGrid->Options<<goVertLine<<goHorzLine;
121    StrGrid->Options<<goDrawFocusSelected<<goColSizing;
122    StrGrid->Options<<goTabs;
123    StrGrid->OnKeyDown=&OnGridKeyDown;
124    StrGrid->OnMouseDown=&OnGridMouseDown;
125    StrGrid->OnMouseUp=&OnGridMouseUp;
126    StrGrid->OnSelectCell=&OnGridSelectCell;
127    StrGrid->OnSetEditText=&OnGridSetEditText;
128    StrGrid->OnGetEditMask=&OnGridGetEditMask;
129    StrGrid->OnTopLeftChanged=&OnGridTopLeftChanged;
130  }
131  void TVclStrGrid::InitActInput(const PVclStrGrid& PrevStrGrid){
132    if (PrevStrGrid.Empty()){
133      if (ActValEd!=NULL){
134        ActValEd->OnChange=&OnActValChange;
135        ActValEd->OnKeyDown=&OnGridKeyDown;
136        ActValCheckBox=new TCheckBox(StrGrid);
137        ActValCheckBox->Parent=ActValEd->Parent;
138        ActValCheckBox->OnClick=&OnActValChange;
139        ActValCheckBox->OnKeyDown=&OnGridKeyDown;
140        ActValCheckBox->Visible=false;
141        ActValCheckBox->TabOrder=-1;
142        ActValCheckBox->Anchors=ActValEd->Anchors;
143        ActValCheckBox->Left=ActValEd->Left; ActValCheckBox->Top=ActValEd->Top;
144        ActValCheckBox->Width=ActValEd->Width; ActValCheckBox->Height=ActValEd->Height;
145        GridValCheckBox=new TCheckBox(StrGrid);
146        GridValCheckBox->Parent=StrGrid->Parent;
147        GridValCheckBox->OnClick=&OnActValChange;
148        GridValCheckBox->OnKeyDown=&OnGridKeyDown;
149        GridValCheckBox->Visible=false;
150        GridValCheckBox->TabOrder=-1;
151        GridValCheckBox->Color=clActiveCaption;
152        ActValComboBox=new TComboBox(StrGrid);
153        ActValComboBox->Parent=ActValEd->Parent;
154        ActValComboBox->OnChange=&OnActValChange;
155        ActValComboBox->OnKeyDown=&OnGridKeyDown;
156        ActValComboBox->Style=Stdctrls::csDropDownList;
157        ActValComboBox->Visible=false;
158        ActValComboBox->TabOrder=-1;
159        ActValComboBox->Anchors=ActValEd->Anchors;
160        ActValComboBox->Left=ActValEd->Left; ActValComboBox->Top=ActValEd->Top;
161        ActValComboBox->Width=ActValEd->Width; ActValComboBox->Height=ActValEd->Height;
162        GridValComboBox=new TComboBox(StrGrid);
163        GridValComboBox->Parent=StrGrid->Parent;
164        GridValComboBox->OnChange=&OnActValChange;
165        GridValComboBox->OnKeyDown=&OnGridKeyDown;
166        GridValComboBox->Style=Stdctrls::csDropDownList;
167        GridValComboBox->Visible=false;
168        GridValComboBox->TabOrder=-1;
169      } else {
170        ActValCheckBox=NULL;
171        GridValCheckBox=NULL;
172        ActValComboBox=NULL;
173        GridValComboBox=NULL;
174      }
175      ActExtEdBt=new TButton(StrGrid);
176      ActExtEdBt->Parent=ActValEd->Parent;
177      ActExtEdBt->OnClick=&OnActExtEdBtClick;
178      ActExtEdBt->Visible=false;
179      ActExtEdBt->TabOrder=-1;
180      ActExtEdBt->Anchors=ActValEd->Anchors;
181      ActExtEdBt->Anchors>>akLeft;
182      ActExtEdBt->Width=80;
183      ActExtEdBt->Height=ActValEd->Height;
184      ActExtEdBt->Left=ActValEd->Left+ActValEd->Width-ActExtEdBt->Width;
185      ActExtEdBt->Top=ActValEd->Top;
186      GridExtEdBt=new TButton(StrGrid);
187      GridExtEdBt->Parent=StrGrid->Parent;
188      GridExtEdBt->OnClick=&OnActExtEdBtClick;
189      GridExtEdBt->Visible=false;
190      GridExtEdBt->TabOrder=-1;
191      ActExtValEd=new TEdit(StrGrid);
192      ActExtValEd->Parent=ActValEd->Parent;
193      ActExtValEd->OnChange=&OnActValChange;
194      ActExtValEd->OnKeyDown=&OnGridKeyDown;
195      ActExtValEd->Visible=false;
196      ActExtValEd->TabOrder=-1;
197      ActExtValEd->Anchors=ActValEd->Anchors;
198      ActExtValEd->Left=ActValEd->Left; ActExtValEd->Top=ActValEd->Top;
199      ActExtValEd->Width=ActValEd->Width-ActExtEdBt->Width-10;
200      ActExtValEd->Height=ActValEd->Height;
201    } else {
202      IAssert(PrevStrGrid->ActValEd==ActValEd);
203    }
204  }
205  TVclStrGrid::TVclStrGrid(
206   TStringGrid* _StrGrid, TEdit* _ActValEd,
207   const int& _FixedCols, const int& _FixedRows,
208   const PVclStrGrid& PrevStrGrid):
209    GridValVV(), FixedCols(_FixedCols), FixedRows(_FixedRows),
210    StrGrid(_StrGrid), GridValCheckBox(NULL), GridValComboBox(NULL),
211    SelColN(-1), SelRowN(-1), PrevSelValStr(),
212    ActValEd(_ActValEd), ActValCheckBox(NULL), ActValComboBox(NULL),
213    ActExtValEd(NULL), GridExtEdBt(NULL), ActExtEdBt(NULL),
214    ColRowPrToVarTypeH(), ColRowPrToDfValStrH(), ColRowPrToValStrVH(){
215    GridValVV.Gen(FixedCols, FixedRows);
216    InitActInput(PrevStrGrid);
217    InitGrid();
218    UnSelCell();
219    SyncToGui();
220  }
221  PVclStrGrid TVclStrGrid::New(
222   TStringGrid* StrGrid, TEdit* ActValEd,
223   const int& FixedCols, const int& FixedRows,
224   const PVclStrGrid& PrevStrGrid){
225    if (PrevStrGrid.Empty()){
226      return new TVclStrGrid(StrGrid, ActValEd, FixedCols, FixedRows, PrevStrGrid);
227    } else {
228      PVclStrGrid StrGrid=PrevStrGrid;
229      StrGrid->FixedCols=FixedCols;
230      StrGrid->FixedRows=FixedRows;
231      StrGrid->SelColN=-1;
232      StrGrid->SelRowN=-1;
233      StrGrid->PrevSelValStr="";
234      StrGrid->ColRowPrToVarTypeH.Clr();
235      StrGrid->ColRowPrToDfValStrH.Clr();
236      StrGrid->ColRowPrToValStrVH.Clr();
237      StrGrid->GridValVV.Gen(FixedCols, FixedRows);
238      StrGrid->InitGrid();
239      StrGrid->UnSelCell();
240      StrGrid->SyncToGui();
241      return StrGrid;
242    }
243  }
244  TVclStrGrid::~TVclStrGrid(){
245    if (GridValCheckBox!=NULL){GridValCheckBox->Visible=false;}
246    if (GridValComboBox!=NULL){GridValComboBox->Visible=false;}
247    if (ActValEd!=NULL){ActValEd->Visible=false;}
248    if (ActValCheckBox!=NULL){ActValCheckBox->Visible=false;}
249    if (ActValComboBox!=NULL){ActValComboBox->Visible=false;}
250    if (ActExtValEd!=NULL){ActExtValEd->Visible=false;}
251    if (ActExtEdBt!=NULL){ActExtEdBt->Visible=false;}
252    if (GridExtEdBt!=NULL){GridExtEdBt->Visible=false;}
253  }
254  void TVclStrGrid::RegExtGetStrF(
255   const TStr& ExtNm, const TExtGetStrF& ExtGetStrF){
256    TypeToGetStrFH.AddDat(ExtNm, ExtGetStrF);
257  }
258  bool TVclStrGrid::IsExtGetStrF(const TStr& ExtNm, TExtGetStrF& ExtGetStrF) const {
259    return TypeToGetStrFH.IsKeyGetDat(ExtNm, ExtGetStrF);
260  }
261  void TVclStrGrid::SyncToGui(){
262    int GridCols=TInt::GetMx(FixedCols+1, GetCols());
263    int GridRows=TInt::GetMx(FixedRows+1, GetRows());
264    if (StrGrid->FixedCols!=FixedCols){StrGrid->FixedCols=FixedCols;}
265    if (StrGrid->FixedRows!=FixedRows){StrGrid->FixedRows=FixedRows;}
266    if (StrGrid->ColCount!=GridCols){StrGrid->ColCount=GridCols;}
267    if (StrGrid->RowCount!=GridRows){StrGrid->RowCount=GridRows;}
268    for (int ColN=0; ColN<GridCols; ColN++){
269      for (int RowN=0; RowN<GridRows; RowN++){
270        if ((ColN<GetCols())&&(RowN<GetRows())){
271          TStr ValStr=GetVal(ColN, RowN);
272          if (StrGrid->Cells[ColN][RowN]!=ValStr.CStr()){
273            StrGrid->Cells[ColN][RowN]=ValStr.CStr();
274          }
275        } else {
276          StrGrid->Cells[ColN][RowN]="";
277        }
278      }
279    }
280    SelCell(SelColN, SelRowN, false);
281  }
282  void TVclStrGrid::_OnGridSetEditText(
283   const int& ColN, const int& RowN, const TStr& ValStr){
284    if ((0<=ColN)&&(ColN<GetCols())&&(0<=RowN)&&(RowN<GetRows())){
285      At(ColN, RowN)=ValStr.CStr();
286      SelCell(ColN, RowN, false);
287    }
288  }
289  void TVclStrGrid::FitColWidth(const int& MnWidth){
290    for (int ColN=0; ColN<GetCols(); ColN++){
291      int MxWidth=0;
292      for (int RowN=0; RowN<GetRows(); RowN++){
293        TStr ValStr=GetVal(ColN, RowN);
294        int Width=StrGrid->Canvas->TextWidth(ValStr.CStr());
295        MxWidth=TInt::GetMx(MxWidth, Width);
296      }
297      MxWidth=TInt::GetMx(5+MxWidth, MnWidth);
298      StrGrid->ColWidths[ColN]=MxWidth;
299    }
300    SyncToGui();
301  }
302  void TVclStrGrid::FitRowHeight(const int& MnHeight){
303    int AllMxHeight=0;
304    for (int RowN=0; RowN<GetRows(); RowN++){
305      int MxHeight=0;
306      for (int ColN=0; ColN<GetCols(); ColN++){
307        TStr ValStr=GetVal(ColN, RowN);
308        int Height=StrGrid->Canvas->TextHeight(ValStr.CStr());
309        MxHeight=TInt::GetMx(MxHeight, Height);
310      }
311      MxHeight=TInt::GetMx(1+MxHeight, MnHeight);
312      AllMxHeight=TInt::GetMx(AllMxHeight, MxHeight);
313    }
314    StrGrid->DefaultRowHeight=AllMxHeight;
315    SyncToGui();
316  }
317  void TVclStrGrid::FitColRowSize(const int& MnColWidth, const int& MnRowHeight){
318    FitColWidth(MnColWidth);
319    FitRowHeight(MnRowHeight);
320  }
321  int TVclStrGrid::SetFontSize(const int& FontSize){
322    if (FontSize>0){
323      StrGrid->Font->Size=FontSize;
324      GridValCheckBox->Font->Size=FontSize;
325      GridValComboBox->Font->Size=FontSize;
326      GridExtEdBt->Font->Size=FontSize;
327      FitColRowSize();
328    }
329    return StrGrid->Font->Size;
330  }
331  void TVclStrGrid::SetDfGridLook(){
332    SetFontSize(8);
333    for (int ColN=0; ColN<StrGrid->ColCount; ColN++){
334      TInt ColWidth;
335      if (!ColNToWidthH.IsKeyGetDat(ColN, ColWidth)){ColWidth=64;}
336      StrGrid->ColWidths[ColN]=ColWidth;
337    }
338    for (int RowN=0; RowN<StrGrid->RowCount; RowN++){
339      StrGrid->RowHeights[RowN]=22;}
340    SyncToGui();
341  }
342  bool TVclStrGrid::SelCell(
343   const int ColN, const int RowN, const bool& UpdatePrevSelValStrP){
344    if ((FixedCols<=ColN)&&(ColN<GetCols())&&(FixedRows<=RowN)&&(RowN<GetRows())){
345      if (ActValEd!=NULL){
346        SelColN=-1; SelRowN=-1;
347        TVclStrGridVarType VarType; TStrV ValStrV;
348        GetCellVarType(ColN, RowN, VarType, ValStrV);
349        if (VarType==gvtBool){ 
350          DisableCtrl(ActValEd);
351          EnableCtrl(ActValCheckBox); EnableCtrl(GridValCheckBox);
352          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
353          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
354          TRect Rect=StrGrid->CellRect(ColN, RowN);
355          GridValCheckBox->Left=3+Rect.Left&bsol;*+10*/;
356          GridValCheckBox->Top=3+Rect.Top;
357          GridValCheckBox->Width=Rect.Width()&bsol;*-10*/;
358          GridValCheckBox->Height=Rect.Height();
359          ActValCheckBox->Checked=(At(ColN, RowN)==TBool::GetYesNoStr(true));
360          GridValCheckBox->Checked=ActValCheckBox->Checked;
361        } else
362        if (VarType==gvtStrV){ 
363          DisableCtrl(ActValEd);
364          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
365          EnableCtrl(ActValComboBox); EnableCtrl(GridValComboBox);
366          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
367          TRect Rect=StrGrid->CellRect(ColN, RowN);
368          GridValComboBox->Left=3+Rect.Left&bsol;*+10*/;
369          GridValComboBox->Top=3+Rect.Top;
370          GridValComboBox->Width=Rect.Width()&bsol;*-10*/;
371          GridValComboBox->Height=Rect.Height();
372          ActValComboBox->Items->Clear(); GridValComboBox->Items->Clear();
373          for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
374            ActValComboBox->Items->Add(ValStrV[ValStrN].CStr());
375            GridValComboBox->Items->Add(ValStrV[ValStrN].CStr());
376          }
377          ActValComboBox->ItemIndex=
378           ActValComboBox->Items->IndexOf(At(ColN, RowN).CStr());
379          if ((ValStrV.Len()>0)&&(ActValComboBox->ItemIndex==-1)){
380            ActValComboBox->ItemIndex=0;}
381          GridValComboBox->ItemIndex=ActValComboBox->ItemIndex;
382        } else
383        if (VarType==gvtExt){ 
384          TStr ExtNm;
385          if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
386          else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
387          else {ExtNm="";}
388          TExtGetStrF ExtGetStrF;
389          if (IsExtGetStrF(ExtNm, ExtGetStrF)){
390            DisableCtrl(ActValEd);
391            DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
392            DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
393            EnableCtrl(ActExtValEd); EnableCtrl(ActExtEdBt); EnableCtrl(GridExtEdBt);
394            TRect Rect=StrGrid->CellRect(ColN, RowN);
395            GridExtEdBt->Left=3+Rect.Left;
396            GridExtEdBt->Top=3+Rect.Top;
397            GridExtEdBt->Width=Rect.Width();
398            GridExtEdBt->Height=Rect.Height();
399            int TxtWidth=10+StrGrid->Canvas->TextWidth(ExtNm.CStr());
400            if (GridExtEdBt->Width>2*TxtWidth){
401              GridExtEdBt->Left=Rect.Right-TxtWidth+1;
402              GridExtEdBt->Width=TxtWidth;
403            }
404            ActExtValEd->Text=At(ColN, RowN).CStr();
405            ActExtEdBt->Caption=ExtNm.CStr();
406            GridExtEdBt->Caption=ExtNm.CStr();
407          }
408        } else { 
409          EnableCtrl(ActValEd);
410          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
411          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
412          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
413          ActValEd->Text=At(ColN, RowN).CStr();
414        }
415      }
416      SelColN=ColN; SelRowN=RowN;
417      if (UpdatePrevSelValStrP){PrevSelValStr=GetVal(ColN, RowN);}
418      if (IsGridCell(ColN, RowN)){
419        StrGrid->Options<<goEditing;
420      } else {
421        StrGrid->Options>>goEditing;
422      }
423      TGridRect SelRect;
424      SelRect.Left=ColN; SelRect.Top=RowN;
425      SelRect.Right=ColN; SelRect.Bottom=RowN;
426      StrGrid->Selection=SelRect;
427      return true;
428    } else {
429      UnSelCell();
430      return false;
431    }
432  }
433  void TVclStrGrid::UnSelCell(){
434    SelColN=-1; SelRowN=-1;
435    DisableCtrl(ActValEd, true);
436    DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
437    DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
438    DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
439    if (Empty()){ActValEd->Text="No Data";}
440    else {ActValEd->Text="";}
441    StrGrid->Options>>goEditing;
442    TGridRect SelRect;
443    SelRect.Left=-1; SelRect.Top=-1;
444    SelRect.Right=-1; SelRect.Bottom=-1;
445    StrGrid->Selection=SelRect;
446  }
447  bool TVclStrGrid::IsSelCell(int& _SelColN, int& _SelRowN) const {
448    if ((FixedCols<=SelColN)&&(SelColN<GetCols())&&
449     (FixedRows<=SelRowN)&&(SelRowN<GetRows())){
450      _SelColN=SelColN; _SelRowN=SelRowN; return true;
451    } else {
452      return false;
453    }
454  }
455  TStr TVclStrGrid::GetVal(const int& ColN, const int& RowN){
456    TStr ValStr=GridValVV.At(ColN, RowN);
457    if ((FixedCols<=ColN)&&(FixedRows<=RowN)){
458      TVclStrGridVarType VarType; TStrV ValStrV;
459      GetCellVarType(ColN, RowN, VarType, ValStrV);
460      if (VarType==gvtBool){ 
461        ValStr=TBool::GetYesNoStr(ValStr==TBool::GetYesNoStr(true));
462      } else
463      if (VarType==gvtStrV){ 
464        if (!ValStrV.IsIn(ValStr)){
465          if (ValStrV.Len()>0){ValStr=ValStrV[0];} else {ValStr="";}
466        }
467      } else
468      if (VarType==gvtFlt){ 
469        if (!ValStr.IsFlt()){ValStr="0";}
470      } else
471      if (VarType==gvtInt){ 
472        if (!ValStr.IsInt()){ValStr="0";}
473      } else
474      if (VarType==gvtExt){ 
475        TStr ExtNm;
476        if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
477        else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
478        else {ExtNm="";}
479        TExtGetStrF ExtGetStrF;
480        if (IsExtGetStrF(ExtNm, ExtGetStrF)){
481          TStr NewValStr; bool OkP;
482          (*ExtGetStrF())(true, ValStr, NewValStr, OkP);
483          if (OkP){ValStr=NewValStr;}
484        }
485      }
486      GridValVV.PutXY(ColN, RowN, ValStr);
487    }
488    return ValStr;
489  }
490  void TVclStrGrid::DelCol(const int& ColN){
491    GridValVV.DelX(ColN);
492    SyncToGui();
493  }
494  void TVclStrGrid::DelRow(const int& DelRowN){
495    ColRowPrToVarTypeH.DelIfKey(TIntPr(1, DelRowN));
496    ColRowPrToDfValStrH.DelIfKey(TIntPr(1, DelRowN));
497    ColRowPrToValStrVH.DelIfKey(TIntPr(1, DelRowN));
498    for (int RowN=DelRowN+1; RowN<GetRows(); RowN++){
499      TInt VarType;
500      if (ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), VarType)){
501        ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN-1), VarType);
502        ColRowPrToVarTypeH.DelKey(TIntPr(1, RowN));
503      }
504      TStr DfValStr;
505      if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), DfValStr)){
506        ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN-1), DfValStr);
507        ColRowPrToDfValStrH.DelKey(TIntPr(1, RowN));
508      }
509      TStrV ValStrV;
510      if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){
511        ColRowPrToValStrVH.AddDat(TIntPr(1, RowN-1), ValStrV);
512        ColRowPrToValStrVH.DelKey(TIntPr(1, RowN));
513      }
514    }
515    GridValVV.DelY(DelRowN);
516    SyncToGui();
517  }
518  void TVclStrGrid::GetCellVarType(
519   const int& ColN, const int& RowN,
520   TVclStrGridVarType& VarType, TStrV& ValStrV) const {
521    TInt _VarType;
522    if ((FixedRows==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(ColN, 1), _VarType))){
<span onclick='openModal()' class='match'>523      VarType=TVclStrGridVarType(int(_VarType));
524      if (VarType==gvtStrV){
525        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(ColN, 1), ValStrV)){}
</span>526        else {ValStrV.Clr();}
527      }
528    } else
529    if ((FixedCols==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), _VarType))){
530      VarType=TVclStrGridVarType(int(_VarType));
531      if (VarType==gvtStrV){
532        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){}
533        else {ValStrV.Clr();}
534      }
535    } else {
536      VarType=gvtUndef; ValStrV.Clr();
537    }
538  }
539  bool TVclStrGrid::IsGridCell(const int& ColN, const int& RowN) const {
540    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
541    return (VarType!=gvtBool)&&(VarType!=gvtStrV);
542  }
543  int TVclStrGrid::AddColVar(
544   const TStr& VarNm, const int& ColWidth,
545   const TVclStrGridVarType& VarType,
546   const TStr& DfValStr, const TStrV& ValStrV){
547    IAssert(FixedRows==1);
548    GridValVV.AddXDim();
549    int ColN=GetCols()-1;
550    At(ColN, 0)=VarNm;
551    if (ColWidth!=-1){
552      ColNToWidthH.AddDat(ColN, ColWidth);
553      StrGrid->ColCount=GetCols();
554      StrGrid->ColWidths[ColN]=ColWidth;
555    }
556    ColRowPrToVarTypeH.AddDat(TIntPr(ColN, 1), VarType);
557    if (!DfValStr.Empty()){
558      ColRowPrToDfValStrH.AddDat(TIntPr(ColN, 1), DfValStr);}
559    if (!ValStrV.Empty()){
560      ColRowPrToValStrVH.AddDat(TIntPr(ColN, 1), ValStrV);}
561    SyncToGui();
562    int VarN=GetCols()-1-FixedCols;
563    return VarN;
564  }
565  int TVclStrGrid::AddColVar(
566   const TStr& VarNm, const int& ColWidth,
567   const TVclStrGridVarType& VarType,
568   const TStr& DfValStr, const TStr& ValStrVStr, const char& SplitCh){
569    TStrV ValStrV; ValStrVStr.SplitOnAllCh(SplitCh, ValStrV);
570    return AddColVar(VarNm, ColWidth, VarType, DfValStr, ValStrV);
571  }
572  int TVclStrGrid::AddRowVar(
573   const TStr& VarNm,
574   const TVclStrGridVarType& VarType,
575   const TStr& DfValStr, const TStrV& ValStrV){
576    IAssert(FixedCols==1);
577    GridValVV.AddYDim();
578    At(0, GetRows()-1)=VarNm;
579    int RowN=GetRows()-1;
580    ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN), VarType);
581    if (!DfValStr.Empty()){
582      ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN), DfValStr);}
583    if (!ValStrV.Empty()){
584      ColRowPrToValStrVH.AddDat(TIntPr(1, RowN), ValStrV);}
585    SyncToGui();
586    int VarN=GetRows()-1-FixedRows;
587    return VarN;
588  }
589  TStr TVclStrGrid::GetDfColVarVal(const int& ColVarN){
590    int ColN=FixedCols+ColVarN;
591    TStr DfValStr;
592    if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), DfValStr)){
593      if ((!DfValStr.Empty())&&(DfValStr.LastCh()=='#')){
594        TStr SubDfValStr=DfValStr.GetSubStr(0, DfValStr.Len()-2);
595        DfValStr=GetUniqueColVarVal(ColVarN, SubDfValStr);
596      }
597      TVclStrGridVarType VarType; GetCellVarType(ColN, -1, VarType);
598      if (VarType==gvtExt){DfValStr="";}
599    }
600    return DfValStr;
601  }
602  int TVclStrGrid::AddColRec(){
603    GridValVV.AddXDim();
604    SyncToGui();
605    int ColRecN=GetCols()-1-FixedCols;
606    return ColRecN;
607  }
608  int TVclStrGrid::AddRowRec(){
609    GridValVV.AddYDim();
610    int RowN=GetRows()-1;
611    int RowRecN=GetRows()-1-FixedRows;
612    for (int ColVarN=0; ColVarN<GetColVars(); ColVarN++){
613      PutColVarVal(ColVarN, RowRecN, GetDfColVarVal(ColVarN));}
614    SyncToGui(); SetFocus();
615    SelCell(FixedCols, RowN);
616    return RowRecN;
617  }
618  int TVclStrGrid::AddRowRec(const TStr& VarNm, const TStrV& ValStrV){
619    int RecN=AddRowRec();
620    if (!VarNm.Empty()){RowVarNm(RecN)=VarNm;}
621    for (int VarN=0; VarN<ValStrV.Len(); VarN++){
622      ColVarVal(VarN, RecN)=ValStrV[VarN];}
623    SyncToGui();
624    return RecN;
625  }
626  TStr TVclStrGrid::GetUniqueColVarVal(const int& ColVarN, const TStr& PfxValStr){
627    int RowRecs=GetRowRecs();
628    TStrH VarValH(RowRecs);
629    for (int RowRecN=0; RowRecN<RowRecs; RowRecN++){
630      VarValH.AddDat(ColVarVal(ColVarN, RowRecN));}
631    int ValStrN=1;
632    forever{
633      TStr ValStr=PfxValStr+TInt::GetStr(ValStrN);
634      if (!VarValH.IsKey(ValStr)){return ValStr;}
635      ValStrN++;
636    }
637  }
638  void TVclStrGrid::DelSelRowRec(){
639    int DelColN; int DelRowN;
640    if (IsSelCell(DelColN, DelRowN)){
641      DelRow(DelRowN);
642      SelCell(DelColN, DelRowN);
643      if (!IsSelCell()){
644        SelCell(DelColN, DelRowN-1);}
645      SyncToGui();
646    }
647    SetFocus();
648  }
649  void TVclStrGrid::CopySelRowRec(){
650    int SrcColN; int SrcRowN;
651    if (IsSelCell(SrcColN, SrcRowN)){
652      int DstRecN=AddRowRec();
653      int DstRowN=GetRowNFromRecN(DstRecN);
654      for (int ColN=0; ColN<GetCols(); ColN++){
655        At(ColN, DstRowN)=GetVal(ColN, SrcRowN);}
656      SelCell(GetFixedCols(), GetRows()-1);
657      SyncToGui();
658    }
659    SetFocus();
660  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</h3>
            <pre><code>1  #include "gridvcl.h"
2  void __fastcall TVclStrGrid::OnGridKeyDown(
3   TObject *Sender, WORD &Key, TShiftState Shift){
4    if (Key==27){
5      int ColN; int RowN;
6      if (IsSelCell(ColN, RowN)){
7        PutVal(ColN, RowN, PrevSelValStr);
8      }
9    }
10    if (Key==' '){
11      int ColN; int RowN;
12      if (IsSelCell(ColN, RowN)){
13        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
14        if (VarType==gvtBool){ 
15          ActValCheckBox->Checked=!ActValCheckBox->Checked;
16        } else
17        if (VarType==gvtStrV){ 
18          if (ActValComboBox->Items->Count>0){
19            ActValComboBox->ItemIndex=
20             (ActValComboBox->ItemIndex+1)%ActValComboBox->Items->Count;
21            OnActValChange(ActValComboBox);
22          }
23        }
24      }
25    }
26  }
27  void __fastcall TVclStrGrid::OnGridMouseDown(
28   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
29    int ColN; int RowN; StrGrid->MouseToCell(X, Y, ColN, RowN);
30    SelCell(ColN, RowN);
31  }
32  void __fastcall TVclStrGrid::OnGridMouseUp(
33   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
34    SyncToGui();
35  }
36  void __fastcall TVclStrGrid::OnGridSelectCell(
37   TObject *Sender, int ACol, int ARow, bool &CanSelect){
38    CanSelect=SelCell(ACol, ARow);
39    SyncToGui();
40  }
41  void __fastcall TVclStrGrid::OnGridSetEditText(
42   TObject *Sender, int ACol, int ARow, const AnsiString Value){
43    _OnGridSetEditText(ACol, ARow, Value.c_str());
44  }
45  void __fastcall TVclStrGrid::OnGridGetEditMask(
46   TObject *Sender, int ColN, int RowN, AnsiString& MaskStr){
47    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
48    if (VarType==gvtStrMask){
49      MaskStr="#0.9;1; ";
50    } else {
51      MaskStr="";
52    }
53  }
54  void __fastcall TVclStrGrid::OnGridTopLeftChanged(TObject *Sender){
55    SyncToGui();
56  }
57  void __fastcall TVclStrGrid::OnActValChange(TObject *Sender){
58    TStr ValStr;
59    if (Sender==ActValEd){
60      ValStr=ActValEd->Text.c_str();
61      int ColN; int RowN;
62      if (IsSelCell(ColN, RowN)){
63        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
64      }
65    } else
66    if (Sender==ActValCheckBox){
67      ValStr=TBool::GetYesNoStr(ActValCheckBox->Checked);
68    } else
69    if (Sender==GridValCheckBox){
70      ValStr=TBool::GetYesNoStr(GridValCheckBox->Checked);
71    } else
72    if (Sender==ActValComboBox){
73      ValStr=ActValComboBox->Text.c_str();
74    } else
75    if (Sender==GridValComboBox){
76      ValStr=GridValComboBox->Text.c_str();
77    } else
78    if (Sender==ActExtValEd){
79      ValStr=ActExtValEd->Text.c_str();
80    } else {
81      Fail;
82    }
83    int ColN; int RowN;
84    if (IsSelCell(ColN, RowN)){
85      PutVal(ColN, RowN, ValStr);
86    }
87  }
88  void __fastcall TVclStrGrid::OnActExtEdBtClick(TObject *Sender){
89    TStr ExtNm=ActExtEdBt->Caption.c_str();
90    TExtGetStrF ExtGetStrF;
91    if (IsExtGetStrF(ExtNm, ExtGetStrF)){
92      int ColN; int RowN;
93      if (IsSelCell(ColN, RowN)){
94        TStr PrevValStr=GetVal(ColN, RowN);
95        TStr NewValStr; bool OkP;
96        (*ExtGetStrF())(false, PrevValStr, NewValStr, OkP);
97        if (OkP){
98          ActExtValEd->Text=NewValStr.CStr();
99        }
100      }
101    }
102  }
103  void TVclStrGrid::EnableCtrl(TControl* Control, const bool& VisibleP){
104    if (Control!=NULL){
105      if (!Control->Enabled){Control->Enabled=true;}
106      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
107    }
108  }
109  void TVclStrGrid::DisableCtrl(TControl* Control, const bool& VisibleP){
110    if (Control!=NULL){
111      if (Control->Enabled){Control->Enabled=false;}
112      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
113    }
114  }
115  void TVclStrGrid::InitGrid(){
116    IAssert(StrGrid!=NULL);
117    StrGrid->ScrollBars=ssBoth;
118    StrGrid->Options.Clear();
119    StrGrid->Options<<goFixedVertLine<<goFixedHorzLine;
120    StrGrid->Options<<goVertLine<<goHorzLine;
121    StrGrid->Options<<goDrawFocusSelected<<goColSizing;
122    StrGrid->Options<<goTabs;
123    StrGrid->OnKeyDown=&OnGridKeyDown;
124    StrGrid->OnMouseDown=&OnGridMouseDown;
125    StrGrid->OnMouseUp=&OnGridMouseUp;
126    StrGrid->OnSelectCell=&OnGridSelectCell;
127    StrGrid->OnSetEditText=&OnGridSetEditText;
128    StrGrid->OnGetEditMask=&OnGridGetEditMask;
129    StrGrid->OnTopLeftChanged=&OnGridTopLeftChanged;
130  }
131  void TVclStrGrid::InitActInput(const PVclStrGrid& PrevStrGrid){
132    if (PrevStrGrid.Empty()){
133      if (ActValEd!=NULL){
134        ActValEd->OnChange=&OnActValChange;
135        ActValEd->OnKeyDown=&OnGridKeyDown;
136        ActValCheckBox=new TCheckBox(StrGrid);
137        ActValCheckBox->Parent=ActValEd->Parent;
138        ActValCheckBox->OnClick=&OnActValChange;
139        ActValCheckBox->OnKeyDown=&OnGridKeyDown;
140        ActValCheckBox->Visible=false;
141        ActValCheckBox->TabOrder=-1;
142        ActValCheckBox->Anchors=ActValEd->Anchors;
143        ActValCheckBox->Left=ActValEd->Left; ActValCheckBox->Top=ActValEd->Top;
144        ActValCheckBox->Width=ActValEd->Width; ActValCheckBox->Height=ActValEd->Height;
145        GridValCheckBox=new TCheckBox(StrGrid);
146        GridValCheckBox->Parent=StrGrid->Parent;
147        GridValCheckBox->OnClick=&OnActValChange;
148        GridValCheckBox->OnKeyDown=&OnGridKeyDown;
149        GridValCheckBox->Visible=false;
150        GridValCheckBox->TabOrder=-1;
151        GridValCheckBox->Color=clActiveCaption;
152        ActValComboBox=new TComboBox(StrGrid);
153        ActValComboBox->Parent=ActValEd->Parent;
154        ActValComboBox->OnChange=&OnActValChange;
155        ActValComboBox->OnKeyDown=&OnGridKeyDown;
156        ActValComboBox->Style=Stdctrls::csDropDownList;
157        ActValComboBox->Visible=false;
158        ActValComboBox->TabOrder=-1;
159        ActValComboBox->Anchors=ActValEd->Anchors;
160        ActValComboBox->Left=ActValEd->Left; ActValComboBox->Top=ActValEd->Top;
161        ActValComboBox->Width=ActValEd->Width; ActValComboBox->Height=ActValEd->Height;
162        GridValComboBox=new TComboBox(StrGrid);
163        GridValComboBox->Parent=StrGrid->Parent;
164        GridValComboBox->OnChange=&OnActValChange;
165        GridValComboBox->OnKeyDown=&OnGridKeyDown;
166        GridValComboBox->Style=Stdctrls::csDropDownList;
167        GridValComboBox->Visible=false;
168        GridValComboBox->TabOrder=-1;
169      } else {
170        ActValCheckBox=NULL;
171        GridValCheckBox=NULL;
172        ActValComboBox=NULL;
173        GridValComboBox=NULL;
174      }
175      ActExtEdBt=new TButton(StrGrid);
176      ActExtEdBt->Parent=ActValEd->Parent;
177      ActExtEdBt->OnClick=&OnActExtEdBtClick;
178      ActExtEdBt->Visible=false;
179      ActExtEdBt->TabOrder=-1;
180      ActExtEdBt->Anchors=ActValEd->Anchors;
181      ActExtEdBt->Anchors>>akLeft;
182      ActExtEdBt->Width=80;
183      ActExtEdBt->Height=ActValEd->Height;
184      ActExtEdBt->Left=ActValEd->Left+ActValEd->Width-ActExtEdBt->Width;
185      ActExtEdBt->Top=ActValEd->Top;
186      GridExtEdBt=new TButton(StrGrid);
187      GridExtEdBt->Parent=StrGrid->Parent;
188      GridExtEdBt->OnClick=&OnActExtEdBtClick;
189      GridExtEdBt->Visible=false;
190      GridExtEdBt->TabOrder=-1;
191      ActExtValEd=new TEdit(StrGrid);
192      ActExtValEd->Parent=ActValEd->Parent;
193      ActExtValEd->OnChange=&OnActValChange;
194      ActExtValEd->OnKeyDown=&OnGridKeyDown;
195      ActExtValEd->Visible=false;
196      ActExtValEd->TabOrder=-1;
197      ActExtValEd->Anchors=ActValEd->Anchors;
198      ActExtValEd->Left=ActValEd->Left; ActExtValEd->Top=ActValEd->Top;
199      ActExtValEd->Width=ActValEd->Width-ActExtEdBt->Width-10;
200      ActExtValEd->Height=ActValEd->Height;
201    } else {
202      IAssert(PrevStrGrid->ActValEd==ActValEd);
203    }
204  }
205  TVclStrGrid::TVclStrGrid(
206   TStringGrid* _StrGrid, TEdit* _ActValEd,
207   const int& _FixedCols, const int& _FixedRows,
208   const PVclStrGrid& PrevStrGrid):
209    GridValVV(), FixedCols(_FixedCols), FixedRows(_FixedRows),
210    StrGrid(_StrGrid), GridValCheckBox(NULL), GridValComboBox(NULL),
211    SelColN(-1), SelRowN(-1), PrevSelValStr(),
212    ActValEd(_ActValEd), ActValCheckBox(NULL), ActValComboBox(NULL),
213    ActExtValEd(NULL), GridExtEdBt(NULL), ActExtEdBt(NULL),
214    ColRowPrToVarTypeH(), ColRowPrToDfValStrH(), ColRowPrToValStrVH(){
215    GridValVV.Gen(FixedCols, FixedRows);
216    InitActInput(PrevStrGrid);
217    InitGrid();
218    UnSelCell();
219    SyncToGui();
220  }
221  PVclStrGrid TVclStrGrid::New(
222   TStringGrid* StrGrid, TEdit* ActValEd,
223   const int& FixedCols, const int& FixedRows,
224   const PVclStrGrid& PrevStrGrid){
225    if (PrevStrGrid.Empty()){
226      return new TVclStrGrid(StrGrid, ActValEd, FixedCols, FixedRows, PrevStrGrid);
227    } else {
228      PVclStrGrid StrGrid=PrevStrGrid;
229      StrGrid->FixedCols=FixedCols;
230      StrGrid->FixedRows=FixedRows;
231      StrGrid->SelColN=-1;
232      StrGrid->SelRowN=-1;
233      StrGrid->PrevSelValStr="";
234      StrGrid->ColRowPrToVarTypeH.Clr();
235      StrGrid->ColRowPrToDfValStrH.Clr();
236      StrGrid->ColRowPrToValStrVH.Clr();
237      StrGrid->GridValVV.Gen(FixedCols, FixedRows);
238      StrGrid->InitGrid();
239      StrGrid->UnSelCell();
240      StrGrid->SyncToGui();
241      return StrGrid;
242    }
243  }
244  TVclStrGrid::~TVclStrGrid(){
245    if (GridValCheckBox!=NULL){GridValCheckBox->Visible=false;}
246    if (GridValComboBox!=NULL){GridValComboBox->Visible=false;}
247    if (ActValEd!=NULL){ActValEd->Visible=false;}
248    if (ActValCheckBox!=NULL){ActValCheckBox->Visible=false;}
249    if (ActValComboBox!=NULL){ActValComboBox->Visible=false;}
250    if (ActExtValEd!=NULL){ActExtValEd->Visible=false;}
251    if (ActExtEdBt!=NULL){ActExtEdBt->Visible=false;}
252    if (GridExtEdBt!=NULL){GridExtEdBt->Visible=false;}
253  }
254  void TVclStrGrid::RegExtGetStrF(
255   const TStr& ExtNm, const TExtGetStrF& ExtGetStrF){
256    TypeToGetStrFH.AddDat(ExtNm, ExtGetStrF);
257  }
258  bool TVclStrGrid::IsExtGetStrF(const TStr& ExtNm, TExtGetStrF& ExtGetStrF) const {
259    return TypeToGetStrFH.IsKeyGetDat(ExtNm, ExtGetStrF);
260  }
261  void TVclStrGrid::SyncToGui(){
262    int GridCols=TInt::GetMx(FixedCols+1, GetCols());
263    int GridRows=TInt::GetMx(FixedRows+1, GetRows());
264    if (StrGrid->FixedCols!=FixedCols){StrGrid->FixedCols=FixedCols;}
265    if (StrGrid->FixedRows!=FixedRows){StrGrid->FixedRows=FixedRows;}
266    if (StrGrid->ColCount!=GridCols){StrGrid->ColCount=GridCols;}
267    if (StrGrid->RowCount!=GridRows){StrGrid->RowCount=GridRows;}
268    for (int ColN=0; ColN<GridCols; ColN++){
269      for (int RowN=0; RowN<GridRows; RowN++){
270        if ((ColN<GetCols())&&(RowN<GetRows())){
271          TStr ValStr=GetVal(ColN, RowN);
272          if (StrGrid->Cells[ColN][RowN]!=ValStr.CStr()){
273            StrGrid->Cells[ColN][RowN]=ValStr.CStr();
274          }
275        } else {
276          StrGrid->Cells[ColN][RowN]="";
277        }
278      }
279    }
280    SelCell(SelColN, SelRowN, false);
281  }
282  void TVclStrGrid::_OnGridSetEditText(
283   const int& ColN, const int& RowN, const TStr& ValStr){
284    if ((0<=ColN)&&(ColN<GetCols())&&(0<=RowN)&&(RowN<GetRows())){
285      At(ColN, RowN)=ValStr.CStr();
286      SelCell(ColN, RowN, false);
287    }
288  }
289  void TVclStrGrid::FitColWidth(const int& MnWidth){
290    for (int ColN=0; ColN<GetCols(); ColN++){
291      int MxWidth=0;
292      for (int RowN=0; RowN<GetRows(); RowN++){
293        TStr ValStr=GetVal(ColN, RowN);
294        int Width=StrGrid->Canvas->TextWidth(ValStr.CStr());
295        MxWidth=TInt::GetMx(MxWidth, Width);
296      }
297      MxWidth=TInt::GetMx(5+MxWidth, MnWidth);
298      StrGrid->ColWidths[ColN]=MxWidth;
299    }
300    SyncToGui();
301  }
302  void TVclStrGrid::FitRowHeight(const int& MnHeight){
303    int AllMxHeight=0;
304    for (int RowN=0; RowN<GetRows(); RowN++){
305      int MxHeight=0;
306      for (int ColN=0; ColN<GetCols(); ColN++){
307        TStr ValStr=GetVal(ColN, RowN);
308        int Height=StrGrid->Canvas->TextHeight(ValStr.CStr());
309        MxHeight=TInt::GetMx(MxHeight, Height);
310      }
311      MxHeight=TInt::GetMx(1+MxHeight, MnHeight);
312      AllMxHeight=TInt::GetMx(AllMxHeight, MxHeight);
313    }
314    StrGrid->DefaultRowHeight=AllMxHeight;
315    SyncToGui();
316  }
317  void TVclStrGrid::FitColRowSize(const int& MnColWidth, const int& MnRowHeight){
318    FitColWidth(MnColWidth);
319    FitRowHeight(MnRowHeight);
320  }
321  int TVclStrGrid::SetFontSize(const int& FontSize){
322    if (FontSize>0){
323      StrGrid->Font->Size=FontSize;
324      GridValCheckBox->Font->Size=FontSize;
325      GridValComboBox->Font->Size=FontSize;
326      GridExtEdBt->Font->Size=FontSize;
327      FitColRowSize();
328    }
329    return StrGrid->Font->Size;
330  }
331  void TVclStrGrid::SetDfGridLook(){
332    SetFontSize(8);
333    for (int ColN=0; ColN<StrGrid->ColCount; ColN++){
334      TInt ColWidth;
335      if (!ColNToWidthH.IsKeyGetDat(ColN, ColWidth)){ColWidth=64;}
336      StrGrid->ColWidths[ColN]=ColWidth;
337    }
338    for (int RowN=0; RowN<StrGrid->RowCount; RowN++){
339      StrGrid->RowHeights[RowN]=22;}
340    SyncToGui();
341  }
342  bool TVclStrGrid::SelCell(
343   const int ColN, const int RowN, const bool& UpdatePrevSelValStrP){
344    if ((FixedCols<=ColN)&&(ColN<GetCols())&&(FixedRows<=RowN)&&(RowN<GetRows())){
345      if (ActValEd!=NULL){
346        SelColN=-1; SelRowN=-1;
347        TVclStrGridVarType VarType; TStrV ValStrV;
348        GetCellVarType(ColN, RowN, VarType, ValStrV);
349        if (VarType==gvtBool){ 
350          DisableCtrl(ActValEd);
351          EnableCtrl(ActValCheckBox); EnableCtrl(GridValCheckBox);
352          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
353          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
354          TRect Rect=StrGrid->CellRect(ColN, RowN);
355          GridValCheckBox->Left=3+Rect.Left&bsol;*+10*/;
356          GridValCheckBox->Top=3+Rect.Top;
357          GridValCheckBox->Width=Rect.Width()&bsol;*-10*/;
358          GridValCheckBox->Height=Rect.Height();
359          ActValCheckBox->Checked=(At(ColN, RowN)==TBool::GetYesNoStr(true));
360          GridValCheckBox->Checked=ActValCheckBox->Checked;
361        } else
362        if (VarType==gvtStrV){ 
363          DisableCtrl(ActValEd);
364          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
365          EnableCtrl(ActValComboBox); EnableCtrl(GridValComboBox);
366          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
367          TRect Rect=StrGrid->CellRect(ColN, RowN);
368          GridValComboBox->Left=3+Rect.Left&bsol;*+10*/;
369          GridValComboBox->Top=3+Rect.Top;
370          GridValComboBox->Width=Rect.Width()&bsol;*-10*/;
371          GridValComboBox->Height=Rect.Height();
372          ActValComboBox->Items->Clear(); GridValComboBox->Items->Clear();
373          for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
374            ActValComboBox->Items->Add(ValStrV[ValStrN].CStr());
375            GridValComboBox->Items->Add(ValStrV[ValStrN].CStr());
376          }
377          ActValComboBox->ItemIndex=
378           ActValComboBox->Items->IndexOf(At(ColN, RowN).CStr());
379          if ((ValStrV.Len()>0)&&(ActValComboBox->ItemIndex==-1)){
380            ActValComboBox->ItemIndex=0;}
381          GridValComboBox->ItemIndex=ActValComboBox->ItemIndex;
382        } else
383        if (VarType==gvtExt){ 
384          TStr ExtNm;
385          if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
386          else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
387          else {ExtNm="";}
388          TExtGetStrF ExtGetStrF;
389          if (IsExtGetStrF(ExtNm, ExtGetStrF)){
390            DisableCtrl(ActValEd);
391            DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
392            DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
393            EnableCtrl(ActExtValEd); EnableCtrl(ActExtEdBt); EnableCtrl(GridExtEdBt);
394            TRect Rect=StrGrid->CellRect(ColN, RowN);
395            GridExtEdBt->Left=3+Rect.Left;
396            GridExtEdBt->Top=3+Rect.Top;
397            GridExtEdBt->Width=Rect.Width();
398            GridExtEdBt->Height=Rect.Height();
399            int TxtWidth=10+StrGrid->Canvas->TextWidth(ExtNm.CStr());
400            if (GridExtEdBt->Width>2*TxtWidth){
401              GridExtEdBt->Left=Rect.Right-TxtWidth+1;
402              GridExtEdBt->Width=TxtWidth;
403            }
404            ActExtValEd->Text=At(ColN, RowN).CStr();
405            ActExtEdBt->Caption=ExtNm.CStr();
406            GridExtEdBt->Caption=ExtNm.CStr();
407          }
408        } else { 
409          EnableCtrl(ActValEd);
410          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
411          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
412          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
413          ActValEd->Text=At(ColN, RowN).CStr();
414        }
415      }
416      SelColN=ColN; SelRowN=RowN;
417      if (UpdatePrevSelValStrP){PrevSelValStr=GetVal(ColN, RowN);}
418      if (IsGridCell(ColN, RowN)){
419        StrGrid->Options<<goEditing;
420      } else {
421        StrGrid->Options>>goEditing;
422      }
423      TGridRect SelRect;
424      SelRect.Left=ColN; SelRect.Top=RowN;
425      SelRect.Right=ColN; SelRect.Bottom=RowN;
426      StrGrid->Selection=SelRect;
427      return true;
428    } else {
429      UnSelCell();
430      return false;
431    }
432  }
433  void TVclStrGrid::UnSelCell(){
434    SelColN=-1; SelRowN=-1;
435    DisableCtrl(ActValEd, true);
436    DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
437    DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
438    DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
439    if (Empty()){ActValEd->Text="No Data";}
440    else {ActValEd->Text="";}
441    StrGrid->Options>>goEditing;
442    TGridRect SelRect;
443    SelRect.Left=-1; SelRect.Top=-1;
444    SelRect.Right=-1; SelRect.Bottom=-1;
445    StrGrid->Selection=SelRect;
446  }
447  bool TVclStrGrid::IsSelCell(int& _SelColN, int& _SelRowN) const {
448    if ((FixedCols<=SelColN)&&(SelColN<GetCols())&&
449     (FixedRows<=SelRowN)&&(SelRowN<GetRows())){
450      _SelColN=SelColN; _SelRowN=SelRowN; return true;
451    } else {
452      return false;
453    }
454  }
455  TStr TVclStrGrid::GetVal(const int& ColN, const int& RowN){
456    TStr ValStr=GridValVV.At(ColN, RowN);
457    if ((FixedCols<=ColN)&&(FixedRows<=RowN)){
458      TVclStrGridVarType VarType; TStrV ValStrV;
459      GetCellVarType(ColN, RowN, VarType, ValStrV);
460      if (VarType==gvtBool){ 
461        ValStr=TBool::GetYesNoStr(ValStr==TBool::GetYesNoStr(true));
462      } else
463      if (VarType==gvtStrV){ 
464        if (!ValStrV.IsIn(ValStr)){
465          if (ValStrV.Len()>0){ValStr=ValStrV[0];} else {ValStr="";}
466        }
467      } else
468      if (VarType==gvtFlt){ 
469        if (!ValStr.IsFlt()){ValStr="0";}
470      } else
471      if (VarType==gvtInt){ 
472        if (!ValStr.IsInt()){ValStr="0";}
473      } else
474      if (VarType==gvtExt){ 
475        TStr ExtNm;
476        if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
477        else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
478        else {ExtNm="";}
479        TExtGetStrF ExtGetStrF;
480        if (IsExtGetStrF(ExtNm, ExtGetStrF)){
481          TStr NewValStr; bool OkP;
482          (*ExtGetStrF())(true, ValStr, NewValStr, OkP);
483          if (OkP){ValStr=NewValStr;}
484        }
485      }
486      GridValVV.PutXY(ColN, RowN, ValStr);
487    }
488    return ValStr;
489  }
490  void TVclStrGrid::DelCol(const int& ColN){
491    GridValVV.DelX(ColN);
492    SyncToGui();
493  }
494  void TVclStrGrid::DelRow(const int& DelRowN){
495    ColRowPrToVarTypeH.DelIfKey(TIntPr(1, DelRowN));
496    ColRowPrToDfValStrH.DelIfKey(TIntPr(1, DelRowN));
497    ColRowPrToValStrVH.DelIfKey(TIntPr(1, DelRowN));
498    for (int RowN=DelRowN+1; RowN<GetRows(); RowN++){
499      TInt VarType;
500      if (ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), VarType)){
501        ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN-1), VarType);
502        ColRowPrToVarTypeH.DelKey(TIntPr(1, RowN));
503      }
504      TStr DfValStr;
505      if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), DfValStr)){
506        ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN-1), DfValStr);
507        ColRowPrToDfValStrH.DelKey(TIntPr(1, RowN));
508      }
509      TStrV ValStrV;
510      if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){
511        ColRowPrToValStrVH.AddDat(TIntPr(1, RowN-1), ValStrV);
512        ColRowPrToValStrVH.DelKey(TIntPr(1, RowN));
513      }
514    }
515    GridValVV.DelY(DelRowN);
516    SyncToGui();
517  }
518  void TVclStrGrid::GetCellVarType(
519   const int& ColN, const int& RowN,
520   TVclStrGridVarType& VarType, TStrV& ValStrV) const {
521    TInt _VarType;
522    if ((FixedRows==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(ColN, 1), _VarType))){
523      VarType=TVclStrGridVarType(int(_VarType));
524      if (VarType==gvtStrV){
525        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(ColN, 1), ValStrV)){}
526        else {ValStrV.Clr();}
527      }
528    } else
529    if ((FixedCols==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), _VarType))){
<span onclick='openModal()' class='match'>530      VarType=TVclStrGridVarType(int(_VarType));
531      if (VarType==gvtStrV){
532        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){}
</span>533        else {ValStrV.Clr();}
534      }
535    } else {
536      VarType=gvtUndef; ValStrV.Clr();
537    }
538  }
539  bool TVclStrGrid::IsGridCell(const int& ColN, const int& RowN) const {
540    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
541    return (VarType!=gvtBool)&&(VarType!=gvtStrV);
542  }
543  int TVclStrGrid::AddColVar(
544   const TStr& VarNm, const int& ColWidth,
545   const TVclStrGridVarType& VarType,
546   const TStr& DfValStr, const TStrV& ValStrV){
547    IAssert(FixedRows==1);
548    GridValVV.AddXDim();
549    int ColN=GetCols()-1;
550    At(ColN, 0)=VarNm;
551    if (ColWidth!=-1){
552      ColNToWidthH.AddDat(ColN, ColWidth);
553      StrGrid->ColCount=GetCols();
554      StrGrid->ColWidths[ColN]=ColWidth;
555    }
556    ColRowPrToVarTypeH.AddDat(TIntPr(ColN, 1), VarType);
557    if (!DfValStr.Empty()){
558      ColRowPrToDfValStrH.AddDat(TIntPr(ColN, 1), DfValStr);}
559    if (!ValStrV.Empty()){
560      ColRowPrToValStrVH.AddDat(TIntPr(ColN, 1), ValStrV);}
561    SyncToGui();
562    int VarN=GetCols()-1-FixedCols;
563    return VarN;
564  }
565  int TVclStrGrid::AddColVar(
566   const TStr& VarNm, const int& ColWidth,
567   const TVclStrGridVarType& VarType,
568   const TStr& DfValStr, const TStr& ValStrVStr, const char& SplitCh){
569    TStrV ValStrV; ValStrVStr.SplitOnAllCh(SplitCh, ValStrV);
570    return AddColVar(VarNm, ColWidth, VarType, DfValStr, ValStrV);
571  }
572  int TVclStrGrid::AddRowVar(
573   const TStr& VarNm,
574   const TVclStrGridVarType& VarType,
575   const TStr& DfValStr, const TStrV& ValStrV){
576    IAssert(FixedCols==1);
577    GridValVV.AddYDim();
578    At(0, GetRows()-1)=VarNm;
579    int RowN=GetRows()-1;
580    ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN), VarType);
581    if (!DfValStr.Empty()){
582      ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN), DfValStr);}
583    if (!ValStrV.Empty()){
584      ColRowPrToValStrVH.AddDat(TIntPr(1, RowN), ValStrV);}
585    SyncToGui();
586    int VarN=GetRows()-1-FixedRows;
587    return VarN;
588  }
589  TStr TVclStrGrid::GetDfColVarVal(const int& ColVarN){
590    int ColN=FixedCols+ColVarN;
591    TStr DfValStr;
592    if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), DfValStr)){
593      if ((!DfValStr.Empty())&&(DfValStr.LastCh()=='#')){
594        TStr SubDfValStr=DfValStr.GetSubStr(0, DfValStr.Len()-2);
595        DfValStr=GetUniqueColVarVal(ColVarN, SubDfValStr);
596      }
597      TVclStrGridVarType VarType; GetCellVarType(ColN, -1, VarType);
598      if (VarType==gvtExt){DfValStr="";}
599    }
600    return DfValStr;
601  }
602  int TVclStrGrid::AddColRec(){
603    GridValVV.AddXDim();
604    SyncToGui();
605    int ColRecN=GetCols()-1-FixedCols;
606    return ColRecN;
607  }
608  int TVclStrGrid::AddRowRec(){
609    GridValVV.AddYDim();
610    int RowN=GetRows()-1;
611    int RowRecN=GetRows()-1-FixedRows;
612    for (int ColVarN=0; ColVarN<GetColVars(); ColVarN++){
613      PutColVarVal(ColVarN, RowRecN, GetDfColVarVal(ColVarN));}
614    SyncToGui(); SetFocus();
615    SelCell(FixedCols, RowN);
616    return RowRecN;
617  }
618  int TVclStrGrid::AddRowRec(const TStr& VarNm, const TStrV& ValStrV){
619    int RecN=AddRowRec();
620    if (!VarNm.Empty()){RowVarNm(RecN)=VarNm;}
621    for (int VarN=0; VarN<ValStrV.Len(); VarN++){
622      ColVarVal(VarN, RecN)=ValStrV[VarN];}
623    SyncToGui();
624    return RecN;
625  }
626  TStr TVclStrGrid::GetUniqueColVarVal(const int& ColVarN, const TStr& PfxValStr){
627    int RowRecs=GetRowRecs();
628    TStrH VarValH(RowRecs);
629    for (int RowRecN=0; RowRecN<RowRecs; RowRecN++){
630      VarValH.AddDat(ColVarVal(ColVarN, RowRecN));}
631    int ValStrN=1;
632    forever{
633      TStr ValStr=PfxValStr+TInt::GetStr(ValStrN);
634      if (!VarValH.IsKey(ValStr)){return ValStr;}
635      ValStrN++;
636    }
637  }
638  void TVclStrGrid::DelSelRowRec(){
639    int DelColN; int DelRowN;
640    if (IsSelCell(DelColN, DelRowN)){
641      DelRow(DelRowN);
642      SelCell(DelColN, DelRowN);
643      if (!IsSelCell()){
644        SelCell(DelColN, DelRowN-1);}
645      SyncToGui();
646    }
647    SetFocus();
648  }
649  void TVclStrGrid::CopySelRowRec(){
650    int SrcColN; int SrcRowN;
651    if (IsSelCell(SrcColN, SrcRowN)){
652      int DstRecN=AddRowRec();
653      int DstRowN=GetRowNFromRecN(DstRecN);
654      for (int ColN=0; ColN<GetCols(); ColN++){
655        At(ColN, DstRowN)=GetVal(ColN, SrcRowN);}
656      SelCell(GetFixedCols(), GetRows()-1);
657      SyncToGui();
658    }
659    SetFocus();
660  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</div>
                </div>
                <div class="column column_space"><pre><code>523      VarType=TVclStrGridVarType(int(_VarType));
524      if (VarType==gvtStrV){
525        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(ColN, 1), ValStrV)){}
</pre></code></div>
                <div class="column column_space"><pre><code>530      VarType=TVclStrGridVarType(int(_VarType));
531      if (VarType==gvtStrV){
532        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    