
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "DockingManager.h"
3  #include "DockingSplitter.h"
4  #include "DockingCont.h"
5  #include "Gripper.h"
6  #include "Parameters.h"
7  using namespace std;
8  BOOL DockingManager::_isRegistered = FALSE;
9  static	HWND			hWndServer	= NULL;
10  static	HHOOK			gWinCallHook = NULL;
11  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam);
12  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam)
13  {
14  	if (nCode == HC_ACTION && hWndServer)
15  	{
16  		DockingManager *pDockingManager = (DockingManager *)::GetWindowLongPtr(hWndServer, GWLP_USERDATA);
17  		if (pDockingManager)
18  		{
19  			vector<DockingCont*> & vcontainer = pDockingManager->getContainerInfo();
20  			CWPSTRUCT * pCwp = (CWPSTRUCT*)lParam;
21  			if (pCwp->message == WM_KILLFOCUS)
22  			{
23  				for (int i = 0; i < DOCKCONT_MAX; ++i)
24  				{
25  					vcontainer[i]->SetActive(FALSE);	
26  				}
27  			}
28  			else if (pCwp->message == WM_SETFOCUS)
29  			{
30  				for (int i = 0; i < DOCKCONT_MAX; ++i)
31  				{
32  					vcontainer[i]->SetActive(IsChild(vcontainer[i]->getHSelf(), pCwp->hwnd));	
33  				}
34  			}
35  		}
36  	}
37  	return CallNextHookEx(gWinCallHook, nCode, wParam, lParam);
38  }
39  DockingManager::DockingManager()
40  {
41  	memset(_iContMap, -1, CONT_MAP_MAX * sizeof(int));
42  	_iContMap[0] = CONT_LEFT;
43  	_iContMap[1] = CONT_RIGHT;
44  	_iContMap[2] = CONT_TOP;
45  	_iContMap[3] = CONT_BOTTOM;
46  	for (int i = 0; i < DOCKCONT_MAX; ++i)
47  	{
48  		DockingCont *_pDockCont = new DockingCont;
49  		_vContainer.push_back(_pDockCont);
50  		DockingSplitter *_pSplitter = new DockingSplitter;
51  		_vSplitter.push_back(_pSplitter);
52  	}
53  }
54  DockingManager::~DockingManager()
55  {
56  	for (int i = 0; i < DOCKCONT_MAX; ++i)
57  	{
58  		delete _vSplitter[i];
59  	}
60  }
61  void DockingManager::init(HINSTANCE hInst, HWND hWnd, Window ** ppWin)
62  {
63  	Window::init(hInst, hWnd);
64  	if (!_isRegistered)
65  	{
66  		WNDCLASS clz{};
67  		clz.style = 0;
68  		clz.lpfnWndProc = staticWinProc;
69  		clz.cbClsExtra = 0;
70  		clz.cbWndExtra = 0;
71  		clz.hInstance = _hInst;
72  		clz.hIcon = NULL;
73  		clz.hCursor = ::LoadCursor(NULL, IDC_ARROW);
74  		clz.hbrBackground = NULL;
75  		clz.lpszMenuName = NULL;
76  		clz.lpszClassName = DSPC_CLASS_NAME;
77  		if (!::RegisterClass(&clz))
78  		{
79  			throw std::runtime_error("DockingManager::init : RegisterClass() function failed");
80  		}
81  		_isRegistered = TRUE;
82  	}
83  	_hSelf = ::CreateWindowEx(
84  					0,
85  					DSPC_CLASS_NAME,
86  					TEXT(""),
87  					WS_CHILD | WS_CLIPCHILDREN,
88  					CW_USEDEFAULT, CW_USEDEFAULT,
89  					CW_USEDEFAULT, CW_USEDEFAULT,
90  					_hParent,
91  					NULL,
92  					_hInst,
93  					(LPVOID)this);
94  	if (!_hSelf)
95  	{
96  		throw std::runtime_error("DockingManager::init : CreateWindowEx() function return null");
97  	}
98  	setClientWnd(ppWin);
99  	for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
100  	{
101  		_vContainer[iCont]->init(_hInst, _hSelf);
102  		_vContainer[iCont]->doDialog(false);
103  		::SetParent(_vContainer[iCont]->getHSelf(), _hParent);
104  		if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
105  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_HORIZONTAL);
106  		else
107  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_VERTICAL);
108  	}
109  	if (!hWndServer)
110  		hWndServer = _hSelf;
111  	CoInitialize(NULL);
112  	if (!gWinCallHook)	
113  		gWinCallHook = ::SetWindowsHookEx(WH_CALLWNDPROC, focusWndProc, hInst, GetCurrentThreadId());
114  	if (!gWinCallHook)
115  	{
116  		throw std::runtime_error("DockingManager::init : SetWindowsHookEx() function return null");
117  	}
118  	_dockData.hWnd = _hSelf;
119  	_isInitialized = TRUE;
120  }
121  void DockingManager::destroy()
122  {
123  	::DestroyWindow(_hSelf);
124  }
125  LRESULT CALLBACK DockingManager::staticWinProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
126  {
127  	DockingManager *pDockingManager = NULL;
128  	switch (message)
129  	{
130  		case WM_NCCREATE :
131  			pDockingManager = static_cast<DockingManager *>(reinterpret_cast<LPCREATESTRUCT>(lParam)->lpCreateParams);
132  			pDockingManager->_hSelf = hwnd;
133  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pDockingManager));
134  			return TRUE;
135  		default :
136  			pDockingManager = reinterpret_cast<DockingManager *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
137  			if (!pDockingManager)
138  				return ::DefWindowProc(hwnd, message, wParam, lParam);
139  			return pDockingManager->runProc(hwnd, message, wParam, lParam);
140  	}
141  }
142  void DockingManager::updateContainerInfo(HWND hClient)
143  {
144  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
145  	{
146  		if (_vContainer[iCont]->updateInfo(hClient) == TRUE)
147  		{
148  			break;
149  		}
150  	}
151  }
152  void DockingManager::showFloatingContainers(bool show)
153  {
154  	for (size_t i=0; i < _vContainer.size(); i++)
155  	{
156  		size_t iElementCnt = _vContainer[i]->getElementCnt();
157  		if (iElementCnt > 0)
158  		{
159  			if (0 < ::SendMessage(_vContainer[i]->getTabWnd(), TCM_GETITEMCOUNT, 0, 0)) 
160  				_vContainer[i]->display(show);
161  		}
162  	}
163  }
164  LRESULT DockingManager::runProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
165  {
166  	switch (message)
167  	{
168  		case WM_ERASEBKGND:
169  		{
170  			if (!NppDarkMode::isEnabled())
171  			{
172  				break;
173  			}
174  			RECT rc{};
175  			::GetClientRect(hwnd, &rc);
176  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
177  			return TRUE;
178  		}
179  		case WM_NCACTIVATE:
180  		{
181  			for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
182  			{
183  				::SendMessage(_vContainer[iCont]->getHSelf(), WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
184  			}
185  			if (static_cast<int>(lParam) != -1)
186  			{
187  				::SendMessage(_hParent, WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
188  			}
189  			break;
190  		}
191  		case WM_MOVE:
192  		case WM_SIZE:
193  		{
194  			resize();
195  			break;
196  		}
197  		case WM_DESTROY:
198  		{
199  			if (hWndServer == hwnd)
200  			{
201  				UnhookWindowsHookEx(gWinCallHook);
202  				gWinCallHook = NULL;
203  				hWndServer = NULL;
204  			}
205  			if (_hImageList != NULL)
206  			{
207  				::ImageList_Destroy(_hImageList);
208  			}
209  			for (int32_t i = static_cast<int32_t>(_vContainer.size()); i > 0; i--)
210  			{
211  				_vContainer[i-1]->destroy();
212  				delete _vContainer[i-1];
213  			}
214  			CoUninitialize();
215  			break;
216  		}
217  		case DMM_LBUTTONUP:	
218  		{
219  			if (::GetActiveWindow() != _hParent)
220  				break;
221  			for (int i = 0; i < DOCKCONT_MAX; ++i)
222  			{
223  				_vContainer[i]->SetActive(IsChild(_vContainer[i]->getHSelf(), ::GetFocus()));
224  			}
225  			return TRUE;
226  		}
227  		case DMM_MOVE:
228  		{
229  			Gripper *pGripper = new Gripper;
230  			pGripper->init(_hInst, _hParent);
231  			pGripper->startGrip(reinterpret_cast<DockingCont*>(lParam), this);
232  			break;
233  		}
234  		case DMM_MOVE_SPLITTER:
235  		{
236  			int offset = static_cast<int32_t>(wParam);
237  			for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
238  			{
239  				if (_vSplitter[iCont]->getHSelf() == reinterpret_cast<HWND>(lParam))
240  				{
241  					switch (iCont)
242  					{
243  						case CONT_TOP:
244  							_dockData.rcRegion[iCont].bottom -= offset;
245  							if (_dockData.rcRegion[iCont].bottom < 0)
246  							{
247  								_dockData.rcRegion[iCont].bottom = 0;
248  							}
249  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset < 0))
250  							{
251  								_dockData.rcRegion[iCont].bottom += offset;
252  							}
253  							break;
254  						case CONT_BOTTOM:
255  							_dockData.rcRegion[iCont].bottom   += offset;
256  							if (_dockData.rcRegion[iCont].bottom < 0)
257  							{
258  								_dockData.rcRegion[iCont].bottom   = 0;
259  							}
260  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset > 0))
261  							{
<span onclick='openModal()' class='match'>262  								_dockData.rcRegion[iCont].bottom -= offset;
263  							}
264  							break;
265  						case CONT_LEFT:
</span>266  							_dockData.rcRegion[iCont].right    -= offset;
267  							if (_dockData.rcRegion[iCont].right < 0)
268  							{
269  								_dockData.rcRegion[iCont].right = 0;
270  							}
271  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset < 0))
272  							{
273  								_dockData.rcRegion[iCont].right += offset;
274  							}
275  							break;
276  						case CONT_RIGHT:
277  							_dockData.rcRegion[iCont].right    += offset;
278  							if (_dockData.rcRegion[iCont].right < 0)
279  							{
280  								_dockData.rcRegion[iCont].right = 0;
281  							}
282  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset > 0))
283  							{
284  								_dockData.rcRegion[iCont].right -= offset;
285  							}
286  							break;
287  					}
288  					resize();
289  					break;
290  				}
291  			}
292  			break;
293  		}
294  		case DMM_DOCK:
295  		case DMM_FLOAT:
296  		{
297  			toggleActiveTb(reinterpret_cast<DockingCont*>(lParam), message);
298  			return FALSE;
299  		}
300  		case DMM_CLOSE:
301  		{
302  			tTbData	TbData	= *(reinterpret_cast<DockingCont*>(lParam))->getDataOfActiveTb();
303  			LRESULT res = SendNotify(TbData.hClient, DMN_CLOSE);	
304  			return res;
305  		}
306  		case DMM_FLOATALL:
307  		{
308  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_FLOAT);
309  			return FALSE;
310  		}
311  		case DMM_DOCKALL:
312  		{
313  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_DOCK);
314  			return FALSE;
315  		}
316  		case DMM_GETIMAGELIST:
317  		{
318  			return reinterpret_cast<LPARAM>(_hImageList);
319  		}
320  		case DMM_GETICONPOS:
321  		{
322  			for (size_t uImageCnt = 0, len = _vImageList.size(); uImageCnt < len; ++uImageCnt)
323  			{
324  				if (reinterpret_cast<HWND>(lParam) == _vImageList[uImageCnt])
325  				{
326  					return uImageCnt;
327  				}
328  			}
329  			return -1;
330  		}
331  		default :
332  			break;
333  	}
334  	return ::DefWindowProc(_hSelf, message, wParam, lParam);
335  }
336  void DockingManager::resize()
337  {
338      reSizeTo(_rect);
339  }
340  void DockingManager::reSizeTo(RECT & rc)
341  {
342  	_rect = rc;
343  	_rcWork	= rc;
344  	if (_isInitialized == FALSE)
345  		return;
346  	_dockData.rcRegion[CONT_TOP].left      = rc.left;
347  	_dockData.rcRegion[CONT_TOP].top       = rc.top;
348  	_dockData.rcRegion[CONT_TOP].right     = rc.right-rc.left;
349  	_vSplitter[CONT_TOP]->display(false);
350  	if (_vContainer[CONT_TOP]->isVisible())
351  	{
352  		_rcWork.top		+= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
353  		_rcWork.bottom	-= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
354  		RECT	rc = {_dockData.rcRegion[CONT_TOP].left  ,
355  					  _dockData.rcRegion[CONT_TOP].top + _dockData.rcRegion[CONT_TOP].bottom,
356  					  _dockData.rcRegion[CONT_TOP].right ,
357  					  SPLITTER_WIDTH};
358  		_vSplitter[CONT_TOP]->reSizeTo(rc);
359  	}
360  	_dockData.rcRegion[CONT_BOTTOM].left   = rc.left;
361  	_dockData.rcRegion[CONT_BOTTOM].top    = rc.top + rc.bottom - _dockData.rcRegion[CONT_BOTTOM].bottom;
362  	_dockData.rcRegion[CONT_BOTTOM].right  = rc.right-rc.left;
363  	RECT		rcBottom	= _dockData.rcRegion[CONT_BOTTOM];
364  	_vSplitter[CONT_BOTTOM]->display(false);
365  	if (_vContainer[CONT_BOTTOM]->isVisible())
366  	{
367  		_rcWork.bottom	-= _dockData.rcRegion[CONT_BOTTOM].bottom + SPLITTER_WIDTH;
368  		if (_rcWork.bottom < rc.top)
369  		{
370  			rcBottom.top     = _rcWork.top + rc.top + SPLITTER_WIDTH;
371  			rcBottom.bottom += _rcWork.bottom - rc.top;
372  			_rcWork.bottom = rc.top;
373  		}
374  		if ((rcBottom.bottom + SPLITTER_WIDTH) < 0)
375  		{
376  			_rcWork.bottom = rc.bottom - _dockData.rcRegion[CONT_TOP].bottom;
377  		}
378  		RECT	rc = {rcBottom.left,
379  					  rcBottom.top - SPLITTER_WIDTH,
380  					  rcBottom.right,
381  					  SPLITTER_WIDTH};
382  		_vSplitter[CONT_BOTTOM]->reSizeTo(rc);
383  	}
384  	_dockData.rcRegion[CONT_LEFT].left     = rc.left;
385  	_dockData.rcRegion[CONT_LEFT].top      = _rcWork.top;
386  	_dockData.rcRegion[CONT_LEFT].bottom   = _rcWork.bottom;
387  	_vSplitter[CONT_LEFT]->display(false);
388  	if (_vContainer[CONT_LEFT]->isVisible())
389  	{
390  		_rcWork.left		+= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
391  		_rcWork.right	-= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
392  		RECT	rc = {_dockData.rcRegion[CONT_LEFT].right,
393  					  _dockData.rcRegion[CONT_LEFT].top,
394  					  SPLITTER_WIDTH,
395  					  _dockData.rcRegion[CONT_LEFT].bottom};
396  		_vSplitter[CONT_LEFT]->reSizeTo(rc);
397  	}
398  	_dockData.rcRegion[CONT_RIGHT].left    = rc.right - _dockData.rcRegion[CONT_RIGHT].right;
399  	_dockData.rcRegion[CONT_RIGHT].top     = _rcWork.top;
400  	_dockData.rcRegion[CONT_RIGHT].bottom  = _rcWork.bottom;
401  	RECT		rcRight		= _dockData.rcRegion[CONT_RIGHT];
402  	_vSplitter[CONT_RIGHT]->display(false);
403  	if (_vContainer[CONT_RIGHT]->isVisible())
404  	{
405  		_rcWork.right	-= _dockData.rcRegion[CONT_RIGHT].right + SPLITTER_WIDTH;
406  		if (_rcWork.right < 15)
407  		{
408  			rcRight.left    = _rcWork.left + 15 + SPLITTER_WIDTH;
409  			rcRight.right  += _rcWork.right - 15;
410  			_rcWork.right	= 15;
411  		}
412  		RECT	rc = {rcRight.left - SPLITTER_WIDTH,
413  					  rcRight.top,
414  					  SPLITTER_WIDTH,
415  					  rcRight.bottom};
416  		_vSplitter[CONT_RIGHT]->reSizeTo(rc);
417  	}
418  	if (_vContainer[CONT_BOTTOM]->isVisible())
419  	{
420  		::SetWindowPos(_vContainer[CONT_BOTTOM]->getHSelf(), NULL,
421  					   rcBottom.left  ,
422  					   rcBottom.top   ,
423  					   rcBottom.right ,
424  					   rcBottom.bottom,
425  					   SWP_NOZORDER);
426  		_vSplitter[CONT_BOTTOM]->display();
427  	}
428  	if (_vContainer[CONT_TOP]->isVisible())
429  	{
430  		::SetWindowPos(_vContainer[CONT_TOP]->getHSelf(), NULL,
431  					   _dockData.rcRegion[CONT_TOP].left  ,
432  					   _dockData.rcRegion[CONT_TOP].top   ,
433  					   _dockData.rcRegion[CONT_TOP].right ,
434  					   _dockData.rcRegion[CONT_TOP].bottom,
435  					   SWP_NOZORDER);
436  		_vSplitter[CONT_TOP]->display();
437  	}
438  	if (_vContainer[CONT_RIGHT]->isVisible())
439  	{
440  		::SetWindowPos(_vContainer[CONT_RIGHT]->getHSelf(), NULL,
441  					   rcRight.left  ,
442  					   rcRight.top   ,
443  					   rcRight.right ,
444  					   rcRight.bottom,
445  					   SWP_NOZORDER);
446  		_vSplitter[CONT_RIGHT]->display();
447  	}
448  	if (_vContainer[CONT_LEFT]->isVisible())
449  	{
450  		::SetWindowPos(_vContainer[CONT_LEFT]->getHSelf(), NULL,
451  					   _dockData.rcRegion[CONT_LEFT].left  ,
452  					   _dockData.rcRegion[CONT_LEFT].top   ,
453  					   _dockData.rcRegion[CONT_LEFT].right ,
454  					   _dockData.rcRegion[CONT_LEFT].bottom,
455  					   SWP_NOZORDER);
456  		_vSplitter[CONT_LEFT]->display();
457  	}
458  	(*_ppMainWindow)->reSizeTo(_rcWork);
459  }
460  void DockingManager::createDockableDlg(tTbData data, int iCont, bool isVisible)
461  {
462  	if ((data.uMask & DWS_ICONTAB) && data.hIconTab != NULL)
463  	{
464  		if (_hImageList == NULL)
465  		{
466  			int iconDpiDynamicalSize = NppParameters::getInstance()._dpiManager.scaleY(12) + 2;
467  			_hImageList = ::ImageList_Create(iconDpiDynamicalSize, iconDpiDynamicalSize, ILC_COLOR32 | ILC_MASK, 0, 0);
468  		}
469  		::ImageList_AddIcon(_hImageList, data.hIconTab);
470  		_vImageList.push_back(data.hClient);
471  	}
472  	if ((data.uMask & DWS_USEOWNDARKMODE) != DWS_USEOWNDARKMODE && NppDarkMode::isEnabledForPlugins())
473  	{
474  		NppDarkMode::autoSubclassAndThemePluginDockWindow(data.hClient);
475  	}
476  	RECT				rc			= {0,0,0,0};
477  	DockingCont*		pCont		= NULL;
478  	if (memcmp(&data.rcFloat, &rc, sizeof(RECT)) == 0)
479  	{
480  		::GetWindowRect(data.hClient, &data.rcFloat);
481  		if (iCont == -1)
482  		{
483  			isVisible = (::IsWindowVisible(data.hClient) == TRUE);
484  			if (data.uMask & DWS_DF_FLOATING)
485  			{
486  				pCont = new DockingCont;
487  				_vContainer.push_back(pCont);
488  				pCont->init(_hInst, _hSelf);
489  				pCont->doDialog(isVisible, true);
490  				data.iPrevCont = (data.uMask & 0x30000000) >> 28;
491  				iCont = static_cast<int32_t>(_vContainer.size()) - 1;
492  			}
493  			else
494  			{
495  				iCont = (data.uMask & 0x30000000) >> 28;
496  				data.iPrevCont = -1;
497  			}
498  		}
499  	}
500  	else if ((iCont >= DOCKCONT_MAX) || (data.iPrevCont >= DOCKCONT_MAX))
501  	{
502  		if (iCont >= DOCKCONT_MAX)
503  		{
504  			if (_iContMap[iCont] == -1)
505  			{
506  				pCont = new DockingCont;
507  				_vContainer.push_back(pCont);
508  				pCont->init(_hInst, _hSelf);
509  				pCont->doDialog(isVisible, true);
510  				_iContMap[iCont] = static_cast<int32_t>(_vContainer.size()) - 1;
511  			}
512  			iCont = _iContMap[iCont];
513  		}
514  		else
515  		{
516  			if (_iContMap[data.iPrevCont] == -1)
517  			{
518  				pCont = new DockingCont;
519  				_vContainer.push_back(pCont);
520  				pCont->init(_hInst, _hSelf);
521  				pCont->doDialog(false, true);
522  				pCont->reSizeToWH(data.rcFloat);
523  				_iContMap[data.iPrevCont] = static_cast<int32_t>(_vContainer.size()) - 1;
524  			}
525  			data.iPrevCont = _iContMap[data.iPrevCont];
526  		}
527  	}
528  	if (_vContainer.size() > static_cast<size_t>(iCont) && _vContainer[iCont] != nullptr)
529  	{
530  		_vContainer[iCont]->createToolbar(data);
531  		for (const auto& cont : _vContainer)
532  		{
533  			if (cont->isVisible() && cont != _vContainer[iCont])
534  			{
535  				::RedrawWindow(cont->getHSelf(), nullptr, nullptr, RDW_INVALIDATE);
536  			}
537  		}
538  	}
539  	if (iCont < DOCKCONT_MAX)
540  		SendNotify(data.hClient, MAKELONG(DMN_DOCK, iCont));
541  	else
542  		SendNotify(data.hClient, MAKELONG(DMN_FLOAT, iCont));
543  }
544  void DockingManager::setActiveTab(int iCont, int iItem)
545  {
546  	if ((iCont == -1) || (_iContMap[iCont] == -1))
547  		return;
548  	_vContainer[_iContMap[iCont]]->setActiveTb(iItem);
549  }
550  void DockingManager::showDockableDlg(HWND hDlg, BOOL view)
551  {
552  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
553  	{
554  		tTbData *pTbData = _vContainer[i]->findToolbarByWnd(hDlg);
555  		if (pTbData != NULL)
556  		{
557  			_vContainer[i]->showToolbar(pTbData, view);
558  			return;
559  		}
560  	}
561  }
562  void DockingManager::showDockableDlg(TCHAR* pszName, BOOL view)
563  {
564  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
565  	{
566  		tTbData *pTbData = _vContainer[i]->findToolbarByName(pszName);
567  		if (pTbData != NULL)
568  		{
569  			_vContainer[i]->showToolbar(pTbData, view);
570  			return;
571  		}
572  	}
573  }
574  LRESULT DockingManager::SendNotify(HWND hWnd, UINT message)
575  {
576  	NMHDR nmhdr{};
577  	nmhdr.code		= message;
578  	nmhdr.hwndFrom	= _hParent;
579  	nmhdr.idFrom	= ::GetDlgCtrlID(_hParent);
580  	::SendMessage(hWnd, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
581  	return ::GetWindowLongPtr(hWnd, DWLP_MSGRESULT);
582  }
583  void DockingManager::setDockedContSize(int iCont, int iSize)
584  {
585  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
586  		_dockData.rcRegion[iCont].bottom = iSize;
587  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
588  		_dockData.rcRegion[iCont].right = iSize;
589  	else
590  		return;
591  	resize();
592  }
593  int DockingManager::getDockedContSize(int iCont)
594  {
595  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
596  		return _dockData.rcRegion[iCont].bottom;
597  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
598  		return _dockData.rcRegion[iCont].right;
599  	else
600  		return -1;
601  }
602  DockingCont* DockingManager::toggleActiveTb(DockingCont* pContSrc, UINT message, BOOL bNew, LPRECT prcFloat)
603  {
604  	tTbData			TbData		= *pContSrc->getDataOfActiveTb();
605  	int				iContSrc	= GetContainer(pContSrc);
606  	int				iContPrev	= TbData.iPrevCont;
607  	BOOL			isCont		= ContExists(iContPrev);
608  	DockingCont*	pContTgt	= NULL;
609  	if (prcFloat != NULL)
610  	{
611  		TbData.rcFloat = *prcFloat;
612  	}
613  	if ((isCont == FALSE) || (bNew == TRUE))
614  	{
615  		int	iContNew = FindEmptyContainer();
616  		if (iContNew == -1)
617  		{
618  			pContTgt = new DockingCont;
619  			pContTgt->init(_hInst, _hSelf);
620  			pContTgt->doDialog(true, true);
621  			if ((bNew == FALSE) || (!pContSrc->isFloating()))
622  				TbData.iPrevCont = iContSrc;
623  			pContTgt->createToolbar(TbData);
624  			_vContainer.push_back(pContTgt);
625  		}
626  		else
627  		{
628  			pContTgt = _vContainer[iContNew];
629  			if ((pContSrc->isFloating()) != (pContTgt->isFloating()))
630                  TbData.iPrevCont = iContSrc;
631  			pContTgt->createToolbar(TbData);
632  		}
633  	}
634  	else
635  	{
636  		pContTgt = _vContainer[iContPrev];
637  		TbData.iPrevCont = iContSrc;
638  		pContTgt->createToolbar(TbData);
639  	}
640  	SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
641  	_vContainer[iContSrc]->removeToolbar(TbData);
642  	return pContTgt;
643  }
644  DockingCont* DockingManager::toggleVisTb(DockingCont* pContSrc, UINT message, LPRECT prcFloat)
645  {
646  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
647  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
648  	int					iContSrc	= GetContainer(pContSrc);
649  	int					iContPrev	= pTbData->iPrevCont;
650  	BOOL				isCont		= ContExists(iContPrev);
651  	DockingCont*		pContTgt	= NULL;
652  	pContSrc->doDialog(false);
653  	resize();
654  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
655  	{
656  		tTbData		TbData = *vTbData[iTb];
657  		if (prcFloat != NULL)
658  		{
659  			TbData.rcFloat = *prcFloat;
660  		}
661  		if (isCont == FALSE)
662  		{
663  			pContTgt = new DockingCont;
664  			pContTgt->init(_hInst, _hSelf);
665  			pContTgt->doDialog(true, true);
666  			TbData.iPrevCont = iContSrc;
667  			pContTgt->createToolbar(TbData);
668  			_vContainer.push_back(pContTgt);
669  			isCont	= TRUE;
670  			iContPrev = GetContainer(pContTgt);
671  		}
672  		else
673  		{
674  			pContTgt = _vContainer[iContPrev];
675  			TbData.iPrevCont = iContSrc;
676  			pContTgt->createToolbar(TbData);
677  		}
678  		SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
679  		_vContainer[iContSrc]->removeToolbar(TbData);
680  	}
681  	_vContainer[iContPrev]->setActiveTb(pTbData);
682  	return pContTgt;
683  }
684  void DockingManager::toggleActiveTb(DockingCont* pContSrc, DockingCont* pContTgt)
685  {
686  	tTbData		TbData		= *pContSrc->getDataOfActiveTb();
687  	toggleTb(pContSrc, pContTgt, TbData);
688  }
689  void DockingManager::toggleVisTb(DockingCont* pContSrc, DockingCont* pContTgt)
690  {
691  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
692  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
693  	pContSrc->doDialog(false);
694  	resize();
695  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
696  	{
697  		tTbData		TbData = *vTbData[iTb];
698  		toggleTb(pContSrc, pContTgt, TbData);
699  	}
700  	pContTgt->setActiveTb(pTbData);
701  }
702  void DockingManager::toggleTb(DockingCont* pContSrc, DockingCont* pContTgt, tTbData TbData)
703  {
704  	int					iContSrc	= GetContainer(pContSrc);
705  	int					iContTgt	= GetContainer(pContTgt);
706  	if (((iContSrc <  DOCKCONT_MAX) && (iContTgt >= DOCKCONT_MAX)) ||
707  		((iContSrc >= DOCKCONT_MAX) && (iContTgt <  DOCKCONT_MAX)))
708  	{
709  		TbData.iPrevCont = iContSrc;
710  	}
711  	if (iContTgt < DOCKCONT_MAX)
712  		SendNotify(TbData.hClient, MAKELONG(DMN_DOCK, iContTgt));
713  	else
714  		SendNotify(TbData.hClient, MAKELONG(DMN_FLOAT, iContTgt));
715  	pContTgt->createToolbar(TbData);
716  	_vContainer[iContSrc]->removeToolbar(TbData);
717  }
718  BOOL DockingManager::ContExists(size_t iCont)
719  {
720  	BOOL	bRet = FALSE;
721  	if (iCont < _vContainer.size())
722  	{
723  		bRet = TRUE;
724  	}
725  	return bRet;
726  }
727  int DockingManager::GetContainer(DockingCont* pCont)
728  {
729  	int iRet = -1;
730  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
731  	{
732  		if (_vContainer[iCont] == pCont)
733  		{
734  			iRet = static_cast<int32_t>(iCont);
735  			break;
736  		}
737  	}
738  	return iRet;
739  }
740  int DockingManager::FindEmptyContainer()
741  {
742      int      iRetCont       = -1;
743      BOOL*    pPrevDockList  = (BOOL*) new BOOL[_vContainer.size()+1];
744      BOOL*    pArrayPos      = &pPrevDockList[1];
745      for (size_t iCont = 0, len = _vContainer.size()+1; iCont < len; ++iCont)
746      {
747          pPrevDockList[iCont] = FALSE;
748      }
749      for (size_t iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
750      {
751          vector<tTbData*>    vTbData = _vContainer[iCont]->getDataOfAllTb();
752          for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
753          {
754              pArrayPos[vTbData[iTb]->iPrevCont] = TRUE;
755          }
756      }
757      for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
758      {
759          if (pArrayPos[iCont] == FALSE)
760          {
761              if (!_vContainer[iCont]->isVisible())
762              {
763  				iRetCont = static_cast<int32_t>(iCont);
764                  break;
765              }
766          }
767      }
768      delete [] pPrevDockList;
769      return iRetCont;
770  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</h3>
            <pre><code>1  #include <stdexcept>
2  #include "DockingManager.h"
3  #include "DockingSplitter.h"
4  #include "DockingCont.h"
5  #include "Gripper.h"
6  #include "Parameters.h"
7  using namespace std;
8  BOOL DockingManager::_isRegistered = FALSE;
9  static	HWND			hWndServer	= NULL;
10  static	HHOOK			gWinCallHook = NULL;
11  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam);
12  LRESULT CALLBACK focusWndProc(int nCode, WPARAM wParam, LPARAM lParam)
13  {
14  	if (nCode == HC_ACTION && hWndServer)
15  	{
16  		DockingManager *pDockingManager = (DockingManager *)::GetWindowLongPtr(hWndServer, GWLP_USERDATA);
17  		if (pDockingManager)
18  		{
19  			vector<DockingCont*> & vcontainer = pDockingManager->getContainerInfo();
20  			CWPSTRUCT * pCwp = (CWPSTRUCT*)lParam;
21  			if (pCwp->message == WM_KILLFOCUS)
22  			{
23  				for (int i = 0; i < DOCKCONT_MAX; ++i)
24  				{
25  					vcontainer[i]->SetActive(FALSE);	
26  				}
27  			}
28  			else if (pCwp->message == WM_SETFOCUS)
29  			{
30  				for (int i = 0; i < DOCKCONT_MAX; ++i)
31  				{
32  					vcontainer[i]->SetActive(IsChild(vcontainer[i]->getHSelf(), pCwp->hwnd));	
33  				}
34  			}
35  		}
36  	}
37  	return CallNextHookEx(gWinCallHook, nCode, wParam, lParam);
38  }
39  DockingManager::DockingManager()
40  {
41  	memset(_iContMap, -1, CONT_MAP_MAX * sizeof(int));
42  	_iContMap[0] = CONT_LEFT;
43  	_iContMap[1] = CONT_RIGHT;
44  	_iContMap[2] = CONT_TOP;
45  	_iContMap[3] = CONT_BOTTOM;
46  	for (int i = 0; i < DOCKCONT_MAX; ++i)
47  	{
48  		DockingCont *_pDockCont = new DockingCont;
49  		_vContainer.push_back(_pDockCont);
50  		DockingSplitter *_pSplitter = new DockingSplitter;
51  		_vSplitter.push_back(_pSplitter);
52  	}
53  }
54  DockingManager::~DockingManager()
55  {
56  	for (int i = 0; i < DOCKCONT_MAX; ++i)
57  	{
58  		delete _vSplitter[i];
59  	}
60  }
61  void DockingManager::init(HINSTANCE hInst, HWND hWnd, Window ** ppWin)
62  {
63  	Window::init(hInst, hWnd);
64  	if (!_isRegistered)
65  	{
66  		WNDCLASS clz{};
67  		clz.style = 0;
68  		clz.lpfnWndProc = staticWinProc;
69  		clz.cbClsExtra = 0;
70  		clz.cbWndExtra = 0;
71  		clz.hInstance = _hInst;
72  		clz.hIcon = NULL;
73  		clz.hCursor = ::LoadCursor(NULL, IDC_ARROW);
74  		clz.hbrBackground = NULL;
75  		clz.lpszMenuName = NULL;
76  		clz.lpszClassName = DSPC_CLASS_NAME;
77  		if (!::RegisterClass(&clz))
78  		{
79  			throw std::runtime_error("DockingManager::init : RegisterClass() function failed");
80  		}
81  		_isRegistered = TRUE;
82  	}
83  	_hSelf = ::CreateWindowEx(
84  					0,
85  					DSPC_CLASS_NAME,
86  					TEXT(""),
87  					WS_CHILD | WS_CLIPCHILDREN,
88  					CW_USEDEFAULT, CW_USEDEFAULT,
89  					CW_USEDEFAULT, CW_USEDEFAULT,
90  					_hParent,
91  					NULL,
92  					_hInst,
93  					(LPVOID)this);
94  	if (!_hSelf)
95  	{
96  		throw std::runtime_error("DockingManager::init : CreateWindowEx() function return null");
97  	}
98  	setClientWnd(ppWin);
99  	for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
100  	{
101  		_vContainer[iCont]->init(_hInst, _hSelf);
102  		_vContainer[iCont]->doDialog(false);
103  		::SetParent(_vContainer[iCont]->getHSelf(), _hParent);
104  		if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
105  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_HORIZONTAL);
106  		else
107  			_vSplitter[iCont]->init(_hInst, _hParent, _hSelf, DMS_VERTICAL);
108  	}
109  	if (!hWndServer)
110  		hWndServer = _hSelf;
111  	CoInitialize(NULL);
112  	if (!gWinCallHook)	
113  		gWinCallHook = ::SetWindowsHookEx(WH_CALLWNDPROC, focusWndProc, hInst, GetCurrentThreadId());
114  	if (!gWinCallHook)
115  	{
116  		throw std::runtime_error("DockingManager::init : SetWindowsHookEx() function return null");
117  	}
118  	_dockData.hWnd = _hSelf;
119  	_isInitialized = TRUE;
120  }
121  void DockingManager::destroy()
122  {
123  	::DestroyWindow(_hSelf);
124  }
125  LRESULT CALLBACK DockingManager::staticWinProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
126  {
127  	DockingManager *pDockingManager = NULL;
128  	switch (message)
129  	{
130  		case WM_NCCREATE :
131  			pDockingManager = static_cast<DockingManager *>(reinterpret_cast<LPCREATESTRUCT>(lParam)->lpCreateParams);
132  			pDockingManager->_hSelf = hwnd;
133  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pDockingManager));
134  			return TRUE;
135  		default :
136  			pDockingManager = reinterpret_cast<DockingManager *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
137  			if (!pDockingManager)
138  				return ::DefWindowProc(hwnd, message, wParam, lParam);
139  			return pDockingManager->runProc(hwnd, message, wParam, lParam);
140  	}
141  }
142  void DockingManager::updateContainerInfo(HWND hClient)
143  {
144  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
145  	{
146  		if (_vContainer[iCont]->updateInfo(hClient) == TRUE)
147  		{
148  			break;
149  		}
150  	}
151  }
152  void DockingManager::showFloatingContainers(bool show)
153  {
154  	for (size_t i=0; i < _vContainer.size(); i++)
155  	{
156  		size_t iElementCnt = _vContainer[i]->getElementCnt();
157  		if (iElementCnt > 0)
158  		{
159  			if (0 < ::SendMessage(_vContainer[i]->getTabWnd(), TCM_GETITEMCOUNT, 0, 0)) 
160  				_vContainer[i]->display(show);
161  		}
162  	}
163  }
164  LRESULT DockingManager::runProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
165  {
166  	switch (message)
167  	{
168  		case WM_ERASEBKGND:
169  		{
170  			if (!NppDarkMode::isEnabled())
171  			{
172  				break;
173  			}
174  			RECT rc{};
175  			::GetClientRect(hwnd, &rc);
176  			::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
177  			return TRUE;
178  		}
179  		case WM_NCACTIVATE:
180  		{
181  			for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
182  			{
183  				::SendMessage(_vContainer[iCont]->getHSelf(), WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
184  			}
185  			if (static_cast<int>(lParam) != -1)
186  			{
187  				::SendMessage(_hParent, WM_NCACTIVATE, wParam, static_cast<LPARAM>(-1));
188  			}
189  			break;
190  		}
191  		case WM_MOVE:
192  		case WM_SIZE:
193  		{
194  			resize();
195  			break;
196  		}
197  		case WM_DESTROY:
198  		{
199  			if (hWndServer == hwnd)
200  			{
201  				UnhookWindowsHookEx(gWinCallHook);
202  				gWinCallHook = NULL;
203  				hWndServer = NULL;
204  			}
205  			if (_hImageList != NULL)
206  			{
207  				::ImageList_Destroy(_hImageList);
208  			}
209  			for (int32_t i = static_cast<int32_t>(_vContainer.size()); i > 0; i--)
210  			{
211  				_vContainer[i-1]->destroy();
212  				delete _vContainer[i-1];
213  			}
214  			CoUninitialize();
215  			break;
216  		}
217  		case DMM_LBUTTONUP:	
218  		{
219  			if (::GetActiveWindow() != _hParent)
220  				break;
221  			for (int i = 0; i < DOCKCONT_MAX; ++i)
222  			{
223  				_vContainer[i]->SetActive(IsChild(_vContainer[i]->getHSelf(), ::GetFocus()));
224  			}
225  			return TRUE;
226  		}
227  		case DMM_MOVE:
228  		{
229  			Gripper *pGripper = new Gripper;
230  			pGripper->init(_hInst, _hParent);
231  			pGripper->startGrip(reinterpret_cast<DockingCont*>(lParam), this);
232  			break;
233  		}
234  		case DMM_MOVE_SPLITTER:
235  		{
236  			int offset = static_cast<int32_t>(wParam);
237  			for (int iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
238  			{
239  				if (_vSplitter[iCont]->getHSelf() == reinterpret_cast<HWND>(lParam))
240  				{
241  					switch (iCont)
242  					{
243  						case CONT_TOP:
244  							_dockData.rcRegion[iCont].bottom -= offset;
245  							if (_dockData.rcRegion[iCont].bottom < 0)
246  							{
247  								_dockData.rcRegion[iCont].bottom = 0;
248  							}
249  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset < 0))
250  							{
251  								_dockData.rcRegion[iCont].bottom += offset;
252  							}
253  							break;
254  						case CONT_BOTTOM:
255  							_dockData.rcRegion[iCont].bottom   += offset;
256  							if (_dockData.rcRegion[iCont].bottom < 0)
257  							{
258  								_dockData.rcRegion[iCont].bottom   = 0;
259  							}
260  							if ((_rcWork.bottom < (-SPLITTER_WIDTH)) && (offset > 0))
261  							{
262  								_dockData.rcRegion[iCont].bottom -= offset;
263  							}
264  							break;
265  						case CONT_LEFT:
266  							_dockData.rcRegion[iCont].right    -= offset;
267  							if (_dockData.rcRegion[iCont].right < 0)
268  							{
269  								_dockData.rcRegion[iCont].right = 0;
270  							}
271  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset < 0))
272  							{
273  								_dockData.rcRegion[iCont].right += offset;
274  							}
275  							break;
276  						case CONT_RIGHT:
277  							_dockData.rcRegion[iCont].right    += offset;
278  							if (_dockData.rcRegion[iCont].right < 0)
279  							{
280  								_dockData.rcRegion[iCont].right = 0;
281  							}
282  							if ((_rcWork.right < SPLITTER_WIDTH) && (offset > 0))
283  							{
<span onclick='openModal()' class='match'>284  								_dockData.rcRegion[iCont].right -= offset;
285  							}
286  							break;
287  					}
</span>288  					resize();
289  					break;
290  				}
291  			}
292  			break;
293  		}
294  		case DMM_DOCK:
295  		case DMM_FLOAT:
296  		{
297  			toggleActiveTb(reinterpret_cast<DockingCont*>(lParam), message);
298  			return FALSE;
299  		}
300  		case DMM_CLOSE:
301  		{
302  			tTbData	TbData	= *(reinterpret_cast<DockingCont*>(lParam))->getDataOfActiveTb();
303  			LRESULT res = SendNotify(TbData.hClient, DMN_CLOSE);	
304  			return res;
305  		}
306  		case DMM_FLOATALL:
307  		{
308  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_FLOAT);
309  			return FALSE;
310  		}
311  		case DMM_DOCKALL:
312  		{
313  			toggleVisTb(reinterpret_cast<DockingCont*>(lParam), DMM_DOCK);
314  			return FALSE;
315  		}
316  		case DMM_GETIMAGELIST:
317  		{
318  			return reinterpret_cast<LPARAM>(_hImageList);
319  		}
320  		case DMM_GETICONPOS:
321  		{
322  			for (size_t uImageCnt = 0, len = _vImageList.size(); uImageCnt < len; ++uImageCnt)
323  			{
324  				if (reinterpret_cast<HWND>(lParam) == _vImageList[uImageCnt])
325  				{
326  					return uImageCnt;
327  				}
328  			}
329  			return -1;
330  		}
331  		default :
332  			break;
333  	}
334  	return ::DefWindowProc(_hSelf, message, wParam, lParam);
335  }
336  void DockingManager::resize()
337  {
338      reSizeTo(_rect);
339  }
340  void DockingManager::reSizeTo(RECT & rc)
341  {
342  	_rect = rc;
343  	_rcWork	= rc;
344  	if (_isInitialized == FALSE)
345  		return;
346  	_dockData.rcRegion[CONT_TOP].left      = rc.left;
347  	_dockData.rcRegion[CONT_TOP].top       = rc.top;
348  	_dockData.rcRegion[CONT_TOP].right     = rc.right-rc.left;
349  	_vSplitter[CONT_TOP]->display(false);
350  	if (_vContainer[CONT_TOP]->isVisible())
351  	{
352  		_rcWork.top		+= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
353  		_rcWork.bottom	-= _dockData.rcRegion[CONT_TOP].bottom + SPLITTER_WIDTH;
354  		RECT	rc = {_dockData.rcRegion[CONT_TOP].left  ,
355  					  _dockData.rcRegion[CONT_TOP].top + _dockData.rcRegion[CONT_TOP].bottom,
356  					  _dockData.rcRegion[CONT_TOP].right ,
357  					  SPLITTER_WIDTH};
358  		_vSplitter[CONT_TOP]->reSizeTo(rc);
359  	}
360  	_dockData.rcRegion[CONT_BOTTOM].left   = rc.left;
361  	_dockData.rcRegion[CONT_BOTTOM].top    = rc.top + rc.bottom - _dockData.rcRegion[CONT_BOTTOM].bottom;
362  	_dockData.rcRegion[CONT_BOTTOM].right  = rc.right-rc.left;
363  	RECT		rcBottom	= _dockData.rcRegion[CONT_BOTTOM];
364  	_vSplitter[CONT_BOTTOM]->display(false);
365  	if (_vContainer[CONT_BOTTOM]->isVisible())
366  	{
367  		_rcWork.bottom	-= _dockData.rcRegion[CONT_BOTTOM].bottom + SPLITTER_WIDTH;
368  		if (_rcWork.bottom < rc.top)
369  		{
370  			rcBottom.top     = _rcWork.top + rc.top + SPLITTER_WIDTH;
371  			rcBottom.bottom += _rcWork.bottom - rc.top;
372  			_rcWork.bottom = rc.top;
373  		}
374  		if ((rcBottom.bottom + SPLITTER_WIDTH) < 0)
375  		{
376  			_rcWork.bottom = rc.bottom - _dockData.rcRegion[CONT_TOP].bottom;
377  		}
378  		RECT	rc = {rcBottom.left,
379  					  rcBottom.top - SPLITTER_WIDTH,
380  					  rcBottom.right,
381  					  SPLITTER_WIDTH};
382  		_vSplitter[CONT_BOTTOM]->reSizeTo(rc);
383  	}
384  	_dockData.rcRegion[CONT_LEFT].left     = rc.left;
385  	_dockData.rcRegion[CONT_LEFT].top      = _rcWork.top;
386  	_dockData.rcRegion[CONT_LEFT].bottom   = _rcWork.bottom;
387  	_vSplitter[CONT_LEFT]->display(false);
388  	if (_vContainer[CONT_LEFT]->isVisible())
389  	{
390  		_rcWork.left		+= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
391  		_rcWork.right	-= _dockData.rcRegion[CONT_LEFT].right + SPLITTER_WIDTH;
392  		RECT	rc = {_dockData.rcRegion[CONT_LEFT].right,
393  					  _dockData.rcRegion[CONT_LEFT].top,
394  					  SPLITTER_WIDTH,
395  					  _dockData.rcRegion[CONT_LEFT].bottom};
396  		_vSplitter[CONT_LEFT]->reSizeTo(rc);
397  	}
398  	_dockData.rcRegion[CONT_RIGHT].left    = rc.right - _dockData.rcRegion[CONT_RIGHT].right;
399  	_dockData.rcRegion[CONT_RIGHT].top     = _rcWork.top;
400  	_dockData.rcRegion[CONT_RIGHT].bottom  = _rcWork.bottom;
401  	RECT		rcRight		= _dockData.rcRegion[CONT_RIGHT];
402  	_vSplitter[CONT_RIGHT]->display(false);
403  	if (_vContainer[CONT_RIGHT]->isVisible())
404  	{
405  		_rcWork.right	-= _dockData.rcRegion[CONT_RIGHT].right + SPLITTER_WIDTH;
406  		if (_rcWork.right < 15)
407  		{
408  			rcRight.left    = _rcWork.left + 15 + SPLITTER_WIDTH;
409  			rcRight.right  += _rcWork.right - 15;
410  			_rcWork.right	= 15;
411  		}
412  		RECT	rc = {rcRight.left - SPLITTER_WIDTH,
413  					  rcRight.top,
414  					  SPLITTER_WIDTH,
415  					  rcRight.bottom};
416  		_vSplitter[CONT_RIGHT]->reSizeTo(rc);
417  	}
418  	if (_vContainer[CONT_BOTTOM]->isVisible())
419  	{
420  		::SetWindowPos(_vContainer[CONT_BOTTOM]->getHSelf(), NULL,
421  					   rcBottom.left  ,
422  					   rcBottom.top   ,
423  					   rcBottom.right ,
424  					   rcBottom.bottom,
425  					   SWP_NOZORDER);
426  		_vSplitter[CONT_BOTTOM]->display();
427  	}
428  	if (_vContainer[CONT_TOP]->isVisible())
429  	{
430  		::SetWindowPos(_vContainer[CONT_TOP]->getHSelf(), NULL,
431  					   _dockData.rcRegion[CONT_TOP].left  ,
432  					   _dockData.rcRegion[CONT_TOP].top   ,
433  					   _dockData.rcRegion[CONT_TOP].right ,
434  					   _dockData.rcRegion[CONT_TOP].bottom,
435  					   SWP_NOZORDER);
436  		_vSplitter[CONT_TOP]->display();
437  	}
438  	if (_vContainer[CONT_RIGHT]->isVisible())
439  	{
440  		::SetWindowPos(_vContainer[CONT_RIGHT]->getHSelf(), NULL,
441  					   rcRight.left  ,
442  					   rcRight.top   ,
443  					   rcRight.right ,
444  					   rcRight.bottom,
445  					   SWP_NOZORDER);
446  		_vSplitter[CONT_RIGHT]->display();
447  	}
448  	if (_vContainer[CONT_LEFT]->isVisible())
449  	{
450  		::SetWindowPos(_vContainer[CONT_LEFT]->getHSelf(), NULL,
451  					   _dockData.rcRegion[CONT_LEFT].left  ,
452  					   _dockData.rcRegion[CONT_LEFT].top   ,
453  					   _dockData.rcRegion[CONT_LEFT].right ,
454  					   _dockData.rcRegion[CONT_LEFT].bottom,
455  					   SWP_NOZORDER);
456  		_vSplitter[CONT_LEFT]->display();
457  	}
458  	(*_ppMainWindow)->reSizeTo(_rcWork);
459  }
460  void DockingManager::createDockableDlg(tTbData data, int iCont, bool isVisible)
461  {
462  	if ((data.uMask & DWS_ICONTAB) && data.hIconTab != NULL)
463  	{
464  		if (_hImageList == NULL)
465  		{
466  			int iconDpiDynamicalSize = NppParameters::getInstance()._dpiManager.scaleY(12) + 2;
467  			_hImageList = ::ImageList_Create(iconDpiDynamicalSize, iconDpiDynamicalSize, ILC_COLOR32 | ILC_MASK, 0, 0);
468  		}
469  		::ImageList_AddIcon(_hImageList, data.hIconTab);
470  		_vImageList.push_back(data.hClient);
471  	}
472  	if ((data.uMask & DWS_USEOWNDARKMODE) != DWS_USEOWNDARKMODE && NppDarkMode::isEnabledForPlugins())
473  	{
474  		NppDarkMode::autoSubclassAndThemePluginDockWindow(data.hClient);
475  	}
476  	RECT				rc			= {0,0,0,0};
477  	DockingCont*		pCont		= NULL;
478  	if (memcmp(&data.rcFloat, &rc, sizeof(RECT)) == 0)
479  	{
480  		::GetWindowRect(data.hClient, &data.rcFloat);
481  		if (iCont == -1)
482  		{
483  			isVisible = (::IsWindowVisible(data.hClient) == TRUE);
484  			if (data.uMask & DWS_DF_FLOATING)
485  			{
486  				pCont = new DockingCont;
487  				_vContainer.push_back(pCont);
488  				pCont->init(_hInst, _hSelf);
489  				pCont->doDialog(isVisible, true);
490  				data.iPrevCont = (data.uMask & 0x30000000) >> 28;
491  				iCont = static_cast<int32_t>(_vContainer.size()) - 1;
492  			}
493  			else
494  			{
495  				iCont = (data.uMask & 0x30000000) >> 28;
496  				data.iPrevCont = -1;
497  			}
498  		}
499  	}
500  	else if ((iCont >= DOCKCONT_MAX) || (data.iPrevCont >= DOCKCONT_MAX))
501  	{
502  		if (iCont >= DOCKCONT_MAX)
503  		{
504  			if (_iContMap[iCont] == -1)
505  			{
506  				pCont = new DockingCont;
507  				_vContainer.push_back(pCont);
508  				pCont->init(_hInst, _hSelf);
509  				pCont->doDialog(isVisible, true);
510  				_iContMap[iCont] = static_cast<int32_t>(_vContainer.size()) - 1;
511  			}
512  			iCont = _iContMap[iCont];
513  		}
514  		else
515  		{
516  			if (_iContMap[data.iPrevCont] == -1)
517  			{
518  				pCont = new DockingCont;
519  				_vContainer.push_back(pCont);
520  				pCont->init(_hInst, _hSelf);
521  				pCont->doDialog(false, true);
522  				pCont->reSizeToWH(data.rcFloat);
523  				_iContMap[data.iPrevCont] = static_cast<int32_t>(_vContainer.size()) - 1;
524  			}
525  			data.iPrevCont = _iContMap[data.iPrevCont];
526  		}
527  	}
528  	if (_vContainer.size() > static_cast<size_t>(iCont) && _vContainer[iCont] != nullptr)
529  	{
530  		_vContainer[iCont]->createToolbar(data);
531  		for (const auto& cont : _vContainer)
532  		{
533  			if (cont->isVisible() && cont != _vContainer[iCont])
534  			{
535  				::RedrawWindow(cont->getHSelf(), nullptr, nullptr, RDW_INVALIDATE);
536  			}
537  		}
538  	}
539  	if (iCont < DOCKCONT_MAX)
540  		SendNotify(data.hClient, MAKELONG(DMN_DOCK, iCont));
541  	else
542  		SendNotify(data.hClient, MAKELONG(DMN_FLOAT, iCont));
543  }
544  void DockingManager::setActiveTab(int iCont, int iItem)
545  {
546  	if ((iCont == -1) || (_iContMap[iCont] == -1))
547  		return;
548  	_vContainer[_iContMap[iCont]]->setActiveTb(iItem);
549  }
550  void DockingManager::showDockableDlg(HWND hDlg, BOOL view)
551  {
552  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
553  	{
554  		tTbData *pTbData = _vContainer[i]->findToolbarByWnd(hDlg);
555  		if (pTbData != NULL)
556  		{
557  			_vContainer[i]->showToolbar(pTbData, view);
558  			return;
559  		}
560  	}
561  }
562  void DockingManager::showDockableDlg(TCHAR* pszName, BOOL view)
563  {
564  	for (size_t i = 0, len = _vContainer.size(); i < len; ++i)
565  	{
566  		tTbData *pTbData = _vContainer[i]->findToolbarByName(pszName);
567  		if (pTbData != NULL)
568  		{
569  			_vContainer[i]->showToolbar(pTbData, view);
570  			return;
571  		}
572  	}
573  }
574  LRESULT DockingManager::SendNotify(HWND hWnd, UINT message)
575  {
576  	NMHDR nmhdr{};
577  	nmhdr.code		= message;
578  	nmhdr.hwndFrom	= _hParent;
579  	nmhdr.idFrom	= ::GetDlgCtrlID(_hParent);
580  	::SendMessage(hWnd, WM_NOTIFY, nmhdr.idFrom, reinterpret_cast<LPARAM>(&nmhdr));
581  	return ::GetWindowLongPtr(hWnd, DWLP_MSGRESULT);
582  }
583  void DockingManager::setDockedContSize(int iCont, int iSize)
584  {
585  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
586  		_dockData.rcRegion[iCont].bottom = iSize;
587  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
588  		_dockData.rcRegion[iCont].right = iSize;
589  	else
590  		return;
591  	resize();
592  }
593  int DockingManager::getDockedContSize(int iCont)
594  {
595  	if ((iCont == CONT_TOP) || (iCont == CONT_BOTTOM))
596  		return _dockData.rcRegion[iCont].bottom;
597  	else if ((iCont == CONT_LEFT) || (iCont == CONT_RIGHT))
598  		return _dockData.rcRegion[iCont].right;
599  	else
600  		return -1;
601  }
602  DockingCont* DockingManager::toggleActiveTb(DockingCont* pContSrc, UINT message, BOOL bNew, LPRECT prcFloat)
603  {
604  	tTbData			TbData		= *pContSrc->getDataOfActiveTb();
605  	int				iContSrc	= GetContainer(pContSrc);
606  	int				iContPrev	= TbData.iPrevCont;
607  	BOOL			isCont		= ContExists(iContPrev);
608  	DockingCont*	pContTgt	= NULL;
609  	if (prcFloat != NULL)
610  	{
611  		TbData.rcFloat = *prcFloat;
612  	}
613  	if ((isCont == FALSE) || (bNew == TRUE))
614  	{
615  		int	iContNew = FindEmptyContainer();
616  		if (iContNew == -1)
617  		{
618  			pContTgt = new DockingCont;
619  			pContTgt->init(_hInst, _hSelf);
620  			pContTgt->doDialog(true, true);
621  			if ((bNew == FALSE) || (!pContSrc->isFloating()))
622  				TbData.iPrevCont = iContSrc;
623  			pContTgt->createToolbar(TbData);
624  			_vContainer.push_back(pContTgt);
625  		}
626  		else
627  		{
628  			pContTgt = _vContainer[iContNew];
629  			if ((pContSrc->isFloating()) != (pContTgt->isFloating()))
630                  TbData.iPrevCont = iContSrc;
631  			pContTgt->createToolbar(TbData);
632  		}
633  	}
634  	else
635  	{
636  		pContTgt = _vContainer[iContPrev];
637  		TbData.iPrevCont = iContSrc;
638  		pContTgt->createToolbar(TbData);
639  	}
640  	SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
641  	_vContainer[iContSrc]->removeToolbar(TbData);
642  	return pContTgt;
643  }
644  DockingCont* DockingManager::toggleVisTb(DockingCont* pContSrc, UINT message, LPRECT prcFloat)
645  {
646  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
647  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
648  	int					iContSrc	= GetContainer(pContSrc);
649  	int					iContPrev	= pTbData->iPrevCont;
650  	BOOL				isCont		= ContExists(iContPrev);
651  	DockingCont*		pContTgt	= NULL;
652  	pContSrc->doDialog(false);
653  	resize();
654  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
655  	{
656  		tTbData		TbData = *vTbData[iTb];
657  		if (prcFloat != NULL)
658  		{
659  			TbData.rcFloat = *prcFloat;
660  		}
661  		if (isCont == FALSE)
662  		{
663  			pContTgt = new DockingCont;
664  			pContTgt->init(_hInst, _hSelf);
665  			pContTgt->doDialog(true, true);
666  			TbData.iPrevCont = iContSrc;
667  			pContTgt->createToolbar(TbData);
668  			_vContainer.push_back(pContTgt);
669  			isCont	= TRUE;
670  			iContPrev = GetContainer(pContTgt);
671  		}
672  		else
673  		{
674  			pContTgt = _vContainer[iContPrev];
675  			TbData.iPrevCont = iContSrc;
676  			pContTgt->createToolbar(TbData);
677  		}
678  		SendNotify(TbData.hClient, MAKELONG(message==DMM_DOCK?DMN_DOCK:DMN_FLOAT, GetContainer(pContTgt)));
679  		_vContainer[iContSrc]->removeToolbar(TbData);
680  	}
681  	_vContainer[iContPrev]->setActiveTb(pTbData);
682  	return pContTgt;
683  }
684  void DockingManager::toggleActiveTb(DockingCont* pContSrc, DockingCont* pContTgt)
685  {
686  	tTbData		TbData		= *pContSrc->getDataOfActiveTb();
687  	toggleTb(pContSrc, pContTgt, TbData);
688  }
689  void DockingManager::toggleVisTb(DockingCont* pContSrc, DockingCont* pContTgt)
690  {
691  	vector<tTbData*>	vTbData		= pContSrc->getDataOfVisTb();
692  	tTbData*			pTbData		= pContSrc->getDataOfActiveTb();
693  	pContSrc->doDialog(false);
694  	resize();
695  	for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
696  	{
697  		tTbData		TbData = *vTbData[iTb];
698  		toggleTb(pContSrc, pContTgt, TbData);
699  	}
700  	pContTgt->setActiveTb(pTbData);
701  }
702  void DockingManager::toggleTb(DockingCont* pContSrc, DockingCont* pContTgt, tTbData TbData)
703  {
704  	int					iContSrc	= GetContainer(pContSrc);
705  	int					iContTgt	= GetContainer(pContTgt);
706  	if (((iContSrc <  DOCKCONT_MAX) && (iContTgt >= DOCKCONT_MAX)) ||
707  		((iContSrc >= DOCKCONT_MAX) && (iContTgt <  DOCKCONT_MAX)))
708  	{
709  		TbData.iPrevCont = iContSrc;
710  	}
711  	if (iContTgt < DOCKCONT_MAX)
712  		SendNotify(TbData.hClient, MAKELONG(DMN_DOCK, iContTgt));
713  	else
714  		SendNotify(TbData.hClient, MAKELONG(DMN_FLOAT, iContTgt));
715  	pContTgt->createToolbar(TbData);
716  	_vContainer[iContSrc]->removeToolbar(TbData);
717  }
718  BOOL DockingManager::ContExists(size_t iCont)
719  {
720  	BOOL	bRet = FALSE;
721  	if (iCont < _vContainer.size())
722  	{
723  		bRet = TRUE;
724  	}
725  	return bRet;
726  }
727  int DockingManager::GetContainer(DockingCont* pCont)
728  {
729  	int iRet = -1;
730  	for (size_t iCont = 0, len = _vContainer.size(); iCont < len; ++iCont)
731  	{
732  		if (_vContainer[iCont] == pCont)
733  		{
734  			iRet = static_cast<int32_t>(iCont);
735  			break;
736  		}
737  	}
738  	return iRet;
739  }
740  int DockingManager::FindEmptyContainer()
741  {
742      int      iRetCont       = -1;
743      BOOL*    pPrevDockList  = (BOOL*) new BOOL[_vContainer.size()+1];
744      BOOL*    pArrayPos      = &pPrevDockList[1];
745      for (size_t iCont = 0, len = _vContainer.size()+1; iCont < len; ++iCont)
746      {
747          pPrevDockList[iCont] = FALSE;
748      }
749      for (size_t iCont = 0; iCont < DOCKCONT_MAX; ++iCont)
750      {
751          vector<tTbData*>    vTbData = _vContainer[iCont]->getDataOfAllTb();
752          for (size_t iTb = 0, len = vTbData.size(); iTb < len; ++iTb)
753          {
754              pArrayPos[vTbData[iTb]->iPrevCont] = TRUE;
755          }
756      }
757      for (size_t iCont = DOCKCONT_MAX, len = _vContainer.size(); iCont < len; ++iCont)
758      {
759          if (pArrayPos[iCont] == FALSE)
760          {
761              if (!_vContainer[iCont]->isVisible())
762              {
763  				iRetCont = static_cast<int32_t>(iCont);
764                  break;
765              }
766          }
767      }
768      delete [] pPrevDockList;
769      return iRetCont;
770  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DockingManager.cpp</div>
                </div>
                <div class="column column_space"><pre><code>262  								_dockData.rcRegion[iCont].bottom -= offset;
263  							}
264  							break;
265  						case CONT_LEFT:
</pre></code></div>
                <div class="column column_space"><pre><code>284  								_dockData.rcRegion[iCont].right -= offset;
285  							}
286  							break;
287  					}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    