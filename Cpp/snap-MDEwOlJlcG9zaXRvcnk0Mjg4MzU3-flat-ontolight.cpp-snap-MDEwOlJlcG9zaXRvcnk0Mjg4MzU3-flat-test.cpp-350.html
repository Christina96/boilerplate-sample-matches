
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</h3>
            <pre><code>1  void TLwLangBs::SaveTxt(FILE* fOut){
2    fprintf(fOut, &quot;===LwLangBs-Begin====================\n&quot;);
3    for (int LangN=0; LangN&lt;GetLangs(); LangN++){
4      int LangId=GetLangId(LangN);
5      fprintf(fOut, &quot;N:%d Id:%d Nm:&#x27;%s&#x27; Desc:&#x27;%s&#x27;\n&quot;,
6       LangN, LangId, GetLangNm(LangId).CStr(), GetLangDesc(LangId).CStr());
7    }
8    fprintf(fOut, &quot;===LwLangBs-End======================\n&quot;);
9  }
10  void TLwTermType::SaveTxt(FILE* fOut){
11    fprintf(fOut, &quot;Id:%d Nm:&#x27;%s&#x27; LangId:%d Desc:&#x27;%s&#x27;\n&quot;,
12      GetTermTypeId(), GetTermTypeNm().CStr(), GetLangId(), GetDescStr().CStr());
13  }
14  void TLwTerm::SaveTxt(FILE* fOut){
15    fprintf(fOut, &quot;Id:%d Nm:&#x27;%s&#x27; LangId:%d TermTypeId:%d Desc:&#x27;%s&#x27;\n&quot;,
16     GetTermId(), GetTermNm().CStr(), GetLangId(), GetTermTypeId(), GetDescStr().CStr());
17  }
18  int TLwTermTypeBs::AddTermType(const PLwTermType&amp; LwTermType){
19    IAssert(!IsTermTypeId(LwTermType-&gt;GetTermTypeId()));
20    IdToTermTypeVH.AddDat(LwTermType-&gt;GetTermTypeId()).Add(LwTermType);
21    TStrIntPr TermTypeNmLangIdPr=
22     TStrIntPr(LwTermType-&gt;GetTermTypeNm(), LwTermType-&gt;GetLangId());
23    TermTypeNmLangIdToIdH.AddDat(TermTypeNmLangIdPr, LwTermType-&gt;GetTermTypeId());
24    return LwTermType-&gt;GetTermTypeId();
25  }
26  void TLwTermTypeBs::SaveTxt(FILE* fOut){
27    fprintf(fOut, &quot;===LwTermTypeBs-Begin================\n&quot;);
28    for (int TermTypeN=0; TermTypeN&lt;GetTermTypes(); TermTypeN++){
29      fprintf(fOut, &quot;N:%d &quot;, TermTypeN);
30      GetTermType(GetTermTypeId(TermTypeN))-&gt;SaveTxt(fOut);
31    }
32    fprintf(fOut, &quot;===LwTermTypeBs-End==================\n&quot;);
33  }
34  void TLwTermBs::AddTerm(const PLwTerm&amp; Term){
35    IAssert(Onto-&gt;GetLangBs()-&gt;IsLangId(Term-&gt;GetLangId()));
36    if (Term-&gt;GetTermId()&gt;MxTermId){MxTermId=Term-&gt;GetTermId();}
37    IdToTermVH.AddDat(Term-&gt;GetTermId()).Add(Term);
38    TermNmLangIdToToTermIdH.AddDat(
39     TStrIntPr(Term-&gt;GetTermNm(), Term-&gt;GetLangId()), Term-&gt;GetTermId());
40  }
41  int TLwTermBs::AddTermGetTermId(const PLwTerm&amp; Term){
42    IAssert(Term-&gt;GetTermId()==-1);
43    Term-&gt;PutTermId(MxTermId+1);
44    AddTerm(Term);
45    return Term-&gt;GetTermId();
46  }
47  PLwTerm TLwTermBs::GetTerm(const int&amp; TermId){
48    TLwTermV TermV=IdToTermVH.GetDat(TermId);
49    if (Onto-&gt;GetLangBs()-&gt;IsLangNm(&quot;EN&quot;)){
50      int EnLangId=Onto-&gt;GetLangBs()-&gt;GetLangId(&quot;EN&quot;);
51      for (int TermN=0; TermN&lt;TermV.Len(); TermN++){
52        if (TermV[TermN]-&gt;GetLangId()==EnLangId){return TermV[TermN];}
53      }
54    }
55    return TermV[0];
56  }
57  void TLwTermBs::SaveTxt(FILE* fOut){
58    fprintf(fOut, &quot;===LwTermBs-Begin====================\n&quot;);
59    for (int TermN=0; TermN&lt;GetTerms(); TermN++){
60      TLwTermV TermV; GetTermV(GetTermId(TermN), TermV);
61      for (int SubTermN=0; SubTermN&lt;TermV.Len(); SubTermN++){
62        if (TermV.Len()==1){fprintf(fOut, &quot;N:%d &quot;, TermN);}
63        else {fprintf(fOut, &quot;N:%d/%d &quot;, TermN, SubTermN);}
64        TermV[SubTermN]-&gt;SaveTxt(fOut);
65      }
66      Onto-&gt;GetLinkBs()-&gt;SaveTxt(fOut, GetTermId(TermN), &quot;   &quot;);
67    }
68    fprintf(fOut, &quot;===LwTermBs-End======================\n&quot;);
69  }
70  void TLwLinkType::SaveTxt(FILE* fOut){
71    fprintf(fOut, &quot;Id:%d Nm:&#x27;%s&#x27; LangId:%d SDesc:&#x27;%s&#x27; Desc:&#x27;%s&#x27; RevLinkTypeId:%d ParentLinkTypeId:%d\n&quot;,
72     GetLinkTypeId(), GetLinkTypeNm().CStr(), GetLangId(),
73     GetSDescStr().CStr(), GetDescStr().CStr(),
74     GetReverseLinkTypeId(), GetParentLinkTypeId());
75  }
76  void TLwLinkTypeBs::AddLinkType(const PLwLinkType&amp; LwLinkType){
77    IdToLinkTypeVH.AddDat(LwLinkType-&gt;GetLinkTypeId()).Add(LwLinkType);
78    TStrIntPr LinkTypeNmLangIdPr(LwLinkType-&gt;GetLinkTypeNm(), LwLinkType-&gt;GetLangId());
79    IAssert(!LinkTypeNmLangIdToIdH.IsKey(LinkTypeNmLangIdPr));
80    LinkTypeNmLangIdToIdH.AddDat(LinkTypeNmLangIdPr, LwLinkType-&gt;GetLinkTypeId());
81  }
82  void TLwLinkTypeBs::SaveTxt(FILE* fOut){
83    fprintf(fOut, &quot;===LwLinkTypeBs-Begin================\n&quot;);
84    for (int LinkTypeN=0; LinkTypeN&lt;GetLinkTypes(); LinkTypeN++){
85      fprintf(fOut, &quot;N:%d &quot;, LinkTypeN);
86      GetLinkType(GetLinkTypeId(LinkTypeN))-&gt;SaveTxt(fOut);
87    }
88    fprintf(fOut, &quot;===LwLinkTypeBs-End==================\n&quot;);
89  }
90  int TLwLinkBs::GetLinks() const {
91    int Links=0;
92    int TermIds=FromTermIdToLinkTypeIdTermIdPrVH.Len();
93    for (int TermIdN=0; TermIdN&lt;TermIds; TermIdN++){
94      Links+=FromTermIdToLinkTypeIdTermIdPrVH[TermIdN].Len();}
95    return Links;
96  }
97  void TLwLinkBs::AddLink(const int TermId1, int LinkTypeId, int TermId2){
98    IAssert(Onto-&gt;GetTermBs()-&gt;IsTermId(TermId1));
99    IAssert(Onto-&gt;GetLinkTypeBs()-&gt;IsLinkTypeId(LinkTypeId));
100    IAssert(Onto-&gt;GetTermBs()-&gt;IsTermId(TermId2));
101    FromTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId1).Add(TIntPr(LinkTypeId, TermId2));
102    IntoTermIdToLinkTypeIdTermIdPrVH.AddDat(TermId2).Add(TIntPr(LinkTypeId, TermId1));
103  }
104  int TLwLinkBs::GetFromLinks(const int SrcTermId) const {
105    if (FromTermIdToLinkTypeIdTermIdPrVH.IsKey(SrcTermId)){
106      return FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId).Len();
107    } else {return 0;}
108  }
109  void TLwLinkBs::GetFromLink(
110   const int SrcTermId, const int&amp; LinkN, int&amp; LinkTypeId, int&amp; DstTermId){
111    TIntPr&amp; LinkTypeIdDstTermIdPr=
112     FromTermIdToLinkTypeIdTermIdPrVH.GetDat(SrcTermId)[LinkN];
113    LinkTypeId=LinkTypeIdDstTermIdPr.Val1;
114    DstTermId=LinkTypeIdDstTermIdPr.Val2;
115  }
116  int TLwLinkBs::GetIntoLinks(const int DstTermId) const {
117    if (IntoTermIdToLinkTypeIdTermIdPrVH.IsKey(DstTermId)){
118      return IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId).Len();
119    } else {return 0;}
120  }
121  void TLwLinkBs::GetIntoLink(
122   const int DstTermId, const int&amp; LinkN, int&amp; LinkTypeId, int&amp; SrcTermId){
123    TIntPr&amp; LinkTypeIdSrcTermIdPr=
124     IntoTermIdToLinkTypeIdTermIdPrVH.GetDat(DstTermId)[LinkN];
125    LinkTypeId=LinkTypeIdSrcTermIdPr.Val1;
126    SrcTermId=LinkTypeIdSrcTermIdPr.Val2;
127  }
128  void TLwLinkBs::SaveTxt(FILE* fOut, const int&amp; TermId, const TStr&amp; IndentStr){
129    for (int LinkN=0; LinkN&lt;GetFromLinks(TermId); LinkN++){
130      int LinkTypeId; int DstTermId;
131      GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
132      TStr LinkTypeNm=Onto-&gt;GetLinkTypeBs()-&gt;GetLinkType(LinkTypeId)-&gt;GetLinkTypeNm();
133      TStr DstTermNm=Onto-&gt;GetTermBs()-&gt;GetTerm(DstTermId)-&gt;GetTermNm();
134      fprintf(fOut, &quot;%s--&gt;%s--&gt; DstTermId:%d DstTermNm:&#x27;%s&#x27;\n&quot;, IndentStr.CStr(),
135       LinkTypeNm.CStr(), DstTermId, DstTermNm.CStr());
136    }
137    for (int LinkN=0; LinkN&lt;GetIntoLinks(TermId); LinkN++){
138      int LinkTypeId; int SrcTermId;
139      GetIntoLink(TermId, LinkN, LinkTypeId, SrcTermId);
140      TStr LinkTypeNm=Onto-&gt;GetLinkTypeBs()-&gt;GetLinkType(LinkTypeId)-&gt;GetLinkTypeNm();
141      TStr SrcTermNm=Onto-&gt;GetTermBs()-&gt;GetTerm(SrcTermId)-&gt;GetTermNm();
142      fprintf(fOut, &quot;%s&lt;--%s&lt;-- SrcTermId:%d SrcTermNm:&#x27;%s&#x27;\n&quot;, IndentStr.CStr(),
143       LinkTypeNm.CStr(), SrcTermId, SrcTermNm.CStr());
144    }
145  }
146  void TLwOnto::SaveTxt(const TStr&amp; FNm){
147    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
148    fprintf(fOut, &quot;===LwOnto-Begin======================\n&quot;);
149    GetLangBs()-&gt;SaveTxt(fOut);
150    fprintf(fOut, &quot;\n&quot;);
151    GetTermTypeBs()-&gt;SaveTxt(fOut);
152    fprintf(fOut, &quot;\n&quot;);
153    GetLinkTypeBs()-&gt;SaveTxt(fOut);
154    fprintf(fOut, &quot;\n&quot;);
155    GetTermBs()-&gt;SaveTxt(fOut);
156    fprintf(fOut, &quot;===LwOnto-End========================\n&quot;);
157  }
158  PLwOnto TLwOnto::LoadAgroVoc(const TStr&amp; FPath){
159    TStr NrFPath=TStr::GetNrFPath(FPath);
160    PLwOnto LwOnto=TLwOnto::New();
161    {TStr AvLangFNm=NrFPath+&quot;language.txt&quot;;
162    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, AvLangFNm.CStr());
163    PSs AvLangSs=TSs::LoadTxt(ssfCommaSep, AvLangFNm);
164    int AvLangSs_LangNmFldN=AvLangSs-&gt;GetFldX(&quot;languagecode&quot;);
165    int AvLangSs_LangDescFldN=AvLangSs-&gt;GetFldX(&quot;name&quot;);
166    for (int Y=1; Y&lt;AvLangSs-&gt;GetYLen(); Y++){
167      TStr LangNm=AvLangSs-&gt;GetVal(AvLangSs_LangNmFldN, Y);
168      TStr LangDesc=AvLangSs-&gt;GetVal(AvLangSs_LangDescFldN, Y);
169      LwOnto-&gt;GetLangBs()-&gt;AddLang(LangNm, LangDesc);
170    }
171    printf(&quot; Done. (%d)\n&quot;, AvLangSs-&gt;GetYLen()-1);}
172    {TStr AvTermFNm=NrFPath+&quot;agrovocterm.txt&quot;;
173    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, AvTermFNm.CStr());
174    PSs AvTermSs=TSs::LoadTxt(ssfCommaSep, AvTermFNm);
175    int AvTermSs_TermIdFldN=AvTermSs-&gt;GetFldX(&quot;termcode&quot;);
176    int AvTermSs_LangNmFldN=AvTermSs-&gt;GetFldX(&quot;languagecode&quot;);
177    int AvTermSs_TermSpellFldN=AvTermSs-&gt;GetFldX(&quot;termspell&quot;);
178    for (int Y=1; Y&lt;AvTermSs-&gt;GetYLen(); Y++){
179      int TermId=AvTermSs-&gt;GetVal(AvTermSs_TermIdFldN, Y).GetInt();
180      TStr LangNm=AvTermSs-&gt;GetVal(AvTermSs_LangNmFldN, Y);
181      TStr TermNm=AvTermSs-&gt;GetVal(AvTermSs_TermSpellFldN, Y);
182      int LangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(LangNm);
183      PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId);
184      LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
185    }
186    printf(&quot; Done. (%d)\n&quot;, AvTermSs-&gt;GetYLen()-1);}
187    {TStr AvLinkTypeFNm=NrFPath+&quot;linktype.txt&quot;;
188    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, AvLinkTypeFNm.CStr());
189    PSs AvLinkTypeSs=TSs::LoadTxt(ssfCommaSep, AvLinkTypeFNm);
190    int AvLinkTypeSs_LinkTypeIdFldN=AvLinkTypeSs-&gt;GetFldX(&quot;linktypeid&quot;);
191    int AvLinkTypeSs_LangIdFldN=AvLinkTypeSs-&gt;GetFldX(&quot;languagecode&quot;);
192    int AvLinkTypeSs_LinkSDescFldN=AvLinkTypeSs-&gt;GetFldX(&quot;linkdesc&quot;);
193    int AvLinkTypeSs_LinkNmFldN=AvLinkTypeSs-&gt;GetFldX(&quot;linkabr&quot;);
194    int AvLinkTypeSs_LinkDescFldN=AvLinkTypeSs-&gt;GetFldX(&quot;linkdescription&quot;);
195    int AvLinkTypeSs_ReverseLinkIdFldN=AvLinkTypeSs-&gt;GetFldX(&quot;rlinkcode&quot;);
196    int AvLinkTypeSs_ParentLinkTypeIdFldN=AvLinkTypeSs-&gt;GetFldX(&quot;parentlinktypeid&quot;);
197    for (int Y=1; Y&lt;AvLinkTypeSs-&gt;GetYLen(); Y++){
198      int LinkTypeId=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_LinkTypeIdFldN, Y).GetInt();
199      TStr LinkTypeNm=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_LinkNmFldN, Y);
200      TStr LangNm=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_LangIdFldN, Y);
201      TStr SDescStr=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_LinkSDescFldN, Y);
202      TStr DescStr=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_LinkDescFldN, Y);
203      int ReverseLinkTypeId=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_ReverseLinkIdFldN, Y).GetInt(-1);
204      int ParentLinkTypeId=AvLinkTypeSs-&gt;GetVal(AvLinkTypeSs_ParentLinkTypeIdFldN, Y).GetInt(-1);
205      int LangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(LangNm);
206      PLwLinkType LwLinkType=TLwLinkType::New();
207      LwLinkType-&gt;PutLinkTypeId(LinkTypeId);
208      LwLinkType-&gt;PutLinkTypeNm(LinkTypeNm);
209      LwLinkType-&gt;PutLangId(LangId);
210      LwLinkType-&gt;PutSDescStr(SDescStr);
211      LwLinkType-&gt;PutDescStr(DescStr);
212      LwLinkType-&gt;PutReverseLinkTypeId(ReverseLinkTypeId);
213      LwLinkType-&gt;PutParentLinkTypeId(ParentLinkTypeId);
214      LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(LwLinkType);
215    }
216    printf(&quot; Done. (%d)\n&quot;, AvLinkTypeSs-&gt;GetYLen()-1);}
217    {TStr AvTermLinkFNm=NrFPath+&quot;termlink.txt&quot;;
218    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, AvTermLinkFNm.CStr());
219    PSs AvTermLinkSs=TSs::LoadTxt(ssfCommaSep, AvTermLinkFNm);
220    int AvTermLinkSs_TermId1FldN=AvTermLinkSs-&gt;GetFldX(&quot;termcode1&quot;);
221    int AvTermLinkSs_TermId2FldN=AvTermLinkSs-&gt;GetFldX(&quot;termcode2&quot;);
222    int AvTermLinkSs_LinkTypeIdFldN=AvTermLinkSs-&gt;GetFldX(&quot;linktypeid&quot;);
223    for (int Y=1; Y&lt;AvTermLinkSs-&gt;GetYLen(); Y++){
224      int TermId1=AvTermLinkSs-&gt;GetVal(AvTermLinkSs_TermId1FldN, Y).GetInt();
225      int TermId2=AvTermLinkSs-&gt;GetVal(AvTermLinkSs_TermId2FldN, Y).GetInt();
226      int LinkTypeId=AvTermLinkSs-&gt;GetVal(AvTermLinkSs_LinkTypeIdFldN, Y).GetInt();
227      if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(TermId1)){printf(&quot;#&quot;); continue;}
228      if (!LwOnto-&gt;GetTermBs()-&gt;IsTermId(TermId2)){printf(&quot;*&quot;); continue;}
229      LwOnto-&gt;GetLinkBs()-&gt;AddLink(TermId1, LinkTypeId, TermId2);
230    }
231    printf(&quot; Done. (%d)\n&quot;, AvTermLinkSs-&gt;GetYLen()-1);}
232    return LwOnto;
233  }
234  PLwOnto TLwOnto::LoadEuroVoc(const TStr&amp; FPath){
235    TStr NrFPath=TStr::GetNrFPath(FPath);
236    PLwOnto LwOnto=TLwOnto::New();
237    TStr EvTermFNm=NrFPath+&quot;listMultiLg_All.txt&quot;;
238    printf(&quot;Loading &#x27;%s&#x27; ...\n&quot;, EvTermFNm.CStr());
239    PSs EvTermSs=TSs::LoadTxt(ssfTabSep, EvTermFNm);
240    int EvTermSs_TermIdFldN=EvTermSs-&gt;GetFldX(&quot;ID&quot;); IAssert(EvTermSs_TermIdFldN==0);
241    int XLen=EvTermSs-&gt;GetXLen(EvTermSs_TermIdFldN);
242    for (int X=1; X&lt;XLen; X++){
243      TStr LangNm=EvTermSs-&gt;GetVal(X, 0); 
244      LwOnto-&gt;GetLangBs()-&gt;AddLang(LangNm, LangNm); 
245    }
246    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(&quot;EN&quot;);
247    PLwTermType D_TermType=TLwTermType::New(0, &quot;Descriptor&quot;, EnLangId);
248    PLwTermType ND_TermType=TLwTermType::New(1, &quot;Non-descriptor&quot;, EnLangId);
249    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(D_TermType);
250    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(ND_TermType);
251    for (int Y=1; Y&lt;EvTermSs-&gt;GetYLen(); Y++){
252      printf(&quot;%d/%d\r&quot;, Y, EvTermSs-&gt;GetYLen());
253      int TermId=EvTermSs-&gt;GetVal(EvTermSs_TermIdFldN, Y).GetInt();
254      for (int X=1; X&lt;XLen; X++){
255        TStr LangNm=EvTermSs-&gt;GetVal(X, 0);
256        TStr TermNm=EvTermSs-&gt;GetVal(X, Y);
257        int LangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(LangNm);
258        PLwTerm Term=TLwTerm::New(TermId, TermNm, LangId, D_TermType-&gt;GetTermTypeId());
259        LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
260      }
261    }
262    printf(&quot;\nDone. (%d)\n&quot;, EvTermSs-&gt;GetYLen()-1);
263    {PLwLinkType BT_LinkType=TLwLinkType::New(0, &quot;BT&quot;, EnLangId, &quot;Broader-Term&quot;);
264    PLwLinkType NT_LinkType=TLwLinkType::New(1, &quot;NT&quot;, EnLangId, &quot;Narrower-Term&quot;);
265    PLwLinkType MT_LinkType=TLwLinkType::New(2, &quot;MT&quot;, EnLangId, &quot;Micro-Theory&quot;);
266    PLwLinkType RT_LinkType=TLwLinkType::New(3, &quot;RT&quot;, EnLangId, &quot;Related-Term&quot;);
267    PLwLinkType UF_LinkType=TLwLinkType::New(4, &quot;UF&quot;, EnLangId, &quot;Used-For&quot;);
268    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(BT_LinkType);
269    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(NT_LinkType);
270    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(MT_LinkType);
271    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(RT_LinkType);
272    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(UF_LinkType);}
273    {TStr EvLinkFNm=NrFPath+&quot;eurovoc.txt&quot;;
274    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, EvLinkFNm.CStr());
275    PSs EvLinkSs=TSs::LoadTxt(ssfTabSep, EvLinkFNm);
276    int EvLinkSs_TermId1FldN=EvLinkSs-&gt;GetFldX(&quot;term&quot;);
277    int EvLinkSs_LinkTypeNmFldN=EvLinkSs-&gt;GetFldX(&quot;link&quot;);
278    int EvLinkSs_TermId2FldN=EvLinkSs-&gt;GetFldX(&quot;subterm&quot;);
279    int EvLinkSs_TermNmFldN=EvLinkSs-&gt;GetFldX(&quot;name&quot;);
280    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(&quot;EN&quot;);
281    for (int Y=1; Y&lt;EvLinkSs-&gt;GetYLen(); Y++){
282      int TermId1=EvLinkSs-&gt;GetVal(EvLinkSs_TermId1FldN, Y).GetInt();
283      TStr LinkTypeNm=EvLinkSs-&gt;GetVal(EvLinkSs_LinkTypeNmFldN, Y);
284      int TermId2=EvLinkSs-&gt;GetVal(EvLinkSs_TermId2FldN, Y).GetInt();
285      TStr TermNm=EvLinkSs-&gt;GetVal(EvLinkSs_TermNmFldN, Y);
286      if (LinkTypeNm==&quot;UF&quot;){
287        IAssert(TermId2==-1);
288        PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, ND_TermType-&gt;GetTermTypeId());
289        TermId2=LwOnto-&gt;GetTermBs()-&gt;AddTermGetTermId(Term);
290        int LinkTypeId=LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypeId(LinkTypeNm, EnLangId);
291        LwOnto-&gt;GetLinkBs()-&gt;AddLink(TermId1, LinkTypeId, TermId2);
292      } else {
293        if (LinkTypeNm==&quot;NT1&quot;){LinkTypeNm=&quot;NT&quot;;}
294        if (LinkTypeNm==&quot;BT1&quot;){LinkTypeNm=&quot;BT&quot;;}
295        if ((LinkTypeNm==&quot;BT&quot;)||(LinkTypeNm==&quot;NT&quot;)||(LinkTypeNm==&quot;RT&quot;)){
296          int LinkTypeId=LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypeId(LinkTypeNm, EnLangId);
297          LwOnto-&gt;GetLinkBs()-&gt;AddLink(TermId1, LinkTypeId, TermId2);
298        }
299      }
300    }
301    printf(&quot; Done. (%d)\n&quot;, EvLinkSs-&gt;GetYLen()-1);}
302    return LwOnto;
303  }
304  PLwOnto TLwOnto::LoadAsfaVoc(const TStr&amp; FPath){
305    TStr NrFPath=TStr::GetNrFPath(FPath);
306    PLwOnto LwOnto=TLwOnto::New();
307    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;AddLang(&quot;EN&quot;, &quot;English&quot;);
308    {PLwTermType D_TermType=TLwTermType::New(0, &quot;Descriptor&quot;, EnLangId);
309    PLwTermType ND_TermType=TLwTermType::New(1, &quot;Non-descriptor&quot;, EnLangId);
310    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(D_TermType);
311    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(ND_TermType);}
312    {PLwLinkType BT_LinkType=TLwLinkType::New(0, &quot;BT&quot;, EnLangId, &quot;Broader-Term&quot;);
313    PLwLinkType NT_LinkType=TLwLinkType::New(1, &quot;NT&quot;, EnLangId, &quot;Narrower-Term&quot;);
314    PLwLinkType RT_LinkType=TLwLinkType::New(2, &quot;RT&quot;, EnLangId, &quot;Related-Term&quot;);
315    PLwLinkType UF_LinkType=TLwLinkType::New(3, &quot;UF&quot;, EnLangId, &quot;Used-For&quot;);
316    PLwLinkType USE_LinkType=TLwLinkType::New(4, &quot;USE&quot;, EnLangId, &quot;Used-By&quot;);
317    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(BT_LinkType);
318    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(NT_LinkType);
319    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(RT_LinkType);
320    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(UF_LinkType);
321    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(USE_LinkType);}
322    TStr AsfaOntoFNm=NrFPath+&quot;asfa_xml_20060522.xml&quot;;
323    printf(&quot;Loading &#x27;%s&#x27; ...&quot;, AsfaOntoFNm.CStr());
<span onclick='openModal()' class='match'>324    PXmlDoc AsfaXmlDoc=TXmlDoc::LoadTxt(AsfaOntoFNm);
325    IAssert(AsfaXmlDoc-&gt;IsOk());
326    TXmlTokV ConceptXmlTokV;
</span>327    AsfaXmlDoc-&gt;GetTagTokV(&quot;THESAURUS|CONCEPT&quot;, ConceptXmlTokV);
328    printf(&quot; Done.\n&quot;);
329    {printf(&quot;Creating terms ...&quot;);
330    for (int ConceptN=0; ConceptN&lt;ConceptXmlTokV.Len(); ConceptN++){
331      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
332      TStr TermNm;
333      if (ConceptXmlTok-&gt;IsSubTag(&quot;NON-DESCRIPTOR&quot;)){
334        TermNm=ConceptXmlTok-&gt;GetTagTokStr(&quot;NON-DESCRIPTOR&quot;);}
335      else if (ConceptXmlTok-&gt;IsSubTag(&quot;DESCRIPTOR&quot;)){
336        TermNm=ConceptXmlTok-&gt;GetTagTokStr(&quot;DESCRIPTOR&quot;);}
337      TStr TermTypeNm=ConceptXmlTok-&gt;GetTagTokStr(&quot;TYP&quot;);
338      int TermTypeId=LwOnto-&gt;GetTermTypeBs()-&gt;GetTermTypeId(TermTypeNm, EnLangId);
339      TStr DescStr;
340      if (ConceptXmlTok-&gt;IsSubTag(&quot;SN&quot;)){
341        DescStr=ConceptXmlTok-&gt;GetTagTokStr(&quot;SN&quot;);
342        DescStr.ChangeChAll(&#x27;\r&#x27;, &#x27; &#x27;); DescStr.ChangeChAll(&#x27;\n&#x27;, &#x27; &#x27;);
343        DescStr.ChangeStrAll(&quot;  &quot;, &quot; &quot;); DescStr.ToTrunc();
344      }
345      PLwTerm Term=TLwTerm::New(-1, TermNm, EnLangId, TermTypeId, DescStr);
346      LwOnto-&gt;GetTermBs()-&gt;AddTermGetTermId(Term);
347    }
348    printf(&quot; Done. (%d)\n&quot;, LwOnto-&gt;GetTermBs()-&gt;GetTerms());}
349    {printf(&quot;Creating links ...&quot;);
350    for (int ConceptN=0; ConceptN&lt;ConceptXmlTokV.Len(); ConceptN++){
351      PXmlTok ConceptXmlTok=ConceptXmlTokV[ConceptN];
352      TStr TermNm1;
353      if (ConceptXmlTok-&gt;IsSubTag(&quot;NON-DESCRIPTOR&quot;)){
354        TermNm1=ConceptXmlTok-&gt;GetTagTokStr(&quot;NON-DESCRIPTOR&quot;);}
355      else if (ConceptXmlTok-&gt;IsSubTag(&quot;DESCRIPTOR&quot;)){
356        TermNm1=ConceptXmlTok-&gt;GetTagTokStr(&quot;DESCRIPTOR&quot;);}
357      int TermId1=LwOnto-&gt;GetTermBs()-&gt;GetTermId(TermNm1, EnLangId);
358      for (int SubTokN=0; SubTokN&lt;ConceptXmlTok-&gt;GetSubToks(); SubTokN++){
359        PXmlTok SubTok=ConceptXmlTok-&gt;GetSubTok(SubTokN);
360        if (SubTok-&gt;IsTag()){
361          TStr LinkTypeNm=SubTok-&gt;GetTagNm();
362          if (LwOnto-&gt;GetLinkTypeBs()-&gt;IsLinkType(LinkTypeNm, EnLangId)){
363            TStr TermNm2=ConceptXmlTok-&gt;GetTagTokStr(LinkTypeNm);
364            int TermId2=LwOnto-&gt;GetTermBs()-&gt;GetTermId(TermNm2, EnLangId);
365            int LinkTypeId=LwOnto-&gt;GetLinkTypeBs()-&gt;GetLinkTypeId(LinkTypeNm, EnLangId);
366            LwOnto-&gt;GetLinkBs()-&gt;AddLink(TermId1, LinkTypeId, TermId2);
367          }
368        }
369      }
370    }
371    printf(&quot; Done. (%d)\n&quot;, LwOnto-&gt;GetLinkBs()-&gt;GetLinks());}
372    return LwOnto;
373  }
374  PLwOnto TLwOnto::LoadDMozVoc(const TStr&amp; DMozBinFBase, const TStr&amp; FPath){
375    PDMozBs DMozBs=TDMozBs::LoadBin(DMozBinFBase, FPath);
376    int Cats=DMozBs-&gt;GetCats();
377    PLwOnto LwOnto=TLwOnto::New();
378    int EnLangId=LwOnto-&gt;GetLangBs()-&gt;AddLang(&quot;EN&quot;, &quot;English&quot;);
379    PLwTermType Cat_TermType=TLwTermType::New(0, &quot;Category&quot;, EnLangId);
380    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(Cat_TermType);
381    PLwLinkType NT_LinkType=TLwLinkType::New(0, &quot;NT&quot;, EnLangId, &quot;Narrow&quot;);
382    PLwLinkType RT_LinkType=TLwLinkType::New(1, &quot;RT&quot;, EnLangId, &quot;Related&quot;);
383    PLwLinkType SL_LinkType=TLwLinkType::New(2, &quot;SL&quot;, EnLangId, &quot;Symbolic&quot;);
384    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(NT_LinkType);
385    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(RT_LinkType);
386    LwOnto-&gt;GetLinkTypeBs()-&gt;AddLinkType(SL_LinkType);
387    {printf(&quot;Creating terms ...\n&quot;);
388    for (int CatId=0; CatId&lt;Cats; CatId++){
389      if (CatId%1000==0){printf(&quot;%d/%d\r&quot;, CatId, Cats);}
390      TStr TermNm=DMozBs-&gt;GetCatNm(CatId);
391      PLwTerm Term=TLwTerm::New(CatId, TermNm, EnLangId, Cat_TermType-&gt;GetTermTypeId());
392      LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
393    }
394    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetTermBs()-&gt;GetTerms());}
395    {printf(&quot;Creating links ...\n&quot;); 
396    for (int CatId=0; CatId&lt;Cats; CatId++){
397      TStr CatNm=DMozBs-&gt;GetCatNm(CatId);
398      if (CatId%1000==0){printf(&quot;%d/%d\r&quot;, CatId, Cats);}
399      TUIntV SubCatTypeIdPrV; DMozBs-&gt;GetSubCatTypeIdPrV(CatId, SubCatTypeIdPrV);
400      for (int SubCatN=0; SubCatN&lt;SubCatTypeIdPrV.Len(); SubCatN++){
401        int SubCatId; TDMozSubCatType SubCatType;
402        TDMozBs::GetSubCatTypeCatId(SubCatTypeIdPrV[SubCatN], SubCatType, SubCatId);
403        TStr SubCatNm=DMozBs-&gt;GetCatNm(SubCatId);
404        int LinkTypeId=-1;
405        switch (SubCatType){
406          case dmsctNarrow: LinkTypeId=NT_LinkType-&gt;GetLinkTypeId(); break;
407          case dmsctRelated: LinkTypeId=RT_LinkType-&gt;GetLinkTypeId(); break;
408          case dmsctSymbolic: LinkTypeId=SL_LinkType-&gt;GetLinkTypeId(); break;
409          default: LinkTypeId=-1;
410        }
411        if (LinkTypeId!=-1){
412          LwOnto-&gt;GetLinkBs()-&gt;AddLink(CatId, LinkTypeId, SubCatId);
413        }
414      }
415    }
416    printf(&quot; Done. (%d)\n&quot;, LwOnto-&gt;GetLinkBs()-&gt;GetLinks());}
417    return LwOnto;
418  }
419  PLwOnto TLwOnto::LoadVoc(const TStr&amp; FNm) {
420    PLwOnto LwOnto = TLwOnto::New();
421    int EnLangId = LwOnto-&gt;GetLangBs()-&gt;AddLang(&quot;EN&quot;, &quot;English&quot;);
422    PLwTermType TermType = TLwTermType::New(0, &quot;Term&quot;, EnLangId);
423    LwOnto-&gt;GetTermTypeBs()-&gt;AddTermType(TermType);
424    {printf(&quot;Creating terms ...\n&quot;);
425    TStr VocFileStr = TStr::LoadTxt(FNm); 
426    VocFileStr.DelChAll(&#x27;\r&#x27;);
427    TStrV TermNmV; VocFileStr.SplitOnAllCh(&#x27;\n&#x27;, TermNmV);
428    const int Terms = TermNmV.Len();
429    for (int TermId = 0; TermId&lt;Terms; TermId++){
430      if (TermId%1000==0){printf(&quot;%d/%d\r&quot;, TermId, Terms);}
431      TStr TermNm = TermNmV[TermId];
432      PLwTerm Term=TLwTerm::New(TermId, TermNm, EnLangId, TermType-&gt;GetTermTypeId());
433      LwOnto-&gt;GetTermBs()-&gt;AddTerm(Term);
434    }
435    printf(&quot;Done. (%d)\n&quot;, LwOnto-&gt;GetTermBs()-&gt;GetTerms());}
436    return LwOnto;
437  }
438  void TLwOntoGround::SaveTxt(const TStr&amp; FNm){
439    PLwTermBs TermBs=LwOnto-&gt;GetTermBs();
440    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
441    fprintf(fOut, &quot;===LwOnto-Begin======================\n&quot;);
442    for (int TermN=0; TermN&lt;TermBs-&gt;GetTerms(); TermN++){
443      int TermId=TermBs-&gt;GetTermId(TermN);
444      TStr TermNm=TermBs-&gt;GetTerm(TermId)-&gt;GetTermNm();
445      fprintf(fOut, &quot;TermId:%d TermNm:&#x27;%s&#x27;&quot;, TermId, TermNm.CStr());
446      if (TermIdToConceptSpVH.IsKey(TermId)){
447        PBowSpV ConceptSpV=TermIdToConceptSpVH.GetDat(TermId);
448        TStr ConceptSpVStr=ConceptSpV-&gt;GetStr(BowDocBs, 15, 0.66);
449        fprintf(fOut, &quot; ConceptSpV:%s&quot;, ConceptSpVStr.CStr());
450      }
451      fprintf(fOut, &quot;\n&quot;);
452    }
453  }
454  PLwOntoGround TLwOntoGround::GetOntoGround(
455   const PLwOnto&amp; LwOnto, const PBowDocBs&amp; BowDocBs,
456   const TStr&amp; LangNm, const bool&amp; DocCatIsTermIdP,
457   const double&amp; CutWordWgtSumPrc){
458    printf(&quot;Generating Ontology-Classifier...\n&quot;);
459    PLwTermBs TermBs=LwOnto-&gt;GetTermBs();
460    int Terms=TermBs-&gt;GetTerms();
461    PLwLinkBs LinkBs=LwOnto-&gt;GetLinkBs();
462    PLwLinkTypeBs LinkTypeBs=LwOnto-&gt;GetLinkTypeBs();
463    int LangId=LwOnto-&gt;GetLangBs()-&gt;GetLangId(LangNm);
464    int Docs=BowDocBs-&gt;GetDocs();
465    printf(&quot;  Creating BowDocWgtBs ...&quot;);
466    PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
467    PBowSim BowSim=TBowSim::New(bstCos);
468    printf(&quot; Done.\n&quot;);
469    printf(&quot;  Collecting documents per ontology-term ...\n&quot;);
470    TIntIntVH TermIdToDIdVH; int PosCats=0; int NegCats=0;
471    for (int DId=0; DId&lt;Docs; DId++){
472      printf(&quot;    Docs:%d/%d Pos:%d Neg:%d\r&quot;, 1+DId, Docs, PosCats, NegCats);
473      for (int DocCIdN=0; DocCIdN&lt;BowDocBs-&gt;GetDocCIds(DId); DocCIdN++){
474        int CId=BowDocBs-&gt;GetDocCId(DId, DocCIdN);
475        TStr CatNm=BowDocBs-&gt;GetCatNm(CId);
476        if (DocCatIsTermIdP){
477          int TermId=CatNm.GetInt();
478          if (TermBs-&gt;IsTermId(TermId)){
479            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
480          } else {NegCats++;}
481        } else {
482          if (TermBs-&gt;IsTermId(CatNm, LangId)){
483            int TermId=TermBs-&gt;GetTermId(CatNm, LangId);
484            TermIdToDIdVH.AddDat(TermId).Add(DId); PosCats++;
485          } else {NegCats++;}
486        }
487      }
488    }
489    printf(&quot;    Docs:%d/%d Pos:%d Neg:%d\n&quot;, Docs, Docs, PosCats, NegCats);
490    printf(&quot;  Done.\n&quot;);
491    printf(&quot;  Creating sub-terms &amp; up-terms vectors ...&quot;);
492    TIntIntVH Const_TermIdToSubTermIdVH;
493    TIntIntVH TermIdToSubTermIdVH;
494    TIntIntVH TermIdToUpTermIdVH;
495    for (int TermN=0; TermN&lt;Terms; TermN++){
496      int TermId=TermBs-&gt;GetTermId(TermN);
497      for (int LinkN=0; LinkN&lt;LinkBs-&gt;GetFromLinks(TermId); LinkN++){
498        int LinkTypeId; int DstTermId;
499        LinkBs-&gt;GetFromLink(TermId, LinkN, LinkTypeId, DstTermId);
500        TStr LinkTypeNm=LinkTypeBs-&gt;GetLinkType(LinkTypeId)-&gt;GetLinkTypeNm();
501        if (LinkTypeNm==&quot;NT&quot;){
502          Const_TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
503          TermIdToSubTermIdVH.AddDat(TermId).Add(DstTermId);
504          TermIdToUpTermIdVH.AddDat(DstTermId).Add(TermId);
505        }
506      }
507    }
508    printf(&quot;   Done.\n&quot;);
509    printf(&quot;  Creating centroids ...\n&quot;);
510    THash&lt;TInt, PBowSpV&gt; TermIdToConceptSpVH;
511    TIntIntVH TermIdToSubTermDIdVH;
512    TIntH ProcTermIdH;
513    int PrevActiveTerms=-1;
514    forever{
515      int ActiveTerms=0;
516      for (int TermN=0; TermN&lt;Terms; TermN++){
517        int TermId=TermBs-&gt;GetTermId(TermN);
518        if ((TermIdToSubTermIdVH.IsKey(TermId))&amp;&amp;
519         (TermIdToSubTermIdVH.GetDat(TermId).Len()&gt;0)){
520          ActiveTerms++;
521        }
522      }
523      printf(&quot;    Active-Terms:%d\n&quot;, ActiveTerms);
524      if (ActiveTerms==PrevActiveTerms){break;}
525      PrevActiveTerms=ActiveTerms;
526      for (int TermN=0; TermN&lt;Terms; TermN++){
527        int TermId=TermBs-&gt;GetTermId(TermN);
528        if (ProcTermIdH.IsKey(TermId)){continue;}
529        if ((!TermIdToSubTermIdVH.IsKey(TermId))||
530         (TermIdToSubTermIdVH.GetDat(TermId).Len()==0)){
531          printf(&quot;    %d/%d\r&quot;, 1+TermN, Terms);
532          ProcTermIdH.AddKey(TermId);
533          TIntV TermDIdV;
534          if (TermIdToDIdVH.IsKey(TermId)){
535            TermDIdV.AddV(TermIdToDIdVH.GetDat(TermId));}
536          if (TermIdToSubTermDIdVH.IsKey(TermId)){
537            TermDIdV.AddV(TermIdToSubTermDIdVH.GetDat(TermId));}
538          if (TermDIdV.Len()&gt;0){
539            PBowSpV ConceptSpV=
540             TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, TermDIdV, CutWordWgtSumPrc);
541            TermIdToConceptSpVH.AddDat(TermId, ConceptSpV);
542          }
543          if (TermIdToUpTermIdVH.IsKey(TermId)){
544            TIntV&amp; UpTermIdV=TermIdToUpTermIdVH.GetDat(TermId);
545            for (int UpTermIdN=0; UpTermIdN&lt;UpTermIdV.Len(); UpTermIdN++){
546              int UpTermId=UpTermIdV[UpTermIdN];
547              TermIdToSubTermIdVH.GetDat(UpTermId).DelIfIn(TermId);
548              if (TermDIdV.Len()&gt;0){
549                TermIdToSubTermDIdVH.AddDat(UpTermId).AddV(TermDIdV);}
550            }
551          }
552        }
553      }
554    }
555    printf(&quot;  Done.\n&quot;);
556    PLwOntoGround OntoGround=
557     TLwOntoGround::New(LwOnto, BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
558    printf(&quot;Done.\n&quot;);
559    return OntoGround;
560  }
561  PLwOntoGround TLwOntoGround::GetOntoGroundNN(const PLwOnto&amp; LwOnto, 
562          const PBowDocBs&amp; BowDocBs, const TStr&amp; LangNm) {
563      printf(&quot;Generating Ontology-Classifier...\n&quot;);
564      PLwTermBs TermBs=LwOnto-&gt;GetTermBs();
565      const int Terms = TermBs-&gt;GetTerms();
566      const int LangId = LwOnto-&gt;GetLangBs()-&gt;GetLangId(LangNm);
567      const int Words = BowDocBs-&gt;GetWords();
568      printf(&quot;  Creating BowDocWgtBs ...&quot;);
569      PBowDocWgtBs BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
570      PBowSim BowSim=TBowSim::New(bstCos);
571      printf(&quot; Done.\n&quot;);
572      printf(&quot;  Collecting documents per ontology-term ... &quot;);
573      THash&lt;TInt, PBowSpV&gt; TermIdToConceptSpVH;
574      for (int TermN = 0; TermN &lt; Terms; TermN++){
575          int TermId = TermBs-&gt;GetTermId(TermN);
576          PLwTerm Term = TermBs-&gt;GetTerm(TermId);
577          if (Term-&gt;GetLangId() != LangId) { continue; }
578          PBowSpV TermSpV = BowDocBs-&gt;GetSpVFromHtmlStr(
579              Term-&gt;GetTermNm(), BowDocWgtBs);
580          TFltIntKdV SimDIdKdV;
581          BowDocWgtBs-&gt;GetSimDIdV(TermSpV, BowSim, SimDIdKdV, false);
582          TFltV TermV(Words); TermV.PutAll(0.0);
583          for (int SimDIdKdN = 0; SimDIdKdN &lt; SimDIdKdV.Len(); SimDIdKdN++) {
584              PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(SimDIdKdV[SimDIdKdN].Dat);
585              const double Sim = SimDIdKdV[SimDIdKdN].Key;
586              TBowLinAlg::AddVec(Sim, DocSpV, TermV);
587          }
588          TermIdToConceptSpVH.AddDat(TermId, TBowSpV::New(-1, TermV, TFlt::Eps));
589      }
590      printf(&quot;  Done.\n&quot;);
591      PLwOntoGround OntoGround = TLwOntoGround::New(LwOnto, 
592          BowDocBs, BowDocWgtBs, TermIdToConceptSpVH);
593      printf(&quot;Done.\n&quot;);
594      return OntoGround;
595  }
596  void TLwOntoGround::ClassifySpV(
597   const PBowSpV&amp; QueryBowSpV, TSimTermIdPrV&amp; SimTermIdPrV) const {
598    PBowSim BowSim=TBowSim::New(bstCos);
599    SimTermIdPrV.Clr();
600    for (int TermN=0; TermN&lt;TermIdToConceptSpVH.Len(); TermN++){
601      int TermId=TermIdToConceptSpVH.GetKey(TermN);
602      PBowSpV ConceptSpV=TermIdToConceptSpVH[TermN];
603      double Sim=BowSim-&gt;GetSim(QueryBowSpV, ConceptSpV);
604      TStr TermNm = GetLwOnto()-&gt;GetTermBs()-&gt;GetTerm(TermId)-&gt;GetTermNm();
605      if (Sim &gt; 0.0) { SimTermIdPrV.Add(TFltIntPr(Sim, TermId)); } 
606    }
607    SimTermIdPrV.Sort(false);
608  }
609  void TLwOntoGround::ClassifyStr(
610   const TStr&amp; QueryStr, TSimTermIdPrV&amp; SimTermIdPrV) const {
611    PBowDocBs BowDocBs=GetBowDocBs();
612    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
613    PBowSpV QueryBowSpV=
614     BowDocBs-&gt;GetSpVFromHtmlStr(QueryStr, BowDocWgtBs);
615    ClassifySpV(QueryBowSpV, SimTermIdPrV);
616  }
617  void TLwOntoGround::ClassifyHtmlFNm(
618   const TStr&amp; QueryHtmlFNm, TSimTermIdPrV&amp; SimTermIdPrV) const {
619    PBowDocBs BowDocBs=GetBowDocBs();
620    PBowDocWgtBs BowDocWgtBs=GetBowDocWgtBs();
621    PBowSpV QueryBowSpV=
622     BowDocBs-&gt;GetSpVFromHtmlFile(QueryHtmlFNm, BowDocWgtBs);
623    ClassifySpV(QueryBowSpV, SimTermIdPrV);
624  }
625  void TLwOntoGround::SaveCfySetTxt(
626   FILE* fTxt, TSimTermIdPrV&amp; SimTermIdPrV, const int&amp; MxRank){
627    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
628    for (int TermN=0; TermN&lt;Terms; TermN++){
629      double Sim=SimTermIdPrV[TermN].Val1;
630      int TermId=SimTermIdPrV[TermN].Val2;
631      TStr TermNm=LwOnto-&gt;GetTermBs()-&gt;GetTerm(TermId)-&gt;GetTermNm();
632      fprintf(fTxt, &quot;%2d. %.3f %s\n&quot;, 1+TermN, Sim, TermNm.CStr());
633    }
634  }
635  void TLwOntoGround::SaveCfySetXml(
636   FILE* fXml, TSimTermIdPrV&amp; SimTermIdPrV, const int&amp; MxRank){
637    fprintf(fXml, &quot;&lt;OntoClassify&gt;\n&quot;);
638    int Terms=(MxRank==-1) ? SimTermIdPrV.Len() : MxRank;
639    for (int TermN=0; TermN&lt;Terms; TermN++){
640      double Sim=SimTermIdPrV[TermN].Val1;
641      int TermId=SimTermIdPrV[TermN].Val2;
642      TStr TermNm=LwOnto-&gt;GetTermBs()-&gt;GetTerm(TermId)-&gt;GetTermNm();
643      fprintf(fXml, &quot;&lt;Term Rank=\&quot;%d\&quot; Sim=\&quot;%.3f\&quot;&gt;%s&lt;/Term&gt;\n&quot;,
644       1+TermN, Sim, TermNm.CStr());
645    }
646    fprintf(fXml, &quot;&lt;/OntoClassify&gt;\n&quot;);
647  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &lt;stdio.h&gt;
3  #include &lt;sys/time.h&gt;
4  #include &lt;ctime&gt; 
5  double timeInSeconds(struct timeval &amp;tv1, struct timeval &amp;tv2) {
6    double diff = 0;
7    diff += (double)(tv2.tv_sec - tv1.tv_sec);
8    diff += (double)(tv2.tv_usec - tv1.tv_usec) / 1000000;
9    return diff;
10  }
11  template &lt;class PGraph&gt;
12  bool checkResults(TBreathFS&lt;PGraph&gt; &amp;bfs_hybrid, TBreathFS&lt;PGraph&gt; &amp;bfs) {
13    int num = 0;
14    if (bfs.NIdDistH.Len() != bfs_hybrid.NIdDistH.Len()) {
15      printf(&quot;NIdDistH length does not match.\n&quot;);
16      return false;
17    }
18    for (TIntH::TIter it = bfs.NIdDistH.BegI(); it &lt; bfs.NIdDistH.EndI(); it++) {
19      num++;
20      int key = it.GetKey();
21      if (bfs.NIdDistH.GetDat(key) != bfs_hybrid.NIdDistH.GetDat(key)) {
22        printf(&quot;Incorrect! NId: %d, Original: %d, Hybrid: %d\n&quot;, key, bfs.NIdDistH.GetDat(key)(), bfs_hybrid.NIdDistH.GetDat(key)());
23        return false;
24      }
25    }
26    IAssert(num == bfs.Graph-&gt;GetNodes());
27    return true;
28  }
29  template &lt;class PGraph&gt;
30  bool test(PGraph &amp;graph, bool followOut, bool followIn) {
31    printf(&quot;\n================================\nFollowOut: %d, FollowIn: %d\n&quot;, followOut, followIn);
32    int iters = 10;
33    for (int k = 0; k &lt; iters; k++) {
34      TRnd rnd = TRnd((int)time(0));
35      int start = graph-&gt;GetRndNId(rnd);
36      rnd.PutSeed(0);
37      int target = -1;
38      printf(&quot;Start node: %d\n&quot;, start);
39      struct timeval tv1, tv2;
40      gettimeofday(&amp;tv1, NULL);
41      TBreathFS&lt;PGraph&gt; bfs_hybrid(graph, true);
42      int maxDist_hybrid = bfs_hybrid.DoBfsHybrid(start, followOut, followIn, target);
43      gettimeofday(&amp;tv2, NULL);
44      double time_hybrid = timeInSeconds(tv1, tv2);
45      gettimeofday(&amp;tv1, NULL);
46      TBreathFS&lt;PGraph&gt; bfs(graph, true);
47      int maxDist = bfs.DoBfs(start, followOut, followIn, target);
48      gettimeofday(&amp;tv2, NULL);
49      double time = timeInSeconds(tv1, tv2);
50      if (maxDist_hybrid != maxDist) {
51        printf(&quot;MaxDist incorrect.\n&quot;);
52        return false;
53      }
54      if (target == -1) {
55        if (!checkResults&lt;PGraph&gt;(bfs_hybrid, bfs)) {
56          printf(&quot;NIdDistH values incorrect!\n&quot;);
57          return false;
58        }
59      }
60      printf(&quot;Execution times: Original: %.2f, Hybrid: %.2f\n&quot;, time, time_hybrid);
61    }
62    return true;
63  }
64  int main(int argc, char* argv[]) {
65    typedef PNGraph PGraph;  
66    printf(&quot;Creating graph for Livejournal\n&quot;);
67    TFIn FIn(&quot;data/livejournal_scc.graph&quot;);
<span onclick='openModal()' class='match'>68    PGraph graph = TNGraph::Load(FIn);
69    IAssert(graph-&gt;IsOk());
70    printf(&quot;Nodes: %d\n&quot;, graph-&gt;GetNodes());
</span>71    test&lt;PGraph&gt;(graph, true, false);
72    test&lt;PGraph&gt;(graph, false, true);
73    test&lt;PGraph&gt;(graph, true, true);
74    return 0;
75  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ontolight.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test.cpp</div>
                </div>
                <div class="column column_space"><pre><code>324    PXmlDoc AsfaXmlDoc=TXmlDoc::LoadTxt(AsfaOntoFNm);
325    IAssert(AsfaXmlDoc-&gt;IsOk());
326    TXmlTokV ConceptXmlTokV;
</pre></code></div>
                <div class="column column_space"><pre><code>68    PGraph graph = TNGraph::Load(FIn);
69    IAssert(graph-&gt;IsOk());
70    printf(&quot;Nodes: %d\n&quot;, graph-&gt;GetNodes());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    