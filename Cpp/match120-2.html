<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD><TITLE>Matches for toledo_nanochess_wb.c & pawns_1.cpp</TITLE>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>.modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgb(0, 0, 0);
        background-color: rgba(0, 0, 0, 0.4);
    }
    .modal-content {
        height: 250%;
        background-color: #fefefe;
        margin: 5% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
    }
    .close {
        color: #aaa;
        float: right;
        font-size: 20px;
        font-weight: bold;
    }
    .close:hover, .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }
    .column {
        float: left;
        width: 50%;
    }
    .row:after {
        content: ;
        display: table;
        clear: both;
    }
    #column1, #column2 {
        white-space: pre-wrap;
    }</style>
</head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
        <h3 align="center">
            Matches for toledo_nanochess_wb.c & pawns_1.cpp
        </h3>
        <h1 align="center">
            6.0%
        </h1>
        <center>
            <a href="index.html" target="_top">
                INDEX
            </a>
            <span>-</span>
            <a href="help-en.html" target="_top">
                HELP
            </a>
        </center>
    </div>
    <div>
        <TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
            <TR>
                <TH>
                <TH>toledo_nanochess_wb.c (6.976744%)
                <TH>pawns_1.cpp (5.357143%)
                <TH>Tokens
            <TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"'
                onmouseover='this.style.backgroundColor = "yellow"'>
                <TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT>
                <TD><A HREF="javascript:ZweiFrames('match120-0.html#0',2,'match120-1.html#0',3)" NAME="0">(33-35)
                <TD><A HREF="javascript:ZweiFrames('match120-0.html#0',2,'match120-1.html#0',3)" NAME="0">(110-132)</A>
                <TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
        </TABLE>
    </div>
</div>
<hr>
<div style="display: flex;">
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>toledo_nanochess_wb.c</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
1 #include &lt;stdio.h&gt;
2 #include &lt;time.h&gt;
3 char*l=&quot;ustvrtsuqqqqqqqqyyyyyyyy}{|~z|{}&quot;
4 &quot;   76Lsabcddcba .pknbrqmove %s\n\0?A6J57IKJT576,+-48HLSU&quot;;
5 #define v X(0,0,0,21,
6 #define Z while(
7 #define _ ;if(
8 #define P return--G,y^=8,
9 B,i,y,u,b,I[411],*G=I,x=10,z=15,M=1e4,f,j,m,n,t,o,L,E,D,O=100;X(w,c,h,e,S,s){
10 int t,o,L,E,d,O=e,N=-M*M,K=78-h&lt;&lt;x,p,*g,n,*m,A,q,r,C,J,a=y?-x:x;D++;y^=8;G++;d=
11 w||s&amp;&amp;s&gt;=h&amp;&amp;v 0,0)&gt;M;do{_ o=I[p=O]){q=o&amp;z^y _ q&lt;7){A=q--&amp;2?8:4;C=o-9&amp;z?q[
12 &quot;&amp; .$  &quot;]:42;do{r=I[p+=C[l]-64]_!w|p==w){g=q|p+a-S?0:I+S _!r&amp;(q|A&lt;3||g)||(r+1&amp;z
13 ^y)&gt;9&amp;&amp;q|A&gt;2){_ m=!(r-2&amp;7))P G[1]=O,K;J=n=o&amp;z;E=I[p-a]&amp;z;t=q|E-7?n:(n+=2,6^y);Z
14 n&lt;=t){L=r?l[r&amp;7]*9-189-h-q:0 _ s)L+=(1-q?l[p/x+5]-l[O/x+5]+l[p%x+6]*-~!q-l[O%x+
15 6]+o/16*8:!!m*9)+(q?0:!(I[p-1]^n)+!(I[p+1]^n)+l[n&amp;7]*9-386+!!g*99+(A&lt;2))+!(E^y^
16 9)_ s&gt;h||1&lt;s&amp;s==h&amp;&amp;L&gt;z|d){p[I]=n,O[I]=m?*g=*m,*m=0:g?*g=0:0;L-=X(s&gt;h|d?0:p,L-N,
17 h+1,G[1],J=q|A&gt;1?0:p,s)_!(h||s-1|B-O|i-n|p-b|L&lt;-M))P y^=8,u=J;J=q-1|A&lt;7||m||!s|
18 d|r|o&lt;z||v 0,0)&gt;M;O[I]=o;p[I]=r;m?*m=*g,*g=0:g?*g=9^y:0;}_ L&gt;N){*G=O _ s&gt;1){_ h
19 &amp;&amp;c-L&lt;0)P L _!h)i=n,B=O,b=p;}N=L;}n+=J||(g=I+p,m=p&lt;O?g-3:g+2,*m&lt;z|m[O-p]||I[p+=
20 p-O]);}}}}Z!r&amp;q&gt;2||(p=O,q|A&gt;2|o&gt;z&amp;!r&amp;&amp;++C*--A));}}}Z++O&gt;98?O=20:e-O);P N+M*M&amp;&amp;N
21 &gt;-K+1924|d?N:0;}
22 #define D(z)_!strcmp(g,#z))
23 <A NAME="0"></A>main(){char*a,g[80];clock_t k;setbuf(stdout,0);Z fgets(g+x,69,stdin)){sscanf(g+
24 x,&quot;%9s%d%d&quot;,g,&amp;n,&amp;D)D(quit)break D(force)f=1 D(post)j=1 D(nopost)j=0 D(level)o=
25 n,E=n?n:20,O=D*6e3/E D(time)O=n/(E-L%E+1)D(new){_*l-'u')l-=32;G=I;B=y=u=f=L=0;Z
26 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match120-1.html#0',3,'match120-top.html#0',1)"><IMG
27         SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>++B&lt;121)*G++=B/x%x&lt;2|B%x&lt;2?7:B/x&amp;4?0:*l++&amp;31;}D(go)f=0 D(protover)puts(
28 &quot;feature myname=\&quot;Toledo Nanochess Jan/11/2010\&quot; done=1&quot;)_ isalpha(*g)&amp;&amp;isdigit
29 (g[1])){a=g;B=*a++&amp;z;B+=100-(*a++&amp;z)*x;b=*a++&amp;z;b+=100-(*a++&amp;z)*x;i=(*a-'q'?*a-</B></FONT>
30 'r'?*a-98?*a-'n'?I[B]&amp;z^y:11:12:13:14)^y;v u,1)_!f)strcpy(g,&quot;go&quot;);}D(go){k=
31 clock();D=0;n=O&lt;50?4:5;B=21;do{m=X(0,0,0,B,u,n);t=(clock()-k)*1e2/
32 CLOCKS_PER_SEC;*g=B%x+96;g[1]=58-B/x;g[2]=b%x+96;g[3]=58-b/x;g[4]=I[B]-i&amp;z?l[i&amp;
33 7|16]:0;g[5]=0;n++;_ j)printf(&quot;%d %d %d %d %s\n&quot;,n,m,t,D,g);}Z m&gt;-M&amp;m&lt;M&amp;t*x&lt;O);
34 _ o)L++;v u,1);printf(l+23,g);}}}
</PRE>
    </div>
    <div style="flex-grow: 1;">
        <h3>
            <center>
                <span>pawns_1.cpp</span>
                <span> - </span>
                <span></span>
            </center>
        </h3>
        <HR>
        <PRE>
1 #include &lt;algorithm&gt;
2 #include &lt;cassert&gt;
3 #include &quot;bitboard.h&quot;
4 #include &quot;bitcount.h&quot;
5 #include &quot;pawns.h&quot;
6 #include &quot;position.h&quot;
7 namespace {
8   #define V Value
9   #define S(mg, eg) make_score(mg, eg)
10   const Score Doubled[FILE_NB] = {
11     S(13, 43), S(20, 48), S(23, 48), S(23, 48),
12     S(23, 48), S(23, 48), S(20, 48), S(13, 43) };
13   const Score Isolated[2][FILE_NB] = {
14   { S(37, 45), S(54, 52), S(60, 52), S(60, 52),
15     S(60, 52), S(60, 52), S(54, 52), S(37, 45) },
16   { S(25, 30), S(36, 35), S(40, 35), S(40, 35),
17     S(40, 35), S(40, 35), S(36, 35), S(25, 30) } };
18   const Score Backward[2][FILE_NB] = {
19   { S(30, 42), S(43, 46), S(49, 46), S(49, 46),
20     S(49, 46), S(49, 46), S(43, 46), S(30, 42) },
21   { S(20, 28), S(29, 31), S(33, 31), S(33, 31),
22     S(33, 31), S(33, 31), S(29, 31), S(20, 28) } };
23   Score Connected[FILE_NB][RANK_NB];
24   const Score CandidatePassed[RANK_NB] = {
25     S( 0, 0), S( 6, 13), S(6,13), S(14,29),
26     S(34,68), S(83,166), S(0, 0), S( 0, 0) };
27   const Score PawnsFileSpan = S(0, 15);
28   const Score UnsupportedPawnPenalty = S(20, 10);
29   const Value ShelterWeakness[RANK_NB] =
30   { V(100), V(0), V(27), V(73), V(92), V(101), V(101) };
31   const Value StormDanger[3][RANK_NB] = {
32   { V( 0),  V(64), V(128), V(51), V(26) },
33   { V(26),  V(32), V( 96), V(38), V(20) },
34   { V( 0),  V( 0), V(160), V(25), V(13) } };
35   const Value MaxSafetyBonus = V(263);
36   #undef S
37   #undef V
38   template&lt;Color Us&gt;
39   Score evaluate(const Position&amp; pos, Pawns::Entry* e) {
40     const Color  Them  = (Us == WHITE ? BLACK    : WHITE);
41     const Square Up    = (Us == WHITE ? DELTA_N  : DELTA_S);
42     const Square Right = (Us == WHITE ? DELTA_NE : DELTA_SW);
43     const Square Left  = (Us == WHITE ? DELTA_NW : DELTA_SE);
44     Bitboard b, p, doubled;
45     Square s;
46     File f;
47     bool passed, isolated, opposed, connected, backward, candidate, unsupported;
48     Score value = SCORE_ZERO;
49     const Square* pl = pos.list&lt;PAWN&gt;(Us);
50     Bitboard ourPawns = pos.pieces(Us, PAWN);
51     Bitboard theirPawns = pos.pieces(Them, PAWN);
52     e-&gt;passedPawns[Us] = e-&gt;candidatePawns[Us] = 0;
53     e-&gt;kingSquares[Us] = SQ_NONE;
54     e-&gt;semiopenFiles[Us] = 0xFF;
55     e-&gt;pawnAttacks[Us] = shift_bb&lt;Right&gt;(ourPawns) | shift_bb&lt;Left&gt;(ourPawns);
56     e-&gt;pawnsOnSquares[Us][BLACK] = popcount&lt;Max15&gt;(ourPawns &amp; DarkSquares);
57 <A NAME="0"></A>    e-&gt;pawnsOnSquares[Us][WHITE] = pos.count&lt;PAWN&gt;(Us) - e-&gt;pawnsOnSquares[Us][BLACK];
58 <FONT color="#0000ff"><div style="position:absolute;left:0"><A
59         HREF="javascript:ZweiFrames('match120-0.html#0',2,'match120-top.html#0',1)"><IMG SRC="back.gif" ALT="other"
60                                                                                          BORDER="0"
61                                                                                          ALIGN="left"></A></div><B>    while ((s = *pl++) != SQ_NONE)
62     {
63         assert(pos.piece_on(s) == make_piece(Us, PAWN));
64         f = file_of(s);
65         e-&gt;semiopenFiles[Us] &amp;= ~(1 &lt;&lt; f);
66         p = rank_bb(s - pawn_push(Us));
67         b = rank_bb(s) | p;
68         connected   =   ourPawns   &amp; adjacent_files_bb(f) &amp; b;
69         unsupported = !(ourPawns   &amp; adjacent_files_bb(f) &amp; p);
70         isolated    = !(ourPawns   &amp; adjacent_files_bb(f));
71         doubled     =   ourPawns   &amp; forward_bb(Us, s);
72         opposed     =   theirPawns &amp; forward_bb(Us, s);
73         passed      = !(theirPawns &amp; passed_pawn_mask(Us, s));</B></FONT>
74         if (   (passed | isolated | connected)
75             || (ourPawns &amp; pawn_attack_span(Them, s))
76             || (pos.attacks_from&lt;PAWN&gt;(s, Us) &amp; theirPawns))
77             backward = false;
78         else
79         {
80             b = pawn_attack_span(Us, s) &amp; (ourPawns | theirPawns);
81             b = pawn_attack_span(Us, s) &amp; rank_bb(backmost_sq(Us, b));
82             backward = (b | shift_bb&lt;Up&gt;(b)) &amp; theirPawns;
83         }
84         assert(opposed | passed | (pawn_attack_span(Us, s) &amp; theirPawns));
85         candidate =   !(opposed | passed | backward | isolated)
86                    &amp;&amp; (b = pawn_attack_span(Them, s + pawn_push(Us)) &amp; ourPawns) != 0
87                    &amp;&amp;  popcount&lt;Max15&gt;(b) &gt;= popcount&lt;Max15&gt;(pawn_attack_span(Us, s) &amp; theirPawns);
88         if (passed &amp;&amp; !doubled)
89             e-&gt;passedPawns[Us] |= s;
90         if (isolated)
91             value -= Isolated[opposed][f];
92         if (unsupported &amp;&amp; !isolated)
93             value -= UnsupportedPawnPenalty;
94         if (doubled)
95             value -= Doubled[f] / rank_distance(s, lsb(doubled));
96         if (backward)
97             value -= Backward[opposed][f];
98         if (connected)
99             value += Connected[f][relative_rank(Us, s)];
100         if (candidate)
101         {
102             value += CandidatePassed[relative_rank(Us, s)];
103             if (!doubled)
104                 e-&gt;candidatePawns[Us] |= s;
105         }
106     }
107     if (pos.count&lt;PAWN&gt;(Us) &gt; 1)
108     {
109         b = e-&gt;semiopenFiles[Us] ^ 0xFF;
110         value += PawnsFileSpan * int(msb(b) - lsb(b));
111     }
112     return value;
113   }
114 } 
115 namespace Pawns {
116 void init() {
117   const int bonusesByFile[8] = { 1, 3, 3, 4, 4, 3, 3, 1 };
118   int bonus;
119   for (Rank r = RANK_1; r &lt; RANK_8; ++r)
120       for (File f = FILE_A; f &lt;= FILE_H; ++f)
121       {
122           bonus = r * (r-1) * (r-2) + bonusesByFile[f] * (r/2 + 1);
123           Connected[f][r] = make_score(bonus, bonus);
124       }
125 }
126 Entry* probe(const Position&amp; pos, Table&amp; entries) {
127   Key key = pos.pawn_key();
128   Entry* e = entries[key];
129   if (e-&gt;key == key)
130       return e;
131   e-&gt;key = key;
132   e-&gt;value = evaluate&lt;WHITE&gt;(pos, e) - evaluate&lt;BLACK&gt;(pos, e);
133   return e;
134 }
135 template&lt;Color Us&gt;
136 Value Entry::shelter_storm(const Position&amp; pos, Square ksq) {
137   const Color Them = (Us == WHITE ? BLACK : WHITE);
138   static const Bitboard MiddleEdges = (FileABB | FileHBB) &amp; (Rank2BB | Rank3BB);
139   Value safety = MaxSafetyBonus;
140   Bitboard b = pos.pieces(PAWN) &amp; (in_front_bb(Us, rank_of(ksq)) | rank_bb(ksq));
141   Bitboard ourPawns = b &amp; pos.pieces(Us);
142   Bitboard theirPawns = b &amp; pos.pieces(Them);
143   Rank rkUs, rkThem;
144   File kf = std::max(FILE_B, std::min(FILE_G, file_of(ksq)));
145   for (File f = kf - File(1); f &lt;= kf + File(1); ++f)
146   {
147       b = ourPawns &amp; file_bb(f);
148       rkUs = b ? relative_rank(Us, backmost_sq(Us, b)) : RANK_1;
149       b  = theirPawns &amp; file_bb(f);
150       rkThem = b ? relative_rank(Us, frontmost_sq(Them, b)) : RANK_1;
151       if (   (MiddleEdges &amp; make_square(f, rkThem))
152           &amp;&amp; file_of(ksq) == f
153           &amp;&amp; relative_rank(Us, ksq) == rkThem - 1)
154           safety += 200;
155       else
156           safety -= ShelterWeakness[rkUs]
157                   + StormDanger[rkUs == RANK_1 ? 0 : rkThem == rkUs + 1 ? 2 : 1][rkThem];
158   }
159   return safety;
160 }
161 template&lt;Color Us&gt;
162 Score Entry::do_king_safety(const Position&amp; pos, Square ksq) {
163   kingSquares[Us] = ksq;
164   castlingRights[Us] = pos.can_castle(Us);
165   minKPdistance[Us] = 0;
166   Bitboard pawns = pos.pieces(Us, PAWN);
167   if (pawns)
168       while (!(DistanceRingsBB[ksq][minKPdistance[Us]++] &amp; pawns)) {}
169   if (relative_rank(Us, ksq) &gt; RANK_4)
170       return make_score(0, -16 * minKPdistance[Us]);
171   Value bonus = shelter_storm&lt;Us&gt;(pos, ksq);
172   if (pos.can_castle(MakeCastling&lt;Us, KING_SIDE&gt;::right))
173       bonus = std::max(bonus, shelter_storm&lt;Us&gt;(pos, relative_square(Us, SQ_G1)));
174   if (pos.can_castle(MakeCastling&lt;Us, QUEEN_SIDE&gt;::right))
175       bonus = std::max(bonus, shelter_storm&lt;Us&gt;(pos, relative_square(Us, SQ_C1)));
176   return make_score(bonus, -16 * minKPdistance[Us]);
177 }
178 template Score Entry::do_king_safety&lt;WHITE&gt;(const Position&amp; pos, Square ksq);
179 template Score Entry::do_king_safety&lt;BLACK&gt;(const Position&amp; pos, Square ksq);
} </PRE>
    </div>
</div>
<div class="modal" id="myModal" style="display:none;">
    <div class="modal-content"><span class="close">x</span>
        <p></p>
        <div class="row">
            <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div>
            <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div>
        </div>
        <div class="row">
            <div class="column" id="column1">Column 1</div>
            <div class="column" id="column2">Column 2</div>
        </div>
    </div>
</div>
<script>var modal = document.getElementById("myModal"), span = document.getElementsByClassName("close")[0];
span.onclick = function () {
    modal.style.display = "none"
};
window.onclick = function (a) {
    a.target == modal && (modal.style.display = "none")
};
function openModal(a) {
    console.log("the color is " + a);
    let b = getCodes(a);
    console.log(b);
    var c = document.getElementById("column1");
    c.innerText = b[0];
    var d = document.getElementById("column2");
    d.innerText = b[1];
    c.style.color = a;
    c.style.fontWeight = "bold";
    d.style.fontWeight = "bold";
    d.style.color = a;
    var e = document.getElementById("myModal");
    e.style.display = "block"
}
function getCodes(a) {
    for (var b = document.getElementsByTagName("font"), c = [], d = 0; d < b.length; d++) b[d].attributes.color.nodeValue === a && "-" !== b[d].innerText && c.push(b[d].innerText);
    return c
}</script>
<script>const params = window.location.search;
const urlParams = new URLSearchParams(params);
const searchText = urlParams.get('lines');
let lines = searchText.split(',');
for (let line of lines) {
    const elements = document.getElementsByTagName('td');
    for (let i = 0; i < elements.length; i++) {
        if (elements[i].innerText.includes(line)) {
            elements[i].style.background = 'green';
            break;
        }
    }
}</script>
</body>
</html>
