
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bix.cpp</h3>
            <pre><code>1  #include "StdAfx.h"
2  #include "bix.h"
3  #include "book.h"
4  TStr TBixCtx::GetStr() const {
5    TChA ChA;
6    ChA+=TInt::GetStr(SecId);
7    ChA+='['; ChA+=FSet.GetStr(); ChA+=']';
8    return ChA;
9  }
10  int TBixCtx::TitleFlagN=0;
11  int TBixCtx::ContinentFlagN=1;
12  int TBixCtx::AreaFlagN=2;
13  PTqlCtxSet TBixCtxSet::GetAndCtxSet(const PTqlCtxSet& CtxSet){
14    TBixCtxSet* DstCtxSet=new TBixCtxSet();
15    TBixCtxV& V1=BixCtxV;
16    TBixCtxV& V2=((TBixCtxSet*)CtxSet())->BixCtxV;
17    TBixCtxV& DstV=DstCtxSet->BixCtxV;
18    int N1=0; int N2=0;
19    while ((N1<V1.Len())&&(N2<V2.Len())){
20      TBixCtx& Val1=V1[N1];
21      while ((N2<V2.Len())&&(Val1>V2[N2])){
22        N2++;}
23      if ((N2<V2.Len())&&(Val1==V2[N2])){
24        TBixCtx Val(Val1); Val.Merge(V2[N2]);
25        DstV.Add(Val); N2++;
26      }
27      N1++;
28    }
29    return PTqlCtxSet(DstCtxSet);
30  }
31  PTqlCtxSet TBixCtxSet::GetOrCtxSet(const PTqlCtxSet& CtxSet){
32    TBixCtxSet* DstCtxSet=new TBixCtxSet();
33    TBixCtxV& V1=BixCtxV;
34    TBixCtxV& V2=((TBixCtxSet*)CtxSet())->BixCtxV;
35    TBixCtxV& DstV=DstCtxSet->BixCtxV;
36    int N1=0; int N2=0;
37    while ((N1<V1.Len())&&(N2<V2.Len())){
38      TBixCtx& Val1=V1[N1];
39      TBixCtx& Val2=V2[N2];
40      if (Val1<Val2){DstV.Add(Val1); N1++;}
41      else if (Val1>Val2){DstV.Add(Val2); N2++;}
42      else {TBixCtx Val(Val1); Val.Merge(Val2); DstV.Add(Val); N1++; N2++;}
43    }
44    for (int RestN1=N1; RestN1<V1.Len(); RestN1++){DstV.Add(V1[RestN1]);}
45    for (int RestN2=N2; RestN2<V2.Len(); RestN2++){DstV.Add(V2[RestN2]);}
46    return PTqlCtxSet(DstCtxSet);
47  }
48  PTqlCtxSet TBixCtxSet::GetTagCtxSet(const TStr& TagNm){
49    int FlagN=-1;
50    if (TagNm=="title"){FlagN=TBixCtx::TitleFlagN;}
51    if (TagNm=="continent"){FlagN=TBixCtx::ContinentFlagN;}
52    if (TagNm=="area"){FlagN=TBixCtx::AreaFlagN;}
53    if (FlagN==-1){
54      return this;
55    } else {
56      TBixCtxSet* DstCtxSet=new TBixCtxSet();
57      TBixCtxV& V=BixCtxV;
58      TBixCtxV& DstV=DstCtxSet->BixCtxV;
59      for (int N=0; N<V.Len(); N++){
60        if (V[N].IsFlag(FlagN)){
61          DstV.Add(V[N]);}
62      }
63      return PTqlCtxSet(DstCtxSet);
64    }
65  }
66  PTqlCtxSet TBixCtxSet::GetTitleCtxSet(){
67    TBixCtxSet* DstCtxSet=new TBixCtxSet();
68    TBixCtxV& V=BixCtxV;
69    TBixCtxV& DstV=DstCtxSet->BixCtxV;
70    for (int N=0; N<V.Len(); N++){
71      if (V[N].IsFlag(TBixCtx::TitleFlagN)){
72        DstV.Add(V[N]);}
73    }
74    return PTqlCtxSet(DstCtxSet);
75  }
76  TStr TBixCtxSet::GetStr() const {
77    TChA ChA;
78    for (int CtxN=0; CtxN<BixCtxV.Len(); CtxN++){
79      if (CtxN>0){ChA+=' ';}
80      ChA+=BixCtxV[CtxN].GetStr();
81    }
82    return ChA;
83  }
84  void TBix::MergeBixCtx(const TStr& WordStr, const TBixCtx& BixCtx){
85    int WordToCtxVP;
86    if (WordToCtxVH.IsKey(WordStr, WordToCtxVP)){
87      TBixCtxV& BixCtxV=WordToCtxVH[WordToCtxVP];
88      int BixCtxN;
89      if (BixCtxV.IsIn(BixCtx, BixCtxN)){
90        BixCtxV[BixCtxN].Merge(BixCtx); 
91      } else {
92        WordToCtxVH.AddDat(WordStr).AddMerged(BixCtx);
93      }
94    } else {
95      WordToCtxVH.AddDat(WordStr).AddMerged(BixCtx);
96    }
97  }
98  PTqlCtxSet TBix::GetEmptyCtxSet() const {
99    return PTqlCtxSet(new TBixCtxSet());
100  }
101  PTqlCtxSet TBix::GetCtxSet(
102   const TStr& WordStr, const bool& IsWc, const int& MxWcWords) const {
103    IAssert(Access==faRdOnly);
104    TStr NrWordStr=ChDef->GetUcStr(WordStr);
105    PTqlCtxSet CtxSet;
106    if (IsWc){
107      int FirstWordN; int WordN=WordV.SearchBin(NrWordStr, FirstWordN);
108      if (WordN==-1){
109        CtxSet=PTqlCtxSet(new TBixCtxSet()); WordN=FirstWordN;
110      } else {
111        CtxSet=PTqlCtxSet(new TBixCtxSet(WordToCtxVH.GetDat(NrWordStr))); WordN++;
112      }
113      int WcWords=0;
114      while ((WordN<WordV.Len())&&(WordV[WordN].IsPrefix(NrWordStr))&&
115       (WcWords<MxWcWords)){
116        TStr PfxNrWordStr=WordV[WordN];
117        PTqlCtxSet SubCtxSet=
118         PTqlCtxSet(new TBixCtxSet(WordToCtxVH.GetDat(PfxNrWordStr)));
119        CtxSet=CtxSet->GetOrCtxSet(SubCtxSet);
120        WordN++; WcWords++;
121      }
122    } else {
123      int WordP;
124      if (WordToCtxVH.IsKey(NrWordStr, WordP)){
125        CtxSet=PTqlCtxSet(new TBixCtxSet(WordToCtxVH[WordP]));
126      } else {
127        CtxSet=PTqlCtxSet(new TBixCtxSet());
128      }
129    }
130    return CtxSet;
131  }
132  PTqlCtxSet TBix::GetCtxSet(
133   const TStr& TagNm, const TRelOp& RelOp, const TStr& ArgValStr,
134   const int& MxWcWords) const {
135    IAssert(Access==faRdOnly);
136    int ArgVal;
137    if (ArgValStr.IsInt(ArgVal)){
138      TBixCtxV BixCtxV;
139      for (int KeyN=0; KeyN<SecIdKeyNmValTrV.Len(); KeyN++){
140        if (SecIdKeyNmValTrV[KeyN].Val2==TagNm){
141          int KeyVal=SecIdKeyNmValTrV[KeyN].Val3;
142          if (Cmp(RelOp, KeyVal, ArgVal)){
143            int SecId=SecIdKeyNmValTrV[KeyN].Val1;
144            BixCtxV.Add(TBixCtx(SecId));
145          }
146        }
147        if ((MxWcWords!=-1)&&(BixCtxV.Len()>MxWcWords)){break;}
148      }
149      BixCtxV.Merge();
150      PTqlCtxSet CtxSet=PTqlCtxSet(new TBixCtxSet(BixCtxV));
151      return CtxSet;
152    } else {
153      return PTqlCtxSet(new TBixCtxSet());
154    }
155  }
156  void TBix::AddSec(const int& SecId, const TStr& SecStr, const bool& TitleP){
157    IAssert(Access==faCreate);
158    PSIn HtmlSIn=TStrIn::New(SecStr);
159    THtmlLx Lx(HtmlSIn, false);
160    bool InTitleTag=TitleP; bool InContinentTag=false; bool InAreaTag=false;
161    while (Lx.GetSym()!=hsyEof){
162      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)){
163        TStr WordStr(Lx.UcChA);
164        if (!SwSet->IsIn(WordStr)){
165          TBixCtx BixCtx(SecId);
166          if (InTitleTag){BixCtx.SetFlag(TBixCtx::TitleFlagN);}
167          if (InContinentTag){BixCtx.SetFlag(TBixCtx::ContinentFlagN);}
168          if (InAreaTag){BixCtx.SetFlag(TBixCtx::AreaFlagN);}
169          MergeBixCtx(WordStr, BixCtx);
170        }
171      } else
172      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
173        TStr TagNm=Lx.UcChA;
174        if (TagNm==THtmlTok::TitleTagNm){InTitleTag=(Lx.Sym==hsyBTag);}
175        else if (TagNm==ContinentTagNm){InContinentTag=(Lx.Sym==hsyBTag);}
176        else if (TagNm==AreaTagNm){InAreaTag=(Lx.Sym==hsyBTag);}
177      }
178    }
179  }
180  PBixRes TBix::Search(const TStr& QueryStr){
181    PTqlExp TqlExp=TTqlExp::New(QueryStr);
182    PBixRes BixRes;
183    if (TqlExp->IsOk()){
184      PTqlCtxSet CtxSet=TqlExp->Eval(*this);
185      BixRes=PBixRes(new TBixRes(this, QueryStr, CtxSet));
186    } else {
187      BixRes=PBixRes(new TBixRes(TqlExp->GetErrMsg()));
188    }
189    return BixRes;
190  }
191  TBixRes::TBixRes(
192   const PBix& _Bix, const TStr& _QueryStr, const PTqlCtxSet& _CtxSet):
193    Ok(true), MsgStr(TStr::OkStr),
194    Bix(_Bix), QueryStr(_QueryStr), CtxSet(_CtxSet){
195  }
196  void TBixRes::GetHitInfo(
197   const PBook& Book,
198   const int& HitN, const int& MxTitleLen, const int& MxCtxLen,
199   TStr& SecIdStr, TStr& TitleStr, TStr& SecStr, TStr& CtxStr) const {
200    int SecId=CtxSet->GetCtxSecId(HitN);
201    Book->GetSecInfo(SecId, SecIdStr, TitleStr, SecStr);
202    PSIn HtmlSIn=TStrIn::New(SecStr);
203    THtmlLx Lx(HtmlSIn);
<span onclick='openModal()' class='match'>204    TChA TitleChA; bool IsTitleComplete=true;
205    TChA CtxChA;
206    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
207    bool InTitleTag=false;
208    while (((MxCtxLen==-1)||(CtxChA.Len()<MxCtxLen))&&
</span>209     (Lx.GetSym()!=hsyEof)){
210      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)||(Lx.Sym==hsySSym)){
211        PrevLxSym=CurLxSym;
212        CurLxSym=THtmlDoc::GetLxSym(Lx.Sym, Lx.UcChA);
213        if (InTitleTag){
214          if ((MxTitleLen==-1)||(TitleChA.Len()<MxTitleLen)){
215            if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){TitleChA+=' ';}
216            TitleChA+=Lx.ChA;
217          } else {
218            IsTitleComplete=false;
219          }
220        } else {
221          if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){CtxChA+=' ';}
222          CtxChA+=Lx.ChA;
223        }
224      } else
225      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
226        if (Lx.UcChA==THtmlTok::TitleTagNm){
227          InTitleTag=(Lx.Sym==hsyBTag); PrevLxSym=syUndef;
228        } else
229        if (Lx.UcChA==THtmlTok::CardTagNm){
230          TitleChA=Lx.GetArg(THtmlTok::TitleArgNm);
231        }
232      }
233    }
234    if (TitleChA.Empty()){TitleChA=TitleStr;}
235    else {if (!IsTitleComplete){TitleChA+=" ...";}}
236    TitleStr=THtmlLx::GetEscapedStr(TitleChA);
237    if (Lx.Sym!=hsyEof){CtxChA+=" ...";}
238    CtxStr=THtmlLx::GetEscapedStr(CtxChA);
239    SecStr=THtmlLx::GetEscapedStr(SecStr);
240  }
241  void TBixRes::GetHitSetMnMxHitN(
242   const int& HitSetN, const int& HitSetSecs, int& MnHitN, int& MxHitN) const {
243    IAssert(IsOk());
244    IAssert((HitSetN>0)&&(HitSetSecs>0));
245    MnHitN=(HitSetN-1)*HitSetSecs;
246    MxHitN=MnHitN+HitSetSecs-1;
247    MxHitN=TInt::GetMn(MxHitN, GetHits()-1);
248  }
249  void TBixRes::GetHitSet(
250   const int& HitSetN, const int& HitSetSecs, const int& TocHitSets,
251   const TStr& HitSetUrlFldNm, const PUrlSearchEnv& UrlSearchEnv,
252   TStr& PrevTocUrlStr, TStrPrV& TocNmUrlStrPrV, TStr& NextTocUrlStr) const {
253    PrevTocUrlStr.Clr(); TocNmUrlStrPrV.Clr(); NextTocUrlStr.Clr();
254    IAssert(IsOk());
255    IAssert((HitSetN>0)&&(HitSetSecs>0)&&(TocHitSets>0));
256    if (GetHits()==0){return;}
257    int MnHitSetN=1;
258    int MxHitSetN=(GetHits()-1)/HitSetSecs+1;
259    if ((HitSetN<MnHitSetN)||(MnHitSetN>MxHitSetN)){return;}
260    int MnTocHitSetN=((HitSetN-1)/TocHitSets)*TocHitSets+1;
261    int MxTocHitSetN=MnTocHitSetN+TocHitSets-1;
262    MxTocHitSetN=TInt::GetMn(MxTocHitSetN, MxHitSetN);
263    PUrlSearchEnv HitSetUSE=TUrlSearchEnv::MkClone(UrlSearchEnv);
264    if (HitSetN!=MnHitSetN){
265      HitSetUSE->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN-1));
266      PrevTocUrlStr=TStr("/")+HitSetUSE->GetStr();
267    }
268    for (int TocHitSetN=MnTocHitSetN; TocHitSetN<=MxTocHitSetN; TocHitSetN++){
269      TStr Nm=TInt::GetStr(TocHitSetN);
270      TStr UrlStr;
271      if (TocHitSetN!=HitSetN){
272        HitSetUSE->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(TocHitSetN));
273        UrlStr=TStr("/")+HitSetUSE->GetStr();
274      }
275      TocNmUrlStrPrV.Add(TStrPr(Nm, UrlStr));
276    }
277    if (HitSetN!=MxHitSetN){
278      HitSetUSE->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN+1));
279      NextTocUrlStr=TStr("/")+HitSetUSE->GetStr();
280    }
281  }
282  TStr TBix::ContinentTagNm="<CONTINENT>";
283  TStr TBix::AreaTagNm="<AREA>";
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-txtbs.cpp</h3>
            <pre><code>1  TTxtBsRes::TTxtBsRes(
2   const PTxtBs& _TxtBs, const TStr& _WixExpStr, const TBlobPtV& _DocIdV):
3    Ok(true), ErrMsg("Ok"),
4    TxtBs(_TxtBs), WixExpStr(_WixExpStr), DocIdV(){
5    DocIdV.Gen(_DocIdV.Len());
6    for (int DocIdN=0; DocIdN<_DocIdV.Len(); DocIdN++){
7      DocIdV[DocIdN]=_DocIdV[DocIdN];}
8    DocIdV.Sort(false);
9  }
10  void TTxtBsRes::GetDocInfo(
11   const int& DocIdN, const int& MxDocTitleLen, const int& MxDocCtxLen,
12   TStr& DocNm, TStr& DocTitleStr, TStr& DocStr, TStr& DocCtxStr) const {
13    TMem DocMem; TxtBs->GetDocNmMem(DocIdV[DocIdN], DocNm, DocMem);
14    DocStr = TStr(DocMem);
15    PSIn HtmlSIn=TStrIn::New(DocStr);
16    THtmlLx Lx(HtmlSIn);
<span onclick='openModal()' class='match'>17    TChA DocTitleChA; bool IsDocTitleComplete=true;
18    TChA DocCtxChA;
19    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
20    bool InTitleTag=false;
21    while ((DocCtxChA.Len()<MxDocCtxLen)&&(Lx.GetSym()!=hsyEof)){
</span>22      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)||(Lx.Sym==hsySSym)){
23        PrevLxSym=CurLxSym;
24        CurLxSym=THtmlDoc::GetLxSym(Lx.Sym, Lx.UcChA);
25        if (InTitleTag){
26          if (DocTitleChA.Len()<MxDocTitleLen){
27            if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){DocTitleChA+=' ';}
28            DocTitleChA+=Lx.ChA;
29          } else {
30            IsDocTitleComplete=false;
31          }
32        } else {
33          if (TLxSymStr::IsSep(PrevLxSym, CurLxSym)){DocCtxChA+=' ';}
34          DocCtxChA+=Lx.ChA;
35        }
36      } else
37      if ((Lx.Sym==hsyBTag)||(Lx.Sym==hsyETag)){
38        if (Lx.UcChA==THtmlTok::TitleTagNm){
39          InTitleTag=(Lx.Sym==hsyBTag); PrevLxSym=syUndef;
40        } else
41        if (Lx.UcChA==THtmlTok::CardTagNm){
42          DocTitleChA=Lx.GetArg(THtmlTok::TitleArgNm);
43        }
44      }
45    }
46    if (!IsDocTitleComplete){DocTitleChA+="...";}
47    if (Lx.Sym!=hsyEof){DocCtxChA+="...";}
48    DocTitleStr=THtmlLx::GetEscapedStr(DocTitleChA);
49    DocCtxStr=THtmlLx::GetEscapedStr(DocCtxChA);
50  }
51  void TTxtBsRes::GetHitSetMnMxDocN(
52   const int& HitSetN, const int& HitSetDocs, int& MnDocN, int& MxDocN) const {
53    IAssert(IsOk());
54    IAssert((HitSetN>0)&&(HitSetDocs>0));
55    MnDocN=(HitSetN-1)*HitSetDocs;
56    MxDocN=MnDocN+HitSetDocs-1;
57    MxDocN=TInt::GetMn(MxDocN, GetDocs()-1);
58  }
59  void TTxtBsRes::GetHitSet(
60   const int& HitSetN, const int& HitSetDocs, const int& TocHitSets,
61   const TStr& HitSetUrlFldNm, const PUrlEnv& UrlEnv,
62   TStr& PrevTocUrlStr, TStrPrV& TocNmUrlStrPrV, TStr& NextTocUrlStr) const {
63    PrevTocUrlStr.Clr(); TocNmUrlStrPrV.Clr(); NextTocUrlStr.Clr();
64    IAssert(IsOk());
65    IAssert((HitSetN>0)&&(HitSetDocs>0)&&(TocHitSets>0));
66    if (GetDocs()==0){return;}
67    int MnHitSetN=1;
68    int MxHitSetN=(GetDocs()-1)/HitSetDocs+1;
69    if ((HitSetN<MnHitSetN)||(MnHitSetN>MxHitSetN)){return;}
70    int MnTocHitSetN=((HitSetN-1)/TocHitSets)*TocHitSets+1;
71    int MxTocHitSetN=MnTocHitSetN+TocHitSets-1;
72    MxTocHitSetN=TInt::GetMn(MxTocHitSetN, MxHitSetN);
73    PUrlEnv HitSetUrlEnv=TUrlEnv::MkClone(UrlEnv);
74    if (HitSetN!=MnHitSetN){
75      HitSetUrlEnv->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN-1));
76      PrevTocUrlStr=TStr("/")+HitSetUrlEnv->GetFullUrlStr();
77    }
78    for (int TocHitSetN=MnTocHitSetN; TocHitSetN<=MxTocHitSetN; TocHitSetN++){
79      TStr Nm=TInt::GetStr(TocHitSetN);
80      TStr UrlStr;
81      if (TocHitSetN!=HitSetN){
82        HitSetUrlEnv->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(TocHitSetN));
83        UrlStr=TStr("/")+HitSetUrlEnv->GetFullUrlStr();
84      }
85      TocNmUrlStrPrV.Add(TStrPr(Nm, UrlStr));
86    }
87    if (HitSetN!=MxHitSetN){
88      HitSetUrlEnv->AddKeyVal(HitSetUrlFldNm, TInt::GetStr(HitSetN+1));
89      NextTocUrlStr=TStr("/")+HitSetUrlEnv->GetFullUrlStr();
90    }
91  }
92  const TStr TTxtBs::TxtBsFExt=".tbs";
93  const TStr TTxtBs::TxtBsDocNmFExt=".tdn";
94  const TStr TTxtBs::TxtBsDocDatFExt=".tdd";
95  void TTxtBs::GenTxtBsMainFile(const TStr& Nm, const TStr& FPath){
96    TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
97    GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
98    PSOut SOut=TFOut::New(TxtBsFNm);
99    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
100    Lx.PutUQStr("Text Base Main File"); Lx.PutLn();
101    Lx.PutVarStr("Original Name", Nm, true, false);
102    Lx.PutVarStr("Original Path", FPath, true, false);
103    Lx.PutVarStr("Text-Base-Main", TxtBsFNm, true, false);
104    Lx.PutVarStr("Document-Names", TxtBsDocNmFNm, true, false);
105    Lx.PutVarStr("Document-Contents", TxtBsDocDatFNm, true, false);
106    Lx.PutVarStr("Creation Time", TSecTm::GetCurTm().GetStr(), true, false);
107  }
108  void TTxtBs::AddToTxtBsMainFile(const TStr& TxtBsFNm, const TStr& MsgStr){
109    PSOut SOut=TFOut::New(TxtBsFNm, true);
110    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
111    Lx.PutUQStr(MsgStr);
112    Lx.PutUQStr(TStr(" [")+TSecTm::GetCurTm().GetStr()+TStr("]"));
113    Lx.PutLn();
114  }
115  TTxtBs::TTxtBs(const TStr& Nm, const TStr& FPath,
116   const TFAccess& _Access, const TFAccess& _WixAccess, 
117   const int& CacheSize):
118    NrNm(TStr::GetNrFMid(Nm)), NrFPath(TStr::GetNrFPath(FPath)),
119    TxtBsFNm(), Access(_Access), WixAccess(_WixAccess),
120    Wix(), DocNmH(), DocBBs(){
121    TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
122    GetFNms(NrNm, NrFPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
123    int DocNmHPorts;
124    if (Access==faCreate){
125      DocNmHPorts=1000000;
126      GenTxtBsMainFile(NrNm, NrFPath);
127    } else {
128      IAssertR(Exists(NrNm, NrFPath), "[" + NrNm + ", " + NrFPath + "]");
129      DocNmHPorts=-1;
130      TStr OpenMsgStr=TStr("Open (")+TFRnd::GetStrFromFAccess(Access)+")";
131      AddToTxtBsMainFile(TxtBsFNm, OpenMsgStr);
132    }
133    if (WixAccess==faUndef){WixAccess=Access;}
134    Wix=PWix(new TWix(Nm, FPath, WixAccess, CacheSize));
135    DocNmH=PDocNmH(new TDocNmH(TxtBsDocNmFNm, Access, DocNmHPorts, 100000000));
136    DocBBs=PBlobBs(new TMBlobBs(TxtBsDocDatFNm, Access));
137  }
138  TTxtBs::~TTxtBs(){
139    AddToTxtBsMainFile(TxtBsFNm, "Close");
140  }
141  TStr TTxtBs::GetMemUsedStr(){
142    return TStr()+
143     "Wix:["+Wix->GetMemUsedStr()+"]"+
144     " DocNmH:"+TInt::GetMegaStr((int)DocNmH->GetMemUsed());
145  }
146  TBlobPt TTxtBs::AddDocMem(
147   const TStr& UrlStr, const TMem& DocMem, const bool& IndexP){
148    TMOut NmDocSOut(UrlStr.Len()+DocMem.Len()+100);
149    UrlStr.Save(NmDocSOut); DocMem.Save(NmDocSOut);
150    PSIn NmDocSIn=NmDocSOut.GetSIn();
151    TBlobPt DocId=DocBBs->PutBlob(NmDocSIn);
152    TTxtBsDocFDat FDat(TBlobPt(), TSecTm::GetCurTm(), DocMem.Len(), DocId);
153    DocNmH->AddFDat(UrlStr, FDat);
154    if (IndexP){
155      PSIn HtmlDocSIn=TStrIn::New(DocMem.GetAsStr());
156      Wix->AddHtmlDoc(DocId, HtmlDocSIn);
157    }
158    return DocId;
159  }
160  TBlobPt TTxtBs::AddHtmlDoc(
161   const TStr& UrlStr, const PSIn& SIn, const bool& IndexP){
162    TMem DocMem; TMem::LoadMem(SIn, DocMem);
163    return AddDocMem(UrlStr, DocMem, IndexP);
164  }
165  void TTxtBs::GetDocNmStr(const TBlobPt& BlobPt, TStr& DocNm, TStr& DocStr){
166    PSIn NmDocSIn=DocBBs->GetBlob(BlobPt); 
167    DocNm=TStr(*NmDocSIn); 
168    TMem DocMem=TMem(*NmDocSIn); DocStr=TStr(DocMem); 
169  }
170  void TTxtBs::GetDocNmMem(const TBlobPt& BlobPt, TStr& DocNm, TMem& DocMem){
171    PSIn NmDocSIn=DocBBs->GetBlob(BlobPt); 
172    DocNm=TStr(*NmDocSIn); 
173    DocMem=TMem(*NmDocSIn); 
174  }
175  TStr TTxtBs::GetDocNm(const TBlobPt& BlobPt){
176    PSIn NmDocSIn=DocBBs->GetBlob(BlobPt); 
177    return TStr(*NmDocSIn); 
178  }
179  TStr TTxtBs::GetDocStr(const TStr& DocNm){
180    TTxtBsDocFDat DocFDat;
181    DocNmH->GetFDat(DocNm, DocFDat);
182    TBlobPt DocBPt=DocFDat.DocId;
183    TStr _DocNm; TMem DocMem; GetDocNmMem(DocFDat.DocId, _DocNm, DocMem);
184    return TStr(DocMem);
185  }
186  void TTxtBs::GetDocMem(const TStr& DocNm, TMem& DocMem){
187    TTxtBsDocFDat DocFDat;
188    DocNmH->GetFDat(DocNm, DocFDat);
189    TBlobPt DocBPt=DocFDat.DocId;
190    TStr _DocNm; GetDocNmMem(DocFDat.DocId, _DocNm, DocMem);
191  }
192  TBlobPt TTxtBs::FFirstDocId(){
193    return DocNmH->FFirstKeyId();
194  }
195  bool TTxtBs::FNextDocId(TBlobPt& TrvBlobPt, TBlobPt& DocId){
196    TBlobPt KeyId;
197    if (DocNmH->FNextKeyId(TrvBlobPt, KeyId)){
198      TStr DocNm; TTxtBsDocFDat DocFDat;
199      DocNmH->GetKeyFDat(KeyId, DocNm, DocFDat);
200      DocId=DocFDat.DocId;
201      return true;
202    } else {
203      return false;
204    }
205  }
206  PTxtBsRes TTxtBs::Search(const TStr& WixExpStr){
207    PWixExp WixExp=PWixExp(new TWixExp(WixExpStr));
208    PTxtBsRes TxtBsRes;
209    if (WixExp->IsOk()){
210      PWixExpDocIdSet DocIdSet=WixExp->Eval(Wix);
211      TxtBsRes=PTxtBsRes(new TTxtBsRes(this, WixExpStr, DocIdSet->GetDocIdV()));
212    } else {
213      TxtBsRes=PTxtBsRes(new TTxtBsRes(WixExp->GetErrMsg()));
214    }
215    return TxtBsRes;
216  }
217  void TTxtBs::GenIndex(const TStr& Nm, const TStr& FPath, const bool& MemStatP){
218    PTxtBs TxtBs=TTxtBs::New(Nm, FPath, faRdOnly, faCreate);
219    TSecTm StartTm=TSecTm::GetCurTm();
220    TBlobPt TrvBlobPt=TxtBs->FFirstDocId(); 
221    TBlobPt DocId; int DocN=0; TStr DocNm; TMem DocMem;
222    while (TxtBs->FNextDocId(TrvBlobPt, DocId)){
223      TxtBs->GetDocNmMem(DocId, DocNm, DocMem);
224      PSIn DocSIn=TMemIn::New(DocMem);
225      TxtBs->Wix->AddHtmlDoc(DocId, DocSIn);
226      DocN++; 
227      if (DocN%100==0){
228        int SecsSf=TSecTm::GetDSecs(StartTm, TSecTm::GetCurTm());
229        if (MemStatP){
230          int64 MemUsed=TxtBs->GetMemUsed();
231          printf("%d: MemUsed:%s [%s] / %d secs\n", DocN,
232           TUInt64::GetMegaStr(MemUsed).CStr(), TxtBs->GetMemUsedStr().CStr(),
233           SecsSf);
234        } else {
235          printf("%d docs / %d secs\r", DocN, SecsSf);
236        }
237      }
238    }
239  }
240  void TTxtBs::SaveTxt(const PSOut& SOut){
241    {TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens);
242    Lx.PutUQStr("---DocNmH---------------------"); Lx.PutLn();
243    TBlobPt DocNmP=DocNmH->FFirstKeyId(); TBlobPt NmId;
244    while (DocNmH->FNextKeyId(DocNmP, NmId)){
245      TStr DocNm; TTxtBsDocFDat FDat;
246      DocNmH->GetKeyFDat(NmId, DocNm, FDat);
247      Lx.PutVarStr("DocNm", DocNm, false);
248      Lx.PutVarStr("MainNmId", FDat.MainNmId.GetStr(), false);
249      Lx.PutVarStr("Time", FDat.Tm.GetStr(), false);
250      Lx.PutVarInt("Len", FDat.Len, false);
251      Lx.PutVarStr("DocId", FDat.DocId.GetStr(), false);
252      Lx.PutLn();
253    }
254    Lx.PutUQStr("------------------------------"); Lx.PutLn();}
255    Wix->SaveTxt(SOut);
256  }
257  void TTxtBs::GetFNms(
258   const TStr& Nm, const TStr& FPath,
259   TStr& TxtBsFNm, TStr& TxtBsDocNmFNm, TStr& TxtBsDocDatFNm){
260    TStr NrFPath=TStr::GetNrFPath(FPath);
261    TStr NrNm=TStr::GetNrFMid(Nm);
262    TxtBsFNm=NrFPath+NrNm+TxtBsFExt;
263    TxtBsDocNmFNm=NrFPath+NrNm+TxtBsDocNmFExt;
264    TxtBsDocDatFNm=NrFPath+NrNm+TxtBsDocDatFExt;
265  }
266  bool TTxtBs::Exists(const TStr& Nm, const TStr& FPath){
267    TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
268    GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
269    return
270     TFile::Exists(TxtBsFNm)&&
271     TFile::Exists(TxtBsDocNmFNm)&&
272     TMBlobBs::Exists(TxtBsDocDatFNm)&&
273     TWix::Exists(Nm, FPath);
274  }
275  void TTxtBs::Del(const TStr& Nm, const TStr& FPath){
276    if (Exists(Nm, FPath)){
277      TStr TxtBsFNm; TStr TxtBsDocNmFNm; TStr TxtBsDocDatFNm;
278      GetFNms(Nm, FPath, TxtBsFNm, TxtBsDocNmFNm, TxtBsDocDatFNm);
279      TFile::Del(TxtBsFNm);
280      TFile::Del(TxtBsDocNmFNm);
281      TFile::Del(TxtBsDocDatFNm);
282      TWix::Del(Nm, FPath);
283    }
284  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bix.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-txtbs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>204    TChA TitleChA; bool IsTitleComplete=true;
205    TChA CtxChA;
206    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
207    bool InTitleTag=false;
208    while (((MxCtxLen==-1)||(CtxChA.Len()<MxCtxLen))&&
</pre></code></div>
                <div class="column column_space"><pre><code>17    TChA DocTitleChA; bool IsDocTitleComplete=true;
18    TChA DocCtxChA;
19    TLxSym PrevLxSym=syUndef; TLxSym CurLxSym=syUndef;
20    bool InTitleTag=false;
21    while ((DocCtxChA.Len()<MxDocCtxLen)&&(Lx.GetSym()!=hsyEof)){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    