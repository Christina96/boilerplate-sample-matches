
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 91, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_convolution_layer.cpp</h3>
            <pre><code>1  #include &lt;vector&gt;
2  #include &quot;gtest/gtest.h&quot;
3  #include &quot;caffe/blob.hpp&quot;
4  #include &quot;caffe/common.hpp&quot;
5  #include &quot;caffe/filler.hpp&quot;
6  #include &quot;caffe/layers/conv_layer.hpp&quot;
7  #ifdef USE_CUDNN
8  #include &quot;caffe/layers/cudnn_conv_layer.hpp&quot;
9  #endif
10  #include &quot;caffe/test/test_caffe_main.hpp&quot;
11  #include &quot;caffe/test/test_gradient_check_util.hpp&quot;
12  namespace caffe {
13  template &lt;typename Dtype&gt;
14  void caffe_conv(const Blob&lt;Dtype&gt;* in, ConvolutionParameter* conv_param,
15      const vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt;&amp; weights,
16      Blob&lt;Dtype&gt;* out) {
17    const bool has_depth = (out-&gt;num_axes() == 5);
18    if (!has_depth) { CHECK_EQ(4, out-&gt;num_axes()); }
19    int kernel_h, kernel_w;
20    if (conv_param-&gt;has_kernel_h() || conv_param-&gt;has_kernel_w()) {
21      kernel_h = conv_param-&gt;kernel_h();
22      kernel_w = conv_param-&gt;kernel_w();
23    } else {
24      kernel_h = kernel_w = conv_param-&gt;kernel_size(0);
25    }
26    int pad_h, pad_w;
27    if (conv_param-&gt;has_pad_h() || conv_param-&gt;has_pad_w()) {
28      pad_h = conv_param-&gt;pad_h();
29      pad_w = conv_param-&gt;pad_w();
30    } else {
31      pad_h = pad_w = conv_param-&gt;pad_size() ? conv_param-&gt;pad(0) : 0;
32    }
33    int stride_h, stride_w;
34    if (conv_param-&gt;has_stride_h() || conv_param-&gt;has_stride_w()) {
35      stride_h = conv_param-&gt;stride_h();
36      stride_w = conv_param-&gt;stride_w();
37    } else {
38      stride_h = stride_w = conv_param-&gt;stride_size() ? conv_param-&gt;stride(0) : 1;
39    }
40    int dilation_h, dilation_w;
41    dilation_h = dilation_w = conv_param-&gt;dilation_size() ?
42                              conv_param-&gt;dilation(0) : 1;
43    int kernel_d, pad_d, stride_d, dilation_d;
44    if (has_depth) {
45      kernel_d = kernel_h;
46      stride_d = stride_h;
47      pad_d = pad_h;
48      dilation_d = dilation_h;
49    } else {
50      kernel_d = stride_d = dilation_d = 1;
51      pad_d = 0;
52    }
53    int groups = conv_param-&gt;group();
54    int o_g = out-&gt;shape(1) / groups;
55    int k_g = in-&gt;shape(1) / groups;
56    int o_head, k_head;
57    vector&lt;int&gt; weight_offset(4 + has_depth);
58    vector&lt;int&gt; in_offset(4 + has_depth);
59    vector&lt;int&gt; out_offset(4 + has_depth);
60    Dtype* out_data = out-&gt;mutable_cpu_data();
61    for (int n = 0; n &lt; out-&gt;shape(0); n++) {
62      for (int g = 0; g &lt; groups; g++) {
63        o_head = o_g * g;
64        k_head = k_g * g;
65        for (int o = 0; o &lt; o_g; o++) {
66          for (int k = 0; k &lt; k_g; k++) {
67            for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
68              for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
69                for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
70                  for (int r = 0; r &lt; kernel_d; r++) {
71                    for (int p = 0; p &lt; kernel_h; p++) {
72                      for (int q = 0; q &lt; kernel_w; q++) {
73                        int in_z = z * stride_d - pad_d + r * dilation_d;
74                        int in_y = y * stride_h - pad_h + p * dilation_h;
75                        int in_x = x * stride_w - pad_w + q * dilation_w;
76                        if (in_z &gt;= 0 &amp;&amp; in_z &lt; (has_depth ? in-&gt;shape(2) : 1)
77                            &amp;&amp; in_y &gt;= 0 &amp;&amp; in_y &lt; in-&gt;shape(2 + has_depth)
78                            &amp;&amp; in_x &gt;= 0 &amp;&amp; in_x &lt; in-&gt;shape(3 + has_depth)) {
79                          weight_offset[0] = o + o_head;
80                          weight_offset[1] = k;
81                          if (has_depth) { weight_offset[2] = r; }
82                          weight_offset[2 + has_depth] = p;
83                          weight_offset[3 + has_depth] = q;
84                          in_offset[0] = n;
85                          in_offset[1] = k + k_head;
86                          if (has_depth) { in_offset[2] = in_z; }
87                          in_offset[2 + has_depth] = in_y;
88                          in_offset[3 + has_depth] = in_x;
89                          out_offset[0] = n;
90                          out_offset[1] = o + o_head;
91                          if (has_depth) { out_offset[2] = z; }
92                          out_offset[2 + has_depth] = y;
93                          out_offset[3 + has_depth] = x;
94                          out_data[out-&gt;offset(out_offset)] +=
95                              in-&gt;data_at(in_offset)
96                              * weights[0]-&gt;data_at(weight_offset);
97                        }
98                      }
99                    }
100                  }
101                }
102              }
103            }
104          }
105        }
106      }
107    }
108    if (conv_param-&gt;bias_term()) {
109      const Dtype* bias_data = weights[1]-&gt;cpu_data();
110      for (int n = 0; n &lt; out-&gt;shape(0); n++) {
111        for (int o = 0; o &lt; out-&gt;shape(1); o++) {
112          for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
113            for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
114              for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
115                out_offset[0] = n;
116                out_offset[1] = o;
117                if (has_depth) { out_offset[2] = z; }
118                out_offset[2 + has_depth] = y;
119                out_offset[3 + has_depth] = x;
120                out_data[out-&gt;offset(out_offset)] += bias_data[o];
121              }
122            }
123          }
124        }
125      }
126    }
127    if (conv_param-&gt;relu()){
128      for (int n = 0; n &lt; out-&gt;shape(0); n++) {
129        for (int o = 0; o &lt; out-&gt;shape(1); o++) {
130          for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
131            for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
132              for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
133                out_offset[0] = n;
134                out_offset[1] = o;
135                if (has_depth) { out_offset[2] = z; }
136                out_offset[2 + has_depth] = y;
137                out_offset[3 + has_depth] = x;
138                if(out_data[out-&gt;offset(out_offset)] &lt; 0) out_data[out-&gt;offset(out_offset)] = 0;
139              }
140            }
141          }
142        }
143      }
144    }
145  }
146  template void caffe_conv(const Blob&lt;float&gt;* in,
147      ConvolutionParameter* conv_param,
148      const vector&lt;shared_ptr&lt;Blob&lt;float&gt; &gt; &gt;&amp; weights,
149      Blob&lt;float&gt;* out);
150  template void caffe_conv(const Blob&lt;double&gt;* in,
151      ConvolutionParameter* conv_param,
152      const vector&lt;shared_ptr&lt;Blob&lt;double&gt; &gt; &gt;&amp; weights,
153      Blob&lt;double&gt;* out);
154  template &lt;typename TypeParam&gt;
155  class ConvolutionLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
156    typedef typename TypeParam::Dtype Dtype;
157   protected:
158    ConvolutionLayerTest()
159        : blob_bottom_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
160          blob_bottom_2_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
161          blob_top_(new Blob&lt;Dtype&gt;()),
162          blob_top_2_(new Blob&lt;Dtype&gt;()) {}
163    virtual void SetUp() {
164      FillerParameter filler_param;
165      filler_param.set_value(1.);
166      GaussianFiller&lt;Dtype&gt; filler(filler_param);
167      filler.Fill(this-&gt;blob_bottom_);
168      filler.Fill(this-&gt;blob_bottom_2_);
169      blob_bottom_vec_.push_back(blob_bottom_);
170      blob_top_vec_.push_back(blob_top_);
171    }
172    virtual ~ConvolutionLayerTest() {
173      delete blob_bottom_;
174      delete blob_bottom_2_;
175      delete blob_top_;
176      delete blob_top_2_;
177    }
178    virtual Blob&lt;Dtype&gt;* MakeReferenceTop(Blob&lt;Dtype&gt;* top) {
179      this-&gt;ref_blob_top_.reset(new Blob&lt;Dtype&gt;());
180      this-&gt;ref_blob_top_-&gt;ReshapeLike(*top);
181      return this-&gt;ref_blob_top_.get();
182    }
183    Blob&lt;Dtype&gt;* const blob_bottom_;
184    Blob&lt;Dtype&gt;* const blob_bottom_2_;
185    Blob&lt;Dtype&gt;* const blob_top_;
186    Blob&lt;Dtype&gt;* const blob_top_2_;
187    shared_ptr&lt;Blob&lt;Dtype&gt; &gt; ref_blob_top_;
188    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
189    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
190  };
191  TYPED_TEST_CASE(ConvolutionLayerTest, TestDtypesAndDevices);
192  TYPED_TEST(ConvolutionLayerTest, TestSetup) {
193    typedef typename TypeParam::Dtype Dtype;
194    LayerParameter layer_param;
195    ConvolutionParameter* convolution_param =
196        layer_param.mutable_convolution_param();
197    convolution_param-&gt;add_kernel_size(3);
198    convolution_param-&gt;add_stride(2);
199    convolution_param-&gt;set_num_output(4);
200    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
201    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
202    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
203        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
204    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
205    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
206    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 4);
207    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
208    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
209    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
210    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 4);
211    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
212    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
213    convolution_param-&gt;set_num_output(3);
214    convolution_param-&gt;set_group(3);
215    layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
216    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
217    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
218    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 3);
219    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
220    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
221    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
222    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 3);
223    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
224    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
225  }
226  TYPED_TEST(ConvolutionLayerTest, TestSimpleConvolution) {
227    typedef typename TypeParam::Dtype Dtype;
228    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
229    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
230    LayerParameter layer_param;
231    ConvolutionParameter* convolution_param =
232        layer_param.mutable_convolution_param();
233    convolution_param-&gt;add_kernel_size(3);
234    convolution_param-&gt;add_stride(2);
235    convolution_param-&gt;set_num_output(4);
236    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
237    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
238    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
239    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
240        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
241    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
242    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
243    const Dtype* top_data;
244    const Dtype* ref_top_data;
245    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
246        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
247    top_data = this-&gt;blob_top_-&gt;cpu_data();
248    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
249    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
250      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
251    }
252    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
253        this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
254    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
255    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
256    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
257      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
258    }
259  }
260  TYPED_TEST(ConvolutionLayerTest, TestDilatedConvolution) {
261    typedef typename TypeParam::Dtype Dtype;
262    vector&lt;int&gt; bottom_shape;
263    bottom_shape.push_back(2);
264    bottom_shape.push_back(3);
265    bottom_shape.push_back(8);
266    bottom_shape.push_back(7);
267    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
268    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
269    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
270      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
271    }
272    LayerParameter layer_param;
273    ConvolutionParameter* convolution_param =
274        layer_param.mutable_convolution_param();
275    convolution_param-&gt;add_kernel_size(3);
276    convolution_param-&gt;add_dilation(2);
277    convolution_param-&gt;set_num_output(4);
278    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
279    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
280    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
281    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
282        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
283    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
284    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
285    const Dtype* top_data;
286    const Dtype* ref_top_data;
287    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
288               this-&gt;MakeReferenceTop(this-&gt;blob_top_));
289    top_data = this-&gt;blob_top_-&gt;cpu_data();
290    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
291    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
292      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
293    }
294    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
295               this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
296    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
297    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
298    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
299      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
300    }
301  }
302  TYPED_TEST(ConvolutionLayerTest, Test0DConvolution) {
303    typedef typename TypeParam::Dtype Dtype;
304    LayerParameter layer_param;
305    ConvolutionParameter* convolution_param =
306        layer_param.mutable_convolution_param();
307    const int kNumOutput = 3;
308    convolution_param-&gt;set_num_output(kNumOutput);
309    convolution_param-&gt;set_axis(3);
310    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
311    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
312    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
313        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
314    vector&lt;int&gt; top_shape = this-&gt;blob_bottom_-&gt;shape();
315    top_shape[3] = kNumOutput;
316    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
317    EXPECT_EQ(top_shape, this-&gt;blob_top_-&gt;shape());
318    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
319    vector&lt;int&gt; weight_offset(2);
320    const Blob&lt;Dtype&gt;* weight = layer-&gt;blobs()[0].get();
321    const Blob&lt;Dtype&gt;* bias = layer-&gt;blobs()[1].get();
322    const int num = this-&gt;blob_top_-&gt;count(3);
323    const int dim = this-&gt;blob_top_-&gt;shape(3);
324    const int bottom_dim = this-&gt;blob_bottom_-&gt;shape(3);
325    for (int n = 0; n &lt; num; ++n) {
326      for (int d = 0; d &lt; dim; ++d) {
<span onclick='openModal()' class='match'>327        weight_offset[0] = d;
328        Dtype value = bias-&gt;cpu_data()[d];
329        for (int bottom_d = 0; bottom_d &lt; bottom_dim; ++bottom_d) {
330          weight_offset[1] = bottom_d;
331          value += weight-&gt;data_at(weight_offset) *
332                   this-&gt;blob_bottom_-&gt;cpu_data()[n * bottom_dim + bottom_d];
333        }
334        EXPECT_NEAR(value, this-&gt;blob_top_-&gt;cpu_data()[n * dim + d], 1e-4);
335      }
336    }
337  }
338  TYPED_TEST(ConvolutionLayerTest, TestSimple3DConvolution) {
</span>339    typedef typename TypeParam::Dtype Dtype;
340    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
341    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
342    vector&lt;int&gt; bottom_shape(5);
343    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
344    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
345    bottom_shape[2] = 5;
346    bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
347    bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
348    FillerParameter filler_param;
349    GaussianFiller&lt;Dtype&gt; filler(filler_param);
350    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
351      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
352      filler.Fill(this-&gt;blob_bottom_vec_[i]);
353    }
354    LayerParameter layer_param;
355    ConvolutionParameter* convolution_param =
356        layer_param.mutable_convolution_param();
357    convolution_param-&gt;add_kernel_size(3);
358    convolution_param-&gt;add_stride(2);
359    convolution_param-&gt;set_num_output(4);
360    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
361    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
362    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
363        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
364    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
365    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
366    const Dtype* top_data;
367    const Dtype* ref_top_data;
368    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
369        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
370    top_data = this-&gt;blob_top_-&gt;cpu_data();
371    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
372    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
373      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
374    }
375    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
376        this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
377    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
378    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
379    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
380      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
381    }
382  }
383  TYPED_TEST(ConvolutionLayerTest, TestDilated3DConvolution) {
384    typedef typename TypeParam::Dtype Dtype;
385    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
386    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
387    vector&lt;int&gt; bottom_shape(5);
388    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
389    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
390    bottom_shape[2] = 6;
391    bottom_shape[3] = 7;
392    bottom_shape[4] = 8;
393    FillerParameter filler_param;
394    GaussianFiller&lt;Dtype&gt; filler(filler_param);
395    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
396      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
397      filler.Fill(this-&gt;blob_bottom_vec_[i]);
398    }
399    LayerParameter layer_param;
400    ConvolutionParameter* convolution_param =
401        layer_param.mutable_convolution_param();
402    convolution_param-&gt;add_kernel_size(3);
403    convolution_param-&gt;add_dilation(2);
404    convolution_param-&gt;set_num_output(4);
405    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
406    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
407    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
408        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
409    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
410    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
411    const Dtype* top_data;
412    const Dtype* ref_top_data;
413    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
414               this-&gt;MakeReferenceTop(this-&gt;blob_top_));
415    top_data = this-&gt;blob_top_-&gt;cpu_data();
416    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
417    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
418      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
419    }
420    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
421               this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
422    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
423    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
424    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
425      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
426    }
427  }
428  TYPED_TEST(ConvolutionLayerTest, Test1x1Convolution) {
429    typedef typename TypeParam::Dtype Dtype;
430    LayerParameter layer_param;
431    ConvolutionParameter* convolution_param =
432        layer_param.mutable_convolution_param();
433    convolution_param-&gt;add_kernel_size(1);
434    convolution_param-&gt;add_stride(1);
435    convolution_param-&gt;set_num_output(4);
436    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
437    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
438    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
439    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
440        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
441    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
442    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
443    const Dtype* top_data;
444    const Dtype* ref_top_data;
445    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
446        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
447    top_data = this-&gt;blob_top_-&gt;cpu_data();
448    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
449    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
450      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
451    }
452  }
453  TYPED_TEST(ConvolutionLayerTest, TestSimpleConvolutionGroup) {
454    typedef typename TypeParam::Dtype Dtype;
455    LayerParameter layer_param;
456    ConvolutionParameter* convolution_param =
457        layer_param.mutable_convolution_param();
458    convolution_param-&gt;add_kernel_size(3);
459    convolution_param-&gt;add_stride(2);
460    convolution_param-&gt;set_num_output(3);
461    convolution_param-&gt;set_group(3);
462    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
463    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
464    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
465    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
466        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
467    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
468    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
469    const Dtype* top_data;
470    const Dtype* ref_top_data;
471    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
472        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
473    top_data = this-&gt;blob_top_-&gt;cpu_data();
474    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
475    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
476      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
477    }
478  }
479  TYPED_TEST(ConvolutionLayerTest, TestSobelConvolution) {
480    typedef typename TypeParam::Dtype Dtype;
481    shared_ptr&lt;GaussianFiller&lt;Dtype&gt; &gt; filler;
482    FillerParameter filler_param;
483    filler_param.set_value(1.);
484    filler.reset(new GaussianFiller&lt;Dtype&gt;(filler_param));
485    filler-&gt;Fill(this-&gt;blob_bottom_);
486    this-&gt;blob_bottom_2_-&gt;CopyFrom(*this-&gt;blob_bottom_);
487    LayerParameter layer_param;
488    ConvolutionParameter* convolution_param =
489        layer_param.mutable_convolution_param();
490    convolution_param-&gt;add_kernel_size(3);
491    convolution_param-&gt;add_stride(2);
492    convolution_param-&gt;set_num_output(1);
493    convolution_param-&gt;set_bias_term(false);
494    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
495        new ConvolutionLayer&lt;Dtype&gt;(layer_param));
496    layer-&gt;blobs().resize(1);
497    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 3));
498    Dtype* weights = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
499    for (int c = 0; c &lt; 3; ++c) {
500      int i = c * 9;  
501      weights[i +  0] = -1;
502      weights[i +  1] =  0;
503      weights[i +  2] =  1;
504      weights[i +  3] = -2;
505      weights[i +  4] =  0;
506      weights[i +  5] =  2;
507      weights[i +  6] = -1;
508      weights[i +  7] =  0;
509      weights[i +  8] =  1;
510    }
511    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
512    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
513    vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_bottom_vec;
514    vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_top_vec;
515    shared_ptr&lt;Blob&lt;Dtype&gt; &gt; blob_sep(new Blob&lt;Dtype&gt;());
516    sep_blob_bottom_vec.push_back(this-&gt;blob_bottom_2_);
517    sep_blob_top_vec.push_back(this-&gt;blob_top_2_);
518    convolution_param-&gt;clear_kernel_size();
519    convolution_param-&gt;clear_stride();
520    convolution_param-&gt;set_kernel_h(3);
521    convolution_param-&gt;set_kernel_w(1);
522    convolution_param-&gt;set_stride_h(2);
523    convolution_param-&gt;set_stride_w(1);
524    convolution_param-&gt;set_num_output(1);
525    convolution_param-&gt;set_bias_term(false);
526    layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
527    layer-&gt;blobs().resize(1);
528    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 1));
529    Dtype* weights_1 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
530    for (int c = 0; c &lt; 3; ++c) {
531      int i = c * 3;  
532      weights_1[i +  0] = 1;
533      weights_1[i +  1] = 2;
534      weights_1[i +  2] = 1;
535    }
536    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
537    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
538    blob_sep-&gt;CopyFrom(*this-&gt;blob_top_2_, false, true);
539    sep_blob_bottom_vec.clear();
540    sep_blob_bottom_vec.push_back(blob_sep.get());
541    convolution_param-&gt;set_kernel_h(1);
542    convolution_param-&gt;set_kernel_w(3);
543    convolution_param-&gt;set_stride_h(1);
544    convolution_param-&gt;set_stride_w(2);
545    convolution_param-&gt;set_num_output(1);
546    convolution_param-&gt;set_bias_term(false);
547    layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
548    layer-&gt;blobs().resize(1);
549    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 1, 1, 3));
550    Dtype* weights_2 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
551    weights_2[0] = -1;
552    weights_2[1] =  0;
553    weights_2[2] =  1;
554    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
555    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
556    const Dtype* top_data = this-&gt;blob_top_-&gt;cpu_data();
557    const Dtype* sep_top_data = this-&gt;blob_top_2_-&gt;cpu_data();
558    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
559      EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
560    }
561  }
562  TYPED_TEST(ConvolutionLayerTest, TestNDAgainst2D) {
563    typedef typename TypeParam::Dtype Dtype;
564    const int kernel_h = 11;
565    const int kernel_w = 13;
566    vector&lt;int&gt; bottom_shape(4);
567    bottom_shape[0] = 15;
568    bottom_shape[1] = 18;
569    bottom_shape[2] = kernel_h * 2;
570    bottom_shape[3] = kernel_w * 2;
571    FillerParameter filler_param;
572    GaussianFiller&lt;Dtype&gt; filler(filler_param);
573    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
574      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
575      filler.Fill(this-&gt;blob_bottom_vec_[i]);
576    }
577    LayerParameter layer_param;
578    ConvolutionParameter* convolution_param =
579        layer_param.mutable_convolution_param();
580    convolution_param-&gt;set_num_output(12);
581    convolution_param-&gt;set_bias_term(false);
582    convolution_param-&gt;set_group(6);
583    convolution_param-&gt;set_kernel_h(kernel_h);
584    convolution_param-&gt;set_kernel_w(kernel_w);
585    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
586    Blob&lt;Dtype&gt; weights;
587    Blob&lt;Dtype&gt; top_diff;
588    bool copy_diff;
589    bool reshape;
590    {
591      ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
592      layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
593      top_diff.ReshapeLike(*this-&gt;blob_top_);
594      filler.Fill(&amp;top_diff);
595      ASSERT_EQ(1, layer.blobs().size());
596      copy_diff = false; reshape = true;
597      weights.CopyFrom(*layer.blobs()[0], copy_diff, reshape);
598    }
599    vector&lt;bool&gt; propagate_down(1, true);
600    Blob&lt;Dtype&gt; result_2d;
601    Blob&lt;Dtype&gt; backward_result_2d;
602    Blob&lt;Dtype&gt; backward_weight_result_2d;
603    {
604      caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
605                this-&gt;blob_top_-&gt;mutable_cpu_data());
606      caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
607                this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
608      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
609      convolution_param-&gt;set_force_nd_im2col(false);
610      ConvolutionLayer&lt;Dtype&gt; layer_2d(layer_param);
611      layer_2d.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
612      ASSERT_EQ(1, layer_2d.blobs().size());
613      copy_diff = false; reshape = false;
614      layer_2d.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
615      layer_2d.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
616      copy_diff = false; reshape = true;
617      result_2d.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
618      ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
619      caffe_copy(top_diff.count(), top_diff.cpu_data(),
620                 this-&gt;blob_top_-&gt;mutable_cpu_diff());
621      layer_2d.Backward(this-&gt;blob_top_vec_, propagate_down,
622                        this-&gt;blob_bottom_vec_);
623      copy_diff = true; reshape = true;
624      backward_result_2d.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
625      backward_weight_result_2d.CopyFrom(weights, copy_diff, reshape);
626    }
627    Blob&lt;Dtype&gt; result_nd;
628    Blob&lt;Dtype&gt; backward_result_nd;
629    Blob&lt;Dtype&gt; backward_weight_result_nd;
630    {
631      caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
632                this-&gt;blob_top_-&gt;mutable_cpu_data());
633      caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
634                this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
635      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
636      convolution_param-&gt;set_force_nd_im2col(true);
637      ConvolutionLayer&lt;Dtype&gt; layer_nd(layer_param);
638      layer_nd.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
639      ASSERT_EQ(1, layer_nd.blobs().size());
640      copy_diff = false; reshape = false;
641      layer_nd.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
642      layer_nd.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
643      copy_diff = false; reshape = true;
644      result_nd.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
645      ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
646      caffe_copy(top_diff.count(), top_diff.cpu_data(),
647                 this-&gt;blob_top_-&gt;mutable_cpu_diff());
648      layer_nd.Backward(this-&gt;blob_top_vec_, propagate_down,
649                        this-&gt;blob_bottom_vec_);
650      copy_diff = true; reshape = true;
651      backward_result_nd.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
652      backward_weight_result_nd.CopyFrom(weights, copy_diff, reshape);
653    }
654    ASSERT_EQ(result_nd.count(), result_2d.count());
655    for (int i = 0; i &lt; result_2d.count(); ++i)  {
656      EXPECT_EQ(result_2d.cpu_data()[i], result_nd.cpu_data()[i]);
657    }
658    ASSERT_EQ(backward_result_nd.count(), backward_result_2d.count());
659    for (int i = 0; i &lt; backward_result_2d.count(); ++i) {
660      EXPECT_EQ(backward_result_2d.cpu_diff()[i],
661                backward_result_nd.cpu_diff()[i]);
662    }
663    ASSERT_EQ(backward_weight_result_nd.count(),
664              backward_weight_result_2d.count());
665    for (int i = 0; i &lt; backward_weight_result_2d.count(); ++i) {
666      EXPECT_EQ(backward_weight_result_2d.cpu_diff()[i],
667                backward_weight_result_nd.cpu_diff()[i]);
668    }
669  }
670  TYPED_TEST(ConvolutionLayerTest, TestGradient) {
671    typedef typename TypeParam::Dtype Dtype;
672    LayerParameter layer_param;
673    ConvolutionParameter* convolution_param =
674        layer_param.mutable_convolution_param();
675    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
676    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
677    convolution_param-&gt;add_kernel_size(3);
678    convolution_param-&gt;add_stride(2);
679    convolution_param-&gt;set_num_output(2);
680    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
681    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
682    ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
683    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
684    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
685        this-&gt;blob_top_vec_);
686  }
687  TYPED_TEST(ConvolutionLayerTest, TestDilatedGradient) {
688    typedef typename TypeParam::Dtype Dtype;
689    LayerParameter layer_param;
690    ConvolutionParameter* convolution_param =
691        layer_param.mutable_convolution_param();
692    vector&lt;int&gt; bottom_shape;
693    bottom_shape.push_back(2);
694    bottom_shape.push_back(3);
695    bottom_shape.push_back(5);
696    bottom_shape.push_back(6);
697    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
698      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
699    }
700    convolution_param-&gt;add_kernel_size(3);
701    convolution_param-&gt;add_dilation(2);
702    convolution_param-&gt;set_num_output(2);
703    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
704    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
705    ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
706    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
707    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
708                                    this-&gt;blob_top_vec_);
709  }
710  TYPED_TEST(ConvolutionLayerTest, TestGradient3D) {
711    typedef typename TypeParam::Dtype Dtype;
712    LayerParameter layer_param;
713    ConvolutionParameter* convolution_param =
714        layer_param.mutable_convolution_param();
715    vector&lt;int&gt; bottom_shape(5);
716    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
717    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
718    bottom_shape[2] = 5;
719    bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
720    bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
721    FillerParameter filler_param;
722    GaussianFiller&lt;Dtype&gt; filler(filler_param);
723    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
724      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
725      filler.Fill(this-&gt;blob_bottom_vec_[i]);
726    }
727    convolution_param-&gt;add_kernel_size(3);
728    convolution_param-&gt;add_stride(2);
729    convolution_param-&gt;set_num_output(2);
730    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
731    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
732    ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
733    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
734    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
735        this-&gt;blob_top_vec_);
736  }
737  TYPED_TEST(ConvolutionLayerTest, Test1x1Gradient) {
738    typedef typename TypeParam::Dtype Dtype;
739    LayerParameter layer_param;
740    ConvolutionParameter* convolution_param =
741        layer_param.mutable_convolution_param();
742    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
743    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
744    convolution_param-&gt;add_kernel_size(1);
745    convolution_param-&gt;add_stride(1);
746    convolution_param-&gt;set_num_output(2);
747    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
748    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
749    ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
750    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
751    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
752        this-&gt;blob_top_vec_);
753  }
754  TYPED_TEST(ConvolutionLayerTest, TestGradientGroup) {
755    typedef typename TypeParam::Dtype Dtype;
756    LayerParameter layer_param;
757    ConvolutionParameter* convolution_param =
758        layer_param.mutable_convolution_param();
759    convolution_param-&gt;add_kernel_size(3);
760    convolution_param-&gt;add_stride(2);
761    convolution_param-&gt;set_num_output(3);
762    convolution_param-&gt;set_group(3);
763    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
764    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
765    ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
766    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
767    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
768        this-&gt;blob_top_vec_);
769  }
770  #ifdef USE_CUDNN
771  template &lt;typename Dtype&gt;
772  class CuDNNConvolutionLayerTest : public GPUDeviceTest&lt;Dtype&gt; {
773   protected:
774    CuDNNConvolutionLayerTest()
775        : blob_bottom_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
776          blob_bottom_2_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
777          blob_top_(new Blob&lt;Dtype&gt;()),
778          blob_top_2_(new Blob&lt;Dtype&gt;()) {}
779    virtual void SetUp() {
780      FillerParameter filler_param;
781      filler_param.set_value(1.);
782      GaussianFiller&lt;Dtype&gt; filler(filler_param);
783      filler.Fill(this-&gt;blob_bottom_);
784      filler.Fill(this-&gt;blob_bottom_2_);
785      blob_bottom_vec_.push_back(blob_bottom_);
786      blob_top_vec_.push_back(blob_top_);
787    }
788    virtual ~CuDNNConvolutionLayerTest() {
789      delete blob_bottom_;
790      delete blob_bottom_2_;
791      delete blob_top_;
792      delete blob_top_2_;
793    }
794    virtual Blob&lt;Dtype&gt;* MakeReferenceTop(Blob&lt;Dtype&gt;* top) {
795      this-&gt;ref_blob_top_.reset(new Blob&lt;Dtype&gt;());
796      this-&gt;ref_blob_top_-&gt;ReshapeLike(*top);
797      return this-&gt;ref_blob_top_.get();
798    }
799    Blob&lt;Dtype&gt;* const blob_bottom_;
800    Blob&lt;Dtype&gt;* const blob_bottom_2_;
801    Blob&lt;Dtype&gt;* const blob_top_;
802    Blob&lt;Dtype&gt;* const blob_top_2_;
803    shared_ptr&lt;Blob&lt;Dtype&gt; &gt; ref_blob_top_;
804    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
805    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
806  };
807  TYPED_TEST_CASE(CuDNNConvolutionLayerTest, TestDtypes);
808  TYPED_TEST(CuDNNConvolutionLayerTest, TestSetupCuDNN) {
809    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
810    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
811    LayerParameter layer_param;
812    ConvolutionParameter* convolution_param =
813        layer_param.mutable_convolution_param();
814    convolution_param-&gt;add_kernel_size(3);
815    convolution_param-&gt;add_stride(2);
816    convolution_param-&gt;set_num_output(4);
817    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
818    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
819    shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
820        new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
821    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
822    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
823    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 4);
824    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
825    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
826    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
827    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 4);
828    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
829    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
830    convolution_param-&gt;set_num_output(3);
831    convolution_param-&gt;set_group(3);
832    layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
833    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
834    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
835    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 3);
836    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
837    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
838    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
839    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 3);
840    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
841    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
842  }
843  TYPED_TEST(CuDNNConvolutionLayerTest, TestSimpleConvolutionCuDNN) {
844    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
845    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
846    LayerParameter layer_param;
847    ConvolutionParameter* convolution_param =
848        layer_param.mutable_convolution_param();
849    convolution_param-&gt;add_kernel_size(3);
850    convolution_param-&gt;add_stride(2);
851    convolution_param-&gt;set_num_output(4);
852    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
853    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
854    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
855    shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
856        new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
857    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
858    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
859    const TypeParam* top_data;
860    const TypeParam* ref_top_data;
861    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
862        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
863    top_data = this-&gt;blob_top_-&gt;cpu_data();
864    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
865    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
866      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
867    }
868    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
869        this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
870    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
871    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
872    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
873      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
874    }
875  }
876  TYPED_TEST(CuDNNConvolutionLayerTest, TestSimpleConvolutionGroupCuDNN) {
877    LayerParameter layer_param;
878    ConvolutionParameter* convolution_param =
879        layer_param.mutable_convolution_param();
880    convolution_param-&gt;add_kernel_size(3);
881    convolution_param-&gt;add_stride(2);
882    convolution_param-&gt;set_num_output(3);
883    convolution_param-&gt;set_group(3);
884    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
885    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
886    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
887    shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
888        new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
889    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
890    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
891    const TypeParam* top_data;
892    const TypeParam* ref_top_data;
893    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
894        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
895    top_data = this-&gt;blob_top_-&gt;cpu_data();
896    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
897    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
898      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
899    }
900  }
901  TYPED_TEST(CuDNNConvolutionLayerTest, TestSobelConvolutionCuDNN) {
902    shared_ptr&lt;GaussianFiller&lt;TypeParam&gt; &gt; filler;
903    FillerParameter filler_param;
904    filler_param.set_value(1.);
905    filler.reset(new GaussianFiller&lt;TypeParam&gt;(filler_param));
906    filler-&gt;Fill(this-&gt;blob_bottom_);
907    this-&gt;blob_bottom_2_-&gt;CopyFrom(*this-&gt;blob_bottom_);
908    LayerParameter layer_param;
909    ConvolutionParameter* convolution_param =
910        layer_param.mutable_convolution_param();
911    convolution_param-&gt;add_kernel_size(3);
912    convolution_param-&gt;add_stride(2);
913    convolution_param-&gt;set_num_output(1);
914    convolution_param-&gt;set_bias_term(false);
915    shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
916        new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
917    layer-&gt;blobs().resize(1);
918    layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 3, 3, 3));
919    TypeParam* weights = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
920    for (int c = 0; c &lt; 3; ++c) {
921      int i = c * 9;  
922      weights[i +  0] = -1;
923      weights[i +  1] =  0;
924      weights[i +  2] =  1;
925      weights[i +  3] = -2;
926      weights[i +  4] =  0;
927      weights[i +  5] =  2;
928      weights[i +  6] = -1;
929      weights[i +  7] =  0;
930      weights[i +  8] =  1;
931    }
932    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
933    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
934    vector&lt;Blob&lt;TypeParam&gt;*&gt; sep_blob_bottom_vec;
935    vector&lt;Blob&lt;TypeParam&gt;*&gt; sep_blob_top_vec;
936    shared_ptr&lt;Blob&lt;TypeParam&gt; &gt; blob_sep(new Blob&lt;TypeParam&gt;());
937    sep_blob_bottom_vec.push_back(this-&gt;blob_bottom_2_);
938    sep_blob_top_vec.push_back(this-&gt;blob_top_2_);
939    convolution_param-&gt;clear_kernel_size();
940    convolution_param-&gt;clear_stride();
941    convolution_param-&gt;set_kernel_h(3);
942    convolution_param-&gt;set_kernel_w(1);
943    convolution_param-&gt;set_stride_h(2);
944    convolution_param-&gt;set_stride_w(1);
945    convolution_param-&gt;set_num_output(1);
946    convolution_param-&gt;set_bias_term(false);
947    layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
948    layer-&gt;blobs().resize(1);
949    layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 3, 3, 1));
950    TypeParam* weights_1 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
951    for (int c = 0; c &lt; 3; ++c) {
952      int i = c * 3;  
953      weights_1[i +  0] = 1;
954      weights_1[i +  1] = 2;
955      weights_1[i +  2] = 1;
956    }
957    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
958    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
959    blob_sep-&gt;CopyFrom(*this-&gt;blob_top_2_, false, true);
960    sep_blob_bottom_vec.clear();
961    sep_blob_bottom_vec.push_back(blob_sep.get());
962    convolution_param-&gt;set_kernel_h(1);
963    convolution_param-&gt;set_kernel_w(3);
964    convolution_param-&gt;set_stride_h(1);
965    convolution_param-&gt;set_stride_w(2);
966    convolution_param-&gt;set_num_output(1);
967    convolution_param-&gt;set_bias_term(false);
968    layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
969    layer-&gt;blobs().resize(1);
970    layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 1, 1, 3));
971    TypeParam* weights_2 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
972    weights_2[0] = -1;
973    weights_2[1] =  0;
974    weights_2[2] =  1;
975    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
976    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
977    const TypeParam* top_data = this-&gt;blob_top_-&gt;cpu_data();
978    const TypeParam* sep_top_data = this-&gt;blob_top_2_-&gt;cpu_data();
979    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
980      EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
981    }
982  }
983  TYPED_TEST(CuDNNConvolutionLayerTest, TestGradientCuDNN) {
984    LayerParameter layer_param;
985    ConvolutionParameter* convolution_param =
986        layer_param.mutable_convolution_param();
987    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
988    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
989    convolution_param-&gt;add_kernel_size(3);
990    convolution_param-&gt;add_stride(2);
991    convolution_param-&gt;set_num_output(2);
992    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
993    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
994    CuDNNConvolutionLayer&lt;TypeParam&gt; layer(layer_param);
995    GradientChecker&lt;TypeParam&gt; checker(1e-2, 1e-3);
996    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
997        this-&gt;blob_top_vec_);
998  }
999  TYPED_TEST(CuDNNConvolutionLayerTest, TestGradientGroupCuDNN) {
1000    LayerParameter layer_param;
1001    ConvolutionParameter* convolution_param =
1002        layer_param.mutable_convolution_param();
1003    convolution_param-&gt;add_kernel_size(3);
1004    convolution_param-&gt;add_stride(2);
1005    convolution_param-&gt;set_num_output(3);
1006    convolution_param-&gt;set_group(3);
1007    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
1008    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
1009    CuDNNConvolutionLayer&lt;TypeParam&gt; layer(layer_param);
1010    GradientChecker&lt;TypeParam&gt; checker(1e-2, 1e-3);
1011    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
1012        this-&gt;blob_top_vec_);
1013  }
1014  #endif
1015  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_convolution_layer.cpp</h3>
            <pre><code>1  #ifdef MKLDNN_SUPPORTED
2  #include &lt;vector&gt;
3  #include &quot;gtest/gtest.h&quot;
4  #include &quot;caffe/blob.hpp&quot;
5  #include &quot;caffe/common.hpp&quot;
6  #include &quot;caffe/filler.hpp&quot;
7  #include &quot;caffe/layers/mkldnn_layers.hpp&quot;
8  #include &quot;caffe/test/test_caffe_main.hpp&quot;
9  #include &quot;caffe/test/test_gradient_check_util.hpp&quot;
10  namespace caffe {
11  template &lt;typename Dtype&gt;
12  void caffe_conv(const Blob&lt;Dtype&gt;* in, ConvolutionParameter* conv_param,
13      const vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt;&amp; weights,
14      Blob&lt;Dtype&gt;* out) {
15    const bool has_depth = (out-&gt;num_axes() == 5);
16    if (!has_depth) { CHECK_EQ(4, out-&gt;num_axes()); }
17    int kernel_h, kernel_w;
18    if (conv_param-&gt;has_kernel_h() || conv_param-&gt;has_kernel_w()) {
19      kernel_h = conv_param-&gt;kernel_h();
20      kernel_w = conv_param-&gt;kernel_w();
21    } else {
22      kernel_h = kernel_w = conv_param-&gt;kernel_size(0);
23    }
24    int pad_h, pad_w;
25    if (conv_param-&gt;has_pad_h() || conv_param-&gt;has_pad_w()) {
26      pad_h = conv_param-&gt;pad_h();
27      pad_w = conv_param-&gt;pad_w();
28    } else {
29      pad_h = pad_w = conv_param-&gt;pad_size() ? conv_param-&gt;pad(0) : 0;
30    }
31    int stride_h, stride_w;
32    if (conv_param-&gt;has_stride_h() || conv_param-&gt;has_stride_w()) {
33      stride_h = conv_param-&gt;stride_h();
34      stride_w = conv_param-&gt;stride_w();
35    } else {
36      stride_h = stride_w = conv_param-&gt;stride_size() ? conv_param-&gt;stride(0) : 1;
37    }
38    int dilation_h, dilation_w;
39    dilation_h = dilation_w = conv_param-&gt;dilation_size() ?
40                              conv_param-&gt;dilation(0) : 1;
41    int kernel_d, pad_d, stride_d, dilation_d;
42    if (has_depth) {
43      kernel_d = kernel_h;
44      stride_d = stride_h;
45      pad_d = pad_h;
46      dilation_d = dilation_h;
47    } else {
48      kernel_d = stride_d = dilation_d = 1;
49      pad_d = 0;
50    }
51    int groups = conv_param-&gt;group();
52    int o_g = out-&gt;shape(1) / groups;
53    int k_g = in-&gt;shape(1) / groups;
54    int o_head, k_head;
55    vector&lt;int&gt; weight_offset(4 + has_depth);
56    vector&lt;int&gt; in_offset(4 + has_depth);
57    vector&lt;int&gt; out_offset(4 + has_depth);
58    Dtype* out_data = out-&gt;mutable_cpu_data();
59    for (int n = 0; n &lt; out-&gt;shape(0); n++) {
60      for (int g = 0; g &lt; groups; g++) {
61        o_head = o_g * g;
62        k_head = k_g * g;
63        for (int o = 0; o &lt; o_g; o++) {
64          for (int k = 0; k &lt; k_g; k++) {
65            for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
66              for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
67                for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
68                  for (int r = 0; r &lt; kernel_d; r++) {
69                    for (int p = 0; p &lt; kernel_h; p++) {
70                      for (int q = 0; q &lt; kernel_w; q++) {
71                        int in_z = z * stride_d - pad_d + r * dilation_d;
72                        int in_y = y * stride_h - pad_h + p * dilation_h;
73                        int in_x = x * stride_w - pad_w + q * dilation_w;
74                        if (in_z &gt;= 0 &amp;&amp; in_z &lt; (has_depth ? in-&gt;shape(2) : 1)
75                            &amp;&amp; in_y &gt;= 0 &amp;&amp; in_y &lt; in-&gt;shape(2 + has_depth)
76                            &amp;&amp; in_x &gt;= 0 &amp;&amp; in_x &lt; in-&gt;shape(3 + has_depth)) {
77                          weight_offset[0] = o + o_head;
78                          weight_offset[1] = k;
79                          if (has_depth) { weight_offset[2] = r; }
80                          weight_offset[2 + has_depth] = p;
81                          weight_offset[3 + has_depth] = q;
82                          in_offset[0] = n;
83                          in_offset[1] = k + k_head;
84                          if (has_depth) { in_offset[2] = in_z; }
85                          in_offset[2 + has_depth] = in_y;
86                          in_offset[3 + has_depth] = in_x;
87                          out_offset[0] = n;
88                          out_offset[1] = o + o_head;
89                          if (has_depth) { out_offset[2] = z; }
90                          out_offset[2 + has_depth] = y;
91                          out_offset[3 + has_depth] = x;
92                          out_data[out-&gt;offset(out_offset)] +=
93                              in-&gt;data_at(in_offset)
94                              * weights[0]-&gt;data_at(weight_offset);
95                        }
96                      }
97                    }
98                  }
99                }
100              }
101            }
102          }
103        }
104      }
105    }
106    if (conv_param-&gt;bias_term()) {
107      const Dtype* bias_data = weights[1]-&gt;cpu_data();
108      for (int n = 0; n &lt; out-&gt;shape(0); n++) {
109        for (int o = 0; o &lt; out-&gt;shape(1); o++) {
110          for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
111            for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
112              for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
113                out_offset[0] = n;
114                out_offset[1] = o;
115                if (has_depth) { out_offset[2] = z; }
116                out_offset[2 + has_depth] = y;
117                out_offset[3 + has_depth] = x;
118                out_data[out-&gt;offset(out_offset)] += bias_data[o];
119              }
120            }
121          }
122        }
123      }
124    }
125    if (conv_param-&gt;relu()){
126      for (int n = 0; n &lt; out-&gt;shape(0); n++) {
127        for (int o = 0; o &lt; out-&gt;shape(1); o++) {
128          for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
129            for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
130              for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
131                out_offset[0] = n;
132                out_offset[1] = o;
133                if (has_depth) { out_offset[2] = z; }
134                out_offset[2 + has_depth] = y;
135                out_offset[3 + has_depth] = x;
136                if(out_data[out-&gt;offset(out_offset)] &lt; 0) out_data[out-&gt;offset(out_offset)] = 0;
137              }
138            }
139          }
140        }
141      }
142    }
143  }
144  template void caffe_conv(const Blob&lt;float&gt;* in,
145      ConvolutionParameter* conv_param,
146      const vector&lt;shared_ptr&lt;Blob&lt;float&gt; &gt; &gt;&amp; weights,
147      Blob&lt;float&gt;* out);
148  template void caffe_conv(const Blob&lt;double&gt;* in,
149      ConvolutionParameter* conv_param,
150      const vector&lt;shared_ptr&lt;Blob&lt;double&gt; &gt; &gt;&amp; weights,
151      Blob&lt;double&gt;* out);
152  template &lt;typename TypeParam&gt;
153  class MKLDNNConvolutionLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
154    typedef typename TypeParam::Dtype Dtype;
155  #define MB 2
156  #define IC 8
157  #define OC 8
158  #define IH 5
159  #define IW 5
160  #define OH 5
161  #define OW 5
162  #define KH 3
163  #define KW 3
164  #define CS 1
165  #define GR 2
166  #define PD 1
167   protected:
168    MKLDNNConvolutionLayerTest()
169        : blob_bottom_(new Blob&lt;Dtype&gt;(MB, IC, IH, IW)),
170          blob_bottom_2_(new Blob&lt;Dtype&gt;(MB, IC, IH, IW)),
171          blob_top_(new Blob&lt;Dtype&gt;()),
172          blob_top_2_(new Blob&lt;Dtype&gt;()) {}
173    virtual void SetUp() {
174      FillerParameter filler_param;
175      filler_param.set_value(1.);
176      GaussianFiller&lt;Dtype&gt; filler(filler_param);
177      filler.Fill(this-&gt;blob_bottom_);
178      filler.Fill(this-&gt;blob_bottom_2_);
179      blob_bottom_vec_.push_back(blob_bottom_);
180      blob_top_vec_.push_back(blob_top_);
181    }
182    virtual ~MKLDNNConvolutionLayerTest() {
183      delete blob_bottom_;
184      delete blob_bottom_2_;
185      delete blob_top_;
186      delete blob_top_2_;
187    }
188    virtual Blob&lt;Dtype&gt;* MakeReferenceTop(Blob&lt;Dtype&gt;* top) {
189      this-&gt;ref_blob_top_.reset(new Blob&lt;Dtype&gt;());
190      this-&gt;ref_blob_top_-&gt;ReshapeLike(*top);
191      return this-&gt;ref_blob_top_.get();
192    }
193    Blob&lt;Dtype&gt;* const blob_bottom_;
194    Blob&lt;Dtype&gt;* const blob_bottom_2_;
195    Blob&lt;Dtype&gt;* const blob_top_;
196    Blob&lt;Dtype&gt;* const blob_top_2_;
197    shared_ptr&lt;Blob&lt;Dtype&gt; &gt; ref_blob_top_;
198    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
199    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
200  };
201  typedef ::testing::Types&lt;CPUDevice&lt;float&gt;
202                          &gt; TestDtypesCPU;
203  TYPED_TEST_CASE(MKLDNNConvolutionLayerTest, TestDtypesCPU);
204  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSetupMKLDNN) {
205    typedef typename TypeParam::Dtype Dtype;
206    LayerParameter layer_param;
207    ConvolutionParameter* convolution_param =
208        layer_param.mutable_convolution_param();
209    convolution_param-&gt;add_kernel_size(KH);
210    convolution_param-&gt;add_stride(CS);
211    convolution_param-&gt;set_num_output(OC);
212    convolution_param-&gt;add_pad(PD);
213    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
214    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
215    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
216        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
217    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
218    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), MB);
219    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), OC);
220    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), OH);
221    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), OW);
222    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), MB);
223    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), OC );
224    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), OH);
225    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), OW);
226    convolution_param-&gt;set_num_output(OC);
227    convolution_param-&gt;set_group(GR);
228    layer.reset(new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
229    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
230    EXPECT_EQ(this-&gt;blob_top_-&gt;num(), MB);
231    EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), OC);
232    EXPECT_EQ(this-&gt;blob_top_-&gt;height(), OH);
233    EXPECT_EQ(this-&gt;blob_top_-&gt;width(), OW);
234    EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), MB);
235    EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), OC);
236    EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), OH);
237    EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), OW);
238  }
239  #if 0
240  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSetupMKLDNNWithRectangeKernelStridePad) {
241    typedef typename TypeParam::Dtype Dtype;
242    LayerParameter layer_param;
243    ConvolutionParameter* convolution_param =
244        layer_param.mutable_convolution_param();
245    convolution_param-&gt;set_kernel_h(4);
246    convolution_param-&gt;set_kernel_w(1);
247    convolution_param-&gt;set_stride_h(3);
248    convolution_param-&gt;set_stride_w(1);
249    convolution_param-&gt;set_num_output(OC);
250    convolution_param-&gt;set_pad_h(2);
251    convolution_param-&gt;set_pad_w(1);
252    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
253    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
254    shared_ptr&lt;MKLDNNConvolutionLayer&lt;Dtype&gt; &gt; layer(
255        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
256    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
257    EXPECT_EQ(convolution_param-&gt;kernel_h(), 4);
258    EXPECT_EQ(layer-&gt;GetKernelHeight(), 4);
259    EXPECT_EQ(convolution_param-&gt;kernel_w(), 1);
260    EXPECT_EQ(layer-&gt;GetKernelWidth(), 1);
261    EXPECT_EQ(convolution_param-&gt;stride_h(), 3);
262    EXPECT_EQ(layer-&gt;GetStrideHeight(), 3);
263    EXPECT_EQ(convolution_param-&gt;stride_w(), 1);
264    EXPECT_EQ(layer-&gt;GetStrideWidth(), 1);
265    EXPECT_EQ(convolution_param-&gt;pad_h(), 2);
266    EXPECT_EQ(layer-&gt;GetPadHeight(), 2);
267    EXPECT_EQ(convolution_param-&gt;pad_w(), 1);
268    EXPECT_EQ(layer-&gt;GetPadWidth(), 1);
269    convolution_param-&gt;set_num_output(OC);
270    convolution_param-&gt;set_group(GR);
271    layer.reset(new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
272    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
273    EXPECT_EQ(convolution_param-&gt;kernel_h(), 4);
274    EXPECT_EQ(layer-&gt;GetKernelHeight(), 4);
275    EXPECT_EQ(convolution_param-&gt;kernel_w(), 1);
276    EXPECT_EQ(layer-&gt;GetKernelWidth(), 1);
277    EXPECT_EQ(convolution_param-&gt;stride_h(), 3);
278    EXPECT_EQ(layer-&gt;GetStrideHeight(), 3);
279    EXPECT_EQ(convolution_param-&gt;stride_w(), 1);
280    EXPECT_EQ(layer-&gt;GetStrideWidth(), 1);
281    EXPECT_EQ(convolution_param-&gt;pad_h(), 2);
282    EXPECT_EQ(layer-&gt;GetPadHeight(), 2);
283    EXPECT_EQ(convolution_param-&gt;pad_w(), 1);
284    EXPECT_EQ(layer-&gt;GetPadWidth(), 1);
285  }
286  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSimpleConvolutionMKLDNN) {
287    typedef typename TypeParam::Dtype Dtype;
288    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
289    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
290    LayerParameter layer_param;
291    ConvolutionParameter* convolution_param =
292        layer_param.mutable_convolution_param();
293    convolution_param-&gt;add_kernel_size(KH);
294    convolution_param-&gt;add_stride(CS);
295    convolution_param-&gt;set_num_output(OC);
296    convolution_param-&gt;add_pad(PD);
297    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
298    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
299    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
300    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
301        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
302    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
303    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
304    const Dtype* top_data;
305    const Dtype* ref_top_data;
306    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
307        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
308    top_data = this-&gt;blob_top_-&gt;cpu_data();
309    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
310    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
311      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
312    }
313  #if 0   
314    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
315        this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
316    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
317    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
318    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
319      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
320    }
321  #endif
322  }
323  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSimpleConvolutionReLUMKLDNN) {
324    typedef typename TypeParam::Dtype Dtype;
325    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
326    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
327    LayerParameter layer_param;
328    ConvolutionParameter* convolution_param =
329        layer_param.mutable_convolution_param();
330    convolution_param-&gt;add_kernel_size(3);
331    convolution_param-&gt;add_stride(2);
332    convolution_param-&gt;set_num_output(OC);
333    convolution_param-&gt;set_relu(true);
334    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
335    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
336    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
337    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
338        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
339    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
340    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
341    const Dtype* top_data;
342    const Dtype* ref_top_data;
343    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
344        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
345    top_data = this-&gt;blob_top_-&gt;cpu_data();
346    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
347    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
348      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
349    }
350  }
351  TYPED_TEST(MKLDNNConvolutionLayerTest, TestDilatedConvolutionMKLDNN) {
352    typedef typename TypeParam::Dtype Dtype;
353    vector&lt;int&gt; bottom_shape;
354    bottom_shape.push_back(2);
355    bottom_shape.push_back(3);
356    bottom_shape.push_back(8);
357    bottom_shape.push_back(7);
358    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
359    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
360    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
361      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
362    }
363    LayerParameter layer_param;
364    ConvolutionParameter* convolution_param =
365        layer_param.mutable_convolution_param();
366    convolution_param-&gt;add_kernel_size(3);
367    convolution_param-&gt;add_dilation(2);
368    convolution_param-&gt;set_num_output(4);
369    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
370    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
371    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
372    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
373        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
374    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
375    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
376    const Dtype* top_data;
377    const Dtype* ref_top_data;
378    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
379               this-&gt;MakeReferenceTop(this-&gt;blob_top_));
380    top_data = this-&gt;blob_top_-&gt;cpu_data();
381    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
382    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
383      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
384    }
385  #if 0   
386    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
387               this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
388    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
389    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
390    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
391      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
392    }
393  #endif
394  }
395  #endif
396  #if 0
397  TYPED_TEST(MKLDNNConvolutionLayerTest, Test0DConvolutionMKLDNN) {
398    typedef typename TypeParam::Dtype Dtype;
399    LayerParameter layer_param;
400    ConvolutionParameter* convolution_param =
401        layer_param.mutable_convolution_param();
402    const int kNumOutput = 3;
403    convolution_param-&gt;set_num_output(kNumOutput);
404    convolution_param-&gt;set_axis(3);
405    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
406    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
407    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
408        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
409    vector&lt;int&gt; top_shape = this-&gt;blob_bottom_-&gt;shape();
410    top_shape[3] = kNumOutput;
411    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
412    EXPECT_EQ(top_shape, this-&gt;blob_top_-&gt;shape());
413    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
414    vector&lt;int&gt; weight_offset(2);
415    const Blob&lt;Dtype&gt;* weight = layer-&gt;blobs()[0].get();
416    const Blob&lt;Dtype&gt;* bias = layer-&gt;blobs()[1].get();
417    const int num = this-&gt;blob_top_-&gt;count(3);
418    const int dim = this-&gt;blob_top_-&gt;shape(3);
419    const int bottom_dim = this-&gt;blob_bottom_-&gt;shape(3);
420    for (int n = 0; n &lt; num; ++n) {
421      for (int d = 0; d &lt; dim; ++d) {
<span onclick='openModal()' class='match'>422        weight_offset[0] = d;
423        Dtype value = bias-&gt;cpu_data()[d];
424        for (int bottom_d = 0; bottom_d &lt; bottom_dim; ++bottom_d) {
425          weight_offset[1] = bottom_d;
426          value += weight-&gt;data_at(weight_offset) *
427                   this-&gt;blob_bottom_-&gt;cpu_data()[n * bottom_dim + bottom_d];
428        }
429        EXPECT_NEAR(value, this-&gt;blob_top_-&gt;cpu_data()[n * dim + d], 1e-4);
430      }
431    }
432  }
433  #endif
</span>434  #if 0
435  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSimple3DConvolution) {
436    typedef typename TypeParam::Dtype Dtype;
437    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
438    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
439    vector&lt;int&gt; bottom_shape(5);
440    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
441    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
442    bottom_shape[2] = 5;
443    bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
444    bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
445    FillerParameter filler_param;
446    GaussianFiller&lt;Dtype&gt; filler(filler_param);
447    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
448      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
449      filler.Fill(this-&gt;blob_bottom_vec_[i]);
450    }
451    LayerParameter layer_param;
452    ConvolutionParameter* convolution_param =
453        layer_param.mutable_convolution_param();
454    convolution_param-&gt;add_kernel_size(3);
455    convolution_param-&gt;add_stride(2);
456    convolution_param-&gt;set_num_output(4);
457    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
458    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
459    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
460        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
461    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
462    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
463    const Dtype* top_data;
464    const Dtype* ref_top_data;
465    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
466        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
467    top_data = this-&gt;blob_top_-&gt;cpu_data();
468    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
469    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
470      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
471    }
472  #if 0   
473    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
474        this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
475    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
476    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
477    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
478      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
479    }
480  #endif
481  }
482  #endif
483  #if 0
484  TYPED_TEST(MKLDNNConvolutionLayerTest, TestDilated3DConvolution) {
485    typedef typename TypeParam::Dtype Dtype;
486    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
487    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
488    vector&lt;int&gt; bottom_shape(5);
489    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
490    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
491    bottom_shape[2] = 6;
492    bottom_shape[3] = 7;
493    bottom_shape[4] = 8;
494    FillerParameter filler_param;
495    GaussianFiller&lt;Dtype&gt; filler(filler_param);
496    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
497      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
498      filler.Fill(this-&gt;blob_bottom_vec_[i]);
499    }
500    LayerParameter layer_param;
501    ConvolutionParameter* convolution_param =
502        layer_param.mutable_convolution_param();
503    convolution_param-&gt;add_kernel_size(3);
504    convolution_param-&gt;add_dilation(2);
505    convolution_param-&gt;set_num_output(4);
506    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
507    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
508    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
509        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
510    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
511    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
512    const Dtype* top_data;
513    const Dtype* ref_top_data;
514    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
515               this-&gt;MakeReferenceTop(this-&gt;blob_top_));
516    top_data = this-&gt;blob_top_-&gt;cpu_data();
517    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
518    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
519      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
520    }
521    caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
522               this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
523    top_data = this-&gt;blob_top_2_-&gt;cpu_data();
524    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
525    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
526      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
527    }
528  }
529  #endif
530  TYPED_TEST(MKLDNNConvolutionLayerTest, Test1x1Convolution) {
531    typedef typename TypeParam::Dtype Dtype;
532    LayerParameter layer_param;
533    ConvolutionParameter* convolution_param =
534        layer_param.mutable_convolution_param();
535    convolution_param-&gt;add_kernel_size(1);
536    convolution_param-&gt;add_stride(1);
537    convolution_param-&gt;set_num_output(OC);
538    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
539    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
540    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
541    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
542        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
543    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
544    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
545    const Dtype* top_data;
546    const Dtype* ref_top_data;
547    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
548        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
549    top_data = this-&gt;blob_top_-&gt;cpu_data();
550    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
551    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
552      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
553    }
554  }
555  TYPED_TEST(MKLDNNConvolutionLayerTest, Test1x1ConvolutionReLU) {
556    typedef typename TypeParam::Dtype Dtype;
557    LayerParameter layer_param;
558    ConvolutionParameter* convolution_param =
559        layer_param.mutable_convolution_param();
560    convolution_param-&gt;add_kernel_size(1);
561    convolution_param-&gt;add_stride(1);
562    convolution_param-&gt;set_num_output(OC);
563    convolution_param-&gt;set_relu(true);
564    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
565    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
566    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
567    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
568        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
569    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
570    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
571    const Dtype* top_data;
572    const Dtype* ref_top_data;
573    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
574        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
575    top_data = this-&gt;blob_top_-&gt;cpu_data();
576    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
577    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
578      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
579    }
580  }
581  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSimpleConvolutionGroup) {
582    typedef typename TypeParam::Dtype Dtype;
583    LayerParameter layer_param;
584    ConvolutionParameter* convolution_param =
585        layer_param.mutable_convolution_param();
586    convolution_param-&gt;add_kernel_size(KH);
587    convolution_param-&gt;add_stride(CS);
588    convolution_param-&gt;set_num_output(OC);
589    convolution_param-&gt;set_group(GR);
590    convolution_param-&gt;add_pad(PD);
591    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
592    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
593    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
594    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
595        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
596    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
597    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
598    const Dtype* top_data;
599    const Dtype* ref_top_data;
600    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
601        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
602    top_data = this-&gt;blob_top_-&gt;cpu_data();
603    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
604    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
605      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
606    }
607  }
608  #if 0
609  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSimpleConvolutionReLUGroup) {
610    typedef typename TypeParam::Dtype Dtype;
611    LayerParameter layer_param;
612    ConvolutionParameter* convolution_param =
613        layer_param.mutable_convolution_param();
614    convolution_param-&gt;add_kernel_size(3);
615    convolution_param-&gt;add_stride(2);
616    convolution_param-&gt;set_num_output(OC);
617    convolution_param-&gt;set_relu(true);
618    convolution_param-&gt;set_group(GR);
619    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
620    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;constant&quot;);
621    convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
622    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
623        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
624    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
625    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
626    const Dtype* top_data;
627    const Dtype* ref_top_data;
628    caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
629        this-&gt;MakeReferenceTop(this-&gt;blob_top_));
630    top_data = this-&gt;blob_top_-&gt;cpu_data();
631    ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
632    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
633      EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
634    }
635  }
636  TYPED_TEST(MKLDNNConvolutionLayerTest, TestSobelConvolution) {
637    typedef typename TypeParam::Dtype Dtype;
638    shared_ptr&lt;GaussianFiller&lt;Dtype&gt; &gt; filler;
639    FillerParameter filler_param;
640    filler_param.set_value(1.);
641    filler.reset(new GaussianFiller&lt;Dtype&gt;(filler_param));
642    filler-&gt;Fill(this-&gt;blob_bottom_);
643    this-&gt;blob_bottom_2_-&gt;CopyFrom(*this-&gt;blob_bottom_);
644    LayerParameter layer_param;
645    ConvolutionParameter* convolution_param =
646        layer_param.mutable_convolution_param();
647    convolution_param-&gt;add_kernel_size(3);
648    convolution_param-&gt;add_stride(2);
649    convolution_param-&gt;set_num_output(1);
650    convolution_param-&gt;set_bias_term(false);
651    shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
652        new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
653    layer-&gt;blobs().resize(1);
654    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 3));
655    Dtype* weights = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
656    for (int c = 0; c &lt; 3; ++c) {
657      int i = c * 9;  
658      weights[i +  0] = -1;
659      weights[i +  1] =  0;
660      weights[i +  2] =  1;
661      weights[i +  3] = -2;
662      weights[i +  4] =  0;
663      weights[i +  5] =  2;
664      weights[i +  6] = -1;
665      weights[i +  7] =  0;
666      weights[i +  8] =  1;
667    }
668    layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
669    layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
670    vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_bottom_vec;
671    vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_top_vec;
672    shared_ptr&lt;Blob&lt;Dtype&gt; &gt; blob_sep(new Blob&lt;Dtype&gt;());
673    sep_blob_bottom_vec.push_back(this-&gt;blob_bottom_2_);
674    sep_blob_top_vec.push_back(this-&gt;blob_top_2_);
675    convolution_param-&gt;clear_kernel_size();
676    convolution_param-&gt;clear_stride();
677    convolution_param-&gt;set_kernel_h(3);
678    convolution_param-&gt;set_kernel_w(1);
679    convolution_param-&gt;set_stride_h(2);
680    convolution_param-&gt;set_stride_w(1);
681    convolution_param-&gt;set_num_output(1);
682    convolution_param-&gt;set_bias_term(false);
683    layer.reset(new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
684    layer-&gt;blobs().resize(1);
685    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 1));
686    Dtype* weights_1 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
687    for (int c = 0; c &lt; 3; ++c) {
688      int i = c * 3;  
689      weights_1[i +  0] = 1;
690      weights_1[i +  1] = 2;
691      weights_1[i +  2] = 1;
692    }
693    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
694    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
695    blob_sep-&gt;CopyFrom(*this-&gt;blob_top_2_, false, true);
696    sep_blob_bottom_vec.clear();
697    sep_blob_bottom_vec.push_back(blob_sep.get());
698    convolution_param-&gt;set_kernel_h(1);
699    convolution_param-&gt;set_kernel_w(3);
700    convolution_param-&gt;set_stride_h(1);
701    convolution_param-&gt;set_stride_w(2);
702    convolution_param-&gt;set_num_output(1);
703    convolution_param-&gt;set_bias_term(false);
704    layer.reset(new MKLDNNConvolutionLayer&lt;Dtype&gt;(layer_param));
705    layer-&gt;blobs().resize(1);
706    layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 1, 1, 3));
707    Dtype* weights_2 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
708    weights_2[0] = -1;
709    weights_2[1] =  0;
710    weights_2[2] =  1;
711    layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
712    layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
713    const Dtype* top_data = this-&gt;blob_top_-&gt;cpu_data();
714    const Dtype* sep_top_data = this-&gt;blob_top_2_-&gt;cpu_data();
715    for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
716      EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
717    }
718  }
719  #endif
720  #if 0
721  TYPED_TEST(MKLDNNConvolutionLayerTest, TestNDAgainst2D) {
722    typedef typename TypeParam::Dtype Dtype;
723    const int kernel_h = 11;
724    const int kernel_w = 13;
725    vector&lt;int&gt; bottom_shape(4);
726    bottom_shape[0] = 15;
727    bottom_shape[1] = 18;
728    bottom_shape[2] = kernel_h * 2;
729    bottom_shape[3] = kernel_w * 2;
730    FillerParameter filler_param;
731    GaussianFiller&lt;Dtype&gt; filler(filler_param);
732    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
733      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
734      filler.Fill(this-&gt;blob_bottom_vec_[i]);
735    }
736    LayerParameter layer_param;
737    ConvolutionParameter* convolution_param =
738        layer_param.mutable_convolution_param();
739    convolution_param-&gt;set_num_output(12);
740    convolution_param-&gt;set_bias_term(false);
741    convolution_param-&gt;set_group(6);
742    convolution_param-&gt;set_kernel_h(kernel_h);
743    convolution_param-&gt;set_kernel_w(kernel_w);
744    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
745    Blob&lt;Dtype&gt; weights;
746    Blob&lt;Dtype&gt; top_diff;
747    bool copy_diff;
748    bool reshape;
749    {
750      MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
751      layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
752      top_diff.ReshapeLike(*this-&gt;blob_top_);
753      filler.Fill(&amp;top_diff);
754      ASSERT_EQ(1, layer.blobs().size());
755      copy_diff = false; reshape = true;
756      weights.CopyFrom(*layer.blobs()[0], copy_diff, reshape);
757    }
758    vector&lt;bool&gt; propagate_down(1, true);
759    Blob&lt;Dtype&gt; result_2d;
760    Blob&lt;Dtype&gt; backward_result_2d;
761    Blob&lt;Dtype&gt; backward_weight_result_2d;
762    {
763      caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
764                this-&gt;blob_top_-&gt;mutable_cpu_data());
765      caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
766                this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
767      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
768      convolution_param-&gt;set_force_nd_im2col(false);
769      MKLDNNConvolutionLayer&lt;Dtype&gt; layer_2d(layer_param);
770      layer_2d.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
771      ASSERT_EQ(1, layer_2d.blobs().size());
772      copy_diff = false; reshape = false;
773      layer_2d.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
774      layer_2d.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
775      copy_diff = false; reshape = true;
776      result_2d.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
777      ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
778      caffe_copy(top_diff.count(), top_diff.cpu_data(),
779                 this-&gt;blob_top_-&gt;mutable_cpu_diff());
780      layer_2d.Backward(this-&gt;blob_top_vec_, propagate_down,
781                        this-&gt;blob_bottom_vec_);
782      copy_diff = true; reshape = true;
783      backward_result_2d.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
784      backward_weight_result_2d.CopyFrom(weights, copy_diff, reshape);
785    }
786    Blob&lt;Dtype&gt; result_nd;
787    Blob&lt;Dtype&gt; backward_result_nd;
788    Blob&lt;Dtype&gt; backward_weight_result_nd;
789    {
790      caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
791                this-&gt;blob_top_-&gt;mutable_cpu_data());
792      caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
793                this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
794      caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
795      convolution_param-&gt;set_force_nd_im2col(true);
796      MKLDNNConvolutionLayer&lt;Dtype&gt; layer_nd(layer_param);
797      layer_nd.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
798      ASSERT_EQ(1, layer_nd.blobs().size());
799      copy_diff = false; reshape = false;
800      layer_nd.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
801      layer_nd.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
802      copy_diff = false; reshape = true;
803      result_nd.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
804      ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
805      caffe_copy(top_diff.count(), top_diff.cpu_data(),
806                 this-&gt;blob_top_-&gt;mutable_cpu_diff());
807      layer_nd.Backward(this-&gt;blob_top_vec_, propagate_down,
808                        this-&gt;blob_bottom_vec_);
809      copy_diff = true; reshape = true;
810      backward_result_nd.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
811      backward_weight_result_nd.CopyFrom(weights, copy_diff, reshape);
812    }
813    ASSERT_EQ(result_nd.count(), result_2d.count());
814    for (int i = 0; i &lt; result_2d.count(); ++i)  {
815      EXPECT_EQ(result_2d.cpu_data()[i], result_nd.cpu_data()[i]);
816    }
817    ASSERT_EQ(backward_result_nd.count(), backward_result_2d.count());
818    for (int i = 0; i &lt; backward_result_2d.count(); ++i) {
819      EXPECT_EQ(backward_result_2d.cpu_diff()[i],
820                backward_result_nd.cpu_diff()[i]);
821    }
822    ASSERT_EQ(backward_weight_result_nd.count(),
823              backward_weight_result_2d.count());
824    for (int i = 0; i &lt; backward_weight_result_2d.count(); ++i) {
825      EXPECT_EQ(backward_weight_result_2d.cpu_diff()[i],
826                backward_weight_result_nd.cpu_diff()[i]);
827    }
828  }
829  #endif
830  TYPED_TEST(MKLDNNConvolutionLayerTest, DISABLED_TestGradient) {
831    typedef typename TypeParam::Dtype Dtype;
832    LayerParameter layer_param;
833    ConvolutionParameter* convolution_param =
834        layer_param.mutable_convolution_param();
835    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
836    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
837    convolution_param-&gt;add_kernel_size(KH);
838    convolution_param-&gt;add_stride(CS);
839    convolution_param-&gt;set_num_output(OC);
840    convolution_param-&gt;add_pad(PD);
841    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
842    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
843    MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
844    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
845    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
846        this-&gt;blob_top_vec_);
847  }
848  #if 0
849  TYPED_TEST(MKLDNNConvolutionLayerTest, TestDilatedGradient) {
850    typedef typename TypeParam::Dtype Dtype;
851    LayerParameter layer_param;
852    ConvolutionParameter* convolution_param =
853        layer_param.mutable_convolution_param();
854    vector&lt;int&gt; bottom_shape;
855    bottom_shape.push_back(2);
856    bottom_shape.push_back(3);
857    bottom_shape.push_back(5);
858    bottom_shape.push_back(6);
859    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
860      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
861    }
862    convolution_param-&gt;add_kernel_size(3);
863    convolution_param-&gt;add_dilation(2);
864    convolution_param-&gt;set_num_output(2);
865    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
866    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
867    MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
868    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
869    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
870                                    this-&gt;blob_top_vec_);
871  }
872  #endif
873  #if 0
874  TYPED_TEST(MKLDNNConvolutionLayerTest, TestGradient3D) {
875    typedef typename TypeParam::Dtype Dtype;
876    LayerParameter layer_param;
877    ConvolutionParameter* convolution_param =
878        layer_param.mutable_convolution_param();
879    vector&lt;int&gt; bottom_shape(5);
880    bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
881    bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
882    bottom_shape[2] = 5;
883    bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
884    bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
885    FillerParameter filler_param;
886    GaussianFiller&lt;Dtype&gt; filler(filler_param);
887    for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
888      this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
889      filler.Fill(this-&gt;blob_bottom_vec_[i]);
890    }
891    convolution_param-&gt;add_kernel_size(3);
892    convolution_param-&gt;add_stride(2);
893    convolution_param-&gt;set_num_output(2);
894    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
895    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
896    MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
897    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
898    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
899        this-&gt;blob_top_vec_);
900  }
901  TYPED_TEST(MKLDNNConvolutionLayerTest, Test1x1Gradient) {
902    typedef typename TypeParam::Dtype Dtype;
903    LayerParameter layer_param;
904    ConvolutionParameter* convolution_param =
905        layer_param.mutable_convolution_param();
906    this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
907    this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
908    convolution_param-&gt;add_kernel_size(1);
909    convolution_param-&gt;add_stride(1);
910    convolution_param-&gt;set_num_output(2);
911    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
912    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
913    MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
914    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
915    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
916        this-&gt;blob_top_vec_);
917  }
918  #endif
919  TYPED_TEST(MKLDNNConvolutionLayerTest, TestGradientGroup) {
920    typedef typename TypeParam::Dtype Dtype;
921    LayerParameter layer_param;
922    ConvolutionParameter* convolution_param =
923        layer_param.mutable_convolution_param();
924    convolution_param-&gt;add_kernel_size(3);
925    convolution_param-&gt;add_stride(2);
926    convolution_param-&gt;set_num_output(2);
927    convolution_param-&gt;set_group(GR);
928    convolution_param-&gt;mutable_weight_filler()-&gt;set_type(&quot;gaussian&quot;);
929    convolution_param-&gt;mutable_bias_filler()-&gt;set_type(&quot;gaussian&quot;);
930    MKLDNNConvolutionLayer&lt;Dtype&gt; layer(layer_param);
931    GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
932    checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
933        this-&gt;blob_top_vec_);
934  }
935  }  
936  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_convolution_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkldnn_convolution_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>327        weight_offset[0] = d;
328        Dtype value = bias-&gt;cpu_data()[d];
329        for (int bottom_d = 0; bottom_d &lt; bottom_dim; ++bottom_d) {
330          weight_offset[1] = bottom_d;
331          value += weight-&gt;data_at(weight_offset) *
332                   this-&gt;blob_bottom_-&gt;cpu_data()[n * bottom_dim + bottom_d];
333        }
334        EXPECT_NEAR(value, this-&gt;blob_top_-&gt;cpu_data()[n * dim + d], 1e-4);
335      }
336    }
337  }
338  TYPED_TEST(ConvolutionLayerTest, TestSimple3DConvolution) {
</pre></code></div>
                <div class="column column_space"><pre><code>422        weight_offset[0] = d;
423        Dtype value = bias-&gt;cpu_data()[d];
424        for (int bottom_d = 0; bottom_d &lt; bottom_dim; ++bottom_d) {
425          weight_offset[1] = bottom_d;
426          value += weight-&gt;data_at(weight_offset) *
427                   this-&gt;blob_bottom_-&gt;cpu_data()[n * bottom_dim + bottom_d];
428        }
429        EXPECT_NEAR(value, this-&gt;blob_top_-&gt;cpu_data()[n * dim + d], 1e-4);
430      }
431    }
432  }
433  #endif
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    