
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.8%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mdtr.cpp</h3>
            <pre><code>1  #include "mdtr.h"
2  PDNd TDNd::Load(TSIn& SIn){
3    TStr TypeNm(SIn);
4    if (TypeNm==TTypeNm<TDNdLeaf>()){return new TDNdLeaf(SIn);}
5    else {Fail; return NULL;}
6  }
7  PTbValDs TDNdLeaf::GetPostrValDs(const PValRet& ValRet) const {
8    return Md->GetPostrValDs(PValRet(new TOvlValRet(Md->GetDmHd(), ValRet)));}
9  PTbValDs TDNdABr::GetPostrValDs(const PValRet& ValRet) const {
10    return DNdV[OrTbValSet->InN(ValRet->GetVal(AttrN))]->GetPostrValDs(ValRet);}
<span onclick='openModal()' class='match'>11  void TDNdABr::Print() const {
12    printf("Node-AttrBr\n");
13    for (int BrN=0; BrN<DNdV.Len(); BrN++){DNdV[BrN]->Print();}
14  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tessedit.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "control.h"
5  #include "matchdefs.h"
6  #include "pageres.h"
7  #include "params.h"
8  #include "stopper.h"
9  #include "tesseractclass.h"
10  #include "tessvars.h"
11  #include "tprintf.h"
12  #ifndef DISABLED_LEGACY_ENGINE
13  #  include "chop.h"
14  #  include "intmatcher.h"
15  #  include "reject.h"
16  #endif
17  #include "lstmrecognizer.h"
18  namespace tesseract {
19  void Tesseract::read_config_file(const char *filename, SetParamConstraint constraint) {
20    std::string path = datadir;
21    path += "configs/";
22    path += filename;
23    FILE *fp;
24    if ((fp = fopen(path.c_str(), "rb")) != nullptr) {
25      fclose(fp);
26    } else {
27      path = datadir;
28      path += "tessconfigs/";
29      path += filename;
30      if ((fp = fopen(path.c_str(), "rb")) != nullptr) {
31        fclose(fp);
32      } else {
33        path = filename;
34      }
35    }
36    ParamUtils::ReadParamsFile(path.c_str(), constraint, this->params());
37  }
38  bool Tesseract::init_tesseract_lang_data(const std::string &arg0,
39                                           const std::string &language, OcrEngineMode oem,
40                                           char **configs, int configs_size,
41                                           const std::vector<std::string> *vars_vec,
42                                           const std::vector<std::string> *vars_values,
43                                           bool set_only_non_debug_params, TessdataManager *mgr) {
44    lang = !language.empty() ? language : "eng";
45    language_data_path_prefix = datadir;
46    language_data_path_prefix += lang;
47    language_data_path_prefix += ".";
48    std::string tessdata_path = language_data_path_prefix + kTrainedDataSuffix;
49    if (!mgr->is_loaded() && !mgr->Init(tessdata_path.c_str())) {
50      tprintf("Error opening data file %s\n", tessdata_path.c_str());
51      tprintf(
52          "Please make sure the TESSDATA_PREFIX environment variable is set"
53          " to your \"tessdata\" directory.\n");
54      return false;
55    }
56  #ifdef DISABLED_LEGACY_ENGINE
57    tessedit_ocr_engine_mode.set_value(OEM_LSTM_ONLY);
58  #else
59    if (oem == OEM_DEFAULT) {
60      if (!mgr->IsLSTMAvailable()) {
61        tessedit_ocr_engine_mode.set_value(OEM_TESSERACT_ONLY);
62      } else if (!mgr->IsBaseAvailable()) {
63        tessedit_ocr_engine_mode.set_value(OEM_LSTM_ONLY);
64      } else {
65        tessedit_ocr_engine_mode.set_value(OEM_TESSERACT_LSTM_COMBINED);
66      }
67    }
68  #endif 
69    TFile fp;
70    if (mgr->GetComponent(TESSDATA_LANG_CONFIG, &fp)) {
71      ParamUtils::ReadParamsFromFp(SET_PARAM_CONSTRAINT_NONE, &fp, this->params());
72    }
73    SetParamConstraint set_params_constraint =
74        set_only_non_debug_params ? SET_PARAM_CONSTRAINT_NON_DEBUG_ONLY : SET_PARAM_CONSTRAINT_NONE;
75    for (int i = 0; i < configs_size; ++i) {
76      read_config_file(configs[i], set_params_constraint);
77    }
78    if (vars_vec != nullptr && vars_values != nullptr) {
79      for (unsigned i = 0; i < vars_vec->size(); ++i) {
80        if (!ParamUtils::SetParam((*vars_vec)[i].c_str(), (*vars_values)[i].c_str(),
81                                  set_params_constraint, this->params())) {
82          tprintf("Warning: The parameter '%s' was not found.\n", (*vars_vec)[i].c_str());
83        }
84      }
85    }
86    if (!tessedit_write_params_to_file.empty()) {
87      FILE *params_file = fopen(tessedit_write_params_to_file.c_str(), "wb");
88      if (params_file != nullptr) {
89        ParamUtils::PrintParams(params_file, this->params());
90        fclose(params_file);
91      } else {
92        tprintf("Failed to open %s for writing params.\n", tessedit_write_params_to_file.c_str());
93      }
94    }
95  #ifndef DISABLED_LEGACY_ENGINE
96    if (oem != OEM_DEFAULT) {
97      tessedit_ocr_engine_mode.set_value(oem);
98    }
99  #endif
100    if (tessedit_init_config_only) {
101      return true;
102    }
103  #ifdef DISABLED_LEGACY_ENGINE
104    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
105  #else
106    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY ||
107        tessedit_ocr_engine_mode == OEM_TESSERACT_LSTM_COMBINED) {
108  #endif 
109      if (mgr->IsComponentAvailable(TESSDATA_LSTM)) {
110        lstm_recognizer_ = new LSTMRecognizer(language_data_path_prefix.c_str());
111        ASSERT_HOST(lstm_recognizer_->Load(this->params(), lstm_use_matrix ? language : "", mgr));
112      } else {
113        tprintf("Error: LSTM requested, but not present!! Loading tesseract.\n");
114        tessedit_ocr_engine_mode.set_value(OEM_TESSERACT_ONLY);
115      }
116    }
117    if (tessedit_ocr_engine_mode == OEM_LSTM_ONLY) {
118      unicharset.CopyFrom(lstm_recognizer_->GetUnicharset());
119    }
120  #ifndef DISABLED_LEGACY_ENGINE
121    else if (!mgr->GetComponent(TESSDATA_UNICHARSET, &fp) || !unicharset.load_from_file(&fp, false)) {
122      tprintf(
123          "Error: Tesseract (legacy) engine requested, but components are "
124          "not present in %s!!\n",
125          tessdata_path.c_str());
126      return false;
127    }
128  #endif 
129    if (unicharset.size() > MAX_NUM_CLASSES) {
130      tprintf("Error: Size of unicharset is greater than MAX_NUM_CLASSES\n");
131      return false;
132    }
133    right_to_left_ = unicharset.major_right_to_left();
134  #ifndef DISABLED_LEGACY_ENGINE
135    UNICHARSET encoder_unicharset;
136    encoder_unicharset.CopyFrom(unicharset);
137    unichar_ambigs.InitUnicharAmbigs(unicharset, use_ambigs_for_adaption);
138    unichar_ambigs.LoadUniversal(encoder_unicharset, &unicharset);
139    if (!tessedit_ambigs_training && mgr->GetComponent(TESSDATA_AMBIGS, &fp)) {
140      unichar_ambigs.LoadUnicharAmbigs(encoder_unicharset, &fp, ambigs_debug_level,
141                                       use_ambigs_for_adaption, &unicharset);
142    }
143    for (int p = ParamsModel::PTRAIN_PASS1; p < ParamsModel::PTRAIN_NUM_PASSES; ++p) {
144      language_model_->getParamsModel().SetPass(static_cast<ParamsModel::PassEnum>(p));
145      if (mgr->GetComponent(TESSDATA_PARAMS_MODEL, &fp)) {
146        if (!language_model_->getParamsModel().LoadFromFp(lang.c_str(), &fp)) {
147          return false;
148        }
149      }
150    }
151  #endif 
152    return true;
153  }
154  static bool IsStrInList(const std::string &str, const std::vector<std::string> &str_list) {
155    for (const auto &i : str_list) {
156      if (i == str) {
157        return true;
158      }
159    }
160    return false;
161  }
162  void Tesseract::ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
163                                      std::vector<std::string> *not_to_load) {
164    std::string remains(lang_str);
165    std::string prefix;
166    size_t found = lang.find_last_of('/');
167    if (found != std::string::npos) {
168      prefix = lang.substr(0, found + 1);
169    }
170    while (!remains.empty()) {
171      const char *start = remains.c_str();
172      while (*start == '+') {
173        ++start;
174      }
175      std::vector<std::string> *target = to_load;
176      if (*start == '~') {
177        target = not_to_load;
178        ++start;
179      }
180      int end = strlen(start);
181      const char *plus = strchr(start, '+');
182      if (plus != nullptr && plus - start < end) {
183        end = plus - start;
184      }
185      std::string lang_code(start);
186      lang_code.resize(end);
187      std::string next(start + end);
188      remains = next;
189      lang_code = prefix + lang_code;
190      if (!IsStrInList(lang_code, *target)) {
191        target->push_back(lang_code);
192      }
193    }
194  }
195  int Tesseract::init_tesseract(const std::string &arg0, const std::string &textbase,
196                                const std::string &language, OcrEngineMode oem, char **configs,
197                                int configs_size, const std::vector<std::string> *vars_vec,
198                                const std::vector<std::string> *vars_values,
199                                bool set_only_non_debug_params, TessdataManager *mgr) {
200    std::vector<std::string> langs_to_load;
201    std::vector<std::string> langs_not_to_load;
202    ParseLanguageString(language, &langs_to_load, &langs_not_to_load);
203    for (auto *lang : sub_langs_) {
204      delete lang;
205    }
206    main_setup(arg0, textbase);
207    sub_langs_.clear();
208    bool loaded_primary = false;
209    for (auto &lang_to_load : langs_to_load) {
210      if (!IsStrInList(lang_to_load, langs_not_to_load)) {
211        const char *lang_str = lang_to_load.c_str();
212        Tesseract *tess_to_init;
213        if (!loaded_primary) {
214          tess_to_init = this;
215        } else {
216          tess_to_init = new Tesseract;
217          tess_to_init->main_setup(arg0, textbase);
218        }
219        int result = tess_to_init->init_tesseract_internal(arg0, textbase, lang_str, oem, configs,
220                                                           configs_size, vars_vec, vars_values,
221                                                           set_only_non_debug_params, mgr);
222        mgr->Clear();
223        if (!loaded_primary) {
224          if (result < 0) {
225            tprintf("Failed loading language '%s'\n", lang_str);
226          } else {
227            ParseLanguageString(tess_to_init->tessedit_load_sublangs, &langs_to_load,
228                                &langs_not_to_load);
229            loaded_primary = true;
230          }
231        } else {
232          if (result < 0) {
233            tprintf("Failed loading language '%s'\n", lang_str);
234            delete tess_to_init;
235          } else {
236            sub_langs_.push_back(tess_to_init);
237            ParseLanguageString(tess_to_init->tessedit_load_sublangs, &langs_to_load,
238                                &langs_not_to_load);
239          }
240        }
241      }
242    }
243    if (!loaded_primary && !langs_to_load.empty()) {
244      tprintf("Tesseract couldn't load any languages!\n");
245      return -1; 
246    }
247  #ifndef DISABLED_LEGACY_ENGINE
248    if (!sub_langs_.empty()) {
249      if (tessedit_use_primary_params_model) {
250        for (auto &sub_lang : sub_langs_) {
251          sub_lang->language_model_->getParamsModel().Copy(this->language_model_->getParamsModel());
252        }
253        tprintf("Using params model of the primary language\n");
254      } else {
255        this->language_model_->getParamsModel().Clear();
256        for (auto &sub_lang : sub_langs_) {
257          sub_lang->language_model_->getParamsModel().Clear();
258        }
259      }
260    }
261    SetupUniversalFontIds();
262  #endif 
263    return 0;
264  }
265  int Tesseract::init_tesseract_internal(const std::string &arg0, const std::string &textbase,
266                                         const std::string &language, OcrEngineMode oem,
267                                         char **configs, int configs_size,
268                                         const std::vector<std::string> *vars_vec,
269                                         const std::vector<std::string> *vars_values,
270                                         bool set_only_non_debug_params, TessdataManager *mgr) {
271    if (!init_tesseract_lang_data(arg0, language, oem, configs, configs_size, vars_vec,
272                                  vars_values, set_only_non_debug_params, mgr)) {
273      return -1;
274    }
275    if (tessedit_init_config_only) {
276      return 0;
277    }
278    bool init_tesseract = tessedit_ocr_engine_mode != OEM_LSTM_ONLY;
279    program_editup(textbase, init_tesseract ? mgr : nullptr, init_tesseract ? mgr : nullptr);
280    return 0; 
281  }
282  #ifndef DISABLED_LEGACY_ENGINE
<span onclick='openModal()' class='match'>283  static void CollectFonts(const UnicityTable<FontInfo> &new_fonts,
284                           UnicityTable<FontInfo> *all_fonts) {
285    for (int i = 0; i < new_fonts.size(); ++i) {
286      all_fonts->push_back(new_fonts.at(i));
287    }
288  }
</span>289  static void AssignIds(const UnicityTable<FontInfo> &all_fonts, UnicityTable<FontInfo> *lang_fonts) {
290    for (int i = 0; i < lang_fonts->size(); ++i) {
291      auto index = all_fonts.get_index(lang_fonts->at(i));
292      lang_fonts->at(i).universal_id = index;
293    }
294  }
295  void Tesseract::SetupUniversalFontIds() {
296    UnicityTable<FontInfo> all_fonts;
297    CollectFonts(get_fontinfo_table(), &all_fonts);
298    for (auto &sub_lang : sub_langs_) {
299      CollectFonts(sub_lang->get_fontinfo_table(), &all_fonts);
300    }
301    AssignIds(all_fonts, &get_fontinfo_table());
302    for (auto &sub_lang : sub_langs_) {
303      AssignIds(all_fonts, &sub_lang->get_fontinfo_table());
304    }
305    font_table_size_ = all_fonts.size();
306  }
307  #endif 
308  void Tesseract::end_tesseract() {
309    end_recog();
310  }
311  enum CMD_EVENTS { ACTION_1_CMD_EVENT, RECOG_WERDS, RECOG_PSEUDO, ACTION_2_CMD_EVENT };
312  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mdtr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tessedit.cpp</div>
                </div>
                <div class="column column_space"><pre><code>11  void TDNdABr::Print() const {
12    printf("Node-AttrBr\n");
13    for (int BrN=0; BrN<DNdV.Len(); BrN++){DNdV[BrN]->Print();}
14  }
</pre></code></div>
                <div class="column column_space"><pre><code>283  static void CollectFonts(const UnicityTable<FontInfo> &new_fonts,
284                           UnicityTable<FontInfo> *all_fonts) {
285    for (int i = 0; i < new_fonts.size(); ++i) {
286      all_fonts->push_back(new_fonts.at(i));
287    }
288  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    