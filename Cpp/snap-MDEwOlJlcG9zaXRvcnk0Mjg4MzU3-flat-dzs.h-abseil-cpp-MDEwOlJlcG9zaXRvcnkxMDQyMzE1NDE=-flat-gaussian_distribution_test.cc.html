
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.665024630541872%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dzs.h</h3>
            <pre><code>1  #ifndef dzs_h
2  #define dzs_h
3  #include "book.h"
4  class TDzsBsDoc;
5  typedef TPt<TDzsBsDoc> PDzsBsDoc;
6  typedef TVec<PDzsBsDoc> TDzsBsDocV;
7  class TDzsBsDoc{
8  private:
9    TCRef CRef;
10  private:
11    TStr IdStr;
12    TStr TitleStr;
13    TStr DataStr;
14    TInt YearN;
15  public:
16    TDzsBsDoc(): IdStr(), TitleStr(), DataStr(), YearN(){}
17    TDzsBsDoc(const TStr _IdStr, const TStr& _TitleStr,
18     const TStr& _DataStr, const int& _YearN):
19      IdStr(_IdStr), TitleStr(_TitleStr), DataStr(_DataStr), YearN(_YearN){}
20    static PDzsBsDoc New(const TStr& IdStr, const TStr& TitleStr,
21     const TStr& DataStr, const int& YearN){
22      return PDzsBsDoc(new TDzsBsDoc(IdStr, TitleStr, DataStr, YearN));}
23    static PDzsBsDoc Load(TSIn& SIn){return new TDzsBsDoc(SIn);}
24    TDzsBsDoc(TSIn& SIn):
25      IdStr(SIn), TitleStr(SIn), DataStr(SIn), YearN(SIn){}
26    void Save(TSOut& SOut){
27      IdStr.Save(SOut); TitleStr.Save(SOut);
28      DataStr.Save(SOut); YearN.Save(SOut);}
29    TDzsBsDoc& operator=(const TDzsBsDoc& Doc){
30      IdStr=Doc.IdStr; TitleStr=Doc.TitleStr;
31      DataStr=Doc.DataStr; YearN=Doc.YearN; return *this;}
32    TStr GetIdStr() const {return IdStr;}
33    TStr GetTitleStr() const {return TitleStr;}
<span onclick='openModal()' class='match'>34    TStr GetDataStr() const {return DataStr;}
35    int GetYearN() const {return YearN;}
</span>36    static void AddDataTokToChA(const PXmlTok& Tok, TChA& ChA);
37    static TStr GetDataTokStr(const PXmlTok& Tok);
38    static TStr GetDataTokVStr(const TXmlTokV& TokV, const TStr& SepStr);
39    static void GetDocParts(
40     const TStr& FNm, const PXmlDoc& XmlDoc,
41     const TStr& FPath, const TStr& WebAlias,
42     bool& Ok, TStr& IdStr, TStr& TitleStr, TStr& DataStr, int& YearN);
43    static PDzsBsDoc GetDzsBsDoc(
44     const TStr& FNm, const PXmlDoc& XmlDoc,
45     const TStr& FPath, const TStr& WebAlias);
46    static void GetDocParts(
47     const TStr& FNm, const PHtmlDoc& HtmlDoc,
48     const TStr& FPath, const TStr& WebAlias,
49     bool& Ok, TStr& IdStr, TStr& TitleStr, TStr& DataStr, int& YearN);
50    static PDzsBsDoc GetDzsBsDoc(
51     const TStr& FNm, const PHtmlDoc& HtmlDoc,
52     const TStr& FPath, const TStr& WebAlias);
53    friend PDzsBsDoc;
54  };
55  class TDzsBs: public TBook{
56  private:
57    static bool IsReg;
58    static bool MkReg(){
59      return TBook::Reg(TTypeNm<TDzsBs>(), TBookLoadF(&Load));}
60  private:
61    TDzsBsDocV DzsBsDocV;
62    PBix Bix;
63    void AddDoc(const PDzsBsDoc& DzsBsDoc);
64  public:
65    TDzsBs(const TStr& FPath, const TStr& WebAlias);
66    static PBook New(const TStr& FPath, const TStr& WebAlias){
67      return PBook(new TDzsBs(FPath, WebAlias));}
68    TDzsBs(TSIn& SIn):
69      TBook(SIn), DzsBsDocV(SIn), Bix(SIn){}
70    static PBook Load(TSIn& SIn){return PBook(new TDzsBs(SIn));}
71    void Save(TSOut& SOut){
72      TBook::Save(SOut); DzsBsDocV.Save(SOut); Bix.Save(SOut);}
73    TDzsBs& operator=(const TDzsBs&){Fail; return *this;}
74    PBookToc GetBookToc() const {Fail; return NULL;}
75    int GetSecs() const {return DzsBsDocV.Len();}
76    void GetSecInfo(
77     const int& SecId, TStr& SecIdStr, TStr& TitleStr, TStr& SecStr) const;
78    PBixRes Search(const TStr& QueryStr) const {
79      return Bix->Search(QueryStr);}
80  };
81  class TDzsBsX;
82  typedef TPt<TDzsBsX> PDzsBsX;
83  class TDzsBsX{
84  private:
85    TCRef CRef;
86  private:
87    PBook Book;
88    PBixRes BixRes;
89  public:
90    TDzsBsX(): Book(), BixRes(){}
91    static PDzsBsX New(){return PDzsBsX(new TDzsBsX());}
92    ~TDzsBsX(){}
93    TDzsBsX(TSIn&){Fail;}
94    static PDzsBsX Load(TSIn& SIn){return PDzsBsX(new TDzsBsX(SIn));}
95    void Save(TSOut&){Fail;}
96    TDzsBsX& operator=(const TDzsBsX&){Fail; return *this;}
97    bool LoadBook(const TStr& FNm);
98    void UnloadBook();
99    int GetBookSecs();
100    bool GetBookSecInfo(
101     const int& SecId, TStr& SecIdStr, TStr& TitleStr, TStr& SecStr);
102    bool SearchBook(const TStr& QueryStr);
103    bool IsResultOk();
104    bool GetResultMsgStr(TStr& MsgStr);
105    bool GetResultQueryStr(TStr& QueryStr);
106    int GetResultHits();
107    bool GetResultHitInfo(
108     const int& HitN, const int& MxTitleLen, const int& MxCtxLen,
109     TStr& SecIdStr, TStr& TitleStr, TStr& SecStr, TStr& CtxStr);
110    friend PDzsBsX;
111  };
112  class TDzsKwBs;
113  typedef TPt<TDzsKwBs> PDzsKwBs;
114  class TDzsKwBs{
115  private:
116    TCRef CRef;
117  private:
118    TStrStrVH KwToSecIdVH;
119  public:
120    TDzsKwBs(): KwToSecIdVH(){}
121    TDzsKwBs(const TStr& FNm);
122    static PDzsKwBs New(const TStr& FNm){return PDzsKwBs(new TDzsKwBs(FNm));}
123    ~TDzsKwBs(){}
124    TDzsKwBs(TSIn&){Fail;}
125    static PDzsKwBs Load(TSIn& SIn){return PDzsKwBs(new TDzsKwBs(SIn));}
126    void Save(TSOut&){Fail;}
127    TDzsKwBs& operator=(const TDzsKwBs&){Fail; return *this;}
128    int GetKws() const {return KwToSecIdVH.Len();}
129    TStr GetKwStr(const int& KwN) const {return KwToSecIdVH.GetKey(KwN);}
130    void AddHits(const PBook& Book, const TStr& FNm);
131    friend PDzsKwBs;
132  };
133  class TDzsHKw;
134  typedef TPt<TDzsHKw> PDzsHKw;
135  typedef TVec<PDzsHKw> TDzsHKwV;
136  class TDzsHKw{
137  private:
138    TCRef CRef;
139  private:
140    TStr KwNm;
141    int Lev;
142    TStrV QueryStrV;
143    TStrV SecIdStrV;
144  public:
145    TDzsHKw(): KwNm(), Lev(), QueryStrV(), SecIdStrV(){}
146    TDzsHKw(const TStr& KwNm, const int& Lev, const TStrV& QueryStrV);
147    static PDzsHKw New(
148     const TStr& KwNm, const int& Lev, const TStrV& QueryStrV=TStrV()){
149      return PDzsHKw(new TDzsHKw(KwNm, Lev, QueryStrV));}
150    ~TDzsHKw(){}
151    TDzsHKw(TSIn&){Fail;}
152    static PDzsHKw Load(TSIn& SIn){return PDzsHKw(new TDzsHKw(SIn));}
153    void Save(TSOut&){Fail;}
154    TDzsHKw& operator=(const TDzsHKw&){Fail; return *this;}
155    TStr GetKwNm() const {return KwNm;}
156    int GetLev() const {return Lev;}
157    int GetQueryStrs() const {return QueryStrV.Len();}
158    TStr GetQueryStr(const int& QueryStrN) const {return QueryStrV[QueryStrN];}
159    void AddSecIdStr(const TStr& SecIdStr){
160      SecIdStrV.AddUnique(SecIdStr);}
161    friend PDzsHKw;
162  };
163  class TDzsHKwBs;
164  typedef TPt<TDzsHKwBs> PDzsHKwBs;
165  class TDzsHKwBs{
166  private:
167    TCRef CRef;
168  private:
169    PXmlDoc XmlDoc;
170  public:
171    TDzsHKwBs(const PXmlDoc& _XmlDoc):
172      XmlDoc(_XmlDoc){EAssert(IsOk(), "Invalid Xml File.");}
173    static PDzsHKwBs New(const PXmlDoc& XmlDoc){
174      return PDzsHKwBs(new TDzsHKwBs(XmlDoc));}
175    ~TDzsHKwBs(){}
176    TDzsHKwBs(TSIn&){Fail;}
177    static PDzsHKwBs Load(TSIn& SIn){return PDzsHKwBs(new TDzsHKwBs(SIn));}
178    void Save(TSOut&){Fail;}
179    TDzsHKwBs& operator=(const TDzsHKwBs&){Fail; return *this;}
180    static bool IsTopicOk(const PXmlTok& TopicTok);
181    bool IsOk() const {
182      return IsTopicOk(XmlDoc->GetTok());}
183    static void AddHits(const PXmlTok& TopicTok, const PBook& Book);
184    void AddHits(const PBook& Book){
185      AddHits(XmlDoc->GetTok(), Book);}
186    static TStr GetQueryStr(const TStr& TxtStr);
187    static TStr GetFPathSegStr(const TStr& TxtStr);
188    static PDzsHKwBs LoadTxt(const TStr& FNm);
189    static PDzsHKwBs LoadXml(const TStr& FNm){
190      return New(TXmlDoc::LoadTxt(FNm));}
191    void SaveXml(const TStr& FNm) const {
192      XmlDoc->SaveTxt(FNm);}
193    static void SaveHtml(const PXmlTok& TopicTok, const TStr& FPath);
194    void SaveHtml(const TStr& FPath){
195      SaveHtml(XmlDoc->GetTok(), FPath);}
196    friend PDzsHKwBs;
197  };
198  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-gaussian_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/gaussian_distribution.h"
2  #include <algorithm>
3  #include <cmath>
4  #include <cstddef>
5  #include <ios>
6  #include <iterator>
7  #include <random>
8  #include <string>
9  #include <type_traits>
10  #include <vector>
11  #include "gmock/gmock.h"
12  #include "gtest/gtest.h"
13  #include "absl/base/macros.h"
14  #include "absl/log/log.h"
15  #include "absl/numeric/internal/representation.h"
16  #include "absl/random/internal/chi_square.h"
17  #include "absl/random/internal/distribution_test_util.h"
18  #include "absl/random/internal/sequence_urbg.h"
19  #include "absl/random/random.h"
20  #include "absl/strings/str_cat.h"
21  #include "absl/strings/str_format.h"
22  #include "absl/strings/str_replace.h"
23  #include "absl/strings/strip.h"
24  namespace {
25  using absl::random_internal::kChiSquared;
26  template <typename RealType>
27  class GaussianDistributionInterfaceTest : public ::testing::Test {};
28  using RealTypes =
29      std::conditional<absl::numeric_internal::IsDoubleDouble(),
30                       ::testing::Types<float, double>,
31                       ::testing::Types<float, double, long double>>::type;
32  TYPED_TEST_SUITE(GaussianDistributionInterfaceTest, RealTypes);
33  TYPED_TEST(GaussianDistributionInterfaceTest, SerializeTest) {
34    using param_type =
35        typename absl::gaussian_distribution<TypeParam>::param_type;
36    const TypeParam kParams[] = {
37        1,                                           
38        std::nextafter(TypeParam(1), TypeParam(0)),  
39        std::nextafter(TypeParam(1), TypeParam(2)),  
40        TypeParam(1e-8), TypeParam(1e-4), TypeParam(2), TypeParam(1e4),
41        TypeParam(1e8), TypeParam(1e20), TypeParam(2.5),
42        std::numeric_limits<TypeParam>::infinity(),
43        std::numeric_limits<TypeParam>::max(),
44        std::numeric_limits<TypeParam>::epsilon(),
45        std::nextafter(std::numeric_limits<TypeParam>::min(),
46                       TypeParam(1)),           
47        std::numeric_limits<TypeParam>::min(),  
48        std::numeric_limits<TypeParam>::denorm_min(),  
49        std::numeric_limits<TypeParam>::min() / 2,
50        std::nextafter(std::numeric_limits<TypeParam>::min(),
51                       TypeParam(0)),  
52    };
53    constexpr int kCount = 1000;
54    absl::InsecureBitGen gen;
55    for (const auto mod : {0, 1, 2, 3}) {
56      for (const auto x : kParams) {
57        if (!std::isfinite(x)) continue;
58        for (const auto y : kParams) {
59          const TypeParam mean = (mod & 0x1) ? -x : x;
60          const TypeParam stddev = (mod & 0x2) ? -y : y;
61          const param_type param(mean, stddev);
62          absl::gaussian_distribution<TypeParam> before(mean, stddev);
63          EXPECT_EQ(before.mean(), param.mean());
64          EXPECT_EQ(before.stddev(), param.stddev());
65          {
66            absl::gaussian_distribution<TypeParam> via_param(param);
67            EXPECT_EQ(via_param, before);
68            EXPECT_EQ(via_param.param(), before.param());
69          }
70          auto sample_min = before.max();
71          auto sample_max = before.min();
72          for (int i = 0; i < kCount; i++) {
73            auto sample = before(gen);
74            if (sample > sample_max) sample_max = sample;
75            if (sample < sample_min) sample_min = sample;
76            EXPECT_GE(sample, before.min()) << before;
77            EXPECT_LE(sample, before.max()) << before;
78          }
79          if (!std::is_same<TypeParam, long double>::value) {
80            LOG(INFO) << "Range{" << mean << ", " << stddev << "}: " << sample_min
81                      << ", " << sample_max;
82          }
83          std::stringstream ss;
84          ss << before;
85          if (!std::isfinite(mean) || !std::isfinite(stddev)) {
86            continue;
87          }
88          absl::gaussian_distribution<TypeParam> after(-0.53f, 2.3456f);
89          EXPECT_NE(before.mean(), after.mean());
90          EXPECT_NE(before.stddev(), after.stddev());
91          EXPECT_NE(before.param(), after.param());
92          EXPECT_NE(before, after);
93          ss >> after;
94          EXPECT_EQ(before.mean(), after.mean());
95          EXPECT_EQ(before.stddev(), after.stddev())  
96              << ss.str() << " "                      
97              << (ss.good() ? "good " : "")           
98              << (ss.bad() ? "bad " : "")             
99              << (ss.eof() ? "eof " : "")             
100              << (ss.fail() ? "fail " : "");
101        }
102      }
103    }
104  }
105  class GaussianModel {
106   public:
107    GaussianModel(double mean, double stddev) : mean_(mean), stddev_(stddev) {}
108    double mean() const { return mean_; }
109    double variance() const { return stddev() * stddev(); }
110    double stddev() const { return stddev_; }
<span onclick='openModal()' class='match'>111    double skew() const { return 0; }
112    double kurtosis() const { return 3.0; }
</span>113    double InverseCDF(double p) {
114      ABSL_ASSERT(p >= 0.0);
115      ABSL_ASSERT(p < 1.0);
116      return mean() + stddev() * -absl::random_internal::InverseNormalSurvival(p);
117    }
118   private:
119    const double mean_;
120    const double stddev_;
121  };
122  struct Param {
123    double mean;
124    double stddev;
125    double p_fail;  
126    int trials;     
127  };
128  class GaussianDistributionTests : public testing::TestWithParam<Param>,
129                                    public GaussianModel {
130   public:
131    GaussianDistributionTests()
132        : GaussianModel(GetParam().mean, GetParam().stddev) {}
133    template <typename D>
134    bool SingleZTest(const double p, const size_t samples);
135    template <typename D>
136    double SingleChiSquaredTest();
137    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
138  };
139  template <typename D>
140  bool GaussianDistributionTests::SingleZTest(const double p,
141                                              const size_t samples) {
142    D dis(mean(), stddev());
143    std::vector<double> data;
144    data.reserve(samples);
145    for (size_t i = 0; i < samples; i++) {
146      const double x = dis(rng_);
147      data.push_back(x);
148    }
149    const double max_err = absl::random_internal::MaxErrorTolerance(p);
150    const auto m = absl::random_internal::ComputeDistributionMoments(data);
151    const double z = absl::random_internal::ZScore(mean(), m);
152    const bool pass = absl::random_internal::Near("z", z, 0.0, max_err);
153    const double jb =
154        static_cast<double>(m.n) / 6.0 *
155        (std::pow(m.skewness, 2.0) + std::pow(m.kurtosis - 3.0, 2.0) / 4.0);
156    if (!pass || jb > 9.21) {
157      LOG(INFO)
158          << "p=" << p << " max_err=" << max_err << "\n"
159             " mean=" << m.mean << " vs. " << mean() << "\n"
160             " stddev=" << std::sqrt(m.variance) << " vs. " << stddev() << "\n"
161             " skewness=" << m.skewness << " vs. " << skew() << "\n"
162             " kurtosis=" << m.kurtosis << " vs. " << kurtosis() << "\n"
163             " z=" << z << " vs. 0\n"
164             " jb=" << jb << " vs. 9.21";
165    }
166    return pass;
167  }
168  template <typename D>
169  double GaussianDistributionTests::SingleChiSquaredTest() {
170    const size_t kSamples = 10000;
171    const int kBuckets = 50;
172    std::vector<double> cutoffs;
173    const double kInc = 1.0 / static_cast<double>(kBuckets);
174    for (double p = kInc; p < 1.0; p += kInc) {
175      cutoffs.push_back(InverseCDF(p));
176    }
177    if (cutoffs.back() != std::numeric_limits<double>::infinity()) {
178      cutoffs.push_back(std::numeric_limits<double>::infinity());
179    }
180    D dis(mean(), stddev());
181    std::vector<int32_t> counts(cutoffs.size(), 0);
182    for (int j = 0; j < kSamples; j++) {
183      const double x = dis(rng_);
184      auto it = std::upper_bound(cutoffs.begin(), cutoffs.end(), x);
185      counts[std::distance(cutoffs.begin(), it)]++;
186    }
187    const int dof = static_cast<int>(counts.size()) - 1;
188    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.98);
189    const double expected =
190        static_cast<double>(kSamples) / static_cast<double>(counts.size());
191    double chi_square = absl::random_internal::ChiSquareWithExpected(
192        std::begin(counts), std::end(counts), expected);
193    double p = absl::random_internal::ChiSquarePValue(chi_square, dof);
194    if (chi_square > threshold) {
195      for (size_t i = 0; i < cutoffs.size(); i++) {
196        LOG(INFO) << i << " : (" << cutoffs[i] << ") = " << counts[i];
197      }
198      LOG(INFO) << "mean=" << mean() << " stddev=" << stddev() << "\n"
199                   " expected " << expected << "\n"
200                << kChiSquared << " " << chi_square << " (" << p << ")\n"
201                << kChiSquared << " @ 0.98 = " << threshold;
202    }
203    return p;
204  }
205  TEST_P(GaussianDistributionTests, ZTest) {
206    const size_t kSamples = 10000;
207    const auto& param = GetParam();
208    const int expected_failures =
209        std::max(1, static_cast<int>(std::ceil(param.trials * param.p_fail)));
210    const double p = absl::random_internal::RequiredSuccessProbability(
211        param.p_fail, param.trials);
212    int failures = 0;
213    for (int i = 0; i < param.trials; i++) {
214      failures +=
215          SingleZTest<absl::gaussian_distribution<double>>(p, kSamples) ? 0 : 1;
216    }
217    EXPECT_LE(failures, expected_failures);
218  }
219  TEST_P(GaussianDistributionTests, ChiSquaredTest) {
220    const int kTrials = 20;
221    int failures = 0;
222    for (int i = 0; i < kTrials; i++) {
223      double p_value =
224          SingleChiSquaredTest<absl::gaussian_distribution<double>>();
225      if (p_value < 0.0025) {  
226        failures++;
227      }
228    }
229    EXPECT_LE(failures, 4);
230  }
231  std::vector<Param> GenParams() {
232    return {
233        Param{0.0, 1.0, 0.01, 100},
234        Param{0.0, 1e2, 0.01, 100},
235        Param{0.0, 1e4, 0.01, 100},
236        Param{0.0, 1e8, 0.01, 100},
237        Param{0.0, 1e16, 0.01, 100},
238        Param{0.0, 1e-3, 0.01, 100},
239        Param{0.0, 1e-5, 0.01, 100},
240        Param{0.0, 1e-9, 0.01, 100},
241        Param{0.0, 1e-17, 0.01, 100},
242        Param{1.0, 1.0, 0.01, 100},
243        Param{1.0, 1e2, 0.01, 100},
244        Param{1.0, 1e-2, 0.01, 100},
245        Param{1e2, 1.0, 0.01, 100},
246        Param{-1e2, 1.0, 0.01, 100},
247        Param{1e2, 1e6, 0.01, 100},
248        Param{-1e2, 1e6, 0.01, 100},
249        Param{1e4, 1e4, 0.01, 100},
250        Param{1e8, 1e4, 0.01, 100},
251        Param{1e12, 1e4, 0.01, 100},
252    };
253  }
254  std::string ParamName(const ::testing::TestParamInfo<Param>& info) {
255    const auto& p = info.param;
256    std::string name = absl::StrCat("mean_", absl::SixDigits(p.mean), "__stddev_",
257                                    absl::SixDigits(p.stddev));
258    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
259  }
260  INSTANTIATE_TEST_SUITE_P(All, GaussianDistributionTests,
261                           ::testing::ValuesIn(GenParams()), ParamName);
262  TEST(GaussianDistributionTest, StabilityTest) {
263    absl::random_internal::sequence_urbg urbg(
264        {0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
265         0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
266         0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
267         0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull});
268    std::vector<int> output(11);
269    {
270      absl::gaussian_distribution<double> dist;
271      std::generate(std::begin(output), std::end(output),
272                    [&] { return static_cast<int>(10000000.0 * dist(urbg)); });
273      EXPECT_EQ(13, urbg.invocations());
274      EXPECT_THAT(output,  
275                  testing::ElementsAre(1494, 25518841, 9991550, 1351856,
276                                       -20373238, 3456682, 333530, -6804981,
277                                       -15279580, -16459654, 1494));
278    }
279    urbg.reset();
280    {
281      absl::gaussian_distribution<float> dist;
282      std::generate(std::begin(output), std::end(output),
283                    [&] { return static_cast<int>(1000000.0f * dist(urbg)); });
284      EXPECT_EQ(13, urbg.invocations());
285      EXPECT_THAT(
286          output,  
287          testing::ElementsAre(149, 2551884, 999155, 135185, -2037323, 345668,
288                               33353, -680498, -1527958, -1645965, 149));
289    }
290  }
291  TEST(GaussianDistributionTest, AlgorithmBounds) {
292    absl::gaussian_distribution<double> dist;
293    const uint64_t kValues[] = {
294        0x1000000000000100ull, 0x2000000000000100ull, 0x3000000000000100ull,
295        0x4000000000000100ull, 0x5000000000000100ull, 0x6000000000000100ull,
296        0x9000000000000100ull, 0xa000000000000100ull, 0xb000000000000100ull,
297        0xc000000000000100ull, 0xd000000000000100ull, 0xe000000000000100ull};
298    const uint64_t kExtraValues[] = {
299        0x7000000000000100ull, 0x7800000000000100ull,  
300        0x7c00000000000100ull, 0x7e00000000000100ull,  
301        0xf000000000000100ull, 0xf800000000000100ull,  
302        0xfc00000000000100ull, 0xfe00000000000100ull};
303    auto make_box = [](uint64_t v, uint64_t box) {
304      return (v & 0xffffffffffffff80ull) | box;
305    };
306    for (uint64_t box = 0; box < 0x7f; box++) {
307      for (const uint64_t v : kValues) {
308        absl::random_internal::sequence_urbg urbg(
309            {make_box(v, box), 0x0003eb76f6f7f755ull, 0x5FCEA50FDB2F953Bull});
310        auto a = dist(urbg);
311        EXPECT_EQ(1, urbg.invocations()) << box << " " << std::hex << v;
312        if (v & 0x8000000000000000ull) {
313          EXPECT_LT(a, 0.0) << box << " " << std::hex << v;
314        } else {
315          EXPECT_GT(a, 0.0) << box << " " << std::hex << v;
316        }
317      }
318      if (box > 10 && box < 100) {
319        for (const uint64_t v : kExtraValues) {
320          absl::random_internal::sequence_urbg urbg(
321              {make_box(v, box), 0x0003eb76f6f7f755ull, 0x5FCEA50FDB2F953Bull});
322          auto a = dist(urbg);
323          EXPECT_EQ(1, urbg.invocations()) << box << " " << std::hex << v;
324          if (v & 0x8000000000000000ull) {
325            EXPECT_LT(a, 0.0) << box << " " << std::hex << v;
326          } else {
327            EXPECT_GT(a, 0.0) << box << " " << std::hex << v;
328          }
329        }
330      }
331    }
332    auto make_fallback = [](uint64_t v) { return (v & 0xffffffffffffff80ull); };
333    double tail[2];
334    {
335      absl::random_internal::sequence_urbg urbg(
336          {make_fallback(0x7800000000000000ull), 0x13CCA830EB61BD96ull,
337           0x00000076f6f7f755ull});
338      tail[0] = dist(urbg);
339      EXPECT_EQ(3, urbg.invocations());
340      EXPECT_GT(tail[0], 0);
341    }
342    {
343      absl::random_internal::sequence_urbg urbg(
344          {make_fallback(0xf800000000000000ull), 0x13CCA830EB61BD96ull,
345           0x00000076f6f7f755ull});
346      tail[1] = dist(urbg);
347      EXPECT_EQ(3, urbg.invocations());
348      EXPECT_LT(tail[1], 0);
349    }
350    EXPECT_EQ(tail[0], -tail[1]);
351    EXPECT_EQ(418610, static_cast<int64_t>(tail[0] * 100000.0));
352    {
353      absl::random_internal::sequence_urbg urbg(
354          {make_box(0x7f00000000000000ull, 120), 0xe000000000000001ull,
355           0x13CCA830EB61BD96ull});
356      tail[0] = dist(urbg);
357      EXPECT_EQ(2, urbg.invocations());
358      EXPECT_GT(tail[0], 0);
359    }
360    {
361      absl::random_internal::sequence_urbg urbg(
362          {make_box(0xff00000000000000ull, 120), 0xe000000000000001ull,
363           0x13CCA830EB61BD96ull});
364      tail[1] = dist(urbg);
365      EXPECT_EQ(2, urbg.invocations());
366      EXPECT_LT(tail[1], 0);
367    }
368    EXPECT_EQ(tail[0], -tail[1]);
369    EXPECT_EQ(61948, static_cast<int64_t>(tail[0] * 100000.0));
370    {
371      absl::random_internal::sequence_urbg urbg(
372          {make_box(0xff00000000000000ull, 120), 0x1000000000000001,
373           make_box(0x1000000000000100ull, 50), 0x13CCA830EB61BD96ull});
374      dist(urbg);
375      EXPECT_EQ(3, urbg.invocations());
376    }
377  }
378  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dzs.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-gaussian_distribution_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>34    TStr GetDataStr() const {return DataStr;}
35    int GetYearN() const {return YearN;}
</pre></code></div>
                <div class="column column_space"><pre><code>111    double skew() const { return 0; }
112    double kurtosis() const { return 3.0; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    