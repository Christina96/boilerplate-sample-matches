
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</h3>
            <pre><code>1  #include "time_zone_info.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <chrono>
5  #include <cstdint>
6  #include <cstdio>
7  #include <cstdlib>
8  #include <cstring>
9  #include <fstream>
10  #include <functional>
11  #include <memory>
12  #include <sstream>
13  #include <string>
14  #include <utility>
15  #include "absl/base/config.h"
16  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
17  #include "time_zone_fixed.h"
18  #include "time_zone_posix.h"
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace time_internal {
22  namespace cctz {
23  namespace {
24  inline bool IsLeap(year_t year) {
25    return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
26  }
27  const std::int_least32_t kDaysPerYear[2] = {365, 366};
28  const std::int_least16_t kMonthOffsets[2][1 + 12 + 1] = {
29      {-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
30      {-1, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366},
31  };
32  const std::int_least32_t kSecsPerDay = 24 * 60 * 60;
33  const std::int_least64_t kSecsPer400Years = 146097LL * kSecsPerDay;
34  const std::int_least32_t kSecsPerYear[2] = {
35      365 * kSecsPerDay,
36      366 * kSecsPerDay,
37  };
38  inline int ToPosixWeekday(weekday wd) {
39    switch (wd) {
40      case weekday::sunday:
41        return 0;
42      case weekday::monday:
43        return 1;
44      case weekday::tuesday:
45        return 2;
46      case weekday::wednesday:
47        return 3;
48      case weekday::thursday:
49        return 4;
50      case weekday::friday:
51        return 5;
52      case weekday::saturday:
53        return 6;
54    }
55    return 0; &bsol;*NOTREACHED*/
56  }
57  inline std::uint_fast8_t Decode8(const char* cp) {
58    return static_cast<std::uint_fast8_t>(*cp) & 0xff;
59  }
60  std::int_fast32_t Decode32(const char* cp) {
61    std::uint_fast32_t v = 0;
62    for (int i = 0; i != (32 / 8); ++i) v = (v << 8) | Decode8(cp++);
63    const std::int_fast32_t s32max = 0x7fffffff;
64    const auto s32maxU = static_cast<std::uint_fast32_t>(s32max);
65    if (v <= s32maxU) return static_cast<std::int_fast32_t>(v);
66    return static_cast<std::int_fast32_t>(v - s32maxU - 1) - s32max - 1;
67  }
68  std::int_fast64_t Decode64(const char* cp) {
69    std::uint_fast64_t v = 0;
70    for (int i = 0; i != (64 / 8); ++i) v = (v << 8) | Decode8(cp++);
71    const std::int_fast64_t s64max = 0x7fffffffffffffff;
72    const auto s64maxU = static_cast<std::uint_fast64_t>(s64max);
73    if (v <= s64maxU) return static_cast<std::int_fast64_t>(v);
74    return static_cast<std::int_fast64_t>(v - s64maxU - 1) - s64max - 1;
75  }
76  struct Header {            
77    std::size_t timecnt;     
78    std::size_t typecnt;     
79    std::size_t charcnt;     
80    std::size_t leapcnt;     
81    std::size_t ttisstdcnt;  
82    std::size_t ttisutcnt;   
83    bool Build(const tzhead& tzh);
84    std::size_t DataLength(std::size_t time_len) const;
85  };
86  bool Header::Build(const tzhead& tzh) {
87    std::int_fast32_t v;
88    if ((v = Decode32(tzh.tzh_timecnt)) < 0) return false;
89    timecnt = static_cast<std::size_t>(v);
90    if ((v = Decode32(tzh.tzh_typecnt)) < 0) return false;
91    typecnt = static_cast<std::size_t>(v);
92    if ((v = Decode32(tzh.tzh_charcnt)) < 0) return false;
93    charcnt = static_cast<std::size_t>(v);
94    if ((v = Decode32(tzh.tzh_leapcnt)) < 0) return false;
95    leapcnt = static_cast<std::size_t>(v);
96    if ((v = Decode32(tzh.tzh_ttisstdcnt)) < 0) return false;
97    ttisstdcnt = static_cast<std::size_t>(v);
98    if ((v = Decode32(tzh.tzh_ttisutcnt)) < 0) return false;
99    ttisutcnt = static_cast<std::size_t>(v);
100    return true;
101  }
102  std::size_t Header::DataLength(std::size_t time_len) const {
103    std::size_t len = 0;
104    len += (time_len + 1) * timecnt;  
105    len += (4 + 1 + 1) * typecnt;     
106    len += 1 * charcnt;               
107    len += (time_len + 4) * leapcnt;  
108    len += 1 * ttisstdcnt;            
109    len += 1 * ttisutcnt;             
110    return len;
111  }
112  bool AllYearDST(const PosixTimeZone& posix) {
113    if (posix.dst_start.date.fmt != PosixTransition::N) return false;
114    if (posix.dst_start.date.n.day != 0) return false;
115    if (posix.dst_start.time.offset != 0) return false;
116    if (posix.dst_end.date.fmt != PosixTransition::J) return false;
117    if (posix.dst_end.date.j.day != kDaysPerYear[0]) return false;
118    const auto offset = posix.std_offset - posix.dst_offset;
119    if (posix.dst_end.time.offset + offset != kSecsPerDay) return false;
120    return true;
121  }
122  std::int_fast64_t TransOffset(bool leap_year, int jan1_weekday,
123                                const PosixTransition& pt) {
124    std::int_fast64_t days = 0;
125    switch (pt.date.fmt) {
126      case PosixTransition::J: {
127        days = pt.date.j.day;
128        if (!leap_year || days < kMonthOffsets[1][3]) days -= 1;
129        break;
130      }
131      case PosixTransition::N: {
132        days = pt.date.n.day;
133        break;
134      }
135      case PosixTransition::M: {
136        const bool last_week = (pt.date.m.week == 5);
137        days = kMonthOffsets[leap_year][pt.date.m.month + last_week];
138        const std::int_fast64_t weekday = (jan1_weekday + days) % 7;
139        if (last_week) {
140          days -= (weekday + 7 - 1 - pt.date.m.weekday) % 7 + 1;
141        } else {
142          days += (pt.date.m.weekday + 7 - weekday) % 7;
143          days += (pt.date.m.week - 1) * 7;
144        }
145        break;
146      }
147    }
148    return (days * kSecsPerDay) + pt.time.offset;
149  }
150  inline time_zone::civil_lookup MakeUnique(const time_point<seconds>& tp) {
151    time_zone::civil_lookup cl;
152    cl.kind = time_zone::civil_lookup::UNIQUE;
153    cl.pre = cl.trans = cl.post = tp;
154    return cl;
155  }
156  inline time_zone::civil_lookup MakeUnique(std::int_fast64_t unix_time) {
157    return MakeUnique(FromUnixSeconds(unix_time));
158  }
159  inline time_zone::civil_lookup MakeSkipped(const Transition& tr,
160                                             const civil_second& cs) {
161    time_zone::civil_lookup cl;
162    cl.kind = time_zone::civil_lookup::SKIPPED;
163    cl.pre = FromUnixSeconds(tr.unix_time - 1 + (cs - tr.prev_civil_sec));
164    cl.trans = FromUnixSeconds(tr.unix_time);
165    cl.post = FromUnixSeconds(tr.unix_time - (tr.civil_sec - cs));
166    return cl;
167  }
168  inline time_zone::civil_lookup MakeRepeated(const Transition& tr,
169                                              const civil_second& cs) {
170    time_zone::civil_lookup cl;
171    cl.kind = time_zone::civil_lookup::REPEATED;
172    cl.pre = FromUnixSeconds(tr.unix_time - 1 - (tr.prev_civil_sec - cs));
173    cl.trans = FromUnixSeconds(tr.unix_time);
174    cl.post = FromUnixSeconds(tr.unix_time + (cs - tr.civil_sec));
175    return cl;
176  }
177  inline civil_second YearShift(const civil_second& cs, year_t shift) {
178    return civil_second(cs.year() + shift, cs.month(), cs.day(), cs.hour(),
179                        cs.minute(), cs.second());
180  }
181  }  
182  bool TimeZoneInfo::GetTransitionType(std::int_fast32_t utc_offset, bool is_dst,
183                                       const std::string& abbr,
184                                       std::uint_least8_t* index) {
185    std::size_t type_index = 0;
186    std::size_t abbr_index = abbreviations_.size();
187    for (; type_index != transition_types_.size(); ++type_index) {
188      const TransitionType& tt(transition_types_[type_index]);
189      const char* tt_abbr = &abbreviations_[tt.abbr_index];
190      if (tt_abbr == abbr) abbr_index = tt.abbr_index;
191      if (tt.utc_offset == utc_offset && tt.is_dst == is_dst) {
192        if (abbr_index == tt.abbr_index) break;  
193      }
194    }
195    if (type_index > 255 || abbr_index > 255) {
196      return false;
197    }
198    if (type_index == transition_types_.size()) {
199      TransitionType& tt(*transition_types_.emplace(transition_types_.end()));
200      tt.utc_offset = static_cast<std::int_least32_t>(utc_offset);
201      tt.is_dst = is_dst;
202      if (abbr_index == abbreviations_.size()) {
203        abbreviations_.append(abbr);
204        abbreviations_.append(1, '\0');
205      }
206      tt.abbr_index = static_cast<std::uint_least8_t>(abbr_index);
207    }
208    *index = static_cast<std::uint_least8_t>(type_index);
209    return true;
210  }
211  bool TimeZoneInfo::EquivTransitions(std::uint_fast8_t tt1_index,
212                                      std::uint_fast8_t tt2_index) const {
213    if (tt1_index == tt2_index) return true;
214    const TransitionType& tt1(transition_types_[tt1_index]);
215    const TransitionType& tt2(transition_types_[tt2_index]);
216    if (tt1.utc_offset != tt2.utc_offset) return false;
217    if (tt1.is_dst != tt2.is_dst) return false;
218    if (tt1.abbr_index != tt2.abbr_index) return false;
219    return true;
220  }
221  bool TimeZoneInfo::ExtendTransitions() {
222    extended_ = false;
223    if (future_spec_.empty()) return true;  
224    PosixTimeZone posix;
225    if (!ParsePosixSpec(future_spec_, &posix)) return false;
226    std::uint_least8_t std_ti;
227    if (!GetTransitionType(posix.std_offset, false, posix.std_abbr, &std_ti))
228      return false;
229    if (posix.dst_abbr.empty()) {  
230      return EquivTransitions(transitions_.back().type_index, std_ti);
231    }
232    std::uint_least8_t dst_ti;
233    if (!GetTransitionType(posix.dst_offset, true, posix.dst_abbr, &dst_ti))
234      return false;
235    if (AllYearDST(posix)) {  
236      return EquivTransitions(transitions_.back().type_index, dst_ti);
237    }
238    transitions_.reserve(transitions_.size() + 400 * 2 + 2);
239    extended_ = true;
240    const Transition& last(transitions_.back());
241    const std::int_fast64_t last_time = last.unix_time;
242    const TransitionType& last_tt(transition_types_[last.type_index]);
243    last_year_ = LocalTime(last_time, last_tt).cs.year();
244    bool leap_year = IsLeap(last_year_);
245    const civil_second jan1(last_year_);
246    std::int_fast64_t jan1_time = jan1 - civil_second();
247    int jan1_weekday = ToPosixWeekday(get_weekday(jan1));
248    Transition dst = {0, dst_ti, civil_second(), civil_second()};
249    Transition std = {0, std_ti, civil_second(), civil_second()};
250    for (const year_t limit = last_year_ + 400;; ++last_year_) {
251      auto dst_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_start);
252      auto std_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_end);
253      dst.unix_time = jan1_time + dst_trans_off - posix.std_offset;
254      std.unix_time = jan1_time + std_trans_off - posix.dst_offset;
255      const auto* ta = dst.unix_time < std.unix_time ? &dst : &std;
256      const auto* tb = dst.unix_time < std.unix_time ? &std : &dst;
257      if (last_time < tb->unix_time) {
258        if (last_time < ta->unix_time) transitions_.push_back(*ta);
259        transitions_.push_back(*tb);
260      }
261      if (last_year_ == limit) break;
262      jan1_time += kSecsPerYear[leap_year];
263      jan1_weekday = (jan1_weekday + kDaysPerYear[leap_year]) % 7;
264      leap_year = !leap_year && IsLeap(last_year_ + 1);
265    }
266    return true;
267  }
268  namespace {
269  using FilePtr = std::unique_ptr<FILE, int (*)(FILE*)>;
270  inline FilePtr FOpen(const char* path, const char* mode) {
271  #if defined(_MSC_VER)
272    FILE* fp;
273    if (fopen_s(&fp, path, mode) != 0) fp = nullptr;
274    return FilePtr(fp, fclose);
275  #else
276    return FilePtr(fopen(path, mode), fclose);
277  #endif
278  }
279  class FileZoneInfoSource : public ZoneInfoSource {
280   public:
281    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
282    std::size_t Read(void* ptr, std::size_t size) override {
283      size = std::min(size, len_);
284      std::size_t nread = fread(ptr, 1, size, fp_.get());
285      len_ -= nread;
286      return nread;
287    }
288    int Skip(std::size_t offset) override {
289      offset = std::min(offset, len_);
290      int rc = fseek(fp_.get(), static_cast<long>(offset), SEEK_CUR);
291      if (rc == 0) len_ -= offset;
292      return rc;
293    }
294    std::string Version() const override {
295      return std::string();
296    }
297   protected:
298    explicit FileZoneInfoSource(
299        FilePtr fp, std::size_t len = std::numeric_limits<std::size_t>::max())
300        : fp_(std::move(fp)), len_(len) {}
301   private:
302    FilePtr fp_;
303    std::size_t len_;
304  };
305  std::unique_ptr<ZoneInfoSource> FileZoneInfoSource::Open(
306      const std::string& name) {
307    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
308    std::string path;
309    if (pos == name.size() || name[pos] != '/') {
310      const char* tzdir = "/usr/share/zoneinfo";
311      char* tzdir_env = nullptr;
312  #if defined(_MSC_VER)
313      _dupenv_s(&tzdir_env, nullptr, "TZDIR");
314  #else
315      tzdir_env = std::getenv("TZDIR");
316  #endif
317      if (tzdir_env && *tzdir_env) tzdir = tzdir_env;
318      path += tzdir;
319      path += '/';
320  #if defined(_MSC_VER)
321      free(tzdir_env);
322  #endif
323    }
324    path.append(name, pos, std::string::npos);
325    auto fp = FOpen(path.c_str(), "rb");
326    if (fp == nullptr) return nullptr;
327    return std::unique_ptr<ZoneInfoSource>(new FileZoneInfoSource(std::move(fp)));
328  }
329  class AndroidZoneInfoSource : public FileZoneInfoSource {
330   public:
331    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
332    std::string Version() const override { return version_; }
333   private:
334    explicit AndroidZoneInfoSource(FilePtr fp, std::size_t len,
335                                   std::string version)
336        : FileZoneInfoSource(std::move(fp), len), version_(std::move(version)) {}
337    std::string version_;
338  };
339  std::unique_ptr<ZoneInfoSource> AndroidZoneInfoSource::Open(
340      const std::string& name) {
341    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
342    for (const char* tzdata : {"/data/misc/zoneinfo/current/tzdata",
343                               "/system/usr/share/zoneinfo/tzdata"}) {
344      auto fp = FOpen(tzdata, "rb");
345      if (fp == nullptr) continue;
346      char hbuf[24];  
347      if (fread(hbuf, 1, sizeof(hbuf), fp.get()) != sizeof(hbuf)) continue;
348      if (strncmp(hbuf, "tzdata", 6) != 0) continue;
349      const char* vers = (hbuf[11] == '\0') ? hbuf + 6 : "";
350      const std::int_fast32_t index_offset = Decode32(hbuf + 12);
351      const std::int_fast32_t data_offset = Decode32(hbuf + 16);
352      if (index_offset < 0 || data_offset < index_offset) continue;
353      if (fseek(fp.get(), static_cast<long>(index_offset), SEEK_SET) != 0)
354        continue;
355      char ebuf[52];  
356      const std::size_t index_size =
357          static_cast<std::size_t>(data_offset - index_offset);
358      const std::size_t zonecnt = index_size / sizeof(ebuf);
359      if (zonecnt * sizeof(ebuf) != index_size) continue;
360      for (std::size_t i = 0; i != zonecnt; ++i) {
361        if (fread(ebuf, 1, sizeof(ebuf), fp.get()) != sizeof(ebuf)) break;
362        const std::int_fast32_t start = data_offset + Decode32(ebuf + 40);
363        const std::int_fast32_t length = Decode32(ebuf + 44);
364        if (start < 0 || length < 0) break;
365        ebuf[40] = '\0';  
366        if (strcmp(name.c_str() + pos, ebuf) == 0) {
367          if (fseek(fp.get(), static_cast<long>(start), SEEK_SET) != 0) break;
368          return std::unique_ptr<ZoneInfoSource>(new AndroidZoneInfoSource(
369              std::move(fp), static_cast<std::size_t>(length), vers));
370        }
371      }
372    }
373    return nullptr;
374  }
375  class FuchsiaZoneInfoSource : public FileZoneInfoSource {
376   public:
377    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
378    std::string Version() const override { return version_; }
379   private:
380    explicit FuchsiaZoneInfoSource(FilePtr fp, std::string version)
381        : FileZoneInfoSource(std::move(fp)), version_(std::move(version)) {}
382    std::string version_;
383  };
384  std::unique_ptr<ZoneInfoSource> FuchsiaZoneInfoSource::Open(
385      const std::string& name) {
386    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
387    const auto kTzdataPrefixes = {
388        "/config/data/tzdata/",
389        "/pkg/data/tzdata/",
390        "/data/tzdata/",
391    };
392    const auto kEmptyPrefix = {""};
393    const bool name_absolute = (pos != name.size() && name[pos] == '/');
394    const auto prefixes = name_absolute ? kEmptyPrefix : kTzdataPrefixes;
395    for (const std::string prefix : prefixes) {
396      std::string path = prefix;
397      if (!prefix.empty()) path += "zoneinfo/tzif2/";  
398      path.append(name, pos, std::string::npos);
399      auto fp = FOpen(path.c_str(), "rb");
400      if (fp == nullptr) continue;
401      std::string version;
402      if (!prefix.empty()) {
403        std::ifstream version_stream(prefix + "revision.txt");
404        if (version_stream.is_open()) {
405          std::getline(version_stream, version);
406        }
407      }
408      return std::unique_ptr<ZoneInfoSource>(
409          new FuchsiaZoneInfoSource(std::move(fp), std::move(version)));
410    }
411    return nullptr;
412  }
413  }  
414  bool TimeZoneInfo::ResetToBuiltinUTC(const seconds& offset) {
415    transition_types_.resize(1);
416    TransitionType& tt(transition_types_.back());
417    tt.utc_offset = static_cast<std::int_least32_t>(offset.count());
418    tt.is_dst = false;
419    tt.abbr_index = 0;
420    transitions_.clear();
421    transitions_.reserve(12);
422    for (const std::int_fast64_t unix_time : {
423             -(1LL << 59),  
424             1420070400LL,  
425             1451606400LL,  
426             1483228800LL,  
427             1514764800LL,  
428             1546300800LL,  
429             1577836800LL,  
430             1609459200LL,  
431             1640995200LL,  
432             1672531200LL,  
433             1704067200LL,  
434             1735689600LL,  
435         }) {
436      Transition& tr(*transitions_.emplace(transitions_.end()));
437      tr.unix_time = unix_time;
438      tr.type_index = 0;
439      tr.civil_sec = LocalTime(tr.unix_time, tt).cs;
440      tr.prev_civil_sec = tr.civil_sec - 1;
441    }
442    default_transition_type_ = 0;
443    abbreviations_ = FixedOffsetToAbbr(offset);
444    abbreviations_.append(1, '\0');
445    future_spec_.clear();  
446    extended_ = false;
447    tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
448    tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
449    transitions_.shrink_to_fit();
450    return true;
451  }
452  bool TimeZoneInfo::Load(ZoneInfoSource* zip) {
453    tzhead tzh;
454    if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
455    if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
456      return false;
457    Header hdr;
458    if (!hdr.Build(tzh)) return false;
459    std::size_t time_len = 4;
460    if (tzh.tzh_version[0] != '\0') {
461      if (zip->Skip(hdr.DataLength(time_len)) != 0) return false;
462      if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
463      if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
464        return false;
465      if (tzh.tzh_version[0] == '\0') return false;
466      if (!hdr.Build(tzh)) return false;
467      time_len = 8;
468    }
469    if (hdr.typecnt == 0) return false;
470    if (hdr.leapcnt != 0) {
471      return false;
472    }
473    if (hdr.ttisstdcnt != 0 && hdr.ttisstdcnt != hdr.typecnt) return false;
474    if (hdr.ttisutcnt != 0 && hdr.ttisutcnt != hdr.typecnt) return false;
475    std::size_t len = hdr.DataLength(time_len);
476    std::vector<char> tbuf(len);
477    if (zip->Read(tbuf.data(), len) != len) return false;
478    const char* bp = tbuf.data();
479    transitions_.reserve(hdr.timecnt + 2);
480    transitions_.resize(hdr.timecnt);
481    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
482      transitions_[i].unix_time = (time_len == 4) ? Decode32(bp) : Decode64(bp);
483      bp += time_len;
484      if (i != 0) {
485        if (!Transition::ByUnixTime()(transitions_[i - 1], transitions_[i]))
486          return false;  
487      }
488    }
489    bool seen_type_0 = false;
490    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
491      transitions_[i].type_index = Decode8(bp++);
492      if (transitions_[i].type_index >= hdr.typecnt) return false;
493      if (transitions_[i].type_index == 0) seen_type_0 = true;
494    }
495    transition_types_.reserve(hdr.typecnt + 2);
496    transition_types_.resize(hdr.typecnt);
497    for (std::size_t i = 0; i != hdr.typecnt; ++i) {
498      transition_types_[i].utc_offset =
499          static_cast<std::int_least32_t>(Decode32(bp));
500      if (transition_types_[i].utc_offset >= kSecsPerDay ||
501          transition_types_[i].utc_offset <= -kSecsPerDay)
502        return false;
503      bp += 4;
504      transition_types_[i].is_dst = (Decode8(bp++) != 0);
505      transition_types_[i].abbr_index = Decode8(bp++);
506      if (transition_types_[i].abbr_index >= hdr.charcnt) return false;
507    }
508    default_transition_type_ = 0;
509    if (seen_type_0 && hdr.timecnt != 0) {
510      std::uint_fast8_t index = 0;
511      if (transition_types_[0].is_dst) {
512        index = transitions_[0].type_index;
513        while (index != 0 && transition_types_[index].is_dst) --index;
514      }
515      while (index != hdr.typecnt && transition_types_[index].is_dst) ++index;
516      if (index != hdr.typecnt) default_transition_type_ = index;
517    }
518    abbreviations_.reserve(hdr.charcnt + 10);
519    abbreviations_.assign(bp, hdr.charcnt);
520    bp += hdr.charcnt;
521    bp += (time_len + 4) * hdr.leapcnt;  
522    bp += 1 * hdr.ttisstdcnt;            
523    bp += 1 * hdr.ttisutcnt;             
524    assert(bp == tbuf.data() + tbuf.size());
525    future_spec_.clear();
526    if (tzh.tzh_version[0] != '\0') {
527      auto get_char = [](ZoneInfoSource* azip) -> int {
528        unsigned char ch;  
529        return (azip->Read(&ch, 1) == 1) ? ch : EOF;
530      };
531      if (get_char(zip) != '\n') return false;
532      for (int c = get_char(zip); c != '\n'; c = get_char(zip)) {
533        if (c == EOF) return false;
<span onclick='openModal()' class='match'>534        future_spec_.push_back(static_cast<char>(c));
535      }
536    }
</span>537    if (version_.empty()) {
538      version_ = zip->Version();
539    }
540    while (hdr.timecnt > 1) {
541      if (!EquivTransitions(transitions_[hdr.timecnt - 1].type_index,
542                            transitions_[hdr.timecnt - 2].type_index)) {
543        break;
544      }
545      hdr.timecnt -= 1;
546    }
547    transitions_.resize(hdr.timecnt);
548    if (transitions_.empty() || transitions_.front().unix_time >= 0) {
549      Transition& tr(*transitions_.emplace(transitions_.begin()));
550      tr.unix_time = -(1LL << 59);  
551      tr.type_index = default_transition_type_;
552    }
553    if (!ExtendTransitions()) return false;
554    const Transition& last(transitions_.back());
555    if (last.unix_time < 0) {
556      const std::uint_fast8_t type_index = last.type_index;
557      Transition& tr(*transitions_.emplace(transitions_.end()));
558      tr.unix_time = 2147483647;  
559      tr.type_index = type_index;
560    }
561    const TransitionType* ttp = &transition_types_[default_transition_type_];
562    for (std::size_t i = 0; i != transitions_.size(); ++i) {
563      Transition& tr(transitions_[i]);
564      tr.prev_civil_sec = LocalTime(tr.unix_time, *ttp).cs - 1;
565      ttp = &transition_types_[tr.type_index];
566      tr.civil_sec = LocalTime(tr.unix_time, *ttp).cs;
567      if (i != 0) {
568        if (!Transition::ByCivilTime()(transitions_[i - 1], tr))
569          return false;  
570      }
571    }
572    for (auto& tt : transition_types_) {
573      tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
574      tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
575    }
576    transitions_.shrink_to_fit();
577    return true;
578  }
579  bool TimeZoneInfo::Load(const std::string& name) {
580    auto offset = seconds::zero();
581    if (FixedOffsetFromName(name, &offset)) {
582      return ResetToBuiltinUTC(offset);
583    }
584    auto zip = cctz_extension::zone_info_source_factory(
585        name, [](const std::string& n) -> std::unique_ptr<ZoneInfoSource> {
586          if (auto z = FileZoneInfoSource::Open(n)) return z;
587          if (auto z = AndroidZoneInfoSource::Open(n)) return z;
588          if (auto z = FuchsiaZoneInfoSource::Open(n)) return z;
589          return nullptr;
590        });
591    return zip != nullptr && Load(zip.get());
592  }
593  std::unique_ptr<TimeZoneInfo> TimeZoneInfo::UTC() {
594    auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
595    tz->ResetToBuiltinUTC(seconds::zero());
596    return tz;
597  }
598  std::unique_ptr<TimeZoneInfo> TimeZoneInfo::Make(const std::string& name) {
599    auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
600    if (!tz->Load(name)) tz.reset();  
601    return tz;
602  }
603  time_zone::absolute_lookup TimeZoneInfo::LocalTime(
604      std::int_fast64_t unix_time, const TransitionType& tt) const {
605    return {(civil_second() + unix_time) + tt.utc_offset, tt.utc_offset,
606            tt.is_dst, &abbreviations_[tt.abbr_index]};
607  }
608  time_zone::absolute_lookup TimeZoneInfo::LocalTime(std::int_fast64_t unix_time,
609                                                     const Transition& tr) const {
610    const TransitionType& tt = transition_types_[tr.type_index];
611    return {tr.civil_sec + (unix_time - tr.unix_time),  
612            tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
613  }
614  time_zone::civil_lookup TimeZoneInfo::TimeLocal(const civil_second& cs,
615                                                  year_t c4_shift) const {
616    assert(last_year_ - 400 < cs.year() && cs.year() <= last_year_);
617    time_zone::civil_lookup cl = MakeTime(cs);
618    if (c4_shift > seconds::max().count() / kSecsPer400Years) {
619      cl.pre = cl.trans = cl.post = time_point<seconds>::max();
620    } else {
621      const auto offset = seconds(c4_shift * kSecsPer400Years);
622      const auto limit = time_point<seconds>::max() - offset;
623      for (auto* tp : {&cl.pre, &cl.trans, &cl.post}) {
624        if (*tp > limit) {
625          *tp = time_point<seconds>::max();
626        } else {
627          *tp += offset;
628        }
629      }
630    }
631    return cl;
632  }
633  time_zone::absolute_lookup TimeZoneInfo::BreakTime(
634      const time_point<seconds>& tp) const {
635    std::int_fast64_t unix_time = ToUnixSeconds(tp);
636    const std::size_t timecnt = transitions_.size();
637    assert(timecnt != 0);  
638    if (unix_time < transitions_[0].unix_time) {
639      return LocalTime(unix_time, transition_types_[default_transition_type_]);
640    }
641    if (unix_time >= transitions_[timecnt - 1].unix_time) {
642      if (extended_) {
643        const std::int_fast64_t diff =
644            unix_time - transitions_[timecnt - 1].unix_time;
645        const year_t shift = diff / kSecsPer400Years + 1;
646        const auto d = seconds(shift * kSecsPer400Years);
647        time_zone::absolute_lookup al = BreakTime(tp - d);
648        al.cs = YearShift(al.cs, shift * 400);
649        return al;
650      }
651      return LocalTime(unix_time, transitions_[timecnt - 1]);
652    }
653    const std::size_t hint = local_time_hint_.load(std::memory_order_relaxed);
654    if (0 < hint && hint < timecnt) {
655      if (transitions_[hint - 1].unix_time <= unix_time) {
656        if (unix_time < transitions_[hint].unix_time) {
657          return LocalTime(unix_time, transitions_[hint - 1]);
658        }
659      }
660    }
661    const Transition target = {unix_time, 0, civil_second(), civil_second()};
662    const Transition* begin = &transitions_[0];
663    const Transition* tr = std::upper_bound(begin, begin + timecnt, target,
664                                            Transition::ByUnixTime());
665    local_time_hint_.store(static_cast<std::size_t>(tr - begin),
666                           std::memory_order_relaxed);
667    return LocalTime(unix_time, *--tr);
668  }
669  time_zone::civil_lookup TimeZoneInfo::MakeTime(const civil_second& cs) const {
670    const std::size_t timecnt = transitions_.size();
671    assert(timecnt != 0);  
672    const Transition* tr = nullptr;
673    const Transition* begin = &transitions_[0];
674    const Transition* end = begin + timecnt;
675    if (cs < begin->civil_sec) {
676      tr = begin;
677    } else if (cs >= transitions_[timecnt - 1].civil_sec) {
678      tr = end;
679    } else {
680      const std::size_t hint = time_local_hint_.load(std::memory_order_relaxed);
681      if (0 < hint && hint < timecnt) {
682        if (transitions_[hint - 1].civil_sec <= cs) {
683          if (cs < transitions_[hint].civil_sec) {
684            tr = begin + hint;
685          }
686        }
687      }
688      if (tr == nullptr) {
689        const Transition target = {0, 0, cs, civil_second()};
690        tr = std::upper_bound(begin, end, target, Transition::ByCivilTime());
691        time_local_hint_.store(static_cast<std::size_t>(tr - begin),
692                               std::memory_order_relaxed);
693      }
694    }
695    if (tr == begin) {
696      if (tr->prev_civil_sec >= cs) {
697        const TransitionType& tt(transition_types_[default_transition_type_]);
698        if (cs < tt.civil_min) return MakeUnique(time_point<seconds>::min());
699        return MakeUnique(cs - (civil_second() + tt.utc_offset));
700      }
701      return MakeSkipped(*tr, cs);
702    }
703    if (tr == end) {
704      if (cs > (--tr)->prev_civil_sec) {
705        if (extended_ && cs.year() > last_year_) {
706          const year_t shift = (cs.year() - last_year_ - 1) / 400 + 1;
707          return TimeLocal(YearShift(cs, shift * -400), shift);
708        }
709        const TransitionType& tt(transition_types_[tr->type_index]);
710        if (cs > tt.civil_max) return MakeUnique(time_point<seconds>::max());
711        return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
712      }
713      return MakeRepeated(*tr, cs);
714    }
715    if (tr->prev_civil_sec < cs) {
716      return MakeSkipped(*tr, cs);
717    }
718    if (cs <= (--tr)->prev_civil_sec) {
719      return MakeRepeated(*tr, cs);
720    }
721    return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
722  }
723  std::string TimeZoneInfo::Version() const { return version_; }
724  std::string TimeZoneInfo::Description() const {
725    std::ostringstream oss;
726    oss << "#trans=" << transitions_.size();
727    oss << " #types=" << transition_types_.size();
728    oss << " spec='" << future_spec_ << "'";
729    return oss.str();
730  }
731  bool TimeZoneInfo::NextTransition(const time_point<seconds>& tp,
732                                    time_zone::civil_transition* trans) const {
733    if (transitions_.empty()) return false;
734    const Transition* begin = &transitions_[0];
735    const Transition* end = begin + transitions_.size();
736    if (begin->unix_time <= -(1LL << 59)) {
737      ++begin;
738    }
739    std::int_fast64_t unix_time = ToUnixSeconds(tp);
740    const Transition target = {unix_time, 0, civil_second(), civil_second()};
741    const Transition* tr =
742        std::upper_bound(begin, end, target, Transition::ByUnixTime());
743    for (; tr != end; ++tr) {  
744      std::uint_fast8_t prev_type_index =
745          (tr == begin) ? default_transition_type_ : tr[-1].type_index;
746      if (!EquivTransitions(prev_type_index, tr[0].type_index)) break;
747    }
748    if (tr == end) return false;
749    trans->from = tr->prev_civil_sec + 1;
750    trans->to = tr->civil_sec;
751    return true;
752  }
753  bool TimeZoneInfo::PrevTransition(const time_point<seconds>& tp,
754                                    time_zone::civil_transition* trans) const {
755    if (transitions_.empty()) return false;
756    const Transition* begin = &transitions_[0];
757    const Transition* end = begin + transitions_.size();
758    if (begin->unix_time <= -(1LL << 59)) {
759      ++begin;
760    }
761    std::int_fast64_t unix_time = ToUnixSeconds(tp);
762    if (FromUnixSeconds(unix_time) != tp) {
763      if (unix_time == std::numeric_limits<std::int_fast64_t>::max()) {
764        if (end == begin) return false;  
765        trans->from = (--end)->prev_civil_sec + 1;
766        trans->to = end->civil_sec;
767        return true;
768      }
769      unix_time += 1;  
770    }
771    const Transition target = {unix_time, 0, civil_second(), civil_second()};
772    const Transition* tr =
773        std::lower_bound(begin, end, target, Transition::ByUnixTime());
774    for (; tr != begin; --tr) {  
775      std::uint_fast8_t prev_type_index =
776          (tr - 1 == begin) ? default_transition_type_ : tr[-2].type_index;
777      if (!EquivTransitions(prev_type_index, tr[-1].type_index)) break;
778    }
779    if (tr == begin) return false;
780    trans->from = (--tr)->prev_civil_sec + 1;
781    trans->to = tr->civil_sec;
782    return true;
783  }
784  }  
785  }  
786  ABSL_NAMESPACE_END
787  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</h3>
            <pre><code>1  #include "time_zone_info.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <chrono>
5  #include <cstdint>
6  #include <cstdio>
7  #include <cstdlib>
8  #include <cstring>
9  #include <fstream>
10  #include <functional>
11  #include <memory>
12  #include <sstream>
13  #include <string>
14  #include <utility>
15  #include "absl/base/config.h"
16  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
17  #include "time_zone_fixed.h"
18  #include "time_zone_posix.h"
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace time_internal {
22  namespace cctz {
23  namespace {
24  inline bool IsLeap(year_t year) {
25    return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
26  }
27  const std::int_least32_t kDaysPerYear[2] = {365, 366};
28  const std::int_least16_t kMonthOffsets[2][1 + 12 + 1] = {
29      {-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
30      {-1, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366},
31  };
32  const std::int_least32_t kSecsPerDay = 24 * 60 * 60;
33  const std::int_least64_t kSecsPer400Years = 146097LL * kSecsPerDay;
34  const std::int_least32_t kSecsPerYear[2] = {
35      365 * kSecsPerDay,
36      366 * kSecsPerDay,
37  };
38  inline int ToPosixWeekday(weekday wd) {
39    switch (wd) {
40      case weekday::sunday:
41        return 0;
42      case weekday::monday:
43        return 1;
44      case weekday::tuesday:
45        return 2;
46      case weekday::wednesday:
47        return 3;
48      case weekday::thursday:
49        return 4;
50      case weekday::friday:
51        return 5;
52      case weekday::saturday:
53        return 6;
54    }
55    return 0; &bsol;*NOTREACHED*/
56  }
57  inline std::uint_fast8_t Decode8(const char* cp) {
58    return static_cast<std::uint_fast8_t>(*cp) & 0xff;
59  }
60  std::int_fast32_t Decode32(const char* cp) {
61    std::uint_fast32_t v = 0;
62    for (int i = 0; i != (32 / 8); ++i) v = (v << 8) | Decode8(cp++);
63    const std::int_fast32_t s32max = 0x7fffffff;
64    const auto s32maxU = static_cast<std::uint_fast32_t>(s32max);
65    if (v <= s32maxU) return static_cast<std::int_fast32_t>(v);
66    return static_cast<std::int_fast32_t>(v - s32maxU - 1) - s32max - 1;
67  }
68  std::int_fast64_t Decode64(const char* cp) {
69    std::uint_fast64_t v = 0;
70    for (int i = 0; i != (64 / 8); ++i) v = (v << 8) | Decode8(cp++);
71    const std::int_fast64_t s64max = 0x7fffffffffffffff;
72    const auto s64maxU = static_cast<std::uint_fast64_t>(s64max);
73    if (v <= s64maxU) return static_cast<std::int_fast64_t>(v);
74    return static_cast<std::int_fast64_t>(v - s64maxU - 1) - s64max - 1;
75  }
76  struct Header {            
77    std::size_t timecnt;     
78    std::size_t typecnt;     
79    std::size_t charcnt;     
80    std::size_t leapcnt;     
81    std::size_t ttisstdcnt;  
82    std::size_t ttisutcnt;   
83    bool Build(const tzhead& tzh);
84    std::size_t DataLength(std::size_t time_len) const;
85  };
86  bool Header::Build(const tzhead& tzh) {
87    std::int_fast32_t v;
88    if ((v = Decode32(tzh.tzh_timecnt)) < 0) return false;
89    timecnt = static_cast<std::size_t>(v);
90    if ((v = Decode32(tzh.tzh_typecnt)) < 0) return false;
91    typecnt = static_cast<std::size_t>(v);
92    if ((v = Decode32(tzh.tzh_charcnt)) < 0) return false;
93    charcnt = static_cast<std::size_t>(v);
94    if ((v = Decode32(tzh.tzh_leapcnt)) < 0) return false;
95    leapcnt = static_cast<std::size_t>(v);
96    if ((v = Decode32(tzh.tzh_ttisstdcnt)) < 0) return false;
97    ttisstdcnt = static_cast<std::size_t>(v);
98    if ((v = Decode32(tzh.tzh_ttisutcnt)) < 0) return false;
99    ttisutcnt = static_cast<std::size_t>(v);
100    return true;
101  }
102  std::size_t Header::DataLength(std::size_t time_len) const {
103    std::size_t len = 0;
104    len += (time_len + 1) * timecnt;  
105    len += (4 + 1 + 1) * typecnt;     
106    len += 1 * charcnt;               
107    len += (time_len + 4) * leapcnt;  
108    len += 1 * ttisstdcnt;            
109    len += 1 * ttisutcnt;             
110    return len;
111  }
112  bool AllYearDST(const PosixTimeZone& posix) {
113    if (posix.dst_start.date.fmt != PosixTransition::N) return false;
114    if (posix.dst_start.date.n.day != 0) return false;
115    if (posix.dst_start.time.offset != 0) return false;
116    if (posix.dst_end.date.fmt != PosixTransition::J) return false;
117    if (posix.dst_end.date.j.day != kDaysPerYear[0]) return false;
118    const auto offset = posix.std_offset - posix.dst_offset;
119    if (posix.dst_end.time.offset + offset != kSecsPerDay) return false;
120    return true;
121  }
122  std::int_fast64_t TransOffset(bool leap_year, int jan1_weekday,
123                                const PosixTransition& pt) {
124    std::int_fast64_t days = 0;
125    switch (pt.date.fmt) {
126      case PosixTransition::J: {
127        days = pt.date.j.day;
128        if (!leap_year || days < kMonthOffsets[1][3]) days -= 1;
129        break;
130      }
131      case PosixTransition::N: {
132        days = pt.date.n.day;
133        break;
134      }
135      case PosixTransition::M: {
136        const bool last_week = (pt.date.m.week == 5);
137        days = kMonthOffsets[leap_year][pt.date.m.month + last_week];
138        const std::int_fast64_t weekday = (jan1_weekday + days) % 7;
139        if (last_week) {
140          days -= (weekday + 7 - 1 - pt.date.m.weekday) % 7 + 1;
141        } else {
142          days += (pt.date.m.weekday + 7 - weekday) % 7;
143          days += (pt.date.m.week - 1) * 7;
144        }
145        break;
146      }
147    }
148    return (days * kSecsPerDay) + pt.time.offset;
149  }
150  inline time_zone::civil_lookup MakeUnique(const time_point<seconds>& tp) {
151    time_zone::civil_lookup cl;
152    cl.kind = time_zone::civil_lookup::UNIQUE;
153    cl.pre = cl.trans = cl.post = tp;
154    return cl;
155  }
156  inline time_zone::civil_lookup MakeUnique(std::int_fast64_t unix_time) {
157    return MakeUnique(FromUnixSeconds(unix_time));
158  }
159  inline time_zone::civil_lookup MakeSkipped(const Transition& tr,
160                                             const civil_second& cs) {
161    time_zone::civil_lookup cl;
162    cl.kind = time_zone::civil_lookup::SKIPPED;
163    cl.pre = FromUnixSeconds(tr.unix_time - 1 + (cs - tr.prev_civil_sec));
164    cl.trans = FromUnixSeconds(tr.unix_time);
165    cl.post = FromUnixSeconds(tr.unix_time - (tr.civil_sec - cs));
166    return cl;
167  }
168  inline time_zone::civil_lookup MakeRepeated(const Transition& tr,
169                                              const civil_second& cs) {
170    time_zone::civil_lookup cl;
171    cl.kind = time_zone::civil_lookup::REPEATED;
172    cl.pre = FromUnixSeconds(tr.unix_time - 1 - (tr.prev_civil_sec - cs));
173    cl.trans = FromUnixSeconds(tr.unix_time);
174    cl.post = FromUnixSeconds(tr.unix_time + (cs - tr.civil_sec));
175    return cl;
176  }
177  inline civil_second YearShift(const civil_second& cs, year_t shift) {
178    return civil_second(cs.year() + shift, cs.month(), cs.day(), cs.hour(),
179                        cs.minute(), cs.second());
180  }
181  }  
182  bool TimeZoneInfo::GetTransitionType(std::int_fast32_t utc_offset, bool is_dst,
183                                       const std::string& abbr,
184                                       std::uint_least8_t* index) {
185    std::size_t type_index = 0;
186    std::size_t abbr_index = abbreviations_.size();
187    for (; type_index != transition_types_.size(); ++type_index) {
188      const TransitionType& tt(transition_types_[type_index]);
189      const char* tt_abbr = &abbreviations_[tt.abbr_index];
190      if (tt_abbr == abbr) abbr_index = tt.abbr_index;
191      if (tt.utc_offset == utc_offset && tt.is_dst == is_dst) {
192        if (abbr_index == tt.abbr_index) break;  
193      }
194    }
195    if (type_index > 255 || abbr_index > 255) {
196      return false;
197    }
198    if (type_index == transition_types_.size()) {
199      TransitionType& tt(*transition_types_.emplace(transition_types_.end()));
200      tt.utc_offset = static_cast<std::int_least32_t>(utc_offset);
201      tt.is_dst = is_dst;
202      if (abbr_index == abbreviations_.size()) {
203        abbreviations_.append(abbr);
204        abbreviations_.append(1, '\0');
205      }
206      tt.abbr_index = static_cast<std::uint_least8_t>(abbr_index);
207    }
208    *index = static_cast<std::uint_least8_t>(type_index);
209    return true;
210  }
211  bool TimeZoneInfo::EquivTransitions(std::uint_fast8_t tt1_index,
212                                      std::uint_fast8_t tt2_index) const {
213    if (tt1_index == tt2_index) return true;
214    const TransitionType& tt1(transition_types_[tt1_index]);
215    const TransitionType& tt2(transition_types_[tt2_index]);
216    if (tt1.utc_offset != tt2.utc_offset) return false;
217    if (tt1.is_dst != tt2.is_dst) return false;
218    if (tt1.abbr_index != tt2.abbr_index) return false;
219    return true;
220  }
221  bool TimeZoneInfo::ExtendTransitions() {
222    extended_ = false;
223    if (future_spec_.empty()) return true;  
224    PosixTimeZone posix;
225    if (!ParsePosixSpec(future_spec_, &posix)) return false;
226    std::uint_least8_t std_ti;
227    if (!GetTransitionType(posix.std_offset, false, posix.std_abbr, &std_ti))
228      return false;
229    if (posix.dst_abbr.empty()) {  
230      return EquivTransitions(transitions_.back().type_index, std_ti);
231    }
232    std::uint_least8_t dst_ti;
233    if (!GetTransitionType(posix.dst_offset, true, posix.dst_abbr, &dst_ti))
234      return false;
235    if (AllYearDST(posix)) {  
236      return EquivTransitions(transitions_.back().type_index, dst_ti);
237    }
238    transitions_.reserve(transitions_.size() + 400 * 2 + 2);
239    extended_ = true;
240    const Transition& last(transitions_.back());
241    const std::int_fast64_t last_time = last.unix_time;
242    const TransitionType& last_tt(transition_types_[last.type_index]);
243    last_year_ = LocalTime(last_time, last_tt).cs.year();
244    bool leap_year = IsLeap(last_year_);
245    const civil_second jan1(last_year_);
246    std::int_fast64_t jan1_time = jan1 - civil_second();
247    int jan1_weekday = ToPosixWeekday(get_weekday(jan1));
248    Transition dst = {0, dst_ti, civil_second(), civil_second()};
249    Transition std = {0, std_ti, civil_second(), civil_second()};
250    for (const year_t limit = last_year_ + 400;; ++last_year_) {
251      auto dst_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_start);
252      auto std_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_end);
253      dst.unix_time = jan1_time + dst_trans_off - posix.std_offset;
254      std.unix_time = jan1_time + std_trans_off - posix.dst_offset;
255      const auto* ta = dst.unix_time < std.unix_time ? &dst : &std;
256      const auto* tb = dst.unix_time < std.unix_time ? &std : &dst;
257      if (last_time < tb->unix_time) {
258        if (last_time < ta->unix_time) transitions_.push_back(*ta);
259        transitions_.push_back(*tb);
260      }
261      if (last_year_ == limit) break;
262      jan1_time += kSecsPerYear[leap_year];
263      jan1_weekday = (jan1_weekday + kDaysPerYear[leap_year]) % 7;
264      leap_year = !leap_year && IsLeap(last_year_ + 1);
265    }
266    return true;
267  }
268  namespace {
269  using FilePtr = std::unique_ptr<FILE, int (*)(FILE*)>;
270  inline FilePtr FOpen(const char* path, const char* mode) {
271  #if defined(_MSC_VER)
272    FILE* fp;
273    if (fopen_s(&fp, path, mode) != 0) fp = nullptr;
274    return FilePtr(fp, fclose);
275  #else
276    return FilePtr(fopen(path, mode), fclose);
277  #endif
278  }
279  class FileZoneInfoSource : public ZoneInfoSource {
280   public:
281    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
282    std::size_t Read(void* ptr, std::size_t size) override {
283      size = std::min(size, len_);
284      std::size_t nread = fread(ptr, 1, size, fp_.get());
285      len_ -= nread;
286      return nread;
287    }
288    int Skip(std::size_t offset) override {
289      offset = std::min(offset, len_);
290      int rc = fseek(fp_.get(), static_cast<long>(offset), SEEK_CUR);
291      if (rc == 0) len_ -= offset;
292      return rc;
293    }
294    std::string Version() const override {
295      return std::string();
296    }
297   protected:
298    explicit FileZoneInfoSource(
299        FilePtr fp, std::size_t len = std::numeric_limits<std::size_t>::max())
300        : fp_(std::move(fp)), len_(len) {}
301   private:
302    FilePtr fp_;
303    std::size_t len_;
304  };
305  std::unique_ptr<ZoneInfoSource> FileZoneInfoSource::Open(
306      const std::string& name) {
307    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
308    std::string path;
309    if (pos == name.size() || name[pos] != '/') {
310      const char* tzdir = "/usr/share/zoneinfo";
311      char* tzdir_env = nullptr;
312  #if defined(_MSC_VER)
313      _dupenv_s(&tzdir_env, nullptr, "TZDIR");
314  #else
315      tzdir_env = std::getenv("TZDIR");
316  #endif
317      if (tzdir_env && *tzdir_env) tzdir = tzdir_env;
318      path += tzdir;
319      path += '/';
320  #if defined(_MSC_VER)
321      free(tzdir_env);
322  #endif
323    }
324    path.append(name, pos, std::string::npos);
325    auto fp = FOpen(path.c_str(), "rb");
326    if (fp == nullptr) return nullptr;
327    return std::unique_ptr<ZoneInfoSource>(new FileZoneInfoSource(std::move(fp)));
328  }
329  class AndroidZoneInfoSource : public FileZoneInfoSource {
330   public:
331    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
332    std::string Version() const override { return version_; }
333   private:
334    explicit AndroidZoneInfoSource(FilePtr fp, std::size_t len,
335                                   std::string version)
336        : FileZoneInfoSource(std::move(fp), len), version_(std::move(version)) {}
337    std::string version_;
338  };
339  std::unique_ptr<ZoneInfoSource> AndroidZoneInfoSource::Open(
340      const std::string& name) {
341    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
342    for (const char* tzdata : {"/data/misc/zoneinfo/current/tzdata",
343                               "/system/usr/share/zoneinfo/tzdata"}) {
344      auto fp = FOpen(tzdata, "rb");
345      if (fp == nullptr) continue;
346      char hbuf[24];  
347      if (fread(hbuf, 1, sizeof(hbuf), fp.get()) != sizeof(hbuf)) continue;
348      if (strncmp(hbuf, "tzdata", 6) != 0) continue;
349      const char* vers = (hbuf[11] == '\0') ? hbuf + 6 : "";
350      const std::int_fast32_t index_offset = Decode32(hbuf + 12);
351      const std::int_fast32_t data_offset = Decode32(hbuf + 16);
352      if (index_offset < 0 || data_offset < index_offset) continue;
353      if (fseek(fp.get(), static_cast<long>(index_offset), SEEK_SET) != 0)
354        continue;
355      char ebuf[52];  
356      const std::size_t index_size =
357          static_cast<std::size_t>(data_offset - index_offset);
358      const std::size_t zonecnt = index_size / sizeof(ebuf);
359      if (zonecnt * sizeof(ebuf) != index_size) continue;
360      for (std::size_t i = 0; i != zonecnt; ++i) {
361        if (fread(ebuf, 1, sizeof(ebuf), fp.get()) != sizeof(ebuf)) break;
362        const std::int_fast32_t start = data_offset + Decode32(ebuf + 40);
363        const std::int_fast32_t length = Decode32(ebuf + 44);
364        if (start < 0 || length < 0) break;
365        ebuf[40] = '\0';  
366        if (strcmp(name.c_str() + pos, ebuf) == 0) {
367          if (fseek(fp.get(), static_cast<long>(start), SEEK_SET) != 0) break;
368          return std::unique_ptr<ZoneInfoSource>(new AndroidZoneInfoSource(
369              std::move(fp), static_cast<std::size_t>(length), vers));
370        }
371      }
372    }
373    return nullptr;
374  }
375  class FuchsiaZoneInfoSource : public FileZoneInfoSource {
376   public:
377    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
378    std::string Version() const override { return version_; }
379   private:
380    explicit FuchsiaZoneInfoSource(FilePtr fp, std::string version)
381        : FileZoneInfoSource(std::move(fp)), version_(std::move(version)) {}
382    std::string version_;
383  };
384  std::unique_ptr<ZoneInfoSource> FuchsiaZoneInfoSource::Open(
385      const std::string& name) {
386    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
387    const auto kTzdataPrefixes = {
388        "/config/data/tzdata/",
389        "/pkg/data/tzdata/",
390        "/data/tzdata/",
391    };
392    const auto kEmptyPrefix = {""};
393    const bool name_absolute = (pos != name.size() && name[pos] == '/');
394    const auto prefixes = name_absolute ? kEmptyPrefix : kTzdataPrefixes;
395    for (const std::string prefix : prefixes) {
396      std::string path = prefix;
397      if (!prefix.empty()) path += "zoneinfo/tzif2/";  
398      path.append(name, pos, std::string::npos);
399      auto fp = FOpen(path.c_str(), "rb");
400      if (fp == nullptr) continue;
401      std::string version;
402      if (!prefix.empty()) {
403        std::ifstream version_stream(prefix + "revision.txt");
404        if (version_stream.is_open()) {
405          std::getline(version_stream, version);
406        }
407      }
408      return std::unique_ptr<ZoneInfoSource>(
409          new FuchsiaZoneInfoSource(std::move(fp), std::move(version)));
410    }
411    return nullptr;
412  }
413  }  
414  bool TimeZoneInfo::ResetToBuiltinUTC(const seconds& offset) {
415    transition_types_.resize(1);
416    TransitionType& tt(transition_types_.back());
417    tt.utc_offset = static_cast<std::int_least32_t>(offset.count());
418    tt.is_dst = false;
419    tt.abbr_index = 0;
420    transitions_.clear();
421    transitions_.reserve(12);
422    for (const std::int_fast64_t unix_time : {
423             -(1LL << 59),  
424             1420070400LL,  
425             1451606400LL,  
426             1483228800LL,  
427             1514764800LL,  
428             1546300800LL,  
429             1577836800LL,  
430             1609459200LL,  
431             1640995200LL,  
432             1672531200LL,  
433             1704067200LL,  
434             1735689600LL,  
435         }) {
436      Transition& tr(*transitions_.emplace(transitions_.end()));
437      tr.unix_time = unix_time;
438      tr.type_index = 0;
439      tr.civil_sec = LocalTime(tr.unix_time, tt).cs;
440      tr.prev_civil_sec = tr.civil_sec - 1;
441    }
442    default_transition_type_ = 0;
443    abbreviations_ = FixedOffsetToAbbr(offset);
444    abbreviations_.append(1, '\0');
445    future_spec_.clear();  
446    extended_ = false;
447    tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
448    tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
449    transitions_.shrink_to_fit();
450    return true;
451  }
452  bool TimeZoneInfo::Load(ZoneInfoSource* zip) {
453    tzhead tzh;
454    if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
455    if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
456      return false;
457    Header hdr;
458    if (!hdr.Build(tzh)) return false;
459    std::size_t time_len = 4;
460    if (tzh.tzh_version[0] != '\0') {
461      if (zip->Skip(hdr.DataLength(time_len)) != 0) return false;
462      if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
463      if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
464        return false;
465      if (tzh.tzh_version[0] == '\0') return false;
466      if (!hdr.Build(tzh)) return false;
467      time_len = 8;
468    }
469    if (hdr.typecnt == 0) return false;
470    if (hdr.leapcnt != 0) {
471      return false;
472    }
473    if (hdr.ttisstdcnt != 0 && hdr.ttisstdcnt != hdr.typecnt) return false;
474    if (hdr.ttisutcnt != 0 && hdr.ttisutcnt != hdr.typecnt) return false;
475    std::size_t len = hdr.DataLength(time_len);
476    std::vector<char> tbuf(len);
477    if (zip->Read(tbuf.data(), len) != len) return false;
478    const char* bp = tbuf.data();
479    transitions_.reserve(hdr.timecnt + 2);
480    transitions_.resize(hdr.timecnt);
481    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
482      transitions_[i].unix_time = (time_len == 4) ? Decode32(bp) : Decode64(bp);
483      bp += time_len;
484      if (i != 0) {
485        if (!Transition::ByUnixTime()(transitions_[i - 1], transitions_[i]))
486          return false;  
487      }
488    }
489    bool seen_type_0 = false;
490    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
491      transitions_[i].type_index = Decode8(bp++);
492      if (transitions_[i].type_index >= hdr.typecnt) return false;
493      if (transitions_[i].type_index == 0) seen_type_0 = true;
494    }
495    transition_types_.reserve(hdr.typecnt + 2);
496    transition_types_.resize(hdr.typecnt);
497    for (std::size_t i = 0; i != hdr.typecnt; ++i) {
498      transition_types_[i].utc_offset =
499          static_cast<std::int_least32_t>(Decode32(bp));
500      if (transition_types_[i].utc_offset >= kSecsPerDay ||
501          transition_types_[i].utc_offset <= -kSecsPerDay)
502        return false;
503      bp += 4;
504      transition_types_[i].is_dst = (Decode8(bp++) != 0);
505      transition_types_[i].abbr_index = Decode8(bp++);
506      if (transition_types_[i].abbr_index >= hdr.charcnt) return false;
507    }
508    default_transition_type_ = 0;
509    if (seen_type_0 && hdr.timecnt != 0) {
510      std::uint_fast8_t index = 0;
511      if (transition_types_[0].is_dst) {
512        index = transitions_[0].type_index;
513        while (index != 0 && transition_types_[index].is_dst) --index;
514      }
515      while (index != hdr.typecnt && transition_types_[index].is_dst) ++index;
516      if (index != hdr.typecnt) default_transition_type_ = index;
517    }
518    abbreviations_.reserve(hdr.charcnt + 10);
519    abbreviations_.assign(bp, hdr.charcnt);
520    bp += hdr.charcnt;
521    bp += (time_len + 4) * hdr.leapcnt;  
522    bp += 1 * hdr.ttisstdcnt;            
523    bp += 1 * hdr.ttisutcnt;             
524    assert(bp == tbuf.data() + tbuf.size());
525    future_spec_.clear();
526    if (tzh.tzh_version[0] != '\0') {
527      auto get_char = [](ZoneInfoSource* azip) -> int {
528        unsigned char ch;  
529        return (azip->Read(&ch, 1) == 1) ? ch : EOF;
530      };
531      if (get_char(zip) != '\n') return false;
532      for (int c = get_char(zip); c != '\n'; c = get_char(zip)) {
533        if (c == EOF) return false;
<span onclick='openModal()' class='match'>534        future_spec_.push_back(static_cast<char>(c));
535      }
536    }
</span>537    if (version_.empty()) {
538      version_ = zip->Version();
539    }
540    while (hdr.timecnt > 1) {
541      if (!EquivTransitions(transitions_[hdr.timecnt - 1].type_index,
542                            transitions_[hdr.timecnt - 2].type_index)) {
543        break;
544      }
545      hdr.timecnt -= 1;
546    }
547    transitions_.resize(hdr.timecnt);
548    if (transitions_.empty() || transitions_.front().unix_time >= 0) {
549      Transition& tr(*transitions_.emplace(transitions_.begin()));
550      tr.unix_time = -(1LL << 59);  
551      tr.type_index = default_transition_type_;
552    }
553    if (!ExtendTransitions()) return false;
554    const Transition& last(transitions_.back());
555    if (last.unix_time < 0) {
556      const std::uint_fast8_t type_index = last.type_index;
557      Transition& tr(*transitions_.emplace(transitions_.end()));
558      tr.unix_time = 2147483647;  
559      tr.type_index = type_index;
560    }
561    const TransitionType* ttp = &transition_types_[default_transition_type_];
562    for (std::size_t i = 0; i != transitions_.size(); ++i) {
563      Transition& tr(transitions_[i]);
564      tr.prev_civil_sec = LocalTime(tr.unix_time, *ttp).cs - 1;
565      ttp = &transition_types_[tr.type_index];
566      tr.civil_sec = LocalTime(tr.unix_time, *ttp).cs;
567      if (i != 0) {
568        if (!Transition::ByCivilTime()(transitions_[i - 1], tr))
569          return false;  
570      }
571    }
572    for (auto& tt : transition_types_) {
573      tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
574      tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
575    }
576    transitions_.shrink_to_fit();
577    return true;
578  }
579  bool TimeZoneInfo::Load(const std::string& name) {
580    auto offset = seconds::zero();
581    if (FixedOffsetFromName(name, &offset)) {
582      return ResetToBuiltinUTC(offset);
583    }
584    auto zip = cctz_extension::zone_info_source_factory(
585        name, [](const std::string& n) -> std::unique_ptr<ZoneInfoSource> {
586          if (auto z = FileZoneInfoSource::Open(n)) return z;
587          if (auto z = AndroidZoneInfoSource::Open(n)) return z;
588          if (auto z = FuchsiaZoneInfoSource::Open(n)) return z;
589          return nullptr;
590        });
591    return zip != nullptr && Load(zip.get());
592  }
593  std::unique_ptr<TimeZoneInfo> TimeZoneInfo::UTC() {
594    auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
595    tz->ResetToBuiltinUTC(seconds::zero());
596    return tz;
597  }
598  std::unique_ptr<TimeZoneInfo> TimeZoneInfo::Make(const std::string& name) {
599    auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
600    if (!tz->Load(name)) tz.reset();  
601    return tz;
602  }
603  time_zone::absolute_lookup TimeZoneInfo::LocalTime(
604      std::int_fast64_t unix_time, const TransitionType& tt) const {
605    return {(civil_second() + unix_time) + tt.utc_offset, tt.utc_offset,
606            tt.is_dst, &abbreviations_[tt.abbr_index]};
607  }
608  time_zone::absolute_lookup TimeZoneInfo::LocalTime(std::int_fast64_t unix_time,
609                                                     const Transition& tr) const {
610    const TransitionType& tt = transition_types_[tr.type_index];
611    return {tr.civil_sec + (unix_time - tr.unix_time),  
612            tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
613  }
614  time_zone::civil_lookup TimeZoneInfo::TimeLocal(const civil_second& cs,
615                                                  year_t c4_shift) const {
616    assert(last_year_ - 400 < cs.year() && cs.year() <= last_year_);
617    time_zone::civil_lookup cl = MakeTime(cs);
618    if (c4_shift > seconds::max().count() / kSecsPer400Years) {
619      cl.pre = cl.trans = cl.post = time_point<seconds>::max();
620    } else {
621      const auto offset = seconds(c4_shift * kSecsPer400Years);
622      const auto limit = time_point<seconds>::max() - offset;
623      for (auto* tp : {&cl.pre, &cl.trans, &cl.post}) {
624        if (*tp > limit) {
625          *tp = time_point<seconds>::max();
626        } else {
627          *tp += offset;
628        }
629      }
630    }
631    return cl;
632  }
633  time_zone::absolute_lookup TimeZoneInfo::BreakTime(
634      const time_point<seconds>& tp) const {
635    std::int_fast64_t unix_time = ToUnixSeconds(tp);
636    const std::size_t timecnt = transitions_.size();
637    assert(timecnt != 0);  
638    if (unix_time < transitions_[0].unix_time) {
639      return LocalTime(unix_time, transition_types_[default_transition_type_]);
640    }
641    if (unix_time >= transitions_[timecnt - 1].unix_time) {
642      if (extended_) {
643        const std::int_fast64_t diff =
644            unix_time - transitions_[timecnt - 1].unix_time;
645        const year_t shift = diff / kSecsPer400Years + 1;
646        const auto d = seconds(shift * kSecsPer400Years);
647        time_zone::absolute_lookup al = BreakTime(tp - d);
648        al.cs = YearShift(al.cs, shift * 400);
649        return al;
650      }
651      return LocalTime(unix_time, transitions_[timecnt - 1]);
652    }
653    const std::size_t hint = local_time_hint_.load(std::memory_order_relaxed);
654    if (0 < hint && hint < timecnt) {
655      if (transitions_[hint - 1].unix_time <= unix_time) {
656        if (unix_time < transitions_[hint].unix_time) {
657          return LocalTime(unix_time, transitions_[hint - 1]);
658        }
659      }
660    }
661    const Transition target = {unix_time, 0, civil_second(), civil_second()};
662    const Transition* begin = &transitions_[0];
663    const Transition* tr = std::upper_bound(begin, begin + timecnt, target,
664                                            Transition::ByUnixTime());
665    local_time_hint_.store(static_cast<std::size_t>(tr - begin),
666                           std::memory_order_relaxed);
667    return LocalTime(unix_time, *--tr);
668  }
669  time_zone::civil_lookup TimeZoneInfo::MakeTime(const civil_second& cs) const {
670    const std::size_t timecnt = transitions_.size();
671    assert(timecnt != 0);  
672    const Transition* tr = nullptr;
673    const Transition* begin = &transitions_[0];
674    const Transition* end = begin + timecnt;
675    if (cs < begin->civil_sec) {
676      tr = begin;
677    } else if (cs >= transitions_[timecnt - 1].civil_sec) {
678      tr = end;
679    } else {
680      const std::size_t hint = time_local_hint_.load(std::memory_order_relaxed);
681      if (0 < hint && hint < timecnt) {
682        if (transitions_[hint - 1].civil_sec <= cs) {
683          if (cs < transitions_[hint].civil_sec) {
684            tr = begin + hint;
685          }
686        }
687      }
688      if (tr == nullptr) {
689        const Transition target = {0, 0, cs, civil_second()};
690        tr = std::upper_bound(begin, end, target, Transition::ByCivilTime());
691        time_local_hint_.store(static_cast<std::size_t>(tr - begin),
692                               std::memory_order_relaxed);
693      }
694    }
695    if (tr == begin) {
696      if (tr->prev_civil_sec >= cs) {
697        const TransitionType& tt(transition_types_[default_transition_type_]);
698        if (cs < tt.civil_min) return MakeUnique(time_point<seconds>::min());
699        return MakeUnique(cs - (civil_second() + tt.utc_offset));
700      }
701      return MakeSkipped(*tr, cs);
702    }
703    if (tr == end) {
704      if (cs > (--tr)->prev_civil_sec) {
705        if (extended_ && cs.year() > last_year_) {
706          const year_t shift = (cs.year() - last_year_ - 1) / 400 + 1;
707          return TimeLocal(YearShift(cs, shift * -400), shift);
708        }
709        const TransitionType& tt(transition_types_[tr->type_index]);
710        if (cs > tt.civil_max) return MakeUnique(time_point<seconds>::max());
711        return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
712      }
713      return MakeRepeated(*tr, cs);
714    }
715    if (tr->prev_civil_sec < cs) {
716      return MakeSkipped(*tr, cs);
717    }
718    if (cs <= (--tr)->prev_civil_sec) {
719      return MakeRepeated(*tr, cs);
720    }
721    return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
722  }
723  std::string TimeZoneInfo::Version() const { return version_; }
724  std::string TimeZoneInfo::Description() const {
725    std::ostringstream oss;
726    oss << "#trans=" << transitions_.size();
727    oss << " #types=" << transition_types_.size();
728    oss << " spec='" << future_spec_ << "'";
729    return oss.str();
730  }
731  bool TimeZoneInfo::NextTransition(const time_point<seconds>& tp,
732                                    time_zone::civil_transition* trans) const {
733    if (transitions_.empty()) return false;
734    const Transition* begin = &transitions_[0];
735    const Transition* end = begin + transitions_.size();
736    if (begin->unix_time <= -(1LL << 59)) {
737      ++begin;
738    }
739    std::int_fast64_t unix_time = ToUnixSeconds(tp);
740    const Transition target = {unix_time, 0, civil_second(), civil_second()};
741    const Transition* tr =
742        std::upper_bound(begin, end, target, Transition::ByUnixTime());
743    for (; tr != end; ++tr) {  
744      std::uint_fast8_t prev_type_index =
745          (tr == begin) ? default_transition_type_ : tr[-1].type_index;
746      if (!EquivTransitions(prev_type_index, tr[0].type_index)) break;
747    }
748    if (tr == end) return false;
749    trans->from = tr->prev_civil_sec + 1;
750    trans->to = tr->civil_sec;
751    return true;
752  }
753  bool TimeZoneInfo::PrevTransition(const time_point<seconds>& tp,
754                                    time_zone::civil_transition* trans) const {
755    if (transitions_.empty()) return false;
756    const Transition* begin = &transitions_[0];
757    const Transition* end = begin + transitions_.size();
758    if (begin->unix_time <= -(1LL << 59)) {
759      ++begin;
760    }
761    std::int_fast64_t unix_time = ToUnixSeconds(tp);
762    if (FromUnixSeconds(unix_time) != tp) {
763      if (unix_time == std::numeric_limits<std::int_fast64_t>::max()) {
764        if (end == begin) return false;  
765        trans->from = (--end)->prev_civil_sec + 1;
766        trans->to = end->civil_sec;
767        return true;
768      }
769      unix_time += 1;  
770    }
771    const Transition target = {unix_time, 0, civil_second(), civil_second()};
772    const Transition* tr =
773        std::lower_bound(begin, end, target, Transition::ByUnixTime());
774    for (; tr != begin; --tr) {  
775      std::uint_fast8_t prev_type_index =
776          (tr - 1 == begin) ? default_transition_type_ : tr[-2].type_index;
777      if (!EquivTransitions(prev_type_index, tr[-1].type_index)) break;
778    }
779    if (tr == begin) return false;
780    trans->from = (--tr)->prev_civil_sec + 1;
781    trans->to = tr->civil_sec;
782    return true;
783  }
784  }  
785  }  
786  ABSL_NAMESPACE_END
787  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</div>
                </div>
                <div class="column column_space"><pre><code>534        future_spec_.push_back(static_cast<char>(c));
535      }
536    }
</pre></code></div>
                <div class="column column_space"><pre><code>534        future_spec_.push_back(static_cast<char>(c));
535      }
536    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    