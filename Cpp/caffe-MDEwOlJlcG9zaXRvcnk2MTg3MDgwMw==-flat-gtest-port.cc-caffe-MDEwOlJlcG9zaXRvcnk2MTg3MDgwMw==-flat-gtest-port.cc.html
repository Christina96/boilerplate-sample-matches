
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.cc</h3>
            <pre><code>1  #include "gtest/internal/gtest-port.h"
2  #include <limits.h>
3  #include <stdlib.h>
4  #include <stdio.h>
5  #include <string.h>
6  #if GTEST_OS_WINDOWS_MOBILE
7  # include <windows.h>  
8  #elif GTEST_OS_WINDOWS
9  # include <io.h>
10  # include <sys/stat.h>
11  #else
12  # include <unistd.h>
13  #endif  
14  #if GTEST_OS_MAC
15  # include <mach/mach_init.h>
16  # include <mach/task.h>
17  # include <mach/vm_map.h>
18  #endif  
19  #if GTEST_OS_QNX
20  # include <devctl.h>
21  # include <sys/procfs.h>
22  #endif  
23  #include "gtest/gtest-spi.h"
24  #include "gtest/gtest-message.h"
25  #include "gtest/internal/gtest-internal.h"
26  #include "gtest/internal/gtest-string.h"
27  #define GTEST_IMPLEMENTATION_ 1
28  #include "src/gtest-internal-inl.h"
29  #undef GTEST_IMPLEMENTATION_
30  namespace testing {
31  namespace internal {
32  #if defined(_MSC_VER) || defined(__BORLANDC__)
33  const int kStdOutFileno = 1;
34  const int kStdErrFileno = 2;
35  #else
36  const int kStdOutFileno = STDOUT_FILENO;
37  const int kStdErrFileno = STDERR_FILENO;
38  #endif  
39  #if GTEST_OS_MAC
40  size_t GetThreadCount() {
41    const task_t task = mach_task_self();
42    mach_msg_type_number_t thread_count;
43    thread_act_array_t thread_list;
44    const kern_return_t status = task_threads(task, &thread_list, &thread_count);
45    if (status == KERN_SUCCESS) {
46      vm_deallocate(task,
47                    reinterpret_cast<vm_address_t>(thread_list),
48                    sizeof(thread_t) * thread_count);
49      return static_cast<size_t>(thread_count);
50    } else {
51      return 0;
52    }
53  }
54  #elif GTEST_OS_QNX
55  size_t GetThreadCount() {
56    const int fd = open("/proc/self/as", O_RDONLY);
57    if (fd < 0) {
58      return 0;
59    }
60    procfs_info process_info;
61    const int status =
62        devctl(fd, DCMD_PROC_INFO, &process_info, sizeof(process_info), NULL);
63    close(fd);
64    if (status == EOK) {
65      return static_cast<size_t>(process_info.num_threads);
66    } else {
67      return 0;
68    }
69  }
70  #else
71  size_t GetThreadCount() {
72    return 0;
73  }
74  #endif  
75  #if GTEST_USES_POSIX_RE
76  RE::~RE() {
77    if (is_valid_) {
78      regfree(&partial_regex_);
79      regfree(&full_regex_);
80    }
81    free(const_cast<char*>(pattern_));
82  }
83  bool RE::FullMatch(const char* str, const RE& re) {
84    if (!re.is_valid_) return false;
85    regmatch_t match;
86    return regexec(&re.full_regex_, str, 1, &match, 0) == 0;
87  }
88  bool RE::PartialMatch(const char* str, const RE& re) {
89    if (!re.is_valid_) return false;
90    regmatch_t match;
91    return regexec(&re.partial_regex_, str, 1, &match, 0) == 0;
92  }
93  void RE::Init(const char* regex) {
94    pattern_ = posix::StrDup(regex);
95    const size_t full_regex_len = strlen(regex) + 10;
96    char* const full_pattern = new char[full_regex_len];
97    snprintf(full_pattern, full_regex_len, "^(%s)$", regex);
98    is_valid_ = regcomp(&full_regex_, full_pattern, REG_EXTENDED) == 0;
99    if (is_valid_) {
100      const char* const partial_regex = (*regex == '\0') ? "()" : regex;
101      is_valid_ = regcomp(&partial_regex_, partial_regex, REG_EXTENDED) == 0;
102    }
103    EXPECT_TRUE(is_valid_)
104        << "Regular expression \"" << regex
105        << "\" is not a valid POSIX Extended regular expression.";
106    delete[] full_pattern;
107  }
108  #elif GTEST_USES_SIMPLE_RE
109  bool IsInSet(char ch, const char* str) {
110    return ch != '\0' && strchr(str, ch) != NULL;
111  }
112  bool IsAsciiDigit(char ch) { return '0' <= ch && ch <= '9'; }
113  bool IsAsciiPunct(char ch) {
114    return IsInSet(ch, "^-!\"#$%&'()*+,./:;<=>?@[\\]_`{|}~");
115  }
116  bool IsRepeat(char ch) { return IsInSet(ch, "?*+"); }
117  bool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, " \f\n\r\t\v"); }
118  bool IsAsciiWordChar(char ch) {
119    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') ||
120        ('0' <= ch && ch <= '9') || ch == '_';
121  }
122  bool IsValidEscape(char c) {
123    return (IsAsciiPunct(c) || IsInSet(c, "dDfnrsStvwW"));
124  }
125  bool AtomMatchesChar(bool escaped, char pattern_char, char ch) {
126    if (escaped) {  
127      switch (pattern_char) {
128        case 'd': return IsAsciiDigit(ch);
129        case 'D': return !IsAsciiDigit(ch);
130        case 'f': return ch == '\f';
131        case 'n': return ch == '\n';
132        case 'r': return ch == '\r';
133        case 's': return IsAsciiWhiteSpace(ch);
134        case 'S': return !IsAsciiWhiteSpace(ch);
135        case 't': return ch == '\t';
136        case 'v': return ch == '\v';
137        case 'w': return IsAsciiWordChar(ch);
138        case 'W': return !IsAsciiWordChar(ch);
139      }
140      return IsAsciiPunct(pattern_char) && pattern_char == ch;
141    }
142    return (pattern_char == '.' && ch != '\n') || pattern_char == ch;
143  }
144  std::string FormatRegexSyntaxError(const char* regex, int index) {
145    return (Message() << "Syntax error at index " << index
146            << " in simple regular expression \"" << regex << "\": ").GetString();
147  }
148  bool ValidateRegex(const char* regex) {
149    if (regex == NULL) {
150      ADD_FAILURE() << "NULL is not a valid simple regular expression.";
151      return false;
152    }
153    bool is_valid = true;
154    bool prev_repeatable = false;
155    for (int i = 0; regex[i]; i++) {
156      if (regex[i] == '\\') {  
157        i++;
158        if (regex[i] == '\0') {
159          ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
160                        << "'\\' cannot appear at the end.";
161          return false;
162        }
163        if (!IsValidEscape(regex[i])) {
164          ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
165                        << "invalid escape sequence \"\\" << regex[i] << "\".";
166          is_valid = false;
167        }
168        prev_repeatable = true;
169      } else {  
170        const char ch = regex[i];
171        if (ch == '^' && i > 0) {
172          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
173                        << "'^' can only appear at the beginning.";
174          is_valid = false;
175        } else if (ch == '$' && regex[i + 1] != '\0') {
176          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
177                        << "'$' can only appear at the end.";
178          is_valid = false;
179        } else if (IsInSet(ch, "()[]{}|")) {
180          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
181                        << "'" << ch << "' is unsupported.";
182          is_valid = false;
183        } else if (IsRepeat(ch) && !prev_repeatable) {
184          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
185                        << "'" << ch << "' can only follow a repeatable token.";
186          is_valid = false;
187        }
188        prev_repeatable = !IsInSet(ch, "^$?*+");
189      }
190    }
191    return is_valid;
192  }
193  bool MatchRepetitionAndRegexAtHead(
194      bool escaped, char c, char repeat, const char* regex,
195      const char* str) {
196    const size_t min_count = (repeat == '+') ? 1 : 0;
197    const size_t max_count = (repeat == '?') ? 1 :
198        static_cast<size_t>(-1) - 1;
199    for (size_t i = 0; i <= max_count; ++i) {
200      if (i >= min_count && MatchRegexAtHead(regex, str + i)) {
201        return true;
202      }
203      if (str[i] == '\0' || !AtomMatchesChar(escaped, c, str[i]))
204        return false;
205    }
206    return false;
207  }
208  bool MatchRegexAtHead(const char* regex, const char* str) {
209    if (*regex == '\0')  
210      return true;
211    if (*regex == '$')
212      return *str == '\0';
213    const bool escaped = *regex == '\\';
214    if (escaped)
215      ++regex;
216    if (IsRepeat(regex[1])) {
217      return MatchRepetitionAndRegexAtHead(
218          escaped, regex[0], regex[1], regex + 2, str);
219    } else {
220      return (*str != '\0') && AtomMatchesChar(escaped, *regex, *str) &&
221          MatchRegexAtHead(regex + 1, str + 1);
222    }
223  }
224  bool MatchRegexAnywhere(const char* regex, const char* str) {
225    if (regex == NULL || str == NULL)
226      return false;
227    if (*regex == '^')
228      return MatchRegexAtHead(regex + 1, str);
229    do {
230      if (MatchRegexAtHead(regex, str))
231        return true;
232    } while (*str++ != '\0');
233    return false;
234  }
235  RE::~RE() {
236    free(const_cast<char*>(pattern_));
237    free(const_cast<char*>(full_pattern_));
238  }
239  bool RE::FullMatch(const char* str, const RE& re) {
240    return re.is_valid_ && MatchRegexAnywhere(re.full_pattern_, str);
241  }
242  bool RE::PartialMatch(const char* str, const RE& re) {
243    return re.is_valid_ && MatchRegexAnywhere(re.pattern_, str);
244  }
245  void RE::Init(const char* regex) {
246    pattern_ = full_pattern_ = NULL;
247    if (regex != NULL) {
248      pattern_ = posix::StrDup(regex);
249    }
250    is_valid_ = ValidateRegex(regex);
251    if (!is_valid_) {
252      return;
253    }
254    const size_t len = strlen(regex);
255    char* buffer = static_cast<char*>(malloc(len + 3));
256    full_pattern_ = buffer;
257    if (*regex != '^')
258      *buffer++ = '^';  
259    memcpy(buffer, regex, len);
260    buffer += len;
261    if (len == 0 || regex[len - 1] != '$')
262      *buffer++ = '$';  
263    *buffer = '\0';
264  }
265  #endif  
266  const char kUnknownFile[] = "unknown file";
267  GTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {
268    const std::string file_name(file == NULL ? kUnknownFile : file);
269    if (line < 0) {
270      return file_name + ":";
271    }
272  #ifdef _MSC_VER
273    return file_name + "(" + StreamableToString(line) + "):";
274  #else
275    return file_name + ":" + StreamableToString(line) + ":";
276  #endif  
277  }
278  GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(
279      const char* file, int line) {
280    const std::string file_name(file == NULL ? kUnknownFile : file);
281    if (line < 0)
282      return file_name;
283    else
284      return file_name + ":" + StreamableToString(line);
285  }
286  GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
287      : severity_(severity) {
288    const char* const marker =
289        severity == GTEST_INFO ?    "[  INFO ]" :
290        severity == GTEST_WARNING ? "[WARNING]" :
291        severity == GTEST_ERROR ?   "[ ERROR ]" : "[ FATAL ]";
292    GetStream() << ::std::endl << marker << " "
293                << FormatFileLocation(file, line).c_str() << ": ";
294  }
295  GTestLog::~GTestLog() {
296    GetStream() << ::std::endl;
297    if (severity_ == GTEST_FATAL) {
298      fflush(stderr);
299      posix::Abort();
300    }
301  }
302  #ifdef _MSC_VER
303  # pragma warning(push)
304  # pragma warning(disable: 4996)
305  #endif  
306  #if GTEST_HAS_STREAM_REDIRECTION
307  class CapturedStream {
308   public:
309    explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {
310  # if GTEST_OS_WINDOWS
311      char temp_dir_path[MAX_PATH + 1] = { '\0' };  
312      char temp_file_path[MAX_PATH + 1] = { '\0' };  
313      ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);
314      const UINT success = ::GetTempFileNameA(temp_dir_path,
315                                              "gtest_redir",
316                                              0,  
317                                              temp_file_path);
318      GTEST_CHECK_(success != 0)
319          << "Unable to create a temporary file in " << temp_dir_path;
320      const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);
321      GTEST_CHECK_(captured_fd != -1) << "Unable to open temporary file "
322                                      << temp_file_path;
323      filename_ = temp_file_path;
324  # else
325  #  if GTEST_OS_LINUX_ANDROID
326      char name_template[] = "/sdcard/gtest_captured_stream.XXXXXX";
327  #  else
328      char name_template[] = "/tmp/captured_stream.XXXXXX";
329  #  endif  
330      const int captured_fd = mkstemp(name_template);
331      filename_ = name_template;
332  # endif  
333      fflush(NULL);
334      dup2(captured_fd, fd_);
335      close(captured_fd);
336    }
337    ~CapturedStream() {
338      remove(filename_.c_str());
339    }
340    std::string GetCapturedString() {
341      if (uncaptured_fd_ != -1) {
342        fflush(NULL);
343        dup2(uncaptured_fd_, fd_);
344        close(uncaptured_fd_);
345        uncaptured_fd_ = -1;
346      }
347      FILE* const file = posix::FOpen(filename_.c_str(), "r");
348      const std::string content = ReadEntireFile(file);
349      posix::FClose(file);
350      return content;
351    }
352   private:
353    static std::string ReadEntireFile(FILE* file);
354    static size_t GetFileSize(FILE* file);
355    const int fd_;  
356    int uncaptured_fd_;
357    ::std::string filename_;
358    GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);
359  };
360  size_t CapturedStream::GetFileSize(FILE* file) {
361    fseek(file, 0, SEEK_END);
362    return static_cast<size_t>(ftell(file));
363  }
364  std::string CapturedStream::ReadEntireFile(FILE* file) {
365    const size_t file_size = GetFileSize(file);
366    char* const buffer = new char[file_size];
367    size_t bytes_last_read = 0;  
368    size_t bytes_read = 0;       
369    fseek(file, 0, SEEK_SET);
370    do {
371      bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);
372      bytes_read += bytes_last_read;
373    } while (bytes_last_read > 0 && bytes_read < file_size);
374    const std::string content(buffer, bytes_read);
375    delete[] buffer;
376    return content;
377  }
378  # ifdef _MSC_VER
379  #  pragma warning(pop)
380  # endif  
381  static CapturedStream* g_captured_stderr = NULL;
382  static CapturedStream* g_captured_stdout = NULL;
383  void CaptureStream(int fd, const char* stream_name, CapturedStream** stream) {
384    if (*stream != NULL) {
385      GTEST_LOG_(FATAL) << "Only one " << stream_name
386                        << " capturer can exist at a time.";
387    }
388    *stream = new CapturedStream(fd);
389  }
390  std::string GetCapturedStream(CapturedStream** captured_stream) {
391    const std::string content = (*captured_stream)->GetCapturedString();
392    delete *captured_stream;
393    *captured_stream = NULL;
394    return content;
395  }
<span onclick='openModal()' class='match'>396  void CaptureStdout() {
397    CaptureStream(kStdOutFileno, "stdout", &g_captured_stdout);
398  }
399  void CaptureStderr() {
</span>400    CaptureStream(kStdErrFileno, "stderr", &g_captured_stderr);
401  }
402  std::string GetCapturedStdout() {
403    return GetCapturedStream(&g_captured_stdout);
404  }
405  std::string GetCapturedStderr() {
406    return GetCapturedStream(&g_captured_stderr);
407  }
408  #endif  
409  #if GTEST_HAS_DEATH_TEST
410  ::std::vector<testing::internal::string> g_argvs;
411  static const ::std::vector<testing::internal::string>* g_injected_test_argvs =
412                                          NULL;  
413  void SetInjectableArgvs(const ::std::vector<testing::internal::string>* argvs) {
414    if (g_injected_test_argvs != argvs)
415      delete g_injected_test_argvs;
416    g_injected_test_argvs = argvs;
417  }
418  const ::std::vector<testing::internal::string>& GetInjectableArgvs() {
419    if (g_injected_test_argvs != NULL) {
420      return *g_injected_test_argvs;
421    }
422    return g_argvs;
423  }
424  #endif  
425  #if GTEST_OS_WINDOWS_MOBILE
426  namespace posix {
427  void Abort() {
428    DebugBreak();
429    TerminateProcess(GetCurrentProcess(), 1);
430  }
431  }  
432  #endif  
433  static std::string FlagToEnvVar(const char* flag) {
434    const std::string full_flag =
435        (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();
436    Message env_var;
437    for (size_t i = 0; i != full_flag.length(); i++) {
438      env_var << ToUpper(full_flag.c_str()[i]);
439    }
440    return env_var.GetString();
441  }
442  bool ParseInt32(const Message& src_text, const char* str, Int32* value) {
443    char* end = NULL;
444    const long long_value = strtol(str, &end, 10);  
445    if (*end != '\0') {
446      Message msg;
447      msg << "WARNING: " << src_text
448          << " is expected to be a 32-bit integer, but actually"
449          << " has value \"" << str << "\".\n";
450      printf("%s", msg.GetString().c_str());
451      fflush(stdout);
452      return false;
453    }
454    const Int32 result = static_cast<Int32>(long_value);
455    if (long_value == LONG_MAX || long_value == LONG_MIN ||
456        result != long_value
457        ) {
458      Message msg;
459      msg << "WARNING: " << src_text
460          << " is expected to be a 32-bit integer, but actually"
461          << " has value " << str << ", which overflows.\n";
462      printf("%s", msg.GetString().c_str());
463      fflush(stdout);
464      return false;
465    }
466    *value = result;
467    return true;
468  }
469  bool BoolFromGTestEnv(const char* flag, bool default_value) {
470    const std::string env_var = FlagToEnvVar(flag);
471    const char* const string_value = posix::GetEnv(env_var.c_str());
472    return string_value == NULL ?
473        default_value : strcmp(string_value, "0") != 0;
474  }
475  Int32 Int32FromGTestEnv(const char* flag, Int32 default_value) {
476    const std::string env_var = FlagToEnvVar(flag);
477    const char* const string_value = posix::GetEnv(env_var.c_str());
478    if (string_value == NULL) {
479      return default_value;
480    }
481    Int32 result = default_value;
482    if (!ParseInt32(Message() << "Environment variable " << env_var,
483                    string_value, &result)) {
484      printf("The default value %s is used.\n",
485             (Message() << default_value).GetString().c_str());
486      fflush(stdout);
487      return default_value;
488    }
489    return result;
490  }
491  const char* StringFromGTestEnv(const char* flag, const char* default_value) {
492    const std::string env_var = FlagToEnvVar(flag);
493    const char* const value = posix::GetEnv(env_var.c_str());
494    return value == NULL ? default_value : value;
495  }
496  }  
497  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.cc</h3>
            <pre><code>1  #include "gtest/internal/gtest-port.h"
2  #include <limits.h>
3  #include <stdlib.h>
4  #include <stdio.h>
5  #include <string.h>
6  #if GTEST_OS_WINDOWS_MOBILE
7  # include <windows.h>  
8  #elif GTEST_OS_WINDOWS
9  # include <io.h>
10  # include <sys/stat.h>
11  #else
12  # include <unistd.h>
13  #endif  
14  #if GTEST_OS_MAC
15  # include <mach/mach_init.h>
16  # include <mach/task.h>
17  # include <mach/vm_map.h>
18  #endif  
19  #if GTEST_OS_QNX
20  # include <devctl.h>
21  # include <sys/procfs.h>
22  #endif  
23  #include "gtest/gtest-spi.h"
24  #include "gtest/gtest-message.h"
25  #include "gtest/internal/gtest-internal.h"
26  #include "gtest/internal/gtest-string.h"
27  #define GTEST_IMPLEMENTATION_ 1
28  #include "src/gtest-internal-inl.h"
29  #undef GTEST_IMPLEMENTATION_
30  namespace testing {
31  namespace internal {
32  #if defined(_MSC_VER) || defined(__BORLANDC__)
33  const int kStdOutFileno = 1;
34  const int kStdErrFileno = 2;
35  #else
36  const int kStdOutFileno = STDOUT_FILENO;
37  const int kStdErrFileno = STDERR_FILENO;
38  #endif  
39  #if GTEST_OS_MAC
40  size_t GetThreadCount() {
41    const task_t task = mach_task_self();
42    mach_msg_type_number_t thread_count;
43    thread_act_array_t thread_list;
44    const kern_return_t status = task_threads(task, &thread_list, &thread_count);
45    if (status == KERN_SUCCESS) {
46      vm_deallocate(task,
47                    reinterpret_cast<vm_address_t>(thread_list),
48                    sizeof(thread_t) * thread_count);
49      return static_cast<size_t>(thread_count);
50    } else {
51      return 0;
52    }
53  }
54  #elif GTEST_OS_QNX
55  size_t GetThreadCount() {
56    const int fd = open("/proc/self/as", O_RDONLY);
57    if (fd < 0) {
58      return 0;
59    }
60    procfs_info process_info;
61    const int status =
62        devctl(fd, DCMD_PROC_INFO, &process_info, sizeof(process_info), NULL);
63    close(fd);
64    if (status == EOK) {
65      return static_cast<size_t>(process_info.num_threads);
66    } else {
67      return 0;
68    }
69  }
70  #else
71  size_t GetThreadCount() {
72    return 0;
73  }
74  #endif  
75  #if GTEST_USES_POSIX_RE
76  RE::~RE() {
77    if (is_valid_) {
78      regfree(&partial_regex_);
79      regfree(&full_regex_);
80    }
81    free(const_cast<char*>(pattern_));
82  }
83  bool RE::FullMatch(const char* str, const RE& re) {
84    if (!re.is_valid_) return false;
85    regmatch_t match;
86    return regexec(&re.full_regex_, str, 1, &match, 0) == 0;
87  }
88  bool RE::PartialMatch(const char* str, const RE& re) {
89    if (!re.is_valid_) return false;
90    regmatch_t match;
91    return regexec(&re.partial_regex_, str, 1, &match, 0) == 0;
92  }
93  void RE::Init(const char* regex) {
94    pattern_ = posix::StrDup(regex);
95    const size_t full_regex_len = strlen(regex) + 10;
96    char* const full_pattern = new char[full_regex_len];
97    snprintf(full_pattern, full_regex_len, "^(%s)$", regex);
98    is_valid_ = regcomp(&full_regex_, full_pattern, REG_EXTENDED) == 0;
99    if (is_valid_) {
100      const char* const partial_regex = (*regex == '\0') ? "()" : regex;
101      is_valid_ = regcomp(&partial_regex_, partial_regex, REG_EXTENDED) == 0;
102    }
103    EXPECT_TRUE(is_valid_)
104        << "Regular expression \"" << regex
105        << "\" is not a valid POSIX Extended regular expression.";
106    delete[] full_pattern;
107  }
108  #elif GTEST_USES_SIMPLE_RE
109  bool IsInSet(char ch, const char* str) {
110    return ch != '\0' && strchr(str, ch) != NULL;
111  }
112  bool IsAsciiDigit(char ch) { return '0' <= ch && ch <= '9'; }
113  bool IsAsciiPunct(char ch) {
114    return IsInSet(ch, "^-!\"#$%&'()*+,./:;<=>?@[\\]_`{|}~");
115  }
116  bool IsRepeat(char ch) { return IsInSet(ch, "?*+"); }
117  bool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, " \f\n\r\t\v"); }
118  bool IsAsciiWordChar(char ch) {
119    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') ||
120        ('0' <= ch && ch <= '9') || ch == '_';
121  }
122  bool IsValidEscape(char c) {
123    return (IsAsciiPunct(c) || IsInSet(c, "dDfnrsStvwW"));
124  }
125  bool AtomMatchesChar(bool escaped, char pattern_char, char ch) {
126    if (escaped) {  
127      switch (pattern_char) {
128        case 'd': return IsAsciiDigit(ch);
129        case 'D': return !IsAsciiDigit(ch);
130        case 'f': return ch == '\f';
131        case 'n': return ch == '\n';
132        case 'r': return ch == '\r';
133        case 's': return IsAsciiWhiteSpace(ch);
134        case 'S': return !IsAsciiWhiteSpace(ch);
135        case 't': return ch == '\t';
136        case 'v': return ch == '\v';
137        case 'w': return IsAsciiWordChar(ch);
138        case 'W': return !IsAsciiWordChar(ch);
139      }
140      return IsAsciiPunct(pattern_char) && pattern_char == ch;
141    }
142    return (pattern_char == '.' && ch != '\n') || pattern_char == ch;
143  }
144  std::string FormatRegexSyntaxError(const char* regex, int index) {
145    return (Message() << "Syntax error at index " << index
146            << " in simple regular expression \"" << regex << "\": ").GetString();
147  }
148  bool ValidateRegex(const char* regex) {
149    if (regex == NULL) {
150      ADD_FAILURE() << "NULL is not a valid simple regular expression.";
151      return false;
152    }
153    bool is_valid = true;
154    bool prev_repeatable = false;
155    for (int i = 0; regex[i]; i++) {
156      if (regex[i] == '\\') {  
157        i++;
158        if (regex[i] == '\0') {
159          ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
160                        << "'\\' cannot appear at the end.";
161          return false;
162        }
163        if (!IsValidEscape(regex[i])) {
164          ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)
165                        << "invalid escape sequence \"\\" << regex[i] << "\".";
166          is_valid = false;
167        }
168        prev_repeatable = true;
169      } else {  
170        const char ch = regex[i];
171        if (ch == '^' && i > 0) {
172          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
173                        << "'^' can only appear at the beginning.";
174          is_valid = false;
175        } else if (ch == '$' && regex[i + 1] != '\0') {
176          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
177                        << "'$' can only appear at the end.";
178          is_valid = false;
179        } else if (IsInSet(ch, "()[]{}|")) {
180          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
181                        << "'" << ch << "' is unsupported.";
182          is_valid = false;
183        } else if (IsRepeat(ch) && !prev_repeatable) {
184          ADD_FAILURE() << FormatRegexSyntaxError(regex, i)
185                        << "'" << ch << "' can only follow a repeatable token.";
186          is_valid = false;
187        }
188        prev_repeatable = !IsInSet(ch, "^$?*+");
189      }
190    }
191    return is_valid;
192  }
193  bool MatchRepetitionAndRegexAtHead(
194      bool escaped, char c, char repeat, const char* regex,
195      const char* str) {
196    const size_t min_count = (repeat == '+') ? 1 : 0;
197    const size_t max_count = (repeat == '?') ? 1 :
198        static_cast<size_t>(-1) - 1;
199    for (size_t i = 0; i <= max_count; ++i) {
200      if (i >= min_count && MatchRegexAtHead(regex, str + i)) {
201        return true;
202      }
203      if (str[i] == '\0' || !AtomMatchesChar(escaped, c, str[i]))
204        return false;
205    }
206    return false;
207  }
208  bool MatchRegexAtHead(const char* regex, const char* str) {
209    if (*regex == '\0')  
210      return true;
211    if (*regex == '$')
212      return *str == '\0';
213    const bool escaped = *regex == '\\';
214    if (escaped)
215      ++regex;
216    if (IsRepeat(regex[1])) {
217      return MatchRepetitionAndRegexAtHead(
218          escaped, regex[0], regex[1], regex + 2, str);
219    } else {
220      return (*str != '\0') && AtomMatchesChar(escaped, *regex, *str) &&
221          MatchRegexAtHead(regex + 1, str + 1);
222    }
223  }
224  bool MatchRegexAnywhere(const char* regex, const char* str) {
225    if (regex == NULL || str == NULL)
226      return false;
227    if (*regex == '^')
228      return MatchRegexAtHead(regex + 1, str);
229    do {
230      if (MatchRegexAtHead(regex, str))
231        return true;
232    } while (*str++ != '\0');
233    return false;
234  }
235  RE::~RE() {
236    free(const_cast<char*>(pattern_));
237    free(const_cast<char*>(full_pattern_));
238  }
239  bool RE::FullMatch(const char* str, const RE& re) {
240    return re.is_valid_ && MatchRegexAnywhere(re.full_pattern_, str);
241  }
242  bool RE::PartialMatch(const char* str, const RE& re) {
243    return re.is_valid_ && MatchRegexAnywhere(re.pattern_, str);
244  }
245  void RE::Init(const char* regex) {
246    pattern_ = full_pattern_ = NULL;
247    if (regex != NULL) {
248      pattern_ = posix::StrDup(regex);
249    }
250    is_valid_ = ValidateRegex(regex);
251    if (!is_valid_) {
252      return;
253    }
254    const size_t len = strlen(regex);
255    char* buffer = static_cast<char*>(malloc(len + 3));
256    full_pattern_ = buffer;
257    if (*regex != '^')
258      *buffer++ = '^';  
259    memcpy(buffer, regex, len);
260    buffer += len;
261    if (len == 0 || regex[len - 1] != '$')
262      *buffer++ = '$';  
263    *buffer = '\0';
264  }
265  #endif  
266  const char kUnknownFile[] = "unknown file";
267  GTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {
268    const std::string file_name(file == NULL ? kUnknownFile : file);
269    if (line < 0) {
270      return file_name + ":";
271    }
272  #ifdef _MSC_VER
273    return file_name + "(" + StreamableToString(line) + "):";
274  #else
275    return file_name + ":" + StreamableToString(line) + ":";
276  #endif  
277  }
278  GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(
279      const char* file, int line) {
280    const std::string file_name(file == NULL ? kUnknownFile : file);
281    if (line < 0)
282      return file_name;
283    else
284      return file_name + ":" + StreamableToString(line);
285  }
286  GTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)
287      : severity_(severity) {
288    const char* const marker =
289        severity == GTEST_INFO ?    "[  INFO ]" :
290        severity == GTEST_WARNING ? "[WARNING]" :
291        severity == GTEST_ERROR ?   "[ ERROR ]" : "[ FATAL ]";
292    GetStream() << ::std::endl << marker << " "
293                << FormatFileLocation(file, line).c_str() << ": ";
294  }
295  GTestLog::~GTestLog() {
296    GetStream() << ::std::endl;
297    if (severity_ == GTEST_FATAL) {
298      fflush(stderr);
299      posix::Abort();
300    }
301  }
302  #ifdef _MSC_VER
303  # pragma warning(push)
304  # pragma warning(disable: 4996)
305  #endif  
306  #if GTEST_HAS_STREAM_REDIRECTION
307  class CapturedStream {
308   public:
309    explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {
310  # if GTEST_OS_WINDOWS
311      char temp_dir_path[MAX_PATH + 1] = { '\0' };  
312      char temp_file_path[MAX_PATH + 1] = { '\0' };  
313      ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);
314      const UINT success = ::GetTempFileNameA(temp_dir_path,
315                                              "gtest_redir",
316                                              0,  
317                                              temp_file_path);
318      GTEST_CHECK_(success != 0)
319          << "Unable to create a temporary file in " << temp_dir_path;
320      const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);
321      GTEST_CHECK_(captured_fd != -1) << "Unable to open temporary file "
322                                      << temp_file_path;
323      filename_ = temp_file_path;
324  # else
325  #  if GTEST_OS_LINUX_ANDROID
326      char name_template[] = "/sdcard/gtest_captured_stream.XXXXXX";
327  #  else
328      char name_template[] = "/tmp/captured_stream.XXXXXX";
329  #  endif  
330      const int captured_fd = mkstemp(name_template);
331      filename_ = name_template;
332  # endif  
333      fflush(NULL);
334      dup2(captured_fd, fd_);
335      close(captured_fd);
336    }
337    ~CapturedStream() {
338      remove(filename_.c_str());
339    }
340    std::string GetCapturedString() {
341      if (uncaptured_fd_ != -1) {
342        fflush(NULL);
343        dup2(uncaptured_fd_, fd_);
344        close(uncaptured_fd_);
345        uncaptured_fd_ = -1;
346      }
347      FILE* const file = posix::FOpen(filename_.c_str(), "r");
348      const std::string content = ReadEntireFile(file);
349      posix::FClose(file);
350      return content;
351    }
352   private:
353    static std::string ReadEntireFile(FILE* file);
354    static size_t GetFileSize(FILE* file);
355    const int fd_;  
356    int uncaptured_fd_;
357    ::std::string filename_;
358    GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);
359  };
360  size_t CapturedStream::GetFileSize(FILE* file) {
361    fseek(file, 0, SEEK_END);
362    return static_cast<size_t>(ftell(file));
363  }
364  std::string CapturedStream::ReadEntireFile(FILE* file) {
365    const size_t file_size = GetFileSize(file);
366    char* const buffer = new char[file_size];
367    size_t bytes_last_read = 0;  
368    size_t bytes_read = 0;       
369    fseek(file, 0, SEEK_SET);
370    do {
371      bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);
372      bytes_read += bytes_last_read;
373    } while (bytes_last_read > 0 && bytes_read < file_size);
374    const std::string content(buffer, bytes_read);
375    delete[] buffer;
376    return content;
377  }
378  # ifdef _MSC_VER
379  #  pragma warning(pop)
380  # endif  
381  static CapturedStream* g_captured_stderr = NULL;
382  static CapturedStream* g_captured_stdout = NULL;
383  void CaptureStream(int fd, const char* stream_name, CapturedStream** stream) {
384    if (*stream != NULL) {
385      GTEST_LOG_(FATAL) << "Only one " << stream_name
386                        << " capturer can exist at a time.";
387    }
388    *stream = new CapturedStream(fd);
389  }
390  std::string GetCapturedStream(CapturedStream** captured_stream) {
391    const std::string content = (*captured_stream)->GetCapturedString();
392    delete *captured_stream;
393    *captured_stream = NULL;
394    return content;
395  }
396  void CaptureStdout() {
397    CaptureStream(kStdOutFileno, "stdout", &g_captured_stdout);
398  }
<span onclick='openModal()' class='match'>399  void CaptureStderr() {
400    CaptureStream(kStdErrFileno, "stderr", &g_captured_stderr);
401  }
402  std::string GetCapturedStdout() {
</span>403    return GetCapturedStream(&g_captured_stdout);
404  }
405  std::string GetCapturedStderr() {
406    return GetCapturedStream(&g_captured_stderr);
407  }
408  #endif  
409  #if GTEST_HAS_DEATH_TEST
410  ::std::vector<testing::internal::string> g_argvs;
411  static const ::std::vector<testing::internal::string>* g_injected_test_argvs =
412                                          NULL;  
413  void SetInjectableArgvs(const ::std::vector<testing::internal::string>* argvs) {
414    if (g_injected_test_argvs != argvs)
415      delete g_injected_test_argvs;
416    g_injected_test_argvs = argvs;
417  }
418  const ::std::vector<testing::internal::string>& GetInjectableArgvs() {
419    if (g_injected_test_argvs != NULL) {
420      return *g_injected_test_argvs;
421    }
422    return g_argvs;
423  }
424  #endif  
425  #if GTEST_OS_WINDOWS_MOBILE
426  namespace posix {
427  void Abort() {
428    DebugBreak();
429    TerminateProcess(GetCurrentProcess(), 1);
430  }
431  }  
432  #endif  
433  static std::string FlagToEnvVar(const char* flag) {
434    const std::string full_flag =
435        (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();
436    Message env_var;
437    for (size_t i = 0; i != full_flag.length(); i++) {
438      env_var << ToUpper(full_flag.c_str()[i]);
439    }
440    return env_var.GetString();
441  }
442  bool ParseInt32(const Message& src_text, const char* str, Int32* value) {
443    char* end = NULL;
444    const long long_value = strtol(str, &end, 10);  
445    if (*end != '\0') {
446      Message msg;
447      msg << "WARNING: " << src_text
448          << " is expected to be a 32-bit integer, but actually"
449          << " has value \"" << str << "\".\n";
450      printf("%s", msg.GetString().c_str());
451      fflush(stdout);
452      return false;
453    }
454    const Int32 result = static_cast<Int32>(long_value);
455    if (long_value == LONG_MAX || long_value == LONG_MIN ||
456        result != long_value
457        ) {
458      Message msg;
459      msg << "WARNING: " << src_text
460          << " is expected to be a 32-bit integer, but actually"
461          << " has value " << str << ", which overflows.\n";
462      printf("%s", msg.GetString().c_str());
463      fflush(stdout);
464      return false;
465    }
466    *value = result;
467    return true;
468  }
469  bool BoolFromGTestEnv(const char* flag, bool default_value) {
470    const std::string env_var = FlagToEnvVar(flag);
471    const char* const string_value = posix::GetEnv(env_var.c_str());
472    return string_value == NULL ?
473        default_value : strcmp(string_value, "0") != 0;
474  }
475  Int32 Int32FromGTestEnv(const char* flag, Int32 default_value) {
476    const std::string env_var = FlagToEnvVar(flag);
477    const char* const string_value = posix::GetEnv(env_var.c_str());
478    if (string_value == NULL) {
479      return default_value;
480    }
481    Int32 result = default_value;
482    if (!ParseInt32(Message() << "Environment variable " << env_var,
483                    string_value, &result)) {
484      printf("The default value %s is used.\n",
485             (Message() << default_value).GetString().c_str());
486      fflush(stdout);
487      return default_value;
488    }
489    return result;
490  }
491  const char* StringFromGTestEnv(const char* flag, const char* default_value) {
492    const std::string env_var = FlagToEnvVar(flag);
493    const char* const value = posix::GetEnv(env_var.c_str());
494    return value == NULL ? default_value : value;
495  }
496  }  
497  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gtest-port.cc</div>
                </div>
                <div class="column column_space"><pre><code>396  void CaptureStdout() {
397    CaptureStream(kStdOutFileno, "stdout", &g_captured_stdout);
398  }
399  void CaptureStderr() {
</pre></code></div>
                <div class="column column_space"><pre><code>399  void CaptureStderr() {
400    CaptureStream(kStdErrFileno, "stderr", &g_captured_stderr);
401  }
402  std::string GetCapturedStdout() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    