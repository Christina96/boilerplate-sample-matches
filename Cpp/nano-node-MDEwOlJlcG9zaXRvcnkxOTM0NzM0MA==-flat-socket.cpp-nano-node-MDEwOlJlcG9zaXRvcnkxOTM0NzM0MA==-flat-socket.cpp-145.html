
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 99, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</h3>
            <pre><code>1  #include &lt;nano/boost/asio/ip/address_v6.hpp&gt;
2  #include &lt;nano/boost/asio/ip/network_v6.hpp&gt;
3  #include &lt;nano/lib/threading.hpp&gt;
4  #include &lt;nano/node/transport/socket.hpp&gt;
5  #include &lt;nano/test_common/system.hpp&gt;
6  #include &lt;nano/test_common/testutil.hpp&gt;
7  #include &lt;gtest/gtest.h&gt;
8  #include &lt;boost/asio/read.hpp&gt;
9  #include &lt;map&gt;
10  #include &lt;memory&gt;
11  #include &lt;utility&gt;
12  #include &lt;vector&gt;
13  using namespace std::chrono_literals;
14  TEST (socket, max_connections)
15  {
16  	nano::test::system system;
17  	auto node = system.add_node ();
18  	auto server_port = system.get_available_port ();
19  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
20  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, 2);
21  	boost::system::error_code ec;
22  	server_socket-&gt;start (ec);
23  	ASSERT_FALSE (ec);
24  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
25  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
26  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
27  		server_sockets.push_back (new_connection);
28  		return true;
29  	});
30  	std::atomic&lt;size_t&gt; connection_attempts = 0;
31  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
32  		ASSERT_EQ (ec_a.value (), 0);
33  		++connection_attempts;
34  	};
35  	auto client1 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
36  	client1-&gt;async_connect (dst_endpoint, connect_handler);
37  	auto client2 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
38  	client2-&gt;async_connect (dst_endpoint, connect_handler);
39  	auto client3 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
40  	client3-&gt;async_connect (dst_endpoint, connect_handler);
41  	auto get_tcp_accept_failures = [&amp;node] () {
42  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in);
43  	};
44  	auto get_tcp_accept_successes = [&amp;node] () {
45  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
46  	};
47  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 1);
48  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 2);
49  	ASSERT_TIMELY_EQ (5s, connection_attempts, 3);
50  	server_sockets[0].reset ();
51  	auto client4 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
52  	client4-&gt;async_connect (dst_endpoint, connect_handler);
53  	auto client5 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
54  	client5-&gt;async_connect (dst_endpoint, connect_handler);
55  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 2);
56  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 3);
57  	ASSERT_TIMELY_EQ (5s, connection_attempts, 5);
58  	server_sockets[1].reset ();
59  	server_sockets[2].reset ();
60  	ASSERT_EQ (server_sockets.size (), 3);
61  	auto client6 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
62  	client6-&gt;async_connect (dst_endpoint, connect_handler);
63  	auto client7 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
64  	client7-&gt;async_connect (dst_endpoint, connect_handler);
65  	auto client8 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
66  	client8-&gt;async_connect (dst_endpoint, connect_handler);
67  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 3);
68  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 5);
69  	ASSERT_TIMELY_EQ (5s, connection_attempts, 8); 
70  	ASSERT_TIMELY_EQ (5s, server_sockets.size (), 5); 
71  	node-&gt;stop ();
72  }
73  TEST (socket, max_connections_per_ip)
74  {
75  	nano::test::system system;
76  	auto node = system.add_node ();
77  	ASSERT_FALSE (node-&gt;flags.disable_max_peers_per_ip);
78  	auto server_port = system.get_available_port ();
79  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
80  	const auto max_ip_connections = node-&gt;network_params.network.max_peers_per_ip;
81  	ASSERT_TRUE (max_ip_connections &gt;= 1);
82  	const auto max_global_connections = 1000;
83  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
84  	boost::system::error_code ec;
85  	server_socket-&gt;start (ec);
86  	ASSERT_FALSE (ec);
87  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
88  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
89  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
90  		server_sockets.push_back (new_connection);
91  		return true;
92  	});
93  	std::atomic&lt;size_t&gt; connection_attempts = 0;
94  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
95  		ASSERT_EQ (ec_a.value (), 0);
96  		++connection_attempts;
97  	};
98  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
99  	client_list.reserve (max_ip_connections + 1);
100  	for (auto idx = 0; idx &lt; max_ip_connections + 1; ++idx)
101  	{
102  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
103  		client-&gt;async_connect (dst_endpoint, connect_handler);
104  		client_list.push_back (client);
105  	}
106  	auto get_tcp_max_per_ip = [&amp;node] () {
107  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
108  	};
109  	auto get_tcp_accept_successes = [&amp;node] () {
110  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
111  	};
112  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections);
113  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 1);
114  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
115  	node-&gt;stop ();
116  }
117  TEST (socket, limited_subnet_address)
118  {
119  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
120  	auto network = nano::transport::socket_functions::get_ipv6_subnet_address (address.to_v6 (), 32); 
121  	ASSERT_EQ (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713/32&quot;, network.to_string ());
122  	ASSERT_EQ (&quot;a41d:b7b2::/32&quot;, network.canonical ().to_string ());
123  }
124  TEST (socket, first_ipv6_subnet_address)
125  {
126  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
127  	auto first_address = nano::transport::socket_functions::first_ipv6_subnet_address (address.to_v6 (), 32); 
128  	ASSERT_EQ (&quot;a41d:b7b2::&quot;, first_address.to_string ());
129  }
130  TEST (socket, last_ipv6_subnet_address)
131  {
132  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
133  	auto last_address = nano::transport::socket_functions::last_ipv6_subnet_address (address.to_v6 (), 32); 
134  	ASSERT_EQ (&quot;a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff&quot;, last_address.to_string ());
135  }
136  TEST (socket, count_subnetwork_connections)
137  {
138  	nano::test::system system;
139  	auto node = system.add_node ();
140  	auto address0 = boost::asio::ip::make_address (&quot;a41d:b7b1:ffff:ffff:ffff:ffff:ffff:ffff&quot;); 
141  	auto address1 = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;); 
142  	auto address2 = boost::asio::ip::make_address (&quot;a41d:b7b2::&quot;); 
143  	auto address3 = boost::asio::ip::make_address (&quot;a41d:b7b2::1&quot;);
144  	auto address4 = boost::asio::ip::make_address (&quot;a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff&quot;); 
145  	auto address5 = boost::asio::ip::make_address (&quot;a41d:b7b3::&quot;); 
146  	auto address6 = boost::asio::ip::make_address (&quot;a41d:b7b3::1&quot;); 
147  	auto connection0 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
148  	auto connection1 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
149  	auto connection2 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
150  	auto connection3 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
151  	auto connection4 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
152  	auto connection5 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
153  	auto connection6 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
154  	nano::transport::address_socket_mmap connections_per_address;
155  	connections_per_address.emplace (address0, connection0);
156  	connections_per_address.emplace (address1, connection1);
157  	connections_per_address.emplace (address2, connection2);
158  	connections_per_address.emplace (address3, connection3);
159  	connections_per_address.emplace (address4, connection4);
160  	connections_per_address.emplace (address5, connection5);
161  	connections_per_address.emplace (address6, connection6);
162  	ASSERT_EQ (4, nano::transport::socket_functions::count_subnetwork_connections (connections_per_address, address1.to_v6 (), 32));
163  }
164  TEST (socket, max_connections_per_subnetwork)
165  {
166  	nano::test::system system;
167  	nano::node_flags node_flags;
168  	node_flags.disable_max_peers_per_ip = true;
169  	node_flags.disable_max_peers_per_subnetwork = false;
170  	auto node = system.add_node (node_flags);
171  	ASSERT_TRUE (node-&gt;flags.disable_max_peers_per_ip);
172  	ASSERT_FALSE (node-&gt;flags.disable_max_peers_per_subnetwork);
173  	auto server_port = system.get_available_port ();
174  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
175  	const auto max_subnetwork_connections = node-&gt;network_params.network.max_peers_per_subnetwork;
176  	ASSERT_TRUE (max_subnetwork_connections &gt;= 1);
177  	const auto max_global_connections = 1000;
178  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
179  	boost::system::error_code ec;
180  	server_socket-&gt;start (ec);
181  	ASSERT_FALSE (ec);
182  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
183  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
184  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
185  		server_sockets.push_back (new_connection);
186  		return true;
187  	});
188  	std::atomic&lt;size_t&gt; connection_attempts = 0;
189  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
190  		ASSERT_EQ (ec_a.value (), 0);
191  		++connection_attempts;
192  	};
193  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
194  	client_list.reserve (max_subnetwork_connections + 1);
195  	for (auto idx = 0; idx &lt; max_subnetwork_connections + 1; ++idx)
196  	{
197  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
198  		client-&gt;async_connect (dst_endpoint, connect_handler);
199  		client_list.push_back (client);
200  	}
201  	auto get_tcp_max_per_subnetwork = [&amp;node] () {
202  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_subnetwork, nano::stat::dir::in);
203  	};
204  	auto get_tcp_accept_successes = [&amp;node] () {
205  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
206  	};
207  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_subnetwork_connections);
208  	ASSERT_TIMELY (5s, get_tcp_max_per_subnetwork () == 1);
209  	ASSERT_TIMELY (5s, connection_attempts == max_subnetwork_connections + 1);
210  	node-&gt;stop ();
211  }
212  TEST (socket, disabled_max_peers_per_ip)
213  {
214  	nano::test::system system;
215  	nano::node_flags node_flags;
216  	node_flags.disable_max_peers_per_ip = true;
217  	auto node = system.add_node (node_flags);
218  	ASSERT_TRUE (node-&gt;flags.disable_max_peers_per_ip);
219  	auto server_port = system.get_available_port ();
220  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
221  	const auto max_ip_connections = node-&gt;network_params.network.max_peers_per_ip;
222  	ASSERT_TRUE (max_ip_connections &gt;= 1);
223  	const auto max_global_connections = 1000;
224  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
225  	boost::system::error_code ec;
226  	server_socket-&gt;start (ec);
227  	ASSERT_FALSE (ec);
228  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
229  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
230  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
231  		server_sockets.push_back (new_connection);
232  		return true;
233  	});
234  	std::atomic&lt;size_t&gt; connection_attempts = 0;
235  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
236  		ASSERT_EQ (ec_a.value (), 0);
237  		++connection_attempts;
238  	};
239  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
240  	client_list.reserve (max_ip_connections + 1);
241  	for (auto idx = 0; idx &lt; max_ip_connections + 1; ++idx)
242  	{
243  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
244  		client-&gt;async_connect (dst_endpoint, connect_handler);
245  		client_list.push_back (client);
246  	}
247  	auto get_tcp_max_per_ip = [&amp;node] () {
248  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
249  	};
250  	auto get_tcp_accept_successes = [&amp;node] () {
251  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
252  	};
253  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections + 1);
254  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 0);
255  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
256  	node-&gt;stop ();
257  }
258  TEST (socket, disconnection_of_silent_connections)
259  {
260  	nano::test::system system;
261  	nano::node_config config;
262  	config.tcp_io_timeout = std::chrono::seconds::max ();
263  	config.network_params.network.idle_timeout = std::chrono::seconds::max ();
264  	config.network_params.network.silent_connection_tolerance_time = std::chrono::seconds{ 5 };
265  	auto node = system.add_node (config);
266  	auto server_port = system.get_available_port ();
267  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
268  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, 1);
269  	boost::system::error_code ec;
270  	server_socket-&gt;start (ec);
271  	ASSERT_FALSE (ec);
272  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
273  	std::shared_ptr&lt;nano::transport::socket&gt; server_data_socket;
274  	server_socket-&gt;on_connection ([&amp;server_data_socket] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
275  		server_data_socket = new_connection;
276  		return true;
277  	});
278  	auto client_socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
279  	std::atomic&lt;bool&gt; connected{ false };
280  	client_socket-&gt;async_connect (dst_endpoint, [client_socket, &amp;connected] (boost::system::error_code const &amp; ec_a) {
281  		ASSERT_FALSE (ec_a);
282  		connected = true;
283  	});
284  	ASSERT_TIMELY (4s, connected);
285  	ASSERT_TIMELY (10s, server_data_socket != nullptr);
286  	ASSERT_TIMELY (10s, server_data_socket-&gt;is_closed ());
287  	auto get_tcp_io_timeout_drops = [&amp;node] () {
288  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::in);
289  	};
290  	auto get_tcp_silent_connection_drops = [&amp;node] () {
291  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_silent_connection_drop, nano::stat::dir::in);
292  	};
293  	ASSERT_EQ (0, get_tcp_io_timeout_drops ());
294  	ASSERT_EQ (1, get_tcp_silent_connection_drops ());
295  	node-&gt;stop ();
296  }
297  TEST (socket, drop_policy)
298  {
299  	nano::test::system system;
300  	auto node_flags = nano::inactive_node_flag_defaults ();
301  	node_flags.read_only = false;
302  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
303  	auto node = inactivenode.node;
304  	nano::thread_runner runner (node-&gt;io_ctx, 1);
305  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; connections;
306  	auto func = [&amp;] (size_t total_message_count, nano::transport::buffer_drop_policy drop_policy) {
307  		auto server_port (system.get_available_port ());
308  		boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
309  		auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, endpoint, 1);
310  		boost::system::error_code ec;
311  		server_socket-&gt;start (ec);
312  		ASSERT_FALSE (ec);
313  		server_socket-&gt;on_connection ([&amp;connections] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
314  			connections.push_back (new_connection);
315  			return true;
316  		});
317  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
318  		nano::transport::channel_tcp channel{ *node, client };
319  		nano::test::counted_completion write_completion (static_cast&lt;unsigned&gt; (total_message_count));
320  		client-&gt;async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port ()),
321  		[&amp;channel, total_message_count, node, &amp;write_completion, &amp;drop_policy, client] (boost::system::error_code const &amp; ec_a) mutable {
322  			for (int i = 0; i &lt; total_message_count; i++)
323  			{
324  				std::vector&lt;uint8_t&gt; buff (1);
325  				channel.send_buffer (
326  				nano::shared_const_buffer (std::move (buff)), [&amp;write_completion, client] (boost::system::error_code const &amp; ec, size_t size_a) mutable {
327  					client.reset ();
328  					write_completion.increment ();
329  				},
330  				drop_policy);
331  			}
332  		});
333  		ASSERT_FALSE (write_completion.await_count_for (std::chrono::seconds (5)));
334  		ASSERT_EQ (1, client.use_count ());
335  	};
336  	func (nano::transport::socket::default_max_queue_size * 2 + 1, nano::transport::buffer_drop_policy::no_socket_drop);
337  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
338  	ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
339  	func (nano::transport::socket::default_max_queue_size + 1, nano::transport::buffer_drop_policy::limiter);
340  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
341  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
342  	node-&gt;stop ();
343  	runner.stop_event_processing ();
344  	runner.join ();
345  }
346  TEST (socket, concurrent_writes)
347  {
348  	nano::test::system system;
349  	auto node_flags = nano::inactive_node_flag_defaults ();
350  	node_flags.read_only = false;
351  	node_flags.disable_max_peers_per_ip = true;
352  	node_flags.disable_max_peers_per_subnetwork = true;
353  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
354  	auto node = inactivenode.node;
355  	nano::thread_runner runner (node-&gt;io_ctx, 1);
356  	constexpr size_t max_connections = 4;
357  	constexpr size_t client_count = max_connections;
358  	constexpr size_t message_count = 4;
359  	constexpr size_t total_message_count = client_count * message_count;
360  	nano::test::counted_completion read_count_completion (total_message_count);
361  	std::function&lt;void (std::shared_ptr&lt;nano::transport::socket&gt; const &amp;)&gt; reader = [&amp;read_count_completion, &amp;total_message_count, &amp;reader] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; socket_a) {
362  		auto buff (std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; ());
363  		buff-&gt;resize (1);
364  		socket_a-&gt;async_read (buff, 1, [&amp;read_count_completion, &amp;reader, &amp;total_message_count, socket_a, buff] (boost::system::error_code const &amp; ec, size_t size_a) {
365  			if (!ec)
366  			{
367  				if (read_count_completion.increment () &lt; total_message_count)
368  				{
369  					reader (socket_a);
370  				}
371  			}
372  			else if (ec != boost::asio::error::eof)
373  			{
374  				std::cerr &lt;&lt; &quot;async_read: &quot; &lt;&lt; ec.message () &lt;&lt; std::endl;
375  			}
376  		});
377  	};
378  	auto server_port (system.get_available_port ());
379  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
380  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, endpoint, max_connections);
381  	boost::system::error_code ec;
382  	server_socket-&gt;start (ec);
383  	ASSERT_FALSE (ec);
384  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; connections;
385  	server_socket-&gt;on_connection ([&amp;connections, &amp;reader] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
386  		if (ec_a)
387  		{
388  			std::cerr &lt;&lt; &quot;on_connection: &quot; &lt;&lt; ec_a.message () &lt;&lt; std::endl;
389  		}
390  		else
391  		{
392  			connections.push_back (new_connection);
393  			reader (new_connection);
394  		}
395  		return true;
396  	});
397  	nano::test::counted_completion connection_count_completion (client_count);
398  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; clients;
399  	for (unsigned i = 0; i &lt; client_count; i++)
400  	{
401  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
402  		clients.push_back (client);
403  		client-&gt;async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v4::loopback (), server_socket-&gt;listening_port ()),
404  		[&amp;connection_count_completion] (boost::system::error_code const &amp; ec_a) {
405  			if (ec_a)
406  			{
407  				std::cerr &lt;&lt; &quot;async_connect: &quot; &lt;&lt; ec_a.message () &lt;&lt; std::endl;
408  			}
409  			else
410  			{
411  				connection_count_completion.increment ();
412  			}
413  		});
414  	}
415  	ASSERT_FALSE (connection_count_completion.await_count_for (10s));
416  	auto client (clients[0]);
417  	std::vector&lt;std::thread&gt; client_threads;
418  	for (int i = 0; i &lt; client_count; i++)
419  	{
420  		client_threads.emplace_back ([&amp;client, &amp;message_count] () {
421  			for (int i = 0; i &lt; message_count; i++)
422  			{
423  				std::vector&lt;uint8_t&gt; buff;
424  				buff.push_back (&#x27;A&#x27; + i);
425  				client-&gt;async_write (nano::shared_const_buffer (std::move (buff)));
426  			}
427  		});
428  	}
429  	ASSERT_FALSE (read_count_completion.await_count_for (10s));
430  	node-&gt;stop ();
431  	runner.stop_event_processing ();
432  	runner.join ();
433  	ASSERT_EQ (node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in), client_count);
434  	ASSERT_LT (node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in), client_count);
435  	for (auto &amp; t : client_threads)
436  	{
437  		t.join ();
438  	}
439  }
440  TEST (socket_timeout, connect)
441  {
442  	nano::test::system system (1);
443  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
444  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (1);
445  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::make_address_v6 (&quot;::ffff:10.255.254.253&quot;), 1234);
446  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
447  	std::atomic&lt;bool&gt; done = false;
448  	boost::system::error_code ec;
449  	socket-&gt;async_connect (endpoint, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
450  		if (ec_a)
451  		{
452  			ec = ec_a;
453  			done = true;
454  		}
455  	});
456  	ASSERT_TIMELY (6s, done == true);
457  	ASSERT_TRUE (ec);
458  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_connect_error, nano::stat::dir::in));
459  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
460  }
461  TEST (socket_timeout, read)
462  {
463  	nano::test::system system (1);
464  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
465  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
466  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
467  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
468  	acceptor.open (endpoint.protocol ());
469  	acceptor.bind (endpoint);
470  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
471  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
472  	acceptor.async_accept (newsock, [] (boost::system::error_code const &amp; ec_a) {
473  		EXPECT_FALSE (ec_a);
474  	});
475  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
476  	std::atomic&lt;bool&gt; done = false;
477  	boost::system::error_code ec;
478  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
479  		EXPECT_FALSE (ec_a);
480  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
481  		socket-&gt;async_read (buffer, 1, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
482  			if (ec_a)
483  			{
484  				ec = ec_a;
485  				done = true;
486  			}
487  		});
488  	});
489  	ASSERT_TIMELY (10s, done == true);
490  	ASSERT_TRUE (ec);
491  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
492  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
493  }
494  TEST (socket_timeout, write)
495  {
496  	nano::test::system system (1);
497  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
498  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
499  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
500  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
501  	acceptor.open (endpoint.protocol ());
502  	acceptor.bind (endpoint);
503  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
504  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
505  	acceptor.async_accept (newsock, [] (boost::system::error_code const &amp; ec_a) {
506  		EXPECT_FALSE (ec_a);
507  	});
508  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node, 1024 * 64); 
509  	std::atomic&lt;bool&gt; done = false;
510  	boost::system::error_code ec;
511  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
512  		EXPECT_FALSE (ec_a);
513  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (128 * 1024);
514  		for (auto i = 0; i &lt; 1024; ++i)
515  		{
516  			socket-&gt;async_write (nano::shared_const_buffer{ buffer }, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
517  				if (ec_a)
518  				{
519  					ec = ec_a;
<span onclick='openModal()' class='match'>520  					done = true;
521  				}
522  			});
523  		}
524  	});
525  	ASSERT_TIMELY (10s, done == true);
526  	ASSERT_TRUE (ec);
527  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
528  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
529  }
530  TEST (socket_timeout, read_overlapped)
</span>531  {
532  	nano::test::system system (1);
533  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
534  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
535  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
536  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
537  	acceptor.open (endpoint.protocol ());
538  	acceptor.bind (endpoint);
539  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
540  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
541  	acceptor.async_accept (newsock, [&amp;newsock] (boost::system::error_code const &amp; ec_a) {
542  		EXPECT_FALSE (ec_a);
543  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
544  		nano::async_write (newsock, nano::shared_const_buffer (buffer), [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
545  			debug_assert (!ec_a);
546  			debug_assert (size_a == 1);
547  		});
548  	});
549  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
550  	std::atomic&lt;bool&gt; done = false;
551  	boost::system::error_code ec;
552  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
553  		EXPECT_FALSE (ec_a);
554  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
555  		socket-&gt;async_read (buffer, 1, [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
556  			debug_assert (size_a == 1);
557  		});
558  		socket-&gt;async_read (buffer, 1, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
559  			debug_assert (size_a == 0);
560  			if (ec_a)
561  			{
562  				ec = ec_a;
563  				done = true;
564  			}
565  		});
566  	});
567  	ASSERT_TIMELY (10s, done == true);
568  	ASSERT_TRUE (ec);
569  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
570  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
571  }
572  TEST (socket_timeout, write_overlapped)
573  {
574  	nano::test::system system (1);
575  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
576  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
577  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
578  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
579  	acceptor.open (endpoint.protocol ());
580  	acceptor.bind (endpoint);
581  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
582  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
583  	auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
584  	acceptor.async_accept (newsock, [&amp;newsock, &amp;buffer] (boost::system::error_code const &amp; ec_a) {
585  		EXPECT_FALSE (ec_a);
586  		boost::asio::async_read (newsock, boost::asio::buffer (buffer-&gt;data (), buffer-&gt;size ()), [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
587  			debug_assert (size_a == 1);
588  		});
589  	});
590  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node, 1024 * 64); 
591  	std::atomic&lt;bool&gt; done = false;
592  	boost::system::error_code ec;
593  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
594  		EXPECT_FALSE (ec_a);
595  		auto buffer1 = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
596  		auto buffer2 = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (128 * 1024);
597  		socket-&gt;async_write (nano::shared_const_buffer{ buffer1 }, [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
598  			debug_assert (size_a == 1);
599  		});
600  		for (auto i = 0; i &lt; 1024; ++i)
601  		{
602  			socket-&gt;async_write (nano::shared_const_buffer{ buffer2 }, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
603  				if (ec_a)
604  				{
605  					ec = ec_a;
606  					done = true;
607  				}
608  			});
609  		}
610  	});
611  	ASSERT_TIMELY (10s, done == true);
612  	ASSERT_TRUE (ec);
613  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
614  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
615  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</h3>
            <pre><code>1  #include &lt;nano/boost/asio/ip/address_v6.hpp&gt;
2  #include &lt;nano/boost/asio/ip/network_v6.hpp&gt;
3  #include &lt;nano/lib/threading.hpp&gt;
4  #include &lt;nano/node/transport/socket.hpp&gt;
5  #include &lt;nano/test_common/system.hpp&gt;
6  #include &lt;nano/test_common/testutil.hpp&gt;
7  #include &lt;gtest/gtest.h&gt;
8  #include &lt;boost/asio/read.hpp&gt;
9  #include &lt;map&gt;
10  #include &lt;memory&gt;
11  #include &lt;utility&gt;
12  #include &lt;vector&gt;
13  using namespace std::chrono_literals;
14  TEST (socket, max_connections)
15  {
16  	nano::test::system system;
17  	auto node = system.add_node ();
18  	auto server_port = system.get_available_port ();
19  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
20  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, 2);
21  	boost::system::error_code ec;
22  	server_socket-&gt;start (ec);
23  	ASSERT_FALSE (ec);
24  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
25  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
26  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
27  		server_sockets.push_back (new_connection);
28  		return true;
29  	});
30  	std::atomic&lt;size_t&gt; connection_attempts = 0;
31  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
32  		ASSERT_EQ (ec_a.value (), 0);
33  		++connection_attempts;
34  	};
35  	auto client1 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
36  	client1-&gt;async_connect (dst_endpoint, connect_handler);
37  	auto client2 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
38  	client2-&gt;async_connect (dst_endpoint, connect_handler);
39  	auto client3 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
40  	client3-&gt;async_connect (dst_endpoint, connect_handler);
41  	auto get_tcp_accept_failures = [&amp;node] () {
42  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in);
43  	};
44  	auto get_tcp_accept_successes = [&amp;node] () {
45  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
46  	};
47  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 1);
48  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 2);
49  	ASSERT_TIMELY_EQ (5s, connection_attempts, 3);
50  	server_sockets[0].reset ();
51  	auto client4 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
52  	client4-&gt;async_connect (dst_endpoint, connect_handler);
53  	auto client5 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
54  	client5-&gt;async_connect (dst_endpoint, connect_handler);
55  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 2);
56  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 3);
57  	ASSERT_TIMELY_EQ (5s, connection_attempts, 5);
58  	server_sockets[1].reset ();
59  	server_sockets[2].reset ();
60  	ASSERT_EQ (server_sockets.size (), 3);
61  	auto client6 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
62  	client6-&gt;async_connect (dst_endpoint, connect_handler);
63  	auto client7 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
64  	client7-&gt;async_connect (dst_endpoint, connect_handler);
65  	auto client8 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
66  	client8-&gt;async_connect (dst_endpoint, connect_handler);
67  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_failures (), 3);
68  	ASSERT_TIMELY_EQ (5s, get_tcp_accept_successes (), 5);
69  	ASSERT_TIMELY_EQ (5s, connection_attempts, 8); 
70  	ASSERT_TIMELY_EQ (5s, server_sockets.size (), 5); 
71  	node-&gt;stop ();
72  }
73  TEST (socket, max_connections_per_ip)
74  {
75  	nano::test::system system;
76  	auto node = system.add_node ();
77  	ASSERT_FALSE (node-&gt;flags.disable_max_peers_per_ip);
78  	auto server_port = system.get_available_port ();
79  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
80  	const auto max_ip_connections = node-&gt;network_params.network.max_peers_per_ip;
81  	ASSERT_TRUE (max_ip_connections &gt;= 1);
82  	const auto max_global_connections = 1000;
83  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
84  	boost::system::error_code ec;
85  	server_socket-&gt;start (ec);
86  	ASSERT_FALSE (ec);
87  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
88  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
89  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
90  		server_sockets.push_back (new_connection);
91  		return true;
92  	});
93  	std::atomic&lt;size_t&gt; connection_attempts = 0;
94  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
95  		ASSERT_EQ (ec_a.value (), 0);
96  		++connection_attempts;
97  	};
98  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
99  	client_list.reserve (max_ip_connections + 1);
100  	for (auto idx = 0; idx &lt; max_ip_connections + 1; ++idx)
101  	{
102  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
103  		client-&gt;async_connect (dst_endpoint, connect_handler);
104  		client_list.push_back (client);
105  	}
106  	auto get_tcp_max_per_ip = [&amp;node] () {
107  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
108  	};
109  	auto get_tcp_accept_successes = [&amp;node] () {
110  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
111  	};
112  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections);
113  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 1);
114  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
115  	node-&gt;stop ();
116  }
117  TEST (socket, limited_subnet_address)
118  {
119  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
120  	auto network = nano::transport::socket_functions::get_ipv6_subnet_address (address.to_v6 (), 32); 
121  	ASSERT_EQ (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713/32&quot;, network.to_string ());
122  	ASSERT_EQ (&quot;a41d:b7b2::/32&quot;, network.canonical ().to_string ());
123  }
124  TEST (socket, first_ipv6_subnet_address)
125  {
126  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
127  	auto first_address = nano::transport::socket_functions::first_ipv6_subnet_address (address.to_v6 (), 32); 
128  	ASSERT_EQ (&quot;a41d:b7b2::&quot;, first_address.to_string ());
129  }
130  TEST (socket, last_ipv6_subnet_address)
131  {
132  	auto address = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;);
133  	auto last_address = nano::transport::socket_functions::last_ipv6_subnet_address (address.to_v6 (), 32); 
134  	ASSERT_EQ (&quot;a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff&quot;, last_address.to_string ());
135  }
136  TEST (socket, count_subnetwork_connections)
137  {
138  	nano::test::system system;
139  	auto node = system.add_node ();
140  	auto address0 = boost::asio::ip::make_address (&quot;a41d:b7b1:ffff:ffff:ffff:ffff:ffff:ffff&quot;); 
141  	auto address1 = boost::asio::ip::make_address (&quot;a41d:b7b2:8298:cf45:672e:bd1a:e7fb:f713&quot;); 
142  	auto address2 = boost::asio::ip::make_address (&quot;a41d:b7b2::&quot;); 
143  	auto address3 = boost::asio::ip::make_address (&quot;a41d:b7b2::1&quot;);
144  	auto address4 = boost::asio::ip::make_address (&quot;a41d:b7b2:ffff:ffff:ffff:ffff:ffff:ffff&quot;); 
145  	auto address5 = boost::asio::ip::make_address (&quot;a41d:b7b3::&quot;); 
146  	auto address6 = boost::asio::ip::make_address (&quot;a41d:b7b3::1&quot;); 
147  	auto connection0 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
148  	auto connection1 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
149  	auto connection2 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
150  	auto connection3 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
151  	auto connection4 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
152  	auto connection5 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
153  	auto connection6 = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
154  	nano::transport::address_socket_mmap connections_per_address;
155  	connections_per_address.emplace (address0, connection0);
156  	connections_per_address.emplace (address1, connection1);
157  	connections_per_address.emplace (address2, connection2);
158  	connections_per_address.emplace (address3, connection3);
159  	connections_per_address.emplace (address4, connection4);
160  	connections_per_address.emplace (address5, connection5);
161  	connections_per_address.emplace (address6, connection6);
162  	ASSERT_EQ (4, nano::transport::socket_functions::count_subnetwork_connections (connections_per_address, address1.to_v6 (), 32));
163  }
164  TEST (socket, max_connections_per_subnetwork)
165  {
166  	nano::test::system system;
167  	nano::node_flags node_flags;
168  	node_flags.disable_max_peers_per_ip = true;
169  	node_flags.disable_max_peers_per_subnetwork = false;
170  	auto node = system.add_node (node_flags);
171  	ASSERT_TRUE (node-&gt;flags.disable_max_peers_per_ip);
172  	ASSERT_FALSE (node-&gt;flags.disable_max_peers_per_subnetwork);
173  	auto server_port = system.get_available_port ();
174  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
175  	const auto max_subnetwork_connections = node-&gt;network_params.network.max_peers_per_subnetwork;
176  	ASSERT_TRUE (max_subnetwork_connections &gt;= 1);
177  	const auto max_global_connections = 1000;
178  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
179  	boost::system::error_code ec;
180  	server_socket-&gt;start (ec);
181  	ASSERT_FALSE (ec);
182  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
183  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
184  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
185  		server_sockets.push_back (new_connection);
186  		return true;
187  	});
188  	std::atomic&lt;size_t&gt; connection_attempts = 0;
189  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
190  		ASSERT_EQ (ec_a.value (), 0);
191  		++connection_attempts;
192  	};
193  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
194  	client_list.reserve (max_subnetwork_connections + 1);
195  	for (auto idx = 0; idx &lt; max_subnetwork_connections + 1; ++idx)
196  	{
197  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
198  		client-&gt;async_connect (dst_endpoint, connect_handler);
199  		client_list.push_back (client);
200  	}
201  	auto get_tcp_max_per_subnetwork = [&amp;node] () {
202  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_subnetwork, nano::stat::dir::in);
203  	};
204  	auto get_tcp_accept_successes = [&amp;node] () {
205  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
206  	};
207  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_subnetwork_connections);
208  	ASSERT_TIMELY (5s, get_tcp_max_per_subnetwork () == 1);
209  	ASSERT_TIMELY (5s, connection_attempts == max_subnetwork_connections + 1);
210  	node-&gt;stop ();
211  }
212  TEST (socket, disabled_max_peers_per_ip)
213  {
214  	nano::test::system system;
215  	nano::node_flags node_flags;
216  	node_flags.disable_max_peers_per_ip = true;
217  	auto node = system.add_node (node_flags);
218  	ASSERT_TRUE (node-&gt;flags.disable_max_peers_per_ip);
219  	auto server_port = system.get_available_port ();
220  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
221  	const auto max_ip_connections = node-&gt;network_params.network.max_peers_per_ip;
222  	ASSERT_TRUE (max_ip_connections &gt;= 1);
223  	const auto max_global_connections = 1000;
224  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, max_global_connections);
225  	boost::system::error_code ec;
226  	server_socket-&gt;start (ec);
227  	ASSERT_FALSE (ec);
228  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
229  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; server_sockets;
230  	server_socket-&gt;on_connection ([&amp;server_sockets] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
231  		server_sockets.push_back (new_connection);
232  		return true;
233  	});
234  	std::atomic&lt;size_t&gt; connection_attempts = 0;
235  	auto connect_handler = [&amp;connection_attempts] (boost::system::error_code const &amp; ec_a) {
236  		ASSERT_EQ (ec_a.value (), 0);
237  		++connection_attempts;
238  	};
239  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; client_list;
240  	client_list.reserve (max_ip_connections + 1);
241  	for (auto idx = 0; idx &lt; max_ip_connections + 1; ++idx)
242  	{
243  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
244  		client-&gt;async_connect (dst_endpoint, connect_handler);
245  		client_list.push_back (client);
246  	}
247  	auto get_tcp_max_per_ip = [&amp;node] () {
248  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_max_per_ip, nano::stat::dir::in);
249  	};
250  	auto get_tcp_accept_successes = [&amp;node] () {
251  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in);
252  	};
253  	ASSERT_TIMELY (5s, get_tcp_accept_successes () == max_ip_connections + 1);
254  	ASSERT_TIMELY (5s, get_tcp_max_per_ip () == 0);
255  	ASSERT_TIMELY (5s, connection_attempts == max_ip_connections + 1);
256  	node-&gt;stop ();
257  }
258  TEST (socket, disconnection_of_silent_connections)
259  {
260  	nano::test::system system;
261  	nano::node_config config;
262  	config.tcp_io_timeout = std::chrono::seconds::max ();
263  	config.network_params.network.idle_timeout = std::chrono::seconds::max ();
264  	config.network_params.network.silent_connection_tolerance_time = std::chrono::seconds{ 5 };
265  	auto node = system.add_node (config);
266  	auto server_port = system.get_available_port ();
267  	boost::asio::ip::tcp::endpoint listen_endpoint{ boost::asio::ip::address_v6::any (), server_port };
268  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, listen_endpoint, 1);
269  	boost::system::error_code ec;
270  	server_socket-&gt;start (ec);
271  	ASSERT_FALSE (ec);
272  	boost::asio::ip::tcp::endpoint dst_endpoint{ boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port () };
273  	std::shared_ptr&lt;nano::transport::socket&gt; server_data_socket;
274  	server_socket-&gt;on_connection ([&amp;server_data_socket] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
275  		server_data_socket = new_connection;
276  		return true;
277  	});
278  	auto client_socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
279  	std::atomic&lt;bool&gt; connected{ false };
280  	client_socket-&gt;async_connect (dst_endpoint, [client_socket, &amp;connected] (boost::system::error_code const &amp; ec_a) {
281  		ASSERT_FALSE (ec_a);
282  		connected = true;
283  	});
284  	ASSERT_TIMELY (4s, connected);
285  	ASSERT_TIMELY (10s, server_data_socket != nullptr);
286  	ASSERT_TIMELY (10s, server_data_socket-&gt;is_closed ());
287  	auto get_tcp_io_timeout_drops = [&amp;node] () {
288  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::in);
289  	};
290  	auto get_tcp_silent_connection_drops = [&amp;node] () {
291  		return node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_silent_connection_drop, nano::stat::dir::in);
292  	};
293  	ASSERT_EQ (0, get_tcp_io_timeout_drops ());
294  	ASSERT_EQ (1, get_tcp_silent_connection_drops ());
295  	node-&gt;stop ();
296  }
297  TEST (socket, drop_policy)
298  {
299  	nano::test::system system;
300  	auto node_flags = nano::inactive_node_flag_defaults ();
301  	node_flags.read_only = false;
302  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
303  	auto node = inactivenode.node;
304  	nano::thread_runner runner (node-&gt;io_ctx, 1);
305  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; connections;
306  	auto func = [&amp;] (size_t total_message_count, nano::transport::buffer_drop_policy drop_policy) {
307  		auto server_port (system.get_available_port ());
308  		boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
309  		auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, endpoint, 1);
310  		boost::system::error_code ec;
311  		server_socket-&gt;start (ec);
312  		ASSERT_FALSE (ec);
313  		server_socket-&gt;on_connection ([&amp;connections] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
314  			connections.push_back (new_connection);
315  			return true;
316  		});
317  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
318  		nano::transport::channel_tcp channel{ *node, client };
319  		nano::test::counted_completion write_completion (static_cast&lt;unsigned&gt; (total_message_count));
320  		client-&gt;async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), server_socket-&gt;listening_port ()),
321  		[&amp;channel, total_message_count, node, &amp;write_completion, &amp;drop_policy, client] (boost::system::error_code const &amp; ec_a) mutable {
322  			for (int i = 0; i &lt; total_message_count; i++)
323  			{
324  				std::vector&lt;uint8_t&gt; buff (1);
325  				channel.send_buffer (
326  				nano::shared_const_buffer (std::move (buff)), [&amp;write_completion, client] (boost::system::error_code const &amp; ec, size_t size_a) mutable {
327  					client.reset ();
328  					write_completion.increment ();
329  				},
330  				drop_policy);
331  			}
332  		});
333  		ASSERT_FALSE (write_completion.await_count_for (std::chrono::seconds (5)));
334  		ASSERT_EQ (1, client.use_count ());
335  	};
336  	func (nano::transport::socket::default_max_queue_size * 2 + 1, nano::transport::buffer_drop_policy::no_socket_drop);
337  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
338  	ASSERT_EQ (0, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
339  	func (nano::transport::socket::default_max_queue_size + 1, nano::transport::buffer_drop_policy::limiter);
340  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_no_socket_drop, nano::stat::dir::out));
341  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_drop, nano::stat::dir::out));
342  	node-&gt;stop ();
343  	runner.stop_event_processing ();
344  	runner.join ();
345  }
346  TEST (socket, concurrent_writes)
347  {
348  	nano::test::system system;
349  	auto node_flags = nano::inactive_node_flag_defaults ();
350  	node_flags.read_only = false;
351  	node_flags.disable_max_peers_per_ip = true;
352  	node_flags.disable_max_peers_per_subnetwork = true;
353  	nano::inactive_node inactivenode (nano::unique_path (), node_flags);
354  	auto node = inactivenode.node;
355  	nano::thread_runner runner (node-&gt;io_ctx, 1);
356  	constexpr size_t max_connections = 4;
357  	constexpr size_t client_count = max_connections;
358  	constexpr size_t message_count = 4;
359  	constexpr size_t total_message_count = client_count * message_count;
360  	nano::test::counted_completion read_count_completion (total_message_count);
361  	std::function&lt;void (std::shared_ptr&lt;nano::transport::socket&gt; const &amp;)&gt; reader = [&amp;read_count_completion, &amp;total_message_count, &amp;reader] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; socket_a) {
362  		auto buff (std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; ());
363  		buff-&gt;resize (1);
364  		socket_a-&gt;async_read (buff, 1, [&amp;read_count_completion, &amp;reader, &amp;total_message_count, socket_a, buff] (boost::system::error_code const &amp; ec, size_t size_a) {
365  			if (!ec)
366  			{
367  				if (read_count_completion.increment () &lt; total_message_count)
368  				{
369  					reader (socket_a);
370  				}
371  			}
372  			else if (ec != boost::asio::error::eof)
373  			{
374  				std::cerr &lt;&lt; &quot;async_read: &quot; &lt;&lt; ec.message () &lt;&lt; std::endl;
375  			}
376  		});
377  	};
378  	auto server_port (system.get_available_port ());
379  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::any (), server_port);
380  	auto server_socket = std::make_shared&lt;nano::transport::server_socket&gt; (*node, endpoint, max_connections);
381  	boost::system::error_code ec;
382  	server_socket-&gt;start (ec);
383  	ASSERT_FALSE (ec);
384  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; connections;
385  	server_socket-&gt;on_connection ([&amp;connections, &amp;reader] (std::shared_ptr&lt;nano::transport::socket&gt; const &amp; new_connection, boost::system::error_code const &amp; ec_a) {
386  		if (ec_a)
387  		{
388  			std::cerr &lt;&lt; &quot;on_connection: &quot; &lt;&lt; ec_a.message () &lt;&lt; std::endl;
389  		}
390  		else
391  		{
392  			connections.push_back (new_connection);
393  			reader (new_connection);
394  		}
395  		return true;
396  	});
397  	nano::test::counted_completion connection_count_completion (client_count);
398  	std::vector&lt;std::shared_ptr&lt;nano::transport::socket&gt;&gt; clients;
399  	for (unsigned i = 0; i &lt; client_count; i++)
400  	{
401  		auto client = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
402  		clients.push_back (client);
403  		client-&gt;async_connect (boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v4::loopback (), server_socket-&gt;listening_port ()),
404  		[&amp;connection_count_completion] (boost::system::error_code const &amp; ec_a) {
405  			if (ec_a)
406  			{
407  				std::cerr &lt;&lt; &quot;async_connect: &quot; &lt;&lt; ec_a.message () &lt;&lt; std::endl;
408  			}
409  			else
410  			{
411  				connection_count_completion.increment ();
412  			}
413  		});
414  	}
415  	ASSERT_FALSE (connection_count_completion.await_count_for (10s));
416  	auto client (clients[0]);
417  	std::vector&lt;std::thread&gt; client_threads;
418  	for (int i = 0; i &lt; client_count; i++)
419  	{
420  		client_threads.emplace_back ([&amp;client, &amp;message_count] () {
421  			for (int i = 0; i &lt; message_count; i++)
422  			{
423  				std::vector&lt;uint8_t&gt; buff;
424  				buff.push_back (&#x27;A&#x27; + i);
425  				client-&gt;async_write (nano::shared_const_buffer (std::move (buff)));
426  			}
427  		});
428  	}
429  	ASSERT_FALSE (read_count_completion.await_count_for (10s));
430  	node-&gt;stop ();
431  	runner.stop_event_processing ();
432  	runner.join ();
433  	ASSERT_EQ (node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_success, nano::stat::dir::in), client_count);
434  	ASSERT_LT (node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_accept_failure, nano::stat::dir::in), client_count);
435  	for (auto &amp; t : client_threads)
436  	{
437  		t.join ();
438  	}
439  }
440  TEST (socket_timeout, connect)
441  {
442  	nano::test::system system (1);
443  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
444  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (1);
445  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::make_address_v6 (&quot;::ffff:10.255.254.253&quot;), 1234);
446  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
447  	std::atomic&lt;bool&gt; done = false;
448  	boost::system::error_code ec;
449  	socket-&gt;async_connect (endpoint, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
450  		if (ec_a)
451  		{
452  			ec = ec_a;
453  			done = true;
454  		}
455  	});
456  	ASSERT_TIMELY (6s, done == true);
457  	ASSERT_TRUE (ec);
458  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_connect_error, nano::stat::dir::in));
459  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
460  }
461  TEST (socket_timeout, read)
462  {
463  	nano::test::system system (1);
464  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
465  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
466  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
467  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
468  	acceptor.open (endpoint.protocol ());
469  	acceptor.bind (endpoint);
470  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
471  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
472  	acceptor.async_accept (newsock, [] (boost::system::error_code const &amp; ec_a) {
473  		EXPECT_FALSE (ec_a);
474  	});
475  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
476  	std::atomic&lt;bool&gt; done = false;
477  	boost::system::error_code ec;
478  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
479  		EXPECT_FALSE (ec_a);
480  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
481  		socket-&gt;async_read (buffer, 1, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
482  			if (ec_a)
483  			{
484  				ec = ec_a;
485  				done = true;
486  			}
487  		});
488  	});
489  	ASSERT_TIMELY (10s, done == true);
490  	ASSERT_TRUE (ec);
491  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
492  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
493  }
494  TEST (socket_timeout, write)
495  {
496  	nano::test::system system (1);
497  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
498  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
499  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
500  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
501  	acceptor.open (endpoint.protocol ());
502  	acceptor.bind (endpoint);
503  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
504  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
505  	acceptor.async_accept (newsock, [] (boost::system::error_code const &amp; ec_a) {
506  		EXPECT_FALSE (ec_a);
507  	});
508  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node, 1024 * 64); 
509  	std::atomic&lt;bool&gt; done = false;
510  	boost::system::error_code ec;
511  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
512  		EXPECT_FALSE (ec_a);
513  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (128 * 1024);
514  		for (auto i = 0; i &lt; 1024; ++i)
515  		{
516  			socket-&gt;async_write (nano::shared_const_buffer{ buffer }, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
517  				if (ec_a)
518  				{
519  					ec = ec_a;
520  					done = true;
521  				}
522  			});
523  		}
524  	});
525  	ASSERT_TIMELY (10s, done == true);
526  	ASSERT_TRUE (ec);
527  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
528  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
529  }
530  TEST (socket_timeout, read_overlapped)
531  {
532  	nano::test::system system (1);
533  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
534  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
535  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
536  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
537  	acceptor.open (endpoint.protocol ());
538  	acceptor.bind (endpoint);
539  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
540  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
541  	acceptor.async_accept (newsock, [&amp;newsock] (boost::system::error_code const &amp; ec_a) {
542  		EXPECT_FALSE (ec_a);
543  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
544  		nano::async_write (newsock, nano::shared_const_buffer (buffer), [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
545  			debug_assert (!ec_a);
546  			debug_assert (size_a == 1);
547  		});
548  	});
549  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node);
550  	std::atomic&lt;bool&gt; done = false;
551  	boost::system::error_code ec;
552  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
553  		EXPECT_FALSE (ec_a);
554  		auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
555  		socket-&gt;async_read (buffer, 1, [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
556  			debug_assert (size_a == 1);
557  		});
558  		socket-&gt;async_read (buffer, 1, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
559  			debug_assert (size_a == 0);
560  			if (ec_a)
561  			{
562  				ec = ec_a;
563  				done = true;
564  			}
565  		});
566  	});
567  	ASSERT_TIMELY (10s, done == true);
568  	ASSERT_TRUE (ec);
569  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_read_error, nano::stat::dir::in));
570  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
571  }
572  TEST (socket_timeout, write_overlapped)
573  {
574  	nano::test::system system (1);
575  	std::shared_ptr&lt;nano::node&gt; node = system.nodes[0];
576  	node-&gt;config.tcp_io_timeout = std::chrono::seconds (2);
577  	boost::asio::ip::tcp::endpoint endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
578  	boost::asio::ip::tcp::acceptor acceptor (system.io_ctx);
579  	acceptor.open (endpoint.protocol ());
580  	acceptor.bind (endpoint);
581  	acceptor.listen (boost::asio::socket_base::max_listen_connections);
582  	boost::asio::ip::tcp::socket newsock (system.io_ctx);
583  	auto buffer = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
584  	acceptor.async_accept (newsock, [&amp;newsock, &amp;buffer] (boost::system::error_code const &amp; ec_a) {
585  		EXPECT_FALSE (ec_a);
586  		boost::asio::async_read (newsock, boost::asio::buffer (buffer-&gt;data (), buffer-&gt;size ()), [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
587  			debug_assert (size_a == 1);
588  		});
589  	});
590  	auto socket = std::make_shared&lt;nano::transport::client_socket&gt; (*node, 1024 * 64); 
591  	std::atomic&lt;bool&gt; done = false;
592  	boost::system::error_code ec;
593  	socket-&gt;async_connect (acceptor.local_endpoint (), [&amp;socket, &amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a) {
594  		EXPECT_FALSE (ec_a);
595  		auto buffer1 = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (1);
596  		auto buffer2 = std::make_shared&lt;std::vector&lt;uint8_t&gt;&gt; (128 * 1024);
597  		socket-&gt;async_write (nano::shared_const_buffer{ buffer1 }, [] (boost::system::error_code const &amp; ec_a, size_t size_a) {
598  			debug_assert (size_a == 1);
599  		});
600  		for (auto i = 0; i &lt; 1024; ++i)
601  		{
602  			socket-&gt;async_write (nano::shared_const_buffer{ buffer2 }, [&amp;ec, &amp;done] (boost::system::error_code const &amp; ec_a, size_t size_a) {
603  				if (ec_a)
604  				{
605  					ec = ec_a;
<span onclick='openModal()' class='match'>606  					done = true;
607  				}
608  			});
609  		}
610  	});
611  	ASSERT_TIMELY (10s, done == true);
612  	ASSERT_TRUE (ec);
613  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
614  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
615  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-socket.cpp</div>
                </div>
                <div class="column column_space"><pre><code>520  					done = true;
521  				}
522  			});
523  		}
524  	});
525  	ASSERT_TIMELY (10s, done == true);
526  	ASSERT_TRUE (ec);
527  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
528  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
529  }
530  TEST (socket_timeout, read_overlapped)
</pre></code></div>
                <div class="column column_space"><pre><code>606  					done = true;
607  				}
608  			});
609  		}
610  	});
611  	ASSERT_TIMELY (10s, done == true);
612  	ASSERT_TRUE (ec);
613  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_write_error, nano::stat::dir::in));
614  	ASSERT_EQ (1, node-&gt;stats.count (nano::stat::type::tcp, nano::stat::detail::tcp_io_timeout_drop, nano::stat::dir::out));
615  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    