
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.434180138568129%, Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</h3>
            <pre><code>1  #include "absl/strings/numbers.h"
2  #include <sys/types.h>
3  #include <cfenv>  
4  #include <cfloat>
5  #include <cinttypes>
6  #include <climits>
7  #include <cmath>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstdlib>
12  #include <cstring>
13  #include <limits>
14  #include <numeric>
15  #include <random>
16  #include <set>
17  #include <string>
18  #include <vector>
19  #include "gmock/gmock.h"
20  #include "gtest/gtest.h"
21  #include "absl/log/log.h"
22  #include "absl/random/distributions.h"
23  #include "absl/random/random.h"
24  #include "absl/strings/internal/numbers_test_common.h"
25  #include "absl/strings/internal/ostringstream.h"
26  #include "absl/strings/internal/pow10_helper.h"
27  #include "absl/strings/str_cat.h"
28  namespace {
29  using absl::SimpleAtoi;
30  using absl::SimpleHexAtoi;
31  using absl::numbers_internal::kSixDigitsToBufferSize;
32  using absl::numbers_internal::safe_strto32_base;
33  using absl::numbers_internal::safe_strto64_base;
34  using absl::numbers_internal::safe_strtou32_base;
35  using absl::numbers_internal::safe_strtou64_base;
36  using absl::numbers_internal::SixDigitsToBuffer;
37  using absl::strings_internal::Itoa;
38  using absl::strings_internal::strtouint32_test_cases;
39  using absl::strings_internal::strtouint64_test_cases;
40  using testing::Eq;
41  using testing::MatchesRegex;
42  const int kFloatNumCases = 5000000;
43  std::string PerfectDtoa(double d) {
44    if (d == 0) return "0";
45    if (d < 0) return "-" + PerfectDtoa(-d);
46    int64_t mantissa, exp = 0;
47    while (d >= 1ULL << 63) ++exp, d *= 0.5;
48    while ((mantissa = d) != d) --exp, d *= 2.0;
49    constexpr int maxlen = 1100;  
50    char buf[maxlen + 5];
51    for (int64_t num = mantissa, pos = maxlen; --pos >= 0;) {
52      buf[pos] = '0' + (num % 10);
53      num /= 10;
54    }
55    char* begin = &buf[0];
56    char* end = buf + maxlen;
57    for (int i = 0; i != exp; i += (exp > 0) ? 1 : -1) {
58      int carry = 0;
59      for (char* p = end; --p != begin;) {
60        int dig = *p - '0';
61        dig = dig * (exp > 0 ? 2 : 5) + carry;
62        carry = dig / 10;
63        dig %= 10;
64        *p = '0' + dig;
65      }
66    }
67    if (exp < 0) {
68      memmove(end + 1 + exp, end + exp, 1 - exp);
69      end[exp] = '.';
70      ++end;
71    }
72    while (*begin == '0' && begin[1] != '.') ++begin;
73    return {begin, end};
74  }
75  TEST(ToString, PerfectDtoa) {
76    EXPECT_THAT(PerfectDtoa(1), Eq("1"));
77    EXPECT_THAT(PerfectDtoa(0.1),
78                Eq("0.1000000000000000055511151231257827021181583404541015625"));
79    EXPECT_THAT(PerfectDtoa(1e24), Eq("999999999999999983222784"));
80    EXPECT_THAT(PerfectDtoa(5e-324), MatchesRegex("0.0000.*625"));
81    for (int i = 0; i < 100; ++i) {
82      for (double multiplier :
83           {1e-300, 1e-200, 1e-100, 0.1, 1.0, 10.0, 1e100, 1e300}) {
84        double d = multiplier * i;
85        std::string s = PerfectDtoa(d);
86        EXPECT_DOUBLE_EQ(d, strtod(s.c_str(), nullptr));
87      }
88    }
89  }
90  template <typename integer>
91  struct MyInteger {
92    integer i;
93    explicit constexpr MyInteger(integer i) : i(i) {}
94    constexpr operator integer() const { return i; }
95    constexpr MyInteger operator+(MyInteger other) const { return i + other.i; }
96    constexpr MyInteger operator-(MyInteger other) const { return i - other.i; }
97    constexpr MyInteger operator*(MyInteger other) const { return i * other.i; }
98    constexpr MyInteger operator/(MyInteger other) const { return i / other.i; }
99    constexpr bool operator<(MyInteger other) const { return i < other.i; }
100    constexpr bool operator<=(MyInteger other) const { return i <= other.i; }
101    constexpr bool operator==(MyInteger other) const { return i == other.i; }
102    constexpr bool operator>=(MyInteger other) const { return i >= other.i; }
103    constexpr bool operator>(MyInteger other) const { return i > other.i; }
104    constexpr bool operator!=(MyInteger other) const { return i != other.i; }
105    integer as_integer() const { return i; }
106  };
107  typedef MyInteger<int64_t> MyInt64;
108  typedef MyInteger<uint64_t> MyUInt64;
109  void CheckInt32(int32_t x) {
110    char buffer[absl::numbers_internal::kFastToBufferSize];
111    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
112    std::string expected = std::to_string(x);
113    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
114    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
115    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
116  }
117  void CheckInt64(int64_t x) {
118    char buffer[absl::numbers_internal::kFastToBufferSize + 3];
119    buffer[0] = '*';
120    buffer[23] = '*';
121    buffer[24] = '*';
122    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
123    std::string expected = std::to_string(x);
124    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
125    EXPECT_EQ(buffer[0], '*');
126    EXPECT_EQ(buffer[23], '*');
127    EXPECT_EQ(buffer[24], '*');
128    char* my_actual =
129        absl::numbers_internal::FastIntToBuffer(MyInt64(x), &buffer[1]);
130    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
131  }
132  void CheckUInt32(uint32_t x) {
133    char buffer[absl::numbers_internal::kFastToBufferSize];
134    char* actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
135    std::string expected = std::to_string(x);
136    EXPECT_EQ(expected, std::string(buffer, actual)) << " Input " << x;
137    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, buffer);
138    EXPECT_EQ(expected, std::string(buffer, generic_actual)) << " Input " << x;
139  }
140  void CheckUInt64(uint64_t x) {
141    char buffer[absl::numbers_internal::kFastToBufferSize + 1];
142    char* actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
143    std::string expected = std::to_string(x);
144    EXPECT_EQ(expected, std::string(&buffer[1], actual)) << " Input " << x;
145    char* generic_actual = absl::numbers_internal::FastIntToBuffer(x, &buffer[1]);
146    EXPECT_EQ(expected, std::string(&buffer[1], generic_actual))
147        << " Input " << x;
148    char* my_actual =
149        absl::numbers_internal::FastIntToBuffer(MyUInt64(x), &buffer[1]);
150    EXPECT_EQ(expected, std::string(&buffer[1], my_actual)) << " Input " << x;
151  }
152  void CheckHex64(uint64_t v) {
153    char expected[16 + 1];
154    std::string actual = absl::StrCat(absl::Hex(v, absl::kZeroPad16));
155    snprintf(expected, sizeof(expected), "%016" PRIx64, static_cast<uint64_t>(v));
156    EXPECT_EQ(expected, actual) << " Input " << v;
157    actual = absl::StrCat(absl::Hex(v, absl::kSpacePad16));
158    snprintf(expected, sizeof(expected), "%16" PRIx64, static_cast<uint64_t>(v));
159    EXPECT_EQ(expected, actual) << " Input " << v;
160  }
161  TEST(Numbers, TestFastPrints) {
162    for (int i = -100; i <= 100; i++) {
163      CheckInt32(i);
164      CheckInt64(i);
165    }
<span onclick='openModal()' class='match'>166    for (int i = 0; i <= 100; i++) {
167      CheckUInt32(i);
168      CheckUInt64(i);
169    }
170    CheckInt32(INT_MIN);
171    CheckInt32(INT_MAX);
172    CheckInt64(LONG_MIN);
173    CheckInt64(uint64_t{1000000000});
174    CheckInt64(uint64_t{9999999999});
175    CheckInt64(uint64_t{100000000000000});
176    CheckInt64(uint64_t{999999999999999});
177    CheckInt64(uint64_t{1000000000000000000});
178    CheckInt64(uint64_t{1199999999999999999});
179    CheckInt64(int64_t{-700000000000000000});
180    CheckInt64(LONG_MAX);
181    CheckUInt32(std::numeric_limits<uint32_t>::max());
182    CheckUInt64(uint64_t{1000000000});
183    CheckUInt64(uint64_t{9999999999});
184    CheckUInt64(uint64_t{100000000000000});
185    CheckUInt64(uint64_t{999999999999999});
186    CheckUInt64(uint64_t{1000000000000000000});
187    CheckUInt64(uint64_t{1199999999999999999});
</span>188    CheckUInt64(std::numeric_limits<uint64_t>::max());
189    for (int i = 0; i < 10000; i++) {
190      CheckHex64(i);
191    }
192    CheckHex64(uint64_t{0x123456789abcdef0});
193  }
194  template <typename int_type, typename in_val_type>
195  void VerifySimpleAtoiGood(in_val_type in_value, int_type exp_value) {
196    std::string s;
197    absl::strings_internal::OStringStream(&s) << in_value;
198    int_type x = static_cast<int_type>(~exp_value);
199    EXPECT_TRUE(SimpleAtoi(s, &x))
200        << "in_value=" << in_value << " s=" << s << " x=" << x;
201    EXPECT_EQ(exp_value, x);
202    x = static_cast<int_type>(~exp_value);
203    EXPECT_TRUE(SimpleAtoi(s.c_str(), &x));
204    EXPECT_EQ(exp_value, x);
205  }
206  template <typename int_type, typename in_val_type>
207  void VerifySimpleAtoiBad(in_val_type in_value) {
208    std::string s;
209    absl::strings_internal::OStringStream(&s) << in_value;
210    int_type x;
211    EXPECT_FALSE(SimpleAtoi(s, &x));
212    EXPECT_FALSE(SimpleAtoi(s.c_str(), &x));
213  }
214  TEST(NumbersTest, Atoi) {
215    VerifySimpleAtoiGood<int32_t>(0, 0);
216    VerifySimpleAtoiGood<int32_t>(42, 42);
217    VerifySimpleAtoiGood<int32_t>(-42, -42);
218    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
219                                  std::numeric_limits<int32_t>::min());
220    VerifySimpleAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
221                                  std::numeric_limits<int32_t>::max());
222    VerifySimpleAtoiGood<uint32_t>(0, 0);
223    VerifySimpleAtoiGood<uint32_t>(42, 42);
224    VerifySimpleAtoiBad<uint32_t>(-42);
225    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
226    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
227                                   std::numeric_limits<int32_t>::max());
228    VerifySimpleAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
229                                   std::numeric_limits<uint32_t>::max());
230    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
231    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
232    VerifySimpleAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
233    VerifySimpleAtoiGood<int64_t>(0, 0);
234    VerifySimpleAtoiGood<int64_t>(42, 42);
235    VerifySimpleAtoiGood<int64_t>(-42, -42);
236    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
237                                  std::numeric_limits<int32_t>::min());
238    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
239                                  std::numeric_limits<int32_t>::max());
240    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
241                                  std::numeric_limits<uint32_t>::max());
242    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
243                                  std::numeric_limits<int64_t>::min());
244    VerifySimpleAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
245                                  std::numeric_limits<int64_t>::max());
246    VerifySimpleAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
247    VerifySimpleAtoiGood<uint64_t>(0, 0);
248    VerifySimpleAtoiGood<uint64_t>(42, 42);
249    VerifySimpleAtoiBad<uint64_t>(-42);
250    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
251    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
252                                   std::numeric_limits<int32_t>::max());
253    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
254                                   std::numeric_limits<uint32_t>::max());
255    VerifySimpleAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
256    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
257                                   std::numeric_limits<int64_t>::max());
258    VerifySimpleAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
259                                   std::numeric_limits<uint64_t>::max());
260    VerifySimpleAtoiGood<absl::uint128>(0, 0);
261    VerifySimpleAtoiGood<absl::uint128>(42, 42);
262    VerifySimpleAtoiBad<absl::uint128>(-42);
263    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
264    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
265                                        std::numeric_limits<int32_t>::max());
266    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
267                                        std::numeric_limits<uint32_t>::max());
268    VerifySimpleAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
269    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
270                                        std::numeric_limits<int64_t>::max());
271    VerifySimpleAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
272                                        std::numeric_limits<uint64_t>::max());
273    VerifySimpleAtoiGood<absl::uint128>(
274        std::numeric_limits<absl::uint128>::max(),
275        std::numeric_limits<absl::uint128>::max());
276    VerifySimpleAtoiGood<absl::int128>(0, 0);
277    VerifySimpleAtoiGood<absl::int128>(42, 42);
278    VerifySimpleAtoiGood<absl::int128>(-42, -42);
279    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::min(),
280                                        std::numeric_limits<int32_t>::min());
281    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int32_t>::max(),
282                                        std::numeric_limits<int32_t>::max());
283    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint32_t>::max(),
284                                        std::numeric_limits<uint32_t>::max());
285    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::min(),
286                                        std::numeric_limits<int64_t>::min());
287    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<int64_t>::max(),
288                                        std::numeric_limits<int64_t>::max());
289    VerifySimpleAtoiGood<absl::int128>(std::numeric_limits<uint64_t>::max(),
290                                        std::numeric_limits<uint64_t>::max());
291    VerifySimpleAtoiGood<absl::int128>(
292        std::numeric_limits<absl::int128>::min(),
293        std::numeric_limits<absl::int128>::min());
294    VerifySimpleAtoiGood<absl::int128>(
295        std::numeric_limits<absl::int128>::max(),
296        std::numeric_limits<absl::int128>::max());
297    VerifySimpleAtoiBad<absl::int128>(std::numeric_limits<absl::uint128>::max());
298    VerifySimpleAtoiGood<int>(-42, -42);
299    VerifySimpleAtoiGood<int32_t>(-42, -42);
300    VerifySimpleAtoiGood<uint32_t>(42, 42);
301    VerifySimpleAtoiGood<unsigned int>(42, 42);
302    VerifySimpleAtoiGood<int64_t>(-42, -42);
303    VerifySimpleAtoiGood<long>(-42, -42);  
304    VerifySimpleAtoiGood<uint64_t>(42, 42);
305    VerifySimpleAtoiGood<size_t>(42, 42);
306    VerifySimpleAtoiGood<std::string::size_type>(42, 42);
307  }
308  TEST(NumbersTest, Atod) {
309  #if !defined(DBL_TRUE_MIN)
310    static constexpr double DBL_TRUE_MIN =
311        4.940656458412465441765687928682213723650598026143247644255856825e-324;
312  #endif
313  #if !defined(FLT_TRUE_MIN)
314    static constexpr float FLT_TRUE_MIN =
315        1.401298464324817070923729583289916131280261941876515771757068284e-45f;
316  #endif
317    double d;
318    float f;
319    EXPECT_TRUE(absl::SimpleAtod("NaN", &d));
320    EXPECT_TRUE(std::isnan(d));
321    EXPECT_TRUE(absl::SimpleAtod("nAN", &d));
322    EXPECT_TRUE(std::isnan(d));
323    EXPECT_TRUE(absl::SimpleAtod("-nan", &d));
324    EXPECT_TRUE(std::isnan(d));
325    EXPECT_TRUE(absl::SimpleAtod("inf", &d));
326    EXPECT_TRUE(std::isinf(d) && (d > 0));
327    EXPECT_TRUE(absl::SimpleAtod("+Infinity", &d));
328    EXPECT_TRUE(std::isinf(d) && (d > 0));
329    EXPECT_TRUE(absl::SimpleAtod("-INF", &d));
330    EXPECT_TRUE(std::isinf(d) && (d < 0));
331    EXPECT_TRUE(absl::SimpleAtod("1.7976931348623157e+308", &d));
332    EXPECT_EQ(d, 1.7976931348623157e+308);
333    EXPECT_TRUE(absl::SimpleAtod("5e308", &d));
334    EXPECT_TRUE(std::isinf(d) && (d > 0));
335    EXPECT_TRUE(absl::SimpleAtof("3.4028234663852886e+38", &f));
336    EXPECT_EQ(f, 3.4028234663852886e+38f);
337    EXPECT_TRUE(absl::SimpleAtof("7e38", &f));
338    EXPECT_TRUE(std::isinf(f) && (f > 0));
339    EXPECT_TRUE(absl::SimpleAtod("1e308", &d));
340    EXPECT_EQ(d, 1e308);
341    EXPECT_FALSE(std::isinf(d));
342    EXPECT_TRUE(absl::SimpleAtod("1e309", &d));
343    EXPECT_TRUE(std::isinf(d));
344    EXPECT_TRUE(absl::SimpleAtof("1e38", &f));
345    EXPECT_EQ(f, 1e38f);
346    EXPECT_FALSE(std::isinf(f));
347    EXPECT_TRUE(absl::SimpleAtof("1e39", &f));
348    EXPECT_TRUE(std::isinf(f));
349    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e307", &d));
350    EXPECT_EQ(d, 9.999999999999999999e307);
351    EXPECT_FALSE(std::isinf(d));
352    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e308", &d));
353    EXPECT_TRUE(std::isinf(d));
354    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e37", &f));
355    EXPECT_EQ(f, 9.999999999999999999e37f);
356    EXPECT_FALSE(std::isinf(f));
357    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e38", &f));
358    EXPECT_TRUE(std::isinf(f));
359    EXPECT_TRUE(absl::SimpleAtod("2.2250738585072014e-308", &d));
360    EXPECT_EQ(d, 2.2250738585072014e-308);
361    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-324", &d));
362    EXPECT_EQ(d, 4.9406564584124654e-324);
363    EXPECT_TRUE(absl::SimpleAtod("4.9406564584124654e-325", &d));
364    EXPECT_EQ(d, 0);
365    EXPECT_TRUE(absl::SimpleAtof("1.1754943508222875e-38", &f));
366    EXPECT_EQ(f, 1.1754943508222875e-38f);
367    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-45", &f));
368    EXPECT_EQ(f, 1.4012984643248171e-45f);
369    EXPECT_TRUE(absl::SimpleAtof("1.4012984643248171e-46", &f));
370    EXPECT_EQ(f, 0);
371    EXPECT_TRUE(absl::SimpleAtod("1e-307", &d));
372    EXPECT_EQ(d, 1e-307);
373    EXPECT_GE(d, DBL_MIN);
374    EXPECT_LT(d, DBL_MIN * 10);
375    EXPECT_TRUE(absl::SimpleAtod("1e-323", &d));
376    EXPECT_EQ(d, 1e-323);
377    EXPECT_GE(d, DBL_TRUE_MIN);
378    EXPECT_LT(d, DBL_TRUE_MIN * 10);
379    EXPECT_TRUE(absl::SimpleAtod("1e-324", &d));
380    EXPECT_EQ(d, 0);
381    EXPECT_TRUE(absl::SimpleAtof("1e-37", &f));
382    EXPECT_EQ(f, 1e-37f);
383    EXPECT_GE(f, FLT_MIN);
384    EXPECT_LT(f, FLT_MIN * 10);
385    EXPECT_TRUE(absl::SimpleAtof("1e-45", &f));
386    EXPECT_EQ(f, 1e-45f);
387    EXPECT_GE(f, FLT_TRUE_MIN);
388    EXPECT_LT(f, FLT_TRUE_MIN * 10);
389    EXPECT_TRUE(absl::SimpleAtof("1e-46", &f));
390    EXPECT_EQ(f, 0);
391    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-308", &d));
392    EXPECT_EQ(d, 9.999999999999999999e-308);
393    EXPECT_GE(d, DBL_MIN);
394    EXPECT_LT(d, DBL_MIN * 10);
395    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-324", &d));
396    EXPECT_EQ(d, 9.999999999999999999e-324);
397    EXPECT_GE(d, DBL_TRUE_MIN);
398    EXPECT_LT(d, DBL_TRUE_MIN * 10);
399    EXPECT_TRUE(absl::SimpleAtod("9.999999999999999999e-325", &d));
400    EXPECT_EQ(d, 0);
401    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-38", &f));
402    EXPECT_EQ(f, 9.999999999999999999e-38f);
403    EXPECT_GE(f, FLT_MIN);
404    EXPECT_LT(f, FLT_MIN * 10);
405    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-46", &f));
406    EXPECT_EQ(f, 9.999999999999999999e-46f);
407    EXPECT_GE(f, FLT_TRUE_MIN);
408    EXPECT_LT(f, FLT_TRUE_MIN * 10);
409    EXPECT_TRUE(absl::SimpleAtof("9.999999999999999999e-47", &f));
410    EXPECT_EQ(f, 0);
411    EXPECT_TRUE(absl::SimpleAtod("  \t\r\n  2.718", &d));
412    EXPECT_EQ(d, 2.718);
413    EXPECT_TRUE(absl::SimpleAtod("  3.141  ", &d));
414    EXPECT_EQ(d, 3.141);
415    EXPECT_FALSE(absl::SimpleAtod("n 0", &d));
416    EXPECT_FALSE(absl::SimpleAtod("0n ", &d));
417    EXPECT_TRUE(absl::SimpleAtod("000123", &d));
418    EXPECT_EQ(d, 123);
419    EXPECT_TRUE(absl::SimpleAtod("000.456", &d));
420    EXPECT_EQ(d, 0.456);
421    EXPECT_TRUE(absl::SimpleAtod(".5", &d));
422    EXPECT_EQ(d, 0.5);
423    EXPECT_TRUE(absl::SimpleAtod("-.707", &d));
424    EXPECT_EQ(d, -0.707);
425    EXPECT_TRUE(absl::SimpleAtod("+6.0221408e+23", &d));
426    EXPECT_EQ(d, 6.0221408e+23);
427    EXPECT_FALSE(absl::SimpleAtod("123_456", &d));
428    EXPECT_TRUE(absl::SimpleAtod("8.9", &d));
429    EXPECT_FALSE(absl::SimpleAtod("8,9", &d));
430    EXPECT_TRUE(absl::SimpleAtod("4503599627370497.5", &d));
431    EXPECT_EQ(d, 4503599627370497.5);
432    EXPECT_TRUE(absl::SimpleAtod("1e+23", &d));
433    EXPECT_EQ(d, 1e+23);
434    EXPECT_TRUE(absl::SimpleAtod("9223372036854775807", &d));
435    EXPECT_EQ(d, 9223372036854775807);
436    EXPECT_TRUE(absl::SimpleAtof("0.0625", &f));
437    EXPECT_EQ(f, 0.0625f);
438    EXPECT_TRUE(absl::SimpleAtof("20040229.0", &f));
439    EXPECT_EQ(f, 20040229.0f);
440    EXPECT_TRUE(absl::SimpleAtof("2147483647.0", &f));
441    EXPECT_EQ(f, 2147483647.0f);
442    EXPECT_TRUE(absl::SimpleAtod("122.416294033786585", &d));
443    EXPECT_EQ(d, 122.416294033786585);
444    EXPECT_TRUE(absl::SimpleAtof("122.416294033786585", &f));
445    EXPECT_EQ(f, 122.416294033786585f);
446  }
447  TEST(NumbersTest, Prefixes) {
448    double d;
449    EXPECT_FALSE(absl::SimpleAtod("++1", &d));
450    EXPECT_FALSE(absl::SimpleAtod("+-1", &d));
451    EXPECT_FALSE(absl::SimpleAtod("-+1", &d));
452    EXPECT_FALSE(absl::SimpleAtod("--1", &d));
453    EXPECT_TRUE(absl::SimpleAtod("-1", &d));
454    EXPECT_EQ(d, -1.);
455    EXPECT_TRUE(absl::SimpleAtod("+1", &d));
456    EXPECT_EQ(d, +1.);
457    float f;
458    EXPECT_FALSE(absl::SimpleAtof("++1", &f));
459    EXPECT_FALSE(absl::SimpleAtof("+-1", &f));
460    EXPECT_FALSE(absl::SimpleAtof("-+1", &f));
461    EXPECT_FALSE(absl::SimpleAtof("--1", &f));
462    EXPECT_TRUE(absl::SimpleAtof("-1", &f));
463    EXPECT_EQ(f, -1.f);
464    EXPECT_TRUE(absl::SimpleAtof("+1", &f));
465    EXPECT_EQ(f, +1.f);
466  }
467  TEST(NumbersTest, Atoenum) {
468    enum E01 {
469      E01_zero = 0,
470      E01_one = 1,
471    };
472    VerifySimpleAtoiGood<E01>(E01_zero, E01_zero);
473    VerifySimpleAtoiGood<E01>(E01_one, E01_one);
474    enum E_101 {
475      E_101_minusone = -1,
476      E_101_zero = 0,
477      E_101_one = 1,
478    };
479    VerifySimpleAtoiGood<E_101>(E_101_minusone, E_101_minusone);
480    VerifySimpleAtoiGood<E_101>(E_101_zero, E_101_zero);
481    VerifySimpleAtoiGood<E_101>(E_101_one, E_101_one);
482    enum E_bigint {
483      E_bigint_zero = 0,
484      E_bigint_one = 1,
485      E_bigint_max31 = static_cast<int32_t>(0x7FFFFFFF),
486    };
487    VerifySimpleAtoiGood<E_bigint>(E_bigint_zero, E_bigint_zero);
488    VerifySimpleAtoiGood<E_bigint>(E_bigint_one, E_bigint_one);
489    VerifySimpleAtoiGood<E_bigint>(E_bigint_max31, E_bigint_max31);
490    enum E_fullint {
491      E_fullint_zero = 0,
492      E_fullint_one = 1,
493      E_fullint_max31 = static_cast<int32_t>(0x7FFFFFFF),
494      E_fullint_min32 = INT32_MIN,
495    };
496    VerifySimpleAtoiGood<E_fullint>(E_fullint_zero, E_fullint_zero);
497    VerifySimpleAtoiGood<E_fullint>(E_fullint_one, E_fullint_one);
498    VerifySimpleAtoiGood<E_fullint>(E_fullint_max31, E_fullint_max31);
499    VerifySimpleAtoiGood<E_fullint>(E_fullint_min32, E_fullint_min32);
500    enum E_biguint {
501      E_biguint_zero = 0,
502      E_biguint_one = 1,
503      E_biguint_max31 = static_cast<uint32_t>(0x7FFFFFFF),
504      E_biguint_max32 = static_cast<uint32_t>(0xFFFFFFFF),
505    };
506    VerifySimpleAtoiGood<E_biguint>(E_biguint_zero, E_biguint_zero);
507    VerifySimpleAtoiGood<E_biguint>(E_biguint_one, E_biguint_one);
508    VerifySimpleAtoiGood<E_biguint>(E_biguint_max31, E_biguint_max31);
509    VerifySimpleAtoiGood<E_biguint>(E_biguint_max32, E_biguint_max32);
510  }
511  template <typename int_type, typename in_val_type>
512  void VerifySimpleHexAtoiGood(in_val_type in_value, int_type exp_value) {
513    std::string s;
514    absl::strings_internal::OStringStream strm(&s);
515    if (in_value >= 0) {
516      strm << std::hex << in_value;
517    } else {
518      strm << "-" << std::hex << -absl::uint128(in_value);
519    }
520    int_type x = static_cast<int_type>(~exp_value);
521    EXPECT_TRUE(SimpleHexAtoi(s, &x))
522        << "in_value=" << std::hex << in_value << " s=" << s << " x=" << x;
523    EXPECT_EQ(exp_value, x);
524    x = static_cast<int_type>(~exp_value);
525    EXPECT_TRUE(SimpleHexAtoi(
526        s.c_str(), &x));  
527    EXPECT_EQ(exp_value, x);
528  }
529  template <typename int_type, typename in_val_type>
530  void VerifySimpleHexAtoiBad(in_val_type in_value) {
531    std::string s;
532    absl::strings_internal::OStringStream strm(&s);
533    if (in_value >= 0) {
534      strm << std::hex << in_value;
535    } else {
536      strm << "-" << std::hex << -absl::uint128(in_value);
537    }
538    int_type x;
539    EXPECT_FALSE(SimpleHexAtoi(s, &x));
540    EXPECT_FALSE(SimpleHexAtoi(
541        s.c_str(), &x));  
542  }
543  TEST(NumbersTest, HexAtoi) {
544    VerifySimpleHexAtoiGood<int32_t>(0, 0);
545    VerifySimpleHexAtoiGood<int32_t>(0x42, 0x42);
546    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
547    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::min(),
548                                     std::numeric_limits<int32_t>::min());
549    VerifySimpleHexAtoiGood<int32_t>(std::numeric_limits<int32_t>::max(),
550                                     std::numeric_limits<int32_t>::max());
551    VerifySimpleHexAtoiGood<uint32_t>(0, 0);
552    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
553    VerifySimpleHexAtoiBad<uint32_t>(-0x42);
554    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int32_t>::min());
555    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<int32_t>::max(),
556                                      std::numeric_limits<int32_t>::max());
557    VerifySimpleHexAtoiGood<uint32_t>(std::numeric_limits<uint32_t>::max(),
558                                      std::numeric_limits<uint32_t>::max());
559    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::min());
560    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<int64_t>::max());
561    VerifySimpleHexAtoiBad<uint32_t>(std::numeric_limits<uint64_t>::max());
562    VerifySimpleHexAtoiGood<int64_t>(0, 0);
563    VerifySimpleHexAtoiGood<int64_t>(0x42, 0x42);
564    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
565    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::min(),
566                                     std::numeric_limits<int32_t>::min());
567    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int32_t>::max(),
568                                     std::numeric_limits<int32_t>::max());
569    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<uint32_t>::max(),
570                                     std::numeric_limits<uint32_t>::max());
571    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::min(),
572                                     std::numeric_limits<int64_t>::min());
573    VerifySimpleHexAtoiGood<int64_t>(std::numeric_limits<int64_t>::max(),
574                                     std::numeric_limits<int64_t>::max());
575    VerifySimpleHexAtoiBad<int64_t>(std::numeric_limits<uint64_t>::max());
576    VerifySimpleHexAtoiGood<uint64_t>(0, 0);
577    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
578    VerifySimpleHexAtoiBad<uint64_t>(-0x42);
579    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int32_t>::min());
580    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int32_t>::max(),
581                                      std::numeric_limits<int32_t>::max());
582    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint32_t>::max(),
583                                      std::numeric_limits<uint32_t>::max());
584    VerifySimpleHexAtoiBad<uint64_t>(std::numeric_limits<int64_t>::min());
585    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<int64_t>::max(),
586                                      std::numeric_limits<int64_t>::max());
587    VerifySimpleHexAtoiGood<uint64_t>(std::numeric_limits<uint64_t>::max(),
588                                      std::numeric_limits<uint64_t>::max());
589    VerifySimpleHexAtoiGood<absl::uint128>(0, 0);
590    VerifySimpleHexAtoiGood<absl::uint128>(0x42, 0x42);
591    VerifySimpleHexAtoiBad<absl::uint128>(-0x42);
592    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int32_t>::min());
593    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int32_t>::max(),
594                                           std::numeric_limits<int32_t>::max());
595    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint32_t>::max(),
596                                           std::numeric_limits<uint32_t>::max());
597    VerifySimpleHexAtoiBad<absl::uint128>(std::numeric_limits<int64_t>::min());
598    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<int64_t>::max(),
599                                           std::numeric_limits<int64_t>::max());
600    VerifySimpleHexAtoiGood<absl::uint128>(std::numeric_limits<uint64_t>::max(),
601                                           std::numeric_limits<uint64_t>::max());
602    VerifySimpleHexAtoiGood<absl::uint128>(
603        std::numeric_limits<absl::uint128>::max(),
604        std::numeric_limits<absl::uint128>::max());
605    VerifySimpleHexAtoiGood<int>(-0x42, -0x42);
606    VerifySimpleHexAtoiGood<int32_t>(-0x42, -0x42);
607    VerifySimpleHexAtoiGood<uint32_t>(0x42, 0x42);
608    VerifySimpleHexAtoiGood<unsigned int>(0x42, 0x42);
609    VerifySimpleHexAtoiGood<int64_t>(-0x42, -0x42);
610    VerifySimpleHexAtoiGood<long>(-0x42, -0x42);  
611    VerifySimpleHexAtoiGood<uint64_t>(0x42, 0x42);
612    VerifySimpleHexAtoiGood<size_t>(0x42, 0x42);
613    VerifySimpleHexAtoiGood<std::string::size_type>(0x42, 0x42);
614    int32_t value;
615    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
616    EXPECT_EQ(0x34234324, value);
617    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
618    EXPECT_EQ(0x34234324, value);
619    EXPECT_TRUE(safe_strto32_base(" \t\n 34234324", &value, 16));
620    EXPECT_EQ(0x34234324, value);
621    EXPECT_TRUE(safe_strto32_base("34234324 \t\n ", &value, 16));
622    EXPECT_EQ(0x34234324, value);
623  }
624  TEST(stringtest, safe_strto32_base) {
625    int32_t value;
626    EXPECT_TRUE(safe_strto32_base("0x34234324", &value, 16));
627    EXPECT_EQ(0x34234324, value);
628    EXPECT_TRUE(safe_strto32_base("0X34234324", &value, 16));
629    EXPECT_EQ(0x34234324, value);
630    EXPECT_TRUE(safe_strto32_base("34234324", &value, 16));
631    EXPECT_EQ(0x34234324, value);
632    EXPECT_TRUE(safe_strto32_base("0", &value, 16));
633    EXPECT_EQ(0, value);
634    EXPECT_TRUE(safe_strto32_base(" \t\n -0x34234324", &value, 16));
635    EXPECT_EQ(-0x34234324, value);
636    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 16));
637    EXPECT_EQ(-0x34234324, value);
638    EXPECT_TRUE(safe_strto32_base("7654321", &value, 8));
639    EXPECT_EQ(07654321, value);
640    EXPECT_TRUE(safe_strto32_base("-01234", &value, 8));
641    EXPECT_EQ(-01234, value);
642    EXPECT_FALSE(safe_strto32_base("1834", &value, 8));
643    EXPECT_TRUE(safe_strto32_base("0", &value, 0));
644    EXPECT_EQ(0, value);
645    EXPECT_TRUE(safe_strto32_base("077", &value, 0));
646    EXPECT_EQ(077, value);  
647    EXPECT_FALSE(safe_strto32_base("088", &value, 0));
648    EXPECT_FALSE(safe_strto32_base("0xG", &value, 0));
649    EXPECT_TRUE(safe_strto32_base("34234324", &value, 10));
650    EXPECT_EQ(34234324, value);
651    EXPECT_TRUE(safe_strto32_base("0", &value, 10));
652    EXPECT_EQ(0, value);
653    EXPECT_TRUE(safe_strto32_base(" \t\n -34234324", &value, 10));
654    EXPECT_EQ(-34234324, value);
655    EXPECT_TRUE(safe_strto32_base("34234324 \n\t ", &value, 10));
656    EXPECT_EQ(34234324, value);
657    EXPECT_FALSE(safe_strto32_base("", &value, 10));
658    EXPECT_FALSE(safe_strto32_base("  ", &value, 10));
659    EXPECT_FALSE(safe_strto32_base("abc", &value, 10));
660    EXPECT_FALSE(safe_strto32_base("34234324a", &value, 10));
661    EXPECT_FALSE(safe_strto32_base("34234.3", &value, 10));
662    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
663    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
664    EXPECT_TRUE(safe_strto32_base(std::string("0x1234"), &value, 16));
665    EXPECT_EQ(0x1234, value);
666    EXPECT_TRUE(safe_strto32_base("1234", &value, 10));
667    EXPECT_EQ(1234, value);
668  }
669  TEST(stringtest, safe_strto32_range) {
670    int32_t value;
671    EXPECT_FALSE(safe_strto32_base("2147483648", &value, 10));
672    EXPECT_EQ(std::numeric_limits<int32_t>::max(), value);
673    EXPECT_TRUE(safe_strto32_base("-2147483648", &value, 10));
674    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
675    EXPECT_FALSE(safe_strto32_base("-2147483649", &value, 10));
676    EXPECT_EQ(std::numeric_limits<int32_t>::min(), value);
677  }
678  TEST(stringtest, safe_strto64_range) {
679    int64_t value;
680    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
681    EXPECT_EQ(std::numeric_limits<int64_t>::max(), value);
682    EXPECT_TRUE(safe_strto64_base("-9223372036854775808", &value, 10));
683    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
684    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
685    EXPECT_EQ(std::numeric_limits<int64_t>::min(), value);
686  }
687  TEST(stringtest, safe_strto32_leading_substring) {
688    int32_t value;
689    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 10));
690    EXPECT_EQ(4069, value);
691    EXPECT_FALSE(safe_strto32_base("04069@@@", &value, 8));
692    EXPECT_EQ(0406, value);
693    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 10));
694    EXPECT_EQ(4069, value);
695    EXPECT_FALSE(safe_strto32_base("04069balloons", &value, 16));
696    EXPECT_EQ(0x4069ba, value);
697    EXPECT_FALSE(safe_strto32_base("@@@", &value, 10));
698    EXPECT_EQ(0, value);  
699  }
700  TEST(stringtest, safe_strto64_leading_substring) {
701    int64_t value;
702    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 10));
703    EXPECT_EQ(4069, value);
704    EXPECT_FALSE(safe_strto64_base("04069@@@", &value, 8));
705    EXPECT_EQ(0406, value);
706    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 10));
707    EXPECT_EQ(4069, value);
708    EXPECT_FALSE(safe_strto64_base("04069balloons", &value, 16));
709    EXPECT_EQ(0x4069ba, value);
710    EXPECT_FALSE(safe_strto64_base("@@@", &value, 10));
711    EXPECT_EQ(0, value);  
712  }
713  TEST(stringtest, safe_strto64_base) {
714    int64_t value;
715    EXPECT_TRUE(safe_strto64_base("0x3423432448783446", &value, 16));
716    EXPECT_EQ(int64_t{0x3423432448783446}, value);
717    EXPECT_TRUE(safe_strto64_base("3423432448783446", &value, 16));
718    EXPECT_EQ(int64_t{0x3423432448783446}, value);
719    EXPECT_TRUE(safe_strto64_base("0", &value, 16));
720    EXPECT_EQ(0, value);
721    EXPECT_TRUE(safe_strto64_base(" \t\n -0x3423432448783446", &value, 16));
722    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
723    EXPECT_TRUE(safe_strto64_base(" \t\n -3423432448783446", &value, 16));
724    EXPECT_EQ(int64_t{-0x3423432448783446}, value);
725    EXPECT_TRUE(safe_strto64_base("123456701234567012", &value, 8));
726    EXPECT_EQ(int64_t{0123456701234567012}, value);
727    EXPECT_TRUE(safe_strto64_base("-017777777777777", &value, 8));
728    EXPECT_EQ(int64_t{-017777777777777}, value);
729    EXPECT_FALSE(safe_strto64_base("19777777777777", &value, 8));
730    EXPECT_TRUE(safe_strto64_base("0", &value, 0));
731    EXPECT_EQ(0, value);
732    EXPECT_TRUE(safe_strto64_base("077", &value, 0));
733    EXPECT_EQ(077, value);  
734    EXPECT_FALSE(safe_strto64_base("088", &value, 0));
735    EXPECT_FALSE(safe_strto64_base("0xG", &value, 0));
736    EXPECT_TRUE(safe_strto64_base("34234324487834466", &value, 10));
737    EXPECT_EQ(int64_t{34234324487834466}, value);
738    EXPECT_TRUE(safe_strto64_base("0", &value, 10));
739    EXPECT_EQ(0, value);
740    EXPECT_TRUE(safe_strto64_base(" \t\n -34234324487834466", &value, 10));
741    EXPECT_EQ(int64_t{-34234324487834466}, value);
742    EXPECT_TRUE(safe_strto64_base("34234324487834466 \n\t ", &value, 10));
743    EXPECT_EQ(int64_t{34234324487834466}, value);
744    EXPECT_FALSE(safe_strto64_base("", &value, 10));
745    EXPECT_FALSE(safe_strto64_base("  ", &value, 10));
746    EXPECT_FALSE(safe_strto64_base("abc", &value, 10));
747    EXPECT_FALSE(safe_strto64_base("34234324487834466a", &value, 10));
748    EXPECT_FALSE(safe_strto64_base("34234487834466.3", &value, 10));
749    EXPECT_FALSE(safe_strto64_base("9223372036854775808", &value, 10));
750    EXPECT_FALSE(safe_strto64_base("-9223372036854775809", &value, 10));
751    EXPECT_TRUE(safe_strto64_base(std::string("0x1234"), &value, 16));
752    EXPECT_EQ(0x1234, value);
753    EXPECT_TRUE(safe_strto64_base("1234", &value, 10));
754    EXPECT_EQ(1234, value);
755  }
756  const size_t kNumRandomTests = 10000;
757  template <typename IntType>
758  void test_random_integer_parse_base(bool (*parse_func)(absl::string_view,
759                                                         IntType* value,
760                                                         int base)) {
761    using RandomEngine = std::minstd_rand0;
762    std::random_device rd;
763    RandomEngine rng(rd());
764    std::uniform_int_distribution<IntType> random_int(
765        std::numeric_limits<IntType>::min());
766    std::uniform_int_distribution<int> random_base(2, 35);
767    for (size_t i = 0; i < kNumRandomTests; i++) {
768      IntType value = random_int(rng);
769      int base = random_base(rng);
770      std::string str_value;
771      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
772      IntType parsed_value;
773      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
774      EXPECT_EQ(parsed_value, value);
775      EXPECT_FALSE(
776          parse_func(absl::StrCat(std::numeric_limits<IntType>::max(), value),
777                     &parsed_value, base));
778      if (std::numeric_limits<IntType>::min() < 0) {
779        EXPECT_FALSE(
780            parse_func(absl::StrCat(std::numeric_limits<IntType>::min(), value),
781                       &parsed_value, base));
782      } else {
783        EXPECT_FALSE(parse_func(absl::StrCat("-", value), &parsed_value, base));
784      }
785    }
786  }
787  TEST(stringtest, safe_strto32_random) {
788    test_random_integer_parse_base<int32_t>(&safe_strto32_base);
789  }
790  TEST(stringtest, safe_strto64_random) {
791    test_random_integer_parse_base<int64_t>(&safe_strto64_base);
792  }
793  TEST(stringtest, safe_strtou32_random) {
794    test_random_integer_parse_base<uint32_t>(&safe_strtou32_base);
795  }
796  TEST(stringtest, safe_strtou64_random) {
797    test_random_integer_parse_base<uint64_t>(&safe_strtou64_base);
798  }
799  TEST(stringtest, safe_strtou128_random) {
800    using RandomEngine = std::minstd_rand0;
801    using IntType = absl::uint128;
802    constexpr auto parse_func = &absl::numbers_internal::safe_strtou128_base;
803    std::random_device rd;
804    RandomEngine rng(rd());
805    std::uniform_int_distribution<uint64_t> random_uint64(
806        std::numeric_limits<uint64_t>::min());
807    std::uniform_int_distribution<int> random_base(2, 35);
808    for (size_t i = 0; i < kNumRandomTests; i++) {
809      IntType value = random_uint64(rng);
810      value = (value << 64) + random_uint64(rng);
811      int base = random_base(rng);
812      std::string str_value;
813      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
814      IntType parsed_value;
815      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
816      EXPECT_EQ(parsed_value, value);
817      std::string s;
818      absl::strings_internal::OStringStream(&s)
819          << std::numeric_limits<IntType>::max() << value;
820      EXPECT_FALSE(parse_func(s, &parsed_value, base));
821      s.clear();
822      absl::strings_internal::OStringStream(&s) << "-" << value;
823      EXPECT_FALSE(parse_func(s, &parsed_value, base));
824    }
825  }
826  TEST(stringtest, safe_strto128_random) {
827    using RandomEngine = std::minstd_rand0;
828    using IntType = absl::int128;
829    constexpr auto parse_func = &absl::numbers_internal::safe_strto128_base;
830    std::random_device rd;
831    RandomEngine rng(rd());
832    std::uniform_int_distribution<int64_t> random_int64(
833        std::numeric_limits<int64_t>::min());
834    std::uniform_int_distribution<uint64_t> random_uint64(
835        std::numeric_limits<uint64_t>::min());
836    std::uniform_int_distribution<int> random_base(2, 35);
837    for (size_t i = 0; i < kNumRandomTests; ++i) {
838      int64_t high = random_int64(rng);
839      uint64_t low = random_uint64(rng);
840      IntType value = absl::MakeInt128(high, low);
841      int base = random_base(rng);
842      std::string str_value;
843      EXPECT_TRUE(Itoa<IntType>(value, base, &str_value));
844      IntType parsed_value;
845      EXPECT_TRUE(parse_func(str_value, &parsed_value, base));
846      EXPECT_EQ(parsed_value, value);
847      std::string s;
848      absl::strings_internal::OStringStream(&s)
849          << std::numeric_limits<IntType>::max() << value;
850      EXPECT_FALSE(parse_func(s, &parsed_value, base));
851      s.clear();
852      absl::strings_internal::OStringStream(&s)
853          << std::numeric_limits<IntType>::min() << value;
854      EXPECT_FALSE(parse_func(s, &parsed_value, base));
855    }
856  }
857  TEST(stringtest, safe_strtou32_base) {
858    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
859      const auto& e = strtouint32_test_cases()[i];
860      uint32_t value;
861      EXPECT_EQ(e.expect_ok, safe_strtou32_base(e.str, &value, e.base))
862          << "str=\"" << e.str << "\" base=" << e.base;
863      if (e.expect_ok) {
864        EXPECT_EQ(e.expected, value) << "i=" << i << " str=\"" << e.str
865                                     << "\" base=" << e.base;
866      }
867    }
868  }
869  TEST(stringtest, safe_strtou32_base_length_delimited) {
870    for (int i = 0; strtouint32_test_cases()[i].str != nullptr; ++i) {
871      const auto& e = strtouint32_test_cases()[i];
872      std::string tmp(e.str);
873      tmp.append("12");  
874      uint32_t value;
875      EXPECT_EQ(e.expect_ok,
876                safe_strtou32_base(absl::string_view(tmp.data(), strlen(e.str)),
877                                   &value, e.base))
878          << "str=\"" << e.str << "\" base=" << e.base;
879      if (e.expect_ok) {
880        EXPECT_EQ(e.expected, value) << "i=" << i << " str=" << e.str
881                                     << " base=" << e.base;
882      }
883    }
884  }
885  TEST(stringtest, safe_strtou64_base) {
886    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
887      const auto& e = strtouint64_test_cases()[i];
888      uint64_t value;
889      EXPECT_EQ(e.expect_ok, safe_strtou64_base(e.str, &value, e.base))
890          << "str=\"" << e.str << "\" base=" << e.base;
891      if (e.expect_ok) {
892        EXPECT_EQ(e.expected, value) << "str=" << e.str << " base=" << e.base;
893      }
894    }
895  }
896  TEST(stringtest, safe_strtou64_base_length_delimited) {
897    for (int i = 0; strtouint64_test_cases()[i].str != nullptr; ++i) {
898      const auto& e = strtouint64_test_cases()[i];
899      std::string tmp(e.str);
900      tmp.append("12");  
901      uint64_t value;
902      EXPECT_EQ(e.expect_ok,
903                safe_strtou64_base(absl::string_view(tmp.data(), strlen(e.str)),
904                                   &value, e.base))
905          << "str=\"" << e.str << "\" base=" << e.base;
906      if (e.expect_ok) {
907        EXPECT_EQ(e.expected, value) << "str=\"" << e.str << "\" base=" << e.base;
908      }
909    }
910  }
911  #if defined(__GLIBC__) || defined(__BIONIC__)
912  #define ABSL_HAVE_FEENABLEEXCEPT 1
913  #define ABSL_HAVE_FEDISABLEEXCEPT 1
914  #endif
915  class SimpleDtoaTest : public testing::Test {
916   protected:
917    void SetUp() override {
918      feholdexcept(&fp_env_);
919  #ifdef ABSL_HAVE_FEENABLEEXCEPT
920      feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
921  #endif
922    }
923    void TearDown() override {
924  #ifdef ABSL_HAVE_FEDISABLEEXCEPT
925      fedisableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
926  #endif
927      fesetenv(&fp_env_);
928    }
929    std::string ToNineDigits(double value) {
930      char buffer[16];  
931      snprintf(buffer, sizeof(buffer), "%.9g", value);
932      return buffer;
933    }
934    fenv_t fp_env_;
935  };
936  template <typename R>
937  void ExhaustiveFloat(uint32_t cases, R&& runnable) {
938    runnable(0.0f);
939    runnable(-0.0f);
940    if (cases >= 2e9) {  
941      for (float f = 0; f < std::numeric_limits<float>::max(); ) {
942        f = nextafterf(f, std::numeric_limits<float>::max());
943        runnable(-f);
944        runnable(f);
945      }
946      return;
947    }
948    std::set<float> floats = {3.4028234e38f};
949    for (float f : {1.0, 3.14159265, 2.718281828, 1 / 2.718281828}) {
950      for (float testf = f; testf != 0; testf *= 0.1f) floats.insert(testf);
951      for (float testf = f; testf != 0; testf *= 0.5f) floats.insert(testf);
952      for (float testf = f; testf < 3e38f / 2; testf *= 2.0f)
953        floats.insert(testf);
954      for (float testf = f; testf < 3e38f / 10; testf *= 10) floats.insert(testf);
955    }
956    float last = *floats.begin();
957    runnable(last);
958    runnable(-last);
959    int iters_per_float = cases / floats.size();
960    if (iters_per_float == 0) iters_per_float = 1;
961    for (float f : floats) {
962      if (f == last) continue;
963      float testf = std::nextafter(last, std::numeric_limits<float>::max());
964      runnable(testf);
965      runnable(-testf);
966      last = testf;
967      if (f == last) continue;
968      double step = (double{f} - last) / iters_per_float;
969      for (double d = last + step; d < f; d += step) {
970        testf = d;
971        if (testf != last) {
972          runnable(testf);
973          runnable(-testf);
974          last = testf;
975        }
976      }
977      testf = std::nextafter(f, 0.0f);
978      if (testf > last) {
979        runnable(testf);
980        runnable(-testf);
981        last = testf;
982      }
983      if (f != last) {
984        runnable(f);
985        runnable(-f);
986        last = f;
987      }
988    }
989  }
990  TEST_F(SimpleDtoaTest, ExhaustiveDoubleToSixDigits) {
991    uint64_t test_count = 0;
992    std::vector<double> mismatches;
993    auto checker = [&](double d) {
994      if (d != d) return;  
995      ++test_count;
996      char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
997      SixDigitsToBuffer(d, sixdigitsbuf);
998      char snprintfbuf[kSixDigitsToBufferSize] = {0};
999      snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1000      if (strcmp(sixdigitsbuf, snprintfbuf) != 0) {
1001        mismatches.push_back(d);
1002        if (mismatches.size() < 10) {
1003          LOG(ERROR) << "Six-digit failure with double.  d=" << d
1004                     << " sixdigits=" << sixdigitsbuf
1005                     << " printf(%g)=" << snprintfbuf;
1006        }
1007      }
1008    };
1009    checker(5e-324);
1010    checker(1e-308);
1011    checker(1.0);
1012    checker(1.000005);
1013    checker(1.7976931348623157e308);
1014    checker(0.00390625);
1015  #ifndef _MSC_VER
1016    checker(0.001953125);
1017  #endif
1018    checker(0.005859375);
1019    checker(1.089095e-15);
1020    checker(3.274195e-55);
1021    checker(6.534355e-146);
1022    checker(2.920845e+234);
1023    if (mismatches.empty()) {
1024      test_count = 0;
1025      ExhaustiveFloat(kFloatNumCases, checker);
1026      test_count = 0;
1027      std::vector<int> digit_testcases{
1028          100000, 100001, 100002, 100005, 100010, 100020, 100050, 100100,  
1029          195312, 195313,  
1030          200000, 500000, 800000,  
1031          585937, 585938,  
1032          900000, 990000, 999000, 999900, 999990, 999996, 999997, 999998, 999999};
1033      if (kFloatNumCases >= 1e9) {
1034        constexpr int min_mantissa = 100000, max_mantissa = 999999;
1035        digit_testcases.resize(max_mantissa - min_mantissa + 1);
1036        std::iota(digit_testcases.begin(), digit_testcases.end(), min_mantissa);
1037      }
1038      for (int exponent = -324; exponent <= 308; ++exponent) {
1039        double powten = absl::strings_internal::Pow10(exponent);
1040        if (powten == 0) powten = 5e-324;
1041        if (kFloatNumCases >= 1e9) {
1042          char buf[kSixDigitsToBufferSize];
1043          LOG(INFO) << "Exp " << exponent << " powten=" << powten << "(" << powten
1044                    << ") ("
1045                    << absl::string_view(buf, SixDigitsToBuffer(powten, buf))
1046                    << ")";
1047        }
1048        for (int digits : digit_testcases) {
1049          if (exponent == 308 && digits >= 179769) break;  
1050          double digiform = (digits + 0.5) * 0.00001;
1051          double testval = digiform * powten;
1052          double pretestval = nextafter(testval, 0);
1053          double posttestval = nextafter(testval, 1.7976931348623157e308);
1054          checker(testval);
1055          checker(pretestval);
1056          checker(posttestval);
1057        }
1058      }
1059    } else {
1060      EXPECT_EQ(mismatches.size(), 0);
1061      for (size_t i = 0; i < mismatches.size(); ++i) {
1062        if (i > 100) i = mismatches.size() - 1;
1063        double d = mismatches[i];
1064        char sixdigitsbuf[kSixDigitsToBufferSize] = {0};
1065        SixDigitsToBuffer(d, sixdigitsbuf);
1066        char snprintfbuf[kSixDigitsToBufferSize] = {0};
1067        snprintf(snprintfbuf, kSixDigitsToBufferSize, "%g", d);
1068        double before = nextafter(d, 0.0);
1069        double after = nextafter(d, 1.7976931348623157e308);
1070        char b1[32], b2[kSixDigitsToBufferSize];
1071        LOG(ERROR) << "Mismatch #" << i << "  d=" << d << " (" << ToNineDigits(d)
1072                   << ") sixdigits='" << sixdigitsbuf << "' snprintf='"
1073                   << snprintfbuf << "' Before.=" << PerfectDtoa(before) << " "
1074                   << (SixDigitsToBuffer(before, b2), b2) << " vs snprintf="
1075                   << (snprintf(b1, sizeof(b1), "%g", before), b1)
1076                   << " Perfect=" << PerfectDtoa(d) << " "
1077                   << (SixDigitsToBuffer(d, b2), b2)
1078                   << " vs snprintf=" << (snprintf(b1, sizeof(b1), "%g", d), b1)
1079                   << " After.=." << PerfectDtoa(after) << " "
1080                   << (SixDigitsToBuffer(after, b2), b2) << " vs snprintf="
1081                   << (snprintf(b1, sizeof(b1), "%g", after), b1);
1082      }
1083    }
1084  }
1085  TEST(StrToInt32, Partial) {
1086    struct Int32TestLine {
1087      std::string input;
1088      bool status;
1089      int32_t value;
1090    };
1091    const int32_t int32_min = std::numeric_limits<int32_t>::min();
1092    const int32_t int32_max = std::numeric_limits<int32_t>::max();
1093    Int32TestLine int32_test_line[] = {
1094        {"", false, 0},
1095        {" ", false, 0},
1096        {"-", false, 0},
1097        {"123@@@", false, 123},
1098        {absl::StrCat(int32_min, int32_max), false, int32_min},
1099        {absl::StrCat(int32_max, int32_max), false, int32_max},
1100    };
1101    for (const Int32TestLine& test_line : int32_test_line) {
1102      int32_t value = -2;
1103      bool status = safe_strto32_base(test_line.input, &value, 10);
1104      EXPECT_EQ(test_line.status, status) << test_line.input;
1105      EXPECT_EQ(test_line.value, value) << test_line.input;
1106      value = -2;
1107      status = safe_strto32_base(test_line.input, &value, 10);
1108      EXPECT_EQ(test_line.status, status) << test_line.input;
1109      EXPECT_EQ(test_line.value, value) << test_line.input;
1110      value = -2;
1111      status = safe_strto32_base(absl::string_view(test_line.input), &value, 10);
1112      EXPECT_EQ(test_line.status, status) << test_line.input;
1113      EXPECT_EQ(test_line.value, value) << test_line.input;
1114    }
1115  }
1116  TEST(StrToUint32, Partial) {
1117    struct Uint32TestLine {
1118      std::string input;
1119      bool status;
1120      uint32_t value;
1121    };
1122    const uint32_t uint32_max = std::numeric_limits<uint32_t>::max();
1123    Uint32TestLine uint32_test_line[] = {
1124        {"", false, 0},
1125        {" ", false, 0},
1126        {"-", false, 0},
1127        {"123@@@", false, 123},
1128        {absl::StrCat(uint32_max, uint32_max), false, uint32_max},
1129    };
1130    for (const Uint32TestLine& test_line : uint32_test_line) {
1131      uint32_t value = 2;
1132      bool status = safe_strtou32_base(test_line.input, &value, 10);
1133      EXPECT_EQ(test_line.status, status) << test_line.input;
1134      EXPECT_EQ(test_line.value, value) << test_line.input;
1135      value = 2;
1136      status = safe_strtou32_base(test_line.input, &value, 10);
1137      EXPECT_EQ(test_line.status, status) << test_line.input;
1138      EXPECT_EQ(test_line.value, value) << test_line.input;
1139      value = 2;
1140      status = safe_strtou32_base(absl::string_view(test_line.input), &value, 10);
1141      EXPECT_EQ(test_line.status, status) << test_line.input;
1142      EXPECT_EQ(test_line.value, value) << test_line.input;
1143    }
1144  }
1145  TEST(StrToInt64, Partial) {
1146    struct Int64TestLine {
1147      std::string input;
1148      bool status;
1149      int64_t value;
1150    };
1151    const int64_t int64_min = std::numeric_limits<int64_t>::min();
1152    const int64_t int64_max = std::numeric_limits<int64_t>::max();
1153    Int64TestLine int64_test_line[] = {
1154        {"", false, 0},
1155        {" ", false, 0},
1156        {"-", false, 0},
1157        {"123@@@", false, 123},
1158        {absl::StrCat(int64_min, int64_max), false, int64_min},
1159        {absl::StrCat(int64_max, int64_max), false, int64_max},
1160    };
1161    for (const Int64TestLine& test_line : int64_test_line) {
1162      int64_t value = -2;
1163      bool status = safe_strto64_base(test_line.input, &value, 10);
1164      EXPECT_EQ(test_line.status, status) << test_line.input;
1165      EXPECT_EQ(test_line.value, value) << test_line.input;
1166      value = -2;
1167      status = safe_strto64_base(test_line.input, &value, 10);
1168      EXPECT_EQ(test_line.status, status) << test_line.input;
1169      EXPECT_EQ(test_line.value, value) << test_line.input;
1170      value = -2;
1171      status = safe_strto64_base(absl::string_view(test_line.input), &value, 10);
1172      EXPECT_EQ(test_line.status, status) << test_line.input;
1173      EXPECT_EQ(test_line.value, value) << test_line.input;
1174    }
1175  }
1176  TEST(StrToUint64, Partial) {
1177    struct Uint64TestLine {
1178      std::string input;
1179      bool status;
1180      uint64_t value;
1181    };
1182    const uint64_t uint64_max = std::numeric_limits<uint64_t>::max();
1183    Uint64TestLine uint64_test_line[] = {
1184        {"", false, 0},
1185        {" ", false, 0},
1186        {"-", false, 0},
1187        {"123@@@", false, 123},
1188        {absl::StrCat(uint64_max, uint64_max), false, uint64_max},
1189    };
1190    for (const Uint64TestLine& test_line : uint64_test_line) {
1191      uint64_t value = 2;
1192      bool status = safe_strtou64_base(test_line.input, &value, 10);
1193      EXPECT_EQ(test_line.status, status) << test_line.input;
1194      EXPECT_EQ(test_line.value, value) << test_line.input;
1195      value = 2;
1196      status = safe_strtou64_base(test_line.input, &value, 10);
1197      EXPECT_EQ(test_line.status, status) << test_line.input;
1198      EXPECT_EQ(test_line.value, value) << test_line.input;
1199      value = 2;
1200      status = safe_strtou64_base(absl::string_view(test_line.input), &value, 10);
1201      EXPECT_EQ(test_line.status, status) << test_line.input;
1202      EXPECT_EQ(test_line.value, value) << test_line.input;
1203    }
1204  }
1205  TEST(StrToInt32Base, PrefixOnly) {
1206    struct Int32TestLine {
1207      std::string input;
1208      bool status;
1209      int32_t value;
1210    };
1211    Int32TestLine int32_test_line[] = {
1212      { "", false, 0 },
1213      { "-", false, 0 },
1214      { "-0", true, 0 },
1215      { "0", true, 0 },
1216      { "0x", false, 0 },
1217      { "-0x", false, 0 },
1218    };
1219    const int base_array[] = { 0, 2, 8, 10, 16 };
1220    for (const Int32TestLine& line : int32_test_line) {
1221      for (const int base : base_array) {
1222        int32_t value = 2;
1223        bool status = safe_strto32_base(line.input.c_str(), &value, base);
1224        EXPECT_EQ(line.status, status) << line.input << " " << base;
1225        EXPECT_EQ(line.value, value) << line.input << " " << base;
1226        value = 2;
1227        status = safe_strto32_base(line.input, &value, base);
1228        EXPECT_EQ(line.status, status) << line.input << " " << base;
1229        EXPECT_EQ(line.value, value) << line.input << " " << base;
1230        value = 2;
1231        status = safe_strto32_base(absl::string_view(line.input), &value, base);
1232        EXPECT_EQ(line.status, status) << line.input << " " << base;
1233        EXPECT_EQ(line.value, value) << line.input << " " << base;
1234      }
1235    }
1236  }
1237  TEST(StrToUint32Base, PrefixOnly) {
1238    struct Uint32TestLine {
1239      std::string input;
1240      bool status;
1241      uint32_t value;
1242    };
1243    Uint32TestLine uint32_test_line[] = {
1244      { "", false, 0 },
1245      { "0", true, 0 },
1246      { "0x", false, 0 },
1247    };
1248    const int base_array[] = { 0, 2, 8, 10, 16 };
1249    for (const Uint32TestLine& line : uint32_test_line) {
1250      for (const int base : base_array) {
1251        uint32_t value = 2;
1252        bool status = safe_strtou32_base(line.input.c_str(), &value, base);
1253        EXPECT_EQ(line.status, status) << line.input << " " << base;
1254        EXPECT_EQ(line.value, value) << line.input << " " << base;
1255        value = 2;
1256        status = safe_strtou32_base(line.input, &value, base);
1257        EXPECT_EQ(line.status, status) << line.input << " " << base;
1258        EXPECT_EQ(line.value, value) << line.input << " " << base;
1259        value = 2;
1260        status = safe_strtou32_base(absl::string_view(line.input), &value, base);
1261        EXPECT_EQ(line.status, status) << line.input << " " << base;
1262        EXPECT_EQ(line.value, value) << line.input << " " << base;
1263      }
1264    }
1265  }
1266  TEST(StrToInt64Base, PrefixOnly) {
1267    struct Int64TestLine {
1268      std::string input;
1269      bool status;
1270      int64_t value;
1271    };
1272    Int64TestLine int64_test_line[] = {
1273      { "", false, 0 },
1274      { "-", false, 0 },
1275      { "-0", true, 0 },
1276      { "0", true, 0 },
1277      { "0x", false, 0 },
1278      { "-0x", false, 0 },
1279    };
1280    const int base_array[] = { 0, 2, 8, 10, 16 };
1281    for (const Int64TestLine& line : int64_test_line) {
1282      for (const int base : base_array) {
1283        int64_t value = 2;
1284        bool status = safe_strto64_base(line.input.c_str(), &value, base);
1285        EXPECT_EQ(line.status, status) << line.input << " " << base;
1286        EXPECT_EQ(line.value, value) << line.input << " " << base;
1287        value = 2;
1288        status = safe_strto64_base(line.input, &value, base);
1289        EXPECT_EQ(line.status, status) << line.input << " " << base;
1290        EXPECT_EQ(line.value, value) << line.input << " " << base;
1291        value = 2;
1292        status = safe_strto64_base(absl::string_view(line.input), &value, base);
1293        EXPECT_EQ(line.status, status) << line.input << " " << base;
1294        EXPECT_EQ(line.value, value) << line.input << " " << base;
1295      }
1296    }
1297  }
1298  TEST(StrToUint64Base, PrefixOnly) {
1299    struct Uint64TestLine {
1300      std::string input;
1301      bool status;
1302      uint64_t value;
1303    };
1304    Uint64TestLine uint64_test_line[] = {
1305      { "", false, 0 },
1306      { "0", true, 0 },
1307      { "0x", false, 0 },
1308    };
1309    const int base_array[] = { 0, 2, 8, 10, 16 };
1310    for (const Uint64TestLine& line : uint64_test_line) {
1311      for (const int base : base_array) {
1312        uint64_t value = 2;
1313        bool status = safe_strtou64_base(line.input.c_str(), &value, base);
1314        EXPECT_EQ(line.status, status) << line.input << " " << base;
1315        EXPECT_EQ(line.value, value) << line.input << " " << base;
1316        value = 2;
1317        status = safe_strtou64_base(line.input, &value, base);
1318        EXPECT_EQ(line.status, status) << line.input << " " << base;
1319        EXPECT_EQ(line.value, value) << line.input << " " << base;
1320        value = 2;
1321        status = safe_strtou64_base(absl::string_view(line.input), &value, base);
1322        EXPECT_EQ(line.status, status) << line.input << " " << base;
1323        EXPECT_EQ(line.value, value) << line.input << " " << base;
1324      }
1325    }
1326  }
1327  void TestFastHexToBufferZeroPad16(uint64_t v) {
1328    char buf[16];
1329    auto digits = absl::numbers_internal::FastHexToBufferZeroPad16(v, buf);
1330    absl::string_view res(buf, 16);
1331    char buf2[17];
1332    snprintf(buf2, sizeof(buf2), "%016" PRIx64, v);
1333    EXPECT_EQ(res, buf2) << v;
1334    size_t expected_digits = snprintf(buf2, sizeof(buf2), "%" PRIx64, v);
1335    EXPECT_EQ(digits, expected_digits) << v;
1336  }
1337  TEST(FastHexToBufferZeroPad16, Smoke) {
1338    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::min());
1339    TestFastHexToBufferZeroPad16(std::numeric_limits<uint64_t>::max());
1340    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::min());
1341    TestFastHexToBufferZeroPad16(std::numeric_limits<int64_t>::max());
1342    absl::BitGen rng;
1343    for (int i = 0; i < 100000; ++i) {
1344      TestFastHexToBufferZeroPad16(
1345          absl::LogUniform(rng, std::numeric_limits<uint64_t>::min(),
1346                           std::numeric_limits<uint64_t>::max()));
1347    }
1348  }
1349  }  
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <string>
3  #include <mutex>
4  #include <numeric>
5  #include <inja.hpp>
6  #include <yaml-cpp/yaml.h>
7  #include "../config/binding.h"
8  #include "../generator/config/nodemanip.h"
9  #include "../generator/config/ruleconvert.h"
10  #include "../generator/config/subexport.h"
11  #include "../generator/template/templates.h"
12  #include "../script/cron.h"
13  #include "../script/script_quickjs.h"
14  #include "../server/webserver.h"
15  #include "../utils/base64/base64.h"
16  #include "../utils/file_extra.h"
17  #include "../utils/ini_reader/ini_reader.h"
18  #include "../utils/logger.h"
19  #include "../utils/network.h"
20  #include "../utils/regexp.h"
21  #include "../utils/stl_extra.h"
22  #include "../utils/string.h"
23  #include "../utils/string_hash.h"
24  #include "../utils/system.h"
25  #include "../utils/system.h"
26  #include "../utils/urlencode.h"
27  #include "../utils/yamlcpp_extra.h"
28  #include "interfaces.h"
29  #include "multithread.h"
30  #include "settings.h"
31  #include "upload.h"
32  #include "webget.h"
33  extern WebServer webServer;
34  string_array gRegexBlacklist = {"(.*)*"};
35  void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &ruleset_content_array);
36  std::string parseProxy(const std::string &source)
37  {
38      std::string proxy = source;
39      if(source == "SYSTEM")
40          proxy = getSystemProxy();
41      else if(source == "NONE")
42          proxy = "";
43      return proxy;
44  }
45  extern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;
46  struct UAProfile
47  {
48      std::string head;
49      std::string version_match;
50      std::string version_target;
51      std::string target;
52      tribool clash_new_name = tribool();
53      int surge_ver = -1;
54  };
55  const std::vector<UAProfile> UAMatchList = {
<span onclick='openModal()' class='match'>56      {"ClashForAndroid","\\/([0-9.]+)","2.0","clash",true},
57      {"ClashForAndroid","\\/([0-9.]+)R","","clashr",false},
58      {"ClashForAndroid","","","clash",false},
59      {"ClashforWindows","\\/([0-9.]+)","0.11","clash",true},
60      {"ClashforWindows","","","clash",false},
61      {"ClashX Pro","","","clash",true},
62      {"ClashX","\\/([0-9.]+)","0.13","clash",true},
63      {"Clash","","","clash",true},
64      {"Kitsunebi","","","v2ray"},
65      {"Loon","","","loon"},
66      {"Pharos","","","mixed"},
67      {"Potatso","","","mixed"},
68      {"Quantumult%20X","","","quanx"},
69      {"Quantumult","","","quan"},
</span>70      {"Qv2ray","","","v2ray"},
71      {"Shadowrocket","","","mixed"},
72      {"Surfboard","","","surfboard"},
73      {"Surge","\\/([0-9.]+).*x86","906","surge",false,4}, 
74      {"Surge","\\/([0-9.]+).*x86","368","surge",false,3}, 
75      {"Surge","\\/([0-9.]+)","1419","surge",false,4}, 
76      {"Surge","\\/([0-9.]+)","900","surge",false,3}, 
77      {"Surge","","","surge",false,2}, 
78      {"Trojan-Qt5","","","trojan"},
79      {"V2rayU","","","v2ray"},
80      {"V2RayX","","","v2ray"}
81  };
82  bool verGreaterEqual(const std::string &src_ver, const std::string &target_ver)
83  {
84      string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;
85      while(true)
86      {
87          src_pos_end = src_ver.find('.', src_pos_beg);
88          if(src_pos_end == src_ver.npos)
89              src_pos_end = src_ver.size();
90          int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));
91          target_pos_end = target_ver.find('.', target_pos_beg);
92          if(target_pos_end == target_ver.npos)
93              target_pos_end = target_ver.size();
94          int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));
95          if(part_src > part_target)
96              break;
97          else if(part_src < part_target)
98              return false;
99          else if(src_pos_end >= src_ver.size() - 1 || target_pos_end >= target_ver.size() - 1)
100              break;
101          src_pos_beg = src_pos_end + 1;
102          target_pos_beg = target_pos_end + 1;
103      }
104      return true;
105  }
106  void matchUserAgent(const std::string &user_agent, std::string &target, tribool &clash_new_name, int &surge_ver)
107  {
108      if(user_agent.empty())
109          return;
110      for(const UAProfile &x : UAMatchList)
111      {
112          if(startsWith(user_agent, x.head))
113          {
114              if(!x.version_match.empty())
115              {
116                  std::string version;
117                  if(regGetMatch(user_agent, x.version_match, 2, 0, &version))
118                      continue;
119                  if(!x.version_target.empty() && !verGreaterEqual(version, x.version_target))
120                      continue;
121              }
122              target = x.target;
123              clash_new_name = x.clash_new_name;
124              if(x.surge_ver != -1)
125                  surge_ver = x.surge_ver;
126              return;
127          }
128      }
129      return;
130  }
131  std::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)
132  {
133      std::string url = urlDecode(getUrlArg(request.argument, "url")), type = getUrlArg(request.argument, "type");
134      return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));
135  }
136  std::string getRuleset(RESPONSE_CALLBACK_ARGS)
137  {
138      std::string &argument = request.argument;
139      int *status_code = &response.status_code;
140      std::string url = urlSafeBase64Decode(getUrlArg(argument, "url")), type = getUrlArg(argument, "type"), group = urlSafeBase64Decode(getUrlArg(argument, "group"));
141      std::string output_content, dummy;
142      int type_int = to_int(type, 0);
143      if(!url.size() || !type.size() || (type_int == 2 && !group.size()) || (type_int < 1 || type_int > 6))
144      {
145          *status_code = 400;
146          return "Invalid request!";
147      }
148      std::string proxy = parseProxy(global.proxyRuleset);
149      string_array vArray = split(url, "|");
150      for(std::string &x : vArray)
151          x.insert(0, "ruleset,");
152      std::vector<RulesetContent> rca;
153      RulesetConfigs confs = INIBinding::from<RulesetConfig>::from_ini(vArray);
154      refreshRulesets(confs, rca);
155      for(RulesetContent &x : rca)
156      {
157          std::string content = x.rule_content.get();
158          output_content += convertRuleset(content, x.rule_type);
159      }
160      if(!output_content.size())
161      {
162          *status_code = 400;
163          return "Invalid request!";
164      }
165      std::string strLine;
166      std::stringstream ss;
167      const std::string rule_match_regex = "^(.*?,.*?)(,.*)(,.*)$";
168      ss << output_content;
169      char delimiter = getLineBreak(output_content);
170      std::string::size_type lineSize, posb, pose;
171      auto filterLine = [&]()
172      {
173          posb = 0;
174          pose = strLine.find(',');
175          if(pose == strLine.npos)
176              return 1;
177          posb = pose + 1;
178          pose = strLine.find(',', posb);
179          if(pose == strLine.npos)
180          {
181              pose = strLine.size();
182              if(strLine[pose - 1] == '\r')
183                  pose--;
184          }
185          pose -= posb;
186          return 0;
187      };
188      lineSize = output_content.size();
189      output_content.clear();
190      output_content.reserve(lineSize);
191      if(type_int == 3 || type_int == 4 || type_int == 6)
192          output_content = "payload:\n";
193      while(getline(ss, strLine, delimiter))
194      {
195          if(strFind(strLine, "&bsol;&bsol;"))
196          {
197              strLine.erase(strLine.find("&bsol;&bsol;"));
198              strLine = trimWhitespace(strLine);
199          }
200          switch(type_int)
201          {
202          case 2:
203              if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
204                  continue;
205              break;
206          case 1:
207              if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
208                  continue;
209              break;
210          case 3:
211              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
212                  continue;
213              if(filterLine())
214                  continue;
215              output_content += "  - '";
216              if(strLine[posb - 2] == 'X')
217                  output_content += "+.";
218              output_content += strLine.substr(posb, pose);
219              output_content += "'\n";
220              continue;
221          case 4:
222              if(!startsWith(strLine, "IP-CIDR,") && !startsWith(strLine, "IP-CIDR6,"))
223                  continue;
224              if(filterLine())
225                  continue;
226              output_content += "  - '";
227              output_content += strLine.substr(posb, pose);
228              output_content += "'\n";
229              continue;
230          case 5:
231              if(!startsWith(strLine, "DOMAIN-SUFFIX,") && !startsWith(strLine, "DOMAIN,"))
232                  continue;
233              if(filterLine())
234                  continue;
235              output_content += strLine.substr(posb, pose);
236              output_content += '\n';
237              continue;
238          case 6:
239              if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
240                  continue;
241              output_content += "  - ";
242          }
243          lineSize = strLine.size();
244          if(lineSize && strLine[lineSize - 1] == '\r') 
245              strLine.erase(--lineSize);
246          if(!strLine.empty() && (strLine[0] != ';' && strLine[0] != '#' && !(lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')))
247          {
248              if(type_int == 2)
249              {
250                  if(startsWith(strLine, "IP-CIDR6"))
251                      strLine.replace(0, 8, "IP6-CIDR");
252                  strLine += "," + group;
253                  if(count_least(strLine, ',', 3) && regReplace(strLine, rule_match_regex, "$2") == ",no-resolve")
254                      strLine = regReplace(strLine, rule_match_regex, "$1$3$2");
255                  else
256                      strLine = regReplace(strLine, rule_match_regex, "$1$3");
257              }
258          }
259          output_content += strLine;
260          output_content += '\n';
261      }
262      if(output_content == "payload:\n")
263      {
264          switch(type_int)
265          {
266          case 3:
267              output_content += "  - '--placeholder--'";
268              break;
269          case 4:
270              output_content += "  - '0.0.0.0/32'";
271              break;
272          case 6:
273              output_content += "  - 'DOMAIN,--placeholder--'";
274              break;
275          }
276      }
277      return output_content;
278  }
279  void checkExternalBase(const std::string &path, std::string &dest)
280  {
281      if(isLink(path) || (startsWith(path, global.basePath) && fileExist(path)))
282          dest = path;
283  }
284  std::string subconverter(RESPONSE_CALLBACK_ARGS)
285  {
286      std::string &argument = request.argument;
287      int *status_code = &response.status_code;
288      std::string argTarget = getUrlArg(argument, "target"), argSurgeVer = getUrlArg(argument, "ver");
289      tribool argClashNewField = getUrlArg(argument, "new_name");
290      int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;
291      if(argTarget == "auto")
292          matchUserAgent(request.headers["User-Agent"], argTarget, argClashNewField, intSurgeVer);
293      bool lSimpleSubscription = false;
294      switch(hash_(argTarget))
295      {
296      case "ss"_hash: case "ssd"_hash: case "ssr"_hash: case "sssub"_hash: case "v2ray"_hash: case "trojan"_hash: case "mixed"_hash:
297          lSimpleSubscription = true;
298          break;
299      case "clash"_hash: case "clashr"_hash: case "surge"_hash: case "quan"_hash: case "quanx"_hash: case "loon"_hash: case "surfboard"_hash: case "mellow"_hash:
300          break;
301      default:
302          *status_code = 400;
303          return "Invalid target!";
304      }
305      if((!global.APIMode || global.CFWChildProcess) && !global.generatorMode)
306          readConf();
307      std::string argUrl = urlDecode(getUrlArg(argument, "url"));
308      std::string argGroupName = urlDecode(getUrlArg(argument, "group")), argUploadPath = getUrlArg(argument, "upload_path");
309      std::string argIncludeRemark = urlDecode(getUrlArg(argument, "include")), argExcludeRemark = urlDecode(getUrlArg(argument, "exclude"));
310      std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, "groups")), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, "ruleset")), argExternalConfig = urlDecode(getUrlArg(argument, "config"));
311      std::string argDeviceID = getUrlArg(argument, "dev_id"), argFilename = urlDecode(getUrlArg(argument, "filename")), argUpdateInterval = getUrlArg(argument, "interval"), argUpdateStrict = getUrlArg(argument, "strict");
312      std::string argRenames = urlDecode(getUrlArg(argument, "rename")), argFilterScript = urlDecode(getUrlArg(argument, "filter_script"));
313      tribool argUpload = getUrlArg(argument, "upload"), argEmoji = getUrlArg(argument, "emoji"), argAddEmoji = getUrlArg(argument, "add_emoji"), argRemoveEmoji = getUrlArg(argument, "remove_emoji");
314      tribool argAppendType = getUrlArg(argument, "append_type"), argTFO = getUrlArg(argument, "tfo"), argUDP = getUrlArg(argument, "udp"), argGenNodeList = getUrlArg(argument, "list");
315      tribool argSort = getUrlArg(argument, "sort"), argUseSortScript = getUrlArg(argument, "sort_script");
316      tribool argGenClashScript = getUrlArg(argument, "script"), argEnableInsert = getUrlArg(argument, "insert");
317      tribool argSkipCertVerify = getUrlArg(argument, "scv"), argFilterDeprecated = getUrlArg(argument, "fdn"), argExpandRulesets = getUrlArg(argument, "expand"), argAppendUserinfo = getUrlArg(argument, "append_info");
318      tribool argPrependInsert = getUrlArg(argument, "prepend"), argGenClassicalRuleProvider = getUrlArg(argument, "classic"), argTLS13 = getUrlArg(argument, "tls13");
319      std::string base_content, output_content;
320      ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;
321      RulesetConfigs lCustomRulesets = global.customRulesets;
322      string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;
323      std::vector<RulesetContent> lRulesetContent;
324      extra_settings ext;
325      std::string subInfo, dummy;
326      int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;
327      bool authorized = !global.APIMode || getUrlArg(argument, "token") == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == "true" : global.updateStrict;
328      if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())
329          return "Invalid request!";
330      std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;
331      std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;
332      argEnableInsert.define(global.enableInsert);
333      if(!argUrl.size() && (!global.APIMode || authorized))
334          argUrl = global.defaultUrls;
335      if((!argUrl.size() && !(global.insertUrls.size() && argEnableInsert)) || !argTarget.size())
336      {
337          *status_code = 400;
338          return "Invalid request!";
339      }
340      string_array req_args = split(argument, "&");
341      string_map req_arg_map;
342      for(std::string &x : req_args)
343      {
344          string_size pos = x.find("=");
345          if(pos == x.npos)
346          {
347              req_arg_map[x] = "";
348              continue;
349          }
350          if(x.substr(0, pos) == "token")
351              continue;
352          req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
353      }
354      req_arg_map["target"] = argTarget;
355      req_arg_map["ver"] = std::to_string(intSurgeVer);
356      template_args tpl_args;
357      tpl_args.global_vars = global.templateVars;
358      tpl_args.request_params = req_arg_map;
359      std::string proxy = parseProxy(global.proxySubscription);
360      ext.authorized = authorized;
361      ext.append_proxy_type = argAppendType.get(global.appendType);
362      if((argTarget == "clash" || argTarget == "clashr") && argGenClashScript.is_undef())
363          argExpandRulesets.define(true);
364      ext.clash_proxies_style = global.clashProxiesStyle;
365      ext.tfo.define(argTFO).define(global.TFOFlag);
366      ext.udp.define(argUDP).define(global.UDPFlag);
367      ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);
368      ext.tls13.define(argTLS13).define(global.TLS13Flag);
369      ext.sort_flag = argSort.get(global.enableSort);
370      argUseSortScript.define(global.sortScript.size() != 0);
371      if(ext.sort_flag && argUseSortScript)
372          ext.sort_script = global.sortScript;
373      ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);
374      ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);
375      ext.clash_script = argGenClashScript.get();
376      ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();
377      if(!argExpandRulesets)
378          ext.clash_new_field_name = true;
379      else
380          ext.clash_script = false;
381      ext.nodelist = argGenNodeList;
382      ext.surge_ssr_path = global.surgeSSRPath;
383      ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;
384      ext.enable_rule_generator = global.enableRuleGen;
385      ext.overwrite_original_rules = global.overwriteOriginalRules;
386      if(!argExpandRulesets)
387          ext.managed_config_prefix = global.managedConfigPrefix;
388      if(argExternalConfig.empty())
389          argExternalConfig = global.defaultExtConfig;
390      if(argExternalConfig.size())
391      {
392          writeLog(0, "External configuration file provided. Loading...", LOG_LEVEL_INFO);
393          ExternalConfig extconf;
394          extconf.tpl_args = &tpl_args;
395          if(loadExternalConfig(argExternalConfig, extconf) == 0)
396          {
397              if(!ext.nodelist)
398              {
399                  checkExternalBase(extconf.sssub_rule_base, lSSSubBase);
400                  if(!lSimpleSubscription)
401                  {
402                      checkExternalBase(extconf.clash_rule_base, lClashBase);
403                      checkExternalBase(extconf.surge_rule_base, lSurgeBase);
404                      checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);
405                      checkExternalBase(extconf.mellow_rule_base, lMellowBase);
406                      checkExternalBase(extconf.quan_rule_base, lQuanBase);
407                      checkExternalBase(extconf.quanx_rule_base, lQuanXBase);
408                      checkExternalBase(extconf.loon_rule_base, lLoonBase);
409                      if(extconf.surge_ruleset.size())
410                          lCustomRulesets = extconf.surge_ruleset;
411                      if(extconf.custom_proxy_group.size())
412                          lCustomProxyGroups = extconf.custom_proxy_group;
413                      ext.enable_rule_generator = extconf.enable_rule_generator;
414                      ext.overwrite_original_rules = extconf.overwrite_original_rules;
415                  }
416              }
417              if(extconf.rename.size())
418                  ext.rename_array = extconf.rename;
419              if(extconf.emoji.size())
420                  ext.emoji_array = extconf.emoji;
421              if(extconf.include.size())
422                  lIncludeRemarks = extconf.include;
423              if(extconf.exclude.size())
424                  lExcludeRemarks = extconf.exclude;
425              argAddEmoji.define(extconf.add_emoji);
426              argRemoveEmoji.define(extconf.remove_old_emoji);
427          }
428      }
429      else
430      {
431          if(!lSimpleSubscription)
432          {
433              if(argCustomGroups.size() && !ext.nodelist)
434              {
435                  string_array vArray = split(argCustomGroups, "@");
436                  lCustomProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() && !ext.nodelist)
439              {
440                  string_array vArray = split(argCustomRulesets, "@");
441                  lCustomRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray);
442              }
443          }
444      }
445      if(ext.enable_rule_generator && !ext.nodelist && !lSimpleSubscription)
446      {
447          if(lCustomRulesets != global.customRulesets)
448              refreshRulesets(lCustomRulesets, lRulesetContent);
449          else
450          {
451              if(global.updateRulesetOnRequest)
452                  refreshRulesets(global.customRulesets, global.rulesetsContent);
453              lRulesetContent = global.rulesetsContent;
454          }
455      }
456      if(!argEmoji.is_undef())
457      {
458          argAddEmoji.set(argEmoji);
459          argRemoveEmoji.set(true);
460      }
461      ext.add_emoji = argAddEmoji.get(global.addEmoji);
462      ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);
463      if(ext.add_emoji && ext.emoji_array.empty())
464          ext.emoji_array = safe_get_emojis();
465      if(argRenames.size())
466          ext.rename_array = INIBinding::from<RegexMatchConfig>::from_ini(split(argRenames, "`"), "@");
467      else if(ext.rename_array.empty())
468          ext.rename_array = safe_get_renames();
469      if(argIncludeRemark.size() && regValid(argIncludeRemark))
470          lIncludeRemarks = string_array{argIncludeRemark};
471      if(argExcludeRemark.size() && regValid(argExcludeRemark))
472          lExcludeRemarks = string_array{argExcludeRemark};
473      if(authorized && !global.scriptCleanContext)
474      {
475          ext.js_runtime = new qjs::Runtime();
476          script_runtime_init(*ext.js_runtime);
477          ext.js_context = new qjs::Context(*ext.js_runtime);
478          script_context_init(*ext.js_context);
479      }
480      RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
481      string_array urls;
482      std::vector<Proxy> nodes, insert_nodes;
483      int groupID = 0;
484      parse_settings parse_set;
485      parse_set.proxy = &proxy;
486      parse_set.exclude_remarks = &lExcludeRemarks;
487      parse_set.include_remarks = &lIncludeRemarks;
488      parse_set.stream_rules = &stream_temp;
489      parse_set.time_rules = &time_temp;
490      parse_set.sub_info = &subInfo;
491      parse_set.authorized = authorized;
492      parse_set.request_header = &request.headers;
493      parse_set.js_runtime = ext.js_runtime;
494      parse_set.js_context = ext.js_context;
495      if(global.insertUrls.size() && argEnableInsert)
496      {
497          groupID = -1;
498          urls = split(global.insertUrls, "|");
499          importItems(urls, true);
500          for(std::string &x : urls)
501          {
502              x = regTrim(x);
503              writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
504              if(addNodes(x, insert_nodes, groupID, parse_set) == -1)
505              {
506                  if(global.skipFailedLinks)
507                      writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
508                  else
509                  {
510                      *status_code = 400;
511                      return "The following link doesn't contain any valid node info: " + x;
512                  }
513              }
514              groupID--;
515          }
516      }
517      urls = split(argUrl, "|");
518      importItems(urls, true);
519      groupID = 0;
520      for(std::string &x : urls)
521      {
522          x = regTrim(x);
523          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
524          if(addNodes(x, nodes, groupID, parse_set) == -1)
525          {
526              if(global.skipFailedLinks)
527                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
528              else
529              {
530                  *status_code = 400;
531                  return "The following link doesn't contain any valid node info: " + x;
532              }
533          }
534          groupID++;
535      }
536      if(!nodes.size() && !insert_nodes.size())
537      {
538          *status_code = 400;
539          return "No nodes were found!";
540      }
541      if(subInfo.size() && argAppendUserinfo.get(global.appendUserinfo))
542          response.headers.emplace("Subscription-UserInfo", subInfo);
543      if(request.method == "HEAD")
544          return "";
545      argPrependInsert.define(global.prependInsert);
546      if(argPrependInsert)
547      {
548          std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));
549          nodes.swap(insert_nodes);
550      }
551      else
552      {
553          std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));
554      }
555      std::string filterScript = global.filterScript;
556      if(authorized && !argFilterScript.empty())
557          filterScript = argFilterScript;
558      if(filterScript.size())
559      {
560          if(startsWith(filterScript, "path:"))
561              filterScript = fileGet(filterScript.substr(5), false);
562          script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
563          {
564              try
565              {
566                  ctx.eval(filterScript);
567                  auto filter = (std::function<bool(const Proxy&)>) ctx.eval("filter");
568                  nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());
569              }
570              catch(qjs::exception)
571              {
572                  script_print_stack(ctx);
573              }
574          }, global.scriptCleanContext);
575      }
576      if(argGroupName.size())
577          for(Proxy &x : nodes)
578              x.Group = argGroupName;
579      preprocessNodes(nodes, ext);
580      ProxyGroupConfigs dummy_group;
581      std::vector<RulesetContent> dummy_ruleset;
582      std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, "profile_data")));
583      if(managed_url.empty())
584          managed_url = global.managedConfigPrefix + "/sub?" + argument;
585      proxy = parseProxy(global.proxyConfig);
586      switch(hash_(argTarget))
587      {
588      case "clash"_hash: case "clashr"_hash:
589          writeLog(0, argTarget == "clashr" ? "Generate target: ClashR" : "Generate target: Clash", LOG_LEVEL_INFO);
590          tpl_args.local_vars["clash.new_field_name"] = ext.clash_new_field_name ? "true" : "false";
591          response.headers["profile-update-interval"] = std::to_string(interval / 3600);
592          if(ext.nodelist)
593          {
594              YAML::Node yamlnode;
595              proxyToClash(nodes, yamlnode, dummy_group, argTarget == "clashr", ext);
596              output_content = YAML::Dump(yamlnode);
597          }
598          else
599          {
600              if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
601              {
602                  *status_code = 400;
603                  return base_content;
604              }
605              output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == "clashr", ext);
606          }
607          if(argUpload)
608              uploadGist(argTarget, argUploadPath, output_content, false);
609          break;
610      case "surge"_hash:
611          writeLog(0, "Generate target: Surge " + std::to_string(intSurgeVer), LOG_LEVEL_INFO);
612          if(ext.nodelist)
613          {
614              output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);
615              if(argUpload)
616                  uploadGist("surge" + argSurgeVer + "list", argUploadPath, output_content, true);
617          }
618          else
619          {
620              if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
621              {
622                  *status_code = 400;
623                  return base_content;
624              }
625              output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);
626              if(argUpload)
627                  uploadGist("surge" + argSurgeVer, argUploadPath, output_content, true);
628              if(global.writeManagedConfig && global.managedConfigPrefix.size())
629                  output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
630                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
631          }
632          break;
633      case "surfboard"_hash:
634          writeLog(0, "Generate target: Surfboard", LOG_LEVEL_INFO);
635          if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
636          {
637              *status_code = 400;
638              return base_content;
639          }
640          output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);
641          if(argUpload)
642              uploadGist("surfboard", argUploadPath, output_content, true);
643          if(global.writeManagedConfig && global.managedConfigPrefix.size())
644              output_content = "#!MANAGED-CONFIG " + managed_url + (interval ? " interval=" + std::to_string(interval) : "") \
645                   + " strict=" + std::string(strict ? "true" : "false") + "\n\n" + output_content;
646          break;
647      case "mellow"_hash:
648          writeLog(0, "Generate target: Mellow", LOG_LEVEL_INFO);
649          if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
650          {
651              *status_code = 400;
652              return base_content;
653          }
654          output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
655          if(argUpload)
656              uploadGist("mellow", argUploadPath, output_content, true);
657          break;
658      case "sssub"_hash:
659          writeLog(0, "Generate target: SS Subscription", LOG_LEVEL_INFO);
660          if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
661          {
662              *status_code = 400;
663              return base_content;
664          }
665          output_content = proxyToSSSub(base_content, nodes, ext);
666          if(argUpload)
667              uploadGist("sssub", argUploadPath, output_content, false);
668          break;
669      case "ss"_hash:
670          writeLog(0, "Generate target: SS", LOG_LEVEL_INFO);
671          output_content = proxyToSingle(nodes, 1, ext);
672          if(argUpload)
673              uploadGist("ss", argUploadPath, output_content, false);
674          break;
675      case "ssr"_hash:
676          writeLog(0, "Generate target: SSR", LOG_LEVEL_INFO);
677          output_content = proxyToSingle(nodes, 2, ext);
678          if(argUpload)
679              uploadGist("ssr", argUploadPath, output_content, false);
680          break;
681      case "v2ray"_hash:
682          writeLog(0, "Generate target: v2rayN", LOG_LEVEL_INFO);
683          output_content = proxyToSingle(nodes, 4, ext);
684          if(argUpload)
685              uploadGist("v2ray", argUploadPath, output_content, false);
686          break;
687      case "trojan"_hash:
688          writeLog(0, "Generate target: Trojan", LOG_LEVEL_INFO);
689          output_content = proxyToSingle(nodes, 8, ext);
690          if(argUpload)
691              uploadGist("trojan", argUploadPath, output_content, false);
692          break;
693      case "mixed"_hash:
694          writeLog(0, "Generate target: Standard Subscription", LOG_LEVEL_INFO);
695          output_content = proxyToSingle(nodes, 15, ext);
696          if(argUpload)
697              uploadGist("sub", argUploadPath, output_content, false);
698          break;
699      case "quan"_hash:
700          writeLog(0, "Generate target: Quantumult", LOG_LEVEL_INFO);
701          if(!ext.nodelist)
702          {
703              if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
704              {
705                  *status_code = 400;
706                  return base_content;
707              }
708          }
709          output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
710          if(argUpload)
711              uploadGist("quan", argUploadPath, output_content, false);
712          break;
713      case "quanx"_hash:
714          writeLog(0, "Generate target: Quantumult X", LOG_LEVEL_INFO);
715          if(!ext.nodelist)
716          {
717              if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
718              {
719                  *status_code = 400;
720                  return base_content;
721              }
722          }
723          output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
724          if(argUpload)
725              uploadGist("quanx", argUploadPath, output_content, false);
726          break;
727      case "loon"_hash:
728          writeLog(0, "Generate target: Loon", LOG_LEVEL_INFO);
729          if(!ext.nodelist)
730          {
731              if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
732              {
733                  *status_code = 400;
734                  return base_content;
735              }
736          }
737          output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
738          if(argUpload)
739              uploadGist("loon", argUploadPath, output_content, false);
740          break;
741      case "ssd"_hash:
742          writeLog(0, "Generate target: SSD", LOG_LEVEL_INFO);
743          output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);
744          if(argUpload)
745              uploadGist("ssd", argUploadPath, output_content, false);
746          break;
747      default:
748          writeLog(0, "Generate target: Unspecified", LOG_LEVEL_INFO);
749          *status_code = 500;
750          return "Unrecognized target";
751      }
752      writeLog(0, "Generate completed.", LOG_LEVEL_INFO);
753      if(argFilename.size())
754          response.headers.emplace("Content-Disposition", "attachment; filename=\"" + argFilename + "\"; filename*=utf-8''" + urlEncode(argFilename));
755      return output_content;
756  }
757  std::string simpleToClashR(RESPONSE_CALLBACK_ARGS)
758  {
759      std::string &argument = request.argument;
760      int *status_code = &response.status_code;
761      std::string url = argument.size() <= 8 ? "" : argument.substr(8);
762      if(!url.size() || argument.substr(0, 8) != "sublink=")
763      {
764          *status_code = 400;
765          return "Invalid request!";
766      }
767      if(url == "sublink")
768      {
769          *status_code = 400;
770          return "Please insert your subscription link instead of clicking the default link.";
771      }
772      request.argument = "target=clashr&url=" + urlEncode(url);
773      return subconverter(request, response);
774  }
775  std::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)
776  {
777      std::string &argument = request.argument;
778      int *status_code = &response.status_code;
779      INIReader ini;
780      string_array dummy_str_array;
781      std::vector<Proxy> nodes;
782      std::string base_content, url = argument.size() <= 5 ? "" : argument.substr(5);
783      const std::string proxygroup_name = global.clashUseNewField ? "proxy-groups" : "Proxy Group", rule_name = global.clashUseNewField ? "rules" : "Rule";
784      ini.store_any_line = true;
785      if(!url.size())
786          url = global.defaultUrls;
787      if(!url.size() || argument.substr(0, 5) != "link=")
788      {
789          *status_code = 400;
790          return "Invalid request!";
791      }
792      if(url == "link")
793      {
794          *status_code = 400;
795          return "Please insert your subscription link instead of clicking the default link.";
796      }
797      writeLog(0, "SurgeConfToClash called with url '" + url + "'.", LOG_LEVEL_INFO);
798      std::string proxy = parseProxy(global.proxyConfig);
799      YAML::Node clash;
800      template_args tpl_args;
801      tpl_args.global_vars = global.templateVars;
802      tpl_args.local_vars["clash.new_field_name"] = global.clashUseNewField ? "true" : "false";
803      tpl_args.request_params["target"] = "clash";
804      tpl_args.request_params["url"] = url;
805      if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
806      {
807          *status_code = 400;
808          return base_content;
809      }
810      clash = YAML::Load(base_content);
811      base_content = fetchFile(url, proxy, global.cacheConfig);
812      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
813      {
814          std::string errmsg = "Parsing Surge config failed! Reason: " + ini.GetLastError();
815          writeLog(0, errmsg, LOG_LEVEL_ERROR);
816          *status_code = 400;
817          return errmsg;
818      }
819      if(!ini.SectionExist("Proxy") || !ini.SectionExist("Proxy Group") || !ini.SectionExist("Rule"))
820      {
821          std::string errmsg = "Incomplete surge config! Missing critical sections!";
822          writeLog(0, errmsg, LOG_LEVEL_ERROR);
823          *status_code = 400;
824          return errmsg;
825      }
826      string_multimap section;
827      ini.GetItems("Proxy Group", section);
828      std::string name, type, content;
829      string_array links;
830      links.emplace_back(url);
831      YAML::Node singlegroup;
832      for(auto &x : section)
833      {
834          singlegroup.reset();
835          name = x.first;
836          content = x.second;
837          dummy_str_array = split(content, ",");
838          if(!dummy_str_array.size())
839              continue;
840          type = dummy_str_array[0];
841          if(!(type == "select" || type == "url-test" || type == "fallback" || type == "load-balance")) 
842              continue;
843          singlegroup["name"] = name;
844          singlegroup["type"] = type;
845          for(unsigned int i = 1; i < dummy_str_array.size(); i++)
846          {
847              if(startsWith(dummy_str_array[i], "url"))
848                  singlegroup["url"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
849              else if(startsWith(dummy_str_array[i], "interval"))
850                  singlegroup["interval"] = trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1));
851              else if(startsWith(dummy_str_array[i], "policy-path"))
852                  links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find("=") + 1)));
853              else
854                  singlegroup["proxies"].push_back(trim(dummy_str_array[i]));
855          }
856          clash[proxygroup_name].push_back(singlegroup);
857      }
858      proxy = parseProxy(global.proxySubscription);
859      eraseElements(dummy_str_array);
860      RegexMatchConfigs dummy_regex_array;
861      std::string subInfo;
862      parse_settings parse_set;
863      parse_set.proxy = &proxy;
864      parse_set.exclude_remarks = parse_set.include_remarks = &dummy_str_array;
865      parse_set.stream_rules = parse_set.time_rules = &dummy_regex_array;
866      parse_set.request_header = &request.headers;
867      parse_set.sub_info = &subInfo;
868      parse_set.authorized = !global.APIMode;
869      for(std::string &x : links)
870      {
871          writeLog(0, "Fetching node data from url '" + x + "'.", LOG_LEVEL_INFO);
872          if(addNodes(x, nodes, 0, parse_set) == -1)
873          {
874              if(global.skipFailedLinks)
875                  writeLog(0, "The following link doesn't contain any valid node info: " + x, LOG_LEVEL_WARNING);
876              else
877              {
878                  *status_code = 400;
879                  return "The following link doesn't contain any valid node info: " + x;
880              }
881          }
882      }
883      if(!nodes.size())
884      {
885          *status_code = 400;
886          return "No nodes were found!";
887      }
888      extra_settings ext;
889      ext.sort_flag = global.enableSort;
890      ext.filter_deprecated = global.filterDeprecated;
891      ext.clash_new_field_name = global.clashUseNewField;
892      ext.udp = global.UDPFlag;
893      ext.tfo = global.TFOFlag;
894      ext.skip_cert_verify = global.skipCertVerify;
895      ext.tls13 = global.TLS13Flag;
896      ext.clash_proxies_style = global.clashProxiesStyle;
897      ProxyGroupConfigs dummy_groups;
898      proxyToClash(nodes, clash, dummy_groups, false, ext);
899      section.clear();
900      ini.GetItems("Proxy", section);
901      for(auto &x : section)
902      {
903          singlegroup.reset();
904          name = x.first;
905          content = x.second;
906          dummy_str_array = split(content, ",");
907          if(!dummy_str_array.size())
908              continue;
909          content = trim(dummy_str_array[0]);
910          switch(hash_(content))
911          {
912          case "direct"_hash:
913              singlegroup["name"] = name;
914              singlegroup["type"] = "select";
915              singlegroup["proxies"].push_back("DIRECT");
916              break;
917          case "reject"_hash:
918          case "reject-tinygif"_hash:
919              singlegroup["name"] = name;
920              singlegroup["type"] = "select";
921              singlegroup["proxies"].push_back("REJECT");
922              break;
923          default:
924              continue;
925          }
926          clash[proxygroup_name].push_back(singlegroup);
927      }
928      eraseElements(dummy_str_array);
929      ini.GetAll("Rule", "{NONAME}", dummy_str_array);
930      YAML::Node rule;
931      string_array strArray;
932      std::string strLine;
933      std::stringstream ss;
934      std::string::size_type lineSize;
935      for(std::string &x : dummy_str_array)
936      {
937          if(startsWith(x, "RULE-SET"))
938          {
939              strArray = split(x, ",");
940              if(strArray.size() != 3)
941                  continue;
942              content = webGet(strArray[1], proxy, global.cacheRuleset);
943              if(!content.size())
944                  continue;
945              ss << content;
946              char delimiter = getLineBreak(content);
947              while(getline(ss, strLine, delimiter))
948              {
949                  lineSize = strLine.size();
950                  if(lineSize && strLine[lineSize - 1] == '\r') 
951                      strLine.erase(--lineSize);
952                  if(!lineSize || strLine[0] == ';' || strLine[0] == '#' || (lineSize >= 2 && strLine[0] == '/' && strLine[1] == '/')) 
953                      continue;
954                  else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);})) 
955                      continue;
956                  strLine += strArray[2];
957                  if(count_least(strLine, ',', 3))
958                      strLine = regReplace(strLine, "^(.*?,.*?)(,.*)(,.*)$", "$1$3$2");
959                  rule.push_back(strLine);
960              }
961              ss.clear();
962              continue;
963          }
964          else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&strLine](std::string type){return startsWith(strLine, type);}))
965              continue;
966          rule.push_back(x);
967      }
968      clash[rule_name] = rule;
969      response.headers["profile-update-interval"] = std::to_string(global.updateInterval / 3600);
970      writeLog(0, "Conversion completed.", LOG_LEVEL_INFO);
971      return YAML::Dump(clash);
972  }
973  std::string getProfile(RESPONSE_CALLBACK_ARGS)
974  {
975      std::string &argument = request.argument;
976      int *status_code = &response.status_code;
977      std::string name = urlDecode(getUrlArg(argument, "name")), token = urlDecode(getUrlArg(argument, "token"));
978      string_array profiles = split(name, "|");
979      name = profiles[0];
980      if(token.empty() || name.empty())
981      {
982          *status_code = 403;
983          return "Forbidden";
984      }
985      std::string profile_content;
986      if(fileExist(name))
987      {
988          profile_content = fileGet(name, true);
989      }
990      else
991      {
992          *status_code = 404;
993          return "Profile not found";
994      }
995      writeLog(0, "Trying to load profile '" + name + "'.", LOG_LEVEL_INFO);
996      INIReader ini;
997      if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
998      {
999          writeLog(0, "Load profile failed! Reason: " + ini.GetLastError(), LOG_LEVEL_ERROR);
1000          *status_code = 500;
1001          return "Broken profile!";
1002      }
1003      writeLog(0, "Trying to parse profile '" + name + "'.", LOG_LEVEL_INFO);
1004      string_multimap contents;
1005      ini.GetItems("Profile", contents);
1006      if(!contents.size())
1007      {
1008          writeLog(0, "Load profile failed! Reason: Empty Profile section", LOG_LEVEL_ERROR);
1009          *status_code = 500;
1010          return "Broken profile!";
1011      }
1012      auto profile_token = contents.find("profile_token");
1013      if(profiles.size() == 1 && profile_token != contents.end())
1014      {
1015          if(token != profile_token->second)
1016          {
1017              *status_code = 403;
1018              return "Forbidden";
1019          }
1020          token = global.accessToken;
1021      }
1022      else
1023      {
1024          if(token != global.accessToken)
1025          {
1026              *status_code = 403;
1027              return "Forbidden";
1028          }
1029      }
1030      if(profiles.size() > 1)
1031      {
1032          writeLog(0, "Multiple profiles are provided. Trying to combine profiles...", LOG_TYPE_INFO);
1033          std::string all_urls, url;
1034          auto iter = contents.find("url");
1035          if(iter != contents.end())
1036              all_urls = iter->second;
1037          for(size_t i = 1; i < profiles.size(); i++)
1038          {
1039              name = profiles[i];
1040              if(!fileExist(name))
1041              {
1042                  writeLog(0, "Ignoring non-exist profile '" + name + "'...", LOG_LEVEL_WARNING);
1043                  continue;
1044              }
1045              if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE && !ini.SectionExist("Profile"))
1046              {
1047                  writeLog(0, "Ignoring broken profile '" + name + "'...", LOG_LEVEL_WARNING);
1048                  continue;
1049              }
1050              url = ini.Get("Profile", "url");
1051              if(url.size())
1052              {
1053                  all_urls += "|" + url;
1054                  writeLog(0, "Profile url from '" + name + "' added.", LOG_LEVEL_INFO);
1055              }
1056              else
1057              {
1058                  writeLog(0, "Profile '" + name + "' does not have url key. Skipping...", LOG_LEVEL_INFO);
1059              }
1060          }
1061          iter->second = all_urls;
1062      }
1063      contents.emplace("token", token);
1064      contents.emplace("profile_data", base64Encode(global.managedConfigPrefix + "/getprofile?" + argument));
1065      std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &x, auto y){ return x + y.first + "=" + urlEncode(y.second) + "&"; });
1066      query += argument;
1067      request.argument = query;
1068      return subconverter(request, response);
1069  }
1070  inline std::string intToStream(unsigned long long stream)
1071  {
1072      char chrs[16] = {}, units[6] = {' ', 'K', 'M', 'G', 'T', 'P'};
1073      double streamval = stream;
1074      unsigned int level = 0;
1075      while(streamval > 1024.0)
1076      {
1077          if(level >= 5)
1078              break;
1079          level++;
1080          streamval /= 1024.0;
1081      }
1082      snprintf(chrs, 15, "%.2f %cB", streamval, units[level]);
1083      return std::string(chrs);
1084  }
1085  std::string subInfoToMessage(std::string subinfo)
1086  {
1087      using ull = unsigned long long;
1088      subinfo = replaceAllDistinct(subinfo, "; ", "&");
1089      std::string retdata, useddata = "N/A", totaldata = "N/A", expirydata = "N/A";
1090      std::string upload = getUrlArg(subinfo, "upload"), download = getUrlArg(subinfo, "download"), total = getUrlArg(subinfo, "total"), expire = getUrlArg(subinfo, "expire");
1091      ull used = to_number<ull>(upload, 0) + to_number<ull>(download, 0), tot = to_number<ull>(total, 0);
1092      time_t expiry = to_number<time_t>(expire, 0);
1093      if(used != 0)
1094          useddata = intToStream(used);
1095      if(tot != 0)
1096          totaldata = intToStream(tot);
1097      if(expiry != 0)
1098      {
1099          char buffer[30];
1100          struct tm *dt = localtime(&expiry);
1101          strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M", dt);
1102          expirydata.assign(buffer);
1103      }
1104      if(useddata == "N/A" && totaldata == "N/A" && expirydata == "N/A")
1105          retdata = "Not Available";
1106      else
1107          retdata += "Stream Used: " + useddata + " Stream Total: " + totaldata + " Expiry Time: " + expirydata;
1108      return retdata;
1109  }
1110  int simpleGenerator()
1111  {
1112      writeLog(0, "Reading generator configuration...", LOG_LEVEL_INFO);
1113      std::string config = fileGet("generate.ini"), path, profile, arguments, content;
1114      if(config.empty())
1115      {
1116          writeLog(0, "Generator configuration not found or empty!", LOG_LEVEL_ERROR);
1117          return -1;
1118      }
1119      INIReader ini;
1120      if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)
1121      {
1122          writeLog(0, "Generator configuration broken! Reason:" + ini.GetLastError(), LOG_LEVEL_ERROR);
1123          return -2;
1124      }
1125      writeLog(0, "Read generator configuration completed.\n", LOG_LEVEL_INFO);
1126      string_array sections = ini.GetSections();
1127      if(global.generateProfiles.size())
1128      {
1129          writeLog(0, "Generating with specific artifacts: \"" + global.generateProfiles + "\"...", LOG_LEVEL_INFO);
1130          string_array targets = split(global.generateProfiles, ","), new_targets;
1131          for(std::string &x : targets)
1132          {
1133              x = trim(x);
1134              if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())
1135                  new_targets.emplace_back(std::move(x));
1136              else
1137              {
1138                  writeLog(0, "Artifact \"" + x + "\" not found in generator settings!", LOG_LEVEL_ERROR);
1139                  return -3;
1140              }
1141          }
1142          sections = new_targets;
1143          sections.shrink_to_fit();
1144      }
1145      else
1146          writeLog(0, "Generating all artifacts...", LOG_LEVEL_INFO);
1147      string_multimap allItems;
1148      std::string proxy = parseProxy(global.proxySubscription);
1149      Request request;
1150      Response response;
1151      for(std::string &x : sections)
1152      {
1153          arguments.clear();
1154          response.status_code = 200;
1155          writeLog(0, "Generating artifact '" + x + "'...", LOG_LEVEL_INFO);
1156          ini.EnterSection(x);
1157          if(ini.ItemExist("path"))
1158              path = ini.Get("path");
1159          else
1160          {
1161              writeLog(0, "Artifact '" + x + "' output path missing! Skipping...\n", LOG_LEVEL_ERROR);
1162              continue;
1163          }
1164          if(ini.ItemExist("profile"))
1165          {
1166              profile = ini.Get("profile");
1167              request.argument = "name=" + urlEncode(profile) + "&token=" + global.accessToken + "&expand=true";
1168              content = getProfile(request, response);
1169          }
1170          else
1171          {
1172              if(ini.GetBool("direct") == true)
1173              {
1174                  std::string url = ini.Get("url");
1175                  content = fetchFile(url, proxy, global.cacheSubscription);
1176                  if(content.empty())
1177                  {
1178                      writeLog(0, "Artifact '" + x + "' generate ERROR! Please check your link.\n", LOG_LEVEL_ERROR);
1179                      if(sections.size() == 1)
1180                          return -1;
1181                  }
1182                  fileWrite(path, "\xEF\xBB\xBF" + content, true);
1183                  continue;
1184              }
1185              ini.GetItems(allItems);
1186              allItems.emplace("expand", "true");
1187              for(auto &y : allItems)
1188              {
1189                  if(y.first == "path")
1190                      continue;
1191                  arguments += y.first + "=" + urlEncode(y.second) + "&";
1192              }
1193              arguments.erase(arguments.size() - 1);
1194              request.argument = arguments;
1195              content = subconverter(request, response);
1196          }
1197          if(response.status_code != 200)
1198          {
1199              writeLog(0, "Artifact '" + x + "' generate ERROR! Reason: " + content + "\n", LOG_LEVEL_ERROR);
1200              if(sections.size() == 1)
1201                  return -1;
1202              continue;
1203          }
1204          fileWrite(path, content, true);
1205          auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == "Subscription-UserInfo"; });
1206          if(iter != response.headers.end())
1207              writeLog(0, "User Info for artifact '" + x + "': " + subInfoToMessage(iter->second), LOG_LEVEL_INFO);
1208          writeLog(0, "Artifact '" + x + "' generate SUCCESS!\n", LOG_LEVEL_INFO);
1209          eraseElements(response.headers);
1210      }
1211      writeLog(0, "All artifact generated. Exiting...", LOG_LEVEL_INFO);
1212      return 0;
1213  }
1214  std::string renderTemplate(RESPONSE_CALLBACK_ARGS)
1215  {
1216      std::string &argument = request.argument;
1217      int *status_code = &response.status_code;
1218      std::string path = urlDecode(getUrlArg(argument, "path"));
1219      writeLog(0, "Trying to render template '" + path + "'...", LOG_LEVEL_INFO);
1220      if(!startsWith(path, global.templatePath) || !fileExist(path))
1221      {
1222          *status_code = 404;
1223          return "Not found";
1224      }
1225      std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);
1226      if(template_content.empty())
1227      {
1228          *status_code = 400;
1229          return "File empty or out of scope";
1230      }
1231      template_args tpl_args;
1232      tpl_args.global_vars = global.templateVars;
1233      string_array req_args = split(argument, "&");
1234      string_size pos;
1235      string_map req_arg_map;
1236      for(std::string &x : req_args)
1237      {
1238          pos = x.find("=");
1239          if(pos == x.npos)
1240              req_arg_map[x] = "";
1241          else
1242              req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
1243      }
1244      tpl_args.request_params = req_arg_map;
1245      std::string output_content;
1246      if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)
1247      {
1248          *status_code = 400;
1249          writeLog(0, "Render failed with error.", LOG_LEVEL_WARNING);
1250      }
1251      else
1252          writeLog(0, "Render completed.", LOG_LEVEL_INFO);
1253      return output_content;
1254  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-numbers_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</div>
                </div>
                <div class="column column_space"><pre><code>166    for (int i = 0; i <= 100; i++) {
167      CheckUInt32(i);
168      CheckUInt64(i);
169    }
170    CheckInt32(INT_MIN);
171    CheckInt32(INT_MAX);
172    CheckInt64(LONG_MIN);
173    CheckInt64(uint64_t{1000000000});
174    CheckInt64(uint64_t{9999999999});
175    CheckInt64(uint64_t{100000000000000});
176    CheckInt64(uint64_t{999999999999999});
177    CheckInt64(uint64_t{1000000000000000000});
178    CheckInt64(uint64_t{1199999999999999999});
179    CheckInt64(int64_t{-700000000000000000});
180    CheckInt64(LONG_MAX);
181    CheckUInt32(std::numeric_limits<uint32_t>::max());
182    CheckUInt64(uint64_t{1000000000});
183    CheckUInt64(uint64_t{9999999999});
184    CheckUInt64(uint64_t{100000000000000});
185    CheckUInt64(uint64_t{999999999999999});
186    CheckUInt64(uint64_t{1000000000000000000});
187    CheckUInt64(uint64_t{1199999999999999999});
</pre></code></div>
                <div class="column column_space"><pre><code>56      {"ClashForAndroid","\\/([0-9.]+)","2.0","clash",true},
57      {"ClashForAndroid","\\/([0-9.]+)R","","clashr",false},
58      {"ClashForAndroid","","","clash",false},
59      {"ClashforWindows","\\/([0-9.]+)","0.11","clash",true},
60      {"ClashforWindows","","","clash",false},
61      {"ClashX Pro","","","clash",true},
62      {"ClashX","\\/([0-9.]+)","0.13","clash",true},
63      {"Clash","","","clash",true},
64      {"Kitsunebi","","","v2ray"},
65      {"Loon","","","loon"},
66      {"Pharos","","","mixed"},
67      {"Potatso","","","mixed"},
68      {"Quantumult%20X","","","quanx"},
69      {"Quantumult","","","quan"},
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    