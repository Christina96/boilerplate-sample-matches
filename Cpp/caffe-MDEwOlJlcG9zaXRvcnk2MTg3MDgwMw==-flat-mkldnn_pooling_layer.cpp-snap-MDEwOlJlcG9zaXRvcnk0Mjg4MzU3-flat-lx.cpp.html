
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.0232675771370765%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKLDNN_SUPPORTED
2  #include <algorithm>
3  #include <cfloat>
4  #include <vector>
5  #include "caffe/common.hpp"
6  #include "caffe/layer.hpp"
7  #include "caffe/layers/mkldnn_layers.hpp"
8  #include "caffe/syncedmem.hpp"
9  #include "caffe/util/math_functions.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void MKLDNNPoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom
13                                              ,const vector<Blob<Dtype>*>& top)
14  {
15      VLOG(1) << "MKLDNNPoolingLayer<Dtype>::LayerSetUp: " << this->layer_param_.name();
16      Layer<Dtype>::LayerSetUp(bottom, top);
17      PoolingParameter pool_param = this->layer_param_.pooling_param();
18      if (pool_param.global_pooling()) {
19          CHECK(!(pool_param.has_kernel_size() || pool_param.has_kernel_h() || pool_param.has_kernel_w()))
20              << "With Global_pooling: true Filter size cannot specified";
21      } else {
22          CHECK(!pool_param.has_kernel_size() != !(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
23              << "Filter size is kernel_size OR kernel_h and kernel_w; not both";
24          CHECK(pool_param.has_kernel_size() ||(pool_param.has_kernel_h() && pool_param.has_kernel_w()))
25              << "For non-square filters both kernel_h and kernel_w are required.";
26      }
27      CHECK((!pool_param.has_pad() && pool_param.has_pad_h() && pool_param.has_pad_w())
28              || (!pool_param.has_pad_h() && !pool_param.has_pad_w()))
29          << "pad is pad OR pad_h and pad_w are required.";
30      CHECK((!pool_param.has_stride() && pool_param.has_stride_h() && pool_param.has_stride_w())
31              || (!pool_param.has_stride_h() && !pool_param.has_stride_w()))
32          << "Stride is stride OR stride_h and stride_w are required.";
33      global_pooling_ = pool_param.global_pooling();
34      if (global_pooling_) {
35          kernel_h_ = bottom[0]->height();
36          kernel_w_ = bottom[0]->width();
37      } else {
38          if (pool_param.has_kernel_size()) {
39            kernel_h_ = kernel_w_ = pool_param.kernel_size();
40          } else {
41            kernel_h_ = pool_param.kernel_h();
42            kernel_w_ = pool_param.kernel_w();
43          }
44      }
45      CHECK_GT(kernel_h_, 0) << "Filter dimensions cannot be zero.";
46      CHECK_GT(kernel_w_, 0) << "Filter dimensions cannot be zero.";
47      if (!pool_param.has_pad_h()) {
48          pad_t_ = pad_b_ = pad_l_ = pad_r_ = pool_param.pad();
49      } else {
50          pad_t_ = pad_b_ = pool_param.pad_h();
51          pad_l_ = pad_r_ = pool_param.pad_w();
52      }
53      if (!pool_param.has_stride_h()) {
54          stride_h_ = stride_w_ = pool_param.stride();
55      } else {
56          stride_h_ = pool_param.stride_h();
57          stride_w_ = pool_param.stride_w();
58      }
59      if (global_pooling_) {
60          CHECK(pad_t_ == 0 && pad_l_ == 0 && stride_h_ == 1 && stride_w_ == 1)
61              << "With Global_pooling: true; only pad = 0 and stride = 1";
62      }
63      if (pad_t_ != 0 || pad_l_ != 0) {
64          CHECK(this->layer_param_.pooling_param().pool() == PoolingParameter_PoolMethod_AVE
65          || this->layer_param_.pooling_param().pool() == PoolingParameter_PoolMethod_MAX)
66          << "Padding implemented only for average and max pooling.";
67          CHECK_LT(pad_t_, kernel_h_);
68          CHECK_LT(pad_l_, kernel_w_);
69      }
70      compute_output_shape(bottom, top);
71  }
72  template <typename Dtype>
73  void MKLDNNPoolingLayer<Dtype>::compute_output_shape(const vector<Blob<Dtype>*>& bottom
74                                          ,const vector<Blob<Dtype>*>& top)
75  {
76      height_out_ = static_cast<int>(ceil(static_cast<float>(
77          bottom[0]->height() + pad_t_ + pad_b_ - kernel_h_) / stride_h_)) + 1;
78      width_out_ = static_cast<int>(ceil(static_cast<float>(
79          bottom[0]->width() + pad_r_ + pad_l_ - kernel_w_) / stride_w_)) + 1;
80      if (pad_t_ || pad_b_ || pad_r_ || pad_l_ || kernel_h_ == 1 || kernel_w_ == 1) {
81          if ((height_out_ - 1) * stride_h_ >= bottom[0]->height() + pad_t_) {
82            --height_out_;
83          }
84          if ((width_out_ - 1) * stride_w_ >= bottom[0]->width() + pad_l_) {
85            --width_out_;
86          }
87          CHECK_LT((height_out_ - 1) * stride_h_, bottom[0]->height() + pad_t_);
88          CHECK_LT((width_out_ - 1) * stride_w_, bottom[0]->width() + pad_l_);
89      }
90      else
91      {
92        force_exclude_padding_flag_ = true;
93      }
94      auto h = bottom[0]->height() + pad_t_;
95      while (h + pad_b_ < stride_h_ * (height_out_ - 1) + kernel_h_) pad_b_++;
96      auto w = bottom[0]->width() + pad_l_;
97      while (w + pad_r_ < stride_w_ * (width_out_ - 1) + kernel_w_) pad_r_++;
98  }
99  template <typename Dtype>
100  void MKLDNNPoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom
101                                          ,const vector<Blob<Dtype>*>& top)
102  {
103      VLOG(1) << "MKLDNNPoolingLayer<Dtype>::Reshape: "  << this->layer_param_.name();
104      this->reshape = (this->width_ == bottom[0]->width() &&
105                       this->height_ == bottom[0]->height() &&
106                       this->channels_ == bottom[0]->channels() &&
107                       this->num_ == bottom[0]->num()) ? false : true;
108      this->num_ = bottom[0]->num();
109      this->channels_ = bottom[0]->channels();
110      this->height_ = bottom[0]->height();
111      this->width_ = bottom[0]->width();
112      compute_output_shape(bottom, top);
113      CHECK_EQ(4, bottom[0]->num_axes()) << "Input must have 4 axes, "
114          << "corresponding to (num, channels, height, width)";
115      top[0]->Reshape(bottom[0]->num(), channels_, height_out_, width_out_);
116      if (top.size() > 1) {
117          (reinterpret_cast<Blob<uint32_t>* > (top[1]) )->Reshape(num_,
118              channels_, height_out_, width_out_);
119      }
120      if (top.size() == 1) {
121          max_idx_.Reshape(bottom[0]->num(), channels_, height_out_, width_out_);
122      }
123  }
124  template <typename Dtype>
125  void MKLDNNPoolingLayer<Dtype>::InitPoolingFwd(const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top)
126  {
127      if (std::is_same<Dtype, double>::value)  NOT_IMPLEMENTED;
128      auto propagation = this->phase_ == TEST ? prop_kind::forward_scoring : prop_kind::forward_training;
129      algorithm pooling_algorithm;
130      switch (this->layer_param_.pooling_param().pool()) {
131      case PoolingParameter_PoolMethod_MAX:
132          pooling_algorithm = algorithm::pooling_max;
133          break;
134      case PoolingParameter_PoolMethod_AVE:
135          if (this->layer_param_.pooling_param().avg_include_pad()) {
136              pooling_algorithm = algorithm::pooling_avg_include_padding;
137          }else {
138              pooling_algorithm = algorithm::pooling_avg_exclude_padding;
139          }
140          if (force_exclude_padding_flag_ == true)
141          {
142            pooling_algorithm = algorithm::pooling_avg_exclude_padding;
143          }
144          break;
145      case PoolingParameter_PoolMethod_STOCHASTIC:
146          NOT_IMPLEMENTED;
147          break;
148      default:
149          LOG(FATAL) << "Unknown pooling method.";
150      }
151      int32_t n = this->num_;
152      int32_t c = this->channels_;
153      int32_t ih = this->height_;
154      int32_t iw = this->width_;
155      int32_t oh = this->height_out_;
156      int32_t ow = this->width_out_;
157      int32_t kh = this->kernel_h_;
158      int32_t kw = this->kernel_w_;
159      int32_t sh = this->stride_h_;
160      int32_t sw = this->stride_w_;
161      int32_t pt = this->pad_t_;
162      int32_t pb = this->pad_b_;
163      int32_t pl = this->pad_l_;
164      int32_t pr = this->pad_r_;
165      bool bottom_data_is_prv = (const_cast<Dtype*>(bottom[0]->prv_data()) != NULL);
166      bool top_data_is_prv = (const_cast<Dtype*>(top[0]->prv_data()) != NULL);
167      engine cpu_engine = CpuEngine::Instance().get_engine();
168      memory::data_type mpcsn = memory::data_type::f32;
169      memory::dims bottom_tz = {n, c, ih, iw};
170      memory::dims top_tz = {n, c, oh, ow};
171      memory::format mfmt_nchw = memory::format::nchw;
172      typedef typename memory::primitive_desc MemPD; 
173      memory::format cmfmt = mfmt_nchw;
174      shared_ptr<MemPD> usr_bottom_data_mpd(new MemPD({{bottom_tz}, mpcsn, mfmt_nchw}, cpu_engine));
175      shared_ptr<MemPD> usr_top_data_mpd(new MemPD({{top_tz}, mpcsn, mfmt_nchw}, cpu_engine));
176      std::vector<float> scale(1, 1.);
177      if (bottom_data_is_prv || top_data_is_prv) {
178          shared_ptr<MKLDNNMemoryDescriptor<Dtype, false> > mem_descr
179              = get_mkldnn_prv_descriptor<Dtype, false>(bottom[0]);
180          cmfmt = static_cast<memory::format>(mem_descr->prv_memory_pd()->desc().data.format);
181          mpcsn = static_cast<memory::data_type>(mem_descr->prv_memory_pd()->desc().data.data_type);
182          scale[0] = mem_descr->get_scale(0);
183          mpcsn = (mpcsn==memory::data_type::s8) && mem_descr->get_sum() ? memory::data_type::u8 : mpcsn;
184      }
185      shared_ptr<memory::desc> init_fwd_bottom_md(new memory::desc({bottom_tz}, mpcsn, cmfmt));
186      shared_ptr<memory::desc> init_fwd_top_md(new memory::desc({top_tz}, mpcsn, cmfmt));
187      pooling_forward::desc poolingFwd_desc(propagation, pooling_algorithm, *init_fwd_bottom_md,*init_fwd_top_md
188                                          , {sh, sw}, {kh, kw}, {pt, pl}, {pb, pr}, padding_kind::zero);
189      std::string subengines = this->layer_param_.engine();
190      if (subengines.find("MKLDNN") == std::string::npos || subengines == "MKLDNN")
191        subengines = "MKLDNN:CPU";
192      EngineParser ep(subengines);
193      unsigned subEngineIndex = 0;
194      poolingFwd_pd = NULL;
195      for(; subEngineIndex < ep.getNumberOfSubEngines(); subEngineIndex++) {
196        try {
197          poolingFwd_pd.reset(new pooling_forward::primitive_desc(poolingFwd_desc,
198                  ep.getMKLDNNSubEngine(subEngineIndex)));
199        }
200        catch(...) {
201          continue;
202        }
203        break;
204      }
205      CHECK(poolingFwd_pd);
206      engine engine = ep.getMKLDNNSubEngine(subEngineIndex);
207      shared_ptr<MemPD> prv_fwd_bottom_data_mpd;
208      shared_ptr<MemPD> prv_fwd_top_data_mpd;
209      if (bottom_data_is_prv || top_data_is_prv) {
210          prv_fwd_bottom_data_mpd.reset(new MemPD(*init_fwd_bottom_md, engine));
211          prv_fwd_top_data_mpd.reset(new MemPD(*init_fwd_top_md, engine));
212          info_mem_pd<Dtype>(prv_fwd_bottom_data_mpd, "pooling_src:" + this->layer_param_.name());
213          info_mem_pd<Dtype>(prv_fwd_top_data_mpd, "pooling_dst:" + this->layer_param_.name());
214      }
215      uint32_t* mask = NULL;  
216      const bool use_top_mask = top.size() > 1;
217      mask = (use_top_mask) ?  reinterpret_cast<uint32_t*>(top[1]->mutable_cpu_data())
218              : max_idx_.mutable_cpu_data();
219      fwd_bottom_data.reset(new MKLDNNData<Dtype>(usr_bottom_data_mpd, prv_fwd_bottom_data_mpd, bottom[0], this, scale));
220      fwd_bottom_data_primitive = fwd_bottom_data->create_input(false);
221      fwd_top_data.reset(new MKLDNNData<Dtype>(usr_top_data_mpd, prv_fwd_top_data_mpd, top[0], this, scale));
222      fwd_top_data_memory = fwd_top_data->create_output_memory();
223      if (propagation == prop_kind::forward_training &&
224              pooling_algorithm != algorithm::pooling_avg_exclude_padding &&
225              pooling_algorithm != algorithm::pooling_avg_include_padding) {
226          indices_pd.reset(new MemPD(poolingFwd_pd->workspace_primitive_desc()));
227          indices_memory.reset(new memory(*indices_pd, reinterpret_cast<void *>(mask)));
228          poolingFwd.reset(new pooling_forward(*poolingFwd_pd, *fwd_bottom_data_primitive, *fwd_top_data_memory, *indices_memory));
229      } else {
230          poolingFwd.reset(new pooling_forward(*poolingFwd_pd, *fwd_bottom_data_primitive, *fwd_top_data_memory));
231      }
232      MKLDNNPrimitive<Dtype> fwd_bottom_data_primitive_transfer(fwd_bottom_data_primitive);
233      fwd_bottom_data->set_mkldnn_primitive(fwd_bottom_data_primitive_transfer);
234      MKLDNNPrimitive<Dtype> fwd_top_data_memory_transfer(fwd_top_data_memory);
235      fwd_top_data->set_mkldnn_primitive(fwd_top_data_memory_transfer);
236  }
237  template <typename Dtype>
238  void MKLDNNPoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom
239                                              ,const vector<Blob<Dtype>*>& top)
240  {
241      VLOG(1) << "MKLDNNPoolingLayer<Dtype>::Forward_cpu: " << this->layer_param_.name();
242  #ifdef DEBUG
243      LOG(INFO) << "MKLDNNPoolingLayer<Dtype>::Forward_cpu: " << this->layer_param_.name();
244  #endif
245      bool _mkldnn_primitive = false;
246      if (NULL == poolingFwd_pd || this->reshape) {
247          InitPoolingFwd(bottom, top);
248          _mkldnn_primitive = true;
249      }
250      fwd_bottom_data->sync_before_read();
251      fwd_top_data->sync_before_write();
252      PERFORMANCE_EVENT_ID_INIT(perf_id_fw_, PERFORMANCE_MKLDNN_NAME("FW"));
253      PERFORMANCE_MEASUREMENT_BEGIN();
254      poolingFwd.submit();
255      if (_mkldnn_primitive) {
256        CircleBuf::Instance()->DecRefCnt(bottom[0]->prv_data());
257      }
258      PERFORMANCE_MEASUREMENT_END_ID(perf_id_fw_);
259  }
260  template <typename Dtype>
261  void MKLDNNPoolingLayer<Dtype>::InitPoolingBwd(const vector<Blob<Dtype>*>& top
262                                                 , const vector<bool>& propagate_down
263                                                 , const vector<Blob<Dtype>*>& bottom)
264  {
265      if (std::is_same<Dtype, double>::value)  NOT_IMPLEMENTED;
266      algorithm pooling_algorithm;
267      switch (this->layer_param_.pooling_param().pool()) {
268      case PoolingParameter_PoolMethod_MAX:
269          pooling_algorithm = algorithm::pooling_max;
270          break;
271      case PoolingParameter_PoolMethod_AVE:
<span onclick='openModal()' class='match'>272          if (this->layer_param_.pooling_param().avg_include_pad()) {
273              pooling_algorithm = algorithm::pooling_avg_include_padding;
274          }else {
275              pooling_algorithm = algorithm::pooling_avg_exclude_padding;
276          }
277          break;
278      case PoolingParameter_PoolMethod_STOCHASTIC:
</span>279          NOT_IMPLEMENTED;
280          break;
281      default:
282          LOG(FATAL) << "Unknown pooling method.";
283      }
284      int32_t n = this->num_;
285      int32_t c = this->channels_;
286      int32_t ih = this->height_;
287      int32_t iw = this->width_;
288      int32_t oh = this->height_out_;
289      int32_t ow = this->width_out_;
290      int32_t kh = this->kernel_h_;
291      int32_t kw = this->kernel_w_;
292      int32_t sh = this->stride_h_;
293      int32_t sw = this->stride_w_;
294      int32_t pt = this->pad_t_;
295      int32_t pb = this->pad_b_;
296      int32_t pr = this->pad_r_;
297      int32_t pl = this->pad_l_;
298      bool top_diff_is_prv = (const_cast<Dtype*>(top[0]->prv_diff()) != NULL);
299      engine cpu_engine = CpuEngine::Instance().get_engine();
300      memory::data_type mpcsn = memory::data_type::f32;
301      memory::dims bottom_tz = {n, c, ih, iw};
302      memory::dims top_tz = {n, c, oh, ow};
303      memory::format mfmt_nchw = memory::format::nchw;
304      typedef typename memory::primitive_desc MemPD; 
305      memory::format bwd_cmfmt = mfmt_nchw;
306      if (top_diff_is_prv) {
307          shared_ptr<MKLDNNMemoryDescriptor<Dtype, true> > mem_descr
308              = get_mkldnn_prv_descriptor<Dtype, true>(top[0]);
309          bwd_cmfmt = static_cast<memory::format>(mem_descr->prv_memory_pd()->desc().data.format);
310      }
311      bool bottom_data_is_prv = (const_cast<Dtype*>(bottom[0]->prv_data()) != NULL);
312      if (bottom_data_is_prv) {
313          shared_ptr<MKLDNNMemoryDescriptor<Dtype, false> > mem_descr
314              = get_mkldnn_prv_descriptor<Dtype, false>(bottom[0]);
315          memory::format fwd_prv_bottom_data_mfmt = static_cast<memory::format>(mem_descr->prv_memory_pd()->desc().data.format);
316  #ifdef DEBUG
317          LOG(INFO) << "MKLDNNPoolingLayer<Dtype>::InitPoolingBwd: memory format of prv bottom data is: " << fwd_prv_bottom_data_mfmt;
318          LOG(INFO) << "MKLDNNPoolingLayer<Dtype>::InitPoolingBwd: Reorder the top and bottom diff to the format of prv bottom data! (Performance consideration)";
319  #endif
320          bwd_cmfmt = fwd_prv_bottom_data_mfmt;
321      }
322      shared_ptr<memory::desc> init_bwd_bottom_md(new memory::desc({bottom_tz}, mpcsn, bwd_cmfmt));
323      shared_ptr<memory::desc> init_bwd_top_md(new memory::desc({top_tz}, mpcsn, bwd_cmfmt));
324      shared_ptr<MemPD> usr_bottom_data_mpd(new MemPD({{bottom_tz}, mpcsn, mfmt_nchw}, cpu_engine));
325      shared_ptr<MemPD> usr_top_data_mpd(new MemPD({{top_tz}, mpcsn, mfmt_nchw}, cpu_engine));
326      pooling_backward::desc poolingBwd_desc(pooling_algorithm, *init_bwd_bottom_md,*init_bwd_top_md
327                                          , {sh, sw}, {kh, kw}, {pt, pl}, {pb, pr}, padding_kind::zero);
328      std::string subengines = this->layer_param_.engine();
329      if (subengines.find("MKLDNN") == std::string::npos || subengines == "MKLDNN")
330        subengines = "MKLDNN:CPU";
331      EngineParser ep(subengines);
332      unsigned subEngineIndex = 0;
333      poolingBwd_pd = NULL;
334      for(; subEngineIndex < ep.getNumberOfSubEngines(); subEngineIndex++) {
335        try {
336          poolingBwd_pd.reset(new pooling_backward::primitive_desc(poolingBwd_desc,
337                  ep.getMKLDNNSubEngine(subEngineIndex), *poolingFwd_pd));
338        }
339        catch(...) {
340          continue;
341        }
342        break;
343      }
344      CHECK(poolingBwd_pd);
345      engine engine = ep.getMKLDNNSubEngine(subEngineIndex);
346      shared_ptr<MemPD> prv_bwd_bottom_diff_mpd, prv_bwd_top_diff_mpd;
347      if (top_diff_is_prv || bottom_data_is_prv) {
348          prv_bwd_bottom_diff_mpd.reset(new MemPD(*init_bwd_bottom_md, engine));
349          prv_bwd_top_diff_mpd.reset(new MemPD(*init_bwd_top_md, engine));
350      }
351      bwd_bottom_diff.reset(new MKLDNNDiff<Dtype>(usr_bottom_data_mpd, prv_bwd_bottom_diff_mpd, bottom[0], this));
352      bwd_bottom_diff->name = "bwd_bottom_diff_data   @ " + this->layer_param_.name();
353      bwd_bottom_diff_memory = bwd_bottom_diff->create_output_memory();
354      bwd_top_diff.reset(new MKLDNNDiff<Dtype>(usr_top_data_mpd, prv_bwd_top_diff_mpd, top[0], this));
355      bwd_top_diff->name = "bwd_top_diff_data   @ " + this->layer_param_.name();
356      bwd_top_diff_primitive = bwd_top_diff->create_input(false);
357      if (pooling_algorithm != algorithm::pooling_avg_include_padding &&
358           pooling_algorithm != algorithm::pooling_avg_exclude_padding)
359          poolingBwd.reset(new pooling_backward(*poolingBwd_pd,
360                      *bwd_top_diff_primitive, *indices_memory,
361                      *bwd_bottom_diff_memory));
362      else
363          poolingBwd.reset(new pooling_backward(*poolingBwd_pd,
364                      *bwd_top_diff_primitive, *bwd_bottom_diff_memory));
365      MKLDNNPrimitive<Dtype> bwd_bottom_diff_memory_transfer(bwd_bottom_diff_memory);
366      bwd_bottom_diff->set_mkldnn_primitive(bwd_bottom_diff_memory_transfer);
367      MKLDNNPrimitive<Dtype> bwd_top_diff_primitive_transfer(bwd_top_diff_primitive);
368      bwd_top_diff->set_mkldnn_primitive(bwd_top_diff_primitive_transfer);
369  }
370  template <typename Dtype>
371  void MKLDNNPoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top
372                                              , const vector<bool>& propagate_down
373                                              , const vector<Blob<Dtype>*>& bottom)
374  {
375      VLOG(1) << "MKLDNNPoolingLayer<Dtype>::Backward_cpu: " << this->layer_param_.name();
376  #ifdef DEBUG
377      LOG(INFO) << "MKLDNNPoolingLayer<Dtype>::Backward_cpu: " << this->layer_param_.name();
378  #endif
379      if (!propagate_down[0]) {
380          return;
381      }
382      if (NULL == poolingBwd_pd || this->reshape)
383          InitPoolingBwd(top, propagate_down, bottom);
384      bwd_top_diff->sync_before_read();
385      bwd_bottom_diff->sync_before_write();
386      PERFORMANCE_EVENT_ID_INIT(perf_id_bw_, PERFORMANCE_MKLDNN_NAME("BW"));
387      PERFORMANCE_MEASUREMENT_BEGIN();
388  #ifdef DEBUG
389      if (bottom[0]->prv_data() != NULL)
390      {
391          LOG(INFO) << "Debug: Bottom prv data: " << *bottom[0]->prv_data();
392      }
393      else
394      {
395          LOG(INFO) << "Debug: Bottom prv data is NULL!";
396      }
397      if (top[0]->prv_diff() != NULL)
398      {
399          LOG(INFO) << "Debug: Top prv diff: " << *top[0]->prv_diff();
400      }
401      else
402      {
403          LOG(INFO) << "Debug: Top prv diff is NULL!";
404      }
405  #endif
406      poolingBwd.submit();
407  #ifdef DEBUG
408      if (bottom[0]->prv_diff() != NULL)
409      {
410          LOG(INFO) << "Debug: Bottom prv diff: " << *bottom[0]->prv_diff();
411      }
412      else
413      {
414          LOG(INFO) << "Debug: Bottom prv diff is NULL!";
415      }
416  #endif
417      PERFORMANCE_MEASUREMENT_END_ID(perf_id_bw_);
418  }
419  #ifdef CPU_ONLY
420  STUB_GPU(MKLDNNPoolingLayer);
421  #else
422  template <typename Dtype>
423  void MKLDNNPoolingLayer<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom
424                                              ,const vector<Blob<Dtype>*>& top)
425  { NOT_IMPLEMENTED; }
426  template <typename Dtype>
427  void MKLDNNPoolingLayer<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top
428                                              ,const vector<bool>& propagate_down
429                                              ,const vector<Blob<Dtype>*>& bottom)
430  { NOT_IMPLEMENTED; }
431  #endif
432  INSTANTIATE_CLASS(MKLDNNPoolingLayer);
433  }  
434  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lx.cpp</h3>
            <pre><code>1  void TLxChDef::SetUcCh(const TStr& Str){
2    for (int CC=1; CC<Str.Len(); CC++){
3      UcChV[Str[CC]-TCh::Mn]=TCh(Str[0]);}
4  }
5  void TLxChDef::SetChTy(const TLxChTy& ChTy, const TStr& Str){
6    for (int CC=0; CC<Str.Len(); CC++){
7      ChTyV[Str[CC]-TCh::Mn]=TInt(ChTy);}
8  }
9  TLxChDef::TLxChDef(const TLxChDefTy& ChDefTy):
10    ChTyV(TCh::Vals), UcChV(TCh::Vals){
11    if (ChDefTy==lcdtUsAscii){
12      ChTyV.PutAll(TInt(lctSpace));
13      SetChTy(lctNum, "0123456789");
14      SetChTy(lctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
15      SetChTy(lctAlpha, "abcdefghijklmnopqrstuvwxyz");
16      SetChTy(lctAlpha, "@_");
17      SetChTy(lctSSym, "\"'.,:;+-*/%!#|&<=>?()[]{}");
18      SetChTy(lctTerm, TStr(TCh::CrCh));
19      SetChTy(lctTerm, TStr(TCh::LfCh));
20      SetChTy(lctTerm, TStr(TCh::EofCh));
21      for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}
22      SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("Dd"); SetUcCh("Ee");
23      SetUcCh("Ff"); SetUcCh("Gg"); SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj");
24      SetUcCh("Kk"); SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo");
25      SetUcCh("Pp"); SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("Tt");
26      SetUcCh("Uu"); SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy");
27      SetUcCh("Zz");
28    } else
29    if (ChDefTy==lcdtYuAscii){
30      ChTyV.PutAll(TInt(lctSpace));
31      SetChTy(lctNum, "0123456789");
32      SetChTy(lctAlpha, "ABC^]D\\EFGHIJKLMNOPQRS[TUVWXYZ@");
33      SetChTy(lctAlpha, "abc~}d|efghijklmnopqrs{tuvwxyz`");
34      SetChTy(lctAlpha, "_");
35      SetChTy(lctSSym, "\".,:;+-*/%!#&<=>?()");
36      SetChTy(lctTerm, TStr(TCh::CrCh));
37      SetChTy(lctTerm, TStr(TCh::LfCh));
38      SetChTy(lctTerm, TStr(TCh::EofCh));
39      for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}
40      SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("^~"); SetUcCh("]}");
41      SetUcCh("Dd"); SetUcCh("\\|"); SetUcCh("Ee"); SetUcCh("Ff"); SetUcCh("Gg");
42      SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj"); SetUcCh("Kk"); SetUcCh("Ll");
43      SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo"); SetUcCh("Pp"); SetUcCh("Qq");
44      SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("[{"); SetUcCh("Tt"); SetUcCh("Uu");
45      SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy"); SetUcCh("Zz");
46      SetUcCh("@`");
47    } else {
48      Fail;
49    }
50  }
51  bool TLxChDef::IsNmStr(const TStr& Str) const {
52    if (Str.Len()==0){return false;}
53    if (!IsAlpha(Str.GetCh(0))){return false;}
54    for (int ChN=1; ChN<Str.Len(); ChN++){
55      if (!IsAlNum(Str.GetCh(ChN))){return false;}}
56    return true;
57  }
58  TStr TLxChDef::GetUcStr(const TStr& Str) const {
59    TChA UcStr;
60    for (int ChN=0; ChN<Str.Len(); ChN++){
61      UcStr.AddCh(GetUc(Str.GetCh(ChN)));}
62    return UcStr;
63  }
64  PLxChDef TLxChDef::GetChDef(const TLxChDefTy& ChDefTy){
65    static PLxChDef UsAsciiChDef=NULL;
66    static PLxChDef YuAsciiChDef=NULL;
67    switch (ChDefTy){
68      case lcdtUsAscii:
69        if (UsAsciiChDef.Empty()){UsAsciiChDef=TLxChDef::New(lcdtUsAscii);}
70        return UsAsciiChDef;
71      case lcdtYuAscii:
72        if (YuAsciiChDef.Empty()){YuAsciiChDef=TLxChDef::New(lcdtYuAscii);}
73        return YuAsciiChDef;
74      default: Fail; return NULL;
75    }
76  }
77  const TStr TLxSymStr::UndefStr="<undefined>";
78  const TStr TLxSymStr::LnStr="<line>";
79  const TStr TLxSymStr::TabStr="<tab>";
80  const TStr TLxSymStr::IntStr="<integer>";
81  const TStr TLxSymStr::FltStr="<float>";
82  const TStr TLxSymStr::StrStr="<string>";
83  const TStr TLxSymStr::IdStrStr="<id-string>";
84  const TStr TLxSymStr::QStrStr="<q-string>";
85  const TStr TLxSymStr::PeriodStr=".";
86  const TStr TLxSymStr::DPeriodStr="..";
87  const TStr TLxSymStr::CommaStr=",";
88  const TStr TLxSymStr::ColonStr=":";
89  const TStr TLxSymStr::DColonStr="::";
90  const TStr TLxSymStr::SemicolonStr=";";
91  const TStr TLxSymStr::PlusStr="+";
92  const TStr TLxSymStr::MinusStr="-";
93  const TStr TLxSymStr::AsteriskStr="*";
94  const TStr TLxSymStr::SlashStr="/";
95  const TStr TLxSymStr::PercentStr="%";
96  const TStr TLxSymStr::ExclamationStr="!";
97  const TStr TLxSymStr::VBarStr="|";
98  const TStr TLxSymStr::AmpersandStr="&";
99  const TStr TLxSymStr::QuestionStr="?";
100  const TStr TLxSymStr::HashStr="#";
101  const TStr TLxSymStr::EqStr="=";
102  const TStr TLxSymStr::NEqStr="<>";
103  const TStr TLxSymStr::LssStr="<";
104  const TStr TLxSymStr::GtrStr=">";
105  const TStr TLxSymStr::LEqStr="<=";
106  const TStr TLxSymStr::GEqStr=">=";
107  const TStr TLxSymStr::LParenStr="(";
108  const TStr TLxSymStr::RParenStr=")";
109  const TStr TLxSymStr::LBracketStr="[";
110  const TStr TLxSymStr::RBracketStr="]";
111  const TStr TLxSymStr::LBraceStr="{";
112  const TStr TLxSymStr::RBraceStr="}";
113  const TStr TLxSymStr::EolnStr="<end-of-line>";
114  const TStr TLxSymStr::EofStr="<end-of-file>";
115  TStr TLxSymStr::GetSymStr(const TLxSym& Sym){
116    switch (Sym){
117      case syUndef: return UndefStr;
118      case syLn: return LnStr;
119      case syTab: return TabStr;
120      case syInt: return IntStr;
121      case syFlt: return FltStr;
122      case syStr: return StrStr;
123      case syIdStr: return IdStrStr;
124      case syQStr: return QStrStr;
125      case syPeriod: return PeriodStr;
126      case syDPeriod: return DPeriodStr;
127      case syComma: return CommaStr;
128      case syColon: return ColonStr;
129      case syDColon: return DColonStr;
130      case sySemicolon: return SemicolonStr;
131      case syPlus: return PlusStr;
132      case syMinus: return MinusStr;
133      case syAsterisk: return AsteriskStr;
134      case sySlash: return SlashStr;
135      case syPercent: return PercentStr;
136      case syExclamation: return ExclamationStr;
137      case syVBar: return VBarStr;
138      case syAmpersand: return AmpersandStr;
139      case syQuestion: return QuestionStr;
140      case syHash: return HashStr;
141      case syEq: return EqStr;
142      case syNEq: return NEqStr;
143      case syLss: return LssStr;
144      case syGtr: return GtrStr;
145      case syLEq: return LEqStr;
146      case syGEq: return GEqStr;
147      case syLParen: return LParenStr;
148      case syRParen: return RParenStr;
149      case syLBracket: return LBracketStr;
150      case syRBracket: return RBracketStr;
151      case syLBrace: return LBraceStr;
152      case syRBrace: return RBraceStr;
153      case syEoln: return EolnStr;
154      case syEof: return EofStr;
155      default: Fail; return TStr();
156    }
157  }
158  TLxSym TLxSymStr::GetSSym(const TStr& Str){
159    static TStrIntH StrToLxSymH(100);
160    if (StrToLxSymH.Len()==0){
161      StrToLxSymH.AddDat(PeriodStr, syPeriod);
162      StrToLxSymH.AddDat(DPeriodStr, syDPeriod);
163      StrToLxSymH.AddDat(CommaStr, syComma);
164      StrToLxSymH.AddDat(ColonStr, syColon);
165      StrToLxSymH.AddDat(DColonStr, syDColon);
166      StrToLxSymH.AddDat(SemicolonStr, sySemicolon);
167      StrToLxSymH.AddDat(PlusStr, syPlus);
168      StrToLxSymH.AddDat(MinusStr, syMinus);
169      StrToLxSymH.AddDat(AsteriskStr, syAsterisk);
170      StrToLxSymH.AddDat(SlashStr, sySlash);
171      StrToLxSymH.AddDat(PercentStr, syPercent);
172      StrToLxSymH.AddDat(ExclamationStr, syExclamation);
173      StrToLxSymH.AddDat(VBarStr, syVBar);
174      StrToLxSymH.AddDat(AmpersandStr, syAmpersand);
175      StrToLxSymH.AddDat(QuestionStr, syQuestion);
176      StrToLxSymH.AddDat(HashStr, syHash);
177      StrToLxSymH.AddDat(EqStr, syEq);
178      StrToLxSymH.AddDat(NEqStr, syNEq);
179      StrToLxSymH.AddDat(LssStr, syLss);
180      StrToLxSymH.AddDat(GtrStr, syGtr);
181      StrToLxSymH.AddDat(LEqStr, syLEq);
182      StrToLxSymH.AddDat(GEqStr, syGEq);
183      StrToLxSymH.AddDat(LParenStr, syLParen);
184      StrToLxSymH.AddDat(RParenStr, syRParen);
185      StrToLxSymH.AddDat(LBracketStr, syLBracket);
186      StrToLxSymH.AddDat(RBracketStr, syRBracket);
187      StrToLxSymH.AddDat(LBraceStr, syLBrace);
188      StrToLxSymH.AddDat(RBraceStr, syRBrace);
189    }
190    int KeyId=StrToLxSymH.GetKeyId(Str);
191    if (KeyId==-1){
192      return syUndef;
193    } else {
194      return TLxSym(int(StrToLxSymH[KeyId]));
195    }
196  }
197  bool TLxSymStr::IsSep(const TLxSym& PrevSym, const TLxSym& Sym){
198    static TFSet SepPrevSymSet=TFSet()|
199      syUndef|syColon|syDColon|syEq|
200      syLParen|syRParen|syLBracket|syRBracket|syLBrace|syRBrace|
201      syEoln|syEof;
202    static TFSet SepSymSet=TFSet()|
203      syPeriod|syComma|syColon|syDColon|sySemicolon|
204      syEq|
205      syExclamation|syQuestion|
206      syLParen|syRParen|syLBracket|syRBracket|syLBrace|syRBrace|
207      syEoln|syEof;
208    return !SepPrevSymSet.In(PrevSym) && !SepSymSet.In(Sym);
209  }
210  TILxSymSt::TILxSymSt():
211    Sym(syUndef),
212    Str(), UcStr(), CmtStr(),
213    Bool(false), Int(0), Flt(0),
214    SymLnN(-1), SymLnChN(-1), SymChN(-1){}
215  TILxSymSt::TILxSymSt(const TILxSymSt& SymSt):
216    Sym(SymSt.Sym),
217    Str(SymSt.Str), UcStr(SymSt.UcStr), CmtStr(SymSt.CmtStr),
218    Bool(SymSt.Bool), Int(SymSt.Int), Flt(SymSt.Flt),
219    SymLnN(SymSt.SymLnN), SymLnChN(SymSt.SymLnChN), SymChN(SymSt.SymChN){Fail;}
220  TILxSymSt::TILxSymSt(TILx& Lx):
221    Sym(Lx.Sym),
222    Str(Lx.Str), UcStr(Lx.UcStr), CmtStr(Lx.CmtStr),
223    Bool(Lx.Bool), Int(Lx.Int), Flt(Lx.Flt),
224    SymLnN(Lx.SymLnN), SymLnChN(Lx.SymLnChN), SymChN(Lx.SymChN){}
225  void TILxSymSt::Restore(TILx& Lx){
226    Lx.Sym=Sym;
227    Lx.Str=Str; Lx.UcStr=UcStr; Lx.CmtStr=CmtStr;
228    Lx.Bool=Bool; Lx.Int=Int; Lx.Flt=Flt;
229    Lx.SymLnN=SymLnN; Lx.SymLnChN=SymLnChN; Lx.SymChN=SymChN;}
230  TILx::TILx(const PSIn& _SIn, const TFSet& OptSet, const TLxChDefTy& ChDefTy):
231    ChDef(TLxChDef::GetChDef(ChDefTy)),
232    SIn(_SIn), RSIn(*SIn),
233    PrevCh(' '), Ch(' '), LnN(0), LnChN(0-1), ChN(0-1),
234    PrevSymStStack(), RwStrH(50),
235    IsCmtAlw(false), IsRetEoln(false), IsSigNum(false),
236    IsUniStr(false), IsCsSens(false), IsExcept(false),
237    IsTabSep(false), IsList(false),
238    Sym(syUndef),
239    Str(), UcStr(), CmtStr(),
240    Bool(false), Int(0), Flt(0),
241    SymLnN(-1), SymLnChN(-1), SymChN(-1){
242    for (int Opt=0; Opt<iloMx; Opt++){
243      if (OptSet.In(Opt)){SetOpt(Opt, true);}}
244  }
245  void TILx::SetOpt(const int& Opt, const bool& Val){
246    switch (Opt){
247      case iloCmtAlw: IsCmtAlw=Val; break;
248      case iloRetEoln: IsRetEoln=Val; break;
249      case iloSigNum: IsSigNum=Val; break;
250      case iloUniStr: IsUniStr=Val; break;
251      case iloCsSens: IsCsSens=Val; break;
252      case iloExcept: IsExcept=Val; break;
253      case iloTabSep: IsTabSep=Val; break;
254      case iloList: IsList=Val; break;
255      default: Fail;
256    }
257  }
258  TLxSym TILx::AddRw(const TStr& Str){
259    IAssert(RwStrH.Len()<syMxRw-syMnRw+1);
260    TStr UcStr=ChDef->GetUcStr(Str);
261    IAssert(!RwStrH.IsKey(UcStr));
262    TLxSym RwSym=TLxSym(syMnRw+RwStrH.Len());
263    RwStrH.AddDat(Str, TInt(int(RwSym)));
264    return RwSym;
265  }
266  PSIn TILx::GetSIn(const char& SepCh){
267    IAssert(PrevSymStStack.Empty());
268    while ((Ch!=TCh::EofCh)&&(Ch!=SepCh)){GetCh();}
269    return SIn;
270  }
271  TLxSym TILx::GetSym(const TFSet& Expect){
272    CmtStr.Clr();
273    if (!PrevSymStStack.Empty()){
274      PrevSymStStack.Top().Restore(*this); PrevSymStStack.Pop();
275    } else
276    if (Expect.In(syLn)){
277      if (Ch==TCh::EofCh){
278        Sym=syEof;
279      } else {
280        Str.Clr();
281        if (IsBof()){GetCh();}
282        while (!ChDef->IsTerm(Ch)){Str.AddCh(Ch); GetCh();}
283        bool _IsRetEoln=IsRetEoln; IsRetEoln=true;
284        GetSym(TFSet()|syEoln|syEof); Sym=syLn;
285        IsRetEoln=_IsRetEoln;
286      }
287    } else
288    if (IsTabSep){
289      if (IsBof()){GetCh();}
290      if (Ch==TCh::TabCh){ 
291        Sym=syTab; GetCh();
292      } else
293      if (ChDef->IsTerm(Ch)){ 
294        bool _IsRetEoln=IsRetEoln; IsRetEoln=true; IsTabSep=false;
295        GetSym(TFSet()|syEoln|syEof);
296        IsRetEoln=_IsRetEoln; IsTabSep=true;
297      } else {
298        Str.Clr();
299        while ((!ChDef->IsTerm(Ch))&&(Ch!=TCh::TabCh)){
300          Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
301        Sym=syStr; QuoteP=false;
302      }
303    } else {
304      while (ChDef->IsSpace(Ch)){GetCh();}
305      SymLnN=LnN; SymLnChN=LnChN; SymChN=ChN;
306      if (ChDef->IsAlpha(Ch)){
307        if (IsUniStr){Sym=syStr;} else {Sym=syIdStr;}
308        Str.Clr(); UcStr.Clr(); QuoteP=false;
309        do {Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch));}
310        while (ChDef->IsAlNum(GetCh()));
311        if (!RwStrH.Empty()){
312          TStr RwStr=Str; if (!IsCsSens){RwStr=UcStr;}
313          int SymKeyId=RwStrH.GetKeyId(RwStr);
314          if (SymKeyId!=-1){Sym=TLxSym(int(RwStrH[SymKeyId]));}
315        }
316        if (Expect.In(syBool)){
317          Sym=syBool; IAssert(TBool::IsValStr(Str));
318          Bool=TBool::GetValFromStr(Str);
319        }
320      } else
321      if ((Ch=='"')||(Ch=='\'')){
322        if (IsUniStr){Sym=syStr;} else {Sym=syQStr;}
323        Str.Clr(); UcStr.Clr(); QuoteP=true; QuoteCh=Ch;
324        GetCh();
325        forever{
326          while ((Ch!=QuoteCh)&&(Ch!='\\')&&(Ch!=TCh::EofCh)){
327            Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
328          if (Ch==TCh::EofCh){
329            Sym=syUndef; break;
330          } else if (Ch==QuoteCh){
331            GetCh(); break;
332          } else {
333            GetCh();
334            switch (Ch){
335              case '"': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
336              case '\\': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
337              case '\'': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
338              case '/': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
339              case 'b': Str.AddCh('\b'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
340              case 'f': Str.AddCh('\f'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
341              case 'n': Str.AddCh('\n'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
342              case 'r': Str.AddCh('\r'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
343              case 't': Str.AddCh('\t'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
344              case 'u': {
345                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
346                int UChCd = TCh::GetHex(Ch);
347                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
348                UChCd = 16 * UChCd + TCh::GetHex(Ch);
349                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
350                UChCd = 16 * UChCd + TCh::GetHex(Ch);
351                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
352                UChCd = 16 * UChCd + TCh::GetHex(Ch);
353                TUnicode::EncodeUtf8(UChCd, Str);
354  			  TUnicode::EncodeUtf8(UChCd, UcStr); }
355                GetCh(); break; 
356              default: Sym=syUndef; break;
357            }
358            if (Sym==syUndef){
359              throw PExcept(new TExcept("Invalid Escape Sequence in Quoted String"));}
360          }
361        }
362      } else
363      if ((ChDef->IsNum(Ch))||(IsSigNum&&((Ch=='+')||(Ch=='-')))){
364        Str.Clr(); bool IntP=true;
365        do {Str.AddCh(Ch);} while (ChDef->IsNum(GetCh()));
366        if (Expect.In(syFlt)){
367          if (Ch=='.'){
368            Str.AddCh(Ch); IntP=false;
369            while (ChDef->IsNum(GetCh())){Str.AddCh(Ch);}
370          }
371          if ((Ch=='e')||(Ch=='E')){
372            Str.AddCh(Ch); GetCh(); IntP=false;
373            if ((Ch=='+')||(Ch=='-')){Str.AddCh(Ch); GetCh();}
374            while (ChDef->IsNum(Ch)){Str.AddCh(Ch); GetCh();}
375          }
376        }
377        UcStr=Str;
378        if (IntP&&(Expect.In(syInt))){
379          Sym=syInt; Int=atoi(Str.CStr());
380        } else {
381          Sym=syFlt; Flt=atof(Str.CStr());
382        }
383      } else
384      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
385        Sym=syEoln;
386        if (Ch==TCh::CrCh){if (GetCh()==TCh::LfCh){GetCh();}} else
387        if (Ch==TCh::LfCh){if (GetCh()==TCh::CrCh){GetCh();}}
388        LnN++; LnChN=0; if (!IsRetEoln){GetSym(Expect);}
389      } else
390      if (Ch=='/'){
391        GetCh();
392        if ((IsCmtAlw)&&(Ch=='/')){
393          TChA _CmtStr;
394          do {_CmtStr+=GetCh();} while (!ChDef->IsTerm(Ch));
395          _CmtStr.Pop(); _CmtStr.Trunc();
396          if (Ch==TCh::CrCh){
397            if (GetCh()==TCh::LfCh){GetCh();}
398          } else
399          if (Ch==TCh::LfCh){
400            if (GetCh()==TCh::CrCh){GetCh();}
401          }
402          if (IsRetEoln){Sym=syEoln;} else {GetSym(Expect);}
403          CmtStr=_CmtStr;
404        } else
405        if (Ch=='*'){
406          TChA _CmtStr;
407          do {
408            while (GetCh()!='*'){_CmtStr+=Ch;}
409            _CmtStr+=GetCh();
410          } while (Ch!='/');
411          _CmtStr.Pop(); _CmtStr.Pop(); _CmtStr.Trunc();
412          GetCh(); GetSym(Expect);
413          CmtStr=_CmtStr;
414        } else {
415          Sym=sySlash;
416        }
417      } else
418      if (Ch==TCh::EofCh){
419        Sym=syEof;
420      } else {
421        switch (Ch){
422          case '.':
<span onclick='openModal()' class='match'>423            if (GetCh()=='.'){Sym=syDPeriod; GetCh();}
424            else {Sym=syPeriod;} break;
425          case ',': Sym=syComma; GetCh(); break;
</span>426          case ':':
427            if (GetCh()==':'){Sym=syDColon; GetCh();}
428            else {Sym=syColon;} break;
429          case ';': Sym=sySemicolon; GetCh(); break;
430          case '+': Sym=syPlus; GetCh(); break;
431          case '-': Sym=syMinus; GetCh(); break;
432          case '*': Sym=syAsterisk; GetCh(); break;
433          case '/': Sym=sySlash; GetCh(); break;
434          case '%': Sym=syPercent; GetCh(); break;
435          case '!': Sym=syExclamation; GetCh(); break;
436          case '|': Sym=syVBar; GetCh(); break;
437          case '&': Sym=syAmpersand; GetCh(); break;
438          case '=': Sym=syEq; GetCh(); break;
439          case '<':
440            GetCh();
441            if (Ch=='='){Sym=syLEq; GetCh();}
442            else if (Ch=='>'){Sym=syNEq; GetCh();}
443            else {Sym=syLss;} break;
444          case '>':
445            if (GetCh()=='='){Sym=syGEq; GetCh();}
446            else {Sym=syGtr;} break;
447          case '?': Sym=syQuestion; GetCh(); break;
448          case '#':
449            if (IsCmtAlw){
450              TChA _CmtStr;
451              do {_CmtStr+=GetCh();} while (!ChDef->IsTerm(Ch));
452              _CmtStr.Pop(); _CmtStr.Trunc();
453              if (Ch==TCh::CrCh){
454                if (GetCh()==TCh::LfCh){GetCh();}
455              } else
456              if (Ch==TCh::LfCh){
457                if (GetCh()==TCh::CrCh){GetCh();}
458              }
459              if (IsRetEoln){Sym=syEoln;} else {GetSym(Expect);}
460              CmtStr=_CmtStr;
461            } else {
462              Sym=syHash; GetCh();
463            }
464            break;
465          case '(': Sym=syLParen; GetCh(); break;
466          case ')': Sym=syRParen; GetCh(); break;
467          case '[': Sym=syLBracket; GetCh(); break;
468          case ']': Sym=syRBracket; GetCh(); break;
469          case '{': Sym=syLBrace; GetCh(); break;
470          case '}': Sym=syRBrace; GetCh(); break;
471          default: Sym=syUndef; GetCh(); break;
472        }
473      }
474    }
475    if ((!Expect.In(Sym))&&(!Expect.Empty())){
476      if (IsExcept){
477       TStr MsgStr=
478        TStr("Unexpected symbol (")+GetSymStr()+") ["+GetFPosStr()+"]";
479       throw PExcept(new TExcept(MsgStr));
480      } else {
481        Fail;
482      }
483    }
484    return Sym;
485  }
486  TStr TILx::GetStrToCh(const char& ToCh){
487    Sym=syStr; Str.Clr(); UcStr.Clr();
488    while ((Ch!=ToCh)&&(Ch!=TCh::EofCh)){
489      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
490    return Str;
491  }
492  TStr TILx::GetStrToEolnOrCh(const char& ToCh){
493    Sym=syStr; Str.Clr(); UcStr.Clr();
494    while ((Ch!=ToCh)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
495      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
496    return Str;
497  }
498  TStr TILx::GetStrToEoln(const bool& DoTrunc){
499    Sym=syStr; Str.Clr(); UcStr.Clr();
500    while ((Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
501      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
502    if (DoTrunc){Str.ToTrunc(); UcStr.ToTrunc();}
503    return Str;
504  }
505  TStr TILx::GetStrToEolnAndCh(const char& ToCh){
506    Sym=syStr; Str.Clr(); UcStr.Clr();
507    if (IsBof()){GetCh();}
508    forever {
509      if (Ch==TCh::EofCh){break;}
510      if (((ChN==0)||(PrevCh==TCh::CrCh)||(PrevCh==TCh::LfCh))&&(Ch==ToCh)){
511        GetCh(); break;}
512      else {Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
513    }
514    return Str;
515  }
516  void TILx::SkipToEoln(){
517    while ((Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
518      GetCh();}
519    if (Ch==TCh::CrCh){if (GetCh()==TCh::LfCh){GetCh();}} else
520    if (Ch==TCh::LfCh){if (GetCh()==TCh::CrCh){GetCh();}}
521  }
522  TLxSym TILx::PeekSym(const int& Syms){
523    TILxSymSt CurSymSt(*this);
524    TSStack<TILxSymSt> SymStStack;
525    for (int SymN=0; SymN<Syms; SymN++){
526      GetSym(); SymStStack.Push(TILxSymSt(*this));}
527    TLxSym PeekedSym=Sym;
528    while (!SymStStack.Empty()){
529      SymStStack.Top().Restore(*this); SymStStack.Pop();
530      PutSym();
531    }
532    CurSymSt.Restore(*this);
533    return PeekedSym;
534  }
535  TStr TILx::GetSymStr() const {
536    switch (Sym){
537      case syInt: return Str;
538      case syFlt: return Str;
539      case syStr: return Str;
540      case syIdStr: return Str;
541      case syQStr: return Str;
542      default:
543        if ((syMnRw<=Sym)&&(Sym<=syMxRw)){return Str;}
544        else {return TLxSymStr::GetSymStr(Sym);}
545    }
546  }
547  TStr TILx::GetFPosStr() const {
548    TChA ChA;
549    ChA+="File:"; ChA+=SIn->GetSNm();
550    ChA+=" Line:"; ChA+=TInt::GetStr(LnN+1);
551    ChA+=" Char:"; ChA+=TInt::GetStr(LnChN);
552    return ChA;
553  }
554  TStr TILx::GetQStr(const TStr& Str, const bool& QuoteP, const char& QuoteCh){
555    if (QuoteP){
556      TChA ChA;
557      ChA+=QuoteCh;
558      int StrLen=Str.Len();
559      for (int ChN=0; ChN<StrLen; ChN++){
560        char Ch=Str.CStr()[ChN];
561        if (Ch==QuoteCh){ChA+=QuoteCh; ChA+=QuoteCh;}
562        else {ChA+=Ch;}
563      }
564      ChA+=QuoteCh;
565      return ChA;
566    } else {
567      return Str;
568    }
569  }
570  void TILx::GetVarBoolV(const TStr& VarNm, TBoolV& BoolV, const bool& NewLn){
571    BoolV.Clr();
572    GetVar(VarNm, true, NewLn);
573    while (GetSym(syRBracket, syBool)==syQStr){
574      BoolV.Add(Bool); if (NewLn){GetEoln();}}
575    if (NewLn){GetEoln();}
576  }
577  void TILx::GetVarIntV(const TStr& VarNm, TIntV& IntV, const bool& NewLn){
578    IntV.Clr();
579    GetVar(VarNm, true, NewLn);
580    while (GetSym(syRBracket, syInt)==syInt){
581      IntV.Add(Int); if (NewLn){GetEoln();}}
582    if (NewLn){GetEoln();}
583  }
584  void TILx::GetVarFltV(const TStr& VarNm, TFltV& FltV, const bool& NewLn){
585    FltV.Clr();
586    GetVar(VarNm, true, NewLn);
587    while (GetSym(syRBracket, syFlt)==syFlt){
588      FltV.Add(Flt); if (NewLn){GetEoln();}}
589    if (NewLn){GetEoln();}
590  }
591  void TILx::GetVarStrV(const TStr& VarNm, TStrV& StrV, const bool& NewLn){
592    StrV.Clr();
593    GetVar(VarNm, true, NewLn);
594    while (GetSym(syRBracket, syQStr)==syQStr){
595      StrV.Add(Str); if (NewLn){GetEoln();}}
596    if (NewLn){GetEoln();}
597  }
598  void TILx::GetVarStrPrV(const TStr& VarNm, TStrPrV& StrPrV, const bool& NewLn){
599    StrPrV.Clr();
600    GetVar(VarNm, true, NewLn);
601    while (GetSym(syRBracket, syLBracket)==syLBracket){
602      TStr Str1=GetQStr(); TStr Str2=GetQStr();
603      GetSym(syRBracket);
604      StrPrV.Add(TStrPr(Str1, Str2)); if (NewLn){GetEoln();}
605    }
606    if (NewLn){GetEoln();}
607  }
608  void TILx::GetVarStrVV(const TStr& VarNm, TVec<TStrV>& StrVV, const bool& NewLn){
609    StrVV.Clr();
610    GetVar(VarNm, true, NewLn);
611    while (GetSym(syRBracket, syLBracket)==syLBracket){
612      StrVV.Add();
613      while (GetSym(syQStr, syRBracket)==syQStr){
614        StrVV.Last().Add(Str);}
615      if (NewLn){GetEoln();}
616    }
617    if (NewLn){GetEoln();}
618  }
619  void TILx::GetLnV(const TStr& FNm, TStrV& LnV){
620    TFIn SIn(FNm); LnV.Clr(); TChA Ln;
621    if (!SIn.Eof()){
622      char Ch=SIn.GetCh();
623      while (!SIn.Eof()){
624        if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
625          if (!SIn.Eof()){
626            char PrevCh=Ch; Ch=SIn.GetCh();
627            if (!SIn.Eof()){
628              if (PrevCh==TCh::CrCh){if (Ch==TCh::LfCh){Ch=SIn.GetCh();}} else
629              if (PrevCh==TCh::LfCh){if (Ch==TCh::CrCh){Ch=SIn.GetCh();}}
630            }
631          }
632          LnV.Add(Ln); Ln.Clr();
633        } else {
634          Ln+=Ch; Ch=SIn.GetCh();
635        }
636      }
637      if (!Ln.Empty()){
638        LnV.Add(Ln);}
639    }
640  }
641  void TOLx::PutSep(const TLxSym& Sym){
642    if (TLxSymStr::IsSep(PrevSym, Sym)){
643      if (IsTabSep){RSOut.PutCh(TCh::TabCh);} else {RSOut.PutCh(' ');}}
644    PrevSym=Sym;
645  }
646  TOLx::TOLx(const PSOut& _SOut, const TFSet& OptSet, const TLxChDefTy& ChDefTy):
647    ChDef(TLxChDef::GetChDef(ChDefTy)), SOut(_SOut), RSOut(*SOut),
648    IsCmtAlw(false), IsFrcEoln(false), IsSigNum(false),
649    IsUniStr(false), IsCsSens(false), IsTabSep(false), IsVarIndent(false),
650    VarIndentLev(0),
651    RwStrH(50), RwSymH(50), PrevSym(syUndef){
652    for (int Opt=0; Opt<oloMx; Opt++){
653      if (OptSet.In(Opt)){SetOpt(Opt, true);}}
654  }
655  void TOLx::SetOpt(const int& Opt, const bool& Val){
656    switch (Opt){
657      case oloCmtAlw: IsCmtAlw=Val; break;
658      case oloFrcEoln: IsFrcEoln=Val; break;
659      case oloSigNum: IsSigNum=Val; break;
660      case oloUniStr: IsUniStr=Val; break;
661      case oloCsSens: IsCsSens=Val; break;
662      case oloTabSep: IsTabSep=Val; break;
663      case oloVarIndent: IsVarIndent=Val; break;
664      default: Fail;
665    }
666  }
667  TLxSym TOLx::AddRw(const TStr& Str){
668    IAssert(RwStrH.Len()<syMxRw-syMnRw+1);
669    TStr UcStr=ChDef->GetUcStr(Str);
670    IAssert(!RwStrH.IsKey(UcStr));
671    TLxSym RwSym=TLxSym(syMnRw+RwStrH.Len());
672    RwStrH.AddDat(Str, TInt(int(RwSym)));
673    RwSymH.AddDat(TInt(int(RwSym)), Str);
674    return RwSym;
675  }
676  void TOLx::PutSym(const TLxSym& Sym){
677    TStr Str;
678    if ((syMnRw<=Sym)&&(Sym<=syMxRw)){
679      Str=Str=RwSymH[Sym];
680    } else {
681      Str=TLxSymStr::GetSymStr(Sym);
682    }
683    PutSep(Sym); RSOut.PutStr(Str);
684  }
685  void TOLx::PutVarBoolV(const TStr& VarNm, const TBoolV& BoolV,
686   const bool& NewLn, const bool& CheckIdStr){
687    PutVar(VarNm, true, NewLn, CheckIdStr);
688    for (int BoolN=0; BoolN<BoolV.Len(); BoolN++){
689      if (IsVarIndent){PutIndent(VarIndentLev);}
690      PutBool(BoolV[BoolN]);
691      if (NewLn){PutLn();}
692    }
693    PutVarEnd(true, NewLn);
694  }
695  void TOLx::PutVarIntV(const TStr& VarNm, const TIntV& IntV,
696   const bool& NewLn, const bool& CheckIdStr){
697    PutVar(VarNm, true, NewLn, CheckIdStr);
698    for (int IntN=0; IntN<IntV.Len(); IntN++){
699      if (IsVarIndent){PutIndent(VarIndentLev);}
700      PutInt(IntV[IntN]);
701      if (NewLn){PutLn();}
702    }
703    PutVarEnd(true, NewLn);
704  }
705  void TOLx::PutVarFltV(const TStr& VarNm, const TFltV& FltV,
706   const bool& NewLn, const bool& CheckIdStr){
707    PutVar(VarNm, true, NewLn, CheckIdStr);
708    for (int FltN=0; FltN<FltV.Len(); FltN++){
709      if (IsVarIndent){PutIndent(VarIndentLev);}
710      PutFlt(FltV[FltN]);
711      if (NewLn){PutLn();}
712    }
713    PutVarEnd(true, NewLn);
714  }
715  void TOLx::PutVarStrV(const TStr& VarNm, const TStrV& StrV,
716   const bool& NewLn, const bool& CheckIdStr){
717    PutVar(VarNm, true, NewLn, CheckIdStr);
718    for (int StrN=0; StrN<StrV.Len(); StrN++){
719      if (IsVarIndent){PutIndent(VarIndentLev);}
720      PutQStr(StrV[StrN]);
721      if (NewLn){PutLn();}
722    }
723    PutVarEnd(true, NewLn);
724  }
725  void TOLx::PutVarStrPrV(const TStr& VarNm, const TStrPrV& StrPrV,
726   const bool& NewLn, const bool& CheckIdStr){
727    PutVar(VarNm, true, NewLn, CheckIdStr);
728    for (int StrPrN=0; StrPrN<StrPrV.Len(); StrPrN++){
729      if (IsVarIndent){PutIndent(VarIndentLev);}
730      PutSym(syLBracket);
731      PutQStr(StrPrV[StrPrN].Val1); PutQStr(StrPrV[StrPrN].Val2);
732      PutSym(syRBracket);
733      if (NewLn){PutLn();}
734    }
735    PutVarEnd(true, NewLn);
736  }
737  void TOLx::PutVarStrVV(const TStr& VarNm, const TVec<TStrV>& StrVV,
738   const bool& NewLn, const bool& CheckIdStr){
739    PutVar(VarNm, true, NewLn, CheckIdStr);
740    for (int StrVN=0; StrVN<StrVV.Len(); StrVN++){
741      if (IsVarIndent){PutIndent(VarIndentLev);}
742      PutSym(syLBracket);
743      for (int StrN=0; StrN<StrVV[StrVN].Len(); StrN++){
744        PutQStr(StrVV[StrVN][StrN]);}
745      PutSym(syRBracket);
746      if (NewLn){PutLn();}
747    }
748    PutVarEnd(true, NewLn);
749  }
750  char TPreproc::GetCh(){
751    Assert(Ch!=TCh::EofCh);
752    PrevCh=Ch;
753    Ch=((SIn->Eof()) ? TCh::EofCh : SIn->GetCh());
754    return Ch;
755  }
756  bool TPreproc::IsSubstId(const TStr& SubstId, TStr& SubstValStr) const {
757    if (SubstIdToKeyIdValPrVH.IsKey(SubstId)){
758      const TStrPrV& KeyIdValPrV=SubstIdToKeyIdValPrVH.GetDat(SubstId);
759      for (int KeyN=0; KeyN<KeyIdValPrV.Len(); KeyN++){
760        if (SubstKeyIdV.IsIn(KeyIdValPrV[KeyN].Val1)){
761          SubstValStr=KeyIdValPrV[KeyN].Val2;
762          return true;
763        }
764      }
765      return false;
766    } else {
767      return false;
768    }
769  }
770  TPreproc::TPreproc(const TStr& InFNm, const TStr& OutFNm,
771   const TStr& SubstFNm, const TStrV& _SubstKeyIdV):
772    SIn(), SubstKeyIdV(_SubstKeyIdV),
773    PrevCh('\0'), Ch('\0'){
774    if (!SubstFNm.Empty()){
775      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SubstFNm);
776      TXmlTokV SubstTokV; XmlDoc->GetTok()->GetTagTokV("Subst", SubstTokV);
777      for (int SubstTokN=0; SubstTokN<SubstTokV.Len(); SubstTokN++){
778        PXmlTok SubstTok=SubstTokV[SubstTokN];
779        TStr SubstId=SubstTok->GetArgVal("Id", "");
780        if (!SubstId.Empty()){
781          TStrPrV& KeyIdValPrV=SubstIdToKeyIdValPrVH.AddDat(SubstId);
782          TXmlTokV StrTokV; SubstTok->GetTagTokV("Str", StrTokV);
783          for (int StrTokN=0; StrTokN<StrTokV.Len(); StrTokN++){
784            PXmlTok StrTok=StrTokV[StrTokN];
785            TStr KeyId=StrTok->GetArgVal("Key", "");
786            TStr ValStr=StrTok->GetTokStr(false);
787            if (!KeyId.Empty()){
788              KeyIdValPrV.Add(TStrPr(KeyId, ValStr));
789            }
790          }
791        }
792      }
793    }
794    SIn=TFIn::New(InFNm);
795    PSOut SOut=TFOut::New(OutFNm);
796    bool CopyModeP=false; bool IgnoreModeP=false;
797    GetCh();
798    while (Ch!=TCh::EofCh){
799      if (isalpha(Ch)||(((PrevCh=='\0')||(PrevCh=='\r')||(PrevCh=='\n'))&&(Ch=='#'))){
800        TChA IdChA;
801        do {
802          IdChA+=Ch; GetCh();
803        } while ((Ch!=TCh::EofCh)&&(isalnum(Ch)));
804        if (IdChA=="#ifdef"){
805          TChA CondKeyIdChA;
806          while ((Ch!=TCh::EofCh)&&(Ch!='\n')&&(Ch!='\r')){
807            CondKeyIdChA+=Ch; GetCh();}
808          if (Ch=='\n'){GetCh(); if (Ch=='\r'){GetCh();}}
809          else if (Ch=='\r'){GetCh(); if (Ch=='\n'){GetCh();}}
810          CondKeyIdChA.Trunc();
811          IAssert(CopyModeP==false);
812          IAssert(IgnoreModeP==false);
813          if (SubstKeyIdV.IsIn(CondKeyIdChA)){
814            CopyModeP=true; IgnoreModeP=false;
815          } else {
816            CopyModeP=false; IgnoreModeP=true;
817          }
818        } else
819        if (IdChA=="#endif"){
820          while ((Ch!=TCh::EofCh)&&(Ch!='\n')&&(Ch!='\r')){
821            GetCh();}
822          if (Ch=='\n'){GetCh(); if (Ch=='\r'){GetCh();}}
823          else if (Ch=='\r'){GetCh(); if (Ch=='\n'){GetCh();}}
824          IAssert(CopyModeP||IgnoreModeP);
825          CopyModeP=false; IgnoreModeP=false;
826        } else {
827          TStr SubstValStr;
828          if ((!CopyModeP)&&(IsSubstId(IdChA, SubstValStr))){
829            if (!IgnoreModeP){SOut->PutStr(SubstValStr);}
830          } else {
831            if (!IgnoreModeP){SOut->PutStr(IdChA);}
832          }
833        }
834      } else {
835        if (!IgnoreModeP){SOut->PutCh(Ch);}
836        GetCh();
837      }
838    }
839  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkldnn_pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lx.cpp</div>
                </div>
                <div class="column column_space"><pre><code>272          if (this->layer_param_.pooling_param().avg_include_pad()) {
273              pooling_algorithm = algorithm::pooling_avg_include_padding;
274          }else {
275              pooling_algorithm = algorithm::pooling_avg_exclude_padding;
276          }
277          break;
278      case PoolingParameter_PoolMethod_STOCHASTIC:
</pre></code></div>
                <div class="column column_space"><pre><code>423            if (GetCh()=='.'){Sym=syDPeriod; GetCh();}
424            else {Sym=syPeriod;} break;
425          case ',': Sym=syComma; GetCh(); break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    