
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.3781212841854935%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</h3>
            <pre><code>1  #ifndef LSIONTO_H
2  #define LSIONTO_H
3  #include "mine.h"
4  #include "graph.h"
5  ClassTPV(TOntoConcept, POntoConcept, TOntoConceptV) 
6  private:
7      TInt Id;
8      TStr CptNm;
9      TIntV DIdV;
10      TBool IsValid;
11      PBowSpV ConceptSpV;
12      PBowSpV SvmKeyWdSpV;
13      TIntFltKdV MedoidDIdWgtV;
14      PSVMModel CptMd;
15      TFlt Compactness;
16      TFlt Clarity;
17  private:
18      void GenMedoid(PBowDocWgtBs BowDocWgtBs);
19      UndefCopyAssign(TOntoConcept);
20  public:
21      TOntoConcept(): Id(-1), CptNm("New Concept") { }
22      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
23          const int _Id, const TIntV& _DIdV);
24      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
25          const int _Id, const TIntV& _DIdV) { 
26              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _DIdV); }
27      TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
28          const int _Id, const TStr& _CptNm, const TIntV& _DIdV);
29      static POntoConcept New(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
30          const int _Id, const TStr& _CptNm, const TIntV& _DIdV) { 
31              return new TOntoConcept(BowDocBs, BowDocWgtBs, _Id, _CptNm, _DIdV); }
32      int GetId() const { return Id; }
33      TStr GetName() const { return CptNm; }
34      void SetName(const TStr& NewCptNm) { CptNm = NewCptNm; }
35      bool IsCentroidValid() const { return IsValid; }
36      PBowSpV GetCentroidSpV() const { return ConceptSpV; }
37      void ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs);
38      PBowSpV GetSvmSpV() const { return SvmKeyWdSpV; }
39      void SetSvmSpV(PBowSpV NewSvmSpV) { SvmKeyWdSpV = NewSvmSpV; }
40      int GetDocs() const { return DIdV.Len(); }
41      int GetDId(const int& DIdN) const { return DIdV[DIdN]; }
42      void GetDIdV(TIntV& _DIdV) const { _DIdV=DIdV; }
43      TIntV& GetDIdVRef() { return DIdV; }
44      void SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV);
45      void AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
46      void AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
47      void DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV);
48      bool DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId);
49      TStr GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
50        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
51        const bool& ShowWeights = false, const bool& UseMedoidP = false) const;
52      TStr GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords = 3,
53        const double& TopWordsWgtPrc = 1.0, const TStr& SepStr = ", ",
54        const bool& ShowWeights = false) const;
55      void CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
56          const double& SvmC = 1.0, const double& SvmJ = 5.0, 
57          const int& SvmTime = -1);
58      bool IsCptMd() const { return !CptMd.Empty(); }
59      void CfyDocSpV(PBowSpV DocSpV, bool& IsDocInCpt, double& Prob) { 
60          IsDocInCpt = CptMd->GetCfyBool(DocSpV); Prob = CptMd->GetProbCfy(DocSpV); }
61      void SetCompactness(const double& NewVal) { Compactness = NewVal; }
62      double GetCompactness() const { return Compactness; }
63      void SetClarity(const double& NewVal) { Clarity = NewVal; }
64      double GetClarity() const { return Clarity; }
65  };
66  ClassTV(TOntoRltType, TOntoRltTypeV) 
67  private:
68      TStr TypeNm;
69      TBool Directed;
70      TBool Transitive;
71  public:
72      static TStr SubCptOfRltStr;
73      static TStr SimilarRltStr;
74  public:
75      TOntoRltType(): TypeNm("") {}
76      TOntoRltType(const TStr& _TypeNm, const bool& _Directed, const bool& _Transitive):
77          TypeNm(_TypeNm), Directed(_Directed), Transitive(_Transitive) { }
78      const TStr& GetName() const { return TypeNm; }
79      bool IsType(const TStr& RltTypeNm) const { return (RltTypeNm == TypeNm); }
80      bool IsDir() const { return Directed; }
81      bool IsTransitive() const { return Transitive; }
82  };
83  ClassTP(TUniqueId, PUniqueId)
84  private:
85      TInt IdCounter;
86  public:
87      TUniqueId(const int& StartId = 0): IdCounter(StartId) { };
88      static PUniqueId New(const int& StartId = 0) { return new TUniqueId(StartId); }
89      TUniqueId(TSIn& SIn): IdCounter(SIn) { }
90      static PUniqueId Load(TSIn &SIn) { return new TUniqueId(SIn); }
91      void Save(TSOut& SOut) const { IdCounter.Save(SOut); }
92      int GetNextId() { const int NextId = IdCounter; IdCounter++; return NextId; }
93  };
94  typedef enum { osatKMeans, osatCat, osatLwOntoCfier } TOntoSuggestAlgType;
95  class TOntoAlg {
96  public:
97      static void SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
98          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
99          TOntoConceptV& NewConceptV); 
100      static void SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
101          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV);
102      static void SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
103          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
104          PUniqueId UniqueId, TOntoConceptV& NewConceptV);
105  };
106  ClassTP(TOntoExport, POntoExport)
107  public:
108      virtual void StartExport() {};
109      virtual void EndExport() {};
110      virtual void PutCpt(const int& CptId, const TStr CptNm, 
111          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
112          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
113          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {};
114      virtual bool IsCptSubCptLink() { return false; }
115      virtual bool IsCptSuperCptLink() { return false; }
116      virtual bool IsCptDocLink() { return false; }
117      virtual bool IsCptAlwaysSvm() { return false; }
118      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
119          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {};
120      virtual bool IsDocCptLink() { return false; }
121      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
122          const bool& TransitiveP) {};
123      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
124          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {};
125      virtual bool IsRlt() { return false; }
126  };
127  class TOntoExportPTO: TOntoExport {
128  private:
129      PSOut SOut;
130      bool DigLibP; 
131      TStr BowFNmStr;
132      TStr GetUri(const int& Id, const TStr& Nm);
133  public:
134      TOntoExportPTO(PSOut _SOut, const bool& _DigLibP, const TStr& _BowFNmStr):
135          SOut(_SOut), DigLibP(_DigLibP), BowFNmStr(_BowFNmStr) { }
136      static POntoExport New(PSOut SOut, const bool& DigLibP, const TStr& BowFNmStr) { 
137          return new TOntoExportPTO(SOut, DigLibP, BowFNmStr); }
138      virtual void StartExport();
139      virtual void EndExport();
140      virtual void PutCpt(const int& CptId, const TStr CptNm, 
141          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
142          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
143          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
144      virtual bool IsCptSubCptLink() { return false; }
145      virtual bool IsCptSuperCptLink() { return true; }
146      virtual bool IsCptDocLink() { return DigLibP; }
147      virtual bool IsCptAlwaysSvm() { return false; }
148      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
149          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
150      virtual bool IsDocCptLink() { return true; }
151  };
152  class TOntoExportProlog: TOntoExport {
153  private:
154      PSOut SOut;
155      TStr GetCptLabel(const int& CptId) { return TStr::Fmt("c%d", CptId); }
156      TStr GetInstLabel(const int& InstId) { return TStr::Fmt("id%d", InstId); }
157  public:
158      TOntoExportProlog(PSOut _SOut): SOut(_SOut) { }
159      static POntoExport New(PSOut SOut) { return new TOntoExportProlog(SOut); }
160      virtual void StartExport();
161      virtual void EndExport();
162      virtual void PutCpt(const int& CptId, const TStr CptNm, 
163          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
164          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
165          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
166      virtual bool IsCptSubCptLink() { return false; }
167      virtual bool IsCptSuperCptLink() { return true; }
168      virtual bool IsCptDocLink() { return false; }
169      virtual bool IsCptAlwaysSvm() { return false; }
170      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
171          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
172      virtual bool IsDocCptLink() { return true; }
173  };
174  class TOntoExportOWL: TOntoExport {
175  private:
176      PSOut SOut;
177      TBool StoreDocsP;
178      TBool StoreAbstractsP;
179      TStr GetUri(const int& Id, const TStr& Nm);
180  public:
181      TOntoExportOWL(PSOut _SOut, const bool& _StoreDocsP, const bool& _StoreAbstractsP): 
182        SOut(_SOut), StoreDocsP(_StoreDocsP), StoreAbstractsP(_StoreAbstractsP) { }
183      static POntoExport New(PSOut SOut, const bool& StoreDocsP, const bool& StoreAbstractsP) { 
184          return new TOntoExportOWL(SOut, StoreDocsP, StoreAbstractsP); }
185      virtual void StartExport();
186      virtual void EndExport();
187      virtual void PutCpt(const int& CptId, const TStr CptNm, 
188          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
189          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
190          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV);
191      virtual bool IsCptSubCptLink() { return false; }
192      virtual bool IsCptSuperCptLink() { return true; }
193      virtual bool IsCptDocLink() { return false; }
194      virtual bool IsCptAlwaysSvm() { return false; }
195      virtual void PutDoc(const int& DId, const TStr& DocTitle, 
196          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV);
197      virtual bool IsDocCptLink() { return true; }
198      virtual void PutRltType(const TStr& RltNm, const bool& DirectedP,
199          const bool& TransitiveP);
200      virtual void PutRlt(const TStr& RltNm, const int& SrcCptId, 
201          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm);
202      virtual bool IsRlt() { return true; }
203  };
204  ClassTP(TOntology, POntology)
205  private:
206      PBowDocBs BowDocBs;
207      PBowDocWgtBs BowDocWgtBs;
208      PBowSim BowSim;
209      TOntoConceptV ConceptV;
210      TOntoRltTypeV RltTypeV;
211      PGraph OntoGraph;
212      PUniqueId UniqueId;
213  private:
214      void GenerateEmptyOnto();
215      TIntH CptIdPosH;
216      void RefreshCptIdPosH();
217      void ReconnectToRoot();
218      void AddRltsFromList(TIntStrPrV& InRltV, 
219          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
220      void AddSonDIdV(const int& CptId, TIntV& SonDIdV);
221      void CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV);
222      void Export(POntoExport OntoExport);
223      UndefDefaultCopyAssign(TOntology);
224  public:
225      TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs,
226          const TBowSimType& BowSimType);
227      static POntology New(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
228          const TBowSimType& BowSimType) { 
229              return new TOntology(_BowDocBs, _BowDocWgtBs, BowSimType); }
230      PBowDocBs GetBowDocBs() const { return BowDocBs; }
231      PBowDocWgtBs GetBowDocWgtBs() const { return BowDocWgtBs; }
232      int GetConcepts() const { return ConceptV.Len(); }
233      int GetCptId(const int& CptIdN) const { return ConceptV[CptIdN]->GetId(); }
234      POntoConcept GetConcept(const int& CptId) const {
235          IAssertR(IsCptId(CptId), "There is no such concept!"); 
236          return ConceptV[CptIdPosH.GetDat(CptId)]; }
237      void GetCptIdV(TIntV& CptIdV);
238      bool IsCptId(const int& CptId) const { return CptIdPosH.IsKey(CptId); }
239      bool IsRootCpt(const int& CptId) const { return CptId == 0; }
240      POntoConcept GetRootCpt() const { return GetConcept(0); }
241      TStr GetCptName(const int& CptId) const { return GetConcept(CptId)->GetName(); }
242      void SetCptName(const int& CptId, const TStr& NewName);
243      int GetCptDocs(const int& CptId) const { return GetConcept(CptId)->GetDocs(); }
244      void GetCptDIdV(const int& CptId, TIntV& DIdV) const {
245          GetConcept(CptId)->GetDIdV(DIdV); }
246      void SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP);
247      TStr GetCptKeyWdStr(const int& CptId, const int WordN, const bool& UseMedoidP) const {
248          return GetConcept(CptId)->GetKeyWdStr(BowDocBs, WordN, 1.0, ", ", false, UseMedoidP); }
249      TStr GetCptSvmKeyWdStr(const int& CptId, const int WordN) const {
250          return GetConcept(CptId)->GetSvmKeyWdStr(BowDocBs, WordN); }
251      void GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV);
252      double GetCptCompactness(const int& CptId) const {
253          return GetConcept(CptId)->GetCompactness(); }
254      double GetCptClarity(const int& CptId) const {
255          return GetConcept(CptId)->GetClarity(); }
256      void CalcCptMd(const int& CptId, const double& SvmC, 
257          const double& SvmJ, const int& SvmTime);
258      void CfyDId(const int& DId, TIntFltKdV& CfyResV);
259      void IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV);
260      void IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP);
261      void AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP);
262      void ReCalcWgtBs() { BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtLogDFNrmTFIDF); }
263      void ResetAllCptKeyWd();
264      void GetSubCptIdV(const int& CptId, TIntV& SubCptIdV);
265      void GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV);
266      bool HasSuperCpt(const int& CptId) { TIntV SuperCptIdV; 
267          GetSuperCptIdV(CptId, SuperCptIdV); return (SuperCptIdV.Len() > 0); }
268      int GetCptUnusedDocs(const int& CptId) {
269          TIntV DIdV; GetCptUnusedDIdV(CptId, DIdV); return DIdV.Len(); }
270      void GetCptUnusedDIdV(const int& CptId, TIntV& UnusedDIdV);
271      void GetCptContextDIdV(const int& CptId, TIntV& ContextDIdV, 
272          const bool& AddSonDIdP = true);
273      void GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV);
274      void GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV);
275      void AddUpDIdV(const int& CptId, const TIntV& SubDIdV);
276      void DelUpDIdV(const int& CptId, const TIntV& SubDIdV);
277      void DelDownDIdV(const int& CptId, const TIntV& SubDIdV);
278      void DelDownDId(const int& CptId, const int& DId);
279      void GetCptInRltV(const int& CptId, TIntStrPrV& InRltV);
280      void GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV);
281      void GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV);
282      void GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
283          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV);
284      int GetRltTypes() const { return RltTypeV.Len(); }
285      int GetRltTypeN(const TStr& RltTypeNm) const;
286      bool IsRltType(const TStr& RltTypeNm) const { 
287          return GetRltTypeN(RltTypeNm) != -1; }
288      const TStr& GetRltTypeNm(const int& RltTypeN) const { 
289          return RltTypeV[RltTypeN].GetName(); }
290      bool IsRltDir(const TStr& RltTypeNm) const {
291          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
292          return RltTypeV[GetRltTypeN(RltTypeNm)].IsDir(); }
293      bool IsRltTransitive(const TStr& RltTypeNm) const  {
294          IAssertR(IsRltType(RltTypeNm), "There is no such relation!"); 
295          return RltTypeV[GetRltTypeN(RltTypeNm)].IsTransitive(); }
296      bool IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
297      void AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
298      bool DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm);
299      void SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType,
300          const int& NewConceptN, TOntoConceptV& NewConceptV);
301      void SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType,
302          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
303      void SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
304          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV);
305      POntoConcept GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV);
306      POntoConcept GenSubconcept(const TIntV& NewCptDIdV);
307      void SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
308          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV,
309          TIntV& SuggestVocNV);
310      void AddConcept(const POntoConcept& NewCpt, const int& FatherCptId);
311      void BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV);
<span onclick='openModal()' class='match'>312      void DeleteConcept(const int& CptId, const bool& DoRedirect);
313      void PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId); 
314      void UniteConcepts(const int& CptId1, const int& CptId2);
315      void CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP);
</span>316      void NewConcept();
317      void ExtractKeywords(const int& CptId);
318      void CalcCptCompactness(const int& CptId);
319      void CalcCptClarity(const int& CptId);
320      PGraph GetGraph() const { return OntoGraph; }
321      void PrepareGraph(const int& SelectedCptId);
322      void PlaceGraph();
323      void SaveTxtStat(const TStr& FNm) { }
324      void ExportPTO(const TStr& FNm, const bool& DigLibP);
325      void ExportProlog(const TStr& FNm);
326      void ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP);
327      static POntology ImportPTO(const TStr& RdfFNm, const TStr& BowFNm);
328  };
329  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</h3>
            <pre><code>1  void TEvalScore::Tokenize(const TStr& Str, TStrV& TokenV) {
2      TStr LcStr = GetLc(Str);
3      TokenV.Clr(); TChA WordChA;
4      const int Chs = LcStr.Len();
5      for (int ChN = 0; ChN < Chs; ChN++) {
6          const char Ch = LcStr[ChN];
7          if (IsChar(Ch)) {
8              WordChA += Ch;
9          } else if (!WordChA.Empty()) {
10              TokenV.Add(WordChA);
11              WordChA.Clr();
12          }
13      }
14  }
15  void TEvalScore::Parse(const TStr& Str, TIntV& WIdV) {
16      TStrV TokenV; Tokenize(Str, TokenV); WIdV.Clr();
17      for (int WdN = 0; WdN < TokenV.Len(); WdN++) {
18          TStr WdStr = TokenV[WdN];
19          int WId = WordH.GetKeyId(WdStr);
20          if (WId == -1) { WId = WordH.AddKey(WdStr); }
21          WIdV.Add(WId);
22      }
23  }
24  void TEvalScore::GetNGramH(const TIntV& WIdV,
25          const int& MxNGramLen, TIntH& NGramIdH) {
26      const int Wds = WIdV.Len();
27      for (int NGramLen = 1; NGramLen <= MxNGramLen; NGramLen++) {
28          const int MxNGramStart = Wds - NGramLen + 1;
29          for (int NGramStart = 0; NGramStart < MxNGramStart; NGramStart++) {
30              TIntV NGram; WIdV.GetSubValV(NGramStart, NGramStart+NGramLen-1, NGram);
31              IAssert(NGram.Len() == NGramLen);
32              int NGramId = NGramH.GetKeyId(NGram);
33              if (NGramId == -1) { NGramId = NGramH.AddKey(NGram); }
34              NGramIdH.AddDat(NGramId)++;
35          }
36      }
37  }
38  PMom TEvalScore::EvalSig(const PTransCorpus& TransCorpus,
39          const int& Samples, const int& SampleSize, const int& Seed) {
40      TIntV SentIdV; TransCorpus->GetSentIdV(SentIdV);
41      TRnd Rnd(Seed); PMom Mom = TMom::New();
42      for (int SampleN = 0; SampleN < Samples; SampleN++) {
43          TIntV SampleIdV = SentIdV;
44          SampleIdV.Shuffle(Rnd);
45          SampleIdV.Trunc(SampleSize);
46          Mom->Add(Eval(TransCorpus, SampleIdV));
47      }
48      Mom->Def();
49      return Mom;
50  }
51  double TEvalScoreBleu::Eval(const PTransCorpus& TransCorpus, const TIntV& _SentIdV) {
52      IAssert(TransCorpus->IsTrans());
53      TIntH ClipCountNGramH, CountNGramH;
54      int FullTransLen = 0, FullRefLen = 0;
55      TIntV SentIdV = _SentIdV;
56      if (SentIdV.Empty()) { TransCorpus->GetSentIdV(SentIdV); }
57      const int Sents = SentIdV.Len();
58      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
59          const int SentId = SentIdV[SentIdN];
60          TIntV TransWIdV; Parse(TransCorpus->GetTransStr(SentId), TransWIdV);
61          TIntH TransNGramH; GetNGramH(TransWIdV, MxNGramLen, TransNGramH);
62          TIntH FreeTransNGramH = TransNGramH; 
63          const int TransLen = TransWIdV.Len();
64          int BestLen = 0, BestLenDiff = TInt::Mx;
65          TStrV RefTransStrV = TransCorpus->GetRefTransStrV(SentId);
66          for (int RefN = 0; RefN < RefTransStrV.Len(); RefN++) {
67              TIntV RefWIdV; Parse(RefTransStrV[RefN], RefWIdV);
68              TIntH RefNGramH; GetNGramH(RefWIdV, MxNGramLen, RefNGramH);
69              int TransNGramKeyId = TransNGramH.FFirstKeyId();
70              while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
71                  const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
72                  const int FreeTransNGrams = FreeTransNGramH(NGramId);
73                  if (RefNGramH.IsKey(NGramId) && (FreeTransNGrams>0)) {
74                      const int RefNGrams = RefNGramH(NGramId);
75                      FreeTransNGramH(NGramId) = TInt::GetMx(0, FreeTransNGrams - RefNGrams);
76                  }
77              }
78              const int RefLen = RefWIdV.Len();
79              const int LenDiff = TInt::Abs(TransLen - RefLen);
80              if (LenDiff < BestLenDiff) {
81                  BestLen = RefLen; BestLenDiff = LenDiff;
82              }
83          }
84          int TransNGramKeyId = TransNGramH.FFirstKeyId();
85          while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
86              const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
87              IAssert(NGramId != -1);
88              const int FreeNGramId = FreeTransNGramH.GetKey(TransNGramKeyId);
89              IAssert(NGramId == FreeNGramId);
90              const int Count = TransNGramH[TransNGramKeyId];
91              const int ClipCount = Count - FreeTransNGramH[TransNGramKeyId];
92              CountNGramH.AddDat(NGramId) += Count;
93              ClipCountNGramH.AddDat(NGramId) += ClipCount;
94          }
95          FullTransLen += TransLen;
96          FullRefLen += BestLen;
97      }
98      TIntV ClipCountV(MxNGramLen); ClipCountV.PutAll(0);
99      int ClipCountKeyId = ClipCountNGramH.FFirstKeyId();
100      while (ClipCountNGramH.FNextKeyId(ClipCountKeyId)) {
101          const int NGramId = ClipCountNGramH.GetKey(ClipCountKeyId);
102          const int NGramLen = GetNGramLen(NGramId);
103          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
104          ClipCountV[NGramLen-1] += ClipCountNGramH[ClipCountKeyId];
105      }
106      TIntV CountV(MxNGramLen); CountV.PutAll(0);
107      int CountKeyId = CountNGramH.FFirstKeyId();
108      while (CountNGramH.FNextKeyId(CountKeyId)) {
109          const int NGramId = CountNGramH.GetKey(CountKeyId);
110          const int NGramLen = GetNGramLen(NGramId);
111          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
112          CountV[NGramLen-1] += CountNGramH[CountKeyId];
113      }
114      TFltV PrecV(MxNGramLen, 0);
115      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
116          const int ClipCount = ClipCountV[NGramLen];
117          const int Count = CountV[NGramLen];
118          const double Prec = (Count > 0) ? double(ClipCount)/double(Count) : 0.0;
119          PrecV.Add(Prec);
120          printf("%d-gram Match:%d Total:%d Prec:%.5f\n", NGramLen+1, ClipCount, Count, Prec);
121      }
122      double LogBP = TFlt::GetMn(0.0, 1.0 - double(FullRefLen)/double(FullTransLen));
123      double BP = exp(LogBP);
124      printf("Sentence Len: %d, Best-match Sntence Len: %d, Score: %.5f\n",
125          FullTransLen, FullRefLen, LogBP);
126      double BleuScore = BP;
127      const double Wgt = 1.0 / double(MxNGramLen);
128      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
129          BleuScore *= pow(PrecV[NGramLen], Wgt);
130      }
131      printf("BLEU Score: %.5f\n", BleuScore);
132      return BleuScore;
133  }
134  void TTransCorpus::PutScriptHeader(const PSOut& SOut) {
135  }
136  void TTransCorpus::CleanTmx(const TStr& InTmxFNm, const TStr& OutXmlFNm) {
137      TFIn FIn(InTmxFNm); TFOut FOut(OutXmlFNm);
138      TStr ChStr; bool InTagP = false;
139      while (!FIn.Eof()) {
140          ChStr = TStr::GetChStr(FIn.GetCh());
141          if (ChStr == "<") { InTagP = true; FOut.PutStr(ChStr); }
142          else if (ChStr == ">") { InTagP = false; FOut.PutStr(ChStr); }
143          else if (!InTagP && ChStr != "\n" && ChStr != "\r") {
144              FOut.PutStr(TXmlDoc::GetXmlStr(ChStr));
145          } else { FOut.PutStr(ChStr); }
146      }
147  }
148  TStr TTransCorpus::CleanRtf(const TStr& InStr) {
149      TChA OutChA; int Chs = InStr.Len(); bool RtfTagP = false;
150      for (int ChN = 0; ChN < Chs; ChN++) {
151          const char Ch = InStr[ChN];
152          if (Ch == '{' || Ch == '}') { &bsol;* skip */ }
153          else if (Ch == '\\') { RtfTagP = true; }
154          else if (Ch == ' ' && RtfTagP) { RtfTagP = false; }
155          else if (!RtfTagP) { OutChA += Ch; }
156      }
157      return OutChA;
158  }
159  int TTransCorpus::CountWords(const TIntStrH& StrH) {
160      int Words = 0, KeyId = StrH.FFirstKeyId();
161      while (StrH.FNextKeyId(KeyId)) {
162          const TStr& Str = StrH[KeyId];
163          TStrV WordV; Str.SplitOnWs(WordV);
164          Words += WordV.Len();
165      }
166      return Words;
167  }
168  int TTransCorpus::CountWords(const TIntStrVH& StrVH, const bool& AllSents) {
169      int Words = 0, KeyId = StrVH.FFirstKeyId();
170      while (StrVH.FNextKeyId(KeyId)) {
171          const TStrV& StrV = StrVH[KeyId];
172          if (AllSents) {
173              for (int StrN = 0; StrN < StrV.Len(); StrN++) {
174                  TStrV WordV; StrV[StrN].SplitOnWs(WordV);
175                  Words += WordV.Len();
176              }
177          } else {
178              TStrV WordV; StrV[0].SplitOnWs(WordV);
179              Words += WordV.Len();
180          }
181      }
182      return Words;
183  }
184  inline void TTransCorpus::AddSentenceNoTrans(const int& SentId,
185          const TStr& OrgStr, const TStr& RefTransStr) {
186      AddSentenceNoTrans(SentId, OrgStr, TStrV::GetV(RefTransStr));
187  }
188  void TTransCorpus::AddSentenceNoTrans(const int& SentId,
189          const TStr& OrgStr, const TStrV& RefTransStrV) {
190      if (OrgStr.Empty()) { return; }
191      if (RefTransStrV[0].Empty()) { return; }
192      IAssert(!OrgStrH.IsKey(SentId));
193      OrgStrH.AddDat(SentId, OrgStr);
194      RefTransStrVH.AddDat(SentId, RefTransStrV);
195      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
196      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
197      IAssert(OrgKeyId == RefTransKeyId);
198  }
199  inline void TTransCorpus::AddSentenceNoOrg(const int& SentId,
200          const TStr& TransStr, const TStr& RefTransStr) {
201      AddSentenceNoOrg(SentId, TransStr, TStrV::GetV(RefTransStr));
202  }
203  void TTransCorpus::AddSentenceNoOrg(const int& SentId,
204          const TStr& TransStr, const TStrV& RefTransStrV) {
205      IAssert(!TransStrH.IsKey(SentId));
206      TransStrH.AddDat(SentId, TransStr);
207      RefTransStrVH.AddDat(SentId, RefTransStrV);
208      const int TransKeyId = TransStrH.GetKeyId(SentId);
209      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
210      IAssert(TransKeyId == RefTransKeyId);
211  }
212  inline void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
213          const TStr& TransStr, const TStr& RefTransStr) {
214      AddSentence(SentId, OrgStr, TransStr, TStrV::GetV(RefTransStr));
215  }
216  void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
217          const TStr& TransStr, const TStrV& RefTransStrV) {
218      IAssert(!OrgStrH.IsKey(SentId));
219      OrgStrH.AddDat(SentId, OrgStr);
220      TransStrH.AddDat(SentId, TransStr);
221      RefTransStrVH.AddDat(SentId, RefTransStrV);
222      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
223      const int TransKeyId = TransStrH.GetKeyId(SentId);
224      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
225      IAssert(OrgKeyId == TransKeyId);
226      IAssert(OrgKeyId == RefTransKeyId);
227  }
228  void TTransCorpus::GetSentIdV(TIntV& SentIdV) const {
229      if (IsOrg()) { OrgStrH.GetKeyV(SentIdV); }
230      else if (IsTrans()) { TransStrH.GetKeyV(SentIdV); }
231      else if (IsRefTrans()) { RefTransStrVH.GetKeyV(SentIdV); }
232      else { Fail; }
233  }
234  PTransCorpus TTransCorpus::LoadAC(const TStr& InXmlFNm, const int& MxSents) {
235      PTransCorpus TransCorpus = TTransCorpus::New();
236      PSIn XmlSIn=TFIn::New(InXmlFNm);
237      TXmlDoc::SkipTopTag(XmlSIn); 
238      printf("Ignoring: %s\n", TXmlDoc::LoadTxt(XmlSIn)->GetTok()->GetTagNm().CStr()); 
239      TXmlDoc::SkipTopTag(XmlSIn); 
240      TXmlDoc::SkipTopTag(XmlSIn); 
241      PXmlDoc XmlDoc; int XmlDocs = 0, SentId = 0;;
242      forever{
243          XmlDocs++; printf("%7d Sentences \r", SentId);
244          XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
245          if (!XmlDoc->IsOk()) { &bsol;*printf("Error: %s\n", XmlDoc->GetMsgStr().CStr());*/ break; }
246          PXmlTok TopTok=XmlDoc->GetTok();
247          if (TopTok->IsTag("div")){
248              TStr DocNm = TopTok->GetArgVal("n");
249              TXmlTokV LinkTokV; TopTok->GetTagTokV("linkGrp|link", LinkTokV);
250              for (int LinkTokN = 0; LinkTokN < LinkTokV.Len(); LinkTokN++) {
251                  PXmlTok LinkTok = LinkTokV[LinkTokN];
252                  TStr LinkType = LinkTok->GetArgVal("type");
253                  if (LinkType == "1:1") {
254                      TXmlTokV S1TokV; LinkTok->GetTagTokV("s1", S1TokV);
255                      TXmlTokV S2TokV; LinkTok->GetTagTokV("s2", S2TokV);
256                      IAssert(S1TokV.Len() == 1); IAssert(S2TokV.Len() == 1);
257                      TStr ParaStr1 = S1TokV[0]->GetTagTokStr("");
258                      TStr ParaStr2 = S2TokV[0]->GetTagTokStr("");
259                      TransCorpus->AddSentenceNoTrans(SentId, ParaStr1, ParaStr2); SentId++;
260                  }
261              }
262          } else {
263              printf("Unknow tag: %s\n", TopTok->GetTagNm().CStr());
264          }
265          if ((MxSents != -1) && (TransCorpus->GetSentences() > MxSents)) { break; }
266      }
267      printf("\n");
268      return TransCorpus;
269  }
270  PTransCorpus TTransCorpus::LoadEP(const TStr& InOrgFPath, const TStr& InTransFPath) {
271      PTransCorpus TransCorpus = TTransCorpus::New();
272      TStr NrmInTransFPath = TStr::GetNrAbsFPath(InTransFPath);
273      TFFile OrgFNms(InOrgFPath, "txt", false); TStr OrgFNm;
274      int SentId = 0;
275      while (OrgFNms.Next(OrgFNm)) {
276          TStr TransFNm = NrmInTransFPath + OrgFNm.GetFBase();
277          IAssertR(TFile::Exists(TransFNm), TransFNm);
278          printf("Loading %s and %s ...\r", OrgFNm.CStr(), TransFNm.CStr());
279          TLnRet OrgLnRet(TFIn::New(OrgFNm));
280          TLnRet TransLnRet(TFIn::New(TransFNm));
281          TStr OrgLn, TransLn; int LnN = 1; bool EmptyLnP = false;
282          while (OrgLnRet.NextLn(OrgLn)) {
283              if (!TransLnRet.NextLn(TransLn)) {
284                  printf("\nEarly stop in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
285                  break; 
286              }
287              if (OrgLn.Empty() || TransFNm.Empty()) {
288                  EmptyLnP = true;
289              } else if (OrgLn[0] == '<' || TransLn[0] == '<') {
290                  if (TransLn[0] != OrgLn[0]) {
291                      printf("\nError in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
292                      break; 
293                  }
294                  EmptyLnP = false;
295              } else if (!EmptyLnP) {
296                  TransCorpus->AddSentenceNoTrans(SentId,
297                      OrgLn.ToTrunc(), TransLn.ToTrunc());
298                  SentId++;
299              }
300              LnN++;
301          }
302      }
303      printf("\nDone!\n");
304      return TransCorpus;
305  }
306  PTransCorpus TTransCorpus::LoadTMX(const TStr& InTmxFPath,
307          const TStr& OrgLang, const TStr& RefTransLang) {
308      PTransCorpus TransCorpus = TTransCorpus::New();
309      TFFile TmxFNms(InTmxFPath, "tmx", false); TStr TmxFNm; int SentId = 0;
310      while (TmxFNms.Next(TmxFNm)) {
311          printf("Loading %s ...\n", TmxFNm.CStr());
312          TStr CleanTmxFNm = TmxFNm + ".xml";
313          CleanTmx(TmxFNm, CleanTmxFNm);
314          PSIn XmlSIn = TFIn::New(CleanTmxFNm);
315          PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
316          if (!XmlDoc->IsOk()) {
317              printf(" error: %s\n", XmlDoc->GetMsgStr().CStr());
318              continue;
319          }
320          TXmlTokV TuTokV; XmlDoc->GetTagTokV("tmx|body|tu", TuTokV);
321          const int TuToks = TuTokV.Len();
322          for (int TuTokN = 0; TuTokN < TuToks; TuTokN++) {
323              if (TuTokN % 100 == 0) { printf(" %d / %d\r", TuTokN, TuToks); }
324              TXmlTokV TuvTokV; TuTokV[TuTokN]->GetTagTokV("tuv", TuvTokV);
325              IAssert(TuvTokV.Len() == 2);
326              TStr OrgSent, RefTransSent;
327              for (int TuvTokN = 0; TuvTokN < TuvTokV.Len(); TuvTokN++) {
328                  TStr Lang = TuvTokV[TuvTokN]->GetStrArgVal("xml:lang", "");
329                  TStr Sent = CleanRtf(TuvTokV[TuvTokN]->GetTagTok("seg")->GetTokStr(false));
330                  if (Lang == OrgLang) { OrgSent = Sent; }
331                  else if (Lang == RefTransLang) { RefTransSent = Sent; }
332              }
333              TransCorpus->AddSentenceNoTrans(SentId, OrgSent, RefTransSent); SentId++;
334          }
335          printf(" %d / %d\n", TuToks, TuToks);
336      }
337      return TransCorpus;
338  }
339  PTransCorpus TTransCorpus::LoadTxt(const TStr& InOrgFNm,
340          const TStr& InTransFNm, const TStr& InRefTransFNm) {
341      PSIn OrgSIn = !InOrgFNm.Empty() ? TFIn::New(InOrgFNm) : PSIn();
342      PSIn TransSIn = !InTransFNm.Empty() ? TFIn::New(InTransFNm) : PSIn();
343      PSIn RefTransSIn = !InRefTransFNm.Empty() ? TFIn::New(InRefTransFNm) : PSIn();
344      const bool IsOrgP = !OrgSIn.Empty();
345      const bool IsTransP = !TransSIn.Empty();
346      const bool IsRefTransP = !RefTransSIn.Empty();
347      if (!IsOrgP) { printf("No original sentences!\n"); }
348      if (!IsTransP) { printf("No machine translation sentences!\n"); }
349      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
350      PTransCorpus TransCorpus = TTransCorpus::New();
351      TLnRet OrgLnRet(OrgSIn), TransLnRet(TransSIn), RefTransLnRet(RefTransSIn);
352      TStr OrgLnStr, TransLnStr, RefTransLnStr; int LnN = 1;
353      forever {
354          if (IsOrgP && !OrgLnRet.NextLn(OrgLnStr)) { break; }
355          if (IsTransP && !TransLnRet.NextLn(TransLnStr)) { break; }
356          if (IsRefTransP && !RefTransLnRet.NextLn(RefTransLnStr)) { break; }
357          if (LnN % 100 == 0) { printf("  %7d Sentences\r", LnN); }
358          if (!IsOrgP) {
359              TransCorpus->AddSentenceNoOrg(LnN, TransLnStr, RefTransLnStr);
360          } else if (!IsTransP) {
361              TransCorpus->AddSentenceNoTrans(LnN, OrgLnStr, RefTransLnStr);
362          } else { IAssert(IsRefTransP);
363              TransCorpus->AddSentence(LnN, OrgLnStr, TransLnStr, RefTransLnStr);
364          }
365          LnN++;
366      } printf("\n");
367      return TransCorpus;
368  }
369  void TTransCorpus::SaveTxt(const TStr& OutFBase, const TStr& OutOrgFNm,
370          const TStr& OutTransFNm, const TStr& OutRefTransFNm, TStrV& OrgFNmV,
371          TStrV& TransFNmV, TStrV& RefTransFNmV, const int& LinesPerFile) {
372      OrgFNmV.Clr(); TransFNmV.Clr(); RefTransFNmV.Clr();
373      if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutOrgFNm)); }
374      if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutTransFNm)); }
375      if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutRefTransFNm)); }
376      PSOut OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
377      PSOut TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
378      PSOut RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
379      const bool IsOrgP = !OrgSOut.Empty() && IsOrg();
380      const bool IsTransP = !TransSOut.Empty() && IsTrans();
381      const bool IsRefTransP = !RefTransSOut.Empty() && IsRefTrans();
382      if (!IsOrgP) { printf("No original sentences!\n"); }
383      if (!IsTransP) { printf("No machine translation sentences!\n"); }
384      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
385      TIntV SentIdV; GetSentIdV(SentIdV);
386      for (int SentIdN = 0; SentIdN < SentIdV.Len(); SentIdN++) {
387          const int SentId = SentIdV[SentIdN];
388          if (IsOrgP) { OrgSOut->PutStrLn(GetOrgStr(SentId)); }
389          if (IsTransP) { TransSOut->PutStrLn(GetTransStr(SentId)); }
390          if (IsRefTransP) { RefTransSOut->PutStrLn(GetRefTransStrV(SentId)[0]); }
391          if ((LinesPerFile!=-1) && (SentIdN>0) && (SentIdN % LinesPerFile == 0)) {
392              if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutOrgFNm)); }
393              if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutTransFNm)); }
394              if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutRefTransFNm)); }
395              OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
396              TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
397              RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
398          }
399      }
400  }
401  void TTransCorpus::SaveTransScript(const TStr& OutFBase, const TStr& OrgLang,
402          const TStr& TransLang, const TStrV& OrgFNmV, const TStrV& RefTransFNmV) {
403      const int FNms = OrgFNmV.Len();
404      IAssert(OrgFNmV.Len() == RefTransFNmV.Len());
405      PSOut TokSOut = TFOut::New(OutFBase + "_tokenize.sh");
406      PutScriptHeader(TokSOut);
407      for (int FNmN = 0; FNmN < FNms; FNmN++) {
408          TokSOut->PutStrLn("tokenize.pl -lang=" + OrgLang + " " +
409              OrgFNmV[FNmN].GetFBase() + " " +
410              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase());
411          TokSOut->PutStrLn("tokenize.pl -lang=" + TransLang + " " +
412              RefTransFNmV[FNmN].GetFBase() + " " +
413              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
414      }
415      TokSOut->Flush();
416      PSOut AlignSOut = TFOut::New(OutFBase + "_align.sh");
417      PutScriptHeader(AlignSOut);
418      for (int FNmN = 0; FNmN < FNms; FNmN++) {
419          AlignSOut->PutStrLn("ssal -f " +
420              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase() + " " +
421              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
422          AlignSOut->PutStrLn("mv " +
423              TStr::PutFExt(OrgFNmV[FNmN], ".tok.al").GetFBase() + " " +
424              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase());
425          AlignSOut->PutStrLn("mv " +
426              TStr::PutFExt(RefTransFNmV[FNmN], ".tok.al").GetFBase() + " " +
427              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase());
428      }
429      AlignSOut->Flush();
430      PSOut LcSOut = TFOut::New(OutFBase + "_lowercase.sh");
431      PutScriptHeader(LcSOut);
432      for (int FNmN = 0; FNmN < FNms; FNmN++) {
433          LcSOut->PutStrLn("lc-latin.pl " +
434              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase() + " " +
435              TStr::PutFExt(OrgFNmV[FNmN], ".lc").GetFBase());
436          LcSOut->PutStrLn("lc-latin.pl " +
437              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase() + " " +
438              TStr::PutFExt(RefTransFNmV[FNmN], ".lc").GetFBase());
439      }
440      LcSOut->Flush();
441  }
442  TAlignPair::TAlignPair(const TStr& _Lang1, const TStr& _Lang2): Lang1(_Lang1), Lang2(_Lang2) {
443      BowDocBs1 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
444      BowDocBs2 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
445  }
446  TAlignPair::TAlignPair(TSIn& SIn) {
447      Lang1.Load(SIn); Lang2.Load(SIn);
448      BowDocBs1 = TBowDocBs::Load(SIn); BowDocBs1->SaveTxtStat(Lang1 + Lang2 + ".txt");
449      BowDocBs2 = TBowDocBs::Load(SIn); BowDocBs2->SaveTxtStat(Lang1 + Lang2 + ".txt");
450      Def();
451  }
452  void TAlignPair::Save(TSOut& SOut) const {
453      Lang1.Save(SOut); Lang2.Save(SOut);
454      BowDocBs1->Save(SOut); BowDocBs2->Save(SOut);
455  }
456  void TAlignPair::AddSent(const TStr& Sent1, const TStr& Sent2) {
457      TStr DocNm = TInt::GetStr(BowDocBs1->GetDocs());
458      BowDocBs1->AddHtmlDoc(DocNm, TStrV(), Sent1, false);
459      BowDocBs2->AddHtmlDoc(DocNm, TStrV(), Sent2, false);
460      IAssert(BowDocBs1->GetDocs() == BowDocBs2->GetDocs());
461  }
462  void TAlignPair::Def() {
463      BowDocWgtBs1 = TBowDocWgtBs::New(BowDocBs1, bwwtNrmTFIDF);
464      BowDocWgtBs2 = TBowDocWgtBs::New(BowDocBs2, bwwtNrmTFIDF);
465      Matrix1 = TBowMatrix(BowDocWgtBs1);
466      Matrix2 = TBowMatrix(BowDocWgtBs2);
467  }
468  const TMatrix& TAlignPair::GetMatrix(const TStr& Lang) const {
469      if (Lang == Lang1) { return Matrix1; }
470      else if (Lang == Lang2) { return Matrix2; }
471      TExcept::Throw("Wrong language " + Lang + "!");
472      Fail; return *(new TBowMatrix); 
473  }
474  void TAlignPair::GetSpV(const TStr& Str, const TStr& Lang, TIntFltKdV& SpV) const {
475      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
476      PBowSpV BowSpV = (Lang == Lang1) ?
477          BowDocBs1->GetSpVFromHtmlStr(Str) :
478          BowDocBs2->GetSpVFromHtmlStr(Str);
479      BowSpV->GetIntFltKdV(SpV);
480  }
481  TStr TAlignPair::GetSpVStr(const TIntFltKdV& SpV, const TStr& Lang,
482          const int& MxWords, const double& MxWgtPrc) const {
483      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
484      PBowDocBs BowDocBs = (Lang == Lang1) ? BowDocBs1 : BowDocBs2;
485      PBowSpV BowSpV = TBowSpV::New(-1, SpV);
486      return BowSpV->GetStr(BowDocBs, MxWords, MxWgtPrc, " ", false, false);
487  }
488  PAlignPair TAlignPair::LoadAcXml(const TStr& FNm, const int& MxSents) {
489      printf("Loading %s ...\n", FNm.CStr());
490      TStr BaseNm = FNm.GetFMid();
491      TStrV PartV; BaseNm.SplitOnAllCh('-', PartV);
492      IAssertR(PartV.Len() == 3, "Bad file name: " + BaseNm);
493      PAlignPair AlignPair = TAlignPair::New(PartV[1], PartV[2]);
494      PTransCorpus TransCorpus = TTransCorpus::LoadAC(FNm, MxSents * 4);
495      const int AllSents = TransCorpus->GetSentences();
496      TIntV SentIdV(AllSents, 0);
497      for (int SentId = 0; SentId < AllSents; SentId++) {
498          SentIdV.Add(SentId);
499      }
500      if (MxSents != -1 && AllSents > MxSents) {
501          TRnd Rnd(1);
502          SentIdV.Shuffle(Rnd);
503          SentIdV.Trunc(MxSents);
504      }
505      const int Sents = SentIdV.Len();
506      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
507          const int SentId = SentIdV[SentIdN];
508          const TStr& Sent1 = TransCorpus->GetOrgStr(SentId);
509          const TStr& Sent2 = TransCorpus->GetRefTransStrV(SentId)[0];
510          AlignPair->AddSent(Sent1, Sent2);
511      }
512      AlignPair->Def();
513      return AlignPair;
514  }
515  void TAlignPairBs::AddAlignPair(const PAlignPair& AlignPair) {
516      const int LangId1 = LangH.AddKey(AlignPair->GetLang1());
517      const int LangId2 = LangH.AddKey(AlignPair->GetLang2());
518      AlignPairV.Add(AlignPair);
519      LangToAlignPairVH.AddDat(LangId1).Add(AlignPair);
520      LangToAlignPairVH.AddDat(LangId2).Add(AlignPair);
521      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
522      LangPrToAlignPairH.AddDat(LangIdPr, AlignPair);
523  }
524  PAlignPair TAlignPairBs::GetAlignPair(const int& LangId1, const int& LangId2) {
525      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
526      return LangPrToAlignPairH.GetDat(LangIdPr);
527  }
528  TAlignPairBs::TAlignPairBs(TSIn& SIn) {
529      LangH.Load(SIn);
530      TAlignPairV TmpAlignPairV(SIn);
531      for (int TmpAlignPairN = 0; TmpAlignPairN < TmpAlignPairV.Len(); TmpAlignPairN++) {
532          AddAlignPair(TmpAlignPairV[TmpAlignPairN]);
533      }
534  }
535  void TAlignPairBs::Save(TSOut& SOut) const {
536      LangH.Save(SOut);
537      AlignPairV.Save(SOut);
538  }
<span onclick='openModal()' class='match'>539  TStr TAlignPairBs::MapQuery(const TAlignPairMap& Map, const TStr& QueryStr,
540          const int& QueryLangId, const int& TargetLangId, const int& TransQueryMtpy,
541          const double& MxWgtPrc) {
</span>542      PAlignPair AlignPair = GetAlignPair(QueryLangId, TargetLangId);
543      const TStr& QueryLang = LangH.GetKey(QueryLangId);
544      const TStr& TargetLang = LangH.GetKey(TargetLangId);
545      TIntFltKdV InSpV; AlignPair->GetSpV(QueryStr, QueryLang, InSpV);
546      const TMatrix& QueryMatrix = AlignPair->GetMatrix(QueryLang);
547      const TMatrix& TargetMatrix = AlignPair->GetMatrix(TargetLang);
548      TIntFltKdV OutSpV; Map(InSpV, QueryMatrix, TargetMatrix, OutSpV);
549      return AlignPair->GetSpVStr(OutSpV, TargetLang,
550          InSpV.Len() * TransQueryMtpy, MxWgtPrc);
551  }
552  PAlignPairBs TAlignPairBs::LoadAcXml(const TStr& FPath, const int& MxSents) {
553      PAlignPairBs AlignPairBs = TAlignPairBs::New();
554      TFFile FFile(FPath, ".xml", false); TStr FNm;
555      while (FFile.Next(FNm)) {
556          PAlignPair AlignPair = TAlignPair::LoadAcXml(FNm, MxSents);
557          AlignPairBs->AddAlignPair(AlignPair);
558      }
559      return AlignPairBs;
560  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</div>
                </div>
                <div class="column column_space"><pre><code>312      void DeleteConcept(const int& CptId, const bool& DoRedirect);
313      void PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId); 
314      void UniteConcepts(const int& CptId1, const int& CptId2);
315      void CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP);
</pre></code></div>
                <div class="column column_space"><pre><code>539  TStr TAlignPairBs::MapQuery(const TAlignPairMap& Map, const TStr& QueryStr,
540          const int& QueryLangId, const int& TargetLangId, const int& TransQueryMtpy,
541          const double& MxWgtPrc) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    