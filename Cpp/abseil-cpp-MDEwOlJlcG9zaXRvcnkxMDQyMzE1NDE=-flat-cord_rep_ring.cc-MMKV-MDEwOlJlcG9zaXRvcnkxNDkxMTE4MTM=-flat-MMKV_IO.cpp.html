
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.547960941987363%, Tokens: 10</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_ring.h"
2  #include <cassert>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iostream>
6  #include <limits>
7  #include <memory>
8  #include <string>
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/throw_delegate.h"
11  #include "absl/base/macros.h"
12  #include "absl/container/inlined_vector.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_consume.h"
15  #include "absl/strings/internal/cord_rep_flat.h"
16  namespace absl {
17  ABSL_NAMESPACE_BEGIN
18  namespace cord_internal {
19  namespace {
20  using index_type = CordRepRing::index_type;
21  enum class Direction { kForward, kReversed };
22  inline bool IsFlatOrExternal(CordRep* rep) {
23    return rep->IsFlat() || rep->IsExternal();
24  }
25  inline void CheckCapacity(size_t n, size_t extra) {
26    if (ABSL_PREDICT_FALSE(extra > CordRepRing::kMaxCapacity - n)) {
27      base_internal::ThrowStdLengthError("Maximum capacity exceeded");
28    }
29  }
30  CordRepFlat* CreateFlat(const char* s, size_t n, size_t extra = 0) {  
31    assert(n <= kMaxFlatLength);
32    auto* rep = CordRepFlat::New(n + extra);
33    rep->length = n;
34    memcpy(rep->Data(), s, n);
35    return rep;
36  }
37  void UnrefEntries(const CordRepRing* rep, index_type head, index_type tail) {
38    rep->ForEach(head, tail, [rep](index_type ix) {
39      CordRep* child = rep->entry_child(ix);
40      if (!child->refcount.Decrement()) {
41        if (child->tag >= FLAT) {
42          CordRepFlat::Delete(child->flat());
43        } else {
44          CordRepExternal::Delete(child->external());
45        }
46      }
47    });
48  }
49  }  
50  std::ostream& operator<<(std::ostream& s, const CordRepRing& rep) {
51    s << "  CordRepRing(" << &rep << ", length = " << rep.length
52      << ", head = " << rep.head_ << ", tail = " << rep.tail_
53      << ", cap = " << rep.capacity_ << ", rc = " << rep.refcount.Get()
54      << ", begin_pos_ = " << static_cast<ptrdiff_t>(rep.begin_pos_) << ") {\n";
55    CordRepRing::index_type head = rep.head();
56    do {
57      CordRep* child = rep.entry_child(head);
58      s << " entry[" << head << "] length = " << rep.entry_length(head)
59        << ", child " << child << ", clen = " << child->length
60        << ", tag = " << static_cast<int>(child->tag)
61        << ", rc = " << child->refcount.Get()
62        << ", offset = " << rep.entry_data_offset(head)
63        << ", end_pos = " << static_cast<ptrdiff_t>(rep.entry_end_pos(head))
64        << "\n";
65      head = rep.advance(head);
66    } while (head != rep.tail());
67    return s << "}\n";
68  }
69  void CordRepRing::AddDataOffset(index_type index, size_t n) {
70    entry_data_offset()[index] += static_cast<offset_type>(n);
71  }
72  void CordRepRing::SubLength(index_type index, size_t n) {
73    entry_end_pos()[index] -= n;
74  }
75  class CordRepRing::Filler {
76   public:
77    Filler(CordRepRing* rep, index_type pos) : rep_(rep), head_(pos), pos_(pos) {}
78    index_type head() const { return head_; }
79    index_type pos() const { return pos_; }
80    void Add(CordRep* child, size_t offset, pos_type end_pos) {
81      rep_->entry_end_pos()[pos_] = end_pos;
82      rep_->entry_child()[pos_] = child;
83      rep_->entry_data_offset()[pos_] = static_cast<offset_type>(offset);
84      pos_ = rep_->advance(pos_);
85    }
86   private:
87    CordRepRing* rep_;
88    index_type head_;
89    index_type pos_;
90  };
91  #ifdef ABSL_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL
92  constexpr size_t CordRepRing::kMaxCapacity;
93  #endif
94  bool CordRepRing::IsValid(std::ostream& output) const {
95    if (capacity_ == 0) {
96      output << "capacity == 0";
97      return false;
98    }
99    if (head_ >= capacity_ || tail_ >= capacity_) {
100      output << "head " << head_ << " and/or tail " << tail_ << "exceed capacity "
101             << capacity_;
102      return false;
103    }
104    const index_type back = retreat(tail_);
105    size_t pos_length = Distance(begin_pos_, entry_end_pos(back));
106    if (pos_length != length) {
107      output << "length " << length << " does not match positional length "
108             << pos_length << " from begin_pos " << begin_pos_ << " and entry["
109             << back << "].end_pos " << entry_end_pos(back);
110      return false;
111    }
112    index_type head = head_;
113    pos_type begin_pos = begin_pos_;
114    do {
115      pos_type end_pos = entry_end_pos(head);
<span onclick='openModal()' class='match'>116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
</span>127      if (child->tag < FLAT && child->tag != EXTERNAL) {
128        output << "entry[" << head << "].child has an invalid tag "
129               << static_cast<int>(child->tag);
130        return false;
131      }
132      size_t offset = entry_data_offset(head);
133      if (offset >= child->length || entry_length > child->length - offset) {
134        output << "entry[" << head << "] has offset " << offset
135               << " and entry length " << entry_length
136               << " which are outside of the child's length of " << child->length;
137        return false;
138      }
139      begin_pos = end_pos;
140      head = advance(head);
141    } while (head != tail_);
142    return true;
143  }
144  #ifdef EXTRA_CORD_RING_VALIDATION
145  CordRepRing* CordRepRing::Validate(CordRepRing* rep, const char* file,
146                                     int line) {
147    if (!rep->IsValid(std::cerr)) {
148      std::cerr << "\nERROR: CordRepRing corrupted";
149      if (line) std::cerr << " at line " << line;
150      if (file) std::cerr << " in file " << file;
151      std::cerr << "\nContent = " << *rep;
152      abort();
153    }
154    return rep;
155  }
156  #endif  
157  CordRepRing* CordRepRing::New(size_t capacity, size_t extra) {
158    CheckCapacity(capacity, extra);
159    size_t size = AllocSize(capacity += extra);
160    void* mem = ::operator new(size);
161    auto* rep = new (mem) CordRepRing(static_cast<index_type>(capacity));
162    rep->tag = RING;
163    rep->capacity_ = static_cast<index_type>(capacity);
164    rep->begin_pos_ = 0;
165    return rep;
166  }
167  void CordRepRing::SetCapacityForTesting(size_t capacity) {
168    assert(capacity <= capacity_);
169    assert(head() == 0 || head() < tail());
170    memmove(Layout::Partial(capacity).Pointer<1>(data_) + head(),
171            Layout::Partial(capacity_).Pointer<1>(data_) + head(),
172            entries() * sizeof(Layout::ElementType<1>));
173    memmove(Layout::Partial(capacity, capacity).Pointer<2>(data_) + head(),
174            Layout::Partial(capacity_, capacity_).Pointer<2>(data_) + head(),
175            entries() * sizeof(Layout::ElementType<2>));
176    capacity_ = static_cast<index_type>(capacity);
177  }
178  void CordRepRing::Delete(CordRepRing* rep) {
179    assert(rep != nullptr && rep->IsRing());
180  #if defined(__cpp_sized_deallocation)
181    size_t size = AllocSize(rep->capacity_);
182    rep->~CordRepRing();
183    ::operator delete(rep, size);
184  #else
185    rep->~CordRepRing();
186    ::operator delete(rep);
187  #endif
188  }
189  void CordRepRing::Destroy(CordRepRing* rep) {
190    UnrefEntries(rep, rep->head(), rep->tail());
191    Delete(rep);
192  }
193  template <bool ref>
194  void CordRepRing::Fill(const CordRepRing* src, index_type head,
195                         index_type tail) {
196    this->length = src->length;
197    head_ = 0;
198    tail_ = advance(0, src->entries(head, tail));
199    begin_pos_ = src->begin_pos_;
200    auto* dst_pos = entry_end_pos();
201    auto* dst_child = entry_child();
202    auto* dst_offset = entry_data_offset();
203    src->ForEach(head, tail, [&](index_type index) {
204      *dst_pos++ = src->entry_end_pos(index);
205      CordRep* child = src->entry_child(index);
206      *dst_child++ = ref ? CordRep::Ref(child) : child;
207      *dst_offset++ = src->entry_data_offset(index);
208    });
209  }
210  CordRepRing* CordRepRing::Copy(CordRepRing* rep, index_type head,
211                                 index_type tail, size_t extra) {
212    CordRepRing* newrep = CordRepRing::New(rep->entries(head, tail), extra);
213    newrep->Fill<true>(rep, head, tail);
214    CordRep::Unref(rep);
215    return newrep;
216  }
217  CordRepRing* CordRepRing::Mutable(CordRepRing* rep, size_t extra) {
218    size_t entries = rep->entries();
219    if (!rep->refcount.IsOne()) {
220      return Copy(rep, rep->head(), rep->tail(), extra);
221    } else if (entries + extra > rep->capacity()) {
222      const size_t min_grow = rep->capacity() + rep->capacity() / 2;
223      const size_t min_extra = (std::max)(extra, min_grow - entries);
224      CordRepRing* newrep = CordRepRing::New(entries, min_extra);
225      newrep->Fill<false>(rep, rep->head(), rep->tail());
226      CordRepRing::Delete(rep);
227      return newrep;
228    } else {
229      return rep;
230    }
231  }
232  Span<char> CordRepRing::GetAppendBuffer(size_t size) {
233    assert(refcount.IsOne());
234    index_type back = retreat(tail_);
235    CordRep* child = entry_child(back);
236    if (child->tag >= FLAT && child->refcount.IsOne()) {
237      size_t capacity = child->flat()->Capacity();
238      pos_type end_pos = entry_end_pos(back);
239      size_t data_offset = entry_data_offset(back);
240      size_t entry_length = Distance(entry_begin_pos(back), end_pos);
241      size_t used = data_offset + entry_length;
242      if (size_t n = (std::min)(capacity - used, size)) {
243        child->length = data_offset + entry_length + n;
244        entry_end_pos()[back] = end_pos + n;
245        this->length += n;
246        return {child->flat()->Data() + used, n};
247      }
248    }
249    return {nullptr, 0};
250  }
251  Span<char> CordRepRing::GetPrependBuffer(size_t size) {
252    assert(refcount.IsOne());
253    CordRep* child = entry_child(head_);
254    size_t data_offset = entry_data_offset(head_);
255    if (data_offset && child->refcount.IsOne() && child->tag >= FLAT) {
256      size_t n = (std::min)(data_offset, size);
257      this->length += n;
258      begin_pos_ -= n;
259      data_offset -= n;
260      entry_data_offset()[head_] = static_cast<offset_type>(data_offset);
261      return {child->flat()->Data() + data_offset, n};
262    }
263    return {nullptr, 0};
264  }
265  CordRepRing* CordRepRing::CreateFromLeaf(CordRep* child, size_t offset,
266                                           size_t len, size_t extra) {
267    CordRepRing* rep = CordRepRing::New(1, extra);
268    rep->head_ = 0;
269    rep->tail_ = rep->advance(0);
270    rep->length = len;
271    rep->entry_end_pos()[0] = len;
272    rep->entry_child()[0] = child;
273    rep->entry_data_offset()[0] = static_cast<offset_type>(offset);
274    return Validate(rep);
275  }
276  CordRepRing* CordRepRing::CreateSlow(CordRep* child, size_t extra) {
277    CordRepRing* rep = nullptr;
278    Consume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
279      if (IsFlatOrExternal(child_arg)) {
280        rep = rep ? AppendLeaf(rep, child_arg, offset, len)
281                  : CreateFromLeaf(child_arg, offset, len, extra);
282      } else if (rep) {
283        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
284      } else if (offset == 0 && child_arg->length == len) {
285        rep = Mutable(child_arg->ring(), extra);
286      } else {
287        rep = SubRing(child_arg->ring(), offset, len, extra);
288      }
289    });
290    return Validate(rep, nullptr, __LINE__);
291  }
292  CordRepRing* CordRepRing::Create(CordRep* child, size_t extra) {
293    size_t length = child->length;
294    if (IsFlatOrExternal(child)) {
295      return CreateFromLeaf(child, 0, length, extra);
296    }
297    if (child->IsRing()) {
298      return Mutable(child->ring(), extra);
299    }
300    return CreateSlow(child, extra);
301  }
302  template <CordRepRing::AddMode mode>
303  CordRepRing* CordRepRing::AddRing(CordRepRing* rep, CordRepRing* ring,
304                                    size_t offset, size_t len) {
305    assert(offset < ring->length);
306    constexpr bool append = mode == AddMode::kAppend;
307    Position head = ring->Find(offset);
308    Position tail = ring->FindTail(head.index, offset + len);
309    const index_type entries = ring->entries(head.index, tail.index);
310    rep = Mutable(rep, entries);
311    const pos_type delta_length =
312        (append ? rep->begin_pos_ + rep->length : rep->begin_pos_ - len) -
313        ring->entry_begin_pos(head.index) - head.offset;
314    Filler filler(rep, append ? rep->tail_ : rep->retreat(rep->head_, entries));
315    if (ring->refcount.IsOne()) {
316      ring->ForEach(head.index, tail.index, [&](index_type ix) {
317        filler.Add(ring->entry_child(ix), ring->entry_data_offset(ix),
318                   ring->entry_end_pos(ix) + delta_length);
319      });
320      if (head.index != ring->head_) UnrefEntries(ring, ring->head_, head.index);
321      if (tail.index != ring->tail_) UnrefEntries(ring, tail.index, ring->tail_);
322      CordRepRing::Delete(ring);
323    } else {
324      ring->ForEach(head.index, tail.index, [&](index_type ix) {
325        CordRep* child = ring->entry_child(ix);
326        filler.Add(child, ring->entry_data_offset(ix),
327                   ring->entry_end_pos(ix) + delta_length);
328        CordRep::Ref(child);
329      });
330      CordRepRing::Unref(ring);
331    }
332    if (head.offset) {
333      rep->AddDataOffset(filler.head(), head.offset);
334    }
335    if (tail.offset) {
336      rep->SubLength(rep->retreat(filler.pos()), tail.offset);
337    }
338    rep->length += len;
339    if (append) {
340      rep->tail_ = filler.pos();
341    } else {
342      rep->head_ = filler.head();
343      rep->begin_pos_ -= len;
344    }
345    return Validate(rep);
346  }
347  CordRepRing* CordRepRing::AppendSlow(CordRepRing* rep, CordRep* child) {
348    Consume(child, [&rep](CordRep* child_arg, size_t offset, size_t len) {
349      if (child_arg->IsRing()) {
350        rep = AddRing<AddMode::kAppend>(rep, child_arg->ring(), offset, len);
351      } else {
352        rep = AppendLeaf(rep, child_arg, offset, len);
353      }
354    });
355    return rep;
356  }
357  CordRepRing* CordRepRing::AppendLeaf(CordRepRing* rep, CordRep* child,
358                                       size_t offset, size_t len) {
359    rep = Mutable(rep, 1);
360    index_type back = rep->tail_;
361    const pos_type begin_pos = rep->begin_pos_ + rep->length;
362    rep->tail_ = rep->advance(rep->tail_);
363    rep->length += len;
364    rep->entry_end_pos()[back] = begin_pos + len;
365    rep->entry_child()[back] = child;
366    rep->entry_data_offset()[back] = static_cast<offset_type>(offset);
367    return Validate(rep, nullptr, __LINE__);
368  }
369  CordRepRing* CordRepRing::Append(CordRepRing* rep, CordRep* child) {
370    size_t length = child->length;
371    if (IsFlatOrExternal(child)) {
372      return AppendLeaf(rep, child, 0, length);
373    }
374    if (child->IsRing()) {
375      return AddRing<AddMode::kAppend>(rep, child->ring(), 0, length);
376    }
377    return AppendSlow(rep, child);
378  }
379  CordRepRing* CordRepRing::PrependSlow(CordRepRing* rep, CordRep* child) {
380    ReverseConsume(child, [&](CordRep* child_arg, size_t offset, size_t len) {
381      if (IsFlatOrExternal(child_arg)) {
382        rep = PrependLeaf(rep, child_arg, offset, len);
383      } else {
384        rep = AddRing<AddMode::kPrepend>(rep, child_arg->ring(), offset, len);
385      }
386    });
387    return Validate(rep);
388  }
389  CordRepRing* CordRepRing::PrependLeaf(CordRepRing* rep, CordRep* child,
390                                        size_t offset, size_t len) {
391    rep = Mutable(rep, 1);
392    index_type head = rep->retreat(rep->head_);
393    pos_type end_pos = rep->begin_pos_;
394    rep->head_ = head;
395    rep->length += len;
396    rep->begin_pos_ -= len;
397    rep->entry_end_pos()[head] = end_pos;
398    rep->entry_child()[head] = child;
399    rep->entry_data_offset()[head] = static_cast<offset_type>(offset);
400    return Validate(rep);
401  }
402  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, CordRep* child) {
403    size_t length = child->length;
404    if (IsFlatOrExternal(child)) {
405      return PrependLeaf(rep, child, 0, length);
406    }
407    if (child->IsRing()) {
408      return AddRing<AddMode::kPrepend>(rep, child->ring(), 0, length);
409    }
410    return PrependSlow(rep, child);
411  }
412  CordRepRing* CordRepRing::Append(CordRepRing* rep, absl::string_view data,
413                                   size_t extra) {
414    if (rep->refcount.IsOne()) {
415      Span<char> avail = rep->GetAppendBuffer(data.length());
416      if (!avail.empty()) {
417        memcpy(avail.data(), data.data(), avail.length());
418        data.remove_prefix(avail.length());
419      }
420    }
421    if (data.empty()) return Validate(rep);
422    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
423    rep = Mutable(rep, flats);
424    Filler filler(rep, rep->tail_);
425    pos_type pos = rep->begin_pos_ + rep->length;
426    while (data.length() >= kMaxFlatLength) {
427      auto* flat = CreateFlat(data.data(), kMaxFlatLength);
428      filler.Add(flat, 0, pos += kMaxFlatLength);
429      data.remove_prefix(kMaxFlatLength);
430    }
431    if (data.length()) {
432      auto* flat = CreateFlat(data.data(), data.length(), extra);
433      filler.Add(flat, 0, pos += data.length());
434    }
435    rep->length = pos - rep->begin_pos_;
436    rep->tail_ = filler.pos();
437    return Validate(rep);
438  }
439  CordRepRing* CordRepRing::Prepend(CordRepRing* rep, absl::string_view data,
440                                    size_t extra) {
441    if (rep->refcount.IsOne()) {
442      Span<char> avail = rep->GetPrependBuffer(data.length());
443      if (!avail.empty()) {
444        const char* tail = data.data() + data.length() - avail.length();
445        memcpy(avail.data(), tail, avail.length());
446        data.remove_suffix(avail.length());
447      }
448    }
449    if (data.empty()) return rep;
450    const size_t flats = (data.length() - 1) / kMaxFlatLength + 1;
451    rep = Mutable(rep, flats);
452    pos_type pos = rep->begin_pos_;
453    Filler filler(rep, rep->retreat(rep->head_, static_cast<index_type>(flats)));
454    size_t first_size = data.size() - (flats - 1) * kMaxFlatLength;
455    CordRepFlat* flat = CordRepFlat::New(first_size + extra);
456    flat->length = first_size + extra;
457    memcpy(flat->Data() + extra, data.data(), first_size);
458    data.remove_prefix(first_size);
459    filler.Add(flat, extra, pos);
460    pos -= first_size;
461    while (!data.empty()) {
462      assert(data.size() >= kMaxFlatLength);
463      flat = CreateFlat(data.data(), kMaxFlatLength);
464      filler.Add(flat, 0, pos);
465      pos -= kMaxFlatLength;
466      data.remove_prefix(kMaxFlatLength);
467    }
468    rep->head_ = filler.head();
469    rep->length += rep->begin_pos_ - pos;
470    rep->begin_pos_ = pos;
471    return Validate(rep);
472  }
473  static constexpr index_type kBinarySearchThreshold = 32;
474  static constexpr index_type kBinarySearchEndCount = 8;
475  template <bool wrap>
476  CordRepRing::index_type CordRepRing::FindBinary(index_type head,
477                                                  index_type tail,
478                                                  size_t offset) const {
479    index_type count = tail + (wrap ? capacity_ : 0) - head;
480    do {
481      count = (count - 1) / 2;
482      assert(count < entries(head, tail_));
483      index_type mid = wrap ? advance(head, count) : head + count;
484      index_type after_mid = wrap ? advance(mid) : mid + 1;
485      bool larger = (offset >= entry_end_offset(mid));
486      head = larger ? after_mid : head;
487      tail = larger ? tail : mid;
488      assert(head != tail);
489    } while (ABSL_PREDICT_TRUE(count > kBinarySearchEndCount));
490    return head;
491  }
492  CordRepRing::Position CordRepRing::FindSlow(index_type head,
493                                              size_t offset) const {
494    index_type tail = tail_;
495    if (tail > head) {
496      index_type count = tail - head;
497      if (count > kBinarySearchThreshold) {
498        head = FindBinary<false>(head, tail, offset);
499      }
500    } else {
501      index_type count = capacity_ + tail - head;
502      if (count > kBinarySearchThreshold) {
503        head = FindBinary<true>(head, tail, offset);
504      }
505    }
506    pos_type pos = entry_begin_pos(head);
507    pos_type end_pos = entry_end_pos(head);
508    while (offset >= Distance(begin_pos_, end_pos)) {
509      head = advance(head);
510      pos = end_pos;
511      end_pos = entry_end_pos(head);
512    }
513    return {head, offset - Distance(begin_pos_, pos)};
514  }
515  CordRepRing::Position CordRepRing::FindTailSlow(index_type head,
516                                                  size_t offset) const {
517    index_type tail = tail_;
518    const size_t tail_offset = offset - 1;
519    if (tail > head) {
520      index_type count = tail - head;
521      if (count > kBinarySearchThreshold) {
522        head = FindBinary<false>(head, tail, tail_offset);
523      }
524    } else {
525      index_type count = capacity_ + tail - head;
526      if (count > kBinarySearchThreshold) {
527        head = FindBinary<true>(head, tail, tail_offset);
528      }
529    }
530    size_t end_offset = entry_end_offset(head);
531    while (tail_offset >= end_offset) {
532      head = advance(head);
533      end_offset = entry_end_offset(head);
534    }
535    return {advance(head), end_offset - offset};
536  }
537  char CordRepRing::GetCharacter(size_t offset) const {
538    assert(offset < length);
539    Position pos = Find(offset);
540    size_t data_offset = entry_data_offset(pos.index) + pos.offset;
541    return GetRepData(entry_child(pos.index))[data_offset];
542  }
543  CordRepRing* CordRepRing::SubRing(CordRepRing* rep, size_t offset,
544                                    size_t len, size_t extra) {
545    assert(offset <= rep->length);
546    assert(offset <= rep->length - len);
547    if (len == 0) {
548      CordRep::Unref(rep);
549      return nullptr;
550    }
551    Position head = rep->Find(offset);
552    Position tail = rep->FindTail(head.index, offset + len);
553    const size_t new_entries = rep->entries(head.index, tail.index);
554    if (rep->refcount.IsOne() && extra <= (rep->capacity() - new_entries)) {
555      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
556      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
557      rep->head_ = head.index;
558      rep->tail_ = tail.index;
559    } else {
560      rep = Copy(rep, head.index, tail.index, extra);
561      head.index = rep->head_;
562      tail.index = rep->tail_;
563    }
564    rep->length = len;
565    rep->begin_pos_ += offset;
566    if (head.offset) {
567      rep->AddDataOffset(head.index, head.offset);
568    }
569    if (tail.offset) {
570      rep->SubLength(rep->retreat(tail.index), tail.offset);
571    }
572    return Validate(rep);
573  }
574  CordRepRing* CordRepRing::RemovePrefix(CordRepRing* rep, size_t len,
575                                         size_t extra) {
576    assert(len <= rep->length);
577    if (len == rep->length) {
578      CordRep::Unref(rep);
579      return nullptr;
580    }
581    Position head = rep->Find(len);
582    if (rep->refcount.IsOne()) {
583      if (head.index != rep->head_) UnrefEntries(rep, rep->head_, head.index);
584      rep->head_ = head.index;
585    } else {
586      rep = Copy(rep, head.index, rep->tail_, extra);
587      head.index = rep->head_;
588    }
589    rep->length -= len;
590    rep->begin_pos_ += len;
591    if (head.offset) {
592      rep->AddDataOffset(head.index, head.offset);
593    }
594    return Validate(rep);
595  }
596  CordRepRing* CordRepRing::RemoveSuffix(CordRepRing* rep, size_t len,
597                                         size_t extra) {
598    assert(len <= rep->length);
599    if (len == rep->length) {
600      CordRep::Unref(rep);
601      return nullptr;
602    }
603    Position tail = rep->FindTail(rep->length - len);
604    if (rep->refcount.IsOne()) {
605      if (tail.index != rep->tail_) UnrefEntries(rep, tail.index, rep->tail_);
606      rep->tail_ = tail.index;
607    } else {
608      rep = Copy(rep, rep->head_, tail.index, extra);
609      tail.index = rep->tail_;
610    }
611    rep->length -= len;
612    if (tail.offset) {
613      rep->SubLength(rep->retreat(tail.index), tail.offset);
614    }
615    return Validate(rep);
616  }
617  }  
618  ABSL_NAMESPACE_END
619  }  
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</h3>
            <pre><code>1  #include "MMKV_IO.h"
2  #include "CodedInputData.h"
3  #include "CodedOutputData.h"
4  #include "InterProcessLock.h"
5  #include "MMBuffer.h"
6  #include "MMKVLog.h"
7  #include "MMKVMetaInfo.hpp"
8  #include "MemoryFile.h"
9  #include "MiniPBCoder.h"
10  #include "PBUtility.h"
11  #include "ScopedLock.hpp"
12  #include "ThreadLock.h"
13  #include "aes/AESCrypt.h"
14  #include "aes/openssl/openssl_aes.h"
15  #include "aes/openssl/openssl_md5.h"
16  #include "crc32/Checksum.h"
17  #include <algorithm>
18  #include <cassert>
19  #include <cstring>
20  #ifdef MMKV_IOS
21  #    include "MMKV_OSX.h"
22  #endif
23  #ifdef MMKV_APPLE
24  #    if __has_feature(objc_arc)
25  #        error This file must be compiled with MRC. Use -fno-objc-arc flag.
26  #    endif
27  #endif 
28  using namespace std;
29  using namespace mmkv;
30  using KVHolderRet_t = std::pair<bool, KeyValueHolder>;
31  constexpr uint32_t Fixed32Size = pbFixed32Size();
32  MMKV_NAMESPACE_BEGIN
33  void MMKV::loadFromFile() {
34      if (!m_metaFile->isFileValid()) {
35          m_metaFile->reloadFromFile();
36      }
37      if (!m_metaFile->isFileValid()) {
38          MMKVError("file [%s] not valid", m_metaFile->getPath().c_str());
39      } else {
40          m_metaInfo->read(m_metaFile->getMemory());
41      }
42  #ifndef MMKV_DISABLE_CRYPT
43      if (m_crypter) {
44          if (m_metaInfo->m_version >= MMKVVersionRandomIV) {
45              m_crypter->resetIV(m_metaInfo->m_vector, sizeof(m_metaInfo->m_vector));
46          }
47      }
48  #endif
49      if (!m_file->isFileValid()) {
50          m_file->reloadFromFile();
51      }
52      if (!m_file->isFileValid()) {
53          MMKVError("file [%s] not valid", m_path.c_str());
54      } else {
55          bool loadFromFile = false, needFullWriteback = false;
56          checkDataValid(loadFromFile, needFullWriteback);
57          MMKVInfo("loading [%s] with %zu actual size, file size %zu, InterProcess %d, meta info "
58                   "version:%u",
59                   m_mmapID.c_str(), m_actualSize, m_file->getFileSize(), m_isInterProcess, m_metaInfo->m_version);
60          auto ptr = (uint8_t *) m_file->getMemory();
61          if (loadFromFile && m_actualSize > 0) {
62              MMKVInfo("loading [%s] with crc %u sequence %u version %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
63                       m_metaInfo->m_sequence, m_metaInfo->m_version);
64              MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);
65              if (m_crypter) {
66                  clearDictionary(m_dicCrypt);
67              } else {
68                  clearDictionary(m_dic);
69              }
70              if (needFullWriteback) {
71  #ifndef MMKV_DISABLE_CRYPT
72                  if (m_crypter) {
73                      MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter);
74                  } else
75  #endif
76                  {
77                      MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);
78                  }
79              } else {
80  #ifndef MMKV_DISABLE_CRYPT
81                  if (m_crypter) {
82                      MiniPBCoder::decodeMap(*m_dicCrypt, inputBuffer, m_crypter);
83                  } else
84  #endif
85                  {
86                      MiniPBCoder::decodeMap(*m_dic, inputBuffer);
87                  }
88              }
89              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
90              m_output->seek(m_actualSize);
91              if (needFullWriteback) {
92                  fullWriteback();
93              }
94          } else {
95              SCOPED_LOCK(m_exclusiveProcessLock);
96              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
97              if (m_actualSize > 0) {
98                  writeActualSize(0, 0, nullptr, IncreaseSequence);
99                  sync(MMKV_SYNC);
100              } else {
101                  writeActualSize(0, 0, nullptr, KeepSequence);
102              }
103          }
104          auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
105          MMKVInfo("loaded [%s] with %zu key-values", m_mmapID.c_str(), count);
106      }
107      m_needLoadFromFile = false;
108  }
109  void MMKV::partialLoadFromFile() {
110      m_metaInfo->read(m_metaFile->getMemory());
111      size_t oldActualSize = m_actualSize;
112      m_actualSize = readActualSize();
113      auto fileSize = m_file->getFileSize();
114      MMKVDebug("loading [%s] with file size %zu, oldActualSize %zu, newActualSize %zu", m_mmapID.c_str(), fileSize,
115                oldActualSize, m_actualSize);
116      if (m_actualSize > 0) {
117          if (m_actualSize < fileSize && m_actualSize + Fixed32Size <= fileSize) {
118              if (m_actualSize > oldActualSize) {
119                  auto position = oldActualSize;
120                  size_t addedSize = m_actualSize - position;
121                  auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
122                  m_crcDigest = (uint32_t) CRC32(m_crcDigest, basePtr + position, addedSize);
123                  if (m_crcDigest == m_metaInfo->m_crcDigest) {
124                      MMBuffer inputBuffer(basePtr, m_actualSize, MMBufferNoCopy);
125  #ifndef MMKV_DISABLE_CRYPT
126                      if (m_crypter) {
127                          MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter, position);
128                      } else
129  #endif
130                      {
131                          MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer, position);
132                      }
133                      m_output->seek(addedSize);
134                      m_hasFullWriteback = false;
135                      auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
136                      MMKVDebug("partial loaded [%s] with %zu values", m_mmapID.c_str(), count);
137                      return;
138                  } else {
139                      MMKVError("m_crcDigest[%u] != m_metaInfo->m_crcDigest[%u]", m_crcDigest, m_metaInfo->m_crcDigest);
140                  }
141              }
142          }
143      }
144      clearMemoryCache();
145      loadFromFile();
146  }
147  void MMKV::checkDataValid(bool &loadFromFile, bool &needFullWriteback) {
148      auto fileSize = m_file->getFileSize();
149      auto checkLastConfirmedInfo = [&] {
150          if (m_metaInfo->m_version >= MMKVVersionActualSize) {
151              uint32_t oldStyleActualSize = 0;
152              memcpy(&oldStyleActualSize, m_file->getMemory(), Fixed32Size);
153              if (oldStyleActualSize != m_actualSize) {
154                  MMKVWarning("oldStyleActualSize %u not equal to meta actual size %lu", oldStyleActualSize,
155                              m_actualSize);
156                  if (oldStyleActualSize < fileSize && (oldStyleActualSize + Fixed32Size) <= fileSize) {
157                      if (checkFileCRCValid(oldStyleActualSize, m_metaInfo->m_crcDigest)) {
158                          MMKVInfo("looks like [%s] been downgrade & upgrade again", m_mmapID.c_str());
159                          loadFromFile = true;
160                          writeActualSize(oldStyleActualSize, m_metaInfo->m_crcDigest, nullptr, KeepSequence);
161                          return;
162                      }
163                  } else {
164                      MMKVWarning("oldStyleActualSize %u greater than file size %lu", oldStyleActualSize, fileSize);
165                  }
166              }
167              auto lastActualSize = m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize;
168              if (lastActualSize < fileSize && (lastActualSize + Fixed32Size) <= fileSize) {
169                  auto lastCRCDigest = m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest;
170                  if (checkFileCRCValid(lastActualSize, lastCRCDigest)) {
171                      loadFromFile = true;
172                      writeActualSize(lastActualSize, lastCRCDigest, nullptr, KeepSequence);
173                  } else {
174                      MMKVError("check [%s] error: lastActualSize %u, lastActualCRC %u", m_mmapID.c_str(), lastActualSize,
175                                lastCRCDigest);
176                  }
177              } else {
178                  MMKVError("check [%s] error: lastActualSize %u, file size is %u", m_mmapID.c_str(), lastActualSize,
179                            fileSize);
180              }
181          }
182      };
183      m_actualSize = readActualSize();
184      if (m_actualSize < fileSize && (m_actualSize + Fixed32Size) <= fileSize) {
185          if (checkFileCRCValid(m_actualSize, m_metaInfo->m_crcDigest)) {
186              loadFromFile = true;
187          } else {
188              checkLastConfirmedInfo();
189              if (!loadFromFile) {
190                  auto strategic = onMMKVCRCCheckFail(m_mmapID);
191                  if (strategic == OnErrorRecover) {
192                      loadFromFile = true;
193                      needFullWriteback = true;
194                  }
195                  MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
196              }
197          }
198      } else {
199          MMKVError("check [%s] error: %zu size in total, file size is %zu", m_mmapID.c_str(), m_actualSize, fileSize);
200          checkLastConfirmedInfo();
201          if (!loadFromFile) {
202              auto strategic = onMMKVFileLengthError(m_mmapID);
203              if (strategic == OnErrorRecover) {
204                  m_actualSize = fileSize - Fixed32Size;
205                  loadFromFile = true;
206                  needFullWriteback = true;
207              }
208              MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
209          }
210      }
211  }
212  void MMKV::checkLoadData() {
213      if (m_needLoadFromFile) {
214          SCOPED_LOCK(m_sharedProcessLock);
215          m_needLoadFromFile = false;
216          loadFromFile();
217          return;
218      }
219      if (!m_isInterProcess) {
220          return;
221      }
222      if (!m_metaFile->isFileValid()) {
223          return;
224      }
225      SCOPED_LOCK(m_sharedProcessLock);
226      MMKVMetaInfo metaInfo;
227      metaInfo.read(m_metaFile->getMemory());
228      if (m_metaInfo->m_sequence != metaInfo.m_sequence) {
229          MMKVInfo("[%s] oldSeq %u, newSeq %u", m_mmapID.c_str(), m_metaInfo->m_sequence, metaInfo.m_sequence);
230          SCOPED_LOCK(m_sharedProcessLock);
231          clearMemoryCache();
232          loadFromFile();
233          notifyContentChanged();
234      } else if (m_metaInfo->m_crcDigest != metaInfo.m_crcDigest) {
235          MMKVDebug("[%s] oldCrc %u, newCrc %u, new actualSize %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
236                    metaInfo.m_crcDigest, metaInfo.m_actualSize);
237          SCOPED_LOCK(m_sharedProcessLock);
238          size_t fileSize = m_file->getActualFileSize();
239          if (m_file->getFileSize() != fileSize) {
240              MMKVInfo("file size has changed [%s] from %zu to %zu", m_mmapID.c_str(), m_file->getFileSize(), fileSize);
241              clearMemoryCache();
242              loadFromFile();
243          } else {
244              partialLoadFromFile();
245          }
246          notifyContentChanged();
247      }
248  }
249  constexpr uint32_t ItemSizeHolder = 0x00ffffff;
250  constexpr uint32_t ItemSizeHolderSize = 4;
251  static pair<MMBuffer, size_t> prepareEncode(const MMKVMap &dic) {
252      size_t totalSize = ItemSizeHolderSize;
253      for (auto &itr : dic) {
254          auto &kvHolder = itr.second;
255          totalSize += kvHolder.computedKVSize + kvHolder.valueSize;
256      }
257      return make_pair(MMBuffer(), totalSize);
258  }
259  #ifndef MMKV_DISABLE_CRYPT
260  static pair<MMBuffer, size_t> prepareEncode(const MMKVMapCrypt &dic) {
261      MMKVVector vec;
262      size_t totalSize = 0;
263      uint32_t smallestOffet = 5 + 1; 
264      for (auto &itr : dic) {
265          auto &kvHolder = itr.second;
266          if (kvHolder.type == KeyValueHolderType_Offset) {
267              totalSize += kvHolder.pbKeyValueSize + kvHolder.keySize + kvHolder.valueSize;
268              smallestOffet = min(smallestOffet, kvHolder.offset);
269          } else {
270              vec.emplace_back(itr.first, kvHolder.toMMBuffer(nullptr, nullptr));
271          }
272      }
273      if (smallestOffet > 5) {
274          smallestOffet = ItemSizeHolderSize;
275      }
276      totalSize += smallestOffet;
277      if (vec.empty()) {
278          return make_pair(MMBuffer(), totalSize);
279      }
280      auto buffer = MiniPBCoder::encodeDataWithObject(vec);
281      auto sizeOfMap = CodedInputData(buffer.getPtr(), buffer.length()).readUInt32();
282      totalSize += sizeOfMap;
283      return make_pair(move(buffer), totalSize);
284  }
285  #endif
286  bool MMKV::ensureMemorySize(size_t newSize) {
287      if (!isFileValid()) {
288          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
289          return false;
290      }
291      if (newSize >= m_output->spaceLeft() || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {
292          auto fileSize = m_file->getFileSize();
293          auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
294          auto sizeOfDic = preparedData.second;
295          size_t lenNeeded = sizeOfDic + Fixed32Size + newSize;
296          size_t dicCount = m_crypter ? m_dicCrypt->size() : m_dic->size();
297          size_t avgItemSize = lenNeeded / std::max<size_t>(1, dicCount);
298          size_t futureUsage = avgItemSize * std::max<size_t>(8, (dicCount + 1) / 2);
299          if (lenNeeded >= fileSize || (lenNeeded + futureUsage) >= fileSize) {
300              size_t oldSize = fileSize;
301              do {
302                  fileSize *= 2;
303              } while (lenNeeded + futureUsage >= fileSize);
304              MMKVInfo("extending [%s] file size from %zu to %zu, incoming size:%zu, future usage:%zu", m_mmapID.c_str(),
305                       oldSize, fileSize, newSize, futureUsage);
306              if (!m_file->truncate(fileSize)) {
307                  return false;
308              }
309              if (!isFileValid()) {
310                  MMKVWarning("[%s] file not valid", m_mmapID.c_str());
311                  return false;
312              }
313          }
314          return doFullWriteBack(move(preparedData), nullptr);
315      }
316      return true;
317  }
318  size_t MMKV::readActualSize() {
319      MMKV_ASSERT(m_file->getMemory());
320      MMKV_ASSERT(m_metaFile->isFileValid());
321      uint32_t actualSize = 0;
322      memcpy(&actualSize, m_file->getMemory(), Fixed32Size);
323      if (m_metaInfo->m_version >= MMKVVersionActualSize) {
324          if (m_metaInfo->m_actualSize != actualSize) {
325              MMKVWarning("[%s] actual size %u, meta actual size %u", m_mmapID.c_str(), actualSize,
326                          m_metaInfo->m_actualSize);
327          }
328          return m_metaInfo->m_actualSize;
329      } else {
330          return actualSize;
331      }
332  }
333  void MMKV::oldStyleWriteActualSize(size_t actualSize) {
334      MMKV_ASSERT(m_file->getMemory());
335      m_actualSize = actualSize;
336  #ifdef MMKV_IOS
337      auto ret = guardForBackgroundWriting(m_file->getMemory(), Fixed32Size);
338      if (!ret.first) {
339          return;
340      }
341  #endif
342      memcpy(m_file->getMemory(), &actualSize, Fixed32Size);
343  }
344  bool MMKV::writeActualSize(size_t size, uint32_t crcDigest, const void *iv, bool increaseSequence) {
345      oldStyleWriteActualSize(size);
346      if (!m_metaFile->isFileValid()) {
347          return false;
348      }
349      bool needsFullWrite = false;
350      m_actualSize = size;
351      m_metaInfo->m_actualSize = static_cast<uint32_t>(size);
352      m_crcDigest = crcDigest;
353      m_metaInfo->m_crcDigest = crcDigest;
354      if (m_metaInfo->m_version < MMKVVersionSequence) {
355          m_metaInfo->m_version = MMKVVersionSequence;
356          needsFullWrite = true;
357      }
358  #ifndef MMKV_DISABLE_CRYPT
359      if (unlikely(iv)) {
360          memcpy(m_metaInfo->m_vector, iv, sizeof(m_metaInfo->m_vector));
361          if (m_metaInfo->m_version < MMKVVersionRandomIV) {
362              m_metaInfo->m_version = MMKVVersionRandomIV;
363          }
364          needsFullWrite = true;
365      }
366  #endif
367      if (unlikely(increaseSequence)) {
368          m_metaInfo->m_sequence++;
369          m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize = static_cast<uint32_t>(size);
370          m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest = crcDigest;
371          if (m_metaInfo->m_version < MMKVVersionActualSize) {
372              m_metaInfo->m_version = MMKVVersionActualSize;
373          }
374          needsFullWrite = true;
375          MMKVInfo("[%s] increase sequence to %u, crc %u, actualSize %u", m_mmapID.c_str(), m_metaInfo->m_sequence,
376                   m_metaInfo->m_crcDigest, m_metaInfo->m_actualSize);
377      }
378  #ifdef MMKV_IOS
379      auto ret = guardForBackgroundWriting(m_metaFile->getMemory(), sizeof(MMKVMetaInfo));
380      if (!ret.first) {
381          return false;
382      }
383  #endif
384      if (unlikely(needsFullWrite)) {
385          m_metaInfo->write(m_metaFile->getMemory());
386      } else {
387          m_metaInfo->writeCRCAndActualSizeOnly(m_metaFile->getMemory());
388      }
389      return true;
390  }
391  MMBuffer MMKV::getDataForKey(MMKVKey_t key) {
392      checkLoadData();
393  #ifndef MMKV_DISABLE_CRYPT
394      if (m_crypter) {
395          auto itr = m_dicCrypt->find(key);
396          if (itr != m_dicCrypt->end()) {
397              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
398              return itr->second.toMMBuffer(basePtr, m_crypter);
399          }
400      } else
401  #endif
402      {
403          auto itr = m_dic->find(key);
404          if (itr != m_dic->end()) {
405              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
406              return itr->second.toMMBuffer(basePtr);
407          }
408      }
409      MMBuffer nan;
410      return nan;
411  }
412  #ifndef MMKV_DISABLE_CRYPT
413  #    if defined(TARGET_OS_SIMULATOR) && defined(TARGET_CPU_X86)
414  static AESCryptStatus t_status;
415  #    else
416  thread_local AESCryptStatus t_status;
417  #    endif
418  #endif 
419  bool MMKV::setDataForKey(MMBuffer &&data, MMKVKey_t key, bool isDataHolder) {
420      if ((!isDataHolder && data.length() == 0) || isKeyEmpty(key)) {
421          return false;
422      }
423      SCOPED_LOCK(m_lock);
424      SCOPED_LOCK(m_exclusiveProcessLock);
425      checkLoadData();
426  #ifndef MMKV_DISABLE_CRYPT
427      if (m_crypter) {
428          if (isDataHolder) {
429              auto sizeNeededForData = pbRawVarint32Size((uint32_t) data.length()) + data.length();
430              if (!KeyValueHolderCrypt::isValueStoredAsOffset(sizeNeededForData)) {
431                  data = MiniPBCoder::encodeDataWithObject(data);
432                  isDataHolder = false;
433              }
434          }
435          auto itr = m_dicCrypt->find(key);
436          if (itr != m_dicCrypt->end()) {
437  #    ifdef MMKV_APPLE
438              auto ret = appendDataWithKey(data, key, itr->second, isDataHolder);
439  #    else
440              auto ret = appendDataWithKey(data, key, isDataHolder);
441  #    endif
442              if (!ret.first) {
443                  return false;
444              }
445              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
446                  KeyValueHolderCrypt kvHolder(ret.second.keySize, ret.second.valueSize, ret.second.offset);
447                  memcpy(&kvHolder.cryptStatus, &t_status, sizeof(t_status));
448                  itr->second = move(kvHolder);
449              } else {
450                  itr->second = KeyValueHolderCrypt(move(data));
451              }
452          } else {
453              auto ret = appendDataWithKey(data, key, isDataHolder);
454              if (!ret.first) {
455                  return false;
456              }
457              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
458                  auto r = m_dicCrypt->emplace(
459                      key, KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset));
460                  if (r.second) {
461                      memcpy(&(r.first->second.cryptStatus), &t_status, sizeof(t_status));
462                  }
463              } else {
464                  m_dicCrypt->emplace(key, KeyValueHolderCrypt(move(data)));
465              }
466          }
467      } else
468  #endif 
469      {
470          auto itr = m_dic->find(key);
471          if (itr != m_dic->end()) {
472              auto ret = appendDataWithKey(data, itr->second, isDataHolder);
473              if (!ret.first) {
474                  return false;
475              }
476              itr->second = std::move(ret.second);
477          } else {
478              auto ret = appendDataWithKey(data, key, isDataHolder);
479              if (!ret.first) {
480                  return false;
481              }
482              m_dic->emplace(key, std::move(ret.second));
483          }
484      }
485      m_hasFullWriteback = false;
486  #ifdef MMKV_APPLE
487      [key retain];
488  #endif
489      return true;
490  }
491  bool MMKV::removeDataForKey(MMKVKey_t key) {
492      if (isKeyEmpty(key)) {
493          return false;
494      }
495  #ifndef MMKV_DISABLE_CRYPT
496      if (m_crypter) {
497          auto itr = m_dicCrypt->find(key);
498          if (itr != m_dicCrypt->end()) {
499              m_hasFullWriteback = false;
500              static MMBuffer nan;
501  #    ifdef MMKV_APPLE
502              auto ret = appendDataWithKey(nan, key, itr->second);
503              if (ret.first) {
504                  auto oldKey = itr->first;
505                  m_dicCrypt->erase(itr);
506                  [oldKey release];
507              }
508  #    else
509              auto ret = appendDataWithKey(nan, key);
510              if (ret.first) {
511                  m_dicCrypt->erase(itr);
512              }
513  #    endif
514              return ret.first;
515          }
516      } else
517  #endif 
518      {
519          auto itr = m_dic->find(key);
520          if (itr != m_dic->end()) {
521              m_hasFullWriteback = false;
522              static MMBuffer nan;
523              auto ret = appendDataWithKey(nan, itr->second);
524              if (ret.first) {
525  #ifdef MMKV_APPLE
526                  auto oldKey = itr->first;
527                  m_dic->erase(itr);
528                  [oldKey release];
529  #else
530                  m_dic->erase(itr);
531  #endif
532              }
533              return ret.first;
534          }
535      }
536      return false;
537  }
538  KVHolderRet_t
539  MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
540      auto isKeyEncoded = (originKeyLength < keyData.length());
541      auto keyLength = static_cast<uint32_t>(keyData.length());
542      auto valueLength = static_cast<uint32_t>(data.length());
543      if (isDataHolder) {
544          valueLength += pbRawVarint32Size(valueLength);
545      }
546      size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
547      size += valueLength + pbRawVarint32Size(valueLength);
548      SCOPED_LOCK(m_exclusiveProcessLock);
549      bool hasEnoughSize = ensureMemorySize(size);
550      if (!hasEnoughSize || !isFileValid()) {
551          return make_pair(false, KeyValueHolder());
552      }
553  #ifdef MMKV_IOS
554      auto ret = guardForBackgroundWriting(m_output->curWritePointer(), size);
555      if (!ret.first) {
556          return make_pair(false, KeyValueHolder());
557      }
558  #endif
559  #ifndef MMKV_DISABLE_CRYPT
560      if (m_crypter) {
561          if (KeyValueHolderCrypt::isValueStoredAsOffset(valueLength)) {
562              m_crypter->getCurStatus(t_status);
563          }
564      }
565  #endif
566      try {
567          if (isKeyEncoded) {
568              m_output->writeRawData(keyData);
569          } else {
570              m_output->writeData(keyData);
571          }
572          if (isDataHolder) {
573              m_output->writeRawVarint32((int32_t) valueLength);
574          }
575          m_output->writeData(data); 
576      } catch (std::exception &e) {
577          MMKVError("%s", e.what());
578          return make_pair(false, KeyValueHolder());
579      }
580      auto offset = static_cast<uint32_t>(m_actualSize);
581      auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
582  #ifndef MMKV_DISABLE_CRYPT
583      if (m_crypter) {
584          m_crypter->encrypt(ptr, ptr, size);
585      }
586  #endif
587      m_actualSize += size;
588      updateCRCDigest(ptr, size);
589      return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
590  }
591  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, MMKVKey_t key, bool isDataHolder) {
592  #ifdef MMKV_APPLE
593      auto oData = [key dataUsingEncoding:NSUTF8StringEncoding];
594      auto keyData = MMBuffer(oData, MMBufferNoCopy);
595  #else
596      auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy);
597  #endif
598      return doAppendDataWithKey(data, keyData, isDataHolder, static_cast<uint32_t>(keyData.length()));
599  }
600  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, const KeyValueHolder &kvHolder, bool isDataHolder) {
601      SCOPED_LOCK(m_exclusiveProcessLock);
602      uint32_t keyLength = kvHolder.keySize;
603      size_t rawKeySize = keyLength + pbRawVarint32Size(keyLength);
604      {
605          auto valueLength = static_cast<uint32_t>(data.length());
606          if (isDataHolder) {
607              valueLength += pbRawVarint32Size(valueLength);
608          }
609          auto size = rawKeySize + valueLength + pbRawVarint32Size(valueLength);
610          bool hasEnoughSize = ensureMemorySize(size);
611          if (!hasEnoughSize) {
612              return make_pair(false, KeyValueHolder());
613          }
614      }
615      auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
616      MMBuffer keyData(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy);
617      return doAppendDataWithKey(data, keyData, isDataHolder, keyLength);
618  }
619  bool MMKV::fullWriteback(AESCrypt *newCrypter) {
620      if (m_hasFullWriteback) {
621          return true;
622      }
623      if (m_needLoadFromFile) {
624          return true;
625      }
626      if (!isFileValid()) {
627          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
628          return false;
629      }
630      if (m_crypter ? m_dicCrypt->empty() : m_dic->empty()) {
631          clearAll();
632          return true;
633      }
634      auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
635      auto sizeOfDic = preparedData.second;
636      SCOPED_LOCK(m_exclusiveProcessLock);
637      if (sizeOfDic > 0) {
638          auto fileSize = m_file->getFileSize();
639          if (sizeOfDic + Fixed32Size <= fileSize) {
640              return doFullWriteBack(move(preparedData), newCrypter);
641          } else {
642              assert(0);
643              assert(newCrypter == nullptr);
644              return ensureMemorySize(sizeOfDic + Fixed32Size - fileSize);
645          }
646      }
647      return false;
648  }
649  static void
650  memmoveDictionary(MMKVMap &dic, CodedOutputData *output, uint8_t *ptr, AESCrypt *encrypter, size_t totalSize) {
651      auto originOutputPtr = output->curWritePointer();
652      auto writePtr = originOutputPtr + ItemSizeHolderSize;
653      if (!dic.empty()) {
654          vector<KeyValueHolder *> vec;
655          vec.reserve(dic.size());
656          for (auto &itr : dic) {
657              vec.push_back(&itr.second);
658          }
659          sort(vec.begin(), vec.end(), [](const auto &left, const auto &right) { return left->offset < right->offset; });
660          vector<pair<uint32_t, uint32_t>> dataSections; 
661          dataSections.emplace_back(vec.front()->offset, vec.front()->computedKVSize + vec.front()->valueSize);
662          for (size_t index = 1, total = vec.size(); index < total; index++) {
663              auto kvHolder = vec[index];
664              auto &lastSection = dataSections.back();
665              if (kvHolder->offset == lastSection.first + lastSection.second) {
666                  lastSection.second += kvHolder->computedKVSize + kvHolder->valueSize;
667              } else {
668                  dataSections.emplace_back(kvHolder->offset, kvHolder->computedKVSize + kvHolder->valueSize);
669              }
670          }
671          auto basePtr = ptr + Fixed32Size;
672          for (auto &section : dataSections) {
673              memmove(writePtr, basePtr + section.first, section.second);
674              writePtr += section.second;
675          }
676          if (!encrypter) {
677              auto offset = ItemSizeHolderSize;
678              for (auto kvHolder : vec) {
679                  kvHolder->offset = offset;
680                  offset += kvHolder->computedKVSize + kvHolder->valueSize;
681              }
682          }
683      }
684      output->writeRawVarint32(ItemSizeHolder);
685      auto writtenSize = static_cast<size_t>(writePtr - originOutputPtr);
686  #ifndef MMKV_DISABLE_CRYPT
687      if (encrypter) {
688          encrypter->encrypt(originOutputPtr, originOutputPtr, writtenSize);
689      }
690  #endif
691      assert(writtenSize == totalSize);
692      output->seek(writtenSize - ItemSizeHolderSize);
693  }
694  #ifndef MMKV_DISABLE_CRYPT
695  static void memmoveDictionary(MMKVMapCrypt &dic,
696                                CodedOutputData *output,
697                                uint8_t *ptr,
698                                AESCrypt *decrypter,
699                                AESCrypt *encrypter,
700                                pair<MMBuffer, size_t> &preparedData) {
701      vector<KeyValueHolderCrypt *> vec;
702      if (!dic.empty()) {
703          vec.reserve(dic.size());
704          for (auto &itr : dic) {
705              if (itr.second.type == KeyValueHolderType_Offset) {
706                  vec.push_back(&itr.second);
707              }
708          }
709          sort(vec.begin(), vec.end(), [](auto left, auto right) { return left->offset < right->offset; });
710      }
711      auto sizeHolder = ItemSizeHolder, sizeHolderSize = ItemSizeHolderSize;
712      if (!vec.empty()) {
713          auto smallestOffset = vec.front()->offset;
714          if (smallestOffset != ItemSizeHolderSize && smallestOffset <= 5) {
715              sizeHolderSize = smallestOffset;
716              assert(sizeHolderSize != 0);
717              static const uint32_t ItemSizeHolders[] = {0, 0x0f, 0xff, 0xffff, 0xffffff, 0xffffffff};
718              sizeHolder = ItemSizeHolders[sizeHolderSize];
719          }
720      }
721      output->writeRawVarint32(static_cast<int32_t>(sizeHolder));
722      auto writePtr = output->curWritePointer();
723      if (encrypter) {
724          encrypter->encrypt(writePtr - sizeHolderSize, writePtr - sizeHolderSize, sizeHolderSize);
725      }
726      if (!vec.empty()) {
727          vector<tuple<uint32_t, uint32_t, AESCryptStatus *>> dataSections; 
728          dataSections.push_back(vec.front()->toTuple());
729          for (size_t index = 1, total = vec.size(); index < total; index++) {
730              auto kvHolder = vec[index];
731              auto &lastSection = dataSections.back();
732              if (kvHolder->offset == get<0>(lastSection) + get<1>(lastSection)) {
733                  get<1>(lastSection) += kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
734              } else {
735                  dataSections.push_back(kvHolder->toTuple());
736              }
737          }
738          auto basePtr = ptr + Fixed32Size;
739          for (auto &section : dataSections) {
740              auto crypter = decrypter->cloneWithStatus(*get<2>(section));
741              crypter.decrypt(basePtr + get<0>(section), writePtr, get<1>(section));
742              writePtr += get<1>(section);
743          }
744          if (encrypter) {
745              auto offset = sizeHolderSize;
746              for (auto kvHolder : vec) {
747                  kvHolder->offset = offset;
748                  auto size = kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
749                  encrypter->getCurStatus(kvHolder->cryptStatus);
750                  encrypter->encrypt(basePtr + offset, basePtr + offset, size);
751                  offset += size;
752              }
753          }
754      }
755      auto &data = preparedData.first;
756      if (data.length() > 0) {
757          auto dataSize = CodedInputData(data.getPtr(), data.length()).readUInt32();
758          if (dataSize > 0) {
759              auto dataPtr = (uint8_t *) data.getPtr() + pbRawVarint32Size(dataSize);
760              if (encrypter) {
761                  encrypter->encrypt(dataPtr, writePtr, dataSize);
762              } else {
763                  memcpy(writePtr, dataPtr, dataSize);
764              }
765              writePtr += dataSize;
766          }
767      }
768      auto writtenSize = static_cast<size_t>(writePtr - output->curWritePointer());
769      assert(writtenSize + sizeHolderSize == preparedData.second);
770      output->seek(writtenSize);
771  }
772  #    define InvalidCryptPtr ((AESCrypt *) (void *) (1))
773  #endif 
774  bool MMKV::doFullWriteBack(pair<MMBuffer, size_t> preparedData, AESCrypt *newCrypter) {
775      auto ptr = (uint8_t *) m_file->getMemory();
776      auto totalSize = preparedData.second;
777  #ifdef MMKV_IOS
778      auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);
779      if (!ret.first) {
780          return false;
781      }
782  #endif
783  #ifndef MMKV_DISABLE_CRYPT
784      uint8_t newIV[AES_KEY_LEN];
785      auto decrypter = m_crypter;
786      auto encrypter = (newCrypter == InvalidCryptPtr) ? nullptr : (newCrypter ? newCrypter : m_crypter);
787      if (encrypter) {
788          AESCrypt::fillRandomIV(newIV);
789          encrypter->resetIV(newIV, sizeof(newIV));
790      }
791  #endif
792      delete m_output;
793      m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
794  #ifndef MMKV_DISABLE_CRYPT
795      if (m_crypter) {
796          memmoveDictionary(*m_dicCrypt, m_output, ptr, decrypter, encrypter, preparedData);
797      } else {
798  #else
799      {
800          auto encrypter = m_crypter;
801  #endif
802          memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);
803      }
804      m_actualSize = totalSize;
805  #ifndef MMKV_DISABLE_CRYPT
806      if (encrypter) {
807          recaculateCRCDigestWithIV(newIV);
808      } else
809  #endif
810      {
811          recaculateCRCDigestWithIV(nullptr);
812      }
813      m_hasFullWriteback = true;
814      sync(MMKV_SYNC);
815      return true;
816  }
817  #ifndef MMKV_DISABLE_CRYPT
818  bool MMKV::reKey(const string &cryptKey) {
819      SCOPED_LOCK(m_lock);
820      checkLoadData();
821      bool ret = false;
822      if (m_crypter) {
823          if (cryptKey.length() > 0) {
824              string oldKey = this->cryptKey();
825              if (cryptKey == oldKey) {
826                  return true;
827              } else {
828                  MMKVInfo("reKey with new aes key");
829                  auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
830                  m_hasFullWriteback = false;
831                  ret = fullWriteback(newCrypt);
832                  if (ret) {
833                      delete m_crypter;
834                      m_crypter = newCrypt;
835                  } else {
836                      delete newCrypt;
837                  }
838              }
839          } else {
840              MMKVInfo("reKey to no aes key");
841              m_hasFullWriteback = false;
842              ret = fullWriteback(InvalidCryptPtr);
843              if (ret) {
844                  delete m_crypter;
845                  m_crypter = nullptr;
846                  if (!m_dic) {
847                      m_dic = new MMKVMap();
848                  }
849              }
850          }
851      } else {
852          if (cryptKey.length() > 0) {
853              MMKVInfo("reKey to a aes key");
854              m_hasFullWriteback = false;
855              auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
856              ret = fullWriteback(newCrypt);
857              if (ret) {
858                  m_crypter = newCrypt;
859                  if (!m_dicCrypt) {
860                      m_dicCrypt = new MMKVMapCrypt();
861                  }
862              } else {
863                  delete newCrypt;
864              }
865          } else {
866              return true;
867          }
868      }
869      if (ret) {
870          clearMemoryCache();
871      }
872      return ret;
873  }
874  #endif
875  void MMKV::trim() {
876      SCOPED_LOCK(m_lock);
877      MMKVInfo("prepare to trim %s", m_mmapID.c_str());
878      checkLoadData();
879      if (m_actualSize == 0) {
880          clearAll();
881          return;
882      } else if (m_file->getFileSize() <= DEFAULT_MMAP_SIZE) {
883          return;
884      }
885      SCOPED_LOCK(m_exclusiveProcessLock);
886      fullWriteback();
887      auto oldSize = m_file->getFileSize();
888      auto fileSize = oldSize;
889      while (fileSize > (m_actualSize + Fixed32Size) * 2) {
890          fileSize /= 2;
891      }
892      fileSize = std::max<size_t>(fileSize, DEFAULT_MMAP_SIZE);
893      if (oldSize == fileSize) {
894          MMKVInfo("there's no need to trim %s with size %zu, actualSize %zu", m_mmapID.c_str(), fileSize, m_actualSize);
895          return;
896      }
897      MMKVInfo("trimming %s from %zu to %zu, actualSize %zu", m_mmapID.c_str(), oldSize, fileSize, m_actualSize);
898      if (!m_file->truncate(fileSize)) {
899          return;
900      }
901      fileSize = m_file->getFileSize();
902      auto ptr = (uint8_t *) m_file->getMemory();
903      delete m_output;
904      m_output = new CodedOutputData(ptr + pbFixed32Size(), fileSize - Fixed32Size);
905      m_output->seek(m_actualSize);
906      MMKVInfo("finish trim %s from %zu to %zu", m_mmapID.c_str(), oldSize, fileSize);
907  }
908  void MMKV::clearAll() {
909      MMKVInfo("cleaning all key-values from [%s]", m_mmapID.c_str());
910      SCOPED_LOCK(m_lock);
911      SCOPED_LOCK(m_exclusiveProcessLock);
912      checkLoadData();
913      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
914          MMKVInfo("nothing to clear for [%s]", m_mmapID.c_str());
915          return;
916      }
917      m_file->truncate(DEFAULT_MMAP_SIZE);
918  #ifndef MMKV_DISABLE_CRYPT
919      uint8_t newIV[AES_KEY_LEN];
920      AESCrypt::fillRandomIV(newIV);
921      if (m_crypter) {
922          m_crypter->resetIV(newIV, sizeof(newIV));
923      }
924      writeActualSize(0, 0, newIV, IncreaseSequence);
925  #else
926      writeActualSize(0, 0, nullptr, IncreaseSequence);
927  #endif
928      m_metaFile->msync(MMKV_SYNC);
929      clearMemoryCache();
930      loadFromFile();
931  }
932  bool MMKV::isFileValid(const string &mmapID, MMKVPath_t *relatePath) {
<span onclick='openModal()' class='match'>933      MMKVPath_t kvPath = mappedKVPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
934      if (!isFileExist(kvPath)) {
935          return true;
936      }
937      MMKVPath_t crcPath = crcPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
938      if (!isFileExist(crcPath)) {
939          return false;
940      }
</span>941      uint32_t crcFile = 0;
942      MMBuffer *data = readWholeFile(crcPath);
943      if (data) {
944          if (data->getPtr()) {
945              MMKVMetaInfo metaInfo;
946              metaInfo.read(data->getPtr());
947              crcFile = metaInfo.m_crcDigest;
948          }
949          delete data;
950      } else {
951          return false;
952      }
953      uint32_t crcDigest = 0;
954      MMBuffer *fileData = readWholeFile(kvPath);
955      if (fileData) {
956          if (fileData->getPtr() && (fileData->length() >= Fixed32Size)) {
957              uint32_t actualSize = 0;
958              memcpy(&actualSize, fileData->getPtr(), Fixed32Size);
959              if (actualSize > (fileData->length() - Fixed32Size)) {
960                  delete fileData;
961                  return false;
962              }
963              crcDigest = (uint32_t) CRC32(0, (const uint8_t *) fileData->getPtr() + Fixed32Size, (uint32_t) actualSize);
964          }
965          delete fileData;
966          return crcFile == crcDigest;
967      } else {
968          return false;
969      }
970  }
971  MMKV_NAMESPACE_END
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_ring.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</div>
                <div class="column column_space"><pre><code>116      size_t entry_length = Distance(begin_pos, end_pos);
117      if (entry_length == 0) {
118        output << "entry[" << head << "] has an invalid length " << entry_length
119               << " from begin_pos " << begin_pos << " and end_pos " << end_pos;
120        return false;
121      }
122      CordRep* child = entry_child(head);
123      if (child == nullptr) {
124        output << "entry[" << head << "].child == nullptr";
125        return false;
126      }
</pre></code></div>
                <div class="column column_space"><pre><code>933      MMKVPath_t kvPath = mappedKVPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
934      if (!isFileExist(kvPath)) {
935          return true;
936      }
937      MMKVPath_t crcPath = crcPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
938      if (!isFileExist(crcPath)) {
939          return false;
940      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    