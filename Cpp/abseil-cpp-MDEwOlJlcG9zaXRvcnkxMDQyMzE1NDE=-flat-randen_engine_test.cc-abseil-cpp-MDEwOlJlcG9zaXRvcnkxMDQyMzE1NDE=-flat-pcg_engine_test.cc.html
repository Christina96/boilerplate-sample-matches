
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-randen_engine_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/randen_engine.h"
2  #include <algorithm>
3  #include <bitset>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/log/log.h"
9  #include "absl/random/internal/explicit_seed_seq.h"
10  #include "absl/strings/str_cat.h"
11  #include "absl/time/clock.h"
12  #define UPDATE_GOLDEN 0
13  using randen_u64 = absl::random_internal::randen_engine<uint64_t>;
14  using randen_u32 = absl::random_internal::randen_engine<uint32_t>;
15  using absl::random_internal::ExplicitSeedSeq;
16  namespace {
17  template <typename UIntType>
18  class RandenEngineTypedTest : public ::testing::Test {};
19  using UIntTypes = ::testing::Types<uint8_t, uint16_t, uint32_t, uint64_t>;
20  TYPED_TEST_SUITE(RandenEngineTypedTest, UIntTypes);
21  TYPED_TEST(RandenEngineTypedTest, VerifyReseedChangesAllValues) {
22    using randen = typename absl::random_internal::randen_engine<TypeParam>;
23    using result_type = typename randen::result_type;
24    const size_t kNumOutputs = (sizeof(randen) * 2 / sizeof(TypeParam)) + 1;
25    randen engine;
26    {
27      std::seed_seq seq1{1, 2, 3, 4, 5, 6, 7};
28      engine.seed(seq1);
29    }
30    result_type a[kNumOutputs];
31    std::generate(std::begin(a), std::end(a), std::ref(engine));
32    {
33      std::random_device rd;
34      std::seed_seq seq2{rd(), rd(), rd()};
35      engine.seed(seq2);
36    }
37    result_type b[kNumOutputs];
38    std::generate(std::begin(b), std::end(b), std::ref(engine));
39    size_t changed_bits = 0;
40    size_t unchanged_bits = 0;
41    size_t total_set = 0;
42    size_t total_bits = 0;
43    size_t equal_count = 0;
44    for (size_t i = 0; i < kNumOutputs; ++i) {
45      equal_count += (a[i] == b[i]) ? 1 : 0;
46      std::bitset<sizeof(result_type) * 8> bitset(a[i] ^ b[i]);
47      changed_bits += bitset.count();
48      unchanged_bits += bitset.size() - bitset.count();
49      std::bitset<sizeof(result_type) * 8> a_set(a[i]);
50      std::bitset<sizeof(result_type) * 8> b_set(b[i]);
51      total_set += a_set.count() + b_set.count();
52      total_bits += 2 * 8 * sizeof(result_type);
53    }
54    EXPECT_LE(changed_bits, 0.60 * (changed_bits + unchanged_bits));
55    EXPECT_GE(changed_bits, 0.40 * (changed_bits + unchanged_bits));
56    EXPECT_NEAR(total_set, total_bits * 0.5, 4 * std::sqrt(total_bits))
57        << "@" << total_set / static_cast<double>(total_bits);
58    const double kExpected = kNumOutputs / (1.0 * sizeof(result_type) * 8);
59    EXPECT_LE(equal_count, 1.0 + kExpected);
60  }
61  constexpr size_t kTwoBufferValues = sizeof(randen_u64) / sizeof(uint16_t) + 1;
62  TYPED_TEST(RandenEngineTypedTest, VerifyDiscard) {
63    using randen = typename absl::random_internal::randen_engine<TypeParam>;
64    for (size_t num_used = 0; num_used < kTwoBufferValues; ++num_used) {
65      randen engine_used;
66      for (size_t i = 0; i < num_used; ++i) {
67        engine_used();
68      }
69      for (size_t num_discard = 0; num_discard < kTwoBufferValues;
70           ++num_discard) {
71        randen engine1 = engine_used;
72        randen engine2 = engine_used;
73        for (size_t i = 0; i < num_discard; ++i) {
74          engine1();
75        }
76        engine2.discard(num_discard);
77        for (size_t i = 0; i < kTwoBufferValues; ++i) {
78          const auto r1 = engine1();
79          const auto r2 = engine2();
80          ASSERT_EQ(r1, r2) << "used=" << num_used << " discard=" << num_discard;
81        }
82      }
83    }
84  }
85  TYPED_TEST(RandenEngineTypedTest, StreamOperatorsResult) {
86    using randen = typename absl::random_internal::randen_engine<TypeParam>;
87    std::wostringstream os;
88    std::wistringstream is;
89    randen engine;
90    EXPECT_EQ(&(os << engine), &os);
91    EXPECT_EQ(&(is >> engine), &is);
92  }
93  TYPED_TEST(RandenEngineTypedTest, StreamSerialization) {
94    using randen = typename absl::random_internal::randen_engine<TypeParam>;
95    for (size_t discard = 0; discard < kTwoBufferValues; ++discard) {
96      ExplicitSeedSeq seed_sequence{12, 34, 56};
97      randen engine(seed_sequence);
98      engine.discard(discard);
99      std::stringstream stream;
100      stream << engine;
101      randen new_engine;
102      stream >> new_engine;
103      for (size_t i = 0; i < 64; ++i) {
104        EXPECT_EQ(engine(), new_engine()) << " " << i;
105      }
106    }
107  }
108  constexpr size_t kNumGoldenOutputs = 127;
109  TYPED_TEST(RandenEngineTypedTest, RandomNumberEngineInterface) {
110    using randen = typename absl::random_internal::randen_engine<TypeParam>;
111    using E = randen;
<span onclick='openModal()' class='match'>112    using T = typename E::result_type;
113    static_assert(std::is_copy_constructible<E>::value,
114                  "randen_engine must be copy constructible");
115    static_assert(absl::is_copy_assignable<E>::value,
116                  "randen_engine must be copy assignable");
117    static_assert(std::is_move_constructible<E>::value,
</span>118                  "randen_engine must be move constructible");
119    static_assert(absl::is_move_assignable<E>::value,
120                  "randen_engine must be move assignable");
121    static_assert(std::is_same<decltype(std::declval<E>()()), T>::value,
122                  "return type of operator() must be result_type");
123    E e, v;
124    const E x, y;
125    T s = 1;
126    std::seed_seq q{1, 2, 3};
127    unsigned long long z = 1;  
128    std::wostringstream os;
129    std::wistringstream is;
130    E{};
131    E{x};
132    E{s};
133    E{q};
134    e.seed();
135    EXPECT_TRUE(e == x);
136    e.seed(q);
137    {
138      E tmp(q);
139      EXPECT_TRUE(e == tmp);
140    }
141    e();
142    {
143      E tmp(q);
144      EXPECT_TRUE(e != tmp);
145    }
146    e.discard(z);
147    static_assert(std::is_same<decltype(x == y), bool>::value,
148                  "return type of operator== must be bool");
149    static_assert(std::is_same<decltype(x != y), bool>::value,
150                  "return type of operator== must be bool");
151  }
152  TYPED_TEST(RandenEngineTypedTest, RandenEngineSFINAETest) {
153    using randen = typename absl::random_internal::randen_engine<TypeParam>;
154    using result_type = typename randen::result_type;
155    {
156      randen engine(result_type(1));
157      engine.seed(result_type(1));
158    }
159    {
160      result_type n = 1;
161      randen engine(n);
162      engine.seed(n);
163    }
164    {
165      randen engine(1);
166      engine.seed(1);
167    }
168    {
169      int n = 1;
170      randen engine(n);
171      engine.seed(n);
172    }
173    {
174      std::seed_seq seed_seq;
175      randen engine(seed_seq);
176      engine.seed(seed_seq);
177    }
178    {
179      randen engine{std::seed_seq()};
180      engine.seed(std::seed_seq());
181    }
182  }
183  TEST(RandenTest, VerifyGoldenRanden64Default) {
184    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
185        0xc3c14f134e433977, 0xdda9f47cd90410ee, 0x887bf3087fd8ca10,
186        0xf0b780f545c72912, 0x15dbb1d37696599f, 0x30ec63baff3c6d59,
187        0xb29f73606f7f20a6, 0x02808a316f49a54c, 0x3b8feaf9d5c8e50e,
188        0x9cbf605e3fd9de8a, 0xc970ae1a78183bbb, 0xd8b2ffd356301ed5,
189        0xf4b327fe0fc73c37, 0xcdfd8d76eb8f9a19, 0xc3a506eb91420c9d,
190        0xd5af05dd3eff9556, 0x48db1bb78f83c4a1, 0x7023920e0d6bfe8c,
191        0x58d3575834956d42, 0xed1ef4c26b87b840, 0x8eef32a23e0b2df3,
192        0x497cabf3431154fc, 0x4e24370570029a8b, 0xd88b5749f090e5ea,
193        0xc651a582a970692f, 0x78fcec2cbb6342f5, 0x463cb745612f55db,
194        0x352ee4ad1816afe3, 0x026ff374c101da7e, 0x811ef0821c3de851,
195        0x6f7e616704c4fa59, 0xa0660379992d58fc, 0x04b0a374a3b795c7,
196        0x915f3445685da798, 0x26802a8ac76571ce, 0x4663352533ce1882,
197        0xb9fdefb4a24dc738, 0x5588ba3a4d6e6c51, 0xa2101a42d35f1956,
198        0x607195a5e200f5fd, 0x7e100308f3290764, 0xe1e5e03c759c0709,
199        0x082572cc5da6606f, 0xcbcf585399e432f1, 0xe8a2be4f8335d8f1,
200        0x0904469acbfee8f2, 0xf08bd31b6daecd51, 0x08e8a1f1a69da69a,
201        0x6542a20aad57bff5, 0x2e9705bb053d6b46, 0xda2fc9db0713c391,
202        0x78e3a810213b6ffb, 0xdc16a59cdd85f8a6, 0xc0932718cd55781f,
203        0xb9bfb29c2b20bfe5, 0xb97289c1be0f2f9c, 0xc0a2a0e403a892d4,
204        0x5524bb834771435b, 0x8265da3d39d1a750, 0xff4af3ab8d1b78c5,
205        0xf0ec5f424bcad77f, 0x66e455f627495189, 0xc82d3120b57e3270,
206        0x3424e47dc22596e3, 0xbc0c95129ccedcdd, 0xc191c595afc4dcbf,
207        0x120392bd2bb70939, 0x7f90650ea6cd6ab4, 0x7287491832695ad3,
208        0xa7c8fac5a7917eb0, 0xd088cb9418be0361, 0x7c1bf9839c7c1ce5,
209        0xe2e991fa58e1e79e, 0x78565cdefd28c4ad, 0x7351b9fef98bafad,
210        0x2a9eac28b08c96bf, 0x6c4f179696cb2225, 0x13a685861bab87e0,
211        0x64c6de5aa0501971, 0x30537425cac70991, 0x01590d9dc6c532b7,
212        0x7e05e3aa8ec720dc, 0x74a07d9c54e3e63f, 0x738184388f3bc1d2,
213        0x26ffdc5067be3acb, 0x6bcdf185561f255f, 0xa0eaf2e1cf99b1c6,
214        0x171df81934f68604, 0x7ea5a21665683e5a, 0x5d1cb02075ba1cea,
215        0x957f38cbd2123fdf, 0xba6364eff80de02f, 0x606e0a0e41d452ee,
216        0x892d8317de82f7a2, 0xe707b1db50f7b43e, 0x4eb28826766fcf5b,
217        0x5a362d56e80a0951, 0x6ee217df16527d78, 0xf6737962ba6b23dd,
218        0x443e63857d4076ca, 0x790d9a5f048adfeb, 0xd796b052151ee94d,
219        0x033ed95c12b04a03, 0x8b833ff84893da5d, 0x3d6724b1bb15eab9,
220        0x9877c4225061ca76, 0xd68d6810adf74fb3, 0x42e5352fe30ce989,
221        0x265b565a7431fde7, 0x3cdbf7e358df4b8b, 0x2922a47f6d3e8779,
222        0x52d2242f65b37f88, 0x5d836d6e2958d6b5, 0x29d40f00566d5e26,
223        0x288db0e1124b14a0, 0x6c056608b7d9c1b6, 0x0b9471bdb8f19d32,
224        0x8fb946504faa6c9d, 0x8943a9464540251c, 0xfd1fe27d144a09e0,
225        0xea6ac458da141bda, 0x8048f217633fce36, 0xfeda1384ade74d31,
226        0x4334b8b02ff7612f, 0xdbc8441f5227e216, 0x096d119a3605c85b,
227        0x2b72b31c21b7d7d0};
228    randen_u64 engine;
229  #if UPDATE_GOLDEN
230    (void)kGolden;  
231    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
232      printf("0x%016lx, ", engine());
233      if (i % 3 == 2) {
234        printf("\n");
235      }
236    }
237    printf("\n\n\n");
238  #else
239    for (const auto& elem : kGolden) {
240      EXPECT_EQ(elem, engine());
241    }
242    engine.seed();
243    for (const auto& elem : kGolden) {
244      EXPECT_EQ(elem, engine());
245    }
246  #endif
247  }
248  TEST(RandenTest, VerifyGoldenRanden64Seeded) {
249    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
250        0x83a9e58f94d3dcd5, 0x70bbdff3d97949fb, 0x0438481f7471c1b4,
251        0x34fdc58ee5fb5930, 0xceee4f2d2a937d17, 0xb5a26a68e432aea9,
252        0x8b64774a3fb51740, 0xd89ac1fc74249c74, 0x03910d1d23fc3fdf,
253        0xd38f630878aa897f, 0x0ee8f0f5615f7e44, 0x98f5a53df8279d52,
254        0xb403f52c25938d0e, 0x240072996ea6e838, 0xd3a791246190fa61,
255        0xaaedd3df7a7b4f80, 0xc6eacabe05deaf6e, 0xb7967dd8790edf4d,
256        0x9a0a8e67e049d279, 0x0494f606aebc23e7, 0x598dcd687bc3e0ee,
257        0x010ac81802d452a1, 0x6407c87160aa2842, 0x5a56e276486f93a0,
258        0xc887a399d46a8f02, 0x9e1e6100fe93b740, 0x12d02e330f8901f6,
259        0xc39ca52b47e790b7, 0xb0b0a2fa11e82e61, 0x1542d841a303806a,
260        0x1fe659fd7d6e9d86, 0xb8c90d80746541ac, 0x239d56a5669ddc94,
261        0xd40db57c8123d13c, 0x3abc2414153a0db0, 0x9bad665630cb8d61,
262        0x0bd1fb90ee3f4bbc, 0x8f0b4d7e079b4e42, 0xfa0fb0e0ee59e793,
263        0x51080b283e071100, 0x2c4b9e715081cc15, 0xbe10ed49de4941df,
264        0xf8eaac9d4b1b0d37, 0x4bcce4b54605e139, 0xa64722b76765dda6,
265        0xb9377d738ca28ab5, 0x779fad81a8ccc1af, 0x65cb3ee61ffd3ba7,
266        0xd74e79087862836f, 0xd05b9c584c3f25bf, 0x2ba93a4693579827,
267        0xd81530aff05420ce, 0xec06cea215478621, 0x4b1798a6796d65ad,
268        0xf142f3fb3a6f6fa6, 0x002b7bf7e237b560, 0xf47f2605ef65b4f8,
269        0x9804ec5517effc18, 0xaed3d7f8b7d481cd, 0x5651c24c1ce338d1,
270        0x3e7a38208bf0a3c6, 0x6796a7b614534aed, 0x0d0f3b848358460f,
271        0x0fa5fe7600b19524, 0x2b0cf38253faaedc, 0x10df9188233a9fd6,
272        0x3a10033880138b59, 0x5fb0b0d23948e80f, 0x9e76f7b02fbf5350,
273        0x0816052304b1a985, 0x30c9880db41fd218, 0x14aa399b65e20f28,
274        0xe1454a8cace787b4, 0x325ac971b6c6f0f5, 0x716b1aa2784f3d36,
275        0x3d5ce14accfd144f, 0x6c0c97710f651792, 0xbc5b0f59fb333532,
276        0x2a90a7d2140470bc, 0x8da269f55c1e1c8d, 0xcfc37143895792ca,
277        0xbe21eab1f30b238f, 0x8c47229dee4d65fd, 0x5743614ed1ed7d54,
278        0x351372a99e9c476e, 0x2bd5ea15e5db085f, 0x6925fde46e0af4ca,
279        0xed3eda2bdc1f45bd, 0xdef68c68d460fa6e, 0xe42a0de76253e2b5,
280        0x4e5176dcbc29c305, 0xbfd85fba9f810f6e, 0x76a5a2a9beb815c6,
281        0x01edc4ddceaf414c, 0xa4e98904b4bb3b4b, 0x00bd63ac7d2f1ddd,
282        0xb8491fe6e998ddbb, 0xb386a3463dda6800, 0x0081887688871619,
283        0x33d394b3344e9a38, 0x815dba65a3a8baf9, 0x4232f6ec02c2fd1a,
284        0xb5cff603edd20834, 0x580189243f687663, 0xa8d5a2cbdc27fe99,
285        0x725d881693fa0131, 0xa2be2c13db2c7ac5, 0x7b6a9614b509fd78,
286        0xb6b136d71e717636, 0x660f1a71aff046ea, 0x0ba10ae346c8ec9e,
287        0xe66dde53e3145b41, 0x3b18288c88c26be6, 0x4d9d9d2ff02db933,
288        0x4167da8c70f46e8a, 0xf183beef8c6318b4, 0x4d889e1e71eeeef1,
289        0x7175c71ad6689b6b, 0xfb9e42beacd1b7dd, 0xc33d0e91b29b5e0d,
290        0xd39b83291ce47922, 0xc4d570fb8493d12e, 0x23d5a5724f424ae6,
291        0x5245f161876b6616, 0x38d77dbd21ab578d, 0x9c3423311f4ecbfe,
292        0x76fe31389bacd9d5,
293    };
294    ExplicitSeedSeq seed_sequence{12, 34, 56};
295    randen_u64 engine(seed_sequence);
296  #if UPDATE_GOLDEN
297    (void)kGolden;  
298    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
299      printf("0x%016lx, ", engine());
300      if (i % 3 == 2) {
301        printf("\n");
302      }
303    }
304    printf("\n\n\n");
305  #else
306    for (const auto& elem : kGolden) {
307      EXPECT_EQ(elem, engine());
308    }
309    engine.seed(seed_sequence);
310    for (const auto& elem : kGolden) {
311      EXPECT_EQ(elem, engine());
312    }
313  #endif
314  }
315  TEST(RandenTest, VerifyGoldenRanden32Default) {
316    constexpr uint64_t kGolden[2 * kNumGoldenOutputs] = {
317        0x4e433977, 0xc3c14f13, 0xd90410ee, 0xdda9f47c, 0x7fd8ca10, 0x887bf308,
318        0x45c72912, 0xf0b780f5, 0x7696599f, 0x15dbb1d3, 0xff3c6d59, 0x30ec63ba,
319        0x6f7f20a6, 0xb29f7360, 0x6f49a54c, 0x02808a31, 0xd5c8e50e, 0x3b8feaf9,
320        0x3fd9de8a, 0x9cbf605e, 0x78183bbb, 0xc970ae1a, 0x56301ed5, 0xd8b2ffd3,
321        0x0fc73c37, 0xf4b327fe, 0xeb8f9a19, 0xcdfd8d76, 0x91420c9d, 0xc3a506eb,
322        0x3eff9556, 0xd5af05dd, 0x8f83c4a1, 0x48db1bb7, 0x0d6bfe8c, 0x7023920e,
323        0x34956d42, 0x58d35758, 0x6b87b840, 0xed1ef4c2, 0x3e0b2df3, 0x8eef32a2,
324        0x431154fc, 0x497cabf3, 0x70029a8b, 0x4e243705, 0xf090e5ea, 0xd88b5749,
325        0xa970692f, 0xc651a582, 0xbb6342f5, 0x78fcec2c, 0x612f55db, 0x463cb745,
326        0x1816afe3, 0x352ee4ad, 0xc101da7e, 0x026ff374, 0x1c3de851, 0x811ef082,
327        0x04c4fa59, 0x6f7e6167, 0x992d58fc, 0xa0660379, 0xa3b795c7, 0x04b0a374,
328        0x685da798, 0x915f3445, 0xc76571ce, 0x26802a8a, 0x33ce1882, 0x46633525,
329        0xa24dc738, 0xb9fdefb4, 0x4d6e6c51, 0x5588ba3a, 0xd35f1956, 0xa2101a42,
330        0xe200f5fd, 0x607195a5, 0xf3290764, 0x7e100308, 0x759c0709, 0xe1e5e03c,
331        0x5da6606f, 0x082572cc, 0x99e432f1, 0xcbcf5853, 0x8335d8f1, 0xe8a2be4f,
332        0xcbfee8f2, 0x0904469a, 0x6daecd51, 0xf08bd31b, 0xa69da69a, 0x08e8a1f1,
333        0xad57bff5, 0x6542a20a, 0x053d6b46, 0x2e9705bb, 0x0713c391, 0xda2fc9db,
334        0x213b6ffb, 0x78e3a810, 0xdd85f8a6, 0xdc16a59c, 0xcd55781f, 0xc0932718,
335        0x2b20bfe5, 0xb9bfb29c, 0xbe0f2f9c, 0xb97289c1, 0x03a892d4, 0xc0a2a0e4,
336        0x4771435b, 0x5524bb83, 0x39d1a750, 0x8265da3d, 0x8d1b78c5, 0xff4af3ab,
337        0x4bcad77f, 0xf0ec5f42, 0x27495189, 0x66e455f6, 0xb57e3270, 0xc82d3120,
338        0xc22596e3, 0x3424e47d, 0x9ccedcdd, 0xbc0c9512, 0xafc4dcbf, 0xc191c595,
339        0x2bb70939, 0x120392bd, 0xa6cd6ab4, 0x7f90650e, 0x32695ad3, 0x72874918,
340        0xa7917eb0, 0xa7c8fac5, 0x18be0361, 0xd088cb94, 0x9c7c1ce5, 0x7c1bf983,
341        0x58e1e79e, 0xe2e991fa, 0xfd28c4ad, 0x78565cde, 0xf98bafad, 0x7351b9fe,
342        0xb08c96bf, 0x2a9eac28, 0x96cb2225, 0x6c4f1796, 0x1bab87e0, 0x13a68586,
343        0xa0501971, 0x64c6de5a, 0xcac70991, 0x30537425, 0xc6c532b7, 0x01590d9d,
344        0x8ec720dc, 0x7e05e3aa, 0x54e3e63f, 0x74a07d9c, 0x8f3bc1d2, 0x73818438,
345        0x67be3acb, 0x26ffdc50, 0x561f255f, 0x6bcdf185, 0xcf99b1c6, 0xa0eaf2e1,
346        0x34f68604, 0x171df819, 0x65683e5a, 0x7ea5a216, 0x75ba1cea, 0x5d1cb020,
347        0xd2123fdf, 0x957f38cb, 0xf80de02f, 0xba6364ef, 0x41d452ee, 0x606e0a0e,
348        0xde82f7a2, 0x892d8317, 0x50f7b43e, 0xe707b1db, 0x766fcf5b, 0x4eb28826,
349        0xe80a0951, 0x5a362d56, 0x16527d78, 0x6ee217df, 0xba6b23dd, 0xf6737962,
350        0x7d4076ca, 0x443e6385, 0x048adfeb, 0x790d9a5f, 0x151ee94d, 0xd796b052,
351        0x12b04a03, 0x033ed95c, 0x4893da5d, 0x8b833ff8, 0xbb15eab9, 0x3d6724b1,
352        0x5061ca76, 0x9877c422, 0xadf74fb3, 0xd68d6810, 0xe30ce989, 0x42e5352f,
353        0x7431fde7, 0x265b565a, 0x58df4b8b, 0x3cdbf7e3, 0x6d3e8779, 0x2922a47f,
354        0x65b37f88, 0x52d2242f, 0x2958d6b5, 0x5d836d6e, 0x566d5e26, 0x29d40f00,
355        0x124b14a0, 0x288db0e1, 0xb7d9c1b6, 0x6c056608, 0xb8f19d32, 0x0b9471bd,
356        0x4faa6c9d, 0x8fb94650, 0x4540251c, 0x8943a946, 0x144a09e0, 0xfd1fe27d,
357        0xda141bda, 0xea6ac458, 0x633fce36, 0x8048f217, 0xade74d31, 0xfeda1384,
358        0x2ff7612f, 0x4334b8b0, 0x5227e216, 0xdbc8441f, 0x3605c85b, 0x096d119a,
359        0x21b7d7d0, 0x2b72b31c};
360    randen_u32 engine;
361  #if UPDATE_GOLDEN
362    (void)kGolden;  
363    for (size_t i = 0; i < 2 * kNumGoldenOutputs; ++i) {
364      printf("0x%08x, ", engine());
365      if (i % 6 == 5) {
366        printf("\n");
367      }
368    }
369    printf("\n\n\n");
370  #else
371    for (const auto& elem : kGolden) {
372      EXPECT_EQ(elem, engine());
373    }
374    engine.seed();
375    for (const auto& elem : kGolden) {
376      EXPECT_EQ(elem, engine());
377    }
378  #endif
379  }
380  TEST(RandenTest, VerifyGoldenRanden32Seeded) {
381    constexpr uint64_t kGolden[2 * kNumGoldenOutputs] = {
382        0x94d3dcd5, 0x83a9e58f, 0xd97949fb, 0x70bbdff3, 0x7471c1b4, 0x0438481f,
383        0xe5fb5930, 0x34fdc58e, 0x2a937d17, 0xceee4f2d, 0xe432aea9, 0xb5a26a68,
384        0x3fb51740, 0x8b64774a, 0x74249c74, 0xd89ac1fc, 0x23fc3fdf, 0x03910d1d,
385        0x78aa897f, 0xd38f6308, 0x615f7e44, 0x0ee8f0f5, 0xf8279d52, 0x98f5a53d,
386        0x25938d0e, 0xb403f52c, 0x6ea6e838, 0x24007299, 0x6190fa61, 0xd3a79124,
387        0x7a7b4f80, 0xaaedd3df, 0x05deaf6e, 0xc6eacabe, 0x790edf4d, 0xb7967dd8,
388        0xe049d279, 0x9a0a8e67, 0xaebc23e7, 0x0494f606, 0x7bc3e0ee, 0x598dcd68,
389        0x02d452a1, 0x010ac818, 0x60aa2842, 0x6407c871, 0x486f93a0, 0x5a56e276,
390        0xd46a8f02, 0xc887a399, 0xfe93b740, 0x9e1e6100, 0x0f8901f6, 0x12d02e33,
391        0x47e790b7, 0xc39ca52b, 0x11e82e61, 0xb0b0a2fa, 0xa303806a, 0x1542d841,
392        0x7d6e9d86, 0x1fe659fd, 0x746541ac, 0xb8c90d80, 0x669ddc94, 0x239d56a5,
393        0x8123d13c, 0xd40db57c, 0x153a0db0, 0x3abc2414, 0x30cb8d61, 0x9bad6656,
394        0xee3f4bbc, 0x0bd1fb90, 0x079b4e42, 0x8f0b4d7e, 0xee59e793, 0xfa0fb0e0,
395        0x3e071100, 0x51080b28, 0x5081cc15, 0x2c4b9e71, 0xde4941df, 0xbe10ed49,
396        0x4b1b0d37, 0xf8eaac9d, 0x4605e139, 0x4bcce4b5, 0x6765dda6, 0xa64722b7,
397        0x8ca28ab5, 0xb9377d73, 0xa8ccc1af, 0x779fad81, 0x1ffd3ba7, 0x65cb3ee6,
398        0x7862836f, 0xd74e7908, 0x4c3f25bf, 0xd05b9c58, 0x93579827, 0x2ba93a46,
399        0xf05420ce, 0xd81530af, 0x15478621, 0xec06cea2, 0x796d65ad, 0x4b1798a6,
400        0x3a6f6fa6, 0xf142f3fb, 0xe237b560, 0x002b7bf7, 0xef65b4f8, 0xf47f2605,
401        0x17effc18, 0x9804ec55, 0xb7d481cd, 0xaed3d7f8, 0x1ce338d1, 0x5651c24c,
402        0x8bf0a3c6, 0x3e7a3820, 0x14534aed, 0x6796a7b6, 0x8358460f, 0x0d0f3b84,
403        0x00b19524, 0x0fa5fe76, 0x53faaedc, 0x2b0cf382, 0x233a9fd6, 0x10df9188,
404        0x80138b59, 0x3a100338, 0x3948e80f, 0x5fb0b0d2, 0x2fbf5350, 0x9e76f7b0,
405        0x04b1a985, 0x08160523, 0xb41fd218, 0x30c9880d, 0x65e20f28, 0x14aa399b,
406        0xace787b4, 0xe1454a8c, 0xb6c6f0f5, 0x325ac971, 0x784f3d36, 0x716b1aa2,
407        0xccfd144f, 0x3d5ce14a, 0x0f651792, 0x6c0c9771, 0xfb333532, 0xbc5b0f59,
408        0x140470bc, 0x2a90a7d2, 0x5c1e1c8d, 0x8da269f5, 0x895792ca, 0xcfc37143,
409        0xf30b238f, 0xbe21eab1, 0xee4d65fd, 0x8c47229d, 0xd1ed7d54, 0x5743614e,
410        0x9e9c476e, 0x351372a9, 0xe5db085f, 0x2bd5ea15, 0x6e0af4ca, 0x6925fde4,
411        0xdc1f45bd, 0xed3eda2b, 0xd460fa6e, 0xdef68c68, 0x6253e2b5, 0xe42a0de7,
412        0xbc29c305, 0x4e5176dc, 0x9f810f6e, 0xbfd85fba, 0xbeb815c6, 0x76a5a2a9,
413        0xceaf414c, 0x01edc4dd, 0xb4bb3b4b, 0xa4e98904, 0x7d2f1ddd, 0x00bd63ac,
414        0xe998ddbb, 0xb8491fe6, 0x3dda6800, 0xb386a346, 0x88871619, 0x00818876,
415        0x344e9a38, 0x33d394b3, 0xa3a8baf9, 0x815dba65, 0x02c2fd1a, 0x4232f6ec,
416        0xedd20834, 0xb5cff603, 0x3f687663, 0x58018924, 0xdc27fe99, 0xa8d5a2cb,
417        0x93fa0131, 0x725d8816, 0xdb2c7ac5, 0xa2be2c13, 0xb509fd78, 0x7b6a9614,
418        0x1e717636, 0xb6b136d7, 0xaff046ea, 0x660f1a71, 0x46c8ec9e, 0x0ba10ae3,
419        0xe3145b41, 0xe66dde53, 0x88c26be6, 0x3b18288c, 0xf02db933, 0x4d9d9d2f,
420        0x70f46e8a, 0x4167da8c, 0x8c6318b4, 0xf183beef, 0x71eeeef1, 0x4d889e1e,
421        0xd6689b6b, 0x7175c71a, 0xacd1b7dd, 0xfb9e42be, 0xb29b5e0d, 0xc33d0e91,
422        0x1ce47922, 0xd39b8329, 0x8493d12e, 0xc4d570fb, 0x4f424ae6, 0x23d5a572,
423        0x876b6616, 0x5245f161, 0x21ab578d, 0x38d77dbd, 0x1f4ecbfe, 0x9c342331,
424        0x9bacd9d5, 0x76fe3138,
425    };
426    ExplicitSeedSeq seed_sequence{12, 34, 56};
427    randen_u32 engine(seed_sequence);
428  #if UPDATE_GOLDEN
429    (void)kGolden;  
430    for (size_t i = 0; i < 2 * kNumGoldenOutputs; ++i) {
431      printf("0x%08x, ", engine());
432      if (i % 6 == 5) {
433        printf("\n");
434      }
435    }
436    printf("\n\n\n");
437  #else
438    for (const auto& elem : kGolden) {
439      EXPECT_EQ(elem, engine());
440    }
441    engine.seed(seed_sequence);
442    for (const auto& elem : kGolden) {
443      EXPECT_EQ(elem, engine());
444    }
445  #endif
446  }
447  TEST(RandenTest, VerifyGoldenFromDeserializedEngine) {
448    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
449        0x067f9f9ab919657a, 0x0534605912988583, 0x8a303f72feaa673f,
450        0x77b7fd747909185c, 0xd9af90403c56d891, 0xd939c6cb204d14b5,
451        0x7fbe6b954a47b483, 0x8b31a47cc34c768d, 0x3a9e546da2701a9c,
452        0x5246539046253e71, 0x417191ffb2a848a1, 0x7b1c7bf5a5001d09,
453        0x9489b15d194f2361, 0xfcebdeea3bcd2461, 0xd643027c854cec97,
454        0x5885397f91e0d21c, 0x53173b0efae30d58, 0x1c9c71168449fac1,
455        0xe358202b711ed8aa, 0x94e3918ed1d8227c, 0x5bb4e251450144cf,
456        0xb5c7a519b489af3b, 0x6f8b560b1f7b3469, 0xfde11dd4a1c74eef,
457        0x33383d2f76457dcf, 0x3060c0ec6db9fce1, 0x18f451fcddeec766,
458        0xe73c5d6b9f26da2a, 0x8d4cc566671b32a4, 0xb8189b73776bc9ff,
459        0x497a70f9caf0bc23, 0x23afcc509791dcea, 0x18af70dc4b27d306,
460        0xd3853f955a0ce5b9, 0x441db6c01a0afb17, 0xd0136c3fb8e1f13f,
461        0x5e4fd6fc2f33783c, 0xe0d24548adb5da51, 0x0f4d8362a7d3485a,
462        0x9f572d68270fa563, 0x6351fbc823024393, 0xa66dbfc61810e9ab,
463        0x0ff17fc14b651af8, 0xd74c55dafb99e623, 0x36303bc1ad85c6c2,
464        0x4920cd6a2af7e897, 0x0b8848addc30fecd, 0x9e1562eda6488e93,
465        0x197553807d607828, 0xbef5eaeda5e21235, 0x18d91d2616aca527,
466        0xb7821937f5c873cd, 0x2cd4ae5650dbeefc, 0xb35a64376f75ffdf,
467        0x9226d414d647fe07, 0x663f3db455bbb35e, 0xa829eead6ae93247,
468        0x7fd69c204dd0d25f, 0xbe1411f891c9acb1, 0xd476f34a506d5f11,
469        0xf423d2831649c5ca, 0x1e503962951abd75, 0xeccc9e8b1e34b537,
470        0xb11a147294044854, 0xc4cf27f0abf4929d, 0xe9193abf6fa24c8c,
471        0xa94a259e3aba8808, 0x21dc414197deffa3, 0xa2ae211d1ff622ae,
472        0xfe3995c46be5a4f4, 0xe9984c284bf11128, 0xcb1ce9d2f0851a80,
473        0x42fee17971d87cd8, 0xac76a98d177adc88, 0xa0973b3dedc4af6f,
474        0xdf56d6bbcb1b8e86, 0xf1e6485f407b11c9, 0x2c63de4deccb15c0,
475        0x6fe69db32ed4fad7, 0xaa51a65f84bca1f1, 0x242f2ee81d608afc,
476        0x8eb88b2b69fc153b, 0x22c20098baf73fd1, 0x57759466f576488c,
477        0x075ca562cea1be9d, 0x9a74814d73d28891, 0x73d1555fc02f4d3d,
478        0xc17f8f210ee89337, 0x46cca7999eaeafd4, 0x5db8d6a327a0d8ac,
479        0xb79b4f93c738d7a1, 0x9994512f0036ded1, 0xd3883026f38747f4,
480        0xf31f7458078d097c, 0x736ce4d480680669, 0x7a496f4c7e1033e3,
481        0xecf85bf297fbc68c, 0x9e37e1d0f24f3c4e, 0x15b6e067ca0746fc,
482        0xdd4a39905c5db81c, 0xb5dfafa7bcfdf7da, 0xca6646fb6f92a276,
483        0x1c6b35f363ef0efd, 0x6a33d06037ad9f76, 0x45544241afd8f80f,
484        0x83f8d83f859c90c5, 0x22aea9c5365e8c19, 0xfac35b11f20b6a6a,
485        0xd1acf49d1a27dd2f, 0xf281cd09c4fed405, 0x076000a42cd38e4f,
486        0x6ace300565070445, 0x463a62781bddc4db, 0x1477126b46b569ac,
487        0x127f2bb15035fbb8, 0xdfa30946049c04a8, 0x89072a586ba8dd3e,
488        0x62c809582bb7e74d, 0x22c0c3641406c28b, 0x9b66e36c47ff004d,
489        0xb9cd2c7519653330, 0x18608d79cd7a598d, 0x92c0bd1323e53e32,
490        0x887ff00de8524aa5, 0xa074410b787abd10, 0x18ab41b8057a2063,
491        0x1560abf26bc5f987};
492  #if UPDATE_GOLDEN
493    (void)kGolden;  
494    std::seed_seq seed_sequence{1, 2, 3, 4, 5};
495    randen_u64 engine(seed_sequence);
496    std::ostringstream stream;
497    stream << engine;
498    auto str = stream.str();
499    printf("%s\n\n", str.c_str());
500    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
501      printf("0x%016lx, ", engine());
502      if (i % 3 == 2) {
503        printf("\n");
504      }
505    }
506    printf("\n\n\n");
507  #else
508    randen_u64 engine;
509    std::istringstream stream(
510        "0 0 9824501439887287479 3242284395352394785 243836530774933777 "
511        "4047941804708365596 17165468127298385802 949276103645889255 "
512        "10659970394998657921 1657570836810929787 11697746266668051452 "
513        "9967209969299905230 14140390331161524430 7383014124183271684 "
514        "13146719127702337852 13983155220295807171 11121125587542359264 "
515        "195757810993252695 17138580243103178492 11326030747260920501 "
516        "8585097322474965590 18342582839328350995 15052982824209724634 "
517        "7321861343874683609 1806786911778767826 10100850842665572955 "
518        "9249328950653985078 13600624835326909759 11137960060943860251 "
519        "10208781341792329629 9282723971471525577 16373271619486811032 32");
520    stream >> engine;
521    for (const auto& elem : kGolden) {
522      EXPECT_EQ(elem, engine());
523    }
524  #endif
525  }
526  TEST(RandenTest, IsFastOrSlow) {
527    static constexpr size_t kCount = 100000;
528    randen_u64 engine;
529    randen_u64::result_type sum = 0;
530    auto start = absl::GetCurrentTimeNanos();
531    for (int i = 0; i < kCount; i++) {
532      sum += engine();
533    }
534    auto duration = absl::GetCurrentTimeNanos() - start;
535    LOG(INFO) << static_cast<double>(duration) / static_cast<double>(kCount)
536              << "ns";
537    EXPECT_GT(sum, 0);
538    EXPECT_GE(duration, kCount);  
539  }
540  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</h3>
            <pre><code>1  #include "absl/random/internal/pcg_engine.h"
2  #include <algorithm>
3  #include <bitset>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/random/internal/explicit_seed_seq.h"
9  #include "absl/time/clock.h"
10  #define UPDATE_GOLDEN 0
11  namespace {
12  using absl::random_internal::ExplicitSeedSeq;
13  using absl::random_internal::pcg32_2018_engine;
14  using absl::random_internal::pcg64_2018_engine;
15  template <typename EngineType>
16  class PCGEngineTest : public ::testing::Test {};
17  using EngineTypes = ::testing::Types<pcg64_2018_engine, pcg32_2018_engine>;
18  TYPED_TEST_SUITE(PCGEngineTest, EngineTypes);
19  TYPED_TEST(PCGEngineTest, VerifyReseedChangesAllValues) {
20    using engine_type = TypeParam;
21    using result_type = typename engine_type::result_type;
22    const size_t kNumOutputs = 16;
23    engine_type engine;
24    {
25      std::seed_seq seq1{1, 2, 3, 4, 5, 6, 7};
26      engine.seed(seq1);
27    }
28    result_type a[kNumOutputs];
29    std::generate(std::begin(a), std::end(a), std::ref(engine));
30    {
31      std::random_device rd;
32      std::seed_seq seq2{rd(), rd(), rd()};
33      engine.seed(seq2);
34    }
35    result_type b[kNumOutputs];
36    std::generate(std::begin(b), std::end(b), std::ref(engine));
37    size_t changed_bits = 0;
38    size_t unchanged_bits = 0;
39    size_t total_set = 0;
40    size_t total_bits = 0;
41    size_t equal_count = 0;
42    for (size_t i = 0; i < kNumOutputs; ++i) {
43      equal_count += (a[i] == b[i]) ? 1 : 0;
44      std::bitset<sizeof(result_type) * 8> bitset(a[i] ^ b[i]);
45      changed_bits += bitset.count();
46      unchanged_bits += bitset.size() - bitset.count();
47      std::bitset<sizeof(result_type) * 8> a_set(a[i]);
48      std::bitset<sizeof(result_type) * 8> b_set(b[i]);
49      total_set += a_set.count() + b_set.count();
50      total_bits += 2 * 8 * sizeof(result_type);
51    }
52    EXPECT_LE(changed_bits, 0.60 * (changed_bits + unchanged_bits));
53    EXPECT_GE(changed_bits, 0.40 * (changed_bits + unchanged_bits));
54    EXPECT_NEAR(total_set, total_bits * 0.5, 4 * std::sqrt(total_bits))
55        << "@" << total_set / static_cast<double>(total_bits);
56    const double kExpected = kNumOutputs / (1.0 * sizeof(result_type) * 8);
57    EXPECT_LE(equal_count, 1.0 + kExpected);
58  }
59  constexpr size_t kTwoBufferValues = 16;
60  TYPED_TEST(PCGEngineTest, VerifyDiscard) {
61    using engine_type = TypeParam;
62    for (size_t num_used = 0; num_used < kTwoBufferValues; ++num_used) {
63      engine_type engine_used;
64      for (size_t i = 0; i < num_used; ++i) {
65        engine_used();
66      }
67      for (size_t num_discard = 0; num_discard < kTwoBufferValues;
68           ++num_discard) {
69        engine_type engine1 = engine_used;
70        engine_type engine2 = engine_used;
71        for (size_t i = 0; i < num_discard; ++i) {
72          engine1();
73        }
74        engine2.discard(num_discard);
75        for (size_t i = 0; i < kTwoBufferValues; ++i) {
76          const auto r1 = engine1();
77          const auto r2 = engine2();
78          ASSERT_EQ(r1, r2) << "used=" << num_used << " discard=" << num_discard;
79        }
80      }
81    }
82  }
83  TYPED_TEST(PCGEngineTest, StreamOperatorsResult) {
84    using engine_type = TypeParam;
85    std::wostringstream os;
86    std::wistringstream is;
87    engine_type engine;
88    EXPECT_EQ(&(os << engine), &os);
89    EXPECT_EQ(&(is >> engine), &is);
90  }
91  TYPED_TEST(PCGEngineTest, StreamSerialization) {
92    using engine_type = TypeParam;
93    for (size_t discard = 0; discard < kTwoBufferValues; ++discard) {
94      ExplicitSeedSeq seed_sequence{12, 34, 56};
95      engine_type engine(seed_sequence);
96      engine.discard(discard);
97      std::stringstream stream;
98      stream << engine;
99      engine_type new_engine;
100      stream >> new_engine;
101      for (size_t i = 0; i < 64; ++i) {
102        EXPECT_EQ(engine(), new_engine()) << " " << i;
103      }
104    }
105  }
106  constexpr size_t kNumGoldenOutputs = 127;
107  TYPED_TEST(PCGEngineTest, RandomNumberEngineInterface) {
108    using engine_type = TypeParam;
109    using E = engine_type;
<span onclick='openModal()' class='match'>110    using T = typename E::result_type;
111    static_assert(std::is_copy_constructible<E>::value,
112                  "engine_type must be copy constructible");
113    static_assert(absl::is_copy_assignable<E>::value,
114                  "engine_type must be copy assignable");
115    static_assert(std::is_move_constructible<E>::value,
</span>116                  "engine_type must be move constructible");
117    static_assert(absl::is_move_assignable<E>::value,
118                  "engine_type must be move assignable");
119    static_assert(std::is_same<decltype(std::declval<E>()()), T>::value,
120                  "return type of operator() must be result_type");
121    E e, v;
122    const E x, y;
123    T s = 1;
124    std::seed_seq q{1, 2, 3};
125    unsigned long long z = 1;  
126    std::wostringstream os;
127    std::wistringstream is;
128    E{};
129    E{x};
130    E{s};
131    E{q};
132    e.seed();
133    EXPECT_TRUE(e == x);
134    e.seed(q);
135    {
136      E tmp(q);
137      EXPECT_TRUE(e == tmp);
138    }
139    e();
140    {
141      E tmp(q);
142      EXPECT_TRUE(e != tmp);
143    }
144    e.discard(z);
145    static_assert(std::is_same<decltype(x == y), bool>::value,
146                  "return type of operator== must be bool");
147    static_assert(std::is_same<decltype(x != y), bool>::value,
148                  "return type of operator== must be bool");
149  }
150  TYPED_TEST(PCGEngineTest, RandenEngineSFINAETest) {
151    using engine_type = TypeParam;
152    using result_type = typename engine_type::result_type;
153    {
154      engine_type engine(result_type(1));
155      engine.seed(result_type(1));
156    }
157    {
158      result_type n = 1;
159      engine_type engine(n);
160      engine.seed(n);
161    }
162    {
163      engine_type engine(1);
164      engine.seed(1);
165    }
166    {
167      int n = 1;
168      engine_type engine(n);
169      engine.seed(n);
170    }
171    {
172      std::seed_seq seed_seq;
173      engine_type engine(seed_seq);
174      engine.seed(seed_seq);
175    }
176    {
177      engine_type engine{std::seed_seq()};
178      engine.seed(std::seed_seq());
179    }
180  }
181  TEST(PCG642018EngineTest, VerifyGolden) {
182    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
183        0x01070196e695f8f1, 0x703ec840c59f4493, 0xe54954914b3a44fa,
184        0x96130ff204b9285e, 0x7d9fdef535ceb21a, 0x666feed42e1219a0,
185        0x981f685721c8326f, 0xad80710d6eab4dda, 0xe202c480b037a029,
186        0x5d3390eaedd907e2, 0x0756befb39c6b8aa, 0x1fb44ba6634d62a3,
187        0x8d20423662426642, 0x34ea910167a39fb4, 0x93010b43a80d0ab6,
188        0x663db08a98fc568a, 0x720b0a1335956fae, 0x2c35483e31e1d3ba,
189        0x429f39776337409d, 0xb46d99e638687344, 0x105370b96aedcaee,
190        0x3999e92f811cff71, 0xd230f8bcb591cfc9, 0x0dce3db2ba7bdea5,
191        0xcf2f52c91eec99af, 0x2bc7c24a8b998a39, 0xbd8af1b0d599a19c,
192        0x56bc45abc66059f5, 0x170a46dc170f7f1e, 0xc25daf5277b85fad,
193        0xe629c2e0c948eadb, 0x1720a796915542ed, 0x22fb0caa4f909951,
194        0x7e0c0f4175acd83d, 0xd9fcab37ff2a860c, 0xab2280fb2054bad1,
195        0x58e8a06f37fa9e99, 0xc3a52a30b06528c7, 0x0175f773a13fc1bd,
196        0x731cfc584b00e840, 0x404cc7b2648069cb, 0x5bc29153b0b7f783,
197        0x771310a38cc999d1, 0x766a572f0a71a916, 0x90f450fb4fc48348,
198        0xf080ea3e1c7b1a0d, 0x15471a4507d66a44, 0x7d58e55a78f3df69,
199        0x0130a094576ac99c, 0x46669cb2d04b1d87, 0x17ab5bed20191840,
200        0x95b177d260adff3e, 0x025fb624b6ee4c07, 0xb35de4330154a95f,
201        0xe8510fff67e24c79, 0x132c3cbcd76ed2d3, 0x35e7cc145a093904,
202        0x9f5b5b5f81583b79, 0x3ee749a533966233, 0x4af85886cdeda8cd,
203        0x0ca5380ecb3ef3aa, 0x4f674eb7661d3192, 0x88a29aad00cd7733,
204        0x70b627ca045ffac6, 0x5912b43ea887623d, 0x95dc9fc6f62cf221,
205        0x926081a12a5c905b, 0x9c57d4cd7dfce651, 0x85ab2cbf23e3bb5d,
206        0xc5cd669f63023152, 0x3067be0fad5d898e, 0x12b56f444cb53d05,
207        0xbc2e5a640c3434fc, 0x9280bff0e4613fe1, 0x98819094c528743e,
208        0x999d1c98d829df33, 0x9ff82a012dc89242, 0xf99183ed39c8be94,
209        0xf0f59161cd421c55, 0x3c705730c2f6c48d, 0x66ad85c6e9278a61,
210        0x2a3428e4a428d5d0, 0x79207d68fd04940d, 0xea7f2b402edc8430,
211        0xa06b419ac857f63b, 0xcb1dd0e6fbc47e1c, 0x4f55229200ada6a4,
212        0x9647b5e6359c927f, 0x30bf8f9197c7efe5, 0xa79519529cc384d0,
213        0xbb22c4f339ad6497, 0xd7b9782f59d14175, 0x0dff12fff2ec0118,
214        0xa331ad8305343a7c, 0x48dad7e3f17e0862, 0x324c6fb3fd3c9665,
215        0xf0e4350e7933dfc4, 0x7ccda2f30b8b03b6, 0xa0afc6179005de40,
216        0xee65da6d063b3a30, 0xb9506f42f2bfe87a, 0xc9a2e26b0ef5baa0,
217        0x39fa9d4f495011d6, 0xbecc21a45d023948, 0x6bf484c6593f737f,
218        0x8065e0070cadc3b7, 0x9ef617ed8d419799, 0xac692cf8c233dd15,
219        0xd2ed87583c4ebb98, 0xad95ba1bebfedc62, 0x9b60b160a8264e43,
220        0x0bc8c45f71fcf25b, 0x4a78035cdf1c9931, 0x4602dc106667e029,
221        0xb335a3c250498ac8, 0x0256ebc4df20cab8, 0x0c61efd153f0c8d9,
222        0xe5d0150a4f806f88, 0x99d6521d351e7d87, 0x8d4888c9f80f4325,
223        0x106c5735c1ba868d, 0x73414881b880a878, 0x808a9a58a3064751,
224        0x339a29f3746de3d5, 0x5410d7fa4f873896, 0xd84623c81d7b8a03,
225        0x1f7c7e7a7f47f462,
226    };
227    pcg64_2018_engine engine(0);
228  #if UPDATE_GOLDEN
229    (void)kGolden;  
230    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
231      printf("0x%016lx, ", engine());
232      if (i % 3 == 2) {
233        printf("\n");
234      }
235    }
236    printf("\n\n\n");
237  #else
238    for (const auto& elem : kGolden) {
239      EXPECT_EQ(elem, engine());
240    }
241    engine.seed();
242    for (const auto& elem : kGolden) {
243      EXPECT_EQ(elem, engine());
244    }
245  #endif
246  }
247  TEST(PCG642018EngineTest, VerifyGoldenSeeded) {
248    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
249        0xb03988f1e39691ee, 0xbd2a1eb5ac31e97a, 0x8f00d6d433634d02,
250        0x1823c28d483d5776, 0x000c3ee3e1aeb74a, 0xfa82ef27a4f3df9c,
251        0xc6f382308654e454, 0x414afb1a238996c2, 0x4703a4bc252eb411,
252        0x99d64f62c8f7f654, 0xbb07ebe11a34fa44, 0x79eb06a363c06131,
253        0xf66ad3756f1c6b21, 0x130c01d5e869f457, 0x5ca2b9963aecbc81,
254        0xfef7bebc1de27e6c, 0x1d174faa5ed2cdbf, 0xd75b7a773f2bb889,
255        0xc35c872327a170a5, 0x46da6d88646a42fe, 0x4622985e0442dae2,
256        0xbe3cbd67297f1f9b, 0xe7c37b4a4798bfd1, 0x173d5dfad15a25c3,
257        0x0eb6849ba2961522, 0xb0ff7246e6700d73, 0x88cb9c42d3afa577,
258        0xb609731dbd94d917, 0xd3941cda04b40081, 0x28d140f7409bea3a,
259        0x3c96699a920a124a, 0xdb28be521958b2fd, 0x0a3f44db3d4c5124,
260        0x7ac8e60ba13b70d2, 0x75f03a41ded5195a, 0xaed10ac7c4e4825d,
261        0xb92a3b18aadb7adc, 0xda45e0081f2bca46, 0x74d39ab3753143fc,
262        0xb686038018fac9ca, 0x4cc309fe99542dbb, 0xf3e1a4fcb311097c,
263        0x58763d6fa698d69d, 0xd11c365dbecd8d60, 0x2c15d55725b1dee7,
264        0x89805f254d85658c, 0x2374c44dfc62158b, 0x9a8350fa7995328d,
265        0x198f838970cf91da, 0x96aff569562c0e53, 0xd76c8c52b7ec6e3f,
266        0x23a01cd9ae4baa81, 0x3adb366b6d02a893, 0xb3313e2a4c5b333f,
267        0x04c11230b96a5425, 0x1f7f7af04787d571, 0xaddb019365275ec7,
268        0x5c960468ccb09f42, 0x8438db698c69a44a, 0x492be1e46111637e,
269        0x9c6c01e18100c610, 0xbfe48e75b7d0aceb, 0xb5e0b89ec1ce6a00,
270        0x9d280ecbc2fe8997, 0x290d9e991ba5fcab, 0xeec5bec7d9d2a4f0,
271        0x726e81488f19150e, 0x1a6df7955a7e462c, 0x37a12d174ba46bb5,
272        0x3cdcdffd96b1b5c5, 0x2c5d5ac10661a26e, 0xa742ed18f22e50c4,
273        0x00e0ed88ff0d8a35, 0x3d3c1718cb1efc0b, 0x1d70c51ffbccbf11,
274        0xfbbb895132a4092f, 0x619d27f2fb095f24, 0x69af68200985e5c4,
275        0xbee4885f57373f8d, 0x10b7a6bfe0587e40, 0xa885e6cf2f7e5f0a,
276        0x59f879464f767550, 0x24e805d69056990d, 0x860970b911095891,
277        0xca3189954f84170d, 0x6652a5edd4590134, 0x5e1008cef76174bf,
278        0xcbd417881f2bcfe5, 0xfd49fc9d706ecd17, 0xeebf540221ebd066,
279        0x46af7679464504cb, 0xd4028486946956f1, 0xd4f41864b86c2103,
280        0x7af090e751583372, 0x98cdaa09278cb642, 0xffd42b921215602f,
281        0x1d05bec8466b1740, 0xf036fa78a0132044, 0x787880589d1ecc78,
282        0x5644552cfef33230, 0x0a97e275fe06884b, 0x96d1b13333d470b5,
283        0xc8b3cdad52d3b034, 0x091357b9db7376fd, 0xa5fe4232555edf8c,
284        0x3371bc3b6ada76b5, 0x7deeb2300477c995, 0x6fc6d4244f2849c1,
285        0x750e8cc797ca340a, 0x81728613cd79899f, 0x3467f4ee6f9aeb93,
286        0x5ef0a905f58c640f, 0x432db85e5101c98a, 0x6488e96f46ac80c2,
287        0x22fddb282625048c, 0x15b287a0bc2d4c5d, 0xa7e2343ef1f28bce,
288        0xc87ee1aa89bed09e, 0x220610107812c5e9, 0xcbdab6fcd640f586,
289        0x8d41047970928784, 0x1aa431509ec1ade0, 0xac3f0be53f518ddc,
290        0x16f4428ad81d0cbb, 0x675b13c2736fc4bb, 0x6db073afdd87e32d,
291        0x572f3ca2f1a078c6,
292    };
293    ExplicitSeedSeq seed_sequence{12, 34, 56};
294    pcg64_2018_engine engine(seed_sequence);
295  #if UPDATE_GOLDEN
296    (void)kGolden;  
297    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
298      printf("0x%016lx, ", engine());
299      if (i % 3 == 2) {
300        printf("\n");
301      }
302    }
303    printf("\n\n\n");
304  #else
305    for (const auto& elem : kGolden) {
306      EXPECT_EQ(elem, engine());
307    }
308    engine.seed(seed_sequence);
309    for (const auto& elem : kGolden) {
310      EXPECT_EQ(elem, engine());
311    }
312  #endif
313  }
314  TEST(PCG642018EngineTest, VerifyGoldenFromDeserializedEngine) {
315    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
316        0xdd425b47b4113dea, 0x1b07176479d444b0, 0x6b391027586f2e42,
317        0xa166f2b15f4a2143, 0xffb6dbd7a179ee97, 0xb2c00035365bf0b1,
318        0x8fbb518b45855521, 0xfc789a55ddf87c3b, 0x429531f0f17ff355,
319        0xbe708560d603d283, 0x5bff415175c5cb6b, 0xe813491f4ad45394,
320        0xa853f4506d55880d, 0x7e538453e568172e, 0xe101f1e098ddd0ec,
321        0x6ee31266ee4c766d, 0xa8786d92d66b39d7, 0xfee622a2acf5e5b0,
322        0x5fe8e82c102fa7b3, 0x01f10be4cdb53c9d, 0xbe0545366f857022,
323        0x12e74f010a339bca, 0xb10d85ca40d5ce34, 0xe80d6feba5054875,
324        0x2b7c1ee6d567d4ee, 0x2a9cd043bfd03b66, 0x5cfc531bd239f3f1,
325        0x1c4734e4647d70f5, 0x85a8f60f006b5760, 0x6a4239ce76dca387,
326        0x8da0f86d7339335c, 0xf055b0468551374d, 0x486e8567e9bea9a0,
327        0x4cb531b8405192dd, 0xf813b1ee3157110b, 0x214c2a664a875d8e,
328        0x74531237b29b35f7, 0xa6f0267bb77a771e, 0x64b552bff54184a4,
329        0xa2d6f7af2d75b6fc, 0x460a10018e03b5ab, 0x76fd1fdcb81d0800,
330        0x76f5f81805070d9d, 0x1fb75cb1a70b289a, 0x9dfd25a022c4b27f,
331        0x9a31a14a80528e9e, 0x910dc565ddc25820, 0xd6aef8e2b0936c10,
332        0xe1773c507fe70225, 0xe027fd7aadd632bc, 0xc1fecb427089c8b8,
333        0xb5c74c69fa9dbf26, 0x71bf9b0e4670227d, 0x25f48fad205dcfdd,
334        0x905248ec4d689c56, 0x5c2b7631b0de5c9d, 0x9f2ee0f8f485036c,
335        0xfd6ce4ebb90bf7ea, 0xd435d20046085574, 0x6b7eadcb0625f986,
336        0x679d7d44b48be89e, 0x49683b8e1cdc49de, 0x4366cf76e9a2f4ca,
337        0x54026ec1cdad7bed, 0xa9a04385207f28d3, 0xc8e66de4eba074b2,
338        0x40b08c42de0f4cc0, 0x1d4c5e0e93c5bbc0, 0x19b80792e470ae2d,
339        0x6fcaaeaa4c2a5bd9, 0xa92cb07c4238438e, 0x8bb5c918a007e298,
340        0x7cd671e944874cf4, 0x88166470b1ba3cac, 0xd013d476eaeeade6,
341        0xcee416947189b3c3, 0x5d7c16ab0dce6088, 0xd3578a5c32b13d27,
342        0x3875db5adc9cc973, 0xfbdaba01c5b5dc56, 0xffc4fdd391b231c3,
343        0x2334520ecb164fec, 0x361c115e7b6de1fa, 0xeee58106cc3563d7,
344        0x8b7f35a8db25ebb8, 0xb29d00211e2cafa6, 0x22a39fe4614b646b,
345        0x92ca6de8b998506d, 0x40922fe3d388d1db, 0x9da47f1e540f802a,
346        0x811dceebf16a25db, 0xf6524ae22e0e53a9, 0x52d9e780a16eb99d,
347        0x4f504286bb830207, 0xf6654d4786bd5cc3, 0x00bd98316003a7e1,
348        0xefda054a6ab8f5f3, 0x46cfb0f4c1872827, 0xc22b316965c0f3b2,
349        0xd1a28087c7e7562a, 0xaa4f6a094b7f5cff, 0xfe2bc853a041f7da,
350        0xe9d531402a83c3ba, 0xe545d8663d3ce4dd, 0xfa2dcd7d91a13fa8,
351        0xda1a080e52a127b8, 0x19c98f1f809c3d84, 0x2cef109af4678c88,
352        0x53462accab3b9132, 0x176b13a80415394e, 0xea70047ef6bc178b,
353        0x57bca80506d6dcdf, 0xd853ba09ff09f5c4, 0x75f4df3a7ddd4775,
354        0x209c367ade62f4fe, 0xa9a0bbc74d5f4682, 0x5dfe34bada86c21a,
355        0xc2c05bbcd38566d1, 0x6de8088e348c916a, 0x6a7001c6000c2196,
356        0xd9fb51865fc4a367, 0x12f320e444ece8ff, 0x6d56f7f793d65035,
357        0x138f31b7a865f8aa, 0x58fc68b4026b9adf, 0xcd48954b79fb6436,
358        0x27dfce4a0232af87,
359    };
360  #if UPDATE_GOLDEN
361    (void)kGolden;  
362    std::seed_seq seed_sequence{1, 2, 3};
363    pcg64_2018_engine engine(seed_sequence);
364    std::ostringstream stream;
365    stream << engine;
366    auto str = stream.str();
367    printf("%s\n\n", str.c_str());
368    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
369      printf("0x%016lx, ", engine());
370      if (i % 3 == 2) {
371        printf("\n");
372      }
373    }
374    printf("\n\n\n");
375  #else
376    pcg64_2018_engine engine;
377    std::istringstream stream(
378        "2549297995355413924 4865540595714422341 6364136223846793005 "
379        "1442695040888963407 18088519957565336995 4845369368158826708");
380    stream >> engine;
381    for (const auto& elem : kGolden) {
382      EXPECT_EQ(elem, engine());
383    }
384  #endif
385  }
386  TEST(PCG322018EngineTest, VerifyGolden) {
387    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
388        0x7a7ecbd9, 0x89fd6c06, 0xae646aa8, 0xcd3cf945, 0x6204b303, 0x198c8585,
389        0x49fce611, 0xd1e9297a, 0x142d9440, 0xee75f56b, 0x473a9117, 0xe3a45903,
390        0xbce807a1, 0xe54e5f4d, 0x497d6c51, 0x61829166, 0xa740474b, 0x031912a8,
391        0x9de3defa, 0xd266dbf1, 0x0f38bebb, 0xec3c4f65, 0x07c5057d, 0xbbce03c8,
392        0xfd2ac7a8, 0xffcf4773, 0x5b10affb, 0xede1c842, 0xe22b01b7, 0xda133c8c,
393        0xaf89b0f4, 0x25d1b8bc, 0x9f625482, 0x7bfd6882, 0x2e2210c0, 0x2c8fb9a6,
394        0x42cb3b83, 0x40ce0dab, 0x644a3510, 0x36230ef2, 0xe2cb6d43, 0x1012b343,
395        0x746c6c9f, 0x36714cf8, 0xed1f5026, 0x8bbbf83e, 0xe98710f4, 0x8a2afa36,
396        0x09035349, 0x6dc1a487, 0x682b634b, 0xc106794f, 0x7dd78beb, 0x628c262b,
397        0x852fb232, 0xb153ac4c, 0x4f169d1b, 0xa69ab774, 0x4bd4b6f2, 0xdc351dd3,
398        0x93ff3c8c, 0xa30819ab, 0xff07758c, 0x5ab13c62, 0xd16d7fb5, 0xc4950ffa,
399        0xd309ae49, 0xb9677a87, 0x4464e317, 0x90dc44f1, 0xc694c1d4, 0x1d5e1168,
400        0xadf37a2d, 0xda38990d, 0x1ec4bd33, 0x36ca25ce, 0xfa0dc76a, 0x968a9d43,
401        0x6950ac39, 0xdd3276bc, 0x06d5a71e, 0x1f6f282d, 0x5c626c62, 0xdde3fc31,
402        0x152194ce, 0xc35ed14c, 0xb1f7224e, 0x47f76bb8, 0xb34fdd08, 0x7011395e,
403        0x162d2a49, 0x0d1bf09f, 0x9428a952, 0x03c5c344, 0xd3525616, 0x7816fff3,
404        0x6bceb8a8, 0x8345a081, 0x366420fd, 0x182abeda, 0x70f82745, 0xaf15ded8,
405        0xc7f52ca2, 0xa98db9c5, 0x919d99ba, 0x9c376c1c, 0xed8d34c2, 0x716ae9f5,
406        0xef062fa5, 0xee3b6c56, 0x52325658, 0x61afa9c3, 0xfdaf02f0, 0x961cf3ab,
407        0x9f291565, 0x4fbf3045, 0x0590c899, 0xde901385, 0x45005ffb, 0x509db162,
408        0x262fa941, 0x4c421653, 0x4b17c21e, 0xea0d1530, 0xde803845, 0x61bfd515,
409        0x438523ef,
410    };
411    pcg32_2018_engine engine(0);
412  #if UPDATE_GOLDEN
413    (void)kGolden;  
414    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
415      printf("0x%08x, ", engine());
416      if (i % 6 == 5) {
417        printf("\n");
418      }
419    }
420    printf("\n\n\n");
421  #else
422    for (const auto& elem : kGolden) {
423      EXPECT_EQ(elem, engine());
424    }
425    engine.seed();
426    for (const auto& elem : kGolden) {
427      EXPECT_EQ(elem, engine());
428    }
429  #endif
430  }
431  TEST(PCG322018EngineTest, VerifyGoldenSeeded) {
432    constexpr uint32_t kGolden[kNumGoldenOutputs] = {
433        0x60b5a64c, 0x978502f9, 0x80a75f60, 0x241f1158, 0xa4cd1dbb, 0xe7284017,
434        0x3b678da5, 0x5223ec99, 0xe4bdd5d9, 0x72190e6d, 0xe6e702c9, 0xff80c768,
435        0xcf126ed3, 0x1fbd20ab, 0x60980489, 0xbc72bf89, 0x407ac6c0, 0x00bf3c51,
436        0xf9087897, 0x172e4eb6, 0xe9e4f443, 0x1a6098bf, 0xbf44f8c2, 0xdd84a0e5,
437        0xd9a52364, 0xc0e2e786, 0x061ae2ba, 0x9facb8e3, 0x6109432d, 0xd4e0a013,
438        0xbd8eb9a6, 0x7e86c3b6, 0x629c0e68, 0x05337430, 0xb495b9f4, 0x11ccd65d,
439        0xb578db25, 0x66f1246d, 0x6ef20a7f, 0x5e429812, 0x11772130, 0xb944b5c2,
440        0x01624128, 0xa2385ab7, 0xd3e10d35, 0xbe570ec3, 0xc951656f, 0xbe8944a0,
441        0x7be41062, 0x5709f919, 0xd745feda, 0x9870b9ae, 0xb44b8168, 0x19e7683b,
442        0xded8017f, 0xc6e4d544, 0x91ae4225, 0xd6745fba, 0xb992f284, 0x65b12b33,
443        0xa9d5fdb4, 0xf105ce1a, 0x35ca1a6e, 0x2ff70dd0, 0xd8335e49, 0xfb71ddf2,
444        0xcaeabb89, 0x5c6f5f84, 0x9a811a7d, 0xbcecbbd1, 0x0f661ba0, 0x9ad93b9d,
445        0xedd23e0b, 0x42062f48, 0xd38dd7e4, 0x6cd63c9c, 0x640b98ae, 0x4bff5653,
446        0x12626371, 0x13266017, 0xe7a698d8, 0x39c74667, 0xe8fdf2e3, 0x52803bf8,
447        0x2af6895b, 0x91335b7b, 0x699e4961, 0x00a40fff, 0x253ff2b6, 0x4a6cf672,
448        0x9584e85f, 0xf2a5000c, 0x4d58aba8, 0xb8513e6a, 0x767fad65, 0x8e326f9e,
449        0x182f15a1, 0x163dab52, 0xdf99c780, 0x047282a1, 0xee4f90dd, 0xd50394ae,
450        0x6c9fd5f0, 0xb06a9194, 0x387e3840, 0x04a9487b, 0xf678a4c2, 0xd0a78810,
451        0xd502c97e, 0xd6a9b12a, 0x4accc5dc, 0x416ed53e, 0x50411536, 0xeeb89c24,
452        0x813a7902, 0x034ebca6, 0xffa52e7c, 0x7ecd3d0e, 0xfa37a0d2, 0xb1fbe2c1,
453        0xb7efc6d1, 0xefa4ccee, 0xf6f80424, 0x2283f3d9, 0x68732284, 0x94f3b5c8,
454        0xbbdeceb9,
455    };
456    ExplicitSeedSeq seed_sequence{12, 34, 56};
457    pcg32_2018_engine engine(seed_sequence);
458  #if UPDATE_GOLDEN
459    (void)kGolden;  
460    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
461      printf("0x%08x, ", engine());
462      if (i % 6 == 5) {
463        printf("\n");
464      }
465    }
466    printf("\n\n\n");
467  #else
468    for (const auto& elem : kGolden) {
469      EXPECT_EQ(elem, engine());
470    }
471    engine.seed(seed_sequence);
472    for (const auto& elem : kGolden) {
473      EXPECT_EQ(elem, engine());
474    }
475  #endif
476  }
477  TEST(PCG322018EngineTest, VerifyGoldenFromDeserializedEngine) {
478    constexpr uint64_t kGolden[kNumGoldenOutputs] = {
479        0x780f7042, 0xba137215, 0x43ab6f22, 0x0cb55f46, 0x44b2627d, 0x835597af,
480        0xea973ea1, 0x0d2abd35, 0x4fdd601c, 0xac4342fe, 0x7db7e93c, 0xe56ebcaf,
481        0x3596470a, 0x7770a9ad, 0x9b893320, 0x57db3415, 0xb432de54, 0xa02baf71,
482        0xa256aadb, 0x88921fc7, 0xa35fa6b3, 0xde3eca46, 0x605739a7, 0xa890b82b,
483        0xe457b7ad, 0x335fb903, 0xeb06790c, 0xb3c54bf6, 0x6141e442, 0xa599a482,
484        0xb78987cc, 0xc61dfe9d, 0x0f1d6ace, 0x17460594, 0x8f6a5061, 0x083dc354,
485        0xe9c337fb, 0xcfd105f7, 0x926764b6, 0x638d24dc, 0xeaac650a, 0x67d2cb9c,
486        0xd807733c, 0x205fc52e, 0xf5399e2e, 0x6c46ddcc, 0xb603e875, 0xce113a25,
487        0x3c8d4813, 0xfb584db8, 0xf6d255ff, 0xea80954f, 0x42e8be85, 0xb2feee72,
488        0x62bd8d16, 0x1be4a142, 0x97dca1a4, 0xdd6e7333, 0xb2caa20e, 0xa12b1588,
489        0xeb3a5a1a, 0x6fa5ba89, 0x077ea931, 0x8ddb1713, 0x0dd03079, 0x2c2ba965,
490        0xa77fac17, 0xc8325742, 0x8bb893bf, 0xc2315741, 0xeaceee92, 0x81dd2ee2,
491        0xe5214216, 0x1b9b8fb2, 0x01646d03, 0x24facc25, 0xd8c0e0bb, 0xa33fe106,
492        0xf34fe976, 0xb3b4b44e, 0x65618fed, 0x032c6192, 0xa9dd72ce, 0xf391887b,
493        0xf41c6a6e, 0x05c4bd6d, 0x37fa260e, 0x46b05659, 0xb5f6348a, 0x62d26d89,
494        0x39f6452d, 0xb17b30a2, 0xbdd82743, 0x38ecae3b, 0xfe90f0a2, 0xcb2d226d,
495        0xcf8a0b1c, 0x0eed3d4d, 0xa1f69cfc, 0xd7ac3ba5, 0xce9d9a6b, 0x121deb4c,
496        0x4a0d03f3, 0xc1821ed1, 0x59c249ac, 0xc0abb474, 0x28149985, 0xfd9a82ba,
497        0x5960c3b2, 0xeff00cba, 0x6073aa17, 0x25dc0919, 0x9976626e, 0xdd2ccc33,
498        0x39ecb6ec, 0xc6e15d13, 0xfac94cfd, 0x28cfd34f, 0xf2d2c32d, 0x51c23d08,
499        0x4fdb2f48, 0x97baa807, 0xf2c1004c, 0xc4ae8136, 0x71f31c94, 0x8c92d601,
500        0x36caf5cd,
501    };
502  #if UPDATE_GOLDEN
503    (void)kGolden;  
504    std::seed_seq seed_sequence{1, 2, 3};
505    pcg32_2018_engine engine(seed_sequence);
506    std::ostringstream stream;
507    stream << engine;
508    auto str = stream.str();
509    printf("%s\n\n", str.c_str());
510    for (size_t i = 0; i < kNumGoldenOutputs; ++i) {
511      printf("0x%08x, ", engine());
512      if (i % 6 == 5) {
513        printf("\n");
514      }
515    }
516    printf("\n\n\n");
517    EXPECT_FALSE(true);
518  #else
519    pcg32_2018_engine engine;
520    std::istringstream stream(
521        "6364136223846793005 1442695040888963407 6537028157270659894");
522    stream >> engine;
523    for (const auto& elem : kGolden) {
524      EXPECT_EQ(elem, engine());
525    }
526  #endif
527  }
528  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-randen_engine_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-pcg_engine_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>112    using T = typename E::result_type;
113    static_assert(std::is_copy_constructible<E>::value,
114                  "randen_engine must be copy constructible");
115    static_assert(absl::is_copy_assignable<E>::value,
116                  "randen_engine must be copy assignable");
117    static_assert(std::is_move_constructible<E>::value,
</pre></code></div>
                <div class="column column_space"><pre><code>110    using T = typename E::result_type;
111    static_assert(std::is_copy_constructible<E>::value,
112                  "engine_type must be copy constructible");
113    static_assert(absl::is_copy_assignable<E>::value,
114                  "engine_type must be copy assignable");
115    static_assert(std::is_move_constructible<E>::value,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    