
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6694766420793816%, Tokens: 10</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
<span onclick='openModal()' class='match'>903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
</span>909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-pi.cpp</h3>
            <pre><code>1  #include "pi.h"
2  void TPiRec::AddFldNmVal(
3   TPiDb* PiDb, const TStr& FldNm, const TStr& FldVal){
4    int FldNmCId=PiDb->AddCStr(FldNm);
5    int FldValCId=PiDb->AddCStr(FldVal);
6    FldNmCIdToValCIdH.AddDat(FldNmCId, FldValCId);
7  }
8  bool TPiRec::IsGetFldNmVal(const int& FldNmCId, TInt& FldValCId) const {
9    return FldNmCIdToValCIdH.IsKeyGetDat(FldNmCId, FldValCId);
10  }
11  void TPiRec::GetFldNmVal(
12   const int& FldN, int& FldNmCId, int& FldValCId) const {
13    FldNmCId=FldNmCIdToValCIdH.GetKey(FldN);
14    FldValCId=FldNmCIdToValCIdH[FldN];
15  }
16  void TPiRec::GetFldNmVal(
17   const TPiDb* PiDb, const int& FldN, TStr& FldNm, TStr& FldVal) const {
18    int FldNmCId=FldNmCIdToValCIdH.GetKey(FldN);
19    int FldValCId=FldNmCIdToValCIdH[FldN];
20    FldNm=PiDb->GetCStr(FldNmCId);
21    FldVal=PiDb->GetCStr(FldValCId);
22  }
23  TStr TPiRec::GetFldVal(
24   const TPiDb* PiDb, const TStr& FldNm, const TStr& DfVal) const {
25    int FldNmCId=PiDb->GetCId(FldNm);
26    int FldId;
27    if (FldNmCIdToValCIdH.IsKey(FldNmCId, FldId)){
28      int FldValCId=FldNmCIdToValCIdH[FldId];
29      return PiDb->GetCStr(FldValCId);
30    } else {
31      return DfVal;
32    }
33  }
34  TStr TPiRec::GetNrMoneyStr(const TStr& MoneyStr){
35    const TStr MEuroStr=" million euro";
36    const TStr EuroStr=" euro";
37    TStr NrMoneyStr;
38    if (MoneyStr.IsSuffix(MEuroStr)){
39      TStr NumStr=MoneyStr.GetSubStr(0, MoneyStr.Len()-MEuroStr.Len()-1);
40      if (NumStr.IsFlt()){
41        NrMoneyStr=TFlt::GetStr(NumStr.GetFlt(), "%8.2fMeuro");
42      } else {
43        NrMoneyStr="Unknown";
44      }
45    } else
46    if (MoneyStr.IsSuffix(EuroStr)){
47      TStr NumStr=MoneyStr.GetSubStr(0, MoneyStr.Len()-EuroStr.Len()-1);
48      if (NumStr.IsFlt()){
49        NrMoneyStr=TFlt::GetStr(NumStr.GetFlt()/1000000.0, "%8.2fMeuro");
50      } else {
51        NrMoneyStr="Unknown";
52      }
53    } else {
54      NrMoneyStr="Unknown";
55    }
56    return NrMoneyStr;
57  }
58  TStr TPiRec::GetNrDurationStr(const TStr& DurationStr){
59    const TStr MonthsStr=" months";
60    TStr NrDurationStr;
61    if (DurationStr.IsSuffix(MonthsStr)){
62      TStr NumStr=DurationStr.GetSubStr(0, DurationStr.Len()-MonthsStr.Len()-1);
63      if (NumStr.IsInt()){
64        NrDurationStr=TInt::GetStr(NumStr.GetInt(), "%3d months");
65      } else {
66        NrDurationStr=DurationStr;
67      }
68    } else {
69      NrDurationStr=DurationStr;
70    }
71    return NrDurationStr;
72  }
73  TPiGraph::TPiGraph(const PPiDb& PiDb){
74    printf("Generating Graphs...\n");
75    printf("  ...collecting values\n");
76    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
77      PPiRec Proj=PiDb->GetProj(ProjN);
78      CallNmH.AddKey(Proj->GetCallNm(PiDb()));
79      SubProgNmH.AddKey(Proj->GetProjSubProg(PiDb()));
80      TStr ProjRef=Proj->GetProjRef(PiDb());
81      int ProjOrgs=PiDb->GetProjOrgs(ProjRef);
82      for (int OrgN=0; OrgN<ProjOrgs; OrgN++){
83        PPiRec Org=PiDb->GetProjOrg(ProjRef, OrgN);
84        CountryNmH.AddKey(Org->GetCountryNm(PiDb()));
85        OrgNmH.AddKey(Org->GetOrgNm(PiDb()));
86      }
87    }
88    TStrV CallNmV; CallNmH.GetKeyV(CallNmV); CallNmV.Sort();
89    TStrV SubProgNmV; SubProgNmH.GetKeyV(SubProgNmV); SubProgNmV.Sort();
90    TStrV CountryNmV; CountryNmH.GetKeyV(CountryNmV); CountryNmV.Sort();
91    TStrV OrgNmV; OrgNmH.GetKeyV(OrgNmV); OrgNmV.Sort();
92    printf("  ...organization & countries\n");
93    THash<TStr, TStrH> CallNmToOrgNmHH;
94    THash<TStr, TStrH> SubProgNmToOrgNmHH;
95    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
96      PPiRec Proj=PiDb->GetProj(ProjN);
97      TStr CallNm=Proj->GetCallNm(PiDb());
98      TStr SubProgNm=Proj->GetProjSubProg(PiDb());
99      TStr ProjRef=Proj->GetProjRef(PiDb());
100      int ProjOrgs=PiDb->GetProjOrgs(ProjRef);
<span onclick='openModal()' class='match'>101      for (int OrgN1=0; OrgN1<ProjOrgs; OrgN1++){
102        PPiRec Org1=PiDb->GetProjOrg(ProjRef, OrgN1);
103        TStr OrgNm1=Org1->GetOrgNm(PiDb());
104        TStr CountryNm1=Org1->GetCountryNm(PiDb());
105        CallNmToOrgNmHH.AddDat(CallNm).AddKey(OrgNm1);
106        SubProgNmToOrgNmHH.AddDat(SubProgNm).AddKey(OrgNm1);
107        for (int OrgN2=OrgN1+1; OrgN2<ProjOrgs; OrgN2++){
108          PPiRec Org2=PiDb->GetProjOrg(ProjRef, OrgN2);
</span>109          TStr OrgNm2=Org2->GetOrgNm(PiDb());
110          TStr CountryNm2=Org2->GetCountryNm(PiDb());
111          if (OrgNm1<OrgNm2){
112            OrgNmPrToFqH.AddDat(TStrPr(OrgNm1, OrgNm2))++;
113            CallNmToOrgNmPrToFqH.AddDat(CallNm).AddDat(TStrPr(OrgNm1, OrgNm2))++;
114            SubProgNmToOrgNmPrToFqH.AddDat(SubProgNm).AddDat(TStrPr(OrgNm1, OrgNm2))++;
115            if (CountryNm1==CountryNm2){
116              CountryNmToOrgNmPrToFqH.AddDat(CountryNm1).AddDat(TStrPr(OrgNm1, OrgNm2))++;}
117          } else {
118            OrgNmPrToFqH.AddDat(TStrPr(OrgNm2, OrgNm1))++;
119            CallNmToOrgNmPrToFqH.AddDat(CallNm).AddDat(TStrPr(OrgNm2, OrgNm1))++;
120            SubProgNmToOrgNmPrToFqH.AddDat(SubProgNm).AddDat(TStrPr(OrgNm2, OrgNm1))++;
121            if (CountryNm1==CountryNm2){
122              CountryNmToOrgNmPrToFqH.AddDat(CountryNm1).AddDat(TStrPr(OrgNm2, OrgNm1))++;}
123          }
124          if (CountryNm1<CountryNm2){CountryNmPrToFqH.AddDat(TStrPr(CountryNm1, CountryNm2))++;}
125          else {CountryNmPrToFqH.AddDat(TStrPr(CountryNm2, CountryNm1))++;}
126        }
127      }
128    }
129    printf("  ...calls\n");
130    for (int CallNmN1=0; CallNmN1<CallNmV.Len(); CallNmN1++){
131      for (int CallNmN2=CallNmN1+1; CallNmN2<CallNmV.Len(); CallNmN2++){
132        TStrV OrgNmV1; CallNmToOrgNmHH.GetDat(CallNmV[CallNmN1]).GetKeyV(OrgNmV1);
133        TStrV OrgNmV2; CallNmToOrgNmHH.GetDat(CallNmV[CallNmN2]).GetKeyV(OrgNmV2);
134        OrgNmV1.Sort(); OrgNmV2.Sort(); OrgNmV1.Intrs(OrgNmV2);
135        CallNmPrToFqH.AddDat(
136         TStrPr(CallNmV[CallNmN1], CallNmV[CallNmN2]), OrgNmV1.Len());
137      }
138    }
139    printf("  ...subprogrames\n");
140    for (int SubProgNmN1=0; SubProgNmN1<SubProgNmV.Len(); SubProgNmN1++){
141      if (!SubProgNmToOrgNmHH.IsKey(SubProgNmV[SubProgNmN1])){continue;}
142      for (int SubProgNmN2=SubProgNmN1+1; SubProgNmN2<SubProgNmV.Len(); SubProgNmN2++){
143        if (!SubProgNmToOrgNmHH.IsKey(SubProgNmV[SubProgNmN2])){continue;}
144        TStrV OrgNmV1; SubProgNmToOrgNmHH.GetDat(SubProgNmV[SubProgNmN1]).GetKeyV(OrgNmV1);
145        TStrV OrgNmV2; SubProgNmToOrgNmHH.GetDat(SubProgNmV[SubProgNmN2]).GetKeyV(OrgNmV2);
146        OrgNmV1.Sort(); OrgNmV2.Sort(); OrgNmV1.Intrs(OrgNmV2);
147        SubProgNmPrToFqH.AddDat(
148         TStrPr(SubProgNmV[SubProgNmN1], SubProgNmV[SubProgNmN2]), OrgNmV1.Len());
149      }
150    }
151    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
152      PPiRec Org=PiDb->GetOrg(OrgN);
153      TStr OrgNm=Org->GetOrgNm(PiDb());
154      TStr OrgType=Org->GetOrgType(PiDb());
155      TStr OrgSME=Org->GetSME(PiDb());
156      int OrgColor=TGksColor::GetCyan().GetArgbVal();
157      if (OrgType=="REC"){OrgColor=TGksColor::GetBlue().GetArgbVal();}
158      else if (OrgType=="GOV"){OrgColor=TGksColor::GetCyan().GetArgbVal();}
159      else if (OrgType=="HES"){OrgColor=TGksColor::GetGreen().GetArgbVal();}
160      else if (OrgType=="PRI"){OrgColor=TGksColor::GetRed().GetArgbVal();}
161      else if (OrgType=="IND"){
162        OrgColor=TGksColor::GetBlack().GetArgbVal();
163        if (OrgSME=="Yes"){OrgColor=TGksColor::GetYellow().GetArgbVal();}
164      } else {
165        OrgColor=TGksColor::GetCyan().GetArgbVal();
166      }
167      OrgNmToColorH.AddDat(OrgNm, OrgColor);
168    }
169    printf("Done.\n");
170  }
171  PGraph TPiGraph::GetDistTree(const PGraph& Graph, const TStr& StartVNm){
172    PGraph DstTree=TGraph::New();
173    PVrtx StartNode=new TGVrtx(StartVNm);
174    DstTree->AddVrtx(StartNode);
175    IAssert(Graph->IsVrtx(StartVNm));
176    int StartVId=Graph->GetVrtx(StartVNm)->GetVId();
177    TIntV VDistV(Graph->GetVrtxs()); VDistV.PutAll(-1);
178    TIntPrQ OpenVIdDistPrQ; OpenVIdDistPrQ.Push(TIntPr(StartVId, 0));
179    VDistV[StartVId]=0;
180    while (!OpenVIdDistPrQ.Empty()){
181      int VId=OpenVIdDistPrQ.Top().Val1;
182      int VDist=OpenVIdDistPrQ.Top().Val2;
183      OpenVIdDistPrQ.Pop();
184      IAssert(VDistV[VId]==VDist);
185      PVrtx Vrtx=Graph->GetVrtx(VId);
186      PVrtx SrcNode;
187      if (DstTree->GetVrtxs()==1){SrcNode=DstTree->GetVrtx(Vrtx->GetVNm());}
188      else {SrcNode=DstTree->GetVrtx(TStr("_")+Vrtx->GetVNm());}
189      int OutEIds=Vrtx->GetOutEIds();
190      for (int EIdN=0; EIdN<OutEIds; EIdN++){
191        int EId=Vrtx->GetOutEId(EIdN);
192        PEdge Edge=Graph->GetEdge(EId);
193        int OtherVId=Edge->GetOtherVId(Vrtx);
194        TStr OtherVNm=Graph->GetVrtx(OtherVId)->GetVNm();
195        if (VDistV[OtherVId]==-1){
196          OpenVIdDistPrQ.Push(TIntPr(OtherVId, VDist+1));
197          VDistV[OtherVId]=VDist+1;
198          PVrtx DstNode=TGVrtx::New(TStr("_")+OtherVNm);
199          DstTree->AddVrtx(DstNode);
200          TStr ENm=TInt::GetStr(OtherVId);
201          PEdge Branch=TGEdge::New(SrcNode, DstNode, TStr("_")+ENm);
202          DstTree->AddEdge(Branch);
203        }
204      }
205    }
206    return DstTree;
207  }
208  PGraph TPiGraph::GetGraph(
209   const TStrPrIntH& StrPrToFqH, const TStrIntH& StrToColorH,
210   const double& MxWgtSumPrc, const int& MxVrtxs){
211    double WgtSum=0;
212    for (int StrPrN=0; StrPrN<StrPrToFqH.Len(); StrPrN++){
213      WgtSum+=StrPrToFqH[StrPrN];
214    }
215    double MxWgtSum=WgtSum*MxWgtSumPrc;
216    TIntStrPrPrV FqStrPrPrV; StrPrToFqH.GetDatKeyPrV(FqStrPrPrV);
217    FqStrPrPrV.Sort(false);
218    double WgtSumSF=0; int MxStrPrN=-1; int MnFq=0; int MxFq=0;
219    TStrH StrH;
220    for (int StrPrN=0; StrPrN<FqStrPrPrV.Len(); StrPrN++){
221      if (WgtSumSF>MxWgtSum){break;}
222      if ((MxVrtxs!=-1)&&(StrH.Len()>MxVrtxs)){break;}
223      MxStrPrN=StrPrN;
224      StrH.AddKey(FqStrPrPrV[StrPrN].Val2.Val1);
225      StrH.AddKey(FqStrPrPrV[StrPrN].Val2.Val2);
226      int Fq=FqStrPrPrV[StrPrN].Val1;
227      WgtSumSF+=Fq;
228      if ((StrPrN==0)||(Fq<MnFq)){MnFq=Fq;}
229      if ((StrPrN==0)||(Fq>MxFq)){MxFq=Fq;}
230    }
231    TStrV StrV; StrH.GetKeyV(StrV);
232    PGraph Graph=TGGraph::New();
233    THash<TStr, PVrtx> StrToVrtxH;
234    for (int StrN=0; StrN<StrV.Len(); StrN++){
235      PVrtx Vrtx=new TGVrtx(StrV[StrN]);
236      Graph->AddVrtx(Vrtx);
237      StrToVrtxH.AddDat(StrV[StrN], Vrtx);
238      if (StrToColorH.IsKey(StrV[StrN])){
239        Vrtx->PutColor(StrToColorH.GetDat(StrV[StrN]));
240      }
241    }
242    for (int StrPrN=0; StrPrN<=MxStrPrN; StrPrN++){
243      TStr Str1=FqStrPrPrV[StrPrN].Val2.Val1;
244      TStr Str2=FqStrPrPrV[StrPrN].Val2.Val2;
245      if (Str1==Str2){continue;}
246      PVrtx Vrtx1=StrToVrtxH.GetDat(Str1);
247      PVrtx Vrtx2=StrToVrtxH.GetDat(Str2);
248      int Fq=FqStrPrPrV[StrPrN].Val1;
249      TStr EdgeNm=TInt::GetStr(Fq);
250      PEdge Edge=new TGEdge(Vrtx1, Vrtx2, EdgeNm, false);
251      Graph->AddEdge(Edge);
252      int Width=int(1+10*((double(Fq)-MnFq)/(MxFq-MnFq+1)));
253      Edge->PutWidth(Width);
254      Edge->PutWgt(Fq);
255    }
256    return Graph;
257  }
258  PMom TPiGraph::GetDistMom(const PGraph& Graph, const int& StartVId){
259    PMom DistMom=TMom::New();
260    TIntV VDistV(Graph->GetVrtxs()); VDistV.PutAll(-1);
261    TIntPrQ OpenVIdDistPrQ; OpenVIdDistPrQ.Push(TIntPr(StartVId, 0));
262    VDistV[StartVId]=0;
263    while (!OpenVIdDistPrQ.Empty()){
264      int VId=OpenVIdDistPrQ.Top().Val1;
265      int VDist=OpenVIdDistPrQ.Top().Val2;
266      OpenVIdDistPrQ.Pop();
267      IAssert(VDistV[VId]==VDist);
268      PVrtx Vrtx=Graph->GetVrtx(VId);
269      int OutEdges=Vrtx->GetOutEIds();
270      for (int OutEIdN=0; OutEIdN<OutEdges; OutEIdN++){
271        int EId=Vrtx->GetOutEId(OutEIdN);
272        PEdge Edge=Graph->GetEdge(EId);
273        int OutVId=Edge->GetOtherVId(Vrtx);
274        if (VDistV[OutVId]==-1){
275          OpenVIdDistPrQ.Push(TIntPr(OutVId, VDist+1));
276          VDistV[OutVId]=VDist+1;
277          DistMom->Add(VDist+1);
278        }
279      }
280    }
281    DistMom->Def();
282    return DistMom;
283  }
284  void TPiGraph::GetConnectedness(
285   const PGraph& Graph, const TStr& TxtFNm, const TStr& TabFNm){
286    int Vrtxs=Graph->GetVrtxs();
287    typedef TTriple<PMom, TFlt, TInt> TMomDistVIdTr;
288    TVec<TMomDistVIdTr> MomDistVIdV(Vrtxs, 0);
289    PMom AllVrtxDistMom=TMom::New();
290    for (int VId=0; VId<Vrtxs; VId++){
291      printf("%d/%d\r", 1+VId, Vrtxs);
292      PVrtx Vrtx=Graph->GetVrtx(VId);
293      PMom VrtxDistMom=GetDistMom(Graph, VId);
294      double VrtxDistMean=0;
295      if (VrtxDistMom->IsUsable()){
296        VrtxDistMean=VrtxDistMom->GetMean();}
297      MomDistVIdV.Add(TMomDistVIdTr(VrtxDistMom, -VrtxDistMean, VId));
298      AllVrtxDistMom->Add(VrtxDistMean);
299    }
300    AllVrtxDistMom->Def();
301    printf("\n");
302    MomDistVIdV.Sort(false);
303    TFOut TxtFOut(TxtFNm); FILE* fTxtOut=TxtFOut.GetFileId();
304    TFOut TabFOut(TabFNm); FILE* fTabOut=TabFOut.GetFileId();
305    if (AllVrtxDistMom->IsUsable()){
306      fprintf(fTxtOut, "*** Average distance between vertices: %.3f\n",
307       AllVrtxDistMom->GetMean());
308    }
309    fprintf(fTxtOut, "*** Vertices by average distance to the rest of the graph\n");
310    fprintf(fTabOut, "Rank\tConnectedness\tName\n");
311    double MxVrtxMeanDistSF=0;
312    for (int VIdN=0; VIdN<MomDistVIdV.Len(); VIdN++){
313      PMom VrtxDistMom=MomDistVIdV[VIdN].Val1;
314      double VrtxMeanDist=-MomDistVIdV[VIdN].Val2;
315      int VId=MomDistVIdV[VIdN].Val3;
316      PVrtx Vrtx=Graph->GetVrtx(VId);
317      fprintf(fTxtOut, "%4d. %4.2f avg.dist. '%s'\n",
318       1+VIdN, VrtxMeanDist, Vrtx->GetVNm().CStr());
319      if ((VIdN==0)||(VrtxMeanDist>=MxVrtxMeanDistSF)){
320        fprintf(fTabOut, "%d\t%.2f\t%s\n",
321         1+VIdN, VrtxMeanDist, Vrtx->GetVNm().CStr());
322        MxVrtxMeanDistSF=VrtxMeanDist;
323      }
324    }
325    fprintf(fTxtOut, "\n");
326    fprintf(fTxtOut, "\n");
327    printf("Done.\n");
328  }
329  void TPiGraph::GetConnComps(const PGraph& Graph, const TStr& FNm){
330    int Vrtxs=Graph->GetVrtxs();
331    TIntV VrtxMarkV(Vrtxs); VrtxMarkV.PutAll(-1);
332    int ConnComps=0; int NonSingleConnComps=0; TIntV ConnCompLenV;
333    forever{
334      int StartVId=VrtxMarkV.SearchForw(-1);
335      if (StartVId==-1){break;}
336      int ConnCompN=ConnComps; ConnComps++; ConnCompLenV.Add(0);
337      TIntQ OpenVIdQ; OpenVIdQ.Push(StartVId);
338      while (!OpenVIdQ.Empty()){
339        int VId=OpenVIdQ.Top(); OpenVIdQ.Pop();
340        PVrtx Vrtx=Graph->GetVrtx(VId);
341        IAssert((VrtxMarkV[VId]==-1)||(VrtxMarkV[VId]==ConnCompN));
342        if (VrtxMarkV[VId]==-1){
343          VrtxMarkV[VId]=ConnCompN;
344          ConnCompLenV[ConnCompN]++;
345          int OutEdges=Vrtx->GetOutEIds();
346          for (int OutEIdN=0; OutEIdN<OutEdges; OutEIdN++){
347            int EId=Vrtx->GetOutEId(OutEIdN);
348            PEdge Edge=Graph->GetEdge(EId);
349            int OutVId=Edge->GetOtherVId(Vrtx);
350            PVrtx OutVrtx=Graph->GetVrtx(OutVId);
351            TStr OutVrtxNm=OutVrtx->GetVNm();
352            IAssert((VrtxMarkV[OutVId]==-1)||(VrtxMarkV[OutVId]==ConnCompN));
353            if (VrtxMarkV[OutVId]==-1){
354              OpenVIdQ.Push(OutVId);
355            }
356          }
357        }
358      }
359      if (ConnCompLenV[ConnCompN]>1){
360        NonSingleConnComps++;}
361    }
362    TIntStrVH ConnCompNToVrtxNmVH;
363    for (int VId=0; VId<Vrtxs; VId++){
364      int ConnCompN=VrtxMarkV[VId];
365      int ConnCompLen=ConnCompLenV[ConnCompN];
366      if (ConnCompLen>1){
367        PVrtx Vrtx=Graph->GetVrtx(VId);
368        ConnCompNToVrtxNmVH.AddDat(ConnCompN).Add(Vrtx->GetVNm());}
369    }
370    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
371    fprintf(fOut, "*** All Connected-Components: %d\n", ConnComps);
372    fprintf(fOut, "*** Non-Single Connected-Components: %d\n", NonSingleConnComps);
373    fprintf(fOut, "\n");
374    for (int ConnCompP=0; ConnCompP<ConnCompNToVrtxNmVH.Len(); ConnCompP++){
375      int ConnCompN=ConnCompNToVrtxNmVH.GetKey(ConnCompP);
376      int ConnCompLen=ConnCompLenV[ConnCompN];
377      TStrV& VrtxNmV=ConnCompNToVrtxNmVH[ConnCompP];
378      VrtxNmV.Sort();
379      fprintf(fOut, "*** Connected component %d (%d organizations)\n",
380       1+ConnCompP, ConnCompLen);
381      for (int VrtxNmN=0; VrtxNmN<VrtxNmV.Len(); VrtxNmN++){
382        PVrtx Vrtx=Graph->GetVrtx(VrtxNmV[VrtxNmN]);
383        fprintf(fOut, "'%s'\n",
384         Vrtx->GetVNm().CStr());
385      }
386      fprintf(fOut, "\n");
387    }
388  }
389  void TPiDb::GetCStrV(const TIntH& StrCIdH, TStrV& StrV) const {
390    TIntV StrCIdV; StrCIdH.GetKeyV(StrCIdV);
391    StrV.Clr();
392    for (int StrN=0; StrN<StrCIdV.Len(); StrN++){
393      int StrCId=StrCIdV[StrN];
394      TStr Str=GetCStr(StrCId);
395      StrV.Add(Str);
396    }
397    StrV.Sort();
398  }
399  double TPiDb::GetOrgFunding(const TStr& OrgNm) const {
400    const TIntV& ProjRefCIdV=OrgCNmToProjCRefVH.GetDat(GetCId(OrgNm));
401    double Funding=0;
402    for (int ProjN=0; ProjN<ProjRefCIdV.Len(); ProjN++){
403      TStr ProjRef=GetCStr(ProjRefCIdV[ProjN]);
404      PPiRec Proj=GetProj(ProjRef);
405      TStr ProjFundingStr=Proj->GetProjFund(this);
406      TStr MMoneyStr; TStr EuroStr;
407      ProjFundingStr.SplitOnCh(MMoneyStr, 'M', EuroStr);
408      if (MMoneyStr.IsFlt()&&(EuroStr=="euro")){
409        Funding+=MMoneyStr.GetFlt()/GetProjOrgs(ProjRef);
410      }
411    }
412    return Funding;
413  }
414  int TPiDb::GetPrimeContrs(const TStr& OrgNm) const {
415    int PrimeContrs=0;
416    for (int ProjN=0; ProjN<GetOrgProjs(OrgNm); ProjN++){
417      PPiRec Proj=GetOrgProj(OrgNm, ProjN);
418      if (Proj->GetProjPrimeContr(this)==OrgNm){PrimeContrs++;}
419    }
420    return PrimeContrs;
421  }
422  void TPiDb::GetFqClbOrgNmV(
423   const TStr& OrgNm, int& SumClbs, TIntStrPrV& FqClbOrgNmPrV) const {
424    SumClbs=0;
425    TStrIntH ClbOrgNmFqH;
426    for (int ProjN=0; ProjN<GetOrgProjs(OrgNm); ProjN++){
427      PPiRec Proj=GetOrgProj(OrgNm, ProjN);
428      TStr ProjRef=Proj->GetProjRef(this);
429      for (int OrgN=0; OrgN<GetProjOrgs(ProjRef); OrgN++){
430        PPiRec Org=GetProjOrg(ProjRef, OrgN);
431        TStr ClbOrgNm=Org->GetOrgNm(this);
432        if (OrgNm!=ClbOrgNm){
433          ClbOrgNmFqH.AddDat(ClbOrgNm)++; SumClbs++;}
434      }
435    }
436    ClbOrgNmFqH.GetDatKeyPrV(FqClbOrgNmPrV);
437    FqClbOrgNmPrV.Sort(false);
438  }
439  void TPiDb::GetClbProjRefV(
440   const TStr& OrgNm1, const TStr& OrgNm2, TStrV& ClbProjRefV) const {
441    ClbProjRefV.Clr();
442    for (int ProjN=0; ProjN<GetOrgProjs(OrgNm1); ProjN++){
443      PPiRec Proj=GetOrgProj(OrgNm1, ProjN);
444      TStr ProjRef=Proj->GetProjRef(this);
445      for (int OrgN=0; OrgN<GetProjOrgs(ProjRef); OrgN++){
446        PPiRec Org=GetProjOrg(ProjRef, OrgN);
447        TStr ClbOrgNm=Org->GetOrgNm(this);
448        if (ClbOrgNm==OrgNm2){
449          ClbProjRefV.Add(ProjRef);}
450      }
451    }
452    ClbProjRefV.Sort();
453  }
454  void TPiDb::GetOrgProjSummary(const TStr& OrgNm, TStrPrV& FundProjRefPrV) const {
455    FundProjRefPrV.Clr();
456    for (int ProjN=0; ProjN<GetOrgProjs(OrgNm); ProjN++){
457      PPiRec Proj=GetOrgProj(OrgNm, ProjN);
458      TStr ProjNm=Proj->GetProjAcronym(this).GetUc();
459      TStr ProjRef=Proj->GetProjRef(this);
460      TStr ProjFund=Proj->GetProjFund(this);
461      FundProjRefPrV.Add(TStrPr(ProjNm, ProjRef));
462    }
463    FundProjRefPrV.Sort(true);
464  }
465  void TPiDb::GetCountryProjSummary(const TStr& CountryNm,
466   int& PrimeContracts, TIntStrPrV& FqPrimeContrOrgNmPrV,
467   int& SumProjRefFq, TStrStrIntTrV& FundProjRefFqTrV,
468   int& SumCountryClbFq, TIntStrPrV& FqCountryNmPrV) const {
469    PrimeContracts=0; TStrIntH PrimeContrOrgNmToFqH;
470    SumProjRefFq=0; FundProjRefFqTrV.Clr();
471    SumCountryClbFq=0; FqCountryNmPrV.Clr(); TStrIntH CountryNmToFqH;
472    for (int ProjN=0; ProjN<GetProjs(); ProjN++){
473      PPiRec Proj=GetProj(ProjN);
474      TStr ProjRef=Proj->GetProjRef(this);
475      for (int OrgN=0; OrgN<GetProjOrgs(ProjRef); OrgN++){
476        PPiRec Org=GetProjOrg(ProjRef, OrgN);
477        if (Org->GetOrgCountry(this)==CountryNm){
478          if (Proj->GetProjPrimeContr(this)==Org->GetOrgNm(this)){
479            PrimeContrOrgNmToFqH.AddDat(Org->GetOrgNm(this))++;
480            PrimeContracts++;
481          }
482          SumProjRefFq++;
483          if ((FundProjRefFqTrV.Len()>0)&&(FundProjRefFqTrV.Last().Val2==ProjRef)){
484            FundProjRefFqTrV.Last().Val3++;
485          } else {
486            FundProjRefFqTrV.Add(TStrStrIntTr(Proj->GetProjFund(this), ProjRef, 1));
487          }
488        }
489      }
490      if ((FundProjRefFqTrV.Len()>0)&&(FundProjRefFqTrV.Last().Val2==ProjRef)){
491        for (int OrgN=0; OrgN<GetProjOrgs(ProjRef); OrgN++){
492          PPiRec Org=GetProjOrg(ProjRef, OrgN);
493          if (Org->GetOrgCountry(this)!=CountryNm){
494            SumCountryClbFq++;
495            CountryNmToFqH.AddDat(Org->GetOrgCountry(this))++;
496          }
497        }
498      }
499    }
500    PrimeContrOrgNmToFqH.GetDatKeyPrV(FqPrimeContrOrgNmPrV);
501    FqPrimeContrOrgNmPrV.Sort(false);
502    FundProjRefFqTrV.Sort(false);
503    CountryNmToFqH.GetDatKeyPrV(FqCountryNmPrV); FqCountryNmPrV.Sort(false);
504  }
505  void TPiDb::GetCountryOrgSummary(const TStr& CountryNm,
506   int& SumOrgNmFq, TIntStrPrV& FqOrgNmPrV,
507   int& SumOrgTypeFq, TIntStrPrV& FqOrgTypePrV) const {
508    SumOrgNmFq=0; TStrIntH OrgNmToFqH;
509    SumOrgTypeFq=0; TStrIntH OrgTypeToFqH;
510    for (int OrgN=0; OrgN<GetOrgs(); OrgN++){
511      PPiRec Org=GetOrg(OrgN);
512      TStr OrgNm=Org->GetOrgNm(this);
513      if (Org->GetOrgCountry(this)==CountryNm){
514        int OrgProjs=GetOrgProjs(OrgNm);
515        SumOrgNmFq+=OrgProjs; OrgNmToFqH.AddDat(OrgNm)+=OrgProjs;
516        SumOrgTypeFq++; OrgTypeToFqH.AddDat(Org->GetOrgType(this))++;
517      }
518    }
519    OrgNmToFqH.GetDatKeyPrV(FqOrgNmPrV); FqOrgNmPrV.Sort(false);
520    OrgTypeToFqH.GetDatKeyPrV(FqOrgTypePrV); FqOrgTypePrV.Sort(false);
521  }
522  void TPiDb::GetSortedProjRefV(const TStr& KeyNm, TStrV& ProjRefV) const {
523    TStrPrV KeyValProjRefPrV(GetProjs(), 0);
524    bool AscOrderP=true;
525    for (int ProjN=0; ProjN<GetProjs(); ProjN++){
526      PPiRec Proj=GetProj(ProjN);
527      TStr ProjRef=Proj->GetProjRef(this);
528      TStr KeyVal;
529      if (KeyNm=="Acronym"){KeyVal=Proj->GetProjAcronym(this);}
530      else if (KeyNm=="Instrument"){KeyVal=Proj->GetProjInstr(this)+Proj->GetProjValue(this);}
531      else if (KeyNm=="Value"){KeyVal=Proj->GetProjValue(this); AscOrderP=false;}
532      else if (KeyNm=="Funding"){KeyVal=Proj->GetProjFund(this); AscOrderP=false;}
533      else if (KeyNm=="Duration"){KeyVal=Proj->GetProjDuration(this)+Proj->GetProjValue(this); AscOrderP=false;}
534      else if (KeyNm=="Consortium"){KeyVal=Proj->GetProjPartners(this)+Proj->GetProjValue(this); AscOrderP=false;}
535      else if (KeyNm=="Strategic Objective"){KeyVal=Proj->GetProjSubProg(this)+Proj->GetProjInstr(this); AscOrderP=false;}
536      else if (KeyNm=="Programme"){KeyVal=Proj->GetProjProg(this)+Proj->GetProjSubProg(this)+Proj->GetProjInstr(this);}
537      else if (KeyNm=="SubProgramme"){KeyVal=Proj->GetProjSubProg(this)+Proj->GetProjInstr(this)+Proj->GetProjValue(this);}
538      else {KeyVal=Proj->GetProjAcronym(this);}
539      if (KeyVal=="Unknown"){KeyVal="\tUnknown";}
540      KeyVal=KeyVal+Proj->GetProjAcronym(this);
541      TStrPr KeyValProjRefPr(KeyVal, Proj->GetProjRef(this));
542      KeyValProjRefPrV.Add(KeyValProjRefPr);
543    }
544    KeyValProjRefPrV.Sort(AscOrderP);
545    ProjRefV.Gen(KeyValProjRefPrV.Len(), 0);
546    for (int ProjN=0; ProjN<KeyValProjRefPrV.Len(); ProjN++){
547      ProjRefV.Add(KeyValProjRefPrV[ProjN].Val2);
548    }
549  }
550  void TPiDb::GetSortedOrgNmV(const TStr& KeyNm, TStrV& OrgNmV) const {
551    TStrPrV KeyValOrgNmPrV(GetOrgs(), 0); bool AscOrderP=true;
552    for (int OrgN=0; OrgN<GetOrgs(); OrgN++){
553      PPiRec Org=GetOrg(OrgN);
554      TStr OrgNm=Org->GetOrgNm(this);
555      TStr KeyVal;
556      if (KeyNm=="Organisation"){KeyVal=OrgNm;}
557      else if (KeyNm=="Projects"){KeyVal=Org->GetOrgProjs(this); AscOrderP=false;}
558      else if (KeyNm=="Funding"){KeyVal=Org->GetOrgFunding(this); AscOrderP=false;}
559      else if (KeyNm=="Type"){KeyVal=Org->GetOrgType(this);}
560      else if (KeyNm=="Country"){KeyVal=Org->GetOrgCountry(this)+Org->GetOrgProjs(this);}
561      else if (KeyNm=="City"){KeyVal=Org->GetOrgCity(this)+Org->GetOrgProjs(this);}
562      else {KeyVal=OrgNm;}
563      if (KeyVal=="Unknown"){KeyVal="\tUnknown";}
564      KeyVal=KeyVal+OrgNm;
565      TStrPr KeyValOrgNmPr(KeyVal, OrgNm);
566      KeyValOrgNmPrV.Add(KeyValOrgNmPr);
567    }
568    KeyValOrgNmPrV.Sort(AscOrderP);
569    OrgNmV.Gen(KeyValOrgNmPrV.Len(), 0);
570    for (int OrgN=0; OrgN<KeyValOrgNmPrV.Len(); OrgN++){
571      OrgNmV.Add(KeyValOrgNmPrV[OrgN].Val2);
572    }
573  }
574  void TPiDb::GetSortedCountryNmV(const TStr& KeyNm, TStrV& CountryNmV) const {
575    TStrPrV KeyValCountryNmPrV(GetCountries(), 0); bool AscOrderP=true;
576    for (int CountryN=0; CountryN<GetCountries(); CountryN++){
577      PPiRec Country=GetCountry(CountryN);
578      TStr CountryNm=Country->GetCountryNm(this);
579      TStr KeyVal;
580      if (KeyNm=="Country"){KeyVal=CountryNm;}
581      else if (KeyNm=="Organisations"){KeyVal=Country->GetCountryOrgs(this); AscOrderP=false;}
582      else if (KeyNm=="Projects"){KeyVal=Country->GetCountryProjs(this); AscOrderP=false;}
583      else if (KeyNm=="Funding"){KeyVal=Country->GetCountryFunding(this); AscOrderP=false;}
584      else if (KeyNm=="Population"){KeyVal=Country->GetCountryPopulation(this); AscOrderP=false;}
585      else if (KeyNm=="GDP Per Capita"){KeyVal=Country->GetCountryGdpPerCapita(this); AscOrderP=false;}
586      else if (KeyNm=="Funding Per Capita"){KeyVal=Country->GetCountryFundingPerCapita(this); AscOrderP=false;}
587      else if (KeyNm=="Funding Per GDP"){KeyVal=Country->GetCountryFundingPerGdp(this); AscOrderP=false;}
588      else {KeyVal=CountryNm;}
589      if (KeyVal=="Unknown"){KeyVal="\tUnknown";}
590      KeyVal=KeyVal+CountryNm;
591      TStrPr KeyValCountryNmPr(KeyVal, CountryNm);
592      KeyValCountryNmPrV.Add(KeyValCountryNmPr);
593    }
594    KeyValCountryNmPrV.Sort(AscOrderP);
595    CountryNmV.Gen(KeyValCountryNmPrV.Len(), 0);
596    for (int CountryN=0; CountryN<KeyValCountryNmPrV.Len(); CountryN++){
597      CountryNmV.Add(KeyValCountryNmPrV[CountryN].Val2);
598    }
599  }
600  PBowDocBs TPiDb::GenBowDocBs() const {
601    printf("Generating Bag-Of-Words...\n");
602    TStrV ProjNmV;
603    TStrV ProjDescStrV;
604    for (int ProjN=0; ProjN<GetProjs(); ProjN++){
605      PPiRec Proj=GetProj(ProjN);
606      TStr ProjNm=Proj->GetProjRef(this);
607      TStr ProjDescStr=
608       Proj->GetProjTitle(this)+"; "+
609       Proj->GetProjSubj(this)+"; "+
610       Proj->GetProjDesc(this);
611      ProjNmV.Add(ProjNm);
612      ProjDescStrV.Add(ProjDescStr);
613    }
614    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
615    PStemmer Stemmer=TStemmer::New(stmtPorter, true);
616    PNGramBs NGramBs=
617     TNGramBs::GetNGramBsFromHtmlStrV(ProjDescStrV, 3, 3, SwSet, Stemmer);
618    NGramBs->SaveTxt("NGram.Txt");
619    printf("\n");
620    PBowDocBs BowDocBs=TBowDocBs::New();
621    BowDocBs->PutNGramBs(NGramBs);
622    {for (int ProjN=0; ProjN<GetProjs(); ProjN++){
623      if (ProjN%10==0){printf("%d/%d\r", ProjN, GetProjs());}
624      BowDocBs->AddHtmlDoc(ProjNmV[ProjN], TStrV(), ProjDescStrV[ProjN]);
625    }
626    printf("%d/%d\n", GetProjs(), GetProjs());}
627    BowDocBs->AssertOk();
628    printf("\nDone.\n");
629    return BowDocBs;
630  }
631  PPiRec TPiDb::LoadProjHtml(const TStr& FNm, const PPiDb& PiDb){
632    PPiRec Proj=TPiRec::New();
633    TStr HtmlStr=TStr::LoadTxt(FNm);
634    PSIn HtmlSIn=TStrIn::New(HtmlStr);
635    THtmlLx Lx(HtmlSIn);
636    while (Lx.GetSym()!=hsyEof){
637      if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<TABLE>")&&(Lx.GetArg("BORDER", "")=="1")){
638        break;
639      } else
640      if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<P>")){
641        Lx.GetSym();
642        if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<B>")){
643          TChA FldNm; TChA FldVal;
644          Lx.GetSym();
645          while (!((Lx.Sym==hsyETag)&&(Lx.UcChA=="<B>"))){
646            FldNm+=Lx.PreSpaceChA; FldNm+=Lx.ChA; Lx.GetSym();}
647          FldNm.Trunc();
648          if ((FldNm.Len()>0)&&(FldNm.LastCh()==':')){FldNm.Pop();}
649          Lx.GetSym();
650          while (!((Lx.Sym==hsyETag)&&(Lx.UcChA=="<P>"))){
651            if ((Lx.Sym!=hsyBTag)&&(Lx.Sym!=hsyETag)){
652              FldVal+=Lx.PreSpaceChA; FldVal+=Lx.ChA;}
653            Lx.GetSym();
654          }
655          FldVal.Trunc();
656          if (FldVal=="IP (Integrated Project)"){FldVal="IP";}
657          if (FldVal=="NoE (Network of Excellence)"){FldVal="NoE";}
658          if (FldVal=="STREP (Specific Targeted Research Project)"){FldVal="STREP";}
659          if (FldVal=="CON (Coordination of research actions)"){FldVal="CON";}
660          if (FldVal=="CA (Coordination action)"){FldVal="CA";}
661          if (FldVal=="SSA (Specific Support Action)"){FldVal="SSA";}
662          if (FldNm=="Project Cost"){FldVal=TPiRec::GetNrMoneyStr(FldVal);}
663          if (FldNm=="Project Funding"){FldVal=TPiRec::GetNrMoneyStr(FldVal);}
664          if (FldNm=="Duration"){FldVal=TPiRec::GetNrDurationStr(FldVal);}
665          Proj->AddFldNmVal(PiDb(), FldNm, FldVal);
666        }
667      }
668    }
669    if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<TABLE>")&&(Lx.GetArg("BORDER", "")=="1")){
670      bool PrimeContractorP=false;
671      while (Lx.GetSym()!=hsyEof){
672        if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<TD>")&&(Lx.GetArg("ALIGN", "")=="center")){
673          Lx.GetSym(); TChA FldVal;
674          while (!((Lx.Sym==hsyETag)&&(Lx.UcChA=="<TD>"))){
675            if ((Lx.Sym!=hsyBTag)&&(Lx.Sym!=hsyETag)){
676              FldVal+=Lx.PreSpaceChA; FldVal+=Lx.ChA;}
677            Lx.GetSym();
678          }
679          FldVal.Trunc();
680          if (FldVal=="Prime Contractor"){PrimeContractorP=true;}
681        } else
682        if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<TABLE>")&&(Lx.GetArg("BORDER", "")=="0")){
683          PPiRec Org=TPiRec::New();
684          while (Lx.GetSym()!=hsyEof){
685            if ((Lx.Sym==hsyETag)&&(Lx.UcChA=="<TABLE>")){
686              break;
687            } else
688            if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<TD>")){
689              Lx.GetSym();
690              if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<B>")){
691                TChA FldNm; TChA FldVal;
692                Lx.GetSym();
693                while (!((Lx.Sym==hsyETag)&&(Lx.UcChA=="<B>"))){
694                  FldNm+=Lx.PreSpaceChA; FldNm+=Lx.ChA; Lx.GetSym();}
695                FldNm.Trunc();
696                if ((FldNm.Len()>0)&&(FldNm.LastCh()==':')){FldNm.Pop();}
697                Lx.GetSym();
698                while (!((Lx.Sym==hsyETag)&&(Lx.UcChA=="<TD>"))){
699                  if ((Lx.Sym!=hsyBTag)&&(Lx.Sym!=hsyETag)){
700                    FldVal+=Lx.PreSpaceChA; FldVal+=Lx.ChA;
701                  } else
702                  if ((Lx.Sym==hsyBTag)&&(Lx.UcChA=="<BR>")){
703                    FldVal+=" / ";
704                  }
705                  Lx.GetSym();
706                }
707                FldVal.Trunc();
708                if ((FldNm=="Organisation Name")||(FldNm=="Organisation")){
709                  FldNm="Organisation";
710                  FldVal.ChangeCh('\"', ' ');
711                  FldVal.ChangeCh('.', ' ');
712                  FldVal.ChangeCh('-', ' ');
713                  FldVal.Trunc();
714                  FldVal.ToUc();
715                  if (FldVal=="JOSEF STEPHAN INSTITUTE"){FldVal="JOZEF STEFAN INSTITUTE";}
716                  if (FldVal=="FRAUNHOFER GESELLSCHAFT ZUR FORDERUNG DER ANGEWANDTEN FORSCHUNG E V"){
717                    FldVal="FRAUNHOFER GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E V";}
718                  if (FldVal=="SIRMA AI EAD"){FldVal="SIRMA AI LTD";}
719                }
720                if (FldNm=="City"){FldVal.ToUc();}
721                if (FldNm=="Org. Country"){FldNm="Country";}
722                if (FldVal=="RUSSIAN FEDERATION"){FldVal="RUSSIA";}
723                Org->AddFldNmVal(PiDb(), FldNm, FldVal);
724              }
725            }
726          }
727          if (PrimeContractorP){
728            Proj->AddFldNmVal(PiDb(), "Prime Contractor", Org->GetOrgNm(PiDb()));
729            PrimeContractorP=false;
730          }
731          if (!PiDb->IsProjOrg(Proj->GetProjRef(PiDb()), Org->GetOrgNm(PiDb()))){
732            PiDb->AddOrgOnProj(Org, Proj->GetProjRef(PiDb()));}
733        }
734      }
735    }
736    return Proj;
737  }
738  PPiDb TPiDb::LoadHtml(const TStr& FPath, const TStr& FBasePrefixStr){
739    PPiDb PiDb=TPiDb::New();
740    TFFile FFile(TStr::GetNrFPath(FPath)+FBasePrefixStr); TStr FNm;
741    while (FFile.Next(FNm)){
742      printf("%s\n", FNm.CStr());
743      PPiRec Proj=LoadProjHtml(FNm, PiDb);
744      PiDb->AddProj(Proj);
745    }
746    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
747      PPiRec Proj=PiDb->GetProj(ProjN);
748      TStr ProjRef=Proj->GetProjRef(PiDb());
749      Proj->AddFldNmVal(PiDb(), "Partners", PiDb->GetProjOrgsStr(ProjRef));
750      if (Proj->GetProjValue(PiDb())=="Unknown"){
751        Proj->AddFldNmVal(PiDb(), "Project Cost", Proj->GetProjFund(PiDb()));}
752    }
753    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
754      PPiRec Org=PiDb->GetOrg(OrgN);
755      TStr OrgNm=Org->GetOrgNm(PiDb());
756      Org->AddFldNmVal(PiDb(), "Projects", PiDb->GetOrgProjsStr(OrgNm));
757      Org->AddFldNmVal(PiDb(), "Funding", PiDb->GetOrgFundingStr(OrgNm));
758    }
759    TStrIntH CountryNmToOrgsH;
760    TStrIntH CountryNmToProjsH;
761    TStrFltH CountryNmToFundingH;
762    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
763      PPiRec Org=PiDb->GetOrg(OrgN);
764      TStr OrgNm=Org->GetOrgNm(PiDb());
765      TStr CountryNm=Org->GetOrgCountry(PiDb());
766      CountryNmToOrgsH.AddDat(CountryNm)++;
767      CountryNmToProjsH.AddDat(CountryNm)+=PiDb->GetOrgProjs(OrgNm);
768      CountryNmToFundingH.AddDat(CountryNm)+=PiDb->GetOrgFunding(OrgNm);
769    }
770    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadBin("CiaWFB2002.Bin");
771    for (int CountryN=0; CountryN<CountryNmToOrgsH.Len(); CountryN++){
772      TStr CountryNm=CountryNmToOrgsH.GetKey(CountryN);
773      int Orgs=CountryNmToOrgsH.GetDat(CountryNm);
774      int Projs=CountryNmToProjsH.GetDat(CountryNm);
775      double Funding=CountryNmToFundingH.GetDat(CountryNm);
776      PCiaWFBCountry CiaWFBCountry;
777      double Population=0;
778      double GdpPerCapita=0;
779      if (CiaWFBBs->IsCountry(CountryNm, CiaWFBCountry)){
780        Population=CiaWFBCountry->GetFldValNum("Population");
781        GdpPerCapita=CiaWFBCountry->GetFldValNum("GDP - per capita");
782      }
783      double FundingPerCapita=0;
784      if (Population>0){
785        FundingPerCapita=1000000*Funding/Population;}
786      PPiRec Country=TPiRec::New();
787      Country->AddFldNmVal(PiDb(), "Country", CountryNm);
788      Country->AddFldNmVal(PiDb(), "Country Organisations", TInt::GetStr(Orgs, "%4d org."));
789      Country->AddFldNmVal(PiDb(), "Country Projects", TInt::GetStr(Projs, "%4d proj."));
790      Country->AddFldNmVal(PiDb(), "Country Funding", TFlt::GetStr(Funding, "%8.2fMeuro"));
791      if (Population>0){
792        Country->AddFldNmVal(PiDb(), "Country Population", TFlt::GetStr(Population/1000000, "%8.2fM"));}
793      if (GdpPerCapita>0){
794        Country->AddFldNmVal(PiDb(), "Country GDP Per Capita", TFlt::GetStr(GdpPerCapita, "%8.0f$"));}
795      if (FundingPerCapita>0){
796        Country->AddFldNmVal(PiDb(), "Country Funding Per Capita", TFlt::GetStr(FundingPerCapita, "%8.2f$/cap"));}
797      if (GdpPerCapita>0){
798        Country->AddFldNmVal(PiDb(), "Country Funding Per GDP", TFlt::GetStr(FundingPerCapita/GdpPerCapita, "%12.8fGDP"));}
799      PiDb->AddCountry(Country);
800    }
801    return PiDb;
802  }
803  void TPiDb::SaveTxtLnDoc(const TStr& FNm){
804    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
805    for (int ProjN=0; ProjN<GetProjs(); ProjN++){
806      PPiRec Proj=GetProj(ProjN);
807      TStr ProjNm=Proj->GetProjProg(this)+"-"+Proj->GetProjAcronym(this);
808      TStr CatNm=Proj->GetProjProg(this);
809      TStr ProjDescStr=
810       Proj->GetProjTitle(this)+"; "+
811       Proj->GetProjSubj(this)+"; "+
812       Proj->GetProjDesc(this);
813      ProjDescStr.ChangeChAll('\r', ' ');
814      ProjDescStr.ChangeChAll('\n', ' ');
815      fprintf(fOut, "%s !%s %s\n", ProjNm.CStr(), CatNm.CStr(), ProjDescStr.CStr());
816    }
817  }
818  PPiDb TPiDb::LoadFP6IstTab(const TStr& ProjOrgTabFNm, const TStr& ProjDocXmlFNm){
819    PPiDb PiDb=TPiDb::New();
820    PSs ProjOrgSs=TSs::LoadTxt(ssfTabSep, ProjOrgTabFNm, TNotify::StdNotify);
821    int ProjRef_FldN=ProjOrgSs->GetFldX("PROJECT_REF", "Project Reference"); EAssert(ProjRef_FldN!=-1);
822    int StartDate_FldN=ProjOrgSs->GetFldX("START_DATE"); EAssert(StartDate_FldN!=-1);
823    int EndDate_FldN=ProjOrgSs->GetFldX("END_DATE"); EAssert(EndDate_FldN!=-1);
824    int Title_FldN=ProjOrgSs->GetFldX("TITLE", "Title"); EAssert(Title_FldN!=-1);
825    int Acronym_FldN=ProjOrgSs->GetFldX("ACRONYM", "Project Acronym"); EAssert(Acronym_FldN!=-1);
826    int CallNm_FldN=ProjOrgSs->GetFldX("CALL_IDENTIFIER", "Call"); EAssert(CallNm_FldN!=-1);
827    int StrategicObj_FldN=ProjOrgSs->GetFldX("STRATEGIC_OBJECTIVE"); EAssert(StrategicObj_FldN!=-1);
828    int ContractType_FldN=ProjOrgSs->GetFldX("CONTRACT_TYPE.DESCRIPTION", "Contract Type"); EAssert(ContractType_FldN!=-1);
829    int PartnerRole_FldN=ProjOrgSs->GetFldX("PARTNER_ROLE.DESCRIPTION"); EAssert(PartnerRole_FldN!=-1);
830    int Org_FldN=ProjOrgSs->GetFldX("Organisation"); EAssert(Org_FldN!=-1);
831    int LegalNm_FldN=ProjOrgSs->GetFldX("Organisation"); EAssert(LegalNm_FldN!=-1);
832    int OrgType_FldN=ProjOrgSs->GetFldX("ORGANISATION_TYPE", "Organisation Type"); EAssert(OrgType_FldN!=-1);
833    int SMEFlag_FldN=ProjOrgSs->GetFldX("SME Flag"); EAssert(SMEFlag_FldN!=-1);
834    int WorkingCity_FldN=ProjOrgSs->GetFldX("WORKING_CITY", "City"); EAssert(WorkingCity_FldN!=-1);
835    int WorkingCountryCd_FldN=ProjOrgSs->GetFldX("WORKING_COUNTRY_CODE", "Country"); EAssert(WorkingCountryCd_FldN!=-1);
836    for (int ProjN=1; ProjN<ProjOrgSs->GetYLen(); ProjN++){
837      TStr ProjRefVal=ProjOrgSs->GetVal(ProjRef_FldN, ProjN);
838      TStr StartDateVal=ProjOrgSs->GetVal(StartDate_FldN, ProjN);
839      TStr EndDateVal=ProjOrgSs->GetVal(EndDate_FldN, ProjN);
840      TStr TitleVal=ProjOrgSs->GetVal(Title_FldN, ProjN);
841      TStr AcronymVal=ProjOrgSs->GetVal(Acronym_FldN, ProjN);
842      TStr CallNmVal=ProjOrgSs->GetVal(CallNm_FldN, ProjN);
843      TStr ObjectiveVal=ProjOrgSs->GetVal(StrategicObj_FldN, ProjN);
844      TStr ContractTypeVal=ProjOrgSs->GetVal(ContractType_FldN, ProjN);
845      TStr DurationValStr="Unknown";
846      TSecTm StartDateSecTm=TSecTm::GetDtTmFromDmyStr(StartDateVal);
847      TSecTm EndDateSecTm=TSecTm::GetDtTmFromDmyStr(EndDateVal);
848      if (StartDateSecTm.IsDef()&&EndDateSecTm.IsDef()){
849        uint DurationSecs=TSecTm::GetDSecs(StartDateSecTm, EndDateSecTm);
850        DurationValStr=
851         TInt::GetStr(DurationSecs/(30*3600*24))+" months";
852      }
853      if (ContractTypeVal=="Integrated Project"){ContractTypeVal="IP";}
854      if (ContractTypeVal=="Specific Targeted Research Project"){ContractTypeVal="STREP";}
855      if (ContractTypeVal=="Network of Excellence"){ContractTypeVal="NoE";}
856      if (ContractTypeVal=="Specific Support Action"){ContractTypeVal="SSA";}
857      if (ContractTypeVal=="Coordination Action"){ContractTypeVal="CA";}
858      PPiRec Proj;
859      if (PiDb->IsProj(ProjRefVal)){
860        Proj=PiDb->GetProj(ProjRefVal);
861      } else {
862        Proj=TPiRec::New();
863        Proj->AddFldNmVal(PiDb(), "Project Reference", ProjRefVal);
864        Proj->AddFldNmVal(PiDb(), "Title", TitleVal);
865        Proj->AddFldNmVal(PiDb(), "Project Acronym", AcronymVal);
866        Proj->AddFldNmVal(PiDb(), "Call", CallNmVal);
867        Proj->AddFldNmVal(PiDb(), "Subprogramme Area", ObjectiveVal);
868        Proj->AddFldNmVal(PiDb(), "Contract Type", ContractTypeVal);
869        Proj->AddFldNmVal(PiDb(), "Start Date", StartDateVal);
870        Proj->AddFldNmVal(PiDb(), "End Date", EndDateVal);
871        Proj->AddFldNmVal(PiDb(), "Duration", DurationValStr);
872        PiDb->AddProj(Proj);
873      }
874      TStr PartnerRoleVal=ProjOrgSs->GetVal(PartnerRole_FldN, ProjN);
875      TStr OrganisationNmVal=ProjOrgSs->GetVal(Org_FldN, ProjN);
876      TStr LegalNmVal=ProjOrgSs->GetVal(LegalNm_FldN, ProjN);
877      TStr OrgTypeVal=ProjOrgSs->GetVal(OrgType_FldN, ProjN);
878      TStr SMEFlagVal=ProjOrgSs->GetVal(SMEFlag_FldN, ProjN);
879      TStr CountryCdVal=ProjOrgSs->GetVal(WorkingCountryCd_FldN, ProjN);
880      TStr CityNmVal=ProjOrgSs->GetVal(WorkingCity_FldN, ProjN);
881      if (LegalNmVal.Empty()){LegalNmVal=OrganisationNmVal;}
882      PPiRec Org=TPiRec::New();
883      Org->AddFldNmVal(PiDb(), "Organisation", LegalNmVal);
884      Org->AddFldNmVal(PiDb(), "Organisation Type", OrgTypeVal);
885      Org->AddFldNmVal(PiDb(), "SME", (SMEFlagVal=="X")?"Yes":"No");
886      Org->AddFldNmVal(PiDb(), "City", CityNmVal);
887      Org->AddFldNmVal(PiDb(), "Country", CountryCdVal);
888      PiDb->AddOrgOnProj(Org, ProjRefVal);
889      if (PartnerRoleVal=="Coordinator"){
890        Proj->AddFldNmVal(PiDb(), "Prime Contractor", Org->GetOrgNm(PiDb()));}
891    }
892    if (!ProjDocXmlFNm.Empty()){
893      printf("Loading '%s' ...\n", ProjDocXmlFNm.CStr());
894      PXmlDoc ProjDocXmlDoc=TXmlDoc::LoadTxt(ProjDocXmlFNm);
895      TXmlTokV ProjDocXmlTokV;
896      ProjDocXmlDoc->GetTagTokV("Projects|Project", ProjDocXmlTokV);
897      for (int ProjN=0; ProjN<ProjDocXmlTokV.Len(); ProjN++){
898        printf("  %d/%d\r", 1+ProjN, ProjDocXmlTokV.Len());
899        TStr ProjRef=ProjDocXmlTokV[ProjN]->GetArgVal("id");
900        TStr ProjNm=ProjDocXmlTokV[ProjN]->GetTagTokStr("Acronym");
901        TStr ProjTitleStr=ProjDocXmlTokV[ProjN]->GetTagTokStr("projectTitle");
902        TStr ProjAbstractStr=ProjDocXmlTokV[ProjN]->GetTagTokStrOrDf("projectAbstract");
903        if (PiDb->IsProj(ProjRef)){
904          PPiRec Proj=PiDb->GetProj(ProjRef);
905          Proj->AddFldNmVal(PiDb(), "Objective", ProjAbstractStr);
906        }
907      }
908      printf("\nDone.\n");
909    }
910    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
911      PPiRec Proj=PiDb->GetProj(ProjN);
912      TStr ProjRef=Proj->GetProjRef(PiDb());
913      Proj->AddFldNmVal(PiDb(), "Partners", PiDb->GetProjOrgsStr(ProjRef));
914    }
915    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
916      PPiRec Org=PiDb->GetOrg(OrgN);
917      TStr OrgNm=Org->GetOrgNm(PiDb());
918      Org->AddFldNmVal(PiDb(), "Projects", PiDb->GetOrgProjsStr(OrgNm));
919    }
920    TStrIntH CountryNmToOrgsH;
921    TStrIntH CountryNmToProjsH;
922    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
923      PPiRec Org=PiDb->GetOrg(OrgN);
924      TStr OrgNm=Org->GetOrgNm(PiDb());
925      TStr CountryNm=Org->GetOrgCountry(PiDb());
926      CountryNmToOrgsH.AddDat(CountryNm)++;
927      CountryNmToProjsH.AddDat(CountryNm)+=PiDb->GetOrgProjs(OrgNm);
928    }
929    for (int CountryN=0; CountryN<CountryNmToOrgsH.Len(); CountryN++){
930      TStr CountryNm=CountryNmToOrgsH.GetKey(CountryN);
931      int Orgs=CountryNmToOrgsH.GetDat(CountryNm);
932      int Projs=CountryNmToProjsH.GetDat(CountryNm);
933      PPiRec Country=TPiRec::New();
934      Country->AddFldNmVal(PiDb(), "Country", CountryNm);
935      Country->AddFldNmVal(PiDb(), "Country Organisations", TInt::GetStr(Orgs, "%4d org."));
936      Country->AddFldNmVal(PiDb(), "Country Projects", TInt::GetStr(Projs, "%4d proj."));
937      PiDb->AddCountry(Country);
938    }
939    PiDb->PiGraph=TPiGraph::New(PiDb);
940    PiDb->BowDocBs=PiDb->GenBowDocBs();
941    return PiDb;
942  }
943  PPiDb TPiDb::LoadFP7IstTab(const TStr& ProjOrgTabFNm){
944    PPiDb PiDb=TPiDb::New();
945    PSs ProjOrgSs=TSs::LoadTxt(ssfTabSep, ProjOrgTabFNm, TNotify::StdNotify);
946    int ProjRef_FldN=ProjOrgSs->GetFldX("PROPOSAL", "Project Reference"); EAssert(ProjRef_FldN!=-1);
947    int StartDate_FldN=ProjOrgSs->GetFldX("START DATE"); EAssert(StartDate_FldN!=-1);
948    int EndDate_FldN=ProjOrgSs->GetFldX("END DATE"); EAssert(EndDate_FldN!=-1);
949    int Title_FldN=ProjOrgSs->GetFldX("TITLE", "Title"); EAssert(Title_FldN!=-1);
950    int Acronym_FldN=ProjOrgSs->GetFldX("ACRONYM", "Project Acronym"); EAssert(Acronym_FldN!=-1);
951    int CallNm_FldN=ProjOrgSs->GetFldX("CALL IDENTIFIER", "Call"); EAssert(CallNm_FldN!=-1);
952    int StrategicObj_FldN=ProjOrgSs->GetFldX("STRATEGIC OBJECTIVE"); EAssert(StrategicObj_FldN!=-1);
953    int ContractType_FldN=ProjOrgSs->GetFldX("INSTRUMENT", "Contract Type"); EAssert(ContractType_FldN!=-1);
954    int PartnerRole_FldN=ProjOrgSs->GetFldX("PARTNER ROLE DESCRIPTION"); EAssert(PartnerRole_FldN!=-1);
955    int Org_FldN=ProjOrgSs->GetFldX("SHORT NAME"); EAssert(Org_FldN!=-1);
956    int LegalNm_FldN=ProjOrgSs->GetFldX("LEAGL NAME", "Organisation"); EAssert(LegalNm_FldN!=-1);
957    int WorkingCity_FldN=ProjOrgSs->GetFldX("LEGAL CITY", "City"); EAssert(WorkingCity_FldN!=-1);
958    int WorkingCountryCd_FldN=ProjOrgSs->GetFldX("LEGAL COUNTRY CODE", "Country"); EAssert(WorkingCountryCd_FldN!=-1);
959    for (int ProjN=1; ProjN<ProjOrgSs->GetYLen(); ProjN++){
960      TStr ProjRefVal=ProjOrgSs->GetVal(ProjRef_FldN, ProjN);
961      TStr StartDateVal=ProjOrgSs->GetVal(StartDate_FldN, ProjN);
962      TStr EndDateVal=ProjOrgSs->GetVal(EndDate_FldN, ProjN);
963      TStr TitleVal=ProjOrgSs->GetVal(Title_FldN, ProjN);
964      TStr AcronymVal=ProjOrgSs->GetVal(Acronym_FldN, ProjN);
965      TStr CallNmVal=ProjOrgSs->GetVal(CallNm_FldN, ProjN);
966      TStr ObjectiveVal=ProjOrgSs->GetVal(StrategicObj_FldN, ProjN);
967      TStr ContractTypeVal=ProjOrgSs->GetVal(ContractType_FldN, ProjN);
968      TStr DurationValStr="Unknown";
969      TSecTm StartDateSecTm=TSecTm::GetDtTmFromDmyStr(StartDateVal);
970      TSecTm EndDateSecTm=TSecTm::GetDtTmFromDmyStr(EndDateVal);
971      if (StartDateSecTm.IsDef()&&EndDateSecTm.IsDef()){
972        uint DurationSecs=TSecTm::GetDSecs(StartDateSecTm, EndDateSecTm);
973        DurationValStr=
974         TInt::GetStr(DurationSecs/(30*3600*24))+" months";
975      }
976      if (ContractTypeVal=="Large-scale integrating project"){ContractTypeVal="IP";}
977      if (ContractTypeVal=="Small or medium-scale focused research project -STREP"){ContractTypeVal="STREP";}
978      if (ContractTypeVal=="Network of Excellence"){ContractTypeVal="NoE";}
979      if (ContractTypeVal=="Coordination and support action - Support"){ContractTypeVal="SSA";}
980      if (ContractTypeVal=="Coordination and support action - Coordination"){ContractTypeVal="CA";}
981      PPiRec Proj;
982      if (PiDb->IsProj(ProjRefVal)){
983        Proj=PiDb->GetProj(ProjRefVal);
984      } else {
985        Proj=TPiRec::New();
986        Proj->AddFldNmVal(PiDb(), "Project Reference", ProjRefVal);
987        Proj->AddFldNmVal(PiDb(), "Title", TitleVal);
988        Proj->AddFldNmVal(PiDb(), "Project Acronym", AcronymVal);
989        Proj->AddFldNmVal(PiDb(), "Call", CallNmVal);
990        Proj->AddFldNmVal(PiDb(), "Subprogramme Area", ObjectiveVal);
991        Proj->AddFldNmVal(PiDb(), "Contract Type", ContractTypeVal);
992        Proj->AddFldNmVal(PiDb(), "Start Date", StartDateVal);
993        Proj->AddFldNmVal(PiDb(), "End Date", EndDateVal);
994        Proj->AddFldNmVal(PiDb(), "Duration", DurationValStr);
995        PiDb->AddProj(Proj);
996      }
997      TStr PartnerRoleVal=ProjOrgSs->GetVal(PartnerRole_FldN, ProjN);
998      TStr OrganisationNmVal=ProjOrgSs->GetVal(Org_FldN, ProjN);
999      TStr LegalNmVal=ProjOrgSs->GetVal(LegalNm_FldN, ProjN);
1000      TStr OrgTypeVal="";
1001      TStr SMEFlagVal="";
1002      TStr CountryCdVal=ProjOrgSs->GetVal(WorkingCountryCd_FldN, ProjN);
1003      TStr CityNmVal=ProjOrgSs->GetVal(WorkingCity_FldN, ProjN);
1004      if (LegalNmVal.Empty()){LegalNmVal=OrganisationNmVal;}
1005      PPiRec Org=TPiRec::New();
1006      Org->AddFldNmVal(PiDb(), "Organisation", LegalNmVal);
1007      Org->AddFldNmVal(PiDb(), "Organisation Type", OrgTypeVal);
1008      Org->AddFldNmVal(PiDb(), "SME", (SMEFlagVal=="X")?"Yes":"No");
1009      Org->AddFldNmVal(PiDb(), "City", CityNmVal);
1010      Org->AddFldNmVal(PiDb(), "Country", CountryCdVal);
1011      PiDb->AddOrgOnProj(Org, ProjRefVal);
1012      if (PartnerRoleVal=="Coordinator"){
1013        Proj->AddFldNmVal(PiDb(), "Prime Contractor", Org->GetOrgNm(PiDb()));}
1014    }
1015    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
1016      PPiRec Proj=PiDb->GetProj(ProjN);
1017      TStr ProjRef=Proj->GetProjRef(PiDb());
1018      Proj->AddFldNmVal(PiDb(), "Partners", PiDb->GetProjOrgsStr(ProjRef));
1019    }
1020    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
1021      PPiRec Org=PiDb->GetOrg(OrgN);
1022      TStr OrgNm=Org->GetOrgNm(PiDb());
1023      Org->AddFldNmVal(PiDb(), "Projects", PiDb->GetOrgProjsStr(OrgNm));
1024    }
1025    TStrIntH CountryNmToOrgsH;
1026    TStrIntH CountryNmToProjsH;
1027    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
1028      PPiRec Org=PiDb->GetOrg(OrgN);
1029      TStr OrgNm=Org->GetOrgNm(PiDb());
1030      TStr CountryNm=Org->GetOrgCountry(PiDb());
1031      CountryNmToOrgsH.AddDat(CountryNm)++;
1032      CountryNmToProjsH.AddDat(CountryNm)+=PiDb->GetOrgProjs(OrgNm);
1033    }
1034    for (int CountryN=0; CountryN<CountryNmToOrgsH.Len(); CountryN++){
1035      TStr CountryNm=CountryNmToOrgsH.GetKey(CountryN);
1036      int Orgs=CountryNmToOrgsH.GetDat(CountryNm);
1037      int Projs=CountryNmToProjsH.GetDat(CountryNm);
1038      PPiRec Country=TPiRec::New();
1039      Country->AddFldNmVal(PiDb(), "Country", CountryNm);
1040      Country->AddFldNmVal(PiDb(), "Country Organisations", TInt::GetStr(Orgs, "%4d org."));
1041      Country->AddFldNmVal(PiDb(), "Country Projects", TInt::GetStr(Projs, "%4d proj."));
1042      PiDb->AddCountry(Country);
1043    }
1044    PiDb->PiGraph=TPiGraph::New(PiDb);
1045    PiDb->BowDocBs=PiDb->GenBowDocBs();
1046    return PiDb;
1047  }
1048  PPiDb TPiDb::LoadFP5IstTab(const TStr& ProjOrgTabFNm){
1049    PPiDb PiDb=TPiDb::New();
1050    PSs ProjOrgSs=TSs::LoadTxt(ssfTabSep, ProjOrgTabFNm, TNotify::StdNotify);
1051    int ProjRef_FldN=ProjOrgSs->GetFldX("PROJECT REF", "Project Reference", 1); EAssert(ProjRef_FldN!=-1);
1052    int StartDate_FldN=ProjOrgSs->GetFldX("START DATE", "", 1); EAssert(StartDate_FldN!=-1);
1053    int EndDate_FldN=ProjOrgSs->GetFldX("END DATE", "", 1); EAssert(EndDate_FldN!=-1);
1054    int Title_FldN=ProjOrgSs->GetFldX("TITLE", "Title", 1); EAssert(Title_FldN!=-1);
1055    int Acronym_FldN=ProjOrgSs->GetFldX("ACRONYM", "Project Acronym", 1); EAssert(Acronym_FldN!=-1);
1056    int CallNm_FldN=ProjOrgSs->GetFldX("CALL IDENTIFIER", "Call", 1); EAssert(CallNm_FldN!=-1);
1057    int StrategicObj_FldN=ProjOrgSs->GetFldX("STRATEGIC OBJECTIVE", "", 1); EAssert(StrategicObj_FldN!=-1);
1058    int ContractType_FldN=ProjOrgSs->GetFldX("INSTRUMENT", "Contract Type", 1); EAssert(ContractType_FldN!=-1);
1059    int PartnerRole_FldN=ProjOrgSs->GetFldX("PARTNER ROLE DESCRIPTION", "", 1); EAssert(PartnerRole_FldN!=-1);
1060    int Org_FldN=ProjOrgSs->GetFldX("SHORT NAME", "", 1); EAssert(Org_FldN!=-1);
1061    int LegalNm_FldN=ProjOrgSs->GetFldX("LEGAL NAME", "Organisation", 1); EAssert(LegalNm_FldN!=-1);
1062    int OrgType_FldN=ProjOrgSs->GetFldX("ORGANISATION TYPE", "Organisation Type", 1); EAssert(OrgType_FldN!=-1);
1063    int WorkingCity_FldN=ProjOrgSs->GetFldX("LEGAL CITY", "City", 1); EAssert(WorkingCity_FldN!=-1);
1064    int WorkingCountryCd_FldN=ProjOrgSs->GetFldX("LEGAL COUNTRY CODE", "Country", 1); EAssert(WorkingCountryCd_FldN!=-1);
1065    for (int ProjN=1; ProjN<ProjOrgSs->GetYLen(); ProjN++){
1066      TStr ProjRefVal=ProjOrgSs->GetVal(ProjRef_FldN, ProjN);
1067      TStr StartDateVal=ProjOrgSs->GetVal(StartDate_FldN, ProjN);
1068      TStr EndDateVal=ProjOrgSs->GetVal(EndDate_FldN, ProjN);
1069      TStr TitleVal=ProjOrgSs->GetVal(Title_FldN, ProjN);
1070      TStr AcronymVal=ProjOrgSs->GetVal(Acronym_FldN, ProjN);
1071      TStr CallNmVal=ProjOrgSs->GetVal(CallNm_FldN, ProjN);
1072      TStr ObjectiveVal=ProjOrgSs->GetVal(StrategicObj_FldN, ProjN);
1073      TStr ContractTypeVal=ProjOrgSs->GetVal(ContractType_FldN, ProjN);
1074      TStr DurationValStr="Unknown";
1075      TSecTm StartDateSecTm=TSecTm::GetDtTmFromDmyStr(StartDateVal);
1076      TSecTm EndDateSecTm=TSecTm::GetDtTmFromDmyStr(EndDateVal);
1077      if (StartDateSecTm.IsDef()&&EndDateSecTm.IsDef()){
1078        uint DurationSecs=TSecTm::GetDSecs(StartDateSecTm, EndDateSecTm);
1079        DurationValStr=
1080         TInt::GetStr(DurationSecs/(30*3600*24))+" months";
1081      }
1082      if (ContractTypeVal=="Large-scale integrating project"){ContractTypeVal="IP";}
1083      if (ContractTypeVal=="Small or medium-scale focused research project -STREP"){ContractTypeVal="STREP";}
1084      if (ContractTypeVal=="Network of Excellence"){ContractTypeVal="NoE";}
1085      if (ContractTypeVal=="Coordination and support action - Support"){ContractTypeVal="SSA";}
1086      if (ContractTypeVal=="Coordination and support action - Coordination"){ContractTypeVal="CA";}
1087      PPiRec Proj;
1088      if (PiDb->IsProj(ProjRefVal)){
1089        Proj=PiDb->GetProj(ProjRefVal);
1090      } else {
1091        Proj=TPiRec::New();
1092        Proj->AddFldNmVal(PiDb(), "Project Reference", ProjRefVal);
1093        Proj->AddFldNmVal(PiDb(), "Title", TitleVal);
1094        Proj->AddFldNmVal(PiDb(), "Project Acronym", AcronymVal);
1095        Proj->AddFldNmVal(PiDb(), "Call", CallNmVal);
1096        Proj->AddFldNmVal(PiDb(), "Subprogramme Area", ObjectiveVal);
1097        Proj->AddFldNmVal(PiDb(), "Contract Type", ContractTypeVal);
1098        Proj->AddFldNmVal(PiDb(), "Start Date", StartDateVal);
1099        Proj->AddFldNmVal(PiDb(), "End Date", EndDateVal);
1100        Proj->AddFldNmVal(PiDb(), "Duration", DurationValStr);
1101        PiDb->AddProj(Proj);
1102      }
1103      TStr PartnerRoleVal=ProjOrgSs->GetVal(PartnerRole_FldN, ProjN);
1104      TStr OrganisationNmVal=ProjOrgSs->GetVal(Org_FldN, ProjN);
1105      TStr LegalNmVal=ProjOrgSs->GetVal(LegalNm_FldN, ProjN);
1106      TStr OrgTypeVal=ProjOrgSs->GetVal(OrgType_FldN, ProjN);
1107      TStr SMEFlagVal="";
1108      TStr CountryCdVal=ProjOrgSs->GetVal(WorkingCountryCd_FldN, ProjN);
1109      TStr CityNmVal=ProjOrgSs->GetVal(WorkingCity_FldN, ProjN);
1110      if (LegalNmVal.Empty()){LegalNmVal=OrganisationNmVal;}
1111      PPiRec Org=TPiRec::New();
1112      Org->AddFldNmVal(PiDb(), "Organisation", LegalNmVal);
1113      Org->AddFldNmVal(PiDb(), "Organisation Type", OrgTypeVal);
1114      Org->AddFldNmVal(PiDb(), "SME", (SMEFlagVal=="X")?"Yes":"No");
1115      Org->AddFldNmVal(PiDb(), "City", CityNmVal);
1116      Org->AddFldNmVal(PiDb(), "Country", CountryCdVal);
1117      PiDb->AddOrgOnProj(Org, ProjRefVal);
1118      if (PartnerRoleVal=="Coordinator"){
1119        Proj->AddFldNmVal(PiDb(), "Prime Contractor", Org->GetOrgNm(PiDb()));}
1120    }
1121    for (int ProjN=0; ProjN<PiDb->GetProjs(); ProjN++){
1122      PPiRec Proj=PiDb->GetProj(ProjN);
1123      TStr ProjRef=Proj->GetProjRef(PiDb());
1124      Proj->AddFldNmVal(PiDb(), "Partners", PiDb->GetProjOrgsStr(ProjRef));
1125    }
1126    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
1127      PPiRec Org=PiDb->GetOrg(OrgN);
1128      TStr OrgNm=Org->GetOrgNm(PiDb());
1129      Org->AddFldNmVal(PiDb(), "Projects", PiDb->GetOrgProjsStr(OrgNm));
1130    }
1131    TStrIntH CountryNmToOrgsH;
1132    TStrIntH CountryNmToProjsH;
1133    for (int OrgN=0; OrgN<PiDb->GetOrgs(); OrgN++){
1134      PPiRec Org=PiDb->GetOrg(OrgN);
1135      TStr OrgNm=Org->GetOrgNm(PiDb());
1136      TStr CountryNm=Org->GetOrgCountry(PiDb());
1137      CountryNmToOrgsH.AddDat(CountryNm)++;
1138      CountryNmToProjsH.AddDat(CountryNm)+=PiDb->GetOrgProjs(OrgNm);
1139    }
1140    for (int CountryN=0; CountryN<CountryNmToOrgsH.Len(); CountryN++){
1141      TStr CountryNm=CountryNmToOrgsH.GetKey(CountryN);
1142      int Orgs=CountryNmToOrgsH.GetDat(CountryNm);
1143      int Projs=CountryNmToProjsH.GetDat(CountryNm);
1144      PPiRec Country=TPiRec::New();
1145      Country->AddFldNmVal(PiDb(), "Country", CountryNm);
1146      Country->AddFldNmVal(PiDb(), "Country Organisations", TInt::GetStr(Orgs, "%4d org."));
1147      Country->AddFldNmVal(PiDb(), "Country Projects", TInt::GetStr(Projs, "%4d proj."));
1148      PiDb->AddCountry(Country);
1149    }
1150    PiDb->PiGraph=TPiGraph::New(PiDb);
1151    PiDb->BowDocBs=PiDb->GenBowDocBs();
1152    return PiDb;
1153  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-pi.cpp</div>
                </div>
                <div class="column column_space"><pre><code>903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
</pre></code></div>
                <div class="column column_space"><pre><code>101      for (int OrgN1=0; OrgN1<ProjOrgs; OrgN1++){
102        PPiRec Org1=PiDb->GetProjOrg(ProjRef, OrgN1);
103        TStr OrgNm1=Org1->GetOrgNm(PiDb());
104        TStr CountryNm1=Org1->GetCountryNm(PiDb());
105        CallNmToOrgNmHH.AddDat(CallNm).AddKey(OrgNm1);
106        SubProgNmToOrgNmHH.AddDat(SubProgNm).AddKey(OrgNm1);
107        for (int OrgN2=OrgN1+1; OrgN2<ProjOrgs; OrgN2++){
108          PPiRec Org2=PiDb->GetProjOrg(ProjRef, OrgN2);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    