
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.5696202531645564%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-throw_delegate_test.cc</h3>
            <pre><code>1  #include "absl/base/internal/throw_delegate.h"
2  #include <functional>
3  #include <new>
4  #include <stdexcept>
5  #include "absl/base/config.h"
6  #include "gtest/gtest.h"
7  namespace {
8  using absl::base_internal::ThrowStdLogicError;
9  using absl::base_internal::ThrowStdInvalidArgument;
10  using absl::base_internal::ThrowStdDomainError;
11  using absl::base_internal::ThrowStdLengthError;
12  using absl::base_internal::ThrowStdOutOfRange;
13  using absl::base_internal::ThrowStdRuntimeError;
14  using absl::base_internal::ThrowStdRangeError;
15  using absl::base_internal::ThrowStdOverflowError;
16  using absl::base_internal::ThrowStdUnderflowError;
17  using absl::base_internal::ThrowStdBadFunctionCall;
18  using absl::base_internal::ThrowStdBadAlloc;
19  constexpr const char* what_arg = "The quick brown fox jumps over the lazy dog";
20  template <typename E>
21  void ExpectThrowChar(void (*f)(const char*)) {
22  #ifdef ABSL_HAVE_EXCEPTIONS
23    try {
24      f(what_arg);
25      FAIL() << "Didn't throw";
26    } catch (const E& e) {
27      EXPECT_STREQ(e.what(), what_arg);
28    }
29  #else
30    EXPECT_DEATH_IF_SUPPORTED(f(what_arg), what_arg);
31  #endif
32  }
33  template <typename E>
34  void ExpectThrowString(void (*f)(const std::string&)) {
35  #ifdef ABSL_HAVE_EXCEPTIONS
36    try {
37      f(what_arg);
38      FAIL() << "Didn't throw";
39    } catch (const E& e) {
40      EXPECT_STREQ(e.what(), what_arg);
41    }
42  #else
43    EXPECT_DEATH_IF_SUPPORTED(f(what_arg), what_arg);
44  #endif
45  }
46  template <typename E>
47  void ExpectThrowNoWhat(void (*f)()) {
48  #ifdef ABSL_HAVE_EXCEPTIONS
49    try {
50      f();
51      FAIL() << "Didn't throw";
52    } catch (const E& e) {
53    }
54  #else
55    EXPECT_DEATH_IF_SUPPORTED(f(), "");
56  #endif
<span onclick='openModal()' class='match'>57  }
58  TEST(ThrowDelegate, ThrowStdLogicErrorChar) {
59    ExpectThrowChar<std::logic_error>(ThrowStdLogicError);
60  }
61  TEST(ThrowDelegate, ThrowStdInvalidArgumentChar) {
62    ExpectThrowChar<std::invalid_argument>(ThrowStdInvalidArgument);
63  }
64  TEST(ThrowDelegate, ThrowStdDomainErrorChar) {
65    ExpectThrowChar<std::domain_error>(ThrowStdDomainError);
66  }
67  TEST(ThrowDelegate, ThrowStdLengthErrorChar) {
68    ExpectThrowChar<std::length_error>(ThrowStdLengthError);
69  }
70  TEST(ThrowDelegate, ThrowStdOutOfRangeChar) {
71    ExpectThrowChar<std::out_of_range>(ThrowStdOutOfRange);
72  }
</span>73  TEST(ThrowDelegate, ThrowStdRuntimeErrorChar) {
74    ExpectThrowChar<std::runtime_error>(ThrowStdRuntimeError);
75  }
76  TEST(ThrowDelegate, ThrowStdRangeErrorChar) {
77    ExpectThrowChar<std::range_error>(ThrowStdRangeError);
78  }
79  TEST(ThrowDelegate, ThrowStdOverflowErrorChar) {
80    ExpectThrowChar<std::overflow_error>(ThrowStdOverflowError);
81  }
82  TEST(ThrowDelegate, ThrowStdUnderflowErrorChar) {
83    ExpectThrowChar<std::underflow_error>(ThrowStdUnderflowError);
84  }
85  TEST(ThrowDelegate, ThrowStdLogicErrorString) {
86    ExpectThrowString<std::logic_error>(ThrowStdLogicError);
87  }
88  TEST(ThrowDelegate, ThrowStdInvalidArgumentString) {
89    ExpectThrowString<std::invalid_argument>(ThrowStdInvalidArgument);
90  }
91  TEST(ThrowDelegate, ThrowStdDomainErrorString) {
92    ExpectThrowString<std::domain_error>(ThrowStdDomainError);
93  }
94  TEST(ThrowDelegate, ThrowStdLengthErrorString) {
95    ExpectThrowString<std::length_error>(ThrowStdLengthError);
96  }
97  TEST(ThrowDelegate, ThrowStdOutOfRangeString) {
98    ExpectThrowString<std::out_of_range>(ThrowStdOutOfRange);
99  }
100  TEST(ThrowDelegate, ThrowStdRuntimeErrorString) {
101    ExpectThrowString<std::runtime_error>(ThrowStdRuntimeError);
102  }
103  TEST(ThrowDelegate, ThrowStdRangeErrorString) {
104    ExpectThrowString<std::range_error>(ThrowStdRangeError);
105  }
106  TEST(ThrowDelegate, ThrowStdOverflowErrorString) {
107    ExpectThrowString<std::overflow_error>(ThrowStdOverflowError);
108  }
109  TEST(ThrowDelegate, ThrowStdUnderflowErrorString) {
110    ExpectThrowString<std::underflow_error>(ThrowStdUnderflowError);
111  }
112  TEST(ThrowDelegate, ThrowStdBadFunctionCallNoWhat) {
113  #ifdef ABSL_HAVE_EXCEPTIONS
114    try {
115      ThrowStdBadFunctionCall();
116      FAIL() << "Didn't throw";
117    } catch (const std::bad_function_call&) {
118    }
119  #ifdef _LIBCPP_VERSION
120    catch (const std::exception&) {
121    }
122  #endif
123  #else
124    EXPECT_DEATH_IF_SUPPORTED(ThrowStdBadFunctionCall(), "");
125  #endif
126  }
127  TEST(ThrowDelegate, ThrowStdBadAllocNoWhat) {
128    ExpectThrowNoWhat<std::bad_alloc>(ThrowStdBadAlloc);
129  }
130  }  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</h3>
            <pre><code>1  #pragma once
2  #include <boost/config.hpp>
3  #include <boost/version.hpp>
4  #include <algorithm>
5  #include <array>
6  #include <chrono>
7  #include <optional>
8  #include <string>
9  using namespace std::chrono_literals;
10  namespace boost
11  {
12  namespace filesystem
13  {
14  	class path;
15  }
16  }
17  #define xstr(a) ver_str (a)
18  #define ver_str(a) #a
19  char const * const NANO_VERSION_STRING = xstr (TAG_VERSION_STRING);
20  char const * const NANO_MAJOR_VERSION_STRING = xstr (MAJOR_VERSION_STRING);
21  char const * const NANO_MINOR_VERSION_STRING = xstr (MINOR_VERSION_STRING);
22  char const * const NANO_PATCH_VERSION_STRING = xstr (PATCH_VERSION_STRING);
23  char const * const NANO_PRE_RELEASE_VERSION_STRING = xstr (PRE_RELEASE_VERSION_STRING);
24  char const * const BUILD_INFO = xstr (GIT_COMMIT_HASH BOOST_COMPILER) " \"BOOST " xstr (BOOST_VERSION) "\" BUILT " xstr (__DATE__);
25  #if defined(__has_feature)
26  #if __has_feature(address_sanitizer)
27  inline bool is_asan_build ()
28  {
29  	return true;
30  }
31  #else
32  inline bool is_asan_build ()
33  {
34  	return false;
35  }
36  #endif
37  #elif defined(__SANITIZE_ADDRESS__)
38  inline bool is_asan_build ()
39  {
40  	return true;
41  }
42  #else
43  inline bool is_asan_build ()
44  {
45  	return false;
46  }
47  #endif
48  #if defined(__has_feature)
49  #if __has_feature(thread_sanitizer)
50  inline bool is_tsan_build ()
51  {
52  	return true;
53  }
54  #else
55  inline bool is_tsan_build ()
56  {
57  	return false;
58  }
59  #endif
60  #elif defined(__SANITIZE_THREAD__)
61  inline bool is_tsan_build ()
62  {
63  	return true;
64  }
65  #else
66  inline bool is_tsan_build ()
67  {
68  	return false;
69  }
70  #endif
71  namespace nano
72  {
73  uint8_t get_major_node_version ();
74  uint8_t get_minor_node_version ();
75  uint8_t get_patch_node_version ();
76  uint8_t get_pre_release_node_version ();
77  std::optional<std::string> get_env (char const * variable_name);
78  std::string get_env_or_default (char const * variable_name, std::string const default_value);
79  int get_env_int_or_default (char const * variable_name, int const default_value);
80  uint64_t get_env_threshold_or_default (char const * variable_name, uint64_t const default_value);
81  uint16_t test_node_port ();
82  uint16_t test_rpc_port ();
83  uint16_t test_ipc_port ();
84  uint16_t test_websocket_port ();
85  std::array<uint8_t, 2> test_magic_number ();
86  uint32_t test_scan_wallet_reps_delay ();
87  enum class networks : uint16_t
88  {
89  	invalid = 0x0,
90  	nano_dev_network = 0x5241, 
91  	nano_beta_network = 0x5242, 
92  	nano_live_network = 0x5243, 
93  	nano_test_network = 0x5258, 
94  };
95  enum class work_version
96  {
97  	unspecified,
98  	work_1
99  };
100  enum class block_type : uint8_t;
101  class root;
102  class block;
103  class block_details;
104  class work_thresholds
105  {
106  public:
107  	uint64_t const epoch_1;
108  	uint64_t const epoch_2;
109  	uint64_t const epoch_2_receive;
110  	uint64_t const base;
111  	uint64_t const entry;
112  	constexpr work_thresholds (uint64_t epoch_1_a, uint64_t epoch_2_a, uint64_t epoch_2_receive_a) :
113  		epoch_1 (epoch_1_a), epoch_2 (epoch_2_a), epoch_2_receive (epoch_2_receive_a),
114  		base (std::max ({ epoch_1, epoch_2, epoch_2_receive })),
115  		entry (std::min ({ epoch_1, epoch_2, epoch_2_receive }))
116  	{
117  	}
118  	work_thresholds () = delete;
119  	work_thresholds operator= (nano::work_thresholds const & other_a)
120  	{
121  		return other_a;
122  	}
123  	uint64_t threshold_entry (nano::work_version const, nano::block_type const) const;
124  	uint64_t threshold (nano::block_details const &) const;
125  	uint64_t threshold (nano::work_version const, nano::block_details const) const;
126  	uint64_t threshold_base (nano::work_version const) const;
127  	uint64_t value (nano::root const & root_a, uint64_t work_a) const;
128  	double normalized_multiplier (double const, uint64_t const) const;
129  	double denormalized_multiplier (double const, uint64_t const) const;
130  	uint64_t difficulty (nano::work_version const, nano::root const &, uint64_t const) const;
131  	uint64_t difficulty (nano::block const & block_a) const;
132  	bool validate_entry (nano::work_version const, nano::root const &, uint64_t const) const;
133  	bool validate_entry (nano::block const &) const;
134  	static nano::work_thresholds const publish_full;
135  	static nano::work_thresholds const publish_beta;
136  	static nano::work_thresholds const publish_dev;
137  	static nano::work_thresholds const publish_test;
138  };
139  class network_constants
140  {
141  	static constexpr std::chrono::seconds default_cleanup_period = std::chrono::seconds (60);
142  	static constexpr size_t default_max_peers_per_ip = 10;
143  public:
144  	network_constants (nano::work_thresholds & work_, nano::networks network_a) :
145  		current_network (network_a),
146  		work (work_),
147  		principal_weight_factor (1000), 
148  		default_node_port (44000),
149  		default_rpc_port (45000),
150  		default_ipc_port (46000),
151  		default_websocket_port (47000),
152  		aec_loop_interval_ms (300), 
153  		cleanup_period (default_cleanup_period),
154  		keepalive_period (std::chrono::seconds (15)),
155  		idle_timeout (default_cleanup_period * 2),
156  		silent_connection_tolerance_time (std::chrono::seconds (120)),
157  		syn_cookie_cutoff (std::chrono::seconds (5)),
158  		bootstrap_interval (std::chrono::seconds (15 * 60)),
159  		max_peers_per_ip (default_max_peers_per_ip),
160  		max_peers_per_subnetwork (default_max_peers_per_ip * 4),
161  		ipv6_subnetwork_prefix_for_limiting (64), 
162  		peer_dump_interval (std::chrono::seconds (5 * 60)),
163  		vote_broadcast_interval (15 * 1000)
164  	{
165  		if (is_live_network ())
166  		{
167  			default_node_port = 7075;
168  			default_rpc_port = 7076;
169  			default_ipc_port = 7077;
170  			default_websocket_port = 7078;
171  		}
172  		else if (is_beta_network ())
173  		{
174  			default_node_port = 54000;
175  			default_rpc_port = 55000;
176  			default_ipc_port = 56000;
177  			default_websocket_port = 57000;
178  		}
179  		else if (is_test_network ())
180  		{
181  			default_node_port = test_node_port ();
182  			default_rpc_port = test_rpc_port ();
183  			default_ipc_port = test_ipc_port ();
184  			default_websocket_port = test_websocket_port ();
185  		}
186  		else if (is_dev_network ())
187  		{
188  			aec_loop_interval_ms = 20;
189  			cleanup_period = std::chrono::seconds (1);
190  			keepalive_period = std::chrono::seconds (1);
191  			idle_timeout = cleanup_period * 15;
192  			max_peers_per_ip = 20;
193  			max_peers_per_subnetwork = max_peers_per_ip * 4;
194  			peer_dump_interval = std::chrono::seconds (1);
195  			vote_broadcast_interval = 500;
196  			telemetry_request_cooldown = 500ms;
197  			telemetry_cache_cutoff = 2000ms;
198  			telemetry_request_interval = 500ms;
199  			telemetry_broadcast_interval = 500ms;
200  			optimistic_activation_delay = 2s;
201  		}
202  	}
203  	static char const * active_network_err_msg;
204  	nano::networks current_network{ nano::network_constants::active_network };
205  	nano::work_thresholds & work;
206  	unsigned principal_weight_factor;
207  	uint16_t default_node_port;
208  	uint16_t default_rpc_port;
209  	uint16_t default_ipc_port;
210  	uint16_t default_websocket_port;
211  	unsigned aec_loop_interval_ms;
212  	std::chrono::seconds cleanup_period;
213  	std::chrono::milliseconds cleanup_period_half () const
214  	{
215  		return std::chrono::duration_cast<std::chrono::milliseconds> (cleanup_period) / 2;
216  	}
217  	std::chrono::seconds cleanup_cutoff () const
218  	{
219  		return cleanup_period * 5;
<span onclick='openModal()' class='match'>220  	}
221  	std::chrono::seconds keepalive_period;
222  	std::chrono::seconds idle_timeout;
223  	std::chrono::seconds silent_connection_tolerance_time;
224  	std::chrono::seconds syn_cookie_cutoff;
225  	std::chrono::seconds bootstrap_interval;
226  	size_t max_peers_per_ip;
227  	size_t max_peers_per_subnetwork;
228  	size_t ipv6_subnetwork_prefix_for_limiting;
229  	std::chrono::seconds peer_dump_interval;
230  	uint64_t vote_broadcast_interval;
231  	std::chrono::milliseconds telemetry_request_cooldown{ 1000 * 15 };
232  	std::chrono::milliseconds telemetry_request_interval{ 1000 * 60 };
233  	std::chrono::milliseconds telemetry_broadcast_interval{ 1000 * 60 };
234  	std::chrono::milliseconds telemetry_cache_cutoff{ 1000 * 130 }; 
235  	std::chrono::seconds optimistic_activation_delay{ 30 };
</span>236  	nano::networks network () const
237  	{
238  		return current_network;
239  	}
240  	static void set_active_network (nano::networks network_a)
241  	{
242  		active_network = network_a;
243  	}
244  	static bool set_active_network (std::string network_a)
245  	{
246  		auto error{ false };
247  		if (network_a == "live")
248  		{
249  			active_network = nano::networks::nano_live_network;
250  		}
251  		else if (network_a == "beta")
252  		{
253  			active_network = nano::networks::nano_beta_network;
254  		}
255  		else if (network_a == "dev")
256  		{
257  			active_network = nano::networks::nano_dev_network;
258  		}
259  		else if (network_a == "test")
260  		{
261  			active_network = nano::networks::nano_test_network;
262  		}
263  		else
264  		{
265  			error = true;
266  		}
267  		return error;
268  	}
269  	char const * get_current_network_as_string ()
270  	{
271  		return is_live_network () ? "live" : is_beta_network () ? "beta"
272  		: is_test_network ()                                    ? "test"
273  																: "dev";
274  	}
275  	bool is_live_network () const
276  	{
277  		return current_network == nano::networks::nano_live_network;
278  	}
279  	bool is_beta_network () const
280  	{
281  		return current_network == nano::networks::nano_beta_network;
282  	}
283  	bool is_dev_network () const
284  	{
285  		return current_network == nano::networks::nano_dev_network;
286  	}
287  	bool is_test_network () const
288  	{
289  		return current_network == nano::networks::nano_test_network;
290  	}
291  	static nano::networks active_network;
292  	uint8_t const protocol_version = 0x13;
293  	uint8_t const protocol_version_min = 0x12;
294  	uint8_t const bootstrap_protocol_version_min = 0x13;
295  };
296  std::string get_node_toml_config_path (boost::filesystem::path const & data_path);
297  std::string get_rpc_toml_config_path (boost::filesystem::path const & data_path);
298  std::string get_access_toml_config_path (boost::filesystem::path const & data_path);
299  std::string get_qtwallet_toml_config_path (boost::filesystem::path const & data_path);
300  std::string get_tls_toml_config_path (boost::filesystem::path const & data_path);
301  bool running_within_valgrind ();
302  bool memory_intensive_instrumentation ();
303  bool slow_instrumentation ();
304  bool is_sanitizer_build ();
305  void force_nano_dev_network ();
306  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-throw_delegate_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-config.hpp</div>
                </div>
                <div class="column column_space"><pre><code>57  }
58  TEST(ThrowDelegate, ThrowStdLogicErrorChar) {
59    ExpectThrowChar<std::logic_error>(ThrowStdLogicError);
60  }
61  TEST(ThrowDelegate, ThrowStdInvalidArgumentChar) {
62    ExpectThrowChar<std::invalid_argument>(ThrowStdInvalidArgument);
63  }
64  TEST(ThrowDelegate, ThrowStdDomainErrorChar) {
65    ExpectThrowChar<std::domain_error>(ThrowStdDomainError);
66  }
67  TEST(ThrowDelegate, ThrowStdLengthErrorChar) {
68    ExpectThrowChar<std::length_error>(ThrowStdLengthError);
69  }
70  TEST(ThrowDelegate, ThrowStdOutOfRangeChar) {
71    ExpectThrowChar<std::out_of_range>(ThrowStdOutOfRange);
72  }
</pre></code></div>
                <div class="column column_space"><pre><code>220  	}
221  	std::chrono::seconds keepalive_period;
222  	std::chrono::seconds idle_timeout;
223  	std::chrono::seconds silent_connection_tolerance_time;
224  	std::chrono::seconds syn_cookie_cutoff;
225  	std::chrono::seconds bootstrap_interval;
226  	size_t max_peers_per_ip;
227  	size_t max_peers_per_subnetwork;
228  	size_t ipv6_subnetwork_prefix_for_limiting;
229  	std::chrono::seconds peer_dump_interval;
230  	uint64_t vote_broadcast_interval;
231  	std::chrono::milliseconds telemetry_request_cooldown{ 1000 * 15 };
232  	std::chrono::milliseconds telemetry_request_interval{ 1000 * 60 };
233  	std::chrono::milliseconds telemetry_broadcast_interval{ 1000 * 60 };
234  	std::chrono::milliseconds telemetry_cache_cutoff{ 1000 * 130 }; 
235  	std::chrono::seconds optimistic_activation_delay{ 30 };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    