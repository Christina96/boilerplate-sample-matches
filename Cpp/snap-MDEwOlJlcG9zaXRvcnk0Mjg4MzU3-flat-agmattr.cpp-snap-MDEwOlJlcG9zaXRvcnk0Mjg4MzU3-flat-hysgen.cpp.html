
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 40.058479532163744%, Tokens: 29</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmattr.h"
3  #include "Snap.h"
4  #include "agm.h"
5  void TCesna::RandomInit(const int InitComs) {
6    F.Gen(G->GetNodes());
7    SumFV.Gen(InitComs);
8    NumComs = InitComs;
9    for (int u = 0; u < F.Len(); u++) {
10      int Mem = G->GetNI(u).GetDeg();
11      if (Mem > 10) { Mem = 10; }
12      for (int c = 0; c < Mem; c++) {
13        int CID = Rnd.GetUniDevInt(InitComs);
14        AddCom(u, CID, Rnd.GetUniDev());
15      }
16    }
17    for (int c = 0; c < SumFV.Len(); c++) {
18      if (SumFV[c] == 0.0) {
19        int UID = Rnd.GetUniDevInt(G->GetNodes());
20        AddCom(UID, c, Rnd.GetUniDev());
21      }
22    }
23    InitW();
24  }
25  void TCesna::NeighborComInit(const int InitComs) {
26    TFltIntPrV NIdPhiV(F.Len(), 0);
27    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
28    NeighborComInit(NIdPhiV, InitComs);
29  }
30  void TCesna::NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs) {
31    NIdPhiV.Sort(true);
32    F.Gen(G->GetNodes());
33    SumFV.Gen(InitComs);
34    NumComs = InitComs;
35    TIntSet InvalidNIDS(F.Len());
36    TIntV ChosenNIDV(InitComs, 0); 
37    int CurCID = 0;
38    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
39      int UID = NIdPhiV[ui].Val2;
40      fflush(stdout);
41      if (InvalidNIDS.IsKey(UID)) { continue; }
42      ChosenNIDV.Add(UID); 
43      AddCom(UID, CurCID, 1.0);
44      TUNGraph::TNodeI NI = G->GetNI(UID);
45      fflush(stdout);
46      for (int e = 0; e < NI.GetDeg(); e++) {
47        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
48      }
49      for (int e = 0; e < NI.GetDeg(); e++) {
50        InvalidNIDS.AddKey(NI.GetNbrNId(e));
51      }
<span onclick='openModal()' class='match'>52      CurCID++;
53      fflush(stdout);
54      if (CurCID >= NumComs) { break;  }
55    }
56    if (NumComs > CurCID) {
57      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
58    }
59    for (int c = 0; c < SumFV.Len(); c++) {
60      if (SumFV[c] == 0.0) {
61        int ComSz = 10;
62        for (int u = 0; u < ComSz; u++) {
63          int UID = Rnd.GetUniDevInt(G->GetNodes());
64          AddCom(UID, c, Rnd.GetUniDev());
65        }
66      }
67    }
68    InitW();
69  }
</span>70  void TCesna::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
71    F.Gen(G->GetNodes());
72    SumFV.Gen(CmtyVV.Len());
73    NumComs = CmtyVV.Len();
74    InitW();
75    for (int c = 0; c < CmtyVV.Len(); c++) {
76      for (int u = 0; u < CmtyVV[c].Len(); u++) {
77        int UID = CmtyVV[c][u];
78        if (! NIDToIdx.IsKey(UID)) { continue; }
79        AddCom(NIDToIdx.GetKeyId(UID), c, 1.0);
80      }
81    }
82  }
83  void TCesna::SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH) {
84    HOVIDSV.Gen(GraphPt->GetNodes());  
85    HOKIDSV.Gen(GraphPt->GetNodes());  
86    X.Gen(GraphPt->GetNodes());
87    TIntV NIDV;
88    GraphPt->GetNIdV(NIDV);
89    NIDToIdx.Gen(NIDV.Len());
90    NIDToIdx.AddKeyV(NIDV);
91    printf("rearrage nodes\n");
92    G = TSnap::GetSubGraph(GraphPt, NIDV, true);
93    for (int nid = 0; nid < G->GetNodes(); nid++) {
94      IAssert(G->IsNode(nid)); 
95    }
96    TSnap::DelSelfEdges(G);
97    PNoCom = 1.0 / (double) G->GetNodes();
98    DoParallel = false;
99    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
100    NegWgt = 1.0;
101    int NumAttr = 0;
102    for (int u = 0; u < NIDAttrH.Len(); u++) {
103      int UID = NIDAttrH.GetKey(u);
104      if (! NIDToIdx.IsKey(UID)) { continue; }
105      X[NIDToIdx.GetKeyId(UID)].Gen(NIDAttrH[u].Len());
106      for (int k = 0; k < NIDAttrH[u].Len(); k++) {
107        int KID = NIDAttrH[u][k];
108        IAssert (KID >= 0);
109        X[NIDToIdx.GetKeyId(UID)].AddKey(KID);
110        if (NumAttr < KID + 1) { NumAttr = KID + 1; } 
111      }
112    }
113    Attrs = NumAttr;
114    InitW();
115  }
116  double TCesna::Likelihood(const bool _DoParallel) { 
117    TExeTm ExeTm;
118    double L = 0.0;
119    if (_DoParallel) {
120    #pragma omp parallel for 
121      for (int u = 0; u < F.Len(); u++) {
122        double LU = LikelihoodForRow(u);
123        #pragma omp atomic
124          L += LU;
125      }
126    }
127    else {
128      for (int u = 0; u < F.Len(); u++) {
129        double LU = LikelihoodForRow(u);
130          L += LU;
131      }
132    }
133    return L;
134  }
135  double TCesna::LikelihoodForRow(const int UID) {
136    return LikelihoodForRow(UID, F[UID]);
137  }
138  double TCesna::LikelihoodForRow(const int UID, const TIntFltH& FU) {
139    double L = 0.0;
140    TFltV HOSumFV; 
141    if (HOVIDSV[UID].Len() > 0) {
142      HOSumFV.Gen(SumFV.Len());
143      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
144        for (int c = 0; c < SumFV.Len(); c++) {
145          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
146        }
147      }
148    }
149    TUNGraph::TNodeI NI = G->GetNI(UID);
150    for (int e = 0; e < NI.GetDeg(); e++) {
151      int v = NI.GetNbrNId(e);
152      if (v == UID) { continue; }
153      if (HOVIDSV[UID].IsKey(v)) { continue; }
154      L += log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
155    }
156    for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
157      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
158      L -= NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
159    }
160    if (RegCoef > 0.0) { 
161      L -= RegCoef * Sum(FU);
162    }
163    if (RegCoef < 0.0) { 
164      L += RegCoef * Norm2(FU);
165    }
166    L *= (1.0 - WeightAttr);
167    for (int k = 0; k < Attrs; k++) {
168      if (HOKIDSV[UID].IsKey(k)) { continue; }
169      L += WeightAttr * LikelihoodAttrKForRow(UID, k, FU);
170    }
171    return L;
172  }
173  double TCesna::LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK) {
174    double Prob = PredictAttrK(FU, WK);
175    double L = 0.0;
176    if (GetAttr(UID, K)) { 
177      L = Prob == 0.0? -100.0: log(Prob);
178    } else {
179      L = Prob == 1.0? -100.0: log(1.0 - Prob);
180    }
181    return L;
182  }
183  void TCesna::GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
184    GradU.Gen(CIDSet.Len());
185    TFltV HOSumFV; 
186    if (HOVIDSV[UID].Len() > 0) {
187      HOSumFV.Gen(SumFV.Len());
188      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
189        for (int c = 0; c < SumFV.Len(); c++) {
190          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
191        }
192      }
193    }
194    TUNGraph::TNodeI NI = G->GetNI(UID);
195    int Deg = NI.GetDeg();
196    TFltV PredV(Deg), GradV(CIDSet.Len());
197    TIntV CIDV(CIDSet.Len());
198    for (int e = 0; e < Deg; e++) {
199      if (NI.GetNbrNId(e) == UID) { continue; }
200      if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
201      PredV[e] = Prediction(UID, NI.GetNbrNId(e));
202    }
203    for (int c = 0; c < CIDSet.Len(); c++) {
204      int CID = CIDSet.GetKey(c);
205      double Val = 0.0;
206      for (int e = 0; e < Deg; e++) {
207        int VID = NI.GetNbrNId(e);
208        if (VID == UID) { continue; }
209        if (HOVIDSV[UID].IsKey(VID)) { continue; }
210        Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
211      }
212      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
213      Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
214      CIDV[c] = CID;
215      GradV[c] = Val;
216    }
217    if (RegCoef > 0.0) { 
218      for (int c = 0; c < GradV.Len(); c++) {
219        GradV[c] -= RegCoef; 
220      }
221    }
222    if (RegCoef < 0.0) { 
223      for (int c = 0; c < GradV.Len(); c++) {
224        GradV[c] += 2 * RegCoef * GetCom(UID, CIDV[c]); 
225      }
226    }
227    for (int c = 0; c < GradV.Len(); c++) {
228      GradV[c] *= (1.0 - WeightAttr);
229    }
230    TFltV AttrPredV(Attrs);
231    for (int k = 0; k < Attrs; k++) {
232      if (HOKIDSV[UID].IsKey(k)) { continue; }
233      AttrPredV[k] = PredictAttrK(F[UID], W[k]);
234    }
235    for (int c = 0; c < GradV.Len(); c++) {
236      for (int k = 0; k < Attrs; k++) {
237        if (HOKIDSV[UID].IsKey(k)) { continue; }
238        GradV[c] += WeightAttr * (GetAttr(UID, k) - AttrPredV[k]) * GetW(CIDV[c], k);
239      }
240    }
241    for (int c = 0; c < GradV.Len(); c++) {
242      if (GetCom(UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
243      if (fabs(GradV[c]) < 0.0001) { continue; }
244      GradU.AddDat(CIDV[c], GradV[c]);
245    }
246    for (int c = 0; c < GradU.Len(); c++) {
247      if (GradU[c] >= 10) { GradU[c] = 10; }
248      if (GradU[c] <= -10) { GradU[c] = -10; }
249      IAssert(GradU[c] >= -10);
250    }
251  }
252  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV) {
253    TVec<TFltV> TmpV;
254    GetCmtyVV(CmtyVV, TmpV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
255  }
256  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz) {
257    CmtyVV.Gen(NumComs, 0);
258    Wck.Gen(NumComs, 0);
259    TIntFltH CIDSumFH(NumComs);
260    for (int c = 0; c < SumFV.Len(); c++) {
261      CIDSumFH.AddDat(c, SumFV[c]);
262    }
263    CIDSumFH.SortByDat(false);
264    for (int c = 0; c < NumComs; c++) {
265      int CID = CIDSumFH.GetKey(c);
266      TIntFltH NIDFucH(F.Len() / 10);
267      TIntV CmtyV;
268      IAssert(SumFV[CID] == CIDSumFH.GetDat(CID));
269      if (SumFV[CID] < Thres) { continue; }
270      for (int u = 0; u < F.Len(); u++) {
271        int NID = NIDToIdx[u];
272        if (GetCom(u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(u, CID)); }
273      }
274      NIDFucH.SortByDat(false);
275      NIDFucH.GetKeyV(CmtyV);
276      if (CmtyV.Len() < MinSz) { continue; }
277      CmtyVV.Add(CmtyV); 
278      TFltV WV(Attrs);
279      for (int k = 0; k < Attrs; k++) {
280        WV[k] = GetW(CID, k);
281      }
282      Wck.Add(WV);
283    }
284    if ( NumComs != CmtyVV.Len()) {
285      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
286    }
287  }
288  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
289    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
290  }
291  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
292    CmtyVV.Gen(NumComs, 0);
293    for (int c = 0; c < NumComs; c++) {
294      TIntV CmtyV;
295      for (int u = 0; u < G->GetNodes(); u++) {
296        if (GetCom(u, c) > Thres) { CmtyV.Add(NIDToIdx[u]); }
297      }
298      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
299    }
300    if ( NumComs != CmtyVV.Len()) {
301      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
302    }
303  }
304  int TCesna::FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC, const double HOFrac, const double StepAlpha, const double StepBeta) {
305      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
306      TIntV ComsV;
307      ComsV.Add(MinComs);
308      while (ComsV.Len() < DivComs) {
309        int NewComs = int(ComsV.Last() * ComsGap);
310        if (NewComs == ComsV.Last().Val) { NewComs++; }
311        ComsV.Add(NewComs);
312      }
313      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
314      return FindComs(ComsV, UseBIC, HOFrac, NumThreads, OutFNm, StepAlpha, StepBeta);
315  }
316  int TCesna::FindComs(TIntV& ComsV, const bool UseBIC, const double HOFrac, const int NumThreads, const TStr PlotLFNm, const double StepAlpha, const double StepBeta) {
317    if (ComsV.Len() == 0) {
318      int MaxComs = G->GetNodes() / 5;
319      ComsV.Add(2);
320      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
321    }
322    int MaxIterCV = 3;
323    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV), HoldOutSetsAttr(MaxIterCV);
324    TFltIntPrV NIdPhiV;
325    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
326    if (! UseBIC) { 
327      TIntV NIdV1, NIdV2;
328      G->GetNIdV(NIdV1);
329      G->GetNIdV(NIdV2);
330      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
331        TCesnaUtil::GenHoldOutPairs(G, HoldOutSets[IterCV], HOFrac, Rnd);
332        GenHoldOutAttr(HOFrac, HoldOutSetsAttr[IterCV]);
333      }
334    }
335    TFltV HOLV(ComsV.Len());
336    TIntFltPrV ComsLV;
337    for (int c = 0; c < ComsV.Len(); c++) {
338      const int Coms = ComsV[c];
339      if (! UseBIC) { 
340        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
341          HOVIDSV = HoldOutSets[IterCV];
342          HOKIDSV = HoldOutSetsAttr[IterCV];
343          NeighborComInit(NIdPhiV, Coms);
344          if (NumThreads == 1) {
345            MLEGradAscent(0.01, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
346          } else {
347            MLEGradAscentParallel(0.01, 100, NumThreads, "", StepAlpha, StepBeta);
348          }
349          double HOL = LikelihoodHoldOut();
350          HOL = HOL < 0? HOL: TFlt::Mn;
351          HOLV[c] += HOL;
352        }
353      }
354      else {
355        HOVIDSV.Gen(G->GetNodes());
356        HOKIDSV.Gen(G->GetNodes());
357        if (NumThreads == 1) {
358          MLEGradAscent(0.005, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
359          printf("likelihood: train:%f, attr:%f, hold:%f\n", Likelihood(), LikelihoodAttr(), LikelihoodHoldOut());
360        } else {
361          MLEGradAscentParallel(0.005, 100, NumThreads, "", StepAlpha, StepBeta);
362        }
363        double NumParams = (1.0 - WeightAttr) * Coms + WeightAttr * Coms * Attrs;
364        double Observations = (1.0 - WeightAttr) * G->GetNodes() * (G->GetNodes() - 1) / 2 + WeightAttr * G->GetNodes() * Attrs;
365        double BIC = 2 * Likelihood() - NumParams * log (Observations);
366        HOLV[c] = BIC;
367      }
368    }
369    int EstComs = 2;
370    double MaxL = TFlt::Mn;
371    if (UseBIC) {
372      printf("Number of communities vs likelihood (criterion: BIC)\n");
373    } else {
374      printf("Number of communities vs likelihood (criterion: Cross validation)\n");
375    }
376    for (int c = 0; c < ComsV.Len(); c++) {
377      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
378      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
379      if (MaxL < HOLV[c]) {
380        MaxL = HOLV[c];
381        EstComs = ComsV[c];
382      }
383    }
384    printf("\n");
385    RandomInit(EstComs);
386    HOVIDSV.Gen(G->GetNodes());
387    HOKIDSV.Gen(G->GetNodes());
388    if (! PlotLFNm.Empty()) {
389      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
390    }
391    return EstComs;
392  }
393  double TCesna::LikelihoodHoldOut() { 
394    double L = 0.0;
395    for (int u = 0; u < HOVIDSV.Len(); u++) {
396      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
397        int VID = HOVIDSV[u][e];
398        if (VID == u) { continue; } 
399        double Pred = Prediction(u, VID);
400        if (G->IsEdge(u, VID)) {
401          L += log(1.0 - Pred);
402        }
403        else {
404          L += NegWgt * log(Pred);
405        }
406      } 
407    }
408    L *= (1.0 - WeightAttr);
409    for (int u = 0; u < HOKIDSV.Len(); u++) {
410      for (int e = 0; e < HOKIDSV[u].Len(); e++) {
411        IAssert(HOKIDSV[u][e] < Attrs);
412        L += WeightAttr * LikelihoodAttrKForRow(u, HOKIDSV[u][e]);
413      }
414    }
415    return L;
416  }
417  double TCesna::GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
418    double StepSize = 1.0;
419    double InitLikelihood = LikelihoodForRow(UID);
420    TIntFltH NewVarV(DeltaV.Len());
421    for(int iter = 0; iter < MaxIter; iter++) {
422      for (int i = 0; i < DeltaV.Len(); i++){
423        int CID = DeltaV.GetKey(i);
424        double NewVal = GetCom(UID, CID) + StepSize * DeltaV.GetDat(CID);
425        if (NewVal < MinVal) { NewVal = MinVal; }
426        if (NewVal > MaxVal) { NewVal = MaxVal; }
427        NewVarV.AddDat(CID, NewVal);
428      }
429      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
430        StepSize *= Beta;
431      } else {
432        break;
433      }
434      if (iter == MaxIter - 1) { 
435        StepSize = 0.0;
436        break;
437      }
438    }
439    return StepSize;
440  }
441  int TCesna::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
442    time_t InitTime = time(NULL);
443    TExeTm ExeTm, CheckTm;
444    int iter = 0, PrevIter = 0;
445    TIntFltPrV IterLV;
446    TUNGraph::TNodeI UI;
447    double PrevL = TFlt::Mn, CurL = 0.0;
448    TIntV NIdxV(F.Len(), 0);
449    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
450    TIntFltH GradV;
451    TIntSet CIDSet(NumComs);
452    for (int c = 0; c < NumComs; c++) { CIDSet.AddKey(c); }
453    while(iter < MaxIter) {
454      NIdxV.Shuffle(Rnd);
455      for (int ui = 0; ui < F.Len(); ui++, iter++) {
456        int u = NIdxV[ui]; 
457        GradientForRow(u, GradV, CIDSet);
458        if (Norm2(GradV) < 1e-4) { continue; }
459        double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
460        if (LearnRate == 0.0) { continue; }
461        for (int ci = 0; ci < GradV.Len(); ci++) {
462          int CID = GradV.GetKey(ci);
463          double Change = LearnRate * GradV.GetDat(CID);
464          double NewFuc = GetCom(u, CID) + Change;
465          if (NewFuc <= 0.0) {
466            DelCom(u, CID);
467          } else {
468            AddCom(u, CID, NewFuc);
469          }
470        }
471        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
472          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
473        }
474      }
475      for (int k = 0; k < Attrs; k++) {
476        TFltV GradWV(NumComs);
477        GradientForWK(GradWV, k);
478        if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
479        double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
480        if (LearnRate == 0.0) { continue; }
481        for (int c = 0; c < GradWV.Len(); c++){
482          W[k][c] += LearnRate * GradWV[c];
483          if (W[k][c] < MinValW) { W[k][c] = MinValW; }
484          if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
485        }
486      }
487      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
488      fflush(stdout);
489      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
490        PrevIter = iter;
491        CurL = Likelihood();
492        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
493          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
494        }
495        fflush(stdout);
496        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
497        else { PrevL = CurL; }
498      }
499    }
500    printf("\n");
501    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
502    if (! PlotNm.Empty()) {
503      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
504    }
505    return iter;
506  }
507  int TCesna::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
508    time_t InitTime = time(NULL);
509    uint64 StartTm = TSecTm::GetCurTm().GetAbsSecs();
510    TExeTm ExeTm, CheckTm;
511    double PrevL = Likelihood(true);
512    TIntFltPrV IterLV;
513    int PrevIter = 0;
514    int iter = 0;
515    TIntV NIdxV(F.Len(), 0);
516    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
517    TIntV NIDOPTV(F.Len()); 
518    NIDOPTV.PutAll(0);
519    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
520    TIntV NewNIDV(ChunkNum * ChunkSize);
521    for (iter = 0; iter < MaxIter; iter++) {
522      NIdxV.Clr(false);
523      for (int i = 0; i < F.Len(); i++) { 
524        if (NIDOPTV[i] == 0) {  NIdxV.Add(i); }
525      }
526      IAssert (NIdxV.Len() <= F.Len());
527      NIdxV.Shuffle(Rnd);
528  #pragma omp parallel for schedule(static, 1)
529      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
530        TIntFltH GradV;
531        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
532          NewNIDV[ui] = -1;
533          if (ui >= NIdxV.Len()) { continue; }
534          int u = NIdxV[ui]; 
535          TUNGraph::TNodeI UI = G->GetNI(u);
536          TIntSet CIDSet(5 * UI.GetDeg());
537          TIntFltH CurFU = F[u];
538          for (int e = 0; e < UI.GetDeg(); e++) {
539            if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
540            TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
541            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
542              CIDSet.AddKey(CI.GetKey());
543            }
544          }
545          if (CIDSet.Empty()) { 
546            CurFU.Clr();
547          }
548          else {
549            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
550              if (! CIDSet.IsKey(CI.GetKey())) {
551                CurFU.DelIfKey(CI.GetKey());
552              }
553            }
554            GradientForRow(u, GradV, CIDSet);
555            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
556            double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
557            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
558            for (int ci = 0; ci < GradV.Len(); ci++) {
559              int CID = GradV.GetKey(ci);
560              double Change = LearnRate * GradV.GetDat(CID);
561              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
562              if (NewFuc <= 0.0) {
563                CurFU.DelIfKey(CID);
564              } else {
565                CurFU.AddDat(CID) = NewFuc;
566              }
567            }
568            CurFU.Defrag();
569          }
570          NewF[ui] = CurFU;
571          NewNIDV[ui] = u;
572        }
573      }
574      int NumNoChangeGrad = 0;
575      int NumNoChangeStepSize = 0;
576      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
577        int NewNID = NewNIDV[ui];
578        if (NewNID == -1) { NumNoChangeGrad++; continue; }
579        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
580        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
581          SumFV[CI.GetKey()] -= CI.GetDat();
582        }
583      }
584  #pragma omp parallel for
585      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
586        int NewNID = NewNIDV[ui];
587        if (NewNID < 0) { continue; }
588        F[NewNID] = NewF[ui];
589      }
590      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
591        int NewNID = NewNIDV[ui];
592        if (NewNID < 0) { continue; }
593        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
594          SumFV[CI.GetKey()] += CI.GetDat();
595        }
596      }
597      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
598        int NewNID = NewNIDV[ui];
599        if (NewNID < 0) { continue; }
600        TUNGraph::TNodeI UI = G->GetNI(NewNID);
601        NIDOPTV[NewNID] = 0;
602        for (int e = 0; e < UI.GetDeg(); e++) {
603          NIDOPTV[UI.GetNbrNId(e)] = 0;
604        }
605      }
606      int OPTCnt = 0;
607      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
608      if (! PlotNm.Empty()) {
609        printf("\r%d iterations [%s] %s secs", iter * ChunkSize * ChunkNum, ExeTm.GetTmStr(), TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
610        if (PrevL > TFlt::Mn) { printf(" (%f) %d g %d s %d OPT", PrevL, NumNoChangeGrad, NumNoChangeStepSize, OPTCnt); }
611        fflush(stdout);
612      }
613      if (iter == 0 || (iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
614    #pragma omp parallel for
615        for (int k = 0; k < Attrs; k++) {
616          TFltV GradWV(NumComs);
617          GradientForWK(GradWV, k);
618          if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
619          double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
620          if (LearnRate == 0.0) { continue; }
621          for (int c = 0; c < GradWV.Len(); c++){
622            W[k][c] += LearnRate * GradWV[c];
623            if (W[k][c] < MinValW) { W[k][c] = MinValW; }
624            if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
625          }
626        }
627        PrevIter = iter;
628        double CurL = Likelihood(true);
629        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
630        printf("\r%d iterations, Likelihood: %f, Diff: %f [%lu secs]", iter, CurL,  CurL - PrevL, time(NULL) - InitTime);
631         fflush(stdout);
632        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
633          break;
634        }
635        else {
636          PrevL = CurL;
637        }
638      }
639    }
640    if (! PlotNm.Empty()) {
641      printf("\nMLE completed with %d iterations(%s secs)\n", iter, TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
642      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
643    } else {
644      printf("\rMLE completed with %d iterations(%lu secs)", iter, time(NULL) - InitTime);
645      fflush(stdout);
646    }
647    return iter;
648  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "hysgen.h"
3  void THysgenUtil::DumpCmtyVV(const TStr OutFNm, TVec<TIntV>& CmtyVV, TIntStrH& NIDNmH) {
4    FILE* F = fopen(OutFNm.CStr(), "wt");
5    for (int c = 0; c < CmtyVV.Len(); c++) {
6      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVV[c].Len());
7      for (int u = 0; u < CmtyVV[c].Len(); u++) {
8        if (NIDNmH.IsKey(CmtyVV[c][u])){
9          fprintf(F, "%s\t", NIDNmH.GetDat(CmtyVV[c][u]).CStr());
10        }
11        else {
12          fprintf(F, "%d\t", (int) CmtyVV[c][u]);
13        }
14      }
15      fprintf(F, "\n");
16    }
17    fclose(F);
18  }
19  void THysgenUtil::DumpCmtyVH(const TStr OutFNm, TVec<TIntFltH>& CmtyVH, TIntStrH& NIDNmH, Criteria Crit) {
20    FILE* F = fopen(OutFNm.CStr(), "wt");
21    int UId;
22    for (int c = 0; c < CmtyVH.Len(); c++) {
23      fprintf(F, "\n\n*** COMMUNITY #%d, Length=%d ***\n", c+1, CmtyVH[c].Len());
24      TIntV SortedV;
25      if (Crit == Alphabetical) {
26        TIntStrH SortedCNames;
27        for (TIntFltH::TIter NI = CmtyVH[c].BegI(); NI < CmtyVH[c].EndI(); NI++) {
28          SortedCNames.AddDat(NI.GetKey(), NIDNmH.GetDat(NI.GetKey()));
29        }
30        SortedCNames.SortByDat();
31        for (TIntStrH::TIter NI = SortedCNames.BegI();
32             NI < SortedCNames.EndI(); NI++) {
33          SortedV.Add(NI.GetKey());
34        }
35      } else {
36        CmtyVH[c].SortByDat(false);
37        CmtyVH[c].GetKeyV(SortedV);
38      }
39      for (TIntV ::TIter NI = SortedV.BegI(); NI < SortedV.EndI(); NI++) {
40        UId = NI->Val;
41        if (NIDNmH.IsKey(UId)){
42          fprintf(F, "%s: ", NIDNmH.GetDat(UId).CStr());
43        }
44        else {
45          fprintf(F, "%d: ", UId);
46        }
47        fprintf(F, "%f,\t", (double) CmtyVH[c].GetDat(UId));
48      }
49      fprintf(F, "\n");
50    }
51    fclose(F);
52  }
53  PHGraph THysgenUtil::LoadEdgeList(const TStr& InFNm, TStrHash<TInt>& NodeNameH,
54                                    TSsFmt SsFmt) {
55    TSsParser Ss(InFNm, SsFmt);
56    PHGraph PG = THGraph::New();
57    THGraph& G = *PG;
58    TStrHash<TInt> StrSet(Mega(1), true);
59    int EIdCtr = 0;
60    int RedunEdgesCnt = 0; 
61    std::string Curr;
62    while (Ss.Next()) {
63      TIntSet NIdH;
64      NIdH.Gen(Ss.Len());
65      if (Ss.Len() == 0) { continue; }
66      Curr = Ss[0];
67      if (Curr.compare(0,1, "#") == 0) { continue; } 
68      for (int i = 0; i < Ss.Len(); i++){
69        int ENId = StrSet.AddKey(Ss[i]);
70        if (! G.IsNode(ENId)) { G.AddNode(ENId, Ss[i]); }
71        NIdH.AddKey(ENId);
72      }
73      if (G.AddEdge(NIdH,EIdCtr) >= 0) {
74        EIdCtr++;
75      } else {RedunEdgesCnt++; }
76    }
77    printf("\nNumber of redundant edges: %d:\n", RedunEdgesCnt);
78    NodeNameH = StrSet;
79    NodeNameH.Pack();
80    G.Defrag();
81    return PG;
82  }
83  template<class PHGraph>
84  double THysgenUtil::GetConductance(const PHGraph& Graph, const TIntSet& CmtyS,
85                                     const int N2Edges) {
86    TIntV NeiNV;
87    int Vol = 0,  Cut = 0;
88    double Phi = 0.0;
89    for (int i = 0; i < CmtyS.Len(); i++) {
90      if (! Graph->IsNode(CmtyS[i])) { continue; }
91      THGraph::TNodeI  NI = Graph->GetNI(CmtyS[i]);
92      NI.GetNbrNodes(NeiNV);
93      for (int nei = 0; nei < NeiNV.Len(); nei++) {
94        if (! CmtyS.IsKey(NeiNV[nei])) { Cut += 1; }
95      }
96      Vol += NI.Get2Edges();
97    }
98    int N2Edges2 = N2Edges * 2;
99    if (Vol != N2Edges2) {
100      if (N2Edges2 - Vol < Vol) { Phi = Cut / double (N2Edges2 - Vol); }
101      else if (Vol == 0) { Phi = 0.0; }
102      else { Phi = Cut / double(Vol); }
103    } else {
104      if (Vol == N2Edges2) { Phi = 1.0; }
105    }
106    return Phi;
107  }
108  template<class PHGraph>
109  void THysgenUtil::GetNbhCom(const PHGraph& Graph, const int NID, TIntSet& NBCmtyS) {
110    THGraph::TNodeI NI = Graph->GetNI(NID);
111    NBCmtyS.Gen(NI.GetNbrNodes() + 1);
112    NBCmtyS.AddKey(NID);
113    for (int e = 0; e < NI.GetNbrNodes(); e++) {
114      NBCmtyS.AddKey(NI.GetNbrNId(e));
115    }
116  }
117  template<class PHGraph>
118  void THysgenUtil::GetPhiNIdPrV(const PHGraph &G, TFltIntPrV &PhiNIdPrV, const int MinComSiz) {
119    PhiNIdPrV.Gen(G->GetNodes(), 0);
120    const int N2Edges = G->Get2Edges();
121    TExeTm RunTm;
122    for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
123      TIntSet NBCmty(NI.GetNbrNodes() + 1);
124      double Phi;
125      if (NI.GetNbrNodes() < MinComSiz) { 
126        Phi = 1.0;
127      } else {
128        THysgenUtil::GetNbhCom<PHGraph>(G, NI.GetId(), NBCmty);
129        Phi = THysgenUtil::GetConductance(G, NBCmty, N2Edges);
130      }
131      PhiNIdPrV.Add(TFltIntPr(Phi, NI.GetId()));
132    }
133    PhiNIdPrV.Sort(true);
134    fflush(stdout);
135  }
136  void THysgenUtil::GetBinLocs(const int& DecNum, TIntV& LocsV, const TIntV& NodMapV) {
137    int MaxShift = ceil(TMath::Log2((double) DecNum+1));
138    int NumCopy = DecNum;
139    for (int j = 0; j < MaxShift; j++) {
140      if ( NumCopy / 2.0 != floor(NumCopy / 2.0) ) {
141        LocsV.Add(NodMapV[j]);
142      }
143      NumCopy = int(NumCopy / 2.0);
144    }
145  }
146  void THysgen::SetGraph(const PHGraph& GraphPt) {
147    HONEIdsV.Gen(GraphPt->GetNodes());
148    HONNIdsV.Gen(GraphPt->GetNodes());
149    HOKIDSV.Gen(GraphPt->GetNodes());
150    TIntV NIDV;
151    GraphPt->GetNIdV(NIDV);
152    NIdToIdx.Gen(NIDV.Len());
153    NIdToIdx.AddKeyV(NIDV);
154    G = TSnap::GetSubGraph(GraphPt, NIDV);
155    for (int nid = 0; nid < G->GetNodes(); nid++) {
156      IAssert(G->IsNode(nid));
157    }
158    PrNoCom = 1.0 / (double) G->GetNodes();
159    if (1.0 / PrNoCom > sqrt(TFlt::Mx)) { PrNoCom = 0.99 / sqrt(TFlt::Mx); } 
160    NegWgt = 1.0;
161  }
162  void THysgen::LoadComInit(const TStr& InFNm, TSsFmt SsFmt) {
163    TSsParser Ss(InFNm, SsFmt);
164    TVec<TStrFltH> ComsVH;
165    TStrSet NodsInFile(G->GetNodes());
166    std::string Curr;
167    printf("Loading community initializations from file ...\n");
168    while (Ss.Next()) {
169      if (Ss.Len() == 0) { continue; }
170      Curr = Ss[0];
171      if (Curr.compare(0,1, "#") == 0 || Curr.compare(0,1, "*") == 0) { continue; } 
172      TStrFltH CurComH;
173      for (int i = 0; i < Ss.Len(); i++){
174        Curr = Ss[i];
175        TStr NName; double SN;
176        int SepLoc = Curr.find_first_of(":");
177        if (SepLoc == -1) {
178          NName = Curr.c_str();
179          SN = InitVal;
180        } else {
181          NName = Curr.substr(0, SepLoc).c_str();
182          SN = strtod(Curr.substr(SepLoc + 2, 8).c_str(), NULL);
183        }
184        CurComH.AddDat(NName, SN);
185        NodsInFile.AddKey(NName);
186      }
187      ComsVH.Add(CurComH);
188    }
189    for (int c = 0; c < ComsVH.Len(); c++) {
190      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
191        AddNCom(NI.GetId(), c, InitNullS);
192        if (ComsVH[c].IsKey(NI.GetName())) {
193          AddNCom(NI.GetId(), c, ComsVH[c].GetDat(NI.GetName()));
194        }
195      }
196    }
197    printf("\n");
198    for (int c = 0; c < GetNumComs(); c++) {
199      printf("comm %d:\t\t", c);
200      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
201        if (GetNCom(NI.GetId(),c) > InitNullS) {
202          printf("%s,%0.2f\t",NI.GetName().CStr(), GetNCom(NI.GetId(),c));
203        }
204      }
205      printf("\n");
206    }
207    printf("\n Likelihood of the initial community memberships from the file is: %f\n", Likelihood());
208  }
209  void THysgen::ComInit(const int InitComs, const int MinComSiz, const double PerturbDens) {
210    IAssertR(InitVal>0.0 || InitNullS>0.0, "Error: At least one of -ic or -in "
211             "parameters should be set > 0. Cannot start without any initalization.");
212    S.Gen(G->GetNodes()); 
213    time_t InitTime = time(NULL);
214    printf("\n** Initializing the communities and the parameters is started...\n");
215    NumCIdNV.Gen(InitComs);
216    NumComs = InitComs;
217    if (InitNullS > 0.0) {
218      UniformComInit(InitComs);
219      InitTime = time(NULL);
220      InitEdgeProb();
221    }
222    if (InitNullS != InitVal) {
223      InitTime = time(NULL);
224      NeighborComInit(MinComSiz, InitNullS==0.0);
225      if (InitNullS==0.0) {
226        InitTime = time(NULL);
227        InitEdgeProb();
228      }
229    }
230    if (InitNullS != InitVal) {
231      RandomComPerturb(PerturbDens);
232    } else { RandomComPerturb(); }
233    printf("\n** Initializations finsihed [%lu sec]\n", time(NULL) - InitTime);
234  }
235  void THysgen::UniformComInit(const int InitComs) {
236    for (int c=0; c < NumComs; c++) {
237      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
238        AddNCom(NI.GetId(), c, InitNullS, true);
239      }
240    }
241  }
242  void THysgen::RandomComPerturb(double Density) {
243    if (Density <= 0.0) { return; }
244    for (int c=0; c < NumComs; c++) {
245      for (THGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
246        if (GetNCom(NI.GetId(), c) == 0) { continue; } 
247        if (Rnd.GetUniDev() < Density) { AddNCom(NI.GetId(), c, InitVal*Rnd.GetUniDev()); }
248      }
249    }
250  }
251  void THysgen::NeighborComInit(const int MinComSiz, const bool& IsInit) {
252    TFltIntPrV PhiNIdPrV;
253    THysgenUtil::GetPhiNIdPrV<PHGraph>(G, PhiNIdPrV, MinComSiz);
254    NeighborComInit(PhiNIdPrV, IsInit);
255  }
256  void THysgen::NeighborComInit(TFltIntPrV& PhiNIdPrV, const bool& IsInit) {
257    PhiNIdPrV.Sort(true);
258    TIntV NIdV;
259    TIntV EIdV;
260    THGraph::TNodeI NI;
261    THGraph::TEdgeI EI;
262    TIntSet InvalidNIDS(S.Len());
263    TIntV NumCIdNDefV(NumComs, 0);
264    int CurCID = 0;
265    for (int ui = 0; ui < PhiNIdPrV.Len(); ui++) {
266      if (PhiNIdPrV[ui].Val1 == 0.0) { 
267        continue;
268      }
269      int UID = PhiNIdPrV[ui].Val2;
270      fflush(stdout);
271      if (InvalidNIDS.IsKey(UID)) { continue; }
272      AddNCom(UID, CurCID, InitVal, IsInit);
273      InvalidNIDS.AddKey(UID);
274      NI = G->GetNI(UID);
275      fflush(stdout);
276      NI.GetNbrNodes(NIdV);
277      AddNCom(NIdV, CurCID, InitVal, IsInit);
278      NumCIdNDefV[CurCID] = NIdV.Len()+1;
279      InvalidNIDS.AddKeyV(NIdV);
<span onclick='openModal()' class='match'>280      CurCID++;
281      if (CurCID >= NumComs) { break; }
282      fflush(stdout);
283    }
284    if (NumComs > CurCID) {
285      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
286    }
287    for (int c = 0; c < NumCIdNV.Len(); c++) {
288      if (NumCIdNDefV[c] == 0) {
289        printf("Empty communities remained after initialization. "
290               "Members are getting assigned randomly!!\n\n");
291        int ComSz = 10;
292        for (int u = 0; u < ComSz; u++) {
293          int UID = Rnd.GetUniDevInt(G->GetNodes());
294          AddNCom(UID, c, InitVal, IsInit);
295        }
296      }
297    }
298  }
</span>299  void THysgen::InitEdgeProb(){
300    TInt NId;
301    TInt CIterKey;
302    ProbEdgCommHH.Gen(G->GetEdges());
303    ProbNotEdgH.Gen(G->GetEdges());
304    ProbEdgH.Gen(G->GetEdges());
305    ProbENoiseV.Gen(G->GetNodes(),1);
306    ProbENoiseV[0] = 1;
307    int DPMatSize = NumComs + (SNoise>0); 
308    AuxDPEdgVV.Gen(DPMatSize);
309    for (int i = 0; i < DPMatSize; i++) {
310      AuxDPEdgVV[i].Gen(DPMatSize);
311      for (int j = 0; j < DPMatSize; j++) {
312        AuxDPEdgVV[i][j] = 0.0;
313      }
314    }
315    for (THGraph::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
316      TIntV NumMmbrsInEdgV(NumComs);
317      TIntFltH ProdH(NumComs);
318      TIntV NeiNV;
319      EI.GetNodesV(NeiNV);
320      for (int n = 0; n < NeiNV.Len(); n++) {
321        NId = NeiNV[n];
322        for (TIntFltH::TIter SNI = S[NId].BegI(); SNI < S[NId].EndI(); SNI++) {
323          CIterKey = SNI.GetKey();
324          if (!ProdH.IsKey(CIterKey)) { ProdH.AddDat(CIterKey, 1.0); }
325          ProdH.AddDat(CIterKey, ProdH.GetDat(CIterKey)*SNI.GetDat());
326          NumMmbrsInEdgV[CIterKey] ++;
327        }
328      }
329      for (int CId = 0; CId < NumComs; CId++){
330        if (NumMmbrsInEdgV[CId] > 0 && NumMmbrsInEdgV[CId] < NeiNV.Len()) {
331          ProdH.DelKey(CId);
332        }
333      }
334      AddECom(EI.GetId(), ProdH);
335    }
336    if (InitNullS > 0.0) { InitPrAllEdgesS(InitNullS, true);
337    } else { InitPrAllEdgesS(InitVal, false); }
338  }
339  void THysgen::UpdateUEdgesProb(const int& UId, const int& CId, const double& SUNew){
340    double SUOld = GetNCom(UId,CId);
341    TIntV EIdV;
342    TIntFltH ProbEH;
343    double PrECOld;
344    double PrECNew;
345    int EId;
346    G->GetNI(UId).GetEIDs(EIdV);
347    for (int e = 0; e < EIdV.Len(); e++) {
348      EId = EIdV[e];
349      if (SUOld < DBL_EPSILON) {
350        TIntV ENodesV;
351        G->GetEI(EId).GetNbrNodes(ENodesV);
352        PrECNew = SUNew;
353        for (int n = 0; n < ENodesV.Len(); n++) {
354          if (ENodesV[n] == UId) { continue; }
355          PrECNew *= GetNCom(ENodesV[n], CId);
356        }
357      } else {
358        PrECOld = GetECom(EId, CId);
359        PrECNew = PrECOld*SUNew/SUOld;
360      }
361      if (PrECNew > 0.0) {
362        AddECom(EId, CId, PrECNew);
363      } else {
364        DelECom(EId, CId);
365      }
366    }
367  }
368  void THysgen::InitPrAllEdgesS(const double& DefVal, const bool& IsEqualComms){
369    if (SumPrPsblEdgesPow_nVV.Len()==0) {
370      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
371    } else {
372      SumPrPsblEdgesPow_nVV.Clr();
373      SumPrPsblEdgesPow_nVV.Gen(NumCIdNV.Len(), 0.0);
374    }
375    TFlt SToN = 1.0;
376    for (int c=0; c<NumCIdNV.Len(); c++){
377      TFltV PsiV;
378      PsiV.Add(1.0);
379      SToN = 1.0;
380      for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) || (n<=TayN && PsiV[n-1]>TayThresh) ; n++){ 
381        SToN *= DefVal;
382        PsiV.Add(pow(SToN+1.0, NumCIdNV[c]) - 1);
383      }
384      SumPrPsblEdgesPow_nVV.Add(PsiV);
385      if (IsEqualComms && NumCIdNV.Len()>1) {
386        for (int c=1; c<NumCIdNV.Len(); c++) {
387          TFltV PsiVCopy(SumPrPsblEdgesPow_nVV[0]);
388          SumPrPsblEdgesPow_nVV.Add(PsiVCopy);
389        }
390        printf("\n Done the same initialization for the rest of %d communities...\n",NumComs()-1);
391        break;
392      }
393    }
394  }
395  void THysgen::UpdatePrAllEdgesS(const int &UID, const int &CID, const double& SNNew){
396    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
397    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, true);
398  }
399  void THysgen::UpdatePrAllEdgesS(TFltV& PsiV, const int& UID, const int& CID, const double& SNNew, const bool IsApplyChange){
400    PsiV[0] = 1.0; 
401    double SNOld = GetNCom(UID,CID);
402    double SToNOld = 1.0, SToNNew = 1.0;
403    int nLast = 0;
404    for (int n=1; (n <= MinTayN && PsiV[n-1] > 0.0) ||
405                  (n <= TayN    && PsiV[n-1]>TayThresh); n++){
406      if (n >= PsiV.Len()) {
407        PsiV.Add(0.0);
408      }
409      SToNOld *= SNOld; SToNNew *= SNNew;
410      PsiV[n] = ((SToNNew+1.0)/(SToNOld+1.0)) *
411                                      (SumPrPsblEdgesPow_nVV[CID][n]-SToNOld) + SToNNew; 
412      nLast = n;
413    }
414    if (IsApplyChange) {
415      for (int n = 1; n <= nLast; n++) {
416        if (n >= SumPrPsblEdgesPow_nVV[CID].Len()) {
417          SumPrPsblEdgesPow_nVV[CID].Add(-1.0);
418        }
419        SumPrPsblEdgesPow_nVV[CID][n] = PsiV[n];
420      }
421      nLast++;
422      while (nLast < SumPrPsblEdgesPow_nVV[CID].Len()) {
423        SumPrPsblEdgesPow_nVV[CID][nLast] = 0.0;
424        nLast++;
425      }
426    }
427  }
428  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID,
429                                    const bool IsLikelihood, const bool Verbose){
430    double SCoef = 1.0;
431    double LikCoef = 1.0;
432    double S_uc = GetNCom(UID,CID);
433    double SPowN = 1.0;
434    if (!IsLikelihood){
435      if (S_uc <= 0.0) { return SumPrPsblEdgesPow_nVV[CID][1]; }
436      else { SCoef = 1.0/S_uc; }
437    }
438    if (S_uc<=0.0 && IsLikelihood) { return 0.0; }
439    double Val = 0.0;
440    double Val_n;
441    if (Verbose) {
442      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
443    }
444    for (int n=1; n<SumPrPsblEdgesPow_nVV[CID].Len() &&
445                  SumPrPsblEdgesPow_nVV[CID][n]>TayThresh; n++){
446      if (IsLikelihood) { LikCoef = -n; }
447      SPowN *= S_uc;
448      Val_n = SCoef * (SPowN/(1+SPowN)) * (SumPrPsblEdgesPow_nVV[CID][n] - SPowN) / LikCoef;
449      Val += Val_n;
450      if(Verbose){
451        printf("\t --- (n=%d): %f\n", n , Val_n);
452      }
453    }
454    return Val;
455  }
456  double THysgen::PredictAllCEdgesS(const int &UID, const int &CID, const double& SNNew,
457                                    const bool IsLikelihood, const bool Verbose){
458    IAssertR(IsLikelihood,"This Overload of function is only designed for computing the likelihood, not gradient!\n");
459    double SCoef = 1.0;
460    double LikCoef;
461    double SPowN = 1.0;
462    if (SNNew <= 0.0) { return 0.0; } 
463    double Val = 0.0;
464    double Val_n;
465    if (Verbose) {
466      printf("### PredictAllCEdgesS for node %d and comm %d :\n", UID, CID);
467    }
468    TFltV PsiV(SumPrPsblEdgesPow_nVV[CID].Len());
469    UpdatePrAllEdgesS(PsiV, UID, CID, SNNew, false);
470    for (int n=1; n<PsiV.Len() && PsiV[n]>TayThresh; n++){ 
471      LikCoef = -n;
472      SPowN *= SNNew;
473      Val_n = SCoef * (SPowN/(1.0+SPowN)) * (PsiV[n] - SPowN) / LikCoef;
474      Val += Val_n;
475      if(Verbose){
476        printf("\t --- (n=%d): %f\n", n , Val_n);
477      }
478    }
479    return Val;
480  }
481  double THysgen::PredictAllCEdgesS_direct(const int &UID, const int &CID,
482                                           const bool IsLikelihood, const bool Verbose) {
483    double Psi_c = 0.0;
484    double S_uc = GetNCom(UID,CID);
485    if (S_uc <= 0.0 && IsLikelihood) { return 0.0; }
486    TIntV CNodesV(S.Len(),0);
487    for (int nod=0; nod < S.Len(); nod++) {
488      if (GetNCom(nod, CID) > 0.0 || nod==UID) {CNodesV.Add(nod);}
489    }
490    TInt NPsbEdges = pow(2, CNodesV.Len());
491    for (int e=0; e<NPsbEdges; e++) {
492      TIntV ENodesV;
493      THysgenUtil::GetBinLocs(e, ENodesV, CNodesV);
494      if (!ENodesV.IsIn(UID) || ENodesV.Len() < 2) { continue; }
495      double ECProb = 1.0;
496      for (int i = 0; i < ENodesV.Len(); i++) {
497        if (Verbose) {
498          printf("%d, ", ENodesV[i]()); }
499        if (ENodesV[i] != UID) { ECProb *= GetNCom(ENodesV[i], CID); }
500      }
501      if (Verbose) {
502        printf(" --\t ECProb=%f, ", ECProb);
503      }
504      if (ECProb == 1.0 && S_uc == 1.0) { continue; }
505      if (!IsLikelihood) {
506        Psi_c += (ECProb / (1.0 - ECProb*S_uc));
507      } else {
508        Psi_c += log(1.0 - ECProb*S_uc);
509      }
510      if (Verbose) {
511        printf(" *Islikelihood=%d*, Psi_c=%f\n", IsLikelihood, Psi_c); }
512    }
513    return Psi_c;
514  }
515  void THysgen::UpdateProbNotEdgH(const int &EId, const double &PrECNew,
516                                const double &PrECOld) {
517    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
518    if (PrECNew>=0.0 && ProbNotEdgH.IsKey(EId) && ProbNotEdgH.GetDat(EId)()==-1.0)  {
519      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId); 
520      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
521      if (1.0 - ProbEdgH.GetDat(EId) < 1.0) { 
522        ProbNotEdgH.AddDat(EId, 1.0 - ProbEdgH.GetDat(EId));
523      }
524      return;
525    }
526    double PrNotE;
527    if (PrECOld < 1.0){
528      PrNotE = ProbNotEdgH.GetDat(EId) * (1.0 - PrECNew) / (1.0 - PrECOld);
529    } else {
530      PrNotE = 1.0 - PrENoise;
531      for (TIntFltH::TIter HI = ProbEdgCommHH.GetDat(EId).BegI();
532           HI < ProbEdgCommHH.GetDat(EId).EndI(); HI++) {
533        PrNotE *= 1.0 - HI.GetDat();
534      }
535    }
536    ProbNotEdgH.AddDat(EId, PrNotE);
537    ProbEdgH.AddDat(EId, 1-PrNotE);
538    if (PrNotE >= 1.0) {
539      TIntFltH& ProdH = ProbEdgCommHH.GetDat(EId);
540      ProbEdgH.AddDat(EId, GetPrEPrecision(ProdH, AuxDPEdgVV, PrENoise));
541      ProbNotEdgH.AddDat(EId,-1.0);
542    }
543  }
544  double THysgen::DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
545    double DP = 0.0;
546    for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
547      if (UV.IsKey(HI.GetKey())) {
548        DP += UV.GetDat(HI.GetKey()) * HI.GetDat();
549      }
550    }
551    return DP;
552  }
553  void THysgen::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
554    S.Gen(G->GetNodes());
555    NumCIdNV.Gen(CmtyVV.Len());
556    NumComs = CmtyVV.Len();
557    for (int c = 0; c < CmtyVV.Len(); c++) {
558      for (int u = 0; u < CmtyVV[c].Len(); u++) {
559        int UID = CmtyVV[c][u];
560        if (! NIdToIdx.IsKey(UID)) { continue; }
561        AddNCom(NIdToIdx.GetKeyId(UID), c, 1.0);
562      }
563    }
564  }
565  double THysgen::Likelihood() {
566    TExeTm ExeTm;
567    double L = 0.0;
568    for (int u = 0; u < S.Len(); u++) {
569      double LU = LikelihoodForRow(u);
570      L += LU;
571    }
572    return L ;
573  }
574  double THysgen::LikelihoodForRow(const int UID) {
575    return LikelihoodForRow(UID, S[UID]);
576  }
577  double THysgen::LikelihoodForRow(const int UID, const TIntFltH &SU) {
578    bool IsSUpdated = false;
579    if (S[UID].Len() != SU.Len()) {
580      IsSUpdated = true;
581    } else {
582      for (int CID = 0; CID < NumComs; CID++){
583        if (!S[UID].IsKey(CID) && !SU.IsKey(CID)) {continue;}
584        if ( (S[UID].IsKey(CID) && !SU.IsKey(CID)) ||
585            (!S[UID].IsKey(CID) && SU.IsKey(CID)) ||
586            abs(S[UID].GetDat(CID) - SU.GetDat(CID)) > DBL_MIN ) {
587          IsSUpdated = true;
588          break;
589        }
590      }
591    }
592    double L = 0.0;
593    const bool IsLikelihood = true;
594    THGraph::TNodeI NI = G->GetNI(UID);
595    TIntV EIdV; 
596    NI.GetEIDs(EIdV);
597    TFlt SumLgPrNotUEdges = 0.0; 
598    for (int e = 0; e < NI.GetDeg(); e++) {
599      int EId = EIdV[e];
600      TIntFltH PrENewCH;
601      if (HONNIdsV[UID].IsKey(EId)) { continue; }
602        L += log(GetPrE(EId, UID, SU, PrENewCH));
603        for (TIntFltH::TIter PrECI = PrENewCH.BegI(); PrECI < PrENewCH.EndI(); PrECI++){
604          SumLgPrNotUEdges += log(1.0 - PrECI.GetDat());
605        }
606    }
607    TFlt SumAllPsbl = 0.0;
608    for (TIntFltH::TIter UCI = SU.BegI(); UCI < SU.EndI(); UCI++) {
609      if (IsSUpdated) {
610        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), UCI.GetDat(), IsLikelihood);
611      } else {
612        SumAllPsbl += PredictAllCEdgesS(UID, UCI.GetKey(), IsLikelihood);
613      }
614    }
615    L += NegWgt * (SumAllPsbl - SumLgPrNotUEdges);
616    if (RegCoef > 0.0) {
617      L -= RegCoef * Sum(SU);
618    }
619    return L;
620  }
621  void THysgen::GradientForRow(const int UId, TIntFltH &GradNod) {
622    GradNod.Gen(GetNumComs());
623    THGraph::TNodeI NI = G->GetNI(UId);
624    int NDeg = NI.GetDeg();
625    TIntV EIdV; 
626    NI.GetEIDs(EIdV);
627    TIntFltH PredEH(NDeg);
628    TFltV PredECMinusUV(GetNumComs());
629    TFltV GradV(GetNumComs());
630    TIntV CIDV(GetNumComs());
631    TIntV NIdV;
632    TInt NId;
633    TInt EId;
634    for (int e = 0; e < NDeg; e++) {
635      EId = EIdV[e];
636      if (HONEIdsV[UId].IsKey(EId)) { continue; }
637      PredEH.AddDat(EId, GetPrE(EId)); 
638    }
639    for (int CId = 0; CId < NumComs; CId++) { 
640      double Val = 0.0;
641      for (int e = 0; e < NDeg; e++) {
642        EId = EIdV[e];
643        if (HONEIdsV[UId].IsKey(EId)) { continue; }
644        if (GetNCom(UId, CId) > 0.0) {
645          PredECMinusUV[CId] =
646            GetECom(EId, CId) / GetNCom(UId, CId); 
647        } else {
648          PredECMinusUV[CId] = 1.0;
649          G->GetEI(EId).GetNodesV(NIdV);
650          for (int m = 0; m < NIdV.Len(); m++) {
651            NId = NIdV[m];
652            if (NId != UId) { PredECMinusUV[CId] *= GetNCom(NId, CId); }
653          }
654        }
655        double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
656        if (GetECom(EId, CId) >= 1.0 || (1.0 - GetECom(EId, CId) <= 0.0)) {
657          double PredENotCId = 1.0 - PrENoise;
658          for (int c2 = 0; c2 < NumComs; c2++) {
659            if (c2 == CId) { continue; }
660            PredENotCId *= 1.0 - GetECom(EId, c2);
661          }
662          Val += PredECMinusUV[CId] * PredENotCId / PredEH.GetDat(EId); 
663        }
664        else {
665          double PrNotENotC = (1.0 - PredEH.GetDat(EId)) / (1.0 - GetECom(EId, CId));
666          Val +=
667            PredECMinusUV[CId] * PrNotENotC / PredEH.GetDat(EId);
668        }
669        Val += NegWgt * (PredECMinusUV[CId] /
670          (1.0 - GetECom(EId, CId)));
671      }
672      Val -= NegWgt * PredictAllCEdgesS(UId, CId, false);
673      CIDV[CId] = CId;
674      GradV[CId] = Val;
675    }
676    for (int c = 0; c < GradV.Len(); c++) {
677      GradNod.AddDat(CIDV[c], GradV[CIDV[c]]);
678    }
679  }
680  void THysgen::GetCmtyVV(TVec<TIntFltH>& CmtyVH, TVec<TIntV>& CmtyVV, TVec<TFltV>& WckVV,
681                          const double Thres, const int MinSz) {
682    CmtyVH.Gen(NumComs, 0.0);
683    CmtyVV.Gen(NumComs, 0.0);
684    for (int CId = 0; CId < NumComs; CId++) {
685      TIntFltH NIDSucH(S.Len());
686      TIntV CmtyV;
687      for (int u = 0; u < S.Len(); u++) {
688        int NID = NIdToIdx[u];
689        if (GetNCom(u, CId) > Thres) {
690          NIDSucH.AddDat(NID, GetNCom(u, CId));
691        }
692      }
693      NIDSucH.SortByDat(false);
694      NIDSucH.GetKeyV(CmtyV);
695      if (CmtyV.Len() < MinSz) { continue; }
696      CmtyVH.Add(NIDSucH);
697      CmtyVV.Add(CmtyV);
698    }
699    if ( NumComs != CmtyVV.Len()) {
700      printf("Unsorted Community vector generated. %d communities are ommitted\n",
701             NumComs.Val - CmtyVV.Len());
702    }
703  }
704  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
705    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
706  }
707  void THysgen::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
708    CmtyVV.Gen(NumComs, 0.0);
709    for (int c = 0; c < NumComs; c++) {
710      TIntV CmtyV;
711      for (int u = 0; u < G->GetNodes(); u++) {
712        if (GetNCom(u, c) > Thres) { CmtyV.Add(NIdToIdx[u]); }
713      }
714      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
715    }
716    if ( NumComs != CmtyVV.Len()) {
717      printf("*Sorted* Community vector generated. %d communities are ommitted\n",
718             NumComs.Val - CmtyVV.Len());
719    }
720  }
721  double THysgen::GetStepSizeByLineSearch(const int UID, const TIntFltH &DeltaH,
722                                          const double &stepSize,
723                                          const double &CtrlParam,
724                                          const double &ReductionRatio,
725                                          const int MaxIter) {
726    double StepSize = stepSize;
727    double NewVal;
728    bool ShouldReduce = true;
729    while (ShouldReduce) {
730      ShouldReduce = false;
731      for (TIntFltH::TIter CI = DeltaH.BegI(); CI < DeltaH.EndI(); CI++) {
732        int CID = CI.GetKey();
733        NewVal = GetNCom(UID, CID) + StepSize * CI.GetDat();
734        if ((NewVal < MinVal || NewVal > MaxVal)) {
735          StepSize *= ReductionRatio;
736          ShouldReduce = true;
737          break;
738        }
739      }
740    }
741    double InitLikelihood = LikelihoodForRow(UID);
742    double FinalLikelihood = 0.0;
743    TIntFltH SearchVecH;
744    for(int iter = 0; iter < MaxIter; iter++) {
745      TIntFltH NewVarH;
746      GetUpdatedNodP(NewVarH, SearchVecH, UID, DeltaH, StepSize);
747      FinalLikelihood = LikelihoodForRow(UID, NewVarH);
748      double DotProd = DotProduct(SearchVecH, SearchVecH);
749      if (FinalLikelihood < InitLikelihood + CtrlParam * StepSize * DotProd ||
750                                                      isinf(FinalLikelihood)) {
751        StepSize *= ReductionRatio;
752      } else {
753        break;
754      }
755      if (iter == MaxIter - 1 || DotProd < 0.00001) {
756        StepSize = 0.0;
757        break;
758      }
759    }
760    return StepSize;
761  }
762  int THysgen::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm,
763                             const double StepSize, const double StepCtrlParam, const double StepReductionRatio) {
764    int NegLikPermits = MaxIter/3;
765    int MaxIterLineSearch = 100;
766    time_t InitTime = time(NULL);
767    time_t InitIterTime;
768    TExeTm ExeTm, CheckTm;
769    int iter = 0; 
770    TIntFltPrV IterLV; 
771    THGraph::TNodeI UI; 
772    double PrevL = Likelihood(), CurL = 0.0, DiffL;
773    printf("\n0 iterations (iter/#nodes = 0) {[INITIAL] Likelihood: %.4e}\n",PrevL);
774    TIntV NIdxV(S.Len(), 0);  
775    for (int i = 0; i < S.Len(); i++) { NIdxV.Add(i); }
776    TIntFltH GradUH;
777    TFltV Last5;
778    double SumLast5 = 0;
779    while(iter < MaxIter) {
780      InitIterTime = time(NULL);
781      NIdxV.Shuffle(Rnd);
782      for (int ui = 0; ui < S.Len(); ui++, iter++) {
783        int u = NIdxV[ui];
784        GradientForRow(u, GradUH);
785        if (Norm2(GradUH) < 1e-4) { continue; }
786        TIntFltH GradAdjustedH;
787        TIntFltH SearchVecH;
788        NormalizeIfLarge(GradUH, GradAdjustedH);
789        bool IsAnyValidChange = RmvWeakDirections(u, GradAdjustedH);
790        if (! IsAnyValidChange) { continue; }
791        double LearnRate = GetStepSizeByLineSearch(u, GradAdjustedH, StepSize,
792                                                   StepCtrlParam,
793                                                   StepReductionRatio,
794                                                   MaxIterLineSearch);
795        if (LearnRate <= DBL_MIN) { continue; }
796        TIntFltH SNew;
797        GetUpdatedNodP(SNew, u, GradAdjustedH, LearnRate);
798        double NewSuc;
799        for (int CID = 0; CID < NumComs; CID++) {
800          if (! SNew.IsKey(CID)) {
801            NewSuc = 0.0;
802          } else {
803            NewSuc = SNew.GetDat(CID);
804          }
805          if (NewSuc < DBL_EPSILON) {
806            DelNCom(u, CID);
807          } else {
808            AddNCom(u, CID, NewSuc);
809          }
810        }
811        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
812          IterLV.Add(TIntFltPr(iter, Likelihood()));
813        }
814      }
815      CurL = Likelihood();
816      DiffL = CurL - PrevL;
817      PrevL = CurL;
818      double AdjDiffL = (abs(DiffL) < 1000.0) ? abs(DiffL) : 1000.0;
819      Last5.Add(AdjDiffL);
820      SumLast5 += AdjDiffL;
821      if (Last5.Len() > 5) {
822        SumLast5 -= Last5[0];
823        Last5.Del(0);
824      }
825      if (fabs(CurL) < 1e9) {
826        if (fabs(DiffL) < 1e9) {
827          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4f} [%lu/%lu sec]\n",
828                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
829        } else {
830          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4f, Diff: %.4e} [%lu/%lu sec]\n",
831                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
832        }
833      } else {
834        if (fabs(DiffL) < 1e9) {
835          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4f} [%lu/%lu sec]\n",
836                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
837        } else {
838          printf("\r%d iterations (iter/#nodes = %d) {Likelihood: %.4e, Diff: %.4e} [%lu/%lu sec]\n",
839                 iter, iter/G->GetNodes(), CurL, DiffL, time(NULL) - InitIterTime, time(NULL) - InitTime);
840        }
841      }
842      printf("\n");
843      fflush(stdout);
844      if (DiffL < 0.0) { 
845        if (NegLikPermits <= 0) { break; }
846        NegLikPermits --;
847      }
848      if (SumLast5/Last5.Len() <= Thres) {
849        printf("The average of last five differences < threshold. Iterations end...\n");
850        break;
851      }
852    }
853    printf("\n");
854    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
855    if (! PlotNm.Empty()) {
856      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
857    }
858    return iter;
859  }
860  double THysgen::GetPrE(const int &EId, const int &UId, const TIntFltH &SUNewH,
861                         TIntFltH &PrEOutCH) {
862    double PrENoise = GetENoiseProb(G->GetEI(EId).Len());
863    double SUOld;
864    double SUNew;
865    double PrECOld;
866    double PrENew = 1.0 - PrENoise;
867    int SCId;
868    for (TIntFltH::TIter SCI = SUNewH.BegI(); SCI < SUNewH.EndI(); SCI++) {
869      SCId = SCI.GetKey();
870      SUNew = SCI.GetDat();
871      SUOld = GetNCom(UId, SCId);
872      if (SUOld < DBL_EPSILON) {
873        TIntV ENodesV;
874        G->GetEI(EId).GetNbrNodes(ENodesV);
875        double PrEC = SUNew;
876        for (int n = 0; n < ENodesV.Len(); n++) {
877          if (ENodesV[n] == UId) { continue; }
878          PrEC *= GetNCom(ENodesV[n], SCId);
879        }
880        PrEOutCH.AddDat(SCId, PrEC);
881      } else {
882        PrECOld = GetECom(EId, SCId);
883        PrEOutCH.AddDat(SCId, PrECOld * SUNew / SUOld);
884      }
885      PrENew *= 1.0 - PrEOutCH.GetDat(SCId);
886    }
887    if (PrENew < 1.0) { PrENew = 1.0 - PrENew; }
888    else {
889      PrENew = GetPrEPrecision(PrEOutCH, AuxDPEdgVV, PrENoise);
890    }
891    return PrENew;
892  }
893  double THysgen::GetPrEPrecision(const TIntFltH &ECH, TVec<TFltV> &DPMatVV,
894                                  const double PrENoise) {
895    int NumEC = ECH.Len();
896    TFltV ECV(NumEC);
897    ECH.GetDatV(ECV);
898    if (PrENoise > 0.0) { ECV.Add(PrENoise); NumEC++; }
899    for (int i=1; i<NumEC; i++) {
900      DPMatVV[i][NumEC-1] = 0;
901    }
902    DPMatVV[0][NumEC-1] = ECV[NumEC-1];
903    for (int j= NumEC - 2; j >= 0; j--) {
904      DPMatVV[0][j] = DPMatVV[0][j + 1] + ECV[j];
905    }
906    for (int i=1; i<NumEC; i++) {
907      for (int j=NumEC-1-i; j>=0; j--) {
908        DPMatVV[i][j] = ECV[j] * DPMatVV[i-1][j+1] + DPMatVV[i][j+1];
909      }
910    }
911    double prob = 0.0;
912    double SignCoef = 1.0;
913    for (int i=0; i<NumEC; i++) {
914      prob += SignCoef * DPMatVV[i][0];
915      SignCoef *= -1.0;
916    }
917    if (prob < DBL_MIN || prob >1) {
918      prob = DBL_MIN;
919    }
920    return prob;
921  }
922  void THysgen::GetUpdatedNodP(TIntFltH &SNew, const int &UID, const TIntFltH& GradUH,
923                          double &StepSize) {
924    TIntFltH SearchVecOut;
925    GetUpdatedNodP(SNew, SearchVecOut, UID, GradUH, StepSize);
926  }
927  void THysgen::GetUpdatedNodP(TIntFltH &SNew, TIntFltH& SearchVecOut, const int& UID,
928                               const TIntFltH& GradUH, double& StepSize) {
929    for (int CID = 0; CID < NumComs; CID++) {
930      if (GradUH.IsKey(CID)) {
931        double Change = StepSize * GradUH.GetDat(CID);
932        if (RegCoef>0.0 && GetNCom(UID, CID)>0.0) {
933          Change -= - RegCoef;
934        }
935        double NewSuc = GetNCom(UID, CID) + Change;
936        if (NewSuc < DBL_EPSILON) {
937          NewSuc = MinVal;
938        } else if (NewSuc >= MaxVal - TayThresh) {
939          NewSuc = MaxVal - TayThresh;
940        }
941        Change = NewSuc - GetNCom(UID, CID);
942        if (NewSuc >= DBL_EPSILON) {
943          SNew.AddDat(CID, NewSuc);
944        }
945        SearchVecOut.AddDat(CID, Change);
946      } else {
947        if (GetNCom(UID, CID) > 0.0) {
948          double NewSuc;
949          if (GetNCom(UID, CID) >= MaxVal - TayThresh) {
950            NewSuc = MaxVal - TayThresh;
951          } else {
952            NewSuc = GetNCom(UID, CID);
953          }
954          SNew.AddDat(CID, NewSuc);
955        }
956      }
957    }
958  }
959  bool THysgen::AcceptStepSA(const int &UID, const TIntFltH &SNew, const int &Iter,
960                        const int &MaxIter, const double &SAParamK) {
961    double T0 = 100.0;
962    double T = T0/((double)Iter+1.0);
963    double OldLikelihood = LikelihoodForRow(UID);
964    double NewLikelihood = LikelihoodForRow(UID, SNew);
965    double DeltaE = - (NewLikelihood-OldLikelihood);
966    double PrAccept = exp(-DeltaE/(SAParamK*T));
967    if (Rnd.GetUniDev() < PrAccept) { return true; }
968    return false;
969  }
970  bool THysgen::RmvWeakDirections(const int &UId, TIntFltH &GradH) {
971    bool IsEligible = false;
972    THashSet<TInt> BadDirH;
973    for (TIntFltH::TIter CI = GradH.BegI(); CI < GradH.EndI(); CI++) {
974      if ((GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() < DBL_EPSILON) ||
975            (1.0 - GetNCom(UId, CI.GetKey()) < DBL_EPSILON && CI.GetDat() > DBL_EPSILON)) {
976        BadDirH.AddKey(CI.GetKey());
977      } else {
978        IsEligible = true;
979      }
980    }
981    if (BadDirH.Len() > 0) {
982      for (THashSet<TInt>::TIter CId = BadDirH.BegI();
983           CId < BadDirH.EndI(); CId++) {
984        GradH.DelKey(CId.GetKey());
985      }
986    }
987    return IsEligible;
988  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hysgen.cpp</div>
                </div>
                <div class="column column_space"><pre><code>52      CurCID++;
53      fflush(stdout);
54      if (CurCID >= NumComs) { break;  }
55    }
56    if (NumComs > CurCID) {
57      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
58    }
59    for (int c = 0; c < SumFV.Len(); c++) {
60      if (SumFV[c] == 0.0) {
61        int ComSz = 10;
62        for (int u = 0; u < ComSz; u++) {
63          int UID = Rnd.GetUniDevInt(G->GetNodes());
64          AddCom(UID, c, Rnd.GetUniDev());
65        }
66      }
67    }
68    InitW();
69  }
</pre></code></div>
                <div class="column column_space"><pre><code>280      CurCID++;
281      if (CurCID >= NumComs) { break; }
282      fflush(stdout);
283    }
284    if (NumComs > CurCID) {
285      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
286    }
287    for (int c = 0; c < NumCIdNV.Len(); c++) {
288      if (NumCIdNDefV[c] == 0) {
289        printf("Empty communities remained after initialization. "
290               "Members are getting assigned randomly!!\n\n");
291        int ComSz = 10;
292        for (int u = 0; u < ComSz; u++) {
293          int UID = Rnd.GetUniDevInt(G->GetNodes());
294          AddNCom(UID, c, InitVal, IsInit);
295        }
296      }
297    }
298  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    