
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ColourPopup.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <stdexcept>
3  #include "ColourPopup.h"
4  #include "NppDarkMode.h"
5  DWORD colourItems[] = {
6  	RGB(  0,   0,   0),	RGB( 64,   0,   0),	RGB(128,   0,   0),	RGB(128,  64,  64),	RGB(255,   0,   0),	RGB(255, 128, 128),
7  	RGB(255, 255, 128),	RGB(255, 255,   0),	RGB(255, 128,  64),	RGB(255, 128,   0),	RGB(128,  64,   0),	RGB(128, 128,   0),
8  	RGB(128, 128,  64),	RGB(  0,  64,   0),	RGB(  0, 128,   0),	RGB(  0, 255,   0),	RGB(128, 255,   0),	RGB(128, 255, 128),
9  	RGB(  0, 255, 128),	RGB(  0, 255,  64),	RGB(  0, 128, 128),	RGB(  0, 128,  64),	RGB(  0,  64,  64),	RGB(128, 128, 128),
10  	RGB( 64, 128, 128),	RGB(  0,   0, 128),	RGB(  0,   0, 255),	RGB(  0,  64, 128),	RGB(  0, 255, 255), RGB(128, 255, 255),
11  	RGB(  0, 128, 255),	RGB(  0, 128, 192),	RGB(128, 128, 255),	RGB(  0,   0, 160),	RGB(  0,   0,  64),	RGB(192, 192, 192),
12  	RGB( 64,   0,  64),	RGB( 64,   0,  64),	RGB(128,   0, 128),	RGB(128,   0,  64),	RGB(128, 128, 192),	RGB(255, 128, 192),
13  	RGB(255, 128, 255),	RGB(255,   0, 255), RGB(255,   0, 128),	RGB(128,   0, 255), RGB( 64,   0, 128),	RGB(255, 255, 255),
14  };
15  void ColourPopup::create(int dialogID) 
16  {
17  	_hSelf = ::CreateDialogParam(_hInst, MAKEINTRESOURCE(dialogID), _hParent,  dlgProc, reinterpret_cast<LPARAM>(this));
18  	if (!_hSelf)
19  	{
20  		throw std::runtime_error("ColourPopup::create : CreateDialogParam() function return null");
21  	}
22  	Window::getClientRect(_rc);
23  	display();
24  }
25  intptr_t CALLBACK ColourPopup::dlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) 
26  {
27  	switch (message) 
28  	{
29  		case WM_MEASUREITEM:
30  		{
31  			RECT rc;
32  			LPMEASUREITEMSTRUCT lpmis = reinterpret_cast<LPMEASUREITEMSTRUCT>(lParam);
33  			::GetWindowRect(::GetDlgItem(hwnd, lpmis->CtlID), &rc);
34  			lpmis->itemHeight = (rc.bottom-rc.top)/6; 
35  			lpmis->itemWidth = (rc.right-rc.left)/8;
36  			return TRUE;
37  		}
38  		case WM_INITDIALOG :
39  		{
40  			ColourPopup *pColourPopup = reinterpret_cast<ColourPopup *>(lParam);
41  			pColourPopup->_hSelf = hwnd;
42  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, static_cast<LONG_PTR>(lParam));
43  			pColourPopup->run_dlgProc(message, wParam, lParam);
44  			return TRUE;
45  		}
46  		default :
47  		{
48  			ColourPopup *pColourPopup = reinterpret_cast<ColourPopup *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
49  			if (!pColourPopup)
50  				return FALSE;
51  			return pColourPopup->run_dlgProc(message, wParam, lParam);
52  		}
53  	}
54  }
55  intptr_t CALLBACK ColourPopup::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
56  {
57  	switch (message)
58  	{
59  		case WM_INITDIALOG:
60  		{
61  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
62  			int nColor;
63  			for (nColor = 0 ; nColor < int(sizeof(colourItems)/sizeof(DWORD)) ; ++nColor)
64  			{
65  				::SendDlgItemMessage(_hSelf, IDC_COLOUR_LIST, LB_ADDSTRING, nColor, reinterpret_cast<LPARAM>(""));
66  				::SendDlgItemMessage(_hSelf, IDC_COLOUR_LIST, LB_SETITEMDATA, nColor, static_cast<LPARAM>(colourItems[nColor]));
67  			}
68  			return TRUE;
69  		}
70  		case WM_CTLCOLORLISTBOX:
71  		{
72  			if (NppDarkMode::isEnabled())
73  			{
74  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
75  			}
76  			return reinterpret_cast<LRESULT>(::GetStockObject(NULL_BRUSH));
77  		}
78  		case WM_CTLCOLORDLG:
79  		case WM_CTLCOLORSTATIC:
80  		{
81  			if (NppDarkMode::isEnabled())
82  			{
83  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
84  			}
85  			break;
86  		}
87  		case WM_PRINTCLIENT:
88  		{
89  			if (NppDarkMode::isEnabled())
90  			{
91  				return TRUE;
92  			}
93  			break;
94  		}
95  		case NPPM_INTERNAL_REFRESHDARKMODE:
96  		{
97  			NppDarkMode::autoThemeChildControls(_hSelf);
98  			return TRUE;
99  		}
100  		case WM_DRAWITEM:
101  		{
102  			HDC hdc;
103  			COLORREF	cr;
104  			HBRUSH		hbrush;
105  			DRAWITEMSTRUCT *pdis = (DRAWITEMSTRUCT *)lParam;
106  			hdc = pdis->hDC;
107  			RECT rc = pdis->rcItem;
108  			SetBkMode(hdc,TRANSPARENT);
109  			if (pdis->itemID == UINT(-1)) return 0; 
110  			switch (pdis->itemAction)
111  			{
112  				case ODA_DRAWENTIRE:
113  					switch (pdis->CtlID)
114  					{
115  						case IDC_COLOUR_LIST:
116  							rc = pdis->rcItem;
117  							cr = (COLORREF) pdis->itemData;
118  							InflateRect(&rc, -3, -3);
119  							hbrush = CreateSolidBrush((COLORREF)cr);
120  							FillRect(hdc, &rc, hbrush);
121  							DeleteObject(hbrush);
122  							hbrush = CreateSolidBrush(NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : RGB(0, 0, 0));
123  							FrameRect(hdc, &rc, hbrush);
124  							DeleteObject(hbrush);
125  							break;
126  					}
127  					[[fallthrough]];
128  				case ODA_SELECT:
129  					rc = pdis->rcItem;
130  					if (pdis->itemState & ODS_SELECTED)
131  					{
132  						rc.bottom --;
133  						rc.right --;
134  						HPEN hpen = CreatePen(PS_SOLID, 1, NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : GetSysColor(COLOR_BTNSHADOW));
135  						HPEN holdPen = (HPEN)SelectObject(hdc, hpen);
136  						MoveToEx(hdc, rc.left, rc.bottom, NULL);
137  						LineTo(hdc, rc.left, rc.top);
138  						LineTo(hdc, rc.right, rc.top);
139  						SelectObject(hdc, holdPen);
140  						DeleteObject(hpen);
141  						hpen = CreatePen(PS_SOLID, 1, NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : GetSysColor(COLOR_BTNHIGHLIGHT));
142  						holdPen = (HPEN)SelectObject(hdc, hpen);
143  						LineTo(hdc, rc.right, rc.bottom);
144  						LineTo(hdc, rc.left, rc.bottom);
145  						SelectObject(hdc, holdPen);
146  						DeleteObject(hpen);
147  					}
148  					else 
149  					{
150  						hbrush = CreateSolidBrush(NppDarkMode::isEnabled() ? NppDarkMode::getDarkerBackgroundColor() : GetSysColor(COLOR_3DFACE));
151  						FrameRect(hdc, &rc, hbrush);
152  						DeleteObject(hbrush);
153  					}
154  					break;
155  				case ODA_FOCUS:
156  					rc = pdis->rcItem;
157  					InflateRect(&rc, -2, -2);
158  					DrawFocusRect(hdc, &rc);
159  					break;
160  				default:
161  					break;
162  			}
163  			return TRUE;
164  		}
165  		case WM_COMMAND:
<span onclick='openModal()' class='match'>166  			switch (LOWORD(wParam))
167              {
168                  case IDOK :
169  			    {
170  					CHOOSECOLOR cc;                 
171  					static COLORREF acrCustClr[16] = {
</span>172  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
173  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
174  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
175  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
176  					}; 
177  					::ZeroMemory(&cc, sizeof(cc));
178  					cc.lStructSize = sizeof(cc);
179  					cc.hwndOwner = _hParent;
180  					cc.lpCustColors = (LPDWORD) acrCustClr;
181  					cc.rgbResult = _colour;
182  					cc.lpfnHook = chooseColorDlgProc;
183  					cc.Flags = CC_FULLOPEN | CC_RGBINIT | CC_ENABLEHOOK;
184  					display(false);
185  					if (ChooseColor(&cc)==TRUE) 
186  					{
187  						::SendMessage(_hParent, WM_PICKUP_COLOR, cc.rgbResult, 0);
188  					}
189  					else
190  					{
191  						::SendMessage(_hParent, WM_PICKUP_CANCEL, 0, 0);
192  					}
193  				    return TRUE;
194  			    }
195                  case IDC_COLOUR_LIST :
196                  {
197  			        if (HIWORD(wParam) == LBN_SELCHANGE)
198  		            {
199                          auto i = ::SendMessage(reinterpret_cast<HWND>(lParam), LB_GETCURSEL, 0L, 0L);
200  						_colour = static_cast<COLORREF>(::SendMessage(reinterpret_cast<HWND>(lParam), LB_GETITEMDATA, i, 0L));
201                          ::SendMessage(_hParent, WM_PICKUP_COLOR, _colour, 0);
202  					    return TRUE;
203  		            }
204  					return FALSE;
205                  }
206                  default :
207                      return FALSE;
208              }
209  		case WM_ACTIVATE :
210          {
211  			if (LOWORD(wParam) == WA_INACTIVE)
212  				::SendMessage(_hParent, WM_PICKUP_CANCEL, 0, 0);
213  			return TRUE;
214  		}
215  	}
216  	return FALSE;
217  }
218  uintptr_t CALLBACK ColourPopup::chooseColorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM) 
219  {
220  	switch (message)
221  	{
222  		case WM_INITDIALOG:
223  		{
224  			if (NppDarkMode::isExperimentalSupported())
225  			{
226  				NppDarkMode::setDarkTitleBar(hwnd);
227  			}
228  			NppDarkMode::autoSubclassAndThemeChildControls(hwnd);
229  			break;
230  		}
231  		case WM_CTLCOLOREDIT:
232  		{
233  			if (NppDarkMode::isEnabled())
234  			{
235  				return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
236  			}
237  			break;
238  		}
239  		case WM_CTLCOLORLISTBOX:
240  		case WM_CTLCOLORDLG:
241  		case WM_CTLCOLORSTATIC:
242  		{
243  			if (NppDarkMode::isEnabled())
244  			{
245  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
246  			}
247  			break;
248  		}
249  		case WM_PRINTCLIENT:
250  		{
251  			if (NppDarkMode::isEnabled())
252  			{
253  				return TRUE;
254  			}
255  			break;
256  		}
257  		case WM_ERASEBKGND:
258  		{
259  			if (NppDarkMode::isEnabled())
260  			{
261  				RECT rc = {};
262  				::GetClientRect(hwnd, &rc);
263  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
264  				return TRUE;
265  			}
266  			break;
267  		}
268  	}
269  	return FALSE;
270  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ColourPopup.cpp</h3>
            <pre><code>1  #include <iostream>
2  #include <stdexcept>
3  #include "ColourPopup.h"
4  #include "NppDarkMode.h"
5  DWORD colourItems[] = {
6  	RGB(  0,   0,   0),	RGB( 64,   0,   0),	RGB(128,   0,   0),	RGB(128,  64,  64),	RGB(255,   0,   0),	RGB(255, 128, 128),
7  	RGB(255, 255, 128),	RGB(255, 255,   0),	RGB(255, 128,  64),	RGB(255, 128,   0),	RGB(128,  64,   0),	RGB(128, 128,   0),
8  	RGB(128, 128,  64),	RGB(  0,  64,   0),	RGB(  0, 128,   0),	RGB(  0, 255,   0),	RGB(128, 255,   0),	RGB(128, 255, 128),
9  	RGB(  0, 255, 128),	RGB(  0, 255,  64),	RGB(  0, 128, 128),	RGB(  0, 128,  64),	RGB(  0,  64,  64),	RGB(128, 128, 128),
10  	RGB( 64, 128, 128),	RGB(  0,   0, 128),	RGB(  0,   0, 255),	RGB(  0,  64, 128),	RGB(  0, 255, 255), RGB(128, 255, 255),
11  	RGB(  0, 128, 255),	RGB(  0, 128, 192),	RGB(128, 128, 255),	RGB(  0,   0, 160),	RGB(  0,   0,  64),	RGB(192, 192, 192),
12  	RGB( 64,   0,  64),	RGB( 64,   0,  64),	RGB(128,   0, 128),	RGB(128,   0,  64),	RGB(128, 128, 192),	RGB(255, 128, 192),
13  	RGB(255, 128, 255),	RGB(255,   0, 255), RGB(255,   0, 128),	RGB(128,   0, 255), RGB( 64,   0, 128),	RGB(255, 255, 255),
14  };
15  void ColourPopup::create(int dialogID) 
16  {
17  	_hSelf = ::CreateDialogParam(_hInst, MAKEINTRESOURCE(dialogID), _hParent,  dlgProc, reinterpret_cast<LPARAM>(this));
18  	if (!_hSelf)
19  	{
20  		throw std::runtime_error("ColourPopup::create : CreateDialogParam() function return null");
21  	}
22  	Window::getClientRect(_rc);
23  	display();
24  }
25  intptr_t CALLBACK ColourPopup::dlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) 
26  {
27  	switch (message) 
28  	{
29  		case WM_MEASUREITEM:
30  		{
31  			RECT rc;
32  			LPMEASUREITEMSTRUCT lpmis = reinterpret_cast<LPMEASUREITEMSTRUCT>(lParam);
33  			::GetWindowRect(::GetDlgItem(hwnd, lpmis->CtlID), &rc);
34  			lpmis->itemHeight = (rc.bottom-rc.top)/6; 
35  			lpmis->itemWidth = (rc.right-rc.left)/8;
36  			return TRUE;
37  		}
38  		case WM_INITDIALOG :
39  		{
40  			ColourPopup *pColourPopup = reinterpret_cast<ColourPopup *>(lParam);
41  			pColourPopup->_hSelf = hwnd;
42  			::SetWindowLongPtr(hwnd, GWLP_USERDATA, static_cast<LONG_PTR>(lParam));
43  			pColourPopup->run_dlgProc(message, wParam, lParam);
44  			return TRUE;
45  		}
46  		default :
47  		{
48  			ColourPopup *pColourPopup = reinterpret_cast<ColourPopup *>(::GetWindowLongPtr(hwnd, GWLP_USERDATA));
49  			if (!pColourPopup)
50  				return FALSE;
51  			return pColourPopup->run_dlgProc(message, wParam, lParam);
52  		}
53  	}
54  }
55  intptr_t CALLBACK ColourPopup::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
56  {
57  	switch (message)
58  	{
59  		case WM_INITDIALOG:
60  		{
61  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
62  			int nColor;
63  			for (nColor = 0 ; nColor < int(sizeof(colourItems)/sizeof(DWORD)) ; ++nColor)
64  			{
65  				::SendDlgItemMessage(_hSelf, IDC_COLOUR_LIST, LB_ADDSTRING, nColor, reinterpret_cast<LPARAM>(""));
66  				::SendDlgItemMessage(_hSelf, IDC_COLOUR_LIST, LB_SETITEMDATA, nColor, static_cast<LPARAM>(colourItems[nColor]));
67  			}
68  			return TRUE;
69  		}
70  		case WM_CTLCOLORLISTBOX:
71  		{
72  			if (NppDarkMode::isEnabled())
73  			{
74  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
75  			}
76  			return reinterpret_cast<LRESULT>(::GetStockObject(NULL_BRUSH));
77  		}
78  		case WM_CTLCOLORDLG:
79  		case WM_CTLCOLORSTATIC:
80  		{
81  			if (NppDarkMode::isEnabled())
82  			{
83  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
84  			}
85  			break;
86  		}
87  		case WM_PRINTCLIENT:
88  		{
89  			if (NppDarkMode::isEnabled())
90  			{
91  				return TRUE;
92  			}
93  			break;
94  		}
95  		case NPPM_INTERNAL_REFRESHDARKMODE:
96  		{
97  			NppDarkMode::autoThemeChildControls(_hSelf);
98  			return TRUE;
99  		}
100  		case WM_DRAWITEM:
101  		{
102  			HDC hdc;
103  			COLORREF	cr;
104  			HBRUSH		hbrush;
105  			DRAWITEMSTRUCT *pdis = (DRAWITEMSTRUCT *)lParam;
106  			hdc = pdis->hDC;
107  			RECT rc = pdis->rcItem;
108  			SetBkMode(hdc,TRANSPARENT);
109  			if (pdis->itemID == UINT(-1)) return 0; 
110  			switch (pdis->itemAction)
111  			{
112  				case ODA_DRAWENTIRE:
113  					switch (pdis->CtlID)
114  					{
115  						case IDC_COLOUR_LIST:
116  							rc = pdis->rcItem;
117  							cr = (COLORREF) pdis->itemData;
118  							InflateRect(&rc, -3, -3);
119  							hbrush = CreateSolidBrush((COLORREF)cr);
120  							FillRect(hdc, &rc, hbrush);
121  							DeleteObject(hbrush);
122  							hbrush = CreateSolidBrush(NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : RGB(0, 0, 0));
123  							FrameRect(hdc, &rc, hbrush);
124  							DeleteObject(hbrush);
125  							break;
126  					}
127  					[[fallthrough]];
128  				case ODA_SELECT:
129  					rc = pdis->rcItem;
130  					if (pdis->itemState & ODS_SELECTED)
131  					{
132  						rc.bottom --;
133  						rc.right --;
134  						HPEN hpen = CreatePen(PS_SOLID, 1, NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : GetSysColor(COLOR_BTNSHADOW));
135  						HPEN holdPen = (HPEN)SelectObject(hdc, hpen);
136  						MoveToEx(hdc, rc.left, rc.bottom, NULL);
137  						LineTo(hdc, rc.left, rc.top);
138  						LineTo(hdc, rc.right, rc.top);
139  						SelectObject(hdc, holdPen);
140  						DeleteObject(hpen);
141  						hpen = CreatePen(PS_SOLID, 1, NppDarkMode::isEnabled() ? NppDarkMode::getEdgeColor() : GetSysColor(COLOR_BTNHIGHLIGHT));
142  						holdPen = (HPEN)SelectObject(hdc, hpen);
143  						LineTo(hdc, rc.right, rc.bottom);
144  						LineTo(hdc, rc.left, rc.bottom);
145  						SelectObject(hdc, holdPen);
146  						DeleteObject(hpen);
147  					}
148  					else 
149  					{
150  						hbrush = CreateSolidBrush(NppDarkMode::isEnabled() ? NppDarkMode::getDarkerBackgroundColor() : GetSysColor(COLOR_3DFACE));
151  						FrameRect(hdc, &rc, hbrush);
152  						DeleteObject(hbrush);
153  					}
154  					break;
155  				case ODA_FOCUS:
156  					rc = pdis->rcItem;
157  					InflateRect(&rc, -2, -2);
158  					DrawFocusRect(hdc, &rc);
159  					break;
160  				default:
161  					break;
162  			}
163  			return TRUE;
164  		}
165  		case WM_COMMAND:
<span onclick='openModal()' class='match'>166  			switch (LOWORD(wParam))
167              {
168                  case IDOK :
169  			    {
170  					CHOOSECOLOR cc;                 
171  					static COLORREF acrCustClr[16] = {
</span>172  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
173  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
174  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
175  						RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),RGB(0xFF,0xFF,0xFF),\
176  					}; 
177  					::ZeroMemory(&cc, sizeof(cc));
178  					cc.lStructSize = sizeof(cc);
179  					cc.hwndOwner = _hParent;
180  					cc.lpCustColors = (LPDWORD) acrCustClr;
181  					cc.rgbResult = _colour;
182  					cc.lpfnHook = chooseColorDlgProc;
183  					cc.Flags = CC_FULLOPEN | CC_RGBINIT | CC_ENABLEHOOK;
184  					display(false);
185  					if (ChooseColor(&cc)==TRUE) 
186  					{
187  						::SendMessage(_hParent, WM_PICKUP_COLOR, cc.rgbResult, 0);
188  					}
189  					else
190  					{
191  						::SendMessage(_hParent, WM_PICKUP_CANCEL, 0, 0);
192  					}
193  				    return TRUE;
194  			    }
195                  case IDC_COLOUR_LIST :
196                  {
197  			        if (HIWORD(wParam) == LBN_SELCHANGE)
198  		            {
199                          auto i = ::SendMessage(reinterpret_cast<HWND>(lParam), LB_GETCURSEL, 0L, 0L);
200  						_colour = static_cast<COLORREF>(::SendMessage(reinterpret_cast<HWND>(lParam), LB_GETITEMDATA, i, 0L));
201                          ::SendMessage(_hParent, WM_PICKUP_COLOR, _colour, 0);
202  					    return TRUE;
203  		            }
204  					return FALSE;
205                  }
206                  default :
207                      return FALSE;
208              }
209  		case WM_ACTIVATE :
210          {
211  			if (LOWORD(wParam) == WA_INACTIVE)
212  				::SendMessage(_hParent, WM_PICKUP_CANCEL, 0, 0);
213  			return TRUE;
214  		}
215  	}
216  	return FALSE;
217  }
218  uintptr_t CALLBACK ColourPopup::chooseColorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM) 
219  {
220  	switch (message)
221  	{
222  		case WM_INITDIALOG:
223  		{
224  			if (NppDarkMode::isExperimentalSupported())
225  			{
226  				NppDarkMode::setDarkTitleBar(hwnd);
227  			}
228  			NppDarkMode::autoSubclassAndThemeChildControls(hwnd);
229  			break;
230  		}
231  		case WM_CTLCOLOREDIT:
232  		{
233  			if (NppDarkMode::isEnabled())
234  			{
235  				return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
236  			}
237  			break;
238  		}
239  		case WM_CTLCOLORLISTBOX:
240  		case WM_CTLCOLORDLG:
241  		case WM_CTLCOLORSTATIC:
242  		{
243  			if (NppDarkMode::isEnabled())
244  			{
245  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
246  			}
247  			break;
248  		}
249  		case WM_PRINTCLIENT:
250  		{
251  			if (NppDarkMode::isEnabled())
252  			{
253  				return TRUE;
254  			}
255  			break;
256  		}
257  		case WM_ERASEBKGND:
258  		{
259  			if (NppDarkMode::isEnabled())
260  			{
261  				RECT rc = {};
262  				::GetClientRect(hwnd, &rc);
263  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
264  				return TRUE;
265  			}
266  			break;
267  		}
268  	}
269  	return FALSE;
270  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ColourPopup.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ColourPopup.cpp</div>
                </div>
                <div class="column column_space"><pre><code>166  			switch (LOWORD(wParam))
167              {
168                  case IDOK :
169  			    {
170  					CHOOSECOLOR cc;                 
171  					static COLORREF acrCustClr[16] = {
</pre></code></div>
                <div class="column column_space"><pre><code>166  			switch (LOWORD(wParam))
167              {
168                  case IDOK :
169  			    {
170  					CHOOSECOLOR cc;                 
171  					static COLORREF acrCustClr[16] = {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    