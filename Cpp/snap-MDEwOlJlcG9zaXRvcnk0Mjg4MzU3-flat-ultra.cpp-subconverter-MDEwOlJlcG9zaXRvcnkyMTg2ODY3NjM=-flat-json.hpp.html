
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.370655470025659%, Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ultra.cpp</h3>
            <pre><code>1  #include "ultra.h"
2  TGasDef::TGasDef(const bool& DbP):
3    FldNmTyUseTrV(){
4    if (DbP){
5      LocIdFldN=FldNmTyUseTrV.Add(TStrTr("LocationID", "int", "meta"));
6      ProdIdFldN=FldNmTyUseTrV.Add(TStrTr("ProductID", "int", "meta"));
7      DateFldN=FldNmTyUseTrV.Add(TStrTr("Date", "date", "active"));
8      DayNFldN=FldNmTyUseTrV.Add(TStrTr("Day", "int", "active"));
9      MonthNFldN=FldNmTyUseTrV.Add(TStrTr("Month", "int", "active"));
10      YearNFldN=FldNmTyUseTrV.Add(TStrTr("Year", "int", "active"));
11      HourNFldN=FldNmTyUseTrV.Add(TStrTr("HourStart", "int", "active"));
12      FldNmTyUseTrV.Add(TStrTr("HourEnd", "int", "active"));
13      DowNFldN=FldNmTyUseTrV.Add(TStrTr("DayOfWeek", "dow", "active"));
14      IsHolidayFldN=FldNmTyUseTrV.Add(TStrTr("ISHoliday", "int", "active"));
15      IsHolidayStartFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayStart", "int", "active"));
16      IsHolidayEndFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayEnd", "int", "active"));
17      IsDayBeforeHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayBeforeHoliday", "int", "active"));
18      IsDayAfterHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayAfterHoliday", "int", "active"));
19      VolFldN=FldNmTyUseTrV.Add(TStrTr("VolumeStart", "int", "active"));
20      CsptFldN=FldNmTyUseTrV.Add(TStrTr("Cnsmptn", "int", "active"));
21      FldNmTyUseTrV.Add(TStrTr("Interpolation", "int", "active"));
22      CsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1W", "int", "active"));
23      CsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2W", "int", "active"));
24      CsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3W", "int", "active"));
25      SumCsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1W", "int", "active"));
26      SumCsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2W", "int", "active"));
27      SumCsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3W", "int", "active"));
28      CsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1D", "int", "active"));
29      CsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2D", "int", "active"));
30      CsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3D", "int", "active"));
31      CsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast4D", "int", "active"));
32      CsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast5D", "int", "active"));
33      CsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast6D", "int", "active"));
34      SumCsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1D", "int", "active"));
35      SumCsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2D", "int", "active"));
36      SumCsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3D", "int", "active"));
37      SumCsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast4D", "int", "active"));
38      SumCsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast5D", "int", "active"));
39      SumCsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast6D", "int", "active"));
40      PriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("PriceChange", "int", "active"));
41      DaysBeforePriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("DaysBeforePriceChange", "int", "active"));
42    } else {
43      LocIdFldN=FldNmTyUseTrV.Add(TStrTr("LocationID", "int", "meta"));
44      TankIdFldN=FldNmTyUseTrV.Add(TStrTr("TankID", "int", "meta"));
<span onclick='openModal()' class='match'>45      ProdIdFldN=FldNmTyUseTrV.Add(TStrTr("ProductID", "int", "meta"));
46      DateFldN=FldNmTyUseTrV.Add(TStrTr("Date", "date", "active"));
47      HourNFldN=FldNmTyUseTrV.Add(TStrTr("HourStart", "int", "active"));
48      FldNmTyUseTrV.Add(TStrTr("HourEnd", "int", "active"));
49      CsptFldN=FldNmTyUseTrV.Add(TStrTr("Cnsmptn", "int", "active"));
50      VolFldN=FldNmTyUseTrV.Add(TStrTr("VolumeStart", "int", "active"));
51      FldNmTyUseTrV.Add(TStrTr("Interpolation", "int", "active"));
52      CsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1W", "int", "active"));
53      CsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2W", "int", "active"));
54      CsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3W", "int", "active"));
55      SumCsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1W", "int", "active"));
56      SumCsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2W", "int", "active"));
57      SumCsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3W", "int", "active"));
58      CsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1D", "int", "active"));
59      CsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2D", "int", "active"));
</span>60      CsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3D", "int", "active"));
61      CsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast4D", "int", "active"));
62      CsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast5D", "int", "active"));
63      CsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast6D", "int", "active"));
64      SumCsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1D", "int", "active"));
65      SumCsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2D", "int", "active"));
66      SumCsptLast3DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3D", "int", "active"));
67      SumCsptLast4DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast4D", "int", "active"));
68      SumCsptLast5DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast5D", "int", "active"));
69      SumCsptLast6DFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast6D", "int", "active"));
70      DayNFldN=FldNmTyUseTrV.Add(TStrTr("Day", "int", "active"));
71      MonthNFldN=FldNmTyUseTrV.Add(TStrTr("Month", "int", "active"));
72      YearNFldN=FldNmTyUseTrV.Add(TStrTr("Year", "int", "active"));
73      DowNFldN=FldNmTyUseTrV.Add(TStrTr("DayOfWeek", "dow", "active"));
74      IsHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsHoliday", "int", "active"));
75      IsHolidayStartFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayStart", "int", "active"));
76      IsHolidayEndFldN=FldNmTyUseTrV.Add(TStrTr("IsHolidayEnd", "int", "active"));
77      IsDayBeforeHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayBeforeHoliday", "int", "active"));
78      IsDayAfterHolidayFldN=FldNmTyUseTrV.Add(TStrTr("IsDayAfterHoliday", "int", "active"));
79      PriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("PriceChange", "int", "active"));
80      DaysBeforePriceChangeFldN=FldNmTyUseTrV.Add(TStrTr("DaysBeforePriceChange", "int", "active"));
81      ProdNmFldN=FldNmTyUseTrV.Add(TStrTr("ProductName", "int", "ignore"));
82      LocNmFldN=FldNmTyUseTrV.Add(TStrTr("LocationName", "int", "ignore"));
83    }
84  }
85  bool TGasDef::IsFldNmVOk(const TStrV& FldNmV) const {
86    if (GetFlds()!=FldNmV.Len()){return false;}
87    for (int FldN=0; FldN<FldNmV.Len(); FldN++){
88      if (FldNmTyUseTrV[FldN].Val1!=FldNmV[FldN]){
89        printf("'%s'!='%s'", FldNmTyUseTrV[FldN].Val1.CStr(), FldNmV[FldN].CStr());
90        return false;
91      }
92    }
93    return true;
94  }
95  void TGasDef::GetFldIntValV(const TStrV& FldStrValV, TIntV& FldIntValV) const {
96    int Flds=GetFlds();
97    EAssertR(Flds==FldStrValV.Len(), "Number of data fields doesn't fit.");
98    FldIntValV.Gen(Flds);
99    for (int FldN=0; FldN<Flds; FldN++){
100      TStrTr& FldNmTyUseTr=FldNmTyUseTrV[FldN];
101      if (FldNmTyUseTr.Val3!="ignore"){
102        if (FldNmTyUseTr.Val2=="int"){
103          if (FldStrValV[FldN]=="True"){FldIntValV[FldN]=1;}
104          else if (FldStrValV[FldN]=="False"){FldIntValV[FldN]=0;}
105          else {FldIntValV[FldN]=FldStrValV[FldN].GetInt();}
106        } else
107        if (FldNmTyUseTr.Val2=="date"){
108          TSecTm Date=TSecTm::GetDtTmFromDmyStr(FldStrValV[FldN]);
109          FldIntValV[FldN]=Date.GetAbsSecs();
110        } else
111        if (FldNmTyUseTr.Val2=="dow"){
112          TStr DowNm=FldStrValV[FldN];
113          if (!DowNm.Empty()){DowNm.PutCh(0, TCh::GetUc(DowNm[0]));}
114          int DowN=TTmInfo::GetDayOfWeekN(DowNm, lSi);
115          FldIntValV[FldN]=DowN;
116        }
117      }
118    }
119  }
120  TSecTm TGasDef::GetTm(const TIntV& FldIntValV) const {
121    int HourN=FldIntValV[HourNFldN];
122    int DayN=FldIntValV[DayNFldN];
123    int MonthN=FldIntValV[MonthNFldN];
124    int YearN=FldIntValV[YearNFldN];
125    TSecTm Tm=TSecTm::GetDtTm(YearN, MonthN, DayN);
126    Tm.AddHours(HourN);
127    return Tm;
128  }
129  void TGasDef::GetHdm(
130   const TIntV& FldIntValV, int& HourN, int& DowN, int& MonthN) const {
131    HourN=FldIntValV[HourNFldN];
132    DowN=FldIntValV[DowNFldN]-1;
133    MonthN=FldIntValV[MonthNFldN]-1;
134  }
135  TSecTm TGasLtpBs::GetMnDate() const {
136    TSecTm MnDate;
137    int Recs=GetRecs();
138    for (int RecN=0; RecN<Recs; RecN++){
139      TSecTm Date=GetDate(RecN);
140      if ((RecN==0)||(Date<MnDate)){MnDate=Date;}
141    }
142    return MnDate;
143  }
144  TSecTm TGasLtpBs::GetMxDate() const {
145    TSecTm MxDate;
146    int Recs=GetRecs();
147    for (int RecN=0; RecN<Recs; RecN++){
148      TSecTm Date=GetDate(RecN);
149      if ((RecN==0)||(Date>MxDate)){MxDate=Date;}
150    }
151    return MxDate;
152  }
153  void TGasLtpBs::GenStat(){
154    TMom::NewV(HourMomV, 24);
155    TMom::NewV(DowMomV, 7);
156    TMom::NewV(MonthMomV, 12);
157    TMom::NewVV(DowHourMomVV, 7, 24);
158    int Recs=GetRecs();
159    for (int RecN=0; RecN<Recs; RecN++){
160      int HourN; int DowN; int MonthN;
161      GasDef->GetHdm(GetRec(RecN), HourN, DowN, MonthN);
162      int Cspt=GasDef->GetCspt(GetRec(RecN));
163      HourMomV[HourN]->Add(Cspt);
164      DowMomV[DowN]->Add(Cspt);
165      MonthMomV[MonthN]->Add(Cspt);
166      DowHourMomVV.At(DowN, HourN)->Add(Cspt);
167    }
168    TMom::DefV(HourMomV);
169    TMom::DefV(DowMomV);
170    TMom::DefV(MonthMomV);
171    TMom::DefVV(DowHourMomVV);
172  }
173  bool TGasLtpBs::IsDowHourMomUsable() const {
174    return
175     TMom::IsUsableV(HourMomV)&&
176     TMom::IsUsableV(DowMomV)&&
177     TMom::IsUsableVV(DowHourMomVV);
178  }
179  void TGasLtpBs::RepairUnknowns(){
180    if (!IsDowHourMomUsable()){
181      printf("*** Error: day-of-week & hour statistics cannot be generated (not enough data)!\n");
182      printf("*** Can not repair data!\n");
183      return;
184    }
185    int Recs=GetRecs();
186    for (int RecN=0; RecN<Recs; RecN++){
187      int RecHourN; int RecDowN; int RecMonthN;
188      GetHdm(RecN, RecHourN, RecDowN, RecMonthN);
189      TSecTm RecTm=GetTm(RecN);
190      TSecTm RecDate=GetDate(RecN);
191      TStr Str=RecTm.GetStr();
192      if (RecN>0){
193        int DSecs=TSecTm::GetDSecs(GetTm(RecN-1), RecTm);
194        if (DSecs!=3600){
195          printf("*** Error - records not at hour interval (%s - %s)!\n",
196           GetTm(RecN-1).GetStr().CStr(), RecTm.GetStr().CStr());
197        }
198      }
199      if (GetCspt(RecN)<0){
200        printf("*** Error: consumption is negative (%d)!\n", GetCspt(RecN));
201        printf("*** Can not repair data!\n");
202        return;
203      }
204      if (GetCsptLast1D(RecN)==-1){
205        GetCsptLast1D(RecN)=DowHourMomVV.At((RecDowN+7-1)%7, RecHourN)->GetMedian();}
206      if (GetCsptLast2D(RecN)==-1){
207        GetCsptLast2D(RecN)=DowHourMomVV.At((RecDowN+7-2)%7, RecHourN)->GetMedian();}
208      if (GetCsptLast3D(RecN)==-1){
209        GetCsptLast3D(RecN)=DowHourMomVV.At((RecDowN+7-3)%7, RecHourN)->GetMedian();}
210      if (GetCsptLast4D(RecN)==-1){
211        GetCsptLast4D(RecN)=DowHourMomVV.At((RecDowN+7-4)%7, RecHourN)->GetMedian();}
212      if (GetCsptLast5D(RecN)==-1){
213        GetCsptLast5D(RecN)=DowHourMomVV.At((RecDowN+7-5)%7, RecHourN)->GetMedian();}
214      if (GetCsptLast6D(RecN)==-1){
215        GetCsptLast6D(RecN)=DowHourMomVV.At((RecDowN+7-6)%7, RecHourN)->GetMedian();}
216      if (GetSumCsptLast1D(RecN)==-1){
217        GetSumCsptLast1D(RecN)=DowMomV[(RecDowN+7-1)%7]->GetMedian();}
218      if (GetSumCsptLast2D(RecN)==-1){
219        GetSumCsptLast2D(RecN)=DowMomV[(RecDowN+7-2)%7]->GetMedian();}
220      if (GetSumCsptLast3D(RecN)==-1){
221        GetSumCsptLast3D(RecN)=DowMomV[(RecDowN+7-1)%7]->GetMedian();}
222      if (GetSumCsptLast4D(RecN)==-1){
223        GetSumCsptLast4D(RecN)=DowMomV[(RecDowN+7-4)%7]->GetMedian();}
224      if (GetSumCsptLast5D(RecN)==-1){
225        GetSumCsptLast5D(RecN)=DowMomV[(RecDowN+7-5)%7]->GetMedian();}
226      if (GetSumCsptLast6D(RecN)==-1){
227        GetSumCsptLast6D(RecN)=DowMomV[(RecDowN+7-6)%7]->GetMedian();}
228      if (GetCsptLast1W(RecN)==-1){
229        GetCsptLast1W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
230      if (GetCsptLast2W(RecN)==-1){
231        GetCsptLast2W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
232      if (GetCsptLast3W(RecN)==-1){
233        GetCsptLast3W(RecN)=DowHourMomVV.At(RecDowN, RecHourN)->GetMedian();}
234      if (GetSumCsptLast1W(RecN)==-1){
235        GetSumCsptLast1W(RecN)=DowMomV[RecDowN]->GetMedian();}
236      if (GetSumCsptLast2W(RecN)==-1){
237        GetSumCsptLast2W(RecN)=DowMomV[RecDowN]->GetMedian();}
238      if (GetSumCsptLast3W(RecN)==-1){
239        GetSumCsptLast3W(RecN)=DowMomV[RecDowN]->GetMedian();}
240    }
241  }
242  void TGasLtpBs::SaveStatTxt(const PSOut& SOut) const {
243    SOut->PutStr("==========================================================");
244    SOut->PutLn();
245    SOut->PutStr(LtpNm); SOut->PutStr("  /  ");
246    SOut->PutStr(LocNm); SOut->PutStr("  /  ");
247    SOut->PutStr(ProdNm); SOut->PutLn();
248    SOut->PutStr("Consumption per Hour");
249    SOut->PutLn();
250    for (int HourN=0; HourN<24; HourN++){
251      SOut->PutInt(HourN); SOut->PutStr(": ");
252      SOut->PutStr(HourMomV[HourN]->GetStr(' ', ':', true));
253      SOut->PutLn();
254    }
255    SOut->PutStr("Consumption per Day-Of-Week");
256    SOut->PutLn();
257    for (int DowN=0; DowN<7; DowN++){
258      SOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1)); SOut->PutStr(": ");
259      SOut->PutStr(DowMomV[DowN]->GetStr(' ', ':', true));
260      SOut->PutLn();
261    }
262    SOut->PutStr("Consumption per Month");
263    SOut->PutLn();
264    for (int MonthN=0; MonthN<12; MonthN++){
265      SOut->PutStr(TTmInfo::GetMonthNm(MonthN+1)); SOut->PutStr(": ");
266      SOut->PutStr(MonthMomV[MonthN]->GetStr(' ', ':', true));
267      SOut->PutLn();
268    }
269    SOut->PutStr("Consumption per Day-Of-Week&Hour");
270    SOut->PutLn();
271    {for (int DowN=0; DowN<7; DowN++){
272      for (int HourN=0; HourN<24; HourN++){
273        SOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1)); SOut->PutStr("/");
274        SOut->PutInt(HourN); SOut->PutStr(": ");
275        SOut->PutStr(DowHourMomVV.At(DowN, HourN)->GetStr(' ', ':', true));
276        SOut->PutLn();
277      }
278    }}
279    SOut->Flush();
280  }
281  void TGasLtpBs::SaveStatBin(const PSOut& SOut) const {
282    PGasLtpBs StatLtpBs=TGasLtpBs::New(LtpNm, LocNm, ProdNm);
283    StatLtpBs->HourMomV=HourMomV;
284    StatLtpBs->DowMomV=DowMomV;
285    StatLtpBs->MonthMomV=MonthMomV;
286    StatLtpBs->DowHourMomVV=DowHourMomVV;
287    StatLtpBs->Save(*SOut);
288    SOut->Flush();
289  }
290  void TGasLtpBs::LoadStatV(const TStr& FNm, TGasLtpBsV& GasLtpBsV){
291    GasLtpBsV.Clr();
292    if (TFile::Exists(FNm)){
293      PSIn SIn=TFIn::New(FNm);
294      while (!SIn->Eof()){
295        PGasLtpBs GasLtpBs=TGasLtpBs::Load(*SIn);
296        GasLtpBsV.Add(GasLtpBs);
297      }
298    }
299  }
300  void TGasLtpBs::ConvTabToLtp(const TStr& InTabFNmWc, const TStr& OutLtpFPath,
301   const bool& RepairUnknownsP){
302    PGasDef GasDef=TGasDef::New();
303    TStr OutLtpNrFPath=TStr::GetNrFPath(OutLtpFPath);
304    PGasLtpBs GasLtpBs; TStr LtpNm; TSecTm PrevLtpTm;
305    PSOut LtpStatTxtSOut=TFOut::New(OutLtpNrFPath+LtpStatTxtFNm);
306    PSOut LtpStatBinSOut=TFOut::New(OutLtpNrFPath+LtpStatBinFNm);
307    TFFile FFile(InTabFNmWc, false); TStr FNm; int Recs=0;
308    while (FFile.Next(FNm)){
309      printf("Processing file '%s'\n", FNm.CStr());
310      PSIn SIn=TFIn::New(FNm);
311      char PrevCh=' '; TStrV FldNmV;
312      TSs::LoadTxtFldV(ssfTabSep, SIn, PrevCh, FldNmV);
313      EAssertR(GasDef->IsFldNmVOk(FldNmV), TStr("Field names don't fit in ")+FNm);
314      int LnN=0;
315      while (!SIn->Eof()){
316        char PrevCh=' '; TStrV FldStrValV;
317        TSs::LoadTxtFldV(ssfTabSep, SIn, PrevCh, FldStrValV); LnN++;
318        if (LtpNm!=GasDef->GetLtpNm(FldStrValV)){
319          if (!GasLtpBs.Empty()){
320            GasLtpBs->GenStat();
321            if (RepairUnknownsP){GasLtpBs->RepairUnknowns();}
322            GasLtpBs->SaveStatTxt(LtpStatTxtSOut);
323            GasLtpBs->SaveStatBin(LtpStatBinSOut);
324            TStr LtpFNm=OutLtpNrFPath+GasDef->GetLtpFNm(LtpNm);
325            {TFOut LtpSOut(LtpFNm); GasLtpBs->Save(LtpSOut);}
326            PGasLtpBs NewGasLtpBs=TGasLtpBs::Load(LtpFNm);
327          }
328          LtpNm=GasDef->GetLtpNm(FldStrValV);
329          TStr LocNm=GasDef->GetLocNm(FldStrValV);
330          TStr ProdNm=GasDef->GetProdNm(FldStrValV);
331          GasLtpBs=TGasLtpBs::New(LtpNm, LocNm, ProdNm, GasDef);
332          PrevLtpTm.Undef();
333          printf("Processing Ltp: '%s' '%s' '%s'\n",
334           LtpNm.CStr(), LocNm.CStr(), ProdNm.CStr());
335        }
336        TIntV& FldIntValV=GasLtpBs->AddRec();
337        GasDef->GetFldIntValV(FldStrValV, FldIntValV);
338        TSecTm LtpTm=GasDef->GetTm(FldIntValV);
339        if (PrevLtpTm.IsDef()){
340          if (PrevLtpTm>=LtpTm){
341            printf("Time is not increasing [Line:%d PrevTime:%s CurTime:%s]\n",
342             LnN, PrevLtpTm.GetStr().CStr(), LtpTm.GetStr().CStr());
343          }
344          if (TSecTm::GetDSecs(PrevLtpTm, LtpTm)!=3600){
345            printf("Not one hour difference between subsequent records "
346             "[Line:%d PrevTime:%s CurTime:%s]\n",
347             LnN, PrevLtpTm.GetStr().CStr(), LtpTm.GetStr().CStr());
348          }
349          EAssertR(PrevLtpTm<LtpTm, "Records not in increased time sequence.");
350        }
351        PrevLtpTm=LtpTm;
352        Recs++; if (Recs%1000==0){printf("%d\r", Recs);}
353      }
354    }
355    if (!GasLtpBs.Empty()){
356      GasLtpBs->GenStat();
357      if (RepairUnknownsP){GasLtpBs->RepairUnknowns();}
358      GasLtpBs->SaveStatTxt(LtpStatTxtSOut);
359      GasLtpBs->SaveStatBin(LtpStatBinSOut);
360      TStr LtpFNm=OutLtpNrFPath+GasDef->GetLtpFNm(LtpNm);
361      {TFOut LtpSOut(LtpFNm); GasLtpBs->Save(LtpSOut);}
362      PGasLtpBs NewGasLtpBs=TGasLtpBs::Load(LtpFNm);
363    }
364  }
365  const TStr TGasLtpBs::LtpStatTxtFNm="LtpStat.Txt";
366  const TStr TGasLtpBs::LtpStatBinFNm="LtpStat.Dat";
367  int TGasDm::AddVar(const TStr& VarNm, const TStr& VarTy){
368    IAssert((!VarNmTyKdV.IsIn(TStrKd(VarNm)))&&(VarValVV.Empty()));
369    int VarN=VarNmTyKdV.Add(TStrKd(VarNm, VarTy));
370    if (VarTy=="class"){IAssert(ClassVarN==-1); ClassVarN=VarN;}
371    if (VarTy=="date"){IAssert(DateVarN==-1); DateVarN=VarN;}
372    if (VarTy=="volume"){IAssert(VolVarN==-1); VolVarN=VarN;}
373    if (VarTy=="attr"){Attrs++;}
374    return VarN;
375  }
376  void TGasDm::GetAttrNmV(TStrV& AttrNmV) const {
377    AttrNmV.Gen(Attrs, 0);
378    for (int VarN=0; VarN<GetVars(); VarN++){
379      if (GetVarTy(VarN)=="attr"){
380        AttrNmV.Add(GetVarNm(VarN));
381      }
382    }
383  }
384  int TGasDm::GetAttrN(const TStr& AttrNm) const {
385    TStrV AttrNmV; GetAttrNmV(AttrNmV);
386    return AttrNmV.SearchForw(AttrNm);
387  }
388  TStr TGasDm::GetClassNm() const {
389    for (int VarN=0; VarN<GetVars(); VarN++){
390      if (GetVarTy(VarN)=="class"){
391        return GetVarNm(VarN);
392      }
393    }
394    Fail;
395    return TStr();
396  }
397  void TGasDm::GetRecNV(
398   const TSecTm& StartDate, const TSecTm& EndDate,
399   const int& StartRecN, const int& EndRecN, const double& MnCspt, TIntV& RecNV){
400    if ((StartDate.IsDef()&&EndDate.IsDef())){
401      IAssert((StartRecN==-1)&&(EndRecN==-1));
402      RecNV.Clr(); int Recs=GetRecs();
403      for (int RecN=0; RecN<Recs; RecN++){
404        TSecTm RecDate=GetDateVal(RecN);
405        if ((StartDate.IsDef()&&(RecDate<StartDate))||
406         (EndDate.IsDef()&&(EndDate<RecDate))){continue;}
407        if ((MnCspt!=-1)&&(GetClassVal(RecN)<MnCspt)){continue;}
408        RecNV.Add(RecN);
409      }
410    } else
411    if ((StartRecN!=-1)&&(EndRecN!=-1)){
412      IAssert((!StartDate.IsDef())&&(!EndDate.IsDef()));
413      RecNV.Clr();
414      for (int RecN=StartRecN; RecN<=EndRecN; RecN++){
415        RecNV.Add(RecN);
416      }
417    } else {
418      Fail;
419    }
420  }
421  void TGasDm::GetAttrValV(const int& RecN, TFltV& AttrValV) const {
422    AttrValV.Gen(Attrs, 0);
423    for (int VarN=0; VarN<GetVars(); VarN++){
424      if (GetVarTy(VarN)=="attr"){
425        AttrValV.Add(VarValVV[RecN][VarN]);
426      }
427    }
428  }
429  double TGasDm::GetAttrVal(
430   const int& RecN, const int& AttrN, const double& DfVal) const {
431    TFltV AttrValV; GetAttrValV(RecN, AttrValV);
432    if (AttrN==-1){return DfVal;}
433    else {return AttrValV[AttrN];}
434  }
435  double TGasDm::GetAttrVal(
436   const int& RecN, const TStr& AttrNm, const double& DfVal) const {
437    TFltV AttrValV; GetAttrValV(RecN, AttrValV);
438    int AttrN=GetAttrN(AttrNm);
439    if (AttrN==-1){return DfVal;}
440    else {return AttrValV[AttrN];}
441  }
442  TStr TGasDm::GetBitsStr(const int& RecN) const {
443    double IsHolidayVal=GetAttrVal(RecN, "IsHoliday", 0);
444    double IsHolidayStartVal=GetAttrVal(RecN, "IsHolidayStart", 0);
445    double IsHolidayEndVal=GetAttrVal(RecN, "IsHolidayEnd", 0);
446    double IsDayBeforeHolidayVal=GetAttrVal(RecN, "IsDayBeforeHoliday", 0);
447    double IsDayAfterHolidayVal=GetAttrVal(RecN, "IsDayAfterHoliday", 0);
448    double PriceChangeVal=GetAttrVal(RecN, "PriceChange", 0);
449    double DaysBeforePriceChangeVal=GetAttrVal(RecN, "DaysBeforePriceChange", 0);
450    TChA ChA;
451    if (IsHolidayVal!=0){ChA+=" IsHoliday";}
452    if (IsHolidayStartVal!=0){ChA+=" IsHolidayStart";}
453    if (IsHolidayEndVal!=0){ChA+=" IsHolidayEnd";}
454    if (IsDayBeforeHolidayVal!=0){ChA+=" IsDayBeforeHoliday";}
455    if (IsDayAfterHolidayVal!=0){ChA+=" IsDayAfterHoliday";}
456    if (PriceChangeVal!=0){ChA+=" PriceChange:"; ChA+=TFlt::GetStr(PriceChangeVal);}
457    if (DaysBeforePriceChangeVal!=0){
458      ChA+=" DaysBeforePriceChange:"; ChA+=TFlt::GetStr(DaysBeforePriceChangeVal);
459      if (RecN+1<GetRecs()){
460        ChA+=TFlt::GetStr(GetAttrVal(RecN+1, "PriceChange", 0), "(%g%%)");}
461    }
462    return ChA;
463  }
464  PGasDm TGasDm::GetWeekGasDm(const PGasLtpBs& GasLtpBs){
465    TIntIntH DayNToCsptH;
466    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
467      int DayN=GasLtpBs->GetDateInt(RecN);
468      DayNToCsptH.AddDat(DayN)+=GasLtpBs->GetCspt(RecN);
469    }
470    TSecTm MnLtpDate=GasLtpBs->GetMnDate();
471    TSecTm MxLtpDate=GasLtpBs->GetMxDate();
472    typedef TKeyDat<TSecTm, TInt> TDateCsptKd;
473    TVec<TDateCsptKd> DateCsptKdV;
474    for (TSecTm LtpDate=MnLtpDate; LtpDate<MxLtpDate; LtpDate.AddDays(1)){
475      int DayN=LtpDate.GetAbsSecs();
476      if (!DayNToCsptH.IsKey(DayN)){continue;}
477      int Cspt=DayNToCsptH.GetDat(DayN);
478      if (LtpDate.GetDayOfWeekN()==TTmInfo::SunN){
479        DateCsptKdV.Add(TDateCsptKd(LtpDate, 0));}
480      if (DateCsptKdV.Len()>0){
481        DateCsptKdV.Last().Dat+=Cspt;}
482    }
483    PGasDm GasDm=TGasDm::New("Week");
484    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
485    GasDm->PutLocNm(GasLtpBs->GetLocNm());
486    GasDm->PutProdNm(GasLtpBs->GetProdNm());
487    GasDm->AddVar("Date", "date");
488    GasDm->AddVar("Cspt", "class");
489    GasDm->AddVar("Const", "attr");
490    GasDm->AddVar("Month", "attr");
491    GasDm->AddVar("SumCsptLast1W", "attr");
492    GasDm->AddVar("SumCsptLast2W", "attr");
493    GasDm->AddVar("SumCsptLast3W", "attr");
494    GasDm->AddVar("SumCsptLast1D", "attr");
495    GasDm->AddVar("SumCsptLast2D", "attr");
496    GasDm->AddVar("SumCsptLast3D", "attr");
497    GasDm->AddVar("SumCsptLast4D", "attr");
498    GasDm->AddVar("SumCsptLast5D", "attr");
499    GasDm->AddVar("SumCsptLast6D", "attr");
500    GasDm->AddVar("Volume", "volume");
501    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
502      TSecTm Date=TSecTm(GasLtpBs->GetDateInt(RecN));
503      int DateCsptKdN=DateCsptKdV.SearchForw(TDateCsptKd(Date));
504      if (DateCsptKdN==-1){continue;}
505      double Cspt=DateCsptKdV[DateCsptKdN].Dat;
506      if (Cspt==-1){continue;}
507      else {DateCsptKdV[DateCsptKdN].Dat=-1;}
508      TFltV VarValV(GasDm->GetVars(), 0);
509      VarValV.Add(GasLtpBs->GetDateInt(RecN));
510      VarValV.Add(Cspt);
511      VarValV.Add(1);
512      VarValV.Add(GasLtpBs->GetMonthN(RecN));
513      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1W(RecN)));
514      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2W(RecN)));
515      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3W(RecN)));
516      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1D(RecN)));
517      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2D(RecN)));
518      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3D(RecN)));
519      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast4D(RecN)));
520      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast5D(RecN)));
521      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast6D(RecN)));
522      if (VarValV.IsIn(-1)){
523        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
524      VarValV.Add(GasLtpBs->GetVol(RecN));
525      GasDm->AddRec(VarValV);
526    }}
527    return GasDm;
528  }
529  PGasDm TGasDm::GetDayGasDm(const PGasLtpBs& GasLtpBs){
530    TIntIntH DayNToCsptH;
531    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
532      int DayN=GasLtpBs->GetDateInt(RecN);
533      DayNToCsptH.AddDat(DayN)+=GasLtpBs->GetCspt(RecN);
534    }
535    PGasDm GasDm=TGasDm::New("Day");
536    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
537    GasDm->PutLocNm(GasLtpBs->GetLocNm());
538    GasDm->PutProdNm(GasLtpBs->GetProdNm());
539    GasDm->AddVar("Date", "date");
540    GasDm->AddVar("Cspt", "class");
541    GasDm->AddVar("Const", "attr");
542    GasDm->AddVar("Dow", "attr");
543    GasDm->AddVar("Month", "attr");
544    GasDm->AddVar("SumCsptLast1W", "attr");
545    GasDm->AddVar("SumCsptLast2W", "attr");
546    GasDm->AddVar("SumCsptLast3W", "attr");
547    GasDm->AddVar("SumCsptLast1D", "attr");
548    GasDm->AddVar("SumCsptLast2D", "attr");
549    GasDm->AddVar("SumCsptLast3D", "attr");
550    GasDm->AddVar("SumCsptLast4D", "attr");
551    GasDm->AddVar("SumCsptLast5D", "attr");
552    GasDm->AddVar("SumCsptLast6D", "attr");
553    GasDm->AddVar("IsHoliday", "attr");
554    GasDm->AddVar("IsHolidayStart", "attr");
555    GasDm->AddVar("IsHolidayEnd", "attr");
556    GasDm->AddVar("IsDayBeforeHoliday", "attr");
557    GasDm->AddVar("IsDayAfterHoliday", "attr");
558    GasDm->AddVar("PriceChange", "attr");
559    GasDm->AddVar("DaysBeforePriceChange", "attr");
560    GasDm->AddVar("Volume", "volume");
561    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
562      double Cspt=DayNToCsptH.GetDat(GasLtpBs->GetDateInt(RecN));
563      if (Cspt==-1){continue;}
564      else {DayNToCsptH.GetDat(GasLtpBs->GetDateInt(RecN))=-1;}
565      TFltV VarValV(GasDm->GetVars(), 0);
566      VarValV.Add(GasLtpBs->GetDateInt(RecN));
567      VarValV.Add(Cspt);
568      VarValV.Add(1);
569      VarValV.Add(GasLtpBs->GetDowN(RecN));
570      VarValV.Add(GasLtpBs->GetMonthN(RecN));
571      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1W(RecN)));
572      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2W(RecN)));
573      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3W(RecN)));
574      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast1D(RecN)));
575      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast2D(RecN)));
576      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast3D(RecN)));
577      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast4D(RecN)));
578      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast5D(RecN)));
579      VarValV.Add(TFlt(GasLtpBs->GetSumCsptLast6D(RecN)));
580      if (VarValV.IsIn(-1)){
581        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
582      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
583      VarValV.Add(GasLtpBs->GetIsHolidayStart(RecN));
584      VarValV.Add(GasLtpBs->GetIsHolidayEnd(RecN));
585      VarValV.Add(GasLtpBs->GetIsDayBeforeHoliday(RecN));
586      VarValV.Add(GasLtpBs->GetIsDayAfterHoliday(RecN));
587      VarValV.Add(GasLtpBs->GetPriceChange(RecN));
588      VarValV.Add(GasLtpBs->GetDaysBeforePriceChange(RecN));
589      VarValV.Add(GasLtpBs->GetVol(RecN));
590      GasDm->AddRec(VarValV);
591    }}
592    return GasDm;
593  }
594  void TGasDm::AddCsptBlock(
595   TIntIntH& HourNToCsptH, const int& BlockN, const int& Cspt){
596    if ((!HourNToCsptH.IsKey(BlockN))||(HourNToCsptH.GetDat(BlockN)!=-1)){
597      if (Cspt==-1){
598        HourNToCsptH.AddDat(BlockN)=-1;
599      } else {
600        HourNToCsptH.AddDat(BlockN)=Cspt;
601      }
602    }
603  }
604  PGasDm TGasDm::GetHourBlockGasDm(const PGasLtpBs& GasLtpBs, const int& HourBlockLen){
605    EAssertRA(24%HourBlockLen==0, "Hour resulution not divisible by 24", TInt::GetStr(HourBlockLen));
606    TIntIntH BlockNToCsptH;
607    TIntIntH BlockNToCsptLast1WH;
608    TIntIntH BlockNToCsptLast2WH;
609    TIntIntH BlockNToCsptLast3WH;
610    TIntIntH BlockNToCsptLast1DH;
611    TIntIntH BlockNToCsptLast2DH;
612    TIntIntH BlockNToCsptLast3DH;
613    TIntIntH BlockNToCsptLast4DH;
614    TIntIntH BlockNToCsptLast5DH;
615    TIntIntH BlockNToCsptLast6DH;
616    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
617      int DayN=GasLtpBs->GetDateInt(RecN); IAssert(DayN%100==0);
618      int HourN=GasLtpBs->GetHourN(RecN);
619      IAssert((0<=HourN)&&(HourN<24));
620      int BlockN=DayN+(HourN/HourBlockLen)*HourBlockLen;
621      BlockNToCsptH.AddDat(BlockN)+=GasLtpBs->GetCspt(RecN);
622      AddCsptBlock(BlockNToCsptLast1WH, BlockN, GasLtpBs->GetCsptLast1W(RecN));
623      AddCsptBlock(BlockNToCsptLast2WH, BlockN, GasLtpBs->GetCsptLast2W(RecN));
624      AddCsptBlock(BlockNToCsptLast3WH, BlockN, GasLtpBs->GetCsptLast3W(RecN));
625      AddCsptBlock(BlockNToCsptLast1DH, BlockN, GasLtpBs->GetCsptLast1D(RecN));
626      AddCsptBlock(BlockNToCsptLast2DH, BlockN, GasLtpBs->GetCsptLast2D(RecN));
627      AddCsptBlock(BlockNToCsptLast3DH, BlockN, GasLtpBs->GetCsptLast3D(RecN));
628      AddCsptBlock(BlockNToCsptLast4DH, BlockN, GasLtpBs->GetCsptLast4D(RecN));
629      AddCsptBlock(BlockNToCsptLast5DH, BlockN, GasLtpBs->GetCsptLast5D(RecN));
630      AddCsptBlock(BlockNToCsptLast6DH, BlockN, GasLtpBs->GetCsptLast6D(RecN));
631    }
632    PGasDm GasDm=TGasDm::New(TStr("Hour")+TInt::GetStr(HourBlockLen));
633    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
634    GasDm->PutLocNm(GasLtpBs->GetLocNm());
635    GasDm->PutProdNm(GasLtpBs->GetProdNm());
636    GasDm->AddVar("Date", "date"); 
637    GasDm->AddVar("Cspt", "class"); 
638    GasDm->AddVar("Const", "attr"); 
639    GasDm->AddVar("Hour", "attr"); 
640    GasDm->AddVar("Dow", "attr"); 
641    GasDm->AddVar("Month", "attr"); 
642    GasDm->AddVar("CsptLast1W", "attr");
643    GasDm->AddVar("CsptLast2W", "attr");
644    GasDm->AddVar("CsptLast3W", "attr");
645    GasDm->AddVar("CsptLast1D", "attr");
646    GasDm->AddVar("CsptLast2D", "attr");
647    GasDm->AddVar("CsptLast3D", "attr");
648    GasDm->AddVar("CsptLast4D", "attr");
649    GasDm->AddVar("CsptLast5D", "attr");
650    GasDm->AddVar("CsptLast6D", "attr");
651    GasDm->AddVar("IsHoliday", "attr");
652    GasDm->AddVar("Volume", "volume");
653    {for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
654      int DayN=GasLtpBs->GetDateInt(RecN); IAssert(DayN%100==0);
655      int HourN=GasLtpBs->GetHourN(RecN);
656      IAssert((0<=HourN)&&(HourN<24));
657      int BlockN=DayN+(HourN/HourBlockLen)*HourBlockLen;
658      int BlockHourN=BlockN%100;
659      double Cspt=BlockNToCsptH.GetDat(BlockN);
660      if (Cspt==-1){continue;}
661      else {BlockNToCsptH.GetDat(BlockN)=-1;}
662      TFltV VarValV(GasDm->GetVars(), 0);
663      VarValV.Add(GasLtpBs->GetDateInt(RecN)); 
664      VarValV.Add(Cspt); 
665      VarValV.Add(1); 
666      VarValV.Add(BlockHourN); 
667      VarValV.Add(GasLtpBs->GetDowN(RecN)); 
668      VarValV.Add(GasLtpBs->GetMonthN(RecN)); 
669      VarValV.Add(int(BlockNToCsptLast1WH.GetDat(BlockN))); 
670      VarValV.Add(int(BlockNToCsptLast2WH.GetDat(BlockN))); 
671      VarValV.Add(int(BlockNToCsptLast3WH.GetDat(BlockN))); 
672      VarValV.Add(int(BlockNToCsptLast1DH.GetDat(BlockN))); 
673      VarValV.Add(int(BlockNToCsptLast2DH.GetDat(BlockN))); 
674      VarValV.Add(int(BlockNToCsptLast3DH.GetDat(BlockN))); 
675      VarValV.Add(int(BlockNToCsptLast4DH.GetDat(BlockN))); 
676      VarValV.Add(int(BlockNToCsptLast5DH.GetDat(BlockN))); 
677      VarValV.Add(int(BlockNToCsptLast6DH.GetDat(BlockN))); 
678      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
679      if (VarValV.IsIn(-1)){
680        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
681      VarValV.Add(GasLtpBs->GetVol(RecN));
682      GasDm->AddRec(VarValV);
683    }}
684    return GasDm;
685  }
686  PGasDm TGasDm::GetHourGasDm(const PGasLtpBs& GasLtpBs){
687    PGasDm GasDm=TGasDm::New();
688    GasDm->PutLtpNm(GasLtpBs->GetLtpNm());
689    GasDm->PutLocNm(GasLtpBs->GetLocNm());
690    GasDm->PutProdNm(GasLtpBs->GetProdNm());
691    GasDm->AddVar("Date", "date"); 
692    GasDm->AddVar("Cspt", "class"); 
693    GasDm->AddVar("Const", "attr"); 
694    GasDm->AddVar("Hour", "attr"); 
695    GasDm->AddVar("Dow", "attr"); 
696    GasDm->AddVar("Month", "attr"); 
697    GasDm->AddVar("CsptLast1W", "attr");
698    GasDm->AddVar("CsptLast2W", "attr");
699    GasDm->AddVar("CsptLast3W", "attr");
700    GasDm->AddVar("CsptLast1D", "attr");
701    GasDm->AddVar("CsptLast2D", "attr");
702    GasDm->AddVar("CsptLast3D", "attr");
703    GasDm->AddVar("IsHoliday", "attr");
704    GasDm->AddVar("Volume", "volume");
705    for (int RecN=0; RecN<GasLtpBs->GetRecs(); RecN++){
706      TFltV VarValV(GasDm->GetVars(), 0);
707      VarValV.Add(GasLtpBs->GetDateInt(RecN)); 
708      VarValV.Add(GasLtpBs->GetCspt(RecN)); 
709      VarValV.Add(1); 
710      VarValV.Add(GasLtpBs->GetHourN(RecN)); 
711      VarValV.Add(GasLtpBs->GetDowN(RecN)); 
712      VarValV.Add(GasLtpBs->GetMonthN(RecN)); 
713      VarValV.Add(TFlt(GasLtpBs->GetCsptLast1W(RecN)));
714      VarValV.Add(TFlt(GasLtpBs->GetCsptLast2W(RecN)));
715      VarValV.Add(TFlt(GasLtpBs->GetCsptLast3W(RecN)));
716      VarValV.Add(TFlt(GasLtpBs->GetCsptLast1D(RecN)));
717      VarValV.Add(TFlt(GasLtpBs->GetCsptLast2D(RecN)));
718      VarValV.Add(TFlt(GasLtpBs->GetCsptLast3D(RecN)));
719      VarValV.Add(GasLtpBs->GetIsHoliday(RecN));
720      if (VarValV.IsIn(-1)){
721        printf("Ignoring %s\n", GasLtpBs->GetTm(RecN).GetStr().CStr()); continue;}
722      VarValV.Add(GasLtpBs->GetVol(RecN));
723      GasDm->AddRec(VarValV);
724    }
725    return GasDm;
726  }
727  int TGasDm::AddWeekRec(const double& Cspt){
728    IAssert(TypeNm=="Week");
729    TSecTm PrevDt=GetDateVal(GetRecs()-1);
730    TSecTm TodayDt=TSecTm(PrevDt).AddDays(+7);
731    int TodayRecN=AddRec();
732    if (TodayRecN<=21){
733      TExcept::Throw("Not enough past data - cannot calculate future records.");}
734    PutVarVal(TodayRecN, "Date", TodayDt.GetAbsSecs());
735    PutVarVal(TodayRecN, "Cspt", Cspt);
736    PutVarVal(TodayRecN, "Const", 1);
737    PutVarVal(TodayRecN, "Month", TodayDt.GetMonthN());
738    PutVarVal(TodayRecN, "SumCsptLast1W", GetVarVal(TodayRecN-7, "Cspt"));
739    PutVarVal(TodayRecN, "SumCsptLast2W", GetVarVal(TodayRecN-14, "Cspt"));
740    PutVarVal(TodayRecN, "SumCsptLast3W", GetVarVal(TodayRecN-21, "Cspt"));
741    PutVarVal(TodayRecN, "SumCsptLast1D", GetVarVal(TodayRecN-1, "Cspt"));
742    PutVarVal(TodayRecN, "SumCsptLast2D", GetVarVal(TodayRecN-2, "Cspt"));
743    PutVarVal(TodayRecN, "SumCsptLast3D", GetVarVal(TodayRecN-3, "Cspt"));
744    PutVarVal(TodayRecN, "SumCsptLast4D", GetVarVal(TodayRecN-4, "Cspt"));
745    PutVarVal(TodayRecN, "SumCsptLast5D", GetVarVal(TodayRecN-5, "Cspt"));
746    PutVarVal(TodayRecN, "SumCsptLast6D", GetVarVal(TodayRecN-6, "Cspt"));
747    PutVarVal(TodayRecN, "Volume", -1);
748    return TodayRecN;
749  }
750  int TGasDm::AddDayRec(const double& Cspt){
751    IAssert(TypeNm=="Day");
752    TSecTm PrevDt=GetDateVal(GetRecs()-1);
753    TSecTm TodayDt=TSecTm(PrevDt).AddDays(+1);
754    int TodayRecN=AddRec();
755    if (TodayRecN<=21){
756      TExcept::Throw("Not enough past data - cannot calculate future records.");}
757    PutVarVal(TodayRecN, "Date", TodayDt.GetAbsSecs());
758    PutVarVal(TodayRecN, "Cspt", Cspt);
759    PutVarVal(TodayRecN, "Const", 1);
760    PutVarVal(TodayRecN, "Dow", TodayDt.GetDayOfWeekN());
761    PutVarVal(TodayRecN, "Month", TodayDt.GetMonthN());
762    PutVarVal(TodayRecN, "SumCsptLast1W", GetVarVal(TodayRecN-7, "Cspt"));
763    PutVarVal(TodayRecN, "SumCsptLast2W", GetVarVal(TodayRecN-14, "Cspt"));
764    PutVarVal(TodayRecN, "SumCsptLast3W", GetVarVal(TodayRecN-21, "Cspt"));
765    PutVarVal(TodayRecN, "SumCsptLast1D", GetVarVal(TodayRecN-1, "Cspt"));
766    PutVarVal(TodayRecN, "SumCsptLast2D", GetVarVal(TodayRecN-2, "Cspt"));
767    PutVarVal(TodayRecN, "SumCsptLast3D", GetVarVal(TodayRecN-3, "Cspt"));
768    PutVarVal(TodayRecN, "SumCsptLast4D", GetVarVal(TodayRecN-4, "Cspt"));
769    PutVarVal(TodayRecN, "SumCsptLast5D", GetVarVal(TodayRecN-5, "Cspt"));
770    PutVarVal(TodayRecN, "SumCsptLast6D", GetVarVal(TodayRecN-6, "Cspt"));
771    PutVarVal(TodayRecN, "IsHoliday", 0);
772    PutVarVal(TodayRecN, "IsHolidayStart", 0);
773    PutVarVal(TodayRecN, "IsHolidayEnd", 0);
774    PutVarVal(TodayRecN, "IsDayBeforeHoliday", 0);
775    PutVarVal(TodayRecN, "IsDayAfterHoliday", 0);
776    PutVarVal(TodayRecN, "PriceChange", 0);
777    PutVarVal(TodayRecN, "DaysBeforePriceChange", 0);
778    PutVarVal(TodayRecN, "Volume", -1);
779    return TodayRecN;
780  }
781  int TGasDm::AddHourBlockRec(const double& Cspt){
782    IAssert(TypeNm.IsPrefix("Hour"));
783    TStr HoursResStr=TypeNm.GetSubStr(TStr("Hour").Len(), 999);
784    int HoursRes=HoursResStr.GetInt(1);
785    int RecsPerDay=24/HoursRes;
786    int RecsPerWeek=(7*24)/HoursRes;
787    TSecTm PrevTm=GetDateVal(GetRecs()-1);
788    TSecTm NowTm=TSecTm(PrevTm).AddHours(HoursRes);
789    int NowRecN=AddRec();
790    if (NowRecN<=3*RecsPerWeek){
791      TExcept::Throw("Not enough past data - cannot calculate future records.");}
792    PutVarVal(NowRecN, "Date", NowTm.GetAbsSecs());
793    PutVarVal(NowRecN, "Cspt", Cspt);
794    PutVarVal(NowRecN, "Const", 1);
795    PutVarVal(NowRecN, "Hour", NowTm.GetHourN());
796    PutVarVal(NowRecN, "Dow", NowTm.GetDayOfWeekN());
797    PutVarVal(NowRecN, "Month", NowTm.GetMonthN());
798    PutVarVal(NowRecN, "CsptLast1W", GetVarVal(NowRecN-1*RecsPerWeek, "Cspt"));
799    PutVarVal(NowRecN, "CsptLast2W", GetVarVal(NowRecN-2*RecsPerWeek, "Cspt"));
800    PutVarVal(NowRecN, "CsptLast3W", GetVarVal(NowRecN-3*RecsPerWeek, "Cspt"));
801    PutVarVal(NowRecN, "CsptLast1D", GetVarVal(NowRecN-1*RecsPerDay, "Cspt"));
802    PutVarVal(NowRecN, "CsptLast2D", GetVarVal(NowRecN-2*RecsPerDay, "Cspt"));
803    PutVarVal(NowRecN, "CsptLast3D", GetVarVal(NowRecN-3*RecsPerDay, "Cspt"));
804    PutVarVal(NowRecN, "CsptLast4D", GetVarVal(NowRecN-4*RecsPerDay, "Cspt"));
805    PutVarVal(NowRecN, "CsptLast5D", GetVarVal(NowRecN-5*RecsPerDay, "Cspt"));
806    PutVarVal(NowRecN, "CsptLast6D", GetVarVal(NowRecN-6*RecsPerDay, "Cspt"));
807    PutVarVal(NowRecN, "IsHoliday", 0);
808    PutVarVal(NowRecN, "Volume", -1);
809    return NowRecN;
810  }
811  int TGasDm::AddTmResRec(const double& Cspt){
812    if (TypeNm=="Week"){return AddWeekRec(Cspt);}
813    if (TypeNm=="Day"){return AddDayRec(Cspt);}
814    if (TypeNm.IsPrefix("Hour")){return AddHourBlockRec(Cspt);}
815    else {Fail; return -1;}
816  }
817  void TGasDm::DumpRec(const int& RecN) const {
818    printf("Record[%d]:", RecN);
819    for (int VarN=0; VarN<GetVars(); VarN++){
820      if (GetVarNm(VarN)=="Date"){
821        printf(" [%s:%s]", GetVarNm(VarN).CStr(),
822         TSecTm(int(GetVarVal(RecN, VarN))).GetStr().CStr());
823      } else {
824        printf(" [%s:%g]", GetVarNm(VarN).CStr(), GetVarVal(RecN, VarN));
825      }
826    }
827    printf("\n\n");
828  }
829  void TGasDmHd::GetAttrNmV(TStrV& AttrNmV) const {
830    AttrNmV.Clr();
831    for (int VarN=0; VarN<GetVars(); VarN++){
832      if (GetVarTy(VarN)=="attr"){
833        AttrNmV.Add(GetVarNm(VarN));
834      }
835    }
836  }
837  TStr TGasDmHd::GetClassNm() const {
838    for (int VarN=0; VarN<GetVars(); VarN++){
839      if (GetVarTy(VarN)=="class"){
840        return GetVarNm(VarN);
841      }
842    }
843    Fail;
844    return TStr();
845  }
846  TStr TGasMdMType::GetDescStr() const {
847    if (GetMdTypes()==1){
848      TGasMdType GasMdType=GetMdType(0);
849      return TGasMd::GetGasMdTypeBriefNm(GasMdType);
850    } else {
851      TChA ChA;
852      ChA+="Ensemble(";
853      for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
854        if (MdTypeN>0){ChA+=' ';}
855        TGasMdType GasMdType=GetMdType(MdTypeN);
856        double Wgt=GetMdWgt(MdTypeN);
857        ChA+=TGasMd::GetGasMdTypeBriefNm(GasMdType);
858        ChA+=":";
859        ChA+=TFlt::GetStr(Wgt, "%.2f");
860      }
861      ChA+=")";
862      return ChA;
863    }
864  }
865  void TGasMdMType::AddMdTypeWgt(const TGasMdType& MdType, const double& MdWgt){
866    if (MdWgt<=0){return;}
867    MdTypeWgtPrV.Add(TIntFltPr(int(MdType), MdWgt));
868  }
869  void TGasMdMType::NrmMdWgt(){
870    double SumMdWgt=0;
871    for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
872      SumMdWgt+=GetMdWgt(MdTypeN);}
873    {for (int MdTypeN=0; MdTypeN<GetMdTypes(); MdTypeN++){
874      MdTypeWgtPrV[MdTypeN].Val2=MdTypeWgtPrV[MdTypeN].Val2/SumMdWgt;}}
875  }
876  double TGasMd::GetCorPredClassVal(
877   const PGasDm& GasDm, const int& RecN, const double& CorFact) const {
878    double ClassVal=GetPredClassVal(GasDm, RecN);
879    if (GasDm->GetAttrVal(RecN, "DaysBeforePriceChange", 0)==1){
880      ClassVal*=CorFact;}
881    if (ClassVal<0){
882      ClassVal=0;}
883    return ClassVal;
884  }
885  PGasMd TGasMd::New(
886   const TGasMdType& GasMdType,
887   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
888   const PGasDm& GasDm,
889   const TSecTm& StartDate, const TSecTm& EndDate,
890   const int& StartRecN, const int& EndRecN, const double& MnCspt){
891    switch (GasMdType){
892      case gmtCTb: return TGasMdCTb::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
893      case gmtLr: return TGasMdSvd::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
894      case gmtNNbr: return TGasMdNNbr::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
895      case gmtSvm: return TGasMdSvm::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
896      case gmtCubist: return TGasMdCubist::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
897      case gmtRegTree: return TGasMdRegTree::New(GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
898      case gmtEnsemble: return TGasMdEnsemble::New(GasMdMType, GasMdParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
899      default: Fail; return NULL;
900    }
901  }
902  TStr TGasMd::GetGasMdTypeNm(const TGasMdType& GasMdType){
903    switch (GasMdType){
904      case gmtCTb: return "Contingency-Table";
905      case gmtLr: return "Singular-Value-Decomposition";
906      case gmtNNbr: return "Nearest-Neigbour";
907      case gmtSvm: return "Support-Vector-Machine";
908      case gmtCubist: return "Cubist";
909      case gmtRegTree: return "Regression-Tree";
910      case gmtEnsemble: return "Ensemble";
911      default: Fail; return TStr();
912    }
913  }
914  TStr TGasMd::GetGasMdTypeBriefNm(const TGasMdType& GasMdType){
915    switch (GasMdType){
916      case gmtCTb: return "ContTb";
917      case gmtLr: return "SVD";
918      case gmtNNbr: return "NNbr";
919      case gmtSvm: return "SVM";
920      case gmtCubist: return "Cubist";
921      case gmtRegTree: return "RTree";
922      case gmtEnsemble: return "Ensemble";
923      default: Fail; return TStr();
924    }
925  }
926  TStr TGasMd::GetMdParamStr(){
927    return
928     "<Model>"
929     "  <ContTable><Moment>Median</Moment></ContTable>"
930     "  <NNbr><K>5</K></NNbr>"
931     "  <Cubist><FileId>CubistData</FileId></Cubist>"
932     "  <Svm><FileId>SvmData</FileId></Svm>"
933     "  <RegTree><MnLeafExs>5</MnLeafExs></RegTree>"
934     "</Model>";
935  }
936  PGasMd TGasMdEnsemble::New(
937   const PGasMdMType& GasMdMType, const TStr& ParamStr, const PGasDm& GasDm,
938   const TSecTm& StartDate, const TSecTm& EndDate,
939   const int& StartRecN, const int& EndRecN, const double& MnCspt){
940    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
941    TGasMdEnsemble* GasMdEnsemble=new TGasMdEnsemble(GasDmHd, GasMdMType);
942    PGasMd GasMd(GasMdEnsemble);
943    for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
944      TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
945      PGasMd SubGasMd=TGasMd::New(GasMdType, NULL, ParamStr, GasDm, StartDate, EndDate, StartRecN, EndRecN, MnCspt);
946      GasMdEnsemble->GasMdV.Add(SubGasMd);
947    }
948    return GasMd;
949  }
950  double TGasMdEnsemble::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
951    IAssert(GetGasDmHd()->IsCompatible(GasDm));
952    double PredClassVal=0;
953    for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
954      double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
955      PGasMd SubGasMd=GasMdV[MdTypeN];
956      PredClassVal+=GasMdWgt*SubGasMd->GetPredClassVal(GasDm, RecN);
957    }
958    return PredClassVal;
959  }
960  PMom TGasMdEnsemble::GetClassValMom() const {
961    return GasMdV[0]->GetClassValMom();
962  }
963  void TGasMdEnsemble::Print() const {
964    if (GasMdMType->GetMdTypes()==1){
965      GasMdV[0]->Print();
966    } else {
967      printf("==========================================================\n");
968      printf("ClassVal: %s\n", GetClassValMom()->GetStr(' ', ':', true).CStr());
969      printf("ClassVal =\n");
970      for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
971        TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
972        double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
973        printf("    + %g * %s\n", GasMdWgt, TGasMd::GetGasMdTypeNm(GasMdType).CStr());
974      }
975      printf("\n");
976    }
977  }
978  PGasMd TGasMdCTb::New(const TStr& ParamStr, const PGasDm& GasDm,
979   const TSecTm& StartDate, const TSecTm& EndDate,
980   const int& StartRecN, const int& EndRecN, const double& MnCspt){
981    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
982    TGasMdCTb* GasMdCTb=new TGasMdCTb(GasDmHd); PGasMd GasMd(GasMdCTb);
983    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
984    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
985    GasMdCTb->MomNm=ParamXmlDoc->GetTagTokStr("Model|ContTable|Moment");
986    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
987    int Recs=RecNV.Len();
988    GasMdCTb->HourAttrN=GasDm->GetAttrN("Hour");
989    GasMdCTb->DowAttrN=GasDm->GetAttrN("Dow");
990    GasMdCTb->MonthAttrN=GasDm->GetAttrN("Month");
991    GasMdCTb->ClassValMom=TMom::New();
992    TMom::NewV(GasMdCTb->HourMomV, 24);
993    TMom::NewV(GasMdCTb->DowMomV, 7);
994    TMom::NewV(GasMdCTb->MonthMomV, 12);
995    TMom::NewVV(GasMdCTb->DowHourMomVV, 7, 24);
996    for (int RecNN=0; RecNN<Recs; RecNN++){
997      int RecN=RecNV[RecNN];
998      double ClassVal=GasDm->GetClassVal(RecN);
999      int HourN, DowN, MonthN;
1000      if (GasMdCTb->HourAttrN!=-1){HourN=GasDm->GetAttrVal(RecN, GasMdCTb->HourAttrN, 0);}
1001      if (GasMdCTb->DowAttrN!=-1){DowN=GasDm->GetAttrVal(RecN, GasMdCTb->DowAttrN, 0)-1;}
1002      if (GasMdCTb->MonthAttrN!=-1){MonthN=GasDm->GetAttrVal(RecN, GasMdCTb->MonthAttrN, 0)-1;}
1003      GasMdCTb->ClassValMom->Add(ClassVal);
1004      if (GasMdCTb->HourAttrN!=-1){
1005        GasMdCTb->HourMomV[HourN]->Add(ClassVal);}
1006      if (GasMdCTb->DowAttrN!=-1){
1007        GasMdCTb->DowMomV[DowN]->Add(ClassVal);}
1008      if (GasMdCTb->MonthAttrN!=-1){
1009        GasMdCTb->MonthMomV[MonthN]->Add(ClassVal);}
1010      if ((GasMdCTb->DowAttrN!=-1)&&(GasMdCTb->HourAttrN!=-1)){
1011        GasMdCTb->DowHourMomVV.At(DowN, HourN)->Add(ClassVal);}
1012    }
1013    GasMdCTb->ClassValMom->Def();
1014    TMom::DefV(GasMdCTb->HourMomV);
1015    TMom::DefV(GasMdCTb->DowMomV);
1016    TMom::DefV(GasMdCTb->MonthMomV);
1017    TMom::DefVV(GasMdCTb->DowHourMomVV);
1018    return GasMd;
1019  }
1020  double TGasMdCTb::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1021    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1022    int HourN, DowN, MonthN;
1023    if (HourAttrN!=-1){HourN=GasDm->GetAttrVal(RecN, HourAttrN, 0);}
1024    if (DowAttrN!=-1){DowN=GasDm->GetAttrVal(RecN, DowAttrN, 0)-1;}
1025    if (MonthAttrN!=-1){MonthN=GasDm->GetAttrVal(RecN, MonthAttrN, 0)-1;}
1026    PMom Mom1; PMom Mom2;
1027    if ((HourAttrN!=-1)&&(DowAttrN!=-1)){
1028      Mom1=DowHourMomVV.At(DowN, HourN);
1029    } else
1030    if ((DowAttrN!=-1)&&(MonthAttrN!=-1)){
1031      Mom1=DowMomV[DowN];
1032    } else
1033    if (HourAttrN!=-1){
1034      Mom1=HourMomV[HourN];
1035    } else
1036    if (DowAttrN!=-1){
1037      Mom1=DowMomV[DowN];
1038    } else
1039    if (MonthAttrN!=-1){
1040      Mom1=MonthMomV[MonthN];
1041    } else {
1042      Mom1=ClassValMom;
1043    }
1044    double PredClassVal=0;
1045    if (Mom1->IsUsable()){
1046      PredClassVal=Mom1->GetByNm(MomNm);
1047    }
1048    if ((!Mom2.Empty())&&(Mom2->IsUsable())){
1049      PredClassVal=0.5*PredClassVal+0.5*Mom2->GetByNm(MomNm);
1050    }
1051    return PredClassVal;
1052  }
1053  void TGasMdCTb::Print() const {
1054    printf("==========================================================\n");
1055    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1056    printf("per Hour:");
1057    for (int HourN=0; HourN<24; HourN++){
1058      printf(" [%d:%s]", HourN, HourMomV[HourN]->GetStrByNm(MomNm).CStr());}
1059    printf("\n");
1060    printf("per Day-Of-Week:");
1061    for (int DowN=0; DowN<7; DowN++){
1062      printf(" [%s:%s]", TTmInfo::GetDayOfWeekNm(DowN+1).CStr(),
1063       DowMomV[DowN]->GetStrByNm(MomNm).CStr());
1064    }
1065    printf("\n");
1066    printf("per Month:");
1067    for (int MonthN=0; MonthN<12; MonthN++){
1068      printf(" [%s:%s]", TTmInfo::GetMonthNm(MonthN+1).CStr(),
1069       MonthMomV[MonthN]->GetStrByNm(MomNm).CStr());
1070    }
1071    printf("\n");
1072  }
1073  PGasMd TGasMdSvd::New(const TStr& ParamStr, const PGasDm& GasDm,
1074   const TSecTm& StartDate, const TSecTm& EndDate,
1075   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1076    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1077    TGasMdSvd* GasMdSvd=new TGasMdSvd(GasDmHd); PGasMd GasMd(GasMdSvd);
1078    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1079    int Attrs=GasDm->GetAttrs(); int Recs=RecNV.Len();
1080    TFltVV XVV(Recs, Attrs); TFltV YV(Recs); GasMdSvd->ClassValMom=TMom::New();
1081    for (int RecNN=0; RecNN<Recs; RecNN++){
1082      int RecN=RecNV[RecNN];
1083      double ClassVal=GasDm->GetClassVal(RecN);
1084      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1085      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1086        XVV.At(RecNN, AttrN)=AttrValV[AttrN];
1087      }
1088      YV[RecNN]=ClassVal;
1089      GasMdSvd->ClassValMom->Add(ClassVal);
1090    }
1091    GasMdSvd->ClassValMom->Def();
1092    PSvd Svd=TSvd::New(XVV, YV);
1093    Svd->GetCfV(GasMdSvd->CfV);
1094    Svd->GetCfUncerV(GasMdSvd->CfUncerV);
1095    GasMdSvd->ChiSq=Svd->GetChiSq();
1096    return GasMd;
1097  }
1098  double TGasMdSvd::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1099    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1100    double PredClassVal=0;
1101    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1102    IAssert(AttrValV.Len()==CfV.Len());
1103    for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1104      PredClassVal+=CfV[AttrN]*AttrValV[AttrN];
1105    }
1106    return PredClassVal;
1107  }
1108  void TGasMdSvd::Print() const {
1109    printf("==========================================================\n");
1110    PGasDmHd GasDmHd=GetGasDmHd();
1111    TStrV AttrNmV; GasDmHd->GetAttrNmV(AttrNmV);
1112    TStr ClassNm=GasDmHd->GetClassNm();
1113    printf("%s = ", ClassNm.CStr());
1114    IAssert((AttrNmV.Len()==CfV.Len())&&(AttrNmV.Len()==CfUncerV.Len()));
1115    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1116      printf("\t%+g * %s\n", CfV[AttrN](), AttrNmV[AttrN].CStr());
1117    }
1118    printf("\n");
1119    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1120  }
1121  PGasMd TGasMdNNbr::New(const TStr& ParamStr, const PGasDm& GasDm,
1122   const TSecTm& StartDate, const TSecTm& EndDate,
1123   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1124    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1125    TGasMdNNbr* GasMdNNbr=new TGasMdNNbr(GasDmHd); PGasMd GasMd(GasMdNNbr);
1126    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1127    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1128    GasMdNNbr->NNbrs=ParamXmlDoc->GetTagTokStr("Model|NNbr|K").GetInt();
1129    IAssert(GasMdNNbr->NNbrs>0);
1130    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1131    int Attrs=GasDm->GetAttrs(); int Recs=RecNV.Len();
1132    GasMdNNbr->AttrValVV.Gen(Recs); TMom::NewV(GasMdNNbr->AttrValMomV, Attrs);
1133    GasMdNNbr->ClassValV.Gen(Recs); GasMdNNbr->ClassValMom=TMom::New();
1134    for (int RecNN=0; RecNN<Recs; RecNN++){
1135      int RecN=RecNV[RecNN];
1136      TFltV& AttrValV=GasMdNNbr->AttrValVV[RecNN];
1137      GasDm->GetAttrValV(RecN, AttrValV);
1138      for (int AttrN=0; AttrN<Attrs; AttrN++){
1139        GasMdNNbr->AttrValMomV[AttrN]->Add(AttrValV[AttrN]);}
1140      double ClassVal=GasDm->GetClassVal(RecN);
1141      GasMdNNbr->ClassValV[RecNN]=ClassVal;
1142      GasMdNNbr->ClassValMom->Add(ClassVal);
1143    }
1144    TMom::DefV(GasMdNNbr->AttrValMomV);
1145    GasMdNNbr->ClassValMom->Def();
1146    return GasMd;
1147  }
1148  double TGasMdNNbr::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1149    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1150    TFltIntKdV DistRecNKdV;
1151    TFltV PredAttrValV; GasDm->GetAttrValV(RecN, PredAttrValV);
1152    for (int AttrValVN=0; AttrValVN<AttrValVV.Len(); AttrValVN++){
1153      TFltV& DmAttrValV=AttrValVV[AttrValVN];
1154      double Dist=0;
1155      for (int AttrN=0; AttrN<PredAttrValV.Len(); AttrN++){
1156        double AttrValDist=PredAttrValV[AttrN]-DmAttrValV[AttrN];
1157        double AttrNrmVal=AttrValMomV[AttrN]->GetMedian();
1158        if (AttrNrmVal!=0){AttrValDist=AttrValDist/AttrNrmVal;}
1159        Dist+=TMath::Sqr(AttrValDist);
1160      }
1161      Dist=sqrt(Dist);
1162      TFltIntKd DistRecNKd(Dist, AttrValVN);
1163      DistRecNKdV.AddSorted(DistRecNKd, true, NNbrs);
1164    }
1165    double PredClassVal=0;
1166    for (int DistRecNKdN=0; DistRecNKdN<DistRecNKdV.Len(); DistRecNKdN++){
1167      int RecN=DistRecNKdV[DistRecNKdN].Dat;
1168      double ClassVal=ClassValV[RecN];
1169      PredClassVal+=ClassVal;
1170    }
1171    if (DistRecNKdV.Len()>0){
1172      PredClassVal=PredClassVal/DistRecNKdV.Len();}
1173    return PredClassVal;
1174  }
1175  TStr TGasMdNNbr::GetPredExpl(const PGasDm& GasDm, const int& RecN) const {
1176    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1177    TFltIntKdV DistRecNKdV;
1178    TFltV PredAttrValV; GasDm->GetAttrValV(RecN, PredAttrValV);
1179    for (int AttrValVN=0; AttrValVN<AttrValVV.Len(); AttrValVN++){
1180      TFltV& DmAttrValV=AttrValVV[AttrValVN];
1181      double Dist=0;
1182      for (int AttrN=0; AttrN<PredAttrValV.Len(); AttrN++){
1183        double AttrValDist=PredAttrValV[AttrN]-DmAttrValV[AttrN];
1184        double AttrNrmVal=AttrValMomV[AttrN]->GetMedian();
1185        if (AttrNrmVal!=0){AttrValDist=AttrValDist/AttrNrmVal;}
1186        Dist+=TMath::Sqr(AttrValDist);
1187      }
1188      Dist=sqrt(Dist);
1189      TFltIntKd DistRecNKd(Dist, AttrValVN);
1190      DistRecNKdV.AddSorted(DistRecNKd, true, NNbrs);
1191    }
1192    TChA PredExplChA;
1193    return PredExplChA;
1194  }
1195  void TGasMdNNbr::Print() const {
1196    printf("==========================================================\n");
1197    printf("Nearest-Neigbours Window-Size: %d\n", NNbrs);
1198    printf("Records: %d\n", AttrValVV.Len());
1199    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1200  }
1201  PGasMd TGasMdCubist::New(
1202   const TStr& ParamStr, const PGasDm& GasDm,
1203   const TSecTm& StartDate, const TSecTm& EndDate,
1204   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1205    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1206    TGasMdCubist* GasMdCubist=new TGasMdCubist(GasDmHd); PGasMd GasMd(GasMdCubist);
1207    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1208    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1209    GasMdCubist->IdFNm=ParamXmlDoc->GetTagTokStr("Model|Cubist|FileId");
1210    TStr IdFNm=GasMdCubist->IdFNm;
1211    PSOut NamesSOut=TFOut::New(IdFNm+".names");
1212    NamesSOut->PutStr(GasDm->GetClassNm()); NamesSOut->PutStr(".\n\n");
1213    NamesSOut->PutStr(GasDm->GetClassNm()); NamesSOut->PutStr(": ");
1214    NamesSOut->PutStr("continuous");
1215    NamesSOut->PutStr(".\n");
1216    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1217    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1218      NamesSOut->PutStr(AttrNmV[AttrN]); NamesSOut->PutStr(": ");
1219      if (AttrNmV[AttrN]=="Dow"){
1220        for (int DowN=0; DowN<7; DowN++){
1221          if (DowN>0){NamesSOut->PutStr(",");}
1222          NamesSOut->PutStr(TTmInfo::GetDayOfWeekNm(DowN+1));
1223        }
1224      } else
1225      if (AttrNmV[AttrN]=="Month"){
1226        for (int MonthN=0; MonthN<12; MonthN++){
1227          if (MonthN>0){NamesSOut->PutStr(",");}
1228          NamesSOut->PutStr(TTmInfo::GetMonthNm(MonthN+1));
1229        }
1230      } else {
1231        NamesSOut->PutStr("continuous");
1232      }
1233      NamesSOut->PutStr(".\n");
1234    }
1235    NamesSOut=NULL;
1236    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1237    int Recs=RecNV.Len();
1238    PSOut DataSOut=TFOut::New(IdFNm+".data");
1239    GasMdCubist->ClassValMom=TMom::New();
1240    for (int RecNN=0; RecNN<Recs; RecNN++){
1241      int RecN=RecNV[RecNN];
1242      double ClassVal=GasDm->GetClassVal(RecN);
1243      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1244      GasMdCubist->ClassValMom->Add(ClassVal);
1245      DataSOut->PutFlt(ClassVal);
1246      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1247        DataSOut->PutStr(",");
1248        if (AttrNmV[AttrN]=="Dow"){
1249          DataSOut->PutStr(TTmInfo::GetDayOfWeekNm(AttrValV[AttrN]));
1250        } else
1251        if (AttrNmV[AttrN]=="Month"){
1252          DataSOut->PutStr(TTmInfo::GetMonthNm(AttrValV[AttrN]));
1253        } else {
1254          DataSOut->PutFlt(AttrValV[AttrN]);
1255        }
1256      }
1257      DataSOut->PutStr("\n");
1258    }
1259    GasMdCubist->ClassValMom->Def();
1260    DataSOut=NULL;
1261    TFile::Del(IdFNm+".model", false);
1262    TStr CubistCmLn=TStr("CubistX.exe -f ")+IdFNm&bsol;*+" "+OptStr*/;
1263    system(CubistCmLn.CStr());
1264    {PSIn NamesSIn=TFIn::New(IdFNm+".names");
1265    GasMdCubist->NamesFileStr=TStr(NamesSIn);}
1266    {PSIn DataSIn=TFIn::New(IdFNm+".data");
1267    GasMdCubist->DataFileStr=TStr(DataSIn);}
1268    {PSIn ModelSIn=TFIn::New(IdFNm+".model");
1269    GasMdCubist->ModelFileStr=TStr(ModelSIn);}
1270    TFile::Del(IdFNm+".names", false);
1271    TFile::Del(IdFNm+".data", false);
1272    TFile::Del(IdFNm+".model", false);
1273    return GasMd;
1274  }
1275  double TGasMdCubist::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1276    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1277    {PSOut NamesSOut=TFOut::New(IdFNm+".names");
1278    NamesSOut->PutStr(NamesFileStr);}
1279    {PSOut DataSOut=TFOut::New(IdFNm+".data");
1280    DataSOut->PutStr(DataFileStr);}
1281    {PSOut ModelSOut=TFOut::New(IdFNm+".model");
1282    ModelSOut->PutStr(ModelFileStr);}
1283    PSOut CasesSOut=TFOut::New(IdFNm+".cases");
1284    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1285    double ClassVal=GasDm->GetClassVal(RecN);
1286    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1287    CasesSOut->PutFlt(ClassVal);
1288    for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1289      CasesSOut->PutStr(",");
1290      if (AttrNmV[AttrN]=="Dow"){
1291        CasesSOut->PutStr(TTmInfo::GetDayOfWeekNm(AttrValV[AttrN]));
1292      } else
1293      if (AttrNmV[AttrN]=="Month"){
1294        CasesSOut->PutStr(TTmInfo::GetMonthNm(AttrValV[AttrN]));
1295      } else {
1296        CasesSOut->PutFlt(AttrValV[AttrN]);
1297      }
1298    }
1299    CasesSOut->PutStr("\n");
1300    CasesSOut=NULL;
1301    TFile::Del(IdFNm+".xml", false);
1302    TStr CubistCmLn=TStr("CubistC.exe -f ")+IdFNm;
1303    system(CubistCmLn.CStr());
1304    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(IdFNm+".xml");
1305    TStr PredClassValStr=XmlDoc->GetTagTokStr("Prediction|Predicted");
1306    double PredClassVal=PredClassValStr.GetFlt();
1307    TFile::Del(IdFNm+".names", false);
1308    TFile::Del(IdFNm+".data", false);
1309    TFile::Del(IdFNm+".model", false);
1310    TFile::Del(IdFNm+".cases", false);
1311    TFile::Del(IdFNm+".xml", false);
1312    return PredClassVal;
1313  }
1314  void TGasMdCubist::Print() const {
1315    printf("==========================================================\n");
1316    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1317  }
1318  PGasMd TGasMdSvm::New(const TStr& ParamStr, const PGasDm& GasDm,
1319   const TSecTm& StartDate, const TSecTm& EndDate,
1320   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1321    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1322    TGasMdSvm* GasMdSvm=new TGasMdSvm(GasDmHd); PGasMd GasMd(GasMdSvm);
1323    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1324    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1325    GasMdSvm->IdFNm=ParamXmlDoc->GetTagTokStr("Model|Svm|FileId");
1326    TStr IdFNm=GasMdSvm->IdFNm;
1327    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1328    int Recs=RecNV.Len();
1329    PSOut TrainSOut=TFOut::New(IdFNm+".train");
1330    TrainSOut->PutStr("# ");
1331    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1332    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1333      TrainSOut->PutStr(AttrNmV[AttrN]); TrainSOut->PutStr(" ");}
1334    TrainSOut->PutStr(GasDm->GetClassNm());
1335    TrainSOut->PutStr("\n");
1336    TrainSOut->PutStr("@examples\n");
1337    TrainSOut->PutStr("dimension "); TrainSOut->PutInt(AttrNmV.Len()); TrainSOut->PutStr("\n");
1338    TrainSOut->PutStr("format xy\n");
1339    GasMdSvm->ClassValMom=TMom::New();
1340    for (int RecNN=0; RecNN<Recs; RecNN++){
1341      int RecN=RecNV[RecNN];
1342      double ClassVal=GasDm->GetClassVal(RecN);
1343      TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1344      GasMdSvm->ClassValMom->Add(ClassVal);
1345      for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1346        TrainSOut->PutFlt(AttrValV[AttrN]);
1347        TrainSOut->PutStr(" ");
1348      }
1349      TrainSOut->PutFlt(ClassVal);
1350      TrainSOut->PutStr("\n");
1351    }
1352    GasMdSvm->ClassValMom->Def();
1353    TrainSOut=NULL;
1354    PSOut ParamSOut=TFOut::New(IdFNm+".param");
1355    ParamSOut->PutStr("@kernel\n");
1356    ParamSOut->PutStr("type dot\n");
1357    ParamSOut->PutStr("@parameters\n");
1358    ParamSOut->PutStr("C 1000\n");
1359    ParamSOut->PutStr("epsilon 0.1\n");
1360    ParamSOut=NULL;
1361    TFile::Del(IdFNm+".train.svm", false);
1362    TStr SvmCmLn=TStr("MySvmLearn.exe ")+IdFNm+".train "+IdFNm+".param";
1363    system(SvmCmLn.CStr());
1364    {PSIn ModelSIn=TFIn::New(IdFNm+".train.svm");
1365    GasMdSvm->ModelFileStr=TStr(ModelSIn);}
1366    TFile::Del(IdFNm+".train", false);
1367    TFile::Del(IdFNm+".param", false);
1368    TFile::Del(IdFNm+".train.svm", false);
1369    return GasMd;
1370  }
1371  double TGasMdSvm::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1372    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1373    {PSOut ModelSOut=TFOut::New(IdFNm+".train.svm");
1374    ModelSOut->PutStr(ModelFileStr);}
1375    PSOut TestSOut=TFOut::New(IdFNm+".test");
1376    TestSOut->PutStr("# ");
1377    TStrV AttrNmV; GasDm->GetAttrNmV(AttrNmV);
1378    for (int AttrN=0; AttrN<AttrNmV.Len(); AttrN++){
1379      TestSOut->PutStr(AttrNmV[AttrN]); TestSOut->PutStr(" ");}
1380    TestSOut->PutStr(GasDm->GetClassNm());
1381    TestSOut->PutStr("\n");
1382    TestSOut->PutStr("@examples\n");
1383    TestSOut->PutStr("dimension "); TestSOut->PutInt(AttrNmV.Len()); TestSOut->PutStr("\n");
1384    TestSOut->PutStr("format xy\n");
1385    double ClassVal=GasDm->GetClassVal(RecN);
1386    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1387    {for (int AttrN=0; AttrN<AttrValV.Len(); AttrN++){
1388      TestSOut->PutFlt(AttrValV[AttrN]);
1389      TestSOut->PutStr(" ");
1390    }}
1391    TestSOut->PutFlt(ClassVal);
1392    TestSOut->PutStr("\n");
1393    TestSOut=NULL;
1394    PSOut ParamSOut=TFOut::New(IdFNm+".param");
1395    ParamSOut->PutStr("@kernel\n");
1396    ParamSOut->PutStr("type dot\n");
1397    ParamSOut->PutStr("@parameters\n");
1398    ParamSOut->PutStr("C 1000\n");
1399    ParamSOut->PutStr("epsilon 0.1\n");
1400    ParamSOut=NULL;
1401    TFile::Del(IdFNm+"test.pred", false);
1402    TStr SvmCmLn=TStr("MySvmPredict.exe ")+
1403     IdFNm+".train.svm "+IdFNm+".test "+IdFNm+".param";
1404    system(SvmCmLn.CStr());
1405    PSIn PredSIn=TFIn::New(IdFNm+".test.pred");
1406    TILx PredLx(PredSIn, TFSet()|iloRetEoln|iloSigNum);
1407    PredLx.GetSym(syLn);
1408    double PredClassVal=PredLx.GetFlt();
1409    TFile::Del(IdFNm+".train.svm", false);
1410    TFile::Del(IdFNm+".test", false);
1411    TFile::Del(IdFNm+".param", false);
1412    TFile::Del(IdFNm+".test.pred", false);
1413    return PredClassVal;
1414  }
1415  void TGasMdSvm::Print() const {
1416    printf("==========================================================\n");
1417    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1418  }
1419  PGasRegNd TGasRegNd::New(const int& MnLeafExs,
1420   const TVec<TFltV>& AttrValVV, const TFltV& ClassValV, const TIntV& ExNV){
1421    IAssert(ExNV.Len()>0);
1422    PGasRegNd RegNd=PGasRegNd(new TGasRegNd());
1423    RegNd->ClassValMom=TMom::New();
1424    for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1425      RegNd->ClassValMom->Add(ClassValV[ExNV[ExNN]]);}
1426    RegNd->ClassValMom->Def();
1427    if (ExNV.Len()<MnLeafExs){
1428      return RegNd;}
1429    int MnSubRegNdExs=TInt::GetMx(ExNV.Len()/10, MnLeafExs);
1430    double BestSplitQual=-1;
1431    int BestSplitAttrN=-1; double BestSplitAttrVal=0;
1432    TIntV BestLExNV; TIntV BestRExNV;
1433    int Attrs=AttrValVV[0].Len();
1434    for (int SplitAttrN=0; SplitAttrN<Attrs; SplitAttrN++){
1435      TFltV SplitValV; PMom SplitValMom=TMom::New();
1436      for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1437        double AttrVal=AttrValVV[ExNV[ExNN]][SplitAttrN];
1438        SplitValV.Add(AttrVal); SplitValMom->Add(AttrVal);
1439      }
1440      SplitValV.Sort(); SplitValMom->Def();
1441      double MnSplitValResol=
1442       (SplitValMom->GetQuart3()-SplitValMom->GetQuart1())/100;
1443      double PrevSplitVal;
1444      for (int SplitValN=1; SplitValN<SplitValV.Len()-1; SplitValN++){
1445        double SplitVal=SplitValV[SplitValN];
1446        if ((SplitValN>1)&&(SplitVal-PrevSplitVal<=MnSplitValResol)){continue;}
1447        PrevSplitVal=SplitVal;
1448        PMom LClassValMom=TMom::New(); TIntV LExNV;
1449        PMom RClassValMom=TMom::New(); TIntV RExNV;
1450        for (int ExNN=0; ExNN<ExNV.Len(); ExNN++){
1451          int ExN=ExNV[ExNN];
1452          double AttrVal=AttrValVV[ExN][SplitAttrN];
1453          if (AttrVal<SplitVal){
1454            LClassValMom->Add(ClassValV[ExN]); LExNV.Add(ExN);
1455          } else {
1456            RClassValMom->Add(ClassValV[ExN]); RExNV.Add(ExN);
1457          }
1458        }
1459        LClassValMom->Def(); RClassValMom->Def();
1460        if ((LClassValMom->IsUsable()&&RClassValMom->IsUsable())&&
1461         (LExNV.Len()>MnSubRegNdExs)&&(RExNV.Len()>MnSubRegNdExs)){
1462          double SplitQual=
1463           TMath::Sqr(LClassValMom->GetSDev()*LExNV.Len())+
1464           TMath::Sqr(RClassValMom->GetSDev()*RExNV.Len());
1465          if ((BestSplitQual==-1)||(SplitQual<BestSplitQual)){
1466            BestSplitQual=SplitQual;
1467            BestSplitAttrN=SplitAttrN; BestSplitAttrVal=SplitVal;
1468            BestLExNV=LExNV; BestRExNV=RExNV;
1469          }
1470        }
1471      }
1472    }
1473    if (BestSplitQual!=-1){
1474      RegNd->SplitQual=BestSplitQual;
1475      RegNd->SplitAttrN=BestSplitAttrN;
1476      RegNd->SplitAttrVal=BestSplitAttrVal;
1477      if ((BestLExNV.Len()>0)&&(BestRExNV.Len()>0)){
1478        RegNd->LRegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, BestLExNV);
1479        RegNd->RRegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, BestRExNV);
1480      }
1481    }
1482    printf(".");
1483    return RegNd;
1484  }
1485  double TGasRegNd::GetPredClassVal(const TFltV& AttrValV) const {
1486    if (IsLeaf()){
1487      return ClassValMom->GetMedian();
1488    } else {
1489      if (AttrValV[SplitAttrN]<SplitAttrVal){
1490        return LRegNd->GetPredClassVal(AttrValV);
1491      } else {
1492        return RRegNd->GetPredClassVal(AttrValV);
1493      }
1494    }
1495  }
1496  void TGasRegNd::Print(const PGasDmHd& GasDmHd, const int& Levs) const {
1497    if (IsLeaf()){
1498      for (int LevN=0; LevN<Levs; LevN++){printf("   ");}
1499      printf("%s=%g(%g) [%d Exs.]\n",
1500       GasDmHd->GetClassNm().CStr(),
1501       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1502    } else {
1503      for (int LevN=0; LevN<Levs; LevN++){printf("   ");}
1504      printf("%s <  %g [%s=%g(%g)] [%d Exs.]\n",
1505       GasDmHd->GetAttrNm(SplitAttrN).CStr(), SplitAttrVal,
1506       GasDmHd->GetClassNm().CStr(),
1507       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1508      LRegNd->Print(GasDmHd, Levs+1);
1509      {for (int LevN=0; LevN<Levs; LevN++){printf("   ");}}
1510      printf("%s >= %g [%s=%g(%g)] [%d Exs.]\n",
1511       GasDmHd->GetAttrNm(SplitAttrN).CStr(), SplitAttrVal,
1512       GasDmHd->GetClassNm().CStr(),
1513       ClassValMom->GetMean(), ClassValMom->GetSDev(), ClassValMom->GetVals());
1514      RRegNd->Print(GasDmHd, Levs+1);
1515    }
1516  }
1517  PGasMd TGasMdRegTree::New(const TStr& ParamStr, const PGasDm& GasDm,
1518   const TSecTm& StartDate, const TSecTm& EndDate,
1519   const int& StartRecN, const int& EndRecN, const double& MnCspt){
1520    PGasDmHd GasDmHd=TGasDmHd::New(GasDm);
1521    TGasMdRegTree* GasMdRegTree=new TGasMdRegTree(GasDmHd); PGasMd GasMd(GasMdRegTree);
1522    PSIn ParamXmlSIn=TStrIn::New(ParamStr);
1523    PXmlDoc ParamXmlDoc=TXmlDoc::LoadTxt(ParamXmlSIn);
1524    int MnLeafExs=ParamXmlDoc->GetTagTokStr("Model|RegTree|MnLeafExs").GetInt();
1525    TIntV RecNV; GasDm->GetRecNV(StartDate, EndDate, StartRecN, EndRecN, MnCspt, RecNV);
1526     int Recs=RecNV.Len();
1527    TVec<TFltV> AttrValVV(Recs);
1528    TFltV ClassValV(Recs); GasMdRegTree->ClassValMom=TMom::New();
1529    for (int RecNN=0; RecNN<Recs; RecNN++){
1530      int RecN=RecNV[RecNN];
1531      TFltV& AttrValV=AttrValVV[RecNN];
1532      GasDm->GetAttrValV(RecN, AttrValV);
1533      double ClassVal=GasDm->GetClassVal(RecN);
1534      ClassValV[RecNN]=ClassVal;
1535      GasMdRegTree->ClassValMom->Add(ClassVal);
1536    }
1537    GasMdRegTree->ClassValMom->Def();
1538    int AllExs=AttrValVV.Len();
1539    TIntV AllExNV(AllExs); for (int ExN=0; ExN<AllExs; ExN++){AllExNV[ExN]=ExN;}
1540    GasMdRegTree->RegNd=TGasRegNd::New(MnLeafExs, AttrValVV, ClassValV, AllExNV);
1541    return GasMd;
1542  }
1543  double TGasMdRegTree::GetPredClassVal(const PGasDm& GasDm, const int& RecN) const {
1544    IAssert(GetGasDmHd()->IsCompatible(GasDm));
1545    TFltV AttrValV; GasDm->GetAttrValV(RecN, AttrValV);
1546    double PredClassVal=RegNd->GetPredClassVal(AttrValV);
1547    return PredClassVal;
1548  }
1549  void TGasMdRegTree::Print() const {
1550    printf("==========================================================\n");
1551    printf("ClassVal: %s\n", ClassValMom->GetStr(' ', ':', true).CStr());
1552    RegNd->Print(GasDmHd);
1553  }
1554  TGasMdCor::TGasMdCor(const TStr& LtpFPath):
1555    DateProdNmToCorFactMomH(){
1556    TFFile FFile(LtpFPath, ".Ltp", false); TStr FNm;
1557    while (FFile.Next(FNm)){
1558      printf(".");
1559      PGasLtpBs GasLtpBs=TGasLtpBs::Load(FNm);
1560      TStr ProdNm=GasLtpBs->ProdNm;
1561      PGasDm GasDm=TGasDm::GetDayGasDm(GasLtpBs);
1562      TSecTm MnDate=GasLtpBs->GetMnDate();
1563      TSecTm MxDate=GasLtpBs->GetMxDate();
1564      PGasMd GasMd=TGasMd::New(
1565       gmtCTb, NULL, TGasMd::GetMdParamStr(), GasDm, MnDate, MxDate, -1, -1, 100);
1566      for (int RecN=0; RecN<GasDm->GetRecs(); RecN++){
1567        double Cspt=GasDm->GetClassVal(RecN);
1568        double PredCspt=GasMd->GetPredClassVal(GasDm, RecN);
1569        if (PredCspt==0){continue;}
1570        double CorFact=Cspt/PredCspt;
1571        TSecTm Date=GasDm->GetDateVal(RecN);
1572        TDateProdNmPr DateProdNmPr(Date, ProdNm);
1573        if (!DateProdNmToCorFactMomH.IsKey(DateProdNmPr)){
1574          DateProdNmToCorFactMomH.AddDat(DateProdNmPr, TMom::New());}
1575        DateProdNmToCorFactMomH.GetDat(DateProdNmPr)->Add(CorFact);
1576      }
1577    }
1578    for (int DateProdNmP=0; DateProdNmP<DateProdNmToCorFactMomH.Len(); DateProdNmP++){
1579      DateProdNmToCorFactMomH[DateProdNmP]->Def();}
1580  }
1581  double TGasMdCor::GetCorFact(const TSecTm& Date, const TStr& ProdNm) const {
1582    TDateProdNmPr DateProdNmPr(Date, ProdNm);
1583    int DateProdNmP;
1584    if (DateProdNmToCorFactMomH.IsKey(DateProdNmPr, DateProdNmP)){
1585      PMom CorFactMom=DateProdNmToCorFactMomH[DateProdNmP];
1586      if (CorFactMom->IsUsable()){
1587        return CorFactMom->GetMean();
1588      } else {
1589        return 1;
1590      }
1591    } else {
1592      return 1;
1593    }
1594  }
1595  void TGasMdCor::SaveTxt(const TStr& FNm) const {
1596    typedef TTriple<TSecTm, TStr, TInt> TDateProdNmIdTr;
1597    TVec<TDateProdNmIdTr> DateProdNmIdTrV;
1598    for (int DateProdNmP=0; DateProdNmP<DateProdNmToCorFactMomH.Len(); DateProdNmP++){
1599      TSecTm Date=DateProdNmToCorFactMomH.GetKey(DateProdNmP).Val1;
1600      TStr ProdNm=DateProdNmToCorFactMomH.GetKey(DateProdNmP).Val2;
1601      TDateProdNmIdTr DateProdNmIdTr(Date, ProdNm, DateProdNmP);
1602      DateProdNmIdTrV.Add(DateProdNmIdTr);
1603    }
1604    DateProdNmIdTrV.Sort();
1605    TFOut LogFOut(FNm); FILE* fLog=LogFOut.GetFileId();
1606    for (int DpiN=0; DpiN<DateProdNmIdTrV.Len(); DpiN++){
1607      TSecTm Date=DateProdNmIdTrV[DpiN].Val1;
1608      TStr ProdNm=DateProdNmIdTrV[DpiN].Val2;
1609      int DateProdNmP=DateProdNmIdTrV[DpiN].Val3;
1610      PMom CorFactMom=DateProdNmToCorFactMomH[DateProdNmP];
1611      fprintf(fLog, "%s - %-25s - %s\n",
1612       Date.GetDtStr().CStr(), ProdNm.CStr(),
1613       CorFactMom->GetStr(' ', ':', true).CStr());
1614    }
1615  }
1616  double TGasOrder::GetQuantity(const TSecTm& Dt, TGasOrderV& GasOrderV){
1617    double Quantity=0;
1618    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1619      if (GasOrderV[GasOrderN]->ReceiveDt==Dt){
1620        Quantity+=GasOrderV[GasOrderN]->Quantity;}
1621    }
1622    return Quantity;
1623  }
1624  double TGasOrder::GetQuantity(
1625   const TSecTm& MnTm, const TSecTm& MxTm, TGasOrderV& GasOrderV){
1626    double Quantity=0;
1627    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1628      TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1629      if ((MnTm<=ReceiveDt)&&(ReceiveDt<MxTm)){
1630        Quantity+=GasOrderV[GasOrderN]->Quantity;}
1631    }
1632    return Quantity;
1633  }
1634  void TGasOrder::DelOrders(const TSecTm& Dt, TGasOrderV& GasOrderV){
1635    PGasOrder GasOrder=TGasOrder::New(Dt, Dt, 0, false);
1636    GasOrderV.DelAll(GasOrder);
1637  }
1638  void TGasOrder::DelOrders(
1639   const TSecTm& MnTm, const TSecTm& MxTm, TGasOrderV& GasOrderV){
1640    for (int GasOrderN=GasOrderV.Len()-1; GasOrderN>=0; GasOrderN--){
1641      TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1642      if ((MnTm<=ReceiveDt)&&(ReceiveDt<MxTm)){
1643        GasOrderV.Del(GasOrderN);
1644      }
1645    }
1646  }
1647  void TGasOrder::DelUnapprovedOrders(
1648   const TSecTm& MnTm, TGasOrderV& GasOrderV, TStrV& MsgStrV){
1649    MsgStrV.Clr();
1650    for (int GasOrderN=GasOrderV.Len()-1; GasOrderN>=0; GasOrderN--){
1651      if (!GasOrderV[GasOrderN]->ApprovedP){
1652        TSecTm ReceiveDt=GasOrderV[GasOrderN]->ReceiveDt;
1653        if (MnTm<=ReceiveDt){
1654          MsgStrV.Add(GasOrderV[GasOrderN]->GetStr());
1655          GasOrderV.Del(GasOrderN);
1656        }
1657      }
1658    }
1659  }
1660  PGasOrder TGasOrder::LoadXml(const PXmlTok& XmlTok){
1661    TStr IssueDtStr=XmlTok->GetTagTokStr("IssueDate");
1662    TSecTm IssueDt=TSecTm::GetDtTmFromDmyStr(IssueDtStr);
1663    TStr ReceiveDtStr=XmlTok->GetTagTokStr("ReceiveDate");
1664    TSecTm ReceiveDt=TSecTm::GetDtTmFromDmyStr(ReceiveDtStr);
1665    TStr QuantityStr=XmlTok->GetTagTokStr("Quantity");
1666    double Quantity=QuantityStr.GetFlt(-1);
1667    PGasOrder GasOrder=TGasOrder::New(IssueDt, ReceiveDt, Quantity, true);
1668    return GasOrder;
1669  }
1670  void TGasOrder::SaveXml(const PSOut& SOut, const TStr& IndentStr) const {
1671    SOut->PutStr(IndentStr); SOut->PutStr("<GasOrder>\n");
1672    SOut->PutStr(IndentStr);
1673    SOut->PutStr(TStr::GetStr(IssueDt.GetDtMdyStr(), "  <IssueDate>%s</IssueDate>\n"));
1674    SOut->PutStr(IndentStr);
1675    SOut->PutStr(TStr::GetStr(ReceiveDt.GetDtMdyStr(), "  <ReceiveDate>%s</ReceiveDate>\n"));
1676    SOut->PutStr(IndentStr);
1677    SOut->PutStr(TFlt::GetStr(Quantity, "  <Quantity>%g</Quantity>\n"));
1678    SOut->PutStr(IndentStr); SOut->PutStr("</GasOrder>\n");
1679  }
1680  PGasStation TGasStation::LoadXml(const PXmlTok& XmlTok){
1681    PGasStation GasStation=TGasStation::New();
1682    GasStation->DescStr=XmlTok->GetTagTokStr("Description");
1683    GasStation->ProdNm=XmlTok->GetTagTokStr("Product");
1684    GasStation->FullVolumeVal=XmlTok->GetTagTokStr("FullVolume").GetFlt(-1);
1685    GasStation->SafetyVolumeVal=XmlTok->GetTagTokStr("SafetyVolume").GetFlt(-1);
1686    GasStation->DeliveryDays=XmlTok->GetTagTokStr("DeliveryDays").GetFlt(-1);
1687    GasStation->StockDurationDays=XmlTok->GetTagTokStr("StockDurationDays").GetFlt(-1);
1688    GasStation->OrderQuantityCorFact=XmlTok->GetTagTokStr("OrderQuantityCorrection").GetFlt(-1);
1689    GasStation->ExceptPredCorFact=XmlTok->GetTagTokStr("ExceptionPredictionCorrection").GetFlt(-1);
1690    GasStation->HistWnDays=XmlTok->GetTagTokStr("HistoryWindowDays").GetFlt(-1);
1691    GasStation->TmGridHours=XmlTok->GetTagTokStr("TimeGridHours").GetFlt(-1);
1692    GasStation->VolumeVal=XmlTok->GetTagTokStr("Volume").GetFlt(-1);
1693    TXmlTokV GasOrderXmlTokV;
1694    XmlTok->GetTagTokV("GasOrderList|GasOrder", GasOrderXmlTokV);
1695    GasStation->GasOrderV.Clr();
1696    for (int GasOrderN=0; GasOrderN<GasOrderXmlTokV.Len(); GasOrderN++){
1697      PGasOrder GasOrder=TGasOrder::LoadXml(GasOrderXmlTokV[GasOrderN]);
1698      GasStation->GasOrderV.Add(GasOrder);
1699    }
1700    return GasStation;
1701  }
1702  PGasStation TGasStation::LoadXml(const TStr& FNm){
1703    PSIn SIn=TFIn::New(FNm);
1704    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
1705    if (!XmlDoc->IsOk()){
1706      TExcept::Throw("Invalid Xml File", SIn->GetSNm());}
1707    return LoadXml(XmlDoc->GetTok());
1708  }
1709  void TGasStation::SaveXml(const PSOut& SOut) const {
1710    SOut->PutStr("<GasStation>\n");
1711    SOut->PutStr(TStr::GetStr(DescStr, "  <Description>%s</Description>\n"));
1712    SOut->PutStr(TStr::GetStr(ProdNm, "  <Product>%s</Product>\n"));
1713    SOut->PutStr(TFlt::GetStr(FullVolumeVal, "  <FullVolume>%g</FullVolume>\n"));
1714    SOut->PutStr(TFlt::GetStr(SafetyVolumeVal, "  <SafetyVolume>%g</SafetyVolume>\n"));
1715    SOut->PutStr(TInt::GetStr(DeliveryDays, "  <DeliveryDays>%d</DeliveryDays>\n"));
1716    SOut->PutStr(TInt::GetStr(StockDurationDays, "  <StockDurationDays>%d</StockDurationDays>\n"));
1717    SOut->PutStr(TFlt::GetStr(OrderQuantityCorFact, "  <OrderQuantityCorrection>%g</OrderQuantityCorrection>\n"));
1718    SOut->PutStr(TFlt::GetStr(ExceptPredCorFact, "  <ExceptionPredictionCorrection>%g</ExceptionPredictionCorrection>\n"));
1719    SOut->PutStr(TInt::GetStr(HistWnDays, "  <HistoryWindowDays>%d</HistoryWindowDays>\n"));
1720    SOut->PutStr(TInt::GetStr(TmGridHours, "  <TimeGridHours>%d</TimeGridHours>\n"));
1721    SOut->PutStr(TFlt::GetStr(VolumeVal, "  <Volume>%g</Volume>\n"));
1722    SOut->PutStr("  <NewGasOrderList>\n");
1723    for (int GasOrderN=0; GasOrderN<NewGasOrderV.Len(); GasOrderN++){
1724      NewGasOrderV[GasOrderN]->SaveXml(SOut, "    ");
1725    }
1726    SOut->PutStr("  </NewGasOrderList>\n");
1727    SOut->PutStr("</GasStation>\n");
1728  }
1729  void TGasStation::DumpDef(FILE* fOut) const {
1730    fprintf(fOut, "===GasStation-Start========\n");
1731    fprintf(fOut, "DescStr: %s\n", DescStr.CStr());
1732    fprintf(fOut, "ProdStr: %s\n", ProdNm.CStr());
1733    fprintf(fOut, "FullVolumeVal: %g\n", FullVolumeVal);
1734    fprintf(fOut, "SafetyVolumeVal: %g\n", SafetyVolumeVal);
1735    fprintf(fOut, "DeliveryDays: %d\n", DeliveryDays);
1736    fprintf(fOut, "StockDurationDays: %d\n", StockDurationDays);
1737    fprintf(fOut, "OrderQuantityCorFact: %g\n", OrderQuantityCorFact);
1738    fprintf(fOut, "ExceptPredCorFact: %g\n", ExceptPredCorFact);
1739    fprintf(fOut, "HistWnDays: %d\n", HistWnDays);
1740    fprintf(fOut, "TmGridHours: %d\n", TmGridHours);
1741    fprintf(fOut, "VolumeVal: %d\n", VolumeVal);
1742    fprintf(fOut, "GasOrderV: (%d)\n", GasOrderV.Len());
1743    for (int GasOrderN=0; GasOrderN<GasOrderV.Len(); GasOrderN++){
1744      fprintf(fOut, "  %s\n", GasOrderV[GasOrderN]->GetStr().CStr());}
1745    fprintf(fOut, "NewGasOrderV: (%d)\n", NewGasOrderV.Len());
1746    {for (int GasOrderN=0; GasOrderN<NewGasOrderV.Len(); GasOrderN++){
1747      fprintf(fOut, "  %s\n", NewGasOrderV[GasOrderN]->GetStr().CStr());}}
1748    fprintf(fOut, "===GasStation-End==========\n");
1749  }
1750  void TGasExe::GenPredEval(
1751   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
1752   const PGasMdCor& GasMdCor, const bool& UseMdCorP,
1753   const PGasDm& GasDm,
1754   const TSecTm& MnDate, const TSecTm& MxDate,
1755   const int& TrainWnLen, const int& TestWnLen, const int& WnStepLen,
1756   const double& MnCspt, const double& MnOutlierRelErr,
1757   const TStr& LogFNm, const int& LogVerbLev, const bool& AppendToLog,
1758   const TStr& TabLogFNm, const bool& AppendToTabLog,
1759   FILE* fOlap, const TStr& OlapPfxLn,
1760   TGasPredV& GasPredV,
1761   PMom& AllPredAbsErrMom, PMom& AllPredRelErrMom,
1762   const bool& PrintToScrP){
1763    TFOut LogFOut(LogFNm, AppendToLog); FILE* fLog=LogFOut.GetFileId();
1764    TFOut TabLogFOut(TabLogFNm, AppendToTabLog); FILE* fTabLog=TabLogFOut.GetFileId();
1765    TSecTm EvalStampTm=TSecTm::GetCurTm();
1766    fprintf(fLog, "===Start-Evaluation======================\n");
1767    fprintf(fLog, "Evaluation (%s)\n", EvalStampTm.GetStr().CStr());
1768    if (GasMdMType->GetMdTypes()==1){
1769      TGasMdType GasMdType=GasMdMType->GetMdType(0);
1770      fprintf(fLog, "Training algorithm '%s'\n", TGasMd::GetGasMdTypeNm(GasMdType).CStr());
1771    } else {
1772      for (int MdTypeN=0; MdTypeN<GasMdMType->GetMdTypes(); MdTypeN++){
1773        TGasMdType GasMdType=GasMdMType->GetMdType(MdTypeN);
1774        double GasMdWgt=GasMdMType->GetMdWgt(MdTypeN);
1775        fprintf(fLog, "Training algorithm '%s'(%g)\n", TGasMd::GetGasMdTypeNm(GasMdType).CStr(), GasMdWgt);
1776      }
1777    }
1778    fprintf(fLog, "Location/Tank/Product: %s\n", GasDm->GetDescStr().CStr());
1779    fprintf(fLog, "Min. Date: %s   Max. Date: %s\n", MnDate.GetDtStr().CStr(), MxDate.GetDtStr().CStr());
1780    fprintf(fLog, "Train Window: %d   Test Window: %d   Window Step: %d\n", TrainWnLen, TestWnLen, WnStepLen);
1781    fprintf(fLog, "Min. Consumption: %g\n", MnCspt);
1782    if (LogVerbLev>0){
1783      fprintf(fLog, "=========================================\n");}
1784    GasPredV.Clr();
1785    AllPredAbsErrMom=TMom::New();
1786    AllPredRelErrMom=TMom::New();
1787    TStrV OutlierStrV;
1788    for (TSecTm Date=MnDate; Date<MxDate; Date.AddDays(WnStepLen)){
1789      TSecTm StartDate=Date;
1790      TSecTm EndDate=TSecTm(Date).AddDays(TrainWnLen);
1791      TSecTm StartPredDate=TSecTm(Date).AddDays(TrainWnLen+1);
1792      TSecTm EndPredDate=TSecTm(Date).AddDays(TrainWnLen+1+TestWnLen-1);
1793      if (EndPredDate>=MxDate){continue;}
1794      TIntV TrainRecNV; GasDm->GetRecNV(StartDate, EndDate, -1, -1, MnCspt, TrainRecNV);
1795      int TrainRecs=TrainRecNV.Len();
1796      if (LogVerbLev>0){
1797        fprintf(fLog, "---Start-Window--------------------------\n");
1798        fprintf(fLog, "Training From %s   To %s (%d records)\n",
1799         StartDate.GetDtStr().CStr(), EndDate.GetDtStr().CStr(), TrainRecs);
1800        fprintf(fLog, "Testing  From %s   To %s\n",
1801         StartPredDate.GetDtStr().CStr(), EndPredDate.GetDtStr().CStr());
1802      }
1803      if (double(TrainRecs)<double(TrainWnLen)*0.5){continue;}
1804      PGasMd GasMd=TGasMd::New(gmtEnsemble, GasMdMType, GasMdParamStr, GasDm, StartDate, EndDate, -1, -1, MnCspt);
1805      if (PrintToScrP){GasMd->Print();}
1806      if (LogVerbLev>1){
1807        fprintf(fLog, ".........................................\n");}
1808      PMom PredAbsErrMom=TMom::New();
1809      PMom PredRelErrMom=TMom::New();
1810      PMom TestClassValMom=TMom::New();
1811      TIntV PredRecNV;
1812      GasDm->GetRecNV(StartPredDate, EndPredDate, -1, -1, MnCspt, PredRecNV);
1813      for (int PredRecNN=0; PredRecNN<PredRecNV.Len(); PredRecNN++){
1814        int RecN=PredRecNV[PredRecNN];
1815        TSecTm Date=GasDm->GetDateVal(RecN);
1816        TStr DateStr=Date.GetDtStr();
1817        int HourN=GasDm->GetAttrVal(RecN, "Hour", -1);
1818        double ClassVal=GasDm->GetClassVal(RecN);
1819        double PredClassVal=GasMd->GetCorPredClassVal(GasDm, RecN, 1.5);
1820        if (UseMdCorP){
1821          double CorFact=GasMdCor->GetCorFact(Date, GasDm->GetProdNm());
1822          PredClassVal=CorFact*PredClassVal;
1823        }
1824        double RawPredAbsErr=ClassVal-PredClassVal;
1825        double PredAbsErr=fabs(ClassVal-PredClassVal);
1826        double PredRelErr=0; double RawPredRelErr=0;
1827        if (ClassVal!=0){
1828          RawPredRelErr=(ClassVal-PredClassVal)/ClassVal;
1829          PredRelErr=fabs(RawPredRelErr);
1830        }
1831        PredAbsErrMom->Add(PredAbsErr); AllPredAbsErrMom->Add(PredAbsErr);
1832        PredRelErrMom->Add(PredRelErr); AllPredRelErrMom->Add(PredRelErr);
1833        TestClassValMom->Add(ClassVal);
1834        PGasPred GasPred=TGasPred::New();
1835        GasPred->CorrVal=ClassVal;
1836        GasPred->PredVal=PredClassVal;
1837        GasPred->AbsErr=RawPredAbsErr;
1838        GasPred->RelErr=RawPredRelErr;
1839        GasPred->Tm=GasDm->GetDateVal(RecN);
1840        GasPred->OutlierP=(PredRelErr>MnOutlierRelErr);
1841        GasPred->DescStr=GasDm->GetBitsStr(RecN);
1842        GasPredV.Add(GasPred);
1843        if (LogVerbLev>1){
1844          fprintf(fLog,
1845           "Correct: %g   Predicted: %g   Abs-Error: %g   Rel-Error: %g   Date: %s   Hour: %d",
1846           ClassVal, PredClassVal, RawPredAbsErr, PredRelErr, DateStr.CStr(), HourN);
1847          fprintf(fLog, "   Desc: {%s}", GasDm->GetBitsStr(RecN).CStr());
1848          if (PredRelErr>MnOutlierRelErr){fprintf(fLog, "   Outlier");}
1849          fprintf(fLog, "\n");
1850        }
1851        if (fOlap!=NULL){
1852          fprintf(fOlap, "%s%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
1853           OlapPfxLn.CStr(),
1854           Date.GetDtMdyStr().CStr(),
1855           TTmInfo::GetMonthNm(Date.GetMonthN()).CStr(),
1856           TTmInfo::GetDayOfWeekNm(Date.GetDayOfWeekN()).CStr(),
1857           TFlt::GetStr(ClassVal).CStr(),
1858           TFlt::GetStr(PredClassVal).CStr(),
1859           TFlt::GetStr(RawPredAbsErr).CStr(),
1860           TFlt::GetStr(PredRelErr).CStr());
1861        }
1862      }
1863      PredAbsErrMom->Def();
1864      PredRelErrMom->Def();
1865      TestClassValMom->Def();
1866      if (LogVerbLev>1){
1867        fprintf(fLog, ".........................................\n");}
1868      if (LogVerbLev>0){
1869        fprintf(fLog, "Train Class Stat.: %s\n", GasMd->GetClassValMom()->GetStr(' ', ':', true).CStr());
1870        fprintf(fLog, "Test Class Stat.: %s\n", TestClassValMom->GetStr(' ', ':', true).CStr());
1871        fprintf(fLog, ".........................................\n");
1872        fprintf(fLog, "Abs-Error: %s\n", PredAbsErrMom->GetStr(' ', ':', true).CStr());
1873        fprintf(fLog, "Rel-Error: %s\n", PredRelErrMom->GetStr(' ', ':', true).CStr());
1874        fprintf(fLog, "---End-Window----------------------------\n");
1875      }
1876      if (PrintToScrP){
1877        printf("PredAbsErr: %s\n", PredAbsErrMom->GetStr(' ', ':', true).CStr());
1878        printf("PredRelErr: %s\n", PredRelErrMom->GetStr(' ', ':', true).CStr());
1879        printf("Model for: %s - %s ; Predict for: %s - %s\n",
1880         StartDate.GetDtStr().CStr(), EndDate.GetDtStr().CStr(),
1881         StartPredDate.GetDtStr().CStr(), EndPredDate.GetDtStr().CStr());
1882      }
1883    }
1884    AllPredAbsErrMom->Def();
1885    AllPredRelErrMom->Def();
1886    if (LogVerbLev>0){
1887      fprintf(fLog, "=========================================\n");}
1888    fprintf(fLog, "Abs-Error: %s\n", AllPredAbsErrMom->GetStr(' ', ':', true).CStr());
1889    fprintf(fLog, "Rel-Error: %s\n", AllPredRelErrMom->GetStr(' ', ':', true).CStr());
1890    fprintf(fLog, "Evaluation (%s)\n", EvalStampTm.GetStr().CStr());
1891    fprintf(fLog, "===End-Evaluation========================\n");
1892    fprintf(fTabLog, "%s\t", GasDm->GetLtpNm().CStr());
1893    fprintf(fTabLog, "%s\t", GasDm->GetLocNm().CStr());
1894    fprintf(fTabLog, "%s\t", GasDm->GetProdNm().CStr());
1895    fprintf(fTabLog, "%s\t", GasDm->GetTypeNm().CStr());
1896    fprintf(fTabLog, "%d\t", TrainWnLen);
1897    fprintf(fTabLog, "%d\t", TestWnLen);
1898    fprintf(fTabLog, "%s\t", GasMdMType->GetDescStr().CStr());
1899    fprintf(fTabLog, "%s\t", AllPredAbsErrMom->TMom::GetValVStr().CStr());
1900    fprintf(fTabLog, "%s\n", AllPredRelErrMom->TMom::GetValVStr().CStr());
1901  }
1902  void TGasExe::GenDayOrder(
1903   const TStr& LogFNm,
1904   const PGasStation& GasStation, const TStr& OutGasStationFNm,
1905   const TSecTm& StartDt, const int& ProcessDays,
1906   const PGasDm& GasDm,
1907   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
1908   TGasSimRecV& GasSimRecV){
1909    PMom TodayPredVolMom=TMom::New();
1910    PMom TodayRealVolMom=TMom::New();
1911    int UnderSafetyLevWarns=0;
1912    int ReschOrdDtWarns=0;
1913    TFOut LogSOut(LogFNm); FILE* fLog=LogSOut.GetFileId();
1914    GasStation->DumpDef(fLog);
1915    if (!StartDt.IsDef()){
1916      TExcept::Throw("Invalid start date.");}
1917    int FirstRecN=0;
1918    while (FirstRecN<GasDm->GetRecs()){
1919      TSecTm CurRecDt=GasDm->GetDateVal(FirstRecN);
1920      if (CurRecDt==StartDt){break;}
1921      FirstRecN++;
1922    }
1923    if (FirstRecN==GasDm->GetRecs()){
1924      TSecTm CurRecDt=GasDm->GetDateVal(GasDm->GetRecs()-1);
1925      CurRecDt.AddDays(1);
1926      if (CurRecDt!=StartDt){
1927        TExcept::Throw("Invalid start date.", StartDt.GetDtStr());}
1928    }
1929    GasSimRecV.Clr();
1930    for (int TodayRecN=FirstRecN; TodayRecN<FirstRecN+ProcessDays-1; TodayRecN++){
1931      GasDm->AssureDayRec(TodayRecN);
1932      TSecTm TodayDt=GasDm->GetDateVal(TodayRecN);
1933      TStr TodayDtStr=TodayDt.GetDtStr();
1934      fprintf(fLog, "Start day at record [%d] for date [%s]\n", TodayRecN, TodayDtStr.CStr());
1935      fprintf(fLog, "\tDay-Info: [%s]\n", GasDm->GetBitsStr(TodayRecN).CStr());
1936      if (TodayRecN>FirstRecN){
1937        TSecTm PrevDt=GasDm->GetDateVal(TodayRecN-1);
1938        EAssertRA(TodayDt==TSecTm(PrevDt).AddDays(1),
1939         "Invalid time grid", TodayDtStr);
1940      }
1941      PGasSimRec GasSimRec=TGasSimRec::New(GasStation, TodayDtStr);
1942      int MnMdRecN=TodayRecN-GasStation->HistWnDays;
1943      int MxMdRecN=TodayRecN-1;
1944      PGasMd GasMd=TGasMd::New(
1945       gmtEnsemble, GasMdMType, GasMdParamStr,
1946       GasDm,
1947       GasDm->GetDateVal(MnMdRecN), GasDm->GetDateVal(MxMdRecN), -1, -1,
1948       100);
1949      fprintf(fLog, "\tCreate Model for %d records (from %d to %d)\n",
1950       MxMdRecN-MnMdRecN+1, MnMdRecN, MxMdRecN);
1951      double OrderQuantity=TGasOrder::GetQuantity(TodayDt, GasStation->GasOrderV);
1952      fprintf(fLog, "\tExecuted Orders for Quantity: %.0f\n", OrderQuantity);
1953      double TodayPredCspt=GasMd->GetPredClassVal(GasDm, TodayRecN);
1954      GasDm->PutCsptIfEmpty(TodayRecN, TodayPredCspt);
1955      fprintf(fLog, "\tPredicted consumption: %.0f\n", TodayPredCspt);
1956      double TodayRealCspt=GasDm->GetClassVal(TodayRecN);
1957      fprintf(fLog, "\tReal consumption: %.0f\n", TodayRealCspt);
1958      double TodayPredOpenVol=GasStation->VolumeVal+OrderQuantity;
1959      double TodayPredCloseVol=TodayPredOpenVol-TodayRealCspt;
1960      if ((TodayPredOpenVol!=-1)&&(TodayPredCloseVol!=-1)){
1961        TodayPredVolMom->Add((TodayPredOpenVol+TodayPredCloseVol)/2);}
1962      double TodayOpenRealVol=GasDm->GetVolVal(TodayRecN);
1963      double TodayCloseRealVol=-1;
1964      if (TodayRecN+1<GasDm->GetRecs()){
1965        TodayCloseRealVol=GasDm->GetVolVal(TodayRecN+1);}
1966      if ((TodayOpenRealVol!=-1)&&(TodayCloseRealVol!=-1)){
1967        TodayRealVolMom->Add((TodayOpenRealVol+TodayCloseRealVol)/2);}
1968      double SimVolumeVal=GasStation->VolumeVal;
1969      int SimTodayRecN=TodayRecN;
1970      int SimDays=GasStation->StockDurationDays+GasStation->DeliveryDays;
1971      fprintf(fLog, "\tSimulation to generate orders for %d (%d+%d) days.\n",
1972       SimDays, GasStation->StockDurationDays, GasStation->DeliveryDays);
1973      GasSimRec->PutReal(TodayPredOpenVol, TodayRealCspt, OrderQuantity);
1974      while (SimTodayRecN-TodayRecN<SimDays){
1975        GasDm->AssureDayRec(SimTodayRecN);
1976        TSecTm SimTodayDt=GasDm->GetDateVal(SimTodayRecN);
1977        TStr SimTodayDtStr=SimTodayDt.GetDtStr();
1978        double SimOrderQuantity=
1979         TGasOrder::GetQuantity(SimTodayDt, GasStation->GasOrderV);
1980        double SimPredCspt=GasMd->GetCorPredClassVal(
1981         GasDm, SimTodayRecN, GasStation->ExceptPredCorFact);
1982        GasDm->PutCsptIfEmpty(SimTodayRecN, SimPredCspt);
1983        GasSimRec->AddSimStep(SimTodayDtStr,
1984         SimVolumeVal-SimPredCspt+SimOrderQuantity,
1985         SimVolumeVal, SimPredCspt, SimOrderQuantity);
1986        fprintf(fLog, "\t\tSimVolume: %.0f = (v)%.0f - (c)%.0f + (o)%.0f (Date:%s) (Day:%d)\n",
1987         SimVolumeVal-SimPredCspt+SimOrderQuantity,
1988         SimVolumeVal, SimPredCspt, SimOrderQuantity,
1989         SimTodayDtStr.CStr(), SimTodayRecN-TodayRecN);
1990        if (SimVolumeVal-SimPredCspt+SimOrderQuantity>=GasStation->SafetyVolumeVal){
1991          SimVolumeVal=SimVolumeVal+SimOrderQuantity-SimPredCspt;
1992          SimTodayRecN++;
1993        } else {
1994          fprintf(fLog, "\t\tUnder safety level - calculate order quantity for %d days\n",
1995           GasStation->StockDurationDays);
1996          double SubOrderQuantity=0;
1997          for (int DurDayN=0; DurDayN<GasStation->StockDurationDays; DurDayN++){
1998            GasDm->AssureDayRec(SimTodayRecN+DurDayN);
1999            double SubSimPredCspt=0;
2000            if (DurDayN==0){
2001              SubSimPredCspt=GasStation->SafetyVolumeVal-
2002               (SimVolumeVal-SimPredCspt+SimOrderQuantity);
2003            } else {
2004              SubSimPredCspt=GasMd->GetCorPredClassVal(
2005               GasDm, SimTodayRecN+DurDayN, GasStation->ExceptPredCorFact);
2006            }
2007            GasDm->PutCsptIfEmpty(SimTodayRecN+DurDayN, SubSimPredCspt);
2008            GasSimRec->AddOrdStep(
2009             GasDm->GetDateVal(SimTodayRecN+DurDayN).GetDtStr(),
2010             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt);
2011            fprintf(fLog, "\t\t\tOrderQuantity: %.0f = (o)%.0f + (c)%.0f (Date:%s) (Day:%d)\n",
2012             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt,
2013             GasDm->GetDateVal(SimTodayRecN+DurDayN).GetDtStr().CStr(), DurDayN);
2014            SubOrderQuantity+=SubSimPredCspt;
2015          }
2016          GasSimRec->PutCorrQuant(
2017           SubOrderQuantity*GasStation->OrderQuantityCorFact);
2018          fprintf(fLog, "\t\t\tOrderQuantity: %.0f = %.0f * %.2f (Correction)\n",
2019           SubOrderQuantity*GasStation->OrderQuantityCorFact,
2020           SubOrderQuantity, GasStation->OrderQuantityCorFact);
2021          SubOrderQuantity*=GasStation->OrderQuantityCorFact;
2022          int OrderIssueDayRecN=SimTodayRecN-GasStation->DeliveryDays;
2023          if (OrderIssueDayRecN<0){OrderIssueDayRecN=0;}
2024          if (OrderIssueDayRecN<TodayRecN){
2025            fprintf(fLog, "\t\tReschedule Order: [%s] to [%s] !!!\n",
2026             GasDm->GetDateVal(OrderIssueDayRecN).GetDtStr().CStr(),
2027             GasDm->GetDateVal(TodayRecN).GetDtStr().CStr());
2028            OrderIssueDayRecN=TodayRecN;
2029            ReschOrdDtWarns++;
2030          }
2031          TSecTm OrderIssueDt=GasDm->GetDateVal(OrderIssueDayRecN);
2032          TSecTm OrderReceiveDt=
2033           GasDm->GetDateVal(OrderIssueDayRecN+GasStation->DeliveryDays);
2034          TStrV MsgStrV;
2035          TGasOrder::DelUnapprovedOrders(OrderReceiveDt, GasStation->GasOrderV, MsgStrV);
2036          TGasOrder::DelUnapprovedOrders(OrderReceiveDt, GasStation->NewGasOrderV, MsgStrV);
2037          for (int MsgStrN=0; MsgStrN<MsgStrV.Len(); MsgStrN++){
2038            fprintf(fLog, "\t\tDelete-Order: %s\n", MsgStrV[MsgStrN].CStr());}
2039          PGasOrder GasOrder=
2040           TGasOrder::New(OrderIssueDt, OrderReceiveDt, SubOrderQuantity, false);
2041          GasStation->GasOrderV.AddSorted(GasOrder);
2042          GasStation->NewGasOrderV.AddSorted(GasOrder);
2043          fprintf(fLog, "\t\tCreate-Order: %s\n", GasOrder->GetStr().CStr());
2044          break;
2045        }
2046      }
2047      fprintf(fLog, "\tNewVolume: %.0f = (v)%.0f + (o)%.0f - (c)%.0f\n",
2048       GasStation->VolumeVal+OrderQuantity-TodayRealCspt,
2049       GasStation->VolumeVal, OrderQuantity, TodayRealCspt);
2050      GasStation->VolumeVal=GasStation->VolumeVal+OrderQuantity-TodayRealCspt;
2051      if (GasStation->VolumeVal<GasStation->SafetyVolumeVal){
2052        UnderSafetyLevWarns++;
2053        fprintf(fLog, "\tUnder safety level: %.0f<%.0f !!!\n",
2054         GasStation->VolumeVal, GasStation->SafetyVolumeVal);
2055      }
2056      TGasOrder::DelOrders(TodayDt, GasStation->GasOrderV);
2057      GasSimRecV.Add(GasSimRec);
2058      fprintf(fLog, "Close day at record [%d] for date [%s]\n", TodayRecN, TodayDtStr.CStr());
2059    }
2060    GasStation->SaveXml(OutGasStationFNm);
2061    GasStation->DumpDef(fLog);
2062    TodayPredVolMom->Def(); TodayRealVolMom->Def();
2063    fprintf(fLog, "===Statistics-Start======================\n");
2064    fprintf(fLog, "Predicted-Volume-Statistics: %s\n", TodayPredVolMom->GetStr().CStr());
2065    fprintf(fLog, "     Real-Volume-Statistics: %s\n", TodayRealVolMom->GetStr().CStr());
2066    fprintf(fLog, "Under-Safety-Level-Warnings: %d\n", UnderSafetyLevWarns);
2067    fprintf(fLog, "  Reschedule-Order-Warnings: %d\n", ReschOrdDtWarns);
2068    fprintf(fLog, "===Statistics-End========================\n");
2069  }
2070  void TGasExe::GenHourBlockOrder(
2071   const TStr& LogFNm,
2072   const PGasStation& GasStation, const TStr& OutGasStationFNm,
2073   const TSecTm& StartDt, const int& ProcessDays,
2074   const PGasDm& GasDm,
2075   const PGasMdMType& GasMdMType, const TStr& GasMdParamStr,
2076   TGasSimRecV& GasSimRecV){
2077    int TmGridHours=GasStation->TmGridHours;
2078    PMom NowPredVolMom=TMom::New();
2079    PMom NowRealVolMom=TMom::New();
2080    int UnderSafetyLevWarns=0;
2081    int ReschOrdDtWarns=0;
2082    TFOut LogSOut(LogFNm); FILE* fLog=LogSOut.GetFileId();
2083    GasStation->DumpDef(fLog);
2084    if (!StartDt.IsDef()){
2085      TExcept::Throw("Invalid start date.");}
2086    int FirstRecN=0;
2087    while (FirstRecN<GasDm->GetRecs()){
2088      TSecTm CurRecDt=GasDm->GetDateVal(FirstRecN);
2089      if (CurRecDt==StartDt){break;}
2090      FirstRecN++;
2091    }
2092    if (FirstRecN==GasDm->GetRecs()){
2093      TSecTm CurRecDt=GasDm->GetDateVal(GasDm->GetRecs()-1);
2094      CurRecDt.AddDays(1);
2095      if (CurRecDt!=StartDt){
2096        TExcept::Throw("Invalid start date.", StartDt.GetDtStr());}
2097    }
2098    GasSimRecV.Clr();
2099    int DayRecs=24/TmGridHours;
2100    int ProcessRecs=ProcessDays*DayRecs;
2101    for (int NowRecN=FirstRecN; NowRecN<FirstRecN+ProcessRecs; NowRecN++){
2102      GasDm->AssureDayRec(NowRecN);
2103      TSecTm NowDt=GasDm->GetDateVal(NowRecN);
2104      int NowHourN=GasDm->GetHourN(NowRecN);
2105      TStr NowDtTmStr=NowDt.GetDtStr()+"/"+TInt::GetStr(NowHourN);
2106      TSecTm NowStartTm=TSecTm(NowDt).AddHours(NowHourN);
2107      TSecTm NowEndTm=TSecTm(NowStartTm).AddHours(TmGridHours);
2108      fprintf(fLog, "Start day at record [%d] for date/hour [%s]\n", NowRecN, NowDtTmStr.CStr());
2109      fprintf(fLog, "\tFrom [%s] To [%s]\n", NowStartTm.GetStr().CStr(), NowEndTm.GetStr().CStr());
2110      fprintf(fLog, "\tDay-Info: [%s]\n", GasDm->GetBitsStr(NowRecN).CStr());
2111      if (NowRecN>FirstRecN){
2112        TSecTm PrevDt=GasDm->GetDateVal(NowRecN-1);
2113        int PrevHourN=GasDm->GetHourN(NowRecN-1);
2114        if (NowDt==PrevDt){
2115          EAssertRA(NowHourN-PrevHourN==TmGridHours, "Invalid time grid", NowDtTmStr);
2116        } else
2117        if (NowDt==TSecTm(PrevDt).AddDays(1)){
2118          EAssertRA(NowHourN==0, "Invalid time grid", NowDtTmStr);
2119        }
2120      }
2121      PGasSimRec GasSimRec=TGasSimRec::New(GasStation, NowDtTmStr);
2122      int MnMdRecN=NowRecN-GasStation->HistWnDays*DayRecs;
2123      int MxMdRecN=NowRecN-1;
2124      PGasMd GasMd=TGasMd::New(
2125       gmtEnsemble, GasMdMType, GasMdParamStr,
2126       GasDm,
2127       TSecTm(), TSecTm(), MnMdRecN, MxMdRecN,
2128       100);
2129      fprintf(fLog, "\tCreate Model for %d records (from %d to %d)\n",
2130       MxMdRecN-MnMdRecN+1, MnMdRecN, MxMdRecN);
2131      double OrderQuantity=
2132       TGasOrder::GetQuantity(NowStartTm, NowEndTm, GasStation->GasOrderV);
2133      fprintf(fLog, "\tExecuted Orders for Quantity: %.0f\n", OrderQuantity);
2134      double NowPredCspt=GasMd->GetPredClassVal(GasDm, NowRecN);
2135      if (NowPredCspt<0){NowPredCspt=0;}
2136      GasDm->PutCsptIfEmpty(NowRecN, NowPredCspt);
2137      fprintf(fLog, "\tPredicted consumption: %.0f\n", NowPredCspt);
2138      double NowRealCspt=GasDm->GetClassVal(NowRecN);
2139      fprintf(fLog, "\tReal consumption: %.0f\n", NowRealCspt);
2140      double NowPredOpenVol=GasStation->VolumeVal+OrderQuantity;
2141      double NowPredCloseVol=NowPredOpenVol-NowRealCspt;
2142      if ((NowPredOpenVol!=-1)&&(NowPredCloseVol!=-1)){
2143        NowPredVolMom->Add((NowPredOpenVol+NowPredCloseVol)/2);}
2144      double NowOpenRealVol=GasDm->GetVolVal(NowRecN);
2145      double NowCloseRealVol=-1;
2146      if (NowRecN+1<GasDm->GetRecs()){
2147        NowCloseRealVol=GasDm->GetVolVal(NowRecN+1);}
2148      if ((NowOpenRealVol!=-1)&&(NowCloseRealVol!=-1)){
2149        NowRealVolMom->Add((NowOpenRealVol+NowCloseRealVol)/2);}
2150      double SimVolumeVal=GasStation->VolumeVal;
2151      int SimNowRecN=NowRecN;
2152      int SimDays=GasStation->StockDurationDays+GasStation->DeliveryDays;
2153      int SimRecs=SimDays*DayRecs;
2154      fprintf(fLog, "\tSimulation to generate orders for %d (%d+%d) days (%d records).\n",
2155       SimDays, GasStation->StockDurationDays, GasStation->DeliveryDays, SimRecs);
2156      GasSimRec->PutReal(NowPredOpenVol, NowRealCspt, OrderQuantity);
2157      while (SimNowRecN-NowRecN<SimRecs){
2158        GasDm->AssureDayRec(SimNowRecN);
2159        TSecTm SimNowDt=GasDm->GetDateVal(SimNowRecN);
2160        int SimNowHourN=GasDm->GetHourN(SimNowRecN);
2161        TStr SimNowDtTmStr=SimNowDt.GetDtStr()+"/"+TInt::GetStr(SimNowHourN);
2162        TSecTm SimNowStartTm=TSecTm(SimNowDt).AddHours(SimNowHourN);
2163        TSecTm SimNowEndTm=TSecTm(SimNowStartTm).AddHours(TmGridHours);
2164        double SimOrderQuantity=
2165         TGasOrder::GetQuantity(SimNowStartTm, SimNowEndTm, GasStation->GasOrderV);
2166        double SimPredCspt=GasMd->GetCorPredClassVal(
2167         GasDm, SimNowRecN, GasStation->ExceptPredCorFact);
2168        GasDm->PutCsptIfEmpty(SimNowRecN, SimPredCspt);
2169        GasSimRec->AddSimStep(SimNowDtTmStr,
2170         SimVolumeVal-SimPredCspt+SimOrderQuantity,
2171         SimVolumeVal, SimPredCspt, SimOrderQuantity);
2172        fprintf(fLog, "\t\tSimVolume: %.0f = (v)%.0f - (c)%.0f + (o)%.0f (Date/Hour:%s) (Step:%d)\n",
2173         SimVolumeVal-SimPredCspt+SimOrderQuantity,
2174         SimVolumeVal, SimPredCspt, SimOrderQuantity,
2175         SimNowDtTmStr.CStr(), SimNowRecN-NowRecN);
2176        if (SimVolumeVal-SimPredCspt+SimOrderQuantity>=GasStation->SafetyVolumeVal){
2177          SimVolumeVal=SimVolumeVal+SimOrderQuantity-SimPredCspt;
2178          SimNowRecN++;
2179        } else {
2180          fprintf(fLog, "\t\tUnder safety level - calculate order quantity for %d days\n",
2181           GasStation->StockDurationDays);
2182          double SubOrderQuantity=0;
2183          int DurRecs=GasStation->StockDurationDays*DayRecs;
2184          for (int DurRecN=0; DurRecN<DurRecs; DurRecN++){
2185            GasDm->AssureDayRec(SimNowRecN+DurRecN);
2186            TSecTm DurDt=GasDm->GetDateVal(SimNowRecN+DurRecN);
2187            int DurHourN=GasDm->GetHourN(SimNowRecN+DurRecN);
2188            TStr DurDtTmStr=DurDt.GetDtStr()+"/"+TInt::GetStr(DurHourN);
2189            double SubSimPredCspt=0;
2190            if (DurRecN==0){
2191              SubSimPredCspt=GasStation->SafetyVolumeVal-
2192               (SimVolumeVal-SimPredCspt+SimOrderQuantity);
2193            } else {
2194              SubSimPredCspt=GasMd->GetCorPredClassVal(
2195               GasDm, SimNowRecN+DurRecN, GasStation->ExceptPredCorFact);
2196            }
2197            GasDm->PutCsptIfEmpty(SimNowRecN+DurRecN, SubSimPredCspt);
2198            GasSimRec->AddOrdStep(
2199             DurDtTmStr,
2200             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt);
2201            fprintf(fLog, "\t\t\tOrderQuantity: %.0f = (o)%.0f + (c)%.0f (Date:%s) (Rec:%d)\n",
2202             SubOrderQuantity+SubSimPredCspt, SubOrderQuantity, SubSimPredCspt,
2203             DurDtTmStr.CStr(), DurRecN);
2204            SubOrderQuantity+=SubSimPredCspt;
2205          }
2206          GasSimRec->PutCorrQuant(
2207           SubOrderQuantity*GasStation->OrderQuantityCorFact);
2208          fprintf(fLog, "\t\t\tOrderQuantity: %.0f = %.0f * %.2f (Correction)\n",
2209           SubOrderQuantity*GasStation->OrderQuantityCorFact,
2210           SubOrderQuantity, GasStation->OrderQuantityCorFact);
2211          SubOrderQuantity*=GasStation->OrderQuantityCorFact;
2212          int OrderIssueRecN=SimNowRecN-GasStation->DeliveryDays*DayRecs;
2213          if (OrderIssueRecN<0){OrderIssueRecN=0;}
2214          if (OrderIssueRecN<NowRecN){
2215            fprintf(fLog, "\t\tReschedule Order: [%s] to [%s] !!!\n",
2216             GasDm->GetDateVal(OrderIssueRecN).GetDtStr().CStr(),
2217             GasDm->GetDateVal(NowRecN).GetDtStr().CStr());
2218            OrderIssueRecN=NowRecN;
2219            ReschOrdDtWarns++;
2220          }
2221          TSecTm OrderIssueTm=GasDm->GetDateVal(OrderIssueRecN);
2222          int OrderIssueHourN=GasDm->GetHourN(OrderIssueRecN);
2223          OrderIssueTm.AddHours(OrderIssueHourN);
2224          int DeliveryRecs=GasStation->DeliveryDays*DayRecs;
2225          TSecTm OrderReceiveTm=GasDm->GetDateVal(OrderIssueRecN+DeliveryRecs);
2226          int OrderReceiveHourN=GasDm->GetHourN(OrderIssueRecN+DeliveryRecs);
2227          OrderReceiveTm.AddHours(OrderReceiveHourN);
2228          TStrV MsgStrV;
2229          TGasOrder::DelUnapprovedOrders(OrderReceiveTm, GasStation->GasOrderV, MsgStrV);
2230          TGasOrder::DelUnapprovedOrders(OrderReceiveTm, GasStation->NewGasOrderV, MsgStrV);
2231          for (int MsgStrN=0; MsgStrN<MsgStrV.Len(); MsgStrN++){
2232            fprintf(fLog, "\t\tDelete-Order: %s\n", MsgStrV[MsgStrN].CStr());}
2233          PGasOrder GasOrder=
2234           TGasOrder::New(OrderIssueTm, OrderReceiveTm, SubOrderQuantity, false);
2235          GasStation->GasOrderV.AddSorted(GasOrder);
2236          GasStation->NewGasOrderV.AddSorted(GasOrder);
2237          fprintf(fLog, "\t\tCreate-Order: %s\n", GasOrder->GetStr().CStr());
2238          break;
2239        }
2240      }
2241      fprintf(fLog, "\tNewVolume: %.0f = (v)%.0f + (o)%.0f - (c)%.0f\n",
2242       GasStation->VolumeVal+OrderQuantity-NowRealCspt,
2243       GasStation->VolumeVal, OrderQuantity, NowRealCspt);
2244      GasStation->VolumeVal=GasStation->VolumeVal+OrderQuantity-NowRealCspt;
2245      if (GasStation->VolumeVal<GasStation->SafetyVolumeVal){
2246        UnderSafetyLevWarns++;
2247        fprintf(fLog, "\tUnder safety level: %.0f<%.0f !!!\n",
2248         GasStation->VolumeVal, GasStation->SafetyVolumeVal);
2249      }
2250      TGasOrder::DelOrders(NowStartTm, NowEndTm, GasStation->GasOrderV);
2251      GasSimRecV.Add(GasSimRec);
2252      fprintf(fLog, "Close day at record [%d] for date/hour [%s]\n", NowRecN, NowDtTmStr.CStr());
2253    }
2254    GasStation->SaveXml(OutGasStationFNm);
2255    GasStation->DumpDef(fLog);
2256    NowPredVolMom->Def(); NowRealVolMom->Def();
2257    fprintf(fLog, "===Statistics-Start======================\n");
2258    fprintf(fLog, "Predicted-Volume-Statistics: %s\n", NowPredVolMom->GetStr().CStr());
2259    fprintf(fLog, "     Real-Volume-Statistics: %s\n", NowRealVolMom->GetStr().CStr());
2260    fprintf(fLog, "Under-Safety-Level-Warnings: %d\n", UnderSafetyLevWarns);
2261    fprintf(fLog, "  Reschedule-Order-Warnings: %d\n", ReschOrdDtWarns);
2262    fprintf(fLog, "===Statistics-End========================\n");
2263  }
2264  int TGasExe::GenPrediction(
2265   const TStr& TabFNm,
2266   const TStr& _LtpFNm,
2267   const TStr& LtpFPath,
2268   const bool& RepairP,
2269   const TStr& OutLogFNm,
2270   const TStr& OutXmlFNm,
2271   const TStr& MdNm,
2272   const TStr& TmResNm,
2273   const TStr& PredDateStr,
2274   const int& PredDays,
2275   const int& TrainDays,
2276   const double& MnCspt,
2277   const double& ExceptPredCorFact){
2278    Try;
2279    TStr LtpFNm=_LtpFNm;
2280    if ((!TabFNm.Empty())&&(LtpFNm.Empty())){
2281      LtpFNm=TStr::PutFExt(TabFNm, ".Ltp");}
2282    TSecTm PredDate=TSecTm::GetDtTmFromDmyStr(PredDateStr);
2283    TFOut LogFOut(OutLogFNm); FILE* fLog=LogFOut.GetFileId();
2284    if (!TabFNm.Empty()){
2285      TGasLtpBs::ConvTabToLtp(TabFNm, LtpFPath, RepairP);}
2286    PGasLtpBs GasLtpBs=TGasLtpBs::Load(LtpFNm);
2287    PGasMdMType GasMdMType;
2288    if (MdNm=="ctb"){GasMdMType=TGasMdMType::New(gmtCTb);}
2289    else if (MdNm=="svd"){GasMdMType=TGasMdMType::New(gmtLr);}
2290    else if (MdNm=="nnbr"){GasMdMType=TGasMdMType::New(gmtNNbr);}
2291    else if (MdNm=="svm"){GasMdMType=TGasMdMType::New(gmtSvm);}
2292    else if (MdNm=="cubist"){GasMdMType=TGasMdMType::New(gmtCubist);}
2293    else if (MdNm=="rtree"){GasMdMType=TGasMdMType::New(gmtRegTree);}
2294    else if (MdNm=="ens"){
2295      GasMdMType=TGasMdMType::New();
2296      GasMdMType->AddMdTypeWgt(gmtLr, 40);
2297      GasMdMType->AddMdTypeWgt(gmtNNbr, 30);
2298      GasMdMType->AddMdTypeWgt(gmtCTb, 30);
2299      GasMdMType->NrmMdWgt();
2300    } else {
2301      TExcept::Throw("Invalid model type", MdNm);
2302    }
2303    PGasDm GasDm;
2304    if (TmResNm=="w"){GasDm=TGasDm::GetWeekGasDm(GasLtpBs);}
2305    else if (TmResNm=="d"){GasDm=TGasDm::GetDayGasDm(GasLtpBs);}
2306    else if (TmResNm=="24h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 24);}
2307    else if (TmResNm=="12h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 12);}
2308    else if (TmResNm=="6h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 6);}
2309    else if (TmResNm=="4h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 4);}
2310    else if (TmResNm=="3h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 3);}
2311    else if (TmResNm=="2h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 2);}
2312    else if (TmResNm=="1h"){GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, 1);}
2313    else {TExcept::Throw("Invalid time resolution", TmResNm);}
2314    TSecTm MnLtpDate=GasLtpBs->GetMnDate();
2315    TSecTm MxLtpDate=GasLtpBs->GetMxDate();
2316    fprintf(fLog, "Minimal-Possible-Train-Date: %s\n", MnLtpDate.GetDtStr().CStr());
2317    fprintf(fLog, "Maximal-Possible-Train-Date: %s\n", MxLtpDate.GetDtStr().CStr());
2318    if (PredDateStr.Empty()){
2319      PredDate=TSecTm(MxLtpDate).AddDays(1);}
2320    TSecTm StartPredDate=PredDate;
2321    TSecTm EndPredDate=TSecTm(StartPredDate).AddDays(PredDays-1);
2322    TSecTm StartTrainDate=TSecTm(StartPredDate).AddDays(-TrainDays);
2323    TSecTm EndTrainDate=TSecTm(StartPredDate).AddDays(-1);
2324    fprintf(fLog, "Start-Train-Date: %s\n", StartTrainDate.GetDtStr().CStr());
2325    fprintf(fLog, "End-Train-Date: %s\n", EndTrainDate.GetDtStr().CStr());
2326    fprintf(fLog, "Start-Prediction-Date: %s\n", StartPredDate.GetDtStr().CStr());
2327    fprintf(fLog, "End-Prediction-Date: %s\n", EndPredDate.GetDtStr().CStr());
2328    if ((StartTrainDate<MnLtpDate)||(MxLtpDate<StartTrainDate)){
2329      TExcept::Throw("Bad Start-Train-Date", StartTrainDate.GetStr());}
2330    if ((EndTrainDate<MnLtpDate)||(MxLtpDate<EndTrainDate)){
2331      TExcept::Throw("Bad End-Train-Date", EndTrainDate.GetStr());}
2332    TIntV TrainRecNV; TIntV SimPredRecNV;
2333    GasDm->GetRecNV(StartTrainDate, EndTrainDate, -1, -1, MnCspt, TrainRecNV);
2334    GasDm->GetRecNV(StartPredDate, EndPredDate, -1, -1, MnCspt, SimPredRecNV);
2335    int TrainRecs=TrainRecNV.Len(); int SimPredRecs=SimPredRecNV.Len();
2336    if (TrainRecs==0){
2337      TExcept::Throw("Empty Train Set");
2338    } else {
2339      fprintf(fLog, "Train Records: %d (from %d to %d)\n",
2340       TrainRecs, TrainRecNV[0], TrainRecNV.Last());
2341    }
2342    fprintf(fLog, "Simulated Prediction Records: %d\n", SimPredRecs);
2343    PGasMd GasMd=TGasMd::New(
2344     gmtEnsemble, GasMdMType,
2345     TGasMd::GetMdParamStr(),
2346     GasDm,
2347     StartTrainDate, EndTrainDate, -1, -1,
2348     MnCspt);
2349    {TFOut SOut(OutXmlFNm); FILE* fOut=SOut.GetFileId();
2350    fprintf(fOut, "<Predictions>\n");
2351    fprintf(fOut, "  <Location>%s</Location>\n",
2352     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetLocNm()).CStr());
2353    fprintf(fOut, "  <Product>%s</Product>\n",
2354     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetProdNm()).CStr());
2355    fprintf(fOut, "  <LtpCode>%s</LtpCode>\n",
2356     TXmlLx::GetXmlStrFromPlainStr(GasLtpBs->GetLtpNm()).CStr());
2357    TSecTm CurPredDate=StartPredDate;
2358    for (int SimPredRecNN=0; SimPredRecNN<SimPredRecs; SimPredRecNN++){
2359      int PredRecN=SimPredRecNV[SimPredRecNN];
2360      CurPredDate=TSecTm::GetDtTm(GasDm->GetDateVal(PredRecN));
2361      TStr PredDateStr=GasDm->GetDateVal(PredRecN).GetDtStr();
2362      int HourN=GasDm->GetAttrVal(PredRecN, "Hour", -1);
2363      TStr PredTmStr;
2364      if (HourN==-1){
2365        fprintf(fLog, "Prediction date: %s (record %d)\n",
2366         PredDateStr.CStr(), PredRecN);
2367         PredTmStr=PredDateStr;
2368      } else {
2369        fprintf(fLog, "Prediction date: %s %d:00 (record %d)\n",
2370         PredDateStr.CStr(), HourN, PredRecN);
2371        PredTmStr=PredDateStr+" "+TInt::GetStr(HourN)+":00";
2372      }
2373      double PredClassVal=GasMd->GetCorPredClassVal(GasDm, PredRecN, ExceptPredCorFact);
2374      double RealClassVal=GasDm->GetClassVal(PredRecN);
2375      fprintf(fLog, "Predicted Consumption: %.0f\n", PredClassVal);
2376      fprintf(fLog, "Real Consumption: %.0f\n", RealClassVal);
2377      fprintf(fOut, "  <Prediction Mode=\"Simulation\">\n");
2378      fprintf(fOut, "    <Time>%s</Time>\n", PredTmStr.CStr());
2379      fprintf(fOut, "    <Predicted>%.0f</Predicted>\n", PredClassVal);
2380      if (RealClassVal!=-1){
2381        fprintf(fOut, "    <Real>%.0f</Real>\n", RealClassVal);}
2382      fprintf(fOut, "  </Prediction>\n");
2383    }
2384    while (CurPredDate<=EndPredDate){
2385      int PredRecN=GasDm->AddTmResRec();
2386      CurPredDate=TSecTm::GetDtTm(GasDm->GetDateVal(PredRecN));
2387      TStr PredDateStr=GasDm->GetDateVal(PredRecN).GetDtStr();
2388      int HourN=GasDm->GetAttrVal(PredRecN, "Hour", -1);
2389      TStr PredTmStr;
2390      if (HourN==-1){
2391        fprintf(fLog, "Prediction date: %s (record %d)\n",
2392         PredDateStr.CStr(), PredRecN);
2393         PredTmStr=PredDateStr;
2394      } else {
2395        fprintf(fLog, "Prediction date: %s %d:00 (record %d)\n",
2396         PredDateStr.CStr(), HourN, PredRecN);
2397        PredTmStr=PredDateStr+" "+TInt::GetStr(HourN)+":00";
2398      }
2399      double PredClassVal=GasMd->GetCorPredClassVal(GasDm, PredRecN, ExceptPredCorFact);
2400      GasDm->PutCsptIfEmpty(PredRecN, PredClassVal);
2401      fprintf(fLog, "Predicted Consumption: %.0f\n", PredClassVal);
2402      fprintf(fOut, "  <Prediction Mode=\"Future\">\n");
2403      fprintf(fOut, "    <Time>%s</Time>\n", PredTmStr.CStr());
2404      fprintf(fOut, "    <Predicted>%.0f</Predicted>\n", PredClassVal);
2405      fprintf(fOut, "  </Prediction>\n");
2406    }
2407    fprintf(fOut, "</Predictions>\n");}
2408    return 0;
2409    Catch;
2410    return 1;
2411  }
2412  int TGasExe::GenOrder(
2413   const TStr& TabFNm,
2414   const TStr& _LtpFNm,
2415   const TStr& InGasStationFNm,
2416   const TStr& OutGasStationFNm,
2417   const TStr& OutLogFNm,
2418   const TStr& OutSimFNm,
2419   const TStr& StartDateStr,
2420   const int& ProcessDays){
2421    Try;
2422    TStr LtpFNm=_LtpFNm;
2423    if ((!TabFNm.Empty())&&(LtpFNm.Empty())){
2424      LtpFNm=TStr::PutFExt(TabFNm, ".Ltp");}
2425    TStr LtpFPath=LtpFNm.GetFPath();
2426    TSecTm StartDt=TSecTm::GetDtTmFromDmyStr(StartDateStr);
2427    PGasMdMType GasMdMType=TGasMdMType::New();
2428    GasMdMType->AddMdTypeWgt(gmtLr, 40);
2429    GasMdMType->AddMdTypeWgt(gmtNNbr, 30);
2430    GasMdMType->AddMdTypeWgt(gmtCTb, 30);
2431    GasMdMType->NrmMdWgt();
2432    if (!TabFNm.Empty()){
2433      TGasLtpBs::ConvTabToLtp(TabFNm, LtpFPath);}
2434    PGasLtpBs GasLtpBs=TGasLtpBs::Load(LtpFNm);
2435    PGasStation GasStation=TGasStation::LoadXml(InGasStationFNm);
2436    if (GasStation->TmGridHours==24){
2437      PGasDm GasDm=TGasDm::GetDayGasDm(GasLtpBs);
2438      TGasSimRecV GasSimRecV;
2439      TGasExe::GenDayOrder(
2440       OutLogFNm,
2441       GasStation, OutGasStationFNm,
2442       StartDt, ProcessDays,
2443       GasDm,
2444       GasMdMType, TGasMd::GetMdParamStr(),
2445       GasSimRecV);
2446      if (!OutSimFNm.Empty()){
2447        TGasSimRec::SaveBin(OutSimFNm, GasSimRecV);}
2448    } else
2449    if ((0<GasStation->TmGridHours)&&(GasStation->TmGridHours<24)){
2450      PGasDm GasDm=TGasDm::GetHourBlockGasDm(GasLtpBs, GasStation->TmGridHours);
2451      TGasSimRecV GasSimRecV;
2452      TGasExe::GenHourBlockOrder(
2453       OutLogFNm,
2454       GasStation, OutGasStationFNm,
2455       StartDt, ProcessDays,
2456       GasDm,
2457       GasMdMType, TGasMd::GetMdParamStr(),
2458       GasSimRecV);
2459      if (!OutSimFNm.Empty()){
2460        TGasSimRec::SaveBin(OutSimFNm, GasSimRecV);}
2461    } else {
2462      TExcept::Throw(
2463       "Time-Grid should be 0<tg<=24", TInt::GetStr(GasStation->TmGridHours));
2464    }
2465    return 0;
2466    Catch;
2467    return 1;
2468  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-json.hpp</h3>
            <pre><code>1  #ifndef INCLUDE_NLOHMANN_JSON_HPP_
2  #define INCLUDE_NLOHMANN_JSON_HPP_
3  #define NLOHMANN_JSON_VERSION_MAJOR 3
4  #define NLOHMANN_JSON_VERSION_MINOR 10
5  #define NLOHMANN_JSON_VERSION_PATCH 2
6  #include <algorithm> 
7  #include <cstddef> 
8  #include <functional> 
9  #include <initializer_list> 
10  #ifndef JSON_NO_IO
11      #include <iosfwd> 
12  #endif  
13  #include <iterator> 
14  #include <memory> 
15  #include <numeric> 
16  #include <string> 
17  #include <utility> 
18  #include <vector> 
19  #include <type_traits>
20  #include <utility>
21  #include <algorithm> 
22  #include <array> 
23  #include <forward_list> 
24  #include <iterator> 
25  #include <map> 
26  #include <string> 
27  #include <tuple> 
28  #include <type_traits> 
29  #include <unordered_map> 
30  #include <utility> 
31  #include <valarray> 
32  #include <exception> 
33  #include <stdexcept> 
34  #include <string> 
35  #include <vector> 
36  #include <array> 
37  #include <cstddef> 
38  #include <cstdint> 
39  #include <string> 
40  namespace nlohmann
41  {
42  namespace detail
43  {
44  enum class value_t : std::uint8_t
45  {
46      null,             
47      object,           
48      array,            
49      string,           
50      boolean,          
51      number_integer,   
52      number_unsigned,  
53      number_float,     
54      binary,           
55      discarded         
56  };
57  inline bool operator<(const value_t lhs, const value_t rhs) noexcept
58  {
59      static constexpr std::array<std::uint8_t, 9> order = {{
60              0 &bsol;* null */, 3 &bsol;* object */, 4 &bsol;* array */, 5 &bsol;* string */,
61              1 &bsol;* boolean */, 2 &bsol;* integer */, 2 &bsol;* unsigned */, 2 &bsol;* float */,
62              6 &bsol;* binary */
63          }
64      };
65      const auto l_index = static_cast<std::size_t>(lhs);
66      const auto r_index = static_cast<std::size_t>(rhs);
67      return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
68  }
69  }  
70  }  
71  #include <string>
72  #include <utility> 
73  #if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
74  #if defined(JSON_HEDLEY_VERSION)
75      #undef JSON_HEDLEY_VERSION
76  #endif
77  #define JSON_HEDLEY_VERSION 15
78  #if defined(JSON_HEDLEY_STRINGIFY_EX)
79      #undef JSON_HEDLEY_STRINGIFY_EX
80  #endif
81  #define JSON_HEDLEY_STRINGIFY_EX(x) #x
82  #if defined(JSON_HEDLEY_STRINGIFY)
83      #undef JSON_HEDLEY_STRINGIFY
84  #endif
85  #define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)
86  #if defined(JSON_HEDLEY_CONCAT_EX)
87      #undef JSON_HEDLEY_CONCAT_EX
88  #endif
89  #define JSON_HEDLEY_CONCAT_EX(a,b) a##b
90  #if defined(JSON_HEDLEY_CONCAT)
91      #undef JSON_HEDLEY_CONCAT
92  #endif
93  #define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)
94  #if defined(JSON_HEDLEY_CONCAT3_EX)
95      #undef JSON_HEDLEY_CONCAT3_EX
96  #endif
97  #define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c
98  #if defined(JSON_HEDLEY_CONCAT3)
99      #undef JSON_HEDLEY_CONCAT3
100  #endif
101  #define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)
102  #if defined(JSON_HEDLEY_VERSION_ENCODE)
103      #undef JSON_HEDLEY_VERSION_ENCODE
104  #endif
105  #define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))
106  #if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
107      #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
108  #endif
109  #define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
110  #if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
111      #undef JSON_HEDLEY_VERSION_DECODE_MINOR
112  #endif
113  #define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
114  #if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
115      #undef JSON_HEDLEY_VERSION_DECODE_REVISION
116  #endif
117  #define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
118  #if defined(JSON_HEDLEY_GNUC_VERSION)
119      #undef JSON_HEDLEY_GNUC_VERSION
120  #endif
121  #if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
122      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
123  #elif defined(__GNUC__)
124      #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
125  #endif
126  #if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
127      #undef JSON_HEDLEY_GNUC_VERSION_CHECK
128  #endif
129  #if defined(JSON_HEDLEY_GNUC_VERSION)
130      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
131  #else
132      #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
133  #endif
134  #if defined(JSON_HEDLEY_MSVC_VERSION)
135      #undef JSON_HEDLEY_MSVC_VERSION
136  #endif
137  #if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
138      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
139  #elif defined(_MSC_FULL_VER) && !defined(__ICL)
140      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
141  #elif defined(_MSC_VER) && !defined(__ICL)
142      #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
143  #endif
144  #if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
145      #undef JSON_HEDLEY_MSVC_VERSION_CHECK
146  #endif
147  #if !defined(JSON_HEDLEY_MSVC_VERSION)
148      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
149  #elif defined(_MSC_VER) && (_MSC_VER >= 1400)
150      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
151  #elif defined(_MSC_VER) && (_MSC_VER >= 1200)
152      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
153  #else
154      #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
155  #endif
156  #if defined(JSON_HEDLEY_INTEL_VERSION)
157      #undef JSON_HEDLEY_INTEL_VERSION
158  #endif
159  #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
160      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
161  #elif defined(__INTEL_COMPILER) && !defined(__ICL)
162      #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
163  #endif
164  #if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
165      #undef JSON_HEDLEY_INTEL_VERSION_CHECK
166  #endif
167  #if defined(JSON_HEDLEY_INTEL_VERSION)
168      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
169  #else
170      #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
171  #endif
172  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
173      #undef JSON_HEDLEY_INTEL_CL_VERSION
174  #endif
175  #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
176      #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
177  #endif
178  #if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
179      #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
180  #endif
181  #if defined(JSON_HEDLEY_INTEL_CL_VERSION)
182      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
183  #else
184      #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
185  #endif
186  #if defined(JSON_HEDLEY_PGI_VERSION)
187      #undef JSON_HEDLEY_PGI_VERSION
188  #endif
189  #if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
190      #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
191  #endif
192  #if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
193      #undef JSON_HEDLEY_PGI_VERSION_CHECK
194  #endif
195  #if defined(JSON_HEDLEY_PGI_VERSION)
196      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
197  #else
198      #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
199  #endif
200  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
201      #undef JSON_HEDLEY_SUNPRO_VERSION
202  #endif
203  #if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
204      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
205  #elif defined(__SUNPRO_C)
206      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
207  #elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
208      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
209  #elif defined(__SUNPRO_CC)
210      #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
211  #endif
212  #if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
213      #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
214  #endif
215  #if defined(JSON_HEDLEY_SUNPRO_VERSION)
216      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
217  #else
218      #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
219  #endif
220  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
221      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
222  #endif
223  #if defined(__EMSCRIPTEN__)
224      #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
225  #endif
226  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
227      #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
228  #endif
229  #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
230      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
231  #else
232      #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
233  #endif
234  #if defined(JSON_HEDLEY_ARM_VERSION)
235      #undef JSON_HEDLEY_ARM_VERSION
236  #endif
237  #if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
238      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
239  #elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
240      #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
241  #endif
242  #if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
243      #undef JSON_HEDLEY_ARM_VERSION_CHECK
244  #endif
245  #if defined(JSON_HEDLEY_ARM_VERSION)
246      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
247  #else
248      #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
249  #endif
250  #if defined(JSON_HEDLEY_IBM_VERSION)
251      #undef JSON_HEDLEY_IBM_VERSION
252  #endif
253  #if defined(__ibmxl__)
254      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
255  #elif defined(__xlC__) && defined(__xlC_ver__)
256      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
257  #elif defined(__xlC__)
258      #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
259  #endif
260  #if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
261      #undef JSON_HEDLEY_IBM_VERSION_CHECK
262  #endif
263  #if defined(JSON_HEDLEY_IBM_VERSION)
264      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
265  #else
266      #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
267  #endif
268  #if defined(JSON_HEDLEY_TI_VERSION)
269      #undef JSON_HEDLEY_TI_VERSION
270  #endif
271  #if \
272      defined(__TI_COMPILER_VERSION__) && \
273      ( \
274        defined(__TMS470__) || defined(__TI_ARM__) || \
275        defined(__MSP430__) || \
276        defined(__TMS320C2000__) \
277      )
278  #if (__TI_COMPILER_VERSION__ >= 16000000)
279      #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
280  #endif
281  #endif
282  #if defined(JSON_HEDLEY_TI_VERSION_CHECK)
283      #undef JSON_HEDLEY_TI_VERSION_CHECK
284  #endif
285  #if defined(JSON_HEDLEY_TI_VERSION)
286      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
287  #else
288      #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
289  #endif
290  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
291      #undef JSON_HEDLEY_TI_CL2000_VERSION
292  #endif
293  #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
294      #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
295  #endif
296  #if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
297      #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
298  #endif
299  #if defined(JSON_HEDLEY_TI_CL2000_VERSION)
300      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
301  #else
302      #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
303  #endif
304  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
305      #undef JSON_HEDLEY_TI_CL430_VERSION
306  #endif
307  #if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
308      #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
309  #endif
310  #if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
311      #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
312  #endif
313  #if defined(JSON_HEDLEY_TI_CL430_VERSION)
314      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
315  #else
316      #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
317  #endif
318  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
319      #undef JSON_HEDLEY_TI_ARMCL_VERSION
320  #endif
321  #if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
322      #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
323  #endif
324  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
325      #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
326  #endif
327  #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
328      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
329  #else
330      #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
331  #endif
332  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
333      #undef JSON_HEDLEY_TI_CL6X_VERSION
334  #endif
335  #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
336      #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
337  #endif
338  #if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
339      #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
340  #endif
341  #if defined(JSON_HEDLEY_TI_CL6X_VERSION)
342      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
343  #else
344      #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
345  #endif
346  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
347      #undef JSON_HEDLEY_TI_CL7X_VERSION
348  #endif
349  #if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
350      #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
351  #endif
352  #if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
353      #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
354  #endif
355  #if defined(JSON_HEDLEY_TI_CL7X_VERSION)
356      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
357  #else
358      #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
359  #endif
360  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
361      #undef JSON_HEDLEY_TI_CLPRU_VERSION
362  #endif
363  #if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
364      #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
365  #endif
366  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
367      #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
368  #endif
369  #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
370      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
371  #else
372      #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
373  #endif
374  #if defined(JSON_HEDLEY_CRAY_VERSION)
375      #undef JSON_HEDLEY_CRAY_VERSION
376  #endif
377  #if defined(_CRAYC)
378      #if defined(_RELEASE_PATCHLEVEL)
379          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
380      #else
381          #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
382      #endif
383  #endif
384  #if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
385      #undef JSON_HEDLEY_CRAY_VERSION_CHECK
386  #endif
387  #if defined(JSON_HEDLEY_CRAY_VERSION)
388      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
389  #else
390      #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
391  #endif
392  #if defined(JSON_HEDLEY_IAR_VERSION)
393      #undef JSON_HEDLEY_IAR_VERSION
394  #endif
395  #if defined(__IAR_SYSTEMS_ICC__)
396      #if __VER__ > 1000
397          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
398      #else
399          #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
400      #endif
401  #endif
402  #if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
403      #undef JSON_HEDLEY_IAR_VERSION_CHECK
404  #endif
405  #if defined(JSON_HEDLEY_IAR_VERSION)
406      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
407  #else
408      #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
409  #endif
410  #if defined(JSON_HEDLEY_TINYC_VERSION)
411      #undef JSON_HEDLEY_TINYC_VERSION
412  #endif
413  #if defined(__TINYC__)
414      #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
415  #endif
416  #if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
417      #undef JSON_HEDLEY_TINYC_VERSION_CHECK
418  #endif
419  #if defined(JSON_HEDLEY_TINYC_VERSION)
420      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
421  #else
422      #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
423  #endif
424  #if defined(JSON_HEDLEY_DMC_VERSION)
425      #undef JSON_HEDLEY_DMC_VERSION
426  #endif
427  #if defined(__DMC__)
428      #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
429  #endif
430  #if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
431      #undef JSON_HEDLEY_DMC_VERSION_CHECK
432  #endif
433  #if defined(JSON_HEDLEY_DMC_VERSION)
434      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
435  #else
436      #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
437  #endif
438  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
439      #undef JSON_HEDLEY_COMPCERT_VERSION
440  #endif
441  #if defined(__COMPCERT_VERSION__)
442      #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
443  #endif
444  #if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
445      #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
446  #endif
447  #if defined(JSON_HEDLEY_COMPCERT_VERSION)
448      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
449  #else
450      #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
451  #endif
452  #if defined(JSON_HEDLEY_PELLES_VERSION)
453      #undef JSON_HEDLEY_PELLES_VERSION
454  #endif
455  #if defined(__POCC__)
456      #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
457  #endif
458  #if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
459      #undef JSON_HEDLEY_PELLES_VERSION_CHECK
460  #endif
461  #if defined(JSON_HEDLEY_PELLES_VERSION)
462      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
463  #else
464      #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
465  #endif
466  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
467      #undef JSON_HEDLEY_MCST_LCC_VERSION
468  #endif
469  #if defined(__LCC__) && defined(__LCC_MINOR__)
470      #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
471  #endif
472  #if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
473      #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
474  #endif
475  #if defined(JSON_HEDLEY_MCST_LCC_VERSION)
476      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
477  #else
478      #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
479  #endif
480  #if defined(JSON_HEDLEY_GCC_VERSION)
481      #undef JSON_HEDLEY_GCC_VERSION
482  #endif
483  #if \
484      defined(JSON_HEDLEY_GNUC_VERSION) && \
485      !defined(__clang__) && \
486      !defined(JSON_HEDLEY_INTEL_VERSION) && \
487      !defined(JSON_HEDLEY_PGI_VERSION) && \
488      !defined(JSON_HEDLEY_ARM_VERSION) && \
489      !defined(JSON_HEDLEY_CRAY_VERSION) && \
490      !defined(JSON_HEDLEY_TI_VERSION) && \
491      !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
492      !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
493      !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
494      !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
495      !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
496      !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
497      !defined(__COMPCERT__) && \
498      !defined(JSON_HEDLEY_MCST_LCC_VERSION)
499      #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
500  #endif
501  #if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
502      #undef JSON_HEDLEY_GCC_VERSION_CHECK
503  #endif
504  #if defined(JSON_HEDLEY_GCC_VERSION)
505      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
506  #else
507      #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
508  #endif
509  #if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
510      #undef JSON_HEDLEY_HAS_ATTRIBUTE
511  #endif
512  #if \
513    defined(__has_attribute) && \
514    ( \
515      (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
516    )
517  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
518  #else
519  #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
520  #endif
521  #if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
522      #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
523  #endif
524  #if defined(__has_attribute)
525      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
526  #else
527      #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
528  #endif
529  #if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
530      #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
531  #endif
532  #if defined(__has_attribute)
533      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
534  #else
535      #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
536  #endif
537  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
538      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
539  #endif
540  #if \
541      defined(__has_cpp_attribute) && \
542      defined(__cplusplus) && \
543      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
544      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
545  #else
546      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
547  #endif
548  #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
549      #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
550  #endif
551  #if !defined(__cplusplus) || !defined(__has_cpp_attribute)
552      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
553  #elif \
554      !defined(JSON_HEDLEY_PGI_VERSION) && \
555      !defined(JSON_HEDLEY_IAR_VERSION) && \
556      (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
557      (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
558      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
559  #else
560      #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
561  #endif
562  #if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
563      #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
564  #endif
565  #if defined(__has_cpp_attribute) && defined(__cplusplus)
566      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
567  #else
568      #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
569  #endif
570  #if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
571      #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
572  #endif
573  #if defined(__has_cpp_attribute) && defined(__cplusplus)
574      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
575  #else
576      #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
577  #endif
578  #if defined(JSON_HEDLEY_HAS_BUILTIN)
579      #undef JSON_HEDLEY_HAS_BUILTIN
580  #endif
581  #if defined(__has_builtin)
582      #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
583  #else
584      #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
585  #endif
586  #if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
587      #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
588  #endif
589  #if defined(__has_builtin)
590      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
591  #else
592      #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
593  #endif
594  #if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
595      #undef JSON_HEDLEY_GCC_HAS_BUILTIN
596  #endif
597  #if defined(__has_builtin)
598      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
599  #else
600      #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
601  #endif
602  #if defined(JSON_HEDLEY_HAS_FEATURE)
603      #undef JSON_HEDLEY_HAS_FEATURE
604  #endif
605  #if defined(__has_feature)
606      #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
607  #else
608      #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
609  #endif
610  #if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
611      #undef JSON_HEDLEY_GNUC_HAS_FEATURE
612  #endif
613  #if defined(__has_feature)
614      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
615  #else
616      #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
617  #endif
618  #if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
619      #undef JSON_HEDLEY_GCC_HAS_FEATURE
620  #endif
621  #if defined(__has_feature)
622      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
623  #else
624      #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
625  #endif
626  #if defined(JSON_HEDLEY_HAS_EXTENSION)
627      #undef JSON_HEDLEY_HAS_EXTENSION
628  #endif
629  #if defined(__has_extension)
630      #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
631  #else
632      #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
633  #endif
634  #if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
635      #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
636  #endif
637  #if defined(__has_extension)
638      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
639  #else
640      #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
641  #endif
642  #if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
643      #undef JSON_HEDLEY_GCC_HAS_EXTENSION
644  #endif
645  #if defined(__has_extension)
646      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
647  #else
648      #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
649  #endif
650  #if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
651      #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
652  #endif
653  #if defined(__has_declspec_attribute)
654      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
655  #else
656      #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
657  #endif
658  #if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
659      #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
660  #endif
661  #if defined(__has_declspec_attribute)
662      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
663  #else
664      #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
665  #endif
666  #if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
667      #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
668  #endif
669  #if defined(__has_declspec_attribute)
670      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
671  #else
672      #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
673  #endif
674  #if defined(JSON_HEDLEY_HAS_WARNING)
675      #undef JSON_HEDLEY_HAS_WARNING
676  #endif
677  #if defined(__has_warning)
678      #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
679  #else
680      #define JSON_HEDLEY_HAS_WARNING(warning) (0)
681  #endif
682  #if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
683      #undef JSON_HEDLEY_GNUC_HAS_WARNING
684  #endif
685  #if defined(__has_warning)
686      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
687  #else
688      #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
689  #endif
690  #if defined(JSON_HEDLEY_GCC_HAS_WARNING)
691      #undef JSON_HEDLEY_GCC_HAS_WARNING
692  #endif
693  #if defined(__has_warning)
694      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
695  #else
696      #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
697  #endif
698  #if \
699      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
700      defined(__clang__) || \
701      JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
702      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
703      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
704      JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
705      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
706      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
707      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
708      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
709      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
710      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
711      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
712      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
713      JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
714      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
715      JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
716      (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
717      #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
718  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
719      #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
720  #else
721      #define JSON_HEDLEY_PRAGMA(value)
722  #endif
723  #if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
724      #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
725  #endif
726  #if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
727      #undef JSON_HEDLEY_DIAGNOSTIC_POP
728  #endif
729  #if defined(__clang__)
730      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
731      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
732  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
733      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
734      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
735  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
736      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
737      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
738  #elif \
739      JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
740      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
741      #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
742      #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
743  #elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
744      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
745      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
746  #elif \
747      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
748      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
749      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
750      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
751      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
752      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
753      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
754      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
755  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
756      #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
757      #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
758  #else
759      #define JSON_HEDLEY_DIAGNOSTIC_PUSH
760      #define JSON_HEDLEY_DIAGNOSTIC_POP
761  #endif
762  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
763      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
764  #endif
765  #if defined(__cplusplus)
766  #  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
767  #    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
768  #      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
769  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
770      JSON_HEDLEY_DIAGNOSTIC_PUSH \
771      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
772      _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
773      _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
774      xpr \
775      JSON_HEDLEY_DIAGNOSTIC_POP
776  #      else
777  #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
778      JSON_HEDLEY_DIAGNOSTIC_PUSH \
779      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
780      _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
781      xpr \
782      JSON_HEDLEY_DIAGNOSTIC_POP
783  #      endif
784  #    else
785  #      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
786      JSON_HEDLEY_DIAGNOSTIC_PUSH \
787      _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
788      xpr \
789      JSON_HEDLEY_DIAGNOSTIC_POP
790  #    endif
791  #  endif
792  #endif
793  #if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
794      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
795  #endif
796  #if defined(JSON_HEDLEY_CONST_CAST)
797      #undef JSON_HEDLEY_CONST_CAST
798  #endif
799  #if defined(__cplusplus)
800  #  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
801  #elif \
802    JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
803    JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
804    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
805  #  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
806          JSON_HEDLEY_DIAGNOSTIC_PUSH \
807          JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
808          ((T) (expr)); \
809          JSON_HEDLEY_DIAGNOSTIC_POP \
810      }))
811  #else
812  #  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
813  #endif
814  #if defined(JSON_HEDLEY_REINTERPRET_CAST)
815      #undef JSON_HEDLEY_REINTERPRET_CAST
816  #endif
817  #if defined(__cplusplus)
818      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
819  #else
820      #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
821  #endif
822  #if defined(JSON_HEDLEY_STATIC_CAST)
823      #undef JSON_HEDLEY_STATIC_CAST
824  #endif
825  #if defined(__cplusplus)
826      #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
827  #else
828      #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
829  #endif
830  #if defined(JSON_HEDLEY_CPP_CAST)
831      #undef JSON_HEDLEY_CPP_CAST
832  #endif
833  #if defined(__cplusplus)
834  #  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
835  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
836      JSON_HEDLEY_DIAGNOSTIC_PUSH \
837      _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
838      ((T) (expr)) \
839      JSON_HEDLEY_DIAGNOSTIC_POP
840  #  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
841  #    define JSON_HEDLEY_CPP_CAST(T, expr) \
842      JSON_HEDLEY_DIAGNOSTIC_PUSH \
843      _Pragma("diag_suppress=Pe137") \
844      JSON_HEDLEY_DIAGNOSTIC_POP
845  #  else
846  #    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
847  #  endif
848  #else
849  #  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
850  #endif
851  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
852      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
853  #endif
854  #if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
855      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
856  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
857      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
858  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
859      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
860  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
861      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
862  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
863      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
864  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
865      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
866  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
867      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
868  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
869      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
870  #elif \
871      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
872      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
873      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
874      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
875      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
876      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
877      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
878      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
879      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
880      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
881      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
882      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
883  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
884      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
885  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
886      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
887  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
888      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
889  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
890      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
891  #else
892      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
893  #endif
894  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
895      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
896  #endif
897  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
898      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
899  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
900      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
901  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
902      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
903  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
904      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
905  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
906      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
907  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
908      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
909  #elif \
910      JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
911      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
912      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
913      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
914      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
915  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
916      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
917  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
918      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
919  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
920      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
921  #else
922      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
923  #endif
924  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
925      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
926  #endif
927  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
928      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
929  #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
930      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
931  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
932      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
933  #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
934      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
935  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
936      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
937  #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
938      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
939  #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
940      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
941  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
942      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
943  #elif \
944      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
945      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
946      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
947      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
948  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
949      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
950  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
951      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
952  #else
953      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
954  #endif
955  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
956      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
957  #endif
958  #if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
959      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
960  #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
961      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
962  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
963      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
964  #else
965      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
966  #endif
967  #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
968      #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
969  #endif
970  #if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
971      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
972  #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
973      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
974  #elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
975      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
976  #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
977      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
978  #else
979      #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
980  #endif
981  #if defined(JSON_HEDLEY_DEPRECATED)
982      #undef JSON_HEDLEY_DEPRECATED
983  #endif
984  #if defined(JSON_HEDLEY_DEPRECATED_FOR)
985      #undef JSON_HEDLEY_DEPRECATED_FOR
986  #endif
987  #if \
988      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
989      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
990      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
991      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
992  #elif \
993      (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
994      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
995      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
996      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
997      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
998      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
999      JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
1000      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
1001      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
1002      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1003      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
1004      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1005      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
1006      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
1007  #elif defined(__cplusplus) && (__cplusplus >= 201402L)
1008      #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
1009      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
1010  #elif \
1011      JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
1012      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1013      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1014      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1015      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1016      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1017      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1018      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1019      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1020      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1021      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1022      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1023      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1024      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1025      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1026      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1027      #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
1028      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
1029  #elif \
1030      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1031      JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
1032      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1033      #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
1034      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
1035  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1036      #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
1037      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
1038  #else
1039      #define JSON_HEDLEY_DEPRECATED(since)
1040      #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
1041  #endif
1042  #if defined(JSON_HEDLEY_UNAVAILABLE)
1043      #undef JSON_HEDLEY_UNAVAILABLE
1044  #endif
1045  #if \
1046      JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
1047      JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
1048      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1049      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1050      #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
1051  #else
1052      #define JSON_HEDLEY_UNAVAILABLE(available_since)
1053  #endif
1054  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
1055      #undef JSON_HEDLEY_WARN_UNUSED_RESULT
1056  #endif
1057  #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
1058      #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
1059  #endif
1060  #if \
1061      JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
1062      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1063      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1064      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1065      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1066      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1067      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1068      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1069      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1070      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1071      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1072      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1073      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1074      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1075      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
1076      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1077      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1078      #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
1079      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
1080  #elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
1081      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1082      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
1083  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
1084      #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1085      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
1086  #elif defined(_Check_return_) &bsol;* SAL */
1087      #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
1088      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
1089  #else
1090      #define JSON_HEDLEY_WARN_UNUSED_RESULT
1091      #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
1092  #endif
1093  #if defined(JSON_HEDLEY_SENTINEL)
1094      #undef JSON_HEDLEY_SENTINEL
1095  #endif
1096  #if \
1097      JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
1098      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1099      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1100      JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1101      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1102      #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
1103  #else
1104      #define JSON_HEDLEY_SENTINEL(position)
1105  #endif
1106  #if defined(JSON_HEDLEY_NO_RETURN)
1107      #undef JSON_HEDLEY_NO_RETURN
1108  #endif
1109  #if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1110      #define JSON_HEDLEY_NO_RETURN __noreturn
1111  #elif \
1112      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1113      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1114      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1115  #elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
1116      #define JSON_HEDLEY_NO_RETURN _Noreturn
1117  #elif defined(__cplusplus) && (__cplusplus >= 201103L)
1118      #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
1119  #elif \
1120      JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
1121      JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
1122      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1123      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1124      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1125      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1126      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1127      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1128      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1129      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1130      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1131      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1132      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1133      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1134      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1135      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1136      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1137      #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
1138  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1139      #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
1140  #elif \
1141      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1142      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1143      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1144  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
1145      #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
1146  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1147      #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
1148  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1149      #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
1150  #else
1151      #define JSON_HEDLEY_NO_RETURN
1152  #endif
1153  #if defined(JSON_HEDLEY_NO_ESCAPE)
1154      #undef JSON_HEDLEY_NO_ESCAPE
1155  #endif
1156  #if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
1157      #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
1158  #else
1159      #define JSON_HEDLEY_NO_ESCAPE
1160  #endif
1161  #if defined(JSON_HEDLEY_UNREACHABLE)
1162      #undef JSON_HEDLEY_UNREACHABLE
1163  #endif
1164  #if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
1165      #undef JSON_HEDLEY_UNREACHABLE_RETURN
1166  #endif
1167  #if defined(JSON_HEDLEY_ASSUME)
1168      #undef JSON_HEDLEY_ASSUME
1169  #endif
1170  #if \
1171      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1172      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1173      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1174      #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
1175  #elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
1176      #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
1177  #elif \
1178      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1179      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1180      #if defined(__cplusplus)
1181          #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
1182      #else
1183          #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
1184      #endif
1185  #endif
1186  #if \
1187      (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
1188      JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
1189      JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
1190      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1191      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
1192      JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
1193      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1194      #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
1195  #elif defined(JSON_HEDLEY_ASSUME)
1196      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1197  #endif
1198  #if !defined(JSON_HEDLEY_ASSUME)
1199      #if defined(JSON_HEDLEY_UNREACHABLE)
1200          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
1201      #else
1202          #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
1203      #endif
1204  #endif
1205  #if defined(JSON_HEDLEY_UNREACHABLE)
1206      #if  \
1207          JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1208          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
1209          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
1210      #else
1211          #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
1212      #endif
1213  #else
1214      #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
1215  #endif
1216  #if !defined(JSON_HEDLEY_UNREACHABLE)
1217      #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
1218  #endif
1219  JSON_HEDLEY_DIAGNOSTIC_PUSH
1220  #if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
1221      #pragma clang diagnostic ignored "-Wpedantic"
1222  #endif
1223  #if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
1224      #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
1225  #endif
1226  #if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
1227      #if defined(__clang__)
1228          #pragma clang diagnostic ignored "-Wvariadic-macros"
1229      #elif defined(JSON_HEDLEY_GCC_VERSION)
1230          #pragma GCC diagnostic ignored "-Wvariadic-macros"
1231      #endif
1232  #endif
1233  #if defined(JSON_HEDLEY_NON_NULL)
1234      #undef JSON_HEDLEY_NON_NULL
1235  #endif
1236  #if \
1237      JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
1238      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1239      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1240      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1241      #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
1242  #else
1243      #define JSON_HEDLEY_NON_NULL(...)
1244  #endif
1245  JSON_HEDLEY_DIAGNOSTIC_POP
1246  #if defined(JSON_HEDLEY_PRINTF_FORMAT)
1247      #undef JSON_HEDLEY_PRINTF_FORMAT
1248  #endif
1249  #if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
1250      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
1251  #elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
1252      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
1253  #elif \
1254      JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
1255      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1256      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1257      JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
1258      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1259      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1260      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1261      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1262      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1263      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1264      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1265      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1266      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1267      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1268      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1269      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1270      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1271      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
1272  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
1273      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
1274  #else
1275      #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
1276  #endif
1277  #if defined(JSON_HEDLEY_CONSTEXPR)
1278      #undef JSON_HEDLEY_CONSTEXPR
1279  #endif
1280  #if defined(__cplusplus)
1281      #if __cplusplus >= 201103L
1282          #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
1283      #endif
1284  #endif
1285  #if !defined(JSON_HEDLEY_CONSTEXPR)
1286      #define JSON_HEDLEY_CONSTEXPR
1287  #endif
1288  #if defined(JSON_HEDLEY_PREDICT)
1289      #undef JSON_HEDLEY_PREDICT
1290  #endif
1291  #if defined(JSON_HEDLEY_LIKELY)
1292      #undef JSON_HEDLEY_LIKELY
1293  #endif
1294  #if defined(JSON_HEDLEY_UNLIKELY)
1295      #undef JSON_HEDLEY_UNLIKELY
1296  #endif
1297  #if defined(JSON_HEDLEY_UNPREDICTABLE)
1298      #undef JSON_HEDLEY_UNPREDICTABLE
1299  #endif
1300  #if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
1301      #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
1302  #endif
1303  #if \
1304    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
1305    JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
1306    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1307  #  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
1308  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
1309  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
1310  #  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
1311  #  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
1312  #elif \
1313    (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1314    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
1315    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1316    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
1317    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1318    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1319    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1320    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
1321    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1322    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
1323    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1324    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1325    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1326    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
1327    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1328    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1329  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
1330      (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
1331  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
1332      (__extension__ ({ \
1333          double hedley_probability_ = (probability); \
1334          ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
1335      }))
1336  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
1337      (__extension__ ({ \
1338          double hedley_probability_ = (probability); \
1339          ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
1340      }))
1341  #  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
1342  #  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
1343  #else
1344  #  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
1345  #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
1346  #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
1347  #  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
1348  #  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
1349  #endif
1350  #if !defined(JSON_HEDLEY_UNPREDICTABLE)
1351      #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
1352  #endif
1353  #if defined(JSON_HEDLEY_MALLOC)
1354      #undef JSON_HEDLEY_MALLOC
1355  #endif
1356  #if \
1357      JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
1358      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1359      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1360      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1361      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1362      JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1363      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1364      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1365      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1366      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1367      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1368      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1369      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1370      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1371      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1372      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1373      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1374      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1375      #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
1376  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1377      #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
1378  #elif \
1379      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1380      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1381      #define JSON_HEDLEY_MALLOC __declspec(restrict)
1382  #else
1383      #define JSON_HEDLEY_MALLOC
1384  #endif
1385  #if defined(JSON_HEDLEY_PURE)
1386      #undef JSON_HEDLEY_PURE
1387  #endif
1388  #if \
1389    JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
1390    JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
1391    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1392    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1393    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1394    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1395    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1396    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1397    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1398    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1399    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1400    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1401    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1402    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1403    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1404    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1405    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1406    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1407    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1408  #  define JSON_HEDLEY_PURE __attribute__((__pure__))
1409  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1410  #  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
1411  #elif defined(__cplusplus) && \
1412      ( \
1413        JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
1414        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
1415        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
1416      )
1417  #  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
1418  #else
1419  #  define JSON_HEDLEY_PURE
1420  #endif
1421  #if defined(JSON_HEDLEY_CONST)
1422      #undef JSON_HEDLEY_CONST
1423  #endif
1424  #if \
1425      JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
1426      JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
1427      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1428      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1429      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1430      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1431      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1432      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1433      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1434      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1435      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1436      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1437      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1438      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1439      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1440      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1441      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1442      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1443      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1444      #define JSON_HEDLEY_CONST __attribute__((__const__))
1445  #elif \
1446      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
1447      #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
1448  #else
1449      #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
1450  #endif
1451  #if defined(JSON_HEDLEY_RESTRICT)
1452      #undef JSON_HEDLEY_RESTRICT
1453  #endif
1454  #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
1455      #define JSON_HEDLEY_RESTRICT restrict
1456  #elif \
1457      JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
1458      JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
1459      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1460      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1461      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1462      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1463      JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
1464      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1465      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
1466      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
1467      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1468      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
1469      JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
1470      defined(__clang__) || \
1471      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1472      #define JSON_HEDLEY_RESTRICT __restrict
1473  #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
1474      #define JSON_HEDLEY_RESTRICT _Restrict
1475  #else
1476      #define JSON_HEDLEY_RESTRICT
1477  #endif
1478  #if defined(JSON_HEDLEY_INLINE)
1479      #undef JSON_HEDLEY_INLINE
1480  #endif
1481  #if \
1482      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
1483      (defined(__cplusplus) && (__cplusplus >= 199711L))
1484      #define JSON_HEDLEY_INLINE inline
1485  #elif \
1486      defined(JSON_HEDLEY_GCC_VERSION) || \
1487      JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
1488      #define JSON_HEDLEY_INLINE __inline__
1489  #elif \
1490      JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1491      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1492      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1493      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
1494      JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
1495      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
1496      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
1497      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1498      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1499      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1500      #define JSON_HEDLEY_INLINE __inline
1501  #else
1502      #define JSON_HEDLEY_INLINE
1503  #endif
1504  #if defined(JSON_HEDLEY_ALWAYS_INLINE)
1505      #undef JSON_HEDLEY_ALWAYS_INLINE
1506  #endif
1507  #if \
1508    JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
1509    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1510    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1511    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1512    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1513    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1514    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1515    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1516    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1517    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1518    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1519    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1520    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1521    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1522    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1523    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1524    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1525    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1526    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1527  #  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
1528  #elif \
1529    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
1530    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1531  #  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
1532  #elif defined(__cplusplus) && \
1533      ( \
1534        JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1535        JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1536        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1537        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1538        JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1539        JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
1540      )
1541  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
1542  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1543  #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
1544  #else
1545  #  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
1546  #endif
1547  #if defined(JSON_HEDLEY_NEVER_INLINE)
1548      #undef JSON_HEDLEY_NEVER_INLINE
1549  #endif
1550  #if \
1551      JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
1552      JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
1553      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1554      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1555      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1556      JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
1557      JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
1558      (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1559      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
1560      (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1561      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
1562      (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1563      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
1564      (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1565      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
1566      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
1567      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
1568      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
1569      JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
1570      #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
1571  #elif \
1572      JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
1573      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1574      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1575  #elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
1576      #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
1577  #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
1578      #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
1579  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1580      #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
1581  #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
1582      #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
1583  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
1584      #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
1585  #else
1586      #define JSON_HEDLEY_NEVER_INLINE
1587  #endif
1588  #if defined(JSON_HEDLEY_PRIVATE)
1589      #undef JSON_HEDLEY_PRIVATE
1590  #endif
1591  #if defined(JSON_HEDLEY_PUBLIC)
1592      #undef JSON_HEDLEY_PUBLIC
1593  #endif
1594  #if defined(JSON_HEDLEY_IMPORT)
1595      #undef JSON_HEDLEY_IMPORT
1596  #endif
1597  #if defined(_WIN32) || defined(__CYGWIN__)
1598  #  define JSON_HEDLEY_PRIVATE
1599  #  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
1600  #  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
1601  #else
1602  #  if \
1603      JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
1604      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1605      JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
1606      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1607      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1608      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1609      ( \
1610        defined(__TI_EABI__) && \
1611        ( \
1612          (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
1613          JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
1614        ) \
1615      ) || \
1616      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1617  #    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
1618  #    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
1619  #  else
1620  #    define JSON_HEDLEY_PRIVATE
1621  #    define JSON_HEDLEY_PUBLIC
1622  #  endif
1623  #  define JSON_HEDLEY_IMPORT    extern
1624  #endif
1625  #if defined(JSON_HEDLEY_NO_THROW)
1626      #undef JSON_HEDLEY_NO_THROW
1627  #endif
1628  #if \
1629      JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
1630      JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
1631      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1632      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1633      #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
1634  #elif \
1635      JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
1636      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
1637      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
1638      #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
1639  #else
1640      #define JSON_HEDLEY_NO_THROW
1641  #endif
1642  #if defined(JSON_HEDLEY_FALL_THROUGH)
1643      #undef JSON_HEDLEY_FALL_THROUGH
1644  #endif
1645  #if \
1646      JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
1647      JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
1648      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1649      #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
1650  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
1651      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
1652  #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
1653      #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
1654  #elif defined(__fallthrough) &bsol;* SAL */
1655      #define JSON_HEDLEY_FALL_THROUGH __fallthrough
1656  #else
1657      #define JSON_HEDLEY_FALL_THROUGH
1658  #endif
1659  #if defined(JSON_HEDLEY_RETURNS_NON_NULL)
1660      #undef JSON_HEDLEY_RETURNS_NON_NULL
1661  #endif
1662  #if \
1663      JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
1664      JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1665      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1666      #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
1667  #elif defined(_Ret_notnull_) &bsol;* SAL */
1668      #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
1669  #else
1670      #define JSON_HEDLEY_RETURNS_NON_NULL
1671  #endif
1672  #if defined(JSON_HEDLEY_ARRAY_PARAM)
1673      #undef JSON_HEDLEY_ARRAY_PARAM
1674  #endif
1675  #if \
1676      defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
1677      !defined(__STDC_NO_VLA__) && \
1678      !defined(__cplusplus) && \
1679      !defined(JSON_HEDLEY_PGI_VERSION) && \
1680      !defined(JSON_HEDLEY_TINYC_VERSION)
1681      #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
1682  #else
1683      #define JSON_HEDLEY_ARRAY_PARAM(name)
1684  #endif
1685  #if defined(JSON_HEDLEY_IS_CONSTANT)
1686      #undef JSON_HEDLEY_IS_CONSTANT
1687  #endif
1688  #if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
1689      #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
1690  #endif
1691  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1692      #undef JSON_HEDLEY_IS_CONSTEXPR_
1693  #endif
1694  #if \
1695      JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
1696      JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1697      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1698      JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
1699      JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
1700      JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1701      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
1702      (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
1703      JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1704      JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
1705      #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
1706  #endif
1707  #if !defined(__cplusplus)
1708  #  if \
1709         JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
1710         JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
1711         JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1712         JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
1713         JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
1714         JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
1715         JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
1716  #if defined(__INTPTR_TYPE__)
1717      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
1718  #else
1719      #include <stdint.h>
1720      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
1721  #endif
1722  #  elif \
1723         ( \
1724            defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
1725            !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
1726            !defined(JSON_HEDLEY_PGI_VERSION) && \
1727            !defined(JSON_HEDLEY_IAR_VERSION)) || \
1728         (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
1729         JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
1730         JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
1731         JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
1732         JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
1733  #if defined(__INTPTR_TYPE__)
1734      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
1735  #else
1736      #include <stdint.h>
1737      #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
1738  #endif
1739  #  elif \
1740         defined(JSON_HEDLEY_GCC_VERSION) || \
1741         defined(JSON_HEDLEY_INTEL_VERSION) || \
1742         defined(JSON_HEDLEY_TINYC_VERSION) || \
1743         defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
1744         JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
1745         defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
1746         defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
1747         defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
1748         defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
1749         defined(__clang__)
1750  #    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
1751          sizeof(void) != \
1752          sizeof(*( \
1753                    1 ? \
1754                    ((void*) ((expr) * 0L) ) : \
1755  ((struct { char v[sizeof(void) * 2]; } *) 1) \
1756                  ) \
1757                ) \
1758                                              )
1759  #  endif
1760  #endif
1761  #if defined(JSON_HEDLEY_IS_CONSTEXPR_)
1762      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1763          #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
1764      #endif
1765      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
1766  #else
1767      #if !defined(JSON_HEDLEY_IS_CONSTANT)
1768          #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
1769      #endif
1770      #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
1771  #endif
1772  #if defined(JSON_HEDLEY_BEGIN_C_DECLS)
1773      #undef JSON_HEDLEY_BEGIN_C_DECLS
1774  #endif
1775  #if defined(JSON_HEDLEY_END_C_DECLS)
1776      #undef JSON_HEDLEY_END_C_DECLS
1777  #endif
1778  #if defined(JSON_HEDLEY_C_DECL)
1779      #undef JSON_HEDLEY_C_DECL
1780  #endif
1781  #if defined(__cplusplus)
1782      #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
1783      #define JSON_HEDLEY_END_C_DECLS }
1784      #define JSON_HEDLEY_C_DECL extern "C"
1785  #else
1786      #define JSON_HEDLEY_BEGIN_C_DECLS
1787      #define JSON_HEDLEY_END_C_DECLS
1788      #define JSON_HEDLEY_C_DECL
1789  #endif
1790  #if defined(JSON_HEDLEY_STATIC_ASSERT)
1791      #undef JSON_HEDLEY_STATIC_ASSERT
1792  #endif
1793  #if \
1794    !defined(__cplusplus) && ( \
1795        (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
1796        (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
1797        JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
1798        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
1799        defined(_Static_assert) \
1800      )
1801  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
1802  #elif \
1803    (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
1804    JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
1805    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1806  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
1807  #else
1808  #  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
1809  #endif
1810  #if defined(JSON_HEDLEY_NULL)
1811      #undef JSON_HEDLEY_NULL
1812  #endif
1813  #if defined(__cplusplus)
1814      #if __cplusplus >= 201103L
1815          #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
1816      #elif defined(NULL)
1817          #define JSON_HEDLEY_NULL NULL
1818      #else
1819          #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
1820      #endif
1821  #elif defined(NULL)
1822      #define JSON_HEDLEY_NULL NULL
1823  #else
1824      #define JSON_HEDLEY_NULL ((void*) 0)
1825  #endif
1826  #if defined(JSON_HEDLEY_MESSAGE)
1827      #undef JSON_HEDLEY_MESSAGE
1828  #endif
1829  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
1830  #  define JSON_HEDLEY_MESSAGE(msg) \
1831      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1832      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1833      JSON_HEDLEY_PRAGMA(message msg) \
1834      JSON_HEDLEY_DIAGNOSTIC_POP
1835  #elif \
1836    JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
1837    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1838  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
1839  #elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
1840  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
1841  #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
1842  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1843  #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
1844  #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
1845  #else
1846  #  define JSON_HEDLEY_MESSAGE(msg)
1847  #endif
1848  #if defined(JSON_HEDLEY_WARNING)
1849      #undef JSON_HEDLEY_WARNING
1850  #endif
1851  #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
1852  #  define JSON_HEDLEY_WARNING(msg) \
1853      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1854      JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
1855      JSON_HEDLEY_PRAGMA(clang warning msg) \
1856      JSON_HEDLEY_DIAGNOSTIC_POP
1857  #elif \
1858    JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
1859    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
1860    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
1861  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
1862  #elif \
1863    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
1864    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1865  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
1866  #else
1867  #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
1868  #endif
1869  #if defined(JSON_HEDLEY_REQUIRE)
1870      #undef JSON_HEDLEY_REQUIRE
1871  #endif
1872  #if defined(JSON_HEDLEY_REQUIRE_MSG)
1873      #undef JSON_HEDLEY_REQUIRE_MSG
1874  #endif
1875  #if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
1876  #  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
1877  #    define JSON_HEDLEY_REQUIRE(expr) \
1878      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1879      _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
1880      __attribute__((diagnose_if(!(expr), #expr, "error"))) \
1881      JSON_HEDLEY_DIAGNOSTIC_POP
1882  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
1883      JSON_HEDLEY_DIAGNOSTIC_PUSH \
1884      _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
1885      __attribute__((diagnose_if(!(expr), msg, "error"))) \
1886      JSON_HEDLEY_DIAGNOSTIC_POP
1887  #  else
1888  #    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
1889  #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
1890  #  endif
1891  #else
1892  #  define JSON_HEDLEY_REQUIRE(expr)
1893  #  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
1894  #endif
1895  #if defined(JSON_HEDLEY_FLAGS)
1896      #undef JSON_HEDLEY_FLAGS
1897  #endif
1898  #if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
1899      #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
1900  #else
1901      #define JSON_HEDLEY_FLAGS
1902  #endif
1903  #if defined(JSON_HEDLEY_FLAGS_CAST)
1904      #undef JSON_HEDLEY_FLAGS_CAST
1905  #endif
1906  #if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
1907  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
1908          JSON_HEDLEY_DIAGNOSTIC_PUSH \
1909          _Pragma("warning(disable:188)") \
1910          ((T) (expr)); \
1911          JSON_HEDLEY_DIAGNOSTIC_POP \
1912      }))
1913  #else
1914  #  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
1915  #endif
1916  #if defined(JSON_HEDLEY_EMPTY_BASES)
1917      #undef JSON_HEDLEY_EMPTY_BASES
1918  #endif
1919  #if \
1920      (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
1921      JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
1922      #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
1923  #else
1924      #define JSON_HEDLEY_EMPTY_BASES
1925  #endif
1926  #if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
1927      #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
1928  #endif
1929  #if defined(__clang__)
1930      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
1931  #else
1932      #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
1933  #endif
1934  #if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
1935      #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
1936  #endif
1937  #define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
1938  #if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
1939      #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
1940  #endif
1941  #define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
1942  #if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
1943      #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
1944  #endif
1945  #define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)
1946  #if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
1947      #undef JSON_HEDLEY_CLANG_HAS_FEATURE
1948  #endif
1949  #define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)
1950  #if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
1951      #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
1952  #endif
1953  #define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)
1954  #if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
1955      #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
1956  #endif
1957  #define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
1958  #if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
1959      #undef JSON_HEDLEY_CLANG_HAS_WARNING
1960  #endif
1961  #define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)
1962  #endif &bsol;* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */
1963  #if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
1964      #if defined(__clang__)
1965          #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
1966              #error "unsupported Clang version - see https:&bsol;&bsol;github.com/nlohmann/json#supported-compilers"
1967          #endif
1968      #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
1969          #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
1970              #error "unsupported GCC version - see https:&bsol;&bsol;github.com/nlohmann/json#supported-compilers"
1971          #endif
1972      #endif
1973  #endif
1974  #if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
1975      #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
1976          #define JSON_HAS_CPP_20
1977          #define JSON_HAS_CPP_17
1978          #define JSON_HAS_CPP_14
1979      #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) 
1980          #define JSON_HAS_CPP_17
1981          #define JSON_HAS_CPP_14
1982      #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
1983          #define JSON_HAS_CPP_14
1984      #endif
1985      #define JSON_HAS_CPP_11
1986  #endif
1987  #if defined(__clang__)
1988      #pragma clang diagnostic push
1989      #pragma clang diagnostic ignored "-Wdocumentation"
1990      #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
1991  #endif
1992  #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
1993      #define JSON_THROW(exception) throw exception
1994      #define JSON_TRY try
1995      #define JSON_CATCH(exception) catch(exception)
1996      #define JSON_INTERNAL_CATCH(exception) catch(exception)
1997  #else
1998      #include <cstdlib>
1999      #define JSON_THROW(exception) std::abort()
2000      #define JSON_TRY if(true)
2001      #define JSON_CATCH(exception) if(false)
2002      #define JSON_INTERNAL_CATCH(exception) if(false)
2003  #endif
2004  #if defined(JSON_THROW_USER)
2005      #undef JSON_THROW
2006      #define JSON_THROW JSON_THROW_USER
2007  #endif
2008  #if defined(JSON_TRY_USER)
2009      #undef JSON_TRY
2010      #define JSON_TRY JSON_TRY_USER
2011  #endif
2012  #if defined(JSON_CATCH_USER)
2013      #undef JSON_CATCH
2014      #define JSON_CATCH JSON_CATCH_USER
2015      #undef JSON_INTERNAL_CATCH
2016      #define JSON_INTERNAL_CATCH JSON_CATCH_USER
2017  #endif
2018  #if defined(JSON_INTERNAL_CATCH_USER)
2019      #undef JSON_INTERNAL_CATCH
2020      #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
2021  #endif
2022  #if !defined(JSON_ASSERT)
2023      #include <cassert> 
2024      #define JSON_ASSERT(x) assert(x)
2025  #endif
2026  #if defined(JSON_TESTS_PRIVATE)
2027      #define JSON_PRIVATE_UNLESS_TESTED public
2028  #else
2029      #define JSON_PRIVATE_UNLESS_TESTED private
2030  #endif
2031  #define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
2032      template<typename BasicJsonType>                                                            \
2033      inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
2034      {                                                                                           \
2035          static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
2036          static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
2037          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2038                                 [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
2039          {                                                                                       \
2040              return ej_pair.first == e;                                                          \
2041          });                                                                                     \
2042          j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
2043      }                                                                                           \
2044      template<typename BasicJsonType>                                                            \
2045      inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
2046      {                                                                                           \
2047          static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
2048          static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
2049          auto it = std::find_if(std::begin(m), std::end(m),                                      \
2050                                 [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
2051          {                                                                                       \
2052              return ej_pair.second == j;                                                         \
2053          });                                                                                     \
2054          e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
2055      }
2056  #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
2057      template<template<typename, typename, typename...> class ObjectType,   \
2058               template<typename, typename...> class ArrayType,              \
2059               class StringType, class BooleanType, class NumberIntegerType, \
2060               class NumberUnsignedType, class NumberFloatType,              \
2061               template<typename> class AllocatorType,                       \
2062               template<typename, typename = void> class JSONSerializer,     \
2063               class BinaryType>
2064  #define NLOHMANN_BASIC_JSON_TPL                                            \
2065      basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
2066      NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
2067      AllocatorType, JSONSerializer, BinaryType>
2068  #define NLOHMANN_JSON_EXPAND( x ) x
2069  #define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
2070  #define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
2071          NLOHMANN_JSON_PASTE64, \
2072          NLOHMANN_JSON_PASTE63, \
2073          NLOHMANN_JSON_PASTE62, \
2074          NLOHMANN_JSON_PASTE61, \
2075          NLOHMANN_JSON_PASTE60, \
2076          NLOHMANN_JSON_PASTE59, \
2077          NLOHMANN_JSON_PASTE58, \
2078          NLOHMANN_JSON_PASTE57, \
2079          NLOHMANN_JSON_PASTE56, \
2080          NLOHMANN_JSON_PASTE55, \
2081          NLOHMANN_JSON_PASTE54, \
2082          NLOHMANN_JSON_PASTE53, \
2083          NLOHMANN_JSON_PASTE52, \
2084          NLOHMANN_JSON_PASTE51, \
2085          NLOHMANN_JSON_PASTE50, \
2086          NLOHMANN_JSON_PASTE49, \
2087          NLOHMANN_JSON_PASTE48, \
2088          NLOHMANN_JSON_PASTE47, \
2089          NLOHMANN_JSON_PASTE46, \
2090          NLOHMANN_JSON_PASTE45, \
2091          NLOHMANN_JSON_PASTE44, \
2092          NLOHMANN_JSON_PASTE43, \
2093          NLOHMANN_JSON_PASTE42, \
2094          NLOHMANN_JSON_PASTE41, \
2095          NLOHMANN_JSON_PASTE40, \
2096          NLOHMANN_JSON_PASTE39, \
2097          NLOHMANN_JSON_PASTE38, \
2098          NLOHMANN_JSON_PASTE37, \
2099          NLOHMANN_JSON_PASTE36, \
2100          NLOHMANN_JSON_PASTE35, \
2101          NLOHMANN_JSON_PASTE34, \
2102          NLOHMANN_JSON_PASTE33, \
2103          NLOHMANN_JSON_PASTE32, \
2104          NLOHMANN_JSON_PASTE31, \
2105          NLOHMANN_JSON_PASTE30, \
2106          NLOHMANN_JSON_PASTE29, \
2107          NLOHMANN_JSON_PASTE28, \
2108          NLOHMANN_JSON_PASTE27, \
2109          NLOHMANN_JSON_PASTE26, \
2110          NLOHMANN_JSON_PASTE25, \
2111          NLOHMANN_JSON_PASTE24, \
2112          NLOHMANN_JSON_PASTE23, \
2113          NLOHMANN_JSON_PASTE22, \
2114          NLOHMANN_JSON_PASTE21, \
2115          NLOHMANN_JSON_PASTE20, \
2116          NLOHMANN_JSON_PASTE19, \
2117          NLOHMANN_JSON_PASTE18, \
2118          NLOHMANN_JSON_PASTE17, \
2119          NLOHMANN_JSON_PASTE16, \
2120          NLOHMANN_JSON_PASTE15, \
2121          NLOHMANN_JSON_PASTE14, \
2122          NLOHMANN_JSON_PASTE13, \
2123          NLOHMANN_JSON_PASTE12, \
2124          NLOHMANN_JSON_PASTE11, \
2125          NLOHMANN_JSON_PASTE10, \
2126          NLOHMANN_JSON_PASTE9, \
2127          NLOHMANN_JSON_PASTE8, \
2128          NLOHMANN_JSON_PASTE7, \
2129          NLOHMANN_JSON_PASTE6, \
2130          NLOHMANN_JSON_PASTE5, \
2131          NLOHMANN_JSON_PASTE4, \
2132          NLOHMANN_JSON_PASTE3, \
2133          NLOHMANN_JSON_PASTE2, \
2134          NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
2135  #define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
2136  #define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
2137  #define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
2138  #define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
2139  #define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
2140  #define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
2141  #define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
2142  #define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
2143  #define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
2144  #define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
2145  #define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
2146  #define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
2147  #define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
2148  #define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
2149  #define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
2150  #define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
2151  #define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
2152  #define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
2153  #define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
2154  #define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
2155  #define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
2156  #define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
2157  #define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
2158  #define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
2159  #define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
2160  #define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
2161  #define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
2162  #define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
2163  #define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
2164  #define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
2165  #define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
2166  #define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
2167  #define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
2168  #define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
2169  #define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
2170  #define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
2171  #define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
2172  #define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
2173  #define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
2174  #define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
2175  #define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
2176  #define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
2177  #define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
2178  #define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
2179  #define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
2180  #define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
2181  #define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
2182  #define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
2183  #define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
2184  #define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
2185  #define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
2186  #define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
2187  #define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
2188  #define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
2189  #define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
2190  #define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
2191  #define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
2192  #define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
2193  #define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
2194  #define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
2195  #define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
2196  #define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
2197  #define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)
2198  #define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
2199  #define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
2200  #define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
2201      friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2202      friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2203  #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
2204      inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
2205      inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }
2206  #ifndef JSON_USE_IMPLICIT_CONVERSIONS
2207      #define JSON_USE_IMPLICIT_CONVERSIONS 1
2208  #endif
2209  #if JSON_USE_IMPLICIT_CONVERSIONS
2210      #define JSON_EXPLICIT
2211  #else
2212      #define JSON_EXPLICIT explicit
2213  #endif
2214  #ifndef JSON_DIAGNOSTICS
2215      #define JSON_DIAGNOSTICS 0
2216  #endif
2217  namespace nlohmann
2218  {
2219  namespace detail
2220  {
2221  inline void replace_substring(std::string& s, const std::string& f,
2222                                const std::string& t)
2223  {
2224      JSON_ASSERT(!f.empty());
2225      for (auto pos = s.find(f);                
2226              pos != std::string::npos;         
2227              s.replace(pos, f.size(), t),      
2228              pos = s.find(f, pos + t.size()))  
2229      {}
2230  }
2231  inline std::string escape(std::string s)
2232  {
2233      replace_substring(s, "~", "~0");
2234      replace_substring(s, "/", "~1");
2235      return s;
2236  }
2237  static void unescape(std::string& s)
2238  {
2239      replace_substring(s, "~1", "/");
2240      replace_substring(s, "~0", "~");
2241  }
2242  } 
2243  } 
2244  #include <cstddef> 
2245  namespace nlohmann
2246  {
2247  namespace detail
2248  {
2249  struct position_t
2250  {
2251      std::size_t chars_read_total = 0;
2252      std::size_t chars_read_current_line = 0;
2253      std::size_t lines_read = 0;
2254      constexpr operator size_t() const
2255      {
2256          return chars_read_total;
2257      }
2258  };
2259  } 
2260  } 
2261  namespace nlohmann
2262  {
2263  namespace detail
2264  {
2265  class exception : public std::exception
2266  {
2267    public:
2268      const char* what() const noexcept override
2269      {
2270          return m.what();
2271      }
2272      const int id; 
2273    protected:
2274      JSON_HEDLEY_NON_NULL(3)
2275      exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}
2276      static std::string name(const std::string& ename, int id_)
2277      {
2278          return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
2279      }
2280      template<typename BasicJsonType>
2281      static std::string diagnostics(const BasicJsonType& leaf_element)
2282      {
2283  #if JSON_DIAGNOSTICS
2284          std::vector<std::string> tokens;
2285          for (const auto* current = &leaf_element; current->m_parent != nullptr; current = current->m_parent)
2286          {
2287              switch (current->m_parent->type())
2288              {
2289                  case value_t::array:
2290                  {
2291                      for (std::size_t i = 0; i < current->m_parent->m_value.array->size(); ++i)
2292                      {
2293                          if (&current->m_parent->m_value.array->operator[](i) == current)
2294                          {
2295                              tokens.emplace_back(std::to_string(i));
2296                              break;
2297                          }
2298                      }
2299                      break;
2300                  }
2301                  case value_t::object:
2302                  {
2303                      for (const auto& element : *current->m_parent->m_value.object)
2304                      {
2305                          if (&element.second == current)
2306                          {
2307                              tokens.emplace_back(element.first.c_str());
2308                              break;
2309                          }
2310                      }
2311                      break;
2312                  }
2313                  case value_t::null: 
2314                  case value_t::string: 
2315                  case value_t::boolean: 
2316                  case value_t::number_integer: 
2317                  case value_t::number_unsigned: 
2318                  case value_t::number_float: 
2319                  case value_t::binary: 
2320                  case value_t::discarded: 
2321                  default:   
2322                      break; 
2323              }
2324          }
2325          if (tokens.empty())
2326          {
2327              return "";
2328          }
2329          return "(" + std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
2330                                       [](const std::string & a, const std::string & b)
2331          {
2332              return a + "/" + detail::escape(b);
2333          }) + ") ";
2334  #else
2335          static_cast<void>(leaf_element);
2336          return "";
2337  #endif
2338      }
2339    private:
2340      std::runtime_error m;
2341  };
2342  class parse_error : public exception
2343  {
2344    public:
2345      template<typename BasicJsonType>
2346      static parse_error create(int id_, const position_t& pos, const std::string& what_arg, const BasicJsonType& context)
2347      {
2348          std::string w = exception::name("parse_error", id_) + "parse error" +
2349                          position_string(pos) + ": " + exception::diagnostics(context) + what_arg;
2350          return parse_error(id_, pos.chars_read_total, w.c_str());
2351      }
2352      template<typename BasicJsonType>
2353      static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, const BasicJsonType& context)
2354      {
2355          std::string w = exception::name("parse_error", id_) + "parse error" +
2356                          (byte_ != 0 ? (" at byte " + std::to_string(byte_)) : "") +
2357                          ": " + exception::diagnostics(context) + what_arg;
2358          return parse_error(id_, byte_, w.c_str());
2359      }
2360      const std::size_t byte;
2361    private:
2362      parse_error(int id_, std::size_t byte_, const char* what_arg)
2363          : exception(id_, what_arg), byte(byte_) {}
2364      static std::string position_string(const position_t& pos)
2365      {
2366          return " at line " + std::to_string(pos.lines_read + 1) +
2367                 ", column " + std::to_string(pos.chars_read_current_line);
2368      }
2369  };
2370  class invalid_iterator : public exception
2371  {
2372    public:
2373      template<typename BasicJsonType>
2374      static invalid_iterator create(int id_, const std::string& what_arg, const BasicJsonType& context)
2375      {
2376          std::string w = exception::name("invalid_iterator", id_) + exception::diagnostics(context) + what_arg;
2377          return invalid_iterator(id_, w.c_str());
2378      }
2379    private:
2380      JSON_HEDLEY_NON_NULL(3)
2381      invalid_iterator(int id_, const char* what_arg)
2382          : exception(id_, what_arg) {}
2383  };
2384  class type_error : public exception
2385  {
2386    public:
2387      template<typename BasicJsonType>
2388      static type_error create(int id_, const std::string& what_arg, const BasicJsonType& context)
2389      {
2390          std::string w = exception::name("type_error", id_) + exception::diagnostics(context) + what_arg;
2391          return type_error(id_, w.c_str());
2392      }
2393    private:
2394      JSON_HEDLEY_NON_NULL(3)
2395      type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
2396  };
2397  class out_of_range : public exception
2398  {
2399    public:
2400      template<typename BasicJsonType>
2401      static out_of_range create(int id_, const std::string& what_arg, const BasicJsonType& context)
2402      {
2403          std::string w = exception::name("out_of_range", id_) + exception::diagnostics(context) + what_arg;
2404          return out_of_range(id_, w.c_str());
2405      }
2406    private:
2407      JSON_HEDLEY_NON_NULL(3)
2408      out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
2409  };
2410  class other_error : public exception
2411  {
2412    public:
2413      template<typename BasicJsonType>
2414      static other_error create(int id_, const std::string& what_arg, const BasicJsonType& context)
2415      {
2416          std::string w = exception::name("other_error", id_) + exception::diagnostics(context) + what_arg;
2417          return other_error(id_, w.c_str());
2418      }
2419    private:
2420      JSON_HEDLEY_NON_NULL(3)
2421      other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
2422  };
2423  }  
2424  }  
2425  #include <cstddef> 
2426  #include <type_traits> 
2427  #include <utility> 
2428  namespace nlohmann
2429  {
2430  namespace detail
2431  {
2432  template<typename T>
2433  using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;
2434  #ifdef JSON_HAS_CPP_14
2435  using std::enable_if_t;
2436  using std::index_sequence;
2437  using std::make_index_sequence;
2438  using std::index_sequence_for;
2439  #else
2440  template<bool B, typename T = void>
2441  using enable_if_t = typename std::enable_if<B, T>::type;
2442  template <typename T, T... Ints>
2443  struct integer_sequence
2444  {
2445      using value_type = T;
2446      static constexpr std::size_t size() noexcept
2447      {
2448          return sizeof...(Ints);
2449      }
2450  };
2451  template <size_t... Ints>
2452  using index_sequence = integer_sequence<size_t, Ints...>;
2453  namespace utility_internal
2454  {
2455  template <typename Seq, size_t SeqSize, size_t Rem>
2456  struct Extend;
2457  template <typename T, T... Ints, size_t SeqSize>
2458  struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
2459  {
2460      using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
2461  };
2462  template <typename T, T... Ints, size_t SeqSize>
2463  struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
2464  {
2465      using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
2466  };
2467  template <typename T, size_t N>
2468  struct Gen
2469  {
2470      using type =
2471          typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
2472  };
2473  template <typename T>
2474  struct Gen<T, 0>
2475  {
2476      using type = integer_sequence<T>;
2477  };
2478  }  
2479  template <typename T, T N>
2480  using make_integer_sequence = typename utility_internal::Gen<T, N>::type;
2481  template <size_t N>
2482  using make_index_sequence = make_integer_sequence<size_t, N>;
2483  template <typename... Ts>
2484  using index_sequence_for = make_index_sequence<sizeof...(Ts)>;
2485  #endif
2486  template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
2487  template<> struct priority_tag<0> {};
2488  template<typename T>
2489  struct static_const
2490  {
2491      static constexpr T value{};
2492  };
2493  template<typename T>
2494  constexpr T static_const<T>::value;
2495  }  
2496  }  
2497  namespace nlohmann
2498  {
2499  namespace detail
2500  {
2501  template <class T> struct identity_tag {};
2502  }  
2503  }  
2504  #include <limits> 
2505  #include <type_traits> 
2506  #include <utility> 
2507  #include <tuple> 
2508  #include <iterator> 
2509  namespace nlohmann
2510  {
2511  namespace detail
2512  {
2513  template<typename ...Ts> struct make_void
2514  {
2515      using type = void;
2516  };
2517  template<typename ...Ts> using void_t = typename make_void<Ts...>::type;
2518  } 
2519  }  
2520  namespace nlohmann
2521  {
2522  namespace detail
2523  {
2524  template<typename It, typename = void>
2525  struct iterator_types {};
2526  template<typename It>
2527  struct iterator_types <
2528      It,
2529      void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
2530      typename It::reference, typename It::iterator_category >>
2531  {
2532      using difference_type = typename It::difference_type;
2533      using value_type = typename It::value_type;
2534      using pointer = typename It::pointer;
2535      using reference = typename It::reference;
2536      using iterator_category = typename It::iterator_category;
2537  };
2538  template<typename T, typename = void>
2539  struct iterator_traits
2540  {
2541  };
2542  template<typename T>
2543  struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
2544              : iterator_types<T>
2545  {
2546  };
2547  template<typename T>
2548  struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
2549  {
2550      using iterator_category = std::random_access_iterator_tag;
2551      using value_type = T;
2552      using difference_type = ptrdiff_t;
2553      using pointer = T*;
2554      using reference = T&;
2555  };
2556  } 
2557  } 
2558  #include <type_traits>
2559  namespace nlohmann
2560  {
2561  namespace detail
2562  {
2563  struct nonesuch
2564  {
2565      nonesuch() = delete;
2566      ~nonesuch() = delete;
2567      nonesuch(nonesuch const&) = delete;
2568      nonesuch(nonesuch const&&) = delete;
2569      void operator=(nonesuch const&) = delete;
2570      void operator=(nonesuch&&) = delete;
2571  };
2572  template<class Default,
2573           class AlwaysVoid,
2574           template<class...> class Op,
2575           class... Args>
2576  struct detector
2577  {
2578      using value_t = std::false_type;
2579      using type = Default;
2580  };
2581  template<class Default, template<class...> class Op, class... Args>
2582  struct detector<Default, void_t<Op<Args...>>, Op, Args...>
2583  {
2584      using value_t = std::true_type;
2585      using type = Op<Args...>;
2586  };
2587  template<template<class...> class Op, class... Args>
2588  using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;
2589  template<template<class...> class Op, class... Args>
2590  struct is_detected_lazy : is_detected<Op, Args...> { };
2591  template<template<class...> class Op, class... Args>
2592  using detected_t = typename detector<nonesuch, void, Op, Args...>::type;
2593  template<class Default, template<class...> class Op, class... Args>
2594  using detected_or = detector<Default, void, Op, Args...>;
2595  template<class Default, template<class...> class Op, class... Args>
2596  using detected_or_t = typename detected_or<Default, Op, Args...>::type;
2597  template<class Expected, template<class...> class Op, class... Args>
2598  using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;
2599  template<class To, template<class...> class Op, class... Args>
2600  using is_detected_convertible =
2601      std::is_convertible<detected_t<Op, Args...>, To>;
2602  }  
2603  }  
2604  #ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
2605  #define INCLUDE_NLOHMANN_JSON_FWD_HPP_
2606  #include <cstdint> 
2607  #include <map> 
2608  #include <memory> 
2609  #include <string> 
2610  #include <vector> 
2611  namespace nlohmann
2612  {
2613  template<typename T = void, typename SFINAE = void>
2614  struct adl_serializer;
2615  template<template<typename U, typename V, typename... Args> class ObjectType =
2616           std::map,
2617           template<typename U, typename... Args> class ArrayType = std::vector,
2618           class StringType = std::string, class BooleanType = bool,
2619           class NumberIntegerType = std::int64_t,
2620           class NumberUnsignedType = std::uint64_t,
2621           class NumberFloatType = double,
2622           template<typename U> class AllocatorType = std::allocator,
2623           template<typename T, typename SFINAE = void> class JSONSerializer =
2624           adl_serializer,
2625           class BinaryType = std::vector<std::uint8_t>>
2626  class basic_json;
2627  template<typename BasicJsonType>
2628  class json_pointer;
2629  using json = basic_json<>;
2630  template<class Key, class T, class IgnoredLess, class Allocator>
2631  struct ordered_map;
2632  using ordered_json = basic_json<nlohmann::ordered_map>;
2633  }  
2634  #endif  
2635  namespace nlohmann
2636  {
2637  namespace detail
2638  {
2639  template<typename> struct is_basic_json : std::false_type {};
2640  NLOHMANN_BASIC_JSON_TPL_DECLARATION
2641  struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};
2642  template<typename>
2643  class json_ref;
2644  template<typename>
2645  struct is_json_ref : std::false_type {};
2646  template<typename T>
2647  struct is_json_ref<json_ref<T>> : std::true_type {};
2648  template<typename T>
2649  using mapped_type_t = typename T::mapped_type;
2650  template<typename T>
2651  using key_type_t = typename T::key_type;
2652  template<typename T>
2653  using value_type_t = typename T::value_type;
2654  template<typename T>
2655  using difference_type_t = typename T::difference_type;
2656  template<typename T>
2657  using pointer_t = typename T::pointer;
2658  template<typename T>
2659  using reference_t = typename T::reference;
2660  template<typename T>
2661  using iterator_category_t = typename T::iterator_category;
2662  template<typename T>
2663  using iterator_t = typename T::iterator;
2664  template<typename T, typename... Args>
2665  using to_json_function = decltype(T::to_json(std::declval<Args>()...));
2666  template<typename T, typename... Args>
2667  using from_json_function = decltype(T::from_json(std::declval<Args>()...));
2668  template<typename T, typename U>
2669  using get_template_function = decltype(std::declval<T>().template get<U>());
2670  template<typename BasicJsonType, typename T, typename = void>
2671  struct has_from_json : std::false_type {};
2672  template <typename BasicJsonType, typename T>
2673  struct is_getable
2674  {
2675      static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
2676  };
2677  template<typename BasicJsonType, typename T>
2678  struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2679  {
2680      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2681      static constexpr bool value =
2682          is_detected_exact<void, from_json_function, serializer,
2683          const BasicJsonType&, T&>::value;
2684  };
2685  template<typename BasicJsonType, typename T, typename = void>
2686  struct has_non_default_from_json : std::false_type {};
2687  template<typename BasicJsonType, typename T>
2688  struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2689  {
2690      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2691      static constexpr bool value =
2692          is_detected_exact<T, from_json_function, serializer,
2693          const BasicJsonType&>::value;
2694  };
2695  template<typename BasicJsonType, typename T, typename = void>
2696  struct has_to_json : std::false_type {};
2697  template<typename BasicJsonType, typename T>
2698  struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
2699  {
2700      using serializer = typename BasicJsonType::template json_serializer<T, void>;
2701      static constexpr bool value =
2702          is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
2703          T>::value;
2704  };
2705  template<class...> struct conjunction : std::true_type { };
2706  template<class B1> struct conjunction<B1> : B1 { };
2707  template<class B1, class... Bn>
2708  struct conjunction<B1, Bn...>
2709  : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};
2710  template<class B> struct negation : std::integral_constant < bool, !B::value > { };
2711  template <typename T>
2712  struct is_default_constructible : std::is_default_constructible<T> {};
2713  template <typename T1, typename T2>
2714  struct is_default_constructible<std::pair<T1, T2>>
2715              : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
2716  template <typename T1, typename T2>
2717  struct is_default_constructible<const std::pair<T1, T2>>
2718              : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};
2719  template <typename... Ts>
2720  struct is_default_constructible<std::tuple<Ts...>>
2721              : conjunction<is_default_constructible<Ts>...> {};
2722  template <typename... Ts>
2723  struct is_default_constructible<const std::tuple<Ts...>>
2724              : conjunction<is_default_constructible<Ts>...> {};
2725  template <typename T, typename... Args>
2726  struct is_constructible : std::is_constructible<T, Args...> {};
2727  template <typename T1, typename T2>
2728  struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};
2729  template <typename T1, typename T2>
2730  struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};
2731  template <typename... Ts>
2732  struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};
2733  template <typename... Ts>
2734  struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};
2735  template<typename T, typename = void>
2736  struct is_iterator_traits : std::false_type {};
2737  template<typename T>
2738  struct is_iterator_traits<iterator_traits<T>>
2739  {
2740    private:
2741      using traits = iterator_traits<T>;
2742    public:
2743      static constexpr auto value =
2744          is_detected<value_type_t, traits>::value &&
2745          is_detected<difference_type_t, traits>::value &&
2746          is_detected<pointer_t, traits>::value &&
2747          is_detected<iterator_category_t, traits>::value &&
2748          is_detected<reference_t, traits>::value;
2749  };
2750  template<typename T, typename = void>
2751  struct is_complete_type : std::false_type {};
2752  template<typename T>
2753  struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};
2754  template<typename BasicJsonType, typename CompatibleObjectType,
2755           typename = void>
2756  struct is_compatible_object_type_impl : std::false_type {};
2757  template<typename BasicJsonType, typename CompatibleObjectType>
2758  struct is_compatible_object_type_impl <
2759      BasicJsonType, CompatibleObjectType,
2760      enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
2761      is_detected<key_type_t, CompatibleObjectType>::value >>
2762  {
2763      using object_t = typename BasicJsonType::object_t;
2764      static constexpr bool value =
2765          is_constructible<typename object_t::key_type,
2766          typename CompatibleObjectType::key_type>::value &&
2767          is_constructible<typename object_t::mapped_type,
2768          typename CompatibleObjectType::mapped_type>::value;
2769  };
2770  template<typename BasicJsonType, typename CompatibleObjectType>
2771  struct is_compatible_object_type
2772      : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};
2773  template<typename BasicJsonType, typename ConstructibleObjectType,
2774           typename = void>
2775  struct is_constructible_object_type_impl : std::false_type {};
2776  template<typename BasicJsonType, typename ConstructibleObjectType>
2777  struct is_constructible_object_type_impl <
2778      BasicJsonType, ConstructibleObjectType,
2779      enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
2780      is_detected<key_type_t, ConstructibleObjectType>::value >>
2781  {
2782      using object_t = typename BasicJsonType::object_t;
2783      static constexpr bool value =
2784          (is_default_constructible<ConstructibleObjectType>::value &&
2785           (std::is_move_assignable<ConstructibleObjectType>::value ||
2786            std::is_copy_assignable<ConstructibleObjectType>::value) &&
2787           (is_constructible<typename ConstructibleObjectType::key_type,
2788            typename object_t::key_type>::value &&
2789            std::is_same <
2790            typename object_t::mapped_type,
2791            typename ConstructibleObjectType::mapped_type >::value)) ||
2792          (has_from_json<BasicJsonType,
2793           typename ConstructibleObjectType::mapped_type>::value ||
2794           has_non_default_from_json <
2795           BasicJsonType,
2796           typename ConstructibleObjectType::mapped_type >::value);
2797  };
2798  template<typename BasicJsonType, typename ConstructibleObjectType>
2799  struct is_constructible_object_type
2800      : is_constructible_object_type_impl<BasicJsonType,
2801        ConstructibleObjectType> {};
2802  template<typename BasicJsonType, typename CompatibleStringType,
2803           typename = void>
2804  struct is_compatible_string_type_impl : std::false_type {};
2805  template<typename BasicJsonType, typename CompatibleStringType>
2806  struct is_compatible_string_type_impl <
2807      BasicJsonType, CompatibleStringType,
2808      enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
2809      value_type_t, CompatibleStringType>::value >>
2810  {
2811      static constexpr auto value =
2812          is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
2813  };
2814  template<typename BasicJsonType, typename ConstructibleStringType>
2815  struct is_compatible_string_type
2816      : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> {};
2817  template<typename BasicJsonType, typename ConstructibleStringType,
2818           typename = void>
2819  struct is_constructible_string_type_impl : std::false_type {};
2820  template<typename BasicJsonType, typename ConstructibleStringType>
2821  struct is_constructible_string_type_impl <
2822      BasicJsonType, ConstructibleStringType,
2823      enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
2824      value_type_t, ConstructibleStringType>::value >>
2825  {
2826      static constexpr auto value =
2827          is_constructible<ConstructibleStringType,
2828          typename BasicJsonType::string_t>::value;
2829  };
2830  template<typename BasicJsonType, typename ConstructibleStringType>
2831  struct is_constructible_string_type
2832      : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> {};
2833  template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
2834  struct is_compatible_array_type_impl : std::false_type {};
2835  template<typename BasicJsonType, typename CompatibleArrayType>
2836  struct is_compatible_array_type_impl <
2837      BasicJsonType, CompatibleArrayType,
2838      enable_if_t < is_detected<value_type_t, CompatibleArrayType>::value&&
2839      is_detected<iterator_t, CompatibleArrayType>::value&&
2840      !is_iterator_traits <
2841      iterator_traits<CompatibleArrayType >>::value >>
2842  {
2843      static constexpr bool value =
2844          is_constructible<BasicJsonType,
2845          typename CompatibleArrayType::value_type>::value;
2846  };
2847  template<typename BasicJsonType, typename CompatibleArrayType>
2848  struct is_compatible_array_type
2849      : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};
2850  template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
2851  struct is_constructible_array_type_impl : std::false_type {};
2852  template<typename BasicJsonType, typename ConstructibleArrayType>
2853  struct is_constructible_array_type_impl <
2854      BasicJsonType, ConstructibleArrayType,
2855      enable_if_t<std::is_same<ConstructibleArrayType,
2856      typename BasicJsonType::value_type>::value >>
2857              : std::true_type {};
2858  template<typename BasicJsonType, typename ConstructibleArrayType>
2859  struct is_constructible_array_type_impl <
2860      BasicJsonType, ConstructibleArrayType,
2861      enable_if_t < !std::is_same<ConstructibleArrayType,
2862      typename BasicJsonType::value_type>::value&&
2863      is_default_constructible<ConstructibleArrayType>::value&&
2864  (std::is_move_assignable<ConstructibleArrayType>::value ||
2865   std::is_copy_assignable<ConstructibleArrayType>::value)&&
2866  is_detected<value_type_t, ConstructibleArrayType>::value&&
2867  is_detected<iterator_t, ConstructibleArrayType>::value&&
2868  is_complete_type <
2869  detected_t<value_type_t, ConstructibleArrayType >>::value >>
2870  {
2871      static constexpr bool value =
2872          !is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value &&
2873          (std::is_same<typename ConstructibleArrayType::value_type,
2874           typename BasicJsonType::array_t::value_type>::value ||
2875           has_from_json<BasicJsonType,
2876           typename ConstructibleArrayType::value_type>::value ||
2877           has_non_default_from_json <
2878           BasicJsonType, typename ConstructibleArrayType::value_type >::value);
2879  };
2880  template<typename BasicJsonType, typename ConstructibleArrayType>
2881  struct is_constructible_array_type
2882      : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};
2883  template<typename RealIntegerType, typename CompatibleNumberIntegerType,
2884           typename = void>
2885  struct is_compatible_integer_type_impl : std::false_type {};
2886  template<typename RealIntegerType, typename CompatibleNumberIntegerType>
2887  struct is_compatible_integer_type_impl <
2888      RealIntegerType, CompatibleNumberIntegerType,
2889      enable_if_t < std::is_integral<RealIntegerType>::value&&
2890      std::is_integral<CompatibleNumberIntegerType>::value&&
2891      !std::is_same<bool, CompatibleNumberIntegerType>::value >>
2892  {
2893      using RealLimits = std::numeric_limits<RealIntegerType>;
2894      using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;
2895      static constexpr auto value =
2896          is_constructible<RealIntegerType,
2897          CompatibleNumberIntegerType>::value &&
2898          CompatibleLimits::is_integer &&
2899          RealLimits::is_signed == CompatibleLimits::is_signed;
2900  };
2901  template<typename RealIntegerType, typename CompatibleNumberIntegerType>
2902  struct is_compatible_integer_type
2903      : is_compatible_integer_type_impl<RealIntegerType,
2904        CompatibleNumberIntegerType> {};
2905  template<typename BasicJsonType, typename CompatibleType, typename = void>
2906  struct is_compatible_type_impl: std::false_type {};
2907  template<typename BasicJsonType, typename CompatibleType>
2908  struct is_compatible_type_impl <
2909      BasicJsonType, CompatibleType,
2910      enable_if_t<is_complete_type<CompatibleType>::value >>
2911  {
2912      static constexpr bool value =
2913          has_to_json<BasicJsonType, CompatibleType>::value;
2914  };
2915  template<typename BasicJsonType, typename CompatibleType>
2916  struct is_compatible_type
2917      : is_compatible_type_impl<BasicJsonType, CompatibleType> {};
2918  template<typename T1, typename T2>
2919  struct is_constructible_tuple : std::false_type {};
2920  template<typename T1, typename... Args>
2921  struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};
2922  template <typename T>
2923  struct is_ordered_map
2924  {
2925      using one = char;
2926      struct two
2927      {
2928          char x[2]; 
2929      };
2930      template <typename C> static one test( decltype(&C::capacity) ) ;
2931      template <typename C> static two test(...);
2932      enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; 
2933  };
2934  template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
2935  T conditional_static_cast(U value)
2936  {
2937      return static_cast<T>(value);
2938  }
2939  template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
2940  T conditional_static_cast(U value)
2941  {
2942      return value;
2943  }
2944  }  
2945  }  
2946  namespace nlohmann
2947  {
2948  namespace detail
2949  {
2950  template<typename BasicJsonType>
2951  void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
2952  {
2953      if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
2954      {
2955          JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name()), j));
2956      }
2957      n = nullptr;
2958  }
2959  template < typename BasicJsonType, typename ArithmeticType,
2960             enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
2961                           !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
2962                           int > = 0 >
2963  void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
2964  {
2965      switch (static_cast<value_t>(j))
2966      {
2967          case value_t::number_unsigned:
2968          {
2969              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
2970              break;
2971          }
2972          case value_t::number_integer:
2973          {
2974              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
2975              break;
2976          }
2977          case value_t::number_float:
2978          {
2979              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
2980              break;
2981          }
2982          case value_t::null:
2983          case value_t::object:
2984          case value_t::array:
2985          case value_t::string:
2986          case value_t::boolean:
2987          case value_t::binary:
2988          case value_t::discarded:
2989          default:
2990              JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name()), j));
2991      }
2992  }
2993  template<typename BasicJsonType>
2994  void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
2995  {
2996      if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
2997      {
2998          JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name()), j));
2999      }
3000      b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
3001  }
3002  template<typename BasicJsonType>
3003  void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
3004  {
3005      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3006      {
3007          JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name()), j));
3008      }
3009      s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
3010  }
3011  template <
3012      typename BasicJsonType, typename ConstructibleStringType,
3013      enable_if_t <
3014          is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value&&
3015          !std::is_same<typename BasicJsonType::string_t,
3016                        ConstructibleStringType>::value,
3017          int > = 0 >
3018  void from_json(const BasicJsonType& j, ConstructibleStringType& s)
3019  {
3020      if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
3021      {
3022          JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name()), j));
3023      }
3024      s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
3025  }
3026  template<typename BasicJsonType>
3027  void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
3028  {
3029      get_arithmetic_value(j, val);
3030  }
3031  template<typename BasicJsonType>
3032  void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
3033  {
3034      get_arithmetic_value(j, val);
3035  }
3036  template<typename BasicJsonType>
3037  void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
3038  {
3039      get_arithmetic_value(j, val);
3040  }
3041  template<typename BasicJsonType, typename EnumType,
3042           enable_if_t<std::is_enum<EnumType>::value, int> = 0>
3043  void from_json(const BasicJsonType& j, EnumType& e)
3044  {
3045      typename std::underlying_type<EnumType>::type val;
3046      get_arithmetic_value(j, val);
3047      e = static_cast<EnumType>(val);
3048  }
3049  template<typename BasicJsonType, typename T, typename Allocator,
3050           enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
3051  void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
3052  {
3053      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3054      {
3055          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3056      }
3057      l.clear();
3058      std::transform(j.rbegin(), j.rend(),
3059                     std::front_inserter(l), [](const BasicJsonType & i)
3060      {
3061          return i.template get<T>();
3062      });
3063  }
3064  template<typename BasicJsonType, typename T,
3065           enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
3066  void from_json(const BasicJsonType& j, std::valarray<T>& l)
3067  {
3068      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3069      {
3070          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3071      }
3072      l.resize(j.size());
3073      std::transform(j.begin(), j.end(), std::begin(l),
3074                     [](const BasicJsonType & elem)
3075      {
3076          return elem.template get<T>();
3077      });
3078  }
3079  template<typename BasicJsonType, typename T, std::size_t N>
3080  auto from_json(const BasicJsonType& j, T (&arr)[N]) 
3081  -> decltype(j.template get<T>(), void())
3082  {
3083      for (std::size_t i = 0; i < N; ++i)
3084      {
3085          arr[i] = j.at(i).template get<T>();
3086      }
3087  }
3088  template<typename BasicJsonType>
3089  void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> &bsol;*unused*/)
3090  {
3091      arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
3092  }
3093  template<typename BasicJsonType, typename T, std::size_t N>
3094  auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
3095                            priority_tag<2> &bsol;*unused*/)
3096  -> decltype(j.template get<T>(), void())
3097  {
3098      for (std::size_t i = 0; i < N; ++i)
3099      {
3100          arr[i] = j.at(i).template get<T>();
3101      }
3102  }
3103  template<typename BasicJsonType, typename ConstructibleArrayType,
3104           enable_if_t<
3105               std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
3106               int> = 0>
3107  auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> &bsol;*unused*/)
3108  -> decltype(
3109      arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
3110      j.template get<typename ConstructibleArrayType::value_type>(),
3111      void())
3112  {
3113      using std::end;
3114      ConstructibleArrayType ret;
3115      ret.reserve(j.size());
3116      std::transform(j.begin(), j.end(),
3117                     std::inserter(ret, end(ret)), [](const BasicJsonType & i)
3118      {
3119          return i.template get<typename ConstructibleArrayType::value_type>();
3120      });
3121      arr = std::move(ret);
3122  }
3123  template<typename BasicJsonType, typename ConstructibleArrayType,
3124           enable_if_t<
3125               std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
3126               int> = 0>
3127  void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
3128                            priority_tag<0> &bsol;*unused*/)
3129  {
3130      using std::end;
3131      ConstructibleArrayType ret;
3132      std::transform(
3133          j.begin(), j.end(), std::inserter(ret, end(ret)),
3134          [](const BasicJsonType & i)
3135      {
3136          return i.template get<typename ConstructibleArrayType::value_type>();
3137      });
3138      arr = std::move(ret);
3139  }
3140  template < typename BasicJsonType, typename ConstructibleArrayType,
3141             enable_if_t <
3142                 is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
3143                 !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
3144                 !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
3145                 !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
3146                 !is_basic_json<ConstructibleArrayType>::value,
3147                 int > = 0 >
3148  auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
3149  -> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
3150  j.template get<typename ConstructibleArrayType::value_type>(),
3151  void())
3152  {
3153      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3154      {
3155          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3156      }
3157      from_json_array_impl(j, arr, priority_tag<3> {});
3158  }
3159  template < typename BasicJsonType, typename T, std::size_t... Idx >
3160  std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
3161          identity_tag<std::array<T, sizeof...(Idx)>> &bsol;*unused*/, index_sequence<Idx...> &bsol;*unused*/)
3162  {
3163      return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
3164  }
3165  template < typename BasicJsonType, typename T, std::size_t N >
3166  auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
3167  -> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
3168  {
3169      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3170      {
3171          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3172      }
3173      return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
3174  }
3175  template<typename BasicJsonType>
3176  void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
3177  {
3178      if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
3179      {
3180          JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(j.type_name()), j));
3181      }
3182      bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
3183  }
3184  template<typename BasicJsonType, typename ConstructibleObjectType,
3185           enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
3186  void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
3187  {
3188      if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
3189      {
3190          JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name()), j));
3191      }
3192      ConstructibleObjectType ret;
3193      const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
3194      using value_type = typename ConstructibleObjectType::value_type;
3195      std::transform(
3196          inner_object->begin(), inner_object->end(),
3197          std::inserter(ret, ret.begin()),
3198          [](typename BasicJsonType::object_t::value_type const & p)
3199      {
3200          return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
3201      });
3202      obj = std::move(ret);
3203  }
3204  template < typename BasicJsonType, typename ArithmeticType,
3205             enable_if_t <
3206                 std::is_arithmetic<ArithmeticType>::value&&
3207                 !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
3208                 !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
3209                 !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
3210                 !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
3211                 int > = 0 >
3212  void from_json(const BasicJsonType& j, ArithmeticType& val)
3213  {
3214      switch (static_cast<value_t>(j))
3215      {
3216          case value_t::number_unsigned:
3217          {
3218              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
3219              break;
3220          }
3221          case value_t::number_integer:
3222          {
3223              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
3224              break;
3225          }
3226          case value_t::number_float:
3227          {
3228              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
3229              break;
3230          }
3231          case value_t::boolean:
3232          {
3233              val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
3234              break;
3235          }
3236          case value_t::null:
3237          case value_t::object:
3238          case value_t::array:
3239          case value_t::string:
3240          case value_t::binary:
3241          case value_t::discarded:
3242          default:
3243              JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name()), j));
3244      }
3245  }
3246  template<typename BasicJsonType, typename... Args, std::size_t... Idx>
3247  std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> &bsol;*unused*/)
3248  {
3249      return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);
3250  }
3251  template < typename BasicJsonType, class A1, class A2 >
3252  std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> &bsol;*unused*/, priority_tag<0> &bsol;*unused*/)
3253  {
3254      return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
3255              std::forward<BasicJsonType>(j).at(1).template get<A2>()};
3256  }
3257  template<typename BasicJsonType, typename A1, typename A2>
3258  void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> &bsol;*unused*/)
3259  {
3260      p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
3261  }
3262  template<typename BasicJsonType, typename... Args>
3263  std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> &bsol;*unused*/, priority_tag<2> &bsol;*unused*/)
3264  {
3265      return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
3266  }
3267  template<typename BasicJsonType, typename... Args>
3268  void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> &bsol;*unused*/)
3269  {
3270      t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
3271  }
3272  template<typename BasicJsonType, typename TupleRelated>
3273  auto from_json(BasicJsonType&& j, TupleRelated&& t)
3274  -> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
3275  {
3276      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3277      {
3278          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3279      }
3280      return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
3281  }
3282  template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
3283             typename = enable_if_t < !std::is_constructible <
3284                                          typename BasicJsonType::string_t, Key >::value >>
3285  void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
3286  {
3287      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3288      {
3289          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3290      }
3291      m.clear();
3292      for (const auto& p : j)
3293      {
3294          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3295          {
3296              JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name()), j));
3297          }
3298          m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
3299      }
3300  }
3301  template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
3302             typename = enable_if_t < !std::is_constructible <
3303                                          typename BasicJsonType::string_t, Key >::value >>
3304  void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
3305  {
3306      if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
3307      {
3308          JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name()), j));
3309      }
3310      m.clear();
3311      for (const auto& p : j)
3312      {
3313          if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
3314          {
3315              JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name()), j));
3316          }
3317          m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
3318      }
3319  }
3320  struct from_json_fn
3321  {
3322      template<typename BasicJsonType, typename T>
3323      auto operator()(const BasicJsonType& j, T&& val) const
3324      noexcept(noexcept(from_json(j, std::forward<T>(val))))
3325      -> decltype(from_json(j, std::forward<T>(val)))
3326      {
3327          return from_json(j, std::forward<T>(val));
3328      }
3329  };
3330  }  
3331  namespace 
3332  {
3333  constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value; 
3334  } 
3335  } 
3336  #include <algorithm> 
3337  #include <iterator> 
3338  #include <string> 
3339  #include <tuple> 
3340  #include <type_traits> 
3341  #include <utility> 
3342  #include <valarray> 
3343  #include <vector> 
3344  #include <cstddef> 
3345  #include <iterator> 
3346  #include <string> 
3347  #include <tuple> 
3348  #include <utility> 
3349  namespace nlohmann
3350  {
3351  namespace detail
3352  {
3353  template<typename string_type>
3354  void int_to_string( string_type& target, std::size_t value )
3355  {
3356      using std::to_string;
3357      target = to_string(value);
3358  }
3359  template<typename IteratorType> class iteration_proxy_value
3360  {
3361    public:
3362      using difference_type = std::ptrdiff_t;
3363      using value_type = iteration_proxy_value;
3364      using pointer = value_type * ;
3365      using reference = value_type & ;
3366      using iterator_category = std::input_iterator_tag;
3367      using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;
3368    private:
3369      IteratorType anchor;
3370      std::size_t array_index = 0;
3371      mutable std::size_t array_index_last = 0;
3372      mutable string_type array_index_str = "0";
3373      const string_type empty_str{};
3374    public:
3375      explicit iteration_proxy_value(IteratorType it) noexcept
3376          : anchor(std::move(it))
3377      {}
3378      iteration_proxy_value& operator*()
3379      {
3380          return *this;
3381      }
3382      iteration_proxy_value& operator++()
3383      {
3384          ++anchor;
3385          ++array_index;
3386          return *this;
3387      }
3388      bool operator==(const iteration_proxy_value& o) const
3389      {
3390          return anchor == o.anchor;
3391      }
3392      bool operator!=(const iteration_proxy_value& o) const
3393      {
3394          return anchor != o.anchor;
3395      }
3396      const string_type& key() const
3397      {
3398          JSON_ASSERT(anchor.m_object != nullptr);
3399          switch (anchor.m_object->type())
3400          {
3401              case value_t::array:
3402              {
3403                  if (array_index != array_index_last)
3404                  {
3405                      int_to_string( array_index_str, array_index );
3406                      array_index_last = array_index;
3407                  }
3408                  return array_index_str;
3409              }
3410              case value_t::object:
3411                  return anchor.key();
3412              case value_t::null:
3413              case value_t::string:
3414              case value_t::boolean:
3415              case value_t::number_integer:
3416              case value_t::number_unsigned:
3417              case value_t::number_float:
3418              case value_t::binary:
3419              case value_t::discarded:
3420              default:
3421                  return empty_str;
3422          }
3423      }
3424      typename IteratorType::reference value() const
3425      {
3426          return anchor.value();
3427      }
3428  };
3429  template<typename IteratorType> class iteration_proxy
3430  {
3431    private:
3432      typename IteratorType::reference container;
3433    public:
3434      explicit iteration_proxy(typename IteratorType::reference cont) noexcept
3435          : container(cont) {}
3436      iteration_proxy_value<IteratorType> begin() noexcept
3437      {
3438          return iteration_proxy_value<IteratorType>(container.begin());
3439      }
3440      iteration_proxy_value<IteratorType> end() noexcept
3441      {
3442          return iteration_proxy_value<IteratorType>(container.end());
3443      }
3444  };
3445  template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
3446  auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
3447  {
3448      return i.key();
3449  }
3450  template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
3451  auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
3452  {
3453      return i.value();
3454  }
3455  }  
3456  }  
3457  namespace std
3458  {
3459  #if defined(__clang__)
3460      #pragma clang diagnostic push
3461      #pragma clang diagnostic ignored "-Wmismatched-tags"
3462  #endif
3463  template<typename IteratorType>
3464  class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>
3465              : public std::integral_constant<std::size_t, 2> {};
3466  template<std::size_t N, typename IteratorType>
3467  class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>
3468  {
3469    public:
3470      using type = decltype(
3471                       get<N>(std::declval <
3472                              ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
3473  };
3474  #if defined(__clang__)
3475      #pragma clang diagnostic pop
3476  #endif
3477  } 
3478  namespace nlohmann
3479  {
3480  namespace detail
3481  {
3482  template<value_t> struct external_constructor;
3483  template<>
3484  struct external_constructor<value_t::boolean>
3485  {
3486      template<typename BasicJsonType>
3487      static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
3488      {
3489          j.m_value.destroy(j.m_type);
3490          j.m_type = value_t::boolean;
3491          j.m_value = b;
3492          j.assert_invariant();
3493      }
3494  };
3495  template<>
3496  struct external_constructor<value_t::string>
3497  {
3498      template<typename BasicJsonType>
3499      static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
3500      {
3501          j.m_value.destroy(j.m_type);
3502          j.m_type = value_t::string;
3503          j.m_value = s;
3504          j.assert_invariant();
3505      }
3506      template<typename BasicJsonType>
3507      static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
3508      {
3509          j.m_value.destroy(j.m_type);
3510          j.m_type = value_t::string;
3511          j.m_value = std::move(s);
3512          j.assert_invariant();
3513      }
3514      template < typename BasicJsonType, typename CompatibleStringType,
3515                 enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
3516                               int > = 0 >
3517      static void construct(BasicJsonType& j, const CompatibleStringType& str)
3518      {
3519          j.m_value.destroy(j.m_type);
3520          j.m_type = value_t::string;
3521          j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
3522          j.assert_invariant();
3523      }
3524  };
3525  template<>
3526  struct external_constructor<value_t::binary>
3527  {
3528      template<typename BasicJsonType>
3529      static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
3530      {
3531          j.m_value.destroy(j.m_type);
3532          j.m_type = value_t::binary;
3533          j.m_value = typename BasicJsonType::binary_t(b);
3534          j.assert_invariant();
3535      }
3536      template<typename BasicJsonType>
3537      static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
3538      {
3539          j.m_value.destroy(j.m_type);
3540          j.m_type = value_t::binary;
3541          j.m_value = typename BasicJsonType::binary_t(std::move(b));
3542          j.assert_invariant();
3543      }
3544  };
3545  template<>
3546  struct external_constructor<value_t::number_float>
3547  {
3548      template<typename BasicJsonType>
3549      static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
3550      {
3551          j.m_value.destroy(j.m_type);
3552          j.m_type = value_t::number_float;
3553          j.m_value = val;
3554          j.assert_invariant();
3555      }
3556  };
3557  template<>
3558  struct external_constructor<value_t::number_unsigned>
3559  {
3560      template<typename BasicJsonType>
3561      static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
3562      {
3563          j.m_value.destroy(j.m_type);
3564          j.m_type = value_t::number_unsigned;
3565          j.m_value = val;
3566          j.assert_invariant();
3567      }
3568  };
3569  template<>
3570  struct external_constructor<value_t::number_integer>
3571  {
3572      template<typename BasicJsonType>
3573      static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
3574      {
3575          j.m_value.destroy(j.m_type);
3576          j.m_type = value_t::number_integer;
3577          j.m_value = val;
3578          j.assert_invariant();
3579      }
3580  };
3581  template<>
3582  struct external_constructor<value_t::array>
3583  {
3584      template<typename BasicJsonType>
3585      static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
3586      {
3587          j.m_value.destroy(j.m_type);
3588          j.m_type = value_t::array;
3589          j.m_value = arr;
3590          j.set_parents();
3591          j.assert_invariant();
3592      }
3593      template<typename BasicJsonType>
3594      static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
3595      {
3596          j.m_value.destroy(j.m_type);
3597          j.m_type = value_t::array;
3598          j.m_value = std::move(arr);
3599          j.set_parents();
3600          j.assert_invariant();
3601      }
3602      template < typename BasicJsonType, typename CompatibleArrayType,
3603                 enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
3604                               int > = 0 >
3605      static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
3606      {
3607          using std::begin;
3608          using std::end;
3609          j.m_value.destroy(j.m_type);
3610          j.m_type = value_t::array;
3611          j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
3612          j.set_parents();
3613          j.assert_invariant();
3614      }
3615      template<typename BasicJsonType>
3616      static void construct(BasicJsonType& j, const std::vector<bool>& arr)
3617      {
3618          j.m_value.destroy(j.m_type);
3619          j.m_type = value_t::array;
3620          j.m_value = value_t::array;
3621          j.m_value.array->reserve(arr.size());
3622          for (const bool x : arr)
3623          {
3624              j.m_value.array->push_back(x);
3625              j.set_parent(j.m_value.array->back());
3626          }
3627          j.assert_invariant();
3628      }
3629      template<typename BasicJsonType, typename T,
3630               enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
3631      static void construct(BasicJsonType& j, const std::valarray<T>& arr)
3632      {
3633          j.m_value.destroy(j.m_type);
3634          j.m_type = value_t::array;
3635          j.m_value = value_t::array;
3636          j.m_value.array->resize(arr.size());
3637          if (arr.size() > 0)
3638          {
3639              std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
3640          }
3641          j.set_parents();
3642          j.assert_invariant();
3643      }
3644  };
3645  template<>
3646  struct external_constructor<value_t::object>
3647  {
3648      template<typename BasicJsonType>
3649      static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
3650      {
3651          j.m_value.destroy(j.m_type);
3652          j.m_type = value_t::object;
3653          j.m_value = obj;
3654          j.set_parents();
3655          j.assert_invariant();
3656      }
3657      template<typename BasicJsonType>
3658      static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
3659      {
3660          j.m_value.destroy(j.m_type);
3661          j.m_type = value_t::object;
3662          j.m_value = std::move(obj);
3663          j.set_parents();
3664          j.assert_invariant();
3665      }
3666      template < typename BasicJsonType, typename CompatibleObjectType,
3667                 enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
3668      static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
3669      {
3670          using std::begin;
3671          using std::end;
3672          j.m_value.destroy(j.m_type);
3673          j.m_type = value_t::object;
3674          j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
3675          j.set_parents();
3676          j.assert_invariant();
3677      }
3678  };
3679  template<typename BasicJsonType, typename T,
3680           enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
3681  void to_json(BasicJsonType& j, T b) noexcept
3682  {
3683      external_constructor<value_t::boolean>::construct(j, b);
3684  }
3685  template<typename BasicJsonType, typename CompatibleString,
3686           enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
3687  void to_json(BasicJsonType& j, const CompatibleString& s)
3688  {
3689      external_constructor<value_t::string>::construct(j, s);
3690  }
3691  template<typename BasicJsonType>
3692  void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
3693  {
3694      external_constructor<value_t::string>::construct(j, std::move(s));
3695  }
3696  template<typename BasicJsonType, typename FloatType,
3697           enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
3698  void to_json(BasicJsonType& j, FloatType val) noexcept
3699  {
3700      external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
3701  }
3702  template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
3703           enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
3704  void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
3705  {
3706      external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
3707  }
3708  template<typename BasicJsonType, typename CompatibleNumberIntegerType,
3709           enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
3710  void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
3711  {
3712      external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
3713  }
3714  template<typename BasicJsonType, typename EnumType,
3715           enable_if_t<std::is_enum<EnumType>::value, int> = 0>
3716  void to_json(BasicJsonType& j, EnumType e) noexcept
3717  {
3718      using underlying_type = typename std::underlying_type<EnumType>::type;
3719      external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
3720  }
3721  template<typename BasicJsonType>
3722  void to_json(BasicJsonType& j, const std::vector<bool>& e)
3723  {
3724      external_constructor<value_t::array>::construct(j, e);
3725  }
3726  template < typename BasicJsonType, typename CompatibleArrayType,
3727             enable_if_t < is_compatible_array_type<BasicJsonType,
3728                           CompatibleArrayType>::value&&
3729                           !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
3730                           !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
3731                           !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
3732                           !is_basic_json<CompatibleArrayType>::value,
3733                           int > = 0 >
3734  void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
3735  {
3736      external_constructor<value_t::array>::construct(j, arr);
3737  }
3738  template<typename BasicJsonType>
3739  void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
3740  {
3741      external_constructor<value_t::binary>::construct(j, bin);
3742  }
3743  template<typename BasicJsonType, typename T,
3744           enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
3745  void to_json(BasicJsonType& j, const std::valarray<T>& arr)
3746  {
3747      external_constructor<value_t::array>::construct(j, std::move(arr));
3748  }
3749  template<typename BasicJsonType>
3750  void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
3751  {
3752      external_constructor<value_t::array>::construct(j, std::move(arr));
3753  }
3754  template < typename BasicJsonType, typename CompatibleObjectType,
3755             enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
3756  void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
3757  {
3758      external_constructor<value_t::object>::construct(j, obj);
3759  }
3760  template<typename BasicJsonType>
3761  void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
3762  {
3763      external_constructor<value_t::object>::construct(j, std::move(obj));
3764  }
3765  template <
3766      typename BasicJsonType, typename T, std::size_t N,
3767      enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
3768                    const T(&)[N]>::value, 
3769                    int > = 0 >
3770  void to_json(BasicJsonType& j, const T(&arr)[N]) 
3771  {
3772      external_constructor<value_t::array>::construct(j, arr);
3773  }
3774  template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
3775  void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
3776  {
3777      j = { p.first, p.second };
3778  }
3779  template<typename BasicJsonType, typename T,
3780           enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
3781  void to_json(BasicJsonType& j, const T& b)
3782  {
3783      j = { {b.key(), b.value()} };
3784  }
3785  template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
3786  void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> &bsol;*unused*/)
3787  {
3788      j = { std::get<Idx>(t)... };
3789  }
3790  template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
3791  void to_json(BasicJsonType& j, const T& t)
3792  {
3793      to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
3794  }
3795  struct to_json_fn
3796  {
3797      template<typename BasicJsonType, typename T>
3798      auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
3799      -> decltype(to_json(j, std::forward<T>(val)), void())
3800      {
3801          return to_json(j, std::forward<T>(val));
3802      }
3803  };
3804  }  
3805  namespace 
3806  {
3807  constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value; 
3808  } 
3809  } 
3810  namespace nlohmann
3811  {
3812  template<typename ValueType, typename>
3813  struct adl_serializer
3814  {
3815      template<typename BasicJsonType, typename TargetType = ValueType>
3816      static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
3817          noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
3818      -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
3819      {
3820          ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
3821      }
3822      template<typename BasicJsonType, typename TargetType = ValueType>
3823      static auto from_json(BasicJsonType && j) noexcept(
3824      noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
3825      -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
3826      {
3827          return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
3828      }
3829      template<typename BasicJsonType, typename TargetType = ValueType>
3830      static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
3831          noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
3832      -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
3833      {
3834          ::nlohmann::to_json(j, std::forward<TargetType>(val));
3835      }
3836  };
3837  }  
3838  #include <cstdint> 
3839  #include <tuple> 
3840  #include <utility> 
3841  namespace nlohmann
3842  {
3843  template<typename BinaryType>
3844  class byte_container_with_subtype : public BinaryType
3845  {
3846    public:
3847      using container_type = BinaryType;
3848      using subtype_type = std::uint64_t;
3849      byte_container_with_subtype() noexcept(noexcept(container_type()))
3850          : container_type()
3851      {}
3852      byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
3853          : container_type(b)
3854      {}
3855      byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
3856          : container_type(std::move(b))
3857      {}
3858      byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
3859          : container_type(b)
3860          , m_subtype(subtype_)
3861          , m_has_subtype(true)
3862      {}
3863      byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
3864          : container_type(std::move(b))
3865          , m_subtype(subtype_)
3866          , m_has_subtype(true)
3867      {}
3868      bool operator==(const byte_container_with_subtype& rhs) const
3869      {
3870          return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
3871                 std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
3872      }
3873      bool operator!=(const byte_container_with_subtype& rhs) const
3874      {
3875          return !(rhs == *this);
3876      }
3877      void set_subtype(subtype_type subtype_) noexcept
3878      {
3879          m_subtype = subtype_;
3880          m_has_subtype = true;
3881      }
3882      constexpr subtype_type subtype() const noexcept
3883      {
3884          return m_has_subtype ? m_subtype : subtype_type(-1);
3885      }
3886      constexpr bool has_subtype() const noexcept
3887      {
3888          return m_has_subtype;
3889      }
3890      void clear_subtype() noexcept
3891      {
3892          m_subtype = 0;
3893          m_has_subtype = false;
3894      }
3895    private:
3896      subtype_type m_subtype = 0;
3897      bool m_has_subtype = false;
3898  };
3899  }  
3900  #include <cstdint> 
3901  #include <cstddef> 
3902  #include <functional> 
3903  namespace nlohmann
3904  {
3905  namespace detail
3906  {
3907  inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
3908  {
3909      seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
3910      return seed;
3911  }
3912  template<typename BasicJsonType>
3913  std::size_t hash(const BasicJsonType& j)
3914  {
3915      using string_t = typename BasicJsonType::string_t;
3916      using number_integer_t = typename BasicJsonType::number_integer_t;
3917      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
3918      using number_float_t = typename BasicJsonType::number_float_t;
3919      const auto type = static_cast<std::size_t>(j.type());
3920      switch (j.type())
3921      {
3922          case BasicJsonType::value_t::null:
3923          case BasicJsonType::value_t::discarded:
3924          {
3925              return combine(type, 0);
3926          }
3927          case BasicJsonType::value_t::object:
3928          {
3929              auto seed = combine(type, j.size());
3930              for (const auto& element : j.items())
3931              {
3932                  const auto h = std::hash<string_t> {}(element.key());
3933                  seed = combine(seed, h);
3934                  seed = combine(seed, hash(element.value()));
3935              }
3936              return seed;
3937          }
3938          case BasicJsonType::value_t::array:
3939          {
3940              auto seed = combine(type, j.size());
3941              for (const auto& element : j)
3942              {
3943                  seed = combine(seed, hash(element));
3944              }
3945              return seed;
3946          }
3947          case BasicJsonType::value_t::string:
3948          {
3949              const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
3950              return combine(type, h);
3951          }
3952          case BasicJsonType::value_t::boolean:
3953          {
3954              const auto h = std::hash<bool> {}(j.template get<bool>());
3955              return combine(type, h);
3956          }
3957          case BasicJsonType::value_t::number_integer:
3958          {
3959              const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
3960              return combine(type, h);
3961          }
3962          case BasicJsonType::value_t::number_unsigned:
3963          {
3964              const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
3965              return combine(type, h);
3966          }
3967          case BasicJsonType::value_t::number_float:
3968          {
3969              const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
3970              return combine(type, h);
3971          }
3972          case BasicJsonType::value_t::binary:
3973          {
3974              auto seed = combine(type, j.get_binary().size());
3975              const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
3976              seed = combine(seed, h);
3977              seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
3978              for (const auto byte : j.get_binary())
3979              {
3980                  seed = combine(seed, std::hash<std::uint8_t> {}(byte));
3981              }
3982              return seed;
3983          }
3984          default:                   
3985              JSON_ASSERT(false); 
3986              return 0;              
3987      }
3988  }
3989  }  
3990  }  
3991  #include <algorithm> 
3992  #include <array> 
3993  #include <cmath> 
3994  #include <cstddef> 
3995  #include <cstdint> 
3996  #include <cstdio> 
3997  #include <cstring> 
3998  #include <iterator> 
3999  #include <limits> 
4000  #include <string> 
4001  #include <utility> 
4002  #include <vector> 
4003  #include <array> 
4004  #include <cstddef> 
4005  #include <cstring> 
4006  #include <iterator> 
4007  #include <memory> 
4008  #include <numeric> 
4009  #include <string> 
4010  #include <type_traits> 
4011  #include <utility> 
4012  #ifndef JSON_NO_IO
4013      #include <cstdio>   
4014      #include <istream>  
4015  #endif                  
4016  namespace nlohmann
4017  {
4018  namespace detail
4019  {
4020  enum class input_format_t { json, cbor, msgpack, ubjson, bson };
4021  #ifndef JSON_NO_IO
4022  class file_input_adapter
4023  {
4024    public:
4025      using char_type = char;
4026      JSON_HEDLEY_NON_NULL(2)
4027      explicit file_input_adapter(std::FILE* f) noexcept
4028          : m_file(f)
4029      {}
4030      file_input_adapter(const file_input_adapter&) = delete;
4031      file_input_adapter(file_input_adapter&&) noexcept = default;
4032      file_input_adapter& operator=(const file_input_adapter&) = delete;
4033      file_input_adapter& operator=(file_input_adapter&&) = delete;
4034      ~file_input_adapter() = default;
4035      std::char_traits<char>::int_type get_character() noexcept
4036      {
4037          return std::fgetc(m_file);
4038      }
4039    private:
4040      std::FILE* m_file;
4041  };
4042  class input_stream_adapter
4043  {
4044    public:
4045      using char_type = char;
4046      ~input_stream_adapter()
4047      {
4048          if (is != nullptr)
4049          {
4050              is->clear(is->rdstate() & std::ios::eofbit);
4051          }
4052      }
4053      explicit input_stream_adapter(std::istream& i)
4054          : is(&i), sb(i.rdbuf())
4055      {}
4056      input_stream_adapter(const input_stream_adapter&) = delete;
4057      input_stream_adapter& operator=(input_stream_adapter&) = delete;
4058      input_stream_adapter& operator=(input_stream_adapter&&) = delete;
4059      input_stream_adapter(input_stream_adapter&& rhs) noexcept
4060          : is(rhs.is), sb(rhs.sb)
4061      {
4062          rhs.is = nullptr;
4063          rhs.sb = nullptr;
4064      }
4065      std::char_traits<char>::int_type get_character()
4066      {
4067          auto res = sb->sbumpc();
4068          if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
4069          {
4070              is->clear(is->rdstate() | std::ios::eofbit);
4071          }
4072          return res;
4073      }
4074    private:
4075      std::istream* is = nullptr;
4076      std::streambuf* sb = nullptr;
4077  };
4078  #endif  
4079  template<typename IteratorType>
4080  class iterator_input_adapter
4081  {
4082    public:
4083      using char_type = typename std::iterator_traits<IteratorType>::value_type;
4084      iterator_input_adapter(IteratorType first, IteratorType last)
4085          : current(std::move(first)), end(std::move(last))
4086      {}
4087      typename std::char_traits<char_type>::int_type get_character()
4088      {
4089          if (JSON_HEDLEY_LIKELY(current != end))
4090          {
4091              auto result = std::char_traits<char_type>::to_int_type(*current);
4092              std::advance(current, 1);
4093              return result;
4094          }
4095          return std::char_traits<char_type>::eof();
4096      }
4097    private:
4098      IteratorType current;
4099      IteratorType end;
4100      template<typename BaseInputAdapter, size_t T>
4101      friend struct wide_string_input_helper;
4102      bool empty() const
4103      {
4104          return current == end;
4105      }
4106  };
4107  template<typename BaseInputAdapter, size_t T>
4108  struct wide_string_input_helper;
4109  template<typename BaseInputAdapter>
4110  struct wide_string_input_helper<BaseInputAdapter, 4>
4111  {
4112      static void fill_buffer(BaseInputAdapter& input,
4113                              std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
4114                              size_t& utf8_bytes_index,
4115                              size_t& utf8_bytes_filled)
4116      {
4117          utf8_bytes_index = 0;
4118          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4119          {
4120              utf8_bytes[0] = std::char_traits<char>::eof();
4121              utf8_bytes_filled = 1;
4122          }
4123          else
4124          {
4125              const auto wc = input.get_character();
4126              if (wc < 0x80)
4127              {
4128                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4129                  utf8_bytes_filled = 1;
4130              }
4131              else if (wc <= 0x7FF)
4132              {
4133                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
4134                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4135                  utf8_bytes_filled = 2;
4136              }
4137              else if (wc <= 0xFFFF)
4138              {
4139                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
4140                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4141                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4142                  utf8_bytes_filled = 3;
4143              }
4144              else if (wc <= 0x10FFFF)
4145              {
4146                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
4147                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
4148                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4149                  utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4150                  utf8_bytes_filled = 4;
4151              }
4152              else
4153              {
4154                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4155                  utf8_bytes_filled = 1;
4156              }
4157          }
4158      }
4159  };
4160  template<typename BaseInputAdapter>
4161  struct wide_string_input_helper<BaseInputAdapter, 2>
4162  {
4163      static void fill_buffer(BaseInputAdapter& input,
4164                              std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
4165                              size_t& utf8_bytes_index,
4166                              size_t& utf8_bytes_filled)
4167      {
4168          utf8_bytes_index = 0;
4169          if (JSON_HEDLEY_UNLIKELY(input.empty()))
4170          {
4171              utf8_bytes[0] = std::char_traits<char>::eof();
4172              utf8_bytes_filled = 1;
4173          }
4174          else
4175          {
4176              const auto wc = input.get_character();
4177              if (wc < 0x80)
4178              {
4179                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4180                  utf8_bytes_filled = 1;
4181              }
4182              else if (wc <= 0x7FF)
4183              {
4184                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
4185                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4186                  utf8_bytes_filled = 2;
4187              }
4188              else if (0xD800 > wc || wc >= 0xE000)
4189              {
4190                  utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
4191                  utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
4192                  utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
4193                  utf8_bytes_filled = 3;
4194              }
4195              else
4196              {
4197                  if (JSON_HEDLEY_UNLIKELY(!input.empty()))
4198                  {
4199                      const auto wc2 = static_cast<unsigned int>(input.get_character());
4200                      const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
4201                      utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
4202                      utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
4203                      utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
4204                      utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
4205                      utf8_bytes_filled = 4;
4206                  }
4207                  else
4208                  {
4209                      utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
4210                      utf8_bytes_filled = 1;
4211                  }
4212              }
4213          }
4214      }
4215  };
4216  template<typename BaseInputAdapter, typename WideCharType>
4217  class wide_string_input_adapter
4218  {
4219    public:
4220      using char_type = char;
4221      wide_string_input_adapter(BaseInputAdapter base)
4222          : base_adapter(base) {}
4223      typename std::char_traits<char>::int_type get_character() noexcept
4224      {
4225          if (utf8_bytes_index == utf8_bytes_filled)
4226          {
4227              fill_buffer<sizeof(WideCharType)>();
4228              JSON_ASSERT(utf8_bytes_filled > 0);
4229              JSON_ASSERT(utf8_bytes_index == 0);
4230          }
4231          JSON_ASSERT(utf8_bytes_filled > 0);
4232          JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
4233          return utf8_bytes[utf8_bytes_index++];
4234      }
4235    private:
4236      BaseInputAdapter base_adapter;
4237      template<size_t T>
4238      void fill_buffer()
4239      {
4240          wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
4241      }
4242      std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};
4243      std::size_t utf8_bytes_index = 0;
4244      std::size_t utf8_bytes_filled = 0;
4245  };
4246  template<typename IteratorType, typename Enable = void>
4247  struct iterator_input_adapter_factory
4248  {
4249      using iterator_type = IteratorType;
4250      using char_type = typename std::iterator_traits<iterator_type>::value_type;
4251      using adapter_type = iterator_input_adapter<iterator_type>;
4252      static adapter_type create(IteratorType first, IteratorType last)
4253      {
4254          return adapter_type(std::move(first), std::move(last));
4255      }
4256  };
4257  template<typename T>
4258  struct is_iterator_of_multibyte
4259  {
4260      using value_type = typename std::iterator_traits<T>::value_type;
4261      enum
4262      {
4263          value = sizeof(value_type) > 1
4264      };
4265  };
4266  template<typename IteratorType>
4267  struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
4268  {
4269      using iterator_type = IteratorType;
4270      using char_type = typename std::iterator_traits<iterator_type>::value_type;
4271      using base_adapter_type = iterator_input_adapter<iterator_type>;
4272      using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;
4273      static adapter_type create(IteratorType first, IteratorType last)
4274      {
4275          return adapter_type(base_adapter_type(std::move(first), std::move(last)));
4276      }
4277  };
4278  template<typename IteratorType>
4279  typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
4280  {
4281      using factory_type = iterator_input_adapter_factory<IteratorType>;
4282      return factory_type::create(first, last);
4283  }
4284  namespace container_input_adapter_factory_impl
4285  {
4286  using std::begin;
4287  using std::end;
4288  template<typename ContainerType, typename Enable = void>
4289  struct container_input_adapter_factory {};
4290  template<typename ContainerType>
4291  struct container_input_adapter_factory< ContainerType,
4292         void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
4293         {
4294             using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));
4295             static adapter_type create(const ContainerType& container)
4296  {
4297      return input_adapter(begin(container), end(container));
4298  }
4299         };
4300  } 
4301  template<typename ContainerType>
4302  typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
4303  {
4304      return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
4305  }
4306  #ifndef JSON_NO_IO
4307  inline file_input_adapter input_adapter(std::FILE* file)
4308  {
4309      return file_input_adapter(file);
4310  }
4311  inline input_stream_adapter input_adapter(std::istream& stream)
4312  {
4313      return input_stream_adapter(stream);
4314  }
4315  inline input_stream_adapter input_adapter(std::istream&& stream)
4316  {
4317      return input_stream_adapter(stream);
4318  }
4319  #endif  
4320  using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));
4321  template < typename CharT,
4322             typename std::enable_if <
4323                 std::is_pointer<CharT>::value&&
4324                 !std::is_array<CharT>::value&&
4325                 std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
4326                 sizeof(typename std::remove_pointer<CharT>::type) == 1,
4327                 int >::type = 0 >
4328  contiguous_bytes_input_adapter input_adapter(CharT b)
4329  {
4330      auto length = std::strlen(reinterpret_cast<const char*>(b));
4331      const auto* ptr = reinterpret_cast<const char*>(b);
4332      return input_adapter(ptr, ptr + length);
4333  }
4334  template<typename T, std::size_t N>
4335  auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) 
4336  {
4337      return input_adapter(array, array + N);
4338  }
4339  class span_input_adapter
4340  {
4341    public:
4342      template < typename CharT,
4343                 typename std::enable_if <
4344                     std::is_pointer<CharT>::value&&
4345                     std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
4346                     sizeof(typename std::remove_pointer<CharT>::type) == 1,
4347                     int >::type = 0 >
4348      span_input_adapter(CharT b, std::size_t l)
4349          : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}
4350      template<class IteratorType,
4351               typename std::enable_if<
4352                   std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
4353                   int>::type = 0>
4354      span_input_adapter(IteratorType first, IteratorType last)
4355          : ia(input_adapter(first, last)) {}
4356      contiguous_bytes_input_adapter&& get()
4357      {
4358          return std::move(ia); 
4359      }
4360    private:
4361      contiguous_bytes_input_adapter ia;
4362  };
4363  }  
4364  }  
4365  #include <cstddef>
4366  #include <string> 
4367  #include <utility> 
4368  #include <vector> 
4369  namespace nlohmann
4370  {
4371  template<typename BasicJsonType>
4372  struct json_sax
4373  {
4374      using number_integer_t = typename BasicJsonType::number_integer_t;
4375      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4376      using number_float_t = typename BasicJsonType::number_float_t;
4377      using string_t = typename BasicJsonType::string_t;
4378      using binary_t = typename BasicJsonType::binary_t;
4379      virtual bool null() = 0;
4380      virtual bool boolean(bool val) = 0;
4381      virtual bool number_integer(number_integer_t val) = 0;
4382      virtual bool number_unsigned(number_unsigned_t val) = 0;
4383      virtual bool number_float(number_float_t val, const string_t& s) = 0;
4384      virtual bool string(string_t& val) = 0;
4385      virtual bool binary(binary_t& val) = 0;
4386      virtual bool start_object(std::size_t elements) = 0;
4387      virtual bool key(string_t& val) = 0;
4388      virtual bool end_object() = 0;
4389      virtual bool start_array(std::size_t elements) = 0;
4390      virtual bool end_array() = 0;
4391      virtual bool parse_error(std::size_t position,
4392                               const std::string& last_token,
4393                               const detail::exception& ex) = 0;
4394      json_sax() = default;
4395      json_sax(const json_sax&) = default;
4396      json_sax(json_sax&&) noexcept = default;
4397      json_sax& operator=(const json_sax&) = default;
4398      json_sax& operator=(json_sax&&) noexcept = default;
4399      virtual ~json_sax() = default;
4400  };
4401  namespace detail
4402  {
4403  template<typename BasicJsonType>
4404  class json_sax_dom_parser
4405  {
4406    public:
4407      using number_integer_t = typename BasicJsonType::number_integer_t;
4408      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4409      using number_float_t = typename BasicJsonType::number_float_t;
4410      using string_t = typename BasicJsonType::string_t;
4411      using binary_t = typename BasicJsonType::binary_t;
4412      explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
4413          : root(r), allow_exceptions(allow_exceptions_)
4414      {}
4415      json_sax_dom_parser(const json_sax_dom_parser&) = delete;
4416      json_sax_dom_parser(json_sax_dom_parser&&) = default; 
4417      json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
4418      json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; 
4419      ~json_sax_dom_parser() = default;
4420      bool null()
4421      {
4422          handle_value(nullptr);
4423          return true;
4424      }
4425      bool boolean(bool val)
4426      {
4427          handle_value(val);
4428          return true;
4429      }
4430      bool number_integer(number_integer_t val)
4431      {
4432          handle_value(val);
4433          return true;
4434      }
4435      bool number_unsigned(number_unsigned_t val)
4436      {
4437          handle_value(val);
4438          return true;
4439      }
4440      bool number_float(number_float_t val, const string_t& &bsol;*unused*/)
4441      {
4442          handle_value(val);
4443          return true;
4444      }
4445      bool string(string_t& val)
4446      {
4447          handle_value(val);
4448          return true;
4449      }
4450      bool binary(binary_t& val)
4451      {
4452          handle_value(std::move(val));
4453          return true;
4454      }
4455      bool start_object(std::size_t len)
4456      {
4457          ref_stack.push_back(handle_value(BasicJsonType::value_t::object));
4458          if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
4459          {
4460              JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len), *ref_stack.back()));
4461          }
4462          return true;
4463      }
4464      bool key(string_t& val)
4465      {
4466          object_element = &(ref_stack.back()->m_value.object->operator[](val));
4467          return true;
4468      }
4469      bool end_object()
4470      {
4471          ref_stack.back()->set_parents();
4472          ref_stack.pop_back();
4473          return true;
4474      }
4475      bool start_array(std::size_t len)
4476      {
4477          ref_stack.push_back(handle_value(BasicJsonType::value_t::array));
4478          if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
4479          {
4480              JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len), *ref_stack.back()));
4481          }
4482          return true;
4483      }
4484      bool end_array()
4485      {
4486          ref_stack.back()->set_parents();
4487          ref_stack.pop_back();
4488          return true;
4489      }
4490      template<class Exception>
4491      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/,
4492                       const Exception& ex)
4493      {
4494          errored = true;
4495          static_cast<void>(ex);
4496          if (allow_exceptions)
4497          {
4498              JSON_THROW(ex);
4499          }
4500          return false;
4501      }
4502      constexpr bool is_errored() const
4503      {
4504          return errored;
4505      }
4506    private:
4507      template<typename Value>
4508      JSON_HEDLEY_RETURNS_NON_NULL
4509      BasicJsonType* handle_value(Value&& v)
4510      {
4511          if (ref_stack.empty())
4512          {
4513              root = BasicJsonType(std::forward<Value>(v));
4514              return &root;
4515          }
4516          JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
4517          if (ref_stack.back()->is_array())
4518          {
4519              ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
4520              return &(ref_stack.back()->m_value.array->back());
4521          }
4522          JSON_ASSERT(ref_stack.back()->is_object());
4523          JSON_ASSERT(object_element);
4524          *object_element = BasicJsonType(std::forward<Value>(v));
4525          return object_element;
4526      }
4527      BasicJsonType& root;
4528      std::vector<BasicJsonType*> ref_stack {};
4529      BasicJsonType* object_element = nullptr;
4530      bool errored = false;
4531      const bool allow_exceptions = true;
4532  };
4533  template<typename BasicJsonType>
4534  class json_sax_dom_callback_parser
4535  {
4536    public:
4537      using number_integer_t = typename BasicJsonType::number_integer_t;
4538      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4539      using number_float_t = typename BasicJsonType::number_float_t;
4540      using string_t = typename BasicJsonType::string_t;
4541      using binary_t = typename BasicJsonType::binary_t;
4542      using parser_callback_t = typename BasicJsonType::parser_callback_t;
4543      using parse_event_t = typename BasicJsonType::parse_event_t;
4544      json_sax_dom_callback_parser(BasicJsonType& r,
4545                                   const parser_callback_t cb,
4546                                   const bool allow_exceptions_ = true)
4547          : root(r), callback(cb), allow_exceptions(allow_exceptions_)
4548      {
4549          keep_stack.push_back(true);
4550      }
4551      json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
4552      json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; 
4553      json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
4554      json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; 
4555      ~json_sax_dom_callback_parser() = default;
4556      bool null()
4557      {
4558          handle_value(nullptr);
4559          return true;
4560      }
4561      bool boolean(bool val)
4562      {
4563          handle_value(val);
4564          return true;
4565      }
4566      bool number_integer(number_integer_t val)
4567      {
4568          handle_value(val);
4569          return true;
4570      }
4571      bool number_unsigned(number_unsigned_t val)
4572      {
4573          handle_value(val);
4574          return true;
4575      }
4576      bool number_float(number_float_t val, const string_t& &bsol;*unused*/)
4577      {
4578          handle_value(val);
4579          return true;
4580      }
4581      bool string(string_t& val)
4582      {
4583          handle_value(val);
4584          return true;
4585      }
4586      bool binary(binary_t& val)
4587      {
4588          handle_value(std::move(val));
4589          return true;
4590      }
4591      bool start_object(std::size_t len)
4592      {
4593          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
4594          keep_stack.push_back(keep);
4595          auto val = handle_value(BasicJsonType::value_t::object, true);
4596          ref_stack.push_back(val.second);
4597          if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
4598          {
4599              JSON_THROW(out_of_range::create(408, "excessive object size: " + std::to_string(len), *ref_stack.back()));
4600          }
4601          return true;
4602      }
4603      bool key(string_t& val)
4604      {
4605          BasicJsonType k = BasicJsonType(val);
4606          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
4607          key_keep_stack.push_back(keep);
4608          if (keep && ref_stack.back())
4609          {
4610              object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
4611          }
4612          return true;
4613      }
4614      bool end_object()
4615      {
4616          if (ref_stack.back())
4617          {
4618              if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
4619              {
4620                  *ref_stack.back() = discarded;
4621              }
4622              else
4623              {
4624                  ref_stack.back()->set_parents();
4625              }
4626          }
4627          JSON_ASSERT(!ref_stack.empty());
4628          JSON_ASSERT(!keep_stack.empty());
4629          ref_stack.pop_back();
4630          keep_stack.pop_back();
4631          if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
4632          {
4633              for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
4634              {
4635                  if (it->is_discarded())
4636                  {
4637                      ref_stack.back()->erase(it);
4638                      break;
4639                  }
4640              }
4641          }
4642          return true;
4643      }
4644      bool start_array(std::size_t len)
4645      {
4646          const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
4647          keep_stack.push_back(keep);
4648          auto val = handle_value(BasicJsonType::value_t::array, true);
4649          ref_stack.push_back(val.second);
4650          if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
4651          {
4652              JSON_THROW(out_of_range::create(408, "excessive array size: " + std::to_string(len), *ref_stack.back()));
4653          }
4654          return true;
4655      }
4656      bool end_array()
4657      {
4658          bool keep = true;
4659          if (ref_stack.back())
4660          {
4661              keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
4662              if (keep)
4663              {
4664                  ref_stack.back()->set_parents();
4665              }
4666              else
4667              {
4668                  *ref_stack.back() = discarded;
4669              }
4670          }
4671          JSON_ASSERT(!ref_stack.empty());
4672          JSON_ASSERT(!keep_stack.empty());
4673          ref_stack.pop_back();
4674          keep_stack.pop_back();
4675          if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
4676          {
4677              ref_stack.back()->m_value.array->pop_back();
4678          }
4679          return true;
4680      }
4681      template<class Exception>
4682      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/,
4683                       const Exception& ex)
4684      {
4685          errored = true;
4686          static_cast<void>(ex);
4687          if (allow_exceptions)
4688          {
4689              JSON_THROW(ex);
4690          }
4691          return false;
4692      }
4693      constexpr bool is_errored() const
4694      {
4695          return errored;
4696      }
4697    private:
4698      template<typename Value>
4699      std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
4700      {
4701          JSON_ASSERT(!keep_stack.empty());
4702          if (!keep_stack.back())
4703          {
4704              return {false, nullptr};
4705          }
4706          auto value = BasicJsonType(std::forward<Value>(v));
4707          const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);
4708          if (!keep)
4709          {
4710              return {false, nullptr};
4711          }
4712          if (ref_stack.empty())
4713          {
4714              root = std::move(value);
4715              return {true, &root};
4716          }
4717          if (!ref_stack.back())
4718          {
4719              return {false, nullptr};
4720          }
4721          JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
4722          if (ref_stack.back()->is_array())
4723          {
4724              ref_stack.back()->m_value.array->emplace_back(std::move(value));
4725              return {true, &(ref_stack.back()->m_value.array->back())};
4726          }
4727          JSON_ASSERT(ref_stack.back()->is_object());
4728          JSON_ASSERT(!key_keep_stack.empty());
4729          const bool store_element = key_keep_stack.back();
4730          key_keep_stack.pop_back();
4731          if (!store_element)
4732          {
4733              return {false, nullptr};
4734          }
4735          JSON_ASSERT(object_element);
4736          *object_element = std::move(value);
4737          return {true, object_element};
4738      }
4739      BasicJsonType& root;
4740      std::vector<BasicJsonType*> ref_stack {};
4741      std::vector<bool> keep_stack {};
4742      std::vector<bool> key_keep_stack {};
4743      BasicJsonType* object_element = nullptr;
4744      bool errored = false;
4745      const parser_callback_t callback = nullptr;
4746      const bool allow_exceptions = true;
4747      BasicJsonType discarded = BasicJsonType::value_t::discarded;
4748  };
4749  template<typename BasicJsonType>
4750  class json_sax_acceptor
4751  {
4752    public:
4753      using number_integer_t = typename BasicJsonType::number_integer_t;
4754      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4755      using number_float_t = typename BasicJsonType::number_float_t;
4756      using string_t = typename BasicJsonType::string_t;
4757      using binary_t = typename BasicJsonType::binary_t;
4758      bool null()
4759      {
4760          return true;
4761      }
4762      bool boolean(bool &bsol;*unused*/)
4763      {
4764          return true;
4765      }
4766      bool number_integer(number_integer_t &bsol;*unused*/)
4767      {
4768          return true;
4769      }
4770      bool number_unsigned(number_unsigned_t &bsol;*unused*/)
4771      {
4772          return true;
4773      }
4774      bool number_float(number_float_t &bsol;*unused*/, const string_t& &bsol;*unused*/)
4775      {
4776          return true;
4777      }
4778      bool string(string_t& &bsol;*unused*/)
4779      {
4780          return true;
4781      }
4782      bool binary(binary_t& &bsol;*unused*/)
4783      {
4784          return true;
4785      }
4786      bool start_object(std::size_t &bsol;*unused*/ = std::size_t(-1))
4787      {
4788          return true;
4789      }
4790      bool key(string_t& &bsol;*unused*/)
4791      {
4792          return true;
4793      }
4794      bool end_object()
4795      {
4796          return true;
4797      }
4798      bool start_array(std::size_t &bsol;*unused*/ = std::size_t(-1))
4799      {
4800          return true;
4801      }
4802      bool end_array()
4803      {
4804          return true;
4805      }
4806      bool parse_error(std::size_t &bsol;*unused*/, const std::string& &bsol;*unused*/, const detail::exception& &bsol;*unused*/)
4807      {
4808          return false;
4809      }
4810  };
4811  }  
4812  }  
4813  #include <array> 
4814  #include <clocale> 
4815  #include <cstddef> 
4816  #include <cstdio> 
4817  #include <cstdlib> 
4818  #include <initializer_list> 
4819  #include <string> 
4820  #include <utility> 
4821  #include <vector> 
4822  namespace nlohmann
4823  {
4824  namespace detail
4825  {
4826  template<typename BasicJsonType>
4827  class lexer_base
4828  {
4829    public:
4830      enum class token_type
4831      {
4832          uninitialized,    
4833          literal_true,     
4834          literal_false,    
4835          literal_null,     
4836          value_string,     
4837          value_unsigned,   
4838          value_integer,    
4839          value_float,      
4840          begin_array,      
4841          begin_object,     
4842          end_array,        
4843          end_object,       
4844          name_separator,   
4845          value_separator,  
4846          parse_error,      
4847          end_of_input,     
4848          literal_or_value  
4849      };
4850      JSON_HEDLEY_RETURNS_NON_NULL
4851      JSON_HEDLEY_CONST
4852      static const char* token_type_name(const token_type t) noexcept
4853      {
4854          switch (t)
4855          {
4856              case token_type::uninitialized:
4857                  return "<uninitialized>";
4858              case token_type::literal_true:
4859                  return "true literal";
4860              case token_type::literal_false:
4861                  return "false literal";
4862              case token_type::literal_null:
4863                  return "null literal";
4864              case token_type::value_string:
4865                  return "string literal";
4866              case token_type::value_unsigned:
4867              case token_type::value_integer:
4868              case token_type::value_float:
4869                  return "number literal";
4870              case token_type::begin_array:
4871                  return "'['";
4872              case token_type::begin_object:
4873                  return "'{'";
4874              case token_type::end_array:
4875                  return "']'";
4876              case token_type::end_object:
4877                  return "'}'";
4878              case token_type::name_separator:
4879                  return "':'";
4880              case token_type::value_separator:
4881                  return "','";
4882              case token_type::parse_error:
4883                  return "<parse error>";
4884              case token_type::end_of_input:
4885                  return "end of input";
4886              case token_type::literal_or_value:
4887                  return "'[', '{', or a literal";
4888              default: 
4889                  return "unknown token";
4890          }
4891      }
4892  };
4893  template<typename BasicJsonType, typename InputAdapterType>
4894  class lexer : public lexer_base<BasicJsonType>
4895  {
4896      using number_integer_t = typename BasicJsonType::number_integer_t;
4897      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
4898      using number_float_t = typename BasicJsonType::number_float_t;
4899      using string_t = typename BasicJsonType::string_t;
4900      using char_type = typename InputAdapterType::char_type;
4901      using char_int_type = typename std::char_traits<char_type>::int_type;
4902    public:
4903      using token_type = typename lexer_base<BasicJsonType>::token_type;
4904      explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
4905          : ia(std::move(adapter))
4906          , ignore_comments(ignore_comments_)
4907          , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
4908      {}
4909      lexer(const lexer&) = delete;
4910      lexer(lexer&&) = default; 
4911      lexer& operator=(lexer&) = delete;
4912      lexer& operator=(lexer&&) = default; 
4913      ~lexer() = default;
4914    private:
4915      JSON_HEDLEY_PURE
4916      static char get_decimal_point() noexcept
4917      {
4918          const auto* loc = localeconv();
4919          JSON_ASSERT(loc != nullptr);
4920          return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
4921      }
4922      int get_codepoint()
4923      {
4924          JSON_ASSERT(current == 'u');
4925          int codepoint = 0;
4926          const auto factors = { 12u, 8u, 4u, 0u };
4927          for (const auto factor : factors)
4928          {
4929              get();
4930              if (current >= '0' && current <= '9')
4931              {
4932                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
4933              }
4934              else if (current >= 'A' && current <= 'F')
4935              {
4936                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
4937              }
4938              else if (current >= 'a' && current <= 'f')
4939              {
4940                  codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
4941              }
4942              else
4943              {
4944                  return -1;
4945              }
4946          }
4947          JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
4948          return codepoint;
4949      }
4950      bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
4951      {
4952          JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
4953          add(current);
4954          for (auto range = ranges.begin(); range != ranges.end(); ++range)
4955          {
4956              get();
4957              if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))
4958              {
4959                  add(current);
4960              }
4961              else
4962              {
4963                  error_message = "invalid string: ill-formed UTF-8 byte";
4964                  return false;
4965              }
4966          }
4967          return true;
4968      }
4969      token_type scan_string()
4970      {
4971          reset();
4972          JSON_ASSERT(current == '\"');
4973          while (true)
4974          {
4975              switch (get())
4976              {
4977                  case std::char_traits<char_type>::eof():
4978                  {
4979                      error_message = "invalid string: missing closing quote";
4980                      return token_type::parse_error;
4981                  }
4982                  case '\"':
4983                  {
4984                      return token_type::value_string;
4985                  }
4986                  case '\\':
4987                  {
4988                      switch (get())
4989                      {
4990                          case '\"':
4991                              add('\"');
4992                              break;
4993                          case '\\':
4994                              add('\\');
4995                              break;
4996                          case '/':
4997                              add('/');
4998                              break;
4999                          case 'b':
5000                              add('\b');
5001                              break;
5002                          case 'f':
5003                              add('\f');
5004                              break;
5005                          case 'n':
5006                              add('\n');
5007                              break;
5008                          case 'r':
5009                              add('\r');
5010                              break;
5011                          case 't':
5012                              add('\t');
5013                              break;
5014                          case 'u':
5015                          {
5016                              const int codepoint1 = get_codepoint();
5017                              int codepoint = codepoint1; 
5018                              if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
5019                              {
5020                                  error_message = "invalid string: '\\u' must be followed by 4 hex digits";
5021                                  return token_type::parse_error;
5022                              }
5023                              if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
5024                              {
5025                                  if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
5026                                  {
5027                                      const int codepoint2 = get_codepoint();
5028                                      if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
5029                                      {
5030                                          error_message = "invalid string: '\\u' must be followed by 4 hex digits";
5031                                          return token_type::parse_error;
5032                                      }
5033                                      if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
5034                                      {
5035                                          codepoint = static_cast<int>(
5036                                                          (static_cast<unsigned int>(codepoint1) << 10u)
5037                                                          + static_cast<unsigned int>(codepoint2)
5038                                                          - 0x35FDC00u);
5039                                      }
5040                                      else
5041                                      {
5042                                          error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
5043                                          return token_type::parse_error;
5044                                      }
5045                                  }
5046                                  else
5047                                  {
5048                                      error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
5049                                      return token_type::parse_error;
5050                                  }
5051                              }
5052                              else
5053                              {
5054                                  if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
5055                                  {
5056                                      error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
5057                                      return token_type::parse_error;
5058                                  }
5059                              }
5060                              JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);
5061                              if (codepoint < 0x80)
5062                              {
5063                                  add(static_cast<char_int_type>(codepoint));
5064                              }
5065                              else if (codepoint <= 0x7FF)
5066                              {
5067                                  add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
5068                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5069                              }
5070                              else if (codepoint <= 0xFFFF)
5071                              {
5072                                  add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
5073                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
5074                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5075                              }
5076                              else
5077                              {
5078                                  add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
5079                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
5080                                  add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
5081                                  add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
5082                              }
5083                              break;
5084                          }
5085                          default:
5086                              error_message = "invalid string: forbidden character after backslash";
5087                              return token_type::parse_error;
5088                      }
5089                      break;
5090                  }
5091                  case 0x00:
5092                  {
5093                      error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
5094                      return token_type::parse_error;
5095                  }
5096                  case 0x01:
5097                  {
5098                      error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
5099                      return token_type::parse_error;
5100                  }
5101                  case 0x02:
5102                  {
5103                      error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
5104                      return token_type::parse_error;
5105                  }
5106                  case 0x03:
5107                  {
5108                      error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
5109                      return token_type::parse_error;
5110                  }
5111                  case 0x04:
5112                  {
5113                      error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
5114                      return token_type::parse_error;
5115                  }
5116                  case 0x05:
5117                  {
5118                      error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
5119                      return token_type::parse_error;
5120                  }
5121                  case 0x06:
5122                  {
5123                      error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
5124                      return token_type::parse_error;
5125                  }
5126                  case 0x07:
5127                  {
5128                      error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
5129                      return token_type::parse_error;
5130                  }
5131                  case 0x08:
5132                  {
5133                      error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
5134                      return token_type::parse_error;
5135                  }
5136                  case 0x09:
5137                  {
5138                      error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
5139                      return token_type::parse_error;
5140                  }
5141                  case 0x0A:
5142                  {
5143                      error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
5144                      return token_type::parse_error;
5145                  }
5146                  case 0x0B:
5147                  {
5148                      error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
5149                      return token_type::parse_error;
5150                  }
5151                  case 0x0C:
5152                  {
5153                      error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
5154                      return token_type::parse_error;
5155                  }
5156                  case 0x0D:
5157                  {
5158                      error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
5159                      return token_type::parse_error;
5160                  }
5161                  case 0x0E:
5162                  {
5163                      error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
5164                      return token_type::parse_error;
5165                  }
5166                  case 0x0F:
5167                  {
5168                      error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
5169                      return token_type::parse_error;
5170                  }
5171                  case 0x10:
5172                  {
5173                      error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
5174                      return token_type::parse_error;
5175                  }
5176                  case 0x11:
5177                  {
5178                      error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
5179                      return token_type::parse_error;
5180                  }
5181                  case 0x12:
5182                  {
5183                      error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
5184                      return token_type::parse_error;
5185                  }
5186                  case 0x13:
5187                  {
5188                      error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
5189                      return token_type::parse_error;
5190                  }
5191                  case 0x14:
5192                  {
5193                      error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
5194                      return token_type::parse_error;
5195                  }
5196                  case 0x15:
5197                  {
5198                      error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
5199                      return token_type::parse_error;
5200                  }
5201                  case 0x16:
5202                  {
5203                      error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
5204                      return token_type::parse_error;
5205                  }
5206                  case 0x17:
5207                  {
5208                      error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
5209                      return token_type::parse_error;
5210                  }
5211                  case 0x18:
5212                  {
5213                      error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
5214                      return token_type::parse_error;
5215                  }
5216                  case 0x19:
5217                  {
5218                      error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
5219                      return token_type::parse_error;
5220                  }
5221                  case 0x1A:
5222                  {
5223                      error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
5224                      return token_type::parse_error;
5225                  }
5226                  case 0x1B:
5227                  {
5228                      error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
5229                      return token_type::parse_error;
5230                  }
5231                  case 0x1C:
5232                  {
5233                      error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
5234                      return token_type::parse_error;
5235                  }
5236                  case 0x1D:
5237                  {
5238                      error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
5239                      return token_type::parse_error;
5240                  }
5241                  case 0x1E:
5242                  {
5243                      error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
5244                      return token_type::parse_error;
5245                  }
5246                  case 0x1F:
5247                  {
5248                      error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
5249                      return token_type::parse_error;
5250                  }
5251                  case 0x20:
5252                  case 0x21:
5253                  case 0x23:
5254                  case 0x24:
5255                  case 0x25:
5256                  case 0x26:
5257                  case 0x27:
5258                  case 0x28:
5259                  case 0x29:
5260                  case 0x2A:
5261                  case 0x2B:
5262                  case 0x2C:
5263                  case 0x2D:
5264                  case 0x2E:
5265                  case 0x2F:
5266                  case 0x30:
5267                  case 0x31:
5268                  case 0x32:
5269                  case 0x33:
5270                  case 0x34:
5271                  case 0x35:
5272                  case 0x36:
5273                  case 0x37:
5274                  case 0x38:
5275                  case 0x39:
5276                  case 0x3A:
5277                  case 0x3B:
5278                  case 0x3C:
5279                  case 0x3D:
5280                  case 0x3E:
5281                  case 0x3F:
5282                  case 0x40:
5283                  case 0x41:
5284                  case 0x42:
5285                  case 0x43:
5286                  case 0x44:
5287                  case 0x45:
5288                  case 0x46:
5289                  case 0x47:
5290                  case 0x48:
5291                  case 0x49:
5292                  case 0x4A:
5293                  case 0x4B:
5294                  case 0x4C:
5295                  case 0x4D:
5296                  case 0x4E:
5297                  case 0x4F:
5298                  case 0x50:
5299                  case 0x51:
5300                  case 0x52:
5301                  case 0x53:
5302                  case 0x54:
5303                  case 0x55:
5304                  case 0x56:
5305                  case 0x57:
5306                  case 0x58:
5307                  case 0x59:
5308                  case 0x5A:
5309                  case 0x5B:
5310                  case 0x5D:
5311                  case 0x5E:
5312                  case 0x5F:
5313                  case 0x60:
5314                  case 0x61:
5315                  case 0x62:
5316                  case 0x63:
5317                  case 0x64:
5318                  case 0x65:
5319                  case 0x66:
5320                  case 0x67:
5321                  case 0x68:
5322                  case 0x69:
5323                  case 0x6A:
5324                  case 0x6B:
5325                  case 0x6C:
5326                  case 0x6D:
5327                  case 0x6E:
5328                  case 0x6F:
5329                  case 0x70:
5330                  case 0x71:
5331                  case 0x72:
5332                  case 0x73:
5333                  case 0x74:
5334                  case 0x75:
5335                  case 0x76:
5336                  case 0x77:
5337                  case 0x78:
5338                  case 0x79:
5339                  case 0x7A:
5340                  case 0x7B:
5341                  case 0x7C:
5342                  case 0x7D:
5343                  case 0x7E:
5344                  case 0x7F:
5345                  {
5346                      add(current);
5347                      break;
5348                  }
5349                  case 0xC2:
5350                  case 0xC3:
5351                  case 0xC4:
5352                  case 0xC5:
5353                  case 0xC6:
5354                  case 0xC7:
5355                  case 0xC8:
5356                  case 0xC9:
5357                  case 0xCA:
5358                  case 0xCB:
5359                  case 0xCC:
5360                  case 0xCD:
5361                  case 0xCE:
5362                  case 0xCF:
5363                  case 0xD0:
5364                  case 0xD1:
5365                  case 0xD2:
5366                  case 0xD3:
5367                  case 0xD4:
5368                  case 0xD5:
5369                  case 0xD6:
5370                  case 0xD7:
5371                  case 0xD8:
5372                  case 0xD9:
5373                  case 0xDA:
5374                  case 0xDB:
5375                  case 0xDC:
5376                  case 0xDD:
5377                  case 0xDE:
5378                  case 0xDF:
5379                  {
5380                      if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
5381                      {
5382                          return token_type::parse_error;
5383                      }
5384                      break;
5385                  }
5386                  case 0xE0:
5387                  {
5388                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
5389                      {
5390                          return token_type::parse_error;
5391                      }
5392                      break;
5393                  }
5394                  case 0xE1:
5395                  case 0xE2:
5396                  case 0xE3:
5397                  case 0xE4:
5398                  case 0xE5:
5399                  case 0xE6:
5400                  case 0xE7:
5401                  case 0xE8:
5402                  case 0xE9:
5403                  case 0xEA:
5404                  case 0xEB:
5405                  case 0xEC:
5406                  case 0xEE:
5407                  case 0xEF:
5408                  {
5409                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
5410                      {
5411                          return token_type::parse_error;
5412                      }
5413                      break;
5414                  }
5415                  case 0xED:
5416                  {
5417                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
5418                      {
5419                          return token_type::parse_error;
5420                      }
5421                      break;
5422                  }
5423                  case 0xF0:
5424                  {
5425                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
5426                      {
5427                          return token_type::parse_error;
5428                      }
5429                      break;
5430                  }
5431                  case 0xF1:
5432                  case 0xF2:
5433                  case 0xF3:
5434                  {
5435                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
5436                      {
5437                          return token_type::parse_error;
5438                      }
5439                      break;
5440                  }
5441                  case 0xF4:
5442                  {
5443                      if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
5444                      {
5445                          return token_type::parse_error;
5446                      }
5447                      break;
5448                  }
5449                  default:
5450                  {
5451                      error_message = "invalid string: ill-formed UTF-8 byte";
5452                      return token_type::parse_error;
5453                  }
5454              }
5455          }
5456      }
5457      bool scan_comment()
5458      {
5459          switch (get())
5460          {
5461              case '/':
5462              {
5463                  while (true)
5464                  {
5465                      switch (get())
5466                      {
5467                          case '\n':
5468                          case '\r':
5469                          case std::char_traits<char_type>::eof():
5470                          case '\0':
5471                              return true;
5472                          default:
5473                              break;
5474                      }
5475                  }
5476              }
5477              case '*':
5478              {
5479                  while (true)
5480                  {
5481                      switch (get())
5482                      {
5483                          case std::char_traits<char_type>::eof():
5484                          case '\0':
5485                          {
5486                              error_message = "invalid comment; missing closing '*/'";
5487                              return false;
5488                          }
5489                          case '*':
5490                          {
5491                              switch (get())
5492                              {
5493                                  case '/':
5494                                      return true;
5495                                  default:
5496                                  {
5497                                      unget();
5498                                      continue;
5499                                  }
5500                              }
5501                          }
5502                          default:
5503                              continue;
5504                      }
5505                  }
5506              }
5507              default:
5508              {
5509                  error_message = "invalid comment; expecting '/' or '*' after '/'";
5510                  return false;
5511              }
5512          }
5513      }
5514      JSON_HEDLEY_NON_NULL(2)
5515      static void strtof(float& f, const char* str, char** endptr) noexcept
5516      {
5517          f = std::strtof(str, endptr);
5518      }
5519      JSON_HEDLEY_NON_NULL(2)
5520      static void strtof(double& f, const char* str, char** endptr) noexcept
5521      {
5522          f = std::strtod(str, endptr);
5523      }
5524      JSON_HEDLEY_NON_NULL(2)
5525      static void strtof(long double& f, const char* str, char** endptr) noexcept
5526      {
5527          f = std::strtold(str, endptr);
5528      }
5529      token_type scan_number()  
5530      {
5531          reset();
5532          token_type number_type = token_type::value_unsigned;
5533          switch (current)
5534          {
5535              case '-':
5536              {
5537                  add(current);
5538                  goto scan_number_minus;
5539              }
5540              case '0':
5541              {
5542                  add(current);
5543                  goto scan_number_zero;
5544              }
5545              case '1':
5546              case '2':
5547              case '3':
5548              case '4':
5549              case '5':
5550              case '6':
5551              case '7':
5552              case '8':
5553              case '9':
5554              {
5555                  add(current);
5556                  goto scan_number_any1;
5557              }
5558              default:            
5559                  JSON_ASSERT(false); 
5560          }
5561  scan_number_minus:
5562          number_type = token_type::value_integer;
5563          switch (get())
5564          {
5565              case '0':
5566              {
5567                  add(current);
5568                  goto scan_number_zero;
5569              }
5570              case '1':
5571              case '2':
5572              case '3':
5573              case '4':
5574              case '5':
5575              case '6':
5576              case '7':
5577              case '8':
5578              case '9':
5579              {
5580                  add(current);
5581                  goto scan_number_any1;
5582              }
5583              default:
5584              {
5585                  error_message = "invalid number; expected digit after '-'";
5586                  return token_type::parse_error;
5587              }
5588          }
5589  scan_number_zero:
5590          switch (get())
5591          {
5592              case '.':
5593              {
5594                  add(decimal_point_char);
5595                  goto scan_number_decimal1;
5596              }
5597              case 'e':
5598              case 'E':
5599              {
5600                  add(current);
5601                  goto scan_number_exponent;
5602              }
5603              default:
5604                  goto scan_number_done;
5605          }
5606  scan_number_any1:
5607          switch (get())
5608          {
5609              case '0':
5610              case '1':
5611              case '2':
5612              case '3':
5613              case '4':
5614              case '5':
5615              case '6':
5616              case '7':
5617              case '8':
5618              case '9':
5619              {
5620                  add(current);
5621                  goto scan_number_any1;
5622              }
5623              case '.':
5624              {
5625                  add(decimal_point_char);
5626                  goto scan_number_decimal1;
5627              }
5628              case 'e':
5629              case 'E':
5630              {
5631                  add(current);
5632                  goto scan_number_exponent;
5633              }
5634              default:
5635                  goto scan_number_done;
5636          }
5637  scan_number_decimal1:
5638          number_type = token_type::value_float;
5639          switch (get())
5640          {
5641              case '0':
5642              case '1':
5643              case '2':
5644              case '3':
5645              case '4':
5646              case '5':
5647              case '6':
5648              case '7':
5649              case '8':
5650              case '9':
5651              {
5652                  add(current);
5653                  goto scan_number_decimal2;
5654              }
5655              default:
5656              {
5657                  error_message = "invalid number; expected digit after '.'";
5658                  return token_type::parse_error;
5659              }
5660          }
5661  scan_number_decimal2:
5662          switch (get())
5663          {
5664              case '0':
5665              case '1':
5666              case '2':
5667              case '3':
5668              case '4':
5669              case '5':
5670              case '6':
5671              case '7':
5672              case '8':
5673              case '9':
5674              {
5675                  add(current);
5676                  goto scan_number_decimal2;
5677              }
5678              case 'e':
5679              case 'E':
5680              {
5681                  add(current);
5682                  goto scan_number_exponent;
5683              }
5684              default:
5685                  goto scan_number_done;
5686          }
5687  scan_number_exponent:
5688          number_type = token_type::value_float;
5689          switch (get())
5690          {
5691              case '+':
5692              case '-':
5693              {
5694                  add(current);
5695                  goto scan_number_sign;
5696              }
5697              case '0':
5698              case '1':
5699              case '2':
5700              case '3':
5701              case '4':
5702              case '5':
5703              case '6':
5704              case '7':
5705              case '8':
5706              case '9':
5707              {
5708                  add(current);
5709                  goto scan_number_any2;
5710              }
5711              default:
5712              {
5713                  error_message =
5714                      "invalid number; expected '+', '-', or digit after exponent";
5715                  return token_type::parse_error;
5716              }
5717          }
5718  scan_number_sign:
5719          switch (get())
5720          {
5721              case '0':
5722              case '1':
5723              case '2':
5724              case '3':
5725              case '4':
5726              case '5':
5727              case '6':
5728              case '7':
5729              case '8':
5730              case '9':
5731              {
5732                  add(current);
5733                  goto scan_number_any2;
5734              }
5735              default:
5736              {
5737                  error_message = "invalid number; expected digit after exponent sign";
5738                  return token_type::parse_error;
5739              }
5740          }
5741  scan_number_any2:
5742          switch (get())
5743          {
5744              case '0':
5745              case '1':
5746              case '2':
5747              case '3':
5748              case '4':
5749              case '5':
5750              case '6':
5751              case '7':
5752              case '8':
5753              case '9':
5754              {
5755                  add(current);
5756                  goto scan_number_any2;
5757              }
5758              default:
5759                  goto scan_number_done;
5760          }
5761  scan_number_done:
5762          unget();
5763          char* endptr = nullptr; 
5764          errno = 0;
5765          if (number_type == token_type::value_unsigned)
5766          {
5767              const auto x = std::strtoull(token_buffer.data(), &endptr, 10);
5768              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5769              if (errno == 0)
5770              {
5771                  value_unsigned = static_cast<number_unsigned_t>(x);
5772                  if (value_unsigned == x)
5773                  {
5774                      return token_type::value_unsigned;
5775                  }
5776              }
5777          }
5778          else if (number_type == token_type::value_integer)
5779          {
5780              const auto x = std::strtoll(token_buffer.data(), &endptr, 10);
5781              JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5782              if (errno == 0)
5783              {
5784                  value_integer = static_cast<number_integer_t>(x);
5785                  if (value_integer == x)
5786                  {
5787                      return token_type::value_integer;
5788                  }
5789              }
5790          }
5791          strtof(value_float, token_buffer.data(), &endptr);
5792          JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());
5793          return token_type::value_float;
5794      }
5795      JSON_HEDLEY_NON_NULL(2)
5796      token_type scan_literal(const char_type* literal_text, const std::size_t length,
5797                              token_type return_type)
5798      {
5799          JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);
5800          for (std::size_t i = 1; i < length; ++i)
5801          {
5802              if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))
5803              {
5804                  error_message = "invalid literal";
5805                  return token_type::parse_error;
5806              }
5807          }
5808          return return_type;
5809      }
5810      void reset() noexcept
5811      {
5812          token_buffer.clear();
5813          token_string.clear();
5814          token_string.push_back(std::char_traits<char_type>::to_char_type(current));
5815      }
5816      char_int_type get()
5817      {
5818          ++position.chars_read_total;
5819          ++position.chars_read_current_line;
5820          if (next_unget)
5821          {
5822              next_unget = false;
5823          }
5824          else
5825          {
5826              current = ia.get_character();
5827          }
5828          if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
5829          {
5830              token_string.push_back(std::char_traits<char_type>::to_char_type(current));
5831          }
5832          if (current == '\n')
5833          {
5834              ++position.lines_read;
5835              position.chars_read_current_line = 0;
5836          }
5837          return current;
5838      }
5839      void unget()
5840      {
5841          next_unget = true;
5842          --position.chars_read_total;
5843          if (position.chars_read_current_line == 0)
5844          {
5845              if (position.lines_read > 0)
5846              {
5847                  --position.lines_read;
5848              }
5849          }
5850          else
5851          {
5852              --position.chars_read_current_line;
5853          }
5854          if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
5855          {
5856              JSON_ASSERT(!token_string.empty());
5857              token_string.pop_back();
5858          }
5859      }
5860      void add(char_int_type c)
5861      {
5862          token_buffer.push_back(static_cast<typename string_t::value_type>(c));
5863      }
5864    public:
5865      constexpr number_integer_t get_number_integer() const noexcept
5866      {
5867          return value_integer;
5868      }
5869      constexpr number_unsigned_t get_number_unsigned() const noexcept
5870      {
5871          return value_unsigned;
5872      }
5873      constexpr number_float_t get_number_float() const noexcept
5874      {
5875          return value_float;
5876      }
5877      string_t& get_string()
5878      {
5879          return token_buffer;
5880      }
5881      constexpr position_t get_position() const noexcept
5882      {
5883          return position;
5884      }
5885      std::string get_token_string() const
5886      {
5887          std::string result;
5888          for (const auto c : token_string)
5889          {
5890              if (static_cast<unsigned char>(c) <= '\x1F')
5891              {
5892                  std::array<char, 9> cs{{}};
5893                  (std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c)); 
5894                  result += cs.data();
5895              }
5896              else
5897              {
5898                  result.push_back(static_cast<std::string::value_type>(c));
5899              }
5900          }
5901          return result;
5902      }
5903      JSON_HEDLEY_RETURNS_NON_NULL
5904      constexpr const char* get_error_message() const noexcept
5905      {
5906          return error_message;
5907      }
5908      bool skip_bom()
5909      {
5910          if (get() == 0xEF)
5911          {
5912              return get() == 0xBB && get() == 0xBF;
5913          }
5914          unget();
5915          return true;
5916      }
5917      void skip_whitespace()
5918      {
5919          do
5920          {
5921              get();
5922          }
5923          while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
5924      }
5925      token_type scan()
5926      {
5927          if (position.chars_read_total == 0 && !skip_bom())
5928          {
5929              error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
5930              return token_type::parse_error;
5931          }
5932          skip_whitespace();
5933          while (ignore_comments && current == '/')
5934          {
5935              if (!scan_comment())
5936              {
5937                  return token_type::parse_error;
5938              }
5939              skip_whitespace();
5940          }
5941          switch (current)
5942          {
5943              case '[':
5944                  return token_type::begin_array;
5945              case ']':
5946                  return token_type::end_array;
5947              case '{':
5948                  return token_type::begin_object;
5949              case '}':
5950                  return token_type::end_object;
5951              case ':':
5952                  return token_type::name_separator;
5953              case ',':
5954                  return token_type::value_separator;
5955              case 't':
5956              {
5957                  std::array<char_type, 4> true_literal = {{char_type('t'), char_type('r'), char_type('u'), char_type('e')}};
5958                  return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
5959              }
5960              case 'f':
5961              {
5962                  std::array<char_type, 5> false_literal = {{char_type('f'), char_type('a'), char_type('l'), char_type('s'), char_type('e')}};
5963                  return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
5964              }
5965              case 'n':
5966              {
5967                  std::array<char_type, 4> null_literal = {{char_type('n'), char_type('u'), char_type('l'), char_type('l')}};
5968                  return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
5969              }
5970              case '\"':
5971                  return scan_string();
5972              case '-':
5973              case '0':
5974              case '1':
5975              case '2':
5976              case '3':
5977              case '4':
5978              case '5':
5979              case '6':
5980              case '7':
5981              case '8':
5982              case '9':
5983                  return scan_number();
5984              case '\0':
5985              case std::char_traits<char_type>::eof():
5986                  return token_type::end_of_input;
5987              default:
5988                  error_message = "invalid literal";
5989                  return token_type::parse_error;
5990          }
5991      }
5992    private:
5993      InputAdapterType ia;
5994      const bool ignore_comments = false;
5995      char_int_type current = std::char_traits<char_type>::eof();
5996      bool next_unget = false;
5997      position_t position {};
5998      std::vector<char_type> token_string {};
5999      string_t token_buffer {};
6000      const char* error_message = "";
6001      number_integer_t value_integer = 0;
6002      number_unsigned_t value_unsigned = 0;
6003      number_float_t value_float = 0;
6004      const char_int_type decimal_point_char = '.';
6005  };
6006  }  
6007  }  
6008  #include <cstdint> 
6009  #include <utility> 
6010  #include <string> 
6011  namespace nlohmann
6012  {
6013  namespace detail
6014  {
6015  template<typename T>
6016  using null_function_t = decltype(std::declval<T&>().null());
6017  template<typename T>
6018  using boolean_function_t =
6019      decltype(std::declval<T&>().boolean(std::declval<bool>()));
6020  template<typename T, typename Integer>
6021  using number_integer_function_t =
6022      decltype(std::declval<T&>().number_integer(std::declval<Integer>()));
6023  template<typename T, typename Unsigned>
6024  using number_unsigned_function_t =
6025      decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));
6026  template<typename T, typename Float, typename String>
6027  using number_float_function_t = decltype(std::declval<T&>().number_float(
6028                                      std::declval<Float>(), std::declval<const String&>()));
6029  template<typename T, typename String>
6030  using string_function_t =
6031      decltype(std::declval<T&>().string(std::declval<String&>()));
6032  template<typename T, typename Binary>
6033  using binary_function_t =
6034      decltype(std::declval<T&>().binary(std::declval<Binary&>()));
6035  template<typename T>
6036  using start_object_function_t =
6037      decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));
6038  template<typename T, typename String>
6039  using key_function_t =
6040      decltype(std::declval<T&>().key(std::declval<String&>()));
6041  template<typename T>
6042  using end_object_function_t = decltype(std::declval<T&>().end_object());
6043  template<typename T>
6044  using start_array_function_t =
6045      decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));
6046  template<typename T>
6047  using end_array_function_t = decltype(std::declval<T&>().end_array());
6048  template<typename T, typename Exception>
6049  using parse_error_function_t = decltype(std::declval<T&>().parse_error(
6050          std::declval<std::size_t>(), std::declval<const std::string&>(),
6051          std::declval<const Exception&>()));
6052  template<typename SAX, typename BasicJsonType>
6053  struct is_sax
6054  {
6055    private:
6056      static_assert(is_basic_json<BasicJsonType>::value,
6057                    "BasicJsonType must be of type basic_json<...>");
6058      using number_integer_t = typename BasicJsonType::number_integer_t;
6059      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6060      using number_float_t = typename BasicJsonType::number_float_t;
6061      using string_t = typename BasicJsonType::string_t;
6062      using binary_t = typename BasicJsonType::binary_t;
6063      using exception_t = typename BasicJsonType::exception;
6064    public:
6065      static constexpr bool value =
6066          is_detected_exact<bool, null_function_t, SAX>::value &&
6067          is_detected_exact<bool, boolean_function_t, SAX>::value &&
6068          is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
6069          is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
6070          is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
6071          is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
6072          is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
6073          is_detected_exact<bool, start_object_function_t, SAX>::value &&
6074          is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
6075          is_detected_exact<bool, end_object_function_t, SAX>::value &&
6076          is_detected_exact<bool, start_array_function_t, SAX>::value &&
6077          is_detected_exact<bool, end_array_function_t, SAX>::value &&
6078          is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
6079  };
6080  template<typename SAX, typename BasicJsonType>
6081  struct is_sax_static_asserts
6082  {
6083    private:
6084      static_assert(is_basic_json<BasicJsonType>::value,
6085                    "BasicJsonType must be of type basic_json<...>");
6086      using number_integer_t = typename BasicJsonType::number_integer_t;
6087      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6088      using number_float_t = typename BasicJsonType::number_float_t;
6089      using string_t = typename BasicJsonType::string_t;
6090      using binary_t = typename BasicJsonType::binary_t;
6091      using exception_t = typename BasicJsonType::exception;
6092    public:
6093      static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
6094                    "Missing/invalid function: bool null()");
6095      static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
6096                    "Missing/invalid function: bool boolean(bool)");
6097      static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
6098                    "Missing/invalid function: bool boolean(bool)");
6099      static_assert(
6100          is_detected_exact<bool, number_integer_function_t, SAX,
6101          number_integer_t>::value,
6102          "Missing/invalid function: bool number_integer(number_integer_t)");
6103      static_assert(
6104          is_detected_exact<bool, number_unsigned_function_t, SAX,
6105          number_unsigned_t>::value,
6106          "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
6107      static_assert(is_detected_exact<bool, number_float_function_t, SAX,
6108                    number_float_t, string_t>::value,
6109                    "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
6110      static_assert(
6111          is_detected_exact<bool, string_function_t, SAX, string_t>::value,
6112          "Missing/invalid function: bool string(string_t&)");
6113      static_assert(
6114          is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
6115          "Missing/invalid function: bool binary(binary_t&)");
6116      static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
6117                    "Missing/invalid function: bool start_object(std::size_t)");
6118      static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
6119                    "Missing/invalid function: bool key(string_t&)");
6120      static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
6121                    "Missing/invalid function: bool end_object()");
6122      static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
6123                    "Missing/invalid function: bool start_array(std::size_t)");
6124      static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
6125                    "Missing/invalid function: bool end_array()");
6126      static_assert(
6127          is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
6128          "Missing/invalid function: bool parse_error(std::size_t, const "
6129          "std::string&, const exception&)");
6130  };
6131  }  
6132  }  
6133  namespace nlohmann
6134  {
6135  namespace detail
6136  {
6137  enum class cbor_tag_handler_t
6138  {
6139      error,   
6140      ignore,  
6141      store    
6142  };
6143  static inline bool little_endianess(int num = 1) noexcept
6144  {
6145      return *reinterpret_cast<char*>(&num) == 1;
6146  }
6147  template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
6148  class binary_reader
6149  {
6150      using number_integer_t = typename BasicJsonType::number_integer_t;
6151      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
6152      using number_float_t = typename BasicJsonType::number_float_t;
6153      using string_t = typename BasicJsonType::string_t;
6154      using binary_t = typename BasicJsonType::binary_t;
6155      using json_sax_t = SAX;
6156      using char_type = typename InputAdapterType::char_type;
6157      using char_int_type = typename std::char_traits<char_type>::int_type;
6158    public:
6159      explicit binary_reader(InputAdapterType&& adapter) noexcept : ia(std::move(adapter))
6160      {
6161          (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
6162      }
6163      binary_reader(const binary_reader&) = delete;
6164      binary_reader(binary_reader&&) = default; 
6165      binary_reader& operator=(const binary_reader&) = delete;
6166      binary_reader& operator=(binary_reader&&) = default; 
6167      ~binary_reader() = default;
6168      JSON_HEDLEY_NON_NULL(3)
6169      bool sax_parse(const input_format_t format,
6170                     json_sax_t* sax_,
6171                     const bool strict = true,
6172                     const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
6173      {
6174          sax = sax_;
6175          bool result = false;
6176          switch (format)
6177          {
6178              case input_format_t::bson:
6179                  result = parse_bson_internal();
6180                  break;
6181              case input_format_t::cbor:
6182                  result = parse_cbor_internal(true, tag_handler);
6183                  break;
6184              case input_format_t::msgpack:
6185                  result = parse_msgpack_internal();
6186                  break;
6187              case input_format_t::ubjson:
6188                  result = parse_ubjson_internal();
6189                  break;
6190              case input_format_t::json: 
6191              default:            
6192                  JSON_ASSERT(false); 
6193          }
6194          if (result && strict)
6195          {
6196              if (format == input_format_t::ubjson)
6197              {
6198                  get_ignore_noop();
6199              }
6200              else
6201              {
6202                  get();
6203              }
6204              if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))
6205              {
6206                  return sax->parse_error(chars_read, get_token_string(),
6207                                          parse_error::create(110, chars_read, exception_message(format, "expected end of input; last byte: 0x" + get_token_string(), "value"), BasicJsonType()));
6208              }
6209          }
6210          return result;
6211      }
6212    private:
6213      bool parse_bson_internal()
6214      {
6215          std::int32_t document_size{};
6216          get_number<std::int32_t, true>(input_format_t::bson, document_size);
6217          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
6218          {
6219              return false;
6220          }
6221          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&bsol;*is_array*/false)))
6222          {
6223              return false;
6224          }
6225          return sax->end_object();
6226      }
6227      bool get_bson_cstr(string_t& result)
6228      {
6229          auto out = std::back_inserter(result);
6230          while (true)
6231          {
6232              get();
6233              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
6234              {
6235                  return false;
6236              }
6237              if (current == 0x00)
6238              {
6239                  return true;
6240              }
6241              *out++ = static_cast<typename string_t::value_type>(current);
6242          }
6243      }
6244      template<typename NumberType>
6245      bool get_bson_string(const NumberType len, string_t& result)
6246      {
6247          if (JSON_HEDLEY_UNLIKELY(len < 1))
6248          {
6249              auto last_token = get_token_string();
6250              return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "string length must be at least 1, is " + std::to_string(len), "string"), BasicJsonType()));
6251          }
6252          return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
6253      }
6254      template<typename NumberType>
6255      bool get_bson_binary(const NumberType len, binary_t& result)
6256      {
6257          if (JSON_HEDLEY_UNLIKELY(len < 0))
6258          {
6259              auto last_token = get_token_string();
6260              return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, "byte array length cannot be negative, is " + std::to_string(len), "binary"), BasicJsonType()));
6261          }
6262          std::uint8_t subtype{};
6263          get_number<std::uint8_t>(input_format_t::bson, subtype);
6264          result.set_subtype(subtype);
6265          return get_binary(input_format_t::bson, len, result);
6266      }
6267      bool parse_bson_element_internal(const char_int_type element_type,
6268                                       const std::size_t element_type_parse_position)
6269      {
6270          switch (element_type)
6271          {
6272              case 0x01: 
6273              {
6274                  double number{};
6275                  return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
6276              }
6277              case 0x02: 
6278              {
6279                  std::int32_t len{};
6280                  string_t value;
6281                  return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
6282              }
6283              case 0x03: 
6284              {
6285                  return parse_bson_internal();
6286              }
6287              case 0x04: 
6288              {
6289                  return parse_bson_array();
6290              }
6291              case 0x05: 
6292              {
6293                  std::int32_t len{};
6294                  binary_t value;
6295                  return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
6296              }
6297              case 0x08: 
6298              {
6299                  return sax->boolean(get() != 0);
6300              }
6301              case 0x0A: 
6302              {
6303                  return sax->null();
6304              }
6305              case 0x10: 
6306              {
6307                  std::int32_t value{};
6308                  return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
6309              }
6310              case 0x12: 
6311              {
6312                  std::int64_t value{};
6313                  return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
6314              }
6315              default: 
6316              {
6317                  std::array<char, 3> cr{{}};
6318                  (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type)); 
6319                  return sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, "Unsupported BSON record type 0x" + std::string(cr.data()), BasicJsonType()));
6320              }
6321          }
6322      }
6323      bool parse_bson_element_list(const bool is_array)
6324      {
6325          string_t key;
6326          while (auto element_type = get())
6327          {
6328              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
6329              {
6330                  return false;
6331              }
6332              const std::size_t element_type_parse_position = chars_read;
6333              if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
6334              {
6335                  return false;
6336              }
6337              if (!is_array && !sax->key(key))
6338              {
6339                  return false;
6340              }
6341              if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
6342              {
6343                  return false;
6344              }
6345              key.clear();
6346          }
6347          return true;
6348      }
6349      bool parse_bson_array()
6350      {
6351          std::int32_t document_size{};
6352          get_number<std::int32_t, true>(input_format_t::bson, document_size);
6353          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
6354          {
6355              return false;
6356          }
6357          if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(&bsol;*is_array*/true)))
6358          {
6359              return false;
6360          }
6361          return sax->end_array();
6362      }
6363      bool parse_cbor_internal(const bool get_char,
6364                               const cbor_tag_handler_t tag_handler)
6365      {
6366          switch (get_char ? get() : current)
6367          {
6368              case std::char_traits<char_type>::eof():
6369                  return unexpect_eof(input_format_t::cbor, "value");
6370              case 0x00:
6371              case 0x01:
6372              case 0x02:
6373              case 0x03:
6374              case 0x04:
6375              case 0x05:
6376              case 0x06:
6377              case 0x07:
6378              case 0x08:
6379              case 0x09:
6380              case 0x0A:
6381              case 0x0B:
6382              case 0x0C:
6383              case 0x0D:
6384              case 0x0E:
6385              case 0x0F:
6386              case 0x10:
6387              case 0x11:
6388              case 0x12:
6389              case 0x13:
6390              case 0x14:
6391              case 0x15:
6392              case 0x16:
6393              case 0x17:
6394                  return sax->number_unsigned(static_cast<number_unsigned_t>(current));
6395              case 0x18: 
6396              {
6397                  std::uint8_t number{};
6398                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
6399              }
6400              case 0x19: 
6401              {
6402                  std::uint16_t number{};
6403                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
6404              }
6405              case 0x1A: 
6406              {
6407                  std::uint32_t number{};
6408                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
6409              }
6410              case 0x1B: 
6411              {
6412                  std::uint64_t number{};
6413                  return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
6414              }
6415              case 0x20:
6416              case 0x21:
6417              case 0x22:
6418              case 0x23:
6419              case 0x24:
6420              case 0x25:
6421              case 0x26:
6422              case 0x27:
6423              case 0x28:
6424              case 0x29:
6425              case 0x2A:
6426              case 0x2B:
6427              case 0x2C:
6428              case 0x2D:
6429              case 0x2E:
6430              case 0x2F:
6431              case 0x30:
6432              case 0x31:
6433              case 0x32:
6434              case 0x33:
6435              case 0x34:
6436              case 0x35:
6437              case 0x36:
6438              case 0x37:
6439                  return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));
6440              case 0x38: 
6441              {
6442                  std::uint8_t number{};
6443                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
6444              }
6445              case 0x39: 
6446              {
6447                  std::uint16_t number{};
6448                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
6449              }
6450              case 0x3A: 
6451              {
6452                  std::uint32_t number{};
6453                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
6454              }
6455              case 0x3B: 
6456              {
6457                  std::uint64_t number{};
6458                  return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
6459                          - static_cast<number_integer_t>(number));
6460              }
6461              case 0x40:
6462              case 0x41:
6463              case 0x42:
6464              case 0x43:
6465              case 0x44:
6466              case 0x45:
6467              case 0x46:
6468              case 0x47:
6469              case 0x48:
6470              case 0x49:
6471              case 0x4A:
6472              case 0x4B:
6473              case 0x4C:
6474              case 0x4D:
6475              case 0x4E:
6476              case 0x4F:
6477              case 0x50:
6478              case 0x51:
6479              case 0x52:
6480              case 0x53:
6481              case 0x54:
6482              case 0x55:
6483              case 0x56:
6484              case 0x57:
6485              case 0x58: 
6486              case 0x59: 
6487              case 0x5A: 
6488              case 0x5B: 
6489              case 0x5F: 
6490              {
6491                  binary_t b;
6492                  return get_cbor_binary(b) && sax->binary(b);
6493              }
6494              case 0x60:
6495              case 0x61:
6496              case 0x62:
6497              case 0x63:
6498              case 0x64:
6499              case 0x65:
6500              case 0x66:
6501              case 0x67:
6502              case 0x68:
6503              case 0x69:
6504              case 0x6A:
6505              case 0x6B:
6506              case 0x6C:
6507              case 0x6D:
6508              case 0x6E:
6509              case 0x6F:
6510              case 0x70:
6511              case 0x71:
6512              case 0x72:
6513              case 0x73:
6514              case 0x74:
6515              case 0x75:
6516              case 0x76:
6517              case 0x77:
6518              case 0x78: 
6519              case 0x79: 
6520              case 0x7A: 
6521              case 0x7B: 
6522              case 0x7F: 
6523              {
6524                  string_t s;
6525                  return get_cbor_string(s) && sax->string(s);
6526              }
6527              case 0x80:
6528              case 0x81:
6529              case 0x82:
6530              case 0x83:
6531              case 0x84:
6532              case 0x85:
6533              case 0x86:
6534              case 0x87:
6535              case 0x88:
6536              case 0x89:
6537              case 0x8A:
6538              case 0x8B:
6539              case 0x8C:
6540              case 0x8D:
6541              case 0x8E:
6542              case 0x8F:
6543              case 0x90:
6544              case 0x91:
6545              case 0x92:
6546              case 0x93:
6547              case 0x94:
6548              case 0x95:
6549              case 0x96:
6550              case 0x97:
6551                  return get_cbor_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
6552              case 0x98: 
6553              {
6554                  std::uint8_t len{};
6555                  return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
6556              }
6557              case 0x99: 
6558              {
6559                  std::uint16_t len{};
6560                  return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
6561              }
6562              case 0x9A: 
6563              {
6564                  std::uint32_t len{};
6565                  return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
6566              }
6567              case 0x9B: 
6568              {
6569                  std::uint64_t len{};
6570                  return get_number(input_format_t::cbor, len) && get_cbor_array(detail::conditional_static_cast<std::size_t>(len), tag_handler);
6571              }
6572              case 0x9F: 
6573                  return get_cbor_array(std::size_t(-1), tag_handler);
6574              case 0xA0:
6575              case 0xA1:
6576              case 0xA2:
6577              case 0xA3:
6578              case 0xA4:
6579              case 0xA5:
6580              case 0xA6:
6581              case 0xA7:
6582              case 0xA8:
6583              case 0xA9:
6584              case 0xAA:
6585              case 0xAB:
6586              case 0xAC:
6587              case 0xAD:
6588              case 0xAE:
6589              case 0xAF:
6590              case 0xB0:
6591              case 0xB1:
6592              case 0xB2:
6593              case 0xB3:
6594              case 0xB4:
6595              case 0xB5:
6596              case 0xB6:
6597              case 0xB7:
6598                  return get_cbor_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);
6599              case 0xB8: 
6600              {
6601                  std::uint8_t len{};
6602                  return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
6603              }
6604              case 0xB9: 
6605              {
6606                  std::uint16_t len{};
6607                  return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
6608              }
6609              case 0xBA: 
6610              {
6611                  std::uint32_t len{};
6612                  return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
6613              }
6614              case 0xBB: 
6615              {
6616                  std::uint64_t len{};
6617                  return get_number(input_format_t::cbor, len) && get_cbor_object(detail::conditional_static_cast<std::size_t>(len), tag_handler);
6618              }
6619              case 0xBF: 
6620                  return get_cbor_object(std::size_t(-1), tag_handler);
6621              case 0xC6: 
6622              case 0xC7:
6623              case 0xC8:
6624              case 0xC9:
6625              case 0xCA:
6626              case 0xCB:
6627              case 0xCC:
6628              case 0xCD:
6629              case 0xCE:
6630              case 0xCF:
6631              case 0xD0:
6632              case 0xD1:
6633              case 0xD2:
6634              case 0xD3:
6635              case 0xD4:
6636              case 0xD8: 
6637              case 0xD9: 
6638              case 0xDA: 
6639              case 0xDB: 
6640              {
6641                  switch (tag_handler)
6642                  {
6643                      case cbor_tag_handler_t::error:
6644                      {
6645                          auto last_token = get_token_string();
6646                          return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value"), BasicJsonType()));
6647                      }
6648                      case cbor_tag_handler_t::ignore:
6649                      {
6650                          switch (current)
6651                          {
6652                              case 0xD8:
6653                              {
6654                                  std::uint8_t subtype_to_ignore{};
6655                                  get_number(input_format_t::cbor, subtype_to_ignore);
6656                                  break;
6657                              }
6658                              case 0xD9:
6659                              {
6660                                  std::uint16_t subtype_to_ignore{};
6661                                  get_number(input_format_t::cbor, subtype_to_ignore);
6662                                  break;
6663                              }
6664                              case 0xDA:
6665                              {
6666                                  std::uint32_t subtype_to_ignore{};
6667                                  get_number(input_format_t::cbor, subtype_to_ignore);
6668                                  break;
6669                              }
6670                              case 0xDB:
6671                              {
6672                                  std::uint64_t subtype_to_ignore{};
6673                                  get_number(input_format_t::cbor, subtype_to_ignore);
6674                                  break;
6675                              }
6676                              default:
6677                                  break;
6678                          }
6679                          return parse_cbor_internal(true, tag_handler);
6680                      }
6681                      case cbor_tag_handler_t::store:
6682                      {
6683                          binary_t b;
6684                          switch (current)
6685                          {
6686                              case 0xD8:
6687                              {
6688                                  std::uint8_t subtype{};
6689                                  get_number(input_format_t::cbor, subtype);
6690                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
6691                                  break;
6692                              }
6693                              case 0xD9:
6694                              {
6695                                  std::uint16_t subtype{};
6696                                  get_number(input_format_t::cbor, subtype);
6697                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
6698                                  break;
6699                              }
6700                              case 0xDA:
6701                              {
6702                                  std::uint32_t subtype{};
6703                                  get_number(input_format_t::cbor, subtype);
6704                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
6705                                  break;
6706                              }
6707                              case 0xDB:
6708                              {
6709                                  std::uint64_t subtype{};
6710                                  get_number(input_format_t::cbor, subtype);
6711                                  b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
6712                                  break;
6713                              }
6714                              default:
6715                                  return parse_cbor_internal(true, tag_handler);
6716                          }
6717                          get();
6718                          return get_cbor_binary(b) && sax->binary(b);
6719                      }
6720                      default:                 
6721                          JSON_ASSERT(false); 
6722                          return false;        
6723                  }
6724              }
6725              case 0xF4: 
6726                  return sax->boolean(false);
6727              case 0xF5: 
6728                  return sax->boolean(true);
6729              case 0xF6: 
6730                  return sax->null();
6731              case 0xF9: 
6732              {
6733                  const auto byte1_raw = get();
6734                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
6735                  {
6736                      return false;
6737                  }
6738                  const auto byte2_raw = get();
6739                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
6740                  {
6741                      return false;
6742                  }
6743                  const auto byte1 = static_cast<unsigned char>(byte1_raw);
6744                  const auto byte2 = static_cast<unsigned char>(byte2_raw);
6745                  const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
6746                  const double val = [&half]
6747                  {
6748                      const int exp = (half >> 10u) & 0x1Fu;
6749                      const unsigned int mant = half & 0x3FFu;
6750                      JSON_ASSERT(0 <= exp&& exp <= 32);
6751                      JSON_ASSERT(mant <= 1024);
6752                      switch (exp)
6753                      {
6754                          case 0:
6755                              return std::ldexp(mant, -24);
6756                          case 31:
6757                              return (mant == 0)
6758                              ? std::numeric_limits<double>::infinity()
6759                              : std::numeric_limits<double>::quiet_NaN();
6760                          default:
6761                              return std::ldexp(mant + 1024, exp - 25);
6762                      }
6763                  }();
6764                  return sax->number_float((half & 0x8000u) != 0
6765                                           ? static_cast<number_float_t>(-val)
6766                                           : static_cast<number_float_t>(val), "");
6767              }
6768              case 0xFA: 
6769              {
6770                  float number{};
6771                  return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
6772              }
6773              case 0xFB: 
6774              {
6775                  double number{};
6776                  return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
6777              }
6778              default: 
6779              {
6780                  auto last_token = get_token_string();
6781                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, "invalid byte: 0x" + last_token, "value"), BasicJsonType()));
6782              }
6783          }
6784      }
6785      bool get_cbor_string(string_t& result)
6786      {
6787          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
6788          {
6789              return false;
6790          }
6791          switch (current)
6792          {
6793              case 0x60:
6794              case 0x61:
6795              case 0x62:
6796              case 0x63:
6797              case 0x64:
6798              case 0x65:
6799              case 0x66:
6800              case 0x67:
6801              case 0x68:
6802              case 0x69:
6803              case 0x6A:
6804              case 0x6B:
6805              case 0x6C:
6806              case 0x6D:
6807              case 0x6E:
6808              case 0x6F:
6809              case 0x70:
6810              case 0x71:
6811              case 0x72:
6812              case 0x73:
6813              case 0x74:
6814              case 0x75:
6815              case 0x76:
6816              case 0x77:
6817              {
6818                  return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
6819              }
6820              case 0x78: 
6821              {
6822                  std::uint8_t len{};
6823                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
6824              }
6825              case 0x79: 
6826              {
6827                  std::uint16_t len{};
6828                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
6829              }
6830              case 0x7A: 
6831              {
6832                  std::uint32_t len{};
6833                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
6834              }
6835              case 0x7B: 
6836              {
6837                  std::uint64_t len{};
6838                  return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
6839              }
6840              case 0x7F: 
6841              {
6842                  while (get() != 0xFF)
6843                  {
6844                      string_t chunk;
6845                      if (!get_cbor_string(chunk))
6846                      {
6847                          return false;
6848                      }
6849                      result.append(chunk);
6850                  }
6851                  return true;
6852              }
6853              default:
6854              {
6855                  auto last_token = get_token_string();
6856                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x" + last_token, "string"), BasicJsonType()));
6857              }
6858          }
6859      }
6860      bool get_cbor_binary(binary_t& result)
6861      {
6862          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
6863          {
6864              return false;
6865          }
6866          switch (current)
6867          {
6868              case 0x40:
6869              case 0x41:
6870              case 0x42:
6871              case 0x43:
6872              case 0x44:
6873              case 0x45:
6874              case 0x46:
6875              case 0x47:
6876              case 0x48:
6877              case 0x49:
6878              case 0x4A:
6879              case 0x4B:
6880              case 0x4C:
6881              case 0x4D:
6882              case 0x4E:
6883              case 0x4F:
6884              case 0x50:
6885              case 0x51:
6886              case 0x52:
6887              case 0x53:
6888              case 0x54:
6889              case 0x55:
6890              case 0x56:
6891              case 0x57:
6892              {
6893                  return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
6894              }
6895              case 0x58: 
6896              {
6897                  std::uint8_t len{};
6898                  return get_number(input_format_t::cbor, len) &&
6899                         get_binary(input_format_t::cbor, len, result);
6900              }
6901              case 0x59: 
6902              {
6903                  std::uint16_t len{};
6904                  return get_number(input_format_t::cbor, len) &&
6905                         get_binary(input_format_t::cbor, len, result);
6906              }
6907              case 0x5A: 
6908              {
6909                  std::uint32_t len{};
6910                  return get_number(input_format_t::cbor, len) &&
6911                         get_binary(input_format_t::cbor, len, result);
6912              }
6913              case 0x5B: 
6914              {
6915                  std::uint64_t len{};
6916                  return get_number(input_format_t::cbor, len) &&
6917                         get_binary(input_format_t::cbor, len, result);
6918              }
6919              case 0x5F: 
6920              {
6921                  while (get() != 0xFF)
6922                  {
6923                      binary_t chunk;
6924                      if (!get_cbor_binary(chunk))
6925                      {
6926                          return false;
6927                      }
6928                      result.insert(result.end(), chunk.begin(), chunk.end());
6929                  }
6930                  return true;
6931              }
6932              default:
6933              {
6934                  auto last_token = get_token_string();
6935                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, "expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x" + last_token, "binary"), BasicJsonType()));
6936              }
6937          }
6938      }
6939      bool get_cbor_array(const std::size_t len,
6940                          const cbor_tag_handler_t tag_handler)
6941      {
6942          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
6943          {
6944              return false;
6945          }
6946          if (len != std::size_t(-1))
6947          {
6948              for (std::size_t i = 0; i < len; ++i)
6949              {
6950                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
6951                  {
6952                      return false;
6953                  }
6954              }
6955          }
6956          else
6957          {
6958              while (get() != 0xFF)
6959              {
6960                  if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
6961                  {
6962                      return false;
6963                  }
6964              }
6965          }
6966          return sax->end_array();
6967      }
6968      bool get_cbor_object(const std::size_t len,
6969                           const cbor_tag_handler_t tag_handler)
6970      {
6971          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
6972          {
6973              return false;
6974          }
6975          if (len != 0)
6976          {
6977              string_t key;
6978              if (len != std::size_t(-1))
6979              {
6980                  for (std::size_t i = 0; i < len; ++i)
6981                  {
6982                      get();
6983                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
6984                      {
6985                          return false;
6986                      }
6987                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
6988                      {
6989                          return false;
6990                      }
6991                      key.clear();
6992                  }
6993              }
6994              else
6995              {
6996                  while (get() != 0xFF)
6997                  {
6998                      if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
6999                      {
7000                          return false;
7001                      }
7002                      if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
7003                      {
7004                          return false;
7005                      }
7006                      key.clear();
7007                  }
7008              }
7009          }
7010          return sax->end_object();
7011      }
7012      bool parse_msgpack_internal()
7013      {
7014          switch (get())
7015          {
7016              case std::char_traits<char_type>::eof():
7017                  return unexpect_eof(input_format_t::msgpack, "value");
7018              case 0x00:
7019              case 0x01:
7020              case 0x02:
7021              case 0x03:
7022              case 0x04:
7023              case 0x05:
7024              case 0x06:
7025              case 0x07:
7026              case 0x08:
7027              case 0x09:
7028              case 0x0A:
7029              case 0x0B:
7030              case 0x0C:
7031              case 0x0D:
7032              case 0x0E:
7033              case 0x0F:
7034              case 0x10:
7035              case 0x11:
7036              case 0x12:
7037              case 0x13:
7038              case 0x14:
7039              case 0x15:
7040              case 0x16:
7041              case 0x17:
7042              case 0x18:
7043              case 0x19:
7044              case 0x1A:
7045              case 0x1B:
7046              case 0x1C:
7047              case 0x1D:
7048              case 0x1E:
7049              case 0x1F:
7050              case 0x20:
7051              case 0x21:
7052              case 0x22:
7053              case 0x23:
7054              case 0x24:
7055              case 0x25:
7056              case 0x26:
7057              case 0x27:
7058              case 0x28:
7059              case 0x29:
7060              case 0x2A:
7061              case 0x2B:
7062              case 0x2C:
7063              case 0x2D:
7064              case 0x2E:
7065              case 0x2F:
7066              case 0x30:
7067              case 0x31:
7068              case 0x32:
7069              case 0x33:
7070              case 0x34:
7071              case 0x35:
7072              case 0x36:
7073              case 0x37:
7074              case 0x38:
7075              case 0x39:
7076              case 0x3A:
7077              case 0x3B:
7078              case 0x3C:
7079              case 0x3D:
7080              case 0x3E:
7081              case 0x3F:
7082              case 0x40:
7083              case 0x41:
7084              case 0x42:
7085              case 0x43:
7086              case 0x44:
7087              case 0x45:
7088              case 0x46:
7089              case 0x47:
7090              case 0x48:
7091              case 0x49:
7092              case 0x4A:
7093              case 0x4B:
7094              case 0x4C:
7095              case 0x4D:
7096              case 0x4E:
7097              case 0x4F:
7098              case 0x50:
7099              case 0x51:
7100              case 0x52:
7101              case 0x53:
7102              case 0x54:
7103              case 0x55:
7104              case 0x56:
7105              case 0x57:
7106              case 0x58:
7107              case 0x59:
7108              case 0x5A:
7109              case 0x5B:
7110              case 0x5C:
7111              case 0x5D:
7112              case 0x5E:
7113              case 0x5F:
7114              case 0x60:
7115              case 0x61:
7116              case 0x62:
7117              case 0x63:
7118              case 0x64:
7119              case 0x65:
7120              case 0x66:
7121              case 0x67:
7122              case 0x68:
7123              case 0x69:
7124              case 0x6A:
7125              case 0x6B:
7126              case 0x6C:
7127              case 0x6D:
7128              case 0x6E:
7129              case 0x6F:
7130              case 0x70:
7131              case 0x71:
7132              case 0x72:
7133              case 0x73:
7134              case 0x74:
7135              case 0x75:
7136              case 0x76:
7137              case 0x77:
7138              case 0x78:
7139              case 0x79:
7140              case 0x7A:
7141              case 0x7B:
7142              case 0x7C:
7143              case 0x7D:
7144              case 0x7E:
7145              case 0x7F:
7146                  return sax->number_unsigned(static_cast<number_unsigned_t>(current));
7147              case 0x80:
7148              case 0x81:
7149              case 0x82:
7150              case 0x83:
7151              case 0x84:
7152              case 0x85:
7153              case 0x86:
7154              case 0x87:
7155              case 0x88:
7156              case 0x89:
7157              case 0x8A:
7158              case 0x8B:
7159              case 0x8C:
7160              case 0x8D:
7161              case 0x8E:
7162              case 0x8F:
7163                  return get_msgpack_object(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
7164              case 0x90:
7165              case 0x91:
7166              case 0x92:
7167              case 0x93:
7168              case 0x94:
7169              case 0x95:
7170              case 0x96:
7171              case 0x97:
7172              case 0x98:
7173              case 0x99:
7174              case 0x9A:
7175              case 0x9B:
7176              case 0x9C:
7177              case 0x9D:
7178              case 0x9E:
7179              case 0x9F:
7180                  return get_msgpack_array(static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));
7181              case 0xA0:
7182              case 0xA1:
7183              case 0xA2:
7184              case 0xA3:
7185              case 0xA4:
7186              case 0xA5:
7187              case 0xA6:
7188              case 0xA7:
7189              case 0xA8:
7190              case 0xA9:
7191              case 0xAA:
7192              case 0xAB:
7193              case 0xAC:
7194              case 0xAD:
7195              case 0xAE:
7196              case 0xAF:
7197              case 0xB0:
7198              case 0xB1:
7199              case 0xB2:
7200              case 0xB3:
7201              case 0xB4:
7202              case 0xB5:
7203              case 0xB6:
7204              case 0xB7:
7205              case 0xB8:
7206              case 0xB9:
7207              case 0xBA:
7208              case 0xBB:
7209              case 0xBC:
7210              case 0xBD:
7211              case 0xBE:
7212              case 0xBF:
7213              case 0xD9: 
7214              case 0xDA: 
7215              case 0xDB: 
7216              {
7217                  string_t s;
7218                  return get_msgpack_string(s) && sax->string(s);
7219              }
7220              case 0xC0: 
7221                  return sax->null();
7222              case 0xC2: 
7223                  return sax->boolean(false);
7224              case 0xC3: 
7225                  return sax->boolean(true);
7226              case 0xC4: 
7227              case 0xC5: 
7228              case 0xC6: 
7229              case 0xC7: 
7230              case 0xC8: 
7231              case 0xC9: 
7232              case 0xD4: 
7233              case 0xD5: 
7234              case 0xD6: 
7235              case 0xD7: 
7236              case 0xD8: 
7237              {
7238                  binary_t b;
7239                  return get_msgpack_binary(b) && sax->binary(b);
7240              }
7241              case 0xCA: 
7242              {
7243                  float number{};
7244                  return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
7245              }
7246              case 0xCB: 
7247              {
7248                  double number{};
7249                  return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
7250              }
7251              case 0xCC: 
7252              {
7253                  std::uint8_t number{};
7254                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7255              }
7256              case 0xCD: 
7257              {
7258                  std::uint16_t number{};
7259                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7260              }
7261              case 0xCE: 
7262              {
7263                  std::uint32_t number{};
7264                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7265              }
7266              case 0xCF: 
7267              {
7268                  std::uint64_t number{};
7269                  return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
7270              }
7271              case 0xD0: 
7272              {
7273                  std::int8_t number{};
7274                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7275              }
7276              case 0xD1: 
7277              {
7278                  std::int16_t number{};
7279                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7280              }
7281              case 0xD2: 
7282              {
7283                  std::int32_t number{};
7284                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7285              }
7286              case 0xD3: 
7287              {
7288                  std::int64_t number{};
7289                  return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
7290              }
7291              case 0xDC: 
7292              {
7293                  std::uint16_t len{};
7294                  return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
7295              }
7296              case 0xDD: 
7297              {
7298                  std::uint32_t len{};
7299                  return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
7300              }
7301              case 0xDE: 
7302              {
7303                  std::uint16_t len{};
7304                  return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
7305              }
7306              case 0xDF: 
7307              {
7308                  std::uint32_t len{};
7309                  return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
7310              }
7311              case 0xE0:
7312              case 0xE1:
7313              case 0xE2:
7314              case 0xE3:
7315              case 0xE4:
7316              case 0xE5:
7317              case 0xE6:
7318              case 0xE7:
7319              case 0xE8:
7320              case 0xE9:
7321              case 0xEA:
7322              case 0xEB:
7323              case 0xEC:
7324              case 0xED:
7325              case 0xEE:
7326              case 0xEF:
7327              case 0xF0:
7328              case 0xF1:
7329              case 0xF2:
7330              case 0xF3:
7331              case 0xF4:
7332              case 0xF5:
7333              case 0xF6:
7334              case 0xF7:
7335              case 0xF8:
7336              case 0xF9:
7337              case 0xFA:
7338              case 0xFB:
7339              case 0xFC:
7340              case 0xFD:
7341              case 0xFE:
7342              case 0xFF:
7343                  return sax->number_integer(static_cast<std::int8_t>(current));
7344              default: 
7345              {
7346                  auto last_token = get_token_string();
7347                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, "invalid byte: 0x" + last_token, "value"), BasicJsonType()));
7348              }
7349          }
7350      }
7351      bool get_msgpack_string(string_t& result)
7352      {
7353          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
7354          {
7355              return false;
7356          }
7357          switch (current)
7358          {
7359              case 0xA0:
7360              case 0xA1:
7361              case 0xA2:
7362              case 0xA3:
7363              case 0xA4:
7364              case 0xA5:
7365              case 0xA6:
7366              case 0xA7:
7367              case 0xA8:
7368              case 0xA9:
7369              case 0xAA:
7370              case 0xAB:
7371              case 0xAC:
7372              case 0xAD:
7373              case 0xAE:
7374              case 0xAF:
7375              case 0xB0:
7376              case 0xB1:
7377              case 0xB2:
7378              case 0xB3:
7379              case 0xB4:
7380              case 0xB5:
7381              case 0xB6:
7382              case 0xB7:
7383              case 0xB8:
7384              case 0xB9:
7385              case 0xBA:
7386              case 0xBB:
7387              case 0xBC:
7388              case 0xBD:
7389              case 0xBE:
7390              case 0xBF:
7391              {
7392                  return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
7393              }
7394              case 0xD9: 
7395              {
7396                  std::uint8_t len{};
7397                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
7398              }
7399              case 0xDA: 
7400              {
7401                  std::uint16_t len{};
7402                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
7403              }
7404              case 0xDB: 
7405              {
7406                  std::uint32_t len{};
7407                  return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
7408              }
7409              default:
7410              {
7411                  auto last_token = get_token_string();
7412                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x" + last_token, "string"), BasicJsonType()));
7413              }
7414          }
7415      }
7416      bool get_msgpack_binary(binary_t& result)
7417      {
7418          auto assign_and_return_true = [&result](std::int8_t subtype)
7419          {
7420              result.set_subtype(static_cast<std::uint8_t>(subtype));
7421              return true;
7422          };
7423          switch (current)
7424          {
7425              case 0xC4: 
7426              {
7427                  std::uint8_t len{};
7428                  return get_number(input_format_t::msgpack, len) &&
7429                         get_binary(input_format_t::msgpack, len, result);
7430              }
7431              case 0xC5: 
7432              {
7433                  std::uint16_t len{};
7434                  return get_number(input_format_t::msgpack, len) &&
7435                         get_binary(input_format_t::msgpack, len, result);
7436              }
7437              case 0xC6: 
7438              {
7439                  std::uint32_t len{};
7440                  return get_number(input_format_t::msgpack, len) &&
7441                         get_binary(input_format_t::msgpack, len, result);
7442              }
7443              case 0xC7: 
7444              {
7445                  std::uint8_t len{};
7446                  std::int8_t subtype{};
7447                  return get_number(input_format_t::msgpack, len) &&
7448                         get_number(input_format_t::msgpack, subtype) &&
7449                         get_binary(input_format_t::msgpack, len, result) &&
7450                         assign_and_return_true(subtype);
7451              }
7452              case 0xC8: 
7453              {
7454                  std::uint16_t len{};
7455                  std::int8_t subtype{};
7456                  return get_number(input_format_t::msgpack, len) &&
7457                         get_number(input_format_t::msgpack, subtype) &&
7458                         get_binary(input_format_t::msgpack, len, result) &&
7459                         assign_and_return_true(subtype);
7460              }
7461              case 0xC9: 
7462              {
7463                  std::uint32_t len{};
7464                  std::int8_t subtype{};
7465                  return get_number(input_format_t::msgpack, len) &&
7466                         get_number(input_format_t::msgpack, subtype) &&
7467                         get_binary(input_format_t::msgpack, len, result) &&
7468                         assign_and_return_true(subtype);
7469              }
7470              case 0xD4: 
7471              {
7472                  std::int8_t subtype{};
7473                  return get_number(input_format_t::msgpack, subtype) &&
7474                         get_binary(input_format_t::msgpack, 1, result) &&
7475                         assign_and_return_true(subtype);
7476              }
7477              case 0xD5: 
7478              {
7479                  std::int8_t subtype{};
7480                  return get_number(input_format_t::msgpack, subtype) &&
7481                         get_binary(input_format_t::msgpack, 2, result) &&
7482                         assign_and_return_true(subtype);
7483              }
7484              case 0xD6: 
7485              {
7486                  std::int8_t subtype{};
7487                  return get_number(input_format_t::msgpack, subtype) &&
7488                         get_binary(input_format_t::msgpack, 4, result) &&
7489                         assign_and_return_true(subtype);
7490              }
7491              case 0xD7: 
7492              {
7493                  std::int8_t subtype{};
7494                  return get_number(input_format_t::msgpack, subtype) &&
7495                         get_binary(input_format_t::msgpack, 8, result) &&
7496                         assign_and_return_true(subtype);
7497              }
7498              case 0xD8: 
7499              {
7500                  std::int8_t subtype{};
7501                  return get_number(input_format_t::msgpack, subtype) &&
7502                         get_binary(input_format_t::msgpack, 16, result) &&
7503                         assign_and_return_true(subtype);
7504              }
7505              default:           
7506                  return false;  
7507          }
7508      }
7509      bool get_msgpack_array(const std::size_t len)
7510      {
7511          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
7512          {
7513              return false;
7514          }
7515          for (std::size_t i = 0; i < len; ++i)
7516          {
7517              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
7518              {
7519                  return false;
7520              }
7521          }
7522          return sax->end_array();
7523      }
7524      bool get_msgpack_object(const std::size_t len)
7525      {
7526          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
7527          {
7528              return false;
7529          }
7530          string_t key;
7531          for (std::size_t i = 0; i < len; ++i)
7532          {
7533              get();
7534              if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
7535              {
7536                  return false;
7537              }
7538              if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
7539              {
7540                  return false;
7541              }
7542              key.clear();
7543          }
7544          return sax->end_object();
7545      }
7546      bool parse_ubjson_internal(const bool get_char = true)
7547      {
7548          return get_ubjson_value(get_char ? get_ignore_noop() : current);
7549      }
7550      bool get_ubjson_string(string_t& result, const bool get_char = true)
7551      {
7552          if (get_char)
7553          {
7554              get();  
7555          }
7556          if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
7557          {
7558              return false;
7559          }
7560          switch (current)
7561          {
7562              case 'U':
7563              {
7564                  std::uint8_t len{};
7565                  return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
7566              }
7567              case 'i':
7568              {
7569                  std::int8_t len{};
7570                  return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
7571              }
7572              case 'I':
7573              {
7574                  std::int16_t len{};
7575                  return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
7576              }
7577              case 'l':
7578              {
7579                  std::int32_t len{};
7580                  return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
7581              }
7582              case 'L':
7583              {
7584                  std::int64_t len{};
7585                  return get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);
7586              }
7587              default:
7588                  auto last_token = get_token_string();
7589                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token, "string"), BasicJsonType()));
7590          }
7591      }
7592      bool get_ubjson_size_value(std::size_t& result)
7593      {
7594          switch (get_ignore_noop())
7595          {
7596              case 'U':
7597              {
7598                  std::uint8_t number{};
7599                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7600                  {
7601                      return false;
7602                  }
7603                  result = static_cast<std::size_t>(number);
7604                  return true;
7605              }
7606              case 'i':
7607              {
7608                  std::int8_t number{};
7609                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7610                  {
7611                      return false;
7612                  }
7613                  result = static_cast<std::size_t>(number); 
7614                  return true;
7615              }
7616              case 'I':
7617              {
7618                  std::int16_t number{};
7619                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7620                  {
7621                      return false;
7622                  }
7623                  result = static_cast<std::size_t>(number);
7624                  return true;
7625              }
7626              case 'l':
7627              {
7628                  std::int32_t number{};
7629                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7630                  {
7631                      return false;
7632                  }
7633                  result = static_cast<std::size_t>(number);
7634                  return true;
7635              }
7636              case 'L':
7637              {
7638                  std::int64_t number{};
7639                  if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))
7640                  {
7641                      return false;
7642                  }
7643                  result = static_cast<std::size_t>(number);
7644                  return true;
7645              }
7646              default:
7647              {
7648                  auto last_token = get_token_string();
7649                  return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token, "size"), BasicJsonType()));
7650              }
7651          }
7652      }
7653      bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result)
7654      {
7655          result.first = string_t::npos; 
7656          result.second = 0; 
7657          get_ignore_noop();
7658          if (current == '$')
7659          {
7660              result.second = get();  
7661              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "type")))
7662              {
7663                  return false;
7664              }
7665              get_ignore_noop();
7666              if (JSON_HEDLEY_UNLIKELY(current != '#'))
7667              {
7668                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "value")))
7669                  {
7670                      return false;
7671                  }
7672                  auto last_token = get_token_string();
7673                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "expected '#' after type information; last byte: 0x" + last_token, "size"), BasicJsonType()));
7674              }
7675              return get_ubjson_size_value(result.first);
7676          }
7677          if (current == '#')
7678          {
7679              return get_ubjson_size_value(result.first);
7680          }
7681          return true;
7682      }
7683      bool get_ubjson_value(const char_int_type prefix)
7684      {
7685          switch (prefix)
7686          {
7687              case std::char_traits<char_type>::eof():  
7688                  return unexpect_eof(input_format_t::ubjson, "value");
7689              case 'T':  
7690                  return sax->boolean(true);
7691              case 'F':  
7692                  return sax->boolean(false);
7693              case 'Z':  
7694                  return sax->null();
7695              case 'U':
7696              {
7697                  std::uint8_t number{};
7698                  return get_number(input_format_t::ubjson, number) && sax->number_unsigned(number);
7699              }
7700              case 'i':
7701              {
7702                  std::int8_t number{};
7703                  return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
7704              }
7705              case 'I':
7706              {
7707                  std::int16_t number{};
7708                  return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
7709              }
7710              case 'l':
7711              {
7712                  std::int32_t number{};
7713                  return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
7714              }
7715              case 'L':
7716              {
7717                  std::int64_t number{};
7718                  return get_number(input_format_t::ubjson, number) && sax->number_integer(number);
7719              }
7720              case 'd':
7721              {
7722                  float number{};
7723                  return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
7724              }
7725              case 'D':
7726              {
7727                  double number{};
7728                  return get_number(input_format_t::ubjson, number) && sax->number_float(static_cast<number_float_t>(number), "");
7729              }
7730              case 'H':
7731              {
7732                  return get_ubjson_high_precision_number();
7733              }
7734              case 'C':  
7735              {
7736                  get();
7737                  if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "char")))
7738                  {
7739                      return false;
7740                  }
7741                  if (JSON_HEDLEY_UNLIKELY(current > 127))
7742                  {
7743                      auto last_token = get_token_string();
7744                      return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token, "char"), BasicJsonType()));
7745                  }
7746                  string_t s(1, static_cast<typename string_t::value_type>(current));
7747                  return sax->string(s);
7748              }
7749              case 'S':  
7750              {
7751                  string_t s;
7752                  return get_ubjson_string(s) && sax->string(s);
7753              }
7754              case '[':  
7755                  return get_ubjson_array();
7756              case '{':  
7757                  return get_ubjson_object();
7758              default: 
7759              {
7760                  auto last_token = get_token_string();
7761                  return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, "invalid byte: 0x" + last_token, "value"), BasicJsonType()));
7762              }
7763          }
7764      }
7765      bool get_ubjson_array()
7766      {
7767          std::pair<std::size_t, char_int_type> size_and_type;
7768          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
7769          {
7770              return false;
7771          }
7772          if (size_and_type.first != string_t::npos)
7773          {
7774              if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
7775              {
7776                  return false;
7777              }
7778              if (size_and_type.second != 0)
7779              {
7780                  if (size_and_type.second != 'N')
7781                  {
7782                      for (std::size_t i = 0; i < size_and_type.first; ++i)
7783                      {
7784                          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
7785                          {
7786                              return false;
7787                          }
7788                      }
7789                  }
7790              }
7791              else
7792              {
7793                  for (std::size_t i = 0; i < size_and_type.first; ++i)
7794                  {
7795                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7796                      {
7797                          return false;
7798                      }
7799                  }
7800              }
7801          }
7802          else
7803          {
7804              if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
7805              {
7806                  return false;
7807              }
7808              while (current != ']')
7809              {
7810                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
7811                  {
7812                      return false;
7813                  }
7814                  get_ignore_noop();
7815              }
7816          }
7817          return sax->end_array();
7818      }
7819      bool get_ubjson_object()
7820      {
7821          std::pair<std::size_t, char_int_type> size_and_type;
7822          if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
7823          {
7824              return false;
7825          }
7826          string_t key;
7827          if (size_and_type.first != string_t::npos)
7828          {
7829              if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
7830              {
7831                  return false;
7832              }
7833              if (size_and_type.second != 0)
7834              {
7835                  for (std::size_t i = 0; i < size_and_type.first; ++i)
7836                  {
7837                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
7838                      {
7839                          return false;
7840                      }
7841                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
7842                      {
7843                          return false;
7844                      }
7845                      key.clear();
7846                  }
7847              }
7848              else
7849              {
7850                  for (std::size_t i = 0; i < size_and_type.first; ++i)
7851                  {
7852                      if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
7853                      {
7854                          return false;
7855                      }
7856                      if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7857                      {
7858                          return false;
7859                      }
7860                      key.clear();
7861                  }
7862              }
7863          }
7864          else
7865          {
7866              if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
7867              {
7868                  return false;
7869              }
7870              while (current != '}')
7871              {
7872                  if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
7873                  {
7874                      return false;
7875                  }
7876                  if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
7877                  {
7878                      return false;
7879                  }
7880                  get_ignore_noop();
7881                  key.clear();
7882              }
7883          }
7884          return sax->end_object();
7885      }
7886      bool get_ubjson_high_precision_number()
7887      {
7888          std::size_t size{};
7889          auto res = get_ubjson_size_value(size);
7890          if (JSON_HEDLEY_UNLIKELY(!res))
7891          {
7892              return res;
7893          }
7894          std::vector<char> number_vector;
7895          for (std::size_t i = 0; i < size; ++i)
7896          {
7897              get();
7898              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, "number")))
7899              {
7900                  return false;
7901              }
7902              number_vector.push_back(static_cast<char>(current));
7903          }
7904          using ia_type = decltype(detail::input_adapter(number_vector));
7905          auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
7906          const auto result_number = number_lexer.scan();
7907          const auto number_string = number_lexer.get_token_string();
7908          const auto result_remainder = number_lexer.scan();
7909          using token_type = typename detail::lexer_base<BasicJsonType>::token_type;
7910          if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
7911          {
7912              return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number"), BasicJsonType()));
7913          }
7914          switch (result_number)
7915          {
7916              case token_type::value_integer:
7917                  return sax->number_integer(number_lexer.get_number_integer());
7918              case token_type::value_unsigned:
7919                  return sax->number_unsigned(number_lexer.get_number_unsigned());
7920              case token_type::value_float:
7921                  return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
7922              case token_type::uninitialized:
7923              case token_type::literal_true:
7924              case token_type::literal_false:
7925              case token_type::literal_null:
7926              case token_type::value_string:
7927              case token_type::begin_array:
7928              case token_type::begin_object:
7929              case token_type::end_array:
7930              case token_type::end_object:
7931              case token_type::name_separator:
7932              case token_type::value_separator:
7933              case token_type::parse_error:
7934              case token_type::end_of_input:
7935              case token_type::literal_or_value:
7936              default:
7937                  return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, "invalid number text: " + number_lexer.get_token_string(), "high-precision number"), BasicJsonType()));
7938          }
7939      }
7940      char_int_type get()
7941      {
7942          ++chars_read;
7943          return current = ia.get_character();
7944      }
7945      char_int_type get_ignore_noop()
7946      {
7947          do
7948          {
7949              get();
7950          }
7951          while (current == 'N');
7952          return current;
7953      }
7954      template<typename NumberType, bool InputIsLittleEndian = false>
7955      bool get_number(const input_format_t format, NumberType& result)
7956      {
7957          std::array<std::uint8_t, sizeof(NumberType)> vec{};
7958          for (std::size_t i = 0; i < sizeof(NumberType); ++i)
7959          {
7960              get();
7961              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
7962              {
7963                  return false;
7964              }
7965              if (is_little_endian != InputIsLittleEndian)
7966              {
7967                  vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
7968              }
7969              else
7970              {
7971                  vec[i] = static_cast<std::uint8_t>(current); 
7972              }
7973          }
7974          std::memcpy(&result, vec.data(), sizeof(NumberType));
7975          return true;
7976      }
7977      template<typename NumberType>
7978      bool get_string(const input_format_t format,
7979                      const NumberType len,
7980                      string_t& result)
7981      {
7982          bool success = true;
7983          for (NumberType i = 0; i < len; i++)
7984          {
7985              get();
7986              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
7987              {
7988                  success = false;
7989                  break;
7990              }
7991              result.push_back(static_cast<typename string_t::value_type>(current));
7992          }
7993          return success;
7994      }
7995      template<typename NumberType>
7996      bool get_binary(const input_format_t format,
7997                      const NumberType len,
7998                      binary_t& result)
7999      {
8000          bool success = true;
8001          for (NumberType i = 0; i < len; i++)
8002          {
8003              get();
8004              if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
8005              {
8006                  success = false;
8007                  break;
8008              }
8009              result.push_back(static_cast<std::uint8_t>(current));
8010          }
8011          return success;
8012      }
8013      JSON_HEDLEY_NON_NULL(3)
8014      bool unexpect_eof(const input_format_t format, const char* context) const
8015      {
8016          if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))
8017          {
8018              return sax->parse_error(chars_read, "<end of file>",
8019                                      parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), BasicJsonType()));
8020          }
8021          return true;
8022      }
8023      std::string get_token_string() const
8024      {
8025          std::array<char, 3> cr{{}};
8026          (std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current)); 
8027          return std::string{cr.data()};
8028      }
8029      std::string exception_message(const input_format_t format,
8030                                    const std::string& detail,
8031                                    const std::string& context) const
8032      {
8033          std::string error_msg = "syntax error while parsing ";
8034          switch (format)
8035          {
8036              case input_format_t::cbor:
8037                  error_msg += "CBOR";
8038                  break;
8039              case input_format_t::msgpack:
8040                  error_msg += "MessagePack";
8041                  break;
8042              case input_format_t::ubjson:
8043                  error_msg += "UBJSON";
8044                  break;
8045              case input_format_t::bson:
8046                  error_msg += "BSON";
8047                  break;
8048              case input_format_t::json: 
8049              default:            
8050                  JSON_ASSERT(false); 
8051          }
8052          return error_msg + " " + context + ": " + detail;
8053      }
8054    private:
8055      InputAdapterType ia;
8056      char_int_type current = std::char_traits<char_type>::eof();
8057      std::size_t chars_read = 0;
8058      const bool is_little_endian = little_endianess();
8059      json_sax_t* sax = nullptr;
8060  };
8061  }  
8062  }  
8063  #include <cmath> 
8064  #include <cstdint> 
8065  #include <functional> 
8066  #include <string> 
8067  #include <utility> 
8068  #include <vector> 
8069  namespace nlohmann
8070  {
8071  namespace detail
8072  {
8073  enum class parse_event_t : std::uint8_t
8074  {
8075      object_start,
8076      object_end,
8077      array_start,
8078      array_end,
8079      key,
8080      value
8081  };
8082  template<typename BasicJsonType>
8083  using parser_callback_t =
8084      std::function<bool(int &bsol;*depth*/, parse_event_t &bsol;*event*/, BasicJsonType& &bsol;*parsed*/)>;
8085  template<typename BasicJsonType, typename InputAdapterType>
8086  class parser
8087  {
8088      using number_integer_t = typename BasicJsonType::number_integer_t;
8089      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
8090      using number_float_t = typename BasicJsonType::number_float_t;
8091      using string_t = typename BasicJsonType::string_t;
8092      using lexer_t = lexer<BasicJsonType, InputAdapterType>;
8093      using token_type = typename lexer_t::token_type;
8094    public:
8095      explicit parser(InputAdapterType&& adapter,
8096                      const parser_callback_t<BasicJsonType> cb = nullptr,
8097                      const bool allow_exceptions_ = true,
8098                      const bool skip_comments = false)
8099          : callback(cb)
8100          , m_lexer(std::move(adapter), skip_comments)
8101          , allow_exceptions(allow_exceptions_)
8102      {
8103          get_token();
8104      }
8105      void parse(const bool strict, BasicJsonType& result)
8106      {
8107          if (callback)
8108          {
8109              json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
8110              sax_parse_internal(&sdp);
8111              if (strict && (get_token() != token_type::end_of_input))
8112              {
8113                  sdp.parse_error(m_lexer.get_position(),
8114                                  m_lexer.get_token_string(),
8115                                  parse_error::create(101, m_lexer.get_position(),
8116                                                      exception_message(token_type::end_of_input, "value"), BasicJsonType()));
8117              }
8118              if (sdp.is_errored())
8119              {
8120                  result = value_t::discarded;
8121                  return;
8122              }
8123              if (result.is_discarded())
8124              {
8125                  result = nullptr;
8126              }
8127          }
8128          else
8129          {
8130              json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
8131              sax_parse_internal(&sdp);
8132              if (strict && (get_token() != token_type::end_of_input))
8133              {
8134                  sdp.parse_error(m_lexer.get_position(),
8135                                  m_lexer.get_token_string(),
8136                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), BasicJsonType()));
8137              }
8138              if (sdp.is_errored())
8139              {
8140                  result = value_t::discarded;
8141                  return;
8142              }
8143          }
8144          result.assert_invariant();
8145      }
8146      bool accept(const bool strict = true)
8147      {
8148          json_sax_acceptor<BasicJsonType> sax_acceptor;
8149          return sax_parse(&sax_acceptor, strict);
8150      }
8151      template<typename SAX>
8152      JSON_HEDLEY_NON_NULL(2)
8153      bool sax_parse(SAX* sax, const bool strict = true)
8154      {
8155          (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
8156          const bool result = sax_parse_internal(sax);
8157          if (result && strict && (get_token() != token_type::end_of_input))
8158          {
8159              return sax->parse_error(m_lexer.get_position(),
8160                                      m_lexer.get_token_string(),
8161                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), BasicJsonType()));
8162          }
8163          return result;
8164      }
8165    private:
8166      template<typename SAX>
8167      JSON_HEDLEY_NON_NULL(2)
8168      bool sax_parse_internal(SAX* sax)
8169      {
8170          std::vector<bool> states;
8171          bool skip_to_state_evaluation = false;
8172          while (true)
8173          {
8174              if (!skip_to_state_evaluation)
8175              {
8176                  switch (last_token)
8177                  {
8178                      case token_type::begin_object:
8179                      {
8180                          if (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))
8181                          {
8182                              return false;
8183                          }
8184                          if (get_token() == token_type::end_object)
8185                          {
8186                              if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
8187                              {
8188                                  return false;
8189                              }
8190                              break;
8191                          }
8192                          if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
8193                          {
8194                              return sax->parse_error(m_lexer.get_position(),
8195                                                      m_lexer.get_token_string(),
8196                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), BasicJsonType()));
8197                          }
8198                          if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
8199                          {
8200                              return false;
8201                          }
8202                          if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
8203                          {
8204                              return sax->parse_error(m_lexer.get_position(),
8205                                                      m_lexer.get_token_string(),
8206                                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), BasicJsonType()));
8207                          }
8208                          states.push_back(false);
8209                          get_token();
8210                          continue;
8211                      }
8212                      case token_type::begin_array:
8213                      {
8214                          if (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))
8215                          {
8216                              return false;
8217                          }
8218                          if (get_token() == token_type::end_array)
8219                          {
8220                              if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
8221                              {
8222                                  return false;
8223                              }
8224                              break;
8225                          }
8226                          states.push_back(true);
8227                          continue;
8228                      }
8229                      case token_type::value_float:
8230                      {
8231                          const auto res = m_lexer.get_number_float();
8232                          if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
8233                          {
8234                              return sax->parse_error(m_lexer.get_position(),
8235                                                      m_lexer.get_token_string(),
8236                                                      out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'", BasicJsonType()));
8237                          }
8238                          if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
8239                          {
8240                              return false;
8241                          }
8242                          break;
8243                      }
8244                      case token_type::literal_false:
8245                      {
8246                          if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
8247                          {
8248                              return false;
8249                          }
8250                          break;
8251                      }
8252                      case token_type::literal_null:
8253                      {
8254                          if (JSON_HEDLEY_UNLIKELY(!sax->null()))
8255                          {
8256                              return false;
8257                          }
8258                          break;
8259                      }
8260                      case token_type::literal_true:
8261                      {
8262                          if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
8263                          {
8264                              return false;
8265                          }
8266                          break;
8267                      }
8268                      case token_type::value_integer:
8269                      {
8270                          if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
8271                          {
8272                              return false;
8273                          }
8274                          break;
8275                      }
8276                      case token_type::value_string:
8277                      {
8278                          if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
8279                          {
8280                              return false;
8281                          }
8282                          break;
8283                      }
8284                      case token_type::value_unsigned:
8285                      {
8286                          if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
8287                          {
8288                              return false;
8289                          }
8290                          break;
8291                      }
8292                      case token_type::parse_error:
8293                      {
8294                          return sax->parse_error(m_lexer.get_position(),
8295                                                  m_lexer.get_token_string(),
8296                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), BasicJsonType()));
8297                      }
8298                      case token_type::uninitialized:
8299                      case token_type::end_array:
8300                      case token_type::end_object:
8301                      case token_type::name_separator:
8302                      case token_type::value_separator:
8303                      case token_type::end_of_input:
8304                      case token_type::literal_or_value:
8305                      default: 
8306                      {
8307                          return sax->parse_error(m_lexer.get_position(),
8308                                                  m_lexer.get_token_string(),
8309                                                  parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), BasicJsonType()));
8310                      }
8311                  }
8312              }
8313              else
8314              {
8315                  skip_to_state_evaluation = false;
8316              }
8317              if (states.empty())
8318              {
8319                  return true;
8320              }
8321              if (states.back())  
8322              {
8323                  if (get_token() == token_type::value_separator)
8324                  {
8325                      get_token();
8326                      continue;
8327                  }
8328                  if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
8329                  {
8330                      if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
8331                      {
8332                          return false;
8333                      }
8334                      JSON_ASSERT(!states.empty());
8335                      states.pop_back();
8336                      skip_to_state_evaluation = true;
8337                      continue;
8338                  }
8339                  return sax->parse_error(m_lexer.get_position(),
8340                                          m_lexer.get_token_string(),
8341                                          parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), BasicJsonType()));
8342              }
8343              if (get_token() == token_type::value_separator)
8344              {
8345                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
8346                  {
8347                      return sax->parse_error(m_lexer.get_position(),
8348                                              m_lexer.get_token_string(),
8349                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), BasicJsonType()));
8350                  }
8351                  if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
8352                  {
8353                      return false;
8354                  }
8355                  if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
8356                  {
8357                      return sax->parse_error(m_lexer.get_position(),
8358                                              m_lexer.get_token_string(),
8359                                              parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), BasicJsonType()));
8360                  }
8361                  get_token();
8362                  continue;
8363              }
8364              if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
8365              {
8366                  if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
8367                  {
8368                      return false;
8369                  }
8370                  JSON_ASSERT(!states.empty());
8371                  states.pop_back();
8372                  skip_to_state_evaluation = true;
8373                  continue;
8374              }
8375              return sax->parse_error(m_lexer.get_position(),
8376                                      m_lexer.get_token_string(),
8377                                      parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), BasicJsonType()));
8378          }
8379      }
8380      token_type get_token()
8381      {
8382          return last_token = m_lexer.scan();
8383      }
8384      std::string exception_message(const token_type expected, const std::string& context)
8385      {
8386          std::string error_msg = "syntax error ";
8387          if (!context.empty())
8388          {
8389              error_msg += "while parsing " + context + " ";
8390          }
8391          error_msg += "- ";
8392          if (last_token == token_type::parse_error)
8393          {
8394              error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
8395                           m_lexer.get_token_string() + "'";
8396          }
8397          else
8398          {
8399              error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
8400          }
8401          if (expected != token_type::uninitialized)
8402          {
8403              error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
8404          }
8405          return error_msg;
8406      }
8407    private:
8408      const parser_callback_t<BasicJsonType> callback = nullptr;
8409      token_type last_token = token_type::uninitialized;
8410      lexer_t m_lexer;
8411      const bool allow_exceptions = true;
8412  };
8413  }  
8414  }  
8415  #include <cstddef> 
8416  #include <limits>  
8417  namespace nlohmann
8418  {
8419  namespace detail
8420  {
8421  class primitive_iterator_t
8422  {
8423    private:
8424      using difference_type = std::ptrdiff_t;
8425      static constexpr difference_type begin_value = 0;
8426      static constexpr difference_type end_value = begin_value + 1;
8427    JSON_PRIVATE_UNLESS_TESTED:
8428      difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();
8429    public:
8430      constexpr difference_type get_value() const noexcept
8431      {
8432          return m_it;
8433      }
8434      void set_begin() noexcept
8435      {
8436          m_it = begin_value;
8437      }
8438      void set_end() noexcept
8439      {
8440          m_it = end_value;
8441      }
8442      constexpr bool is_begin() const noexcept
8443      {
8444          return m_it == begin_value;
8445      }
8446      constexpr bool is_end() const noexcept
8447      {
8448          return m_it == end_value;
8449      }
8450      friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8451      {
8452          return lhs.m_it == rhs.m_it;
8453      }
8454      friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8455      {
8456          return lhs.m_it < rhs.m_it;
8457      }
8458      primitive_iterator_t operator+(difference_type n) noexcept
8459      {
8460          auto result = *this;
8461          result += n;
8462          return result;
8463      }
8464      friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
8465      {
8466          return lhs.m_it - rhs.m_it;
8467      }
8468      primitive_iterator_t& operator++() noexcept
8469      {
8470          ++m_it;
8471          return *this;
8472      }
8473      primitive_iterator_t const operator++(int) noexcept 
8474      {
8475          auto result = *this;
8476          ++m_it;
8477          return result;
8478      }
8479      primitive_iterator_t& operator--() noexcept
8480      {
8481          --m_it;
8482          return *this;
8483      }
8484      primitive_iterator_t const operator--(int) noexcept 
8485      {
8486          auto result = *this;
8487          --m_it;
8488          return result;
8489      }
8490      primitive_iterator_t& operator+=(difference_type n) noexcept
8491      {
8492          m_it += n;
8493          return *this;
8494      }
8495      primitive_iterator_t& operator-=(difference_type n) noexcept
8496      {
8497          m_it -= n;
8498          return *this;
8499      }
8500  };
8501  }  
8502  }  
8503  namespace nlohmann
8504  {
8505  namespace detail
8506  {
8507  template<typename BasicJsonType> struct internal_iterator
8508  {
8509      typename BasicJsonType::object_t::iterator object_iterator {};
8510      typename BasicJsonType::array_t::iterator array_iterator {};
8511      primitive_iterator_t primitive_iterator {};
8512  };
8513  }  
8514  }  
8515  #include <iterator> 
8516  #include <type_traits> 
8517  namespace nlohmann
8518  {
8519  namespace detail
8520  {
8521  template<typename IteratorType> class iteration_proxy;
8522  template<typename IteratorType> class iteration_proxy_value;
8523  template<typename BasicJsonType>
8524  class iter_impl
8525  {
8526      using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
8527      friend other_iter_impl;
8528      friend BasicJsonType;
8529      friend iteration_proxy<iter_impl>;
8530      friend iteration_proxy_value<iter_impl>;
8531      using object_t = typename BasicJsonType::object_t;
8532      using array_t = typename BasicJsonType::array_t;
8533      static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
8534                    "iter_impl only accepts (const) basic_json");
8535    public:
8536      using iterator_category = std::bidirectional_iterator_tag;
8537      using value_type = typename BasicJsonType::value_type;
8538      using difference_type = typename BasicJsonType::difference_type;
8539      using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
8540            typename BasicJsonType::const_pointer,
8541            typename BasicJsonType::pointer>::type;
8542      using reference =
8543          typename std::conditional<std::is_const<BasicJsonType>::value,
8544          typename BasicJsonType::const_reference,
8545          typename BasicJsonType::reference>::type;
8546      iter_impl() = default;
8547      ~iter_impl() = default;
8548      iter_impl(iter_impl&&) noexcept = default;
8549      iter_impl& operator=(iter_impl&&) noexcept = default;
8550      explicit iter_impl(pointer object) noexcept : m_object(object)
8551      {
8552          JSON_ASSERT(m_object != nullptr);
8553          switch (m_object->m_type)
8554          {
8555              case value_t::object:
8556              {
8557                  m_it.object_iterator = typename object_t::iterator();
8558                  break;
8559              }
8560              case value_t::array:
8561              {
8562                  m_it.array_iterator = typename array_t::iterator();
8563                  break;
8564              }
8565              case value_t::null:
8566              case value_t::string:
8567              case value_t::boolean:
8568              case value_t::number_integer:
8569              case value_t::number_unsigned:
8570              case value_t::number_float:
8571              case value_t::binary:
8572              case value_t::discarded:
8573              default:
8574              {
8575                  m_it.primitive_iterator = primitive_iterator_t();
8576                  break;
8577              }
8578          }
8579      }
8580      iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
8581          : m_object(other.m_object), m_it(other.m_it)
8582      {}
8583      iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
8584      {
8585          if (&other != this)
8586          {
8587              m_object = other.m_object;
8588              m_it = other.m_it;
8589          }
8590          return *this;
8591      }
8592      iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
8593          : m_object(other.m_object), m_it(other.m_it)
8594      {}
8595      iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept 
8596      {
8597          m_object = other.m_object;
8598          m_it = other.m_it;
8599          return *this;
8600      }
8601    JSON_PRIVATE_UNLESS_TESTED:
8602      void set_begin() noexcept
8603      {
8604          JSON_ASSERT(m_object != nullptr);
8605          switch (m_object->m_type)
8606          {
8607              case value_t::object:
8608              {
8609                  m_it.object_iterator = m_object->m_value.object->begin();
8610                  break;
8611              }
8612              case value_t::array:
8613              {
8614                  m_it.array_iterator = m_object->m_value.array->begin();
8615                  break;
8616              }
8617              case value_t::null:
8618              {
8619                  m_it.primitive_iterator.set_end();
8620                  break;
8621              }
8622              case value_t::string:
8623              case value_t::boolean:
8624              case value_t::number_integer:
8625              case value_t::number_unsigned:
8626              case value_t::number_float:
8627              case value_t::binary:
8628              case value_t::discarded:
8629              default:
8630              {
8631                  m_it.primitive_iterator.set_begin();
8632                  break;
8633              }
8634          }
8635      }
8636      void set_end() noexcept
8637      {
8638          JSON_ASSERT(m_object != nullptr);
8639          switch (m_object->m_type)
8640          {
8641              case value_t::object:
8642              {
8643                  m_it.object_iterator = m_object->m_value.object->end();
8644                  break;
8645              }
8646              case value_t::array:
8647              {
8648                  m_it.array_iterator = m_object->m_value.array->end();
8649                  break;
8650              }
8651              case value_t::null:
8652              case value_t::string:
8653              case value_t::boolean:
8654              case value_t::number_integer:
8655              case value_t::number_unsigned:
8656              case value_t::number_float:
8657              case value_t::binary:
8658              case value_t::discarded:
8659              default:
8660              {
8661                  m_it.primitive_iterator.set_end();
8662                  break;
8663              }
8664          }
8665      }
8666    public:
8667      reference operator*() const
8668      {
8669          JSON_ASSERT(m_object != nullptr);
8670          switch (m_object->m_type)
8671          {
8672              case value_t::object:
8673              {
8674                  JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
8675                  return m_it.object_iterator->second;
8676              }
8677              case value_t::array:
8678              {
8679                  JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
8680                  return *m_it.array_iterator;
8681              }
8682              case value_t::null:
8683                  JSON_THROW(invalid_iterator::create(214, "cannot get value", *m_object));
8684              case value_t::string:
8685              case value_t::boolean:
8686              case value_t::number_integer:
8687              case value_t::number_unsigned:
8688              case value_t::number_float:
8689              case value_t::binary:
8690              case value_t::discarded:
8691              default:
8692              {
8693                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
8694                  {
8695                      return *m_object;
8696                  }
8697                  JSON_THROW(invalid_iterator::create(214, "cannot get value", *m_object));
8698              }
8699          }
8700      }
8701      pointer operator->() const
8702      {
8703          JSON_ASSERT(m_object != nullptr);
8704          switch (m_object->m_type)
8705          {
8706              case value_t::object:
8707              {
8708                  JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());
8709                  return &(m_it.object_iterator->second);
8710              }
8711              case value_t::array:
8712              {
8713                  JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());
8714                  return &*m_it.array_iterator;
8715              }
8716              case value_t::null:
8717              case value_t::string:
8718              case value_t::boolean:
8719              case value_t::number_integer:
8720              case value_t::number_unsigned:
8721              case value_t::number_float:
8722              case value_t::binary:
8723              case value_t::discarded:
8724              default:
8725              {
8726                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
8727                  {
8728                      return m_object;
8729                  }
8730                  JSON_THROW(invalid_iterator::create(214, "cannot get value", *m_object));
8731              }
8732          }
8733      }
8734      iter_impl const operator++(int) 
8735      {
8736          auto result = *this;
8737          ++(*this);
8738          return result;
8739      }
8740      iter_impl& operator++()
8741      {
8742          JSON_ASSERT(m_object != nullptr);
8743          switch (m_object->m_type)
8744          {
8745              case value_t::object:
8746              {
8747                  std::advance(m_it.object_iterator, 1);
8748                  break;
8749              }
8750              case value_t::array:
8751              {
8752                  std::advance(m_it.array_iterator, 1);
8753                  break;
8754              }
8755              case value_t::null:
8756              case value_t::string:
8757              case value_t::boolean:
8758              case value_t::number_integer:
8759              case value_t::number_unsigned:
8760              case value_t::number_float:
8761              case value_t::binary:
8762              case value_t::discarded:
8763              default:
8764              {
8765                  ++m_it.primitive_iterator;
8766                  break;
8767              }
8768          }
8769          return *this;
8770      }
8771      iter_impl const operator--(int) 
8772      {
8773          auto result = *this;
8774          --(*this);
8775          return result;
8776      }
8777      iter_impl& operator--()
8778      {
8779          JSON_ASSERT(m_object != nullptr);
8780          switch (m_object->m_type)
8781          {
8782              case value_t::object:
8783              {
8784                  std::advance(m_it.object_iterator, -1);
8785                  break;
8786              }
8787              case value_t::array:
8788              {
8789                  std::advance(m_it.array_iterator, -1);
8790                  break;
8791              }
8792              case value_t::null:
8793              case value_t::string:
8794              case value_t::boolean:
8795              case value_t::number_integer:
8796              case value_t::number_unsigned:
8797              case value_t::number_float:
8798              case value_t::binary:
8799              case value_t::discarded:
8800              default:
8801              {
8802                  --m_it.primitive_iterator;
8803                  break;
8804              }
8805          }
8806          return *this;
8807      }
8808      template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
8809      bool operator==(const IterImpl& other) const
8810      {
8811          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
8812          {
8813              JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", *m_object));
8814          }
8815          JSON_ASSERT(m_object != nullptr);
8816          switch (m_object->m_type)
8817          {
8818              case value_t::object:
8819                  return (m_it.object_iterator == other.m_it.object_iterator);
8820              case value_t::array:
8821                  return (m_it.array_iterator == other.m_it.array_iterator);
8822              case value_t::null:
8823              case value_t::string:
8824              case value_t::boolean:
8825              case value_t::number_integer:
8826              case value_t::number_unsigned:
8827              case value_t::number_float:
8828              case value_t::binary:
8829              case value_t::discarded:
8830              default:
8831                  return (m_it.primitive_iterator == other.m_it.primitive_iterator);
8832          }
8833      }
8834      template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
8835      bool operator!=(const IterImpl& other) const
8836      {
8837          return !operator==(other);
8838      }
8839      bool operator<(const iter_impl& other) const
8840      {
8841          if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
8842          {
8843              JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", *m_object));
8844          }
8845          JSON_ASSERT(m_object != nullptr);
8846          switch (m_object->m_type)
8847          {
8848              case value_t::object:
8849                  JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", *m_object));
8850              case value_t::array:
8851                  return (m_it.array_iterator < other.m_it.array_iterator);
8852              case value_t::null:
8853              case value_t::string:
8854              case value_t::boolean:
8855              case value_t::number_integer:
8856              case value_t::number_unsigned:
8857              case value_t::number_float:
8858              case value_t::binary:
8859              case value_t::discarded:
8860              default:
8861                  return (m_it.primitive_iterator < other.m_it.primitive_iterator);
8862          }
8863      }
8864      bool operator<=(const iter_impl& other) const
8865      {
8866          return !other.operator < (*this);
8867      }
8868      bool operator>(const iter_impl& other) const
8869      {
8870          return !operator<=(other);
8871      }
8872      bool operator>=(const iter_impl& other) const
8873      {
8874          return !operator<(other);
8875      }
8876      iter_impl& operator+=(difference_type i)
8877      {
8878          JSON_ASSERT(m_object != nullptr);
8879          switch (m_object->m_type)
8880          {
8881              case value_t::object:
8882                  JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", *m_object));
8883              case value_t::array:
8884              {
8885                  std::advance(m_it.array_iterator, i);
8886                  break;
8887              }
8888              case value_t::null:
8889              case value_t::string:
8890              case value_t::boolean:
8891              case value_t::number_integer:
8892              case value_t::number_unsigned:
8893              case value_t::number_float:
8894              case value_t::binary:
8895              case value_t::discarded:
8896              default:
8897              {
8898                  m_it.primitive_iterator += i;
8899                  break;
8900              }
8901          }
8902          return *this;
8903      }
8904      iter_impl& operator-=(difference_type i)
8905      {
8906          return operator+=(-i);
8907      }
8908      iter_impl operator+(difference_type i) const
8909      {
8910          auto result = *this;
8911          result += i;
8912          return result;
8913      }
8914      friend iter_impl operator+(difference_type i, const iter_impl& it)
8915      {
8916          auto result = it;
8917          result += i;
8918          return result;
8919      }
8920      iter_impl operator-(difference_type i) const
8921      {
8922          auto result = *this;
8923          result -= i;
8924          return result;
8925      }
8926      difference_type operator-(const iter_impl& other) const
8927      {
8928          JSON_ASSERT(m_object != nullptr);
8929          switch (m_object->m_type)
8930          {
8931              case value_t::object:
8932                  JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", *m_object));
8933              case value_t::array:
8934                  return m_it.array_iterator - other.m_it.array_iterator;
8935              case value_t::null:
8936              case value_t::string:
8937              case value_t::boolean:
8938              case value_t::number_integer:
8939              case value_t::number_unsigned:
8940              case value_t::number_float:
8941              case value_t::binary:
8942              case value_t::discarded:
8943              default:
8944                  return m_it.primitive_iterator - other.m_it.primitive_iterator;
8945          }
8946      }
8947      reference operator[](difference_type n) const
8948      {
8949          JSON_ASSERT(m_object != nullptr);
8950          switch (m_object->m_type)
8951          {
8952              case value_t::object:
8953                  JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", *m_object));
8954              case value_t::array:
8955                  return *std::next(m_it.array_iterator, n);
8956              case value_t::null:
8957                  JSON_THROW(invalid_iterator::create(214, "cannot get value", *m_object));
8958              case value_t::string:
8959              case value_t::boolean:
8960              case value_t::number_integer:
8961              case value_t::number_unsigned:
8962              case value_t::number_float:
8963              case value_t::binary:
8964              case value_t::discarded:
8965              default:
8966              {
8967                  if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
8968                  {
8969                      return *m_object;
8970                  }
8971                  JSON_THROW(invalid_iterator::create(214, "cannot get value", *m_object));
8972              }
8973          }
8974      }
8975      const typename object_t::key_type& key() const
8976      {
8977          JSON_ASSERT(m_object != nullptr);
8978          if (JSON_HEDLEY_LIKELY(m_object->is_object()))
8979          {
8980              return m_it.object_iterator->first;
8981          }
8982          JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", *m_object));
8983      }
8984      reference value() const
8985      {
8986          return operator*();
8987      }
8988    JSON_PRIVATE_UNLESS_TESTED:
8989      pointer m_object = nullptr;
8990      internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
8991  };
8992  } 
8993  } 
8994  #include <cstddef> 
8995  #include <iterator> 
8996  #include <utility> 
8997  namespace nlohmann
8998  {
8999  namespace detail
9000  {
9001  template<typename Base>
9002  class json_reverse_iterator : public std::reverse_iterator<Base>
9003  {
9004    public:
9005      using difference_type = std::ptrdiff_t;
9006      using base_iterator = std::reverse_iterator<Base>;
9007      using reference = typename Base::reference;
9008      explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
9009          : base_iterator(it) {}
9010      explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}
9011      json_reverse_iterator const operator++(int) 
9012      {
9013          return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
9014      }
9015      json_reverse_iterator& operator++()
9016      {
9017          return static_cast<json_reverse_iterator&>(base_iterator::operator++());
9018      }
9019      json_reverse_iterator const operator--(int) 
9020      {
9021          return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
9022      }
9023      json_reverse_iterator& operator--()
9024      {
9025          return static_cast<json_reverse_iterator&>(base_iterator::operator--());
9026      }
9027      json_reverse_iterator& operator+=(difference_type i)
9028      {
9029          return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
9030      }
9031      json_reverse_iterator operator+(difference_type i) const
9032      {
9033          return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
9034      }
9035      json_reverse_iterator operator-(difference_type i) const
9036      {
9037          return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
9038      }
9039      difference_type operator-(const json_reverse_iterator& other) const
9040      {
9041          return base_iterator(*this) - base_iterator(other);
9042      }
9043      reference operator[](difference_type n) const
9044      {
9045          return *(this->operator+(n));
9046      }
9047      auto key() const -> decltype(std::declval<Base>().key())
9048      {
9049          auto it = --this->base();
9050          return it.key();
9051      }
9052      reference value() const
9053      {
9054          auto it = --this->base();
9055          return it.operator * ();
9056      }
9057  };
9058  }  
9059  }  
9060  #include <algorithm> 
9061  #include <cctype> 
9062  #include <limits> 
9063  #include <numeric> 
9064  #include <string> 
9065  #include <utility> 
9066  #include <vector> 
9067  namespace nlohmann
9068  {
9069  template<typename BasicJsonType>
9070  class json_pointer
9071  {
9072      NLOHMANN_BASIC_JSON_TPL_DECLARATION
9073      friend class basic_json;
9074    public:
9075      explicit json_pointer(const std::string& s = "")
9076          : reference_tokens(split(s))
9077      {}
9078      std::string to_string() const
9079      {
9080          return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
9081                                 std::string{},
9082                                 [](const std::string & a, const std::string & b)
9083          {
9084              return a + "/" + detail::escape(b);
9085          });
9086      }
9087      operator std::string() const
9088      {
9089          return to_string();
9090      }
9091      json_pointer& operator/=(const json_pointer& ptr)
9092      {
9093          reference_tokens.insert(reference_tokens.end(),
9094                                  ptr.reference_tokens.begin(),
9095                                  ptr.reference_tokens.end());
9096          return *this;
9097      }
9098      json_pointer& operator/=(std::string token)
9099      {
9100          push_back(std::move(token));
9101          return *this;
9102      }
9103      json_pointer& operator/=(std::size_t array_idx)
9104      {
9105          return *this /= std::to_string(array_idx);
9106      }
9107      friend json_pointer operator/(const json_pointer& lhs,
9108                                    const json_pointer& rhs)
9109      {
9110          return json_pointer(lhs) /= rhs;
9111      }
9112      friend json_pointer operator/(const json_pointer& ptr, std::string token) 
9113      {
9114          return json_pointer(ptr) /= std::move(token);
9115      }
9116      friend json_pointer operator/(const json_pointer& ptr, std::size_t array_idx)
9117      {
9118          return json_pointer(ptr) /= array_idx;
9119      }
9120      json_pointer parent_pointer() const
9121      {
9122          if (empty())
9123          {
9124              return *this;
9125          }
9126          json_pointer res = *this;
9127          res.pop_back();
9128          return res;
9129      }
9130      void pop_back()
9131      {
9132          if (JSON_HEDLEY_UNLIKELY(empty()))
9133          {
9134              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", BasicJsonType()));
9135          }
9136          reference_tokens.pop_back();
9137      }
9138      const std::string& back() const
9139      {
9140          if (JSON_HEDLEY_UNLIKELY(empty()))
9141          {
9142              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", BasicJsonType()));
9143          }
9144          return reference_tokens.back();
9145      }
9146      void push_back(const std::string& token)
9147      {
9148          reference_tokens.push_back(token);
9149      }
9150      void push_back(std::string&& token)
9151      {
9152          reference_tokens.push_back(std::move(token));
9153      }
9154      bool empty() const noexcept
9155      {
9156          return reference_tokens.empty();
9157      }
9158    private:
9159      static typename BasicJsonType::size_type array_index(const std::string& s)
9160      {
9161          using size_type = typename BasicJsonType::size_type;
9162          if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
9163          {
9164              JSON_THROW(detail::parse_error::create(106, 0, "array index '" + s + "' must not begin with '0'", BasicJsonType()));
9165          }
9166          if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
9167          {
9168              JSON_THROW(detail::parse_error::create(109, 0, "array index '" + s + "' is not a number", BasicJsonType()));
9169          }
9170          std::size_t processed_chars = 0;
9171          unsigned long long res = 0;  
9172          JSON_TRY
9173          {
9174              res = std::stoull(s, &processed_chars);
9175          }
9176          JSON_CATCH(std::out_of_range&)
9177          {
9178              JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'", BasicJsonType()));
9179          }
9180          if (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))
9181          {
9182              JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'", BasicJsonType()));
9183          }
9184          if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  
9185          {
9186              JSON_THROW(detail::out_of_range::create(410, "array index " + s + " exceeds size_type", BasicJsonType())); 
9187          }
9188          return static_cast<size_type>(res);
9189      }
9190    JSON_PRIVATE_UNLESS_TESTED:
9191      json_pointer top() const
9192      {
9193          if (JSON_HEDLEY_UNLIKELY(empty()))
9194          {
9195              JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", BasicJsonType()));
9196          }
9197          json_pointer result = *this;
9198          result.reference_tokens = {reference_tokens[0]};
9199          return result;
9200      }
9201    private:
9202      BasicJsonType& get_and_create(BasicJsonType& j) const
9203      {
9204          auto* result = &j;
9205          for (const auto& reference_token : reference_tokens)
9206          {
9207              switch (result->type())
9208              {
9209                  case detail::value_t::null:
9210                  {
9211                      if (reference_token == "0")
9212                      {
9213                          result = &result->operator[](0);
9214                      }
9215                      else
9216                      {
9217                          result = &result->operator[](reference_token);
9218                      }
9219                      break;
9220                  }
9221                  case detail::value_t::object:
9222                  {
9223                      result = &result->operator[](reference_token);
9224                      break;
9225                  }
9226                  case detail::value_t::array:
9227                  {
9228                      result = &result->operator[](array_index(reference_token));
9229                      break;
9230                  }
9231                  case detail::value_t::string:
9232                  case detail::value_t::boolean:
9233                  case detail::value_t::number_integer:
9234                  case detail::value_t::number_unsigned:
9235                  case detail::value_t::number_float:
9236                  case detail::value_t::binary:
9237                  case detail::value_t::discarded:
9238                  default:
9239                      JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", j));
9240              }
9241          }
9242          return *result;
9243      }
9244      BasicJsonType& get_unchecked(BasicJsonType* ptr) const
9245      {
9246          for (const auto& reference_token : reference_tokens)
9247          {
9248              if (ptr->is_null())
9249              {
9250                  const bool nums =
9251                      std::all_of(reference_token.begin(), reference_token.end(),
9252                                  [](const unsigned char x)
9253                  {
9254                      return std::isdigit(x);
9255                  });
9256                  *ptr = (nums || reference_token == "-")
9257                         ? detail::value_t::array
9258                         : detail::value_t::object;
9259              }
9260              switch (ptr->type())
9261              {
9262                  case detail::value_t::object:
9263                  {
9264                      ptr = &ptr->operator[](reference_token);
9265                      break;
9266                  }
9267                  case detail::value_t::array:
9268                  {
9269                      if (reference_token == "-")
9270                      {
9271                          ptr = &ptr->operator[](ptr->m_value.array->size());
9272                      }
9273                      else
9274                      {
9275                          ptr = &ptr->operator[](array_index(reference_token));
9276                      }
9277                      break;
9278                  }
9279                  case detail::value_t::null:
9280                  case detail::value_t::string:
9281                  case detail::value_t::boolean:
9282                  case detail::value_t::number_integer:
9283                  case detail::value_t::number_unsigned:
9284                  case detail::value_t::number_float:
9285                  case detail::value_t::binary:
9286                  case detail::value_t::discarded:
9287                  default:
9288                      JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'", *ptr));
9289              }
9290          }
9291          return *ptr;
9292      }
9293      BasicJsonType& get_checked(BasicJsonType* ptr) const
9294      {
9295          for (const auto& reference_token : reference_tokens)
9296          {
9297              switch (ptr->type())
9298              {
9299                  case detail::value_t::object:
9300                  {
9301                      ptr = &ptr->at(reference_token);
9302                      break;
9303                  }
9304                  case detail::value_t::array:
9305                  {
9306                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
9307                      {
9308                          JSON_THROW(detail::out_of_range::create(402,
9309                                                                  "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
9310                                                                  ") is out of range", *ptr));
9311                      }
9312                      ptr = &ptr->at(array_index(reference_token));
9313                      break;
9314                  }
9315                  case detail::value_t::null:
9316                  case detail::value_t::string:
9317                  case detail::value_t::boolean:
9318                  case detail::value_t::number_integer:
9319                  case detail::value_t::number_unsigned:
9320                  case detail::value_t::number_float:
9321                  case detail::value_t::binary:
9322                  case detail::value_t::discarded:
9323                  default:
9324                      JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'", *ptr));
9325              }
9326          }
9327          return *ptr;
9328      }
9329      const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
9330      {
9331          for (const auto& reference_token : reference_tokens)
9332          {
9333              switch (ptr->type())
9334              {
9335                  case detail::value_t::object:
9336                  {
9337                      ptr = &ptr->operator[](reference_token);
9338                      break;
9339                  }
9340                  case detail::value_t::array:
9341                  {
9342                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
9343                      {
9344                          JSON_THROW(detail::out_of_range::create(402, "array index '-' (" + std::to_string(ptr->m_value.array->size()) + ") is out of range", *ptr));
9345                      }
9346                      ptr = &ptr->operator[](array_index(reference_token));
9347                      break;
9348                  }
9349                  case detail::value_t::null:
9350                  case detail::value_t::string:
9351                  case detail::value_t::boolean:
9352                  case detail::value_t::number_integer:
9353                  case detail::value_t::number_unsigned:
9354                  case detail::value_t::number_float:
9355                  case detail::value_t::binary:
9356                  case detail::value_t::discarded:
9357                  default:
9358                      JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'", *ptr));
9359              }
9360          }
9361          return *ptr;
9362      }
9363      const BasicJsonType& get_checked(const BasicJsonType* ptr) const
9364      {
9365          for (const auto& reference_token : reference_tokens)
9366          {
9367              switch (ptr->type())
9368              {
9369                  case detail::value_t::object:
9370                  {
9371                      ptr = &ptr->at(reference_token);
9372                      break;
9373                  }
9374                  case detail::value_t::array:
9375                  {
9376                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
9377                      {
9378                          JSON_THROW(detail::out_of_range::create(402,
9379                                                                  "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
9380                                                                  ") is out of range", *ptr));
9381                      }
9382                      ptr = &ptr->at(array_index(reference_token));
9383                      break;
9384                  }
9385                  case detail::value_t::null:
9386                  case detail::value_t::string:
9387                  case detail::value_t::boolean:
9388                  case detail::value_t::number_integer:
9389                  case detail::value_t::number_unsigned:
9390                  case detail::value_t::number_float:
9391                  case detail::value_t::binary:
9392                  case detail::value_t::discarded:
9393                  default:
9394                      JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'", *ptr));
9395              }
9396          }
9397          return *ptr;
9398      }
9399      bool contains(const BasicJsonType* ptr) const
9400      {
9401          for (const auto& reference_token : reference_tokens)
9402          {
9403              switch (ptr->type())
9404              {
9405                  case detail::value_t::object:
9406                  {
9407                      if (!ptr->contains(reference_token))
9408                      {
9409                          return false;
9410                      }
9411                      ptr = &ptr->operator[](reference_token);
9412                      break;
9413                  }
9414                  case detail::value_t::array:
9415                  {
9416                      if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
9417                      {
9418                          return false;
9419                      }
9420                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
9421                      {
9422                          return false;
9423                      }
9424                      if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
9425                      {
9426                          if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
9427                          {
9428                              return false;
9429                          }
9430                          for (std::size_t i = 1; i < reference_token.size(); i++)
9431                          {
9432                              if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
9433                              {
9434                                  return false;
9435                              }
9436                          }
9437                      }
9438                      const auto idx = array_index(reference_token);
9439                      if (idx >= ptr->size())
9440                      {
9441                          return false;
9442                      }
9443                      ptr = &ptr->operator[](idx);
9444                      break;
9445                  }
9446                  case detail::value_t::null:
9447                  case detail::value_t::string:
9448                  case detail::value_t::boolean:
9449                  case detail::value_t::number_integer:
9450                  case detail::value_t::number_unsigned:
9451                  case detail::value_t::number_float:
9452                  case detail::value_t::binary:
9453                  case detail::value_t::discarded:
9454                  default:
9455                  {
9456                      return false;
9457                  }
9458              }
9459          }
9460          return true;
9461      }
9462      static std::vector<std::string> split(const std::string& reference_string)
9463      {
9464          std::vector<std::string> result;
9465          if (reference_string.empty())
9466          {
9467              return result;
9468          }
9469          if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
9470          {
9471              JSON_THROW(detail::parse_error::create(107, 1, "JSON pointer must be empty or begin with '/' - was: '" + reference_string + "'", BasicJsonType()));
9472          }
9473          for (
9474              std::size_t slash = reference_string.find_first_of('/', 1),
9475              start = 1;
9476              start != 0;
9477              start = (slash == std::string::npos) ? 0 : slash + 1,
9478              slash = reference_string.find_first_of('/', start))
9479          {
9480              auto reference_token = reference_string.substr(start, slash - start);
9481              for (std::size_t pos = reference_token.find_first_of('~');
9482                      pos != std::string::npos;
9483                      pos = reference_token.find_first_of('~', pos + 1))
9484              {
9485                  JSON_ASSERT(reference_token[pos] == '~');
9486                  if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
9487                                           (reference_token[pos + 1] != '0' &&
9488                                            reference_token[pos + 1] != '1')))
9489                  {
9490                      JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", BasicJsonType()));
9491                  }
9492              }
9493              detail::unescape(reference_token);
9494              result.push_back(reference_token);
9495          }
9496          return result;
9497      }
9498    private:
9499      static void flatten(const std::string& reference_string,
9500                          const BasicJsonType& value,
9501                          BasicJsonType& result)
9502      {
9503          switch (value.type())
9504          {
9505              case detail::value_t::array:
9506              {
9507                  if (value.m_value.array->empty())
9508                  {
9509                      result[reference_string] = nullptr;
9510                  }
9511                  else
9512                  {
9513                      for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
9514                      {
9515                          flatten(reference_string + "/" + std::to_string(i),
9516                                  value.m_value.array->operator[](i), result);
9517                      }
9518                  }
9519                  break;
9520              }
9521              case detail::value_t::object:
9522              {
9523                  if (value.m_value.object->empty())
9524                  {
9525                      result[reference_string] = nullptr;
9526                  }
9527                  else
9528                  {
9529                      for (const auto& element : *value.m_value.object)
9530                      {
9531                          flatten(reference_string + "/" + detail::escape(element.first), element.second, result);
9532                      }
9533                  }
9534                  break;
9535              }
9536              case detail::value_t::null:
9537              case detail::value_t::string:
9538              case detail::value_t::boolean:
9539              case detail::value_t::number_integer:
9540              case detail::value_t::number_unsigned:
9541              case detail::value_t::number_float:
9542              case detail::value_t::binary:
9543              case detail::value_t::discarded:
9544              default:
9545              {
9546                  result[reference_string] = value;
9547                  break;
9548              }
9549          }
9550      }
9551      static BasicJsonType
9552      unflatten(const BasicJsonType& value)
9553      {
9554          if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
9555          {
9556              JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", value));
9557          }
9558          BasicJsonType result;
9559          for (const auto& element : *value.m_value.object)
9560          {
9561              if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
9562              {
9563                  JSON_THROW(detail::type_error::create(315, "values in object must be primitive", element.second));
9564              }
9565              json_pointer(element.first).get_and_create(result) = element.second;
9566          }
9567          return result;
9568      }
9569      friend bool operator==(json_pointer const& lhs,
9570                             json_pointer const& rhs) noexcept
9571      {
9572          return lhs.reference_tokens == rhs.reference_tokens;
9573      }
9574      friend bool operator!=(json_pointer const& lhs,
9575                             json_pointer const& rhs) noexcept
9576      {
9577          return !(lhs == rhs);
9578      }
9579      std::vector<std::string> reference_tokens;
9580  };
9581  }  
9582  #include <initializer_list>
9583  #include <utility>
9584  namespace nlohmann
9585  {
9586  namespace detail
9587  {
9588  template<typename BasicJsonType>
9589  class json_ref
9590  {
9591    public:
9592      using value_type = BasicJsonType;
9593      json_ref(value_type&& value)
9594          : owned_value(std::move(value))
9595      {}
9596      json_ref(const value_type& value)
9597          : value_ref(&value)
9598      {}
9599      json_ref(std::initializer_list<json_ref> init)
9600          : owned_value(init)
9601      {}
9602      template <
9603          class... Args,
9604          enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
9605      json_ref(Args && ... args)
9606          : owned_value(std::forward<Args>(args)...)
9607      {}
9608      json_ref(json_ref&&) noexcept = default;
9609      json_ref(const json_ref&) = delete;
9610      json_ref& operator=(const json_ref&) = delete;
9611      json_ref& operator=(json_ref&&) = delete;
9612      ~json_ref() = default;
9613      value_type moved_or_copied() const
9614      {
9615          if (value_ref == nullptr)
9616          {
9617              return std::move(owned_value);
9618          }
9619          return *value_ref;
9620      }
9621      value_type const& operator*() const
9622      {
9623          return value_ref ? *value_ref : owned_value;
9624      }
9625      value_type const* operator->() const
9626      {
9627          return &** this;
9628      }
9629    private:
9630      mutable value_type owned_value = nullptr;
9631      value_type const* value_ref = nullptr;
9632  };
9633  }  
9634  }  
9635  #include <algorithm> 
9636  #include <array> 
9637  #include <cmath> 
9638  #include <cstdint> 
9639  #include <cstring> 
9640  #include <limits> 
9641  #include <string> 
9642  #include <utility> 
9643  #include <algorithm> 
9644  #include <cstddef> 
9645  #include <iterator> 
9646  #include <memory> 
9647  #include <string> 
9648  #include <vector> 
9649  #ifndef JSON_NO_IO
9650      #include <ios>      
9651      #include <ostream>  
9652  #endif  
9653  namespace nlohmann
9654  {
9655  namespace detail
9656  {
9657  template<typename CharType> struct output_adapter_protocol
9658  {
9659      virtual void write_character(CharType c) = 0;
9660      virtual void write_characters(const CharType* s, std::size_t length) = 0;
9661      virtual ~output_adapter_protocol() = default;
9662      output_adapter_protocol() = default;
9663      output_adapter_protocol(const output_adapter_protocol&) = default;
9664      output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
9665      output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
9666      output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
9667  };
9668  template<typename CharType>
9669  using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;
9670  template<typename CharType>
9671  class output_vector_adapter : public output_adapter_protocol<CharType>
9672  {
9673    public:
9674      explicit output_vector_adapter(std::vector<CharType>& vec) noexcept
9675          : v(vec)
9676      {}
9677      void write_character(CharType c) override
9678      {
9679          v.push_back(c);
9680      }
9681      JSON_HEDLEY_NON_NULL(2)
9682      void write_characters(const CharType* s, std::size_t length) override
9683      {
9684          std::copy(s, s + length, std::back_inserter(v));
9685      }
9686    private:
9687      std::vector<CharType>& v;
9688  };
9689  #ifndef JSON_NO_IO
9690  template<typename CharType>
9691  class output_stream_adapter : public output_adapter_protocol<CharType>
9692  {
9693    public:
9694      explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
9695          : stream(s)
9696      {}
9697      void write_character(CharType c) override
9698      {
9699          stream.put(c);
9700      }
9701      JSON_HEDLEY_NON_NULL(2)
9702      void write_characters(const CharType* s, std::size_t length) override
9703      {
9704          stream.write(s, static_cast<std::streamsize>(length));
9705      }
9706    private:
9707      std::basic_ostream<CharType>& stream;
9708  };
9709  #endif  
9710  template<typename CharType, typename StringType = std::basic_string<CharType>>
9711  class output_string_adapter : public output_adapter_protocol<CharType>
9712  {
9713    public:
9714      explicit output_string_adapter(StringType& s) noexcept
9715          : str(s)
9716      {}
9717      void write_character(CharType c) override
9718      {
9719          str.push_back(c);
9720      }
9721      JSON_HEDLEY_NON_NULL(2)
9722      void write_characters(const CharType* s, std::size_t length) override
9723      {
9724          str.append(s, length);
9725      }
9726    private:
9727      StringType& str;
9728  };
9729  template<typename CharType, typename StringType = std::basic_string<CharType>>
9730  class output_adapter
9731  {
9732    public:
9733      output_adapter(std::vector<CharType>& vec)
9734          : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}
9735  #ifndef JSON_NO_IO
9736      output_adapter(std::basic_ostream<CharType>& s)
9737          : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
9738  #endif  
9739      output_adapter(StringType& s)
9740          : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}
9741      operator output_adapter_t<CharType>()
9742      {
9743          return oa;
9744      }
9745    private:
9746      output_adapter_t<CharType> oa = nullptr;
9747  };
9748  }  
9749  }  
9750  namespace nlohmann
9751  {
9752  namespace detail
9753  {
9754  template<typename BasicJsonType, typename CharType>
9755  class binary_writer
9756  {
9757      using string_t = typename BasicJsonType::string_t;
9758      using binary_t = typename BasicJsonType::binary_t;
9759      using number_float_t = typename BasicJsonType::number_float_t;
9760    public:
9761      explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
9762      {
9763          JSON_ASSERT(oa);
9764      }
9765      void write_bson(const BasicJsonType& j)
9766      {
9767          switch (j.type())
9768          {
9769              case value_t::object:
9770              {
9771                  write_bson_object(*j.m_value.object);
9772                  break;
9773              }
9774              case value_t::null:
9775              case value_t::array:
9776              case value_t::string:
9777              case value_t::boolean:
9778              case value_t::number_integer:
9779              case value_t::number_unsigned:
9780              case value_t::number_float:
9781              case value_t::binary:
9782              case value_t::discarded:
9783              default:
9784              {
9785                  JSON_THROW(type_error::create(317, "to serialize to BSON, top-level type must be object, but is " + std::string(j.type_name()), j));
9786              }
9787          }
9788      }
9789      void write_cbor(const BasicJsonType& j)
9790      {
9791          switch (j.type())
9792          {
9793              case value_t::null:
9794              {
9795                  oa->write_character(to_char_type(0xF6));
9796                  break;
9797              }
9798              case value_t::boolean:
9799              {
9800                  oa->write_character(j.m_value.boolean
9801                                      ? to_char_type(0xF5)
9802                                      : to_char_type(0xF4));
9803                  break;
9804              }
9805              case value_t::number_integer:
9806              {
9807                  if (j.m_value.number_integer >= 0)
9808                  {
9809                      if (j.m_value.number_integer <= 0x17)
9810                      {
9811                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
9812                      }
9813                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
9814                      {
9815                          oa->write_character(to_char_type(0x18));
9816                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
9817                      }
9818                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
9819                      {
9820                          oa->write_character(to_char_type(0x19));
9821                          write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
9822                      }
9823                      else if (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
9824                      {
9825                          oa->write_character(to_char_type(0x1A));
9826                          write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
9827                      }
9828                      else
9829                      {
9830                          oa->write_character(to_char_type(0x1B));
9831                          write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
9832                      }
9833                  }
9834                  else
9835                  {
9836                      const auto positive_number = -1 - j.m_value.number_integer;
9837                      if (j.m_value.number_integer >= -24)
9838                      {
9839                          write_number(static_cast<std::uint8_t>(0x20 + positive_number));
9840                      }
9841                      else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
9842                      {
9843                          oa->write_character(to_char_type(0x38));
9844                          write_number(static_cast<std::uint8_t>(positive_number));
9845                      }
9846                      else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
9847                      {
9848                          oa->write_character(to_char_type(0x39));
9849                          write_number(static_cast<std::uint16_t>(positive_number));
9850                      }
9851                      else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
9852                      {
9853                          oa->write_character(to_char_type(0x3A));
9854                          write_number(static_cast<std::uint32_t>(positive_number));
9855                      }
9856                      else
9857                      {
9858                          oa->write_character(to_char_type(0x3B));
9859                          write_number(static_cast<std::uint64_t>(positive_number));
9860                      }
9861                  }
9862                  break;
9863              }
9864              case value_t::number_unsigned:
9865              {
9866                  if (j.m_value.number_unsigned <= 0x17)
9867                  {
9868                      write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
9869                  }
9870                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
9871                  {
9872                      oa->write_character(to_char_type(0x18));
9873                      write_number(static_cast<std::uint8_t>(j.m_value.number_unsigned));
9874                  }
9875                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
9876                  {
9877                      oa->write_character(to_char_type(0x19));
9878                      write_number(static_cast<std::uint16_t>(j.m_value.number_unsigned));
9879                  }
9880                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
9881                  {
9882                      oa->write_character(to_char_type(0x1A));
9883                      write_number(static_cast<std::uint32_t>(j.m_value.number_unsigned));
9884                  }
9885                  else
9886                  {
9887                      oa->write_character(to_char_type(0x1B));
9888                      write_number(static_cast<std::uint64_t>(j.m_value.number_unsigned));
9889                  }
9890                  break;
9891              }
9892              case value_t::number_float:
9893              {
9894                  if (std::isnan(j.m_value.number_float))
9895                  {
9896                      oa->write_character(to_char_type(0xF9));
9897                      oa->write_character(to_char_type(0x7E));
9898                      oa->write_character(to_char_type(0x00));
9899                  }
9900                  else if (std::isinf(j.m_value.number_float))
9901                  {
9902                      oa->write_character(to_char_type(0xf9));
9903                      oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
9904                      oa->write_character(to_char_type(0x00));
9905                  }
9906                  else
9907                  {
9908                      write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);
9909                  }
9910                  break;
9911              }
9912              case value_t::string:
9913              {
9914                  const auto N = j.m_value.string->size();
9915                  if (N <= 0x17)
9916                  {
9917                      write_number(static_cast<std::uint8_t>(0x60 + N));
9918                  }
9919                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
9920                  {
9921                      oa->write_character(to_char_type(0x78));
9922                      write_number(static_cast<std::uint8_t>(N));
9923                  }
9924                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
9925                  {
9926                      oa->write_character(to_char_type(0x79));
9927                      write_number(static_cast<std::uint16_t>(N));
9928                  }
9929                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
9930                  {
9931                      oa->write_character(to_char_type(0x7A));
9932                      write_number(static_cast<std::uint32_t>(N));
9933                  }
9934                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
9935                  {
9936                      oa->write_character(to_char_type(0x7B));
9937                      write_number(static_cast<std::uint64_t>(N));
9938                  }
9939                  oa->write_characters(
9940                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
9941                      j.m_value.string->size());
9942                  break;
9943              }
9944              case value_t::array:
9945              {
9946                  const auto N = j.m_value.array->size();
9947                  if (N <= 0x17)
9948                  {
9949                      write_number(static_cast<std::uint8_t>(0x80 + N));
9950                  }
9951                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
9952                  {
9953                      oa->write_character(to_char_type(0x98));
9954                      write_number(static_cast<std::uint8_t>(N));
9955                  }
9956                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
9957                  {
9958                      oa->write_character(to_char_type(0x99));
9959                      write_number(static_cast<std::uint16_t>(N));
9960                  }
9961                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
9962                  {
9963                      oa->write_character(to_char_type(0x9A));
9964                      write_number(static_cast<std::uint32_t>(N));
9965                  }
9966                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
9967                  {
9968                      oa->write_character(to_char_type(0x9B));
9969                      write_number(static_cast<std::uint64_t>(N));
9970                  }
9971                  for (const auto& el : *j.m_value.array)
9972                  {
9973                      write_cbor(el);
9974                  }
9975                  break;
9976              }
9977              case value_t::binary:
9978              {
9979                  if (j.m_value.binary->has_subtype())
9980                  {
9981                      if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
9982                      {
9983                          write_number(static_cast<std::uint8_t>(0xd8));
9984                          write_number(static_cast<std::uint8_t>(j.m_value.binary->subtype()));
9985                      }
9986                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
9987                      {
9988                          write_number(static_cast<std::uint8_t>(0xd9));
9989                          write_number(static_cast<std::uint16_t>(j.m_value.binary->subtype()));
9990                      }
9991                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
9992                      {
9993                          write_number(static_cast<std::uint8_t>(0xda));
9994                          write_number(static_cast<std::uint32_t>(j.m_value.binary->subtype()));
9995                      }
9996                      else if (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
9997                      {
9998                          write_number(static_cast<std::uint8_t>(0xdb));
9999                          write_number(static_cast<std::uint64_t>(j.m_value.binary->subtype()));
10000                      }
10001                  }
10002                  const auto N = j.m_value.binary->size();
10003                  if (N <= 0x17)
10004                  {
10005                      write_number(static_cast<std::uint8_t>(0x40 + N));
10006                  }
10007                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
10008                  {
10009                      oa->write_character(to_char_type(0x58));
10010                      write_number(static_cast<std::uint8_t>(N));
10011                  }
10012                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10013                  {
10014                      oa->write_character(to_char_type(0x59));
10015                      write_number(static_cast<std::uint16_t>(N));
10016                  }
10017                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10018                  {
10019                      oa->write_character(to_char_type(0x5A));
10020                      write_number(static_cast<std::uint32_t>(N));
10021                  }
10022                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
10023                  {
10024                      oa->write_character(to_char_type(0x5B));
10025                      write_number(static_cast<std::uint64_t>(N));
10026                  }
10027                  oa->write_characters(
10028                      reinterpret_cast<const CharType*>(j.m_value.binary->data()),
10029                      N);
10030                  break;
10031              }
10032              case value_t::object:
10033              {
10034                  const auto N = j.m_value.object->size();
10035                  if (N <= 0x17)
10036                  {
10037                      write_number(static_cast<std::uint8_t>(0xA0 + N));
10038                  }
10039                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
10040                  {
10041                      oa->write_character(to_char_type(0xB8));
10042                      write_number(static_cast<std::uint8_t>(N));
10043                  }
10044                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10045                  {
10046                      oa->write_character(to_char_type(0xB9));
10047                      write_number(static_cast<std::uint16_t>(N));
10048                  }
10049                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10050                  {
10051                      oa->write_character(to_char_type(0xBA));
10052                      write_number(static_cast<std::uint32_t>(N));
10053                  }
10054                  else if (N <= (std::numeric_limits<std::uint64_t>::max)())
10055                  {
10056                      oa->write_character(to_char_type(0xBB));
10057                      write_number(static_cast<std::uint64_t>(N));
10058                  }
10059                  for (const auto& el : *j.m_value.object)
10060                  {
10061                      write_cbor(el.first);
10062                      write_cbor(el.second);
10063                  }
10064                  break;
10065              }
10066              case value_t::discarded:
10067              default:
10068                  break;
10069          }
10070      }
10071      void write_msgpack(const BasicJsonType& j)
10072      {
10073          switch (j.type())
10074          {
10075              case value_t::null: 
10076              {
10077                  oa->write_character(to_char_type(0xC0));
10078                  break;
10079              }
10080              case value_t::boolean: 
10081              {
10082                  oa->write_character(j.m_value.boolean
10083                                      ? to_char_type(0xC3)
10084                                      : to_char_type(0xC2));
10085                  break;
10086              }
10087              case value_t::number_integer:
10088              {
10089                  if (j.m_value.number_integer >= 0)
10090                  {
10091                      if (j.m_value.number_unsigned < 128)
10092                      {
10093                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10094                      }
10095                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
10096                      {
10097                          oa->write_character(to_char_type(0xCC));
10098                          write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10099                      }
10100                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
10101                      {
10102                          oa->write_character(to_char_type(0xCD));
10103                          write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
10104                      }
10105                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
10106                      {
10107                          oa->write_character(to_char_type(0xCE));
10108                          write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
10109                      }
10110                      else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
10111                      {
10112                          oa->write_character(to_char_type(0xCF));
10113                          write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
10114                      }
10115                  }
10116                  else
10117                  {
10118                      if (j.m_value.number_integer >= -32)
10119                      {
10120                          write_number(static_cast<std::int8_t>(j.m_value.number_integer));
10121                      }
10122                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
10123                               j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
10124                      {
10125                          oa->write_character(to_char_type(0xD0));
10126                          write_number(static_cast<std::int8_t>(j.m_value.number_integer));
10127                      }
10128                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
10129                               j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
10130                      {
10131                          oa->write_character(to_char_type(0xD1));
10132                          write_number(static_cast<std::int16_t>(j.m_value.number_integer));
10133                      }
10134                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
10135                               j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
10136                      {
10137                          oa->write_character(to_char_type(0xD2));
10138                          write_number(static_cast<std::int32_t>(j.m_value.number_integer));
10139                      }
10140                      else if (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
10141                               j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
10142                      {
10143                          oa->write_character(to_char_type(0xD3));
10144                          write_number(static_cast<std::int64_t>(j.m_value.number_integer));
10145                      }
10146                  }
10147                  break;
10148              }
10149              case value_t::number_unsigned:
10150              {
10151                  if (j.m_value.number_unsigned < 128)
10152                  {
10153                      write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10154                  }
10155                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
10156                  {
10157                      oa->write_character(to_char_type(0xCC));
10158                      write_number(static_cast<std::uint8_t>(j.m_value.number_integer));
10159                  }
10160                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
10161                  {
10162                      oa->write_character(to_char_type(0xCD));
10163                      write_number(static_cast<std::uint16_t>(j.m_value.number_integer));
10164                  }
10165                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
10166                  {
10167                      oa->write_character(to_char_type(0xCE));
10168                      write_number(static_cast<std::uint32_t>(j.m_value.number_integer));
10169                  }
10170                  else if (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
10171                  {
10172                      oa->write_character(to_char_type(0xCF));
10173                      write_number(static_cast<std::uint64_t>(j.m_value.number_integer));
10174                  }
10175                  break;
10176              }
10177              case value_t::number_float:
10178              {
10179                  write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);
10180                  break;
10181              }
10182              case value_t::string:
10183              {
10184                  const auto N = j.m_value.string->size();
10185                  if (N <= 31)
10186                  {
10187                      write_number(static_cast<std::uint8_t>(0xA0 | N));
10188                  }
10189                  else if (N <= (std::numeric_limits<std::uint8_t>::max)())
10190                  {
10191                      oa->write_character(to_char_type(0xD9));
10192                      write_number(static_cast<std::uint8_t>(N));
10193                  }
10194                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10195                  {
10196                      oa->write_character(to_char_type(0xDA));
10197                      write_number(static_cast<std::uint16_t>(N));
10198                  }
10199                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10200                  {
10201                      oa->write_character(to_char_type(0xDB));
10202                      write_number(static_cast<std::uint32_t>(N));
10203                  }
10204                  oa->write_characters(
10205                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
10206                      j.m_value.string->size());
10207                  break;
10208              }
10209              case value_t::array:
10210              {
10211                  const auto N = j.m_value.array->size();
10212                  if (N <= 15)
10213                  {
10214                      write_number(static_cast<std::uint8_t>(0x90 | N));
10215                  }
10216                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10217                  {
10218                      oa->write_character(to_char_type(0xDC));
10219                      write_number(static_cast<std::uint16_t>(N));
10220                  }
10221                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10222                  {
10223                      oa->write_character(to_char_type(0xDD));
10224                      write_number(static_cast<std::uint32_t>(N));
10225                  }
10226                  for (const auto& el : *j.m_value.array)
10227                  {
10228                      write_msgpack(el);
10229                  }
10230                  break;
10231              }
10232              case value_t::binary:
10233              {
10234                  const bool use_ext = j.m_value.binary->has_subtype();
10235                  const auto N = j.m_value.binary->size();
10236                  if (N <= (std::numeric_limits<std::uint8_t>::max)())
10237                  {
10238                      std::uint8_t output_type{};
10239                      bool fixed = true;
10240                      if (use_ext)
10241                      {
10242                          switch (N)
10243                          {
10244                              case 1:
10245                                  output_type = 0xD4; 
10246                                  break;
10247                              case 2:
10248                                  output_type = 0xD5; 
10249                                  break;
10250                              case 4:
10251                                  output_type = 0xD6; 
10252                                  break;
10253                              case 8:
10254                                  output_type = 0xD7; 
10255                                  break;
10256                              case 16:
10257                                  output_type = 0xD8; 
10258                                  break;
10259                              default:
10260                                  output_type = 0xC7; 
10261                                  fixed = false;
10262                                  break;
10263                          }
10264                      }
10265                      else
10266                      {
10267                          output_type = 0xC4; 
10268                          fixed = false;
10269                      }
10270                      oa->write_character(to_char_type(output_type));
10271                      if (!fixed)
10272                      {
10273                          write_number(static_cast<std::uint8_t>(N));
10274                      }
10275                  }
10276                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10277                  {
10278                      std::uint8_t output_type = use_ext
10279                                                 ? 0xC8 
10280                                                 : 0xC5; 
10281                      oa->write_character(to_char_type(output_type));
10282                      write_number(static_cast<std::uint16_t>(N));
10283                  }
10284                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10285                  {
10286                      std::uint8_t output_type = use_ext
10287                                                 ? 0xC9 
10288                                                 : 0xC6; 
10289                      oa->write_character(to_char_type(output_type));
10290                      write_number(static_cast<std::uint32_t>(N));
10291                  }
10292                  if (use_ext)
10293                  {
10294                      write_number(static_cast<std::int8_t>(j.m_value.binary->subtype()));
10295                  }
10296                  oa->write_characters(
10297                      reinterpret_cast<const CharType*>(j.m_value.binary->data()),
10298                      N);
10299                  break;
10300              }
10301              case value_t::object:
10302              {
10303                  const auto N = j.m_value.object->size();
10304                  if (N <= 15)
10305                  {
10306                      write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
10307                  }
10308                  else if (N <= (std::numeric_limits<std::uint16_t>::max)())
10309                  {
10310                      oa->write_character(to_char_type(0xDE));
10311                      write_number(static_cast<std::uint16_t>(N));
10312                  }
10313                  else if (N <= (std::numeric_limits<std::uint32_t>::max)())
10314                  {
10315                      oa->write_character(to_char_type(0xDF));
10316                      write_number(static_cast<std::uint32_t>(N));
10317                  }
10318                  for (const auto& el : *j.m_value.object)
10319                  {
10320                      write_msgpack(el.first);
10321                      write_msgpack(el.second);
10322                  }
10323                  break;
10324              }
10325              case value_t::discarded:
10326              default:
10327                  break;
10328          }
10329      }
10330      void write_ubjson(const BasicJsonType& j, const bool use_count,
10331                        const bool use_type, const bool add_prefix = true)
10332      {
10333          switch (j.type())
10334          {
10335              case value_t::null:
10336              {
10337                  if (add_prefix)
10338                  {
10339                      oa->write_character(to_char_type('Z'));
10340                  }
10341                  break;
10342              }
10343              case value_t::boolean:
10344              {
10345                  if (add_prefix)
10346                  {
10347                      oa->write_character(j.m_value.boolean
10348                                          ? to_char_type('T')
10349                                          : to_char_type('F'));
10350                  }
10351                  break;
10352              }
10353              case value_t::number_integer:
10354              {
10355                  write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
10356                  break;
10357              }
10358              case value_t::number_unsigned:
10359              {
10360                  write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
10361                  break;
10362              }
10363              case value_t::number_float:
10364              {
10365                  write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
10366                  break;
10367              }
10368              case value_t::string:
10369              {
10370                  if (add_prefix)
10371                  {
10372                      oa->write_character(to_char_type('S'));
10373                  }
10374                  write_number_with_ubjson_prefix(j.m_value.string->size(), true);
10375                  oa->write_characters(
10376                      reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
10377                      j.m_value.string->size());
10378                  break;
10379              }
10380              case value_t::array:
10381              {
10382                  if (add_prefix)
10383                  {
10384                      oa->write_character(to_char_type('['));
10385                  }
10386                  bool prefix_required = true;
10387                  if (use_type && !j.m_value.array->empty())
10388                  {
10389                      JSON_ASSERT(use_count);
10390                      const CharType first_prefix = ubjson_prefix(j.front());
10391                      const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
10392                                                           [this, first_prefix](const BasicJsonType & v)
10393                      {
10394                          return ubjson_prefix(v) == first_prefix;
10395                      });
10396                      if (same_prefix)
10397                      {
10398                          prefix_required = false;
10399                          oa->write_character(to_char_type('$'));
10400                          oa->write_character(first_prefix);
10401                      }
10402                  }
10403                  if (use_count)
10404                  {
10405                      oa->write_character(to_char_type('#'));
10406                      write_number_with_ubjson_prefix(j.m_value.array->size(), true);
10407                  }
10408                  for (const auto& el : *j.m_value.array)
10409                  {
10410                      write_ubjson(el, use_count, use_type, prefix_required);
10411                  }
10412                  if (!use_count)
10413                  {
10414                      oa->write_character(to_char_type(']'));
10415                  }
10416                  break;
10417              }
10418              case value_t::binary:
10419              {
10420                  if (add_prefix)
10421                  {
10422                      oa->write_character(to_char_type('['));
10423                  }
10424                  if (use_type && !j.m_value.binary->empty())
10425                  {
10426                      JSON_ASSERT(use_count);
10427                      oa->write_character(to_char_type('$'));
10428                      oa->write_character('U');
10429                  }
10430                  if (use_count)
10431                  {
10432                      oa->write_character(to_char_type('#'));
10433                      write_number_with_ubjson_prefix(j.m_value.binary->size(), true);
10434                  }
10435                  if (use_type)
10436                  {
10437                      oa->write_characters(
10438                          reinterpret_cast<const CharType*>(j.m_value.binary->data()),
10439                          j.m_value.binary->size());
10440                  }
10441                  else
10442                  {
10443                      for (size_t i = 0; i < j.m_value.binary->size(); ++i)
10444                      {
10445                          oa->write_character(to_char_type('U'));
10446                          oa->write_character(j.m_value.binary->data()[i]);
10447                      }
10448                  }
10449                  if (!use_count)
10450                  {
10451                      oa->write_character(to_char_type(']'));
10452                  }
10453                  break;
10454              }
10455              case value_t::object:
10456              {
10457                  if (add_prefix)
10458                  {
10459                      oa->write_character(to_char_type('{'));
10460                  }
10461                  bool prefix_required = true;
10462                  if (use_type && !j.m_value.object->empty())
10463                  {
10464                      JSON_ASSERT(use_count);
10465                      const CharType first_prefix = ubjson_prefix(j.front());
10466                      const bool same_prefix = std::all_of(j.begin(), j.end(),
10467                                                           [this, first_prefix](const BasicJsonType & v)
10468                      {
10469                          return ubjson_prefix(v) == first_prefix;
10470                      });
10471                      if (same_prefix)
10472                      {
10473                          prefix_required = false;
10474                          oa->write_character(to_char_type('$'));
10475                          oa->write_character(first_prefix);
10476                      }
10477                  }
10478                  if (use_count)
10479                  {
10480                      oa->write_character(to_char_type('#'));
10481                      write_number_with_ubjson_prefix(j.m_value.object->size(), true);
10482                  }
10483                  for (const auto& el : *j.m_value.object)
10484                  {
10485                      write_number_with_ubjson_prefix(el.first.size(), true);
10486                      oa->write_characters(
10487                          reinterpret_cast<const CharType*>(el.first.c_str()),
10488                          el.first.size());
10489                      write_ubjson(el.second, use_count, use_type, prefix_required);
10490                  }
10491                  if (!use_count)
10492                  {
10493                      oa->write_character(to_char_type('}'));
10494                  }
10495                  break;
10496              }
10497              case value_t::discarded:
10498              default:
10499                  break;
10500          }
10501      }
10502    private:
10503      static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
10504      {
10505          const auto it = name.find(static_cast<typename string_t::value_type>(0));
10506          if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
10507          {
10508              JSON_THROW(out_of_range::create(409, "BSON key cannot contain code point U+0000 (at byte " + std::to_string(it) + ")", j));
10509              static_cast<void>(j);
10510          }
10511          return &bsol;*id*/ 1ul + name.size() + &bsol;*zero-terminator*/1u;
10512      }
10513      void write_bson_entry_header(const string_t& name,
10514                                   const std::uint8_t element_type)
10515      {
10516          oa->write_character(to_char_type(element_type)); 
10517          oa->write_characters(
10518              reinterpret_cast<const CharType*>(name.c_str()),
10519              name.size() + 1u);
10520      }
10521      void write_bson_boolean(const string_t& name,
10522                              const bool value)
10523      {
10524          write_bson_entry_header(name, 0x08);
10525          oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
10526      }
10527      void write_bson_double(const string_t& name,
10528                             const double value)
10529      {
10530          write_bson_entry_header(name, 0x01);
10531          write_number<double, true>(value);
10532      }
10533      static std::size_t calc_bson_string_size(const string_t& value)
10534      {
10535          return sizeof(std::int32_t) + value.size() + 1ul;
10536      }
10537      void write_bson_string(const string_t& name,
10538                             const string_t& value)
10539      {
10540          write_bson_entry_header(name, 0x02);
10541          write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size() + 1ul));
10542          oa->write_characters(
10543              reinterpret_cast<const CharType*>(value.c_str()),
10544              value.size() + 1);
10545      }
10546      void write_bson_null(const string_t& name)
10547      {
10548          write_bson_entry_header(name, 0x0A);
10549      }
10550      static std::size_t calc_bson_integer_size(const std::int64_t value)
10551      {
10552          return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
10553                 ? sizeof(std::int32_t)
10554                 : sizeof(std::int64_t);
10555      }
10556      void write_bson_integer(const string_t& name,
10557                              const std::int64_t value)
10558      {
10559          if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
10560          {
10561              write_bson_entry_header(name, 0x10); 
10562              write_number<std::int32_t, true>(static_cast<std::int32_t>(value));
10563          }
10564          else
10565          {
10566              write_bson_entry_header(name, 0x12); 
10567              write_number<std::int64_t, true>(static_cast<std::int64_t>(value));
10568          }
10569      }
10570      static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
10571      {
10572          return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
10573                 ? sizeof(std::int32_t)
10574                 : sizeof(std::int64_t);
10575      }
10576      void write_bson_unsigned(const string_t& name,
10577                               const BasicJsonType& j)
10578      {
10579          if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
10580          {
10581              write_bson_entry_header(name, 0x10 &bsol;* int32 */);
10582              write_number<std::int32_t, true>(static_cast<std::int32_t>(j.m_value.number_unsigned));
10583          }
10584          else if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
10585          {
10586              write_bson_entry_header(name, 0x12 &bsol;* int64 */);
10587              write_number<std::int64_t, true>(static_cast<std::int64_t>(j.m_value.number_unsigned));
10588          }
10589          else
10590          {
10591              JSON_THROW(out_of_range::create(407, "integer number " + std::to_string(j.m_value.number_unsigned) + " cannot be represented by BSON as it does not fit int64", j));
10592          }
10593      }
10594      void write_bson_object_entry(const string_t& name,
10595                                   const typename BasicJsonType::object_t& value)
10596      {
10597          write_bson_entry_header(name, 0x03); 
10598          write_bson_object(value);
10599      }
10600      static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
10601      {
10602          std::size_t array_index = 0ul;
10603          const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), std::size_t(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
10604          {
10605              return result + calc_bson_element_size(std::to_string(array_index++), el);
10606          });
10607          return sizeof(std::int32_t) + embedded_document_size + 1ul;
10608      }
10609      static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
10610      {
10611          return sizeof(std::int32_t) + value.size() + 1ul;
10612      }
10613      void write_bson_array(const string_t& name,
10614                            const typename BasicJsonType::array_t& value)
10615      {
10616          write_bson_entry_header(name, 0x04); 
10617          write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_array_size(value)));
10618          std::size_t array_index = 0ul;
10619          for (const auto& el : value)
10620          {
10621              write_bson_element(std::to_string(array_index++), el);
10622          }
10623          oa->write_character(to_char_type(0x00));
10624      }
10625      void write_bson_binary(const string_t& name,
10626                             const binary_t& value)
10627      {
10628          write_bson_entry_header(name, 0x05);
10629          write_number<std::int32_t, true>(static_cast<std::int32_t>(value.size()));
10630          write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : std::uint8_t(0x00));
10631          oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
10632      }
10633      static std::size_t calc_bson_element_size(const string_t& name,
10634              const BasicJsonType& j)
10635      {
10636          const auto header_size = calc_bson_entry_header_size(name, j);
10637          switch (j.type())
10638          {
10639              case value_t::object:
10640                  return header_size + calc_bson_object_size(*j.m_value.object);
10641              case value_t::array:
10642                  return header_size + calc_bson_array_size(*j.m_value.array);
10643              case value_t::binary:
10644                  return header_size + calc_bson_binary_size(*j.m_value.binary);
10645              case value_t::boolean:
10646                  return header_size + 1ul;
10647              case value_t::number_float:
10648                  return header_size + 8ul;
10649              case value_t::number_integer:
10650                  return header_size + calc_bson_integer_size(j.m_value.number_integer);
10651              case value_t::number_unsigned:
10652                  return header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);
10653              case value_t::string:
10654                  return header_size + calc_bson_string_size(*j.m_value.string);
10655              case value_t::null:
10656                  return header_size + 0ul;
10657              case value_t::discarded:
10658              default:
10659                  JSON_ASSERT(false); 
10660                  return 0ul;
10661          }
10662      }
10663      void write_bson_element(const string_t& name,
10664                              const BasicJsonType& j)
10665      {
10666          switch (j.type())
10667          {
10668              case value_t::object:
10669                  return write_bson_object_entry(name, *j.m_value.object);
10670              case value_t::array:
10671                  return write_bson_array(name, *j.m_value.array);
10672              case value_t::binary:
10673                  return write_bson_binary(name, *j.m_value.binary);
10674              case value_t::boolean:
10675                  return write_bson_boolean(name, j.m_value.boolean);
10676              case value_t::number_float:
10677                  return write_bson_double(name, j.m_value.number_float);
10678              case value_t::number_integer:
10679                  return write_bson_integer(name, j.m_value.number_integer);
10680              case value_t::number_unsigned:
10681                  return write_bson_unsigned(name, j);
10682              case value_t::string:
10683                  return write_bson_string(name, *j.m_value.string);
10684              case value_t::null:
10685                  return write_bson_null(name);
10686              case value_t::discarded:
10687              default:
10688                  JSON_ASSERT(false); 
10689                  return;
10690          }
10691      }
10692      static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
10693      {
10694          std::size_t document_size = std::accumulate(value.begin(), value.end(), std::size_t(0),
10695                                      [](size_t result, const typename BasicJsonType::object_t::value_type & el)
10696          {
10697              return result += calc_bson_element_size(el.first, el.second);
10698          });
10699          return sizeof(std::int32_t) + document_size + 1ul;
10700      }
10701      void write_bson_object(const typename BasicJsonType::object_t& value)
10702      {
10703          write_number<std::int32_t, true>(static_cast<std::int32_t>(calc_bson_object_size(value)));
10704          for (const auto& el : value)
10705          {
10706              write_bson_element(el.first, el.second);
10707          }
10708          oa->write_character(to_char_type(0x00));
10709      }
10710      static constexpr CharType get_cbor_float_prefix(float &bsol;*unused*/)
10711      {
10712          return to_char_type(0xFA);  
10713      }
10714      static constexpr CharType get_cbor_float_prefix(double &bsol;*unused*/)
10715      {
10716          return to_char_type(0xFB);  
10717      }
10718      static constexpr CharType get_msgpack_float_prefix(float &bsol;*unused*/)
10719      {
10720          return to_char_type(0xCA);  
10721      }
10722      static constexpr CharType get_msgpack_float_prefix(double &bsol;*unused*/)
10723      {
10724          return to_char_type(0xCB);  
10725      }
10726      template<typename NumberType, typename std::enable_if<
10727                   std::is_floating_point<NumberType>::value, int>::type = 0>
10728      void write_number_with_ubjson_prefix(const NumberType n,
10729                                           const bool add_prefix)
10730      {
10731          if (add_prefix)
10732          {
10733              oa->write_character(get_ubjson_float_prefix(n));
10734          }
10735          write_number(n);
10736      }
10737      template<typename NumberType, typename std::enable_if<
10738                   std::is_unsigned<NumberType>::value, int>::type = 0>
10739      void write_number_with_ubjson_prefix(const NumberType n,
10740                                           const bool add_prefix)
10741      {
10742          if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
10743          {
10744              if (add_prefix)
10745              {
10746                  oa->write_character(to_char_type('i'));  
10747              }
10748              write_number(static_cast<std::uint8_t>(n));
10749          }
10750          else if (n <= (std::numeric_limits<std::uint8_t>::max)())
10751          {
10752              if (add_prefix)
10753              {
10754                  oa->write_character(to_char_type('U'));  
10755              }
10756              write_number(static_cast<std::uint8_t>(n));
10757          }
10758          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
10759          {
10760              if (add_prefix)
10761              {
10762                  oa->write_character(to_char_type('I'));  
10763              }
10764              write_number(static_cast<std::int16_t>(n));
10765          }
10766          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
10767          {
10768              if (add_prefix)
10769              {
10770                  oa->write_character(to_char_type('l'));  
10771              }
10772              write_number(static_cast<std::int32_t>(n));
10773          }
10774          else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
10775          {
10776              if (add_prefix)
10777              {
10778                  oa->write_character(to_char_type('L'));  
10779              }
10780              write_number(static_cast<std::int64_t>(n));
10781          }
10782          else
10783          {
10784              if (add_prefix)
10785              {
10786                  oa->write_character(to_char_type('H'));  
10787              }
10788              const auto number = BasicJsonType(n).dump();
10789              write_number_with_ubjson_prefix(number.size(), true);
10790              for (std::size_t i = 0; i < number.size(); ++i)
10791              {
10792                  oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
10793              }
10794          }
10795      }
10796      template < typename NumberType, typename std::enable_if <
10797                     std::is_signed<NumberType>::value&&
10798                     !std::is_floating_point<NumberType>::value, int >::type = 0 >
10799      void write_number_with_ubjson_prefix(const NumberType n,
10800                                           const bool add_prefix)
10801      {
10802          if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
10803          {
10804              if (add_prefix)
10805              {
10806                  oa->write_character(to_char_type('i'));  
10807              }
10808              write_number(static_cast<std::int8_t>(n));
10809          }
10810          else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
10811          {
10812              if (add_prefix)
10813              {
10814                  oa->write_character(to_char_type('U'));  
10815              }
10816              write_number(static_cast<std::uint8_t>(n));
10817          }
10818          else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
10819          {
10820              if (add_prefix)
10821              {
10822                  oa->write_character(to_char_type('I'));  
10823              }
10824              write_number(static_cast<std::int16_t>(n));
10825          }
10826          else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
10827          {
10828              if (add_prefix)
10829              {
10830                  oa->write_character(to_char_type('l'));  
10831              }
10832              write_number(static_cast<std::int32_t>(n));
10833          }
10834          else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
10835          {
10836              if (add_prefix)
10837              {
10838                  oa->write_character(to_char_type('L'));  
10839              }
10840              write_number(static_cast<std::int64_t>(n));
10841          }
10842          else
10843          {
10844              if (add_prefix)
10845              {
10846                  oa->write_character(to_char_type('H'));  
10847              }
10848              const auto number = BasicJsonType(n).dump();
10849              write_number_with_ubjson_prefix(number.size(), true);
10850              for (std::size_t i = 0; i < number.size(); ++i)
10851              {
10852                  oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
10853              }
10854          }
10855      }
10856      CharType ubjson_prefix(const BasicJsonType& j) const noexcept
10857      {
10858          switch (j.type())
10859          {
10860              case value_t::null:
10861                  return 'Z';
10862              case value_t::boolean:
10863                  return j.m_value.boolean ? 'T' : 'F';
10864              case value_t::number_integer:
10865              {
10866                  if ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
10867                  {
10868                      return 'i';
10869                  }
10870                  if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
10871                  {
10872                      return 'U';
10873                  }
10874                  if ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
10875                  {
10876                      return 'I';
10877                  }
10878                  if ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
10879                  {
10880                      return 'l';
10881                  }
10882                  if ((std::numeric_limits<std::int64_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
10883                  {
10884                      return 'L';
10885                  }
10886                  return 'H'; 
10887              }
10888              case value_t::number_unsigned:
10889              {
10890                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
10891                  {
10892                      return 'i';
10893                  }
10894                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
10895                  {
10896                      return 'U';
10897                  }
10898                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
10899                  {
10900                      return 'I';
10901                  }
10902                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
10903                  {
10904                      return 'l';
10905                  }
10906                  if (j.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
10907                  {
10908                      return 'L';
10909                  }
10910                  return 'H'; 
10911              }
10912              case value_t::number_float:
10913                  return get_ubjson_float_prefix(j.m_value.number_float);
10914              case value_t::string:
10915                  return 'S';
10916              case value_t::array: 
10917              case value_t::binary:
10918                  return '[';
10919              case value_t::object:
10920                  return '{';
10921              case value_t::discarded:
10922              default:  
10923                  return 'N';
10924          }
10925      }
10926      static constexpr CharType get_ubjson_float_prefix(float &bsol;*unused*/)
10927      {
10928          return 'd';  
10929      }
10930      static constexpr CharType get_ubjson_float_prefix(double &bsol;*unused*/)
10931      {
10932          return 'D';  
10933      }
10934      template<typename NumberType, bool OutputIsLittleEndian = false>
10935      void write_number(const NumberType n)
10936      {
10937          std::array<CharType, sizeof(NumberType)> vec{};
10938          std::memcpy(vec.data(), &n, sizeof(NumberType));
10939          if (is_little_endian != OutputIsLittleEndian)
10940          {
10941              std::reverse(vec.begin(), vec.end());
10942          }
10943          oa->write_characters(vec.data(), sizeof(NumberType));
10944      }
10945      void write_compact_float(const number_float_t n, detail::input_format_t format)
10946      {
10947  #ifdef __GNUC__
10948  #pragma GCC diagnostic push
10949  #pragma GCC diagnostic ignored "-Wfloat-equal"
10950  #endif
10951          if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
10952                  static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
10953                  static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
10954          {
10955              oa->write_character(format == detail::input_format_t::cbor
10956                                  ? get_cbor_float_prefix(static_cast<float>(n))
10957                                  : get_msgpack_float_prefix(static_cast<float>(n)));
10958              write_number(static_cast<float>(n));
10959          }
10960          else
10961          {
10962              oa->write_character(format == detail::input_format_t::cbor
10963                                  ? get_cbor_float_prefix(n)
10964                                  : get_msgpack_float_prefix(n));
10965              write_number(n);
10966          }
10967  #ifdef __GNUC__
10968  #pragma GCC diagnostic pop
10969  #endif
10970      }
10971    public:
10972      template < typename C = CharType,
10973                 enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
10974      static constexpr CharType to_char_type(std::uint8_t x) noexcept
10975      {
10976          return *reinterpret_cast<char*>(&x);
10977      }
10978      template < typename C = CharType,
10979                 enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
10980      static CharType to_char_type(std::uint8_t x) noexcept
10981      {
10982          static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
10983          static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
10984          CharType result;
10985          std::memcpy(&result, &x, sizeof(x));
10986          return result;
10987      }
10988      template<typename C = CharType,
10989               enable_if_t<std::is_unsigned<C>::value>* = nullptr>
10990      static constexpr CharType to_char_type(std::uint8_t x) noexcept
10991      {
10992          return x;
10993      }
10994      template < typename InputCharType, typename C = CharType,
10995                 enable_if_t <
10996                     std::is_signed<C>::value &&
10997                     std::is_signed<char>::value &&
10998                     std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
10999                     > * = nullptr >
11000      static constexpr CharType to_char_type(InputCharType x) noexcept
11001      {
11002          return x;
11003      }
11004    private:
11005      const bool is_little_endian = little_endianess();
11006      output_adapter_t<CharType> oa = nullptr;
11007  };
11008  }  
11009  }  
11010  #include <algorithm> 
11011  #include <array> 
11012  #include <clocale> 
11013  #include <cmath> 
11014  #include <cstddef> 
11015  #include <cstdint> 
11016  #include <cstdio> 
11017  #include <limits> 
11018  #include <string> 
11019  #include <type_traits> 
11020  #include <utility> 
11021  #include <array> 
11022  #include <cmath>   
11023  #include <cstdint> 
11024  #include <cstring> 
11025  #include <limits> 
11026  #include <type_traits> 
11027  namespace nlohmann
11028  {
11029  namespace detail
11030  {
11031  namespace dtoa_impl
11032  {
11033  template<typename Target, typename Source>
11034  Target reinterpret_bits(const Source source)
11035  {
11036      static_assert(sizeof(Target) == sizeof(Source), "size mismatch");
11037      Target target;
11038      std::memcpy(&target, &source, sizeof(Source));
11039      return target;
11040  }
11041  struct diyfp 
11042  {
11043      static constexpr int kPrecision = 64; 
11044      std::uint64_t f = 0;
11045      int e = 0;
11046      constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}
11047      static diyfp sub(const diyfp& x, const diyfp& y) noexcept
11048      {
11049          JSON_ASSERT(x.e == y.e);
11050          JSON_ASSERT(x.f >= y.f);
11051          return {x.f - y.f, x.e};
11052      }
11053      static diyfp mul(const diyfp& x, const diyfp& y) noexcept
11054      {
11055          static_assert(kPrecision == 64, "internal error");
11056          const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
11057          const std::uint64_t u_hi = x.f >> 32u;
11058          const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
11059          const std::uint64_t v_hi = y.f >> 32u;
11060          const std::uint64_t p0 = u_lo * v_lo;
11061          const std::uint64_t p1 = u_lo * v_hi;
11062          const std::uint64_t p2 = u_hi * v_lo;
11063          const std::uint64_t p3 = u_hi * v_hi;
11064          const std::uint64_t p0_hi = p0 >> 32u;
11065          const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
11066          const std::uint64_t p1_hi = p1 >> 32u;
11067          const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
11068          const std::uint64_t p2_hi = p2 >> 32u;
11069          std::uint64_t Q = p0_hi + p1_lo + p2_lo;
11070          Q += std::uint64_t{1} << (64u - 32u - 1u); 
11071          const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);
11072          return {h, x.e + y.e + 64};
11073      }
11074      static diyfp normalize(diyfp x) noexcept
11075      {
11076          JSON_ASSERT(x.f != 0);
11077          while ((x.f >> 63u) == 0)
11078          {
11079              x.f <<= 1u;
11080              x.e--;
11081          }
11082          return x;
11083      }
11084      static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
11085      {
11086          const int delta = x.e - target_exponent;
11087          JSON_ASSERT(delta >= 0);
11088          JSON_ASSERT(((x.f << delta) >> delta) == x.f);
11089          return {x.f << delta, target_exponent};
11090      }
11091  };
11092  struct boundaries
11093  {
11094      diyfp w;
11095      diyfp minus;
11096      diyfp plus;
11097  };
11098  template<typename FloatType>
11099  boundaries compute_boundaries(FloatType value)
11100  {
11101      JSON_ASSERT(std::isfinite(value));
11102      JSON_ASSERT(value > 0);
11103      static_assert(std::numeric_limits<FloatType>::is_iec559,
11104                    "internal error: dtoa_short requires an IEEE-754 floating-point implementation");
11105      constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; 
11106      constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
11107      constexpr int      kMinExp    = 1 - kBias;
11108      constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); 
11109      using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;
11110      const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
11111      const std::uint64_t E = bits >> (kPrecision - 1);
11112      const std::uint64_t F = bits & (kHiddenBit - 1);
11113      const bool is_denormal = E == 0;
11114      const diyfp v = is_denormal
11115                      ? diyfp(F, kMinExp)
11116                      : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);
11117      const bool lower_boundary_is_closer = F == 0 && E > 1;
11118      const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
11119      const diyfp m_minus = lower_boundary_is_closer
11120                            ? diyfp(4 * v.f - 1, v.e - 2)  
11121                            : diyfp(2 * v.f - 1, v.e - 1); 
11122      const diyfp w_plus = diyfp::normalize(m_plus);
11123      const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);
11124      return {diyfp::normalize(v), w_minus, w_plus};
11125  }
11126  constexpr int kAlpha = -60;
11127  constexpr int kGamma = -32;
11128  struct cached_power 
11129  {
11130      std::uint64_t f;
11131      int e;
11132      int k;
11133  };
11134  inline cached_power get_cached_power_for_binary_exponent(int e)
11135  {
11136      constexpr int kCachedPowersMinDecExp = -300;
11137      constexpr int kCachedPowersDecStep = 8;
11138      static constexpr std::array<cached_power, 79> kCachedPowers =
11139      {
11140          {
11141              { 0xAB70FE17C79AC6CA, -1060, -300 },
11142              { 0xFF77B1FCBEBCDC4F, -1034, -292 },
11143              { 0xBE5691EF416BD60C, -1007, -284 },
11144              { 0x8DD01FAD907FFC3C,  -980, -276 },
11145              { 0xD3515C2831559A83,  -954, -268 },
11146              { 0x9D71AC8FADA6C9B5,  -927, -260 },
11147              { 0xEA9C227723EE8BCB,  -901, -252 },
11148              { 0xAECC49914078536D,  -874, -244 },
11149              { 0x823C12795DB6CE57,  -847, -236 },
11150              { 0xC21094364DFB5637,  -821, -228 },
11151              { 0x9096EA6F3848984F,  -794, -220 },
11152              { 0xD77485CB25823AC7,  -768, -212 },
11153              { 0xA086CFCD97BF97F4,  -741, -204 },
11154              { 0xEF340A98172AACE5,  -715, -196 },
11155              { 0xB23867FB2A35B28E,  -688, -188 },
11156              { 0x84C8D4DFD2C63F3B,  -661, -180 },
11157              { 0xC5DD44271AD3CDBA,  -635, -172 },
11158              { 0x936B9FCEBB25C996,  -608, -164 },
11159              { 0xDBAC6C247D62A584,  -582, -156 },
11160              { 0xA3AB66580D5FDAF6,  -555, -148 },
11161              { 0xF3E2F893DEC3F126,  -529, -140 },
11162              { 0xB5B5ADA8AAFF80B8,  -502, -132 },
11163              { 0x87625F056C7C4A8B,  -475, -124 },
11164              { 0xC9BCFF6034C13053,  -449, -116 },
11165              { 0x964E858C91BA2655,  -422, -108 },
11166              { 0xDFF9772470297EBD,  -396, -100 },
11167              { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
11168              { 0xF8A95FCF88747D94,  -343,  -84 },
11169              { 0xB94470938FA89BCF,  -316,  -76 },
11170              { 0x8A08F0F8BF0F156B,  -289,  -68 },
11171              { 0xCDB02555653131B6,  -263,  -60 },
11172              { 0x993FE2C6D07B7FAC,  -236,  -52 },
11173              { 0xE45C10C42A2B3B06,  -210,  -44 },
11174              { 0xAA242499697392D3,  -183,  -36 },
11175              { 0xFD87B5F28300CA0E,  -157,  -28 },
11176              { 0xBCE5086492111AEB,  -130,  -20 },
11177              { 0x8CBCCC096F5088CC,  -103,  -12 },
11178              { 0xD1B71758E219652C,   -77,   -4 },
11179              { 0x9C40000000000000,   -50,    4 },
11180              { 0xE8D4A51000000000,   -24,   12 },
11181              { 0xAD78EBC5AC620000,     3,   20 },
11182              { 0x813F3978F8940984,    30,   28 },
11183              { 0xC097CE7BC90715B3,    56,   36 },
11184              { 0x8F7E32CE7BEA5C70,    83,   44 },
11185              { 0xD5D238A4ABE98068,   109,   52 },
11186              { 0x9F4F2726179A2245,   136,   60 },
11187              { 0xED63A231D4C4FB27,   162,   68 },
11188              { 0xB0DE65388CC8ADA8,   189,   76 },
11189              { 0x83C7088E1AAB65DB,   216,   84 },
11190              { 0xC45D1DF942711D9A,   242,   92 },
11191              { 0x924D692CA61BE758,   269,  100 },
11192              { 0xDA01EE641A708DEA,   295,  108 },
11193              { 0xA26DA3999AEF774A,   322,  116 },
11194              { 0xF209787BB47D6B85,   348,  124 },
11195              { 0xB454E4A179DD1877,   375,  132 },
11196              { 0x865B86925B9BC5C2,   402,  140 },
11197              { 0xC83553C5C8965D3D,   428,  148 },
11198              { 0x952AB45CFA97A0B3,   455,  156 },
11199              { 0xDE469FBD99A05FE3,   481,  164 },
11200              { 0xA59BC234DB398C25,   508,  172 },
11201              { 0xF6C69A72A3989F5C,   534,  180 },
11202              { 0xB7DCBF5354E9BECE,   561,  188 },
11203              { 0x88FCF317F22241E2,   588,  196 },
11204              { 0xCC20CE9BD35C78A5,   614,  204 },
11205              { 0x98165AF37B2153DF,   641,  212 },
11206              { 0xE2A0B5DC971F303A,   667,  220 },
11207              { 0xA8D9D1535CE3B396,   694,  228 },
11208              { 0xFB9B7CD9A4A7443C,   720,  236 },
11209              { 0xBB764C4CA7A44410,   747,  244 },
11210              { 0x8BAB8EEFB6409C1A,   774,  252 },
11211              { 0xD01FEF10A657842C,   800,  260 },
11212              { 0x9B10A4E5E9913129,   827,  268 },
11213              { 0xE7109BFBA19C0C9D,   853,  276 },
11214              { 0xAC2820D9623BF429,   880,  284 },
11215              { 0x80444B5E7AA7CF85,   907,  292 },
11216              { 0xBF21E44003ACDD2D,   933,  300 },
11217              { 0x8E679C2F5E44FF8F,   960,  308 },
11218              { 0xD433179D9C8CB841,   986,  316 },
11219              { 0x9E19DB92B4E31BA9,  1013,  324 },
11220          }
11221      };
11222      JSON_ASSERT(e >= -1500);
11223      JSON_ASSERT(e <=  1500);
11224      const int f = kAlpha - e - 1;
11225      const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);
11226      const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
11227      JSON_ASSERT(index >= 0);
11228      JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());
11229      const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
11230      JSON_ASSERT(kAlpha <= cached.e + e + 64);
11231      JSON_ASSERT(kGamma >= cached.e + e + 64);
11232      return cached;
11233  }
11234  inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
11235  {
11236      if (n >= 1000000000)
11237      {
11238          pow10 = 1000000000;
11239          return 10;
11240      }
11241      if (n >= 100000000)
11242      {
11243          pow10 = 100000000;
11244          return  9;
11245      }
11246      if (n >= 10000000)
11247      {
11248          pow10 = 10000000;
11249          return  8;
11250      }
11251      if (n >= 1000000)
11252      {
11253          pow10 = 1000000;
11254          return  7;
11255      }
11256      if (n >= 100000)
11257      {
11258          pow10 = 100000;
11259          return  6;
11260      }
11261      if (n >= 10000)
11262      {
11263          pow10 = 10000;
11264          return  5;
11265      }
11266      if (n >= 1000)
11267      {
11268          pow10 = 1000;
11269          return  4;
11270      }
11271      if (n >= 100)
11272      {
11273          pow10 = 100;
11274          return  3;
11275      }
11276      if (n >= 10)
11277      {
11278          pow10 = 10;
11279          return  2;
11280      }
11281      pow10 = 1;
11282      return 1;
11283  }
11284  inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
11285                           std::uint64_t rest, std::uint64_t ten_k)
11286  {
11287      JSON_ASSERT(len >= 1);
11288      JSON_ASSERT(dist <= delta);
11289      JSON_ASSERT(rest <= delta);
11290      JSON_ASSERT(ten_k > 0);
11291      while (rest < dist
11292              && delta - rest >= ten_k
11293              && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
11294      {
11295          JSON_ASSERT(buf[len - 1] != '0');
11296          buf[len - 1]--;
11297          rest += ten_k;
11298      }
11299  }
11300  inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
11301                               diyfp M_minus, diyfp w, diyfp M_plus)
11302  {
11303      static_assert(kAlpha >= -60, "internal error");
11304      static_assert(kGamma <= -32, "internal error");
11305      JSON_ASSERT(M_plus.e >= kAlpha);
11306      JSON_ASSERT(M_plus.e <= kGamma);
11307      std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; 
11308      std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; 
11309      const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);
11310      auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); 
11311      std::uint64_t p2 = M_plus.f & (one.f - 1);                    
11312      JSON_ASSERT(p1 > 0);
11313      std::uint32_t pow10{};
11314      const int k = find_largest_pow10(p1, pow10);
11315      int n = k;
11316      while (n > 0)
11317      {
11318          const std::uint32_t d = p1 / pow10;  
11319          const std::uint32_t r = p1 % pow10;  
11320          JSON_ASSERT(d <= 9);
11321          buffer[length++] = static_cast<char>('0' + d); 
11322          p1 = r;
11323          n--;
11324          const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
11325          if (rest <= delta)
11326          {
11327              decimal_exponent += n;
11328              const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
11329              grisu2_round(buffer, length, dist, delta, rest, ten_n);
11330              return;
11331          }
11332          pow10 /= 10;
11333      }
11334      JSON_ASSERT(p2 > delta);
11335      int m = 0;
11336      for (;;)
11337      {
11338          JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
11339          p2 *= 10;
11340          const std::uint64_t d = p2 >> -one.e;     
11341          const std::uint64_t r = p2 & (one.f - 1); 
11342          JSON_ASSERT(d <= 9);
11343          buffer[length++] = static_cast<char>('0' + d); 
11344          p2 = r;
11345          m++;
11346          delta *= 10;
11347          dist  *= 10;
11348          if (p2 <= delta)
11349          {
11350              break;
11351          }
11352      }
11353      decimal_exponent -= m;
11354      const std::uint64_t ten_m = one.f;
11355      grisu2_round(buffer, length, dist, delta, p2, ten_m);
11356  }
11357  JSON_HEDLEY_NON_NULL(1)
11358  inline void grisu2(char* buf, int& len, int& decimal_exponent,
11359                     diyfp m_minus, diyfp v, diyfp m_plus)
11360  {
11361      JSON_ASSERT(m_plus.e == m_minus.e);
11362      JSON_ASSERT(m_plus.e == v.e);
11363      const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);
11364      const diyfp c_minus_k(cached.f, cached.e); 
11365      const diyfp w       = diyfp::mul(v,       c_minus_k);
11366      const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
11367      const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);
11368      const diyfp M_minus(w_minus.f + 1, w_minus.e);
11369      const diyfp M_plus (w_plus.f  - 1, w_plus.e );
11370      decimal_exponent = -cached.k; 
11371      grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
11372  }
11373  template<typename FloatType>
11374  JSON_HEDLEY_NON_NULL(1)
11375  void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
11376  {
11377      static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
11378                    "internal error: not enough precision");
11379      JSON_ASSERT(std::isfinite(value));
11380      JSON_ASSERT(value > 0);
11381  #if 0
11382      const boundaries w = compute_boundaries(static_cast<double>(value));
11383  #else
11384      const boundaries w = compute_boundaries(value);
11385  #endif
11386      grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
11387  }
11388  JSON_HEDLEY_NON_NULL(1)
11389  JSON_HEDLEY_RETURNS_NON_NULL
11390  inline char* append_exponent(char* buf, int e)
11391  {
11392      JSON_ASSERT(e > -1000);
11393      JSON_ASSERT(e <  1000);
11394      if (e < 0)
11395      {
11396          e = -e;
11397          *buf++ = '-';
11398      }
11399      else
11400      {
11401          *buf++ = '+';
11402      }
11403      auto k = static_cast<std::uint32_t>(e);
11404      if (k < 10)
11405      {
11406          *buf++ = '0';
11407          *buf++ = static_cast<char>('0' + k);
11408      }
11409      else if (k < 100)
11410      {
11411          *buf++ = static_cast<char>('0' + k / 10);
11412          k %= 10;
11413          *buf++ = static_cast<char>('0' + k);
11414      }
11415      else
11416      {
11417          *buf++ = static_cast<char>('0' + k / 100);
11418          k %= 100;
11419          *buf++ = static_cast<char>('0' + k / 10);
11420          k %= 10;
11421          *buf++ = static_cast<char>('0' + k);
11422      }
11423      return buf;
11424  }
11425  JSON_HEDLEY_NON_NULL(1)
11426  JSON_HEDLEY_RETURNS_NON_NULL
11427  inline char* format_buffer(char* buf, int len, int decimal_exponent,
11428                             int min_exp, int max_exp)
11429  {
11430      JSON_ASSERT(min_exp < 0);
11431      JSON_ASSERT(max_exp > 0);
11432      const int k = len;
11433      const int n = len + decimal_exponent;
11434      if (k <= n && n <= max_exp)
11435      {
11436          std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
11437          buf[n + 0] = '.';
11438          buf[n + 1] = '0';
11439          return buf + (static_cast<size_t>(n) + 2);
11440      }
11441      if (0 < n && n <= max_exp)
11442      {
11443          JSON_ASSERT(k > n);
11444          std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
11445          buf[n] = '.';
11446          return buf + (static_cast<size_t>(k) + 1U);
11447      }
11448      if (min_exp < n && n <= 0)
11449      {
11450          std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
11451          buf[0] = '0';
11452          buf[1] = '.';
11453          std::memset(buf + 2, '0', static_cast<size_t>(-n));
11454          return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
11455      }
11456      if (k == 1)
11457      {
11458          buf += 1;
11459      }
11460      else
11461      {
11462          std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
11463          buf[1] = '.';
11464          buf += 1 + static_cast<size_t>(k);
11465      }
11466      *buf++ = 'e';
11467      return append_exponent(buf, n - 1);
11468  }
11469  } 
11470  template<typename FloatType>
11471  JSON_HEDLEY_NON_NULL(1, 2)
11472  JSON_HEDLEY_RETURNS_NON_NULL
11473  char* to_chars(char* first, const char* last, FloatType value)
11474  {
11475      static_cast<void>(last); 
11476      JSON_ASSERT(std::isfinite(value));
11477      if (std::signbit(value))
11478      {
11479          value = -value;
11480          *first++ = '-';
11481      }
11482  #ifdef __GNUC__
11483  #pragma GCC diagnostic push
11484  #pragma GCC diagnostic ignored "-Wfloat-equal"
11485  #endif
11486      if (value == 0) 
11487      {
11488          *first++ = '0';
11489          *first++ = '.';
11490          *first++ = '0';
11491          return first;
11492      }
11493  #ifdef __GNUC__
11494  #pragma GCC diagnostic pop
11495  #endif
11496      JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);
11497      int len = 0;
11498      int decimal_exponent = 0;
11499      dtoa_impl::grisu2(first, len, decimal_exponent, value);
11500      JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);
11501      constexpr int kMinExp = -4;
11502      constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;
11503      JSON_ASSERT(last - first >= kMaxExp + 2);
11504      JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
11505      JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);
11506      return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
11507  }
11508  } 
11509  } 
11510  namespace nlohmann
11511  {
11512  namespace detail
11513  {
11514  enum class error_handler_t
11515  {
11516      strict,  
11517      replace, 
11518      ignore   
11519  };
11520  template<typename BasicJsonType>
11521  class serializer
11522  {
11523      using string_t = typename BasicJsonType::string_t;
11524      using number_float_t = typename BasicJsonType::number_float_t;
11525      using number_integer_t = typename BasicJsonType::number_integer_t;
11526      using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
11527      using binary_char_t = typename BasicJsonType::binary_t::value_type;
11528      static constexpr std::uint8_t UTF8_ACCEPT = 0;
11529      static constexpr std::uint8_t UTF8_REJECT = 1;
11530    public:
11531      serializer(output_adapter_t<char> s, const char ichar,
11532                 error_handler_t error_handler_ = error_handler_t::strict)
11533          : o(std::move(s))
11534          , loc(std::localeconv())
11535          , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
11536          , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
11537          , indent_char(ichar)
11538          , indent_string(512, indent_char)
11539          , error_handler(error_handler_)
11540      {}
11541      serializer(const serializer&) = delete;
11542      serializer& operator=(const serializer&) = delete;
11543      serializer(serializer&&) = delete;
11544      serializer& operator=(serializer&&) = delete;
11545      ~serializer() = default;
11546      void dump(const BasicJsonType& val,
11547                const bool pretty_print,
11548                const bool ensure_ascii,
11549                const unsigned int indent_step,
11550                const unsigned int current_indent = 0)
11551      {
11552          switch (val.m_type)
11553          {
11554              case value_t::object:
11555              {
11556                  if (val.m_value.object->empty())
11557                  {
11558                      o->write_characters("{}", 2);
11559                      return;
11560                  }
11561                  if (pretty_print)
11562                  {
11563                      o->write_characters("{\n", 2);
11564                      const auto new_indent = current_indent + indent_step;
11565                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
11566                      {
11567                          indent_string.resize(indent_string.size() * 2, ' ');
11568                      }
11569                      auto i = val.m_value.object->cbegin();
11570                      for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
11571                      {
11572                          o->write_characters(indent_string.c_str(), new_indent);
11573                          o->write_character('\"');
11574                          dump_escaped(i->first, ensure_ascii);
11575                          o->write_characters("\": ", 3);
11576                          dump(i->second, true, ensure_ascii, indent_step, new_indent);
11577                          o->write_characters(",\n", 2);
11578                      }
11579                      JSON_ASSERT(i != val.m_value.object->cend());
11580                      JSON_ASSERT(std::next(i) == val.m_value.object->cend());
11581                      o->write_characters(indent_string.c_str(), new_indent);
11582                      o->write_character('\"');
11583                      dump_escaped(i->first, ensure_ascii);
11584                      o->write_characters("\": ", 3);
11585                      dump(i->second, true, ensure_ascii, indent_step, new_indent);
11586                      o->write_character('\n');
11587                      o->write_characters(indent_string.c_str(), current_indent);
11588                      o->write_character('}');
11589                  }
11590                  else
11591                  {
11592                      o->write_character('{');
11593                      auto i = val.m_value.object->cbegin();
11594                      for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
11595                      {
11596                          o->write_character('\"');
11597                          dump_escaped(i->first, ensure_ascii);
11598                          o->write_characters("\":", 2);
11599                          dump(i->second, false, ensure_ascii, indent_step, current_indent);
11600                          o->write_character(',');
11601                      }
11602                      JSON_ASSERT(i != val.m_value.object->cend());
11603                      JSON_ASSERT(std::next(i) == val.m_value.object->cend());
11604                      o->write_character('\"');
11605                      dump_escaped(i->first, ensure_ascii);
11606                      o->write_characters("\":", 2);
11607                      dump(i->second, false, ensure_ascii, indent_step, current_indent);
11608                      o->write_character('}');
11609                  }
11610                  return;
11611              }
11612              case value_t::array:
11613              {
11614                  if (val.m_value.array->empty())
11615                  {
11616                      o->write_characters("[]", 2);
11617                      return;
11618                  }
11619                  if (pretty_print)
11620                  {
11621                      o->write_characters("[\n", 2);
11622                      const auto new_indent = current_indent + indent_step;
11623                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
11624                      {
11625                          indent_string.resize(indent_string.size() * 2, ' ');
11626                      }
11627                      for (auto i = val.m_value.array->cbegin();
11628                              i != val.m_value.array->cend() - 1; ++i)
11629                      {
11630                          o->write_characters(indent_string.c_str(), new_indent);
11631                          dump(*i, true, ensure_ascii, indent_step, new_indent);
11632                          o->write_characters(",\n", 2);
11633                      }
11634                      JSON_ASSERT(!val.m_value.array->empty());
11635                      o->write_characters(indent_string.c_str(), new_indent);
11636                      dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);
11637                      o->write_character('\n');
11638                      o->write_characters(indent_string.c_str(), current_indent);
11639                      o->write_character(']');
11640                  }
11641                  else
11642                  {
11643                      o->write_character('[');
11644                      for (auto i = val.m_value.array->cbegin();
11645                              i != val.m_value.array->cend() - 1; ++i)
11646                      {
11647                          dump(*i, false, ensure_ascii, indent_step, current_indent);
11648                          o->write_character(',');
11649                      }
11650                      JSON_ASSERT(!val.m_value.array->empty());
11651                      dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);
11652                      o->write_character(']');
11653                  }
11654                  return;
11655              }
11656              case value_t::string:
11657              {
11658                  o->write_character('\"');
11659                  dump_escaped(*val.m_value.string, ensure_ascii);
11660                  o->write_character('\"');
11661                  return;
11662              }
11663              case value_t::binary:
11664              {
11665                  if (pretty_print)
11666                  {
11667                      o->write_characters("{\n", 2);
11668                      const auto new_indent = current_indent + indent_step;
11669                      if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
11670                      {
11671                          indent_string.resize(indent_string.size() * 2, ' ');
11672                      }
11673                      o->write_characters(indent_string.c_str(), new_indent);
11674                      o->write_characters("\"bytes\": [", 10);
11675                      if (!val.m_value.binary->empty())
11676                      {
11677                          for (auto i = val.m_value.binary->cbegin();
11678                                  i != val.m_value.binary->cend() - 1; ++i)
11679                          {
11680                              dump_integer(*i);
11681                              o->write_characters(", ", 2);
11682                          }
11683                          dump_integer(val.m_value.binary->back());
11684                      }
11685                      o->write_characters("],\n", 3);
11686                      o->write_characters(indent_string.c_str(), new_indent);
11687                      o->write_characters("\"subtype\": ", 11);
11688                      if (val.m_value.binary->has_subtype())
11689                      {
11690                          dump_integer(val.m_value.binary->subtype());
11691                      }
11692                      else
11693                      {
11694                          o->write_characters("null", 4);
11695                      }
11696                      o->write_character('\n');
11697                      o->write_characters(indent_string.c_str(), current_indent);
11698                      o->write_character('}');
11699                  }
11700                  else
11701                  {
11702                      o->write_characters("{\"bytes\":[", 10);
11703                      if (!val.m_value.binary->empty())
11704                      {
11705                          for (auto i = val.m_value.binary->cbegin();
11706                                  i != val.m_value.binary->cend() - 1; ++i)
11707                          {
11708                              dump_integer(*i);
11709                              o->write_character(',');
11710                          }
11711                          dump_integer(val.m_value.binary->back());
11712                      }
11713                      o->write_characters("],\"subtype\":", 12);
11714                      if (val.m_value.binary->has_subtype())
11715                      {
11716                          dump_integer(val.m_value.binary->subtype());
11717                          o->write_character('}');
11718                      }
11719                      else
11720                      {
11721                          o->write_characters("null}", 5);
11722                      }
11723                  }
11724                  return;
11725              }
11726              case value_t::boolean:
11727              {
11728                  if (val.m_value.boolean)
11729                  {
11730                      o->write_characters("true", 4);
11731                  }
11732                  else
11733                  {
11734                      o->write_characters("false", 5);
11735                  }
11736                  return;
11737              }
11738              case value_t::number_integer:
11739              {
11740                  dump_integer(val.m_value.number_integer);
11741                  return;
11742              }
11743              case value_t::number_unsigned:
11744              {
11745                  dump_integer(val.m_value.number_unsigned);
11746                  return;
11747              }
11748              case value_t::number_float:
11749              {
11750                  dump_float(val.m_value.number_float);
11751                  return;
11752              }
11753              case value_t::discarded:
11754              {
11755                  o->write_characters("<discarded>", 11);
11756                  return;
11757              }
11758              case value_t::null:
11759              {
11760                  o->write_characters("null", 4);
11761                  return;
11762              }
11763              default:            
11764                  JSON_ASSERT(false); 
11765          }
11766      }
11767    JSON_PRIVATE_UNLESS_TESTED:
11768      void dump_escaped(const string_t& s, const bool ensure_ascii)
11769      {
11770          std::uint32_t codepoint{};
11771          std::uint8_t state = UTF8_ACCEPT;
11772          std::size_t bytes = 0;  
11773          std::size_t bytes_after_last_accept = 0;
11774          std::size_t undumped_chars = 0;
11775          for (std::size_t i = 0; i < s.size(); ++i)
11776          {
11777              const auto byte = static_cast<std::uint8_t>(s[i]);
11778              switch (decode(state, codepoint, byte))
11779              {
11780                  case UTF8_ACCEPT:  
11781                  {
11782                      switch (codepoint)
11783                      {
11784                          case 0x08: 
11785                          {
11786                              string_buffer[bytes++] = '\\';
11787                              string_buffer[bytes++] = 'b';
11788                              break;
11789                          }
11790                          case 0x09: 
11791                          {
11792                              string_buffer[bytes++] = '\\';
11793                              string_buffer[bytes++] = 't';
11794                              break;
11795                          }
11796                          case 0x0A: 
11797                          {
11798                              string_buffer[bytes++] = '\\';
11799                              string_buffer[bytes++] = 'n';
11800                              break;
11801                          }
11802                          case 0x0C: 
11803                          {
11804                              string_buffer[bytes++] = '\\';
11805                              string_buffer[bytes++] = 'f';
11806                              break;
11807                          }
11808                          case 0x0D: 
11809                          {
11810                              string_buffer[bytes++] = '\\';
11811                              string_buffer[bytes++] = 'r';
11812                              break;
11813                          }
11814                          case 0x22: 
11815                          {
11816                              string_buffer[bytes++] = '\\';
11817                              string_buffer[bytes++] = '\"';
11818                              break;
11819                          }
11820                          case 0x5C: 
11821                          {
11822                              string_buffer[bytes++] = '\\';
11823                              string_buffer[bytes++] = '\\';
11824                              break;
11825                          }
11826                          default:
11827                          {
11828                              if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
11829                              {
11830                                  if (codepoint <= 0xFFFF)
11831                                  {
11832                                      (std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
11833                                                      static_cast<std::uint16_t>(codepoint));
11834                                      bytes += 6;
11835                                  }
11836                                  else
11837                                  {
11838                                      (std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
11839                                                      static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
11840                                                      static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu)));
11841                                      bytes += 12;
11842                                  }
11843                              }
11844                              else
11845                              {
11846                                  string_buffer[bytes++] = s[i];
11847                              }
11848                              break;
11849                          }
11850                      }
11851                      if (string_buffer.size() - bytes < 13)
11852                      {
11853                          o->write_characters(string_buffer.data(), bytes);
11854                          bytes = 0;
11855                      }
11856                      bytes_after_last_accept = bytes;
11857                      undumped_chars = 0;
11858                      break;
11859                  }
11860                  case UTF8_REJECT:  
11861                  {
11862                      switch (error_handler)
11863                      {
11864                          case error_handler_t::strict:
11865                          {
11866                              std::string sn(9, '\0');
11867                              (std::snprintf)(&sn[0], sn.size(), "%.2X", byte);
11868                              JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn, BasicJsonType()));
11869                          }
11870                          case error_handler_t::ignore:
11871                          case error_handler_t::replace:
11872                          {
11873                              if (undumped_chars > 0)
11874                              {
11875                                  --i;
11876                              }
11877                              bytes = bytes_after_last_accept;
11878                              if (error_handler == error_handler_t::replace)
11879                              {
11880                                  if (ensure_ascii)
11881                                  {
11882                                      string_buffer[bytes++] = '\\';
11883                                      string_buffer[bytes++] = 'u';
11884                                      string_buffer[bytes++] = 'f';
11885                                      string_buffer[bytes++] = 'f';
11886                                      string_buffer[bytes++] = 'f';
11887                                      string_buffer[bytes++] = 'd';
11888                                  }
11889                                  else
11890                                  {
11891                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
11892                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
11893                                      string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
11894                                  }
11895                                  if (string_buffer.size() - bytes < 13)
11896                                  {
11897                                      o->write_characters(string_buffer.data(), bytes);
11898                                      bytes = 0;
11899                                  }
11900                                  bytes_after_last_accept = bytes;
11901                              }
11902                              undumped_chars = 0;
11903                              state = UTF8_ACCEPT;
11904                              break;
11905                          }
11906                          default:            
11907                              JSON_ASSERT(false); 
11908                      }
11909                      break;
11910                  }
11911                  default:  
11912                  {
11913                      if (!ensure_ascii)
11914                      {
11915                          string_buffer[bytes++] = s[i];
11916                      }
11917                      ++undumped_chars;
11918                      break;
11919                  }
11920              }
11921          }
11922          if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
11923          {
11924              if (bytes > 0)
11925              {
11926                  o->write_characters(string_buffer.data(), bytes);
11927              }
11928          }
11929          else
11930          {
11931              switch (error_handler)
11932              {
11933                  case error_handler_t::strict:
11934                  {
11935                      std::string sn(9, '\0');
11936                      (std::snprintf)(&sn[0], sn.size(), "%.2X", static_cast<std::uint8_t>(s.back()));
11937                      JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn, BasicJsonType()));
11938                  }
11939                  case error_handler_t::ignore:
11940                  {
11941                      o->write_characters(string_buffer.data(), bytes_after_last_accept);
11942                      break;
11943                  }
11944                  case error_handler_t::replace:
11945                  {
11946                      o->write_characters(string_buffer.data(), bytes_after_last_accept);
11947                      if (ensure_ascii)
11948                      {
11949                          o->write_characters("\\ufffd", 6);
11950                      }
11951                      else
11952                      {
11953                          o->write_characters("\xEF\xBF\xBD", 3);
11954                      }
11955                      break;
11956                  }
11957                  default:            
11958                      JSON_ASSERT(false); 
11959              }
11960          }
11961      }
11962    private:
11963      inline unsigned int count_digits(number_unsigned_t x) noexcept
11964      {
11965          unsigned int n_digits = 1;
11966          for (;;)
11967          {
11968              if (x < 10)
11969              {
11970                  return n_digits;
11971              }
11972              if (x < 100)
11973              {
11974                  return n_digits + 1;
11975              }
11976              if (x < 1000)
11977              {
11978                  return n_digits + 2;
11979              }
11980              if (x < 10000)
11981              {
11982                  return n_digits + 3;
11983              }
11984              x = x / 10000u;
11985              n_digits += 4;
11986          }
11987      }
11988      template < typename NumberType, detail::enable_if_t <
11989                     std::is_integral<NumberType>::value ||
11990                     std::is_same<NumberType, number_unsigned_t>::value ||
11991                     std::is_same<NumberType, number_integer_t>::value ||
11992                     std::is_same<NumberType, binary_char_t>::value,
11993                     int > = 0 >
11994      void dump_integer(NumberType x)
11995      {
11996          static constexpr std::array<std::array<char, 2>, 100> digits_to_99
11997          {
11998              {
11999                  {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
12000                  {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
12001                  {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
12002                  {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
12003                  {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
12004                  {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
12005                  {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
12006                  {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
12007                  {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
12008                  {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
12009              }
12010          };
12011          if (x == 0)
12012          {
12013              o->write_character('0');
12014              return;
12015          }
12016          auto buffer_ptr = number_buffer.begin(); 
12017          const bool is_negative = std::is_signed<NumberType>::value && !(x >= 0); 
12018          number_unsigned_t abs_value;
12019          unsigned int n_chars{};
12020          if (is_negative)
12021          {
12022              *buffer_ptr = '-';
12023              abs_value = remove_sign(static_cast<number_integer_t>(x));
12024              n_chars = 1 + count_digits(abs_value);
12025          }
12026          else
12027          {
12028              abs_value = static_cast<number_unsigned_t>(x);
12029              n_chars = count_digits(abs_value);
12030          }
12031          JSON_ASSERT(n_chars < number_buffer.size() - 1);
12032          buffer_ptr += n_chars;
12033          while (abs_value >= 100)
12034          {
12035              const auto digits_index = static_cast<unsigned>((abs_value % 100));
12036              abs_value /= 100;
12037              *(--buffer_ptr) = digits_to_99[digits_index][1];
12038              *(--buffer_ptr) = digits_to_99[digits_index][0];
12039          }
12040          if (abs_value >= 10)
12041          {
12042              const auto digits_index = static_cast<unsigned>(abs_value);
12043              *(--buffer_ptr) = digits_to_99[digits_index][1];
12044              *(--buffer_ptr) = digits_to_99[digits_index][0];
12045          }
12046          else
12047          {
12048              *(--buffer_ptr) = static_cast<char>('0' + abs_value);
12049          }
12050          o->write_characters(number_buffer.data(), n_chars);
12051      }
12052      void dump_float(number_float_t x)
12053      {
12054          if (!std::isfinite(x))
12055          {
12056              o->write_characters("null", 4);
12057              return;
12058          }
12059          static constexpr bool is_ieee_single_or_double
12060              = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
12061                (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);
12062          dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
12063      }
12064      void dump_float(number_float_t x, std::true_type &bsol;*is_ieee_single_or_double*/)
12065      {
12066          auto* begin = number_buffer.data();
12067          auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);
12068          o->write_characters(begin, static_cast<size_t>(end - begin));
12069      }
12070      void dump_float(number_float_t x, std::false_type &bsol;*is_ieee_single_or_double*/)
12071      {
12072          static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;
12073          std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);
12074          JSON_ASSERT(len > 0);
12075          JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());
12076          if (thousands_sep != '\0')
12077          {
12078              auto* const end = std::remove(number_buffer.begin(),
12079                                            number_buffer.begin() + len, thousands_sep);
12080              std::fill(end, number_buffer.end(), '\0');
12081              JSON_ASSERT((end - number_buffer.begin()) <= len);
12082              len = (end - number_buffer.begin());
12083          }
12084          if (decimal_point != '\0' && decimal_point != '.')
12085          {
12086              auto* const dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
12087              if (dec_pos != number_buffer.end())
12088              {
12089                  *dec_pos = '.';
12090              }
12091          }
12092          o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));
12093          const bool value_is_int_like =
12094              std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
12095                           [](char c)
12096          {
12097              return c == '.' || c == 'e';
12098          });
12099          if (value_is_int_like)
12100          {
12101              o->write_characters(".0", 2);
12102          }
12103      }
12104      static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
12105      {
12106          static const std::array<std::uint8_t, 400> utf8d =
12107          {
12108              {
12109                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12110                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12111                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12112                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
12113                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
12114                  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
12115                  8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
12116                  0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, 
12117                  0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 
12118                  0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, 
12119                  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 
12120                  1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 
12121                  1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 
12122                  1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 
12123              }
12124          };
12125          JSON_ASSERT(byte < utf8d.size());
12126          const std::uint8_t type = utf8d[byte];
12127          codep = (state != UTF8_ACCEPT)
12128                  ? (byte & 0x3fu) | (codep << 6u)
12129                  : (0xFFu >> type) & (byte);
12130          std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
12131          JSON_ASSERT(index < 400);
12132          state = utf8d[index];
12133          return state;
12134      }
12135      number_unsigned_t remove_sign(number_unsigned_t x)
12136      {
12137          JSON_ASSERT(false); 
12138          return x; 
12139      }
12140      inline number_unsigned_t remove_sign(number_integer_t x) noexcept
12141      {
12142          JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); 
12143          return static_cast<number_unsigned_t>(-(x + 1)) + 1;
12144      }
12145    private:
12146      output_adapter_t<char> o = nullptr;
12147      std::array<char, 64> number_buffer{{}};
12148      const std::lconv* loc = nullptr;
12149      const char thousands_sep = '\0';
12150      const char decimal_point = '\0';
12151      std::array<char, 512> string_buffer{{}};
12152      const char indent_char;
12153      string_t indent_string;
12154      const error_handler_t error_handler;
12155  };
12156  }  
12157  }  
12158  #include <functional> 
12159  #include <initializer_list> 
12160  #include <iterator> 
12161  #include <memory> 
12162  #include <stdexcept> 
12163  #include <type_traits> 
12164  #include <utility> 
12165  #include <vector> 
12166  namespace nlohmann
12167  {
12168  template <class Key, class T, class IgnoredLess = std::less<Key>,
12169            class Allocator = std::allocator<std::pair<const Key, T>>>
12170                    struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
12171  {
12172      using key_type = Key;
12173      using mapped_type = T;
12174      using Container = std::vector<std::pair<const Key, T>, Allocator>;
12175      using typename Container::iterator;
12176      using typename Container::const_iterator;
12177      using typename Container::size_type;
12178      using typename Container::value_type;
12179      ordered_map(const Allocator& alloc = Allocator()) : Container{alloc} {}
12180      template <class It>
12181      ordered_map(It first, It last, const Allocator& alloc = Allocator())
12182          : Container{first, last, alloc} {}
12183      ordered_map(std::initializer_list<T> init, const Allocator& alloc = Allocator() )
12184          : Container{init, alloc} {}
12185      std::pair<iterator, bool> emplace(const key_type& key, T&& t)
12186      {
12187          for (auto it = this->begin(); it != this->end(); ++it)
12188          {
12189              if (it->first == key)
12190              {
12191                  return {it, false};
12192              }
12193          }
12194          Container::emplace_back(key, t);
12195          return {--this->end(), true};
12196      }
12197      T& operator[](const Key& key)
12198      {
12199          return emplace(key, T{}).first->second;
12200      }
12201      const T& operator[](const Key& key) const
12202      {
12203          return at(key);
12204      }
12205      T& at(const Key& key)
12206      {
12207          for (auto it = this->begin(); it != this->end(); ++it)
12208          {
12209              if (it->first == key)
12210              {
12211                  return it->second;
12212              }
12213          }
12214          JSON_THROW(std::out_of_range("key not found"));
12215      }
12216      const T& at(const Key& key) const
12217      {
12218          for (auto it = this->begin(); it != this->end(); ++it)
12219          {
12220              if (it->first == key)
12221              {
12222                  return it->second;
12223              }
12224          }
12225          JSON_THROW(std::out_of_range("key not found"));
12226      }
12227      size_type erase(const Key& key)
12228      {
12229          for (auto it = this->begin(); it != this->end(); ++it)
12230          {
12231              if (it->first == key)
12232              {
12233                  for (auto next = it; ++next != this->end(); ++it)
12234                  {
12235                      it->~value_type(); 
12236                      new (&*it) value_type{std::move(*next)};
12237                  }
12238                  Container::pop_back();
12239                  return 1;
12240              }
12241          }
12242          return 0;
12243      }
12244      iterator erase(iterator pos)
12245      {
12246          auto it = pos;
12247          for (auto next = it; ++next != this->end(); ++it)
12248          {
12249              it->~value_type(); 
12250              new (&*it) value_type{std::move(*next)};
12251          }
12252          Container::pop_back();
12253          return pos;
12254      }
12255      size_type count(const Key& key) const
12256      {
12257          for (auto it = this->begin(); it != this->end(); ++it)
12258          {
12259              if (it->first == key)
12260              {
12261                  return 1;
12262              }
12263          }
12264          return 0;
12265      }
12266      iterator find(const Key& key)
12267      {
12268          for (auto it = this->begin(); it != this->end(); ++it)
12269          {
12270              if (it->first == key)
12271              {
12272                  return it;
12273              }
12274          }
12275          return Container::end();
12276      }
12277      const_iterator find(const Key& key) const
12278      {
12279          for (auto it = this->begin(); it != this->end(); ++it)
12280          {
12281              if (it->first == key)
12282              {
12283                  return it;
12284              }
12285          }
12286          return Container::end();
12287      }
12288      std::pair<iterator, bool> insert( value_type&& value )
12289      {
12290          return emplace(value.first, std::move(value.second));
12291      }
12292      std::pair<iterator, bool> insert( const value_type& value )
12293      {
12294          for (auto it = this->begin(); it != this->end(); ++it)
12295          {
12296              if (it->first == value.first)
12297              {
12298                  return {it, false};
12299              }
12300          }
12301          Container::push_back(value);
12302          return {--this->end(), true};
12303      }
12304      template<typename InputIt>
12305      using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
12306              std::input_iterator_tag>::value>::type;
12307      template<typename InputIt, typename = require_input_iter<InputIt>>
12308      void insert(InputIt first, InputIt last)
12309      {
12310          for (auto it = first; it != last; ++it)
12311          {
12312              insert(*it);
12313          }
12314      }
12315  };
12316  }  
12317  #if defined(JSON_HAS_CPP_17)
12318      #include <string_view>
12319  #endif
12320  namespace nlohmann
12321  {
12322  NLOHMANN_BASIC_JSON_TPL_DECLARATION
12323  class basic_json 
12324  {
12325    private:
12326      template<detail::value_t> friend struct detail::external_constructor;
12327      friend ::nlohmann::json_pointer<basic_json>;
12328      template<typename BasicJsonType, typename InputType>
12329      friend class ::nlohmann::detail::parser;
12330      friend ::nlohmann::detail::serializer<basic_json>;
12331      template<typename BasicJsonType>
12332      friend class ::nlohmann::detail::iter_impl;
12333      template<typename BasicJsonType, typename CharType>
12334      friend class ::nlohmann::detail::binary_writer;
12335      template<typename BasicJsonType, typename InputType, typename SAX>
12336      friend class ::nlohmann::detail::binary_reader;
12337      template<typename BasicJsonType>
12338      friend class ::nlohmann::detail::json_sax_dom_parser;
12339      template<typename BasicJsonType>
12340      friend class ::nlohmann::detail::json_sax_dom_callback_parser;
12341      friend class ::nlohmann::detail::exception;
12342      using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
12343    JSON_PRIVATE_UNLESS_TESTED:
12344      using lexer = ::nlohmann::detail::lexer_base<basic_json>;
12345      template<typename InputAdapterType>
12346      static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
12347          InputAdapterType adapter,
12348          detail::parser_callback_t<basic_json>cb = nullptr,
12349          const bool allow_exceptions = true,
12350          const bool ignore_comments = false
12351                                   )
12352      {
12353          return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
12354                  std::move(cb), allow_exceptions, ignore_comments);
12355      }
12356    private:
12357      using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
12358      template<typename BasicJsonType>
12359      using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
12360      template<typename BasicJsonType>
12361      using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
12362      template<typename Iterator>
12363      using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
12364      template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;
12365      template<typename CharType>
12366      using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;
12367      template<typename InputType>
12368      using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
12369      template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;
12370    JSON_PRIVATE_UNLESS_TESTED:
12371      using serializer = ::nlohmann::detail::serializer<basic_json>;
12372    public:
12373      using value_t = detail::value_t;
12374      using json_pointer = ::nlohmann::json_pointer<basic_json>;
12375      template<typename T, typename SFINAE>
12376      using json_serializer = JSONSerializer<T, SFINAE>;
12377      using error_handler_t = detail::error_handler_t;
12378      using cbor_tag_handler_t = detail::cbor_tag_handler_t;
12379      using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;
12380      using input_format_t = detail::input_format_t;
12381      using json_sax_t = json_sax<basic_json>;
12382      using exception = detail::exception;
12383      using parse_error = detail::parse_error;
12384      using invalid_iterator = detail::invalid_iterator;
12385      using type_error = detail::type_error;
12386      using out_of_range = detail::out_of_range;
12387      using other_error = detail::other_error;
12388      using value_type = basic_json;
12389      using reference = value_type&;
12390      using const_reference = const value_type&;
12391      using difference_type = std::ptrdiff_t;
12392      using size_type = std::size_t;
12393      using allocator_type = AllocatorType<basic_json>;
12394      using pointer = typename std::allocator_traits<allocator_type>::pointer;
12395      using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;
12396      using iterator = iter_impl<basic_json>;
12397      using const_iterator = iter_impl<const basic_json>;
12398      using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
12399      using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;
12400      static allocator_type get_allocator()
12401      {
12402          return allocator_type();
12403      }
12404      JSON_HEDLEY_WARN_UNUSED_RESULT
12405      static basic_json meta()
12406      {
12407          basic_json result;
<span onclick='openModal()' class='match'>12408          result["copyright"] = "(C) 2013-2021 Niels Lohmann";
12409          result["name"] = "JSON for Modern C++";
12410          result["url"] = "https:&bsol;&bsol;github.com/nlohmann/json";
12411          result["version"]["string"] =
12412              std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
12413              std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
12414              std::to_string(NLOHMANN_JSON_VERSION_PATCH);
12415          result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
12416          result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
12417          result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;
12418  #ifdef _WIN32
12419          result["platform"] = "win32";
12420  #elif defined __linux__
12421          result["platform"] = "linux";
12422  #elif defined __APPLE__
12423          result["platform"] = "apple";
12424  #elif defined __unix__
12425          result["platform"] = "unix";
12426  #else
12427          result["platform"] = "unknown";
12428  #endif
12429  #if defined(__ICC) || defined(__INTEL_COMPILER)
12430          result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
</span>12431  #elif defined(__clang__)
12432          result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
12433  #elif defined(__GNUC__) || defined(__GNUG__)
12434          result["compiler"] = {{"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)}};
12435  #elif defined(__HP_cc) || defined(__HP_aCC)
12436          result["compiler"] = "hp"
12437  #elif defined(__IBMCPP__)
12438          result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
12439  #elif defined(_MSC_VER)
12440          result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
12441  #elif defined(__PGI)
12442          result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
12443  #elif defined(__SUNPRO_CC)
12444          result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
12445  #else
12446          result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
12447  #endif
12448  #ifdef __cplusplus
12449          result["compiler"]["c++"] = std::to_string(__cplusplus);
12450  #else
12451          result["compiler"]["c++"] = "unknown";
12452  #endif
12453          return result;
12454      }
12455  #if defined(JSON_HAS_CPP_14)
12456      using object_comparator_t = std::less<>;
12457  #else
12458      using object_comparator_t = std::less<StringType>;
12459  #endif
12460      using object_t = ObjectType<StringType,
12461            basic_json,
12462            object_comparator_t,
12463            AllocatorType<std::pair<const StringType,
12464            basic_json>>>;
12465      using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
12466      using string_t = StringType;
12467      using boolean_t = BooleanType;
12468      using number_integer_t = NumberIntegerType;
12469      using number_unsigned_t = NumberUnsignedType;
12470      using number_float_t = NumberFloatType;
12471      using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
12472    private:
12473      template<typename T, typename... Args>
12474      JSON_HEDLEY_RETURNS_NON_NULL
12475      static T* create(Args&& ... args)
12476      {
12477          AllocatorType<T> alloc;
12478          using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;
12479          auto deleter = [&](T * obj)
12480          {
12481              AllocatorTraits::deallocate(alloc, obj, 1);
12482          };
12483          std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
12484          AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
12485          JSON_ASSERT(obj != nullptr);
12486          return obj.release();
12487      }
12488    JSON_PRIVATE_UNLESS_TESTED:
12489      union json_value
12490      {
12491          object_t* object;
12492          array_t* array;
12493          string_t* string;
12494          binary_t* binary;
12495          boolean_t boolean;
12496          number_integer_t number_integer;
12497          number_unsigned_t number_unsigned;
12498          number_float_t number_float;
12499          json_value() = default;
12500          json_value(boolean_t v) noexcept : boolean(v) {}
12501          json_value(number_integer_t v) noexcept : number_integer(v) {}
12502          json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
12503          json_value(number_float_t v) noexcept : number_float(v) {}
12504          json_value(value_t t)
12505          {
12506              switch (t)
12507              {
12508                  case value_t::object:
12509                  {
12510                      object = create<object_t>();
12511                      break;
12512                  }
12513                  case value_t::array:
12514                  {
12515                      array = create<array_t>();
12516                      break;
12517                  }
12518                  case value_t::string:
12519                  {
12520                      string = create<string_t>("");
12521                      break;
12522                  }
12523                  case value_t::binary:
12524                  {
12525                      binary = create<binary_t>();
12526                      break;
12527                  }
12528                  case value_t::boolean:
12529                  {
12530                      boolean = boolean_t(false);
12531                      break;
12532                  }
12533                  case value_t::number_integer:
12534                  {
12535                      number_integer = number_integer_t(0);
12536                      break;
12537                  }
12538                  case value_t::number_unsigned:
12539                  {
12540                      number_unsigned = number_unsigned_t(0);
12541                      break;
12542                  }
12543                  case value_t::number_float:
12544                  {
12545                      number_float = number_float_t(0.0);
12546                      break;
12547                  }
12548                  case value_t::null:
12549                  {
12550                      object = nullptr;  
12551                      break;
12552                  }
12553                  case value_t::discarded:
12554                  default:
12555                  {
12556                      object = nullptr;  
12557                      if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
12558                      {
12559                          JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.10.2", basic_json())); 
12560                      }
12561                      break;
12562                  }
12563              }
12564          }
12565          json_value(const string_t& value)
12566          {
12567              string = create<string_t>(value);
12568          }
12569          json_value(string_t&& value)
12570          {
12571              string = create<string_t>(std::move(value));
12572          }
12573          json_value(const object_t& value)
12574          {
12575              object = create<object_t>(value);
12576          }
12577          json_value(object_t&& value)
12578          {
12579              object = create<object_t>(std::move(value));
12580          }
12581          json_value(const array_t& value)
12582          {
12583              array = create<array_t>(value);
12584          }
12585          json_value(array_t&& value)
12586          {
12587              array = create<array_t>(std::move(value));
12588          }
12589          json_value(const typename binary_t::container_type& value)
12590          {
12591              binary = create<binary_t>(value);
12592          }
12593          json_value(typename binary_t::container_type&& value)
12594          {
12595              binary = create<binary_t>(std::move(value));
12596          }
12597          json_value(const binary_t& value)
12598          {
12599              binary = create<binary_t>(value);
12600          }
12601          json_value(binary_t&& value)
12602          {
12603              binary = create<binary_t>(std::move(value));
12604          }
12605          void destroy(value_t t)
12606          {
12607              if (t == value_t::array || t == value_t::object)
12608              {
12609                  std::vector<basic_json> stack;
12610                  if (t == value_t::array)
12611                  {
12612                      stack.reserve(array->size());
12613                      std::move(array->begin(), array->end(), std::back_inserter(stack));
12614                  }
12615                  else
12616                  {
12617                      stack.reserve(object->size());
12618                      for (auto&& it : *object)
12619                      {
12620                          stack.push_back(std::move(it.second));
12621                      }
12622                  }
12623                  while (!stack.empty())
12624                  {
12625                      basic_json current_item(std::move(stack.back()));
12626                      stack.pop_back();
12627                      if (current_item.is_array())
12628                      {
12629                          std::move(current_item.m_value.array->begin(), current_item.m_value.array->end(), std::back_inserter(stack));
12630                          current_item.m_value.array->clear();
12631                      }
12632                      else if (current_item.is_object())
12633                      {
12634                          for (auto&& it : *current_item.m_value.object)
12635                          {
12636                              stack.push_back(std::move(it.second));
12637                          }
12638                          current_item.m_value.object->clear();
12639                      }
12640                  }
12641              }
12642              switch (t)
12643              {
12644                  case value_t::object:
12645                  {
12646                      AllocatorType<object_t> alloc;
12647                      std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
12648                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
12649                      break;
12650                  }
12651                  case value_t::array:
12652                  {
12653                      AllocatorType<array_t> alloc;
12654                      std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
12655                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
12656                      break;
12657                  }
12658                  case value_t::string:
12659                  {
12660                      AllocatorType<string_t> alloc;
12661                      std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
12662                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
12663                      break;
12664                  }
12665                  case value_t::binary:
12666                  {
12667                      AllocatorType<binary_t> alloc;
12668                      std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
12669                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
12670                      break;
12671                  }
12672                  case value_t::null:
12673                  case value_t::boolean:
12674                  case value_t::number_integer:
12675                  case value_t::number_unsigned:
12676                  case value_t::number_float:
12677                  case value_t::discarded:
12678                  default:
12679                  {
12680                      break;
12681                  }
12682              }
12683          }
12684      };
12685    private:
12686      void assert_invariant(bool check_parents = true) const noexcept
12687      {
12688          JSON_ASSERT(m_type != value_t::object || m_value.object != nullptr);
12689          JSON_ASSERT(m_type != value_t::array || m_value.array != nullptr);
12690          JSON_ASSERT(m_type != value_t::string || m_value.string != nullptr);
12691          JSON_ASSERT(m_type != value_t::binary || m_value.binary != nullptr);
12692  #if JSON_DIAGNOSTICS
12693          JSON_TRY
12694          {
12695              JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
12696              {
12697                  return j.m_parent == this;
12698              }));
12699          }
12700          JSON_CATCH(...) {} 
12701  #endif
12702          static_cast<void>(check_parents);
12703      }
12704      void set_parents()
12705      {
12706  #if JSON_DIAGNOSTICS
12707          switch (m_type)
12708          {
12709              case value_t::array:
12710              {
12711                  for (auto& element : *m_value.array)
12712                  {
12713                      element.m_parent = this;
12714                  }
12715                  break;
12716              }
12717              case value_t::object:
12718              {
12719                  for (auto& element : *m_value.object)
12720                  {
12721                      element.second.m_parent = this;
12722                  }
12723                  break;
12724              }
12725              case value_t::null:
12726              case value_t::string:
12727              case value_t::boolean:
12728              case value_t::number_integer:
12729              case value_t::number_unsigned:
12730              case value_t::number_float:
12731              case value_t::binary:
12732              case value_t::discarded:
12733              default:
12734                  break;
12735          }
12736  #endif
12737      }
12738      iterator set_parents(iterator it, typename iterator::difference_type count)
12739      {
12740  #if JSON_DIAGNOSTICS
12741          for (typename iterator::difference_type i = 0; i < count; ++i)
12742          {
12743              (it + i)->m_parent = this;
12744          }
12745  #else
12746          static_cast<void>(count);
12747  #endif
12748          return it;
12749      }
12750      reference set_parent(reference j, std::size_t old_capacity = std::size_t(-1))
12751      {
12752  #if JSON_DIAGNOSTICS
12753          if (old_capacity != std::size_t(-1))
12754          {
12755              JSON_ASSERT(type() == value_t::array);
12756              if (JSON_HEDLEY_UNLIKELY(m_value.array->capacity() != old_capacity))
12757              {
12758                  set_parents();
12759                  return j;
12760              }
12761          }
12762  #ifdef JSON_HEDLEY_MSVC_VERSION
12763  #pragma warning(push )
12764  #pragma warning(disable : 4127) 
12765  #endif
12766          if (detail::is_ordered_map<object_t>::value)
12767          {
12768              set_parents();
12769              return j;
12770          }
12771  #ifdef JSON_HEDLEY_MSVC_VERSION
12772  #pragma warning( pop )
12773  #endif
12774          j.m_parent = this;
12775  #else
12776          static_cast<void>(j);
12777          static_cast<void>(old_capacity);
12778  #endif
12779          return j;
12780      }
12781    public:
12782      using parse_event_t = detail::parse_event_t;
12783      using parser_callback_t = detail::parser_callback_t<basic_json>;
12784      basic_json(const value_t v)
12785          : m_type(v), m_value(v)
12786      {
12787          assert_invariant();
12788      }
12789      basic_json(std::nullptr_t = nullptr) noexcept
12790          : basic_json(value_t::null)
12791      {
12792          assert_invariant();
12793      }
12794      template < typename CompatibleType,
12795                 typename U = detail::uncvref_t<CompatibleType>,
12796                 detail::enable_if_t <
12797                     !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
12798      basic_json(CompatibleType && val) noexcept(noexcept( 
12799                  JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
12800                                             std::forward<CompatibleType>(val))))
12801      {
12802          JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
12803          set_parents();
12804          assert_invariant();
12805      }
12806      template < typename BasicJsonType,
12807                 detail::enable_if_t <
12808                     detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
12809      basic_json(const BasicJsonType& val)
12810      {
12811          using other_boolean_t = typename BasicJsonType::boolean_t;
12812          using other_number_float_t = typename BasicJsonType::number_float_t;
12813          using other_number_integer_t = typename BasicJsonType::number_integer_t;
12814          using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
12815          using other_string_t = typename BasicJsonType::string_t;
12816          using other_object_t = typename BasicJsonType::object_t;
12817          using other_array_t = typename BasicJsonType::array_t;
12818          using other_binary_t = typename BasicJsonType::binary_t;
12819          switch (val.type())
12820          {
12821              case value_t::boolean:
12822                  JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
12823                  break;
12824              case value_t::number_float:
12825                  JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
12826                  break;
12827              case value_t::number_integer:
12828                  JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
12829                  break;
12830              case value_t::number_unsigned:
12831                  JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
12832                  break;
12833              case value_t::string:
12834                  JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
12835                  break;
12836              case value_t::object:
12837                  JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
12838                  break;
12839              case value_t::array:
12840                  JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
12841                  break;
12842              case value_t::binary:
12843                  JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
12844                  break;
12845              case value_t::null:
12846                  *this = nullptr;
12847                  break;
12848              case value_t::discarded:
12849                  m_type = value_t::discarded;
12850                  break;
12851              default:            
12852                  JSON_ASSERT(false); 
12853          }
12854          set_parents();
12855          assert_invariant();
12856      }
12857      basic_json(initializer_list_t init,
12858                 bool type_deduction = true,
12859                 value_t manual_type = value_t::array)
12860      {
12861          bool is_an_object = std::all_of(init.begin(), init.end(),
12862                                          [](const detail::json_ref<basic_json>& element_ref)
12863          {
12864              return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[0].is_string();
12865          });
12866          if (!type_deduction)
12867          {
12868              if (manual_type == value_t::array)
12869              {
12870                  is_an_object = false;
12871              }
12872              if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
12873              {
12874                  JSON_THROW(type_error::create(301, "cannot create object from initializer list", basic_json()));
12875              }
12876          }
12877          if (is_an_object)
12878          {
12879              m_type = value_t::object;
12880              m_value = value_t::object;
12881              for (auto& element_ref : init)
12882              {
12883                  auto element = element_ref.moved_or_copied();
12884                  m_value.object->emplace(
12885                      std::move(*((*element.m_value.array)[0].m_value.string)),
12886                      std::move((*element.m_value.array)[1]));
12887              }
12888          }
12889          else
12890          {
12891              m_type = value_t::array;
12892              m_value.array = create<array_t>(init.begin(), init.end());
12893          }
12894          set_parents();
12895          assert_invariant();
12896      }
12897      JSON_HEDLEY_WARN_UNUSED_RESULT
12898      static basic_json binary(const typename binary_t::container_type& init)
12899      {
12900          auto res = basic_json();
12901          res.m_type = value_t::binary;
12902          res.m_value = init;
12903          return res;
12904      }
12905      JSON_HEDLEY_WARN_UNUSED_RESULT
12906      static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
12907      {
12908          auto res = basic_json();
12909          res.m_type = value_t::binary;
12910          res.m_value = binary_t(init, subtype);
12911          return res;
12912      }
12913      JSON_HEDLEY_WARN_UNUSED_RESULT
12914      static basic_json binary(typename binary_t::container_type&& init)
12915      {
12916          auto res = basic_json();
12917          res.m_type = value_t::binary;
12918          res.m_value = std::move(init);
12919          return res;
12920      }
12921      JSON_HEDLEY_WARN_UNUSED_RESULT
12922      static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
12923      {
12924          auto res = basic_json();
12925          res.m_type = value_t::binary;
12926          res.m_value = binary_t(std::move(init), subtype);
12927          return res;
12928      }
12929      JSON_HEDLEY_WARN_UNUSED_RESULT
12930      static basic_json array(initializer_list_t init = {})
12931      {
12932          return basic_json(init, false, value_t::array);
12933      }
12934      JSON_HEDLEY_WARN_UNUSED_RESULT
12935      static basic_json object(initializer_list_t init = {})
12936      {
12937          return basic_json(init, false, value_t::object);
12938      }
12939      basic_json(size_type cnt, const basic_json& val)
12940          : m_type(value_t::array)
12941      {
12942          m_value.array = create<array_t>(cnt, val);
12943          set_parents();
12944          assert_invariant();
12945      }
12946      template < class InputIT, typename std::enable_if <
12947                     std::is_same<InputIT, typename basic_json_t::iterator>::value ||
12948                     std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
12949      basic_json(InputIT first, InputIT last)
12950      {
12951          JSON_ASSERT(first.m_object != nullptr);
12952          JSON_ASSERT(last.m_object != nullptr);
12953          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
12954          {
12955              JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", basic_json()));
12956          }
12957          m_type = first.m_object->m_type;
12958          switch (m_type)
12959          {
12960              case value_t::boolean:
12961              case value_t::number_float:
12962              case value_t::number_integer:
12963              case value_t::number_unsigned:
12964              case value_t::string:
12965              {
12966                  if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
12967                                           || !last.m_it.primitive_iterator.is_end()))
12968                  {
12969                      JSON_THROW(invalid_iterator::create(204, "iterators out of range", *first.m_object));
12970                  }
12971                  break;
12972              }
12973              case value_t::null:
12974              case value_t::object:
12975              case value_t::array:
12976              case value_t::binary:
12977              case value_t::discarded:
12978              default:
12979                  break;
12980          }
12981          switch (m_type)
12982          {
12983              case value_t::number_integer:
12984              {
12985                  m_value.number_integer = first.m_object->m_value.number_integer;
12986                  break;
12987              }
12988              case value_t::number_unsigned:
12989              {
12990                  m_value.number_unsigned = first.m_object->m_value.number_unsigned;
12991                  break;
12992              }
12993              case value_t::number_float:
12994              {
12995                  m_value.number_float = first.m_object->m_value.number_float;
12996                  break;
12997              }
12998              case value_t::boolean:
12999              {
13000                  m_value.boolean = first.m_object->m_value.boolean;
13001                  break;
13002              }
13003              case value_t::string:
13004              {
13005                  m_value = *first.m_object->m_value.string;
13006                  break;
13007              }
13008              case value_t::object:
13009              {
13010                  m_value.object = create<object_t>(first.m_it.object_iterator,
13011                                                    last.m_it.object_iterator);
13012                  break;
13013              }
13014              case value_t::array:
13015              {
13016                  m_value.array = create<array_t>(first.m_it.array_iterator,
13017                                                  last.m_it.array_iterator);
13018                  break;
13019              }
13020              case value_t::binary:
13021              {
13022                  m_value = *first.m_object->m_value.binary;
13023                  break;
13024              }
13025              case value_t::null:
13026              case value_t::discarded:
13027              default:
13028                  JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " + std::string(first.m_object->type_name()), *first.m_object));
13029          }
13030          set_parents();
13031          assert_invariant();
13032      }
13033      template<typename JsonRef,
13034               detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
13035                                   std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
13036      basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}
13037      basic_json(const basic_json& other)
13038          : m_type(other.m_type)
13039      {
13040          other.assert_invariant();
13041          switch (m_type)
13042          {
13043              case value_t::object:
13044              {
13045                  m_value = *other.m_value.object;
13046                  break;
13047              }
13048              case value_t::array:
13049              {
13050                  m_value = *other.m_value.array;
13051                  break;
13052              }
13053              case value_t::string:
13054              {
13055                  m_value = *other.m_value.string;
13056                  break;
13057              }
13058              case value_t::boolean:
13059              {
13060                  m_value = other.m_value.boolean;
13061                  break;
13062              }
13063              case value_t::number_integer:
13064              {
13065                  m_value = other.m_value.number_integer;
13066                  break;
13067              }
13068              case value_t::number_unsigned:
13069              {
13070                  m_value = other.m_value.number_unsigned;
13071                  break;
13072              }
13073              case value_t::number_float:
13074              {
13075                  m_value = other.m_value.number_float;
13076                  break;
13077              }
13078              case value_t::binary:
13079              {
13080                  m_value = *other.m_value.binary;
13081                  break;
13082              }
13083              case value_t::null:
13084              case value_t::discarded:
13085              default:
13086                  break;
13087          }
13088          set_parents();
13089          assert_invariant();
13090      }
13091      basic_json(basic_json&& other) noexcept
13092          : m_type(std::move(other.m_type)),
13093            m_value(std::move(other.m_value))
13094      {
13095          other.assert_invariant(false);
13096          other.m_type = value_t::null;
13097          other.m_value = {};
13098          set_parents();
13099          assert_invariant();
13100      }
13101      basic_json& operator=(basic_json other) noexcept (
13102          std::is_nothrow_move_constructible<value_t>::value&&
13103          std::is_nothrow_move_assignable<value_t>::value&&
13104          std::is_nothrow_move_constructible<json_value>::value&&
13105          std::is_nothrow_move_assignable<json_value>::value
13106      )
13107      {
13108          other.assert_invariant();
13109          using std::swap;
13110          swap(m_type, other.m_type);
13111          swap(m_value, other.m_value);
13112          set_parents();
13113          assert_invariant();
13114          return *this;
13115      }
13116      ~basic_json() noexcept
13117      {
13118          assert_invariant(false);
13119          m_value.destroy(m_type);
13120      }
13121    public:
13122      string_t dump(const int indent = -1,
13123                    const char indent_char = ' ',
13124                    const bool ensure_ascii = false,
13125                    const error_handler_t error_handler = error_handler_t::strict) const
13126      {
13127          string_t result;
13128          serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);
13129          if (indent >= 0)
13130          {
13131              s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
13132          }
13133          else
13134          {
13135              s.dump(*this, false, ensure_ascii, 0);
13136          }
13137          return result;
13138      }
13139      constexpr value_t type() const noexcept
13140      {
13141          return m_type;
13142      }
13143      constexpr bool is_primitive() const noexcept
13144      {
13145          return is_null() || is_string() || is_boolean() || is_number() || is_binary();
13146      }
13147      constexpr bool is_structured() const noexcept
13148      {
13149          return is_array() || is_object();
13150      }
13151      constexpr bool is_null() const noexcept
13152      {
13153          return m_type == value_t::null;
13154      }
13155      constexpr bool is_boolean() const noexcept
13156      {
13157          return m_type == value_t::boolean;
13158      }
13159      constexpr bool is_number() const noexcept
13160      {
13161          return is_number_integer() || is_number_float();
13162      }
13163      constexpr bool is_number_integer() const noexcept
13164      {
13165          return m_type == value_t::number_integer || m_type == value_t::number_unsigned;
13166      }
13167      constexpr bool is_number_unsigned() const noexcept
13168      {
13169          return m_type == value_t::number_unsigned;
13170      }
13171      constexpr bool is_number_float() const noexcept
13172      {
13173          return m_type == value_t::number_float;
13174      }
13175      constexpr bool is_object() const noexcept
13176      {
13177          return m_type == value_t::object;
13178      }
13179      constexpr bool is_array() const noexcept
13180      {
13181          return m_type == value_t::array;
13182      }
13183      constexpr bool is_string() const noexcept
13184      {
13185          return m_type == value_t::string;
13186      }
13187      constexpr bool is_binary() const noexcept
13188      {
13189          return m_type == value_t::binary;
13190      }
13191      constexpr bool is_discarded() const noexcept
13192      {
13193          return m_type == value_t::discarded;
13194      }
13195      constexpr operator value_t() const noexcept
13196      {
13197          return m_type;
13198      }
13199    private:
13200      boolean_t get_impl(boolean_t* &bsol;*unused*/) const
13201      {
13202          if (JSON_HEDLEY_LIKELY(is_boolean()))
13203          {
13204              return m_value.boolean;
13205          }
13206          JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name()), *this));
13207      }
13208      object_t* get_impl_ptr(object_t* &bsol;*unused*/) noexcept
13209      {
13210          return is_object() ? m_value.object : nullptr;
13211      }
13212      constexpr const object_t* get_impl_ptr(const object_t* &bsol;*unused*/) const noexcept
13213      {
13214          return is_object() ? m_value.object : nullptr;
13215      }
13216      array_t* get_impl_ptr(array_t* &bsol;*unused*/) noexcept
13217      {
13218          return is_array() ? m_value.array : nullptr;
13219      }
13220      constexpr const array_t* get_impl_ptr(const array_t* &bsol;*unused*/) const noexcept
13221      {
13222          return is_array() ? m_value.array : nullptr;
13223      }
13224      string_t* get_impl_ptr(string_t* &bsol;*unused*/) noexcept
13225      {
13226          return is_string() ? m_value.string : nullptr;
13227      }
13228      constexpr const string_t* get_impl_ptr(const string_t* &bsol;*unused*/) const noexcept
13229      {
13230          return is_string() ? m_value.string : nullptr;
13231      }
13232      boolean_t* get_impl_ptr(boolean_t* &bsol;*unused*/) noexcept
13233      {
13234          return is_boolean() ? &m_value.boolean : nullptr;
13235      }
13236      constexpr const boolean_t* get_impl_ptr(const boolean_t* &bsol;*unused*/) const noexcept
13237      {
13238          return is_boolean() ? &m_value.boolean : nullptr;
13239      }
13240      number_integer_t* get_impl_ptr(number_integer_t* &bsol;*unused*/) noexcept
13241      {
13242          return is_number_integer() ? &m_value.number_integer : nullptr;
13243      }
13244      constexpr const number_integer_t* get_impl_ptr(const number_integer_t* &bsol;*unused*/) const noexcept
13245      {
13246          return is_number_integer() ? &m_value.number_integer : nullptr;
13247      }
13248      number_unsigned_t* get_impl_ptr(number_unsigned_t* &bsol;*unused*/) noexcept
13249      {
13250          return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
13251      }
13252      constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* &bsol;*unused*/) const noexcept
13253      {
13254          return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
13255      }
13256      number_float_t* get_impl_ptr(number_float_t* &bsol;*unused*/) noexcept
13257      {
13258          return is_number_float() ? &m_value.number_float : nullptr;
13259      }
13260      constexpr const number_float_t* get_impl_ptr(const number_float_t* &bsol;*unused*/) const noexcept
13261      {
13262          return is_number_float() ? &m_value.number_float : nullptr;
13263      }
13264      binary_t* get_impl_ptr(binary_t* &bsol;*unused*/) noexcept
13265      {
13266          return is_binary() ? m_value.binary : nullptr;
13267      }
13268      constexpr const binary_t* get_impl_ptr(const binary_t* &bsol;*unused*/) const noexcept
13269      {
13270          return is_binary() ? m_value.binary : nullptr;
13271      }
13272      template<typename ReferenceType, typename ThisType>
13273      static ReferenceType get_ref_impl(ThisType& obj)
13274      {
13275          auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();
13276          if (JSON_HEDLEY_LIKELY(ptr != nullptr))
13277          {
13278              return *ptr;
13279          }
13280          JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name()), obj));
13281      }
13282    public:
13283      template<typename PointerType, typename std::enable_if<
13284                   std::is_pointer<PointerType>::value, int>::type = 0>
13285      auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
13286      {
13287          return get_impl_ptr(static_cast<PointerType>(nullptr));
13288      }
13289      template < typename PointerType, typename std::enable_if <
13290                     std::is_pointer<PointerType>::value&&
13291                     std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
13292      constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
13293      {
13294          return get_impl_ptr(static_cast<PointerType>(nullptr));
13295      }
13296    private:
13297      template < typename ValueType,
13298                 detail::enable_if_t <
13299                     detail::is_default_constructible<ValueType>::value&&
13300                     detail::has_from_json<basic_json_t, ValueType>::value,
13301                     int > = 0 >
13302      ValueType get_impl(detail::priority_tag<0> &bsol;*unused*/) const noexcept(noexcept(
13303                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
13304      {
13305          ValueType ret{};
13306          JSONSerializer<ValueType>::from_json(*this, ret);
13307          return ret;
13308      }
13309      template < typename ValueType,
13310                 detail::enable_if_t <
13311                     detail::has_non_default_from_json<basic_json_t, ValueType>::value,
13312                     int > = 0 >
13313      ValueType get_impl(detail::priority_tag<1> &bsol;*unused*/) const noexcept(noexcept(
13314                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
13315      {
13316          return JSONSerializer<ValueType>::from_json(*this);
13317      }
13318      template < typename BasicJsonType,
13319                 detail::enable_if_t <
13320                     detail::is_basic_json<BasicJsonType>::value,
13321                     int > = 0 >
13322      BasicJsonType get_impl(detail::priority_tag<2> &bsol;*unused*/) const
13323      {
13324          return *this;
13325      }
13326      template<typename BasicJsonType,
13327               detail::enable_if_t<
13328                   std::is_same<BasicJsonType, basic_json_t>::value,
13329                   int> = 0>
13330      basic_json get_impl(detail::priority_tag<3> &bsol;*unused*/) const
13331      {
13332          return *this;
13333      }
13334      template<typename PointerType,
13335               detail::enable_if_t<
13336                   std::is_pointer<PointerType>::value,
13337                   int> = 0>
13338      constexpr auto get_impl(detail::priority_tag<4> &bsol;*unused*/) const noexcept
13339      -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
13340      {
13341          return get_ptr<PointerType>();
13342      }
13343    public:
13344      template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
13345  #if defined(JSON_HAS_CPP_14)
13346      constexpr
13347  #endif
13348      auto get() const noexcept(
13349      noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
13350      -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
13351      {
13352          static_assert(!std::is_reference<ValueTypeCV>::value,
13353                        "get() cannot be used with reference types, you might want to use get_ref()");
13354          return get_impl<ValueType>(detail::priority_tag<4> {});
13355      }
13356      template<typename PointerType, typename std::enable_if<
13357                   std::is_pointer<PointerType>::value, int>::type = 0>
13358      auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
13359      {
13360          return get_ptr<PointerType>();
13361      }
13362      template < typename ValueType,
13363                 detail::enable_if_t <
13364                     !detail::is_basic_json<ValueType>::value&&
13365                     detail::has_from_json<basic_json_t, ValueType>::value,
13366                     int > = 0 >
13367      ValueType & get_to(ValueType& v) const noexcept(noexcept(
13368                  JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
13369      {
13370          JSONSerializer<ValueType>::from_json(*this, v);
13371          return v;
13372      }
13373      template<typename ValueType,
13374               detail::enable_if_t <
13375                   detail::is_basic_json<ValueType>::value,
13376                   int> = 0>
13377      ValueType & get_to(ValueType& v) const
13378      {
13379          v = *this;
13380          return v;
13381      }
13382      template <
13383          typename T, std::size_t N,
13384          typename Array = T (&)[N], 
13385          detail::enable_if_t <
13386              detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
13387      Array get_to(T (&v)[N]) const 
13388      noexcept(noexcept(JSONSerializer<Array>::from_json(
13389                            std::declval<const basic_json_t&>(), v)))
13390      {
13391          JSONSerializer<Array>::from_json(*this, v);
13392          return v;
13393      }
13394      template<typename ReferenceType, typename std::enable_if<
13395                   std::is_reference<ReferenceType>::value, int>::type = 0>
13396      ReferenceType get_ref()
13397      {
13398          return get_ref_impl<ReferenceType>(*this);
13399      }
13400      template < typename ReferenceType, typename std::enable_if <
13401                     std::is_reference<ReferenceType>::value&&
13402                     std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
13403      ReferenceType get_ref() const
13404      {
13405          return get_ref_impl<ReferenceType>(*this);
13406      }
13407      template < typename ValueType, typename std::enable_if <
13408                     detail::conjunction <
13409                         detail::negation<std::is_pointer<ValueType>>,
13410                         detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
13411                                          detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
13412                                          detail::negation<detail::is_basic_json<ValueType>>,
13413                                          detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
13414  #if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
13415                                                  detail::negation<std::is_same<ValueType, std::string_view>>,
13416  #endif
13417                                                  detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
13418                                                  >::value, int >::type = 0 >
13419                                          JSON_EXPLICIT operator ValueType() const
13420      {
13421          return get<ValueType>();
13422      }
13423      binary_t& get_binary()
13424      {
13425          if (!is_binary())
13426          {
13427              JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name()), *this));
13428          }
13429          return *get_ptr<binary_t*>();
13430      }
13431      const binary_t& get_binary() const
13432      {
13433          if (!is_binary())
13434          {
13435              JSON_THROW(type_error::create(302, "type must be binary, but is " + std::string(type_name()), *this));
13436          }
13437          return *get_ptr<const binary_t*>();
13438      }
13439      reference at(size_type idx)
13440      {
13441          if (JSON_HEDLEY_LIKELY(is_array()))
13442          {
13443              JSON_TRY
13444              {
13445                  return set_parent(m_value.array->at(idx));
13446              }
13447              JSON_CATCH (std::out_of_range&)
13448              {
13449                  JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range", *this));
13450              }
13451          }
13452          else
13453          {
13454              JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name()), *this));
13455          }
13456      }
13457      const_reference at(size_type idx) const
13458      {
13459          if (JSON_HEDLEY_LIKELY(is_array()))
13460          {
13461              JSON_TRY
13462              {
13463                  return m_value.array->at(idx);
13464              }
13465              JSON_CATCH (std::out_of_range&)
13466              {
13467                  JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range", *this));
13468              }
13469          }
13470          else
13471          {
13472              JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name()), *this));
13473          }
13474      }
13475      reference at(const typename object_t::key_type& key)
13476      {
13477          if (JSON_HEDLEY_LIKELY(is_object()))
13478          {
13479              JSON_TRY
13480              {
13481                  return set_parent(m_value.object->at(key));
13482              }
13483              JSON_CATCH (std::out_of_range&)
13484              {
13485                  JSON_THROW(out_of_range::create(403, "key '" + key + "' not found", *this));
13486              }
13487          }
13488          else
13489          {
13490              JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name()), *this));
13491          }
13492      }
13493      const_reference at(const typename object_t::key_type& key) const
13494      {
13495          if (JSON_HEDLEY_LIKELY(is_object()))
13496          {
13497              JSON_TRY
13498              {
13499                  return m_value.object->at(key);
13500              }
13501              JSON_CATCH (std::out_of_range&)
13502              {
13503                  JSON_THROW(out_of_range::create(403, "key '" + key + "' not found", *this));
13504              }
13505          }
13506          else
13507          {
13508              JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name()), *this));
13509          }
13510      }
13511      reference operator[](size_type idx)
13512      {
13513          if (is_null())
13514          {
13515              m_type = value_t::array;
13516              m_value.array = create<array_t>();
13517              assert_invariant();
13518          }
13519          if (JSON_HEDLEY_LIKELY(is_array()))
13520          {
13521              if (idx >= m_value.array->size())
13522              {
13523  #if JSON_DIAGNOSTICS
13524                  const auto previous_size = m_value.array->size();
13525  #endif
13526                  m_value.array->resize(idx + 1);
13527  #if JSON_DIAGNOSTICS
13528                  set_parents(begin() + static_cast<typename iterator::difference_type>(previous_size), static_cast<typename iterator::difference_type>(idx + 1 - previous_size));
13529  #endif
13530              }
13531              return m_value.array->operator[](idx);
13532          }
13533          JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name()), *this));
13534      }
13535      const_reference operator[](size_type idx) const
13536      {
13537          if (JSON_HEDLEY_LIKELY(is_array()))
13538          {
13539              return m_value.array->operator[](idx);
13540          }
13541          JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name()), *this));
13542      }
13543      reference operator[](const typename object_t::key_type& key)
13544      {
13545          if (is_null())
13546          {
13547              m_type = value_t::object;
13548              m_value.object = create<object_t>();
13549              assert_invariant();
13550          }
13551          if (JSON_HEDLEY_LIKELY(is_object()))
13552          {
13553              return set_parent(m_value.object->operator[](key));
13554          }
13555          JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name()), *this));
13556      }
13557      const_reference operator[](const typename object_t::key_type& key) const
13558      {
13559          if (JSON_HEDLEY_LIKELY(is_object()))
13560          {
13561              JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
13562              return m_value.object->find(key)->second;
13563          }
13564          JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name()), *this));
13565      }
13566      template<typename T>
13567      JSON_HEDLEY_NON_NULL(2)
13568      reference operator[](T* key)
13569      {
13570          if (is_null())
13571          {
13572              m_type = value_t::object;
13573              m_value = value_t::object;
13574              assert_invariant();
13575          }
13576          if (JSON_HEDLEY_LIKELY(is_object()))
13577          {
13578              return set_parent(m_value.object->operator[](key));
13579          }
13580          JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name()), *this));
13581      }
13582      template<typename T>
13583      JSON_HEDLEY_NON_NULL(2)
13584      const_reference operator[](T* key) const
13585      {
13586          if (JSON_HEDLEY_LIKELY(is_object()))
13587          {
13588              JSON_ASSERT(m_value.object->find(key) != m_value.object->end());
13589              return m_value.object->find(key)->second;
13590          }
13591          JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name()), *this));
13592      }
13593      template < class ValueType, typename std::enable_if <
13594                     detail::is_getable<basic_json_t, ValueType>::value
13595                     && !std::is_same<value_t, ValueType>::value, int >::type = 0 >
13596      ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
13597      {
13598          if (JSON_HEDLEY_LIKELY(is_object()))
13599          {
13600              const auto it = find(key);
13601              if (it != end())
13602              {
13603                  return it->template get<ValueType>();
13604              }
13605              return default_value;
13606          }
13607          JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name()), *this));
13608      }
13609      string_t value(const typename object_t::key_type& key, const char* default_value) const
13610      {
13611          return value(key, string_t(default_value));
13612      }
13613      template<class ValueType, typename std::enable_if<
13614                   detail::is_getable<basic_json_t, ValueType>::value, int>::type = 0>
13615      ValueType value(const json_pointer& ptr, const ValueType& default_value) const
13616      {
13617          if (JSON_HEDLEY_LIKELY(is_object()))
13618          {
13619              JSON_TRY
13620              {
13621                  return ptr.get_checked(this).template get<ValueType>();
13622              }
13623              JSON_INTERNAL_CATCH (out_of_range&)
13624              {
13625                  return default_value;
13626              }
13627          }
13628          JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name()), *this));
13629      }
13630      JSON_HEDLEY_NON_NULL(3)
13631      string_t value(const json_pointer& ptr, const char* default_value) const
13632      {
13633          return value(ptr, string_t(default_value));
13634      }
13635      reference front()
13636      {
13637          return *begin();
13638      }
13639      const_reference front() const
13640      {
13641          return *cbegin();
13642      }
13643      reference back()
13644      {
13645          auto tmp = end();
13646          --tmp;
13647          return *tmp;
13648      }
13649      const_reference back() const
13650      {
13651          auto tmp = cend();
13652          --tmp;
13653          return *tmp;
13654      }
13655      template < class IteratorType, typename std::enable_if <
13656                     std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
13657                     std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
13658                 = 0 >
13659      IteratorType erase(IteratorType pos)
13660      {
13661          if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
13662          {
13663              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", *this));
13664          }
13665          IteratorType result = end();
13666          switch (m_type)
13667          {
13668              case value_t::boolean:
13669              case value_t::number_float:
13670              case value_t::number_integer:
13671              case value_t::number_unsigned:
13672              case value_t::string:
13673              case value_t::binary:
13674              {
13675                  if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
13676                  {
13677                      JSON_THROW(invalid_iterator::create(205, "iterator out of range", *this));
13678                  }
13679                  if (is_string())
13680                  {
13681                      AllocatorType<string_t> alloc;
13682                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
13683                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
13684                      m_value.string = nullptr;
13685                  }
13686                  else if (is_binary())
13687                  {
13688                      AllocatorType<binary_t> alloc;
13689                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
13690                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
13691                      m_value.binary = nullptr;
13692                  }
13693                  m_type = value_t::null;
13694                  assert_invariant();
13695                  break;
13696              }
13697              case value_t::object:
13698              {
13699                  result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
13700                  break;
13701              }
13702              case value_t::array:
13703              {
13704                  result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
13705                  break;
13706              }
13707              case value_t::null:
13708              case value_t::discarded:
13709              default:
13710                  JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name()), *this));
13711          }
13712          return result;
13713      }
13714      template < class IteratorType, typename std::enable_if <
13715                     std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
13716                     std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int >::type
13717                 = 0 >
13718      IteratorType erase(IteratorType first, IteratorType last)
13719      {
13720          if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
13721          {
13722              JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", *this));
13723          }
13724          IteratorType result = end();
13725          switch (m_type)
13726          {
13727              case value_t::boolean:
13728              case value_t::number_float:
13729              case value_t::number_integer:
13730              case value_t::number_unsigned:
13731              case value_t::string:
13732              case value_t::binary:
13733              {
13734                  if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
13735                                         || !last.m_it.primitive_iterator.is_end()))
13736                  {
13737                      JSON_THROW(invalid_iterator::create(204, "iterators out of range", *this));
13738                  }
13739                  if (is_string())
13740                  {
13741                      AllocatorType<string_t> alloc;
13742                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
13743                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
13744                      m_value.string = nullptr;
13745                  }
13746                  else if (is_binary())
13747                  {
13748                      AllocatorType<binary_t> alloc;
13749                      std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.binary);
13750                      std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.binary, 1);
13751                      m_value.binary = nullptr;
13752                  }
13753                  m_type = value_t::null;
13754                  assert_invariant();
13755                  break;
13756              }
13757              case value_t::object:
13758              {
13759                  result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
13760                                                last.m_it.object_iterator);
13761                  break;
13762              }
13763              case value_t::array:
13764              {
13765                  result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
13766                                               last.m_it.array_iterator);
13767                  break;
13768              }
13769              case value_t::null:
13770              case value_t::discarded:
13771              default:
13772                  JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name()), *this));
13773          }
13774          return result;
13775      }
13776      size_type erase(const typename object_t::key_type& key)
13777      {
13778          if (JSON_HEDLEY_LIKELY(is_object()))
13779          {
13780              return m_value.object->erase(key);
13781          }
13782          JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name()), *this));
13783      }
13784      void erase(const size_type idx)
13785      {
13786          if (JSON_HEDLEY_LIKELY(is_array()))
13787          {
13788              if (JSON_HEDLEY_UNLIKELY(idx >= size()))
13789              {
13790                  JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range", *this));
13791              }
13792              m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
13793          }
13794          else
13795          {
13796              JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name()), *this));
13797          }
13798      }
13799      template<typename KeyT>
13800      iterator find(KeyT&& key)
13801      {
13802          auto result = end();
13803          if (is_object())
13804          {
13805              result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
13806          }
13807          return result;
13808      }
13809      template<typename KeyT>
13810      const_iterator find(KeyT&& key) const
13811      {
13812          auto result = cend();
13813          if (is_object())
13814          {
13815              result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
13816          }
13817          return result;
13818      }
13819      template<typename KeyT>
13820      size_type count(KeyT&& key) const
13821      {
13822          return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
13823      }
13824      template < typename KeyT, typename std::enable_if <
13825                     !std::is_same<typename std::decay<KeyT>::type, json_pointer>::value, int >::type = 0 >
13826      bool contains(KeyT && key) const
13827      {
13828          return is_object() && m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();
13829      }
13830      bool contains(const json_pointer& ptr) const
13831      {
13832          return ptr.contains(this);
13833      }
13834      iterator begin() noexcept
13835      {
13836          iterator result(this);
13837          result.set_begin();
13838          return result;
13839      }
13840      const_iterator begin() const noexcept
13841      {
13842          return cbegin();
13843      }
13844      const_iterator cbegin() const noexcept
13845      {
13846          const_iterator result(this);
13847          result.set_begin();
13848          return result;
13849      }
13850      iterator end() noexcept
13851      {
13852          iterator result(this);
13853          result.set_end();
13854          return result;
13855      }
13856      const_iterator end() const noexcept
13857      {
13858          return cend();
13859      }
13860      const_iterator cend() const noexcept
13861      {
13862          const_iterator result(this);
13863          result.set_end();
13864          return result;
13865      }
13866      reverse_iterator rbegin() noexcept
13867      {
13868          return reverse_iterator(end());
13869      }
13870      const_reverse_iterator rbegin() const noexcept
13871      {
13872          return crbegin();
13873      }
13874      reverse_iterator rend() noexcept
13875      {
13876          return reverse_iterator(begin());
13877      }
13878      const_reverse_iterator rend() const noexcept
13879      {
13880          return crend();
13881      }
13882      const_reverse_iterator crbegin() const noexcept
13883      {
13884          return const_reverse_iterator(cend());
13885      }
13886      const_reverse_iterator crend() const noexcept
13887      {
13888          return const_reverse_iterator(cbegin());
13889      }
13890    public:
13891      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
13892      static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
13893      {
13894          return ref.items();
13895      }
13896      JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
13897      static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
13898      {
13899          return ref.items();
13900      }
13901      iteration_proxy<iterator> items() noexcept
13902      {
13903          return iteration_proxy<iterator>(*this);
13904      }
13905      iteration_proxy<const_iterator> items() const noexcept
13906      {
13907          return iteration_proxy<const_iterator>(*this);
13908      }
13909      bool empty() const noexcept
13910      {
13911          switch (m_type)
13912          {
13913              case value_t::null:
13914              {
13915                  return true;
13916              }
13917              case value_t::array:
13918              {
13919                  return m_value.array->empty();
13920              }
13921              case value_t::object:
13922              {
13923                  return m_value.object->empty();
13924              }
13925              case value_t::string:
13926              case value_t::boolean:
13927              case value_t::number_integer:
13928              case value_t::number_unsigned:
13929              case value_t::number_float:
13930              case value_t::binary:
13931              case value_t::discarded:
13932              default:
13933              {
13934                  return false;
13935              }
13936          }
13937      }
13938      size_type size() const noexcept
13939      {
13940          switch (m_type)
13941          {
13942              case value_t::null:
13943              {
13944                  return 0;
13945              }
13946              case value_t::array:
13947              {
13948                  return m_value.array->size();
13949              }
13950              case value_t::object:
13951              {
13952                  return m_value.object->size();
13953              }
13954              case value_t::string:
13955              case value_t::boolean:
13956              case value_t::number_integer:
13957              case value_t::number_unsigned:
13958              case value_t::number_float:
13959              case value_t::binary:
13960              case value_t::discarded:
13961              default:
13962              {
13963                  return 1;
13964              }
13965          }
13966      }
13967      size_type max_size() const noexcept
13968      {
13969          switch (m_type)
13970          {
13971              case value_t::array:
13972              {
13973                  return m_value.array->max_size();
13974              }
13975              case value_t::object:
13976              {
13977                  return m_value.object->max_size();
13978              }
13979              case value_t::null:
13980              case value_t::string:
13981              case value_t::boolean:
13982              case value_t::number_integer:
13983              case value_t::number_unsigned:
13984              case value_t::number_float:
13985              case value_t::binary:
13986              case value_t::discarded:
13987              default:
13988              {
13989                  return size();
13990              }
13991          }
13992      }
13993      void clear() noexcept
13994      {
13995          switch (m_type)
13996          {
13997              case value_t::number_integer:
13998              {
13999                  m_value.number_integer = 0;
14000                  break;
14001              }
14002              case value_t::number_unsigned:
14003              {
14004                  m_value.number_unsigned = 0;
14005                  break;
14006              }
14007              case value_t::number_float:
14008              {
14009                  m_value.number_float = 0.0;
14010                  break;
14011              }
14012              case value_t::boolean:
14013              {
14014                  m_value.boolean = false;
14015                  break;
14016              }
14017              case value_t::string:
14018              {
14019                  m_value.string->clear();
14020                  break;
14021              }
14022              case value_t::binary:
14023              {
14024                  m_value.binary->clear();
14025                  break;
14026              }
14027              case value_t::array:
14028              {
14029                  m_value.array->clear();
14030                  break;
14031              }
14032              case value_t::object:
14033              {
14034                  m_value.object->clear();
14035                  break;
14036              }
14037              case value_t::null:
14038              case value_t::discarded:
14039              default:
14040                  break;
14041          }
14042      }
14043      void push_back(basic_json&& val)
14044      {
14045          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14046          {
14047              JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name()), *this));
14048          }
14049          if (is_null())
14050          {
14051              m_type = value_t::array;
14052              m_value = value_t::array;
14053              assert_invariant();
14054          }
14055          const auto old_capacity = m_value.array->capacity();
14056          m_value.array->push_back(std::move(val));
14057          set_parent(m_value.array->back(), old_capacity);
14058      }
14059      reference operator+=(basic_json&& val)
14060      {
14061          push_back(std::move(val));
14062          return *this;
14063      }
14064      void push_back(const basic_json& val)
14065      {
14066          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14067          {
14068              JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name()), *this));
14069          }
14070          if (is_null())
14071          {
14072              m_type = value_t::array;
14073              m_value = value_t::array;
14074              assert_invariant();
14075          }
14076          const auto old_capacity = m_value.array->capacity();
14077          m_value.array->push_back(val);
14078          set_parent(m_value.array->back(), old_capacity);
14079      }
14080      reference operator+=(const basic_json& val)
14081      {
14082          push_back(val);
14083          return *this;
14084      }
14085      void push_back(const typename object_t::value_type& val)
14086      {
14087          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
14088          {
14089              JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name()), *this));
14090          }
14091          if (is_null())
14092          {
14093              m_type = value_t::object;
14094              m_value = value_t::object;
14095              assert_invariant();
14096          }
14097          auto res = m_value.object->insert(val);
14098          set_parent(res.first->second);
14099      }
14100      reference operator+=(const typename object_t::value_type& val)
14101      {
14102          push_back(val);
14103          return *this;
14104      }
14105      void push_back(initializer_list_t init)
14106      {
14107          if (is_object() && init.size() == 2 && (*init.begin())->is_string())
14108          {
14109              basic_json&& key = init.begin()->moved_or_copied();
14110              push_back(typename object_t::value_type(
14111                            std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
14112          }
14113          else
14114          {
14115              push_back(basic_json(init));
14116          }
14117      }
14118      reference operator+=(initializer_list_t init)
14119      {
14120          push_back(init);
14121          return *this;
14122      }
14123      template<class... Args>
14124      reference emplace_back(Args&& ... args)
14125      {
14126          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
14127          {
14128              JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name()), *this));
14129          }
14130          if (is_null())
14131          {
14132              m_type = value_t::array;
14133              m_value = value_t::array;
14134              assert_invariant();
14135          }
14136          const auto old_capacity = m_value.array->capacity();
14137          m_value.array->emplace_back(std::forward<Args>(args)...);
14138          return set_parent(m_value.array->back(), old_capacity);
14139      }
14140      template<class... Args>
14141      std::pair<iterator, bool> emplace(Args&& ... args)
14142      {
14143          if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
14144          {
14145              JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name()), *this));
14146          }
14147          if (is_null())
14148          {
14149              m_type = value_t::object;
14150              m_value = value_t::object;
14151              assert_invariant();
14152          }
14153          auto res = m_value.object->emplace(std::forward<Args>(args)...);
14154          set_parent(res.first->second);
14155          auto it = begin();
14156          it.m_it.object_iterator = res.first;
14157          return {it, res.second};
14158      }
14159      template<typename... Args>
14160      iterator insert_iterator(const_iterator pos, Args&& ... args)
14161      {
14162          iterator result(this);
14163          JSON_ASSERT(m_value.array != nullptr);
14164          auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
14165          m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
14166          result.m_it.array_iterator = m_value.array->begin() + insert_pos;
14167          set_parents();
14168          return result;
14169      }
14170      iterator insert(const_iterator pos, const basic_json& val)
14171      {
14172          if (JSON_HEDLEY_LIKELY(is_array()))
14173          {
14174              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14175              {
14176                  JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", *this));
14177              }
14178              return insert_iterator(pos, val);
14179          }
14180          JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name()), *this));
14181      }
14182      iterator insert(const_iterator pos, basic_json&& val)
14183      {
14184          return insert(pos, val);
14185      }
14186      iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
14187      {
14188          if (JSON_HEDLEY_LIKELY(is_array()))
14189          {
14190              if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14191              {
14192                  JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", *this));
14193              }
14194              return insert_iterator(pos, cnt, val);
14195          }
14196          JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name()), *this));
14197      }
14198      iterator insert(const_iterator pos, const_iterator first, const_iterator last)
14199      {
14200          if (JSON_HEDLEY_UNLIKELY(!is_array()))
14201          {
14202              JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name()), *this));
14203          }
14204          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14205          {
14206              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", *this));
14207          }
14208          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14209          {
14210              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", *this));
14211          }
14212          if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
14213          {
14214              JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", *this));
14215          }
14216          return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
14217      }
14218      iterator insert(const_iterator pos, initializer_list_t ilist)
14219      {
14220          if (JSON_HEDLEY_UNLIKELY(!is_array()))
14221          {
14222              JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name()), *this));
14223          }
14224          if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
14225          {
14226              JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", *this));
14227          }
14228          return insert_iterator(pos, ilist.begin(), ilist.end());
14229      }
14230      void insert(const_iterator first, const_iterator last)
14231      {
14232          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14233          {
14234              JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name()), *this));
14235          }
14236          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14237          {
14238              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", *this));
14239          }
14240          if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
14241          {
14242              JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", *this));
14243          }
14244          m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
14245      }
14246      void update(const_reference j)
14247      {
14248          if (is_null())
14249          {
14250              m_type = value_t::object;
14251              m_value.object = create<object_t>();
14252              assert_invariant();
14253          }
14254          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14255          {
14256              JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name()), *this));
14257          }
14258          if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
14259          {
14260              JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name()), *this));
14261          }
14262          for (auto it = j.cbegin(); it != j.cend(); ++it)
14263          {
14264              m_value.object->operator[](it.key()) = it.value();
14265          }
14266      }
14267      void update(const_iterator first, const_iterator last)
14268      {
14269          if (is_null())
14270          {
14271              m_type = value_t::object;
14272              m_value.object = create<object_t>();
14273              assert_invariant();
14274          }
14275          if (JSON_HEDLEY_UNLIKELY(!is_object()))
14276          {
14277              JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name()), *this));
14278          }
14279          if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
14280          {
14281              JSON_THROW(invalid_iterator::create(210, "iterators do not fit", *this));
14282          }
14283          if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()
14284                                   || !last.m_object->is_object()))
14285          {
14286              JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", *this));
14287          }
14288          for (auto it = first; it != last; ++it)
14289          {
14290              m_value.object->operator[](it.key()) = it.value();
14291          }
14292      }
14293      void swap(reference other) noexcept (
14294          std::is_nothrow_move_constructible<value_t>::value&&
14295          std::is_nothrow_move_assignable<value_t>::value&&
14296          std::is_nothrow_move_constructible<json_value>::value&&
14297          std::is_nothrow_move_assignable<json_value>::value
14298      )
14299      {
14300          std::swap(m_type, other.m_type);
14301          std::swap(m_value, other.m_value);
14302          set_parents();
14303          other.set_parents();
14304          assert_invariant();
14305      }
14306      friend void swap(reference left, reference right) noexcept (
14307          std::is_nothrow_move_constructible<value_t>::value&&
14308          std::is_nothrow_move_assignable<value_t>::value&&
14309          std::is_nothrow_move_constructible<json_value>::value&&
14310          std::is_nothrow_move_assignable<json_value>::value
14311      )
14312      {
14313          left.swap(right);
14314      }
14315      void swap(array_t& other) 
14316      {
14317          if (JSON_HEDLEY_LIKELY(is_array()))
14318          {
14319              std::swap(*(m_value.array), other);
14320          }
14321          else
14322          {
14323              JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name()), *this));
14324          }
14325      }
14326      void swap(object_t& other) 
14327      {
14328          if (JSON_HEDLEY_LIKELY(is_object()))
14329          {
14330              std::swap(*(m_value.object), other);
14331          }
14332          else
14333          {
14334              JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name()), *this));
14335          }
14336      }
14337      void swap(string_t& other) 
14338      {
14339          if (JSON_HEDLEY_LIKELY(is_string()))
14340          {
14341              std::swap(*(m_value.string), other);
14342          }
14343          else
14344          {
14345              JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name()), *this));
14346          }
14347      }
14348      void swap(binary_t& other) 
14349      {
14350          if (JSON_HEDLEY_LIKELY(is_binary()))
14351          {
14352              std::swap(*(m_value.binary), other);
14353          }
14354          else
14355          {
14356              JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name()), *this));
14357          }
14358      }
14359      void swap(typename binary_t::container_type& other) 
14360      {
14361          if (JSON_HEDLEY_LIKELY(is_binary()))
14362          {
14363              std::swap(*(m_value.binary), other);
14364          }
14365          else
14366          {
14367              JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name()), *this));
14368          }
14369      }
14370    public:
14371      friend bool operator==(const_reference lhs, const_reference rhs) noexcept
14372      {
14373  #ifdef __GNUC__
14374  #pragma GCC diagnostic push
14375  #pragma GCC diagnostic ignored "-Wfloat-equal"
14376  #endif
14377          const auto lhs_type = lhs.type();
14378          const auto rhs_type = rhs.type();
14379          if (lhs_type == rhs_type)
14380          {
14381              switch (lhs_type)
14382              {
14383                  case value_t::array:
14384                      return *lhs.m_value.array == *rhs.m_value.array;
14385                  case value_t::object:
14386                      return *lhs.m_value.object == *rhs.m_value.object;
14387                  case value_t::null:
14388                      return true;
14389                  case value_t::string:
14390                      return *lhs.m_value.string == *rhs.m_value.string;
14391                  case value_t::boolean:
14392                      return lhs.m_value.boolean == rhs.m_value.boolean;
14393                  case value_t::number_integer:
14394                      return lhs.m_value.number_integer == rhs.m_value.number_integer;
14395                  case value_t::number_unsigned:
14396                      return lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;
14397                  case value_t::number_float:
14398                      return lhs.m_value.number_float == rhs.m_value.number_float;
14399                  case value_t::binary:
14400                      return *lhs.m_value.binary == *rhs.m_value.binary;
14401                  case value_t::discarded:
14402                  default:
14403                      return false;
14404              }
14405          }
14406          else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
14407          {
14408              return static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float;
14409          }
14410          else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
14411          {
14412              return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer);
14413          }
14414          else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
14415          {
14416              return static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;
14417          }
14418          else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
14419          {
14420              return lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned);
14421          }
14422          else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
14423          {
14424              return static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;
14425          }
14426          else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
14427          {
14428              return lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned);
14429          }
14430          return false;
14431  #ifdef __GNUC__
14432  #pragma GCC diagnostic pop
14433  #endif
14434      }
14435      template<typename ScalarType, typename std::enable_if<
14436                   std::is_scalar<ScalarType>::value, int>::type = 0>
14437      friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
14438      {
14439          return lhs == basic_json(rhs);
14440      }
14441      template<typename ScalarType, typename std::enable_if<
14442                   std::is_scalar<ScalarType>::value, int>::type = 0>
14443      friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
14444      {
14445          return basic_json(lhs) == rhs;
14446      }
14447      friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
14448      {
14449          return !(lhs == rhs);
14450      }
14451      template<typename ScalarType, typename std::enable_if<
14452                   std::is_scalar<ScalarType>::value, int>::type = 0>
14453      friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
14454      {
14455          return lhs != basic_json(rhs);
14456      }
14457      template<typename ScalarType, typename std::enable_if<
14458                   std::is_scalar<ScalarType>::value, int>::type = 0>
14459      friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
14460      {
14461          return basic_json(lhs) != rhs;
14462      }
14463      friend bool operator<(const_reference lhs, const_reference rhs) noexcept
14464      {
14465          const auto lhs_type = lhs.type();
14466          const auto rhs_type = rhs.type();
14467          if (lhs_type == rhs_type)
14468          {
14469              switch (lhs_type)
14470              {
14471                  case value_t::array:
14472                      return (*lhs.m_value.array) < (*rhs.m_value.array);
14473                  case value_t::object:
14474                      return (*lhs.m_value.object) < (*rhs.m_value.object);
14475                  case value_t::null:
14476                      return false;
14477                  case value_t::string:
14478                      return (*lhs.m_value.string) < (*rhs.m_value.string);
14479                  case value_t::boolean:
14480                      return (lhs.m_value.boolean) < (rhs.m_value.boolean);
14481                  case value_t::number_integer:
14482                      return (lhs.m_value.number_integer) < (rhs.m_value.number_integer);
14483                  case value_t::number_unsigned:
14484                      return (lhs.m_value.number_unsigned) < (rhs.m_value.number_unsigned);
14485                  case value_t::number_float:
14486                      return (lhs.m_value.number_float) < (rhs.m_value.number_float);
14487                  case value_t::binary:
14488                      return (*lhs.m_value.binary) < (*rhs.m_value.binary);
14489                  case value_t::discarded:
14490                  default:
14491                      return false;
14492              }
14493          }
14494          else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)
14495          {
14496              return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
14497          }
14498          else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)
14499          {
14500              return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
14501          }
14502          else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)
14503          {
14504              return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
14505          }
14506          else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)
14507          {
14508              return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
14509          }
14510          else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)
14511          {
14512              return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
14513          }
14514          else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)
14515          {
14516              return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
14517          }
14518          return operator<(lhs_type, rhs_type);
14519      }
14520      template<typename ScalarType, typename std::enable_if<
14521                   std::is_scalar<ScalarType>::value, int>::type = 0>
14522      friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
14523      {
14524          return lhs < basic_json(rhs);
14525      }
14526      template<typename ScalarType, typename std::enable_if<
14527                   std::is_scalar<ScalarType>::value, int>::type = 0>
14528      friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
14529      {
14530          return basic_json(lhs) < rhs;
14531      }
14532      friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
14533      {
14534          return !(rhs < lhs);
14535      }
14536      template<typename ScalarType, typename std::enable_if<
14537                   std::is_scalar<ScalarType>::value, int>::type = 0>
14538      friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
14539      {
14540          return lhs <= basic_json(rhs);
14541      }
14542      template<typename ScalarType, typename std::enable_if<
14543                   std::is_scalar<ScalarType>::value, int>::type = 0>
14544      friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
14545      {
14546          return basic_json(lhs) <= rhs;
14547      }
14548      friend bool operator>(const_reference lhs, const_reference rhs) noexcept
14549      {
14550          return !(lhs <= rhs);
14551      }
14552      template<typename ScalarType, typename std::enable_if<
14553                   std::is_scalar<ScalarType>::value, int>::type = 0>
14554      friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
14555      {
14556          return lhs > basic_json(rhs);
14557      }
14558      template<typename ScalarType, typename std::enable_if<
14559                   std::is_scalar<ScalarType>::value, int>::type = 0>
14560      friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
14561      {
14562          return basic_json(lhs) > rhs;
14563      }
14564      friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
14565      {
14566          return !(lhs < rhs);
14567      }
14568      template<typename ScalarType, typename std::enable_if<
14569                   std::is_scalar<ScalarType>::value, int>::type = 0>
14570      friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
14571      {
14572          return lhs >= basic_json(rhs);
14573      }
14574      template<typename ScalarType, typename std::enable_if<
14575                   std::is_scalar<ScalarType>::value, int>::type = 0>
14576      friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
14577      {
14578          return basic_json(lhs) >= rhs;
14579      }
14580  #ifndef JSON_NO_IO
14581      friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
14582      {
14583          const bool pretty_print = o.width() > 0;
14584          const auto indentation = pretty_print ? o.width() : 0;
14585          o.width(0);
14586          serializer s(detail::output_adapter<char>(o), o.fill());
14587          s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
14588          return o;
14589      }
14590      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
14591      friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
14592      {
14593          return o << j;
14594      }
14595  #endif  
14596      template<typename InputType>
14597      JSON_HEDLEY_WARN_UNUSED_RESULT
14598      static basic_json parse(InputType&& i,
14599                              const parser_callback_t cb = nullptr,
14600                              const bool allow_exceptions = true,
14601                              const bool ignore_comments = false)
14602      {
14603          basic_json result;
14604          parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
14605          return result;
14606      }
14607      template<typename IteratorType>
14608      JSON_HEDLEY_WARN_UNUSED_RESULT
14609      static basic_json parse(IteratorType first,
14610                              IteratorType last,
14611                              const parser_callback_t cb = nullptr,
14612                              const bool allow_exceptions = true,
14613                              const bool ignore_comments = false)
14614      {
14615          basic_json result;
14616          parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
14617          return result;
14618      }
14619      JSON_HEDLEY_WARN_UNUSED_RESULT
14620      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
14621      static basic_json parse(detail::span_input_adapter&& i,
14622                              const parser_callback_t cb = nullptr,
14623                              const bool allow_exceptions = true,
14624                              const bool ignore_comments = false)
14625      {
14626          basic_json result;
14627          parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
14628          return result;
14629      }
14630      template<typename InputType>
14631      static bool accept(InputType&& i,
14632                         const bool ignore_comments = false)
14633      {
14634          return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
14635      }
14636      template<typename IteratorType>
14637      static bool accept(IteratorType first, IteratorType last,
14638                         const bool ignore_comments = false)
14639      {
14640          return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
14641      }
14642      JSON_HEDLEY_WARN_UNUSED_RESULT
14643      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
14644      static bool accept(detail::span_input_adapter&& i,
14645                         const bool ignore_comments = false)
14646      {
14647          return parser(i.get(), nullptr, false, ignore_comments).accept(true);
14648      }
14649      template <typename InputType, typename SAX>
14650      JSON_HEDLEY_NON_NULL(2)
14651      static bool sax_parse(InputType&& i, SAX* sax,
14652                            input_format_t format = input_format_t::json,
14653                            const bool strict = true,
14654                            const bool ignore_comments = false)
14655      {
14656          auto ia = detail::input_adapter(std::forward<InputType>(i));
14657          return format == input_format_t::json
14658                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14659                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
14660      }
14661      template<class IteratorType, class SAX>
14662      JSON_HEDLEY_NON_NULL(3)
14663      static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
14664                            input_format_t format = input_format_t::json,
14665                            const bool strict = true,
14666                            const bool ignore_comments = false)
14667      {
14668          auto ia = detail::input_adapter(std::move(first), std::move(last));
14669          return format == input_format_t::json
14670                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14671                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
14672      }
14673      template <typename SAX>
14674      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
14675      JSON_HEDLEY_NON_NULL(2)
14676      static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
14677                            input_format_t format = input_format_t::json,
14678                            const bool strict = true,
14679                            const bool ignore_comments = false)
14680      {
14681          auto ia = i.get();
14682          return format == input_format_t::json
14683                 ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
14684                 : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);
14685      }
14686  #ifndef JSON_NO_IO
14687      JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
14688      friend std::istream& operator<<(basic_json& j, std::istream& i)
14689      {
14690          return operator>>(i, j);
14691      }
14692      friend std::istream& operator>>(std::istream& i, basic_json& j)
14693      {
14694          parser(detail::input_adapter(i)).parse(false, j);
14695          return i;
14696      }
14697  #endif  
14698      JSON_HEDLEY_RETURNS_NON_NULL
14699      const char* type_name() const noexcept
14700      {
14701          {
14702              switch (m_type)
14703              {
14704                  case value_t::null:
14705                      return "null";
14706                  case value_t::object:
14707                      return "object";
14708                  case value_t::array:
14709                      return "array";
14710                  case value_t::string:
14711                      return "string";
14712                  case value_t::boolean:
14713                      return "boolean";
14714                  case value_t::binary:
14715                      return "binary";
14716                  case value_t::discarded:
14717                      return "discarded";
14718                  case value_t::number_integer:
14719                  case value_t::number_unsigned:
14720                  case value_t::number_float:
14721                  default:
14722                      return "number";
14723              }
14724          }
14725      }
14726    JSON_PRIVATE_UNLESS_TESTED:
14727      value_t m_type = value_t::null;
14728      json_value m_value = {};
14729  #if JSON_DIAGNOSTICS
14730      basic_json* m_parent = nullptr;
14731  #endif
14732    public:
14733      static std::vector<std::uint8_t> to_cbor(const basic_json& j)
14734      {
14735          std::vector<std::uint8_t> result;
14736          to_cbor(j, result);
14737          return result;
14738      }
14739      static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
14740      {
14741          binary_writer<std::uint8_t>(o).write_cbor(j);
14742      }
14743      static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
14744      {
14745          binary_writer<char>(o).write_cbor(j);
14746      }
14747      static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
14748      {
14749          std::vector<std::uint8_t> result;
14750          to_msgpack(j, result);
14751          return result;
14752      }
14753      static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
14754      {
14755          binary_writer<std::uint8_t>(o).write_msgpack(j);
14756      }
14757      static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
14758      {
14759          binary_writer<char>(o).write_msgpack(j);
14760      }
14761      static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
14762              const bool use_size = false,
14763              const bool use_type = false)
14764      {
14765          std::vector<std::uint8_t> result;
14766          to_ubjson(j, result, use_size, use_type);
14767          return result;
14768      }
14769      static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
14770                            const bool use_size = false, const bool use_type = false)
14771      {
14772          binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
14773      }
14774      static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
14775                            const bool use_size = false, const bool use_type = false)
14776      {
14777          binary_writer<char>(o).write_ubjson(j, use_size, use_type);
14778      }
14779      static std::vector<std::uint8_t> to_bson(const basic_json& j)
14780      {
14781          std::vector<std::uint8_t> result;
14782          to_bson(j, result);
14783          return result;
14784      }
14785      static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
14786      {
14787          binary_writer<std::uint8_t>(o).write_bson(j);
14788      }
14789      static void to_bson(const basic_json& j, detail::output_adapter<char> o)
14790      {
14791          binary_writer<char>(o).write_bson(j);
14792      }
14793      template<typename InputType>
14794      JSON_HEDLEY_WARN_UNUSED_RESULT
14795      static basic_json from_cbor(InputType&& i,
14796                                  const bool strict = true,
14797                                  const bool allow_exceptions = true,
14798                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14799      {
14800          basic_json result;
14801          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14802          auto ia = detail::input_adapter(std::forward<InputType>(i));
14803          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
14804          return res ? result : basic_json(value_t::discarded);
14805      }
14806      template<typename IteratorType>
14807      JSON_HEDLEY_WARN_UNUSED_RESULT
14808      static basic_json from_cbor(IteratorType first, IteratorType last,
14809                                  const bool strict = true,
14810                                  const bool allow_exceptions = true,
14811                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14812      {
14813          basic_json result;
14814          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14815          auto ia = detail::input_adapter(std::move(first), std::move(last));
14816          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
14817          return res ? result : basic_json(value_t::discarded);
14818      }
14819      template<typename T>
14820      JSON_HEDLEY_WARN_UNUSED_RESULT
14821      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
14822      static basic_json from_cbor(const T* ptr, std::size_t len,
14823                                  const bool strict = true,
14824                                  const bool allow_exceptions = true,
14825                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14826      {
14827          return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
14828      }
14829      JSON_HEDLEY_WARN_UNUSED_RESULT
14830      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
14831      static basic_json from_cbor(detail::span_input_adapter&& i,
14832                                  const bool strict = true,
14833                                  const bool allow_exceptions = true,
14834                                  const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
14835      {
14836          basic_json result;
14837          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14838          auto ia = i.get();
14839          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
14840          return res ? result : basic_json(value_t::discarded);
14841      }
14842      template<typename InputType>
14843      JSON_HEDLEY_WARN_UNUSED_RESULT
14844      static basic_json from_msgpack(InputType&& i,
14845                                     const bool strict = true,
14846                                     const bool allow_exceptions = true)
14847      {
14848          basic_json result;
14849          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14850          auto ia = detail::input_adapter(std::forward<InputType>(i));
14851          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
14852          return res ? result : basic_json(value_t::discarded);
14853      }
14854      template<typename IteratorType>
14855      JSON_HEDLEY_WARN_UNUSED_RESULT
14856      static basic_json from_msgpack(IteratorType first, IteratorType last,
14857                                     const bool strict = true,
14858                                     const bool allow_exceptions = true)
14859      {
14860          basic_json result;
14861          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14862          auto ia = detail::input_adapter(std::move(first), std::move(last));
14863          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
14864          return res ? result : basic_json(value_t::discarded);
14865      }
14866      template<typename T>
14867      JSON_HEDLEY_WARN_UNUSED_RESULT
14868      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
14869      static basic_json from_msgpack(const T* ptr, std::size_t len,
14870                                     const bool strict = true,
14871                                     const bool allow_exceptions = true)
14872      {
14873          return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
14874      }
14875      JSON_HEDLEY_WARN_UNUSED_RESULT
14876      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
14877      static basic_json from_msgpack(detail::span_input_adapter&& i,
14878                                     const bool strict = true,
14879                                     const bool allow_exceptions = true)
14880      {
14881          basic_json result;
14882          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14883          auto ia = i.get();
14884          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);
14885          return res ? result : basic_json(value_t::discarded);
14886      }
14887      template<typename InputType>
14888      JSON_HEDLEY_WARN_UNUSED_RESULT
14889      static basic_json from_ubjson(InputType&& i,
14890                                    const bool strict = true,
14891                                    const bool allow_exceptions = true)
14892      {
14893          basic_json result;
14894          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14895          auto ia = detail::input_adapter(std::forward<InputType>(i));
14896          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
14897          return res ? result : basic_json(value_t::discarded);
14898      }
14899      template<typename IteratorType>
14900      JSON_HEDLEY_WARN_UNUSED_RESULT
14901      static basic_json from_ubjson(IteratorType first, IteratorType last,
14902                                    const bool strict = true,
14903                                    const bool allow_exceptions = true)
14904      {
14905          basic_json result;
14906          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14907          auto ia = detail::input_adapter(std::move(first), std::move(last));
14908          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
14909          return res ? result : basic_json(value_t::discarded);
14910      }
14911      template<typename T>
14912      JSON_HEDLEY_WARN_UNUSED_RESULT
14913      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
14914      static basic_json from_ubjson(const T* ptr, std::size_t len,
14915                                    const bool strict = true,
14916                                    const bool allow_exceptions = true)
14917      {
14918          return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
14919      }
14920      JSON_HEDLEY_WARN_UNUSED_RESULT
14921      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
14922      static basic_json from_ubjson(detail::span_input_adapter&& i,
14923                                    const bool strict = true,
14924                                    const bool allow_exceptions = true)
14925      {
14926          basic_json result;
14927          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14928          auto ia = i.get();
14929          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);
14930          return res ? result : basic_json(value_t::discarded);
14931      }
14932      template<typename InputType>
14933      JSON_HEDLEY_WARN_UNUSED_RESULT
14934      static basic_json from_bson(InputType&& i,
14935                                  const bool strict = true,
14936                                  const bool allow_exceptions = true)
14937      {
14938          basic_json result;
14939          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14940          auto ia = detail::input_adapter(std::forward<InputType>(i));
14941          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
14942          return res ? result : basic_json(value_t::discarded);
14943      }
14944      template<typename IteratorType>
14945      JSON_HEDLEY_WARN_UNUSED_RESULT
14946      static basic_json from_bson(IteratorType first, IteratorType last,
14947                                  const bool strict = true,
14948                                  const bool allow_exceptions = true)
14949      {
14950          basic_json result;
14951          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14952          auto ia = detail::input_adapter(std::move(first), std::move(last));
14953          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
14954          return res ? result : basic_json(value_t::discarded);
14955      }
14956      template<typename T>
14957      JSON_HEDLEY_WARN_UNUSED_RESULT
14958      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
14959      static basic_json from_bson(const T* ptr, std::size_t len,
14960                                  const bool strict = true,
14961                                  const bool allow_exceptions = true)
14962      {
14963          return from_bson(ptr, ptr + len, strict, allow_exceptions);
14964      }
14965      JSON_HEDLEY_WARN_UNUSED_RESULT
14966      JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
14967      static basic_json from_bson(detail::span_input_adapter&& i,
14968                                  const bool strict = true,
14969                                  const bool allow_exceptions = true)
14970      {
14971          basic_json result;
14972          detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
14973          auto ia = i.get();
14974          const bool res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);
14975          return res ? result : basic_json(value_t::discarded);
14976      }
14977      reference operator[](const json_pointer& ptr)
14978      {
14979          return ptr.get_unchecked(this);
14980      }
14981      const_reference operator[](const json_pointer& ptr) const
14982      {
14983          return ptr.get_unchecked(this);
14984      }
14985      reference at(const json_pointer& ptr)
14986      {
14987          return ptr.get_checked(this);
14988      }
14989      const_reference at(const json_pointer& ptr) const
14990      {
14991          return ptr.get_checked(this);
14992      }
14993      basic_json flatten() const
14994      {
14995          basic_json result(value_t::object);
14996          json_pointer::flatten("", *this, result);
14997          return result;
14998      }
14999      basic_json unflatten() const
15000      {
15001          return json_pointer::unflatten(*this);
15002      }
15003      basic_json patch(const basic_json& json_patch) const
15004      {
15005          basic_json result = *this;
15006          enum class patch_operations {add, remove, replace, move, copy, test, invalid};
15007          const auto get_op = [](const std::string & op)
15008          {
15009              if (op == "add")
15010              {
15011                  return patch_operations::add;
15012              }
15013              if (op == "remove")
15014              {
15015                  return patch_operations::remove;
15016              }
15017              if (op == "replace")
15018              {
15019                  return patch_operations::replace;
15020              }
15021              if (op == "move")
15022              {
15023                  return patch_operations::move;
15024              }
15025              if (op == "copy")
15026              {
15027                  return patch_operations::copy;
15028              }
15029              if (op == "test")
15030              {
15031                  return patch_operations::test;
15032              }
15033              return patch_operations::invalid;
15034          };
15035          const auto operation_add = [&result](json_pointer & ptr, basic_json val)
15036          {
15037              if (ptr.empty())
15038              {
15039                  result = val;
15040                  return;
15041              }
15042              json_pointer top_pointer = ptr.top();
15043              if (top_pointer != ptr)
15044              {
15045                  result.at(top_pointer);
15046              }
15047              const auto last_path = ptr.back();
15048              ptr.pop_back();
15049              basic_json& parent = result[ptr];
15050              switch (parent.m_type)
15051              {
15052                  case value_t::null:
15053                  case value_t::object:
15054                  {
15055                      parent[last_path] = val;
15056                      break;
15057                  }
15058                  case value_t::array:
15059                  {
15060                      if (last_path == "-")
15061                      {
15062                          parent.push_back(val);
15063                      }
15064                      else
15065                      {
15066                          const auto idx = json_pointer::array_index(last_path);
15067                          if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
15068                          {
15069                              JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range", parent));
15070                          }
15071                          parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
15072                      }
15073                      break;
15074                  }
15075                  case value_t::string: 
15076                  case value_t::boolean: 
15077                  case value_t::number_integer: 
15078                  case value_t::number_unsigned: 
15079                  case value_t::number_float: 
15080                  case value_t::binary: 
15081                  case value_t::discarded: 
15082                  default:            
15083                      JSON_ASSERT(false); 
15084              }
15085          };
15086          const auto operation_remove = [this, &result](json_pointer & ptr)
15087          {
15088              const auto last_path = ptr.back();
15089              ptr.pop_back();
15090              basic_json& parent = result.at(ptr);
15091              if (parent.is_object())
15092              {
15093                  auto it = parent.find(last_path);
15094                  if (JSON_HEDLEY_LIKELY(it != parent.end()))
15095                  {
15096                      parent.erase(it);
15097                  }
15098                  else
15099                  {
15100                      JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found", *this));
15101                  }
15102              }
15103              else if (parent.is_array())
15104              {
15105                  parent.erase(json_pointer::array_index(last_path));
15106              }
15107          };
15108          if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
15109          {
15110              JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", json_patch));
15111          }
15112          for (const auto& val : json_patch)
15113          {
15114              const auto get_value = [&val](const std::string & op,
15115                                            const std::string & member,
15116                                            bool string_type) -> basic_json &
15117              {
15118                  auto it = val.m_value.object->find(member);
15119                  const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";
15120                  if (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))
15121                  {
15122                      JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'", val));
15123                  }
15124                  if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
15125                  {
15126                      JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'", val));
15127                  }
15128                  return it->second;
15129              };
15130              if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
15131              {
15132                  JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", val));
15133              }
15134              const auto op = get_value("op", "op", true).template get<std::string>();
15135              const auto path = get_value(op, "path", true).template get<std::string>();
15136              json_pointer ptr(path);
15137              switch (get_op(op))
15138              {
15139                  case patch_operations::add:
15140                  {
15141                      operation_add(ptr, get_value("add", "value", false));
15142                      break;
15143                  }
15144                  case patch_operations::remove:
15145                  {
15146                      operation_remove(ptr);
15147                      break;
15148                  }
15149                  case patch_operations::replace:
15150                  {
15151                      result.at(ptr) = get_value("replace", "value", false);
15152                      break;
15153                  }
15154                  case patch_operations::move:
15155                  {
15156                      const auto from_path = get_value("move", "from", true).template get<std::string>();
15157                      json_pointer from_ptr(from_path);
15158                      basic_json v = result.at(from_ptr);
15159                      operation_remove(from_ptr);
15160                      operation_add(ptr, v);
15161                      break;
15162                  }
15163                  case patch_operations::copy:
15164                  {
15165                      const auto from_path = get_value("copy", "from", true).template get<std::string>();
15166                      const json_pointer from_ptr(from_path);
15167                      basic_json v = result.at(from_ptr);
15168                      operation_add(ptr, v);
15169                      break;
15170                  }
15171                  case patch_operations::test:
15172                  {
15173                      bool success = false;
15174                      JSON_TRY
15175                      {
15176                          success = (result.at(ptr) == get_value("test", "value", false));
15177                      }
15178                      JSON_INTERNAL_CATCH (out_of_range&)
15179                      {
15180                      }
15181                      if (JSON_HEDLEY_UNLIKELY(!success))
15182                      {
15183                          JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump(), val));
15184                      }
15185                      break;
15186                  }
15187                  case patch_operations::invalid:
15188                  default:
15189                  {
15190                      JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid", val));
15191                  }
15192              }
15193          }
15194          return result;
15195      }
15196      JSON_HEDLEY_WARN_UNUSED_RESULT
15197      static basic_json diff(const basic_json& source, const basic_json& target,
15198                             const std::string& path = "")
15199      {
15200          basic_json result(value_t::array);
15201          if (source == target)
15202          {
15203              return result;
15204          }
15205          if (source.type() != target.type())
15206          {
15207              result.push_back(
15208              {
15209                  {"op", "replace"}, {"path", path}, {"value", target}
15210              });
15211              return result;
15212          }
15213          switch (source.type())
15214          {
15215              case value_t::array:
15216              {
15217                  std::size_t i = 0;
15218                  while (i < source.size() && i < target.size())
15219                  {
15220                      auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
15221                      result.insert(result.end(), temp_diff.begin(), temp_diff.end());
15222                      ++i;
15223                  }
15224                  const auto end_index = static_cast<difference_type>(result.size());
15225                  while (i < source.size())
15226                  {
15227                      result.insert(result.begin() + end_index, object(
15228                      {
15229                          {"op", "remove"},
15230                          {"path", path + "/" + std::to_string(i)}
15231                      }));
15232                      ++i;
15233                  }
15234                  while (i < target.size())
15235                  {
15236                      result.push_back(
15237                      {
15238                          {"op", "add"},
15239                          {"path", path + "/-"},
15240                          {"value", target[i]}
15241                      });
15242                      ++i;
15243                  }
15244                  break;
15245              }
15246              case value_t::object:
15247              {
15248                  for (auto it = source.cbegin(); it != source.cend(); ++it)
15249                  {
15250                      const auto path_key = path + "/" + detail::escape(it.key());
15251                      if (target.find(it.key()) != target.end())
15252                      {
15253                          auto temp_diff = diff(it.value(), target[it.key()], path_key);
15254                          result.insert(result.end(), temp_diff.begin(), temp_diff.end());
15255                      }
15256                      else
15257                      {
15258                          result.push_back(object(
15259                          {
15260                              {"op", "remove"}, {"path", path_key}
15261                          }));
15262                      }
15263                  }
15264                  for (auto it = target.cbegin(); it != target.cend(); ++it)
15265                  {
15266                      if (source.find(it.key()) == source.end())
15267                      {
15268                          const auto path_key = path + "/" + detail::escape(it.key());
15269                          result.push_back(
15270                          {
15271                              {"op", "add"}, {"path", path_key},
15272                              {"value", it.value()}
15273                          });
15274                      }
15275                  }
15276                  break;
15277              }
15278              case value_t::null:
15279              case value_t::string:
15280              case value_t::boolean:
15281              case value_t::number_integer:
15282              case value_t::number_unsigned:
15283              case value_t::number_float:
15284              case value_t::binary:
15285              case value_t::discarded:
15286              default:
15287              {
15288                  result.push_back(
15289                  {
15290                      {"op", "replace"}, {"path", path}, {"value", target}
15291                  });
15292                  break;
15293              }
15294          }
15295          return result;
15296      }
15297      void merge_patch(const basic_json& apply_patch)
15298      {
15299          if (apply_patch.is_object())
15300          {
15301              if (!is_object())
15302              {
15303                  *this = object();
15304              }
15305              for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
15306              {
15307                  if (it.value().is_null())
15308                  {
15309                      erase(it.key());
15310                  }
15311                  else
15312                  {
15313                      operator[](it.key()).merge_patch(it.value());
15314                  }
15315              }
15316          }
15317          else
15318          {
15319              *this = apply_patch;
15320          }
15321      }
15322  };
15323  NLOHMANN_BASIC_JSON_TPL_DECLARATION
15324  std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
15325  {
15326      return j.dump();
15327  }
15328  } 
15329  namespace std
15330  {
15331  template<>
15332  struct hash<nlohmann::json>
15333  {
15334      std::size_t operator()(const nlohmann::json& j) const
15335      {
15336          return nlohmann::detail::hash(j);
15337      }
15338  };
15339  template<>
15340  struct less<::nlohmann::detail::value_t>
15341  {
15342      bool operator()(nlohmann::detail::value_t lhs,
15343                      nlohmann::detail::value_t rhs) const noexcept
15344      {
15345          return nlohmann::detail::operator<(lhs, rhs);
15346      }
15347  };
15348  #ifndef JSON_HAS_CPP_20
15349  template<>
15350  inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept( 
15351      is_nothrow_move_constructible<nlohmann::json>::value&&  
15352      is_nothrow_move_assignable<nlohmann::json>::value
15353                                )
15354  {
15355      j1.swap(j2);
15356  }
15357  #endif
15358  } 
15359  JSON_HEDLEY_NON_NULL(1)
15360  inline nlohmann::json operator "" _json(const char* s, std::size_t n)
15361  {
15362      return nlohmann::json::parse(s, s + n);
15363  }
15364  JSON_HEDLEY_NON_NULL(1)
15365  inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
15366  {
15367      return nlohmann::json::json_pointer(std::string(s, n));
15368  }
15369  #if defined(__clang__)
15370      #pragma clang diagnostic pop
15371  #endif
15372  #undef JSON_ASSERT
15373  #undef JSON_INTERNAL_CATCH
15374  #undef JSON_CATCH
15375  #undef JSON_THROW
15376  #undef JSON_TRY
15377  #undef JSON_PRIVATE_UNLESS_TESTED
15378  #undef JSON_HAS_CPP_11
15379  #undef JSON_HAS_CPP_14
15380  #undef JSON_HAS_CPP_17
15381  #undef JSON_HAS_CPP_20
15382  #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
15383  #undef NLOHMANN_BASIC_JSON_TPL
15384  #undef JSON_EXPLICIT
15385  #undef JSON_HEDLEY_ALWAYS_INLINE
15386  #undef JSON_HEDLEY_ARM_VERSION
15387  #undef JSON_HEDLEY_ARM_VERSION_CHECK
15388  #undef JSON_HEDLEY_ARRAY_PARAM
15389  #undef JSON_HEDLEY_ASSUME
15390  #undef JSON_HEDLEY_BEGIN_C_DECLS
15391  #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
15392  #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
15393  #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
15394  #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
15395  #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
15396  #undef JSON_HEDLEY_CLANG_HAS_FEATURE
15397  #undef JSON_HEDLEY_CLANG_HAS_WARNING
15398  #undef JSON_HEDLEY_COMPCERT_VERSION
15399  #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
15400  #undef JSON_HEDLEY_CONCAT
15401  #undef JSON_HEDLEY_CONCAT3
15402  #undef JSON_HEDLEY_CONCAT3_EX
15403  #undef JSON_HEDLEY_CONCAT_EX
15404  #undef JSON_HEDLEY_CONST
15405  #undef JSON_HEDLEY_CONSTEXPR
15406  #undef JSON_HEDLEY_CONST_CAST
15407  #undef JSON_HEDLEY_CPP_CAST
15408  #undef JSON_HEDLEY_CRAY_VERSION
15409  #undef JSON_HEDLEY_CRAY_VERSION_CHECK
15410  #undef JSON_HEDLEY_C_DECL
15411  #undef JSON_HEDLEY_DEPRECATED
15412  #undef JSON_HEDLEY_DEPRECATED_FOR
15413  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
15414  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
15415  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
15416  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
15417  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
15418  #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
15419  #undef JSON_HEDLEY_DIAGNOSTIC_POP
15420  #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
15421  #undef JSON_HEDLEY_DMC_VERSION
15422  #undef JSON_HEDLEY_DMC_VERSION_CHECK
15423  #undef JSON_HEDLEY_EMPTY_BASES
15424  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
15425  #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
15426  #undef JSON_HEDLEY_END_C_DECLS
15427  #undef JSON_HEDLEY_FLAGS
15428  #undef JSON_HEDLEY_FLAGS_CAST
15429  #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
15430  #undef JSON_HEDLEY_GCC_HAS_BUILTIN
15431  #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
15432  #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
15433  #undef JSON_HEDLEY_GCC_HAS_EXTENSION
15434  #undef JSON_HEDLEY_GCC_HAS_FEATURE
15435  #undef JSON_HEDLEY_GCC_HAS_WARNING
15436  #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
15437  #undef JSON_HEDLEY_GCC_VERSION
15438  #undef JSON_HEDLEY_GCC_VERSION_CHECK
15439  #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
15440  #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
15441  #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
15442  #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
15443  #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
15444  #undef JSON_HEDLEY_GNUC_HAS_FEATURE
15445  #undef JSON_HEDLEY_GNUC_HAS_WARNING
15446  #undef JSON_HEDLEY_GNUC_VERSION
15447  #undef JSON_HEDLEY_GNUC_VERSION_CHECK
15448  #undef JSON_HEDLEY_HAS_ATTRIBUTE
15449  #undef JSON_HEDLEY_HAS_BUILTIN
15450  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
15451  #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
15452  #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
15453  #undef JSON_HEDLEY_HAS_EXTENSION
15454  #undef JSON_HEDLEY_HAS_FEATURE
15455  #undef JSON_HEDLEY_HAS_WARNING
15456  #undef JSON_HEDLEY_IAR_VERSION
15457  #undef JSON_HEDLEY_IAR_VERSION_CHECK
15458  #undef JSON_HEDLEY_IBM_VERSION
15459  #undef JSON_HEDLEY_IBM_VERSION_CHECK
15460  #undef JSON_HEDLEY_IMPORT
15461  #undef JSON_HEDLEY_INLINE
15462  #undef JSON_HEDLEY_INTEL_CL_VERSION
15463  #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
15464  #undef JSON_HEDLEY_INTEL_VERSION
15465  #undef JSON_HEDLEY_INTEL_VERSION_CHECK
15466  #undef JSON_HEDLEY_IS_CONSTANT
15467  #undef JSON_HEDLEY_IS_CONSTEXPR_
15468  #undef JSON_HEDLEY_LIKELY
15469  #undef JSON_HEDLEY_MALLOC
15470  #undef JSON_HEDLEY_MCST_LCC_VERSION
15471  #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
15472  #undef JSON_HEDLEY_MESSAGE
15473  #undef JSON_HEDLEY_MSVC_VERSION
15474  #undef JSON_HEDLEY_MSVC_VERSION_CHECK
15475  #undef JSON_HEDLEY_NEVER_INLINE
15476  #undef JSON_HEDLEY_NON_NULL
15477  #undef JSON_HEDLEY_NO_ESCAPE
15478  #undef JSON_HEDLEY_NO_RETURN
15479  #undef JSON_HEDLEY_NO_THROW
15480  #undef JSON_HEDLEY_NULL
15481  #undef JSON_HEDLEY_PELLES_VERSION
15482  #undef JSON_HEDLEY_PELLES_VERSION_CHECK
15483  #undef JSON_HEDLEY_PGI_VERSION
15484  #undef JSON_HEDLEY_PGI_VERSION_CHECK
15485  #undef JSON_HEDLEY_PREDICT
15486  #undef JSON_HEDLEY_PRINTF_FORMAT
15487  #undef JSON_HEDLEY_PRIVATE
15488  #undef JSON_HEDLEY_PUBLIC
15489  #undef JSON_HEDLEY_PURE
15490  #undef JSON_HEDLEY_REINTERPRET_CAST
15491  #undef JSON_HEDLEY_REQUIRE
15492  #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
15493  #undef JSON_HEDLEY_REQUIRE_MSG
15494  #undef JSON_HEDLEY_RESTRICT
15495  #undef JSON_HEDLEY_RETURNS_NON_NULL
15496  #undef JSON_HEDLEY_SENTINEL
15497  #undef JSON_HEDLEY_STATIC_ASSERT
15498  #undef JSON_HEDLEY_STATIC_CAST
15499  #undef JSON_HEDLEY_STRINGIFY
15500  #undef JSON_HEDLEY_STRINGIFY_EX
15501  #undef JSON_HEDLEY_SUNPRO_VERSION
15502  #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
15503  #undef JSON_HEDLEY_TINYC_VERSION
15504  #undef JSON_HEDLEY_TINYC_VERSION_CHECK
15505  #undef JSON_HEDLEY_TI_ARMCL_VERSION
15506  #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
15507  #undef JSON_HEDLEY_TI_CL2000_VERSION
15508  #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
15509  #undef JSON_HEDLEY_TI_CL430_VERSION
15510  #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
15511  #undef JSON_HEDLEY_TI_CL6X_VERSION
15512  #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
15513  #undef JSON_HEDLEY_TI_CL7X_VERSION
15514  #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
15515  #undef JSON_HEDLEY_TI_CLPRU_VERSION
15516  #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
15517  #undef JSON_HEDLEY_TI_VERSION
15518  #undef JSON_HEDLEY_TI_VERSION_CHECK
15519  #undef JSON_HEDLEY_UNAVAILABLE
15520  #undef JSON_HEDLEY_UNLIKELY
15521  #undef JSON_HEDLEY_UNPREDICTABLE
15522  #undef JSON_HEDLEY_UNREACHABLE
15523  #undef JSON_HEDLEY_UNREACHABLE_RETURN
15524  #undef JSON_HEDLEY_VERSION
15525  #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
15526  #undef JSON_HEDLEY_VERSION_DECODE_MINOR
15527  #undef JSON_HEDLEY_VERSION_DECODE_REVISION
15528  #undef JSON_HEDLEY_VERSION_ENCODE
15529  #undef JSON_HEDLEY_WARNING
15530  #undef JSON_HEDLEY_WARN_UNUSED_RESULT
15531  #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
15532  #undef JSON_HEDLEY_FALL_THROUGH
15533  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ultra.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-json.hpp</div>
                </div>
                <div class="column column_space"><pre><code>45      ProdIdFldN=FldNmTyUseTrV.Add(TStrTr("ProductID", "int", "meta"));
46      DateFldN=FldNmTyUseTrV.Add(TStrTr("Date", "date", "active"));
47      HourNFldN=FldNmTyUseTrV.Add(TStrTr("HourStart", "int", "active"));
48      FldNmTyUseTrV.Add(TStrTr("HourEnd", "int", "active"));
49      CsptFldN=FldNmTyUseTrV.Add(TStrTr("Cnsmptn", "int", "active"));
50      VolFldN=FldNmTyUseTrV.Add(TStrTr("VolumeStart", "int", "active"));
51      FldNmTyUseTrV.Add(TStrTr("Interpolation", "int", "active"));
52      CsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1W", "int", "active"));
53      CsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2W", "int", "active"));
54      CsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast3W", "int", "active"));
55      SumCsptLast1WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast1W", "int", "active"));
56      SumCsptLast2WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast2W", "int", "active"));
57      SumCsptLast3WFldN=FldNmTyUseTrV.Add(TStrTr("SumCnsmptnLast3W", "int", "active"));
58      CsptLast1DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast1D", "int", "active"));
59      CsptLast2DFldN=FldNmTyUseTrV.Add(TStrTr("CnsmptnLast2D", "int", "active"));
</pre></code></div>
                <div class="column column_space"><pre><code>12408          result["copyright"] = "(C) 2013-2021 Niels Lohmann";
12409          result["name"] = "JSON for Modern C++";
12410          result["url"] = "https:&bsol;&bsol;github.com/nlohmann/json";
12411          result["version"]["string"] =
12412              std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
12413              std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
12414              std::to_string(NLOHMANN_JSON_VERSION_PATCH);
12415          result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
12416          result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
12417          result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;
12418  #ifdef _WIN32
12419          result["platform"] = "win32";
12420  #elif defined __linux__
12421          result["platform"] = "linux";
12422  #elif defined __APPLE__
12423          result["platform"] = "apple";
12424  #elif defined __unix__
12425          result["platform"] = "unix";
12426  #else
12427          result["platform"] = "unknown";
12428  #endif
12429  #if defined(__ICC) || defined(__INTEL_COMPILER)
12430          result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    