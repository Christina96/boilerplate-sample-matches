
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5316455696202533%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</h3>
            <pre><code>1  #ifndef SPARSEVECTOR_H
2  #define SPARSEVECTOR_H
3  namespace Scintilla::Internal {
4  template <typename T>
5  class SparseVector {
6  private:
7  	Partitioning<Sci::Position> starts;
8  	SplitVector<T> values;
9  	T empty;	
10  	void ClearValue(Sci::Position partition) noexcept {
11  		values.SetValueAt(partition, T());
12  	}
13  public:
14  	SparseVector() : empty() {
15  		starts = Partitioning<Sci::Position>(8);
16  		values = SplitVector<T>();
17  		values.InsertEmpty(0, 2);
18  	}
19  	Sci::Position Length() const noexcept {
20  		return starts.Length();
21  	}
22  	Sci::Position Elements() const noexcept {
23  		return starts.Partitions();
24  	}
25  	Sci::Position PositionOfElement(Sci::Position element) const noexcept {
26  		return starts.PositionFromPartition(element);
27  	}
<span onclick='openModal()' class='match'>28  	Sci::Position ElementFromPosition(Sci::Position position) const noexcept {
29  		if (position < Length()) {
30  			return starts.PartitionFromPosition(position);
31  		} else {
32  			return starts.Partitions();
33  		}
34  	}
</span>35  	const T& ValueAt(Sci::Position position) const noexcept {
36  		assert(position <= Length());
37  		const Sci::Position partition = ElementFromPosition(position);
38  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
39  		if (startPartition == position) {
40  			return values.ValueAt(partition);
41  		} else {
42  			return empty;
43  		}
44  	}
45  	T Extract(Sci::Position position) {
46  		assert(position <= Length());
47  		const Sci::Position partition = ElementFromPosition(position);
48  		assert(partition >= 0);
49  		assert(partition <= starts.Partitions());
50  		assert(starts.PositionFromPartition(partition) == position);
51  		T value = std::move(values.operator[](partition));
52  		if ((partition > 0) && (partition < starts.Partitions())) {
53  			starts.RemovePartition(partition);
54  			values.Delete(partition);
55  		}
56  		Check();
57  		return value;
58  	}
59  	template <typename ParamType>
60  	void SetValueAt(Sci::Position position, ParamType &&value) {
61  		assert(position <= Length());
62  		const Sci::Position partition = ElementFromPosition(position);
63  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
64  		if (value == T()) {
65  			if (position == 0 || position == Length()) {
66  				ClearValue(partition);
67  			} else if (position == startPartition) {
68  				ClearValue(partition);
69  				starts.RemovePartition(partition);
70  				values.Delete(partition);
71  			}
72  		} else {
73  			if (position == startPartition) {
74  				ClearValue(partition);
75  				values.SetValueAt(partition, std::forward<ParamType>(value));
76  			} else {
77  				starts.InsertPartition(partition + 1, position);
78  				values.Insert(partition + 1, std::forward<ParamType>(value));
79  			}
80  		}
81  	}
82  	void InsertSpace(Sci::Position position, Sci::Position insertLength) {
83  		assert(position <= Length());
84  		const Sci::Position partition = starts.PartitionFromPosition(position);
85  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
86  		if (startPartition == position) {
87  			const bool positionOccupied = values.ValueAt(partition) != T();
88  			if (partition == 0) {
89  				if (positionOccupied) {
90  					starts.InsertPartition(1, 0);
91  					values.InsertEmpty(0, 1);
92  				}
93  				starts.InsertText(partition, insertLength);
94  			} else {
95  				if (positionOccupied) {
96  					starts.InsertText(partition - 1, insertLength);
97  				} else {
98  					starts.InsertText(partition, insertLength);
99  				}
100  			}
101  		} else {
102  			starts.InsertText(partition, insertLength);
103  		}
104  	}
105  	void DeletePosition(Sci::Position position) {
106  		assert(position < Length());
107  		Sci::Position partition = starts.PartitionFromPosition(position);
108  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
109  		if (startPartition == position) {
110  			if (partition == 0) {
111  				ClearValue(0);
112  				if (starts.PositionFromPartition(1) == 1) {
113  					if (Elements() > 1) {
114  						starts.RemovePartition(partition + 1);
115  						values.Delete(partition);
116  					}
117  				}
118  			} else if (partition == starts.Partitions()) {
119  				ClearValue(partition);
120  				throw std::runtime_error("SparseVector: deleting end partition.");
121  			} else {
122  				ClearValue(partition);
123  				starts.RemovePartition(partition);
124  				values.Delete(partition);
125  				partition--;
126  			}
127  		}
128  		starts.InsertText(partition, -1);
129  		Check();
130  	}
131  	void DeleteAll() {
132  		starts = Partitioning<Sci::Position>(8);
133  		values = SplitVector<T>();
134  		values.InsertEmpty(0, 2);
135  	}
136  	void DeleteRange(Sci::Position position, Sci::Position deleteLength) {
137  		if (position > Length() || (deleteLength == 0)) {
138  			return;
139  		}
140  		const Sci::Position positionEnd = position + deleteLength;
141  		assert(positionEnd <= Length());
142  		if (position == 0) {
143  			while ((Elements() > 1) && (starts.PositionFromPartition(1) <= deleteLength)) {
144  				starts.RemovePartition(1);
145  				values.Delete(0);
146  			}
147  			starts.InsertText(0, -deleteLength);
148  			if (Length() == 0) {
149  				ClearValue(0);
150  			}
151  		} else {
152  			const Sci::Position partition = starts.PartitionFromPosition(position);
153  			const bool atPartitionStart = position == starts.PositionFromPartition(partition);
154  			const Sci::Position partitionDelete = partition + (atPartitionStart ? 0 : 1);
155  			assert(partitionDelete > 0);
156  			for (;;) {
157  				const Sci::Position positionAtIndex = starts.PositionFromPartition(partitionDelete);
158  				assert(position <= positionAtIndex);
159  				if (positionAtIndex >= positionEnd) {
160  					break;
161  				}
162  				assert(partitionDelete <= Elements());
163  				starts.RemovePartition(partitionDelete);
164  				values.Delete(partitionDelete);
165  			}
166  			starts.InsertText(partition - (atPartitionStart ? 1 : 0), -deleteLength);
167  		}
168  		Check();
169  	}
170  	Sci::Position PositionNext(Sci::Position start) const noexcept {
171  		const Sci::Position element = ElementFromPosition(start);
172  		if (element < Elements()) {
173  			return PositionOfElement(element + 1);
174  		}
175  		return Length() + 1;	
176  	}
177  	Sci::Position IndexAfter(Sci::Position position) const noexcept {
178  		assert(position < Length());
179  		if (position < 0)
180  			return 0;
181  		const Sci::Position partition = starts.PartitionFromPosition(position);
182  		return partition + 1;
183  	}
184  	void Check() const {
185  #ifdef CHECK_CORRECTNESS
186  		starts.Check();
187  		if (starts.Partitions() != values.Length() - 1) {
188  			throw std::runtime_error("SparseVector: Partitions and values different lengths.");
189  		}
190  #endif
191  	}
192  };
193  }
194  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_test.cc</h3>
            <pre><code>1  #include "absl/strings/cord.h"
2  #include <algorithm>
3  #include <climits>
4  #include <cstdio>
5  #include <iterator>
6  #include <map>
7  #include <numeric>
8  #include <random>
9  #include <sstream>
10  #include <type_traits>
11  #include <utility>
12  #include <vector>
13  #include "gmock/gmock.h"
14  #include "gtest/gtest.h"
15  #include "absl/base/config.h"
16  #include "absl/base/internal/endian.h"
17  #include "absl/base/macros.h"
18  #include "absl/container/fixed_array.h"
19  #include "absl/hash/hash.h"
20  #include "absl/log/check.h"
21  #include "absl/log/log.h"
22  #include "absl/random/random.h"
23  #include "absl/strings/cord_test_helpers.h"
24  #include "absl/strings/cordz_test_helpers.h"
25  #include "absl/strings/match.h"
26  #include "absl/strings/str_cat.h"
27  #include "absl/strings/str_format.h"
28  #include "absl/strings/string_view.h"
29  static constexpr auto FLAT = absl::cord_internal::FLAT;
30  static constexpr auto MAX_FLAT_TAG = absl::cord_internal::MAX_FLAT_TAG;
31  typedef std::mt19937_64 RandomEngine;
32  using absl::cord_internal::CordRep;
33  using absl::cord_internal::CordRepBtree;
34  using absl::cord_internal::CordRepConcat;
35  using absl::cord_internal::CordRepCrc;
36  using absl::cord_internal::CordRepExternal;
37  using absl::cord_internal::CordRepFlat;
38  using absl::cord_internal::CordRepSubstring;
39  using absl::cord_internal::CordzUpdateTracker;
40  using absl::cord_internal::kFlatOverhead;
41  using absl::cord_internal::kMaxFlatLength;
42  using ::testing::ElementsAre;
43  using ::testing::Le;
44  static std::string RandomLowercaseString(RandomEngine* rng);
45  static std::string RandomLowercaseString(RandomEngine* rng, size_t length);
46  static int GetUniformRandomUpTo(RandomEngine* rng, int upper_bound) {
47    if (upper_bound > 0) {
48      std::uniform_int_distribution<int> uniform(0, upper_bound - 1);
49      return uniform(*rng);
50    } else {
51      return 0;
52    }
53  }
<span onclick='openModal()' class='match'>54  static size_t GetUniformRandomUpTo(RandomEngine* rng, size_t upper_bound) {
55    if (upper_bound > 0) {
56      std::uniform_int_distribution<size_t> uniform(0, upper_bound - 1);
57      return uniform(*rng);
58    } else {
59      return 0;
60    }
61  }
</span>62  static int32_t GenerateSkewedRandom(RandomEngine* rng, int max_log) {
63    const uint32_t base = (*rng)() % (max_log + 1);
64    const uint32_t mask = ((base < 32) ? (1u << base) : 0u) - 1u;
65    return (*rng)() & mask;
66  }
67  static std::string RandomLowercaseString(RandomEngine* rng) {
68    int length;
69    std::bernoulli_distribution one_in_1k(0.001);
70    std::bernoulli_distribution one_in_10k(0.0001);
71    if (one_in_10k(*rng)) {
72      length = GetUniformRandomUpTo(rng, 1048576);
73    } else if (one_in_1k(*rng)) {
74      length = GetUniformRandomUpTo(rng, 10000);
75    } else {
76      length = GenerateSkewedRandom(rng, 10);
77    }
78    return RandomLowercaseString(rng, length);
79  }
80  static std::string RandomLowercaseString(RandomEngine* rng, size_t length) {
81    std::string result(length, '\0');
82    std::uniform_int_distribution<int> chars('a', 'z');
83    std::generate(result.begin(), result.end(),
84                  [&]() { return static_cast<char>(chars(*rng)); });
85    return result;
86  }
87  static void DoNothing(absl::string_view &bsol;* data */, void* &bsol;* arg */) {}
88  static void DeleteExternalString(absl::string_view data, void* arg) {
89    std::string* s = reinterpret_cast<std::string*>(arg);
90    EXPECT_EQ(data, *s);
91    delete s;
92  }
93  static void AddExternalMemory(absl::string_view s, absl::Cord* dst) {
94    std::string* str = new std::string(s.data(), s.size());
95    dst->Append(absl::MakeCordFromExternal(*str, [str](absl::string_view data) {
96      DeleteExternalString(data, str);
97    }));
98  }
99  static void DumpGrowth() {
100    absl::Cord str;
101    for (int i = 0; i < 1000; i++) {
102      char c = 'a' + i % 26;
103      str.Append(absl::string_view(&c, 1));
104    }
105  }
106  static size_t AppendWithFragments(const std::string& s, RandomEngine* rng,
107                                    absl::Cord* cord) {
108    size_t j = 0;
109    const size_t max_size = s.size() / 5;  
110    size_t min_size = max_size;            
111    while (j < s.size()) {
112      size_t N = 1 + GetUniformRandomUpTo(rng, max_size);
113      if (N > (s.size() - j)) {
114        N = s.size() - j;
115      }
116      if (N < min_size) {
117        min_size = N;
118      }
119      std::bernoulli_distribution coin_flip(0.5);
120      if (coin_flip(*rng)) {
121        AddExternalMemory(absl::string_view(s.data() + j, N), cord);
122      } else {
123        cord->Append(absl::string_view(s.data() + j, N));
124      }
125      j += N;
126    }
127    return min_size;
128  }
129  static void AddNewStringBlock(const std::string& str, absl::Cord* dst) {
130    char* data = new char[str.size()];
131    memcpy(data, str.data(), str.size());
132    dst->Append(absl::MakeCordFromExternal(
133        absl::string_view(data, str.size()),
134        [](absl::string_view s) { delete[] s.data(); }));
135  }
136  static absl::Cord MakeComposite() {
137    absl::Cord cord;
138    cord.Append("the");
139    AddExternalMemory(" quick brown", &cord);
140    AddExternalMemory(" fox jumped", &cord);
141    absl::Cord full(" over");
142    AddExternalMemory(" the lazy", &full);
143    AddNewStringBlock(" dog slept the whole day away", &full);
144    absl::Cord substring = full.Subcord(0, 18);
145    substring.Append(std::string(1000, '.'));
146    cord.Append(substring);
147    cord = cord.Subcord(0, cord.size() - 998);  
148    return cord;
149  }
150  namespace absl {
151  ABSL_NAMESPACE_BEGIN
152  class CordTestPeer {
153   public:
154    static void ForEachChunk(
155        const Cord& c, absl::FunctionRef<void(absl::string_view)> callback) {
156      c.ForEachChunk(callback);
157    }
158    static bool IsTree(const Cord& c) { return c.contents_.is_tree(); }
159    static CordRep* Tree(const Cord& c) { return c.contents_.tree(); }
160    static cord_internal::CordzInfo* GetCordzInfo(const Cord& c) {
161      return c.contents_.cordz_info();
162    }
163    static Cord MakeSubstring(Cord src, size_t offset, size_t length) {
164      CHECK(src.contents_.is_tree()) << "Can not be inlined";
165      CHECK(!src.ExpectedChecksum().has_value()) << "Can not be hardened";
166      Cord cord;
167      auto* tree = cord_internal::SkipCrcNode(src.contents_.tree());
168      auto* rep = CordRepSubstring::Create(CordRep::Ref(tree), offset, length);
169      cord.contents_.EmplaceTree(rep, CordzUpdateTracker::kSubCord);
170      return cord;
171    }
172  };
173  ABSL_NAMESPACE_END
174  }  
175  class CordTest : public testing::TestWithParam<int> {
176   public:
177    bool UseCrc() const { return GetParam() == 2 || GetParam() == 3; }
178    void MaybeHarden(absl::Cord& c) {
179      if (UseCrc()) {
180        c.SetExpectedChecksum(1);
181      }
182    }
183    absl::Cord MaybeHardened(absl::Cord c) {
184      MaybeHarden(c);
185      return c;
186    }
187    static std::string ToString(testing::TestParamInfo<int> param) {
188      switch (param.param) {
189        case 0:
190          return "Btree";
191        case 1:
192          return "BtreeHardened";
193        default:
194          assert(false);
195          return "???";
196      }
197    }
198  };
199  INSTANTIATE_TEST_SUITE_P(WithParam, CordTest, testing::Values(0, 1),
200                           CordTest::ToString);
201  TEST(CordRepFlat, AllFlatCapacities) {
202    static_assert(absl::cord_internal::kFlatOverhead < 32, "");
203    static_assert(absl::cord_internal::kMinFlatSize == 32, "");
204    static_assert(absl::cord_internal::kMaxLargeFlatSize == 256 << 10, "");
205    EXPECT_EQ(absl::cord_internal::TagToAllocatedSize(FLAT), 32);
206    EXPECT_EQ(absl::cord_internal::TagToAllocatedSize(MAX_FLAT_TAG), 256 << 10);
207    size_t last_size = 0;
208    for (int tag = FLAT; tag <= MAX_FLAT_TAG; ++tag) {
209      size_t size = absl::cord_internal::TagToAllocatedSize(tag);
210      ASSERT_GT(size, last_size);
211      ASSERT_EQ(absl::cord_internal::TagToAllocatedSize(tag), size);
212      last_size = size;
213    }
214    for (size_t size = 32; size <= 512; size += 8) {
215      ASSERT_EQ(absl::cord_internal::RoundUpForTag(size), size);
216      uint8_t tag = absl::cord_internal::AllocatedSizeToTag(size);
217      ASSERT_EQ(absl::cord_internal::TagToAllocatedSize(tag), size);
218    }
219    for (size_t size = 512; size <= 8192; size += 64) {
220      ASSERT_EQ(absl::cord_internal::RoundUpForTag(size), size);
221      uint8_t tag = absl::cord_internal::AllocatedSizeToTag(size);
222      ASSERT_EQ(absl::cord_internal::TagToAllocatedSize(tag), size);
223    }
224    for (size_t size = 8192; size <= 256 * 1024; size += 4 * 1024) {
225      ASSERT_EQ(absl::cord_internal::RoundUpForTag(size), size);
226      uint8_t tag = absl::cord_internal::AllocatedSizeToTag(size);
227      ASSERT_EQ(absl::cord_internal::TagToAllocatedSize(tag), size);
228    }
229  }
230  TEST(CordRepFlat, MaxFlatSize) {
231    CordRepFlat* flat = CordRepFlat::New(kMaxFlatLength);
232    EXPECT_EQ(flat->Capacity(), kMaxFlatLength);
233    CordRep::Unref(flat);
234    flat = CordRepFlat::New(kMaxFlatLength * 4);
235    EXPECT_EQ(flat->Capacity(), kMaxFlatLength);
236    CordRep::Unref(flat);
237  }
238  TEST(CordRepFlat, MaxLargeFlatSize) {
239    const size_t size = 256 * 1024 - kFlatOverhead;
240    CordRepFlat* flat = CordRepFlat::New(CordRepFlat::Large(), size);
241    EXPECT_GE(flat->Capacity(), size);
242    CordRep::Unref(flat);
243  }
244  TEST(CordRepFlat, AllFlatSizes) {
245    const size_t kMaxSize = 256 * 1024;
246    for (size_t size = 32; size <= kMaxSize; size *=2) {
247      const size_t length = size - kFlatOverhead - 1;
248      CordRepFlat* flat = CordRepFlat::New(CordRepFlat::Large(), length);
249      EXPECT_GE(flat->Capacity(), length);
250      memset(flat->Data(), 0xCD, flat->Capacity());
251      CordRep::Unref(flat);
252    }
253  }
254  TEST_P(CordTest, AllFlatSizes) {
255    using absl::strings_internal::CordTestAccess;
256    for (size_t s = 0; s < CordTestAccess::MaxFlatLength(); s++) {
257      std::string src;
258      while (src.size() < s) {
259        src.push_back('a' + (src.size() % 26));
260      }
261      absl::Cord dst(src);
262      MaybeHarden(dst);
263      EXPECT_EQ(std::string(dst), src) << s;
264    }
265  }
266  TEST_P(CordTest, GigabyteCordFromExternal) {
267    const size_t one_gig = 1024U * 1024U * 1024U;
268    size_t max_size = 2 * one_gig;
269    if (sizeof(max_size) > 4) max_size = 128 * one_gig;
270    size_t length = 128 * 1024;
271    char* data = new char[length];
272    absl::Cord from = absl::MakeCordFromExternal(
273        absl::string_view(data, length),
274        [](absl::string_view sv) { delete[] sv.data(); });
275    absl::Cord c;
276    c.Append(from);
277    while (c.size() < max_size) {
278      c.Append(c);
279      c.Append(from);
280      c.Append(from);
281      c.Append(from);
282      c.Append(from);
283      MaybeHarden(c);
284    }
285    for (int i = 0; i < 1024; ++i) {
286      c.Append(from);
287    }
288    LOG(INFO) << "Made a Cord with " << c.size() << " bytes!";
289  }
290  static absl::Cord MakeExternalCord(int size) {
291    char* buffer = new char[size];
292    memset(buffer, 'x', size);
293    absl::Cord cord;
294    cord.Append(absl::MakeCordFromExternal(
295        absl::string_view(buffer, size),
296        [](absl::string_view s) { delete[] s.data(); }));
297    return cord;
298  }
299  extern bool my_unique_true_boolean;
300  bool my_unique_true_boolean = true;
301  TEST_P(CordTest, Assignment) {
302    absl::Cord x(absl::string_view("hi there"));
303    absl::Cord y(x);
304    MaybeHarden(y);
305    ASSERT_EQ(x.ExpectedChecksum(), absl::nullopt);
306    ASSERT_EQ(std::string(x), "hi there");
307    ASSERT_EQ(std::string(y), "hi there");
308    ASSERT_TRUE(x == y);
309    ASSERT_TRUE(x <= y);
310    ASSERT_TRUE(y <= x);
311    x = absl::string_view("foo");
312    ASSERT_EQ(std::string(x), "foo");
313    ASSERT_EQ(std::string(y), "hi there");
314    ASSERT_TRUE(x < y);
315    ASSERT_TRUE(y > x);
316    ASSERT_TRUE(x != y);
317    ASSERT_TRUE(x <= y);
318    ASSERT_TRUE(y >= x);
319    x = "foo";
320    ASSERT_EQ(x, "foo");
321    std::vector<std::pair<absl::string_view, absl::string_view>>
322        test_string_pairs = {{"hi there", "foo"},
323                             {"loooooong coooooord", "short cord"},
324                             {"short cord", "loooooong coooooord"},
325                             {"loooooong coooooord1", "loooooong coooooord2"}};
326    for (std::pair<absl::string_view, absl::string_view> test_strings :
327         test_string_pairs) {
328      absl::Cord tmp(test_strings.first);
329      absl::Cord z(std::move(tmp));
330      ASSERT_EQ(std::string(z), test_strings.first);
331      tmp = test_strings.second;
332      z = std::move(tmp);
333      ASSERT_EQ(std::string(z), test_strings.second);
334    }
335    {
336      absl::Cord my_small_cord("foo");
337      absl::Cord my_big_cord("loooooong coooooord");
338      absl::Cord* my_small_alias =
339          my_unique_true_boolean ? &my_small_cord : &my_big_cord;
340      absl::Cord* my_big_alias =
341          !my_unique_true_boolean ? &my_small_cord : &my_big_cord;
342      *my_small_alias = std::move(my_small_cord);
343      *my_big_alias = std::move(my_big_cord);
344    }
345  }
346  TEST_P(CordTest, StartsEndsWith) {
347    absl::Cord x(absl::string_view("abcde"));
348    MaybeHarden(x);
349    absl::Cord empty("");
350    ASSERT_TRUE(x.StartsWith(absl::Cord("abcde")));
351    ASSERT_TRUE(x.StartsWith(absl::Cord("abc")));
352    ASSERT_TRUE(x.StartsWith(absl::Cord("")));
353    ASSERT_TRUE(empty.StartsWith(absl::Cord("")));
354    ASSERT_TRUE(x.EndsWith(absl::Cord("abcde")));
355    ASSERT_TRUE(x.EndsWith(absl::Cord("cde")));
356    ASSERT_TRUE(x.EndsWith(absl::Cord("")));
357    ASSERT_TRUE(empty.EndsWith(absl::Cord("")));
358    ASSERT_TRUE(!x.StartsWith(absl::Cord("xyz")));
359    ASSERT_TRUE(!empty.StartsWith(absl::Cord("xyz")));
360    ASSERT_TRUE(!x.EndsWith(absl::Cord("xyz")));
361    ASSERT_TRUE(!empty.EndsWith(absl::Cord("xyz")));
362    ASSERT_TRUE(x.StartsWith("abcde"));
363    ASSERT_TRUE(x.StartsWith("abc"));
364    ASSERT_TRUE(x.StartsWith(""));
365    ASSERT_TRUE(empty.StartsWith(""));
366    ASSERT_TRUE(x.EndsWith("abcde"));
367    ASSERT_TRUE(x.EndsWith("cde"));
368    ASSERT_TRUE(x.EndsWith(""));
369    ASSERT_TRUE(empty.EndsWith(""));
370    ASSERT_TRUE(!x.StartsWith("xyz"));
371    ASSERT_TRUE(!empty.StartsWith("xyz"));
372    ASSERT_TRUE(!x.EndsWith("xyz"));
373    ASSERT_TRUE(!empty.EndsWith("xyz"));
374  }
375  TEST_P(CordTest, Subcord) {
376    RandomEngine rng(GTEST_FLAG_GET(random_seed));
377    const std::string s = RandomLowercaseString(&rng, 1024);
378    absl::Cord a;
379    AppendWithFragments(s, &rng, &a);
380    MaybeHarden(a);
381    ASSERT_EQ(s, std::string(a));
382    std::set<size_t> positions;
383    for (int i = 0; i <= 32; ++i) {
384      positions.insert(i);
385      positions.insert(i * 32 - 1);
386      positions.insert(i * 32);
387      positions.insert(i * 32 + 1);
388      positions.insert(a.size() - i);
389    }
390    positions.insert(237);
391    positions.insert(732);
392    for (size_t pos : positions) {
393      if (pos > a.size()) continue;
394      for (size_t end_pos : positions) {
395        if (end_pos < pos || end_pos > a.size()) continue;
396        absl::Cord sa = a.Subcord(pos, end_pos - pos);
397        ASSERT_EQ(absl::string_view(s).substr(pos, end_pos - pos),
398                  std::string(sa))
399            << a;
400        if (pos != 0 || end_pos != a.size()) {
401          ASSERT_EQ(sa.ExpectedChecksum(), absl::nullopt);
402        }
403      }
404    }
405    const std::string sh = "short";
406    absl::Cord c(sh);
407    for (size_t pos = 0; pos <= sh.size(); ++pos) {
408      for (size_t n = 0; n <= sh.size() - pos; ++n) {
409        absl::Cord sc = c.Subcord(pos, n);
410        ASSERT_EQ(sh.substr(pos, n), std::string(sc)) << c;
411      }
412    }
413    absl::Cord sa = a.Subcord(0, a.size());
414    std::string ss = s.substr(0, s.size());
415    while (sa.size() > 1) {
416      sa = sa.Subcord(1, sa.size() - 2);
417      ss = ss.substr(1, ss.size() - 2);
418      ASSERT_EQ(ss, std::string(sa)) << a;
419      if (HasFailure()) break;  
420    }
421    sa = a.Subcord(0, a.size() + 1);
422    EXPECT_EQ(s, std::string(sa));
423    sa = a.Subcord(a.size() + 1, 0);
424    EXPECT_TRUE(sa.empty());
425    sa = a.Subcord(a.size() + 1, 1);
426    EXPECT_TRUE(sa.empty());
427  }
428  TEST_P(CordTest, Swap) {
429    absl::string_view a("Dexter");
430    absl::string_view b("Mandark");
431    absl::Cord x(a);
432    absl::Cord y(b);
433    MaybeHarden(x);
434    swap(x, y);
435    if (UseCrc()) {
436      ASSERT_EQ(x.ExpectedChecksum(), absl::nullopt);
437      ASSERT_EQ(y.ExpectedChecksum(), 1);
438    }
439    ASSERT_EQ(x, absl::Cord(b));
440    ASSERT_EQ(y, absl::Cord(a));
441    x.swap(y);
442    if (UseCrc()) {
443      ASSERT_EQ(x.ExpectedChecksum(), 1);
444      ASSERT_EQ(y.ExpectedChecksum(), absl::nullopt);
445    }
446    ASSERT_EQ(x, absl::Cord(a));
447    ASSERT_EQ(y, absl::Cord(b));
448  }
449  static void VerifyCopyToString(const absl::Cord& cord) {
450    std::string initially_empty;
451    absl::CopyCordToString(cord, &initially_empty);
452    EXPECT_EQ(initially_empty, cord);
453    constexpr size_t kInitialLength = 1024;
454    std::string has_initial_contents(kInitialLength, 'x');
455    const char* address_before_copy = has_initial_contents.data();
456    absl::CopyCordToString(cord, &has_initial_contents);
457    EXPECT_EQ(has_initial_contents, cord);
458    if (cord.size() <= kInitialLength) {
459      EXPECT_EQ(has_initial_contents.data(), address_before_copy)
460          << "CopyCordToString allocated new string storage; "
461             "has_initial_contents = \""
462          << has_initial_contents << "\"";
463    }
464  }
465  TEST_P(CordTest, CopyToString) {
466    VerifyCopyToString(absl::Cord());  
467    VerifyCopyToString(MaybeHardened(absl::Cord("small cord")));
468    VerifyCopyToString(MaybeHardened(
469        absl::MakeFragmentedCord({"fragmented ", "cord ", "to ", "test ",
470                                  "copying ", "to ", "a ", "string."})));
471  }
472  TEST_P(CordTest, AppendEmptyBuffer) {
473    absl::Cord cord;
474    cord.Append(absl::CordBuffer());
475    cord.Append(absl::CordBuffer::CreateWithDefaultLimit(2000));
476  }
477  TEST_P(CordTest, AppendEmptyBufferToFlat) {
478    absl::Cord cord(std::string(2000, 'x'));
479    cord.Append(absl::CordBuffer());
480    cord.Append(absl::CordBuffer::CreateWithDefaultLimit(2000));
481  }
482  TEST_P(CordTest, AppendEmptyBufferToTree) {
483    absl::Cord cord(std::string(2000, 'x'));
484    cord.Append(std::string(2000, 'y'));
485    cord.Append(absl::CordBuffer());
486    cord.Append(absl::CordBuffer::CreateWithDefaultLimit(2000));
487  }
488  TEST_P(CordTest, AppendSmallBuffer) {
489    absl::Cord cord;
490    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
491    ASSERT_THAT(buffer.capacity(), Le(15));
492    memcpy(buffer.data(), "Abc", 3);
493    buffer.SetLength(3);
494    cord.Append(std::move(buffer));
495    EXPECT_EQ(buffer.length(), 0);    
496    EXPECT_GT(buffer.capacity(), 0);  
497    buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
498    memcpy(buffer.data(), "defgh", 5);
499    buffer.SetLength(5);
500    cord.Append(std::move(buffer));
501    EXPECT_EQ(buffer.length(), 0);    
502    EXPECT_GT(buffer.capacity(), 0);  
503    EXPECT_THAT(cord.Chunks(), ElementsAre("Abcdefgh"));
504  }
505  TEST_P(CordTest, AppendAndPrependBufferArePrecise) {
506    std::string test_data(absl::cord_internal::kMaxFlatLength * 10, 'x');
507    absl::Cord cord1(test_data);
508    absl::Cord cord2(test_data);
509    const size_t size1 = cord1.EstimatedMemoryUsage();
510    const size_t size2 = cord2.EstimatedMemoryUsage();
511    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
512    memcpy(buffer.data(), "Abc", 3);
513    buffer.SetLength(3);
514    cord1.Append(std::move(buffer));
515    buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
516    memcpy(buffer.data(), "Abc", 3);
517    buffer.SetLength(3);
518    cord2.Prepend(std::move(buffer));
519  #ifndef NDEBUG
520    constexpr size_t kMaxDelta = 128 + 32;
521  #else
522    constexpr size_t kMaxDelta = 128 + 32 + 256;
523  #endif
524    EXPECT_LE(cord1.EstimatedMemoryUsage() - size1, kMaxDelta);
525    EXPECT_LE(cord2.EstimatedMemoryUsage() - size2, kMaxDelta);
526    EXPECT_EQ(cord1, absl::StrCat(test_data, "Abc"));
527    EXPECT_EQ(cord2, absl::StrCat("Abc", test_data));
528  }
529  TEST_P(CordTest, PrependSmallBuffer) {
530    absl::Cord cord;
531    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
532    ASSERT_THAT(buffer.capacity(), Le(15));
533    memcpy(buffer.data(), "Abc", 3);
534    buffer.SetLength(3);
535    cord.Prepend(std::move(buffer));
536    EXPECT_EQ(buffer.length(), 0);    
537    EXPECT_GT(buffer.capacity(), 0);  
538    buffer = absl::CordBuffer::CreateWithDefaultLimit(3);
539    memcpy(buffer.data(), "defgh", 5);
540    buffer.SetLength(5);
541    cord.Prepend(std::move(buffer));
542    EXPECT_EQ(buffer.length(), 0);    
543    EXPECT_GT(buffer.capacity(), 0);  
544    EXPECT_THAT(cord.Chunks(), ElementsAre("defghAbc"));
545  }
546  TEST_P(CordTest, AppendLargeBuffer) {
547    absl::Cord cord;
548    std::string s1(700, '1');
549    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(s1.size());
550    memcpy(buffer.data(), s1.data(), s1.size());
551    buffer.SetLength(s1.size());
552    cord.Append(std::move(buffer));
553    EXPECT_EQ(buffer.length(), 0);    
554    EXPECT_GT(buffer.capacity(), 0);  
555    std::string s2(1000, '2');
556    buffer = absl::CordBuffer::CreateWithDefaultLimit(s2.size());
557    memcpy(buffer.data(), s2.data(), s2.size());
558    buffer.SetLength(s2.size());
559    cord.Append(std::move(buffer));
560    EXPECT_EQ(buffer.length(), 0);    
561    EXPECT_GT(buffer.capacity(), 0);  
562    EXPECT_THAT(cord.Chunks(), ElementsAre(s1, s2));
563  }
564  TEST_P(CordTest, PrependLargeBuffer) {
565    absl::Cord cord;
566    std::string s1(700, '1');
567    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(s1.size());
568    memcpy(buffer.data(), s1.data(), s1.size());
569    buffer.SetLength(s1.size());
570    cord.Prepend(std::move(buffer));
571    EXPECT_EQ(buffer.length(), 0);    
572    EXPECT_GT(buffer.capacity(), 0);  
573    std::string s2(1000, '2');
574    buffer = absl::CordBuffer::CreateWithDefaultLimit(s2.size());
575    memcpy(buffer.data(), s2.data(), s2.size());
576    buffer.SetLength(s2.size());
577    cord.Prepend(std::move(buffer));
578    EXPECT_EQ(buffer.length(), 0);    
579    EXPECT_GT(buffer.capacity(), 0);  
580    EXPECT_THAT(cord.Chunks(), ElementsAre(s2, s1));
581  }
582  class CordAppendBufferTest : public testing::TestWithParam<bool> {
583   public:
584    size_t is_default() const { return GetParam(); }
585    static std::string ToString(testing::TestParamInfo<bool> param) {
586      return param.param ? "DefaultLimit" : "CustomLimit";
587    }
588    size_t limit() const {
589      return is_default() ? absl::CordBuffer::kDefaultLimit
590                          : absl::CordBuffer::kCustomLimit;
591    }
592    size_t maximum_payload() const {
593      return is_default() ? absl::CordBuffer::MaximumPayload()
594                          : absl::CordBuffer::MaximumPayload(limit());
595    }
596    absl::CordBuffer GetAppendBuffer(absl::Cord& cord, size_t capacity,
597                                     size_t min_capacity = 16) {
598      return is_default()
599                 ? cord.GetAppendBuffer(capacity, min_capacity)
600                 : cord.GetCustomAppendBuffer(limit(), capacity, min_capacity);
601    }
602  };
603  INSTANTIATE_TEST_SUITE_P(WithParam, CordAppendBufferTest, testing::Bool(),
604                           CordAppendBufferTest::ToString);
605  TEST_P(CordAppendBufferTest, GetAppendBufferOnEmptyCord) {
606    absl::Cord cord;
607    absl::CordBuffer buffer = GetAppendBuffer(cord, 1000);
608    EXPECT_GE(buffer.capacity(), 1000);
609    EXPECT_EQ(buffer.length(), 0);
610  }
611  TEST_P(CordAppendBufferTest, GetAppendBufferOnInlinedCord) {
612    static constexpr int kInlinedSize = sizeof(absl::CordBuffer) - 1;
613    for (int size : {6, kInlinedSize - 3, kInlinedSize - 2, 1000}) {
614      absl::Cord cord("Abc");
615      absl::CordBuffer buffer = GetAppendBuffer(cord, size, 1);
616      EXPECT_GE(buffer.capacity(), 3 + size);
617      EXPECT_EQ(buffer.length(), 3);
618      EXPECT_EQ(absl::string_view(buffer.data(), buffer.length()), "Abc");
619      EXPECT_TRUE(cord.empty());
620    }
621  }
622  TEST_P(CordAppendBufferTest, GetAppendBufferOnInlinedCordCapacityCloseToMax) {
623    for (size_t dist_from_max = 0; dist_from_max <= 4; ++dist_from_max) {
624      absl::Cord cord("Abc");
625      size_t size = std::numeric_limits<size_t>::max() - dist_from_max;
626      absl::CordBuffer buffer = GetAppendBuffer(cord, size, 1);
627      EXPECT_GE(buffer.capacity(), maximum_payload());
628      EXPECT_EQ(buffer.length(), 3);
629      EXPECT_EQ(absl::string_view(buffer.data(), buffer.length()), "Abc");
630      EXPECT_TRUE(cord.empty());
631    }
632  }
633  TEST_P(CordAppendBufferTest, GetAppendBufferOnFlat) {
634    absl::Cord cord;
635    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
636    const size_t expected_capacity = buffer.capacity();
637    buffer.SetLength(3);
638    memcpy(buffer.data(), "Abc", 3);
639    cord.Append(std::move(buffer));
640    buffer = GetAppendBuffer(cord, 6);
641    EXPECT_EQ(buffer.capacity(), expected_capacity);
642    EXPECT_EQ(buffer.length(), 3);
643    EXPECT_EQ(absl::string_view(buffer.data(), buffer.length()), "Abc");
644    EXPECT_TRUE(cord.empty());
645  }
646  TEST_P(CordAppendBufferTest, GetAppendBufferOnFlatWithoutMinCapacity) {
647    absl::Cord cord;
648    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
649    buffer.SetLength(30);
650    memset(buffer.data(), 'x', 30);
651    cord.Append(std::move(buffer));
652    buffer = GetAppendBuffer(cord, 1000, 900);
653    EXPECT_GE(buffer.capacity(), 1000);
654    EXPECT_EQ(buffer.length(), 0);
655    EXPECT_EQ(cord, std::string(30, 'x'));
656  }
657  TEST_P(CordAppendBufferTest, GetAppendBufferOnTree) {
658    RandomEngine rng;
659    for (int num_flats : {2, 3, 100}) {
660      absl::Cord cord;
661      std::string prefix;
662      std::string last;
663      for (int i = 0; i < num_flats - 1; ++i) {
664        prefix += last;
665        last = RandomLowercaseString(&rng, 10);
666        absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
667        buffer.SetLength(10);
668        memcpy(buffer.data(), last.data(), 10);
669        cord.Append(std::move(buffer));
670      }
671      absl::CordBuffer buffer = GetAppendBuffer(cord, 6);
672      EXPECT_GE(buffer.capacity(), 500);
673      EXPECT_EQ(buffer.length(), 10);
674      EXPECT_EQ(absl::string_view(buffer.data(), buffer.length()), last);
675      EXPECT_EQ(cord, prefix);
676    }
677  }
678  TEST_P(CordAppendBufferTest, GetAppendBufferOnTreeWithoutMinCapacity) {
679    absl::Cord cord;
680    for (int i = 0; i < 2; ++i) {
681      absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
682      buffer.SetLength(3);
683      memcpy(buffer.data(), i ? "def" : "Abc", 3);
684      cord.Append(std::move(buffer));
685    }
686    absl::CordBuffer buffer = GetAppendBuffer(cord, 1000, 900);
687    EXPECT_GE(buffer.capacity(), 1000);
688    EXPECT_EQ(buffer.length(), 0);
689    EXPECT_EQ(cord, "Abcdef");
690  }
691  TEST_P(CordAppendBufferTest, GetAppendBufferOnSubstring) {
692    absl::Cord cord;
693    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
694    buffer.SetLength(450);
695    memset(buffer.data(), 'x', 450);
696    cord.Append(std::move(buffer));
697    cord.RemovePrefix(1);
698    buffer = GetAppendBuffer(cord, 6);
699    EXPECT_EQ(buffer.length(), 0);
700    EXPECT_EQ(cord, std::string(449, 'x'));
701  }
702  TEST_P(CordAppendBufferTest, GetAppendBufferOnSharedCord) {
703    absl::Cord cord;
704    absl::CordBuffer buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
705    buffer.SetLength(3);
706    memcpy(buffer.data(), "Abc", 3);
707    cord.Append(std::move(buffer));
708    absl::Cord shared_cord = cord;
709    buffer = GetAppendBuffer(cord, 6);
710    EXPECT_EQ(buffer.length(), 0);
711    EXPECT_EQ(cord, "Abc");
712    buffer = absl::CordBuffer::CreateWithDefaultLimit(500);
713    buffer.SetLength(3);
714    memcpy(buffer.data(), "def", 3);
715    cord.Append(std::move(buffer));
716    shared_cord = cord;
717    buffer = GetAppendBuffer(cord, 6);
718    EXPECT_EQ(buffer.length(), 0);
719    EXPECT_EQ(cord, "Abcdef");
720  }
721  TEST_P(CordTest, TryFlatEmpty) {
722    absl::Cord c;
723    EXPECT_EQ(c.TryFlat(), "");
724  }
725  TEST_P(CordTest, TryFlatFlat) {
726    absl::Cord c("hello");
727    MaybeHarden(c);
728    EXPECT_EQ(c.TryFlat(), "hello");
729  }
730  TEST_P(CordTest, TryFlatSubstrInlined) {
731    absl::Cord c("hello");
732    c.RemovePrefix(1);
733    MaybeHarden(c);
734    EXPECT_EQ(c.TryFlat(), "ello");
735  }
736  TEST_P(CordTest, TryFlatSubstrFlat) {
737    absl::Cord c("longer than 15 bytes");
738    absl::Cord sub = absl::CordTestPeer::MakeSubstring(c, 1, c.size() - 1);
739    MaybeHarden(sub);
740    EXPECT_EQ(sub.TryFlat(), "onger than 15 bytes");
741  }
742  TEST_P(CordTest, TryFlatConcat) {
743    absl::Cord c = absl::MakeFragmentedCord({"hel", "lo"});
744    MaybeHarden(c);
745    EXPECT_EQ(c.TryFlat(), absl::nullopt);
746  }
747  TEST_P(CordTest, TryFlatExternal) {
748    absl::Cord c = absl::MakeCordFromExternal("hell", [](absl::string_view) {});
749    MaybeHarden(c);
750    EXPECT_EQ(c.TryFlat(), "hell");
751  }
752  TEST_P(CordTest, TryFlatSubstrExternal) {
753    absl::Cord c = absl::MakeCordFromExternal("hell", [](absl::string_view) {});
754    absl::Cord sub = absl::CordTestPeer::MakeSubstring(c, 1, c.size() - 1);
755    MaybeHarden(sub);
756    EXPECT_EQ(sub.TryFlat(), "ell");
757  }
758  TEST_P(CordTest, TryFlatCommonlyAssumedInvariants) {
759    absl::string_view fragments[] = {"A fragmented test",
760                                     " cord",
761                                     " to test subcords",
762                                     " of ",
763                                     "a",
764                                     " cord for",
765                                     " each chunk "
766                                     "returned by the ",
767                                     "iterator"};
768    absl::Cord c = absl::MakeFragmentedCord(fragments);
769    MaybeHarden(c);
770    int fragment = 0;
771    int offset = 0;
772    absl::Cord::CharIterator itc = c.char_begin();
773    for (absl::string_view sv : c.Chunks()) {
774      absl::string_view expected = fragments[fragment];
775      absl::Cord subcord1 = c.Subcord(offset, sv.length());
776      absl::Cord subcord2 = absl::Cord::AdvanceAndRead(&itc, sv.size());
777      EXPECT_EQ(subcord1.TryFlat(), expected);
778      EXPECT_EQ(subcord2.TryFlat(), expected);
779      ++fragment;
780      offset += sv.length();
781    }
782  }
783  static bool IsFlat(const absl::Cord& c) {
784    return c.chunk_begin() == c.chunk_end() || ++c.chunk_begin() == c.chunk_end();
785  }
786  static void VerifyFlatten(absl::Cord c) {
787    std::string old_contents(c);
788    absl::string_view old_flat;
789    bool already_flat_and_non_empty = IsFlat(c) && !c.empty();
790    if (already_flat_and_non_empty) {
791      old_flat = *c.chunk_begin();
792    }
793    absl::string_view new_flat = c.Flatten();
794    EXPECT_EQ(new_flat, old_contents);
795    EXPECT_EQ(std::string(c), old_contents);
796    if (already_flat_and_non_empty) {
797      EXPECT_EQ(old_flat.data(), new_flat.data())
798          << "Allocated new memory even though the Cord was already flat.";
799    }
800    EXPECT_TRUE(IsFlat(c));
801  }
802  TEST_P(CordTest, Flatten) {
803    VerifyFlatten(absl::Cord());
804    VerifyFlatten(MaybeHardened(absl::Cord("small cord")));
805    VerifyFlatten(
806        MaybeHardened(absl::Cord("larger than small buffer optimization")));
807    VerifyFlatten(MaybeHardened(
808        absl::MakeFragmentedCord({"small ", "fragmented ", "cord"})));
809    RandomEngine rng(GTEST_FLAG_GET(random_seed));
810    VerifyFlatten(MaybeHardened(absl::Cord(RandomLowercaseString(&rng, 8192))));
811  }
812  namespace {
813  class TestData {
814   private:
815    std::vector<std::string> data_;
816    static std::string MakeString(int length) {
817      std::string result;
818      char buf[30];
819      snprintf(buf, sizeof(buf), "(%d)", length);
820      while (result.size() < length) {
821        result += buf;
822      }
823      result.resize(length);
824      return result;
825    }
826   public:
827    TestData() {
828      for (int i = 0; i < 30; i++) {
829        data_.push_back(MakeString(i));
830      }
831      static const int kMaxFlatLength = 4096 - 9;
832      static const int kHalf = kMaxFlatLength / 2;
833      for (int i = -10; i <= +10; i++) {
834        data_.push_back(MakeString(kHalf + i));
835      }
836      for (int i = -10; i <= +10; i++) {
837        data_.push_back(MakeString(kMaxFlatLength + i));
838      }
839    }
840    size_t size() const { return data_.size(); }
841    const std::string& data(size_t i) const { return data_[i]; }
842  };
843  }  
844  TEST_P(CordTest, MultipleLengths) {
845    TestData d;
846    for (size_t i = 0; i < d.size(); i++) {
847      std::string a = d.data(i);
848      {  
849        absl::Cord tmp(a);
850        absl::Cord x(tmp);
851        MaybeHarden(x);
852        EXPECT_EQ(a, std::string(x)) << "'" << a << "'";
853      }
854      {  
855        absl::Cord x(a);
856        MaybeHarden(x);
857        EXPECT_EQ(a, std::string(x)) << "'" << a << "'";
858      }
859      {  
860        absl::Cord self(a);
861        MaybeHarden(self);
862        self.Append(self);
863        EXPECT_EQ(a + a, std::string(self)) << "'" << a << "' + '" << a << "'";
864      }
865      {  
866        absl::Cord self(a);
867        MaybeHarden(self);
868        self.Prepend(self);
869        EXPECT_EQ(a + a, std::string(self)) << "'" << a << "' + '" << a << "'";
870      }
871      for (size_t j = 0; j < d.size(); j++) {
872        std::string b = d.data(j);
873        {  
874          absl::Cord x(a);
875          absl::Cord y(b);
876          MaybeHarden(x);
877          x = y;
878          EXPECT_EQ(b, std::string(x)) << "'" << a << "' + '" << b << "'";
879        }
880        {  
881          absl::Cord x(a);
882          MaybeHarden(x);
883          x = b;
884          EXPECT_EQ(b, std::string(x)) << "'" << a << "' + '" << b << "'";
885        }
886        {  
887          absl::Cord x(a);
888          absl::Cord y(b);
889          MaybeHarden(x);
890          x.Append(y);
891          EXPECT_EQ(a + b, std::string(x)) << "'" << a << "' + '" << b << "'";
892        }
893        {  
894          absl::Cord x(a);
895          MaybeHarden(x);
896          x.Append(b);
897          EXPECT_EQ(a + b, std::string(x)) << "'" << a << "' + '" << b << "'";
898        }
899        {  
900          absl::Cord x(a);
901          absl::Cord y(b);
902          MaybeHarden(x);
903          x.Prepend(y);
904          EXPECT_EQ(b + a, std::string(x)) << "'" << b << "' + '" << a << "'";
905        }
906        {  
907          absl::Cord x(a);
908          MaybeHarden(x);
909          x.Prepend(b);
910          EXPECT_EQ(b + a, std::string(x)) << "'" << b << "' + '" << a << "'";
911        }
912      }
913    }
914  }
915  namespace {
916  TEST_P(CordTest, RemoveSuffixWithExternalOrSubstring) {
917    absl::Cord cord = absl::MakeCordFromExternal(
918        "foo bar baz", [](absl::string_view s) { DoNothing(s, nullptr); });
919    EXPECT_EQ("foo bar baz", std::string(cord));
920    MaybeHarden(cord);
921    cord.RemoveSuffix(4);
922    EXPECT_EQ("foo bar", std::string(cord));
923    MaybeHarden(cord);
924    cord.RemoveSuffix(4);
925    EXPECT_EQ("foo", std::string(cord));
926  }
927  TEST_P(CordTest, RemoveSuffixMakesZeroLengthNode) {
928    absl::Cord c;
929    c.Append(absl::Cord(std::string(100, 'x')));
930    absl::Cord other_ref = c;  
931    MaybeHarden(c);
932    c.Append(absl::Cord(std::string(200, 'y')));
933    c.RemoveSuffix(200);
934    EXPECT_EQ(std::string(100, 'x'), std::string(c));
935  }
936  }  
937  namespace {
938  absl::Cord CordWithZedBlock(size_t size) {
939    char* data = new char[size];
940    if (size > 0) {
941      memset(data, 'z', size);
942    }
943    absl::Cord cord = absl::MakeCordFromExternal(
944        absl::string_view(data, size),
945        [](absl::string_view s) { delete[] s.data(); });
946    return cord;
947  }
948  TEST_P(CordTest, CordSpliceTestZedBlock) {
949    absl::Cord blob = CordWithZedBlock(10);
950    MaybeHarden(blob);
951    EXPECT_EQ(10, blob.size());
952    std::string s;
953    absl::CopyCordToString(blob, &s);
954    EXPECT_EQ("zzzzzzzzzz", s);
955  }
956  TEST_P(CordTest, CordSpliceTestZedBlock0) {
957    absl::Cord blob = CordWithZedBlock(0);
958    MaybeHarden(blob);
959    EXPECT_EQ(0, blob.size());
960    std::string s;
961    absl::CopyCordToString(blob, &s);
962    EXPECT_EQ("", s);
963  }
964  TEST_P(CordTest, CordSpliceTestZedBlockSuffix1) {
965    absl::Cord blob = CordWithZedBlock(10);
966    MaybeHarden(blob);
967    EXPECT_EQ(10, blob.size());
968    absl::Cord suffix(blob);
969    suffix.RemovePrefix(9);
970    EXPECT_EQ(1, suffix.size());
971    std::string s;
972    absl::CopyCordToString(suffix, &s);
973    EXPECT_EQ("z", s);
974  }
975  TEST_P(CordTest, CordSpliceTestZedBlockSuffix0) {
976    absl::Cord blob = CordWithZedBlock(10);
977    MaybeHarden(blob);
978    EXPECT_EQ(10, blob.size());
979    absl::Cord suffix(blob);
980    suffix.RemovePrefix(10);
981    EXPECT_EQ(0, suffix.size());
982    std::string s;
983    absl::CopyCordToString(suffix, &s);
984    EXPECT_EQ("", s);
985  }
986  absl::Cord BigCord(size_t len, char v) {
987    std::string s(len, v);
988    return absl::Cord(s);
989  }
990  absl::Cord SpliceCord(const absl::Cord& blob, int64_t offset,
991                        const absl::Cord& block) {
992    CHECK_GE(offset, 0);
993    CHECK_LE(static_cast<size_t>(offset) + block.size(), blob.size());
994    absl::Cord result(blob);
995    result.RemoveSuffix(blob.size() - offset);
996    result.Append(block);
997    absl::Cord suffix(blob);
998    suffix.RemovePrefix(offset + block.size());
999    result.Append(suffix);
1000    CHECK_EQ(blob.size(), result.size());
1001    return result;
1002  }
1003  TEST_P(CordTest, CordSpliceTestRemoveEntireBlock1) {
1004    absl::Cord zero = CordWithZedBlock(10);
1005    MaybeHarden(zero);
1006    absl::Cord suffix(zero);
1007    suffix.RemovePrefix(10);
1008    absl::Cord result;
1009    result.Append(suffix);
1010  }
1011  TEST_P(CordTest, CordSpliceTestRemoveEntireBlock2) {
1012    absl::Cord zero = CordWithZedBlock(10);
1013    MaybeHarden(zero);
1014    absl::Cord prefix(zero);
1015    prefix.RemoveSuffix(10);
1016    absl::Cord suffix(zero);
1017    suffix.RemovePrefix(10);
1018    absl::Cord result(prefix);
1019    result.Append(suffix);
1020  }
1021  TEST_P(CordTest, CordSpliceTestRemoveEntireBlock3) {
1022    absl::Cord blob = CordWithZedBlock(10);
1023    absl::Cord block = BigCord(10, 'b');
1024    MaybeHarden(blob);
1025    MaybeHarden(block);
1026    blob = SpliceCord(blob, 0, block);
1027  }
1028  struct CordCompareTestCase {
1029    template <typename LHS, typename RHS>
1030    CordCompareTestCase(const LHS& lhs, const RHS& rhs, bool use_crc)
1031        : lhs_cord(lhs), rhs_cord(rhs) {
1032      if (use_crc) {
1033        lhs_cord.SetExpectedChecksum(1);
1034      }
1035    }
1036    absl::Cord lhs_cord;
1037    absl::Cord rhs_cord;
1038  };
1039  const auto sign = [](int x) { return x == 0 ? 0 : (x > 0 ? 1 : -1); };
1040  void VerifyComparison(const CordCompareTestCase& test_case) {
1041    std::string lhs_string(test_case.lhs_cord);
1042    std::string rhs_string(test_case.rhs_cord);
1043    int expected = sign(lhs_string.compare(rhs_string));
1044    EXPECT_EQ(expected, test_case.lhs_cord.Compare(test_case.rhs_cord))
1045        << "LHS=" << lhs_string << "; RHS=" << rhs_string;
1046    EXPECT_EQ(expected, test_case.lhs_cord.Compare(rhs_string))
1047        << "LHS=" << lhs_string << "; RHS=" << rhs_string;
1048    EXPECT_EQ(-expected, test_case.rhs_cord.Compare(test_case.lhs_cord))
1049        << "LHS=" << rhs_string << "; RHS=" << lhs_string;
1050    EXPECT_EQ(-expected, test_case.rhs_cord.Compare(lhs_string))
1051        << "LHS=" << rhs_string << "; RHS=" << lhs_string;
1052  }
1053  TEST_P(CordTest, Compare) {
1054    absl::Cord subcord("aaaaaBBBBBcccccDDDDD");
1055    subcord = subcord.Subcord(3, 10);
1056    absl::Cord tmp("aaaaaaaaaaaaaaaa");
1057    tmp.Append("BBBBBBBBBBBBBBBB");
1058    absl::Cord concat = absl::Cord("cccccccccccccccc");
1059    concat.Append("DDDDDDDDDDDDDDDD");
1060    concat.Prepend(tmp);
1061    absl::Cord concat2("aaaaaaaaaaaaa");
1062    concat2.Append("aaaBBBBBBBBBBBBBBBBccccc");
1063    concat2.Append("cccccccccccDDDDDDDDDDDDDD");
1064    concat2.Append("DD");
1065    const bool use_crc = UseCrc();
1066    std::vector<CordCompareTestCase> test_cases = {{
1067        {"abcdef", "abcdef", use_crc},
1068        {"abcdef", "abcdee", use_crc},
1069        {"abcdef", "abcdeg", use_crc},
1070        {"bbcdef", "abcdef", use_crc},
1071        {"bbcdef", "abcdeg", use_crc},
1072        {"abcdefa", "abcdef", use_crc},
1073        {"abcdef", "abcdefa", use_crc},
1074        {"aaaaaBBBBBcccccDDDDD", "aaaaaBBBBBcccccDDDDD", use_crc},
1075        {"aaaaaBBBBBcccccDDDDD", "aaaaaBBBBBxccccDDDDD", use_crc},
1076        {"aaaaaBBBBBcxcccDDDDD", "aaaaaBBBBBcccccDDDDD", use_crc},
1077        {"aaaaaBBBBBxccccDDDDD", "aaaaaBBBBBcccccDDDDX", use_crc},
1078        {"aaaaaBBBBBcccccDDDDDa", "aaaaaBBBBBcccccDDDDD", use_crc},
1079        {"aaaaaBBBBBcccccDDDDD", "aaaaaBBBBBcccccDDDDDa", use_crc},
1080        {subcord, subcord, use_crc},
1081        {subcord, "aaBBBBBccc", use_crc},
1082        {subcord, "aaBBBBBccd", use_crc},
1083        {subcord, "aaBBBBBccb", use_crc},
1084        {subcord, "aaBBBBBxcb", use_crc},
1085        {subcord, "aaBBBBBccca", use_crc},
1086        {subcord, "aaBBBBBcc", use_crc},
1087        {concat, concat, use_crc},
1088        {concat,
1089         "aaaaaaaaaaaaaaaaBBBBBBBBBBBBBBBBccccccccccccccccDDDDDDDDDDDDDDDD",
1090         use_crc},
1091        {concat,
1092         "aaaaaaaaaaaaaaaaBBBBBBBBBBBBBBBBcccccccccccccccxDDDDDDDDDDDDDDDD",
1093         use_crc},
1094        {concat,
1095         "aaaaaaaaaaaaaaaaBBBBBBBBBBBBBBBBacccccccccccccccDDDDDDDDDDDDDDDD",
1096         use_crc},
1097        {concat,
1098         "aaaaaaaaaaaaaaaaBBBBBBBBBBBBBBBBccccccccccccccccDDDDDDDDDDDDDDD",
1099         use_crc},
1100        {concat,
1101         "aaaaaaaaaaaaaaaaBBBBBBBBBBBBBBBBccccccccccccccccDDDDDDDDDDDDDDDDe",
1102         use_crc},
1103        {concat, concat2, use_crc},
1104    }};
1105    for (const auto& tc : test_cases) {
1106      VerifyComparison(tc);
1107    }
1108  }
1109  TEST_P(CordTest, CompareAfterAssign) {
1110    absl::Cord a("aaaaaa1111111");
1111    absl::Cord b("aaaaaa2222222");
1112    MaybeHarden(a);
1113    a = "cccccc";
1114    b = "cccccc";
1115    EXPECT_EQ(a, b);
1116    EXPECT_FALSE(a < b);
1117    a = "aaaa";
1118    b = "bbbbb";
1119    a = "";
1120    b = "";
1121    EXPECT_EQ(a, b);
1122    EXPECT_FALSE(a < b);
1123  }
1124  static void TestCompare(const absl::Cord& c, const absl::Cord& d,
1125                          RandomEngine* rng) {
1126    typedef std::basic_string<uint8_t> ustring;
1127    ustring cs(reinterpret_cast<const uint8_t*>(std::string(c).data()), c.size());
1128    ustring ds(reinterpret_cast<const uint8_t*>(std::string(d).data()), d.size());
1129    int expected = sign(cs.compare(ds));
1130    EXPECT_EQ(expected, sign(c.Compare(d))) << c << ", " << d;
1131  }
1132  TEST_P(CordTest, CompareComparisonIsUnsigned) {
1133    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1134    std::uniform_int_distribution<uint32_t> uniform_uint8(0, 255);
1135    char x = static_cast<char>(uniform_uint8(rng));
1136    TestCompare(
1137        absl::Cord(std::string(GetUniformRandomUpTo(&rng, 100), x)),
1138        absl::Cord(std::string(GetUniformRandomUpTo(&rng, 100), x ^ 0x80)), &rng);
1139  }
1140  TEST_P(CordTest, CompareRandomComparisons) {
1141    const int kIters = 5000;
1142    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1143    int n = GetUniformRandomUpTo(&rng, 5000);
1144    absl::Cord a[] = {MakeExternalCord(n),
1145                      absl::Cord("ant"),
1146                      absl::Cord("elephant"),
1147                      absl::Cord("giraffe"),
1148                      absl::Cord(std::string(GetUniformRandomUpTo(&rng, 100),
1149                                             GetUniformRandomUpTo(&rng, 100))),
1150                      absl::Cord(""),
1151                      absl::Cord("x"),
1152                      absl::Cord("A"),
1153                      absl::Cord("B"),
1154                      absl::Cord("C")};
1155    for (int i = 0; i < kIters; i++) {
1156      absl::Cord c, d;
1157      for (int j = 0; j < (i % 7) + 1; j++) {
1158        c.Append(a[GetUniformRandomUpTo(&rng, ABSL_ARRAYSIZE(a))]);
1159        d.Append(a[GetUniformRandomUpTo(&rng, ABSL_ARRAYSIZE(a))]);
1160      }
1161      std::bernoulli_distribution coin_flip(0.5);
1162      MaybeHarden(c);
1163      MaybeHarden(d);
1164      TestCompare(coin_flip(rng) ? c : absl::Cord(std::string(c)),
1165                  coin_flip(rng) ? d : absl::Cord(std::string(d)), &rng);
1166    }
1167  }
1168  template <typename T1, typename T2>
1169  void CompareOperators() {
1170    const T1 a("a");
1171    const T2 b("b");
1172    EXPECT_TRUE(a == a);
1173    EXPECT_TRUE(std::is_pointer<T1>::value || a == T1("a"));
1174    EXPECT_TRUE(std::is_pointer<T2>::value || a == T2("a"));
1175    EXPECT_FALSE(a == b);
1176    EXPECT_TRUE(a != b);
1177    EXPECT_FALSE(a != a);
1178    EXPECT_TRUE(a < b);
1179    EXPECT_FALSE(b < a);
1180    EXPECT_TRUE(b > a);
1181    EXPECT_FALSE(a > b);
1182    EXPECT_TRUE(a >= a);
1183    EXPECT_TRUE(b >= a);
1184    EXPECT_FALSE(a >= b);
1185    EXPECT_TRUE(a <= a);
1186    EXPECT_TRUE(a <= b);
1187    EXPECT_FALSE(b <= a);
1188  }
1189  TEST_P(CordTest, ComparisonOperators_Cord_Cord) {
1190    CompareOperators<absl::Cord, absl::Cord>();
1191  }
1192  TEST_P(CordTest, ComparisonOperators_Cord_StringPiece) {
1193    CompareOperators<absl::Cord, absl::string_view>();
1194  }
1195  TEST_P(CordTest, ComparisonOperators_StringPiece_Cord) {
1196    CompareOperators<absl::string_view, absl::Cord>();
1197  }
1198  TEST_P(CordTest, ComparisonOperators_Cord_string) {
1199    CompareOperators<absl::Cord, std::string>();
1200  }
1201  TEST_P(CordTest, ComparisonOperators_string_Cord) {
1202    CompareOperators<std::string, absl::Cord>();
1203  }
1204  TEST_P(CordTest, ComparisonOperators_stdstring_Cord) {
1205    CompareOperators<std::string, absl::Cord>();
1206  }
1207  TEST_P(CordTest, ComparisonOperators_Cord_stdstring) {
1208    CompareOperators<absl::Cord, std::string>();
1209  }
1210  TEST_P(CordTest, ComparisonOperators_charstar_Cord) {
1211    CompareOperators<const char*, absl::Cord>();
1212  }
1213  TEST_P(CordTest, ComparisonOperators_Cord_charstar) {
1214    CompareOperators<absl::Cord, const char*>();
1215  }
1216  TEST_P(CordTest, ConstructFromExternalReleaserInvoked) {
1217    {
1218      bool invoked = false;
1219      auto releaser = [&invoked](absl::string_view) { invoked = true; };
1220      {
1221        auto c = absl::MakeCordFromExternal("", releaser);
1222        EXPECT_TRUE(invoked);
1223      }
1224    }
1225    std::string large_dummy(2048, 'c');
1226    {
1227      bool invoked = false;
1228      auto releaser = [&invoked](absl::string_view) { invoked = true; };
1229      {
1230        auto c = absl::MakeCordFromExternal(large_dummy, releaser);
1231        EXPECT_FALSE(invoked);
1232      }
1233      EXPECT_TRUE(invoked);
1234    }
1235    {
1236      bool invoked = false;
1237      auto releaser = [&invoked](absl::string_view) { invoked = true; };
1238      {
1239        absl::Cord copy;
1240        {
1241          auto c = absl::MakeCordFromExternal(large_dummy, releaser);
1242          copy = c;
1243          EXPECT_FALSE(invoked);
1244        }
1245        EXPECT_FALSE(invoked);
1246      }
1247      EXPECT_TRUE(invoked);
1248    }
1249  }
1250  TEST_P(CordTest, ConstructFromExternalCompareContents) {
1251    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1252    for (int length = 1; length <= 2048; length *= 2) {
1253      std::string data = RandomLowercaseString(&rng, length);
1254      auto* external = new std::string(data);
1255      auto cord =
1256          absl::MakeCordFromExternal(*external, [external](absl::string_view sv) {
1257            EXPECT_EQ(external->data(), sv.data());
1258            EXPECT_EQ(external->size(), sv.size());
1259            delete external;
1260          });
1261      MaybeHarden(cord);
1262      EXPECT_EQ(data, cord);
1263    }
1264  }
1265  TEST_P(CordTest, ConstructFromExternalLargeReleaser) {
1266    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1267    constexpr size_t kLength = 256;
1268    std::string data = RandomLowercaseString(&rng, kLength);
1269    std::array<char, kLength> data_array;
1270    for (size_t i = 0; i < kLength; ++i) data_array[i] = data[i];
1271    bool invoked = false;
1272    auto releaser = [data_array, &invoked](absl::string_view data) {
1273      EXPECT_EQ(data, absl::string_view(data_array.data(), data_array.size()));
1274      invoked = true;
1275    };
1276    (void)MaybeHardened(absl::MakeCordFromExternal(data, releaser));
1277    EXPECT_TRUE(invoked);
1278  }
1279  TEST_P(CordTest, ConstructFromExternalFunctionPointerReleaser) {
1280    static absl::string_view data("hello world");
1281    static bool invoked;
1282    auto* releaser =
1283        static_cast<void (*)(absl::string_view)>([](absl::string_view sv) {
1284          EXPECT_EQ(data, sv);
1285          invoked = true;
1286        });
1287    invoked = false;
1288    (void)MaybeHardened(absl::MakeCordFromExternal(data, releaser));
1289    EXPECT_TRUE(invoked);
1290    invoked = false;
1291    (void)MaybeHardened(absl::MakeCordFromExternal(data, *releaser));
1292    EXPECT_TRUE(invoked);
1293  }
1294  TEST_P(CordTest, ConstructFromExternalMoveOnlyReleaser) {
1295    struct Releaser {
1296      explicit Releaser(bool* invoked) : invoked(invoked) {}
1297      Releaser(Releaser&& other) noexcept : invoked(other.invoked) {}
1298      void operator()(absl::string_view) const { *invoked = true; }
1299      bool* invoked;
1300    };
1301    bool invoked = false;
1302    (void)MaybeHardened(absl::MakeCordFromExternal("dummy", Releaser(&invoked)));
1303    EXPECT_TRUE(invoked);
1304  }
1305  TEST_P(CordTest, ConstructFromExternalNoArgLambda) {
1306    bool invoked = false;
1307    (void)MaybeHardened(
1308        absl::MakeCordFromExternal("dummy", [&invoked]() { invoked = true; }));
1309    EXPECT_TRUE(invoked);
1310  }
1311  TEST_P(CordTest, ConstructFromExternalStringViewArgLambda) {
1312    bool invoked = false;
1313    (void)MaybeHardened(absl::MakeCordFromExternal(
1314        "dummy", [&invoked](absl::string_view) { invoked = true; }));
1315    EXPECT_TRUE(invoked);
1316  }
1317  TEST_P(CordTest, ConstructFromExternalNonTrivialReleaserDestructor) {
1318    struct Releaser {
1319      explicit Releaser(bool* destroyed) : destroyed(destroyed) {}
1320      ~Releaser() { *destroyed = true; }
1321      void operator()(absl::string_view) const {}
1322      bool* destroyed;
1323    };
1324    bool destroyed = false;
1325    Releaser releaser(&destroyed);
1326    (void)MaybeHardened(absl::MakeCordFromExternal("dummy", releaser));
1327    EXPECT_TRUE(destroyed);
1328  }
1329  TEST_P(CordTest, ConstructFromExternalReferenceQualifierOverloads) {
1330    enum InvokedAs { kMissing, kLValue, kRValue };
1331    enum CopiedAs { kNone, kMove, kCopy };
1332    struct Tracker {
1333      CopiedAs copied_as = kNone;
1334      InvokedAs invoked_as = kMissing;
1335      void Record(InvokedAs rhs) {
1336        ASSERT_EQ(invoked_as, kMissing);
1337        invoked_as = rhs;
1338      }
1339      void Record(CopiedAs rhs) {
1340        if (copied_as == kNone || rhs == kCopy) copied_as = rhs;
1341      }
1342    } tracker;
1343    class Releaser {
1344     public:
1345      explicit Releaser(Tracker* tracker) : tr_(tracker) { *tracker = Tracker(); }
1346      Releaser(Releaser&& rhs) : tr_(rhs.tr_) { tr_->Record(kMove); }
1347      Releaser(const Releaser& rhs) : tr_(rhs.tr_) { tr_->Record(kCopy); }
1348      void operator()(absl::string_view) & { tr_->Record(kLValue); }
1349      void operator()(absl::string_view) && { tr_->Record(kRValue); }
1350     private:
1351      Tracker* tr_;
1352    };
1353    const Releaser releaser1(&tracker);
1354    (void)MaybeHardened(absl::MakeCordFromExternal("", releaser1));
1355    EXPECT_EQ(tracker.copied_as, kCopy);
1356    EXPECT_EQ(tracker.invoked_as, kRValue);
1357    const Releaser releaser2(&tracker);
1358    (void)MaybeHardened(absl::MakeCordFromExternal("", releaser2));
1359    EXPECT_EQ(tracker.copied_as, kCopy);
1360    EXPECT_EQ(tracker.invoked_as, kRValue);
1361    Releaser releaser3(&tracker);
1362    (void)MaybeHardened(absl::MakeCordFromExternal("", std::move(releaser3)));
1363    EXPECT_EQ(tracker.copied_as, kMove);
1364    EXPECT_EQ(tracker.invoked_as, kRValue);
1365    Releaser releaser4(&tracker);
1366    (void)MaybeHardened(absl::MakeCordFromExternal("dummy", releaser4));
1367    EXPECT_EQ(tracker.copied_as, kCopy);
1368    EXPECT_EQ(tracker.invoked_as, kRValue);
1369    const Releaser releaser5(&tracker);
1370    (void)MaybeHardened(absl::MakeCordFromExternal("dummy", releaser5));
1371    EXPECT_EQ(tracker.copied_as, kCopy);
1372    EXPECT_EQ(tracker.invoked_as, kRValue);
1373    Releaser releaser6(&tracker);
1374    (void)MaybeHardened(absl::MakeCordFromExternal("foo", std::move(releaser6)));
1375    EXPECT_EQ(tracker.copied_as, kMove);
1376    EXPECT_EQ(tracker.invoked_as, kRValue);
1377  }
1378  TEST_P(CordTest, ExternalMemoryBasicUsage) {
1379    static const char* strings[] = {"", "hello", "there"};
1380    for (const char* str : strings) {
1381      absl::Cord dst("(prefix)");
1382      MaybeHarden(dst);
1383      AddExternalMemory(str, &dst);
1384      MaybeHarden(dst);
1385      dst.Append("(suffix)");
1386      EXPECT_EQ((std::string("(prefix)") + str + std::string("(suffix)")),
1387                std::string(dst));
1388    }
1389  }
1390  TEST_P(CordTest, ExternalMemoryRemovePrefixSuffix) {
1391    absl::Cord cord = MakeComposite();
1392    std::string s = std::string(cord);
1393    for (int offset = 0; offset <= s.size(); offset++) {
1394      for (int length = 0; length <= s.size() - offset; length++) {
1395        absl::Cord result(cord);
1396        MaybeHarden(result);
1397        result.RemovePrefix(offset);
1398        MaybeHarden(result);
1399        result.RemoveSuffix(result.size() - length);
1400        EXPECT_EQ(s.substr(offset, length), std::string(result))
1401            << offset << " " << length;
1402      }
1403    }
1404  }
1405  TEST_P(CordTest, ExternalMemoryGet) {
1406    absl::Cord cord("hello");
1407    AddExternalMemory(" world!", &cord);
1408    MaybeHarden(cord);
1409    AddExternalMemory(" how are ", &cord);
1410    cord.Append(" you?");
1411    MaybeHarden(cord);
1412    std::string s = std::string(cord);
1413    for (int i = 0; i < s.size(); i++) {
1414      EXPECT_EQ(s[i], cord[i]);
1415    }
1416  }
1417  constexpr auto kFairShare = absl::CordMemoryAccounting::kFairShare;
1418  absl::Cord MakeCord(size_t n, char c) {
1419    const std::string s(n, c);
1420    return absl::Cord(s);
1421  }
1422  TEST(CordTest, CordMemoryUsageEmpty) {
1423    absl::Cord cord;
1424    EXPECT_EQ(sizeof(absl::Cord), cord.EstimatedMemoryUsage());
1425    EXPECT_EQ(sizeof(absl::Cord), cord.EstimatedMemoryUsage(kFairShare));
1426  }
1427  TEST(CordTest, CordMemoryUsageInlined) {
1428    absl::Cord a("hello");
1429    EXPECT_EQ(a.EstimatedMemoryUsage(), sizeof(absl::Cord));
1430    EXPECT_EQ(a.EstimatedMemoryUsage(kFairShare), sizeof(absl::Cord));
1431  }
1432  TEST(CordTest, CordMemoryUsageExternalMemory) {
1433    absl::Cord cord;
1434    AddExternalMemory(std::string(1000, 'x'), &cord);
1435    const size_t expected =
1436        sizeof(absl::Cord) + 1000 + sizeof(CordRepExternal) + sizeof(intptr_t);
1437    EXPECT_EQ(cord.EstimatedMemoryUsage(), expected);
1438    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare), expected);
1439  }
1440  TEST(CordTest, CordMemoryUsageFlat) {
1441    absl::Cord cord = MakeCord(1000, 'a');
1442    const size_t flat_size =
1443        absl::CordTestPeer::Tree(cord)->flat()->AllocatedSize();
1444    EXPECT_EQ(cord.EstimatedMemoryUsage(), sizeof(absl::Cord) + flat_size);
1445    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare),
1446              sizeof(absl::Cord) + flat_size);
1447  }
1448  TEST(CordTest, CordMemoryUsageSubStringSharedFlat) {
1449    absl::Cord flat = MakeCord(2000, 'a');
1450    const size_t flat_size =
1451        absl::CordTestPeer::Tree(flat)->flat()->AllocatedSize();
1452    absl::Cord cord = flat.Subcord(500, 1000);
1453    EXPECT_EQ(cord.EstimatedMemoryUsage(),
1454              sizeof(absl::Cord) + sizeof(CordRepSubstring) + flat_size);
1455    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare),
1456              sizeof(absl::Cord) + sizeof(CordRepSubstring) + flat_size / 2);
1457  }
1458  TEST(CordTest, CordMemoryUsageFlatShared) {
1459    absl::Cord shared = MakeCord(1000, 'a');
1460    absl::Cord cord(shared);
1461    const size_t flat_size =
1462        absl::CordTestPeer::Tree(cord)->flat()->AllocatedSize();
1463    EXPECT_EQ(cord.EstimatedMemoryUsage(), sizeof(absl::Cord) + flat_size);
1464    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare),
1465              sizeof(absl::Cord) + flat_size / 2);
1466  }
1467  TEST(CordTest, CordMemoryUsageFlatHardenedAndShared) {
1468    absl::Cord shared = MakeCord(1000, 'a');
1469    absl::Cord cord(shared);
1470    const size_t flat_size =
1471        absl::CordTestPeer::Tree(cord)->flat()->AllocatedSize();
1472    cord.SetExpectedChecksum(1);
1473    EXPECT_EQ(cord.EstimatedMemoryUsage(),
1474              sizeof(absl::Cord) + sizeof(CordRepCrc) + flat_size);
1475    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare),
1476              sizeof(absl::Cord) + sizeof(CordRepCrc) + flat_size / 2);
1477    absl::Cord cord2(cord);
1478    EXPECT_EQ(cord2.EstimatedMemoryUsage(),
1479              sizeof(absl::Cord) + sizeof(CordRepCrc) + flat_size);
1480    EXPECT_EQ(cord2.EstimatedMemoryUsage(kFairShare),
1481              sizeof(absl::Cord) + (sizeof(CordRepCrc) + flat_size / 2) / 2);
1482  }
1483  TEST(CordTest, CordMemoryUsageBTree) {
1484    absl::Cord cord1;
1485    size_t flats1_size = 0;
1486    absl::Cord flats1[4] = {MakeCord(1000, 'a'), MakeCord(1100, 'a'),
1487                            MakeCord(1200, 'a'), MakeCord(1300, 'a')};
1488    for (absl::Cord flat : flats1) {
1489      flats1_size += absl::CordTestPeer::Tree(flat)->flat()->AllocatedSize();
1490      cord1.Append(std::move(flat));
1491    }
1492    if (!absl::CordTestPeer::Tree(cord1)->IsBtree()) {
1493      LOG(WARNING) << "Cord library code not respecting btree flag";
1494      return;
1495    }
1496    size_t rep1_size = sizeof(CordRepBtree) + flats1_size;
1497    size_t rep1_shared_size = sizeof(CordRepBtree) + flats1_size / 2;
1498    EXPECT_EQ(cord1.EstimatedMemoryUsage(), sizeof(absl::Cord) + rep1_size);
1499    EXPECT_EQ(cord1.EstimatedMemoryUsage(kFairShare),
1500              sizeof(absl::Cord) + rep1_shared_size);
1501    absl::Cord cord2;
1502    size_t flats2_size = 0;
1503    absl::Cord flats2[4] = {MakeCord(600, 'a'), MakeCord(700, 'a'),
1504                            MakeCord(800, 'a'), MakeCord(900, 'a')};
1505    for (absl::Cord& flat : flats2) {
1506      flats2_size += absl::CordTestPeer::Tree(flat)->flat()->AllocatedSize();
1507      cord2.Append(std::move(flat));
1508    }
1509    size_t rep2_size = sizeof(CordRepBtree) + flats2_size;
1510    EXPECT_EQ(cord2.EstimatedMemoryUsage(), sizeof(absl::Cord) + rep2_size);
1511    EXPECT_EQ(cord2.EstimatedMemoryUsage(kFairShare),
1512              sizeof(absl::Cord) + rep2_size);
1513    absl::Cord cord(cord1);
1514    cord.Append(std::move(cord2));
1515    EXPECT_EQ(cord.EstimatedMemoryUsage(),
1516              sizeof(absl::Cord) + sizeof(CordRepBtree) + rep1_size + rep2_size);
1517    EXPECT_EQ(cord.EstimatedMemoryUsage(kFairShare),
1518              sizeof(absl::Cord) + sizeof(CordRepBtree) + rep1_shared_size / 2 +
1519                  rep2_size);
1520  }
1521  TEST_P(CordTest, CordMemoryUsageInlineRep) {
1522    constexpr size_t kMaxInline = 15;  
1523    const std::string small_string(kMaxInline, 'x');
1524    absl::Cord c1(small_string);
1525    absl::Cord c2;
1526    c2.Append(small_string);
1527    EXPECT_EQ(c1, c2);
1528    EXPECT_EQ(c1.EstimatedMemoryUsage(), c2.EstimatedMemoryUsage());
1529  }
1530  }  
1531  TEST_P(CordTest, Concat_Append) {
1532    absl::Cord s1("foobarbarbarbarbar");
1533    MaybeHarden(s1);
1534    s1.Append("abcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefg");
1535    size_t size = s1.size();
1536    absl::Cord s2 = s1;
1537    MaybeHarden(s2);
1538    s2.Append("x");
1539    EXPECT_EQ(s1.size(), size);
1540    EXPECT_EQ(s2.size(), size + 1);
1541  }
1542  TEST_P(CordTest, DiabolicalGrowth) {
1543    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1544    const std::string expected = RandomLowercaseString(&rng, 5000);
1545    absl::Cord cord;
1546    for (char c : expected) {
1547      absl::Cord shared(cord);
1548      cord.Append(absl::string_view(&c, 1));
1549      MaybeHarden(cord);
1550    }
1551    std::string value;
1552    absl::CopyCordToString(cord, &value);
1553    EXPECT_EQ(value, expected);
1554    LOG(INFO) << "Diabolical size allocated = " << cord.EstimatedMemoryUsage();
1555  }
1556  static absl::Cord MakeHuge(absl::string_view prefix) {
1557    absl::Cord cord;
1558    if (sizeof(size_t) > 4) {
1559      const size_t size =
1560          static_cast<size_t>(std::numeric_limits<uint32_t>::max()) + 314;
1561      cord.Append(absl::MakeCordFromExternal(
1562          absl::string_view(prefix.data(), size),
1563          [](absl::string_view s) { DoNothing(s, nullptr); }));
1564    } else {
1565      const size_t s1 = (1u << 31) - 1;
1566      const size_t s2 = 600;
1567      cord.Append(absl::MakeCordFromExternal(
1568          absl::string_view(prefix.data(), s1),
1569          [](absl::string_view s) { DoNothing(s, nullptr); }));
1570      cord.Append(absl::MakeCordFromExternal(
1571          absl::string_view("", s2),
1572          [](absl::string_view s) { DoNothing(s, nullptr); }));
1573    }
1574    return cord;
1575  }
1576  TEST_P(CordTest, HugeCord) {
1577    absl::Cord cord = MakeHuge("huge cord");
1578    MaybeHarden(cord);
1579    const size_t acceptable_delta =
1580        100 + (UseCrc() ? sizeof(absl::cord_internal::CordRepCrc) : 0);
1581    EXPECT_LE(cord.size(), cord.EstimatedMemoryUsage());
1582    EXPECT_GE(cord.size() + acceptable_delta, cord.EstimatedMemoryUsage());
1583  }
1584  TEST_P(CordTest, AppendSelf) {
1585    absl::Cord empty;
1586    MaybeHarden(empty);
1587    empty.Append(empty);
1588    ASSERT_EQ(empty, "");
1589    std::string control_data = "Abc";
1590    absl::Cord data(control_data);
1591    while (control_data.length() < 0x4000) {
1592      MaybeHarden(data);
1593      data.Append(data);
1594      control_data.append(control_data);
1595      ASSERT_EQ(control_data, data);
1596    }
1597  }
1598  TEST_P(CordTest, MakeFragmentedCordFromInitializerList) {
1599    absl::Cord fragmented =
1600        absl::MakeFragmentedCord({"A ", "fragmented ", "Cord"});
1601    MaybeHarden(fragmented);
1602    EXPECT_EQ("A fragmented Cord", fragmented);
1603    auto chunk_it = fragmented.chunk_begin();
1604    ASSERT_TRUE(chunk_it != fragmented.chunk_end());
1605    EXPECT_EQ("A ", *chunk_it);
1606    ASSERT_TRUE(++chunk_it != fragmented.chunk_end());
1607    EXPECT_EQ("fragmented ", *chunk_it);
1608    ASSERT_TRUE(++chunk_it != fragmented.chunk_end());
1609    EXPECT_EQ("Cord", *chunk_it);
1610    ASSERT_TRUE(++chunk_it == fragmented.chunk_end());
1611  }
1612  TEST_P(CordTest, MakeFragmentedCordFromVector) {
1613    std::vector<absl::string_view> chunks = {"A ", "fragmented ", "Cord"};
1614    absl::Cord fragmented = absl::MakeFragmentedCord(chunks);
1615    MaybeHarden(fragmented);
1616    EXPECT_EQ("A fragmented Cord", fragmented);
1617    auto chunk_it = fragmented.chunk_begin();
1618    ASSERT_TRUE(chunk_it != fragmented.chunk_end());
1619    EXPECT_EQ("A ", *chunk_it);
1620    ASSERT_TRUE(++chunk_it != fragmented.chunk_end());
1621    EXPECT_EQ("fragmented ", *chunk_it);
1622    ASSERT_TRUE(++chunk_it != fragmented.chunk_end());
1623    EXPECT_EQ("Cord", *chunk_it);
1624    ASSERT_TRUE(++chunk_it == fragmented.chunk_end());
1625  }
1626  TEST_P(CordTest, CordChunkIteratorTraits) {
1627    static_assert(std::is_copy_constructible<absl::Cord::ChunkIterator>::value,
1628                  "");
1629    static_assert(std::is_copy_assignable<absl::Cord::ChunkIterator>::value, "");
1630    static_assert(std::is_move_constructible<absl::Cord::ChunkIterator>::value,
1631                  "");
1632    static_assert(std::is_move_assignable<absl::Cord::ChunkIterator>::value, "");
1633    static_assert(
1634        std::is_same<
1635            std::iterator_traits<absl::Cord::ChunkIterator>::iterator_category,
1636            std::input_iterator_tag>::value,
1637        "");
1638    static_assert(
1639        std::is_same<std::iterator_traits<absl::Cord::ChunkIterator>::value_type,
1640                     absl::string_view>::value,
1641        "");
1642    static_assert(
1643        std::is_same<
1644            std::iterator_traits<absl::Cord::ChunkIterator>::difference_type,
1645            ptrdiff_t>::value,
1646        "");
1647    static_assert(
1648        std::is_same<std::iterator_traits<absl::Cord::ChunkIterator>::pointer,
1649                     const absl::string_view*>::value,
1650        "");
1651    static_assert(
1652        std::is_same<std::iterator_traits<absl::Cord::ChunkIterator>::reference,
1653                     absl::string_view>::value,
1654        "");
1655  }
1656  static void VerifyChunkIterator(const absl::Cord& cord,
1657                                  size_t expected_chunks) {
1658    EXPECT_EQ(cord.chunk_begin() == cord.chunk_end(), cord.empty()) << cord;
1659    EXPECT_EQ(cord.chunk_begin() != cord.chunk_end(), !cord.empty());
1660    absl::Cord::ChunkRange range = cord.Chunks();
1661    EXPECT_EQ(range.begin() == range.end(), cord.empty());
1662    EXPECT_EQ(range.begin() != range.end(), !cord.empty());
1663    std::string content(cord);
1664    size_t pos = 0;
1665    auto pre_iter = cord.chunk_begin(), post_iter = cord.chunk_begin();
1666    size_t n_chunks = 0;
1667    while (pre_iter != cord.chunk_end() && post_iter != cord.chunk_end()) {
1668      EXPECT_FALSE(pre_iter == cord.chunk_end());   
1669      EXPECT_FALSE(post_iter == cord.chunk_end());  
1670      EXPECT_EQ(pre_iter, post_iter);
1671      EXPECT_EQ(*pre_iter, *post_iter);
1672      EXPECT_EQ(pre_iter->data(), (*pre_iter).data());
1673      EXPECT_EQ(pre_iter->size(), (*pre_iter).size());
1674      absl::string_view chunk = *pre_iter;
1675      EXPECT_FALSE(chunk.empty());
1676      EXPECT_LE(pos + chunk.size(), content.size());
1677      EXPECT_EQ(absl::string_view(content.c_str() + pos, chunk.size()), chunk);
1678      int n_equal_iterators = 0;
1679      for (absl::Cord::ChunkIterator it = range.begin(); it != range.end();
1680           ++it) {
1681        n_equal_iterators += static_cast<int>(it == pre_iter);
1682      }
1683      EXPECT_EQ(n_equal_iterators, 1);
1684      ++pre_iter;
1685      EXPECT_EQ(*post_iter++, chunk);
1686      pos += chunk.size();
1687      ++n_chunks;
1688    }
1689    EXPECT_EQ(expected_chunks, n_chunks);
1690    EXPECT_EQ(pos, content.size());
1691    EXPECT_TRUE(pre_iter == cord.chunk_end());   
1692    EXPECT_TRUE(post_iter == cord.chunk_end());  
1693  }
1694  TEST_P(CordTest, CordChunkIteratorOperations) {
1695    absl::Cord empty_cord;
1696    VerifyChunkIterator(empty_cord, 0);
1697    absl::Cord small_buffer_cord("small cord");
1698    MaybeHarden(small_buffer_cord);
1699    VerifyChunkIterator(small_buffer_cord, 1);
1700    absl::Cord flat_node_cord("larger than small buffer optimization");
1701    MaybeHarden(flat_node_cord);
1702    VerifyChunkIterator(flat_node_cord, 1);
1703    VerifyChunkIterator(MaybeHardened(absl::MakeFragmentedCord(
1704                            {"a ", "small ", "fragmented ", "cord ", "for ",
1705                             "testing ", "chunk ", "iterations."})),
1706                        8);
1707    absl::Cord reused_nodes_cord(std::string(40, 'c'));
1708    reused_nodes_cord.Prepend(absl::Cord(std::string(40, 'b')));
1709    MaybeHarden(reused_nodes_cord);
1710    reused_nodes_cord.Prepend(absl::Cord(std::string(40, 'a')));
1711    size_t expected_chunks = 3;
1712    for (int i = 0; i < 8; ++i) {
1713      reused_nodes_cord.Prepend(reused_nodes_cord);
1714      MaybeHarden(reused_nodes_cord);
1715      expected_chunks *= 2;
1716      VerifyChunkIterator(reused_nodes_cord, expected_chunks);
1717    }
1718    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1719    absl::Cord flat_cord(RandomLowercaseString(&rng, 256));
1720    absl::Cord subcords;
1721    for (int i = 0; i < 128; ++i) subcords.Prepend(flat_cord.Subcord(i, 128));
1722    VerifyChunkIterator(subcords, 128);
1723  }
1724  TEST_P(CordTest, AdvanceAndReadOnDataEdge) {
1725    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1726    const std::string data = RandomLowercaseString(&rng, 2000);
1727    for (bool as_flat : {true, false}) {
1728      SCOPED_TRACE(as_flat ? "Flat" : "External");
1729      absl::Cord cord =
1730          as_flat ? absl::Cord(data)
1731                  : absl::MakeCordFromExternal(data, [](absl::string_view) {});
1732      auto it = cord.Chars().begin();
1733  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
1734      EXPECT_DEATH_IF_SUPPORTED(cord.AdvanceAndRead(&it, 2001), ".*");
1735  #endif
1736      it = cord.Chars().begin();
1737      absl::Cord frag = cord.AdvanceAndRead(&it, 2000);
1738      EXPECT_EQ(frag, data);
1739      EXPECT_TRUE(it == cord.Chars().end());
1740      it = cord.Chars().begin();
1741      frag = cord.AdvanceAndRead(&it, 200);
1742      EXPECT_EQ(frag, data.substr(0, 200));
1743      EXPECT_FALSE(it == cord.Chars().end());
1744      frag = cord.AdvanceAndRead(&it, 1500);
1745      EXPECT_EQ(frag, data.substr(200, 1500));
1746      EXPECT_FALSE(it == cord.Chars().end());
1747      frag = cord.AdvanceAndRead(&it, 300);
1748      EXPECT_EQ(frag, data.substr(1700, 300));
1749      EXPECT_TRUE(it == cord.Chars().end());
1750    }
1751  }
1752  TEST_P(CordTest, AdvanceAndReadOnSubstringDataEdge) {
1753    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1754    const std::string data = RandomLowercaseString(&rng, 2500);
1755    for (bool as_flat : {true, false}) {
1756      SCOPED_TRACE(as_flat ? "Flat" : "External");
1757      absl::Cord cord =
1758          as_flat ? absl::Cord(data)
1759                  : absl::MakeCordFromExternal(data, [](absl::string_view) {});
1760      cord = cord.Subcord(200, 2000);
1761      const std::string substr = data.substr(200, 2000);
1762      auto it = cord.Chars().begin();
1763  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
1764      EXPECT_DEATH_IF_SUPPORTED(cord.AdvanceAndRead(&it, 2001), ".*");
1765  #endif
1766      it = cord.Chars().begin();
1767      absl::Cord frag = cord.AdvanceAndRead(&it, 2000);
1768      EXPECT_EQ(frag, substr);
1769      EXPECT_TRUE(it == cord.Chars().end());
1770      it = cord.Chars().begin();
1771      frag = cord.AdvanceAndRead(&it, 200);
1772      EXPECT_EQ(frag, substr.substr(0, 200));
1773      EXPECT_FALSE(it == cord.Chars().end());
1774      frag = cord.AdvanceAndRead(&it, 1500);
1775      EXPECT_EQ(frag, substr.substr(200, 1500));
1776      EXPECT_FALSE(it == cord.Chars().end());
1777      frag = cord.AdvanceAndRead(&it, 300);
1778      EXPECT_EQ(frag, substr.substr(1700, 300));
1779      EXPECT_TRUE(it == cord.Chars().end());
1780    }
1781  }
1782  TEST_P(CordTest, CharIteratorTraits) {
1783    static_assert(std::is_copy_constructible<absl::Cord::CharIterator>::value,
1784                  "");
1785    static_assert(std::is_copy_assignable<absl::Cord::CharIterator>::value, "");
1786    static_assert(std::is_move_constructible<absl::Cord::CharIterator>::value,
1787                  "");
1788    static_assert(std::is_move_assignable<absl::Cord::CharIterator>::value, "");
1789    static_assert(
1790        std::is_same<
1791            std::iterator_traits<absl::Cord::CharIterator>::iterator_category,
1792            std::input_iterator_tag>::value,
1793        "");
1794    static_assert(
1795        std::is_same<std::iterator_traits<absl::Cord::CharIterator>::value_type,
1796                     char>::value,
1797        "");
1798    static_assert(
1799        std::is_same<
1800            std::iterator_traits<absl::Cord::CharIterator>::difference_type,
1801            ptrdiff_t>::value,
1802        "");
1803    static_assert(
1804        std::is_same<std::iterator_traits<absl::Cord::CharIterator>::pointer,
1805                     const char*>::value,
1806        "");
1807    static_assert(
1808        std::is_same<std::iterator_traits<absl::Cord::CharIterator>::reference,
1809                     const char&>::value,
1810        "");
1811  }
1812  static void VerifyCharIterator(const absl::Cord& cord) {
1813    EXPECT_EQ(cord.char_begin() == cord.char_end(), cord.empty());
1814    EXPECT_EQ(cord.char_begin() != cord.char_end(), !cord.empty());
1815    absl::Cord::CharRange range = cord.Chars();
1816    EXPECT_EQ(range.begin() == range.end(), cord.empty());
1817    EXPECT_EQ(range.begin() != range.end(), !cord.empty());
1818    size_t i = 0;
1819    absl::Cord::CharIterator pre_iter = cord.char_begin();
1820    absl::Cord::CharIterator post_iter = cord.char_begin();
1821    std::string content(cord);
1822    while (pre_iter != cord.char_end() && post_iter != cord.char_end()) {
1823      EXPECT_FALSE(pre_iter == cord.char_end());   
1824      EXPECT_FALSE(post_iter == cord.char_end());  
1825      EXPECT_LT(i, cord.size());
1826      EXPECT_EQ(content[i], *pre_iter);
1827      EXPECT_EQ(pre_iter, post_iter);
1828      EXPECT_EQ(*pre_iter, *post_iter);
1829      EXPECT_EQ(&*pre_iter, &*post_iter);
1830      EXPECT_EQ(&*pre_iter, pre_iter.operator->());
1831      const char* character_address = &*pre_iter;
1832      absl::Cord::CharIterator copy = pre_iter;
1833      ++copy;
1834      EXPECT_EQ(character_address, &*pre_iter);
1835      int n_equal_iterators = 0;
1836      for (absl::Cord::CharIterator it = range.begin(); it != range.end(); ++it) {
1837        n_equal_iterators += static_cast<int>(it == pre_iter);
1838      }
1839      EXPECT_EQ(n_equal_iterators, 1);
1840      absl::Cord::CharIterator advance_iter = range.begin();
1841      absl::Cord::Advance(&advance_iter, i);
1842      EXPECT_EQ(pre_iter, advance_iter);
1843      advance_iter = range.begin();
1844      EXPECT_EQ(absl::Cord::AdvanceAndRead(&advance_iter, i), cord.Subcord(0, i));
1845      EXPECT_EQ(pre_iter, advance_iter);
1846      advance_iter = pre_iter;
1847      absl::Cord::Advance(&advance_iter, cord.size() - i);
1848      EXPECT_EQ(range.end(), advance_iter);
1849      advance_iter = pre_iter;
1850      EXPECT_EQ(absl::Cord::AdvanceAndRead(&advance_iter, cord.size() - i),
1851                cord.Subcord(i, cord.size() - i));
1852      EXPECT_EQ(range.end(), advance_iter);
1853      ++i;
1854      ++pre_iter;
1855      post_iter++;
1856    }
1857    EXPECT_EQ(i, cord.size());
1858    EXPECT_TRUE(pre_iter == cord.char_end());   
1859    EXPECT_TRUE(post_iter == cord.char_end());  
1860    absl::Cord::CharIterator zero_advanced_end = cord.char_end();
1861    absl::Cord::Advance(&zero_advanced_end, 0);
1862    EXPECT_EQ(zero_advanced_end, cord.char_end());
1863    absl::Cord::CharIterator it = cord.char_begin();
1864    for (absl::string_view chunk : cord.Chunks()) {
1865      while (!chunk.empty()) {
1866        EXPECT_EQ(absl::Cord::ChunkRemaining(it), chunk);
1867        chunk.remove_prefix(1);
1868        ++it;
1869      }
1870    }
1871  }
1872  TEST_P(CordTest, CharIteratorOperations) {
1873    absl::Cord empty_cord;
1874    VerifyCharIterator(empty_cord);
1875    absl::Cord small_buffer_cord("small cord");
1876    MaybeHarden(small_buffer_cord);
1877    VerifyCharIterator(small_buffer_cord);
1878    absl::Cord flat_node_cord("larger than small buffer optimization");
1879    MaybeHarden(flat_node_cord);
1880    VerifyCharIterator(flat_node_cord);
1881    VerifyCharIterator(MaybeHardened(
1882        absl::MakeFragmentedCord({"a ", "small ", "fragmented ", "cord ", "for ",
1883                                  "testing ", "character ", "iteration."})));
1884    absl::Cord reused_nodes_cord("ghi");
1885    reused_nodes_cord.Prepend(absl::Cord("def"));
1886    reused_nodes_cord.Prepend(absl::Cord("abc"));
1887    for (int i = 0; i < 4; ++i) {
1888      reused_nodes_cord.Prepend(reused_nodes_cord);
1889      MaybeHarden(reused_nodes_cord);
1890      VerifyCharIterator(reused_nodes_cord);
1891    }
1892    RandomEngine rng(GTEST_FLAG_GET(random_seed));
1893    absl::Cord flat_cord(RandomLowercaseString(&rng, 256));
1894    absl::Cord subcords;
1895    for (int i = 0; i < 4; ++i) {
1896      subcords.Prepend(flat_cord.Subcord(16 * i, 128));
1897      MaybeHarden(subcords);
1898    }
1899    VerifyCharIterator(subcords);
1900  }
1901  TEST_P(CordTest, CharIteratorAdvanceAndRead) {
1902    constexpr int kBlocks = 6;
1903    constexpr size_t kBlockSize = 2500;
1904    constexpr size_t kChunkSize1 = 1500;
1905    constexpr size_t kChunkSize2 = 2500;
1906    constexpr size_t kChunkSize3 = 3000;
1907    constexpr size_t kChunkSize4 = 150;
1908    RandomEngine rng;
1909    std::string data = RandomLowercaseString(&rng, kBlocks * kBlockSize);
1910    absl::Cord cord;
1911    for (int i = 0; i < kBlocks; ++i) {
1912      const std::string block = data.substr(i * kBlockSize, kBlockSize);
1913      cord.Append(absl::Cord(block));
1914    }
1915    MaybeHarden(cord);
1916    for (size_t chunk_size :
1917         {kChunkSize1, kChunkSize2, kChunkSize3, kChunkSize4}) {
1918      absl::Cord::CharIterator it = cord.char_begin();
1919      size_t offset = 0;
1920      while (offset < data.length()) {
1921        const size_t n = std::min<size_t>(data.length() - offset, chunk_size);
1922        absl::Cord chunk = cord.AdvanceAndRead(&it, n);
1923        ASSERT_EQ(chunk.size(), n);
1924        ASSERT_EQ(chunk.Compare(data.substr(offset, n)), 0);
1925        offset += n;
1926      }
1927    }
1928  }
1929  TEST_P(CordTest, StreamingOutput) {
1930    absl::Cord c =
1931        absl::MakeFragmentedCord({"A ", "small ", "fragmented ", "Cord", "."});
1932    MaybeHarden(c);
1933    std::stringstream output;
1934    output << c;
1935    EXPECT_EQ("A small fragmented Cord.", output.str());
1936  }
1937  TEST_P(CordTest, ForEachChunk) {
1938    for (int num_elements : {1, 10, 200}) {
1939      SCOPED_TRACE(num_elements);
1940      std::vector<std::string> cord_chunks;
1941      for (int i = 0; i < num_elements; ++i) {
1942        cord_chunks.push_back(absl::StrCat("[", i, "]"));
1943      }
1944      absl::Cord c = absl::MakeFragmentedCord(cord_chunks);
1945      MaybeHarden(c);
1946      std::vector<std::string> iterated_chunks;
1947      absl::CordTestPeer::ForEachChunk(c,
1948                                       [&iterated_chunks](absl::string_view sv) {
1949                                         iterated_chunks.emplace_back(sv);
1950                                       });
1951      EXPECT_EQ(iterated_chunks, cord_chunks);
1952    }
1953  }
1954  TEST_P(CordTest, SmallBufferAssignFromOwnData) {
1955    constexpr size_t kMaxInline = 15;
1956    std::string contents = "small buff cord";
1957    EXPECT_EQ(contents.size(), kMaxInline);
1958    for (size_t pos = 0; pos < contents.size(); ++pos) {
1959      for (size_t count = contents.size() - pos; count > 0; --count) {
1960        absl::Cord c(contents);
1961        MaybeHarden(c);
1962        absl::string_view flat = c.Flatten();
1963        c = flat.substr(pos, count);
1964        EXPECT_EQ(c, contents.substr(pos, count))
1965            << "pos = " << pos << "; count = " << count;
1966      }
1967    }
1968  }
1969  TEST_P(CordTest, Format) {
1970    absl::Cord c;
1971    absl::Format(&c, "There were %04d little %s.", 3, "pigs");
1972    EXPECT_EQ(c, "There were 0003 little pigs.");
1973    MaybeHarden(c);
1974    absl::Format(&c, "And %-3llx bad wolf!", 1);
1975    MaybeHarden(c);
1976    EXPECT_EQ(c, "There were 0003 little pigs.And 1   bad wolf!");
1977  }
1978  TEST_P(CordTest, Hardening) {
1979    absl::Cord cord("hello");
1980    MaybeHarden(cord);
1981    EXPECT_DEATH_IF_SUPPORTED(cord.RemovePrefix(6), "");
1982    EXPECT_DEATH_IF_SUPPORTED(cord.RemoveSuffix(6), "");
1983    bool test_hardening = false;
1984    ABSL_HARDENING_ASSERT([&]() {
1985      test_hardening = true;
1986      return true;
1987    }());
1988    if (!test_hardening) return;
1989    EXPECT_DEATH_IF_SUPPORTED(cord[5], "");
1990    EXPECT_DEATH_IF_SUPPORTED(*cord.chunk_end(), "");
1991    EXPECT_DEATH_IF_SUPPORTED(static_cast<void>(cord.chunk_end()->empty()), "");
1992    EXPECT_DEATH_IF_SUPPORTED(++cord.chunk_end(), "");
1993  }
1994  TEST_P(CordTest, BtreeHostileSplitInsertJoin) {
1995    absl::BitGen bitgen;
1996    std::string data(1 << 10, 'x');
1997    absl::Cord buffer(data);
1998    absl::Cord cord;
1999    for (int i = 0; i < 1000000; ++i) {
2000      cord.Append(buffer);
2001    }
2002    for (int j = 0; j < 1000; ++j) {
2003      MaybeHarden(cord);
2004      size_t offset = absl::Uniform(bitgen, 0u, cord.size());
2005      size_t length = absl::Uniform(bitgen, 100u, data.size());
2006      if (cord.size() == offset) {
2007        cord.Append(absl::string_view(data.data(), length));
2008      } else {
2009        absl::Cord suffix;
2010        if (offset + length < cord.size()) {
2011          suffix = cord;
2012          suffix.RemovePrefix(offset + length);
2013        }
2014        if (cord.size() > offset) {
2015          cord.RemoveSuffix(cord.size() - offset);
2016        }
2017        cord.Append(absl::string_view(data.data(), length));
2018        if (!suffix.empty()) {
2019          cord.Append(suffix);
2020        }
2021      }
2022    }
2023  }
2024  class AfterExitCordTester {
2025   public:
2026    bool Set(absl::Cord* cord, absl::string_view expected) {
2027      cord_ = cord;
2028      expected_ = expected;
2029      return true;
2030    }
2031    ~AfterExitCordTester() {
2032      EXPECT_EQ(*cord_, expected_);
2033    }
2034   private:
2035    absl::Cord* cord_;
2036    absl::string_view expected_;
2037  };
2038  struct CordLeaker {
2039    union {
2040      absl::Cord cord;
2041    };
2042    template <typename Str>
2043    constexpr explicit CordLeaker(const Str& str) : cord(str) {}
2044    ~CordLeaker() {
2045    }
2046  };
2047  template <typename Str>
2048  void TestConstinitConstructor(Str) {
2049    const auto expected = Str::value;
2050    static AfterExitCordTester exit_tester;  
2051    ABSL_CONST_INIT static CordLeaker cord_leaker(Str{});  
2052    static absl::Cord& cord = cord_leaker.cord;
2053    static bool init_exit_tester = exit_tester.Set(&cord, expected);
2054    (void)init_exit_tester;
2055    EXPECT_EQ(cord, expected);
2056    {
2057      absl::Cord copy = cord;
2058      EXPECT_EQ(copy, expected);
2059    }
2060    EXPECT_EQ(cord, expected);
2061    {
2062      absl::Cord copy = cord;
2063      std::string expected_copy(expected);
2064      for (int i = 0; i < 10; ++i) {
2065        copy.Append(cord);
2066        absl::StrAppend(&expected_copy, expected);
2067        EXPECT_EQ(copy, expected_copy);
2068      }
2069    }
2070    EXPECT_EQ(absl::CordTestPeer::IsTree(cord), cord.size() >= 16);
2071    for (int i = 0; i < 10; ++i) {
2072      EXPECT_EQ(expected, absl::Cord(Str{}));
2073    }
2074  }
2075  constexpr int SimpleStrlen(const char* p) {
2076    return *p ? 1 + SimpleStrlen(p + 1) : 0;
2077  }
2078  struct ShortView {
2079    constexpr absl::string_view operator()() const {
2080      return absl::string_view("SSO string", SimpleStrlen("SSO string"));
2081    }
2082  };
2083  struct LongView {
2084    constexpr absl::string_view operator()() const {
2085      return absl::string_view("String that does not fit SSO.",
2086                               SimpleStrlen("String that does not fit SSO."));
2087    }
2088  };
2089  TEST_P(CordTest, ConstinitConstructor) {
2090    TestConstinitConstructor(
2091        absl::strings_internal::MakeStringConstant(ShortView{}));
2092    TestConstinitConstructor(
2093        absl::strings_internal::MakeStringConstant(LongView{}));
2094  }
2095  namespace {
2096  class PopulatedCordFactory {
2097   public:
2098    constexpr PopulatedCordFactory(absl::string_view name,
2099                                   absl::Cord (*generator)())
2100        : name_(name), generator_(generator) {}
2101    absl::string_view Name() const { return name_; }
2102    absl::Cord Generate() const { return generator_(); }
2103   private:
2104    absl::string_view name_;
2105    absl::Cord (*generator_)();
2106  };
2107  PopulatedCordFactory cord_factories[] = {
2108    {"sso", [] { return absl::Cord("abcde"); }},
2109    {"flat", [] {
2110      absl::Cord flat(absl::StrCat("abcde", std::string(1000, 'x')));
2111      flat.Flatten();
2112      return flat;
2113    }},
2114    {"external", [] {
2115      return absl::MakeCordFromExternal("abcde External!", []{});
2116    }},
2117    {"external substring", [] {
2118      absl::Cord ext = absl::MakeCordFromExternal("-abcde External!", []{});
2119      return absl::CordTestPeer::MakeSubstring(ext, 1, ext.size() - 1);
2120    }},
2121    {"substring", [] {
2122      absl::Cord flat(absl::StrCat("-abcde", std::string(1000, 'x')));
2123      flat.Flatten();
2124      return flat.Subcord(1, 998);
2125    }},
2126    {"fragmented", [] {
2127      std::string fragment = absl::StrCat("abcde", std::string(195, 'x'));
2128      std::vector<std::string> fragments(200, fragment);
2129      absl::Cord cord = absl::MakeFragmentedCord(fragments);
2130      assert(cord.size() == 40000);
2131      return cord;
2132    }},
2133  };
2134  class CordMutator {
2135   public:
2136    constexpr CordMutator(absl::string_view name, void (*mutate)(absl::Cord&),
2137                          void (*undo)(absl::Cord&) = nullptr)
2138        : name_(name), mutate_(mutate), undo_(undo) {}
2139    absl::string_view Name() const { return name_; }
2140    void Mutate(absl::Cord& cord) const { mutate_(cord); }
2141    bool CanUndo() const { return undo_ != nullptr; }
2142    void Undo(absl::Cord& cord) const { undo_(cord); }
2143   private:
2144    absl::string_view name_;
2145    void (*mutate_)(absl::Cord&);
2146    void (*undo_)(absl::Cord&);
2147  };
2148  CordMutator cord_mutators[] = {
2149    {"clear", [](absl::Cord& c) { c.Clear(); }},
2150    {"overwrite", [](absl::Cord& c) { c = "overwritten"; }},
2151    {
2152      "append string",
2153      [](absl::Cord& c) { c.Append("0123456789"); },
2154      [](absl::Cord& c) { c.RemoveSuffix(10); }
2155    },
2156    {
2157      "append cord",
2158      [](absl::Cord& c) {
2159        c.Append(absl::MakeFragmentedCord({"12345", "67890"}));
2160      },
2161      [](absl::Cord& c) { c.RemoveSuffix(10); }
2162    },
2163    {
2164      "append checksummed cord",
2165      [](absl::Cord& c) {
2166        absl::Cord to_append = absl::MakeFragmentedCord({"12345", "67890"});
2167        to_append.SetExpectedChecksum(999);
2168        c.Append(to_append);
2169      },
2170      [](absl::Cord& c) { c.RemoveSuffix(10); }
2171    },
2172    {
2173      "append self",
2174      [](absl::Cord& c) { c.Append(c); },
2175      [](absl::Cord& c) { c.RemoveSuffix(c.size() / 2); }
2176    },
2177    {
2178      "append empty string",
2179      [](absl::Cord& c) { c.Append(""); },
2180      [](absl::Cord& c) { }
2181    },
2182    {
2183      "append empty cord",
2184      [](absl::Cord& c) { c.Append(absl::Cord()); },
2185      [](absl::Cord& c) { }
2186    },
2187    {
2188      "append empty checksummed cord",
2189      [](absl::Cord& c) {
2190        absl::Cord to_append;
2191        to_append.SetExpectedChecksum(999);
2192        c.Append(to_append);
2193      },
2194      [](absl::Cord& c) { }
2195    },
2196    {
2197      "prepend string",
2198      [](absl::Cord& c) { c.Prepend("9876543210"); },
2199      [](absl::Cord& c) { c.RemovePrefix(10); }
2200    },
2201    {
2202      "prepend cord",
2203      [](absl::Cord& c) {
2204        c.Prepend(absl::MakeFragmentedCord({"98765", "43210"}));
2205      },
2206      [](absl::Cord& c) { c.RemovePrefix(10); }
2207    },
2208    {
2209      "prepend checksummed cord",
2210      [](absl::Cord& c) {
2211        absl::Cord to_prepend = absl::MakeFragmentedCord({"98765", "43210"});
2212        to_prepend.SetExpectedChecksum(999);
2213        c.Prepend(to_prepend);
2214      },
2215      [](absl::Cord& c) { c.RemovePrefix(10); }
2216    },
2217    {
2218      "prepend empty string",
2219      [](absl::Cord& c) { c.Prepend(""); },
2220      [](absl::Cord& c) { }
2221    },
2222    {
2223      "prepend empty cord",
2224      [](absl::Cord& c) { c.Prepend(absl::Cord()); },
2225      [](absl::Cord& c) { }
2226    },
2227    {
2228      "prepend empty checksummed cord",
2229      [](absl::Cord& c) {
2230        absl::Cord to_prepend;
2231        to_prepend.SetExpectedChecksum(999);
2232        c.Prepend(to_prepend);
2233      },
2234      [](absl::Cord& c) { }
2235    },
2236    {
2237      "prepend self",
2238      [](absl::Cord& c) { c.Prepend(c); },
2239      [](absl::Cord& c) { c.RemovePrefix(c.size() / 2); }
2240    },
2241    {"remove prefix", [](absl::Cord& c) { c.RemovePrefix(c.size() / 2); }},
2242    {"remove suffix", [](absl::Cord& c) { c.RemoveSuffix(c.size() / 2); }},
2243    {"remove 0-prefix", [](absl::Cord& c) { c.RemovePrefix(0); }},
2244    {"remove 0-suffix", [](absl::Cord& c) { c.RemoveSuffix(0); }},
2245    {"subcord", [](absl::Cord& c) { c = c.Subcord(1, c.size() - 2); }},
2246    {
2247      "swap inline",
2248      [](absl::Cord& c) {
2249        absl::Cord other("swap");
2250        c.swap(other);
2251      }
2252    },
2253    {
2254      "swap tree",
2255      [](absl::Cord& c) {
2256        absl::Cord other(std::string(10000, 'x'));
2257        c.swap(other);
2258      }
2259    },
2260  };
2261  }  
2262  TEST_P(CordTest, ExpectedChecksum) {
2263    for (const PopulatedCordFactory& factory : cord_factories) {
2264      SCOPED_TRACE(factory.Name());
2265      for (bool shared : {false, true}) {
2266        SCOPED_TRACE(shared);
2267        absl::Cord shared_cord_source = factory.Generate();
2268        auto make_instance = [=] {
2269          return shared ? shared_cord_source : factory.Generate();
2270        };
2271        const absl::Cord base_value = factory.Generate();
2272        const std::string base_value_as_string(factory.Generate().Flatten());
2273        absl::Cord c1 = make_instance();
2274        EXPECT_FALSE(c1.ExpectedChecksum().has_value());
2275        c1.SetExpectedChecksum(12345);
2276        EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2277        EXPECT_EQ(c1, base_value);
2278        c1.SetExpectedChecksum(12345);
2279        EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2280        EXPECT_EQ(c1, base_value);
2281        absl::Cord c1_copy_construct = c1;
2282        EXPECT_EQ(c1_copy_construct.ExpectedChecksum().value_or(0), 12345);
2283        absl::Cord c1_copy_assign;
2284        c1_copy_assign = c1;
2285        EXPECT_EQ(c1_copy_assign.ExpectedChecksum().value_or(0), 12345);
2286        absl::Cord c1_move(std::move(c1_copy_assign));
2287        EXPECT_EQ(c1_move.ExpectedChecksum().value_or(0), 12345);
2288        EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2289        EXPECT_EQ(c1, make_instance());
2290        for (const CordMutator& mutator : cord_mutators) {
2291          SCOPED_TRACE(mutator.Name());
2292          absl::Cord c2 = make_instance();
2293          c2.SetExpectedChecksum(24680);
2294          mutator.Mutate(c2);
2295          if (c1 == c2) {
2296            continue;
2297          }
2298          EXPECT_EQ(c2.ExpectedChecksum(), absl::nullopt);
2299          if (mutator.CanUndo()) {
2300            mutator.Undo(c2);
2301            EXPECT_EQ(c2, base_value);
2302            EXPECT_EQ(c2.ExpectedChecksum(), absl::nullopt);
2303          }
2304        }
2305        absl::Cord c3 = make_instance();
2306        c3.SetExpectedChecksum(999);
2307        const absl::Cord& cc3 = c3;
2308        ASSERT_TRUE(cc3.StartsWith("abcde"));
2309        EXPECT_EQ(cc3.size(), base_value_as_string.size());
2310        EXPECT_FALSE(cc3.empty());
2311        EXPECT_EQ(cc3.Compare(base_value), 0);
2312        EXPECT_EQ(cc3.Compare(base_value_as_string), 0);
2313        EXPECT_EQ(cc3.Compare("wxyz"), -1);
2314        EXPECT_EQ(cc3.Compare(absl::Cord("wxyz")), -1);
2315        EXPECT_EQ(cc3.Compare("aaaa"), 1);
2316        EXPECT_EQ(cc3.Compare(absl::Cord("aaaa")), 1);
2317        EXPECT_EQ(absl::Cord("wxyz").Compare(cc3), 1);
2318        EXPECT_EQ(absl::Cord("aaaa").Compare(cc3), -1);
2319        EXPECT_TRUE(cc3.StartsWith("abcd"));
2320        EXPECT_EQ(std::string(cc3), base_value_as_string);
2321        std::string dest;
2322        absl::CopyCordToString(cc3, &dest);
2323        EXPECT_EQ(dest, base_value_as_string);
2324        bool first_pass = true;
2325        for (absl::string_view chunk : cc3.Chunks()) {
2326          if (first_pass) {
2327            EXPECT_TRUE(absl::StartsWith(chunk, "abcde"));
2328          }
2329          first_pass = false;
2330        }
2331        first_pass = true;
2332        for (char ch : cc3.Chars()) {
2333          if (first_pass) {
2334            EXPECT_EQ(ch, 'a');
2335          }
2336          first_pass = false;
2337        }
2338        EXPECT_TRUE(absl::StartsWith(*cc3.chunk_begin(), "abcde"));
2339        EXPECT_EQ(*cc3.char_begin(), 'a');
2340        auto char_it = cc3.char_begin();
2341        absl::Cord::Advance(&char_it, 2);
2342        EXPECT_EQ(absl::Cord::AdvanceAndRead(&char_it, 2), "cd");
2343        EXPECT_EQ(*char_it, 'e');
2344        char_it = cc3.char_begin();
2345        absl::Cord::Advance(&char_it, 2);
2346        EXPECT_TRUE(absl::StartsWith(absl::Cord::ChunkRemaining(char_it), "cde"));
2347        EXPECT_EQ(cc3[0], 'a');
2348        EXPECT_EQ(cc3[4], 'e');
2349        EXPECT_EQ(absl::HashOf(cc3), absl::HashOf(base_value));
2350        EXPECT_EQ(absl::HashOf(cc3), absl::HashOf(base_value_as_string));
2351      }
2352    }
2353  }
2354  TEST_P(CordTest, ChecksummedEmptyCord) {
2355    absl::Cord c1;
2356    EXPECT_FALSE(c1.ExpectedChecksum().has_value());
2357    c1.SetExpectedChecksum(12345);
2358    EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2359    EXPECT_EQ(c1, "");
2360    EXPECT_TRUE(c1.empty());
2361    c1.SetExpectedChecksum(12345);
2362    EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2363    EXPECT_EQ(c1, "");
2364    EXPECT_TRUE(c1.empty());
2365    absl::Cord c1_copy_construct = c1;
2366    EXPECT_EQ(c1_copy_construct.ExpectedChecksum().value_or(0), 12345);
2367    absl::Cord c1_copy_assign;
2368    c1_copy_assign = c1;
2369    EXPECT_EQ(c1_copy_assign.ExpectedChecksum().value_or(0), 12345);
2370    absl::Cord c1_move(std::move(c1_copy_assign));
2371    EXPECT_EQ(c1_move.ExpectedChecksum().value_or(0), 12345);
2372    EXPECT_EQ(c1.ExpectedChecksum().value_or(0), 12345);
2373    EXPECT_EQ(c1, absl::Cord());
2374    for (const CordMutator& mutator : cord_mutators) {
2375      SCOPED_TRACE(mutator.Name());
2376      absl::Cord c2;
2377      c2.SetExpectedChecksum(24680);
2378      mutator.Mutate(c2);
2379      if (c2.empty()) {
2380        continue;
2381      }
2382      EXPECT_EQ(c2.ExpectedChecksum(), absl::nullopt);
2383      if (mutator.CanUndo()) {
2384        mutator.Undo(c2);
2385      }
2386    }
2387    absl::Cord c3;
2388    c3.SetExpectedChecksum(999);
2389    const absl::Cord& cc3 = c3;
2390    EXPECT_TRUE(cc3.StartsWith(""));
2391    EXPECT_TRUE(cc3.EndsWith(""));
2392    EXPECT_TRUE(cc3.empty());
2393    EXPECT_EQ(cc3, "");
2394    EXPECT_EQ(cc3, absl::Cord());
2395    EXPECT_EQ(cc3.size(), 0);
2396    EXPECT_EQ(cc3.Compare(absl::Cord()), 0);
2397    EXPECT_EQ(cc3.Compare(c1), 0);
2398    EXPECT_EQ(cc3.Compare(cc3), 0);
2399    EXPECT_EQ(cc3.Compare(""), 0);
2400    EXPECT_EQ(cc3.Compare("wxyz"), -1);
2401    EXPECT_EQ(cc3.Compare(absl::Cord("wxyz")), -1);
2402    EXPECT_EQ(absl::Cord("wxyz").Compare(cc3), 1);
2403    EXPECT_EQ(std::string(cc3), "");
2404    std::string dest;
2405    absl::CopyCordToString(cc3, &dest);
2406    EXPECT_EQ(dest, "");
2407    for (absl::string_view chunk : cc3.Chunks()) {  
2408      static_cast<void>(chunk);
2409      GTEST_FAIL() << "no chunks expected";
2410    }
2411    EXPECT_TRUE(cc3.chunk_begin() == cc3.chunk_end());
2412    for (char ch : cc3.Chars()) {  
2413      static_cast<void>(ch);
2414      GTEST_FAIL() << "no chars expected";
2415    }
2416    EXPECT_TRUE(cc3.char_begin() == cc3.char_end());
2417    EXPECT_EQ(cc3.TryFlat(), "");
2418    EXPECT_EQ(absl::HashOf(c3), absl::HashOf(absl::Cord()));
2419    EXPECT_EQ(absl::HashOf(c3), absl::HashOf(absl::string_view()));
2420  }
2421  #if defined(GTEST_HAS_DEATH_TEST) && defined(ABSL_INTERNAL_CORD_HAVE_SANITIZER)
2422  const char* MASanDeathExpr() {
2423    return "(use-after-poison|use-of-uninitialized-value)";
2424  }
2425  TEST(CordSanitizerTest, SanitizesEmptyCord) {
2426    absl::Cord cord;
2427    const char* data = cord.Flatten().data();
2428    EXPECT_DEATH(EXPECT_EQ(data[0], 0), MASanDeathExpr());
2429  }
2430  TEST(CordSanitizerTest, SanitizesSmallCord) {
2431    absl::Cord cord("Hello");
2432    const char* data = cord.Flatten().data();
2433    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2434  }
2435  TEST(CordSanitizerTest, SanitizesCordOnSetSSOValue) {
2436    absl::Cord cord("String that is too big to be an SSO value");
2437    cord = "Hello";
2438    const char* data = cord.Flatten().data();
2439    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2440  }
2441  TEST(CordSanitizerTest, SanitizesCordOnCopyCtor) {
2442    absl::Cord src("hello");
2443    absl::Cord dst(src);
2444    const char* data = dst.Flatten().data();
2445    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2446  }
2447  TEST(CordSanitizerTest, SanitizesCordOnMoveCtor) {
2448    absl::Cord src("hello");
2449    absl::Cord dst(std::move(src));
2450    const char* data = dst.Flatten().data();
2451    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2452  }
2453  TEST(CordSanitizerTest, SanitizesCordOnAssign) {
2454    absl::Cord src("hello");
2455    absl::Cord dst;
2456    dst = src;
2457    const char* data = dst.Flatten().data();
2458    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2459  }
2460  TEST(CordSanitizerTest, SanitizesCordOnMoveAssign) {
2461    absl::Cord src("hello");
2462    absl::Cord dst;
2463    dst = std::move(src);
2464    const char* data = dst.Flatten().data();
2465    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2466  }
2467  TEST(CordSanitizerTest, SanitizesCordOnSsoAssign) {
2468    absl::Cord src("hello");
2469    absl::Cord dst("String that is too big to be an SSO value");
2470    dst = src;
2471    const char* data = dst.Flatten().data();
2472    EXPECT_DEATH(EXPECT_EQ(data[5], 0), MASanDeathExpr());
2473  }
2474  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_test.cc</div>
                <div class="column column_space"><pre><code>28  	Sci::Position ElementFromPosition(Sci::Position position) const noexcept {
29  		if (position < Length()) {
30  			return starts.PartitionFromPosition(position);
31  		} else {
32  			return starts.Partitions();
33  		}
34  	}
</pre></code></div>
                <div class="column column_space"><pre><code>54  static size_t GetUniformRandomUpTo(RandomEngine* rng, size_t upper_bound) {
55    if (upper_bound > 0) {
56      std::uniform_int_distribution<size_t> uniform(0, upper_bound - 1);
57      return uniform(*rng);
58    } else {
59      return 0;
60    }
61  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    