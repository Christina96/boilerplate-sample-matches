
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-common.cpp</h3>
            <pre><code>1  #include <boost/thread.hpp>
2  #include <glog/logging.h>
3  #include <cmath>
4  #include <cstdio>
5  #include <ctime>
6  #if defined(_MSC_EXTENSIONS)
7  #include <process.h>
8  #define getpid() _getpid()
9  #endif
10  #include "caffe/common.hpp"
11  #include "caffe/util/rng.hpp"
12  #ifdef _OPENMP
13  #include <omp.h>
14  #endif
15  namespace caffe {
16  static boost::thread_specific_ptr<Caffe> thread_instance_;
17  Caffe& Caffe::Get() {
18    if (!thread_instance_.get()) {
19      thread_instance_.reset(new Caffe());
20    }
21    return *(thread_instance_.get());
22  }
23  int64_t cluster_seedgen(void) {
24  #ifdef DETERMINISTIC
25    return 4013;
26  #else
27    int64_t s, seed, pid;
28    FILE* f = fopen("/dev/urandom", "rb");
29    if (f && fread(&seed, 1, sizeof(seed), f) == sizeof(seed)) {
30      fclose(f);
31      return seed;
32    }
33    LOG(INFO) << "System entropy source not available, "
34                "using fallback algorithm to generate seed instead.";
35    if (f)
36      fclose(f);
37    pid = getpid();
38    s = time(NULL);
39    seed = std::abs(((s * 181) * ((pid - 83) * 359)) % 104729);
40    return seed;
41  #endif
42  }
43  void GlobalInit(int* pargc, char*** pargv) {
44    ::gflags::ParseCommandLineFlags(pargc, pargv, true);
45    ::google::InitGoogleLogging(*(pargv)[0]);
46    ::google::InstallFailureSignalHandler();
47  }
48  #ifdef CPU_ONLY  
49  Caffe::Caffe()
50      : random_generator_(), mode_(Caffe::CPU),
51        solver_count_(1), root_solver_(true), iter_size_(1) { }
52  Caffe::~Caffe() { }
53  void Caffe::set_random_seed(const unsigned int seed) {
54    Get().random_generator_.reset(new RNG(seed));
55  }
56  void Caffe::SetDevice(const int device_id) {
57    NO_GPU;
58  }
59  void Caffe::DeviceQuery() {
60    NO_GPU;
61  }
62  bool Caffe::CheckDevice(const int device_id) {
63    NO_GPU;
64    return false;
65  }
66  int Caffe::FindDevice(const int start_id) {
67    NO_GPU;
68    return -1;
69  }
70  class Caffe::RNG::Generator {
71   public:
72    Generator() : rng_(new caffe::rng_t(cluster_seedgen())) {}
73    explicit Generator(unsigned int seed) : rng_(new caffe::rng_t(seed)) {}
74    caffe::rng_t* rng() { return rng_.get(); }
75   private:
76    shared_ptr<caffe::rng_t> rng_;
77  };
78  Caffe::RNG::RNG() : generator_(new Generator()) { }
<span onclick='openModal()' class='match'>79  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
80  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
81    generator_ = other.generator_;
</span>82    return *this;
83  }
84  void* Caffe::RNG::generator() {
85    return static_cast<void*>(generator_->rng());
86  }
87  #else  
88  Caffe::Caffe()
89      : cublas_handle_(NULL), curand_generator_(NULL), random_generator_(),
90      mode_(Caffe::CPU), solver_count_(1), root_solver_(true), iter_size_(1) {
91    if (cublasCreate(&cublas_handle_) != CUBLAS_STATUS_SUCCESS) {
92      LOG(ERROR) << "Cannot create Cublas handle. Cublas won't be available.";
93    }
94    if (curandCreateGenerator(&curand_generator_, CURAND_RNG_PSEUDO_DEFAULT)
95        != CURAND_STATUS_SUCCESS ||
96        curandSetPseudoRandomGeneratorSeed(curand_generator_, cluster_seedgen())
97        != CURAND_STATUS_SUCCESS) {
98      LOG(ERROR) << "Cannot create Curand generator. Curand won't be available.";
99    }
100  }
101  Caffe::~Caffe() {
102  #ifdef _OPENMP
103    if (0 == omp_get_thread_num()) {
104  #endif
105    if (cublas_handle_) CUBLAS_CHECK(cublasDestroy(cublas_handle_));
106    if (curand_generator_) {
107      CURAND_CHECK(curandDestroyGenerator(curand_generator_));
108    }
109  #ifdef _OPENMP
110    }
111  #endif
112  }
113  void Caffe::set_random_seed(const unsigned int seed) {
114    static bool g_curand_availability_logged = false;
115    if (Get().curand_generator_) {
116      CURAND_CHECK(curandSetPseudoRandomGeneratorSeed(curand_generator(),
117          seed));
118      CURAND_CHECK(curandSetGeneratorOffset(curand_generator(), 0));
119    } else {
120      if (!g_curand_availability_logged) {
121          LOG(ERROR) <<
122              "Curand not available. Skipping setting the curand seed.";
123          g_curand_availability_logged = true;
124      }
125    }
126    Get().random_generator_.reset(new RNG(seed));
127  }
128  void Caffe::SetDevice(const int device_id) {
129    int current_device;
130    CUDA_CHECK(cudaGetDevice(&current_device));
131    if (current_device == device_id) {
132      return;
133    }
134    CUDA_CHECK(cudaSetDevice(device_id));
135    if (Get().cublas_handle_) CUBLAS_CHECK(cublasDestroy(Get().cublas_handle_));
136    if (Get().curand_generator_) {
137      CURAND_CHECK(curandDestroyGenerator(Get().curand_generator_));
138    }
139    CUBLAS_CHECK(cublasCreate(&Get().cublas_handle_));
140    CURAND_CHECK(curandCreateGenerator(&Get().curand_generator_,
141        CURAND_RNG_PSEUDO_DEFAULT));
142    CURAND_CHECK(curandSetPseudoRandomGeneratorSeed(Get().curand_generator_,
143        cluster_seedgen()));
144  }
145  void Caffe::DeviceQuery() {
146    cudaDeviceProp prop;
147    int device;
148    if (cudaSuccess != cudaGetDevice(&device)) {
149      printf("No cuda device present.\n");
150      return;
151    }
152    CUDA_CHECK(cudaGetDeviceProperties(&prop, device));
153    LOG(INFO) << "Device id:                     " << device;
154    LOG(INFO) << "Major revision number:         " << prop.major;
155    LOG(INFO) << "Minor revision number:         " << prop.minor;
156    LOG(INFO) << "Name:                          " << prop.name;
157    LOG(INFO) << "Total global memory:           " << prop.totalGlobalMem;
158    LOG(INFO) << "Total shared memory per block: " << prop.sharedMemPerBlock;
159    LOG(INFO) << "Total registers per block:     " << prop.regsPerBlock;
160    LOG(INFO) << "Warp size:                     " << prop.warpSize;
161    LOG(INFO) << "Maximum memory pitch:          " << prop.memPitch;
162    LOG(INFO) << "Maximum threads per block:     " << prop.maxThreadsPerBlock;
163    LOG(INFO) << "Maximum dimension of block:    "
164        << prop.maxThreadsDim[0] << ", " << prop.maxThreadsDim[1] << ", "
165        << prop.maxThreadsDim[2];
166    LOG(INFO) << "Maximum dimension of grid:     "
167        << prop.maxGridSize[0] << ", " << prop.maxGridSize[1] << ", "
168        << prop.maxGridSize[2];
169    LOG(INFO) << "Clock rate:                    " << prop.clockRate;
170    LOG(INFO) << "Total constant memory:         " << prop.totalConstMem;
171    LOG(INFO) << "Texture alignment:             " << prop.textureAlignment;
172    LOG(INFO) << "Concurrent copy and execution: "
173        << (prop.deviceOverlap ? "Yes" : "No");
174    LOG(INFO) << "Number of multiprocessors:     " << prop.multiProcessorCount;
175    LOG(INFO) << "Kernel execution timeout:      "
176        << (prop.kernelExecTimeoutEnabled ? "Yes" : "No");
177    return;
178  }
179  bool Caffe::CheckDevice(const int device_id) {
180    bool r = ((cudaSuccess == cudaSetDevice(device_id)) &&
181              (cudaSuccess == cudaFree(0)));
182    cudaGetLastError();
183    return r;
184  }
185  int Caffe::FindDevice(const int start_id) {
186    int count = 0;
187    CUDA_CHECK(cudaGetDeviceCount(&count));
188    for (int i = start_id; i < count; i++) {
189      if (CheckDevice(i)) return i;
190    }
191    return -1;
192  }
193  class Caffe::RNG::Generator {
194   public:
195    Generator() : rng_(new caffe::rng_t(cluster_seedgen())) {}
196    explicit Generator(unsigned int seed) : rng_(new caffe::rng_t(seed)) {}
197    caffe::rng_t* rng() { return rng_.get(); }
198   private:
199    shared_ptr<caffe::rng_t> rng_;
200  };
201  Caffe::RNG::RNG() : generator_(new Generator()) { }
202  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
203  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
204    generator_.reset(other.generator_.get());
205    return *this;
206  }
207  void* Caffe::RNG::generator() {
208    return static_cast<void*>(generator_->rng());
209  }
210  const char* cublasGetErrorString(cublasStatus_t error) {
211    switch (error) {
212    case CUBLAS_STATUS_SUCCESS:
213      return "CUBLAS_STATUS_SUCCESS";
214    case CUBLAS_STATUS_NOT_INITIALIZED:
215      return "CUBLAS_STATUS_NOT_INITIALIZED";
216    case CUBLAS_STATUS_ALLOC_FAILED:
217      return "CUBLAS_STATUS_ALLOC_FAILED";
218    case CUBLAS_STATUS_INVALID_VALUE:
219      return "CUBLAS_STATUS_INVALID_VALUE";
220    case CUBLAS_STATUS_ARCH_MISMATCH:
221      return "CUBLAS_STATUS_ARCH_MISMATCH";
222    case CUBLAS_STATUS_MAPPING_ERROR:
223      return "CUBLAS_STATUS_MAPPING_ERROR";
224    case CUBLAS_STATUS_EXECUTION_FAILED:
225      return "CUBLAS_STATUS_EXECUTION_FAILED";
226    case CUBLAS_STATUS_INTERNAL_ERROR:
227      return "CUBLAS_STATUS_INTERNAL_ERROR";
228  #if CUDA_VERSION >= 6000
229    case CUBLAS_STATUS_NOT_SUPPORTED:
230      return "CUBLAS_STATUS_NOT_SUPPORTED";
231  #endif
232  #if CUDA_VERSION >= 6050
233    case CUBLAS_STATUS_LICENSE_ERROR:
234      return "CUBLAS_STATUS_LICENSE_ERROR";
235  #endif
236    }
237    return "Unknown cublas status";
238  }
239  const char* curandGetErrorString(curandStatus_t error) {
240    switch (error) {
241    case CURAND_STATUS_SUCCESS:
242      return "CURAND_STATUS_SUCCESS";
243    case CURAND_STATUS_VERSION_MISMATCH:
244      return "CURAND_STATUS_VERSION_MISMATCH";
245    case CURAND_STATUS_NOT_INITIALIZED:
246      return "CURAND_STATUS_NOT_INITIALIZED";
247    case CURAND_STATUS_ALLOCATION_FAILED:
248      return "CURAND_STATUS_ALLOCATION_FAILED";
249    case CURAND_STATUS_TYPE_ERROR:
250      return "CURAND_STATUS_TYPE_ERROR";
251    case CURAND_STATUS_OUT_OF_RANGE:
252      return "CURAND_STATUS_OUT_OF_RANGE";
253    case CURAND_STATUS_LENGTH_NOT_MULTIPLE:
254      return "CURAND_STATUS_LENGTH_NOT_MULTIPLE";
255    case CURAND_STATUS_DOUBLE_PRECISION_REQUIRED:
256      return "CURAND_STATUS_DOUBLE_PRECISION_REQUIRED";
257    case CURAND_STATUS_LAUNCH_FAILURE:
258      return "CURAND_STATUS_LAUNCH_FAILURE";
259    case CURAND_STATUS_PREEXISTING_FAILURE:
260      return "CURAND_STATUS_PREEXISTING_FAILURE";
261    case CURAND_STATUS_INITIALIZATION_FAILED:
262      return "CURAND_STATUS_INITIALIZATION_FAILED";
263    case CURAND_STATUS_ARCH_MISMATCH:
264      return "CURAND_STATUS_ARCH_MISMATCH";
265    case CURAND_STATUS_INTERNAL_ERROR:
266      return "CURAND_STATUS_INTERNAL_ERROR";
267    }
268    return "Unknown curand status";
269  }
270  #endif  
271  }  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-common.cpp</h3>
            <pre><code>1  #include <boost/thread.hpp>
2  #include <glog/logging.h>
3  #include <cmath>
4  #include <cstdio>
5  #include <ctime>
6  #if defined(_MSC_EXTENSIONS)
7  #include <process.h>
8  #define getpid() _getpid()
9  #endif
10  #include "caffe/common.hpp"
11  #include "caffe/util/rng.hpp"
12  #ifdef _OPENMP
13  #include <omp.h>
14  #endif
15  namespace caffe {
16  static boost::thread_specific_ptr<Caffe> thread_instance_;
17  Caffe& Caffe::Get() {
18    if (!thread_instance_.get()) {
19      thread_instance_.reset(new Caffe());
20    }
21    return *(thread_instance_.get());
22  }
23  int64_t cluster_seedgen(void) {
24  #ifdef DETERMINISTIC
25    return 4013;
26  #else
27    int64_t s, seed, pid;
28    FILE* f = fopen("/dev/urandom", "rb");
29    if (f && fread(&seed, 1, sizeof(seed), f) == sizeof(seed)) {
30      fclose(f);
31      return seed;
32    }
33    LOG(INFO) << "System entropy source not available, "
34                "using fallback algorithm to generate seed instead.";
35    if (f)
36      fclose(f);
37    pid = getpid();
38    s = time(NULL);
39    seed = std::abs(((s * 181) * ((pid - 83) * 359)) % 104729);
40    return seed;
41  #endif
42  }
43  void GlobalInit(int* pargc, char*** pargv) {
44    ::gflags::ParseCommandLineFlags(pargc, pargv, true);
45    ::google::InitGoogleLogging(*(pargv)[0]);
46    ::google::InstallFailureSignalHandler();
47  }
48  #ifdef CPU_ONLY  
49  Caffe::Caffe()
50      : random_generator_(), mode_(Caffe::CPU),
51        solver_count_(1), root_solver_(true), iter_size_(1) { }
52  Caffe::~Caffe() { }
53  void Caffe::set_random_seed(const unsigned int seed) {
54    Get().random_generator_.reset(new RNG(seed));
55  }
56  void Caffe::SetDevice(const int device_id) {
57    NO_GPU;
58  }
59  void Caffe::DeviceQuery() {
60    NO_GPU;
61  }
62  bool Caffe::CheckDevice(const int device_id) {
63    NO_GPU;
64    return false;
65  }
66  int Caffe::FindDevice(const int start_id) {
67    NO_GPU;
68    return -1;
69  }
70  class Caffe::RNG::Generator {
71   public:
72    Generator() : rng_(new caffe::rng_t(cluster_seedgen())) {}
73    explicit Generator(unsigned int seed) : rng_(new caffe::rng_t(seed)) {}
74    caffe::rng_t* rng() { return rng_.get(); }
75   private:
76    shared_ptr<caffe::rng_t> rng_;
77  };
78  Caffe::RNG::RNG() : generator_(new Generator()) { }
79  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
80  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
81    generator_ = other.generator_;
82    return *this;
83  }
84  void* Caffe::RNG::generator() {
85    return static_cast<void*>(generator_->rng());
86  }
87  #else  
88  Caffe::Caffe()
89      : cublas_handle_(NULL), curand_generator_(NULL), random_generator_(),
90      mode_(Caffe::CPU), solver_count_(1), root_solver_(true), iter_size_(1) {
91    if (cublasCreate(&cublas_handle_) != CUBLAS_STATUS_SUCCESS) {
92      LOG(ERROR) << "Cannot create Cublas handle. Cublas won't be available.";
93    }
94    if (curandCreateGenerator(&curand_generator_, CURAND_RNG_PSEUDO_DEFAULT)
95        != CURAND_STATUS_SUCCESS ||
96        curandSetPseudoRandomGeneratorSeed(curand_generator_, cluster_seedgen())
97        != CURAND_STATUS_SUCCESS) {
98      LOG(ERROR) << "Cannot create Curand generator. Curand won't be available.";
99    }
100  }
101  Caffe::~Caffe() {
102  #ifdef _OPENMP
103    if (0 == omp_get_thread_num()) {
104  #endif
105    if (cublas_handle_) CUBLAS_CHECK(cublasDestroy(cublas_handle_));
106    if (curand_generator_) {
107      CURAND_CHECK(curandDestroyGenerator(curand_generator_));
108    }
109  #ifdef _OPENMP
110    }
111  #endif
112  }
113  void Caffe::set_random_seed(const unsigned int seed) {
114    static bool g_curand_availability_logged = false;
115    if (Get().curand_generator_) {
116      CURAND_CHECK(curandSetPseudoRandomGeneratorSeed(curand_generator(),
117          seed));
118      CURAND_CHECK(curandSetGeneratorOffset(curand_generator(), 0));
119    } else {
120      if (!g_curand_availability_logged) {
121          LOG(ERROR) <<
122              "Curand not available. Skipping setting the curand seed.";
123          g_curand_availability_logged = true;
124      }
125    }
126    Get().random_generator_.reset(new RNG(seed));
127  }
128  void Caffe::SetDevice(const int device_id) {
129    int current_device;
130    CUDA_CHECK(cudaGetDevice(&current_device));
131    if (current_device == device_id) {
132      return;
133    }
134    CUDA_CHECK(cudaSetDevice(device_id));
135    if (Get().cublas_handle_) CUBLAS_CHECK(cublasDestroy(Get().cublas_handle_));
136    if (Get().curand_generator_) {
137      CURAND_CHECK(curandDestroyGenerator(Get().curand_generator_));
138    }
139    CUBLAS_CHECK(cublasCreate(&Get().cublas_handle_));
140    CURAND_CHECK(curandCreateGenerator(&Get().curand_generator_,
141        CURAND_RNG_PSEUDO_DEFAULT));
142    CURAND_CHECK(curandSetPseudoRandomGeneratorSeed(Get().curand_generator_,
143        cluster_seedgen()));
144  }
145  void Caffe::DeviceQuery() {
146    cudaDeviceProp prop;
147    int device;
148    if (cudaSuccess != cudaGetDevice(&device)) {
149      printf("No cuda device present.\n");
150      return;
151    }
152    CUDA_CHECK(cudaGetDeviceProperties(&prop, device));
153    LOG(INFO) << "Device id:                     " << device;
154    LOG(INFO) << "Major revision number:         " << prop.major;
155    LOG(INFO) << "Minor revision number:         " << prop.minor;
156    LOG(INFO) << "Name:                          " << prop.name;
157    LOG(INFO) << "Total global memory:           " << prop.totalGlobalMem;
158    LOG(INFO) << "Total shared memory per block: " << prop.sharedMemPerBlock;
159    LOG(INFO) << "Total registers per block:     " << prop.regsPerBlock;
160    LOG(INFO) << "Warp size:                     " << prop.warpSize;
161    LOG(INFO) << "Maximum memory pitch:          " << prop.memPitch;
162    LOG(INFO) << "Maximum threads per block:     " << prop.maxThreadsPerBlock;
163    LOG(INFO) << "Maximum dimension of block:    "
164        << prop.maxThreadsDim[0] << ", " << prop.maxThreadsDim[1] << ", "
165        << prop.maxThreadsDim[2];
166    LOG(INFO) << "Maximum dimension of grid:     "
167        << prop.maxGridSize[0] << ", " << prop.maxGridSize[1] << ", "
168        << prop.maxGridSize[2];
169    LOG(INFO) << "Clock rate:                    " << prop.clockRate;
170    LOG(INFO) << "Total constant memory:         " << prop.totalConstMem;
171    LOG(INFO) << "Texture alignment:             " << prop.textureAlignment;
172    LOG(INFO) << "Concurrent copy and execution: "
173        << (prop.deviceOverlap ? "Yes" : "No");
174    LOG(INFO) << "Number of multiprocessors:     " << prop.multiProcessorCount;
175    LOG(INFO) << "Kernel execution timeout:      "
176        << (prop.kernelExecTimeoutEnabled ? "Yes" : "No");
177    return;
178  }
179  bool Caffe::CheckDevice(const int device_id) {
180    bool r = ((cudaSuccess == cudaSetDevice(device_id)) &&
181              (cudaSuccess == cudaFree(0)));
182    cudaGetLastError();
183    return r;
184  }
185  int Caffe::FindDevice(const int start_id) {
186    int count = 0;
187    CUDA_CHECK(cudaGetDeviceCount(&count));
188    for (int i = start_id; i < count; i++) {
189      if (CheckDevice(i)) return i;
190    }
191    return -1;
192  }
193  class Caffe::RNG::Generator {
194   public:
195    Generator() : rng_(new caffe::rng_t(cluster_seedgen())) {}
196    explicit Generator(unsigned int seed) : rng_(new caffe::rng_t(seed)) {}
197    caffe::rng_t* rng() { return rng_.get(); }
198   private:
199    shared_ptr<caffe::rng_t> rng_;
200  };
201  Caffe::RNG::RNG() : generator_(new Generator()) { }
<span onclick='openModal()' class='match'>202  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
203  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
204    generator_.reset(other.generator_.get());
</span>205    return *this;
206  }
207  void* Caffe::RNG::generator() {
208    return static_cast<void*>(generator_->rng());
209  }
210  const char* cublasGetErrorString(cublasStatus_t error) {
211    switch (error) {
212    case CUBLAS_STATUS_SUCCESS:
213      return "CUBLAS_STATUS_SUCCESS";
214    case CUBLAS_STATUS_NOT_INITIALIZED:
215      return "CUBLAS_STATUS_NOT_INITIALIZED";
216    case CUBLAS_STATUS_ALLOC_FAILED:
217      return "CUBLAS_STATUS_ALLOC_FAILED";
218    case CUBLAS_STATUS_INVALID_VALUE:
219      return "CUBLAS_STATUS_INVALID_VALUE";
220    case CUBLAS_STATUS_ARCH_MISMATCH:
221      return "CUBLAS_STATUS_ARCH_MISMATCH";
222    case CUBLAS_STATUS_MAPPING_ERROR:
223      return "CUBLAS_STATUS_MAPPING_ERROR";
224    case CUBLAS_STATUS_EXECUTION_FAILED:
225      return "CUBLAS_STATUS_EXECUTION_FAILED";
226    case CUBLAS_STATUS_INTERNAL_ERROR:
227      return "CUBLAS_STATUS_INTERNAL_ERROR";
228  #if CUDA_VERSION >= 6000
229    case CUBLAS_STATUS_NOT_SUPPORTED:
230      return "CUBLAS_STATUS_NOT_SUPPORTED";
231  #endif
232  #if CUDA_VERSION >= 6050
233    case CUBLAS_STATUS_LICENSE_ERROR:
234      return "CUBLAS_STATUS_LICENSE_ERROR";
235  #endif
236    }
237    return "Unknown cublas status";
238  }
239  const char* curandGetErrorString(curandStatus_t error) {
240    switch (error) {
241    case CURAND_STATUS_SUCCESS:
242      return "CURAND_STATUS_SUCCESS";
243    case CURAND_STATUS_VERSION_MISMATCH:
244      return "CURAND_STATUS_VERSION_MISMATCH";
245    case CURAND_STATUS_NOT_INITIALIZED:
246      return "CURAND_STATUS_NOT_INITIALIZED";
247    case CURAND_STATUS_ALLOCATION_FAILED:
248      return "CURAND_STATUS_ALLOCATION_FAILED";
249    case CURAND_STATUS_TYPE_ERROR:
250      return "CURAND_STATUS_TYPE_ERROR";
251    case CURAND_STATUS_OUT_OF_RANGE:
252      return "CURAND_STATUS_OUT_OF_RANGE";
253    case CURAND_STATUS_LENGTH_NOT_MULTIPLE:
254      return "CURAND_STATUS_LENGTH_NOT_MULTIPLE";
255    case CURAND_STATUS_DOUBLE_PRECISION_REQUIRED:
256      return "CURAND_STATUS_DOUBLE_PRECISION_REQUIRED";
257    case CURAND_STATUS_LAUNCH_FAILURE:
258      return "CURAND_STATUS_LAUNCH_FAILURE";
259    case CURAND_STATUS_PREEXISTING_FAILURE:
260      return "CURAND_STATUS_PREEXISTING_FAILURE";
261    case CURAND_STATUS_INITIALIZATION_FAILED:
262      return "CURAND_STATUS_INITIALIZATION_FAILED";
263    case CURAND_STATUS_ARCH_MISMATCH:
264      return "CURAND_STATUS_ARCH_MISMATCH";
265    case CURAND_STATUS_INTERNAL_ERROR:
266      return "CURAND_STATUS_INTERNAL_ERROR";
267    }
268    return "Unknown curand status";
269  }
270  #endif  
271  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-common.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-common.cpp</div>
                </div>
                <div class="column column_space"><pre><code>79  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
80  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
81    generator_ = other.generator_;
</pre></code></div>
                <div class="column column_space"><pre><code>202  Caffe::RNG::RNG(unsigned int seed) : generator_(new Generator(seed)) { }
203  Caffe::RNG& Caffe::RNG::operator=(const RNG& other) {
204    generator_.reset(other.generator_.get());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    