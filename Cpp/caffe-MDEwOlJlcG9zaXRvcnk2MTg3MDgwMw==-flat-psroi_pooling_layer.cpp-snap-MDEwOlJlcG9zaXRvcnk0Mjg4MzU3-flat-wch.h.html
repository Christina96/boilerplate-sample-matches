
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.444444444444445%, Tokens: 13</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-psroi_pooling_layer.cpp</h3>
            <pre><code>1  #include <cfloat>
2  #include <algorithm>
3  #include <string>
4  #include <utility>
5  #include <vector>
6  #include "caffe/layers/psroi_pooling_layer.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #ifdef _OPENMP
9  #include <omp.h>
10  #endif
11  using std::max;
12  using std::min;
13  using std::floor;
14  using std::ceil;
15  namespace caffe {
16    template <typename Dtype>
17    void PSROIPoolingLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
18      const vector<Blob<Dtype>*>& top) {
19      PSROIPoolingParameter psroi_pooling_param =
20        this->layer_param_.psroi_pooling_param();
21      spatial_scale_ = psroi_pooling_param.spatial_scale();
22      LOG(ERROR) << "Spatial scale: " << spatial_scale_;
23      CHECK_GT(psroi_pooling_param.output_dim(), 0)
24        << "output_dim must be > 0";
25      CHECK_GT(psroi_pooling_param.group_size(), 0)
26        << "group_size must be > 0";
27      output_dim_ = psroi_pooling_param.output_dim();
28      group_size_ = psroi_pooling_param.group_size();
29      pooled_height_ = group_size_;
30      pooled_width_ = group_size_;
31    }
32    template <typename Dtype>
33    void PSROIPoolingLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
34      const vector<Blob<Dtype>*>& top) {
35      channels_ = bottom[0]->channels();
36      CHECK_EQ(channels_, output_dim_ * group_size_ * group_size_)
37        << "input channel number does not match layer parameters";
38      height_ = bottom[0]->height();
39      width_ = bottom[0]->width();
40      top[0]->Reshape(
41        bottom[1]->num(), output_dim_, pooled_height_, pooled_width_);
42      mapping_channel_.Reshape(
43        bottom[1]->num(), output_dim_, pooled_height_, pooled_width_);
44    }
45    template <typename Dtype>
46    static void PSROIPoolingForward(
47      const int num,
48      const Dtype* bottom_data,
49      const Dtype spatial_scale,
50      const int channels,
51      const int height, const int width,
52      const int pooled_height, const int pooled_width,
53      const Dtype* bottom_rois,
54      const int output_dim,
55      const int group_size,
56      Dtype* top_data,
57      int* mapping_channel) {
58        int pixels = width * height;
59  #ifdef _OPENMP
60  	#pragma omp parallel for
61  #endif
62       for (int n = 0; n < num; ++n) {
63          int roi_add = n * 5;
64          int roi_batch_ind = bottom_rois[roi_add];
65          Dtype roi_start_w =
66            static_cast<Dtype>(round(bottom_rois[roi_add + 1])) * spatial_scale;
67          Dtype roi_start_h =
68            static_cast<Dtype>(round(bottom_rois[roi_add + 2])) * spatial_scale;
69          Dtype roi_end_w =
70            static_cast<Dtype>(round(bottom_rois[roi_add + 3]) + 1.) * spatial_scale;
71          Dtype roi_end_h =
72            static_cast<Dtype>(round(bottom_rois[roi_add + 4]) + 1.) * spatial_scale;
73          Dtype roi_width = max<Dtype>(roi_end_w - roi_start_w, 0.1);  
74          Dtype roi_height = max<Dtype>(roi_end_h - roi_start_h, 0.1);
75          Dtype bin_size_h = roi_height / static_cast<Dtype>(pooled_height);
76          Dtype bin_size_w = roi_width / static_cast<Dtype>(pooled_width);
77          int top_roi_offset = n * output_dim * pooled_height * pooled_width;
78          for (int ctop = 0; ctop < output_dim; ++ctop) {
79            int top_plane_offset = top_roi_offset + ctop * pooled_height * pooled_width;
80            for (int ph = 0; ph < pooled_height; ++ph) {
81              int top_row_offset = top_plane_offset + ph * pooled_width;
82              for (int pw = 0; pw < pooled_width; ++pw) {
83                int index = top_row_offset + pw;
84                int hstart = floor(static_cast<Dtype>(ph) * bin_size_h + roi_start_h);
85                int wstart = floor(static_cast<Dtype>(pw) * bin_size_w + roi_start_w);
86                int hend = ceil(static_cast<Dtype>(ph + 1) * bin_size_h + roi_start_h);
87                int wend = ceil(static_cast<Dtype>(pw + 1) * bin_size_w + roi_start_w);
88                hstart = min(max(hstart, 0), height);
89                hend = min(max(hend, 0), height);
90                wstart = min(max(wstart, 0), width);
91                wend = min(max(wend, 0), width);
92                bool is_empty = (hend <= hstart) || (wend <= wstart);
93                int gw = pw;
94                int gh = ph;
95                int c = (ctop * group_size + gh) * group_size + gw;
96                Dtype out_sum = 0;
97                int bottom_base_offset = (roi_batch_ind * channels + c) * pixels;
98                const Dtype *current_bottom = bottom_data + bottom_base_offset;
99                for (int h = hstart; h < hend; ++h) {
100                  int roi_row_offset = h * width;
101                  for (int w = wstart; w < wend; ++w) {
102                    int bottom_index = roi_row_offset + w;
103                    out_sum += current_bottom[bottom_index];
104                  }
105                }
106                Dtype bin_area = (hend - hstart) * (wend - wstart);
107                top_data[index] = is_empty ? 0. : out_sum / bin_area;
108                mapping_channel[index] = c;
109              }
110            }
111          }
112      }
113    }
114    template <typename Dtype>
115    void PSROIPoolingLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
116      const vector<Blob<Dtype>*>& top) {
117      const Dtype* bottom_data = bottom[0]->cpu_data();
118      const Dtype* bottom_rois = bottom[1]->cpu_data();
119      Dtype* top_data = top[0]->mutable_cpu_data();
120      int* mapping_channel_ptr = mapping_channel_.mutable_cpu_data();
121      int count = top[0]->count();
122      caffe_set(count, Dtype(0), top_data);
123      caffe_set(count, -1, mapping_channel_ptr);
124      PSROIPoolingForward(bottom[1]->num(), bottom_data, spatial_scale_,
125        channels_, height_, width_, pooled_height_,
126        pooled_width_, bottom_rois, output_dim_, group_size_,
127        top_data, mapping_channel_ptr);
128    }
129    template <typename Dtype>
130      static void PSROIPoolingBackward(
<span onclick='openModal()' class='match'>131      const int num,
132      const Dtype* top_diff,
133      const int* mapping_channel,
134      const int num_rois,
135      const Dtype spatial_scale,
136      const int channels,
137      const int height, const int width,
</span>138      const int pooled_height, const int pooled_width,
139      const int output_dim,
140      Dtype* bottom_diff,
141      const Dtype* bottom_rois) {
142      int pixels = height * width;
143  #ifdef _OPENMP
144   	#pragma omp parallel for
145  #endif
146      for (int i = 0; i < num; ++i) {
147        int pw = i % pooled_width;
148        int ph = (i / pooled_width) % pooled_height;
149        int n = i / pooled_width / pooled_height / output_dim;
150        int roi_add = n * 5;
151        int roi_batch_ind = bottom_rois[roi_add];
152        Dtype roi_start_w =
153          static_cast<Dtype>(round(bottom_rois[roi_add + 1])) * spatial_scale;
154        Dtype roi_start_h =
155          static_cast<Dtype>(round(bottom_rois[roi_add + 2])) * spatial_scale;
156        Dtype roi_end_w =
157          static_cast<Dtype>(round(bottom_rois[roi_add + 3]) + 1.) * spatial_scale;
158        Dtype roi_end_h =
159          static_cast<Dtype>(round(bottom_rois[roi_add + 4]) + 1.) * spatial_scale;
160        Dtype roi_width = max(roi_end_w - roi_start_w, (Dtype)0.1);  
161        Dtype roi_height = max(roi_end_h - roi_start_h, (Dtype)0.1);
162        Dtype bin_size_h = roi_height / static_cast<Dtype>(pooled_height);
163        Dtype bin_size_w = roi_width / static_cast<Dtype>(pooled_width);
164        int hstart = floor(static_cast<Dtype>(ph)* bin_size_h + roi_start_h);
165        int wstart = floor(static_cast<Dtype>(pw)* bin_size_w + roi_start_w);
166        int hend = ceil(static_cast<Dtype>(ph + 1) * bin_size_h + roi_start_h);
167        int wend = ceil(static_cast<Dtype>(pw + 1) * bin_size_w + roi_start_w);
168        hstart = min(max(hstart, 0), height);
169        hend = min(max(hend, 0), height);
170        wstart = min(max(wstart, 0), width);
171        wend = min(max(wend, 0), width);
172        bool is_empty = (hend <= hstart) || (wend <= wstart);
173        int c = mapping_channel[i];
174        Dtype* offset_bottom_diff = bottom_diff + (roi_batch_ind * channels + c) * pixels;
175        Dtype bin_area = (hend - hstart) * (wend - wstart);
176        Dtype diff_val = is_empty ? 0. : top_diff[i] / bin_area;
177        for (int h = hstart; h < hend; ++h) {
178          for (int w = wstart; w < wend; ++w) {
179            offset_bottom_diff[h * width + w] += diff_val;
180          }
181        }
182      }
183    }
184    template <typename Dtype>
185    void PSROIPoolingLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
186      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
187      if (!propagate_down[0]) {
188        return;
189      }
190      const Dtype* bottom_rois = bottom[1]->cpu_data();
191      const Dtype* top_diff = top[0]->cpu_diff();
192      Dtype* bottom_diff = bottom[0]->mutable_cpu_diff();
193      const int bottom_count = bottom[0]->count();
194      const int* mapping_channel_ptr = mapping_channel_.cpu_data();
195      caffe_set(bottom[1]->count(), Dtype(0), bottom[1]->mutable_cpu_diff());
196      caffe_set(bottom_count, Dtype(0), bottom_diff);
197      const int count = top[0]->count();
198      PSROIPoolingBackward(count, top_diff, mapping_channel_ptr,
199        top[0]->num(), spatial_scale_, channels_, height_, width_,
200        pooled_height_, pooled_width_, output_dim_, bottom_diff,
201        bottom_rois);
202    }
203  #ifdef CPU_ONLY
204    STUB_GPU(PSROIPoolingLayer);
205  #endif
206    INSTANTIATE_CLASS(PSROIPoolingLayer);
207    REGISTER_LAYER_CLASS(PSROIPooling);
208  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wch.h</h3>
            <pre><code>1  class TWCh{
2  private:
3    uchar MsVal;
4    uchar LsVal;
5  public:
6    static const TWCh Mn;
7    static const TWCh Mx;
8    static const int Vals;
9    TWCh(): MsVal(0), LsVal(0){}
10    TWCh(const uchar& _LsVal): MsVal(0), LsVal(_LsVal){}
11    TWCh(const uchar& _MsVal, const uchar& _LsVal):
12      MsVal(_MsVal), LsVal(_LsVal){}
13    TWCh(const int& _MsVal, const int& _LsVal):
14      MsVal(uchar(_MsVal)), LsVal(uchar(_LsVal)){}
15    operator char() const {return LsVal;}
16    TWCh(TSIn& SIn){SIn.Load(MsVal); SIn.Load(LsVal);}
17    void Save(TSOut& SOut) const {SOut.Save(MsVal); SOut.Save(MsVal);}
18    TWCh& operator=(const TWCh& WCh){
19      MsVal=WCh.MsVal; LsVal=WCh.LsVal; return *this;}
20    bool operator==(const TWCh& WCh) const {
21      return (MsVal==WCh.MsVal)&&(LsVal==WCh.LsVal);}
22    bool operator<(const TWCh& WCh) const {
23      return (MsVal<WCh.MsVal)||((MsVal==WCh.MsVal)&&(LsVal<WCh.LsVal));}
24    int GetMemUsed() const {return sizeof(MsVal)+sizeof(LsVal);}
25    int GetPrimHashCd() const {return LsVal;}
26    int GetSecHashCd() const {return MsVal;}
27    char GetCh() const {
28      if (MsVal==TCh::NullCh){return LsVal;} else {return '#';}}
29    static TWCh LoadTxt(const PSIn& SIn){
30      uchar LsVal=SIn->GetCh(); uchar MsVal=SIn->GetCh();
31      return TWCh(MsVal, LsVal);}
32    void SaveTxt(const PSOut& SOut) const {
33      SOut->PutCh(MsVal); SOut->PutCh(LsVal);}
34    static const TWCh StartWCh;
35    static const TWCh TabWCh;
36    static const TWCh LfWCh;
37    static const TWCh CrWCh;
38    static const TWCh SpaceWCh;
39  };
40  typedef TVec<TWCh> TWChV;
41  class TWChA{
42  private:
43    TWChV WChV;
44    void AddCStr(const char* CStr);
45    void PutCStr(const char* CStr);
46  public:
47    TWChA(const int& MxWChs=0): WChV(MxWChs, 0){}
48    TWChA(const TWChA& WChA): WChV(WChA.WChV){}
49    TWChA(const TWChV& _WChV): WChV(_WChV){}
50    TWChA(const char* CStr): WChV(){PutCStr(CStr);}
51    TWChA(const TChA& ChA): WChV(){PutCStr(ChA.CStr());}
52    TWChA(const TStr& Str): WChV(){PutCStr(Str.CStr());}
53    ~TWChA(){}
54    TWChA(TSIn& SIn): WChV(SIn){}
55    void Save(TSOut& SOut){WChV.Save(SOut);}
56    TWChA& operator=(const TWChA& WChA){
57      if (this!=&WChA){WChV=WChA.WChV;} return *this;}
58    TWChA& operator=(const char* CStr){PutCStr(CStr); return *this;}
59    TWChA& operator=(const TChA& ChA){PutCStr(ChA.CStr()); return *this;}
60    TWChA& operator=(const TStr& Str){PutCStr(Str.CStr()); return *this;}
61    bool operator==(const TWChA& WChA) const {return WChV==WChA.WChV;}
62    bool operator==(const char* CStr) const {return strcmp(GetStr().CStr(), CStr)!=0;}
63    TWChA& operator+=(const char& Ch){WChV.Add(TWCh(Ch)); return *this;}
64    TWChA& operator+=(const TWCh& WCh){WChV.Add(WCh); return *this;}
65    TWChA& operator+=(const char* CStr){AddCStr(CStr); return *this;}
66    TWChA& operator+=(const TChA& ChA){AddCStr(ChA.CStr()); return *this;}
67    TWChA& operator+=(const TStr& Str){AddCStr(Str.CStr()); return *this;}
68    TWChA& operator+=(const TWChA& WChA){WChV.AddV(WChA.WChV); return *this;}
69    TWCh operator[](const int& ChN) const {return WChV[ChN];}
70    int GetMemUsed(){return WChV.GetMemUsed();}
71    void Clr(){WChV.Clr();}
72    int Len() const {return WChV.Len();}
73    bool Empty() const {return WChV.Empty();}
74    TStr GetStr() const;
75    void GetSubWChA(const int& BChN, const int& EChN, TWChA& WChA) const {
76      WChV.GetSubValV(BChN, EChN, WChA.WChV);}
<span onclick='openModal()' class='match'>77    void InsStr(const int& BChN, const TStr& Str);
78    void DelSubStr(const int& BChN, const int& EChN);
79    bool DelStr(const TStr& Str);
80    void SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const;
81    int SearchCh(const TWCh& WCh, const int& BChN=0) const {
</span>82      return WChV.SearchForw(WCh, BChN);}
83    int SearchStr(const TWChA& WChA, const int& BChN=0) const {
84      return WChV.SearchVForw(WChA.WChV, BChN);}
85    bool IsChIn(const char& Ch) const {return SearchCh(Ch)!=-1;}
86    bool IsStrIn(const TWChA& WChA) const {return SearchStr(WChA)!=-1;}
87    bool IsPrefix(const TWChA& WChA) const {
88      TWChV SubWChV; WChV.GetSubValV(0, WChA.Len()-1, SubWChV);
89      return SubWChV==WChA.WChV;}
90    bool IsSufix(const TWChA& WChA) const {
91      TWChV SubWChV; WChV.GetSubValV(Len()-WChA.Len(), Len()-1, SubWChV);
92      return SubWChV==WChA.WChV;}
93    int ChangeStr(const TStr& SrcStr, const TStr& DstStr, const int& BChN=0);
94    int ChangeStrAll(const TStr& SrcStr, const TStr& DstStr);
95    static void LoadTxt(const PSIn& SIn, TWChA& WChA);
96    void SaveTxt(const PSOut& SOut) const;
97    static TWChA EmptyWChA;
98  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-psroi_pooling_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wch.h</div>
                </div>
                <div class="column column_space"><pre><code>131      const int num,
132      const Dtype* top_diff,
133      const int* mapping_channel,
134      const int num_rois,
135      const Dtype spatial_scale,
136      const int channels,
137      const int height, const int width,
</pre></code></div>
                <div class="column column_space"><pre><code>77    void InsStr(const int& BChN, const TStr& Str);
78    void DelSubStr(const int& BChN, const int& EChN);
79    bool DelStr(const TStr& Str);
80    void SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const;
81    int SearchCh(const TWCh& WCh, const int& BChN=0) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    