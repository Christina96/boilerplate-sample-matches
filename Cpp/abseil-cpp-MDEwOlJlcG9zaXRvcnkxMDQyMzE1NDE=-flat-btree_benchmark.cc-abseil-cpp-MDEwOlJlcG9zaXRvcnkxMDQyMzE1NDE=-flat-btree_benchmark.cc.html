
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</h3>
            <pre><code>1  #include <stdint.h>
2  #include <algorithm>
3  #include <functional>
4  #include <map>
5  #include <numeric>
6  #include <random>
7  #include <set>
8  #include <string>
9  #include <type_traits>
10  #include <unordered_map>
11  #include <unordered_set>
12  #include <vector>
13  #include "benchmark/benchmark.h"
14  #include "absl/algorithm/container.h"
15  #include "absl/base/internal/raw_logging.h"
16  #include "absl/container/btree_map.h"
17  #include "absl/container/btree_set.h"
18  #include "absl/container/btree_test.h"
19  #include "absl/container/flat_hash_map.h"
20  #include "absl/container/flat_hash_set.h"
21  #include "absl/container/internal/hashtable_debug.h"
22  #include "absl/hash/hash.h"
23  #include "absl/log/log.h"
24  #include "absl/memory/memory.h"
25  #include "absl/random/random.h"
26  #include "absl/strings/cord.h"
27  #include "absl/strings/str_format.h"
28  #include "absl/time/time.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace container_internal {
32  namespace {
33  constexpr size_t kBenchmarkValues = 1 << 20;
34  constexpr size_t kAddRemBatchSize = 1 << 2;
35  template <typename V>
36  std::vector<V> GenerateValues(int n) {
37    constexpr int kSeed = 23;
38    return GenerateValuesWithSeed<V>(n, 4 * n, kSeed);
39  }
40  template <typename T>
41  void BM_InsertImpl(benchmark::State& state, bool sorted) {
42    using V = typename remove_pair_const<typename T::value_type>::type;
43    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
44    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
45    if (sorted) {
46      std::sort(values.begin(), values.end());
47    }
48    T container(values.begin(), values.end());
49    const int batch_size = (kBenchmarkValues + 9) / 10;
50    while (state.KeepRunningBatch(batch_size)) {
51      state.PauseTiming();
52      const auto i = static_cast<int>(state.iterations());
53      for (int j = i; j < i + batch_size; j++) {
54        int x = j % kBenchmarkValues;
55        container.erase(key_of_value(values[x]));
56      }
57      state.ResumeTiming();
58      for (int j = i; j < i + batch_size; j++) {
59        int x = j % kBenchmarkValues;
60        container.insert(values[x]);
61      }
62    }
63  }
64  template <typename T>
65  void BM_Insert(benchmark::State& state) {
66    BM_InsertImpl<T>(state, false);
67  }
68  template <typename T>
69  void BM_InsertSorted(benchmark::State& state) {
70    BM_InsertImpl<T>(state, true);
71  }
72  template <typename T>
73  void BM_InsertSmall(benchmark::State& state) {
74    using V = typename remove_pair_const<typename T::value_type>::type;
75    const int kSize = 8;
76    std::vector<V> values = GenerateValues<V>(kSize);
77    T container;
78    while (state.KeepRunningBatch(kSize)) {
79      for (int i = 0; i < kSize; ++i) {
80        benchmark::DoNotOptimize(container.insert(values[i]));
81      }
82      state.PauseTiming();
83      container.clear();
84      state.ResumeTiming();
85    }
86  }
87  template <typename T>
88  void BM_LookupImpl(benchmark::State& state, bool sorted) {
89    using V = typename remove_pair_const<typename T::value_type>::type;
90    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
91    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
92    if (sorted) {
93      std::sort(values.begin(), values.end());
94    }
95    T container(values.begin(), values.end());
96    while (state.KeepRunning()) {
97      int idx = state.iterations() % kBenchmarkValues;
98      benchmark::DoNotOptimize(container.find(key_of_value(values[idx])));
99    }
100  }
101  template <typename T>
102  void BM_Lookup(benchmark::State& state) {
103    BM_LookupImpl<T>(state, false);
104  }
105  template <typename T>
106  void BM_FullLookup(benchmark::State& state) {
107    BM_LookupImpl<T>(state, true);
108  }
109  template <typename T>
110  void BM_Erase(benchmark::State& state) {
111    using V = typename remove_pair_const<typename T::value_type>::type;
112    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
113    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
114    T container(values.begin(), values.end());
115    const int batch_size = (kBenchmarkValues + 9) / 10;
116    while (state.KeepRunningBatch(batch_size)) {
117      const int i = state.iterations();
118      for (int j = i; j < i + batch_size; j++) {
119        int x = j % kBenchmarkValues;
120        container.erase(key_of_value(values[x]));
121      }
122      state.PauseTiming();
123      for (int j = i; j < i + batch_size; j++) {
124        int x = j % kBenchmarkValues;
125        container.insert(values[x]);
126      }
127      state.ResumeTiming();
128    }
129  }
130  template <typename T>
131  void BM_EraseRange(benchmark::State& state) {
132    using V = typename remove_pair_const<typename T::value_type>::type;
133    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
134    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
135    T container(values.begin(), values.end());
136    const int batch_size = (kBenchmarkValues + 9) / 10;
137    while (state.KeepRunningBatch(batch_size)) {
138      const int i = state.iterations();
139      const int start_index = i % kBenchmarkValues;
140      state.PauseTiming();
141      {
142        std::vector<V> removed;
143        removed.reserve(batch_size);
144        auto itr = container.find(key_of_value(values[start_index]));
145        auto start = itr;
146        for (int j = 0; j < batch_size; j++) {
147          if (itr == container.end()) {
148            state.ResumeTiming();
149            container.erase(start, itr);
150            state.PauseTiming();
151            itr = container.begin();
152            start = itr;
153          }
154          removed.push_back(*itr++);
155        }
156        state.ResumeTiming();
157        container.erase(start, itr);
158        state.PauseTiming();
159        container.insert(removed.begin(), removed.end());
160      }
161      state.ResumeTiming();
162    }
163  }
164  struct EraseIfPred {
165    uint64_t i = 0;
166    template <typename T>
167    bool operator()(const T&) {
168      return ++i % 2;
169    }
170  };
171  template <typename T>
172  void BM_EraseIf(benchmark::State& state) {
173    using V = typename remove_pair_const<typename T::value_type>::type;
174    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
175    const int batch_size = (kBenchmarkValues + 1) / 2;
176    EraseIfPred pred;
177    while (state.KeepRunningBatch(batch_size)) {
178      state.PauseTiming();
179      {
180        T container(values.begin(), values.end());
181        state.ResumeTiming();
182        erase_if(container, pred);
183        benchmark::DoNotOptimize(container);
184        state.PauseTiming();
185      }
186      state.ResumeTiming();
187    }
188  }
189  template <typename T>
190  void BM_QueueAddRem(benchmark::State& state) {
191    using V = typename remove_pair_const<typename T::value_type>::type;
192    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
193    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, "for performance");
194    T container;
195    const size_t half = kBenchmarkValues / 2;
196    std::vector<int> remove_keys(half);
197    std::vector<int> add_keys(half);
198    while (state.KeepRunningBatch(half * kAddRemBatchSize)) {
199      state.PauseTiming();
200      container.clear();
201      for (size_t i = 0; i < half; ++i) {
202        remove_keys[i] = i;
203        add_keys[i] = i;
204      }
205      constexpr int kSeed = 5;
206      std::mt19937_64 rand(kSeed);
207      std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
208      std::shuffle(add_keys.begin(), add_keys.end(), rand);
209      Generator<V> g(kBenchmarkValues * kAddRemBatchSize);
210      for (size_t i = 0; i < half; ++i) {
211        container.insert(g(add_keys[i]));
212        container.insert(g(half + remove_keys[i]));
213      }
214      size_t offset = 0;
215      for (size_t i = 0; i < kAddRemBatchSize; ++i) {
216        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
217        std::shuffle(add_keys.begin(), add_keys.end(), rand);
218        offset += half;
219        state.ResumeTiming();
220        for (size_t idx = 0; idx < half; ++idx) {
221          container.erase(key_of_value(g(offset - half + remove_keys[idx])));
222          container.insert(g(offset + half + add_keys[idx]));
223        }
224        state.PauseTiming();
225      }
226      state.ResumeTiming();
227    }
228  }
229  template <typename T>
230  void BM_MixedAddRem(benchmark::State& state) {
231    using V = typename remove_pair_const<typename T::value_type>::type;
232    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
233    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, "for performance");
234    T container;
235    std::vector<int> remove_keys(kBenchmarkValues);
236    std::vector<int> add_keys(kBenchmarkValues);
237    while (state.KeepRunningBatch(kBenchmarkValues * kAddRemBatchSize)) {
238      state.PauseTiming();
239      container.clear();
240      constexpr int kSeed = 7;
241      std::mt19937_64 rand(kSeed);
242      std::vector<V> values = GenerateValues<V>(kBenchmarkValues * 2);
243      container.insert(values.begin(), values.begin() + kBenchmarkValues);
244      for (size_t i = 0; i < kBenchmarkValues; ++i) {
245        remove_keys[i] = i + kBenchmarkValues;
246        add_keys[i] = i;
247      }
248      for (size_t i = 0; i < kAddRemBatchSize; ++i) {
249        remove_keys.swap(add_keys);
250        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
251        std::shuffle(add_keys.begin(), add_keys.end(), rand);
252        state.ResumeTiming();
253        for (size_t idx = 0; idx < kBenchmarkValues; ++idx) {
254          container.erase(key_of_value(values[remove_keys[idx]]));
255          container.insert(values[add_keys[idx]]);
256        }
257        state.PauseTiming();
258      }
259      state.ResumeTiming();
260    }
261  }
262  template <typename T>
263  void BM_Fifo(benchmark::State& state) {
264    using V = typename remove_pair_const<typename T::value_type>::type;
265    T container;
266    Generator<V> g(kBenchmarkValues + state.max_iterations);
267    for (int i = 0; i < kBenchmarkValues; i++) {
268      container.insert(g(i));
269    }
270    while (state.KeepRunning()) {
271      container.erase(container.begin());
272      container.insert(container.end(), g(state.iterations() + kBenchmarkValues));
273    }
274  }
275  template <typename T>
276  void BM_FwdIter(benchmark::State& state) {
277    using V = typename remove_pair_const<typename T::value_type>::type;
278    using R = typename T::value_type const*;
279    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
280    T container(values.begin(), values.end());
281    auto iter = container.end();
282    R r = nullptr;
283    while (state.KeepRunning()) {
284      if (iter == container.end()) iter = container.begin();
285      r = &(*iter);
286      ++iter;
287    }
288    benchmark::DoNotOptimize(r);
289  }
290  template <typename T>
291  void BM_RangeConstructionImpl(benchmark::State& state, bool sorted) {
292    using V = typename remove_pair_const<typename T::value_type>::type;
293    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
294    if (sorted) {
295      std::sort(values.begin(), values.end());
296    }
297    {
298      T container(values.begin(), values.end());
299    }
300    while (state.KeepRunning()) {
301      T container(values.begin(), values.end());
302      benchmark::DoNotOptimize(container);
303    }
304  }
305  template <typename T>
306  void BM_InsertRangeRandom(benchmark::State& state) {
307    BM_RangeConstructionImpl<T>(state, false);
308  }
309  template <typename T>
310  void BM_InsertRangeSorted(benchmark::State& state) {
311    BM_RangeConstructionImpl<T>(state, true);
312  }
313  #define STL_ORDERED_TYPES(value)                     \
314    using stl_set_##value = std::set<value>;           \
315    using stl_map_##value = std::map<value, intptr_t>; \
316    using stl_multiset_##value = std::multiset<value>; \
317    using stl_multimap_##value = std::multimap<value, intptr_t>
318  using StdString = std::string;
319  STL_ORDERED_TYPES(int32_t);
320  STL_ORDERED_TYPES(int64_t);
321  STL_ORDERED_TYPES(StdString);
322  STL_ORDERED_TYPES(Cord);
323  STL_ORDERED_TYPES(Time);
324  #define STL_UNORDERED_TYPES(value)                                       \
325    using stl_unordered_set_##value = std::unordered_set<value>;           \
326    using stl_unordered_map_##value = std::unordered_map<value, intptr_t>; \
327    using flat_hash_set_##value = flat_hash_set<value>;                    \
328    using flat_hash_map_##value = flat_hash_map<value, intptr_t>;          \
329    using stl_unordered_multiset_##value = std::unordered_multiset<value>; \
330    using stl_unordered_multimap_##value =                                 \
331        std::unordered_multimap<value, intptr_t>
332  #define STL_UNORDERED_TYPES_CUSTOM_HASH(value, hash)                           \
333    using stl_unordered_set_##value = std::unordered_set<value, hash>;           \
334    using stl_unordered_map_##value = std::unordered_map<value, intptr_t, hash>; \
335    using flat_hash_set_##value = flat_hash_set<value, hash>;                    \
336    using flat_hash_map_##value = flat_hash_map<value, intptr_t, hash>;          \
337    using stl_unordered_multiset_##value = std::unordered_multiset<value, hash>; \
338    using stl_unordered_multimap_##value =                                       \
339        std::unordered_multimap<value, intptr_t, hash>
340  STL_UNORDERED_TYPES_CUSTOM_HASH(Cord, absl::Hash<absl::Cord>);
341  STL_UNORDERED_TYPES(int32_t);
342  STL_UNORDERED_TYPES(int64_t);
343  STL_UNORDERED_TYPES(StdString);
344  STL_UNORDERED_TYPES_CUSTOM_HASH(Time, absl::Hash<absl::Time>);
345  #define BTREE_TYPES(value)                                            \
346    using btree_256_set_##value =                                       \
347        btree_set<value, std::less<value>, std::allocator<value>>;      \
348    using btree_256_map_##value =                                       \
349        btree_map<value, intptr_t, std::less<value>,                    \
350                  std::allocator<std::pair<const value, intptr_t>>>;    \
351    using btree_256_multiset_##value =                                  \
352        btree_multiset<value, std::less<value>, std::allocator<value>>; \
353    using btree_256_multimap_##value =                                  \
354        btree_multimap<value, intptr_t, std::less<value>,               \
355                       std::allocator<std::pair<const value, intptr_t>>>
356  BTREE_TYPES(int32_t);
357  BTREE_TYPES(int64_t);
358  BTREE_TYPES(StdString);
359  BTREE_TYPES(Cord);
360  BTREE_TYPES(Time);
361  #define MY_BENCHMARK4(type, func)                                              \
362    void BM_##type##_##func(benchmark::State& state) { BM_##func<type>(state); } \
363    BENCHMARK(BM_##type##_##func)
364  #define MY_BENCHMARK3_STL(type)           \
365    MY_BENCHMARK4(type, Insert);            \
366    MY_BENCHMARK4(type, InsertSorted);      \
367    MY_BENCHMARK4(type, InsertSmall);       \
368    MY_BENCHMARK4(type, Lookup);            \
369    MY_BENCHMARK4(type, FullLookup);        \
370    MY_BENCHMARK4(type, Erase);             \
371    MY_BENCHMARK4(type, EraseRange);        \
372    MY_BENCHMARK4(type, QueueAddRem);       \
373    MY_BENCHMARK4(type, MixedAddRem);       \
374    MY_BENCHMARK4(type, Fifo);              \
375    MY_BENCHMARK4(type, FwdIter);           \
376    MY_BENCHMARK4(type, InsertRangeRandom); \
377    MY_BENCHMARK4(type, InsertRangeSorted)
378  #define MY_BENCHMARK3(type)     \
379    MY_BENCHMARK4(type, EraseIf); \
380    MY_BENCHMARK3_STL(type)
381  #define MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type) \
382    MY_BENCHMARK3_STL(stl_##type);                \
383    MY_BENCHMARK3_STL(stl_unordered_##type);      \
384    MY_BENCHMARK3(btree_256_##type)
385  #define MY_BENCHMARK2(type)                \
386    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type); \
387    MY_BENCHMARK3(flat_hash_##type)
388  #ifdef MULTI_TESTING
389  #define MY_BENCHMARK(type)                            \
390    MY_BENCHMARK2(set_##type);                          \
391    MY_BENCHMARK2(map_##type);                          \
392    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multiset_##type); \
393    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multimap_##type)
394  #else
395  #define MY_BENCHMARK(type)   \
396    MY_BENCHMARK2(set_##type); \
397    MY_BENCHMARK2(map_##type)
398  #endif
399  MY_BENCHMARK(int32_t);
400  MY_BENCHMARK(int64_t);
401  MY_BENCHMARK(StdString);
402  MY_BENCHMARK(Cord);
403  MY_BENCHMARK(Time);
404  template <int Size, int Copies>
405  struct BigType {
406    BigType() : BigType(0) {}
407    explicit BigType(int x) { std::iota(values.begin(), values.end(), x); }
408    void Copy(const BigType& other) {
409      for (int i = 0; i < Size && i < Copies; ++i) values[i] = other.values[i];
410      for (int i = Size, idx = 0; i < Copies; ++i) {
411        int64_t tmp = other.values[idx];
412        benchmark::DoNotOptimize(tmp);
413        idx = idx + 1 == Size ? 0 : idx + 1;
414      }
415    }
416    BigType(const BigType& other) { Copy(other); }
417    BigType& operator=(const BigType& other) {
418      Copy(other);
419      return *this;
420    }
421    bool operator<(const BigType& other) const {
422      return std::lexicographical_compare(
423          values.begin(), values.begin() + std::min(Size, Copies),
424          other.values.begin(), other.values.begin() + std::min(Size, Copies));
425    }
426    bool operator==(const BigType& other) const {
427      return std::equal(values.begin(), values.begin() + std::min(Size, Copies),
428                        other.values.begin());
429    }
430    template <typename State>
431    friend State AbslHashValue(State h, const BigType& b) {
432      for (int i = 0; i < Size && i < Copies; ++i)
433        h = State::combine(std::move(h), b.values[i]);
434      return h;
435    }
436    std::array<int64_t, Size> values;
437  };
438  #define BIG_TYPE_BENCHMARKS(SIZE, COPIES)                                     \
439    using stl_set_size##SIZE##copies##COPIES = std::set<BigType<SIZE, COPIES>>; \
440    using stl_map_size##SIZE##copies##COPIES =                                  \
441        std::map<BigType<SIZE, COPIES>, intptr_t>;                              \
442    using stl_multiset_size##SIZE##copies##COPIES =                             \
443        std::multiset<BigType<SIZE, COPIES>>;                                   \
444    using stl_multimap_size##SIZE##copies##COPIES =                             \
445        std::multimap<BigType<SIZE, COPIES>, intptr_t>;                         \
446    using stl_unordered_set_size##SIZE##copies##COPIES =                        \
447        std::unordered_set<BigType<SIZE, COPIES>,                               \
448                           absl::Hash<BigType<SIZE, COPIES>>>;                  \
449    using stl_unordered_map_size##SIZE##copies##COPIES =                        \
450        std::unordered_map<BigType<SIZE, COPIES>, intptr_t,                     \
451                           absl::Hash<BigType<SIZE, COPIES>>>;                  \
452    using flat_hash_set_size##SIZE##copies##COPIES =                            \
453        flat_hash_set<BigType<SIZE, COPIES>>;                                   \
454    using flat_hash_map_size##SIZE##copies##COPIES =                            \
455        flat_hash_map<BigType<SIZE, COPIES>, intptr_t>;                         \
456    using stl_unordered_multiset_size##SIZE##copies##COPIES =                   \
457        std::unordered_multiset<BigType<SIZE, COPIES>,                          \
458                                absl::Hash<BigType<SIZE, COPIES>>>;             \
459    using stl_unordered_multimap_size##SIZE##copies##COPIES =                   \
460        std::unordered_multimap<BigType<SIZE, COPIES>, intptr_t,                \
461                                absl::Hash<BigType<SIZE, COPIES>>>;             \
462    using btree_256_set_size##SIZE##copies##COPIES =                            \
463        btree_set<BigType<SIZE, COPIES>>;                                       \
464    using btree_256_map_size##SIZE##copies##COPIES =                            \
465        btree_map<BigType<SIZE, COPIES>, intptr_t>;                             \
466    using btree_256_multiset_size##SIZE##copies##COPIES =                       \
467        btree_multiset<BigType<SIZE, COPIES>>;                                  \
468    using btree_256_multimap_size##SIZE##copies##COPIES =                       \
469        btree_multimap<BigType<SIZE, COPIES>, intptr_t>;                        \
470    MY_BENCHMARK(size##SIZE##copies##COPIES)
471  #ifndef NODESIZE_TESTING
472  #ifdef BIG_TYPE_TESTING
473  BIG_TYPE_BENCHMARKS(1, 4);
474  BIG_TYPE_BENCHMARKS(4, 1);
475  BIG_TYPE_BENCHMARKS(4, 4);
476  BIG_TYPE_BENCHMARKS(1, 8);
477  BIG_TYPE_BENCHMARKS(8, 1);
478  BIG_TYPE_BENCHMARKS(8, 8);
479  BIG_TYPE_BENCHMARKS(1, 16);
480  BIG_TYPE_BENCHMARKS(16, 1);
481  BIG_TYPE_BENCHMARKS(16, 16);
482  BIG_TYPE_BENCHMARKS(1, 32);
483  BIG_TYPE_BENCHMARKS(32, 1);
484  BIG_TYPE_BENCHMARKS(32, 32);
485  #else
486  BIG_TYPE_BENCHMARKS(32, 32);
487  #endif
488  #endif
489  template <int Size>
490  struct BigTypePtr {
491    BigTypePtr() : BigTypePtr(0) {}
492    explicit BigTypePtr(int x) {
493      ptr = absl::make_unique<BigType<Size, Size>>(x);
494    }
495    BigTypePtr(const BigTypePtr& other) {
<span onclick='openModal()' class='match'>496      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&& other) noexcept = default;
</span>499    BigTypePtr& operator=(const BigTypePtr& other) {
500      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
501    }
502    BigTypePtr& operator=(BigTypePtr&& other) noexcept = default;
503    bool operator<(const BigTypePtr& other) const { return *ptr < *other.ptr; }
504    bool operator==(const BigTypePtr& other) const { return *ptr == *other.ptr; }
505    std::unique_ptr<BigType<Size, Size>> ptr;
506  };
507  template <int Size>
508  double ContainerInfo(const btree_set<BigTypePtr<Size>>& b) {
509    const double bytes_used =
510        b.bytes_used() + b.size() * sizeof(BigType<Size, Size>);
511    const double bytes_per_value = bytes_used / b.size();
512    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
513    return bytes_per_value;
514  }
515  template <int Size>
516  double ContainerInfo(const btree_map<int, BigTypePtr<Size>>& b) {
517    const double bytes_used =
518        b.bytes_used() + b.size() * sizeof(BigType<Size, Size>);
519    const double bytes_per_value = bytes_used / b.size();
520    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
521    return bytes_per_value;
522  }
523  #define BIG_TYPE_PTR_BENCHMARKS(SIZE)                                          \
524    using stl_set_size##SIZE##copies##SIZE##ptr = std::set<BigType<SIZE, SIZE>>; \
525    using stl_map_size##SIZE##copies##SIZE##ptr =                                \
526        std::map<int, BigType<SIZE, SIZE>>;                                      \
527    using stl_unordered_set_size##SIZE##copies##SIZE##ptr =                      \
528        std::unordered_set<BigType<SIZE, SIZE>,                                  \
529                           absl::Hash<BigType<SIZE, SIZE>>>;                     \
530    using stl_unordered_map_size##SIZE##copies##SIZE##ptr =                      \
531        std::unordered_map<int, BigType<SIZE, SIZE>>;                            \
532    using flat_hash_set_size##SIZE##copies##SIZE##ptr =                          \
533        flat_hash_set<BigType<SIZE, SIZE>>;                                      \
534    using flat_hash_map_size##SIZE##copies##SIZE##ptr =                          \
535        flat_hash_map<int, BigTypePtr<SIZE>>;                                    \
536    using btree_256_set_size##SIZE##copies##SIZE##ptr =                          \
537        btree_set<BigTypePtr<SIZE>>;                                             \
538    using btree_256_map_size##SIZE##copies##SIZE##ptr =                          \
539        btree_map<int, BigTypePtr<SIZE>>;                                        \
540    MY_BENCHMARK3_STL(stl_set_size##SIZE##copies##SIZE##ptr);                    \
541    MY_BENCHMARK3_STL(stl_unordered_set_size##SIZE##copies##SIZE##ptr);          \
542    MY_BENCHMARK3(flat_hash_set_size##SIZE##copies##SIZE##ptr);                  \
543    MY_BENCHMARK3(btree_256_set_size##SIZE##copies##SIZE##ptr);                  \
544    MY_BENCHMARK3_STL(stl_map_size##SIZE##copies##SIZE##ptr);                    \
545    MY_BENCHMARK3_STL(stl_unordered_map_size##SIZE##copies##SIZE##ptr);          \
546    MY_BENCHMARK3(flat_hash_map_size##SIZE##copies##SIZE##ptr);                  \
547    MY_BENCHMARK3(btree_256_map_size##SIZE##copies##SIZE##ptr)
548  BIG_TYPE_PTR_BENCHMARKS(32);
549  void BM_BtreeSet_IteratorSubtraction(benchmark::State& state) {
550    absl::InsecureBitGen bitgen;
551    std::vector<int> vec;
552    vec.reserve(state.range(0));
553    for (int i = 0; i < state.range(0); ++i) vec.push_back(i);
554    absl::c_shuffle(vec, bitgen);
555    absl::btree_set<int> set;
556    for (int i : vec) set.insert(i);
557    size_t distance = absl::Uniform(bitgen, 0u, set.size());
558    while (state.KeepRunningBatch(distance)) {
559      size_t end = absl::Uniform(bitgen, distance, set.size());
560      size_t begin = end - distance;
561      benchmark::DoNotOptimize(set.find(static_cast<int>(end)) -
562                               set.find(static_cast<int>(begin)));
563      distance = absl::Uniform(bitgen, 0u, set.size());
564    }
565  }
566  BENCHMARK(BM_BtreeSet_IteratorSubtraction)->Range(1 << 10, 1 << 20);
567  }  
568  }  
569  ABSL_NAMESPACE_END
570  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</h3>
            <pre><code>1  #include <stdint.h>
2  #include <algorithm>
3  #include <functional>
4  #include <map>
5  #include <numeric>
6  #include <random>
7  #include <set>
8  #include <string>
9  #include <type_traits>
10  #include <unordered_map>
11  #include <unordered_set>
12  #include <vector>
13  #include "benchmark/benchmark.h"
14  #include "absl/algorithm/container.h"
15  #include "absl/base/internal/raw_logging.h"
16  #include "absl/container/btree_map.h"
17  #include "absl/container/btree_set.h"
18  #include "absl/container/btree_test.h"
19  #include "absl/container/flat_hash_map.h"
20  #include "absl/container/flat_hash_set.h"
21  #include "absl/container/internal/hashtable_debug.h"
22  #include "absl/hash/hash.h"
23  #include "absl/log/log.h"
24  #include "absl/memory/memory.h"
25  #include "absl/random/random.h"
26  #include "absl/strings/cord.h"
27  #include "absl/strings/str_format.h"
28  #include "absl/time/time.h"
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace container_internal {
32  namespace {
33  constexpr size_t kBenchmarkValues = 1 << 20;
34  constexpr size_t kAddRemBatchSize = 1 << 2;
35  template <typename V>
36  std::vector<V> GenerateValues(int n) {
37    constexpr int kSeed = 23;
38    return GenerateValuesWithSeed<V>(n, 4 * n, kSeed);
39  }
40  template <typename T>
41  void BM_InsertImpl(benchmark::State& state, bool sorted) {
42    using V = typename remove_pair_const<typename T::value_type>::type;
43    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
44    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
45    if (sorted) {
46      std::sort(values.begin(), values.end());
47    }
48    T container(values.begin(), values.end());
49    const int batch_size = (kBenchmarkValues + 9) / 10;
50    while (state.KeepRunningBatch(batch_size)) {
51      state.PauseTiming();
52      const auto i = static_cast<int>(state.iterations());
53      for (int j = i; j < i + batch_size; j++) {
54        int x = j % kBenchmarkValues;
55        container.erase(key_of_value(values[x]));
56      }
57      state.ResumeTiming();
58      for (int j = i; j < i + batch_size; j++) {
59        int x = j % kBenchmarkValues;
60        container.insert(values[x]);
61      }
62    }
63  }
64  template <typename T>
65  void BM_Insert(benchmark::State& state) {
66    BM_InsertImpl<T>(state, false);
67  }
68  template <typename T>
69  void BM_InsertSorted(benchmark::State& state) {
70    BM_InsertImpl<T>(state, true);
71  }
72  template <typename T>
73  void BM_InsertSmall(benchmark::State& state) {
74    using V = typename remove_pair_const<typename T::value_type>::type;
75    const int kSize = 8;
76    std::vector<V> values = GenerateValues<V>(kSize);
77    T container;
78    while (state.KeepRunningBatch(kSize)) {
79      for (int i = 0; i < kSize; ++i) {
80        benchmark::DoNotOptimize(container.insert(values[i]));
81      }
82      state.PauseTiming();
83      container.clear();
84      state.ResumeTiming();
85    }
86  }
87  template <typename T>
88  void BM_LookupImpl(benchmark::State& state, bool sorted) {
89    using V = typename remove_pair_const<typename T::value_type>::type;
90    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
91    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
92    if (sorted) {
93      std::sort(values.begin(), values.end());
94    }
95    T container(values.begin(), values.end());
96    while (state.KeepRunning()) {
97      int idx = state.iterations() % kBenchmarkValues;
98      benchmark::DoNotOptimize(container.find(key_of_value(values[idx])));
99    }
100  }
101  template <typename T>
102  void BM_Lookup(benchmark::State& state) {
103    BM_LookupImpl<T>(state, false);
104  }
105  template <typename T>
106  void BM_FullLookup(benchmark::State& state) {
107    BM_LookupImpl<T>(state, true);
108  }
109  template <typename T>
110  void BM_Erase(benchmark::State& state) {
111    using V = typename remove_pair_const<typename T::value_type>::type;
112    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
113    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
114    T container(values.begin(), values.end());
115    const int batch_size = (kBenchmarkValues + 9) / 10;
116    while (state.KeepRunningBatch(batch_size)) {
117      const int i = state.iterations();
118      for (int j = i; j < i + batch_size; j++) {
119        int x = j % kBenchmarkValues;
120        container.erase(key_of_value(values[x]));
121      }
122      state.PauseTiming();
123      for (int j = i; j < i + batch_size; j++) {
124        int x = j % kBenchmarkValues;
125        container.insert(values[x]);
126      }
127      state.ResumeTiming();
128    }
129  }
130  template <typename T>
131  void BM_EraseRange(benchmark::State& state) {
132    using V = typename remove_pair_const<typename T::value_type>::type;
133    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
134    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
135    T container(values.begin(), values.end());
136    const int batch_size = (kBenchmarkValues + 9) / 10;
137    while (state.KeepRunningBatch(batch_size)) {
138      const int i = state.iterations();
139      const int start_index = i % kBenchmarkValues;
140      state.PauseTiming();
141      {
142        std::vector<V> removed;
143        removed.reserve(batch_size);
144        auto itr = container.find(key_of_value(values[start_index]));
145        auto start = itr;
146        for (int j = 0; j < batch_size; j++) {
147          if (itr == container.end()) {
148            state.ResumeTiming();
149            container.erase(start, itr);
150            state.PauseTiming();
151            itr = container.begin();
152            start = itr;
153          }
154          removed.push_back(*itr++);
155        }
156        state.ResumeTiming();
157        container.erase(start, itr);
158        state.PauseTiming();
159        container.insert(removed.begin(), removed.end());
160      }
161      state.ResumeTiming();
162    }
163  }
164  struct EraseIfPred {
165    uint64_t i = 0;
166    template <typename T>
167    bool operator()(const T&) {
168      return ++i % 2;
169    }
170  };
171  template <typename T>
172  void BM_EraseIf(benchmark::State& state) {
173    using V = typename remove_pair_const<typename T::value_type>::type;
174    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
175    const int batch_size = (kBenchmarkValues + 1) / 2;
176    EraseIfPred pred;
177    while (state.KeepRunningBatch(batch_size)) {
178      state.PauseTiming();
179      {
180        T container(values.begin(), values.end());
181        state.ResumeTiming();
182        erase_if(container, pred);
183        benchmark::DoNotOptimize(container);
184        state.PauseTiming();
185      }
186      state.ResumeTiming();
187    }
188  }
189  template <typename T>
190  void BM_QueueAddRem(benchmark::State& state) {
191    using V = typename remove_pair_const<typename T::value_type>::type;
192    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
193    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, "for performance");
194    T container;
195    const size_t half = kBenchmarkValues / 2;
196    std::vector<int> remove_keys(half);
197    std::vector<int> add_keys(half);
198    while (state.KeepRunningBatch(half * kAddRemBatchSize)) {
199      state.PauseTiming();
200      container.clear();
201      for (size_t i = 0; i < half; ++i) {
202        remove_keys[i] = i;
203        add_keys[i] = i;
204      }
205      constexpr int kSeed = 5;
206      std::mt19937_64 rand(kSeed);
207      std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
208      std::shuffle(add_keys.begin(), add_keys.end(), rand);
209      Generator<V> g(kBenchmarkValues * kAddRemBatchSize);
210      for (size_t i = 0; i < half; ++i) {
211        container.insert(g(add_keys[i]));
212        container.insert(g(half + remove_keys[i]));
213      }
214      size_t offset = 0;
215      for (size_t i = 0; i < kAddRemBatchSize; ++i) {
216        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
217        std::shuffle(add_keys.begin(), add_keys.end(), rand);
218        offset += half;
219        state.ResumeTiming();
220        for (size_t idx = 0; idx < half; ++idx) {
221          container.erase(key_of_value(g(offset - half + remove_keys[idx])));
222          container.insert(g(offset + half + add_keys[idx]));
223        }
224        state.PauseTiming();
225      }
226      state.ResumeTiming();
227    }
228  }
229  template <typename T>
230  void BM_MixedAddRem(benchmark::State& state) {
231    using V = typename remove_pair_const<typename T::value_type>::type;
232    typename KeyOfValue<typename T::key_type, V>::type key_of_value;
233    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, "for performance");
234    T container;
235    std::vector<int> remove_keys(kBenchmarkValues);
236    std::vector<int> add_keys(kBenchmarkValues);
237    while (state.KeepRunningBatch(kBenchmarkValues * kAddRemBatchSize)) {
238      state.PauseTiming();
239      container.clear();
240      constexpr int kSeed = 7;
241      std::mt19937_64 rand(kSeed);
242      std::vector<V> values = GenerateValues<V>(kBenchmarkValues * 2);
243      container.insert(values.begin(), values.begin() + kBenchmarkValues);
244      for (size_t i = 0; i < kBenchmarkValues; ++i) {
245        remove_keys[i] = i + kBenchmarkValues;
246        add_keys[i] = i;
247      }
248      for (size_t i = 0; i < kAddRemBatchSize; ++i) {
249        remove_keys.swap(add_keys);
250        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
251        std::shuffle(add_keys.begin(), add_keys.end(), rand);
252        state.ResumeTiming();
253        for (size_t idx = 0; idx < kBenchmarkValues; ++idx) {
254          container.erase(key_of_value(values[remove_keys[idx]]));
255          container.insert(values[add_keys[idx]]);
256        }
257        state.PauseTiming();
258      }
259      state.ResumeTiming();
260    }
261  }
262  template <typename T>
263  void BM_Fifo(benchmark::State& state) {
264    using V = typename remove_pair_const<typename T::value_type>::type;
265    T container;
266    Generator<V> g(kBenchmarkValues + state.max_iterations);
267    for (int i = 0; i < kBenchmarkValues; i++) {
268      container.insert(g(i));
269    }
270    while (state.KeepRunning()) {
271      container.erase(container.begin());
272      container.insert(container.end(), g(state.iterations() + kBenchmarkValues));
273    }
274  }
275  template <typename T>
276  void BM_FwdIter(benchmark::State& state) {
277    using V = typename remove_pair_const<typename T::value_type>::type;
278    using R = typename T::value_type const*;
279    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
280    T container(values.begin(), values.end());
281    auto iter = container.end();
282    R r = nullptr;
283    while (state.KeepRunning()) {
284      if (iter == container.end()) iter = container.begin();
285      r = &(*iter);
286      ++iter;
287    }
288    benchmark::DoNotOptimize(r);
289  }
290  template <typename T>
291  void BM_RangeConstructionImpl(benchmark::State& state, bool sorted) {
292    using V = typename remove_pair_const<typename T::value_type>::type;
293    std::vector<V> values = GenerateValues<V>(kBenchmarkValues);
294    if (sorted) {
295      std::sort(values.begin(), values.end());
296    }
297    {
298      T container(values.begin(), values.end());
299    }
300    while (state.KeepRunning()) {
301      T container(values.begin(), values.end());
302      benchmark::DoNotOptimize(container);
303    }
304  }
305  template <typename T>
306  void BM_InsertRangeRandom(benchmark::State& state) {
307    BM_RangeConstructionImpl<T>(state, false);
308  }
309  template <typename T>
310  void BM_InsertRangeSorted(benchmark::State& state) {
311    BM_RangeConstructionImpl<T>(state, true);
312  }
313  #define STL_ORDERED_TYPES(value)                     \
314    using stl_set_##value = std::set<value>;           \
315    using stl_map_##value = std::map<value, intptr_t>; \
316    using stl_multiset_##value = std::multiset<value>; \
317    using stl_multimap_##value = std::multimap<value, intptr_t>
318  using StdString = std::string;
319  STL_ORDERED_TYPES(int32_t);
320  STL_ORDERED_TYPES(int64_t);
321  STL_ORDERED_TYPES(StdString);
322  STL_ORDERED_TYPES(Cord);
323  STL_ORDERED_TYPES(Time);
324  #define STL_UNORDERED_TYPES(value)                                       \
325    using stl_unordered_set_##value = std::unordered_set<value>;           \
326    using stl_unordered_map_##value = std::unordered_map<value, intptr_t>; \
327    using flat_hash_set_##value = flat_hash_set<value>;                    \
328    using flat_hash_map_##value = flat_hash_map<value, intptr_t>;          \
329    using stl_unordered_multiset_##value = std::unordered_multiset<value>; \
330    using stl_unordered_multimap_##value =                                 \
331        std::unordered_multimap<value, intptr_t>
332  #define STL_UNORDERED_TYPES_CUSTOM_HASH(value, hash)                           \
333    using stl_unordered_set_##value = std::unordered_set<value, hash>;           \
334    using stl_unordered_map_##value = std::unordered_map<value, intptr_t, hash>; \
335    using flat_hash_set_##value = flat_hash_set<value, hash>;                    \
336    using flat_hash_map_##value = flat_hash_map<value, intptr_t, hash>;          \
337    using stl_unordered_multiset_##value = std::unordered_multiset<value, hash>; \
338    using stl_unordered_multimap_##value =                                       \
339        std::unordered_multimap<value, intptr_t, hash>
340  STL_UNORDERED_TYPES_CUSTOM_HASH(Cord, absl::Hash<absl::Cord>);
341  STL_UNORDERED_TYPES(int32_t);
342  STL_UNORDERED_TYPES(int64_t);
343  STL_UNORDERED_TYPES(StdString);
344  STL_UNORDERED_TYPES_CUSTOM_HASH(Time, absl::Hash<absl::Time>);
345  #define BTREE_TYPES(value)                                            \
346    using btree_256_set_##value =                                       \
347        btree_set<value, std::less<value>, std::allocator<value>>;      \
348    using btree_256_map_##value =                                       \
349        btree_map<value, intptr_t, std::less<value>,                    \
350                  std::allocator<std::pair<const value, intptr_t>>>;    \
351    using btree_256_multiset_##value =                                  \
352        btree_multiset<value, std::less<value>, std::allocator<value>>; \
353    using btree_256_multimap_##value =                                  \
354        btree_multimap<value, intptr_t, std::less<value>,               \
355                       std::allocator<std::pair<const value, intptr_t>>>
356  BTREE_TYPES(int32_t);
357  BTREE_TYPES(int64_t);
358  BTREE_TYPES(StdString);
359  BTREE_TYPES(Cord);
360  BTREE_TYPES(Time);
361  #define MY_BENCHMARK4(type, func)                                              \
362    void BM_##type##_##func(benchmark::State& state) { BM_##func<type>(state); } \
363    BENCHMARK(BM_##type##_##func)
364  #define MY_BENCHMARK3_STL(type)           \
365    MY_BENCHMARK4(type, Insert);            \
366    MY_BENCHMARK4(type, InsertSorted);      \
367    MY_BENCHMARK4(type, InsertSmall);       \
368    MY_BENCHMARK4(type, Lookup);            \
369    MY_BENCHMARK4(type, FullLookup);        \
370    MY_BENCHMARK4(type, Erase);             \
371    MY_BENCHMARK4(type, EraseRange);        \
372    MY_BENCHMARK4(type, QueueAddRem);       \
373    MY_BENCHMARK4(type, MixedAddRem);       \
374    MY_BENCHMARK4(type, Fifo);              \
375    MY_BENCHMARK4(type, FwdIter);           \
376    MY_BENCHMARK4(type, InsertRangeRandom); \
377    MY_BENCHMARK4(type, InsertRangeSorted)
378  #define MY_BENCHMARK3(type)     \
379    MY_BENCHMARK4(type, EraseIf); \
380    MY_BENCHMARK3_STL(type)
381  #define MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type) \
382    MY_BENCHMARK3_STL(stl_##type);                \
383    MY_BENCHMARK3_STL(stl_unordered_##type);      \
384    MY_BENCHMARK3(btree_256_##type)
385  #define MY_BENCHMARK2(type)                \
386    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type); \
387    MY_BENCHMARK3(flat_hash_##type)
388  #ifdef MULTI_TESTING
389  #define MY_BENCHMARK(type)                            \
390    MY_BENCHMARK2(set_##type);                          \
391    MY_BENCHMARK2(map_##type);                          \
392    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multiset_##type); \
393    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multimap_##type)
394  #else
395  #define MY_BENCHMARK(type)   \
396    MY_BENCHMARK2(set_##type); \
397    MY_BENCHMARK2(map_##type)
398  #endif
399  MY_BENCHMARK(int32_t);
400  MY_BENCHMARK(int64_t);
401  MY_BENCHMARK(StdString);
402  MY_BENCHMARK(Cord);
403  MY_BENCHMARK(Time);
404  template <int Size, int Copies>
405  struct BigType {
406    BigType() : BigType(0) {}
407    explicit BigType(int x) { std::iota(values.begin(), values.end(), x); }
408    void Copy(const BigType& other) {
409      for (int i = 0; i < Size && i < Copies; ++i) values[i] = other.values[i];
410      for (int i = Size, idx = 0; i < Copies; ++i) {
411        int64_t tmp = other.values[idx];
412        benchmark::DoNotOptimize(tmp);
413        idx = idx + 1 == Size ? 0 : idx + 1;
414      }
415    }
416    BigType(const BigType& other) { Copy(other); }
417    BigType& operator=(const BigType& other) {
418      Copy(other);
419      return *this;
420    }
421    bool operator<(const BigType& other) const {
422      return std::lexicographical_compare(
423          values.begin(), values.begin() + std::min(Size, Copies),
424          other.values.begin(), other.values.begin() + std::min(Size, Copies));
425    }
426    bool operator==(const BigType& other) const {
427      return std::equal(values.begin(), values.begin() + std::min(Size, Copies),
428                        other.values.begin());
429    }
430    template <typename State>
431    friend State AbslHashValue(State h, const BigType& b) {
432      for (int i = 0; i < Size && i < Copies; ++i)
433        h = State::combine(std::move(h), b.values[i]);
434      return h;
435    }
436    std::array<int64_t, Size> values;
437  };
438  #define BIG_TYPE_BENCHMARKS(SIZE, COPIES)                                     \
439    using stl_set_size##SIZE##copies##COPIES = std::set<BigType<SIZE, COPIES>>; \
440    using stl_map_size##SIZE##copies##COPIES =                                  \
441        std::map<BigType<SIZE, COPIES>, intptr_t>;                              \
442    using stl_multiset_size##SIZE##copies##COPIES =                             \
443        std::multiset<BigType<SIZE, COPIES>>;                                   \
444    using stl_multimap_size##SIZE##copies##COPIES =                             \
445        std::multimap<BigType<SIZE, COPIES>, intptr_t>;                         \
446    using stl_unordered_set_size##SIZE##copies##COPIES =                        \
447        std::unordered_set<BigType<SIZE, COPIES>,                               \
448                           absl::Hash<BigType<SIZE, COPIES>>>;                  \
449    using stl_unordered_map_size##SIZE##copies##COPIES =                        \
450        std::unordered_map<BigType<SIZE, COPIES>, intptr_t,                     \
451                           absl::Hash<BigType<SIZE, COPIES>>>;                  \
452    using flat_hash_set_size##SIZE##copies##COPIES =                            \
453        flat_hash_set<BigType<SIZE, COPIES>>;                                   \
454    using flat_hash_map_size##SIZE##copies##COPIES =                            \
455        flat_hash_map<BigType<SIZE, COPIES>, intptr_t>;                         \
456    using stl_unordered_multiset_size##SIZE##copies##COPIES =                   \
457        std::unordered_multiset<BigType<SIZE, COPIES>,                          \
458                                absl::Hash<BigType<SIZE, COPIES>>>;             \
459    using stl_unordered_multimap_size##SIZE##copies##COPIES =                   \
460        std::unordered_multimap<BigType<SIZE, COPIES>, intptr_t,                \
461                                absl::Hash<BigType<SIZE, COPIES>>>;             \
462    using btree_256_set_size##SIZE##copies##COPIES =                            \
463        btree_set<BigType<SIZE, COPIES>>;                                       \
464    using btree_256_map_size##SIZE##copies##COPIES =                            \
465        btree_map<BigType<SIZE, COPIES>, intptr_t>;                             \
466    using btree_256_multiset_size##SIZE##copies##COPIES =                       \
467        btree_multiset<BigType<SIZE, COPIES>>;                                  \
468    using btree_256_multimap_size##SIZE##copies##COPIES =                       \
469        btree_multimap<BigType<SIZE, COPIES>, intptr_t>;                        \
470    MY_BENCHMARK(size##SIZE##copies##COPIES)
471  #ifndef NODESIZE_TESTING
472  #ifdef BIG_TYPE_TESTING
473  BIG_TYPE_BENCHMARKS(1, 4);
474  BIG_TYPE_BENCHMARKS(4, 1);
475  BIG_TYPE_BENCHMARKS(4, 4);
476  BIG_TYPE_BENCHMARKS(1, 8);
477  BIG_TYPE_BENCHMARKS(8, 1);
478  BIG_TYPE_BENCHMARKS(8, 8);
479  BIG_TYPE_BENCHMARKS(1, 16);
480  BIG_TYPE_BENCHMARKS(16, 1);
481  BIG_TYPE_BENCHMARKS(16, 16);
482  BIG_TYPE_BENCHMARKS(1, 32);
483  BIG_TYPE_BENCHMARKS(32, 1);
484  BIG_TYPE_BENCHMARKS(32, 32);
485  #else
486  BIG_TYPE_BENCHMARKS(32, 32);
487  #endif
488  #endif
489  template <int Size>
490  struct BigTypePtr {
491    BigTypePtr() : BigTypePtr(0) {}
492    explicit BigTypePtr(int x) {
493      ptr = absl::make_unique<BigType<Size, Size>>(x);
494    }
495    BigTypePtr(const BigTypePtr& other) {
496      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&& other) noexcept = default;
499    BigTypePtr& operator=(const BigTypePtr& other) {
<span onclick='openModal()' class='match'>500      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
501    }
502    BigTypePtr& operator=(BigTypePtr&& other) noexcept = default;
</span>503    bool operator<(const BigTypePtr& other) const { return *ptr < *other.ptr; }
504    bool operator==(const BigTypePtr& other) const { return *ptr == *other.ptr; }
505    std::unique_ptr<BigType<Size, Size>> ptr;
506  };
507  template <int Size>
508  double ContainerInfo(const btree_set<BigTypePtr<Size>>& b) {
509    const double bytes_used =
510        b.bytes_used() + b.size() * sizeof(BigType<Size, Size>);
511    const double bytes_per_value = bytes_used / b.size();
512    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
513    return bytes_per_value;
514  }
515  template <int Size>
516  double ContainerInfo(const btree_map<int, BigTypePtr<Size>>& b) {
517    const double bytes_used =
518        b.bytes_used() + b.size() * sizeof(BigType<Size, Size>);
519    const double bytes_per_value = bytes_used / b.size();
520    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
521    return bytes_per_value;
522  }
523  #define BIG_TYPE_PTR_BENCHMARKS(SIZE)                                          \
524    using stl_set_size##SIZE##copies##SIZE##ptr = std::set<BigType<SIZE, SIZE>>; \
525    using stl_map_size##SIZE##copies##SIZE##ptr =                                \
526        std::map<int, BigType<SIZE, SIZE>>;                                      \
527    using stl_unordered_set_size##SIZE##copies##SIZE##ptr =                      \
528        std::unordered_set<BigType<SIZE, SIZE>,                                  \
529                           absl::Hash<BigType<SIZE, SIZE>>>;                     \
530    using stl_unordered_map_size##SIZE##copies##SIZE##ptr =                      \
531        std::unordered_map<int, BigType<SIZE, SIZE>>;                            \
532    using flat_hash_set_size##SIZE##copies##SIZE##ptr =                          \
533        flat_hash_set<BigType<SIZE, SIZE>>;                                      \
534    using flat_hash_map_size##SIZE##copies##SIZE##ptr =                          \
535        flat_hash_map<int, BigTypePtr<SIZE>>;                                    \
536    using btree_256_set_size##SIZE##copies##SIZE##ptr =                          \
537        btree_set<BigTypePtr<SIZE>>;                                             \
538    using btree_256_map_size##SIZE##copies##SIZE##ptr =                          \
539        btree_map<int, BigTypePtr<SIZE>>;                                        \
540    MY_BENCHMARK3_STL(stl_set_size##SIZE##copies##SIZE##ptr);                    \
541    MY_BENCHMARK3_STL(stl_unordered_set_size##SIZE##copies##SIZE##ptr);          \
542    MY_BENCHMARK3(flat_hash_set_size##SIZE##copies##SIZE##ptr);                  \
543    MY_BENCHMARK3(btree_256_set_size##SIZE##copies##SIZE##ptr);                  \
544    MY_BENCHMARK3_STL(stl_map_size##SIZE##copies##SIZE##ptr);                    \
545    MY_BENCHMARK3_STL(stl_unordered_map_size##SIZE##copies##SIZE##ptr);          \
546    MY_BENCHMARK3(flat_hash_map_size##SIZE##copies##SIZE##ptr);                  \
547    MY_BENCHMARK3(btree_256_map_size##SIZE##copies##SIZE##ptr)
548  BIG_TYPE_PTR_BENCHMARKS(32);
549  void BM_BtreeSet_IteratorSubtraction(benchmark::State& state) {
550    absl::InsecureBitGen bitgen;
551    std::vector<int> vec;
552    vec.reserve(state.range(0));
553    for (int i = 0; i < state.range(0); ++i) vec.push_back(i);
554    absl::c_shuffle(vec, bitgen);
555    absl::btree_set<int> set;
556    for (int i : vec) set.insert(i);
557    size_t distance = absl::Uniform(bitgen, 0u, set.size());
558    while (state.KeepRunningBatch(distance)) {
559      size_t end = absl::Uniform(bitgen, distance, set.size());
560      size_t begin = end - distance;
561      benchmark::DoNotOptimize(set.find(static_cast<int>(end)) -
562                               set.find(static_cast<int>(begin)));
563      distance = absl::Uniform(bitgen, 0u, set.size());
564    }
565  }
566  BENCHMARK(BM_BtreeSet_IteratorSubtraction)->Range(1 << 10, 1 << 20);
567  }  
568  }  
569  ABSL_NAMESPACE_END
570  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>496      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&& other) noexcept = default;
</pre></code></div>
                <div class="column column_space"><pre><code>500      ptr = absl::make_unique<BigType<Size, Size>>(*other.ptr);
501    }
502    BigTypePtr& operator=(BigTypePtr&& other) noexcept = default;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    