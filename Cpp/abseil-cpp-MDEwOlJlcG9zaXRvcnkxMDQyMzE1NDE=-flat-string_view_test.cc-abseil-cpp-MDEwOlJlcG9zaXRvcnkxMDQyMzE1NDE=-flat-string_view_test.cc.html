
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_test.cc</h3>
            <pre><code>1  #include "absl/strings/string_view.h"
2  #include <stdlib.h>
3  #include <iomanip>
4  #include <iterator>
5  #include <limits>
6  #include <map>
7  #include <sstream>
8  #include <stdexcept>
9  #include <string>
10  #include <type_traits>
11  #include <utility>
12  #include "gtest/gtest.h"
13  #include "absl/base/config.h"
14  #include "absl/base/dynamic_annotations.h"
15  #include "absl/base/options.h"
16  #if defined(ABSL_HAVE_STD_STRING_VIEW) || defined(__ANDROID__)
17  #define ABSL_EXPECT_DEATH_IF_SUPPORTED(statement, regex) \
18    EXPECT_DEATH_IF_SUPPORTED(statement, ".*")
19  #else
20  #define ABSL_EXPECT_DEATH_IF_SUPPORTED(statement, regex) \
21    EXPECT_DEATH_IF_SUPPORTED(statement, regex)
22  #endif
23  namespace {
24  template <typename T>
25  struct Mallocator {
26    typedef T value_type;
27    typedef size_t size_type;
28    typedef ptrdiff_t difference_type;
29    typedef T* pointer;
30    typedef const T* const_pointer;
31    typedef T& reference;
32    typedef const T& const_reference;
33    size_type max_size() const {
34      return size_t(std::numeric_limits<size_type>::max()) / sizeof(value_type);
35    }
36    template <typename U>
37    struct rebind {
38      typedef Mallocator<U> other;
39    };
40    Mallocator() = default;
41    template <class U>
42    Mallocator(const Mallocator<U>&) {}  
43    T* allocate(size_t n) { return static_cast<T*>(std::malloc(n * sizeof(T))); }
44    void deallocate(T* p, size_t) { std::free(p); }
45  };
46  template <typename T, typename U>
47  bool operator==(const Mallocator<T>&, const Mallocator<U>&) {
48    return true;
49  }
50  template <typename T, typename U>
51  bool operator!=(const Mallocator<T>&, const Mallocator<U>&) {
52    return false;
53  }
54  TEST(StringViewTest, Ctor) {
55    {
56      absl::string_view s10;
57      EXPECT_TRUE(s10.data() == nullptr);
58      EXPECT_EQ(0u, s10.length());
59    }
60    {
61      const char* hello = "hello";
62      absl::string_view s20(hello);
63      EXPECT_TRUE(s20.data() == hello);
64      EXPECT_EQ(5u, s20.length());
65      absl::string_view s21(hello, 4);
66      EXPECT_TRUE(s21.data() == hello);
67      EXPECT_EQ(4u, s21.length());
68      absl::string_view s22(hello, 6);
69      EXPECT_TRUE(s22.data() == hello);
70      EXPECT_EQ(6u, s22.length());
71    }
72    {
73      std::string hola = "hola";
74      absl::string_view s30(hola);
75      EXPECT_TRUE(s30.data() == hola.data());
76      EXPECT_EQ(4u, s30.length());
77      hola.push_back('\0');
78      hola.append("h2");
79      hola.push_back('\0');
80      absl::string_view s31(hola);
81      EXPECT_TRUE(s31.data() == hola.data());
82      EXPECT_EQ(8u, s31.length());
83    }
84    {
85      using mstring =
86          std::basic_string<char, std::char_traits<char>, Mallocator<char>>;
87      mstring str1("BUNGIE-JUMPING!");
88      const mstring str2("SLEEPING!");
89      absl::string_view s1(str1);
90      s1.remove_prefix(strlen("BUNGIE-JUM"));
91      absl::string_view s2(str2);
92      s2.remove_prefix(strlen("SLEE"));
93      EXPECT_EQ(s1, s2);
94      EXPECT_EQ(s1, "PING!");
95    }
96  }
97  TEST(StringViewTest, Swap) {
98    absl::string_view a("a");
99    absl::string_view b("bbb");
100    EXPECT_TRUE(noexcept(a.swap(b)));
101    a.swap(b);
102    EXPECT_EQ(a, "bbb");
103    EXPECT_EQ(b, "a");
104    a.swap(b);
105    EXPECT_EQ(a, "a");
106    EXPECT_EQ(b, "bbb");
107  }
108  TEST(StringViewTest, STLComparator) {
109    std::string s1("foo");
110    std::string s2("bar");
111    std::string s3("baz");
112    absl::string_view p1(s1);
113    absl::string_view p2(s2);
114    absl::string_view p3(s3);
115    typedef std::map<absl::string_view, int> TestMap;
116    TestMap map;
117    map.insert(std::make_pair(p1, 0));
118    map.insert(std::make_pair(p2, 1));
119    map.insert(std::make_pair(p3, 2));
120    EXPECT_EQ(map.size(), 3u);
121    TestMap::const_iterator iter = map.begin();
122    EXPECT_EQ(iter->second, 1);
123    ++iter;
124    EXPECT_EQ(iter->second, 2);
125    ++iter;
126    EXPECT_EQ(iter->second, 0);
127    ++iter;
128    EXPECT_TRUE(iter == map.end());
129    TestMap::iterator new_iter = map.find("zot");
130    EXPECT_TRUE(new_iter == map.end());
131    new_iter = map.find("bar");
132    EXPECT_TRUE(new_iter != map.end());
133    map.erase(new_iter);
134    EXPECT_EQ(map.size(), 2u);
135    iter = map.begin();
136    EXPECT_EQ(iter->second, 2);
137    ++iter;
138    EXPECT_EQ(iter->second, 0);
139    ++iter;
140    EXPECT_TRUE(iter == map.end());
141  }
142  #define COMPARE(result, op, x, y)                                      \
143    EXPECT_EQ(result, absl::string_view((x)) op absl::string_view((y))); \
144    EXPECT_EQ(result, absl::string_view((x)).compare(absl::string_view((y))) op 0)
145  TEST(StringViewTest, ComparisonOperators) {
146    COMPARE(true, ==, "",   "");
147    COMPARE(true, ==, "", absl::string_view());
148    COMPARE(true, ==, absl::string_view(), "");
149    COMPARE(true, ==, "a",  "a");
150    COMPARE(true, ==, "aa", "aa");
151    COMPARE(false, ==, "a",  "");
152    COMPARE(false, ==, "",   "a");
153    COMPARE(false, ==, "a",  "b");
154    COMPARE(false, ==, "a",  "aa");
155    COMPARE(false, ==, "aa", "a");
156    COMPARE(false, !=, "",   "");
157    COMPARE(false, !=, "a",  "a");
158    COMPARE(false, !=, "aa", "aa");
159    COMPARE(true, !=, "a",  "");
160    COMPARE(true, !=, "",   "a");
161    COMPARE(true, !=, "a",  "b");
162    COMPARE(true, !=, "a",  "aa");
163    COMPARE(true, !=, "aa", "a");
164    COMPARE(true, <, "a",  "b");
165    COMPARE(true, <, "a",  "aa");
166    COMPARE(true, <, "aa", "b");
167    COMPARE(true, <, "aa", "bb");
168    COMPARE(false, <, "a",  "a");
169    COMPARE(false, <, "b",  "a");
170    COMPARE(false, <, "aa", "a");
171    COMPARE(false, <, "b",  "aa");
172    COMPARE(false, <, "bb", "aa");
173    COMPARE(true, <=, "a",  "a");
174    COMPARE(true, <=, "a",  "b");
175    COMPARE(true, <=, "a",  "aa");
176    COMPARE(true, <=, "aa", "b");
177    COMPARE(true, <=, "aa", "bb");
178    COMPARE(false, <=, "b",  "a");
179    COMPARE(false, <=, "aa", "a");
180    COMPARE(false, <=, "b",  "aa");
181    COMPARE(false, <=, "bb", "aa");
182    COMPARE(false, >=, "a",  "b");
183    COMPARE(false, >=, "a",  "aa");
184    COMPARE(false, >=, "aa", "b");
185    COMPARE(false, >=, "aa", "bb");
186    COMPARE(true, >=, "a",  "a");
187    COMPARE(true, >=, "b",  "a");
188    COMPARE(true, >=, "aa", "a");
189    COMPARE(true, >=, "b",  "aa");
190    COMPARE(true, >=, "bb", "aa");
191    COMPARE(false, >, "a",  "a");
192    COMPARE(false, >, "a",  "b");
193    COMPARE(false, >, "a",  "aa");
194    COMPARE(false, >, "aa", "b");
195    COMPARE(false, >, "aa", "bb");
196    COMPARE(true, >, "b",  "a");
197    COMPARE(true, >, "aa", "a");
198    COMPARE(true, >, "b",  "aa");
199    COMPARE(true, >, "bb", "aa");
200  }
201  TEST(StringViewTest, ComparisonOperatorsByCharacterPosition) {
202    std::string x;
203    for (size_t i = 0; i < 256; i++) {
204      x += 'a';
205      std::string y = x;
206      COMPARE(true, ==, x, y);
207      for (size_t j = 0; j < i; j++) {
208        std::string z = x;
209        z[j] = 'b';       
210        COMPARE(false, ==, x, z);
211        COMPARE(true, <, x, z);
212        COMPARE(true, >, z, x);
213        if (j + 1 < i) {
214          z[j + 1] = 'A';  
215          COMPARE(false, ==, x, z);
216          COMPARE(true, <, x, z);
217          COMPARE(true, >, z, x);
218          z[j + 1] = 'z';  
219          COMPARE(false, ==, x, z);
220          COMPARE(true, <, x, z);
221          COMPARE(true, >, z, x);
222        }
223      }
224    }
225  }
226  #undef COMPARE
227  template <typename T>
228  struct is_type {
229    template <typename U>
230    static bool same(U) {
231      return false;
232    }
233    static bool same(T) { return true; }
234  };
235  TEST(StringViewTest, NposMatchesStdStringView) {
236    EXPECT_EQ(absl::string_view::npos, std::string::npos);
237    EXPECT_TRUE(is_type<size_t>::same(absl::string_view::npos));
238    EXPECT_FALSE(is_type<size_t>::same(""));
239    char test[absl::string_view::npos & 1] = {0};
240    EXPECT_EQ(0, test[0]);
241  }
242  TEST(StringViewTest, STL1) {
243    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
244    const absl::string_view b("abc");
245    const absl::string_view c("xyz");
246    const absl::string_view d("foobar");
247    const absl::string_view e;
248    std::string temp("123");
249    temp += '\0';
250    temp += "456";
251    const absl::string_view f(temp);
252    EXPECT_EQ(a[6], 'g');
253    EXPECT_EQ(b[0], 'a');
254    EXPECT_EQ(c[2], 'z');
255    EXPECT_EQ(f[3], '\0');
256    EXPECT_EQ(f[5], '5');
257    EXPECT_EQ(*d.data(), 'f');
258    EXPECT_EQ(d.data()[5], 'r');
259    EXPECT_TRUE(e.data() == nullptr);
260    EXPECT_EQ(*a.begin(), 'a');
261    EXPECT_EQ(*(b.begin() + 2), 'c');
262    EXPECT_EQ(*(c.end() - 1), 'z');
263    EXPECT_EQ(*a.rbegin(), 'z');
264    EXPECT_EQ(*(b.rbegin() + 2), 'a');
265    EXPECT_EQ(*(c.rend() - 1), 'x');
266    EXPECT_TRUE(a.rbegin() + 26 == a.rend());
267    EXPECT_EQ(a.size(), 26u);
268    EXPECT_EQ(b.size(), 3u);
269    EXPECT_EQ(c.size(), 3u);
270    EXPECT_EQ(d.size(), 6u);
271    EXPECT_EQ(e.size(), 0u);
272    EXPECT_EQ(f.size(), 7u);
273    EXPECT_TRUE(!d.empty());
274    EXPECT_TRUE(d.begin() != d.end());
275    EXPECT_TRUE(d.begin() + 6 == d.end());
276    EXPECT_TRUE(e.empty());
277    EXPECT_TRUE(e.begin() == e.end());
278    char buf[4] = { '%', '%', '%', '%' };
279    EXPECT_EQ(a.copy(buf, 4), 4u);
280    EXPECT_EQ(buf[0], a[0]);
281    EXPECT_EQ(buf[1], a[1]);
282    EXPECT_EQ(buf[2], a[2]);
283    EXPECT_EQ(buf[3], a[3]);
284    EXPECT_EQ(a.copy(buf, 3, 7), 3u);
285    EXPECT_EQ(buf[0], a[7]);
286    EXPECT_EQ(buf[1], a[8]);
287    EXPECT_EQ(buf[2], a[9]);
288    EXPECT_EQ(buf[3], a[3]);
289    EXPECT_EQ(c.copy(buf, 99), 3u);
290    EXPECT_EQ(buf[0], c[0]);
291    EXPECT_EQ(buf[1], c[1]);
292    EXPECT_EQ(buf[2], c[2]);
293    EXPECT_EQ(buf[3], a[3]);
294  #ifdef ABSL_HAVE_EXCEPTIONS
295    EXPECT_THROW(a.copy(buf, 1, 27), std::out_of_range);
296  #else
297    ABSL_EXPECT_DEATH_IF_SUPPORTED(a.copy(buf, 1, 27), "absl::string_view::copy");
298  #endif
299  }
300  TEST(StringViewTest, STL2) {
301    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
302    const absl::string_view b("abc");
303    const absl::string_view c("xyz");
304    absl::string_view d("foobar");
305    const absl::string_view e;
306    const absl::string_view f(
307        "123"
308        "\0"
309        "456",
310        7);
311    d = absl::string_view();
312    EXPECT_EQ(d.size(), 0u);
313    EXPECT_TRUE(d.empty());
314    EXPECT_TRUE(d.data() == nullptr);
315    EXPECT_TRUE(d.begin() == d.end());
316    EXPECT_EQ(a.find(b), 0u);
317    EXPECT_EQ(a.find(b, 1), absl::string_view::npos);
318    EXPECT_EQ(a.find(c), 23u);
319    EXPECT_EQ(a.find(c, 9), 23u);
320    EXPECT_EQ(a.find(c, absl::string_view::npos), absl::string_view::npos);
321    EXPECT_EQ(b.find(c), absl::string_view::npos);
322    EXPECT_EQ(b.find(c, absl::string_view::npos), absl::string_view::npos);
323    EXPECT_EQ(a.find(d), 0u);
324    EXPECT_EQ(a.find(e), 0u);
325    EXPECT_EQ(a.find(d, 12), 12u);
326    EXPECT_EQ(a.find(e, 17), 17u);
327    absl::string_view g("xx not found bb");
328    EXPECT_EQ(a.find(g), absl::string_view::npos);
329    EXPECT_EQ(d.find(b), absl::string_view::npos);
330    EXPECT_EQ(e.find(b), absl::string_view::npos);
331    EXPECT_EQ(d.find(b, 4), absl::string_view::npos);
332    EXPECT_EQ(e.find(b, 7), absl::string_view::npos);
333    size_t empty_search_pos = std::string().find(std::string());
334    EXPECT_EQ(d.find(d), empty_search_pos);
335    EXPECT_EQ(d.find(e), empty_search_pos);
336    EXPECT_EQ(e.find(d), empty_search_pos);
337    EXPECT_EQ(e.find(e), empty_search_pos);
338    EXPECT_EQ(d.find(d, 4), std::string().find(std::string(), 4));
339    EXPECT_EQ(d.find(e, 4), std::string().find(std::string(), 4));
340    EXPECT_EQ(e.find(d, 4), std::string().find(std::string(), 4));
341    EXPECT_EQ(e.find(e, 4), std::string().find(std::string(), 4));
342    EXPECT_EQ(a.find('a'), 0u);
343    EXPECT_EQ(a.find('c'), 2u);
344    EXPECT_EQ(a.find('z'), 25u);
345    EXPECT_EQ(a.find('$'), absl::string_view::npos);
346    EXPECT_EQ(a.find('\0'), absl::string_view::npos);
347    EXPECT_EQ(f.find('\0'), 3u);
348    EXPECT_EQ(f.find('3'), 2u);
349    EXPECT_EQ(f.find('5'), 5u);
350    EXPECT_EQ(g.find('o'), 4u);
351    EXPECT_EQ(g.find('o', 4), 4u);
352    EXPECT_EQ(g.find('o', 5), 8u);
353    EXPECT_EQ(a.find('b', 5), absl::string_view::npos);
354    EXPECT_EQ(d.find('\0'), absl::string_view::npos);
355    EXPECT_EQ(e.find('\0'), absl::string_view::npos);
356    EXPECT_EQ(d.find('\0', 4), absl::string_view::npos);
357    EXPECT_EQ(e.find('\0', 7), absl::string_view::npos);
358    EXPECT_EQ(d.find('x'), absl::string_view::npos);
359    EXPECT_EQ(e.find('x'), absl::string_view::npos);
360    EXPECT_EQ(d.find('x', 4), absl::string_view::npos);
361    EXPECT_EQ(e.find('x', 7), absl::string_view::npos);
362    EXPECT_EQ(a.find(b.data(), 1, 0), 1u);
363    EXPECT_EQ(a.find(c.data(), 9, 0), 9u);
364    EXPECT_EQ(a.find(c.data(), absl::string_view::npos, 0),
365              absl::string_view::npos);
366    EXPECT_EQ(b.find(c.data(), absl::string_view::npos, 0),
367              absl::string_view::npos);
368    EXPECT_EQ(d.find(b.data(), 4, 0), absl::string_view::npos);
369    EXPECT_EQ(e.find(b.data(), 7, 0), absl::string_view::npos);
370    EXPECT_EQ(a.find(b.data(), 1), absl::string_view::npos);
371    EXPECT_EQ(a.find(c.data(), 9), 23u);
372    EXPECT_EQ(a.find(c.data(), absl::string_view::npos), absl::string_view::npos);
373    EXPECT_EQ(b.find(c.data(), absl::string_view::npos), absl::string_view::npos);
374    EXPECT_EQ(d.find(b.data(), 4), absl::string_view::npos);
375    EXPECT_EQ(e.find(b.data(), 7), absl::string_view::npos);
376    EXPECT_EQ(a.rfind(b), 0u);
377    EXPECT_EQ(a.rfind(b, 1), 0u);
378    EXPECT_EQ(a.rfind(c), 23u);
379    EXPECT_EQ(a.rfind(c, 22), absl::string_view::npos);
380    EXPECT_EQ(a.rfind(c, 1), absl::string_view::npos);
381    EXPECT_EQ(a.rfind(c, 0), absl::string_view::npos);
382    EXPECT_EQ(b.rfind(c), absl::string_view::npos);
383    EXPECT_EQ(b.rfind(c, 0), absl::string_view::npos);
384    EXPECT_EQ(a.rfind(d), std::string(a).rfind(std::string()));
385    EXPECT_EQ(a.rfind(e), std::string(a).rfind(std::string()));
386    EXPECT_EQ(a.rfind(d, 12), 12u);
387    EXPECT_EQ(a.rfind(e, 17), 17u);
388    EXPECT_EQ(a.rfind(g), absl::string_view::npos);
389    EXPECT_EQ(d.rfind(b), absl::string_view::npos);
390    EXPECT_EQ(e.rfind(b), absl::string_view::npos);
391    EXPECT_EQ(d.rfind(b, 4), absl::string_view::npos);
392    EXPECT_EQ(e.rfind(b, 7), absl::string_view::npos);
393    EXPECT_EQ(d.rfind(d, 4), std::string().rfind(std::string()));
394    EXPECT_EQ(e.rfind(d, 7), std::string().rfind(std::string()));
395    EXPECT_EQ(d.rfind(e, 4), std::string().rfind(std::string()));
396    EXPECT_EQ(e.rfind(e, 7), std::string().rfind(std::string()));
397    EXPECT_EQ(d.rfind(d), std::string().rfind(std::string()));
398    EXPECT_EQ(e.rfind(d), std::string().rfind(std::string()));
399    EXPECT_EQ(d.rfind(e), std::string().rfind(std::string()));
400    EXPECT_EQ(e.rfind(e), std::string().rfind(std::string()));
401    EXPECT_EQ(g.rfind('o'), 8u);
402    EXPECT_EQ(g.rfind('q'), absl::string_view::npos);
403    EXPECT_EQ(g.rfind('o', 8), 8u);
404    EXPECT_EQ(g.rfind('o', 7), 4u);
405    EXPECT_EQ(g.rfind('o', 3), absl::string_view::npos);
406    EXPECT_EQ(f.rfind('\0'), 3u);
407    EXPECT_EQ(f.rfind('\0', 12), 3u);
408    EXPECT_EQ(f.rfind('3'), 2u);
409    EXPECT_EQ(f.rfind('5'), 5u);
410    EXPECT_EQ(d.rfind('o'), absl::string_view::npos);
411    EXPECT_EQ(e.rfind('o'), absl::string_view::npos);
412    EXPECT_EQ(d.rfind('o', 4), absl::string_view::npos);
413    EXPECT_EQ(e.rfind('o', 7), absl::string_view::npos);
414    EXPECT_EQ(a.rfind(b.data(), 1, 0), 1u);
415    EXPECT_EQ(a.rfind(c.data(), 22, 0), 22u);
416    EXPECT_EQ(a.rfind(c.data(), 1, 0), 1u);
417    EXPECT_EQ(a.rfind(c.data(), 0, 0), 0u);
418    EXPECT_EQ(b.rfind(c.data(), 0, 0), 0u);
419    EXPECT_EQ(d.rfind(b.data(), 4, 0), 0u);
420    EXPECT_EQ(e.rfind(b.data(), 7, 0), 0u);
421  }
422  TEST(StringViewTest, STL2FindFirst) {
423    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
424    const absl::string_view b("abc");
425    const absl::string_view c("xyz");
426    absl::string_view d("foobar");
427    const absl::string_view e;
428    const absl::string_view f(
429        "123"
430        "\0"
431        "456",
432        7);
433    absl::string_view g("xx not found bb");
434    d = absl::string_view();
435    EXPECT_EQ(a.find_first_of(b), 0u);
436    EXPECT_EQ(a.find_first_of(b, 0), 0u);
437    EXPECT_EQ(a.find_first_of(b, 1), 1u);
438    EXPECT_EQ(a.find_first_of(b, 2), 2u);
439    EXPECT_EQ(a.find_first_of(b, 3), absl::string_view::npos);
440    EXPECT_EQ(a.find_first_of(c), 23u);
441    EXPECT_EQ(a.find_first_of(c, 23), 23u);
442    EXPECT_EQ(a.find_first_of(c, 24), 24u);
443    EXPECT_EQ(a.find_first_of(c, 25), 25u);
444    EXPECT_EQ(a.find_first_of(c, 26), absl::string_view::npos);
445    EXPECT_EQ(g.find_first_of(b), 13u);
446    EXPECT_EQ(g.find_first_of(c), 0u);
447    EXPECT_EQ(a.find_first_of(f), absl::string_view::npos);
448    EXPECT_EQ(f.find_first_of(a), absl::string_view::npos);
449    EXPECT_EQ(a.find_first_of(d), absl::string_view::npos);
450    EXPECT_EQ(a.find_first_of(e), absl::string_view::npos);
451    EXPECT_EQ(d.find_first_of(b), absl::string_view::npos);
452    EXPECT_EQ(e.find_first_of(b), absl::string_view::npos);
453    EXPECT_EQ(d.find_first_of(d), absl::string_view::npos);
454    EXPECT_EQ(e.find_first_of(d), absl::string_view::npos);
455    EXPECT_EQ(d.find_first_of(e), absl::string_view::npos);
456    EXPECT_EQ(e.find_first_of(e), absl::string_view::npos);
457    EXPECT_EQ(a.find_first_not_of(b), 3u);
458    EXPECT_EQ(a.find_first_not_of(c), 0u);
459    EXPECT_EQ(b.find_first_not_of(a), absl::string_view::npos);
460    EXPECT_EQ(c.find_first_not_of(a), absl::string_view::npos);
461    EXPECT_EQ(f.find_first_not_of(a), 0u);
462    EXPECT_EQ(a.find_first_not_of(f), 0u);
463    EXPECT_EQ(a.find_first_not_of(d), 0u);
464    EXPECT_EQ(a.find_first_not_of(e), 0u);
465    EXPECT_EQ(a.find_first_not_of(d), 0u);
466    EXPECT_EQ(a.find_first_not_of(e), 0u);
467    EXPECT_EQ(a.find_first_not_of(d, 1), 1u);
468    EXPECT_EQ(a.find_first_not_of(e, 1), 1u);
469    EXPECT_EQ(a.find_first_not_of(d, a.size() - 1), a.size() - 1);
470    EXPECT_EQ(a.find_first_not_of(e, a.size() - 1), a.size() - 1);
471    EXPECT_EQ(a.find_first_not_of(d, a.size()), absl::string_view::npos);
472    EXPECT_EQ(a.find_first_not_of(e, a.size()), absl::string_view::npos);
473    EXPECT_EQ(a.find_first_not_of(d, absl::string_view::npos),
474              absl::string_view::npos);
475    EXPECT_EQ(a.find_first_not_of(e, absl::string_view::npos),
476              absl::string_view::npos);
477    EXPECT_EQ(d.find_first_not_of(a), absl::string_view::npos);
478    EXPECT_EQ(e.find_first_not_of(a), absl::string_view::npos);
479    EXPECT_EQ(d.find_first_not_of(d), absl::string_view::npos);
480    EXPECT_EQ(e.find_first_not_of(d), absl::string_view::npos);
481    EXPECT_EQ(d.find_first_not_of(e), absl::string_view::npos);
482    EXPECT_EQ(e.find_first_not_of(e), absl::string_view::npos);
483    absl::string_view h("====");
484    EXPECT_EQ(h.find_first_not_of('='), absl::string_view::npos);
485    EXPECT_EQ(h.find_first_not_of('=', 3), absl::string_view::npos);
486    EXPECT_EQ(h.find_first_not_of('\0'), 0u);
487    EXPECT_EQ(g.find_first_not_of('x'), 2u);
488    EXPECT_EQ(f.find_first_not_of('\0'), 0u);
489    EXPECT_EQ(f.find_first_not_of('\0', 3), 4u);
490    EXPECT_EQ(f.find_first_not_of('\0', 2), 2u);
491    EXPECT_EQ(d.find_first_not_of('x'), absl::string_view::npos);
492    EXPECT_EQ(e.find_first_not_of('x'), absl::string_view::npos);
493    EXPECT_EQ(d.find_first_not_of('\0'), absl::string_view::npos);
494    EXPECT_EQ(e.find_first_not_of('\0'), absl::string_view::npos);
495  }
496  TEST(StringViewTest, STL2FindLast) {
497    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
498    const absl::string_view b("abc");
499    const absl::string_view c("xyz");
500    absl::string_view d("foobar");
501    const absl::string_view e;
502    const absl::string_view f(
503        "123"
504        "\0"
505        "456",
506        7);
507    absl::string_view g("xx not found bb");
508    absl::string_view h("====");
509    absl::string_view i("56");
510    d = absl::string_view();
511    EXPECT_EQ(h.find_last_of(a), absl::string_view::npos);
512    EXPECT_EQ(g.find_last_of(a), g.size() - 1);
513    EXPECT_EQ(a.find_last_of(b), 2u);
514    EXPECT_EQ(a.find_last_of(c), a.size() - 1);
515    EXPECT_EQ(f.find_last_of(i), 6u);
516    EXPECT_EQ(a.find_last_of('a'), 0u);
517    EXPECT_EQ(a.find_last_of('b'), 1u);
518    EXPECT_EQ(a.find_last_of('z'), 25u);
519    EXPECT_EQ(a.find_last_of('a', 5), 0u);
520    EXPECT_EQ(a.find_last_of('b', 5), 1u);
521    EXPECT_EQ(a.find_last_of('b', 0), absl::string_view::npos);
522    EXPECT_EQ(a.find_last_of('z', 25), 25u);
523    EXPECT_EQ(a.find_last_of('z', 24), absl::string_view::npos);
524    EXPECT_EQ(f.find_last_of(i, 5), 5u);
525    EXPECT_EQ(f.find_last_of(i, 6), 6u);
526    EXPECT_EQ(f.find_last_of(a, 4), absl::string_view::npos);
527    EXPECT_EQ(f.find_last_of(d), absl::string_view::npos);
528    EXPECT_EQ(f.find_last_of(e), absl::string_view::npos);
529    EXPECT_EQ(f.find_last_of(d, 4), absl::string_view::npos);
530    EXPECT_EQ(f.find_last_of(e, 4), absl::string_view::npos);
531    EXPECT_EQ(d.find_last_of(d), absl::string_view::npos);
532    EXPECT_EQ(d.find_last_of(e), absl::string_view::npos);
533    EXPECT_EQ(e.find_last_of(d), absl::string_view::npos);
534    EXPECT_EQ(e.find_last_of(e), absl::string_view::npos);
535    EXPECT_EQ(d.find_last_of(f), absl::string_view::npos);
536    EXPECT_EQ(e.find_last_of(f), absl::string_view::npos);
537    EXPECT_EQ(d.find_last_of(d, 4), absl::string_view::npos);
538    EXPECT_EQ(d.find_last_of(e, 4), absl::string_view::npos);
539    EXPECT_EQ(e.find_last_of(d, 4), absl::string_view::npos);
540    EXPECT_EQ(e.find_last_of(e, 4), absl::string_view::npos);
541    EXPECT_EQ(d.find_last_of(f, 4), absl::string_view::npos);
542    EXPECT_EQ(e.find_last_of(f, 4), absl::string_view::npos);
543    EXPECT_EQ(a.find_last_not_of(b), a.size() - 1);
544    EXPECT_EQ(a.find_last_not_of(c), 22u);
545    EXPECT_EQ(b.find_last_not_of(a), absl::string_view::npos);
546    EXPECT_EQ(b.find_last_not_of(b), absl::string_view::npos);
547    EXPECT_EQ(f.find_last_not_of(i), 4u);
548    EXPECT_EQ(a.find_last_not_of(c, 24), 22u);
549    EXPECT_EQ(a.find_last_not_of(b, 3), 3u);
550    EXPECT_EQ(a.find_last_not_of(b, 2), absl::string_view::npos);
551    EXPECT_EQ(f.find_last_not_of(d), f.size() - 1);
552    EXPECT_EQ(f.find_last_not_of(e), f.size() - 1);
553    EXPECT_EQ(f.find_last_not_of(d, 4), 4u);
554    EXPECT_EQ(f.find_last_not_of(e, 4), 4u);
555    EXPECT_EQ(d.find_last_not_of(d), absl::string_view::npos);
556    EXPECT_EQ(d.find_last_not_of(e), absl::string_view::npos);
557    EXPECT_EQ(e.find_last_not_of(d), absl::string_view::npos);
558    EXPECT_EQ(e.find_last_not_of(e), absl::string_view::npos);
559    EXPECT_EQ(d.find_last_not_of(f), absl::string_view::npos);
560    EXPECT_EQ(e.find_last_not_of(f), absl::string_view::npos);
561    EXPECT_EQ(d.find_last_not_of(d, 4), absl::string_view::npos);
562    EXPECT_EQ(d.find_last_not_of(e, 4), absl::string_view::npos);
563    EXPECT_EQ(e.find_last_not_of(d, 4), absl::string_view::npos);
564    EXPECT_EQ(e.find_last_not_of(e, 4), absl::string_view::npos);
565    EXPECT_EQ(d.find_last_not_of(f, 4), absl::string_view::npos);
566    EXPECT_EQ(e.find_last_not_of(f, 4), absl::string_view::npos);
567    EXPECT_EQ(h.find_last_not_of('x'), h.size() - 1);
568    EXPECT_EQ(h.find_last_not_of('='), absl::string_view::npos);
569    EXPECT_EQ(b.find_last_not_of('c'), 1u);
570    EXPECT_EQ(h.find_last_not_of('x', 2), 2u);
571    EXPECT_EQ(h.find_last_not_of('=', 2), absl::string_view::npos);
572    EXPECT_EQ(b.find_last_not_of('b', 1), 0u);
573    EXPECT_EQ(d.find_last_not_of('x'), absl::string_view::npos);
574    EXPECT_EQ(e.find_last_not_of('x'), absl::string_view::npos);
575    EXPECT_EQ(d.find_last_not_of('\0'), absl::string_view::npos);
576    EXPECT_EQ(e.find_last_not_of('\0'), absl::string_view::npos);
577  }
578  TEST(StringViewTest, STL2Substr) {
579    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
580    const absl::string_view b("abc");
581    const absl::string_view c("xyz");
582    absl::string_view d("foobar");
583    const absl::string_view e;
584    d = absl::string_view();
585    EXPECT_EQ(a.substr(0, 3), b);
586    EXPECT_EQ(a.substr(23), c);
587    EXPECT_EQ(a.substr(23, 3), c);
588    EXPECT_EQ(a.substr(23, 99), c);
589    EXPECT_EQ(a.substr(0), a);
590    EXPECT_EQ(a.substr(), a);
591    EXPECT_EQ(a.substr(3, 2), "de");
592    EXPECT_EQ(d.substr(0, 99), e);
593    EXPECT_EQ(a.substr(0, absl::string_view::npos), a);
594    EXPECT_EQ(a.substr(23, absl::string_view::npos), c);
595  #ifdef ABSL_HAVE_EXCEPTIONS
596    EXPECT_THROW((void)a.substr(99, 2), std::out_of_range);
597  #else
598    ABSL_EXPECT_DEATH_IF_SUPPORTED((void)a.substr(99, 2),
599                                   "absl::string_view::substr");
600  #endif
601  }
602  TEST(StringViewTest, TruncSubstr) {
603    const absl::string_view hi("hi");
604    EXPECT_EQ("", absl::ClippedSubstr(hi, 0, 0));
605    EXPECT_EQ("h", absl::ClippedSubstr(hi, 0, 1));
606    EXPECT_EQ("hi", absl::ClippedSubstr(hi, 0));
607    EXPECT_EQ("i", absl::ClippedSubstr(hi, 1));
608    EXPECT_EQ("", absl::ClippedSubstr(hi, 2));
609    EXPECT_EQ("", absl::ClippedSubstr(hi, 3));  
610    EXPECT_EQ("", absl::ClippedSubstr(hi, 3, 2));  
611  }
612  TEST(StringViewTest, UTF8) {
613    std::string utf8 = "\u00E1";
614    std::string utf8_twice = utf8 + " " + utf8;
615    size_t utf8_len = strlen(utf8.data());
616    EXPECT_EQ(utf8_len, absl::string_view(utf8_twice).find_first_of(" "));
617    EXPECT_EQ(utf8_len, absl::string_view(utf8_twice).find_first_of(" \t"));
618  }
619  TEST(StringViewTest, FindConformance) {
620    struct {
621      std::string haystack;
622      std::string needle;
623    } specs[] = {
624      {"", ""},
625      {"", "a"},
626      {"a", ""},
627      {"a", "a"},
628      {"a", "b"},
629      {"aa", ""},
630      {"aa", "a"},
631      {"aa", "b"},
632      {"ab", "a"},
633      {"ab", "b"},
634      {"abcd", ""},
635      {"abcd", "a"},
636      {"abcd", "d"},
637      {"abcd", "ab"},
638      {"abcd", "bc"},
639      {"abcd", "cd"},
640      {"abcd", "abcd"},
641    };
642    for (const auto& s : specs) {
643      SCOPED_TRACE(s.haystack);
644      SCOPED_TRACE(s.needle);
645      std::string st = s.haystack;
646      absl::string_view sp = s.haystack;
647      for (size_t i = 0; i <= sp.size(); ++i) {
648        size_t pos = (i == sp.size()) ? absl::string_view::npos : i;
649        SCOPED_TRACE(pos);
650        EXPECT_EQ(sp.find(s.needle, pos),
651                  st.find(s.needle, pos));
652        EXPECT_EQ(sp.rfind(s.needle, pos),
653                  st.rfind(s.needle, pos));
654        EXPECT_EQ(sp.find_first_of(s.needle, pos),
655                  st.find_first_of(s.needle, pos));
656        EXPECT_EQ(sp.find_first_not_of(s.needle, pos),
657                  st.find_first_not_of(s.needle, pos));
658        EXPECT_EQ(sp.find_last_of(s.needle, pos),
659                  st.find_last_of(s.needle, pos));
660        EXPECT_EQ(sp.find_last_not_of(s.needle, pos),
661                  st.find_last_not_of(s.needle, pos));
662      }
663    }
664  }
665  TEST(StringViewTest, Remove) {
666    absl::string_view a("foobar");
667    std::string s1("123");
668    s1 += '\0';
669    s1 += "456";
670    absl::string_view e;
671    std::string s2;
672    absl::string_view c(a);
673    c.remove_prefix(3);
674    EXPECT_EQ(c, "bar");
675    c = a;
676    c.remove_prefix(0);
677    EXPECT_EQ(c, a);
678    c.remove_prefix(c.size());
679    EXPECT_EQ(c, e);
680    c = a;
681    c.remove_suffix(3);
682    EXPECT_EQ(c, "foo");
683    c = a;
684    c.remove_suffix(0);
685    EXPECT_EQ(c, a);
686    c.remove_suffix(c.size());
687    EXPECT_EQ(c, e);
688  }
689  TEST(StringViewTest, Set) {
690    absl::string_view a("foobar");
691    absl::string_view empty;
692    absl::string_view b;
693    b = absl::string_view("foobar", 6);
694    EXPECT_EQ(b, a);
695    b = absl::string_view("foobar", 0);
696    EXPECT_EQ(b, empty);
697    b = absl::string_view("foobar", 7);
698    EXPECT_NE(b, a);
699    b = absl::string_view("foobar");
700    EXPECT_EQ(b, a);
701  }
702  TEST(StringViewTest, FrontBack) {
703    static const char arr[] = "abcd";
704    const absl::string_view csp(arr, 4);
705    EXPECT_EQ(&arr[0], &csp.front());
706    EXPECT_EQ(&arr[3], &csp.back());
707  }
708  TEST(StringViewTest, FrontBackSingleChar) {
709    static const char c = 'a';
710    const absl::string_view csp(&c, 1);
711    EXPECT_EQ(&c, &csp.front());
712    EXPECT_EQ(&c, &csp.back());
713  }
714  TEST(StringViewTest, FrontBackEmpty) {
715  #ifndef ABSL_USES_STD_STRING_VIEW
716  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
717    absl::string_view sv;
718    ABSL_EXPECT_DEATH_IF_SUPPORTED(sv.front(), "");
719    ABSL_EXPECT_DEATH_IF_SUPPORTED(sv.back(), "");
720  #endif
721  #endif
722  }
723  #if !defined(ABSL_USES_STD_STRING_VIEW) ||                    \
724      (!(defined(_GLIBCXX_RELEASE) && _GLIBCXX_RELEASE >= 9) && \
725       !defined(_LIBCPP_VERSION) && !defined(_MSC_VER))
726  #define ABSL_HAVE_STRING_VIEW_FROM_NULLPTR 1
727  #endif
728  TEST(StringViewTest, NULLInput) {
729    absl::string_view s;
730    EXPECT_EQ(s.data(), nullptr);
731    EXPECT_EQ(s.size(), 0u);
732  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
733    s = absl::string_view(nullptr);
734    EXPECT_EQ(s.data(), nullptr);
735    EXPECT_EQ(s.size(), 0u);
736    EXPECT_EQ("", std::string(s));
737  #endif  
738  }
739  TEST(StringViewTest, Comparisons2) {
740    absl::string_view abc("abcdefghijklmnopqrstuvwxyz");
741    EXPECT_EQ(abc, absl::string_view("abcdefghijklmnopqrstuvwxyz"));
742    EXPECT_EQ(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxyz")), 0);
743    EXPECT_LT(abc, absl::string_view("abcdefghijklmnopqrstuvwxzz"));
744    EXPECT_LT(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxzz")), 0);
745    EXPECT_GT(abc, absl::string_view("abcdefghijklmnopqrstuvwxyy"));
746    EXPECT_GT(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxyy")), 0);
747    absl::string_view digits("0123456789");
748    auto npos = absl::string_view::npos;
749    EXPECT_EQ(digits.compare(3, npos, absl::string_view("3456789")), 0);  
750    EXPECT_EQ(digits.compare(3, 4, absl::string_view("3456")), 0);        
751    EXPECT_EQ(digits.compare(10, 0, absl::string_view()), 0);             
752    EXPECT_EQ(digits.compare(3, 4, absl::string_view("0123456789"), 3, 4),
753              0);  
754    EXPECT_LT(digits.compare(3, 4, absl::string_view("0123456789"), 3, 5),
755              0);  
756    EXPECT_LT(digits.compare(0, npos, absl::string_view("0123456789"), 3, 5),
757              0);  
758    EXPECT_EQ(digits.compare(3, 4, "3456"), 0);                 
759    EXPECT_EQ(digits.compare(3, npos, "3456789"), 0);           
760    EXPECT_EQ(digits.compare(10, 0, ""), 0);                    
761    EXPECT_EQ(digits.compare(3, 4, "0123456789", 3, 4), 0);     
762    EXPECT_LT(digits.compare(3, 4, "0123456789", 3, 5), 0);     
763    EXPECT_LT(digits.compare(0, npos, "0123456789", 3, 5), 0);  
764  }
765  TEST(StringViewTest, At) {
766    absl::string_view abc = "abc";
767    EXPECT_EQ(abc.at(0), 'a');
768    EXPECT_EQ(abc.at(1), 'b');
769    EXPECT_EQ(abc.at(2), 'c');
770  #ifdef ABSL_HAVE_EXCEPTIONS
771    EXPECT_THROW((void)abc.at(3), std::out_of_range);
772  #else
773    ABSL_EXPECT_DEATH_IF_SUPPORTED((void)abc.at(3), "absl::string_view::at");
774  #endif
775  }
776  struct MyCharAlloc : std::allocator<char> {};
777  TEST(StringViewTest, ExplicitConversionOperator) {
778    absl::string_view sp = "hi";
779    EXPECT_EQ(sp, std::string(sp));
780  }
781  TEST(StringViewTest, NullSafeStringView) {
782    {
783      absl::string_view s = absl::NullSafeStringView(nullptr);
784      EXPECT_EQ(nullptr, s.data());
785      EXPECT_EQ(0u, s.size());
786      EXPECT_EQ(absl::string_view(), s);
787    }
788    {
789      static const char kHi[] = "hi";
790      absl::string_view s = absl::NullSafeStringView(kHi);
791      EXPECT_EQ(kHi, s.data());
792      EXPECT_EQ(strlen(kHi), s.size());
793      EXPECT_EQ(absl::string_view("hi"), s);
794    }
795  }
796  TEST(StringViewTest, ConstexprNullSafeStringView) {
797    {
798      constexpr absl::string_view s = absl::NullSafeStringView(nullptr);
799      EXPECT_EQ(nullptr, s.data());
800      EXPECT_EQ(0u, s.size());
801      EXPECT_EQ(absl::string_view(), s);
802    }
803  #if !defined(_MSC_VER) || _MSC_VER >= 1910
804    {
805      static constexpr char kHi[] = "hi";
806      absl::string_view s = absl::NullSafeStringView(kHi);
807      EXPECT_EQ(kHi, s.data());
808      EXPECT_EQ(strlen(kHi), s.size());
809      EXPECT_EQ(absl::string_view("hi"), s);
810    }
811    {
812      constexpr absl::string_view s = absl::NullSafeStringView("hello");
813      EXPECT_EQ(s.size(), 5u);
814      EXPECT_EQ("hello", s);
815    }
816  #endif
817  }
818  TEST(StringViewTest, ConstexprCompiles) {
819    constexpr absl::string_view sp;
820  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
821    constexpr absl::string_view cstr(nullptr);
822  #endif
823    constexpr absl::string_view cstr_len("cstr", 4);
824  #if defined(ABSL_USES_STD_STRING_VIEW)
825  #if !defined(__GLIBCXX__)
826  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
827  #endif  
828  #else  
829  #if ABSL_HAVE_BUILTIN(__builtin_strlen) || \
830      (defined(__GNUC__) && !defined(__clang__))
831  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
832  #elif defined(__GNUC__)  
833  #error GCC/clang should have constexpr string_view.
834  #endif
835  #if defined(_MSC_VER) && _MSC_VER >= 1910
836  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
837  #endif
838  #endif  
839  #ifdef ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR
840    constexpr absl::string_view cstr_strlen("foo");
841    EXPECT_EQ(cstr_strlen.length(), 3u);
842    constexpr absl::string_view cstr_strlen2 = "bar";
843    EXPECT_EQ(cstr_strlen2, "bar");
844  #if ABSL_HAVE_BUILTIN(__builtin_memcmp) || \
845      (defined(__GNUC__) && !defined(__clang__))
846  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_COMPARISON 1
847  #endif
848  #ifdef ABSL_HAVE_CONSTEXPR_STRING_VIEW_COMPARISON
849    constexpr absl::string_view foo = "foo";
850    constexpr absl::string_view bar = "bar";
851    constexpr bool foo_eq_bar = foo == bar;
852    constexpr bool foo_ne_bar = foo != bar;
853    constexpr bool foo_lt_bar = foo < bar;
854    constexpr bool foo_le_bar = foo <= bar;
855    constexpr bool foo_gt_bar = foo > bar;
856    constexpr bool foo_ge_bar = foo >= bar;
857    constexpr int foo_compare_bar = foo.compare(bar);
858    EXPECT_FALSE(foo_eq_bar);
859    EXPECT_TRUE(foo_ne_bar);
860    EXPECT_FALSE(foo_lt_bar);
861    EXPECT_FALSE(foo_le_bar);
862    EXPECT_TRUE(foo_gt_bar);
863    EXPECT_TRUE(foo_ge_bar);
864    EXPECT_GT(foo_compare_bar, 0);
865  #endif
866  #endif
867  #if !defined(__clang__) || 3 < __clang_major__ || \
868    (3 == __clang_major__ && 4 < __clang_minor__)
869    constexpr absl::string_view::iterator const_begin_empty = sp.begin();
870    constexpr absl::string_view::iterator const_end_empty = sp.end();
871    EXPECT_EQ(const_begin_empty, const_end_empty);
872  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
873    constexpr absl::string_view::iterator const_begin_nullptr = cstr.begin();
874    constexpr absl::string_view::iterator const_end_nullptr = cstr.end();
875    EXPECT_EQ(const_begin_nullptr, const_end_nullptr);
876  #endif  
877  #endif  
878    constexpr absl::string_view::iterator const_begin = cstr_len.begin();
879    constexpr absl::string_view::iterator const_end = cstr_len.end();
880    constexpr absl::string_view::size_type const_size = cstr_len.size();
881    constexpr absl::string_view::size_type const_length = cstr_len.length();
882    static_assert(const_begin + const_size == const_end,
883                  "pointer arithmetic check");
884    static_assert(const_begin + const_length == const_end,
885                  "pointer arithmetic check");
886  #ifndef _MSC_VER
887    EXPECT_EQ(const_begin + const_size, const_end);
888    EXPECT_EQ(const_begin + const_length, const_end);
889  #endif
890    constexpr bool isempty = sp.empty();
891    EXPECT_TRUE(isempty);
892    constexpr const char c = cstr_len[2];
893    EXPECT_EQ(c, 't');
894    constexpr const char cfront = cstr_len.front();
895    constexpr const char cback = cstr_len.back();
896    EXPECT_EQ(cfront, 'c');
897    EXPECT_EQ(cback, 'r');
898    constexpr const char* np = sp.data();
899    constexpr const char* cstr_ptr = cstr_len.data();
900    EXPECT_EQ(np, nullptr);
901    EXPECT_NE(cstr_ptr, nullptr);
902    constexpr size_t sp_npos = sp.npos;
903    EXPECT_EQ(sp_npos, static_cast<size_t>(-1));
904  }
905  constexpr char ConstexprMethodsHelper() {
906  #if defined(__cplusplus) && __cplusplus >= 201402L
907    absl::string_view str("123", 3);
908    str.remove_prefix(1);
909    str.remove_suffix(1);
910    absl::string_view bar;
911    str.swap(bar);
912    return bar.front();
913  #else
914    return '2';
915  #endif
916  }
917  TEST(StringViewTest, ConstexprMethods) {
918    static_assert(ConstexprMethodsHelper() == '2', "");
919    constexpr absl::string_view foobar("foobar", 6);
920    constexpr absl::string_view foo = foobar.substr(0, 3);
921    constexpr absl::string_view bar = foobar.substr(3);
922    EXPECT_EQ(foo, "foo");
923    EXPECT_EQ(bar, "bar");
924  }
925  TEST(StringViewTest, Noexcept) {
926    EXPECT_TRUE((std::is_nothrow_constructible<absl::string_view,
927                                               const std::string&>::value));
928    EXPECT_TRUE((std::is_nothrow_constructible<absl::string_view,
929                                               const std::string&>::value));
930    EXPECT_TRUE(std::is_nothrow_constructible<absl::string_view>::value);
931    constexpr absl::string_view sp;
932    EXPECT_TRUE(noexcept(sp.begin()));
933    EXPECT_TRUE(noexcept(sp.end()));
934    EXPECT_TRUE(noexcept(sp.cbegin()));
935    EXPECT_TRUE(noexcept(sp.cend()));
936    EXPECT_TRUE(noexcept(sp.rbegin()));
937    EXPECT_TRUE(noexcept(sp.rend()));
938    EXPECT_TRUE(noexcept(sp.crbegin()));
939    EXPECT_TRUE(noexcept(sp.crend()));
940    EXPECT_TRUE(noexcept(sp.size()));
941    EXPECT_TRUE(noexcept(sp.length()));
942    EXPECT_TRUE(noexcept(sp.empty()));
943    EXPECT_TRUE(noexcept(sp.data()));
944    EXPECT_TRUE(noexcept(sp.compare(sp)));
945    EXPECT_TRUE(noexcept(sp.find(sp)));
946    EXPECT_TRUE(noexcept(sp.find('f')));
947    EXPECT_TRUE(noexcept(sp.rfind(sp)));
948    EXPECT_TRUE(noexcept(sp.rfind('f')));
949    EXPECT_TRUE(noexcept(sp.find_first_of(sp)));
950    EXPECT_TRUE(noexcept(sp.find_first_of('f')));
951    EXPECT_TRUE(noexcept(sp.find_last_of(sp)));
<span onclick='openModal()' class='match'>952    EXPECT_TRUE(noexcept(sp.find_last_of('f')));
953    EXPECT_TRUE(noexcept(sp.find_first_not_of(sp)));
954    EXPECT_TRUE(noexcept(sp.find_first_not_of('f')));
955    EXPECT_TRUE(noexcept(sp.find_last_not_of(sp)));
</span>956    EXPECT_TRUE(noexcept(sp.find_last_not_of('f')));
957  }
958  TEST(StringViewTest, BoundsCheck) {
959  #ifndef ABSL_USES_STD_STRING_VIEW
960  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
961    absl::string_view h = "hello";
962    ABSL_EXPECT_DEATH_IF_SUPPORTED(h[5], "");
963    ABSL_EXPECT_DEATH_IF_SUPPORTED(h[static_cast<size_t>(-1)], "");
964  #endif
965  #endif
966  }
967  TEST(ComparisonOpsTest, StringCompareNotAmbiguous) {
968    EXPECT_EQ("hello", std::string("hello"));
969    EXPECT_LT("hello", std::string("world"));
970  }
971  TEST(ComparisonOpsTest, HeterogeneousStringViewEquals) {
972    EXPECT_EQ(absl::string_view("hello"), std::string("hello"));
973    EXPECT_EQ("hello", absl::string_view("hello"));
974  }
975  TEST(FindOneCharTest, EdgeCases) {
976    absl::string_view a("xxyyyxx");
977    a.remove_prefix(1);
978    a.remove_suffix(1);
979    EXPECT_EQ(0u, a.find('x'));
980    EXPECT_EQ(0u, a.find('x', 0));
981    EXPECT_EQ(4u, a.find('x', 1));
982    EXPECT_EQ(4u, a.find('x', 4));
983    EXPECT_EQ(absl::string_view::npos, a.find('x', 5));
984    EXPECT_EQ(4u, a.rfind('x'));
985    EXPECT_EQ(4u, a.rfind('x', 5));
986    EXPECT_EQ(4u, a.rfind('x', 4));
987    EXPECT_EQ(0u, a.rfind('x', 3));
988    EXPECT_EQ(0u, a.rfind('x', 0));
989    a.remove_prefix(1);
990    a.remove_suffix(1);
991    EXPECT_EQ(absl::string_view::npos, a.find('x'));
992    EXPECT_EQ(absl::string_view::npos, a.rfind('x'));
993  }
994  #ifndef ABSL_HAVE_THREAD_SANITIZER  
995  TEST(HugeStringView, TwoPointTwoGB) {
996    if (sizeof(size_t) <= 4)
997      return;
998    const size_t size = size_t{2200} * 1000 * 1000;
999    std::string s(size, 'a');
1000    absl::string_view sp(s);
1001    EXPECT_EQ(size, sp.length());
1002    sp.remove_prefix(1);
1003    EXPECT_EQ(size - 1, sp.length());
1004    sp.remove_suffix(2);
1005    EXPECT_EQ(size - 1 - 2, sp.length());
1006  }
1007  #endif  
1008  #if !defined(NDEBUG) && !defined(ABSL_USES_STD_STRING_VIEW)
1009  TEST(NonNegativeLenTest, NonNegativeLen) {
1010    ABSL_EXPECT_DEATH_IF_SUPPORTED(
1011        absl::string_view("xyz", static_cast<size_t>(-1)), "len <= kMaxSize");
1012  }
1013  TEST(LenExceedsMaxSizeTest, LenExceedsMaxSize) {
1014    auto max_size = absl::string_view().max_size();
1015    absl::string_view ok_view("", max_size);
1016    ABSL_EXPECT_DEATH_IF_SUPPORTED(absl::string_view("", max_size + 1),
1017                                   "len <= kMaxSize");
1018  }
1019  #endif  
1020  class StringViewStreamTest : public ::testing::Test {
1021   public:
1022    template <typename T>
1023    std::string Pad(const T& s, int width, char fill = 0) {
1024      std::ostringstream oss;
1025      if (fill != 0) {
1026        oss << std::setfill(fill);
1027      }
1028      if (width < 0) {
1029        width = -width;
1030        oss << std::right;
1031      }
1032      oss << std::setw(width) << s;
1033      return oss.str();
1034    }
1035  };
1036  TEST_F(StringViewStreamTest, Padding) {
1037    std::string s("hello");
1038    absl::string_view sp(s);
1039    for (int w = -64; w < 64; ++w) {
1040      SCOPED_TRACE(w);
1041      EXPECT_EQ(Pad(s, w), Pad(sp, w));
1042    }
1043    for (int w = -64; w < 64; ++w) {
1044      SCOPED_TRACE(w);
1045      EXPECT_EQ(Pad(s, w, '#'), Pad(sp, w, '#'));
1046    }
1047  }
1048  TEST_F(StringViewStreamTest, ResetsWidth) {
1049    std::string s = "hi";
1050    absl::string_view sp = s;
1051    {
1052      std::ostringstream oss;
1053      oss << "[" << std::setfill('#') << std::setw(5) << s << "]";
1054      ASSERT_EQ("[###hi]", oss.str());
1055    }
1056    {
1057      std::ostringstream oss;
1058      oss << "[" << std::setfill('#') << std::setw(5) << sp << "]";
1059      EXPECT_EQ("[###hi]", oss.str());
1060    }
1061  }
1062  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_test.cc</h3>
            <pre><code>1  #include "absl/strings/string_view.h"
2  #include <stdlib.h>
3  #include <iomanip>
4  #include <iterator>
5  #include <limits>
6  #include <map>
7  #include <sstream>
8  #include <stdexcept>
9  #include <string>
10  #include <type_traits>
11  #include <utility>
12  #include "gtest/gtest.h"
13  #include "absl/base/config.h"
14  #include "absl/base/dynamic_annotations.h"
15  #include "absl/base/options.h"
16  #if defined(ABSL_HAVE_STD_STRING_VIEW) || defined(__ANDROID__)
17  #define ABSL_EXPECT_DEATH_IF_SUPPORTED(statement, regex) \
18    EXPECT_DEATH_IF_SUPPORTED(statement, ".*")
19  #else
20  #define ABSL_EXPECT_DEATH_IF_SUPPORTED(statement, regex) \
21    EXPECT_DEATH_IF_SUPPORTED(statement, regex)
22  #endif
23  namespace {
24  template <typename T>
25  struct Mallocator {
26    typedef T value_type;
27    typedef size_t size_type;
28    typedef ptrdiff_t difference_type;
29    typedef T* pointer;
30    typedef const T* const_pointer;
31    typedef T& reference;
32    typedef const T& const_reference;
33    size_type max_size() const {
34      return size_t(std::numeric_limits<size_type>::max()) / sizeof(value_type);
35    }
36    template <typename U>
37    struct rebind {
38      typedef Mallocator<U> other;
39    };
40    Mallocator() = default;
41    template <class U>
42    Mallocator(const Mallocator<U>&) {}  
43    T* allocate(size_t n) { return static_cast<T*>(std::malloc(n * sizeof(T))); }
44    void deallocate(T* p, size_t) { std::free(p); }
45  };
46  template <typename T, typename U>
47  bool operator==(const Mallocator<T>&, const Mallocator<U>&) {
48    return true;
49  }
50  template <typename T, typename U>
51  bool operator!=(const Mallocator<T>&, const Mallocator<U>&) {
52    return false;
53  }
54  TEST(StringViewTest, Ctor) {
55    {
56      absl::string_view s10;
57      EXPECT_TRUE(s10.data() == nullptr);
58      EXPECT_EQ(0u, s10.length());
59    }
60    {
61      const char* hello = "hello";
62      absl::string_view s20(hello);
63      EXPECT_TRUE(s20.data() == hello);
64      EXPECT_EQ(5u, s20.length());
65      absl::string_view s21(hello, 4);
66      EXPECT_TRUE(s21.data() == hello);
67      EXPECT_EQ(4u, s21.length());
68      absl::string_view s22(hello, 6);
69      EXPECT_TRUE(s22.data() == hello);
70      EXPECT_EQ(6u, s22.length());
71    }
72    {
73      std::string hola = "hola";
74      absl::string_view s30(hola);
75      EXPECT_TRUE(s30.data() == hola.data());
76      EXPECT_EQ(4u, s30.length());
77      hola.push_back('\0');
78      hola.append("h2");
79      hola.push_back('\0');
80      absl::string_view s31(hola);
81      EXPECT_TRUE(s31.data() == hola.data());
82      EXPECT_EQ(8u, s31.length());
83    }
84    {
85      using mstring =
86          std::basic_string<char, std::char_traits<char>, Mallocator<char>>;
87      mstring str1("BUNGIE-JUMPING!");
88      const mstring str2("SLEEPING!");
89      absl::string_view s1(str1);
90      s1.remove_prefix(strlen("BUNGIE-JUM"));
91      absl::string_view s2(str2);
92      s2.remove_prefix(strlen("SLEE"));
93      EXPECT_EQ(s1, s2);
94      EXPECT_EQ(s1, "PING!");
95    }
96  }
97  TEST(StringViewTest, Swap) {
98    absl::string_view a("a");
99    absl::string_view b("bbb");
100    EXPECT_TRUE(noexcept(a.swap(b)));
101    a.swap(b);
102    EXPECT_EQ(a, "bbb");
103    EXPECT_EQ(b, "a");
104    a.swap(b);
105    EXPECT_EQ(a, "a");
106    EXPECT_EQ(b, "bbb");
107  }
108  TEST(StringViewTest, STLComparator) {
109    std::string s1("foo");
110    std::string s2("bar");
111    std::string s3("baz");
112    absl::string_view p1(s1);
113    absl::string_view p2(s2);
114    absl::string_view p3(s3);
115    typedef std::map<absl::string_view, int> TestMap;
116    TestMap map;
117    map.insert(std::make_pair(p1, 0));
118    map.insert(std::make_pair(p2, 1));
119    map.insert(std::make_pair(p3, 2));
120    EXPECT_EQ(map.size(), 3u);
121    TestMap::const_iterator iter = map.begin();
122    EXPECT_EQ(iter->second, 1);
123    ++iter;
124    EXPECT_EQ(iter->second, 2);
125    ++iter;
126    EXPECT_EQ(iter->second, 0);
127    ++iter;
128    EXPECT_TRUE(iter == map.end());
129    TestMap::iterator new_iter = map.find("zot");
130    EXPECT_TRUE(new_iter == map.end());
131    new_iter = map.find("bar");
132    EXPECT_TRUE(new_iter != map.end());
133    map.erase(new_iter);
134    EXPECT_EQ(map.size(), 2u);
135    iter = map.begin();
136    EXPECT_EQ(iter->second, 2);
137    ++iter;
138    EXPECT_EQ(iter->second, 0);
139    ++iter;
140    EXPECT_TRUE(iter == map.end());
141  }
142  #define COMPARE(result, op, x, y)                                      \
143    EXPECT_EQ(result, absl::string_view((x)) op absl::string_view((y))); \
144    EXPECT_EQ(result, absl::string_view((x)).compare(absl::string_view((y))) op 0)
145  TEST(StringViewTest, ComparisonOperators) {
146    COMPARE(true, ==, "",   "");
147    COMPARE(true, ==, "", absl::string_view());
148    COMPARE(true, ==, absl::string_view(), "");
149    COMPARE(true, ==, "a",  "a");
150    COMPARE(true, ==, "aa", "aa");
151    COMPARE(false, ==, "a",  "");
152    COMPARE(false, ==, "",   "a");
153    COMPARE(false, ==, "a",  "b");
154    COMPARE(false, ==, "a",  "aa");
155    COMPARE(false, ==, "aa", "a");
156    COMPARE(false, !=, "",   "");
157    COMPARE(false, !=, "a",  "a");
158    COMPARE(false, !=, "aa", "aa");
159    COMPARE(true, !=, "a",  "");
160    COMPARE(true, !=, "",   "a");
161    COMPARE(true, !=, "a",  "b");
162    COMPARE(true, !=, "a",  "aa");
163    COMPARE(true, !=, "aa", "a");
164    COMPARE(true, <, "a",  "b");
165    COMPARE(true, <, "a",  "aa");
166    COMPARE(true, <, "aa", "b");
167    COMPARE(true, <, "aa", "bb");
168    COMPARE(false, <, "a",  "a");
169    COMPARE(false, <, "b",  "a");
170    COMPARE(false, <, "aa", "a");
171    COMPARE(false, <, "b",  "aa");
172    COMPARE(false, <, "bb", "aa");
173    COMPARE(true, <=, "a",  "a");
174    COMPARE(true, <=, "a",  "b");
175    COMPARE(true, <=, "a",  "aa");
176    COMPARE(true, <=, "aa", "b");
177    COMPARE(true, <=, "aa", "bb");
178    COMPARE(false, <=, "b",  "a");
179    COMPARE(false, <=, "aa", "a");
180    COMPARE(false, <=, "b",  "aa");
181    COMPARE(false, <=, "bb", "aa");
182    COMPARE(false, >=, "a",  "b");
183    COMPARE(false, >=, "a",  "aa");
184    COMPARE(false, >=, "aa", "b");
185    COMPARE(false, >=, "aa", "bb");
186    COMPARE(true, >=, "a",  "a");
187    COMPARE(true, >=, "b",  "a");
188    COMPARE(true, >=, "aa", "a");
189    COMPARE(true, >=, "b",  "aa");
190    COMPARE(true, >=, "bb", "aa");
191    COMPARE(false, >, "a",  "a");
192    COMPARE(false, >, "a",  "b");
193    COMPARE(false, >, "a",  "aa");
194    COMPARE(false, >, "aa", "b");
195    COMPARE(false, >, "aa", "bb");
196    COMPARE(true, >, "b",  "a");
197    COMPARE(true, >, "aa", "a");
198    COMPARE(true, >, "b",  "aa");
199    COMPARE(true, >, "bb", "aa");
200  }
201  TEST(StringViewTest, ComparisonOperatorsByCharacterPosition) {
202    std::string x;
203    for (size_t i = 0; i < 256; i++) {
204      x += 'a';
205      std::string y = x;
206      COMPARE(true, ==, x, y);
207      for (size_t j = 0; j < i; j++) {
208        std::string z = x;
209        z[j] = 'b';       
210        COMPARE(false, ==, x, z);
211        COMPARE(true, <, x, z);
212        COMPARE(true, >, z, x);
213        if (j + 1 < i) {
214          z[j + 1] = 'A';  
215          COMPARE(false, ==, x, z);
216          COMPARE(true, <, x, z);
217          COMPARE(true, >, z, x);
218          z[j + 1] = 'z';  
219          COMPARE(false, ==, x, z);
220          COMPARE(true, <, x, z);
221          COMPARE(true, >, z, x);
222        }
223      }
224    }
225  }
226  #undef COMPARE
227  template <typename T>
228  struct is_type {
229    template <typename U>
230    static bool same(U) {
231      return false;
232    }
233    static bool same(T) { return true; }
234  };
235  TEST(StringViewTest, NposMatchesStdStringView) {
236    EXPECT_EQ(absl::string_view::npos, std::string::npos);
237    EXPECT_TRUE(is_type<size_t>::same(absl::string_view::npos));
238    EXPECT_FALSE(is_type<size_t>::same(""));
239    char test[absl::string_view::npos & 1] = {0};
240    EXPECT_EQ(0, test[0]);
241  }
242  TEST(StringViewTest, STL1) {
243    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
244    const absl::string_view b("abc");
245    const absl::string_view c("xyz");
246    const absl::string_view d("foobar");
247    const absl::string_view e;
248    std::string temp("123");
249    temp += '\0';
250    temp += "456";
251    const absl::string_view f(temp);
252    EXPECT_EQ(a[6], 'g');
253    EXPECT_EQ(b[0], 'a');
254    EXPECT_EQ(c[2], 'z');
255    EXPECT_EQ(f[3], '\0');
256    EXPECT_EQ(f[5], '5');
257    EXPECT_EQ(*d.data(), 'f');
258    EXPECT_EQ(d.data()[5], 'r');
259    EXPECT_TRUE(e.data() == nullptr);
260    EXPECT_EQ(*a.begin(), 'a');
261    EXPECT_EQ(*(b.begin() + 2), 'c');
262    EXPECT_EQ(*(c.end() - 1), 'z');
263    EXPECT_EQ(*a.rbegin(), 'z');
264    EXPECT_EQ(*(b.rbegin() + 2), 'a');
265    EXPECT_EQ(*(c.rend() - 1), 'x');
266    EXPECT_TRUE(a.rbegin() + 26 == a.rend());
267    EXPECT_EQ(a.size(), 26u);
268    EXPECT_EQ(b.size(), 3u);
269    EXPECT_EQ(c.size(), 3u);
270    EXPECT_EQ(d.size(), 6u);
271    EXPECT_EQ(e.size(), 0u);
272    EXPECT_EQ(f.size(), 7u);
273    EXPECT_TRUE(!d.empty());
274    EXPECT_TRUE(d.begin() != d.end());
275    EXPECT_TRUE(d.begin() + 6 == d.end());
276    EXPECT_TRUE(e.empty());
277    EXPECT_TRUE(e.begin() == e.end());
278    char buf[4] = { '%', '%', '%', '%' };
279    EXPECT_EQ(a.copy(buf, 4), 4u);
280    EXPECT_EQ(buf[0], a[0]);
281    EXPECT_EQ(buf[1], a[1]);
282    EXPECT_EQ(buf[2], a[2]);
283    EXPECT_EQ(buf[3], a[3]);
284    EXPECT_EQ(a.copy(buf, 3, 7), 3u);
285    EXPECT_EQ(buf[0], a[7]);
286    EXPECT_EQ(buf[1], a[8]);
287    EXPECT_EQ(buf[2], a[9]);
288    EXPECT_EQ(buf[3], a[3]);
289    EXPECT_EQ(c.copy(buf, 99), 3u);
290    EXPECT_EQ(buf[0], c[0]);
291    EXPECT_EQ(buf[1], c[1]);
292    EXPECT_EQ(buf[2], c[2]);
293    EXPECT_EQ(buf[3], a[3]);
294  #ifdef ABSL_HAVE_EXCEPTIONS
295    EXPECT_THROW(a.copy(buf, 1, 27), std::out_of_range);
296  #else
297    ABSL_EXPECT_DEATH_IF_SUPPORTED(a.copy(buf, 1, 27), "absl::string_view::copy");
298  #endif
299  }
300  TEST(StringViewTest, STL2) {
301    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
302    const absl::string_view b("abc");
303    const absl::string_view c("xyz");
304    absl::string_view d("foobar");
305    const absl::string_view e;
306    const absl::string_view f(
307        "123"
308        "\0"
309        "456",
310        7);
311    d = absl::string_view();
312    EXPECT_EQ(d.size(), 0u);
313    EXPECT_TRUE(d.empty());
314    EXPECT_TRUE(d.data() == nullptr);
315    EXPECT_TRUE(d.begin() == d.end());
316    EXPECT_EQ(a.find(b), 0u);
317    EXPECT_EQ(a.find(b, 1), absl::string_view::npos);
318    EXPECT_EQ(a.find(c), 23u);
319    EXPECT_EQ(a.find(c, 9), 23u);
320    EXPECT_EQ(a.find(c, absl::string_view::npos), absl::string_view::npos);
321    EXPECT_EQ(b.find(c), absl::string_view::npos);
322    EXPECT_EQ(b.find(c, absl::string_view::npos), absl::string_view::npos);
323    EXPECT_EQ(a.find(d), 0u);
324    EXPECT_EQ(a.find(e), 0u);
325    EXPECT_EQ(a.find(d, 12), 12u);
326    EXPECT_EQ(a.find(e, 17), 17u);
327    absl::string_view g("xx not found bb");
328    EXPECT_EQ(a.find(g), absl::string_view::npos);
329    EXPECT_EQ(d.find(b), absl::string_view::npos);
330    EXPECT_EQ(e.find(b), absl::string_view::npos);
331    EXPECT_EQ(d.find(b, 4), absl::string_view::npos);
332    EXPECT_EQ(e.find(b, 7), absl::string_view::npos);
333    size_t empty_search_pos = std::string().find(std::string());
334    EXPECT_EQ(d.find(d), empty_search_pos);
335    EXPECT_EQ(d.find(e), empty_search_pos);
336    EXPECT_EQ(e.find(d), empty_search_pos);
337    EXPECT_EQ(e.find(e), empty_search_pos);
338    EXPECT_EQ(d.find(d, 4), std::string().find(std::string(), 4));
339    EXPECT_EQ(d.find(e, 4), std::string().find(std::string(), 4));
340    EXPECT_EQ(e.find(d, 4), std::string().find(std::string(), 4));
341    EXPECT_EQ(e.find(e, 4), std::string().find(std::string(), 4));
342    EXPECT_EQ(a.find('a'), 0u);
343    EXPECT_EQ(a.find('c'), 2u);
344    EXPECT_EQ(a.find('z'), 25u);
345    EXPECT_EQ(a.find('$'), absl::string_view::npos);
346    EXPECT_EQ(a.find('\0'), absl::string_view::npos);
347    EXPECT_EQ(f.find('\0'), 3u);
348    EXPECT_EQ(f.find('3'), 2u);
349    EXPECT_EQ(f.find('5'), 5u);
350    EXPECT_EQ(g.find('o'), 4u);
351    EXPECT_EQ(g.find('o', 4), 4u);
352    EXPECT_EQ(g.find('o', 5), 8u);
353    EXPECT_EQ(a.find('b', 5), absl::string_view::npos);
354    EXPECT_EQ(d.find('\0'), absl::string_view::npos);
355    EXPECT_EQ(e.find('\0'), absl::string_view::npos);
356    EXPECT_EQ(d.find('\0', 4), absl::string_view::npos);
357    EXPECT_EQ(e.find('\0', 7), absl::string_view::npos);
358    EXPECT_EQ(d.find('x'), absl::string_view::npos);
359    EXPECT_EQ(e.find('x'), absl::string_view::npos);
360    EXPECT_EQ(d.find('x', 4), absl::string_view::npos);
361    EXPECT_EQ(e.find('x', 7), absl::string_view::npos);
362    EXPECT_EQ(a.find(b.data(), 1, 0), 1u);
363    EXPECT_EQ(a.find(c.data(), 9, 0), 9u);
364    EXPECT_EQ(a.find(c.data(), absl::string_view::npos, 0),
365              absl::string_view::npos);
366    EXPECT_EQ(b.find(c.data(), absl::string_view::npos, 0),
367              absl::string_view::npos);
368    EXPECT_EQ(d.find(b.data(), 4, 0), absl::string_view::npos);
369    EXPECT_EQ(e.find(b.data(), 7, 0), absl::string_view::npos);
370    EXPECT_EQ(a.find(b.data(), 1), absl::string_view::npos);
371    EXPECT_EQ(a.find(c.data(), 9), 23u);
372    EXPECT_EQ(a.find(c.data(), absl::string_view::npos), absl::string_view::npos);
373    EXPECT_EQ(b.find(c.data(), absl::string_view::npos), absl::string_view::npos);
374    EXPECT_EQ(d.find(b.data(), 4), absl::string_view::npos);
375    EXPECT_EQ(e.find(b.data(), 7), absl::string_view::npos);
376    EXPECT_EQ(a.rfind(b), 0u);
377    EXPECT_EQ(a.rfind(b, 1), 0u);
378    EXPECT_EQ(a.rfind(c), 23u);
379    EXPECT_EQ(a.rfind(c, 22), absl::string_view::npos);
380    EXPECT_EQ(a.rfind(c, 1), absl::string_view::npos);
381    EXPECT_EQ(a.rfind(c, 0), absl::string_view::npos);
382    EXPECT_EQ(b.rfind(c), absl::string_view::npos);
383    EXPECT_EQ(b.rfind(c, 0), absl::string_view::npos);
384    EXPECT_EQ(a.rfind(d), std::string(a).rfind(std::string()));
385    EXPECT_EQ(a.rfind(e), std::string(a).rfind(std::string()));
386    EXPECT_EQ(a.rfind(d, 12), 12u);
387    EXPECT_EQ(a.rfind(e, 17), 17u);
388    EXPECT_EQ(a.rfind(g), absl::string_view::npos);
389    EXPECT_EQ(d.rfind(b), absl::string_view::npos);
390    EXPECT_EQ(e.rfind(b), absl::string_view::npos);
391    EXPECT_EQ(d.rfind(b, 4), absl::string_view::npos);
392    EXPECT_EQ(e.rfind(b, 7), absl::string_view::npos);
393    EXPECT_EQ(d.rfind(d, 4), std::string().rfind(std::string()));
394    EXPECT_EQ(e.rfind(d, 7), std::string().rfind(std::string()));
395    EXPECT_EQ(d.rfind(e, 4), std::string().rfind(std::string()));
396    EXPECT_EQ(e.rfind(e, 7), std::string().rfind(std::string()));
397    EXPECT_EQ(d.rfind(d), std::string().rfind(std::string()));
398    EXPECT_EQ(e.rfind(d), std::string().rfind(std::string()));
399    EXPECT_EQ(d.rfind(e), std::string().rfind(std::string()));
400    EXPECT_EQ(e.rfind(e), std::string().rfind(std::string()));
401    EXPECT_EQ(g.rfind('o'), 8u);
402    EXPECT_EQ(g.rfind('q'), absl::string_view::npos);
403    EXPECT_EQ(g.rfind('o', 8), 8u);
404    EXPECT_EQ(g.rfind('o', 7), 4u);
405    EXPECT_EQ(g.rfind('o', 3), absl::string_view::npos);
406    EXPECT_EQ(f.rfind('\0'), 3u);
407    EXPECT_EQ(f.rfind('\0', 12), 3u);
408    EXPECT_EQ(f.rfind('3'), 2u);
409    EXPECT_EQ(f.rfind('5'), 5u);
410    EXPECT_EQ(d.rfind('o'), absl::string_view::npos);
411    EXPECT_EQ(e.rfind('o'), absl::string_view::npos);
412    EXPECT_EQ(d.rfind('o', 4), absl::string_view::npos);
413    EXPECT_EQ(e.rfind('o', 7), absl::string_view::npos);
414    EXPECT_EQ(a.rfind(b.data(), 1, 0), 1u);
415    EXPECT_EQ(a.rfind(c.data(), 22, 0), 22u);
416    EXPECT_EQ(a.rfind(c.data(), 1, 0), 1u);
417    EXPECT_EQ(a.rfind(c.data(), 0, 0), 0u);
418    EXPECT_EQ(b.rfind(c.data(), 0, 0), 0u);
419    EXPECT_EQ(d.rfind(b.data(), 4, 0), 0u);
420    EXPECT_EQ(e.rfind(b.data(), 7, 0), 0u);
421  }
422  TEST(StringViewTest, STL2FindFirst) {
423    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
424    const absl::string_view b("abc");
425    const absl::string_view c("xyz");
426    absl::string_view d("foobar");
427    const absl::string_view e;
428    const absl::string_view f(
429        "123"
430        "\0"
431        "456",
432        7);
433    absl::string_view g("xx not found bb");
434    d = absl::string_view();
435    EXPECT_EQ(a.find_first_of(b), 0u);
436    EXPECT_EQ(a.find_first_of(b, 0), 0u);
437    EXPECT_EQ(a.find_first_of(b, 1), 1u);
438    EXPECT_EQ(a.find_first_of(b, 2), 2u);
439    EXPECT_EQ(a.find_first_of(b, 3), absl::string_view::npos);
440    EXPECT_EQ(a.find_first_of(c), 23u);
441    EXPECT_EQ(a.find_first_of(c, 23), 23u);
442    EXPECT_EQ(a.find_first_of(c, 24), 24u);
443    EXPECT_EQ(a.find_first_of(c, 25), 25u);
444    EXPECT_EQ(a.find_first_of(c, 26), absl::string_view::npos);
445    EXPECT_EQ(g.find_first_of(b), 13u);
446    EXPECT_EQ(g.find_first_of(c), 0u);
447    EXPECT_EQ(a.find_first_of(f), absl::string_view::npos);
448    EXPECT_EQ(f.find_first_of(a), absl::string_view::npos);
449    EXPECT_EQ(a.find_first_of(d), absl::string_view::npos);
450    EXPECT_EQ(a.find_first_of(e), absl::string_view::npos);
451    EXPECT_EQ(d.find_first_of(b), absl::string_view::npos);
452    EXPECT_EQ(e.find_first_of(b), absl::string_view::npos);
453    EXPECT_EQ(d.find_first_of(d), absl::string_view::npos);
454    EXPECT_EQ(e.find_first_of(d), absl::string_view::npos);
455    EXPECT_EQ(d.find_first_of(e), absl::string_view::npos);
456    EXPECT_EQ(e.find_first_of(e), absl::string_view::npos);
457    EXPECT_EQ(a.find_first_not_of(b), 3u);
458    EXPECT_EQ(a.find_first_not_of(c), 0u);
459    EXPECT_EQ(b.find_first_not_of(a), absl::string_view::npos);
460    EXPECT_EQ(c.find_first_not_of(a), absl::string_view::npos);
461    EXPECT_EQ(f.find_first_not_of(a), 0u);
462    EXPECT_EQ(a.find_first_not_of(f), 0u);
463    EXPECT_EQ(a.find_first_not_of(d), 0u);
464    EXPECT_EQ(a.find_first_not_of(e), 0u);
465    EXPECT_EQ(a.find_first_not_of(d), 0u);
466    EXPECT_EQ(a.find_first_not_of(e), 0u);
467    EXPECT_EQ(a.find_first_not_of(d, 1), 1u);
468    EXPECT_EQ(a.find_first_not_of(e, 1), 1u);
469    EXPECT_EQ(a.find_first_not_of(d, a.size() - 1), a.size() - 1);
470    EXPECT_EQ(a.find_first_not_of(e, a.size() - 1), a.size() - 1);
471    EXPECT_EQ(a.find_first_not_of(d, a.size()), absl::string_view::npos);
472    EXPECT_EQ(a.find_first_not_of(e, a.size()), absl::string_view::npos);
473    EXPECT_EQ(a.find_first_not_of(d, absl::string_view::npos),
474              absl::string_view::npos);
475    EXPECT_EQ(a.find_first_not_of(e, absl::string_view::npos),
476              absl::string_view::npos);
477    EXPECT_EQ(d.find_first_not_of(a), absl::string_view::npos);
478    EXPECT_EQ(e.find_first_not_of(a), absl::string_view::npos);
479    EXPECT_EQ(d.find_first_not_of(d), absl::string_view::npos);
480    EXPECT_EQ(e.find_first_not_of(d), absl::string_view::npos);
481    EXPECT_EQ(d.find_first_not_of(e), absl::string_view::npos);
482    EXPECT_EQ(e.find_first_not_of(e), absl::string_view::npos);
483    absl::string_view h("====");
484    EXPECT_EQ(h.find_first_not_of('='), absl::string_view::npos);
485    EXPECT_EQ(h.find_first_not_of('=', 3), absl::string_view::npos);
486    EXPECT_EQ(h.find_first_not_of('\0'), 0u);
487    EXPECT_EQ(g.find_first_not_of('x'), 2u);
488    EXPECT_EQ(f.find_first_not_of('\0'), 0u);
489    EXPECT_EQ(f.find_first_not_of('\0', 3), 4u);
490    EXPECT_EQ(f.find_first_not_of('\0', 2), 2u);
491    EXPECT_EQ(d.find_first_not_of('x'), absl::string_view::npos);
492    EXPECT_EQ(e.find_first_not_of('x'), absl::string_view::npos);
493    EXPECT_EQ(d.find_first_not_of('\0'), absl::string_view::npos);
494    EXPECT_EQ(e.find_first_not_of('\0'), absl::string_view::npos);
495  }
496  TEST(StringViewTest, STL2FindLast) {
497    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
498    const absl::string_view b("abc");
499    const absl::string_view c("xyz");
500    absl::string_view d("foobar");
501    const absl::string_view e;
502    const absl::string_view f(
503        "123"
504        "\0"
505        "456",
506        7);
507    absl::string_view g("xx not found bb");
508    absl::string_view h("====");
509    absl::string_view i("56");
510    d = absl::string_view();
511    EXPECT_EQ(h.find_last_of(a), absl::string_view::npos);
512    EXPECT_EQ(g.find_last_of(a), g.size() - 1);
513    EXPECT_EQ(a.find_last_of(b), 2u);
514    EXPECT_EQ(a.find_last_of(c), a.size() - 1);
515    EXPECT_EQ(f.find_last_of(i), 6u);
516    EXPECT_EQ(a.find_last_of('a'), 0u);
517    EXPECT_EQ(a.find_last_of('b'), 1u);
518    EXPECT_EQ(a.find_last_of('z'), 25u);
519    EXPECT_EQ(a.find_last_of('a', 5), 0u);
520    EXPECT_EQ(a.find_last_of('b', 5), 1u);
521    EXPECT_EQ(a.find_last_of('b', 0), absl::string_view::npos);
522    EXPECT_EQ(a.find_last_of('z', 25), 25u);
523    EXPECT_EQ(a.find_last_of('z', 24), absl::string_view::npos);
524    EXPECT_EQ(f.find_last_of(i, 5), 5u);
525    EXPECT_EQ(f.find_last_of(i, 6), 6u);
526    EXPECT_EQ(f.find_last_of(a, 4), absl::string_view::npos);
527    EXPECT_EQ(f.find_last_of(d), absl::string_view::npos);
528    EXPECT_EQ(f.find_last_of(e), absl::string_view::npos);
529    EXPECT_EQ(f.find_last_of(d, 4), absl::string_view::npos);
530    EXPECT_EQ(f.find_last_of(e, 4), absl::string_view::npos);
531    EXPECT_EQ(d.find_last_of(d), absl::string_view::npos);
532    EXPECT_EQ(d.find_last_of(e), absl::string_view::npos);
533    EXPECT_EQ(e.find_last_of(d), absl::string_view::npos);
534    EXPECT_EQ(e.find_last_of(e), absl::string_view::npos);
535    EXPECT_EQ(d.find_last_of(f), absl::string_view::npos);
536    EXPECT_EQ(e.find_last_of(f), absl::string_view::npos);
537    EXPECT_EQ(d.find_last_of(d, 4), absl::string_view::npos);
538    EXPECT_EQ(d.find_last_of(e, 4), absl::string_view::npos);
539    EXPECT_EQ(e.find_last_of(d, 4), absl::string_view::npos);
540    EXPECT_EQ(e.find_last_of(e, 4), absl::string_view::npos);
541    EXPECT_EQ(d.find_last_of(f, 4), absl::string_view::npos);
542    EXPECT_EQ(e.find_last_of(f, 4), absl::string_view::npos);
543    EXPECT_EQ(a.find_last_not_of(b), a.size() - 1);
544    EXPECT_EQ(a.find_last_not_of(c), 22u);
545    EXPECT_EQ(b.find_last_not_of(a), absl::string_view::npos);
546    EXPECT_EQ(b.find_last_not_of(b), absl::string_view::npos);
547    EXPECT_EQ(f.find_last_not_of(i), 4u);
548    EXPECT_EQ(a.find_last_not_of(c, 24), 22u);
549    EXPECT_EQ(a.find_last_not_of(b, 3), 3u);
550    EXPECT_EQ(a.find_last_not_of(b, 2), absl::string_view::npos);
551    EXPECT_EQ(f.find_last_not_of(d), f.size() - 1);
552    EXPECT_EQ(f.find_last_not_of(e), f.size() - 1);
553    EXPECT_EQ(f.find_last_not_of(d, 4), 4u);
554    EXPECT_EQ(f.find_last_not_of(e, 4), 4u);
555    EXPECT_EQ(d.find_last_not_of(d), absl::string_view::npos);
556    EXPECT_EQ(d.find_last_not_of(e), absl::string_view::npos);
557    EXPECT_EQ(e.find_last_not_of(d), absl::string_view::npos);
558    EXPECT_EQ(e.find_last_not_of(e), absl::string_view::npos);
559    EXPECT_EQ(d.find_last_not_of(f), absl::string_view::npos);
560    EXPECT_EQ(e.find_last_not_of(f), absl::string_view::npos);
561    EXPECT_EQ(d.find_last_not_of(d, 4), absl::string_view::npos);
562    EXPECT_EQ(d.find_last_not_of(e, 4), absl::string_view::npos);
563    EXPECT_EQ(e.find_last_not_of(d, 4), absl::string_view::npos);
564    EXPECT_EQ(e.find_last_not_of(e, 4), absl::string_view::npos);
565    EXPECT_EQ(d.find_last_not_of(f, 4), absl::string_view::npos);
566    EXPECT_EQ(e.find_last_not_of(f, 4), absl::string_view::npos);
567    EXPECT_EQ(h.find_last_not_of('x'), h.size() - 1);
568    EXPECT_EQ(h.find_last_not_of('='), absl::string_view::npos);
569    EXPECT_EQ(b.find_last_not_of('c'), 1u);
570    EXPECT_EQ(h.find_last_not_of('x', 2), 2u);
571    EXPECT_EQ(h.find_last_not_of('=', 2), absl::string_view::npos);
572    EXPECT_EQ(b.find_last_not_of('b', 1), 0u);
573    EXPECT_EQ(d.find_last_not_of('x'), absl::string_view::npos);
574    EXPECT_EQ(e.find_last_not_of('x'), absl::string_view::npos);
575    EXPECT_EQ(d.find_last_not_of('\0'), absl::string_view::npos);
576    EXPECT_EQ(e.find_last_not_of('\0'), absl::string_view::npos);
577  }
578  TEST(StringViewTest, STL2Substr) {
579    const absl::string_view a("abcdefghijklmnopqrstuvwxyz");
580    const absl::string_view b("abc");
581    const absl::string_view c("xyz");
582    absl::string_view d("foobar");
583    const absl::string_view e;
584    d = absl::string_view();
585    EXPECT_EQ(a.substr(0, 3), b);
586    EXPECT_EQ(a.substr(23), c);
587    EXPECT_EQ(a.substr(23, 3), c);
588    EXPECT_EQ(a.substr(23, 99), c);
589    EXPECT_EQ(a.substr(0), a);
590    EXPECT_EQ(a.substr(), a);
591    EXPECT_EQ(a.substr(3, 2), "de");
592    EXPECT_EQ(d.substr(0, 99), e);
593    EXPECT_EQ(a.substr(0, absl::string_view::npos), a);
594    EXPECT_EQ(a.substr(23, absl::string_view::npos), c);
595  #ifdef ABSL_HAVE_EXCEPTIONS
596    EXPECT_THROW((void)a.substr(99, 2), std::out_of_range);
597  #else
598    ABSL_EXPECT_DEATH_IF_SUPPORTED((void)a.substr(99, 2),
599                                   "absl::string_view::substr");
600  #endif
601  }
602  TEST(StringViewTest, TruncSubstr) {
603    const absl::string_view hi("hi");
604    EXPECT_EQ("", absl::ClippedSubstr(hi, 0, 0));
605    EXPECT_EQ("h", absl::ClippedSubstr(hi, 0, 1));
606    EXPECT_EQ("hi", absl::ClippedSubstr(hi, 0));
607    EXPECT_EQ("i", absl::ClippedSubstr(hi, 1));
608    EXPECT_EQ("", absl::ClippedSubstr(hi, 2));
609    EXPECT_EQ("", absl::ClippedSubstr(hi, 3));  
610    EXPECT_EQ("", absl::ClippedSubstr(hi, 3, 2));  
611  }
612  TEST(StringViewTest, UTF8) {
613    std::string utf8 = "\u00E1";
614    std::string utf8_twice = utf8 + " " + utf8;
615    size_t utf8_len = strlen(utf8.data());
616    EXPECT_EQ(utf8_len, absl::string_view(utf8_twice).find_first_of(" "));
617    EXPECT_EQ(utf8_len, absl::string_view(utf8_twice).find_first_of(" \t"));
618  }
619  TEST(StringViewTest, FindConformance) {
620    struct {
621      std::string haystack;
622      std::string needle;
623    } specs[] = {
624      {"", ""},
625      {"", "a"},
626      {"a", ""},
627      {"a", "a"},
628      {"a", "b"},
629      {"aa", ""},
630      {"aa", "a"},
631      {"aa", "b"},
632      {"ab", "a"},
633      {"ab", "b"},
634      {"abcd", ""},
635      {"abcd", "a"},
636      {"abcd", "d"},
637      {"abcd", "ab"},
638      {"abcd", "bc"},
639      {"abcd", "cd"},
640      {"abcd", "abcd"},
641    };
642    for (const auto& s : specs) {
643      SCOPED_TRACE(s.haystack);
644      SCOPED_TRACE(s.needle);
645      std::string st = s.haystack;
646      absl::string_view sp = s.haystack;
647      for (size_t i = 0; i <= sp.size(); ++i) {
648        size_t pos = (i == sp.size()) ? absl::string_view::npos : i;
649        SCOPED_TRACE(pos);
650        EXPECT_EQ(sp.find(s.needle, pos),
651                  st.find(s.needle, pos));
652        EXPECT_EQ(sp.rfind(s.needle, pos),
653                  st.rfind(s.needle, pos));
654        EXPECT_EQ(sp.find_first_of(s.needle, pos),
655                  st.find_first_of(s.needle, pos));
656        EXPECT_EQ(sp.find_first_not_of(s.needle, pos),
657                  st.find_first_not_of(s.needle, pos));
658        EXPECT_EQ(sp.find_last_of(s.needle, pos),
659                  st.find_last_of(s.needle, pos));
660        EXPECT_EQ(sp.find_last_not_of(s.needle, pos),
661                  st.find_last_not_of(s.needle, pos));
662      }
663    }
664  }
665  TEST(StringViewTest, Remove) {
666    absl::string_view a("foobar");
667    std::string s1("123");
668    s1 += '\0';
669    s1 += "456";
670    absl::string_view e;
671    std::string s2;
672    absl::string_view c(a);
673    c.remove_prefix(3);
674    EXPECT_EQ(c, "bar");
675    c = a;
676    c.remove_prefix(0);
677    EXPECT_EQ(c, a);
678    c.remove_prefix(c.size());
679    EXPECT_EQ(c, e);
680    c = a;
681    c.remove_suffix(3);
682    EXPECT_EQ(c, "foo");
683    c = a;
684    c.remove_suffix(0);
685    EXPECT_EQ(c, a);
686    c.remove_suffix(c.size());
687    EXPECT_EQ(c, e);
688  }
689  TEST(StringViewTest, Set) {
690    absl::string_view a("foobar");
691    absl::string_view empty;
692    absl::string_view b;
693    b = absl::string_view("foobar", 6);
694    EXPECT_EQ(b, a);
695    b = absl::string_view("foobar", 0);
696    EXPECT_EQ(b, empty);
697    b = absl::string_view("foobar", 7);
698    EXPECT_NE(b, a);
699    b = absl::string_view("foobar");
700    EXPECT_EQ(b, a);
701  }
702  TEST(StringViewTest, FrontBack) {
703    static const char arr[] = "abcd";
704    const absl::string_view csp(arr, 4);
705    EXPECT_EQ(&arr[0], &csp.front());
706    EXPECT_EQ(&arr[3], &csp.back());
707  }
708  TEST(StringViewTest, FrontBackSingleChar) {
709    static const char c = 'a';
710    const absl::string_view csp(&c, 1);
711    EXPECT_EQ(&c, &csp.front());
712    EXPECT_EQ(&c, &csp.back());
713  }
714  TEST(StringViewTest, FrontBackEmpty) {
715  #ifndef ABSL_USES_STD_STRING_VIEW
716  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
717    absl::string_view sv;
718    ABSL_EXPECT_DEATH_IF_SUPPORTED(sv.front(), "");
719    ABSL_EXPECT_DEATH_IF_SUPPORTED(sv.back(), "");
720  #endif
721  #endif
722  }
723  #if !defined(ABSL_USES_STD_STRING_VIEW) ||                    \
724      (!(defined(_GLIBCXX_RELEASE) && _GLIBCXX_RELEASE >= 9) && \
725       !defined(_LIBCPP_VERSION) && !defined(_MSC_VER))
726  #define ABSL_HAVE_STRING_VIEW_FROM_NULLPTR 1
727  #endif
728  TEST(StringViewTest, NULLInput) {
729    absl::string_view s;
730    EXPECT_EQ(s.data(), nullptr);
731    EXPECT_EQ(s.size(), 0u);
732  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
733    s = absl::string_view(nullptr);
734    EXPECT_EQ(s.data(), nullptr);
735    EXPECT_EQ(s.size(), 0u);
736    EXPECT_EQ("", std::string(s));
737  #endif  
738  }
739  TEST(StringViewTest, Comparisons2) {
740    absl::string_view abc("abcdefghijklmnopqrstuvwxyz");
741    EXPECT_EQ(abc, absl::string_view("abcdefghijklmnopqrstuvwxyz"));
742    EXPECT_EQ(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxyz")), 0);
743    EXPECT_LT(abc, absl::string_view("abcdefghijklmnopqrstuvwxzz"));
744    EXPECT_LT(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxzz")), 0);
745    EXPECT_GT(abc, absl::string_view("abcdefghijklmnopqrstuvwxyy"));
746    EXPECT_GT(abc.compare(absl::string_view("abcdefghijklmnopqrstuvwxyy")), 0);
747    absl::string_view digits("0123456789");
748    auto npos = absl::string_view::npos;
749    EXPECT_EQ(digits.compare(3, npos, absl::string_view("3456789")), 0);  
750    EXPECT_EQ(digits.compare(3, 4, absl::string_view("3456")), 0);        
751    EXPECT_EQ(digits.compare(10, 0, absl::string_view()), 0);             
752    EXPECT_EQ(digits.compare(3, 4, absl::string_view("0123456789"), 3, 4),
753              0);  
754    EXPECT_LT(digits.compare(3, 4, absl::string_view("0123456789"), 3, 5),
755              0);  
756    EXPECT_LT(digits.compare(0, npos, absl::string_view("0123456789"), 3, 5),
757              0);  
758    EXPECT_EQ(digits.compare(3, 4, "3456"), 0);                 
759    EXPECT_EQ(digits.compare(3, npos, "3456789"), 0);           
760    EXPECT_EQ(digits.compare(10, 0, ""), 0);                    
761    EXPECT_EQ(digits.compare(3, 4, "0123456789", 3, 4), 0);     
762    EXPECT_LT(digits.compare(3, 4, "0123456789", 3, 5), 0);     
763    EXPECT_LT(digits.compare(0, npos, "0123456789", 3, 5), 0);  
764  }
765  TEST(StringViewTest, At) {
766    absl::string_view abc = "abc";
767    EXPECT_EQ(abc.at(0), 'a');
768    EXPECT_EQ(abc.at(1), 'b');
769    EXPECT_EQ(abc.at(2), 'c');
770  #ifdef ABSL_HAVE_EXCEPTIONS
771    EXPECT_THROW((void)abc.at(3), std::out_of_range);
772  #else
773    ABSL_EXPECT_DEATH_IF_SUPPORTED((void)abc.at(3), "absl::string_view::at");
774  #endif
775  }
776  struct MyCharAlloc : std::allocator<char> {};
777  TEST(StringViewTest, ExplicitConversionOperator) {
778    absl::string_view sp = "hi";
779    EXPECT_EQ(sp, std::string(sp));
780  }
781  TEST(StringViewTest, NullSafeStringView) {
782    {
783      absl::string_view s = absl::NullSafeStringView(nullptr);
784      EXPECT_EQ(nullptr, s.data());
785      EXPECT_EQ(0u, s.size());
786      EXPECT_EQ(absl::string_view(), s);
787    }
788    {
789      static const char kHi[] = "hi";
790      absl::string_view s = absl::NullSafeStringView(kHi);
791      EXPECT_EQ(kHi, s.data());
792      EXPECT_EQ(strlen(kHi), s.size());
793      EXPECT_EQ(absl::string_view("hi"), s);
794    }
795  }
796  TEST(StringViewTest, ConstexprNullSafeStringView) {
797    {
798      constexpr absl::string_view s = absl::NullSafeStringView(nullptr);
799      EXPECT_EQ(nullptr, s.data());
800      EXPECT_EQ(0u, s.size());
801      EXPECT_EQ(absl::string_view(), s);
802    }
803  #if !defined(_MSC_VER) || _MSC_VER >= 1910
804    {
805      static constexpr char kHi[] = "hi";
806      absl::string_view s = absl::NullSafeStringView(kHi);
807      EXPECT_EQ(kHi, s.data());
808      EXPECT_EQ(strlen(kHi), s.size());
809      EXPECT_EQ(absl::string_view("hi"), s);
810    }
811    {
812      constexpr absl::string_view s = absl::NullSafeStringView("hello");
813      EXPECT_EQ(s.size(), 5u);
814      EXPECT_EQ("hello", s);
815    }
816  #endif
817  }
818  TEST(StringViewTest, ConstexprCompiles) {
819    constexpr absl::string_view sp;
820  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
821    constexpr absl::string_view cstr(nullptr);
822  #endif
823    constexpr absl::string_view cstr_len("cstr", 4);
824  #if defined(ABSL_USES_STD_STRING_VIEW)
825  #if !defined(__GLIBCXX__)
826  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
827  #endif  
828  #else  
829  #if ABSL_HAVE_BUILTIN(__builtin_strlen) || \
830      (defined(__GNUC__) && !defined(__clang__))
831  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
832  #elif defined(__GNUC__)  
833  #error GCC/clang should have constexpr string_view.
834  #endif
835  #if defined(_MSC_VER) && _MSC_VER >= 1910
836  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR 1
837  #endif
838  #endif  
839  #ifdef ABSL_HAVE_CONSTEXPR_STRING_VIEW_FROM_CSTR
840    constexpr absl::string_view cstr_strlen("foo");
841    EXPECT_EQ(cstr_strlen.length(), 3u);
842    constexpr absl::string_view cstr_strlen2 = "bar";
843    EXPECT_EQ(cstr_strlen2, "bar");
844  #if ABSL_HAVE_BUILTIN(__builtin_memcmp) || \
845      (defined(__GNUC__) && !defined(__clang__))
846  #define ABSL_HAVE_CONSTEXPR_STRING_VIEW_COMPARISON 1
847  #endif
848  #ifdef ABSL_HAVE_CONSTEXPR_STRING_VIEW_COMPARISON
849    constexpr absl::string_view foo = "foo";
850    constexpr absl::string_view bar = "bar";
851    constexpr bool foo_eq_bar = foo == bar;
852    constexpr bool foo_ne_bar = foo != bar;
853    constexpr bool foo_lt_bar = foo < bar;
854    constexpr bool foo_le_bar = foo <= bar;
855    constexpr bool foo_gt_bar = foo > bar;
856    constexpr bool foo_ge_bar = foo >= bar;
857    constexpr int foo_compare_bar = foo.compare(bar);
858    EXPECT_FALSE(foo_eq_bar);
859    EXPECT_TRUE(foo_ne_bar);
860    EXPECT_FALSE(foo_lt_bar);
861    EXPECT_FALSE(foo_le_bar);
862    EXPECT_TRUE(foo_gt_bar);
863    EXPECT_TRUE(foo_ge_bar);
864    EXPECT_GT(foo_compare_bar, 0);
865  #endif
866  #endif
867  #if !defined(__clang__) || 3 < __clang_major__ || \
868    (3 == __clang_major__ && 4 < __clang_minor__)
869    constexpr absl::string_view::iterator const_begin_empty = sp.begin();
870    constexpr absl::string_view::iterator const_end_empty = sp.end();
871    EXPECT_EQ(const_begin_empty, const_end_empty);
872  #ifdef ABSL_HAVE_STRING_VIEW_FROM_NULLPTR
873    constexpr absl::string_view::iterator const_begin_nullptr = cstr.begin();
874    constexpr absl::string_view::iterator const_end_nullptr = cstr.end();
875    EXPECT_EQ(const_begin_nullptr, const_end_nullptr);
876  #endif  
877  #endif  
878    constexpr absl::string_view::iterator const_begin = cstr_len.begin();
879    constexpr absl::string_view::iterator const_end = cstr_len.end();
880    constexpr absl::string_view::size_type const_size = cstr_len.size();
881    constexpr absl::string_view::size_type const_length = cstr_len.length();
882    static_assert(const_begin + const_size == const_end,
883                  "pointer arithmetic check");
884    static_assert(const_begin + const_length == const_end,
885                  "pointer arithmetic check");
886  #ifndef _MSC_VER
887    EXPECT_EQ(const_begin + const_size, const_end);
888    EXPECT_EQ(const_begin + const_length, const_end);
889  #endif
890    constexpr bool isempty = sp.empty();
891    EXPECT_TRUE(isempty);
892    constexpr const char c = cstr_len[2];
893    EXPECT_EQ(c, 't');
894    constexpr const char cfront = cstr_len.front();
895    constexpr const char cback = cstr_len.back();
896    EXPECT_EQ(cfront, 'c');
897    EXPECT_EQ(cback, 'r');
898    constexpr const char* np = sp.data();
899    constexpr const char* cstr_ptr = cstr_len.data();
900    EXPECT_EQ(np, nullptr);
901    EXPECT_NE(cstr_ptr, nullptr);
902    constexpr size_t sp_npos = sp.npos;
903    EXPECT_EQ(sp_npos, static_cast<size_t>(-1));
904  }
905  constexpr char ConstexprMethodsHelper() {
906  #if defined(__cplusplus) && __cplusplus >= 201402L
907    absl::string_view str("123", 3);
908    str.remove_prefix(1);
909    str.remove_suffix(1);
910    absl::string_view bar;
911    str.swap(bar);
912    return bar.front();
913  #else
914    return '2';
915  #endif
916  }
917  TEST(StringViewTest, ConstexprMethods) {
918    static_assert(ConstexprMethodsHelper() == '2', "");
919    constexpr absl::string_view foobar("foobar", 6);
920    constexpr absl::string_view foo = foobar.substr(0, 3);
921    constexpr absl::string_view bar = foobar.substr(3);
922    EXPECT_EQ(foo, "foo");
923    EXPECT_EQ(bar, "bar");
924  }
925  TEST(StringViewTest, Noexcept) {
926    EXPECT_TRUE((std::is_nothrow_constructible<absl::string_view,
927                                               const std::string&>::value));
928    EXPECT_TRUE((std::is_nothrow_constructible<absl::string_view,
929                                               const std::string&>::value));
930    EXPECT_TRUE(std::is_nothrow_constructible<absl::string_view>::value);
931    constexpr absl::string_view sp;
932    EXPECT_TRUE(noexcept(sp.begin()));
933    EXPECT_TRUE(noexcept(sp.end()));
934    EXPECT_TRUE(noexcept(sp.cbegin()));
935    EXPECT_TRUE(noexcept(sp.cend()));
936    EXPECT_TRUE(noexcept(sp.rbegin()));
937    EXPECT_TRUE(noexcept(sp.rend()));
938    EXPECT_TRUE(noexcept(sp.crbegin()));
939    EXPECT_TRUE(noexcept(sp.crend()));
940    EXPECT_TRUE(noexcept(sp.size()));
941    EXPECT_TRUE(noexcept(sp.length()));
942    EXPECT_TRUE(noexcept(sp.empty()));
943    EXPECT_TRUE(noexcept(sp.data()));
944    EXPECT_TRUE(noexcept(sp.compare(sp)));
945    EXPECT_TRUE(noexcept(sp.find(sp)));
946    EXPECT_TRUE(noexcept(sp.find('f')));
947    EXPECT_TRUE(noexcept(sp.rfind(sp)));
948    EXPECT_TRUE(noexcept(sp.rfind('f')));
949    EXPECT_TRUE(noexcept(sp.find_first_of(sp)));
<span onclick='openModal()' class='match'>950    EXPECT_TRUE(noexcept(sp.find_first_of('f')));
951    EXPECT_TRUE(noexcept(sp.find_last_of(sp)));
952    EXPECT_TRUE(noexcept(sp.find_last_of('f')));
953    EXPECT_TRUE(noexcept(sp.find_first_not_of(sp)));
</span>954    EXPECT_TRUE(noexcept(sp.find_first_not_of('f')));
955    EXPECT_TRUE(noexcept(sp.find_last_not_of(sp)));
956    EXPECT_TRUE(noexcept(sp.find_last_not_of('f')));
957  }
958  TEST(StringViewTest, BoundsCheck) {
959  #ifndef ABSL_USES_STD_STRING_VIEW
960  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
961    absl::string_view h = "hello";
962    ABSL_EXPECT_DEATH_IF_SUPPORTED(h[5], "");
963    ABSL_EXPECT_DEATH_IF_SUPPORTED(h[static_cast<size_t>(-1)], "");
964  #endif
965  #endif
966  }
967  TEST(ComparisonOpsTest, StringCompareNotAmbiguous) {
968    EXPECT_EQ("hello", std::string("hello"));
969    EXPECT_LT("hello", std::string("world"));
970  }
971  TEST(ComparisonOpsTest, HeterogeneousStringViewEquals) {
972    EXPECT_EQ(absl::string_view("hello"), std::string("hello"));
973    EXPECT_EQ("hello", absl::string_view("hello"));
974  }
975  TEST(FindOneCharTest, EdgeCases) {
976    absl::string_view a("xxyyyxx");
977    a.remove_prefix(1);
978    a.remove_suffix(1);
979    EXPECT_EQ(0u, a.find('x'));
980    EXPECT_EQ(0u, a.find('x', 0));
981    EXPECT_EQ(4u, a.find('x', 1));
982    EXPECT_EQ(4u, a.find('x', 4));
983    EXPECT_EQ(absl::string_view::npos, a.find('x', 5));
984    EXPECT_EQ(4u, a.rfind('x'));
985    EXPECT_EQ(4u, a.rfind('x', 5));
986    EXPECT_EQ(4u, a.rfind('x', 4));
987    EXPECT_EQ(0u, a.rfind('x', 3));
988    EXPECT_EQ(0u, a.rfind('x', 0));
989    a.remove_prefix(1);
990    a.remove_suffix(1);
991    EXPECT_EQ(absl::string_view::npos, a.find('x'));
992    EXPECT_EQ(absl::string_view::npos, a.rfind('x'));
993  }
994  #ifndef ABSL_HAVE_THREAD_SANITIZER  
995  TEST(HugeStringView, TwoPointTwoGB) {
996    if (sizeof(size_t) <= 4)
997      return;
998    const size_t size = size_t{2200} * 1000 * 1000;
999    std::string s(size, 'a');
1000    absl::string_view sp(s);
1001    EXPECT_EQ(size, sp.length());
1002    sp.remove_prefix(1);
1003    EXPECT_EQ(size - 1, sp.length());
1004    sp.remove_suffix(2);
1005    EXPECT_EQ(size - 1 - 2, sp.length());
1006  }
1007  #endif  
1008  #if !defined(NDEBUG) && !defined(ABSL_USES_STD_STRING_VIEW)
1009  TEST(NonNegativeLenTest, NonNegativeLen) {
1010    ABSL_EXPECT_DEATH_IF_SUPPORTED(
1011        absl::string_view("xyz", static_cast<size_t>(-1)), "len <= kMaxSize");
1012  }
1013  TEST(LenExceedsMaxSizeTest, LenExceedsMaxSize) {
1014    auto max_size = absl::string_view().max_size();
1015    absl::string_view ok_view("", max_size);
1016    ABSL_EXPECT_DEATH_IF_SUPPORTED(absl::string_view("", max_size + 1),
1017                                   "len <= kMaxSize");
1018  }
1019  #endif  
1020  class StringViewStreamTest : public ::testing::Test {
1021   public:
1022    template <typename T>
1023    std::string Pad(const T& s, int width, char fill = 0) {
1024      std::ostringstream oss;
1025      if (fill != 0) {
1026        oss << std::setfill(fill);
1027      }
1028      if (width < 0) {
1029        width = -width;
1030        oss << std::right;
1031      }
1032      oss << std::setw(width) << s;
1033      return oss.str();
1034    }
1035  };
1036  TEST_F(StringViewStreamTest, Padding) {
1037    std::string s("hello");
1038    absl::string_view sp(s);
1039    for (int w = -64; w < 64; ++w) {
1040      SCOPED_TRACE(w);
1041      EXPECT_EQ(Pad(s, w), Pad(sp, w));
1042    }
1043    for (int w = -64; w < 64; ++w) {
1044      SCOPED_TRACE(w);
1045      EXPECT_EQ(Pad(s, w, '#'), Pad(sp, w, '#'));
1046    }
1047  }
1048  TEST_F(StringViewStreamTest, ResetsWidth) {
1049    std::string s = "hi";
1050    absl::string_view sp = s;
1051    {
1052      std::ostringstream oss;
1053      oss << "[" << std::setfill('#') << std::setw(5) << s << "]";
1054      ASSERT_EQ("[###hi]", oss.str());
1055    }
1056    {
1057      std::ostringstream oss;
1058      oss << "[" << std::setfill('#') << std::setw(5) << sp << "]";
1059      EXPECT_EQ("[###hi]", oss.str());
1060    }
1061  }
1062  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-string_view_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>952    EXPECT_TRUE(noexcept(sp.find_last_of('f')));
953    EXPECT_TRUE(noexcept(sp.find_first_not_of(sp)));
954    EXPECT_TRUE(noexcept(sp.find_first_not_of('f')));
955    EXPECT_TRUE(noexcept(sp.find_last_not_of(sp)));
</pre></code></div>
                <div class="column column_space"><pre><code>950    EXPECT_TRUE(noexcept(sp.find_first_of('f')));
951    EXPECT_TRUE(noexcept(sp.find_last_of(sp)));
952    EXPECT_TRUE(noexcept(sp.find_last_of('f')));
953    EXPECT_TRUE(noexcept(sp.find_first_not_of(sp)));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    