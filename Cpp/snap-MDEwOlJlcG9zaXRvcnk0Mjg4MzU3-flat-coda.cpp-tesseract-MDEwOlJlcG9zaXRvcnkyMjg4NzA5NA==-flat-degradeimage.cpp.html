
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.0%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-coda.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmfast.h"
3  #include "agmdirected.h"
4  #include "agm.h"
5  #ifdef USE_OPENMP
6  #include <omp.h>
7  #endif
8  int main(int argc, char* argv[]) {
9    Env = TEnv(argc, argv, TNotify::StdNotify);
10    Env.PrepArgs(TStr::Fmt("ragm. build: %s, %s. Time: %s", __TIME__, __DATE__, TExeTm::GetCurTm()));
11    TExeTm ExeTm;
12    Try
13    TStr OutFPrx = Env.GetIfArgPrefixStr("-o:", "", "Output Graph data prefix");
14    const TStr InFNm = Env.GetIfArgPrefixStr("-i:", "../as20graph.txt", "Input edgelist file name");
15    const TStr LabelFNm = Env.GetIfArgPrefixStr("-l:", "", "Input file name for node names (Node ID, Node label) ");
16    const int IsUndirected = Env.GetIfArgPrefixInt("-g:", 0, "Input graph type. 0:directed, 1:undirected");
17    int OptComs = Env.GetIfArgPrefixInt("-c:", 100, "The number of communities to detect (-1: detect automatically)");
18    const int MinComs = Env.GetIfArgPrefixInt("-mc:", 5, "Minimum number of communities to try");
19    const int MaxComs = Env.GetIfArgPrefixInt("-xc:", 100, "Maximum number of communities to try");
20    const int DivComs = Env.GetIfArgPrefixInt("-nc:", 10, "How many trials for the number of communities");
21    const int NumThreads = Env.GetIfArgPrefixInt("-nt:", 4, "Number of threads for parallelization");
22    const double StepAlpha = Env.GetIfArgPrefixFlt("-sa:", 0.05, "Alpha for backtracking line search");
23    const double StepBeta = Env.GetIfArgPrefixFlt("-sb:", 0.3, "Beta for backtracking line search");
24  #ifdef USE_OPENMP
25    omp_set_num_threads(NumThreads);
26  #endif
27    PNGraph G;
28    TIntStrH NIDNameH;
29    if (IsUndirected == 1) {
30      PUNGraph UG;
<span onclick='openModal()' class='match'>31      if (InFNm.IsSuffix(".ungraph")) {
32        TFIn GFIn(InFNm);
33        UG = TUNGraph::Load(GFIn);
34      } else {
35        UG = TAGMUtil::LoadEdgeListStr<PUNGraph>(InFNm, NIDNameH);
36      }
37      G = TSnap::ConvertGraph<PNGraph, PUNGraph>(UG);
38    } else {
</span>39      if (InFNm.IsSuffix(".ngraph")) {
40        TFIn GFIn(InFNm);
41        G = TNGraph::Load(GFIn);
42      } else {
43        G = TAGMUtil::LoadEdgeListStr<PNGraph>(InFNm, NIDNameH);
44      }
45    }
46    if (LabelFNm.Len() > 0) {
47      TSsParser Ss(LabelFNm, ssfTabSep);
48      while (Ss.Next()) {
49        if (Ss.Len() > 0) { NIDNameH.AddDat(Ss.GetInt(0), Ss.GetFld(1)); }
50      }
51    }
52    printf("Graph: %d Nodes %d Edges\n", G->GetNodes(), G->GetEdges());
53    TVec<TIntV> EstCmtyVVIn, EstCmtyVVOut;
54    TExeTm RunTm;
55    TCoda CD(G, 10, 10);
56    if (OptComs == -1) {
57      printf("finding number of communities\n");
58      OptComs = CD.FindComsByCV(NumThreads, MaxComs, MinComs, DivComs, OutFPrx, StepAlpha, StepBeta);
59    }
60    CD.NeighborComInit(OptComs);
61    if (NumThreads == 1 || G->GetEdges() < 1000) {
62      CD.MLEGradAscent(0.0001, 1000 * G->GetNodes(), "", StepAlpha, StepBeta);
63    } else {
64      CD.MLEGradAscentParallel(0.0001, 1000, NumThreads, "", StepAlpha, StepBeta);
65    }
66    CD.GetCmtyVV(EstCmtyVVOut, EstCmtyVVIn);
67    TAGMUtil::DumpCmtyVV(OutFPrx + "cmtyvv.out.txt", EstCmtyVVOut, NIDNameH);
68    TAGMUtil::DumpCmtyVV(OutFPrx + "cmtyvv.in.txt", EstCmtyVVIn, NIDNameH);
69    Catch
70    printf("\nrun time: %s (%s)\n", ExeTm.GetTmStr(), TSecTm::GetCurTm().GetTmStr().CStr());
71    return 0;
72  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-degradeimage.cpp</h3>
            <pre><code>1  #include "degradeimage.h"
2  #include <allheaders.h> 
3  #include <cstdlib>
4  #include "helpers.h" 
5  #include "rect.h"
6  namespace tesseract {
7  enum FactorNames {
8    FN_INCOLOR,
9    FN_Y0,
10    FN_Y1,
11    FN_Y2,
12    FN_Y3,
13    FN_X0,
14    FN_X1,
15    FN_SHEAR,
16    FN_NUM_FACTORS
17  };
18  const float kRotationRange = 0.02f;
19  const int kExposureFactor = 16;
20  const int kSaltnPepper = 5;
21  const int kMinRampSize = 1000;
22  Image DegradeImage(Image input, int exposure, TRand *randomizer, float *rotation) {
23    Image pix = pixConvertTo8(input, false);
24    input.destroy();
25    input = pix;
26    int width = pixGetWidth(input);
27    int height = pixGetHeight(input);
28    if (exposure >= 2) {
29      pix = input;
30      input = pixErodeGray(pix, 3, 3);
31      pix.destroy();
32    }
33    pix = pixBlockconv(input, 1, 1);
34    input.destroy();
35    if (rotation != nullptr) {
36      float radians_clockwise = 0.0f;
37      if (*rotation) {
38        radians_clockwise = *rotation;
39      } else if (randomizer != nullptr) {
40        radians_clockwise = randomizer->SignedRand(kRotationRange);
41      }
42      input = pixRotate(pix, radians_clockwise, L_ROTATE_AREA_MAP, L_BRING_IN_WHITE, 0, 0);
43      *rotation = radians_clockwise;
44      pix.destroy();
45    } else {
46      input = pix;
47    }
48    if (exposure >= 3 || exposure == 1) {
49      pix = input;
50      input = pixErodeGray(pix, 3, 3);
51      pix.destroy();
52    }
53    int erosion_offset = 0;
54    if (exposure <= 0) {
55      erosion_offset = -3 * kExposureFactor;
56    }
57    erosion_offset -= exposure * kExposureFactor;
58    l_uint32 *data = pixGetData(input);
59    for (int y = 0; y < height; ++y) {
60      for (int x = 0; x < width; ++x) {
61        int pixel = GET_DATA_BYTE(data, x);
62        if (randomizer != nullptr) {
63          pixel += randomizer->IntRand() % (kSaltnPepper * 2 + 1) - kSaltnPepper;
64        }
65        if (height + width > kMinRampSize) {
66          pixel -= (2 * x + y) * 32 / (height + width);
67        }
68        pixel += erosion_offset;
69        if (pixel < 0) {
70          pixel = 0;
71        }
72        if (pixel > 255) {
73          pixel = 255;
74        }
75        SET_DATA_BYTE(data, x, pixel);
76      }
77      data += pixGetWpl(input);
78    }
79    return input;
80  }
81  Image PrepareDistortedPix(const Image pix, bool perspective, bool invert, bool white_noise,
82                           bool smooth_noise, bool blur, int box_reduction, TRand *randomizer,
83                           std::vector<TBOX> *boxes) {
84    Image distorted = pix.copy();
85    if ((white_noise || smooth_noise) && randomizer->SignedRand(1.0) > 0.0) {
86      srand(randomizer->IntRand());
87      Image pixn = pixAddGaussianNoise(distorted, 8.0);
88      distorted.destroy();
89      if (smooth_noise) {
90        distorted = pixBlockconv(pixn, 1, 1);
91        pixn.destroy();
92      } else {
93        distorted = pixn;
94      }
95    }
96    if (blur && randomizer->SignedRand(1.0) > 0.0) {
97      Image blurred = pixBlockconv(distorted, 1, 1);
98      distorted.destroy();
99      distorted = blurred;
100    }
101    if (perspective) {
102      GeneratePerspectiveDistortion(0, 0, randomizer, &distorted, boxes);
103    }
104    if (boxes != nullptr) {
105      for (auto &b : *boxes) {
106        b.scale(1.0f / box_reduction);
107        if (b.width() <= 0) {
108          b.set_right(b.left() + 1);
109        }
110      }
111    }
112    if (invert && randomizer->SignedRand(1.0) < -0) {
113      pixInvert(distorted, distorted);
114    }
115    return distorted;
116  }
117  void GeneratePerspectiveDistortion(int width, int height, TRand *randomizer, Image *pix,
118                                     std::vector<TBOX> *boxes) {
119    if (pix != nullptr && *pix != nullptr) {
120      width = pixGetWidth(*pix);
121      height = pixGetHeight(*pix);
122    }
123    float *im_coeffs = nullptr;
124    float *box_coeffs = nullptr;
125    l_int32 incolor = ProjectiveCoeffs(width, height, randomizer, &im_coeffs, &box_coeffs);
126    if (pix != nullptr && *pix != nullptr) {
127      Image transformed = pixProjective(*pix, im_coeffs, incolor);
128      if (transformed == nullptr) {
129        tprintf("Projective transformation failed!!\n");
130        return;
131      }
132      pix->destroy();
133      *pix = transformed;
134    }
135    if (boxes != nullptr) {
136      for (auto &b : *boxes) {
137        int x1, y1, x2, y2;
138        const TBOX &box = b;
139        projectiveXformSampledPt(box_coeffs, box.left(), height - box.top(), &x1, &y1);
140        projectiveXformSampledPt(box_coeffs, box.right(), height - box.bottom(), &x2, &y2);
141        TBOX new_box1(x1, height - y2, x2, height - y1);
142        projectiveXformSampledPt(box_coeffs, box.left(), height - box.bottom(), &x1, &y1);
143        projectiveXformSampledPt(box_coeffs, box.right(), height - box.top(), &x2, &y2);
144        TBOX new_box2(x1, height - y1, x2, height - y2);
145        b = new_box1.bounding_union(new_box2);
146      }
147    }
148    lept_free(im_coeffs);
149    lept_free(box_coeffs);
150  }
151  int ProjectiveCoeffs(int width, int height, TRand *randomizer, float **im_coeffs,
152                       float **box_coeffs) {
153    Pta *src_pts = ptaCreate(4);
154    ptaAddPt(src_pts, 0.0f, 0.0f);
155    ptaAddPt(src_pts, width, 0.0f);
156    ptaAddPt(src_pts, width, height);
157    ptaAddPt(src_pts, 0.0f, height);
158    float factors[FN_NUM_FACTORS];
159    float shear = 0.0f; 
160    for (int i = 0; i < FN_NUM_FACTORS; ++i) {
161      if (i == FN_SHEAR) {
162        shear = randomizer->SignedRand(0.5 / 3.0);
163        shear = shear >= 0.0 ? shear * shear : -shear * shear;
164        if (shear < -factors[FN_X0]) {
165          shear = -factors[FN_X0];
166        }
167        if (shear > factors[FN_X1]) {
168          shear = factors[FN_X1];
169        }
170        factors[i] = shear;
171      } else if (i != FN_INCOLOR) {
172        factors[i] = fabs(randomizer->SignedRand(1.0));
<span onclick='openModal()' class='match'>173        if (i <= FN_Y3) {
174          factors[i] *= 5.0 / 8.0;
175        } else {
176          factors[i] *= 0.5;
177        }
178        factors[i] *= factors[i];
179      }
</span>180    }
181    Pta *dest_pts = ptaCreate(4);
182    ptaAddPt(dest_pts, factors[FN_X0] * width, factors[FN_Y0] * height);
183    ptaAddPt(dest_pts, (1.0f - factors[FN_X1]) * width, factors[FN_Y1] * height);
184    ptaAddPt(dest_pts, (1.0f - factors[FN_X1] + shear) * width, (1 - factors[FN_Y2]) * height);
185    ptaAddPt(dest_pts, (factors[FN_X0] + shear) * width, (1 - factors[FN_Y3]) * height);
186    getProjectiveXformCoeffs(dest_pts, src_pts, im_coeffs);
187    getProjectiveXformCoeffs(src_pts, dest_pts, box_coeffs);
188    ptaDestroy(&src_pts);
189    ptaDestroy(&dest_pts);
190    return factors[FN_INCOLOR] > 0.5f ? L_BRING_IN_WHITE : L_BRING_IN_BLACK;
191  }
192  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-coda.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-degradeimage.cpp</div>
                </div>
                <div class="column column_space"><pre><code>31      if (InFNm.IsSuffix(".ungraph")) {
32        TFIn GFIn(InFNm);
33        UG = TUNGraph::Load(GFIn);
34      } else {
35        UG = TAGMUtil::LoadEdgeListStr<PUNGraph>(InFNm, NIDNameH);
36      }
37      G = TSnap::ConvertGraph<PNGraph, PUNGraph>(UG);
38    } else {
</pre></code></div>
                <div class="column column_space"><pre><code>173        if (i <= FN_Y3) {
174          factors[i] *= 5.0 / 8.0;
175        } else {
176          factors[i] *= 0.5;
177        }
178        factors[i] *= factors[i];
179      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    