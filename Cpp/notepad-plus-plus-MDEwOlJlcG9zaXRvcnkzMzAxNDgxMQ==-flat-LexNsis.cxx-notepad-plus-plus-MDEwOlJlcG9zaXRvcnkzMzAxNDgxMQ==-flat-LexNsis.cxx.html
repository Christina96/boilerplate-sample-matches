
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static bool isNsisNumber(char ch)
20  {
21    return (ch >= '0' && ch <= '9');
22  }
23  static bool isNsisChar(char ch)
24  {
25    return (ch == '.' ) || (ch == '_' ) || isNsisNumber(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
26  }
27  static bool isNsisLetter(char ch)
28  {
29    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
30  }
31  static bool NsisNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &styler)
32  {
33    Sci_Position nNextLine = -1;
34    for( Sci_PositionU i = start; i < end; i++ )
35    {
36      char cNext = styler.SafeGetCharAt( i );
37      if( cNext == '\n' )
38      {
39        nNextLine = i+1;
40        break;
41      }
42    }
43    if( nNextLine == -1 ) 
44      return false;
45    for( Sci_PositionU firstChar = nNextLine; firstChar < end; firstChar++ )
46    {
47      char cNext = styler.SafeGetCharAt( firstChar );
48      if( cNext == ' ' )
49        continue;
50      if( cNext == '\t' )
51        continue;
52      if( cNext == '!' )
53      {
54        if( styler.Match(firstChar, "!else") )
55          return true;
56      }
57      break;
58    }
59    return false;
60  }
61  static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
62  {
63    if( bIgnoreCase )
64       return CompareCaseInsensitive( s1, s2);
65    return strcmp( s1, s2 );
66  }
67  static int calculateFoldNsis(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &styler, bool bElse, bool foldUtilityCmd )
68  {
69    int style = styler.StyleAt(end);
70    if( end - start > 20 )
71      return foldlevel;
72    if( foldUtilityCmd )
73    {
74      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
75          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_IFDEFINEDEF &&
76          style != SCE_NSIS_MACRODEF && style != SCE_NSIS_SECTIONGROUP &&
77          style != SCE_NSIS_PAGEEX )
78            return foldlevel;
79    }
80    else
81    {
82      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
83          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_SECTIONGROUP &&
84          style != SCE_NSIS_PAGEEX )
85            return foldlevel;
86    }
87    int newFoldlevel = foldlevel;
88    bool bIgnoreCase = false;
89    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
<span onclick='openModal()' class='match'>90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = '\0';
93    for (Sci_PositionU i = 0; i < end - start + 1 && i < 19; i++)
</span>94  	{
95  		s[i] = static_cast<char>( styler[ start + i ] );
96  		s[i + 1] = '\0';
97  	}
98    if( s[0] == '!' )
99    {
100      if( NsisCmp(s, "!ifndef", bIgnoreCase) == 0 || NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase ) == 0 || NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!macro", bIgnoreCase ) == 0 )
101        newFoldlevel++;
102      else if( NsisCmp(s, "!endif", bIgnoreCase) == 0 || NsisCmp(s, "!macroend", bIgnoreCase ) == 0 )
103        newFoldlevel--;
104      else if( bElse && NsisCmp(s, "!else", bIgnoreCase) == 0 )
105        newFoldlevel++;
106    }
107    else
108    {
109      if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionGroup", bIgnoreCase ) == 0 || NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "SubSection", bIgnoreCase ) == 0 || NsisCmp(s, "PageEx", bIgnoreCase ) == 0 )
110        newFoldlevel++;
111      else if( NsisCmp(s, "SectionGroupEnd", bIgnoreCase ) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase ) == 0 )
112        newFoldlevel--;
113    }
114    return newFoldlevel;
115  }
116  static int classifyWordNsis(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &styler )
117  {
118    bool bIgnoreCase = false;
119    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
120      bIgnoreCase = true;
121    bool bUserVars = false;
122    if( styler.GetPropertyInt("nsis.uservars") == 1 )
123      bUserVars = true;
124  	char s[100];
125  	s[0] = '\0';
126  	s[1] = '\0';
127  	WordList &Functions = *keywordLists[0];
128  	WordList &Variables = *keywordLists[1];
129  	WordList &Lables = *keywordLists[2];
130  	WordList &UserDefined = *keywordLists[3];
131  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 99; i++)
132  	{
133      if( bIgnoreCase )
134        s[i] = static_cast<char>( tolower(styler[ start + i ] ) );
135      else
136  		  s[i] = static_cast<char>( styler[ start + i ] );
137  		s[i + 1] = '\0';
138  	}
139  	if( NsisCmp(s, "!macro", bIgnoreCase ) == 0 || NsisCmp(s, "!macroend", bIgnoreCase) == 0 ) 
140  		return SCE_NSIS_MACRODEF;
141  	if( NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 ||  NsisCmp(s, "!ifndef", bIgnoreCase) == 0 ||  NsisCmp(s, "!endif", bIgnoreCase) == 0 ) 
142  		return SCE_NSIS_IFDEFINEDEF;
143  	if( NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!else", bIgnoreCase )  == 0 ) 
144  		return SCE_NSIS_IFDEFINEDEF;
145  	if (NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase )  == 0 ) 
146  		return SCE_NSIS_IFDEFINEDEF;
147    if( NsisCmp(s, "SectionGroup", bIgnoreCase) == 0 || NsisCmp(s, "SectionGroupEnd", bIgnoreCase) == 0 ) 
148      return SCE_NSIS_SECTIONGROUP;
149  	if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase) == 0 ) 
150  		return SCE_NSIS_SECTIONDEF;
151  	if( NsisCmp(s, "SubSection", bIgnoreCase) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase) == 0 ) 
152  		return SCE_NSIS_SUBSECTIONDEF;
153    if( NsisCmp(s, "PageEx", bIgnoreCase) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase) == 0 ) 
154      return SCE_NSIS_PAGEEX;
155  	if( NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 ) 
156  		return SCE_NSIS_FUNCTIONDEF;
157  	if ( Functions.InList(s) )
158  		return SCE_NSIS_FUNCTION;
159  	if ( Variables.InList(s) )
160  		return SCE_NSIS_VARIABLE;
161  	if ( Lables.InList(s) )
162  		return SCE_NSIS_LABEL;
163  	if( UserDefined.InList(s) )
164  		return SCE_NSIS_USERDEFINED;
165  	if( strlen(s) > 3 )
166  	{
167  		if( s[1] == '{' && s[strlen(s)-1] == '}' )
168  			return SCE_NSIS_VARIABLE;
169  	}
170    if( s[0] == '$' && bUserVars )
171    {
172      bool bHasSimpleNsisChars = true;
173      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
174  	  {
175        if( !isNsisChar( s[j] ) )
176        {
177          bHasSimpleNsisChars = false;
178          break;
179        }
180  	  }
181      if( bHasSimpleNsisChars )
182        return SCE_NSIS_VARIABLE;
183    }
184    if( isNsisNumber( s[0] ) )
185    {
186      bool bHasSimpleNsisNumber = true;
187      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
188  	  {
189        if( !isNsisNumber( s[j] ) )
190        {
191          bHasSimpleNsisNumber = false;
192          break;
193        }
194  	  }
195      if( bHasSimpleNsisNumber )
196        return SCE_NSIS_NUMBER;
197    }
198  	return SCE_NSIS_DEFAULT;
199  }
200  static void ColouriseNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &styler)
201  {
202  	int state = SCE_NSIS_DEFAULT;
203    if( startPos > 0 )
204      state = styler.StyleAt(startPos-1); 
205  	styler.StartAt( startPos );
206  	styler.GetLine( startPos );
207  	Sci_PositionU nLengthDoc = startPos + length;
208  	styler.StartSegment( startPos );
209  	char cCurrChar;
210  	bool bVarInString = false;
211    bool bClassicVarInString = false;
212  	Sci_PositionU i;
213  	for( i = startPos; i < nLengthDoc; i++ )
214  	{
215  		cCurrChar = styler.SafeGetCharAt( i );
216  		char cNextChar = styler.SafeGetCharAt(i+1);
217  		switch(state)
218  		{
219  			case SCE_NSIS_DEFAULT:
220  				if( cCurrChar == ';' || cCurrChar == '#' ) 
221  				{
222  					styler.ColourTo(i-1, state );
223  					state = SCE_NSIS_COMMENT;
224  					break;
225  				}
226  				if( cCurrChar == '"' )
227  				{
228  					styler.ColourTo(i-1, state );
229  					state = SCE_NSIS_STRINGDQ;
230  					bVarInString = false;
231            bClassicVarInString = false;
232  					break;
233  				}
234  				if( cCurrChar == '\'' )
235  				{
236  					styler.ColourTo(i-1, state );
237  					state = SCE_NSIS_STRINGRQ;
238  					bVarInString = false;
239            bClassicVarInString = false;
240  					break;
241  				}
242  				if( cCurrChar == '`' )
243  				{
244  					styler.ColourTo(i-1, state );
245  					state = SCE_NSIS_STRINGLQ;
246  					bVarInString = false;
247            bClassicVarInString = false;
248  					break;
249  				}
250  				if( cCurrChar == '$' || isNsisChar(cCurrChar) || cCurrChar == '!' )
251  				{
252  					styler.ColourTo(i-1,state);
253  				  state = SCE_NSIS_FUNCTION;
254            if( isNsisNumber(cCurrChar) && (cNextChar == '\t' || cNextChar == ' ' || cNextChar == '\r' || cNextChar == '\n' ) )
255                styler.ColourTo( i, SCE_NSIS_NUMBER);
256  					break;
257  				}
258          if( cCurrChar == '/' && cNextChar == '*' )
259          {
260            styler.ColourTo(i-1,state);
261            state = SCE_NSIS_COMMENTBOX;
262            break;
263          }
264  				break;
265  			case SCE_NSIS_COMMENT:
266  				if( cNextChar == '\n' || cNextChar == '\r' )
267          {
268            if( cCurrChar == '\\' )
269            {
270              styler.ColourTo(i-2,state);
271              styler.ColourTo(i,SCE_NSIS_DEFAULT);
272            }
273            else
274            {
275  				    styler.ColourTo(i,state);
276              state = SCE_NSIS_DEFAULT;
277            }
278          }
279  				break;
280  			case SCE_NSIS_STRINGDQ:
281        case SCE_NSIS_STRINGLQ:
282        case SCE_NSIS_STRINGRQ:
283          if( styler.SafeGetCharAt(i-1) == '\\' && styler.SafeGetCharAt(i-2) == '$' )
284            break; 
285          if( cCurrChar == '"' && state == SCE_NSIS_STRINGDQ )
286  				{
287  					styler.ColourTo(i,state);
288  				  state = SCE_NSIS_DEFAULT;
289            break;
290  				}
291          if( cCurrChar == '`' && state == SCE_NSIS_STRINGLQ )
292          {
293  					styler.ColourTo(i,state);
294  				  state = SCE_NSIS_DEFAULT;
295            break;
296  				}
297          if( cCurrChar == '\'' && state == SCE_NSIS_STRINGRQ )
298  				{
299  					styler.ColourTo(i,state);
300  				  state = SCE_NSIS_DEFAULT;
301            break;
302  				}
303          if( cNextChar == '\r' || cNextChar == '\n' )
304          {
305            Sci_Position nCurLine = styler.GetLine(i+1);
306            Sci_Position nBack = i;
307            bool bNextLine = false;
308            while( nBack > 0 )
309            {
310              if( styler.GetLine(nBack) != nCurLine )
311                break;
312              char cTemp = styler.SafeGetCharAt(nBack, 'a'); 
313              if( cTemp == '\\' )
314              {
315                bNextLine = true;
316                break;
317              }
318              if( cTemp != '\r' && cTemp != '\n' && cTemp != '\t' && cTemp != ' ' )
319                break;
320              nBack--;
321            }
322            if( bNextLine )
323            {
324              styler.ColourTo(i+1,state);
325            }
326            if( bNextLine == false )
327            {
328              styler.ColourTo(i,state);
329  				    state = SCE_NSIS_DEFAULT;
330            }
331          }
332  				break;
333  			case SCE_NSIS_FUNCTION:
334          if( cCurrChar == '$' )
335            state = SCE_NSIS_DEFAULT;
336          else if( cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' ) )
337            state = SCE_NSIS_DEFAULT;
338  				else if( (isNsisChar(cCurrChar) && !isNsisChar( cNextChar) && cNextChar != '}') || cCurrChar == '}' )
339  				{
340  					state = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler );
341  					styler.ColourTo( i, state);
342  					state = SCE_NSIS_DEFAULT;
343  				}
344  				else if( !isNsisChar( cCurrChar ) && cCurrChar != '{' && cCurrChar != '}' )
345  				{
346            if( classifyWordNsis( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_NSIS_NUMBER )
347               styler.ColourTo( i-1, SCE_NSIS_NUMBER );
348  					state = SCE_NSIS_DEFAULT;
349  					if( cCurrChar == '"' )
350  					{
351  						state = SCE_NSIS_STRINGDQ;
352  						bVarInString = false;
353              bClassicVarInString = false;
354  					}
355  					else if( cCurrChar == '`' )
356  					{
357  						state = SCE_NSIS_STRINGLQ;
358  						bVarInString = false;
359              bClassicVarInString = false;
360  					}
361  					else if( cCurrChar == '\'' )
362  					{
363  						state = SCE_NSIS_STRINGRQ;
364  						bVarInString = false;
365              bClassicVarInString = false;
366  					}
367  					else if( cCurrChar == '#' || cCurrChar == ';' )
368            {
369  						state = SCE_NSIS_COMMENT;
370            }
371  				}
372  				break;
373        case SCE_NSIS_COMMENTBOX:
374          if( styler.SafeGetCharAt(i-1) == '*' && cCurrChar == '/' )
375          {
376            styler.ColourTo(i,state);
377            state = SCE_NSIS_DEFAULT;
378          }
379          break;
380  		}
381  		if( state == SCE_NSIS_COMMENT || state == SCE_NSIS_COMMENTBOX )
382  		{
383  			styler.ColourTo(i,state);
384  		}
385  		else if( state == SCE_NSIS_STRINGDQ || state == SCE_NSIS_STRINGLQ || state == SCE_NSIS_STRINGRQ )
386  		{
387        bool bIngoreNextDollarSign = false;
388        bool bUserVars = false;
389        if( styler.GetPropertyInt("nsis.uservars") == 1 )
390          bUserVars = true;
391        if( bVarInString && cCurrChar == '$' )
392        {
393          bVarInString = false;
394          bIngoreNextDollarSign = true;
395        }
396        else if( bVarInString && cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' || cNextChar == '"' || cNextChar == '`' || cNextChar == '\'' ) )
397        {
398          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
399          bVarInString = false;
400          bIngoreNextDollarSign = false;
401        }
402        else if( bVarInString && !isNsisChar(cNextChar) )
403        {
404          int nWordState = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler);
405  				if( nWordState == SCE_NSIS_VARIABLE )
406  					styler.ColourTo( i, SCE_NSIS_STRINGVAR);
407          else if( bUserVars )
408            styler.ColourTo( i, SCE_NSIS_STRINGVAR);
409          bVarInString = false;
410        }
411        else if( bClassicVarInString && cNextChar == '}' )
412        {
413          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
414  				bClassicVarInString = false;
415        }
416  			if( !bIngoreNextDollarSign && cCurrChar == '$' && cNextChar == '{' )
417  			{
418  				styler.ColourTo( i-1, state);
419  				bClassicVarInString = true;
420          bVarInString = false;
421  			}
422        else if( !bIngoreNextDollarSign && cCurrChar == '$' )
423        {
424          styler.ColourTo( i-1, state);
425          bVarInString = true;
426          bClassicVarInString = false;
427        }
428  		}
429  	}
430  	styler.ColourTo(nLengthDoc-1,state);
431  }
432  static void FoldNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler)
433  {
434  	if( styler.GetPropertyInt("fold") == 0 )
435  		return;
436    bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) == 1;
437    bool foldUtilityCmd = styler.GetPropertyInt("nsis.foldutilcmd", 1) == 1;
438    bool blockComment = false;
439    Sci_Position lineCurrent = styler.GetLine(startPos);
440    Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
441    bool bArg1 = true;
442    Sci_Position nWordStart = -1;
443    int levelCurrent = SC_FOLDLEVELBASE;
444  	if (lineCurrent > 0)
445  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
446  	int levelNext = levelCurrent;
447    int style = styler.StyleAt(safeStartPos);
448    if( style == SCE_NSIS_COMMENTBOX )
449    {
450      if( styler.SafeGetCharAt(safeStartPos) == '/' && styler.SafeGetCharAt(safeStartPos+1) == '*' )
451        levelNext++;
452      blockComment = true;
453    }
454    for (Sci_PositionU i = safeStartPos; i < startPos + length; i++)
455  	{
456      char chCurr = styler.SafeGetCharAt(i);
457      style = styler.StyleAt(i);
458      if( blockComment && style != SCE_NSIS_COMMENTBOX )
459      {
460        levelNext--;
461        blockComment = false;
462      }
463      else if( !blockComment && style == SCE_NSIS_COMMENTBOX )
464      {
465        levelNext++;
466        blockComment = true;
467      }
468      if( bArg1 && !blockComment)
469      {
470        if( nWordStart == -1 && (isNsisLetter(chCurr) || chCurr == '!') )
471        {
472          nWordStart = i;
473        }
474        else if( isNsisLetter(chCurr) == false && nWordStart > -1 )
475        {
476          int newLevel = calculateFoldNsis( nWordStart, i-1, levelNext, styler, foldAtElse, foldUtilityCmd );
477          if( newLevel == levelNext )
478          {
479            if( foldAtElse && foldUtilityCmd )
480            {
481              if( NsisNextLineHasElse(i, startPos + length, styler) )
482                levelNext--;
483            }
484          }
485          else
486            levelNext = newLevel;
487          bArg1 = false;
488        }
489      }
490      if( chCurr == '\n' )
491      {
492        if( bArg1 && foldAtElse && foldUtilityCmd && !blockComment )
493        {
494          if( NsisNextLineHasElse(i, startPos + length, styler) )
495            levelNext--;
496        }
497        int levelUse = levelCurrent;
498  			int lev = levelUse | levelNext << 16;
499        if (levelUse < levelNext )
500  				lev |= SC_FOLDLEVELHEADERFLAG;
501  			if (lev != styler.LevelAt(lineCurrent))
502  				styler.SetLevel(lineCurrent, lev);
503  			lineCurrent++;
504  			levelCurrent = levelNext;
505        bArg1 = true; 
506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext << 16;
511  	if (levelUse < levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	"Functions",
518  	"Variables",
519  	"Lables",
520  	"UserDefined",
521  	0, };
522  LexerModule lmNsis(SCLEX_NSIS, ColouriseNsisDoc, "nsis", FoldNsisDoc, nsisWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static bool isNsisNumber(char ch)
20  {
21    return (ch >= '0' && ch <= '9');
22  }
23  static bool isNsisChar(char ch)
24  {
25    return (ch == '.' ) || (ch == '_' ) || isNsisNumber(ch) || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
26  }
27  static bool isNsisLetter(char ch)
28  {
29    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
30  }
31  static bool NsisNextLineHasElse(Sci_PositionU start, Sci_PositionU end, Accessor &styler)
32  {
33    Sci_Position nNextLine = -1;
34    for( Sci_PositionU i = start; i < end; i++ )
35    {
36      char cNext = styler.SafeGetCharAt( i );
37      if( cNext == '\n' )
38      {
39        nNextLine = i+1;
40        break;
41      }
42    }
43    if( nNextLine == -1 ) 
44      return false;
45    for( Sci_PositionU firstChar = nNextLine; firstChar < end; firstChar++ )
46    {
47      char cNext = styler.SafeGetCharAt( firstChar );
48      if( cNext == ' ' )
49        continue;
50      if( cNext == '\t' )
51        continue;
52      if( cNext == '!' )
53      {
54        if( styler.Match(firstChar, "!else") )
55          return true;
56      }
57      break;
58    }
59    return false;
60  }
61  static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
62  {
63    if( bIgnoreCase )
64       return CompareCaseInsensitive( s1, s2);
65    return strcmp( s1, s2 );
66  }
67  static int calculateFoldNsis(Sci_PositionU start, Sci_PositionU end, int foldlevel, Accessor &styler, bool bElse, bool foldUtilityCmd )
68  {
69    int style = styler.StyleAt(end);
70    if( end - start > 20 )
71      return foldlevel;
72    if( foldUtilityCmd )
73    {
74      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
75          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_IFDEFINEDEF &&
76          style != SCE_NSIS_MACRODEF && style != SCE_NSIS_SECTIONGROUP &&
77          style != SCE_NSIS_PAGEEX )
78            return foldlevel;
79    }
80    else
81    {
82      if( style != SCE_NSIS_FUNCTIONDEF && style != SCE_NSIS_SECTIONDEF &&
83          style != SCE_NSIS_SUBSECTIONDEF && style != SCE_NSIS_SECTIONGROUP &&
84          style != SCE_NSIS_PAGEEX )
85            return foldlevel;
86    }
87    int newFoldlevel = foldlevel;
88    bool bIgnoreCase = false;
89    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = '\0';
93    for (Sci_PositionU i = 0; i < end - start + 1 && i < 19; i++)
94  	{
95  		s[i] = static_cast<char>( styler[ start + i ] );
96  		s[i + 1] = '\0';
97  	}
98    if( s[0] == '!' )
99    {
100      if( NsisCmp(s, "!ifndef", bIgnoreCase) == 0 || NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase ) == 0 || NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!macro", bIgnoreCase ) == 0 )
101        newFoldlevel++;
102      else if( NsisCmp(s, "!endif", bIgnoreCase) == 0 || NsisCmp(s, "!macroend", bIgnoreCase ) == 0 )
103        newFoldlevel--;
104      else if( bElse && NsisCmp(s, "!else", bIgnoreCase) == 0 )
105        newFoldlevel++;
106    }
107    else
108    {
109      if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionGroup", bIgnoreCase ) == 0 || NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "SubSection", bIgnoreCase ) == 0 || NsisCmp(s, "PageEx", bIgnoreCase ) == 0 )
110        newFoldlevel++;
111      else if( NsisCmp(s, "SectionGroupEnd", bIgnoreCase ) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase ) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase ) == 0 )
112        newFoldlevel--;
113    }
114    return newFoldlevel;
115  }
116  static int classifyWordNsis(Sci_PositionU start, Sci_PositionU end, WordList *keywordLists[], Accessor &styler )
117  {
118    bool bIgnoreCase = false;
119    if( styler.GetPropertyInt("nsis.ignorecase") == 1 )
120      bIgnoreCase = true;
121    bool bUserVars = false;
122    if( styler.GetPropertyInt("nsis.uservars") == 1 )
<span onclick='openModal()' class='match'>123      bUserVars = true;
124  	char s[100];
125  	s[0] = '\0';
126  	s[1] = '\0';
</span>127  	WordList &Functions = *keywordLists[0];
128  	WordList &Variables = *keywordLists[1];
129  	WordList &Lables = *keywordLists[2];
130  	WordList &UserDefined = *keywordLists[3];
131  	for (Sci_PositionU i = 0; i < end - start + 1 && i < 99; i++)
132  	{
133      if( bIgnoreCase )
134        s[i] = static_cast<char>( tolower(styler[ start + i ] ) );
135      else
136  		  s[i] = static_cast<char>( styler[ start + i ] );
137  		s[i + 1] = '\0';
138  	}
139  	if( NsisCmp(s, "!macro", bIgnoreCase ) == 0 || NsisCmp(s, "!macroend", bIgnoreCase) == 0 ) 
140  		return SCE_NSIS_MACRODEF;
141  	if( NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 ||  NsisCmp(s, "!ifndef", bIgnoreCase) == 0 ||  NsisCmp(s, "!endif", bIgnoreCase) == 0 ) 
142  		return SCE_NSIS_IFDEFINEDEF;
143  	if( NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!else", bIgnoreCase )  == 0 ) 
144  		return SCE_NSIS_IFDEFINEDEF;
145  	if (NsisCmp(s, "!ifmacrodef", bIgnoreCase ) == 0 || NsisCmp(s, "!ifmacrondef", bIgnoreCase )  == 0 ) 
146  		return SCE_NSIS_IFDEFINEDEF;
147    if( NsisCmp(s, "SectionGroup", bIgnoreCase) == 0 || NsisCmp(s, "SectionGroupEnd", bIgnoreCase) == 0 ) 
148      return SCE_NSIS_SECTIONGROUP;
149  	if( NsisCmp(s, "Section", bIgnoreCase ) == 0 || NsisCmp(s, "SectionEnd", bIgnoreCase) == 0 ) 
150  		return SCE_NSIS_SECTIONDEF;
151  	if( NsisCmp(s, "SubSection", bIgnoreCase) == 0 || NsisCmp(s, "SubSectionEnd", bIgnoreCase) == 0 ) 
152  		return SCE_NSIS_SUBSECTIONDEF;
153    if( NsisCmp(s, "PageEx", bIgnoreCase) == 0 || NsisCmp(s, "PageExEnd", bIgnoreCase) == 0 ) 
154      return SCE_NSIS_PAGEEX;
155  	if( NsisCmp(s, "Function", bIgnoreCase) == 0 || NsisCmp(s, "FunctionEnd", bIgnoreCase) == 0 ) 
156  		return SCE_NSIS_FUNCTIONDEF;
157  	if ( Functions.InList(s) )
158  		return SCE_NSIS_FUNCTION;
159  	if ( Variables.InList(s) )
160  		return SCE_NSIS_VARIABLE;
161  	if ( Lables.InList(s) )
162  		return SCE_NSIS_LABEL;
163  	if( UserDefined.InList(s) )
164  		return SCE_NSIS_USERDEFINED;
165  	if( strlen(s) > 3 )
166  	{
167  		if( s[1] == '{' && s[strlen(s)-1] == '}' )
168  			return SCE_NSIS_VARIABLE;
169  	}
170    if( s[0] == '$' && bUserVars )
171    {
172      bool bHasSimpleNsisChars = true;
173      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
174  	  {
175        if( !isNsisChar( s[j] ) )
176        {
177          bHasSimpleNsisChars = false;
178          break;
179        }
180  	  }
181      if( bHasSimpleNsisChars )
182        return SCE_NSIS_VARIABLE;
183    }
184    if( isNsisNumber( s[0] ) )
185    {
186      bool bHasSimpleNsisNumber = true;
187      for (Sci_PositionU j = 1; j < end - start + 1 && j < 99; j++)
188  	  {
189        if( !isNsisNumber( s[j] ) )
190        {
191          bHasSimpleNsisNumber = false;
192          break;
193        }
194  	  }
195      if( bHasSimpleNsisNumber )
196        return SCE_NSIS_NUMBER;
197    }
198  	return SCE_NSIS_DEFAULT;
199  }
200  static void ColouriseNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *keywordLists[], Accessor &styler)
201  {
202  	int state = SCE_NSIS_DEFAULT;
203    if( startPos > 0 )
204      state = styler.StyleAt(startPos-1); 
205  	styler.StartAt( startPos );
206  	styler.GetLine( startPos );
207  	Sci_PositionU nLengthDoc = startPos + length;
208  	styler.StartSegment( startPos );
209  	char cCurrChar;
210  	bool bVarInString = false;
211    bool bClassicVarInString = false;
212  	Sci_PositionU i;
213  	for( i = startPos; i < nLengthDoc; i++ )
214  	{
215  		cCurrChar = styler.SafeGetCharAt( i );
216  		char cNextChar = styler.SafeGetCharAt(i+1);
217  		switch(state)
218  		{
219  			case SCE_NSIS_DEFAULT:
220  				if( cCurrChar == ';' || cCurrChar == '#' ) 
221  				{
222  					styler.ColourTo(i-1, state );
223  					state = SCE_NSIS_COMMENT;
224  					break;
225  				}
226  				if( cCurrChar == '"' )
227  				{
228  					styler.ColourTo(i-1, state );
229  					state = SCE_NSIS_STRINGDQ;
230  					bVarInString = false;
231            bClassicVarInString = false;
232  					break;
233  				}
234  				if( cCurrChar == '\'' )
235  				{
236  					styler.ColourTo(i-1, state );
237  					state = SCE_NSIS_STRINGRQ;
238  					bVarInString = false;
239            bClassicVarInString = false;
240  					break;
241  				}
242  				if( cCurrChar == '`' )
243  				{
244  					styler.ColourTo(i-1, state );
245  					state = SCE_NSIS_STRINGLQ;
246  					bVarInString = false;
247            bClassicVarInString = false;
248  					break;
249  				}
250  				if( cCurrChar == '$' || isNsisChar(cCurrChar) || cCurrChar == '!' )
251  				{
252  					styler.ColourTo(i-1,state);
253  				  state = SCE_NSIS_FUNCTION;
254            if( isNsisNumber(cCurrChar) && (cNextChar == '\t' || cNextChar == ' ' || cNextChar == '\r' || cNextChar == '\n' ) )
255                styler.ColourTo( i, SCE_NSIS_NUMBER);
256  					break;
257  				}
258          if( cCurrChar == '/' && cNextChar == '*' )
259          {
260            styler.ColourTo(i-1,state);
261            state = SCE_NSIS_COMMENTBOX;
262            break;
263          }
264  				break;
265  			case SCE_NSIS_COMMENT:
266  				if( cNextChar == '\n' || cNextChar == '\r' )
267          {
268            if( cCurrChar == '\\' )
269            {
270              styler.ColourTo(i-2,state);
271              styler.ColourTo(i,SCE_NSIS_DEFAULT);
272            }
273            else
274            {
275  				    styler.ColourTo(i,state);
276              state = SCE_NSIS_DEFAULT;
277            }
278          }
279  				break;
280  			case SCE_NSIS_STRINGDQ:
281        case SCE_NSIS_STRINGLQ:
282        case SCE_NSIS_STRINGRQ:
283          if( styler.SafeGetCharAt(i-1) == '\\' && styler.SafeGetCharAt(i-2) == '$' )
284            break; 
285          if( cCurrChar == '"' && state == SCE_NSIS_STRINGDQ )
286  				{
287  					styler.ColourTo(i,state);
288  				  state = SCE_NSIS_DEFAULT;
289            break;
290  				}
291          if( cCurrChar == '`' && state == SCE_NSIS_STRINGLQ )
292          {
293  					styler.ColourTo(i,state);
294  				  state = SCE_NSIS_DEFAULT;
295            break;
296  				}
297          if( cCurrChar == '\'' && state == SCE_NSIS_STRINGRQ )
298  				{
299  					styler.ColourTo(i,state);
300  				  state = SCE_NSIS_DEFAULT;
301            break;
302  				}
303          if( cNextChar == '\r' || cNextChar == '\n' )
304          {
305            Sci_Position nCurLine = styler.GetLine(i+1);
306            Sci_Position nBack = i;
307            bool bNextLine = false;
308            while( nBack > 0 )
309            {
310              if( styler.GetLine(nBack) != nCurLine )
311                break;
312              char cTemp = styler.SafeGetCharAt(nBack, 'a'); 
313              if( cTemp == '\\' )
314              {
315                bNextLine = true;
316                break;
317              }
318              if( cTemp != '\r' && cTemp != '\n' && cTemp != '\t' && cTemp != ' ' )
319                break;
320              nBack--;
321            }
322            if( bNextLine )
323            {
324              styler.ColourTo(i+1,state);
325            }
326            if( bNextLine == false )
327            {
328              styler.ColourTo(i,state);
329  				    state = SCE_NSIS_DEFAULT;
330            }
331          }
332  				break;
333  			case SCE_NSIS_FUNCTION:
334          if( cCurrChar == '$' )
335            state = SCE_NSIS_DEFAULT;
336          else if( cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' ) )
337            state = SCE_NSIS_DEFAULT;
338  				else if( (isNsisChar(cCurrChar) && !isNsisChar( cNextChar) && cNextChar != '}') || cCurrChar == '}' )
339  				{
340  					state = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler );
341  					styler.ColourTo( i, state);
342  					state = SCE_NSIS_DEFAULT;
343  				}
344  				else if( !isNsisChar( cCurrChar ) && cCurrChar != '{' && cCurrChar != '}' )
345  				{
346            if( classifyWordNsis( styler.GetStartSegment(), i-1, keywordLists, styler) == SCE_NSIS_NUMBER )
347               styler.ColourTo( i-1, SCE_NSIS_NUMBER );
348  					state = SCE_NSIS_DEFAULT;
349  					if( cCurrChar == '"' )
350  					{
351  						state = SCE_NSIS_STRINGDQ;
352  						bVarInString = false;
353              bClassicVarInString = false;
354  					}
355  					else if( cCurrChar == '`' )
356  					{
357  						state = SCE_NSIS_STRINGLQ;
358  						bVarInString = false;
359              bClassicVarInString = false;
360  					}
361  					else if( cCurrChar == '\'' )
362  					{
363  						state = SCE_NSIS_STRINGRQ;
364  						bVarInString = false;
365              bClassicVarInString = false;
366  					}
367  					else if( cCurrChar == '#' || cCurrChar == ';' )
368            {
369  						state = SCE_NSIS_COMMENT;
370            }
371  				}
372  				break;
373        case SCE_NSIS_COMMENTBOX:
374          if( styler.SafeGetCharAt(i-1) == '*' && cCurrChar == '/' )
375          {
376            styler.ColourTo(i,state);
377            state = SCE_NSIS_DEFAULT;
378          }
379          break;
380  		}
381  		if( state == SCE_NSIS_COMMENT || state == SCE_NSIS_COMMENTBOX )
382  		{
383  			styler.ColourTo(i,state);
384  		}
385  		else if( state == SCE_NSIS_STRINGDQ || state == SCE_NSIS_STRINGLQ || state == SCE_NSIS_STRINGRQ )
386  		{
387        bool bIngoreNextDollarSign = false;
388        bool bUserVars = false;
389        if( styler.GetPropertyInt("nsis.uservars") == 1 )
390          bUserVars = true;
391        if( bVarInString && cCurrChar == '$' )
392        {
393          bVarInString = false;
394          bIngoreNextDollarSign = true;
395        }
396        else if( bVarInString && cCurrChar == '\\' && (cNextChar == 'n' || cNextChar == 'r' || cNextChar == 't' || cNextChar == '"' || cNextChar == '`' || cNextChar == '\'' ) )
397        {
398          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
399          bVarInString = false;
400          bIngoreNextDollarSign = false;
401        }
402        else if( bVarInString && !isNsisChar(cNextChar) )
403        {
404          int nWordState = classifyWordNsis( styler.GetStartSegment(), i, keywordLists, styler);
405  				if( nWordState == SCE_NSIS_VARIABLE )
406  					styler.ColourTo( i, SCE_NSIS_STRINGVAR);
407          else if( bUserVars )
408            styler.ColourTo( i, SCE_NSIS_STRINGVAR);
409          bVarInString = false;
410        }
411        else if( bClassicVarInString && cNextChar == '}' )
412        {
413          styler.ColourTo( i+1, SCE_NSIS_STRINGVAR);
414  				bClassicVarInString = false;
415        }
416  			if( !bIngoreNextDollarSign && cCurrChar == '$' && cNextChar == '{' )
417  			{
418  				styler.ColourTo( i-1, state);
419  				bClassicVarInString = true;
420          bVarInString = false;
421  			}
422        else if( !bIngoreNextDollarSign && cCurrChar == '$' )
423        {
424          styler.ColourTo( i-1, state);
425          bVarInString = true;
426          bClassicVarInString = false;
427        }
428  		}
429  	}
430  	styler.ColourTo(nLengthDoc-1,state);
431  }
432  static void FoldNsisDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler)
433  {
434  	if( styler.GetPropertyInt("fold") == 0 )
435  		return;
436    bool foldAtElse = styler.GetPropertyInt("fold.at.else", 0) == 1;
437    bool foldUtilityCmd = styler.GetPropertyInt("nsis.foldutilcmd", 1) == 1;
438    bool blockComment = false;
439    Sci_Position lineCurrent = styler.GetLine(startPos);
440    Sci_PositionU safeStartPos = styler.LineStart( lineCurrent );
441    bool bArg1 = true;
442    Sci_Position nWordStart = -1;
443    int levelCurrent = SC_FOLDLEVELBASE;
444  	if (lineCurrent > 0)
445  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
446  	int levelNext = levelCurrent;
447    int style = styler.StyleAt(safeStartPos);
448    if( style == SCE_NSIS_COMMENTBOX )
449    {
450      if( styler.SafeGetCharAt(safeStartPos) == '/' && styler.SafeGetCharAt(safeStartPos+1) == '*' )
451        levelNext++;
452      blockComment = true;
453    }
454    for (Sci_PositionU i = safeStartPos; i < startPos + length; i++)
455  	{
456      char chCurr = styler.SafeGetCharAt(i);
457      style = styler.StyleAt(i);
458      if( blockComment && style != SCE_NSIS_COMMENTBOX )
459      {
460        levelNext--;
461        blockComment = false;
462      }
463      else if( !blockComment && style == SCE_NSIS_COMMENTBOX )
464      {
465        levelNext++;
466        blockComment = true;
467      }
468      if( bArg1 && !blockComment)
469      {
470        if( nWordStart == -1 && (isNsisLetter(chCurr) || chCurr == '!') )
471        {
472          nWordStart = i;
473        }
474        else if( isNsisLetter(chCurr) == false && nWordStart > -1 )
475        {
476          int newLevel = calculateFoldNsis( nWordStart, i-1, levelNext, styler, foldAtElse, foldUtilityCmd );
477          if( newLevel == levelNext )
478          {
479            if( foldAtElse && foldUtilityCmd )
480            {
481              if( NsisNextLineHasElse(i, startPos + length, styler) )
482                levelNext--;
483            }
484          }
485          else
486            levelNext = newLevel;
487          bArg1 = false;
488        }
489      }
490      if( chCurr == '\n' )
491      {
492        if( bArg1 && foldAtElse && foldUtilityCmd && !blockComment )
493        {
494          if( NsisNextLineHasElse(i, startPos + length, styler) )
495            levelNext--;
496        }
497        int levelUse = levelCurrent;
498  			int lev = levelUse | levelNext << 16;
499        if (levelUse < levelNext )
500  				lev |= SC_FOLDLEVELHEADERFLAG;
501  			if (lev != styler.LevelAt(lineCurrent))
502  				styler.SetLevel(lineCurrent, lev);
503  			lineCurrent++;
504  			levelCurrent = levelNext;
505        bArg1 = true; 
506        nWordStart = -1;
507      }
508    }
509  	int levelUse = levelCurrent;
510  	int lev = levelUse | levelNext << 16;
511  	if (levelUse < levelNext)
512  		lev |= SC_FOLDLEVELHEADERFLAG;
513  	if (lev != styler.LevelAt(lineCurrent))
514  		styler.SetLevel(lineCurrent, lev);
515  }
516  static const char * const nsisWordLists[] = {
517  	"Functions",
518  	"Variables",
519  	"Lables",
520  	"UserDefined",
521  	0, };
522  LexerModule lmNsis(SCLEX_NSIS, ColouriseNsisDoc, "nsis", FoldNsisDoc, nsisWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexNsis.cxx</div>
                </div>
                <div class="column column_space"><pre><code>90      bIgnoreCase = true;
91    char s[20]; 
92    s[0] = '\0';
93    for (Sci_PositionU i = 0; i < end - start + 1 && i < 19; i++)
</pre></code></div>
                <div class="column column_space"><pre><code>123      bUserVars = true;
124  	char s[100];
125  	s[0] = '\0';
126  	s[1] = '\0';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    