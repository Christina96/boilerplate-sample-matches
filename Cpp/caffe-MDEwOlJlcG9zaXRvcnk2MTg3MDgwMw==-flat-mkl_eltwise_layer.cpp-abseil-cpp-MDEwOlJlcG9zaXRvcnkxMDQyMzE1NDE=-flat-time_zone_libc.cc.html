
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.597122302158273%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_eltwise_layer.cpp</h3>
            <pre><code>1  #if defined(MKL2017_SUPPORTED)
2  #include <cfloat>
3  #include <vector>
4  #include "caffe/layers/mkl_layers.hpp"
5  #include "caffe/util/math_functions.hpp"
6  #include "caffe/util/performance.hpp"
7  namespace caffe {
8  template <typename Dtype>
9  MKLEltwiseLayer<Dtype>::~MKLEltwiseLayer() {
10    dnnDelete<Dtype>(sumPrimitive);
11  }
12  template <typename Dtype>
13  void MKLEltwiseLayer<Dtype>::Init(const vector<Blob<Dtype>*>& bottom,
14               const vector<Blob<Dtype>*>& top) {
15    channels_ = bottom[0]->channels();
16    height_ = bottom[0]->height();
17    width_ = bottom[0]->width();
18    num_ = bottom[0]->num();
19    op_ = this->layer_param_.eltwise_param().operation();
20    coeffs_ = vector<Dtype>(bottom.size(), 1);
21    if (this->layer_param().eltwise_param().coeff_size()) {
22      for (int i = 0; i < bottom.size(); ++i) {
23        coeffs_[i] = this->layer_param().eltwise_param().coeff(i);
24      }
25    }
26    stable_prod_grad_ = this->layer_param_.eltwise_param().stable_prod_grad();
27    num_bottoms = bottom.size();
28    size_t dim_src = bottom[0]->shape().size();
29    size_t sizes_src[dim_src], strides_src[dim_src];
30    for (size_t d = 0; d < dim_src; ++d) {
31        sizes_src[d] = bottom[0]->shape()[dim_src - d - 1];
32        strides_src[d] = (d == 0) ? 1 : strides_src[d-1]*sizes_src[d-1];
33    }
34    for (size_t i = 0; i < num_bottoms; ++i) {
35        fwd_bottom_data.push_back(
36          shared_ptr<MKLData<Dtype> >(new MKLData<Dtype>));
37        bwd_bottom_diff.push_back(
38          shared_ptr<MKLDiff<Dtype> >(new MKLDiff<Dtype>));
39        CHECK_EQ(dim_src, bottom[i]->shape().size());
40        fwd_bottom_data[i]->create_user_layout(dim_src,
41                                               sizes_src,
42                                               strides_src,
43                                               false);
44        bwd_bottom_diff[i]->create_user_layout(dim_src,
45                                               sizes_src,
46                                               strides_src,
47                                               false);
48    }
49    fwd_top_data->create_user_layout(dim_src, sizes_src, strides_src, false);
50    dnnDelete<Dtype>(sumPrimitive);
51  }
52  template <typename Dtype>
53  void MKLEltwiseLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
54        const vector<Blob<Dtype>*>& top) {
55    CHECK(this->layer_param().eltwise_param().coeff_size() == 0
56        || this->layer_param().eltwise_param().coeff_size() == bottom.size()) <<
57        "MKLEltwise Layer takes one coefficient per bottom blob.";
58    CHECK(!(this->layer_param().eltwise_param().operation()
59        == EltwiseParameter_EltwiseOp_PROD
60        && this->layer_param().eltwise_param().coeff_size())) <<
61        "MKLEltwise layer only takes coefficients for summation.";
62    CHECK(this->layer_param().eltwise_param().operation() ==
63      EltwiseParameter_EltwiseOp_SUM)
64        << "MKLEltwise Layer only process summation.";
65    Init(bottom, top);
66  }
67  template <typename Dtype>
68  void MKLEltwiseLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
69        const vector<Blob<Dtype>*>& top) {
70    for (int i = 1; i < bottom.size(); ++i) {
71      CHECK(bottom[i]->shape() == bottom[0]->shape());
72    }
73    top[0]->ReshapeLike(*bottom[0]);
74    if (this->layer_param_.eltwise_param().operation() ==
75        EltwiseParameter_EltwiseOp_MAX && top.size() == 1) {
76      max_idx_.Reshape(bottom[0]->shape());
77    }
78    if (channels_ == bottom[0]->channels() &&
79        height_ == bottom[0]->height() &&
80        width_ == bottom[0]->width() &&
81        num_ == bottom[0]->num() &&
82        num_bottoms == bottom.size()) {
83      return;
84    }
85    Init(bottom, top);
86  }
87  template <typename Dtype>
88  void MKLEltwiseLayer<Dtype>::Forward_cpu(
89      const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
90    dnnError_t e;
91    vector<void*> bottom_data;
92    bool num_prv = 0;
93    for (size_t i = 0; i < num_bottoms; i++) {
94      bottom_data.push_back(
95        reinterpret_cast<void *>(const_cast<Dtype*>(bottom[i]->prv_data())));
96      if (bottom_data[i] != NULL) {
97        num_prv += 1;
98      } else {
99        bottom_data[i] =
100          reinterpret_cast<void *>(const_cast<Dtype*>(bottom[i]->cpu_data()));
101      }
102    }
103    if (num_prv > 0) {
104      if (sumPrimitive == NULL) {
105        dnnLayout_t int_layout = NULL;
106        for (size_t i = 0; i < num_bottoms; ++i) {
107          if (bottom[i]->prv_data() != NULL) {
108            CHECK((bottom[i]->get_prv_data_descriptor())->get_descr_type()
109              == PrvMemDescr::PRV_DESCR_MKL2017);
110            shared_ptr<MKLData<Dtype> > mem_descr =
111                boost::static_pointer_cast<MKLData<Dtype> >(
112                  bottom[i]->get_prv_data_descriptor());
113            CHECK(mem_descr != NULL);
114            fwd_bottom_data[i] = mem_descr;
115            if (int_layout == NULL) {
116              int_layout = mem_descr->layout_int;
117            }
118          }
119        }
120        e = dnnSumCreate<Dtype>(&sumPrimitive, NULL,
121          num_bottoms, int_layout, &coeffs_[0]);
122        CHECK_EQ(e, E_SUCCESS);
123        fwd_top_data->create_internal_layout(sumPrimitive, dnnResourceDst);
124        for (int i = 0; i < num_bottoms; ++i) {
125          if (bottom[i]->prv_data() == NULL) {
126            fwd_bottom_data[i]->create_internal_layout(sumPrimitive,
127                (dnnResourceType_t)(dnnResourceMultipleSrc + i));
128          }
129        }
130      }
131    } else {
132      if (sumPrimitive == NULL) {
133        e = dnnSumCreate<Dtype>(&sumPrimitive, NULL, num_bottoms,
134          fwd_top_data->layout_usr, &coeffs_[0]);
135        CHECK_EQ(e, E_SUCCESS);
136      }
137    }
138    switch (op_) {
139    case EltwiseParameter_EltwiseOp_SUM:
140      void *eltwise_res[dnnResourceNumber];
<span onclick='openModal()' class='match'>141      for (int i = 0; i < num_bottoms; ++i) {
142        if (fwd_bottom_data[i]->convert_to_int) {
143          eltwise_res[dnnResourceMultipleSrc + i] =
144            fwd_bottom_data[i]->get_converted_prv(bottom[i], false);
145        } else {
146          eltwise_res[dnnResourceMultipleSrc + i] =
147            reinterpret_cast<void *>(bottom_data[i]);
148        }
149      }
</span>150      if (fwd_top_data->conversion_needed()) {
151        top[0]->set_prv_data_descriptor(fwd_top_data);
152        eltwise_res[dnnResourceDst] =
153          reinterpret_cast<void*>(const_cast<Dtype*>(top[0]->mutable_prv_data()));
154      } else {
155        eltwise_res[dnnResourceDst] =
156          reinterpret_cast<void*>(const_cast<Dtype*>(top[0]->mutable_cpu_data()));
157      }
158      { 
159        PERFORMANCE_EVENT_ID_INIT(perf_id_fw_, PERFORMANCE_MKL_NAME("FW"));
160        PERFORMANCE_MEASUREMENT_BEGIN();
161        e = dnnExecute<Dtype>(sumPrimitive, eltwise_res);
162        PERFORMANCE_MEASUREMENT_END_ID(perf_id_fw_);
163      }
164      CHECK_EQ(e, E_SUCCESS);
165      break;
166    case EltwiseParameter_EltwiseOp_PROD:
167    case EltwiseParameter_EltwiseOp_MAX:
168      LOG(FATAL) << "Unsupported elementwise operation.";
169    default:
170      LOG(FATAL) << "Unknown elementwise operation.";
171    }
172  }
173  template <typename Dtype>
174  void MKLEltwiseLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
175      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
176    bool is_top_diff_prv = top[0]->prv_diff() == NULL ? false : true;
177    for (int i = 0; i < bottom.size(); ++i) {
178      if (propagate_down[i]) {
179        switch (op_) {
180        case EltwiseParameter_EltwiseOp_SUM:
181          CHECK_EQ(coeffs_[i], Dtype(1)) << "Not supported yet";
182          if (is_top_diff_prv == false) {
183            bottom[i]->set_cpu_diff(top[0]->mutable_cpu_diff());
184          } else {
185            if (!bwd_bottom_diff[i]->layout_int) {
186              bwd_bottom_diff[i]->create_internal_layout(sumPrimitive,
187                (dnnResourceType_t)(dnnResourceMultipleSrc + i));
188            }
189            CHECK_EQ(true, bwd_bottom_diff[i]->layout_compare(
190                    top[0]->get_prv_diff_descriptor()));
191            bottom[i]->set_prv_diff_descriptor(top[0]->get_prv_diff_descriptor(),
192                                               false);
193          }
194          break;
195        case EltwiseParameter_EltwiseOp_MAX:
196        case EltwiseParameter_EltwiseOp_PROD:
197          LOG(FATAL) << "Unsupported elementwise operation.";
198        default:
199          LOG(FATAL) << "Unknown elementwise operation.";
200        }
201      }
202    }
203  }
204  #ifdef CPU_ONLY
205  STUB_GPU(MKLEltwiseLayer);
206  #else
207  template <typename Dtype>
208  void MKLEltwiseLayer<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
209      const vector<Blob<Dtype>*>& top) {NOT_IMPLEMENTED;}
210  template <typename Dtype>
211  void MKLEltwiseLayer<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
212      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom)
213    {NOT_IMPLEMENTED;}
214  #endif
215  INSTANTIATE_CLASS(MKLEltwiseLayer);
216  }  
217  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_libc.cc</h3>
            <pre><code>1  #if defined(_WIN32) || defined(_WIN64)
2  #define _CRT_SECURE_NO_WARNINGS 1
3  #endif
4  #include "time_zone_libc.h"
5  #include <chrono>
6  #include <ctime>
7  #include <limits>
8  #include <utility>
9  #include "absl/base/config.h"
10  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
11  #include "absl/time/internal/cctz/include/cctz/time_zone.h"
12  #if defined(_AIX)
13  extern "C" {
14  extern long altzone;
15  }
16  #endif
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace time_internal {
20  namespace cctz {
21  namespace {
22  #if defined(_WIN32) || defined(_WIN64)
23  auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + _dstbias) {
24    const bool is_dst = tm.tm_isdst > 0;
25    return _timezone + (is_dst ? _dstbias : 0);
26  }
27  auto tm_zone(const std::tm& tm) -> decltype(_tzname[0]) {
28    const bool is_dst = tm.tm_isdst > 0;
29    return _tzname[is_dst];
30  }
31  #elif defined(__sun) || defined(_AIX)
32  auto tm_gmtoff(const std::tm& tm) -> decltype(timezone) {
33    const bool is_dst = tm.tm_isdst > 0;
34    return is_dst ? altzone : timezone;
35  }
36  auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
37    const bool is_dst = tm.tm_isdst > 0;
38    return tzname[is_dst];
39  }
40  #elif defined(__native_client__) || defined(__myriad2__) || \
41      defined(__EMSCRIPTEN__)
42  auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + 0) {
43    const bool is_dst = tm.tm_isdst > 0;
44    return _timezone + (is_dst ? 60 * 60 : 0);
45  }
46  auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
47    const bool is_dst = tm.tm_isdst > 0;
48    return tzname[is_dst];
49  }
50  #else
51  #if defined(tm_gmtoff)
52  auto tm_gmtoff(const std::tm& tm) -> decltype(tm.tm_gmtoff) {
53    return tm.tm_gmtoff;
54  }
55  #elif defined(__tm_gmtoff)
56  auto tm_gmtoff(const std::tm& tm) -> decltype(tm.__tm_gmtoff) {
57    return tm.__tm_gmtoff;
58  }
59  #else
60  template <typename T>
61  auto tm_gmtoff(const T& tm) -> decltype(tm.tm_gmtoff) {
62    return tm.tm_gmtoff;
63  }
64  template <typename T>
65  auto tm_gmtoff(const T& tm) -> decltype(tm.__tm_gmtoff) {
66    return tm.__tm_gmtoff;
67  }
68  #endif  
69  #if defined(tm_zone)
70  auto tm_zone(const std::tm& tm) -> decltype(tm.tm_zone) { return tm.tm_zone; }
71  #elif defined(__tm_zone)
72  auto tm_zone(const std::tm& tm) -> decltype(tm.__tm_zone) {
73    return tm.__tm_zone;
74  }
75  #else
76  template <typename T>
77  auto tm_zone(const T& tm) -> decltype(tm.tm_zone) {
78    return tm.tm_zone;
79  }
80  template <typename T>
81  auto tm_zone(const T& tm) -> decltype(tm.__tm_zone) {
82    return tm.__tm_zone;
83  }
84  #endif  
85  #endif
86  inline std::tm* gm_time(const std::time_t* timep, std::tm* result) {
87  #if defined(_WIN32) || defined(_WIN64)
88    return gmtime_s(result, timep) ? nullptr : result;
89  #else
90    return gmtime_r(timep, result);
91  #endif
92  }
93  inline std::tm* local_time(const std::time_t* timep, std::tm* result) {
94  #if defined(_WIN32) || defined(_WIN64)
95    return localtime_s(result, timep) ? nullptr : result;
96  #else
97    return localtime_r(timep, result);
98  #endif
99  }
100  bool make_time(const civil_second& cs, int is_dst, std::time_t* t, int* off) {
101    std::tm tm;
102    tm.tm_year = static_cast<int>(cs.year() - year_t{1900});
103    tm.tm_mon = cs.month() - 1;
104    tm.tm_mday = cs.day();
105    tm.tm_hour = cs.hour();
106    tm.tm_min = cs.minute();
107    tm.tm_sec = cs.second();
108    tm.tm_isdst = is_dst;
109    *t = std::mktime(&tm);
110    if (*t == std::time_t{-1}) {
111      std::tm tm2;
112      const std::tm* tmp = local_time(t, &tm2);
113      if (tmp == nullptr || tmp->tm_year != tm.tm_year ||
114          tmp->tm_mon != tm.tm_mon || tmp->tm_mday != tm.tm_mday ||
115          tmp->tm_hour != tm.tm_hour || tmp->tm_min != tm.tm_min ||
116          tmp->tm_sec != tm.tm_sec) {
117        return false;
118      }
119    }
120    *off = static_cast<int>(tm_gmtoff(tm));
121    return true;
122  }
123  std::time_t find_trans(std::time_t lo, std::time_t hi, int offset) {
124    std::tm tm;
125    while (lo + 1 != hi) {
126      const std::time_t mid = lo + (hi - lo) / 2;
127      std::tm* tmp = local_time(&mid, &tm);
<span onclick='openModal()' class='match'>128      if (tmp != nullptr) {
129        if (tm_gmtoff(*tmp) == offset) {
130          hi = mid;
131        } else {
132          lo = mid;
133        }
134      } else {
</span>135        while (++lo != hi) {
136          tmp = local_time(&lo, &tm);
137          if (tmp != nullptr) {
138            if (tm_gmtoff(*tmp) == offset) break;
139          }
140        }
141        return lo;
142      }
143    }
144    return hi;
145  }
146  }  
147  TimeZoneLibC::TimeZoneLibC(const std::string& name)
148      : local_(name == "localtime") {}
149  time_zone::absolute_lookup TimeZoneLibC::BreakTime(
150      const time_point<seconds>& tp) const {
151    time_zone::absolute_lookup al;
152    al.offset = 0;
153    al.is_dst = false;
154    al.abbr = "-00";
155    const std::int_fast64_t s = ToUnixSeconds(tp);
156    if (s < std::numeric_limits<std::time_t>::min()) {
157      al.cs = civil_second::min();
158      return al;
159    }
160    if (s > std::numeric_limits<std::time_t>::max()) {
161      al.cs = civil_second::max();
162      return al;
163    }
164    const std::time_t t = static_cast<std::time_t>(s);
165    std::tm tm;
166    std::tm* tmp = local_ ? local_time(&t, &tm) : gm_time(&t, &tm);
167    if (tmp == nullptr) {
168      al.cs = (s < 0) ? civil_second::min() : civil_second::max();
169      return al;
170    }
171    const year_t year = tmp->tm_year + year_t{1900};
172    al.cs = civil_second(year, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour,
173                         tmp->tm_min, tmp->tm_sec);
174    al.offset = static_cast<int>(tm_gmtoff(*tmp));
175    al.abbr = local_ ? tm_zone(*tmp) : "UTC";  
176    al.is_dst = tmp->tm_isdst > 0;
177    return al;
178  }
179  time_zone::civil_lookup TimeZoneLibC::MakeTime(const civil_second& cs) const {
180    if (!local_) {
181      static const civil_second min_tp_cs =
182          civil_second() + ToUnixSeconds(time_point<seconds>::min());
183      static const civil_second max_tp_cs =
184          civil_second() + ToUnixSeconds(time_point<seconds>::max());
185      const time_point<seconds> tp = (cs < min_tp_cs) ? time_point<seconds>::min()
186                                     : (cs > max_tp_cs)
187                                         ? time_point<seconds>::max()
188                                         : FromUnixSeconds(cs - civil_second());
189      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
190    }
191    if (cs.year() < 0) {
192      if (cs.year() < std::numeric_limits<int>::min() + year_t{1900}) {
193        const time_point<seconds> tp = time_point<seconds>::min();
194        return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
195      }
196    } else {
197      if (cs.year() - year_t{1900} > std::numeric_limits<int>::max()) {
198        const time_point<seconds> tp = time_point<seconds>::max();
199        return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
200      }
201    }
202    std::time_t t0, t1;
203    int offset0, offset1;
204    if (make_time(cs, 0, &t0, &offset0) && make_time(cs, 1, &t1, &offset1)) {
205      if (t0 == t1) {
206        const time_point<seconds> tp = FromUnixSeconds(t0);
207        return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
208      }
209      if (t0 > t1) {
210        std::swap(t0, t1);
211        std::swap(offset0, offset1);
212      }
213      const std::time_t tt = find_trans(t0, t1, offset1);
214      const time_point<seconds> trans = FromUnixSeconds(tt);
215      if (offset0 < offset1) {
216        const time_point<seconds> pre = FromUnixSeconds(t1);
217        const time_point<seconds> post = FromUnixSeconds(t0);
218        return {time_zone::civil_lookup::SKIPPED, pre, trans, post};
219      }
220      const time_point<seconds> pre = FromUnixSeconds(t0);
221      const time_point<seconds> post = FromUnixSeconds(t1);
222      return {time_zone::civil_lookup::REPEATED, pre, trans, post};
223    }
224    const time_point<seconds> tp = (cs < civil_second())
225                                       ? time_point<seconds>::min()
226                                       : time_point<seconds>::max();
227    return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
228  }
229  bool TimeZoneLibC::NextTransition(const time_point<seconds>&,
230                                    time_zone::civil_transition*) const {
231    return false;
232  }
233  bool TimeZoneLibC::PrevTransition(const time_point<seconds>&,
234                                    time_zone::civil_transition*) const {
235    return false;
236  }
237  std::string TimeZoneLibC::Version() const {
238    return std::string();  
239  }
240  std::string TimeZoneLibC::Description() const {
241    return local_ ? "localtime" : "UTC";
242  }
243  }  
244  }  
245  ABSL_NAMESPACE_END
246  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-mkl_eltwise_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_libc.cc</div>
                </div>
                <div class="column column_space"><pre><code>141      for (int i = 0; i < num_bottoms; ++i) {
142        if (fwd_bottom_data[i]->convert_to_int) {
143          eltwise_res[dnnResourceMultipleSrc + i] =
144            fwd_bottom_data[i]->get_converted_prv(bottom[i], false);
145        } else {
146          eltwise_res[dnnResourceMultipleSrc + i] =
147            reinterpret_cast<void *>(bottom_data[i]);
148        }
149      }
</pre></code></div>
                <div class="column column_space"><pre><code>128      if (tmp != nullptr) {
129        if (tm_gmtoff(*tmp) == offset) {
130          hi = mid;
131        } else {
132          lo = mid;
133        }
134      } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    