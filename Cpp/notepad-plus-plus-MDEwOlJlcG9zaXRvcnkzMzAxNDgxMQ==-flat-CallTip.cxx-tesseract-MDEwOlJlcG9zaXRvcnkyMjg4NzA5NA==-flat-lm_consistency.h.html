
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CallTip.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cassert>
4  #include <cstring>
5  #include <cstdio>
6  #include <cmath>
7  #include <stdexcept>
8  #include <string>
9  #include <string_view>
10  #include <vector>
11  #include <optional>
12  #include <algorithm>
13  #include <memory>
14  #include "ScintillaTypes.h"
15  #include "ScintillaMessages.h"
16  #include "Debugging.h"
17  #include "Geometry.h"
18  #include "Platform.h"
19  #include "Position.h"
20  #include "CallTip.h"
21  using namespace Scintilla;
22  using namespace Scintilla::Internal;
23  size_t Chunk::Length() const noexcept {
24  	return end - start;
25  }
26  CallTip::CallTip() noexcept {
27  	wCallTip = {};
28  	inCallTipMode = false;
29  	posStartCallTip = 0;
30  	rectUp = PRectangle(0,0,0,0);
31  	rectDown = PRectangle(0,0,0,0);
32  	lineHeight = 1;
33  	offsetMain = 0;
34  	tabSize = 0;
35  	above = false;
<span onclick='openModal()' class='match'>36  	useStyleCallTip = false;    
37  	insetX = 5;
38  	widthArrow = 14;
39  	borderHeight = 2; 
40  	verticalOffset = 1;
</span>41  #ifdef __APPLE__
42  	colourBG = ColourRGBA(0xff, 0xff, 0xc6);
43  	colourUnSel = ColourRGBA(0, 0, 0);
44  #else
45  	colourBG = ColourRGBA(0xff, 0xff, 0xff);
46  	colourUnSel = ColourRGBA(0x80, 0x80, 0x80);
47  #endif
48  	colourSel = ColourRGBA(0, 0, 0x80);
49  	colourShade = ColourRGBA(0, 0, 0);
50  	colourLight = ColourRGBA(0xc0, 0xc0, 0xc0);
51  	codePage = 0;
52  	clickPlace = 0;
53  }
54  CallTip::~CallTip() {
55  	wCallTip.Destroy();
56  }
57  bool CallTip::IsTabCharacter(char ch) const noexcept {
58  	return (tabSize > 0) && (ch == '\t');
59  }
60  int CallTip::NextTabPos(int x) const noexcept {
61  	if (tabSize > 0) {              
62  		x -= insetX;                
63  		x = (x + tabSize) / tabSize;  
64  		return tabSize*x + insetX;  
65  	} else {
66  		return x + 1;                 
67  	}
68  }
69  namespace {
70  constexpr bool IsArrowCharacter(char ch) noexcept {
71  	return (ch == 0) || (ch == '\001') || (ch == '\002');
72  }
73  void DrawArrow(Surface *surface, const PRectangle &rc, bool upArrow, ColourRGBA colourBG, ColourRGBA colourUnSel) {
74  	surface->FillRectangle(rc, colourBG);
75  	const PRectangle rcClientInner = Clamp(rc.Inset(1), Edge::right, rc.right - 2);
76  	surface->FillRectangle(rcClientInner, colourUnSel);
77  	const XYPOSITION width = std::floor(rcClientInner.Width());
78  	const XYPOSITION halfWidth = std::floor(width / 2) - 1;
79  	const XYPOSITION quarterWidth = std::floor(halfWidth / 2);
80  	const XYPOSITION centreX = rcClientInner.left + width / 2;
81  	const XYPOSITION centreY = std::floor((rcClientInner.top + rcClientInner.bottom) / 2);
82  	constexpr XYPOSITION pixelMove = 0.0f;
83  	if (upArrow) {      
84  		const Point pts[] = {
85  			Point(centreX - halfWidth + pixelMove, centreY + quarterWidth + 0.5f),
86  			Point(centreX + halfWidth + pixelMove, centreY + quarterWidth + 0.5f),
87  			Point(centreX + pixelMove, centreY - halfWidth + quarterWidth + 0.5f),
88  		};
89  		surface->Polygon(pts, std::size(pts), FillStroke(colourBG));
90  	} else {            
91  		const Point pts[] = {
92  			Point(centreX - halfWidth + pixelMove, centreY - quarterWidth + 0.5f),
93  			Point(centreX + halfWidth + pixelMove, centreY - quarterWidth + 0.5f),
94  			Point(centreX + pixelMove, centreY + halfWidth - quarterWidth + 0.5f),
95  		};
96  		surface->Polygon(pts, std::size(pts), FillStroke(colourBG));
97  	}
98  }
99  }
100  int CallTip::DrawChunk(Surface *surface, int x, std::string_view sv,
101  	int ytext, PRectangle rcClient, bool asHighlight, bool draw) {
102  	if (sv.empty()) {
103  		return x;
104  	}
105  	std::vector<size_t> ends(1);
106  	for (size_t i=0; i<sv.length(); i++) {
107  		if (IsArrowCharacter(sv[i]) || IsTabCharacter(sv[i])) {
108  			if (ends.back() != i)
109  				ends.push_back(i);
110  			ends.push_back(i+1);
111  		}
112  	}
113  	if (ends.back() != sv.length())
114  		ends.push_back(sv.length());
115  	ends.erase(ends.begin());	
116  	size_t startSeg = 0;
117  	for (const size_t endSeg : ends) {
118  		assert(endSeg > 0);
119  		int xEnd;
120  		if (IsArrowCharacter(sv[startSeg])) {
121  			xEnd = x + widthArrow;
122  			const bool upArrow = sv[startSeg] == '\001';
123  			rcClient.left = static_cast<XYPOSITION>(x);
124  			rcClient.right = static_cast<XYPOSITION>(xEnd);
125  			if (draw) {
126  				DrawArrow(surface, rcClient, upArrow, colourBG, colourUnSel);
127  			}
128  			offsetMain = xEnd;
129  			if (upArrow) {
130  				rectUp = rcClient;
131  			} else {
132  				rectDown = rcClient;
133  			}
134  		} else if (IsTabCharacter(sv[startSeg])) {
135  			xEnd = NextTabPos(x);
136  		} else {
137  			const std::string_view segText = sv.substr(startSeg, endSeg - startSeg);
138  			xEnd = x + static_cast<int>(std::lround(surface->WidthText(font.get(), segText)));
139  			if (draw) {
140  				rcClient.left = static_cast<XYPOSITION>(x);
141  				rcClient.right = static_cast<XYPOSITION>(xEnd);
142  				surface->DrawTextTransparent(rcClient, font.get(), static_cast<XYPOSITION>(ytext),
143  									segText, asHighlight ? colourSel : colourUnSel);
144  			}
145  		}
146  		x = xEnd;
147  		startSeg = endSeg;
148  	}
149  	return x;
150  }
151  int CallTip::PaintContents(Surface *surfaceWindow, bool draw) {
152  	const PRectangle rcClientPos = wCallTip.GetClientPosition();
153  	const PRectangle rcClientSize(0.0f, 0.0f, rcClientPos.right - rcClientPos.left,
154  	                        rcClientPos.bottom - rcClientPos.top);
155  	PRectangle rcClient(1.0f, 1.0f, rcClientSize.right - 1, rcClientSize.bottom - 1);
156  	const int ascent = static_cast<int>(std::round(surfaceWindow->Ascent(font.get()) - surfaceWindow->InternalLeading(font.get())));
157  	int ytext = static_cast<int>(rcClient.top) + ascent + 1;
158  	rcClient.bottom = ytext + surfaceWindow->Descent(font.get()) + 1;
159  	std::string_view remaining(val);
160  	int maxWidth = 0;
161  	size_t lineStart = 0;
162  	while (!remaining.empty()) {
163  		const std::string_view chunkVal = remaining.substr(0, remaining.find_first_of('\n'));
164  		remaining.remove_prefix(chunkVal.length());
165  		if (!remaining.empty()) {
166  			remaining.remove_prefix(1);	
167  		}
168  		const Chunk chunkLine(lineStart, lineStart + chunkVal.length());
169  		Chunk chunkHighlight(
170  			std::clamp(highlight.start, chunkLine.start, chunkLine.end),
171  			std::clamp(highlight.end, chunkLine.start, chunkLine.end)
172  		);
173  		chunkHighlight.start -= lineStart;
174  		chunkHighlight.end -= lineStart;
175  		rcClient.top = static_cast<XYPOSITION>(ytext - ascent - 1);
176  		int x = insetX;     
177  		x = DrawChunk(surfaceWindow, x,
178  			chunkVal.substr(0, chunkHighlight.start),
179  			ytext, rcClient, false, draw);
180  		x = DrawChunk(surfaceWindow, x,
181  			chunkVal.substr(chunkHighlight.start, chunkHighlight.Length()),
182  			ytext, rcClient, true, draw);
183  		x = DrawChunk(surfaceWindow, x,
184  			chunkVal.substr(chunkHighlight.end),
185  			ytext, rcClient, false, draw);
186  		ytext += lineHeight;
187  		rcClient.bottom += lineHeight;
188  		maxWidth = std::max(maxWidth, x);
189  		lineStart += chunkVal.length() + 1;
190  	}
191  	return maxWidth;
192  }
193  void CallTip::PaintCT(Surface *surfaceWindow) {
194  	if (val.empty())
195  		return;
196  	const PRectangle rcClientPos = wCallTip.GetClientPosition();
197  	const PRectangle rcClientSize(0.0f, 0.0f, rcClientPos.right - rcClientPos.left,
198  	                        rcClientPos.bottom - rcClientPos.top);
199  	const PRectangle rcClient(1.0f, 1.0f, rcClientSize.right - 1, rcClientSize.bottom - 1);
200  	surfaceWindow->FillRectangle(rcClient, colourBG);
201  	offsetMain = insetX;    
202  	PaintContents(surfaceWindow, true);
203  #if !defined(__APPLE__) && !PLAT_CURSES
204  	constexpr XYPOSITION border = 1.0f;
205  	surfaceWindow->FillRectangle(Side(rcClientSize, Edge::left, border), colourLight);
206  	surfaceWindow->FillRectangle(Side(rcClientSize, Edge::right, border), colourShade);
207  	surfaceWindow->FillRectangle(Side(rcClientSize, Edge::bottom, border), colourShade);
208  	surfaceWindow->FillRectangle(Side(rcClientSize, Edge::top, border), colourLight);
209  #endif
210  }
211  void CallTip::MouseClick(Point pt) noexcept {
212  	clickPlace = 0;
213  	if (rectUp.Contains(pt))
214  		clickPlace = 1;
215  	if (rectDown.Contains(pt))
216  		clickPlace = 2;
217  }
218  PRectangle CallTip::CallTipStart(Sci::Position pos, Point pt, int textHeight, const char *defn,
219                                   int codePage_, Surface *surfaceMeasure, std::shared_ptr<Font> font_) {
220  	clickPlace = 0;
221  	val = defn;
222  	codePage = codePage_;
223  	highlight = Chunk();
224  	inCallTipMode = true;
225  	posStartCallTip = pos;
226  	font = font_;
227  	const int numLines = 1 + static_cast<int>(std::count(val.begin(), val.end(), '\n'));
228  	rectUp = PRectangle(0,0,0,0);
229  	rectDown = PRectangle(0,0,0,0);
230  	offsetMain = insetX;            
231  	lineHeight = static_cast<int>(std::lround(surfaceMeasure->Height(font.get())));
232  #if !PLAT_CURSES
233  	widthArrow = lineHeight * 9 / 10;
234  #endif
235  	const int width = PaintContents(surfaceMeasure, false) + insetX;
236  	const int height = lineHeight * numLines - static_cast<int>(surfaceMeasure->InternalLeading(font.get())) + borderHeight * 2;
237  	if (above) {
238  		return PRectangle(pt.x - offsetMain, pt.y - verticalOffset - height, pt.x + width - offsetMain, pt.y - verticalOffset);
239  	} else {
240  		return PRectangle(pt.x - offsetMain, pt.y + verticalOffset + textHeight, pt.x + width - offsetMain, pt.y + verticalOffset + textHeight + height);
241  	}
242  }
243  void CallTip::CallTipCancel() noexcept {
244  	inCallTipMode = false;
245  	if (wCallTip.Created()) {
246  		wCallTip.Destroy();
247  	}
248  }
249  void CallTip::SetHighlight(size_t start, size_t end) {
250  	if ((start != highlight.start) || (end != highlight.end)) {
251  		highlight.start = start;
252  		highlight.end = (end > start) ? end : start;
253  		if (wCallTip.Created()) {
254  			wCallTip.InvalidateAll();
255  		}
256  	}
257  }
258  void CallTip::SetTabSize(int tabSz) noexcept {
259  	tabSize = tabSz;
260  	useStyleCallTip = true;
261  }
262  void CallTip::SetPosition(bool aboveText) noexcept {
263  	above = aboveText;
264  }
265  bool CallTip::UseStyleCallTip() const noexcept {
266  	return useStyleCallTip;
267  }
268  void CallTip::SetForeBack(ColourRGBA fore, ColourRGBA back) noexcept {
269  	colourBG = back;
270  	colourUnSel = fore;
271  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lm_consistency.h</h3>
            <pre><code>1  #ifndef TESSERACT_WORDREC_LM_CONSISTENCY_H_
2  #define TESSERACT_WORDREC_LM_CONSISTENCY_H_
3  #include <cstdint> 
4  #include "dawg.h"  
5  #include "dict.h"  
6  class BLOB_CHOICE;
7  namespace tesseract {
8  static const char *const XHeightConsistencyEnumName[] = {
9      "XH_GOOD",
10      "XH_SUBNORMAL",
11      "XH_INCONSISTENT",
12  };
13  struct LMConsistencyInfo {
14    enum ChartypeEnum { CT_NONE, CT_ALPHA, CT_DIGIT, CT_OTHER };
15    static const int kShiftThresh = 1;
16    static const int kMaxEntropy = 1;
17    static const int kSUB = 0, kNORM = 1, kSUP = 2;
18    static const int kNumPos = 3;
19    explicit LMConsistencyInfo(const LMConsistencyInfo *parent_info) {
20      if (parent_info == nullptr) {
21        num_alphas = 0;
22        num_digits = 0;
23        num_punc = 0;
24        num_other = 0;
25        chartype = CT_NONE;
26        punc_ref = NO_EDGE;
<span onclick='openModal()' class='match'>27        invalid_punc = false;
28        num_non_first_upper = 0;
29        num_lower = 0;
30        script_id = 0;
31        inconsistent_script = false;
</span>32        num_inconsistent_spaces = 0;
33        inconsistent_font = false;
34        for (int i = 0; i < kNumPos; i++) {
35          xht_count[i] = 0;
36          xht_count_punc[i] = 0;
37          xht_lo[i] = 0;
38          xht_hi[i] = 256; 
39        }
40        xht_sp = -1; 
41        xpos_entropy = 0;
42        xht_decision = XH_GOOD;
43      } else {
44        *this = *parent_info;
45      }
46    }
47    inline int NumInconsistentPunc() const {
48      return invalid_punc ? num_punc : 0;
49    }
50    inline int NumInconsistentCase() const {
51      return (num_non_first_upper > num_lower) ? num_lower : num_non_first_upper;
52    }
53    inline int NumInconsistentChartype() const {
54      return (NumInconsistentPunc() + num_other +
55              ((num_alphas > num_digits) ? num_digits : num_alphas));
56    }
57    inline bool Consistent() const {
58      return (NumInconsistentPunc() == 0 && NumInconsistentCase() == 0 &&
59              NumInconsistentChartype() == 0 && !inconsistent_script && !inconsistent_font &&
60              !InconsistentXHeight());
61    }
62    inline int NumInconsistentSpaces() const {
63      return num_inconsistent_spaces;
64    }
65    inline int InconsistentXHeight() const {
66      return xht_decision == XH_INCONSISTENT;
67    }
68    void ComputeXheightConsistency(const BLOB_CHOICE *b, bool is_punc);
69    float BodyMinXHeight() const {
70      if (InconsistentXHeight()) {
71        return 0.0f;
72      }
73      return xht_lo[kNORM];
74    }
75    float BodyMaxXHeight() const {
76      if (InconsistentXHeight()) {
77        return static_cast<float>(INT16_MAX);
78      }
79      return xht_hi[kNORM];
80    }
81    EDGE_REF punc_ref;
82    int num_alphas;
83    int num_digits;
84    int num_punc;
85    int num_other;
86    ChartypeEnum chartype;
87    XHeightConsistencyEnum xht_decision;
88    int num_non_first_upper;
89    int num_lower;
90    int script_id;
91    int num_inconsistent_spaces;
92    float xht_lo[kNumPos];
93    float xht_hi[kNumPos];
94    int16_t xht_count[kNumPos];
95    int16_t xht_count_punc[kNumPos];
96    int16_t xht_sp;
97    int16_t xpos_entropy;
98    bool invalid_punc;
99    bool inconsistent_script;
100    bool inconsistent_font;
101  };
102  } 
103  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-CallTip.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lm_consistency.h</div>
                </div>
                <div class="column column_space"><pre><code>36  	useStyleCallTip = false;    
37  	insetX = 5;
38  	widthArrow = 14;
39  	borderHeight = 2; 
40  	verticalOffset = 1;
</pre></code></div>
                <div class="column column_space"><pre><code>27        invalid_punc = false;
28        num_non_first_upper = 0;
29        num_lower = 0;
30        script_id = 0;
31        inconsistent_script = false;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    