
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "functionListPanel.h"
3  #include "xmlMatchedTagsHighlighter.h"
4  #include "VerticalFileSwitcher.h"
5  #include "ProjectPanel.h"
6  #include "documentMap.h"
7  #include "Common.h"
8  #include <stack>
9  using namespace std;
10  BOOL Notepad_plus::notify(SCNotification *notification)
11  {
12  	bool isFromPrimary = (_mainEditView.getHSelf() == notification->nmhdr.hwndFrom || _mainDocTab.getHSelf() == notification->nmhdr.hwndFrom);
13  	bool isFromSecondary = !isFromPrimary && (_subEditView.getHSelf() == notification->nmhdr.hwndFrom || _subDocTab.getHSelf() == notification->nmhdr.hwndFrom);
14  	ScintillaEditView * notifyView = nullptr;
15  	if (isFromPrimary)
16  		notifyView = &_mainEditView;
17  	else if (isFromSecondary)
18  		notifyView = &_subEditView;
19  	DocTabView *notifyDocTab = isFromPrimary?&_mainDocTab:&_subDocTab;
20  	TBHDR * tabNotification = (TBHDR*) notification;
21  	switch (notification->nmhdr.code)
22  	{
23  		case SCN_MODIFIED:
24  		{
25  			if (!notifyView)
26  				return FALSE;
27  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT))
28  			{
29  				_pEditView->updateBeginEndSelectPosition(notification->modificationType & SC_MOD_INSERTTEXT, notification->position, notification->length);
30  				_linkTriggered = true;
31  				::InvalidateRect(notifyView->getHSelf(), NULL, TRUE);
32  			}
33  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT | SC_PERFORMED_UNDO | SC_PERFORMED_REDO))
34  			{
35  				_pEditView->getCurrentBuffer()->setModifiedStatus(true);
36  			}
37  			if (notification->modificationType & SC_MOD_CHANGEINDICATOR)
38  			{
39  				::InvalidateRect(notifyView->getHSelf(), NULL, FALSE);
40  			}
41  			break;
42  		}
43  		case SCN_SAVEPOINTREACHED:
44  		case SCN_SAVEPOINTLEFT:
45  		{
46  			Buffer * buf = 0;
47  			if (isFromPrimary)
48  			{
49  				buf = _mainEditView.getCurrentBuffer();
50  			}
51  			else if (isFromSecondary)
52  			{
53  				buf = _subEditView.getCurrentBuffer();
54  			}
55  			else
56  			{
57  				BufferID id = BUFFER_INVALID;
58  				if (notification->nmhdr.hwndFrom == _invisibleEditView.getHSelf())
59  				{
60  					id = MainFileManager.getBufferFromDocument(_invisibleEditView.execute(SCI_GETDOCPOINTER));
61  				}
62  				else if (notification->nmhdr.hwndFrom == _fileEditView.getHSelf())
63  				{
64  					id = MainFileManager.getBufferFromDocument(_fileEditView.execute(SCI_GETDOCPOINTER));
65  				}
66  				else
67  					break;	
68  				if (id != BUFFER_INVALID)
69  				{
70  					buf = MainFileManager.getBufferByID(id);
71  				}
72  				else
73  					break;
74  			}
75  			bool isDirty = notification->nmhdr.code == SCN_SAVEPOINTLEFT;
76  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
77  			if (isSnapshotMode && !isDirty)
78  			{
79  				bool canUndo = _pEditView->execute(SCI_CANUNDO) == TRUE;
80  				if (!canUndo && buf->isLoadedDirty() && buf->isDirty())
81  					isDirty = true;
82  			}
83  			if (buf->isUnsync()) 
84  				isDirty = true;
85  			if (buf->isSavePointDirty())
86  				isDirty = true;
87  			buf->setDirty(isDirty);
88  			break;
89  		}
90  		case SCN_MODIFYATTEMPTRO:
91  		{
92  			break;
93  		}
94  		case SCN_KEY:
95  		{
96  			break;
97  		}
98  		case TCN_MOUSEHOVERING:
99  		case TCN_MOUSEHOVERSWITCHING:
100  		{
101  			NppParameters& nppParam = NppParameters::getInstance();
102  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
103  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
104  			if (doPeekOnTab)
105  			{
106  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
107  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
108  				if (pTabDocView)
109  				{
110  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
111  					Buffer *pBuf = MainFileManager.getBufferByID(id);
112  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
113  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
114  					RECT rect{};
115  					TabCtrl_GetItemRect(pTabDocView->getHSelf(), tbHdr->_tabOrigin, &rect);
116  					POINT p{};
117  					p.x = rect.left;
118  					p.y = rect.bottom;
119  					::ClientToScreen(pTabDocView->getHSelf(), &p);
120  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
121  					{
122  						_documentPeeker.doDialog(p, pBuf, *(const_cast<ScintillaEditView*>(pTabDocView->getScintillaEditView())));
123  					}
124  					else  
125  					{
126  						_documentPeeker.display(false);
127  					}
128  				}
129  			}
130  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
131  			{
132  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
133  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
134  				if (pTabDocView)
135  				{
136  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
137  					Buffer *pBuf = MainFileManager.getBufferByID(id);
138  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
139  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
140  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
141  					{
142  						_pDocMap->showInMapTemporarily(pBuf, notifyView);
143  						_pDocMap->setSyntaxHiliting();
144  					}
145  					else  
146  					{
147  						_pDocMap->reloadMap();
148  						_pDocMap->setSyntaxHiliting();
149  					}
150  					_pDocMap->setTemporarilyShowing(true);
151  				}
152  			}
153  			break;
154  		}
155  		case TCN_MOUSELEAVING:
156  		{
157  			NppParameters& nppParam = NppParameters::getInstance();
158  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
159  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
160  			if (doPeekOnTab)
161  			{
162  				_documentPeeker.display(false);
163  			}
164  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
165  			{
166  				_pDocMap->reloadMap();
167  				_pDocMap->setSyntaxHiliting();
168  				_pDocMap->setTemporarilyShowing(false);
169  			}
170  			break;
171  		}
172  		case TCN_TABDROPPEDOUTSIDE:
173  		case TCN_TABDROPPED:
174  		{
175  			TabBarPlus *sender = reinterpret_cast<TabBarPlus *>(notification->nmhdr.idFrom);
176  			bool isInCtrlStat = (::GetKeyState(VK_LCONTROL) & 0x80000000) != 0;
177  			if (notification->nmhdr.code == TCN_TABDROPPEDOUTSIDE)
178  			{
179  				POINT p = sender->getDraggingPoint();
180  				HWND hWin = ::WindowFromPoint(p);
181  				if (hWin == _pEditView->getHSelf()) 
182  				{
183  					if (!_tabPopupDropMenu.isCreated())
184  					{
185  						TCHAR goToView[32] = TEXT("Move to Other View");
186  						TCHAR cloneToView[32] = TEXT("Clone to Other View");
187  						vector<MenuItemUnit> itemUnitArray;
188  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, goToView));
189  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, cloneToView));
190  						_tabPopupDropMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
191  						_nativeLangSpeaker.changeLangTabDropContextMenu(_tabPopupDropMenu.getMenuHandle());
192  					}
193  					_tabPopupDropMenu.display(p);
194  				}
195  				else if ((hWin == _pNonDocTab->getHSelf()) ||
196  						 (hWin == _pNonEditView->getHSelf())) 
197  				{
198  					docGotoAnotherEditView(isInCtrlStat?TransferClone:TransferMove);
199  				}
200  				else
201  				{
202  					RECT nppZone{};
203  					::GetWindowRect(_pPublicInterface->getHSelf(), &nppZone);
204  					bool isInNppZone = (((p.x >= nppZone.left) && (p.x <= nppZone.right)) && (p.y >= nppZone.top) && (p.y <= nppZone.bottom));
205  					if (isInNppZone)
206  					{
207  						return TRUE;
208  					}
209  					generic_string quotFileName = TEXT("\"");
210  					quotFileName += _pEditView->getCurrentBuffer()->getFullPathName();
211  					quotFileName += TEXT("\"");
212  					COPYDATASTRUCT fileNamesData{};
213  					fileNamesData.dwData = COPYDATA_FILENAMESW;
214  					fileNamesData.lpData = (void *)quotFileName.c_str();
215  					fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
216  					HWND hWinParent = ::GetParent(hWin);
217  					const rsize_t classNameBufferSize = MAX_PATH;
218  					TCHAR className[classNameBufferSize];
219  					::GetClassName(hWinParent,className, classNameBufferSize);
220  					if (lstrcmp(className, _pPublicInterface->getClassName()) == 0 && hWinParent != _pPublicInterface->getHSelf()) 
221  					{
222  						int index = _pDocTab->getCurrentTabIndex();
223  						BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
224  						Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
225  						int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
226  						if (buf->isDirty())
227  						{
228  							generic_string msg, title;
229  							_nativeLangSpeaker.messageBox("CannotMoveDoc",
230  								_pPublicInterface->getHSelf(),
231  								TEXT("Document is modified, save it then try again."),
232  								TEXT("Move to new Notepad++ Instance"),
233  								MB_OK);
234  						}
235  						else
236  						{
237  							::SendMessage(hWinParent, NPPM_INTERNAL_SWITCHVIEWFROMHWND, 0, reinterpret_cast<LPARAM>(hWin));
238  							::SendMessage(hWinParent, WM_COPYDATA, reinterpret_cast<WPARAM>(_pPublicInterface->getHinst()), reinterpret_cast<LPARAM>(&fileNamesData));
239  							if (!isInCtrlStat)
240  							{
241  								fileClose(bufferToClose, iView);
242  								if (noOpenedDoc())
243  									::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
244  							}
245  						}
246  					}
247  					else 
248  					{
249  						docOpenInNewInstance(isInCtrlStat?TransferClone:TransferMove, p.x, p.y);
250  					}
251  				}
252  			}
253  			sender->resetDraggingPoint();
254  			return TRUE;
255  		}
256  		case TCN_TABDELETE:
257  		{
258  			int index = tabNotification->_tabOrigin;
259  			BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
260  			Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
261  			int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
262  			if (buf->isDirty())
263  			{
264  				activateBuffer(bufferToClose, iView);
265  			}
266  			if (fileClose(bufferToClose, iView))
267  				checkDocState();
268  			break;
269  		}
270  		case TCN_SELCHANGE:
271  		{
272  			int iView = -1;
273  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
274  			{
275  				iView = MAIN_VIEW;
276  			}
277  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
278  			{
279  				iView = SUB_VIEW;
280  			}
281  			else
282  				break;
283  			_documentPeeker.saveCurrentSnapshot(*_pEditView);
284  			switchEditViewTo(iView);
285  			BufferID bufid = _pDocTab->getBufferByIndex(_pDocTab->getCurrentTabIndex());
286  			if (bufid != BUFFER_INVALID)
287  			{
288  				_isFolding = true; 
289  				activateBuffer(bufid, iView);
290  				_isFolding = false;
291  			}
292  			_documentPeeker.display(false);
293  			break;
294  		}
295  		case NM_CLICK :
296  		{
297  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
298  			{
299  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
300  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_TYPING_MODE))
301  				{
302  					bool isOverTypeMode = (_pEditView->execute(SCI_GETOVERTYPE) != 0);
303  					_pEditView->execute(SCI_SETOVERTYPE, !isOverTypeMode);
304  					_statusBar.setText((_pEditView->execute(SCI_GETOVERTYPE))?TEXT("OVR"):TEXT("INS"), STATUSBAR_TYPING_MODE);
305  				}
306  			}
307  			else if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf() && _activeView == SUB_VIEW)
308  			{
309  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
310  				if (isSnapshotMode)
311  				{
312  					MainFileManager.backupCurrentBuffer();
313  				}
314  				switchEditViewTo(MAIN_VIEW);
315  			}
316  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf() && _activeView == MAIN_VIEW)
317  			{
318  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
319  				if (isSnapshotMode)
320  				{
321  					MainFileManager.backupCurrentBuffer();
322  				}
323  				switchEditViewTo(SUB_VIEW);
324  			}
325  			break;
326  		}
327  		case NM_DBLCLK :
328  		{
329  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
330  			{
331  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
332  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_CUR_POS))
333  				{
334  					bool isFirstTime = !_goToLineDlg.isCreated();
335  					_goToLineDlg.doDialog(_nativeLangSpeaker.isRTL());
336  					if (isFirstTime)
337  						_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
338  				}
339  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_SIZE))
340  				{
341  					command(IDM_VIEW_SUMMARY);
342  				}
343  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
344  				{
345  					POINT p;
346  					::GetCursorPos(&p);
347  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
348  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
349  				}
350  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
351  				{
352  					POINT p;
353  					::GetCursorPos(&p);
354  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
355  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
356  					if (!hEditMenu)
357  						return TRUE;
358  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
359  					if (!hEolFormatMenu)
360  						return TRUE;
361  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
362  				}
363  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
364  				{
365  					POINT p;
366  					::GetCursorPos(&p);
367  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
368  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
369  				}
370  			}
371  			break;
372  		}
373  		case NM_RCLICK :
374  		{
375  			POINT p;
376  			::GetCursorPos(&p);
377  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
378  			{
379  				switchEditViewTo(MAIN_VIEW);
380  			}
381  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
382  			{
383  				switchEditViewTo(SUB_VIEW);
384  			}
385  			else if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())  
386  			{
387  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
388  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
389  				{
390  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
391  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
392  				}
393  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
394  				{
395  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
396  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
397  					if (!hEditMenu)
398  						return TRUE;
399  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
400  					if (!hEolFormatMenu)
401  						return TRUE;
402  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
403  				}
404  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
405  				{
406  					POINT p;
407  					::GetCursorPos(&p);
408  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
409  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
410  				}
411  				return TRUE;
412  			}
413  			else if (_pDocumentListPanel && notification->nmhdr.hwndFrom == _pDocumentListPanel->getHSelf())
414  			{
415  				if (_pDocumentListPanel->nbSelectedFiles() > 1)
416  				{
417  					if (!_fileSwitcherMultiFilePopupMenu.isCreated())
418  					{
419  						vector<MenuItemUnit> itemUnitArray;
420  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSE, TEXT("Close Selected files")));
421  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSEOTHERS, TEXT("Close Other files")));
422  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYNAMES, TEXT("Copy Selected Names")));
423  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYPATHS, TEXT("Copy Selected Pathnames")));
424  						for (auto&& x : itemUnitArray)
425  						{
426  							const generic_string menuItem = _nativeLangSpeaker.getNativeLangMenuString(x._cmdID);
427  							if (!menuItem.empty())
428  								x._itemName = menuItem;
429  						}
430  						_fileSwitcherMultiFilePopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray);
431  					}
432  					_fileSwitcherMultiFilePopupMenu.display(p);
433  					return TRUE;
434  				}
435  			}
436  			else 
437  				return TRUE;
438  			if (!_tabPopupMenu.isCreated())
439  			{
440  				std::vector<MenuItemUnit> itemUnitArray;
441  				NppParameters& nppParam = NppParameters::getInstance();
442  				if (nppParam.hasCustomTabContextMenu())
443  				{
444  					itemUnitArray = nppParam.getTabContextMenuItems();
445  				}
446  				else 
447  				{
448  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSE, TEXT("Close")));
449  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_BUT_CURRENT, TEXT("Close All BUT This"), TEXT("Close Multiple Tabs")));
450  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TOLEFT, TEXT("Close All to the Left"), TEXT("Close Multiple Tabs")));
451  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TORIGHT, TEXT("Close All to the Right"), TEXT("Close Multiple Tabs")));
452  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_UNCHANGED, TEXT("Close All Unchanged"), TEXT("Close Multiple Tabs")));
453  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVE, TEXT("Save")));
454  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVEAS, TEXT("Save As...")));
455  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_FOLDER, TEXT("Open Containing Folder in Explorer"), TEXT("Open into")));
456  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_CMD, TEXT("Open Containing Folder in cmd"), TEXT("Open into")));
457  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CONTAININGFOLDERASWORKSPACE, TEXT("Open Containing Folder as Workspace"), TEXT("Open into")));
458  					itemUnitArray.push_back(MenuItemUnit(0, NULL, TEXT("Open into")));
459  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_DEFAULT_VIEWER, TEXT("Open in Default Viewer"), TEXT("Open into")));
460  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RENAME, TEXT("Rename")));
461  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_DELETE, TEXT("Move to Recycle Bin")));
462  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RELOAD, TEXT("Reload")));
463  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_PRINT, TEXT("Print")));
464  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
465  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_SETREADONLY, TEXT("Read-Only")));
466  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CLEARREADONLY, TEXT("Clear Read-Only Flag")));
467  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
468  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FULLPATHTOCLIP, TEXT("Copy Full File Path"), TEXT("Copy to Clipboard")));
469  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FILENAMETOCLIP, TEXT("Copy Filename"), TEXT("Copy to Clipboard")));
470  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CURRENTDIRTOCLIP, TEXT("Copy Current Dir. Path"), TEXT("Copy to Clipboard")));
471  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, TEXT("Move to Other View"), TEXT("Move Document")));
472  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, TEXT("Clone to Other View"), TEXT("Move Document")));
473  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_NEW_INSTANCE, TEXT("Move to New Instance"), TEXT("Move Document")));
474  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_LOAD_IN_NEW_INSTANCE, TEXT("Open in New Instance"), TEXT("Move Document")));
475  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_1, TEXT("Apply Color 1"), TEXT("Apply Color to Tab")));
476  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_2, TEXT("Apply Color 2"), TEXT("Apply Color to Tab")));
477  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_3, TEXT("Apply Color 3"), TEXT("Apply Color to Tab")));
478  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_4, TEXT("Apply Color 4"), TEXT("Apply Color to Tab")));
479  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_5, TEXT("Apply Color 5"), TEXT("Apply Color to Tab")));
480  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_NONE, TEXT("Remove Color"), TEXT("Apply Color to Tab")));
481  				}
482  				_tabPopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
483  				_nativeLangSpeaker.changeLangTabContextMenu(_tabPopupMenu.getMenuHandle());
484  			}
485  			for (int i = 0; i < 5; ++i)
486  			{
487  				COLORREF colour = NppDarkMode::getIndividualTabColour(i, NppDarkMode::isDarkMenuEnabled(), true);
488  				HBITMAP hBitmap = generateSolidColourMenuItemIcon(colour);
489  				SetMenuItemBitmaps(_tabPopupMenu.getMenuHandle(), IDM_VIEW_TAB_COLOUR_1 + i, MF_BYCOMMAND, hBitmap, hBitmap);
490  			}
491  			bool isEnable = ((::GetMenuState(_mainMenuHandle, IDM_FILE_SAVE, MF_BYCOMMAND)&MF_DISABLED) == 0);
492  			_tabPopupMenu.enableItem(IDM_FILE_SAVE, isEnable);
493  			Buffer * buf = _pEditView->getCurrentBuffer();
494  			bool isUserReadOnly = buf->getUserReadOnly();
495  			_tabPopupMenu.checkItem(IDM_EDIT_SETREADONLY, isUserReadOnly);
496  			bool isSysReadOnly = buf->getFileReadOnly();
497  			_tabPopupMenu.enableItem(IDM_EDIT_SETREADONLY, !isSysReadOnly && !buf->isMonitoringOn());
498  			_tabPopupMenu.enableItem(IDM_EDIT_CLEARREADONLY, isSysReadOnly);
499  			bool isFileExisting = PathFileExists(buf->getFullPathName()) != FALSE;
500  			_tabPopupMenu.enableItem(IDM_FILE_DELETE, isFileExisting);
501  			_tabPopupMenu.enableItem(IDM_FILE_RELOAD, isFileExisting);
502  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_FOLDER, isFileExisting);
503  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_CMD, isFileExisting);
504  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_DEFAULT_VIEWER, isAssoCommandExisting(buf->getFullPathName()));
505  			bool isDirty = buf->isDirty();
506  			bool isUntitled = buf->isUntitled();
507  			_tabPopupMenu.enableItem(IDM_VIEW_GOTO_NEW_INSTANCE, !(isDirty||isUntitled));
508  			_tabPopupMenu.enableItem(IDM_VIEW_LOAD_IN_NEW_INSTANCE, !(isDirty||isUntitled));
509  			_tabPopupMenu.display(p);
510  			return TRUE;
511  		}
512  		case SCN_MARGINCLICK:
513  		{
514  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
<span onclick='openModal()' class='match'>515  				switchEditViewTo(MAIN_VIEW);
516  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
517  				switchEditViewTo(SUB_VIEW);
518  			intptr_t lineClick = _pEditView->execute(SCI_LINEFROMPOSITION, notification->position);
</span>519  			if (notification->margin == ScintillaEditView::_SC_MARGE_FOLDER)
520  			{
521  				_pEditView->marginClick(notification->position, notification->modifiers);
522  				if (_pDocMap)
523  					_pDocMap->fold(lineClick, _pEditView->isFolded(lineClick));
524  				ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
525  				_smartHighlighter.highlightView(_pEditView, unfocusView);
526  			}
527  			else if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
528  			{
529  				if (!_pEditView->markerMarginClick(lineClick))
530  					bookmarkToggle(lineClick);
531  			}
532  			break;
533  		}
534  		case SCN_MARGINRIGHTCLICK:
535  		{
536  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
537  				switchEditViewTo(MAIN_VIEW);
538  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
539  				switchEditViewTo(SUB_VIEW);
540  			if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
541  			{
542  				POINT p;
543  				::GetCursorPos(&p);
544  				MenuPosition& menuPos = getMenuPosition("search-bookmark");
545  				HMENU hSearchMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
546  				if (hSearchMenu)
547  				{
548  					HMENU hBookmarkMenu = ::GetSubMenu(hSearchMenu, menuPos._y);
549  					if (hBookmarkMenu)
550  					{
551  						TrackPopupMenu(hBookmarkMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
552  					}
553  				}
554  			}
555  			break;
556  		}
557  		case SCN_FOLDINGSTATECHANGED :
558  		{
559  			if ((notification->nmhdr.hwndFrom == _mainEditView.getHSelf()) || (notification->nmhdr.hwndFrom == _subEditView.getHSelf()))
560  			{
561  				size_t lineClicked = notification->line;
562  				if (!_isFolding)
563  				{
564  					addHotSpot();
565  				}
566  				if (_pDocMap)
567  					_pDocMap->fold(lineClicked, _pEditView->isFolded(lineClicked));
568  			}
569  			return TRUE;
570  		}
571  		case SCN_CHARADDED:
572  		{
573  			if (!_recordingMacro && !_playingBackMacro) 
574  			{
575  				const NppGUI & nppGui = NppParameters::getInstance().getNppGUI();
576  				bool indentMaintain = nppGui._maitainIndent;
577  				if (indentMaintain)
578  					maintainIndentation(static_cast<TCHAR>(notification->ch));
579  				Buffer* currentBuf = _pEditView->getCurrentBuffer();
580  				if (currentBuf->allowAutoCompletion())
581  				{
582  					AutoCompletion* autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
583  					bool isColumnMode = _pEditView->execute(SCI_GETSELECTIONS) > 1; 
584  					if (nppGui._matchedPairConf.hasAnyPairsPair() && !isColumnMode)
585  						autoC->insertMatchedChars(notification->ch, nppGui._matchedPairConf);
586  					autoC->update(notification->ch);
587  				}
588  			}
589  			break;
590  		}
591  		case SCN_DOUBLECLICK:
592  		{
593  			if (!notifyView)
594  				return FALSE;
595  			if (notification->modifiers == SCMOD_CTRL)
596  			{
597  				const NppGUI & nppGUI = NppParameters::getInstance().getNppGUI();
598  				std::string bufstring;
599  				size_t position_of_click;
600  				if (notification->position != -1)
601  					position_of_click = notification->position;
602  				else
603  					position_of_click = _pEditView->execute(SCI_GETCURRENTPOS);
604  				{
605  					char *buf;
606  					if (nppGUI._delimiterSelectionOnEntireDocument)
607  					{
608  						auto length = notifyView->execute(SCI_GETLENGTH);
609  						buf = new char[length + 1];
610  						notifyView->execute(SCI_GETTEXT, length + 1, reinterpret_cast<LPARAM>(buf));
611  					}
612  					else
613  					{
614  						auto length = notifyView->execute(SCI_GETCURLINE);
615  						buf = new char[length + 1];
616  						notifyView->execute(SCI_GETCURLINE, length, reinterpret_cast<LPARAM>(buf));
617  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
618  						position_of_click = position_of_click - line_position;
619  					}
620  					bufstring = buf;
621  					delete [] buf;
622  				}
623  				int leftmost_position = -1;
624  				int rightmost_position = -1;
625  				if (nppGUI._rightmostDelimiter == nppGUI._leftmostDelimiter)
626  				{
627  					for (int32_t i = static_cast<int32_t>(position_of_click); i >= 0; --i)
628  					{
629  						if (i >= static_cast<int32_t>(bufstring.size()))
630  							return FALSE;
631  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
632  						{
633  							if (nppGUI._leftmostDelimiter == '"')
634  							{
635  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
636  								{
637  									leftmost_position = i;
638  									break;
639  								}
640  							}
641  							else
642  							{
643  								leftmost_position = i;
644  								break;
645  							}
646  						}
647  					}
648  					if (leftmost_position == -1)
649  						break;
650  					for (size_t i = position_of_click; i < bufstring.length(); ++i)
651  					{
652  						if (bufstring.at(i) == nppGUI._rightmostDelimiter)
653  						{
654  							if (nppGUI._rightmostDelimiter == '"')
655  							{
656  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
657  								{
658  									rightmost_position = static_cast<int32_t>(i);
659  									break;
660  								}
661  							}
662  							else
663  							{
664  								rightmost_position = static_cast<int32_t>(i);
665  								break;
666  							}
667  						}
668  					}
669  				}
670  				else
671  				{
672  					std::stack<unsigned int> leftmost_delimiter_positions;
673  					for (unsigned int i = 0; i < bufstring.length(); ++i)
674  					{
675  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
676  							leftmost_delimiter_positions.push(i);
677  						else if (bufstring.at(i) == nppGUI._rightmostDelimiter && ! leftmost_delimiter_positions.empty())
678  						{
679  							unsigned int matching_leftmost = leftmost_delimiter_positions.top();
680  							leftmost_delimiter_positions.pop();
681  							assert( (leftmost_position == -1 && rightmost_position == -1) || (leftmost_position >= 0 && rightmost_position >= 0) );
682  							if (matching_leftmost <= position_of_click && i >= position_of_click && (leftmost_position == -1 || matching_leftmost > static_cast<unsigned int>(leftmost_position)))
683  							{
684  								leftmost_position = matching_leftmost;
685  								rightmost_position = i;
686  							}
687  						}
688  					}
689  				}
690  				if (rightmost_position != -1 && leftmost_position != -1)
691  				{
692  					if (nppGUI._delimiterSelectionOnEntireDocument)
693  					{
694  						notifyView->execute(SCI_SETCURRENTPOS, rightmost_position);
695  						notifyView->execute(SCI_SETANCHOR, leftmost_position + 1);
696  					}
697  					else
698  					{
699  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
700  						notifyView->execute(SCI_SETCURRENTPOS, line_position + rightmost_position);
701  						notifyView->execute(SCI_SETANCHOR, line_position + leftmost_position + 1);
702  					}
703  				}
704  			}
705  			else
706  			{ 
707  				auto indicMsk = notifyView->execute(SCI_INDICATORALLONFOR, notification->position);
708  				if (!(indicMsk & (1 << URL_INDIC)))
709  					break;
710  				auto startPos = notifyView->execute(SCI_INDICATORSTART, URL_INDIC, notification->position);
711  				auto endPos = notifyView->execute(SCI_INDICATOREND, URL_INDIC, notification->position);
712  				if ((notification->position < startPos) || (notification->position > endPos))
713  					break;
714  				::PostMessage(notifyView->getHSelf(), WM_LBUTTONUP, 0, 0);
715  				notifyView->execute(SCI_SETSEL, notification->position, notification->position); 
716  				generic_string url = notifyView->getGenericTextAsString(static_cast<size_t>(startPos), static_cast<size_t>(endPos));
717  				::ShellExecute(_pPublicInterface->getHSelf(), TEXT("open"), url.c_str(), NULL, NULL, SW_SHOW);
718  			}
719  			break;
720  		}
721  		case SCN_UPDATEUI:
722  		{
723  			if (!notifyView)
724  				return FALSE;
725  			NppParameters& nppParam = NppParameters::getInstance();
726  			NppGUI & nppGui = nppParam.getNppGUI();
727  			if (notification->updated & SC_UPDATE_V_SCROLL)
728  			{
729  				addHotSpot(notifyView);
730  			}
731  			if (nppParam._isFindReplacing)
732  				break;
733  			Buffer* currentBuf = _pEditView->getCurrentBuffer();
734  			if (notification->nmhdr.hwndFrom != _pEditView->getHSelf() && currentBuf->allowSmartHilite()) 
735  			{
736  				if (nppGui._smartHiliteOnAnotherView)
737  				{
738  					TCHAR selectedText[1024];
739  					_pEditView->getGenericSelectedText(selectedText, sizeof(selectedText)/sizeof(TCHAR), false);
740  					_smartHighlighter.highlightViewWithWord(notifyView, selectedText);
741  				}
742  				break;
743  			}
744  			braceMatch();
745  			if (nppGui._enableTagsMatchHilite)
746  			{
747  				XmlMatchedTagsHighlighter xmlTagMatchHiliter(_pEditView);
748  				xmlTagMatchHiliter.tagMatch(nppGui._enableTagAttrsHilite);
749  			}
750  			if (nppGui._enableSmartHilite && currentBuf->allowSmartHilite())
751  			{
752  				if (nppGui._disableSmartHiliteTmp)
753  					nppGui._disableSmartHiliteTmp = false;
754  				else
755  				{
756  					ScintillaEditView * anbotherView = isFromPrimary ? &_subEditView : &_mainEditView;
757  					_smartHighlighter.highlightView(notifyView, anbotherView);
758  				}
759  			}
760  			bool selectionIsChanged = (notification->updated & SC_UPDATE_SELECTION) != 0;
761  			bool contentIsChanged = (notification->updated & SC_UPDATE_CONTENT) != 0;
762  			if (selectionIsChanged || contentIsChanged)
763  			{
764  				updateStatusBar();
765  			}
766  			if (_pFuncList && (!_pFuncList->isClosed()) && _pFuncList->isVisible())
767  				_pFuncList->markEntry();
768  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
769  			autoC->update(0);
770  			break;
771  		}
772  		case TTN_GETDISPINFO:
773  		{
774  			try
775  			{
776  				LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
777  				lpttt->hinst = NULL;
778  				POINT p;
779  				::GetCursorPos(&p);
780  				::MapWindowPoints(NULL, _pPublicInterface->getHSelf(), &p, 1);
781  				HWND hWin = ::ChildWindowFromPointEx(_pPublicInterface->getHSelf(), p, CWP_SKIPINVISIBLE);
782  				const int tipMaxLen = 1024;
783  				static TCHAR docTip[tipMaxLen];
784  				docTip[0] = '\0';
785  				generic_string tipTmp(TEXT(""));
786  				int id = int(lpttt->hdr.idFrom);
787  				if (hWin == _rebarTop.getHSelf())
788  				{
789  					getNameStrFromCmd(id, tipTmp);
790  					if (tipTmp.length() >= 80)
791  						return FALSE;
792  					wcscpy_s(lpttt->szText, tipTmp.c_str());
793  					return TRUE;
794  				}
795  				else if (hWin == _mainDocTab.getHSelf())
796  				{
797  					BufferID idd = _mainDocTab.getBufferByIndex(id);
798  					Buffer * buf = MainFileManager.getBufferByID(idd);
799  					if (buf == nullptr)
800  						return FALSE;
801  					tipTmp = buf->getFullPathName();
802  					if (tipTmp.length() >= tipMaxLen)
803  						return FALSE;
804  					wcscpy_s(docTip, tipTmp.c_str());
805  					lpttt->lpszText = docTip;
806  					return TRUE;
807  				}
808  				else if (hWin == _subDocTab.getHSelf())
809  				{
810  					BufferID idd = _subDocTab.getBufferByIndex(id);
811  					Buffer * buf = MainFileManager.getBufferByID(idd);
812  					if (buf == nullptr)
813  						return FALSE;
814  					tipTmp = buf->getFullPathName();
815  					if (tipTmp.length() >= tipMaxLen)
816  						return FALSE;
817  					wcscpy_s(docTip, tipTmp.c_str());
818  					lpttt->lpszText = docTip;
819  					return TRUE;
820  				}
821  				else
822  					return FALSE;
823  			}
824  			catch (...)
825  			{
826  			}
827  			break;
828  		}
829  		case SCN_ZOOM:
830  		{
831  			if (!notifyView)
832  				return FALSE;
833  			ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
834  			_smartHighlighter.highlightView(notifyView, unfocusView);
835  			break;
836  		}
837  		case SCN_MACRORECORD:
838  		{
839  			_macro.push_back(
840  				recordedMacroStep(
841  					notification->message,
842  					notification->wParam,
843  					notification->lParam
844  				)
845  			);
846  			break;
847  		}
848  		case SCN_PAINTED:
849  		{
850  			if (!notifyView)
851  				return FALSE;
852  			_mainEditView.restoreCurrentPosPostStep();
853  			_subEditView.restoreCurrentPosPostStep();
854  			if (_mainEditView.isWrapRestoreNeeded())
855  			{
856  				_mainEditView.restoreCurrentPosPreStep();
857  				_mainEditView.setWrapRestoreNeeded(false);
858  			}
859  			if (_subEditView.isWrapRestoreNeeded())
860  			{
861  				_subEditView.restoreCurrentPosPreStep();
862  				_subEditView.setWrapRestoreNeeded(false);
863  			}
864  			notifyView->updateLineNumberWidth();
865  			if (_syncInfo.doSync())
866  				doSynScorll(HWND(notification->nmhdr.hwndFrom));
867  			NppParameters& nppParam = NppParameters::getInstance();
868  			if ((_linkTriggered && !nppParam._isFindReplacing) || notification->wParam == LINKTRIGGERED)
869  			{
870  				addHotSpot();
871  				_linkTriggered = false;
872  			}
873  			if (_pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible() && !_pDocMap->isTemporarilyShowing())
874  			{
875  				_pDocMap->wrapMap();
876  				_pDocMap->scrollMap();
877  			}
878  			break;
879  		}
880  		case SCN_NEEDSHOWN:
881  		{
882  			break;
883  		}
884  		case SCN_CALLTIPCLICK:
885  		{
886  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
887  			autoC->callTipClick(notification->position);
888  			break;
889  		}
890  		case SCN_AUTOCSELECTION:
891  		{
892  			const NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
893  			if (nppGui._autocStatus == NppGUI::AutocStatus::autoc_none)
894  			{
895  				break;
896  			}
897  			if (notification->listCompletionMethod == SC_AC_NEWLINE && !nppGui._autocInsertSelectedUseENTER)
898  			{
899  				notifyView->execute(SCI_AUTOCCANCEL);
900  				notifyView->execute(SCI_NEWLINE);
901  			}
902  			if (notification->listCompletionMethod == SC_AC_TAB && !nppGui._autocInsertSelectedUseTAB)
903  			{
904  				notifyView->execute(SCI_AUTOCCANCEL);
905  				notifyView->execute(SCI_TAB);
906  			}
907  			break;
908  		}
909  		case RBN_HEIGHTCHANGE:
910  		{
911  			SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
912  			break;
913  		}
914  		case RBN_CHEVRONPUSHED:
915  		{
916  			NMREBARCHEVRON * lpnm = reinterpret_cast<NMREBARCHEVRON *>(notification);
917  			ReBar * notifRebar = &_rebarTop;
918  			if (_rebarBottom.getHSelf() == lpnm->hdr.hwndFrom)
919  				notifRebar = &_rebarBottom;
920  			if (lpnm->wID == REBAR_BAR_TOOLBAR)
921  			{
922  				POINT pt{};
923  				pt.x = lpnm->rc.left;
924  				pt.y = lpnm->rc.bottom;
925  				ClientToScreen(notifRebar->getHSelf(), &pt);
926  				_toolBar.doPopop(pt);
927  				return TRUE;
928  			}
929  			REBARBANDINFO rbBand;
930  			ZeroMemory(&rbBand, REBARBAND_SIZE);
931  			rbBand.cbSize = REBARBAND_SIZE;
932  			rbBand.fMask = RBBIM_CHILD;
933  			::SendMessage(notifRebar->getHSelf(), RB_GETBANDINFO, lpnm->uBand, reinterpret_cast<LPARAM>(&rbBand));
934  			::SendMessage(rbBand.hwndChild, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(lpnm));
935  			break;
936  		}
937  		default:
938  			break;
939  	}
940  	return FALSE;
941  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "functionListPanel.h"
3  #include "xmlMatchedTagsHighlighter.h"
4  #include "VerticalFileSwitcher.h"
5  #include "ProjectPanel.h"
6  #include "documentMap.h"
7  #include "Common.h"
8  #include <stack>
9  using namespace std;
10  BOOL Notepad_plus::notify(SCNotification *notification)
11  {
12  	bool isFromPrimary = (_mainEditView.getHSelf() == notification->nmhdr.hwndFrom || _mainDocTab.getHSelf() == notification->nmhdr.hwndFrom);
13  	bool isFromSecondary = !isFromPrimary && (_subEditView.getHSelf() == notification->nmhdr.hwndFrom || _subDocTab.getHSelf() == notification->nmhdr.hwndFrom);
14  	ScintillaEditView * notifyView = nullptr;
15  	if (isFromPrimary)
16  		notifyView = &_mainEditView;
17  	else if (isFromSecondary)
18  		notifyView = &_subEditView;
19  	DocTabView *notifyDocTab = isFromPrimary?&_mainDocTab:&_subDocTab;
20  	TBHDR * tabNotification = (TBHDR*) notification;
21  	switch (notification->nmhdr.code)
22  	{
23  		case SCN_MODIFIED:
24  		{
25  			if (!notifyView)
26  				return FALSE;
27  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT))
28  			{
29  				_pEditView->updateBeginEndSelectPosition(notification->modificationType & SC_MOD_INSERTTEXT, notification->position, notification->length);
30  				_linkTriggered = true;
31  				::InvalidateRect(notifyView->getHSelf(), NULL, TRUE);
32  			}
33  			if (notification->modificationType & (SC_MOD_DELETETEXT | SC_MOD_INSERTTEXT | SC_PERFORMED_UNDO | SC_PERFORMED_REDO))
34  			{
35  				_pEditView->getCurrentBuffer()->setModifiedStatus(true);
36  			}
37  			if (notification->modificationType & SC_MOD_CHANGEINDICATOR)
38  			{
39  				::InvalidateRect(notifyView->getHSelf(), NULL, FALSE);
40  			}
41  			break;
42  		}
43  		case SCN_SAVEPOINTREACHED:
44  		case SCN_SAVEPOINTLEFT:
45  		{
46  			Buffer * buf = 0;
47  			if (isFromPrimary)
48  			{
49  				buf = _mainEditView.getCurrentBuffer();
50  			}
51  			else if (isFromSecondary)
52  			{
53  				buf = _subEditView.getCurrentBuffer();
54  			}
55  			else
56  			{
57  				BufferID id = BUFFER_INVALID;
58  				if (notification->nmhdr.hwndFrom == _invisibleEditView.getHSelf())
59  				{
60  					id = MainFileManager.getBufferFromDocument(_invisibleEditView.execute(SCI_GETDOCPOINTER));
61  				}
62  				else if (notification->nmhdr.hwndFrom == _fileEditView.getHSelf())
63  				{
64  					id = MainFileManager.getBufferFromDocument(_fileEditView.execute(SCI_GETDOCPOINTER));
65  				}
66  				else
67  					break;	
68  				if (id != BUFFER_INVALID)
69  				{
70  					buf = MainFileManager.getBufferByID(id);
71  				}
72  				else
73  					break;
74  			}
75  			bool isDirty = notification->nmhdr.code == SCN_SAVEPOINTLEFT;
76  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
77  			if (isSnapshotMode && !isDirty)
78  			{
79  				bool canUndo = _pEditView->execute(SCI_CANUNDO) == TRUE;
80  				if (!canUndo && buf->isLoadedDirty() && buf->isDirty())
81  					isDirty = true;
82  			}
83  			if (buf->isUnsync()) 
84  				isDirty = true;
85  			if (buf->isSavePointDirty())
86  				isDirty = true;
87  			buf->setDirty(isDirty);
88  			break;
89  		}
90  		case SCN_MODIFYATTEMPTRO:
91  		{
92  			break;
93  		}
94  		case SCN_KEY:
95  		{
96  			break;
97  		}
98  		case TCN_MOUSEHOVERING:
99  		case TCN_MOUSEHOVERSWITCHING:
100  		{
101  			NppParameters& nppParam = NppParameters::getInstance();
102  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
103  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
104  			if (doPeekOnTab)
105  			{
106  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
107  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
108  				if (pTabDocView)
109  				{
110  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
111  					Buffer *pBuf = MainFileManager.getBufferByID(id);
112  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
113  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
114  					RECT rect{};
115  					TabCtrl_GetItemRect(pTabDocView->getHSelf(), tbHdr->_tabOrigin, &rect);
116  					POINT p{};
117  					p.x = rect.left;
118  					p.y = rect.bottom;
119  					::ClientToScreen(pTabDocView->getHSelf(), &p);
120  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
121  					{
122  						_documentPeeker.doDialog(p, pBuf, *(const_cast<ScintillaEditView*>(pTabDocView->getScintillaEditView())));
123  					}
124  					else  
125  					{
126  						_documentPeeker.display(false);
127  					}
128  				}
129  			}
130  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
131  			{
132  				TBHDR *tbHdr = reinterpret_cast<TBHDR *>(notification);
133  				DocTabView *pTabDocView = isFromPrimary ? &_mainDocTab : (isFromSecondary ? &_subDocTab : nullptr);
134  				if (pTabDocView)
135  				{
136  					BufferID id = pTabDocView->getBufferByIndex(tbHdr->_tabOrigin);
137  					Buffer *pBuf = MainFileManager.getBufferByID(id);
138  					Buffer *currentBufMain = _mainEditView.getCurrentBuffer();
139  					Buffer *currentBufSub = _subEditView.getCurrentBuffer();
140  					if (pBuf != currentBufMain && pBuf != currentBufSub) 
141  					{
142  						_pDocMap->showInMapTemporarily(pBuf, notifyView);
143  						_pDocMap->setSyntaxHiliting();
144  					}
145  					else  
146  					{
147  						_pDocMap->reloadMap();
148  						_pDocMap->setSyntaxHiliting();
149  					}
150  					_pDocMap->setTemporarilyShowing(true);
151  				}
152  			}
153  			break;
154  		}
155  		case TCN_MOUSELEAVING:
156  		{
157  			NppParameters& nppParam = NppParameters::getInstance();
158  			bool doPeekOnTab = nppParam.getNppGUI()._isDocPeekOnTab;
159  			bool doPeekOnMap = nppParam.getNppGUI()._isDocPeekOnMap;
160  			if (doPeekOnTab)
161  			{
162  				_documentPeeker.display(false);
163  			}
164  			if (doPeekOnMap && _pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible())
165  			{
166  				_pDocMap->reloadMap();
167  				_pDocMap->setSyntaxHiliting();
168  				_pDocMap->setTemporarilyShowing(false);
169  			}
170  			break;
171  		}
172  		case TCN_TABDROPPEDOUTSIDE:
173  		case TCN_TABDROPPED:
174  		{
175  			TabBarPlus *sender = reinterpret_cast<TabBarPlus *>(notification->nmhdr.idFrom);
176  			bool isInCtrlStat = (::GetKeyState(VK_LCONTROL) & 0x80000000) != 0;
177  			if (notification->nmhdr.code == TCN_TABDROPPEDOUTSIDE)
178  			{
179  				POINT p = sender->getDraggingPoint();
180  				HWND hWin = ::WindowFromPoint(p);
181  				if (hWin == _pEditView->getHSelf()) 
182  				{
183  					if (!_tabPopupDropMenu.isCreated())
184  					{
185  						TCHAR goToView[32] = TEXT("Move to Other View");
186  						TCHAR cloneToView[32] = TEXT("Clone to Other View");
187  						vector<MenuItemUnit> itemUnitArray;
188  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, goToView));
189  						itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, cloneToView));
190  						_tabPopupDropMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
191  						_nativeLangSpeaker.changeLangTabDropContextMenu(_tabPopupDropMenu.getMenuHandle());
192  					}
193  					_tabPopupDropMenu.display(p);
194  				}
195  				else if ((hWin == _pNonDocTab->getHSelf()) ||
196  						 (hWin == _pNonEditView->getHSelf())) 
197  				{
198  					docGotoAnotherEditView(isInCtrlStat?TransferClone:TransferMove);
199  				}
200  				else
201  				{
202  					RECT nppZone{};
203  					::GetWindowRect(_pPublicInterface->getHSelf(), &nppZone);
204  					bool isInNppZone = (((p.x >= nppZone.left) && (p.x <= nppZone.right)) && (p.y >= nppZone.top) && (p.y <= nppZone.bottom));
205  					if (isInNppZone)
206  					{
207  						return TRUE;
208  					}
209  					generic_string quotFileName = TEXT("\"");
210  					quotFileName += _pEditView->getCurrentBuffer()->getFullPathName();
211  					quotFileName += TEXT("\"");
212  					COPYDATASTRUCT fileNamesData{};
213  					fileNamesData.dwData = COPYDATA_FILENAMESW;
214  					fileNamesData.lpData = (void *)quotFileName.c_str();
215  					fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
216  					HWND hWinParent = ::GetParent(hWin);
217  					const rsize_t classNameBufferSize = MAX_PATH;
218  					TCHAR className[classNameBufferSize];
219  					::GetClassName(hWinParent,className, classNameBufferSize);
220  					if (lstrcmp(className, _pPublicInterface->getClassName()) == 0 && hWinParent != _pPublicInterface->getHSelf()) 
221  					{
222  						int index = _pDocTab->getCurrentTabIndex();
223  						BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
224  						Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
225  						int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
226  						if (buf->isDirty())
227  						{
228  							generic_string msg, title;
229  							_nativeLangSpeaker.messageBox("CannotMoveDoc",
230  								_pPublicInterface->getHSelf(),
231  								TEXT("Document is modified, save it then try again."),
232  								TEXT("Move to new Notepad++ Instance"),
233  								MB_OK);
234  						}
235  						else
236  						{
237  							::SendMessage(hWinParent, NPPM_INTERNAL_SWITCHVIEWFROMHWND, 0, reinterpret_cast<LPARAM>(hWin));
238  							::SendMessage(hWinParent, WM_COPYDATA, reinterpret_cast<WPARAM>(_pPublicInterface->getHinst()), reinterpret_cast<LPARAM>(&fileNamesData));
239  							if (!isInCtrlStat)
240  							{
241  								fileClose(bufferToClose, iView);
242  								if (noOpenedDoc())
243  									::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
244  							}
245  						}
246  					}
247  					else 
248  					{
249  						docOpenInNewInstance(isInCtrlStat?TransferClone:TransferMove, p.x, p.y);
250  					}
251  				}
252  			}
253  			sender->resetDraggingPoint();
254  			return TRUE;
255  		}
256  		case TCN_TABDELETE:
257  		{
258  			int index = tabNotification->_tabOrigin;
259  			BufferID bufferToClose = notifyDocTab->getBufferByIndex(index);
260  			Buffer * buf = MainFileManager.getBufferByID(bufferToClose);
261  			int iView = isFromPrimary?MAIN_VIEW:SUB_VIEW;
262  			if (buf->isDirty())
263  			{
264  				activateBuffer(bufferToClose, iView);
265  			}
266  			if (fileClose(bufferToClose, iView))
267  				checkDocState();
268  			break;
269  		}
270  		case TCN_SELCHANGE:
271  		{
272  			int iView = -1;
273  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
274  			{
275  				iView = MAIN_VIEW;
276  			}
277  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
278  			{
279  				iView = SUB_VIEW;
280  			}
281  			else
282  				break;
283  			_documentPeeker.saveCurrentSnapshot(*_pEditView);
284  			switchEditViewTo(iView);
285  			BufferID bufid = _pDocTab->getBufferByIndex(_pDocTab->getCurrentTabIndex());
286  			if (bufid != BUFFER_INVALID)
287  			{
288  				_isFolding = true; 
289  				activateBuffer(bufid, iView);
290  				_isFolding = false;
291  			}
292  			_documentPeeker.display(false);
293  			break;
294  		}
295  		case NM_CLICK :
296  		{
297  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
298  			{
299  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
300  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_TYPING_MODE))
301  				{
302  					bool isOverTypeMode = (_pEditView->execute(SCI_GETOVERTYPE) != 0);
303  					_pEditView->execute(SCI_SETOVERTYPE, !isOverTypeMode);
304  					_statusBar.setText((_pEditView->execute(SCI_GETOVERTYPE))?TEXT("OVR"):TEXT("INS"), STATUSBAR_TYPING_MODE);
305  				}
306  			}
307  			else if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf() && _activeView == SUB_VIEW)
308  			{
309  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
310  				if (isSnapshotMode)
311  				{
312  					MainFileManager.backupCurrentBuffer();
313  				}
314  				switchEditViewTo(MAIN_VIEW);
315  			}
316  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf() && _activeView == MAIN_VIEW)
317  			{
318  				bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
319  				if (isSnapshotMode)
320  				{
321  					MainFileManager.backupCurrentBuffer();
322  				}
323  				switchEditViewTo(SUB_VIEW);
324  			}
325  			break;
326  		}
327  		case NM_DBLCLK :
328  		{
329  			if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())
330  			{
331  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
332  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_CUR_POS))
333  				{
334  					bool isFirstTime = !_goToLineDlg.isCreated();
335  					_goToLineDlg.doDialog(_nativeLangSpeaker.isRTL());
336  					if (isFirstTime)
337  						_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
338  				}
339  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_SIZE))
340  				{
341  					command(IDM_VIEW_SUMMARY);
342  				}
343  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
344  				{
345  					POINT p;
346  					::GetCursorPos(&p);
347  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
348  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
349  				}
350  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
351  				{
352  					POINT p;
353  					::GetCursorPos(&p);
354  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
355  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
356  					if (!hEditMenu)
357  						return TRUE;
358  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
359  					if (!hEolFormatMenu)
360  						return TRUE;
361  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
362  				}
363  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
364  				{
365  					POINT p;
366  					::GetCursorPos(&p);
367  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
368  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
369  				}
370  			}
371  			break;
372  		}
373  		case NM_RCLICK :
374  		{
375  			POINT p;
376  			::GetCursorPos(&p);
377  			if (notification->nmhdr.hwndFrom == _mainDocTab.getHSelf())
378  			{
379  				switchEditViewTo(MAIN_VIEW);
380  			}
381  			else if (notification->nmhdr.hwndFrom == _subDocTab.getHSelf())
382  			{
383  				switchEditViewTo(SUB_VIEW);
384  			}
385  			else if (notification->nmhdr.hwndFrom == _statusBar.getHSelf())  
386  			{
387  				LPNMMOUSE lpnm = (LPNMMOUSE)notification;
388  				if (lpnm->dwItemSpec == DWORD(STATUSBAR_DOC_TYPE))
389  				{
390  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_LANGUAGE);
391  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
392  				}
393  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_EOF_FORMAT))
394  				{
395  					MenuPosition & menuPos = getMenuPosition("edit-eolConversion");
396  					HMENU hEditMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
397  					if (!hEditMenu)
398  						return TRUE;
399  					HMENU hEolFormatMenu = ::GetSubMenu(hEditMenu, menuPos._y);
400  					if (!hEolFormatMenu)
401  						return TRUE;
402  					TrackPopupMenu(hEolFormatMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
403  				}
404  				else if (lpnm->dwItemSpec == DWORD(STATUSBAR_UNICODE_TYPE))
405  				{
406  					POINT p;
407  					::GetCursorPos(&p);
408  					HMENU hLangMenu = ::GetSubMenu(_mainMenuHandle, MENUINDEX_FORMAT);
409  					TrackPopupMenu(hLangMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
410  				}
411  				return TRUE;
412  			}
413  			else if (_pDocumentListPanel && notification->nmhdr.hwndFrom == _pDocumentListPanel->getHSelf())
414  			{
415  				if (_pDocumentListPanel->nbSelectedFiles() > 1)
416  				{
417  					if (!_fileSwitcherMultiFilePopupMenu.isCreated())
418  					{
419  						vector<MenuItemUnit> itemUnitArray;
420  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSE, TEXT("Close Selected files")));
421  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_FILESCLOSEOTHERS, TEXT("Close Other files")));
422  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYNAMES, TEXT("Copy Selected Names")));
423  						itemUnitArray.push_back(MenuItemUnit(IDM_DOCLIST_COPYPATHS, TEXT("Copy Selected Pathnames")));
424  						for (auto&& x : itemUnitArray)
425  						{
426  							const generic_string menuItem = _nativeLangSpeaker.getNativeLangMenuString(x._cmdID);
427  							if (!menuItem.empty())
428  								x._itemName = menuItem;
429  						}
430  						_fileSwitcherMultiFilePopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray);
431  					}
432  					_fileSwitcherMultiFilePopupMenu.display(p);
433  					return TRUE;
434  				}
435  			}
436  			else 
437  				return TRUE;
438  			if (!_tabPopupMenu.isCreated())
439  			{
440  				std::vector<MenuItemUnit> itemUnitArray;
441  				NppParameters& nppParam = NppParameters::getInstance();
442  				if (nppParam.hasCustomTabContextMenu())
443  				{
444  					itemUnitArray = nppParam.getTabContextMenuItems();
445  				}
446  				else 
447  				{
448  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSE, TEXT("Close")));
449  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_BUT_CURRENT, TEXT("Close All BUT This"), TEXT("Close Multiple Tabs")));
450  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TOLEFT, TEXT("Close All to the Left"), TEXT("Close Multiple Tabs")));
451  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_TORIGHT, TEXT("Close All to the Right"), TEXT("Close Multiple Tabs")));
452  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CLOSEALL_UNCHANGED, TEXT("Close All Unchanged"), TEXT("Close Multiple Tabs")));
453  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVE, TEXT("Save")));
454  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_SAVEAS, TEXT("Save As...")));
455  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_FOLDER, TEXT("Open Containing Folder in Explorer"), TEXT("Open into")));
456  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_CMD, TEXT("Open Containing Folder in cmd"), TEXT("Open into")));
457  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_CONTAININGFOLDERASWORKSPACE, TEXT("Open Containing Folder as Workspace"), TEXT("Open into")));
458  					itemUnitArray.push_back(MenuItemUnit(0, NULL, TEXT("Open into")));
459  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_OPEN_DEFAULT_VIEWER, TEXT("Open in Default Viewer"), TEXT("Open into")));
460  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RENAME, TEXT("Rename")));
461  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_DELETE, TEXT("Move to Recycle Bin")));
462  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_RELOAD, TEXT("Reload")));
463  					itemUnitArray.push_back(MenuItemUnit(IDM_FILE_PRINT, TEXT("Print")));
464  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
465  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_SETREADONLY, TEXT("Read-Only")));
466  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CLEARREADONLY, TEXT("Clear Read-Only Flag")));
467  					itemUnitArray.push_back(MenuItemUnit(0, NULL));
468  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FULLPATHTOCLIP, TEXT("Copy Full File Path"), TEXT("Copy to Clipboard")));
469  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_FILENAMETOCLIP, TEXT("Copy Filename"), TEXT("Copy to Clipboard")));
470  					itemUnitArray.push_back(MenuItemUnit(IDM_EDIT_CURRENTDIRTOCLIP, TEXT("Copy Current Dir. Path"), TEXT("Copy to Clipboard")));
471  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_ANOTHER_VIEW, TEXT("Move to Other View"), TEXT("Move Document")));
472  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_CLONE_TO_ANOTHER_VIEW, TEXT("Clone to Other View"), TEXT("Move Document")));
473  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_GOTO_NEW_INSTANCE, TEXT("Move to New Instance"), TEXT("Move Document")));
474  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_LOAD_IN_NEW_INSTANCE, TEXT("Open in New Instance"), TEXT("Move Document")));
475  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_1, TEXT("Apply Color 1"), TEXT("Apply Color to Tab")));
476  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_2, TEXT("Apply Color 2"), TEXT("Apply Color to Tab")));
477  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_3, TEXT("Apply Color 3"), TEXT("Apply Color to Tab")));
478  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_4, TEXT("Apply Color 4"), TEXT("Apply Color to Tab")));
479  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_5, TEXT("Apply Color 5"), TEXT("Apply Color to Tab")));
480  					itemUnitArray.push_back(MenuItemUnit(IDM_VIEW_TAB_COLOUR_NONE, TEXT("Remove Color"), TEXT("Apply Color to Tab")));
481  				}
482  				_tabPopupMenu.create(_pPublicInterface->getHSelf(), itemUnitArray, _mainMenuHandle);
483  				_nativeLangSpeaker.changeLangTabContextMenu(_tabPopupMenu.getMenuHandle());
484  			}
485  			for (int i = 0; i < 5; ++i)
486  			{
487  				COLORREF colour = NppDarkMode::getIndividualTabColour(i, NppDarkMode::isDarkMenuEnabled(), true);
488  				HBITMAP hBitmap = generateSolidColourMenuItemIcon(colour);
489  				SetMenuItemBitmaps(_tabPopupMenu.getMenuHandle(), IDM_VIEW_TAB_COLOUR_1 + i, MF_BYCOMMAND, hBitmap, hBitmap);
490  			}
491  			bool isEnable = ((::GetMenuState(_mainMenuHandle, IDM_FILE_SAVE, MF_BYCOMMAND)&MF_DISABLED) == 0);
492  			_tabPopupMenu.enableItem(IDM_FILE_SAVE, isEnable);
493  			Buffer * buf = _pEditView->getCurrentBuffer();
494  			bool isUserReadOnly = buf->getUserReadOnly();
495  			_tabPopupMenu.checkItem(IDM_EDIT_SETREADONLY, isUserReadOnly);
496  			bool isSysReadOnly = buf->getFileReadOnly();
497  			_tabPopupMenu.enableItem(IDM_EDIT_SETREADONLY, !isSysReadOnly && !buf->isMonitoringOn());
498  			_tabPopupMenu.enableItem(IDM_EDIT_CLEARREADONLY, isSysReadOnly);
499  			bool isFileExisting = PathFileExists(buf->getFullPathName()) != FALSE;
500  			_tabPopupMenu.enableItem(IDM_FILE_DELETE, isFileExisting);
501  			_tabPopupMenu.enableItem(IDM_FILE_RELOAD, isFileExisting);
502  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_FOLDER, isFileExisting);
503  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_CMD, isFileExisting);
504  			_tabPopupMenu.enableItem(IDM_FILE_OPEN_DEFAULT_VIEWER, isAssoCommandExisting(buf->getFullPathName()));
505  			bool isDirty = buf->isDirty();
506  			bool isUntitled = buf->isUntitled();
507  			_tabPopupMenu.enableItem(IDM_VIEW_GOTO_NEW_INSTANCE, !(isDirty||isUntitled));
508  			_tabPopupMenu.enableItem(IDM_VIEW_LOAD_IN_NEW_INSTANCE, !(isDirty||isUntitled));
509  			_tabPopupMenu.display(p);
510  			return TRUE;
511  		}
512  		case SCN_MARGINCLICK:
513  		{
514  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
<span onclick='openModal()' class='match'>515  				switchEditViewTo(MAIN_VIEW);
516  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
517  				switchEditViewTo(SUB_VIEW);
518  			intptr_t lineClick = _pEditView->execute(SCI_LINEFROMPOSITION, notification->position);
</span>519  			if (notification->margin == ScintillaEditView::_SC_MARGE_FOLDER)
520  			{
521  				_pEditView->marginClick(notification->position, notification->modifiers);
522  				if (_pDocMap)
523  					_pDocMap->fold(lineClick, _pEditView->isFolded(lineClick));
524  				ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
525  				_smartHighlighter.highlightView(_pEditView, unfocusView);
526  			}
527  			else if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
528  			{
529  				if (!_pEditView->markerMarginClick(lineClick))
530  					bookmarkToggle(lineClick);
531  			}
532  			break;
533  		}
534  		case SCN_MARGINRIGHTCLICK:
535  		{
536  			if (notification->nmhdr.hwndFrom == _mainEditView.getHSelf())
537  				switchEditViewTo(MAIN_VIEW);
538  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
539  				switchEditViewTo(SUB_VIEW);
540  			if ((notification->margin == ScintillaEditView::_SC_MARGE_SYMBOL) && !notification->modifiers)
541  			{
542  				POINT p;
543  				::GetCursorPos(&p);
544  				MenuPosition& menuPos = getMenuPosition("search-bookmark");
545  				HMENU hSearchMenu = ::GetSubMenu(_mainMenuHandle, menuPos._x);
546  				if (hSearchMenu)
547  				{
548  					HMENU hBookmarkMenu = ::GetSubMenu(hSearchMenu, menuPos._y);
549  					if (hBookmarkMenu)
550  					{
551  						TrackPopupMenu(hBookmarkMenu, 0, p.x, p.y, 0, _pPublicInterface->getHSelf(), NULL);
552  					}
553  				}
554  			}
555  			break;
556  		}
557  		case SCN_FOLDINGSTATECHANGED :
558  		{
559  			if ((notification->nmhdr.hwndFrom == _mainEditView.getHSelf()) || (notification->nmhdr.hwndFrom == _subEditView.getHSelf()))
560  			{
561  				size_t lineClicked = notification->line;
562  				if (!_isFolding)
563  				{
564  					addHotSpot();
565  				}
566  				if (_pDocMap)
567  					_pDocMap->fold(lineClicked, _pEditView->isFolded(lineClicked));
568  			}
569  			return TRUE;
570  		}
571  		case SCN_CHARADDED:
572  		{
573  			if (!_recordingMacro && !_playingBackMacro) 
574  			{
575  				const NppGUI & nppGui = NppParameters::getInstance().getNppGUI();
576  				bool indentMaintain = nppGui._maitainIndent;
577  				if (indentMaintain)
578  					maintainIndentation(static_cast<TCHAR>(notification->ch));
579  				Buffer* currentBuf = _pEditView->getCurrentBuffer();
580  				if (currentBuf->allowAutoCompletion())
581  				{
582  					AutoCompletion* autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
583  					bool isColumnMode = _pEditView->execute(SCI_GETSELECTIONS) > 1; 
584  					if (nppGui._matchedPairConf.hasAnyPairsPair() && !isColumnMode)
585  						autoC->insertMatchedChars(notification->ch, nppGui._matchedPairConf);
586  					autoC->update(notification->ch);
587  				}
588  			}
589  			break;
590  		}
591  		case SCN_DOUBLECLICK:
592  		{
593  			if (!notifyView)
594  				return FALSE;
595  			if (notification->modifiers == SCMOD_CTRL)
596  			{
597  				const NppGUI & nppGUI = NppParameters::getInstance().getNppGUI();
598  				std::string bufstring;
599  				size_t position_of_click;
600  				if (notification->position != -1)
601  					position_of_click = notification->position;
602  				else
603  					position_of_click = _pEditView->execute(SCI_GETCURRENTPOS);
604  				{
605  					char *buf;
606  					if (nppGUI._delimiterSelectionOnEntireDocument)
607  					{
608  						auto length = notifyView->execute(SCI_GETLENGTH);
609  						buf = new char[length + 1];
610  						notifyView->execute(SCI_GETTEXT, length + 1, reinterpret_cast<LPARAM>(buf));
611  					}
612  					else
613  					{
614  						auto length = notifyView->execute(SCI_GETCURLINE);
615  						buf = new char[length + 1];
616  						notifyView->execute(SCI_GETCURLINE, length, reinterpret_cast<LPARAM>(buf));
617  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
618  						position_of_click = position_of_click - line_position;
619  					}
620  					bufstring = buf;
621  					delete [] buf;
622  				}
623  				int leftmost_position = -1;
624  				int rightmost_position = -1;
625  				if (nppGUI._rightmostDelimiter == nppGUI._leftmostDelimiter)
626  				{
627  					for (int32_t i = static_cast<int32_t>(position_of_click); i >= 0; --i)
628  					{
629  						if (i >= static_cast<int32_t>(bufstring.size()))
630  							return FALSE;
631  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
632  						{
633  							if (nppGUI._leftmostDelimiter == '"')
634  							{
635  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
636  								{
637  									leftmost_position = i;
638  									break;
639  								}
640  							}
641  							else
642  							{
643  								leftmost_position = i;
644  								break;
645  							}
646  						}
647  					}
648  					if (leftmost_position == -1)
649  						break;
650  					for (size_t i = position_of_click; i < bufstring.length(); ++i)
651  					{
652  						if (bufstring.at(i) == nppGUI._rightmostDelimiter)
653  						{
654  							if (nppGUI._rightmostDelimiter == '"')
655  							{
656  								if (! (i > 0 && bufstring.at(i - 1) == '\\'))
657  								{
658  									rightmost_position = static_cast<int32_t>(i);
659  									break;
660  								}
661  							}
662  							else
663  							{
664  								rightmost_position = static_cast<int32_t>(i);
665  								break;
666  							}
667  						}
668  					}
669  				}
670  				else
671  				{
672  					std::stack<unsigned int> leftmost_delimiter_positions;
673  					for (unsigned int i = 0; i < bufstring.length(); ++i)
674  					{
675  						if (bufstring.at(i) == nppGUI._leftmostDelimiter)
676  							leftmost_delimiter_positions.push(i);
677  						else if (bufstring.at(i) == nppGUI._rightmostDelimiter && ! leftmost_delimiter_positions.empty())
678  						{
679  							unsigned int matching_leftmost = leftmost_delimiter_positions.top();
680  							leftmost_delimiter_positions.pop();
681  							assert( (leftmost_position == -1 && rightmost_position == -1) || (leftmost_position >= 0 && rightmost_position >= 0) );
682  							if (matching_leftmost <= position_of_click && i >= position_of_click && (leftmost_position == -1 || matching_leftmost > static_cast<unsigned int>(leftmost_position)))
683  							{
684  								leftmost_position = matching_leftmost;
685  								rightmost_position = i;
686  							}
687  						}
688  					}
689  				}
690  				if (rightmost_position != -1 && leftmost_position != -1)
691  				{
692  					if (nppGUI._delimiterSelectionOnEntireDocument)
693  					{
694  						notifyView->execute(SCI_SETCURRENTPOS, rightmost_position);
695  						notifyView->execute(SCI_SETANCHOR, leftmost_position + 1);
696  					}
697  					else
698  					{
699  						const auto line_position = notifyView->execute(SCI_POSITIONFROMLINE, notifyView->getCurrentLineNumber());
700  						notifyView->execute(SCI_SETCURRENTPOS, line_position + rightmost_position);
701  						notifyView->execute(SCI_SETANCHOR, line_position + leftmost_position + 1);
702  					}
703  				}
704  			}
705  			else
706  			{ 
707  				auto indicMsk = notifyView->execute(SCI_INDICATORALLONFOR, notification->position);
708  				if (!(indicMsk & (1 << URL_INDIC)))
709  					break;
710  				auto startPos = notifyView->execute(SCI_INDICATORSTART, URL_INDIC, notification->position);
711  				auto endPos = notifyView->execute(SCI_INDICATOREND, URL_INDIC, notification->position);
712  				if ((notification->position < startPos) || (notification->position > endPos))
713  					break;
714  				::PostMessage(notifyView->getHSelf(), WM_LBUTTONUP, 0, 0);
715  				notifyView->execute(SCI_SETSEL, notification->position, notification->position); 
716  				generic_string url = notifyView->getGenericTextAsString(static_cast<size_t>(startPos), static_cast<size_t>(endPos));
717  				::ShellExecute(_pPublicInterface->getHSelf(), TEXT("open"), url.c_str(), NULL, NULL, SW_SHOW);
718  			}
719  			break;
720  		}
721  		case SCN_UPDATEUI:
722  		{
723  			if (!notifyView)
724  				return FALSE;
725  			NppParameters& nppParam = NppParameters::getInstance();
726  			NppGUI & nppGui = nppParam.getNppGUI();
727  			if (notification->updated & SC_UPDATE_V_SCROLL)
728  			{
729  				addHotSpot(notifyView);
730  			}
731  			if (nppParam._isFindReplacing)
732  				break;
733  			Buffer* currentBuf = _pEditView->getCurrentBuffer();
734  			if (notification->nmhdr.hwndFrom != _pEditView->getHSelf() && currentBuf->allowSmartHilite()) 
735  			{
736  				if (nppGui._smartHiliteOnAnotherView)
737  				{
738  					TCHAR selectedText[1024];
739  					_pEditView->getGenericSelectedText(selectedText, sizeof(selectedText)/sizeof(TCHAR), false);
740  					_smartHighlighter.highlightViewWithWord(notifyView, selectedText);
741  				}
742  				break;
743  			}
744  			braceMatch();
745  			if (nppGui._enableTagsMatchHilite)
746  			{
747  				XmlMatchedTagsHighlighter xmlTagMatchHiliter(_pEditView);
748  				xmlTagMatchHiliter.tagMatch(nppGui._enableTagAttrsHilite);
749  			}
750  			if (nppGui._enableSmartHilite && currentBuf->allowSmartHilite())
751  			{
752  				if (nppGui._disableSmartHiliteTmp)
753  					nppGui._disableSmartHiliteTmp = false;
754  				else
755  				{
756  					ScintillaEditView * anbotherView = isFromPrimary ? &_subEditView : &_mainEditView;
757  					_smartHighlighter.highlightView(notifyView, anbotherView);
758  				}
759  			}
760  			bool selectionIsChanged = (notification->updated & SC_UPDATE_SELECTION) != 0;
761  			bool contentIsChanged = (notification->updated & SC_UPDATE_CONTENT) != 0;
762  			if (selectionIsChanged || contentIsChanged)
763  			{
764  				updateStatusBar();
765  			}
766  			if (_pFuncList && (!_pFuncList->isClosed()) && _pFuncList->isVisible())
767  				_pFuncList->markEntry();
768  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
769  			autoC->update(0);
770  			break;
771  		}
772  		case TTN_GETDISPINFO:
773  		{
774  			try
775  			{
776  				LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
777  				lpttt->hinst = NULL;
778  				POINT p;
779  				::GetCursorPos(&p);
780  				::MapWindowPoints(NULL, _pPublicInterface->getHSelf(), &p, 1);
781  				HWND hWin = ::ChildWindowFromPointEx(_pPublicInterface->getHSelf(), p, CWP_SKIPINVISIBLE);
782  				const int tipMaxLen = 1024;
783  				static TCHAR docTip[tipMaxLen];
784  				docTip[0] = '\0';
785  				generic_string tipTmp(TEXT(""));
786  				int id = int(lpttt->hdr.idFrom);
787  				if (hWin == _rebarTop.getHSelf())
788  				{
789  					getNameStrFromCmd(id, tipTmp);
790  					if (tipTmp.length() >= 80)
791  						return FALSE;
792  					wcscpy_s(lpttt->szText, tipTmp.c_str());
793  					return TRUE;
794  				}
795  				else if (hWin == _mainDocTab.getHSelf())
796  				{
797  					BufferID idd = _mainDocTab.getBufferByIndex(id);
798  					Buffer * buf = MainFileManager.getBufferByID(idd);
799  					if (buf == nullptr)
800  						return FALSE;
801  					tipTmp = buf->getFullPathName();
802  					if (tipTmp.length() >= tipMaxLen)
803  						return FALSE;
804  					wcscpy_s(docTip, tipTmp.c_str());
805  					lpttt->lpszText = docTip;
806  					return TRUE;
807  				}
808  				else if (hWin == _subDocTab.getHSelf())
809  				{
810  					BufferID idd = _subDocTab.getBufferByIndex(id);
811  					Buffer * buf = MainFileManager.getBufferByID(idd);
812  					if (buf == nullptr)
813  						return FALSE;
814  					tipTmp = buf->getFullPathName();
815  					if (tipTmp.length() >= tipMaxLen)
816  						return FALSE;
817  					wcscpy_s(docTip, tipTmp.c_str());
818  					lpttt->lpszText = docTip;
819  					return TRUE;
820  				}
821  				else
822  					return FALSE;
823  			}
824  			catch (...)
825  			{
826  			}
827  			break;
828  		}
829  		case SCN_ZOOM:
830  		{
831  			if (!notifyView)
832  				return FALSE;
833  			ScintillaEditView * unfocusView = isFromPrimary ? &_subEditView : &_mainEditView;
834  			_smartHighlighter.highlightView(notifyView, unfocusView);
835  			break;
836  		}
837  		case SCN_MACRORECORD:
838  		{
839  			_macro.push_back(
840  				recordedMacroStep(
841  					notification->message,
842  					notification->wParam,
843  					notification->lParam
844  				)
845  			);
846  			break;
847  		}
848  		case SCN_PAINTED:
849  		{
850  			if (!notifyView)
851  				return FALSE;
852  			_mainEditView.restoreCurrentPosPostStep();
853  			_subEditView.restoreCurrentPosPostStep();
854  			if (_mainEditView.isWrapRestoreNeeded())
855  			{
856  				_mainEditView.restoreCurrentPosPreStep();
857  				_mainEditView.setWrapRestoreNeeded(false);
858  			}
859  			if (_subEditView.isWrapRestoreNeeded())
860  			{
861  				_subEditView.restoreCurrentPosPreStep();
862  				_subEditView.setWrapRestoreNeeded(false);
863  			}
864  			notifyView->updateLineNumberWidth();
865  			if (_syncInfo.doSync())
866  				doSynScorll(HWND(notification->nmhdr.hwndFrom));
867  			NppParameters& nppParam = NppParameters::getInstance();
868  			if ((_linkTriggered && !nppParam._isFindReplacing) || notification->wParam == LINKTRIGGERED)
869  			{
870  				addHotSpot();
871  				_linkTriggered = false;
872  			}
873  			if (_pDocMap && (!_pDocMap->isClosed()) && _pDocMap->isVisible() && !_pDocMap->isTemporarilyShowing())
874  			{
875  				_pDocMap->wrapMap();
876  				_pDocMap->scrollMap();
877  			}
878  			break;
879  		}
880  		case SCN_NEEDSHOWN:
881  		{
882  			break;
883  		}
884  		case SCN_CALLTIPCLICK:
885  		{
886  			AutoCompletion * autoC = isFromPrimary ? &_autoCompleteMain : &_autoCompleteSub;
887  			autoC->callTipClick(notification->position);
888  			break;
889  		}
890  		case SCN_AUTOCSELECTION:
891  		{
892  			const NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
893  			if (nppGui._autocStatus == NppGUI::AutocStatus::autoc_none)
894  			{
895  				break;
896  			}
897  			if (notification->listCompletionMethod == SC_AC_NEWLINE && !nppGui._autocInsertSelectedUseENTER)
898  			{
899  				notifyView->execute(SCI_AUTOCCANCEL);
900  				notifyView->execute(SCI_NEWLINE);
901  			}
902  			if (notification->listCompletionMethod == SC_AC_TAB && !nppGui._autocInsertSelectedUseTAB)
903  			{
904  				notifyView->execute(SCI_AUTOCCANCEL);
905  				notifyView->execute(SCI_TAB);
906  			}
907  			break;
908  		}
909  		case RBN_HEIGHTCHANGE:
910  		{
911  			SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
912  			break;
913  		}
914  		case RBN_CHEVRONPUSHED:
915  		{
916  			NMREBARCHEVRON * lpnm = reinterpret_cast<NMREBARCHEVRON *>(notification);
917  			ReBar * notifRebar = &_rebarTop;
918  			if (_rebarBottom.getHSelf() == lpnm->hdr.hwndFrom)
919  				notifRebar = &_rebarBottom;
920  			if (lpnm->wID == REBAR_BAR_TOOLBAR)
921  			{
922  				POINT pt{};
923  				pt.x = lpnm->rc.left;
924  				pt.y = lpnm->rc.bottom;
925  				ClientToScreen(notifRebar->getHSelf(), &pt);
926  				_toolBar.doPopop(pt);
927  				return TRUE;
928  			}
929  			REBARBANDINFO rbBand;
930  			ZeroMemory(&rbBand, REBARBAND_SIZE);
931  			rbBand.cbSize = REBARBAND_SIZE;
932  			rbBand.fMask = RBBIM_CHILD;
933  			::SendMessage(notifRebar->getHSelf(), RB_GETBANDINFO, lpnm->uBand, reinterpret_cast<LPARAM>(&rbBand));
934  			::SendMessage(rbBand.hwndChild, WM_NOTIFY, 0, reinterpret_cast<LPARAM>(lpnm));
935  			break;
936  		}
937  		default:
938  			break;
939  	}
940  	return FALSE;
941  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppNotification.cpp</div>
                </div>
                <div class="column column_space"><pre><code>515  				switchEditViewTo(MAIN_VIEW);
516  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
517  				switchEditViewTo(SUB_VIEW);
518  			intptr_t lineClick = _pEditView->execute(SCI_LINEFROMPOSITION, notification->position);
</pre></code></div>
                <div class="column column_space"><pre><code>515  				switchEditViewTo(MAIN_VIEW);
516  			else if (notification->nmhdr.hwndFrom == _subEditView.getHSelf())
517  				switchEditViewTo(SUB_VIEW);
518  			intptr_t lineClick = _pEditView->execute(SCI_LINEFROMPOSITION, notification->position);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    