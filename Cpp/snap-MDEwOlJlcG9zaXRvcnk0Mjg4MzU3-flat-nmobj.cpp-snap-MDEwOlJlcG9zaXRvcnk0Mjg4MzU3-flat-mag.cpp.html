
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.476683937823832%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include "nmobj.h"
2  TNmObjBs::TNmObjBs(
3   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
4   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr="<.>";
20  TStr TNmObjBs::BreakTagStr="<br>";
21  TStr TNmObjBs::ParagraphTagStr="<p>";
22  TStr TNmObjBs::EofTagStr="<eof>";
23  void TNmObjBs::LoadCustSwSet(const PSIn& SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn& SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf("Word already normalized (%s)", WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr& _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn('_')){
64      WordStr.ChangeChAll('_', '$');
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef->GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex->IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef->GetLcChA(NrWordChA);
85          if (NrWordChA.Len()>0){
86            NrWordChA.PutCh(0, ChDef->GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef->GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr& Str){
98    if (Str=="Ignore"){return noaIgnore;}
99    if (Str=="Standalone"){return noaStandalone;}
100    if (Str=="AsCapitalized"){return noaAsCapitalized;}
101    if (Str=="Unperiod"){return noaUnperiod;}
102    if (Str=="Acronym"){return noaAcronym;}
103    if (Str=="FirstName"){return noaFirstName;}
104    if (Str=="Person"){return noaPerson;}
105    if (Str=="Company"){return noaCompany;}
106    if (Str=="Organization"){return noaOrganization;}
107    if (Str=="Country"){return noaCountry;}
108    if (Str=="Geography"){return noaGeography;}
109    TExcept::Throw("Invalid Named-Object name.", Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn& SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec<TStrV> NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN<NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr& WordStr, const TNmObjAttr& NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV& WordStrV, const TNmObjAttr& NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr& Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef->IsAlpha(FirstCh)){return false;}
163    if (!ChDef->IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr& Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN<ChA.Len(); ChN++){
169      if (!ChDef->IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr& Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef->IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr& Str) const {
180    return (!Str.Empty())&&(Str[0]=='<');
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr& Str1, const TStr& Str2,
184   const int& MnPfxLen, const int& MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN>=ChA1.Len()){break;}
189      if (ChN>=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1<=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1>MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1>MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV& WordStrV, const bool& DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
<span onclick='openModal()' class='match'>207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
</span>211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV& NmObjStrV, TStrV& NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr& HtmlStr, TStrV& CandWordStrV, const bool& DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf("Tokens: ");}
230    for (int TokN=0; TokN<HtmlDoc->GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc->GetTok(TokN);
232      HtmlDoc->GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf("%s ", Str.CStr());}
242            else {printf("%s(%s) ", Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&&(LastNmObjTokN<TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf("%s ", Str.CStr());}
258          if (
259           (Str==".")||(Str=="!")||(Str=="?")||
260           (Str=="\"")||(Str=="-")||(Str=="/")||
261           (Str==":")||(Str==";")){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str=="<TITLE>"){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str=="<SCRIPT>"){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str=="<P>"){
276            if ((!CandWordStrV.Empty())&&(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str=="<TD>")||(Str=="<BR>")){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf("\n");}
291    if (DumpP){
292      printf("Candidates: ");
293      for (int CandWordStrN=0; CandWordStrN<CandWordStrV.Len(); CandWordStrN++){
294        printf("%s ", CandWordStrV[CandWordStrN].CStr());}
295      printf("\n");
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV& CandWordStrV, TIntV& NmObjIdV, const bool& DumpP){
300    TVec<TStrV> NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN<CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()<=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef->GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&&((WordStr.Len()>4)&&(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&&(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN>1)&&(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()<=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()>5){
350        while (NrWordStrV.Len()>2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef->GetUcStr(NrWordStrV[0]);
353        if (SwSet->IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV& WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()<SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()>=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN<NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV& SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()<SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&&(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&&
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()<SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()<SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN<NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV& NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf("Named-Objects: ");
409      for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf("%s ", NmObjStr.CStr());
413      }
414      printf("\n");
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV& IdTitleSrcHtmlQuV,
419   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
420   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
421   const int& MxDocs, const bool& DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN<IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&&(DocN>MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf("===============================================\n");
440        printf("%s\n", DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs->AddDoc(DocNm, "", NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
447    NmObjBs->PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn& _CpdSIn,
452   const TSwSetType& SwSetType, const PSIn& CustSwSetSIn,
453   const PSIn& NrWordBsSIn, const PSIn& WordTypeBsSIn, const TStr& MteFNm,
454   const int& MxDocs, const bool& DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
460      TStr DocNm=CpDoc->GetDocNm();
461      TStr DateStr=CpDoc->GetDateStr();
462      TStr HtmlStr=CpDoc->GetTxtStr();
463      Docs++; printf("%d %s\r", Docs, DocNm.CStr());
464      if (DumpP){
465        printf("===============================================\n");
466        printf("%s\n", DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs->ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs->FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs->AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs->GetMergedNmObj(NewNmObjIdV);
473    NmObjBs->PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr& CpdFNm,
478   const TSwSetType& SwSetType, const TStr& CustSwSetFNm,
479   const TStr& NrWordBsFNm, const TStr& WordTypeBsFNm, const TStr& MteFNm,
480   const int& MxDocs, const bool& DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&&(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&&(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&&(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV& NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId<Pfxs; PfxId++){
512      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr& WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr& SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()>1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId<Pfxs; PfxId++){
558      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()>1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId<Pfxs; PfxId++){
626      TIntV& NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN<NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr& WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr& WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr& WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN<NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr& SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr& SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr& SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&&
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&&
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()>1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN<FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV& NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId<NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId<Docs; DocId++){
686      TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN<NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV& NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP<NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV& NmObjStrFqPrV, const int& MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2>=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV& NmObjFqStrPrV, const int& MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1>=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs& BowDocBs, TIntV& BowDIdV, 
733   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs->GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs,
760   const TStr& NmObjStr1, const TStr& NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr& TargetNmObjStr, TIntPrV& FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN<NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr& DocNm, const TStr& DateStr, const TIntV& NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN<NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]->DateStr=DateStr;
792    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP<NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int& DocId, const char& SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV& NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN<NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN>0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int& MnNmObjFq) const {
814    printf("Generating Bag-Of-Words...\n");
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId<GetDocs(); DocId++){
817      if (DocId%100==0){printf("%d\r", DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)>=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN<TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs->AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs->PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs->AssertOk();
837    printf("\nDone.\n");
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId<NmObjs; NmObjId++){
844      printf("%d/%d\r", (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf("\n");
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs& BowDocBs, const PBowDocWgtBs& BowDocWgtBs, const int& MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr& FqFNm, const TStr& SwFNm,
855   const TStr& AbcFNm, const TStr& DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId<NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV& WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf("Saving by frequency to '%s' ...", FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, "%d - %s\n", Fq, WordStrVStr.CStr());
874      }
875      printf(" Done.\n");
876    }
877    if (!SwFNm.Empty()){
878      printf("Saving by frequency for stop-words proposal to '%s' ...", SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN<FqWordStrVPrV.Len(); PrN++){
881        TStrV& WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, ' ');
883        fprintf(fOut, "%s\n", WordStrVStr.CStr());
884      }
885      printf(" Done.\n");
886    }
887    if (!AbcFNm.Empty()){
888      printf("Saving by alphabet to '%s' ...", AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN<WordStrVFqPrV.Len(); PrN++){
891        TStrV& WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, "%s - %d [", WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN<DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, "'%s' ", DocNm.CStr());
901        }
902        fprintf(fOut, "]\n");
903      }
904      printf(" Done.\n");
905    }
906    if (!DocFNm.Empty()){
907      printf("Saving by documents to '%s' ...", DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId<GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, "'%s'(%d):", DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, "[%s]", DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN<DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, " [%s:%d]", NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, "\n");
922      }
923      printf(" Done.\n");
924    }
925  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "mag.h"
3  TRnd TMAGNodeSimple::Rnd = TRnd(0);
4  TRnd TMAGNodeBern::Rnd = TRnd(0);
5  TRnd TMAGNodeBeta::Rnd = TRnd(0);
6  const double TMAGAffMtx::NInf = -DBL_MAX;
7  TMAGAffMtx::TMAGAffMtx(const TFltV& SeedMatrix) : SeedMtx(SeedMatrix) {
8    MtxDim = (int) sqrt((double)SeedMatrix.Len());
9    IAssert(MtxDim*MtxDim == SeedMtx.Len());
10  }
11  TMAGAffMtx& TMAGAffMtx::operator = (const TMAGAffMtx& Kronecker) {
12    if (this != &Kronecker){
13      MtxDim=Kronecker.MtxDim;
14      SeedMtx=Kronecker.SeedMtx;
15    }
16    return *this;
17  }
18  bool TMAGAffMtx::IsProbMtx() const {
19    for (int i = 0; i < Len(); i++) {
20      if (At(i) < 0.0 || At(i) > 1.0) return false;
21    }
22    return true;
23  }
24  void TMAGAffMtx::SetRndMtx(TRnd& Rnd, const int& PrmMtxDim, const double& MinProb) {
25    MtxDim = PrmMtxDim;
26    SeedMtx.Gen(MtxDim*MtxDim);
27    for (int p = 0; p < SeedMtx.Len(); p++) {
28      do {
29        SeedMtx[p] = Rnd.GetUniDev();
30      } while (SeedMtx[p] < MinProb);
31    }
32  }
33  void TMAGAffMtx::SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val, const int& Eps0Val) {
34    for (int i = 0; i < Len(); i++) {
35      double& Val = At(i);
36      if (Val == Eps1Val) Val = double(Eps1);
37      else if (Val == Eps0Val) Val = double(Eps0);
38    }
39  }
40  void TMAGAffMtx::AddRndNoise(TRnd& Rnd, const double& SDev) {
41    Dump("before");
42    double NewVal;
43    int c =0;
44    for (int i = 0; i < Len(); i++) {
45      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) < 0.01 || NewVal>0.99) && c <1000; c++) { }
46      if (c < 999) { At(i) = NewVal; } else { printf("XXXXX\n"); }
47    }
48    Dump("after");
49  }
50  TStr TMAGAffMtx::GetMtxStr() const {
51    TChA ChA("[");
52    for (int i = 0; i < Len(); i++) {
53      ChA += TStr::Fmt("%g", At(i));
54      if ((i+1)%GetDim()==0 && (i+1<Len())) { ChA += "; "; }
55      else if (i+1<Len()) { ChA += " "; }
56    }
57    ChA += "]";
58    return TStr(ChA);
59  }
60  void TMAGAffMtx::GetLLMtx(TMAGAffMtx& LLMtx) {
61    LLMtx.GenMtx(MtxDim);
62    for (int i = 0; i < Len(); i++) {
63      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
64      else { LLMtx.At(i) = NInf; }
65    }
66  }
67  void TMAGAffMtx::GetProbMtx(TMAGAffMtx& ProbMtx) {
68    ProbMtx.GenMtx(MtxDim);
69    for (int i = 0; i < Len(); i++) {
70      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
71      else { ProbMtx.At(i) = 0.0; }
72    }
73  }
74  void TMAGAffMtx::Swap(TMAGAffMtx& Mtx) {
75    ::Swap(MtxDim, Mtx.MtxDim);
76    SeedMtx.Swap(Mtx.SeedMtx);
77  }
78  double TMAGAffMtx::GetMtxSum() const {
79    double Sum = 0;
80    for (int i = 0; i < Len(); i++) {
81      Sum += At(i); }
82    return Sum;
83  }
84  double TMAGAffMtx::GetRowSum(const int& RowId) const {
85    double Sum = 0;
86    for (int c = 0; c < GetDim(); c++) {
87      Sum += At(RowId, c); }
88    return Sum;
89  }
90  double TMAGAffMtx::GetColSum(const int& ColId) const {
91    double Sum = 0;
92    for (int r = 0; r < GetDim(); r++) {
93      Sum += At(r, ColId); }
94    return Sum;
95  }
96  double TMAGAffMtx::Normalize() {
97  	double Sum = GetMtxSum();
98  	if(Sum == 0) {
99  		return 0;
100  	}
101  	for(int i = 0; i < Len(); i++) {
102  		At(i) = At(i) / Sum;
103  	}
104  	return Sum;
105  }
106  void TMAGAffMtx::Dump(const TStr& MtxNm, const bool& Sort) const {
107    if (! MtxNm.Empty()) printf("%s\n", MtxNm.CStr());
108    double Sum=0.0;
109    TFltV ValV = SeedMtx;
110    if (Sort) { ValV.Sort(false); }
111    for (int i = 0; i < ValV.Len(); i++) {
112      printf("  %10.4g", ValV[i]());
113      Sum += ValV[i];
114      if ((i+1) % GetDim() == 0) { printf("\n"); }
115    }
116    printf(" (sum:%.4f)\n", Sum);
117  }
118  double TMAGAffMtx::GetAvgAbsErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
119    TFltV P1 = Mtx1.GetMtx();
120    TFltV P2 = Mtx2.GetMtx();
121    IAssert(P1.Len() == P2.Len());
122    P1.Sort();  P2.Sort();
123    double delta = 0.0;
124    for (int i = 0; i < P1.Len(); i++) {
125      delta += fabs(P1[i] - P2[i]);
126    }
127    return delta/P1.Len();
128  }
129  double TMAGAffMtx::GetAvgFroErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
130    TFltV P1 = Mtx1.GetMtx();
131    TFltV P2 = Mtx2.GetMtx();
132    IAssert(P1.Len() == P2.Len());
133    P1.Sort();  P2.Sort();
134    double delta = 0.0;
135    for (int i = 0; i < P1.Len(); i++) {
136      delta += pow(P1[i] - P2[i], 2);
137    }
138    return sqrt(delta/P1.Len());
139  }
140  TMAGAffMtx TMAGAffMtx::GetMtx(TStr MatlabMtxStr) {
141    TStrV RowStrV, ColStrV;
142    MatlabMtxStr.ChangeChAll(',', ' ');
143    MatlabMtxStr.SplitOnAllCh(';', RowStrV);  IAssert(! RowStrV.Empty());
144    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
145    const int Rows = RowStrV.Len();
146    const int Cols = ColStrV.Len();
147    IAssert(Rows == Cols);
148    TMAGAffMtx Mtx(Rows);
149    for (int r = 0; r < Rows; r++) {
150      RowStrV[r].SplitOnWs(ColStrV);
151      IAssert(ColStrV.Len() == Cols);
152      for (int c = 0; c < Cols; c++) {
153        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
154    }
155    return Mtx;
156  }
157  TMAGAffMtx TMAGAffMtx::GetRndMtx(TRnd& Rnd, const int& Dim, const double& MinProb) {
158    TMAGAffMtx Mtx;
159    Mtx.SetRndMtx(Rnd, Dim, MinProb);
160    return Mtx;
161  }
162  void TMAGNodeSimple::AttrGen(TIntVV& AttrVV, const int& NNodes) {
163  	IAssert(Dim > 0);
164  	AttrVV.Gen(NNodes, Dim);
165  	AttrVV.PutAll(0);
<span onclick='openModal()' class='match'>166  	for(int i = 0; i < NNodes; i++) {
167  		for(int l = 0; l < Dim; l++) {
168  			if((TMAGNodeSimple::Rnd).GetUniDev() > Mu) {
169  				AttrVV.At(i, l) = 1;
170  			}
</span>171  		}
172  	}
173  }
174  void TMAGNodeSimple::LoadTxt(const TStr& InFNm) {
175  	FILE *fp = fopen(InFNm.CStr(), "r");
176  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
177  	char buf[128];
178  	char *token;
179  	TStr TokenStr;
180  	TFlt Val;
181  	token = strtok(buf, "&");
182  	token = strtok(token, " \t");
183  	TokenStr = TStr(token);
184  	Mu = TokenStr.GetFlt(Val);
185  	fclose(fp);
186  }
187  void TMAGNodeSimple::SaveTxt(TStrV& OutStrV) const {
188  	OutStrV.Gen(Dim, 0);
189  	for(int i = 0; i < Dim; i++) {
190  		OutStrV.Add(TStr::Fmt("%f", double(Mu)));
191  	}
192  }
193  TMAGNodeBern& TMAGNodeBern::operator=(const TMAGNodeBern& Dist) {
194  	MuV = Dist.MuV;
195  	Dim = Dist.Dim;
196  	return (*this);
197  }
198  void TMAGNodeBern::AttrGen(TIntVV& AttrVV, const int& NNodes) {
199  	IAssert(Dim > 0);
200  	AttrVV.Gen(NNodes, Dim);
201  	AttrVV.PutAll(0);
202  	for(int i = 0; i < NNodes; i++) {
203  		for(int l = 0; l < Dim; l++) {
204  			if((TMAGNodeBern::Rnd).GetUniDev() > MuV[l]) {
205  				AttrVV.At(i, l) = 1;
206  			}
207  		}
208  	}
209  }
210  void TMAGNodeBern::LoadTxt(const TStr& InFNm) {
211  	FILE *fp = fopen(InFNm.CStr(), "r");
212  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
213  	Dim = 0;
214  	MuV.Gen(10, 0);
215  	char buf[128];
216  	char *token;
217  	TStr TokenStr;
218  	TFlt Val;
219  	while(fgets(buf, sizeof(buf), fp) != NULL) {
220  		token = strtok(buf, "&");
221  		token = strtok(token, " \t");
222  		TokenStr = TStr(token);
223  		MuV.Add(TokenStr.GetFlt(Val));
224  	}
225  	Dim = MuV.Len();
226  	fclose(fp);
227  }
228  void TMAGNodeBern::SaveTxt(TStrV& OutStrV) const {
229  	OutStrV.Gen(Dim, 0);
230  	for(int i = 0; i < Dim; i++) {
231  		OutStrV.Add(TStr::Fmt("%f", double(MuV[i])));
232  	}
233  }
234  TMAGNodeBeta& TMAGNodeBeta::operator=(const TMAGNodeBeta& Dist) {
235  	AlphaV = Dist.AlphaV;
236  	BetaV = Dist.BetaV;
237  	Dim = Dist.Dim;
238  	MuV = Dist.MuV;
239  	Dirty = Dist.Dirty;
240  	return (*this);
241  }
242  void TMAGNodeBeta::SetBeta(const int& Attr, const double& Alpha, const double& Beta) {
243  	IAssert(Attr < Dim);
244  	AlphaV[Attr] = Alpha;
245  	BetaV[Attr] = Beta;
246  	Dirty = true;
247  }
248  void TMAGNodeBeta::SetBetaV(const TFltV& _AlphaV, const TFltV& _BetaV) {
249  	IAssert(_AlphaV.Len() == _BetaV.Len());
250  	AlphaV = _AlphaV;
251  	BetaV = _BetaV;
252  	Dim = _AlphaV.Len();
253  	Dirty = true;
254  }
255  void TMAGNodeBeta::AttrGen(TIntVV& AttrVV, const int& NNodes) {
256  	IAssert(Dim > 0);
257  	AttrVV.Gen(NNodes, Dim);
258  	AttrVV.PutAll(0);
259  	for(int i = 0; i < NNodes; i++) {
260  		for(int l = 0; l < Dim; l++) {
261  			double x = TMAGNodeBeta::Rnd.GetGammaDev((int)AlphaV[l]);
262  			double y = TMAGNodeBeta::Rnd.GetGammaDev((int)BetaV[l]);
263  			MuV[l] = x / (x + y);
264  			if((TMAGNodeBeta::Rnd).GetUniDev() > MuV[l]) {
265  				AttrVV.At(i, l) = 1;
266  			}
267  		}
268  	}
269  	Dirty = false;
270  }
271  void TMAGNodeBeta::LoadTxt(const TStr& InFNm) {
272  	FILE *fp = fopen(InFNm.CStr(), "r");
273  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
274  	Dim = 0;
275  	AlphaV.Gen(10, 0);
276  	BetaV.Gen(10, 0);
277  	char buf[128];
278  	char *token;
279  	TStr TokenStr;
280  	TFlt Val;
281  	while(fgets(buf, sizeof(buf), fp) != NULL) {
282  		token = strtok(buf, "&");
283  		token = strtok(token, " \t");
284  		TokenStr = TStr(token);
285  		AlphaV.Add(TokenStr.GetFlt(Val));
286  		token = strtok(NULL, " \t");
287  		TokenStr = TStr(token);
288  		BetaV.Add(TokenStr.GetFlt(Val));
289  		Dim++;
290  	}
291  	fclose(fp);
292  }
293  void TMAGNodeBeta::SaveTxt(TStrV& OutStrV) const {
294  	OutStrV.Gen(Dim, 0);
295  	for(int i = 0; i < Dim; i++) {
296  		OutStrV.Add(TStr::Fmt("%f %f", double(AlphaV[i]), double(BetaV[i])));
297  	}
298  }
299  void TMAGFitBern::SetGraph(const PNGraph& GraphPt) {
300  	Graph = GraphPt;
301  	bool NodesOk = true;
302  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
303  	if (! Graph->IsNode(nid)) { NodesOk=false; break; } }
304  	if (! NodesOk) {
305  	TIntV NIdV;  GraphPt->GetNIdV(NIdV);
306  	Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
307  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
308  	  IAssert(Graph->IsNode(nid)); }
309  	}
310  }
311  void TMAGFitBern::SetPhiVV(const TIntVV& AttrVV, const int KnownIds) {
312  	const int NNodes = Param.GetNodes();
313  	const int NAttrs = Param.GetAttrs();
314  	PhiVV.Gen(NNodes, NAttrs);
315  	KnownVV.Gen(NNodes, NAttrs);
316  	for(int l = 0; l < NAttrs; l++) {
317  		for(int i = 0; i < NNodes; i++) {
318  			if(int(AttrVV(i, l)) == 0) {
319  				PhiVV(i, l) = 0.9999;
320  			} else {
321  				PhiVV(i, l) = 0.0001;
322  			}
323  		}
324  		if(l < KnownIds) {
325  			KnownVV.PutY(l, true);
326  		} else {
327  			KnownVV.PutY(l, false);
328  		}
329  	}
330  }
331  void TMAGFitBern::SaveTxt(const TStr& FNm) {
332  	const int NNodes = Param.GetNodes();
333  	const int NAttrs = Param.GetAttrs();
334  	const TFltV MuV = GetMuV();
335  	TMAGAffMtxV MtxV;
336  	Param.GetMtxV(MtxV);
337  	FILE *fp = fopen(FNm.GetCStr(), "w");
338  	for(int l = 0; l < NAttrs; l++) {
339  		fprintf(fp, "%.4f\t", double(MuV[l]));
340  		for(int row = 0; row < 2; row++) {
341  			for(int col = 0; col < 2; col++) {
342  				fprintf(fp, " %.4f", double(MtxV[l].At(row, col)));
343  			}
344  			fprintf(fp, (row == 0) ? ";" : "\n");
345  		}
346  	}
347  	fclose(fp);
348  	fp = fopen((FNm + "f").CStr(), "w");
349  	for(int i = 0; i < NNodes; i++) {
350  		for(int l = 0; l < NAttrs; l++) {
351  			fprintf(fp, "%f ", double(PhiVV(i, l)));
352  		}
353  		fprintf(fp, "\n");
354  	}
355  	fclose(fp);
356  }
357  void TMAGFitBern::Init(const TFltV& MuV, const TMAGAffMtxV& AffMtxV) {
358  	TMAGNodeBern DistParam(MuV);
359  	Param.SetNodeAttr(DistParam);
360  	Param.SetMtxV(AffMtxV);
361  	const int NNodes = Param.GetNodes();
362  	const int NAttrs = Param.GetAttrs();
363  	PhiVV.Gen(NNodes, NAttrs);
364  	KnownVV.Gen(NNodes, NAttrs);
365  	KnownVV.PutAll(false);
366  }
367  #if 0
368  void TMAGFitBern::PerturbInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const double& PerturbRate) {
369  	IAssert(PerturbRate < 1.0);
370  	TFltV InitMuV = MuV;	
371  	TMAGNodeBern DistParam(InitMuV);
372  	Param.SetMtxV(AffMtxV);
373  	TRnd& Rnd = TMAGNodeBern::Rnd;
374  	TMAGAffMtxV PerturbMtxV = AffMtxV;
375  	const int NNodes = Param.GetNodes();
376  	const int NAttrs = Param.GetAttrs();
377  	for(int l = 0; l < NAttrs; l++) {
378  		double Mu = MuV[l] + PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
379  		if(Mu < 0.01) {  Mu = 0.01;  }
380  		if(Mu > 0.99) {  Mu = 0.99;  }
381  		DistParam.SetMu(l, Mu);
382  		TMAGAffMtx AffMtx(AffMtxV[l]);
383  		for(int p = 0; p < 4; p++) {
384  			AffMtx.At(p) += PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
385  			if(AffMtx.At(p) < 0.05) {  AffMtx.At(p) = 0.05;  }
386  			if(AffMtx.At(p) > 0.95) {  AffMtx.At(p) = 0.95;  }
387  		}
388  		AffMtx.At(0, 1) = AffMtx.At(1, 0);
389  		PerturbMtxV[l] = AffMtx;
390  	}
391  	printf("\n");
392  	for(int l = 0; l < NAttrs; l++) {
393  		printf("Mu = %.3f  ", DistParam.GetMu(l));
394  		printf("AffMtx = %s\n", PerturbMtxV[l].GetMtxStr().GetCStr());
395  	}
396  	Param.SetMtxV(PerturbMtxV);
397  	Param.SetNodeAttr(DistParam);
398  	PhiVV.Gen(NNodes, NAttrs);
399  	KnownVV.Gen(NNodes, NAttrs);
400  	KnownVV.PutAll(false);
401  }
402  #endif	
403  void TMAGFitBern::RandomInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const int& Seed) {
404  	TRnd& Rnd = TMAGNodeBern::Rnd;
405  	Rnd.PutSeed(Seed);
406  	TFltV InitMuV = MuV;	InitMuV.PutAll(0.5);
407  	TMAGNodeBern DistParam(InitMuV);
408  	Param.SetMtxV(AffMtxV);
409  	const int NNodes = Param.GetNodes();
410  	const int NAttrs = Param.GetAttrs();
411  	PhiVV.Gen(NNodes, NAttrs);
412  	KnownVV.Gen(NNodes, NAttrs);
413  	KnownVV.PutAll(false);
414  	for(int i = 0; i < NNodes; i++) {
415  		for(int l = 0; l < NAttrs; l++) {
416  			PhiVV.At(i, l) = Rnd.GetUniDev();
417  		}
418  	}
419  	TMAGAffMtxV RndMtxV = AffMtxV;
420  	for(int l = 0; l < NAttrs; l++) {
421  		for(int p = 0; p < 4; p++) {
422  			RndMtxV[l].At(p) = TMAGNodeBern::Rnd.GetUniDev();
423  			if(RndMtxV[l].At(p) < 0.1) {  RndMtxV[l].At(p) = 0.1;  }
424  			if(RndMtxV[l].At(p) > 0.9) {  RndMtxV[l].At(p) = 0.9;  }
425  		}
426  		RndMtxV[l].At(0, 1) = RndMtxV[l].At(1, 0);
427  	}
428  	printf("\n");
429  	for(int l = 0; l < NAttrs; l++) {
430  		printf("AffMtx = %s\n", RndMtxV[l].GetMtxStr().GetCStr());
431  	}
432  	Param.SetMtxV(RndMtxV);
433  	Param.SetNodeAttr(DistParam);
434  }
435  const double TMAGFitBern::GetInCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
436  	return (PhiVV.At(i, l) * Theta.At(0, A) + (1.0 - PhiVV.At(i, l)) * Theta.At(1, A));
437  }
438  const double TMAGFitBern::GetOutCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
439  	return (PhiVV.At(j, l) * Theta.At(A, 0) + (1.0 - PhiVV.At(j, l)) * Theta.At(A, 1));
440  }
441  const double TMAGFitBern::GetAvgInCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
442  	const int NNodes = Param.GetNodes();
443  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
444  	return (Mu_l * Theta.At(0, A) + (1.0 - Mu_l) * Theta.At(1, A));
445  }
446  const double TMAGFitBern::GetAvgOutCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
447  	const int NNodes = Param.GetNodes();
448  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
449  	return (Mu_l * Theta.At(A, 0) + (1.0 - Mu_l) * Theta.At(A, 1));
450  }
451  const double TMAGFitBern::GetProbPhi(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2) const {
452  	double Prob1 = (Attr1 == 0) ? double(PhiVV.At(NId1, AId)) : (1.0 - PhiVV.At(NId1, AId));
453  	double Prob2 = (Attr2 == 0) ? double(PhiVV.At(NId2, AId)) : (1.0 - PhiVV.At(NId2, AId));
454  	return (Prob1 * Prob2);
455  }
456  const double TMAGFitBern::GetProbMu(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2, const bool Left, const bool Right) const {
457  	TMAGNodeBern DistParam = Param.GetNodeAttr();
458  	double Mu = AvgPhiV[AId] / double(Param.GetNodes());
459  	double Prob1 = (Left) ? double(PhiVV.At(NId1, AId)) : double(Mu);
460  	double Prob2 = (Right)? double(PhiVV.At(NId2, AId)) : double(Mu);
461  	Prob1 = (Attr1 == 0) ? Prob1 : 1.0 - Prob1;
462  	Prob2 = (Attr2 == 0) ? Prob2 : 1.0 - Prob2;
463  	return (Prob1 * Prob2);
464  }
465  const double TMAGFitBern::GetThetaLL(const int& NId1, const int& NId2, const int& AId) const {
466  	double LL = 0.0;
467  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
468  	for(int A1 = 0; A1 < 2; A1++) {
469  		for(int A2 = 0; A2 < 2; A2++) {
470  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2);
471  		}
472  	}
473  	return log(LL);
474  }
475  const double TMAGFitBern::GetAvgThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
476  	double LL = 0.0;
477  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
478  	for(int A1 = 0; A1 < 2; A1++) {
479  		for(int A2 = 0; A2 < 2; A2++) {
480  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2);
481  		}
482  	}
483  	return log(LL);
484  }
485  const double TMAGFitBern::GetSqThetaLL(const int& NId1, const int& NId2, const int& AId) const {
486  	double LL = 0.0;
487  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
488  	for(int A1 = 0; A1 < 2; A1++) {
489  		for(int A2 = 0; A2 < 2; A2++) {
490  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
491  		}
492  	}
493  	return log(LL);
494  }
495  const double TMAGFitBern::GetAvgSqThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
496  	double LL = 0.0;
497  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
498  	for(int A1 = 0; A1 < 2; A1++) {
499  		for(int A2 = 0; A2 < 2; A2++) {
500  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
501  		}
502  	}
503  	return log(LL);
504  }
505  const double TMAGFitBern::GetProdLinWeight(const int& NId1, const int& NId2) const {
506  	const int NAttrs = Param.GetAttrs();
507  	double LL = 0.0;
508  	for(int l = 0; l < NAttrs; l++) {
509  		LL += GetThetaLL(NId1, NId2, l);
510  	}
511  	return LL + log(NormConst);
512  }
513  const double TMAGFitBern::GetAvgProdLinWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
514  	const int NAttrs = Param.GetAttrs();
515  	double LL = 0.0;
516  	for(int l = 0; l < NAttrs; l++) {
517  		LL += GetAvgThetaLL(NId1, NId2, l, Left, Right);
518  	}
519  	return LL + log(NormConst);
520  }
521  const double TMAGFitBern::GetProdSqWeight(const int& NId1, const int& NId2) const {
522  	const int NAttrs = Param.GetAttrs();
523  	double LL = 0.0;
524  	for(int l = 0; l < NAttrs; l++) {
525  		LL += GetSqThetaLL(NId1, NId2, l);
526  	}
527  	return LL + 2 * log(NormConst);
528  }
529  const double TMAGFitBern::GetAvgProdSqWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
530  	const int NAttrs = Param.GetAttrs();
531  	double LL = 0.0;
532  	for(int l = 0; l < NAttrs; l++) {
533  		LL += GetAvgSqThetaLL(NId1, NId2, l, Left, Right);
534  	}
535  	return LL + 2 * log(NormConst);
536  }
537  const double LogSumExp(const double LogVal1, const double LogVal2) {
538  	double MaxExp = (LogVal1 > LogVal2) ? LogVal1 : LogVal2;
539  	double Sum = exp(LogVal1 - MaxExp) + exp(LogVal2 - MaxExp);
540  	return (log(Sum) + MaxExp);
541  }
542  const double LogSumExp(const TFltV& LogValV) {
543  	const int Len = LogValV.Len();
544  	double MaxExp = -DBL_MAX;
545  	for(int i = 0; i < Len; i++) {
546  		if(MaxExp < LogValV[i]) {  MaxExp = LogValV[i];  }
547  	}
548  	double Sum = 0.0;
549  	for(int i = 0; i < Len; i++) {
550  		Sum += exp(LogValV[i] - MaxExp);
551  	}
552  	return (log(Sum) + MaxExp);
553  }
554  const double LogSumExp(const double *LogValArray, const int Len) {
555  	TFltV TmpV(Len);
556  	for(int i = 0; i < Len; i++) {  TmpV[i] = LogValArray[i];  }
557  	return LogSumExp(TmpV);
558  }
559  const double TMAGFitBern::GradPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& DeltaQ, const TFltVV& CntVV) {
560  	const int NAttrs = CntVV.GetYDim();
561  	double Grad = DeltaQ - log(x) + log(1.0-x);
562  	for(int l = 0; l < NAttrs; l++) {
563  		if(l == AId) {  continue;  }
564  		const double C0 = PhiVV(NId, l);
565  		const double C1 = 1.0 - C0;
566  		Grad -= Lambda * C0 * log(CntVV(0, l) + C0 * x);
567  		Grad -= Lambda * C1 * log(CntVV(1, l) + C1 * x);
568  		Grad += Lambda * C0 * log(CntVV(2, l) + C0 * (1-x));
569  		Grad += Lambda * C1 * log(CntVV(3, l) + C1 * (1-x));
570  		Grad -= Lambda * log(CntVV(0, l) + CntVV(1, l) + x);
571  		Grad += Lambda * log(CntVV(2, l) + CntVV(3, l) + (1-x));
572  	}
573  	return Grad;
574  }
575  const double TMAGFitBern::ObjPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& Q0, const double& Q1, const TFltVV& CntVV) {
576  	const int NAttrs = CntVV.GetYDim();
577  	double Val = x*(Q0 - log(x)) + (1-x)*(Q1 - log(1.0-x));
578  	for(int l = 0; l < NAttrs; l++) {
579  		if(l == AId) {  continue;  }
580  		const double C0 = PhiVV(NId, l);
581  		const double C1 = 1.0 - C0;
582  		Val -= Lambda * (CntVV(0, l) + C0 * x) * log(CntVV(0, l) + C0 * x);
583  		Val -= Lambda * (CntVV(1, l) + C1 * x) * log(CntVV(1, l) + C1 * x);
584  		Val -= Lambda * (CntVV(2, l) + C0 * (1-x)) * log(CntVV(2, l) + C0 * (1-x));
585  		Val -= Lambda * (CntVV(3, l) + C1 * (1-x)) * log(CntVV(3, l) + C1 * (1-x));
586  		Val += Lambda * (CntVV(0, l) + CntVV(1, l) + x) * log(CntVV(0, l) + CntVV(1, l) + x);
587  		Val += Lambda * (CntVV(2, l) + CntVV(3, l) + 1 - x) * log(CntVV(2, l) + CntVV(3, l) + (1-x));
588  		if(!(CntVV(0, l) > 0))	printf("CntVV(0, %d) = %.2f\n", l, double(CntVV(0, l)));
589  		if(!(CntVV(1, l) > 0))	printf("CntVV(1, %d) = %.2f\n", l, double(CntVV(1, l)));
590  		if(!(CntVV(2, l) > 0))	printf("CntVV(2, %d) = %.2f\n", l, double(CntVV(2, l)));
591  		if(!(CntVV(3, l) > 0))	printf("CntVV(3, %d) = %.2f\n", l, double(CntVV(3, l)));
592  	}
593  	return Val;
594  }
595  const double TMAGFitBern::GetEstNoEdgeLL(const int& NId, const int& AId) const {
596  	TMAGNodeBern DistParam = Param.GetNodeAttr();
597  	double LL = 0.0;
598  	return LL;
599  }
600  const double TMAGFitBern::UpdatePhi(const int& NId, const int& AId, double& Phi) {
601  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
602  	TMAGAffMtx SqTheta(Theta);
603  	const int NNodes = Param.GetNodes();
604  	Theta.GetLLMtx(LLTheta);
605  	TMAGNodeBern DistParam = Param.GetNodeAttr();
606  	const double Mu = DistParam.GetMu(AId);
607  	for(int i = 0; i < Theta.Len(); i++) {
608  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
609  	}
610  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
611  	TFltV NonEdgeLLV[2];
612  	for(int i = 0; i < 2; i++) {
613  		EdgeQ[i] = 0.0;
614  		NonEdgeQ[i] = 0.0;
615  		MaxExp[i] = -DBL_MAX;
616  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
617  	}
618  	for(int j = 0; j < NNodes; j++) {
619  		if(j == NId) {	continue;	}
620  		if(Graph->IsEdge(NId, j)) {
621  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
622  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
623  		} else {
624  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
625  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
626  			for(int i = 0; i < 2; i++) {
627  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
628  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
629  			}
630  		}
631  		if(Graph->IsEdge(j, NId)) {
632  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
633  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
634  		} else {
635  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
636  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
637  			for(int i = 0; i < 2; i++) {
638  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
639  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
640  			}
641  		}
642  	}
643  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
644  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
645  	double Q[2];
646  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
647  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
648  	Phi = Q[0] - LogSumExp(Q, 2);
649  	Phi = exp(Phi);
650  	return Phi - PhiVV.At(NId, AId);
651  }
652  const double TMAGFitBern::UpdatePhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi) {
653  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
654  	TMAGAffMtx SqTheta(Theta);
655  	const int NNodes = Param.GetNodes();
656  	const int NAttrs = Param.GetAttrs();
657  	Theta.GetLLMtx(LLTheta);
658  	TMAGNodeBern DistParam = Param.GetNodeAttr();
659  	const double Mu = DistParam.GetMu(AId);
660  	for(int i = 0; i < Theta.Len(); i++) {
661  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
662  	}
663  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
664  	TFltV NonEdgeLLV[2];
665  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
666  	for(int i = 0; i < 2; i++) {
667  		EdgeQ[i] = 0.0;
668  		NonEdgeQ[i] = 0.0;
669  		MaxExp[i] = -DBL_MAX;
670  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
671  	}
672  	for(int j = 0; j < NNodes; j++) {
673  		if(j == NId) {	continue;	}
674  		for(int l = 0; l < NAttrs; l++) {
675  			if(l == AId) {  continue;  }
676  			CntVV(0, l) = CntVV(0, l) + PhiVV(j, AId) * PhiVV(j, l);
677  			CntVV(1, l) = CntVV(1, l) + PhiVV(j, AId) * (1.0-PhiVV(j, l));
678  			CntVV(2, l) = CntVV(2, l) + (1.0-PhiVV(j, AId)) * PhiVV(j, l);
679  			CntVV(3, l) = CntVV(3, l) + (1.0-PhiVV(j, AId)) * (1.0-PhiVV(j, l));
680  		}
681  		if(Graph->IsEdge(NId, j)) {
682  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
683  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
684  		} else {
685  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
686  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
687  			for(int i = 0; i < 2; i++) {
688  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
689  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
690  			}
691  		}
692  		if(Graph->IsEdge(j, NId)) {
693  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
694  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
695  		} else {
696  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
697  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
698  			for(int i = 0; i < 2; i++) {
699  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
700  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
701  			}
702  		}
703  	}
704  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
705  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
706  	double Q[2];
707  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
708  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
709  	double DeltaQ = Q[0] - Q[1];
710  	double x[] = {PhiVV(NId, AId)};
711  	for(int n = 0; n < 1; n++) {
712  		double LrnRate = 0.001;
713  		for(int step = 0; step < 200; step++) {
714  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
715  			if(Grad > 0.0) {  x[n] += LrnRate;  }
716  			else {  x[n] -= LrnRate;  }
717  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
718  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
719  			LrnRate *= 0.995;
720  		}
721  	}
722  	double MaxVal = -DBL_MAX;
723  	int MaxX = -1;
724  	for(int n = 0; n < 1; n++) {
725  		double Val = ObjPhiMI(x[n], NId, AId, Lambda, Q[0], Q[1], CntVV);
726  		if(Val > MaxVal) {
727  			MaxVal = Val;
728  			MaxX = n;
729  		}
730  	}
731  	IAssert(MaxX >= 0);
732  	Phi = x[MaxX];
733  	return Phi - PhiVV.At(NId, AId);
734  }
735  const double TMAGFitBern::UpdateApxPhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi, TFltVV& ProdVV) {
736  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
737  	const int NNodes = Param.GetNodes();
738  	const int NAttrs = Param.GetAttrs();
739  	Theta.GetLLMtx(LLTheta);
740  	TMAGNodeBern DistParam = Param.GetNodeAttr();
741  	const double Mu = DistParam.GetMu(AId);
742  	TMAGAffMtx SqTheta(Theta);
743  	for(int i = 0; i < Theta.Len(); i++) {
744  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
745  	}
746  	TFltV ProdV;	ProdVV.GetRow(NId, ProdV);
747  	ProdV[0] -= GetAvgThetaLL(NId, NId, AId, true, false);
748  	ProdV[1] -= GetAvgThetaLL(NId, NId, AId, false, true);
749  	ProdV[2] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, true, false);
750  	ProdV[3] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, false, true);
751  	double EdgeQ[2], MaxExp[2];
752  	TFltV NonEdgeLLV[2];
753  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
754  	for(int i = 0; i < 2; i++) {
755  		EdgeQ[i] = 0.0;
756  		MaxExp[i] = -DBL_MAX;
757  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
758  	}
759  	for(int F = 0; F < 2; F++) {
760  		NonEdgeLLV[F].Add(ProdV[0] + log(GetAvgOutCoeff(NId, AId, F, Theta)));
761  		NonEdgeLLV[F].Add(ProdV[1] + log(GetAvgInCoeff(NId, AId, F, Theta)));
762  		NonEdgeLLV[F].Add(ProdV[2] + log(GetAvgOutCoeff(NId, AId, F, SqTheta)));
763  		NonEdgeLLV[F].Add(ProdV[3] + log(GetAvgInCoeff(NId, AId, F, SqTheta)));
764  	}
765  	EdgeQ[0] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[0]));
766  	EdgeQ[1] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[1]));
767  	for(int l = 0; l < NAttrs; l++) {
768  		if(l == AId) {  continue;  }
769  		int BgId = (AId > l) ? AId : l;
770  		int SmId = (AId + l) - BgId;
771  		int SmL = (l < AId) ? 1 : 0;
772  		BgId *= 4;
773  		CntVV(0, l) = AvgPhiPairVV(SmId, BgId) - PhiVV(NId, AId) * PhiVV(NId, l);
774  		CntVV(1+SmL, l) = AvgPhiPairVV(SmId, BgId+1+SmL) - PhiVV(NId, AId) * (1.0-PhiVV(NId, l));
775  		CntVV(2-SmL, l) = AvgPhiPairVV(SmId, BgId+2-SmL) - (1.0-PhiVV(NId, AId)) * PhiVV(NId, l);
776  		CntVV(3, l) = AvgPhiPairVV(SmId, BgId+3) - (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, l));
777  	}
778  	TNGraph::TNodeI NI = Graph->GetNI(NId);
779  	for(int d = 0; d < NI.GetOutDeg(); d++) {
780  		int Out = NI.GetOutNId(d);
781  		if(NId == Out) {  continue;  }
782  		double LinW = GetProdLinWeight(NId, Out) - GetThetaLL(NId, Out, AId);
783  		double SqW = GetProdSqWeight(NId, Out) - GetSqThetaLL(NId, Out, AId);
784  		for(int F = 0; F < 2; F++) {
785  			EdgeQ[F] += GetOutCoeff(NId, Out, AId, F, LLTheta);
786  			EdgeQ[F] += exp(LinW + log(GetOutCoeff(NId, Out, AId, F, Theta)));
787  			EdgeQ[F] += 0.5 * exp(SqW + log(GetOutCoeff(NId, Out, AId, F, SqTheta)));
788  		}
789  	}
790  	for(int d = 0; d < NI.GetInDeg(); d++) {
791  		int In = NI.GetInNId(d);
792  		if(NId == In) {  continue;  }
793  		double LinW = GetProdLinWeight(In, NId) - GetThetaLL(In, NId, AId);
794  		double SqW = GetProdSqWeight(In, NId) - GetSqThetaLL(In, NId, AId);
795  		for(int F = 0; F < 2; F++) {
796  			EdgeQ[F] += GetInCoeff(In, NId, AId, F, LLTheta);
797  			EdgeQ[F] += exp(LinW + log(GetInCoeff(In, NId, AId, F, Theta)));
798  			EdgeQ[F] += 0.5 * exp(SqW + log(GetInCoeff(In, NId, AId, F, SqTheta)));
799  		}
800  	}
801  	EdgeQ[0] += log(Mu);
802  	EdgeQ[1] += log(1.0 - Mu);
803  	double DeltaQ = EdgeQ[0] - EdgeQ[1];
804  	double x[] = {PhiVV(NId, AId)};
805  	TFltV ObjValV;	ObjValV.Gen(60, 0);
806  	for(int n = 0; n < 1; n++) {
807  		double LrnRate = 0.001;
808  		for(int step = 0; step < 50; step++) {
809  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
810  			if(Grad > 0.0) {  x[n] += LrnRate;  }
811  			else {  x[n] -= LrnRate;  }
812  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
813  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
814  			if(x[n] == 0.9999 || x[n] == 0.0001) {
815  				break;
816  			}
817  			LrnRate *= 0.995;
818  		}
819  		ObjValV.Add(x[n]);
820  	}
821  	double MaxVal = -DBL_MAX;
822  	int MaxX = -1;
823  	for(int n = 0; n < ObjValV.Len(); n++) {
824  		double Val = ObjPhiMI(ObjValV[n], NId, AId, Lambda, EdgeQ[0], EdgeQ[1], CntVV);
825  		if(Val > MaxVal) {
826  			MaxVal = Val;
827  			MaxX = n;
828  		} else if(MaxX < 0) {
829  			printf("(%d, %d) : %f  Q[0] = %f  Q[1] = %f  Val = %f\n", NId, AId, double(x[n]), double(EdgeQ[0]), double(EdgeQ[1]), Val);
830  		}
831  	}
832  	IAssert(MaxX >= 0);
833  	Phi = ObjValV[MaxX];
834  	return Phi - PhiVV.At(NId, AId);
835  }
836  double TMAGFitBern::DoEStepOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
837  	const int NNodes = Param.GetNodes();
838  	const int NAttrs = Param.GetAttrs();
839  	double MaxDelta = 0, L1 = 0;
840  	double Val;
841  	TFltIntIntTrV NewVal;
842  	int RndCount = 0;
843  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
844  	TIntV NIndV(NNodes), AIndV(NAttrs);
845  	NewVal.Gen(NAttrs * 2);
846  	for(int i = 0; i < NNodes; i++) {
847  		for(int l = 0; l < NAttrs * 2; l++) {
848  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
849  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
850  			double Delta = 0.0;
851  			if(KnownVV(NId, AId)) {
852  				Val = PhiVV.At(NId, AId);
853  			} else {
854  				Delta = UpdatePhiMI(Lambda, NId, AId, Val);
855  			}
856  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
857  			if(fabs(Delta) > MaxDelta) {
858  				MaxDelta = fabs(Delta);
859  			}
860  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
861  		}
862  		for(int l = 0; l < NAttrs * 2; l++) {
863  			const int NId = NewVal[l].Val2;
864  			const int AId = NewVal[l].Val3;
865  			PhiVV.At(NId, AId) = NewVal[l].Val1;
866  		}
867  	}
868  	for(int i = 0; i < NNodes; i++) {
869  		for(int l = 0; l < NAttrs; l++) {
870  			MuV[l] = MuV[l] + PhiVV.At(i, l);
871  		}
872  	}
873  	for(int l = 0; l < NAttrs; l++) {
874  		MuV[l] = MuV[l] / double(NNodes);
875  	}
876  	TFltV SortMuV = MuV;
877  	double Avg = 0.0;
878  	SortMuV.Sort(false);
879  	for(int l = 0; l < NAttrs; l++) {
880  		printf("  F[%d] = %.3f", l, double(MuV[l]));
881  		Avg += SortMuV[l];
882  		L1 += fabs(TrueMuV[l] - SortMuV[l]);
883  	}
884  	printf("\n");
885  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
886  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
887  	L1 /= double(NAttrs);
888  	return L1;
889  }
890  double TMAGFitBern::DoEStepApxOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
891  	const int NNodes = Param.GetNodes();
892  	const int NAttrs = Param.GetAttrs();
893  	double MaxDelta = 0, L1 = 0;
894  	double Val;
895  	TFltIntIntTrV NewVal;
896  	int RndCount = 0;
897  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
898  	TFltVV ProdVV(NNodes, 4);	ProdVV.PutAll(0.0);
899  	TIntV NIndV(NNodes), AIndV(NAttrs);
900  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
901  	AvgPhiPairVV.Gen(NAttrs, 4*NAttrs);		AvgPhiPairVV.PutAll(0.0);
902  	for(int i = 0; i < NNodes; i++) {
903  		for(int l = 0; l < NAttrs; l++) {
904  			for(int p = l+1; p < NAttrs; p++) {
905  				int index = 4 * p;
906  				AvgPhiPairVV(l, index) += PhiVV(i, l) * PhiVV(i, p);
907  				AvgPhiPairVV(l, index+1) += PhiVV(i, l) * (1.0-PhiVV(i, p));
908  				AvgPhiPairVV(l, index+2) += (1.0-PhiVV(i, l)) * PhiVV(i, p);
909  				AvgPhiPairVV(l, index+3) += (1.0-PhiVV(i, l)) * (1.0-PhiVV(i, p));
910  			}
911  			AvgPhiV[l] += PhiVV(i, l);
912  		}
913  	}
914  	for(int i = 0; i < NNodes; i++) {
915  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
916  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
917  		ProdVV(i, 2) = GetAvgProdSqWeight(i, i, true, false);
918  		ProdVV(i, 3) = GetAvgProdSqWeight(i, i, false, true);
919  	}
920  	const int Iter = 3;
921  	NewVal.Gen(NAttrs * Iter);
922  	for(int i = 0; i < NNodes * Iter; i++) {
923  		for(int l = 0; l < NAttrs; l++) {
924  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
925  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
926  			double Delta = 0.0;
927  			if(KnownVV(NId, AId)) {
928  				Val = PhiVV.At(NId, AId);
929  			} else {
930  				Delta = UpdateApxPhiMI(Lambda, NId, AId, Val, ProdVV);
931  			}
932  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
933  			if(fabs(Delta) > MaxDelta) {
934  				MaxDelta = fabs(Delta);
935  			}
936  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
937  		}
938  		for(int l = 0; l < NAttrs; l++) {
939  			const int NId = NewVal[l].Val2;
940  			const int AId = NewVal[l].Val3;
941  			ProdVV(NId, 0) -= GetAvgThetaLL(NId, NId, AId, true, false);
942  			ProdVV(NId, 1) -= GetAvgThetaLL(NId, NId, AId, false, true);
943  			ProdVV(NId, 2) -= GetAvgSqThetaLL(NId, NId, AId, true, false);
944  			ProdVV(NId, 3) -= GetAvgSqThetaLL(NId, NId, AId, false, true);
945  			for(int p = 0; p < NAttrs; p++) {
946  				if(p > AId) {
947  					int index = 4 * p;
948  					AvgPhiPairVV(AId, index) -= PhiVV(NId, AId) * PhiVV(NId, p);
949  					AvgPhiPairVV(AId, index+1) -= PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
950  					AvgPhiPairVV(AId, index+2) -= (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
951  					AvgPhiPairVV(AId, index+3) -= (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
952  				} else if (p < AId) {
953  					int index = 4 * AId;
954  					AvgPhiPairVV(p, index) -= PhiVV(NId, p) * PhiVV(NId, AId);
955  					AvgPhiPairVV(p, index+1) -= PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
956  					AvgPhiPairVV(p, index+2) -= (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
957  					AvgPhiPairVV(p, index+3) -= (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
958  				}
959  			}
960  			AvgPhiV[AId] -= PhiVV(NId, AId);
961  			PhiVV.At(NId, AId) = NewVal[l].Val1;
962  			ProdVV(NId, 0) += GetAvgThetaLL(NId, NId, AId, true, false);
963  			ProdVV(NId, 1) += GetAvgThetaLL(NId, NId, AId, false, true);
964  			ProdVV(NId, 2) += GetAvgSqThetaLL(NId, NId, AId, true, false);
965  			ProdVV(NId, 3) += GetAvgSqThetaLL(NId, NId, AId, false, true);
966  			for(int p = 0; p < NAttrs; p++) {
967  				if(p > AId) {
968  					int index = 4 * p;
969  					AvgPhiPairVV(AId, index) += PhiVV(NId, AId) * PhiVV(NId, p);
970  					AvgPhiPairVV(AId, index+1) += PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
971  					AvgPhiPairVV(AId, index+2) += (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
972  					AvgPhiPairVV(AId, index+3) += (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
973  				} else if (p < AId) {
974  					int index = 4 * AId;
975  					AvgPhiPairVV(p, index) += PhiVV(NId, p) * PhiVV(NId, AId);
976  					AvgPhiPairVV(p, index+1) += PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
977  					AvgPhiPairVV(p, index+2) += (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
978  					AvgPhiPairVV(p, index+3) += (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
979  				}
980  			}
981  			AvgPhiV[AId] += PhiVV(NId, AId);
982  		}
983  	}
984  	for(int l = 0; l < NAttrs; l++) {
985  		MuV[l] = AvgPhiV[l] / double(NNodes);
986  	}
987  	TFltV SortMuV = MuV;
988  	double Avg = 0.0;
989  	for(int l = 0; l < NAttrs; l++) {
990  		printf("  F[%d] = %.3f", l, double(MuV[l]));
991  		Avg += SortMuV[l];
992  	}
993  	printf("\n");
994  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
995  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
996  	return L1;
997  }
998  double TMAGFitBern::DoEStep(const TFltV& TrueMuV, const int& NIter, double& LL, const double& Lambda) {
999  	const int NNodes = Param.GetNodes();
1000  	const int NAttrs = Param.GetAttrs();
1001  	TFltVV NewPhiVV(NNodes, NAttrs);
1002  	TFltV Delta(NIter);
1003  	for(int i = 0; i < NIter; i++) {
1004  		TExeTm IterTm;
1005  		printf("EStep iteration : %d\n", (i+1));
1006  		if(ESpeedUp) {
1007  			Delta[i] = DoEStepApxOneIter(TrueMuV, NewPhiVV, Lambda);
1008  		} else {
1009  			Delta[i] = DoEStepOneIter(TrueMuV, NewPhiVV, Lambda);
1010  		}
1011  		printf("  (Time = %s)\n", IterTm.GetTmStr());
1012  	}
1013  	printf("\n");
1014  	NewPhiVV.Clr();
1015  	return Delta.Last();
1016  }
1017  const double TMAGFitBern::UpdateMu(const int& AId) {
1018  	const int NNodes = Param.GetNodes();
1019  	TMAGNodeBern DistParam = Param.GetNodeAttr();
1020  	const double OldMu = DistParam.GetMu(AId);
1021  	double NewMu = 0.0;
1022  	for(int i = 0; i < NNodes; i++) {
1023  		NewMu += PhiVV.At(i, AId);
1024  	}
1025  	AvgPhiV[AId] = NewMu;
1026  	NewMu /= double(NNodes);
1027  	printf("      [Posterior Mu] = %.4f\n", NewMu);
1028  	double Delta = fabs(NewMu - OldMu);
1029  	DistParam.SetMu(AId, NewMu);
1030  	Param.SetNodeAttr(DistParam);
1031  	return Delta;
1032  }
1033  const void TMAGFitBern::GradAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1034  	const int NNodes = Param.GetNodes();
1035  	GradV.PutAll(0.0);
1036  	for(int i = 0; i < NNodes; i++) {
1037  		for(int j = 0; j < NNodes; j++) {
1038  			double Prod = ProdVV(i, j) - GetThetaLL(i, j, AId);
1039  			double Sq = SqVV(i, j) - GetSqThetaLL(i, j, AId);
1040  			for(int p = 0; p < 4; p++) {
1041  				int Ai = p / 2;
1042  				int Aj = p % 2;
1043  				double Prob = GetProbPhi(i, j, AId, Ai, Aj);
1044  				if(Graph->IsEdge(i, j)) {
1045  					GradV[p] += Prob / CurMtx.At(p);
1046  				} else {
1047  					GradV[p] -= Prob * exp(Prod);
1048  					GradV[p] -= Prob * exp(Sq) * CurMtx.At(p);
1049  				}
1050  			}
1051  		}
1052  	}
1053  }
1054  const void TMAGFitBern::GradApxAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1055  	const int NNodes = Param.GetNodes();
1056  	GradV.PutAll(0.0);
1057  	TFltV LogSumV;
1058  	for(int p = 0; p < 4; p++) {
1059  		int Ai = p / 2;
1060  		int Aj = p % 2;
1061  		LogSumV.Gen(NNodes * 4, 0);
1062  		for(int i = 0; i < NNodes; i++) {
1063  			const double LProd = ProdVV(i, 0) - GetAvgThetaLL(i, i, AId, true, false);
1064  			const double LSq = SqVV(i, 0) - GetAvgSqThetaLL(i, i, AId, true, false);
1065  			const double RProd = ProdVV(i, 1) - GetAvgThetaLL(i, i, AId, false, true);
1066  			const double RSq = SqVV(i, 1) - GetAvgSqThetaLL(i, i, AId, false, true);
1067  			LogSumV.Add(LProd + log(GetProbMu(i, i, AId, Ai, Aj, true, false)));
1068  			LogSumV.Add(LSq + log(GetProbMu(i, i, AId, Ai, Aj, true, false)) + log(CurMtx.At(p)));
1069  			LogSumV.Add(RProd + log(GetProbMu(i, i, AId, Ai, Aj, false, true)));
1070  			LogSumV.Add(RSq + log(GetProbMu(i, i, AId, Ai, Aj, false, true)) + log(CurMtx.At(p)));
1071  		}
1072  		double LogSum = LogSumExp(LogSumV);
1073  		GradV[p] -= (NNodes - 1) * 0.5 * exp(LogSum);
1074  	}
1075  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1076  		const int NId1 = EI.GetSrcNId();
1077  		const int NId2 = EI.GetDstNId();
1078  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1079  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1080  		for(int p = 0; p < 4; p++) {
1081  			int Ai = p / 2;
1082  			int Aj = p % 2;
1083  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1084  			GradV[p] += Prob / CurMtx.At(p);
1085  			GradV[p] += Prob * exp(ProdOne);
1086  			GradV[p] += Prob * exp(SqOne) * CurMtx.At(p);
1087  		}
1088  	}
1089  #if 0
1090  	const double Prod = ProdVV(0, 0) - GetAvgThetaLL(0, 0, AId, false, false);
1091  	const double Sq = SqVV(0, 0) - GetAvgSqThetaLL(0, 0, AId, false, false);
1092  	for(int p = 0; p < 4; p++) {
1093  		int Ai = p / 2;
1094  		int Aj = p % 2;
1095  		GradV[p] -= NSq * exp(Prod) * GetProbMu(0, 0, AId, Ai, Aj, false, false);
1096  		GradV[p] -= NSq * exp(Sq) * GetProbMu(0, 0, AId, Ai, Aj, false, false) * CurMtx.At(p);
1097  	}
1098  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1099  		const int NId1 = EI.GetSrcNId();
1100  		const int NId2 = EI.GetDstNId();
1101  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1102  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1103  		for(int p = 0; p < 4; p++) {
1104  			int Ai = p / 2;
1105  			int Aj = p % 2;
1106  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1107  		}
1108  	}
1109  #endif
1110  }
1111  const double TMAGFitBern::UpdateAffMtx(const int& AId, const double& LrnRate, const double& MaxGrad, const double& Lambda, TFltVV& ProdVV, TFltVV& SqVV, TMAGAffMtx& NewMtx) {
1112  	double Delta = 0.0;
1113  	TMAGAffMtx AffMtx = Param.GetMtx(AId);
1114  	TFltV GradV(4);
1115  	TFltV HessV(4);
1116  	if(MSpeedUp) {
1117  		GradApxAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1118  	} else {
1119  		GradAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1120  	}
1121  	double Ratio = 1.0;
1122  	for(int p = 0; p < 4; p++) {
1123  		if(fabs(Ratio * LrnRate * GradV[p]) > MaxGrad) {
1124  			Ratio = MaxGrad / fabs(LrnRate * GradV[p]);
1125  		}
1126  	}
1127  	for(int p = 0; p < 4; p++) {
1128  		GradV[p] *= (Ratio * LrnRate);
1129  		NewMtx.At(p) = AffMtx.At(p) + GradV[p];
1130  		if(NewMtx.At(p) < 0.0001) {  NewMtx.At(p) = 0.0001;  }
1131  	}
1132  	printf("      [Attr = %d]\n", AId);
1133      printf("        %s  + [%f, %f; %f %f]  ----->  %s\n", (AffMtx.GetMtxStr()).GetCStr(), double(GradV[0]), double(GradV[1]), double(GradV[2]), double(GradV[3]), (NewMtx.GetMtxStr()).GetCStr());
1134  	return Delta;
1135  }
1136  void TMAGFitBern::NormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1137  	const int NNodes = Param.GetNodes();
1138  	const int NAttrs = MtxV.Len();
1139  	TFltV MuV = GetMuV();
1140  	double Product = 1.0, ExpEdge = NNodes * (NNodes - 1);
1141  	TFltV SumV(NAttrs), EdgeSumV(NAttrs);
1142  	SumV.PutAll(0.0);	EdgeSumV.PutAll(0.0);
1143  	for(int l = 0; l < NAttrs; l++) {
1144  		double Mu = (UseMu) ? double(MuV[l]) : (AvgPhiV[l] / double(NNodes));
1145  		EdgeSumV[l] += Mu * Mu * MtxV[l].At(0, 0);
1146  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1147  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1148  		EdgeSumV[l] += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1149  		SumV[l] = SumV[l] + MtxV[l].At(0, 0);
1150  		SumV[l] = SumV[l] + MtxV[l].At(0, 1);
1151  		SumV[l] = SumV[l] + MtxV[l].At(1, 0);
1152  		SumV[l] = SumV[l] + MtxV[l].At(1, 1);
1153  		Product *= SumV[l];
1154  		ExpEdge *= EdgeSumV[l];
1155  	}
1156  	ExpEdge = Graph->GetEdges() / ExpEdge;
1157  	NormConst *= Product;
1158  	Product = 1.0;
1159  	for(int l = 0; l < NAttrs; l++) {
1160  		for(int p = 0; p < 4; p++) {
1161  			MtxV[l].At(p) = MtxV[l].At(p) * Product / SumV[l];
1162  		}
1163  	}
1164  }
1165  void TMAGFitBern::UnNormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1166  	const int NNodes = Param.GetNodes();
1167  	const int NAttrs = MtxV.Len();
1168  	TFltIntPrV MaxEntV(NAttrs);
1169  	TFltV MuV = GetMuV();
1170  	NormalizeAffMtxV(MtxV, UseMu);
1171  	double ExpEdge = NNodes * (NNodes - 1);
1172  	for(int l = 0; l < NAttrs; l++) {
1173  		double Mu = MuV[l];
1174  		double EdgeSum = Mu * Mu * MtxV[l].At(0, 0);
1175  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1176  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1177  		EdgeSum += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1178  		ExpEdge *= EdgeSum;
1179  	}
1180  	NormConst = double(Graph->GetEdges()) / ExpEdge;
1181  	for(int l = 0; l < NAttrs; l++) {
1182  		MaxEntV[l] = TFltIntPr(-1, l);
1183  		for(int p = 0; p < 4; p++) {
1184  			if(MaxEntV[l].Val1 < MtxV[l].At(p)) {  MaxEntV[l].Val1 = MtxV[l].At(p);  }
1185  		}
1186  	}
1187  	MaxEntV.Sort(false);
1188  	for(int l = 0; l < NAttrs; l++) {
1189  		int CurId = MaxEntV[l].Val2;
1190  		double Factor = pow(NormConst, 1.0 / double(NAttrs - l));
1191  		double MaxFactor = 0.9999 / MaxEntV[l].Val1;
1192  		Factor = (Factor > MaxFactor) ? MaxFactor : Factor;
1193  		NormConst = NormConst / Factor;
1194  		for(int p = 0; p < 4; p++) {
1195  			MtxV[CurId].At(p) = MtxV[CurId].At(p) * Factor;
1196  		}
1197  	}
1198  }
1199  const void TMAGFitBern::PrepareUpdateAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1200  	const int NNodes = Param.GetNodes();
1201  	ProdVV.Gen(NNodes, NNodes);
1202  	SqVV.Gen(NNodes, NNodes);
1203  	for(int i = 0; i < NNodes; i++) {
1204  		for(int j = 0; j < NNodes; j++) {
1205  			ProdVV(i, j) = GetProdLinWeight(i, j);
1206  			SqVV(i, j) = GetProdSqWeight(i, j);
1207  		}
1208  	}
1209  }
1210  const void TMAGFitBern::PrepareUpdateApxAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1211  	const int NNodes = Param.GetNodes();
1212  	ProdVV.Gen(NNodes, 2);
1213  	SqVV.Gen(NNodes, 2);
1214  	for(int i = 0; i < NNodes; i++) {
1215  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
1216  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
1217  		SqVV(i, 0) = GetAvgProdSqWeight(i, i, true, false);
1218  		SqVV(i, 1) = GetAvgProdSqWeight(i, i, false, true);
1219  	}
1220  }
1221  const double TMAGFitBern::UpdateAffMtxV(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1222  	const int NNodes = Param.GetNodes();
1223  	const int NAttrs = Param.GetAttrs();
1224  	const TMAGNodeBern DistParam = Param.GetNodeAttr();
1225  	const TFltV MuV = DistParam.GetMuV();
1226  	double Delta = 0.0;
1227  	double DecLrnRate = LrnRate, DecMaxGrad = MaxGrad;
1228  	TFltVV ProdVV(NNodes, NNodes), SqVV(NNodes, NNodes);
1229  	TMAGAffMtxV NewMtxV, OldMtxV;
1230  	Param.GetMtxV(OldMtxV);
1231  	Param.GetMtxV(NewMtxV);
1232  	for(int g = 0; g < GradIter; g++) {
1233  		if(MSpeedUp) {
1234  			PrepareUpdateApxAffMtx(ProdVV, SqVV);
1235  		} else {
1236  			PrepareUpdateAffMtx(ProdVV, SqVV);
1237  		}
1238  		printf("    [Grad step = %d]\n", (g+1));
1239  		for(int l = NReal; l < NAttrs; l++) {
1240  			UpdateAffMtx(l, DecLrnRate, DecMaxGrad, Lambda, ProdVV, SqVV, NewMtxV[l]);
1241  			Param.SetMtxV(NewMtxV);
1242  		}
1243  		DecLrnRate *= 0.97;
1244  		DecMaxGrad *= 0.97;
1245  		printf("\n");
1246  		NormalizeAffMtxV(NewMtxV, true);
1247  		Param.SetMtxV(NewMtxV);
1248  	}
1249  	NormalizeAffMtxV(NewMtxV, true);
1250  	printf( "\nFinal\n");
1251  	for(int l = 0; l < NAttrs; l++) {
1252  		printf("    [");
1253  		for(int p = 0; p < 4; p++) {
1254  			Delta += fabs(OldMtxV[l].At(p) - NewMtxV[l].At(p));
1255  			printf(" %.4f ", double(NewMtxV[l].At(p)));
1256  		}
1257  		printf("]\n");
1258  	}
1259  	Param.SetMtxV(NewMtxV);
1260  	ProdVV.Clr();		SqVV.Clr();
1261  	return Delta;
1262  }
1263  void TMAGFitBern::DoMStep(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1264  	const int NAttrs = Param.GetAttrs();
1265  	double MuDelta = 0.0, AffMtxDelta = 0.0;
1266  	TExeTm ExeTm;
1267  	printf("\n");
1268  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
1269  	for(int l = 0; l < NAttrs; l++) {
1270  		MuDelta += UpdateMu(l);
1271  	}
1272  	printf("\n");
1273  	printf("  == Update Theta\n");
1274  	AffMtxDelta += UpdateAffMtxV(GradIter, LrnRate, MaxGrad, Lambda, NReal);
1275  	printf("\n");
1276  	printf("Elpased time = %s\n", ExeTm.GetTmStr());
1277  	printf("\n");
1278  }
1279  void TMAGFitBern::DoEMAlg(const int& NStep, const int& NEstep, const int& NMstep, const double& LrnRate, const double& MaxGrad, const double& Lambda, const double& ReInit, const int& NReal) {
1280  	const int NNodes = Param.GetNodes();
1281  	const int NAttrs = Param.GetAttrs();
1282  	TIntV IndexV;
1283  	double LL;
1284  	MuHisV.Gen(NStep + 1, 0);
1285  	MtxHisV.Gen(NStep + 1, 0);
1286  	LLHisV.Gen(NStep + 1, 0);
1287  	printf("--------------------------------------------\n");
1288  	printf("Before EM Iteration\n");
1289  	printf("--------------------------------------------\n");
1290  	TMAGAffMtxV InitMtxV;
1291  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1292  	Param.GetMtxV(InitMtxV);
1293  	TFltV InitMuV = NodeAttr.GetMuV();
1294  	for(int i = 0; i < NNodes; i++) {
1295  		for(int l = 0; l < NAttrs; l++) {
1296  			if(! KnownVV(i, l)) {
1297  				PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1298  			}
1299  		}
1300  	}
1301  	if(Debug) {
1302  		double LL = ComputeApxLL();
1303  		MuHisV.Add(InitMuV);
1304  		MtxHisV.Add(InitMtxV);
1305  		LLHisV.Add(LL);
1306  	}
1307  	NormalizeAffMtxV(InitMtxV, true);
1308  	Param.SetMtxV(InitMtxV);
1309  	for(int n = 0; n < NStep; n++) {
1310  		printf("--------------------------------------------\n");
1311  		printf("EM Iteration : %d\n", (n+1));
1312  		printf("--------------------------------------------\n");
1313  		NodeAttr = Param.GetNodeAttr();
1314  		for(int i = 0; i < NNodes; i++) {
1315  			for(int l = 0; l < NAttrs; l++) {
1316  				if(!KnownVV(i, l) && TMAGNodeBern::Rnd.GetUniDev() < ReInit) {
1317  					PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1318  				}
1319  			}
1320  		}
1321  		DoEStep(InitMuV, NEstep, LL, Lambda);
1322  		Param.GetMtxV(InitMtxV);
1323  		Param.SetMtxV(InitMtxV);
1324  		DoMStep(NMstep, LrnRate, MaxGrad, Lambda, NReal);
1325  		printf("\n");
1326  		if(Debug) {
1327  			double LL = ComputeApxLL();
1328  			MuHisV.Add(InitMuV);
1329  			MtxHisV.Add(InitMtxV);
1330  			LLHisV.Add(LL);
1331  			printf("    ApxLL = %.2f (Const = %f)\n", LL, double(NormConst));
1332  		}
1333  	}
1334  	Param.GetMtxV(InitMtxV);
1335  	UnNormalizeAffMtxV(InitMtxV, true);
1336  	Param.SetMtxV(InitMtxV);
1337  }
1338  void TMAGFitBern::MakeCCDF(const TFltPrV& RawV, TFltPrV& CcdfV) {
1339  	double Total = 0.0;
1340  	CcdfV.Gen(RawV.Len(), 0);
1341  	for(int i = 0; i < RawV.Len(); i++) {
1342  		if(RawV[i].Val2 <= 0) {  continue;  }
1343  		Total += RawV[i].Val2;
1344  		CcdfV.Add(RawV[i]);
1345  		IAssert(RawV[i].Val2 > 0);
1346  	}
1347  	for(int i = 1; i < CcdfV.Len(); i++) {
1348  		CcdfV[i].Val2 += CcdfV[i-1].Val2;
1349  	}
1350  	for(int i = CcdfV.Len() - 1; i > 0; i--) {
1351  		CcdfV[i].Val2 = (Total - CcdfV[i-1].Val2) ;
1352  		if(CcdfV[i].Val2 <= 0) {  printf("CCDF = %f\n", double(CcdfV[i].Val2));}
1353  		IAssert(CcdfV[i].Val2 > 0);
1354  	}
1355  	CcdfV[0].Val2 = Total;
1356  }
1357  void TMAGFitBern::PlotProperties(const TStr& FNm) {
1358  	const int NNodes = Param.GetNodes();
1359  	const int NAttrs = Param.GetAttrs();
1360  	TMAGParam<TMAGNodeBern> MAGGen(NNodes, NAttrs);
1361  	TMAGNodeBern MAGNode = Param.GetNodeAttr();
1362  	MAGGen.SetNodeAttr(MAGNode);
1363  	TMAGAffMtxV MtxV;	Param.GetMtxV(MtxV);
1364  	MAGGen.SetMtxV(MtxV);
1365  	PNGraph TrG = new TNGraph;
1366  	*TrG = *Graph;
1367  	TIntVV AttrVV(NNodes, NAttrs);
1368  	for(int i = 0; i < NNodes; i++) {
1369  		for(int j = 0; j < NAttrs; j++) {
1370  			if(PhiVV(i, j) > TMAGNodeBern::Rnd.GetUniDev())	AttrVV(i, j) = 0;
1371  			else AttrVV(i, j) = 1;
1372  		}
1373  	}
1374  	PNGraph MAG = MAGGen.GenMAG(AttrVV, true, 10000);
1375  	printf("%d edges created for MAG...\n", MAG->GetEdges());
1376  	TSnap::DelZeroDegNodes(TrG);
1377  	TSnap::DelZeroDegNodes(MAG);
1378  	TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
1379      TGnuPlot InDegP(FNm + "-InDeg"), OutDegP(FNm + "-OutDeg"), SvalP(FNm + "-Sval"), SvecP(FNm + "-Svec"), WccP(FNm + "-Wcc"), HopP(FNm + "-Hop"), TriadP(FNm + "-Triad"), CcfP(FNm + "-Ccf");;
1380      InDegP.SetXYLabel("Degree", "# of nodes");
1381      OutDegP.SetXYLabel("Degree", "# of nodes");
1382      SvalP.SetXYLabel("Rank", "Singular value");
1383      SvecP.SetXYLabel("Rank", "Primary SngVec component");
1384      WccP.SetXYLabel("Size of component", "# of components");
1385      CcfP.SetXYLabel("Degree", "Clustering coefficient");
1386      HopP.SetXYLabel("Hops", "# of node pairs");
1387      TriadP.SetXYLabel("# of triads", "# of participating nodes");
1388      InDegP.SetScale(gpsLog10XY);    InDegP.AddCmd("set key top right");
1389      OutDegP.SetScale(gpsLog10XY);   OutDegP.AddCmd("set key top right");
1390      SvalP.SetScale(gpsLog10XY);     SvalP.AddCmd("set key top right");
1391      SvecP.SetScale(gpsLog10XY);     SvecP.AddCmd("set key top right");
1392      CcfP.SetScale(gpsLog10XY);      CcfP.AddCmd("set key top right");
1393      HopP.SetScale(gpsLog10XY);      HopP.AddCmd("set key top right");
1394      TriadP.SetScale(gpsLog10XY);    TriadP.AddCmd("set key top right");
1395  	InDegP.ShowGrid(false);
1396  	OutDegP.ShowGrid(false);
1397  	SvalP.ShowGrid(false);
1398  	SvecP.ShowGrid(false);
1399  	CcfP.ShowGrid(false);
1400  	HopP.ShowGrid(false);
1401  	TriadP.ShowGrid(false);
1402  	const TStr Style[2] = {"lt 1 lw 3 lc rgb 'black'", "lt 2 lw 3 lc rgb 'red'"};
1403  	const TStr Name[2] = {"Real", "MAG"};
1404  	GS.Add(Graph, TSecTm(1), "Real Graph");
1405  	GS.Add(MAG, TSecTm(2), "MAG");
1406  	TFltPrV InDegV, OutDegV, SvalV, SvecV, HopV, WccV, CcfV, TriadV;
1407  	for(int i = 0; i < GS.Len(); i++) {
1408  		MakeCCDF(GS.At(i)->GetDistr(gsdInDeg), InDegV);
1409  		MakeCCDF(GS.At(i)->GetDistr(gsdOutDeg), OutDegV);
1410  		SvalV = GS.At(i)->GetDistr(gsdSngVal);
1411  		SvecV = GS.At(i)->GetDistr(gsdSngVec);
1412  		MakeCCDF(GS.At(i)->GetDistr(gsdClustCf), CcfV);
1413  		HopV = GS.At(i)->GetDistr(gsdHops);
1414  		MakeCCDF(GS.At(i)->GetDistr(gsdTriadPart), TriadV);
1415  		InDegP.AddPlot(InDegV, gpwLines, Name[i], Style[i]);
1416  		OutDegP.AddPlot(OutDegV, gpwLines, Name[i], Style[i]);
1417  		SvalP.AddPlot(SvalV, gpwLines, Name[i], Style[i]);
1418  		SvecP.AddPlot(SvecV, gpwLines, Name[i], Style[i]);
1419  		CcfP.AddPlot(CcfV, gpwLines, Name[i], Style[i]);
1420  		HopP.AddPlot(HopV, gpwLines, Name[i], Style[i]);
1421  		TriadP.AddPlot(TriadV, gpwLines, Name[i], Style[i]);
1422  	}
1423  	InDegP.SaveEps(30);
1424  	OutDegP.SaveEps(30);
1425  	SvalP.SaveEps(30);
1426  	SvecP.SaveEps(30);
1427  	CcfP.SaveEps(30);
1428  	HopP.SaveEps(30);
1429  	TriadP.SaveEps(30);
1430  }
1431  void TMAGFitBern::CountAttr(TFltV& EstMuV) const {
1432  	const int NNodes = PhiVV.GetXDim();
1433  	const int NAttrs = PhiVV.GetYDim();
1434  	EstMuV.Gen(NAttrs);
1435  	EstMuV.PutAll(0.0);
1436  	for(int l = 0; l < NAttrs; l++) {
1437  		for(int i = 0; i < NNodes; i++) {
1438  			EstMuV[l] = EstMuV[l] + PhiVV(i, l);
1439  		}
1440  		EstMuV[l] = EstMuV[l] / double(NNodes);
1441  	}
1442  }
1443  void TMAGFitBern::SortAttrOrdering(const TFltV& TrueMuV, TIntV& IndexV) const {
1444  	const int NAttrs = TrueMuV.Len();
1445  	TFltV EstMuV, SortedTrueMuV, SortedEstMuV, TrueIdxV, EstIdxV;
1446  	IndexV.Gen(NAttrs);
1447  	TrueIdxV.Gen(NAttrs);
1448  	EstIdxV.Gen(NAttrs);
1449  	for(int l = 0; l < NAttrs; l++) {
1450  		TrueIdxV[l] = l;
1451  		EstIdxV[l] = l;
1452  	}
1453  	CountAttr(EstMuV);
1454  	SortedTrueMuV = TrueMuV;
1455  	SortedEstMuV = EstMuV;
1456  	for(int i = 0; i < NAttrs; i++) {
1457  		if(SortedTrueMuV[i] > 0.5) {  SortedTrueMuV[i] = 1.0 - SortedTrueMuV[i];  }
1458  		if(SortedEstMuV[i] > 0.5) {  SortedEstMuV[i] = 1.0 - SortedEstMuV[i];  }
1459  	}
1460  	for(int i = 0; i < NAttrs; i++) {
1461  		for(int j = i+1; j < NAttrs; j++) {
1462  			if(SortedTrueMuV[i] < SortedTrueMuV[j]) {
1463  				SortedTrueMuV.Swap(i, j);
1464  				TrueIdxV.Swap(i, j);
1465  			}
1466  			if(SortedEstMuV[i] < SortedEstMuV[j]) {
1467  				EstIdxV.Swap((int)SortedEstMuV[i], (int)SortedEstMuV[j]);
1468  				SortedEstMuV.Swap(i, j);
1469  			}
1470  		}
1471  	}
1472  	for(int l = 0; l < NAttrs; l++) {
1473  		IndexV[l] = (int)TrueIdxV[(int)EstIdxV[l]];
1474  	}
1475  }
1476  const bool TMAGFitBern::NextPermutation(TIntV& IndexV) const {
1477  	const int NAttrs = IndexV.Len();
1478  	int Pos = NAttrs - 1;
1479  	while(Pos > 0) {
1480  		if(IndexV[Pos-1] < IndexV[Pos]) {
1481  			break;
1482  		}
1483  		Pos--;
1484  	}
1485  	if(Pos == 0) {
1486  		return false;
1487  	}
1488  	int Val = NAttrs, NewPos = -1;
1489  	for(int i = Pos; i < NAttrs; i++) {
1490  		if(IndexV[i] > IndexV[Pos - 1] && IndexV[i] < Val) {
1491  			NewPos = i;
1492  			Val = IndexV[i];
1493  		}
1494  	}
1495  	IndexV[NewPos] = IndexV[Pos - 1];
1496  	IndexV[Pos - 1] = Val;
1497  	TIntV SubIndexV;
1498      IndexV.GetSubValV(Pos, NAttrs - 1, SubIndexV);
1499  	SubIndexV.Sort(true);
1500  	for(int i = Pos; i < NAttrs; i++) {
1501  		IndexV[i] = SubIndexV[i - Pos];
1502  	}
1503  	return true;
1504  }
1505  const double TMAGFitBern::ComputeJointOneLL(const TIntVV& AttrVV) const {
1506  	double LL = 0.0;
1507  	const int NNodes = Param.GetNodes();
1508  	const int NAttrs = Param.GetAttrs();
1509  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1510  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1511  	const TFltV MuV = NodeAttr.GetMuV();
1512  	for(int l = 0; l < NAttrs; l++) {
1513  		for(int i = 0; i < MtxV[l].Len(); i++) {
1514  			MtxV[l].At(i) = log(MtxV[l].At(i));
1515  		}
1516  	}
1517  	for(int i = 0; i < NNodes; i++) {
1518  		for(int l = 0; l < NAttrs; l++) {
1519  			if(AttrVV.At(i, l) == 0) {
1520  				LL += log(MuV[l]);
1521  			} else {
1522  				LL += log(1.0 - MuV[l]);
1523  			}
1524  		}
1525  		for(int j = 0; j < NNodes; j++) {
1526  			if(i == j) {  continue;  }
1527  			double ProbLL = 0.0;
1528  			for(int l = 0; l < NAttrs; l++) {
1529  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1530  			}
1531  			if(Graph->IsEdge(i, j)) {
1532  				LL += ProbLL;
1533  			} else {
1534  				LL += log(1-exp(ProbLL));
1535  			}
1536  		}
1537  	}
1538  	return LL;
1539  }
1540  const double TMAGFitBern::ComputeJointAdjLL(const TIntVV& AttrVV) const {
1541  	double LL = 0.0;
1542  	const int NNodes = Param.GetNodes();
1543  	const int NAttrs = Param.GetAttrs();
1544  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1545  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1546  	const TFltV MuV = NodeAttr.GetMuV();
1547  	for(int l = 0; l < NAttrs; l++) {
1548  		for(int i = 0; i < MtxV[l].Len(); i++) {
1549  			MtxV[l].At(i) = log(MtxV[l].At(i));
1550  		}
1551  	}
1552  	for(int i = 0; i < NNodes; i++) {
1553  		for(int j = 0; j < NNodes; j++) {
1554  			if(i == j) {  continue;  }
1555  			double ProbLL = 0.0;
1556  			for(int l = 0; l < NAttrs; l++) {
1557  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1558  			}
1559  			if(Graph->IsEdge(i, j)) {
1560  				LL += ProbLL;
1561  			} else {
1562  				LL += log(1-exp(ProbLL));
1563  			}
1564  		}
1565  	}
1566  	return LL;
1567  }
1568  const double TMAGFitBern::ComputeJointLL(int NSample) const {
1569  	double LL = 0.0;
1570  	const int NNodes = Param.GetNodes();
1571  	const int NAttrs = Param.GetAttrs();
1572  	TRnd Rnd(2000);
1573  	TIntVV AttrVV(NNodes, NAttrs);
1574  	int count = 0;
1575  	for(int s = 0; s < NSample; s++) {
1576  		for(int i = 0; i < NNodes; i++) {
1577  			for(int l = 0; l < NAttrs; l++) {
1578  				if(Rnd.GetUniDev() <= PhiVV(i, l)) {
1579  					AttrVV.At(i, l) = 0;
1580  				} else {
1581  					AttrVV.At(i, l) = 1;
1582  				}
1583  				if(PhiVV(i, l) > 0.05 && PhiVV(i, l) < 0.95) count++;
1584  			}
1585  		}
1586  		LL += ComputeJointOneLL(AttrVV);
1587  	}
1588  	AttrVV.Clr();
1589  	return LL / double(NSample);
1590  }
1591  const double TMAGFitBern::ComputeApxLL() const {
1592  	double LL = 0.0;
1593  	const int NNodes = Param.GetNodes();
1594  	const int NAttrs = Param.GetAttrs();
1595  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1596  	TFltV MuV = NodeAttr.GetMuV();
1597  	TMAGAffMtxV LLMtxV(NAttrs);
1598  	for(int l = 0; l < NAttrs; l++) {
1599  		for(int i = 0; i < NNodes; i++) {
1600  			LL += PhiVV(i, l) * log(MuV[l]);
1601  			LL += (1.0 - PhiVV(i, l)) * log(1.0 - MuV[l]);
1602  			LL -= PhiVV(i, l) * log(PhiVV(i, l));
1603  			LL -= (1.0 - PhiVV(i, l)) * log(1.0 - PhiVV(i, l));
1604  		}
1605  		TMAGAffMtx Theta = Param.GetMtx(l);
1606  		Theta.GetLLMtx(LLMtxV[l]);
1607  	}
1608  	for(int i = 0; i < NNodes; i++) {
1609  		for(int j = 0; j < NNodes; j++) {
1610  			if(i == j) {  continue;  }
1611  			if(Graph->IsEdge(i, j)) {
1612  				for(int l = 0; l < NAttrs; l++) {
1613  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1614  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1615  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1616  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1617  				}
1618  				LL += log(NormConst);
1619  			} else {
1620  				LL += log(1-exp(GetProdLinWeight(i, j)));
1621  			}
1622  		}
1623  	}
1624  	return LL;
1625  }
1626  const double TMAGFitBern::ComputeApxAdjLL() const {
1627  	double LL = 0.0;
1628  	const int NNodes = Param.GetNodes();
1629  	const int NAttrs = Param.GetAttrs();
1630  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1631  	TFltV MuV = NodeAttr.GetMuV();
1632  	MuV.PutAll(0.0);
1633  	TMAGAffMtxV LLMtxV(NAttrs);
1634  	double TotalEdge = 0.0;
1635  	for(int l = 0; l < NAttrs; l++) {
1636  		TMAGAffMtx Theta = Param.GetMtx(l);
1637  		Theta.GetLLMtx(LLMtxV[l]);
1638  	}
1639  	for(int i = 0; i < NNodes; i++) {
1640  		for(int j = 0; j < NNodes; j++) {
1641  			if(i == j) {  continue;  }
1642  			if(Graph->IsEdge(i, j)) {
1643  				for(int l = 0; l < NAttrs; l++) {
1644  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1645  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1646  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1647  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1648  				}
1649  			} else {
1650  				LL += log(1-exp(GetProdLinWeight(i, j)));
1651  			}
1652  			double TempLL = 1.0;
1653  			for(int l = 0; l < NAttrs; l++) {
1654  				int Ai = (double(PhiVV(i, l)) > 0.5) ? 0 : 1;
1655  				int Aj = (double(PhiVV(j, l)) > 0.5) ? 0 : 1;
1656  				TempLL *= Param.GetMtx(l).At(Ai, Aj);
1657  			}
1658  			if(TMAGNodeBern::Rnd.GetUniDev() < TempLL) {
1659  				TotalEdge += 1.0;
1660  			}
1661  		}
1662  	}
1663  	return LL;
1664  }
1665  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV, const int AId1, const int AId2) {
1666  	const int NNodes = AttrV.GetXDim();
1667  	double MI = 0.0;
1668  	double Cor = 0.0;
1669  	TFltVV Pxy(2,2);
1670  	TFltV Px(2), Py(2);
1671  	Pxy.PutAll(0.0);
1672  	Px.PutAll(0.0);
1673  	Py.PutAll(0.0);
1674  	for(int i = 0; i < NNodes; i++) {
1675  		int X = AttrV(i, AId1);
1676  		int Y = AttrV(i, AId2);
1677  		Pxy(X, Y) = Pxy(X, Y) + 1;
1678  		Px[X] = Px[X] + 1;
1679  		Py[Y] = Py[Y] + 1;
1680  		Cor += double(X * Y);
1681  	}
1682  	for(int x = 0; x < 2; x++) {
1683  		for(int y = 0; y < 2; y++) {
1684        MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y).Val) - log(Px[x].Val) - log(Py[y].Val) + log((double)NNodes));
1685  		}
1686  	}
1687  	return MI;
1688  }
1689  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV, const int AId1, const int AId2) {
1690  	const int NNodes = AttrV.GetXDim();
1691  	double MI = 0.0;
1692  	double Cor = 0.0;
1693  	TFltVV Pxy(2,2);
1694  	TFltV Px(2), Py(2);
1695  	Pxy.PutAll(0.0);
1696  	Px.PutAll(0.0);
1697  	Py.PutAll(0.0);
1698  	for(int i = 0; i < NNodes; i++) {
1699  		double X = AttrV(i, AId1);
1700  		double Y = AttrV(i, AId2);
1701  		Pxy(0, 0) = Pxy(0, 0) + X * Y;
1702  		Pxy(0, 1) = Pxy(0, 1) + X * (1 - Y);
1703  		Pxy(1, 0) = Pxy(1, 0) + (1 - X) * Y;
1704  		Pxy(1, 1) = (i+1) - Pxy(0, 0) - Pxy(0, 1) - Pxy(1, 0);
1705  		Px[0] = Px[0] + X;
1706  		Py[0] = Py[0] + Y;
1707  		Cor += double((1-X) * (1-Y));
1708  	}
1709  	Px[1] = NNodes - Px[0];
1710  	Py[1] = NNodes - Py[0];
1711  	for(int x = 0; x < 2; x++) {
1712  		for(int y = 0; y < 2; y++) {
1713  			MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y)) - log(Px[x]) - log(Py[y]) + log(double(NNodes)));
1714  		}
1715  	}
1716  	return MI;
1717  }
1718  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV) {
1719  	const int NAttrs = AttrV.GetYDim();
1720  	double MI = 0.0;
1721  	for(int l = 0; l < NAttrs; l++) {
1722  		for(int k = l+1; k < NAttrs; k++) {
1723  			MI += ComputeMI(AttrV, l, k);
1724  		}
1725  	}
1726  	return MI;
1727  }
1728  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV) {
1729  	const int NAttrs = AttrV.GetYDim();
1730  	double MI = 0.0;
1731  	for(int l = 0; l < NAttrs; l++) {
1732  		for(int k = l+1; k < NAttrs; k++) {
1733  			MI += ComputeMI(AttrV, l, k);
1734  		}
1735  	}
1736  	return MI;
1737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</div>
                </div>
                <div class="column column_space"><pre><code>207  TStr TNmObjBs::GetWordStrVStr(const TStrV& WordStrV, const char& SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN<WordStrV.Len(); WordStrN++){
210      if (WordStrN>0){WordChA+=SepCh;}
</pre></code></div>
                <div class="column column_space"><pre><code>166  	for(int i = 0; i < NNodes; i++) {
167  		for(int l = 0; l < Dim; l++) {
168  			if((TMAGNodeSimple::Rnd).GetUniDev() > Mu) {
169  				AttrVV.At(i, l) = 1;
170  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    