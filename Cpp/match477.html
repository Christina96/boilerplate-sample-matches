<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for tolerances_test.cpp & joint_trajectory_controller_wrapping_test.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for tolerances_test.cpp & joint_trajectory_controller_wrapping_test.cpp
      </h3>
      <h1 align="center">
        7.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>tolerances_test.cpp (9.090909%)<TH>joint_trajectory_controller_wrapping_test.cpp (6.5326633%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match477-0.html#0',2,'match477-1.html#0',3)" NAME="0">(223-237)<TD><A HREF="javascript:ZweiFrames('match477-0.html#0',2,'match477-1.html#0',3)" NAME="0">(61-85)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tolerances_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013, PAL Robotics S.L.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of PAL Robotics S.L. nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//////////////////////////////////////////////////////////////////////////////

/// \author Adolfo Rodriguez Tsouroukdissian

#include &lt;gtest/gtest.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;trajectory_interface/pos_vel_acc_state.h&gt;
#include &lt;joint_trajectory_controller/tolerances.h&gt;

using namespace joint_trajectory_controller;
typedef trajectory_interface::PosVelAccState&lt;double&gt; State;
typedef StateTolerances&lt;double&gt; StateTols;

TEST(TolerancesTest, CheckStateTolerance)
{
  const double tol = 1.0;

  State state_error_ok;
  state_error_ok.position.resize(2, -tol);
  state_error_ok.velocity.resize(2, -tol);
  state_error_ok.acceleration.resize(2, -tol);

  // Empty tolerances: No checks take place
  {
    std::vector&lt;StateTols&gt; state_tols(2);
    EXPECT_TRUE(checkStateTolerance(state_error_ok, state_tols));
  }

  // Check position-only tolerances
  {
    State state_error = state_error_ok;
    StateTols state_tol;
    state_tol.position = tol;
    std::vector&lt;StateTols&gt; state_tols(2, state_tol);

    // Tolerances OK
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase non-checked variable errors
    state_error.velocity.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    state_error.acceleration.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase position errors
    state_error.position.back() *= 2.0;
    EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
  }

  // Check velocity-only tolerances
  {
    State state_error = state_error_ok;
    StateTols state_tol;
    state_tol.velocity = tol;
    std::vector&lt;StateTols&gt; state_tols(2, state_tol);

    // Tolerances OK
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase non-checked variable errors
    state_error.position.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    state_error.acceleration.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase velocity errors
    state_error.velocity.back() *= 2.0;
    EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
  }

  // Check acceleration-only tolerances
  {
    State state_error = state_error_ok;
    StateTols state_tol;
    state_tol.acceleration = tol;
    std::vector&lt;StateTols&gt; state_tols(2, state_tol);

    // Tolerances OK
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase non-checked variable errors
    state_error.position.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    state_error.velocity.back() *= 2.0;
    EXPECT_TRUE(checkStateTolerance(state_error, state_tols));

    // Increase acceleration errors
    state_error.acceleration.back() *= 2.0;
    EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
  }
}

TEST(TolerancesTest, UpdateStateTolerances)
{
  StateTols default_state_tols(1.0, 2.0, 3.0);

  control_msgs::JointTolerance default_tol_msg;
  default_tol_msg.name         = &quot;foo_joint&quot;;
  default_tol_msg.position     = 0.0;
  default_tol_msg.velocity     = 0.0;
  default_tol_msg.acceleration = 0.0;

  // Zero tolerances: No-op
  {
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(default_state_tols.position, state_tols.position);
    EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
    EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
  }

  // Negative tolerances: Reset existing values
  {
    // Position
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.position = -1.0;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(0.0,                             state_tols.position);
    EXPECT_EQ(default_state_tols.velocity,     state_tols.velocity);
    EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
  }
  {
    // Velocity
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.velocity = -1.0;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(default_state_tols.position,     state_tols.position);
    EXPECT_EQ(0.0,                             state_tols.velocity);
    EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
  }
  {
    // Acceleration
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.acceleration = -1.0;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(default_state_tols.position, state_tols.position);
    EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
    EXPECT_EQ(0.0,                         state_tols.acceleration);
  }

  // Positive tolerances: Override existing values
  {
    // Position
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.position = 0.5;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(tol_msg.position,                state_tols.position);
    EXPECT_EQ(default_state_tols.velocity,     state_tols.velocity);
    EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
  }
  {
    // Velocity
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.velocity = 0.5;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(default_state_tols.position,     state_tols.position);
    EXPECT_EQ(tol_msg.velocity,                state_tols.velocity);
    EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
  }
  {
    // Acceleration
    StateTols state_tols = default_state_tols;
    control_msgs::JointTolerance tol_msg = default_tol_msg;
    tol_msg.acceleration = 0.5;
    updateStateTolerances(tol_msg, state_tols);
    EXPECT_EQ(default_state_tols.position, state_tols.position);
    EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
    EXPECT_EQ(tol_msg.acceleration,        state_tols.acceleration);
  }
}

TEST(TolerancesTest, UpdateSegmentTolerances)
{
  // Joint names
  std::vector&lt;std::string&gt; joint_names(2);
  joint_names[0] = &quot;foo_joint&quot;;
  joint_names[1] = &quot;bar_joint&quot;;

  // Tolerances to update from message data
  SegmentTolerances&lt;double&gt; ref_segment_tols(2);
  ref_segment_tols.state_tolerance[0]      = StateTolerances&lt;double&gt;(1.0, 1.0, 1.0);
  ref_segment_tols.state_tolerance[1]      = StateTolerances&lt;double&gt;(2.0, 2.0, 2.0);
  ref_segment_tols.goal_state_tolerance[0] = StateTolerances&lt;double&gt;(3.0, 3.0, 3.0);
  ref_segment_tols.goal_state_tolerance[1] = StateTolerances&lt;double&gt;(4.0, 4.0, 4.0);
  ref_segment_tols.goal_time_tolerance     = 1.0;
<A NAME="0"></A>
  // Message data
  control_msgs::JointTolerance invalid_tol_msg;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match477-1.html#0',3,'match477-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  invalid_tol_msg.name         = &quot;invalid_joint&quot;;
  invalid_tol_msg.position     = -1.0;
  invalid_tol_msg.velocity     = -1.0;
  invalid_tol_msg.acceleration = -1.0;

  control_msgs::JointTolerance state_tol_msg;
  state_tol_msg.name         = joint_names[0];
  state_tol_msg.position     =  0.5;
  state_tol_msg.velocity     =  0.0;
  state_tol_msg.acceleration = -1.0;

  control_msgs::JointTolerance goal_state_tol_msg;
  goal_state_tol_msg.name         = joint_names[1];
  goal_state_tol_msg.position     =  0.25;
  goal_state_tol_msg.velocity     =  0.0;</B></FONT>
  goal_state_tol_msg.acceleration = -1.0;

  control_msgs::FollowJointTrajectoryGoal goal;
  goal.path_tolerance.push_back(invalid_tol_msg); // Useless data that should be ignored
  goal.path_tolerance.push_back(state_tol_msg);   // Only first joint has state tolerances
  goal.path_tolerance.push_back(invalid_tol_msg); // Useless data that should be ignored

  goal.goal_tolerance.push_back(invalid_tol_msg);    // Useless data that should be ignored
  goal.goal_tolerance.push_back(invalid_tol_msg);    // Useless data that should be ignored
  goal.goal_tolerance.push_back(goal_state_tol_msg); // Only second joint has goal state tolerances

  goal.goal_time_tolerance = ros::Duration(0.0); // No-op

  // Update tolerances from message
  SegmentTolerances&lt;double&gt; segment_tols = ref_segment_tols;
  updateSegmentTolerances(goal, joint_names, segment_tols);

  // First joint should get only state tolerances updated
  EXPECT_EQ(state_tol_msg.position,                       segment_tols.state_tolerance[0].position);     // Update
  EXPECT_EQ(ref_segment_tols.state_tolerance[0].velocity, segment_tols.state_tolerance[0].velocity);     // No-op
  EXPECT_EQ(0.0,                                          segment_tols.state_tolerance[0].acceleration); // Reset

  EXPECT_EQ(ref_segment_tols.state_tolerance[1].position,     segment_tols.state_tolerance[1].position);     // No-op
  EXPECT_EQ(ref_segment_tols.state_tolerance[1].velocity,     segment_tols.state_tolerance[1].velocity);     // No-op
  EXPECT_EQ(ref_segment_tols.state_tolerance[1].acceleration, segment_tols.state_tolerance[1].acceleration); // No-op

  // Second joint should get only goal state tolerances updated
  EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].position,     segment_tols.goal_state_tolerance[0].position);     // No-op
  EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].velocity,     segment_tols.goal_state_tolerance[0].velocity);     // No-op
  EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].acceleration, segment_tols.goal_state_tolerance[0].acceleration); // No-op

  EXPECT_EQ(goal_state_tol_msg.position,                       segment_tols.goal_state_tolerance[1].position);     // Update
  EXPECT_EQ(ref_segment_tols.goal_state_tolerance[1].velocity, segment_tols.goal_state_tolerance[1].velocity);     // No-op
  EXPECT_EQ(0.0,                                               segment_tols.goal_state_tolerance[1].acceleration); // Reset

  // Goal time constraint
  EXPECT_EQ(ref_segment_tols.goal_time_tolerance, segment_tols.goal_time_tolerance); // No-op

  goal.goal_time_tolerance = ros::Duration(1.0);
  updateSegmentTolerances(goal, joint_names, segment_tols);
  EXPECT_EQ(goal.goal_time_tolerance.toSec(), segment_tols.goal_time_tolerance);     // Update

  goal.goal_time_tolerance = ros::Duration(-1.0);
  updateSegmentTolerances(goal, joint_names, segment_tols);
  EXPECT_EQ(0.0, segment_tols.goal_time_tolerance);                                  // Reset
}

TEST(TolerancesTest, getSegmentTolerances)
{
  ros::NodeHandle nh(&quot;test/constraints&quot;);

  std::vector&lt;std::string&gt; joint_names(2);
  joint_names[0] = &quot;foo_joint&quot;;
  joint_names[1] = &quot;bar_joint&quot;;

  SegmentTolerances&lt;double&gt; segment_tols = getSegmentTolerances&lt;double&gt;(nh, joint_names);

  EXPECT_EQ(joint_names.size(), segment_tols.state_tolerance.size());
  EXPECT_EQ(joint_names.size(), segment_tols.goal_state_tolerance.size());

  EXPECT_EQ(0.05, segment_tols.state_tolerance[0].position);
  EXPECT_EQ(0.0,  segment_tols.state_tolerance[0].velocity);
  EXPECT_EQ(0.0,  segment_tols.state_tolerance[0].acceleration);

  EXPECT_EQ(0.0, segment_tols.state_tolerance[1].position);
  EXPECT_EQ(0.0, segment_tols.state_tolerance[1].velocity);
  EXPECT_EQ(0.0, segment_tols.state_tolerance[1].acceleration);

  EXPECT_EQ(0.03, segment_tols.goal_state_tolerance[0].position);
  EXPECT_EQ(0.02, segment_tols.goal_state_tolerance[0].velocity);
  EXPECT_EQ(0.0,  segment_tols.goal_state_tolerance[0].acceleration);

  EXPECT_EQ(0.01, segment_tols.goal_state_tolerance[1].position);
  EXPECT_EQ(0.02, segment_tols.goal_state_tolerance[1].velocity);
  EXPECT_EQ(0.0,  segment_tols.goal_state_tolerance[1].acceleration);
}

int main(int argc, char** argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  ros::init(argc, argv, &quot;tolerances_test&quot;);
  return RUN_ALL_TESTS();
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joint_trajectory_controller_wrapping_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013, PAL Robotics S.L.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of PAL Robotics S.L. nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//////////////////////////////////////////////////////////////////////////////

/// \author Adolfo Rodriguez Tsouroukdissian

#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;

#include &lt;gtest/gtest.h&gt;

#include &lt;ros/ros.h&gt;
#include &lt;actionlib/client/simple_action_client.h&gt;

#include &lt;std_msgs/Float64.h&gt;
#include &lt;control_msgs/FollowJointTrajectoryAction.h&gt;
#include &lt;control_msgs/JointTrajectoryControllerState.h&gt;
#include &lt;control_msgs/QueryTrajectoryState.h&gt;

// Floating-point value comparison threshold
const double EPS = 0.01;

using actionlib::SimpleClientGoalState;

class JointTrajectoryControllerTest : public ::testing::Test
{
public:
  JointTrajectoryControllerTest()
    : nh(&quot;rrbot_wrapping_controller&quot;),
      short_timeout(1.0),
      long_timeout(10.0),
      controller_state()
<A NAME="0"></A>  {
    n_joints = (2);
    joint_names.resize(n_joints);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match477-0.html#0',2,'match477-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    joint_names[0] = &quot;joint1&quot;;
    joint_names[1] = &quot;joint2&quot;;

    max_pos_err[0] = 0.0;
    max_pos_err[1] = 0.0;

    trajectory_msgs::JointTrajectoryPoint point;
    point.positions.resize(n_joints, 0.0);
    point.velocities.resize(n_joints, 0.0);
    point.accelerations.resize(n_joints, 0.0);

    // Home position just inside upper and lower wrapping angles
    point.positions[0] = M_PI - 0.1;
    point.positions[1] = -M_PI + 0.1;

    // Go home trajectory
    traj_home.joint_names = joint_names;
    traj_home.points.resize(1, point);
    traj_home.points[0].time_from_start = ros::Duration(1.0);

    // Trajectory to command joints outside of wrap range
    points.resize(3, point);
    points[0].positions[0] =  M_PI + 0.01;  // Just outside wrap
    points[0].positions[1] =  -M_PI - 0.01;    // Just outside wrap
    points[0].time_from_start = ros::Duration(1.0);</B></FONT>

    points[1].positions[0] =  M_PI + 0.06;
    points[1].positions[1] = -M_PI - 0.06;
    points[1].time_from_start = ros::Duration(2.0);

    points[2].positions[0] = M_PI + 0.1;
    points[2].positions[1] =  -M_PI - 0.01;
    points[2].time_from_start = ros::Duration(4.0);

    traj.joint_names = joint_names;
    traj.points = points;

    // Action goals
    traj_home_goal.trajectory = traj_home;
    traj_goal.trajectory      = traj;

    // Smoothing publisher (determines how well the robot follows a trajectory)
    smoothing_pub = ros::NodeHandle().advertise&lt;std_msgs::Float64&gt;(&quot;smoothing&quot;, 1);

    // Trajectory publisher
    traj_pub = nh.advertise&lt;trajectory_msgs::JointTrajectory&gt;(&quot;command&quot;, 1);

    // State subscriber
    state_sub = nh.subscribe&lt;control_msgs::JointTrajectoryControllerState&gt;(&quot;state&quot;,
                                                                           1,
                                                                           &amp;JointTrajectoryControllerTest::stateCB,
                                                                           this);

    // Query state service client
    query_state_service = nh.serviceClient&lt;control_msgs::QueryTrajectoryState&gt;(&quot;query_state&quot;);

    // Action client
    const std::string action_server_name = nh.getNamespace() + &quot;/follow_joint_trajectory&quot;;
    action_client.reset(new ActionClient(action_server_name));
    action_client2.reset(new ActionClient(action_server_name));
  }

  ~JointTrajectoryControllerTest()
  {
    state_sub.shutdown(); // This is important, to make sure that the callback is not woken up later in the destructor
  }

protected:
  typedef actionlib::SimpleActionClient&lt;control_msgs::FollowJointTrajectoryAction&gt; ActionClient;
  typedef std::shared_ptr&lt;ActionClient&gt; ActionClientPtr;
  typedef control_msgs::FollowJointTrajectoryGoal ActionGoal;
  typedef control_msgs::JointTrajectoryControllerStateConstPtr StateConstPtr;

  std::mutex mutex;
  ros::NodeHandle nh;

  unsigned int n_joints;
  std::vector&lt;std::string&gt; joint_names;
  std::vector&lt;trajectory_msgs::JointTrajectoryPoint&gt; points;

  trajectory_msgs::JointTrajectory traj_home;
  trajectory_msgs::JointTrajectory traj;
  ActionGoal                       traj_home_goal;
  ActionGoal                       traj_goal;

  ros::Duration short_timeout;
  ros::Duration long_timeout;

  ros::Publisher     smoothing_pub;
  ros::Publisher     traj_pub;
  ros::Subscriber    state_sub;
  ros::ServiceClient query_state_service;
  ActionClientPtr    action_client;
  ActionClientPtr    action_client2;


  StateConstPtr controller_state;
  double max_pos_err[2];

  void stateCB(const StateConstPtr&amp; state)
  {
    std::lock_guard&lt;std::mutex&gt; lock(mutex);
    controller_state = state;

    // Keep track of maximum position error commands
    if (state-&gt;joint_names.size() == 2 &amp;&amp; state-&gt;desired.velocities.size() == 2) {
        for (int i = 0; i &lt; 2; ++i) {
            if (fabs(max_pos_err[i]) &lt; fabs(state-&gt;error.positions[i])) {
                max_pos_err[i] = state-&gt;error.positions[i];
            }
        }
    }
  }

  StateConstPtr getState()
  {
    std::lock_guard&lt;std::mutex&gt; lock(mutex);
    return controller_state;
  }

  double getMaxPosErr(const int&amp; idx)
  {
      return max_pos_err[idx];
  }

  bool initState(const ros::Duration&amp; timeout = ros::Duration(5.0))
  {
    bool init_ok = false;
    ros::Time start_time = ros::Time::now();
    while (!init_ok &amp;&amp; (ros::Time::now() - start_time) &lt; timeout)
    {
      {
        std::lock_guard&lt;std::mutex&gt; lock(mutex);
        init_ok = controller_state &amp;&amp; !controller_state-&gt;joint_names.empty();
      }
      ros::Duration(0.1).sleep();
    }
    return init_ok;
  }

  static bool waitForState(const ActionClientPtr&amp; action_client,
                           const actionlib::SimpleClientGoalState&amp; state,
                           const ros::Duration&amp; timeout)
  {
    using ros::Time;
    using ros::Duration;

    Time start_time = Time::now();
    while (action_client-&gt;getState() != state &amp;&amp; ros::ok())
    {
      if (timeout &gt;= Duration(0.0) &amp;&amp; (Time::now() - start_time) &gt; timeout) { return false; } // Timed-out
      ros::Duration(0.01).sleep();
    }
    return true;
  }
};

TEST_F(JointTrajectoryControllerTest, jointWrapping)
{
  ASSERT_TRUE(initState());
  ASSERT_TRUE(action_client-&gt;waitForServer(long_timeout));

  // Go to home configuration, we need known initial conditions
  traj_home_goal.trajectory.header.stamp = ros::Time(0); // Start immediately
  action_client-&gt;sendGoal(traj_home_goal);
  ASSERT_TRUE(waitForState(action_client, SimpleClientGoalState::SUCCEEDED, long_timeout));

  // Make robot respond with a delay
  {
    std_msgs::Float64 smoothing;
    smoothing.data = 0.75;
    smoothing_pub.publish(smoothing);
    ros::Duration(0.5).sleep();
  }

  // Disable path constraints
  traj_goal.path_tolerance.resize(2);
  traj_goal.path_tolerance[0].name     = &quot;joint1&quot;;
  traj_goal.path_tolerance[0].position = -1.0;
  traj_goal.path_tolerance[0].velocity = -1.0;
  traj_goal.path_tolerance[1].name     = &quot;joint2&quot;;
  traj_goal.path_tolerance[1].position = -1.0;
  traj_goal.path_tolerance[1].velocity = -1.0;

  // Send trajectory (command joints outside of wrap range)
  traj_goal.trajectory.header.stamp = ros::Time(0); // Start immediately
  action_client-&gt;sendGoal(traj_goal);
  EXPECT_TRUE(waitForState(action_client, SimpleClientGoalState::ACTIVE, short_timeout));

  // Wait until done
  EXPECT_TRUE(waitForState(action_client, SimpleClientGoalState::SUCCEEDED, long_timeout));

  // Make sure max position error is small (which would be violated
  // when the position differences are not wrapped properly)
  EXPECT_TRUE(fabs(getMaxPosErr(0)) &lt; 0.7);
  EXPECT_TRUE(fabs(getMaxPosErr(1)) &lt; 0.7);

  // Restore perfect control
  {
    std_msgs::Float64 smoothing;
    smoothing.data = 0.0;
    smoothing_pub.publish(smoothing);
    ros::Duration(0.5).sleep();
  }
}

int main(int argc, char** argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  ros::init(argc, argv, &quot;joint_trajectory_controller_wrapping_test&quot;);

  ros::AsyncSpinner spinner(1);
  spinner.start();
  int ret = RUN_ALL_TESTS();
  spinner.stop();
  ros::shutdown();
  return ret;
}
</PRE>
</div>
  </div>
</body>
</html>
