<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tolerances_test.cpp &amp; joint_trajectory_controller_wrapping_test.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tolerances_test.cpp &amp; joint_trajectory_controller_wrapping_test.cpp
      </h3>
<h1 align="center">
        7.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tolerances_test.cpp (9.090909%)<th>joint_trajectory_controller_wrapping_test.cpp (6.5326633%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(223-237)<td><a href="#" name="0">(61-85)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tolerances_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;gtest/gtest.h&gt;
2 #include &lt;ros/ros.h&gt;
3 #include &lt;trajectory_interface/pos_vel_acc_state.h&gt;
4 #include &lt;joint_trajectory_controller/tolerances.h&gt;
5 using namespace joint_trajectory_controller;
6 typedef trajectory_interface::PosVelAccState&lt;double&gt; State;
7 typedef StateTolerances&lt;double&gt; StateTols;
8 TEST(TolerancesTest, CheckStateTolerance)
9 {
10   const double tol = 1.0;
11   State state_error_ok;
12   state_error_ok.position.resize(2, -tol);
13   state_error_ok.velocity.resize(2, -tol);
14   state_error_ok.acceleration.resize(2, -tol);
15   {
16     std::vector&lt;StateTols&gt; state_tols(2);
17     EXPECT_TRUE(checkStateTolerance(state_error_ok, state_tols));
18   }
19   {
20     State state_error = state_error_ok;
21     StateTols state_tol;
22     state_tol.position = tol;
23     std::vector&lt;StateTols&gt; state_tols(2, state_tol);
24     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
25     state_error.velocity.back() *= 2.0;
26     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
27     state_error.acceleration.back() *= 2.0;
28     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
29     state_error.position.back() *= 2.0;
30     EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
31   }
32   {
33     State state_error = state_error_ok;
34     StateTols state_tol;
35     state_tol.velocity = tol;
36     std::vector&lt;StateTols&gt; state_tols(2, state_tol);
37     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
38     state_error.position.back() *= 2.0;
39     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
40     state_error.acceleration.back() *= 2.0;
41     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
42     state_error.velocity.back() *= 2.0;
43     EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
44   }
45   {
46     State state_error = state_error_ok;
47     StateTols state_tol;
48     state_tol.acceleration = tol;
49     std::vector&lt;StateTols&gt; state_tols(2, state_tol);
50     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
51     state_error.position.back() *= 2.0;
52     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
53     state_error.velocity.back() *= 2.0;
54     EXPECT_TRUE(checkStateTolerance(state_error, state_tols));
55     state_error.acceleration.back() *= 2.0;
56     EXPECT_FALSE(checkStateTolerance(state_error, state_tols));
57   }
58 }
59 TEST(TolerancesTest, UpdateStateTolerances)
60 {
61   StateTols default_state_tols(1.0, 2.0, 3.0);
62   control_msgs::JointTolerance default_tol_msg;
63   default_tol_msg.name         = "foo_joint";
64   default_tol_msg.position     = 0.0;
65   default_tol_msg.velocity     = 0.0;
66   default_tol_msg.acceleration = 0.0;
67   {
68     StateTols state_tols = default_state_tols;
69     control_msgs::JointTolerance tol_msg = default_tol_msg;
70     updateStateTolerances(tol_msg, state_tols);
71     EXPECT_EQ(default_state_tols.position, state_tols.position);
72     EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
73     EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
74   }
75   {
76     StateTols state_tols = default_state_tols;
77     control_msgs::JointTolerance tol_msg = default_tol_msg;
78     tol_msg.position = -1.0;
79     updateStateTolerances(tol_msg, state_tols);
80     EXPECT_EQ(0.0,                             state_tols.position);
81     EXPECT_EQ(default_state_tols.velocity,     state_tols.velocity);
82     EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
83   }
84   {
85     StateTols state_tols = default_state_tols;
86     control_msgs::JointTolerance tol_msg = default_tol_msg;
87     tol_msg.velocity = -1.0;
88     updateStateTolerances(tol_msg, state_tols);
89     EXPECT_EQ(default_state_tols.position,     state_tols.position);
90     EXPECT_EQ(0.0,                             state_tols.velocity);
91     EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
92   }
93   {
94     StateTols state_tols = default_state_tols;
95     control_msgs::JointTolerance tol_msg = default_tol_msg;
96     tol_msg.acceleration = -1.0;
97     updateStateTolerances(tol_msg, state_tols);
98     EXPECT_EQ(default_state_tols.position, state_tols.position);
99     EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
100     EXPECT_EQ(0.0,                         state_tols.acceleration);
101   }
102   {
103     StateTols state_tols = default_state_tols;
104     control_msgs::JointTolerance tol_msg = default_tol_msg;
105     tol_msg.position = 0.5;
106     updateStateTolerances(tol_msg, state_tols);
107     EXPECT_EQ(tol_msg.position,                state_tols.position);
108     EXPECT_EQ(default_state_tols.velocity,     state_tols.velocity);
109     EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
110   }
111   {
112     StateTols state_tols = default_state_tols;
113     control_msgs::JointTolerance tol_msg = default_tol_msg;
114     tol_msg.velocity = 0.5;
115     updateStateTolerances(tol_msg, state_tols);
116     EXPECT_EQ(default_state_tols.position,     state_tols.position);
117     EXPECT_EQ(tol_msg.velocity,                state_tols.velocity);
118     EXPECT_EQ(default_state_tols.acceleration, state_tols.acceleration);
119   }
120   {
121     StateTols state_tols = default_state_tols;
122     control_msgs::JointTolerance tol_msg = default_tol_msg;
123     tol_msg.acceleration = 0.5;
124     updateStateTolerances(tol_msg, state_tols);
125     EXPECT_EQ(default_state_tols.position, state_tols.position);
126     EXPECT_EQ(default_state_tols.velocity, state_tols.velocity);
127     EXPECT_EQ(tol_msg.acceleration,        state_tols.acceleration);
128   }
129 }
130 TEST(TolerancesTest, UpdateSegmentTolerances)
131 {
132   std::vector&lt;std::string&gt; joint_names(2);
133   joint_names[0] = "foo_joint";
134   joint_names[1] = "bar_joint";
135   SegmentTolerances&lt;double&gt; ref_segment_tols(2);
136   ref_segment_tols.state_tolerance[0]      = StateTolerances&lt;double&gt;(1.0, 1.0, 1.0);
137   ref_segment_tols.state_tolerance[1]      = StateTolerances&lt;double&gt;(2.0, 2.0, 2.0);
138   ref_segment_tols.goal_state_tolerance[0] = StateTolerances&lt;double&gt;(3.0, 3.0, 3.0);
139   ref_segment_tols.goal_state_tolerance[1] = StateTolerances&lt;double&gt;(4.0, 4.0, 4.0);
140   ref_segment_tols.goal_time_tolerance     = 1.0;
141 <a name="0"></a>
142   control_msgs::JointTolerance invalid_tol_msg;
143 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  invalid_tol_msg.name         = "invalid_joint";
144   invalid_tol_msg.position     = -1.0;
145   invalid_tol_msg.velocity     = -1.0;
146   invalid_tol_msg.acceleration = -1.0;
147   control_msgs::JointTolerance state_tol_msg;
148   state_tol_msg.name         = joint_names[0];
149   state_tol_msg.position     =  0.5;
150   state_tol_msg.velocity     =  0.0;
151   state_tol_msg.acceleration = -1.0;
152   control_msgs::JointTolerance goal_state_tol_msg;
153   goal_state_tol_msg.name         = joint_names[1];
154   goal_state_tol_msg.position     =  0.25;
155   goal_state_tol_msg.velocity     =  0.0;</b></font>
156   goal_state_tol_msg.acceleration = -1.0;
157   control_msgs::FollowJointTrajectoryGoal goal;
158   goal.path_tolerance.push_back(invalid_tol_msg);   goal.path_tolerance.push_back(state_tol_msg);     goal.path_tolerance.push_back(invalid_tol_msg); 
159   goal.goal_tolerance.push_back(invalid_tol_msg);      goal.goal_tolerance.push_back(invalid_tol_msg);      goal.goal_tolerance.push_back(goal_state_tol_msg); 
160   goal.goal_time_tolerance = ros::Duration(0.0); 
161   SegmentTolerances&lt;double&gt; segment_tols = ref_segment_tols;
162   updateSegmentTolerances(goal, joint_names, segment_tols);
163   EXPECT_EQ(state_tol_msg.position,                       segment_tols.state_tolerance[0].position);       EXPECT_EQ(ref_segment_tols.state_tolerance[0].velocity, segment_tols.state_tolerance[0].velocity);       EXPECT_EQ(0.0,                                          segment_tols.state_tolerance[0].acceleration); 
164   EXPECT_EQ(ref_segment_tols.state_tolerance[1].position,     segment_tols.state_tolerance[1].position);       EXPECT_EQ(ref_segment_tols.state_tolerance[1].velocity,     segment_tols.state_tolerance[1].velocity);       EXPECT_EQ(ref_segment_tols.state_tolerance[1].acceleration, segment_tols.state_tolerance[1].acceleration); 
165   EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].position,     segment_tols.goal_state_tolerance[0].position);       EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].velocity,     segment_tols.goal_state_tolerance[0].velocity);       EXPECT_EQ(ref_segment_tols.goal_state_tolerance[0].acceleration, segment_tols.goal_state_tolerance[0].acceleration); 
166   EXPECT_EQ(goal_state_tol_msg.position,                       segment_tols.goal_state_tolerance[1].position);       EXPECT_EQ(ref_segment_tols.goal_state_tolerance[1].velocity, segment_tols.goal_state_tolerance[1].velocity);       EXPECT_EQ(0.0,                                               segment_tols.goal_state_tolerance[1].acceleration); 
167   EXPECT_EQ(ref_segment_tols.goal_time_tolerance, segment_tols.goal_time_tolerance); 
168   goal.goal_time_tolerance = ros::Duration(1.0);
169   updateSegmentTolerances(goal, joint_names, segment_tols);
170   EXPECT_EQ(goal.goal_time_tolerance.toSec(), segment_tols.goal_time_tolerance);     
171   goal.goal_time_tolerance = ros::Duration(-1.0);
172   updateSegmentTolerances(goal, joint_names, segment_tols);
173   EXPECT_EQ(0.0, segment_tols.goal_time_tolerance);                                  }
174 TEST(TolerancesTest, getSegmentTolerances)
175 {
176   ros::NodeHandle nh("test/constraints");
177   std::vector&lt;std::string&gt; joint_names(2);
178   joint_names[0] = "foo_joint";
179   joint_names[1] = "bar_joint";
180   SegmentTolerances&lt;double&gt; segment_tols = getSegmentTolerances&lt;double&gt;(nh, joint_names);
181   EXPECT_EQ(joint_names.size(), segment_tols.state_tolerance.size());
182   EXPECT_EQ(joint_names.size(), segment_tols.goal_state_tolerance.size());
183   EXPECT_EQ(0.05, segment_tols.state_tolerance[0].position);
184   EXPECT_EQ(0.0,  segment_tols.state_tolerance[0].velocity);
185   EXPECT_EQ(0.0,  segment_tols.state_tolerance[0].acceleration);
186   EXPECT_EQ(0.0, segment_tols.state_tolerance[1].position);
187   EXPECT_EQ(0.0, segment_tols.state_tolerance[1].velocity);
188   EXPECT_EQ(0.0, segment_tols.state_tolerance[1].acceleration);
189   EXPECT_EQ(0.03, segment_tols.goal_state_tolerance[0].position);
190   EXPECT_EQ(0.02, segment_tols.goal_state_tolerance[0].velocity);
191   EXPECT_EQ(0.0,  segment_tols.goal_state_tolerance[0].acceleration);
192   EXPECT_EQ(0.01, segment_tols.goal_state_tolerance[1].position);
193   EXPECT_EQ(0.02, segment_tols.goal_state_tolerance[1].velocity);
194   EXPECT_EQ(0.0,  segment_tols.goal_state_tolerance[1].acceleration);
195 }
196 int main(int argc, char** argv)
197 {
198   testing::InitGoogleTest(&amp;argc, argv);
199   ros::init(argc, argv, "tolerances_test");
200   return RUN_ALL_TESTS();
201 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>joint_trajectory_controller_wrapping_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;algorithm&gt;
2 #include &lt;cmath&gt;
3 #include &lt;memory&gt;
4 #include &lt;mutex&gt;
5 #include &lt;gtest/gtest.h&gt;
6 #include &lt;ros/ros.h&gt;
7 #include &lt;actionlib/client/simple_action_client.h&gt;
8 #include &lt;std_msgs/Float64.h&gt;
9 #include &lt;control_msgs/FollowJointTrajectoryAction.h&gt;
10 #include &lt;control_msgs/JointTrajectoryControllerState.h&gt;
11 #include &lt;control_msgs/QueryTrajectoryState.h&gt;
12 const double EPS = 0.01;
13 using actionlib::SimpleClientGoalState;
14 class JointTrajectoryControllerTest : public ::testing::Test
15 {
16 public:
17   JointTrajectoryControllerTest()
18     : nh("rrbot_wrapping_controller"),
19       short_timeout(1.0),
20       long_timeout(10.0),
21       controller_state()
22 <a name="0"></a>  {
23     n_joints = (2);
24     joint_names.resize(n_joints);
25 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    joint_names[0] = "joint1";
26     joint_names[1] = "joint2";
27     max_pos_err[0] = 0.0;
28     max_pos_err[1] = 0.0;
29     trajectory_msgs::JointTrajectoryPoint point;
30     point.positions.resize(n_joints, 0.0);
31     point.velocities.resize(n_joints, 0.0);
32     point.accelerations.resize(n_joints, 0.0);
33     point.positions[0] = M_PI - 0.1;
34     point.positions[1] = -M_PI + 0.1;
35     traj_home.joint_names = joint_names;
36     traj_home.points.resize(1, point);
37     traj_home.points[0].time_from_start = ros::Duration(1.0);
38     points.resize(3, point);
39     points[0].positions[0] =  M_PI + 0.01;      points[0].positions[1] =  -M_PI - 0.01;        points[0].time_from_start = ros::Duration(1.0);</b></font>
40     points[1].positions[0] =  M_PI + 0.06;
41     points[1].positions[1] = -M_PI - 0.06;
42     points[1].time_from_start = ros::Duration(2.0);
43     points[2].positions[0] = M_PI + 0.1;
44     points[2].positions[1] =  -M_PI - 0.01;
45     points[2].time_from_start = ros::Duration(4.0);
46     traj.joint_names = joint_names;
47     traj.points = points;
48     traj_home_goal.trajectory = traj_home;
49     traj_goal.trajectory      = traj;
50     smoothing_pub = ros::NodeHandle().advertise&lt;std_msgs::Float64&gt;("smoothing", 1);
51     traj_pub = nh.advertise&lt;trajectory_msgs::JointTrajectory&gt;("command", 1);
52     state_sub = nh.subscribe&lt;control_msgs::JointTrajectoryControllerState&gt;("state",
53                                                                            1,
54                                                                            &amp;JointTrajectoryControllerTest::stateCB,
55                                                                            this);
56     query_state_service = nh.serviceClient&lt;control_msgs::QueryTrajectoryState&gt;("query_state");
57     const std::string action_server_name = nh.getNamespace() + "/follow_joint_trajectory";
58     action_client.reset(new ActionClient(action_server_name));
59     action_client2.reset(new ActionClient(action_server_name));
60   }
61   ~JointTrajectoryControllerTest()
62   {
63     state_sub.shutdown();   }
64 protected:
65   typedef actionlib::SimpleActionClient&lt;control_msgs::FollowJointTrajectoryAction&gt; ActionClient;
66   typedef std::shared_ptr&lt;ActionClient&gt; ActionClientPtr;
67   typedef control_msgs::FollowJointTrajectoryGoal ActionGoal;
68   typedef control_msgs::JointTrajectoryControllerStateConstPtr StateConstPtr;
69   std::mutex mutex;
70   ros::NodeHandle nh;
71   unsigned int n_joints;
72   std::vector&lt;std::string&gt; joint_names;
73   std::vector&lt;trajectory_msgs::JointTrajectoryPoint&gt; points;
74   trajectory_msgs::JointTrajectory traj_home;
75   trajectory_msgs::JointTrajectory traj;
76   ActionGoal                       traj_home_goal;
77   ActionGoal                       traj_goal;
78   ros::Duration short_timeout;
79   ros::Duration long_timeout;
80   ros::Publisher     smoothing_pub;
81   ros::Publisher     traj_pub;
82   ros::Subscriber    state_sub;
83   ros::ServiceClient query_state_service;
84   ActionClientPtr    action_client;
85   ActionClientPtr    action_client2;
86   StateConstPtr controller_state;
87   double max_pos_err[2];
88   void stateCB(const StateConstPtr&amp; state)
89   {
90     std::lock_guard&lt;std::mutex&gt; lock(mutex);
91     controller_state = state;
92     if (state-&gt;joint_names.size() == 2 &amp;&amp; state-&gt;desired.velocities.size() == 2) {
93         for (int i = 0; i &lt; 2; ++i) {
94             if (fabs(max_pos_err[i]) &lt; fabs(state-&gt;error.positions[i])) {
95                 max_pos_err[i] = state-&gt;error.positions[i];
96             }
97         }
98     }
99   }
100   StateConstPtr getState()
101   {
102     std::lock_guard&lt;std::mutex&gt; lock(mutex);
103     return controller_state;
104   }
105   double getMaxPosErr(const int&amp; idx)
106   {
107       return max_pos_err[idx];
108   }
109   bool initState(const ros::Duration&amp; timeout = ros::Duration(5.0))
110   {
111     bool init_ok = false;
112     ros::Time start_time = ros::Time::now();
113     while (!init_ok &amp;&amp; (ros::Time::now() - start_time) &lt; timeout)
114     {
115       {
116         std::lock_guard&lt;std::mutex&gt; lock(mutex);
117         init_ok = controller_state &amp;&amp; !controller_state-&gt;joint_names.empty();
118       }
119       ros::Duration(0.1).sleep();
120     }
121     return init_ok;
122   }
123   static bool waitForState(const ActionClientPtr&amp; action_client,
124                            const actionlib::SimpleClientGoalState&amp; state,
125                            const ros::Duration&amp; timeout)
126   {
127     using ros::Time;
128     using ros::Duration;
129     Time start_time = Time::now();
130     while (action_client-&gt;getState() != state &amp;&amp; ros::ok())
131     {
132       if (timeout &gt;= Duration(0.0) &amp;&amp; (Time::now() - start_time) &gt; timeout) { return false; }       ros::Duration(0.01).sleep();
133     }
134     return true;
135   }
136 };
137 TEST_F(JointTrajectoryControllerTest, jointWrapping)
138 {
139   ASSERT_TRUE(initState());
140   ASSERT_TRUE(action_client-&gt;waitForServer(long_timeout));
141   traj_home_goal.trajectory.header.stamp = ros::Time(0);   action_client-&gt;sendGoal(traj_home_goal);
142   ASSERT_TRUE(waitForState(action_client, SimpleClientGoalState::SUCCEEDED, long_timeout));
143   {
144     std_msgs::Float64 smoothing;
145     smoothing.data = 0.75;
146     smoothing_pub.publish(smoothing);
147     ros::Duration(0.5).sleep();
148   }
149   traj_goal.path_tolerance.resize(2);
150   traj_goal.path_tolerance[0].name     = "joint1";
151   traj_goal.path_tolerance[0].position = -1.0;
152   traj_goal.path_tolerance[0].velocity = -1.0;
153   traj_goal.path_tolerance[1].name     = "joint2";
154   traj_goal.path_tolerance[1].position = -1.0;
155   traj_goal.path_tolerance[1].velocity = -1.0;
156   traj_goal.trajectory.header.stamp = ros::Time(0);   action_client-&gt;sendGoal(traj_goal);
157   EXPECT_TRUE(waitForState(action_client, SimpleClientGoalState::ACTIVE, short_timeout));
158   EXPECT_TRUE(waitForState(action_client, SimpleClientGoalState::SUCCEEDED, long_timeout));
159   EXPECT_TRUE(fabs(getMaxPosErr(0)) &lt; 0.7);
160   EXPECT_TRUE(fabs(getMaxPosErr(1)) &lt; 0.7);
161   {
162     std_msgs::Float64 smoothing;
163     smoothing.data = 0.0;
164     smoothing_pub.publish(smoothing);
165     ros::Duration(0.5).sleep();
166   }
167 }
168 int main(int argc, char** argv)
169 {
170   testing::InitGoogleTest(&amp;argc, argv);
171   ros::init(argc, argv, "joint_trajectory_controller_wrapping_test");
172   ros::AsyncSpinner spinner(1);
173   spinner.start();
174   int ret = RUN_ALL_TESTS();
175   spinner.stop();
176   ros::shutdown();
177   return ret;
178 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
