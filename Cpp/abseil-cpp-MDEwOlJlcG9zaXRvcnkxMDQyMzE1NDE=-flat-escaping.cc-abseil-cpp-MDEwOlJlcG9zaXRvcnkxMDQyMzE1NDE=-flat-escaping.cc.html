
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping.cc</h3>
            <pre><code>1  #include "absl/strings/escaping.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <cstdint>
5  #include <cstring>
6  #include <iterator>
7  #include <limits>
8  #include <string>
9  #include "absl/base/internal/endian.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/base/internal/unaligned_access.h"
12  #include "absl/strings/internal/char_map.h"
13  #include "absl/strings/internal/escaping.h"
14  #include "absl/strings/internal/resize_uninitialized.h"
15  #include "absl/strings/internal/utf8.h"
16  #include "absl/strings/str_cat.h"
17  #include "absl/strings/str_join.h"
18  #include "absl/strings/string_view.h"
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace {
22  constexpr bool kUnescapeNulls = false;
23  inline bool is_octal_digit(char c) { return ('0' <= c) && (c <= '7'); }
24  inline unsigned int hex_digit_to_int(char c) {
25    static_assert('0' == 0x30 && 'A' == 0x41 && 'a' == 0x61,
26                  "Character set must be ASCII.");
27    assert(absl::ascii_isxdigit(static_cast<unsigned char>(c)));
28    unsigned int x = static_cast<unsigned char>(c);
29    if (x > '9') {
30      x += 9;
31    }
32    return x & 0xf;
33  }
34  inline bool IsSurrogate(char32_t c, absl::string_view src, std::string* error) {
35    if (c >= 0xD800 && c <= 0xDFFF) {
36      if (error) {
37        *error = absl::StrCat("invalid surrogate character (0xD800-DFFF): \\",
38                              src);
39      }
40      return true;
41    }
42    return false;
43  }
44  bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
45                         char* dest, ptrdiff_t* dest_len, std::string* error) {
46    char* d = dest;
47    const char* p = source.data();
48    const char* end = p + source.size();
49    const char* last_byte = end - 1;
50    while (p == d && p < end && *p != '\\') p++, d++;
51    while (p < end) {
52      if (*p != '\\') {
53        *d++ = *p++;
54      } else {
55        if (++p > last_byte) {  
56          if (error) *error = "String cannot end with \\";
57          return false;
58        }
59        switch (*p) {
60          case 'a':  *d++ = '\a';  break;
61          case 'b':  *d++ = '\b';  break;
62          case 'f':  *d++ = '\f';  break;
63          case 'n':  *d++ = '\n';  break;
64          case 'r':  *d++ = '\r';  break;
65          case 't':  *d++ = '\t';  break;
66          case 'v':  *d++ = '\v';  break;
67          case '\\': *d++ = '\\';  break;
68          case '?':  *d++ = '\?';  break;    
69          case '\'': *d++ = '\'';  break;
70          case '"':  *d++ = '\"';  break;
71          case '0':
72          case '1':
73          case '2':
74          case '3':
75          case '4':
76          case '5':
77          case '6':
78          case '7': {
79            const char* octal_start = p;
80            unsigned int ch = static_cast<unsigned int>(*p - '0');  
81            if (p < last_byte && is_octal_digit(p[1]))
82              ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  
83            if (p < last_byte && is_octal_digit(p[1]))
84              ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  
85            if (ch > 0xff) {
86              if (error) {
87                *error = "Value of \\" +
88                         std::string(octal_start,
89                                     static_cast<size_t>(p + 1 - octal_start)) +
90                         " exceeds 0xff";
91              }
92              return false;
93            }
94            if ((ch == 0) && leave_nulls_escaped) {
95              const size_t octal_size = static_cast<size_t>(p + 1 - octal_start);
96              *d++ = '\\';
97              memmove(d, octal_start, octal_size);
98              d += octal_size;
99              break;
100            }
101            *d++ = static_cast<char>(ch);
102            break;
103          }
104          case 'x':
105          case 'X': {
106            if (p >= last_byte) {
107              if (error) *error = "String cannot end with \\x";
108              return false;
109            } else if (!absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
110              if (error) *error = "\\x cannot be followed by a non-hex digit";
111              return false;
112            }
113            unsigned int ch = 0;
114            const char* hex_start = p;
115            while (p < last_byte &&
116                   absl::ascii_isxdigit(static_cast<unsigned char>(p[1])))
117              ch = (ch << 4) + hex_digit_to_int(*++p);
118            if (ch > 0xFF) {
119              if (error) {
120                *error = "Value of \\" +
121                         std::string(hex_start,
122                                     static_cast<size_t>(p + 1 - hex_start)) +
123                         " exceeds 0xff";
124              }
125              return false;
126            }
127            if ((ch == 0) && leave_nulls_escaped) {
128              const size_t hex_size = static_cast<size_t>(p + 1 - hex_start);
129              *d++ = '\\';
130              memmove(d, hex_start, hex_size);
131              d += hex_size;
132              break;
133            }
134            *d++ = static_cast<char>(ch);
135            break;
136          }
137          case 'u': {
138            char32_t rune = 0;
139            const char* hex_start = p;
140            if (p + 4 >= end) {
141              if (error) {
142                *error = "\\u must be followed by 4 hex digits: \\" +
143                         std::string(hex_start,
144                                     static_cast<size_t>(p + 1 - hex_start));
145              }
146              return false;
147            }
148            for (int i = 0; i < 4; ++i) {
149              if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
150                rune = (rune << 4) + hex_digit_to_int(*++p);  
151              } else {
152                if (error) {
153                  *error = "\\u must be followed by 4 hex digits: \\" +
154                           std::string(hex_start,
155                                       static_cast<size_t>(p + 1 - hex_start));
156                }
157                return false;
158              }
159            }
160            if ((rune == 0) && leave_nulls_escaped) {
161              *d++ = '\\';
162              memmove(d, hex_start, 5);  
163              d += 5;
164              break;
165            }
166            if (IsSurrogate(rune, absl::string_view(hex_start, 5), error)) {
167              return false;
168            }
169            d += strings_internal::EncodeUTF8Char(d, rune);
170            break;
171          }
172          case 'U': {
173            char32_t rune = 0;
174            const char* hex_start = p;
175            if (p + 8 >= end) {
176              if (error) {
177                *error = "\\U must be followed by 8 hex digits: \\" +
178                         std::string(hex_start,
179                                     static_cast<size_t>(p + 1 - hex_start));
180              }
181              return false;
182            }
183            for (int i = 0; i < 8; ++i) {
184              if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
185                uint32_t newrune = (rune << 4) + hex_digit_to_int(*++p);
186                if (newrune > 0x10FFFF) {
187                  if (error) {
188                    *error = "Value of \\" +
189                             std::string(hex_start,
190                                         static_cast<size_t>(p + 1 - hex_start)) +
191                             " exceeds Unicode limit (0x10FFFF)";
192                  }
193                  return false;
194                } else {
195                  rune = newrune;
196                }
197              } else {
198                if (error) {
199                  *error = "\\U must be followed by 8 hex digits: \\" +
200                           std::string(hex_start,
201                                       static_cast<size_t>(p + 1 - hex_start));
202                }
203                return false;
204              }
205            }
206            if ((rune == 0) && leave_nulls_escaped) {
207              *d++ = '\\';
208              memmove(d, hex_start, 9);  
209              d += 9;
210              break;
211            }
212            if (IsSurrogate(rune, absl::string_view(hex_start, 9), error)) {
213              return false;
214            }
215            d += strings_internal::EncodeUTF8Char(d, rune);
216            break;
217          }
218          default: {
219            if (error) *error = std::string("Unknown escape sequence: \\") + *p;
220            return false;
221          }
222        }
223        p++;                                 
224      }
225    }
226    *dest_len = d - dest;
227    return true;
228  }
229  bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
230                         std::string* dest, std::string* error) {
231    strings_internal::STLStringResizeUninitialized(dest, source.size());
232    ptrdiff_t dest_size;
233    if (!CUnescapeInternal(source,
234                           leave_nulls_escaped,
235                           &(*dest)[0],
236                           &dest_size,
237                           error)) {
238      return false;
239    }
240    dest->erase(static_cast<size_t>(dest_size));
241    return true;
242  }
243  std::string CEscapeInternal(absl::string_view src, bool use_hex,
244                              bool utf8_safe) {
245    std::string dest;
246    bool last_hex_escape = false;  
247    for (char c : src) {
248      bool is_hex_escape = false;
249      switch (c) {
250        case '\n': dest.append("\\" "n"); break;
251        case '\r': dest.append("\\" "r"); break;
252        case '\t': dest.append("\\" "t"); break;
253        case '\"': dest.append("\\" "\""); break;
254        case '\'': dest.append("\\" "'"); break;
255        case '\\': dest.append("\\" "\\"); break;
256        default: {
257          const unsigned char uc = static_cast<unsigned char>(c);
258          if ((!utf8_safe || uc < 0x80) &&
259              (!absl::ascii_isprint(uc) ||
260               (last_hex_escape && absl::ascii_isxdigit(uc)))) {
261            if (use_hex) {
262              dest.append("\\" "x");
263              dest.push_back(numbers_internal::kHexChar[uc / 16]);
264              dest.push_back(numbers_internal::kHexChar[uc % 16]);
265              is_hex_escape = true;
266            } else {
267              dest.append("\\");
268              dest.push_back(numbers_internal::kHexChar[uc / 64]);
269              dest.push_back(numbers_internal::kHexChar[(uc % 64) / 8]);
270              dest.push_back(numbers_internal::kHexChar[uc % 8]);
271            }
272          } else {
273            dest.push_back(c);
274            break;
275          }
276        }
277      }
278      last_hex_escape = is_hex_escape;
279    }
280    return dest;
281  }
282  constexpr unsigned char c_escaped_len[256] = {
283      4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 2, 4, 4,  
284      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
285      1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  
286      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
287      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
288      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  
289      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
290      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4,  
291      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
292      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
293      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
294      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
295      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
296      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
297      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
298      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
299  };
300  inline size_t CEscapedLength(absl::string_view src) {
301    size_t escaped_len = 0;
302    for (char c : src)
303      escaped_len += c_escaped_len[static_cast<unsigned char>(c)];
304    return escaped_len;
305  }
306  void CEscapeAndAppendInternal(absl::string_view src, std::string* dest) {
307    size_t escaped_len = CEscapedLength(src);
308    if (escaped_len == src.size()) {
309      dest->append(src.data(), src.size());
310      return;
311    }
312    size_t cur_dest_len = dest->size();
313    strings_internal::STLStringResizeUninitialized(dest,
314                                                   cur_dest_len + escaped_len);
315    char* append_ptr = &(*dest)[cur_dest_len];
316    for (char c : src) {
317      size_t char_len = c_escaped_len[static_cast<unsigned char>(c)];
318      if (char_len == 1) {
319        *append_ptr++ = c;
320      } else if (char_len == 2) {
321        switch (c) {
322          case '\n':
323            *append_ptr++ = '\\';
324            *append_ptr++ = 'n';
325            break;
326          case '\r':
327            *append_ptr++ = '\\';
328            *append_ptr++ = 'r';
329            break;
330          case '\t':
331            *append_ptr++ = '\\';
332            *append_ptr++ = 't';
333            break;
334          case '\"':
335            *append_ptr++ = '\\';
336            *append_ptr++ = '\"';
337            break;
338          case '\'':
339            *append_ptr++ = '\\';
340            *append_ptr++ = '\'';
341            break;
342          case '\\':
343            *append_ptr++ = '\\';
344            *append_ptr++ = '\\';
345            break;
346        }
347      } else {
348        *append_ptr++ = '\\';
349        *append_ptr++ = '0' + static_cast<unsigned char>(c) / 64;
350        *append_ptr++ = '0' + (static_cast<unsigned char>(c) % 64) / 8;
351        *append_ptr++ = '0' + static_cast<unsigned char>(c) % 8;
352      }
353    }
354  }
355  bool Base64UnescapeInternal(const char* src_param, size_t szsrc, char* dest,
356                              size_t szdest, const signed char* unbase64,
357                              size_t* len) {
358    static const char kPad64Equals = '=';
359    static const char kPad64Dot = '.';
360    size_t destidx = 0;
361    int decode = 0;
362    int state = 0;
363    unsigned char ch = 0;
364    unsigned int temp = 0;
365    const unsigned char* src = reinterpret_cast<const unsigned char*>(src_param);
366  #define GET_INPUT(label, remain)                                \
367    label:                                                        \
368    --szsrc;                                                      \
369    ch = *src++;                                                  \
370    decode = unbase64[ch];                                        \
371    if (decode < 0) {                                             \
372      if (absl::ascii_isspace(ch) && szsrc >= remain) goto label; \
373      state = 4 - remain;                                         \
374      break;                                                      \
375    }
376    if (dest) {
377      while (szsrc >= 4) {
378        if (!src[0] || !src[1] || !src[2] ||
379            ((temp = ((unsigned(unbase64[src[0]]) << 18) |
380                      (unsigned(unbase64[src[1]]) << 12) |
381                      (unsigned(unbase64[src[2]]) << 6) |
382                      (unsigned(unbase64[src[3]])))) &
383             0x80000000)) {
384          GET_INPUT(first, 4);
385          temp = static_cast<unsigned char>(decode);
386          GET_INPUT(second, 3);
387          temp = (temp << 6) | static_cast<unsigned char>(decode);
388          GET_INPUT(third, 2);
389          temp = (temp << 6) | static_cast<unsigned char>(decode);
390          GET_INPUT(fourth, 1);
391          temp = (temp << 6) | static_cast<unsigned char>(decode);
392        } else {
393          szsrc -= 4;
394          src += 4;
395        }
396        if (destidx + 3 > szdest) return false;
397        dest[destidx + 2] = static_cast<char>(temp);
<span onclick='openModal()' class='match'>398        temp >>= 8;
399        dest[destidx + 1] = static_cast<char>(temp);
400        temp >>= 8;
401        dest[destidx] = static_cast<char>(temp);
402        destidx += 3;
</span>403      }
404    } else {
405      while (szsrc >= 4) {
406        if (!src[0] || !src[1] || !src[2] ||
407            ((temp = ((unsigned(unbase64[src[0]]) << 18) |
408                      (unsigned(unbase64[src[1]]) << 12) |
409                      (unsigned(unbase64[src[2]]) << 6) |
410                      (unsigned(unbase64[src[3]])))) &
411             0x80000000)) {
412          GET_INPUT(first_no_dest, 4);
413          GET_INPUT(second_no_dest, 3);
414          GET_INPUT(third_no_dest, 2);
415          GET_INPUT(fourth_no_dest, 1);
416        } else {
417          szsrc -= 4;
418          src += 4;
419        }
420        destidx += 3;
421      }
422    }
423  #undef GET_INPUT
424    if (decode < 0 && ch != kPad64Equals && ch != kPad64Dot &&
425        !absl::ascii_isspace(ch))
426      return false;
427    if (ch == kPad64Equals || ch == kPad64Dot) {
428      ++szsrc;
429      --src;
430    } else {
431      while (szsrc > 0) {
432        --szsrc;
433        ch = *src++;
434        decode = unbase64[ch];
435        if (decode < 0) {
436          if (absl::ascii_isspace(ch)) {
437            continue;
438          } else if (ch == kPad64Equals || ch == kPad64Dot) {
439            ++szsrc;
440            --src;
441            break;
442          } else {
443            return false;
444          }
445        }
446        temp = (temp << 6) | static_cast<unsigned char>(decode);
447        ++state;
448        if (state == 4) {
449          if (dest) {
450            if (destidx + 3 > szdest) return false;
451            dest[destidx + 2] = static_cast<char>(temp);
452            temp >>= 8;
453            dest[destidx + 1] = static_cast<char>(temp);
454            temp >>= 8;
455            dest[destidx] = static_cast<char>(temp);
456          }
457          destidx += 3;
458          state = 0;
459          temp = 0;
460        }
461      }
462    }
463    int expected_equals = 0;
464    switch (state) {
465      case 0:
466        break;
467      case 1:
468        return false;
469      case 2:
470        if (dest) {
471          if (destidx + 1 > szdest) return false;
472          temp >>= 4;
473          dest[destidx] = static_cast<char>(temp);
474        }
475        ++destidx;
476        expected_equals = 2;
477        break;
478      case 3:
479        if (dest) {
480          if (destidx + 2 > szdest) return false;
481          temp >>= 2;
482          dest[destidx + 1] = static_cast<char>(temp);
483          temp >>= 8;
484          dest[destidx] = static_cast<char>(temp);
485        }
486        destidx += 2;
487        expected_equals = 1;
488        break;
489      default:
490        ABSL_RAW_LOG(FATAL, "This can't happen; base64 decoder state = %d",
491                     state);
492    }
493    int equals = 0;
494    while (szsrc > 0) {
495      if (*src == kPad64Equals || *src == kPad64Dot)
496        ++equals;
497      else if (!absl::ascii_isspace(*src))
498        return false;
499      --szsrc;
500      ++src;
501    }
502    const bool ok = (equals == 0 || equals == expected_equals);
503    if (ok) *len = destidx;
504    return ok;
505  }
506  constexpr signed char kUnBase64[] = {
507      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
508      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
509      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
510      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
511      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
512      -1,      -1,      -1,      62&bsol;*+*/, -1,      -1,      -1,      63&bsol;*/ */,
513      52&bsol;*0*/, 53&bsol;*1*/, 54&bsol;*2*/, 55&bsol;*3*/, 56&bsol;*4*/, 57&bsol;*5*/, 58&bsol;*6*/, 59&bsol;*7*/,
514      60&bsol;*8*/, 61&bsol;*9*/, -1,      -1,      -1,      -1,      -1,      -1,
515      -1,       0&bsol;*A*/,  1&bsol;*B*/,  2&bsol;*C*/,  3&bsol;*D*/,  4&bsol;*E*/,  5&bsol;*F*/,  6&bsol;*G*/,
516      07&bsol;*H*/,  8&bsol;*I*/,  9&bsol;*J*/, 10&bsol;*K*/, 11&bsol;*L*/, 12&bsol;*M*/, 13&bsol;*N*/, 14&bsol;*O*/,
517      15&bsol;*P*/, 16&bsol;*Q*/, 17&bsol;*R*/, 18&bsol;*S*/, 19&bsol;*T*/, 20&bsol;*U*/, 21&bsol;*V*/, 22&bsol;*W*/,
518      23&bsol;*X*/, 24&bsol;*Y*/, 25&bsol;*Z*/, -1,      -1,      -1,      -1,      -1,
519      -1,      26&bsol;*a*/, 27&bsol;*b*/, 28&bsol;*c*/, 29&bsol;*d*/, 30&bsol;*e*/, 31&bsol;*f*/, 32&bsol;*g*/,
520      33&bsol;*h*/, 34&bsol;*i*/, 35&bsol;*j*/, 36&bsol;*k*/, 37&bsol;*l*/, 38&bsol;*m*/, 39&bsol;*n*/, 40&bsol;*o*/,
521      41&bsol;*p*/, 42&bsol;*q*/, 43&bsol;*r*/, 44&bsol;*s*/, 45&bsol;*t*/, 46&bsol;*u*/, 47&bsol;*v*/, 48&bsol;*w*/,
522      49&bsol;*x*/, 50&bsol;*y*/, 51&bsol;*z*/, -1,      -1,      -1,      -1,      -1,
523      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
524      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
525      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
526      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
527      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
528      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
529      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
530      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
531      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
532      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
533      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
534      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
535      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
536      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
537      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
538      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
539  };
540  constexpr signed char kUnWebSafeBase64[] = {
541      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
542      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
543      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
544      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
545      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
546      -1,      -1,      -1,      -1,      -1,      62&bsol;*-*/, -1,      -1,
547      52&bsol;*0*/, 53&bsol;*1*/, 54&bsol;*2*/, 55&bsol;*3*/, 56&bsol;*4*/, 57&bsol;*5*/, 58&bsol;*6*/, 59&bsol;*7*/,
548      60&bsol;*8*/, 61&bsol;*9*/, -1,      -1,      -1,      -1,      -1,      -1,
549      -1,       0&bsol;*A*/,  1&bsol;*B*/,  2&bsol;*C*/,  3&bsol;*D*/,  4&bsol;*E*/,  5&bsol;*F*/,  6&bsol;*G*/,
550      07&bsol;*H*/,  8&bsol;*I*/,  9&bsol;*J*/, 10&bsol;*K*/, 11&bsol;*L*/, 12&bsol;*M*/, 13&bsol;*N*/, 14&bsol;*O*/,
551      15&bsol;*P*/, 16&bsol;*Q*/, 17&bsol;*R*/, 18&bsol;*S*/, 19&bsol;*T*/, 20&bsol;*U*/, 21&bsol;*V*/, 22&bsol;*W*/,
552      23&bsol;*X*/, 24&bsol;*Y*/, 25&bsol;*Z*/, -1,      -1,      -1,      -1,      63&bsol;*_*/,
553      -1,      26&bsol;*a*/, 27&bsol;*b*/, 28&bsol;*c*/, 29&bsol;*d*/, 30&bsol;*e*/, 31&bsol;*f*/, 32&bsol;*g*/,
554      33&bsol;*h*/, 34&bsol;*i*/, 35&bsol;*j*/, 36&bsol;*k*/, 37&bsol;*l*/, 38&bsol;*m*/, 39&bsol;*n*/, 40&bsol;*o*/,
555      41&bsol;*p*/, 42&bsol;*q*/, 43&bsol;*r*/, 44&bsol;*s*/, 45&bsol;*t*/, 46&bsol;*u*/, 47&bsol;*v*/, 48&bsol;*w*/,
556      49&bsol;*x*/, 50&bsol;*y*/, 51&bsol;*z*/, -1,      -1,      -1,      -1,      -1,
557      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
558      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
559      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
560      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
561      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
562      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
563      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
564      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
565      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
566      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
567      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
568      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
569      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
570      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
571      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
572      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
573  };
574  template <typename String>
575  bool Base64UnescapeInternal(const char* src, size_t slen, String* dest,
576                              const signed char* unbase64) {
577    const size_t dest_len = 3 * (slen / 4) + (slen % 4);
578    strings_internal::STLStringResizeUninitialized(dest, dest_len);
579    size_t len;
580    const bool ok =
581        Base64UnescapeInternal(src, slen, &(*dest)[0], dest_len, unbase64, &len);
582    if (!ok) {
583      dest->clear();
584      return false;
585    }
586    assert(len <= dest_len);
587    dest->erase(len);
588    return true;
589  }
590  constexpr char kHexValueLenient[256] = {
591      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
592      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
593      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
594      0,  1,  2,  3,  4,  5,  6, 7, 8, 9, 0, 0, 0, 0, 0, 0,  
595      0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
596      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
597      0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
598      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
599      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
600      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
601      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
602      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
603      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
604      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
605      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
606      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
607  };
608  template <typename T>
609  void HexStringToBytesInternal(const char* from, T to, size_t num) {
610    for (size_t i = 0; i < num; i++) {
611      to[i] = static_cast<char>(kHexValueLenient[from[i * 2] & 0xFF] << 4) +
612              (kHexValueLenient[from[i * 2 + 1] & 0xFF]);
613    }
614  }
615  template <typename T>
616  void BytesToHexStringInternal(const unsigned char* src, T dest, size_t num) {
617    auto dest_ptr = &dest[0];
618    for (auto src_ptr = src; src_ptr != (src + num); ++src_ptr, dest_ptr += 2) {
619      const char* hex_p = &numbers_internal::kHexTable[*src_ptr * 2];
620      std::copy(hex_p, hex_p + 2, dest_ptr);
621    }
622  }
623  }  
624  bool CUnescape(absl::string_view source, std::string* dest,
625                 std::string* error) {
626    return CUnescapeInternal(source, kUnescapeNulls, dest, error);
627  }
628  std::string CEscape(absl::string_view src) {
629    std::string dest;
630    CEscapeAndAppendInternal(src, &dest);
631    return dest;
632  }
633  std::string CHexEscape(absl::string_view src) {
634    return CEscapeInternal(src, true, false);
635  }
636  std::string Utf8SafeCEscape(absl::string_view src) {
637    return CEscapeInternal(src, false, true);
638  }
639  std::string Utf8SafeCHexEscape(absl::string_view src) {
640    return CEscapeInternal(src, true, true);
641  }
642  bool Base64Unescape(absl::string_view src, std::string* dest) {
643    return Base64UnescapeInternal(src.data(), src.size(), dest, kUnBase64);
644  }
645  bool WebSafeBase64Unescape(absl::string_view src, std::string* dest) {
646    return Base64UnescapeInternal(src.data(), src.size(), dest, kUnWebSafeBase64);
647  }
648  void Base64Escape(absl::string_view src, std::string* dest) {
649    strings_internal::Base64EscapeInternal(
650        reinterpret_cast<const unsigned char*>(src.data()), src.size(), dest,
651        true, strings_internal::kBase64Chars);
652  }
653  void WebSafeBase64Escape(absl::string_view src, std::string* dest) {
654    strings_internal::Base64EscapeInternal(
655        reinterpret_cast<const unsigned char*>(src.data()), src.size(), dest,
656        false, strings_internal::kWebSafeBase64Chars);
657  }
658  std::string Base64Escape(absl::string_view src) {
659    std::string dest;
660    strings_internal::Base64EscapeInternal(
661        reinterpret_cast<const unsigned char*>(src.data()), src.size(), &dest,
662        true, strings_internal::kBase64Chars);
663    return dest;
664  }
665  std::string WebSafeBase64Escape(absl::string_view src) {
666    std::string dest;
667    strings_internal::Base64EscapeInternal(
668        reinterpret_cast<const unsigned char*>(src.data()), src.size(), &dest,
669        false, strings_internal::kWebSafeBase64Chars);
670    return dest;
671  }
672  std::string HexStringToBytes(absl::string_view from) {
673    std::string result;
674    const auto num = from.size() / 2;
675    strings_internal::STLStringResizeUninitialized(&result, num);
676    absl::HexStringToBytesInternal<std::string&>(from.data(), result, num);
677    return result;
678  }
679  std::string BytesToHexString(absl::string_view from) {
680    std::string result;
681    strings_internal::STLStringResizeUninitialized(&result, 2 * from.size());
682    absl::BytesToHexStringInternal<std::string&>(
683        reinterpret_cast<const unsigned char*>(from.data()), result, from.size());
684    return result;
685  }
686  ABSL_NAMESPACE_END
687  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping.cc</h3>
            <pre><code>1  #include "absl/strings/escaping.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <cstdint>
5  #include <cstring>
6  #include <iterator>
7  #include <limits>
8  #include <string>
9  #include "absl/base/internal/endian.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/base/internal/unaligned_access.h"
12  #include "absl/strings/internal/char_map.h"
13  #include "absl/strings/internal/escaping.h"
14  #include "absl/strings/internal/resize_uninitialized.h"
15  #include "absl/strings/internal/utf8.h"
16  #include "absl/strings/str_cat.h"
17  #include "absl/strings/str_join.h"
18  #include "absl/strings/string_view.h"
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace {
22  constexpr bool kUnescapeNulls = false;
23  inline bool is_octal_digit(char c) { return ('0' <= c) && (c <= '7'); }
24  inline unsigned int hex_digit_to_int(char c) {
25    static_assert('0' == 0x30 && 'A' == 0x41 && 'a' == 0x61,
26                  "Character set must be ASCII.");
27    assert(absl::ascii_isxdigit(static_cast<unsigned char>(c)));
28    unsigned int x = static_cast<unsigned char>(c);
29    if (x > '9') {
30      x += 9;
31    }
32    return x & 0xf;
33  }
34  inline bool IsSurrogate(char32_t c, absl::string_view src, std::string* error) {
35    if (c >= 0xD800 && c <= 0xDFFF) {
36      if (error) {
37        *error = absl::StrCat("invalid surrogate character (0xD800-DFFF): \\",
38                              src);
39      }
40      return true;
41    }
42    return false;
43  }
44  bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
45                         char* dest, ptrdiff_t* dest_len, std::string* error) {
46    char* d = dest;
47    const char* p = source.data();
48    const char* end = p + source.size();
49    const char* last_byte = end - 1;
50    while (p == d && p < end && *p != '\\') p++, d++;
51    while (p < end) {
52      if (*p != '\\') {
53        *d++ = *p++;
54      } else {
55        if (++p > last_byte) {  
56          if (error) *error = "String cannot end with \\";
57          return false;
58        }
59        switch (*p) {
60          case 'a':  *d++ = '\a';  break;
61          case 'b':  *d++ = '\b';  break;
62          case 'f':  *d++ = '\f';  break;
63          case 'n':  *d++ = '\n';  break;
64          case 'r':  *d++ = '\r';  break;
65          case 't':  *d++ = '\t';  break;
66          case 'v':  *d++ = '\v';  break;
67          case '\\': *d++ = '\\';  break;
68          case '?':  *d++ = '\?';  break;    
69          case '\'': *d++ = '\'';  break;
70          case '"':  *d++ = '\"';  break;
71          case '0':
72          case '1':
73          case '2':
74          case '3':
75          case '4':
76          case '5':
77          case '6':
78          case '7': {
79            const char* octal_start = p;
80            unsigned int ch = static_cast<unsigned int>(*p - '0');  
81            if (p < last_byte && is_octal_digit(p[1]))
82              ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  
83            if (p < last_byte && is_octal_digit(p[1]))
84              ch = ch * 8 + static_cast<unsigned int>(*++p - '0');  
85            if (ch > 0xff) {
86              if (error) {
87                *error = "Value of \\" +
88                         std::string(octal_start,
89                                     static_cast<size_t>(p + 1 - octal_start)) +
90                         " exceeds 0xff";
91              }
92              return false;
93            }
94            if ((ch == 0) && leave_nulls_escaped) {
95              const size_t octal_size = static_cast<size_t>(p + 1 - octal_start);
96              *d++ = '\\';
97              memmove(d, octal_start, octal_size);
98              d += octal_size;
99              break;
100            }
101            *d++ = static_cast<char>(ch);
102            break;
103          }
104          case 'x':
105          case 'X': {
106            if (p >= last_byte) {
107              if (error) *error = "String cannot end with \\x";
108              return false;
109            } else if (!absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
110              if (error) *error = "\\x cannot be followed by a non-hex digit";
111              return false;
112            }
113            unsigned int ch = 0;
114            const char* hex_start = p;
115            while (p < last_byte &&
116                   absl::ascii_isxdigit(static_cast<unsigned char>(p[1])))
117              ch = (ch << 4) + hex_digit_to_int(*++p);
118            if (ch > 0xFF) {
119              if (error) {
120                *error = "Value of \\" +
121                         std::string(hex_start,
122                                     static_cast<size_t>(p + 1 - hex_start)) +
123                         " exceeds 0xff";
124              }
125              return false;
126            }
127            if ((ch == 0) && leave_nulls_escaped) {
128              const size_t hex_size = static_cast<size_t>(p + 1 - hex_start);
129              *d++ = '\\';
130              memmove(d, hex_start, hex_size);
131              d += hex_size;
132              break;
133            }
134            *d++ = static_cast<char>(ch);
135            break;
136          }
137          case 'u': {
138            char32_t rune = 0;
139            const char* hex_start = p;
140            if (p + 4 >= end) {
141              if (error) {
142                *error = "\\u must be followed by 4 hex digits: \\" +
143                         std::string(hex_start,
144                                     static_cast<size_t>(p + 1 - hex_start));
145              }
146              return false;
147            }
148            for (int i = 0; i < 4; ++i) {
149              if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
150                rune = (rune << 4) + hex_digit_to_int(*++p);  
151              } else {
152                if (error) {
153                  *error = "\\u must be followed by 4 hex digits: \\" +
154                           std::string(hex_start,
155                                       static_cast<size_t>(p + 1 - hex_start));
156                }
157                return false;
158              }
159            }
160            if ((rune == 0) && leave_nulls_escaped) {
161              *d++ = '\\';
162              memmove(d, hex_start, 5);  
163              d += 5;
164              break;
165            }
166            if (IsSurrogate(rune, absl::string_view(hex_start, 5), error)) {
167              return false;
168            }
169            d += strings_internal::EncodeUTF8Char(d, rune);
170            break;
171          }
172          case 'U': {
173            char32_t rune = 0;
174            const char* hex_start = p;
175            if (p + 8 >= end) {
176              if (error) {
177                *error = "\\U must be followed by 8 hex digits: \\" +
178                         std::string(hex_start,
179                                     static_cast<size_t>(p + 1 - hex_start));
180              }
181              return false;
182            }
183            for (int i = 0; i < 8; ++i) {
184              if (absl::ascii_isxdigit(static_cast<unsigned char>(p[1]))) {
185                uint32_t newrune = (rune << 4) + hex_digit_to_int(*++p);
186                if (newrune > 0x10FFFF) {
187                  if (error) {
188                    *error = "Value of \\" +
189                             std::string(hex_start,
190                                         static_cast<size_t>(p + 1 - hex_start)) +
191                             " exceeds Unicode limit (0x10FFFF)";
192                  }
193                  return false;
194                } else {
195                  rune = newrune;
196                }
197              } else {
198                if (error) {
199                  *error = "\\U must be followed by 8 hex digits: \\" +
200                           std::string(hex_start,
201                                       static_cast<size_t>(p + 1 - hex_start));
202                }
203                return false;
204              }
205            }
206            if ((rune == 0) && leave_nulls_escaped) {
207              *d++ = '\\';
208              memmove(d, hex_start, 9);  
209              d += 9;
210              break;
211            }
212            if (IsSurrogate(rune, absl::string_view(hex_start, 9), error)) {
213              return false;
214            }
215            d += strings_internal::EncodeUTF8Char(d, rune);
216            break;
217          }
218          default: {
219            if (error) *error = std::string("Unknown escape sequence: \\") + *p;
220            return false;
221          }
222        }
223        p++;                                 
224      }
225    }
226    *dest_len = d - dest;
227    return true;
228  }
229  bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
230                         std::string* dest, std::string* error) {
231    strings_internal::STLStringResizeUninitialized(dest, source.size());
232    ptrdiff_t dest_size;
233    if (!CUnescapeInternal(source,
234                           leave_nulls_escaped,
235                           &(*dest)[0],
236                           &dest_size,
237                           error)) {
238      return false;
239    }
240    dest->erase(static_cast<size_t>(dest_size));
241    return true;
242  }
243  std::string CEscapeInternal(absl::string_view src, bool use_hex,
244                              bool utf8_safe) {
245    std::string dest;
246    bool last_hex_escape = false;  
247    for (char c : src) {
248      bool is_hex_escape = false;
249      switch (c) {
250        case '\n': dest.append("\\" "n"); break;
251        case '\r': dest.append("\\" "r"); break;
252        case '\t': dest.append("\\" "t"); break;
253        case '\"': dest.append("\\" "\""); break;
254        case '\'': dest.append("\\" "'"); break;
255        case '\\': dest.append("\\" "\\"); break;
256        default: {
257          const unsigned char uc = static_cast<unsigned char>(c);
258          if ((!utf8_safe || uc < 0x80) &&
259              (!absl::ascii_isprint(uc) ||
260               (last_hex_escape && absl::ascii_isxdigit(uc)))) {
261            if (use_hex) {
262              dest.append("\\" "x");
263              dest.push_back(numbers_internal::kHexChar[uc / 16]);
264              dest.push_back(numbers_internal::kHexChar[uc % 16]);
265              is_hex_escape = true;
266            } else {
267              dest.append("\\");
268              dest.push_back(numbers_internal::kHexChar[uc / 64]);
269              dest.push_back(numbers_internal::kHexChar[(uc % 64) / 8]);
270              dest.push_back(numbers_internal::kHexChar[uc % 8]);
271            }
272          } else {
273            dest.push_back(c);
274            break;
275          }
276        }
277      }
278      last_hex_escape = is_hex_escape;
279    }
280    return dest;
281  }
282  constexpr unsigned char c_escaped_len[256] = {
283      4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 2, 4, 4,  
284      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
285      1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  
286      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
287      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
288      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  
289      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  
290      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4,  
291      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
292      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
293      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
294      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
295      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
296      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
297      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
298      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
299  };
300  inline size_t CEscapedLength(absl::string_view src) {
301    size_t escaped_len = 0;
302    for (char c : src)
303      escaped_len += c_escaped_len[static_cast<unsigned char>(c)];
304    return escaped_len;
305  }
306  void CEscapeAndAppendInternal(absl::string_view src, std::string* dest) {
307    size_t escaped_len = CEscapedLength(src);
308    if (escaped_len == src.size()) {
309      dest->append(src.data(), src.size());
310      return;
311    }
312    size_t cur_dest_len = dest->size();
313    strings_internal::STLStringResizeUninitialized(dest,
314                                                   cur_dest_len + escaped_len);
315    char* append_ptr = &(*dest)[cur_dest_len];
316    for (char c : src) {
317      size_t char_len = c_escaped_len[static_cast<unsigned char>(c)];
318      if (char_len == 1) {
319        *append_ptr++ = c;
320      } else if (char_len == 2) {
321        switch (c) {
322          case '\n':
323            *append_ptr++ = '\\';
324            *append_ptr++ = 'n';
325            break;
326          case '\r':
327            *append_ptr++ = '\\';
328            *append_ptr++ = 'r';
329            break;
330          case '\t':
331            *append_ptr++ = '\\';
332            *append_ptr++ = 't';
333            break;
334          case '\"':
335            *append_ptr++ = '\\';
336            *append_ptr++ = '\"';
337            break;
338          case '\'':
339            *append_ptr++ = '\\';
340            *append_ptr++ = '\'';
341            break;
342          case '\\':
343            *append_ptr++ = '\\';
344            *append_ptr++ = '\\';
345            break;
346        }
347      } else {
348        *append_ptr++ = '\\';
349        *append_ptr++ = '0' + static_cast<unsigned char>(c) / 64;
350        *append_ptr++ = '0' + (static_cast<unsigned char>(c) % 64) / 8;
351        *append_ptr++ = '0' + static_cast<unsigned char>(c) % 8;
352      }
353    }
354  }
355  bool Base64UnescapeInternal(const char* src_param, size_t szsrc, char* dest,
356                              size_t szdest, const signed char* unbase64,
357                              size_t* len) {
358    static const char kPad64Equals = '=';
359    static const char kPad64Dot = '.';
360    size_t destidx = 0;
361    int decode = 0;
362    int state = 0;
363    unsigned char ch = 0;
364    unsigned int temp = 0;
365    const unsigned char* src = reinterpret_cast<const unsigned char*>(src_param);
366  #define GET_INPUT(label, remain)                                \
367    label:                                                        \
368    --szsrc;                                                      \
369    ch = *src++;                                                  \
370    decode = unbase64[ch];                                        \
371    if (decode < 0) {                                             \
372      if (absl::ascii_isspace(ch) && szsrc >= remain) goto label; \
373      state = 4 - remain;                                         \
374      break;                                                      \
375    }
376    if (dest) {
377      while (szsrc >= 4) {
378        if (!src[0] || !src[1] || !src[2] ||
379            ((temp = ((unsigned(unbase64[src[0]]) << 18) |
380                      (unsigned(unbase64[src[1]]) << 12) |
381                      (unsigned(unbase64[src[2]]) << 6) |
382                      (unsigned(unbase64[src[3]])))) &
383             0x80000000)) {
384          GET_INPUT(first, 4);
385          temp = static_cast<unsigned char>(decode);
386          GET_INPUT(second, 3);
387          temp = (temp << 6) | static_cast<unsigned char>(decode);
388          GET_INPUT(third, 2);
389          temp = (temp << 6) | static_cast<unsigned char>(decode);
390          GET_INPUT(fourth, 1);
391          temp = (temp << 6) | static_cast<unsigned char>(decode);
392        } else {
393          szsrc -= 4;
394          src += 4;
395        }
396        if (destidx + 3 > szdest) return false;
397        dest[destidx + 2] = static_cast<char>(temp);
398        temp >>= 8;
399        dest[destidx + 1] = static_cast<char>(temp);
400        temp >>= 8;
401        dest[destidx] = static_cast<char>(temp);
402        destidx += 3;
403      }
404    } else {
405      while (szsrc >= 4) {
406        if (!src[0] || !src[1] || !src[2] ||
407            ((temp = ((unsigned(unbase64[src[0]]) << 18) |
408                      (unsigned(unbase64[src[1]]) << 12) |
409                      (unsigned(unbase64[src[2]]) << 6) |
410                      (unsigned(unbase64[src[3]])))) &
411             0x80000000)) {
412          GET_INPUT(first_no_dest, 4);
413          GET_INPUT(second_no_dest, 3);
414          GET_INPUT(third_no_dest, 2);
415          GET_INPUT(fourth_no_dest, 1);
416        } else {
417          szsrc -= 4;
418          src += 4;
419        }
420        destidx += 3;
421      }
422    }
423  #undef GET_INPUT
424    if (decode < 0 && ch != kPad64Equals && ch != kPad64Dot &&
425        !absl::ascii_isspace(ch))
426      return false;
427    if (ch == kPad64Equals || ch == kPad64Dot) {
428      ++szsrc;
429      --src;
430    } else {
431      while (szsrc > 0) {
432        --szsrc;
433        ch = *src++;
434        decode = unbase64[ch];
435        if (decode < 0) {
436          if (absl::ascii_isspace(ch)) {
437            continue;
438          } else if (ch == kPad64Equals || ch == kPad64Dot) {
439            ++szsrc;
440            --src;
441            break;
442          } else {
443            return false;
444          }
445        }
446        temp = (temp << 6) | static_cast<unsigned char>(decode);
447        ++state;
448        if (state == 4) {
449          if (dest) {
450            if (destidx + 3 > szdest) return false;
451            dest[destidx + 2] = static_cast<char>(temp);
<span onclick='openModal()' class='match'>452            temp >>= 8;
453            dest[destidx + 1] = static_cast<char>(temp);
454            temp >>= 8;
455            dest[destidx] = static_cast<char>(temp);
456          }
</span>457          destidx += 3;
458          state = 0;
459          temp = 0;
460        }
461      }
462    }
463    int expected_equals = 0;
464    switch (state) {
465      case 0:
466        break;
467      case 1:
468        return false;
469      case 2:
470        if (dest) {
471          if (destidx + 1 > szdest) return false;
472          temp >>= 4;
473          dest[destidx] = static_cast<char>(temp);
474        }
475        ++destidx;
476        expected_equals = 2;
477        break;
478      case 3:
479        if (dest) {
480          if (destidx + 2 > szdest) return false;
481          temp >>= 2;
482          dest[destidx + 1] = static_cast<char>(temp);
483          temp >>= 8;
484          dest[destidx] = static_cast<char>(temp);
485        }
486        destidx += 2;
487        expected_equals = 1;
488        break;
489      default:
490        ABSL_RAW_LOG(FATAL, "This can't happen; base64 decoder state = %d",
491                     state);
492    }
493    int equals = 0;
494    while (szsrc > 0) {
495      if (*src == kPad64Equals || *src == kPad64Dot)
496        ++equals;
497      else if (!absl::ascii_isspace(*src))
498        return false;
499      --szsrc;
500      ++src;
501    }
502    const bool ok = (equals == 0 || equals == expected_equals);
503    if (ok) *len = destidx;
504    return ok;
505  }
506  constexpr signed char kUnBase64[] = {
507      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
508      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
509      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
510      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
511      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
512      -1,      -1,      -1,      62&bsol;*+*/, -1,      -1,      -1,      63&bsol;*/ */,
513      52&bsol;*0*/, 53&bsol;*1*/, 54&bsol;*2*/, 55&bsol;*3*/, 56&bsol;*4*/, 57&bsol;*5*/, 58&bsol;*6*/, 59&bsol;*7*/,
514      60&bsol;*8*/, 61&bsol;*9*/, -1,      -1,      -1,      -1,      -1,      -1,
515      -1,       0&bsol;*A*/,  1&bsol;*B*/,  2&bsol;*C*/,  3&bsol;*D*/,  4&bsol;*E*/,  5&bsol;*F*/,  6&bsol;*G*/,
516      07&bsol;*H*/,  8&bsol;*I*/,  9&bsol;*J*/, 10&bsol;*K*/, 11&bsol;*L*/, 12&bsol;*M*/, 13&bsol;*N*/, 14&bsol;*O*/,
517      15&bsol;*P*/, 16&bsol;*Q*/, 17&bsol;*R*/, 18&bsol;*S*/, 19&bsol;*T*/, 20&bsol;*U*/, 21&bsol;*V*/, 22&bsol;*W*/,
518      23&bsol;*X*/, 24&bsol;*Y*/, 25&bsol;*Z*/, -1,      -1,      -1,      -1,      -1,
519      -1,      26&bsol;*a*/, 27&bsol;*b*/, 28&bsol;*c*/, 29&bsol;*d*/, 30&bsol;*e*/, 31&bsol;*f*/, 32&bsol;*g*/,
520      33&bsol;*h*/, 34&bsol;*i*/, 35&bsol;*j*/, 36&bsol;*k*/, 37&bsol;*l*/, 38&bsol;*m*/, 39&bsol;*n*/, 40&bsol;*o*/,
521      41&bsol;*p*/, 42&bsol;*q*/, 43&bsol;*r*/, 44&bsol;*s*/, 45&bsol;*t*/, 46&bsol;*u*/, 47&bsol;*v*/, 48&bsol;*w*/,
522      49&bsol;*x*/, 50&bsol;*y*/, 51&bsol;*z*/, -1,      -1,      -1,      -1,      -1,
523      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
524      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
525      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
526      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
527      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
528      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
529      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
530      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
531      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
532      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
533      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
534      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
535      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
536      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
537      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
538      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
539  };
540  constexpr signed char kUnWebSafeBase64[] = {
541      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
542      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
543      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
544      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
545      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
546      -1,      -1,      -1,      -1,      -1,      62&bsol;*-*/, -1,      -1,
547      52&bsol;*0*/, 53&bsol;*1*/, 54&bsol;*2*/, 55&bsol;*3*/, 56&bsol;*4*/, 57&bsol;*5*/, 58&bsol;*6*/, 59&bsol;*7*/,
548      60&bsol;*8*/, 61&bsol;*9*/, -1,      -1,      -1,      -1,      -1,      -1,
549      -1,       0&bsol;*A*/,  1&bsol;*B*/,  2&bsol;*C*/,  3&bsol;*D*/,  4&bsol;*E*/,  5&bsol;*F*/,  6&bsol;*G*/,
550      07&bsol;*H*/,  8&bsol;*I*/,  9&bsol;*J*/, 10&bsol;*K*/, 11&bsol;*L*/, 12&bsol;*M*/, 13&bsol;*N*/, 14&bsol;*O*/,
551      15&bsol;*P*/, 16&bsol;*Q*/, 17&bsol;*R*/, 18&bsol;*S*/, 19&bsol;*T*/, 20&bsol;*U*/, 21&bsol;*V*/, 22&bsol;*W*/,
552      23&bsol;*X*/, 24&bsol;*Y*/, 25&bsol;*Z*/, -1,      -1,      -1,      -1,      63&bsol;*_*/,
553      -1,      26&bsol;*a*/, 27&bsol;*b*/, 28&bsol;*c*/, 29&bsol;*d*/, 30&bsol;*e*/, 31&bsol;*f*/, 32&bsol;*g*/,
554      33&bsol;*h*/, 34&bsol;*i*/, 35&bsol;*j*/, 36&bsol;*k*/, 37&bsol;*l*/, 38&bsol;*m*/, 39&bsol;*n*/, 40&bsol;*o*/,
555      41&bsol;*p*/, 42&bsol;*q*/, 43&bsol;*r*/, 44&bsol;*s*/, 45&bsol;*t*/, 46&bsol;*u*/, 47&bsol;*v*/, 48&bsol;*w*/,
556      49&bsol;*x*/, 50&bsol;*y*/, 51&bsol;*z*/, -1,      -1,      -1,      -1,      -1,
557      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
558      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
559      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
560      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
561      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
562      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
563      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
564      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
565      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
566      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
567      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
568      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
569      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
570      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
571      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
572      -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
573  };
574  template <typename String>
575  bool Base64UnescapeInternal(const char* src, size_t slen, String* dest,
576                              const signed char* unbase64) {
577    const size_t dest_len = 3 * (slen / 4) + (slen % 4);
578    strings_internal::STLStringResizeUninitialized(dest, dest_len);
579    size_t len;
580    const bool ok =
581        Base64UnescapeInternal(src, slen, &(*dest)[0], dest_len, unbase64, &len);
582    if (!ok) {
583      dest->clear();
584      return false;
585    }
586    assert(len <= dest_len);
587    dest->erase(len);
588    return true;
589  }
590  constexpr char kHexValueLenient[256] = {
591      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
592      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
593      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
594      0,  1,  2,  3,  4,  5,  6, 7, 8, 9, 0, 0, 0, 0, 0, 0,  
595      0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
596      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
597      0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  
598      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
599      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
600      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
601      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
602      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
603      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
604      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
605      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
606      0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
607  };
608  template <typename T>
609  void HexStringToBytesInternal(const char* from, T to, size_t num) {
610    for (size_t i = 0; i < num; i++) {
611      to[i] = static_cast<char>(kHexValueLenient[from[i * 2] & 0xFF] << 4) +
612              (kHexValueLenient[from[i * 2 + 1] & 0xFF]);
613    }
614  }
615  template <typename T>
616  void BytesToHexStringInternal(const unsigned char* src, T dest, size_t num) {
617    auto dest_ptr = &dest[0];
618    for (auto src_ptr = src; src_ptr != (src + num); ++src_ptr, dest_ptr += 2) {
619      const char* hex_p = &numbers_internal::kHexTable[*src_ptr * 2];
620      std::copy(hex_p, hex_p + 2, dest_ptr);
621    }
622  }
623  }  
624  bool CUnescape(absl::string_view source, std::string* dest,
625                 std::string* error) {
626    return CUnescapeInternal(source, kUnescapeNulls, dest, error);
627  }
628  std::string CEscape(absl::string_view src) {
629    std::string dest;
630    CEscapeAndAppendInternal(src, &dest);
631    return dest;
632  }
633  std::string CHexEscape(absl::string_view src) {
634    return CEscapeInternal(src, true, false);
635  }
636  std::string Utf8SafeCEscape(absl::string_view src) {
637    return CEscapeInternal(src, false, true);
638  }
639  std::string Utf8SafeCHexEscape(absl::string_view src) {
640    return CEscapeInternal(src, true, true);
641  }
642  bool Base64Unescape(absl::string_view src, std::string* dest) {
643    return Base64UnescapeInternal(src.data(), src.size(), dest, kUnBase64);
644  }
645  bool WebSafeBase64Unescape(absl::string_view src, std::string* dest) {
646    return Base64UnescapeInternal(src.data(), src.size(), dest, kUnWebSafeBase64);
647  }
648  void Base64Escape(absl::string_view src, std::string* dest) {
649    strings_internal::Base64EscapeInternal(
650        reinterpret_cast<const unsigned char*>(src.data()), src.size(), dest,
651        true, strings_internal::kBase64Chars);
652  }
653  void WebSafeBase64Escape(absl::string_view src, std::string* dest) {
654    strings_internal::Base64EscapeInternal(
655        reinterpret_cast<const unsigned char*>(src.data()), src.size(), dest,
656        false, strings_internal::kWebSafeBase64Chars);
657  }
658  std::string Base64Escape(absl::string_view src) {
659    std::string dest;
660    strings_internal::Base64EscapeInternal(
661        reinterpret_cast<const unsigned char*>(src.data()), src.size(), &dest,
662        true, strings_internal::kBase64Chars);
663    return dest;
664  }
665  std::string WebSafeBase64Escape(absl::string_view src) {
666    std::string dest;
667    strings_internal::Base64EscapeInternal(
668        reinterpret_cast<const unsigned char*>(src.data()), src.size(), &dest,
669        false, strings_internal::kWebSafeBase64Chars);
670    return dest;
671  }
672  std::string HexStringToBytes(absl::string_view from) {
673    std::string result;
674    const auto num = from.size() / 2;
675    strings_internal::STLStringResizeUninitialized(&result, num);
676    absl::HexStringToBytesInternal<std::string&>(from.data(), result, num);
677    return result;
678  }
679  std::string BytesToHexString(absl::string_view from) {
680    std::string result;
681    strings_internal::STLStringResizeUninitialized(&result, 2 * from.size());
682    absl::BytesToHexStringInternal<std::string&>(
683        reinterpret_cast<const unsigned char*>(from.data()), result, from.size());
684    return result;
685  }
686  ABSL_NAMESPACE_END
687  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-escaping.cc</div>
                </div>
                <div class="column column_space"><pre><code>398        temp >>= 8;
399        dest[destidx + 1] = static_cast<char>(temp);
400        temp >>= 8;
401        dest[destidx] = static_cast<char>(temp);
402        destidx += 3;
</pre></code></div>
                <div class="column column_space"><pre><code>452            temp >>= 8;
453            dest[destidx + 1] = static_cast<char>(temp);
454            temp >>= 8;
455            dest[destidx] = static_cast<char>(temp);
456          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    