
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tcp_server.cpp</h3>
            <pre><code>1  #include <nano/node/bootstrap/bootstrap_bulk_push.hpp>
2  #include <nano/node/bootstrap/bootstrap_frontier.hpp>
3  #include <nano/node/messages.hpp>
4  #include <nano/node/node.hpp>
5  #include <nano/node/transport/message_deserializer.hpp>
6  #include <nano/node/transport/tcp.hpp>
7  #include <nano/node/transport/tcp_server.hpp>
8  #include <boost/format.hpp>
9  #include <memory>
10  nano::transport::tcp_listener::tcp_listener (uint16_t port_a, nano::node & node_a) :
11  	node (node_a),
12  	port (port_a)
13  {
14  }
15  void nano::transport::tcp_listener::start ()
16  {
17  	nano::lock_guard<nano::mutex> lock{ mutex };
18  	on = true;
19  	listening_socket = std::make_shared<nano::transport::server_socket> (node, boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::any (), port), node.config.tcp_incoming_connections_max);
20  	boost::system::error_code ec;
21  	listening_socket->start (ec);
22  	if (ec)
23  	{
24  		node.logger.always_log (boost::str (boost::format ("Network: Error while binding for incoming TCP/bootstrap on port %1%: %2%") % listening_socket->listening_port () % ec.message ()));
25  		throw std::runtime_error (ec.message ());
26  	}
27  	const auto listening_port = listening_socket->listening_port ();
28  	{
29  		if (port == listening_port)
30  		{
31  			debug_assert (port == node.network.port);
32  			debug_assert (port == node.network.endpoint ().port ());
33  		}
34  		else
35  		{
36  			port = listening_port;
37  		}
38  	}
39  	listening_socket->on_connection ([this] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
40  		if (!ec_a)
41  		{
42  			accept_action (ec_a, new_connection);
43  		}
44  		return true;
45  	});
46  }
47  void nano::transport::tcp_listener::stop ()
48  {
49  	decltype (connections) connections_l;
50  	{
51  		nano::lock_guard<nano::mutex> lock{ mutex };
52  		on = false;
53  		connections_l.swap (connections);
54  	}
55  	if (listening_socket)
56  	{
57  		nano::lock_guard<nano::mutex> lock{ mutex };
58  		listening_socket->close ();
59  		listening_socket = nullptr;
60  	}
61  }
62  std::size_t nano::transport::tcp_listener::connection_count ()
63  {
64  	nano::lock_guard<nano::mutex> lock{ mutex };
65  	return connections.size ();
66  }
67  void nano::transport::tcp_listener::accept_action (boost::system::error_code const & ec, std::shared_ptr<nano::transport::socket> const & socket_a)
68  {
69  	if (!node.network.excluded_peers.check (socket_a->remote_endpoint ()))
70  	{
71  		auto server = std::make_shared<nano::transport::tcp_server> (socket_a, node.shared (), true);
72  		nano::lock_guard<nano::mutex> lock{ mutex };
73  		connections[server.get ()] = server;
74  		server->start ();
75  	}
76  	else
77  	{
78  		node.stats.inc (nano::stat::type::tcp, nano::stat::detail::tcp_excluded);
79  		if (node.config.logging.network_rejected_logging ())
80  		{
81  			node.logger.try_log ("Rejected connection from excluded peer ", socket_a->remote_endpoint ());
82  		}
83  	}
84  }
85  boost::asio::ip::tcp::endpoint nano::transport::tcp_listener::endpoint ()
86  {
87  	nano::lock_guard<nano::mutex> lock{ mutex };
88  	if (on && listening_socket)
89  	{
90  		return boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), port);
91  	}
92  	else
93  	{
94  		return boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), 0);
95  	}
96  }
97  std::unique_ptr<nano::container_info_component> nano::transport::collect_container_info (nano::transport::tcp_listener & bootstrap_listener, std::string const & name)
98  {
99  	auto sizeof_element = sizeof (decltype (bootstrap_listener.connections)::value_type);
100  	auto composite = std::make_unique<container_info_composite> (name);
101  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "connections", bootstrap_listener.connection_count (), sizeof_element }));
102  	return composite;
103  }
104  nano::transport::tcp_server::tcp_server (std::shared_ptr<nano::transport::socket> socket_a, std::shared_ptr<nano::node> node_a, bool allow_bootstrap_a) :
105  	socket{ std::move (socket_a) },
106  	node{ std::move (node_a) },
107  	allow_bootstrap{ allow_bootstrap_a },
108  	message_deserializer{
109  		std::make_shared<nano::transport::message_deserializer> (node_a->network_params.network, node_a->network.publish_filter, node_a->block_uniquer, node_a->vote_uniquer,
110  		[socket_l = socket] (std::shared_ptr<std::vector<uint8_t>> const & data_a, size_t size_a, std::function<void (boost::system::error_code const &, std::size_t)> callback_a) {
111  			debug_assert (socket_l != nullptr);
112  			socket_l->read_impl (data_a, size_a, callback_a);
113  		})
114  	}
115  {
116  	debug_assert (socket != nullptr);
117  }
118  nano::transport::tcp_server::~tcp_server ()
119  {
120  	auto node = this->node.lock ();
121  	if (!node)
122  	{
123  		return;
124  	}
125  	if (node->config.logging.bulk_pull_logging ())
126  	{
127  		node->logger.try_log ("Exiting incoming TCP/bootstrap server");
128  	}
129  	if (socket->type () == nano::transport::socket::type_t::bootstrap)
130  	{
131  		--node->tcp_listener.bootstrap_count;
132  	}
133  	else if (socket->type () == nano::transport::socket::type_t::realtime)
134  	{
135  		--node->tcp_listener.realtime_count;
136  		auto exisiting_response_channel (node->network.tcp_channels.find_channel (remote_endpoint));
137  		if (exisiting_response_channel != nullptr)
138  		{
139  			exisiting_response_channel->temporary = false;
140  			node->network.tcp_channels.erase (remote_endpoint);
141  		}
142  	}
143  	stop ();
144  	nano::lock_guard<nano::mutex> lock{ node->tcp_listener.mutex };
145  	node->tcp_listener.connections.erase (this);
146  }
147  void nano::transport::tcp_server::start ()
148  {
149  	if (remote_endpoint.port () == 0)
150  	{
151  		remote_endpoint = socket->remote_endpoint ();
152  		debug_assert (remote_endpoint.port () != 0);
153  	}
154  	receive_message ();
155  }
156  void nano::transport::tcp_server::stop ()
157  {
158  	if (!stopped.exchange (true))
159  	{
160  		socket->close ();
161  	}
162  }
163  void nano::transport::tcp_server::receive_message ()
164  {
165  	if (stopped)
166  	{
167  		return;
168  	}
169  	message_deserializer->read ([this_l = shared_from_this ()] (boost::system::error_code ec, std::unique_ptr<nano::message> message) {
170  		auto node = this_l->node.lock ();
171  		if (!node)
172  		{
173  			return;
174  		}
175  		if (ec)
176  		{
177  			node->stats.inc (nano::stat::type::error, nano::transport::message_deserializer::to_stat_detail (this_l->message_deserializer->status));
178  			this_l->stop ();
179  		}
180  		else
181  		{
182  			this_l->received_message (std::move (message));
183  		}
184  	});
185  }
186  void nano::transport::tcp_server::received_message (std::unique_ptr<nano::message> message)
187  {
188  	auto node = this->node.lock ();
189  	if (!node)
190  	{
191  		return;
192  	}
193  	bool should_continue = true;
194  	if (message)
195  	{
196  		should_continue = process_message (std::move (message));
197  	}
198  	else
199  	{
200  		debug_assert (message_deserializer->status != transport::message_deserializer::parse_status::success);
201  		node->stats.inc (nano::stat::type::error, nano::transport::message_deserializer::to_stat_detail (message_deserializer->status));
202  		if (message_deserializer->status == transport::message_deserializer::parse_status::duplicate_publish_message)
203  		{
204  			node->stats.inc (nano::stat::type::filter, nano::stat::detail::duplicate_publish);
205  		}
206  	}
207  	if (should_continue)
208  	{
209  		receive_message ();
210  	}
211  }
212  bool nano::transport::tcp_server::process_message (std::unique_ptr<nano::message> message)
213  {
214  	auto node = this->node.lock ();
215  	if (!node)
216  	{
217  		return false;
218  	}
219  	node->stats.inc (nano::stat::type::tcp_server, nano::to_stat_detail (message->header.type), nano::stat::dir::in);
220  	debug_assert (is_undefined_connection () || is_realtime_connection () || is_bootstrap_connection ());
221  	if (is_undefined_connection ())
222  	{
<span onclick='openModal()' class='match'>223  		handshake_message_visitor handshake_visitor{ shared_from_this () };
224  		message->visit (handshake_visitor);
225  		if (handshake_visitor.process)
</span>226  		{
227  			queue_realtime (std::move (message));
228  			return true;
229  		}
230  		else if (handshake_visitor.bootstrap)
231  		{
232  			if (!to_bootstrap_connection ())
233  			{
234  				stop ();
235  				return false;
236  			}
237  		}
238  		else
239  		{
240  			return true;
241  		}
242  	}
243  	else if (is_realtime_connection ())
244  	{
245  		realtime_message_visitor realtime_visitor{ *this };
246  		message->visit (realtime_visitor);
247  		if (realtime_visitor.process)
248  		{
249  			queue_realtime (std::move (message));
250  		}
251  		return true;
252  	}
253  	if (is_bootstrap_connection ())
254  	{
255  		bootstrap_message_visitor bootstrap_visitor{ shared_from_this () };
256  		message->visit (bootstrap_visitor);
257  		return !bootstrap_visitor.processed; 
258  	}
259  	debug_assert (false);
260  	return true; 
261  }
262  void nano::transport::tcp_server::queue_realtime (std::unique_ptr<nano::message> message)
263  {
264  	auto node = this->node.lock ();
265  	if (!node)
266  	{
267  		return;
268  	}
269  	node->network.tcp_message_manager.put_message (nano::tcp_message_item{ std::move (message), remote_endpoint, remote_node_id, socket });
270  }
271  nano::transport::tcp_server::handshake_message_visitor::handshake_message_visitor (std::shared_ptr<tcp_server> server) :
272  	server{ std::move (server) }
273  {
274  }
275  void nano::transport::tcp_server::handshake_message_visitor::node_id_handshake (nano::node_id_handshake const & message)
276  {
277  	auto node = server->node.lock ();
278  	if (!node)
279  	{
280  		return;
281  	}
282  	if (node->flags.disable_tcp_realtime)
283  	{
284  		if (node->config.logging.network_node_id_handshake_logging ())
285  		{
286  			node->logger.try_log (boost::str (boost::format ("Disabled realtime TCP for handshake %1%") % server->remote_endpoint));
287  		}
288  		server->stop ();
289  		return;
290  	}
291  	if (message.query && server->handshake_query_received)
292  	{
293  		if (node->config.logging.network_node_id_handshake_logging ())
294  		{
295  			node->logger.try_log (boost::str (boost::format ("Detected multiple node_id_handshake query from %1%") % server->remote_endpoint));
296  		}
297  		server->stop ();
298  		return;
299  	}
300  	server->handshake_query_received = true;
301  	if (node->config.logging.network_node_id_handshake_logging ())
302  	{
303  		node->logger.try_log (boost::str (boost::format ("Received node_id_handshake message from %1%") % server->remote_endpoint));
304  	}
305  	if (message.query)
306  	{
307  		server->send_handshake_response (*message.query, message.is_v2 ());
308  	}
309  	if (message.response)
310  	{
311  		if (node->network.verify_handshake_response (*message.response, nano::transport::map_tcp_to_endpoint (server->remote_endpoint)))
312  		{
313  			server->to_realtime_connection (message.response->node_id);
314  		}
315  		else
316  		{
317  			server->stop ();
318  			return;
319  		}
320  	}
321  	process = true;
322  }
323  void nano::transport::tcp_server::send_handshake_response (nano::node_id_handshake::query_payload const & query, bool v2)
324  {
325  	auto node = this->node.lock ();
326  	if (!node)
327  	{
328  		return;
329  	}
330  	auto response = node->network.prepare_handshake_response (query, v2);
331  	auto own_query = node->network.prepare_handshake_query (nano::transport::map_tcp_to_endpoint (remote_endpoint));
332  	nano::node_id_handshake handshake_response{ node->network_params.network, own_query, response };
333  	auto shared_const_buffer = handshake_response.to_shared_const_buffer ();
334  	socket->async_write (shared_const_buffer, [this_l = shared_from_this ()] (boost::system::error_code const & ec, std::size_t size_a) {
335  		auto node = this_l->node.lock ();
336  		if (!node)
337  		{
338  			return;
339  		}
340  		if (ec)
341  		{
342  			if (node->config.logging.network_node_id_handshake_logging ())
343  			{
344  				node->logger.try_log (boost::str (boost::format ("Error sending node_id_handshake to %1%: %2%") % this_l->remote_endpoint % ec.message ()));
345  			}
346  			this_l->stop ();
347  		}
348  		else
349  		{
350  			node->stats.inc (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::out);
351  		}
352  	});
353  }
354  void nano::transport::tcp_server::handshake_message_visitor::bulk_pull (const nano::bulk_pull & message)
355  {
356  	bootstrap = true;
357  }
358  void nano::transport::tcp_server::handshake_message_visitor::bulk_pull_account (const nano::bulk_pull_account & message)
359  {
360  	bootstrap = true;
361  }
362  void nano::transport::tcp_server::handshake_message_visitor::bulk_push (const nano::bulk_push & message)
363  {
364  	bootstrap = true;
365  }
366  void nano::transport::tcp_server::handshake_message_visitor::frontier_req (const nano::frontier_req & message)
367  {
368  	bootstrap = true;
369  }
370  nano::transport::tcp_server::realtime_message_visitor::realtime_message_visitor (nano::transport::tcp_server & server_a) :
371  	server{ server_a }
372  {
373  }
374  void nano::transport::tcp_server::realtime_message_visitor::keepalive (const nano::keepalive & message)
375  {
376  	process = true;
377  }
378  void nano::transport::tcp_server::realtime_message_visitor::publish (const nano::publish & message)
379  {
380  	process = true;
381  }
382  void nano::transport::tcp_server::realtime_message_visitor::confirm_req (const nano::confirm_req & message)
383  {
384  	process = true;
385  }
386  void nano::transport::tcp_server::realtime_message_visitor::confirm_ack (const nano::confirm_ack & message)
387  {
388  	process = true;
389  }
390  void nano::transport::tcp_server::realtime_message_visitor::frontier_req (const nano::frontier_req & message)
391  {
392  	process = true;
393  }
394  void nano::transport::tcp_server::realtime_message_visitor::telemetry_req (const nano::telemetry_req & message)
395  {
396  	auto node = server.node.lock ();
397  	if (!node)
398  	{
399  		return;
400  	}
401  	if (server.last_telemetry_req + node->network_params.network.telemetry_request_cooldown < std::chrono::steady_clock::now ())
402  	{
403  		server.last_telemetry_req = std::chrono::steady_clock::now ();
404  		process = true;
405  	}
406  	else
407  	{
408  		node->stats.inc (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone);
409  	}
410  }
411  void nano::transport::tcp_server::realtime_message_visitor::telemetry_ack (const nano::telemetry_ack & message)
412  {
413  	process = true;
414  }
415  void nano::transport::tcp_server::realtime_message_visitor::asc_pull_req (const nano::asc_pull_req & message)
416  {
417  	process = true;
418  }
419  void nano::transport::tcp_server::realtime_message_visitor::asc_pull_ack (const nano::asc_pull_ack & message)
420  {
421  	process = true;
422  }
423  nano::transport::tcp_server::bootstrap_message_visitor::bootstrap_message_visitor (std::shared_ptr<tcp_server> server) :
424  	server{ std::move (server) }
425  {
426  }
427  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_pull (const nano::bulk_pull & message)
428  {
429  	auto node = server->node.lock ();
430  	if (!node)
431  	{
432  		return;
433  	}
434  	if (node->flags.disable_bootstrap_bulk_pull_server)
435  	{
436  		return;
437  	}
438  	if (node->config.logging.bulk_pull_logging ())
439  	{
440  		node->logger.try_log (boost::str (boost::format ("Received bulk pull for %1% down to %2%, maximum of %3% from %4%") % message.start.to_string () % message.end.to_string () % message.count % server->remote_endpoint));
441  	}
442  	node->bootstrap_workers.push_task ([server = server, message = message] () {
443  		auto bulk_pull_server = std::make_shared<nano::bulk_pull_server> (server, std::make_unique<nano::bulk_pull> (message));
444  		bulk_pull_server->send_next ();
445  	});
446  	processed = true;
447  }
448  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_pull_account (const nano::bulk_pull_account & message)
449  {
450  	auto node = server->node.lock ();
451  	if (!node)
452  	{
453  		return;
454  	}
455  	if (node->flags.disable_bootstrap_bulk_pull_server)
456  	{
457  		return;
458  	}
459  	if (node->config.logging.bulk_pull_logging ())
460  	{
461  		node->logger.try_log (boost::str (boost::format ("Received bulk pull account for %1% with a minimum amount of %2%") % message.account.to_account () % nano::amount (message.minimum_amount).format_balance (nano::Mxrb_ratio, 10, true)));
462  	}
463  	node->bootstrap_workers.push_task ([server = server, message = message] () {
464  		auto bulk_pull_account_server = std::make_shared<nano::bulk_pull_account_server> (server, std::make_unique<nano::bulk_pull_account> (message));
465  		bulk_pull_account_server->send_frontier ();
466  	});
467  	processed = true;
468  }
469  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_push (const nano::bulk_push &)
470  {
471  	auto node = server->node.lock ();
472  	if (!node)
473  	{
474  		return;
475  	}
476  	node->bootstrap_workers.push_task ([server = server] () {
477  		auto bulk_push_server = std::make_shared<nano::bulk_push_server> (server);
478  		bulk_push_server->throttled_receive ();
479  	});
480  	processed = true;
481  }
482  void nano::transport::tcp_server::bootstrap_message_visitor::frontier_req (const nano::frontier_req & message)
483  {
484  	auto node = server->node.lock ();
485  	if (!node)
486  	{
487  		return;
488  	}
489  	if (node->config.logging.bulk_pull_logging ())
490  	{
491  		node->logger.try_log (boost::str (boost::format ("Received frontier request for %1% with age %2%") % message.start.to_string () % message.age));
492  	}
493  	node->bootstrap_workers.push_task ([server = server, message = message] () {
494  		auto response = std::make_shared<nano::frontier_req_server> (server, std::make_unique<nano::frontier_req> (message));
495  		response->send_next ();
496  	});
497  	processed = true;
498  }
499  void nano::transport::tcp_server::timeout ()
500  {
501  	auto node = this->node.lock ();
502  	if (!node)
503  	{
504  		return;
505  	}
506  	if (socket->has_timed_out ())
507  	{
508  		if (node->config.logging.bulk_pull_logging ())
509  		{
510  			node->logger.try_log ("Closing incoming tcp / bootstrap server by timeout");
511  		}
512  		{
513  			nano::lock_guard<nano::mutex> lock{ node->tcp_listener.mutex };
514  			node->tcp_listener.connections.erase (this);
515  		}
516  		socket->close ();
517  	}
518  }
519  bool nano::transport::tcp_server::to_bootstrap_connection ()
520  {
521  	auto node = this->node.lock ();
522  	if (!node)
523  	{
524  		return false;
525  	}
526  	if (!allow_bootstrap)
527  	{
528  		return false;
529  	}
530  	if (node->flags.disable_bootstrap_listener)
531  	{
532  		return false;
533  	}
534  	if (node->tcp_listener.bootstrap_count >= node->config.bootstrap_connections_max)
535  	{
536  		return false;
537  	}
538  	if (socket->type () != nano::transport::socket::type_t::undefined)
539  	{
540  		return false;
541  	}
542  	++node->tcp_listener.bootstrap_count;
543  	socket->type_set (nano::transport::socket::type_t::bootstrap);
544  	return true;
545  }
546  bool nano::transport::tcp_server::to_realtime_connection (nano::account const & node_id)
547  {
548  	auto node = this->node.lock ();
549  	if (!node)
550  	{
551  		return false;
552  	}
553  	if (socket->type () == nano::transport::socket::type_t::undefined && !node->flags.disable_tcp_realtime)
554  	{
555  		remote_node_id = node_id;
556  		++node->tcp_listener.realtime_count;
557  		socket->type_set (nano::transport::socket::type_t::realtime);
558  		return true;
559  	}
560  	return false;
561  }
562  bool nano::transport::tcp_server::is_undefined_connection () const
563  {
564  	return socket->type () == nano::transport::socket::type_t::undefined;
565  }
566  bool nano::transport::tcp_server::is_bootstrap_connection () const
567  {
568  	return socket->is_bootstrap_connection ();
569  }
570  bool nano::transport::tcp_server::is_realtime_connection () const
571  {
572  	return socket->is_realtime_connection ();
573  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tcp_server.cpp</h3>
            <pre><code>1  #include <nano/node/bootstrap/bootstrap_bulk_push.hpp>
2  #include <nano/node/bootstrap/bootstrap_frontier.hpp>
3  #include <nano/node/messages.hpp>
4  #include <nano/node/node.hpp>
5  #include <nano/node/transport/message_deserializer.hpp>
6  #include <nano/node/transport/tcp.hpp>
7  #include <nano/node/transport/tcp_server.hpp>
8  #include <boost/format.hpp>
9  #include <memory>
10  nano::transport::tcp_listener::tcp_listener (uint16_t port_a, nano::node & node_a) :
11  	node (node_a),
12  	port (port_a)
13  {
14  }
15  void nano::transport::tcp_listener::start ()
16  {
17  	nano::lock_guard<nano::mutex> lock{ mutex };
18  	on = true;
19  	listening_socket = std::make_shared<nano::transport::server_socket> (node, boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::any (), port), node.config.tcp_incoming_connections_max);
20  	boost::system::error_code ec;
21  	listening_socket->start (ec);
22  	if (ec)
23  	{
24  		node.logger.always_log (boost::str (boost::format ("Network: Error while binding for incoming TCP/bootstrap on port %1%: %2%") % listening_socket->listening_port () % ec.message ()));
25  		throw std::runtime_error (ec.message ());
26  	}
27  	const auto listening_port = listening_socket->listening_port ();
28  	{
29  		if (port == listening_port)
30  		{
31  			debug_assert (port == node.network.port);
32  			debug_assert (port == node.network.endpoint ().port ());
33  		}
34  		else
35  		{
36  			port = listening_port;
37  		}
38  	}
39  	listening_socket->on_connection ([this] (std::shared_ptr<nano::transport::socket> const & new_connection, boost::system::error_code const & ec_a) {
40  		if (!ec_a)
41  		{
42  			accept_action (ec_a, new_connection);
43  		}
44  		return true;
45  	});
46  }
47  void nano::transport::tcp_listener::stop ()
48  {
49  	decltype (connections) connections_l;
50  	{
51  		nano::lock_guard<nano::mutex> lock{ mutex };
52  		on = false;
53  		connections_l.swap (connections);
54  	}
55  	if (listening_socket)
56  	{
57  		nano::lock_guard<nano::mutex> lock{ mutex };
58  		listening_socket->close ();
59  		listening_socket = nullptr;
60  	}
61  }
62  std::size_t nano::transport::tcp_listener::connection_count ()
63  {
64  	nano::lock_guard<nano::mutex> lock{ mutex };
65  	return connections.size ();
66  }
67  void nano::transport::tcp_listener::accept_action (boost::system::error_code const & ec, std::shared_ptr<nano::transport::socket> const & socket_a)
68  {
69  	if (!node.network.excluded_peers.check (socket_a->remote_endpoint ()))
70  	{
71  		auto server = std::make_shared<nano::transport::tcp_server> (socket_a, node.shared (), true);
72  		nano::lock_guard<nano::mutex> lock{ mutex };
73  		connections[server.get ()] = server;
74  		server->start ();
75  	}
76  	else
77  	{
78  		node.stats.inc (nano::stat::type::tcp, nano::stat::detail::tcp_excluded);
79  		if (node.config.logging.network_rejected_logging ())
80  		{
81  			node.logger.try_log ("Rejected connection from excluded peer ", socket_a->remote_endpoint ());
82  		}
83  	}
84  }
85  boost::asio::ip::tcp::endpoint nano::transport::tcp_listener::endpoint ()
86  {
87  	nano::lock_guard<nano::mutex> lock{ mutex };
88  	if (on && listening_socket)
89  	{
90  		return boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), port);
91  	}
92  	else
93  	{
94  		return boost::asio::ip::tcp::endpoint (boost::asio::ip::address_v6::loopback (), 0);
95  	}
96  }
97  std::unique_ptr<nano::container_info_component> nano::transport::collect_container_info (nano::transport::tcp_listener & bootstrap_listener, std::string const & name)
98  {
99  	auto sizeof_element = sizeof (decltype (bootstrap_listener.connections)::value_type);
100  	auto composite = std::make_unique<container_info_composite> (name);
101  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "connections", bootstrap_listener.connection_count (), sizeof_element }));
102  	return composite;
103  }
104  nano::transport::tcp_server::tcp_server (std::shared_ptr<nano::transport::socket> socket_a, std::shared_ptr<nano::node> node_a, bool allow_bootstrap_a) :
105  	socket{ std::move (socket_a) },
106  	node{ std::move (node_a) },
107  	allow_bootstrap{ allow_bootstrap_a },
108  	message_deserializer{
109  		std::make_shared<nano::transport::message_deserializer> (node_a->network_params.network, node_a->network.publish_filter, node_a->block_uniquer, node_a->vote_uniquer,
110  		[socket_l = socket] (std::shared_ptr<std::vector<uint8_t>> const & data_a, size_t size_a, std::function<void (boost::system::error_code const &, std::size_t)> callback_a) {
111  			debug_assert (socket_l != nullptr);
112  			socket_l->read_impl (data_a, size_a, callback_a);
113  		})
114  	}
115  {
116  	debug_assert (socket != nullptr);
117  }
118  nano::transport::tcp_server::~tcp_server ()
119  {
120  	auto node = this->node.lock ();
121  	if (!node)
122  	{
123  		return;
124  	}
125  	if (node->config.logging.bulk_pull_logging ())
126  	{
127  		node->logger.try_log ("Exiting incoming TCP/bootstrap server");
128  	}
129  	if (socket->type () == nano::transport::socket::type_t::bootstrap)
130  	{
131  		--node->tcp_listener.bootstrap_count;
132  	}
133  	else if (socket->type () == nano::transport::socket::type_t::realtime)
134  	{
135  		--node->tcp_listener.realtime_count;
136  		auto exisiting_response_channel (node->network.tcp_channels.find_channel (remote_endpoint));
137  		if (exisiting_response_channel != nullptr)
138  		{
139  			exisiting_response_channel->temporary = false;
140  			node->network.tcp_channels.erase (remote_endpoint);
141  		}
142  	}
143  	stop ();
144  	nano::lock_guard<nano::mutex> lock{ node->tcp_listener.mutex };
145  	node->tcp_listener.connections.erase (this);
146  }
147  void nano::transport::tcp_server::start ()
148  {
149  	if (remote_endpoint.port () == 0)
150  	{
151  		remote_endpoint = socket->remote_endpoint ();
152  		debug_assert (remote_endpoint.port () != 0);
153  	}
154  	receive_message ();
155  }
156  void nano::transport::tcp_server::stop ()
157  {
158  	if (!stopped.exchange (true))
159  	{
160  		socket->close ();
161  	}
162  }
163  void nano::transport::tcp_server::receive_message ()
164  {
165  	if (stopped)
166  	{
167  		return;
168  	}
169  	message_deserializer->read ([this_l = shared_from_this ()] (boost::system::error_code ec, std::unique_ptr<nano::message> message) {
170  		auto node = this_l->node.lock ();
171  		if (!node)
172  		{
173  			return;
174  		}
175  		if (ec)
176  		{
177  			node->stats.inc (nano::stat::type::error, nano::transport::message_deserializer::to_stat_detail (this_l->message_deserializer->status));
178  			this_l->stop ();
179  		}
180  		else
181  		{
182  			this_l->received_message (std::move (message));
183  		}
184  	});
185  }
186  void nano::transport::tcp_server::received_message (std::unique_ptr<nano::message> message)
187  {
188  	auto node = this->node.lock ();
189  	if (!node)
190  	{
191  		return;
192  	}
193  	bool should_continue = true;
194  	if (message)
195  	{
196  		should_continue = process_message (std::move (message));
197  	}
198  	else
199  	{
200  		debug_assert (message_deserializer->status != transport::message_deserializer::parse_status::success);
201  		node->stats.inc (nano::stat::type::error, nano::transport::message_deserializer::to_stat_detail (message_deserializer->status));
202  		if (message_deserializer->status == transport::message_deserializer::parse_status::duplicate_publish_message)
203  		{
204  			node->stats.inc (nano::stat::type::filter, nano::stat::detail::duplicate_publish);
205  		}
206  	}
207  	if (should_continue)
208  	{
209  		receive_message ();
210  	}
211  }
212  bool nano::transport::tcp_server::process_message (std::unique_ptr<nano::message> message)
213  {
214  	auto node = this->node.lock ();
215  	if (!node)
216  	{
217  		return false;
218  	}
219  	node->stats.inc (nano::stat::type::tcp_server, nano::to_stat_detail (message->header.type), nano::stat::dir::in);
220  	debug_assert (is_undefined_connection () || is_realtime_connection () || is_bootstrap_connection ());
221  	if (is_undefined_connection ())
222  	{
223  		handshake_message_visitor handshake_visitor{ shared_from_this () };
224  		message->visit (handshake_visitor);
225  		if (handshake_visitor.process)
226  		{
227  			queue_realtime (std::move (message));
228  			return true;
229  		}
230  		else if (handshake_visitor.bootstrap)
231  		{
232  			if (!to_bootstrap_connection ())
233  			{
234  				stop ();
235  				return false;
236  			}
237  		}
238  		else
239  		{
240  			return true;
241  		}
242  	}
243  	else if (is_realtime_connection ())
244  	{
245  		realtime_message_visitor realtime_visitor{ *this };
246  		message->visit (realtime_visitor);
247  		if (realtime_visitor.process)
248  		{
249  			queue_realtime (std::move (message));
250  		}
251  		return true;
252  	}
253  	if (is_bootstrap_connection ())
254  	{
<span onclick='openModal()' class='match'>255  		bootstrap_message_visitor bootstrap_visitor{ shared_from_this () };
256  		message->visit (bootstrap_visitor);
257  		return !bootstrap_visitor.processed; 
</span>258  	}
259  	debug_assert (false);
260  	return true; 
261  }
262  void nano::transport::tcp_server::queue_realtime (std::unique_ptr<nano::message> message)
263  {
264  	auto node = this->node.lock ();
265  	if (!node)
266  	{
267  		return;
268  	}
269  	node->network.tcp_message_manager.put_message (nano::tcp_message_item{ std::move (message), remote_endpoint, remote_node_id, socket });
270  }
271  nano::transport::tcp_server::handshake_message_visitor::handshake_message_visitor (std::shared_ptr<tcp_server> server) :
272  	server{ std::move (server) }
273  {
274  }
275  void nano::transport::tcp_server::handshake_message_visitor::node_id_handshake (nano::node_id_handshake const & message)
276  {
277  	auto node = server->node.lock ();
278  	if (!node)
279  	{
280  		return;
281  	}
282  	if (node->flags.disable_tcp_realtime)
283  	{
284  		if (node->config.logging.network_node_id_handshake_logging ())
285  		{
286  			node->logger.try_log (boost::str (boost::format ("Disabled realtime TCP for handshake %1%") % server->remote_endpoint));
287  		}
288  		server->stop ();
289  		return;
290  	}
291  	if (message.query && server->handshake_query_received)
292  	{
293  		if (node->config.logging.network_node_id_handshake_logging ())
294  		{
295  			node->logger.try_log (boost::str (boost::format ("Detected multiple node_id_handshake query from %1%") % server->remote_endpoint));
296  		}
297  		server->stop ();
298  		return;
299  	}
300  	server->handshake_query_received = true;
301  	if (node->config.logging.network_node_id_handshake_logging ())
302  	{
303  		node->logger.try_log (boost::str (boost::format ("Received node_id_handshake message from %1%") % server->remote_endpoint));
304  	}
305  	if (message.query)
306  	{
307  		server->send_handshake_response (*message.query, message.is_v2 ());
308  	}
309  	if (message.response)
310  	{
311  		if (node->network.verify_handshake_response (*message.response, nano::transport::map_tcp_to_endpoint (server->remote_endpoint)))
312  		{
313  			server->to_realtime_connection (message.response->node_id);
314  		}
315  		else
316  		{
317  			server->stop ();
318  			return;
319  		}
320  	}
321  	process = true;
322  }
323  void nano::transport::tcp_server::send_handshake_response (nano::node_id_handshake::query_payload const & query, bool v2)
324  {
325  	auto node = this->node.lock ();
326  	if (!node)
327  	{
328  		return;
329  	}
330  	auto response = node->network.prepare_handshake_response (query, v2);
331  	auto own_query = node->network.prepare_handshake_query (nano::transport::map_tcp_to_endpoint (remote_endpoint));
332  	nano::node_id_handshake handshake_response{ node->network_params.network, own_query, response };
333  	auto shared_const_buffer = handshake_response.to_shared_const_buffer ();
334  	socket->async_write (shared_const_buffer, [this_l = shared_from_this ()] (boost::system::error_code const & ec, std::size_t size_a) {
335  		auto node = this_l->node.lock ();
336  		if (!node)
337  		{
338  			return;
339  		}
340  		if (ec)
341  		{
342  			if (node->config.logging.network_node_id_handshake_logging ())
343  			{
344  				node->logger.try_log (boost::str (boost::format ("Error sending node_id_handshake to %1%: %2%") % this_l->remote_endpoint % ec.message ()));
345  			}
346  			this_l->stop ();
347  		}
348  		else
349  		{
350  			node->stats.inc (nano::stat::type::message, nano::stat::detail::node_id_handshake, nano::stat::dir::out);
351  		}
352  	});
353  }
354  void nano::transport::tcp_server::handshake_message_visitor::bulk_pull (const nano::bulk_pull & message)
355  {
356  	bootstrap = true;
357  }
358  void nano::transport::tcp_server::handshake_message_visitor::bulk_pull_account (const nano::bulk_pull_account & message)
359  {
360  	bootstrap = true;
361  }
362  void nano::transport::tcp_server::handshake_message_visitor::bulk_push (const nano::bulk_push & message)
363  {
364  	bootstrap = true;
365  }
366  void nano::transport::tcp_server::handshake_message_visitor::frontier_req (const nano::frontier_req & message)
367  {
368  	bootstrap = true;
369  }
370  nano::transport::tcp_server::realtime_message_visitor::realtime_message_visitor (nano::transport::tcp_server & server_a) :
371  	server{ server_a }
372  {
373  }
374  void nano::transport::tcp_server::realtime_message_visitor::keepalive (const nano::keepalive & message)
375  {
376  	process = true;
377  }
378  void nano::transport::tcp_server::realtime_message_visitor::publish (const nano::publish & message)
379  {
380  	process = true;
381  }
382  void nano::transport::tcp_server::realtime_message_visitor::confirm_req (const nano::confirm_req & message)
383  {
384  	process = true;
385  }
386  void nano::transport::tcp_server::realtime_message_visitor::confirm_ack (const nano::confirm_ack & message)
387  {
388  	process = true;
389  }
390  void nano::transport::tcp_server::realtime_message_visitor::frontier_req (const nano::frontier_req & message)
391  {
392  	process = true;
393  }
394  void nano::transport::tcp_server::realtime_message_visitor::telemetry_req (const nano::telemetry_req & message)
395  {
396  	auto node = server.node.lock ();
397  	if (!node)
398  	{
399  		return;
400  	}
401  	if (server.last_telemetry_req + node->network_params.network.telemetry_request_cooldown < std::chrono::steady_clock::now ())
402  	{
403  		server.last_telemetry_req = std::chrono::steady_clock::now ();
404  		process = true;
405  	}
406  	else
407  	{
408  		node->stats.inc (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone);
409  	}
410  }
411  void nano::transport::tcp_server::realtime_message_visitor::telemetry_ack (const nano::telemetry_ack & message)
412  {
413  	process = true;
414  }
415  void nano::transport::tcp_server::realtime_message_visitor::asc_pull_req (const nano::asc_pull_req & message)
416  {
417  	process = true;
418  }
419  void nano::transport::tcp_server::realtime_message_visitor::asc_pull_ack (const nano::asc_pull_ack & message)
420  {
421  	process = true;
422  }
423  nano::transport::tcp_server::bootstrap_message_visitor::bootstrap_message_visitor (std::shared_ptr<tcp_server> server) :
424  	server{ std::move (server) }
425  {
426  }
427  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_pull (const nano::bulk_pull & message)
428  {
429  	auto node = server->node.lock ();
430  	if (!node)
431  	{
432  		return;
433  	}
434  	if (node->flags.disable_bootstrap_bulk_pull_server)
435  	{
436  		return;
437  	}
438  	if (node->config.logging.bulk_pull_logging ())
439  	{
440  		node->logger.try_log (boost::str (boost::format ("Received bulk pull for %1% down to %2%, maximum of %3% from %4%") % message.start.to_string () % message.end.to_string () % message.count % server->remote_endpoint));
441  	}
442  	node->bootstrap_workers.push_task ([server = server, message = message] () {
443  		auto bulk_pull_server = std::make_shared<nano::bulk_pull_server> (server, std::make_unique<nano::bulk_pull> (message));
444  		bulk_pull_server->send_next ();
445  	});
446  	processed = true;
447  }
448  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_pull_account (const nano::bulk_pull_account & message)
449  {
450  	auto node = server->node.lock ();
451  	if (!node)
452  	{
453  		return;
454  	}
455  	if (node->flags.disable_bootstrap_bulk_pull_server)
456  	{
457  		return;
458  	}
459  	if (node->config.logging.bulk_pull_logging ())
460  	{
461  		node->logger.try_log (boost::str (boost::format ("Received bulk pull account for %1% with a minimum amount of %2%") % message.account.to_account () % nano::amount (message.minimum_amount).format_balance (nano::Mxrb_ratio, 10, true)));
462  	}
463  	node->bootstrap_workers.push_task ([server = server, message = message] () {
464  		auto bulk_pull_account_server = std::make_shared<nano::bulk_pull_account_server> (server, std::make_unique<nano::bulk_pull_account> (message));
465  		bulk_pull_account_server->send_frontier ();
466  	});
467  	processed = true;
468  }
469  void nano::transport::tcp_server::bootstrap_message_visitor::bulk_push (const nano::bulk_push &)
470  {
471  	auto node = server->node.lock ();
472  	if (!node)
473  	{
474  		return;
475  	}
476  	node->bootstrap_workers.push_task ([server = server] () {
477  		auto bulk_push_server = std::make_shared<nano::bulk_push_server> (server);
478  		bulk_push_server->throttled_receive ();
479  	});
480  	processed = true;
481  }
482  void nano::transport::tcp_server::bootstrap_message_visitor::frontier_req (const nano::frontier_req & message)
483  {
484  	auto node = server->node.lock ();
485  	if (!node)
486  	{
487  		return;
488  	}
489  	if (node->config.logging.bulk_pull_logging ())
490  	{
491  		node->logger.try_log (boost::str (boost::format ("Received frontier request for %1% with age %2%") % message.start.to_string () % message.age));
492  	}
493  	node->bootstrap_workers.push_task ([server = server, message = message] () {
494  		auto response = std::make_shared<nano::frontier_req_server> (server, std::make_unique<nano::frontier_req> (message));
495  		response->send_next ();
496  	});
497  	processed = true;
498  }
499  void nano::transport::tcp_server::timeout ()
500  {
501  	auto node = this->node.lock ();
502  	if (!node)
503  	{
504  		return;
505  	}
506  	if (socket->has_timed_out ())
507  	{
508  		if (node->config.logging.bulk_pull_logging ())
509  		{
510  			node->logger.try_log ("Closing incoming tcp / bootstrap server by timeout");
511  		}
512  		{
513  			nano::lock_guard<nano::mutex> lock{ node->tcp_listener.mutex };
514  			node->tcp_listener.connections.erase (this);
515  		}
516  		socket->close ();
517  	}
518  }
519  bool nano::transport::tcp_server::to_bootstrap_connection ()
520  {
521  	auto node = this->node.lock ();
522  	if (!node)
523  	{
524  		return false;
525  	}
526  	if (!allow_bootstrap)
527  	{
528  		return false;
529  	}
530  	if (node->flags.disable_bootstrap_listener)
531  	{
532  		return false;
533  	}
534  	if (node->tcp_listener.bootstrap_count >= node->config.bootstrap_connections_max)
535  	{
536  		return false;
537  	}
538  	if (socket->type () != nano::transport::socket::type_t::undefined)
539  	{
540  		return false;
541  	}
542  	++node->tcp_listener.bootstrap_count;
543  	socket->type_set (nano::transport::socket::type_t::bootstrap);
544  	return true;
545  }
546  bool nano::transport::tcp_server::to_realtime_connection (nano::account const & node_id)
547  {
548  	auto node = this->node.lock ();
549  	if (!node)
550  	{
551  		return false;
552  	}
553  	if (socket->type () == nano::transport::socket::type_t::undefined && !node->flags.disable_tcp_realtime)
554  	{
555  		remote_node_id = node_id;
556  		++node->tcp_listener.realtime_count;
557  		socket->type_set (nano::transport::socket::type_t::realtime);
558  		return true;
559  	}
560  	return false;
561  }
562  bool nano::transport::tcp_server::is_undefined_connection () const
563  {
564  	return socket->type () == nano::transport::socket::type_t::undefined;
565  }
566  bool nano::transport::tcp_server::is_bootstrap_connection () const
567  {
568  	return socket->is_bootstrap_connection ();
569  }
570  bool nano::transport::tcp_server::is_realtime_connection () const
571  {
572  	return socket->is_realtime_connection ();
573  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tcp_server.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-tcp_server.cpp</div>
                </div>
                <div class="column column_space"><pre><code>223  		handshake_message_visitor handshake_visitor{ shared_from_this () };
224  		message->visit (handshake_visitor);
225  		if (handshake_visitor.process)
</pre></code></div>
                <div class="column column_space"><pre><code>255  		bootstrap_message_visitor bootstrap_visitor{ shared_from_this () };
256  		message->visit (bootstrap_visitor);
257  		return !bootstrap_visitor.processed; 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    