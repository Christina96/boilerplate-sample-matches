
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webnetobj.h</h3>
            <pre><code>1  class TWebNetClt;
2  class TWebNetTimer: public TTTimer{
3  private:
4    TWebNetClt* WebNetClt;
5    UndefDefaultCopyAssign(TWebNetTimer);
6  public:
7    TWebNetTimer(TWebNetClt* _WebNetClt):
8      TTTimer(1000), WebNetClt(_WebNetClt){}
9    static PTimer New(TWebNetClt* WebNetClt){
10      return new TWebNetTimer(WebNetClt);}
11    void OnTimeOut();
12  };
13  ClassTPE(TWebNetSrv, PWebNetSrv, TNetSrv)
14  private:
15    PNotify Notify;
16    UndefDefaultCopyAssign(TWebNetSrv);
17  public:
18    TWebNetSrv(const int& _PortN, const bool& FixedPortNP=true, const PNotify& _Notify=NULL);
19    virtual ~TWebNetSrv(){}
20    void OnNetObj(const PNetObj& NetObj);
21    void OnNetMem(const PNetObj& NetObj);
22    virtual void OnHttpRq(const int& SockId, const PHttpRq& HttpRq)=0;
23    virtual void OnHttpRqError(const int& SockId, const TStr& MsgStr)=0;
24    void SendHttpResp(const int& SockId, const PHttpResp& HttpResp);
25  };
26  class TWebNetCltV;
27  ClassTPE(TWebNetClt, PWebNetClt, TNetClt)
28  private:
29    typedef TTriple<TInt, PHttpRq, TTm> TFetchIdHttpRqCreateTmTr;
30    typedef TPair<TInt, TTm> TFetchIdCreateTmPr;
31    PNotify Notify;
32    TWebNetCltV* WebNetCltV;
33    bool ConnectedP;
34    TQQueue<TFetchIdHttpRqCreateTmTr> Wait_FetchIdHttpRqCreateTmTrQ;
35    TQQueue<TFetchIdCreateTmPr> Sent_FetchIdCreateTmPrQ;
36    PTimer Timer;
37    TStr ConnIdStr; 
38    UndefDefaultCopyAssign(TWebNetClt);
39  public:
40    TWebNetClt(const TStr& HostNm, const int& PortN,
41     TWebNetCltV* _WebNetCltV, const TStr& _IdStr, const PNotify& _Notify=NULL);
42    static PWebNetClt New(const TStr& HostNm, const int& PortN,
43     TWebNetCltV* WebNetCltV, const TStr& ConnIdStr, const PNotify& Notify=NULL){
44      return PWebNetClt(new TWebNetClt(HostNm, PortN, WebNetCltV, ConnIdStr, Notify));}
45    ~TWebNetClt();
46    TStr GetConnIdStr() const {return ConnIdStr;}
47    static TStr GetConnIdStr(const TStr& HostNm, const int& PortN, const TStr& Client){
48      return TStr::Fmt("%s:%d#%s", HostNm.CStr(), PortN,Client.CStr());}
49    void OnNetObj(const PNetObj& NetObj);
50    void OnNetMem(const PNetObj& NetObj);
51    virtual void OnHttpResp(const PHttpResp& HttpResp);
52    void SendHttpRq(const PHttpRq& HttpRq);
53    void SendWaitQ();
54    void OnCheckTimeOut();
55    bool IsConnected() const {return ConnectedP;}
56    void OnDisconn(const TStr& MsgStr);
57    bool IsWaitQEmpty() const {return Wait_FetchIdHttpRqCreateTmTrQ.Empty();}
58    void PushToWaitQ(const int& FetchId, const PHttpRq& HttpRq){
59      Wait_FetchIdHttpRqCreateTmTrQ.Push(
60       TFetchIdHttpRqCreateTmTr(FetchId, HttpRq, TTm::GetCurUniTm()));}
61    void TopFromWaitQ(int& FetchId, PHttpRq& HttpRq, TTm& CreateTm){
62      FetchId=Wait_FetchIdHttpRqCreateTmTrQ.Top().Val1;
63      HttpRq=Wait_FetchIdHttpRqCreateTmTrQ.Top().Val2;
64      CreateTm=Wait_FetchIdHttpRqCreateTmTrQ.Top().Val3;}
65    void PopFromWaitQ(){
66      Wait_FetchIdHttpRqCreateTmTrQ.Pop();}
67    void PopFromWaitQ(int& FetchId, PHttpRq& HttpRq, TTm& CreateTm){
68      TopFromWaitQ(FetchId, HttpRq, CreateTm);
<span onclick='openModal()' class='match'>69      PopFromWaitQ();}
70    bool IsSentQEmpty() const {return Sent_FetchIdCreateTmPrQ.Empty();}
71    void PushToSentQ(const int& FetchId){
</span>72      Sent_FetchIdCreateTmPrQ.Push(
73       TFetchIdCreateTmPr(FetchId, TTm::GetCurUniTm()));}
74    void TopFromSentQ(int& FetchId, TTm& CreateTm){
75      FetchId=Sent_FetchIdCreateTmPrQ.Top().Val1;
76      CreateTm=Sent_FetchIdCreateTmPrQ.Top().Val2;}
77    void PopFromSentQ(){
78      Sent_FetchIdCreateTmPrQ.Pop();}
79    void PopFromSentQ(int& FetchId, TTm& CreateTm){
80      TopFromSentQ(FetchId, CreateTm);
81      PopFromSentQ();}
82  };
83  ClassTP(TWebNetCltV, PWebNetCltV)
84  private:
85    PNotify Notify;
86    THash<TStr, PWebNetClt> ConnIdStrToWebNetCltH;
87    int LastFetchId;
88    int CltTimeout;
89    int GetNextFetchId(){
90      LastFetchId++; if (LastFetchId<=0){LastFetchId=1;} return LastFetchId;}
91    UndefCopyAssign(TWebNetCltV);
92  public:
93    TWebNetCltV(const PNotify& Notify=NULL);
94    virtual ~TWebNetCltV(){}
95    virtual void OnHttpResp(const int& FetchId, const PHttpResp& HttpResp)=0;
96    virtual void OnHttpRespError(const int& FetchId, const TStr& MsgStr)=0;
97    void SendHttpRq(const TStr& ConnIdStr, const PHttpRq& HttpRq);
98    int FetchUrl(const PUrl& Url, const int& _FetchId=-1, TStr ConnUid=TStr());
99    bool IsGetWebNetClt(const TStr& ConnIdStr, PWebNetClt& WebNetClt) const {
100      return ConnIdStrToWebNetCltH.IsKeyGetDat(ConnIdStr, WebNetClt);}
101    void AddWebNetClt(const TStr& ConnIdStr, const PWebNetClt& WebNetClt){
102      ConnIdStrToWebNetCltH.AddDat(ConnIdStr, WebNetClt);}
103    void DelIfWebNetClt(const TStr& ConnIdStr){
104      ConnIdStrToWebNetCltH.DelIfKey(ConnIdStr);}
105    static const int DfCltTimeout = 10000;
106    int GetCltTimeout() const {return CltTimeout;}
107    void SetCltTimeout(const int &Timeout) {CltTimeout=Timeout;}
108  };
109  class TWebNetProxy;
110  ClassTP(TProxyConn, PProxyConn) 
111  private:
112    int RqSockId;
113    int RqFetchId, RespFetchId;
114  public:
115    TProxyConn(int _RqSockId, int _RqFetchId, int _RespFetchId):
116      RqSockId(_RqSockId), RqFetchId(_RqFetchId), RespFetchId(RespFetchId) {}
117    void SendHttpResp(TWebNetSrv &WebNetSrv, PHttpResp HttpResp);
118    int GetRqSockId() const {return RqSockId;}
119    int GetRqFetchId() const {return RqFetchId;}
120    int GetRespFetchId() const {return RespFetchId;}
121  };
122  ClassTPEE(TWebNetProxy, PWebNetProxy, TWebNetSrv, TWebNetCltV)
123  private:
124    THash<TInt, PProxyConn> RqSockIdToProxyH;
125    THash<TInt, PProxyConn> RespFetchIdToProxyH;
126    TStr DfSrv;
127  public:
128    TWebNetProxy(const int &PortN, const TStr &DefaultServer=TStr()) :
129     TWebNetSrv(PortN, true), DfSrv(DefaultServer) {SetCltTimeout(GetCltTimeout()-2000);}
130    void OnHttpRq(const int& SockId, const PHttpRq& HttpRq);
131    void OnHttpRqError(const int& SockId, const TStr& MsgStr);
132    void OnHttpResp(const int& FId, const PHttpResp& HttpResp);
133    void OnHttpRespError(const int& FId, const TStr& _MsgStr);
134  };
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_internal.h</h3>
            <pre><code>1  #ifndef ABSL_STATUS_INTERNAL_STATUSOR_INTERNAL_H_
2  #define ABSL_STATUS_INTERNAL_STATUSOR_INTERNAL_H_
3  #include <type_traits>
4  #include <utility>
5  #include "absl/base/attributes.h"
6  #include "absl/meta/type_traits.h"
7  #include "absl/status/status.h"
8  #include "absl/utility/utility.h"
9  namespace absl {
10  ABSL_NAMESPACE_BEGIN
11  template <typename T>
12  class ABSL_MUST_USE_RESULT StatusOr;
13  namespace internal_statusor {
14  template <typename T, typename U, typename = void>
15  struct HasConversionOperatorToStatusOr : std::false_type {};
16  template <typename T, typename U>
17  void test(char (*)[sizeof(std::declval<U>().operator absl::StatusOr<T>())]);
18  template <typename T, typename U>
19  struct HasConversionOperatorToStatusOr<T, U, decltype(test<T, U>(0))>
20      : std::true_type {};
21  template <typename T, typename U>
22  using IsConstructibleOrConvertibleFromStatusOr =
23      absl::disjunction<std::is_constructible<T, StatusOr<U>&>,
24                        std::is_constructible<T, const StatusOr<U>&>,
25                        std::is_constructible<T, StatusOr<U>&&>,
26                        std::is_constructible<T, const StatusOr<U>&&>,
27                        std::is_convertible<StatusOr<U>&, T>,
28                        std::is_convertible<const StatusOr<U>&, T>,
29                        std::is_convertible<StatusOr<U>&&, T>,
30                        std::is_convertible<const StatusOr<U>&&, T>>;
31  template <typename T, typename U>
32  using IsConstructibleOrConvertibleOrAssignableFromStatusOr =
33      absl::disjunction<IsConstructibleOrConvertibleFromStatusOr<T, U>,
34                        std::is_assignable<T&, StatusOr<U>&>,
35                        std::is_assignable<T&, const StatusOr<U>&>,
36                        std::is_assignable<T&, StatusOr<U>&&>,
37                        std::is_assignable<T&, const StatusOr<U>&&>>;
38  template <typename T, typename U>
39  struct IsDirectInitializationAmbiguous
40      : public absl::conditional_t<
41            std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,
42            IsDirectInitializationAmbiguous<T, absl::remove_cvref_t<U>>> {};
43  template <typename T, typename V>
44  struct IsDirectInitializationAmbiguous<T, absl::StatusOr<V>>
45      : public IsConstructibleOrConvertibleFromStatusOr<T, V> {};
46  template <typename T, typename U>
47  using IsDirectInitializationValid = absl::disjunction<
48      std::is_same<T, absl::remove_cvref_t<U>>,
49      absl::negation<absl::disjunction<
50          std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,
51          std::is_same<absl::Status, absl::remove_cvref_t<U>>,
52          std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,
53          IsDirectInitializationAmbiguous<T, U>>>>;
54  template <typename T, typename U>
55  struct IsForwardingAssignmentAmbiguous
56      : public absl::conditional_t<
57            std::is_same<absl::remove_cvref_t<U>, U>::value, std::false_type,
58            IsForwardingAssignmentAmbiguous<T, absl::remove_cvref_t<U>>> {};
59  template <typename T, typename U>
60  struct IsForwardingAssignmentAmbiguous<T, absl::StatusOr<U>>
61      : public IsConstructibleOrConvertibleOrAssignableFromStatusOr<T, U> {};
62  template <typename T, typename U>
63  using IsForwardingAssignmentValid = absl::disjunction<
64      std::is_same<T, absl::remove_cvref_t<U>>,
65      absl::negation<absl::disjunction<
66          std::is_same<absl::StatusOr<T>, absl::remove_cvref_t<U>>,
67          std::is_same<absl::Status, absl::remove_cvref_t<U>>,
68          std::is_same<absl::in_place_t, absl::remove_cvref_t<U>>,
69          IsForwardingAssignmentAmbiguous<T, U>>>>;
70  class Helper {
71   public:
72    static void HandleInvalidStatusCtorArg(Status*);
73    ABSL_ATTRIBUTE_NORETURN static void Crash(const absl::Status& status);
74  };
75  template <typename T, typename... Args>
76  ABSL_ATTRIBUTE_NONNULL(1) void PlacementNew(void* p, Args&&... args) {
77    new (p) T(std::forward<Args>(args)...);
78  }
79  template <typename T>
80  class StatusOrData {
81    template <typename U>
82    friend class StatusOrData;
83   public:
84    StatusOrData() = delete;
85    StatusOrData(const StatusOrData& other) {
86      if (other.ok()) {
87        MakeValue(other.data_);
88        MakeStatus();
89      } else {
90        MakeStatus(other.status_);
91      }
92    }
93    StatusOrData(StatusOrData&& other) noexcept {
94      if (other.ok()) {
95        MakeValue(std::move(other.data_));
96        MakeStatus();
97      } else {
98        MakeStatus(std::move(other.status_));
99      }
100    }
101    template <typename U>
102    explicit StatusOrData(const StatusOrData<U>& other) {
103      if (other.ok()) {
104        MakeValue(other.data_);
105        MakeStatus();
106      } else {
107        MakeStatus(other.status_);
108      }
109    }
110    template <typename U>
111    explicit StatusOrData(StatusOrData<U>&& other) {
112      if (other.ok()) {
113        MakeValue(std::move(other.data_));
114        MakeStatus();
115      } else {
116        MakeStatus(std::move(other.status_));
117      }
118    }
119    template <typename... Args>
120    explicit StatusOrData(absl::in_place_t, Args&&... args)
121        : data_(std::forward<Args>(args)...) {
122      MakeStatus();
123    }
124    explicit StatusOrData(const T& value) : data_(value) {
125      MakeStatus();
126    }
127    explicit StatusOrData(T&& value) : data_(std::move(value)) {
128      MakeStatus();
129    }
130    template <typename U,
131              absl::enable_if_t<std::is_constructible<absl::Status, U&&>::value,
132                                int> = 0>
133    explicit StatusOrData(U&& v) : status_(std::forward<U>(v)) {
134      EnsureNotOk();
135    }
136    StatusOrData& operator=(const StatusOrData& other) {
137      if (this == &other) return *this;
138      if (other.ok())
139        Assign(other.data_);
140      else
141        AssignStatus(other.status_);
142      return *this;
143    }
144    StatusOrData& operator=(StatusOrData&& other) {
145      if (this == &other) return *this;
146      if (other.ok())
147        Assign(std::move(other.data_));
148      else
149        AssignStatus(std::move(other.status_));
150      return *this;
151    }
152    ~StatusOrData() {
153      if (ok()) {
154        status_.~Status();
155        data_.~T();
156      } else {
157        status_.~Status();
158      }
159    }
160    template <typename U>
161    void Assign(U&& value) {
162      if (ok()) {
163        data_ = std::forward<U>(value);
164      } else {
165        MakeValue(std::forward<U>(value));
166        status_ = OkStatus();
167      }
168    }
169    template <typename U>
170    void AssignStatus(U&& v) {
171      Clear();
172      status_ = static_cast<absl::Status>(std::forward<U>(v));
<span onclick='openModal()' class='match'>173      EnsureNotOk();
174    }
175    bool ok() const { return status_.ok(); }
176   protected:
</span>177    union {
178      Status status_;
179    };
180    struct Dummy {};
181    union {
182      Dummy dummy_;
183      T data_;
184    };
185    void Clear() {
186      if (ok()) data_.~T();
187    }
188    void EnsureOk() const {
189      if (ABSL_PREDICT_FALSE(!ok())) Helper::Crash(status_);
190    }
191    void EnsureNotOk() {
192      if (ABSL_PREDICT_FALSE(ok())) Helper::HandleInvalidStatusCtorArg(&status_);
193    }
194    template <typename... Arg>
195    void MakeValue(Arg&&... arg) {
196      internal_statusor::PlacementNew<T>(&dummy_, std::forward<Arg>(arg)...);
197    }
198    template <typename... Args>
199    void MakeStatus(Args&&... args) {
200      internal_statusor::PlacementNew<Status>(&status_,
201                                              std::forward<Args>(args)...);
202    }
203  };
204  template <typename T, bool = std::is_copy_constructible<T>::value>
205  struct CopyCtorBase {
206    CopyCtorBase() = default;
207    CopyCtorBase(const CopyCtorBase&) = default;
208    CopyCtorBase(CopyCtorBase&&) = default;
209    CopyCtorBase& operator=(const CopyCtorBase&) = default;
210    CopyCtorBase& operator=(CopyCtorBase&&) = default;
211  };
212  template <typename T>
213  struct CopyCtorBase<T, false> {
214    CopyCtorBase() = default;
215    CopyCtorBase(const CopyCtorBase&) = delete;
216    CopyCtorBase(CopyCtorBase&&) = default;
217    CopyCtorBase& operator=(const CopyCtorBase&) = default;
218    CopyCtorBase& operator=(CopyCtorBase&&) = default;
219  };
220  template <typename T, bool = std::is_move_constructible<T>::value>
221  struct MoveCtorBase {
222    MoveCtorBase() = default;
223    MoveCtorBase(const MoveCtorBase&) = default;
224    MoveCtorBase(MoveCtorBase&&) = default;
225    MoveCtorBase& operator=(const MoveCtorBase&) = default;
226    MoveCtorBase& operator=(MoveCtorBase&&) = default;
227  };
228  template <typename T>
229  struct MoveCtorBase<T, false> {
230    MoveCtorBase() = default;
231    MoveCtorBase(const MoveCtorBase&) = default;
232    MoveCtorBase(MoveCtorBase&&) = delete;
233    MoveCtorBase& operator=(const MoveCtorBase&) = default;
234    MoveCtorBase& operator=(MoveCtorBase&&) = default;
235  };
236  template <typename T, bool = std::is_copy_constructible<T>::value&&
237                            std::is_copy_assignable<T>::value>
238  struct CopyAssignBase {
239    CopyAssignBase() = default;
240    CopyAssignBase(const CopyAssignBase&) = default;
241    CopyAssignBase(CopyAssignBase&&) = default;
242    CopyAssignBase& operator=(const CopyAssignBase&) = default;
243    CopyAssignBase& operator=(CopyAssignBase&&) = default;
244  };
245  template <typename T>
246  struct CopyAssignBase<T, false> {
247    CopyAssignBase() = default;
248    CopyAssignBase(const CopyAssignBase&) = default;
249    CopyAssignBase(CopyAssignBase&&) = default;
250    CopyAssignBase& operator=(const CopyAssignBase&) = delete;
251    CopyAssignBase& operator=(CopyAssignBase&&) = default;
252  };
253  template <typename T, bool = std::is_move_constructible<T>::value&&
254                            std::is_move_assignable<T>::value>
255  struct MoveAssignBase {
256    MoveAssignBase() = default;
257    MoveAssignBase(const MoveAssignBase&) = default;
258    MoveAssignBase(MoveAssignBase&&) = default;
259    MoveAssignBase& operator=(const MoveAssignBase&) = default;
260    MoveAssignBase& operator=(MoveAssignBase&&) = default;
261  };
262  template <typename T>
263  struct MoveAssignBase<T, false> {
264    MoveAssignBase() = default;
265    MoveAssignBase(const MoveAssignBase&) = default;
266    MoveAssignBase(MoveAssignBase&&) = default;
267    MoveAssignBase& operator=(const MoveAssignBase&) = default;
268    MoveAssignBase& operator=(MoveAssignBase&&) = delete;
269  };
270  ABSL_ATTRIBUTE_NORETURN void ThrowBadStatusOrAccess(absl::Status status);
271  }  
272  ABSL_NAMESPACE_END
273  }  
274  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webnetobj.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-statusor_internal.h</div>
                </div>
                <div class="column column_space"><pre><code>69      PopFromWaitQ();}
70    bool IsSentQEmpty() const {return Sent_FetchIdCreateTmPrQ.Empty();}
71    void PushToSentQ(const int& FetchId){
</pre></code></div>
                <div class="column column_space"><pre><code>173      EnsureNotOk();
174    }
175    bool ok() const { return status_.ok(); }
176   protected:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    