
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.564007824386003%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-BabyGrid.cpp</h3>
            <pre><code>1  #include "BabyGrid.h"
2  #include "Parameters.h"
3  #define MAX_GRIDS 20
4  #define MAX_ROWS 32000
5  #define MAX_COLS 256
6  HFONT hfontbody,hfontheader,hfonttitle;
7  HFONT holdfont;
8  struct _gridhandlestruct
9  	{
10          HMENU gridmenu;
11  		HWND hlist1;
12  		TCHAR protect[2];
13          TCHAR title[305];
14          TCHAR editstring[305];
15          TCHAR editstringdisplay[305];
16  		int rows;
17  		int cols;
18  		int gridwidth;
19  		int gridheight;
20  		int homerow;
21  		int homecol;
22  		int rowheight;
23  		int leftvisiblecol;
24  		int rightvisiblecol;
25  		int topvisiblerow;
26  		int bottomvisiblerow;
27  		int headerrowheight;
28  		int cursorrow;
29  		int cursorcol;
30          int ownerdrawitem;
31          int visiblecolumns;
32          int titleheight;
33          int fontascentheight;
34  		COLORREF cursorcolor;
35  		COLORREF protectcolor;
36  		COLORREF unprotectcolor;
37  		COLORREF textcolor;
38  		COLORREF highlightcolor;
39  		COLORREF highlightcolorNoFocus;
40  		COLORREF highlightcolorProtect;
41  		COLORREF highlightcolorProtectNoFocus;
42  		COLORREF gridlinecolor;
43          COLORREF highlighttextcolor;
44          COLORREF backgroundcolor;
45          COLORREF titletextcolor;
46          COLORREF titlecolor;
47          COLORREF titlegridlinecolor;
48  		BOOL DRAWHIGHLIGHT;
49          BOOL ADVANCEROW;
50          BOOL CURRENTCELLPROTECTED;
51  		BOOL GRIDHASFOCUS;
52          BOOL AUTOROW;
53          RECT activecellrect;
54          HFONT hfont;
55          HFONT hcolumnheadingfont;
56          HFONT htitlefont;
57  		BOOL ROWSNUMBERED;
58  		BOOL COLUMNSNUMBERED;
59          BOOL EDITABLE;
60          BOOL EDITING;
61          BOOL EXTENDLASTCOLUMN;
62          BOOL HSCROLL;
63          BOOL VSCROLL;
64          BOOL SHOWINTEGRALROWS;
65          BOOL ELLIPSIS;
66          BOOL COLAUTOWIDTH;
67          BOOL COLUMNSIZING;
68          BOOL ALLOWCOLUMNRESIZING;
69          int columntoresize;
70          int columntoresizeinitsize;
71          int columntoresizeinitx;
72          int cursortype;
73  		int columnwidths[MAX_COLS+1];
74          BOOL REMEMBERINTEGRALROWS;
75  		BOOL INITIALCONTENT;
76      } BGHS[MAX_GRIDS];
77  _BGCELL BGcell,*LPBGcell;
78  int BG_GridIndex;
79  int FindResult;
80  TCHAR data[1000];
81  CREATESTRUCT cs,*lpcs;
82  int         AddGrid(HMENU);
83  int         FindGrid(HMENU);
84  void		ShowVscroll(HWND,int);
85  void		ShowHscroll(HWND,int);
86  int         BinarySearchListBox(HWND,TCHAR*);
87  void        DisplayEditString(HWND ,int , const TCHAR*);
88  int         CountGrids();
89  int HomeColumnNthVisible(int SI)
90      {
91       int j,hc,count;
92       count=0;
93       hc=BGHS[SI].homecol;
94       for(j=1;j<=hc;++j)
95           {
96            if(BGHS[SI].columnwidths[j]>0)
97                {
98                 ++count;
99                }
100           }
101       return count;
102      }
103  void RefreshGrid(HWND hWnd)
104  	{
105  	 RECT rect;
106       int SI;
107  	 GetClientRect(hWnd,&rect);
108  	 InvalidateRect(hWnd,&rect,FALSE);
109  	 SI=FindGrid(GetMenu(hWnd));
110       if(BGHS[SI].EDITING)
111           {
112            DisplayEditString(hWnd, SI, TEXT(""));
113           }
114  	}
115  int GetNextColWithWidth(int SI, int startcol, int direction)
116      {
117       int j;
118       int ReturnValue;
119       j=startcol;
120       if(direction == 1){j++;}
121       if(direction != 1){j--;}
122       while((j>0)&&(j<=BGHS[SI].cols)&&(BGHS[SI].columnwidths[j] == 0))
123           {
124           if(direction == 1){j++;}
125           if(direction != 1){j--;}
126           }
127       if((j<=BGHS[SI].cols)&&(BGHS[SI].columnwidths[j] > 0))
128           {
129            ReturnValue = j;
130           }
131       else
132           {
133            ReturnValue = 0;
134           }
135       return ReturnValue;
136      }
137  int GetRowOfMouse(int SI,int y)
138  	{
139  	 int ReturnValue;
140  	 if(y<=(BGHS[SI].titleheight))
141  		 {
142  		  return -1;
143  		 }
144  	 if((y>=BGHS[SI].titleheight)&&(y<=BGHS[SI].headerrowheight + BGHS[SI].titleheight))
145  		 {
146  		  return 0;
147  		 }
148  	 y=y-(BGHS[SI].headerrowheight + BGHS[SI].titleheight);
149  	 y=y/BGHS[SI].rowheight;
150  	 ReturnValue = BGHS[SI].homerow + y;
151  	 if(ReturnValue > BGHS[SI].rows){ReturnValue = -1;}
152  	 return ReturnValue;
153  	}
154  int GetColOfMouse(int SI,int x)
155  	{
156  	 int ReturnValue;
157  	 int j;
158  	 if(x<=BGHS[SI].columnwidths[0])
159  		 {
160  		  return 0;
161  		 }
162  	 x-=BGHS[SI].columnwidths[0];
163  	 j=BGHS[SI].homecol;
164  	 while(x>0)
165  		 {
166  		  x-=BGHS[SI].columnwidths[j];
167  		  j++;
168  		 }
169  	 j--;
170  	 ReturnValue = j;
171       if(BGHS[SI].EXTENDLASTCOLUMN)
172           {
173  	      if(j>BGHS[SI].cols){ReturnValue = BGHS[SI].cols;}
174           }
175       else
176           {
177            if(j>BGHS[SI].cols){ReturnValue = -1;}
178           }
179  	 return ReturnValue;
180  	}
181  BOOL OutOfRange(_BGCELL *cell)
182      {
183        if((cell->row > MAX_ROWS)||(cell->col > MAX_COLS))
184            {return TRUE;}
185        else
186            {return FALSE;}
187      }
188  void SetCell(_BGCELL *cell,int row, int col)
189  	{
190  	 cell->row = row;
191  	 cell->col = col;
192  	}
193  void CalcVisibleCellBoundaries(int SelfIndex)
194  {
195   int gridx,gridy;
196   int j;
197   gridx=BGHS[SelfIndex].gridwidth;
198   gridy=BGHS[SelfIndex].gridheight;
199   j=	BGHS[SelfIndex].homecol;
200   BGHS[SelfIndex].leftvisiblecol = BGHS[SelfIndex].homecol;
201   BGHS[SelfIndex].topvisiblerow = BGHS[SelfIndex].homerow;
202   gridx = gridx - BGHS[SelfIndex].columnwidths[0];
203   do
204   {
205    gridx = gridx - BGHS[SelfIndex].columnwidths[j];
206    j++;
207   }while ((gridx >= 0)&&(j<BGHS[SelfIndex].cols));
208   if(j>BGHS[SelfIndex].cols){j=BGHS[SelfIndex].cols;}
209   BGHS[SelfIndex].rightvisiblecol = j;
210   gridy = gridy - BGHS[SelfIndex].headerrowheight;
211   j=	BGHS[SelfIndex].homerow;
212   do
213   {
214    gridy = gridy - BGHS[SelfIndex].rowheight;
215    j++;
216   }while ((gridy > 0)&&(j<BGHS[SelfIndex].rows));
217   if(j>BGHS[SelfIndex].rows){j=BGHS[SelfIndex].rows;}
218   BGHS[SelfIndex].bottomvisiblerow = j;
219  }
220  RECT GetCellRect(HWND hWnd,int SI, int r, int c)
221  	{
222  	 RECT rect;
223  	 int offset;
224  	 int j;
225  	   offset=BGHS[SI].columnwidths[0];
226  	   for(j=BGHS[SI].homecol;j<c;j++)
227  		   {
228  			offset += BGHS[SI].columnwidths[j];
229  		   }
230  	   rect.left = offset;
231  	   rect.right = offset + BGHS[SI].columnwidths[c];
232      if(BGHS[SI].EXTENDLASTCOLUMN)
233          {
234  	        if(!GetNextColWithWidth(SI,c,1))
235  		        {
236  		         RECT trect;
237  		         int temp;
238  		         GetClientRect(hWnd,&trect);
239  		         temp = (offset +(trect.right - rect.left))-rect.left;
240  		         if(temp > BGHS[SI].columnwidths[c])
241  			         {
242  		              rect.right = offset + (trect.right - rect.left);
243  			         }
244  		        }
245          }
246  	   offset = BGHS[SI].headerrowheight+BGHS[SI].titleheight;
247  	   for(j=BGHS[SI].homerow;j<r;j++)
248  		   {
249  			offset += BGHS[SI].rowheight;
250  		   }
251  	   rect.top = offset;
252  	   rect.bottom = offset + BGHS[SI].rowheight;
253  	   return rect;
254  	}
255  void DisplayTitle(HWND hWnd,int SI,HFONT hfont)
256      {
257       RECT rect;
258       HDC gdc;
259       HFONT holdfont;
260       GetClientRect(hWnd,&rect);
261       gdc=GetDC(hWnd);
262       SetBkMode(gdc,TRANSPARENT);
263       holdfont=(HFONT)SelectObject(gdc,hfont);
264       rect.bottom = BGHS[SI].titleheight;
265  	 DrawEdge(gdc,&rect,EDGE_ETCHED,BF_MIDDLE|BF_RECT|BF_ADJUST);
266  	 DrawTextEx(gdc,BGHS[SI].title,-1,&rect,DT_END_ELLIPSIS|DT_CENTER|DT_WORDBREAK|DT_NOPREFIX,NULL);
267       SelectObject(gdc,holdfont);
268       ReleaseDC(hWnd,gdc);
269      }
270  const size_t bufferLen = 1000;
271  void DisplayColumn(HWND hWnd,int SI,int c,int offset,HFONT hfont,HFONT hcolumnheadingfont)
272  {
273  	HDC gdc;
274  	RECT rect,rectsave;
275      HFONT holdfont;
276  	int r;
277  	TCHAR buffer[bufferLen];
278  	int iDataType,iProtection,iProperty;
279  	if(BGHS[SI].columnwidths[c]==0){return;}
280  	 gdc=GetDC(hWnd);
281  	 SetBkMode(gdc,TRANSPARENT);
282       ShowHscroll(hWnd,SI);
283  	 ShowVscroll(hWnd,SI);
284      holdfont = (HFONT)SelectObject(gdc,hcolumnheadingfont);
285  	SetTextColor(gdc,BGHS[SI].titletextcolor);
286  	r=0;
287  	rect.left = offset + 0;
288  	rect.top = BGHS[SI].titleheight;
289  	rect.right = BGHS[SI].columnwidths[c] + offset;
290  	rect.bottom = BGHS[SI].headerrowheight + BGHS[SI].titleheight;
291      if(BGHS[SI].EXTENDLASTCOLUMN)
292          {
293  	        if(!GetNextColWithWidth(SI,c,1))
294  		        {
295  		         RECT trect;
296  		         GetClientRect(hWnd,&trect);
297  		         rect.right = offset + (trect.right - rect.left);
298  		        }
299          }
300      else
301          {
302           if(!GetNextColWithWidth(SI,c,1))
303               {
304  		         RECT trect;
305                   HBRUSH holdbrush;
306                   HPEN holdpen;
307  		         GetClientRect(hWnd,&trect);
308                   trect.left=offset+(rect.right-rect.left);
309                   holdbrush=(HBRUSH)SelectObject(gdc,GetStockObject(GRAY_BRUSH));
310                   holdpen=(HPEN)SelectObject(gdc,GetStockObject(NULL_PEN));
311                   Rectangle(gdc,trect.left,trect.top+BGHS[SI].titleheight,trect.right+1,trect.bottom+1);
312  		         SelectObject(gdc,holdbrush);
313                   SelectObject(gdc,holdpen);
314               }
315          }
316  	 SetCell(&BGcell,r,c);
317  	 wcscpy_s(buffer, TEXT(""));
318  	 if(BGHS[SI].COLUMNSNUMBERED)
319  	 {
320  	  if(c>0)
321  	  {
322  	   int high,low;
323  	   high = ((c-1)/26);
324  	   low = c % 26;
325  	   if(high == 0){high = 32;}else{high+=64;}
326  	   if(low == 0){low=26;}
327  	   low += 64;
328  	   wsprintf(buffer, TEXT("%c%c"), high,low);
329  	  }
330  	 }
331  	 else
332  		 SendMessage(hWnd, BGM_GETCELLDATA, reinterpret_cast<WPARAM>(&BGcell), reinterpret_cast<LPARAM>(buffer));
333  	 rectsave=rect;
334       HBRUSH hbrushtitle, holdbrushtitle;
335       HPEN hpentitle, holdpentitle;
336       hbrushtitle = CreateSolidBrush(BGHS[SI].titlecolor);
337       hpentitle = CreatePen(PS_SOLID, 1, BGHS[SI].titlegridlinecolor);
338       holdbrushtitle = (HBRUSH)SelectObject(gdc, hbrushtitle);
339       holdpentitle = (HPEN)SelectObject(gdc, hpentitle);
340       Rectangle(gdc, rect.left, rect.top, rect.right, rect.bottom);
341       SelectObject(gdc, holdbrushtitle);
342       SelectObject(gdc, holdpentitle);
343       DeleteObject(hbrushtitle);
344       DeleteObject(hpentitle);
345  	 DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_CENTER|DT_WORDBREAK|DT_NOPREFIX,NULL);
346  	 rect=rectsave;
347  	 r=BGHS[SI].topvisiblerow;
348       SelectObject(gdc,hfont);
349  	 while(r<=BGHS[SI].bottomvisiblerow)
350  	 {
351               if((r==BGHS[SI].cursorrow)&&(c>0)&&(BGHS[SI].DRAWHIGHLIGHT))
352                   {
353                    if(BGHS[SI].GRIDHASFOCUS)
354                        {
355                         SetTextColor(gdc,BGHS[SI].highlighttextcolor);
356                        }
357                    else
358                        {
359                         SetTextColor(gdc,BGHS[SI].textcolor);
360                        }
361                   }
362               else
363                   {
364                    SetTextColor(gdc,BGHS[SI].textcolor);
365                   }
366  		 rect.top = rect.bottom;
367  		 rect.bottom = rect.top + BGHS[SI].rowheight;
368  		 rectsave=rect;
369  		 SetCell(&BGcell,r,c);
370  		 wcscpy_s(buffer, TEXT(""));
371  		 if((c==0)&&(BGHS[SI].ROWSNUMBERED))
372  		 {
373  		  wsprintf(buffer, TEXT("%d"), r);
374  		  iProperty = 2 << 4; 
375  		 }
376  		 else
377  		  iProperty = static_cast<int32_t>(SendMessage(hWnd, BGM_GETCELLDATA, reinterpret_cast<WPARAM>(&BGcell), reinterpret_cast<LPARAM>(buffer)));
378  		 if(c==0)
379  		 {
380  			 SetTextColor(gdc, BGHS[SI].titletextcolor);
381  			 HBRUSH hbrush, holdbrush;
382  			 HPEN hpen, holdpen;
383  			 hbrush = CreateSolidBrush(BGHS[SI].titlecolor);
384  			 hpen = CreatePen(PS_SOLID, 1, BGHS[SI].titlegridlinecolor);
385  			 holdbrush = (HBRUSH)SelectObject(gdc, hbrush);
386  			 holdpen = (HPEN)SelectObject(gdc, hpen);
387  			 Rectangle(gdc, rect.left, rect.top, rect.right, rect.bottom);
388  			 SelectObject(gdc, holdbrush);
389  			 SelectObject(gdc, holdpen);
390  			 DeleteObject(hbrush);
391  			 DeleteObject(hpen);
392  		 }
393  		 else
394  		 {
395  		  HBRUSH hbrush,holdbrush;
396  		  HPEN hpen,holdpen;
397  		  iProtection = iProperty & 0xf;
398  		  if(BGHS[SI].DRAWHIGHLIGHT)
399  			  {
400  			   if(r==BGHS[SI].cursorrow)
401  				   {
402  				    if(BGHS[SI].GRIDHASFOCUS)
403  						{
404  							if(iProtection == 1)
405  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorProtect);
406  							else
407  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolor);
408  						}
409  					else
410  						{
411  							if(iProtection == 1)
412  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorProtectNoFocus);
413  							else
414  								hbrush=CreateSolidBrush(BGHS[SI].highlightcolorNoFocus);
415  						}
416  				   }
417  			   else
418  				  {
419  					  if(iProtection == 1)
420  					  {
421  						hbrush=CreateSolidBrush(BGHS[SI].protectcolor);
422  					  }
423  					  else
424  					  {
425  						hbrush=CreateSolidBrush(BGHS[SI].unprotectcolor);
426  					  }
427  				  }
428  			  }
429  		  else
430  			  {
431  					  if(iProtection == 1)
432  					  {
433  						hbrush=CreateSolidBrush(BGHS[SI].protectcolor);
434  					  }
435  					  else
436  					  {
437  						hbrush=CreateSolidBrush(BGHS[SI].unprotectcolor);
438  					  }
439  			  }
440  		  hpen=CreatePen(PS_SOLID,1,BGHS[SI].gridlinecolor);
441  		  holdbrush=(HBRUSH)SelectObject(gdc,hbrush);
442  		  holdpen=(HPEN)SelectObject(gdc,hpen);
443  		  Rectangle(gdc,rect.left,rect.top,rect.right,rect.bottom);
444  		  SelectObject(gdc,holdbrush);
445  		  SelectObject(gdc,holdpen);
446  		  DeleteObject(hbrush);
447  		  DeleteObject(hpen);
448  		 }
449  		 rect.right -= 2;
450  		 rect.left += 2;
451  		 iDataType = iProperty >> 4 & 0xf;
452           if((iDataType < 1)||(iDataType > 5))
453               {
454                iDataType = 1;
455               }
456  		 if(iDataType == 1)
457  		 {
458            if(BGHS[SI].ELLIPSIS)
459                {
460                DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_LEFT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX,NULL);
461                }
462            else
463                {
464  			   DrawTextEx(gdc,buffer,-1,&rect,DT_LEFT|DT_WORDBREAK|DT_EDITCONTROL|DT_NOPREFIX,NULL);
465                }
466  		 }
467  		 if(iDataType == 2)
468  		 {
469  		  DrawTextEx(gdc,buffer,-1,&rect,DT_END_ELLIPSIS|DT_RIGHT|DT_VCENTER|DT_SINGLELINE|DT_NOPREFIX,NULL);
470  		 }
471  		 if(iDataType == 3)
472  		 {
473  		  int k,excess;
474  		  k=2;
475  		  rect.top +=k;
476  		  rect.bottom -=k;
477  		  rect.left +=0;
478  		  rect.right -=0;
479            if((rect.bottom - rect.top)>24)
480            {
481                 excess=(rect.bottom - rect.top)-16;
482                 rect.top += excess / 2;
483                 rect.bottom -= excess / 2;
484            }
485  	      DrawFrameControl(gdc,&rect,DFC_BUTTON,DFCS_BUTTONCHECK|DFCS_CHECKED);
486  		 }
487  		 if(iDataType == 4)
488  		 {
489  		  int k,excess;
490  		  k=2;
491  		  rect.top +=k;
492  		  rect.bottom -=k;
493  		  rect.left +=0;
494  		  rect.right -=0;
495            if((rect.bottom - rect.top)>24)
496            {
497                 excess=(rect.bottom - rect.top)-16;
498                 rect.top += excess / 2;
499                 rect.bottom -= excess / 2;
500            }
501  	      DrawFrameControl(gdc,&rect,DFC_BUTTON,DFCS_BUTTONCHECK);
502  		 }
503  		 if(iDataType == 5) 
504  			 {
505  			   WPARAM wParam;
506                 buffer[0]=0x20;
507                 BGHS[SI].ownerdrawitem = _wtoi(buffer);
508  			   wParam=MAKEWPARAM(::GetMenu(hWnd),BGN_OWNERDRAW);
509  			   SendMessage(GetParent(hWnd), WM_COMMAND, wParam, reinterpret_cast<LPARAM>(&rect));
510  			 }
511           if(BGHS[SI].EDITING)
512               {
513                DisplayEditString(hWnd, SI, TEXT(""));
514               }
515           rect=rectsave;
516  	     r++;
517  	 }
518               {
519  		         RECT trect;
520                   HBRUSH holdbrush, hbrush;
521                   HPEN holdpen;
522  		         GetClientRect(hWnd,&trect);
523                   trect.top = rect.bottom;
524                   trect.left = rect.left;
525                   trect.right = rect.right;
526                   hbrush = CreateSolidBrush(BGHS[SI].backgroundcolor);
527                   holdbrush=(HBRUSH)SelectObject(gdc, hbrush);
528                   holdpen=(HPEN)SelectObject(gdc,GetStockObject(NULL_PEN));
529                   Rectangle(gdc,trect.left,trect.top,trect.right+1,trect.bottom+1);
530  		         SelectObject(gdc,holdbrush);
531                   SelectObject(gdc,holdpen);
532                   DeleteObject(hbrush);
533               }
534       SelectObject(gdc,holdfont);
535       DeleteObject(holdfont);
536  	 ReleaseDC(hWnd,gdc);
537  }
538  void DrawCursor(HWND hWnd,int SI)
539  	{
540  	   RECT rect,rectwhole;
541  	   HDC gdc;
542  	   HPEN hpen,holdpen;
543  	   int rop;
544         if(BGHS[SI].rows == 0){return;}
545  	   GetClientRect(hWnd,&rect);
546  	   if(BGHS[SI].cursorrow < BGHS[SI].homerow){return;}
547         if(BGHS[SI].cursorcol < BGHS[SI].homecol){return;}
548  	   rect = GetCellRect(hWnd,SI,BGHS[SI].cursorrow,BGHS[SI].cursorcol);
549  	   rectwhole=rect;
550  	   gdc=GetDC(hWnd);
551         BGHS[SI].activecellrect = rect;
552  	   rop=GetROP2(gdc);
553  	   SetROP2(gdc,R2_XORPEN);
554  	   SelectObject(gdc,(HBRUSH)GetStockObject(NULL_BRUSH));
555  	   hpen=CreatePen(PS_SOLID,3,BGHS[SI].cursorcolor);  
556  	   holdpen=(HPEN)SelectObject(gdc,hpen);
557  	   Rectangle(gdc,rect.left,rect.top,rect.right,rect.bottom);
558  	   SelectObject(gdc,holdpen);
559  	   DeleteObject(hpen);
560  	   SetROP2(gdc,rop);
561  	   ReleaseDC(hWnd,gdc);
562  	}
563  void SetCurrentCellStatus(HWND hWnd,int SelfIndex)
564      {
565         SetCell(&BGcell,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
566  	   if (SendMessage(hWnd, BGM_GETPROTECTION, reinterpret_cast<WPARAM>(&BGcell), 0))
567             {
568              BGHS[SelfIndex].CURRENTCELLPROTECTED = TRUE;
569             }
570         else
571             {
572              BGHS[SelfIndex].CURRENTCELLPROTECTED = FALSE;
573             }
574      }
575  TCHAR GetASCII(WPARAM wParam, LPARAM lParam)
576      {
577       int returnvalue;
578       TCHAR mbuffer[100];
579       int result;
580       BYTE keys[256];
581       WORD dwReturnedValue;
582       GetKeyboardState(keys);
583  	 result = ToAscii(static_cast<UINT>(wParam), (lParam >> 16) & 0xff, keys, &dwReturnedValue, 0);
584       returnvalue = (TCHAR) dwReturnedValue;
585       if(returnvalue < 0){returnvalue = 0;}
586       wsprintf(mbuffer, TEXT("return value = %d"), returnvalue);
587       if(result!=1){returnvalue = 0;}
588       return (TCHAR)returnvalue;
589      }
590  void SetHomeRow(HWND hWnd,int SI,int row,int col)
591  	{
592  	 RECT gridrect,cellrect;
593  	 GetClientRect(hWnd,&gridrect);
594  	 cellrect=GetCellRect(hWnd,SI,row,col);
595  	 if((cellrect.bottom > gridrect.bottom)&&((cellrect.bottom - cellrect.top)<(gridrect.bottom-(BGHS[SI].headerrowheight+BGHS[SI].titleheight))))
596  		 {
597  			 while(cellrect.bottom > gridrect.bottom)
598  				 {
599  				  BGHS[SI].homerow ++;
600  				  if(row==BGHS[SI].rows)
601  					  {
602  					   gridrect.top = gridrect.bottom - (BGHS[SI].rowheight);
603  				       InvalidateRect(hWnd,&gridrect,TRUE);
604  					  }
605  				  else
606  					  {
607  					   InvalidateRect(hWnd,&gridrect,FALSE);
608  					  }
609  				  cellrect=GetCellRect(hWnd,SI,row,col);
610  				 }
611  		 }
612       else
613           {
614            if((cellrect.bottom - cellrect.top)>=(gridrect.bottom - (BGHS[SI].headerrowheight+BGHS[SI].titleheight)))
615                {
616                 BGHS[SI].homerow++;
617                }
618           }
619  	 cellrect=GetCellRect(hWnd,SI,row,col);
620  		 {
621  			 while((row < BGHS[SI].homerow))
622  				 {
623  				  BGHS[SI].homerow --;
624  				  InvalidateRect(hWnd,&gridrect,FALSE);
625  				  cellrect=GetCellRect(hWnd,SI,row,col);
626  				 }
627  		 }
628  		 SetScrollPos(hWnd,SB_VERT,BGHS[SI].homerow,TRUE);
629  	}
630  void SetHomeCol(HWND hWnd,int SI,int row,int col)
631  	{
632        RECT gridrect{}, cellrect{};
633        GetClientRect(hWnd,&gridrect);
634        cellrect = GetCellRect(hWnd,SI,row,col);
635        while((cellrect.right > gridrect.right)&&(cellrect.left != BGHS[SI].columnwidths[0]))
636            {
637             BGHS[SI].homecol++;
638             cellrect = GetCellRect(hWnd,SI,row,col);
639             InvalidateRect(hWnd,&gridrect,FALSE);
640            }
641        cellrect = GetCellRect(hWnd,SI,row,col);
642        while((BGHS[SI].cursorcol < BGHS[SI].homecol)&&(BGHS[SI].homecol > 1))
643            {
644             BGHS[SI].homecol--;
645             cellrect = GetCellRect(hWnd,SI,row,col);
646             InvalidateRect(hWnd,&gridrect,FALSE);
647            }
648            {
649            int k;
650             k=HomeColumnNthVisible(SI);
651             SetScrollPos(hWnd,SB_HORZ,k,TRUE);
652            }
653  	}
654  void ShowVscroll(HWND hWnd,int SI)
655  	{
656  	 RECT gridrect;
657  	 int totalpixels;
658  	 int rowsvisibleonscreen;
659  	 GetClientRect(hWnd,&gridrect);
660  	 totalpixels = gridrect.bottom;
661       totalpixels -= BGHS[SI].titleheight;
662  	 totalpixels -= BGHS[SI].headerrowheight;
663  	 totalpixels -= (BGHS[SI].rowheight * BGHS[SI].rows);
664  	 rowsvisibleonscreen = (gridrect.bottom - (BGHS[SI].headerrowheight+BGHS[SI].titleheight)) / BGHS[SI].rowheight;
665  	 if(totalpixels < 0)
666  		 {
667  		 ShowScrollBar(hWnd,SB_VERT,TRUE);
668  		 SetScrollRange(hWnd,SB_VERT,1,(BGHS[SI].rows-rowsvisibleonscreen)+1,TRUE);
669           BGHS[SI].VSCROLL = TRUE;
670  		 }
671  	 else
672  		 {
673  		  ShowScrollBar(hWnd,SB_VERT,FALSE);
674            BGHS[SI].VSCROLL = FALSE;
675  		 }
676  	}
677  void ShowHscroll(HWND hWnd,int SI)
678  	{
679  	 RECT gridrect;
680  	 int totalpixels;
681  	 int colswithwidth;
682       int j;
683  	 GetClientRect(hWnd,&gridrect);
684  	 totalpixels = gridrect.right;
685  	 totalpixels -= BGHS[SI].columnwidths[0];
686       colswithwidth = 0;
687       for(j=1;j<=BGHS[SI].cols;j++)
688           {
689            totalpixels -= BGHS[SI].columnwidths[j];
690            if(BGHS[SI].columnwidths[j]>0)
691                {
692                 colswithwidth++;
693                }
694           }
695  	 if(totalpixels < 0)
696  		 {
697  		 ShowScrollBar(hWnd,SB_HORZ,TRUE);
698  		 SetScrollRange(hWnd,SB_HORZ,1,colswithwidth,TRUE);
699           BGHS[SI].HSCROLL = TRUE;
700  		 }
701  	 else
702  		 {
703  		  ShowScrollBar(hWnd,SB_HORZ,FALSE);
704            BGHS[SI].HSCROLL = FALSE;
705  		 }
706  	}
707  void NotifyRowChanged(HWND hWnd,int SI)
708  	{
709  	 WPARAM wParam;
710  	 LPARAM lParam;
711  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
712         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_ROWCHANGED);
713         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
714  	   wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_SELCHANGE);
715  	   SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
716  	}
717  void NotifyColChanged(HWND hWnd,int SI)
718  	{
719  	 WPARAM wParam;
720  	 LPARAM lParam;
721  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
722         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_COLCHANGED);
723         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
724         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_SELCHANGE);
725         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
726  	}
727  void NotifyEndEdit(HWND hWnd,int SI)
728  	{
729  	 WPARAM wParam;
730  	 LPARAM lParam;
731  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
732         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITEND);
733         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
734  	}
735  void NotifyDelete(HWND hWnd,int SI)
736  	{
737  	 WPARAM wParam;
738  	 LPARAM lParam;
739  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
740         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_DELETECELL);
741         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
742  	}
743  void NotifyEditBegin(HWND hWnd,int SI)
744  	{
745  	 WPARAM wParam;
746  	 LPARAM lParam;
747  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
748         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITBEGIN);
749         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
750  	}
751  void NotifyEditEnd(HWND hWnd,int SI)
752  	{
753  	 WPARAM wParam;
754  	 LPARAM lParam;
755  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
756         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_EDITEND);
757         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
758  	}
759  void NotifyCellClicked(HWND hWnd,int SI)
760  	{
761  	 WPARAM wParam;
762  	 LPARAM lParam;
763  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
764         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLCLICKED);
765         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
766  	}
767  void NotifyCellDbClicked(HWND hWnd,int SI)
768  	{
769  	 WPARAM wParam;
770  	 LPARAM lParam;
771  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
772         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLDBCLICKED);
773         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
774  	}
775  void NotifyCellRClicked(HWND hWnd,int SI)
776  	{
777  	 WPARAM wParam;
778  	 LPARAM lParam;
779  	   lParam = MAKELPARAM(BGHS[SI].cursorrow,BGHS[SI].cursorcol);
780         wParam=MAKEWPARAM(BGHS[SI].gridmenu,BGN_CELLRCLICKED);
781         SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
782  	}
783  void GetVisibleColumns(HWND hWnd,int SI)
784      {
785       int j;
786       int value;
787       value=0;
788       for(j=1;j<=BGHS[SI].cols;j++)
789           {
790            if(BGHS[SI].columnwidths[j] > 0)
791                {
792                 value++;
793                }
794           }
795       BGHS[SI].visiblecolumns = value;
796       SetScrollRange(hWnd,SB_HORZ,1,value,TRUE);
797      }
798  int GetNthVisibleColumn(HWND, int SI, int n)
799      {
800       int j,count;
801       int value;
802       j=1;
803       count=0;
804       value = n-1;
805       while(j<=BGHS[SI].cols)
806           {
807            if(BGHS[SI].columnwidths[j]>0)
808                {
809                 count++;
810                 if(count==n)
811                     {
812                      value = j;
813                     }
814                }
815            j++;
816           }
817       return value;
818      }
819  void CloseEdit(HWND hWnd,int SI)
820      {
821       int r,c;
822       _BGCELL cell;
823       r=BGHS[SI].cursorrow;
824       c=BGHS[SI].cursorcol;
825       cell.row = r;
826       cell.col = c;
827  	 SendMessage(hWnd, BGM_SETCELLDATA, reinterpret_cast<WPARAM>(&cell), reinterpret_cast<LPARAM>(BGHS[SI].editstring));
828  	 wcscpy_s(BGHS[SI].editstring, TEXT(""));
829       RefreshGrid(hWnd);
830       BGHS[SI].EDITING = FALSE;
831       HideCaret(hWnd);
832       NotifyEditEnd(hWnd,SI);
833      }
834  void DisplayEditString(HWND hWnd,int SI, const TCHAR* tstring)
835      {
836         int r,c;
837         HFONT holdfont;
838         RECT rt;
839         HDC cdc;
840         r=BGHS[SI].cursorrow;
841         c=BGHS[SI].cursorcol;
842         ShowCaret(hWnd);
843         if((r<BGHS[SI].homerow)||(c<BGHS[SI].homecol))
844             {
845              HideCaret(hWnd);
846              return;
847             }
848         rt=GetCellRect(hWnd,SI,r,c);
849         rt.top += 2;
850         rt.bottom -= 2;
851         rt.right -=2;
852         rt.left += 2;
853         cdc=GetDC(hWnd);
854         Rectangle(cdc,rt.left,rt.top,rt.right,rt.bottom);
855         rt.top += 2;
856         rt.bottom -= 2;
857         rt.right -=2;
858         rt.left += 2;
859         if(lstrlen(BGHS[SI].editstring)<=300)
860             {
861  		   wcscat_s(BGHS[SI].editstring,tstring);
862  		   wcscat_s(BGHS[SI].editstringdisplay,BGHS[SI].editstring);
863             }
864         else
865  		{
866  			if (!NppParameters::getInstance().getNppGUI()._muteSounds)
867  				MessageBeep(0);
868  		}
869         holdfont=(HFONT)SelectObject(cdc,BGHS[SI].hfont);
870         rt.right -= 5;
871         DrawText(cdc,BGHS[SI].editstringdisplay,-1,&rt,DT_RIGHT|DT_VCENTER|DT_SINGLELINE);
872         rt.right +=5;
873         ShowCaret(hWnd);
874         int rh = BGHS[SI].rowheight;
875         int ah = BGHS[SI].fontascentheight;
876         SetCaretPos(rt.right - 4, rt.top + (rh / 2)-ah + 2);
877         SelectObject(cdc,holdfont);
878         ReleaseDC(hWnd,cdc);
879      }
880  ATOM RegisterGridClass(HINSTANCE hInstance)
881  {
882     for(int j = 0 ; j < MAX_GRIDS ; j++)
883     {
884          BGHS[j].gridmenu = 0;
885          BGHS[j].hlist1 = NULL;
886  		wcscpy_s(BGHS[j].protect, TEXT("U"));
887  		BGHS[j].rows = 100;
888  		BGHS[j].cols = 255;
889  		BGHS[j].homerow = 1;
890  		BGHS[j].homecol = 1;
891  		BGHS[j].rowheight = 21;
892  		BGHS[j].headerrowheight = 21;
893  		BGHS[j].ROWSNUMBERED = TRUE;
894  		BGHS[j].COLUMNSNUMBERED = TRUE;
895          BGHS[j].EDITABLE = FALSE;
896          BGHS[j].EDITING = FALSE;
897          BGHS[j].AUTOROW = TRUE;
898  		BGHS[j].cursorcol = 1;
899  		BGHS[j].cursorrow = 1;
900  		BGHS[j].columnwidths[0]=50;
901          BGHS[j].ADVANCEROW = TRUE;
902  		BGHS[j].DRAWHIGHLIGHT = TRUE;
903  		BGHS[j].cursorcolor = RGB(255,255,255);
904  		BGHS[j].protectcolor = RGB(255,255,255);
905  		BGHS[j].unprotectcolor = RGB(255,255,255);
906  		BGHS[j].highlightcolor = RGB(0,0,128);
907  		BGHS[j].highlightcolorNoFocus = RGB(200,200,200);
908  		BGHS[j].highlightcolorProtect = RGB(0,0,128);
909  		BGHS[j].highlightcolorProtectNoFocus = RGB(200,200,200);
910  		BGHS[j].gridlinecolor = RGB(220,220,220);
911          BGHS[j].highlighttextcolor = RGB(255,255,255);
912  		BGHS[j].textcolor = RGB(0,0,0);
913          BGHS[j].backgroundcolor = GetSysColor(COLOR_BTNFACE);
914          BGHS[j].titletextcolor = RGB(0,0,0);
915          BGHS[j].titlecolor = GetSysColor(COLOR_BTNFACE);
916          BGHS[j].titlegridlinecolor = RGB(120,120,120);
917          BGHS[j].titleheight = 0;
918          BGHS[j].EXTENDLASTCOLUMN = TRUE;
919          BGHS[j].SHOWINTEGRALROWS = TRUE;
920          BGHS[j].ELLIPSIS = TRUE;
921          BGHS[j].COLAUTOWIDTH = FALSE;
922          BGHS[j].COLUMNSIZING = FALSE;
923          BGHS[j].ALLOWCOLUMNRESIZING = FALSE;
924          BGHS[j].cursortype = 0;
925          BGHS[j].hcolumnheadingfont = NULL;
926          BGHS[j].htitlefont = NULL;
927  		BGHS[j].INITIALCONTENT = FALSE;
928  		wcscpy_s(BGHS[j].editstring, TEXT(""));
929  		for(int k = 0 ; k < MAX_COLS ; k++)
930  		{
931  			BGHS[j].columnwidths[k]=50;
932  		}
933      }
934  	WNDCLASS wclass;
935      wclass.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
936  	wclass.lpfnWndProc = (WNDPROC)GridProc;
937  	wclass.cbClsExtra = 0;
938  	wclass.cbWndExtra = 0;
939  	wclass.hInstance = hInstance;
940  	wclass.hIcon = NULL;
941  	wclass.hCursor = ::LoadCursor(NULL, IDC_ARROW);
942  	wclass.hbrBackground = (HBRUSH)(GetStockObject(GRAY_BRUSH));
943  	wclass.lpszClassName = TEXT("BABYGRID");
944  	wclass.lpszMenuName = NULL;
945  	return RegisterClass(&wclass);
946  }
947  void SizeGrid(HWND hWnd,int &bsol;*SI*/)
948  {
949       SendMessage(hWnd,WM_SIZE,SIZE_MAXIMIZED,0);
950  }
951  int FindLongestLine(HDC hdc, wchar_t* text, SIZE* size)
952  {
953      int longest = 0;
954      wchar_t* buffer = nullptr;
955      wchar_t* token = WCSTOK(text, TEXT("\n"), &buffer);;
956      while (token)
957      {
958          ::GetTextExtentPoint32(hdc, token, lstrlen(token), size);
959          if (size->cx > longest)
960          {
961               longest=size->cx;
962          }
963          token = WCSTOK(nullptr, TEXT("\n"), &buffer);
964      }
965      return longest;
966  }
967  LRESULT CALLBACK GridProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
968  {
969  	int wmId;
970  	PAINTSTRUCT ps;
971  	TCHAR buffer[bufferLen];
972  	int SelfIndex;
973  	int ReturnValue;
974  	HINSTANCE hInst;
975      int iDataType;
976  	SelfIndex=FindGrid(GetMenu(hWnd));
977  	{
978  	 RECT rect;
979  	 GetClientRect(hWnd,&rect);
980  	 BGHS[SelfIndex].gridwidth = rect.right - rect.left;
981  	 BGHS[SelfIndex].gridheight = rect.bottom - rect.top;
982  	}
983  	ReturnValue = 0;
984  	switch (message)
985  	{
986  		case WM_COMMAND:
987  			wmId    = LOWORD(wParam);
988  			switch (wmId)
989  			{
990                  case 1:
991  				default:
992  				   return DefWindowProc(hWnd, message, wParam, lParam);
993  			}
994  			break;
995  		case WM_PAINT:
996  			BeginPaint(hWnd, &ps);
997  			RECT rt;
998  			GetClientRect(hWnd, &rt);
999  			CalcVisibleCellBoundaries(SelfIndex);
1000  			if (BGHS[SelfIndex].titleheight > 0)
1001  				DisplayTitle(hWnd,SelfIndex,BGHS[SelfIndex].htitlefont);
1002  			DisplayColumn(hWnd,SelfIndex,0,0,BGHS[SelfIndex].hfont,BGHS[SelfIndex].hcolumnheadingfont);
1003  			{
1004  			     int c,j,k,offset;
1005  			     offset = BGHS[SelfIndex].columnwidths[0];
1006  			     j=BGHS[SelfIndex].leftvisiblecol;
1007  			     k=BGHS[SelfIndex].rightvisiblecol;
1008  			     for(c=j;c<=k;c++)
1009  			     {
1010  			          DisplayColumn(hWnd,SelfIndex,c,offset,BGHS[SelfIndex].hfont,BGHS[SelfIndex].hcolumnheadingfont);
1011  			          offset+=BGHS[SelfIndex].columnwidths[c];
1012  			     }
1013  			}
1014  			EndPaint(hWnd, &ps);
1015  			if(GetFocus()==hWnd)
1016  				{
1017  			      PostMessage(hWnd,BGM_DRAWCURSOR,(UINT)SelfIndex,0);
1018  				}
1019  			break;
1020          case BGM_PAINTGRID:
1021          {
1022               RECT rect;
1023               GetClientRect(hWnd, &rect);
1024               InvalidateRect(hWnd,&rect,TRUE);
1025               UpdateWindow(hWnd);
1026  			if (!NppParameters::getInstance().getNppGUI()._muteSounds)
1027  				MessageBeep(0);
1028          }
1029          break;
1030          case WM_SETTEXT:
1031          {
1032                int j,linecount;
1033                SIZE size;
1034                HDC gdc;
1035                HFONT holdfont;
1036                if(lstrlen((TCHAR*)lParam)>300)
1037                {
1038  				  wcscpy_s(BGHS[SelfIndex].title, TEXT("Title too long (300 chars max)"));
1039                }
1040                else
1041                {
1042  				  wcscpy_s(BGHS[SelfIndex].title,(TCHAR*)lParam);
1043                }
1044               gdc=GetDC(hWnd);
1045               if(lstrlen(BGHS[SelfIndex].title) > 0)
1046               {
1047                    linecount=1;
1048  				  for (j = 0; j<static_cast<int>(lstrlen(BGHS[SelfIndex].title)); j++)
1049                    {
1050                         if (BGHS[SelfIndex].title[j] == '\n')
1051                         {
1052                              linecount++;
1053                         }
1054                    }
1055                    holdfont=(HFONT)SelectObject(gdc,BGHS[SelfIndex].htitlefont);
1056                    GetTextExtentPoint32(gdc,BGHS[SelfIndex].title,lstrlen(BGHS[SelfIndex].title),&size);
1057                    SelectObject(gdc,holdfont);
1058  				  BGHS[SelfIndex].titleheight = static_cast<int>((size.cy*1.2) * linecount);
1059               }
1060               else
1061               {
1062                    BGHS[SelfIndex].titleheight = 0;
1063               }
1064               ReleaseDC(hWnd,gdc);
1065  			 RefreshGrid(hWnd);
1066               SizeGrid(hWnd,SelfIndex);
1067          }
1068          break;
1069          case BGM_GETROWS:
1070                ReturnValue = BGHS[SelfIndex].rows;
1071              break;
1072          case BGM_GETCOLS:
1073                ReturnValue = BGHS[SelfIndex].cols;
1074              break;
1075          case BGM_GETCOLWIDTH:
1076                ReturnValue = BGHS[SelfIndex].columnwidths[wParam];
1077              break;
1078          case BGM_GETROWHEIGHT:
1079                 ReturnValue = BGHS[SelfIndex].rowheight;
1080              break;
1081          case BGM_GETHEADERROWHEIGHT:
1082                 ReturnValue = BGHS[SelfIndex].headerrowheight;
1083              break;
1084          case BGM_GETOWNERDRAWITEM:
1085                ReturnValue = BGHS[SelfIndex].ownerdrawitem;
1086              break;
1087  		case BGM_DRAWCURSOR:
1088  			DrawCursor(hWnd, static_cast<int32_t>(wParam));
1089  			break;
1090          case BGM_SETCURSORPOS:
1091                 DrawCursor(hWnd,SelfIndex);
1092                 if((((int)wParam <= BGHS[SelfIndex].rows)&&((int)wParam > 0))&&
1093                     (((int)lParam <= BGHS[SelfIndex].cols)&&((int)lParam > 0)))
1094                 {
1095  					   BGHS[SelfIndex].cursorrow = static_cast<int32_t>(wParam);
1096  					   BGHS[SelfIndex].cursorcol = static_cast<int32_t>(lParam);
1097                 }
1098                 else
1099                 {
1100                      DrawCursor(hWnd,SelfIndex);
1101                      break;
1102                 }
1103                 SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1104                 SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1105                 DrawCursor(hWnd,SelfIndex);
1106                 RefreshGrid(hWnd);
1107              break;
1108  		case BGM_SETLASTVIEW:
1109  			if ((((int)wParam <= BGHS[SelfIndex].rows) && ((int)wParam > 0)) &&
1110  				(((int)lParam <= BGHS[SelfIndex].rows) && ((int)lParam > 0)))
1111  			{
1112  				BGHS[SelfIndex].homerow = static_cast<int32_t>(wParam);
1113  				BGHS[SelfIndex].homecol = 1;
1114  				BGHS[SelfIndex].cursorrow = static_cast<int32_t>(lParam);
1115  				BGHS[SelfIndex].cursorcol = 1;
1116  				SetHomeRow(hWnd, SelfIndex, BGHS[SelfIndex].cursorrow, BGHS[SelfIndex].cursorcol);
1117  				RefreshGrid(hWnd);
1118  				NotifyRowChanged(hWnd, SelfIndex);
1119  			}
1120  			break;
1121          case BGM_SETINITIALCONTENT:
1122                 BGHS[SelfIndex].INITIALCONTENT = (BOOL)wParam;
1123              break;
1124  		case BGM_SHOWHILIGHT:
1125  			   BGHS[SelfIndex].DRAWHIGHLIGHT = (BOOL)wParam;
1126                 RefreshGrid(hWnd);
1127  			break;
1128          case BGM_EXTENDLASTCOLUMN:
1129                 BGHS[SelfIndex].EXTENDLASTCOLUMN = (BOOL)wParam;
1130                 RefreshGrid(hWnd);
1131              break;
1132          case BGM_SHOWINTEGRALROWS:
1133                 BGHS[SelfIndex].SHOWINTEGRALROWS = (BOOL)wParam;
1134                 SizeGrid(hWnd,SelfIndex);
1135                 RefreshGrid(hWnd);
1136              break;
1137          case BGM_SETCOLAUTOWIDTH:
1138                 BGHS[SelfIndex].COLAUTOWIDTH = (BOOL)wParam;
1139              break;
1140          case BGM_SETALLOWCOLRESIZE:
1141                 BGHS[SelfIndex].ALLOWCOLUMNRESIZING = (BOOL)wParam;
1142              break;
1143  		case BGM_PROTECTCELL:
1144                LPBGcell=(_BGCELL*)wParam;
1145                if(OutOfRange(LPBGcell))
1146                {
1147                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1148                     lParam = 0;
1149                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1150  				   ReturnValue = -1;
1151                     break;
1152                }
1153                wsprintf(buffer, TEXT("%05d-%03d"), LPBGcell->row,LPBGcell->col);
1154                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1155                if(FindResult != LB_ERR)
1156                {
1157  				  auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1158  				  if (static_cast<size_t>(lbTextLen) > bufferLen)
1159  					  return TRUE;
1160  					SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1161  				   if((BOOL)lParam)
1162  				   {
1163  					   buffer[10] = 'P';
1164  				   }
1165  				   else
1166  				   {
1167  					   buffer[10] = 'U';
1168  				   }
1169                     SendMessage(BGHS[SelfIndex].hlist1, LB_DELETESTRING, FindResult, 0);
1170  				   SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, FindResult, reinterpret_cast<LPARAM>(buffer));
1171                }
1172  			  else
1173  			  {
1174  				  wcscat_s(buffer, TEXT("|"));
1175  				  if((BOOL)lParam)
1176  				  {
1177  					  wcscat_s(buffer, TEXT("PA"));
1178  				  }
1179  				  else
1180  				  {
1181  					  wcscat_s(buffer, TEXT("UA"));
1182  				  }
1183  				  wcscat_s(buffer, TEXT("|"));
1184  				  SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, FindResult, reinterpret_cast<LPARAM>(buffer));
1185  			  }
1186  			break;
1187  		case BGM_NOTIFYROWCHANGED:
1188  			   NotifyRowChanged(hWnd,SelfIndex);
1189  			break;
1190  		case BGM_NOTIFYCOLCHANGED:
1191  			   NotifyColChanged(hWnd,SelfIndex);
1192  			break;
1193  		case BGM_SETPROTECT:
1194  			if((BOOL)wParam)
1195              {
1196  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("P"));
1197  			}
1198  			else
1199              {
1200  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("U"));
1201  			}
1202  			break;
1203  		case BGM_AUTOROW:
1204  			  if((BOOL)wParam)
1205  			  {
1206  			      BGHS[SelfIndex].AUTOROW = TRUE;
1207  			  }
1208  			  else
1209  			  {
1210  			      BGHS[SelfIndex].AUTOROW = FALSE;
1211  			  }
1212  			break;
1213          case BGM_SETEDITABLE:
1214                 if((BOOL)wParam)
1215                 {
1216                      BGHS[SelfIndex].EDITABLE = TRUE;
1217                 }
1218  			   else
1219  			   {
1220  				   BGHS[SelfIndex].EDITABLE = FALSE;
1221  			   }
1222              break;
1223          case BGM_SETCELLDATA:
1224                LPBGcell=(_BGCELL*)wParam;
1225                if(OutOfRange(LPBGcell))
1226                    {
1227                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1228                     lParam = 0;
1229                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1230  				   ReturnValue = -1;
1231                     break;
1232                    }
1233                wsprintf(buffer, TEXT("%05d-%03d"), LPBGcell->row,LPBGcell->col);
1234  			  if (!BGHS[SelfIndex].INITIALCONTENT) 
1235  			  {
1236  				  FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1237  				  if(FindResult != LB_ERR)
1238  				  {
1239  					  SendMessage(BGHS[SelfIndex].hlist1,LB_DELETESTRING,FindResult,0);
1240  				  }
1241  			  }
1242  			  wcscat_s(buffer, TEXT("|"));
1243  			  wcscat_s(buffer,BGHS[SelfIndex].protect);
1244  			  iDataType = 1;
1245                if(iDataType==1){ wcscat_s(buffer, TEXT("A"));}
1246                if(iDataType==2){ wcscat_s(buffer, TEXT("N"));}
1247                if(iDataType==3){ wcscat_s(buffer, TEXT("T"));}
1248                if(iDataType==4){ wcscat_s(buffer, TEXT("F"));}
1249  			  if(iDataType==5){ wcscat_s(buffer, TEXT("G"));}
1250  			  wcscat_s(buffer, TEXT("|"));
1251  			  wcscat_s(buffer, (TCHAR*)lParam);
1252  			  FindResult = static_cast<int32_t>(SendMessage(BGHS[SelfIndex].hlist1, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(buffer)));
1253                if(FindResult==LB_ERR)
1254  			  {
1255  				if (!NppParameters::getInstance().getNppGUI()._muteSounds)
1256  					MessageBeep(0);
1257  			  }
1258                    {
1259                     RECT rect;
1260                     rect=GetCellRect(hWnd,SelfIndex,LPBGcell->row,LPBGcell->col);
1261                     InvalidateRect(hWnd,&rect,FALSE);
1262                    }
1263                    if(BGHS[SelfIndex].AUTOROW)
1264                    {
1265                     int j = static_cast<int32_t>(SendMessage(BGHS[SelfIndex].hlist1, LB_GETCOUNT, 0, 0));
1266                      if(j>0)
1267                          {
1268                          auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, j-1, 0);
1269                          if (static_cast<size_t>(lbTextLen) > bufferLen)
1270                              return TRUE;
1271                           SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, j - 1, reinterpret_cast<LPARAM>(buffer));
1272                           buffer[5]=0x00;
1273                           j=_wtoi(buffer);
1274                           if(j>SendMessage(hWnd,BGM_GETROWS,0,0))
1275                               {
1276                                SendMessage(hWnd,BGM_SETGRIDDIM,j,BGHS[SelfIndex].cols);
1277                               }
1278                          }
1279                      else
1280                          {
1281                          SendMessage(hWnd,BGM_SETGRIDDIM,j,BGHS[SelfIndex].cols);
1282                          }
1283                    }
1284                    if((BGHS[SelfIndex].COLAUTOWIDTH)||(LPBGcell->row == 0))
1285                        {
1286                         HDC hdc;
1287                         SIZE size { 0, 0 };
1288                         int required_width;
1289                         int current_width;
1290                         int required_height = 30;
1291                         int current_height;
1292                         int longestline;
1293                         HFONT holdfont;
1294                         hdc=GetDC(hWnd);
1295                         if(LPBGcell->row == 0)
1296                             {
1297                               holdfont=(HFONT)SelectObject(hdc,BGHS[SelfIndex].hcolumnheadingfont);
1298                             }
1299                             else
1300                             {
1301                               holdfont=(HFONT)SelectObject(hdc,BGHS[SelfIndex].hfont);
1302                             }
1303                         longestline=FindLongestLine(hdc,(TCHAR*)lParam,&size);
1304                         required_width = longestline+15;
1305                         required_height = size.cy;
1306                             {
1307                                 int count=1;
1308                                 TCHAR tbuffer[255] = { '\0' };
1309  							   wcscpy_s(tbuffer,(TCHAR*)lParam);
1310                                 for(int j=0;j<(int)lstrlen(tbuffer);j++)
1311                                     {
1312                                     if(tbuffer[j]=='\n'){count++;}
1313                                     }
1314                                 if((!BGHS[SelfIndex].ELLIPSIS)||(LPBGcell->row == 0))
1315                                     {
1316                                      required_height *= count;
1317                                     }
1318                                 required_height +=5;
1319                             }
1320                         SelectObject(hdc,holdfont);
1321                         ReleaseDC(hWnd,hdc);
1322                         current_width = BGHS[SelfIndex].columnwidths[LPBGcell->col];
1323                         if(LPBGcell->row == 0)
1324                             {
1325                              current_height = BGHS[SelfIndex].headerrowheight;
1326                              if(required_height > current_height)
1327                                  {
1328                                   SendMessage(hWnd,BGM_SETHEADERROWHEIGHT,required_height,0);
1329                                  }
1330                             }
1331                         else
1332                             {
1333                              current_height = BGHS[SelfIndex].rowheight;
1334                              if(required_height > current_height)
1335  							{
1336                                   SendMessage(hWnd, BGM_SETROWHEIGHT, required_height, 0);
1337                              }
1338                             }
1339                         if(required_width > current_width)
1340                             {
1341                              SendMessage(hWnd,BGM_SETCOLWIDTH,LPBGcell->col,required_width);
1342                             }
1343                         ReleaseDC(hWnd,hdc);
1344                        }
1345              break;
1346          case BGM_GETCELLDATA:
1347                LPBGcell=(_BGCELL*)wParam;
1348                if(OutOfRange(LPBGcell))
1349                    {
1350                      wParam = MAKEWPARAM(GetMenu(hWnd), BGN_OUTOFRANGE);
1351                      lParam = 0;
1352                      SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1353                      ReturnValue = -1;
1354                      break;
1355                    }
1356                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1357                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1358                if(FindResult != LB_ERR)
1359                    {
1360                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1361                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1362                        return TRUE;
1363                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1364                    switch (buffer[10]) 
1365                     {
1366                      case 'U': ReturnValue = 0; break;
1367                      case 'P': ReturnValue = 1; break;
1368                      default : ReturnValue = 0; break;
1369                     }
1370                    switch (buffer[11]) 
1371                     {
1372                      case 'A': ReturnValue |= 1 << 4; break;
1373                      case 'N': ReturnValue |= 2 << 4; break;
1374                      case 'T': ReturnValue |= 3 << 4; break;
1375                      case 'F': ReturnValue |= 4 << 4; break;
1376                      case 'G': ReturnValue |= 5 << 4; break;
1377                      default : ReturnValue |= 1 << 4; break;
1378                     }
1379                     int j,k,c;
1380                     TCHAR tbuffer[1000];
1381                     wcscpy_s(tbuffer,buffer);
1382                     k=lstrlen(tbuffer);
1383                     c=0;
1384                     for(j=13;j<k;j++)
1385                         {
1386                          buffer[c]=tbuffer[j];
1387                          c++;
1388                         }
1389                     buffer[c]=0x00;
1390                     wcscpy_s((TCHAR*)lParam, bufferLen, buffer);
1391                    }
1392  			  else
1393  			  {
1394  				  wcscpy_s((TCHAR*)lParam, bufferLen, TEXT(""));
1395  			  }
1396              break;
1397          case BGM_CLEARGRID:
1398                  SendMessage(BGHS[SelfIndex].hlist1,LB_RESETCONTENT,0,0);
1399                  BGHS[SelfIndex].rows = 0;
1400                  BGHS[SelfIndex].cursorrow = 1;
1401                  BGHS[SelfIndex].homerow = 1;
1402                  BGHS[SelfIndex].homecol = 1;
1403                      {
1404                       RECT rect;
1405                       GetClientRect(hWnd,&rect);
1406                       InvalidateRect(hWnd,&rect,TRUE);
1407                      }
1408              break;
1409          case BGM_DELETECELL:
1410                LPBGcell=(_BGCELL*)wParam;
1411                if(OutOfRange(LPBGcell))
1412                    {
1413                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1414                     lParam = 0;
1415                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1416  				   ReturnValue = -1;
1417                     break;
1418                    }
1419                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1420                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1421                if(FindResult != LB_ERR)
1422                    {
1423                     SendMessage(BGHS[SelfIndex].hlist1,LB_DELETESTRING,FindResult,0);
1424  				   NotifyEndEdit(hWnd,SelfIndex);
1425                    }
1426              break;
1427  		case BGM_SETGRIDDIM:
1428              if (wParam<=MAX_ROWS)
1429              {
1430  	            BGHS[SelfIndex].rows = static_cast<int32_t>(wParam);
1431              }
1432              else
1433              {
1434                  BGHS[SelfIndex].rows = MAX_ROWS;
1435              }
1436  			   if((lParam>0)&&(lParam<=MAX_COLS))
1437  			   {
1438  				   BGHS[SelfIndex].cols = static_cast<int32_t>(lParam);
1439  			   }
1440  			   else
1441  			   {
1442                  if(lParam <= 0)
1443                      {
1444  				     BGHS[SelfIndex].cols = 1;
1445                      }
1446                  else
1447                      {
1448                       BGHS[SelfIndex].cols = MAX_COLS;
1449                      }
1450  			   }
1451                     {RECT rect;
1452                      GetClientRect(hWnd,&rect);
1453                      InvalidateRect(hWnd,&rect,TRUE);
1454                     }
1455                 GetVisibleColumns(hWnd,SelfIndex);
1456  			break;
1457  		case BGM_SETCOLWIDTH:
1458  			  if((wParam <= MAX_COLS) && (lParam >= 0))
1459  			  {
1460                  RECT rect;
1461  				BGHS[SelfIndex].columnwidths[wParam] = static_cast<int32_t>(lParam);
1462                  GetClientRect(hWnd,&rect);
1463                  InvalidateRect(hWnd,&rect,FALSE);
1464                  GetVisibleColumns(hWnd,SelfIndex);
1465  			  }
1466  			break;
1467  		case BGM_SETHEADERROWHEIGHT:
1468              RECT rect;
1469              BGHS[SelfIndex].headerrowheight = static_cast<int32_t>(wParam);
1470              SizeGrid(hWnd, SelfIndex);
1471              GetClientRect(hWnd, &rect);
1472              InvalidateRect(hWnd, &rect, FALSE);
1473              break;
1474          case BGM_GETHOMEROW:
1475                ReturnValue = BGHS[SelfIndex].homerow;
1476              break;
1477          case BGM_GETROW:
1478                ReturnValue = BGHS[SelfIndex].cursorrow;
1479              break;
1480          case BGM_GETCOL:
1481                ReturnValue = BGHS[SelfIndex].cursorcol;
1482              break;
1483          case BGM_GETTYPE:
1484                LPBGcell=(_BGCELL*)wParam;
1485                if(OutOfRange(LPBGcell))
1486                    {
1487                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1488                     lParam = 0;
1489                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1490                     ReturnValue = -1;
1491                     break;
1492                    }
1493                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1494                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1495                if(FindResult != LB_ERR)
1496                    {
1497                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1498                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1499                        return TRUE;
1500                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1501                    switch (buffer[11])
1502                     {
1503                     case 'A':ReturnValue=1;break;
1504                     case 'N':ReturnValue=2;break;
1505                     case 'T':ReturnValue=3;break;
1506                     case 'F':ReturnValue=4;break;
1507                     case 'G':ReturnValue=5;break;
1508                     default: ReturnValue =1;break;
1509                     }
1510                    }
1511              break;
1512          case BGM_GETPROTECTION:
1513                LPBGcell=(_BGCELL*)wParam;
1514                if(OutOfRange(LPBGcell))
1515                    {
1516                     wParam=MAKEWPARAM(GetMenu(hWnd),BGN_OUTOFRANGE);
1517                     lParam = 0;
1518                     SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
1519                     ReturnValue = -1;
1520                     break;
1521                    }
1522                wsprintf(buffer, TEXT("%05d-%03d"),LPBGcell->row,LPBGcell->col);
1523                ReturnValue = 0;
1524                FindResult = BinarySearchListBox(BGHS[SelfIndex].hlist1,buffer);
1525                if(FindResult != LB_ERR)
1526                    {
1527                    auto lbTextLen = ::SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXTLEN, FindResult, 0);
1528                    if (static_cast<size_t>(lbTextLen) > bufferLen)
1529                        return TRUE;
1530                    SendMessage(BGHS[SelfIndex].hlist1, LB_GETTEXT, FindResult, reinterpret_cast<LPARAM>(buffer));
1531                    switch (buffer[10])
1532                     {
1533                    case 'U':ReturnValue=0;break;
1534                    case 'P':ReturnValue=1;break;
1535                    default: ReturnValue =0;break;
1536                     }
1537                    }
1538  			break;
1539          case BGM_SETROWHEIGHT:
1540  			if(wParam <1){wParam=1;}
1541  			BGHS[SelfIndex].rowheight = static_cast<int32_t>(wParam);
1542              SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1543              SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1544              SizeGrid(hWnd,SelfIndex);
1545              {
1546  				RECT rect;
1547  				GetClientRect(hWnd,&rect);
1548  				InvalidateRect(hWnd,&rect,FALSE);
1549              }
1550              break;
1551          case BGM_SETTITLEHEIGHT:
1552              BGHS[SelfIndex].titleheight = static_cast<int32_t>(wParam);
1553              SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1554              SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1555              {
1556                  RECT rect;
1557                  GetClientRect(hWnd,&rect);
1558                  InvalidateRect(hWnd,&rect,FALSE);
1559              }
1560              break;
1561          case BGM_SETGRIDLINECOLOR:
1562  			  DrawCursor(hWnd,SelfIndex);
1563  			  BGHS[SelfIndex].gridlinecolor = (COLORREF)wParam;
1564  			  DrawCursor(hWnd,SelfIndex);
1565                RefreshGrid(hWnd);
1566              break;
1567  		case BGM_SETCURSORCOLOR:
1568  			  DrawCursor(hWnd,SelfIndex);
1569  			  BGHS[SelfIndex].cursorcolor = (COLORREF)wParam;
1570  			  DrawCursor(hWnd,SelfIndex);
1571                RefreshGrid(hWnd);
1572  			break;
1573          case BGM_SETHILIGHTTEXTCOLOR:
1574                 BGHS[SelfIndex].highlighttextcolor = (COLORREF)wParam;
1575  				  {
1576  				   RECT rect;
1577  				   GetClientRect(hWnd,&rect);
1578  				   InvalidateRect(hWnd,&rect,FALSE);
1579  				  }
1580              break;
1581          case BGM_SETHILIGHTCOLOR:
1582                 BGHS[SelfIndex].highlightcolor = (COLORREF)wParam;
1583  				  {
1584  				   RECT rect;
1585  				   GetClientRect(hWnd,&rect);
1586  				   InvalidateRect(hWnd,&rect,FALSE);
1587  				  }
1588              break;
1589          case BGM_SETHILIGHTCOLOR_NOFOCUS:
1590                 BGHS[SelfIndex].highlightcolorNoFocus = (COLORREF)wParam;
1591  				  {
1592  				   RECT rect;
1593  				   GetClientRect(hWnd,&rect);
1594  				   InvalidateRect(hWnd,&rect,FALSE);
1595  				  }
1596              break;
1597          case BGM_SETHILIGHTCOLOR_PROTECT:
1598                 BGHS[SelfIndex].highlightcolorProtect = (COLORREF)wParam;
1599  				  {
1600  				   RECT rect;
1601  				   GetClientRect(hWnd,&rect);
1602  				   InvalidateRect(hWnd,&rect,FALSE);
1603  				  }
1604              break;
1605          case BGM_SETHILIGHTCOLOR_PROTECT_NOFOCUS:
1606                 BGHS[SelfIndex].highlightcolorProtectNoFocus = (COLORREF)wParam;
1607  				  {
1608  				   RECT rect;
1609  				   GetClientRect(hWnd,&rect);
1610  				   InvalidateRect(hWnd,&rect,FALSE);
1611  				  }
1612              break;
1613  		case BGM_SETPROTECTCOLOR:
1614  			  BGHS[SelfIndex].protectcolor = (COLORREF)wParam;
1615  				  {
1616  				   RECT rect;
1617  				   GetClientRect(hWnd,&rect);
1618  				   InvalidateRect(hWnd,&rect,FALSE);
1619  				  }
1620  			break;
1621  		case BGM_SETUNPROTECTCOLOR:
1622  			  BGHS[SelfIndex].unprotectcolor = (COLORREF)wParam;
1623  				  {
1624  				   RECT rect;
1625  				   GetClientRect(hWnd,&rect);
1626  				   InvalidateRect(hWnd,&rect,FALSE);
1627  				  }
1628  			break;
1629  		case BGM_SETTEXTCOLOR:
1630  			  BGHS[SelfIndex].textcolor = (COLORREF)wParam;
1631  				  {
1632  				   RECT rect;
1633  				   GetClientRect(hWnd,&rect);
1634  				   InvalidateRect(hWnd,&rect,FALSE);
1635  				  }
1636  			break;
1637  		case BGM_SETBACKGROUNDCOLOR:
1638  			  BGHS[SelfIndex].backgroundcolor = (COLORREF)wParam;
1639  				  {
1640  				   RECT rect;
1641  				   GetClientRect(hWnd,&rect);
1642  				   InvalidateRect(hWnd,&rect,FALSE);
1643  				  }
1644  			break;
1645  		case BGM_SETTITLETEXTCOLOR:
1646  			  BGHS[SelfIndex].titletextcolor = (COLORREF)wParam;
1647  				  {
1648  				   RECT rect;
1649  				   GetClientRect(hWnd,&rect);
1650  				   InvalidateRect(hWnd,&rect,FALSE);
1651  				  }
1652  			break;
1653  		case BGM_SETTITLECOLOR:
1654  			  BGHS[SelfIndex].titlecolor = (COLORREF)wParam;
1655  				  {
1656  				   RECT rect;
1657  				   GetClientRect(hWnd,&rect);
1658  				   InvalidateRect(hWnd,&rect,FALSE);
1659  				  }
1660  			break;
1661  		case BGM_SETTITLEGRIDLINECOLOR:
1662  			  BGHS[SelfIndex].titlegridlinecolor = (COLORREF)wParam;
1663  				  {
1664  				   RECT rect;
1665  				   GetClientRect(hWnd,&rect);
1666  				   InvalidateRect(hWnd,&rect,FALSE);
1667  				  }
1668  			break;
1669          case BGM_SETELLIPSIS:
1670                 BGHS[SelfIndex].ELLIPSIS = (BOOL)wParam;
1671  				  {
1672  				   RECT rect;
1673  				   GetClientRect(hWnd,&rect);
1674  				   InvalidateRect(hWnd,&rect,FALSE);
1675  				  }
1676              break;
1677          case BGM_SETTITLEFONT:
1678                 BGHS[SelfIndex].htitlefont = (HFONT)wParam;
1679  				  {
1680  				   RECT rect;
1681  				   GetClientRect(hWnd,&rect);
1682  				   InvalidateRect(hWnd,&rect,FALSE);
1683  				  }
1684              break;
1685          case BGM_SETHEADINGFONT:
1686                 BGHS[SelfIndex].hcolumnheadingfont = (HFONT)wParam;
1687  				  {
1688  				   RECT rect;
1689  				   GetClientRect(hWnd,&rect);
1690  				   InvalidateRect(hWnd,&rect,FALSE);
1691  				  }
1692              break;
1693          case BGM_SETROWSNUMBERED:
1694                 BGHS[SelfIndex].ROWSNUMBERED = (BOOL)wParam;
1695  				  {
1696  				   RECT rect;
1697  				   GetClientRect(hWnd,&rect);
1698  				   InvalidateRect(hWnd,&rect,FALSE);
1699  				  }
1700              break;
1701          case BGM_SETCOLSNUMBERED:
1702                 BGHS[SelfIndex].COLUMNSNUMBERED = (BOOL)wParam;
1703  				  {
1704  				   RECT rect;
1705  				   GetClientRect(hWnd,&rect);
1706  				   InvalidateRect(hWnd,&rect,FALSE);
1707  				  }
1708              break;
1709  		case WM_ENABLE:
1710  			if(wParam == FALSE)
1711  				{
1712  				 BGHS[SelfIndex].textcolor = RGB(120,120,120);
1713  				}
1714  			else
1715  				{
1716  				 BGHS[SelfIndex].textcolor = RGB(0,0,0);
1717  				}
1718  			break;
1719          case WM_MOUSEMOVE:
1720                int x,y,r,c,t,z;
1721                x=LOWORD(lParam);
1722                y=HIWORD(lParam);
1723                r=GetRowOfMouse(SelfIndex,y);
1724                c=GetColOfMouse(SelfIndex,x);
1725                t=GetColOfMouse(SelfIndex,x+10);
1726                z=GetColOfMouse(SelfIndex,x-10);
1727                if(BGHS[SelfIndex].COLUMNSIZING)
1728                    {
1729                     int dx,nx,cr;
1730                     dx=x-BGHS[SelfIndex].columntoresizeinitx;
1731                     nx=BGHS[SelfIndex].columntoresizeinitsize + dx;
1732                     if(nx<=0){nx=0;}
1733                     cr=BGHS[SelfIndex].columntoresize;
1734                     SendMessage(hWnd,BGM_SETCOLWIDTH,cr,nx);
1735                    }
1736                if((r==0)&&(c>=-1)&&((t!=c)||(z!=c))&&(!BGHS[SelfIndex].COLUMNSIZING))
1737                    {
1738                     if((BGHS[SelfIndex].cursortype != 2)&&(BGHS[SelfIndex].ALLOWCOLUMNRESIZING))
1739                         {
1740                          BGHS[SelfIndex].cursortype = 2;
1741                          SetCursor(LoadCursor(NULL, IDC_SIZEWE));
1742                         }
1743                    }
1744                else
1745                    {
1746                     if((BGHS[SelfIndex].cursortype != 1)&&(!BGHS[SelfIndex].COLUMNSIZING))
1747                         {
1748                          BGHS[SelfIndex].cursortype = 1;
1749                          SetCursor(LoadCursor(NULL, IDC_ARROW));
1750                         }
1751                    }
1752              break;
1753          case WM_LBUTTONUP:
1754                if(BGHS[SelfIndex].COLUMNSIZING)
1755                    {
1756                     BGHS[SelfIndex].COLUMNSIZING = FALSE;
1757                     SetCursor(LoadCursor(NULL, IDC_ARROW));
1758                     BGHS[SelfIndex].cursortype = 1;
1759                     BGHS[SelfIndex].SHOWINTEGRALROWS=BGHS[SelfIndex].REMEMBERINTEGRALROWS;
1760                     SizeGrid(hWnd,SelfIndex);
1761                    }
1762              break;
1763  		case WM_RBUTTONUP :
1764  		case WM_LBUTTONDBLCLK :
1765  		case WM_LBUTTONDOWN:
1766  			{
1767  			 int x,y,r,c;
1768               if(BGHS[SelfIndex].cursortype == 2)
1769                   {
1770                    int c,x,t,z;
1771                    if(!BGHS[SelfIndex].COLUMNSIZING)
1772  					  {
1773                         BGHS[SelfIndex].REMEMBERINTEGRALROWS = BGHS[SelfIndex].SHOWINTEGRALROWS;
1774  					  }
1775  				  BGHS[SelfIndex].COLUMNSIZING = TRUE;
1776                    BGHS[SelfIndex].SHOWINTEGRALROWS = FALSE;
1777                    x=LOWORD(lParam);
1778                    BGHS[SelfIndex].columntoresizeinitx=x;
1779                       t=GetColOfMouse(SelfIndex,x+10);
1780                       z=GetColOfMouse(SelfIndex,x-10);
1781                    c=GetColOfMouse(SelfIndex,x);
1782                      if(t!=c)
1783                          {
1784                          BGHS[SelfIndex].columntoresize = c;
1785                          }
1786                      if(z!=c)
1787                          {
1788                          if(c==-1)
1789                              {
1790  								c = static_cast<int32_t>(SendMessage(hWnd, BGM_GETCOLS, 0, 0));
1791                              }
1792                          else
1793                              {
1794                                c-=1;
1795                              }
1796                           BGHS[SelfIndex].columntoresize = c;
1797                          }
1798                    BGHS[SelfIndex].columntoresizeinitsize = BGHS[SelfIndex].columnwidths[c];
1799                   }
1800               if(BGHS[SelfIndex].EDITING)
1801                   {
1802                    CloseEdit(hWnd,SelfIndex);
1803                   }
1804               else
1805                   {
1806                    SetFocus(hWnd);
1807                   }
1808               BOOL NRC,NCC;
1809               NRC=FALSE;
1810               NCC=FALSE;
1811  			 if(GetFocus()==hWnd)
1812  				 {
1813  				  x=LOWORD(lParam);
1814  				  y=HIWORD(lParam);
1815  				  r=GetRowOfMouse(SelfIndex,y);
<span onclick='openModal()' class='match'>1816  				  c=GetColOfMouse(SelfIndex,x);
1817  				   DrawCursor(hWnd,SelfIndex);
1818  				   if((r>0)&&(c>0))
1819  					   {
1820  					    if(r != BGHS[SelfIndex].cursorrow)
1821  							{
1822  							 BGHS[SelfIndex].cursorrow = r;
1823                               NRC=TRUE;
1824  							}
1825  						else
</span>1826  							{
1827  					         BGHS[SelfIndex].cursorrow = r;
1828  							}
1829  						if(c != BGHS[SelfIndex].cursorcol)
1830  							{
1831  							 BGHS[SelfIndex].cursorcol = c;
1832                               NCC=TRUE;
1833  							}
1834  						else
1835  							{
1836  						     BGHS[SelfIndex].cursorcol = c;
1837  							}
1838  					   }
1839                     if(NRC){NotifyRowChanged(hWnd,SelfIndex);}
1840                     if(NCC){NotifyColChanged(hWnd,SelfIndex);}
1841  				   DrawCursor(hWnd,SelfIndex);
1842  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1843  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1844  				   RefreshGrid(hWnd);
1845  					if (message == WM_LBUTTONDOWN)
1846  						NotifyCellClicked(hWnd,SelfIndex);
1847  					else if (message == WM_LBUTTONDBLCLK)
1848  						NotifyCellDbClicked(hWnd,SelfIndex);
1849  					else 
1850  						NotifyCellRClicked(hWnd,SelfIndex);
1851  				 }
1852  			 else
1853  				 {
1854  				  SetFocus(hWnd);
1855  				 }
1856  			}
1857  			break;
1858          case WM_ERASEBKGND:
1859              return TRUE;
1860              break;
1861          case WM_GETDLGCODE:
1862                ReturnValue = DLGC_WANTARROWS|DLGC_WANTCHARS|DLGC_DEFPUSHBUTTON;
1863                   if(wParam == 13)
1864                       {
1865  					 NotifyCellDbClicked(hWnd, SelfIndex);
1866                     if(BGHS[SelfIndex].EDITING)
1867                         {
1868                          CloseEdit(hWnd,SelfIndex);
1869                         }
1870  				   DrawCursor(hWnd,SelfIndex);
1871  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1872  				   RefreshGrid(hWnd);
1873                     BGHS[SelfIndex].EDITING = FALSE;
1874                     break;
1875                       }
1876                if(wParam == VK_ESCAPE)
1877                    {
1878                     if(BGHS[SelfIndex].EDITING)
1879                         {
1880                           BGHS[SelfIndex].EDITING = FALSE;
1881  						 wcscpy_s(BGHS[SelfIndex].editstring, TEXT(""));
1882                           HideCaret(hWnd);
1883                           RefreshGrid(hWnd);
1884                           NotifyEditEnd(hWnd,SelfIndex);
1885                         }
1886                      else
1887                          {
1888                            ReturnValue = 0;
1889                          }
1890                      break;
1891                    }
1892              break;
1893  		case WM_KEYDOWN:
1894                if(wParam == VK_ESCAPE)
1895                    {
1896                     if(BGHS[SelfIndex].EDITING)
1897                         {
1898                           BGHS[SelfIndex].EDITING = FALSE;
1899  						 wcscpy_s(BGHS[SelfIndex].editstring, TEXT(""));
1900                           HideCaret(hWnd);
1901                           RefreshGrid(hWnd);
1902                           NotifyEditEnd(hWnd,SelfIndex);
1903                         }
1904                     break;
1905                    }
1906  			  if(wParam == VK_DELETE)
1907  				  {
1908                     NotifyDelete(hWnd,SelfIndex);
1909  				   break;
1910  				  }
1911                if(wParam == VK_TAB)
1912                    {
1913                     SetFocus(GetParent(hWnd));
1914                     break;
1915                    }
1916  			  if(wParam == VK_NEXT)
1917  				  {
1918  				   RECT gridrect;
1919  				   int rpp;
1920                     if(BGHS[SelfIndex].EDITING)
1921                         {
1922                          CloseEdit(hWnd,SelfIndex);
1923                         }
1924                     if(BGHS[SelfIndex].rows == 0){break;}
1925  				   if(BGHS[SelfIndex].cursorrow == BGHS[SelfIndex].rows){break;}
1926  				   GetClientRect(hWnd,&gridrect);
1927  				   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
1928  				   DrawCursor(hWnd,SelfIndex);
1929  				   BGHS[SelfIndex].cursorrow += rpp;
1930  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
1931  					   {
1932  						BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
1933  					   }
1934  				   NotifyRowChanged(hWnd,SelfIndex);
1935  				   DrawCursor(hWnd,SelfIndex);
1936  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1937                     SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1938  				   RefreshGrid(hWnd);
1939                     break;
1940  				  }
1941  			  if(wParam == VK_PRIOR)
1942  				  {
1943  				   RECT gridrect;
1944  				   int rpp;
1945                     if(BGHS[SelfIndex].EDITING)
1946                         {
1947                          CloseEdit(hWnd,SelfIndex);
1948                         }
1949                     if(BGHS[SelfIndex].rows == 0){break;}
1950  				   if(BGHS[SelfIndex].cursorrow == 1){break;}
1951  				   GetClientRect(hWnd,&gridrect);
1952  				   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
1953  				   DrawCursor(hWnd,SelfIndex);
1954  				   BGHS[SelfIndex].cursorrow -= rpp;
1955  				   if(BGHS[SelfIndex].cursorrow < 1)
1956  					   {
1957  						BGHS[SelfIndex].cursorrow = 1;
1958  					   }
1959  				   NotifyRowChanged(hWnd,SelfIndex);
1960  				   DrawCursor(hWnd,SelfIndex);
1961  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1962  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1963  				   RefreshGrid(hWnd);
1964                     break;
1965  				  }
1966  			  if(wParam == VK_DOWN)
1967  				  {
1968                     if(BGHS[SelfIndex].EDITING)
1969                         {
1970                          CloseEdit(hWnd,SelfIndex);
1971                         }
1972                     if(BGHS[SelfIndex].rows == 0){break;}
1973  				   if(BGHS[SelfIndex].cursorrow == BGHS[SelfIndex].rows){break;}
1974  				   DrawCursor(hWnd,SelfIndex);
1975  				   BGHS[SelfIndex].cursorrow ++;
1976  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
1977  					   {
1978  					    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
1979  					   }
1980  				   else
1981  					   {
1982  				        NotifyRowChanged(hWnd,SelfIndex);
1983  					   }
1984  				   DrawCursor(hWnd,SelfIndex);
1985  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1986  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
1987  				   RefreshGrid(hWnd);
1988                     break;
1989  				  }
1990  			  if(wParam == VK_UP)
1991  				  {
1992                     if(BGHS[SelfIndex].EDITING)
1993                         {
1994                          CloseEdit(hWnd,SelfIndex);
1995                         }
1996                     if(BGHS[SelfIndex].rows == 0){break;}
1997  				   if(BGHS[SelfIndex].cursorrow == 1){break;}
1998  				   DrawCursor(hWnd,SelfIndex);
1999  				   BGHS[SelfIndex].cursorrow --;
2000  				   if(BGHS[SelfIndex].cursorrow < 1)
2001                         {
2002                          BGHS[SelfIndex].cursorrow = 1;
2003                         }
2004                     else
2005                         {
2006  				        NotifyRowChanged(hWnd,SelfIndex);
2007                         }
2008  				   DrawCursor(hWnd,SelfIndex);
2009  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2010  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2011  				   RefreshGrid(hWnd);
2012                     break;
2013  				  }
2014  			  if(wParam == VK_LEFT)
2015  				  {
2016                     int k;
2017                     if(BGHS[SelfIndex].EDITING)
2018                         {
2019                          CloseEdit(hWnd,SelfIndex);
2020                         }
2021                     if(!GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,-1))
2022                         {
2023                          break;
2024                         }
2025  				   DrawCursor(hWnd,SelfIndex);
2026                     k=GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,-1);
2027                     if(k)
2028                         {
2029                          BGHS[SelfIndex].cursorcol = k;
2030  						NotifyColChanged(hWnd,SelfIndex);
2031                         }
2032  				   DrawCursor(hWnd,SelfIndex);
2033  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2034  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2035                     break;
2036  				  }
2037  			  if(wParam == VK_RIGHT)
2038  				  {
2039                     int k;
2040                     if(BGHS[SelfIndex].EDITING)
2041                         {
2042                          CloseEdit(hWnd,SelfIndex);
2043                         }
2044  				   DrawCursor(hWnd,SelfIndex);
2045                     k=GetNextColWithWidth(SelfIndex,BGHS[SelfIndex].cursorcol,1);
2046                     if(k)
2047                         {
2048                          BGHS[SelfIndex].cursorcol = k;
2049  						NotifyColChanged(hWnd,SelfIndex);
2050                         }
2051  				   DrawCursor(hWnd,SelfIndex);
2052  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2053  				   SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2054                     RefreshGrid(hWnd);
2055                     break;
2056  				  }
2057                SetCurrentCellStatus(hWnd,SelfIndex);
2058                if((BGHS[SelfIndex].CURRENTCELLPROTECTED)&&(wParam == 13))
2059                    {
2060  				   DrawCursor(hWnd,SelfIndex);
2061  				   BGHS[SelfIndex].cursorrow ++;
2062  				   if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2063  					   {
2064  					    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2065  					   }
2066  				   else
2067  					   {
2068  				         NotifyRowChanged(hWnd,SelfIndex);
2069  					   }
2070  				   DrawCursor(hWnd,SelfIndex);
2071  				   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2072  				   RefreshGrid(hWnd);
2073                     break;
2074                    }
2075                if(BGHS[SelfIndex].CURRENTCELLPROTECTED){break;}
2076                if(!BGHS[SelfIndex].EDITABLE)
2077                    {
2078                     int ascii;
2079                     ascii=GetASCII(wParam,lParam);
2080                     if(ascii == 13) 
2081                         {
2082  				           DrawCursor(hWnd,SelfIndex);
2083  				           BGHS[SelfIndex].cursorrow ++;
2084  				           if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2085  							   {
2086  								BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2087  							   }
2088  						   else
2089  							   {
2090  							    NotifyRowChanged(hWnd,SelfIndex);
2091  							   }
2092  				           DrawCursor(hWnd,SelfIndex);
2093  						   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2094  						   RefreshGrid(hWnd);
2095                             break;
2096                         }
2097                    }
2098                if((BGHS[SelfIndex].EDITABLE)&&(BGHS[SelfIndex].rows > 0))
2099                    {
2100  				  SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2101  				  DrawCursor(hWnd,SelfIndex);
2102  				  DrawCursor(hWnd,SelfIndex);
2103                        {
2104                          int ascii;
2105                            ascii=GetASCII(wParam,lParam);
2106                            wParam = ascii;
2107                            if((wParam >= 32)&&(wParam <= 125))
2108                                {
2109                                 TCHAR tstring[2];
2110                                 if(!BGHS[SelfIndex].EDITING)
2111                                     {
2112                                      NotifyEditBegin(hWnd,SelfIndex);
2113                                     }
2114                                 BGHS[SelfIndex].EDITING = TRUE;
2115                                 tstring[0]= (TCHAR)wParam;
2116                                 tstring[1]=0x00;
2117                                 DisplayEditString(hWnd,SelfIndex,tstring);
2118                                 break;
2119                                }
2120                            if(wParam == 8) 
2121                                {
2122                                 if(!BGHS[SelfIndex].EDITING)
2123                                     {
2124                                      NotifyEditBegin(hWnd,SelfIndex);
2125                                     }
2126                                BGHS[SelfIndex].EDITING = TRUE;
2127                                if(lstrlen(BGHS[SelfIndex].editstring)==0)
2128                                    {
2129                                     DisplayEditString(hWnd,SelfIndex, TEXT(""));
2130                                     break;
2131                                    }
2132                                else
2133                                    {
2134                                     int j;
2135                                     j=lstrlen(BGHS[SelfIndex].editstring);
2136                                     BGHS[SelfIndex].editstring[j-1]=0x00;
2137                                     DisplayEditString(hWnd,SelfIndex, TEXT(""));
2138                                    }
2139                                 break;
2140                                }
2141                            if(wParam == 13)
2142                                {
2143                                 if(BGHS[SelfIndex].EDITING)
2144                                     {
2145                                      CloseEdit(hWnd,SelfIndex);
2146                                     }
2147  				               DrawCursor(hWnd,SelfIndex);
2148  				               BGHS[SelfIndex].cursorrow ++;
2149  				               if(BGHS[SelfIndex].cursorrow > BGHS[SelfIndex].rows)
2150  								   {
2151  								    BGHS[SelfIndex].cursorrow = BGHS[SelfIndex].rows;
2152  								   }
2153  							   else
2154  								   {
2155  							        NotifyRowChanged(hWnd,SelfIndex);
2156  								   }
2157  				               DrawCursor(hWnd,SelfIndex);
2158  							   SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2159  							   RefreshGrid(hWnd);
2160                                 BGHS[SelfIndex].EDITING = FALSE;
2161                                 break;
2162                                }
2163                        }
2164                    }
2165  			break;
2166          case WM_HSCROLL:
2167                    SetFocus(hWnd);
2168                    if((LOWORD(wParam==SB_LINERIGHT))||(LOWORD(wParam)==SB_PAGERIGHT))
2169                        {
2170                         int cp,np;
2171                         cp=GetScrollPos(hWnd,SB_HORZ);
2172                         SetScrollPos(hWnd,SB_HORZ,cp+1,TRUE);
2173                         cp=GetScrollPos(hWnd,SB_HORZ);
2174                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2175                         BGHS[SelfIndex].homecol = np;
2176                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2177                         RefreshGrid(hWnd);
2178                        }
2179                    if((LOWORD(wParam==SB_LINELEFT))||(LOWORD(wParam)==SB_PAGELEFT))
2180                        {
2181                         int cp,np;
2182                         cp=GetScrollPos(hWnd,SB_HORZ);
2183                         SetScrollPos(hWnd,SB_HORZ,cp-1,TRUE);
2184                         cp=GetScrollPos(hWnd,SB_HORZ);
2185                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2186                         BGHS[SelfIndex].homecol = np;
2187                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2188                         RefreshGrid(hWnd);
2189                        }
2190                    if(LOWORD(wParam)==SB_THUMBTRACK)
2191                        {
2192                         int cp,np;
2193                         cp=HIWORD(wParam);
2194                         np=GetNthVisibleColumn(hWnd,SelfIndex,cp);
2195                         SetScrollPos(hWnd,SB_HORZ,np,TRUE);
2196                         BGHS[SelfIndex].homecol = np;
2197                         SetScrollPos(hWnd,SB_HORZ,cp,TRUE);
2198                         RefreshGrid(hWnd);
2199                        }
2200              break;
2201  		case WM_MOUSEWHEEL :
2202  		{
2203  			short zDelta = (short) HIWORD(wParam);
2204  			::SendMessage(hWnd, WM_VSCROLL, zDelta < 0?SB_LINEDOWN:SB_LINEUP, 0);
2205              return TRUE;
2206  		}
2207  		case WM_VSCROLL:
2208                    SetFocus(hWnd);
2209  				  if(LOWORD(wParam)==SB_THUMBTRACK)
2210  					  {
2211  					   RECT gridrect;
2212  					   int min,max;
2213  					   BGHS[SelfIndex].homerow = HIWORD(wParam);
2214  					   SetScrollPos(hWnd,SB_VERT,HIWORD(wParam),TRUE);
2215  					   GetClientRect(hWnd,&gridrect);
2216  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2217  					   if(HIWORD(wParam)==max)
2218  						   {
2219  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2220  							InvalidateRect(hWnd,&gridrect,TRUE);
2221  						   }
2222  					   else
2223  						   {
2224  					        InvalidateRect(hWnd,&gridrect,FALSE);
2225  						   }
2226  					  }
2227  				  if(LOWORD(wParam)==SB_PAGEDOWN)
2228  					  {
2229  					   RECT gridrect;
2230  					   int min,max,sp,rpp;
2231  					   GetClientRect(hWnd,&gridrect);
2232  					   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
2233  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2234  					   sp=GetScrollPos(hWnd,SB_VERT);
2235  					   sp += rpp;
2236  					   if(sp > max){sp=max;}
2237  					   BGHS[SelfIndex].homerow = sp;
2238  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2239  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2240  					   if(sp==max)
2241  						   {
2242  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2243  							InvalidateRect(hWnd,&gridrect,TRUE);
2244  						   }
2245  					   else
2246  						   {
2247  					        InvalidateRect(hWnd,&gridrect,FALSE);
2248  						   }
2249  					  }
2250  				  if(LOWORD(wParam)==SB_LINEDOWN)
2251  					  {
2252  					   RECT gridrect;
2253  					   int min,max,sp;
2254  					   GetClientRect(hWnd,&gridrect);
2255  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2256  					   sp=GetScrollPos(hWnd,SB_VERT);
2257  					   sp += 1;
2258  					   if(sp > max){sp=max;}
2259  					   BGHS[SelfIndex].homerow = sp;
2260  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2261  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2262  					   if(sp==max)
2263  						   {
2264  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2265  							InvalidateRect(hWnd,&gridrect,TRUE);
2266  						   }
2267  					   else
2268  						   {
2269  					        InvalidateRect(hWnd,&gridrect,FALSE);
2270  						   }
2271  					  }
2272  				  	if(LOWORD(wParam)==SB_PAGEUP)
2273  					  {
2274  					   RECT gridrect;
2275  					   int min,max,sp,rpp;
2276  					   GetClientRect(hWnd,&gridrect);
2277  					   rpp = (gridrect.bottom - (BGHS[SelfIndex].headerrowheight+BGHS[SelfIndex].titleheight))/BGHS[SelfIndex].rowheight;
2278  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2279  					   sp=GetScrollPos(hWnd,SB_VERT);
2280  					   sp -= rpp;
2281  					   if(sp < 1){sp=1;}
2282  					   BGHS[SelfIndex].homerow = sp;
2283  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2284  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2285  					   if(sp==max)
2286  						   {
2287  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2288  							InvalidateRect(hWnd,&gridrect,TRUE);
2289  						   }
2290  					   else
2291  						   {
2292  					        InvalidateRect(hWnd,&gridrect,FALSE);
2293  						   }
2294  					  }
2295  				  	if(LOWORD(wParam)==SB_LINEUP)
2296  					  {
2297  					   RECT gridrect;
2298  					   int min,max,sp;
2299  					   GetClientRect(hWnd,&gridrect);
2300  					   sp=GetScrollPos(hWnd,SB_VERT);
2301  					   GetScrollRange(hWnd,SB_VERT,&min,&max);
2302  					   sp -= 1;
2303  					   if(sp < 1){sp=1;}
2304  					   BGHS[SelfIndex].homerow = sp;
2305  					   SetScrollPos(hWnd,SB_VERT,sp,TRUE);
2306  					   SetHomeRow(hWnd,SelfIndex,sp,BGHS[SelfIndex].homecol);
2307  					   if(sp==max)
2308  						   {
2309  						    gridrect.top = gridrect.bottom - (BGHS[SelfIndex].rowheight);
2310  							InvalidateRect(hWnd,&gridrect,TRUE);
2311  						   }
2312  					   else
2313  						   {
2314  					        InvalidateRect(hWnd,&gridrect,FALSE);
2315  						   }
2316  					  }
2317                        RefreshGrid(hWnd);
2318  			break;
2319  		case WM_DESTROY:
2320  			{ int k;
2321                  if(CountGrids()==0)
2322                      {
2323                       DeleteObject(hfontbody);
2324                       DeleteObject(hfontheader);
2325                       DeleteObject(hfonttitle);
2326                      }
2327                  SendMessage(BGHS[SelfIndex].hlist1,LB_RESETCONTENT,0,0);
2328  			    DestroyWindow(BGHS[SelfIndex].hlist1);
2329  				BGHS[SelfIndex].gridmenu = 0;
2330  				BGHS[SelfIndex].hlist1 = NULL;
2331  				BGHS[SelfIndex].hfont = NULL;
2332  				wcscpy_s(BGHS[SelfIndex].protect, TEXT("U"));
2333  				BGHS[SelfIndex].rows = 100;
2334  				BGHS[SelfIndex].cols = 255;
2335  				BGHS[SelfIndex].homerow = 1;
2336  				BGHS[SelfIndex].homecol = 1;
2337  				BGHS[SelfIndex].rowheight = 20;
2338  				BGHS[SelfIndex].headerrowheight = 20;
2339  				BGHS[SelfIndex].ROWSNUMBERED = TRUE;
2340  				BGHS[SelfIndex].COLUMNSNUMBERED = TRUE;
2341                  BGHS[SelfIndex].DRAWHIGHLIGHT = TRUE;
2342  				BGHS[SelfIndex].cursorcol = 1;
2343  				BGHS[SelfIndex].cursorrow = 1;
2344  				BGHS[SelfIndex].columnwidths[0]=40;
2345  				BGHS[SelfIndex].ADVANCEROW = TRUE;
2346  				BGHS[SelfIndex].cursorcolor = RGB(255,255,255);
2347  				BGHS[SelfIndex].protectcolor = RGB(128,128,128);
2348  				BGHS[SelfIndex].unprotectcolor = RGB(255,255,255);
2349  				for(k=1;k<MAX_COLS;k++)
2350  					{
2351  					 BGHS[SelfIndex].columnwidths[k]=50;
2352  					}
2353  				}
2354  			break;
2355  		case WM_SETFOCUS:
2356  			   DrawCursor(hWnd,SelfIndex);
2357  			   BGHS[SelfIndex].GRIDHASFOCUS	= TRUE;
2358                 DrawCursor(hWnd,SelfIndex);
2359                 SetHomeRow(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2360                 SetHomeCol(hWnd,SelfIndex,BGHS[SelfIndex].cursorrow,BGHS[SelfIndex].cursorcol);
2361                 wParam=MAKEWPARAM(GetMenu(hWnd),BGN_GOTFOCUS);
2362                 lParam = 0;
2363                 SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
2364                     {TEXTMETRIC tm;
2365                      HDC hdc;
2366                      hdc=GetDC(hWnd);
2367                      GetTextMetrics(hdc,&tm);
2368                      ReleaseDC(hWnd,hdc);
2369                      BGHS[SelfIndex].fontascentheight = (int)tm.tmAscent;
2370                      CreateCaret(hWnd,NULL,3,tm.tmAscent);
2371                     }
2372  			   RefreshGrid(hWnd);
2373  			break;
2374  		case WM_KILLFOCUS:
2375                 DestroyCaret();
2376  			   DrawCursor(hWnd,SelfIndex);
2377  			   BGHS[SelfIndex].GRIDHASFOCUS	= FALSE;
2378                 wParam=MAKEWPARAM(GetMenu(hWnd),BGN_LOSTFOCUS);
2379                 lParam = 0;
2380                 SendMessage(GetParent(hWnd),WM_COMMAND,wParam,lParam);
2381                 RefreshGrid(hWnd);
2382  			break;
2383          case WM_SETFONT:
2384                BGHS[SelfIndex].hfont = (HFONT)wParam;
2385                if(!BGHS[SelfIndex].hcolumnheadingfont)
2386                    {
2387                     BGHS[SelfIndex].hcolumnheadingfont = (HFONT)wParam;
2388                    }
2389                if(!BGHS[SelfIndex].htitlefont)
2390                    {
2391                     BGHS[SelfIndex].htitlefont = (HFONT)wParam;
2392                    }
2393                RefreshGrid(hWnd);
2394              break;
2395  		case WM_SIZE:
2396  		{
2397  			if (!BGHS[SelfIndex].SHOWINTEGRALROWS)
2398  				break;
2399  			ShowHscroll(hWnd, SelfIndex);
2400  			ShowVscroll(hWnd, SelfIndex);
2401  			if (BGHS[SelfIndex].VSCROLL)
2402  			{
2403  				static int masterHeight = 0; 
2404  				WINDOWPLACEMENT wp;
2405  				wp.length = sizeof(wp);
2406  				::GetWindowPlacement(hWnd, &wp);
2407  				if (masterHeight < 1)
2408  				{
2409  					masterHeight = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
2410  					if (masterHeight < 1)
2411  						break;
2412  				}
2413  				int outerHeight = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
2414  				int innerHeight = outerHeight;
2415  				innerHeight -= BGHS[SelfIndex].titleheight;
2416  				innerHeight -= BGHS[SelfIndex].headerrowheight;
2417  				if (::GetWindowLong(hWnd, GWL_EXSTYLE) & WS_EX_CLIENTEDGE)
2418  					innerHeight -= ::GetSystemMetrics(SM_CYEDGE) * 2;
2419  				if (BGHS[SelfIndex].HSCROLL)
2420  					innerHeight -= ::GetSystemMetrics(SM_CYHSCROLL);
2421  				if (innerHeight <= BGHS[SelfIndex].rowheight * 4)
2422  					break;
2423  				else
2424  				{
2425  					int remainder = innerHeight % BGHS[SelfIndex].rowheight;
2426  					if ((outerHeight + BGHS[SelfIndex].rowheight - remainder) <= masterHeight)
2427  						outerHeight += BGHS[SelfIndex].rowheight - remainder;
2428  					else
2429  						outerHeight -= remainder;
2430  					wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + outerHeight;
2431  					::SetWindowPlacement(hWnd, &wp);
2432  				}
2433  			}
2434  		}
2435  		break;
2436  		case WM_CREATE:
2437  			  lpcs = (LPCREATESTRUCT)lParam;
2438  			  hInst = lpcs->hInstance;
2439                BG_GridIndex = AddGrid(GetMenu(hWnd));
2440                if(CountGrids()==1)
2441                    {
2442                     hfontbody=CreateFont(16,0,0, 0,
2443  										100,
2444  										FALSE,
2445  										FALSE,FALSE,DEFAULT_CHARSET,
2446  										OUT_DEFAULT_PRECIS,
2447  										CLIP_DEFAULT_PRECIS,
2448  										0,
2449  										0 ,
2450  										TEXT("MS Shell Dlg"));
2451                     hfontheader=CreateFont(18,0,0, 0,FW_HEAVY,FALSE,FALSE,FALSE,DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, 0, 0, TEXT("MS Shell Dlg"));
2452                     hfonttitle=CreateFont(20,0,0, 0,FW_HEAVY,FALSE,FALSE,FALSE,DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, 0, 0, TEXT("MS Shell Dlg"));
2453                    }
2454                if((BG_GridIndex >= 0)&&(BG_GridIndex < MAX_GRIDS))
2455                    {
2456  			          BGHS[BG_GridIndex].gridmenu = GetMenu(hWnd);
2457  			          BGHS[BG_GridIndex].hlist1=CreateWindowEx(WS_EX_CLIENTEDGE, TEXT("LISTBOX"), TEXT(""),
2458  				          WS_CHILD|LBS_STANDARD,50,150,200,100,hWnd,NULL,hInst,NULL);
2459  		              BGHS[BG_GridIndex].hfont = hfontbody;
2460                        BGHS[BG_GridIndex].htitlefont = hfonttitle;
2461                        BGHS[BG_GridIndex].hcolumnheadingfont = hfontheader;
2462  					  wcscpy_s(BGHS[BG_GridIndex].title,lpcs->lpszName);
2463  					  SendMessage(hWnd, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(lpcs->lpszName));
2464                    }
2465                if(BG_GridIndex == -1)
2466                    {
2467                     DestroyWindow(hWnd);
2468                    }
2469  			break;
2470  		default:
2471  			return DefWindowProc(hWnd, message, wParam, lParam);
2472     }
2473     return ReturnValue;
2474  }
2475  int CountGrids()
2476  	{
2477  	 int j,count;
2478  	 count=0;
2479  	 for(j=0;j<MAX_GRIDS;j++)
2480  		 if(BGHS[j].gridmenu != 0)
2481  			 {
2482  			  count++;
2483  			 }
2484  	 return count;
2485  	}
2486  int AddGrid( HMENU menuid)
2487      {
2488       int empty_space = -1;
2489       int returnvalue = 0;
2490       int j;
2491       BOOL MATCH;
2492       MATCH=FALSE;
2493       for(j=0;j<MAX_GRIDS;j++)
2494           {
2495            if(BGHS[j].gridmenu == menuid)
2496                {
2497                 MATCH=TRUE;
2498                 returnvalue=j;
2499                }
2500            if(BGHS[j].gridmenu == 0)
2501                {
2502                 empty_space = j;
2503                }
2504           }
2505       if((!MATCH)&&(empty_space >= 0))
2506           {
2507            BGHS[empty_space].gridmenu = menuid;
2508            returnvalue=empty_space;
2509           }
2510       if(MATCH)
2511           {
2512            return returnvalue+MAX_GRIDS;
2513           }
2514       if((!MATCH)&&(empty_space == -1))
2515           {
2516            return -1;
2517           }
2518       return returnvalue;
2519      }
2520  int FindGrid( HMENU menuid)
2521      {
2522       int returnvalue;
2523       int j;
2524       returnvalue = -1;
2525       for(j=0;j<MAX_GRIDS;j++)
2526           {
2527            if(BGHS[j].gridmenu == menuid)
2528                {
2529                 returnvalue=j;
2530                }
2531           }
2532       return returnvalue;
2533      }
2534  int BinarySearchListBox(HWND lbhWnd,TCHAR* searchtext)
2535      {
2536        int ReturnValue;
2537        int lbcount;
2538        int head,tail,finger;
2539        int FindResult;
2540  	  const size_t bufLen = 1000;
2541        TCHAR tbuffer[bufLen];
2542  	  TCHAR headtext[bufLen];
2543  	  TCHAR tailtext[bufLen];
2544        int p;
2545       BOOL FOUND;
2546       FOUND=FALSE;
2547  	 lbcount = static_cast<int32_t>(SendMessage(lbhWnd, LB_GETCOUNT, 0, 0));
2548       if(lbcount == 0)
2549           {
2550             ReturnValue = LB_ERR;
2551             return ReturnValue;
2552           }
2553       if(lbcount < 12)
2554           {
2555  			 FindResult = static_cast<int32_t>(SendMessage(lbhWnd, LB_FINDSTRING, static_cast<unsigned int>(-1), reinterpret_cast<LPARAM>(searchtext)));
2556            ReturnValue = FindResult;
2557            return ReturnValue;
2558           }
2559       head = 0;
2560       tail = lbcount - 1;
2561  	 auto lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, head, 0);
2562  	 if (static_cast<size_t>(lbTextLen) > bufLen)
2563  		 return 0;
2564       SendMessage(lbhWnd, LB_GETTEXT, head, reinterpret_cast<LPARAM>(headtext));
2565       headtext[9] = 0x00;
2566  	 p=lstrcmp(searchtext,headtext);
2567       if(p==0)
2568           {
2569            ReturnValue = head;
2570            return ReturnValue;
2571           }
2572  	 if(p<0)
2573  		 {
2574  		  ReturnValue = LB_ERR;
2575  		  return ReturnValue;
2576  		 }
2577  	 lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, tail, 0);
2578  	 if (static_cast<size_t>(lbTextLen) > bufLen)
2579  		 return 0;
2580  	 SendMessage(lbhWnd, LB_GETTEXT, tail, reinterpret_cast<LPARAM>(tailtext));
2581       tailtext[9] = 0x00;
2582  	 p=lstrcmp(searchtext,tailtext);
2583       if(p==0)
2584           {
2585            ReturnValue = tail;
2586            return ReturnValue;
2587           }
2588  	 if(p>0)
2589  		 {
2590  		  ReturnValue = LB_ERR;
2591  		  return ReturnValue;
2592  		 }
2593       ReturnValue = LB_ERR;
2594  	 FOUND=FALSE;
2595       while ((!FOUND)&&((tail-head)>1))
2596           {
2597                    finger = head + ((tail - head) / 2);
2598  				  lbTextLen = ::SendMessage(lbhWnd, LB_GETTEXTLEN, finger, 0);
2599  				  if (static_cast<size_t>(lbTextLen) > bufLen)
2600  					  return 0;
2601  				  SendMessage(lbhWnd, LB_GETTEXT, finger, reinterpret_cast<LPARAM>(tbuffer));
2602                   tbuffer[9] = 0x00;
2603                   p=lstrcmp(tbuffer,searchtext);
2604                   if(p==0)
2605                       {
2606                        FOUND=TRUE;
2607                        ReturnValue = finger;
2608                       }
2609                   if(p<0)
2610                       {
2611                        head = finger;
2612                       }
2613                   if(p>0)
2614                           {
2615                           tail = finger;
2616                           }
2617           }
2618       return ReturnValue;
2619      }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</h3>
            <pre><code>1  #include "NppDarkMode.h"
2  #include "DarkMode/DarkMode.h"
3  #include "DarkMode/UAHMenuBar.h"
4  #include <dwmapi.h>
5  #include <uxtheme.h>
6  #include <vssym32.h>
7  #include "Parameters.h"
8  #include "resource.h"
9  #include <shlwapi.h>
10  #include <array>
11  #ifdef __GNUC__
12  #include <cmath>
13  #define WINAPI_LAMBDA WINAPI
14  #ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
15  #define DWMWA_USE_IMMERSIVE_DARK_MODE 20
16  #endif
17  #else
18  #define WINAPI_LAMBDA
19  #endif
20  constexpr COLORREF HEXRGB(DWORD rrggbb) {
21  	return
22  		((rrggbb & 0xFF0000) >> 16) |
23  		((rrggbb & 0x00FF00)) |
24  		((rrggbb & 0x0000FF) << 16);
25  }
26  namespace NppDarkMode
27  {
28  	struct Brushes
29  	{
30  		HBRUSH background = nullptr;
31  		HBRUSH softerBackground = nullptr;
32  		HBRUSH hotBackground = nullptr;
33  		HBRUSH pureBackground = nullptr;
34  		HBRUSH errorBackground = nullptr;
35  		HBRUSH edgeBrush = nullptr;
36  		HBRUSH hotEdgeBrush = nullptr;
37  		HBRUSH disabledEdgeBrush = nullptr;
38  		Brushes(const Colors& colors)
39  			: background(::CreateSolidBrush(colors.background))
40  			, softerBackground(::CreateSolidBrush(colors.softerBackground))
41  			, hotBackground(::CreateSolidBrush(colors.hotBackground))
42  			, pureBackground(::CreateSolidBrush(colors.pureBackground))
43  			, errorBackground(::CreateSolidBrush(colors.errorBackground))
44  			, edgeBrush(::CreateSolidBrush(colors.edge))
45  			, hotEdgeBrush(::CreateSolidBrush(colors.hotEdge))
46  			, disabledEdgeBrush(::CreateSolidBrush(colors.disabledEdge))
47  		{}
48  		~Brushes()
49  		{
50  			::DeleteObject(background);			background = nullptr;
51  			::DeleteObject(softerBackground);	softerBackground = nullptr;
52  			::DeleteObject(hotBackground);		hotBackground = nullptr;
53  			::DeleteObject(pureBackground);		pureBackground = nullptr;
54  			::DeleteObject(errorBackground);	errorBackground = nullptr;
55  			::DeleteObject(edgeBrush);			edgeBrush = nullptr;
56  			::DeleteObject(hotEdgeBrush);		hotEdgeBrush = nullptr;
57  			::DeleteObject(disabledEdgeBrush);	disabledEdgeBrush = nullptr;
58  		}
59  		void change(const Colors& colors)
60  		{
61  			::DeleteObject(background);
62  			::DeleteObject(softerBackground);
63  			::DeleteObject(hotBackground);
64  			::DeleteObject(pureBackground);
65  			::DeleteObject(errorBackground);
66  			::DeleteObject(edgeBrush);
67  			::DeleteObject(hotEdgeBrush);
68  			::DeleteObject(disabledEdgeBrush);
69  			background = ::CreateSolidBrush(colors.background);
70  			softerBackground = ::CreateSolidBrush(colors.softerBackground);
71  			hotBackground = ::CreateSolidBrush(colors.hotBackground);
72  			pureBackground = ::CreateSolidBrush(colors.pureBackground);
73  			errorBackground = ::CreateSolidBrush(colors.errorBackground);
74  			edgeBrush = ::CreateSolidBrush(colors.edge);
75  			hotEdgeBrush = ::CreateSolidBrush(colors.hotEdge);
76  			disabledEdgeBrush = ::CreateSolidBrush(colors.disabledEdge);
77  		}
78  	};
79  	struct Pens
80  	{
81  		HPEN darkerTextPen = nullptr;
82  		HPEN edgePen = nullptr;
83  		HPEN hotEdgePen = nullptr;
84  		HPEN disabledEdgePen = nullptr;
85  		Pens(const Colors& colors)
86  			: darkerTextPen(::CreatePen(PS_SOLID, 1, colors.darkerText))
87  			, edgePen(::CreatePen(PS_SOLID, 1, colors.edge))
88  			, hotEdgePen(::CreatePen(PS_SOLID, 1, colors.hotEdge))
89  			, disabledEdgePen(::CreatePen(PS_SOLID, 1, colors.disabledEdge))
90  		{}
91  		~Pens()
92  		{
93  			::DeleteObject(darkerTextPen);		darkerTextPen = nullptr;
94  			::DeleteObject(edgePen);			edgePen = nullptr;
95  			::DeleteObject(hotEdgePen);			hotEdgePen = nullptr;
96  			::DeleteObject(disabledEdgePen);	disabledEdgePen = nullptr;
97  		}
98  		void change(const Colors& colors)
99  		{
100  			::DeleteObject(darkerTextPen);
101  			::DeleteObject(edgePen);
102  			::DeleteObject(hotEdgePen);
103  			::DeleteObject(disabledEdgePen);
104  			darkerTextPen = ::CreatePen(PS_SOLID, 1, colors.darkerText);
105  			edgePen = ::CreatePen(PS_SOLID, 1, colors.edge);
106  			hotEdgePen = ::CreatePen(PS_SOLID, 1, colors.hotEdge);
107  			disabledEdgePen = ::CreatePen(PS_SOLID, 1, colors.disabledEdge);
108  		}
109  	};
110  	static const Colors darkColors{
111  		HEXRGB(0x202020),	
112  		HEXRGB(0x404040),	
113  		HEXRGB(0x404040),	
114  		HEXRGB(0x202020),	
115  		HEXRGB(0xB00000),	
116  		HEXRGB(0xE0E0E0),	
117  		HEXRGB(0xC0C0C0),	
118  		HEXRGB(0x808080),	
119  		HEXRGB(0xFFFF00),	
120  		HEXRGB(0x646464),	
121  		HEXRGB(0x9B9B9B),	
122  		HEXRGB(0x484848)	
123  	};
124  	static const Colors darkRedColors{
125  		HEXRGB(0x302020),	
126  		HEXRGB(0x504040),	
127  		HEXRGB(0x504040),	
128  		HEXRGB(0x302020),	
129  		HEXRGB(0xC00000),	
130  		HEXRGB(0xE0E0E0),	
131  		HEXRGB(0xC0C0C0),	
132  		HEXRGB(0x808080),	
133  		HEXRGB(0xFFFF00),	
134  		HEXRGB(0x908080),	
135  		HEXRGB(0xBBABAB),	
136  		HEXRGB(0x584848)	
137  	};
138  	static const Colors darkGreenColors{
139  		HEXRGB(0x203020),	
140  		HEXRGB(0x405040),	
141  		HEXRGB(0x405040),	
142  		HEXRGB(0x203020),	
143  		HEXRGB(0xB01000),	
144  		HEXRGB(0xE0E0E0),	
145  		HEXRGB(0xC0C0C0),	
146  		HEXRGB(0x808080),	
147  		HEXRGB(0xFFFF00),	
148  		HEXRGB(0x809080),	
149  		HEXRGB(0xABBBAB),	
150  		HEXRGB(0x485848)	
151  	};
152  	static const Colors darkBlueColors{
153  		HEXRGB(0x202040),	
154  		HEXRGB(0x404060),	
155  		HEXRGB(0x404060),	
156  		HEXRGB(0x202040),	
157  		HEXRGB(0xB00020),	
158  		HEXRGB(0xE0E0E0),	
159  		HEXRGB(0xC0C0C0),	
160  		HEXRGB(0x808080),	
161  		HEXRGB(0xFFFF00),	
162  		HEXRGB(0x8080A0),	
163  		HEXRGB(0xABABCB),	
164  		HEXRGB(0x484868)	
165  	};
166  	static const Colors darkPurpleColors{
167  		HEXRGB(0x302040),	
168  		HEXRGB(0x504060),	
169  		HEXRGB(0x504060),	
170  		HEXRGB(0x302040),	
171  		HEXRGB(0xC00020),	
172  		HEXRGB(0xE0E0E0),	
173  		HEXRGB(0xC0C0C0),	
174  		HEXRGB(0x808080),	
175  		HEXRGB(0xFFFF00),	
176  		HEXRGB(0x9080A0),	
177  		HEXRGB(0xBBABCB),	
178  		HEXRGB(0x584868)	
179  	};
180  	static const Colors darkCyanColors{
181  		HEXRGB(0x203040),	
182  		HEXRGB(0x405060),	
183  		HEXRGB(0x405060),	
184  		HEXRGB(0x203040),	
185  		HEXRGB(0xB01020),	
186  		HEXRGB(0xE0E0E0),	
187  		HEXRGB(0xC0C0C0),	
188  		HEXRGB(0x808080),	
189  		HEXRGB(0xFFFF00),	
190  		HEXRGB(0x8090A0),	
191  		HEXRGB(0xBBBBCB),	
192  		HEXRGB(0x485868)	
193  	};
194  	static const Colors darkOliveColors{
195  		HEXRGB(0x303020),	
196  		HEXRGB(0x505040),	
197  		HEXRGB(0x505040),	
198  		HEXRGB(0x303020),	
199  		HEXRGB(0xC01000),	
200  		HEXRGB(0xE0E0E0),	
201  		HEXRGB(0xC0C0C0),	
202  		HEXRGB(0x808080),	
203  		HEXRGB(0xFFFF00),	
204  		HEXRGB(0x909080),	
205  		HEXRGB(0xBBBBAB),	
206  		HEXRGB(0x585848)	
207  	};
208  	Colors darkCustomizedColors{
209  		HEXRGB(0x202020),	
210  		HEXRGB(0x404040),	
211  		HEXRGB(0x404040),	
212  		HEXRGB(0x202020),	
213  		HEXRGB(0xB00000),	
214  		HEXRGB(0xE0E0E0),	
215  		HEXRGB(0xC0C0C0),	
216  		HEXRGB(0x808080),	
217  		HEXRGB(0xFFFF00),	
218  		HEXRGB(0x646464),	
219  		HEXRGB(0x9B9B9B),	
220  		HEXRGB(0x484848)	
221  	};
222  	ColorTone g_colorToneChoice = blackTone;
223  	void setDarkTone(ColorTone colorToneChoice)
224  	{
225  		g_colorToneChoice = colorToneChoice;
226  	}
227  	struct Theme
228  	{
229  		Colors _colors;
230  		Brushes _brushes;
231  		Pens _pens;
232  		Theme(const Colors& colors)
233  			: _colors(colors)
234  			, _brushes(colors)
235  			, _pens(colors)
236  		{}
237  		void change(const Colors& colors)
238  		{
239  			_colors = colors;
240  			_brushes.change(colors);
241  			_pens.change(colors);
242  		}
243  	};
244  	Theme tDefault(darkColors);
245  	Theme tR(darkRedColors);
246  	Theme tG(darkGreenColors);
247  	Theme tB(darkBlueColors);
248  	Theme tP(darkPurpleColors);
249  	Theme tC(darkCyanColors);
250  	Theme tO(darkOliveColors);
251  	Theme tCustom(darkCustomizedColors);
252  	Theme& getTheme()
253  	{
254  		switch (g_colorToneChoice)
255  		{
256  			case redTone:
257  				return tR;
258  			case greenTone:
259  				return tG;
260  			case blueTone:
261  				return tB;
262  			case purpleTone:
263  				return tP;
264  			case cyanTone:
265  				return tC;
266  			case oliveTone:
267  				return tO;
268  			case customizedTone:
269  				return tCustom;
270  			default:
271  				return tDefault;
272  		}
273  	}
274  	static Options _options;			
275  	static AdvancedOptions g_advOptions;
276  	Options configuredOptions()
277  	{
278  		NppGUI nppGui = NppParameters::getInstance().getNppGUI();
279  		Options opt;
280  		opt.enable = nppGui._darkmode._isEnabled;
281  		opt.enableMenubar = opt.enable;
282  		opt.enablePlugin = nppGui._darkmode._isEnabledPlugin;
283  		g_colorToneChoice = nppGui._darkmode._colorTone;
284  		tCustom.change(nppGui._darkmode._customColors);
285  		return opt;
286  	}
287  	static bool g_isAtLeastWindows10 = false;
288  	static bool g_isWine = false;
289  	void initDarkMode()
290  	{
291  		_options = configuredOptions();
292  		initExperimentalDarkMode();
293  		initAdvancedOptions();
294  		g_isAtLeastWindows10 = NppDarkMode::isWindows10();
295  		if (!g_isAtLeastWindows10)
296  		{
297  			g_advOptions._enableWindowsMode = false;
298  		}
299  		else if (NppDarkMode::isWindowsModeEnabled())
300  		{
301  			NppParameters& nppParam = NppParameters::getInstance();
302  			NppGUI& nppGUI = nppParam.getNppGUI();
303  			nppGUI._darkmode._isEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
304  			_options.enable = nppGUI._darkmode._isEnabled;
305  			_options.enableMenubar = _options.enable;
306  		}
307  		setDarkMode(_options.enable, true);
308  		using PWINEGETVERSION = const CHAR* (__cdecl *)(void);
309  		PWINEGETVERSION pWGV = nullptr;
310  		auto hNtdllModule = GetModuleHandle(L"ntdll.dll");
311  		if (hNtdllModule)
312  		{
313  			pWGV = reinterpret_cast<PWINEGETVERSION>(GetProcAddress(hNtdllModule, "wine_get_version"));
314  		}
315  		g_isWine = pWGV != nullptr;
316  	}
317  	void refreshDarkMode(HWND hwnd, bool forceRefresh)
318  	{
319  		bool supportedChanged = false;
320  		auto config = configuredOptions();
321  		if (_options.enable != config.enable)
322  		{
323  			supportedChanged = true;
324  			_options.enable = config.enable;
325  			setDarkMode(_options.enable, _options.enable);
326  		}
327  		if (_options.enableMenubar != config.enableMenubar)
328  		{
329  			supportedChanged = true;
330  			_options.enableMenubar = config.enableMenubar;
331  		}
332  		if (!supportedChanged && !forceRefresh)
333  		{
334  			return;
335  		}
336  		HWND hwndRoot = GetAncestor(hwnd, GA_ROOTOWNER);
337  		::SendMessage(hwndRoot, NPPM_INTERNAL_REFRESHDARKMODE, static_cast<WPARAM>(!forceRefresh), 0);
338  	}
339  	void initAdvancedOptions()
340  	{
341  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
342  		g_advOptions = nppGui._darkmode._advOptions;
343  	}
344  	bool isEnabled()
345  	{
346  		return _options.enable;
347  	}
348  	bool isEnabledForPlugins()
349  	{
350  		return _options.enablePlugin;
351  	}
352  	bool isDarkMenuEnabled()
353  	{
354  		return _options.enableMenubar;
355  	}
356  	bool isExperimentalActive()
357  	{
358  		return g_darkModeEnabled;
359  	}
360  	bool isExperimentalSupported()
361  	{
362  		return g_darkModeSupported;
363  	}
364  	bool isWindowsModeEnabled()
365  	{
366  		return g_advOptions._enableWindowsMode;
367  	}
368  	void setWindowsMode(bool enable)
369  	{
370  		g_advOptions._enableWindowsMode = enable;
371  	}
372  	void setThemeName(const generic_string& newThemeName)
373  	{
374  		if (NppDarkMode::isEnabled())
375  			g_advOptions._darkDefaults._xmlFileName = newThemeName;
376  		else
377  			g_advOptions._lightDefaults._xmlFileName = newThemeName;
378  	}
379  	generic_string getThemeName()
380  	{
381  		auto& theme = NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._xmlFileName : g_advOptions._lightDefaults._xmlFileName;
382  		return (lstrcmp(theme.c_str(), L"stylers.xml") == 0) ? L"" : theme;
383  	}
384  	static bool g_isCustomToolIconUsed = NppParameters::getInstance().getCustomizedToolIcons() != nullptr;
385  	void setToolBarIconSet(int state2Set, bool useDark)
386  	{
387  		if (useDark)
388  			g_advOptions._darkDefaults._toolBarIconSet = state2Set;
389  		else
390  			g_advOptions._lightDefaults._toolBarIconSet = state2Set;
391  	}
392  	int getToolBarIconSet(bool useDark)
393  	{
394  		if (g_isCustomToolIconUsed)
395  		{
396  			return -1;
397  		}
398  		return useDark ? g_advOptions._darkDefaults._toolBarIconSet : g_advOptions._lightDefaults._toolBarIconSet;
399  	}
400  	void setTabIconSet(bool useAltIcons, bool useDark)
401  	{
402  		if (useDark)
403  			g_advOptions._darkDefaults._tabIconSet = useAltIcons ? 1 : 2;
404  		else	
405  			g_advOptions._lightDefaults._tabIconSet = useAltIcons ? 1 : 0;
406  	}
407  	int getTabIconSet(bool useDark)
408  	{
409  		return useDark ? g_advOptions._darkDefaults._tabIconSet : g_advOptions._lightDefaults._tabIconSet;
410  	}
411  	bool useTabTheme()
412  	{
413  		return NppDarkMode::isEnabled() ? g_advOptions._darkDefaults._tabUseTheme : g_advOptions._lightDefaults._tabUseTheme;
414  	}
415  	void setAdvancedOptions()
416  	{
417  		NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
418  		auto& advOpt = nppGui._darkmode._advOptions;
419  		advOpt = g_advOptions;
420  	}
421  	bool isWindows10()
422  	{
423  		return IsWindows10();
424  	}
425  	bool isWindows11()
426  	{
427  		return IsWindows11();
428  	}
429  	DWORD getWindowsBuildNumber()
430  	{
431  		return GetWindowsBuildNumber();
432  	}
433  	COLORREF invertLightness(COLORREF c)
434  	{
435  		WORD h = 0;
436  		WORD s = 0;
437  		WORD l = 0;
438  		ColorRGBToHLS(c, &h, &l, &s);
439  		l = 240 - l;
440  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
441  		return invert_c;
442  	}
443  	COLORREF invertLightnessSofter(COLORREF c)
444  	{
445  		WORD h = 0;
446  		WORD s = 0;
447  		WORD l = 0;
448  		ColorRGBToHLS(c, &h, &l, &s);
449  		l = std::min<WORD>(240U - l, 211U);
450  		COLORREF invert_c = ColorHLSToRGB(h, l, s);
451  		return invert_c;
452  	}
453  	static TreeViewStyle g_treeViewStyle = TreeViewStyle::classic;
454  	static COLORREF g_treeViewBg = NppParameters::getInstance().getCurrentDefaultBgColor();
455  	static double g_lighnessTreeView = 50.0;
456  	double calculatePerceivedLighness(COLORREF c)
457  	{
458  		auto linearValue = [](double colorChannel) -> double
459  		{
460  			colorChannel /= 255.0;
461  			if (colorChannel <= 0.04045)
462  				return colorChannel / 12.92;
463  			return std::pow(((colorChannel + 0.055) / 1.055), 2.4);
464  		};
465  		double r = linearValue(static_cast<double>(GetRValue(c)));
466  		double g = linearValue(static_cast<double>(GetGValue(c)));
467  		double b = linearValue(static_cast<double>(GetBValue(c)));
468  		double luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
469  		double lighness = (luminance <= 216.0 / 24389.0) ? (luminance * 24389.0 / 27.0) : (std::pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0);
470  		return lighness;
471  	}
472  	COLORREF getBackgroundColor()         { return getTheme()._colors.background; }
473  	COLORREF getSofterBackgroundColor()   { return getTheme()._colors.softerBackground; }
474  	COLORREF getHotBackgroundColor()      { return getTheme()._colors.hotBackground; }
475  	COLORREF getDarkerBackgroundColor()   { return getTheme()._colors.pureBackground; }
476  	COLORREF getErrorBackgroundColor()    { return getTheme()._colors.errorBackground; }
477  	COLORREF getTextColor()               { return getTheme()._colors.text; }
478  	COLORREF getDarkerTextColor()         { return getTheme()._colors.darkerText; }
479  	COLORREF getDisabledTextColor()       { return getTheme()._colors.disabledText; }
480  	COLORREF getLinkTextColor()           { return getTheme()._colors.linkText; }
481  	COLORREF getEdgeColor()               { return getTheme()._colors.edge; }
482  	COLORREF getHotEdgeColor()            { return getTheme()._colors.hotEdge; }
483  	COLORREF getDisabledEdgeColor()       { return getTheme()._colors.disabledEdge; }
484  	HBRUSH getBackgroundBrush()           { return getTheme()._brushes.background; }
485  	HBRUSH getSofterBackgroundBrush()     { return getTheme()._brushes.softerBackground; }
486  	HBRUSH getHotBackgroundBrush()        { return getTheme()._brushes.hotBackground; }
487  	HBRUSH getDarkerBackgroundBrush()     { return getTheme()._brushes.pureBackground; }
488  	HBRUSH getErrorBackgroundBrush()      { return getTheme()._brushes.errorBackground; }
489  	HBRUSH getEdgeBrush()                 { return getTheme()._brushes.edgeBrush; }
490  	HBRUSH getHotEdgeBrush()              { return getTheme()._brushes.hotEdgeBrush; }
491  	HBRUSH getDisabledEdgeBrush()         { return getTheme()._brushes.disabledEdgeBrush; }
492  	HPEN getDarkerTextPen()               { return getTheme()._pens.darkerTextPen; }
493  	HPEN getEdgePen()                     { return getTheme()._pens.edgePen; }
494  	HPEN getHotEdgePen()                  { return getTheme()._pens.hotEdgePen; }
495  	HPEN getDisabledEdgePen()             { return getTheme()._pens.disabledEdgePen; }
496  	void setBackgroundColor(COLORREF c)
497  	{
498  		Colors clrs = getTheme()._colors;
499  		clrs.background = c;
500  		getTheme().change(clrs);
501  	}
502  	void setSofterBackgroundColor(COLORREF c)
503  	{
504  		Colors clrs = getTheme()._colors;
505  		clrs.softerBackground = c;
506  		getTheme().change(clrs);
507  	}
508  	void setHotBackgroundColor(COLORREF c)
509  	{
510  		Colors clrs = getTheme()._colors;
511  		clrs.hotBackground = c;
512  		getTheme().change(clrs);
513  	}
514  	void setDarkerBackgroundColor(COLORREF c)
515  	{
516  		Colors clrs = getTheme()._colors;
517  		clrs.pureBackground = c;
518  		getTheme().change(clrs);
519  	}
520  	void setErrorBackgroundColor(COLORREF c)
521  	{
522  		Colors clrs = getTheme()._colors;
523  		clrs.errorBackground = c;
524  		getTheme().change(clrs);
525  	}
526  	void setTextColor(COLORREF c)
527  	{
528  		Colors clrs = getTheme()._colors;
529  		clrs.text = c;
530  		getTheme().change(clrs);
531  	}
532  	void setDarkerTextColor(COLORREF c)
533  	{
534  		Colors clrs = getTheme()._colors;
535  		clrs.darkerText = c;
536  		getTheme().change(clrs);
537  	}
538  	void setDisabledTextColor(COLORREF c)
539  	{
540  		Colors clrs = getTheme()._colors;
541  		clrs.disabledText = c;
542  		getTheme().change(clrs);
543  	}
544  	void setLinkTextColor(COLORREF c)
545  	{
546  		Colors clrs = getTheme()._colors;
547  		clrs.linkText = c;
548  		getTheme().change(clrs);
549  	}
550  	void setEdgeColor(COLORREF c)
551  	{
552  		Colors clrs = getTheme()._colors;
553  		clrs.edge = c;
554  		getTheme().change(clrs);
555  	}
556  	void setHotEdgeColor(COLORREF c)
557  	{
558  		Colors clrs = getTheme()._colors;
559  		clrs.hotEdge = c;
560  		getTheme().change(clrs);
561  	}
562  	void setDisabledEdgeColor(COLORREF c)
563  	{
564  		Colors clrs = getTheme()._colors;
565  		clrs.disabledEdge = c;
566  		getTheme().change(clrs);
567  	}
568  	Colors getDarkModeDefaultColors()
569  	{
570  		return darkColors;
571  	}
572  	void changeCustomTheme(const Colors& colors)
573  	{
574  		tCustom.change(colors);
575  	}
576  	void handleSettingChange(HWND hwnd, LPARAM lParam, bool isFromBtn)
577  	{
578  		UNREFERENCED_PARAMETER(hwnd);
579  		if (!isExperimentalSupported())
580  		{
581  			return;
582  		}
583  		if (IsColorSchemeChangeMessage(lParam) || isFromBtn)
584  		{
585  			g_darkModeEnabled = NppDarkMode::isDarkModeReg() && !IsHighContrast();
586  		}
587  	}
588  	bool isDarkModeReg()
589  	{
590  		DWORD data{};
591  		DWORD dwBufSize = sizeof(data);
592  		LPCTSTR lpSubKey = L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
593  		LPCTSTR lpValue = L"AppsUseLightTheme";
594  		auto result = RegGetValue(HKEY_CURRENT_USER, lpSubKey, lpValue, RRF_RT_REG_DWORD, nullptr, &data, &dwBufSize);
595  		if (result != ERROR_SUCCESS)
596  		{
597  			return false;
598  		}
599  		return data == 0UL;
600  	}
601  	bool runUAHWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* lr)
602  	{
603  		static HTHEME g_menuTheme = nullptr;
604  		UNREFERENCED_PARAMETER(wParam);
605  		switch (message)
606  		{
607  		case WM_UAHDRAWMENU:
608  		{
609  			UAHMENU* pUDM = (UAHMENU*)lParam;
610  			RECT rc{};
611  			{
612  				MENUBARINFO mbi{};
613  				mbi.cbSize = sizeof(MENUBARINFO);
614  				GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi);
615  				RECT rcWindow{};
616  				GetWindowRect(hWnd, &rcWindow);
617  				rc = mbi.rcBar;
618  				OffsetRect(&rc, -rcWindow.left, -rcWindow.top);
619  				rc.top -= 1;
620  			}
621  			FillRect(pUDM->hdc, &rc, NppDarkMode::getDarkerBackgroundBrush());
622  			*lr = 0;
623  			return true;
624  		}
625  		case WM_UAHDRAWMENUITEM:
626  		{
627  			UAHDRAWMENUITEM* pUDMI = (UAHDRAWMENUITEM*)lParam;
628  			wchar_t menuString[256] = { '\0' };
629  			MENUITEMINFO mii{};
630  			{
631  				mii.cbSize = sizeof(MENUITEMINFO);
632  				mii.fMask = MIIM_STRING;
633  				mii.dwTypeData = menuString;
634  				mii.cch = (sizeof(menuString) / 2) - 1;
635  				GetMenuItemInfo(pUDMI->um.hmenu, pUDMI->umi.iPosition, TRUE, &mii);
636  			}
637  			DWORD dwFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
638  			int iTextStateID = MPI_NORMAL;
639  			int iBackgroundStateID = MPI_NORMAL;
640  			{
641  				if ((pUDMI->dis.itemState & ODS_INACTIVE) | (pUDMI->dis.itemState & ODS_DEFAULT))
642  				{
643  					iTextStateID = MPI_NORMAL;
644  					iBackgroundStateID = MPI_NORMAL;
645  				}
646  				if (pUDMI->dis.itemState & ODS_HOTLIGHT)
647  				{
648  					iTextStateID = MPI_HOT;
649  					iBackgroundStateID = MPI_HOT;
650  				}
651  				if (pUDMI->dis.itemState & ODS_SELECTED)
652  				{
653  					iTextStateID = MPI_HOT;
654  					iBackgroundStateID = MPI_HOT;
655  				}
656  				if ((pUDMI->dis.itemState & ODS_GRAYED) || (pUDMI->dis.itemState & ODS_DISABLED))
657  				{
658  					iTextStateID = MPI_DISABLED;
659  					iBackgroundStateID = MPI_DISABLED;
660  				}
661  				if (pUDMI->dis.itemState & ODS_NOACCEL)
662  				{
663  					dwFlags |= DT_HIDEPREFIX;
664  				}
665  			}
666  			if (!g_menuTheme)
667  			{
668  				g_menuTheme = OpenThemeData(hWnd, L"Menu");
669  			}
670  			if (iBackgroundStateID == MPI_NORMAL || iBackgroundStateID == MPI_DISABLED)
671  			{
672  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getDarkerBackgroundBrush());
673  			}
674  			else if (iBackgroundStateID == MPI_HOT || iBackgroundStateID == MPI_DISABLEDHOT)
675  			{
676  				FillRect(pUDMI->um.hdc, &pUDMI->dis.rcItem, NppDarkMode::getHotBackgroundBrush());
677  			}
678  			else
679  			{
680  				DrawThemeBackground(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iBackgroundStateID, &pUDMI->dis.rcItem, nullptr);
681  			}
682  			DTTOPTS dttopts{};
683  			dttopts.dwSize = sizeof(DTTOPTS);
684  			if (iTextStateID == MPI_NORMAL || iTextStateID == MPI_HOT)
685  			{
686  				dttopts.dwFlags |= DTT_TEXTCOLOR;
687  				dttopts.crText = NppDarkMode::getTextColor();
688  			}
689  			DrawThemeTextEx(g_menuTheme, pUDMI->um.hdc, MENU_POPUPITEM, iTextStateID, menuString, mii.cch, dwFlags, &pUDMI->dis.rcItem, &dttopts);
690  			*lr = 0;
691  			return true;
692  		}
693  		case WM_THEMECHANGED:
694  		{
695  			if (g_menuTheme)
696  			{
697  				CloseThemeData(g_menuTheme);
698  				g_menuTheme = nullptr;
699  			}
700  			return false;
701  		}
702  		default:
703  			return false;
704  		}
705  	}
706  	void drawUAHMenuNCBottomLine(HWND hWnd)
707  	{
708  		MENUBARINFO mbi{};
709  		mbi.cbSize = sizeof(MENUBARINFO);
710  		if (!GetMenuBarInfo(hWnd, OBJID_MENU, 0, &mbi))
711  		{
712  			return;
713  		}
714  		RECT rcClient{};
715  		GetClientRect(hWnd, &rcClient);
716  		MapWindowPoints(hWnd, nullptr, (POINT*)&rcClient, 2);
717  		RECT rcWindow{};
718  		GetWindowRect(hWnd, &rcWindow);
719  		OffsetRect(&rcClient, -rcWindow.left, -rcWindow.top);
720  		RECT rcAnnoyingLine = rcClient;
721  		rcAnnoyingLine.bottom = rcAnnoyingLine.top;
722  		rcAnnoyingLine.top--;
723  		HDC hdc = GetWindowDC(hWnd);
724  		FillRect(hdc, &rcAnnoyingLine, NppDarkMode::getDarkerBackgroundBrush());
725  		ReleaseDC(hWnd, hdc);
726  	}
727  	void initExperimentalDarkMode()
728  	{
729  		::InitDarkMode();
730  	}
731  	void setDarkMode(bool useDark, bool fixDarkScrollbar)
732  	{
733  		::SetDarkMode(useDark, fixDarkScrollbar);
734  	}
735  	void allowDarkModeForApp(bool allow)
736  	{
737  		::AllowDarkModeForApp(allow);
738  	}
739  	bool allowDarkModeForWindow(HWND hWnd, bool allow)
740  	{
741  		return ::AllowDarkModeForWindow(hWnd, allow);
742  	}
743  	void setTitleBarThemeColor(HWND hWnd)
744  	{
745  		::RefreshTitleBarThemeColor(hWnd);
746  	}
747  	void enableDarkScrollBarForWindowAndChildren(HWND hwnd)
748  	{
749  		::EnableDarkScrollBarForWindowAndChildren(hwnd);
750  	}
751  	void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width, int height)
752  	{
753  		auto holdBrush = ::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
754  		auto holdPen = ::SelectObject(hdc, hpen);
755  		::RoundRect(hdc, rect.left, rect.top, rect.right, rect.bottom, width, height);
756  		::SelectObject(hdc, holdBrush);
757  		::SelectObject(hdc, holdPen);
758  	}
759  	struct ButtonData
760  	{
761  		HTHEME hTheme = nullptr;
762  		int iStateID = 0;
763  		~ButtonData()
764  		{
765  			closeTheme();
766  		}
767  		bool ensureTheme(HWND hwnd)
768  		{
769  			if (!hTheme)
770  			{
771  				hTheme = OpenThemeData(hwnd, WC_BUTTON);
772  			}
773  			return hTheme != nullptr;
774  		}
775  		void closeTheme()
776  		{
777  			if (hTheme)
778  			{
779  				CloseThemeData(hTheme);
780  				hTheme = nullptr;
781  			}
782  		}
783  	};
784  	void renderButton(HWND hwnd, HDC hdc, HTHEME hTheme, int iPartID, int iStateID)
785  	{
786  		RECT rcClient{};
787  		WCHAR szText[256] = { '\0' };
788  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
789  		DWORD uiState = static_cast<DWORD>(SendMessage(hwnd, WM_QUERYUISTATE, 0, 0));
790  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
791  		HFONT hFont = nullptr;
792  		HFONT hOldFont = nullptr;
793  		HFONT hCreatedFont = nullptr;
794  		LOGFONT lf{};
795  		if (SUCCEEDED(GetThemeFont(hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
796  		{
797  			hCreatedFont = CreateFontIndirect(&lf);
798  			hFont = hCreatedFont;
799  		}
800  		if (!hFont) {
801  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
802  		}
803  		hOldFont = static_cast<HFONT>(SelectObject(hdc, hFont));
804  		DWORD dtFlags = DT_LEFT; 
805  		dtFlags |= (nStyle & BS_MULTILINE) ? DT_WORDBREAK : DT_SINGLELINE;
806  		dtFlags |= ((nStyle & BS_CENTER) == BS_CENTER) ? DT_CENTER : (nStyle & BS_RIGHT) ? DT_RIGHT : 0;
807  		dtFlags |= ((nStyle & BS_VCENTER) == BS_VCENTER) ? DT_VCENTER : (nStyle & BS_BOTTOM) ? DT_BOTTOM : 0;
808  		dtFlags |= (uiState & UISF_HIDEACCEL) ? DT_HIDEPREFIX : 0;
809  		if (!(nStyle & BS_MULTILINE) && !(nStyle & BS_BOTTOM) && !(nStyle & BS_TOP))
810  		{
811  			dtFlags |= DT_VCENTER;
812  		}
813  		GetClientRect(hwnd, &rcClient);
814  		GetWindowText(hwnd, szText, _countof(szText));
815  		SIZE szBox = { 13, 13 };
816  		GetThemePartSize(hTheme, hdc, iPartID, iStateID, NULL, TS_DRAW, &szBox);
817  		RECT rcText = rcClient;
818  		GetThemeBackgroundContentRect(hTheme, hdc, iPartID, iStateID, &rcClient, &rcText);
819  		RECT rcBackground = rcClient;
820  		if (dtFlags & DT_SINGLELINE)
821  		{
822  			rcBackground.top += (rcText.bottom - rcText.top - szBox.cy) / 2;
823  		}
824  		rcBackground.bottom = rcBackground.top + szBox.cy;
825  		rcBackground.right = rcBackground.left + szBox.cx;
826  		rcText.left = rcBackground.right + 3;
827  		DrawThemeParentBackground(hwnd, hdc, &rcClient);
828  		DrawThemeBackground(hTheme, hdc, iPartID, iStateID, &rcBackground, nullptr);
829  		DTTOPTS dtto{};
830  		dtto.dwSize = sizeof(DTTOPTS);
831  		dtto.dwFlags = DTT_TEXTCOLOR;
832  		dtto.crText = NppDarkMode::getTextColor();
833  		if (nStyle & WS_DISABLED)
834  		{
835  			dtto.crText = NppDarkMode::getDisabledTextColor();
836  		}
837  		DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags, &rcText, &dtto);
838  		if ((nState & BST_FOCUS) && !(uiState & UISF_HIDEFOCUS))
839  		{
840  			RECT rcTextOut = rcText;
841  			dtto.dwFlags |= DTT_CALCRECT;
842  			DrawThemeTextEx(hTheme, hdc, iPartID, iStateID, szText, -1, dtFlags | DT_CALCRECT, &rcTextOut, &dtto);
843  			RECT rcFocus = rcTextOut;
844  			rcFocus.bottom++;
845  			rcFocus.left--;
846  			rcFocus.right++;
847  			DrawFocusRect(hdc, &rcFocus);
848  		}
849  		if (hCreatedFont) DeleteObject(hCreatedFont);
850  		SelectObject(hdc, hOldFont);
851  	}
852  	void paintButton(HWND hwnd, HDC hdc, ButtonData& buttonData)
853  	{
854  		DWORD nState = static_cast<DWORD>(SendMessage(hwnd, BM_GETSTATE, 0, 0));
855  		const auto nStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
856  		const auto nButtonStyle = nStyle & BS_TYPEMASK;
857  		int iPartID = BP_CHECKBOX;
858  		if (nButtonStyle == BS_CHECKBOX || nButtonStyle == BS_AUTOCHECKBOX || nButtonStyle == BS_3STATE || nButtonStyle == BS_AUTO3STATE)
859  		{
860  			iPartID = BP_CHECKBOX;
861  		}
862  		else if (nButtonStyle == BS_RADIOBUTTON || nButtonStyle == BS_AUTORADIOBUTTON)
863  		{
864  			iPartID = BP_RADIOBUTTON;
865  		}
866  		else
867  		{
868  			assert(false);
869  		}
870  		int iStateID = RBS_UNCHECKEDNORMAL;
871  		if (nStyle & WS_DISABLED)		iStateID = RBS_UNCHECKEDDISABLED;
872  		else if (nState & BST_PUSHED)	iStateID = RBS_UNCHECKEDPRESSED;
873  		else if (nState & BST_HOT)		iStateID = RBS_UNCHECKEDHOT;
874  		if (nState & BST_CHECKED)		iStateID += 4;
875  		if (BufferedPaintRenderAnimation(hwnd, hdc))
876  		{
877  			return;
878  		}
879  		BP_ANIMATIONPARAMS animParams{};
880  		animParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
881  		animParams.style = BPAS_LINEAR;
882  		if (iStateID != buttonData.iStateID)
883  		{
884  			GetThemeTransitionDuration(buttonData.hTheme, iPartID, buttonData.iStateID, iStateID, TMT_TRANSITIONDURATIONS, &animParams.dwDuration);
885  		}
886  		RECT rcClient{};
887  		GetClientRect(hwnd, &rcClient);
888  		HDC hdcFrom = nullptr;
889  		HDC hdcTo = nullptr;
890  		HANIMATIONBUFFER hbpAnimation = BeginBufferedAnimation(hwnd, hdc, &rcClient, BPBF_COMPATIBLEBITMAP, nullptr, &animParams, &hdcFrom, &hdcTo);
891  		if (hbpAnimation)
892  		{
893  			if (hdcFrom)
894  			{
895  				renderButton(hwnd, hdcFrom, buttonData.hTheme, iPartID, buttonData.iStateID);
896  			}
897  			if (hdcTo)
898  			{
899  				renderButton(hwnd, hdcTo, buttonData.hTheme, iPartID, iStateID);
900  			}
901  			buttonData.iStateID = iStateID;
902  			EndBufferedAnimation(hbpAnimation, TRUE);
903  		}
904  		else
905  		{
906  			renderButton(hwnd, hdc, buttonData.hTheme, iPartID, iStateID);
907  			buttonData.iStateID = iStateID;
908  		}
909  	}
910  	constexpr UINT_PTR g_buttonSubclassID = 42;
911  	LRESULT CALLBACK ButtonSubclass(
912  		HWND hWnd,
913  		UINT uMsg,
914  		WPARAM wParam,
915  		LPARAM lParam,
916  		UINT_PTR uIdSubclass,
917  		DWORD_PTR dwRefData
918  	)
919  	{
920  		UNREFERENCED_PARAMETER(uIdSubclass);
921  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
922  		switch (uMsg)
923  		{
924  			case WM_UPDATEUISTATE:
925  				if (HIWORD(wParam) & (UISF_HIDEACCEL | UISF_HIDEFOCUS))
926  				{
927  					InvalidateRect(hWnd, nullptr, FALSE);
928  				}
929  				break;
930  			case WM_NCDESTROY:
931  				RemoveWindowSubclass(hWnd, ButtonSubclass, g_buttonSubclassID);
932  				delete pButtonData;
933  				break;
934  			case WM_ERASEBKGND:
935  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
936  				{
937  					return TRUE;
938  				}
939  				else
940  				{
941  					break;
942  				}
943  			case WM_THEMECHANGED:
944  				pButtonData->closeTheme();
945  				break;
946  			case WM_PRINTCLIENT:
947  			case WM_PAINT:
948  				if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
949  				{
950  					PAINTSTRUCT ps{};
951  					HDC hdc = reinterpret_cast<HDC>(wParam);
952  					if (!hdc)
953  					{
954  						hdc = BeginPaint(hWnd, &ps);
955  					}
956  					paintButton(hWnd, hdc, *pButtonData);
957  					if (ps.hdc)
958  					{
959  						EndPaint(hWnd, &ps);
960  					}
961  					return 0;
962  				}
963  				else
964  				{
965  					break;
966  				}
967  			case WM_SIZE:
968  			case WM_DESTROY:
969  				BufferedPaintStopAllAnimations(hWnd);
970  				break;
971  			case WM_ENABLE:
972  				if (NppDarkMode::isEnabled())
973  				{
974  					LRESULT lr = DefWindowProc(hWnd, uMsg, wParam, lParam);
975  					InvalidateRect(hWnd, nullptr, FALSE);
976  					return lr;
977  				}
978  				break;
979  		}
980  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
981  	}
982  	void subclassButtonControl(HWND hwnd)
983  	{
984  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
985  		SetWindowSubclass(hwnd, ButtonSubclass, g_buttonSubclassID, pButtonData);
986  	}
987  	void paintGroupbox(HWND hwnd, HDC hdc, ButtonData& buttonData)
988  	{
989  		auto nStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
990  		bool isDisabled = (nStyle & WS_DISABLED) == WS_DISABLED;
991  		int iPartID = BP_GROUPBOX;
992  		int iStateID = isDisabled ? GBS_DISABLED : GBS_NORMAL;
993  		RECT rcClient{};
994  		GetClientRect(hwnd, &rcClient);
995  		RECT rcText = rcClient;
996  		RECT rcBackground = rcClient;
997  		HFONT hFont = nullptr;
998  		HFONT hOldFont = nullptr;
999  		HFONT hCreatedFont = nullptr;
1000  		LOGFONT lf{};
1001  		if (SUCCEEDED(GetThemeFont(buttonData.hTheme, hdc, iPartID, iStateID, TMT_FONT, &lf)))
1002  		{
1003  			hCreatedFont = CreateFontIndirect(&lf);
1004  			hFont = hCreatedFont;
1005  		}
1006  		if (!hFont)
1007  		{
1008  			hFont = reinterpret_cast<HFONT>(SendMessage(hwnd, WM_GETFONT, 0, 0));
1009  		}
1010  		hOldFont = static_cast<HFONT>(::SelectObject(hdc, hFont));
1011  		WCHAR szText[256] = { '\0' };
1012  		GetWindowText(hwnd, szText, _countof(szText));
1013  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
1014  		bool isCenter = (style & BS_CENTER) == BS_CENTER;
1015  		if (szText[0])
1016  		{
1017  			SIZE textSize{};
1018  			GetTextExtentPoint32(hdc, szText, static_cast<int>(wcslen(szText)), &textSize);
1019  			int centerPosX = isCenter ? ((rcClient.right - rcClient.left - textSize.cx) / 2) : 7;
1020  			rcBackground.top += textSize.cy / 2;
1021  			rcText.left += centerPosX;
1022  			rcText.bottom = rcText.top + textSize.cy;
1023  			rcText.right = rcText.left + textSize.cx + 4;
1024  			ExcludeClipRect(hdc, rcText.left, rcText.top, rcText.right, rcText.bottom);
1025  		}
1026  		else
1027  		{
1028  			SIZE textSize{};
1029  			GetTextExtentPoint32(hdc, L"M", 1, &textSize);
1030  			rcBackground.top += textSize.cy / 2;
1031  		}
1032  		RECT rcContent = rcBackground;
1033  		GetThemeBackgroundContentRect(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, &rcBackground, &rcContent);
1034  		ExcludeClipRect(hdc, rcContent.left, rcContent.top, rcContent.right, rcContent.bottom);
1035  		NppDarkMode::paintRoundFrameRect(hdc, rcBackground, NppDarkMode::getEdgePen());
1036  		SelectClipRgn(hdc, nullptr);
1037  		if (szText[0])
1038  		{
1039  			rcText.right -= 2;
1040  			rcText.left += 2;
1041  			DTTOPTS dtto{};
1042  			dtto.dwSize = sizeof(DTTOPTS);
1043  			dtto.dwFlags = DTT_TEXTCOLOR;
1044  			dtto.crText = isDisabled ? NppDarkMode::getDisabledTextColor() : NppDarkMode::getTextColor();
1045  			DWORD textFlags = isCenter ? DT_CENTER : DT_LEFT;
1046  			if(::SendMessage(hwnd, WM_QUERYUISTATE, 0, 0) != static_cast<LRESULT>(NULL))
1047  			{
1048  				textFlags |= DT_HIDEPREFIX;
1049  			}
1050  			DrawThemeTextEx(buttonData.hTheme, hdc, BP_GROUPBOX, iStateID, szText, -1, textFlags | DT_SINGLELINE, &rcText, &dtto);
1051  		}
1052  		if (hCreatedFont) DeleteObject(hCreatedFont);
1053  		SelectObject(hdc, hOldFont);
1054  	}
1055  	constexpr UINT_PTR g_groupboxSubclassID = 42;
1056  	LRESULT CALLBACK GroupboxSubclass(
1057  		HWND hWnd,
1058  		UINT uMsg,
1059  		WPARAM wParam,
1060  		LPARAM lParam,
1061  		UINT_PTR uIdSubclass,
1062  		DWORD_PTR dwRefData
1063  	)
1064  	{
1065  		UNREFERENCED_PARAMETER(uIdSubclass);
1066  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
1067  		switch (uMsg)
1068  		{
1069  		case WM_NCDESTROY:
1070  			RemoveWindowSubclass(hWnd, GroupboxSubclass, g_groupboxSubclassID);
1071  			delete pButtonData;
1072  			break;
1073  		case WM_ERASEBKGND:
1074  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1075  			{
1076  				return TRUE;
1077  			}
1078  			else
1079  			{
1080  				break;
1081  			}
1082  		case WM_THEMECHANGED:
1083  			pButtonData->closeTheme();
1084  			break;
1085  		case WM_PRINTCLIENT:
1086  		case WM_PAINT:
1087  			if (NppDarkMode::isEnabled() && pButtonData->ensureTheme(hWnd))
1088  			{
1089  				PAINTSTRUCT ps{};
1090  				HDC hdc = reinterpret_cast<HDC>(wParam);
1091  				if (!hdc)
1092  				{
1093  					hdc = BeginPaint(hWnd, &ps);
1094  				}
1095  				paintGroupbox(hWnd, hdc, *pButtonData);
1096  				if (ps.hdc)
1097  				{
1098  					EndPaint(hWnd, &ps);
1099  				}
1100  				return 0;
1101  			}
1102  			else
1103  			{
1104  				break;
1105  			}
1106  			break;
1107  		}
1108  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1109  	}
1110  	void subclassGroupboxControl(HWND hwnd)
1111  	{
1112  		DWORD_PTR pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
1113  		SetWindowSubclass(hwnd, GroupboxSubclass, g_groupboxSubclassID, pButtonData);
1114  	}
1115  	constexpr UINT_PTR g_tabSubclassID = 42;
1116  	LRESULT CALLBACK TabSubclass(
1117  		HWND hWnd,
1118  		UINT uMsg,
1119  		WPARAM wParam,
1120  		LPARAM lParam,
1121  		UINT_PTR uIdSubclass,
1122  		DWORD_PTR dwRefData
1123  	)
1124  	{
1125  		UNREFERENCED_PARAMETER(uIdSubclass);
1126  		UNREFERENCED_PARAMETER(dwRefData);
1127  		switch (uMsg)
1128  		{
1129  		case WM_PAINT:
1130  		{
1131  			if (!NppDarkMode::isEnabled())
1132  			{
1133  				break;
1134  			}
1135  			LONG_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
1136  			if ((dwStyle & TCS_BUTTONS) || (dwStyle & TCS_VERTICAL))
1137  			{
1138  				break;
1139  			}
1140  			PAINTSTRUCT ps{};
1141  			HDC hdc = ::BeginPaint(hWnd, &ps);
1142  			::FillRect(hdc, &ps.rcPaint, NppDarkMode::getDarkerBackgroundBrush());
1143  			auto holdPen = static_cast<HPEN>(::SelectObject(hdc, NppDarkMode::getEdgePen()));
1144  			HRGN holdClip = CreateRectRgn(0, 0, 0, 0);
1145  			if (1 != GetClipRgn(hdc, holdClip))
1146  			{
1147  				DeleteObject(holdClip);
1148  				holdClip = nullptr;
1149  			}
1150  			HFONT hFont = reinterpret_cast<HFONT>(SendMessage(hWnd, WM_GETFONT, 0, 0));
1151  			auto hOldFont = SelectObject(hdc, hFont);
1152  			POINT ptCursor{};
1153  			::GetCursorPos(&ptCursor);
1154  			ScreenToClient(hWnd, &ptCursor);
1155  			int nTabs = TabCtrl_GetItemCount(hWnd);
1156  			int nSelTab = TabCtrl_GetCurSel(hWnd);
1157  			for (int i = 0; i < nTabs; ++i)
1158  			{
1159  				RECT rcItem{};
1160  				TabCtrl_GetItemRect(hWnd, i, &rcItem);
1161  				RECT rcFrame = rcItem;
1162  				RECT rcIntersect{};
1163  				if (IntersectRect(&rcIntersect, &ps.rcPaint, &rcItem))
1164  				{
1165  					bool bHot = PtInRect(&rcItem, ptCursor);
1166  					bool isSelectedTab = (i == nSelTab);
1167  					HRGN hClip = CreateRectRgnIndirect(&rcItem);
1168  					SelectClipRgn(hdc, hClip);
1169  					SetTextColor(hdc, (bHot || isSelectedTab ) ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
1170  					::InflateRect(&rcItem, -1, -1);
1171  					rcItem.right += 1;
1172  					::FillRect(hdc, &rcItem, isSelectedTab ? NppDarkMode::getDarkerBackgroundBrush() : bHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getSofterBackgroundBrush());
1173  					SetBkMode(hdc, TRANSPARENT);
1174  					TCHAR label[MAX_PATH]{};
1175  					TCITEM tci{};
1176  					tci.mask = TCIF_TEXT;
1177  					tci.pszText = label;
1178  					tci.cchTextMax = MAX_PATH - 1;
1179  					::SendMessage(hWnd, TCM_GETITEM, i, reinterpret_cast<LPARAM>(&tci));
1180  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1181  					RECT rcText = rcItem;
1182  					rcText.left += dpiManager.scaleX(5);
1183  					rcText.right -= dpiManager.scaleX(3);
1184  					if (isSelectedTab)
1185  					{
1186  						rcText.bottom -= dpiManager.scaleY(4);
1187  						::InflateRect(&rcFrame, 0, 1);
1188  					}
1189  					if (i != nTabs - 1)
1190  					{
1191  						rcFrame.right += 1;
1192  					}
1193  					::FrameRect(hdc, &rcFrame, NppDarkMode::getEdgeBrush());
1194  					DrawText(hdc, label, -1, &rcText, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1195  					DeleteObject(hClip);
1196  					SelectClipRgn(hdc, holdClip);
1197  				}
1198  			}
1199  			SelectObject(hdc, hOldFont);
1200  			SelectClipRgn(hdc, holdClip);
1201  			if (holdClip)
1202  			{
1203  				DeleteObject(holdClip);
1204  				holdClip = nullptr;
1205  			}
1206  			SelectObject(hdc, holdPen);
1207  			EndPaint(hWnd, &ps);
1208  			return 0;
1209  		}
1210  		case WM_NCDESTROY:
1211  		{
1212  			RemoveWindowSubclass(hWnd, TabSubclass, g_tabSubclassID);
1213  			break;
1214  		}
1215  		case WM_PARENTNOTIFY:
1216  		{
1217  			switch (LOWORD(wParam))
1218  			{
1219  				case WM_CREATE:
1220  				{
1221  					auto hwndUpdown = reinterpret_cast<HWND>(lParam);
1222  					if (NppDarkMode::subclassTabUpDownControl(hwndUpdown))
1223  					{
1224  						return 0;
1225  					}
1226  					break;
1227  				}
1228  			}
1229  			return 0;
1230  		}
1231  		}
1232  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1233  	}
1234  	void subclassTabControl(HWND hwnd)
1235  	{
1236  		SetWindowSubclass(hwnd, TabSubclass, g_tabSubclassID, 0);
1237  	}
1238  	constexpr UINT_PTR g_customBorderSubclassID = 42;
1239  	LRESULT CALLBACK CustomBorderSubclass(
1240  		HWND hWnd,
1241  		UINT uMsg,
1242  		WPARAM wParam,
1243  		LPARAM lParam,
1244  		UINT_PTR uIdSubclass,
1245  		DWORD_PTR dwRefData
1246  	)
1247  	{
1248  		UNREFERENCED_PARAMETER(dwRefData);
1249  		static bool isHotStatic = false;
1250  		switch (uMsg)
1251  		{
1252  			case WM_NCPAINT:
1253  			{
1254  				if (!NppDarkMode::isEnabled())
1255  				{
1256  					break;
1257  				}
1258  				DefSubclassProc(hWnd, uMsg, wParam, lParam);
1259  				HDC hdc = ::GetWindowDC(hWnd);
1260  				RECT rcClient{};
1261  				::GetClientRect(hWnd, &rcClient);
1262  				rcClient.right += (2 * ::GetSystemMetrics(SM_CXEDGE));
1263  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1264  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1265  				if (hasVerScrollbar)
1266  				{
1267  					rcClient.right += ::GetSystemMetrics(SM_CXVSCROLL);
1268  				}
1269  				rcClient.bottom += (2 * ::GetSystemMetrics(SM_CYEDGE));
1270  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1271  				if (hasHorScrollbar)
1272  				{
1273  					rcClient.bottom += ::GetSystemMetrics(SM_CYHSCROLL);
1274  				}
1275  				HPEN hPen = ::CreatePen(PS_SOLID, 1, NppDarkMode::getBackgroundColor());
1276  				RECT rcInner = rcClient;
1277  				::InflateRect(&rcInner, -1, -1);
1278  				NppDarkMode::paintRoundFrameRect(hdc, rcInner, hPen);
1279  				::DeleteObject(hPen);
1280  				bool hasFocus = ::GetFocus() == hWnd;
1281  				POINT ptCursor{};
1282  				::GetCursorPos(&ptCursor);
1283  				::ScreenToClient(hWnd, &ptCursor);
1284  				bool isHot = ::PtInRect(&rcClient, ptCursor);
1285  				bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1286  				HPEN hEnabledPen = ((isHotStatic && isHot) || hasFocus ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen());
1287  				NppDarkMode::paintRoundFrameRect(hdc, rcClient, isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen());
1288  				::ReleaseDC(hWnd, hdc);
1289  				return 0;
1290  			}
1291  			break;
1292  			case WM_NCCALCSIZE:
1293  			{
1294  				if (!NppDarkMode::isEnabled())
1295  				{
1296  					break;
1297  				}
1298  				auto lpRect = reinterpret_cast<LPRECT>(lParam);
1299  				::InflateRect(lpRect, -(::GetSystemMetrics(SM_CXEDGE)), -(::GetSystemMetrics(SM_CYEDGE)));
1300  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1301  				bool hasVerScrollbar = (style & WS_VSCROLL) == WS_VSCROLL;
1302  				if (hasVerScrollbar)
1303  				{
1304  					lpRect->right -= ::GetSystemMetrics(SM_CXVSCROLL);
1305  				}
1306  				bool hasHorScrollbar = (style & WS_HSCROLL) == WS_HSCROLL;
1307  				if (hasHorScrollbar)
1308  				{
1309  					lpRect->bottom -= ::GetSystemMetrics(SM_CYHSCROLL);
1310  				}
1311  				return 0;
1312  			}
1313  			break;
1314  			case WM_MOUSEMOVE:
1315  			{
1316  				if (!NppDarkMode::isEnabled())
1317  				{
1318  					break;
1319  				}
1320  				if (::GetFocus() == hWnd)
1321  				{
1322  					break;
1323  				}
1324  				TRACKMOUSEEVENT tme{};
1325  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1326  				tme.dwFlags = TME_LEAVE;
1327  				tme.hwndTrack = hWnd;
1328  				tme.dwHoverTime = HOVER_DEFAULT;
1329  				TrackMouseEvent(&tme);
1330  				if (!isHotStatic)
1331  				{
1332  					isHotStatic = true;
1333  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1334  				}
1335  			}
1336  			break;
1337  			case WM_MOUSELEAVE:
1338  			{
1339  				if (!NppDarkMode::isEnabled())
1340  				{
1341  					break;
1342  				}
1343  				if (isHotStatic)
1344  				{
1345  					isHotStatic = false;
1346  					::SetWindowPos(hWnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1347  				}
1348  				TRACKMOUSEEVENT tme{};
1349  				tme.cbSize = sizeof(TRACKMOUSEEVENT);
1350  				tme.dwFlags = TME_LEAVE | TME_CANCEL;
1351  				tme.hwndTrack = hWnd;
1352  				tme.dwHoverTime = HOVER_DEFAULT;
1353  				TrackMouseEvent(&tme);
1354  			}
1355  			break;
1356  			case WM_NCDESTROY:
1357  			{
1358  				RemoveWindowSubclass(hWnd, CustomBorderSubclass, uIdSubclass);
1359  			}
1360  			break;
1361  		}
1362  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1363  	}
1364  	void subclassCustomBorderForListBoxAndEditControls(HWND hwnd)
1365  	{
1366  		SetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, 0);
1367  	}
1368  	constexpr UINT_PTR g_comboBoxSubclassID = 42;
1369  	LRESULT CALLBACK ComboBoxSubclass(
1370  		HWND hWnd,
1371  		UINT uMsg,
1372  		WPARAM wParam,
1373  		LPARAM lParam,
1374  		UINT_PTR uIdSubclass,
1375  		DWORD_PTR dwRefData
1376  	)
1377  	{
1378  		auto hwndEdit = reinterpret_cast<HWND>(dwRefData);
1379  		switch (uMsg)
1380  		{
1381  			case WM_PAINT:
1382  			{
1383  				if (!NppDarkMode::isEnabled())
1384  				{
1385  					break;
1386  				}
1387  				RECT rc{};
1388  				::GetClientRect(hWnd, &rc);
1389  				PAINTSTRUCT ps{};
1390  				auto hdc = ::BeginPaint(hWnd, &ps);
1391  				::SelectObject(hdc, reinterpret_cast<HFONT>(::SendMessage(hWnd, WM_GETFONT, 0, 0)));
1392  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1393  				auto holdBrush = ::SelectObject(hdc, NppDarkMode::getDarkerBackgroundBrush());
1394  				auto& dpiManager = NppParameters::getInstance()._dpiManager;
1395  				RECT rcArrow{};
1396  				COMBOBOXINFO cbi{};
1397  				cbi.cbSize = sizeof(COMBOBOXINFO);
1398  				const bool resultCbi = ::GetComboBoxInfo(hWnd, &cbi) != FALSE;
1399  				if (resultCbi)
1400  				{
1401  					rcArrow = cbi.rcButton;
1402  					rcArrow.left -= 1;
1403  				}
1404  				else
1405  				{
1406  					rcArrow = {
1407  					rc.right - dpiManager.scaleX(17), rc.top + 1,
1408  					rc.right - 1, rc.bottom - 1
1409  					};
1410  				}
1411  				bool hasFocus = false;
1412  				const bool isWindowEnabled = ::IsWindowEnabled(hWnd) == TRUE;
1413  				auto style = ::GetWindowLongPtr(hWnd, GWL_STYLE);
1414  				if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
1415  				{
1416  					hasFocus = ::GetFocus() == hWnd;
1417  					RECT rcTextBg{};
1418  					if (resultCbi)
1419  					{
1420  						rcTextBg = cbi.rcItem;
1421  					}
1422  					else
1423  					{
1424  						rcTextBg = rc;
1425  						rcTextBg.left += 1;
1426  						rcTextBg.top += 1;
1427  						rcTextBg.right = rcArrow.left - 1;
1428  						rcTextBg.bottom -= 1;
1429  					}
1430  					::FillRect(hdc, &rcTextBg, NppDarkMode::getBackgroundBrush()); 
1431  					auto index = static_cast<int>(::SendMessage(hWnd, CB_GETCURSEL, 0, 0));
1432  					if (index != CB_ERR)
1433  					{
1434  						::SetTextColor(hdc, isWindowEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
1435  						::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1436  						auto bufferLen = static_cast<size_t>(::SendMessage(hWnd, CB_GETLBTEXTLEN, index, 0));
1437  						TCHAR* buffer = new TCHAR[(bufferLen + 1)];
1438  						::SendMessage(hWnd, CB_GETLBTEXT, index, reinterpret_cast<LPARAM>(buffer));
1439  						RECT rcText = rcTextBg;
1440  						rcText.left += 4;
1441  						rcText.right -= 4;
1442  						::DrawText(hdc, buffer, -1, &rcText, DT_NOPREFIX | DT_LEFT | DT_VCENTER | DT_SINGLELINE);
1443  						delete[] buffer;
1444  					}
1445  					if (hasFocus && ::SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0) == FALSE)
1446  					{
1447  						::DrawFocusRect(hdc, &rcTextBg);
1448  					}
1449  				}
1450  				else if ((style & CBS_DROPDOWN) == CBS_DROPDOWN && hwndEdit != nullptr)
1451  				{
1452  					hasFocus = ::GetFocus() == hwndEdit;
1453  				}
1454  				POINT ptCursor{};
1455  				::GetCursorPos(&ptCursor);
1456  				::ScreenToClient(hWnd, &ptCursor);
1457  				bool isHot = ::PtInRect(&rc, ptCursor);
1458  				auto colorEnabledText = isHot ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor();
1459  				::SetTextColor(hdc, isWindowEnabled ? colorEnabledText : NppDarkMode::getDisabledTextColor());
1460  				::SetBkColor(hdc, isHot ? NppDarkMode::getHotBackgroundColor() : NppDarkMode::getBackgroundColor());
1461  				::FillRect(hdc, &rcArrow, isHot ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
1462  				TCHAR arrow[] = L"˅";
1463  				::DrawText(hdc, arrow, -1, &rcArrow, DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
1464  				::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
1465  				auto hEnabledPen = (isHot || hasFocus) ? NppDarkMode::getHotEdgePen() : NppDarkMode::getEdgePen();
1466  				auto hSelectedPen = isWindowEnabled ? hEnabledPen : NppDarkMode::getDisabledEdgePen();
1467  				auto holdPen = static_cast<HPEN>(::SelectObject(hdc, hSelectedPen));
1468  				POINT edge[] = {
1469  					{rcArrow.left - 1, rcArrow.top},
1470  					{rcArrow.left - 1, rcArrow.bottom}
1471  				};
1472  				::Polyline(hdc, edge, _countof(edge));
1473  				int roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(4) : 0;
1474  				NppDarkMode::paintRoundFrameRect(hdc, rc, hSelectedPen, roundCornerValue, roundCornerValue);
1475  				::SelectObject(hdc, holdPen);
1476  				::SelectObject(hdc, holdBrush);
1477  				::EndPaint(hWnd, &ps);
1478  				return 0;
1479  			}
1480  			case WM_NCDESTROY:
1481  			{
1482  				::RemoveWindowSubclass(hWnd, ComboBoxSubclass, uIdSubclass);
1483  				break;
1484  			}
1485  		}
1486  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1487  	}
1488  	void subclassComboBoxControl(HWND hwnd)
1489  	{
1490  		DWORD_PTR hwndEditData = 0;
1491  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1492  		if ((style & CBS_DROPDOWN) == CBS_DROPDOWN)
1493  		{
1494  			POINT pt = { 5, 5 };
1495  			hwndEditData = reinterpret_cast<DWORD_PTR>(::ChildWindowFromPoint(hwnd, pt));
1496  		}
1497  		SetWindowSubclass(hwnd, ComboBoxSubclass, g_comboBoxSubclassID, hwndEditData);
1498  	}
1499  	constexpr UINT_PTR g_listViewSubclassID = 42;
1500  	LRESULT CALLBACK ListViewSubclass(
1501  		HWND hWnd,
1502  		UINT uMsg,
1503  		WPARAM wParam,
1504  		LPARAM lParam,
1505  		UINT_PTR uIdSubclass,
1506  		DWORD_PTR dwRefData
1507  	)
1508  	{
1509  		UNREFERENCED_PARAMETER(dwRefData);
1510  		switch (uMsg)
1511  		{
1512  			case WM_NCDESTROY:
1513  			{
1514  				::RemoveWindowSubclass(hWnd, ListViewSubclass, uIdSubclass);
1515  				break;
1516  			}
1517  			case WM_NOTIFY:
1518  			{
1519  				switch (reinterpret_cast<LPNMHDR>(lParam)->code)
1520  				{
1521  					case NM_CUSTOMDRAW:
1522  					{
1523  						auto lpnmcd = reinterpret_cast<LPNMCUSTOMDRAW>(lParam);
1524  						switch (lpnmcd->dwDrawStage)
1525  						{
1526  							case CDDS_PREPAINT:
1527  							{
1528  								if (NppDarkMode::isExperimentalSupported() && NppDarkMode::isEnabled())
1529  								{
1530  									return CDRF_NOTIFYITEMDRAW;
1531  								}
1532  								return CDRF_DODEFAULT;
1533  							}
1534  							case CDDS_ITEMPREPAINT:
1535  							{
1536  								SetTextColor(lpnmcd->hdc, NppDarkMode::getDarkerTextColor());
1537  								return CDRF_NEWFONT;
1538  							}
1539  							default:
1540  								return CDRF_DODEFAULT;
1541  						}
1542  					}
1543  					break;
1544  				}
1545  				break;
1546  			}
1547  			break;
1548  		}
1549  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
1550  	}
1551  	void subclassListViewControl(HWND hwnd)
1552  	{
1553  		SetWindowSubclass(hwnd, ListViewSubclass, g_listViewSubclassID, 0);
1554  	}
1555  	void autoSubclassAndThemeChildControls(HWND hwndParent, bool subclass, bool theme)
1556  	{
1557  		NppDarkModeParams p{
1558  			g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr
1559  			, subclass
1560  			, theme
1561  		};
1562  		::EnableThemeDialogTexture(hwndParent, theme && !NppDarkMode::isEnabled() ? ETDT_ENABLETAB : ETDT_DISABLE);
1563  		EnumChildWindows(hwndParent, [](HWND hwnd, LPARAM lParam) WINAPI_LAMBDA {
1564  			auto& p = *reinterpret_cast<NppDarkModeParams*>(lParam);
1565  			constexpr size_t classNameLen = 32;
1566  			TCHAR className[classNameLen]{};
1567  			GetClassName(hwnd, className, classNameLen);
1568  			if (wcscmp(className, WC_BUTTON) == 0)
1569  			{
1570  				NppDarkMode::subclassAndThemeButton(hwnd, p);
1571  				return TRUE;
1572  			}
1573  			if (wcscmp(className, WC_COMBOBOX) == 0)
1574  			{
1575  				NppDarkMode::subclassAndThemeComboBox(hwnd, p);
1576  				return TRUE;
1577  			}
1578  			if (wcscmp(className, WC_EDIT) == 0)
1579  			{
1580  				if (!g_isWine)
1581  				{
1582  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, false);
1583  				}
1584  				return TRUE;
1585  			}
1586  			if (wcscmp(className, WC_LISTBOX) == 0)
1587  			{
1588  				if (!g_isWine)
1589  				{
1590  					NppDarkMode::subclassAndThemeListBoxOrEditControl(hwnd, p, true);
1591  				}
1592  				return TRUE;
1593  			}
1594  			if (wcscmp(className, WC_LISTVIEW) == 0)
1595  			{
1596  				NppDarkMode::subclassAndThemeListView(hwnd, p);
1597  				return TRUE;
1598  			}
1599  			if (wcscmp(className, WC_TREEVIEW) == 0)
1600  			{
1601  				NppDarkMode::themeTreeView(hwnd, p);
1602  				return TRUE;
1603  			}
1604  			if (wcscmp(className, TOOLBARCLASSNAME) == 0)
1605  			{
1606  				NppDarkMode::themeToolbar(hwnd, p);
1607  				return TRUE;
1608  			}
1609  			if (wcscmp(className, L"RichEdit20W") == 0 || wcscmp(className, L"RICHEDIT50W") == 0)
1610  			{
1611  				NppDarkMode::themeRichEdit(hwnd, p);
1612  				return TRUE;
1613  			}
1614  			return TRUE;
1615  		}, reinterpret_cast<LPARAM>(&p));
1616  	}
1617  	void autoThemeChildControls(HWND hwndParent)
1618  	{
1619  		autoSubclassAndThemeChildControls(hwndParent, false, g_isAtLeastWindows10);
1620  	}
1621  	void subclassAndThemeButton(HWND hwnd, NppDarkModeParams p)
1622  	{
1623  		auto nButtonStyle = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1624  		switch (nButtonStyle & BS_TYPEMASK)
1625  		{
1626  			case BS_CHECKBOX:
1627  			case BS_AUTOCHECKBOX:
1628  			case BS_3STATE:
1629  			case BS_AUTO3STATE:
1630  			case BS_RADIOBUTTON:
1631  			case BS_AUTORADIOBUTTON:
1632  			{
1633  				if ((nButtonStyle & BS_PUSHLIKE) == BS_PUSHLIKE)
1634  				{
1635  					if (p._theme)
1636  					{
1637  						SetWindowTheme(hwnd, p._themeClassName, nullptr);
1638  					}
1639  					break;
1640  				}
1641  				if (p._subclass)
1642  				{
1643  					NppDarkMode::subclassButtonControl(hwnd);
1644  				}
1645  				break;
1646  			}
1647  			case BS_GROUPBOX:
1648  			{
1649  				if (p._subclass)
1650  				{
1651  					NppDarkMode::subclassGroupboxControl(hwnd);
1652  				}
1653  				break;
1654  			}
1655  			case BS_PUSHBUTTON:
1656  			case BS_DEFPUSHBUTTON:
1657  			case BS_SPLITBUTTON:
1658  			case BS_DEFSPLITBUTTON:
1659  			{
1660  				if (p._theme)
1661  				{
1662  					SetWindowTheme(hwnd, p._themeClassName, nullptr);
1663  				}
1664  				break;
1665  			}
1666  			default:
1667  			{
1668  				break;
1669  			}
1670  		}
1671  	}
1672  	void subclassAndThemeComboBox(HWND hwnd, NppDarkModeParams p)
1673  	{
1674  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1675  		if ((style & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST || (style & CBS_DROPDOWN) == CBS_DROPDOWN)
1676  		{
1677  			COMBOBOXINFO cbi{};
1678  			cbi.cbSize = sizeof(COMBOBOXINFO);
1679  			BOOL result = ::GetComboBoxInfo(hwnd, &cbi);
1680  			if (result == TRUE)
1681  			{
1682  				if (p._theme && cbi.hwndList)
1683  				{
1684  					::SetWindowTheme(cbi.hwndList, p._themeClassName, nullptr);
1685  				}
1686  			}
1687  			if (p._subclass)
1688  			{
1689  				NppDarkMode::subclassComboBoxControl(hwnd);
1690  			}
1691  		}
1692  	}
1693  	void subclassAndThemeListBoxOrEditControl(HWND hwnd, NppDarkModeParams p, bool isListBox)
1694  	{
1695  		const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
1696  		bool hasScrollBar = ((style & WS_HSCROLL) == WS_HSCROLL) || ((style & WS_VSCROLL) == WS_VSCROLL);
1697  		if (p._theme && (isListBox || hasScrollBar))
1698  		{
1699  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1700  		}
1701  		const auto exStyle = ::GetWindowLongPtr(hwnd, GWL_EXSTYLE);
1702  		bool hasClientEdge = (exStyle & WS_EX_CLIENTEDGE) == WS_EX_CLIENTEDGE;
1703  		bool isCBoxListBox = isListBox && (style & LBS_COMBOBOX) == LBS_COMBOBOX;
1704  		if (p._subclass && hasClientEdge && !isCBoxListBox)
1705  		{
1706  			NppDarkMode::subclassCustomBorderForListBoxAndEditControls(hwnd);
1707  		}
1708  #ifndef __MINGW64__ 
1709  		bool changed = false;
1710  		if (::GetWindowSubclass(hwnd, CustomBorderSubclass, g_customBorderSubclassID, nullptr) == TRUE)
1711  		{
1712  			if (NppDarkMode::isEnabled())
1713  			{
1714  				if (hasClientEdge)
1715  				{
1716  					::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle & ~WS_EX_CLIENTEDGE);
1717  					changed = true;
1718  				}
1719  			}
1720  			else if (!hasClientEdge)
1721  			{
1722  				::SetWindowLongPtr(hwnd, GWL_EXSTYLE, exStyle | WS_EX_CLIENTEDGE);
1723  				changed = true;
1724  			}
1725  		}
1726  		if (changed)
1727  		{
1728  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1729  		}
1730  #endif 
1731  	}
1732  	void subclassAndThemeListView(HWND hwnd, NppDarkModeParams p)
1733  	{
1734  		if (p._theme)
1735  		{
1736  			NppDarkMode::setDarkListView(hwnd);
1737  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::listview);
1738  		}
1739  		ListView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1740  		ListView_SetTextBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1741  		ListView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1742  		if (p._subclass)
1743  		{
1744  			auto exStyle = ListView_GetExtendedListViewStyle(hwnd);
1745  			ListView_SetExtendedListViewStyle(hwnd, exStyle | LVS_EX_DOUBLEBUFFER);
1746  			NppDarkMode::subclassListViewControl(hwnd);
1747  		}
1748  	}
1749  	void themeTreeView(HWND hwnd, NppDarkModeParams p)
1750  	{
1751  		TreeView_SetTextColor(hwnd, NppParameters::getInstance().getCurrentDefaultFgColor());
1752  		TreeView_SetBkColor(hwnd, NppParameters::getInstance().getCurrentDefaultBgColor());
1753  		NppDarkMode::calculateTreeViewStyle();
1754  		NppDarkMode::setTreeViewStyle(hwnd);
1755  		if (p._theme)
1756  		{
1757  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::treeview);
1758  		}
1759  	}
1760  	void themeToolbar(HWND hwnd, NppDarkModeParams p)
1761  	{
1762  		NppDarkMode::setDarkLineAbovePanelToolbar(hwnd);
1763  		if (p._theme)
1764  		{
1765  			NppDarkMode::setDarkTooltips(hwnd, NppDarkMode::ToolTipsType::toolbar);
1766  		}
1767  	}
1768  	void themeRichEdit(HWND hwnd, NppDarkModeParams p)
1769  	{
1770  		if (p._theme)
1771  		{
1772  			SetWindowTheme(hwnd, p._themeClassName, nullptr);
1773  		}
1774  	}
1775  	LRESULT darkToolBarNotifyCustomDraw(LPARAM lParam)
1776  	{
1777  		auto nmtbcd = reinterpret_cast<LPNMTBCUSTOMDRAW>(lParam);
1778  		static int roundCornerValue = 0;
1779  		switch (nmtbcd->nmcd.dwDrawStage)
1780  		{
1781  			case CDDS_PREPAINT:
1782  			{
1783  				if (NppDarkMode::isEnabled())
1784  				{
1785  					auto dpiManager = NppParameters::getInstance()._dpiManager;
1786  					roundCornerValue = NppDarkMode::isWindows11() ? dpiManager.scaleX(5) : 0;
1787  					::FillRect(nmtbcd->nmcd.hdc, &nmtbcd->nmcd.rc, NppDarkMode::getDarkerBackgroundBrush());
1788  					return CDRF_NOTIFYITEMDRAW;
1789  				}
1790  				return CDRF_DODEFAULT;
1791  			}
1792  			case CDDS_ITEMPREPAINT:
1793  			{
1794  				nmtbcd->hbrLines = NppDarkMode::getEdgeBrush();
1795  				nmtbcd->clrText = NppDarkMode::getTextColor();
1796  				nmtbcd->clrTextHighlight = NppDarkMode::getTextColor();
1797  				nmtbcd->clrBtnFace = NppDarkMode::getBackgroundColor();
1798  				nmtbcd->clrBtnHighlight = NppDarkMode::getSofterBackgroundColor();
1799  				nmtbcd->clrHighlightHotTrack = NppDarkMode::getHotBackgroundColor();
1800  				nmtbcd->nStringBkMode = TRANSPARENT;
1801  				nmtbcd->nHLStringBkMode = TRANSPARENT;
1802  				if ((nmtbcd->nmcd.uItemState & CDIS_CHECKED) == CDIS_CHECKED)
1803  				{
1804  					auto holdBrush = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getSofterBackgroundBrush());
1805  					auto holdPen = ::SelectObject(nmtbcd->nmcd.hdc, NppDarkMode::getEdgePen());
1806  					::RoundRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc.left, nmtbcd->nmcd.rc.top, nmtbcd->nmcd.rc.right, nmtbcd->nmcd.rc.bottom, roundCornerValue, roundCornerValue);
1807  					::SelectObject(nmtbcd->nmcd.hdc, holdBrush);
1808  					::SelectObject(nmtbcd->nmcd.hdc, holdPen);
1809  					nmtbcd->nmcd.uItemState &= ~CDIS_CHECKED;
1810  				}
1811  				return TBCDRF_HILITEHOTTRACK | TBCDRF_USECDCOLORS | CDRF_NOTIFYPOSTPAINT;
1812  			}
1813  			case CDDS_ITEMPOSTPAINT:
1814  			{
1815  				bool isDropDown = false;
1816  				auto exStyle = ::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETEXTENDEDSTYLE, 0, 0);
1817  				if ((exStyle & TBSTYLE_EX_DRAWDDARROWS) == TBSTYLE_EX_DRAWDDARROWS)
1818  				{
1819  					TBBUTTONINFO tbButtonInfo{};
1820  					tbButtonInfo.cbSize = sizeof(TBBUTTONINFO);
1821  					tbButtonInfo.dwMask = TBIF_STYLE;
1822  					::SendMessage(nmtbcd->nmcd.hdr.hwndFrom, TB_GETBUTTONINFO, nmtbcd->nmcd.dwItemSpec, reinterpret_cast<LPARAM>(&tbButtonInfo));
1823  					isDropDown = (tbButtonInfo.fsStyle & BTNS_DROPDOWN) == BTNS_DROPDOWN;
1824  				}
1825  				if ( !isDropDown && (nmtbcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1826  				{
1827  					NppDarkMode::paintRoundFrameRect(nmtbcd->nmcd.hdc, nmtbcd->nmcd.rc, NppDarkMode::getHotEdgePen(), roundCornerValue, roundCornerValue);
1828  				}
1829  				return CDRF_DODEFAULT;
1830  			}
1831  			default:
1832  				return CDRF_DODEFAULT;
1833  		}
1834  	}
1835  	LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool isPlugin)
1836  	{
1837  		auto lplvcd = reinterpret_cast<LPNMLVCUSTOMDRAW>(lParam);
1838  		switch (lplvcd->nmcd.dwDrawStage)
1839  		{
1840  			case CDDS_PREPAINT:
1841  			{
1842  				return CDRF_NOTIFYITEMDRAW;
1843  			}
1844  			case CDDS_ITEMPREPAINT:
1845  			{
<span onclick='openModal()' class='match'>1846  				auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
1847  				if (NppDarkMode::isEnabled())
1848  				{
1849  					if (isSelected)
1850  					{
1851  						lplvcd->clrText = NppDarkMode::getTextColor();
1852  						lplvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
1853  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
1854  					}
1855  					else if ((lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
</span>1856  					{
1857  						lplvcd->clrText = NppDarkMode::getTextColor();
1858  						lplvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
1859  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
1860  					}
1861  				}
1862  				if (isSelected)
1863  				{
1864  					::DrawFocusRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc);
1865  				}
1866  				LRESULT lr = CDRF_DODEFAULT;
1867  				if (isPlugin)
1868  				{
1869  					lr = ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
1870  				}
1871  				return lr | CDRF_NEWFONT;
1872  			}
1873  			default:
1874  				break;
1875  		}
1876  		return ::DefSubclassProc(hWnd, uMsg, wParam, lParam);
1877  	}
1878  	LRESULT darkTreeViewNotifyCustomDraw(LPARAM lParam)
1879  	{
1880  		auto lptvcd = reinterpret_cast<LPNMTVCUSTOMDRAW>(lParam);
1881  		switch (lptvcd->nmcd.dwDrawStage)
1882  		{
1883  			case CDDS_PREPAINT:
1884  			{
1885  				if (NppDarkMode::isEnabled())
1886  				{
1887  					return CDRF_NOTIFYITEMDRAW;
1888  				}
1889  				return CDRF_DODEFAULT;
1890  			}
1891  			case CDDS_ITEMPREPAINT:
1892  			{
1893  				if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
1894  				{
1895  					lptvcd->clrText = NppDarkMode::getTextColor();
1896  					lptvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
1897  					::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
1898  					return CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
1899  				}
1900  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1901  				{
1902  					lptvcd->clrText = NppDarkMode::getTextColor();
1903  					lptvcd->clrTextBk = NppDarkMode::getHotBackgroundColor();
1904  					auto notifyResult =  CDRF_DODEFAULT;
1905  					if (g_isAtLeastWindows10 || g_treeViewStyle == TreeViewStyle::light)
1906  					{
1907  						::FillRect(lptvcd->nmcd.hdc, &lptvcd->nmcd.rc, NppDarkMode::getHotBackgroundBrush());
1908  						notifyResult = CDRF_NOTIFYPOSTPAINT;
1909  					}
1910  					return CDRF_NEWFONT | notifyResult;
1911  				}
1912  				return CDRF_DODEFAULT;
1913  			}
1914  			case CDDS_ITEMPOSTPAINT:
1915  			{
1916  				RECT rcFrame = lptvcd->nmcd.rc;
1917  				rcFrame.left -= 1;
1918  				rcFrame.right += 1;
1919  				if ((lptvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
1920  				{
1921  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getHotEdgePen(), 0, 0);
1922  				}
1923  				else if ((lptvcd->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED)
1924  				{
1925  					NppDarkMode::paintRoundFrameRect(lptvcd->nmcd.hdc, rcFrame, NppDarkMode::getEdgePen(), 0, 0);
1926  				}
1927  				return CDRF_DODEFAULT;
1928  			}
1929  			default:
1930  				return CDRF_DODEFAULT;
1931  		}
1932  	}
1933  	constexpr UINT_PTR g_pluginDockWindowSubclassID = 42;
1934  	LRESULT CALLBACK PluginDockWindowSubclass(
1935  		HWND hWnd,
1936  		UINT uMsg,
1937  		WPARAM wParam,
1938  		LPARAM lParam,
1939  		UINT_PTR uIdSubclass,
1940  		DWORD_PTR dwRefData
1941  	)
1942  	{
1943  		UNREFERENCED_PARAMETER(dwRefData);
1944  		switch (uMsg)
1945  		{
1946  			case WM_ERASEBKGND:
1947  			{
1948  				if (NppDarkMode::isEnabled())
1949  				{
1950  					RECT rect{};
1951  					GetClientRect(hWnd, &rect);
1952  					::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
1953  					return TRUE;
1954  				}
1955  				break;
1956  			}
1957  			case WM_NCDESTROY:
1958  			{
1959  				::RemoveWindowSubclass(hWnd, PluginDockWindowSubclass, uIdSubclass);
1960  				break;
1961  			}
1962  			case NPPM_INTERNAL_REFRESHDARKMODE:
1963  			{
1964  				NppDarkMode::autoThemeChildControls(hWnd);
1965  				return TRUE;
1966  			}
1967  			case WM_CTLCOLOREDIT:
1968  			{
1969  				if (NppDarkMode::isEnabled())
1970  				{
1971  					return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1972  				}
1973  				break;
1974  			}
1975  			case WM_CTLCOLORLISTBOX:
1976  			{
1977  				if (NppDarkMode::isEnabled())
1978  				{
1979  					return NppDarkMode::onCtlColorListbox(wParam, lParam);
1980  				}
1981  				break;
1982  			}
1983  			case WM_CTLCOLORDLG:
1984  			{
1985  				if (NppDarkMode::isEnabled())
1986  				{
1987  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1988  				}
1989  				break;
1990  			}
1991  			case WM_CTLCOLORSTATIC:
1992  			{
1993  				if (NppDarkMode::isEnabled())
1994  				{
1995  					constexpr size_t classNameLen = 16;
1996  					TCHAR className[classNameLen]{};
1997  					auto hwndEdit = reinterpret_cast<HWND>(lParam);
1998  					GetClassName(hwndEdit, className, classNameLen);
1999  					if (wcscmp(className, WC_EDIT) == 0)
2000  					{
2001  						return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
2002  					}
2003  					return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
2004  				}
2005  				break;
2006  			}
2007  			case WM_PRINTCLIENT:
2008  			{
2009  				if (NppDarkMode::isEnabled())
2010  				{
2011  					return TRUE;
2012  				}
2013  				break;
2014  			}
2015  			case WM_NOTIFY:
2016  			{
2017  				const auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2018  				switch (nmhdr->code)
2019  				{
2020  					case NM_CUSTOMDRAW:
2021  					{
2022  						constexpr size_t classNameLen = 16;
2023  						TCHAR className[classNameLen]{};
2024  						GetClassName(nmhdr->hwndFrom, className, classNameLen);
2025  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2026  						{
2027  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2028  						}
2029  						if (wcscmp(className, WC_LISTVIEW) == 0)
2030  						{
2031  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, true);
2032  						}
2033  						if (wcscmp(className, WC_TREEVIEW) == 0)
2034  						{
2035  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2036  						}
2037  					}
2038  					break;
2039  				}
2040  				break;
2041  			}
2042  		}
2043  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2044  	}
2045  	void autoSubclassAndThemePluginDockWindow(HWND hwnd)
2046  	{
2047  		SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0);
2048  		NppDarkMode::autoSubclassAndThemeChildControls(hwnd, true, g_isAtLeastWindows10);
2049  	}
2050  	ULONG autoSubclassAndThemePlugin(HWND hwnd, ULONG dmFlags)
2051  	{
2052  		constexpr ULONG dmfSubclassParent =     0x00000001UL;
2053  		constexpr ULONG dmfSubclassChildren =   0x00000002UL;
2054  		constexpr ULONG dmfSetThemeChildren =   0x00000004UL;
2055  		constexpr ULONG dmfSetTitleBar =        0x00000008UL;
2056  		constexpr ULONG dmfSetThemeDirectly =   0x00000010UL;
2057  		constexpr ULONG dmfRequiredMask =       dmfSubclassParent | dmfSubclassChildren | dmfSetThemeChildren | dmfSetTitleBar | dmfSetThemeDirectly;
2058  		if (hwnd == nullptr || (dmFlags & dmfRequiredMask) == 0)
2059  		{
2060  			return 0;
2061  		}
2062  		auto dmfBitwiseCheck = [dmFlags](ULONG flag) -> bool {
2063  			return (dmFlags & flag) == flag;
2064  		};
2065  		ULONG result = 0UL;
2066  		if (dmfBitwiseCheck(dmfSubclassParent))
2067  		{
2068  			const bool success = ::SetWindowSubclass(hwnd, PluginDockWindowSubclass, g_pluginDockWindowSubclassID, 0) == TRUE;
2069  			if (success)
2070  			{
2071  				result |= dmfSubclassParent;
2072  			}
2073  		}
2074  		const bool subclassChildren = dmfBitwiseCheck(dmfSubclassChildren);
2075  		if (dmfBitwiseCheck(dmfSetThemeChildren) || subclassChildren)
2076  		{
2077  			NppDarkMode::autoSubclassAndThemeChildControls(hwnd, subclassChildren, g_isAtLeastWindows10);
2078  			result |= dmfSetThemeChildren;
2079  			if (subclassChildren)
2080  			{
2081  				result |= dmfSubclassChildren;
2082  			}
2083  		}
2084  		if (dmfBitwiseCheck(dmfSetTitleBar))
2085  		{
2086  			const auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2087  			if (NppDarkMode::isExperimentalSupported() && ((style & WS_CAPTION) == WS_CAPTION))
2088  			{
2089  				NppDarkMode::setDarkTitleBar(hwnd);
2090  				result |= dmfSetTitleBar;
2091  			}
2092  		}
2093  		if (dmfBitwiseCheck(dmfSetThemeDirectly))
2094  		{
2095  			if (NppDarkMode::isWindows10())
2096  			{
2097  				NppDarkMode::setDarkExplorerTheme(hwnd);
2098  				result |= dmfSetThemeDirectly;
2099  			}
2100  		}
2101  		return result;
2102  	}
2103  	constexpr UINT_PTR g_windowNotifySubclassID = 42;
2104  	LRESULT CALLBACK WindowNotifySubclass(
2105  		HWND hWnd,
2106  		UINT uMsg,
2107  		WPARAM wParam,
2108  		LPARAM lParam,
2109  		UINT_PTR uIdSubclass,
2110  		DWORD_PTR dwRefData
2111  	)
2112  	{
2113  		UNREFERENCED_PARAMETER(dwRefData);
2114  		switch (uMsg)
2115  		{
2116  			case WM_NCDESTROY:
2117  			{
2118  				::RemoveWindowSubclass(hWnd, WindowNotifySubclass, uIdSubclass);
2119  				break;
2120  			}
2121  			case WM_NOTIFY:
2122  			{
2123  				auto nmhdr = reinterpret_cast<LPNMHDR>(lParam);
2124  				constexpr size_t classNameLen = 16;
2125  				TCHAR className[classNameLen]{};
2126  				GetClassName(nmhdr->hwndFrom, className, classNameLen);
2127  				switch (nmhdr->code)
2128  				{
2129  					case NM_CUSTOMDRAW:
2130  					{
2131  						if (wcscmp(className, TOOLBARCLASSNAME) == 0)
2132  						{
2133  							return NppDarkMode::darkToolBarNotifyCustomDraw(lParam);
2134  						}
2135  						if (wcscmp(className, WC_LISTVIEW) == 0)
2136  						{
2137  							return NppDarkMode::darkListViewNotifyCustomDraw(hWnd, uMsg, wParam, lParam, false);
2138  						}
2139  						if (wcscmp(className, WC_TREEVIEW) == 0)
2140  						{
2141  							return NppDarkMode::darkTreeViewNotifyCustomDraw(lParam);
2142  						}
2143  					}
2144  					break;
2145  				}
2146  				break;
2147  			}
2148  		}
2149  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2150  	}
2151  	void autoSubclassAndThemeWindowNotify(HWND hwnd)
2152  	{
2153  		SetWindowSubclass(hwnd, WindowNotifySubclass, g_windowNotifySubclassID, 0);
2154  	}
2155  	constexpr UINT_PTR g_tabUpDownSubclassID = 42;
2156  	LRESULT CALLBACK TabUpDownSubclass(
2157  		HWND hWnd,
2158  		UINT uMsg,
2159  		WPARAM wParam,
2160  		LPARAM lParam,
2161  		UINT_PTR uIdSubclass,
2162  		DWORD_PTR dwRefData
2163  	)
2164  	{
2165  		auto pButtonData = reinterpret_cast<ButtonData*>(dwRefData);
2166  		switch (uMsg)
2167  		{
2168  			case WM_PRINTCLIENT:
2169  			case WM_PAINT:
2170  			{
2171  				if (!NppDarkMode::isEnabled())
2172  				{
2173  					break;
2174  				}
2175  				bool hasTheme = pButtonData->ensureTheme(hWnd);
2176  				RECT rcClient{};
2177  				::GetClientRect(hWnd, &rcClient);
2178  				PAINTSTRUCT ps{};
2179  				auto hdc = ::BeginPaint(hWnd, &ps);
2180  				::FillRect(hdc, &rcClient, NppDarkMode::getDarkerBackgroundBrush());
2181  				auto dpiManager = NppParameters::getInstance()._dpiManager;
2182  				RECT rcArrowLeft = {
2183  					rcClient.left, rcClient.top,
2184  					rcClient.right - ((rcClient.right - rcClient.left) / 2) , rcClient.bottom
2185  				};
2186  				RECT rcArrowRight = {
2187  					rcArrowLeft.right, rcClient.top,
2188  					rcClient.right, rcClient.bottom
2189  				};
2190  				POINT ptCursor{};
2191  				::GetCursorPos(&ptCursor);
2192  				::ScreenToClient(hWnd, &ptCursor);
2193  				bool isHotLeft = ::PtInRect(&rcArrowLeft, ptCursor);
2194  				bool isHotRight = ::PtInRect(&rcArrowRight, ptCursor);
2195  				::SetBkMode(hdc, TRANSPARENT);
2196  				if (hasTheme)
2197  				{
2198  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotLeft ? PBS_HOT : PBS_NORMAL, &rcArrowLeft, nullptr);
2199  					::DrawThemeBackground(pButtonData->hTheme, hdc, BP_PUSHBUTTON, isHotRight ? PBS_HOT : PBS_NORMAL, &rcArrowRight, nullptr);
2200  				}
2201  				else
2202  				{
2203  					::FillRect(hdc, &rcArrowLeft, isHotLeft ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
2204  					::FillRect(hdc, &rcArrowRight, isHotRight ? NppDarkMode::getHotBackgroundBrush() : NppDarkMode::getBackgroundBrush());
2205  				}
2206  				LOGFONT lf{};
2207  				auto font = reinterpret_cast<HFONT>(SendMessage(hWnd, WM_GETFONT, 0, 0));
2208  				::GetObject(font, sizeof(lf), &lf);
2209  				lf.lfHeight = (dpiManager.scaleY(16) - 5) * -1;
2210  				auto holdFont = static_cast<HFONT>(::SelectObject(hdc, CreateFontIndirect(&lf)));
2211  				auto mPosX = ((rcArrowLeft.right - rcArrowLeft.left - dpiManager.scaleX(7) + 1) / 2);
2212  				auto mPosY = ((rcArrowLeft.bottom - rcArrowLeft.top + lf.lfHeight - dpiManager.scaleY(1) - 3) / 2);
2213  				::SetTextColor(hdc, isHotLeft ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
2214  				::ExtTextOut(hdc,
2215  					rcArrowLeft.left + mPosX,
2216  					rcArrowLeft.top + mPosY,
2217  					ETO_CLIPPED,
2218  					&rcArrowLeft, L"<",
2219  					1,
2220  					nullptr);
2221  				::SetTextColor(hdc, isHotRight ? NppDarkMode::getTextColor() : NppDarkMode::getDarkerTextColor());
2222  				::ExtTextOut(hdc,
2223  					rcArrowRight.left + mPosX - dpiManager.scaleX(2) + 3,
2224  					rcArrowRight.top + mPosY,
2225  					ETO_CLIPPED,
2226  					&rcArrowRight, L">",
2227  					1,
2228  					nullptr);
2229  				if (!hasTheme)
2230  				{
2231  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowLeft, NppDarkMode::getEdgePen());
2232  					NppDarkMode::paintRoundFrameRect(hdc, rcArrowRight, NppDarkMode::getEdgePen());
2233  				}
2234  				::SelectObject(hdc, holdFont);
2235  				::EndPaint(hWnd, &ps);
2236  				return FALSE;
2237  			}
2238  			case WM_THEMECHANGED:
2239  			{
2240  				pButtonData->closeTheme();
2241  				break;
2242  			}
2243  			case WM_NCDESTROY:
2244  			{
2245  				::RemoveWindowSubclass(hWnd, TabUpDownSubclass, uIdSubclass);
2246  				delete pButtonData;
2247  				break;
2248  			}
2249  			case WM_ERASEBKGND:
2250  			{
2251  				if (NppDarkMode::isEnabled())
2252  				{
2253  					RECT rcClient{};
2254  					::GetClientRect(hWnd, &rcClient);
2255  					::FillRect(reinterpret_cast<HDC>(wParam), &rcClient, NppDarkMode::getDarkerBackgroundBrush());
2256  					return TRUE;
2257  				}
2258  				break;
2259  			}
2260  		}
2261  		return DefSubclassProc(hWnd, uMsg, wParam, lParam);
2262  	}
2263  	bool subclassTabUpDownControl(HWND hwnd)
2264  	{
2265  		constexpr size_t classNameLen = 16;
2266  		TCHAR className[classNameLen]{};
2267  		GetClassName(hwnd, className, classNameLen);
2268  		if (wcscmp(className, UPDOWN_CLASS) == 0)
2269  		{
2270  			auto pButtonData = reinterpret_cast<DWORD_PTR>(new ButtonData());
2271  			SetWindowSubclass(hwnd, TabUpDownSubclass, g_tabUpDownSubclassID, pButtonData);
2272  			NppDarkMode::setDarkExplorerTheme(hwnd);
2273  			return true;
2274  		}
2275  		return false;
2276  	}
2277  	void setDarkTitleBar(HWND hwnd)
2278  	{
2279  		constexpr DWORD win10Build2004 = 19041;
2280  		if (NppDarkMode::getWindowsBuildNumber() >= win10Build2004)
2281  		{
2282  			BOOL value = NppDarkMode::isEnabled() ? TRUE : FALSE;
2283  			::DwmSetWindowAttribute(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, &value, sizeof(value));
2284  		}
2285  		else
2286  		{
2287  			NppDarkMode::allowDarkModeForWindow(hwnd, NppDarkMode::isEnabled());
2288  			NppDarkMode::setTitleBarThemeColor(hwnd);
2289  		}
2290  	}
2291  	void setDarkExplorerTheme(HWND hwnd)
2292  	{
2293  		SetWindowTheme(hwnd, g_isAtLeastWindows10 && NppDarkMode::isEnabled() ? L"DarkMode_Explorer" : nullptr, nullptr);
2294  	}
2295  	void setDarkScrollBar(HWND hwnd)
2296  	{
2297  		NppDarkMode::setDarkExplorerTheme(hwnd);
2298  	}
2299  	void setDarkTooltips(HWND hwnd, ToolTipsType type)
2300  	{
2301  		UINT msg = 0;
2302  		switch (type)
2303  		{
2304  			case NppDarkMode::ToolTipsType::toolbar:
2305  				msg = TB_GETTOOLTIPS;
2306  				break;
2307  			case NppDarkMode::ToolTipsType::listview:
2308  				msg = LVM_GETTOOLTIPS;
2309  				break;
2310  			case NppDarkMode::ToolTipsType::treeview:
2311  				msg = TVM_GETTOOLTIPS;
2312  				break;
2313  			case NppDarkMode::ToolTipsType::tabbar:
2314  				msg = TCM_GETTOOLTIPS;
2315  				break;
2316  			default:
2317  				msg = 0;
2318  				break;
2319  		}
2320  		if (msg == 0)
2321  		{
2322  			NppDarkMode::setDarkExplorerTheme(hwnd);
2323  		}
2324  		else
2325  		{
2326  			auto hTips = reinterpret_cast<HWND>(::SendMessage(hwnd, msg, 0, 0));
2327  			if (hTips != nullptr)
2328  			{
2329  				NppDarkMode::setDarkExplorerTheme(hTips);
2330  			}
2331  		}
2332  	}
2333  	void setDarkLineAbovePanelToolbar(HWND hwnd)
2334  	{
2335  		COLORSCHEME scheme{};
2336  		scheme.dwSize = sizeof(COLORSCHEME);
2337  		if (NppDarkMode::isEnabled())
2338  		{
2339  			scheme.clrBtnHighlight = NppDarkMode::getDarkerBackgroundColor();
2340  			scheme.clrBtnShadow = NppDarkMode::getDarkerBackgroundColor();
2341  		}
2342  		else
2343  		{
2344  			scheme.clrBtnHighlight = CLR_DEFAULT;
2345  			scheme.clrBtnShadow = CLR_DEFAULT;
2346  		}
2347  		::SendMessage(hwnd, TB_SETCOLORSCHEME, 0, reinterpret_cast<LPARAM>(&scheme));
2348  	}
2349  	void setDarkListView(HWND hwnd)
2350  	{
2351  		if (NppDarkMode::isExperimentalSupported())
2352  		{
2353  			bool useDark = NppDarkMode::isEnabled();
2354  			HWND hHeader = ListView_GetHeader(hwnd);
2355  			NppDarkMode::allowDarkModeForWindow(hHeader, useDark);
2356  			SetWindowTheme(hHeader, useDark ? L"ItemsView" : nullptr, nullptr);
2357  			NppDarkMode::allowDarkModeForWindow(hwnd, useDark);
2358  			SetWindowTheme(hwnd, L"Explorer", nullptr);
2359  		}
2360  	}
2361  	void disableVisualStyle(HWND hwnd, bool doDisable)
2362  	{
2363  		if (doDisable)
2364  		{
2365  			SetWindowTheme(hwnd, L"", L"");
2366  		}
2367  		else
2368  		{
2369  			SetWindowTheme(hwnd, nullptr, nullptr);
2370  		}
2371  	}
2372  	constexpr double g_middleGrayRange = 2.0;
2373  	void calculateTreeViewStyle()
2374  	{
2375  		COLORREF bgColor = NppParameters::getInstance().getCurrentDefaultBgColor();
2376  		if (g_treeViewBg != bgColor || g_lighnessTreeView == 50.0)
2377  		{
2378  			g_lighnessTreeView = calculatePerceivedLighness(bgColor);
2379  			g_treeViewBg = bgColor;
2380  		}
2381  		if (g_lighnessTreeView < (50.0 - g_middleGrayRange))
2382  		{
2383  			g_treeViewStyle = TreeViewStyle::dark;
2384  		}
2385  		else if (g_lighnessTreeView > (50.0 + g_middleGrayRange))
2386  		{
2387  			g_treeViewStyle = TreeViewStyle::light;
2388  		}
2389  		else
2390  		{
2391  			g_treeViewStyle = TreeViewStyle::classic;
2392  		}
2393  	}
2394  	void setTreeViewStyle(HWND hwnd)
2395  	{
2396  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2397  		bool hasHotStyle = (style & TVS_TRACKSELECT) == TVS_TRACKSELECT;
2398  		bool change = false;
2399  		switch (g_treeViewStyle)
2400  		{
2401  			case TreeViewStyle::light:
2402  			{
2403  				if (!hasHotStyle)
2404  				{
2405  					style |= TVS_TRACKSELECT;
2406  					change = true;
2407  				}
2408  				SetWindowTheme(hwnd, L"Explorer", nullptr);
2409  				break;
2410  			}
2411  			case TreeViewStyle::dark:
2412  			{
2413  				if (!hasHotStyle)
2414  				{
2415  					style |= TVS_TRACKSELECT;
2416  					change = true;
2417  				}
2418  				SetWindowTheme(hwnd, g_isAtLeastWindows10 ? L"DarkMode_Explorer" : nullptr, nullptr);
2419  				break;
2420  			}
2421  			default:
2422  			{
2423  				if (hasHotStyle)
2424  				{
2425  					style &= ~TVS_TRACKSELECT;
2426  					change = true;
2427  				}
2428  				SetWindowTheme(hwnd, nullptr, nullptr);
2429  				break;
2430  			}
2431  		}
2432  		if (change)
2433  		{
2434  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2435  		}
2436  	}
2437  	bool isThemeDark()
2438  	{
2439  		return g_treeViewStyle == TreeViewStyle::dark;
2440  	}
2441  	void setBorder(HWND hwnd, bool border)
2442  	{
2443  		auto style = static_cast<long>(::GetWindowLongPtr(hwnd, GWL_STYLE));
2444  		bool hasBorder = (style & WS_BORDER) == WS_BORDER;
2445  		bool change = false;
2446  		if (!hasBorder && border)
2447  		{
2448  			style |= WS_BORDER;
2449  			change = true;
2450  		}
2451  		else if (hasBorder && !border)
2452  		{
2453  			style &= ~WS_BORDER;
2454  			change = true;
2455  		}
2456  		if (change)
2457  		{
2458  			::SetWindowLongPtr(hwnd, GWL_STYLE, style);
2459  			::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
2460  		}
2461  	}
2462  	BOOL CALLBACK enumAutocompleteProc(HWND hwnd, LPARAM &bsol;*lParam*/)
2463  	{
2464  		constexpr size_t classNameLen = 16;
2465  		TCHAR className[classNameLen]{};
2466  		GetClassName(hwnd, className, classNameLen);
2467  		if ((wcscmp(className, L"ListBoxX") == 0))
2468  		{
2469  			NppDarkMode::setDarkTitleBar(hwnd);
2470  			NppDarkMode::autoThemeChildControls(hwnd);
2471  			return FALSE;
2472  		}
2473  		return TRUE;
2474  	}
2475  	void setDarkAutoCompletion()
2476  	{
2477  		::EnumThreadWindows(::GetCurrentThreadId(), (WNDENUMPROC)enumAutocompleteProc, 0);
2478  	}
2479  	LRESULT onCtlColor(HDC hdc)
2480  	{
2481  		if (!NppDarkMode::isEnabled())
2482  		{
2483  			return FALSE;
2484  		}
2485  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2486  		::SetBkColor(hdc, NppDarkMode::getBackgroundColor());
2487  		return reinterpret_cast<LRESULT>(NppDarkMode::getBackgroundBrush());
2488  	}
2489  	LRESULT onCtlColorSofter(HDC hdc)
2490  	{
2491  		if (!NppDarkMode::isEnabled())
2492  		{
2493  			return FALSE;
2494  		}
2495  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2496  		::SetBkColor(hdc, NppDarkMode::getSofterBackgroundColor());
2497  		return reinterpret_cast<LRESULT>(NppDarkMode::getSofterBackgroundBrush());
2498  	}
2499  	LRESULT onCtlColorDarker(HDC hdc)
2500  	{
2501  		if (!NppDarkMode::isEnabled())
2502  		{
2503  			return FALSE;
2504  		}
2505  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2506  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2507  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2508  	}
2509  	LRESULT onCtlColorError(HDC hdc)
2510  	{
2511  		if (!NppDarkMode::isEnabled())
2512  		{
2513  			return FALSE;
2514  		}
2515  		::SetTextColor(hdc, NppDarkMode::getTextColor());
2516  		::SetBkColor(hdc, NppDarkMode::getErrorBackgroundColor());
2517  		return reinterpret_cast<LRESULT>(NppDarkMode::getErrorBackgroundBrush());
2518  	}
2519  	LRESULT onCtlColorDarkerBGStaticText(HDC hdc, bool isTextEnabled)
2520  	{
2521  		if (!NppDarkMode::isEnabled())
2522  		{
2523  			::SetTextColor(hdc, ::GetSysColor(isTextEnabled ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT));
2524  			return FALSE;
2525  		}
2526  		::SetTextColor(hdc, isTextEnabled ? NppDarkMode::getTextColor() : NppDarkMode::getDisabledTextColor());
2527  		::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
2528  		return reinterpret_cast<LRESULT>(NppDarkMode::getDarkerBackgroundBrush());
2529  	}
2530  	INT_PTR onCtlColorListbox(WPARAM wParam, LPARAM lParam)
2531  	{
2532  		auto hdc = reinterpret_cast<HDC>(wParam);
2533  		auto hwnd = reinterpret_cast<HWND>(lParam);
2534  		auto style = ::GetWindowLongPtr(hwnd, GWL_STYLE);
2535  		bool isComboBox = (style & LBS_COMBOBOX) == LBS_COMBOBOX;
2536  		if (!isComboBox && ::IsWindowEnabled(hwnd))
2537  		{
2538  			return static_cast<INT_PTR>(NppDarkMode::onCtlColorSofter(hdc));
2539  		}
2540  		return static_cast<INT_PTR>(NppDarkMode::onCtlColor(hdc));
2541  	}
2542  	struct HLSColour
2543  	{
2544  		WORD _hue;
2545  		WORD _lightness;
2546  		WORD _saturation;
2547  		COLORREF toRGB() const { return ColorHLSToRGB(_hue, _lightness, _saturation); }
2548  	};
2549  	using IndividualTabColours = std::array<HLSColour, 5>;
2550  	static constexpr IndividualTabColours individualTabHuesFor_Dark  { { HLSColour{37, 60, 60}, HLSColour{70, 60, 60}, HLSColour{144, 70, 60}, HLSColour{255, 60, 60}, HLSColour{195, 60, 60} } };
2551  	static constexpr IndividualTabColours individualTabHues          { { HLSColour{37, 210, 150}, HLSColour{70, 210, 150}, HLSColour{144, 210, 150}, HLSColour{255, 210, 150}, HLSColour{195, 210, 150}}};
2552  	COLORREF getIndividualTabColour(int colourIndex, bool themeDependant, bool saturated)
2553  	{
2554  		if (colourIndex < 0 || colourIndex > 4) return {};
2555  		HLSColour result;
2556  		if (themeDependant)
2557  		{
2558  			result = individualTabHuesFor_Dark[colourIndex];
2559  			if (saturated)
2560  			{
2561  				result._lightness = 146U;
2562  				result._saturation = std::min<WORD>(240U, result._saturation + 100U);
2563  			}
2564  		}
2565  		else
2566  		{
2567  			result = individualTabHues[colourIndex];
2568  			if (saturated)
2569  			{
2570  				result._lightness = 140U;
2571  				result._saturation = std::min<WORD>(240U, result._saturation + 30U);
2572  			}
2573  		}
2574  		return result.toRGB();
2575  	}
2576  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-BabyGrid.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1816  				  c=GetColOfMouse(SelfIndex,x);
1817  				   DrawCursor(hWnd,SelfIndex);
1818  				   if((r>0)&&(c>0))
1819  					   {
1820  					    if(r != BGHS[SelfIndex].cursorrow)
1821  							{
1822  							 BGHS[SelfIndex].cursorrow = r;
1823                               NRC=TRUE;
1824  							}
1825  						else
</pre></code></div>
                <div class="column column_space"><pre><code>1846  				auto isSelected = ListView_GetItemState(lplvcd->nmcd.hdr.hwndFrom, lplvcd->nmcd.dwItemSpec, LVIS_SELECTED) == LVIS_SELECTED;
1847  				if (NppDarkMode::isEnabled())
1848  				{
1849  					if (isSelected)
1850  					{
1851  						lplvcd->clrText = NppDarkMode::getTextColor();
1852  						lplvcd->clrTextBk = NppDarkMode::getSofterBackgroundColor();
1853  						::FillRect(lplvcd->nmcd.hdc, &lplvcd->nmcd.rc, NppDarkMode::getSofterBackgroundBrush());
1854  					}
1855  					else if ((lplvcd->nmcd.uItemState & CDIS_HOT) == CDIS_HOT)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    