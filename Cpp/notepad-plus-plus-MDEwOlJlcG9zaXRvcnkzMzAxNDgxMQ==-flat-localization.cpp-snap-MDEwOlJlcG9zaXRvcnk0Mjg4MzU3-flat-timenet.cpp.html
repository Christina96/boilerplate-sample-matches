
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.829181494661921%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-localization.cpp</h3>
            <pre><code>1  #include "Notepad_plus.h"
2  #include "ShortcutMapper.h"
3  #include "EncodingMapper.h"
4  #include "localization.h"
5  #include "fileBrowser.h"
6  using namespace std;
7  MenuPosition menuPos[] = {
8  	{ 0,  -1, -1, "file" },
9  	{ 1,  -1, -1, "edit" },
10  	{ 2,  -1, -1, "search" },
11  	{ 3,  -1, -1, "view" },
12  	{ 4,  -1, -1, "encoding" },
13  	{ 5,  -1, -1, "language" },
14  	{ 6,  -1, -1, "settings" },
15  	{ 7,  -1, -1, "tools" },
16  	{ 8,  -1, -1, "macro" },
17  	{ 9,  -1, -1, "run" },
18  	{ 10, -1, -1, "Plugins" },
19  	{ 11, -1, -1, "Window" },
20  	{ 0,   2, -1, "file-openFolder" },
21  	{ 0,  13, -1, "file-closeMore" },
22  	{ 0,  22, -1, "file-recentFiles" },
23  	{ 1,  11, -1, "edit-insert" },
24  	{ 1,  12, -1, "edit-copyToClipboard" },
25  	{ 1,  13, -1, "edit-indent" },
26  	{ 1,  14, -1, "edit-convertCaseTo" },
27  	{ 1,  15, -1, "edit-lineOperations" },
28  	{ 1,  16, -1, "edit-comment" },
29  	{ 1,  17, -1, "edit-autoCompletion" },
30  	{ 1,  18, -1, "edit-eolConversion" },
31  	{ 1,  19, -1, "edit-blankOperations" },
32  	{ 1,  20, -1, "edit-pasteSpecial" },
33  	{ 1,  21, -1, "edit-onSelection" },
34  	{ 2,  18, -1, "search-markAll" },
35  	{ 2,  19, -1, "search-markOne" },
36  	{ 2,  20, -1, "search-unmarkAll" },
37  	{ 2,  21, -1, "search-jumpUp" },
38  	{ 2,  22, -1, "search-jumpDown" },
39  	{ 2,  23, -1, "search-copyStyledText" },
40  	{ 2,  25, -1, "search-bookmark" },
41  	{ 3,   5, -1, "view-currentFileIn" },
42  	{ 3,   7, -1, "view-showSymbol" },
43  	{ 3,   8, -1, "view-zoom" },
44  	{ 3,   9, -1, "view-moveCloneDocument" },
45  	{ 3,  10, -1, "view-tab" },
46  	{ 3,  19, -1, "view-collapseLevel" },
47  	{ 3,  20, -1, "view-uncollapseLevel" },
48  	{ 3,  24, -1, "view-project" },
49  	{ 4,   5, -1, "encoding-characterSets" },
50  	{ 4,   5,  0, "encoding-arabic" },
51  	{ 4,   5,  1, "encoding-baltic" },
52  	{ 4,   5,  2, "encoding-celtic" },
53  	{ 4,   5,  3, "encoding-cyrillic" },
54  	{ 4,   5,  4, "encoding-centralEuropean" },
55  	{ 4,   5,  5, "encoding-chinese" },
56  	{ 4,   5,  6, "encoding-easternEuropean" },
57  	{ 4,   5,  7, "encoding-greek" },
58  	{ 4,   5,  8, "encoding-hebrew" },
59  	{ 4,   5,  9, "encoding-japanese" },
60  	{ 4,   5, 10, "encoding-korean" },
61  	{ 4,   5, 11, "encoding-northEuropean" },
62  	{ 4,   5, 12, "encoding-thai" },
63  	{ 4,   5, 13, "encoding-turkish" },
64  	{ 4,   5, 14, "encoding-westernEuropean" },
65  	{ 4,   5, 15, "encoding-vietnamese" },
66  	{ 5,  25, -1, "language-userDefinedLanguage" },
67  	{ 6,   4, -1, "settings-import" },
68  	{ 7,   0, -1, "tools-md5" },
69  	{ 7,   1, -1, "tools-sha256" },
70  	{ 11,  0, -1, "window-sortby"},
71  	{ -1,  -1, -1, "" } 
72  };
73  void NativeLangSpeaker::init(TiXmlDocumentA *nativeLangDocRootA, bool loadIfEnglish)
74  {
75  	if (nativeLangDocRootA)
76  	{
77  		_nativeLangA =  nativeLangDocRootA->FirstChild("NotepadPlus");
78  		if (_nativeLangA)
79  		{
80  			_nativeLangA = _nativeLangA->FirstChild("Native-Langue");
81  			if (_nativeLangA)
82  			{
83  				TiXmlElementA *element = _nativeLangA->ToElement();
84  				const char *rtl = element->Attribute("RTL");
85  				if (rtl)
86  					_isRTL = (strcmp(rtl, "yes") == 0);
87                  else
88                      _isRTL = false;
89                  _fileName = element->Attribute("filename");
90  				if (!loadIfEnglish && _fileName && stricmp("english.xml", _fileName) == 0)
91                  {
92  					_nativeLangA = NULL;
93  					return;
94  				}
95  				TiXmlDeclarationA *declaration =  _nativeLangA->GetDocument()->FirstChild()->ToDeclaration();
96  				if (declaration)
97  				{
98  					const char * encodingStr = declaration->Encoding();
99  					EncodingMapper& em = EncodingMapper::getInstance();
100                      int enc = em.getEncodingFromString(encodingStr);
101                      _nativeLangEncoding = (enc != -1)?enc:CP_ACP;
102  				}
103  			}	
104  		}
105      }
106  }
107  generic_string NativeLangSpeaker::getSubMenuEntryName(const char *nodeName) const
108  {
109  	if (!_nativeLangA) return TEXT("");
110  	TiXmlNodeA *mainMenu = _nativeLangA->FirstChild("Menu");
111  	if (!mainMenu) return TEXT("");
112  	mainMenu = mainMenu->FirstChild("Main");
113  	if (!mainMenu) return TEXT("");
114  	TiXmlNodeA *entriesRoot = mainMenu->FirstChild("SubEntries");
115  	if (!entriesRoot) return TEXT("");
116  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
117  	for (TiXmlNodeA *childNode = entriesRoot->FirstChildElement("Item");
118  		childNode ;
119  		childNode = childNode->NextSibling("Item") )
120  	{
121  		TiXmlElementA *element = childNode->ToElement();
122  		const char *idName = element->Attribute("subMenuId");
123  		if (idName)
124  		{
125  			const char *name = element->Attribute("name");
126  			if (!strcmp(idName, nodeName))
127  			{
128  				return wmc.char2wchar(name, _nativeLangEncoding);
129  			}
130  		}
131  	}
132  	return TEXT("");
133  }
134  generic_string NativeLangSpeaker::getNativeLangMenuString(int itemID) const
135  {
136  	if (!_nativeLangA)
137  		return TEXT("");
138  	TiXmlNodeA *node = _nativeLangA->FirstChild("Menu");
139  	if (!node) return TEXT("");
140  	node = node->FirstChild("Main");
141  	if (!node) return TEXT("");
142  	node = node->FirstChild("Commands");
143  	if (!node) return TEXT("");
144  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
145  	for (TiXmlNodeA *childNode = node->FirstChildElement("Item");
146  		childNode ;
147  		childNode = childNode->NextSibling("Item") )
148  	{
149  		TiXmlElementA *element = childNode->ToElement();
150  		int id;
151  		if (element->Attribute("id", &id) && (id == itemID))
152  		{
153  			const char *name = element->Attribute("name");
154  			if (name)
155  			{
156  				return wmc.char2wchar(name, _nativeLangEncoding);
157  			}
158  		}
159  	}
160  	return TEXT("");
161  }
162  generic_string NativeLangSpeaker::getShortcutNameString(int itemID) const
163  {
164  	if (!_nativeLangA)
165  		return TEXT("");
166  	TiXmlNodeA *node = _nativeLangA->FirstChild("Dialog");
167  	if (!node) return TEXT("");
168  	node = node->FirstChild("ShortcutMapper");
169  	if (!node) return TEXT("");
170  	node = node->FirstChild("MainCommandNames");
171  	if (!node) return TEXT("");
172  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
173  	for (TiXmlNodeA *childNode = node->FirstChildElement("Item");
174  		childNode ;
175  		childNode = childNode->NextSibling("Item") )
176  	{
177  		TiXmlElementA *element = childNode->ToElement();
178  		int id;
179  		if (element->Attribute("id", &id) && (id == itemID))
180  		{
181  			const char *name = element->Attribute("name");
182  			if (name)
183  			{
184  				return wmc.char2wchar(name, _nativeLangEncoding);
185  			}
186  		}
187  	}
188  	return TEXT("");
189  }
190  generic_string NativeLangSpeaker::getLocalizedStrFromID(const char *strID, const generic_string& defaultString) const
191  {
192  	if (!_nativeLangA)
193  		return defaultString;
194  	if (!strID)
195  		return defaultString;
196  	TiXmlNodeA *node = _nativeLangA->FirstChild("MiscStrings");
197  	if (!node) return defaultString;
198  	node = node->FirstChild(strID);
199  	if (!node) return defaultString;
200  	TiXmlElementA *element = node->ToElement();
201  	const char *value = element->Attribute("value");
202  	if (!value) return defaultString;
203  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
204  	return wmc.char2wchar(value, _nativeLangEncoding);
205  }
206  MenuPosition & getMenuPosition(const char *id)
207  {
208  	int nbSubMenuPos = sizeof(menuPos)/sizeof(MenuPosition);
209  	for (int i = 0; i < nbSubMenuPos; ++i) 
210  	{
211  		if (strcmp(menuPos[i]._id, id) == 0)
212  			return menuPos[i];
213  	}
214  	return menuPos[nbSubMenuPos-1];
215  }
216  void NativeLangSpeaker::changeMenuLang(HMENU menuHandle)
217  {
218  	if (nullptr == _nativeLangA)
219  		return;
220  	TiXmlNodeA *mainMenu = _nativeLangA->FirstChild("Menu");
221  	if (nullptr == mainMenu)
222  		return;
223  	mainMenu = mainMenu->FirstChild("Main");
224  	if (nullptr == mainMenu)
225  		return;
226  	TiXmlNodeA *entriesRoot = mainMenu->FirstChild("Entries");
227  	if (nullptr == entriesRoot)
228  		return;
229  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
230  	for (TiXmlNodeA *childNode = entriesRoot->FirstChildElement("Item");
231  		childNode ;
232  		childNode = childNode->NextSibling("Item") )
233  	{
234  		TiXmlElementA *element = childNode->ToElement();
235  		const char *menuIdStr = element->Attribute("menuId");
236  		if (menuIdStr)
237  		{
238  			MenuPosition & menuPos = getMenuPosition(menuIdStr);
239  			if (menuPos._x != -1)
240  			{
241  				const char *name = element->Attribute("name");
242  				const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
243  				::ModifyMenu(menuHandle, menuPos._x, MF_BYPOSITION, 0, nameW);
244  			}
245  		}
246  	}
247  	TiXmlNodeA *menuCommandsRoot = mainMenu->FirstChild("Commands");
248  	for (TiXmlNodeA *childNode = menuCommandsRoot->FirstChildElement("Item");
249  		childNode ;
250  		childNode = childNode->NextSibling("Item") )
251  	{
252  		TiXmlElementA *element = childNode->ToElement();
253  		int id;
254  		element->Attribute("id", &id);
255  		const char *name = element->Attribute("name");
256  		const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
257  		::ModifyMenu(menuHandle, id, MF_BYCOMMAND, id, nameW);
258  	}
259  	TiXmlNodeA *subEntriesRoot = mainMenu->FirstChild("SubEntries");
260  	for (TiXmlNodeA *childNode = subEntriesRoot->FirstChildElement("Item");
261  		childNode ;
262  		childNode = childNode->NextSibling("Item") )
263  	{
264  		TiXmlElementA* element = childNode->ToElement();
265  		const char* subMenuIdStr = element->Attribute("subMenuId");
266  		const char* name = element->Attribute("name");
267  		if (nullptr == subMenuIdStr or nullptr == name)
268  			continue;
269  		MenuPosition& menuPos = getMenuPosition(subMenuIdStr);
270  		int x = menuPos._x;
271  		int y = menuPos._y;
272  		int z = menuPos._z;
273  		HMENU hSubMenu = ::GetSubMenu(menuHandle, x);
274  		if (!hSubMenu)
275  			continue;
276  		HMENU hSubMenu2 = ::GetSubMenu(hSubMenu, y);
277  		if (!hSubMenu2)
278  			continue;
279  		HMENU hMenu = hSubMenu;
280  		int pos = y;
281  		if (z != -1)
282  		{
283  			HMENU hSubMenu3 = ::GetSubMenu(hSubMenu2, z);
284  			if (!hSubMenu3)
285  				continue;
286  			hMenu = hSubMenu2;
287  			pos = z;
288  		}
289  		const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
290  		::ModifyMenu(hMenu, pos, MF_BYPOSITION, 0, nameW);
291  	}
292  }
293  static const int tabCmSubMenuEntryPos[] =
294  {
295       1,   
296       4,   
297      13,   
298      14,   
299      15,   
300  };
301  void NativeLangSpeaker::changeLangTabContextMenu(HMENU hCM)
302  {
303  	if (_nativeLangA != nullptr)
304  	{
305  		TiXmlNodeA *tabBarMenu = _nativeLangA->FirstChild("Menu");
306  		if (tabBarMenu)
307  		{
308  			tabBarMenu = tabBarMenu->FirstChild("TabBar");
309  			if (tabBarMenu)
310  			{
311  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
312  				int nbSubEntry = sizeof(tabCmSubMenuEntryPos)/sizeof(int);
313  				for (TiXmlNodeA *childNode = tabBarMenu->FirstChildElement("Item");
314  					childNode ;
315  					childNode = childNode->NextSibling("Item") )
316  				{
317  					TiXmlElementA *element = childNode->ToElement();
318  					int cmd;
319  					const char *cmdStr = element->Attribute("CMDID", &cmd);
320  					if (!cmdStr || (cmd < 0))
321  						continue;
322  					const char* pName = element->Attribute("name");
323  					const wchar_t* pNameW = wmc.char2wchar(pName, _nativeLangEncoding);
324  					if (cmd > nbSubEntry) 
325  					{
326  						::ModifyMenu(hCM, cmd, MF_BYCOMMAND, cmd, pNameW);
327  					}
328  					else 
329  					{
330  						if (!NppParameters::getInstance().hasCustomTabContextMenu()) 
331  						{
332  							int subEntryIndex = cmd;
333  							int subEntrypos = tabCmSubMenuEntryPos[subEntryIndex];
334  							::ModifyMenu(hCM, subEntrypos, MF_BYPOSITION, cmd, pNameW);
335  						}
336  					}
337  				}
338  			}
339  		}
340  	}
341  }
342  void NativeLangSpeaker::changeLangTabDropContextMenu(HMENU hCM)
343  {
344  	const int POS_GO2VIEW = 0;
345  	const int POS_CLONE2VIEW = 1;
346  	if (_nativeLangA)
347  	{
348  		const char *goToViewA = nullptr;
349  		const char *cloneToViewA = nullptr;
350  		TiXmlNodeA *tabBarMenu = _nativeLangA->FirstChild("Menu");
351  		if (tabBarMenu)
352  			tabBarMenu = tabBarMenu->FirstChild("TabBar");
353  		if (tabBarMenu)
354  		{
355  			for (TiXmlNodeA *childNode = tabBarMenu->FirstChildElement("Item");
356  				childNode ;
357  				childNode = childNode->NextSibling("Item") )
358  			{
359  				TiXmlElementA *element = childNode->ToElement();
360  				int ordre;
361  				element->Attribute("CMDID", &ordre);
362  				if (ordre == IDM_VIEW_GOTO_ANOTHER_VIEW)
363  					goToViewA = element->Attribute("name");
364  				else if (ordre == IDM_VIEW_CLONE_TO_ANOTHER_VIEW)
365  					cloneToViewA = element->Attribute("name");
366  			}
367  		}
368  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
369  		if (goToViewA && goToViewA[0])
370  		{
371  			const wchar_t *goToViewG = wmc.char2wchar(goToViewA, _nativeLangEncoding);
372  			int cmdID = ::GetMenuItemID(hCM, POS_GO2VIEW);
373  			::ModifyMenu(hCM, POS_GO2VIEW, MF_BYPOSITION|MF_STRING, cmdID, goToViewG);
374  		}
375  		if (cloneToViewA && cloneToViewA[0])
376  		{
377  			const wchar_t *cloneToViewG = wmc.char2wchar(cloneToViewA, _nativeLangEncoding);
378  			int cmdID = ::GetMenuItemID(hCM, POS_CLONE2VIEW);
379  			::ModifyMenu(hCM, POS_CLONE2VIEW, MF_BYPOSITION|MF_STRING, cmdID, cloneToViewG);
380  		}
381  	}
382  }
383  void NativeLangSpeaker::changeLangTrayIconContexMenu(HMENU hCM)
384  {
385  	if (!_nativeLangA) return;
386  	TiXmlNodeA *tryIconMenu = _nativeLangA->FirstChild("Menu");
387  	if (!tryIconMenu) return;
388  	tryIconMenu = tryIconMenu->FirstChild("TrayIcon");
389  	if (!tryIconMenu) return;
390  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
391  	for (TiXmlNodeA *childNode = tryIconMenu->FirstChildElement("Item");
392  		childNode ;
393  		childNode = childNode->NextSibling("Item") )
394  	{
395  		TiXmlElementA *element = childNode->ToElement();
396  		int id;
397  		const char *sentinel = element->Attribute("id", &id);
398  		const char *name = element->Attribute("name");
399  		if (sentinel && (name && name[0]))
400  		{
401  			const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
402  			::ModifyMenu(hCM, id, MF_BYCOMMAND, id, nameW);
403  		}
404  	}
405  }
406  void NativeLangSpeaker::changeConfigLang(HWND hDlg)
407  {
408  	if (nullptr == _nativeLangA)
409  		return;
410  	TiXmlNodeA *styleConfDlgNode = _nativeLangA->FirstChild("Dialog");
411  	if (!styleConfDlgNode)
412  		return;
413  	styleConfDlgNode = styleConfDlgNode->FirstChild("StyleConfig");
414  	if (!styleConfDlgNode) return;
415  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
416  	const char *titre = (styleConfDlgNode->ToElement())->Attribute("title");
417  	if ((titre && titre[0]) && hDlg)
418  	{
419  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
420  		::SetWindowText(hDlg, nameW);
421  	}
422  	for (TiXmlNodeA *childNode = styleConfDlgNode->FirstChildElement("Item");
423  		childNode ;
424  		childNode = childNode->NextSibling("Item") )
425  	{
426  		TiXmlElementA *element = childNode->ToElement();
427  		int id;
428  		const char *sentinel = element->Attribute("id", &id);
429  		const char *name = element->Attribute("name");
430  		if (sentinel && (name && name[0]))
431  		{
432  			HWND hItem = ::GetDlgItem(hDlg, id);
433  			if (hItem)
434  			{
435  				const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
436  				::SetWindowText(hItem, nameW);
437  			}
438  		}
439  	}
440  	styleConfDlgNode = styleConfDlgNode->FirstChild("SubDialog");
441  	for (TiXmlNodeA *childNode = styleConfDlgNode->FirstChildElement("Item");
442  		childNode ;
443  		childNode = childNode->NextSibling("Item") )
444  	{
445  		TiXmlElementA *element = childNode->ToElement();
446  		int id;
447  		const char *sentinel = element->Attribute("id", &id);
448  		const char *name = element->Attribute("name");
449  		if (sentinel && (name && name[0]))
450  		{
451  			HWND hItem = ::GetDlgItem(hDlg, id);
452  			if (hItem)
453  			{
454  				const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
455  				::SetWindowText(hItem, nameW);
456  			}
457  		}
458  	}
459  }
460  void NativeLangSpeaker::changeStyleCtrlsLang(HWND hDlg, int *idArray, const char **translatedText)
461  {
462  	const int iColorStyle = 0;
463  	const int iUnderline = 8;
464  	HWND hItem;
465  	for (int i = iColorStyle ; i < (iUnderline + 1) ; ++i)
466  	{
467  		if (translatedText[i] && translatedText[i][0])
468  		{
469  			hItem = ::GetDlgItem(hDlg, idArray[i]);
470  			if (hItem)
471  			{
472  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
473  				const wchar_t *nameW = wmc.char2wchar(translatedText[i], _nativeLangEncoding);
474  				::SetWindowText(hItem, nameW);
475  			}
476  		}
477  	}
478  }
479  void NativeLangSpeaker::changeUserDefineLangPopupDlg(HWND hDlg)
480  {
481  	if (!_nativeLangA) return;
482  	TiXmlNodeA *userDefineDlgNode = _nativeLangA->FirstChild("Dialog");
483  	if (!userDefineDlgNode) return;	
484  	userDefineDlgNode = userDefineDlgNode->FirstChild("UserDefine");
485  	if (!userDefineDlgNode) return;
486  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
487  	TiXmlNodeA *stylerDialogNode = userDefineDlgNode->FirstChild("StylerDialog");
488  	if (!stylerDialogNode) return;
489  	const char *titre = (stylerDialogNode->ToElement())->Attribute("title");
490  	if (titre &&titre[0])
491  	{
492  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
493  		::SetWindowText(hDlg, nameW);
494  	}
495  	for (TiXmlNodeA *childNode = stylerDialogNode->FirstChildElement("Item");
496  		childNode ;
497  		childNode = childNode->NextSibling("Item") )
498  	{
499  		TiXmlElementA *element = childNode->ToElement();
500  		int id;
501  		const char *sentinel = element->Attribute("id", &id);
502  		const char *name = element->Attribute("name");
503  		if (sentinel && (name && name[0]))
504  		{
505  			HWND hItem = ::GetDlgItem(hDlg, id);
506  			if (hItem)
507  			{
508  				const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
509  				::SetWindowText(hItem, nameW);
510  			}
511  		}
512  	}
513  }
514  void NativeLangSpeaker::changeUserDefineLang(UserDefineDialog *userDefineDlg)
515  {
516  	if (!_nativeLangA) return;
517  	TiXmlNodeA *userDefineDlgNode = _nativeLangA->FirstChild("Dialog");
518  	if (!userDefineDlgNode) return;	
519  	userDefineDlgNode = userDefineDlgNode->FirstChild("UserDefine");
520  	if (!userDefineDlgNode) return;
521  	HWND hDlg = userDefineDlg->getHSelf();
522  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
523  	const char *titre = (userDefineDlgNode->ToElement())->Attribute("title");
524  	if (titre && titre[0])
525  	{
526  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
527  		::SetWindowText(hDlg, nameW);
528  	}
529  	for (TiXmlNodeA *childNode = userDefineDlgNode->FirstChildElement("Item");
530  		childNode ;
531  		childNode = childNode->NextSibling("Item") )
532  	{
533  		TiXmlElementA *element = childNode->ToElement();
534  		int id;
535  		const char *sentinel = element->Attribute("id", &id);
536  		const char *name = element->Attribute("name");
537  		if (sentinel && (name && name[0]))
538  		{
539  			if (id > 30)
540  			{
541  				HWND hItem = ::GetDlgItem(hDlg, id);
542  				if (hItem)
543  				{
544  					if (id == IDC_DOCK_BUTTON && userDefineDlg->isDocked())
545  					{
546  						generic_string name = getAttrNameByIdStr(TEXT("Undock"), userDefineDlgNode, std::to_string(IDC_UNDOCK_BUTTON).c_str());
547  						::SetWindowText(hItem, name.c_str());
548  					}
549  					else
550  					{
551  						const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
552  						::SetWindowText(hItem, nameW);
553  					}
554  				}
555  			}
556  		}
557  	}
558  	const int nbDlg = 4;
559  	HWND hDlgArrary[nbDlg]{};
560  	hDlgArrary[0] = userDefineDlg->getFolderHandle();
561  	hDlgArrary[1] = userDefineDlg->getKeywordsHandle();
562  	hDlgArrary[2] = userDefineDlg->getCommentHandle();
563  	hDlgArrary[3] = userDefineDlg->getSymbolHandle();
564  	const char nodeNameArray[nbDlg][16] = {"Folder", "Keywords", "Comment", "Operator"};
565  	for (int i = 0 ; i < nbDlg ; ++i)
566  	{
567  		TiXmlNodeA *node = userDefineDlgNode->FirstChild(nodeNameArray[i]);
568  		if (node) 
569  		{
570  			titre = (node->ToElement())->Attribute("title");
571  			if (titre &&titre[0])
572  			{
573  				const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
574  				userDefineDlg->setTabName(i, nameW);
575  			}
576  			for (TiXmlNodeA *childNode = node->FirstChildElement("Item");
577  				childNode ;
578  				childNode = childNode->NextSibling("Item") )
579  			{
580  				TiXmlElementA *element = childNode->ToElement();
581  				int id;
582  				const char *sentinel = element->Attribute("id", &id);
583  				const char *name = element->Attribute("name");
584  				if (sentinel && (name && name[0]))
585  				{
586  					HWND hItem = ::GetDlgItem(hDlgArrary[i], id);
587  					if (hItem)
588  					{
589  						const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
590  						::SetWindowText(hItem, nameW);
591  					}
592  				}
593  			}
594  		}
595  	}
596  	userDefineDlg->redraw();
597  }
598  void NativeLangSpeaker::changeFindReplaceDlgLang(FindReplaceDlg & findReplaceDlg)
599  {
600  	if (_nativeLangA)
601  	{
602  		TiXmlNodeA *dlgNode = _nativeLangA->FirstChild("Dialog");
603  		if (dlgNode)
604  		{
605  			NppParameters& nppParam = NppParameters::getInstance();
606  			dlgNode = searchDlgNode(dlgNode, "Find");
607  			if (dlgNode)
608  			{
609  				const char *titre1 = (dlgNode->ToElement())->Attribute("titleFind");
610  				const char *titre2 = (dlgNode->ToElement())->Attribute("titleReplace");
611  				const char *titre3 = (dlgNode->ToElement())->Attribute("titleFindInFiles");
612  				const char *titre4 = (dlgNode->ToElement())->Attribute("titleFindInProjects");
613  				const char *titre5 = (dlgNode->ToElement())->Attribute("titleMark");
614  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
615  				if (titre1 && titre1[0])
616  				{
617  					basic_string<wchar_t> nameW = wmc.char2wchar(titre1, _nativeLangEncoding);
618  					nppParam.getFindDlgTabTitiles()._find = nameW;
619  					findReplaceDlg.changeTabName(FIND_DLG, nppParam.getFindDlgTabTitiles()._find.c_str());
620  				}
621  				if (titre2  && titre2[0])
622  				{
623  					basic_string<wchar_t> nameW = wmc.char2wchar(titre2, _nativeLangEncoding);
624  					nppParam.getFindDlgTabTitiles()._replace = nameW;
625  					findReplaceDlg.changeTabName(REPLACE_DLG, nppParam.getFindDlgTabTitiles()._replace.c_str());
626  				}
627  				if (titre3 && titre3[0])
628  				{
629  					basic_string<wchar_t> nameW = wmc.char2wchar(titre3, _nativeLangEncoding);
630  					nppParam.getFindDlgTabTitiles()._findInFiles = nameW;
631  					findReplaceDlg.changeTabName(FINDINFILES_DLG, nppParam.getFindDlgTabTitiles()._findInFiles.c_str());
632  				}
633  				if (titre4 && titre4[0])
634  				{
635  					basic_string<wchar_t> nameW = wmc.char2wchar(titre4, _nativeLangEncoding);
636  					nppParam.getFindDlgTabTitiles()._findInProjects = nameW;
637  					findReplaceDlg.changeTabName(FINDINPROJECTS_DLG, nppParam.getFindDlgTabTitiles()._findInProjects.c_str());
638  				}
639  				if (titre5 && titre5[0])
640  				{
641  					basic_string<wchar_t> nameW = wmc.char2wchar(titre5, _nativeLangEncoding);
642  					nppParam.getFindDlgTabTitiles()._mark = nameW;
643  					findReplaceDlg.changeTabName(MARK_DLG, nppParam.getFindDlgTabTitiles()._mark.c_str());
644  				}
645  			}
646  		}
647  	}
648  	changeDlgLang(findReplaceDlg.getHSelf(), "Find");
649  }
650  void NativeLangSpeaker::changePluginsAdminDlgLang(PluginsAdminDlg & pluginsAdminDlg)
651  {
652  	if (_nativeLangA)
653  	{
654  		TiXmlNodeA *dlgNode = _nativeLangA->FirstChild("Dialog");
655  		if (dlgNode)
656  		{
657  			dlgNode = searchDlgNode(dlgNode, "PluginsAdminDlg");
658  			if (dlgNode)
659  			{
660  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
661  				TiXmlNodeA *ColumnPluginNode = dlgNode->FirstChild("ColumnPlugin");
662  				if (ColumnPluginNode)
663  				{
664  					const char *name = (ColumnPluginNode->ToElement())->Attribute("name");
665  					if (name && name[0])
666  					{
667  						basic_string<wchar_t> nameW = wmc.char2wchar(name, _nativeLangEncoding);
668  						pluginsAdminDlg.changeColumnName(COLUMN_PLUGIN, nameW.c_str());
669  					}
670  				}
671  				TiXmlNodeA *ColumnVersionNode = dlgNode->FirstChild("ColumnVersion");
672  				if (ColumnVersionNode)
673  				{
674  					const char *name = (ColumnVersionNode->ToElement())->Attribute("name");
675  					if (name && name[0])
676  					{
677  						basic_string<wchar_t> nameW = wmc.char2wchar(name, _nativeLangEncoding);
678  						pluginsAdminDlg.changeColumnName(COLUMN_VERSION, nameW.c_str());
679  					}
680  				}
681  				const char *titre1 = (dlgNode->ToElement())->Attribute("titleAvailable");
682  				const char *titre2 = (dlgNode->ToElement())->Attribute("titleUpdates");
683  				const char *titre3 = (dlgNode->ToElement())->Attribute("titleInstalled");
684  				const char *titre4 = (dlgNode->ToElement())->Attribute("titleIncompatible");
685  				if (titre1 && titre1[0])
686  				{
687  					basic_string<wchar_t> nameW = wmc.char2wchar(titre1, _nativeLangEncoding);
688  					pluginsAdminDlg.changeTabName(AVAILABLE_LIST, nameW.c_str());
689  				}
690  				if (titre2  && titre2[0])
691  				{
692  					basic_string<wchar_t> nameW = wmc.char2wchar(titre2, _nativeLangEncoding);
693  					pluginsAdminDlg.changeTabName(UPDATES_LIST, nameW.c_str());
694  				}
<span onclick='openModal()' class='match'>695  				if (titre3 && titre3[0])
696  				{
697  					basic_string<wchar_t> nameW = wmc.char2wchar(titre3, _nativeLangEncoding);
698  					pluginsAdminDlg.changeTabName(INSTALLED_LIST, nameW.c_str());
699  				}
700  				if (titre4 && titre4[0])
701  				{
702  					basic_string<wchar_t> nameW = wmc.char2wchar(titre4, _nativeLangEncoding);
703  					pluginsAdminDlg.changeTabName(INCOMPATIBLE_LIST, nameW.c_str());
704  				}
705  			}
706  			changeDlgLang(pluginsAdminDlg.getHSelf(), "PluginsAdminDlg");
707  		}
</span>708  	}
709  }
710  void NativeLangSpeaker::changePrefereceDlgLang(PreferenceDlg & preference) 
711  {
712  	auto currentSel = preference.getListSelectedIndex();
713  	changeDlgLang(preference.getHSelf(), "Preference");
714  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
715  	const size_t titreMaxSize = 128;
716  	char titre[titreMaxSize];
717  	changeDlgLang(preference._generalSubDlg.getHSelf(), "Global", titre, titreMaxSize);
718  	if (titre[0] != '\0')
719  	{
720  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
721  		preference.renameDialogTitle(TEXT("Global"), nameW);
722  	}
723  	changeDlgLang(preference._editingSubDlg.getHSelf(), "Scintillas", titre, titreMaxSize);
724  	if (titre[0] != '\0')
725  	{
726  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
727  		preference.renameDialogTitle(TEXT("Scintillas"), nameW);
728  	}
729  	changeDlgLang(preference._darkModeSubDlg.getHSelf(), "DarkMode", titre, titreMaxSize);
730  	if (titre[0] != '\0')
731  	{
732  		const wchar_t* nameW = wmc.char2wchar(titre, _nativeLangEncoding);
733  		preference.renameDialogTitle(TEXT("DarkMode"), nameW);
734  	}
735  	changeDlgLang(preference._marginsBorderEdgeSubDlg.getHSelf(), "MarginsBorderEdge", titre, titreMaxSize);
736  	if (titre[0] != '\0')
737  	{
738  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
739  		preference.renameDialogTitle(TEXT("MarginsBorderEdge"), nameW);
740  	}
741  	changeDlgLang(preference._newDocumentSubDlg.getHSelf(), "NewDoc", titre, titreMaxSize);
742  	if (titre[0] != '\0')
743  	{
744  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
745  		preference.renameDialogTitle(TEXT("NewDoc"), nameW);
746  	}
747  	changeDlgLang(preference._defaultDirectorySubDlg.getHSelf(), "DefaultDir", titre, titreMaxSize);
748  	if (titre[0] != '\0')
749  	{
750  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
751  		preference.renameDialogTitle(TEXT("DefaultDir"), nameW);
752  	}
753  	changeDlgLang(preference._recentFilesHistorySubDlg.getHSelf(), "RecentFilesHistory", titre, titreMaxSize);
754  	if (titre[0] != '\0')
755  	{
756  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
757  		preference.renameDialogTitle(TEXT("RecentFilesHistory"), nameW);
758  	}
759  	changeDlgLang(preference._fileAssocDlg.getHSelf(), "FileAssoc", titre, titreMaxSize);
760  	if (titre[0] != '\0')
761  	{
762  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
763  		preference.renameDialogTitle(TEXT("FileAssoc"), nameW);
764  	}
765  	changeDlgLang(preference._languageSubDlg.getHSelf(), "Language", titre, titreMaxSize);
766  	if (titre[0] != '\0')
767  	{
768  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
769  		preference.renameDialogTitle(TEXT("Language"), nameW);
770  	}
771  	changeDlgLang(preference._highlightingSubDlg.getHSelf(), "Highlighting", titre, titreMaxSize);
772  	if (titre[0] != '\0')
773  	{
774  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
775  		preference.renameDialogTitle(TEXT("Highlighting"), nameW);
776  	}
777  	changeDlgLang(preference._printSubDlg.getHSelf(), "Print", titre, titreMaxSize);
778  	if (titre[0] != '\0')
779  	{
780  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
781  		preference.renameDialogTitle(TEXT("Print"), nameW);
782  	}
783  	changeDlgLang(preference._searchingSubDlg.getHSelf(), "Searching", titre, titreMaxSize);
784  	if (titre[0] != '\0')
785  	{
786  		const wchar_t* nameW = wmc.char2wchar(titre, _nativeLangEncoding);
787  		preference.renameDialogTitle(TEXT("Searching"), nameW);
788  	}
789  	changeDlgLang(preference._miscSubDlg.getHSelf(), "MISC", titre, titreMaxSize);
790  	if (titre[0] != '\0')
791  	{
792  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
793  		preference.renameDialogTitle(TEXT("MISC"), nameW);
794  	}
795  	changeDlgLang(preference._backupSubDlg.getHSelf(), "Backup", titre, titreMaxSize);
796  	if (titre[0] != '\0')
797  	{
798  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
799  		preference.renameDialogTitle(TEXT("Backup"), nameW);
800  	}
801  	changeDlgLang(preference._autoCompletionSubDlg.getHSelf(), "AutoCompletion", titre, titreMaxSize);
802  	if (titre[0] != '\0')
803  	{
804  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
805  		preference.renameDialogTitle(TEXT("AutoCompletion"), nameW);
806  	}
807  	changeDlgLang(preference._multiInstanceSubDlg.getHSelf(), "MultiInstance", titre, titreMaxSize);
808  	if (titre[0] != '\0')
809  	{
810  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
811  		preference.renameDialogTitle(TEXT("MultiInstance"), nameW);
812  	}
813  	changeDlgLang(preference._delimiterSubDlg.getHSelf(), "Delimiter", titre, titreMaxSize);
814  	if (titre[0] != '\0')
815  	{
816  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
817  		preference.renameDialogTitle(TEXT("Delimiter"), nameW);
818  	}
819  	changeDlgLang(preference._performanceSubDlg.getHSelf(), "Performance", titre, titreMaxSize);
820  	if (titre[0] != '\0')
821  	{
822  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
823  		preference.renameDialogTitle(TEXT("Performance"), nameW);
824  	}
825  	changeDlgLang(preference._cloudAndLinkSubDlg.getHSelf(), "Cloud", titre, titreMaxSize);
826  	if (titre[0] != '\0')
827  	{
828  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
829  		preference.renameDialogTitle(TEXT("Cloud"), nameW);
830  	}
831  	changeDlgLang(preference._searchEngineSubDlg.getHSelf(), "SearchEngine", titre, titreMaxSize);
832  	if (titre[0] != '\0')
833  	{
834  		const wchar_t *nameW = wmc.char2wchar(titre, _nativeLangEncoding);
835  		preference.renameDialogTitle(TEXT("SearchEngine"), nameW);
836  	}
837  	preference.setListSelection(currentSel);
838  }
839  void NativeLangSpeaker::changeShortcutLang()
840  {
841  	if (!_nativeLangA) return;
842  	NppParameters& nppParam = NppParameters::getInstance();
843  	vector<CommandShortcut> & mainshortcuts = nppParam.getUserShortcuts();
844  	vector<ScintillaKeyMap> & scinshortcuts = nppParam.getScintillaKeyList();
845  	TiXmlNodeA *shortcuts = _nativeLangA->FirstChild("Shortcuts");
846  	if (!shortcuts) return;
847  	shortcuts = shortcuts->FirstChild("Main");
848  	if (!shortcuts) return;
849  	TiXmlNodeA *entriesRoot = shortcuts->FirstChild("Entries");
850  	if (!entriesRoot) return;
851  	for (TiXmlNodeA *childNode = entriesRoot->FirstChildElement("Item");
852  		childNode ;
853  		childNode = childNode->NextSibling("Item") )
854  	{
855  		TiXmlElementA *element = childNode->ToElement();
856  		int index, id;
857  		if (element->Attribute("index", &index) && element->Attribute("id", &id))
858  		{
859  			if (index > -1 && static_cast<size_t>(index) < mainshortcuts.size()) 
860  			{
861  				const char *name = element->Attribute("name");
862  				CommandShortcut & csc = mainshortcuts[index];
863  				if (csc.getID() == (unsigned long)id) 
864  				{
865  					csc.setName(name);
866  				}
867  			}
868  		}
869  	}
870  	shortcuts = _nativeLangA->FirstChild("Shortcuts");
871  	if (!shortcuts) return;
872  	shortcuts = shortcuts->FirstChild("Scintilla");
873  	if (!shortcuts) return;
874  	entriesRoot = shortcuts->FirstChild("Entries");
875  	if (!entriesRoot) return;
876  	for (TiXmlNodeA *childNode = entriesRoot->FirstChildElement("Item");
877  		childNode ;
878  		childNode = childNode->NextSibling("Item") )
879  	{
880  		TiXmlElementA *element = childNode->ToElement();
881  		int index;
882  		if (element->Attribute("index", &index))
883  		{
884  			if (index > -1 && static_cast<size_t>(index) < scinshortcuts.size()) 
885  			{
886  				const char *name = element->Attribute("name");
887  				ScintillaKeyMap & skm = scinshortcuts[index];
888  				skm.setName(name);
889  			}
890  		}
891  	}
892  }
893  generic_string NativeLangSpeaker::getShortcutMapperLangStr(const char *nodeName, const TCHAR *defaultStr) const
894  {
895  	if (!_nativeLangA) return defaultStr;
896  	TiXmlNodeA *targetNode = _nativeLangA->FirstChild("Dialog");
897  	if (!targetNode) return defaultStr;
898  	targetNode = targetNode->FirstChild("ShortcutMapper");
899  	if (!targetNode) return defaultStr;
900  	targetNode = targetNode->FirstChild(nodeName);
901  	if (!targetNode) return defaultStr;
902  	const char *name = (targetNode->ToElement())->Attribute("name");
903  	if (name && name[0])
904  	{
905  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
906  		return wmc.char2wchar(name, _nativeLangEncoding);
907  	}
908  	return defaultStr;
909  }
910  TiXmlNodeA * NativeLangSpeaker::searchDlgNode(TiXmlNodeA *node, const char *dlgTagName)
911  {
912  	TiXmlNodeA *dlgNode = node->FirstChild(dlgTagName);
913  	if (dlgNode) return dlgNode;
914  	for (TiXmlNodeA *childNode = node->FirstChildElement();
915  		childNode ;
916  		childNode = childNode->NextSibling() )
917  	{
918  		dlgNode = searchDlgNode(childNode, dlgTagName);
919  		if (dlgNode) return dlgNode;
920  	}
921  	return NULL;
922  }
923  bool NativeLangSpeaker::getDoSaveOrNotStrings(generic_string& title, generic_string& msg)
924  {
925  	if (!_nativeLangA) return false;
926  	TiXmlNodeA *dlgNode = _nativeLangA->FirstChild("Dialog");
927  	if (!dlgNode) return false;
928  	dlgNode = searchDlgNode(dlgNode, "DoSaveOrNot");
929  	if (!dlgNode) return false;
930  	const char *title2set = (dlgNode->ToElement())->Attribute("title");
931  	if (!title2set || !title2set[0]) return false;
932  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
933  	const wchar_t *titleW = wmc.char2wchar(title2set, _nativeLangEncoding);
934  	title = titleW;
935  	for (TiXmlNodeA *childNode = dlgNode->FirstChildElement("Item");
936  		childNode;
937  		childNode = childNode->NextSibling("Item"))
938  	{
939  		TiXmlElementA *element = childNode->ToElement();
940  		int id;
941  		const char *sentinel = element->Attribute("id", &id);
942  		const char *name = element->Attribute("name");
943  		if (sentinel && (name && name[0]))
944  		{
945  			if (id == 1761)
946  			{
947  				const wchar_t *msgW = wmc.char2wchar(name, _nativeLangEncoding);
948  				msg = msgW;
949  				return true;
950  			}
951  		}
952  	}
953  	return false;
954  }
955  bool NativeLangSpeaker::changeDlgLang(HWND hDlg, const char *dlgTagName, char *title, size_t titleMaxSize)
956  {
957  	if (title)
958  		title[0] = '\0';
959  	if (!_nativeLangA) return false;
960  	TiXmlNodeA *dlgNode = _nativeLangA->FirstChild("Dialog");
961  	if (!dlgNode) return false;
962  	dlgNode = searchDlgNode(dlgNode, dlgTagName);
963  	if (!dlgNode) return false;
964  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
965  	const char *title2set = (dlgNode->ToElement())->Attribute("title");
966  	if ((title2set && title2set[0]) && hDlg)
967  	{
968  		const wchar_t *nameW = wmc.char2wchar(title2set, _nativeLangEncoding);
969  		::SetWindowText(hDlg, nameW);
970  		if (title && titleMaxSize)
971  			strncpy(title, title2set, titleMaxSize - 1);
972  	}
973  	for (TiXmlNodeA *childNode = dlgNode->FirstChildElement("Item");
974  		childNode ;
975  		childNode = childNode->NextSibling("Item") )
976  	{
977  		TiXmlElementA *element = childNode->ToElement();
978  		int id;
979  		const char *sentinel = element->Attribute("id", &id);
980  		const char *name = element->Attribute("name");
981  		if (sentinel && (name && name[0]))
982  		{
983  			HWND hItem = ::GetDlgItem(hDlg, id);
984  			if (hItem)
985  			{
986  				const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
987  				::SetWindowText(hItem, nameW);
988  			}
989  		}
990  	}
991  	for (TiXmlNodeA *childNode = dlgNode->FirstChildElement("ComboBox");
992  		childNode;
993  		childNode = childNode->NextSibling("ComboBox"))
994  	{
995  		std::vector<generic_string> comboElms;
996  		TiXmlElementA *element = childNode->ToElement();
997  		int id;
998  		element->Attribute("id", &id);
999  		HWND hCombo = ::GetDlgItem(hDlg, id);
1000  		if (!hCombo) return false;
1001  		for (TiXmlNodeA *gChildNode = childNode->FirstChildElement("Element");
1002  			gChildNode;
1003  			gChildNode = gChildNode->NextSibling("Element"))
1004  		{
1005  			TiXmlElementA *comBoelement = gChildNode->ToElement();
1006  			const char *name = comBoelement->Attribute("name");
1007  			const wchar_t *nameW = wmc.char2wchar(name, _nativeLangEncoding);
1008  			comboElms.push_back(nameW);
1009  		}
1010  		size_t count = ::SendMessage(hCombo, CB_GETCOUNT, 0, 0);
1011  		if (count == comboElms.size())
1012  		{
1013  			auto selIndex = ::SendMessage(hCombo, CB_GETCURSEL, 0, 0);
1014  			::SendMessage(hCombo, CB_RESETCONTENT, 0, 0);
1015  			for (const auto& i : comboElms)
1016  			{
1017  				::SendMessage(hCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(i.c_str()));
1018  			}
1019  			::SendMessage(hCombo, CB_SETCURSEL, selIndex, 0);
1020  		}
1021  	}
1022  	return true;
1023  }
1024  bool NativeLangSpeaker::getMsgBoxLang(const char *msgBoxTagName, generic_string & title, generic_string & message)
1025  {
1026  	title = TEXT("");
1027  	message = TEXT("");
1028  	if (!_nativeLangA) return false;
1029  	TiXmlNodeA *msgBoxNode = _nativeLangA->FirstChild("MessageBox");
1030  	if (!msgBoxNode) return false;
1031  	msgBoxNode = searchDlgNode(msgBoxNode, msgBoxTagName);
1032  	if (!msgBoxNode) return false;
1033  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1034  	const char *titre = (msgBoxNode->ToElement())->Attribute("title");
1035  	const char *msg = (msgBoxNode->ToElement())->Attribute("message");
1036  	if ((titre && titre[0]) && (msg && msg[0]))
1037  	{
1038  		title = wmc.char2wchar(titre, _nativeLangEncoding);
1039  		message = wmc.char2wchar(msg, _nativeLangEncoding);
1040  		return true;
1041  	}
1042  	return false;
1043  }
1044  generic_string NativeLangSpeaker::getDlgLangMenuStr(const char* firstLevelNodeName, const char* secondLevelNodeName, int cmdID, const TCHAR* defaultStr) const
1045  {
1046  	if (!_nativeLangA) return defaultStr;
1047  	TiXmlNodeA *targetNode = _nativeLangA->FirstChild(firstLevelNodeName);
1048  	if (!targetNode) return defaultStr;
1049  	if (secondLevelNodeName && secondLevelNodeName[0])
1050  	{
1051  		targetNode = targetNode->FirstChild(secondLevelNodeName);
1052  		if (!targetNode) return defaultStr;
1053  	}
1054  	targetNode = targetNode->FirstChild("Menu");
1055  	if (!targetNode) return defaultStr;
1056  	const char *name = NULL;
1057  	for (TiXmlNodeA *childNode = targetNode->FirstChildElement("Item");
1058  		childNode;
1059  		childNode = childNode->NextSibling("Item"))
1060  	{
1061  		TiXmlElementA *element = childNode->ToElement();
1062  		int id;
1063  		const char *idStr = element->Attribute("id", &id);
1064  		if (idStr && id == cmdID)
1065  		{
1066  			name = element->Attribute("name");
1067  			break;
1068  		}
1069  	}
1070  	if (name && name[0])
1071  	{
1072  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1073  		return wmc.char2wchar(name, _nativeLangEncoding);
1074  	}
1075  	return defaultStr;
1076  }
1077  generic_string NativeLangSpeaker::getProjectPanelLangMenuStr(const char * nodeName, int cmdID, const TCHAR *defaultStr) const
1078  {
1079  	if (!_nativeLangA) return defaultStr;
1080  	TiXmlNodeA *targetNode = _nativeLangA->FirstChild("ProjectManager");
1081  	if (!targetNode) return defaultStr;
1082  	targetNode = targetNode->FirstChild("Menus");
1083  	if (!targetNode) return defaultStr;
1084  	targetNode = targetNode->FirstChild(nodeName);
1085  	if (!targetNode) return defaultStr;
1086  	const char *name = NULL;
1087  	for (TiXmlNodeA *childNode = targetNode->FirstChildElement("Item");
1088  		childNode ;
1089  		childNode = childNode->NextSibling("Item") )
1090  	{
1091  		TiXmlElementA *element = childNode->ToElement();
1092  		int id;
1093  		const char *idStr = element->Attribute("id", &id);
1094  		if (idStr && id == cmdID)
1095  		{
1096  			name = element->Attribute("name");
1097  			break;
1098  		}
1099  	}
1100  	if (name && name[0])
1101  	{
1102  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1103  		return wmc.char2wchar(name, _nativeLangEncoding);
1104  	}
1105  	return defaultStr;
1106  }
1107  generic_string NativeLangSpeaker::getAttrNameStr(const TCHAR *defaultStr, const char *nodeL1Name, const char *nodeL2Name, const char *nodeL3Name) const
1108  {
1109  	if (!_nativeLangA) return defaultStr;
1110  	TiXmlNodeA *targetNode = _nativeLangA->FirstChild(nodeL1Name);
1111  	if (!targetNode) return defaultStr;
1112  	if (nodeL2Name)
1113  		targetNode = targetNode->FirstChild(nodeL2Name);
1114  	if (!targetNode) return defaultStr;
1115  	const char *name = (targetNode->ToElement())->Attribute(nodeL3Name);
1116  	if (name && name[0])
1117  	{
1118  		WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1119  		return wmc.char2wchar(name, _nativeLangEncoding);
1120  	}
1121  	return defaultStr;
1122  }
1123  	generic_string NativeLangSpeaker::getAttrNameByIdStr(const TCHAR *defaultStr, TiXmlNodeA *targetNode, const char *nodeL1Value, const char *nodeL1Name, const char *nodeL2Name) const
1124  {
1125  	if (!targetNode) return defaultStr;
1126  	for (TiXmlNodeA *childNode = targetNode->FirstChildElement("Item");
1127  		childNode;
1128  		childNode = childNode->NextSibling("Item"))
1129  	{
1130  		TiXmlElementA *element = childNode->ToElement();
1131  		const char *id = element->Attribute(nodeL1Name);
1132  		if (id && id[0] && !strcmp(id, nodeL1Value))
1133  		{
1134  			const char *name = element->Attribute(nodeL2Name);
1135  			if (name && name[0])
1136  			{
1137  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1138  				return wmc.char2wchar(name, _nativeLangEncoding);
1139  			}
1140  		}
1141  	}
1142  	return defaultStr;
1143  }
1144  int NativeLangSpeaker::messageBox(const char *msgBoxTagName, HWND hWnd, const TCHAR *defaultMessage, const TCHAR *defaultTitle, int msgBoxType, int intInfo, const TCHAR *strInfo)
1145  {
1146  	if ((NppParameters::getInstance()).isEndSessionCritical())
1147  		return IDCANCEL; 
1148  	generic_string msg, title;
1149  	if (!getMsgBoxLang(msgBoxTagName, title, msg))
1150  	{
1151  		title = defaultTitle;
1152  		msg = defaultMessage;
1153  	}
1154  	title = stringReplace(title, TEXT("$INT_REPLACE$"), std::to_wstring(intInfo));
1155  	msg = stringReplace(msg, TEXT("$INT_REPLACE$"), std::to_wstring(intInfo));
1156  	if (strInfo)
1157  	{
1158  		title = stringReplace(title, TEXT("$STR_REPLACE$"), strInfo);
1159  		msg = stringReplace(msg, TEXT("$STR_REPLACE$"), strInfo);
1160  	}
1161  	if (_isRTL)
1162  	{
1163  		msgBoxType |= MB_RTLREADING | MB_RIGHT;
1164  	}
1165  	return ::MessageBox(hWnd, msg.c_str(), title.c_str(), msgBoxType);
1166  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</h3>
            <pre><code>1  TTimeNet& TTimeNet::operator = (const TTimeNet& TimeNet) {
2    if (this != &TimeNet) {
3      TNet::operator=(TimeNet);
4    }
5    return *this;
6  }
7  PTimeNet TTimeNet::GetSubGraph(const TIntV& NIdV) const {
8    PTimeNet NewNetPt = TTimeNet::New();
9    TTimeNet& NewNet = *NewNetPt;
10    NewNet.Reserve(NIdV.Len(), -1);
11    int node, edge;
12    TNodeI NI;
13    for (node = 0; node < NIdV.Len(); node++) {
14      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
15    }
16    for (node = 0; node < NIdV.Len(); node++) {
17      NI = GetNI(NIdV[node]);
18      const int SrcNId = NI.GetId();
19      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
20        const int OutNId = NI.GetOutNId(edge);
21        if (NewNet.IsNode(OutNId)) {
22          NewNet.AddEdge(SrcNId, OutNId); }
23      }
24    }
25    NewNet.Defrag();
26    return NewNetPt;
27  }
28  PTimeNENet TTimeNet::GetTimeNENet() const {
29    TIntV NIdV;  GetNIdByTm(NIdV);
30    PTimeNENet OutNet = TTimeNENet::New(GetNodes(), GetEdges());
31    for (int i = 0; i < NIdV.Len(); i++) {
32      const int Src = NIdV[i];
33      const TTimeNet::TNodeI NI = GetNI(Src);
34      const TSecTm SrcTm = NI.GetDat();
35      if (! OutNet->IsNode(Src)) { OutNet->AddNode(Src, SrcTm); }
36      for (int e = 0; e < NI.GetOutDeg(); e++) {
37        if (! OutNet->IsNode(NI.GetOutNId(e))) { OutNet->AddNode(NI.GetOutNId(e), SrcTm); }
38        OutNet->AddEdge(Src, NI.GetOutNId(e), -1, SrcTm);
39      }
40    }
41    return OutNet;
42  }
43  void TTimeNet::GetNIdByTm(TIntV& NIdV) const {
44    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
45    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
46      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
47    TmToNIdV.Sort();
48    NIdV.Gen(GetNodes(), 0);
49    for (int i = 0; i < TmToNIdV.Len(); i++) {
50      NIdV.Add(TmToNIdV[i].Dat); }
51  }
52  void TTimeNet::GetTmBuckets(const TTmUnit& TmUnit, TTmBucketV& TmBucketV) const {
53    THash<TInt, TIntV> TmIdToNIdVH;
54    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
55      const int TmId = NodeI().Round(TmUnit);
56      if (! TmIdToNIdVH.IsKey(TmId)) TmIdToNIdVH.AddKey(TmId);
57      TmIdToNIdVH.GetDat(TmId).Add(NodeI.GetId());
58    }
59    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
60    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
61    TmIdNIdVV.Sort();
62    TmBucketV.Gen(TmIdNIdVV.Len());
63    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
64      TTmBucket& Bucket = TmBucketV[i];
65      Bucket.BegTm = TmIdNIdVV[i].Val1;
66      Bucket.NIdV = TmIdNIdVV[i].Val2;
67    }
68  }
69  void TTimeNet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
70    TIntV NIdV;
71    GetNIdByTm(NIdV);
72    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
73    for (int i = 0; i < NIdV.Len(); i++) {
74      const int b = i/NodesPerBucket;
75      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
76      TmBucketV[b].NIdV.Add(NIdV[i]);
77    }
78  }
79  PGStatVec TTimeNet::TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const {
80    PGStatVec GrowthStat = new TGStatVec(TmUnit, TakeStat);
81    TTmBucketV TmBucketV;
82    GetTmBuckets(TmUnit, TmBucketV);
83    TIntV NodeIdV;
84    TExeTm ExeTm;
85    for (int t = 0; t < TmBucketV.Len(); t++) {
86      NodeIdV.AddV(TmBucketV[t].NIdV); 
87      printf("\n=== %d/%d] %s (%d nodes)\n", t+1, TmBucketV.Len(),
88        TmBucketV[t].BegTm.GetStr().CStr(), NodeIdV.Len());  ExeTm.Tick();
89      if (TmBucketV[t].BegTm < StartTm) continue;
90      PNGraph PreGraph = TSnap::ConvertSubGraph<PNGraph>(PTimeNet((TTimeNet*)this), NodeIdV); 
91      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
92    }
93    return GrowthStat;
94  }
95  void TTimeNet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
96                             const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc, const bool& AlsoRewire) const {
97    const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
98    TTmBucketV TmBucketV;
99    GetTmBuckets(TmUnit, TmBucketV);
100    TIntV NodeIdV;
101    TExeTm ExeTm, Run1Tm;
102    TFltTrV TmDiamV, NdsDiamV;
103    TFltTrV RwTmDiamV, RwNdsDiamV;
104    for (int t = 0; t < TmBucketV.Len(); t++) {
105      NodeIdV.AddV(TmBucketV[t].NIdV); 
106      printf("\n*** %d/%d] at %s (%d nodes)\n", t+1, TmBucketV.Len(),
107        TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), NodeIdV.Len());  ExeTm.Tick();
108      if (TmBucketV[t].BegTm < StartTm) continue;
109      PUNGraph PreGraph = TSnap::ConvertSubGraph<PUNGraph>(PTimeNet((TTimeNet*)this), NodeIdV);
110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
114        Mom.Add(EffDiam);  printf("[%s]\r", Run1Tm.GetTmStr());
115      }
116      Mom.Def();
117      TmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
118      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
119      NdsDiamV.Sort();
120      printf("  [%s]          \n", ExeTm.GetTmStr()); }
121      if (AlsoRewire) {
122        TIntV DegSeqV(PreGraph->GetNodes(), 0);
123        for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) { DegSeqV.Add(NI.GetDeg()); }
124        PUNGraph RwGraph = TSnap::GenConfModel(DegSeqV, TInt::Rnd);
125        printf("Configuration model: (%d, %d) --> (%d, %d)\n", PreGraph->GetNodes(), PreGraph->GetEdges(), RwGraph->GetNodes(), RwGraph->GetEdges());
126        TMom Mom;
127        for (int r = 0; r < NDiamRuns; r++) {
128          printf("  diam run %d...", r+1);  Run1Tm.Tick();
129          const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph):PreGraph);
130          Mom.Add(EffDiam);  printf(" current run [%s]\n", Run1Tm.GetTmStr());
131        }
132        Mom.Def();
133        RwTmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
134        RwNdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
135        RwNdsDiamV.Sort();
136        printf("done with diameter. Total time [%s] \n", ExeTm.GetTmStr());
137      }
138      { TGnuPlot GnuPlot("diamEff-T."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
139      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), WccStr+"Effective Diameter");
140      GnuPlot.AddErrBar(TmDiamV, "True", "");
141      if (! RwTmDiamV.Empty()) { GnuPlot.AddErrBar(RwTmDiamV, "Rewired", "");}
142      GnuPlot.SavePng(); }
143      { TGnuPlot GnuPlot("diamEff-N."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
144      GnuPlot.SetXYLabel("NODES", WccStr+"Effective Diameter");
145      GnuPlot.AddErrBar(NdsDiamV, "True", "");
146      if (! RwNdsDiamV.Empty()) { GnuPlot.AddErrBar(RwNdsDiamV, "Rewired", "");}
147      GnuPlot.SavePng(); }
148    }
149  }
150  void TTimeNet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
151                                 const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const {
152    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
153      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
154    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
155      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
156    const int NDiamRuns = 10;
157    const int NSamples = 100;
158    PUNGraph FullGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
159    if (DelPreTmEdges.IsDef()) {
160      int NDelNodes = 0, NDelEdges = 0;
161      printf("Deleting pre-%s node out-links\n", DelPreTmEdges.GetStr().CStr());
162      for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
163        if (NodeI() < DelPreTmEdges) {
164          const int NodeId = NodeI.GetId();
165          for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
166            FullGraph->DelEdge(NodeId, NodeI.GetOutNId(edge)); }
167          NDelEdges += NodeI.GetOutDeg();  NDelNodes++;
168        }
169      }
170      printf("  Deleted %d nodes out-edges (%d edges total).\n", NDelNodes, NDelEdges);
171      FullGraph->Defrag(true);
172    }
173    PGStatVec GrowthStat = TGStatVec::New(TmUnit);
174    TFltV PreDiamSDev, PreEffDiamSDev, WccDiamSDev, WccEffDiamSDev;
175    TIntV NodeIdV;
176    TExeTm ExeTm;
177    TTmBucketV TmBucketV;
178    GetTmBuckets(TmUnit, TmBucketV);
179    for (int t = 0; t < TmBucketV.Len(); t++) {
180      printf("\nGraph: %s (%d / %d) [%s]\n", TmBucketV[t].BegTm.GetTmStr().CStr(),
181        t+1, TmBucketV.Len(), TExeTm::GetCurTm());
182      NodeIdV.AddV(TmBucketV[t].NIdV); 
183      if (TmBucketV[t].BegTm < PostTmDiam) { continue; }
184      const PUNGraph PreGraph = TSnap::GetSubGraph(FullGraph, NodeIdV, true);
185      const PUNGraph WccGraph = TSnap::GetMxWcc(PreGraph);
186      TIntV PostYearNIdV, WccPostYearNIdV;
187      for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) {
188        if (GetNDat(NI.GetId()) >= PostTmDiam) {
189          PostYearNIdV.Add(NI.GetId());
190          if (WccGraph->IsNode(NI.GetId())) { WccPostYearNIdV.Add(NI.GetId()); }
191        }
192      }
193      TMom PreDiamMom, PreEffDiamMom, WccDiamMom, WccEffDiamMom;
194      int FullDiam; double EffDiam;
195      for (int r = 0; r < NDiamRuns; r++) {
196        if (! PostYearNIdV.Empty()) {
197          TSnap::GetBfsEffDiam(PreGraph, NSamples, PostYearNIdV, false, EffDiam, FullDiam);
198          PreDiamMom.Add(FullDiam);  PreEffDiamMom.Add(EffDiam);
199        }
200        if (! WccPostYearNIdV.Empty()) {
201          TSnap::GetBfsEffDiam(WccGraph, NSamples, WccPostYearNIdV, false, EffDiam, FullDiam);
202          WccDiamMom.Add(FullDiam);  WccEffDiamMom.Add(EffDiam);
203        }
204        printf("  diam: %d  [%s]  \r", r+1, ExeTm.GetTmStr());  ExeTm.Tick();
205      }
206      PreDiamMom.Def();  PreEffDiamMom.Def();
207      WccDiamMom.Def();  WccEffDiamMom.Def();
208      PGStat GraphStatPt = GrowthStat->Add(TmBucketV[t].BegTm);
209      TGStat& GS = *GraphStatPt;
210      GS.TakeBasicStat(PreGraph, false);
211      GS.TakeBasicStat(WccGraph, true);
212      GS.SetVal(gsvFullDiam, PreDiamMom.GetMean()); 
213      GS.SetVal(gsvEffDiam, PreEffDiamMom.GetMean());
214      GS.SetVal(gsvFullWccDiam, WccDiamMom.GetMean());
215      GS.SetVal(gsvEffWccDiam, WccEffDiamMom.GetMean());
216      GS.SetVal(gsvFullDiamDev, PreDiamMom.GetSDev()); 
217      GS.SetVal(gsvEffDiamDev, PreEffDiamMom.GetSDev());
218      GS.SetVal(gsvFullWccDiamDev, WccDiamMom.GetSDev());
219      GS.SetVal(gsvEffWccDiamDev, WccEffDiamMom.GetSDev());
220      { TFOut FOut("growth."+FNmPref+".gStatVec");  GrowthStat->Save(FOut); }
221      GrowthStat->SaveTxt(FNmPref, TStr::Fmt("%s. MISSING PAST DIAMETER\nDelPreEdges\t%s\nPostYearDiam\t%s\n",
222        Desc.CStr(), DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr()));
223    }
224  }
225  void TTimeNet::PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket) const {
226    if (Desc.Empty()) { Desc = FNmPref; }
227    TTimeNet::TTmBucketV TmBucketV;
228    TStr XLbl;
229    if (TmUnit == tmuNodes) {
230      XLbl = "Number of nodes (time)";
231      IAssert(NodesBucket > 0);
232      GetNodeBuckets(NodesBucket, TmBucketV); }
233    else {
234      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
235      GetTmBuckets(TmUnit, TmBucketV);
236    }
237    TIntV NodeIdV;
238    TFltPrV DegToCCfV, CcfV, OpClV, OpV;
239    TVec<TTuple<TFlt, 4> > OpenClsV;
240    TTuple<TFlt, 4> Tuple;
241    TExeTm ExeTm;
242    int XVal = 0;
243    printf("Clustering coefficient over time:\n  %d edges, %d edges per bucket, %d buckets \n", GetEdges(), 100000, TmBucketV.Len());
244    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
245    for (int t = 0; t < TmBucketV.Len(); t++) {
246      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
247      NodeIdV.AddV(TmBucketV[t].NIdV); 
248      int64 Open=0, Close=0;
249      const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);
250      const double CCf = TSnap::GetClustCf(Graph, DegToCCfV, Open, Close);
251      if (TmUnit == tmuNodes) { XVal = Graph->GetNodes(); }
252      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
253      CcfV.Add(TFltPr(XVal, CCf));
254      double FltOpen = static_cast<double>(Open);
255      double FltClose = static_cast<double>(Close);
256      OpClV.Add(TFltPr(XVal, (Open+Close==0 ? 0.0 : FltClose/(FltOpen+FltClose))));
257      OpV.Add(TFltPr(XVal, (Open==0 ? 0.0 : FltClose/FltOpen)));
258      Tuple[0]=Graph->GetNodes();
259      Tuple[1]=Graph->GetEdges();
260      Tuple[2]=FltClose;  Tuple[3]=FltOpen;
261      OpenClsV.Add(Tuple);
262      printf(" %s", ExeTm.GetStr());
263      TGnuPlot::PlotValV(DegToCCfV, TStr::Fmt("ccfAt%02dtm.%s", t+1, FNmPref.CStr()),
264        TStr::Fmt("%s. At time %d. Clustering Coefficient. G(%d,%d)", Desc.CStr(), t+1, Graph->GetNodes(), Graph->GetEdges()),
265        "Degree", "Clustering coefficient", gpsLog10XY, false);
266    }
267    TGnuPlot::PlotValV(CcfV, "ccfOverTm."+FNmPref, Desc+". Average Clustering Coefficient", XLbl, "Average clustering coefficient", gpsAuto, false);
268    TGnuPlot::PlotValV(OpClV, "ClsOpnTr1."+FNmPref, Desc+". Close/(Open+Closed) triads", XLbl, "Close / (Open+Closed) triads", gpsAuto, false);
269    TGnuPlot::PlotValV(OpV, "ClsOpnTr2."+FNmPref, Desc+". Close/Open triads", XLbl, "Close / Open triads", gpsAuto, false);
270    TGnuPlot::SaveTs(OpenClsV, "ClsOpnTr."+FNmPref+".tab", TStr::Fmt("#%s\n#Nodes\tEdges\tClosed\tOpenTriads", Desc.CStr()));
271    printf("\n");
272  }
273  void TTimeNet::PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket) const {
274    TTimeNet::TTmBucketV TmBucketV;
275    TStr XLbl;
276    if (TmUnit == tmuNodes) {
277      XLbl = "Number of nodes (time)";  IAssert(NodesPerBucket > 0);
278      GetNodeBuckets(NodesPerBucket, TmBucketV); }
279    else {
280      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
281      GetTmBuckets(TmUnit, TmBucketV); }
282    printf("\n\n%s\nMedian degree over time:\n  %d edges, %d edges per bucket, %d buckets \n", FNmPref.CStr(), GetEdges(), NodesPerBucket, TmBucketV.Len());
283    TFltPrV MedDegV, MedInDegV, MedOutDegV;
284    TIntV NodeIdV;
285    int XVal;
286    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
287    PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(PTimeNet((TTimeNet*)this));
288    FILE  *F = fopen(("gStat-"+FNmPref+".tab").CStr(), "wt");
289    fprintf(F, "UndirNodes\tUndirEdges\tUndirNonZNodes\tMedianDeg\tMeanDeg\tDirNodes\tDirEdges\tDirNonzNodes\tMedInDeg\tMedOutDeg\tMeanInDeg\tMeanOutDeg\n");
290    for (int t = 0; t < TmBucketV.Len(); t++) {
291      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
292      NodeIdV.AddV(TmBucketV[t].NIdV); 
293      if (TmUnit == tmuNodes) { XVal = NodeIdV.Len(); }
294      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
295      { const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);  TMom Mom;
296      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) { if (NI.GetOutDeg()>0) { Mom.Add(NI.GetOutDeg());} }
297      Mom.Def();  MedDegV.Add(TFltPr(XVal, Mom.GetMedian()));
298      fprintf(F, "%d\t%d\t%d\t%f\t%f", Graph->GetNodes(), Graph->GetEdges(), TSnap::CntNonZNodes(Graph), (float)Mom.GetMedian(), (float)Mom.GetMean()); }
299      { const PNGraph Graph = TSnap::GetSubGraph<PNGraph>(NGraph, NodeIdV); TMom MomOut, MomIn;
300      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301        if (NI.GetOutDeg()>0) { MomOut.Add(NI.GetOutDeg()); }
302        if (NI.GetInDeg()>0) { MomIn.Add(NI.GetInDeg()); } }
303      MomOut.Def();  MedOutDegV.Add(TFltPr(XVal, MomOut.GetMedian()));
304      MomIn.Def();  MedInDegV.Add(TFltPr(XVal, MomIn.GetMedian()));
305      fprintf(F, "\t%d\t%d\t%d\t%f\t%f\t%f\t%f\n", Graph->GetNodes(), Graph->GetEdges(), (int)TSnap::CntNonZNodes(Graph), (float)MomIn.GetMedian(), (float)MomOut.GetMedian(), (float)MomIn.GetMean(), (float)MomOut.GetMean()); }
306    }
307    fclose(F);
308    TGnuPlot::PlotValV(MedDegV, "medDeg."+FNmPref, FNmPref+" Median degree", TTmInfo::GetTmUnitStr(TmUnit), "Median degree");
309    TGnuPlot::PlotValV(MedOutDegV, "medOutDeg."+FNmPref, FNmPref+" Median OUT degree", TTmInfo::GetTmUnitStr(TmUnit), "Median OUT degree");
310    TGnuPlot::PlotValV(MedInDegV, "medInDeg."+FNmPref, FNmPref+" Median IN degree", TTmInfo::GetTmUnitStr(TmUnit), "Median IN degree");
311  }
312  PTimeNet TTimeNet::LoadBipartite(const TStr& InFNm) {
313    PTimeNet TimeNetPt = TTimeNet::New();
314    TTimeNet& TimeNet = *TimeNetPt;
315    PSs Ss = TSs::LoadTxt(ssfTabSep, InFNm.CStr());
316    TIntH Set1IdH; 
317    TStrV StrTimeV;
318    for (int y = 0; y < Ss->GetYLen(); y++) {
319      if (Ss->At(0, y)[0] == '#') continue; 
320      if (Ss->GetXLen(y) < 3) continue;     
321      const int& SrcId = Ss->At(0, y).GetInt();
322      IAssert(! Set1IdH.IsKey(SrcId));
323      IAssert(! TimeNet.IsNode(SrcId));
324      Set1IdH.AddKey(SrcId);
325      Ss->At(1, y).SplitOnAllCh('-', StrTimeV);
326      const int Year = StrTimeV[0].GetInt();
327      const int Month = StrTimeV[1].GetInt();
328      const int Day = StrTimeV[2].GetInt();
329      const TSecTm NodeTm(Year, Month, Day);
330      TimeNet.AddNode(SrcId, NodeTm);
331      for (int dst = 2; dst < Ss->GetXLen(y); dst++) {
332        const int DstId = Ss->At(dst, y).GetInt();
333        IAssert(! Set1IdH.IsKey(DstId));
334        if (! TimeNet.IsNode(DstId)) { TimeNet.AddNode(DstId, NodeTm); }
335        else { TimeNet.GetNDat(DstId) = TMath::Mn(NodeTm, TimeNet.GetNDat(DstId)); }
336        if (! TimeNet.IsEdge(SrcId, DstId)) { TimeNet.AddEdge(SrcId, DstId); }
337      }
338    }
339    TimeNet.Defrag();
340    printf("Bipartate graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
341    printf("  Bipartate sets: %d nodes --> %d nodes\n", TSnap::CntInDegNodes(TimeNetPt, 0),
342      TSnap::CntOutDegNodes(TimeNetPt, 0));
343    return TimeNetPt;
344  }
345  PTimeNet TTimeNet::LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm) {
346    TExeTm ExeTm;
347    PTimeNet TimeNetPt = TTimeNet::New();
348    TTimeNet& TimeNet = *TimeNetPt;
349    printf("Arxiv citation graph (paper publication year)...\n");
350    char Line [1024];
351    FILE *PprF = fopen(PaperFNm.CStr(), "rt");
352    TStr StrId, StrTime;
353    TStrV StrV, StrTimeV;
354    int N = 0, DuplicateNode = 0;
355    while (! feof(PprF)) {
356      Line[0] = 0;
357      fgets(Line, 1024, PprF);
358      if (strlen(Line) == 0 || Line[0] == '#') continue;
359      Line[strlen(Line)-1] = 0; 
360      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
361      StrId = StrV[0];  StrTime = StrV[1];  IAssert(!StrId.Empty() && !StrTime.Empty());
362      StrTime.SplitOnAllCh('-', StrTimeV);  IAssert(StrTimeV.Len() == 3);
363      const int NodeId = StrId.GetInt();
364      if (! TimeNet.IsNode(NodeId)) {
365        const int Year = StrTimeV[0].GetInt();
366        const int Month = StrTimeV[1].GetInt();
367        const int Day = StrTimeV[2].GetInt();
368        TimeNet.AddNode(NodeId, TSecTm(Year, Month, Day));
369      } else { DuplicateNode++; }
370      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
371    }
372    printf("\r  %d nodes read. %d duplicate nodes. %s\n", N, DuplicateNode, ExeTm.GetTmStr());
373    fclose(PprF);
374    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
375    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
376    N = 0;  ExeTm.Tick();
377    printf("Loading Arxiv citations...\n");
378    TIntPrV EdgeV;
379    THash<TInt, TSecTm> NIdToTimeH;
380    while (! feof(CiteF)) {
381      Line[0] = 0;
382      fgets(Line, 1024, CiteF);
383      if (strlen(Line) == 0 || Line[0] == '#') continue;
384      Line[strlen(Line)-1] = 0; 
385      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
386      const int SrcNId = StrV[0].GetInt();
387      const int DstNId = StrV[1].GetInt();
388      EdgeV.Add(TIntPr(SrcNId, DstNId));
389      if (! TimeNet.IsNode(DstNId) && TimeNet.IsNode(SrcNId)) {
390        const TSecTm& SrcTm = TimeNet.GetNDat(SrcNId);
391        if (! NIdToTimeH.IsKey(DstNId)) {
392          NIdToTimeH.AddDat(DstNId, SrcTm);
393          NewDstIds++;
394        }
395        else if (NIdToTimeH.GetDat(DstNId) < SrcTm) {
396          NIdToTimeH.GetDat(DstNId) = SrcTm; }
397      }
398      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
399    }
400    fclose(CiteF);
401    for (int i = 0; i < NIdToTimeH.Len(); i++) {
402      TimeNet.AddNode(NIdToTimeH.GetKey(i), NIdToTimeH[i]);
403    }
404    for (int i = 0; i < EdgeV.Len(); i++) {
405      const int SrcNId = EdgeV[i].Val1;
406      const int DstNId = EdgeV[i].Val2;
407      if (TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
408        if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
409        else { DupLinks++; }
410      } else {
411        if (! TimeNet.IsNode(SrcNId)) {
412          NewSrcIds++;
413          if (! TimeNet.IsNode(DstNId)) { NewCits++; }
414        }
415      }
416    }
417    printf("\r  %d citations read. %s\n", N, ExeTm.GetTmStr());
418    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
419    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
420    TIntV RmNIdV;
421    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
422      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
423    }
424    for (int i = 0; i < RmNIdV.Len(); i++) {
425      TimeNet.DelNode(RmNIdV[i]);
426    }
427    TimeNet.Defrag(true);
428    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
429    printf("  Duplicate citations                    : %d\n", DupLinks);
430    printf("  Nodes without time which are cited     : %d (add them to graph, use time of the earliest source node)\n", NewDstIds);
431    printf("  Citations between unknown time nodes   : %d\n", NewCits);
432    printf("  Nodes without time which make citations: %d (do not add them into the graph)\n", NewSrcIds);
433    return TimeNetPt;
434  }
435  PTimeNet TTimeNet::LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm) {
436    int N = 0;
437    TExeTm ExeTm;
438    PTimeNet TimeNetPt = TTimeNet::New();
439    TTimeNet& TimeNet = *TimeNetPt;
440    TimeNet.Reserve(4000000, 160000000);
441    printf("parsing patent data (patent grant year)...\n");
442    const int& PatIdCol = 0;
443    const int& GYearCol = 1;
444    TStrV ColV;
445    char Line [1024];
446    FILE *PatF = fopen(PatentFNm.CStr(), "rt");
447    fgets(Line, 1024, PatF); 
448    while (! feof(PatF)) {
449      Line[0] = 0;
450      fgets(Line, 1024, PatF);
451      if (strlen(Line) == 0) break;
452      TStr(Line).SplitOnAllCh(',', ColV, false);
453      IAssert(ColV.Len() == 23);
454      const int PatentId = ColV[PatIdCol].GetInt();
455      const int GrantYear = ColV[GYearCol].GetInt();
456      IAssert(! TimeNet.IsNode(PatentId));
457      TimeNet.AddNode(PatentId, TSecTm(GrantYear)); 
458      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
459    }
460    printf("\r  %d patents read. %s\n", N, ExeTm.GetTmStr());
461    fclose(PatF);
462    printf("\nLoading patent citations...\n");
463    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
464    N = 0;  ExeTm.Tick();
465    TStr SrcId, DstId;
466    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
467    fgets(Line, 1024, CiteF); 
468    while (! feof(CiteF)) {
469      Line[0] = 0;
470      fgets(Line, 1024, CiteF);
471      if (strlen(Line) == 0) break;
472      Line[strlen(Line)-1] = 0; 
473      TStr(Line).SplitOnCh(SrcId, ',', DstId);
474      const int SrcNId = SrcId.GetInt();
475      const int DstNId = DstId.GetInt();
476      if (! TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
477        NewCits++;
478        continue;
479      }
480      else if (TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
481        TimeNet.AddNode(DstNId, TimeNet.GetNDat(SrcNId));  NewDstIds++;
482      }
483      else if (! TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
484        TimeNet.AddNode(SrcNId, TimeNet.GetNDat(DstNId));  NewSrcIds++;
485      }
486      if (! TimeNet.IsEdge(SrcNId, DstNId)) {
487        TimeNet.AddEdge(SrcNId, DstNId);
488      } else { DupLinks++; }
489      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
490    }
491    fclose(CiteF);
492    printf("\r  %d citations read. %s\n\n", N, ExeTm.GetTmStr());
493    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
494    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
495    TIntV RmNIdV;
496    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
497      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
498    }
499    for (int i = 0; i < RmNIdV.Len(); i++) {
500      TimeNet.DelNode(RmNIdV[i]);
501    }
502    TimeNet.Defrag(true);
503    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
504    printf("  Duplicate citations                    : %d\n", DupLinks);
505    printf("  Citations between unknown time nodes   : %d\n", NewCits);
506    printf("  Nodes without time which make citations: %d\n", NewSrcIds);
507    printf("  Nodes without time which are cited     : %d\n", NewDstIds);
508    return TimeNetPt;
509  }
510  PTimeNet TTimeNet::LoadAmazon(const TStr& StlFNm) {
511    PTimeNet TimeNetPt = TTimeNet::New();
512    TTimeNet& TimeNet = *TimeNetPt;
513    TimeNet.Reserve(3953993, -1);
514    printf("Amazon Share-the-Love...\n");
515    char line [2024], MonthStr[4];
516    int NLines=0;
517    TStrV ColV;
518    FILE *F = fopen(StlFNm.CStr(), "rt");
519    while (! feof(F)) {
520      memset(line, 0, 2024);
521      fgets(line, 2024, F);
522      if (strlen(line) == 0) break;
523      TStr(line).SplitOnAllCh(',', ColV);
524      const int SrcNId = ColV[0].GetInt();
525      const int DstNId = ColV[1].GetInt();
526      TStr TmStr = ColV[2]; 
527      int Year = TmStr.GetSubStr(5, 6).GetInt();
528      if (Year < 10) { Year += 2000; } else { Year += 1900; }
529      MonthStr[0]=toupper(TmStr[2]);  MonthStr[1]=tolower(TmStr[3]);
530      MonthStr[2]=tolower(TmStr[4]);  MonthStr[3]=0;
531      const int Month = TTmInfo::GetMonthN(MonthStr, lUs);
532      const int Day = TmStr.GetSubStr(0, 1).GetInt();
533      const int Hour = TmStr.GetSubStr(8, 9).GetInt();
534      const int Min = TmStr.GetSubStr(11, 12).GetInt();
535      const int Sec = TmStr.GetSubStr(14, 15).GetInt();
536      if (! TimeNet.IsNode(SrcNId)) { TimeNet.AddNode(SrcNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
537      if (! TimeNet.IsNode(DstNId)) { TimeNet.AddNode(DstNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
538      if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
539      if (++NLines % 100000 == 0) printf("\r  %dk", NLines/1000);
540    }
541    fclose(F);
542    printf("\r  %d lines read\n", NLines);
543    printf("Graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
544    TimeNet.Defrag(true);
545    return TimeNetPt;
546  }
547  TTimeNENet& TTimeNENet::operator = (const TTimeNENet& TimeNet) {
548    if (this != &TimeNet) {
549      TNet::operator=(TimeNet);
550    }
551    return *this;
552  }
553  PTimeNet TTimeNENet::GetTimeNet() const {
554    PTimeNet NewNet = TTimeNet::New();
555    NewNet->Reserve(GetNodes(), -1);
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
557      NewNet->AddNode(NI.GetId(), NI.GetDat());
558    }
559    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
560      const int src = EI.GetSrcNId();
561      const int dst = EI.GetDstNId();
562      if (! NewNet->IsEdge(src, dst)) {
563        NewNet->AddEdge(src, dst); }
564    }
565    NewNet->Defrag();
566    return NewNet;
567  }
568  PTimeNENet TTimeNENet::Get1stEdgeNet() const {
569    PTimeNENet Net = TTimeNENet::New();
570    Net->Reserve(GetNodes(), -1);
571    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
572      Net->AddNode(NI.GetId(), NI.GetDat()); }
573    TIntV EIdV;  GetEIdByTm(EIdV);
574    TIntPrSet EdgeSet(GetEdges());
575    for (int edge = 0; edge < EIdV.Len(); edge++) {
576      const TEdgeI EI = GetEI(EIdV[edge]);
577      const int Src = EI.GetSrcNId();
578      const int Dst = EI.GetDstNId();
579      if (Src==Dst || EdgeSet.IsKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)))) { continue; } 
580      EdgeSet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)));
581      Net->AddEdge(EI);
582    }
583    return Net;
584  }
585  PTimeNENet TTimeNENet::GetSubGraph(const TIntV& NIdV) const {
586    PTimeNENet NewNetPt = TTimeNENet::New();
587    TTimeNENet& NewNet = *NewNetPt;
588    NewNet.Reserve(NIdV.Len(), -1);
589    int node, edge;
590    TNodeI NI;
591    for (node = 0; node < NIdV.Len(); node++) {
592      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node]));
593    }
594    for (node = 0; node < NIdV.Len(); node++) {
595      NI = GetNI(NIdV[node]);
596      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
597        const TEdgeI EI = GetEI(NI.GetOutEId(edge));
598        if (NewNet.IsNode(EI.GetDstNId())) {
599          NewNet.AddEdge(EI); }
600      }
601    }
602    NewNet.Defrag();
603    return NewNetPt;
604  }
605  PTimeNENet TTimeNENet::GetESubGraph(const TIntV& EIdV) const {
606    PTimeNENet NewNetPt = TTimeNENet::New();
607    TTimeNENet& NewNet = *NewNetPt;
608    NewNet.Reserve(-1, EIdV.Len());
609    for (int edge = 0; edge < EIdV.Len(); edge++) {
610      const TEdgeI Edge = GetEI(EIdV[edge]);
611      if (! NewNet.IsNode(Edge.GetSrcNId()))
612        NewNet.AddNode(GetNI(Edge.GetSrcNId()));
613      if (! NewNet.IsNode(Edge.GetDstNId()))
614        NewNet.AddNode(GetNI(Edge.GetDstNId()));
615      NewNet.AddEdge(Edge);
616    }
617    NewNet.Defrag();
618    return NewNetPt;
619  }
620  PTimeNENet TTimeNENet::GetGraphUpToTm(const TSecTm& MaxEdgeTm) const {
621    PTimeNENet NewNetPt = TTimeNENet::New();
622    TTimeNENet& NewNet = *NewNetPt;
623    TSecTm PrevTm;
624    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
625      if (EI() > MaxEdgeTm) { break; }
626      if (! NewNet.IsNode(EI.GetSrcNId()))
627        NewNet.AddNode(GetNI(EI.GetSrcNId()));
628      if (! NewNet.IsNode(EI.GetDstNId()))
629        NewNet.AddNode(GetNI(EI.GetDstNId()));
630      NewNet.AddEdge(EI);
631      IAssert(! PrevTm.IsDef() || PrevTm <= EI()); 
632      PrevTm = EI();
633    }
634    NewNet.Defrag();
635    return NewNetPt;
636  }
637  void TTimeNENet::SortNodeEdgeTimes() {
638    NodeH.SortByDat(true);
639    EdgeH.SortByDat(true);
640  }
641  void TTimeNENet::UpdateNodeTimes() {
642    int Cnt = 0;
643    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
644      TSecTm& NodeTm = NI();
645      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
646        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));
647        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
648      }
649      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
650        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));
651        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
652      }
653    }
654    printf("Update node times: %d/%d updates\n", Cnt, GetNodes());
655  }
656  void TTimeNENet::SetNodeTmToFirstEdgeTm() {
657    int Cnt = 0;
658    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
659      if (NI.GetDeg() == 0) { continue; }
660      TSecTm NodeTm;
661      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
662        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));  IAssert(EdgeTm.IsDef());
663        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
664      }
665      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
666        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));  IAssert(EdgeTm.IsDef());
667        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
668      }
669      GetNDat(NI.GetId()) = NodeTm;
670    }
671    printf("Node times set: %d/%d updates\n", Cnt, GetNodes());
672  }
673  void TTimeNENet::SetRndEdgeTimes(const int& MinTmEdge) {
674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
686      GetEDat(RndEIdV[e]) = TrueTmV[e]; }
687    UpdateNodeTimes();
688  }
689  void TTimeNENet::DumpTimeStat() const {
690    TSecTm MnNodeTm, MxNodeTm;
691    TSecTm MnEdgeTm, MxEdgeTm;
692    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
693      const TSecTm NodeTm = NI();
694      if (! MnNodeTm.IsDef() || MnNodeTm>NodeTm) { MnNodeTm = NodeTm; }
695      if (! MxNodeTm.IsDef() || MxNodeTm<NodeTm) { MxNodeTm = NodeTm; }
696    }
697    printf("Node times:\n  %s\n  %s\n", MnNodeTm.GetStr().CStr(), MxNodeTm.GetStr().CStr());
698    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
699      const TSecTm EdgeTm = EI();
<span onclick='openModal()' class='match'>700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
</span>705  void TTimeNENet::GetNIdByTm(TIntV& NIdV) const {
706    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
707    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
708      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
709    TmToNIdV.Sort();
710    NIdV.Gen(GetNodes(), 0);
711    for (int i = 0; i < TmToNIdV.Len(); i++) {
712      NIdV.Add(TmToNIdV[i].Dat); }
713  }
714  void TTimeNENet::GetEIdByTm(TIntV& EIdV) const {
715    TVec<TKeyDat<TSecTm, TInt> > TmToEIdV(GetEdges(), 0);
716    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
717      TmToEIdV.Add(TKeyDat<TSecTm, TInt>(EI.GetDat(), EI.GetId())); }
718    TmToEIdV.Sort();
719    EIdV.Gen(GetEdges(), 0);
720    for (int i = 0; i < TmToEIdV.Len(); i++) {
721      EIdV.Add(TmToEIdV[i].Dat); }
722  }
723  void TTimeNENet::GetTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
724    THash<TInt, TIntV> TmIdToNIdVH;
725    TIntV NIdV;  GetNIdByTm(NIdV);
726    for (int n = 0; n < NIdV.Len(); n++) {
727      const int TmId = GetNDat(NIdV[n]).Round(TmUnit).GetAbsSecs();
728      if (! TmIdToNIdVH.IsKey(TmId)) { TmIdToNIdVH.AddKey(TmId); }
729      TmIdToNIdVH.GetDat(TmId).Add(NIdV[n]);
730    }
731    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
732    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
733    TmIdNIdVV.Sort();
734    TmBucketV.Gen(TmIdNIdVV.Len());
735    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
736      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
737      Bucket.BegTm = TmIdNIdVV[i].Val1;
738      Bucket.NIdV = TmIdNIdVV[i].Val2;
739    }
740  }
741  void TTimeNENet::GetEdgeTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
742    THash<TInt, TIntV> TmIdToEIdVH;
743    TIntV EIdV;  GetEIdByTm(EIdV);
744    for (int e = 0; e < EIdV.Len(); e++) {
745      const int TmId = GetEDat(EIdV[e]).Round(TmUnit).GetAbsSecs();
746      if (! TmIdToEIdVH.IsKey(TmId)) { TmIdToEIdVH.AddKey(TmId); }
747      TmIdToEIdVH.GetDat(TmId).Add(EIdV[e]);
748    }
749    TVec<TPair<TInt, TIntV> > TmIdEIdVV;
750    TmIdToEIdVH.GetKeyDatPrV(TmIdEIdVV);
751    TmIdEIdVV.Sort();
752    TmBucketV.Gen(TmIdEIdVV.Len());
753    for (int i = 0; i < TmIdEIdVV.Len(); i++) {
754      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
755      Bucket.BegTm = TmIdEIdVV[i].Val1;
756      Bucket.NIdV = TmIdEIdVV[i].Val2;
757    }
758  }
759  void TTimeNENet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
760    TIntV NIdV;  GetNIdByTm(NIdV);
761    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
762    for (int i = 0; i < NIdV.Len(); i++) {
763      const int b = i/NodesPerBucket;
764      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
765      TmBucketV[b].NIdV.Add(NIdV[i]);
766    }
767  }
768  void TTimeNENet::GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
769    TIntV EIdV;  GetEIdByTm(EIdV);
770    TmBucketV.Gen(EIdV.Len()/EdgesPerBucket + 1, 0);
771    for (int i = 0; i < EIdV.Len(); i++) {
772      const int b = i/EdgesPerBucket;
773      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
774      TmBucketV[b].NIdV.Add(EIdV[i]);
775    }
776  }
777  int TTimeNENet::GetTriadEdges(TIntV& TriadEIdV) const {
778    PUNGraph Graph = TUNGraph::New(GetNodes(), GetEdges());
779    TIntV EIdV;  GetEIdByTm(EIdV);
780    TriadEIdV.Clr();
781    TExeTm ExeTm;
782    for (int edge = 0; edge < EIdV.Len(); edge++) {
783      const TEdgeI EI = GetEI(EIdV[edge]);
784      const int Src = EI.GetSrcNId();
785      const int Dst = EI.GetDstNId();
786      if (Src==Dst || Graph->IsEdge(Src, Dst)) { continue; } 
787      if (! Graph->IsNode(Src)) { Graph->AddNode(Src); }
788      if (! Graph->IsNode(Dst)) { Graph->AddNode(Dst); }
789      if (TSnap::GetCmnNbrs(Graph, Src, Dst) > 0) { TriadEIdV.Add(EIdV[edge]); }
790      Graph->AddEdge(Src, Dst);
791      if (edge % 10000 == 0) {
792        printf("\redges %dk / %dk: triangle edges: %dk [total %s]", edge/1000, EIdV.Len()/1000,
793          TriadEIdV.Len()/1000, ExeTm.GetStr()); }
794    }
795    return Graph->GetEdges();
796  }
797  PGStatVec TTimeNENet::TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm) const {
798    TExeTm ExeTm;
799    PGStatVec GStatVec = TGStatVec::New(TimeStep, TakeStat);
800    TTimeNet::TTmBucketV TmBucketV;
801    GetEdgeTmBuckets(TimeStep, TmBucketV);
802    const PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
803    TIntV EdgeIdV;
804    for (int t = 0; t < TmBucketV.Len(); t++) {
805      EdgeIdV.AddV(TmBucketV[t].NIdV); 
806      printf("\n***%d/%d: %s (%d edges) ", t+1, TmBucketV.Len(), TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
807      if (TmBucketV[t].BegTm < StartTm) { continue; }
808      const PNEGraph PreGraph = TSnap::GetESubGraph(FullGraph, EdgeIdV);
809      GStatVec->Add(PreGraph, TmBucketV[t].BegTm);
810      printf("  [%s]\n", ExeTm.GetTmStr());
811    }
812    return GStatVec;
813  }
814  PGStatVec TTimeNENet::TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
815                              const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const {
816    TGStat::NDiamRuns = NDiamRuns;
817    PGStatVec GrowthStat = TGStatVec::New(TmUnit, TakeStat);
818    TTimeNet::TTmBucketV TmBucketV;
819    GetEdgeTmBuckets(TmUnit, TmBucketV);
820    TIntV EdgeIdV;
821    TExeTm ExeTm;
822    for (int t = 0; t < TmBucketV.Len(); t++) {
823      if (TakeNTmUnits == -1) {
824        EdgeIdV.AddV(TmBucketV[t].NIdV); }
825      else {
826        if (t < TakeNTmUnits) { continue; }
827        EdgeIdV.Clr(false);
828        for (int i = t-TakeNTmUnits; i < t; i++) { EdgeIdV.AddV(TmBucketV[i].NIdV); }
829      }
830      printf("*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
831      PNEGraph PreGraph = TSnap::ConvertESubGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this), EdgeIdV);
832      if (LinkBWays) {
833        TIntV KeepEIdV; 
834        for (TNEGraph::TEdgeI EI = PreGraph->BegEI(); EI < PreGraph->EndEI(); EI++) {
835          if (PreGraph->IsEdge(EI.GetDstNId(), EI.GetSrcNId(), true)) { KeepEIdV.Add(EI.GetId()); }
836        }
837        PreGraph = TSnap::GetESubGraph(PreGraph, KeepEIdV);
838      }
839      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
840      { TFOut FOut(TStr::Fmt("growth.%s.gStatVec", FNmPref.CStr()));
841      GrowthStat->Save(FOut); }
842      GrowthStat->SaveTxt(FNmPref, Desc);
843      printf("  [%s]\n", ExeTm.GetTmStr());
844    }
845    return GrowthStat;
846  }
847  void TTimeNENet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
848                               const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc) const {
849    TTimeNet::TTmBucketV TmBucketV;
850    GetEdgeTmBuckets(TmUnit, TmBucketV);
851    PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
852    TIntV EdgeIdV;
853    TExeTm ExeTm, Run1Tm;
854    TFltTrV TmDiamV, NdsDiamV;
855    for (int t = 0; t < TmBucketV.Len(); t++) {
856      EdgeIdV.AddV(TmBucketV[t].NIdV); 
857      printf("\n*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), EdgeIdV.Len());  ExeTm.Tick();
858      if (TmBucketV[t].BegTm < StartTm) continue;
859      PNGraph PreGraph = TSnap::ConvertESubGraph<PNGraph>(FullGraph, EdgeIdV);
860      TMom Mom;
861      double EffDiam = 0.0;
862      for (int r = 0; r < NDiamRuns; r++) {
863        printf("%d...", r+1);  Run1Tm.Tick();
864        if (OnlyWcc) { EffDiam = TSnap::GetAnfEffDiam(TSnap::GetMxWcc(PreGraph)); }
865        else { EffDiam = TSnap::GetAnfEffDiam(PreGraph); }
866        Mom.Add(EffDiam);
867        printf("[%s]\r", Run1Tm.GetTmStr());
868      }
869      Mom.Def();
870      TmDiamV.Add(TFltTr(TmBucketV[t].BegTm.Round(TmUnit).GetAbsSecs(), Mom.GetMean(), Mom.GetSDev()));
871      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
872      NdsDiamV.Sort();
873      printf("  [%s]          \n", ExeTm.GetTmStr());
874      const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
875      { TGnuPlot GnuPlot("diamEff1."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
876      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), "AVERAGE "+WccStr+"Effective Diameter");
877      GnuPlot.AddErrBar(TmDiamV, "", "");
878      GnuPlot.SavePng(); }
879      { TGnuPlot GnuPlot("diamEff2."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
880      GnuPlot.SetXYLabel("NODES", "AVERAGE "+WccStr+"Effective Diameter");
881      GnuPlot.AddErrBar(NdsDiamV, "", "");
882      GnuPlot.SavePng(); }
883    }
884  }
885  void TTimeNENet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
886                                   const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays) {
887    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
888      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
889    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
890      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
891  }
892  PTimeNENet TTimeNENet::GetGnmRndNet(const int& Nodes, const int& Edges) {
893    printf("Generating G_nm(%d, %d)\n", Nodes, Edges);
894    int Src, Dst;
895    PTimeNENet Net = TTimeNENet::New();
896    Net->Reserve(Nodes, Edges);
897    for (int e = 0; e < Edges; e++) {
898      Src = TInt::Rnd.GetUniDevInt(Nodes);
899      Dst = TInt::Rnd.GetUniDevInt(Nodes);
900      while (Dst == Src || Net->IsEdge(Src, Dst)) {
901        Dst = TInt::Rnd.GetUniDevInt(Nodes); }
902      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(e)); }
903      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(e)); }
904      Net->AddEdge(Src, Dst, -1, TSecTm(e));
905    }
906    return Net;
907  }
908  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut) {
909    const double Alpha = Nodes/double(Edges);
910    printf("Generating PA(%d, %d), with slope in:%.1f, out: %.1f\n", Nodes, Edges,
911      2+GammaIn/(Alpha/(1-Alpha)), 2+GammaOut/(Alpha/(1-Alpha)));
912    int nodes=0, edges=0, time=0, iter=0;
913    TIntV OutW(Edges, 0), InW(Edges, 0);
914    PTimeNENet Net = TTimeNENet::New();
915    Net->Reserve(Nodes, Edges);
916    Net->AddNode(0, TSecTm(time++));  nodes++;
917    OutW.Add(0);  InW.Add(0);
918    while (edges < Edges) {
919      int Src=-1, Dst=-1;  iter++;
920      if (TInt::Rnd.GetUniDev() < Alpha) {
921        if (nodes < Nodes) {
922          IAssert(Net->AddNode(nodes, TSecTm(time++)));
923          nodes++; }
924      } else {
925        if (TInt::Rnd.GetUniDev() < nodes*GammaIn/double(edges+nodes*GammaIn)) {
926          Src = TInt::Rnd.GetUniDevInt(nodes); }
927        else { Src = OutW[TInt::Rnd.GetUniDevInt(OutW.Len())]; }
928        if (TInt::Rnd.GetUniDev() < nodes*GammaOut/double(edges+nodes*GammaOut)) {
929          Dst = TInt::Rnd.GetUniDevInt(nodes); }
930        else { Dst = InW[TInt::Rnd.GetUniDevInt(InW.Len())]; }
931      }
932      if (Src == Dst || Net->IsEdge(Src, Dst)) {
933        continue;
934      }
935      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(time++)); nodes++; }
936      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(time++)); nodes++; }
937      Net->AddEdge(Src, Dst, -1, TSecTm(time++));
938      OutW.Add(Src); InW.Add(Dst); edges++;
939    }
940    for (int node = 0; node < Nodes; node++) {
941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
947    printf("Generating PA, nodes:%d, out-deg:%d\n", Nodes, OutDeg);
948    int time=0;
949    PTimeNENet Net = TTimeNENet::New();
950    Net->Reserve(Nodes, OutDeg*Nodes);
951    Net->AddNode(0, TSecTm(++time));  Net->AddNode(1, TSecTm(++time));
952    Net->AddEdge(0, 1, -1, TSecTm(++time));
953    TIntV NIdV;  NIdV.Add(0);  NIdV.Add(1);
954    TIntSet NodeSet;
955    for (int node = 2; node <= Nodes; node++) {
956      NodeSet.Clr(false);
957      while (NodeSet.Len() < OutDeg && NodeSet.Len() < node) {
958        NodeSet.AddKey(NIdV[TInt::Rnd.GetUniDevInt(NIdV.Len())]);
959      }
960      const int N = Net->AddNode(node, TSecTm(++time));
961      for (int i = 0; i < NodeSet.Len(); i++) {
962        Net->AddEdge(node, NodeSet[i], -1, TSecTm(++time));
963        NIdV.Add(N);  NIdV.Add(NodeSet[i]);
964      }
965    }
966    return Net;
967  }
968  void TTimeNENet::SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId, const bool& RelativeTm) const {
969    TIntV EIdV;  GetEIdByTm(EIdV);
970    const int BegTm = RelativeTm ? GetEDat(EIdV[0]).GetAbsSecs() : 0;
971    TIntSet NIdMap;
972    if (RenumberNId) { NIdMap.Gen(GetNodes()); }
973    FILE *F = fopen(EdgeFNm.CStr(), "wt");
974    for (int e =0; e < EIdV.Len(); e++) {
975      const TEdgeI EI = GetEI(EIdV[e]);
976      if (RenumberNId) {
977        const int src = EI.GetSrcNId();
978        const int dst = EI.GetDstNId();
979        NIdMap.AddKey(src);  NIdMap.AddKey(dst);
980        fprintf(F, "%d\t%d\t%d\n", NIdMap.GetKeyId(src), NIdMap.GetKeyId(dst), EI().GetAbsSecs()-BegTm);
981      }else {
982        fprintf(F, "%d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI().GetAbsSecs()-BegTm); }
983    }
984    fclose(F);
985  }
986  PTimeNENet TTimeNENet::GetSmallNet() {
987    PTimeNENet Net = TTimeNENet::New();
988    for (int i = 1; i <= 6; i++) {
989      Net->AddNode(i, TSecTm(0)); }
990    int tm = 1;
991    Net->AddEdge(1, 2, -1, TSecTm(tm++));
992    Net->AddEdge(3, 4, -1, TSecTm(tm++));
993    Net->AddEdge(3, 1, -1, TSecTm(tm++));
994    Net->AddEdge(5, 6, -1, TSecTm(tm++));
995    Net->AddEdge(6, 4, -1, TSecTm(tm++));
996    Net->AddEdge(5, 3, -1, TSecTm(tm++));
997    Net->AddEdge(5, 4, -1, TSecTm(tm++));
998    Net->AddEdge(5, 2, -1, TSecTm(tm++));
999    return Net;
1000  }
1001  PTimeNENet TTimeNENet::LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm) {
1002    const int BegOfTm = 1047369600; 
1003    PTimeNENet Net = TTimeNENet::New();
1004    printf("Adding nodes...");
1005    { TSsParser Ss(NodeFNm, ssfWhiteSep);
1006    while (Ss.Next()) {
1007      const int NId = Ss.GetInt(0);
1008      const int Tm = Ss.GetInt(1)+BegOfTm;
1009      if (TSecTm(Tm) < TSecTm(2002, 1, 1)) {
1010        printf("  skip node %g (time %d)\n", (double) Ss.GetLineNo(), Ss.GetInt(1)); continue; }
1011      Net->AddNode(NId, TSecTm(Tm));
1012    } }
1013    printf(" %d nodes\n", Net->GetNodes());
1014    printf("Adding edges...");
1015    int SkipCnt=0;
1016    { TSsParser Ss(EdgeFNm, ssfWhiteSep);
1017    while (Ss.Next()) {
1018      const int NId1 = Ss.GetInt(0);
1019      const int NId2 = Ss.GetInt(1);
1020      const TSecTm Tm = TSecTm(Ss.GetInt(2)+BegOfTm);
1021      if (! Net->IsNode(NId1) || ! Net->IsNode(NId2)) { printf("not node\n"); continue; }
1022      if (Tm < TSecTm(2002, 1, 1)) { SkipCnt++;
1023        printf("  skip edge %g (time %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr()); continue; }
1024      if (Tm+600 < Net->GetNDat(NId1)) {
1025        printf("  1:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId1).GetStr().CStr());
1026        SkipCnt++;  continue; }
1027      if (Tm+600 < Net->GetNDat(NId2)) { SkipCnt++;
1028        printf("  2:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId2).GetStr().CStr());
1029        SkipCnt++;  continue; }
1030      Net->AddEdge(NId1, NId2, -1, TSecTm(Tm));
1031    } }
1032    printf("  %d edges\n", Net->GetEdges());
1033    printf("  %d edges skipped (edge time < node time)\n", SkipCnt);
1034    Net->UpdateNodeTimes();
1035    return Net;
1036  }
1037  PTimeNENet TTimeNENet::LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld, const int& DstFld, const int& TimeFld, const TSsFmt& Separator) {
1038    printf("Loading %s\n", EdgeFNm.CStr());
1039    PTimeNENet Net = TTimeNENet::New();
1040    TStrHash<TInt> StrToId(Mega(1), true); 
1041    int LineCnt=0;
1042    TExeTm ExeTm;
1043    TSsParser Ss(EdgeFNm, Separator);
1044    TSecTm MinTm=TSecTm::GetCurTm(), MaxTm=TSecTm(100);
1045    while (Ss.Next()) {
1046      if (Ss.IsCmt()) { continue; }
1047      IAssert(Ss.Len() > TimeFld);
1048      const char* Node1 = Ss.GetFld(SrcFld);
1049      const char* Node2 = Ss.GetFld(DstFld);
1050      const char* TmStr = Ss.GetFld(TimeFld);
1051      if (strcmp(TmStr,"NULL")==0) { continue; }
1052      const TSecTm Tm(atoi(TmStr));
1053      const int NId1 = StrToId.AddKey(Node1);
1054      const int NId2 = StrToId.AddKey(Node2);
1055      if (! Net->IsNode(NId1)) { Net->AddNode(NId1, TSecTm()); }
1056      if (! Net->IsNode(NId2)) { Net->AddNode(NId2, TSecTm()); }
1057      MinTm=TMath::Mn(MinTm, Tm);
1058      MaxTm=TMath::Mx(MaxTm, Tm);
1059      Net->AddEdge(NId1, NId2, -1, Tm);
1060      if (++LineCnt % 1000 == 0) {
1061        printf("\r  %dk lines processed: %d %d [%s]", LineCnt/1000, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr()); }
1062    }
1063    printf("\r  %d lines processed: %d %d [%s]\n", LineCnt, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr());
1064    printf("  Data range %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1065    Net->UpdateNodeTimes();
1066    return Net;
1067  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-localization.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</div>
                <div class="column column_space"><pre><code>695  				if (titre3 && titre3[0])
696  				{
697  					basic_string<wchar_t> nameW = wmc.char2wchar(titre3, _nativeLangEncoding);
698  					pluginsAdminDlg.changeTabName(INSTALLED_LIST, nameW.c_str());
699  				}
700  				if (titre4 && titre4[0])
701  				{
702  					basic_string<wchar_t> nameW = wmc.char2wchar(titre4, _nativeLangEncoding);
703  					pluginsAdminDlg.changeTabName(INCOMPATIBLE_LIST, nameW.c_str());
704  				}
705  			}
706  			changeDlgLang(pluginsAdminDlg.getHSelf(), "PluginsAdminDlg");
707  		}
</pre></code></div>
                <div class="column column_space"><pre><code>700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    