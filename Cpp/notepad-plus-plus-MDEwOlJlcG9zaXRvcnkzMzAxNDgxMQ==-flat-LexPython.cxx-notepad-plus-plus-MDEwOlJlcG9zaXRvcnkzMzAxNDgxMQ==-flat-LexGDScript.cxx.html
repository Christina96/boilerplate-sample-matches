
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 138, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPython.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <string>
5  #include <string_view>
6  #include <vector>
7  #include <map>
8  #include <algorithm>
9  #include <functional>
10  #include "ILexer.h"
11  #include "Scintilla.h"
12  #include "SciLexer.h"
13  #include "StringCopy.h"
14  #include "WordList.h"
15  #include "LexAccessor.h"
16  #include "Accessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "CharacterCategory.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "SubStyles.h"
23  #include "DefaultLexer.h"
24  using namespace Scintilla;
25  using namespace Lexilla;
26  namespace {
27  struct SingleFStringExpState {
28  	int state;
29  	int nestingCount;
30  };
31  enum kwType { kwOther, kwClass, kwDef, kwImport, kwCDef, kwCTypeName, kwCPDef };
32  enum literalsAllowed { litNone = 0, litU = 1, litB = 2, litF = 4 };
33  constexpr int indicatorWhitespace = 1;
34  bool IsPyComment(Accessor &styler, Sci_Position pos, Sci_Position len) {
35  	return len > 0 && styler[pos] == '#';
36  }
37  constexpr bool IsPyStringTypeChar(int ch, literalsAllowed allowed) noexcept {
38  	return
39  		((allowed & litB) && (ch == 'b' || ch == 'B')) ||
40  		((allowed & litU) && (ch == 'u' || ch == 'U')) ||
41  		((allowed & litF) && (ch == 'f' || ch == 'F'));
42  }
43  bool IsPyStringStart(int ch, int chNext, int chNext2, literalsAllowed allowed) noexcept {
44  	if (ch == '\'' || ch == '"')
45  		return true;
46  	if (IsPyStringTypeChar(ch, allowed)) {
47  		if (chNext == '"' || chNext == '\'')
48  			return true;
49  		if ((chNext == 'r' || chNext == 'R') && (chNext2 == '"' || chNext2 == '\''))
50  			return true;
51  	}
52  	if ((ch == 'r' || ch == 'R') && (chNext == '"' || chNext == '\''))
53  		return true;
54  	return false;
55  }
56  constexpr bool IsPyFStringState(int st) noexcept {
57  	return ((st == SCE_P_FCHARACTER) || (st == SCE_P_FSTRING) ||
58  		(st == SCE_P_FTRIPLE) || (st == SCE_P_FTRIPLEDOUBLE));
59  }
60  constexpr bool IsPySingleQuoteStringState(int st) noexcept {
61  	return ((st == SCE_P_CHARACTER) || (st == SCE_P_STRING) ||
62  		(st == SCE_P_FCHARACTER) || (st == SCE_P_FSTRING));
63  }
64  constexpr bool IsPyTripleQuoteStringState(int st) noexcept {
65  	return ((st == SCE_P_TRIPLE) || (st == SCE_P_TRIPLEDOUBLE) ||
66  		(st == SCE_P_FTRIPLE) || (st == SCE_P_FTRIPLEDOUBLE));
67  }
68  char GetPyStringQuoteChar(int st) noexcept {
69  	if ((st == SCE_P_CHARACTER) || (st == SCE_P_FCHARACTER) ||
70  			(st == SCE_P_TRIPLE) || (st == SCE_P_FTRIPLE))
71  		return '\'';
72  	if ((st == SCE_P_STRING) || (st == SCE_P_FSTRING) ||
73  			(st == SCE_P_TRIPLEDOUBLE) || (st == SCE_P_FTRIPLEDOUBLE))
74  		return '"';
75  	return '\0';
76  }
77  void PushStateToStack(int state, std::vector<SingleFStringExpState> &stack, SingleFStringExpState *&currentFStringExp) {
78  	SingleFStringExpState single = {state, 0};
79  	stack.push_back(single);
80  	currentFStringExp = &stack.back();
81  }
82  int PopFromStateStack(std::vector<SingleFStringExpState> &stack, SingleFStringExpState *&currentFStringExp) noexcept {
83  	int state = 0;
84  	if (!stack.empty()) {
85  		state = stack.back().state;
86  		stack.pop_back();
87  	}
88  	if (stack.empty()) {
89  		currentFStringExp = nullptr;
90  	} else {
91  		currentFStringExp = &stack.back();
92  	}
93  	return state;
94  }
95  int GetPyStringState(Accessor &styler, Sci_Position i, Sci_PositionU *nextIndex, literalsAllowed allowed) {
96  	char ch = styler.SafeGetCharAt(i);
97  	char chNext = styler.SafeGetCharAt(i + 1);
98  	const int firstIsF = (ch == 'f' || ch == 'F');
99  	if (ch == 'r' || ch == 'R') {
100  		i++;
101  		ch = styler.SafeGetCharAt(i);
102  		chNext = styler.SafeGetCharAt(i + 1);
103  	} else if (IsPyStringTypeChar(ch, allowed)) {
104  		if (chNext == 'r' || chNext == 'R')
105  			i += 2;
106  		else
107  			i += 1;
108  		ch = styler.SafeGetCharAt(i);
109  		chNext = styler.SafeGetCharAt(i + 1);
110  	}
111  	if (ch != '"' && ch != '\'') {
112  		*nextIndex = i + 1;
113  		return SCE_P_DEFAULT;
114  	}
115  	if (ch == chNext && ch == styler.SafeGetCharAt(i + 2)) {
116  		*nextIndex = i + 3;
117  		if (ch == '"')
118  			return (firstIsF ? SCE_P_FTRIPLEDOUBLE : SCE_P_TRIPLEDOUBLE);
119  		else
120  			return (firstIsF ? SCE_P_FTRIPLE : SCE_P_TRIPLE);
121  	} else {
122  		*nextIndex = i + 1;
123  		if (ch == '"')
124  			return (firstIsF ? SCE_P_FSTRING : SCE_P_STRING);
125  		else
126  			return (firstIsF ? SCE_P_FCHARACTER : SCE_P_CHARACTER);
127  	}
128  }
129  inline bool IsAWordChar(int ch, bool unicodeIdentifiers) {
130  	if (IsASCII(ch))
131  		return (IsAlphaNumeric(ch) || ch == '.' || ch == '_');
132  	if (!unicodeIdentifiers)
133  		return false;
134  	return IsXidContinue(ch);
135  }
136  inline bool IsAWordStart(int ch, bool unicodeIdentifiers) {
137  	if (IsASCII(ch))
138  		return (IsUpperOrLowerCase(ch) || ch == '_');
139  	if (!unicodeIdentifiers)
140  		return false;
141  	return IsXidStart(ch);
142  }
143  bool IsFirstNonWhitespace(Sci_Position pos, Accessor &styler) {
144  	const Sci_Position line = styler.GetLine(pos);
145  	const Sci_Position start_pos = styler.LineStart(line);
146  	for (Sci_Position i = start_pos; i < pos; i++) {
147  		const char ch = styler[i];
148  		if (!(ch == ' ' || ch == '\t'))
149  			return false;
150  	}
151  	return true;
152  }
153  unsigned char GetNextNonWhitespaceChar(Accessor &styler, Sci_PositionU pos, Sci_PositionU maxPos, Sci_PositionU *charPosPtr = nullptr) {
154  	while (pos < maxPos) {
155  		const unsigned char ch = styler.SafeGetCharAt(pos, '\0');
156  		if (!(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')) {
157  			if (charPosPtr != nullptr) {
158  				*charPosPtr = pos;
159  			}
160  			return ch;
161  		}
162  		pos++;
163  	}
164  	return '\0';
165  }
166  bool IsMatchOrCaseIdentifier(const StyleContext &sc, Accessor &styler, const char *symbol) {
167  	if (strcmp(symbol, "match") != 0 && strcmp(symbol, "case") != 0) {
168  		return false;
169  	}
170  	if (!IsFirstNonWhitespace(sc.currentPos - strlen(symbol), styler)) {
171  		return true;
172  	}
173  	Sci_PositionU nextCharPos = 0;
174  	const unsigned char nextChar = GetNextNonWhitespaceChar(styler, sc.currentPos, sc.lineEnd, &nextCharPos);
175  	if (nextChar == '=' || nextChar == '#') {
176  		return true;
177  	}
178  	if (nextChar == '.' && nextCharPos >= sc.currentPos) {
179  		const unsigned char followingChar = GetNextNonWhitespaceChar(styler, nextCharPos+1, sc.lineEnd);
180  		if (!IsADigit(followingChar)) {
181  			return true;
182  		}
183  	}
184  	return false;
185  }
186  struct OptionsPython {
187  	int whingeLevel;
188  	bool base2or8Literals;
189  	bool stringsU;
190  	bool stringsB;
191  	bool stringsF;
192  	bool stringsOverNewline;
193  	bool keywords2NoSubIdentifiers;
194  	bool fold;
195  	bool foldQuotes;
196  	bool foldCompact;
197  	bool unicodeIdentifiers;
198  	int identifierAttributes;
199  	int decoratorAttributes;
200  	OptionsPython() noexcept {
201  		whingeLevel = 0;
202  		base2or8Literals = true;
203  		stringsU = true;
204  		stringsB = true;
205  		stringsF = true;
206  		stringsOverNewline = false;
207  		keywords2NoSubIdentifiers = false;
208  		fold = false;
209  		foldQuotes = false;
210  		foldCompact = false;
211  		unicodeIdentifiers = true;
212  		identifierAttributes = 0;
213  		decoratorAttributes = 0;
214  	}
215  	literalsAllowed AllowedLiterals() const noexcept {
216  		literalsAllowed allowedLiterals = stringsU ? litU : litNone;
217  		if (stringsB)
218  			allowedLiterals = static_cast<literalsAllowed>(allowedLiterals | litB);
219  		if (stringsF)
220  			allowedLiterals = static_cast<literalsAllowed>(allowedLiterals | litF);
221  		return allowedLiterals;
222  	}
223  };
224  const char *const pythonWordListDesc[] = {
225  	"Keywords",
226  	"Highlighted identifiers",
227  	nullptr
228  };
229  struct OptionSetPython : public OptionSet<OptionsPython> {
230  	OptionSetPython() {
231  		DefineProperty("tab.timmy.whinge.level", &OptionsPython::whingeLevel,
232  			       "For Python code, checks whether indenting is consistent. "
233  			       "The default, 0 turns off indentation checking, "
234  			       "1 checks whether each line is potentially inconsistent with the previous line, "
235  			       "2 checks whether any space characters occur before a tab character in the indentation, "
236  			       "3 checks whether any spaces are in the indentation, and "
237  			       "4 checks for any tab characters in the indentation. "
238  			       "1 is a good level to use.");
239  		DefineProperty("lexer.python.literals.binary", &OptionsPython::base2or8Literals,
240  			       "Set to 0 to not recognise Python 3 binary and octal literals: 0b1011 0o712.");
241  		DefineProperty("lexer.python.strings.u", &OptionsPython::stringsU,
242  			       "Set to 0 to not recognise Python Unicode literals u\"x\" as used before Python 3.");
243  		DefineProperty("lexer.python.strings.b", &OptionsPython::stringsB,
244  			       "Set to 0 to not recognise Python 3 bytes literals b\"x\".");
245  		DefineProperty("lexer.python.strings.f", &OptionsPython::stringsF,
246  			       "Set to 0 to not recognise Python 3.6 f-string literals f\"var={var}\".");
247  		DefineProperty("lexer.python.strings.over.newline", &OptionsPython::stringsOverNewline,
248  			       "Set to 1 to allow strings to span newline characters.");
249  		DefineProperty("lexer.python.keywords2.no.sub.identifiers", &OptionsPython::keywords2NoSubIdentifiers,
250  			       "When enabled, it will not style keywords2 items that are used as a sub-identifier. "
251  			       "Example: when set, will not highlight \"foo.open\" when \"open\" is a keywords2 item.");
252  		DefineProperty("fold", &OptionsPython::fold);
253  		DefineProperty("fold.quotes.python", &OptionsPython::foldQuotes,
254  			       "This option enables folding multi-line quoted strings when using the Python lexer.");
255  		DefineProperty("fold.compact", &OptionsPython::foldCompact);
256  		DefineProperty("lexer.python.unicode.identifiers", &OptionsPython::unicodeIdentifiers,
257  			       "Set to 0 to not recognise Python 3 Unicode identifiers.");
258  		DefineProperty("lexer.python.identifier.attributes", &OptionsPython::identifierAttributes,
259  			       "Set to 1 to recognise Python identifier attributes.");
260  		DefineProperty("lexer.python.decorator.attributes", &OptionsPython::decoratorAttributes,
261  			       "Set to 1 to recognise Python decorator attributes.");
262  		DefineWordListSets(pythonWordListDesc);
263  	}
264  };
265  const char styleSubable[] = { SCE_P_IDENTIFIER, 0 };
266  LexicalClass lexicalClasses[] = {
267  	0, "SCE_P_DEFAULT", "default", "White space",
268  	1, "SCE_P_COMMENTLINE", "comment line", "Comment",
269  	2, "SCE_P_NUMBER", "literal numeric", "Number",
270  	3, "SCE_P_STRING", "literal string", "String",
271  	4, "SCE_P_CHARACTER", "literal string", "Single quoted string",
272  	5, "SCE_P_WORD", "keyword", "Keyword",
273  	6, "SCE_P_TRIPLE", "literal string", "Triple quotes",
274  	7, "SCE_P_TRIPLEDOUBLE", "literal string", "Triple double quotes",
275  	8, "SCE_P_CLASSNAME", "identifier", "Class name definition",
276  	9, "SCE_P_DEFNAME", "identifier", "Function or method name definition",
277  	10, "SCE_P_OPERATOR", "operator", "Operators",
278  	11, "SCE_P_IDENTIFIER", "identifier", "Identifiers",
279  	12, "SCE_P_COMMENTBLOCK", "comment", "Comment-blocks",
280  	13, "SCE_P_STRINGEOL", "error literal string", "End of line where string is not closed",
281  	14, "SCE_P_WORD2", "identifier", "Highlighted identifiers",
282  	15, "SCE_P_DECORATOR", "preprocessor", "Decorators",
283  	16, "SCE_P_FSTRING", "literal string interpolated", "F-String",
284  	17, "SCE_P_FCHARACTER", "literal string interpolated", "Single quoted f-string",
285  	18, "SCE_P_FTRIPLE", "literal string interpolated", "Triple quoted f-string",
286  	19, "SCE_P_FTRIPLEDOUBLE", "literal string interpolated", "Triple double quoted f-string",
287  	20, "SCE_P_ATTRIBUTE", "identifier", "Attribute of identifier",
288  };
289  }
290  class LexerPython : public DefaultLexer {
291  	WordList keywords;
292  	WordList keywords2;
293  	OptionsPython options;
294  	OptionSetPython osPython;
295  	enum { ssIdentifier };
296  	SubStyles subStyles;
297  	std::map<Sci_Position, std::vector<SingleFStringExpState> > ftripleStateAtEol;
298  public:
299  	explicit LexerPython() :
300  		DefaultLexer("python", SCLEX_PYTHON, lexicalClasses, ELEMENTS(lexicalClasses)),
301  		subStyles(styleSubable, 0x80, 0x40, 0) {
302  	}
303  	~LexerPython() override {
304  	}
305  	void SCI_METHOD Release() override {
306  		delete this;
307  	}
308  	int SCI_METHOD Version() const override {
309  		return lvRelease5;
310  	}
311  	const char *SCI_METHOD PropertyNames() override {
312  		return osPython.PropertyNames();
313  	}
314  	int SCI_METHOD PropertyType(const char *name) override {
315  		return osPython.PropertyType(name);
316  	}
317  	const char *SCI_METHOD DescribeProperty(const char *name) override {
318  		return osPython.DescribeProperty(name);
319  	}
320  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
321  	const char * SCI_METHOD PropertyGet(const char *key) override {
322  		return osPython.PropertyGet(key);
323  	}
324  	const char *SCI_METHOD DescribeWordListSets() override {
325  		return osPython.DescribeWordListSets();
326  	}
327  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
328  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
329  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
330  	void *SCI_METHOD PrivateCall(int, void *) override {
331  		return nullptr;
332  	}
333  	int SCI_METHOD LineEndTypesSupported() override {
334  		return SC_LINE_END_TYPE_UNICODE;
335  	}
336  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
337  		return subStyles.Allocate(styleBase, numberStyles);
338  	}
339  	int SCI_METHOD SubStylesStart(int styleBase) override {
340  		return subStyles.Start(styleBase);
341  	}
342  	int SCI_METHOD SubStylesLength(int styleBase) override {
343  		return subStyles.Length(styleBase);
344  	}
345  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
346  		const int styleBase = subStyles.BaseStyle(subStyle);
347  		return styleBase;
348  	}
349  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
350  		return style;
351  	}
352  	void SCI_METHOD FreeSubStyles() override {
353  		subStyles.Free();
354  	}
355  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
356  		subStyles.SetIdentifiers(style, identifiers);
357  	}
358  	int SCI_METHOD DistanceToSecondaryStyles() override {
359  		return 0;
360  	}
361  	const char *SCI_METHOD GetSubStyleBases() override {
362  		return styleSubable;
363  	}
364  	static ILexer5 *LexerFactoryPython() {
365  		return new LexerPython();
366  	}
367  private:
368  	void ProcessLineEnd(StyleContext &sc, std::vector<SingleFStringExpState> &fstringStateStack, SingleFStringExpState *&currentFStringExp, bool &inContinuedString);
369  };
370  Sci_Position SCI_METHOD LexerPython::PropertySet(const char *key, const char *val) {
371  	if (osPython.PropertySet(&options, key, val)) {
372  		return 0;
373  	}
374  	return -1;
375  }
376  Sci_Position SCI_METHOD LexerPython::WordListSet(int n, const char *wl) {
377  	WordList *wordListN = nullptr;
378  	switch (n) {
379  	case 0:
380  		wordListN = &keywords;
381  		break;
382  	case 1:
383  		wordListN = &keywords2;
384  		break;
385  	default:
386  		break;
387  	}
388  	Sci_Position firstModification = -1;
389  	if (wordListN) {
390  		if (wordListN->Set(wl)) {
391  			firstModification = 0;
392  		}
393  	}
394  	return firstModification;
395  }
396  void LexerPython::ProcessLineEnd(StyleContext &sc, std::vector<SingleFStringExpState> &fstringStateStack, SingleFStringExpState *&currentFStringExp, bool &inContinuedString) {
397  	long deepestSingleStateIndex = -1;
398  	unsigned long i;
399  	for (i = 0; i < fstringStateStack.size(); i++) {
400  		if (IsPySingleQuoteStringState(fstringStateStack[i].state)) {
401  			deepestSingleStateIndex = i;
402  			break;
403  		}
404  	}
405  	if (deepestSingleStateIndex != -1) {
406  		sc.SetState(fstringStateStack[deepestSingleStateIndex].state);
407  		while (fstringStateStack.size() > static_cast<unsigned long>(deepestSingleStateIndex)) {
408  			PopFromStateStack(fstringStateStack, currentFStringExp);
409  		}
410  	}
411  	if (!fstringStateStack.empty()) {
412  		std::pair<Sci_Position, std::vector<SingleFStringExpState> > val;
413  		val.first = sc.currentLine;
414  		val.second = fstringStateStack;
415  		ftripleStateAtEol.insert(val);
416  	}
417  	if ((sc.state == SCE_P_DEFAULT)
418  			|| IsPyTripleQuoteStringState(sc.state)) {
419  		sc.SetState(sc.state);
420  	}
421  	if (IsPySingleQuoteStringState(sc.state)) {
422  		if (inContinuedString || options.stringsOverNewline) {
423  			inContinuedString = false;
424  		} else {
425  			sc.ChangeState(SCE_P_STRINGEOL);
426  			sc.ForwardSetState(SCE_P_DEFAULT);
427  		}
428  	}
429  }
430  void SCI_METHOD LexerPython::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
431  	Accessor styler(pAccess, nullptr);
432  	std::vector<SingleFStringExpState> fstringStateStack;
433  	SingleFStringExpState *currentFStringExp = nullptr;
434  	const Sci_Position endPos = startPos + length;
435  	Sci_Position lineCurrent = styler.GetLine(startPos);
436  	if (startPos > 0) {
437  		if (lineCurrent > 0) {
438  			lineCurrent--;
439  			while (lineCurrent > 0) {
440  				const Sci_Position eolPos = styler.LineStart(lineCurrent) - 1;
441  				const int eolStyle = styler.StyleAt(eolPos);
442  				if (eolStyle == SCE_P_STRING
443  						|| eolStyle == SCE_P_CHARACTER
444  						|| eolStyle == SCE_P_STRINGEOL) {
445  					lineCurrent -= 1;
446  				} else {
447  					break;
448  				}
449  			}
450  			startPos = styler.LineStart(lineCurrent);
451  		}
452  		initStyle = startPos == 0 ? SCE_P_DEFAULT : styler.StyleAt(startPos - 1);
453  	}
454  	const literalsAllowed allowedLiterals = options.AllowedLiterals();
455  	initStyle = initStyle & 31;
456  	if (initStyle == SCE_P_STRINGEOL) {
457  		initStyle = SCE_P_DEFAULT;
458  	}
459  	std::map<Sci_Position, std::vector<SingleFStringExpState> >::iterator it;
460  	it = ftripleStateAtEol.find(lineCurrent - 1);
461  	if (it != ftripleStateAtEol.end() && !it->second.empty()) {
462  		fstringStateStack = it->second;
463  		currentFStringExp = &fstringStateStack.back();
464  	}
465  	it = ftripleStateAtEol.lower_bound(lineCurrent);
466  	if (it != ftripleStateAtEol.end()) {
467  		ftripleStateAtEol.erase(it, ftripleStateAtEol.end());
468  	}
469  	kwType kwLast = kwOther;
470  	int spaceFlags = 0;
471  	styler.IndentAmount(lineCurrent, &spaceFlags, IsPyComment);
472  	bool base_n_number = false;
473  	const WordClassifier &classifierIdentifiers = subStyles.Classifier(SCE_P_IDENTIFIER);
474  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
475  	bool indentGood = true;
476  	Sci_Position startIndicator = sc.currentPos;
477  	bool inContinuedString = false;
478  	for (; sc.More(); sc.Forward()) {
479  		if (sc.atLineStart) {
480  			styler.IndentAmount(lineCurrent, &spaceFlags, IsPyComment);
481  			indentGood = true;
482  			if (options.whingeLevel == 1) {
483  				indentGood = (spaceFlags & wsInconsistent) == 0;
484  			} else if (options.whingeLevel == 2) {
485  				indentGood = (spaceFlags & wsSpaceTab) == 0;
486  			} else if (options.whingeLevel == 3) {
487  				indentGood = (spaceFlags & wsSpace) == 0;
488  			} else if (options.whingeLevel == 4) {
489  				indentGood = (spaceFlags & wsTab) == 0;
490  			}
491  			if (!indentGood) {
492  				styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 0);
493  				startIndicator = sc.currentPos;
494  			}
495  		}
496  		if (sc.atLineEnd) {
497  			ProcessLineEnd(sc, fstringStateStack, currentFStringExp, inContinuedString);
498  			lineCurrent++;
499  			if (!sc.More())
500  				break;
501  		}
502  		bool needEOLCheck = false;
503  		if (sc.state == SCE_P_OPERATOR) {
<span onclick='openModal()' class='match'>504  			kwLast = kwOther;
505  			sc.SetState(SCE_P_DEFAULT);
506  		} else if (sc.state == SCE_P_NUMBER) {
507  			if (!IsAWordChar(sc.ch, false) &&
508  					!(!base_n_number && ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E')))) {
509  				sc.SetState(SCE_P_DEFAULT);
510  			}
511  		} else if (sc.state == SCE_P_IDENTIFIER) {
512  			if ((sc.ch == '.') || (!IsAWordChar(sc.ch, options.unicodeIdentifiers))) {
513  				char s[100];
514  				sc.GetCurrent(s, sizeof(s));
515  				int style = SCE_P_IDENTIFIER;
516  				if ((kwLast == kwImport) && (strcmp(s, "as") == 0)) {
</span>517  					style = SCE_P_WORD;
518  				} else if (keywords.InList(s) && !IsMatchOrCaseIdentifier(sc, styler, s)) {
519  					style = SCE_P_WORD;
520  				} else if (kwLast == kwClass) {
521  					style = SCE_P_CLASSNAME;
522  				} else if (kwLast == kwDef) {
523  					style = SCE_P_DEFNAME;
524  				} else if (kwLast == kwCDef || kwLast == kwCPDef) {
525  					Sci_Position pos = sc.currentPos;
526  					unsigned char ch = styler.SafeGetCharAt(pos, '\0');
527  					while (ch != '\0') {
528  						if (ch == '(') {
529  							style = SCE_P_DEFNAME;
530  							break;
531  						} else if (ch == ':') {
532  							style = SCE_P_CLASSNAME;
533  							break;
534  						} else if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
535  							pos++;
536  							ch = styler.SafeGetCharAt(pos, '\0');
537  						} else {
538  							break;
539  						}
540  					}
541  				} else if (keywords2.InList(s)) {
542  					if (options.keywords2NoSubIdentifiers) {
543  						const Sci_Position pos = styler.GetStartSegment() - 1;
544  						if (pos < 0 || (styler.SafeGetCharAt(pos, '\0') != '.'))
545  							style = SCE_P_WORD2;
546  					} else {
547  						style = SCE_P_WORD2;
548  					}
549  				} else {
550  					const int subStyle = classifierIdentifiers.ValueFor(s);
551  					if (subStyle >= 0) {
552  						style = subStyle;
553  					}
554  					if (options.identifierAttributes > 0 || options.decoratorAttributes > 0) {
555  						Sci_Position pos = styler.GetStartSegment() - 1;
556  						unsigned char ch = styler.SafeGetCharAt(pos, '\0');
557  						while (ch != '\0' && (ch == '.' || ch == ' ' || ch == '\\' || ch == '\t' || ch == '\n' || ch == '\r')) {
558  							if (IsAWordChar(ch, options.unicodeIdentifiers)) {
559  								break;
560  							}
561  							pos--;
562  							ch = styler.SafeGetCharAt(pos, '\0');
563  						}
564  						if (pos < 0 || ch == '.') {
565  							bool isComment = false;
566  							bool isDecoratorAttribute = false;
567  							const Sci_Position attrLine = styler.GetLine(pos);
568  							for (Sci_Position i = styler.LineStart(attrLine); i < pos; i++) {
569  								const char attrCh = styler[i];
570  								if (attrCh == '@')
571  									isDecoratorAttribute = true;
572  								if (attrCh == '#')
573  									isComment = true;
574  								if (!(ch == ' ' || ch == '\t'))
575  									break;
576  							}
577  							if (((isDecoratorAttribute) && (!isComment)) && (((options.decoratorAttributes == 1)  && (style == SCE_P_IDENTIFIER)) || (options.decoratorAttributes == 2))){
578  								style = SCE_P_DECORATOR;
579  							}
580  							if (((!isDecoratorAttribute) && (!isComment)) && (((options.identifierAttributes == 1) && (style == SCE_P_IDENTIFIER)) || (options.identifierAttributes == 2))){
581  								style = SCE_P_ATTRIBUTE;
582  							}
583  						}
584  					}
585  				}
586  				sc.ChangeState(style);
587  				sc.SetState(SCE_P_DEFAULT);
588  				if (style == SCE_P_WORD) {
589  					if (0 == strcmp(s, "class"))
590  						kwLast = kwClass;
591  					else if (0 == strcmp(s, "def"))
592  						kwLast = kwDef;
593  					else if (0 == strcmp(s, "import"))
594  						kwLast = kwImport;
595  					else if (0 == strcmp(s, "cdef"))
596  						kwLast = kwCDef;
597  					else if (0 == strcmp(s, "cpdef"))
598  						kwLast = kwCPDef;
599  					else if (0 == strcmp(s, "cimport"))
600  						kwLast = kwImport;
601  					else if (kwLast != kwCDef && kwLast != kwCPDef)
602  						kwLast = kwOther;
603  				} else if (kwLast != kwCDef && kwLast != kwCPDef) {
604  					kwLast = kwOther;
605  				}
606  			}
607  		} else if ((sc.state == SCE_P_COMMENTLINE) || (sc.state == SCE_P_COMMENTBLOCK)) {
608  			if (sc.ch == '\r' || sc.ch == '\n') {
609  				sc.SetState(SCE_P_DEFAULT);
610  			}
611  		} else if (sc.state == SCE_P_DECORATOR) {
612  			if (!IsAWordStart(sc.ch, options.unicodeIdentifiers)) {
613  				sc.SetState(SCE_P_DEFAULT);
614  			}
615  		} else if (IsPySingleQuoteStringState(sc.state)) {
616  			if (sc.ch == '\\') {
617  				if ((sc.chNext == '\r') && (sc.GetRelative(2) == '\n')) {
618  					sc.Forward();
619  				}
620  				if (sc.chNext == '\n' || sc.chNext == '\r') {
621  					inContinuedString = true;
622  				} else {
623  					sc.Forward();
624  				}
625  			} else if (sc.ch == GetPyStringQuoteChar(sc.state)) {
626  				sc.ForwardSetState(SCE_P_DEFAULT);
627  				needEOLCheck = true;
628  			}
629  		} else if ((sc.state == SCE_P_TRIPLE) || (sc.state == SCE_P_FTRIPLE)) {
630  			if (sc.ch == '\\') {
631  				sc.Forward();
632  			} else if (sc.Match(R"(''')")) {
633  				sc.Forward();
634  				sc.Forward();
635  				sc.ForwardSetState(SCE_P_DEFAULT);
636  				needEOLCheck = true;
637  			}
638  		} else if ((sc.state == SCE_P_TRIPLEDOUBLE) || (sc.state == SCE_P_FTRIPLEDOUBLE)) {
639  			if (sc.ch == '\\') {
640  				sc.Forward();
641  			} else if (sc.Match(R"(""")")) {
642  				sc.Forward();
643  				sc.Forward();
644  				sc.ForwardSetState(SCE_P_DEFAULT);
645  				needEOLCheck = true;
646  			}
647  		}
648  		if (IsPyFStringState(sc.state) && sc.ch == '{') {
649  			if (sc.chNext == '{') {
650  				sc.Forward();
651  			} else {
652  				PushStateToStack(sc.state, fstringStateStack, currentFStringExp);
653  				sc.ForwardSetState(SCE_P_DEFAULT);
654  			}
655  			needEOLCheck = true;
656  		}
657  		if (!fstringStateStack.empty() && (sc.ch == '\'' || sc.ch == '"')) {
658  			long matching_stack_i = -1;
659  			for (unsigned long stack_i = 0; stack_i < fstringStateStack.size() && matching_stack_i == -1; stack_i++) {
660  				const int stack_state = fstringStateStack[stack_i].state;
661  				const char quote = GetPyStringQuoteChar(stack_state);
662  				if (sc.ch == quote) {
663  					if (IsPySingleQuoteStringState(stack_state)) {
664  						matching_stack_i = stack_i;
665  					} else if (quote == '"' ? sc.Match(R"(""")") : sc.Match("'''")) {
666  						matching_stack_i = stack_i;
667  					}
668  				}
669  			}
670  			if (matching_stack_i != -1) {
671  				sc.SetState(fstringStateStack[matching_stack_i].state);
672  				if (IsPyTripleQuoteStringState(fstringStateStack[matching_stack_i].state)) {
673  					sc.Forward();
674  					sc.Forward();
675  				}
676  				sc.ForwardSetState(SCE_P_DEFAULT);
677  				needEOLCheck = true;
678  				while (fstringStateStack.size() > static_cast<unsigned long>(matching_stack_i)) {
679  					PopFromStateStack(fstringStateStack, currentFStringExp);
680  				}
681  			}
682  		}
683  		if (!indentGood && !IsASpaceOrTab(sc.ch)) {
684  			styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 1);
685  			startIndicator = sc.currentPos;
686  			indentGood = true;
687  		}
688  		if ((kwLast == kwCDef || kwLast == kwCPDef) && sc.atLineEnd) {
689  			kwLast = kwOther;
690  		}
691  		if (needEOLCheck && sc.atLineEnd) {
692  			ProcessLineEnd(sc, fstringStateStack, currentFStringExp, inContinuedString);
693  			lineCurrent++;
694  			styler.IndentAmount(lineCurrent, &spaceFlags, IsPyComment);
695  			if (!sc.More())
696  				break;
697  		}
698  		if (currentFStringExp && !IsPySingleQuoteStringState(sc.state) && !IsPyTripleQuoteStringState(sc.state)) {
699  			if (currentFStringExp->nestingCount == 0 && (sc.ch == '}' || sc.ch == ':' || (sc.ch == '!' && sc.chNext != '='))) {
700  				sc.SetState(PopFromStateStack(fstringStateStack, currentFStringExp));
701  			} else {
702  				if (sc.ch == '{' || sc.ch == '[' || sc.ch == '(') {
703  					currentFStringExp->nestingCount++;
704  				} else if (sc.ch == '}' || sc.ch == ']' || sc.ch == ')') {
705  					currentFStringExp->nestingCount--;
706  				}
707  			}
708  		}
709  		if (sc.state == SCE_P_DEFAULT) {
710  			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
711  				if (sc.ch == '0' && (sc.chNext == 'x' || sc.chNext == 'X')) {
712  					base_n_number = true;
713  					sc.SetState(SCE_P_NUMBER);
714  				} else if (sc.ch == '0' &&
715  						(sc.chNext == 'o' || sc.chNext == 'O' || sc.chNext == 'b' || sc.chNext == 'B')) {
716  					if (options.base2or8Literals) {
717  						base_n_number = true;
718  						sc.SetState(SCE_P_NUMBER);
719  					} else {
720  						sc.SetState(SCE_P_NUMBER);
721  						sc.ForwardSetState(SCE_P_IDENTIFIER);
722  					}
723  				} else {
724  					base_n_number = false;
725  					sc.SetState(SCE_P_NUMBER);
726  				}
727  			} else if (isoperator(sc.ch) || sc.ch == '`') {
728  				sc.SetState(SCE_P_OPERATOR);
729  			} else if (sc.ch == '#') {
730  				sc.SetState(sc.chNext == '#' ? SCE_P_COMMENTBLOCK : SCE_P_COMMENTLINE);
731  			} else if (sc.ch == '@') {
732  				if (IsFirstNonWhitespace(sc.currentPos, styler))
733  					sc.SetState(SCE_P_DECORATOR);
734  				else
735  					sc.SetState(SCE_P_OPERATOR);
736  			} else if (IsPyStringStart(sc.ch, sc.chNext, sc.GetRelative(2), allowedLiterals)) {
737  				Sci_PositionU nextIndex = 0;
738  				sc.SetState(GetPyStringState(styler, sc.currentPos, &nextIndex, allowedLiterals));
739  				while (nextIndex > (sc.currentPos + 1) && sc.More()) {
740  					sc.Forward();
741  				}
742  			} else if (IsAWordStart(sc.ch, options.unicodeIdentifiers)) {
743  				sc.SetState(SCE_P_IDENTIFIER);
744  			}
745  		}
746  	}
747  	styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 0);
748  	sc.Complete();
749  }
750  static bool IsCommentLine(Sci_Position line, Accessor &styler) {
751  	const Sci_Position pos = styler.LineStart(line);
752  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
753  	for (Sci_Position i = pos; i < eol_pos; i++) {
754  		const char ch = styler[i];
755  		if (ch == '#')
756  			return true;
757  		else if (ch != ' ' && ch != '\t')
758  			return false;
759  	}
760  	return false;
761  }
762  static bool IsQuoteLine(Sci_Position line, const Accessor &styler) {
763  	const int style = styler.StyleAt(styler.LineStart(line)) & 31;
764  	return IsPyTripleQuoteStringState(style);
765  }
766  void SCI_METHOD LexerPython::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;*initStyle - unused*/, IDocument *pAccess) {
767  	if (!options.fold)
768  		return;
769  	Accessor styler(pAccess, nullptr);
770  	const Sci_Position maxPos = startPos + length;
771  	const Sci_Position maxLines = (maxPos == styler.Length()) ? styler.GetLine(maxPos) : styler.GetLine(maxPos - 1);	
772  	const Sci_Position docLines = styler.GetLine(styler.Length());	
773  	int spaceFlags = 0;
774  	Sci_Position lineCurrent = styler.GetLine(startPos);
775  	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, nullptr);
776  	while (lineCurrent > 0) {
777  		lineCurrent--;
778  		indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, nullptr);
779  		if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG) &&
780  				(!IsCommentLine(lineCurrent, styler)) &&
781  				(!IsQuoteLine(lineCurrent, styler)))
782  			break;
783  	}
784  	int indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
785  	startPos = styler.LineStart(lineCurrent);
786  	int prev_state = SCE_P_DEFAULT & 31;
787  	if (lineCurrent >= 1)
788  		prev_state = styler.StyleAt(startPos - 1) & 31;
789  	int prevQuote = options.foldQuotes && IsPyTripleQuoteStringState(prev_state);
790  	while ((lineCurrent <= docLines) && ((lineCurrent <= maxLines) || prevQuote)) {
791  		int lev = indentCurrent;
792  		Sci_Position lineNext = lineCurrent + 1;
793  		int indentNext = indentCurrent;
794  		int quote = false;
795  		if (lineNext <= docLines) {
796  			indentNext = styler.IndentAmount(lineNext, &spaceFlags, nullptr);
797  			const Sci_Position lookAtPos = (styler.LineStart(lineNext) == styler.Length()) ? styler.Length() - 1 : styler.LineStart(lineNext);
798  			const int style = styler.StyleAt(lookAtPos) & 31;
799  			quote = options.foldQuotes && IsPyTripleQuoteStringState(style);
800  		}
801  		const bool quote_start = (quote && !prevQuote);
802  		const bool quote_continue = (quote && prevQuote);
803  		if (!quote || !prevQuote)
804  			indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
805  		if (quote)
806  			indentNext = indentCurrentLevel;
807  		if (indentNext & SC_FOLDLEVELWHITEFLAG)
808  			indentNext = SC_FOLDLEVELWHITEFLAG | indentCurrentLevel;
809  		if (quote_start) {
810  			lev |= SC_FOLDLEVELHEADERFLAG;
811  		} else if (quote_continue || prevQuote) {
812  			lev = lev + 1;
813  		}
814  		int minCommentLevel = indentCurrentLevel;
815  		while (!quote &&
816  				(lineNext < docLines) &&
817  				((indentNext & SC_FOLDLEVELWHITEFLAG) || (IsCommentLine(lineNext, styler)))) {
818  			if (IsCommentLine(lineNext, styler) && indentNext < minCommentLevel) {
819  				minCommentLevel = indentNext;
820  			}
821  			lineNext++;
822  			indentNext = styler.IndentAmount(lineNext, &spaceFlags, nullptr);
823  		}
824  		const int levelAfterComments = ((lineNext < docLines) ? indentNext & SC_FOLDLEVELNUMBERMASK : minCommentLevel);
825  		const int levelBeforeComments = std::max(indentCurrentLevel, levelAfterComments);
826  		Sci_Position skipLine = lineNext;
827  		int skipLevel = levelAfterComments;
828  		while (--skipLine > lineCurrent) {
829  			const int skipLineIndent = styler.IndentAmount(skipLine, &spaceFlags, nullptr);
830  			if (options.foldCompact) {
831  				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments)
832  					skipLevel = levelBeforeComments;
833  				const int whiteFlag = skipLineIndent & SC_FOLDLEVELWHITEFLAG;
834  				styler.SetLevel(skipLine, skipLevel | whiteFlag);
835  			} else {
836  				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments &&
837  						!(skipLineIndent & SC_FOLDLEVELWHITEFLAG) &&
838  						!IsCommentLine(skipLine, styler))
839  					skipLevel = levelBeforeComments;
840  				styler.SetLevel(skipLine, skipLevel);
841  			}
842  		}
843  		if (!quote && !(indentCurrent & SC_FOLDLEVELWHITEFLAG)) {
844  			if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK))
845  				lev |= SC_FOLDLEVELHEADERFLAG;
846  		}
847  		prevQuote = quote;
848  		styler.SetLevel(lineCurrent, options.foldCompact ? lev : lev & ~SC_FOLDLEVELWHITEFLAG);
849  		indentCurrent = indentNext;
850  		lineCurrent = lineNext;
851  	}
852  }
853  LexerModule lmPython(SCLEX_PYTHON, LexerPython::LexerFactoryPython, "python",
854  		     pythonWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexGDScript.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <string>
5  #include <string_view>
6  #include <vector>
7  #include <map>
8  #include <algorithm>
9  #include <functional>
10  #include "ILexer.h"
11  #include "Scintilla.h"
12  #include "SciLexer.h"
13  #include "StringCopy.h"
14  #include "WordList.h"
15  #include "LexAccessor.h"
16  #include "Accessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "CharacterCategory.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "SubStyles.h"
23  #include "DefaultLexer.h"
24  using namespace Scintilla;
25  using namespace Lexilla;
26  namespace {
27  enum kwType { kwOther, kwClass, kwDef, kwExtends};
28  constexpr int indicatorWhitespace = 1;
29  bool IsGDStringStart(int ch) {
30      return (ch == '\'' || ch == '"');
31  }
32  bool IsGDComment(Accessor &styler, Sci_Position pos, Sci_Position len) {
33  	return len > 0 && styler[pos] == '#';
34  }
35  constexpr bool IsGDSingleQuoteStringState(int st) noexcept {
36  	return ((st == SCE_GD_CHARACTER) || (st == SCE_GD_STRING));
37  }
38  constexpr bool IsGDTripleQuoteStringState(int st) noexcept {
39  	return ((st == SCE_GD_TRIPLE) || (st == SCE_GD_TRIPLEDOUBLE));
40  }
41  char GetGDStringQuoteChar(int st) noexcept {
42  	if ((st == SCE_GD_CHARACTER) || (st == SCE_GD_TRIPLE))
43  		return '\'';
44  	if ((st == SCE_GD_STRING) || (st == SCE_GD_TRIPLEDOUBLE))
45  		return '"';
46  	return '\0';
47  }
48  int GetGDStringState(Accessor &styler, Sci_Position i, Sci_PositionU *nextIndex) {
49  	char ch = styler.SafeGetCharAt(i);
50  	char chNext = styler.SafeGetCharAt(i + 1);
51  	if (ch != '"' && ch != '\'') {
52  		*nextIndex = i + 1;
53  		return SCE_GD_DEFAULT;
54  	}
55  	if (ch == chNext && ch == styler.SafeGetCharAt(i + 2)) {
56  		*nextIndex = i + 3;
57  		if (ch == '"')
58  			return SCE_GD_TRIPLEDOUBLE;
59  		else
60  			return SCE_GD_TRIPLE;
61  	} else {
62  		*nextIndex = i + 1;
63  		if (ch == '"')
64  			return SCE_GD_STRING;
65  		else
66  			return SCE_GD_CHARACTER;
67  	}
68  }
69  int GetGDStringState(int ch) {
70  	if (ch != '"' && ch != '\'')
71  		return SCE_GD_DEFAULT;
72  	if (ch == '"')
73  		return SCE_GD_STRING;
74  	else
75  		return SCE_GD_CHARACTER;
76  }
77  inline bool IsAWordChar(int ch, bool unicodeIdentifiers) {
78  	if (IsASCII(ch))
79  		return (IsAlphaNumeric(ch) || ch == '.' || ch == '_');
80  	if (!unicodeIdentifiers)
81  		return false;
82  	return IsXidContinue(ch);
83  }
84  inline bool IsANodePathChar(int ch, bool unicodeIdentifiers) {
85  	if (IsASCII(ch))
86  		return (IsAlphaNumeric(ch) || ch == '_' || ch == '/' || ch =='%');
87  	if (!unicodeIdentifiers)
88  		return false;
89  	return IsXidContinue(ch);
90  }
91  inline bool IsAWordStart(int ch, bool unicodeIdentifiers) {
92  	if (IsASCII(ch))
93  		return (IsUpperOrLowerCase(ch) || ch == '_');
94  	if (!unicodeIdentifiers)
95  		return false;
96  	return IsXidStart(ch);
97  }
98  bool IsFirstNonWhitespace(Sci_Position pos, Accessor &styler) {
99  	const Sci_Position line = styler.GetLine(pos);
100  	const Sci_Position start_pos = styler.LineStart(line);
101  	for (Sci_Position i = start_pos; i < pos; i++) {
102  		const char ch = styler[i];
103  		if (!(ch == ' ' || ch == '\t'))
104  			return false;
105  	}
106  	return true;
107  }
108  struct OptionsGDScript {
109  	int whingeLevel;
110  	bool base2or8Literals;
111  	bool stringsOverNewline;
112  	bool keywords2NoSubIdentifiers;
113  	bool fold;
114  	bool foldQuotes;
115  	bool foldCompact;
116  	bool unicodeIdentifiers;
117  	OptionsGDScript() noexcept {
118  		whingeLevel = 0;
119  		base2or8Literals = true;
120  		stringsOverNewline = false;
121  		keywords2NoSubIdentifiers = false;
122  		fold = false;
123  		foldQuotes = false;
124  		foldCompact = false;
125  		unicodeIdentifiers = true;
126  	}
127  };
128  const char *const gdscriptWordListDesc[] = {
129  	"Keywords",
130  	"Highlighted identifiers",
131  	nullptr
132  };
133  struct OptionSetGDScript : public OptionSet<OptionsGDScript> {
134  	OptionSetGDScript() {
135  		DefineProperty("lexer.gdscript.whinge.level", &OptionsGDScript::whingeLevel,
136  			       "For GDScript code, checks whether indenting is consistent. "
137  			       "The default, 0 turns off indentation checking, "
138  			       "1 checks whether each line is potentially inconsistent with the previous line, "
139  			       "2 checks whether any space characters occur before a tab character in the indentation, "
140  			       "3 checks whether any spaces are in the indentation, and "
141  			       "4 checks for any tab characters in the indentation. "
142  			       "1 is a good level to use.");
143  		DefineProperty("lexer.gdscript.literals.binary", &OptionsGDScript::base2or8Literals,
144  			       "Set to 0 to not recognise binary and octal literals: 0b1011 0o712.");
145  		DefineProperty("lexer.gdscript.strings.over.newline", &OptionsGDScript::stringsOverNewline,
146  			       "Set to 1 to allow strings to span newline characters.");
147  		DefineProperty("lexer.gdscript.keywords2.no.sub.identifiers", &OptionsGDScript::keywords2NoSubIdentifiers,
148  			       "When enabled, it will not style keywords2 items that are used as a sub-identifier. "
149  			       "Example: when set, will not highlight \"foo.open\" when \"open\" is a keywords2 item.");
150  		DefineProperty("fold", &OptionsGDScript::fold);
151  		DefineProperty("fold.gdscript.quotes", &OptionsGDScript::foldQuotes,
152  			       "This option enables folding multi-line quoted strings when using the GDScript lexer.");
153  		DefineProperty("fold.compact", &OptionsGDScript::foldCompact);
154  		DefineProperty("lexer.gdscript.unicode.identifiers", &OptionsGDScript::unicodeIdentifiers,
155  			       "Set to 0 to not recognise Unicode identifiers.");
156  		DefineWordListSets(gdscriptWordListDesc);
157  	}
158  };
159  const char styleSubable[] = { SCE_GD_IDENTIFIER, 0 };
160  LexicalClass lexicalClasses[] = {
161  	0, "SCE_GD_DEFAULT", "default", "White space",
162  	1, "SCE_GD_COMMENTLINE", "comment line", "Comment",
163  	2, "SCE_GD_NUMBER", "literal numeric", "Number",
164  	3, "SCE_GD_STRING", "literal string", "String",
165  	4, "SCE_GD_CHARACTER", "literal string", "Single quoted string",
166  	5, "SCE_GD_WORD", "keyword", "Keyword",
167  	6, "SCE_GD_TRIPLE", "literal string", "Triple quotes",
168  	7, "SCE_GD_TRIPLEDOUBLE", "literal string", "Triple double quotes",
169  	8, "SCE_GD_CLASSNAME", "identifier", "Class name definition",
170  	9, "SCE_GD_FUNCNAME", "identifier", "Function or method name definition",
171  	10, "SCE_GD_OPERATOR", "operator", "Operators",
172  	11, "SCE_GD_IDENTIFIER", "identifier", "Identifiers",
173  	12, "SCE_GD_COMMENTBLOCK", "comment", "Comment-blocks",
174  	13, "SCE_GD_STRINGEOL", "error literal string", "End of line where string is not closed",
175  	14, "SCE_GD_WORD2", "identifier", "Highlighted identifiers",
176  	15, "SCE_GD_ANNOTATION", "annotation", "Annotations",
177  	16, "SCE_GD_NODEPATH", "path", "Node path",
178  };
179  }
180  class LexerGDScript : public DefaultLexer {
181  	WordList keywords;
182  	WordList keywords2;
183  	OptionsGDScript options;
184  	OptionSetGDScript osGDScript;
185  	enum { ssIdentifier };
186  	SubStyles subStyles;
187  public:
188  	explicit LexerGDScript() :
189  		DefaultLexer("gdscript", SCLEX_GDSCRIPT, lexicalClasses, ELEMENTS(lexicalClasses)),
190  		subStyles(styleSubable, 0x80, 0x40, 0) {
191  	}
192  	~LexerGDScript() override {
193  	}
194  	void SCI_METHOD Release() override {
195  		delete this;
196  	}
197  	int SCI_METHOD Version() const override {
198  		return lvRelease5;
199  	}
200  	const char *SCI_METHOD PropertyNames() override {
201  		return osGDScript.PropertyNames();
202  	}
203  	int SCI_METHOD PropertyType(const char *name) override {
204  		return osGDScript.PropertyType(name);
205  	}
206  	const char *SCI_METHOD DescribeProperty(const char *name) override {
207  		return osGDScript.DescribeProperty(name);
208  	}
209  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
210  	const char * SCI_METHOD PropertyGet(const char *key) override {
211  		return osGDScript.PropertyGet(key);
212  	}
213  	const char *SCI_METHOD DescribeWordListSets() override {
214  		return osGDScript.DescribeWordListSets();
215  	}
216  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
217  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
218  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
219  	void *SCI_METHOD PrivateCall(int, void *) override {
220  		return nullptr;
221  	}
222  	int SCI_METHOD LineEndTypesSupported() override {
223  		return SC_LINE_END_TYPE_UNICODE;
224  	}
225  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
226  		return subStyles.Allocate(styleBase, numberStyles);
227  	}
228  	int SCI_METHOD SubStylesStart(int styleBase) override {
229  		return subStyles.Start(styleBase);
230  	}
231  	int SCI_METHOD SubStylesLength(int styleBase) override {
232  		return subStyles.Length(styleBase);
233  	}
234  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
235  		const int styleBase = subStyles.BaseStyle(subStyle);
236  		return styleBase;
237  	}
238  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
239  		return style;
240  	}
241  	void SCI_METHOD FreeSubStyles() override {
242  		subStyles.Free();
243  	}
244  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
245  		subStyles.SetIdentifiers(style, identifiers);
246  	}
247  	int SCI_METHOD DistanceToSecondaryStyles() override {
248  		return 0;
249  	}
250  	const char *SCI_METHOD GetSubStyleBases() override {
251  		return styleSubable;
252  	}
253  	static ILexer5 *LexerFactoryGDScript() {
254  		return new LexerGDScript();
255  	}
256  private:
257  	void ProcessLineEnd(StyleContext &sc, bool &inContinuedString);
258  };
259  Sci_Position SCI_METHOD LexerGDScript::PropertySet(const char *key, const char *val) {
260  	if (osGDScript.PropertySet(&options, key, val)) {
261  		return 0;
262  	}
263  	return -1;
264  }
265  Sci_Position SCI_METHOD LexerGDScript::WordListSet(int n, const char *wl) {
266  	WordList *wordListN = nullptr;
267  	switch (n) {
268  	case 0:
269  		wordListN = &keywords;
270  		break;
271  	case 1:
272  		wordListN = &keywords2;
273  		break;
274  	default:
275  		break;
276  	}
277  	Sci_Position firstModification = -1;
278  	if (wordListN) {
279  		WordList wlNew;
280  		wlNew.Set(wl);
281  		if (*wordListN != wlNew) {
282  			wordListN->Set(wl);
283  			firstModification = 0;
284  		}
285  	}
286  	return firstModification;
287  }
288  void LexerGDScript::ProcessLineEnd(StyleContext &sc, bool &inContinuedString) {
289  	if ((sc.state == SCE_GD_DEFAULT)
290  			|| IsGDTripleQuoteStringState(sc.state)) {
291  		sc.SetState(sc.state);
292  	}
293  	if (IsGDSingleQuoteStringState(sc.state)) {
294  		if (inContinuedString || options.stringsOverNewline) {
295  			inContinuedString = false;
296  		} else {
297  			sc.ChangeState(SCE_GD_STRINGEOL);
298  			sc.ForwardSetState(SCE_GD_DEFAULT);
299  		}
300  	}
301  }
302  void SCI_METHOD LexerGDScript::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
303  	Accessor styler(pAccess, nullptr);
304  	const Sci_Position endPos = startPos + length;
305  	Sci_Position lineCurrent = styler.GetLine(startPos);
306  	if (startPos > 0) {
307  		if (lineCurrent > 0) {
308  			lineCurrent--;
309  			while (lineCurrent > 0) {
310  				const Sci_Position eolPos = styler.LineStart(lineCurrent) - 1;
311  				const int eolStyle = styler.StyleAt(eolPos);
312  				if (eolStyle == SCE_GD_STRING || eolStyle == SCE_GD_CHARACTER
313  						|| eolStyle == SCE_GD_STRINGEOL) {
314  					lineCurrent -= 1;
315  				} else {
316  					break;
317  				}
318  			}
319  			startPos = styler.LineStart(lineCurrent);
320  		}
321  		initStyle = startPos == 0 ? SCE_GD_DEFAULT : styler.StyleAt(startPos - 1);
322  	}
323  	initStyle = initStyle & 31;
324  	if (initStyle == SCE_GD_STRINGEOL) {
325  		initStyle = SCE_GD_DEFAULT;
326  	}
327  	kwType kwLast = kwOther;
328  	int spaceFlags = 0;
329  	styler.IndentAmount(lineCurrent, &spaceFlags, IsGDComment);
330  	bool base_n_number = false;
331  	const WordClassifier &classifierIdentifiers = subStyles.Classifier(SCE_GD_IDENTIFIER);
332  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
333  	bool indentGood = true;
334  	Sci_Position startIndicator = sc.currentPos;
335  	bool inContinuedString = false;
336  	bool percentIsNodePath = false;
337  	int nodePathStringState = SCE_GD_DEFAULT;
338  	for (; sc.More(); sc.Forward()) {
339  		if (sc.atLineStart) {
340  			styler.IndentAmount(lineCurrent, &spaceFlags, IsGDComment);
341  			indentGood = true;
342  			if (options.whingeLevel == 1) {
343  				indentGood = (spaceFlags & wsInconsistent) == 0;
344  			} else if (options.whingeLevel == 2) {
345  				indentGood = (spaceFlags & wsSpaceTab) == 0;
346  			} else if (options.whingeLevel == 3) {
347  				indentGood = (spaceFlags & wsSpace) == 0;
348  			} else if (options.whingeLevel == 4) {
349  				indentGood = (spaceFlags & wsTab) == 0;
350  			}
351  			if (!indentGood) {
352  				styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 0);
353  				startIndicator = sc.currentPos;
354  			}
355  		}
356  		if (sc.atLineEnd) {
357  			percentIsNodePath = false;
358  			ProcessLineEnd(sc, inContinuedString);
359  			lineCurrent++;
360  			if (!sc.More())
361  				break;
362  		}
363  		bool needEOLCheck = false;
364  		if (sc.state == SCE_GD_OPERATOR) {
<span onclick='openModal()' class='match'>365  			kwLast = kwOther;
366  			sc.SetState(SCE_GD_DEFAULT);
367  		} else if (sc.state == SCE_GD_NUMBER) {
368  			if (!IsAWordChar(sc.ch, false) &&
369  					!(!base_n_number && ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E')))) {
370  				sc.SetState(SCE_GD_DEFAULT);
371  			}
372  		} else if (sc.state == SCE_GD_IDENTIFIER) {
373  			if ((sc.ch == '.') || (!IsAWordChar(sc.ch, options.unicodeIdentifiers))) {
374  				char s[100];
375  				sc.GetCurrent(s, sizeof(s));
376  				int style = SCE_GD_IDENTIFIER;
377  				if (keywords.InList(s)) {
</span>378  					style = SCE_GD_WORD;
379  				} else if (kwLast == kwClass) {
380  					style = SCE_GD_CLASSNAME;
381  				} else if (kwLast == kwDef) {
382  					style = SCE_GD_FUNCNAME;
383  				} else if (keywords2.InList(s)) {
384  					if (options.keywords2NoSubIdentifiers) {
385  						const Sci_Position pos = styler.GetStartSegment() - 1;
386  						if (pos < 0 || (styler.SafeGetCharAt(pos, '\0') != '.'))
387  							style = SCE_GD_WORD2;
388  					} else {
389  						style = SCE_GD_WORD2;
390  					}
391  				} else {
392  					const int subStyle = classifierIdentifiers.ValueFor(s);
393  					if (subStyle >= 0) {
394  						style = subStyle;
395  					}
396  				}
397  				sc.ChangeState(style);
398  				sc.SetState(SCE_GD_DEFAULT);
399  				if (style == SCE_GD_WORD) {
400  					if (0 == strcmp(s, "class"))
401  						kwLast = kwClass;
402  					else if (0 == strcmp(s, "func"))
403  						kwLast = kwDef;
404  					else if (0 == strcmp(s, "extends"))
405  						kwLast = kwExtends;
406  					else
407  						kwLast = kwOther;
408  				} else {
409  					kwLast = kwOther;
410  				}
411  			}
412  		} else if ((sc.state == SCE_GD_COMMENTLINE) || (sc.state == SCE_GD_COMMENTBLOCK)) {
413  			if (sc.ch == '\r' || sc.ch == '\n') {
414  				sc.SetState(SCE_GD_DEFAULT);
415  			}
416  		} else if (sc.state == SCE_GD_ANNOTATION) {
417  			if (!IsAWordStart(sc.ch, options.unicodeIdentifiers)) {
418  				sc.SetState(SCE_GD_DEFAULT);
419  			}
420  		} else if (sc.state == SCE_GD_NODEPATH) {
421  			if (nodePathStringState != SCE_GD_DEFAULT) {
422  				if (sc.ch == GetGDStringQuoteChar(nodePathStringState) ) {
423  					nodePathStringState = SCE_GD_DEFAULT;
424  				}
425  			} else {
426  				if (IsGDStringStart(sc.ch)) {
427  					nodePathStringState = GetGDStringState(sc.ch);
428  				} else if (!IsANodePathChar(sc.ch, options.unicodeIdentifiers)) {
429  					sc.SetState(SCE_GD_DEFAULT);
430  				}
431  			}
432  		} else if (IsGDSingleQuoteStringState(sc.state)) {
433  			if (sc.ch == '\\') {
434  				if ((sc.chNext == '\r') && (sc.GetRelative(2) == '\n')) {
435  					sc.Forward();
436  				}
437  				if (sc.chNext == '\n' || sc.chNext == '\r') {
438  					inContinuedString = true;
439  				} else {
440  					sc.Forward();
441  				}
442  			} else if (sc.ch == GetGDStringQuoteChar(sc.state)) {
443  				sc.ForwardSetState(SCE_GD_DEFAULT);
444  				needEOLCheck = true;
445  			}
446  		} else if (sc.state == SCE_GD_TRIPLE) {
447  			if (sc.ch == '\\') {
448  				sc.Forward();
449  			} else if (sc.Match(R"(''')")) {
450  				sc.Forward();
451  				sc.Forward();
452  				sc.ForwardSetState(SCE_GD_DEFAULT);
453  				needEOLCheck = true;
454  			}
455  		} else if (sc.state == SCE_GD_TRIPLEDOUBLE) {
456  			if (sc.ch == '\\') {
457  				sc.Forward();
458  			} else if (sc.Match(R"(""")")) {
459  				sc.Forward();
460  				sc.Forward();
461  				sc.ForwardSetState(SCE_GD_DEFAULT);
462  				needEOLCheck = true;
463  			}
464  		}
465  		if (!indentGood && !IsASpaceOrTab(sc.ch)) {
466  			styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 1);
467  			startIndicator = sc.currentPos;
468  			indentGood = true;
469  		}
470  		if (needEOLCheck && sc.atLineEnd) {
471  			ProcessLineEnd(sc, inContinuedString);
472  			lineCurrent++;
473  			styler.IndentAmount(lineCurrent, &spaceFlags, IsGDComment);
474  			if (!sc.More())
475  				break;
476  		}
477  		if (sc.state == SCE_GD_DEFAULT) {
478  			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
479  				if (sc.ch == '0' && (sc.chNext == 'x' || sc.chNext == 'X')) {
480  					base_n_number = true;
481  					sc.SetState(SCE_GD_NUMBER);
482  				} else if (sc.ch == '0' &&
483  						(sc.chNext == 'o' || sc.chNext == 'O' || sc.chNext == 'b' || sc.chNext == 'B')) {
484  					if (options.base2or8Literals) {
485  						base_n_number = true;
486  						sc.SetState(SCE_GD_NUMBER);
487  					} else {
488  						sc.SetState(SCE_GD_NUMBER);
489  						sc.ForwardSetState(SCE_GD_IDENTIFIER);
490  					}
491  				} else {
492  					base_n_number = false;
493  					sc.SetState(SCE_GD_NUMBER);
494  				}
495  			} else if ((sc.ch == '$') || (sc.ch == '%' && (percentIsNodePath || IsFirstNonWhitespace(sc.currentPos, styler)))) {
496  				percentIsNodePath = false;
497  				sc.SetState(SCE_GD_NODEPATH);
498  			} else if (isoperator(sc.ch) || sc.ch == '`') {
499  				percentIsNodePath = !((sc.ch == ')') || (sc.ch == ']') || (sc.ch == '}'));
500  				sc.SetState(SCE_GD_OPERATOR);
501  			} else if (sc.ch == '#') {
502  				sc.SetState(sc.chNext == '#' ? SCE_GD_COMMENTBLOCK : SCE_GD_COMMENTLINE);
503  			} else if (sc.ch == '@') {
504  				if (IsFirstNonWhitespace(sc.currentPos, styler))
505  					sc.SetState(SCE_GD_ANNOTATION);
506  				else
507  					sc.SetState(SCE_GD_OPERATOR);
508  			} else if (IsGDStringStart(sc.ch)) {
509  				Sci_PositionU nextIndex = 0;
510  				sc.SetState(GetGDStringState(styler, sc.currentPos, &nextIndex));
511  				while (nextIndex > (sc.currentPos + 1) && sc.More()) {
512  					sc.Forward();
513  				}
514              } else if (IsAWordStart(sc.ch, options.unicodeIdentifiers)) {
515  				sc.SetState(SCE_GD_IDENTIFIER);
516  			}
517  		}
518  	}
519  	styler.IndicatorFill(startIndicator, sc.currentPos, indicatorWhitespace, 0);
520  	sc.Complete();
521  }
522  static bool IsCommentLine(Sci_Position line, Accessor &styler) {
523  	const Sci_Position pos = styler.LineStart(line);
524  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
525  	for (Sci_Position i = pos; i < eol_pos; i++) {
526  		const char ch = styler[i];
527  		if (ch == '#')
528  			return true;
529  		else if (ch != ' ' && ch != '\t')
530  			return false;
531  	}
532  	return false;
533  }
534  static bool IsQuoteLine(Sci_Position line, const Accessor &styler) {
535  	const int style = styler.StyleAt(styler.LineStart(line)) & 31;
536  	return IsGDTripleQuoteStringState(style);
537  }
538  void SCI_METHOD LexerGDScript::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;*initStyle - unused*/, IDocument *pAccess) {
539  	if (!options.fold)
540  		return;
541  	Accessor styler(pAccess, nullptr);
542  	const Sci_Position maxPos = startPos + length;
543  	const Sci_Position maxLines = (maxPos == styler.Length()) ? styler.GetLine(maxPos) : styler.GetLine(maxPos - 1);	
544  	const Sci_Position docLines = styler.GetLine(styler.Length());	
545  	int spaceFlags = 0;
546  	Sci_Position lineCurrent = styler.GetLine(startPos);
547  	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, nullptr);
548  	while (lineCurrent > 0) {
549  		lineCurrent--;
550  		indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, nullptr);
551  		if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG) &&
552  				(!IsCommentLine(lineCurrent, styler)) &&
553  				(!IsQuoteLine(lineCurrent, styler)))
554  			break;
555  	}
556  	int indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
557  	startPos = styler.LineStart(lineCurrent);
558  	int prev_state = SCE_GD_DEFAULT & 31;
559  	if (lineCurrent >= 1)
560  		prev_state = styler.StyleAt(startPos - 1) & 31;
561  	int prevQuote = options.foldQuotes && IsGDTripleQuoteStringState(prev_state);
562  	while ((lineCurrent <= docLines) && ((lineCurrent <= maxLines) || prevQuote)) {
563  		int lev = indentCurrent;
564  		Sci_Position lineNext = lineCurrent + 1;
565  		int indentNext = indentCurrent;
566  		int quote = false;
567  		if (lineNext <= docLines) {
568  			indentNext = styler.IndentAmount(lineNext, &spaceFlags, nullptr);
569  			const Sci_Position lookAtPos = (styler.LineStart(lineNext) == styler.Length()) ? styler.Length() - 1 : styler.LineStart(lineNext);
570  			const int style = styler.StyleAt(lookAtPos) & 31;
571  			quote = options.foldQuotes && IsGDTripleQuoteStringState(style);
572  		}
573  		const bool quote_start = (quote && !prevQuote);
574  		const bool quote_continue = (quote && prevQuote);
575  		if (!quote || !prevQuote)
576  			indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
577  		if (quote)
578  			indentNext = indentCurrentLevel;
579  		if (indentNext & SC_FOLDLEVELWHITEFLAG)
580  			indentNext = SC_FOLDLEVELWHITEFLAG | indentCurrentLevel;
581  		if (quote_start) {
582  			lev |= SC_FOLDLEVELHEADERFLAG;
583  		} else if (quote_continue || prevQuote) {
584  			lev = lev + 1;
585  		}
586  		int minCommentLevel = indentCurrentLevel;
587  		while (!quote &&
588  				(lineNext < docLines) &&
589  				((indentNext & SC_FOLDLEVELWHITEFLAG) || (IsCommentLine(lineNext, styler)))) {
590  			if (IsCommentLine(lineNext, styler) && indentNext < minCommentLevel) {
591  				minCommentLevel = indentNext;
592  			}
593  			lineNext++;
594  			indentNext = styler.IndentAmount(lineNext, &spaceFlags, nullptr);
595  		}
596  		const int levelAfterComments = ((lineNext < docLines) ? indentNext & SC_FOLDLEVELNUMBERMASK : minCommentLevel);
597  		const int levelBeforeComments = std::max(indentCurrentLevel, levelAfterComments);
598  		Sci_Position skipLine = lineNext;
599  		int skipLevel = levelAfterComments;
600  		while (--skipLine > lineCurrent) {
601  			const int skipLineIndent = styler.IndentAmount(skipLine, &spaceFlags, nullptr);
602  			if (options.foldCompact) {
603  				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments)
604  					skipLevel = levelBeforeComments;
605  				const int whiteFlag = skipLineIndent & SC_FOLDLEVELWHITEFLAG;
606  				styler.SetLevel(skipLine, skipLevel | whiteFlag);
607  			} else {
608  				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments &&
609  						!(skipLineIndent & SC_FOLDLEVELWHITEFLAG) &&
610  						!IsCommentLine(skipLine, styler))
611  					skipLevel = levelBeforeComments;
612  				styler.SetLevel(skipLine, skipLevel);
613  			}
614  		}
615  		if (!quote && !(indentCurrent & SC_FOLDLEVELWHITEFLAG)) {
616  			if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK))
617  				lev |= SC_FOLDLEVELHEADERFLAG;
618  		}
619  		prevQuote = quote;
620  		styler.SetLevel(lineCurrent, options.foldCompact ? lev : lev & ~SC_FOLDLEVELWHITEFLAG);
621  		indentCurrent = indentNext;
622  		lineCurrent = lineNext;
623  	}
624  }
625  LexerModule lmGDScript(SCLEX_GDSCRIPT, LexerGDScript::LexerFactoryGDScript, "gdscript",
626  		     gdscriptWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPython.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexGDScript.cxx</div>
                </div>
                <div class="column column_space"><pre><code>504  			kwLast = kwOther;
505  			sc.SetState(SCE_P_DEFAULT);
506  		} else if (sc.state == SCE_P_NUMBER) {
507  			if (!IsAWordChar(sc.ch, false) &&
508  					!(!base_n_number && ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E')))) {
509  				sc.SetState(SCE_P_DEFAULT);
510  			}
511  		} else if (sc.state == SCE_P_IDENTIFIER) {
512  			if ((sc.ch == '.') || (!IsAWordChar(sc.ch, options.unicodeIdentifiers))) {
513  				char s[100];
514  				sc.GetCurrent(s, sizeof(s));
515  				int style = SCE_P_IDENTIFIER;
516  				if ((kwLast == kwImport) && (strcmp(s, "as") == 0)) {
</pre></code></div>
                <div class="column column_space"><pre><code>365  			kwLast = kwOther;
366  			sc.SetState(SCE_GD_DEFAULT);
367  		} else if (sc.state == SCE_GD_NUMBER) {
368  			if (!IsAWordChar(sc.ch, false) &&
369  					!(!base_n_number && ((sc.ch == '+' || sc.ch == '-') && (sc.chPrev == 'e' || sc.chPrev == 'E')))) {
370  				sc.SetState(SCE_GD_DEFAULT);
371  			}
372  		} else if (sc.state == SCE_GD_IDENTIFIER) {
373  			if ((sc.ch == '.') || (!IsAWordChar(sc.ch, options.unicodeIdentifiers))) {
374  				char s[100];
375  				sc.GetCurrent(s, sizeof(s));
376  				int style = SCE_GD_IDENTIFIER;
377  				if (keywords.InList(s)) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    