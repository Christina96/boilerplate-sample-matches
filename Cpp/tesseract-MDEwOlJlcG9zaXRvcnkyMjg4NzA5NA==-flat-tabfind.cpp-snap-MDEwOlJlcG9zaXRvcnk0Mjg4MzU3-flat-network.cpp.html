
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.394170714781402%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabfind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "colpartitiongrid.h"
6  #include "detlinefit.h"
7  #include "host.h" 
8  #include "linefind.h"
9  #include "tabfind.h"
10  #include <algorithm>
11  namespace tesseract {
12  const int kTabRadiusFactor = 5;
13  const int kMinVerticalSearch = 3;
14  const int kMaxVerticalSearch = 12;
15  const int kMaxRaggedSearch = 25;
16  const int kMinLinesInColumn = 10;
17  const int kMinColumnWidth = 200;
18  const double kMinFractionalLinesInColumn = 0.125;
19  const double kAlignedFraction = 0.03125;
20  const double kMaxGutterWidthAbsolute = 2.00;
21  const int kRaggedGutterMultiple = 5;
22  const double kLineFragmentAspectRatio = 10.0;
23  const int kMinEvaluatedTabs = 3;
24  const double kCosMaxSkewAngle = 0.866025;
25  static BOOL_VAR(textord_tabfind_show_initialtabs, false, "Show tab candidates");
26  static BOOL_VAR(textord_tabfind_show_finaltabs, false, "Show tab vectors");
27  TabFind::TabFind(int gridsize, const ICOORD &bleft, const ICOORD &tright, TabVector_LIST *vlines,
28                   int vertical_x, int vertical_y, int resolution)
29      : AlignedBlob(gridsize, bleft, tright)
30      , resolution_(resolution)
31      , image_origin_(0, tright.y() - 1)
32      , v_it_(&vectors_) {
33    width_cb_ = nullptr;
34    v_it_.add_list_after(vlines);
35    SetVerticalSkewAndParallelize(vertical_x, vertical_y);
36    using namespace std::placeholders; 
37    width_cb_ = std::bind(&TabFind::CommonWidth, this, _1);
38  }
39  TabFind::~TabFind() = default;
40  void TabFind::InsertBlobsToGrid(bool h_spread, bool v_spread, BLOBNBOX_LIST *blobs,
41                                  BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> *grid) {
42    BLOBNBOX_IT blob_it(blobs);
43    int b_count = 0;
44    int reject_count = 0;
45    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
46      BLOBNBOX *blob = blob_it.data();
47      if (InsertBlob(h_spread, v_spread, blob, grid)) {
48        ++b_count;
49      } else {
50        ++reject_count;
51      }
52    }
53    if (textord_debug_tabfind) {
54      tprintf("Inserted %d blobs into grid, %d rejected.\n", b_count, reject_count);
55    }
56  }
57  bool TabFind::InsertBlob(bool h_spread, bool v_spread, BLOBNBOX *blob,
58                           BBGrid<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> *grid) {
59    TBOX box = blob->bounding_box();
60    blob->set_left_rule(LeftEdgeForBox(box, false, false));
61    blob->set_right_rule(RightEdgeForBox(box, false, false));
62    blob->set_left_crossing_rule(LeftEdgeForBox(box, true, false));
63    blob->set_right_crossing_rule(RightEdgeForBox(box, true, false));
64    if (blob->joined_to_prev()) {
65      return false;
66    }
67    grid->InsertBBox(h_spread, v_spread, blob);
68    return true;
69  }
70  void TabFind::SetBlockRuleEdges(TO_BLOCK *block) {
71    SetBlobRuleEdges(&block->blobs);
72    SetBlobRuleEdges(&block->small_blobs);
73    SetBlobRuleEdges(&block->noise_blobs);
74    SetBlobRuleEdges(&block->large_blobs);
75  }
76  void TabFind::SetBlobRuleEdges(BLOBNBOX_LIST *blobs) {
77    BLOBNBOX_IT blob_it(blobs);
78    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
79      BLOBNBOX *blob = blob_it.data();
80      TBOX box = blob->bounding_box();
81      blob->set_left_rule(LeftEdgeForBox(box, false, false));
82      blob->set_right_rule(RightEdgeForBox(box, false, false));
83      blob->set_left_crossing_rule(LeftEdgeForBox(box, true, false));
84      blob->set_right_crossing_rule(RightEdgeForBox(box, true, false));
85    }
86  }
87  int TabFind::GutterWidth(int bottom_y, int top_y, const TabVector &v, bool ignore_unmergeables,
88                           int max_gutter_width, int *required_shift) {
89    bool right_to_left = v.IsLeftTab();
90    int bottom_x = v.XAtY(bottom_y);
91    int top_x = v.XAtY(top_y);
92    int start_x = right_to_left ? std::max(top_x, bottom_x) : std::min(top_x, bottom_x);
93    BlobGridSearch sidesearch(this);
94    sidesearch.StartSideSearch(start_x, bottom_y, top_y);
95    int min_gap = max_gutter_width;
96    *required_shift = 0;
97    BLOBNBOX *blob = nullptr;
98    while ((blob = sidesearch.NextSideSearch(right_to_left)) != nullptr) {
99      const TBOX &box = blob->bounding_box();
100      if (box.bottom() >= top_y || box.top() <= bottom_y) {
101        continue; 
102      }
103      if (box.height() >= gridsize() * 2 && box.height() > box.width() * kLineFragmentAspectRatio) {
104        continue;
105      }
106      if (ignore_unmergeables && BLOBNBOX::UnMergeableType(blob->region_type())) {
107        continue; 
108      }
109      int mid_y = (box.bottom() + box.top()) / 2;
110      int tab_x = v.XAtY(mid_y);
111      int gap;
112      if (right_to_left) {
113        gap = tab_x - box.right();
114        if (gap < 0 && box.left() - tab_x < *required_shift) {
115          *required_shift = box.left() - tab_x;
116        }
117      } else {
118        gap = box.left() - tab_x;
119        if (gap < 0 && box.right() - tab_x > *required_shift) {
120          *required_shift = box.right() - tab_x;
121        }
122      }
123      if (gap > 0 && gap < min_gap) {
124        min_gap = gap;
125      }
126    }
127    return min_gap - abs(*required_shift);
128  }
129  void TabFind::GutterWidthAndNeighbourGap(int tab_x, int mean_height, int max_gutter, bool left,
130                                           BLOBNBOX *bbox, int *gutter_width, int *neighbour_gap) {
131    const TBOX &box = bbox->bounding_box();
132    int gutter_x = left ? box.left() : box.right();
133    int internal_x = left ? box.right() : box.left();
134    int tab_gap = left ? gutter_x - tab_x : tab_x - gutter_x;
135    *gutter_width = max_gutter;
136    if (tab_gap > 0) {
137      *gutter_width += tab_gap;
138    }
139    bool debug = WithinTestRegion(2, box.left(), box.bottom());
140    if (debug) {
141      tprintf("Looking in gutter\n");
142    }
143    BLOBNBOX *gutter_bbox = AdjacentBlob(bbox, left, bbox->flow() == BTFT_TEXT_ON_IMAGE, 0.0,
144                                         *gutter_width, box.top(), box.bottom());
145    if (gutter_bbox != nullptr) {
146      const TBOX &gutter_box = gutter_bbox->bounding_box();
147      *gutter_width = left ? tab_x - gutter_box.right() : gutter_box.left() - tab_x;
148    }
149    if (*gutter_width >= max_gutter) {
150      TBOX gutter_box(box);
151      if (left) {
152        gutter_box.set_left(tab_x - max_gutter - 1);
153        gutter_box.set_right(tab_x - max_gutter);
154        int tab_gutter = RightEdgeForBox(gutter_box, true, false);
155        if (tab_gutter < tab_x - 1) {
156          *gutter_width = tab_x - tab_gutter;
157        }
158      } else {
159        gutter_box.set_left(tab_x + max_gutter);
160        gutter_box.set_right(tab_x + max_gutter + 1);
161        int tab_gutter = LeftEdgeForBox(gutter_box, true, false);
162        if (tab_gutter > tab_x + 1) {
163          *gutter_width = tab_gutter - tab_x;
164        }
165      }
166    }
167    if (*gutter_width > max_gutter) {
168      *gutter_width = max_gutter;
169    }
170    if (debug) {
171      tprintf("Looking for neighbour\n");
172    }
173    BLOBNBOX *neighbour = AdjacentBlob(bbox, !left, bbox->flow() == BTFT_TEXT_ON_IMAGE, 0.0,
174                                       *gutter_width, box.top(), box.bottom());
175    int neighbour_edge = left ? RightEdgeForBox(box, true, false) : LeftEdgeForBox(box, true, false);
176    if (neighbour != nullptr) {
177      const TBOX &n_box = neighbour->bounding_box();
178      if (debug) {
179        tprintf("Found neighbour:");
180        n_box.print();
181      }
182      if (left && n_box.left() < neighbour_edge) {
183        neighbour_edge = n_box.left();
184      } else if (!left && n_box.right() > neighbour_edge) {
185        neighbour_edge = n_box.right();
186      }
187    }
188    *neighbour_gap = left ? neighbour_edge - internal_x : internal_x - neighbour_edge;
189  }
190  int TabFind::RightEdgeForBox(const TBOX &box, bool crossing, bool extended) {
191    TabVector *v = RightTabForBox(box, crossing, extended);
192    return v == nullptr ? tright_.x() : v->XAtY((box.top() + box.bottom()) / 2);
193  }
194  int TabFind::LeftEdgeForBox(const TBOX &box, bool crossing, bool extended) {
195    TabVector *v = LeftTabForBox(box, crossing, extended);
196    return v == nullptr ? bleft_.x() : v->XAtY((box.top() + box.bottom()) / 2);
197  }
198  TabVector *TabFind::RightTabForBox(const TBOX &box, bool crossing, bool extended) {
199    if (v_it_.empty()) {
200      return nullptr;
201    }
202    int top_y = box.top();
203    int bottom_y = box.bottom();
204    int mid_y = (top_y + bottom_y) / 2;
205    int right = crossing ? (box.left() + box.right()) / 2 : box.right();
206    int min_key, max_key;
207    SetupTabSearch(right, mid_y, &min_key, &max_key);
208    while (!v_it_.at_first() && v_it_.data()->sort_key() >= min_key) {
209      v_it_.backward();
210    }
211    while (!v_it_.at_last() && v_it_.data()->sort_key() < min_key) {
212      v_it_.forward();
213    }
214    TabVector *best_v = nullptr;
215    int best_x = -1;
216    int key_limit = -1;
217    do {
218      TabVector *v = v_it_.data();
219      int x = v->XAtY(mid_y);
220      if (x >= right && (v->VOverlap(top_y, bottom_y) > 0 ||
221                         (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
222        if (best_v == nullptr || x < best_x) {
223          best_v = v;
224          best_x = x;
225          key_limit = v->sort_key() + max_key - min_key;
226        }
227      }
228      if (v_it_.at_last() || (best_v != nullptr && v->sort_key() > key_limit)) {
229        break; 
230      }
231      v_it_.forward();
232    } while (!v_it_.at_first());
233    return best_v;
234  }
235  TabVector *TabFind::LeftTabForBox(const TBOX &box, bool crossing, bool extended) {
236    if (v_it_.empty()) {
237      return nullptr;
238    }
239    int top_y = box.top();
240    int bottom_y = box.bottom();
241    int mid_y = (top_y + bottom_y) / 2;
242    int left = crossing ? (box.left() + box.right()) / 2 : box.left();
243    int min_key, max_key;
244    SetupTabSearch(left, mid_y, &min_key, &max_key);
245    while (!v_it_.at_last() && v_it_.data()->sort_key() <= max_key) {
246      v_it_.forward();
247    }
248    while (!v_it_.at_first() && v_it_.data()->sort_key() > max_key) {
249      v_it_.backward();
250    }
251    TabVector *best_v = nullptr;
252    int best_x = -1;
253    int key_limit = -1;
254    do {
255      TabVector *v = v_it_.data();
256      int x = v->XAtY(mid_y);
257      if (x <= left && (v->VOverlap(top_y, bottom_y) > 0 ||
258                        (extended && v->ExtendedOverlap(top_y, bottom_y) > 0))) {
259        if (best_v == nullptr || x > best_x) {
260          best_v = v;
261          best_x = x;
262          key_limit = v->sort_key() - (max_key - min_key);
263        }
264      }
265      if (v_it_.at_first() || (best_v != nullptr && v->sort_key() < key_limit)) {
266        break; 
267      }
268      v_it_.backward();
269    } while (!v_it_.at_last());
270    return best_v;
271  }
272  bool TabFind::CommonWidth(int width) {
273    width /= kColumnWidthFactor;
274    ICOORDELT_IT it(&column_widths_);
275    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
276      ICOORDELT *w = it.data();
277      if (w->x() - 1 <= width && width <= w->y() + 1) {
278        return true;
279      }
280    }
281    return false;
282  }
283  bool TabFind::DifferentSizes(int size1, int size2) {
284    return size1 > size2 * 2 || size2 > size1 * 2;
285  }
286  bool TabFind::VeryDifferentSizes(int size1, int size2) {
287    return size1 > size2 * 5 || size2 > size1 * 5;
288  }
289  bool TabFind::FindTabVectors(TabVector_LIST *hlines, BLOBNBOX_LIST *image_blobs, TO_BLOCK *block,
290                               int min_gutter_width, double tabfind_aligned_gap_fraction,
291                               ColPartitionGrid *part_grid, FCOORD *deskew, FCOORD *reskew) {
292    ScrollView *tab_win =
293        FindInitialTabVectors(image_blobs, min_gutter_width, tabfind_aligned_gap_fraction, block);
294    ComputeColumnWidths(tab_win, part_grid);
295    TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
296    SortVectors();
297    CleanupTabs();
298    if (!Deskew(hlines, image_blobs, block, deskew, reskew)) {
299      return false; 
300    }
301    part_grid->Deskew(*deskew);
302    ApplyTabConstraints();
303  #ifndef GRAPHICS_DISABLED
304    if (textord_tabfind_show_finaltabs) {
305      tab_win = MakeWindow(640, 50, "FinalTabs");
306      DisplayBoxes(tab_win);
307      DisplayTabs("FinalTabs", tab_win);
308      tab_win = DisplayTabVectors(tab_win);
309    }
310  #endif 
311    return true;
312  }
313  void TabFind::DontFindTabVectors(BLOBNBOX_LIST *image_blobs, TO_BLOCK *block, FCOORD *deskew,
314                                   FCOORD *reskew) {
315    InsertBlobsToGrid(false, false, image_blobs, this);
316    InsertBlobsToGrid(true, false, &block->blobs, this);
317    deskew->set_x(1.0f);
318    deskew->set_y(0.0f);
319    reskew->set_x(1.0f);
320    reskew->set_y(0.0f);
321  }
322  void TabFind::TidyBlobs(TO_BLOCK *block) {
323    BLOBNBOX_IT large_it = &block->large_blobs;
324    BLOBNBOX_IT blob_it = &block->blobs;
325    int b_count = 0;
326    for (large_it.mark_cycle_pt(); !large_it.cycled_list(); large_it.forward()) {
327      BLOBNBOX *large_blob = large_it.data();
328      if (large_blob->owner() != nullptr) {
329        blob_it.add_to_end(large_it.extract());
330        ++b_count;
331      }
332    }
333    if (textord_debug_tabfind) {
334      tprintf("Moved %d large blobs to normal list\n", b_count);
335  #ifndef GRAPHICS_DISABLED
336      ScrollView *rej_win = MakeWindow(500, 300, "Image blobs");
337      block->plot_graded_blobs(rej_win);
338      block->plot_noise_blobs(rej_win);
339      rej_win->Update();
340  #endif 
341    }
342    block->DeleteUnownedNoise();
343  }
344  void TabFind::SetupTabSearch(int x, int y, int *min_key, int *max_key) {
345    int key1 = TabVector::SortKey(vertical_skew_, x, (y + tright_.y()) / 2);
346    int key2 = TabVector::SortKey(vertical_skew_, x, (y + bleft_.y()) / 2);
347    *min_key = std::min(key1, key2);
348    *max_key = std::max(key1, key2);
349  }
350  #ifndef GRAPHICS_DISABLED
351  ScrollView *TabFind::DisplayTabVectors(ScrollView *tab_win) {
352    TabVector_IT it(&vectors_);
353    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
354      TabVector *vector = it.data();
355      vector->Display(tab_win);
356    }
357    tab_win->Update();
358    return tab_win;
359  }
360  #endif
361  ScrollView *TabFind::FindInitialTabVectors(BLOBNBOX_LIST *image_blobs, int min_gutter_width,
362                                             double tabfind_aligned_gap_fraction, TO_BLOCK *block) {
363  #ifndef GRAPHICS_DISABLED
364    if (textord_tabfind_show_initialtabs) {
365      ScrollView *line_win = MakeWindow(0, 0, "VerticalLines");
366      line_win = DisplayTabVectors(line_win);
367    }
368  #endif
369    if (image_blobs != nullptr) {
370      InsertBlobsToGrid(true, false, image_blobs, this);
371    }
372    InsertBlobsToGrid(true, false, &block->blobs, this);
373    ScrollView *initial_win = FindTabBoxes(min_gutter_width, tabfind_aligned_gap_fraction);
374    FindAllTabVectors(min_gutter_width);
375    TabVector::MergeSimilarTabVectors(vertical_skew_, &vectors_, this);
376    SortVectors();
377    EvaluateTabs();
378  #ifndef GRAPHICS_DISABLED
379    if (textord_tabfind_show_initialtabs && initial_win != nullptr) {
380      initial_win = DisplayTabVectors(initial_win);
381    }
382  #endif
383    MarkVerticalText();
384    return initial_win;
385  }
386  #ifndef GRAPHICS_DISABLED
387  static void DisplayBoxVector(const std::vector<BLOBNBOX *> &boxes, ScrollView *win) {
388    for (auto boxe : boxes) {
389      TBOX box = boxe->bounding_box();
390      int left_x = box.left();
391      int right_x = box.right();
392      int top_y = box.top();
393      int bottom_y = box.bottom();
394      ScrollView::Color box_color = boxe->BoxColor();
395      win->Pen(box_color);
396      win->Rectangle(left_x, bottom_y, right_x, top_y);
397    }
398    win->Update();
399  }
400  #endif 
401  ScrollView *TabFind::FindTabBoxes(int min_gutter_width, double tabfind_aligned_gap_fraction) {
402    left_tab_boxes_.clear();
403    right_tab_boxes_.clear();
404    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> gsearch(this);
405    gsearch.StartFullSearch();
406    BLOBNBOX *bbox;
407    while ((bbox = gsearch.NextFullSearch()) != nullptr) {
408      if (TestBoxForTabs(bbox, min_gutter_width, tabfind_aligned_gap_fraction)) {
409        if (bbox->left_tab_type() != TT_NONE) {
410          left_tab_boxes_.push_back(bbox);
411        }
412        if (bbox->right_tab_type() != TT_NONE) {
413          right_tab_boxes_.push_back(bbox);
414        }
415      }
416    }
417    std::sort(left_tab_boxes_.begin(), left_tab_boxes_.end(), StdSortByBoxLeft<BLOBNBOX>);
418    std::sort(right_tab_boxes_.begin(), right_tab_boxes_.end(), StdSortRightToLeft<BLOBNBOX>);
419    ScrollView *tab_win = nullptr;
420  #ifndef GRAPHICS_DISABLED
421    if (textord_tabfind_show_initialtabs) {
422      tab_win = MakeWindow(0, 100, "InitialTabs");
423      tab_win->Pen(ScrollView::BLUE);
424      tab_win->Brush(ScrollView::NONE);
425      DisplayBoxVector(left_tab_boxes_, tab_win);
426      DisplayBoxVector(right_tab_boxes_, tab_win);
427      tab_win = DisplayTabs("Tabs", tab_win);
428    }
429  #endif 
430    return tab_win;
431  }
432  bool TabFind::TestBoxForTabs(BLOBNBOX *bbox, int min_gutter_width,
433                               double tabfind_aligned_gap_fraction) {
434    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> radsearch(this);
435    TBOX box = bbox->bounding_box();
436    int left_column_edge = bbox->left_rule();
437    int right_column_edge = bbox->right_rule();
438    int left_x = box.left();
439    int right_x = box.right();
440    int top_y = box.top();
441    int bottom_y = box.bottom();
442    int height = box.height();
443    bool debug = WithinTestRegion(3, left_x, top_y);
444    if (debug) {
445      tprintf("Column edges for blob at (%d,%d)->(%d,%d) are [%d, %d]\n", left_x, top_y, right_x,
446              bottom_y, left_column_edge, right_column_edge);
447    }
448    int radius = (height * kTabRadiusFactor + gridsize_ - 1) / gridsize_;
449    radsearch.StartRadSearch((left_x + right_x) / 2, (top_y + bottom_y) / 2, radius);
450    int min_spacing = static_cast<int>(height * tabfind_aligned_gap_fraction);
451    if (min_gutter_width > min_spacing) {
452      min_spacing = min_gutter_width;
453    }
454    int min_ragged_gutter = kRaggedGutterMultiple * gridsize();
455    if (min_gutter_width > min_ragged_gutter) {
456      min_ragged_gutter = min_gutter_width;
457    }
458    int target_right = left_x - min_spacing;
459    int target_left = right_x + min_spacing;
460    bool is_left_tab = true;
461    bool is_right_tab = true;
462    bool maybe_ragged_left = true;
463    bool maybe_ragged_right = true;
464    int maybe_left_tab_up = 0;
465    int maybe_right_tab_up = 0;
466    int maybe_left_tab_down = 0;
467    int maybe_right_tab_down = 0;
468    if (bbox->leader_on_left()) {
469      is_left_tab = false;
470      maybe_ragged_left = false;
471      maybe_left_tab_up = -INT32_MAX;
472      maybe_left_tab_down = -INT32_MAX;
473    }
474    if (bbox->leader_on_right()) {
475      is_right_tab = false;
476      maybe_ragged_right = false;
477      maybe_right_tab_up = -INT32_MAX;
478      maybe_right_tab_down = -INT32_MAX;
479    }
480    int alignment_tolerance = static_cast<int>(resolution_ * kAlignedFraction);
481    BLOBNBOX *neighbour = nullptr;
482    while ((neighbour = radsearch.NextRadSearch()) != nullptr) {
483      if (neighbour == bbox) {
484        continue;
485      }
486      TBOX nbox = neighbour->bounding_box();
487      int n_left = nbox.left();
488      int n_right = nbox.right();
489      if (debug) {
490        tprintf("Neighbour at (%d,%d)->(%d,%d)\n", n_left, nbox.bottom(), n_right, nbox.top());
491      }
492      if (n_right > right_column_edge || n_left < left_column_edge ||
493          left_x < neighbour->left_rule() || right_x > neighbour->right_rule()) {
494        continue; 
495      }
496      int n_mid_x = (n_left + n_right) / 2;
497      int n_mid_y = (nbox.top() + nbox.bottom()) / 2;
498      if (n_mid_x <= left_x && n_right >= target_right) {
499        if (debug) {
500          tprintf("Not a left tab\n");
<span onclick='openModal()' class='match'>501        }
502        is_left_tab = false;
503        if (n_mid_y < top_y) {
504          maybe_left_tab_down = -INT32_MAX;
505        }
506        if (n_mid_y > bottom_y) {
507          maybe_left_tab_up = -INT32_MAX;
508        }
</span>509      } else if (NearlyEqual(left_x, n_left, alignment_tolerance)) {
510        if (debug) {
511          tprintf("Maybe a left tab\n");
512        }
513        if (n_mid_y > top_y && maybe_left_tab_up > -INT32_MAX) {
514          ++maybe_left_tab_up;
515        }
516        if (n_mid_y < bottom_y && maybe_left_tab_down > -INT32_MAX) {
517          ++maybe_left_tab_down;
518        }
519      } else if (n_left < left_x && n_right >= left_x) {
520        if (debug) {
521          tprintf("Maybe Not a left tab\n");
522        }
523        if (n_mid_y > top_y && maybe_left_tab_up > -INT32_MAX) {
524          --maybe_left_tab_up;
525        }
526        if (n_mid_y < bottom_y && maybe_left_tab_down > -INT32_MAX) {
527          --maybe_left_tab_down;
528        }
529      }
530      if (n_left < left_x && nbox.y_overlap(box) && n_right >= target_right) {
531        maybe_ragged_left = false;
532        if (debug) {
533          tprintf("Not a ragged left\n");
534        }
535      }
536      if (n_mid_x >= right_x && n_left <= target_left) {
537        if (debug) {
538          tprintf("Not a right tab\n");
539        }
540        is_right_tab = false;
541        if (n_mid_y < top_y) {
542          maybe_right_tab_down = -INT32_MAX;
543        }
544        if (n_mid_y > bottom_y) {
545          maybe_right_tab_up = -INT32_MAX;
546        }
547      } else if (NearlyEqual(right_x, n_right, alignment_tolerance)) {
548        if (debug) {
549          tprintf("Maybe a right tab\n");
550        }
551        if (n_mid_y > top_y && maybe_right_tab_up > -INT32_MAX) {
552          ++maybe_right_tab_up;
553        }
554        if (n_mid_y < bottom_y && maybe_right_tab_down > -INT32_MAX) {
555          ++maybe_right_tab_down;
556        }
557      } else if (n_right > right_x && n_left <= right_x) {
558        if (debug) {
559          tprintf("Maybe Not a right tab\n");
560        }
561        if (n_mid_y > top_y && maybe_right_tab_up > -INT32_MAX) {
562          --maybe_right_tab_up;
563        }
564        if (n_mid_y < bottom_y && maybe_right_tab_down > -INT32_MAX) {
565          --maybe_right_tab_down;
566        }
567      }
568      if (n_right > right_x && nbox.y_overlap(box) && n_left <= target_left) {
569        maybe_ragged_right = false;
570        if (debug) {
571          tprintf("Not a ragged right\n");
572        }
573      }
574      if (maybe_left_tab_down == -INT32_MAX && maybe_left_tab_up == -INT32_MAX &&
575          maybe_right_tab_down == -INT32_MAX && maybe_right_tab_up == -INT32_MAX) {
576        break;
577      }
578    }
579    if (is_left_tab || maybe_left_tab_up > 1 || maybe_left_tab_down > 1) {
580      bbox->set_left_tab_type(TT_MAYBE_ALIGNED);
581    } else if (maybe_ragged_left && ConfirmRaggedLeft(bbox, min_ragged_gutter)) {
582      bbox->set_left_tab_type(TT_MAYBE_RAGGED);
583    } else {
584      bbox->set_left_tab_type(TT_NONE);
585    }
586    if (is_right_tab || maybe_right_tab_up > 1 || maybe_right_tab_down > 1) {
587      bbox->set_right_tab_type(TT_MAYBE_ALIGNED);
588    } else if (maybe_ragged_right && ConfirmRaggedRight(bbox, min_ragged_gutter)) {
589      bbox->set_right_tab_type(TT_MAYBE_RAGGED);
590    } else {
591      bbox->set_right_tab_type(TT_NONE);
592    }
593    if (debug) {
594      tprintf("Left result = %s, Right result=%s\n",
595              bbox->left_tab_type() == TT_MAYBE_ALIGNED
596                  ? "Aligned"
597                  : (bbox->left_tab_type() == TT_MAYBE_RAGGED ? "Ragged" : "None"),
598              bbox->right_tab_type() == TT_MAYBE_ALIGNED
599                  ? "Aligned"
600                  : (bbox->right_tab_type() == TT_MAYBE_RAGGED ? "Ragged" : "None"));
601    }
602    return bbox->left_tab_type() != TT_NONE || bbox->right_tab_type() != TT_NONE;
603  }
604  bool TabFind::ConfirmRaggedLeft(BLOBNBOX *bbox, int min_gutter) {
605    TBOX search_box(bbox->bounding_box());
606    search_box.set_right(search_box.left());
607    search_box.set_left(search_box.left() - min_gutter);
608    return NothingYOverlapsInBox(search_box, bbox->bounding_box());
609  }
610  bool TabFind::ConfirmRaggedRight(BLOBNBOX *bbox, int min_gutter) {
611    TBOX search_box(bbox->bounding_box());
612    search_box.set_left(search_box.right());
613    search_box.set_right(search_box.right() + min_gutter);
614    return NothingYOverlapsInBox(search_box, bbox->bounding_box());
615  }
616  bool TabFind::NothingYOverlapsInBox(const TBOX &search_box, const TBOX &target_box) {
617    BlobGridSearch rsearch(this);
618    rsearch.StartRectSearch(search_box);
619    BLOBNBOX *blob;
620    while ((blob = rsearch.NextRectSearch()) != nullptr) {
621      const TBOX &box = blob->bounding_box();
622      if (box.y_overlap(target_box) && !(box == target_box)) {
623        return false;
624      }
625    }
626    return true;
627  }
628  void TabFind::FindAllTabVectors(int min_gutter_width) {
629    TabVector_LIST dummy_vectors;
630    int vertical_x = 0;
631    int vertical_y = 1;
632    for (int search_size = kMinVerticalSearch; search_size < kMaxVerticalSearch;
633         search_size += kMinVerticalSearch) {
634      int vector_count = FindTabVectors(search_size, TA_LEFT_ALIGNED, min_gutter_width,
635                                        &dummy_vectors, &vertical_x, &vertical_y);
636      vector_count += FindTabVectors(search_size, TA_RIGHT_ALIGNED, min_gutter_width, &dummy_vectors,
637                                     &vertical_x, &vertical_y);
638      if (vector_count > 0) {
639        break;
640      }
641    }
642    dummy_vectors.clear();
643    for (auto bbox : left_tab_boxes_) {
644      if (bbox->left_tab_type() == TT_CONFIRMED) {
645        bbox->set_left_tab_type(TT_MAYBE_ALIGNED);
646      }
647    }
648    for (auto bbox : right_tab_boxes_) {
649      if (bbox->right_tab_type() == TT_CONFIRMED) {
650        bbox->set_right_tab_type(TT_MAYBE_ALIGNED);
651      }
652    }
653    if (textord_debug_tabfind) {
654      tprintf("Beginning real tab search with vertical = %d,%d...\n", vertical_x, vertical_y);
655    }
656    FindTabVectors(kMaxVerticalSearch, TA_LEFT_ALIGNED, min_gutter_width, &dummy_vectors, &vertical_x,
657                   &vertical_y);
658    FindTabVectors(kMaxVerticalSearch, TA_RIGHT_ALIGNED, min_gutter_width, &dummy_vectors,
659                   &vertical_x, &vertical_y);
660    FindTabVectors(kMaxRaggedSearch, TA_LEFT_RAGGED, min_gutter_width, &dummy_vectors, &vertical_x,
661                   &vertical_y);
662    FindTabVectors(kMaxRaggedSearch, TA_RIGHT_RAGGED, min_gutter_width, &dummy_vectors, &vertical_x,
663                   &vertical_y);
664    TabVector_IT v_it(&vectors_);
665    v_it.add_list_after(&dummy_vectors);
666    SetVerticalSkewAndParallelize(vertical_x, vertical_y);
667  }
668  int TabFind::FindTabVectors(int search_size_multiple, TabAlignment alignment, int min_gutter_width,
669                              TabVector_LIST *vectors, int *vertical_x, int *vertical_y) {
670    TabVector_IT vector_it(vectors);
671    int vector_count = 0;
672    bool right = alignment == TA_RIGHT_ALIGNED || alignment == TA_RIGHT_RAGGED;
673    const std::vector<BLOBNBOX *> &boxes = right ? right_tab_boxes_ : left_tab_boxes_;
674    for (auto bbox : boxes) {
675      if ((!right && bbox->left_tab_type() == TT_MAYBE_ALIGNED) ||
676          (right && bbox->right_tab_type() == TT_MAYBE_ALIGNED)) {
677        TabVector *vector = FindTabVector(search_size_multiple, min_gutter_width, alignment, bbox,
678                                          vertical_x, vertical_y);
679        if (vector != nullptr) {
680          ++vector_count;
681          vector_it.add_to_end(vector);
682        }
683      }
684    }
685    return vector_count;
686  }
687  TabVector *TabFind::FindTabVector(int search_size_multiple, int min_gutter_width,
688                                    TabAlignment alignment, BLOBNBOX *bbox, int *vertical_x,
689                                    int *vertical_y) {
690    int height = std::max(static_cast<int>(bbox->bounding_box().height()), gridsize());
691    AlignedBlobParams align_params(*vertical_x, *vertical_y, height, search_size_multiple,
692                                   min_gutter_width, resolution_, alignment);
693    return FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
694  }
695  void TabFind::SetVerticalSkewAndParallelize(int vertical_x, int vertical_y) {
696    vertical_skew_.set_with_shrink(vertical_x, vertical_y);
697    if (textord_debug_tabfind) {
698      tprintf("Vertical skew vector=(%d,%d)\n", vertical_skew_.x(), vertical_skew_.y());
699    }
700    v_it_.set_to_list(&vectors_);
701    for (v_it_.mark_cycle_pt(); !v_it_.cycled_list(); v_it_.forward()) {
702      TabVector *v = v_it_.data();
703      v->Fit(vertical_skew_, true);
704    }
705    SortVectors();
706  }
707  void TabFind::SortVectors() {
708    vectors_.sort(TabVector::SortVectorsByKey);
709    v_it_.set_to_list(&vectors_);
710  }
711  void TabFind::EvaluateTabs() {
712    TabVector_IT rule_it(&vectors_);
713    for (rule_it.mark_cycle_pt(); !rule_it.cycled_list(); rule_it.forward()) {
714      TabVector *tab = rule_it.data();
715      if (!tab->IsSeparator()) {
716        tab->Evaluate(vertical_skew_, this);
717        if (tab->BoxCount() < kMinEvaluatedTabs) {
718          if (textord_debug_tabfind > 2) {
719            tab->Print("Too few boxes");
720          }
721          delete rule_it.extract();
722          v_it_.set_to_list(&vectors_);
723        } else if (WithinTestRegion(3, tab->startpt().x(), tab->startpt().y())) {
724          tab->Print("Evaluated tab");
725        }
726      }
727    }
728  }
729  void TabFind::ComputeColumnWidths(ScrollView *tab_win, ColPartitionGrid *part_grid) {
730  #ifndef GRAPHICS_DISABLED
731    if (tab_win != nullptr) {
732      tab_win->Pen(ScrollView::WHITE);
733    }
734  #endif 
735    int col_widths_size = (tright_.x() - bleft_.x()) / kColumnWidthFactor;
736    STATS col_widths(0, col_widths_size);
737    ApplyPartitionsToColumnWidths(part_grid, &col_widths);
738  #ifndef GRAPHICS_DISABLED
739    if (tab_win != nullptr) {
740      tab_win->Update();
741    }
742  #endif 
743    if (textord_debug_tabfind > 1) {
744      col_widths.print();
745    }
746    MakeColumnWidths(col_widths_size, &col_widths);
747    ApplyPartitionsToColumnWidths(part_grid, nullptr);
748  }
749  void TabFind::ApplyPartitionsToColumnWidths(ColPartitionGrid *part_grid, STATS *col_widths) {
750    ColPartitionGridSearch gsearch(part_grid);
751    gsearch.StartFullSearch();
752    ColPartition *part;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      BLOBNBOX_C_IT blob_it(part->boxes());
755      if (blob_it.empty()) {
756        continue;
757      }
758      BLOBNBOX *left_blob = blob_it.data();
759      blob_it.move_to_last();
760      BLOBNBOX *right_blob = blob_it.data();
761      TabVector *left_vector = LeftTabForBox(left_blob->bounding_box(), true, false);
762      if (left_vector == nullptr || left_vector->IsRightTab()) {
763        continue;
764      }
765      TabVector *right_vector = RightTabForBox(right_blob->bounding_box(), true, false);
766      if (right_vector == nullptr || right_vector->IsLeftTab()) {
767        continue;
768      }
769      int line_left = left_vector->XAtY(left_blob->bounding_box().bottom());
770      int line_right = right_vector->XAtY(right_blob->bounding_box().bottom());
771      int width = line_right - line_left;
772      if (col_widths != nullptr) {
773        AddPartnerVector(left_blob, right_blob, left_vector, right_vector);
774        if (width >= kMinColumnWidth) {
775          col_widths->add(width / kColumnWidthFactor, 1);
776        }
777      } else {
778        width /= kColumnWidthFactor;
779        ICOORDELT_IT it(&column_widths_);
780        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
781          ICOORDELT *w = it.data();
782          if (NearlyEqual<int>(width, w->y(), 1)) {
783            int true_width = part->bounding_box().width() / kColumnWidthFactor;
784            if (true_width <= w->y() && true_width > w->x()) {
785              w->set_x(true_width);
786            }
787            break;
788          }
789        }
790      }
791    }
792  }
793  void TabFind::MakeColumnWidths(int col_widths_size, STATS *col_widths) {
794    ICOORDELT_IT w_it(&column_widths_);
795    int total_col_count = col_widths->get_total();
796    while (col_widths->get_total() > 0) {
797      int width = col_widths->mode();
798      int col_count = col_widths->pile_count(width);
799      col_widths->add(width, -col_count);
800      for (int left = width - 1; left > 0 && col_widths->pile_count(left) > 0; --left) {
801        int new_count = col_widths->pile_count(left);
802        col_count += new_count;
803        col_widths->add(left, -new_count);
804      }
805      for (int right = width + 1; right < col_widths_size && col_widths->pile_count(right) > 0;
806           ++right) {
807        int new_count = col_widths->pile_count(right);
808        col_count += new_count;
809        col_widths->add(right, -new_count);
810      }
811      if (col_count > kMinLinesInColumn &&
812          col_count > kMinFractionalLinesInColumn * total_col_count) {
813        auto *w = new ICOORDELT(0, width);
814        w_it.add_after_then_move(w);
815        if (textord_debug_tabfind) {
816          tprintf("Column of width %d has %d = %.2f%% lines\n", width * kColumnWidthFactor, col_count,
817                  100.0 * col_count / total_col_count);
818        }
819      }
820    }
821  }
822  void TabFind::MarkVerticalText() {
823    if (textord_debug_tabfind) {
824      tprintf("Checking for vertical lines\n");
825    }
826    BlobGridSearch gsearch(this);
827    gsearch.StartFullSearch();
828    BLOBNBOX *blob = nullptr;
829    while ((blob = gsearch.NextFullSearch()) != nullptr) {
830      if (blob->region_type() < BRT_UNKNOWN) {
831        continue;
832      }
833      if (blob->UniquelyVertical()) {
834        blob->set_region_type(BRT_VERT_TEXT);
835      }
836    }
837  }
838  int TabFind::FindMedianGutterWidth(TabVector_LIST *lines) {
839    TabVector_IT it(lines);
840    int prev_right = -1;
841    int max_gap = static_cast<int>(kMaxGutterWidthAbsolute * resolution_);
842    STATS gaps(0, max_gap - 1);
843    STATS heights(0, max_gap - 1);
844    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
845      TabVector *v = it.data();
846      TabVector *partner = v->GetSinglePartner();
847      if (!v->IsLeftTab() || v->IsSeparator() || !partner) {
848        continue;
849      }
850      heights.add(partner->startpt().x() - v->startpt().x(), 1);
851      if (prev_right > 0 && v->startpt().x() > prev_right) {
852        gaps.add(v->startpt().x() - prev_right, 1);
853      }
854      prev_right = partner->startpt().x();
855    }
856    if (textord_debug_tabfind) {
857      tprintf("TabGutter total %d  median_gap %.2f  median_hgt %.2f\n", gaps.get_total(),
858              gaps.median(), heights.median());
859    }
860    if (gaps.get_total() < kMinLinesInColumn) {
861      return 0;
862    }
863    return static_cast<int>(gaps.median());
864  }
865  BLOBNBOX *TabFind::AdjacentBlob(const BLOBNBOX *bbox, bool look_left, bool ignore_images,
866                                  double min_overlap_fraction, int gap_limit, int top_y,
867                                  int bottom_y) {
868    GridSearch<BLOBNBOX, BLOBNBOX_CLIST, BLOBNBOX_C_IT> sidesearch(this);
869    const TBOX &box = bbox->bounding_box();
870    int left = box.left();
871    int right = box.right();
872    int mid_x = (left + right) / 2;
873    sidesearch.StartSideSearch(mid_x, bottom_y, top_y);
874    int best_gap = 0;
875    bool debug = WithinTestRegion(3, left, bottom_y);
876    BLOBNBOX *result = nullptr;
877    BLOBNBOX *neighbour = nullptr;
878    while ((neighbour = sidesearch.NextSideSearch(look_left)) != nullptr) {
879      if (debug) {
880        tprintf("Adjacent blob: considering box:");
881        neighbour->bounding_box().print();
882      }
883      if (neighbour == bbox || (ignore_images && neighbour->region_type() < BRT_UNKNOWN)) {
884        continue;
885      }
886      const TBOX &nbox = neighbour->bounding_box();
887      int n_top_y = nbox.top();
888      int n_bottom_y = nbox.bottom();
889      int v_overlap = std::min(n_top_y, top_y) - std::max(n_bottom_y, bottom_y);
890      int height = top_y - bottom_y;
891      int n_height = n_top_y - n_bottom_y;
892      if (v_overlap > min_overlap_fraction * std::min(height, n_height) &&
893          (min_overlap_fraction == 0.0 || !DifferentSizes(height, n_height))) {
894        int n_left = nbox.left();
895        int n_right = nbox.right();
896        int h_gap = std::max(n_left, left) - std::min(n_right, right);
897        int n_mid_x = (n_left + n_right) / 2;
898        if (look_left == (n_mid_x < mid_x) && n_mid_x != mid_x) {
899          if (h_gap > gap_limit) {
900            if (debug) {
901              tprintf("Giving up due to big gap = %d vs %d\n", h_gap, gap_limit);
902            }
903            return result;
904          }
905          if (h_gap > 0 && (look_left ? neighbour->right_tab_type() : neighbour->left_tab_type()) >=
906                               TT_CONFIRMED) {
907            if (debug) {
908              tprintf("Collision with like tab of type %d at %d,%d\n",
909                      look_left ? neighbour->right_tab_type() : neighbour->left_tab_type(), n_left,
910                      nbox.bottom());
911            }
912            return result;
913          }
914          if (result == nullptr || h_gap < best_gap) {
915            if (debug) {
916              tprintf("Good result\n");
917            }
918            result = neighbour;
919            best_gap = h_gap;
920          } else {
921            return result;
922          }
923        } else if (debug) {
924          tprintf("Wrong way\n");
925        }
926      } else if (debug) {
927        tprintf("Insufficient overlap\n");
928      }
929    }
930    if (WithinTestRegion(3, left, box.top())) {
931      tprintf("Giving up due to end of search\n");
932    }
933    return result; 
934  }
935  void TabFind::AddPartnerVector(BLOBNBOX *left_blob, BLOBNBOX *right_blob, TabVector *left,
936                                 TabVector *right) {
937    const TBOX &left_box = left_blob->bounding_box();
938    const TBOX &right_box = right_blob->bounding_box();
939    if (left->IsSeparator()) {
940      TabVector *v = LeftTabForBox(left_box, true, true);
941      if (v != nullptr && v != left && v->IsLeftTab() &&
942          v->XAtY(left_box.top()) > left->XAtY(left_box.top())) {
943        left = v; 
944        left->ExtendToBox(left_blob);
945      } else {
946        left = new TabVector(*left, TA_LEFT_RAGGED, vertical_skew_, left_blob);
947        vectors_.add_sorted(TabVector::SortVectorsByKey, left);
948        v_it_.move_to_first();
949      }
950    }
951    if (right->IsSeparator()) {
952      if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
953        tprintf("Box edge (%d,%d-%d)", right_box.right(), right_box.bottom(), right_box.top());
954        right->Print(" looking for improvement for");
955      }
956      TabVector *v = RightTabForBox(right_box, true, true);
957      if (v != nullptr && v != right && v->IsRightTab() &&
958          v->XAtY(right_box.top()) < right->XAtY(right_box.top())) {
959        right = v; 
960        right->ExtendToBox(right_blob);
961        if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
962          right->Print("Extended vector");
963        }
964      } else {
965        right = new TabVector(*right, TA_RIGHT_RAGGED, vertical_skew_, right_blob);
966        vectors_.add_sorted(TabVector::SortVectorsByKey, right);
967        v_it_.move_to_first();
968        if (WithinTestRegion(3, right_box.right(), right_box.bottom())) {
969          right->Print("Created new vector");
970        }
971      }
972    }
973    left->AddPartner(right);
974    right->AddPartner(left);
975  }
976  void TabFind::CleanupTabs() {
977    TabVector_IT it(&vectors_);
978    TabVector_IT dead_it(&dead_vectors_);
979    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
980      TabVector *v = it.data();
981      if (v->IsSeparator() || v->Partnerless()) {
982        dead_it.add_after_then_move(it.extract());
983        v_it_.set_to_list(&vectors_);
984      } else {
985        v->FitAndEvaluateIfNeeded(vertical_skew_, this);
986      }
987    }
988  }
989  void TabFind::RotateBlobList(const FCOORD &rotation, BLOBNBOX_LIST *blobs) {
990    BLOBNBOX_IT it(blobs);
991    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
992      it.data()->rotate_box(rotation);
993    }
994  }
995  bool TabFind::Deskew(TabVector_LIST *hlines, BLOBNBOX_LIST *image_blobs, TO_BLOCK *block,
996                       FCOORD *deskew, FCOORD *reskew) {
997    ComputeDeskewVectors(deskew, reskew);
998    if (deskew->x() < kCosMaxSkewAngle) {
999      return false;
1000    }
1001    RotateBlobList(*deskew, image_blobs);
1002    RotateBlobList(*deskew, &block->blobs);
1003    RotateBlobList(*deskew, &block->small_blobs);
1004    RotateBlobList(*deskew, &block->noise_blobs);
1005    TabVector_IT h_it(hlines);
1006    for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
1007      TabVector *h = h_it.data();
1008      h->Rotate(*deskew);
1009    }
1010    TabVector_IT d_it(&dead_vectors_);
1011    for (d_it.mark_cycle_pt(); !d_it.cycled_list(); d_it.forward()) {
1012      TabVector *d = d_it.data();
1013      d->Rotate(*deskew);
1014    }
1015    SetVerticalSkewAndParallelize(0, 1);
1016    TBOX grid_box(bleft_, tright_);
1017    grid_box.rotate_large(*deskew);
1018    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1019    InsertBlobsToGrid(false, false, image_blobs, this);
1020    InsertBlobsToGrid(true, false, &block->blobs, this);
1021    return true;
1022  }
1023  void TabFind::ResetForVerticalText(const FCOORD &rotate, const FCOORD &rerotate,
1024                                     TabVector_LIST *horizontal_lines, int *min_gutter_width) {
1025    TabVector_LIST ex_verticals;
1026    TabVector_IT ex_v_it(&ex_verticals);
1027    TabVector_LIST vlines;
1028    TabVector_IT v_it(&vlines);
1029    while (!v_it_.empty()) {
1030      TabVector *v = v_it_.extract();
1031      if (v->IsSeparator()) {
1032        v->Rotate(rotate);
1033        ex_v_it.add_after_then_move(v);
1034      } else {
1035        v_it.add_after_then_move(v);
1036      }
1037      v_it_.forward();
1038    }
1039    int median_gutter = FindMedianGutterWidth(&vlines);
1040    if (median_gutter > *min_gutter_width) {
1041      *min_gutter_width = median_gutter;
1042    }
1043    TabVector_IT h_it(horizontal_lines);
1044    for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
1045      TabVector *h = h_it.data();
1046      h->Rotate(rotate);
1047    }
1048    v_it_.add_list_after(horizontal_lines);
1049    v_it_.move_to_first();
1050    h_it.set_to_list(horizontal_lines);
1051    h_it.add_list_after(&ex_verticals);
1052    TBOX grid_box(bleft(), tright());
1053    grid_box.rotate_large(rotate);
1054    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1055  }
1056  void TabFind::Reset() {
1057    v_it_.move_to_first();
1058    for (v_it_.mark_cycle_pt(); !v_it_.cycled_list(); v_it_.forward()) {
1059      if (!v_it_.data()->IsSeparator()) {
1060        delete v_it_.extract();
1061      }
1062    }
1063    Clear();
1064  }
1065  void TabFind::ReflectInYAxis() {
1066    TabVector_LIST temp_list;
1067    TabVector_IT temp_it(&temp_list);
1068    v_it_.move_to_first();
1069    while (!v_it_.empty()) {
1070      TabVector *v = v_it_.extract();
1071      v_it_.forward();
1072      v->ReflectInYAxis();
1073      temp_it.add_before_then_move(v);
1074    }
1075    v_it_.add_list_after(&temp_list);
1076    v_it_.move_to_first();
1077    TBOX grid_box(bleft(), tright());
1078    int tmp = grid_box.left();
1079    grid_box.set_left(-grid_box.right());
1080    grid_box.set_right(-tmp);
1081    Init(gridsize(), grid_box.botleft(), grid_box.topright());
1082  }
1083  void TabFind::ComputeDeskewVectors(FCOORD *deskew, FCOORD *reskew) {
1084    double length = vertical_skew_ % vertical_skew_;
1085    length = sqrt(length);
1086    deskew->set_x(static_cast<float>(vertical_skew_.y() / length));
1087    deskew->set_y(static_cast<float>(vertical_skew_.x() / length));
1088    reskew->set_x(deskew->x());
1089    reskew->set_y(-deskew->y());
1090  }
1091  void TabFind::ApplyTabConstraints() {
1092    TabVector_IT it(&vectors_);
1093    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1094      TabVector *v = it.data();
1095      v->SetupConstraints();
1096    }
1097    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1098      TabVector *v = it.data();
1099      v->SetupPartnerConstraints();
1100    }
1101    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1102      TabVector *v = it.data();
1103      if (!v->IsRightTab()) {
1104        continue;
1105      }
1106      TabVector_IT partner_it(it);
1107      for (partner_it.forward(); !partner_it.at_first(); partner_it.forward()) {
1108        TabVector *partner = partner_it.data();
1109        if (!partner->IsLeftTab() || !v->VOverlap(*partner)) {
1110          continue;
1111        }
1112        v->SetupPartnerConstraints(partner);
1113      }
1114    }
1115    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1116      TabVector *v = it.data();
1117      if (!v->IsSeparator()) {
1118        v->ApplyConstraints();
1119      }
1120    }
1121  }
1122  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</h3>
            <pre><code>1  void TNEANet::LoadNetworkShM(TShMIn& ShMIn) {
2    MxNId = TInt(ShMIn);
3    MxEId = TInt(ShMIn);
4    LoadTNodeFunctor NodeFn;
5    NodeH.LoadShM(ShMIn, NodeFn);
6    EdgeH.LoadShM(ShMIn);
7    KeyToIndexTypeN.LoadShM(ShMIn);
8    KeyToIndexTypeE.LoadShM(ShMIn);
9    KeyToDenseN.LoadShM(ShMIn);
10    KeyToDenseE.LoadShM(ShMIn);
11    IntDefaultsN.LoadShM(ShMIn);
12    IntDefaultsE.LoadShM(ShMIn);
13    StrDefaultsN.LoadShM(ShMIn);
14    StrDefaultsE.LoadShM(ShMIn);
15    FltDefaultsE.LoadShM(ShMIn);
16    FltDefaultsE.LoadShM(ShMIn);
17    LoadVecFunctor vec_fn;
18    VecOfIntVecsN.LoadShM(ShMIn, vec_fn);
19    VecOfIntVecsE.LoadShM(ShMIn, vec_fn);
20    VecOfStrVecsN.Load(ShMIn);
21    VecOfStrVecsE.Load(ShMIn);
22    VecOfFltVecsN.Load(ShMIn);
23    VecOfFltVecsE.Load(ShMIn);
24    LoadVecOfVecFunctor vec_of_vec_fn;
25    VecOfIntVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
26    VecOfIntVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
27    VecOfFltVecVecsN.LoadShM(ShMIn, vec_of_vec_fn);
28    VecOfFltVecVecsE.LoadShM(ShMIn, vec_of_vec_fn);
29    LoadHashOfVecFunctor hash_of_vec_fn;
30    VecOfIntHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
31    VecOfIntHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
32    VecOfFltHashVecsN.LoadShM(ShMIn, hash_of_vec_fn);
33    VecOfFltHashVecsE.LoadShM(ShMIn, hash_of_vec_fn);
34    SAttrN.Load(ShMIn);
35    SAttrE.Load(ShMIn);
36  }
37  bool TNEANet::HasFlag(const TGraphFlag& Flag) const {
38    return HasGraphFlag(TNEANet::TNet, Flag);
39  }
40  bool TNEANet::TNodeI::IsInNId(const int& NId) const {
41    const TNode& Node = NodeHI.GetDat();
42    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
43      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
44        return true;
45    }
46    return false;
47  }
48  bool TNEANet::TNodeI::IsOutNId(const int& NId) const {
49    const TNode& Node = NodeHI.GetDat();
50    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
51      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
52        return true;
53    }
54    return false;
55  }
56  void TNEANet::AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
57    Names = TVec<TStr>();
58    while (!NodeHI.IsEnd()) {
59      if (!NodeAttrIsDeleted(NId, NodeHI)) {
60        Names.Add(NodeHI.GetKey());
61      }
62      NodeHI++;
63    }  
64  }
65  void TNEANet::AttrValueNI(const TInt& NId , TStrIntPrH::TIter NodeHI, TStrV& Values) const {
66    Values = TVec<TStr>();
67    while (!NodeHI.IsEnd()) {
68      if (!NodeAttrIsDeleted(NId, NodeHI)) {
69        Values.Add(GetNodeAttrValue(NId, NodeHI));
70      }
71      NodeHI++;
72    }
73  }
74  void TNEANet::IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
75    Names = TVec<TStr>();
76    while (!NodeHI.IsEnd()) {
77      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
78        Names.Add(NodeHI.GetKey());
79      }
80      NodeHI++;
81    }  
82  }
83  void TNEANet::IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const {
84    Values = TVec<TInt>();
85    while (!NodeHI.IsEnd()) {
86      if (NodeHI.GetDat().Val1 == IntType && !NodeAttrIsIntDeleted(NId, NodeHI)) {
87        TInt val = this->VecOfIntVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
88        Values.Add(val);
89      }
90      NodeHI++;
91    }  
92  }
93  void TNEANet::IntVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
94    Names = TVec<TStr>();
95    while (!NodeHI.IsEnd()) {
96      if (NodeHI.GetDat().Val1 == IntVType) {
97        Names.Add(NodeHI.GetKey());
98      }
99      NodeHI++;
100    }  
101  }
102  void TNEANet::IntVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TIntV>& Values) const {
103    Values = TVec<TIntV>();
104    while (!NodeHI.IsEnd()) {
105      if (NodeHI.GetDat().Val1 == IntVType) {
106        TInt index = NodeHI.GetDat().Val2;
107        TStr attr =  NodeHI.GetKey();
108        TInt loc = CheckDenseOrSparseN(attr);
109        if (loc == 1) {
110          TIntV val = this->VecOfIntVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
111          if (val.Len() != 0) Values.Add(val);
112        } else {
113          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[index];
114          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
115            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
116          }
117        }
118      }
119      NodeHI++;
120    }
121  }
122  void TNEANet::FltVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
123    Names = TVec<TStr>();
124    while (!NodeHI.IsEnd()) {
125      if (NodeHI.GetDat().Val1 == FltVType) {
126        Names.Add(NodeHI.GetKey());
127      }
128      NodeHI++;
129    }  
130  }
131  void TNEANet::FltVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TFltV>& Values) const {
132    Values = TVec<TFltV>();
133    while (!NodeHI.IsEnd()) {
134      if (NodeHI.GetDat().Val1 == FltVType) {
135        TInt index = NodeHI.GetDat().Val2;
136        TStr attr =  NodeHI.GetKey();
137        TInt loc = CheckDenseOrSparseN(attr);
138        if (loc == 1) {
139          TFltV val = this->VecOfFltVecVecsN.GetVal(index).GetVal(NodeH.GetKeyId(NId));
140          if (val.Len() != 0) Values.Add(val);
141        } else {
142          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[index];
143          if (NewHash.IsKey(NodeH.GetKeyId(NId))) {
144            Values.Add(NewHash[NodeH.GetKeyId(NId)]);
145          }
146        }
147      }
148      NodeHI++;
149    }
150  }
151  void TNEANet::StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
152    Names = TVec<TStr>();
153    while (!NodeHI.IsEnd()) {
154      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
155        Names.Add(NodeHI.GetKey());
156      }
157      NodeHI++;
158    }  
159  }
160  void TNEANet::StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const {
161    Values = TVec<TStr>();
162    while (!NodeHI.IsEnd()) {
163      if (NodeHI.GetDat().Val1 == StrType && !NodeAttrIsStrDeleted(NId, NodeHI)) {
164        TStr val = this->VecOfStrVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId));
165        Values.Add(val);
166      }
167      NodeHI++;
168    }  
169  }
170  void TNEANet::FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const {
171    Names = TVec<TStr>();
172    while (!NodeHI.IsEnd()) {
173      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
174        Names.Add(NodeHI.GetKey());
175      }
176      NodeHI++;
177    }  
178  }
179  void TNEANet::FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const {
180    Values = TVec<TFlt>();
181    while (!NodeHI.IsEnd()) {
182      if (NodeHI.GetDat().Val1 == FltType && !NodeAttrIsFltDeleted(NId, NodeHI)) {
183        TFlt val = (this->VecOfFltVecsN.GetVal(NodeHI.GetDat().Val2).GetVal(NodeH.GetKeyId(NId)));
184        Values.Add(val);
185      }
186      NodeHI++;
187    }  
188  }
189  bool TNEANet::IsAttrDeletedN(const int& NId, const TStr& attr) const {
190    bool IntDel = IsIntAttrDeletedN(NId, attr);
191    bool StrDel = IsStrAttrDeletedN(NId, attr);
192    bool FltDel = IsFltAttrDeletedN(NId, attr);
193    bool IntVDel = IsIntVAttrDeletedN(NId, attr);
194    bool FltVDel = IsFltVAttrDeletedN(NId, attr);
195    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
196  }
197  bool TNEANet::IsIntAttrDeletedN(const int& NId, const TStr& attr) const {
198    return NodeAttrIsIntDeleted(NId, KeyToIndexTypeN.GetI(attr));
199  }
200  bool TNEANet::IsIntVAttrDeletedN(const int& NId, const TStr& attr) const {
201    return NodeAttrIsIntVDeleted(NId, KeyToIndexTypeN.GetI(attr));
202  }
203  bool TNEANet::IsFltVAttrDeletedN(const int& NId, const TStr& attr) const {
204    return NodeAttrIsFltVDeleted(NId, KeyToIndexTypeN.GetI(attr));
205  }
206  bool TNEANet::IsStrAttrDeletedN(const int& NId, const TStr& attr) const {
207    return NodeAttrIsStrDeleted(NId, KeyToIndexTypeN.GetI(attr));
208  }
209  bool TNEANet::IsFltAttrDeletedN(const int& NId, const TStr& attr) const {
210    return NodeAttrIsFltDeleted(NId, KeyToIndexTypeN.GetI(attr));
211  }
212  bool TNEANet::NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
213    bool IntDel = NodeAttrIsIntDeleted(NId, NodeHI);
214    bool StrDel = NodeAttrIsStrDeleted(NId, NodeHI);
215    bool FltDel = NodeAttrIsFltDeleted(NId, NodeHI);
216    bool IntVDel = NodeAttrIsIntVDeleted(NId, NodeHI);
217    return IntDel || StrDel || FltDel || IntVDel;
218  }
219  bool TNEANet::NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
220    if (NodeHI.GetDat().Val1 != IntType) {
221      return false;
222    }
223    return (GetIntAttrDefaultN(NodeHI.GetKey()) == this->VecOfIntVecsN.GetVal(
224      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
225  }
226  bool TNEANet::NodeAttrIsIntVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
227    if (NodeHI.GetDat().Val1 != IntVType) {
228      return false;
229    }
230    return (TIntV() == this->VecOfIntVecVecsN.GetVal(
231      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
232  }
233  bool TNEANet::NodeAttrIsFltVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
234    if (NodeHI.GetDat().Val1 != FltVType) {
235      return false;
236    }
237    return (TFltV() == this->VecOfFltVecVecsN.GetVal(
238      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
239  }
240  bool TNEANet::NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
241    if (NodeHI.GetDat().Val1 != StrType) {
242      return false;
243    }
244    return (GetStrAttrDefaultN(NodeHI.GetKey()) == this->VecOfStrVecsN.GetVal(
245      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
246  }
247  bool TNEANet::NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
248    if (NodeHI.GetDat().Val1 != FltType) {
249      return false;
250    }
251    return (GetFltAttrDefaultN(NodeHI.GetKey()) == this->VecOfFltVecsN.GetVal(
252      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId)));
253  }
254  TStr TNEANet::GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const {
255    if (NodeHI.GetDat().Val1 == IntType) {
256      return (this->VecOfIntVecsN.GetVal(
257        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
258    } else if(NodeHI.GetDat().Val1 == StrType) {
259      return this->VecOfStrVecsN.GetVal(
260      this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId));
261    } else if (NodeHI.GetDat().Val1 == FltType) {
262      return (this->VecOfFltVecsN.GetVal(
263        this->KeyToIndexTypeN.GetDat(NodeHI.GetKey()).Val2).GetVal(NodeH.GetKeyId(NId))).GetStr();
264    }
265    return TStr::GetNullStr();
266  }
267  void TNEANet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
268    Names = TVec<TStr>();
269    while (!EdgeHI.IsEnd()) {
270      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
271        Names.Add(EdgeHI.GetKey());
272      }
273      EdgeHI++;
274    }  
275  }
276  void TNEANet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
277    Values = TVec<TStr>();
278    while (!EdgeHI.IsEnd()) {
279      if (!EdgeAttrIsDeleted(EId, EdgeHI)) {
280        Values.Add(GetEdgeAttrValue(EId, EdgeHI));
281      }
282      EdgeHI++;
283    }  
284  }
285  void TNEANet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
286    Names = TVec<TStr>();
287    while (!EdgeHI.IsEnd()) {
288      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
289        Names.Add(EdgeHI.GetKey());
290      }
291      EdgeHI++;
292    }  
293  }
294  void TNEANet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const {
295    Values = TVec<TInt>();
296    while (!EdgeHI.IsEnd()) {
297      if (EdgeHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, EdgeHI)) {
298        TInt val = (this->VecOfIntVecsE[EdgeHI.GetDat().Val2].GetVal(EdgeH.GetKeyId(EId)));
299        Values.Add(val);
300      }
301      EdgeHI++;
302    }  
303  }
304  void TNEANet::IntVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
305    Names = TVec<TStr>();
306    while (!EdgeHI.IsEnd()) {
307      if (EdgeHI.GetDat().Val1 == IntVType) {
308        Names.Add(EdgeHI.GetKey());
309      }
310      EdgeHI++;
311    }  
312  }
313  void TNEANet::IntVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TIntV>& Values) const {
314    Values = TVec<TIntV>();
315    while (!EdgeHI.IsEnd()) {
316      if (EdgeHI.GetDat().Val1 == IntVType) {
317        TInt index = EdgeHI.GetDat().Val2;
318        TStr attr =  EdgeHI.GetKey();
319        TInt loc = CheckDenseOrSparseE(attr);
320        if (loc == 1) {
321          TIntV val = this->VecOfIntVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
322          if (val.Len() != 0) Values.Add(val);
323        } else {
324          const THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[index];
325          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
326            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
327          }
328        }
329      }
330      EdgeHI++;
331    }
332  }
333  void TNEANet::FltVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
334    Names = TVec<TStr>();
335    while (!EdgeHI.IsEnd()) {
336      if (EdgeHI.GetDat().Val1 == FltVType) {
337        Names.Add(EdgeHI.GetKey());
338      }
339      EdgeHI++;
340    }  
341  }
342  void TNEANet::FltVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TFltV>& Values) const {
343    Values = TVec<TFltV>();
344    while (!EdgeHI.IsEnd()) {
345      if (EdgeHI.GetDat().Val1 == FltVType) {
346        TInt index = EdgeHI.GetDat().Val2;
347        TStr attr =  EdgeHI.GetKey();
348        TInt loc = CheckDenseOrSparseE(attr);
349        if (loc == 1) {
350          TFltV val = this->VecOfFltVecVecsE.GetVal(index).GetVal(EdgeH.GetKeyId(EId));
351          if (val.Len() != 0) Values.Add(val);
352        } else {
353          const THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[index];
354          if (NewHash.IsKey(EdgeH.GetKeyId(EId))) {
355            Values.Add(NewHash[EdgeH.GetKeyId(EId)]);
356          }
357        }
358      }
359      EdgeHI++;
360    }
361  }
362  void TNEANet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
363    Names = TVec<TStr>();
364    while (!EdgeHI.IsEnd()) {
365      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
366        Names.Add(EdgeHI.GetKey());
367      }
368      EdgeHI++;
369    }  
370  }
371  void TNEANet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const {
372    Values = TVec<TStr>();
373    while (!EdgeHI.IsEnd()) {
374      if (EdgeHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, EdgeHI)) {
375        TStr val = this->VecOfStrVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId);
376        Values.Add(val);
377      }
378      EdgeHI++;
379    }  
380  }
381  void TNEANet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const {
382    Names = TVec<TStr>();
383    while (!EdgeHI.IsEnd()) {
384      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
385        Names.Add(EdgeHI.GetKey());
386      }
387      EdgeHI++;
388    }  
389  }
390  void TNEANet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const {
391    Values = TVec<TFlt>();
392    while (!EdgeHI.IsEnd()) {
393      if (EdgeHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, EdgeHI)) {
394        TFlt val = (this->VecOfFltVecsE.GetVal(EdgeHI.GetDat().Val2).GetVal(EId));
395        Values.Add(val);
396      }
397      EdgeHI++;
398    }  
399  }
400  bool TNEANet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
401    bool IntDel = IsIntAttrDeletedE(EId, attr);
402    bool IntVDel = IsIntVAttrDeletedE(EId, attr);
403    bool StrDel = IsStrAttrDeletedE(EId, attr);
404    bool FltDel = IsFltAttrDeletedE(EId, attr);
405    bool FltVDel = IsFltVAttrDeletedE(EId, attr);
406    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
407  }
408  bool TNEANet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
409    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
410  }
411  bool TNEANet::IsIntVAttrDeletedE(const int& EId, const TStr& attr) const {
412    return EdgeAttrIsIntVDeleted(EId, KeyToIndexTypeE.GetI(attr));
413  }
414  bool TNEANet::IsFltVAttrDeletedE(const int& EId, const TStr& attr) const {
415    return EdgeAttrIsFltVDeleted(EId, KeyToIndexTypeE.GetI(attr));
416  }
417  bool TNEANet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
418    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
419  }
420  bool TNEANet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
421    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
422  }
423  bool TNEANet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
424    bool IntDel = EdgeAttrIsIntDeleted(EId, EdgeHI);
425    bool IntVDel = EdgeAttrIsIntVDeleted(EId, EdgeHI);
426    bool StrDel = EdgeAttrIsStrDeleted(EId, EdgeHI);
427    bool FltDel = EdgeAttrIsFltDeleted(EId, EdgeHI);
428    bool FltVDel = EdgeAttrIsFltVDeleted(EId, EdgeHI);
429    return IntDel || StrDel || FltDel || IntVDel || FltVDel;
430  }
431  bool TNEANet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
432    return (EdgeHI.GetDat().Val1 == IntType &&
433      GetIntAttrDefaultE(EdgeHI.GetKey()) == this->VecOfIntVecsE.GetVal(
434      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
435  }
436  bool TNEANet::EdgeAttrIsIntVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
437    return (EdgeHI.GetDat().Val1 == IntVType &&
438      TIntV() == this->VecOfIntVecVecsE.GetVal(
439      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
440  }
441  bool TNEANet::EdgeAttrIsFltVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
442    return (EdgeHI.GetDat().Val1 == FltVType &&
443      TFltV() == this->VecOfFltVecVecsE.GetVal(
444      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
445  }
446  bool TNEANet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
447    return (EdgeHI.GetDat().Val1 == StrType &&
448      GetStrAttrDefaultE(EdgeHI.GetKey()) == this->VecOfStrVecsE.GetVal(
449      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
450  }
451  bool TNEANet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
452    return (EdgeHI.GetDat().Val1 == FltType &&
453      GetFltAttrDefaultE(EdgeHI.GetKey()) == this->VecOfFltVecsE.GetVal(
454      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId)));
455  }
456  TStr TNEANet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const {
457    if (EdgeHI.GetDat().Val1 == IntType) {
458      return (this->VecOfIntVecsE.GetVal(
459        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
460    } else if(EdgeHI.GetDat().Val1 == StrType) {
461      return this->VecOfStrVecsE.GetVal(
462      this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId));
463    } else if (EdgeHI.GetDat().Val1 == FltType) {
464      return (this->VecOfFltVecsE.GetVal(
465        this->KeyToIndexTypeE.GetDat(EdgeHI.GetKey()).Val2).GetVal(EdgeH.GetKeyId(EId))).GetStr();
466    }
467    return TStr::GetNullStr();
468  }
469  int TNEANet::AddNode(int NId) {
470    if (NId == -1) {
471      NId = MxNId;  MxNId++;
472    } else {
473      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
474      MxNId = TMath::Mx(NId+1, MxNId());
475    }
476    NodeH.AddDat(NId, TNode(NId));
477    AddAttributes(NId);
478    return NId;
479  }
480  int TNEANet::AddNodeUnchecked(int NId) {
481    if (NId == -1) {
482      NId = MxNId;  MxNId++;
483    } else {
484      if (IsNode(NId)) { return -1;}
485      MxNId = TMath::Mx(NId+1, MxNId());
486    }
487    NodeH.AddDat(NId, TNode(NId));
488    AddAttributes(NId);
489    return NId;
490  }
491  int TNEANet::AddAttributes(const int NId) {
492    int i;
493    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
494      TVec<TInt>& IntVec = VecOfIntVecsN[i];
495      int KeyId = NodeH.GetKeyId(NId);
496      if (IntVec.Len() > KeyId) {
497        IntVec[KeyId] = TInt::Mn;
498      } else {
499        IntVec.Ins(KeyId, TInt::Mn);
500      }
501    }
502    TVec<TStr> DefIntVec = TVec<TStr>();
503    IntDefaultsN.GetKeyV(DefIntVec);
504    for (i = 0; i < DefIntVec.Len(); i++) {
505      TStr attr = DefIntVec[i];
506      TVec<TInt>& IntVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(DefIntVec[i]).Val2];
507      IntVec[NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
508    } 
509    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
510      TVec<TStr>& StrVec = VecOfStrVecsN[i];
511      int KeyId = NodeH.GetKeyId(NId);
512      if (StrVec.Len() > KeyId) {
513        StrVec[KeyId] = TStr::GetNullStr();
514      } else {
515        StrVec.Ins(KeyId, TStr::GetNullStr());
516      }
517    }
518    TVec<TStr> DefStrVec = TVec<TStr>();
519    StrDefaultsN.GetKeyV(DefStrVec);
520    for (i = 0; i < DefStrVec.Len(); i++) {
521      TStr attr = DefStrVec[i];
522      TVec<TStr>& StrVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(DefStrVec[i]).Val2];
523      StrVec[NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
524    }
525    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
526      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
527      int KeyId = NodeH.GetKeyId(NId);
528      if (FltVec.Len() > KeyId) {
529        FltVec[KeyId] = TFlt::Mn;
530      } else {
531        FltVec.Ins(KeyId, TFlt::Mn);
532      }
533    }
534    TVec<TStr> DefFltVec = TVec<TStr>();
535    FltDefaultsN.GetKeyV(DefFltVec);
536    for (i = 0; i < DefFltVec.Len(); i++) {
537      TStr attr = DefFltVec[i];
538      TVec<TFlt>& FltVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(DefFltVec[i]).Val2];
539      FltVec[NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
540    }
541    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
542      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
543      int KeyId = NodeH.GetKeyId(NId);
544      if (IntVecV.Len() > KeyId) {
545        IntVecV[KeyId] = TIntV();
546      } else {
547        IntVecV.Ins(KeyId, TIntV());
548      }
549    }
550    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
551      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
552      int KeyId = NodeH.GetKeyId(NId);
553      if (FltVecV.Len() > KeyId) {
554        FltVecV[KeyId] = TFltV();
555      } else {
556        FltVecV.Ins(KeyId, TFltV());
557      }
558    }
559    return NId;
560  }
561  void TNEANet::DelNode(const int& NId) {
562    int i;
563    TInt Id(NId);
564    SAttrN.DelSAttrId(Id);
565    const TNode& Node = GetNode(NId);
566    for (int out = 0; out < Node.GetOutDeg(); out++) {
567      const int EId = Node.GetOutEId(out);
568      const TEdge& Edge = GetEdge(EId);
569      IAssert(Edge.GetSrcNId() == NId);
570      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
571      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
572        TVec<TInt>& IntVec = VecOfIntVecsE[i];
573        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
574      }
575      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
576        TVec<TStr>& StrVec = VecOfStrVecsE[i];
577        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
578      }
579      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
580        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
581        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
582      }
583      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
584        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
585        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
586      }
587      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
588        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
589        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
590      }
591      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
592        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
593        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
594          IntHashV.DelKey(EdgeH.GetKeyId(EId));
595        }
596      }
597      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
598        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
599        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
600          FltHashV.DelKey(EdgeH.GetKeyId(EId));
601        }
602      }
603      EdgeH.DelKey(EId);
604    }
605    for (int in = 0; in < Node.GetInDeg(); in++) {
606      const int EId = Node.GetInEId(in);
607      const TEdge& Edge = GetEdge(EId);
608      IAssert(Edge.GetDstNId() == NId);
609      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
610      for (i = 0; i < VecOfIntVecsE.Len(); i++) {
611        TVec<TInt>& IntVec = VecOfIntVecsE[i];
612        IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
613      }
614      for (i = 0; i < VecOfStrVecsE.Len(); i++) {
615        TVec<TStr>& StrVec = VecOfStrVecsE[i];
616        StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
617      }
618      for (i = 0; i < VecOfFltVecsE.Len(); i++) {
619        TVec<TFlt>& FltVec = VecOfFltVecsE[i];
620        FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
621      }
622      for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
623        TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
624        IntVecV[EdgeH.GetKeyId(EId)] = TIntV();
625      }
626      for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
627        TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
628        FltVecV[EdgeH.GetKeyId(EId)] = TFltV();
629      }
630      for (i = 0; i < VecOfIntHashVecsE.Len(); i++) {
631        THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsE[i];
632        if (IntHashV.IsKey(EdgeH.GetKeyId(EId))) {
633          IntHashV.DelKey(EdgeH.GetKeyId(EId));
634        }
635      }
636      for (i = 0; i < VecOfFltHashVecsE.Len(); i++) {
637        THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsE[i];
638        if (FltHashV.IsKey(EdgeH.GetKeyId(EId))) {
639          FltHashV.DelKey(EdgeH.GetKeyId(EId));
640        }
641      }
642      EdgeH.DelKey(EId);
643    }
644    for (i = 0; i < VecOfIntVecsN.Len(); i++) {
645      TVec<TInt>& IntVec = VecOfIntVecsN[i];
646      IntVec[NodeH.GetKeyId(NId)] = TInt::Mn;
647    }
648    for (i = 0; i < VecOfStrVecsN.Len(); i++) {
649      TVec<TStr>& StrVec = VecOfStrVecsN[i];
650      StrVec[NodeH.GetKeyId(NId)] = TStr::GetNullStr();
651    }
652    for (i = 0; i < VecOfFltVecsN.Len(); i++) {
653      TVec<TFlt>& FltVec = VecOfFltVecsN[i];
654      FltVec[NodeH.GetKeyId(NId)] = TFlt::Mn;
655    }
656    for (i = 0; i < VecOfIntVecVecsN.Len(); i++) {
657      TVec<TIntV>& IntVecV = VecOfIntVecVecsN[i];
658      IntVecV[NodeH.GetKeyId(NId)] = TIntV();
659    }
660    for (i = 0; i < VecOfFltVecVecsN.Len(); i++) {
661      TVec<TFltV>& FltVecV = VecOfFltVecVecsN[i];
662      FltVecV[NodeH.GetKeyId(NId)] = TFltV();
663    }
664    for (i = 0; i < VecOfIntHashVecsN.Len(); i++) {
665      THash<TInt, TIntV>& IntHashV = VecOfIntHashVecsN[i];
666      if (IntHashV.IsKey(NodeH.GetKeyId(NId))) {
667        IntHashV.DelKey(NodeH.GetKeyId(NId));
668      }
669    }
670    for (i = 0; i < VecOfFltHashVecsN.Len(); i++) {
671      THash<TInt, TFltV>& FltHashV = VecOfFltHashVecsN[i];
672      if (FltHashV.IsKey(NodeH.GetKeyId(NId))) {
673        FltHashV.DelKey(NodeH.GetKeyId(NId));
674      }
675    }
676    NodeH.DelKey(NId);
677  }
678  int TNEANet::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
679    int i;
680    if (EId == -1) { EId = MxEId;  MxEId++; }
681    else { MxEId = TMath::Mx(EId+1, MxEId()); }
682    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
683    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
684    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
685    GetNode(SrcNId).OutEIdV.AddSorted(EId);
686    GetNode(DstNId).InEIdV.AddSorted(EId);
687    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
688      TVec<TInt>& IntVec = VecOfIntVecsE[i];
689      int KeyId = EdgeH.GetKeyId(EId);
690      if (IntVec.Len() > KeyId) {
691        IntVec[KeyId] = TInt::Mn;
692      } else {
693        IntVec.Ins(KeyId, TInt::Mn);
694      }
695    }
696    TVec<TStr> DefIntVec = TVec<TStr>();
697    IntDefaultsE.GetKeyV(DefIntVec);
698    for (i = 0; i < DefIntVec.Len(); i++) {
699      TStr attr = DefIntVec[i];
700      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
701      IntVec[EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
702    }
703    for (i = 0; i < VecOfIntVecVecsE.Len(); i++) {
704      TVec<TIntV>& IntVecV = VecOfIntVecVecsE[i];
705      IntVecV.Ins(EdgeH.GetKeyId(EId), TIntV());
706    }
707    for (i = 0; i < VecOfFltVecVecsE.Len(); i++) {
708      TVec<TFltV>& FltVecV = VecOfFltVecVecsE[i];
709      FltVecV.Ins(EdgeH.GetKeyId(EId), TFltV());
710    }
711    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
712      TVec<TStr>& StrVec = VecOfStrVecsE[i];
713      int KeyId = EdgeH.GetKeyId(EId);
714      if (StrVec.Len() > KeyId) {
715        StrVec[KeyId] = TStr::GetNullStr();
716      } else {
717        StrVec.Ins(KeyId, TStr::GetNullStr());
718      }
719    }
720    TVec<TStr> DefStrVec = TVec<TStr>();
721    StrDefaultsE.GetKeyV(DefStrVec);
722    for (i = 0; i < DefStrVec.Len(); i++) {
723      TStr attr = DefStrVec[i];
724      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
725      StrVec[EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
726    }
727    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
728      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
729      int KeyId = EdgeH.GetKeyId(EId);
730      if (FltVec.Len() > KeyId) {
731        FltVec[KeyId] = TFlt::Mn;
732      } else {
733        FltVec.Ins(KeyId, TFlt::Mn);
734      }
735    }
736    TVec<TStr> DefFltVec = TVec<TStr>();
737    FltDefaultsE.GetKeyV(DefFltVec);
738    for (i = 0; i < DefFltVec.Len(); i++) {
739      TStr attr = DefFltVec[i];
740      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
741      FltVec[EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
742    }
743    return EId;
744  }
745  void TNEANet::DelEdge(const int& EId) {
746    int i;
747    IAssert(IsEdge(EId));
748    const int SrcNId = GetEdge(EId).GetSrcNId();
749    const int DstNId = GetEdge(EId).GetDstNId();
750    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
751    GetNode(DstNId).InEIdV.DelIfIn(EId);
752    TInt Id(EId);
753    SAttrE.DelSAttrId(Id);
754    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
755      TVec<TInt>& IntVec = VecOfIntVecsE[i];
756      IntVec[EdgeH.GetKeyId(EId)] = TInt::Mn;
757    }
758    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
759      TVec<TStr>& StrVec = VecOfStrVecsE[i];
760      StrVec[EdgeH.GetKeyId(EId)] = TStr::GetNullStr();
761    }
762    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
763      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
764      FltVec[EdgeH.GetKeyId(EId)] = TFlt::Mn;
765    }
766    EdgeH.DelKey(EId);
767  }
768  void TNEANet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
769    int EId = 0;
770    bool Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
771    IAssert(Edge); 
772    while (Edge) {
773      DelEdge(EId);
774      Edge = IsEdge(SrcNId, DstNId, EId, IsDir);
775    }
776  }
777  bool TNEANet::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
778    if (! IsNode(SrcNId) || ! IsNode(DstNId)) {
779      return false;
780    }
781    const TNode& SrcNode = GetNode(SrcNId);
782    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
783      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
784      if (DstNId == Edge.GetDstNId()) {
785        EId = Edge.GetId();
786        return true;
787      }
788    }
789    if (! IsDir) {
790      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
791        const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
792        if (DstNId == Edge.GetSrcNId()) {
793          EId = Edge.GetId();
794          return true;
795        }
796      }
797    }
798    return false;
799  }
800  void TNEANet::GetNIdV(TIntV& NIdV) const {
801    NIdV.Gen(GetNodes(), 0);
802    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
803      NIdV.Add(NodeH.GetKey(N));
804    }
805  }
806  void TNEANet::GetEIdV(TIntV& EIdV) const {
807    EIdV.Gen(GetEdges(), 0);
808    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
809      EIdV.Add(EdgeH.GetKey(E));
810    }
811  }
812  void TNEANet::Defrag(const bool& OnlyNodeLinks) {
813    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
814      TNode& Node = NodeH[kid];
815      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
816    }
817    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
818    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
819  }
820  bool TNEANet::IsOk(const bool& ThrowExcept) const {
821    bool RetVal = true;
822    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
823      const TNode& Node = NodeH[N];
824      if (! Node.OutEIdV.IsSorted()) {
825        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
826        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
827      }
828      if (! Node.InEIdV.IsSorted()) {
829        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
830        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
831      }
832      int prevEId = -1;
833      for (int e = 0; e < Node.GetOutDeg(); e++) {
834        if (! IsEdge(Node.GetOutEId(e))) {
835          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
836          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
837        }
838        if (e > 0 && prevEId == Node.GetOutEId(e)) {
839          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
840          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
841        }
842        prevEId = Node.GetOutEId(e);
843      }
844      prevEId = -1;
845      for (int e = 0; e < Node.GetInDeg(); e++) {
846        if (! IsEdge(Node.GetInEId(e))) {
847        const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
848        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
849        }
850        if (e > 0 && prevEId == Node.GetInEId(e)) {
851          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
852          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
853        }
854        prevEId = Node.GetInEId(e);
855      }
856    }
857    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
858      const TEdge& Edge = EdgeH[E];
859      if (! IsNode(Edge.GetSrcNId())) {
860        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
861        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
862      }
863      if (! IsNode(Edge.GetDstNId())) {
864        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
865        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
866      }
867    }
868    return RetVal;
869  }
870  void TNEANet::Dump(FILE *OutF) const {
871    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
872    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
873    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Network with Attributes: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
874    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
875      fprintf(OutF, "  %*d:", NodePlaces, NodeI.GetId());
876      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
877      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
878        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
879      fprintf(OutF, "    out[%d]", NodeI.GetOutDeg());
880      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
881        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
882      TIntV IntAttrN;
883      IntAttrValueNI(NodeI.GetId(), IntAttrN);
884      fprintf(OutF, "    nai[%d]", IntAttrN.Len());
885      for (int i = 0; i < IntAttrN.Len(); i++) {
886        fprintf(OutF, " %*i", NodePlaces, IntAttrN[i]()); }
887      TStrV StrAttrN;
888      StrAttrValueNI(NodeI.GetId(), StrAttrN);
889      fprintf(OutF, "    nas[%d]", StrAttrN.Len());
890      for (int i = 0; i < StrAttrN.Len(); i++) {
891        fprintf(OutF, " %*s", NodePlaces, StrAttrN[i]()); }
892      TFltV FltAttrN;
893      FltAttrValueNI(NodeI.GetId(), FltAttrN);
894      fprintf(OutF, "    naf[%d]", FltAttrN.Len());
895      for (int i = 0; i < FltAttrN.Len(); i++) {
896        fprintf(OutF, " %*f", NodePlaces, FltAttrN[i]()); }
897      fprintf(OutF, "\n");
898    }
899    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
900      fprintf(OutF, "  %*d:  %*d  ->  %*d", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
901      TIntV IntAttrE;
902      IntAttrValueEI(EdgeI.GetId(), IntAttrE);
903      fprintf(OutF, "    eai[%d]", IntAttrE.Len());
904      for (int i = 0; i < IntAttrE.Len(); i++) {
905        fprintf(OutF, " %*i", EdgePlaces, IntAttrE[i]()); 
906      }
907      TStrV StrAttrE;
908      StrAttrValueEI(EdgeI.GetId(), StrAttrE);
909      fprintf(OutF, "    eas[%d]", StrAttrE.Len());
910      for (int i = 0; i < StrAttrE.Len(); i++) {
911        fprintf(OutF, " %*s", EdgePlaces, StrAttrE[i]()); 
912      }
913      TFltV FltAttrE;
914      FltAttrValueEI(EdgeI.GetId(), FltAttrE);
915      fprintf(OutF, "    eaf[%d]", FltAttrE.Len());
916      for (int i = 0; i < FltAttrE.Len(); i++) {
917        fprintf(OutF, " %*f", EdgePlaces, FltAttrE[i]()); 
918      }
919      fprintf(OutF, "\n");
920    }
921  }
922  int TNEANet::AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
923    int i;
924    TInt CurrLen;
925    if (!IsNode(NId)) {
926      return -1;
927    }
928    if (KeyToIndexTypeN.IsKey(attr)) {
929      TVec<TInt>& NewVec = VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
930      NewVec[NodeH.GetKeyId(NId)] = value;
931    } else {
932      CurrLen = VecOfIntVecsN.Len();
933      KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
934      TVec<TInt> NewVec = TVec<TInt>();
935      for (i = 0; i < MxNId; i++) {
936        NewVec.Ins(i, GetIntAttrDefaultN(attr));
937      }
938      NewVec[NodeH.GetKeyId(NId)] = value;
939      VecOfIntVecsN.Add(NewVec);
940    }
941    return 0;
942  }
943  int TNEANet::AddIntVAttrDatN(const int& NId, const TIntV& value, const TStr& attr, TBool UseDense) {
944    if (!IsNode(NId)) {
945      return -1;
946    }
947    TInt location = CheckDenseOrSparseN(attr);
948    if (location==-1) {
949      AddIntVAttrN(attr, UseDense);
950      location = CheckDenseOrSparseN(attr);
951    }
952    if (UseDense) {
953      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
954      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
955      NewVec[NodeH.GetKeyId(NId)] = value;
956    } else {
957      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
958      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
959      NewHash.AddDat(NodeH.GetKeyId(NId), value);
960    }
961    return 0;
962  } 
963  int TNEANet::AddFltVAttrDatN(const int& NId, const TFltV& value, const TStr& attr, TBool UseDense) {
964    if (!IsNode(NId)) {
965      return -1;
966    }
967    TInt location = CheckDenseOrSparseN(attr);
968    if (location==-1) {
969      AddFltVAttrN(attr, UseDense);
970      location = CheckDenseOrSparseN(attr);
971    }
972    if (UseDense) {
973      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
974      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
975      NewVec[NodeH.GetKeyId(NId)] = value;
976    } else {
977      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
978      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
979      NewHash.AddDat(NodeH.GetKeyId(NId), value);
980    }
981    return 0;
982  } 
983  int TNEANet::AppendIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr, TBool UseDense) {
984    if (!IsNode(NId)) {
985      return -1;
<span onclick='openModal()' class='match'>986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
994      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
</span>997      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
998      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
999      NewHash[NodeH.GetKeyId(NId)].Add(value);
1000    }
1001    return 0;
1002  } 
1003  int TNEANet::AppendFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr, TBool UseDense) {
1004    if (!IsNode(NId)) {
1005      return -1;
1006    }
1007    TInt location = CheckDenseOrSparseN(attr);
1008    if (location==-1) {
1009      AddFltVAttrN(attr, UseDense);
1010      location = CheckDenseOrSparseN(attr);
1011    }
1012    if (UseDense) {
1013      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
1014      TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1015      NewVec[NodeH.GetKeyId(NId)].Add(value);
1016    } else {
1017      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", NId, attr.CStr()));
1018      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1019      NewHash[NodeH.GetKeyId(NId)].Add(value);
1020    }
1021    return 0;
1022  } 
1023  int TNEANet::DelFromIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr) {
1024    TInt CurrLen;
1025    if (!IsNode(NId)) {
1026      return -1;
1027    }
1028    TInt location = CheckDenseOrSparseN(attr);
1029    if (location != -1) {
1030      if (location == 1) {
1031        TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1032        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1033          return -1;
1034        }
1035      } else {
1036        THash<TInt, TIntV>& NewHash = VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1037        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1038          return -1;
1039        }
1040      }
1041    } else {
1042      return -1;
1043    }
1044    return 0;
1045  } 
1046  int TNEANet::DelFromFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1047    TInt CurrLen;
1048    if (!IsNode(NId)) {
1049      return -1;
1050    }
1051    TInt location = CheckDenseOrSparseN(attr);
1052    if (location != -1) {
1053      if (location == 1) {
1054        TVec<TFltV>& NewVec = VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1055        if (!NewVec[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1056          return -1;
1057        }
1058      } else {
1059        THash<TInt, TFltV>& NewHash = VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1060        if (!NewHash[NodeH.GetKeyId(NId)].DelIfIn(value)) {
1061          return -1;
1062        }
1063      }
1064    } else {
1065      return -1;
1066    }
1067    return 0;
1068  }
1069  int TNEANet::AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr) {
1070    int i;
1071    TInt CurrLen;
1072    if (!IsNode(NId)) {
1073      return -1;
1074    }
1075    if (KeyToIndexTypeN.IsKey(attr)) {
1076      TVec<TStr>& NewVec = VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1077      NewVec[NodeH.GetKeyId(NId)] = value;
1078    } else {
1079      CurrLen = VecOfStrVecsN.Len();
1080      KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1081      TVec<TStr> NewVec = TVec<TStr>();
1082      for (i = 0; i < MxNId; i++) {
1083          NewVec.Ins(i, GetStrAttrDefaultN(attr));
1084      }
1085      NewVec[NodeH.GetKeyId(NId)] = value;
1086      VecOfStrVecsN.Add(NewVec);
1087    }
1088    return 0;
1089  } 
1090  int TNEANet::AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr) {
1091    int i;
1092    TInt CurrLen;
1093    if (!IsNode(NId)) {
1094      return -1;
1095    }
1096    if (KeyToIndexTypeN.IsKey(attr)) {
1097      TVec<TFlt>& NewVec = VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
1098      NewVec[NodeH.GetKeyId(NId)] = value;
1099    } else {
1100      CurrLen = VecOfFltVecsN.Len();
1101      KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1102      TVec<TFlt> NewVec = TVec<TFlt>();
1103      for (i = 0; i < MxNId; i++) {
1104        NewVec.Ins(i, GetFltAttrDefaultN(attr));
1105      }
1106      NewVec[NodeH.GetKeyId(NId)] = value;
1107      VecOfFltVecsN.Add(NewVec);
1108    }
1109    return 0;
1110  } 
1111  int TNEANet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
1112    int i;
1113    TInt CurrLen;
1114    if (!IsEdge(EId)) {
1115       return -1;
1116    }
1117    if (KeyToIndexTypeE.IsKey(attr)) {
1118      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1119      NewVec[EdgeH.GetKeyId(EId)] = value;
1120    } else {
1121      CurrLen = VecOfIntVecsE.Len();
1122      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1123      TVec<TInt> NewVec = TVec<TInt>();
1124      for (i = 0; i < MxEId; i++) {
1125        NewVec.Ins(i, GetIntAttrDefaultE(attr));
1126      }
1127      NewVec[EdgeH.GetKeyId(EId)] = value;
1128      VecOfIntVecsE.Add(NewVec);
1129    }
1130    return 0;
1131  }
1132  int TNEANet::AddIntVAttrDatE(const int& EId, const TIntV& value, const TStr& attr, TBool UseDense) {
1133    if (!IsEdge(EId)) {
1134      return -1;
1135    }
1136    TInt location = CheckDenseOrSparseE(attr);
1137    if (location==-1) {
1138      AddIntVAttrE(attr, UseDense);
1139      location = CheckDenseOrSparseE(attr);
1140    }
1141    if (UseDense) {
1142      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1143      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1144      NewVec[EdgeH.GetKeyId(EId)] = value;
1145    } else {
1146      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1147      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1148      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1149    }
1150    return 0;
1151  } 
1152  int TNEANet::AddFltVAttrDatE(const int& EId, const TFltV& value, const TStr& attr, TBool UseDense) {
1153    if (!IsEdge(EId)) {
1154      return -1;
1155    }
1156    TInt location = CheckDenseOrSparseE(attr);
1157    if (location==-1) {
1158      AddFltVAttrE(attr, UseDense);
1159      location = CheckDenseOrSparseE(attr);
1160    }
1161    if (UseDense) {
1162      IAssertR(location != 0, TStr::Fmt("EdgeID %d exists for %s in sparse representation", EId, attr.CStr()));
1163      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1164      NewVec[EdgeH.GetKeyId(EId)] = value;
1165    } else {
1166      IAssertR(location != 1, TStr::Fmt("NodeId %d exists for %s in dense representation", EId, attr.CStr()));
1167      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1168      NewHash.AddDat(EdgeH.GetKeyId(EId), value);
1169    }
1170    return 0;
1171  } 
1172  int TNEANet::AppendIntVAttrDatE(const int& EId, const TInt& value, const TStr& attr, TBool UseDense) {
1173    if (!IsEdge(EId)) {
1174      return -1;
1175    }
1176    TInt location = CheckDenseOrSparseE(attr);
1177    if (location==-1) return -1;
1178    if (UseDense) {
1179      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1180      TVec<TIntV>& NewVec = VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1181      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1182    } else {
1183      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1184      THash<TInt, TIntV>& NewHash = VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1185      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1186    }
1187    return 0;
1188  }
1189  int TNEANet::AppendFltVAttrDatE(const int& EId, const TFlt& value, const TStr& attr, TBool UseDense) {
1190    if (!IsEdge(EId)) {
1191      return -1;
1192    }
1193    TInt location = CheckDenseOrSparseE(attr);
1194    if (location==-1) return -1;
1195    if (UseDense) {
1196      IAssertR(location != 0, TStr::Fmt("Edge %d exists for %s in sparse representation", EId, attr.CStr()));
1197      TVec<TFltV>& NewVec = VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1198      NewVec[EdgeH.GetKeyId(EId)].Add(value);
1199    } else {
1200      IAssertR(location != 1, TStr::Fmt("Edge %d exists for %s in dense representation", EId, attr.CStr()));
1201      THash<TInt, TFltV>& NewHash = VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1202      NewHash[EdgeH.GetKeyId(EId)].Add(value);
1203    }
1204    return 0;
1205  }
1206  int TNEANet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
1207    int i;
1208    TInt CurrLen;
1209    if (!IsEdge(EId)) {
1210       return -1;
1211    }
1212    if (KeyToIndexTypeE.IsKey(attr)) {
1213      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1214      NewVec[EdgeH.GetKeyId(EId)] = value;
1215    } else {
1216      CurrLen = VecOfStrVecsE.Len();
1217      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1218      TVec<TStr> NewVec = TVec<TStr>();
1219      for (i = 0; i < MxEId; i++) {
1220        NewVec.Ins(i, GetStrAttrDefaultE(attr));
1221      }
1222      NewVec[EdgeH.GetKeyId(EId)] = value;
1223      VecOfStrVecsE.Add(NewVec);
1224    }
1225    return 0;
1226  } 
1227  int TNEANet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
1228    int i;
1229    TInt CurrLen;
1230    if (!IsEdge(EId)) {
1231       return -1;
1232    }
1233    if (KeyToIndexTypeE.IsKey(attr)) {
1234      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1235      NewVec[EdgeH.GetKeyId(EId)] = value;
1236    } else {
1237      CurrLen = VecOfFltVecsE.Len();
1238      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1239      TVec<TFlt> NewVec = TVec<TFlt>();
1240      for (i = 0; i < MxEId; i++) {
1241        NewVec.Ins(i, GetFltAttrDefaultE(attr));
1242      }
1243      NewVec[EdgeH.GetKeyId(EId)] = value;
1244      VecOfFltVecsE.Add(NewVec);
1245    }
1246    return 0;
1247  }
1248  TVec<TFlt>& TNEANet::GetFltAttrVecE(const TStr& attr) {
1249    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
1250  }
1251  int TNEANet::GetFltKeyIdE(const int& EId) {
1252    return EdgeH.GetKeyId(EId);
1253  }
1254  TInt TNEANet::GetIntAttrDatN(const int& NId, const TStr& attr) {
1255    return VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1256  }
1257  TIntV TNEANet::GetIntVAttrDatN(const int& NId, const TStr& attr) const {
1258    TInt location = CheckDenseOrSparseN(attr);
1259    if (location != 0) return VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1260    else return VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1261  }
1262  TFltV TNEANet::GetFltVAttrDatN(const int& NId, const TStr& attr) const {
1263    TInt location = CheckDenseOrSparseN(attr);
1264    if (location != 0) return VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1265    else return VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1266  }
1267  TStr TNEANet::GetStrAttrDatN(const int& NId, const TStr& attr) {
1268    return VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1269  }
1270  TFlt TNEANet::GetFltAttrDatN(const int& NId, const TStr& attr) {
1271    return VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)];
1272  }
1273  TInt TNEANet::GetIntAttrIndDatN(const int& NId, const int& index) {
1274    return VecOfIntVecsN[index][NodeH.GetKeyId(NId)];
1275  }
1276  TStr TNEANet::GetStrAttrIndDatN(const int& NId, const int& index) {
1277    return VecOfStrVecsN[index][NodeH.GetKeyId(NId)];
1278  }
1279  TFlt TNEANet::GetFltAttrIndDatN(const int& NId, const int& index) {
1280    return VecOfFltVecsN[index][NodeH.GetKeyId(NId)];
1281  }
1282  int TNEANet::GetIntAttrIndN(const TStr& attr) {
1283    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1284  }
1285  int TNEANet::GetAttrIndN(const TStr& attr) {
1286    return KeyToIndexTypeN.GetDat(attr).Val2.Val;
1287  }
1288  TInt TNEANet::GetIntAttrDatE(const int& EId, const TStr& attr) {
1289    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1290  }
1291  TIntV TNEANet::GetIntVAttrDatE(const int& EId, const TStr& attr) {
1292    TInt location = CheckDenseOrSparseE(attr);
1293    if (location != 0) return VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1294    else return VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1295  }
1296  TFltV TNEANet::GetFltVAttrDatE(const int& EId, const TStr& attr) {
1297    TInt location = CheckDenseOrSparseE(attr);
1298    if (location != 0) return VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1299    else return VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1300  }
1301  TStr TNEANet::GetStrAttrDatE(const int& EId, const TStr& attr) {
1302    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1303  }
1304  TFlt TNEANet::GetFltAttrDatE(const int& EId, const TStr& attr) {
1305    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)];
1306  }
1307  TInt TNEANet::GetIntAttrIndDatE(const int& EId, const int& index) {
1308    return VecOfIntVecsE[index][EdgeH.GetKeyId(EId)];
1309  }
1310  TStr TNEANet::GetStrAttrIndDatE(const int& EId, const int& index) {
1311    return VecOfStrVecsE[index][EdgeH.GetKeyId(EId)];
1312  }
1313  TFlt TNEANet::GetFltAttrIndDatE(const int& EId, const int& index) {
1314    return VecOfFltVecsE[index][EdgeH.GetKeyId(EId)];
1315  }
1316  int TNEANet::GetIntAttrIndE(const TStr& attr) {
1317    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1318  }
1319  int TNEANet::GetAttrIndE(const TStr& attr) {
1320    return KeyToIndexTypeE.GetDat(attr).Val2.Val;
1321  }
1322  int TNEANet::DelAttrDatN(const int& NId, const TStr& attr) {
1323    TInt vecType = KeyToIndexTypeN(attr).Val1;
1324    if (vecType == IntType) {
1325      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetIntAttrDefaultN(attr);
1326    } else if (vecType == StrType) {
1327      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetStrAttrDefaultN(attr);
1328    } else if (vecType == FltType) {
1329      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = GetFltAttrDefaultN(attr);
1330    } else if (vecType ==IntVType) {
1331      TInt location = CheckDenseOrSparseN(attr);
1332      if (location == 0) VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1333      else VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TIntV();
1334    } else if (vecType == FltVType) { 
1335      TInt location = CheckDenseOrSparseN(attr);
1336      if (location == 0) VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1337      else VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2][NodeH.GetKeyId(NId)] = TFltV();
1338    } else {
1339      return -1;
1340    }
1341    return 0;
1342  }
1343  int TNEANet::DelAttrDatE(const int& EId, const TStr& attr) {
1344    TInt vecType = KeyToIndexTypeE(attr).Val1;
1345    if (vecType == IntType) {
1346      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
1347    } else if (vecType == StrType) {
1348      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
1349    } else if (vecType == FltType) {
1350      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
1351    } else if (vecType == IntVType) {
1352      TInt location = CheckDenseOrSparseE(attr);
1353      if (location == 0) VecOfIntHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1354      else VecOfIntVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TIntV();
1355    } else if (vecType == FltVType) {
1356      TInt location = CheckDenseOrSparseE(attr);
1357      if (location == 0) VecOfFltHashVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1358      else VecOfFltVecVecsE[KeyToIndexTypeE.GetDat(attr).Val2][EdgeH.GetKeyId(EId)] = TFltV();
1359    } else {
1360      return -1;
1361    }
1362    return 0;
1363  }
1364  int TNEANet::AddIntAttrN(const TStr& attr, TInt defaultValue){
1365    int i;
1366    TInt CurrLen;
1367    TVec<TInt> NewVec;
1368    CurrLen = VecOfIntVecsN.Len();
1369    KeyToIndexTypeN.AddDat(attr, TIntPr(IntType, CurrLen));
1370    NewVec = TVec<TInt>();
1371    for (i = 0; i < MxNId; i++) {
1372      NewVec.Ins(i, defaultValue);
1373    }
1374    VecOfIntVecsN.Add(NewVec);
1375    if (!IntDefaultsN.IsKey(attr)) {
1376      IntDefaultsN.AddDat(attr, defaultValue);
1377    } else {
1378      return -1;
1379    }
1380    return 0;
1381  }
1382  int TNEANet::AddIntVAttrN(const TStr& attr, TBool UseDense){
1383    TInt CurrLen;
1384    if (UseDense) {
1385      CurrLen = VecOfIntVecVecsN.Len();
1386      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1387      KeyToDenseN.AddDat(attr, true);
1388      TVec<TIntV> NewVec = TVec<TIntV>(MxNId);
1389      VecOfIntVecVecsN.Add(NewVec);
1390    } else {
1391      CurrLen = VecOfIntHashVecsN.Len();
1392      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
1393      KeyToDenseN.AddDat(attr, false);
1394      THash<TInt, TIntV> NewHash;
1395      VecOfIntHashVecsN.Add(NewHash);
1396    }
1397    return 0;
1398  }
1399  int TNEANet::AddFltVAttrN(const TStr& attr, TBool UseDense){
1400    TInt CurrLen;
1401    if (UseDense) {
1402      CurrLen = VecOfFltVecVecsN.Len();
1403      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1404      KeyToDenseN.AddDat(attr, true);
1405      TVec<TFltV> NewVec = TVec<TFltV>(MxNId);
1406      VecOfFltVecVecsN.Add(NewVec);
1407    } else {
1408      CurrLen = VecOfFltHashVecsN.Len();
1409      KeyToIndexTypeN.AddDat(attr, TIntPr(FltVType, CurrLen));
1410      KeyToDenseN.AddDat(attr, false);
1411      THash<TInt, TFltV> NewHash;
1412      VecOfFltHashVecsN.Add(NewHash);
1413    }
1414    return 0;
1415  }
1416  int TNEANet::AddStrAttrN(const TStr& attr, TStr defaultValue) {
1417    int i;
1418    TInt CurrLen;
1419    TVec<TStr> NewVec;
1420    CurrLen = VecOfStrVecsN.Len();
1421    KeyToIndexTypeN.AddDat(attr, TIntPr(StrType, CurrLen));
1422    NewVec = TVec<TStr>();
1423    for (i = 0; i < MxNId; i++) {
1424      NewVec.Ins(i, defaultValue);
1425    }
1426    VecOfStrVecsN.Add(NewVec);
1427    if (!StrDefaultsN.IsKey(attr)) {
1428      StrDefaultsN.AddDat(attr, defaultValue);
1429    } else {
1430      return -1;
1431    }
1432    return 0;
1433  }
1434  int TNEANet::AddFltAttrN(const TStr& attr, TFlt defaultValue) {
1435    int i;
1436    TInt CurrLen;
1437    TVec<TFlt> NewVec;
1438    CurrLen = VecOfFltVecsN.Len();
1439    KeyToIndexTypeN.AddDat(attr, TIntPr(FltType, CurrLen));
1440    NewVec = TVec<TFlt>();
1441    for (i = 0; i < MxNId; i++) {
1442      NewVec.Ins(i, defaultValue);
1443    }
1444    VecOfFltVecsN.Add(NewVec);
1445    if (!FltDefaultsN.IsKey(attr)) {
1446      FltDefaultsN.AddDat(attr, defaultValue);
1447    } else {
1448      return -1;
1449    }
1450    return 0;
1451  }
1452  int TNEANet::AddIntAttrE(const TStr& attr, TInt defaultValue){
1453    int i;
1454    TInt CurrLen;
1455    TVec<TInt> NewVec;
1456    CurrLen = VecOfIntVecsE.Len();
1457    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
1458    NewVec = TVec<TInt>();
1459    for (i = 0; i < MxEId; i++) {
1460      NewVec.Ins(i, defaultValue);
1461    }
1462    VecOfIntVecsE.Add(NewVec);
1463    if (!IntDefaultsE.IsKey(attr)) {
1464      IntDefaultsE.AddDat(attr, defaultValue);
1465    } else {
1466      return -1;
1467    }
1468    return 0;
1469  }
1470  int TNEANet::AddIntVAttrE(const TStr& attr, TBool UseDense){
1471    TInt CurrLen;
1472    if (UseDense) {
1473      CurrLen = VecOfIntVecVecsE.Len();
1474      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1475      KeyToDenseE.AddDat(attr, true);
1476      TVec<TIntV> NewVec = TVec<TIntV>(MxEId);
1477      VecOfIntVecVecsE.Add(NewVec);
1478    } else {
1479      CurrLen = VecOfIntHashVecsE.Len();
1480      KeyToIndexTypeE.AddDat(attr, TIntPr(IntVType, CurrLen));
1481      KeyToDenseE.AddDat(attr, false);
1482      THash<TInt, TIntV> NewHash;
1483      VecOfIntHashVecsE.Add(NewHash);
1484    }
1485    return 0;
1486  }
1487  int TNEANet::AddFltVAttrE(const TStr& attr, TBool UseDense){
1488    TInt CurrLen;
1489    if (UseDense) {
1490      CurrLen = VecOfFltVecVecsE.Len();
1491      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1492      KeyToDenseE.AddDat(attr, true);
1493      TVec<TFltV> NewVec = TVec<TFltV>(MxEId);
1494      VecOfFltVecVecsE.Add(NewVec);
1495    } else {
1496      CurrLen = VecOfFltHashVecsE.Len();
1497      KeyToIndexTypeE.AddDat(attr, TIntPr(FltVType, CurrLen));
1498      KeyToDenseE.AddDat(attr, false);
1499      THash<TInt, TFltV> NewHash;
1500      VecOfFltHashVecsE.Add(NewHash);
1501    }
1502    return 0;
1503  }
1504  int TNEANet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
1505    int i;
1506    TInt CurrLen;
1507    TVec<TStr> NewVec;
1508    CurrLen = VecOfStrVecsE.Len();
1509    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
1510    NewVec = TVec<TStr>();
1511    for (i = 0; i < MxEId; i++) {
1512      NewVec.Ins(i, defaultValue);
1513    }
1514    VecOfStrVecsE.Add(NewVec);
1515    if (!StrDefaultsE.IsKey(attr)) {
1516      StrDefaultsE.AddDat(attr, defaultValue);
1517    } else {
1518      return -1;
1519    }
1520    return 0;
1521  }
1522  int TNEANet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
1523    int i;
1524    TInt CurrLen;
1525    TVec<TFlt> NewVec;
1526    CurrLen = VecOfFltVecsE.Len();
1527    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
1528    NewVec = TVec<TFlt>();
1529    for (i = 0; i < MxEId; i++) {
1530      NewVec.Ins(i, defaultValue);
1531    }
1532    VecOfFltVecsE.Add(NewVec);
1533    if (!FltDefaultsE.IsKey(attr)) {
1534      FltDefaultsE.AddDat(attr, defaultValue);
1535    } else {
1536      return -1;
1537    }
1538    return 0;
1539  }
1540  int TNEANet::DelAttrN(const TStr& attr) {
1541    TInt vecType = KeyToIndexTypeN(attr).Val1;
1542    if (vecType == IntType) {
1543      VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TInt>();
1544      if (IntDefaultsN.IsKey(attr)) {
1545        IntDefaultsN.DelKey(attr);
1546      }
1547    } else if (vecType == StrType) {
1548      VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TStr>();  
1549      if (StrDefaultsN.IsKey(attr)) {
1550        StrDefaultsN.DelKey(attr);
1551      }
1552    } else if (vecType == FltType) {
1553      VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFlt>();
1554      if (FltDefaultsN.IsKey(attr)) {
1555        FltDefaultsN.DelKey(attr);
1556      }
1557    } else if (vecType == IntVType) {
1558      TInt location = CheckDenseOrSparseN(attr);
1559      if (location == 1) VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TIntV>();
1560      else VecOfIntHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TIntV>();
1561      KeyToDenseN.DelKey(attr);
1562    } else if (vecType == FltVType) {
1563      TInt location = CheckDenseOrSparseN(attr);
1564      if (location == 1) VecOfFltVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = TVec<TFltV>();
1565      else VecOfFltHashVecsN[KeyToIndexTypeN.GetDat(attr).Val2] = THash<TInt, TFltV>();
1566      KeyToDenseN.DelKey(attr);
1567    } else {
1568      return -1;
1569    }
1570    KeyToIndexTypeN.DelKey(attr);
1571    return 0;
1572  }
1573  int TNEANet::DelAttrE(const TStr& attr) {
1574    TInt vecType = KeyToIndexTypeE(attr).Val1;
1575    if (vecType == IntType) {
1576      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
1577      if (IntDefaultsE.IsKey(attr)) {
1578        IntDefaultsE.DelKey(attr);
1579      }
1580    } else if (vecType == StrType) {
1581      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
1582      if (StrDefaultsE.IsKey(attr)) {
1583        StrDefaultsE.DelKey(attr);
1584      }  
1585    } else if (vecType == FltType) {
1586      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
1587      if (FltDefaultsE.IsKey(attr)) {
1588        FltDefaultsE.DelKey(attr);
1589      }
1590    } else {
1591      return -1;
1592    }
1593    KeyToIndexTypeE.DelKey(attr);
1594    return 0;
1595  }
1596  PNEANet TNEANet::GetSmallGraph() {
1597    PNEANet Net = TNEANet::New();
1598    for (int i = 0; i < 5; i++) { Net->AddNode(i); }
1599    Net->AddEdge(0,1);  Net->AddEdge(0,2);
1600    Net->AddEdge(0,3);  Net->AddEdge(0,4);
1601    Net->AddEdge(1,2);  Net->AddEdge(1,2);
1602    return Net;
1603  }
1604  void TNEANet::GetAttrNNames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1605    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
1606      if (it.GetDat().GetVal1() == IntType) {
1607        IntAttrNames.Add(it.GetKey());
1608      }
1609      if (it.GetDat().GetVal1() == FltType) {
1610        FltAttrNames.Add(it.GetKey());
1611      }
1612      if (it.GetDat().GetVal1() == StrType) {
1613        StrAttrNames.Add(it.GetKey());
1614      }
1615    }
1616  }
1617  void TNEANet::GetAttrENames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const {
1618    for (TStrIntPrH::TIter it = KeyToIndexTypeE.BegI(); it < KeyToIndexTypeE.EndI(); it++) {
1619      if (it.GetDat().GetVal1() == IntType) {
1620        IntAttrNames.Add(it.GetKey());
1621      }
1622      if (it.GetDat().GetVal1() == FltType) {
1623        FltAttrNames.Add(it.GetKey());
1624      }
1625      if (it.GetDat().GetVal1() == StrType) {
1626        StrAttrNames.Add(it.GetKey());
1627      }
1628    }
1629  }
1630  TFlt TNEANet::GetWeightOutEdges(const TNodeI& NI, const TStr& attr) {
1631    TNode Node = GetNode(NI.GetId());
1632    TIntV OutEIdV = Node.OutEIdV;
1633    TFlt total = 0;
1634    int len = Node.OutEIdV.Len();
1635    for (int i = 0; i < len; i++) {
1636      total += GetFltAttrDatE(Node.OutEIdV[i], attr);
1637    }
1638    return total;
1639  }
1640  void TNEANet::GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) {
1641    for (TEdgeI it = BegEI(); it < EndEI(); it++) {
1642      int EId = it.GetId();
1643      int SrcId = it.GetSrcNId();
1644      OutWeights[SrcId] +=AttrVal[GetFltKeyIdE(EId)];
1645    }
1646  }
1647  bool TNEANet::IsFltAttrE(const TStr& attr) {
1648    return (KeyToIndexTypeE.IsKey(attr) &&
1649      KeyToIndexTypeE.GetDat(attr).Val1 == FltType);
1650  }
1651  bool TNEANet::IsIntAttrE(const TStr& attr) {
1652    return (KeyToIndexTypeE.IsKey(attr) &&
1653      KeyToIndexTypeE.GetDat(attr).Val1 == IntType);
1654  }
1655  bool TNEANet::IsStrAttrE(const TStr& attr) {
1656    return (KeyToIndexTypeE.IsKey(attr) &&
1657      KeyToIndexTypeE.GetDat(attr).Val1 == StrType);
1658  }
1659  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
1660    if (!IsNode(NId)) {
1661      return -1;
1662    }
1663    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1664  }
1665  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
1666    if (!IsNode(NId)) {
1667      return -1;
1668    }
1669    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1670  }
1671  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
1672    if (!IsNode(NId)) {
1673      return -1;
1674    }
1675    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1676  }
1677  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
1678    if (!IsNode(NId)) {
1679      return -1;
1680    }
1681    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1682  }
1683  int TNEANet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
1684    if (!IsNode(NId)) {
1685      return -1;
1686    }
1687    return SAttrN.AddSAttrDat(NId, AttrName, Val);
1688  }
1689  int TNEANet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
1690    if (!IsNode(NId)) {
1691      return -1;
1692    }
1693    return SAttrN.AddSAttrDat(NId, AttrId, Val);
1694  }
1695  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
1696    if (!IsNode(NId)) {
1697      return -1;
1698    }
1699    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1700  }
1701  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
1702    if (!IsNode(NId)) {
1703      return -1;
1704    }
1705    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1706  }
1707  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
1708    if (!IsNode(NId)) {
1709      return -1;
1710    }
1711    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1712  }
1713  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
1714    if (!IsNode(NId)) {
1715      return -1;
1716    }
1717    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1718  }
1719  int TNEANet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
1720    if (!IsNode(NId)) {
1721      return -1;
1722    }
1723    return SAttrN.GetSAttrDat(NId, AttrName, Val);
1724  }
1725  int TNEANet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
1726    if (!IsNode(NId)) {
1727      return -1;
1728    }
1729    return SAttrN.GetSAttrDat(NId, AttrId, Val);
1730  }
1731  int TNEANet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
1732    if (!IsNode(NId)) {
1733      return -1;
1734    }
1735    return SAttrN.DelSAttrDat(NId, AttrName);
1736  }
1737  int TNEANet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
1738    if (!IsNode(NId)) {
1739      return -1;
1740    }
1741    return SAttrN.DelSAttrDat(NId, AttrId);
1742  }
1743  int TNEANet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1744    if (!IsNode(NId)) {
1745      return -1;
1746    }
1747    SAttrN.GetSAttrV(NId, AttrType, AttrV);
1748    return 0;
1749  }
1750  int TNEANet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
1751    return SAttrN.GetIdVSAttr(AttrName, IdV);
1752  }
1753  int TNEANet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
1754    return SAttrN.GetIdVSAttr(AttrId, IdV);
1755  }
1756  int TNEANet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1757    return SAttrN.AddSAttr(Name, AttrType, AttrId);
1758  }
1759  int TNEANet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1760    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
1761  }
1762  int TNEANet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1763    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
1764  }
1765  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TInt& Val) {
1766    if (!IsEdge(EId)) {
1767      return -1;
1768    }
1769    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1770  }
1771  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TInt& Val) {
1772    if (!IsEdge(EId)) {
1773      return -1;
1774    }
1775    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1776  }
1777  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TFlt& Val) {
1778    if (!IsEdge(EId)) {
1779      return -1;
1780    }
1781    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1782  }
1783  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TFlt& Val) {
1784    if (!IsEdge(EId)) {
1785      return -1;
1786    }
1787    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1788  }
1789  int TNEANet::AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TStr& Val) {
1790    if (!IsEdge(EId)) {
1791      return -1;
1792    }
1793    return SAttrE.AddSAttrDat(EId, AttrName, Val);
1794  }
1795  int TNEANet::AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TStr& Val) {
1796    if (!IsEdge(EId)) {
1797      return -1;
1798    }
1799    return SAttrE.AddSAttrDat(EId, AttrId, Val);
1800  }
1801  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TInt& Val) const {
1802    if (!IsEdge(EId)) {
1803      return -1;
1804    }
1805    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1806  }
1807  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TInt& Val) const {
1808    if (!IsEdge(EId)) {
1809      return -1;
1810    }
1811    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1812  }
1813  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TFlt& Val) const {
1814    if (!IsEdge(EId)) {
1815      return -1;
1816    }
1817    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1818  }
1819  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TFlt& Val) const {
1820    if (!IsEdge(EId)) {
1821      return -1;
1822    }
1823    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1824  }
1825  int TNEANet::GetSAttrDatE(const TInt& EId, const TStr& AttrName, TStr& Val) const {
1826    if (!IsEdge(EId)) {
1827      return -1;
1828    }
1829    return SAttrE.GetSAttrDat(EId, AttrName, Val);
1830  }
1831  int TNEANet::GetSAttrDatE(const TInt& EId, const TInt& AttrId, TStr& Val) const {
1832    if (!IsEdge(EId)) {
1833      return -1;
1834    }
1835    return SAttrE.GetSAttrDat(EId, AttrId, Val);
1836  }
1837  int TNEANet::DelSAttrDatE(const TInt& EId, const TStr& AttrName) {
1838    if (!IsEdge(EId)) {
1839      return -1;
1840    }
1841    return SAttrE.DelSAttrDat(EId, AttrName);
1842  }
1843  int TNEANet::DelSAttrDatE(const TInt& EId, const TInt& AttrId) {
1844    if (!IsEdge(EId)) {
1845      return -1;
1846    }
1847    return SAttrE.DelSAttrDat(EId, AttrId);
1848  }
1849  int TNEANet::GetSAttrVE(const TInt& EId, const TAttrType AttrType, TAttrPrV& AttrV) const {
1850    if (!IsEdge(EId)) {
1851      return -1;
1852    }
1853    SAttrE.GetSAttrV(EId, AttrType, AttrV);
1854    return 0;
1855  }
1856  int TNEANet::GetIdVSAttrE(const TStr& AttrName, TIntV& IdV) const {
1857    return SAttrE.GetIdVSAttr(AttrName, IdV);
1858  }
1859  int TNEANet::GetIdVSAttrE(const TInt& AttrId, TIntV& IdV) const {
1860    return SAttrE.GetIdVSAttr(AttrId, IdV);
1861  }
1862  int TNEANet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
1863    return SAttrE.AddSAttr(Name, AttrType, AttrId);
1864  }
1865  int TNEANet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
1866    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
1867  }
1868  int TNEANet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
1869    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
1870  }
1871  bool TUndirNet::HasFlag(const TGraphFlag& Flag) const {
1872    return HasGraphFlag(TUndirNet::TNet, Flag);
1873  }
1874  int TUndirNet::AddNode(int NId) {
1875    if (NId == -1) {
1876      NId = MxNId;  MxNId++;
1877    } else {
1878      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1879      MxNId = TMath::Mx(NId+1, MxNId());
1880    }
1881    NodeH.AddDat(NId, TNode(NId));
1882    return NId;
1883  }
1884  int TUndirNet::AddNodeUnchecked(int NId) {
1885    if (NId == -1) {
1886      NId = MxNId;  MxNId++;
1887    } else {
1888      if (IsNode(NId)) { return -1;}
1889      MxNId = TMath::Mx(NId+1, MxNId());
1890    }
1891    NodeH.AddDat(NId, TNode(NId));
1892    return NId;
1893  }
1894  int TUndirNet::AddNode(const int& NId, const TIntV& NbrNIdV) {
1895    int NewNId;
1896    if (NId == -1) {
1897      NewNId = MxNId;  MxNId++;
1898    } else {
1899      IAssertR(! IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1900      NewNId = NId;
1901      MxNId = TMath::Mx(NewNId+1, MxNId());
1902    }
1903    TNode& Node = NodeH.AddDat(NewNId);
1904    Node.Id = NewNId;
1905    Node.NIdV = NbrNIdV;
1906    Node.NIdV.Sort();
1907    NEdges += Node.GetDeg();
1908    for (int i = 0; i < NbrNIdV.Len(); i++) {
1909      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
1910    }
1911    return NewNId;
1912  }
1913  int TUndirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId) {
1914    int NewNId;
1915    if (NId == -1) {
1916      NewNId = MxNId;  MxNId++;
1917    } else {
1918      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1919      NewNId = NId;
1920      MxNId = TMath::Mx(NewNId+1, MxNId()); 
1921    }
1922    TNode& Node = NodeH.AddDat(NewNId);
1923    Node.Id = NewNId;
1924    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
1925    Node.NIdV.Sort();
1926    NEdges += Node.GetDeg();
1927    return NewNId;
1928  }
1929  void TUndirNet::DelNode(const int& NId) {
1930    { AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
1931    TInt Id(NId);
1932    SAttrN.DelSAttrId(Id);
1933    TNode& Node = GetNode(NId);
1934    NEdges -= Node.GetDeg();
1935    for (int e = 0; e < Node.GetDeg(); e++) {
1936      const int nbr = Node.GetNbrNId(e);
1937      if (nbr == NId) { continue; }
1938      TNode& N = GetNode(nbr);
1939      const int n = N.NIdV.SearchBin(NId);
1940      IAssert(n != -1); 
1941      if (n!= -1) { N.NIdV.Del(n); }
1942    } }
1943    NodeH.DelKey(NId);
1944  }
1945  int TUndirNet::GetEdges() const {
1946    return NEdges;
1947  }
1948  int TUndirNet::AddEdge(const int& SrcNId, const int& DstNId) {
1949    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1950    if (IsEdge(SrcNId, DstNId)) { return -2; } 
1951    GetNode(SrcNId).NIdV.AddSorted(DstNId);
1952    if (SrcNId!=DstNId) { 
1953      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
1954    NEdges++;
1955    return -1; 
1956  }
1957  int TUndirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
1958    GetNode(SrcNId).NIdV.Add(DstNId);
1959    if (SrcNId!=DstNId) { 
1960      GetNode(DstNId).NIdV.Add(SrcNId); }
1961    NEdges++;
1962    return -1; 
1963  }
1964  void TUndirNet::DelEdge(const int& SrcNId, const int& DstNId) {
1965    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1966    { TNode& N = GetNode(SrcNId);
1967    const int n = N.NIdV.SearchBin(DstNId);
1968    TIntPr Id(SrcNId, DstNId);
1969    SAttrE.DelSAttrId(Id);
1970    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
1971    if (SrcNId != DstNId) { 
1972      TNode& N = GetNode(DstNId);
1973      const int n = N.NIdV.SearchBin(SrcNId);
1974      if (n!= -1) { N.NIdV.Del(n); }
1975    }
1976  }
1977  bool TUndirNet::IsEdge(const int& SrcNId, const int& DstNId) const {
1978    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
1979    return GetNode(SrcNId).IsNbrNId(DstNId);
1980  }
1981  TUndirNet::TEdgeI TUndirNet::GetEI(const int& SrcNId, const int& DstNId) const {
1982    const int MnNId = TMath::Mn(SrcNId, DstNId);
1983    const int MxNId = TMath::Mx(SrcNId, DstNId);
1984    const TNodeI SrcNI = GetNI(MnNId);
1985    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
1986    IAssert(NodeN != -1);
1987    return TEdgeI(SrcNI, EndNI(), NodeN);
1988  }
1989  void TUndirNet::GetNIdV(TIntV& NIdV) const {
1990    NIdV.Gen(GetNodes(), 0);
1991    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1992      NIdV.Add(NodeH.GetKey(N)); }
1993  }
1994  void TUndirNet::Defrag(const bool& OnlyNodeLinks) {
1995    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
1996      NodeH[n].NIdV.Pack();
1997    }
1998    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
1999      NodeH.Defrag();
2000    }
2001  }
2002  bool TUndirNet::IsOk(const bool& ThrowExcept) const {
2003    bool RetVal = true;
2004    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2005      const TNode& Node = NodeH[N];
2006      if (! Node.NIdV.IsSorted()) {
2007        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", Node.GetId());
2008        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2009        RetVal=false;
2010      }
2011      int prevNId = -1;
2012      for (int e = 0; e < Node.GetDeg(); e++) {
2013        if (! IsNode(Node.GetNbrNId(e))) {
2014          const TStr Msg = TStr::Fmt("Edge %d --> %d: node %d does not exist.",
2015            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
2016          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2017          RetVal=false;
2018        }
2019        if (e > 0 && prevNId == Node.GetNbrNId(e)) {
2020          const TStr Msg = TStr::Fmt("Node %d has duplicate edge %d --> %d.",
2021            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
2022          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2023          RetVal=false;
2024        }
2025        prevNId = Node.GetNbrNId(e);
2026      }
2027    }
2028    int EdgeCnt = 0;
2029    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) { EdgeCnt++; }
2030    if (EdgeCnt != GetEdges()) {
2031      const TStr Msg = TStr::Fmt("Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.", GetEdges(), EdgeCnt);
2032      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
2033      RetVal=false;
2034    }
2035    return RetVal;
2036  }
2037  void TUndirNet::Dump(FILE *OutF) const {
2038    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2039    fprintf(OutF, "-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2040    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2041      const TNode& Node = NodeH[N];
2042      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
2043      for (int edge = 0; edge < Node.GetDeg(); edge++) {
2044        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
2045      fprintf(OutF, "\n");
2046    }
2047    fprintf(OutF, "\n");
2048  }
2049  PUndirNet TUndirNet::GetSmallGraph() {
2050    PUndirNet Graph = TUndirNet::New();
2051    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
2052    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
2053    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
2054    Graph->AddEdge(1,2);
2055    return Graph;
2056  }
2057  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2058    if (!IsNode(NId)) {
2059      return -1;
2060    }
2061    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2062  }
2063  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2064    if (!IsNode(NId)) {
2065      return -1;
2066    }
2067    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2068  }
2069  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2070    if (!IsNode(NId)) {
2071      return -1;
2072    }
2073    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2074  }
2075  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2076    if (!IsNode(NId)) {
2077      return -1;
2078    }
2079    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2080  }
2081  int TUndirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2082    if (!IsNode(NId)) {
2083      return -1;
2084    }
2085    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2086  }
2087  int TUndirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2088    if (!IsNode(NId)) {
2089      return -1;
2090    }
2091    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2092  }
2093  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2094    if (!IsNode(NId)) {
2095      return -1;
2096    }
2097    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2098  }
2099  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2100    if (!IsNode(NId)) {
2101      return -1;
2102    }
2103    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2104  }
2105  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2106    if (!IsNode(NId)) {
2107      return -1;
2108    }
2109    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2110  }
2111  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2112    if (!IsNode(NId)) {
2113      return -1;
2114    }
2115    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2116  }
2117  int TUndirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2118    if (!IsNode(NId)) {
2119      return -1;
2120    }
2121    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2122  }
2123  int TUndirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2124    if (!IsNode(NId)) {
2125      return -1;
2126    }
2127    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2128  }
2129  int TUndirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2130    if (!IsNode(NId)) {
2131      return -1;
2132    }
2133    return SAttrN.DelSAttrDat(NId, AttrName);
2134  }
2135  int TUndirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2136    if (!IsNode(NId)) {
2137      return -1;
2138    }
2139    return SAttrN.DelSAttrDat(NId, AttrId);
2140  }
2141  int TUndirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2142    if (!IsNode(NId)) {
2143      return -1;
2144    }
2145    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2146    return 0;
2147  }
2148  int TUndirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2149    return SAttrN.GetIdVSAttr(AttrName, IdV);
2150  }
2151  int TUndirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2152    return SAttrN.GetIdVSAttr(AttrId, IdV);
2153  }
2154  int TUndirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2155    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2156  }
2157  int TUndirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2158    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2159  }
2160  int TUndirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2161    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2162  }
2163  TIntPr TUndirNet::OrderEdgeNodes(const int& SrcNId, const int& DstNId) const{
2164    if (SrcNId < DstNId) {
2165      return TIntPr(SrcNId, DstNId);
2166    }
2167    return TIntPr(DstNId, SrcNId);
2168  }
2169  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2170    if (!IsEdge(SrcNId, DstNId)) {
2171      return -1;
2172    }
2173    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2174    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2175  }
2176  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2177    if (!IsEdge(SrcNId, DstNId)) {
2178      return -1;
2179    }
2180    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2181    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2182  }
2183  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2184    if (!IsEdge(SrcNId, DstNId)) {
2185      return -1;
2186    }
2187    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2188    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2189  }
2190  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2191    if (!IsEdge(SrcNId, DstNId)) {
2192      return -1;
2193    }
2194    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2195    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2196  }
2197  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2198    if (!IsEdge(SrcNId, DstNId)) {
2199      return -1;
2200    }
2201    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2202    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2203  }
2204  int TUndirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2205    if (!IsEdge(SrcNId, DstNId)) {
2206      return -1;
2207    }
2208    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2209    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2210  }
2211  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2212    if (!IsEdge(SrcNId, DstNId)) {
2213      return -1;
2214    }
2215    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2216    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2217  }
2218  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2219    if (!IsEdge(SrcNId, DstNId)) {
2220      return -1;
2221    }
2222    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2223    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2224  }
2225  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2226    if (!IsEdge(SrcNId, DstNId)) {
2227      return -1;
2228    }
2229    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2230    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2231  }
2232  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2233    if (!IsEdge(SrcNId, DstNId)) {
2234      return -1;
2235    }
2236    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2237    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2238  }
2239  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2240    if (!IsEdge(SrcNId, DstNId)) {
2241      return -1;
2242    }
2243    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2244    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2245  }
2246  int TUndirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2247    if (!IsEdge(SrcNId, DstNId)) {
2248      return -1;
2249    }
2250    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2251    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2252  }
2253  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2254    if (!IsEdge(SrcNId, DstNId)) {
2255      return -1;
2256    }
2257    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2258    return SAttrE.DelSAttrDat(EId, AttrName);
2259  }
2260  int TUndirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2261    if (!IsEdge(SrcNId, DstNId)) {
2262      return -1;
2263    }
2264    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2265    return SAttrE.DelSAttrDat(EId, AttrId);
2266  }
2267  int TUndirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2268    if (!IsEdge(SrcNId, DstNId)) {
2269      return -1;
2270    }
2271    TIntPr EId = OrderEdgeNodes(SrcNId, DstNId);
2272    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2273    return 0;
2274  }
2275  int TUndirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2276    return SAttrE.GetIdVSAttr(AttrName, IdV);
2277  }
2278  int TUndirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2279    return SAttrE.GetIdVSAttr(AttrId, IdV);
2280  }
2281  int TUndirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2282    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2283  }
2284  int TUndirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2285    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2286  }
2287  int TUndirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2288    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2289  }
2290  bool TDirNet::HasFlag(const TGraphFlag& Flag) const {
2291    return HasGraphFlag(TDirNet::TNet, Flag);
2292  }
2293  int TDirNet::AddNode(int NId) {
2294    if (NId == -1) {
2295      NId = MxNId;  MxNId++;
2296    } else {
2297      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2298      MxNId = TMath::Mx(NId+1, MxNId());
2299    }
2300    NodeH.AddDat(NId, TNode(NId));
2301    return NId;
2302  }
2303  int TDirNet::AddNodeUnchecked(int NId) {
2304    if (NId == -1) {
2305      NId = MxNId;  MxNId++;
2306    } else {
2307      if (IsNode(NId)) { return -1;}
2308      MxNId = TMath::Mx(NId+1, MxNId());
2309    }
2310    NodeH.AddDat(NId, TNode(NId));
2311    return NId;
2312  }
2313  int TDirNet::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
2314    int NewNId;
2315    if (NId == -1) {
2316      NewNId = MxNId;  MxNId++;
2317    } else {
2318      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2319      NewNId = NId;
2320      MxNId = TMath::Mx(NewNId+1, MxNId());
2321    }
2322    TNode& Node = NodeH.AddDat(NewNId);
2323    Node.Id = NewNId;
2324    Node.InNIdV = InNIdV;
2325    Node.OutNIdV = OutNIdV;
2326    Node.InNIdV.Sort();
2327    Node.OutNIdV.Sort();
2328    return NewNId;
2329  }
2330  int TDirNet::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
2331    int NewNId;
2332    if (NId == -1) {
2333      NewNId = MxNId;  MxNId++;
2334    } else {
2335      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
2336      NewNId = NId;
2337      MxNId = TMath::Mx(NewNId+1, MxNId());
2338    }
2339    TNode& Node = NodeH.AddDat(NewNId);
2340    Node.Id = NewNId;
2341    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
2342    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
2343    Node.InNIdV.Sort();
2344    Node.OutNIdV.Sort();
2345    return NewNId;
2346  }
2347  void TDirNet::DelNode(const int& NId) {
2348    { TNode& Node = GetNode(NId);
2349    TInt Id(NId);
2350    SAttrN.DelSAttrId(Id);
2351    for (int e = 0; e < Node.GetOutDeg(); e++) {
2352    const int nbr = Node.GetOutNId(e);
2353    if (nbr == NId) { continue; }
2354      TNode& N = GetNode(nbr);
2355      const int n = N.InNIdV.SearchBin(NId);
2356      if (n!= -1) { N.InNIdV.Del(n); }
2357    }
2358    for (int e = 0; e < Node.GetInDeg(); e++) {
2359    const int nbr = Node.GetInNId(e);
2360    if (nbr == NId) { continue; }
2361      TNode& N = GetNode(nbr);
2362      const int n = N.OutNIdV.SearchBin(NId);
2363      if (n!= -1) { N.OutNIdV.Del(n); }
2364    } }
2365    NodeH.DelKey(NId);
2366  }
2367  int TDirNet::GetEdges() const {
2368    int edges=0;
2369    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2370      edges+=NodeH[N].GetOutDeg();
2371    }
2372    return edges;
2373  }
2374  int TDirNet::AddEdge(const int& SrcNId, const int& DstNId) {
2375    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2376    if (IsEdge(SrcNId, DstNId)) { return -2; }
2377    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
2378    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
2379    return -1; 
2380  }
2381  int TDirNet::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
2382    GetNode(SrcNId).OutNIdV.Add(DstNId);
2383    GetNode(DstNId).InNIdV.Add(SrcNId);
2384    return -1; 
2385  }
2386  void TDirNet::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
2387    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
2388    { TNode& N = GetNode(SrcNId);
2389    TIntPr Id(SrcNId, DstNId);
2390    SAttrE.DelSAttrId(Id);
2391    const int n = N.OutNIdV.SearchBin(DstNId);
2392    if (n!= -1) { N.OutNIdV.Del(n); } }
2393    { TNode& N = GetNode(DstNId);
2394    const int n = N.InNIdV.SearchBin(SrcNId);
2395    if (n!= -1) { N.InNIdV.Del(n); } }
2396    if (! IsDir) {
2397      { TNode& N = GetNode(SrcNId);
2398      const int n = N.InNIdV.SearchBin(DstNId);
2399      if (n!= -1) { N.InNIdV.Del(n); } }
2400      { TNode& N = GetNode(DstNId);
2401      const int n = N.OutNIdV.SearchBin(SrcNId);
2402      if (n!= -1) { N.OutNIdV.Del(n); } }
2403    }
2404  }
2405  bool TDirNet::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
2406    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
2407    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
2408    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
2409  }
2410  TDirNet::TEdgeI TDirNet::GetEI(const int& SrcNId, const int& DstNId) const {
2411    const TNodeI SrcNI = GetNI(SrcNId);
2412    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
2413    IAssert(NodeN != -1);
2414    return TEdgeI(SrcNI, EndNI(), NodeN);
2415  }
2416  void TDirNet::GetNIdV(TIntV& NIdV) const {
2417    NIdV.Gen(GetNodes(), 0);
2418    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2419      NIdV.Add(NodeH.GetKey(N)); }
2420  }
2421  void TDirNet::Defrag(const bool& OnlyNodeLinks) {
2422    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
2423      TNode& Node = NodeH[n];
2424      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
2425    }
2426    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
2427  }
2428  bool TDirNet::IsOk(const bool& ThrowExcept) const {
2429    bool RetVal = true;
2430    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2431      const TNode& Node = NodeH[N];
2432      if (! Node.OutNIdV.IsSorted()) {
2433        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
2434        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2435      }
2436      if (! Node.InNIdV.IsSorted()) {
2437        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
2438        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2439      }
2440      int prevNId = -1;
2441      for (int e = 0; e < Node.GetOutDeg(); e++) {
2442        if (! IsNode(Node.GetOutNId(e))) {
2443          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
2444            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
2445          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2446        }
2447        if (e > 0 && prevNId == Node.GetOutNId(e)) {
2448          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
2449            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
2450          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2451        }
2452        prevNId = Node.GetOutNId(e);
2453      }
2454      prevNId = -1;
2455      for (int e = 0; e < Node.GetInDeg(); e++) {
2456        if (! IsNode(Node.GetInNId(e))) {
2457          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
2458            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
2459          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2460        }
2461        if (e > 0 && prevNId == Node.GetInNId(e)) {
2462          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
2463            Node.GetId(), Node.GetId(), Node.GetInNId(e));
2464          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
2465        }
2466        prevNId = Node.GetInNId(e);
2467      }
2468    }
2469    return RetVal;
2470  }
2471  void TDirNet::Dump(FILE *OutF) const {
2472    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
2473    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
2474    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
2475      const TNode& Node = NodeH[N];
2476      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
2477      fprintf(OutF, "    in [%d]", Node.GetInDeg());
2478      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
2479        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
2480      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
2481      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
2482        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
2483      fprintf(OutF, "\n");
2484    }
2485    fprintf(OutF, "\n");
2486  }
2487  PDirNet TDirNet::GetSmallGraph() {
2488    PDirNet G = TDirNet::New();
2489    for (int i = 0; i < 5; i++) { G->AddNode(i); }
2490    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
2491    G->AddEdge(1,3); G->AddEdge(3,4); G->AddEdge(2,3);
2492    return G;
2493  }
2494  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val) {
2495    if (!IsNode(NId)) {
2496      return -1;
2497    }
2498    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2499  }
2500  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val) {
2501    if (!IsNode(NId)) {
2502      return -1;
2503    }
2504    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2505  }
2506  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val) {
2507    if (!IsNode(NId)) {
2508      return -1;
2509    }
2510    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2511  }
2512  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val) {
2513    if (!IsNode(NId)) {
2514      return -1;
2515    }
2516    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2517  }
2518  int TDirNet::AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val) {
2519    if (!IsNode(NId)) {
2520      return -1;
2521    }
2522    return SAttrN.AddSAttrDat(NId, AttrName, Val);
2523  }
2524  int TDirNet::AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val) {
2525    if (!IsNode(NId)) {
2526      return -1;
2527    }
2528    return SAttrN.AddSAttrDat(NId, AttrId, Val);
2529  }
2530  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& Val) const {
2531    if (!IsNode(NId)) {
2532      return -1;
2533    }
2534    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2535  }
2536  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& Val) const {
2537    if (!IsNode(NId)) {
2538      return -1;
2539    }
2540    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2541  }
2542  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& Val) const {
2543    if (!IsNode(NId)) {
2544      return -1;
2545    }
2546    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2547  }
2548  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& Val) const {
2549    if (!IsNode(NId)) {
2550      return -1;
2551    }
2552    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2553  }
2554  int TDirNet::GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& Val) const {
2555    if (!IsNode(NId)) {
2556      return -1;
2557    }
2558    return SAttrN.GetSAttrDat(NId, AttrName, Val);
2559  }
2560  int TDirNet::GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& Val) const {
2561    if (!IsNode(NId)) {
2562      return -1;
2563    }
2564    return SAttrN.GetSAttrDat(NId, AttrId, Val);
2565  }
2566  int TDirNet::DelSAttrDatN(const TInt& NId, const TStr& AttrName) {
2567    if (!IsNode(NId)) {
2568      return -1;
2569    }
2570    return SAttrN.DelSAttrDat(NId, AttrName);
2571  }
2572  int TDirNet::DelSAttrDatN(const TInt& NId, const TInt& AttrId) {
2573    if (!IsNode(NId)) {
2574      return -1;
2575    }
2576    return SAttrN.DelSAttrDat(NId, AttrId);
2577  }
2578  int TDirNet::GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2579    if (!IsNode(NId)) {
2580      return -1;
2581    }
2582    SAttrN.GetSAttrV(NId, AttrType, AttrV);
2583    return 0;
2584  }
2585  int TDirNet::GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const {
2586    return SAttrN.GetIdVSAttr(AttrName, IdV);
2587  }
2588  int TDirNet::GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const {
2589    return SAttrN.GetIdVSAttr(AttrId, IdV);
2590  }
2591  int TDirNet::AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2592    return SAttrN.AddSAttr(Name, AttrType, AttrId);
2593  }
2594  int TDirNet::GetSAttrIdN(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2595    return SAttrN.GetSAttrId(Name, AttrId, AttrType);
2596  }
2597  int TDirNet::GetSAttrNameN(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2598    return SAttrN.GetSAttrName(AttrId, Name, AttrType);
2599  }
2600  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val) {
2601    if (!IsEdge(SrcNId, DstNId)) {
2602      return -1;
2603    }
2604    TIntPr EId(SrcNId, DstNId);
2605    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2606  }
2607  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val) {
2608    if (!IsEdge(SrcNId, DstNId)) {
2609      return -1;
2610    }
2611    TIntPr EId(SrcNId, DstNId);
2612    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2613  }
2614  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val) {
2615    if (!IsEdge(SrcNId, DstNId)) {
2616      return -1;
2617    }
2618    TIntPr EId(SrcNId, DstNId);
2619    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2620  }
2621  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val) {
2622    if (!IsEdge(SrcNId, DstNId)) {
2623      return -1;
2624    }
2625    TIntPr EId(SrcNId, DstNId);
2626    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2627  }
2628  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val) {
2629    if (!IsEdge(SrcNId, DstNId)) {
2630      return -1;
2631    }
2632    TIntPr EId(SrcNId, DstNId);
2633    return SAttrE.AddSAttrDat(EId, AttrName, Val);
2634  }
2635  int TDirNet::AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val) {
2636    if (!IsEdge(SrcNId, DstNId)) {
2637      return -1;
2638    }
2639    TIntPr EId(SrcNId, DstNId);
2640    return SAttrE.AddSAttrDat(EId, AttrId, Val);
2641  }
2642  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& Val) const {
2643    if (!IsEdge(SrcNId, DstNId)) {
2644      return -1;
2645    }
2646    TIntPr EId(SrcNId, DstNId);
2647    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2648  }
2649  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& Val) const {
2650    if (!IsEdge(SrcNId, DstNId)) {
2651      return -1;
2652    }
2653    TIntPr EId(SrcNId, DstNId);
2654    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2655  }
2656  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& Val) const {
2657    if (!IsEdge(SrcNId, DstNId)) {
2658      return -1;
2659    }
2660    TIntPr EId(SrcNId, DstNId);
2661    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2662  }
2663  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& Val) const {
2664    if (!IsEdge(SrcNId, DstNId)) {
2665      return -1;
2666    }
2667    TIntPr EId(SrcNId, DstNId);
2668    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2669  }
2670  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& Val) const {
2671    if (!IsEdge(SrcNId, DstNId)) {
2672      return -1;
2673    }
2674    TIntPr EId(SrcNId, DstNId);
2675    return SAttrE.GetSAttrDat(EId, AttrName, Val);
2676  }
2677  int TDirNet::GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& Val) const {
2678    if (!IsEdge(SrcNId, DstNId)) {
2679      return -1;
2680    }
2681    TIntPr EId(SrcNId, DstNId);
2682    return SAttrE.GetSAttrDat(EId, AttrId, Val);
2683  }
2684  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName) {
2685    if (!IsEdge(SrcNId, DstNId)) {
2686      return -1;
2687    }
2688    TIntPr EId(SrcNId, DstNId);
2689    return SAttrE.DelSAttrDat(EId, AttrName);
2690  }
2691  int TDirNet::DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId) {
2692    if (!IsEdge(SrcNId, DstNId)) {
2693      return -1;
2694    }
2695    TIntPr EId(SrcNId, DstNId);
2696    return SAttrE.DelSAttrDat(EId, AttrId);
2697  }
2698  int TDirNet::GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const {
2699    if (!IsEdge(SrcNId, DstNId)) {
2700      return -1;
2701    }
2702    TIntPr EId(SrcNId, DstNId);
2703    SAttrE.GetSAttrV(EId, AttrType, AttrV);
2704    return 0;
2705  }
2706  int TDirNet::GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const {
2707    return SAttrE.GetIdVSAttr(AttrName, IdV);
2708  }
2709  int TDirNet::GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const {
2710    return SAttrE.GetIdVSAttr(AttrId, IdV);
2711  }
2712  int TDirNet::AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId) {
2713    return SAttrE.AddSAttr(Name, AttrType, AttrId);
2714  }
2715  int TDirNet::GetSAttrIdE(const TStr& Name, TInt& AttrId, TAttrType& AttrType) const {
2716    return SAttrE.GetSAttrId(Name, AttrId, AttrType);
2717  }
2718  int TDirNet::GetSAttrNameE(const TInt& AttrId, TStr& Name, TAttrType& AttrType) const {
2719    return SAttrE.GetSAttrName(AttrId, Name, AttrType);
2720  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tabfind.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.cpp</div>
                <div class="column column_space"><pre><code>501        }
502        is_left_tab = false;
503        if (n_mid_y < top_y) {
504          maybe_left_tab_down = -INT32_MAX;
505        }
506        if (n_mid_y > bottom_y) {
507          maybe_left_tab_up = -INT32_MAX;
508        }
</pre></code></div>
                <div class="column column_space"><pre><code>986    }
987    TInt location = CheckDenseOrSparseN(attr);
988    if (location==-1) {
989      AddIntVAttrN(attr, UseDense);
990      location = CheckDenseOrSparseN(attr);
991    }
992    if (UseDense) {
993      IAssertR(location != 0, TStr::Fmt("NodeId %d exists for %s in sparse representation", NId, attr.CStr()));
994      TVec<TIntV>& NewVec = VecOfIntVecVecsN[KeyToIndexTypeN.GetDat(attr).Val2];
995      NewVec[NodeH.GetKeyId(NId)].Add(value);
996    } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    