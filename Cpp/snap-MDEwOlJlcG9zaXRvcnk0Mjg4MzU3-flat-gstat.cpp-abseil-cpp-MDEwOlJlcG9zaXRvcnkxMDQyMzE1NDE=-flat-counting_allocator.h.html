
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.cpp</h3>
            <pre><code>1  int TGStat::NDiamRuns = 10;
2  int TGStat::TakeSngVals = 100;
3  const TFltPrV TGStat::EmptyV = TFltPrV();
4  bool TGStat::TCmpByVal::operator () (const TGStat& GS1, const TGStat& GS2) const {
5    IAssertR(GS1.HasVal(ValCmp) && GS2.HasVal(ValCmp), TStr::Fmt("CmpVal: %d (%s)", 
6      int(ValCmp), TGStat::GetValStr(ValCmp).CStr()).CStr());
7    bool Res;
8    if (ValCmp == gsvTime) { Res = GS1.Time < GS2.Time; }
9    else { Res = GS1.GetVal(ValCmp) < GS2.GetVal(ValCmp); }
10    if (SortAsc) { return Res; }
11    else { return ! Res; }
12  }
13  bool TGStat::TCmpByVal::operator () (const PGStat& GS1, const PGStat& GS2) const {
14    return operator()(*GS1, *GS2);
15  }
16  TGStat::TGStat(const TSecTm& GraphTm, const TStr& GraphName) :
17    Time(GraphTm), GraphNm(GraphName), ValStatH(), DistrStatH() {
18  }
19  TGStat::TGStat(const PNGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
20    TakeStat(Graph, GraphTm, StatFSet, GraphName);
21  }
22  TGStat::TGStat(const PUNGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
23    TakeStat(Graph, GraphTm, StatFSet, GraphName);
24  }
25  TGStat::TGStat(const PNEGraph& Graph, const TSecTm& GraphTm, TFSet StatFSet, const TStr& GraphName) {
26    TakeStat(Graph, GraphTm, StatFSet, GraphName);
27  }
28  TGStat::TGStat(const TGStat& GStat) : Time(GStat.Time), GraphNm(GStat.GraphNm),
29    ValStatH(GStat.ValStatH), DistrStatH(GStat.DistrStatH) {
30  }
31  TGStat::TGStat(TSIn& SIn) : Time(SIn), GraphNm(SIn), ValStatH(SIn), DistrStatH(SIn) { }
32  void TGStat::Save(TSOut& SOut) const {
33    Time.Save(SOut);  GraphNm.Save(SOut);
34    ValStatH.Save(SOut);  DistrStatH.Save(SOut);
35  }
36  TGStat& TGStat::operator = (const TGStat& GStat) {
37    if (this != &GStat) {
38      Time = GStat.Time;
39      GraphNm = GStat.GraphNm;
40      ValStatH = GStat.ValStatH;
41      DistrStatH = GStat.DistrStatH;
42    }
43    return *this;
44  }
45  bool TGStat::operator == (const TGStat& GStat) const {
46    return Time==GStat.Time && ValStatH==GStat.ValStatH && DistrStatH==GStat.DistrStatH;
47  }
48  bool TGStat::operator < (const TGStat& GStat) const {
49    if (Time<GStat.Time) { return true; }
50    if (Time>GStat.Time) { return false; }
51    if (ValStatH.Empty() && ! GStat.ValStatH.Empty()) { return true; }
52    if (GStat.ValStatH.Empty()) { return false; }
53    for (int v = gsvTime; v < gsvMx; v++) {
54      if (! ValStatH.IsKey(v) && ! GStat.ValStatH.IsKey(v)) { continue; }
55      if (ValStatH.IsKey(v) && ! GStat.ValStatH.IsKey(v)) { return false; }
56      if (! ValStatH.IsKey(v)) { return true; }
57      if (ValStatH.GetDat(v) < GStat.ValStatH.GetDat(v)) { return true; }
58    }
59    return false;
60  }
61  bool TGStat::HasVal(const TGStatVal& StatVal) const {
62    if (StatVal == gsvIndex) { return true; }
63    if (StatVal == gsvTime) { return Time.IsDef(); }
64    return ValStatH.IsKey(int(StatVal));
65  }
66  double TGStat::GetVal(const TGStatVal& StatVal) const {
67    if (StatVal == gsvIndex) { return -1; }
68    if (StatVal == gsvTime) { return Time.GetAbsSecs(); }
69    if (! ValStatH.IsKey(int(StatVal))) { return -1.0; }
70    return ValStatH.GetDat(int(StatVal));
71  }
72  void TGStat::SetVal(const TGStatVal& StatVal, const double& Val) {
73    ValStatH.AddDat(int(StatVal), Val);
74  }
75  const TFltPrV& TGStat::GetDistr(const TGStatDistr& Distr) const {
76    if (! DistrStatH.IsKey(int(Distr))) { return EmptyV; }
77    return DistrStatH.GetDat(int(Distr));
78  }
79  void TGStat::SetDistr(const TGStatDistr& Distr, const TFltPrV& FltPrV) {
80    DistrStatH.AddDat(Distr, FltPrV);
81  }
82  void TGStat::GetDistr(const TGStatDistr& Distr, TFltPrV& FltPrV) const {
83    FltPrV = GetDistr(Distr);
84  }
85  void TGStat::TakeStat(const PNGraph& Graph, const TSecTm& _Time, TFSet StatFSet, const TStr& GraphName) {
86    printf("\n===TakeStat:  G(%u, %u) at %s\n", Graph->GetNodes(), Graph->GetEdges(), _Time.IsDef()?_Time.GetStr().CStr():"");
87    TExeTm ExeTm, FullTm;
88    Time = _Time;
89    GraphNm = GraphName;
90    if (StatFSet.In(gsvNone)) { return; }
91    TakeBasicStat(Graph, false);
92    TakeDiam(Graph, StatFSet, false);
93    if (StatFSet.In(gsdWcc) || StatFSet.In(gsdWccHops) || StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsvWccNodes) || StatFSet.In(gsvWccSrcNodes) || StatFSet.In(gsvWccDstNodes) || StatFSet.In(gsvWccEdges) || StatFSet.In(gsvWccUniqEdges) || StatFSet.In(gsvWccBiDirEdges)) {
94      PNGraph WccGraph = TSnap::GetMxWcc(Graph);
95      TakeBasicStat(WccGraph, true);
96      TakeDiam(WccGraph, StatFSet, true);
97      SetVal(gsvWccSize, WccGraph->GetNodes()/double(Graph->GetNodes()));
98    }
99    TakeSccStat(Graph, StatFSet);
100    TakeBccStat(Graph, StatFSet);
101    TakeDegDistr(Graph, StatFSet);
102    TakeConnComp(Graph, StatFSet);
103    TakeSpectral(Graph, StatFSet, -1);
104    if (StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf)) {
105      TakeClustCf(Graph); }
106    if (StatFSet.In(gsdTriadPart)) {
107      TakeTriadPart(Graph); }
108    printf("**[%s]\n", FullTm.GetTmStr());
109  }
110  void TGStat::TakeStat(const PUNGraph& Graph, const TSecTm& _Time, TFSet StatFSet, const TStr& GraphName) {
111    printf("\n===TakeStat:  UG(%u, %u) at %s\n", Graph->GetNodes(), Graph->GetEdges(), _Time.IsDef()?_Time.GetStr().CStr():"");
112    TExeTm ExeTm, FullTm;
113    Time = _Time;
114    GraphNm = GraphName;
115    if (StatFSet.In(gsvNone)) { return; }
116    TakeBasicStat(Graph, false);
117    TakeDiam(Graph, StatFSet, false);
118    if (StatFSet.In(gsdWcc) || StatFSet.In(gsdWccHops) || StatFSet.In(gsvFullDiam) || StatFSet.In(gsvEffWccDiam) || StatFSet.In(gsvWccNodes) || StatFSet.In(gsvWccSrcNodes) || StatFSet.In(gsvWccDstNodes) || StatFSet.In(gsvWccEdges) || StatFSet.In(gsvWccUniqEdges) || StatFSet.In(gsvWccBiDirEdges)) {
119      PUNGraph WccGraph = TSnap::GetMxWcc(Graph);
120      TakeBasicStat(WccGraph, true);
121      TakeDiam(WccGraph, StatFSet, true);
122      SetVal(gsvWccSize, WccGraph->GetNodes()/double(Graph->GetNodes()));
123    }
124    TakeBccStat(Graph, StatFSet);
125    TakeDegDistr(Graph, StatFSet);
126    TakeConnComp(Graph, StatFSet);
127    if (StatFSet.In(gsdClustCf) || StatFSet.In(gsvClustCf)) {
128      TakeClustCf(Graph); }
129    if (StatFSet.In(gsdTriadPart)) {
130      TakeTriadPart(Graph); }
131    printf("**[%s]\n", FullTm.GetTmStr());
132  }
133  void TGStat::TakeSpectral(const PNGraph& Graph, const int _TakeSngVals) {
134    TakeSpectral(Graph, TFSet() | gsdSngVal | gsdSngVec, _TakeSngVals);
135  }
136  void TGStat::TakeSpectral(const PNGraph& Graph, TFSet StatFSet, int _TakeSngVals) {
137    TExeTm ExeTm;
138    if (_TakeSngVals == -1) { _TakeSngVals = TakeSngVals; }
139    if (StatFSet.In(gsdSngVal)) {
140      printf("sing-vals...");  
141      const int SngVals = TMath::Mn(_TakeSngVals, Graph->GetNodes()/2);
142      TFltV SngValV1;
143      TSnap::GetSngVals(Graph, SngVals, SngValV1);
144      SngValV1.Sort(false);
145      TFltPrV& SngValV = DistrStatH.AddDat(gsdSngVal);
146      SngValV.Gen(SngValV1.Len(), 0);
147      for (int i = 0; i < SngValV1.Len(); i++) {
148        SngValV.Add(TFltPr(i+1, SngValV1[i]));
149      }
150      printf("[%s]  ", ExeTm.GetTmStr());
151    }
152    if (StatFSet.In(gsdSngVec)) {
153      printf("sing-vec...");  
154      TFltV LeftV, RightV;
155      TSnap::GetSngVec(Graph, LeftV, RightV);
156      LeftV.Sort(false);
157      TFltPrV& SngVec = DistrStatH.AddDat(gsdSngVec);
158      SngVec.Gen(LeftV.Len(), 0);
159      for (int i = 0; i < TMath::Mn(Kilo(10), LeftV.Len()/2); i++) {
160        if (LeftV[i] > 0) { SngVec.Add(TFltPr(i+1, LeftV[i])); }
161      }
162      printf("[%s]  ", ExeTm.GetTmStr());
163    }
164  }
165  void TGStat::Plot(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc, bool PowerFit) const {
166    if (Desc.Empty()) Desc = FNmPref.GetUc();
167    if (! HasDistr(Distr) || Distr==gsdUndef || Distr==gsdMx) { return; }
168    TPlotInfo Info = GetPlotInfo(Distr);
169    TGnuPlot GnuPlot(Info.Val1+TStr(".")+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(),GetEdges()));
170    GnuPlot.SetXYLabel(Info.Val2, Info.Val3);
171    GnuPlot.SetScale(Info.Val4);
172    const int plotId = GnuPlot.AddPlot(GetDistr(Distr), gpwLinesPoints, "");
173    if (PowerFit) { GnuPlot.AddPwrFit(plotId, gpwLines); }
174    #ifdef GLib_MACOSX
175    GnuPlot.SaveEps();
176    #else
177    GnuPlot.SavePng();
178    #endif
179  }
180  void TGStat::Plot(const TFSet& FSet, const TStr& FNmPref, const TStr& Desc, bool PowerFit) const {
181    for (int d = gsdUndef; d < gsdMx; d++) {
182      const TGStatDistr Distr = TGStatDistr(d);
183      if (! FSet.In(Distr)) { continue; }
184      Plot(Distr, FNmPref, Desc, PowerFit);
185    }
186  }
187  void TGStat::PlotAll(const TStr& FNmPref, TStr Desc, bool PowerFit) const {
188    for (int d = gsdUndef; d < gsdMx; d++) {
189      const TGStatDistr Distr = TGStatDistr(d);
190      Plot(Distr, FNmPref, Desc, PowerFit);
191    }
192  }
193  void TGStat::DumpValStat() {
194    for (int val = gsvNone; val < gsvMx; val++) {
195      const TGStatVal Val = TGStatVal(val);
196      if (! HasVal(Val)) { continue; }
197      printf("  %s\t%g\n", GetValStr(Val).CStr(), GetVal(Val));
198    }
199  }
200  void TGStat::AvgGStat(const PGStatVec& GStatVec, const bool& ClipAt1) {
201    AvgGStat(GStatVec->GetGStatV(), ClipAt1);
202  }
203  void TGStat::AvgGStat(const TGStatV& GStatV, const bool& ClipAt1) {
204    if (GStatV.Empty()) return;
205    Time = GStatV[0]->Time;
206    GraphNm = GStatV[0]->GraphNm;
207    for (int statVal = 0; statVal > gsvMx; statVal++) {
208      const TGStatVal GStatVal = TGStatVal(statVal);
209      TMom Mom;
210      for (int i = 0; i < GStatV.Len(); i++) {
211        if (GStatV[i]->HasVal(GStatVal)) {
212          Mom.Add(GStatV[i]->GetVal(GStatVal)); }
213      }
214      Mom.Def();
215      if (Mom.IsUsable()) {
216        IAssert(Mom.GetVals() == GStatV.Len()); 
217        SetVal(GStatVal, Mom.GetMean());
218      }
219    }
220    for (int distr = gsdUndef; distr < gsdMx; distr++) {
221      const TGStatDistr GStatDistr = TGStatDistr(distr);
222      THash<TFlt, TFlt> ValToSumH;
223      int DistrCnt = 0;
224      for (int i = 0; i < GStatV.Len(); i++) {
225        if (GStatV[i]->HasDistr(GStatDistr)) {
226          const TFltPrV& D = GStatV[i]->GetDistr(GStatDistr);
227          for (int d = 0; d < D.Len(); d++) {
228            ValToSumH.AddDat(D[d].Val1) += D[d].Val2; }
229          DistrCnt++;
230        }
231      }
232      IAssert(DistrCnt==0 || DistrCnt==GStatV.Len()); 
233      TFltPrV AvgStatV;
234      ValToSumH.GetKeyDatPrV(AvgStatV);  AvgStatV.Sort();
235      for (int i = 0; i < AvgStatV.Len(); i++) {
236        AvgStatV[i].Val2 /= double(DistrCnt);
237        if (ClipAt1 && AvgStatV[i].Val2 < 1) { AvgStatV[i].Val2 = 1; }
238      }
239      SetDistr(GStatDistr, AvgStatV);
240    }
241  }
242  TStr TGStat::GetDistrStr(const TGStatDistr& Distr) {
243    switch (Distr) {
244      case gsdUndef : return TStr("Undef");
245      case gsdInDeg : return "InDeg";
246      case gsdOutDeg : return "OutDeg";
247      case gsdWcc : return "WccDist";
248      case gsdScc : return "SccDist";
249      case gsdHops : return "Hops";
250      case gsdWccHops : return "WccHops";
251      case gsdSngVal : return "SngVal";
252      case gsdSngVec : return "SngVec";
253      case gsdClustCf : return "ClustCf";
254      case gsdTriadPart : return "TriadPart";
255      case gsdMx: return TStr("Mx");
256      default: Fail; return TStr();
257    };
258  }
259  TStr TGStat::GetValStr(const TGStatVal& Val) {
260    static TIntStrH ValTyStrH;
261    if (ValTyStrH.Empty()) {
262      ValTyStrH.AddDat(gsvNone, "None");
263      ValTyStrH.AddDat(gsvIndex, "Index");
264      ValTyStrH.AddDat(gsvTime, "Time");
265      ValTyStrH.AddDat(gsvNodes, "Nodes");
266      ValTyStrH.AddDat(gsvZeroNodes, "ZeroNodes");
267      ValTyStrH.AddDat(gsvNonZNodes, "NonZNodes");
268      ValTyStrH.AddDat(gsvSrcNodes, "SrcNodes");
269      ValTyStrH.AddDat(gsvDstNodes, "DstNodes");
270      ValTyStrH.AddDat(gsvEdges, "Edges");
271      ValTyStrH.AddDat(gsvUniqEdges, "UniqEdges");
272      ValTyStrH.AddDat(gsvBiDirEdges, "BiDirEdges");
273      ValTyStrH.AddDat(gsvWccNodes, "WccNodes");
274      ValTyStrH.AddDat(gsvWccSrcNodes, "WccSrcNodes");
275      ValTyStrH.AddDat(gsvWccDstNodes, "WccDstNodes");
276      ValTyStrH.AddDat(gsvWccEdges, "WccEdges");
277      ValTyStrH.AddDat(gsvWccUniqEdges, "WccUniqEdges");
278      ValTyStrH.AddDat(gsvWccBiDirEdges, "WccBiDirEdges");
279      ValTyStrH.AddDat(gsvSccNodes, "SccNodes");
280      ValTyStrH.AddDat(gsvSccEdges, "SccEdges");
281      ValTyStrH.AddDat(gsvBccNodes, "BccNodes");
282      ValTyStrH.AddDat(gsvBccEdges, "BccEdges");
283      ValTyStrH.AddDat(gsvFullDiam, "FullDiam");
284      ValTyStrH.AddDat(gsvEffDiam, "EffDiam");
285      ValTyStrH.AddDat(gsvEffWccDiam, "EffWccDiam");
286      ValTyStrH.AddDat(gsvFullWccDiam, "FullWccDiam");
287      ValTyStrH.AddDat(gsvFullDiamDev, "FullDiamDev");
288      ValTyStrH.AddDat(gsvEffDiamDev, "EffDiamDev");
289      ValTyStrH.AddDat(gsvEffWccDiamDev, "EffWccDiamDev");
290      ValTyStrH.AddDat(gsvFullWccDiamDev, "FullWccDiamDev");
291      ValTyStrH.AddDat(gsvClustCf, "ClustCf");
292      ValTyStrH.AddDat(gsvOpenTriads, "OpenTr");
293      ValTyStrH.AddDat(gsvClosedTriads, "ClosedTr");
294      ValTyStrH.AddDat(gsvWccSize, "WccSize");
295      ValTyStrH.AddDat(gsvSccSize, "SccSize");
296      ValTyStrH.AddDat(gsvBccSize, "BccSize");
297      ValTyStrH.AddDat(gsvMx, "Mx");
298    }
299    IAssert(ValTyStrH.IsKey(int(Val)));
300    return ValTyStrH.GetDat(int(Val));
301  }
302  TGStat::TPlotInfo TGStat::GetPlotInfo(const TGStatVal& Val) {
303    Fail;
304    return TPlotInfo();
305  }
306  TGStat::TPlotInfo TGStat::GetPlotInfo(const TGStatDistr& Distr) {
307    switch (Distr) {
308      case gsdUndef : Fail; return TPlotInfo();
309      case gsdInDeg : return TPlotInfo("inDeg", "In-degree, k", "Count", gpsLog10XY);
310      case gsdOutDeg : return TPlotInfo("outDeg", "Out-degree, k", "Count", gpsLog10XY);
311      case gsdWcc : return TPlotInfo("wcc", "WCC size", "Count", gpsLog10XY);
312      case gsdScc : return TPlotInfo("scc", "SCC size", "Count", gpsLog10XY);
313      case gsdHops : return TPlotInfo("hop", "Number of hops, h", "Reachable pairs of nodes inside h hops", gpsLog10Y);
314      case gsdWccHops : return TPlotInfo("wccHop", "Number of hops, h", "Reachable pairs of nodes inside h hops in WCC", gpsLog10Y);
315      case gsdSngVal : return TPlotInfo("sval", "Rank", "Singular value", gpsLog10XY);
316      case gsdSngVec : return TPlotInfo("svec", "Rank", "Left singular vector", gpsLog10XY);
317      case gsdClustCf : return TPlotInfo("ccf", "Degree, k", "Clustering coefficient, <C(k)>", gpsLog10XY);
318      case gsdTriadPart : return TPlotInfo("triad", "Number of triads adjacent to a node", "Number of such nodes", gpsLog10XY);
319      case gsdMx : Fail;
320      default: Fail; return TPlotInfo();
321    };
322  }
323  TFSet TGStat::NoStat() {
324    return TFSet() | gsvNone;
325  }
326  TFSet TGStat::BasicStat() {
327    return TFSet();
328  }
329  TFSet TGStat::DegDStat() {
330    return TFSet() | gsdInDeg |  gsdOutDeg;
331  }
332  TFSet TGStat::NoDiamStat() {
333    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc;
334  }
335  TFSet TGStat::NoDistrStat() {
336    return TFSet() | gsdHops | gsdWccHops;
337  }
338  TFSet TGStat::NoSvdStat() {
339    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc |
340      gsdHops |  gsdWccHops | gsdClustCf | gsdTriadPart;
341  }
342  TFSet TGStat::AllStat() {
343    return TFSet() | gsdInDeg |  gsdOutDeg |  gsdWcc |  gsdScc
344      | gsdHops |  gsdWccHops | gsdClustCf | gsdTriadPart 
345      | gsdSngVec | gsdSngVal | gsvFullDiam;
346  }
347  uint TGStatVec::MinNodesEdges = 10;
348  TGStatVec::TGStatVec(const TTmUnit& _TmUnit) : TmUnit(_TmUnit), StatFSet(), GStatV() {
349    StatFSet = TGStat::AllStat();
350  }
351  TGStatVec::TGStatVec(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat) :
352     TmUnit(_TmUnit), StatFSet(TakeGrowthStat), GStatV() {
353  }
354  TGStatVec::TGStatVec(const TGStatVec& GStat) :
355    TmUnit(GStat.TmUnit), StatFSet(GStat.StatFSet), GStatV(GStat.GStatV) {
356  }
357  TGStatVec::TGStatVec(TSIn& SIn) : TmUnit((TTmUnit) TInt(SIn).Val), StatFSet(SIn), GStatV(SIn) {
358  }
359  PGStatVec TGStatVec::New(const TTmUnit& _TmUnit) {
360    return new TGStatVec(_TmUnit);
361  }
362  PGStatVec TGStatVec::New(const TTmUnit& _TmUnit, const TFSet& TakeGrowthStat) {
363    return new TGStatVec(_TmUnit, TakeGrowthStat);
364  }
365  void TGStatVec::Save(TSOut& SOut) const {
366    TInt(TmUnit).Save(SOut);
367    StatFSet.Save(SOut);
368    GStatV.Save(SOut);
369  }
370  TGStatVec& TGStatVec::operator = (const TGStatVec& GStat) {
371    if (this != &GStat) {
372      TmUnit = GStat.TmUnit;
373      StatFSet = GStat.StatFSet;
374      GStatV = GStat.GStatV;
375    }
376    return *this;
377  }
378  PGStat TGStatVec::Add() {
379    GStatV.Add(TGStat::New());
380    return GStatV.Last();
381  }
382  PGStat TGStatVec::Add(const TSecTm& Time, const TStr& GraphNm) {
383    GStatV.Add(TGStat::New(Time, GraphNm));
384    return GStatV.Last();
385  }
386  void TGStatVec::Add(const PNGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
387    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
388      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
389      return;
390    }
391    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
392  }
393  void TGStatVec::Add(const PUNGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
394    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
395      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
396      return;
397    }
398    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
399  }
400  void TGStatVec::Add(const PNEGraph& Graph, const TSecTm& Time, const TStr& GraphNm) {
401    if (Graph->GetNodes() < (int) TGStatVec::MinNodesEdges) {
402      printf(" ** TGStatVec::Add: graph too small (%d nodes).SKIP\n", Graph->GetNodes());
403      return;
404    }
405    Add(TGStat::New(Graph, Time, StatFSet, GraphNm));
406  }
407  void TGStatVec::Sort(const TGStatVal& SortBy, const bool& Asc) {
408    GStatV.SortCmp(TGStat::TCmpByVal(SortBy, Asc));
409  }
410  void TGStatVec::DelBefore(const TSecTm& Tm) {
411    TGStatV NewTickV;
412    for (int i = 0; i < Len(); i++) {
413      if (At(i)->Time >= Tm) { NewTickV.Add(At(i)); }
414    }
415    GStatV.Swap(NewTickV);
416  }
417  void TGStatVec::DelAfter(const TSecTm& Tm) {
418    TGStatV NewTickV;
419    for (int i = 0; i < Len(); i++) {
420      if (At(i)->Time <= Tm) { NewTickV.Add(At(i)); }
421    }
422    GStatV.Swap(NewTickV);
423  }
424  void TGStatVec::DelSmallNodes(const int& MinNodes) {
425    TGStatV NewTickV;
426    for (int i = 0; i < Len(); i++) {
427      if (At(i)->GetNodes() >= MinNodes) { NewTickV.Add(At(i)); }
428    }
429    GStatV.Swap(NewTickV);
430  }
431  void TGStatVec::GetValV(const TGStatVal& XVal, const TGStatVal& YVal, TFltPrV& ValV) const {
432    ValV.Gen(Len(), 0);
433    double x;
434    for (int t = 0; t < Len(); t++) {
435      if (XVal == gsvIndex) { x = t+1; }
436      else if (XVal == gsvTime) { x = GetTime(t); }
437      else { x = At(t)->GetVal(XVal); }
438      ValV.Add(TFltPr(x, At(t)->GetVal(YVal)));
439    }
440    ValV.Sort(true); 
441  }
442  PGStat TGStatVec::GetAvgGStat(const bool& ClipAt1) {
443    PGStat Stat = TGStat::New();
444    Stat->AvgGStat(GStatV, ClipAt1);
445    return Stat;
446  }
447  void TGStatVec::Plot(const TGStatVal& XVal, const TGStatVal& YVal, const TStr& OutFNm, TStr& Desc, const TGpScaleTy& Scale,const bool& PowerFit) const {
448    if (! Last()->HasVal(XVal) || ! Last()->HasVal(YVal)) {
449      if (! Last()->HasVal(XVal)) { printf("** Does not have %s statistic\n", TGStat::GetValStr(XVal).CStr()); }
450      if (! Last()->HasVal(YVal)) { printf("** Does not have %s statistic\n", TGStat::GetValStr(YVal).CStr()); }
451      return;
452    }
453    if (Desc.Empty()) { Desc = OutFNm; }
<span onclick='openModal()' class='match'>454    TFltPrV ValV;
455    TGStatVec::GetValV(XVal, YVal, ValV);
456    TGnuPlot GP(TStr::Fmt("%s-%s.%s", TGStat::GetValStr(XVal).CStr(), TGStat::GetValStr(YVal).CStr(), OutFNm.CStr()),
</span>457      TStr::Fmt("%s. %s vs. %s. G(%d,%d)", Desc.CStr(), TGStat::GetValStr(XVal).CStr(), TGStat::GetValStr(YVal).CStr(),
458      Last()->GetNodes(), Last()->GetEdges()));
459    GP.SetScale(Scale);
460    GP.SetXYLabel(TGStat::GetValStr(XVal), TGStat::GetValStr(YVal));
461    const int Id = GP.AddPlot(ValV, gpwLinesPoints);
462    if (PowerFit) { GP.AddPwrFit(Id); }
463    GP.SavePng();
464  }
465  void TGStatVec::PlotAllVsX(const TGStatVal& XVal, const TStr& OutFNm, TStr Desc, const TGpScaleTy& Scale, const bool& PowerFit) const {
466    const TFSet SkipStat = TFSet() | gsvFullDiamDev | gsvEffDiamDev | gsvEffWccDiamDev | gsvFullWccDiamDev;
467    for (int stat = gsvNone; stat < gsvMx; stat++) {
468      const TGStatVal Stat = TGStatVal(stat);
469      if (SkipStat.In(Stat)) { continue; }
470      if (Last()->HasVal(Stat) && Last()->HasVal(XVal) && Stat!=XVal) {
471        Plot(XVal, Stat, OutFNm, Desc, Scale, PowerFit);
472      }
473    }
474  }
475  void TGStatVec::ImposeDistr(const TGStatDistr& Distr, const TStr& FNmPref, TStr Desc, const bool& ExpBin, 
476      const bool& PowerFit, const TGpSeriesTy& PlotWith, const TStr& Style) const {
477    if (Desc.Empty()) Desc = FNmPref.GetUc();
478    if (! At(0)->HasDistr(Distr) || Distr==gsdUndef || Distr==gsdMx) { return; }
479    TGStat::TPlotInfo Info = At(0)->GetPlotInfo(Distr);
480    TGnuPlot GnuPlot(Info.Val1+TStr(".")+FNmPref, TStr::Fmt("%s. G(%d, %d) --> G(%d, %d)", Desc.CStr(),
481      At(0)->GetNodes(), At(0)->GetEdges(), Last()->GetNodes(), Last()->GetEdges()));
482    GnuPlot.SetXYLabel(Info.Val2, Info.Val3);
483    GnuPlot.SetScale(Info.Val4);
484    int plotId;
485    for (int at = 0; at < Len(); at++) {
486      TStr Legend = At(at)->GetNm();
487      if (Legend.Empty()) { Legend = At(at)->GetTmStr(); }
488      if (! ExpBin) { 
489        plotId = GnuPlot.AddPlot(At(at)->GetDistr(Distr), PlotWith, Legend, Style); }
490      else { 
491        TFltPrV ExpBinV; 
492        TGnuPlot::MakeExpBins(At(at)->GetDistr(Distr), ExpBinV, 2, 0);
493        plotId = GnuPlot.AddPlot(ExpBinV, PlotWith, Legend, Style);
494      }
495      if (PowerFit) { GnuPlot.AddPwrFit(plotId, gpwLines); }
496    }
497    GnuPlot.SavePng();
498  }
499  void TGStatVec::SaveTxt(const TStr& FNmPref, const TStr& Desc) const {
500    FILE *F = fopen(TStr::Fmt("growth.%s.tab", FNmPref.CStr()).CStr(), "wt");
501    fprintf(F, "# %s\n", Desc.CStr());
502    fprintf(F, "# %s", TTmInfo::GetTmUnitStr(TmUnit).CStr());
503    TIntSet StatValSet;
504    for (int i = 0; i < Len(); i++) {
505      for (int v = gsvNone; v < gsvMx; v++) {
506        if (At(i)->HasVal(TGStatVal(v))) { StatValSet.AddKey(v); }
507      }
508    }
509    TIntV StatValV;  StatValSet.GetKeyV(StatValV);  StatValV.Sort();
510    for (int sv = 0; sv < StatValV.Len(); sv++) {
511      fprintf(F, "\t%s", TGStat::GetValStr(TGStatVal(StatValV[sv].Val)).CStr()); }
512    fprintf(F, "Time\n");
513    for (int i = 0; i < Len(); i++) {
514      const TGStat& G = *At(i);
515      for (int sv = 0; sv < StatValV.Len(); sv++) {
516        fprintf(F, "%g\t", G.GetVal(TGStatVal(StatValV[sv].Val))); }
517      fprintf(F, "%s\n", G.GetTmStr().CStr());
518    }
519    fclose(F);
520  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-counting_allocator.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_COUNTING_ALLOCATOR_H_
2  #define ABSL_CONTAINER_INTERNAL_COUNTING_ALLOCATOR_H_
3  #include <cstdint>
4  #include <memory>
5  #include "absl/base/config.h"
6  namespace absl {
7  ABSL_NAMESPACE_BEGIN
8  namespace container_internal {
9  template <typename T>
10  class CountingAllocator {
11   public:
12    using Allocator = std::allocator<T>;
13    using AllocatorTraits = std::allocator_traits<Allocator>;
14    using value_type = typename AllocatorTraits::value_type;
15    using pointer = typename AllocatorTraits::pointer;
16    using const_pointer = typename AllocatorTraits::const_pointer;
17    using size_type = typename AllocatorTraits::size_type;
18    using difference_type = typename AllocatorTraits::difference_type;
19    CountingAllocator() = default;
20    explicit CountingAllocator(int64_t* bytes_used) : bytes_used_(bytes_used) {}
21    CountingAllocator(int64_t* bytes_used, int64_t* instance_count)
22        : bytes_used_(bytes_used), instance_count_(instance_count) {}
23    template <typename U>
24    CountingAllocator(const CountingAllocator<U>& x)
25        : bytes_used_(x.bytes_used_), instance_count_(x.instance_count_) {}
26    pointer allocate(
27        size_type n,
28        typename AllocatorTraits::const_void_pointer hint = nullptr) {
29      Allocator allocator;
30      pointer ptr = AllocatorTraits::allocate(allocator, n, hint);
31      if (bytes_used_ != nullptr) {
32        *bytes_used_ += n * sizeof(T);
33      }
34      return ptr;
35    }
36    void deallocate(pointer p, size_type n) {
<span onclick='openModal()' class='match'>37      Allocator allocator;
38      AllocatorTraits::deallocate(allocator, p, n);
39      if (bytes_used_ != nullptr) {
</span>40        *bytes_used_ -= n * sizeof(T);
41      }
42    }
43    template <typename U, typename... Args>
44    void construct(U* p, Args&&... args) {
45      Allocator allocator;
46      AllocatorTraits::construct(allocator, p, std::forward<Args>(args)...);
47      if (instance_count_ != nullptr) {
48        *instance_count_ += 1;
49      }
50    }
51    template <typename U>
52    void destroy(U* p) {
53      Allocator allocator;
54  #if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)
55  #pragma GCC diagnostic push
56  #pragma GCC diagnostic ignored "-Wuse-after-free"
57  #endif
58      AllocatorTraits::destroy(allocator, p);
59  #if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)
60  #pragma GCC diagnostic pop
61  #endif
62      if (instance_count_ != nullptr) {
63        *instance_count_ -= 1;
64      }
65    }
66    template <typename U>
67    class rebind {
68     public:
69      using other = CountingAllocator<U>;
70    };
71    friend bool operator==(const CountingAllocator& a,
72                           const CountingAllocator& b) {
73      return a.bytes_used_ == b.bytes_used_ &&
74             a.instance_count_ == b.instance_count_;
75    }
76    friend bool operator!=(const CountingAllocator& a,
77                           const CountingAllocator& b) {
78      return !(a == b);
79    }
80    int64_t* bytes_used_ = nullptr;
81    int64_t* instance_count_ = nullptr;
82  };
83  }  
84  ABSL_NAMESPACE_END
85  }  
86  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gstat.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-counting_allocator.h</div>
                </div>
                <div class="column column_space"><pre><code>454    TFltPrV ValV;
455    TGStatVec::GetValV(XVal, YVal, ValV);
456    TGnuPlot GP(TStr::Fmt("%s-%s.%s", TGStat::GetValStr(XVal).CStr(), TGStat::GetValStr(YVal).CStr(), OutFNm.CStr()),
</pre></code></div>
                <div class="column column_space"><pre><code>37      Allocator allocator;
38      AllocatorTraits::deallocate(allocator, p, n);
39      if (bytes_used_ != nullptr) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    