
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5170670037926675%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gks.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "gks.h"
3  TGksBitmap::TGksBitmap(const int& _Width, const int& _Height, const TGksColor& Color):
4   Width(_Width), Height(_Height){
5    PixelV.Gen(Width*Height);
6    const int Pixels=PixelV.Len();
7    for (int PixelN=0; PixelN<Pixels; PixelN++){
8     PixelV[PixelN]=Color.GetArgbVal();
9    }
10  }
11  void TGks::GetDbTxtData(
12   const TStr& TxtStr1, const TStr& TxtStr2, const int& &bsol;*X*/, const int& Y,
13   int& TxtWidth1, int& TxtHeight1, int& TxtWidth2, int& TxtHeight2,
14   int& TxtWidth, int& TxtHeight, int& Y1, int& Y2){
15    TxtWidth1=GetTxtWidth(TxtStr1);
16    TxtHeight1=GetTxtHeight(TxtStr1);
17    TxtWidth2=GetTxtWidth(TxtStr2);
18    TxtHeight2=GetTxtHeight(TxtStr2);
19    TxtWidth=TInt::GetMx(TxtWidth1, TxtWidth2);
20    TxtHeight=TxtHeight1+TxtHeight2;
21    Y1=Y-TxtHeight1/2;
22    Y2=Y+TxtHeight2/2;
23  }
24  void TGks::GetStrVData(
25   const TStrV& StrV, const int& &bsol;*X*/, const int& Y,
26   TIntV& StrWidthV, TIntV& StrHeightV,
27   int& StrVWidth, int& StrVHeight, TIntV& YV){
28    StrWidthV.Gen(StrV.Len()); StrHeightV.Gen(StrV.Len());
29    StrVWidth=0; StrVHeight=0;
30    for (int StrN=0; StrN<StrV.Len(); StrN++){
31      StrWidthV[StrN]=GetTxtWidth(StrV[StrN]);
32      StrHeightV[StrN]=GetTxtHeight(StrV[StrN]);
33      StrVWidth=TInt::GetMx(StrVWidth, StrWidthV[StrN]);
34      StrVHeight+=StrHeightV[StrN];
35    }
36    YV.Gen(StrV.Len());
37    if (StrV.Len()>0){
38      YV[0]=Y-StrVHeight/2+StrHeightV[0]/2;
39      for (int StrN=1; StrN<StrV.Len(); StrN++){
40        YV[StrN]=YV[StrN-1]+StrHeightV[StrN];
41      }
42    }
43  }
44  void TGks::DirLine(
45   const int& X1, const int& Y1, const int& X2, const int& Y2,
46   const bool& LeftDir, const bool& RightDir,
47   const int& ArrowLen, const double& ArrowOffset){
48    Line(X1, Y1, X2, Y2);
49    double AK=99999; if (Y2-Y1!=0){AK=double(X2-X1)/double(Y1-Y2);}
50    double LineLen=GetLineLen(X1, Y1, X2, Y2);
51    double ArrowLenRatio=0;
52    if (LineLen!=0){ArrowLenRatio=ArrowLen/LineLen;}
53    if (LeftDir){
54      int TopX=int(X1+(1-ArrowOffset)*(X2-X1));
55      int TopY=int(Y1+(1-ArrowOffset)*(Y2-Y1));
56      int BackX=int(X1+((1-ArrowOffset)-ArrowLenRatio)*(X2-X1));
57      int BackY=int(Y1+((1-ArrowOffset)-ArrowLenRatio)*(Y2-Y1));
58      double AN=BackY-AK*BackX;
59      double AX=BackX+100;
60      double AY=AK*AX+AN;
61      double TailLenRatio=(0.5*ArrowLen)/GetLineLen(BackX, BackY, int(AX), int(AY));
62      int UpTailX=int(BackX+(TailLenRatio)*(AX-BackX));
63      int UpTailY=int(BackY+(TailLenRatio)*(AY-BackY));
64      int LowTailX=int(BackX-(TailLenRatio)*(AX-BackX));
65      int LowTailY=int(BackY-(TailLenRatio)*(AY-BackY));
66      Line(TopX, TopY, UpTailX, UpTailY);
67      Line(TopX, TopY, LowTailX, LowTailY);
68      Line(LowTailX, LowTailY, TopX, TopY);
69    }
70    if (RightDir){
71      int TopX=int(X1+ArrowOffset*(X2-X1));
72      int TopY=int(Y1+ArrowOffset*(Y2-Y1));
73      int BackX=int(X1+(ArrowOffset+ArrowLenRatio)*(X2-X1));
74      int BackY=int(Y1+(ArrowOffset+ArrowLenRatio)*(Y2-Y1));
75      double AN=BackY-AK*BackX;
76      double AX=BackX+1;
77      double AY=AK*AX+AN;
78      double TailLenRatio=(0.5*ArrowLen)/GetLineLen(BackX, BackY, int(AX), int(AY));
79      int UpTailX=int(BackX+(TailLenRatio)*(AX-BackX));
80      int UpTailY=int(BackY+(TailLenRatio)*(AY-BackY));
81      int LowTailX=int(BackX-(TailLenRatio)*(AX-BackX));
82      int LowTailY=int(BackY-(TailLenRatio)*(AY-BackY));
83      Line(TopX, TopY, UpTailX, UpTailY);
84      Line(TopX, TopY, LowTailX, LowTailY);
85    }
86  }
87  TStr TGks::BreakTxt(
88    const TStr& TxtStr, const TStr& SplitStr, const TStr& EndLnStr,
89    const int& TxtWidth, const int& MxLines) {
90    TStrV PartV; TxtStr.SplitOnStr(SplitStr, PartV);
91    return BreakTxt(PartV, SplitStr, EndLnStr, TxtWidth, MxLines);
92  }
93  TStr TGks::BreakTxt(
94    const TStrV& PartV, const TStr& SplitStr, const TStr& EndLnStr,
95    const int& TxtWidth, const int& MxLines) {
96    if (PartV.Empty()) { return TStr(); }
97    TChA NewTxtStr = PartV[0]; int LineN = 0;
98    int CurrWidth = GetTxtWidth(PartV[0]); 
99    for (int PartN = 1; PartN < PartV.Len(); PartN++) {
100      const TStr& PartStr = PartV[PartN];
101      const int PartWidth = GetTxtWidth(PartStr);
102      if ((CurrWidth+PartWidth) > TxtWidth) {
103        CurrWidth = PartWidth; LineN++;
104        if (MxLines==LineN) { NewTxtStr += SplitStr + "..."; break; }
105          NewTxtStr += EndLnStr; NewTxtStr += '\n'; NewTxtStr += PartStr;
106        } else {
107          CurrWidth += PartWidth;
108          NewTxtStr += SplitStr; NewTxtStr += PartStr;
109        }
110    }
111    return TStr(NewTxtStr);
112  }
113  TGksTxtBoxType TGks::GetTxtBoxType(const TStr& TxtBoxTypeNm){
114    if (TxtBoxTypeNm=="Rect"){return gtbtRect;}
115    else if (TxtBoxTypeNm=="RoundRect"){return gtbtRoundRect;}
116    else if (TxtBoxTypeNm=="Ellipse"){return gtbtEllipse;}
117    else if (TxtBoxTypeNm=="Romb"){return gtbtRomb;}
118    else {return gtbtRect;}
119  }
120  TStr TGks::GetTxtBoxTypeNm(const TGksTxtBoxType& Type){
121    switch (Type){
122      case gtbtRect: return "Rect";
123      case gtbtRoundRect: return "RoundRect";
124      case gtbtEllipse: return "Ellipse";
125      case gtbtRomb: return "Romb";
126      default: Fail; return TStr();
127    }
128  }
129  TGksRect TGks::TxtBox(const TGksTxtBoxType& Type, const TStr& TxtStr,
130   const int& X, const int& Y, const int& Margin){
131    if (TxtStr.IsChIn('#')){
132      TStr TxtStr1; TStr TxtStr2;
133      TxtStr.SplitOnCh(TxtStr1, '#', TxtStr2);
134      return TxtBox(Type, TxtStr1, TxtStr2, X, Y, Margin);
135    } else {
136      switch (Type){
137        case gtbtRect: return RectTxtBox(TxtStr, X, Y, Margin);
138        case gtbtRoundRect: return RoundRectTxtBox(TxtStr, X, Y, Margin);
139        case gtbtEllipse: return EllipseTxtBox(TxtStr, X, Y, Margin);
140        case gtbtRomb: return RombTxtBox(TxtStr, X, Y, Margin);
141        default: Fail; return TGksRect();
142      }
143    }
144  }
145  TGksRect TGks::TxtBox(const TGksTxtBoxType& Type,
146   const TStr& TxtStr1, const TStr& TxtStr2,
<span onclick='openModal()' class='match'>147   const int& X, const int& Y, const int& Margin){
148    switch (Type){
149      case gtbtRect: return RectTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
150      case gtbtRoundRect: return RoundRectTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
151      case gtbtEllipse: return EllipseTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
152      case gtbtRomb: return RombTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
</span>153      default: Fail; return TGksRect();
154    }
155  }
156  TGksRect TGks::LineTxt(const TStr& TxtStr,
157   const int& X1, const int& Y1, const int& X2, const int& Y2){
158    int TxtWidth=GetTxtWidth(TxtStr);
159    int TxtHeight=GetTxtHeight(TxtStr);
160    int TxtX=(X1+(X2-X1)/2);
161    int TxtY=(Y1+(Y2-Y1)/2);
162    TxtBox(gtbtRect, TxtStr, TxtX, TxtY, 2);
163    TGksRect Rect(
164     TxtX-TxtWidth/2, TxtY-TxtHeight/2,
165     TxtX+TxtWidth/2, TxtY+TxtHeight/2);
166    return Rect;
167  }
168  TGksRect TGks::RectTxtBox(const TStr& TxtStr,
169   const int& X, const int& Y, const int& Margin){
170    if ((!TxtStr.IsChIn('\n'))&&(!TxtStr.IsChIn('\\'))){
171      int TxtWidth=GetTxtWidth(TxtStr);
172      int TxtHeight=GetTxtHeight(TxtStr);
173      TGksRect Rect(
174       X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
175       X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
176      RoundRect(Rect, (TxtWidth+Margin)/4, (TxtHeight+Margin)/2);
177      PutTxt(TxtStr, X-TxtWidth/2, Y-TxtHeight/2);
178      return Rect;
179    } else {
180      TStrV TxtStrV;
181      if (TxtStr.IsChIn('\n')){TxtStr.SplitOnAllCh('\n', TxtStrV);}
182      else if (TxtStr.IsChIn('\\')){TxtStr.SplitOnAllCh('\\', TxtStrV);}
183      TIntV TxtWidthV; TIntV TxtHeightV;
184      int TxtVWidth; int TxtVHeight; TIntV YV;
185      GetStrVData(TxtStrV, X, Y,
186       TxtWidthV, TxtHeightV, TxtVWidth, TxtVHeight, YV);
187      TGksRect Rect(
188       X-TxtVWidth/2-Margin, Y-TxtVHeight/2-Margin,
189       X+TxtVWidth/2+Margin, Y+TxtVHeight/2+Margin);
190      Rectangle(Rect);
191      for (int TxtStrN=0; TxtStrN<TxtStrV.Len(); TxtStrN++){
192        PutTxt(TxtStrV[TxtStrN],
193         X-TxtWidthV[TxtStrN]/2, YV[TxtStrN]-TxtHeightV[TxtStrN]/2);
194      }
195      return Rect;
196    }
197  }
198  TGksRect TGks::RectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
199   const int& X, const int& Y, const int& Margin){
200    int TxtWidth1; int TxtHeight1; int TxtWidth2; int TxtHeight2;
201    int TxtWidth; int TxtHeight; int Y1; int Y2;
202    GetDbTxtData(TxtStr1, TxtStr2, X, Y,
203     TxtWidth1, TxtHeight1, TxtWidth2, TxtHeight2,
204     TxtWidth, TxtHeight, Y1, Y2);
205    TGksRect Rect(
206     X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
207     X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
208    Rectangle(Rect);
209    PutTxt(TxtStr1, X-TxtWidth1/2, Y1-TxtHeight1/2);
210    PutTxt(TxtStr2, X-TxtWidth2/2, Y2-TxtHeight2/2);
211    return Rect;
212  }
213  TGksRect TGks::RoundRectTxtBox(const TStr& TxtStr,
214   const int& X, const int& Y, const int& Margin){
215    if ((!TxtStr.IsChIn('\n'))&&(!TxtStr.IsChIn('\\'))){
216      int TxtWidth=GetTxtWidth(TxtStr);
217      int TxtHeight=GetTxtHeight(TxtStr);
218      TGksRect Rect(
219       X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
220       X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
221      RoundRect(Rect, (TxtWidth+Margin)/4, (TxtHeight+Margin)/2);
222      PutTxt(TxtStr, X-TxtWidth/2, Y-TxtHeight/2);
223      return Rect;
224    } else {
225      TStrV TxtStrV;
226      if (TxtStr.IsChIn('\n')){TxtStr.SplitOnAllCh('\n', TxtStrV);}
227      else if (TxtStr.IsChIn('\\')){TxtStr.SplitOnAllCh('\\', TxtStrV);}
228      TIntV TxtWidthV; TIntV TxtHeightV;
229      int TxtVWidth; int TxtVHeight; TIntV YV;
230      GetStrVData(TxtStrV, X, Y,
231       TxtWidthV, TxtHeightV, TxtVWidth, TxtVHeight, YV);
232      TGksRect Rect(
233       X-TxtVWidth/2-Margin, Y-TxtVHeight/2-Margin,
234       X+TxtVWidth/2+Margin, Y+TxtVHeight/2+Margin);
235      RoundRect(Rect, (TxtVWidth+Margin)/4, (TxtVHeight+Margin)/2);
236      for (int TxtStrN=0; TxtStrN<TxtStrV.Len(); TxtStrN++){
237        PutTxt(TxtStrV[TxtStrN],
238         X-TxtWidthV[TxtStrN]/2, YV[TxtStrN]-TxtHeightV[TxtStrN]/2);
239      }
240      return Rect;
241    }
242  }
243  TGksRect TGks::RoundRectTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
244   const int& X, const int& Y, const int& Margin){
245    int TxtWidth1; int TxtHeight1; int TxtWidth2; int TxtHeight2;
246    int TxtWidth; int TxtHeight; int Y1; int Y2;
247    GetDbTxtData(TxtStr1, TxtStr2, X, Y,
248     TxtWidth1, TxtHeight1, TxtWidth2, TxtHeight2,
249     TxtWidth, TxtHeight, Y1, Y2);
250    TGksRect Rect(
251     X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
252     X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
253    RoundRect(Rect, (TxtWidth+Margin)/4, (TxtHeight+Margin)/2);
254    PutTxt(TxtStr1, X-TxtWidth1/2, Y1-TxtHeight1/2);
255    PutTxt(TxtStr2, X-TxtWidth2/2, Y2-TxtHeight2/2);
256    return Rect;
257  }
258  TGksRect TGks::EllipseTxtBox(const TStr& TxtStr,
259   const int& X, const int& Y, const int& Margin){
260    int TxtWidth=GetTxtWidth(TxtStr);
261    int TxtHeight=GetTxtHeight(TxtStr);
262    TGksRect Rect(
263     X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
264     X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
265    Ellipse(Rect);
266    PutTxt(TxtStr, X-TxtWidth/2, Y-TxtHeight/2);
267    return Rect;
268  }
269  TGksRect TGks::EllipseTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
270   const int& X, const int& Y, const int& Margin){
271    int TxtWidth1; int TxtHeight1; int TxtWidth2; int TxtHeight2;
272    int TxtWidth; int TxtHeight; int Y1; int Y2;
273    GetDbTxtData(TxtStr1, TxtStr2, X, Y,
274     TxtWidth1, TxtHeight1, TxtWidth2, TxtHeight2,
275     TxtWidth, TxtHeight, Y1, Y2);
276    TGksRect Rect(
277     X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
278     X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
279    Ellipse(Rect);
280    PutTxt(TxtStr1, X-TxtWidth1/2, Y1-TxtHeight1/2);
281    PutTxt(TxtStr2, X-TxtWidth2/2, Y2-TxtHeight2/2);
282    return Rect;
283  }
284  TGksRect TGks::RombTxtBox(const TStr& TxtStr,
285   const int& X, const int& Y, const int& Margin){
286    int TxtWidth=GetTxtWidth(TxtStr);
287    int TxtHeight=GetTxtHeight(TxtStr);
288    TGksRect Rect(
289     (X-TxtWidth/2-Margin), (Y-TxtHeight-Margin),
290     (X+TxtWidth/2+Margin), (Y+TxtHeight+Margin));
291    TGksSPoint Point1((Rect.GetX1()+Rect.GetX2())/2, Rect.GetY1());
292    TGksSPoint Point2(Rect.GetX1(), (Rect.GetY1()+Rect.GetY2())/2);
293    TGksSPoint Point3((Rect.GetX1()+Rect.GetX2())/2, Rect.GetY2());
294    TGksSPoint Point4(Rect.GetX2(), (Rect.GetY1()+Rect.GetY2())/2);
295    TGksSPointV PointV(4, 0);
296    PointV.Add(Point1); PointV.Add(Point2);
297    PointV.Add(Point3); PointV.Add(Point4);
298    Polygon(PointV);
299    PutTxt(TxtStr, X-TxtWidth/2, Y-TxtHeight/2);
300    return Rect;
301  }
302  TGksRect TGks::RombTxtBox(const TStr& TxtStr1, const TStr& TxtStr2,
303   const int& X, const int& Y, const int& Margin){
304    int TxtWidth1; int TxtHeight1; int TxtWidth2; int TxtHeight2;
305    int TxtWidth; int TxtHeight; int Y1; int Y2;
306    GetDbTxtData(TxtStr1, TxtStr2, X, Y,
307     TxtWidth1, TxtHeight1, TxtWidth2, TxtHeight2,
308     TxtWidth, TxtHeight, Y1, Y2);
309    TGksRect Rect(
310     X-TxtWidth/2-Margin, Y-TxtHeight/2-Margin,
311     X+TxtWidth/2+Margin, Y+TxtHeight/2+Margin);
312    Ellipse(Rect);
313    PutTxt(TxtStr1, X-TxtWidth1/2, Y1-TxtHeight1/2);
314    PutTxt(TxtStr2, X-TxtWidth2/2, Y2-TxtHeight2/2);
315    return Rect;
316  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</h3>
            <pre><code>1  #include "time_zone_info.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <chrono>
5  #include <cstdint>
6  #include <cstdio>
7  #include <cstdlib>
8  #include <cstring>
9  #include <fstream>
10  #include <functional>
11  #include <memory>
12  #include <sstream>
13  #include <string>
14  #include <utility>
15  #include "absl/base/config.h"
16  #include "absl/time/internal/cctz/include/cctz/civil_time.h"
17  #include "time_zone_fixed.h"
18  #include "time_zone_posix.h"
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace time_internal {
22  namespace cctz {
23  namespace {
24  inline bool IsLeap(year_t year) {
25    return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
26  }
27  const std::int_least32_t kDaysPerYear[2] = {365, 366};
28  const std::int_least16_t kMonthOffsets[2][1 + 12 + 1] = {
29      {-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
30      {-1, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366},
31  };
32  const std::int_least32_t kSecsPerDay = 24 * 60 * 60;
33  const std::int_least64_t kSecsPer400Years = 146097LL * kSecsPerDay;
34  const std::int_least32_t kSecsPerYear[2] = {
35      365 * kSecsPerDay,
36      366 * kSecsPerDay,
37  };
<span onclick='openModal()' class='match'>38  inline int ToPosixWeekday(weekday wd) {
39    switch (wd) {
40      case weekday::sunday:
41        return 0;
42      case weekday::monday:
43        return 1;
44      case weekday::tuesday:
45        return 2;
46      case weekday::wednesday:
47        return 3;
</span>48      case weekday::thursday:
49        return 4;
50      case weekday::friday:
51        return 5;
52      case weekday::saturday:
53        return 6;
54    }
55    return 0; &bsol;*NOTREACHED*/
56  }
57  inline std::uint_fast8_t Decode8(const char* cp) {
58    return static_cast<std::uint_fast8_t>(*cp) & 0xff;
59  }
60  std::int_fast32_t Decode32(const char* cp) {
61    std::uint_fast32_t v = 0;
62    for (int i = 0; i != (32 / 8); ++i) v = (v << 8) | Decode8(cp++);
63    const std::int_fast32_t s32max = 0x7fffffff;
64    const auto s32maxU = static_cast<std::uint_fast32_t>(s32max);
65    if (v <= s32maxU) return static_cast<std::int_fast32_t>(v);
66    return static_cast<std::int_fast32_t>(v - s32maxU - 1) - s32max - 1;
67  }
68  std::int_fast64_t Decode64(const char* cp) {
69    std::uint_fast64_t v = 0;
70    for (int i = 0; i != (64 / 8); ++i) v = (v << 8) | Decode8(cp++);
71    const std::int_fast64_t s64max = 0x7fffffffffffffff;
72    const auto s64maxU = static_cast<std::uint_fast64_t>(s64max);
73    if (v <= s64maxU) return static_cast<std::int_fast64_t>(v);
74    return static_cast<std::int_fast64_t>(v - s64maxU - 1) - s64max - 1;
75  }
76  bool AllYearDST(const PosixTimeZone& posix) {
77    if (posix.dst_start.date.fmt != PosixTransition::N) return false;
78    if (posix.dst_start.date.n.day != 0) return false;
79    if (posix.dst_start.time.offset != 0) return false;
80    if (posix.dst_end.date.fmt != PosixTransition::J) return false;
81    if (posix.dst_end.date.j.day != kDaysPerYear[0]) return false;
82    const auto offset = posix.std_offset - posix.dst_offset;
83    if (posix.dst_end.time.offset + offset != kSecsPerDay) return false;
84    return true;
85  }
86  std::int_fast64_t TransOffset(bool leap_year, int jan1_weekday,
87                                const PosixTransition& pt) {
88    std::int_fast64_t days = 0;
89    switch (pt.date.fmt) {
90      case PosixTransition::J: {
91        days = pt.date.j.day;
92        if (!leap_year || days < kMonthOffsets[1][3]) days -= 1;
93        break;
94      }
95      case PosixTransition::N: {
96        days = pt.date.n.day;
97        break;
98      }
99      case PosixTransition::M: {
100        const bool last_week = (pt.date.m.week == 5);
101        days = kMonthOffsets[leap_year][pt.date.m.month + last_week];
102        const std::int_fast64_t weekday = (jan1_weekday + days) % 7;
103        if (last_week) {
104          days -= (weekday + 7 - 1 - pt.date.m.weekday) % 7 + 1;
105        } else {
106          days += (pt.date.m.weekday + 7 - weekday) % 7;
107          days += (pt.date.m.week - 1) * 7;
108        }
109        break;
110      }
111    }
112    return (days * kSecsPerDay) + pt.time.offset;
113  }
114  inline time_zone::civil_lookup MakeUnique(const time_point<seconds>& tp) {
115    time_zone::civil_lookup cl;
116    cl.kind = time_zone::civil_lookup::UNIQUE;
117    cl.pre = cl.trans = cl.post = tp;
118    return cl;
119  }
120  inline time_zone::civil_lookup MakeUnique(std::int_fast64_t unix_time) {
121    return MakeUnique(FromUnixSeconds(unix_time));
122  }
123  inline time_zone::civil_lookup MakeSkipped(const Transition& tr,
124                                             const civil_second& cs) {
125    time_zone::civil_lookup cl;
126    cl.kind = time_zone::civil_lookup::SKIPPED;
127    cl.pre = FromUnixSeconds(tr.unix_time - 1 + (cs - tr.prev_civil_sec));
128    cl.trans = FromUnixSeconds(tr.unix_time);
129    cl.post = FromUnixSeconds(tr.unix_time - (tr.civil_sec - cs));
130    return cl;
131  }
132  inline time_zone::civil_lookup MakeRepeated(const Transition& tr,
133                                              const civil_second& cs) {
134    time_zone::civil_lookup cl;
135    cl.kind = time_zone::civil_lookup::REPEATED;
136    cl.pre = FromUnixSeconds(tr.unix_time - 1 - (tr.prev_civil_sec - cs));
137    cl.trans = FromUnixSeconds(tr.unix_time);
138    cl.post = FromUnixSeconds(tr.unix_time + (cs - tr.civil_sec));
139    return cl;
140  }
141  inline civil_second YearShift(const civil_second& cs, year_t shift) {
142    return civil_second(cs.year() + shift, cs.month(), cs.day(), cs.hour(),
143                        cs.minute(), cs.second());
144  }
145  }  
146  bool TimeZoneInfo::ResetToBuiltinUTC(const seconds& offset) {
147    transition_types_.resize(1);
148    TransitionType& tt(transition_types_.back());
149    tt.utc_offset = static_cast<std::int_least32_t>(offset.count());
150    tt.is_dst = false;
151    tt.abbr_index = 0;
152    transitions_.clear();
153    transitions_.reserve(12);
154    for (const std::int_fast64_t unix_time : {
155             -(1LL << 59),  
156             1420070400LL,  
157             1451606400LL,  
158             1483228800LL,  
159             1514764800LL,  
160             1546300800LL,  
161             1577836800LL,  
162             1609459200LL,  
163             1640995200LL,  
164             1672531200LL,  
165             1704067200LL,  
166             1735689600LL,  
167         }) {
168      Transition& tr(*transitions_.emplace(transitions_.end()));
169      tr.unix_time = unix_time;
170      tr.type_index = 0;
171      tr.civil_sec = LocalTime(tr.unix_time, tt).cs;
172      tr.prev_civil_sec = tr.civil_sec - 1;
173    }
174    default_transition_type_ = 0;
175    abbreviations_ = FixedOffsetToAbbr(offset);
176    abbreviations_.append(1, '\0');
177    future_spec_.clear();  
178    extended_ = false;
179    tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
180    tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
181    transitions_.shrink_to_fit();
182    return true;
183  }
184  bool TimeZoneInfo::Header::Build(const tzhead& tzh) {
185    std::int_fast32_t v;
186    if ((v = Decode32(tzh.tzh_timecnt)) < 0) return false;
187    timecnt = static_cast<std::size_t>(v);
188    if ((v = Decode32(tzh.tzh_typecnt)) < 0) return false;
189    typecnt = static_cast<std::size_t>(v);
190    if ((v = Decode32(tzh.tzh_charcnt)) < 0) return false;
191    charcnt = static_cast<std::size_t>(v);
192    if ((v = Decode32(tzh.tzh_leapcnt)) < 0) return false;
193    leapcnt = static_cast<std::size_t>(v);
194    if ((v = Decode32(tzh.tzh_ttisstdcnt)) < 0) return false;
195    ttisstdcnt = static_cast<std::size_t>(v);
196    if ((v = Decode32(tzh.tzh_ttisutcnt)) < 0) return false;
197    ttisutcnt = static_cast<std::size_t>(v);
198    return true;
199  }
200  std::size_t TimeZoneInfo::Header::DataLength(std::size_t time_len) const {
201    std::size_t len = 0;
202    len += (time_len + 1) * timecnt;  
203    len += (4 + 1 + 1) * typecnt;     
204    len += 1 * charcnt;               
205    len += (time_len + 4) * leapcnt;  
206    len += 1 * ttisstdcnt;            
207    len += 1 * ttisutcnt;             
208    return len;
209  }
210  bool TimeZoneInfo::EquivTransitions(std::uint_fast8_t tt1_index,
211                                      std::uint_fast8_t tt2_index) const {
212    if (tt1_index == tt2_index) return true;
213    const TransitionType& tt1(transition_types_[tt1_index]);
214    const TransitionType& tt2(transition_types_[tt2_index]);
215    if (tt1.utc_offset != tt2.utc_offset) return false;
216    if (tt1.is_dst != tt2.is_dst) return false;
217    if (tt1.abbr_index != tt2.abbr_index) return false;
218    return true;
219  }
220  bool TimeZoneInfo::GetTransitionType(std::int_fast32_t utc_offset, bool is_dst,
221                                       const std::string& abbr,
222                                       std::uint_least8_t* index) {
223    std::size_t type_index = 0;
224    std::size_t abbr_index = abbreviations_.size();
225    for (; type_index != transition_types_.size(); ++type_index) {
226      const TransitionType& tt(transition_types_[type_index]);
227      const char* tt_abbr = &abbreviations_[tt.abbr_index];
228      if (tt_abbr == abbr) abbr_index = tt.abbr_index;
229      if (tt.utc_offset == utc_offset && tt.is_dst == is_dst) {
230        if (abbr_index == tt.abbr_index) break;  
231      }
232    }
233    if (type_index > 255 || abbr_index > 255) {
234      return false;
235    }
236    if (type_index == transition_types_.size()) {
237      TransitionType& tt(*transition_types_.emplace(transition_types_.end()));
238      tt.utc_offset = static_cast<std::int_least32_t>(utc_offset);
239      tt.is_dst = is_dst;
240      if (abbr_index == abbreviations_.size()) {
241        abbreviations_.append(abbr);
242        abbreviations_.append(1, '\0');
243      }
244      tt.abbr_index = static_cast<std::uint_least8_t>(abbr_index);
245    }
246    *index = static_cast<std::uint_least8_t>(type_index);
247    return true;
248  }
249  bool TimeZoneInfo::ExtendTransitions() {
250    extended_ = false;
251    if (future_spec_.empty()) return true;  
252    PosixTimeZone posix;
253    if (!ParsePosixSpec(future_spec_, &posix)) return false;
254    std::uint_least8_t std_ti;
255    if (!GetTransitionType(posix.std_offset, false, posix.std_abbr, &std_ti))
256      return false;
257    if (posix.dst_abbr.empty()) {  
258      return EquivTransitions(transitions_.back().type_index, std_ti);
259    }
260    std::uint_least8_t dst_ti;
261    if (!GetTransitionType(posix.dst_offset, true, posix.dst_abbr, &dst_ti))
262      return false;
263    if (AllYearDST(posix)) {  
264      return EquivTransitions(transitions_.back().type_index, dst_ti);
265    }
266    transitions_.reserve(transitions_.size() + 400 * 2 + 2);
267    extended_ = true;
268    const Transition& last(transitions_.back());
269    const std::int_fast64_t last_time = last.unix_time;
270    const TransitionType& last_tt(transition_types_[last.type_index]);
271    last_year_ = LocalTime(last_time, last_tt).cs.year();
272    bool leap_year = IsLeap(last_year_);
273    const civil_second jan1(last_year_);
274    std::int_fast64_t jan1_time = jan1 - civil_second();
275    int jan1_weekday = ToPosixWeekday(get_weekday(jan1));
276    Transition dst = {0, dst_ti, civil_second(), civil_second()};
277    Transition std = {0, std_ti, civil_second(), civil_second()};
278    for (const year_t limit = last_year_ + 400;; ++last_year_) {
279      auto dst_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_start);
280      auto std_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_end);
281      dst.unix_time = jan1_time + dst_trans_off - posix.std_offset;
282      std.unix_time = jan1_time + std_trans_off - posix.dst_offset;
283      const auto* ta = dst.unix_time < std.unix_time ? &dst : &std;
284      const auto* tb = dst.unix_time < std.unix_time ? &std : &dst;
285      if (last_time < tb->unix_time) {
286        if (last_time < ta->unix_time) transitions_.push_back(*ta);
287        transitions_.push_back(*tb);
288      }
289      if (last_year_ == limit) break;
290      jan1_time += kSecsPerYear[leap_year];
291      jan1_weekday = (jan1_weekday + kDaysPerYear[leap_year]) % 7;
292      leap_year = !leap_year && IsLeap(last_year_ + 1);
293    }
294    return true;
295  }
296  bool TimeZoneInfo::Load(ZoneInfoSource* zip) {
297    tzhead tzh;
298    if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
299    if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
300      return false;
301    Header hdr;
302    if (!hdr.Build(tzh)) return false;
303    std::size_t time_len = 4;
304    if (tzh.tzh_version[0] != '\0') {
305      if (zip->Skip(hdr.DataLength(time_len)) != 0) return false;
306      if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
307      if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
308        return false;
309      if (tzh.tzh_version[0] == '\0') return false;
310      if (!hdr.Build(tzh)) return false;
311      time_len = 8;
312    }
313    if (hdr.typecnt == 0) return false;
314    if (hdr.leapcnt != 0) {
315      return false;
316    }
317    if (hdr.ttisstdcnt != 0 && hdr.ttisstdcnt != hdr.typecnt) return false;
318    if (hdr.ttisutcnt != 0 && hdr.ttisutcnt != hdr.typecnt) return false;
319    std::size_t len = hdr.DataLength(time_len);
320    std::vector<char> tbuf(len);
321    if (zip->Read(tbuf.data(), len) != len) return false;
322    const char* bp = tbuf.data();
323    transitions_.reserve(hdr.timecnt + 2);
324    transitions_.resize(hdr.timecnt);
325    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
326      transitions_[i].unix_time = (time_len == 4) ? Decode32(bp) : Decode64(bp);
327      bp += time_len;
328      if (i != 0) {
329        if (!Transition::ByUnixTime()(transitions_[i - 1], transitions_[i]))
330          return false;  
331      }
332    }
333    bool seen_type_0 = false;
334    for (std::size_t i = 0; i != hdr.timecnt; ++i) {
335      transitions_[i].type_index = Decode8(bp++);
336      if (transitions_[i].type_index >= hdr.typecnt) return false;
337      if (transitions_[i].type_index == 0) seen_type_0 = true;
338    }
339    transition_types_.reserve(hdr.typecnt + 2);
340    transition_types_.resize(hdr.typecnt);
341    for (std::size_t i = 0; i != hdr.typecnt; ++i) {
342      transition_types_[i].utc_offset =
343          static_cast<std::int_least32_t>(Decode32(bp));
344      if (transition_types_[i].utc_offset >= kSecsPerDay ||
345          transition_types_[i].utc_offset <= -kSecsPerDay)
346        return false;
347      bp += 4;
348      transition_types_[i].is_dst = (Decode8(bp++) != 0);
349      transition_types_[i].abbr_index = Decode8(bp++);
350      if (transition_types_[i].abbr_index >= hdr.charcnt) return false;
351    }
352    default_transition_type_ = 0;
353    if (seen_type_0 && hdr.timecnt != 0) {
354      std::uint_fast8_t index = 0;
355      if (transition_types_[0].is_dst) {
356        index = transitions_[0].type_index;
357        while (index != 0 && transition_types_[index].is_dst) --index;
358      }
359      while (index != hdr.typecnt && transition_types_[index].is_dst) ++index;
360      if (index != hdr.typecnt) default_transition_type_ = index;
361    }
362    abbreviations_.reserve(hdr.charcnt + 10);
363    abbreviations_.assign(bp, hdr.charcnt);
364    bp += hdr.charcnt;
365    bp += (time_len + 4) * hdr.leapcnt;  
366    bp += 1 * hdr.ttisstdcnt;            
367    bp += 1 * hdr.ttisutcnt;             
368    assert(bp == tbuf.data() + tbuf.size());
369    future_spec_.clear();
370    if (tzh.tzh_version[0] != '\0') {
371      auto get_char = [](ZoneInfoSource* azip) -> int {
372        unsigned char ch;  
373        return (azip->Read(&ch, 1) == 1) ? ch : EOF;
374      };
375      if (get_char(zip) != '\n') return false;
376      for (int c = get_char(zip); c != '\n'; c = get_char(zip)) {
377        if (c == EOF) return false;
378        future_spec_.push_back(static_cast<char>(c));
379      }
380    }
381    if (version_.empty()) {
382      version_ = zip->Version();
383    }
384    while (hdr.timecnt > 1) {
385      if (!EquivTransitions(transitions_[hdr.timecnt - 1].type_index,
386                            transitions_[hdr.timecnt - 2].type_index)) {
387        break;
388      }
389      hdr.timecnt -= 1;
390    }
391    transitions_.resize(hdr.timecnt);
392    if (transitions_.empty() || transitions_.front().unix_time >= 0) {
393      Transition& tr(*transitions_.emplace(transitions_.begin()));
394      tr.unix_time = -(1LL << 59);  
395      tr.type_index = default_transition_type_;
396    }
397    if (!ExtendTransitions()) return false;
398    const Transition& last(transitions_.back());
399    if (last.unix_time < 0) {
400      const std::uint_fast8_t type_index = last.type_index;
401      Transition& tr(*transitions_.emplace(transitions_.end()));
402      tr.unix_time = 2147483647;  
403      tr.type_index = type_index;
404    }
405    const TransitionType* ttp = &transition_types_[default_transition_type_];
406    for (std::size_t i = 0; i != transitions_.size(); ++i) {
407      Transition& tr(transitions_[i]);
408      tr.prev_civil_sec = LocalTime(tr.unix_time, *ttp).cs - 1;
409      ttp = &transition_types_[tr.type_index];
410      tr.civil_sec = LocalTime(tr.unix_time, *ttp).cs;
411      if (i != 0) {
412        if (!Transition::ByCivilTime()(transitions_[i - 1], tr))
413          return false;  
414      }
415    }
416    for (auto& tt : transition_types_) {
417      tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
418      tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
419    }
420    transitions_.shrink_to_fit();
421    return true;
422  }
423  namespace {
424  using FilePtr = std::unique_ptr<FILE, int (*)(FILE*)>;
425  inline FilePtr FOpen(const char* path, const char* mode) {
426  #if defined(_MSC_VER)
427    FILE* fp;
428    if (fopen_s(&fp, path, mode) != 0) fp = nullptr;
429    return FilePtr(fp, fclose);
430  #else
431    return FilePtr(fopen(path, mode), fclose);
432  #endif
433  }
434  class FileZoneInfoSource : public ZoneInfoSource {
435   public:
436    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
437    std::size_t Read(void* ptr, std::size_t size) override {
438      size = std::min(size, len_);
439      std::size_t nread = fread(ptr, 1, size, fp_.get());
440      len_ -= nread;
441      return nread;
442    }
443    int Skip(std::size_t offset) override {
444      offset = std::min(offset, len_);
445      int rc = fseek(fp_.get(), static_cast<long>(offset), SEEK_CUR);
446      if (rc == 0) len_ -= offset;
447      return rc;
448    }
449    std::string Version() const override {
450      return std::string();
451    }
452   protected:
453    explicit FileZoneInfoSource(
454        FilePtr fp, std::size_t len = std::numeric_limits<std::size_t>::max())
455        : fp_(std::move(fp)), len_(len) {}
456   private:
457    FilePtr fp_;
458    std::size_t len_;
459  };
460  std::unique_ptr<ZoneInfoSource> FileZoneInfoSource::Open(
461      const std::string& name) {
462    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
463    std::string path;
464    if (pos == name.size() || name[pos] != '/') {
465      const char* tzdir = "/usr/share/zoneinfo";
466      char* tzdir_env = nullptr;
467  #if defined(_MSC_VER)
468      _dupenv_s(&tzdir_env, nullptr, "TZDIR");
469  #else
470      tzdir_env = std::getenv("TZDIR");
471  #endif
472      if (tzdir_env && *tzdir_env) tzdir = tzdir_env;
473      path += tzdir;
474      path += '/';
475  #if defined(_MSC_VER)
476      free(tzdir_env);
477  #endif
478    }
479    path.append(name, pos, std::string::npos);
480    auto fp = FOpen(path.c_str(), "rb");
481    if (fp == nullptr) return nullptr;
482    return std::unique_ptr<ZoneInfoSource>(new FileZoneInfoSource(std::move(fp)));
483  }
484  class AndroidZoneInfoSource : public FileZoneInfoSource {
485   public:
486    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
487    std::string Version() const override { return version_; }
488   private:
489    explicit AndroidZoneInfoSource(FilePtr fp, std::size_t len,
490                                   std::string version)
491        : FileZoneInfoSource(std::move(fp), len), version_(std::move(version)) {}
492    std::string version_;
493  };
494  std::unique_ptr<ZoneInfoSource> AndroidZoneInfoSource::Open(
495      const std::string& name) {
496    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
497    for (const char* tzdata : {"/data/misc/zoneinfo/current/tzdata",
498                               "/system/usr/share/zoneinfo/tzdata"}) {
499      auto fp = FOpen(tzdata, "rb");
500      if (fp == nullptr) continue;
501      char hbuf[24];  
502      if (fread(hbuf, 1, sizeof(hbuf), fp.get()) != sizeof(hbuf)) continue;
503      if (strncmp(hbuf, "tzdata", 6) != 0) continue;
504      const char* vers = (hbuf[11] == '\0') ? hbuf + 6 : "";
505      const std::int_fast32_t index_offset = Decode32(hbuf + 12);
506      const std::int_fast32_t data_offset = Decode32(hbuf + 16);
507      if (index_offset < 0 || data_offset < index_offset) continue;
508      if (fseek(fp.get(), static_cast<long>(index_offset), SEEK_SET) != 0)
509        continue;
510      char ebuf[52];  
511      const std::size_t index_size =
512          static_cast<std::size_t>(data_offset - index_offset);
513      const std::size_t zonecnt = index_size / sizeof(ebuf);
514      if (zonecnt * sizeof(ebuf) != index_size) continue;
515      for (std::size_t i = 0; i != zonecnt; ++i) {
516        if (fread(ebuf, 1, sizeof(ebuf), fp.get()) != sizeof(ebuf)) break;
517        const std::int_fast32_t start = data_offset + Decode32(ebuf + 40);
518        const std::int_fast32_t length = Decode32(ebuf + 44);
519        if (start < 0 || length < 0) break;
520        ebuf[40] = '\0';  
521        if (strcmp(name.c_str() + pos, ebuf) == 0) {
522          if (fseek(fp.get(), static_cast<long>(start), SEEK_SET) != 0) break;
523          return std::unique_ptr<ZoneInfoSource>(new AndroidZoneInfoSource(
524              std::move(fp), static_cast<std::size_t>(length), vers));
525        }
526      }
527    }
528    return nullptr;
529  }
530  class FuchsiaZoneInfoSource : public FileZoneInfoSource {
531   public:
532    static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
533    std::string Version() const override { return version_; }
534   private:
535    explicit FuchsiaZoneInfoSource(FilePtr fp, std::string version)
536        : FileZoneInfoSource(std::move(fp)), version_(std::move(version)) {}
537    std::string version_;
538  };
539  std::unique_ptr<ZoneInfoSource> FuchsiaZoneInfoSource::Open(
540      const std::string& name) {
541    const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;
542    const auto kTzdataPrefixes = {
543        "/config/data/tzdata/",
544        "/pkg/data/tzdata/",
545        "/data/tzdata/",
546    };
547    const auto kEmptyPrefix = {""};
548    const bool name_absolute = (pos != name.size() && name[pos] == '/');
549    const auto prefixes = name_absolute ? kEmptyPrefix : kTzdataPrefixes;
550    for (const std::string prefix : prefixes) {
551      std::string path = prefix;
552      if (!prefix.empty()) path += "zoneinfo/tzif2/";  
553      path.append(name, pos, std::string::npos);
554      auto fp = FOpen(path.c_str(), "rb");
555      if (fp == nullptr) continue;
556      std::string version;
557      if (!prefix.empty()) {
558        std::ifstream version_stream(prefix + "revision.txt");
559        if (version_stream.is_open()) {
560          std::getline(version_stream, version);
561        }
562      }
563      return std::unique_ptr<ZoneInfoSource>(
564          new FuchsiaZoneInfoSource(std::move(fp), std::move(version)));
565    }
566    return nullptr;
567  }
568  }  
569  bool TimeZoneInfo::Load(const std::string& name) {
570    auto offset = seconds::zero();
571    if (FixedOffsetFromName(name, &offset)) {
572      return ResetToBuiltinUTC(offset);
573    }
574    auto zip = cctz_extension::zone_info_source_factory(
575        name, [](const std::string& n) -> std::unique_ptr<ZoneInfoSource> {
576          if (auto z = FileZoneInfoSource::Open(n)) return z;
577          if (auto z = AndroidZoneInfoSource::Open(n)) return z;
578          if (auto z = FuchsiaZoneInfoSource::Open(n)) return z;
579          return nullptr;
580        });
581    return zip != nullptr && Load(zip.get());
582  }
583  time_zone::absolute_lookup TimeZoneInfo::LocalTime(
584      std::int_fast64_t unix_time, const TransitionType& tt) const {
585    return {(civil_second() + unix_time) + tt.utc_offset, tt.utc_offset,
586            tt.is_dst, &abbreviations_[tt.abbr_index]};
587  }
588  time_zone::absolute_lookup TimeZoneInfo::LocalTime(std::int_fast64_t unix_time,
589                                                     const Transition& tr) const {
590    const TransitionType& tt = transition_types_[tr.type_index];
591    return {tr.civil_sec + (unix_time - tr.unix_time),  
592            tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
593  }
594  time_zone::civil_lookup TimeZoneInfo::TimeLocal(const civil_second& cs,
595                                                  year_t c4_shift) const {
596    assert(last_year_ - 400 < cs.year() && cs.year() <= last_year_);
597    time_zone::civil_lookup cl = MakeTime(cs);
598    if (c4_shift > seconds::max().count() / kSecsPer400Years) {
599      cl.pre = cl.trans = cl.post = time_point<seconds>::max();
600    } else {
601      const auto offset = seconds(c4_shift * kSecsPer400Years);
602      const auto limit = time_point<seconds>::max() - offset;
603      for (auto* tp : {&cl.pre, &cl.trans, &cl.post}) {
604        if (*tp > limit) {
605          *tp = time_point<seconds>::max();
606        } else {
607          *tp += offset;
608        }
609      }
610    }
611    return cl;
612  }
613  time_zone::absolute_lookup TimeZoneInfo::BreakTime(
614      const time_point<seconds>& tp) const {
615    std::int_fast64_t unix_time = ToUnixSeconds(tp);
616    const std::size_t timecnt = transitions_.size();
617    assert(timecnt != 0);  
618    if (unix_time < transitions_[0].unix_time) {
619      return LocalTime(unix_time, transition_types_[default_transition_type_]);
620    }
621    if (unix_time >= transitions_[timecnt - 1].unix_time) {
622      if (extended_) {
623        const std::int_fast64_t diff =
624            unix_time - transitions_[timecnt - 1].unix_time;
625        const year_t shift = diff / kSecsPer400Years + 1;
626        const auto d = seconds(shift * kSecsPer400Years);
627        time_zone::absolute_lookup al = BreakTime(tp - d);
628        al.cs = YearShift(al.cs, shift * 400);
629        return al;
630      }
631      return LocalTime(unix_time, transitions_[timecnt - 1]);
632    }
633    const std::size_t hint = local_time_hint_.load(std::memory_order_relaxed);
634    if (0 < hint && hint < timecnt) {
635      if (transitions_[hint - 1].unix_time <= unix_time) {
636        if (unix_time < transitions_[hint].unix_time) {
637          return LocalTime(unix_time, transitions_[hint - 1]);
638        }
639      }
640    }
641    const Transition target = {unix_time, 0, civil_second(), civil_second()};
642    const Transition* begin = &transitions_[0];
643    const Transition* tr = std::upper_bound(begin, begin + timecnt, target,
644                                            Transition::ByUnixTime());
645    local_time_hint_.store(static_cast<std::size_t>(tr - begin),
646                           std::memory_order_relaxed);
647    return LocalTime(unix_time, *--tr);
648  }
649  time_zone::civil_lookup TimeZoneInfo::MakeTime(const civil_second& cs) const {
650    const std::size_t timecnt = transitions_.size();
651    assert(timecnt != 0);  
652    const Transition* tr = nullptr;
653    const Transition* begin = &transitions_[0];
654    const Transition* end = begin + timecnt;
655    if (cs < begin->civil_sec) {
656      tr = begin;
657    } else if (cs >= transitions_[timecnt - 1].civil_sec) {
658      tr = end;
659    } else {
660      const std::size_t hint = time_local_hint_.load(std::memory_order_relaxed);
661      if (0 < hint && hint < timecnt) {
662        if (transitions_[hint - 1].civil_sec <= cs) {
663          if (cs < transitions_[hint].civil_sec) {
664            tr = begin + hint;
665          }
666        }
667      }
668      if (tr == nullptr) {
669        const Transition target = {0, 0, cs, civil_second()};
670        tr = std::upper_bound(begin, end, target, Transition::ByCivilTime());
671        time_local_hint_.store(static_cast<std::size_t>(tr - begin),
672                               std::memory_order_relaxed);
673      }
674    }
675    if (tr == begin) {
676      if (tr->prev_civil_sec >= cs) {
677        const TransitionType& tt(transition_types_[default_transition_type_]);
678        if (cs < tt.civil_min) return MakeUnique(time_point<seconds>::min());
679        return MakeUnique(cs - (civil_second() + tt.utc_offset));
680      }
681      return MakeSkipped(*tr, cs);
682    }
683    if (tr == end) {
684      if (cs > (--tr)->prev_civil_sec) {
685        if (extended_ && cs.year() > last_year_) {
686          const year_t shift = (cs.year() - last_year_ - 1) / 400 + 1;
687          return TimeLocal(YearShift(cs, shift * -400), shift);
688        }
689        const TransitionType& tt(transition_types_[tr->type_index]);
690        if (cs > tt.civil_max) return MakeUnique(time_point<seconds>::max());
691        return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
692      }
693      return MakeRepeated(*tr, cs);
694    }
695    if (tr->prev_civil_sec < cs) {
696      return MakeSkipped(*tr, cs);
697    }
698    if (cs <= (--tr)->prev_civil_sec) {
699      return MakeRepeated(*tr, cs);
700    }
701    return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
702  }
703  std::string TimeZoneInfo::Version() const { return version_; }
704  std::string TimeZoneInfo::Description() const {
705    std::ostringstream oss;
706    oss << "#trans=" << transitions_.size();
707    oss << " #types=" << transition_types_.size();
708    oss << " spec='" << future_spec_ << "'";
709    return oss.str();
710  }
711  bool TimeZoneInfo::NextTransition(const time_point<seconds>& tp,
712                                    time_zone::civil_transition* trans) const {
713    if (transitions_.empty()) return false;
714    const Transition* begin = &transitions_[0];
715    const Transition* end = begin + transitions_.size();
716    if (begin->unix_time <= -(1LL << 59)) {
717      ++begin;
718    }
719    std::int_fast64_t unix_time = ToUnixSeconds(tp);
720    const Transition target = {unix_time, 0, civil_second(), civil_second()};
721    const Transition* tr =
722        std::upper_bound(begin, end, target, Transition::ByUnixTime());
723    for (; tr != end; ++tr) {  
724      std::uint_fast8_t prev_type_index =
725          (tr == begin) ? default_transition_type_ : tr[-1].type_index;
726      if (!EquivTransitions(prev_type_index, tr[0].type_index)) break;
727    }
728    if (tr == end) return false;
729    trans->from = tr->prev_civil_sec + 1;
730    trans->to = tr->civil_sec;
731    return true;
732  }
733  bool TimeZoneInfo::PrevTransition(const time_point<seconds>& tp,
734                                    time_zone::civil_transition* trans) const {
735    if (transitions_.empty()) return false;
736    const Transition* begin = &transitions_[0];
737    const Transition* end = begin + transitions_.size();
738    if (begin->unix_time <= -(1LL << 59)) {
739      ++begin;
740    }
741    std::int_fast64_t unix_time = ToUnixSeconds(tp);
742    if (FromUnixSeconds(unix_time) != tp) {
743      if (unix_time == std::numeric_limits<std::int_fast64_t>::max()) {
744        if (end == begin) return false;  
745        trans->from = (--end)->prev_civil_sec + 1;
746        trans->to = end->civil_sec;
747        return true;
748      }
749      unix_time += 1;  
750    }
751    const Transition target = {unix_time, 0, civil_second(), civil_second()};
752    const Transition* tr =
753        std::lower_bound(begin, end, target, Transition::ByUnixTime());
754    for (; tr != begin; --tr) {  
755      std::uint_fast8_t prev_type_index =
756          (tr - 1 == begin) ? default_transition_type_ : tr[-2].type_index;
757      if (!EquivTransitions(prev_type_index, tr[-1].type_index)) break;
758    }
759    if (tr == begin) return false;
760    trans->from = (--tr)->prev_civil_sec + 1;
761    trans->to = tr->civil_sec;
762    return true;
763  }
764  }  
765  }  
766  ABSL_NAMESPACE_END
767  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gks.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-time_zone_info.cc</div>
                </div>
                <div class="column column_space"><pre><code>147   const int& X, const int& Y, const int& Margin){
148    switch (Type){
149      case gtbtRect: return RectTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
150      case gtbtRoundRect: return RoundRectTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
151      case gtbtEllipse: return EllipseTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
152      case gtbtRomb: return RombTxtBox(TxtStr1, TxtStr2, X, Y, Margin);
</pre></code></div>
                <div class="column column_space"><pre><code>38  inline int ToPosixWeekday(weekday wd) {
39    switch (wd) {
40      case weekday::sunday:
41        return 0;
42      case weekday::monday:
43        return 1;
44      case weekday::tuesday:
45        return 2;
46      case weekday::wednesday:
47        return 3;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    