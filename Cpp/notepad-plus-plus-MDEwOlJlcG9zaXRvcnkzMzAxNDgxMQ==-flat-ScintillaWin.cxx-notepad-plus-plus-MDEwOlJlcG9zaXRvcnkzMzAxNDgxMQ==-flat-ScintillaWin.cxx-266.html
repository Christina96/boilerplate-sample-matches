
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaWin.cxx</h3>
            <pre><code>1  #include &lt;cstddef&gt;
2  #include &lt;cstdlib&gt;
3  #include &lt;cstdint&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstring&gt;
6  #include &lt;cstdio&gt;
7  #include &lt;cmath&gt;
8  #include &lt;climits&gt;
9  #include &lt;stdexcept&gt;
10  #include &lt;new&gt;
11  #include &lt;string&gt;
12  #include &lt;string_view&gt;
13  #include &lt;vector&gt;
14  #include &lt;map&gt;
15  #include &lt;set&gt;
16  #include &lt;optional&gt;
17  #include &lt;algorithm&gt;
18  #include &lt;memory&gt;
19  #include &lt;chrono&gt;
20  #include &lt;mutex&gt;
21  #if !defined(NOMINMAX)
22  #define NOMINMAX
23  #endif
24  #undef _WIN32_WINNT
25  #define _WIN32_WINNT 0x0A00
26  #undef WINVER
27  #define WINVER 0x0A00
28  #define WIN32_LEAN_AND_MEAN 1
29  #include &lt;windows.h&gt;
30  #include &lt;commctrl.h&gt;
31  #include &lt;richedit.h&gt;
32  #include &lt;windowsx.h&gt;
33  #include &lt;zmouse.h&gt;
34  #include &lt;ole2.h&gt;
35  #if !defined(DISABLE_D2D)
36  #define USE_D2D 1
37  #endif
38  #if defined(USE_D2D)
39  #include &lt;d2d1.h&gt;
40  #include &lt;dwrite.h&gt;
41  #endif
42  #include &quot;ScintillaTypes.h&quot;
43  #include &quot;ScintillaMessages.h&quot;
44  #include &quot;ScintillaStructures.h&quot;
45  #include &quot;ILoader.h&quot;
46  #include &quot;ILexer.h&quot;
47  #include &quot;Debugging.h&quot;
48  #include &quot;Geometry.h&quot;
49  #include &quot;Platform.h&quot;
50  #include &quot;CharacterCategoryMap.h&quot;
51  #include &quot;Position.h&quot;
52  #include &quot;UniqueString.h&quot;
53  #include &quot;SplitVector.h&quot;
54  #include &quot;Partitioning.h&quot;
55  #include &quot;RunStyles.h&quot;
56  #include &quot;ContractionState.h&quot;
57  #include &quot;CellBuffer.h&quot;
58  #include &quot;CallTip.h&quot;
59  #include &quot;KeyMap.h&quot;
60  #include &quot;Indicator.h&quot;
61  #include &quot;LineMarker.h&quot;
62  #include &quot;Style.h&quot;
63  #include &quot;ViewStyle.h&quot;
64  #include &quot;CharClassify.h&quot;
65  #include &quot;Decoration.h&quot;
66  #include &quot;CaseFolder.h&quot;
67  #include &quot;Document.h&quot;
68  #include &quot;CaseConvert.h&quot;
69  #include &quot;UniConversion.h&quot;
70  #include &quot;Selection.h&quot;
71  #include &quot;PositionCache.h&quot;
72  #include &quot;EditModel.h&quot;
73  #include &quot;MarginView.h&quot;
74  #include &quot;EditView.h&quot;
75  #include &quot;Editor.h&quot;
76  #include &quot;ElapsedPeriod.h&quot;
77  #include &quot;AutoComplete.h&quot;
78  #include &quot;ScintillaBase.h&quot;
79  #include &quot;WinTypes.h&quot;
80  #include &quot;PlatWin.h&quot;
81  #include &quot;HanjaDic.h&quot;
82  #include &quot;ScintillaWin.h&quot;
83  #include &quot;BoostRegexSearch.h&quot;
84  #ifndef SPI_GETWHEELSCROLLLINES
85  #define SPI_GETWHEELSCROLLLINES   104
86  #endif
87  #ifndef WM_UNICHAR
88  #define WM_UNICHAR                      0x0109
89  #endif
90  #ifndef WM_DPICHANGED
91  #define WM_DPICHANGED 0x02E0
92  #endif
93  #ifndef WM_DPICHANGED_AFTERPARENT
94  #define WM_DPICHANGED_AFTERPARENT 0x02E3
95  #endif
96  #ifndef UNICODE_NOCHAR
97  #define UNICODE_NOCHAR                  0xFFFF
98  #endif
99  #ifndef IS_HIGH_SURROGATE
100  #define IS_HIGH_SURROGATE(x)            ((x) &gt;= SURROGATE_LEAD_FIRST &amp;&amp; (x) &lt;= SURROGATE_LEAD_LAST)
101  #endif
102  #ifndef IS_LOW_SURROGATE
103  #define IS_LOW_SURROGATE(x)             ((x) &gt;= SURROGATE_TRAIL_FIRST &amp;&amp; (x) &lt;= SURROGATE_TRAIL_LAST)
104  #endif
105  #ifndef MK_ALT
106  #define MK_ALT 32
107  #endif
108  namespace {
109  constexpr UINT SC_WIN_IDLE = 5001;
110  constexpr UINT SC_WORK_IDLE = 5002;
111  constexpr int IndicatorInput = static_cast&lt;int&gt;(Scintilla::IndicatorNumbers::Ime);
112  constexpr int IndicatorTarget = IndicatorInput + 1;
113  constexpr int IndicatorConverted = IndicatorInput + 2;
114  constexpr int IndicatorUnknown = IndicatorInput + 3;
115  typedef UINT_PTR (WINAPI *SetCoalescableTimerSig)(HWND hwnd, UINT_PTR nIDEvent,
116  	UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay);
117  }
118  using namespace Scintilla;
119  using namespace Scintilla::Internal;
120  namespace {
121  const TCHAR callClassName[] = TEXT(&quot;CallTip&quot;);
122  void SetWindowID(HWND hWnd, int identifier) noexcept {
123  	::SetWindowLongPtr(hWnd, GWLP_ID, identifier);
124  }
125  Point PointFromLParam(sptr_t lpoint) noexcept {
126  	return Point::FromInts(GET_X_LPARAM(lpoint), GET_Y_LPARAM(lpoint));
127  }
128  bool KeyboardIsKeyDown(int key) noexcept {
129  	return (::GetKeyState(key) &amp; 0x80000000) != 0;
130  }
131  constexpr sptr_t extendedKeyboard = 1 &lt;&lt; 24;
132  constexpr bool KeyboardIsNumericKeypadFunction(uptr_t wParam, sptr_t lParam) {
133  	if ((lParam &amp; extendedKeyboard) != 0) {
134  		return false;
135  	}
136  	switch (wParam) {
137  	case VK_INSERT:	
138  	case VK_END:	
139  	case VK_DOWN:	
140  	case VK_NEXT:	
141  	case VK_LEFT:	
142  	case VK_CLEAR:	
143  	case VK_RIGHT:	
144  	case VK_HOME:	
145  	case VK_UP:		
146  	case VK_PRIOR:	
147  		return true;
148  	default:
149  		return false;
150  	}
151  }
152  class FormatEnumerator final : public IEnumFORMATETC {
153  public:
154  	ULONG ref;
155  	ULONG pos;
156  	std::vector&lt;CLIPFORMAT&gt; formats;
157  	FormatEnumerator(ULONG pos_, const CLIPFORMAT formats_[], size_t formatsLen_);
158  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
159  	STDMETHODIMP_(ULONG)AddRef() override;
160  	STDMETHODIMP_(ULONG)Release() override;
161  	STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched) override;
162  	STDMETHODIMP Skip(ULONG celt) override;
163  	STDMETHODIMP Reset() override;
164  	STDMETHODIMP Clone(IEnumFORMATETC **ppenum) override;
165  };
166  class DropSource final : public IDropSource {
167  public:
168  	ScintillaWin *sci = nullptr;
169  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
170  	STDMETHODIMP_(ULONG)AddRef() override;
171  	STDMETHODIMP_(ULONG)Release() override;
172  	STDMETHODIMP QueryContinueDrag(BOOL fEsc, DWORD grfKeyState) override;
173  	STDMETHODIMP GiveFeedback(DWORD) override;
174  };
175  class DataObject final : public IDataObject {
176  public:
177  	ScintillaWin *sci = nullptr;
178  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
179  	STDMETHODIMP_(ULONG)AddRef() override;
180  	STDMETHODIMP_(ULONG)Release() override;
181  	STDMETHODIMP GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) override;
182  	STDMETHODIMP GetDataHere(FORMATETC *, STGMEDIUM *) override;
183  	STDMETHODIMP QueryGetData(FORMATETC *pFE) override;
184  	STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *, FORMATETC *pFEOut)  override;
185  	STDMETHODIMP SetData(FORMATETC *, STGMEDIUM *, BOOL) override;
186  	STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum) override;
187  	STDMETHODIMP DAdvise(FORMATETC *, DWORD, IAdviseSink *, PDWORD) override;
188  	STDMETHODIMP DUnadvise(DWORD) override;
189  	STDMETHODIMP EnumDAdvise(IEnumSTATDATA **) override;
190  };
191  class DropTarget final : public IDropTarget {
192  public:
193  	ScintillaWin *sci = nullptr;
194  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
195  	STDMETHODIMP_(ULONG)AddRef() override;
196  	STDMETHODIMP_(ULONG)Release() override;
197  	STDMETHODIMP DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
198  	STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
199  	STDMETHODIMP DragLeave() override;
200  	STDMETHODIMP Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
201  };
202  class IMContext {
203  	HWND hwnd;
204  public:
205  	HIMC hIMC;
206  	IMContext(HWND hwnd_) noexcept :
207  		hwnd(hwnd_), hIMC(::ImmGetContext(hwnd_)) {
208  	}
209  	IMContext(const IMContext &amp;) = delete;
210  	IMContext(IMContext &amp;&amp;) = delete;
211  	IMContext &amp;operator=(const IMContext &amp;) = delete;
212  	IMContext &amp;operator=(IMContext &amp;&amp;) = delete;
213  	~IMContext() {
214  		if (hIMC)
215  			::ImmReleaseContext(hwnd, hIMC);
216  	}
217  	unsigned int GetImeCaretPos() const noexcept {
218  		return ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, nullptr, 0);
219  	}
220  	std::vector&lt;BYTE&gt; GetImeAttributes() {
221  		const int attrLen = ::ImmGetCompositionStringW(hIMC, GCS_COMPATTR, nullptr, 0);
222  		std::vector&lt;BYTE&gt; attr(attrLen, 0);
223  		::ImmGetCompositionStringW(hIMC, GCS_COMPATTR, &amp;attr[0], static_cast&lt;DWORD&gt;(attr.size()));
224  		return attr;
225  	}
226  	std::wstring GetCompositionString(DWORD dwIndex) {
227  		const LONG byteLen = ::ImmGetCompositionStringW(hIMC, dwIndex, nullptr, 0);
228  		std::wstring wcs(byteLen / 2, 0);
229  		::ImmGetCompositionStringW(hIMC, dwIndex, &amp;wcs[0], byteLen);
230  		return wcs;
231  	}
232  };
233  class GlobalMemory;
234  class ReverseArrowCursor {
235  	UINT dpi = USER_DEFAULT_SCREEN_DPI;
236  	HCURSOR cursor {};
237  public:
238  	ReverseArrowCursor() noexcept {}
239  	ReverseArrowCursor(const ReverseArrowCursor &amp;) = delete;
240  	ReverseArrowCursor(ReverseArrowCursor &amp;&amp;) = delete;
241  	ReverseArrowCursor &amp;operator=(const ReverseArrowCursor &amp;) = delete;
242  	ReverseArrowCursor &amp;operator=(ReverseArrowCursor &amp;&amp;) = delete;
243  	~ReverseArrowCursor() {
244  		if (cursor) {
245  			::DestroyCursor(cursor);
246  		}
247  	}
248  	HCURSOR Load(UINT dpi_) noexcept {
249  		if (cursor)	 {
250  			if (dpi == dpi_) {
251  				return cursor;
252  			}
253  			::DestroyCursor(cursor);
254  		}
255  		dpi = dpi_;
256  		cursor = LoadReverseArrowCursor(dpi_);
257  		return cursor ? cursor : ::LoadCursor({}, IDC_ARROW);
258  	}
259  };
260  struct HorizontalScrollRange {
261  	int pageWidth;
262  	int documentWidth;
263  };
264  }
265  namespace Scintilla::Internal {
266  class ScintillaWin :
267  	public ScintillaBase {
268  	bool lastKeyDownConsumed;
269  	wchar_t lastHighSurrogateChar;
270  	bool capturedMouse;
271  	bool trackedMouseLeave;
272  	SetCoalescableTimerSig SetCoalescableTimerFn;
273  	unsigned int linesPerScroll;	
274  	unsigned int charsPerScroll;	
275  	MouseWheelDelta verticalWheelDelta;
276  	MouseWheelDelta horizontalWheelDelta;
277  	UINT dpi = USER_DEFAULT_SCREEN_DPI;
278  	ReverseArrowCursor reverseArrowCursor;
279  	PRectangle rectangleClient;
280  	HRGN hRgnUpdate;
281  	bool hasOKText;
282  	CLIPFORMAT cfColumnSelect;
283  	CLIPFORMAT cfBorlandIDEBlockType;
284  	CLIPFORMAT cfLineSelect;
285  	CLIPFORMAT cfVSLineTag;
286  	HRESULT hrOle;
287  	DropSource ds;
288  	DataObject dob;
289  	DropTarget dt;
290  	static HINSTANCE hInstance;
291  	static ATOM scintillaClassAtom;
292  	static ATOM callClassAtom;
293  	int deviceScaleFactor = 1;
294  #if defined(USE_D2D)
295  	ID2D1RenderTarget *pRenderTarget;
296  	bool renderTargetValid;
297  	HMONITOR hCurrentMonitor;
298  	std::shared_ptr&lt;RenderingParams&gt; renderingParams;
299  #endif
300  	explicit ScintillaWin(HWND hwnd);
301  	ScintillaWin(const ScintillaWin &amp;) = delete;
302  	ScintillaWin(ScintillaWin &amp;&amp;) = delete;
303  	ScintillaWin &amp;operator=(const ScintillaWin &amp;) = delete;
304  	ScintillaWin &amp;operator=(ScintillaWin &amp;&amp;) = delete;
305  	void Finalise() override;
306  #if defined(USE_D2D)
307  	bool UpdateRenderingParams(bool force) noexcept;
308  	void EnsureRenderTarget(HDC hdc);
309  #endif
310  	void DropRenderTarget() noexcept;
311  	HWND MainHWND() const noexcept;
312  	static sptr_t DirectFunction(
313  		    sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam);
314  	static sptr_t DirectStatusFunction(
315  		    sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam, int *pStatus);
316  	static LRESULT PASCAL SWndProc(
317  		    HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
318  	static LRESULT PASCAL CTWndProc(
319  		    HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
320  	enum : UINT_PTR { invalidTimerID, standardTimerID, idleTimerID, fineTimerStart };
321  	void DisplayCursor(Window::Cursor c) override;
322  	bool DragThreshold(Point ptStart, Point ptNow) override;
323  	void StartDrag() override;
324  	static KeyMod MouseModifiers(uptr_t wParam) noexcept;
325  	Sci::Position TargetAsUTF8(char *text) const;
326  	Sci::Position EncodedFromUTF8(const char *utf8, char *encoded) const;
327  	void SetRenderingParams(Surface *psurf) const;
328  	bool PaintDC(HDC hdc);
329  	sptr_t WndPaint();
330  	void ImeStartComposition();
331  	void ImeEndComposition();
332  	LRESULT ImeOnReconvert(LPARAM lParam);
333  	LRESULT ImeOnDocumentFeed(LPARAM lParam) const;
334  	sptr_t HandleCompositionWindowed(uptr_t wParam, sptr_t lParam);
335  	sptr_t HandleCompositionInline(uptr_t wParam, sptr_t lParam);
336  	static bool KoreanIME() noexcept;
337  	void MoveImeCarets(Sci::Position offset) noexcept;
338  	void DrawImeIndicator(int indicator, Sci::Position len);
339  	void SetCandidateWindowPos();
340  	void SelectionToHangul();
341  	void EscapeHanja();
342  	void ToggleHanja();
343  	void AddWString(std::wstring_view wsv, CharacterSource charSource);
344  	UINT CodePageOfDocument() const noexcept;
345  	bool ValidCodePage(int codePage) const override;
346  	std::string UTF8FromEncoded(std::string_view encoded) const override;
347  	std::string EncodedFromUTF8(std::string_view utf8) const override;
348  	std::string EncodeWString(std::wstring_view wsv);
349  	sptr_t DefWndProc(Message iMessage, uptr_t wParam, sptr_t lParam) override;
350  	void IdleWork() override;
351  	void QueueIdleWork(WorkItems items, Sci::Position upTo) override;
352  	bool SetIdle(bool on) override;
353  	UINT_PTR timers[static_cast&lt;int&gt;(TickReason::dwell)+1] {};
354  	bool FineTickerRunning(TickReason reason) override;
355  	void FineTickerStart(TickReason reason, int millis, int tolerance) override;
356  	void FineTickerCancel(TickReason reason) override;
357  	void SetMouseCapture(bool on) override;
358  	bool HaveMouseCapture() override;
359  	void SetTrackMouseLeaveEvent(bool on) noexcept;
360  	void UpdateBaseElements() override;
361  	bool PaintContains(PRectangle rc) override;
362  	void ScrollText(Sci::Line linesToMove) override;
363  	void NotifyCaretMove() override;
364  	void UpdateSystemCaret() override;
365  	void SetVerticalScrollPos() override;
366  	void SetHorizontalScrollPos() override;
367  	void HorizontalScrollToClamped(int xPos);
368  	HorizontalScrollRange GetHorizontalScrollRange() const;
369  	bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) override;
370  	void NotifyChange() override;
371  	void NotifyFocus(bool focus) override;
372  	void SetCtrlID(int identifier) override;
373  	int GetCtrlID() override;
374  	void NotifyParent(NotificationData scn) override;
375  	void NotifyDoubleClick(Point pt, KeyMod modifiers) override;
376  	std::unique_ptr&lt;CaseFolder&gt; CaseFolderForEncoding() override;
377  	std::string CaseMapString(const std::string &amp;s, CaseMapping caseMapping) override;
378  	void Copy() override;
379  	bool CanPaste() override;
380  	void Paste() override;
381  	void CreateCallTipWindow(PRectangle rc) override;
382  	void AddToPopUp(const char *label, int cmd = 0, bool enabled = true) override;
383  	void ClaimSelection() override;
384  	void GetIntelliMouseParameters() noexcept;
385  	void CopyToGlobal(GlobalMemory &amp;gmUnicode, const SelectionText &amp;selectedText);
386  	void CopyToClipboard(const SelectionText &amp;selectedText) override;
387  	void ScrollMessage(WPARAM wParam);
388  	void HorizontalScrollMessage(WPARAM wParam);
389  	void FullPaint();
390  	void FullPaintDC(HDC hdc);
391  	bool IsCompatibleDC(HDC hOtherDC) noexcept;
392  	DWORD EffectFromState(DWORD grfKeyState) const noexcept;
393  	bool IsVisible() const noexcept;
394  	int SetScrollInfo(int nBar, LPCSCROLLINFO lpsi, BOOL bRedraw) noexcept;
395  	bool GetScrollInfo(int nBar, LPSCROLLINFO lpsi) noexcept;
396  	bool ChangeScrollRange(int nBar, int nMin, int nMax, UINT nPage) noexcept;
397  	void ChangeScrollPos(int barType, Sci::Position pos);
398  	sptr_t GetTextLength();
399  	sptr_t GetText(uptr_t wParam, sptr_t lParam);
400  	Window::Cursor ContextCursor(Point pt);
401  	sptr_t ShowContextMenu(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
402  	PRectangle GetClientRectangle() const override;
403  	void SizeWindow();
404  	sptr_t MouseMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
405  	sptr_t KeyMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
406  	sptr_t FocusMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
407  	sptr_t IMEMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
408  	sptr_t EditMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
<span onclick='openModal()' class='match'>409  	sptr_t IdleMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
410  	sptr_t SciMessage(Message iMessage, uptr_t wParam, sptr_t lParam);
</span>411  public:
412  	~ScintillaWin() override;
413  	sptr_t WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) override;
414  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);
415  	STDMETHODIMP_(ULONG)AddRef();
416  	STDMETHODIMP_(ULONG)Release();
417  	STDMETHODIMP DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
418  	                       POINTL pt, PDWORD pdwEffect);
419  	STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect);
420  	STDMETHODIMP DragLeave();
421  	STDMETHODIMP Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
422  	                  POINTL pt, PDWORD pdwEffect);
423  	STDMETHODIMP GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM);
424  	static void Prepare() noexcept;
425  	static bool Register(HINSTANCE hInstance_) noexcept;
426  	static bool Unregister() noexcept;
427  	bool DragIsRectangularOK(CLIPFORMAT fmt) const noexcept {
428  		return drag.rectangular &amp;&amp; (fmt == cfColumnSelect);
429  	}
430  private:
431  	bool HasCaretSizeChanged() const noexcept;
432  	BOOL CreateSystemCaret();
433  	BOOL DestroySystemCaret() noexcept;
434  	HBITMAP sysCaretBitmap;
435  	int sysCaretWidth;
436  	int sysCaretHeight;
437  	bool styleIdleInQueue;
438  };
439  HINSTANCE ScintillaWin::hInstance {};
440  ATOM ScintillaWin::scintillaClassAtom = 0;
441  ATOM ScintillaWin::callClassAtom = 0;
442  ScintillaWin::ScintillaWin(HWND hwnd) {
443  	lastKeyDownConsumed = false;
444  	lastHighSurrogateChar = 0;
445  	capturedMouse = false;
446  	trackedMouseLeave = false;
447  	SetCoalescableTimerFn = nullptr;
448  	linesPerScroll = 0;
449  	charsPerScroll = 0;
450  	dpi = DpiForWindow(hwnd);
451  	hRgnUpdate = {};
452  	hasOKText = false;
453  	cfColumnSelect = static_cast&lt;CLIPFORMAT&gt;(
454  		::RegisterClipboardFormat(TEXT(&quot;MSDEVColumnSelect&quot;)));
455  	cfBorlandIDEBlockType = static_cast&lt;CLIPFORMAT&gt;(
456  		::RegisterClipboardFormat(TEXT(&quot;Borland IDE Block Type&quot;)));
457  	cfLineSelect = static_cast&lt;CLIPFORMAT&gt;(
458  		::RegisterClipboardFormat(TEXT(&quot;MSDEVLineSelect&quot;)));
459  	cfVSLineTag = static_cast&lt;CLIPFORMAT&gt;(
460  		::RegisterClipboardFormat(TEXT(&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag&quot;)));
461  	hrOle = E_FAIL;
462  	wMain = hwnd;
463  	dob.sci = this;
464  	ds.sci = this;
465  	dt.sci = this;
466  	sysCaretBitmap = {};
467  	sysCaretWidth = 0;
468  	sysCaretHeight = 0;
469  	styleIdleInQueue = false;
470  #if defined(USE_D2D)
471  	pRenderTarget = nullptr;
472  	renderTargetValid = true;
473  	hCurrentMonitor = {};
474  #endif
475  	caret.period = ::GetCaretBlinkTime();
476  	if (caret.period &lt; 0)
477  		caret.period = 0;
478  	hrOle = ::OleInitialize(nullptr);
479  	HMODULE user32 = ::GetModuleHandleW(L&quot;user32.dll&quot;);
480  	SetCoalescableTimerFn = DLLFunction&lt;SetCoalescableTimerSig&gt;(user32, &quot;SetCoalescableTimer&quot;);
481  	vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, ColourRGBA(0, 0, 0xff));
482  	vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, ColourRGBA(0, 0, 0xff));
483  	vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, ColourRGBA(0, 0, 0xff));
484  	vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, ColourRGBA(0, 0, 0xff));
485  }
486  ScintillaWin::~ScintillaWin() {
487  	if (sysCaretBitmap) {
488  		::DeleteObject(sysCaretBitmap);
489  		sysCaretBitmap = {};
490  	}
491  }
492  void ScintillaWin::Finalise() {
493  	ScintillaBase::Finalise();
494  	for (TickReason tr = TickReason::caret; tr &lt;= TickReason::dwell;
495  		tr = static_cast&lt;TickReason&gt;(static_cast&lt;int&gt;(tr) + 1)) {
496  		FineTickerCancel(tr);
497  	}
498  	SetIdle(false);
499  	DropRenderTarget();
500  	::RevokeDragDrop(MainHWND());
501  	if (SUCCEEDED(hrOle)) {
502  		::OleUninitialize();
503  	}
504  }
505  #if defined(USE_D2D)
506  bool ScintillaWin::UpdateRenderingParams(bool force) noexcept {
507  	if (!renderingParams) {
508  		try {
509  			renderingParams = std::make_shared&lt;RenderingParams&gt;();
510  		} catch (const std::bad_alloc &amp;) {
511  			return false;
512  		}
513  	}
514  	const HWND hRootWnd = ::GetAncestor(MainHWND(), GA_ROOT);
515  	const HMONITOR monitor = Internal::MonitorFromWindowHandleScaling(hRootWnd);
516  	if (!force &amp;&amp; monitor == hCurrentMonitor &amp;&amp; renderingParams-&gt;defaultRenderingParams) {
517  		return false;
518  	}
519  	IDWriteRenderingParams *monitorRenderingParams = nullptr;
520  	IDWriteRenderingParams *customClearTypeRenderingParams = nullptr;
521  	const HRESULT hr = pIDWriteFactory-&gt;CreateMonitorRenderingParams(monitor, &amp;monitorRenderingParams);
522  	UINT clearTypeContrast = 0;
523  	if (SUCCEEDED(hr) &amp;&amp; ::SystemParametersInfo(SPI_GETFONTSMOOTHINGCONTRAST, 0, &amp;clearTypeContrast, 0) != 0) {
524  		if (clearTypeContrast &gt;= 1000 &amp;&amp; clearTypeContrast &lt;= 2200) {
525  			const FLOAT gamma = static_cast&lt;FLOAT&gt;(clearTypeContrast) / 1000.0f;
526  			pIDWriteFactory-&gt;CreateCustomRenderingParams(gamma,
527  				monitorRenderingParams-&gt;GetEnhancedContrast(),
528  				monitorRenderingParams-&gt;GetClearTypeLevel(),
529  				monitorRenderingParams-&gt;GetPixelGeometry(),
530  				monitorRenderingParams-&gt;GetRenderingMode(),
531  				&amp;customClearTypeRenderingParams);
532  		}
533  	}
534  	hCurrentMonitor = monitor;
535  	deviceScaleFactor = Internal::GetDeviceScaleFactorWhenGdiScalingActive(hRootWnd);
536  	renderingParams-&gt;defaultRenderingParams.reset(monitorRenderingParams);
537  	renderingParams-&gt;customRenderingParams.reset(customClearTypeRenderingParams);
538  	return true;
539  }
540  namespace {
541  D2D1_SIZE_U GetSizeUFromRect(const RECT &amp;rc, const int scaleFactor) noexcept {
542  	const long width = rc.right - rc.left;
543  	const long height = rc.bottom - rc.top;
544  	const UINT32 scaledWidth = width * scaleFactor;
545  	const UINT32 scaledHeight = height * scaleFactor;
546  	return D2D1::SizeU(scaledWidth, scaledHeight);
547  }
548  }
549  void ScintillaWin::EnsureRenderTarget(HDC hdc) {
550  	if (!renderTargetValid) {
551  		DropRenderTarget();
552  		renderTargetValid = true;
553  	}
554  	if (!pRenderTarget) {
555  		HWND hw = MainHWND();
556  		RECT rc;
557  		::GetClientRect(hw, &amp;rc);
558  		D2D1_RENDER_TARGET_PROPERTIES drtp {};
559  		drtp.type = D2D1_RENDER_TARGET_TYPE_DEFAULT;
560  		drtp.usage = D2D1_RENDER_TARGET_USAGE_NONE;
561  		drtp.minLevel = D2D1_FEATURE_LEVEL_DEFAULT;
562  		if (technology == Technology::DirectWriteDC) {
563  			drtp.dpiX = 96.f;
564  			drtp.dpiY = 96.f;
565  			drtp.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM,
566  				D2D1_ALPHA_MODE_IGNORE);
567  			ID2D1DCRenderTarget *pDCRT = nullptr;
568  			const HRESULT hr = pD2DFactory-&gt;CreateDCRenderTarget(&amp;drtp, &amp;pDCRT);
569  			if (SUCCEEDED(hr)) {
570  				pRenderTarget = pDCRT;
571  			} else {
572  				Platform::DebugPrintf(&quot;Failed CreateDCRenderTarget 0x%lx\n&quot;, hr);
573  				pRenderTarget = nullptr;
574  			}
575  		} else {
576  			drtp.dpiX = 96.f * deviceScaleFactor;
577  			drtp.dpiY = 96.f * deviceScaleFactor;
578  			drtp.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
579  				D2D1_ALPHA_MODE_UNKNOWN);
580  			D2D1_HWND_RENDER_TARGET_PROPERTIES dhrtp {};
581  			dhrtp.hwnd = hw;
582  			dhrtp.pixelSize = ::GetSizeUFromRect(rc, deviceScaleFactor);
583  			dhrtp.presentOptions = (technology == Technology::DirectWriteRetain) ?
584  			D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS : D2D1_PRESENT_OPTIONS_NONE;
585  			ID2D1HwndRenderTarget *pHwndRenderTarget = nullptr;
586  			const HRESULT hr = pD2DFactory-&gt;CreateHwndRenderTarget(drtp, dhrtp, &amp;pHwndRenderTarget);
587  			if (SUCCEEDED(hr)) {
588  				pRenderTarget = pHwndRenderTarget;
589  			} else {
590  				Platform::DebugPrintf(&quot;Failed CreateHwndRenderTarget 0x%lx\n&quot;, hr);
591  				pRenderTarget = nullptr;
592  			}
593  		}
594  		DropGraphics();
595  	}
596  	if ((technology == Technology::DirectWriteDC) &amp;&amp; pRenderTarget) {
597  		RECT rcWindow;
598  		::GetClientRect(MainHWND(), &amp;rcWindow);
599  		const HRESULT hr = static_cast&lt;ID2D1DCRenderTarget*&gt;(pRenderTarget)-&gt;BindDC(hdc, &amp;rcWindow);
600  		if (FAILED(hr)) {
601  			Platform::DebugPrintf(&quot;BindDC failed 0x%lx\n&quot;, hr);
602  			DropRenderTarget();
603  		}
604  	}
605  }
606  #endif
607  void ScintillaWin::DropRenderTarget() noexcept {
608  #if defined(USE_D2D)
609  	ReleaseUnknown(pRenderTarget);
610  #endif
611  }
612  HWND ScintillaWin::MainHWND() const noexcept {
613  	return HwndFromWindow(wMain);
614  }
615  void ScintillaWin::DisplayCursor(Window::Cursor c) {
616  	if (cursorMode != CursorShape::Normal) {
617  		c = static_cast&lt;Window::Cursor&gt;(cursorMode);
618  	}
619  	if (c == Window::Cursor::reverseArrow) {
620  		::SetCursor(reverseArrowCursor.Load(dpi));
621  	} else {
622  		wMain.SetCursor(c);
623  	}
624  }
625  bool ScintillaWin::DragThreshold(Point ptStart, Point ptNow) {
626  	const Point ptDifference = ptStart - ptNow;
627  	const XYPOSITION xMove = std::trunc(std::abs(ptDifference.x));
628  	const XYPOSITION yMove = std::trunc(std::abs(ptDifference.y));
629  	return (xMove &gt; SystemMetricsForDpi(SM_CXDRAG, dpi)) ||
630  		(yMove &gt; SystemMetricsForDpi(SM_CYDRAG, dpi));
631  }
632  void ScintillaWin::StartDrag() {
633  	inDragDrop = DragDrop::dragging;
634  	DWORD dwEffect = 0;
635  	dropWentOutside = true;
636  	IDataObject *pDataObject = &amp;dob;
637  	IDropSource *pDropSource = &amp;ds;
638  	const HRESULT hr = ::DoDragDrop(
639  	                 pDataObject,
640  	                 pDropSource,
641  	                 DROPEFFECT_COPY | DROPEFFECT_MOVE, &amp;dwEffect);
642  	if (SUCCEEDED(hr)) {
643  		if ((hr == DRAGDROP_S_DROP) &amp;&amp; (dwEffect == DROPEFFECT_MOVE) &amp;&amp; dropWentOutside) {
644  			ClearSelection();
645  		}
646  	}
647  	inDragDrop = DragDrop::none;
648  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
649  }
650  KeyMod ScintillaWin::MouseModifiers(uptr_t wParam) noexcept {
651  	return ModifierFlags(
652  		(wParam &amp; MK_SHIFT) != 0,
653  		(wParam &amp; MK_CONTROL) != 0,
654  		KeyboardIsKeyDown(VK_MENU));
655  }
656  }
657  namespace {
658  int InputCodePage() noexcept {
659  	HKL inputLocale = ::GetKeyboardLayout(0);
660  	const LANGID inputLang = LOWORD(inputLocale);
661  	char sCodePage[10];
662  	const int res = ::GetLocaleInfoA(MAKELCID(inputLang, SORT_DEFAULT),
663  	  LOCALE_IDEFAULTANSICODEPAGE, sCodePage, sizeof(sCodePage));
664  	if (!res)
665  		return 0;
666  	return atoi(sCodePage);
667  }
668  Keys KeyTranslate(uptr_t keyIn) noexcept {
669  	switch (keyIn) {
670  	case VK_DOWN:		return Keys::Down;
671  		case VK_UP:		return Keys::Up;
672  		case VK_LEFT:		return Keys::Left;
673  		case VK_RIGHT:		return Keys::Right;
674  		case VK_HOME:		return Keys::Home;
675  		case VK_END:		return Keys::End;
676  		case VK_PRIOR:		return Keys::Prior;
677  		case VK_NEXT:		return Keys::Next;
678  		case VK_DELETE:	return Keys::Delete;
679  		case VK_INSERT:		return Keys::Insert;
680  		case VK_ESCAPE:	return Keys::Escape;
681  		case VK_BACK:		return Keys::Back;
682  		case VK_TAB:		return Keys::Tab;
683  		case VK_RETURN:	return Keys::Return;
684  		case VK_ADD:		return Keys::Add;
685  		case VK_SUBTRACT:	return Keys::Subtract;
686  		case VK_DIVIDE:		return Keys::Divide;
687  		case VK_LWIN:		return Keys::Win;
688  		case VK_RWIN:		return Keys::RWin;
689  		case VK_APPS:		return Keys::Menu;
690  		case VK_OEM_2:		return static_cast&lt;Keys&gt;(&#x27;/&#x27;);
691  		case VK_OEM_3:		return static_cast&lt;Keys&gt;(&#x27;`&#x27;);
692  		case VK_OEM_4:		return static_cast&lt;Keys&gt;(&#x27;[&#x27;);
693  		case VK_OEM_5:		return static_cast&lt;Keys&gt;(&#x27;\\&#x27;);
694  		case VK_OEM_6:		return static_cast&lt;Keys&gt;(&#x27;]&#x27;);
695  		default:			return static_cast&lt;Keys&gt;(keyIn);
696  	}
697  }
698  bool BoundsContains(PRectangle rcBounds, HRGN hRgnBounds, PRectangle rcCheck) noexcept {
699  	bool contains = true;
700  	if (!rcCheck.Empty()) {
701  		if (!rcBounds.Contains(rcCheck)) {
702  			contains = false;
703  		} else if (hRgnBounds) {
704  			const RECT rcw = RectFromPRectangle(rcCheck);
705  			HRGN hRgnCheck = ::CreateRectRgnIndirect(&amp;rcw);
706  			if (hRgnCheck) {
707  				HRGN hRgnDifference = ::CreateRectRgn(0, 0, 0, 0);
708  				if (hRgnDifference) {
709  					const int combination = ::CombineRgn(hRgnDifference, hRgnCheck, hRgnBounds, RGN_DIFF);
710  					if (combination != NULLREGION) {
711  						contains = false;
712  					}
713  					::DeleteRgn(hRgnDifference);
714  				}
715  				::DeleteRgn(hRgnCheck);
716  			}
717  		}
718  	}
719  	return contains;
720  }
721  int MultiByteFromWideChar(UINT codePage, std::wstring_view wsv, LPSTR lpMultiByteStr, ptrdiff_t cbMultiByte) noexcept {
722  	return ::WideCharToMultiByte(codePage, 0, wsv.data(), static_cast&lt;int&gt;(wsv.length()), lpMultiByteStr, static_cast&lt;int&gt;(cbMultiByte), nullptr, nullptr);
723  }
724  int MultiByteLenFromWideChar(UINT codePage, std::wstring_view wsv) noexcept {
725  	return MultiByteFromWideChar(codePage, wsv, nullptr, 0);
726  }
727  int WideCharFromMultiByte(UINT codePage, std::string_view sv, LPWSTR lpWideCharStr, ptrdiff_t cchWideChar) noexcept {
728  	return ::MultiByteToWideChar(codePage, 0, sv.data(), static_cast&lt;int&gt;(sv.length()), lpWideCharStr, static_cast&lt;int&gt;(cchWideChar));
729  }
730  int WideCharLenFromMultiByte(UINT codePage, std::string_view sv) noexcept {
731  	return WideCharFromMultiByte(codePage, sv, nullptr, 0);
732  }
733  std::string StringEncode(std::wstring_view wsv, int codePage) {
734  	const int cchMulti = wsv.length() ? MultiByteLenFromWideChar(codePage, wsv) : 0;
735  	std::string sMulti(cchMulti, 0);
736  	if (cchMulti) {
737  		MultiByteFromWideChar(codePage, wsv, sMulti.data(), cchMulti);
738  	}
739  	return sMulti;
740  }
741  std::wstring StringDecode(std::string_view sv, int codePage) {
742  	const int cchWide = sv.length() ? WideCharLenFromMultiByte(codePage, sv) : 0;
743  	std::wstring sWide(cchWide, 0);
744  	if (cchWide) {
745  		WideCharFromMultiByte(codePage, sv, sWide.data(), cchWide);
746  	}
747  	return sWide;
748  }
749  std::wstring StringMapCase(std::wstring_view wsv, DWORD mapFlags) {
750  	const int charsConverted = ::LCMapStringW(LOCALE_SYSTEM_DEFAULT, mapFlags,
751  		wsv.data(), static_cast&lt;int&gt;(wsv.length()), nullptr, 0);
752  	std::wstring wsConverted(charsConverted, 0);
753  	if (charsConverted) {
754  		::LCMapStringW(LOCALE_SYSTEM_DEFAULT, mapFlags,
755  			wsv.data(), static_cast&lt;int&gt;(wsv.length()), wsConverted.data(), charsConverted);
756  	}
757  	return wsConverted;
758  }
759  }
760  Sci::Position ScintillaWin::TargetAsUTF8(char *text) const {
761  	const Sci::Position targetLength = targetRange.Length();
762  	if (IsUnicodeMode()) {
763  		if (text) {
764  			pdoc-&gt;GetCharRange(text, targetRange.start.Position(), targetLength);
765  		}
766  	} else {
767  		const std::string s = RangeText(targetRange.start.Position(), targetRange.end.Position());
768  		const std::wstring characters = StringDecode(s, CodePageOfDocument());
769  		const int utf8Len = MultiByteLenFromWideChar(CpUtf8, characters);
770  		if (text) {
771  			MultiByteFromWideChar(CpUtf8, characters, text, utf8Len);
772  			text[utf8Len] = &#x27;\0&#x27;;
773  		}
774  		return utf8Len;
775  	}
776  	return targetLength;
777  }
778  Sci::Position ScintillaWin::EncodedFromUTF8(const char *utf8, char *encoded) const {
779  	const Sci::Position inputLength = (lengthForEncode &gt;= 0) ? lengthForEncode : strlen(utf8);
780  	if (IsUnicodeMode()) {
781  		if (encoded) {
782  			memcpy(encoded, utf8, inputLength);
783  		}
784  		return inputLength;
785  	} else {
786  		const std::string_view utf8Input(utf8, inputLength);
787  		const int charsLen = WideCharLenFromMultiByte(CpUtf8, utf8Input);
788  		std::wstring characters(charsLen, L&#x27;\0&#x27;);
789  		WideCharFromMultiByte(CpUtf8, utf8Input, &amp;characters[0], charsLen);
790  		const int encodedLen = MultiByteLenFromWideChar(CodePageOfDocument(), characters);
791  		if (encoded) {
792  			MultiByteFromWideChar(CodePageOfDocument(), characters, encoded, encodedLen);
793  			encoded[encodedLen] = &#x27;\0&#x27;;
794  		}
795  		return encodedLen;
796  	}
797  }
798  void ScintillaWin::SetRenderingParams([[maybe_unused]] Surface *psurf) const {
799  #if defined(USE_D2D)
800  	if (psurf) {
801  		ISetRenderingParams *setDrawingParams = dynamic_cast&lt;ISetRenderingParams *&gt;(psurf);
802  		if (setDrawingParams) {
803  			setDrawingParams-&gt;SetRenderingParams(renderingParams);
804  		}
805  	}
806  #endif
807  }
808  bool ScintillaWin::PaintDC(HDC hdc) {
809  	if (technology == Technology::Default) {
810  		AutoSurface surfaceWindow(hdc, this);
811  		if (surfaceWindow) {
812  			Paint(surfaceWindow, rcPaint);
813  			surfaceWindow-&gt;Release();
814  		}
815  	} else {
816  #if defined(USE_D2D)
817  		EnsureRenderTarget(hdc);
818  		if (pRenderTarget) {
819  			AutoSurface surfaceWindow(pRenderTarget, this);
820  			if (surfaceWindow) {
821  				SetRenderingParams(surfaceWindow);
822  				pRenderTarget-&gt;BeginDraw();
823  				Paint(surfaceWindow, rcPaint);
824  				surfaceWindow-&gt;Release();
825  				const HRESULT hr = pRenderTarget-&gt;EndDraw();
826  				if (hr == static_cast&lt;HRESULT&gt;(D2DERR_RECREATE_TARGET)) {
827  					DropRenderTarget();
828  					return false;
829  				}
830  			}
831  		}
832  #endif
833  	}
834  	return true;
835  }
836  sptr_t ScintillaWin::WndPaint() {
837  	const bool assertsPopup = Platform::ShowAssertionPopUps(false);
838  	paintState = PaintState::painting;
839  	PAINTSTRUCT ps = {};
840  	hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
841  	::GetUpdateRgn(MainHWND(), hRgnUpdate, FALSE);
842  	::BeginPaint(MainHWND(), &amp;ps);
843  	rcPaint = PRectangle::FromInts(ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom);
844  	const PRectangle rcClient = GetClientRectangle();
845  	paintingAllText = BoundsContains(rcPaint, hRgnUpdate, rcClient);
846  	if (!PaintDC(ps.hdc)) {
847  		paintState = PaintState::abandoned;
848  	}
849  	if (hRgnUpdate) {
850  		::DeleteRgn(hRgnUpdate);
851  		hRgnUpdate = {};
852  	}
853  	::EndPaint(MainHWND(), &amp;ps);
854  	if (paintState == PaintState::abandoned) {
855  		FullPaint();
856  		::ValidateRect(MainHWND(), nullptr);
857  	}
858  	paintState = PaintState::notPainting;
859  	Platform::ShowAssertionPopUps(assertsPopup);
860  	return 0;
861  }
862  sptr_t ScintillaWin::HandleCompositionWindowed(uptr_t wParam, sptr_t lParam) {
863  	if (lParam &amp; GCS_RESULTSTR) {
864  		IMContext imc(MainHWND());
865  		if (imc.hIMC) {
866  			AddWString(imc.GetCompositionString(GCS_RESULTSTR), CharacterSource::ImeResult);
867  			const Point pos = PointMainCaret();
868  			COMPOSITIONFORM CompForm {};
869  			CompForm.dwStyle = CFS_POINT;
870  			CompForm.ptCurrentPos = POINTFromPoint(pos);
871  			::ImmSetCompositionWindow(imc.hIMC, &amp;CompForm);
872  		}
873  		return 0;
874  	}
875  	return ::DefWindowProc(MainHWND(), WM_IME_COMPOSITION, wParam, lParam);
876  }
877  bool ScintillaWin::KoreanIME() noexcept {
878  	const int codePage = InputCodePage();
879  	return codePage == 949 || codePage == 1361;
880  }
881  void ScintillaWin::MoveImeCarets(Sci::Position offset) noexcept {
882  	for (size_t r=0; r&lt;sel.Count(); r++) {
883  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
884  		sel.Range(r).caret.SetPosition(positionInsert + offset);
885  		sel.Range(r).anchor.SetPosition(positionInsert + offset);
886  	}
887  }
888  void ScintillaWin::DrawImeIndicator(int indicator, Sci::Position len) {
889  	if (indicator &lt; 8 || indicator &gt; IndicatorMax) {
890  		return;
891  	}
892  	pdoc-&gt;DecorationSetCurrentIndicator(indicator);
893  	for (size_t r=0; r&lt;sel.Count(); r++) {
894  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
895  		pdoc-&gt;DecorationFillRange(positionInsert - len, 1, len);
896  	}
897  }
898  void ScintillaWin::SetCandidateWindowPos() {
899  	IMContext imc(MainHWND());
900  	if (imc.hIMC) {
901  		const Point pos = PointMainCaret();
902  		const PRectangle rcClient = GetTextRectangle();
903  		CANDIDATEFORM CandForm{};
904  		CandForm.dwIndex = 0;
905  		CandForm.dwStyle = CFS_EXCLUDE;
906  		CandForm.ptCurrentPos.x = static_cast&lt;int&gt;(pos.x);
907  		CandForm.ptCurrentPos.y = static_cast&lt;int&gt;(pos.y + std::max(4, vs.lineHeight/4));
908  		CandForm.rcArea.top = static_cast&lt;int&gt;(pos.y);
909  		CandForm.rcArea.bottom = static_cast&lt;int&gt;(pos.y + vs.lineHeight);
910  		CandForm.rcArea.left = static_cast&lt;int&gt;(rcClient.left);
911  		CandForm.rcArea.right = static_cast&lt;int&gt;(rcClient.right);
912  		::ImmSetCandidateWindow(imc.hIMC, &amp;CandForm);
913  	}
914  }
915  void ScintillaWin::SelectionToHangul() {
916  	const Sci::Position selStart = sel.RangeMain().Start().Position();
917  	const Sci::Position documentStrLen = sel.RangeMain().Length();
918  	const Sci::Position selEnd = selStart + documentStrLen;
919  	const Sci::Position utf16Len = pdoc-&gt;CountUTF16(selStart, selEnd);
920  	if (utf16Len &gt; 0) {
921  		std::string documentStr(documentStrLen, &#x27;\0&#x27;);
922  		pdoc-&gt;GetCharRange(&amp;documentStr[0], selStart, documentStrLen);
923  		std::wstring uniStr = StringDecode(documentStr, CodePageOfDocument());
924  		const bool converted = HanjaDict::GetHangulOfHanja(uniStr);
925  		if (converted) {
926  			documentStr = StringEncode(uniStr, CodePageOfDocument());
927  			pdoc-&gt;BeginUndoAction();
928  			ClearSelection();
929  			InsertPaste(&amp;documentStr[0], documentStr.size());
930  			pdoc-&gt;EndUndoAction();
931  		}
932  	}
933  }
934  void ScintillaWin::EscapeHanja() {
935  	if (sel.Count() &gt; 1) {
936  		return; 
937  	}
938  	const Sci::Position currentPos = CurrentPosition();
939  	const int oneCharLen = pdoc-&gt;LenChar(currentPos);
940  	if (oneCharLen &lt; 2) {
941  		return; 
942  	}
943  	constexpr size_t safeLength = UTF8MaxBytes + 1;
944  	std::string oneChar(safeLength, &#x27;\0&#x27;);
945  	pdoc-&gt;GetCharRange(&amp;oneChar[0], currentPos, oneCharLen);
946  	std::wstring uniChar = StringDecode(oneChar, CodePageOfDocument());
947  	IMContext imc(MainHWND());
948  	if (imc.hIMC) {
949  		SetCandidateWindowPos();
950  		if (::ImmEscapeW(GetKeyboardLayout(0), imc.hIMC, IME_ESC_HANJA_MODE, &amp;uniChar[0])) {
951  			SetSelection(currentPos, currentPos + oneCharLen);
952  		}
953  	}
954  }
955  void ScintillaWin::ToggleHanja() {
956  	if (sel.Count() &gt; 1) {
957  		return; 
958  	}
959  	if (sel.Empty()) {
960  		EscapeHanja();
961  	} else {
962  		SelectionToHangul();
963  	}
964  }
965  namespace {
966  std::vector&lt;int&gt; MapImeIndicators(std::vector&lt;BYTE&gt; inputStyle) {
967  	std::vector&lt;int&gt; imeIndicator(inputStyle.size(), IndicatorUnknown);
968  	for (size_t i = 0; i &lt; inputStyle.size(); i++) {
969  		switch (static_cast&lt;int&gt;(inputStyle.at(i))) {
970  		case ATTR_INPUT:
971  			imeIndicator[i] = IndicatorInput;
972  			break;
973  		case ATTR_TARGET_NOTCONVERTED:
974  		case ATTR_TARGET_CONVERTED:
975  			imeIndicator[i] = IndicatorTarget;
976  			break;
977  		case ATTR_CONVERTED:
978  			imeIndicator[i] = IndicatorConverted;
979  			break;
980  		default:
981  			imeIndicator[i] = IndicatorUnknown;
982  			break;
983  		}
984  	}
985  	return imeIndicator;
986  }
987  }
988  void ScintillaWin::AddWString(std::wstring_view wsv, CharacterSource charSource) {
989  	if (wsv.empty())
990  		return;
991  	const int codePage = CodePageOfDocument();
992  	for (size_t i = 0; i &lt; wsv.size(); ) {
993  		const size_t ucWidth = UTF16CharLength(wsv[i]);
994  		const std::string docChar = StringEncode(wsv.substr(i, ucWidth), codePage);
995  		InsertCharacter(docChar, charSource);
996  		i += ucWidth;
997  	}
998  }
999  sptr_t ScintillaWin::HandleCompositionInline(uptr_t, sptr_t lParam) {
1000  	IMContext imc(MainHWND());
1001  	if (!imc.hIMC)
1002  		return 0;
1003  	if (pdoc-&gt;IsReadOnly() || SelectionContainsProtected()) {
1004  		::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
1005  		return 0;
1006  	}
1007  	bool initialCompose = false;
1008  	if (pdoc-&gt;TentativeActive()) {
1009  		pdoc-&gt;TentativeUndo();
1010  	} else {
1011  		initialCompose = true;
1012  	}
1013  	view.imeCaretBlockOverride = false;
1014  	if (lParam &amp; GCS_RESULTSTR) {
1015  		AddWString(imc.GetCompositionString(GCS_RESULTSTR), CharacterSource::ImeResult);
1016  	}
1017  	if (lParam &amp; GCS_COMPSTR) {
1018  		const std::wstring wcs = imc.GetCompositionString(GCS_COMPSTR);
1019  		if (wcs.empty()) {
1020  			ShowCaretAtCurrentPosition();
1021  			return 0;
1022  		}
1023  		if (initialCompose) {
1024  			ClearBeforeTentativeStart();
1025  		}
1026  		SetCandidateWindowPos();
1027  		pdoc-&gt;TentativeStart(); 
1028  		std::vector&lt;int&gt; imeIndicator = MapImeIndicators(imc.GetImeAttributes());
1029  		const int codePage = CodePageOfDocument();
1030  		const std::wstring_view wsv = wcs;
1031  		for (size_t i = 0; i &lt; wsv.size(); ) {
1032  			const size_t ucWidth = UTF16CharLength(wsv[i]);
1033  			const std::string docChar = StringEncode(wsv.substr(i, ucWidth), codePage);
1034  			InsertCharacter(docChar, CharacterSource::TentativeInput);
1035  			DrawImeIndicator(imeIndicator[i], docChar.size());
1036  			i += ucWidth;
1037  		}
1038  		const bool onlyTarget = std::all_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
1039  			return i == IndicatorTarget;
1040  		});
1041  		if (!onlyTarget) {
1042  			Sci::Position imeEndToImeCaretU16 = -static_cast&lt;Sci::Position&gt;(wcs.size());
1043  			if (!(lParam &amp; CS_NOMOVECARET) &amp;&amp; (lParam &amp; GCS_CURSORPOS)) {
1044  				imeEndToImeCaretU16 += imc.GetImeCaretPos();
1045  			}
1046  			if (imeEndToImeCaretU16 != 0) {
1047  				const Sci::Position currentPos = CurrentPosition();
1048  				const Sci::Position imeCaretPosDoc = pdoc-&gt;GetRelativePositionUTF16(currentPos, imeEndToImeCaretU16);
1049  				MoveImeCarets(-currentPos + imeCaretPosDoc);
1050  				if (std::find(imeIndicator.begin(), imeIndicator.end(), IndicatorTarget) != imeIndicator.end()) {
1051  					SetCandidateWindowPos();
1052  				}
1053  			}
1054  		}
1055  		if (KoreanIME()) {
1056  			view.imeCaretBlockOverride = true;
1057  		}
1058  	}
1059  	EnsureCaretVisible();
1060  	ShowCaretAtCurrentPosition();
1061  	return 0;
1062  }
1063  namespace {
1064  Message SciMessageFromEM(unsigned int iMessage) noexcept {
1065  	switch (iMessage) {
1066  	case EM_CANPASTE: return Message::CanPaste;
1067  	case EM_CANUNDO: return Message::CanUndo;
1068  	case EM_EMPTYUNDOBUFFER: return Message::EmptyUndoBuffer;
1069  	case EM_FINDTEXTEX: return Message::FindText;
1070  	case EM_FORMATRANGE: return Message::FormatRange;
1071  	case EM_GETFIRSTVISIBLELINE: return Message::GetFirstVisibleLine;
1072  	case EM_GETLINECOUNT: return Message::GetLineCount;
1073  	case EM_GETSELTEXT: return Message::GetSelText;
1074  	case EM_GETTEXTRANGE: return Message::GetTextRange;
1075  	case EM_HIDESELECTION: return Message::HideSelection;
1076  	case EM_LINEINDEX: return Message::PositionFromLine;
1077  	case EM_LINESCROLL: return Message::LineScroll;
1078  	case EM_REPLACESEL: return Message::ReplaceSel;
1079  	case EM_SCROLLCARET: return Message::ScrollCaret;
1080  	case EM_SETREADONLY: return Message::SetReadOnly;
1081  	case WM_CLEAR: return Message::Clear;
1082  	case WM_COPY: return Message::Copy;
1083  	case WM_CUT: return Message::Cut;
1084  	case WM_SETTEXT: return Message::SetText;
1085  	case WM_PASTE: return Message::Paste;
1086  	case WM_UNDO: return Message::Undo;
1087  	}
1088  	return static_cast&lt;Message&gt;(iMessage);
1089  }
1090  }
1091  namespace Scintilla::Internal {
1092  UINT CodePageFromCharSet(CharacterSet characterSet, UINT documentCodePage) noexcept {
1093  	if (documentCodePage == CpUtf8) {
1094  		return CpUtf8;
1095  	}
1096  	switch (characterSet) {
1097  	case CharacterSet::Ansi: return 1252;
1098  	case CharacterSet::Default: return documentCodePage;
1099  	case CharacterSet::Baltic: return 1257;
1100  	case CharacterSet::ChineseBig5: return 950;
1101  	case CharacterSet::EastEurope: return 1250;
1102  	case CharacterSet::GB2312: return 936;
1103  	case CharacterSet::Greek: return 1253;
1104  	case CharacterSet::Hangul: return 949;
1105  	case CharacterSet::Mac: return 10000;
1106  	case CharacterSet::Oem: return 437;
1107  	case CharacterSet::Russian: return 1251;
1108  	case CharacterSet::ShiftJis: return 932;
1109  	case CharacterSet::Turkish: return 1254;
1110  	case CharacterSet::Johab: return 1361;
1111  	case CharacterSet::Hebrew: return 1255;
1112  	case CharacterSet::Arabic: return 1256;
1113  	case CharacterSet::Vietnamese: return 1258;
1114  	case CharacterSet::Thai: return 874;
1115  	case CharacterSet::Iso8859_15: return 28605;
1116  	case CharacterSet::Cyrillic: return documentCodePage;
1117  	case CharacterSet::Symbol: return documentCodePage;
1118  	default: break;
1119  	}
1120  	return documentCodePage;
1121  }
1122  }
1123  UINT ScintillaWin::CodePageOfDocument() const noexcept {
1124  	return CodePageFromCharSet(vs.styles[StyleDefault].characterSet, pdoc-&gt;dbcsCodePage);
1125  }
1126  std::string ScintillaWin::EncodeWString(std::wstring_view wsv) {
1127  	if (IsUnicodeMode()) {
1128  		const size_t len = UTF8Length(wsv);
1129  		std::string putf(len, 0);
1130  		UTF8FromUTF16(wsv, putf.data(), len);
1131  		return putf;
1132  	} else {
1133  		return StringEncode(wsv, CodePageOfDocument());
1134  	}
1135  }
1136  sptr_t ScintillaWin::GetTextLength() {
1137  	if (pdoc-&gt;dbcsCodePage == 0 || pdoc-&gt;dbcsCodePage == CpUtf8) {
1138  		return pdoc-&gt;CountUTF16(0, pdoc-&gt;Length());
1139  	} else {
1140  		const UINT cpSrc = CodePageOfDocument();
1141  		const Sci::Line lines = pdoc-&gt;LinesTotal();
1142  		Sci::Position codeUnits = 0;
1143  		std::string lineBytes;
1144  		for (Sci::Line line = 0; line &lt; lines; line++) {
1145  			const Sci::Position start = pdoc-&gt;LineStart(line);
1146  			const Sci::Position width = pdoc-&gt;LineStart(line+1) - start;
1147  			lineBytes.resize(width);
1148  			pdoc-&gt;GetCharRange(lineBytes.data(), start, width);
1149  			codeUnits += WideCharLenFromMultiByte(cpSrc, lineBytes);
1150  		}
1151  		return codeUnits;
1152  	}
1153  }
1154  sptr_t ScintillaWin::GetText(uptr_t wParam, sptr_t lParam) {
1155  	if (lParam == 0) {
1156  		return GetTextLength();
1157  	}
1158  	if (wParam == 0) {
1159  		return 0;
1160  	}
1161  	wchar_t *ptr = static_cast&lt;wchar_t *&gt;(PtrFromSPtr(lParam));
1162  	if (pdoc-&gt;Length() == 0) {
1163  		*ptr = L&#x27;\0&#x27;;
1164  		return 0;
1165  	}
1166  	const Sci::Position lengthWanted = wParam - 1;
1167  	if (IsUnicodeMode()) {
1168  		Sci::Position sizeRequestedRange = pdoc-&gt;GetRelativePositionUTF16(0, lengthWanted);
1169  		if (sizeRequestedRange &lt; 0) {
1170  			sizeRequestedRange = pdoc-&gt;Length();
1171  		}
1172  		std::string docBytes(sizeRequestedRange, &#x27;\0&#x27;);
1173  		pdoc-&gt;GetCharRange(&amp;docBytes[0], 0, sizeRequestedRange);
1174  		const size_t uLen = UTF16FromUTF8(docBytes, ptr, lengthWanted);
1175  		ptr[uLen] = L&#x27;\0&#x27;;
1176  		return uLen;
1177  	} else {
1178  		const UINT cpSrc = CodePageOfDocument();
1179  		const Sci::Line lines = pdoc-&gt;LinesTotal();
1180  		Sci::Position codeUnits = 0;
1181  		std::string lineBytes;
1182  		std::wstring lineAsUTF16;
1183  		for (Sci::Line line = 0; line &lt; lines &amp;&amp; codeUnits &lt; lengthWanted; line++) {
1184  			const Sci::Position start = pdoc-&gt;LineStart(line);
1185  			const Sci::Position width = pdoc-&gt;LineStart(line + 1) - start;
1186  			lineBytes.resize(width);
1187  			pdoc-&gt;GetCharRange(lineBytes.data(), start, width);
1188  			const Sci::Position codeUnitsLine = WideCharLenFromMultiByte(cpSrc, lineBytes);
1189  			lineAsUTF16.resize(codeUnitsLine);
1190  			const Sci::Position lengthLeft = lengthWanted - codeUnits;
1191  			WideCharFromMultiByte(cpSrc, lineBytes, lineAsUTF16.data(), lineAsUTF16.length());
1192  			const Sci::Position lengthToCopy = std::min(lengthLeft, codeUnitsLine);
1193  			lineAsUTF16.copy(ptr + codeUnits, lengthToCopy);
1194  			codeUnits += lengthToCopy;
1195  		}
1196  		ptr[codeUnits] = L&#x27;\0&#x27;;
1197  		return codeUnits;
1198  	}
1199  }
1200  Window::Cursor ScintillaWin::ContextCursor(Point pt) {
1201  	if (inDragDrop == DragDrop::dragging) {
1202  		return Window::Cursor::up;
1203  	} else {
1204  		if (PointInSelMargin(pt)) {
1205  			return GetMarginCursor(pt);
1206  		} else if (!SelectionEmpty() &amp;&amp; PointInSelection(pt)) {
1207  			return Window::Cursor::arrow;
1208  		} else if (PointIsHotspot(pt)) {
1209  			return Window::Cursor::hand;
1210  		} else if (hoverIndicatorPos != Sci::invalidPosition) {
1211  			const Sci::Position pos = PositionFromLocation(pt, true, true);
1212  			if (pos != Sci::invalidPosition) {
1213  				return Window::Cursor::hand;
1214  			}
1215  		}
1216  	}
1217  	return Window::Cursor::text;
1218  }
1219  sptr_t ScintillaWin::ShowContextMenu(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1220  	Point pt = PointFromLParam(lParam);
1221  	POINT rpt = POINTFromPoint(pt);
1222  	::ScreenToClient(MainHWND(), &amp;rpt);
1223  	const Point ptClient = PointFromPOINT(rpt);
1224  	if (ShouldDisplayPopup(ptClient)) {
1225  		if ((pt.x == -1) &amp;&amp; (pt.y == -1)) {
1226  			pt = PointMainCaret();
1227  			POINT spt = POINTFromPoint(pt);
1228  			::ClientToScreen(MainHWND(), &amp;spt);
1229  			pt = PointFromPOINT(spt);
1230  		}
1231  		ContextMenu(pt);
1232  		return 0;
1233  	}
1234  	return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1235  }
1236  PRectangle ScintillaWin::GetClientRectangle() const {
1237  	return rectangleClient;
1238  }
1239  void ScintillaWin::SizeWindow() {
1240  #if defined(USE_D2D)
1241  	if (paintState == PaintState::notPainting) {
1242  		DropRenderTarget();
1243  	} else {
1244  		renderTargetValid = false;
1245  	}
1246  #endif
1247  	rectangleClient = wMain.GetClientPosition();
1248  	ChangeSize();
1249  }
1250  sptr_t ScintillaWin::MouseMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1251  	switch (iMessage) {
1252  	case WM_LBUTTONDOWN: {
1253  			IMContext imc(MainHWND());
1254  			if (imc.hIMC) {
1255  				::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
1256  			}
1257  			::SetFocus(MainHWND());
1258  			ButtonDownWithModifiers(PointFromLParam(lParam), ::GetMessageTime(),
1259  						MouseModifiers(wParam));
1260  		}
1261  		break;
1262  	case WM_LBUTTONUP:
1263  		ButtonUpWithModifiers(PointFromLParam(lParam),
1264  				      ::GetMessageTime(), MouseModifiers(wParam));
1265  		break;
1266  	case WM_RBUTTONDOWN: {
1267  			::SetFocus(MainHWND());
1268  			const Point pt = PointFromLParam(lParam);
1269  			if (!PointInSelection(pt)) {
1270  				CancelModes();
1271  				SetEmptySelection(PositionFromLocation(PointFromLParam(lParam)));
1272  			}
1273  			RightButtonDownWithModifiers(pt, ::GetMessageTime(), MouseModifiers(wParam));
1274  		}
1275  		break;
1276  	case WM_MBUTTONDOWN:
1277  		::SetFocus(MainHWND());
1278  		break;
1279  	case WM_MOUSEMOVE: {
1280  			const Point pt = PointFromLParam(lParam);
1281  			if (ptMouseLast != pt) {
1282  				SetTrackMouseLeaveEvent(true);
1283  				ButtonMoveWithModifiers(pt, ::GetMessageTime(), MouseModifiers(wParam));
1284  			}
1285  		}
1286  		break;
1287  	case WM_MOUSELEAVE:
1288  		SetTrackMouseLeaveEvent(false);
1289  		MouseLeave();
1290  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1291  	case WM_MOUSEWHEEL:
1292  	case WM_MOUSEHWHEEL:
1293  		if (!mouseWheelCaptures) {
1294  			RECT rc;
1295  			GetWindowRect(MainHWND(), &amp;rc);
1296  			const POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
1297  			if (!PtInRect(&amp;rc, pt))
1298  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1299  		}
1300  		if (ac.Active()) {
1301  			HWND hWnd = HwndFromWindow(*(ac.lb));
1302  			::SendMessage(hWnd, iMessage, wParam, lParam);
1303  			break;
1304  		}
1305  		if (iMessage == WM_MOUSEHWHEEL || (wParam &amp; MK_SHIFT)) {
1306  			if (vs.wrap.state != Wrap::None || charsPerScroll == 0) {
1307  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1308  			}
1309  			MouseWheelDelta &amp;wheelDelta = (iMessage == WM_MOUSEHWHEEL) ? horizontalWheelDelta : verticalWheelDelta;
1310  			if (wheelDelta.Accumulate(wParam)) {
1311  				const int charsToScroll = charsPerScroll * wheelDelta.Actions();
1312  				const int widthToScroll = static_cast&lt;int&gt;(std::lround(charsToScroll * vs.aveCharWidth));
1313  				HorizontalScrollToClamped(xOffset + widthToScroll);
1314  			}
1315  			return 0;
1316  		}
1317  		if (linesPerScroll != 0 &amp;&amp; verticalWheelDelta.Accumulate(wParam)) {
1318  			Sci::Line linesToScroll = linesPerScroll;
1319  			if (linesPerScroll == WHEEL_PAGESCROLL)
1320  				linesToScroll = LinesOnScreen() - 1;
1321  			if (linesToScroll == 0) {
1322  				linesToScroll = 1;
1323  			}
1324  			linesToScroll *= verticalWheelDelta.Actions();
1325  			if (wParam &amp; MK_CONTROL) {
1326  				if (linesToScroll &lt; 0) {
1327  					KeyCommand(Message::ZoomIn);
1328  				} else {
1329  					KeyCommand(Message::ZoomOut);
1330  				}
1331  			} else {
1332  				ScrollTo(topLine + linesToScroll);
1333  			}
1334  		}
1335  		return 0;
1336  	}
1337  	return 0;
1338  }
1339  sptr_t ScintillaWin::KeyMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1340  	switch (iMessage) {
1341  	case WM_SYSKEYDOWN:
1342  	case WM_KEYDOWN: {
1343  			lastKeyDownConsumed = false;
1344  			const bool altDown = KeyboardIsKeyDown(VK_MENU);
1345  			if (altDown &amp;&amp; KeyboardIsNumericKeypadFunction(wParam, lParam)) {
1346  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1347  			}
1348  			const int ret = KeyDownWithModifiers(
1349  								 KeyTranslate(wParam),
1350  							     ModifierFlags(KeyboardIsKeyDown(VK_SHIFT),
1351  									     KeyboardIsKeyDown(VK_CONTROL),
1352  									     altDown),
1353  							     &amp;lastKeyDownConsumed);
1354  			if (!ret &amp;&amp; !lastKeyDownConsumed) {
1355  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1356  			}
1357  			break;
1358  		}
1359  	case WM_KEYUP:
1360  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1361  	case WM_CHAR:
1362  		if (((wParam &gt;= 128) || !iscntrl(static_cast&lt;int&gt;(wParam))) || !lastKeyDownConsumed) {
1363  			wchar_t wcs[3] = { static_cast&lt;wchar_t&gt;(wParam), 0 };
1364  			unsigned int wclen = 1;
1365  			if (IS_HIGH_SURROGATE(wcs[0])) {
1366  				lastHighSurrogateChar = wcs[0];
1367  				return 0;
1368  			} else if (IS_LOW_SURROGATE(wcs[0])) {
1369  				wcs[1] = wcs[0];
1370  				wcs[0] = lastHighSurrogateChar;
1371  				lastHighSurrogateChar = 0;
1372  				wclen = 2;
1373  			}
1374  			AddWString(std::wstring_view(wcs, wclen), CharacterSource::DirectInput);
1375  		}
1376  		return 0;
1377  	case WM_UNICHAR:
1378  		if (wParam == UNICODE_NOCHAR) {
1379  			return TRUE;
1380  		} else if (lastKeyDownConsumed) {
1381  			return 1;
1382  		} else {
1383  			wchar_t wcs[3] = { 0 };
1384  			const size_t wclen = UTF16FromUTF32Character(static_cast&lt;unsigned int&gt;(wParam), wcs);
1385  			AddWString(std::wstring_view(wcs, wclen), CharacterSource::DirectInput);
1386  			return FALSE;
1387  		}
1388  	}
1389  	return 0;
1390  }
1391  sptr_t ScintillaWin::FocusMessage(unsigned int iMessage, uptr_t wParam, sptr_t) {
1392  	switch (iMessage) {
1393  	case WM_KILLFOCUS: {
1394  		HWND wOther = reinterpret_cast&lt;HWND&gt;(wParam);
1395  		HWND wThis = MainHWND();
1396  		const HWND wCT = HwndFromWindow(ct.wCallTip);
1397  		if (!wParam ||
1398  			!(::IsChild(wThis, wOther) || (wOther == wCT))) {
1399  			SetFocusState(false);
1400  			DestroySystemCaret();
1401  		}
1402  		IMContext imc(MainHWND());
1403  		if (imc.hIMC) {
1404  			::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
1405  		}
1406  		break;
1407  	}
1408  	case WM_SETFOCUS:
1409  		SetFocusState(true);
1410  		DestroySystemCaret();
1411  		CreateSystemCaret();
1412  		break;
1413  	}
1414  	return 0;
1415  }
1416  sptr_t ScintillaWin::IMEMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1417  	switch (iMessage) {
1418  	case WM_INPUTLANGCHANGE:
1419  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1420  	case WM_INPUTLANGCHANGEREQUEST:
1421  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1422  	case WM_IME_KEYDOWN: {
1423  			if (wParam == VK_HANJA) {
1424  				ToggleHanja();
1425  			}
1426  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1427  		}
1428  	case WM_IME_REQUEST: {
1429  			if (wParam == IMR_RECONVERTSTRING) {
1430  				return ImeOnReconvert(lParam);
1431  			}
1432  			if (wParam == IMR_DOCUMENTFEED) {
1433  				return ImeOnDocumentFeed(lParam);
1434  			}
1435  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1436  		}
1437  	case WM_IME_STARTCOMPOSITION:
1438  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1439  			return 0;
1440  		} else {
1441  			ImeStartComposition();
1442  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1443  		}
1444  	case WM_IME_ENDCOMPOSITION:
1445  		ImeEndComposition();
1446  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1447  	case WM_IME_COMPOSITION:
1448  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1449  			return HandleCompositionInline(wParam, lParam);
1450  		} else {
1451  			return HandleCompositionWindowed(wParam, lParam);
1452  		}
1453  	case WM_IME_SETCONTEXT:
1454  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1455  			if (wParam) {
1456  				LPARAM NoImeWin = lParam;
1457  				NoImeWin = NoImeWin &amp; (~ISC_SHOWUICOMPOSITIONWINDOW);
1458  				return ::DefWindowProc(MainHWND(), iMessage, wParam, NoImeWin);
1459  			}
1460  		}
1461  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1462  	case WM_IME_NOTIFY:
1463  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1464  	}
1465  	return 0;
1466  }
1467  sptr_t ScintillaWin::EditMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1468  	switch (iMessage) {
1469  	case EM_LINEFROMCHAR:
1470  		if (PositionFromUPtr(wParam) &lt; 0) {
1471  			wParam = SelectionStart().Position();
1472  		}
1473  		return pdoc-&gt;LineFromPosition(wParam);
1474  	case EM_EXLINEFROMCHAR:
1475  		return pdoc-&gt;LineFromPosition(lParam);
1476  	case EM_GETSEL:
1477  		if (wParam) {
1478  			*reinterpret_cast&lt;DWORD *&gt;(wParam) = static_cast&lt;DWORD&gt;(SelectionStart().Position());
1479  		}
1480  		if (lParam) {
1481  			*reinterpret_cast&lt;DWORD *&gt;(lParam) = static_cast&lt;DWORD&gt;(SelectionEnd().Position());
1482  		}
1483  		return MAKELRESULT(SelectionStart().Position(), SelectionEnd().Position());
1484  	case EM_EXGETSEL: {
1485  			if (lParam == 0) {
1486  				return 0;
1487  			}
1488  			CHARRANGE *pCR = reinterpret_cast&lt;CHARRANGE *&gt;(lParam);
1489  			pCR-&gt;cpMin = static_cast&lt;LONG&gt;(SelectionStart().Position());
1490  			pCR-&gt;cpMax = static_cast&lt;LONG&gt;(SelectionEnd().Position());
1491  		}
1492  		break;
1493  	case EM_SETSEL: {
1494  			Sci::Position nStart = wParam;
1495  			Sci::Position nEnd = lParam;
1496  			if (nStart == 0 &amp;&amp; nEnd == -1) {
1497  				nEnd = pdoc-&gt;Length();
1498  			}
1499  			if (nStart == -1) {
1500  				nStart = nEnd;	
1501  			}
1502  			SetSelection(nEnd, nStart);
1503  			EnsureCaretVisible();
1504  		}
1505  		break;
1506  	case EM_EXSETSEL: {
1507  			if (lParam == 0) {
1508  				return 0;
1509  			}
1510  			const CHARRANGE *pCR = reinterpret_cast&lt;const CHARRANGE *&gt;(lParam);
1511  			sel.selType = Selection::SelTypes::stream;
1512  			if (pCR-&gt;cpMin == 0 &amp;&amp; pCR-&gt;cpMax == -1) {
1513  				SetSelection(pCR-&gt;cpMin, pdoc-&gt;Length());
1514  			} else {
1515  				SetSelection(pCR-&gt;cpMin, pCR-&gt;cpMax);
1516  			}
1517  			EnsureCaretVisible();
1518  			return pdoc-&gt;LineFromPosition(SelectionStart().Position());
1519  		}
1520  	}
1521  	return 0;
1522  }
1523  sptr_t ScintillaWin::IdleMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1524  	switch (iMessage) {
1525  	case SC_WIN_IDLE:
1526  		if (idler.state) {
1527  			if (lParam || (WAIT_TIMEOUT == MsgWaitForMultipleObjects(0, nullptr, 0, 0, QS_INPUT | QS_HOTKEY))) {
1528  				if (Idle()) {
1529  #ifdef _MSC_VER
1530  #pragma warning(suppress: 28159)
1531  #endif
1532  					const DWORD dwCurrent = GetTickCount();
1533  					const DWORD dwStart = wParam ? static_cast&lt;DWORD&gt;(wParam) : dwCurrent;
1534  					constexpr DWORD maxWorkTime = 50;
1535  					if (dwCurrent &gt;= dwStart &amp;&amp; dwCurrent &gt; maxWorkTime &amp;&amp;dwCurrent - maxWorkTime &lt; dwStart)
1536  						PostMessage(MainHWND(), SC_WIN_IDLE, dwStart, 0);
1537  				} else {
1538  					SetIdle(false);
1539  				}
1540  			}
1541  		}
1542  		break;
1543  	case SC_WORK_IDLE:
1544  		IdleWork();
1545  		break;
1546  	}
1547  	return 0;
1548  }
1549  sptr_t ScintillaWin::SciMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
1550  	switch (iMessage) {
1551  	case Message::GetDirectFunction:
1552  		return reinterpret_cast&lt;sptr_t&gt;(DirectFunction);
1553  	case Message::GetDirectStatusFunction:
1554  		return reinterpret_cast&lt;sptr_t&gt;(DirectStatusFunction);
1555  	case Message::GetDirectPointer:
1556  		return reinterpret_cast&lt;sptr_t&gt;(this);
1557  #ifdef SCI_OWNREGEX
1558  	case Message::GetBoostRegexErrmsg:
1559  	{
1560  		if (lParam == 0)
1561  			return g_exceptionMessage.length() + 1;
1562  		if (wParam == 0)
1563  			return 0;
1564  		char *ptr = CharPtrFromSPtr(lParam);
1565  		const Sci_Position len = std::min&lt;Sci_Position&gt;(wParam - 1, g_exceptionMessage.length());
1566  		strncpy (ptr, g_exceptionMessage.c_str(), len);
1567  		ptr [len] = &#x27;\0&#x27;;
1568  		return len;
1569  	}
1570  #endif
1571  	case Message::GrabFocus:
1572  		::SetFocus(MainHWND());
1573  		break;
1574  #ifdef INCLUDE_DEPRECATED_FEATURES
1575  	case Message::SETKEYSUNICODE:
1576  		break;
1577  	case Message::GETKEYSUNICODE:
1578  		return true;
1579  #endif
1580  	case Message::SetTechnology:
1581  		if (const Technology technologyNew = static_cast&lt;Technology&gt;(wParam);
1582  			(technologyNew == Technology::Default) ||
1583  			(technologyNew == Technology::DirectWriteRetain) ||
1584  			(technologyNew == Technology::DirectWriteDC) ||
1585  			(technologyNew == Technology::DirectWrite)) {
1586  			if (technology != technologyNew) {
1587  				if (technologyNew &gt; Technology::Default) {
1588  #if defined(USE_D2D)
1589  					if (!LoadD2D()) {
1590  						return 0;
1591  					}
1592  					UpdateRenderingParams(true);
1593  #else
1594  					return 0;
1595  #endif
1596  				} else {
1597  					bidirectional = Bidirectional::Disabled;
1598  				}
1599  				DropRenderTarget();
1600  				technology = technologyNew;
1601  				view.bufferedDraw = technologyNew == Technology::Default;
1602  				InvalidateStyleRedraw();
1603  			}
1604  		}
1605  		break;
1606  	case Message::SetBidirectional:
1607  		if (technology == Technology::Default) {
1608  			bidirectional = Bidirectional::Disabled;
1609  		} else if (static_cast&lt;Bidirectional&gt;(wParam) &lt;= Bidirectional::R2L) {
1610  			bidirectional = static_cast&lt;Bidirectional&gt;(wParam);
1611  		}
1612  		InvalidateStyleRedraw();
1613  		break;
1614  	case Message::TargetAsUTF8:
1615  		return TargetAsUTF8(CharPtrFromSPtr(lParam));
1616  	case Message::EncodedFromUTF8:
1617  		return EncodedFromUTF8(ConstCharPtrFromUPtr(wParam),
1618  			CharPtrFromSPtr(lParam));
1619  	default:
1620  		break;
1621  	}
1622  	return 0;
1623  }
1624  sptr_t ScintillaWin::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
1625  	try {
1626  		const unsigned int msg = static_cast&lt;unsigned int&gt;(iMessage);
1627  		switch (msg) {
1628  		case WM_CREATE:
1629  			ctrlID = ::GetDlgCtrlID(HwndFromWindow(wMain));
1630  			UpdateBaseElements();
1631  			GetIntelliMouseParameters();
1632  			::RegisterDragDrop(MainHWND(), &amp;dt);
1633  			break;
1634  		case WM_COMMAND:
1635  			Command(LOWORD(wParam));
1636  			break;
1637  		case WM_PAINT:
1638  			return WndPaint();
1639  		case WM_PRINTCLIENT: {
1640  				HDC hdc = reinterpret_cast&lt;HDC&gt;(wParam);
1641  				if (!IsCompatibleDC(hdc)) {
1642  					return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1643  				}
1644  				FullPaintDC(hdc);
1645  			}
1646  			break;
1647  		case WM_VSCROLL:
1648  			ScrollMessage(wParam);
1649  			break;
1650  		case WM_HSCROLL:
1651  			HorizontalScrollMessage(wParam);
1652  			break;
1653  		case WM_SIZE:
1654  			SizeWindow();
1655  			break;
1656  		case WM_TIMER:
1657  			if (wParam == idleTimerID &amp;&amp; idler.state) {
1658  				SendMessage(MainHWND(), SC_WIN_IDLE, 0, 1);
1659  			} else {
1660  				TickFor(static_cast&lt;TickReason&gt;(wParam - fineTimerStart));
1661  			}
1662  			break;
1663  		case SC_WIN_IDLE:
1664  		case SC_WORK_IDLE:
1665  			return IdleMessage(msg, wParam, lParam);
1666  		case WM_GETMINMAXINFO:
1667  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1668  		case WM_LBUTTONDOWN:
1669  		case WM_LBUTTONUP:
1670  		case WM_RBUTTONDOWN:
1671  		case WM_MOUSEMOVE:
1672  		case WM_MOUSELEAVE:
1673  		case WM_MOUSEWHEEL:
1674  		case WM_MOUSEHWHEEL:
1675  			return MouseMessage(msg, wParam, lParam);
1676  		case WM_SETCURSOR:
1677  			if (LOWORD(lParam) == HTCLIENT) {
1678  				POINT pt;
1679  				if (::GetCursorPos(&amp;pt)) {
1680  					::ScreenToClient(MainHWND(), &amp;pt);
1681  					DisplayCursor(ContextCursor(PointFromPOINT(pt)));
1682  				}
1683  				return TRUE;
1684  			} else {
1685  				return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1686  			}
1687  		case WM_SYSKEYDOWN:
1688  		case WM_KEYDOWN:
1689  		case WM_KEYUP:
1690  		case WM_CHAR:
1691  		case WM_UNICHAR:
1692  			return KeyMessage(msg, wParam, lParam);
1693  		case WM_SETTINGCHANGE:
1694  #if defined(USE_D2D)
1695  			if (technology != Technology::Default) {
1696  				UpdateRenderingParams(true);
1697  			}
1698  #endif
1699  			UpdateBaseElements();
1700  			GetIntelliMouseParameters();
1701  			InvalidateStyleRedraw();
1702  			break;
1703  		case WM_GETDLGCODE:
1704  			return DLGC_HASSETSEL | DLGC_WANTALLKEYS;
1705  		case WM_KILLFOCUS:
1706  		case WM_SETFOCUS:
1707  			return FocusMessage(msg, wParam, lParam);
1708  		case WM_SYSCOLORCHANGE:
1709  			UpdateBaseElements();
1710  			InvalidateStyleData();
1711  			break;
1712  		case WM_DPICHANGED:
1713  			dpi = HIWORD(wParam);
1714  			InvalidateStyleRedraw();
1715  			break;
1716  		case WM_DPICHANGED_AFTERPARENT: {
1717  				const UINT dpiNow = DpiForWindow(wMain.GetID());
1718  				if (dpi != dpiNow) {
1719  					dpi = dpiNow;
1720  					InvalidateStyleRedraw();
1721  				}
1722  			}
1723  			break;
1724  		case WM_CONTEXTMENU:
1725  			return ShowContextMenu(msg, wParam, lParam);
1726  		case WM_ERASEBKGND:
1727  			return 1;   
1728  		case WM_SETREDRAW:
1729  			::DefWindowProc(MainHWND(), msg, wParam, lParam);
1730  			if (wParam) {
1731  				SetScrollBars();
1732  				SetVerticalScrollPos();
1733  				SetHorizontalScrollPos();
1734  			}
1735  			return 0;
1736  		case WM_CAPTURECHANGED:
1737  			capturedMouse = false;
1738  			return 0;
1739  		case WM_MOVE:
1740  		case WM_MOUSEACTIVATE:
1741  		case WM_NCHITTEST:
1742  		case WM_NCCALCSIZE:
1743  		case WM_NCPAINT:
1744  		case WM_NCMOUSEMOVE:
1745  		case WM_NCLBUTTONDOWN:
1746  		case WM_SYSCOMMAND:
1747  		case WM_WINDOWPOSCHANGING:
1748  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1749  		case WM_WINDOWPOSCHANGED:
1750  #if defined(USE_D2D)
1751  			if (technology != Technology::Default) {
1752  				if (UpdateRenderingParams(false)) {
1753  					DropGraphics();
1754  					Redraw();
1755  				}
1756  			}
1757  #endif
1758  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1759  		case WM_GETTEXTLENGTH:
1760  			return GetTextLength();
1761  		case WM_GETTEXT:
1762  			return GetText(wParam, lParam);
1763  		case WM_INPUTLANGCHANGE:
1764  		case WM_INPUTLANGCHANGEREQUEST:
1765  		case WM_IME_KEYDOWN:
1766  		case WM_IME_REQUEST:
1767  		case WM_IME_STARTCOMPOSITION:
1768  		case WM_IME_ENDCOMPOSITION:
1769  		case WM_IME_COMPOSITION:
1770  		case WM_IME_SETCONTEXT:
1771  		case WM_IME_NOTIFY:
1772  			return IMEMessage(msg, wParam, lParam);
1773  		case EM_LINEFROMCHAR:
1774  		case EM_EXLINEFROMCHAR:
1775  		case EM_GETSEL:
1776  		case EM_EXGETSEL:
1777  		case EM_SETSEL:
1778  		case EM_EXSETSEL:
1779  			return EditMessage(msg, wParam, lParam);
1780  		}
1781  		iMessage = SciMessageFromEM(msg);
1782  		switch (iMessage) {
1783  		case Message::GetDirectFunction:
1784  		case Message::GetDirectStatusFunction:
1785  		case Message::GetDirectPointer:
1786  #ifdef SCI_OWNREGEX
1787  		case Message::GetBoostRegexErrmsg:
1788  #endif
1789  		case Message::GrabFocus:
1790  		case Message::SetTechnology:
1791  		case Message::SetBidirectional:
1792  		case Message::TargetAsUTF8:
1793  		case Message::EncodedFromUTF8:
1794  			return SciMessage(iMessage, wParam, lParam);
1795  		default:
1796  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
1797  		}
1798  	} catch (std::bad_alloc &amp;) {
1799  		errorStatus = Status::BadAlloc;
1800  	} catch (...) {
1801  		errorStatus = Status::Failure;
1802  	}
1803  	return 0;
1804  }
1805  bool ScintillaWin::ValidCodePage(int codePage) const {
1806  	return codePage == 0 || codePage == CpUtf8 ||
1807  	       codePage == 932 || codePage == 936 || codePage == 949 ||
1808  	       codePage == 950 || codePage == 1361;
1809  }
1810  std::string ScintillaWin::UTF8FromEncoded(std::string_view encoded) const {
1811  	if (IsUnicodeMode()) {
1812  		return std::string(encoded);
1813  	} else {
1814  		std::wstring ws = StringDecode(encoded, CodePageOfDocument());
1815  		return StringEncode(ws, CpUtf8);
1816  	}
1817  }
1818  std::string ScintillaWin::EncodedFromUTF8(std::string_view utf8) const {
1819  	if (IsUnicodeMode()) {
1820  		return std::string(utf8);
1821  	} else {
1822  		std::wstring ws = StringDecode(utf8, CpUtf8);
1823  		return StringEncode(ws, CodePageOfDocument());
1824  	}
1825  }
1826  sptr_t ScintillaWin::DefWndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
1827  	return ::DefWindowProc(MainHWND(), static_cast&lt;unsigned int&gt;(iMessage), wParam, lParam);
1828  }
1829  bool ScintillaWin::FineTickerRunning(TickReason reason) {
1830  	return timers[static_cast&lt;size_t&gt;(reason)] != 0;
1831  }
1832  void ScintillaWin::FineTickerStart(TickReason reason, int millis, int tolerance) {
1833  	FineTickerCancel(reason);
1834  	const UINT_PTR reasonIndex = static_cast&lt;UINT_PTR&gt;(reason);
1835  	const UINT_PTR eventID = static_cast&lt;UINT_PTR&gt;(fineTimerStart) + reasonIndex;
1836  	if (SetCoalescableTimerFn &amp;&amp; tolerance) {
1837  		timers[reasonIndex] = SetCoalescableTimerFn(MainHWND(), eventID, millis, nullptr, tolerance);
1838  	} else {
1839  		timers[reasonIndex] = ::SetTimer(MainHWND(), eventID, millis, nullptr);
1840  	}
1841  }
1842  void ScintillaWin::FineTickerCancel(TickReason reason) {
1843  	const UINT_PTR reasonIndex = static_cast&lt;UINT_PTR&gt;(reason);
1844  	if (timers[reasonIndex]) {
1845  		::KillTimer(MainHWND(), timers[reasonIndex]);
1846  		timers[reasonIndex] = 0;
1847  	}
1848  }
1849  bool ScintillaWin::SetIdle(bool on) {
1850  	if (idler.state != on) {
1851  		if (on) {
1852  			idler.idlerID = ::SetTimer(MainHWND(), idleTimerID, 10, nullptr)
1853  				? reinterpret_cast&lt;IdlerID&gt;(idleTimerID) : 0;
1854  		} else {
1855  			::KillTimer(MainHWND(), reinterpret_cast&lt;uptr_t&gt;(idler.idlerID));
1856  			idler.idlerID = 0;
1857  		}
1858  		idler.state = idler.idlerID != 0;
1859  	}
1860  	return idler.state;
1861  }
1862  void ScintillaWin::IdleWork() {
1863  	styleIdleInQueue = false;
1864  	Editor::IdleWork();
1865  }
1866  void ScintillaWin::QueueIdleWork(WorkItems items, Sci::Position upTo) {
1867  	Editor::QueueIdleWork(items, upTo);
1868  	if (!styleIdleInQueue) {
1869  		if (PostMessage(MainHWND(), SC_WORK_IDLE, 0, 0)) {
1870  			styleIdleInQueue = true;
1871  		}
1872  	}
1873  }
1874  void ScintillaWin::SetMouseCapture(bool on) {
1875  	if (mouseDownCaptures) {
1876  		if (on) {
1877  			::SetCapture(MainHWND());
1878  		} else {
1879  			::ReleaseCapture();
1880  		}
1881  	}
1882  	capturedMouse = on;
1883  }
1884  bool ScintillaWin::HaveMouseCapture() {
1885  	return capturedMouse;
1886  }
1887  void ScintillaWin::SetTrackMouseLeaveEvent(bool on) noexcept {
1888  	if (on &amp;&amp; !trackedMouseLeave) {
1889  		TRACKMOUSEEVENT tme {};
1890  		tme.cbSize = sizeof(tme);
1891  		tme.dwFlags = TME_LEAVE;
1892  		tme.hwndTrack = MainHWND();
1893  		tme.dwHoverTime = HOVER_DEFAULT;	
1894  		TrackMouseEvent(&amp;tme);
1895  	}
1896  	trackedMouseLeave = on;
1897  }
1898  void ScintillaWin::UpdateBaseElements() {
1899  	struct ElementToIndex { Element element; int nIndex; };
1900  	const ElementToIndex eti[] = {
1901  		{ Element::List, COLOR_WINDOWTEXT },
1902  		{ Element::ListBack, COLOR_WINDOW },
1903  		{ Element::ListSelected, COLOR_HIGHLIGHTTEXT },
1904  		{ Element::ListSelectedBack, COLOR_HIGHLIGHT },
1905  	};
1906  	bool changed = false;
1907  	for (const ElementToIndex &amp;ei : eti) {
1908  		changed = vs.SetElementBase(ei.element, ColourRGBA::FromRGB(static_cast&lt;int&gt;(::GetSysColor(ei.nIndex)))) || changed;
1909  	}
1910  	if (changed) {
1911  		Redraw();
1912  	}
1913  }
1914  bool ScintillaWin::PaintContains(PRectangle rc) {
1915  	if (paintState == PaintState::painting) {
1916  		return BoundsContains(rcPaint, hRgnUpdate, rc);
1917  	}
1918  	return true;
1919  }
1920  void ScintillaWin::ScrollText(Sci::Line &amp;bsol;* linesToMove */) {
1921  	Redraw();
1922  	UpdateSystemCaret();
1923  }
1924  void ScintillaWin::NotifyCaretMove() {
1925  	NotifyWinEvent(EVENT_OBJECT_LOCATIONCHANGE, MainHWND(), OBJID_CARET, CHILDID_SELF);
1926  }
1927  void ScintillaWin::UpdateSystemCaret() {
1928  	if (hasFocus) {
1929  		if (pdoc-&gt;TentativeActive()) {
1930  			return;
1931  		}
1932  		if (HasCaretSizeChanged()) {
1933  			DestroySystemCaret();
1934  			CreateSystemCaret();
1935  		}
1936  		const Point pos = PointMainCaret();
1937  		::SetCaretPos(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y));
1938  	}
1939  }
1940  bool ScintillaWin::IsVisible() const noexcept {
1941  	return GetWindowStyle(MainHWND()) &amp; WS_VISIBLE;
1942  }
1943  int ScintillaWin::SetScrollInfo(int nBar, LPCSCROLLINFO lpsi, BOOL bRedraw) noexcept {
1944  	return ::SetScrollInfo(MainHWND(), nBar, lpsi, bRedraw);
1945  }
1946  bool ScintillaWin::GetScrollInfo(int nBar, LPSCROLLINFO lpsi) noexcept {
1947  	return ::GetScrollInfo(MainHWND(), nBar, lpsi) ? true : false;
1948  }
1949  void ScintillaWin::ChangeScrollPos(int barType, Sci::Position pos) {
1950  	if (!IsVisible()) {
1951  		return;
1952  	}
1953  	SCROLLINFO sci = {
1954  		sizeof(sci), 0, 0, 0, 0, 0, 0
1955  	};
1956  	sci.fMask = SIF_POS;
1957  	GetScrollInfo(barType, &amp;sci);
1958  	if (sci.nPos != pos) {
1959  		DwellEnd(true);
1960  		sci.nPos = static_cast&lt;int&gt;(pos);
1961  		SetScrollInfo(barType, &amp;sci, TRUE);
1962  	}
1963  }
1964  void ScintillaWin::SetVerticalScrollPos() {
1965  	ChangeScrollPos(SB_VERT, topLine);
1966  }
1967  void ScintillaWin::SetHorizontalScrollPos() {
1968  	ChangeScrollPos(SB_HORZ, xOffset);
1969  }
1970  bool ScintillaWin::ChangeScrollRange(int nBar, int nMin, int nMax, UINT nPage) noexcept {
1971  	SCROLLINFO sci = { sizeof(sci), SIF_PAGE | SIF_RANGE, 0, 0, 0, 0, 0 };
1972  	GetScrollInfo(nBar, &amp;sci);
1973  	if ((sci.nMin != nMin) || (sci.nMax != nMax) ||	(sci.nPage != nPage)) {
1974  		sci.nMin = nMin;
1975  		sci.nMax = nMax;
1976  		sci.nPage = nPage;
1977  		SetScrollInfo(nBar, &amp;sci, TRUE);
1978  		return true;
1979  	}
1980  	return false;
1981  }
1982  void ScintillaWin::HorizontalScrollToClamped(int xPos) {
1983  	const HorizontalScrollRange range = GetHorizontalScrollRange();
1984  	HorizontalScrollTo(std::clamp(xPos, 0, range.documentWidth - range.pageWidth + 1));
1985  }
1986  HorizontalScrollRange ScintillaWin::GetHorizontalScrollRange() const {
1987  	const PRectangle rcText = GetTextRectangle();
1988  	int pageWidth = static_cast&lt;int&gt;(rcText.Width());
1989  	const int horizEndPreferred = std::max({ scrollWidth, pageWidth - 1, 0 });
1990  	if (!horizontalScrollBarVisible || Wrapping())
1991  		pageWidth = horizEndPreferred + 1;
1992  	return { pageWidth, horizEndPreferred };
1993  }
1994  bool ScintillaWin::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) {
1995  	if (!IsVisible()) {
1996  		return false;
1997  	}
1998  	bool modified = false;
1999  	const Sci::Line vertEndPreferred = nMax;
2000  	if (!verticalScrollBarVisible)
2001  		nPage = vertEndPreferred + 1;
2002  	if (ChangeScrollRange(SB_VERT, 0, static_cast&lt;int&gt;(vertEndPreferred), static_cast&lt;unsigned int&gt;(nPage))) {
2003  		modified = true;
2004  	}
2005  	const HorizontalScrollRange range = GetHorizontalScrollRange();
2006  	if (ChangeScrollRange(SB_HORZ, 0, range.documentWidth, range.pageWidth)) {
2007  		modified = true;
2008  		if (scrollWidth &lt; range.pageWidth) {
2009  			HorizontalScrollTo(0);
2010  		}
2011  	}
2012  	return modified;
2013  }
2014  void ScintillaWin::NotifyChange() {
2015  	::SendMessage(::GetParent(MainHWND()), WM_COMMAND,
2016  	        MAKEWPARAM(GetCtrlID(), FocusChange::Change),
2017  		reinterpret_cast&lt;LPARAM&gt;(MainHWND()));
2018  }
2019  void ScintillaWin::NotifyFocus(bool focus) {
2020  	if (commandEvents) {
2021  		::SendMessage(::GetParent(MainHWND()), WM_COMMAND,
2022  			MAKEWPARAM(GetCtrlID(), focus ? FocusChange::Setfocus : FocusChange::Killfocus),
2023  			reinterpret_cast&lt;LPARAM&gt;(MainHWND()));
2024  	}
2025  	Editor::NotifyFocus(focus);
2026  }
2027  void ScintillaWin::SetCtrlID(int identifier) {
2028  	::SetWindowID(HwndFromWindow(wMain), identifier);
2029  }
2030  int ScintillaWin::GetCtrlID() {
2031  	return ::GetDlgCtrlID(HwndFromWindow(wMain));
2032  }
2033  void ScintillaWin::NotifyParent(NotificationData scn) {
2034  	scn.nmhdr.hwndFrom = MainHWND();
2035  	scn.nmhdr.idFrom = GetCtrlID();
2036  	::SendMessage(::GetParent(MainHWND()), WM_NOTIFY,
2037  	              GetCtrlID(), reinterpret_cast&lt;LPARAM&gt;(&amp;scn));
2038  }
2039  void ScintillaWin::NotifyDoubleClick(Point pt, KeyMod modifiers) {
2040  	ScintillaBase::NotifyDoubleClick(pt, modifiers);
2041  	::SendMessage(MainHWND(),
2042  			  WM_LBUTTONDBLCLK,
2043  			  FlagSet(modifiers, KeyMod::Shift) ? MK_SHIFT : 0,
2044  			  MAKELPARAM(pt.x, pt.y));
2045  }
2046  namespace {
2047  class CaseFolderDBCS : public CaseFolderTable {
2048  	std::vector&lt;wchar_t&gt; utf16Mixed;
2049  	std::vector&lt;wchar_t&gt; utf16Folded;
2050  	UINT cp;
2051  public:
2052  	explicit CaseFolderDBCS(UINT cp_) : cp(cp_) {
2053  	}
2054  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
2055  		if ((lenMixed == 1) &amp;&amp; (sizeFolded &gt; 0)) {
2056  			folded[0] = mapping[static_cast&lt;unsigned char&gt;(mixed[0])];
2057  			return 1;
2058  		} else {
2059  			if (lenMixed &gt; utf16Mixed.size()) {
2060  				utf16Mixed.resize(lenMixed + 8);
2061  			}
2062  			const size_t nUtf16Mixed = WideCharFromMultiByte(cp,
2063  				std::string_view(mixed, lenMixed),
2064  				&amp;utf16Mixed[0],
2065  				utf16Mixed.size());
2066  			if (nUtf16Mixed == 0) {
2067  				folded[0] = &#x27;\0&#x27;;
2068  				return 1;
2069  			}
2070  			size_t lenFlat = 0;
2071  			for (size_t mixIndex=0; mixIndex &lt; nUtf16Mixed; mixIndex++) {
2072  				if ((lenFlat + 20) &gt; utf16Folded.size())
2073  					utf16Folded.resize(lenFlat + 60);
2074  				const char *foldedUTF8 = CaseConvert(utf16Mixed[mixIndex], CaseConversion::fold);
2075  				if (foldedUTF8) {
2076  					wchar_t wFolded[20];
2077  					const size_t charsConverted = UTF16FromUTF8(std::string_view(foldedUTF8),
2078  							wFolded, std::size(wFolded));
2079  					for (size_t j=0; j&lt;charsConverted; j++)
2080  						utf16Folded[lenFlat++] = wFolded[j];
2081  				} else {
2082  					utf16Folded[lenFlat++] = utf16Mixed[mixIndex];
2083  				}
2084  			}
2085  			const std::wstring_view wsvFolded(&amp;utf16Folded[0], lenFlat);
2086  			const size_t lenOut = MultiByteLenFromWideChar(cp, wsvFolded);
2087  			if (lenOut &lt; sizeFolded) {
2088  				MultiByteFromWideChar(cp, wsvFolded, folded, lenOut);
2089  				return lenOut;
2090  			} else {
2091  				return 0;
2092  			}
2093  		}
2094  	}
2095  };
2096  }
2097  std::unique_ptr&lt;CaseFolder&gt; ScintillaWin::CaseFolderForEncoding() {
2098  	const UINT cpDest = CodePageOfDocument();
2099  	if (cpDest == CpUtf8) {
2100  		return std::make_unique&lt;CaseFolderUnicode&gt;();
2101  	} else {
2102  		if (pdoc-&gt;dbcsCodePage == 0) {
2103  			std::unique_ptr&lt;CaseFolderTable&gt; pcf = std::make_unique&lt;CaseFolderTable&gt;();
2104  			for (int i=0x80; i&lt;0x100; i++) {
2105  				char sCharacter[2] = &quot;A&quot;;
2106  				sCharacter[0] = static_cast&lt;char&gt;(i);
2107  				wchar_t wCharacter[20];
2108  				const unsigned int lengthUTF16 = WideCharFromMultiByte(cpDest, sCharacter,
2109  					wCharacter, std::size(wCharacter));
2110  				if (lengthUTF16 == 1) {
2111  					const char *caseFolded = CaseConvert(wCharacter[0], CaseConversion::fold);
2112  					if (caseFolded) {
2113  						wchar_t wLower[20];
2114  						const size_t charsConverted = UTF16FromUTF8(std::string_view(caseFolded),
2115  							wLower, std::size(wLower));
2116  						if (charsConverted == 1) {
2117  							char sCharacterLowered[20];
2118  							const unsigned int lengthConverted = MultiByteFromWideChar(cpDest,
2119  								std::wstring_view(wLower, charsConverted),
2120  								sCharacterLowered, std::size(sCharacterLowered));
2121  							if ((lengthConverted == 1) &amp;&amp; (sCharacter[0] != sCharacterLowered[0])) {
2122  								pcf-&gt;SetTranslation(sCharacter[0], sCharacterLowered[0]);
2123  							}
2124  						}
2125  					}
2126  				}
2127  			}
2128  			return pcf;
2129  		} else {
2130  			return std::make_unique&lt;CaseFolderDBCS&gt;(cpDest);
2131  		}
2132  	}
2133  }
2134  std::string ScintillaWin::CaseMapString(const std::string &amp;s, CaseMapping caseMapping) {
2135  	if ((s.size() == 0) || (caseMapping == CaseMapping::same))
2136  		return s;
2137  	const UINT cpDoc = CodePageOfDocument();
2138  	if (cpDoc == CpUtf8) {
2139  		return CaseConvertString(s, (caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
2140  	}
2141  	const std::wstring wsText = StringDecode(s, cpDoc);
2142  	const DWORD mapFlags = LCMAP_LINGUISTIC_CASING |
2143  		((caseMapping == CaseMapping::upper) ? LCMAP_UPPERCASE : LCMAP_LOWERCASE);
2144  	const std::wstring wsConverted = StringMapCase(wsText, mapFlags);
2145  	std::string sConverted = StringEncode(wsConverted, cpDoc);
2146  	return sConverted;
2147  }
2148  void ScintillaWin::Copy() {
2149  	if (!sel.Empty()) {
2150  		SelectionText selectedText;
2151  		CopySelectionRange(&amp;selectedText);
2152  		CopyToClipboard(selectedText);
2153  	}
2154  }
2155  bool ScintillaWin::CanPaste() {
2156  	if (!Editor::CanPaste())
2157  		return false;
2158  	return ::IsClipboardFormatAvailable(CF_UNICODETEXT) != FALSE;
2159  }
2160  namespace {
2161  class GlobalMemory {
2162  	HGLOBAL hand {};
2163  public:
2164  	void *ptr {};
2165  	GlobalMemory() noexcept {
2166  	}
2167  	explicit GlobalMemory(HGLOBAL hand_) noexcept : hand(hand_) {
2168  		if (hand) {
2169  			ptr = ::GlobalLock(hand);
2170  		}
2171  	}
2172  	GlobalMemory(const GlobalMemory &amp;) = delete;
2173  	GlobalMemory(GlobalMemory &amp;&amp;) = delete;
2174  	GlobalMemory &amp;operator=(const GlobalMemory &amp;) = delete;
2175  	GlobalMemory &amp;operator=(GlobalMemory &amp;&amp;) = delete;
2176  	~GlobalMemory() {
2177  		assert(!ptr);
2178  		assert(!hand);
2179  	}
2180  	void Allocate(size_t bytes) noexcept {
2181  		assert(!hand);
2182  		hand = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, bytes);
2183  		if (hand) {
2184  			ptr = ::GlobalLock(hand);
2185  		}
2186  	}
2187  	HGLOBAL Unlock() noexcept {
2188  		assert(ptr);
2189  		HGLOBAL handCopy = hand;
2190  		::GlobalUnlock(hand);
2191  		ptr = nullptr;
2192  		hand = {};
2193  		return handCopy;
2194  	}
2195  	void SetClip(UINT uFormat) noexcept {
2196  		::SetClipboardData(uFormat, Unlock());
2197  	}
2198  	operator bool() const noexcept {
2199  		return ptr != nullptr;
2200  	}
2201  	SIZE_T Size() const noexcept {
2202  		return ::GlobalSize(hand);
2203  	}
2204  };
2205  bool OpenClipboardRetry(HWND hwnd) noexcept {
2206  	for (int attempt=0; attempt&lt;8; attempt++) {
2207  		if (attempt &gt; 0) {
2208  			::Sleep(1 &lt;&lt; (attempt-1));
2209  		}
2210  		if (::OpenClipboard(hwnd)) {
2211  			return true;
2212  		}
2213  	}
2214  	return false;
2215  }
2216  bool IsValidFormatEtc(const FORMATETC *pFE) noexcept {
2217  	return pFE-&gt;ptd == nullptr &amp;&amp;
2218  		(pFE-&gt;dwAspect &amp; DVASPECT_CONTENT) != 0 &amp;&amp;
2219  		pFE-&gt;lindex == -1 &amp;&amp;
2220  		(pFE-&gt;tymed &amp; TYMED_HGLOBAL) != 0;
2221  }
2222  bool SupportedFormat(const FORMATETC *pFE) noexcept {
2223  	return pFE-&gt;cfFormat == CF_UNICODETEXT &amp;&amp;
2224  		IsValidFormatEtc(pFE);
2225  }
2226  }
2227  void ScintillaWin::Paste() {
2228  	if (!::OpenClipboardRetry(MainHWND())) {
2229  		return;
2230  	}
2231  	UndoGroup ug(pdoc);
2232  	const bool isLine = SelectionEmpty() &amp;&amp;
2233  		(::IsClipboardFormatAvailable(cfLineSelect) || ::IsClipboardFormatAvailable(cfVSLineTag));
2234  	ClearSelection(multiPasteMode == MultiPaste::Each);
2235  	bool isRectangular = (::IsClipboardFormatAvailable(cfColumnSelect) != 0);
2236  	if (!isRectangular) {
2237  		GlobalMemory memBorlandSelection(::GetClipboardData(cfBorlandIDEBlockType));
2238  		if (memBorlandSelection) {
2239  			isRectangular = (memBorlandSelection.Size() == 1) &amp;&amp; (static_cast&lt;BYTE *&gt;(memBorlandSelection.ptr)[0] == 0x02);
2240  			memBorlandSelection.Unlock();
2241  		}
2242  	}
2243  	const PasteShape pasteShape = isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream);
2244  	GlobalMemory memUSelection(::GetClipboardData(CF_UNICODETEXT));
2245  	if (const wchar_t *uptr = static_cast&lt;const wchar_t *&gt;(memUSelection.ptr)) {
2246  		const std::string putf = EncodeWString(uptr);
2247  		InsertPasteShape(putf.c_str(), putf.length(), pasteShape);
2248  		memUSelection.Unlock();
2249  	}
2250  	::CloseClipboard();
2251  	Redraw();
2252  }
2253  void ScintillaWin::CreateCallTipWindow(PRectangle) {
2254  	if (!ct.wCallTip.Created()) {
2255  		HWND wnd = ::CreateWindow(callClassName, TEXT(&quot;ACallTip&quot;),
2256  					     WS_POPUP, 100, 100, 150, 20,
2257  					     MainHWND(), 0,
2258  					     GetWindowInstance(MainHWND()),
2259  					     this);
2260  		ct.wCallTip = wnd;
2261  		ct.wDraw = wnd;
2262  	}
2263  }
2264  void ScintillaWin::AddToPopUp(const char *label, int cmd, bool enabled) {
2265  	HMENU hmenuPopup = static_cast&lt;HMENU&gt;(popup.GetID());
2266  	if (!label[0])
2267  		::AppendMenuA(hmenuPopup, MF_SEPARATOR, 0, &quot;&quot;);
2268  	else if (enabled)
2269  		::AppendMenuA(hmenuPopup, MF_STRING, cmd, label);
2270  	else
2271  		::AppendMenuA(hmenuPopup, MF_STRING | MF_DISABLED | MF_GRAYED, cmd, label);
2272  }
2273  void ScintillaWin::ClaimSelection() {
2274  }
2275  STDMETHODIMP FormatEnumerator::QueryInterface(REFIID riid, PVOID *ppv) {
2276  	*ppv = nullptr;
2277  	if (riid == IID_IUnknown || riid == IID_IEnumFORMATETC) {
2278  		*ppv = this;
2279  	} else {
2280  		return E_NOINTERFACE;
2281  	}
2282  	AddRef();
2283  	return S_OK;
2284  }
2285  STDMETHODIMP_(ULONG)FormatEnumerator::AddRef() {
2286  	return ++ref;
2287  }
2288  STDMETHODIMP_(ULONG)FormatEnumerator::Release() {
2289  	const ULONG refs = --ref;
2290  	if (refs == 0) {
2291  		delete this;
2292  	}
2293  	return refs;
2294  }
2295  STDMETHODIMP FormatEnumerator::Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched) {
2296  	if (!rgelt) return E_POINTER;
2297  	ULONG putPos = 0;
2298  	while ((pos &lt; formats.size()) &amp;&amp; (putPos &lt; celt)) {
2299  		rgelt-&gt;cfFormat = formats[pos];
2300  		rgelt-&gt;ptd = nullptr;
2301  		rgelt-&gt;dwAspect = DVASPECT_CONTENT;
2302  		rgelt-&gt;lindex = -1;
2303  		rgelt-&gt;tymed = TYMED_HGLOBAL;
2304  		rgelt++;
2305  		pos++;
2306  		putPos++;
2307  	}
2308  	if (pceltFetched)
2309  		*pceltFetched = putPos;
2310  	return putPos ? S_OK : S_FALSE;
2311  }
2312  STDMETHODIMP FormatEnumerator::Skip(ULONG celt) {
2313  	pos += celt;
2314  	return S_OK;
2315  }
2316  STDMETHODIMP FormatEnumerator::Reset() {
2317  	pos = 0;
2318  	return S_OK;
2319  }
2320  STDMETHODIMP FormatEnumerator::Clone(IEnumFORMATETC **ppenum) {
2321  	FormatEnumerator *pfe;
2322  	try {
2323  		pfe = new FormatEnumerator(pos, &amp;formats[0], formats.size());
2324  	} catch (...) {
2325  		return E_OUTOFMEMORY;
2326  	}
2327  	return pfe-&gt;QueryInterface(IID_IEnumFORMATETC, reinterpret_cast&lt;void **&gt;(ppenum));
2328  }
2329  FormatEnumerator::FormatEnumerator(ULONG pos_, const CLIPFORMAT formats_[], size_t formatsLen_) {
2330  	ref = 0;   
2331  	pos = pos_;
2332  	formats.insert(formats.begin(), formats_, formats_+formatsLen_);
2333  }
2334  STDMETHODIMP DropSource::QueryInterface(REFIID riid, PVOID *ppv) {
2335  	return sci-&gt;QueryInterface(riid, ppv);
2336  }
2337  STDMETHODIMP_(ULONG)DropSource::AddRef() {
2338  	return sci-&gt;AddRef();
2339  }
2340  STDMETHODIMP_(ULONG)DropSource::Release() {
2341  	return sci-&gt;Release();
2342  }
2343  STDMETHODIMP DropSource::QueryContinueDrag(BOOL fEsc, DWORD grfKeyState) {
2344  	if (fEsc)
2345  		return DRAGDROP_S_CANCEL;
2346  	if (!(grfKeyState &amp; MK_LBUTTON))
2347  		return DRAGDROP_S_DROP;
2348  	return S_OK;
2349  }
2350  STDMETHODIMP DropSource::GiveFeedback(DWORD) {
2351  	return DRAGDROP_S_USEDEFAULTCURSORS;
2352  }
2353  STDMETHODIMP DataObject::QueryInterface(REFIID riid, PVOID *ppv) {
2354  	return sci-&gt;QueryInterface(riid, ppv);
2355  }
2356  STDMETHODIMP_(ULONG)DataObject::AddRef() {
2357  	return sci-&gt;AddRef();
2358  }
2359  STDMETHODIMP_(ULONG)DataObject::Release() {
2360  	return sci-&gt;Release();
2361  }
2362  STDMETHODIMP DataObject::GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) {
2363  	return sci-&gt;GetData(pFEIn, pSTM);
2364  }
2365  STDMETHODIMP DataObject::GetDataHere(FORMATETC *, STGMEDIUM *) {
2366  	return E_NOTIMPL;
2367  }
2368  STDMETHODIMP DataObject::QueryGetData(FORMATETC *pFE) {
2369  	if (sci-&gt;DragIsRectangularOK(pFE-&gt;cfFormat) &amp;&amp; IsValidFormatEtc(pFE)) {
2370  		return S_OK;
2371  	}
2372  	if (SupportedFormat(pFE)) {
2373  		return S_OK;
2374  	} else {
2375  		return S_FALSE;
2376  	}
2377  }
2378  STDMETHODIMP DataObject::GetCanonicalFormatEtc(FORMATETC *, FORMATETC *pFEOut) {
2379  	pFEOut-&gt;cfFormat = CF_UNICODETEXT;
2380  	pFEOut-&gt;ptd = nullptr;
2381  	pFEOut-&gt;dwAspect = DVASPECT_CONTENT;
2382  	pFEOut-&gt;lindex = -1;
2383  	pFEOut-&gt;tymed = TYMED_HGLOBAL;
2384  	return S_OK;
2385  }
2386  STDMETHODIMP DataObject::SetData(FORMATETC *, STGMEDIUM *, BOOL) {
2387  	return E_FAIL;
2388  }
2389  STDMETHODIMP DataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum) {
2390  	try {
2391  		if (dwDirection != DATADIR_GET) {
2392  			*ppEnum = nullptr;
2393  			return E_FAIL;
2394  		}
2395  		const CLIPFORMAT formats[] = {CF_UNICODETEXT};
2396  		FormatEnumerator *pfe = new FormatEnumerator(0, formats, std::size(formats));
2397  		return pfe-&gt;QueryInterface(IID_IEnumFORMATETC, reinterpret_cast&lt;void **&gt;(ppEnum));
2398  	} catch (std::bad_alloc &amp;) {
2399  		sci-&gt;errorStatus = Status::BadAlloc;
2400  		return E_OUTOFMEMORY;
2401  	} catch (...) {
2402  		sci-&gt;errorStatus = Status::Failure;
2403  		return E_FAIL;
2404  	}
2405  }
2406  STDMETHODIMP DataObject::DAdvise(FORMATETC *, DWORD, IAdviseSink *, PDWORD) {
2407  	return E_FAIL;
2408  }
2409  STDMETHODIMP DataObject::DUnadvise(DWORD) {
2410  	return E_FAIL;
2411  }
2412  STDMETHODIMP DataObject::EnumDAdvise(IEnumSTATDATA **) {
2413  	return E_FAIL;
2414  }
2415  STDMETHODIMP DropTarget::QueryInterface(REFIID riid, PVOID *ppv) {
2416  	return sci-&gt;QueryInterface(riid, ppv);
2417  }
2418  STDMETHODIMP_(ULONG)DropTarget::AddRef() {
2419  	return sci-&gt;AddRef();
2420  }
2421  STDMETHODIMP_(ULONG)DropTarget::Release() {
2422  	return sci-&gt;Release();
2423  }
2424  STDMETHODIMP DropTarget::DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2425  	try {
2426  		return sci-&gt;DragEnter(pIDataSource, grfKeyState, pt, pdwEffect);
2427  	} catch (...) {
2428  		sci-&gt;errorStatus = Status::Failure;
2429  	}
2430  	return E_FAIL;
2431  }
2432  STDMETHODIMP DropTarget::DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2433  	try {
2434  		return sci-&gt;DragOver(grfKeyState, pt, pdwEffect);
2435  	} catch (...) {
2436  		sci-&gt;errorStatus = Status::Failure;
2437  	}
2438  	return E_FAIL;
2439  }
2440  STDMETHODIMP DropTarget::DragLeave() {
2441  	try {
2442  		return sci-&gt;DragLeave();
2443  	} catch (...) {
2444  		sci-&gt;errorStatus = Status::Failure;
2445  	}
2446  	return E_FAIL;
2447  }
2448  STDMETHODIMP DropTarget::Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2449  	try {
2450  		return sci-&gt;Drop(pIDataSource, grfKeyState, pt, pdwEffect);
2451  	} catch (...) {
2452  		sci-&gt;errorStatus = Status::Failure;
2453  	}
2454  	return E_FAIL;
2455  }
2456  void ScintillaWin::ImeStartComposition() {
2457  	if (caret.active) {
2458  		IMContext imc(MainHWND());
2459  		const Point pos = PointMainCaret();
2460  		COMPOSITIONFORM CompForm;
2461  		CompForm.dwStyle = CFS_POINT;
2462  		CompForm.ptCurrentPos = POINTFromPoint(pos);
2463  		::ImmSetCompositionWindow(imc.hIMC, &amp;CompForm);
2464  		if (stylesValid) {
2465  			const int styleHere = pdoc-&gt;StyleIndexAt(sel.MainCaret());
2466  			LOGFONTW lf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, L&quot;&quot;};
2467  			int sizeZoomed = vs.styles[styleHere].size + vs.zoomLevel * FontSizeMultiplier;
2468  			if (sizeZoomed &lt;= 2 * FontSizeMultiplier)	
2469  				sizeZoomed = 2 * FontSizeMultiplier;
2470  			lf.lfHeight = -::MulDiv(sizeZoomed, dpi, 72*FontSizeMultiplier);
2471  			lf.lfWeight = static_cast&lt;LONG&gt;(vs.styles[styleHere].weight);
2472  			lf.lfItalic = vs.styles[styleHere].italic ? 1 : 0;
2473  			lf.lfCharSet = DEFAULT_CHARSET;
2474  			lf.lfFaceName[0] = L&#x27;\0&#x27;;
2475  			if (vs.styles[styleHere].fontName) {
2476  				const char* fontName = vs.styles[styleHere].fontName;
2477  				UTF16FromUTF8(std::string_view(fontName), lf.lfFaceName, LF_FACESIZE);
2478  			}
2479  			::ImmSetCompositionFontW(imc.hIMC, &amp;lf);
2480  		}
2481  		DropCaret();
2482  	}
2483  }
2484  void ScintillaWin::ImeEndComposition() {
2485  	view.imeCaretBlockOverride = false;
2486  	pdoc-&gt;TentativeUndo();
2487  	ShowCaretAtCurrentPosition();
2488  }
2489  LRESULT ScintillaWin::ImeOnReconvert(LPARAM lParam) {
2490  	const Sci::Position mainStart = sel.RangeMain().Start().Position();
2491  	const Sci::Position mainEnd = sel.RangeMain().End().Position();
2492  	const Sci::Line curLine = pdoc-&gt;SciLineFromPosition(mainStart);
2493  	if (curLine != pdoc-&gt;LineFromPosition(mainEnd))
2494  		return 0;
2495  	const Sci::Position baseStart = pdoc-&gt;LineStart(curLine);
2496  	const Sci::Position baseEnd = pdoc-&gt;LineEnd(curLine);
2497  	if ((baseStart == baseEnd) || (mainEnd &gt; baseEnd))
2498  		return 0;
2499  	const int codePage = CodePageOfDocument();
2500  	const std::wstring rcFeed = StringDecode(RangeText(baseStart, baseEnd), codePage);
2501  	const int rcFeedLen = static_cast&lt;int&gt;(rcFeed.length()) * sizeof(wchar_t);
2502  	const int rcSize = sizeof(RECONVERTSTRING) + rcFeedLen + sizeof(wchar_t);
2503  	RECONVERTSTRING *rc = static_cast&lt;RECONVERTSTRING *&gt;(PtrFromSPtr(lParam));
2504  	if (!rc)
2505  		return rcSize; 
2506  	wchar_t *rcFeedStart = reinterpret_cast&lt;wchar_t*&gt;(rc + 1);
2507  	memcpy(rcFeedStart, &amp;rcFeed[0], rcFeedLen);
2508  	std::string rcCompString = RangeText(mainStart, mainEnd);
2509  	std::wstring rcCompWstring = StringDecode(rcCompString, codePage);
2510  	std::string rcCompStart = RangeText(baseStart, mainStart);
2511  	std::wstring rcCompWstart = StringDecode(rcCompStart, codePage);
2512  	rc-&gt;dwVersion = 0; 
2513  	rc-&gt;dwStrLen = static_cast&lt;DWORD&gt;(rcFeed.length());
2514  	rc-&gt;dwStrOffset = sizeof(RECONVERTSTRING);
2515  	rc-&gt;dwCompStrLen = static_cast&lt;DWORD&gt;(rcCompWstring.length());
2516  	rc-&gt;dwCompStrOffset = static_cast&lt;DWORD&gt;(rcCompWstart.length()) * sizeof(wchar_t);
2517  	rc-&gt;dwTargetStrLen = rc-&gt;dwCompStrLen;
2518  	rc-&gt;dwTargetStrOffset =rc-&gt;dwCompStrOffset;
2519  	IMContext imc(MainHWND());
2520  	if (!imc.hIMC)
2521  		return 0;
2522  	if (!::ImmSetCompositionStringW(imc.hIMC, SCS_QUERYRECONVERTSTRING, rc, rcSize, nullptr, 0))
2523  		return 0;
2524  	const int tgWlen = rc-&gt;dwTargetStrLen;
2525  	const int tgWstart = rc-&gt;dwTargetStrOffset / sizeof(wchar_t);
2526  	std::string tgCompStart = StringEncode(rcFeed.substr(0, tgWstart), codePage);
2527  	std::string tgComp = StringEncode(rcFeed.substr(tgWstart, tgWlen), codePage);
2528  	const int adjust = static_cast&lt;int&gt;(tgCompStart.length() - rcCompStart.length());
2529  	const int docCompLen = static_cast&lt;int&gt;(tgComp.length());
2530  	for (size_t r=0; r&lt;sel.Count(); r++) {
2531  		const Sci::Position rBase = sel.Range(r).Start().Position();
2532  		const Sci::Position docCompStart = rBase + adjust;
2533  		if (inOverstrike) { 
2534  			sel.Range(r).caret.SetPosition(docCompStart);
2535  			sel.Range(r).anchor.SetPosition(docCompStart);
2536  		} else {
2537  			const Sci::Position lineEnd = pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(rBase));
2538  			const Sci::Position overflow = (docCompStart + docCompLen) - lineEnd;
2539  			if (overflow &gt; 0) {
2540  				pdoc-&gt;DeleteChars(docCompStart, docCompLen - overflow);
2541  			} else {
2542  				pdoc-&gt;DeleteChars(docCompStart, docCompLen);
2543  			}
2544  		}
2545  	}
2546  	return rcSize;
2547  }
2548  LRESULT ScintillaWin::ImeOnDocumentFeed(LPARAM lParam) const {
2549  	const Sci::Position curPos = CurrentPosition();
2550  	const Sci::Line curLine = pdoc-&gt;SciLineFromPosition(curPos);
2551  	const Sci::Position lineStart = pdoc-&gt;LineStart(curLine);
2552  	const Sci::Position lineEnd = pdoc-&gt;LineEnd(curLine);
2553  	const std::wstring rcFeed = StringDecode(RangeText(lineStart, lineEnd), CodePageOfDocument());
2554  	const int rcFeedLen = static_cast&lt;int&gt;(rcFeed.length()) * sizeof(wchar_t);
2555  	const int rcSize = sizeof(RECONVERTSTRING) + rcFeedLen + sizeof(wchar_t);
2556  	RECONVERTSTRING *rc = static_cast&lt;RECONVERTSTRING *&gt;(PtrFromSPtr(lParam));
2557  	if (!rc)
2558  		return rcSize;
2559  	wchar_t *rcFeedStart = reinterpret_cast&lt;wchar_t*&gt;(rc + 1);
2560  	memcpy(rcFeedStart, &amp;rcFeed[0], rcFeedLen);
2561  	IMContext imc(MainHWND());
2562  	if (!imc.hIMC)
2563  		return 0;
2564  	const size_t compStrLen = imc.GetCompositionString(GCS_COMPSTR).size();
2565  	const int imeCaretPos = imc.GetImeCaretPos();
2566  	const Sci::Position compStart = pdoc-&gt;GetRelativePositionUTF16(curPos, -imeCaretPos);
2567  	const Sci::Position compStrOffset = pdoc-&gt;CountUTF16(lineStart, compStart);
2568  	rc-&gt;dwVersion = 0; 
2569  	rc-&gt;dwStrLen = static_cast&lt;DWORD&gt;(rcFeed.length());
2570  	rc-&gt;dwStrOffset = sizeof(RECONVERTSTRING); 
2571  	rc-&gt;dwCompStrLen = static_cast&lt;DWORD&gt;(compStrLen);
2572  	rc-&gt;dwCompStrOffset = static_cast&lt;DWORD&gt;(compStrOffset) * sizeof(wchar_t);
2573  	rc-&gt;dwTargetStrLen = rc-&gt;dwCompStrLen;
2574  	rc-&gt;dwTargetStrOffset = rc-&gt;dwCompStrOffset;
2575  	return rcSize; 
2576  }
2577  void ScintillaWin::GetIntelliMouseParameters() noexcept {
2578  	::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &amp;linesPerScroll, 0);
2579  	if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &amp;charsPerScroll, 0)) {
2580  		charsPerScroll = (linesPerScroll == WHEEL_PAGESCROLL) ? 3 : linesPerScroll;
2581  	}
2582  }
2583  void ScintillaWin::CopyToGlobal(GlobalMemory &amp;gmUnicode, const SelectionText &amp;selectedText) {
2584  	const std::string_view svSelected(selectedText.Data(), selectedText.LengthWithTerminator());
2585  	if (IsUnicodeMode()) {
2586  		const size_t uchars = UTF16Length(svSelected);
2587  		gmUnicode.Allocate(2 * uchars);
2588  		if (gmUnicode) {
2589  			UTF16FromUTF8(svSelected,
2590  				static_cast&lt;wchar_t *&gt;(gmUnicode.ptr), uchars);
2591  		}
2592  	} else {
2593  		const UINT cpSrc = CodePageFromCharSet(
2594  			selectedText.characterSet, selectedText.codePage);
2595  		const size_t uLen = WideCharLenFromMultiByte(cpSrc, svSelected);
2596  		gmUnicode.Allocate(2 * uLen);
2597  		if (gmUnicode) {
2598  			WideCharFromMultiByte(cpSrc, svSelected,
2599  				static_cast&lt;wchar_t *&gt;(gmUnicode.ptr), uLen);
2600  		}
2601  	}
2602  }
2603  void ScintillaWin::CopyToClipboard(const SelectionText &amp;selectedText) {
2604  	if (!::OpenClipboardRetry(MainHWND())) {
2605  		return;
2606  	}
2607  	::EmptyClipboard();
2608  	GlobalMemory uniText;
2609  	CopyToGlobal(uniText, selectedText);
2610  	if (uniText) {
2611  		uniText.SetClip(CF_UNICODETEXT);
2612  	}
2613  	if (selectedText.rectangular) {
2614  		::SetClipboardData(cfColumnSelect, 0);
2615  		GlobalMemory borlandSelection;
2616  		borlandSelection.Allocate(1);
2617  		if (borlandSelection) {
2618  			static_cast&lt;BYTE *&gt;(borlandSelection.ptr)[0] = 0x02;
2619  			borlandSelection.SetClip(cfBorlandIDEBlockType);
2620  		}
2621  	}
2622  	if (selectedText.lineCopy) {
2623  		::SetClipboardData(cfLineSelect, 0);
2624  		::SetClipboardData(cfVSLineTag, 0);
2625  	}
2626  	::CloseClipboard();
2627  }
2628  void ScintillaWin::ScrollMessage(WPARAM wParam) {
2629  	SCROLLINFO sci = {};
2630  	sci.cbSize = sizeof(sci);
2631  	sci.fMask = SIF_ALL;
2632  	GetScrollInfo(SB_VERT, &amp;sci);
2633  	Sci::Line topLineNew = topLine;
2634  	switch (LOWORD(wParam)) {
2635  	case SB_LINEUP:
2636  		topLineNew -= 1;
2637  		break;
2638  	case SB_LINEDOWN:
2639  		topLineNew += 1;
2640  		break;
2641  	case SB_PAGEUP:
2642  		topLineNew -= LinesToScroll(); break;
2643  	case SB_PAGEDOWN: topLineNew += LinesToScroll(); break;
2644  	case SB_TOP: topLineNew = 0; break;
2645  	case SB_BOTTOM: topLineNew = MaxScrollPos(); break;
2646  	case SB_THUMBPOSITION: topLineNew = sci.nTrackPos; break;
2647  	case SB_THUMBTRACK: topLineNew = sci.nTrackPos; break;
2648  	}
2649  	ScrollTo(topLineNew);
2650  }
2651  void ScintillaWin::HorizontalScrollMessage(WPARAM wParam) {
2652  	int xPos = xOffset;
2653  	const PRectangle rcText = GetTextRectangle();
2654  	const int pageWidth = static_cast&lt;int&gt;(rcText.Width() * 2 / 3);
2655  	switch (LOWORD(wParam)) {
2656  	case SB_LINEUP:
2657  		xPos -= 20;
2658  		break;
2659  	case SB_LINEDOWN:	
2660  		xPos += 20;
2661  		break;
2662  	case SB_PAGEUP:
2663  		xPos -= pageWidth;
2664  		break;
2665  	case SB_PAGEDOWN:
2666  		xPos += pageWidth;
2667  		break;
2668  	case SB_TOP:
2669  		xPos = 0;
2670  		break;
2671  	case SB_BOTTOM:
2672  		xPos = scrollWidth;
2673  		break;
2674  	case SB_THUMBPOSITION:
2675  	case SB_THUMBTRACK: {
2676  			SCROLLINFO si {};
2677  			si.cbSize = sizeof(si);
2678  			si.fMask = SIF_TRACKPOS;
2679  			if (GetScrollInfo(SB_HORZ, &amp;si)) {
2680  				xPos = si.nTrackPos;
2681  			}
2682  		}
2683  		break;
2684  	}
2685  	HorizontalScrollToClamped(xPos);
2686  }
2687  void ScintillaWin::FullPaint() {
2688  	if ((technology == Technology::Default) || (technology == Technology::DirectWriteDC)) {
2689  		HDC hdc = ::GetDC(MainHWND());
2690  		FullPaintDC(hdc);
2691  		::ReleaseDC(MainHWND(), hdc);
2692  	} else {
2693  		FullPaintDC({});
2694  	}
2695  }
2696  void ScintillaWin::FullPaintDC(HDC hdc) {
2697  	paintState = PaintState::painting;
2698  	rcPaint = GetClientRectangle();
2699  	paintingAllText = true;
2700  	PaintDC(hdc);
2701  	paintState = PaintState::notPainting;
2702  }
2703  namespace {
2704  bool CompareDevCap(HDC hdc, HDC hOtherDC, int nIndex) noexcept {
2705  	return ::GetDeviceCaps(hdc, nIndex) == ::GetDeviceCaps(hOtherDC, nIndex);
2706  }
2707  }
2708  bool ScintillaWin::IsCompatibleDC(HDC hOtherDC) noexcept {
2709  	HDC hdc = ::GetDC(MainHWND());
2710  	const bool isCompatible =
2711  		CompareDevCap(hdc, hOtherDC, TECHNOLOGY) &amp;&amp;
2712  		CompareDevCap(hdc, hOtherDC, LOGPIXELSY) &amp;&amp;
2713  		CompareDevCap(hdc, hOtherDC, LOGPIXELSX) &amp;&amp;
2714  		CompareDevCap(hdc, hOtherDC, BITSPIXEL) &amp;&amp;
2715  		CompareDevCap(hdc, hOtherDC, PLANES);
2716  	::ReleaseDC(MainHWND(), hdc);
2717  	return isCompatible;
2718  }
2719  DWORD ScintillaWin::EffectFromState(DWORD grfKeyState) const noexcept {
2720  	DWORD dwEffect;
2721  	if (inDragDrop == DragDrop::dragging)	
2722  		dwEffect = DROPEFFECT_MOVE;
2723  	else
2724  		dwEffect = DROPEFFECT_COPY;
2725  	if (grfKeyState &amp; MK_ALT)
2726  		dwEffect = DROPEFFECT_MOVE;
2727  	if (grfKeyState &amp; MK_CONTROL)
2728  		dwEffect = DROPEFFECT_COPY;
2729  	return dwEffect;
2730  }
2731  STDMETHODIMP ScintillaWin::QueryInterface(REFIID riid, PVOID *ppv) {
2732  	*ppv = nullptr;
2733  	if (riid == IID_IUnknown) {
2734  		*ppv = &amp;dt;
2735  	} else if (riid == IID_IDropSource) {
2736  		*ppv = &amp;ds;
2737  	} else if (riid == IID_IDropTarget) {
2738  		*ppv = &amp;dt;
2739  	} else if (riid == IID_IDataObject) {
2740  		*ppv = &amp;dob;
2741  	}
2742  	if (!*ppv)
2743  		return E_NOINTERFACE;
2744  	return S_OK;
2745  }
2746  STDMETHODIMP_(ULONG) ScintillaWin::AddRef() {
2747  	return 1;
2748  }
2749  STDMETHODIMP_(ULONG) ScintillaWin::Release() {
2750  	return 1;
2751  }
2752  STDMETHODIMP ScintillaWin::DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
2753                                       POINTL, PDWORD pdwEffect) {
2754  	if (!pIDataSource )
2755  		return E_POINTER;
2756  	FORMATETC fmtu = {CF_UNICODETEXT, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
2757  	const HRESULT hrHasUText = pIDataSource-&gt;QueryGetData(&amp;fmtu);
2758  	hasOKText = (hrHasUText == S_OK);
2759  	if (hasOKText) {
2760  		*pdwEffect = EffectFromState(grfKeyState);
2761  	} else {
2762  		*pdwEffect = DROPEFFECT_NONE;
2763  	}
2764  	return S_OK;
2765  }
2766  STDMETHODIMP ScintillaWin::DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2767  	try {
2768  		if (!hasOKText || pdoc-&gt;IsReadOnly()) {
2769  			*pdwEffect = DROPEFFECT_NONE;
2770  			return S_OK;
2771  		}
2772  		*pdwEffect = EffectFromState(grfKeyState);
2773  		POINT rpt = {pt.x, pt.y};
2774  		::ScreenToClient(MainHWND(), &amp;rpt);
2775  		SetDragPosition(SPositionFromLocation(PointFromPOINT(rpt), false, false, UserVirtualSpace()));
2776  		return S_OK;
2777  	} catch (...) {
2778  		errorStatus = Status::Failure;
2779  	}
2780  	return E_FAIL;
2781  }
2782  STDMETHODIMP ScintillaWin::DragLeave() {
2783  	try {
2784  		SetDragPosition(SelectionPosition(Sci::invalidPosition));
2785  		return S_OK;
2786  	} catch (...) {
2787  		errorStatus = Status::Failure;
2788  	}
2789  	return E_FAIL;
2790  }
2791  STDMETHODIMP ScintillaWin::Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
2792                                  POINTL pt, PDWORD pdwEffect) {
2793  	try {
2794  		*pdwEffect = EffectFromState(grfKeyState);
2795  		if (!pIDataSource)
2796  			return E_POINTER;
2797  		SetDragPosition(SelectionPosition(Sci::invalidPosition));
2798  		std::string putf;
2799  		FORMATETC fmtu = {CF_UNICODETEXT, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
2800  		STGMEDIUM medium{};
2801  		const HRESULT hr = pIDataSource-&gt;GetData(&amp;fmtu, &amp;medium);
2802  		if (!SUCCEEDED(hr)) {
2803  			return hr;
2804  		}
2805  		if (medium.hGlobal) {
2806  			GlobalMemory memUDrop(medium.hGlobal);
2807  			if (const wchar_t *uptr = static_cast&lt;const wchar_t *&gt;(memUDrop.ptr)) {
2808  				putf = EncodeWString(uptr);
2809  			}
2810  			memUDrop.Unlock();
2811  		}
2812  		if (putf.empty()) {
2813  			return S_OK;
2814  		}
2815  		FORMATETC fmtr = {cfColumnSelect, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
2816  		const bool isRectangular = S_OK == pIDataSource-&gt;QueryGetData(&amp;fmtr);
2817  		POINT rpt = {pt.x, pt.y};
2818  		::ScreenToClient(MainHWND(), &amp;rpt);
2819  		const SelectionPosition movePos = SPositionFromLocation(PointFromPOINT(rpt), false, false, UserVirtualSpace());
2820  		DropAt(movePos, putf.c_str(), putf.size(), *pdwEffect == DROPEFFECT_MOVE, isRectangular);
2821  		::ReleaseStgMedium(&amp;medium);
2822  		return S_OK;
2823  	} catch (...) {
2824  		errorStatus = Status::Failure;
2825  	}
2826  	return E_FAIL;
2827  }
2828  STDMETHODIMP ScintillaWin::GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) {
2829  	if (!SupportedFormat(pFEIn)) {
2830  		return DATA_E_FORMATETC;
2831  	}
2832  	pSTM-&gt;tymed = TYMED_HGLOBAL;
2833  	GlobalMemory uniText;
2834  	CopyToGlobal(uniText, drag);
2835  	pSTM-&gt;hGlobal = uniText ? uniText.Unlock() : 0;
2836  	pSTM-&gt;pUnkForRelease = nullptr;
2837  	return S_OK;
2838  }
2839  void ScintillaWin::Prepare() noexcept {
2840  	Platform_Initialise(hInstance);
2841  	WNDCLASSEX wndclassc{};
2842  	wndclassc.cbSize = sizeof(wndclassc);
2843  	wndclassc.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
2844  	wndclassc.cbWndExtra = sizeof(ScintillaWin *);
2845  	wndclassc.hInstance = hInstance;
2846  	wndclassc.lpfnWndProc = ScintillaWin::CTWndProc;
2847  	wndclassc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
2848  	wndclassc.lpszClassName = callClassName;
2849  	callClassAtom = ::RegisterClassEx(&amp;wndclassc);
2850  }
2851  bool ScintillaWin::Register(HINSTANCE hInstance_) noexcept {
2852  	hInstance = hInstance_;
2853  	WNDCLASSEXW wndclass {};
2854  	wndclass.cbSize = sizeof(wndclass);
2855  	wndclass.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
2856  	wndclass.lpfnWndProc = ScintillaWin::SWndProc;
2857  	wndclass.cbWndExtra = sizeof(ScintillaWin *);
2858  	wndclass.hInstance = hInstance;
2859  	wndclass.lpszClassName = L&quot;Scintilla&quot;;
2860  	scintillaClassAtom = ::RegisterClassExW(&amp;wndclass);
2861  	const bool result = 0 != scintillaClassAtom;
2862  	return result;
2863  }
2864  bool ScintillaWin::Unregister() noexcept {
2865  	bool result = true;
2866  	if (0 != scintillaClassAtom) {
2867  		if (::UnregisterClass(MAKEINTATOM(scintillaClassAtom), hInstance) == 0) {
2868  			result = false;
2869  		}
2870  		scintillaClassAtom = 0;
2871  	}
2872  	if (0 != callClassAtom) {
2873  		if (::UnregisterClass(MAKEINTATOM(callClassAtom), hInstance) == 0) {
2874  			result = false;
2875  		}
2876  		callClassAtom = 0;
2877  	}
2878  	return result;
2879  }
2880  bool ScintillaWin::HasCaretSizeChanged() const noexcept {
2881  	if (
2882  		( (0 != vs.caret.width) &amp;&amp; (sysCaretWidth != vs.caret.width) )
2883  		|| ((0 != vs.lineHeight) &amp;&amp; (sysCaretHeight != vs.lineHeight))
2884  		) {
2885  		return true;
2886  	}
2887  	return false;
2888  }
2889  BOOL ScintillaWin::CreateSystemCaret() {
2890  	sysCaretWidth = vs.caret.width;
2891  	if (0 == sysCaretWidth) {
2892  		sysCaretWidth = 1;
2893  	}
2894  	sysCaretHeight = vs.lineHeight;
2895  	const int bitmapSize = (((sysCaretWidth + 15) &amp; ~15) &gt;&gt; 3) *
2896  		sysCaretHeight;
2897  	std::vector&lt;BYTE&gt; bits(bitmapSize);
2898  	sysCaretBitmap = ::CreateBitmap(sysCaretWidth, sysCaretHeight, 1,
2899  		1, &amp;bits[0]);
2900  	const BOOL retval = ::CreateCaret(
2901  		MainHWND(), sysCaretBitmap,
2902  		sysCaretWidth, sysCaretHeight);
2903  	if (technology == Technology::Default) {
2904  		::ShowCaret(MainHWND());
2905  	}
2906  	return retval;
2907  }
2908  BOOL ScintillaWin::DestroySystemCaret() noexcept {
2909  	::HideCaret(MainHWND());
2910  	const BOOL retval = ::DestroyCaret();
2911  	if (sysCaretBitmap) {
2912  		::DeleteObject(sysCaretBitmap);
2913  		sysCaretBitmap = {};
2914  	}
2915  	return retval;
2916  }
2917  LRESULT PASCAL ScintillaWin::CTWndProc(
2918  	HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
2919  	ScintillaWin *sciThis = static_cast&lt;ScintillaWin *&gt;(PointerFromWindow(hWnd));
2920  	try {
2921  		if (sciThis == nullptr) {
2922  			if (iMessage == WM_CREATE) {
2923  				CREATESTRUCT *pCreate = static_cast&lt;CREATESTRUCT *&gt;(PtrFromSPtr(lParam));
2924  				SetWindowPointer(hWnd, pCreate-&gt;lpCreateParams);
2925  				return 0;
2926  			} else {
2927  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
2928  			}
2929  		} else {
2930  			if (iMessage == WM_NCDESTROY) {
2931  				SetWindowPointer(hWnd, nullptr);
2932  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
2933  			} else if (iMessage == WM_PAINT) {
2934  				PAINTSTRUCT ps;
2935  				::BeginPaint(hWnd, &amp;ps);
2936  				std::unique_ptr&lt;Surface&gt; surfaceWindow(Surface::Allocate(sciThis-&gt;technology));
2937  #if defined(USE_D2D)
2938  				ID2D1HwndRenderTarget *pCTRenderTarget = nullptr;
2939  #endif
2940  				RECT rc;
2941  				GetClientRect(hWnd, &amp;rc);
2942  				if (sciThis-&gt;technology == Technology::Default) {
2943  					surfaceWindow-&gt;Init(ps.hdc, hWnd);
2944  				} else {
2945  #if defined(USE_D2D)
2946  					const int scaleFactor = sciThis-&gt;deviceScaleFactor;
2947  					D2D1_HWND_RENDER_TARGET_PROPERTIES dhrtp {};
2948  					dhrtp.hwnd = hWnd;
2949  					dhrtp.pixelSize = ::GetSizeUFromRect(rc, scaleFactor);
2950  					dhrtp.presentOptions = (sciThis-&gt;technology == Technology::DirectWriteRetain) ?
2951  						D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS : D2D1_PRESENT_OPTIONS_NONE;
2952  					D2D1_RENDER_TARGET_PROPERTIES drtp {};
2953  					drtp.type = D2D1_RENDER_TARGET_TYPE_DEFAULT;
2954  					drtp.pixelFormat.format = DXGI_FORMAT_UNKNOWN;
2955  					drtp.pixelFormat.alphaMode = D2D1_ALPHA_MODE_UNKNOWN;
2956  					drtp.dpiX = 96.f * scaleFactor;
2957  					drtp.dpiY = 96.f * scaleFactor;
2958  					drtp.usage = D2D1_RENDER_TARGET_USAGE_NONE;
2959  					drtp.minLevel = D2D1_FEATURE_LEVEL_DEFAULT;
2960  					if (!SUCCEEDED(pD2DFactory-&gt;CreateHwndRenderTarget(drtp, dhrtp, &amp;pCTRenderTarget))) {
2961  						surfaceWindow-&gt;Release();
2962  						::EndPaint(hWnd, &amp;ps);
2963  						return 0;
2964  					}
2965  					assert(pCTRenderTarget);
2966  					if (pCTRenderTarget) {
2967  						surfaceWindow-&gt;Init(pCTRenderTarget, hWnd);
2968  						pCTRenderTarget-&gt;BeginDraw();
2969  					}
2970  #endif
2971  				}
2972  				surfaceWindow-&gt;SetMode(sciThis-&gt;CurrentSurfaceMode());
2973  				sciThis-&gt;SetRenderingParams(surfaceWindow.get());
2974  				sciThis-&gt;ct.PaintCT(surfaceWindow.get());
2975  #if defined(USE_D2D)
2976  				if (pCTRenderTarget)
2977  					pCTRenderTarget-&gt;EndDraw();
2978  #endif
2979  				surfaceWindow-&gt;Release();
2980  #if defined(USE_D2D)
2981  				ReleaseUnknown(pCTRenderTarget);
2982  #endif
2983  				::EndPaint(hWnd, &amp;ps);
2984  				return 0;
2985  			} else if ((iMessage == WM_NCLBUTTONDOWN) || (iMessage == WM_NCLBUTTONDBLCLK)) {
2986  				POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
2987  				ScreenToClient(hWnd, &amp;pt);
2988  				sciThis-&gt;ct.MouseClick(PointFromPOINT(pt));
2989  				sciThis-&gt;CallTipClick();
2990  				return 0;
2991  			} else if (iMessage == WM_LBUTTONDOWN) {
2992  				sciThis-&gt;ct.MouseClick(PointFromLParam(lParam));
2993  				sciThis-&gt;CallTipClick();
2994  				return 0;
2995  			} else if (iMessage == WM_SETCURSOR) {
2996  				::SetCursor(::LoadCursor(NULL, IDC_ARROW));
2997  				return 0;
2998  			} else if (iMessage == WM_NCHITTEST) {
2999  				return HTCAPTION;
3000  			} else {
3001  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3002  			}
3003  		}
3004  	} catch (...) {
3005  		sciThis-&gt;errorStatus = Status::Failure;
3006  	}
3007  	return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3008  }
3009  sptr_t ScintillaWin::DirectFunction(
3010      sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam) {
3011  	ScintillaWin *sci = reinterpret_cast&lt;ScintillaWin *&gt;(ptr);
3012  	PLATFORM_ASSERT(::GetCurrentThreadId() == ::GetWindowThreadProcessId(sci-&gt;MainHWND(), nullptr));
3013  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3014  }
3015  sptr_t ScintillaWin::DirectStatusFunction(
3016      sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam, int *pStatus) {
3017  	ScintillaWin *sci = reinterpret_cast&lt;ScintillaWin *&gt;(ptr);
3018  	PLATFORM_ASSERT(::GetCurrentThreadId() == ::GetWindowThreadProcessId(sci-&gt;MainHWND(), nullptr));
3019  	const sptr_t returnValue = sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3020  	*pStatus = static_cast&lt;int&gt;(sci-&gt;errorStatus);
3021  	return returnValue;
3022  }
3023  namespace Scintilla::Internal {
3024  sptr_t DirectFunction(
3025      ScintillaWin *sci, UINT iMessage, uptr_t wParam, sptr_t lParam) {
3026  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3027  }
3028  }
3029  LRESULT PASCAL ScintillaWin::SWndProc(
3030  	HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3031  	ScintillaWin *sci = static_cast&lt;ScintillaWin *&gt;(PointerFromWindow(hWnd));
3032  	if (sci == nullptr) {
3033  		try {
3034  			if (iMessage == WM_CREATE) {
3035  				static std::once_flag once;
3036  				std::call_once(once, Prepare);
3037  				sci = new ScintillaWin(hWnd);
3038  				SetWindowPointer(hWnd, sci);
3039  				return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3040  			}
3041  		} catch (...) {
3042  		}
3043  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3044  	} else {
3045  		if (iMessage == WM_NCDESTROY) {
3046  			try {
3047  				sci-&gt;Finalise();
3048  				delete sci;
3049  			} catch (...) {
3050  			}
3051  			SetWindowPointer(hWnd, nullptr);
3052  			return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3053  		} else {
3054  			return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3055  		}
3056  	}
3057  }
3058  extern &quot;C&quot; int Scintilla_RegisterClasses(void *hInstance) {
3059  	const bool result = ScintillaWin::Register(static_cast&lt;HINSTANCE&gt;(hInstance));
3060  	return result;
3061  }
3062  namespace Scintilla::Internal {
3063  int ResourcesRelease(bool fromDllMain) noexcept {
3064  	const bool result = ScintillaWin::Unregister();
3065  	Platform_Finalise(fromDllMain);
3066  	return result;
3067  }
3068  int RegisterClasses(void *hInstance) noexcept {
3069  	const bool result = ScintillaWin::Register(static_cast&lt;HINSTANCE&gt;(hInstance));
3070  	return result;
3071  }
3072  }
3073  extern &quot;C&quot; int Scintilla_ReleaseResources() {
3074  	return Scintilla::Internal::ResourcesRelease(false);
3075  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaWin.cxx</h3>
            <pre><code>1  #include &lt;cstddef&gt;
2  #include &lt;cstdlib&gt;
3  #include &lt;cstdint&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstring&gt;
6  #include &lt;cstdio&gt;
7  #include &lt;cmath&gt;
8  #include &lt;climits&gt;
9  #include &lt;stdexcept&gt;
10  #include &lt;new&gt;
11  #include &lt;string&gt;
12  #include &lt;string_view&gt;
13  #include &lt;vector&gt;
14  #include &lt;map&gt;
15  #include &lt;set&gt;
16  #include &lt;optional&gt;
17  #include &lt;algorithm&gt;
18  #include &lt;memory&gt;
19  #include &lt;chrono&gt;
20  #include &lt;mutex&gt;
21  #if !defined(NOMINMAX)
22  #define NOMINMAX
23  #endif
24  #undef _WIN32_WINNT
25  #define _WIN32_WINNT 0x0A00
26  #undef WINVER
27  #define WINVER 0x0A00
28  #define WIN32_LEAN_AND_MEAN 1
29  #include &lt;windows.h&gt;
30  #include &lt;commctrl.h&gt;
31  #include &lt;richedit.h&gt;
32  #include &lt;windowsx.h&gt;
33  #include &lt;zmouse.h&gt;
34  #include &lt;ole2.h&gt;
35  #if !defined(DISABLE_D2D)
36  #define USE_D2D 1
37  #endif
38  #if defined(USE_D2D)
39  #include &lt;d2d1.h&gt;
40  #include &lt;dwrite.h&gt;
41  #endif
42  #include &quot;ScintillaTypes.h&quot;
43  #include &quot;ScintillaMessages.h&quot;
44  #include &quot;ScintillaStructures.h&quot;
45  #include &quot;ILoader.h&quot;
46  #include &quot;ILexer.h&quot;
47  #include &quot;Debugging.h&quot;
48  #include &quot;Geometry.h&quot;
49  #include &quot;Platform.h&quot;
50  #include &quot;CharacterCategoryMap.h&quot;
51  #include &quot;Position.h&quot;
52  #include &quot;UniqueString.h&quot;
53  #include &quot;SplitVector.h&quot;
54  #include &quot;Partitioning.h&quot;
55  #include &quot;RunStyles.h&quot;
56  #include &quot;ContractionState.h&quot;
57  #include &quot;CellBuffer.h&quot;
58  #include &quot;CallTip.h&quot;
59  #include &quot;KeyMap.h&quot;
60  #include &quot;Indicator.h&quot;
61  #include &quot;LineMarker.h&quot;
62  #include &quot;Style.h&quot;
63  #include &quot;ViewStyle.h&quot;
64  #include &quot;CharClassify.h&quot;
65  #include &quot;Decoration.h&quot;
66  #include &quot;CaseFolder.h&quot;
67  #include &quot;Document.h&quot;
68  #include &quot;CaseConvert.h&quot;
69  #include &quot;UniConversion.h&quot;
70  #include &quot;Selection.h&quot;
71  #include &quot;PositionCache.h&quot;
72  #include &quot;EditModel.h&quot;
73  #include &quot;MarginView.h&quot;
74  #include &quot;EditView.h&quot;
75  #include &quot;Editor.h&quot;
76  #include &quot;ElapsedPeriod.h&quot;
77  #include &quot;AutoComplete.h&quot;
78  #include &quot;ScintillaBase.h&quot;
79  #include &quot;WinTypes.h&quot;
80  #include &quot;PlatWin.h&quot;
81  #include &quot;HanjaDic.h&quot;
82  #include &quot;ScintillaWin.h&quot;
83  #include &quot;BoostRegexSearch.h&quot;
84  #ifndef SPI_GETWHEELSCROLLLINES
85  #define SPI_GETWHEELSCROLLLINES   104
86  #endif
87  #ifndef WM_UNICHAR
88  #define WM_UNICHAR                      0x0109
89  #endif
90  #ifndef WM_DPICHANGED
91  #define WM_DPICHANGED 0x02E0
92  #endif
93  #ifndef WM_DPICHANGED_AFTERPARENT
94  #define WM_DPICHANGED_AFTERPARENT 0x02E3
95  #endif
96  #ifndef UNICODE_NOCHAR
97  #define UNICODE_NOCHAR                  0xFFFF
98  #endif
99  #ifndef IS_HIGH_SURROGATE
100  #define IS_HIGH_SURROGATE(x)            ((x) &gt;= SURROGATE_LEAD_FIRST &amp;&amp; (x) &lt;= SURROGATE_LEAD_LAST)
101  #endif
102  #ifndef IS_LOW_SURROGATE
103  #define IS_LOW_SURROGATE(x)             ((x) &gt;= SURROGATE_TRAIL_FIRST &amp;&amp; (x) &lt;= SURROGATE_TRAIL_LAST)
104  #endif
105  #ifndef MK_ALT
106  #define MK_ALT 32
107  #endif
108  namespace {
109  constexpr UINT SC_WIN_IDLE = 5001;
110  constexpr UINT SC_WORK_IDLE = 5002;
111  constexpr int IndicatorInput = static_cast&lt;int&gt;(Scintilla::IndicatorNumbers::Ime);
112  constexpr int IndicatorTarget = IndicatorInput + 1;
113  constexpr int IndicatorConverted = IndicatorInput + 2;
114  constexpr int IndicatorUnknown = IndicatorInput + 3;
115  typedef UINT_PTR (WINAPI *SetCoalescableTimerSig)(HWND hwnd, UINT_PTR nIDEvent,
116  	UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay);
117  }
118  using namespace Scintilla;
119  using namespace Scintilla::Internal;
120  namespace {
121  const TCHAR callClassName[] = TEXT(&quot;CallTip&quot;);
122  void SetWindowID(HWND hWnd, int identifier) noexcept {
123  	::SetWindowLongPtr(hWnd, GWLP_ID, identifier);
124  }
125  Point PointFromLParam(sptr_t lpoint) noexcept {
126  	return Point::FromInts(GET_X_LPARAM(lpoint), GET_Y_LPARAM(lpoint));
127  }
128  bool KeyboardIsKeyDown(int key) noexcept {
129  	return (::GetKeyState(key) &amp; 0x80000000) != 0;
130  }
131  constexpr sptr_t extendedKeyboard = 1 &lt;&lt; 24;
132  constexpr bool KeyboardIsNumericKeypadFunction(uptr_t wParam, sptr_t lParam) {
133  	if ((lParam &amp; extendedKeyboard) != 0) {
134  		return false;
135  	}
136  	switch (wParam) {
137  	case VK_INSERT:	
138  	case VK_END:	
139  	case VK_DOWN:	
140  	case VK_NEXT:	
141  	case VK_LEFT:	
142  	case VK_CLEAR:	
143  	case VK_RIGHT:	
144  	case VK_HOME:	
145  	case VK_UP:		
146  	case VK_PRIOR:	
147  		return true;
148  	default:
149  		return false;
150  	}
151  }
152  class FormatEnumerator final : public IEnumFORMATETC {
153  public:
154  	ULONG ref;
155  	ULONG pos;
156  	std::vector&lt;CLIPFORMAT&gt; formats;
157  	FormatEnumerator(ULONG pos_, const CLIPFORMAT formats_[], size_t formatsLen_);
158  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
159  	STDMETHODIMP_(ULONG)AddRef() override;
160  	STDMETHODIMP_(ULONG)Release() override;
161  	STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched) override;
162  	STDMETHODIMP Skip(ULONG celt) override;
163  	STDMETHODIMP Reset() override;
164  	STDMETHODIMP Clone(IEnumFORMATETC **ppenum) override;
165  };
166  class DropSource final : public IDropSource {
167  public:
168  	ScintillaWin *sci = nullptr;
169  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
170  	STDMETHODIMP_(ULONG)AddRef() override;
171  	STDMETHODIMP_(ULONG)Release() override;
172  	STDMETHODIMP QueryContinueDrag(BOOL fEsc, DWORD grfKeyState) override;
173  	STDMETHODIMP GiveFeedback(DWORD) override;
174  };
175  class DataObject final : public IDataObject {
176  public:
177  	ScintillaWin *sci = nullptr;
178  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
179  	STDMETHODIMP_(ULONG)AddRef() override;
180  	STDMETHODIMP_(ULONG)Release() override;
181  	STDMETHODIMP GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) override;
182  	STDMETHODIMP GetDataHere(FORMATETC *, STGMEDIUM *) override;
183  	STDMETHODIMP QueryGetData(FORMATETC *pFE) override;
184  	STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *, FORMATETC *pFEOut)  override;
185  	STDMETHODIMP SetData(FORMATETC *, STGMEDIUM *, BOOL) override;
186  	STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum) override;
187  	STDMETHODIMP DAdvise(FORMATETC *, DWORD, IAdviseSink *, PDWORD) override;
188  	STDMETHODIMP DUnadvise(DWORD) override;
189  	STDMETHODIMP EnumDAdvise(IEnumSTATDATA **) override;
190  };
191  class DropTarget final : public IDropTarget {
192  public:
193  	ScintillaWin *sci = nullptr;
194  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv) override;
195  	STDMETHODIMP_(ULONG)AddRef() override;
196  	STDMETHODIMP_(ULONG)Release() override;
197  	STDMETHODIMP DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
198  	STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
199  	STDMETHODIMP DragLeave() override;
200  	STDMETHODIMP Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) override;
201  };
202  class IMContext {
203  	HWND hwnd;
204  public:
205  	HIMC hIMC;
206  	IMContext(HWND hwnd_) noexcept :
207  		hwnd(hwnd_), hIMC(::ImmGetContext(hwnd_)) {
208  	}
209  	IMContext(const IMContext &amp;) = delete;
210  	IMContext(IMContext &amp;&amp;) = delete;
211  	IMContext &amp;operator=(const IMContext &amp;) = delete;
212  	IMContext &amp;operator=(IMContext &amp;&amp;) = delete;
213  	~IMContext() {
214  		if (hIMC)
215  			::ImmReleaseContext(hwnd, hIMC);
216  	}
217  	unsigned int GetImeCaretPos() const noexcept {
218  		return ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, nullptr, 0);
219  	}
220  	std::vector&lt;BYTE&gt; GetImeAttributes() {
221  		const int attrLen = ::ImmGetCompositionStringW(hIMC, GCS_COMPATTR, nullptr, 0);
222  		std::vector&lt;BYTE&gt; attr(attrLen, 0);
223  		::ImmGetCompositionStringW(hIMC, GCS_COMPATTR, &amp;attr[0], static_cast&lt;DWORD&gt;(attr.size()));
224  		return attr;
225  	}
226  	std::wstring GetCompositionString(DWORD dwIndex) {
227  		const LONG byteLen = ::ImmGetCompositionStringW(hIMC, dwIndex, nullptr, 0);
228  		std::wstring wcs(byteLen / 2, 0);
229  		::ImmGetCompositionStringW(hIMC, dwIndex, &amp;wcs[0], byteLen);
230  		return wcs;
231  	}
232  };
233  class GlobalMemory;
234  class ReverseArrowCursor {
235  	UINT dpi = USER_DEFAULT_SCREEN_DPI;
236  	HCURSOR cursor {};
237  public:
238  	ReverseArrowCursor() noexcept {}
239  	ReverseArrowCursor(const ReverseArrowCursor &amp;) = delete;
240  	ReverseArrowCursor(ReverseArrowCursor &amp;&amp;) = delete;
241  	ReverseArrowCursor &amp;operator=(const ReverseArrowCursor &amp;) = delete;
242  	ReverseArrowCursor &amp;operator=(ReverseArrowCursor &amp;&amp;) = delete;
243  	~ReverseArrowCursor() {
244  		if (cursor) {
245  			::DestroyCursor(cursor);
246  		}
247  	}
248  	HCURSOR Load(UINT dpi_) noexcept {
249  		if (cursor)	 {
250  			if (dpi == dpi_) {
251  				return cursor;
252  			}
253  			::DestroyCursor(cursor);
254  		}
255  		dpi = dpi_;
256  		cursor = LoadReverseArrowCursor(dpi_);
257  		return cursor ? cursor : ::LoadCursor({}, IDC_ARROW);
258  	}
259  };
260  struct HorizontalScrollRange {
261  	int pageWidth;
262  	int documentWidth;
263  };
264  }
265  namespace Scintilla::Internal {
266  class ScintillaWin :
267  	public ScintillaBase {
268  	bool lastKeyDownConsumed;
269  	wchar_t lastHighSurrogateChar;
270  	bool capturedMouse;
271  	bool trackedMouseLeave;
272  	SetCoalescableTimerSig SetCoalescableTimerFn;
273  	unsigned int linesPerScroll;	
274  	unsigned int charsPerScroll;	
275  	MouseWheelDelta verticalWheelDelta;
276  	MouseWheelDelta horizontalWheelDelta;
277  	UINT dpi = USER_DEFAULT_SCREEN_DPI;
278  	ReverseArrowCursor reverseArrowCursor;
279  	PRectangle rectangleClient;
280  	HRGN hRgnUpdate;
281  	bool hasOKText;
282  	CLIPFORMAT cfColumnSelect;
283  	CLIPFORMAT cfBorlandIDEBlockType;
284  	CLIPFORMAT cfLineSelect;
285  	CLIPFORMAT cfVSLineTag;
286  	HRESULT hrOle;
287  	DropSource ds;
288  	DataObject dob;
289  	DropTarget dt;
290  	static HINSTANCE hInstance;
291  	static ATOM scintillaClassAtom;
292  	static ATOM callClassAtom;
293  	int deviceScaleFactor = 1;
294  #if defined(USE_D2D)
295  	ID2D1RenderTarget *pRenderTarget;
296  	bool renderTargetValid;
297  	HMONITOR hCurrentMonitor;
298  	std::shared_ptr&lt;RenderingParams&gt; renderingParams;
299  #endif
300  	explicit ScintillaWin(HWND hwnd);
301  	ScintillaWin(const ScintillaWin &amp;) = delete;
302  	ScintillaWin(ScintillaWin &amp;&amp;) = delete;
303  	ScintillaWin &amp;operator=(const ScintillaWin &amp;) = delete;
304  	ScintillaWin &amp;operator=(ScintillaWin &amp;&amp;) = delete;
305  	void Finalise() override;
306  #if defined(USE_D2D)
307  	bool UpdateRenderingParams(bool force) noexcept;
308  	void EnsureRenderTarget(HDC hdc);
309  #endif
310  	void DropRenderTarget() noexcept;
311  	HWND MainHWND() const noexcept;
312  	static sptr_t DirectFunction(
313  		    sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam);
314  	static sptr_t DirectStatusFunction(
315  		    sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam, int *pStatus);
316  	static LRESULT PASCAL SWndProc(
317  		    HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
318  	static LRESULT PASCAL CTWndProc(
319  		    HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
320  	enum : UINT_PTR { invalidTimerID, standardTimerID, idleTimerID, fineTimerStart };
321  	void DisplayCursor(Window::Cursor c) override;
322  	bool DragThreshold(Point ptStart, Point ptNow) override;
323  	void StartDrag() override;
324  	static KeyMod MouseModifiers(uptr_t wParam) noexcept;
325  	Sci::Position TargetAsUTF8(char *text) const;
326  	Sci::Position EncodedFromUTF8(const char *utf8, char *encoded) const;
327  	void SetRenderingParams(Surface *psurf) const;
328  	bool PaintDC(HDC hdc);
329  	sptr_t WndPaint();
330  	void ImeStartComposition();
331  	void ImeEndComposition();
332  	LRESULT ImeOnReconvert(LPARAM lParam);
333  	LRESULT ImeOnDocumentFeed(LPARAM lParam) const;
334  	sptr_t HandleCompositionWindowed(uptr_t wParam, sptr_t lParam);
335  	sptr_t HandleCompositionInline(uptr_t wParam, sptr_t lParam);
336  	static bool KoreanIME() noexcept;
337  	void MoveImeCarets(Sci::Position offset) noexcept;
338  	void DrawImeIndicator(int indicator, Sci::Position len);
339  	void SetCandidateWindowPos();
340  	void SelectionToHangul();
341  	void EscapeHanja();
342  	void ToggleHanja();
343  	void AddWString(std::wstring_view wsv, CharacterSource charSource);
344  	UINT CodePageOfDocument() const noexcept;
345  	bool ValidCodePage(int codePage) const override;
346  	std::string UTF8FromEncoded(std::string_view encoded) const override;
347  	std::string EncodedFromUTF8(std::string_view utf8) const override;
348  	std::string EncodeWString(std::wstring_view wsv);
349  	sptr_t DefWndProc(Message iMessage, uptr_t wParam, sptr_t lParam) override;
350  	void IdleWork() override;
351  	void QueueIdleWork(WorkItems items, Sci::Position upTo) override;
352  	bool SetIdle(bool on) override;
353  	UINT_PTR timers[static_cast&lt;int&gt;(TickReason::dwell)+1] {};
354  	bool FineTickerRunning(TickReason reason) override;
355  	void FineTickerStart(TickReason reason, int millis, int tolerance) override;
356  	void FineTickerCancel(TickReason reason) override;
357  	void SetMouseCapture(bool on) override;
358  	bool HaveMouseCapture() override;
359  	void SetTrackMouseLeaveEvent(bool on) noexcept;
360  	void UpdateBaseElements() override;
361  	bool PaintContains(PRectangle rc) override;
362  	void ScrollText(Sci::Line linesToMove) override;
363  	void NotifyCaretMove() override;
364  	void UpdateSystemCaret() override;
365  	void SetVerticalScrollPos() override;
366  	void SetHorizontalScrollPos() override;
367  	void HorizontalScrollToClamped(int xPos);
368  	HorizontalScrollRange GetHorizontalScrollRange() const;
369  	bool ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) override;
370  	void NotifyChange() override;
371  	void NotifyFocus(bool focus) override;
372  	void SetCtrlID(int identifier) override;
373  	int GetCtrlID() override;
374  	void NotifyParent(NotificationData scn) override;
375  	void NotifyDoubleClick(Point pt, KeyMod modifiers) override;
376  	std::unique_ptr&lt;CaseFolder&gt; CaseFolderForEncoding() override;
377  	std::string CaseMapString(const std::string &amp;s, CaseMapping caseMapping) override;
378  	void Copy() override;
379  	bool CanPaste() override;
380  	void Paste() override;
381  	void CreateCallTipWindow(PRectangle rc) override;
382  	void AddToPopUp(const char *label, int cmd = 0, bool enabled = true) override;
383  	void ClaimSelection() override;
384  	void GetIntelliMouseParameters() noexcept;
385  	void CopyToGlobal(GlobalMemory &amp;gmUnicode, const SelectionText &amp;selectedText);
386  	void CopyToClipboard(const SelectionText &amp;selectedText) override;
387  	void ScrollMessage(WPARAM wParam);
388  	void HorizontalScrollMessage(WPARAM wParam);
389  	void FullPaint();
390  	void FullPaintDC(HDC hdc);
391  	bool IsCompatibleDC(HDC hOtherDC) noexcept;
392  	DWORD EffectFromState(DWORD grfKeyState) const noexcept;
393  	bool IsVisible() const noexcept;
394  	int SetScrollInfo(int nBar, LPCSCROLLINFO lpsi, BOOL bRedraw) noexcept;
395  	bool GetScrollInfo(int nBar, LPSCROLLINFO lpsi) noexcept;
396  	bool ChangeScrollRange(int nBar, int nMin, int nMax, UINT nPage) noexcept;
397  	void ChangeScrollPos(int barType, Sci::Position pos);
398  	sptr_t GetTextLength();
399  	sptr_t GetText(uptr_t wParam, sptr_t lParam);
400  	Window::Cursor ContextCursor(Point pt);
401  	sptr_t ShowContextMenu(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
402  	PRectangle GetClientRectangle() const override;
403  	void SizeWindow();
<span onclick='openModal()' class='match'>404  	sptr_t MouseMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
405  	sptr_t KeyMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
</span>406  	sptr_t FocusMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
407  	sptr_t IMEMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
408  	sptr_t EditMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
409  	sptr_t IdleMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
410  	sptr_t SciMessage(Message iMessage, uptr_t wParam, sptr_t lParam);
411  public:
412  	~ScintillaWin() override;
413  	sptr_t WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) override;
414  	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);
415  	STDMETHODIMP_(ULONG)AddRef();
416  	STDMETHODIMP_(ULONG)Release();
417  	STDMETHODIMP DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
418  	                       POINTL pt, PDWORD pdwEffect);
419  	STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect);
420  	STDMETHODIMP DragLeave();
421  	STDMETHODIMP Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
422  	                  POINTL pt, PDWORD pdwEffect);
423  	STDMETHODIMP GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM);
424  	static void Prepare() noexcept;
425  	static bool Register(HINSTANCE hInstance_) noexcept;
426  	static bool Unregister() noexcept;
427  	bool DragIsRectangularOK(CLIPFORMAT fmt) const noexcept {
428  		return drag.rectangular &amp;&amp; (fmt == cfColumnSelect);
429  	}
430  private:
431  	bool HasCaretSizeChanged() const noexcept;
432  	BOOL CreateSystemCaret();
433  	BOOL DestroySystemCaret() noexcept;
434  	HBITMAP sysCaretBitmap;
435  	int sysCaretWidth;
436  	int sysCaretHeight;
437  	bool styleIdleInQueue;
438  };
439  HINSTANCE ScintillaWin::hInstance {};
440  ATOM ScintillaWin::scintillaClassAtom = 0;
441  ATOM ScintillaWin::callClassAtom = 0;
442  ScintillaWin::ScintillaWin(HWND hwnd) {
443  	lastKeyDownConsumed = false;
444  	lastHighSurrogateChar = 0;
445  	capturedMouse = false;
446  	trackedMouseLeave = false;
447  	SetCoalescableTimerFn = nullptr;
448  	linesPerScroll = 0;
449  	charsPerScroll = 0;
450  	dpi = DpiForWindow(hwnd);
451  	hRgnUpdate = {};
452  	hasOKText = false;
453  	cfColumnSelect = static_cast&lt;CLIPFORMAT&gt;(
454  		::RegisterClipboardFormat(TEXT(&quot;MSDEVColumnSelect&quot;)));
455  	cfBorlandIDEBlockType = static_cast&lt;CLIPFORMAT&gt;(
456  		::RegisterClipboardFormat(TEXT(&quot;Borland IDE Block Type&quot;)));
457  	cfLineSelect = static_cast&lt;CLIPFORMAT&gt;(
458  		::RegisterClipboardFormat(TEXT(&quot;MSDEVLineSelect&quot;)));
459  	cfVSLineTag = static_cast&lt;CLIPFORMAT&gt;(
460  		::RegisterClipboardFormat(TEXT(&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag&quot;)));
461  	hrOle = E_FAIL;
462  	wMain = hwnd;
463  	dob.sci = this;
464  	ds.sci = this;
465  	dt.sci = this;
466  	sysCaretBitmap = {};
467  	sysCaretWidth = 0;
468  	sysCaretHeight = 0;
469  	styleIdleInQueue = false;
470  #if defined(USE_D2D)
471  	pRenderTarget = nullptr;
472  	renderTargetValid = true;
473  	hCurrentMonitor = {};
474  #endif
475  	caret.period = ::GetCaretBlinkTime();
476  	if (caret.period &lt; 0)
477  		caret.period = 0;
478  	hrOle = ::OleInitialize(nullptr);
479  	HMODULE user32 = ::GetModuleHandleW(L&quot;user32.dll&quot;);
480  	SetCoalescableTimerFn = DLLFunction&lt;SetCoalescableTimerSig&gt;(user32, &quot;SetCoalescableTimer&quot;);
481  	vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, ColourRGBA(0, 0, 0xff));
482  	vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, ColourRGBA(0, 0, 0xff));
483  	vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, ColourRGBA(0, 0, 0xff));
484  	vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, ColourRGBA(0, 0, 0xff));
485  }
486  ScintillaWin::~ScintillaWin() {
487  	if (sysCaretBitmap) {
488  		::DeleteObject(sysCaretBitmap);
489  		sysCaretBitmap = {};
490  	}
491  }
492  void ScintillaWin::Finalise() {
493  	ScintillaBase::Finalise();
494  	for (TickReason tr = TickReason::caret; tr &lt;= TickReason::dwell;
495  		tr = static_cast&lt;TickReason&gt;(static_cast&lt;int&gt;(tr) + 1)) {
496  		FineTickerCancel(tr);
497  	}
498  	SetIdle(false);
499  	DropRenderTarget();
500  	::RevokeDragDrop(MainHWND());
501  	if (SUCCEEDED(hrOle)) {
502  		::OleUninitialize();
503  	}
504  }
505  #if defined(USE_D2D)
506  bool ScintillaWin::UpdateRenderingParams(bool force) noexcept {
507  	if (!renderingParams) {
508  		try {
509  			renderingParams = std::make_shared&lt;RenderingParams&gt;();
510  		} catch (const std::bad_alloc &amp;) {
511  			return false;
512  		}
513  	}
514  	const HWND hRootWnd = ::GetAncestor(MainHWND(), GA_ROOT);
515  	const HMONITOR monitor = Internal::MonitorFromWindowHandleScaling(hRootWnd);
516  	if (!force &amp;&amp; monitor == hCurrentMonitor &amp;&amp; renderingParams-&gt;defaultRenderingParams) {
517  		return false;
518  	}
519  	IDWriteRenderingParams *monitorRenderingParams = nullptr;
520  	IDWriteRenderingParams *customClearTypeRenderingParams = nullptr;
521  	const HRESULT hr = pIDWriteFactory-&gt;CreateMonitorRenderingParams(monitor, &amp;monitorRenderingParams);
522  	UINT clearTypeContrast = 0;
523  	if (SUCCEEDED(hr) &amp;&amp; ::SystemParametersInfo(SPI_GETFONTSMOOTHINGCONTRAST, 0, &amp;clearTypeContrast, 0) != 0) {
524  		if (clearTypeContrast &gt;= 1000 &amp;&amp; clearTypeContrast &lt;= 2200) {
525  			const FLOAT gamma = static_cast&lt;FLOAT&gt;(clearTypeContrast) / 1000.0f;
526  			pIDWriteFactory-&gt;CreateCustomRenderingParams(gamma,
527  				monitorRenderingParams-&gt;GetEnhancedContrast(),
528  				monitorRenderingParams-&gt;GetClearTypeLevel(),
529  				monitorRenderingParams-&gt;GetPixelGeometry(),
530  				monitorRenderingParams-&gt;GetRenderingMode(),
531  				&amp;customClearTypeRenderingParams);
532  		}
533  	}
534  	hCurrentMonitor = monitor;
535  	deviceScaleFactor = Internal::GetDeviceScaleFactorWhenGdiScalingActive(hRootWnd);
536  	renderingParams-&gt;defaultRenderingParams.reset(monitorRenderingParams);
537  	renderingParams-&gt;customRenderingParams.reset(customClearTypeRenderingParams);
538  	return true;
539  }
540  namespace {
541  D2D1_SIZE_U GetSizeUFromRect(const RECT &amp;rc, const int scaleFactor) noexcept {
542  	const long width = rc.right - rc.left;
543  	const long height = rc.bottom - rc.top;
544  	const UINT32 scaledWidth = width * scaleFactor;
545  	const UINT32 scaledHeight = height * scaleFactor;
546  	return D2D1::SizeU(scaledWidth, scaledHeight);
547  }
548  }
549  void ScintillaWin::EnsureRenderTarget(HDC hdc) {
550  	if (!renderTargetValid) {
551  		DropRenderTarget();
552  		renderTargetValid = true;
553  	}
554  	if (!pRenderTarget) {
555  		HWND hw = MainHWND();
556  		RECT rc;
557  		::GetClientRect(hw, &amp;rc);
558  		D2D1_RENDER_TARGET_PROPERTIES drtp {};
559  		drtp.type = D2D1_RENDER_TARGET_TYPE_DEFAULT;
560  		drtp.usage = D2D1_RENDER_TARGET_USAGE_NONE;
561  		drtp.minLevel = D2D1_FEATURE_LEVEL_DEFAULT;
562  		if (technology == Technology::DirectWriteDC) {
563  			drtp.dpiX = 96.f;
564  			drtp.dpiY = 96.f;
565  			drtp.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM,
566  				D2D1_ALPHA_MODE_IGNORE);
567  			ID2D1DCRenderTarget *pDCRT = nullptr;
568  			const HRESULT hr = pD2DFactory-&gt;CreateDCRenderTarget(&amp;drtp, &amp;pDCRT);
569  			if (SUCCEEDED(hr)) {
570  				pRenderTarget = pDCRT;
571  			} else {
572  				Platform::DebugPrintf(&quot;Failed CreateDCRenderTarget 0x%lx\n&quot;, hr);
573  				pRenderTarget = nullptr;
574  			}
575  		} else {
576  			drtp.dpiX = 96.f * deviceScaleFactor;
577  			drtp.dpiY = 96.f * deviceScaleFactor;
578  			drtp.pixelFormat = D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
579  				D2D1_ALPHA_MODE_UNKNOWN);
580  			D2D1_HWND_RENDER_TARGET_PROPERTIES dhrtp {};
581  			dhrtp.hwnd = hw;
582  			dhrtp.pixelSize = ::GetSizeUFromRect(rc, deviceScaleFactor);
583  			dhrtp.presentOptions = (technology == Technology::DirectWriteRetain) ?
584  			D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS : D2D1_PRESENT_OPTIONS_NONE;
585  			ID2D1HwndRenderTarget *pHwndRenderTarget = nullptr;
586  			const HRESULT hr = pD2DFactory-&gt;CreateHwndRenderTarget(drtp, dhrtp, &amp;pHwndRenderTarget);
587  			if (SUCCEEDED(hr)) {
588  				pRenderTarget = pHwndRenderTarget;
589  			} else {
590  				Platform::DebugPrintf(&quot;Failed CreateHwndRenderTarget 0x%lx\n&quot;, hr);
591  				pRenderTarget = nullptr;
592  			}
593  		}
594  		DropGraphics();
595  	}
596  	if ((technology == Technology::DirectWriteDC) &amp;&amp; pRenderTarget) {
597  		RECT rcWindow;
598  		::GetClientRect(MainHWND(), &amp;rcWindow);
599  		const HRESULT hr = static_cast&lt;ID2D1DCRenderTarget*&gt;(pRenderTarget)-&gt;BindDC(hdc, &amp;rcWindow);
600  		if (FAILED(hr)) {
601  			Platform::DebugPrintf(&quot;BindDC failed 0x%lx\n&quot;, hr);
602  			DropRenderTarget();
603  		}
604  	}
605  }
606  #endif
607  void ScintillaWin::DropRenderTarget() noexcept {
608  #if defined(USE_D2D)
609  	ReleaseUnknown(pRenderTarget);
610  #endif
611  }
612  HWND ScintillaWin::MainHWND() const noexcept {
613  	return HwndFromWindow(wMain);
614  }
615  void ScintillaWin::DisplayCursor(Window::Cursor c) {
616  	if (cursorMode != CursorShape::Normal) {
617  		c = static_cast&lt;Window::Cursor&gt;(cursorMode);
618  	}
619  	if (c == Window::Cursor::reverseArrow) {
620  		::SetCursor(reverseArrowCursor.Load(dpi));
621  	} else {
622  		wMain.SetCursor(c);
623  	}
624  }
625  bool ScintillaWin::DragThreshold(Point ptStart, Point ptNow) {
626  	const Point ptDifference = ptStart - ptNow;
627  	const XYPOSITION xMove = std::trunc(std::abs(ptDifference.x));
628  	const XYPOSITION yMove = std::trunc(std::abs(ptDifference.y));
629  	return (xMove &gt; SystemMetricsForDpi(SM_CXDRAG, dpi)) ||
630  		(yMove &gt; SystemMetricsForDpi(SM_CYDRAG, dpi));
631  }
632  void ScintillaWin::StartDrag() {
633  	inDragDrop = DragDrop::dragging;
634  	DWORD dwEffect = 0;
635  	dropWentOutside = true;
636  	IDataObject *pDataObject = &amp;dob;
637  	IDropSource *pDropSource = &amp;ds;
638  	const HRESULT hr = ::DoDragDrop(
639  	                 pDataObject,
640  	                 pDropSource,
641  	                 DROPEFFECT_COPY | DROPEFFECT_MOVE, &amp;dwEffect);
642  	if (SUCCEEDED(hr)) {
643  		if ((hr == DRAGDROP_S_DROP) &amp;&amp; (dwEffect == DROPEFFECT_MOVE) &amp;&amp; dropWentOutside) {
644  			ClearSelection();
645  		}
646  	}
647  	inDragDrop = DragDrop::none;
648  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
649  }
650  KeyMod ScintillaWin::MouseModifiers(uptr_t wParam) noexcept {
651  	return ModifierFlags(
652  		(wParam &amp; MK_SHIFT) != 0,
653  		(wParam &amp; MK_CONTROL) != 0,
654  		KeyboardIsKeyDown(VK_MENU));
655  }
656  }
657  namespace {
658  int InputCodePage() noexcept {
659  	HKL inputLocale = ::GetKeyboardLayout(0);
660  	const LANGID inputLang = LOWORD(inputLocale);
661  	char sCodePage[10];
662  	const int res = ::GetLocaleInfoA(MAKELCID(inputLang, SORT_DEFAULT),
663  	  LOCALE_IDEFAULTANSICODEPAGE, sCodePage, sizeof(sCodePage));
664  	if (!res)
665  		return 0;
666  	return atoi(sCodePage);
667  }
668  Keys KeyTranslate(uptr_t keyIn) noexcept {
669  	switch (keyIn) {
670  	case VK_DOWN:		return Keys::Down;
671  		case VK_UP:		return Keys::Up;
672  		case VK_LEFT:		return Keys::Left;
673  		case VK_RIGHT:		return Keys::Right;
674  		case VK_HOME:		return Keys::Home;
675  		case VK_END:		return Keys::End;
676  		case VK_PRIOR:		return Keys::Prior;
677  		case VK_NEXT:		return Keys::Next;
678  		case VK_DELETE:	return Keys::Delete;
679  		case VK_INSERT:		return Keys::Insert;
680  		case VK_ESCAPE:	return Keys::Escape;
681  		case VK_BACK:		return Keys::Back;
682  		case VK_TAB:		return Keys::Tab;
683  		case VK_RETURN:	return Keys::Return;
684  		case VK_ADD:		return Keys::Add;
685  		case VK_SUBTRACT:	return Keys::Subtract;
686  		case VK_DIVIDE:		return Keys::Divide;
687  		case VK_LWIN:		return Keys::Win;
688  		case VK_RWIN:		return Keys::RWin;
689  		case VK_APPS:		return Keys::Menu;
690  		case VK_OEM_2:		return static_cast&lt;Keys&gt;(&#x27;/&#x27;);
691  		case VK_OEM_3:		return static_cast&lt;Keys&gt;(&#x27;`&#x27;);
692  		case VK_OEM_4:		return static_cast&lt;Keys&gt;(&#x27;[&#x27;);
693  		case VK_OEM_5:		return static_cast&lt;Keys&gt;(&#x27;\\&#x27;);
694  		case VK_OEM_6:		return static_cast&lt;Keys&gt;(&#x27;]&#x27;);
695  		default:			return static_cast&lt;Keys&gt;(keyIn);
696  	}
697  }
698  bool BoundsContains(PRectangle rcBounds, HRGN hRgnBounds, PRectangle rcCheck) noexcept {
699  	bool contains = true;
700  	if (!rcCheck.Empty()) {
701  		if (!rcBounds.Contains(rcCheck)) {
702  			contains = false;
703  		} else if (hRgnBounds) {
704  			const RECT rcw = RectFromPRectangle(rcCheck);
705  			HRGN hRgnCheck = ::CreateRectRgnIndirect(&amp;rcw);
706  			if (hRgnCheck) {
707  				HRGN hRgnDifference = ::CreateRectRgn(0, 0, 0, 0);
708  				if (hRgnDifference) {
709  					const int combination = ::CombineRgn(hRgnDifference, hRgnCheck, hRgnBounds, RGN_DIFF);
710  					if (combination != NULLREGION) {
711  						contains = false;
712  					}
713  					::DeleteRgn(hRgnDifference);
714  				}
715  				::DeleteRgn(hRgnCheck);
716  			}
717  		}
718  	}
719  	return contains;
720  }
721  int MultiByteFromWideChar(UINT codePage, std::wstring_view wsv, LPSTR lpMultiByteStr, ptrdiff_t cbMultiByte) noexcept {
722  	return ::WideCharToMultiByte(codePage, 0, wsv.data(), static_cast&lt;int&gt;(wsv.length()), lpMultiByteStr, static_cast&lt;int&gt;(cbMultiByte), nullptr, nullptr);
723  }
724  int MultiByteLenFromWideChar(UINT codePage, std::wstring_view wsv) noexcept {
725  	return MultiByteFromWideChar(codePage, wsv, nullptr, 0);
726  }
727  int WideCharFromMultiByte(UINT codePage, std::string_view sv, LPWSTR lpWideCharStr, ptrdiff_t cchWideChar) noexcept {
728  	return ::MultiByteToWideChar(codePage, 0, sv.data(), static_cast&lt;int&gt;(sv.length()), lpWideCharStr, static_cast&lt;int&gt;(cchWideChar));
729  }
730  int WideCharLenFromMultiByte(UINT codePage, std::string_view sv) noexcept {
731  	return WideCharFromMultiByte(codePage, sv, nullptr, 0);
732  }
733  std::string StringEncode(std::wstring_view wsv, int codePage) {
734  	const int cchMulti = wsv.length() ? MultiByteLenFromWideChar(codePage, wsv) : 0;
735  	std::string sMulti(cchMulti, 0);
736  	if (cchMulti) {
737  		MultiByteFromWideChar(codePage, wsv, sMulti.data(), cchMulti);
738  	}
739  	return sMulti;
740  }
741  std::wstring StringDecode(std::string_view sv, int codePage) {
742  	const int cchWide = sv.length() ? WideCharLenFromMultiByte(codePage, sv) : 0;
743  	std::wstring sWide(cchWide, 0);
744  	if (cchWide) {
745  		WideCharFromMultiByte(codePage, sv, sWide.data(), cchWide);
746  	}
747  	return sWide;
748  }
749  std::wstring StringMapCase(std::wstring_view wsv, DWORD mapFlags) {
750  	const int charsConverted = ::LCMapStringW(LOCALE_SYSTEM_DEFAULT, mapFlags,
751  		wsv.data(), static_cast&lt;int&gt;(wsv.length()), nullptr, 0);
752  	std::wstring wsConverted(charsConverted, 0);
753  	if (charsConverted) {
754  		::LCMapStringW(LOCALE_SYSTEM_DEFAULT, mapFlags,
755  			wsv.data(), static_cast&lt;int&gt;(wsv.length()), wsConverted.data(), charsConverted);
756  	}
757  	return wsConverted;
758  }
759  }
760  Sci::Position ScintillaWin::TargetAsUTF8(char *text) const {
761  	const Sci::Position targetLength = targetRange.Length();
762  	if (IsUnicodeMode()) {
763  		if (text) {
764  			pdoc-&gt;GetCharRange(text, targetRange.start.Position(), targetLength);
765  		}
766  	} else {
767  		const std::string s = RangeText(targetRange.start.Position(), targetRange.end.Position());
768  		const std::wstring characters = StringDecode(s, CodePageOfDocument());
769  		const int utf8Len = MultiByteLenFromWideChar(CpUtf8, characters);
770  		if (text) {
771  			MultiByteFromWideChar(CpUtf8, characters, text, utf8Len);
772  			text[utf8Len] = &#x27;\0&#x27;;
773  		}
774  		return utf8Len;
775  	}
776  	return targetLength;
777  }
778  Sci::Position ScintillaWin::EncodedFromUTF8(const char *utf8, char *encoded) const {
779  	const Sci::Position inputLength = (lengthForEncode &gt;= 0) ? lengthForEncode : strlen(utf8);
780  	if (IsUnicodeMode()) {
781  		if (encoded) {
782  			memcpy(encoded, utf8, inputLength);
783  		}
784  		return inputLength;
785  	} else {
786  		const std::string_view utf8Input(utf8, inputLength);
787  		const int charsLen = WideCharLenFromMultiByte(CpUtf8, utf8Input);
788  		std::wstring characters(charsLen, L&#x27;\0&#x27;);
789  		WideCharFromMultiByte(CpUtf8, utf8Input, &amp;characters[0], charsLen);
790  		const int encodedLen = MultiByteLenFromWideChar(CodePageOfDocument(), characters);
791  		if (encoded) {
792  			MultiByteFromWideChar(CodePageOfDocument(), characters, encoded, encodedLen);
793  			encoded[encodedLen] = &#x27;\0&#x27;;
794  		}
795  		return encodedLen;
796  	}
797  }
798  void ScintillaWin::SetRenderingParams([[maybe_unused]] Surface *psurf) const {
799  #if defined(USE_D2D)
800  	if (psurf) {
801  		ISetRenderingParams *setDrawingParams = dynamic_cast&lt;ISetRenderingParams *&gt;(psurf);
802  		if (setDrawingParams) {
803  			setDrawingParams-&gt;SetRenderingParams(renderingParams);
804  		}
805  	}
806  #endif
807  }
808  bool ScintillaWin::PaintDC(HDC hdc) {
809  	if (technology == Technology::Default) {
810  		AutoSurface surfaceWindow(hdc, this);
811  		if (surfaceWindow) {
812  			Paint(surfaceWindow, rcPaint);
813  			surfaceWindow-&gt;Release();
814  		}
815  	} else {
816  #if defined(USE_D2D)
817  		EnsureRenderTarget(hdc);
818  		if (pRenderTarget) {
819  			AutoSurface surfaceWindow(pRenderTarget, this);
820  			if (surfaceWindow) {
821  				SetRenderingParams(surfaceWindow);
822  				pRenderTarget-&gt;BeginDraw();
823  				Paint(surfaceWindow, rcPaint);
824  				surfaceWindow-&gt;Release();
825  				const HRESULT hr = pRenderTarget-&gt;EndDraw();
826  				if (hr == static_cast&lt;HRESULT&gt;(D2DERR_RECREATE_TARGET)) {
827  					DropRenderTarget();
828  					return false;
829  				}
830  			}
831  		}
832  #endif
833  	}
834  	return true;
835  }
836  sptr_t ScintillaWin::WndPaint() {
837  	const bool assertsPopup = Platform::ShowAssertionPopUps(false);
838  	paintState = PaintState::painting;
839  	PAINTSTRUCT ps = {};
840  	hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
841  	::GetUpdateRgn(MainHWND(), hRgnUpdate, FALSE);
842  	::BeginPaint(MainHWND(), &amp;ps);
843  	rcPaint = PRectangle::FromInts(ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom);
844  	const PRectangle rcClient = GetClientRectangle();
845  	paintingAllText = BoundsContains(rcPaint, hRgnUpdate, rcClient);
846  	if (!PaintDC(ps.hdc)) {
847  		paintState = PaintState::abandoned;
848  	}
849  	if (hRgnUpdate) {
850  		::DeleteRgn(hRgnUpdate);
851  		hRgnUpdate = {};
852  	}
853  	::EndPaint(MainHWND(), &amp;ps);
854  	if (paintState == PaintState::abandoned) {
855  		FullPaint();
856  		::ValidateRect(MainHWND(), nullptr);
857  	}
858  	paintState = PaintState::notPainting;
859  	Platform::ShowAssertionPopUps(assertsPopup);
860  	return 0;
861  }
862  sptr_t ScintillaWin::HandleCompositionWindowed(uptr_t wParam, sptr_t lParam) {
863  	if (lParam &amp; GCS_RESULTSTR) {
864  		IMContext imc(MainHWND());
865  		if (imc.hIMC) {
866  			AddWString(imc.GetCompositionString(GCS_RESULTSTR), CharacterSource::ImeResult);
867  			const Point pos = PointMainCaret();
868  			COMPOSITIONFORM CompForm {};
869  			CompForm.dwStyle = CFS_POINT;
870  			CompForm.ptCurrentPos = POINTFromPoint(pos);
871  			::ImmSetCompositionWindow(imc.hIMC, &amp;CompForm);
872  		}
873  		return 0;
874  	}
875  	return ::DefWindowProc(MainHWND(), WM_IME_COMPOSITION, wParam, lParam);
876  }
877  bool ScintillaWin::KoreanIME() noexcept {
878  	const int codePage = InputCodePage();
879  	return codePage == 949 || codePage == 1361;
880  }
881  void ScintillaWin::MoveImeCarets(Sci::Position offset) noexcept {
882  	for (size_t r=0; r&lt;sel.Count(); r++) {
883  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
884  		sel.Range(r).caret.SetPosition(positionInsert + offset);
885  		sel.Range(r).anchor.SetPosition(positionInsert + offset);
886  	}
887  }
888  void ScintillaWin::DrawImeIndicator(int indicator, Sci::Position len) {
889  	if (indicator &lt; 8 || indicator &gt; IndicatorMax) {
890  		return;
891  	}
892  	pdoc-&gt;DecorationSetCurrentIndicator(indicator);
893  	for (size_t r=0; r&lt;sel.Count(); r++) {
894  		const Sci::Position positionInsert = sel.Range(r).Start().Position();
895  		pdoc-&gt;DecorationFillRange(positionInsert - len, 1, len);
896  	}
897  }
898  void ScintillaWin::SetCandidateWindowPos() {
899  	IMContext imc(MainHWND());
900  	if (imc.hIMC) {
901  		const Point pos = PointMainCaret();
902  		const PRectangle rcClient = GetTextRectangle();
903  		CANDIDATEFORM CandForm{};
904  		CandForm.dwIndex = 0;
905  		CandForm.dwStyle = CFS_EXCLUDE;
906  		CandForm.ptCurrentPos.x = static_cast&lt;int&gt;(pos.x);
907  		CandForm.ptCurrentPos.y = static_cast&lt;int&gt;(pos.y + std::max(4, vs.lineHeight/4));
908  		CandForm.rcArea.top = static_cast&lt;int&gt;(pos.y);
909  		CandForm.rcArea.bottom = static_cast&lt;int&gt;(pos.y + vs.lineHeight);
910  		CandForm.rcArea.left = static_cast&lt;int&gt;(rcClient.left);
911  		CandForm.rcArea.right = static_cast&lt;int&gt;(rcClient.right);
912  		::ImmSetCandidateWindow(imc.hIMC, &amp;CandForm);
913  	}
914  }
915  void ScintillaWin::SelectionToHangul() {
916  	const Sci::Position selStart = sel.RangeMain().Start().Position();
917  	const Sci::Position documentStrLen = sel.RangeMain().Length();
918  	const Sci::Position selEnd = selStart + documentStrLen;
919  	const Sci::Position utf16Len = pdoc-&gt;CountUTF16(selStart, selEnd);
920  	if (utf16Len &gt; 0) {
921  		std::string documentStr(documentStrLen, &#x27;\0&#x27;);
922  		pdoc-&gt;GetCharRange(&amp;documentStr[0], selStart, documentStrLen);
923  		std::wstring uniStr = StringDecode(documentStr, CodePageOfDocument());
924  		const bool converted = HanjaDict::GetHangulOfHanja(uniStr);
925  		if (converted) {
926  			documentStr = StringEncode(uniStr, CodePageOfDocument());
927  			pdoc-&gt;BeginUndoAction();
928  			ClearSelection();
929  			InsertPaste(&amp;documentStr[0], documentStr.size());
930  			pdoc-&gt;EndUndoAction();
931  		}
932  	}
933  }
934  void ScintillaWin::EscapeHanja() {
935  	if (sel.Count() &gt; 1) {
936  		return; 
937  	}
938  	const Sci::Position currentPos = CurrentPosition();
939  	const int oneCharLen = pdoc-&gt;LenChar(currentPos);
940  	if (oneCharLen &lt; 2) {
941  		return; 
942  	}
943  	constexpr size_t safeLength = UTF8MaxBytes + 1;
944  	std::string oneChar(safeLength, &#x27;\0&#x27;);
945  	pdoc-&gt;GetCharRange(&amp;oneChar[0], currentPos, oneCharLen);
946  	std::wstring uniChar = StringDecode(oneChar, CodePageOfDocument());
947  	IMContext imc(MainHWND());
948  	if (imc.hIMC) {
949  		SetCandidateWindowPos();
950  		if (::ImmEscapeW(GetKeyboardLayout(0), imc.hIMC, IME_ESC_HANJA_MODE, &amp;uniChar[0])) {
951  			SetSelection(currentPos, currentPos + oneCharLen);
952  		}
953  	}
954  }
955  void ScintillaWin::ToggleHanja() {
956  	if (sel.Count() &gt; 1) {
957  		return; 
958  	}
959  	if (sel.Empty()) {
960  		EscapeHanja();
961  	} else {
962  		SelectionToHangul();
963  	}
964  }
965  namespace {
966  std::vector&lt;int&gt; MapImeIndicators(std::vector&lt;BYTE&gt; inputStyle) {
967  	std::vector&lt;int&gt; imeIndicator(inputStyle.size(), IndicatorUnknown);
968  	for (size_t i = 0; i &lt; inputStyle.size(); i++) {
969  		switch (static_cast&lt;int&gt;(inputStyle.at(i))) {
970  		case ATTR_INPUT:
971  			imeIndicator[i] = IndicatorInput;
972  			break;
973  		case ATTR_TARGET_NOTCONVERTED:
974  		case ATTR_TARGET_CONVERTED:
975  			imeIndicator[i] = IndicatorTarget;
976  			break;
977  		case ATTR_CONVERTED:
978  			imeIndicator[i] = IndicatorConverted;
979  			break;
980  		default:
981  			imeIndicator[i] = IndicatorUnknown;
982  			break;
983  		}
984  	}
985  	return imeIndicator;
986  }
987  }
988  void ScintillaWin::AddWString(std::wstring_view wsv, CharacterSource charSource) {
989  	if (wsv.empty())
990  		return;
991  	const int codePage = CodePageOfDocument();
992  	for (size_t i = 0; i &lt; wsv.size(); ) {
993  		const size_t ucWidth = UTF16CharLength(wsv[i]);
994  		const std::string docChar = StringEncode(wsv.substr(i, ucWidth), codePage);
995  		InsertCharacter(docChar, charSource);
996  		i += ucWidth;
997  	}
998  }
999  sptr_t ScintillaWin::HandleCompositionInline(uptr_t, sptr_t lParam) {
1000  	IMContext imc(MainHWND());
1001  	if (!imc.hIMC)
1002  		return 0;
1003  	if (pdoc-&gt;IsReadOnly() || SelectionContainsProtected()) {
1004  		::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
1005  		return 0;
1006  	}
1007  	bool initialCompose = false;
1008  	if (pdoc-&gt;TentativeActive()) {
1009  		pdoc-&gt;TentativeUndo();
1010  	} else {
1011  		initialCompose = true;
1012  	}
1013  	view.imeCaretBlockOverride = false;
1014  	if (lParam &amp; GCS_RESULTSTR) {
1015  		AddWString(imc.GetCompositionString(GCS_RESULTSTR), CharacterSource::ImeResult);
1016  	}
1017  	if (lParam &amp; GCS_COMPSTR) {
1018  		const std::wstring wcs = imc.GetCompositionString(GCS_COMPSTR);
1019  		if (wcs.empty()) {
1020  			ShowCaretAtCurrentPosition();
1021  			return 0;
1022  		}
1023  		if (initialCompose) {
1024  			ClearBeforeTentativeStart();
1025  		}
1026  		SetCandidateWindowPos();
1027  		pdoc-&gt;TentativeStart(); 
1028  		std::vector&lt;int&gt; imeIndicator = MapImeIndicators(imc.GetImeAttributes());
1029  		const int codePage = CodePageOfDocument();
1030  		const std::wstring_view wsv = wcs;
1031  		for (size_t i = 0; i &lt; wsv.size(); ) {
1032  			const size_t ucWidth = UTF16CharLength(wsv[i]);
1033  			const std::string docChar = StringEncode(wsv.substr(i, ucWidth), codePage);
1034  			InsertCharacter(docChar, CharacterSource::TentativeInput);
1035  			DrawImeIndicator(imeIndicator[i], docChar.size());
1036  			i += ucWidth;
1037  		}
1038  		const bool onlyTarget = std::all_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
1039  			return i == IndicatorTarget;
1040  		});
1041  		if (!onlyTarget) {
1042  			Sci::Position imeEndToImeCaretU16 = -static_cast&lt;Sci::Position&gt;(wcs.size());
1043  			if (!(lParam &amp; CS_NOMOVECARET) &amp;&amp; (lParam &amp; GCS_CURSORPOS)) {
1044  				imeEndToImeCaretU16 += imc.GetImeCaretPos();
1045  			}
1046  			if (imeEndToImeCaretU16 != 0) {
1047  				const Sci::Position currentPos = CurrentPosition();
1048  				const Sci::Position imeCaretPosDoc = pdoc-&gt;GetRelativePositionUTF16(currentPos, imeEndToImeCaretU16);
1049  				MoveImeCarets(-currentPos + imeCaretPosDoc);
1050  				if (std::find(imeIndicator.begin(), imeIndicator.end(), IndicatorTarget) != imeIndicator.end()) {
1051  					SetCandidateWindowPos();
1052  				}
1053  			}
1054  		}
1055  		if (KoreanIME()) {
1056  			view.imeCaretBlockOverride = true;
1057  		}
1058  	}
1059  	EnsureCaretVisible();
1060  	ShowCaretAtCurrentPosition();
1061  	return 0;
1062  }
1063  namespace {
1064  Message SciMessageFromEM(unsigned int iMessage) noexcept {
1065  	switch (iMessage) {
1066  	case EM_CANPASTE: return Message::CanPaste;
1067  	case EM_CANUNDO: return Message::CanUndo;
1068  	case EM_EMPTYUNDOBUFFER: return Message::EmptyUndoBuffer;
1069  	case EM_FINDTEXTEX: return Message::FindText;
1070  	case EM_FORMATRANGE: return Message::FormatRange;
1071  	case EM_GETFIRSTVISIBLELINE: return Message::GetFirstVisibleLine;
1072  	case EM_GETLINECOUNT: return Message::GetLineCount;
1073  	case EM_GETSELTEXT: return Message::GetSelText;
1074  	case EM_GETTEXTRANGE: return Message::GetTextRange;
1075  	case EM_HIDESELECTION: return Message::HideSelection;
1076  	case EM_LINEINDEX: return Message::PositionFromLine;
1077  	case EM_LINESCROLL: return Message::LineScroll;
1078  	case EM_REPLACESEL: return Message::ReplaceSel;
1079  	case EM_SCROLLCARET: return Message::ScrollCaret;
1080  	case EM_SETREADONLY: return Message::SetReadOnly;
1081  	case WM_CLEAR: return Message::Clear;
1082  	case WM_COPY: return Message::Copy;
1083  	case WM_CUT: return Message::Cut;
1084  	case WM_SETTEXT: return Message::SetText;
1085  	case WM_PASTE: return Message::Paste;
1086  	case WM_UNDO: return Message::Undo;
1087  	}
1088  	return static_cast&lt;Message&gt;(iMessage);
1089  }
1090  }
1091  namespace Scintilla::Internal {
1092  UINT CodePageFromCharSet(CharacterSet characterSet, UINT documentCodePage) noexcept {
1093  	if (documentCodePage == CpUtf8) {
1094  		return CpUtf8;
1095  	}
1096  	switch (characterSet) {
1097  	case CharacterSet::Ansi: return 1252;
1098  	case CharacterSet::Default: return documentCodePage;
1099  	case CharacterSet::Baltic: return 1257;
1100  	case CharacterSet::ChineseBig5: return 950;
1101  	case CharacterSet::EastEurope: return 1250;
1102  	case CharacterSet::GB2312: return 936;
1103  	case CharacterSet::Greek: return 1253;
1104  	case CharacterSet::Hangul: return 949;
1105  	case CharacterSet::Mac: return 10000;
1106  	case CharacterSet::Oem: return 437;
1107  	case CharacterSet::Russian: return 1251;
1108  	case CharacterSet::ShiftJis: return 932;
1109  	case CharacterSet::Turkish: return 1254;
1110  	case CharacterSet::Johab: return 1361;
1111  	case CharacterSet::Hebrew: return 1255;
1112  	case CharacterSet::Arabic: return 1256;
1113  	case CharacterSet::Vietnamese: return 1258;
1114  	case CharacterSet::Thai: return 874;
1115  	case CharacterSet::Iso8859_15: return 28605;
1116  	case CharacterSet::Cyrillic: return documentCodePage;
1117  	case CharacterSet::Symbol: return documentCodePage;
1118  	default: break;
1119  	}
1120  	return documentCodePage;
1121  }
1122  }
1123  UINT ScintillaWin::CodePageOfDocument() const noexcept {
1124  	return CodePageFromCharSet(vs.styles[StyleDefault].characterSet, pdoc-&gt;dbcsCodePage);
1125  }
1126  std::string ScintillaWin::EncodeWString(std::wstring_view wsv) {
1127  	if (IsUnicodeMode()) {
1128  		const size_t len = UTF8Length(wsv);
1129  		std::string putf(len, 0);
1130  		UTF8FromUTF16(wsv, putf.data(), len);
1131  		return putf;
1132  	} else {
1133  		return StringEncode(wsv, CodePageOfDocument());
1134  	}
1135  }
1136  sptr_t ScintillaWin::GetTextLength() {
1137  	if (pdoc-&gt;dbcsCodePage == 0 || pdoc-&gt;dbcsCodePage == CpUtf8) {
1138  		return pdoc-&gt;CountUTF16(0, pdoc-&gt;Length());
1139  	} else {
1140  		const UINT cpSrc = CodePageOfDocument();
1141  		const Sci::Line lines = pdoc-&gt;LinesTotal();
1142  		Sci::Position codeUnits = 0;
1143  		std::string lineBytes;
1144  		for (Sci::Line line = 0; line &lt; lines; line++) {
1145  			const Sci::Position start = pdoc-&gt;LineStart(line);
1146  			const Sci::Position width = pdoc-&gt;LineStart(line+1) - start;
1147  			lineBytes.resize(width);
1148  			pdoc-&gt;GetCharRange(lineBytes.data(), start, width);
1149  			codeUnits += WideCharLenFromMultiByte(cpSrc, lineBytes);
1150  		}
1151  		return codeUnits;
1152  	}
1153  }
1154  sptr_t ScintillaWin::GetText(uptr_t wParam, sptr_t lParam) {
1155  	if (lParam == 0) {
1156  		return GetTextLength();
1157  	}
1158  	if (wParam == 0) {
1159  		return 0;
1160  	}
1161  	wchar_t *ptr = static_cast&lt;wchar_t *&gt;(PtrFromSPtr(lParam));
1162  	if (pdoc-&gt;Length() == 0) {
1163  		*ptr = L&#x27;\0&#x27;;
1164  		return 0;
1165  	}
1166  	const Sci::Position lengthWanted = wParam - 1;
1167  	if (IsUnicodeMode()) {
1168  		Sci::Position sizeRequestedRange = pdoc-&gt;GetRelativePositionUTF16(0, lengthWanted);
1169  		if (sizeRequestedRange &lt; 0) {
1170  			sizeRequestedRange = pdoc-&gt;Length();
1171  		}
1172  		std::string docBytes(sizeRequestedRange, &#x27;\0&#x27;);
1173  		pdoc-&gt;GetCharRange(&amp;docBytes[0], 0, sizeRequestedRange);
1174  		const size_t uLen = UTF16FromUTF8(docBytes, ptr, lengthWanted);
1175  		ptr[uLen] = L&#x27;\0&#x27;;
1176  		return uLen;
1177  	} else {
1178  		const UINT cpSrc = CodePageOfDocument();
1179  		const Sci::Line lines = pdoc-&gt;LinesTotal();
1180  		Sci::Position codeUnits = 0;
1181  		std::string lineBytes;
1182  		std::wstring lineAsUTF16;
1183  		for (Sci::Line line = 0; line &lt; lines &amp;&amp; codeUnits &lt; lengthWanted; line++) {
1184  			const Sci::Position start = pdoc-&gt;LineStart(line);
1185  			const Sci::Position width = pdoc-&gt;LineStart(line + 1) - start;
1186  			lineBytes.resize(width);
1187  			pdoc-&gt;GetCharRange(lineBytes.data(), start, width);
1188  			const Sci::Position codeUnitsLine = WideCharLenFromMultiByte(cpSrc, lineBytes);
1189  			lineAsUTF16.resize(codeUnitsLine);
1190  			const Sci::Position lengthLeft = lengthWanted - codeUnits;
1191  			WideCharFromMultiByte(cpSrc, lineBytes, lineAsUTF16.data(), lineAsUTF16.length());
1192  			const Sci::Position lengthToCopy = std::min(lengthLeft, codeUnitsLine);
1193  			lineAsUTF16.copy(ptr + codeUnits, lengthToCopy);
1194  			codeUnits += lengthToCopy;
1195  		}
1196  		ptr[codeUnits] = L&#x27;\0&#x27;;
1197  		return codeUnits;
1198  	}
1199  }
1200  Window::Cursor ScintillaWin::ContextCursor(Point pt) {
1201  	if (inDragDrop == DragDrop::dragging) {
1202  		return Window::Cursor::up;
1203  	} else {
1204  		if (PointInSelMargin(pt)) {
1205  			return GetMarginCursor(pt);
1206  		} else if (!SelectionEmpty() &amp;&amp; PointInSelection(pt)) {
1207  			return Window::Cursor::arrow;
1208  		} else if (PointIsHotspot(pt)) {
1209  			return Window::Cursor::hand;
1210  		} else if (hoverIndicatorPos != Sci::invalidPosition) {
1211  			const Sci::Position pos = PositionFromLocation(pt, true, true);
1212  			if (pos != Sci::invalidPosition) {
1213  				return Window::Cursor::hand;
1214  			}
1215  		}
1216  	}
1217  	return Window::Cursor::text;
1218  }
1219  sptr_t ScintillaWin::ShowContextMenu(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1220  	Point pt = PointFromLParam(lParam);
1221  	POINT rpt = POINTFromPoint(pt);
1222  	::ScreenToClient(MainHWND(), &amp;rpt);
1223  	const Point ptClient = PointFromPOINT(rpt);
1224  	if (ShouldDisplayPopup(ptClient)) {
1225  		if ((pt.x == -1) &amp;&amp; (pt.y == -1)) {
1226  			pt = PointMainCaret();
1227  			POINT spt = POINTFromPoint(pt);
1228  			::ClientToScreen(MainHWND(), &amp;spt);
1229  			pt = PointFromPOINT(spt);
1230  		}
1231  		ContextMenu(pt);
1232  		return 0;
1233  	}
1234  	return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1235  }
1236  PRectangle ScintillaWin::GetClientRectangle() const {
1237  	return rectangleClient;
1238  }
1239  void ScintillaWin::SizeWindow() {
1240  #if defined(USE_D2D)
1241  	if (paintState == PaintState::notPainting) {
1242  		DropRenderTarget();
1243  	} else {
1244  		renderTargetValid = false;
1245  	}
1246  #endif
1247  	rectangleClient = wMain.GetClientPosition();
1248  	ChangeSize();
1249  }
1250  sptr_t ScintillaWin::MouseMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1251  	switch (iMessage) {
1252  	case WM_LBUTTONDOWN: {
1253  			IMContext imc(MainHWND());
1254  			if (imc.hIMC) {
1255  				::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
1256  			}
1257  			::SetFocus(MainHWND());
1258  			ButtonDownWithModifiers(PointFromLParam(lParam), ::GetMessageTime(),
1259  						MouseModifiers(wParam));
1260  		}
1261  		break;
1262  	case WM_LBUTTONUP:
1263  		ButtonUpWithModifiers(PointFromLParam(lParam),
1264  				      ::GetMessageTime(), MouseModifiers(wParam));
1265  		break;
1266  	case WM_RBUTTONDOWN: {
1267  			::SetFocus(MainHWND());
1268  			const Point pt = PointFromLParam(lParam);
1269  			if (!PointInSelection(pt)) {
1270  				CancelModes();
1271  				SetEmptySelection(PositionFromLocation(PointFromLParam(lParam)));
1272  			}
1273  			RightButtonDownWithModifiers(pt, ::GetMessageTime(), MouseModifiers(wParam));
1274  		}
1275  		break;
1276  	case WM_MBUTTONDOWN:
1277  		::SetFocus(MainHWND());
1278  		break;
1279  	case WM_MOUSEMOVE: {
1280  			const Point pt = PointFromLParam(lParam);
1281  			if (ptMouseLast != pt) {
1282  				SetTrackMouseLeaveEvent(true);
1283  				ButtonMoveWithModifiers(pt, ::GetMessageTime(), MouseModifiers(wParam));
1284  			}
1285  		}
1286  		break;
1287  	case WM_MOUSELEAVE:
1288  		SetTrackMouseLeaveEvent(false);
1289  		MouseLeave();
1290  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1291  	case WM_MOUSEWHEEL:
1292  	case WM_MOUSEHWHEEL:
1293  		if (!mouseWheelCaptures) {
1294  			RECT rc;
1295  			GetWindowRect(MainHWND(), &amp;rc);
1296  			const POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
1297  			if (!PtInRect(&amp;rc, pt))
1298  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1299  		}
1300  		if (ac.Active()) {
1301  			HWND hWnd = HwndFromWindow(*(ac.lb));
1302  			::SendMessage(hWnd, iMessage, wParam, lParam);
1303  			break;
1304  		}
1305  		if (iMessage == WM_MOUSEHWHEEL || (wParam &amp; MK_SHIFT)) {
1306  			if (vs.wrap.state != Wrap::None || charsPerScroll == 0) {
1307  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1308  			}
1309  			MouseWheelDelta &amp;wheelDelta = (iMessage == WM_MOUSEHWHEEL) ? horizontalWheelDelta : verticalWheelDelta;
1310  			if (wheelDelta.Accumulate(wParam)) {
1311  				const int charsToScroll = charsPerScroll * wheelDelta.Actions();
1312  				const int widthToScroll = static_cast&lt;int&gt;(std::lround(charsToScroll * vs.aveCharWidth));
1313  				HorizontalScrollToClamped(xOffset + widthToScroll);
1314  			}
1315  			return 0;
1316  		}
1317  		if (linesPerScroll != 0 &amp;&amp; verticalWheelDelta.Accumulate(wParam)) {
1318  			Sci::Line linesToScroll = linesPerScroll;
1319  			if (linesPerScroll == WHEEL_PAGESCROLL)
1320  				linesToScroll = LinesOnScreen() - 1;
1321  			if (linesToScroll == 0) {
1322  				linesToScroll = 1;
1323  			}
1324  			linesToScroll *= verticalWheelDelta.Actions();
1325  			if (wParam &amp; MK_CONTROL) {
1326  				if (linesToScroll &lt; 0) {
1327  					KeyCommand(Message::ZoomIn);
1328  				} else {
1329  					KeyCommand(Message::ZoomOut);
1330  				}
1331  			} else {
1332  				ScrollTo(topLine + linesToScroll);
1333  			}
1334  		}
1335  		return 0;
1336  	}
1337  	return 0;
1338  }
1339  sptr_t ScintillaWin::KeyMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1340  	switch (iMessage) {
1341  	case WM_SYSKEYDOWN:
1342  	case WM_KEYDOWN: {
1343  			lastKeyDownConsumed = false;
1344  			const bool altDown = KeyboardIsKeyDown(VK_MENU);
1345  			if (altDown &amp;&amp; KeyboardIsNumericKeypadFunction(wParam, lParam)) {
1346  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1347  			}
1348  			const int ret = KeyDownWithModifiers(
1349  								 KeyTranslate(wParam),
1350  							     ModifierFlags(KeyboardIsKeyDown(VK_SHIFT),
1351  									     KeyboardIsKeyDown(VK_CONTROL),
1352  									     altDown),
1353  							     &amp;lastKeyDownConsumed);
1354  			if (!ret &amp;&amp; !lastKeyDownConsumed) {
1355  				return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1356  			}
1357  			break;
1358  		}
1359  	case WM_KEYUP:
1360  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1361  	case WM_CHAR:
1362  		if (((wParam &gt;= 128) || !iscntrl(static_cast&lt;int&gt;(wParam))) || !lastKeyDownConsumed) {
1363  			wchar_t wcs[3] = { static_cast&lt;wchar_t&gt;(wParam), 0 };
1364  			unsigned int wclen = 1;
1365  			if (IS_HIGH_SURROGATE(wcs[0])) {
1366  				lastHighSurrogateChar = wcs[0];
1367  				return 0;
1368  			} else if (IS_LOW_SURROGATE(wcs[0])) {
1369  				wcs[1] = wcs[0];
1370  				wcs[0] = lastHighSurrogateChar;
1371  				lastHighSurrogateChar = 0;
1372  				wclen = 2;
1373  			}
1374  			AddWString(std::wstring_view(wcs, wclen), CharacterSource::DirectInput);
1375  		}
1376  		return 0;
1377  	case WM_UNICHAR:
1378  		if (wParam == UNICODE_NOCHAR) {
1379  			return TRUE;
1380  		} else if (lastKeyDownConsumed) {
1381  			return 1;
1382  		} else {
1383  			wchar_t wcs[3] = { 0 };
1384  			const size_t wclen = UTF16FromUTF32Character(static_cast&lt;unsigned int&gt;(wParam), wcs);
1385  			AddWString(std::wstring_view(wcs, wclen), CharacterSource::DirectInput);
1386  			return FALSE;
1387  		}
1388  	}
1389  	return 0;
1390  }
1391  sptr_t ScintillaWin::FocusMessage(unsigned int iMessage, uptr_t wParam, sptr_t) {
1392  	switch (iMessage) {
1393  	case WM_KILLFOCUS: {
1394  		HWND wOther = reinterpret_cast&lt;HWND&gt;(wParam);
1395  		HWND wThis = MainHWND();
1396  		const HWND wCT = HwndFromWindow(ct.wCallTip);
1397  		if (!wParam ||
1398  			!(::IsChild(wThis, wOther) || (wOther == wCT))) {
1399  			SetFocusState(false);
1400  			DestroySystemCaret();
1401  		}
1402  		IMContext imc(MainHWND());
1403  		if (imc.hIMC) {
1404  			::ImmNotifyIME(imc.hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
1405  		}
1406  		break;
1407  	}
1408  	case WM_SETFOCUS:
1409  		SetFocusState(true);
1410  		DestroySystemCaret();
1411  		CreateSystemCaret();
1412  		break;
1413  	}
1414  	return 0;
1415  }
1416  sptr_t ScintillaWin::IMEMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1417  	switch (iMessage) {
1418  	case WM_INPUTLANGCHANGE:
1419  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1420  	case WM_INPUTLANGCHANGEREQUEST:
1421  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1422  	case WM_IME_KEYDOWN: {
1423  			if (wParam == VK_HANJA) {
1424  				ToggleHanja();
1425  			}
1426  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1427  		}
1428  	case WM_IME_REQUEST: {
1429  			if (wParam == IMR_RECONVERTSTRING) {
1430  				return ImeOnReconvert(lParam);
1431  			}
1432  			if (wParam == IMR_DOCUMENTFEED) {
1433  				return ImeOnDocumentFeed(lParam);
1434  			}
1435  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1436  		}
1437  	case WM_IME_STARTCOMPOSITION:
1438  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1439  			return 0;
1440  		} else {
1441  			ImeStartComposition();
1442  			return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1443  		}
1444  	case WM_IME_ENDCOMPOSITION:
1445  		ImeEndComposition();
1446  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1447  	case WM_IME_COMPOSITION:
1448  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1449  			return HandleCompositionInline(wParam, lParam);
1450  		} else {
1451  			return HandleCompositionWindowed(wParam, lParam);
1452  		}
1453  	case WM_IME_SETCONTEXT:
1454  		if (KoreanIME() || imeInteraction == IMEInteraction::Inline) {
1455  			if (wParam) {
1456  				LPARAM NoImeWin = lParam;
1457  				NoImeWin = NoImeWin &amp; (~ISC_SHOWUICOMPOSITIONWINDOW);
1458  				return ::DefWindowProc(MainHWND(), iMessage, wParam, NoImeWin);
1459  			}
1460  		}
1461  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1462  	case WM_IME_NOTIFY:
1463  		return ::DefWindowProc(MainHWND(), iMessage, wParam, lParam);
1464  	}
1465  	return 0;
1466  }
1467  sptr_t ScintillaWin::EditMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1468  	switch (iMessage) {
1469  	case EM_LINEFROMCHAR:
1470  		if (PositionFromUPtr(wParam) &lt; 0) {
1471  			wParam = SelectionStart().Position();
1472  		}
1473  		return pdoc-&gt;LineFromPosition(wParam);
1474  	case EM_EXLINEFROMCHAR:
1475  		return pdoc-&gt;LineFromPosition(lParam);
1476  	case EM_GETSEL:
1477  		if (wParam) {
1478  			*reinterpret_cast&lt;DWORD *&gt;(wParam) = static_cast&lt;DWORD&gt;(SelectionStart().Position());
1479  		}
1480  		if (lParam) {
1481  			*reinterpret_cast&lt;DWORD *&gt;(lParam) = static_cast&lt;DWORD&gt;(SelectionEnd().Position());
1482  		}
1483  		return MAKELRESULT(SelectionStart().Position(), SelectionEnd().Position());
1484  	case EM_EXGETSEL: {
1485  			if (lParam == 0) {
1486  				return 0;
1487  			}
1488  			CHARRANGE *pCR = reinterpret_cast&lt;CHARRANGE *&gt;(lParam);
1489  			pCR-&gt;cpMin = static_cast&lt;LONG&gt;(SelectionStart().Position());
1490  			pCR-&gt;cpMax = static_cast&lt;LONG&gt;(SelectionEnd().Position());
1491  		}
1492  		break;
1493  	case EM_SETSEL: {
1494  			Sci::Position nStart = wParam;
1495  			Sci::Position nEnd = lParam;
1496  			if (nStart == 0 &amp;&amp; nEnd == -1) {
1497  				nEnd = pdoc-&gt;Length();
1498  			}
1499  			if (nStart == -1) {
1500  				nStart = nEnd;	
1501  			}
1502  			SetSelection(nEnd, nStart);
1503  			EnsureCaretVisible();
1504  		}
1505  		break;
1506  	case EM_EXSETSEL: {
1507  			if (lParam == 0) {
1508  				return 0;
1509  			}
1510  			const CHARRANGE *pCR = reinterpret_cast&lt;const CHARRANGE *&gt;(lParam);
1511  			sel.selType = Selection::SelTypes::stream;
1512  			if (pCR-&gt;cpMin == 0 &amp;&amp; pCR-&gt;cpMax == -1) {
1513  				SetSelection(pCR-&gt;cpMin, pdoc-&gt;Length());
1514  			} else {
1515  				SetSelection(pCR-&gt;cpMin, pCR-&gt;cpMax);
1516  			}
1517  			EnsureCaretVisible();
1518  			return pdoc-&gt;LineFromPosition(SelectionStart().Position());
1519  		}
1520  	}
1521  	return 0;
1522  }
1523  sptr_t ScintillaWin::IdleMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
1524  	switch (iMessage) {
1525  	case SC_WIN_IDLE:
1526  		if (idler.state) {
1527  			if (lParam || (WAIT_TIMEOUT == MsgWaitForMultipleObjects(0, nullptr, 0, 0, QS_INPUT | QS_HOTKEY))) {
1528  				if (Idle()) {
1529  #ifdef _MSC_VER
1530  #pragma warning(suppress: 28159)
1531  #endif
1532  					const DWORD dwCurrent = GetTickCount();
1533  					const DWORD dwStart = wParam ? static_cast&lt;DWORD&gt;(wParam) : dwCurrent;
1534  					constexpr DWORD maxWorkTime = 50;
1535  					if (dwCurrent &gt;= dwStart &amp;&amp; dwCurrent &gt; maxWorkTime &amp;&amp;dwCurrent - maxWorkTime &lt; dwStart)
1536  						PostMessage(MainHWND(), SC_WIN_IDLE, dwStart, 0);
1537  				} else {
1538  					SetIdle(false);
1539  				}
1540  			}
1541  		}
1542  		break;
1543  	case SC_WORK_IDLE:
1544  		IdleWork();
1545  		break;
1546  	}
1547  	return 0;
1548  }
1549  sptr_t ScintillaWin::SciMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
1550  	switch (iMessage) {
1551  	case Message::GetDirectFunction:
1552  		return reinterpret_cast&lt;sptr_t&gt;(DirectFunction);
1553  	case Message::GetDirectStatusFunction:
1554  		return reinterpret_cast&lt;sptr_t&gt;(DirectStatusFunction);
1555  	case Message::GetDirectPointer:
1556  		return reinterpret_cast&lt;sptr_t&gt;(this);
1557  #ifdef SCI_OWNREGEX
1558  	case Message::GetBoostRegexErrmsg:
1559  	{
1560  		if (lParam == 0)
1561  			return g_exceptionMessage.length() + 1;
1562  		if (wParam == 0)
1563  			return 0;
1564  		char *ptr = CharPtrFromSPtr(lParam);
1565  		const Sci_Position len = std::min&lt;Sci_Position&gt;(wParam - 1, g_exceptionMessage.length());
1566  		strncpy (ptr, g_exceptionMessage.c_str(), len);
1567  		ptr [len] = &#x27;\0&#x27;;
1568  		return len;
1569  	}
1570  #endif
1571  	case Message::GrabFocus:
1572  		::SetFocus(MainHWND());
1573  		break;
1574  #ifdef INCLUDE_DEPRECATED_FEATURES
1575  	case Message::SETKEYSUNICODE:
1576  		break;
1577  	case Message::GETKEYSUNICODE:
1578  		return true;
1579  #endif
1580  	case Message::SetTechnology:
1581  		if (const Technology technologyNew = static_cast&lt;Technology&gt;(wParam);
1582  			(technologyNew == Technology::Default) ||
1583  			(technologyNew == Technology::DirectWriteRetain) ||
1584  			(technologyNew == Technology::DirectWriteDC) ||
1585  			(technologyNew == Technology::DirectWrite)) {
1586  			if (technology != technologyNew) {
1587  				if (technologyNew &gt; Technology::Default) {
1588  #if defined(USE_D2D)
1589  					if (!LoadD2D()) {
1590  						return 0;
1591  					}
1592  					UpdateRenderingParams(true);
1593  #else
1594  					return 0;
1595  #endif
1596  				} else {
1597  					bidirectional = Bidirectional::Disabled;
1598  				}
1599  				DropRenderTarget();
1600  				technology = technologyNew;
1601  				view.bufferedDraw = technologyNew == Technology::Default;
1602  				InvalidateStyleRedraw();
1603  			}
1604  		}
1605  		break;
1606  	case Message::SetBidirectional:
1607  		if (technology == Technology::Default) {
1608  			bidirectional = Bidirectional::Disabled;
1609  		} else if (static_cast&lt;Bidirectional&gt;(wParam) &lt;= Bidirectional::R2L) {
1610  			bidirectional = static_cast&lt;Bidirectional&gt;(wParam);
1611  		}
1612  		InvalidateStyleRedraw();
1613  		break;
1614  	case Message::TargetAsUTF8:
1615  		return TargetAsUTF8(CharPtrFromSPtr(lParam));
1616  	case Message::EncodedFromUTF8:
1617  		return EncodedFromUTF8(ConstCharPtrFromUPtr(wParam),
1618  			CharPtrFromSPtr(lParam));
1619  	default:
1620  		break;
1621  	}
1622  	return 0;
1623  }
1624  sptr_t ScintillaWin::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
1625  	try {
1626  		const unsigned int msg = static_cast&lt;unsigned int&gt;(iMessage);
1627  		switch (msg) {
1628  		case WM_CREATE:
1629  			ctrlID = ::GetDlgCtrlID(HwndFromWindow(wMain));
1630  			UpdateBaseElements();
1631  			GetIntelliMouseParameters();
1632  			::RegisterDragDrop(MainHWND(), &amp;dt);
1633  			break;
1634  		case WM_COMMAND:
1635  			Command(LOWORD(wParam));
1636  			break;
1637  		case WM_PAINT:
1638  			return WndPaint();
1639  		case WM_PRINTCLIENT: {
1640  				HDC hdc = reinterpret_cast&lt;HDC&gt;(wParam);
1641  				if (!IsCompatibleDC(hdc)) {
1642  					return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1643  				}
1644  				FullPaintDC(hdc);
1645  			}
1646  			break;
1647  		case WM_VSCROLL:
1648  			ScrollMessage(wParam);
1649  			break;
1650  		case WM_HSCROLL:
1651  			HorizontalScrollMessage(wParam);
1652  			break;
1653  		case WM_SIZE:
1654  			SizeWindow();
1655  			break;
1656  		case WM_TIMER:
1657  			if (wParam == idleTimerID &amp;&amp; idler.state) {
1658  				SendMessage(MainHWND(), SC_WIN_IDLE, 0, 1);
1659  			} else {
1660  				TickFor(static_cast&lt;TickReason&gt;(wParam - fineTimerStart));
1661  			}
1662  			break;
1663  		case SC_WIN_IDLE:
1664  		case SC_WORK_IDLE:
1665  			return IdleMessage(msg, wParam, lParam);
1666  		case WM_GETMINMAXINFO:
1667  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1668  		case WM_LBUTTONDOWN:
1669  		case WM_LBUTTONUP:
1670  		case WM_RBUTTONDOWN:
1671  		case WM_MOUSEMOVE:
1672  		case WM_MOUSELEAVE:
1673  		case WM_MOUSEWHEEL:
1674  		case WM_MOUSEHWHEEL:
1675  			return MouseMessage(msg, wParam, lParam);
1676  		case WM_SETCURSOR:
1677  			if (LOWORD(lParam) == HTCLIENT) {
1678  				POINT pt;
1679  				if (::GetCursorPos(&amp;pt)) {
1680  					::ScreenToClient(MainHWND(), &amp;pt);
1681  					DisplayCursor(ContextCursor(PointFromPOINT(pt)));
1682  				}
1683  				return TRUE;
1684  			} else {
1685  				return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1686  			}
1687  		case WM_SYSKEYDOWN:
1688  		case WM_KEYDOWN:
1689  		case WM_KEYUP:
1690  		case WM_CHAR:
1691  		case WM_UNICHAR:
1692  			return KeyMessage(msg, wParam, lParam);
1693  		case WM_SETTINGCHANGE:
1694  #if defined(USE_D2D)
1695  			if (technology != Technology::Default) {
1696  				UpdateRenderingParams(true);
1697  			}
1698  #endif
1699  			UpdateBaseElements();
1700  			GetIntelliMouseParameters();
1701  			InvalidateStyleRedraw();
1702  			break;
1703  		case WM_GETDLGCODE:
1704  			return DLGC_HASSETSEL | DLGC_WANTALLKEYS;
1705  		case WM_KILLFOCUS:
1706  		case WM_SETFOCUS:
1707  			return FocusMessage(msg, wParam, lParam);
1708  		case WM_SYSCOLORCHANGE:
1709  			UpdateBaseElements();
1710  			InvalidateStyleData();
1711  			break;
1712  		case WM_DPICHANGED:
1713  			dpi = HIWORD(wParam);
1714  			InvalidateStyleRedraw();
1715  			break;
1716  		case WM_DPICHANGED_AFTERPARENT: {
1717  				const UINT dpiNow = DpiForWindow(wMain.GetID());
1718  				if (dpi != dpiNow) {
1719  					dpi = dpiNow;
1720  					InvalidateStyleRedraw();
1721  				}
1722  			}
1723  			break;
1724  		case WM_CONTEXTMENU:
1725  			return ShowContextMenu(msg, wParam, lParam);
1726  		case WM_ERASEBKGND:
1727  			return 1;   
1728  		case WM_SETREDRAW:
1729  			::DefWindowProc(MainHWND(), msg, wParam, lParam);
1730  			if (wParam) {
1731  				SetScrollBars();
1732  				SetVerticalScrollPos();
1733  				SetHorizontalScrollPos();
1734  			}
1735  			return 0;
1736  		case WM_CAPTURECHANGED:
1737  			capturedMouse = false;
1738  			return 0;
1739  		case WM_MOVE:
1740  		case WM_MOUSEACTIVATE:
1741  		case WM_NCHITTEST:
1742  		case WM_NCCALCSIZE:
1743  		case WM_NCPAINT:
1744  		case WM_NCMOUSEMOVE:
1745  		case WM_NCLBUTTONDOWN:
1746  		case WM_SYSCOMMAND:
1747  		case WM_WINDOWPOSCHANGING:
1748  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1749  		case WM_WINDOWPOSCHANGED:
1750  #if defined(USE_D2D)
1751  			if (technology != Technology::Default) {
1752  				if (UpdateRenderingParams(false)) {
1753  					DropGraphics();
1754  					Redraw();
1755  				}
1756  			}
1757  #endif
1758  			return ::DefWindowProc(MainHWND(), msg, wParam, lParam);
1759  		case WM_GETTEXTLENGTH:
1760  			return GetTextLength();
1761  		case WM_GETTEXT:
1762  			return GetText(wParam, lParam);
1763  		case WM_INPUTLANGCHANGE:
1764  		case WM_INPUTLANGCHANGEREQUEST:
1765  		case WM_IME_KEYDOWN:
1766  		case WM_IME_REQUEST:
1767  		case WM_IME_STARTCOMPOSITION:
1768  		case WM_IME_ENDCOMPOSITION:
1769  		case WM_IME_COMPOSITION:
1770  		case WM_IME_SETCONTEXT:
1771  		case WM_IME_NOTIFY:
1772  			return IMEMessage(msg, wParam, lParam);
1773  		case EM_LINEFROMCHAR:
1774  		case EM_EXLINEFROMCHAR:
1775  		case EM_GETSEL:
1776  		case EM_EXGETSEL:
1777  		case EM_SETSEL:
1778  		case EM_EXSETSEL:
1779  			return EditMessage(msg, wParam, lParam);
1780  		}
1781  		iMessage = SciMessageFromEM(msg);
1782  		switch (iMessage) {
1783  		case Message::GetDirectFunction:
1784  		case Message::GetDirectStatusFunction:
1785  		case Message::GetDirectPointer:
1786  #ifdef SCI_OWNREGEX
1787  		case Message::GetBoostRegexErrmsg:
1788  #endif
1789  		case Message::GrabFocus:
1790  		case Message::SetTechnology:
1791  		case Message::SetBidirectional:
1792  		case Message::TargetAsUTF8:
1793  		case Message::EncodedFromUTF8:
1794  			return SciMessage(iMessage, wParam, lParam);
1795  		default:
1796  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
1797  		}
1798  	} catch (std::bad_alloc &amp;) {
1799  		errorStatus = Status::BadAlloc;
1800  	} catch (...) {
1801  		errorStatus = Status::Failure;
1802  	}
1803  	return 0;
1804  }
1805  bool ScintillaWin::ValidCodePage(int codePage) const {
1806  	return codePage == 0 || codePage == CpUtf8 ||
1807  	       codePage == 932 || codePage == 936 || codePage == 949 ||
1808  	       codePage == 950 || codePage == 1361;
1809  }
1810  std::string ScintillaWin::UTF8FromEncoded(std::string_view encoded) const {
1811  	if (IsUnicodeMode()) {
1812  		return std::string(encoded);
1813  	} else {
1814  		std::wstring ws = StringDecode(encoded, CodePageOfDocument());
1815  		return StringEncode(ws, CpUtf8);
1816  	}
1817  }
1818  std::string ScintillaWin::EncodedFromUTF8(std::string_view utf8) const {
1819  	if (IsUnicodeMode()) {
1820  		return std::string(utf8);
1821  	} else {
1822  		std::wstring ws = StringDecode(utf8, CpUtf8);
1823  		return StringEncode(ws, CodePageOfDocument());
1824  	}
1825  }
1826  sptr_t ScintillaWin::DefWndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
1827  	return ::DefWindowProc(MainHWND(), static_cast&lt;unsigned int&gt;(iMessage), wParam, lParam);
1828  }
1829  bool ScintillaWin::FineTickerRunning(TickReason reason) {
1830  	return timers[static_cast&lt;size_t&gt;(reason)] != 0;
1831  }
1832  void ScintillaWin::FineTickerStart(TickReason reason, int millis, int tolerance) {
1833  	FineTickerCancel(reason);
1834  	const UINT_PTR reasonIndex = static_cast&lt;UINT_PTR&gt;(reason);
1835  	const UINT_PTR eventID = static_cast&lt;UINT_PTR&gt;(fineTimerStart) + reasonIndex;
1836  	if (SetCoalescableTimerFn &amp;&amp; tolerance) {
1837  		timers[reasonIndex] = SetCoalescableTimerFn(MainHWND(), eventID, millis, nullptr, tolerance);
1838  	} else {
1839  		timers[reasonIndex] = ::SetTimer(MainHWND(), eventID, millis, nullptr);
1840  	}
1841  }
1842  void ScintillaWin::FineTickerCancel(TickReason reason) {
1843  	const UINT_PTR reasonIndex = static_cast&lt;UINT_PTR&gt;(reason);
1844  	if (timers[reasonIndex]) {
1845  		::KillTimer(MainHWND(), timers[reasonIndex]);
1846  		timers[reasonIndex] = 0;
1847  	}
1848  }
1849  bool ScintillaWin::SetIdle(bool on) {
1850  	if (idler.state != on) {
1851  		if (on) {
1852  			idler.idlerID = ::SetTimer(MainHWND(), idleTimerID, 10, nullptr)
1853  				? reinterpret_cast&lt;IdlerID&gt;(idleTimerID) : 0;
1854  		} else {
1855  			::KillTimer(MainHWND(), reinterpret_cast&lt;uptr_t&gt;(idler.idlerID));
1856  			idler.idlerID = 0;
1857  		}
1858  		idler.state = idler.idlerID != 0;
1859  	}
1860  	return idler.state;
1861  }
1862  void ScintillaWin::IdleWork() {
1863  	styleIdleInQueue = false;
1864  	Editor::IdleWork();
1865  }
1866  void ScintillaWin::QueueIdleWork(WorkItems items, Sci::Position upTo) {
1867  	Editor::QueueIdleWork(items, upTo);
1868  	if (!styleIdleInQueue) {
1869  		if (PostMessage(MainHWND(), SC_WORK_IDLE, 0, 0)) {
1870  			styleIdleInQueue = true;
1871  		}
1872  	}
1873  }
1874  void ScintillaWin::SetMouseCapture(bool on) {
1875  	if (mouseDownCaptures) {
1876  		if (on) {
1877  			::SetCapture(MainHWND());
1878  		} else {
1879  			::ReleaseCapture();
1880  		}
1881  	}
1882  	capturedMouse = on;
1883  }
1884  bool ScintillaWin::HaveMouseCapture() {
1885  	return capturedMouse;
1886  }
1887  void ScintillaWin::SetTrackMouseLeaveEvent(bool on) noexcept {
1888  	if (on &amp;&amp; !trackedMouseLeave) {
1889  		TRACKMOUSEEVENT tme {};
1890  		tme.cbSize = sizeof(tme);
1891  		tme.dwFlags = TME_LEAVE;
1892  		tme.hwndTrack = MainHWND();
1893  		tme.dwHoverTime = HOVER_DEFAULT;	
1894  		TrackMouseEvent(&amp;tme);
1895  	}
1896  	trackedMouseLeave = on;
1897  }
1898  void ScintillaWin::UpdateBaseElements() {
1899  	struct ElementToIndex { Element element; int nIndex; };
1900  	const ElementToIndex eti[] = {
1901  		{ Element::List, COLOR_WINDOWTEXT },
1902  		{ Element::ListBack, COLOR_WINDOW },
1903  		{ Element::ListSelected, COLOR_HIGHLIGHTTEXT },
1904  		{ Element::ListSelectedBack, COLOR_HIGHLIGHT },
1905  	};
1906  	bool changed = false;
1907  	for (const ElementToIndex &amp;ei : eti) {
1908  		changed = vs.SetElementBase(ei.element, ColourRGBA::FromRGB(static_cast&lt;int&gt;(::GetSysColor(ei.nIndex)))) || changed;
1909  	}
1910  	if (changed) {
1911  		Redraw();
1912  	}
1913  }
1914  bool ScintillaWin::PaintContains(PRectangle rc) {
1915  	if (paintState == PaintState::painting) {
1916  		return BoundsContains(rcPaint, hRgnUpdate, rc);
1917  	}
1918  	return true;
1919  }
1920  void ScintillaWin::ScrollText(Sci::Line &amp;bsol;* linesToMove */) {
1921  	Redraw();
1922  	UpdateSystemCaret();
1923  }
1924  void ScintillaWin::NotifyCaretMove() {
1925  	NotifyWinEvent(EVENT_OBJECT_LOCATIONCHANGE, MainHWND(), OBJID_CARET, CHILDID_SELF);
1926  }
1927  void ScintillaWin::UpdateSystemCaret() {
1928  	if (hasFocus) {
1929  		if (pdoc-&gt;TentativeActive()) {
1930  			return;
1931  		}
1932  		if (HasCaretSizeChanged()) {
1933  			DestroySystemCaret();
1934  			CreateSystemCaret();
1935  		}
1936  		const Point pos = PointMainCaret();
1937  		::SetCaretPos(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y));
1938  	}
1939  }
1940  bool ScintillaWin::IsVisible() const noexcept {
1941  	return GetWindowStyle(MainHWND()) &amp; WS_VISIBLE;
1942  }
1943  int ScintillaWin::SetScrollInfo(int nBar, LPCSCROLLINFO lpsi, BOOL bRedraw) noexcept {
1944  	return ::SetScrollInfo(MainHWND(), nBar, lpsi, bRedraw);
1945  }
1946  bool ScintillaWin::GetScrollInfo(int nBar, LPSCROLLINFO lpsi) noexcept {
1947  	return ::GetScrollInfo(MainHWND(), nBar, lpsi) ? true : false;
1948  }
1949  void ScintillaWin::ChangeScrollPos(int barType, Sci::Position pos) {
1950  	if (!IsVisible()) {
1951  		return;
1952  	}
1953  	SCROLLINFO sci = {
1954  		sizeof(sci), 0, 0, 0, 0, 0, 0
1955  	};
1956  	sci.fMask = SIF_POS;
1957  	GetScrollInfo(barType, &amp;sci);
1958  	if (sci.nPos != pos) {
1959  		DwellEnd(true);
1960  		sci.nPos = static_cast&lt;int&gt;(pos);
1961  		SetScrollInfo(barType, &amp;sci, TRUE);
1962  	}
1963  }
1964  void ScintillaWin::SetVerticalScrollPos() {
1965  	ChangeScrollPos(SB_VERT, topLine);
1966  }
1967  void ScintillaWin::SetHorizontalScrollPos() {
1968  	ChangeScrollPos(SB_HORZ, xOffset);
1969  }
1970  bool ScintillaWin::ChangeScrollRange(int nBar, int nMin, int nMax, UINT nPage) noexcept {
1971  	SCROLLINFO sci = { sizeof(sci), SIF_PAGE | SIF_RANGE, 0, 0, 0, 0, 0 };
1972  	GetScrollInfo(nBar, &amp;sci);
1973  	if ((sci.nMin != nMin) || (sci.nMax != nMax) ||	(sci.nPage != nPage)) {
1974  		sci.nMin = nMin;
1975  		sci.nMax = nMax;
1976  		sci.nPage = nPage;
1977  		SetScrollInfo(nBar, &amp;sci, TRUE);
1978  		return true;
1979  	}
1980  	return false;
1981  }
1982  void ScintillaWin::HorizontalScrollToClamped(int xPos) {
1983  	const HorizontalScrollRange range = GetHorizontalScrollRange();
1984  	HorizontalScrollTo(std::clamp(xPos, 0, range.documentWidth - range.pageWidth + 1));
1985  }
1986  HorizontalScrollRange ScintillaWin::GetHorizontalScrollRange() const {
1987  	const PRectangle rcText = GetTextRectangle();
1988  	int pageWidth = static_cast&lt;int&gt;(rcText.Width());
1989  	const int horizEndPreferred = std::max({ scrollWidth, pageWidth - 1, 0 });
1990  	if (!horizontalScrollBarVisible || Wrapping())
1991  		pageWidth = horizEndPreferred + 1;
1992  	return { pageWidth, horizEndPreferred };
1993  }
1994  bool ScintillaWin::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage) {
1995  	if (!IsVisible()) {
1996  		return false;
1997  	}
1998  	bool modified = false;
1999  	const Sci::Line vertEndPreferred = nMax;
2000  	if (!verticalScrollBarVisible)
2001  		nPage = vertEndPreferred + 1;
2002  	if (ChangeScrollRange(SB_VERT, 0, static_cast&lt;int&gt;(vertEndPreferred), static_cast&lt;unsigned int&gt;(nPage))) {
2003  		modified = true;
2004  	}
2005  	const HorizontalScrollRange range = GetHorizontalScrollRange();
2006  	if (ChangeScrollRange(SB_HORZ, 0, range.documentWidth, range.pageWidth)) {
2007  		modified = true;
2008  		if (scrollWidth &lt; range.pageWidth) {
2009  			HorizontalScrollTo(0);
2010  		}
2011  	}
2012  	return modified;
2013  }
2014  void ScintillaWin::NotifyChange() {
2015  	::SendMessage(::GetParent(MainHWND()), WM_COMMAND,
2016  	        MAKEWPARAM(GetCtrlID(), FocusChange::Change),
2017  		reinterpret_cast&lt;LPARAM&gt;(MainHWND()));
2018  }
2019  void ScintillaWin::NotifyFocus(bool focus) {
2020  	if (commandEvents) {
2021  		::SendMessage(::GetParent(MainHWND()), WM_COMMAND,
2022  			MAKEWPARAM(GetCtrlID(), focus ? FocusChange::Setfocus : FocusChange::Killfocus),
2023  			reinterpret_cast&lt;LPARAM&gt;(MainHWND()));
2024  	}
2025  	Editor::NotifyFocus(focus);
2026  }
2027  void ScintillaWin::SetCtrlID(int identifier) {
2028  	::SetWindowID(HwndFromWindow(wMain), identifier);
2029  }
2030  int ScintillaWin::GetCtrlID() {
2031  	return ::GetDlgCtrlID(HwndFromWindow(wMain));
2032  }
2033  void ScintillaWin::NotifyParent(NotificationData scn) {
2034  	scn.nmhdr.hwndFrom = MainHWND();
2035  	scn.nmhdr.idFrom = GetCtrlID();
2036  	::SendMessage(::GetParent(MainHWND()), WM_NOTIFY,
2037  	              GetCtrlID(), reinterpret_cast&lt;LPARAM&gt;(&amp;scn));
2038  }
2039  void ScintillaWin::NotifyDoubleClick(Point pt, KeyMod modifiers) {
2040  	ScintillaBase::NotifyDoubleClick(pt, modifiers);
2041  	::SendMessage(MainHWND(),
2042  			  WM_LBUTTONDBLCLK,
2043  			  FlagSet(modifiers, KeyMod::Shift) ? MK_SHIFT : 0,
2044  			  MAKELPARAM(pt.x, pt.y));
2045  }
2046  namespace {
2047  class CaseFolderDBCS : public CaseFolderTable {
2048  	std::vector&lt;wchar_t&gt; utf16Mixed;
2049  	std::vector&lt;wchar_t&gt; utf16Folded;
2050  	UINT cp;
2051  public:
2052  	explicit CaseFolderDBCS(UINT cp_) : cp(cp_) {
2053  	}
2054  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
2055  		if ((lenMixed == 1) &amp;&amp; (sizeFolded &gt; 0)) {
2056  			folded[0] = mapping[static_cast&lt;unsigned char&gt;(mixed[0])];
2057  			return 1;
2058  		} else {
2059  			if (lenMixed &gt; utf16Mixed.size()) {
2060  				utf16Mixed.resize(lenMixed + 8);
2061  			}
2062  			const size_t nUtf16Mixed = WideCharFromMultiByte(cp,
2063  				std::string_view(mixed, lenMixed),
2064  				&amp;utf16Mixed[0],
2065  				utf16Mixed.size());
2066  			if (nUtf16Mixed == 0) {
2067  				folded[0] = &#x27;\0&#x27;;
2068  				return 1;
2069  			}
2070  			size_t lenFlat = 0;
2071  			for (size_t mixIndex=0; mixIndex &lt; nUtf16Mixed; mixIndex++) {
2072  				if ((lenFlat + 20) &gt; utf16Folded.size())
2073  					utf16Folded.resize(lenFlat + 60);
2074  				const char *foldedUTF8 = CaseConvert(utf16Mixed[mixIndex], CaseConversion::fold);
2075  				if (foldedUTF8) {
2076  					wchar_t wFolded[20];
2077  					const size_t charsConverted = UTF16FromUTF8(std::string_view(foldedUTF8),
2078  							wFolded, std::size(wFolded));
2079  					for (size_t j=0; j&lt;charsConverted; j++)
2080  						utf16Folded[lenFlat++] = wFolded[j];
2081  				} else {
2082  					utf16Folded[lenFlat++] = utf16Mixed[mixIndex];
2083  				}
2084  			}
2085  			const std::wstring_view wsvFolded(&amp;utf16Folded[0], lenFlat);
2086  			const size_t lenOut = MultiByteLenFromWideChar(cp, wsvFolded);
2087  			if (lenOut &lt; sizeFolded) {
2088  				MultiByteFromWideChar(cp, wsvFolded, folded, lenOut);
2089  				return lenOut;
2090  			} else {
2091  				return 0;
2092  			}
2093  		}
2094  	}
2095  };
2096  }
2097  std::unique_ptr&lt;CaseFolder&gt; ScintillaWin::CaseFolderForEncoding() {
2098  	const UINT cpDest = CodePageOfDocument();
2099  	if (cpDest == CpUtf8) {
2100  		return std::make_unique&lt;CaseFolderUnicode&gt;();
2101  	} else {
2102  		if (pdoc-&gt;dbcsCodePage == 0) {
2103  			std::unique_ptr&lt;CaseFolderTable&gt; pcf = std::make_unique&lt;CaseFolderTable&gt;();
2104  			for (int i=0x80; i&lt;0x100; i++) {
2105  				char sCharacter[2] = &quot;A&quot;;
2106  				sCharacter[0] = static_cast&lt;char&gt;(i);
2107  				wchar_t wCharacter[20];
2108  				const unsigned int lengthUTF16 = WideCharFromMultiByte(cpDest, sCharacter,
2109  					wCharacter, std::size(wCharacter));
2110  				if (lengthUTF16 == 1) {
2111  					const char *caseFolded = CaseConvert(wCharacter[0], CaseConversion::fold);
2112  					if (caseFolded) {
2113  						wchar_t wLower[20];
2114  						const size_t charsConverted = UTF16FromUTF8(std::string_view(caseFolded),
2115  							wLower, std::size(wLower));
2116  						if (charsConverted == 1) {
2117  							char sCharacterLowered[20];
2118  							const unsigned int lengthConverted = MultiByteFromWideChar(cpDest,
2119  								std::wstring_view(wLower, charsConverted),
2120  								sCharacterLowered, std::size(sCharacterLowered));
2121  							if ((lengthConverted == 1) &amp;&amp; (sCharacter[0] != sCharacterLowered[0])) {
2122  								pcf-&gt;SetTranslation(sCharacter[0], sCharacterLowered[0]);
2123  							}
2124  						}
2125  					}
2126  				}
2127  			}
2128  			return pcf;
2129  		} else {
2130  			return std::make_unique&lt;CaseFolderDBCS&gt;(cpDest);
2131  		}
2132  	}
2133  }
2134  std::string ScintillaWin::CaseMapString(const std::string &amp;s, CaseMapping caseMapping) {
2135  	if ((s.size() == 0) || (caseMapping == CaseMapping::same))
2136  		return s;
2137  	const UINT cpDoc = CodePageOfDocument();
2138  	if (cpDoc == CpUtf8) {
2139  		return CaseConvertString(s, (caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
2140  	}
2141  	const std::wstring wsText = StringDecode(s, cpDoc);
2142  	const DWORD mapFlags = LCMAP_LINGUISTIC_CASING |
2143  		((caseMapping == CaseMapping::upper) ? LCMAP_UPPERCASE : LCMAP_LOWERCASE);
2144  	const std::wstring wsConverted = StringMapCase(wsText, mapFlags);
2145  	std::string sConverted = StringEncode(wsConverted, cpDoc);
2146  	return sConverted;
2147  }
2148  void ScintillaWin::Copy() {
2149  	if (!sel.Empty()) {
2150  		SelectionText selectedText;
2151  		CopySelectionRange(&amp;selectedText);
2152  		CopyToClipboard(selectedText);
2153  	}
2154  }
2155  bool ScintillaWin::CanPaste() {
2156  	if (!Editor::CanPaste())
2157  		return false;
2158  	return ::IsClipboardFormatAvailable(CF_UNICODETEXT) != FALSE;
2159  }
2160  namespace {
2161  class GlobalMemory {
2162  	HGLOBAL hand {};
2163  public:
2164  	void *ptr {};
2165  	GlobalMemory() noexcept {
2166  	}
2167  	explicit GlobalMemory(HGLOBAL hand_) noexcept : hand(hand_) {
2168  		if (hand) {
2169  			ptr = ::GlobalLock(hand);
2170  		}
2171  	}
2172  	GlobalMemory(const GlobalMemory &amp;) = delete;
2173  	GlobalMemory(GlobalMemory &amp;&amp;) = delete;
2174  	GlobalMemory &amp;operator=(const GlobalMemory &amp;) = delete;
2175  	GlobalMemory &amp;operator=(GlobalMemory &amp;&amp;) = delete;
2176  	~GlobalMemory() {
2177  		assert(!ptr);
2178  		assert(!hand);
2179  	}
2180  	void Allocate(size_t bytes) noexcept {
2181  		assert(!hand);
2182  		hand = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, bytes);
2183  		if (hand) {
2184  			ptr = ::GlobalLock(hand);
2185  		}
2186  	}
2187  	HGLOBAL Unlock() noexcept {
2188  		assert(ptr);
2189  		HGLOBAL handCopy = hand;
2190  		::GlobalUnlock(hand);
2191  		ptr = nullptr;
2192  		hand = {};
2193  		return handCopy;
2194  	}
2195  	void SetClip(UINT uFormat) noexcept {
2196  		::SetClipboardData(uFormat, Unlock());
2197  	}
2198  	operator bool() const noexcept {
2199  		return ptr != nullptr;
2200  	}
2201  	SIZE_T Size() const noexcept {
2202  		return ::GlobalSize(hand);
2203  	}
2204  };
2205  bool OpenClipboardRetry(HWND hwnd) noexcept {
2206  	for (int attempt=0; attempt&lt;8; attempt++) {
2207  		if (attempt &gt; 0) {
2208  			::Sleep(1 &lt;&lt; (attempt-1));
2209  		}
2210  		if (::OpenClipboard(hwnd)) {
2211  			return true;
2212  		}
2213  	}
2214  	return false;
2215  }
2216  bool IsValidFormatEtc(const FORMATETC *pFE) noexcept {
2217  	return pFE-&gt;ptd == nullptr &amp;&amp;
2218  		(pFE-&gt;dwAspect &amp; DVASPECT_CONTENT) != 0 &amp;&amp;
2219  		pFE-&gt;lindex == -1 &amp;&amp;
2220  		(pFE-&gt;tymed &amp; TYMED_HGLOBAL) != 0;
2221  }
2222  bool SupportedFormat(const FORMATETC *pFE) noexcept {
2223  	return pFE-&gt;cfFormat == CF_UNICODETEXT &amp;&amp;
2224  		IsValidFormatEtc(pFE);
2225  }
2226  }
2227  void ScintillaWin::Paste() {
2228  	if (!::OpenClipboardRetry(MainHWND())) {
2229  		return;
2230  	}
2231  	UndoGroup ug(pdoc);
2232  	const bool isLine = SelectionEmpty() &amp;&amp;
2233  		(::IsClipboardFormatAvailable(cfLineSelect) || ::IsClipboardFormatAvailable(cfVSLineTag));
2234  	ClearSelection(multiPasteMode == MultiPaste::Each);
2235  	bool isRectangular = (::IsClipboardFormatAvailable(cfColumnSelect) != 0);
2236  	if (!isRectangular) {
2237  		GlobalMemory memBorlandSelection(::GetClipboardData(cfBorlandIDEBlockType));
2238  		if (memBorlandSelection) {
2239  			isRectangular = (memBorlandSelection.Size() == 1) &amp;&amp; (static_cast&lt;BYTE *&gt;(memBorlandSelection.ptr)[0] == 0x02);
2240  			memBorlandSelection.Unlock();
2241  		}
2242  	}
2243  	const PasteShape pasteShape = isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream);
2244  	GlobalMemory memUSelection(::GetClipboardData(CF_UNICODETEXT));
2245  	if (const wchar_t *uptr = static_cast&lt;const wchar_t *&gt;(memUSelection.ptr)) {
2246  		const std::string putf = EncodeWString(uptr);
2247  		InsertPasteShape(putf.c_str(), putf.length(), pasteShape);
2248  		memUSelection.Unlock();
2249  	}
2250  	::CloseClipboard();
2251  	Redraw();
2252  }
2253  void ScintillaWin::CreateCallTipWindow(PRectangle) {
2254  	if (!ct.wCallTip.Created()) {
2255  		HWND wnd = ::CreateWindow(callClassName, TEXT(&quot;ACallTip&quot;),
2256  					     WS_POPUP, 100, 100, 150, 20,
2257  					     MainHWND(), 0,
2258  					     GetWindowInstance(MainHWND()),
2259  					     this);
2260  		ct.wCallTip = wnd;
2261  		ct.wDraw = wnd;
2262  	}
2263  }
2264  void ScintillaWin::AddToPopUp(const char *label, int cmd, bool enabled) {
2265  	HMENU hmenuPopup = static_cast&lt;HMENU&gt;(popup.GetID());
2266  	if (!label[0])
2267  		::AppendMenuA(hmenuPopup, MF_SEPARATOR, 0, &quot;&quot;);
2268  	else if (enabled)
2269  		::AppendMenuA(hmenuPopup, MF_STRING, cmd, label);
2270  	else
2271  		::AppendMenuA(hmenuPopup, MF_STRING | MF_DISABLED | MF_GRAYED, cmd, label);
2272  }
2273  void ScintillaWin::ClaimSelection() {
2274  }
2275  STDMETHODIMP FormatEnumerator::QueryInterface(REFIID riid, PVOID *ppv) {
2276  	*ppv = nullptr;
2277  	if (riid == IID_IUnknown || riid == IID_IEnumFORMATETC) {
2278  		*ppv = this;
2279  	} else {
2280  		return E_NOINTERFACE;
2281  	}
2282  	AddRef();
2283  	return S_OK;
2284  }
2285  STDMETHODIMP_(ULONG)FormatEnumerator::AddRef() {
2286  	return ++ref;
2287  }
2288  STDMETHODIMP_(ULONG)FormatEnumerator::Release() {
2289  	const ULONG refs = --ref;
2290  	if (refs == 0) {
2291  		delete this;
2292  	}
2293  	return refs;
2294  }
2295  STDMETHODIMP FormatEnumerator::Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFetched) {
2296  	if (!rgelt) return E_POINTER;
2297  	ULONG putPos = 0;
2298  	while ((pos &lt; formats.size()) &amp;&amp; (putPos &lt; celt)) {
2299  		rgelt-&gt;cfFormat = formats[pos];
2300  		rgelt-&gt;ptd = nullptr;
2301  		rgelt-&gt;dwAspect = DVASPECT_CONTENT;
2302  		rgelt-&gt;lindex = -1;
2303  		rgelt-&gt;tymed = TYMED_HGLOBAL;
2304  		rgelt++;
2305  		pos++;
2306  		putPos++;
2307  	}
2308  	if (pceltFetched)
2309  		*pceltFetched = putPos;
2310  	return putPos ? S_OK : S_FALSE;
2311  }
2312  STDMETHODIMP FormatEnumerator::Skip(ULONG celt) {
2313  	pos += celt;
2314  	return S_OK;
2315  }
2316  STDMETHODIMP FormatEnumerator::Reset() {
2317  	pos = 0;
2318  	return S_OK;
2319  }
2320  STDMETHODIMP FormatEnumerator::Clone(IEnumFORMATETC **ppenum) {
2321  	FormatEnumerator *pfe;
2322  	try {
2323  		pfe = new FormatEnumerator(pos, &amp;formats[0], formats.size());
2324  	} catch (...) {
2325  		return E_OUTOFMEMORY;
2326  	}
2327  	return pfe-&gt;QueryInterface(IID_IEnumFORMATETC, reinterpret_cast&lt;void **&gt;(ppenum));
2328  }
2329  FormatEnumerator::FormatEnumerator(ULONG pos_, const CLIPFORMAT formats_[], size_t formatsLen_) {
2330  	ref = 0;   
2331  	pos = pos_;
2332  	formats.insert(formats.begin(), formats_, formats_+formatsLen_);
2333  }
2334  STDMETHODIMP DropSource::QueryInterface(REFIID riid, PVOID *ppv) {
2335  	return sci-&gt;QueryInterface(riid, ppv);
2336  }
2337  STDMETHODIMP_(ULONG)DropSource::AddRef() {
2338  	return sci-&gt;AddRef();
2339  }
2340  STDMETHODIMP_(ULONG)DropSource::Release() {
2341  	return sci-&gt;Release();
2342  }
2343  STDMETHODIMP DropSource::QueryContinueDrag(BOOL fEsc, DWORD grfKeyState) {
2344  	if (fEsc)
2345  		return DRAGDROP_S_CANCEL;
2346  	if (!(grfKeyState &amp; MK_LBUTTON))
2347  		return DRAGDROP_S_DROP;
2348  	return S_OK;
2349  }
2350  STDMETHODIMP DropSource::GiveFeedback(DWORD) {
2351  	return DRAGDROP_S_USEDEFAULTCURSORS;
2352  }
2353  STDMETHODIMP DataObject::QueryInterface(REFIID riid, PVOID *ppv) {
2354  	return sci-&gt;QueryInterface(riid, ppv);
2355  }
2356  STDMETHODIMP_(ULONG)DataObject::AddRef() {
2357  	return sci-&gt;AddRef();
2358  }
2359  STDMETHODIMP_(ULONG)DataObject::Release() {
2360  	return sci-&gt;Release();
2361  }
2362  STDMETHODIMP DataObject::GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) {
2363  	return sci-&gt;GetData(pFEIn, pSTM);
2364  }
2365  STDMETHODIMP DataObject::GetDataHere(FORMATETC *, STGMEDIUM *) {
2366  	return E_NOTIMPL;
2367  }
2368  STDMETHODIMP DataObject::QueryGetData(FORMATETC *pFE) {
2369  	if (sci-&gt;DragIsRectangularOK(pFE-&gt;cfFormat) &amp;&amp; IsValidFormatEtc(pFE)) {
2370  		return S_OK;
2371  	}
2372  	if (SupportedFormat(pFE)) {
2373  		return S_OK;
2374  	} else {
2375  		return S_FALSE;
2376  	}
2377  }
2378  STDMETHODIMP DataObject::GetCanonicalFormatEtc(FORMATETC *, FORMATETC *pFEOut) {
2379  	pFEOut-&gt;cfFormat = CF_UNICODETEXT;
2380  	pFEOut-&gt;ptd = nullptr;
2381  	pFEOut-&gt;dwAspect = DVASPECT_CONTENT;
2382  	pFEOut-&gt;lindex = -1;
2383  	pFEOut-&gt;tymed = TYMED_HGLOBAL;
2384  	return S_OK;
2385  }
2386  STDMETHODIMP DataObject::SetData(FORMATETC *, STGMEDIUM *, BOOL) {
2387  	return E_FAIL;
2388  }
2389  STDMETHODIMP DataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum) {
2390  	try {
2391  		if (dwDirection != DATADIR_GET) {
2392  			*ppEnum = nullptr;
2393  			return E_FAIL;
2394  		}
2395  		const CLIPFORMAT formats[] = {CF_UNICODETEXT};
2396  		FormatEnumerator *pfe = new FormatEnumerator(0, formats, std::size(formats));
2397  		return pfe-&gt;QueryInterface(IID_IEnumFORMATETC, reinterpret_cast&lt;void **&gt;(ppEnum));
2398  	} catch (std::bad_alloc &amp;) {
2399  		sci-&gt;errorStatus = Status::BadAlloc;
2400  		return E_OUTOFMEMORY;
2401  	} catch (...) {
2402  		sci-&gt;errorStatus = Status::Failure;
2403  		return E_FAIL;
2404  	}
2405  }
2406  STDMETHODIMP DataObject::DAdvise(FORMATETC *, DWORD, IAdviseSink *, PDWORD) {
2407  	return E_FAIL;
2408  }
2409  STDMETHODIMP DataObject::DUnadvise(DWORD) {
2410  	return E_FAIL;
2411  }
2412  STDMETHODIMP DataObject::EnumDAdvise(IEnumSTATDATA **) {
2413  	return E_FAIL;
2414  }
2415  STDMETHODIMP DropTarget::QueryInterface(REFIID riid, PVOID *ppv) {
2416  	return sci-&gt;QueryInterface(riid, ppv);
2417  }
2418  STDMETHODIMP_(ULONG)DropTarget::AddRef() {
2419  	return sci-&gt;AddRef();
2420  }
2421  STDMETHODIMP_(ULONG)DropTarget::Release() {
2422  	return sci-&gt;Release();
2423  }
2424  STDMETHODIMP DropTarget::DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2425  	try {
2426  		return sci-&gt;DragEnter(pIDataSource, grfKeyState, pt, pdwEffect);
2427  	} catch (...) {
2428  		sci-&gt;errorStatus = Status::Failure;
2429  	}
2430  	return E_FAIL;
2431  }
2432  STDMETHODIMP DropTarget::DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2433  	try {
2434  		return sci-&gt;DragOver(grfKeyState, pt, pdwEffect);
2435  	} catch (...) {
2436  		sci-&gt;errorStatus = Status::Failure;
2437  	}
2438  	return E_FAIL;
2439  }
2440  STDMETHODIMP DropTarget::DragLeave() {
2441  	try {
2442  		return sci-&gt;DragLeave();
2443  	} catch (...) {
2444  		sci-&gt;errorStatus = Status::Failure;
2445  	}
2446  	return E_FAIL;
2447  }
2448  STDMETHODIMP DropTarget::Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2449  	try {
2450  		return sci-&gt;Drop(pIDataSource, grfKeyState, pt, pdwEffect);
2451  	} catch (...) {
2452  		sci-&gt;errorStatus = Status::Failure;
2453  	}
2454  	return E_FAIL;
2455  }
2456  void ScintillaWin::ImeStartComposition() {
2457  	if (caret.active) {
2458  		IMContext imc(MainHWND());
2459  		const Point pos = PointMainCaret();
2460  		COMPOSITIONFORM CompForm;
2461  		CompForm.dwStyle = CFS_POINT;
2462  		CompForm.ptCurrentPos = POINTFromPoint(pos);
2463  		::ImmSetCompositionWindow(imc.hIMC, &amp;CompForm);
2464  		if (stylesValid) {
2465  			const int styleHere = pdoc-&gt;StyleIndexAt(sel.MainCaret());
2466  			LOGFONTW lf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, L&quot;&quot;};
2467  			int sizeZoomed = vs.styles[styleHere].size + vs.zoomLevel * FontSizeMultiplier;
2468  			if (sizeZoomed &lt;= 2 * FontSizeMultiplier)	
2469  				sizeZoomed = 2 * FontSizeMultiplier;
2470  			lf.lfHeight = -::MulDiv(sizeZoomed, dpi, 72*FontSizeMultiplier);
2471  			lf.lfWeight = static_cast&lt;LONG&gt;(vs.styles[styleHere].weight);
2472  			lf.lfItalic = vs.styles[styleHere].italic ? 1 : 0;
2473  			lf.lfCharSet = DEFAULT_CHARSET;
2474  			lf.lfFaceName[0] = L&#x27;\0&#x27;;
2475  			if (vs.styles[styleHere].fontName) {
2476  				const char* fontName = vs.styles[styleHere].fontName;
2477  				UTF16FromUTF8(std::string_view(fontName), lf.lfFaceName, LF_FACESIZE);
2478  			}
2479  			::ImmSetCompositionFontW(imc.hIMC, &amp;lf);
2480  		}
2481  		DropCaret();
2482  	}
2483  }
2484  void ScintillaWin::ImeEndComposition() {
2485  	view.imeCaretBlockOverride = false;
2486  	pdoc-&gt;TentativeUndo();
2487  	ShowCaretAtCurrentPosition();
2488  }
2489  LRESULT ScintillaWin::ImeOnReconvert(LPARAM lParam) {
2490  	const Sci::Position mainStart = sel.RangeMain().Start().Position();
2491  	const Sci::Position mainEnd = sel.RangeMain().End().Position();
2492  	const Sci::Line curLine = pdoc-&gt;SciLineFromPosition(mainStart);
2493  	if (curLine != pdoc-&gt;LineFromPosition(mainEnd))
2494  		return 0;
2495  	const Sci::Position baseStart = pdoc-&gt;LineStart(curLine);
2496  	const Sci::Position baseEnd = pdoc-&gt;LineEnd(curLine);
2497  	if ((baseStart == baseEnd) || (mainEnd &gt; baseEnd))
2498  		return 0;
2499  	const int codePage = CodePageOfDocument();
2500  	const std::wstring rcFeed = StringDecode(RangeText(baseStart, baseEnd), codePage);
2501  	const int rcFeedLen = static_cast&lt;int&gt;(rcFeed.length()) * sizeof(wchar_t);
2502  	const int rcSize = sizeof(RECONVERTSTRING) + rcFeedLen + sizeof(wchar_t);
2503  	RECONVERTSTRING *rc = static_cast&lt;RECONVERTSTRING *&gt;(PtrFromSPtr(lParam));
2504  	if (!rc)
2505  		return rcSize; 
2506  	wchar_t *rcFeedStart = reinterpret_cast&lt;wchar_t*&gt;(rc + 1);
2507  	memcpy(rcFeedStart, &amp;rcFeed[0], rcFeedLen);
2508  	std::string rcCompString = RangeText(mainStart, mainEnd);
2509  	std::wstring rcCompWstring = StringDecode(rcCompString, codePage);
2510  	std::string rcCompStart = RangeText(baseStart, mainStart);
2511  	std::wstring rcCompWstart = StringDecode(rcCompStart, codePage);
2512  	rc-&gt;dwVersion = 0; 
2513  	rc-&gt;dwStrLen = static_cast&lt;DWORD&gt;(rcFeed.length());
2514  	rc-&gt;dwStrOffset = sizeof(RECONVERTSTRING);
2515  	rc-&gt;dwCompStrLen = static_cast&lt;DWORD&gt;(rcCompWstring.length());
2516  	rc-&gt;dwCompStrOffset = static_cast&lt;DWORD&gt;(rcCompWstart.length()) * sizeof(wchar_t);
2517  	rc-&gt;dwTargetStrLen = rc-&gt;dwCompStrLen;
2518  	rc-&gt;dwTargetStrOffset =rc-&gt;dwCompStrOffset;
2519  	IMContext imc(MainHWND());
2520  	if (!imc.hIMC)
2521  		return 0;
2522  	if (!::ImmSetCompositionStringW(imc.hIMC, SCS_QUERYRECONVERTSTRING, rc, rcSize, nullptr, 0))
2523  		return 0;
2524  	const int tgWlen = rc-&gt;dwTargetStrLen;
2525  	const int tgWstart = rc-&gt;dwTargetStrOffset / sizeof(wchar_t);
2526  	std::string tgCompStart = StringEncode(rcFeed.substr(0, tgWstart), codePage);
2527  	std::string tgComp = StringEncode(rcFeed.substr(tgWstart, tgWlen), codePage);
2528  	const int adjust = static_cast&lt;int&gt;(tgCompStart.length() - rcCompStart.length());
2529  	const int docCompLen = static_cast&lt;int&gt;(tgComp.length());
2530  	for (size_t r=0; r&lt;sel.Count(); r++) {
2531  		const Sci::Position rBase = sel.Range(r).Start().Position();
2532  		const Sci::Position docCompStart = rBase + adjust;
2533  		if (inOverstrike) { 
2534  			sel.Range(r).caret.SetPosition(docCompStart);
2535  			sel.Range(r).anchor.SetPosition(docCompStart);
2536  		} else {
2537  			const Sci::Position lineEnd = pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(rBase));
2538  			const Sci::Position overflow = (docCompStart + docCompLen) - lineEnd;
2539  			if (overflow &gt; 0) {
2540  				pdoc-&gt;DeleteChars(docCompStart, docCompLen - overflow);
2541  			} else {
2542  				pdoc-&gt;DeleteChars(docCompStart, docCompLen);
2543  			}
2544  		}
2545  	}
2546  	return rcSize;
2547  }
2548  LRESULT ScintillaWin::ImeOnDocumentFeed(LPARAM lParam) const {
2549  	const Sci::Position curPos = CurrentPosition();
2550  	const Sci::Line curLine = pdoc-&gt;SciLineFromPosition(curPos);
2551  	const Sci::Position lineStart = pdoc-&gt;LineStart(curLine);
2552  	const Sci::Position lineEnd = pdoc-&gt;LineEnd(curLine);
2553  	const std::wstring rcFeed = StringDecode(RangeText(lineStart, lineEnd), CodePageOfDocument());
2554  	const int rcFeedLen = static_cast&lt;int&gt;(rcFeed.length()) * sizeof(wchar_t);
2555  	const int rcSize = sizeof(RECONVERTSTRING) + rcFeedLen + sizeof(wchar_t);
2556  	RECONVERTSTRING *rc = static_cast&lt;RECONVERTSTRING *&gt;(PtrFromSPtr(lParam));
2557  	if (!rc)
2558  		return rcSize;
2559  	wchar_t *rcFeedStart = reinterpret_cast&lt;wchar_t*&gt;(rc + 1);
2560  	memcpy(rcFeedStart, &amp;rcFeed[0], rcFeedLen);
2561  	IMContext imc(MainHWND());
2562  	if (!imc.hIMC)
2563  		return 0;
2564  	const size_t compStrLen = imc.GetCompositionString(GCS_COMPSTR).size();
2565  	const int imeCaretPos = imc.GetImeCaretPos();
2566  	const Sci::Position compStart = pdoc-&gt;GetRelativePositionUTF16(curPos, -imeCaretPos);
2567  	const Sci::Position compStrOffset = pdoc-&gt;CountUTF16(lineStart, compStart);
2568  	rc-&gt;dwVersion = 0; 
2569  	rc-&gt;dwStrLen = static_cast&lt;DWORD&gt;(rcFeed.length());
2570  	rc-&gt;dwStrOffset = sizeof(RECONVERTSTRING); 
2571  	rc-&gt;dwCompStrLen = static_cast&lt;DWORD&gt;(compStrLen);
2572  	rc-&gt;dwCompStrOffset = static_cast&lt;DWORD&gt;(compStrOffset) * sizeof(wchar_t);
2573  	rc-&gt;dwTargetStrLen = rc-&gt;dwCompStrLen;
2574  	rc-&gt;dwTargetStrOffset = rc-&gt;dwCompStrOffset;
2575  	return rcSize; 
2576  }
2577  void ScintillaWin::GetIntelliMouseParameters() noexcept {
2578  	::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &amp;linesPerScroll, 0);
2579  	if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &amp;charsPerScroll, 0)) {
2580  		charsPerScroll = (linesPerScroll == WHEEL_PAGESCROLL) ? 3 : linesPerScroll;
2581  	}
2582  }
2583  void ScintillaWin::CopyToGlobal(GlobalMemory &amp;gmUnicode, const SelectionText &amp;selectedText) {
2584  	const std::string_view svSelected(selectedText.Data(), selectedText.LengthWithTerminator());
2585  	if (IsUnicodeMode()) {
2586  		const size_t uchars = UTF16Length(svSelected);
2587  		gmUnicode.Allocate(2 * uchars);
2588  		if (gmUnicode) {
2589  			UTF16FromUTF8(svSelected,
2590  				static_cast&lt;wchar_t *&gt;(gmUnicode.ptr), uchars);
2591  		}
2592  	} else {
2593  		const UINT cpSrc = CodePageFromCharSet(
2594  			selectedText.characterSet, selectedText.codePage);
2595  		const size_t uLen = WideCharLenFromMultiByte(cpSrc, svSelected);
2596  		gmUnicode.Allocate(2 * uLen);
2597  		if (gmUnicode) {
2598  			WideCharFromMultiByte(cpSrc, svSelected,
2599  				static_cast&lt;wchar_t *&gt;(gmUnicode.ptr), uLen);
2600  		}
2601  	}
2602  }
2603  void ScintillaWin::CopyToClipboard(const SelectionText &amp;selectedText) {
2604  	if (!::OpenClipboardRetry(MainHWND())) {
2605  		return;
2606  	}
2607  	::EmptyClipboard();
2608  	GlobalMemory uniText;
2609  	CopyToGlobal(uniText, selectedText);
2610  	if (uniText) {
2611  		uniText.SetClip(CF_UNICODETEXT);
2612  	}
2613  	if (selectedText.rectangular) {
2614  		::SetClipboardData(cfColumnSelect, 0);
2615  		GlobalMemory borlandSelection;
2616  		borlandSelection.Allocate(1);
2617  		if (borlandSelection) {
2618  			static_cast&lt;BYTE *&gt;(borlandSelection.ptr)[0] = 0x02;
2619  			borlandSelection.SetClip(cfBorlandIDEBlockType);
2620  		}
2621  	}
2622  	if (selectedText.lineCopy) {
2623  		::SetClipboardData(cfLineSelect, 0);
2624  		::SetClipboardData(cfVSLineTag, 0);
2625  	}
2626  	::CloseClipboard();
2627  }
2628  void ScintillaWin::ScrollMessage(WPARAM wParam) {
2629  	SCROLLINFO sci = {};
2630  	sci.cbSize = sizeof(sci);
2631  	sci.fMask = SIF_ALL;
2632  	GetScrollInfo(SB_VERT, &amp;sci);
2633  	Sci::Line topLineNew = topLine;
2634  	switch (LOWORD(wParam)) {
2635  	case SB_LINEUP:
2636  		topLineNew -= 1;
2637  		break;
2638  	case SB_LINEDOWN:
2639  		topLineNew += 1;
2640  		break;
2641  	case SB_PAGEUP:
2642  		topLineNew -= LinesToScroll(); break;
2643  	case SB_PAGEDOWN: topLineNew += LinesToScroll(); break;
2644  	case SB_TOP: topLineNew = 0; break;
2645  	case SB_BOTTOM: topLineNew = MaxScrollPos(); break;
2646  	case SB_THUMBPOSITION: topLineNew = sci.nTrackPos; break;
2647  	case SB_THUMBTRACK: topLineNew = sci.nTrackPos; break;
2648  	}
2649  	ScrollTo(topLineNew);
2650  }
2651  void ScintillaWin::HorizontalScrollMessage(WPARAM wParam) {
2652  	int xPos = xOffset;
2653  	const PRectangle rcText = GetTextRectangle();
2654  	const int pageWidth = static_cast&lt;int&gt;(rcText.Width() * 2 / 3);
2655  	switch (LOWORD(wParam)) {
2656  	case SB_LINEUP:
2657  		xPos -= 20;
2658  		break;
2659  	case SB_LINEDOWN:	
2660  		xPos += 20;
2661  		break;
2662  	case SB_PAGEUP:
2663  		xPos -= pageWidth;
2664  		break;
2665  	case SB_PAGEDOWN:
2666  		xPos += pageWidth;
2667  		break;
2668  	case SB_TOP:
2669  		xPos = 0;
2670  		break;
2671  	case SB_BOTTOM:
2672  		xPos = scrollWidth;
2673  		break;
2674  	case SB_THUMBPOSITION:
2675  	case SB_THUMBTRACK: {
2676  			SCROLLINFO si {};
2677  			si.cbSize = sizeof(si);
2678  			si.fMask = SIF_TRACKPOS;
2679  			if (GetScrollInfo(SB_HORZ, &amp;si)) {
2680  				xPos = si.nTrackPos;
2681  			}
2682  		}
2683  		break;
2684  	}
2685  	HorizontalScrollToClamped(xPos);
2686  }
2687  void ScintillaWin::FullPaint() {
2688  	if ((technology == Technology::Default) || (technology == Technology::DirectWriteDC)) {
2689  		HDC hdc = ::GetDC(MainHWND());
2690  		FullPaintDC(hdc);
2691  		::ReleaseDC(MainHWND(), hdc);
2692  	} else {
2693  		FullPaintDC({});
2694  	}
2695  }
2696  void ScintillaWin::FullPaintDC(HDC hdc) {
2697  	paintState = PaintState::painting;
2698  	rcPaint = GetClientRectangle();
2699  	paintingAllText = true;
2700  	PaintDC(hdc);
2701  	paintState = PaintState::notPainting;
2702  }
2703  namespace {
2704  bool CompareDevCap(HDC hdc, HDC hOtherDC, int nIndex) noexcept {
2705  	return ::GetDeviceCaps(hdc, nIndex) == ::GetDeviceCaps(hOtherDC, nIndex);
2706  }
2707  }
2708  bool ScintillaWin::IsCompatibleDC(HDC hOtherDC) noexcept {
2709  	HDC hdc = ::GetDC(MainHWND());
2710  	const bool isCompatible =
2711  		CompareDevCap(hdc, hOtherDC, TECHNOLOGY) &amp;&amp;
2712  		CompareDevCap(hdc, hOtherDC, LOGPIXELSY) &amp;&amp;
2713  		CompareDevCap(hdc, hOtherDC, LOGPIXELSX) &amp;&amp;
2714  		CompareDevCap(hdc, hOtherDC, BITSPIXEL) &amp;&amp;
2715  		CompareDevCap(hdc, hOtherDC, PLANES);
2716  	::ReleaseDC(MainHWND(), hdc);
2717  	return isCompatible;
2718  }
2719  DWORD ScintillaWin::EffectFromState(DWORD grfKeyState) const noexcept {
2720  	DWORD dwEffect;
2721  	if (inDragDrop == DragDrop::dragging)	
2722  		dwEffect = DROPEFFECT_MOVE;
2723  	else
2724  		dwEffect = DROPEFFECT_COPY;
2725  	if (grfKeyState &amp; MK_ALT)
2726  		dwEffect = DROPEFFECT_MOVE;
2727  	if (grfKeyState &amp; MK_CONTROL)
2728  		dwEffect = DROPEFFECT_COPY;
2729  	return dwEffect;
2730  }
2731  STDMETHODIMP ScintillaWin::QueryInterface(REFIID riid, PVOID *ppv) {
2732  	*ppv = nullptr;
2733  	if (riid == IID_IUnknown) {
2734  		*ppv = &amp;dt;
2735  	} else if (riid == IID_IDropSource) {
2736  		*ppv = &amp;ds;
2737  	} else if (riid == IID_IDropTarget) {
2738  		*ppv = &amp;dt;
2739  	} else if (riid == IID_IDataObject) {
2740  		*ppv = &amp;dob;
2741  	}
2742  	if (!*ppv)
2743  		return E_NOINTERFACE;
2744  	return S_OK;
2745  }
2746  STDMETHODIMP_(ULONG) ScintillaWin::AddRef() {
2747  	return 1;
2748  }
2749  STDMETHODIMP_(ULONG) ScintillaWin::Release() {
2750  	return 1;
2751  }
2752  STDMETHODIMP ScintillaWin::DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
2753                                       POINTL, PDWORD pdwEffect) {
2754  	if (!pIDataSource )
2755  		return E_POINTER;
2756  	FORMATETC fmtu = {CF_UNICODETEXT, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
2757  	const HRESULT hrHasUText = pIDataSource-&gt;QueryGetData(&amp;fmtu);
2758  	hasOKText = (hrHasUText == S_OK);
2759  	if (hasOKText) {
2760  		*pdwEffect = EffectFromState(grfKeyState);
2761  	} else {
2762  		*pdwEffect = DROPEFFECT_NONE;
2763  	}
2764  	return S_OK;
2765  }
2766  STDMETHODIMP ScintillaWin::DragOver(DWORD grfKeyState, POINTL pt, PDWORD pdwEffect) {
2767  	try {
2768  		if (!hasOKText || pdoc-&gt;IsReadOnly()) {
2769  			*pdwEffect = DROPEFFECT_NONE;
2770  			return S_OK;
2771  		}
2772  		*pdwEffect = EffectFromState(grfKeyState);
2773  		POINT rpt = {pt.x, pt.y};
2774  		::ScreenToClient(MainHWND(), &amp;rpt);
2775  		SetDragPosition(SPositionFromLocation(PointFromPOINT(rpt), false, false, UserVirtualSpace()));
2776  		return S_OK;
2777  	} catch (...) {
2778  		errorStatus = Status::Failure;
2779  	}
2780  	return E_FAIL;
2781  }
2782  STDMETHODIMP ScintillaWin::DragLeave() {
2783  	try {
2784  		SetDragPosition(SelectionPosition(Sci::invalidPosition));
2785  		return S_OK;
2786  	} catch (...) {
2787  		errorStatus = Status::Failure;
2788  	}
2789  	return E_FAIL;
2790  }
2791  STDMETHODIMP ScintillaWin::Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState,
2792                                  POINTL pt, PDWORD pdwEffect) {
2793  	try {
2794  		*pdwEffect = EffectFromState(grfKeyState);
2795  		if (!pIDataSource)
2796  			return E_POINTER;
2797  		SetDragPosition(SelectionPosition(Sci::invalidPosition));
2798  		std::string putf;
2799  		FORMATETC fmtu = {CF_UNICODETEXT, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
2800  		STGMEDIUM medium{};
2801  		const HRESULT hr = pIDataSource-&gt;GetData(&amp;fmtu, &amp;medium);
2802  		if (!SUCCEEDED(hr)) {
2803  			return hr;
2804  		}
2805  		if (medium.hGlobal) {
2806  			GlobalMemory memUDrop(medium.hGlobal);
2807  			if (const wchar_t *uptr = static_cast&lt;const wchar_t *&gt;(memUDrop.ptr)) {
2808  				putf = EncodeWString(uptr);
2809  			}
2810  			memUDrop.Unlock();
2811  		}
2812  		if (putf.empty()) {
2813  			return S_OK;
2814  		}
2815  		FORMATETC fmtr = {cfColumnSelect, nullptr, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
2816  		const bool isRectangular = S_OK == pIDataSource-&gt;QueryGetData(&amp;fmtr);
2817  		POINT rpt = {pt.x, pt.y};
2818  		::ScreenToClient(MainHWND(), &amp;rpt);
2819  		const SelectionPosition movePos = SPositionFromLocation(PointFromPOINT(rpt), false, false, UserVirtualSpace());
2820  		DropAt(movePos, putf.c_str(), putf.size(), *pdwEffect == DROPEFFECT_MOVE, isRectangular);
2821  		::ReleaseStgMedium(&amp;medium);
2822  		return S_OK;
2823  	} catch (...) {
2824  		errorStatus = Status::Failure;
2825  	}
2826  	return E_FAIL;
2827  }
2828  STDMETHODIMP ScintillaWin::GetData(FORMATETC *pFEIn, STGMEDIUM *pSTM) {
2829  	if (!SupportedFormat(pFEIn)) {
2830  		return DATA_E_FORMATETC;
2831  	}
2832  	pSTM-&gt;tymed = TYMED_HGLOBAL;
2833  	GlobalMemory uniText;
2834  	CopyToGlobal(uniText, drag);
2835  	pSTM-&gt;hGlobal = uniText ? uniText.Unlock() : 0;
2836  	pSTM-&gt;pUnkForRelease = nullptr;
2837  	return S_OK;
2838  }
2839  void ScintillaWin::Prepare() noexcept {
2840  	Platform_Initialise(hInstance);
2841  	WNDCLASSEX wndclassc{};
2842  	wndclassc.cbSize = sizeof(wndclassc);
2843  	wndclassc.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
2844  	wndclassc.cbWndExtra = sizeof(ScintillaWin *);
2845  	wndclassc.hInstance = hInstance;
2846  	wndclassc.lpfnWndProc = ScintillaWin::CTWndProc;
2847  	wndclassc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
2848  	wndclassc.lpszClassName = callClassName;
2849  	callClassAtom = ::RegisterClassEx(&amp;wndclassc);
2850  }
2851  bool ScintillaWin::Register(HINSTANCE hInstance_) noexcept {
2852  	hInstance = hInstance_;
2853  	WNDCLASSEXW wndclass {};
2854  	wndclass.cbSize = sizeof(wndclass);
2855  	wndclass.style = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
2856  	wndclass.lpfnWndProc = ScintillaWin::SWndProc;
2857  	wndclass.cbWndExtra = sizeof(ScintillaWin *);
2858  	wndclass.hInstance = hInstance;
2859  	wndclass.lpszClassName = L&quot;Scintilla&quot;;
2860  	scintillaClassAtom = ::RegisterClassExW(&amp;wndclass);
2861  	const bool result = 0 != scintillaClassAtom;
2862  	return result;
2863  }
2864  bool ScintillaWin::Unregister() noexcept {
2865  	bool result = true;
2866  	if (0 != scintillaClassAtom) {
2867  		if (::UnregisterClass(MAKEINTATOM(scintillaClassAtom), hInstance) == 0) {
2868  			result = false;
2869  		}
2870  		scintillaClassAtom = 0;
2871  	}
2872  	if (0 != callClassAtom) {
2873  		if (::UnregisterClass(MAKEINTATOM(callClassAtom), hInstance) == 0) {
2874  			result = false;
2875  		}
2876  		callClassAtom = 0;
2877  	}
2878  	return result;
2879  }
2880  bool ScintillaWin::HasCaretSizeChanged() const noexcept {
2881  	if (
2882  		( (0 != vs.caret.width) &amp;&amp; (sysCaretWidth != vs.caret.width) )
2883  		|| ((0 != vs.lineHeight) &amp;&amp; (sysCaretHeight != vs.lineHeight))
2884  		) {
2885  		return true;
2886  	}
2887  	return false;
2888  }
2889  BOOL ScintillaWin::CreateSystemCaret() {
2890  	sysCaretWidth = vs.caret.width;
2891  	if (0 == sysCaretWidth) {
2892  		sysCaretWidth = 1;
2893  	}
2894  	sysCaretHeight = vs.lineHeight;
2895  	const int bitmapSize = (((sysCaretWidth + 15) &amp; ~15) &gt;&gt; 3) *
2896  		sysCaretHeight;
2897  	std::vector&lt;BYTE&gt; bits(bitmapSize);
2898  	sysCaretBitmap = ::CreateBitmap(sysCaretWidth, sysCaretHeight, 1,
2899  		1, &amp;bits[0]);
2900  	const BOOL retval = ::CreateCaret(
2901  		MainHWND(), sysCaretBitmap,
2902  		sysCaretWidth, sysCaretHeight);
2903  	if (technology == Technology::Default) {
2904  		::ShowCaret(MainHWND());
2905  	}
2906  	return retval;
2907  }
2908  BOOL ScintillaWin::DestroySystemCaret() noexcept {
2909  	::HideCaret(MainHWND());
2910  	const BOOL retval = ::DestroyCaret();
2911  	if (sysCaretBitmap) {
2912  		::DeleteObject(sysCaretBitmap);
2913  		sysCaretBitmap = {};
2914  	}
2915  	return retval;
2916  }
2917  LRESULT PASCAL ScintillaWin::CTWndProc(
2918  	HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
2919  	ScintillaWin *sciThis = static_cast&lt;ScintillaWin *&gt;(PointerFromWindow(hWnd));
2920  	try {
2921  		if (sciThis == nullptr) {
2922  			if (iMessage == WM_CREATE) {
2923  				CREATESTRUCT *pCreate = static_cast&lt;CREATESTRUCT *&gt;(PtrFromSPtr(lParam));
2924  				SetWindowPointer(hWnd, pCreate-&gt;lpCreateParams);
2925  				return 0;
2926  			} else {
2927  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
2928  			}
2929  		} else {
2930  			if (iMessage == WM_NCDESTROY) {
2931  				SetWindowPointer(hWnd, nullptr);
2932  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
2933  			} else if (iMessage == WM_PAINT) {
2934  				PAINTSTRUCT ps;
2935  				::BeginPaint(hWnd, &amp;ps);
2936  				std::unique_ptr&lt;Surface&gt; surfaceWindow(Surface::Allocate(sciThis-&gt;technology));
2937  #if defined(USE_D2D)
2938  				ID2D1HwndRenderTarget *pCTRenderTarget = nullptr;
2939  #endif
2940  				RECT rc;
2941  				GetClientRect(hWnd, &amp;rc);
2942  				if (sciThis-&gt;technology == Technology::Default) {
2943  					surfaceWindow-&gt;Init(ps.hdc, hWnd);
2944  				} else {
2945  #if defined(USE_D2D)
2946  					const int scaleFactor = sciThis-&gt;deviceScaleFactor;
2947  					D2D1_HWND_RENDER_TARGET_PROPERTIES dhrtp {};
2948  					dhrtp.hwnd = hWnd;
2949  					dhrtp.pixelSize = ::GetSizeUFromRect(rc, scaleFactor);
2950  					dhrtp.presentOptions = (sciThis-&gt;technology == Technology::DirectWriteRetain) ?
2951  						D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS : D2D1_PRESENT_OPTIONS_NONE;
2952  					D2D1_RENDER_TARGET_PROPERTIES drtp {};
2953  					drtp.type = D2D1_RENDER_TARGET_TYPE_DEFAULT;
2954  					drtp.pixelFormat.format = DXGI_FORMAT_UNKNOWN;
2955  					drtp.pixelFormat.alphaMode = D2D1_ALPHA_MODE_UNKNOWN;
2956  					drtp.dpiX = 96.f * scaleFactor;
2957  					drtp.dpiY = 96.f * scaleFactor;
2958  					drtp.usage = D2D1_RENDER_TARGET_USAGE_NONE;
2959  					drtp.minLevel = D2D1_FEATURE_LEVEL_DEFAULT;
2960  					if (!SUCCEEDED(pD2DFactory-&gt;CreateHwndRenderTarget(drtp, dhrtp, &amp;pCTRenderTarget))) {
2961  						surfaceWindow-&gt;Release();
2962  						::EndPaint(hWnd, &amp;ps);
2963  						return 0;
2964  					}
2965  					assert(pCTRenderTarget);
2966  					if (pCTRenderTarget) {
2967  						surfaceWindow-&gt;Init(pCTRenderTarget, hWnd);
2968  						pCTRenderTarget-&gt;BeginDraw();
2969  					}
2970  #endif
2971  				}
2972  				surfaceWindow-&gt;SetMode(sciThis-&gt;CurrentSurfaceMode());
2973  				sciThis-&gt;SetRenderingParams(surfaceWindow.get());
2974  				sciThis-&gt;ct.PaintCT(surfaceWindow.get());
2975  #if defined(USE_D2D)
2976  				if (pCTRenderTarget)
2977  					pCTRenderTarget-&gt;EndDraw();
2978  #endif
2979  				surfaceWindow-&gt;Release();
2980  #if defined(USE_D2D)
2981  				ReleaseUnknown(pCTRenderTarget);
2982  #endif
2983  				::EndPaint(hWnd, &amp;ps);
2984  				return 0;
2985  			} else if ((iMessage == WM_NCLBUTTONDOWN) || (iMessage == WM_NCLBUTTONDBLCLK)) {
2986  				POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
2987  				ScreenToClient(hWnd, &amp;pt);
2988  				sciThis-&gt;ct.MouseClick(PointFromPOINT(pt));
2989  				sciThis-&gt;CallTipClick();
2990  				return 0;
2991  			} else if (iMessage == WM_LBUTTONDOWN) {
2992  				sciThis-&gt;ct.MouseClick(PointFromLParam(lParam));
2993  				sciThis-&gt;CallTipClick();
2994  				return 0;
2995  			} else if (iMessage == WM_SETCURSOR) {
2996  				::SetCursor(::LoadCursor(NULL, IDC_ARROW));
2997  				return 0;
2998  			} else if (iMessage == WM_NCHITTEST) {
2999  				return HTCAPTION;
3000  			} else {
3001  				return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3002  			}
3003  		}
3004  	} catch (...) {
3005  		sciThis-&gt;errorStatus = Status::Failure;
3006  	}
3007  	return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3008  }
3009  sptr_t ScintillaWin::DirectFunction(
3010      sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam) {
3011  	ScintillaWin *sci = reinterpret_cast&lt;ScintillaWin *&gt;(ptr);
3012  	PLATFORM_ASSERT(::GetCurrentThreadId() == ::GetWindowThreadProcessId(sci-&gt;MainHWND(), nullptr));
3013  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3014  }
3015  sptr_t ScintillaWin::DirectStatusFunction(
3016      sptr_t ptr, UINT iMessage, uptr_t wParam, sptr_t lParam, int *pStatus) {
3017  	ScintillaWin *sci = reinterpret_cast&lt;ScintillaWin *&gt;(ptr);
3018  	PLATFORM_ASSERT(::GetCurrentThreadId() == ::GetWindowThreadProcessId(sci-&gt;MainHWND(), nullptr));
3019  	const sptr_t returnValue = sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3020  	*pStatus = static_cast&lt;int&gt;(sci-&gt;errorStatus);
3021  	return returnValue;
3022  }
3023  namespace Scintilla::Internal {
3024  sptr_t DirectFunction(
3025      ScintillaWin *sci, UINT iMessage, uptr_t wParam, sptr_t lParam) {
3026  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3027  }
3028  }
3029  LRESULT PASCAL ScintillaWin::SWndProc(
3030  	HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam) {
3031  	ScintillaWin *sci = static_cast&lt;ScintillaWin *&gt;(PointerFromWindow(hWnd));
3032  	if (sci == nullptr) {
3033  		try {
3034  			if (iMessage == WM_CREATE) {
3035  				static std::once_flag once;
3036  				std::call_once(once, Prepare);
3037  				sci = new ScintillaWin(hWnd);
3038  				SetWindowPointer(hWnd, sci);
3039  				return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3040  			}
3041  		} catch (...) {
3042  		}
3043  		return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3044  	} else {
3045  		if (iMessage == WM_NCDESTROY) {
3046  			try {
3047  				sci-&gt;Finalise();
3048  				delete sci;
3049  			} catch (...) {
3050  			}
3051  			SetWindowPointer(hWnd, nullptr);
3052  			return ::DefWindowProc(hWnd, iMessage, wParam, lParam);
3053  		} else {
3054  			return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
3055  		}
3056  	}
3057  }
3058  extern &quot;C&quot; int Scintilla_RegisterClasses(void *hInstance) {
3059  	const bool result = ScintillaWin::Register(static_cast&lt;HINSTANCE&gt;(hInstance));
3060  	return result;
3061  }
3062  namespace Scintilla::Internal {
3063  int ResourcesRelease(bool fromDllMain) noexcept {
3064  	const bool result = ScintillaWin::Unregister();
3065  	Platform_Finalise(fromDllMain);
3066  	return result;
3067  }
3068  int RegisterClasses(void *hInstance) noexcept {
3069  	const bool result = ScintillaWin::Register(static_cast&lt;HINSTANCE&gt;(hInstance));
3070  	return result;
3071  }
3072  }
3073  extern &quot;C&quot; int Scintilla_ReleaseResources() {
3074  	return Scintilla::Internal::ResourcesRelease(false);
3075  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaWin.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaWin.cxx</div>
                </div>
                <div class="column column_space"><pre><code>409  	sptr_t IdleMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
410  	sptr_t SciMessage(Message iMessage, uptr_t wParam, sptr_t lParam);
</pre></code></div>
                <div class="column column_space"><pre><code>404  	sptr_t MouseMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
405  	sptr_t KeyMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    