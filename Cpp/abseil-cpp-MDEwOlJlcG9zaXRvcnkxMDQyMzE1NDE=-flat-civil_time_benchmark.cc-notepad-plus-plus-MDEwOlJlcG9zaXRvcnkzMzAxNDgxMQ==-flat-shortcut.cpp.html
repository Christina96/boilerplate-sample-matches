
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.28198859005705%, Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_benchmark.cc</h3>
            <pre><code>1  #include "absl/time/civil_time.h"
2  #include <numeric>
3  #include <vector>
4  #include "absl/hash/hash.h"
5  #include "benchmark/benchmark.h"
6  namespace {
7  void BM_Difference_Days(benchmark::State& state) {
8    const absl::CivilDay c(2014, 8, 22);
9    const absl::CivilDay epoch(1970, 1, 1);
10    while (state.KeepRunning()) {
11      const absl::civil_diff_t n = c - epoch;
12      benchmark::DoNotOptimize(n);
13    }
14  }
15  BENCHMARK(BM_Difference_Days);
16  void BM_Step_Days(benchmark::State& state) {
17    const absl::CivilDay kStart(2014, 8, 22);
18    absl::CivilDay c = kStart;
19    while (state.KeepRunning()) {
20      benchmark::DoNotOptimize(++c);
21    }
22  }
23  BENCHMARK(BM_Step_Days);
24  void BM_Format(benchmark::State& state) {
25    const absl::CivilSecond c(2014, 1, 2, 3, 4, 5);
26    while (state.KeepRunning()) {
27      const std::string s = absl::FormatCivilTime(c);
28      benchmark::DoNotOptimize(s);
29    }
30  }
31  BENCHMARK(BM_Format);
32  void BM_Parse(benchmark::State& state) {
33    const std::string f = "2014-01-02T03:04:05";
34    absl::CivilSecond c;
35    while (state.KeepRunning()) {
36      const bool b = absl::ParseCivilTime(f, &c);
37      benchmark::DoNotOptimize(b);
38    }
39  }
40  BENCHMARK(BM_Parse);
41  void BM_RoundTripFormatParse(benchmark::State& state) {
42    const absl::CivilSecond c(2014, 1, 2, 3, 4, 5);
43    absl::CivilSecond out;
44    while (state.KeepRunning()) {
45      const bool b = absl::ParseCivilTime(absl::FormatCivilTime(c), &out);
46      benchmark::DoNotOptimize(b);
47    }
48  }
49  BENCHMARK(BM_RoundTripFormatParse);
50  template <typename T>
51  void BM_CivilTimeAbslHash(benchmark::State& state) {
52    const int kSize = 100000;
53    std::vector<T> civil_times(kSize);
54    std::iota(civil_times.begin(), civil_times.end(), T(2018));
55    absl::Hash<T> absl_hasher;
56    while (state.KeepRunningBatch(kSize)) {
57      for (const T civil_time : civil_times) {
58        benchmark::DoNotOptimize(absl_hasher(civil_time));
59      }
60    }
<span onclick='openModal()' class='match'>61  }
62  void BM_CivilYearAbslHash(benchmark::State& state) {
63    BM_CivilTimeAbslHash<absl::CivilYear>(state);
64  }
65  void BM_CivilMonthAbslHash(benchmark::State& state) {
66    BM_CivilTimeAbslHash<absl::CivilMonth>(state);
67  }
68  void BM_CivilDayAbslHash(benchmark::State& state) {
69    BM_CivilTimeAbslHash<absl::CivilDay>(state);
70  }
71  void BM_CivilHourAbslHash(benchmark::State& state) {
72    BM_CivilTimeAbslHash<absl::CivilHour>(state);
73  }
74  void BM_CivilMinuteAbslHash(benchmark::State& state) {
75    BM_CivilTimeAbslHash<absl::CivilMinute>(state);
76  }
77  void BM_CivilSecondAbslHash(benchmark::State& state) {
78    BM_CivilTimeAbslHash<absl::CivilSecond>(state);
79  }
80  BENCHMARK(BM_CivilYearAbslHash);
81  BENCHMARK(BM_CivilMonthAbslHash);
82  BENCHMARK(BM_CivilDayAbslHash);
83  BENCHMARK(BM_CivilHourAbslHash);
84  BENCHMARK(BM_CivilMinuteAbslHash);
85  BENCHMARK(BM_CivilSecondAbslHash);
86  }  
</span></code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-shortcut.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <algorithm>
3  #include <array>
4  #include "shortcut.h"
5  #include "Parameters.h"
6  #include "ScintillaEditView.h"
7  #include "resource.h"
8  #include "Notepad_plus_Window.h"
9  #include "keys.h"
10  using namespace std;
11  struct KeyIDNAME {
12  	const char * name = nullptr;
13  	UCHAR id = 0;
14  };
15  KeyIDNAME namedKeyArray[] = {
16  {"None", VK_NULL},
17  {"Backspace", VK_BACK},
18  {"Tab", VK_TAB},
19  {"Enter", VK_RETURN},
20  {"Esc", VK_ESCAPE},
21  {"Spacebar", VK_SPACE},
22  {"Page up", VK_PRIOR},
23  {"Page down", VK_NEXT},
24  {"End", VK_END},
25  {"Home", VK_HOME},
26  {"Left", VK_LEFT},
27  {"Up", VK_UP},
28  {"Right", VK_RIGHT},
29  {"Down", VK_DOWN},
30  {"INS", VK_INSERT},
31  {"DEL", VK_DELETE},
32  {"0", VK_0},
33  {"1", VK_1},
34  {"2", VK_2},
35  {"3", VK_3},
36  {"4", VK_4},
37  {"5", VK_5},
38  {"6", VK_6},
39  {"7", VK_7},
40  {"8", VK_8},
41  {"9", VK_9},
42  {"A", VK_A},
43  {"B", VK_B},
44  {"C", VK_C},
45  {"D", VK_D},
46  {"E", VK_E},
47  {"F", VK_F},
48  {"G", VK_G},
49  {"H", VK_H},
50  {"I", VK_I},
51  {"J", VK_J},
52  {"K", VK_K},
53  {"L", VK_L},
54  {"M", VK_M},
55  {"N", VK_N},
56  {"O", VK_O},
57  {"P", VK_P},
58  {"Q", VK_Q},
59  {"R", VK_R},
60  {"S", VK_S},
61  {"T", VK_T},
62  {"U", VK_U},
63  {"V", VK_V},
64  {"W", VK_W},
65  {"X", VK_X},
66  {"Y", VK_Y},
67  {"Z", VK_Z},
68  {"Numpad 0", VK_NUMPAD0},
69  {"Numpad 1", VK_NUMPAD1},
70  {"Numpad 2", VK_NUMPAD2},
71  {"Numpad 3", VK_NUMPAD3},
72  {"Numpad 4", VK_NUMPAD4},
73  {"Numpad 5", VK_NUMPAD5},
74  {"Numpad 6", VK_NUMPAD6},
75  {"Numpad 7", VK_NUMPAD7},
76  {"Numpad 8", VK_NUMPAD8},
77  {"Numpad 9", VK_NUMPAD9},
78  {"Num *", VK_MULTIPLY},
79  {"Num +", VK_ADD},
80  {"Num -", VK_SUBTRACT},
81  {"Num .", VK_DECIMAL},
82  {"Num /", VK_DIVIDE},
83  {"F1", VK_F1},
84  {"F2", VK_F2},
85  {"F3", VK_F3},
86  {"F4", VK_F4},
87  {"F5", VK_F5},
88  {"F6", VK_F6},
89  {"F7", VK_F7},
90  {"F8", VK_F8},
91  {"F9", VK_F9},
92  {"F10", VK_F10},
93  {"F11", VK_F11},
94  {"F12", VK_F12},
95  {"~", VK_OEM_3},
96  {"-", VK_OEM_MINUS},
97  {"=", VK_OEM_PLUS},
98  {"[", VK_OEM_4},
99  {"]", VK_OEM_6},
<span onclick='openModal()' class='match'>100  {";", VK_OEM_1},
101  {"'", VK_OEM_7},
102  {"\\", VK_OEM_5},
103  {",", VK_OEM_COMMA},
104  {".", VK_OEM_PERIOD},
105  {"/", VK_OEM_2},
106  {"<>", VK_OEM_102},
107  };
</span>108  #define nbKeys sizeof(namedKeyArray)/sizeof(KeyIDNAME)
109  string Shortcut::toString() const
110  {
111  	string sc;
112  	if (!isEnabled())
113  		return sc;
114  	if (_keyCombo._isCtrl)
115  		sc += "Ctrl+";
116  	if (_keyCombo._isAlt)
117  		sc += "Alt+";
118  	if (_keyCombo._isShift)
119  		sc += "Shift+";
120  	string keyString;
121  	getKeyStrFromVal(_keyCombo._key, keyString);
122  	sc += keyString;
123  	return sc;
124  }
125  void Shortcut::setName(const char* menuName, const char* shortcutName)
126  {
127  	lstrcpynA(_menuName, menuName, menuItemStrLenMax);
128  	char const * name = shortcutName ? shortcutName : menuName;
129  	size_t i = 0, j = 0;
130  	while (name[j] != 0 && i < (menuItemStrLenMax - 1))
131  	{
132  		if (name[j] != '&')
133  		{
134  			_name[i] = name[j];
135  			++i;
136  		}
137  		else 
138  		{
139  			if (name[j+1] == '&') 
140  			{
141  				_name[i] = name[j];
142  				++i;
143  				++j;	
144  			}
145  		}
146  		++j;
147  	}
148  	_name[i] = 0;
149  }
150  string ScintillaKeyMap::toString() const
151  {
152  	string sc;
153  	size_t nbCombos = getSize();
154  	for (size_t combo = 0; combo < nbCombos; ++combo)
155  	{
156  		sc += toString(combo);
157  		if (combo < nbCombos - 1)
158  			sc += " or ";
159  	}
160  	return sc;
161  }
162  string ScintillaKeyMap::toString(size_t index) const
163  {
164  	string sc = "";
165  	if (!isEnabled())
166  		return sc;
167  	KeyCombo kc = _keyCombos[index];
168  	if (kc._isCtrl)
169  		sc += "Ctrl+";
170  	if (kc._isAlt)
171  		sc += "Alt+";
172  	if (kc._isShift)
173  		sc += "Shift+";
174  	string keyString;
175  	getKeyStrFromVal(kc._key, keyString);
176  	sc += keyString;
177  	return sc;
178  }
179  KeyCombo ScintillaKeyMap::getKeyComboByIndex(size_t index) const
180  {
181  	return _keyCombos[index];
182  }
183  void ScintillaKeyMap::setKeyComboByIndex(int index, KeyCombo combo)
184  {
185  	if (combo._key == 0 && (_size > 1))
186  	{	
187  		_keyCombos.erase(_keyCombos.begin() + index);
188  	}
189  	_keyCombos[index] = combo;
190  }
191  void ScintillaKeyMap::removeKeyComboByIndex(size_t index)
192  {
193  	if (_size > 1 && index < _size)
194  	{
195  		_keyCombos.erase(_keyCombos.begin() + index);
196  		_size--;
197  	}
198  }
199  int ScintillaKeyMap::addKeyCombo(KeyCombo combo)
200  {	
201  	if (combo._key == 0)	
202  		return -1;
203  	if (!isEnabled())
204  	{	
205  		_keyCombos[0] = combo;
206  		return 0;
207  	}
208  	for (size_t i = 0; i < _size; ++i)
209  	{	
210  		KeyCombo & kc = _keyCombos[i];
211  		if (combo._key == kc._key && combo._isCtrl == kc._isCtrl && combo._isAlt == kc._isAlt && combo._isShift == kc._isShift)
212  			return static_cast<int32_t>(i);	
213  	}
214  	_keyCombos.push_back(combo);
215  	++_size;
216  	return static_cast<int32_t>(_size - 1);
217  }
218  bool ScintillaKeyMap::isEnabled() const
219  {
220  	return (_keyCombos[0]._key != 0);
221  }
222  size_t ScintillaKeyMap::getSize() const
223  {
224  	return _size;
225  }
226  void getKeyStrFromVal(UCHAR keyVal, string & str)
227  {
228  	str = "";
229  	bool found = false;
230  	size_t i;
231  	for (i = 0; i < nbKeys; ++i)
232  	{
233  		if (keyVal == namedKeyArray[i].id)
234  		{
235  			found = true;
236  			break;
237  		}
238  	}
239  	if (found)
240  		str = namedKeyArray[i].name;
241  	else 
242  		str = "Unlisted";
243  }
244  void getNameStrFromCmd(DWORD cmd, wstring & str)
245  {
246  	if ((cmd >= ID_MACRO) && (cmd < ID_MACRO_LIMIT))
247  	{
248  		vector<MacroShortcut> & theMacros = (NppParameters::getInstance()).getMacroList();
249  		int i = cmd - ID_MACRO;
250  		str = string2wstring(theMacros[i].getName(), CP_UTF8);
251  	}
252  	else if ((cmd >= ID_USER_CMD) && (cmd < ID_USER_CMD_LIMIT))
253  	{
254  		vector<UserCommand> & userCommands = (NppParameters::getInstance()).getUserCommandList();
255  		int i = cmd - ID_USER_CMD;
256  		str = string2wstring(userCommands[i].getName(), CP_UTF8);
257  	}
258  	else if ((cmd >= ID_PLUGINS_CMD) && (cmd < ID_PLUGINS_CMD_LIMIT))
259  	{
260  		vector<PluginCmdShortcut> & pluginCmds = (NppParameters::getInstance()).getPluginCommandList();
261  		size_t i = 0;
262  		for (size_t j = 0, len = pluginCmds.size(); j < len ; ++j)
263  		{
264  			if (pluginCmds[j].getID() == cmd)
265  			{
266  				i = j;
267  				break;
268  			}
269  		}
270  		str = string2wstring(pluginCmds[i].getName(), CP_UTF8);
271  	}
272  	else
273  	{
274  		HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
275  		TCHAR cmdName[menuItemStrLenMax];
276  		HMENU m = reinterpret_cast<HMENU>(::SendMessage(hNotepad_plus, NPPM_INTERNAL_GETMENU, 0, 0));
277  		int nbChar = ::GetMenuString(m, cmd, cmdName, menuItemStrLenMax, MF_BYCOMMAND);
278  		if (!nbChar)
279  			return;
280  		bool fin = false;
281  		int j = 0;
282  		size_t len = lstrlen(cmdName);
283  		for (size_t i = 0 ; i < len; ++i)
284  		{
285  			switch(cmdName[i])
286  			{
287  				case '\t':
288  					cmdName[j] = '\0';
289  					fin = true;
290  					break;
291  				case '&':
292  					break;
293  				default :
294  					cmdName[j++] = cmdName[i];
295  			}
296  			if (fin)
297  				break;
298  		}
299  		cmdName[j] = '\0';
300  		str = cmdName;
301  	}
302  	return;
303  }
304  void Shortcut::updateConflictState(const bool endSession) const
305  {
306  	if (endSession)
307  	{
308  		::SendMessage(_hParent, NPPM_INTERNAL_FINDKEYCONFLICTS, 0, 0);
309  		return;
310  	}
311  	bool isConflict = false;
312  	::SendMessage(_hParent, NPPM_INTERNAL_FINDKEYCONFLICTS,
313  				  reinterpret_cast<WPARAM>(&_keyCombo), reinterpret_cast<LPARAM>(&isConflict));
314  	::ShowWindow(::GetDlgItem(_hSelf, IDC_CONFLICT_STATIC), isConflict ? SW_SHOW : SW_HIDE);
315  }
316  intptr_t CALLBACK Shortcut::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam) 
317  {
318  	switch (Message)
319  	{
320  		case WM_INITDIALOG :
321  		{
322  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
323  			::SetDlgItemText(_hSelf, IDC_NAME_EDIT, _canModifyName ? string2wstring(getMenuName(), CP_UTF8).c_str() : string2wstring(getName(), CP_UTF8).c_str());	
324  			if (!_canModifyName)
325  				::SendDlgItemMessage(_hSelf, IDC_NAME_EDIT, EM_SETREADONLY, TRUE, 0);
326  			auto textlen = ::SendDlgItemMessage(_hSelf, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
327  			::SendDlgItemMessage(_hSelf, IDC_CTRL_CHECK, BM_SETCHECK, _keyCombo._isCtrl?BST_CHECKED:BST_UNCHECKED, 0);
328  			::SendDlgItemMessage(_hSelf, IDC_ALT_CHECK, BM_SETCHECK, _keyCombo._isAlt?BST_CHECKED:BST_UNCHECKED, 0);
329  			::SendDlgItemMessage(_hSelf, IDC_SHIFT_CHECK, BM_SETCHECK, _keyCombo._isShift?BST_CHECKED:BST_UNCHECKED, 0);
330  			::EnableWindow(::GetDlgItem(_hSelf, IDOK), isValid() && (textlen > 0 || !_canModifyName));
331  			int iFound = -1;
332  			for (size_t i = 0 ; i < nbKeys ; ++i)
333  			{
334  				::SendDlgItemMessage(_hSelf, IDC_KEY_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(string2wstring(namedKeyArray[i].name, CP_UTF8).c_str()));
335  				if (_keyCombo._key == namedKeyArray[i].id)
336  					iFound = static_cast<int32_t>(i);
337  			}
338  			if (iFound != -1)
339  				::SendDlgItemMessage(_hSelf, IDC_KEY_COMBO, CB_SETCURSEL, iFound, 0);
340  			::ShowWindow(::GetDlgItem(_hSelf, IDC_WARNING_STATIC), SW_HIDE);
341  			updateConflictState();
342  			NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
343  			nativeLangSpeaker->changeDlgLang(_hSelf, "ShortcutMapperSubDialg");
344  			goToCenter();
345  			return TRUE;
346  		}
347  		case WM_CTLCOLOREDIT:
348  		{
349  			if (NppDarkMode::isEnabled())
350  			{
351  				return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
352  			}
353  			break;
354  		}
355  		case WM_CTLCOLORLISTBOX:
356  		{
357  			if (NppDarkMode::isEnabled())
358  			{
359  				return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
360  			}
361  			break;
362  		}
363  		case WM_CTLCOLORDLG:
364  		case WM_CTLCOLORSTATIC:
365  		{
366  			if (NppDarkMode::isEnabled())
367  			{
368  				auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
369  				if (dlgCtrlID == IDC_NAME_EDIT)
370  				{
371  					return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
372  				}
373  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
374  			}
375  			break;
376  		}
377  		case WM_PRINTCLIENT:
378  		{
379  			if (NppDarkMode::isEnabled())
380  			{
381  				return TRUE;
382  			}
383  			break;
384  		}
385  		case NPPM_INTERNAL_REFRESHDARKMODE:
386  		{
387  			NppDarkMode::autoThemeChildControls(_hSelf);
388  			return TRUE;
389  		}
390  		case WM_COMMAND : 
391  		{
392  			auto textlen = ::SendDlgItemMessage(_hSelf, IDC_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
393  			switch (wParam)
394  			{
395  				case IDC_CTRL_CHECK :
396  					_keyCombo._isCtrl = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
397  					::EnableWindow(::GetDlgItem(_hSelf, IDOK), isValid() && (textlen > 0 || !_canModifyName));
398  					updateConflictState();
399  					return TRUE;
400  				case IDC_ALT_CHECK :
401  					_keyCombo._isAlt = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
402  					::EnableWindow(::GetDlgItem(_hSelf, IDOK), isValid() && (textlen > 0 || !_canModifyName));
403  					updateConflictState();
404  					return TRUE;
405  				case IDC_SHIFT_CHECK :
406  					_keyCombo._isShift = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
407  					updateConflictState();
408  					return TRUE;
409  				case IDOK :
410  					if (!isEnabled())
411  					{
412  						_keyCombo._isCtrl = _keyCombo._isAlt = _keyCombo._isShift = false;
413  					}
414  					if (_canModifyName)
415  					{
416  						TCHAR editName[menuItemStrLenMax]{};
417  						::SendDlgItemMessage(_hSelf, IDC_NAME_EDIT, WM_GETTEXT, menuItemStrLenMax, reinterpret_cast<LPARAM>(editName));
418  						setName(wstring2string(editName, CP_UTF8).c_str());
419  					}
420  					::EndDialog(_hSelf, 0);
421  					updateConflictState(true);
422  					return TRUE;
423  				case IDCANCEL :
424  					::EndDialog(_hSelf, -1);
425  					updateConflictState(true);
426  					return TRUE;
427  				default:
428  					if (HIWORD(wParam) == EN_CHANGE)
429  					{
430  						if (LOWORD(wParam) == IDC_NAME_EDIT)
431  						{
432  							::EnableWindow(::GetDlgItem(_hSelf, IDOK), isValid() && (textlen > 0 || !_canModifyName));
433  							return TRUE;
434  						}
435  					}
436  					else if (HIWORD(wParam) == CBN_SELCHANGE)
437  					{
438  						if (LOWORD(wParam) == IDC_KEY_COMBO)
439  						{
440  							auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETCURSEL, 0, 0);
441  							_keyCombo._key = namedKeyArray[i].id;
442  							::EnableWindow(::GetDlgItem(_hSelf, IDOK), isValid() && (textlen > 0 || !_canModifyName));
443  							::ShowWindow(::GetDlgItem(_hSelf, IDC_WARNING_STATIC), isEnabled()?SW_HIDE:SW_SHOW);
444  							updateConflictState();
445  							return TRUE;
446  						}
447  					}
448  					return FALSE;
449  			}
450  		}
451  		default :
452  			return FALSE;
453  	}
454  	return FALSE;
455  }
456  void Accelerator::updateShortcuts() 
457  {
458  	const array<unsigned long, 3> incrFindAccIds = { IDM_SEARCH_FINDNEXT, IDM_SEARCH_FINDPREV, IDM_SEARCH_FINDINCREMENT };
459  	NppParameters& nppParam = NppParameters::getInstance();
460  	vector<CommandShortcut> & shortcuts = nppParam.getUserShortcuts();
461  	vector<MacroShortcut> & macros  = nppParam.getMacroList();
462  	vector<UserCommand> & userCommands = nppParam.getUserCommandList();
463  	vector<PluginCmdShortcut> & pluginCommands = nppParam.getPluginCommandList();
464  	size_t nbMenu = shortcuts.size();
465  	size_t nbMacro = macros.size();
466  	size_t nbUserCmd = userCommands.size();
467  	size_t nbPluginCmd = pluginCommands.size();
468  	delete [] _pAccelArray;
469  	_pAccelArray = new ACCEL[nbMenu + nbMacro + nbUserCmd + nbPluginCmd];
470  	vector<ACCEL> incrFindAcc;
471  	vector<ACCEL> findReplaceAcc;
472  	int offset = 0;
473  	size_t i = 0;
474  	for (i = 0; i < nbMenu; ++i)
475  	{
476  		if (shortcuts[i].isEnabled())
477  		{
478  			_pAccelArray[offset].cmd = static_cast<WORD>(shortcuts[i].getID());
479  			_pAccelArray[offset].fVirt = shortcuts[i].getAcceleratorModifiers();
480  			_pAccelArray[offset].key = shortcuts[i].getKeyCombo()._key;
481  			if (std::find(incrFindAccIds.begin(), incrFindAccIds.end(), shortcuts[i].getID()) != incrFindAccIds.end())
482  				incrFindAcc.push_back(_pAccelArray[offset]);
483  			if (shortcuts[i].getID() == IDM_SEARCH_FIND || shortcuts[i].getID() == IDM_SEARCH_REPLACE ||
484  				shortcuts[i].getID() == IDM_SEARCH_FINDINFILES || shortcuts[i].getID() == IDM_SEARCH_MARK)
485  				findReplaceAcc.push_back(_pAccelArray[offset]);
486  			++offset;
487  		}
488  	}
489  	for (i = 0; i < nbMacro; ++i)
490  	{
491  		if (macros[i].isEnabled()) 
492  		{
493  			_pAccelArray[offset].cmd = (WORD)(macros[i].getID());
494  			_pAccelArray[offset].fVirt = macros[i].getAcceleratorModifiers();
495  			_pAccelArray[offset].key = macros[i].getKeyCombo()._key;
496  			++offset;
497  		}
498  	}
499  	for (i = 0; i < nbUserCmd; ++i)
500  	{
501  		if (userCommands[i].isEnabled())
502  		{
503  			_pAccelArray[offset].cmd = (WORD)(userCommands[i].getID());
504  			_pAccelArray[offset].fVirt = userCommands[i].getAcceleratorModifiers();
505  			_pAccelArray[offset].key = userCommands[i].getKeyCombo()._key;
506  			++offset;
507  		}
508  	}
509  	for (i = 0; i < nbPluginCmd; ++i)
510  	{
511  		if (pluginCommands[i].isEnabled())
512  		{
513  			_pAccelArray[offset].cmd = (WORD)(pluginCommands[i].getID());
514  			_pAccelArray[offset].fVirt = pluginCommands[i].getAcceleratorModifiers();
515  			_pAccelArray[offset].key = pluginCommands[i].getKeyCombo()._key;
516  			++offset;
517  		}
518  	}
519  	_nbAccelItems = offset;
520  	updateFullMenu();
521  	if (_hAccTable)
522  		::DestroyAcceleratorTable(_hAccTable);
523  	_hAccTable = ::CreateAcceleratorTable(_pAccelArray, _nbAccelItems);
524  	if (_hIncFindAccTab)
525  		::DestroyAcceleratorTable(_hIncFindAccTab);
526  	size_t nb = incrFindAcc.size();
527  	ACCEL *tmpIncrFindAccelArray = new ACCEL[nb];
528  	for (i = 0; i < nb; ++i)
529  	{
530  		tmpIncrFindAccelArray[i] = incrFindAcc[i];
531  	}
532  	_hIncFindAccTab = ::CreateAcceleratorTable(tmpIncrFindAccelArray, static_cast<int32_t>(nb));
533  	delete [] tmpIncrFindAccelArray;
534  	if (_hIncFindAccTab)
535  		::DestroyAcceleratorTable(_hIncFindAccTab);
536  	if (_hFindAccTab)
537  		::DestroyAcceleratorTable(_hFindAccTab);
538  	size_t nbFindReplaceAcc = findReplaceAcc.size();
539  	if (nbFindReplaceAcc)
540  	{
541  		ACCEL* tmpFindAccelArray = new ACCEL[nbFindReplaceAcc];
542  		for (size_t i = 0; i < nbFindReplaceAcc; ++i)
543  			tmpFindAccelArray[i] = findReplaceAcc[i];
544  		_hFindAccTab = ::CreateAcceleratorTable(tmpFindAccelArray, static_cast<int>(nbFindReplaceAcc));
545  		delete[] tmpFindAccelArray;
546  	}
547  	return;
548  }
549  void Accelerator::updateFullMenu()
550  {
551  	NppParameters& nppParam = NppParameters::getInstance();
552  	vector<CommandShortcut> commands = nppParam.getUserShortcuts();
553  	for (size_t i = 0; i < commands.size(); ++i)
554  	{
555  		updateMenuItemByCommand(commands[i]);
556  	}
557  	vector<MacroShortcut> mcommands = nppParam.getMacroList();
558  	for (size_t i = 0; i < mcommands.size(); ++i)
559  	{
560  		updateMenuItemByCommand(mcommands[i]);
561  	}
562  	vector<UserCommand> ucommands = nppParam.getUserCommandList();
563  	for (size_t i = 0; i < ucommands.size(); ++i)
564  	{
565  		updateMenuItemByCommand(ucommands[i]);
566  	}
567  	vector<PluginCmdShortcut> pcommands = nppParam.getPluginCommandList();
568  	for (size_t i = 0; i < pcommands.size(); ++i)
569  	{
570  		updateMenuItemByCommand(pcommands[i]);
571  	}
572  	::DrawMenuBar(_hMenuParent);
573  }
574  void Accelerator::updateMenuItemByCommand(const CommandShortcut& csc)
575  {
576  	int cmdID = csc.getID();
577  	UINT cmdFlags = GetMenuState(_hAccelMenu, cmdID, MF_BYCOMMAND );
578  	cmdFlags = MF_BYCOMMAND | ((cmdFlags&MF_CHECKED) ? MF_CHECKED : MF_UNCHECKED) | ((cmdFlags&MF_DISABLED) ? MF_DISABLED : MF_ENABLED);
579  	::ModifyMenu(_hAccelMenu, cmdID, cmdFlags, cmdID, string2wstring(csc.toMenuItemString(), CP_UTF8).c_str());
580  }
581  recordedMacroStep::recordedMacroStep(int iMessage, uptr_t wParam, uptr_t lParam)
582  	: _message(iMessage), _wParameter(wParam), _lParameter(lParam), _macroType(mtUseLParameter)
583  { 
584  	if (_lParameter)
585  	{
586  		switch (_message)
587  		{
588  			case SCI_SETTEXT :
589  			case SCI_REPLACESEL :
590  			case SCI_REPLACETARGET :
591  			case SCI_REPLACETARGETRE :
592  			case SCI_SEARCHINTARGET :
593  			case SCI_ADDTEXT :
594  			case SCI_ADDSTYLEDTEXT :
595  			case SCI_INSERTTEXT :
596  			case SCI_APPENDTEXT :
597  			case SCI_SETWORDCHARS :
598  			case SCI_SETWHITESPACECHARS :
599  			case SCI_SETSTYLINGEX :
600  			case SCI_TEXTWIDTH :
601  			case SCI_STYLESETFONT :
602  			case SCI_SEARCHNEXT :
603  			case SCI_SEARCHPREV :
604  			case IDFINDWHAT:
605  			case IDREPLACEWITH:
606  			case IDD_FINDINFILES_DIR_COMBO:
607  			case IDD_FINDINFILES_FILTERS_COMBO:
608  			{
609  				char *ch = reinterpret_cast<char *>(_lParameter);
610  				_sParameter = *ch;
611  				_macroType = mtUseSParameter;
612  				_lParameter = 0;
613  			}
614  			break;
615  			default : 
616  				break;
617  		}
618  	}
619  }
620  bool recordedMacroStep::isMacroable() const
621  {
622  	switch (_message)
623  	{
624  		case SCI_REPLACESEL: 
625  		case SCI_ADDTEXT:    
626  		case SCI_INSERTTEXT: 
627  		case SCI_APPENDTEXT: 
628  		case SCI_SEARCHNEXT: 
629  		case SCI_SEARCHPREV: 
630  		{
631  			if (_macroType == mtUseSParameter)
632  				return true;
633  			else
634  				return false;
635  		}
636  		case SCI_GOTOLINE:   
637  		case SCI_GOTOPOS:    
638  		case SCI_SETSELECTIONMODE:  
639  		case SCI_CUT:
640  		case SCI_COPY:
641  		case SCI_PASTE:
642  		case SCI_CLEAR:
643  		case SCI_CLEARALL:
644  		case SCI_SELECTALL:
645  		case SCI_SEARCHANCHOR:
646  		case SCI_LINEDOWN:
647  		case SCI_LINEDOWNEXTEND:
648  		case SCI_PARADOWN:
649  		case SCI_PARADOWNEXTEND:
650  		case SCI_LINEUP:
651  		case SCI_LINEUPEXTEND:
652  		case SCI_PARAUP:
653  		case SCI_PARAUPEXTEND:
654  		case SCI_CHARLEFT:
655  		case SCI_CHARLEFTEXTEND:
656  		case SCI_CHARRIGHT:
657  		case SCI_CHARRIGHTEXTEND:
658  		case SCI_WORDLEFT:
659  		case SCI_WORDLEFTEXTEND:
660  		case SCI_WORDRIGHT:
661  		case SCI_WORDRIGHTEXTEND:
662  		case SCI_WORDPARTLEFT:
663  		case SCI_WORDPARTLEFTEXTEND:
664  		case SCI_WORDPARTRIGHT:
665  		case SCI_WORDPARTRIGHTEXTEND:
666  		case SCI_WORDLEFTEND:
667  		case SCI_WORDLEFTENDEXTEND:
668  		case SCI_WORDRIGHTEND:
669  		case SCI_WORDRIGHTENDEXTEND:
670  		case SCI_HOME:
671  		case SCI_HOMEEXTEND:
672  		case SCI_LINEEND:
673  		case SCI_LINEENDEXTEND:
674  		case SCI_HOMEWRAP:
675  		case SCI_HOMEWRAPEXTEND:
676  		case SCI_LINEENDWRAP:
677  		case SCI_LINEENDWRAPEXTEND:
678  		case SCI_DOCUMENTSTART:
679  		case SCI_DOCUMENTSTARTEXTEND:
680  		case SCI_DOCUMENTEND:
681  		case SCI_DOCUMENTENDEXTEND:
682  		case SCI_STUTTEREDPAGEUP:
683  		case SCI_STUTTEREDPAGEUPEXTEND:
684  		case SCI_STUTTEREDPAGEDOWN:
685  		case SCI_STUTTEREDPAGEDOWNEXTEND:
686  		case SCI_PAGEUP:
687  		case SCI_PAGEUPEXTEND:
688  		case SCI_PAGEDOWN:
689  		case SCI_PAGEDOWNEXTEND:
690  		case SCI_EDITTOGGLEOVERTYPE:
691  		case SCI_CANCEL:
692  		case SCI_DELETEBACK:
693  		case SCI_TAB:
694  		case SCI_BACKTAB:
695  		case SCI_FORMFEED:
696  		case SCI_VCHOME:
697  		case SCI_VCHOMEEXTEND:
698  		case SCI_VCHOMEWRAP:
699  		case SCI_VCHOMEWRAPEXTEND:
700  		case SCI_VCHOMEDISPLAY:
701  		case SCI_VCHOMEDISPLAYEXTEND:
702  		case SCI_DELWORDLEFT:
703  		case SCI_DELWORDRIGHT:
704  		case SCI_DELWORDRIGHTEND:
705  		case SCI_DELLINELEFT:
706  		case SCI_DELLINERIGHT:
707  		case SCI_LINECOPY:
708  		case SCI_LINECUT:
709  		case SCI_LINEDELETE:
710  		case SCI_LINETRANSPOSE:
711  		case SCI_LINEDUPLICATE:
712  		case SCI_LOWERCASE:
713  		case SCI_UPPERCASE:
714  		case SCI_LINESCROLLDOWN:
715  		case SCI_LINESCROLLUP:
716  		case SCI_DELETEBACKNOTLINE:
717  		case SCI_HOMEDISPLAY:
718  		case SCI_HOMEDISPLAYEXTEND:
719  		case SCI_LINEENDDISPLAY:
720  		case SCI_LINEENDDISPLAYEXTEND:
721  		case SCI_LINEDOWNRECTEXTEND:
722  		case SCI_LINEUPRECTEXTEND:
723  		case SCI_CHARLEFTRECTEXTEND:
724  		case SCI_CHARRIGHTRECTEXTEND:
725  		case SCI_HOMERECTEXTEND:
726  		case SCI_VCHOMERECTEXTEND:
727  		case SCI_LINEENDRECTEXTEND:
728  		case SCI_PAGEUPRECTEXTEND:
729  		case SCI_PAGEDOWNRECTEXTEND:
730  		case SCI_SELECTIONDUPLICATE:
731  		case SCI_COPYALLOWLINE:
732  		case SCI_VERTICALCENTRECARET:
733  		case SCI_MOVESELECTEDLINESUP:
734  		case SCI_MOVESELECTEDLINESDOWN:
735  		case SCI_SCROLLTOSTART:
736  		case SCI_SCROLLTOEND:
737  		case SCI_SETVIRTUALSPACEOPTIONS:
738  		case SCI_SETCARETLINEBACKALPHA:
739  		case SCI_NEWLINE:
740  		{
741  			if (_macroType == mtUseLParameter)
742  				return true;
743  			else
744  				return false;
745  		}
746  		default:
747  			return false;
748  	}
749  }
750  void recordedMacroStep::PlayBack(Window* pNotepad, ScintillaEditView *pEditView)
751  {
752  	if (_macroType == mtMenuCommand)
753  	{
754  		::SendMessage(pNotepad->getHSelf(), WM_COMMAND, _wParameter, 0);
755  	}
756  	else
757  	{
758  		if (!isMacroable())
759  			return;
760  		if (_macroType == mtUseSParameter) 
761  		{
762  			pEditView->execute(_message, _wParameter, (LPARAM)_sParameter.c_str());
763  		}
764  		else
765  		{
766  			pEditView->execute(_message, _wParameter, _lParameter);
767  		}
768  		if ( (_message == SCI_SETTEXT)
769  			|| (_message == SCI_REPLACESEL) 
770  			|| (_message == SCI_ADDTEXT) 
771  			|| (_message == SCI_ADDSTYLEDTEXT) 
772  			|| (_message == SCI_INSERTTEXT) 
773  			|| (_message == SCI_APPENDTEXT) )
774  		{
775  			SCNotification scnN;
776  			scnN.nmhdr.code = SCN_CHARADDED;
777  			scnN.nmhdr.hwndFrom = pEditView->getHSelf();
778  			scnN.nmhdr.idFrom = 0;
779  			if (_sParameter.empty())
780  				scnN.ch = 0;
781  			else
782  				scnN.ch = _sParameter.at(0);
783  			::SendMessage(pNotepad->getHSelf(), WM_NOTIFY, 0, reinterpret_cast<LPARAM>(&scnN));
784  		}
785  	}
786  }
787  void ScintillaAccelerator::init(vector<HWND> * vScintillas, HMENU hMenu, HWND menuParent)
788  {
789  	_hAccelMenu = hMenu;
790  	_hMenuParent = menuParent;
791  	size_t nbScintilla = vScintillas->size();
792  	for (size_t i = 0; i < nbScintilla; ++i)
793  	{
794  		_vScintillas.push_back(vScintillas->at(i));
795  	}
796  }
797  void ScintillaAccelerator::updateKeys() 
798  {
799  	NppParameters& nppParam = NppParameters::getInstance();
800  	vector<ScintillaKeyMap> & map = nppParam.getScintillaKeyList();
801  	size_t mapSize = map.size();
802  	size_t index;
803  	size_t nb = nbScintillas();
804  	for (size_t i = 0; i < nb; ++i)
805  	{
806  		::SendMessage(_vScintillas[i], SCI_CLEARALLCMDKEYS, 0, 0);
807  		for (int32_t j = static_cast<int32_t>(mapSize) - 1; j >= 0; j--) 
808  		{	
809  			ScintillaKeyMap skm = map[j];
810  			if (skm.isEnabled()) 
811  			{		
812  				size_t size = skm.getSize();
813  				for (index = 0; index < size; ++index)
814  					::SendMessage(_vScintillas[i], SCI_ASSIGNCMDKEY, skm.toKeyDef(index), skm.getScintillaKeyID());
815  			}
816  			if (skm.getMenuCmdID() != 0) 
817  			{
818  				updateMenuItemByID(skm, skm.getMenuCmdID());
819  			}
820  			if (j == 0)	
821  				break;
822  		}
823  	}
824  }
825  void ScintillaAccelerator::updateMenuItemByID(const ScintillaKeyMap& skm, int id)
826  {
827  	TCHAR cmdName[menuItemStrLenMax];
828  	::GetMenuString(_hAccelMenu, id, cmdName, menuItemStrLenMax, MF_BYCOMMAND);
829  	int i = 0;
830  	while (cmdName[i] != 0)
831  	{
832  		if (cmdName[i] == '\t')
833  		{
834  			cmdName[i] = 0;
835  			break;
836  		}
837  		++i;
838  	}
839  	generic_string menuItem = cmdName;
840  	if (skm.isEnabled())
841  	{
842  		menuItem += TEXT("\t");
843  		menuItem += string2wstring(skm.toString(), CP_UTF8);
844  	}
845  	::ModifyMenu(_hAccelMenu, id, MF_BYCOMMAND, id, menuItem.c_str());
846  	::DrawMenuBar(_hMenuParent);
847  }
848  void ScintillaKeyMap::applyToCurrentIndex()
849  {
850  	int index = static_cast<int>(::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_GETCURSEL, 0, 0));
851  	if (index == LB_ERR)
852  		return;
853  	setKeyComboByIndex(static_cast<int>(index), _keyCombo);
854  	updateListItem(index);
855  	::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_SETCURSEL, index, 0);
856  }
857  void ScintillaKeyMap::validateDialog()
858  {
859  	bool valid = isValid();	
860  	bool isDisabling = _keyCombo._key == 0;	
861  	bool isDisabled = !isEnabled();	
862  	bool isDuplicate = false; 
863  	for (size_t i = 0; i < _size; ++i) 
864  	{
865  		if (_keyCombo._key   == _keyCombos[i]._key   && _keyCombo._isCtrl  == _keyCombos[i]._isCtrl &&
866  			_keyCombo._isAlt == _keyCombos[i]._isAlt && _keyCombo._isShift == _keyCombos[i]._isShift)
867  		{
868  			isDuplicate = true;
869  			break;
870  		}
871  	}
872  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_ADD), valid && !isDisabling && !isDuplicate);
873  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_APPLY), valid && (!isDisabling || _size == 1) && !isDuplicate);
874  	::EnableWindow(::GetDlgItem(_hSelf, IDC_BUTTON_RMVE), (_size > 1)?TRUE:FALSE);
875  	::ShowWindow(::GetDlgItem(_hSelf, IDC_WARNING_STATIC), isDisabled?SW_SHOW:SW_HIDE);
876  	updateConflictState();
877  }
878  void ScintillaKeyMap::showCurrentSettings()
879  {
880  	auto keyIndex = ::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_GETCURSEL, 0, 0);
881  	_keyCombo = _keyCombos[keyIndex];
882  	::SendDlgItemMessage(_hSelf, IDC_CTRL_CHECK,	BM_SETCHECK, _keyCombo._isCtrl?BST_CHECKED:BST_UNCHECKED, 0);
883  	::SendDlgItemMessage(_hSelf, IDC_ALT_CHECK,		BM_SETCHECK, _keyCombo._isAlt?BST_CHECKED:BST_UNCHECKED, 0);
884  	::SendDlgItemMessage(_hSelf, IDC_SHIFT_CHECK,	BM_SETCHECK, _keyCombo._isShift?BST_CHECKED:BST_UNCHECKED, 0);
885  	for (size_t i = 0 ; i < nbKeys ; ++i)
886  	{
887  		if (_keyCombo._key == namedKeyArray[i].id)
888  		{
889  			::SendDlgItemMessage(_hSelf, IDC_KEY_COMBO, CB_SETCURSEL, i, 0);
890  			break;
891  		}
892  	}
893  }
894  void ScintillaKeyMap::updateListItem(int index)
895  {
896  	::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_INSERTSTRING, index, reinterpret_cast<LPARAM>(string2wstring(toString(index), CP_UTF8).c_str()));
897  	::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_DELETESTRING, index+1, 0);
898  }
899  intptr_t CALLBACK ScintillaKeyMap::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam) 
900  {
901  	switch (Message)
902  	{
903  		case WM_INITDIALOG :
904  		{
905  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
906  			::SetDlgItemText(_hSelf, IDC_NAME_EDIT, string2wstring(_name, CP_UTF8).c_str());
907  			_keyCombo = _keyCombos[0];
908  			for (size_t i = 0 ; i < nbKeys ; ++i)
909  			{
910  				::SendDlgItemMessage(_hSelf, IDC_KEY_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(string2wstring(namedKeyArray[i].name, CP_UTF8).c_str()));
911  			}
912  			for (size_t i = 0; i < _size; ++i)
913  			{
914  				::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(string2wstring(toString(i), CP_UTF8).c_str()));
915  			}
916  			::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_SETCURSEL, 0, 0);
917  			showCurrentSettings();
918  			validateDialog();
919  			::ShowWindow(::GetDlgItem(_hSelf, IDC_WARNING_STATIC), SW_HIDE);
920  			NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
921  			nativeLangSpeaker->changeDlgLang(_hSelf, "ShortcutMapperSubDialg");
922  			goToCenter();
923  			return TRUE;
924  		}
925  		case WM_CTLCOLOREDIT:
926  		{
927  			if (NppDarkMode::isEnabled())
928  			{
929  				return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
930  			}
931  			break;
932  		}
933  		case WM_CTLCOLORLISTBOX:
934  		{
935  			if (NppDarkMode::isEnabled())
936  			{
937  				return NppDarkMode::onCtlColorListbox(wParam, lParam);
938  			}
939  			break;
940  		}
941  		case WM_CTLCOLORDLG:
942  		case WM_CTLCOLORSTATIC:
943  		{
944  			if (NppDarkMode::isEnabled())
945  			{
946  				auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
947  				if (dlgCtrlID == IDC_NAME_EDIT)
948  				{
949  					return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
950  				}
951  				return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
952  			}
953  			break;
954  		}
955  		case WM_PRINTCLIENT:
956  		{
957  			if (NppDarkMode::isEnabled())
958  			{
959  				return TRUE;
960  			}
961  			break;
962  		}
963  		case NPPM_INTERNAL_REFRESHDARKMODE:
964  		{
965  			NppDarkMode::autoThemeChildControls(_hSelf);
966  			return TRUE;
967  		}
968  		case WM_COMMAND : 
969  		{
970  			switch (wParam)
971  			{
972  				case IDC_CTRL_CHECK :
973  					_keyCombo._isCtrl = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
974  					validateDialog();
975  					return TRUE;
976  				case IDC_ALT_CHECK :
977  					_keyCombo._isAlt = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
978  					validateDialog();
979  					return TRUE;
980  				case IDC_SHIFT_CHECK :
981  					_keyCombo._isShift = BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0);
982  					validateDialog();
983  					return TRUE;
984  				case IDOK :
985  					_keyCombo._key = 0;
986  					_keyCombo._isCtrl = _keyCombo._isAlt = _keyCombo._isShift = false;
987  					::EndDialog(_hSelf, 0);
988  					return TRUE;
989  				case IDCANCEL :
990  					::EndDialog(_hSelf, -1);
991  					return TRUE;
992  				case IDC_BUTTON_ADD: 
993  				{
994  					size_t oldsize = _size;
995  					int res = addKeyCombo(_keyCombo);
996  					if (res > -1)
997  					{
998  						if (res == static_cast<int32_t>(oldsize))
999  						{
1000  							::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_INSERTSTRING, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(string2wstring(toString(res), CP_UTF8).c_str()));
1001  						}
1002  						else
1003  						{	
1004  							updateListItem(res);
1005  						}
1006  						::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_SETCURSEL, res, 0);
1007  					}
1008  					showCurrentSettings();
1009  					validateDialog();
1010  					return TRUE; 
1011  				}
1012  				case IDC_BUTTON_RMVE:
1013  				{
1014  					if (_size == 1)	
1015  						return TRUE;
1016  					auto i = ::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_GETCURSEL, 0, 0);
1017  					removeKeyComboByIndex(i);
1018  					::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_DELETESTRING, i, 0);
1019  					if (static_cast<size_t>(i) == _size)
1020  						i = _size - 1;
1021  					::SendDlgItemMessage(_hSelf, IDC_LIST_KEYS, LB_SETCURSEL, i, 0);
1022  					showCurrentSettings();
1023  					validateDialog();
1024  					return TRUE; 
1025  				}
1026  				case IDC_BUTTON_APPLY:
1027  				{
1028  					applyToCurrentIndex();
1029  					validateDialog();
1030  					return TRUE;
1031  				}
1032  				default:
1033  					if (HIWORD(wParam) == CBN_SELCHANGE || HIWORD(wParam) == LBN_SELCHANGE)
1034  					{
1035  						switch(LOWORD(wParam))
1036  						{
1037  							case IDC_KEY_COMBO:
1038  							{
1039  								auto i = ::SendDlgItemMessage(_hSelf, IDC_KEY_COMBO, CB_GETCURSEL, 0, 0);
1040  								_keyCombo._key = namedKeyArray[i].id;
1041  								::ShowWindow(::GetDlgItem(_hSelf, IDC_WARNING_STATIC), isEnabled() ? SW_HIDE : SW_SHOW);
1042  								validateDialog();
1043  								return TRUE;
1044  							}
1045  							case IDC_LIST_KEYS:
1046  							{
1047  								showCurrentSettings();
1048  								validateDialog();
1049  								return TRUE;
1050  							}
1051  						}
1052  					}
1053  					return FALSE;
1054  			}
1055  		}
1056  		default :
1057  			return FALSE;
1058  	}
1059  	return FALSE;
1060  }
1061  CommandShortcut::CommandShortcut(const Shortcut& sc, long id) :	Shortcut(sc), _id(id)
1062  {
1063  	_shortcutName = string2wstring(sc.getName(), CP_UTF8);
1064  	if ( _id >= IDM_WINDOW_SORT_FN_ASC and _id <= IDM_WINDOW_SORT_FS_DSC)
1065  		_category = TEXT("Window");
1066  	else if ( _id < IDM_EDIT)
1067  		_category = TEXT("File");
1068  	else if ( _id < IDM_SEARCH)
1069  		_category = TEXT("Edit");
1070  	else if (((_id >= IDM_EDIT_AUTOCOMPLETE) && (_id <= IDM_EDIT_AUTOCOMPLETE_PATH)) || 
1071  			 ((_id >= IDM_EDIT_FUNCCALLTIP_PREVIOUS) && (_id <= IDM_EDIT_FUNCCALLTIP_NEXT)))
1072  		_category = TEXT("Edit");
1073  	else if ( _id < IDM_VIEW)
1074  		_category = TEXT("Search");
1075  	else if ( _id < IDM_FORMAT)
1076  		_category = TEXT("View");
1077  	else if ( _id >= IDM_VIEW_GOTO_ANOTHER_VIEW and _id <= IDM_VIEW_LOAD_IN_NEW_INSTANCE)
1078  		_category = TEXT("View");
1079  	else if ( _id < IDM_LANG)
1080  		_category = TEXT("Format");
1081  	else if ( _id < IDM_ABOUT)
1082  		_category = TEXT("Lang");
1083  	else if ( _id < IDM_SETTING)
1084  		_category = TEXT("About");
1085  	else if ( _id < IDM_TOOL)
1086  		_category = TEXT("Setting");
1087  	else if ( _id < IDM_EXECUTE)
1088  		_category = TEXT("Tool");
1089  	else
1090  		_category = TEXT("Execute");
1091  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-civil_time_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-shortcut.cpp</div>
                </div>
                <div class="column column_space"><pre><code>61  }
62  void BM_CivilYearAbslHash(benchmark::State& state) {
63    BM_CivilTimeAbslHash<absl::CivilYear>(state);
64  }
65  void BM_CivilMonthAbslHash(benchmark::State& state) {
66    BM_CivilTimeAbslHash<absl::CivilMonth>(state);
67  }
68  void BM_CivilDayAbslHash(benchmark::State& state) {
69    BM_CivilTimeAbslHash<absl::CivilDay>(state);
70  }
71  void BM_CivilHourAbslHash(benchmark::State& state) {
72    BM_CivilTimeAbslHash<absl::CivilHour>(state);
73  }
74  void BM_CivilMinuteAbslHash(benchmark::State& state) {
75    BM_CivilTimeAbslHash<absl::CivilMinute>(state);
76  }
77  void BM_CivilSecondAbslHash(benchmark::State& state) {
78    BM_CivilTimeAbslHash<absl::CivilSecond>(state);
79  }
80  BENCHMARK(BM_CivilYearAbslHash);
81  BENCHMARK(BM_CivilMonthAbslHash);
82  BENCHMARK(BM_CivilDayAbslHash);
83  BENCHMARK(BM_CivilHourAbslHash);
84  BENCHMARK(BM_CivilMinuteAbslHash);
85  BENCHMARK(BM_CivilSecondAbslHash);
86  }  
</pre></code></div>
                <div class="column column_space"><pre><code>100  {";", VK_OEM_1},
101  {"'", VK_OEM_7},
102  {"\\", VK_OEM_5},
103  {",", VK_OEM_COMMA},
104  {".", VK_OEM_PERIOD},
105  {"/", VK_OEM_2},
106  {"<>", VK_OEM_102},
107  };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    