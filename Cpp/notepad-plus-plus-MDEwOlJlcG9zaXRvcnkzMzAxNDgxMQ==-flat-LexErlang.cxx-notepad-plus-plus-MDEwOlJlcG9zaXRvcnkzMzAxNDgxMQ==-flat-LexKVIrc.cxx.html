
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 30, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexErlang.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static int is_radix(int radix, int ch) {
20  	int digit;
21  	if (36 < radix || 2 > radix)
22  		return 0;
23  	if (isdigit(ch)) {
24  		digit = ch - '0';
25  	} else if (isalnum(ch)) {
26  		digit = toupper(ch) - 'A' + 10;
27  	} else {
28  		return 0;
29  	}
30  	return (digit < radix);
31  }
32  typedef enum {
33  	STATE_NULL,
34  	COMMENT,
35  	COMMENT_FUNCTION,
36  	COMMENT_MODULE,
37  	COMMENT_DOC,
38  	COMMENT_DOC_MACRO,
39  	ATOM_UNQUOTED,
40  	ATOM_QUOTED,
41  	NODE_NAME_UNQUOTED,
42  	NODE_NAME_QUOTED,
43  	MACRO_START,
44  	MACRO_UNQUOTED,
45  	MACRO_QUOTED,
46  	RECORD_START,
47  	RECORD_UNQUOTED,
48  	RECORD_QUOTED,
49  	NUMERAL_START,
50  	NUMERAL_BASE_VALUE,
51  	NUMERAL_FLOAT,
52  	NUMERAL_EXPONENT,
53  	PREPROCESSOR
54  } atom_parse_state_t;
55  static inline bool IsAWordChar(const int ch) {
56  	return (ch < 0x80) && (ch != ' ') && (isalnum(ch) || ch == '_');
57  }
58  static void ColouriseErlangDoc(Sci_PositionU startPos, Sci_Position length, int initStyle,
59  								WordList *keywordlists[], Accessor &styler) {
60  	StyleContext sc(startPos, length, initStyle, styler);
61  	WordList &reservedWords = *keywordlists[0];
62  	WordList &erlangBIFs = *keywordlists[1];
63  	WordList &erlangPreproc = *keywordlists[2];
64  	WordList &erlangModulesAtt = *keywordlists[3];
65  	WordList &erlangDoc = *keywordlists[4];
66  	WordList &erlangDocMacro = *keywordlists[5];
67  	int radix_digits = 0;
68  	int exponent_digits = 0;
69  	atom_parse_state_t parse_state = STATE_NULL;
70  	atom_parse_state_t old_parse_state = STATE_NULL;
71  	bool to_late_to_comment = false;
72  	char cur[100];
73  	int old_style = SCE_ERLANG_DEFAULT;
74  	styler.StartAt(startPos);
75  	for (; sc.More(); sc.Forward()) {
76  		int style = SCE_ERLANG_DEFAULT;
77  		if (STATE_NULL != parse_state) {
78  			switch (parse_state) {
79  				case STATE_NULL : sc.SetState(SCE_ERLANG_DEFAULT); break;
80  				case COMMENT : {
81  					if (sc.ch != '%') {
82  						to_late_to_comment = true;
83  					} else if (!to_late_to_comment && sc.ch == '%') {
84  						sc.ChangeState(SCE_ERLANG_COMMENT_FUNCTION);
85  						old_style = SCE_ERLANG_COMMENT_FUNCTION;
86  						parse_state = COMMENT_FUNCTION;
87  						sc.Forward();
88  					}
89  				}
90  				case COMMENT_FUNCTION : {
91  					if (sc.ch != '%') {
92  						to_late_to_comment = true;
93  					} else if (!to_late_to_comment && sc.ch == '%') {
94  						sc.ChangeState(SCE_ERLANG_COMMENT_MODULE);
95  						old_style = SCE_ERLANG_COMMENT_MODULE;
96  						parse_state = COMMENT_MODULE;
97  						sc.Forward();
98  					}
99  				}
100  				case COMMENT_MODULE : {
101  					if (parse_state != COMMENT) {
102  						if (sc.chNext == '@') {
103  							old_parse_state = parse_state;
104  							parse_state = ('{' == sc.ch)
105  											? COMMENT_DOC_MACRO
106  											: COMMENT_DOC;
107  							sc.ForwardSetState(sc.state);
108  						}
109  					}
110  					if (sc.MatchLineEnd()) {
111  						to_late_to_comment = false;
112  						sc.SetState(SCE_ERLANG_DEFAULT);
113  						parse_state = STATE_NULL;
114  					}
115  				} break;
116  				case COMMENT_DOC :
117  				case COMMENT_DOC_MACRO : {
118  					if (!isalnum(sc.ch)) {
119  						sc.GetCurrent(cur, sizeof(cur));
120  						if (parse_state == COMMENT_DOC_MACRO
121  							&& erlangDocMacro.InList(cur)) {
122  								sc.ChangeState(SCE_ERLANG_COMMENT_DOC_MACRO);
123  								while (sc.ch != '}' && !sc.atLineEnd)
124  									sc.Forward();
125  						} else if (erlangDoc.InList(cur)) {
126  							sc.ChangeState(SCE_ERLANG_COMMENT_DOC);
127  						} else {
128  							sc.ChangeState(old_style);
129  						}
130  						sc.SetState(old_style);
131  						parse_state = old_parse_state;
132  					}
133  					if (sc.MatchLineEnd()) {
134  						to_late_to_comment = false;
135  						sc.ChangeState(old_style);
136  						sc.SetState(SCE_ERLANG_DEFAULT);
137  						parse_state = STATE_NULL;
138  					}
139  				} break;
140  				case ATOM_UNQUOTED : {
141  					if ('@' == sc.ch){
142  						parse_state = NODE_NAME_UNQUOTED;
143  					} else if (sc.ch == ':') {
144  						if (sc.chNext == ' ') {
145  							sc.ChangeState(SCE_ERLANG_UNKNOWN);
146  							parse_state = STATE_NULL;
147  						} else {
148  							sc.Forward();
149  							if (isalnum(sc.ch) || (sc.ch == '\''))  {
150  								sc.GetCurrent(cur, sizeof(cur));
151  								sc.ChangeState(SCE_ERLANG_MODULES);
152  								sc.SetState(SCE_ERLANG_MODULES);
153  							}
154  							if (sc.ch == '\'') {
155  								parse_state = ATOM_QUOTED;
156  							}
157  						}
158  					} else if (!IsAWordChar(sc.ch)) {
159  						sc.GetCurrent(cur, sizeof(cur));
160  						if (reservedWords.InList(cur)) {
161  							style = SCE_ERLANG_KEYWORD;
162  						} else if (erlangBIFs.InList(cur)
163  									&& strcmp(cur,"erlang:")){
164  							style = SCE_ERLANG_BIFS;
165  						} else if (sc.ch == '(' || '/' == sc.ch){
166  							style = SCE_ERLANG_FUNCTION_NAME;
167  						} else {
168  							style = SCE_ERLANG_ATOM;
169  						}
170  						sc.ChangeState(style);
171  						sc.SetState(SCE_ERLANG_DEFAULT);
172  						parse_state = STATE_NULL;
173  					}
174  				} break;
175  				case ATOM_QUOTED : {
176  					if ( '@' == sc.ch ){
177  						parse_state = NODE_NAME_QUOTED;
178  					} else if ('\'' == sc.ch && '\\' != sc.chPrev) {
179  						sc.ChangeState(SCE_ERLANG_ATOM_QUOTED);
180  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
181  						parse_state = STATE_NULL;
182  					}
183  				} break;
184  				case NODE_NAME_UNQUOTED : {
185  					if ('@' == sc.ch) {
186  						sc.SetState(SCE_ERLANG_DEFAULT);
187  						parse_state = STATE_NULL;
188  					} else if (!IsAWordChar(sc.ch)) {
189  						sc.ChangeState(SCE_ERLANG_NODE_NAME);
190  						sc.SetState(SCE_ERLANG_DEFAULT);
191  						parse_state = STATE_NULL;
192  					}
193  				} break;
194  				case NODE_NAME_QUOTED : {
195  					if ('@' == sc.ch) {
196  						sc.SetState(SCE_ERLANG_DEFAULT);
197  						parse_state = STATE_NULL;
198  					} else if ('\'' == sc.ch && '\\' != sc.chPrev) {
199  						sc.ChangeState(SCE_ERLANG_NODE_NAME_QUOTED);
200  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
201  						parse_state = STATE_NULL;
202  					}
203  				} break;
204  				case RECORD_START : {
205  					if ('\'' == sc.ch) {
206  						parse_state = RECORD_QUOTED;
207  					} else if (isalpha(sc.ch) && islower(sc.ch)) {
208  						parse_state = RECORD_UNQUOTED;
209  					} else { 
210  						sc.SetState(SCE_ERLANG_DEFAULT);
211  						parse_state = STATE_NULL;
212  					}
213  				} break;
214  				case RECORD_UNQUOTED : {
215  					if (!IsAWordChar(sc.ch)) {
216  						sc.ChangeState(SCE_ERLANG_RECORD);
217  						sc.SetState(SCE_ERLANG_DEFAULT);
218  						parse_state = STATE_NULL;
219  					}
220  				} break;
221  				case RECORD_QUOTED : {
222  					if ('\'' == sc.ch && '\\' != sc.chPrev) {
223  						sc.ChangeState(SCE_ERLANG_RECORD_QUOTED);
224  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
225  						parse_state = STATE_NULL;
226  					}
227  				} break;
228  				case MACRO_START : {
229  					if ('\'' == sc.ch) {
230  						parse_state = MACRO_QUOTED;
231  					} else if (isalpha(sc.ch)) {
232  						parse_state = MACRO_UNQUOTED;
233  					} else { 
234  						sc.SetState(SCE_ERLANG_DEFAULT);
235  						parse_state = STATE_NULL;
236  					}
237  				} break;
238  				case MACRO_UNQUOTED : {
239  					if (!IsAWordChar(sc.ch)) {
240  						sc.ChangeState(SCE_ERLANG_MACRO);
241  						sc.SetState(SCE_ERLANG_DEFAULT);
242  						parse_state = STATE_NULL;
243  					}
244  				} break;
245  				case MACRO_QUOTED : {
246  					if ('\'' == sc.ch && '\\' != sc.chPrev) {
247  						sc.ChangeState(SCE_ERLANG_MACRO_QUOTED);
248  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
249  						parse_state = STATE_NULL;
250  					}
251  				} break;
252  				case NUMERAL_START : {
253  					if (isdigit(sc.ch)) {
254  						radix_digits *= 10;
255  						radix_digits += sc.ch - '0'; 
256  					} else if ('#' == sc.ch) {
257  						if (2 > radix_digits || 36 < radix_digits) {
258  							sc.SetState(SCE_ERLANG_DEFAULT);
259  							parse_state = STATE_NULL;
260  						} else {
261  							parse_state = NUMERAL_BASE_VALUE;
262  						}
263  					} else if ('.' == sc.ch && isdigit(sc.chNext)) {
264  						radix_digits = 0;
265  						parse_state = NUMERAL_FLOAT;
266  					} else if ('e' == sc.ch || 'E' == sc.ch) {
267  						exponent_digits = 0;
268  						parse_state = NUMERAL_EXPONENT;
269  					} else {
270  						radix_digits = 0;
271  						sc.ChangeState(SCE_ERLANG_NUMBER);
272  						sc.SetState(SCE_ERLANG_DEFAULT);
273  						parse_state = STATE_NULL;
274  					}
275  				} break;
276  				case NUMERAL_BASE_VALUE : {
277  					if (!is_radix(radix_digits,sc.ch)) {
278  						radix_digits = 0;
279  						if (!isalnum(sc.ch))
280  							sc.ChangeState(SCE_ERLANG_NUMBER);
281  						sc.SetState(SCE_ERLANG_DEFAULT);
282  						parse_state = STATE_NULL;
283  					}
284  				} break;
285  				case NUMERAL_FLOAT : {
286  					if ('e' == sc.ch || 'E' == sc.ch) {
287  						exponent_digits = 0;
288  						parse_state = NUMERAL_EXPONENT;
289  					} else if (!isdigit(sc.ch)) {
290  						sc.ChangeState(SCE_ERLANG_NUMBER);
291  						sc.SetState(SCE_ERLANG_DEFAULT);
292  						parse_state = STATE_NULL;
293  					}
294  				} break;
295  				case NUMERAL_EXPONENT : {
296  					if (('-' == sc.ch || '+' == sc.ch)
297  							&& (isdigit(sc.chNext))) {
298  						sc.Forward();
299  					} else if (!isdigit(sc.ch)) {
300  						if (0 < exponent_digits)
301  							sc.ChangeState(SCE_ERLANG_NUMBER);
302  						sc.SetState(SCE_ERLANG_DEFAULT);
303  						parse_state = STATE_NULL;
304  					} else {
305  						++exponent_digits;
306  					}
307  				} break;
308  				case PREPROCESSOR : {
309  					if (!IsAWordChar(sc.ch)) {
310  						sc.GetCurrent(cur, sizeof(cur));
311  						if (erlangPreproc.InList(cur)) {
312  							style = SCE_ERLANG_PREPROC;
313  						} else if (erlangModulesAtt.InList(cur)) {
314  							style = SCE_ERLANG_MODULES_ATT;
315  						}
316  						sc.ChangeState(style);
317  						sc.SetState(SCE_ERLANG_DEFAULT);
318  						parse_state = STATE_NULL;
319  					}
320  				} break;
321  			}
322  		} &bsol;* End of : STATE_NULL != parse_state */
323  		else
324  		{
325  			switch (sc.state) {
326  				case SCE_ERLANG_VARIABLE : {
327  					if (!IsAWordChar(sc.ch))
328  						sc.SetState(SCE_ERLANG_DEFAULT);
329  				} break;
330  				case SCE_ERLANG_STRING : {
331  					 if (sc.ch == '\"' && sc.chPrev != '\\')
332  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
333  				} break;
334  				case SCE_ERLANG_COMMENT : {
335  					 if (sc.atLineEnd)
336  						sc.SetState(SCE_ERLANG_DEFAULT);
337  				} break;
338  				case SCE_ERLANG_CHARACTER : {
339  					if (sc.chPrev == '\\') {
340  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
341  					} else if (sc.ch != '\\') {
342  						sc.ForwardSetState(SCE_ERLANG_DEFAULT);
343  					}
344  				} break;
345  				case SCE_ERLANG_OPERATOR : {
346  					if (sc.chPrev == '.') {
347  						if (sc.ch == '*' || sc.ch == '/' || sc.ch == '\\'
348  							|| sc.ch == '^') {
349  							sc.ForwardSetState(SCE_ERLANG_DEFAULT);
350  						} else if (sc.ch == '\'') {
351  							sc.ForwardSetState(SCE_ERLANG_DEFAULT);
352  						} else {
353  							sc.SetState(SCE_ERLANG_DEFAULT);
354  						}
355  					} else {
356  						sc.SetState(SCE_ERLANG_DEFAULT);
357  					}
358  				} break;
359  			}
360  		}
361  		if (sc.state == SCE_ERLANG_DEFAULT) {
362  			bool no_new_state = false;
363  			switch (sc.ch) {
364  				case '\"' : sc.SetState(SCE_ERLANG_STRING); break;
365  				case '$' : sc.SetState(SCE_ERLANG_CHARACTER); break;
366  				case '%' : {
367  					parse_state = COMMENT;
368  					sc.SetState(SCE_ERLANG_COMMENT);
369  				} break;
370  				case '#' : {
371  					parse_state = RECORD_START;
372  					sc.SetState(SCE_ERLANG_UNKNOWN);
373  				} break;
374  				case '?' : {
375  					parse_state = MACRO_START;
376  					sc.SetState(SCE_ERLANG_UNKNOWN);
377  				} break;
378  				case '\'' : {
379  					parse_state = ATOM_QUOTED;
380  					sc.SetState(SCE_ERLANG_UNKNOWN);
381  				} break;
382  				case '+' :
383  				case '-' : {
384  					if (IsADigit(sc.chNext)) {
385  						parse_state = NUMERAL_START;
386  						radix_digits = 0;
387  						sc.SetState(SCE_ERLANG_UNKNOWN);
388  					} else if (sc.ch != '+') {
389  						parse_state = PREPROCESSOR;
390  						sc.SetState(SCE_ERLANG_UNKNOWN);
391  					}
392  				} break;
393  				default : no_new_state = true;
394  			}
395  			if (no_new_state) {
396  				if (isdigit(sc.ch)) {
397  					parse_state = NUMERAL_START;
398  					radix_digits = sc.ch - '0';
399  					sc.SetState(SCE_ERLANG_UNKNOWN);
400  				} else if (isupper(sc.ch) || '_' == sc.ch) {
401  					sc.SetState(SCE_ERLANG_VARIABLE);
402  				} else if (isalpha(sc.ch)) {
403  					parse_state = ATOM_UNQUOTED;
404  					sc.SetState(SCE_ERLANG_UNKNOWN);
405  				} else if (isoperator(static_cast<char>(sc.ch))
406  							|| sc.ch == '\\') {
407  					sc.SetState(SCE_ERLANG_OPERATOR);
408  				}
409  			}
410  		}
411  	}
412  	sc.Complete();
413  }
414  static int ClassifyErlangFoldPoint(
415  	Accessor &styler,
416  	int styleNext,
417  	Sci_Position keyword_start
418  ) {
419  	int lev = 0;
420  	if (styler.Match(keyword_start,"case")
421  		|| (
422  			styler.Match(keyword_start,"fun")
423  			&& (SCE_ERLANG_FUNCTION_NAME != styleNext)
424  			)
425  		|| styler.Match(keyword_start,"if")
426  		|| styler.Match(keyword_start,"query")
427  		|| styler.Match(keyword_start,"receive")
428  	) {
429  		++lev;
430  	} else if (styler.Match(keyword_start,"end")) {
431  		--lev;
432  	}
433  	return lev;
434  }
435  static void FoldErlangDoc(
436  	Sci_PositionU startPos, Sci_Position length, int initStyle,
437  	WordList** &bsol;*keywordlists*/, Accessor &styler
438  ) {
439  	Sci_PositionU endPos = startPos + length;
440  	Sci_Position currentLine = styler.GetLine(startPos);
441  	int lev;
442  	int previousLevel = styler.LevelAt(currentLine) & SC_FOLDLEVELNUMBERMASK;
443  	int currentLevel = previousLevel;
444  	int styleNext = styler.StyleAt(startPos);
445  	int style = initStyle;
446  	int stylePrev;
447  	Sci_Position keyword_start = 0;
448  	char ch;
449  	char chNext = styler.SafeGetCharAt(startPos);
450  	bool atEOL;
451  	for (Sci_PositionU i = startPos; i < endPos; i++) {
452  		ch = chNext;
453  		chNext = styler.SafeGetCharAt(i + 1);
454  		stylePrev = style;
455  		style = styleNext;
456  		styleNext = styler.StyleAt(i + 1);
457  		atEOL = ((ch == '\r') && (chNext != '\n')) || (ch == '\n');
458  		if (stylePrev != SCE_ERLANG_KEYWORD
459  			&& style == SCE_ERLANG_KEYWORD) {
460  			keyword_start = i;
461  		}
462  		if (stylePrev == SCE_ERLANG_KEYWORD
463  			&& style != SCE_ERLANG_KEYWORD
464  			&& style != SCE_ERLANG_ATOM
465  		) {
466  			currentLevel += ClassifyErlangFoldPoint(styler,
467  													styleNext,
468  													keyword_start);
469  		}
470  		if (style == SCE_ERLANG_COMMENT
471  			|| style == SCE_ERLANG_COMMENT_MODULE
472  			|| style == SCE_ERLANG_COMMENT_FUNCTION) {
473  			if (ch == '%' && chNext == '{') {
474  				currentLevel++;
475  			} else if (ch == '%' && chNext == '}') {
476  				currentLevel--;
477  			}
478  		}
479  		if (style == SCE_ERLANG_OPERATOR) {
480  			if (ch == '{' || ch == '(' || ch == '[') {
481  				currentLevel++;
482  			} else if (ch == '}' || ch == ')' || ch == ']') {
483  				currentLevel--;
484  			}
485  		}
486  		if (atEOL) {
487  			lev = previousLevel;
<span onclick='openModal()' class='match'>488  			if (currentLevel > previousLevel)
489  				lev |= SC_FOLDLEVELHEADERFLAG;
490  			if (lev != styler.LevelAt(currentLine))
491  				styler.SetLevel(currentLine, lev);
492  			currentLine++;
</span>493  			previousLevel = currentLevel;
494  		}
495  	}
496  	styler.SetLevel(currentLine,
497  					previousLevel
498  					| (styler.LevelAt(currentLine) & ~SC_FOLDLEVELNUMBERMASK));
499  }
500  static const char * const erlangWordListDesc[] = {
501  	"Erlang Reserved words",
502  	"Erlang BIFs",
503  	"Erlang Preprocessor",
504  	"Erlang Module Attributes",
505  	"Erlang Documentation",
506  	"Erlang Documentation Macro",
507  	0
508  };
509  LexerModule lmErlang(
510  	SCLEX_ERLANG,
511  	ColouriseErlangDoc,
512  	"erlang",
513  	FoldErlangDoc,
514  	erlangWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexKVIrc.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsAWordChar(int ch) {
20      return (ch < 0x80) && (isalnum(ch) || ch == '_' || ch == '.'
21              || ch == ':');
22  }
23  static inline bool IsAWordStart(int ch) {
24      return (ch < 0x80) && (isalnum(ch) || ch == '_' );
25  }
26  static void ColouriseKVIrcDoc(Sci_PositionU startPos, Sci_Position length,
27                                int initStyle, WordList *keywordlists[],
28                                Accessor &styler)
29  {
30      StyleContext sc(startPos, length, initStyle, styler);
31      WordList &keywords = *keywordlists[0];
32      WordList &functionKeywords = *keywordlists[1];
33      bool next = true;
34      for( ; sc.More(); next ? sc.Forward() : (void)0 )
35      {
36          next = true;
37          switch (sc.state)
38          {
39              case SCE_KVIRC_DEFAULT:
40                  if (
41                      (sc.ch == '#' && sc.atLineStart) ||
42                      (sc.ch == '#' && (
43                          sc.chPrev != '(' && sc.chPrev != ',' &&
44                          sc.chPrev != ']')
45                      )
46                  )
47                  {
48                      sc.SetState(SCE_KVIRC_COMMENT);
49                      break;
50                  }
51                  if (sc.Match('/', '*'))
52                  {
53                      sc.SetState(SCE_KVIRC_COMMENTBLOCK);
54                      break;
55                  }
56                  if (sc.ch == '"')
57                  {
58                      sc.SetState(SCE_KVIRC_STRING);
59                      break;
60                  }
61                  if (sc.ch == '$')
62                  {
63                      sc.SetState(SCE_KVIRC_FUNCTION);
64                      break;
65                  }
66                  if (sc.ch == '%')
67                  {
68                      sc.SetState(SCE_KVIRC_VARIABLE);
69                      break;
70                  }
71                  if (IsADigit(sc.ch))
72                  {
73                      sc.SetState(SCE_KVIRC_NUMBER);
74                      break;
75                  }
76                  if (IsAWordStart(sc.ch) && IsAWordChar(sc.chNext))
77                  {
78                      sc.SetState(SCE_KVIRC_WORD);
79                      sc.Forward();
80                      break;
81                  }
82                  if (isoperator(sc.ch))
83                  {
84                      sc.SetState(SCE_KVIRC_OPERATOR);
85                      break;
86                  }
87                  break;
88              case SCE_KVIRC_COMMENT:
89                  if (sc.ch == '\r' || sc.ch == '\n')
90                  {
91                      sc.SetState(SCE_KVIRC_DEFAULT);
92                      break;
93                  }
94                  break;
95              case SCE_KVIRC_COMMENTBLOCK:
96                  if (sc.Match('*', '/'))
97                  {
98                      sc.Forward(2);
99                      sc.SetState(SCE_KVIRC_DEFAULT);
100                      next = false;
101                      break;
102                  }
103                  break;
104              case SCE_KVIRC_STRING:
105                  if (sc.ch == '"')
106                  {
107                      if (sc.chPrev == '\\')
108                          break;
109                      sc.ForwardSetState(SCE_KVIRC_DEFAULT);
110                      next = false;
111                      break;
112                  }
113                  if (sc.ch == '$')
114                  {
115                      if (sc.chPrev == '\\')
116                          break;
117                      sc.SetState(SCE_KVIRC_STRING_FUNCTION);
118                      break;
119                  }
120                  if (sc.ch == '%')
121                  {
122                      if (sc.chPrev == '\\')
123                          break;
124                      sc.SetState(SCE_KVIRC_STRING_VARIABLE);
125                      break;
126                  }
127                  if (sc.ch == '\r' || sc.ch == '\n')
128                  {
129                      if (sc.chPrev == '\\')
130                          break;
131                      sc.SetState(SCE_KVIRC_DEFAULT);
132                      break;
133                  }
134                  break;
135              case SCE_KVIRC_FUNCTION:
136              case SCE_KVIRC_VARIABLE:
137                  if (!IsAWordChar(sc.ch))
138                  {
139                      sc.SetState(SCE_KVIRC_DEFAULT);
140                      next = false;
141                      break;
142                  }
143                  break;
144              case SCE_KVIRC_STRING_FUNCTION:
145              case SCE_KVIRC_STRING_VARIABLE:
146                  if (!IsAWordChar(sc.ch))
147                  {
148                      sc.SetState(SCE_KVIRC_STRING);
149                      next = false;
150                      break;
151                  }
152                  break;
153              case SCE_KVIRC_NUMBER:
154                  if (!IsADigit(sc.ch))
155                  {
156                      sc.SetState(SCE_KVIRC_DEFAULT);
157                      next = false;
158                      break;
159                  }
160                  break;
161              case SCE_KVIRC_OPERATOR:
162                  sc.SetState(SCE_KVIRC_DEFAULT);
163                  next = false;
164                  break;
165              case SCE_KVIRC_WORD:
166                  if (!IsAWordChar(sc.ch))
167                  {
168                      char s[100];
169                      Sci_Position wordLen = sc.currentPos - styler.GetStartSegment();
170                      if (wordLen > 99)
171                          wordLen = 99;  &bsol;* Include '\0' in buffer */
172                      Sci_Position i;
173                      for( i = 0; i < wordLen; ++i )
174                      {
175                          s[i] = styler.SafeGetCharAt( styler.GetStartSegment() + i );
176                      }
177                      s[wordLen] = '\0';
178                      if (keywords.InList(s))
179                      {
180                          sc.ChangeState(SCE_KVIRC_KEYWORD);
181                      }
182                      else if (functionKeywords.InList(s))
183                      {
184                          sc.ChangeState(SCE_KVIRC_FUNCTION_KEYWORD);
185                      }
186                      sc.SetState(SCE_KVIRC_DEFAULT);
187                      next = false;
188                      break;
189                  }
190                  break;
191          }
192      }
193      sc.Complete();
194  }
195  static void FoldKVIrcDoc(Sci_PositionU startPos, Sci_Position length, int &bsol;*initStyle - unused*/,
196                        WordList *[], Accessor &styler)
197  {
198      if ( styler.GetPropertyInt("fold") == 0 )
199          return;
200      Sci_Position currentLine = styler.GetLine(startPos);
201      Sci_PositionU safeStartPos = styler.LineStart( currentLine );
202      int currentLevel = SC_FOLDLEVELBASE;
203      if (currentLine > 0)
204          currentLevel = styler.LevelAt(currentLine - 1) >> 16;
205      int nextLevel = currentLevel;
206      for (Sci_PositionU i = safeStartPos; i < startPos + length; ++i)
207      {
208          int state = styler.StyleAt(i) & 31;
209          switch( styler.SafeGetCharAt(i) )
210          {
211              case '{':
212                  if (state != SCE_KVIRC_COMMENT &&
213                      state != SCE_KVIRC_COMMENTBLOCK)
214                      ++nextLevel;
215                  break;
216              case '}':
217                  if (state != SCE_KVIRC_COMMENT &&
218                      state != SCE_KVIRC_COMMENTBLOCK)
219                      --nextLevel;
220                  break;
221              case '\n':
222              case '\r':
223                  int lev = currentLevel | nextLevel << 16;
224                  if (nextLevel > currentLevel )
225                      lev |= SC_FOLDLEVELHEADERFLAG;
226                  if (lev != styler.LevelAt(currentLine))
227                      styler.SetLevel(currentLine, lev);
228                  ++currentLine;
229                  currentLevel = nextLevel;
230                  if (styler.SafeGetCharAt(i) == '\r' &&
231                      styler.SafeGetCharAt(i + 1) == '\n')
232                      ++i;
233                  break;
234          }
235      }
236      int lev = currentLevel | nextLevel << 16;
<span onclick='openModal()' class='match'>237      if (nextLevel > currentLevel )
238          lev |= SC_FOLDLEVELHEADERFLAG;
239      if (lev != styler.LevelAt(currentLine))
240          styler.SetLevel(currentLine, lev);
241  }
</span>242  static const char *const kvircWordListDesc[] = {
243  	"primary",
244  	"function_keywords",
245  	0
246  };
247  LexerModule lmKVIrc(SCLEX_KVIRC, ColouriseKVIrcDoc, "kvirc", FoldKVIrcDoc,
248                      kvircWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexErlang.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexKVIrc.cxx</div>
                </div>
                <div class="column column_space"><pre><code>488  			if (currentLevel > previousLevel)
489  				lev |= SC_FOLDLEVELHEADERFLAG;
490  			if (lev != styler.LevelAt(currentLine))
491  				styler.SetLevel(currentLine, lev);
492  			currentLine++;
</pre></code></div>
                <div class="column column_space"><pre><code>237      if (nextLevel > currentLevel )
238          lev |= SC_FOLDLEVELHEADERFLAG;
239      if (lev != styler.LevelAt(currentLine))
240          styler.SetLevel(currentLine, lev);
241  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    