
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/connect.hpp>
2  #include <nano/boost/asio/ip/tcp.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/boost/beast/core/flat_buffer.hpp>
5  #include <nano/boost/beast/http.hpp>
6  #include <nano/boost/process/child.hpp>
7  #include <nano/lib/threading.hpp>
8  #include <nano/lib/tomlconfig.hpp>
9  #include <nano/node/daemonconfig.hpp>
10  #include <nano/secure/utility.hpp>
11  #include <nano/test_common/testutil.hpp>
12  #include <boost/dll/runtime_symbol_info.hpp>
13  #include <boost/program_options.hpp>
14  #include <boost/property_tree/json_parser.hpp>
15  #include <csignal>
16  #include <future>
17  #include <iomanip>
18  #include <memory>
19  #include <random>
20  #if BOOST_VERSION < 107000
21  using socket_type = boost::asio::ip::tcp::socket;
22  #else
23  using socket_type = boost::asio::basic_stream_socket<boost::asio::ip::tcp, boost::asio::io_context::executor_type>;
24  #endif
25  namespace nano
26  {
27  void force_nano_dev_network ();
28  }
29  namespace beast = boost::beast;
30  namespace http = beast::http;
31  namespace net = boost::asio;
32  using tcp = net::ip::tcp;
33  constexpr auto rpc_port_start = 60000;
34  constexpr auto peering_port_start = 61000;
35  constexpr auto ipc_port_start = 62000;
36  void write_config_files (boost::filesystem::path const & data_path, int index)
37  {
38  	nano::network_params network_params{ nano::network_constants::active_network };
39  	nano::daemon_config daemon_config{ data_path, network_params };
40  	daemon_config.node.peering_port = peering_port_start + index;
41  	daemon_config.node.ipc_config.transport_tcp.enabled = true;
42  	daemon_config.node.ipc_config.transport_tcp.port = ipc_port_start + index;
43  	daemon_config.node.use_memory_pools = (index % 2) == 0;
44  	nano::tomlconfig toml;
45  	daemon_config.serialize_toml (toml);
46  	toml.write (nano::get_node_toml_config_path (data_path));
47  	nano::rpc_config rpc_config{ daemon_config.node.network_params.network };
48  	rpc_config.port = rpc_port_start + index;
49  	rpc_config.enable_control = true;
50  	rpc_config.rpc_process.ipc_port = ipc_port_start + index;
51  	nano::tomlconfig toml_rpc;
52  	rpc_config.serialize_toml (toml_rpc);
53  	toml_rpc.write (nano::get_rpc_toml_config_path (data_path));
54  }
55  class account final
56  {
57  public:
58  	std::string private_key;
59  	std::string public_key;
60  	std::string as_string;
61  };
62  class account_info final
63  {
64  public:
65  	bool operator== (account_info const & other) const
66  	{
67  		return frontier == other.frontier && block_count == other.block_count && balance == other.balance && error == other.error;
68  	}
69  	std::string frontier;
70  	std::string block_count;
71  	std::string balance;
72  	bool error{ false };
73  };
74  class send_receive_impl;
75  class start_receive_session_impl;
76  class rpc_request_impl;
77  class start_receive_session_impl : public std::enable_shared_from_this<start_receive_session_impl>
78  {
79  private:
80  	socket_type socket;
81  	std::atomic<int> & send_calls_remaining;
82  	tcp::resolver::results_type const & results;
83  	std::string const wallet;
84  	std::string const source;
85  	std::string const destination;
86  	std::string const block;
87  	boost::beast::flat_buffer buffer;
88  	http::request<http::string_body> req;
89  	http::response<http::string_body> res;
90  public:
91  	start_receive_session_impl (
92  	boost::asio::io_context & io_ctx_a,
93  	tcp::resolver::results_type const & results_a,
94  	std::string const & wallet_a,
95  	std::string const & source_a,
96  	std::string const & destination_a,
97  	std::atomic<int> & send_calls_remaining_a,
98  	std::string const block_a) :
99  		socket{ io_ctx_a },
100  		send_calls_remaining{ send_calls_remaining_a },
101  		results{ results_a },
102  		wallet{ wallet_a },
103  		source{ source_a },
104  		destination{ destination_a },
105  		block{ std::move (block_a) }
106  	{
107  	}
108  	void start ()
109  	{
110  		async_connect ();
111  	}
112  private:
113  	void async_connect ()
114  	{
115  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
116  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
117  			this_l->request_receive ();
118  		});
119  	}
120  	void request_receive ()
121  	{
122  		boost::property_tree::ptree request;
123  		request.put ("action", "receive");
124  		request.put ("wallet", wallet);
125  		request.put ("account", destination);
126  		request.put ("block", block);
127  		std::stringstream ostream;
128  		boost::property_tree::write_json (ostream, request);
129  		req.method (http::verb::post);
130  		req.version (11);
131  		req.target ("/");
132  		req.body () = ostream.str ();
133  		req.prepare_payload ();
134  		async_write ();
135  	}
136  	void async_write ()
137  	{
138  		http::async_write (socket, req,
139  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
140  			debug_assert (!error_code);
141  			debug_assert (bytes_transferred > 0);
142  			this_l->async_read ();
143  		});
144  	}
145  	void async_read ()
146  	{
147  		http::async_read (socket, buffer, res,
148  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
149  			debug_assert (!error_code);
150  			debug_assert (bytes_transferred > 0);
151  			--this_l->send_calls_remaining;
152  			this_l->socket_shutdown ();
153  		});
154  	}
155  	void socket_shutdown ()
156  	{
157  		boost::system::error_code ec;
158  		socket.shutdown (tcp::socket::shutdown_both, ec);
159  		debug_assert (!ec || ec == boost::system::errc::not_connected);
160  	}
161  };
162  class send_receive_impl : public std::enable_shared_from_this<send_receive_impl>
163  {
164  private:
165  	boost::asio::io_context & io_ctx;
166  	socket_type socket;
167  	std::string const wallet;
168  	std::string const source;
169  	std::string const destination;
170  	std::atomic<int> & send_calls_remaining;
171  	tcp::resolver::results_type const results;
172  	boost::beast::flat_buffer buffer;
173  	http::request<http::string_body> req;
174  	http::response<http::string_body> res;
175  	std::shared_ptr<start_receive_session_impl> start_receive_session = nullptr;
176  public:
177  	send_receive_impl (
178  	boost::asio::io_context & io_ctx_a,
179  	std::string const & wallet_a,
180  	std::string const & source_a,
181  	std::string const & destination_a,
182  	std::atomic<int> & send_calls_remaining_a,
183  	tcp::resolver::results_type const & results_a) :
184  		io_ctx{ io_ctx_a },
185  		socket{ io_ctx },
186  		wallet{ wallet_a },
187  		source{ source_a },
188  		destination{ destination_a },
189  		send_calls_remaining{ send_calls_remaining_a },
190  		results{ results_a }
191  	{
192  	}
193  	void start ()
194  	{
195  		async_connect ();
196  	}
197  private:
198  	void async_connect ()
199  	{
200  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
201  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
202  			this_l->request_send ();
203  		});
204  	}
205  	void request_send ()
206  	{
207  		boost::property_tree::ptree request;
208  		request.put ("action", "send");
209  		request.put ("wallet", wallet);
210  		request.put ("source", source);
211  		request.put ("destination", destination);
212  		request.put ("amount", "1");
213  		std::stringstream ostream;
214  		boost::property_tree::write_json (ostream, request);
215  		req.method (http::verb::post);
216  		req.version (11);
217  		req.target ("/");
218  		req.body () = ostream.str ();
219  		req.prepare_payload ();
220  		async_write ();
221  	}
222  	void async_write ()
223  	{
224  		http::async_write (socket, req,
225  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
226  			debug_assert (!error_code);
227  			debug_assert (bytes_transferred > 0);
228  			this_l->async_read ();
229  		});
230  	}
231  	void async_read ()
232  	{
233  		http::async_read (socket, buffer, res,
234  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
235  			debug_assert (!error_code);
236  			debug_assert (bytes_transferred > 0);
237  			this_l->receive_start ();
238  			this_l->socket_shutdown ();
239  		});
240  	}
241  	void socket_shutdown ()
242  	{
243  		boost::system::error_code ec;
244  		socket.shutdown (tcp::socket::shutdown_both, ec);
245  		debug_assert (!ec || ec == boost::system::errc::not_connected);
246  	}
247  	void receive_start ()
248  	{
249  		boost::property_tree::ptree json;
250  		std::stringstream body (res.body ());
251  		boost::property_tree::read_json (body, json);
252  		auto block = json.get<std::string> ("block");
253  		start_receive_session = std::make_shared<start_receive_session_impl> (
254  		io_ctx, results, wallet, source, destination, send_calls_remaining, block);
255  		start_receive_session->start ();
256  	}
257  };
258  class rpc_request_impl : public std::enable_shared_from_this<rpc_request_impl>
259  {
260  private:
261  	boost::property_tree::ptree const request;
262  	boost::asio::io_context & ioc;
263  	tcp::resolver::results_type const results;
264  	socket_type socket;
265  	boost::beast::flat_buffer buffer;
266  	http::request<http::string_body> req;
267  	http::response<http::string_body> res;
268  	std::promise<boost::optional<boost::property_tree::ptree>> promise;
269  public:
270  	rpc_request_impl (
271  	boost::property_tree::ptree const & request_a,
272  	boost::asio::io_context & ioc_a,
273  	tcp::resolver::results_type const & results_a) :
274  		request{ request_a },
275  		ioc{ ioc_a },
276  		results{ results_a },
277  		socket{ ioc }
278  	{
279  		debug_assert (results.size () == 1);
280  	}
281  	void start ()
282  	{
283  		async_connect ();
284  	}
285  	boost::property_tree::ptree value_get ()
286  	{
287  		auto future = promise.get_future ();
288  		if (future.wait_for (std::chrono::seconds (5)) != std::future_status::ready)
289  		{
290  			throw std::runtime_error ("RPC request timed out");
291  		}
292  		auto response = future.get ();
293  		debug_assert (response.is_initialized ());
294  		return response.value_or (decltype (response)::argument_type{});
295  	}
296  private:
297  	void async_connect ()
298  	{
299  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
300  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
301  			this_l->request_do ();
302  		});
303  	}
304  	void request_do ()
305  	{
306  		std::stringstream ostream;
307  		boost::property_tree::write_json (ostream, request);
308  		req.method (http::verb::post);
309  		req.version (11);
310  		req.target ("/");
311  		req.body () = ostream.str ();
312  		req.prepare_payload ();
313  		async_write ();
314  	}
315  	void async_write ()
316  	{
317  		http::async_write (socket, req,
318  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
319  			debug_assert (!error_code);
320  			debug_assert (bytes_transferred > 0);
321  			this_l->async_read ();
322  		});
323  	}
324  	void async_read ()
325  	{
326  		http::async_read (socket, buffer, res,
327  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
328  			debug_assert (!error_code);
329  			debug_assert (bytes_transferred > 0);
330  			this_l->value_set ();
331  		});
332  	}
333  	void value_set ()
334  	{
335  		boost::property_tree::ptree json;
336  		std::stringstream body (res.body ());
337  		boost::property_tree::read_json (body, json);
338  		promise.set_value (json);
339  	}
340  };
341  boost::property_tree::ptree rpc_request (boost::property_tree::ptree const & request, boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
342  {
343  	auto rpc_request = std::make_shared<rpc_request_impl> (request, ioc, results);
344  	boost::asio::strand<boost::asio::io_context::executor_type> strand{ ioc.get_executor () };
345  	boost::asio::post (strand,
346  	[rpc_request] () {
347  		rpc_request->start ();
348  	});
349  	return rpc_request->value_get ();
350  }
351  void keepalive_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, uint16_t port)
352  {
353  	boost::property_tree::ptree request;
354  	request.put ("action", "keepalive");
355  	request.put ("address", "::1");
356  	request.put ("port", port);
357  	rpc_request (request, ioc, results);
358  }
359  account key_create_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
360  {
361  	boost::property_tree::ptree request;
362  	request.put ("action", "key_create");
363  	auto json = rpc_request (request, ioc, results);
364  	account account_l;
365  	account_l.private_key = json.get<std::string> ("private");
366  	account_l.public_key = json.get<std::string> ("public");
367  	account_l.as_string = json.get<std::string> ("account");
368  	return account_l;
369  }
370  std::string wallet_create_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
371  {
372  	boost::property_tree::ptree request;
373  	request.put ("action", "wallet_create");
374  	auto json = rpc_request (request, ioc, results);
375  	return json.get<std::string> ("wallet");
376  }
377  void wallet_add_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, std::string const & wallet, std::string const & prv_key)
378  {
379  	boost::property_tree::ptree request;
380  	request.put ("action", "wallet_add");
381  	request.put ("wallet", wallet);
382  	request.put ("key", prv_key);
383  	rpc_request (request, ioc, results);
384  }
385  void stop_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
386  {
387  	boost::property_tree::ptree request;
388  	request.put ("action", "stop");
389  	rpc_request (request, ioc, results);
390  }
391  account_info account_info_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, std::string const & account)
392  {
393  	boost::property_tree::ptree request;
394  	request.put ("action", "account_info");
395  	request.put ("account", account);
396  	account_info account_info;
397  	auto json = rpc_request (request, ioc, results);
398  	auto error = json.get_optional<std::string> ("error");
399  	if (error)
400  	{
401  		account_info.error = true;
402  	}
403  	else
404  	{
405  		account_info.balance = json.get<std::string> ("balance");
406  		account_info.block_count = json.get<std::string> ("block_count");
407  		account_info.frontier = json.get<std::string> ("frontier");
408  	}
409  	return account_info;
410  }
411  int main (int argc, char * const * argv)
412  {
<span onclick='openModal()' class='match'>413  	nano::force_nano_dev_network ();
414  	boost::program_options::options_description description ("Command line options");
415  	description.add_options ()
416  		("help", "Print out options")
417  		("node_count,n", boost::program_options::value<int> ()->default_value (10), "The number of nodes to spin up")
</span>418  		("send_count,s", boost::program_options::value<int> ()->default_value (2000), "How many send blocks to generate")
419  		("simultaneous_process_calls", boost::program_options::value<int> ()->default_value (20), "Number of simultaneous rpc sends to do")
420  		("destination_count", boost::program_options::value<int> ()->default_value (2), "How many destination accounts to choose between")
421  		("node_path", boost::program_options::value<std::string> (), "The path to the nano_node to test")
422  		("rpc_path", boost::program_options::value<std::string> (), "The path to the nano_rpc to test");
423  	boost::program_options::variables_map vm;
424  	try
425  	{
426  		boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
427  	}
428  	catch (boost::program_options::error const & err)
429  	{
430  		std::cerr << err.what () << std::endl;
431  		return 1;
432  	}
433  	boost::program_options::notify (vm);
434  	auto node_count = vm.find ("node_count")->second.as<int> ();
435  	auto destination_count = vm.find ("destination_count")->second.as<int> ();
436  	auto send_count = vm.find ("send_count")->second.as<int> ();
437  	auto simultaneous_process_calls = vm.find ("simultaneous_process_calls")->second.as<int> ();
438  	boost::system::error_code err;
439  	auto running_executable_filepath = boost::dll::program_location (err);
440  	auto node_path_it (vm.find ("node_path"));
441  	std::string node_path;
442  	if (node_path_it != vm.end ())
443  	{
444  		node_path = node_path_it->second.as<std::string> ();
445  	}
446  	else
447  	{
448  		auto node_filepath = running_executable_filepath.parent_path () / "nano_node";
449  		if (running_executable_filepath.has_extension ())
450  		{
451  			node_filepath.replace_extension (running_executable_filepath.extension ());
452  		}
453  		node_path = node_filepath.string ();
454  	}
455  	if (!boost::filesystem::exists (node_path))
456  	{
457  		std::cerr << "nano_node executable could not be found in " << node_path << std::endl;
458  		return 1;
459  	}
460  	auto rpc_path_it (vm.find ("rpc_path"));
461  	std::string rpc_path;
462  	if (rpc_path_it != vm.end ())
463  	{
464  		rpc_path = rpc_path_it->second.as<std::string> ();
465  	}
466  	else
467  	{
468  		auto rpc_filepath = running_executable_filepath.parent_path () / "nano_rpc";
469  		if (running_executable_filepath.has_extension ())
470  		{
471  			rpc_filepath.replace_extension (running_executable_filepath.extension ());
472  		}
473  		rpc_path = rpc_filepath.string ();
474  	}
475  	if (!boost::filesystem::exists (rpc_path))
476  	{
477  		std::cerr << "nano_rpc executable could not be found in " << rpc_path << std::endl;
478  		return 1;
479  	}
480  	std::vector<boost::filesystem::path> data_paths;
481  	for (auto i = 0; i < node_count; ++i)
482  	{
483  		auto data_path = nano::unique_path ();
484  		boost::filesystem::create_directory (data_path);
485  		write_config_files (data_path, i);
486  		data_paths.push_back (std::move (data_path));
487  	}
488  	auto current_network = nano::dev::network_params.network.get_current_network_as_string ();
489  	std::vector<std::unique_ptr<boost::process::child>> nodes;
490  	std::vector<std::unique_ptr<boost::process::child>> rpc_servers;
491  	for (auto const & data_path : data_paths)
492  	{
493  		nodes.emplace_back (std::make_unique<boost::process::child> (node_path, "--daemon", "--data_path", data_path.string (), "--network", current_network));
494  		rpc_servers.emplace_back (std::make_unique<boost::process::child> (rpc_path, "--daemon", "--data_path", data_path.string (), "--network", current_network));
495  	}
496  	std::cout << "Waiting for nodes to spin up..." << std::endl;
497  	std::this_thread::sleep_for (std::chrono::seconds (7));
498  	std::cout << "Connecting nodes..." << std::endl;
499  	boost::asio::io_context ioc;
500  	debug_assert (!nano::signal_handler_impl);
501  	nano::signal_handler_impl = [&ioc] () {
502  		ioc.stop ();
503  	};
504  	std::signal (SIGINT, &nano::signal_handler);
505  	std::signal (SIGTERM, &nano::signal_handler);
506  	tcp::resolver resolver{ ioc };
507  	auto const primary_node_results = resolver.resolve ("::1", std::to_string (rpc_port_start));
508  	std::thread t ([send_count, &ioc, &primary_node_results, &resolver, &node_count, &destination_count] () {
509  		for (int i = 0; i < node_count; ++i)
510  		{
511  			keepalive_rpc (ioc, primary_node_results, peering_port_start + i);
512  		}
513  		std::cout << "Beginning tests" << std::endl;
514  		std::vector<account> destination_accounts;
515  		for (int i = 0; i < destination_count; ++i)
516  		{
517  			destination_accounts.emplace_back (key_create_rpc (ioc, primary_node_results));
518  		}
519  		std::string wallet = wallet_create_rpc (ioc, primary_node_results);
520  		wallet_add_rpc (ioc, primary_node_results, wallet, nano::dev::genesis_key.prv.to_string ());
521  		for (auto & account : destination_accounts)
522  		{
523  			wallet_add_rpc (ioc, primary_node_results, wallet, account.private_key);
524  		}
525  		std::cout << "\rPrimary node processing transactions: 00%";
526  		std::random_device rd;
527  		std::mt19937 mt (rd ());
528  		std::uniform_int_distribution<size_t> dist (0, destination_accounts.size () - 1);
529  		std::atomic<int> send_calls_remaining{ send_count };
530  		for (auto i = 0; i < send_count; ++i)
531  		{
532  			account * destination_account;
533  			if (i < destination_accounts.size ())
534  			{
535  				destination_account = &destination_accounts[i];
536  			}
537  			else
538  			{
539  				auto random_account_index = dist (mt);
540  				destination_account = &destination_accounts[random_account_index];
541  			}
542  			auto send_receive = std::make_shared<send_receive_impl> (ioc, wallet, nano::dev::genesis->account ().to_account (), destination_account->as_string, send_calls_remaining, primary_node_results);
543  			boost::asio::strand<boost::asio::io_context::executor_type> strand{ ioc.get_executor () };
544  			boost::asio::post (strand,
545  			[send_receive] () {
546  				send_receive->start ();
547  			});
548  		}
549  		while (send_calls_remaining != 0)
550  		{
551  			static int last_percent = 0;
552  			auto percent = static_cast<int> (100 * ((send_count - send_calls_remaining) / static_cast<double> (send_count)));
553  			if (last_percent != percent)
554  			{
555  				std::cout << "\rPrimary node processing transactions: " << std::setfill ('0') << std::setw (2) << percent << "%";
556  				last_percent = percent;
557  			}
558  		}
559  		std::cout << "\rPrimary node processed transactions                " << std::endl;
560  		std::cout << "Waiting for nodes to catch up..." << std::endl;
561  		std::map<std::string, account_info> known_account_info;
562  		for (int i = 0; i < destination_accounts.size (); ++i)
563  		{
564  			known_account_info.emplace (destination_accounts[i].as_string, account_info_rpc (ioc, primary_node_results, destination_accounts[i].as_string));
565  		}
566  		nano::timer<std::chrono::milliseconds> timer;
567  		timer.start ();
568  		for (int i = 1; i < node_count; ++i)
569  		{
570  			auto const results = resolver.resolve ("::1", std::to_string (rpc_port_start + i));
571  			for (auto & account_info : known_account_info)
572  			{
573  				while (true)
574  				{
575  					auto other_account_info = account_info_rpc (ioc, results, account_info.first);
576  					if (!other_account_info.error && account_info.second == other_account_info)
577  					{
578  						break;
579  					}
580  					if (timer.since_start () > std::chrono::seconds (120))
581  					{
582  						throw std::runtime_error ("Timed out");
583  					}
584  					std::this_thread::sleep_for (std::chrono::seconds (1));
585  				}
586  			}
587  			stop_rpc (ioc, results);
588  		}
589  		stop_rpc (ioc, primary_node_results);
590  	});
591  	nano::thread_runner runner (ioc, simultaneous_process_calls);
592  	t.join ();
593  	runner.join ();
594  	for (auto & node : nodes)
595  	{
596  		node->wait ();
597  	}
598  	for (auto & rpc_server : rpc_servers)
599  	{
600  		rpc_server->wait ();
601  	}
602  	std::cout << "Done!" << std::endl;
603  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/connect.hpp>
2  #include <nano/boost/asio/ip/tcp.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/boost/beast/core/flat_buffer.hpp>
5  #include <nano/boost/beast/http.hpp>
6  #include <nano/boost/process/child.hpp>
7  #include <nano/lib/threading.hpp>
8  #include <nano/lib/tomlconfig.hpp>
9  #include <nano/node/daemonconfig.hpp>
10  #include <nano/secure/utility.hpp>
11  #include <nano/test_common/testutil.hpp>
12  #include <boost/dll/runtime_symbol_info.hpp>
13  #include <boost/program_options.hpp>
14  #include <boost/property_tree/json_parser.hpp>
15  #include <csignal>
16  #include <future>
17  #include <iomanip>
18  #include <memory>
19  #include <random>
20  #if BOOST_VERSION < 107000
21  using socket_type = boost::asio::ip::tcp::socket;
22  #else
23  using socket_type = boost::asio::basic_stream_socket<boost::asio::ip::tcp, boost::asio::io_context::executor_type>;
24  #endif
25  namespace nano
26  {
27  void force_nano_dev_network ();
28  }
29  namespace beast = boost::beast;
30  namespace http = beast::http;
31  namespace net = boost::asio;
32  using tcp = net::ip::tcp;
33  constexpr auto rpc_port_start = 60000;
34  constexpr auto peering_port_start = 61000;
35  constexpr auto ipc_port_start = 62000;
36  void write_config_files (boost::filesystem::path const & data_path, int index)
37  {
38  	nano::network_params network_params{ nano::network_constants::active_network };
39  	nano::daemon_config daemon_config{ data_path, network_params };
40  	daemon_config.node.peering_port = peering_port_start + index;
41  	daemon_config.node.ipc_config.transport_tcp.enabled = true;
42  	daemon_config.node.ipc_config.transport_tcp.port = ipc_port_start + index;
43  	daemon_config.node.use_memory_pools = (index % 2) == 0;
44  	nano::tomlconfig toml;
45  	daemon_config.serialize_toml (toml);
46  	toml.write (nano::get_node_toml_config_path (data_path));
47  	nano::rpc_config rpc_config{ daemon_config.node.network_params.network };
48  	rpc_config.port = rpc_port_start + index;
49  	rpc_config.enable_control = true;
50  	rpc_config.rpc_process.ipc_port = ipc_port_start + index;
51  	nano::tomlconfig toml_rpc;
52  	rpc_config.serialize_toml (toml_rpc);
53  	toml_rpc.write (nano::get_rpc_toml_config_path (data_path));
54  }
55  class account final
56  {
57  public:
58  	std::string private_key;
59  	std::string public_key;
60  	std::string as_string;
61  };
62  class account_info final
63  {
64  public:
65  	bool operator== (account_info const & other) const
66  	{
67  		return frontier == other.frontier && block_count == other.block_count && balance == other.balance && error == other.error;
68  	}
69  	std::string frontier;
70  	std::string block_count;
71  	std::string balance;
72  	bool error{ false };
73  };
74  class send_receive_impl;
75  class start_receive_session_impl;
76  class rpc_request_impl;
77  class start_receive_session_impl : public std::enable_shared_from_this<start_receive_session_impl>
78  {
79  private:
80  	socket_type socket;
81  	std::atomic<int> & send_calls_remaining;
82  	tcp::resolver::results_type const & results;
83  	std::string const wallet;
84  	std::string const source;
85  	std::string const destination;
86  	std::string const block;
87  	boost::beast::flat_buffer buffer;
88  	http::request<http::string_body> req;
89  	http::response<http::string_body> res;
90  public:
91  	start_receive_session_impl (
92  	boost::asio::io_context & io_ctx_a,
93  	tcp::resolver::results_type const & results_a,
94  	std::string const & wallet_a,
95  	std::string const & source_a,
96  	std::string const & destination_a,
97  	std::atomic<int> & send_calls_remaining_a,
98  	std::string const block_a) :
99  		socket{ io_ctx_a },
100  		send_calls_remaining{ send_calls_remaining_a },
101  		results{ results_a },
102  		wallet{ wallet_a },
103  		source{ source_a },
104  		destination{ destination_a },
105  		block{ std::move (block_a) }
106  	{
107  	}
108  	void start ()
109  	{
110  		async_connect ();
111  	}
112  private:
113  	void async_connect ()
114  	{
115  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
116  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
117  			this_l->request_receive ();
118  		});
119  	}
120  	void request_receive ()
121  	{
122  		boost::property_tree::ptree request;
123  		request.put ("action", "receive");
124  		request.put ("wallet", wallet);
125  		request.put ("account", destination);
126  		request.put ("block", block);
127  		std::stringstream ostream;
128  		boost::property_tree::write_json (ostream, request);
129  		req.method (http::verb::post);
130  		req.version (11);
131  		req.target ("/");
132  		req.body () = ostream.str ();
133  		req.prepare_payload ();
134  		async_write ();
135  	}
136  	void async_write ()
137  	{
138  		http::async_write (socket, req,
139  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
140  			debug_assert (!error_code);
141  			debug_assert (bytes_transferred > 0);
142  			this_l->async_read ();
143  		});
144  	}
145  	void async_read ()
146  	{
147  		http::async_read (socket, buffer, res,
148  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
149  			debug_assert (!error_code);
150  			debug_assert (bytes_transferred > 0);
151  			--this_l->send_calls_remaining;
152  			this_l->socket_shutdown ();
153  		});
154  	}
155  	void socket_shutdown ()
156  	{
157  		boost::system::error_code ec;
158  		socket.shutdown (tcp::socket::shutdown_both, ec);
159  		debug_assert (!ec || ec == boost::system::errc::not_connected);
160  	}
161  };
162  class send_receive_impl : public std::enable_shared_from_this<send_receive_impl>
163  {
164  private:
165  	boost::asio::io_context & io_ctx;
166  	socket_type socket;
167  	std::string const wallet;
168  	std::string const source;
169  	std::string const destination;
170  	std::atomic<int> & send_calls_remaining;
171  	tcp::resolver::results_type const results;
172  	boost::beast::flat_buffer buffer;
173  	http::request<http::string_body> req;
174  	http::response<http::string_body> res;
175  	std::shared_ptr<start_receive_session_impl> start_receive_session = nullptr;
176  public:
177  	send_receive_impl (
178  	boost::asio::io_context & io_ctx_a,
179  	std::string const & wallet_a,
180  	std::string const & source_a,
181  	std::string const & destination_a,
182  	std::atomic<int> & send_calls_remaining_a,
183  	tcp::resolver::results_type const & results_a) :
184  		io_ctx{ io_ctx_a },
185  		socket{ io_ctx },
186  		wallet{ wallet_a },
187  		source{ source_a },
188  		destination{ destination_a },
189  		send_calls_remaining{ send_calls_remaining_a },
190  		results{ results_a }
191  	{
192  	}
193  	void start ()
194  	{
195  		async_connect ();
196  	}
197  private:
198  	void async_connect ()
199  	{
200  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
201  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
202  			this_l->request_send ();
203  		});
204  	}
205  	void request_send ()
206  	{
207  		boost::property_tree::ptree request;
208  		request.put ("action", "send");
209  		request.put ("wallet", wallet);
210  		request.put ("source", source);
211  		request.put ("destination", destination);
212  		request.put ("amount", "1");
213  		std::stringstream ostream;
214  		boost::property_tree::write_json (ostream, request);
215  		req.method (http::verb::post);
216  		req.version (11);
217  		req.target ("/");
218  		req.body () = ostream.str ();
219  		req.prepare_payload ();
220  		async_write ();
221  	}
222  	void async_write ()
223  	{
224  		http::async_write (socket, req,
225  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
226  			debug_assert (!error_code);
227  			debug_assert (bytes_transferred > 0);
228  			this_l->async_read ();
229  		});
230  	}
231  	void async_read ()
232  	{
233  		http::async_read (socket, buffer, res,
234  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
235  			debug_assert (!error_code);
236  			debug_assert (bytes_transferred > 0);
237  			this_l->receive_start ();
238  			this_l->socket_shutdown ();
239  		});
240  	}
241  	void socket_shutdown ()
242  	{
243  		boost::system::error_code ec;
244  		socket.shutdown (tcp::socket::shutdown_both, ec);
245  		debug_assert (!ec || ec == boost::system::errc::not_connected);
246  	}
247  	void receive_start ()
248  	{
249  		boost::property_tree::ptree json;
250  		std::stringstream body (res.body ());
251  		boost::property_tree::read_json (body, json);
252  		auto block = json.get<std::string> ("block");
253  		start_receive_session = std::make_shared<start_receive_session_impl> (
254  		io_ctx, results, wallet, source, destination, send_calls_remaining, block);
255  		start_receive_session->start ();
256  	}
257  };
258  class rpc_request_impl : public std::enable_shared_from_this<rpc_request_impl>
259  {
260  private:
261  	boost::property_tree::ptree const request;
262  	boost::asio::io_context & ioc;
263  	tcp::resolver::results_type const results;
264  	socket_type socket;
265  	boost::beast::flat_buffer buffer;
266  	http::request<http::string_body> req;
267  	http::response<http::string_body> res;
268  	std::promise<boost::optional<boost::property_tree::ptree>> promise;
269  public:
270  	rpc_request_impl (
271  	boost::property_tree::ptree const & request_a,
272  	boost::asio::io_context & ioc_a,
273  	tcp::resolver::results_type const & results_a) :
274  		request{ request_a },
275  		ioc{ ioc_a },
276  		results{ results_a },
277  		socket{ ioc }
278  	{
279  		debug_assert (results.size () == 1);
280  	}
281  	void start ()
282  	{
283  		async_connect ();
284  	}
285  	boost::property_tree::ptree value_get ()
286  	{
287  		auto future = promise.get_future ();
288  		if (future.wait_for (std::chrono::seconds (5)) != std::future_status::ready)
289  		{
290  			throw std::runtime_error ("RPC request timed out");
291  		}
292  		auto response = future.get ();
293  		debug_assert (response.is_initialized ());
294  		return response.value_or (decltype (response)::argument_type{});
295  	}
296  private:
297  	void async_connect ()
298  	{
299  		boost::asio::async_connect (socket, results.cbegin (), results.cend (),
300  		[this_l = shared_from_this ()] (boost::system::error_code const & ec, tcp::resolver::iterator iterator) {
301  			this_l->request_do ();
302  		});
303  	}
304  	void request_do ()
305  	{
306  		std::stringstream ostream;
307  		boost::property_tree::write_json (ostream, request);
308  		req.method (http::verb::post);
309  		req.version (11);
310  		req.target ("/");
311  		req.body () = ostream.str ();
312  		req.prepare_payload ();
313  		async_write ();
314  	}
315  	void async_write ()
316  	{
317  		http::async_write (socket, req,
318  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
319  			debug_assert (!error_code);
320  			debug_assert (bytes_transferred > 0);
321  			this_l->async_read ();
322  		});
323  	}
324  	void async_read ()
325  	{
326  		http::async_read (socket, buffer, res,
327  		[this_l = shared_from_this ()] (boost::system::error_code const & error_code, std::size_t bytes_transferred) {
328  			debug_assert (!error_code);
329  			debug_assert (bytes_transferred > 0);
330  			this_l->value_set ();
331  		});
332  	}
333  	void value_set ()
334  	{
335  		boost::property_tree::ptree json;
336  		std::stringstream body (res.body ());
337  		boost::property_tree::read_json (body, json);
338  		promise.set_value (json);
339  	}
340  };
341  boost::property_tree::ptree rpc_request (boost::property_tree::ptree const & request, boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
342  {
343  	auto rpc_request = std::make_shared<rpc_request_impl> (request, ioc, results);
344  	boost::asio::strand<boost::asio::io_context::executor_type> strand{ ioc.get_executor () };
345  	boost::asio::post (strand,
346  	[rpc_request] () {
347  		rpc_request->start ();
348  	});
349  	return rpc_request->value_get ();
350  }
351  void keepalive_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, uint16_t port)
352  {
353  	boost::property_tree::ptree request;
354  	request.put ("action", "keepalive");
355  	request.put ("address", "::1");
356  	request.put ("port", port);
357  	rpc_request (request, ioc, results);
358  }
359  account key_create_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
360  {
361  	boost::property_tree::ptree request;
362  	request.put ("action", "key_create");
363  	auto json = rpc_request (request, ioc, results);
364  	account account_l;
365  	account_l.private_key = json.get<std::string> ("private");
366  	account_l.public_key = json.get<std::string> ("public");
367  	account_l.as_string = json.get<std::string> ("account");
368  	return account_l;
369  }
370  std::string wallet_create_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
371  {
372  	boost::property_tree::ptree request;
373  	request.put ("action", "wallet_create");
374  	auto json = rpc_request (request, ioc, results);
375  	return json.get<std::string> ("wallet");
376  }
377  void wallet_add_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, std::string const & wallet, std::string const & prv_key)
378  {
379  	boost::property_tree::ptree request;
380  	request.put ("action", "wallet_add");
381  	request.put ("wallet", wallet);
382  	request.put ("key", prv_key);
383  	rpc_request (request, ioc, results);
384  }
385  void stop_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results)
386  {
387  	boost::property_tree::ptree request;
388  	request.put ("action", "stop");
389  	rpc_request (request, ioc, results);
390  }
391  account_info account_info_rpc (boost::asio::io_context & ioc, tcp::resolver::results_type const & results, std::string const & account)
392  {
393  	boost::property_tree::ptree request;
394  	request.put ("action", "account_info");
395  	request.put ("account", account);
396  	account_info account_info;
397  	auto json = rpc_request (request, ioc, results);
398  	auto error = json.get_optional<std::string> ("error");
399  	if (error)
400  	{
401  		account_info.error = true;
402  	}
403  	else
404  	{
405  		account_info.balance = json.get<std::string> ("balance");
406  		account_info.block_count = json.get<std::string> ("block_count");
407  		account_info.frontier = json.get<std::string> ("frontier");
408  	}
409  	return account_info;
410  }
411  int main (int argc, char * const * argv)
412  {
<span onclick='openModal()' class='match'>413  	nano::force_nano_dev_network ();
414  	boost::program_options::options_description description ("Command line options");
415  	description.add_options ()
416  		("help", "Print out options")
417  		("node_count,n", boost::program_options::value<int> ()->default_value (10), "The number of nodes to spin up")
</span>418  		("send_count,s", boost::program_options::value<int> ()->default_value (2000), "How many send blocks to generate")
419  		("simultaneous_process_calls", boost::program_options::value<int> ()->default_value (20), "Number of simultaneous rpc sends to do")
420  		("destination_count", boost::program_options::value<int> ()->default_value (2), "How many destination accounts to choose between")
421  		("node_path", boost::program_options::value<std::string> (), "The path to the nano_node to test")
422  		("rpc_path", boost::program_options::value<std::string> (), "The path to the nano_rpc to test");
423  	boost::program_options::variables_map vm;
424  	try
425  	{
426  		boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
427  	}
428  	catch (boost::program_options::error const & err)
429  	{
430  		std::cerr << err.what () << std::endl;
431  		return 1;
432  	}
433  	boost::program_options::notify (vm);
434  	auto node_count = vm.find ("node_count")->second.as<int> ();
435  	auto destination_count = vm.find ("destination_count")->second.as<int> ();
436  	auto send_count = vm.find ("send_count")->second.as<int> ();
437  	auto simultaneous_process_calls = vm.find ("simultaneous_process_calls")->second.as<int> ();
438  	boost::system::error_code err;
439  	auto running_executable_filepath = boost::dll::program_location (err);
440  	auto node_path_it (vm.find ("node_path"));
441  	std::string node_path;
442  	if (node_path_it != vm.end ())
443  	{
444  		node_path = node_path_it->second.as<std::string> ();
445  	}
446  	else
447  	{
448  		auto node_filepath = running_executable_filepath.parent_path () / "nano_node";
449  		if (running_executable_filepath.has_extension ())
450  		{
451  			node_filepath.replace_extension (running_executable_filepath.extension ());
452  		}
453  		node_path = node_filepath.string ();
454  	}
455  	if (!boost::filesystem::exists (node_path))
456  	{
457  		std::cerr << "nano_node executable could not be found in " << node_path << std::endl;
458  		return 1;
459  	}
460  	auto rpc_path_it (vm.find ("rpc_path"));
461  	std::string rpc_path;
462  	if (rpc_path_it != vm.end ())
463  	{
464  		rpc_path = rpc_path_it->second.as<std::string> ();
465  	}
466  	else
467  	{
468  		auto rpc_filepath = running_executable_filepath.parent_path () / "nano_rpc";
469  		if (running_executable_filepath.has_extension ())
470  		{
471  			rpc_filepath.replace_extension (running_executable_filepath.extension ());
472  		}
473  		rpc_path = rpc_filepath.string ();
474  	}
475  	if (!boost::filesystem::exists (rpc_path))
476  	{
477  		std::cerr << "nano_rpc executable could not be found in " << rpc_path << std::endl;
478  		return 1;
479  	}
480  	std::vector<boost::filesystem::path> data_paths;
481  	for (auto i = 0; i < node_count; ++i)
482  	{
483  		auto data_path = nano::unique_path ();
484  		boost::filesystem::create_directory (data_path);
485  		write_config_files (data_path, i);
486  		data_paths.push_back (std::move (data_path));
487  	}
488  	auto current_network = nano::dev::network_params.network.get_current_network_as_string ();
489  	std::vector<std::unique_ptr<boost::process::child>> nodes;
490  	std::vector<std::unique_ptr<boost::process::child>> rpc_servers;
491  	for (auto const & data_path : data_paths)
492  	{
493  		nodes.emplace_back (std::make_unique<boost::process::child> (node_path, "--daemon", "--data_path", data_path.string (), "--network", current_network));
494  		rpc_servers.emplace_back (std::make_unique<boost::process::child> (rpc_path, "--daemon", "--data_path", data_path.string (), "--network", current_network));
495  	}
496  	std::cout << "Waiting for nodes to spin up..." << std::endl;
497  	std::this_thread::sleep_for (std::chrono::seconds (7));
498  	std::cout << "Connecting nodes..." << std::endl;
499  	boost::asio::io_context ioc;
500  	debug_assert (!nano::signal_handler_impl);
501  	nano::signal_handler_impl = [&ioc] () {
502  		ioc.stop ();
503  	};
504  	std::signal (SIGINT, &nano::signal_handler);
505  	std::signal (SIGTERM, &nano::signal_handler);
506  	tcp::resolver resolver{ ioc };
507  	auto const primary_node_results = resolver.resolve ("::1", std::to_string (rpc_port_start));
508  	std::thread t ([send_count, &ioc, &primary_node_results, &resolver, &node_count, &destination_count] () {
509  		for (int i = 0; i < node_count; ++i)
510  		{
511  			keepalive_rpc (ioc, primary_node_results, peering_port_start + i);
512  		}
513  		std::cout << "Beginning tests" << std::endl;
514  		std::vector<account> destination_accounts;
515  		for (int i = 0; i < destination_count; ++i)
516  		{
517  			destination_accounts.emplace_back (key_create_rpc (ioc, primary_node_results));
518  		}
519  		std::string wallet = wallet_create_rpc (ioc, primary_node_results);
520  		wallet_add_rpc (ioc, primary_node_results, wallet, nano::dev::genesis_key.prv.to_string ());
521  		for (auto & account : destination_accounts)
522  		{
523  			wallet_add_rpc (ioc, primary_node_results, wallet, account.private_key);
524  		}
525  		std::cout << "\rPrimary node processing transactions: 00%";
526  		std::random_device rd;
527  		std::mt19937 mt (rd ());
528  		std::uniform_int_distribution<size_t> dist (0, destination_accounts.size () - 1);
529  		std::atomic<int> send_calls_remaining{ send_count };
530  		for (auto i = 0; i < send_count; ++i)
531  		{
532  			account * destination_account;
533  			if (i < destination_accounts.size ())
534  			{
535  				destination_account = &destination_accounts[i];
536  			}
537  			else
538  			{
539  				auto random_account_index = dist (mt);
540  				destination_account = &destination_accounts[random_account_index];
541  			}
542  			auto send_receive = std::make_shared<send_receive_impl> (ioc, wallet, nano::dev::genesis->account ().to_account (), destination_account->as_string, send_calls_remaining, primary_node_results);
543  			boost::asio::strand<boost::asio::io_context::executor_type> strand{ ioc.get_executor () };
544  			boost::asio::post (strand,
545  			[send_receive] () {
546  				send_receive->start ();
547  			});
548  		}
549  		while (send_calls_remaining != 0)
550  		{
551  			static int last_percent = 0;
552  			auto percent = static_cast<int> (100 * ((send_count - send_calls_remaining) / static_cast<double> (send_count)));
553  			if (last_percent != percent)
554  			{
555  				std::cout << "\rPrimary node processing transactions: " << std::setfill ('0') << std::setw (2) << percent << "%";
556  				last_percent = percent;
557  			}
558  		}
559  		std::cout << "\rPrimary node processed transactions                " << std::endl;
560  		std::cout << "Waiting for nodes to catch up..." << std::endl;
561  		std::map<std::string, account_info> known_account_info;
562  		for (int i = 0; i < destination_accounts.size (); ++i)
563  		{
564  			known_account_info.emplace (destination_accounts[i].as_string, account_info_rpc (ioc, primary_node_results, destination_accounts[i].as_string));
565  		}
566  		nano::timer<std::chrono::milliseconds> timer;
567  		timer.start ();
568  		for (int i = 1; i < node_count; ++i)
569  		{
570  			auto const results = resolver.resolve ("::1", std::to_string (rpc_port_start + i));
571  			for (auto & account_info : known_account_info)
572  			{
573  				while (true)
574  				{
575  					auto other_account_info = account_info_rpc (ioc, results, account_info.first);
576  					if (!other_account_info.error && account_info.second == other_account_info)
577  					{
578  						break;
579  					}
580  					if (timer.since_start () > std::chrono::seconds (120))
581  					{
582  						throw std::runtime_error ("Timed out");
583  					}
584  					std::this_thread::sleep_for (std::chrono::seconds (1));
585  				}
586  			}
587  			stop_rpc (ioc, results);
588  		}
589  		stop_rpc (ioc, primary_node_results);
590  	});
591  	nano::thread_runner runner (ioc, simultaneous_process_calls);
592  	t.join ();
593  	runner.join ();
594  	for (auto & node : nodes)
595  	{
596  		node->wait ();
597  	}
598  	for (auto & rpc_server : rpc_servers)
599  	{
600  		rpc_server->wait ();
601  	}
602  	std::cout << "Done!" << std::endl;
603  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry.cpp</div>
                </div>
                <div class="column column_space"><pre><code>413  	nano::force_nano_dev_network ();
414  	boost::program_options::options_description description ("Command line options");
415  	description.add_options ()
416  		("help", "Print out options")
417  		("node_count,n", boost::program_options::value<int> ()->default_value (10), "The number of nodes to spin up")
</pre></code></div>
                <div class="column column_space"><pre><code>413  	nano::force_nano_dev_network ();
414  	boost::program_options::options_description description ("Command line options");
415  	description.add_options ()
416  		("help", "Print out options")
417  		("node_count,n", boost::program_options::value<int> ()->default_value (10), "The number of nodes to spin up")
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    