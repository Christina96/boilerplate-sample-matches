
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-proto.cc</h3>
            <pre><code>1  #include "absl/log/internal/proto.h"
2  #include <algorithm>
3  #include <cassert>
4  #include <cstddef>
5  #include <cstdint>
6  #include <cstring>
7  #include "absl/base/attributes.h"
8  #include "absl/base/config.h"
9  #include "absl/types/span.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace log_internal {
13  namespace {
14  void EncodeRawVarint(uint64_t value, size_t size, absl::Span<char> *buf) {
15    for (size_t s = 0; s < size; s++) {
16      (*buf)[s] = static_cast<char>((value & 0x7f) | (s + 1 == size ? 0 : 0x80));
17      value >>= 7;
18    }
19    buf->remove_prefix(size);
20  }
21  constexpr uint64_t MakeTagType(uint64_t tag, WireType type) {
22    return tag << 3 | static_cast<uint64_t>(type);
23  }
24  }  
25  bool EncodeVarint(uint64_t tag, uint64_t value, absl::Span<char> *buf) {
26    const uint64_t tag_type = MakeTagType(tag, WireType::kVarint);
27    const size_t tag_type_size = VarintSize(tag_type);
28    const size_t value_size = VarintSize(value);
29    if (tag_type_size + value_size > buf->size()) {
30      buf->remove_suffix(buf->size());
31      return false;
32    }
33    EncodeRawVarint(tag_type, tag_type_size, buf);
34    EncodeRawVarint(value, value_size, buf);
35    return true;
36  }
37  bool Encode64Bit(uint64_t tag, uint64_t value, absl::Span<char> *buf) {
38    const uint64_t tag_type = MakeTagType(tag, WireType::k64Bit);
39    const size_t tag_type_size = VarintSize(tag_type);
40    if (tag_type_size + sizeof(value) > buf->size()) {
41      buf->remove_suffix(buf->size());
42      return false;
43    }
44    EncodeRawVarint(tag_type, tag_type_size, buf);
45    for (size_t s = 0; s < sizeof(value); s++) {
46      (*buf)[s] = static_cast<char>(value & 0xff);
47      value >>= 8;
48    }
49    buf->remove_prefix(sizeof(value));
50    return true;
51  }
52  bool Encode32Bit(uint64_t tag, uint32_t value, absl::Span<char> *buf) {
53    const uint64_t tag_type = MakeTagType(tag, WireType::k32Bit);
54    const size_t tag_type_size = VarintSize(tag_type);
55    if (tag_type_size + sizeof(value) > buf->size()) {
56      buf->remove_suffix(buf->size());
57      return false;
58    }
59    EncodeRawVarint(tag_type, tag_type_size, buf);
60    for (size_t s = 0; s < sizeof(value); s++) {
61      (*buf)[s] = static_cast<char>(value & 0xff);
62      value >>= 8;
63    }
64    buf->remove_prefix(sizeof(value));
65    return true;
66  }
67  bool EncodeBytes(uint64_t tag, absl::Span<const char> value,
68                   absl::Span<char> *buf) {
69    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
70    const size_t tag_type_size = VarintSize(tag_type);
71    uint64_t length = value.size();
72    const size_t length_size = VarintSize(length);
73    if (tag_type_size + length_size + value.size() > buf->size()) {
74      buf->remove_suffix(buf->size());
75      return false;
76    }
77    EncodeRawVarint(tag_type, tag_type_size, buf);
78    EncodeRawVarint(length, length_size, buf);
79    memcpy(buf->data(), value.data(), value.size());
80    buf->remove_prefix(value.size());
81    return true;
82  }
83  bool EncodeBytesTruncate(uint64_t tag, absl::Span<const char> value,
84                           absl::Span<char> *buf) {
85    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
86    const size_t tag_type_size = VarintSize(tag_type);
87    uint64_t length = value.size();
88    const size_t length_size =
89        VarintSize(std::min<uint64_t>(length, buf->size()));
90    if (tag_type_size + length_size <= buf->size() &&
91        tag_type_size + length_size + value.size() > buf->size()) {
92      value.remove_suffix(tag_type_size + length_size + value.size() -
93                          buf->size());
94      length = value.size();
95    }
96    if (tag_type_size + length_size + value.size() > buf->size()) {
97      buf->remove_suffix(buf->size());
98      return false;
99    }
100    EncodeRawVarint(tag_type, tag_type_size, buf);
101    EncodeRawVarint(length, length_size, buf);
102    memcpy(buf->data(), value.data(), value.size());
<span onclick='openModal()' class='match'>103    buf->remove_prefix(value.size());
104    return true;
105  }
106  ABSL_MUST_USE_RESULT absl::Span<char> EncodeMessageStart(
</span>107      uint64_t tag, uint64_t max_size, absl::Span<char> *buf) {
108    const uint64_t tag_type = MakeTagType(tag, WireType::kLengthDelimited);
109    const size_t tag_type_size = VarintSize(tag_type);
110    max_size = std::min<uint64_t>(max_size, buf->size());
111    const size_t length_size = VarintSize(max_size);
112    if (tag_type_size + length_size > buf->size()) {
113      buf->remove_suffix(buf->size());
114      return absl::Span<char>();
115    }
116    EncodeRawVarint(tag_type, tag_type_size, buf);
117    const absl::Span<char> ret = buf->subspan(0, length_size);
118    EncodeRawVarint(0, length_size, buf);
119    return ret;
120  }
121  void EncodeMessageLength(absl::Span<char> msg, const absl::Span<char> *buf) {
122    if (!msg.data()) return;
123    assert(buf->data() >= msg.data());
124    if (buf->data() < msg.data()) return;
125    EncodeRawVarint(
126        static_cast<uint64_t>(buf->data() - (msg.data() + msg.size())),
127        msg.size(), &msg);
128  }
129  namespace {
130  uint64_t DecodeVarint(absl::Span<const char> *buf) {
131    uint64_t value = 0;
132    size_t s = 0;
133    while (s < buf->size()) {
134      value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]) & 0x7f)
135               << 7 * s;
136      if (!((*buf)[s++] & 0x80)) break;
137    }
138    buf->remove_prefix(s);
139    return value;
140  }
141  uint64_t Decode64Bit(absl::Span<const char> *buf) {
142    uint64_t value = 0;
143    size_t s = 0;
144    while (s < buf->size()) {
145      value |= static_cast<uint64_t>(static_cast<unsigned char>((*buf)[s]))
146               << 8 * s;
147      if (++s == sizeof(value)) break;
148    }
149    buf->remove_prefix(s);
150    return value;
151  }
152  uint32_t Decode32Bit(absl::Span<const char> *buf) {
153    uint32_t value = 0;
154    size_t s = 0;
155    while (s < buf->size()) {
156      value |= static_cast<uint32_t>(static_cast<unsigned char>((*buf)[s]))
157               << 8 * s;
158      if (++s == sizeof(value)) break;
159    }
160    buf->remove_prefix(s);
161    return value;
162  }
163  }  
164  bool ProtoField::DecodeFrom(absl::Span<const char> *data) {
165    if (data->empty()) return false;
166    const uint64_t tag_type = DecodeVarint(data);
167    tag_ = tag_type >> 3;
168    type_ = static_cast<WireType>(tag_type & 0x07);
169    switch (type_) {
170      case WireType::kVarint:
171        value_ = DecodeVarint(data);
172        break;
173      case WireType::k64Bit:
174        value_ = Decode64Bit(data);
175        break;
176      case WireType::kLengthDelimited: {
177        value_ = DecodeVarint(data);
178        data_ = data->subspan(
179            0, static_cast<size_t>(std::min<uint64_t>(value_, data->size())));
180        data->remove_prefix(data_.size());
181        break;
182      }
183      case WireType::k32Bit:
184        value_ = Decode32Bit(data);
185        break;
186    }
187    return true;
188  }
189  }  
190  ABSL_NAMESPACE_END
191  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</h3>
            <pre><code>1  #include "absl/strings/internal/str_format/arg.h"
2  #include <cassert>
3  #include <cerrno>
4  #include <cstdlib>
5  #include <string>
6  #include <type_traits>
7  #include "absl/base/port.h"
8  #include "absl/strings/internal/str_format/float_conversion.h"
9  #include "absl/strings/numbers.h"
10  namespace absl {
11  ABSL_NAMESPACE_BEGIN
12  namespace str_format_internal {
13  namespace {
14  void ReducePadding(string_view s, size_t *capacity) {
15    *capacity = Excess(s.size(), *capacity);
16  }
17  void ReducePadding(size_t n, size_t *capacity) {
18    *capacity = Excess(n, *capacity);
19  }
20  template <typename T>
21  struct MakeUnsigned : std::make_unsigned<T> {};
22  template <>
23  struct MakeUnsigned<absl::int128> {
24    using type = absl::uint128;
25  };
26  template <>
27  struct MakeUnsigned<absl::uint128> {
28    using type = absl::uint128;
29  };
30  template <typename T>
31  struct IsSigned : std::is_signed<T> {};
32  template <>
33  struct IsSigned<absl::int128> : std::true_type {};
34  template <>
35  struct IsSigned<absl::uint128> : std::false_type {};
36  class IntDigits {
37   public:
38    template <typename T>
39    void PrintAsOct(T v) {
40      static_assert(!IsSigned<T>::value, "");
41      char *p = storage_ + sizeof(storage_);
42      do {
43        *--p = static_cast<char>('0' + (static_cast<size_t>(v) & 7));
44        v >>= 3;
45      } while (v);
46      start_ = p;
47      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
48    }
49    template <typename T>
50    void PrintAsDec(T v) {
51      static_assert(std::is_integral<T>::value, "");
52      start_ = storage_;
53      size_ = static_cast<size_t>(numbers_internal::FastIntToBuffer(v, storage_) -
54                                  storage_);
55    }
56    void PrintAsDec(int128 v) {
57      auto u = static_cast<uint128>(v);
58      bool add_neg = false;
59      if (v < 0) {
60        add_neg = true;
61        u = uint128{} - u;
62      }
63      PrintAsDec(u, add_neg);
64    }
65    void PrintAsDec(uint128 v, bool add_neg = false) {
66      char *p = storage_ + sizeof(storage_);
67      do {
68        p -= 2;
69        numbers_internal::PutTwoDigits(static_cast<uint32_t>(v % 100), p);
70        v /= 100;
71      } while (v);
72      if (p[0] == '0') {
73        ++p;
74      }
75      if (add_neg) {
76        *--p = '-';
77      }
78      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
79      start_ = p;
80    }
81    template <typename T>
82    void PrintAsHexLower(T v) {
83      static_assert(!IsSigned<T>::value, "");
84      char *p = storage_ + sizeof(storage_);
85      do {
86        p -= 2;
87        constexpr const char* table = numbers_internal::kHexTable;
88        std::memcpy(p, table + 2 * (static_cast<size_t>(v) & 0xFF), 2);
89        if (sizeof(T) == 1) break;
90        v >>= 8;
91      } while (v);
92      if (p[0] == '0') {
93        ++p;
94      }
95      start_ = p;
96      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
97    }
98    template <typename T>
99    void PrintAsHexUpper(T v) {
100      static_assert(!IsSigned<T>::value, "");
101      char *p = storage_ + sizeof(storage_);
102      do {
103        *--p = "0123456789ABCDEF"[static_cast<size_t>(v) & 15];
104        v >>= 4;
105      } while (v);
106      start_ = p;
107      size_ = static_cast<size_t>(storage_ + sizeof(storage_) - p);
108    }
109    string_view with_neg_and_zero() const { return {start_, size_}; }
110    string_view without_neg_or_zero() const {
111      static_assert('-' < '0', "The check below verifies both.");
112      size_t advance = start_[0] <= '0' ? 1 : 0;
113      return {start_ + advance, size_ - advance};
114    }
115    bool is_negative() const { return start_[0] == '-'; }
116   private:
117    const char *start_;
118    size_t size_;
119    char storage_[128 / 3 + 1 + 1];
120  };
121  string_view BaseIndicator(const IntDigits &as_digits,
122                            const FormatConversionSpecImpl conv) {
123    bool alt = conv.has_alt_flag() ||
124               conv.conversion_char() == FormatConversionCharInternal::p;
125    bool hex = (conv.conversion_char() == FormatConversionCharInternal::x ||
126                conv.conversion_char() == FormatConversionCharInternal::X ||
127                conv.conversion_char() == FormatConversionCharInternal::p);
128    if (alt && hex && !as_digits.without_neg_or_zero().empty()) {
129      return conv.conversion_char() == FormatConversionCharInternal::X ? "0X"
130                                                                       : "0x";
131    }
132    return {};
133  }
134  string_view SignColumn(bool neg, const FormatConversionSpecImpl conv) {
135    if (conv.conversion_char() == FormatConversionCharInternal::d ||
136        conv.conversion_char() == FormatConversionCharInternal::i) {
137      if (neg) return "-";
138      if (conv.has_show_pos_flag()) return "+";
139      if (conv.has_sign_col_flag()) return " ";
140    }
141    return {};
142  }
143  bool ConvertCharImpl(char v,
144                       const FormatConversionSpecImpl conv,
145                       FormatSinkImpl* sink) {
146    size_t fill = 0;
147    if (conv.width() >= 0)
148      fill = static_cast<size_t>(conv.width());
149    ReducePadding(1, &fill);
150    if (!conv.has_left_flag()) sink->Append(fill, ' ');
151    sink->Append(1, v);
152    if (conv.has_left_flag()) sink->Append(fill, ' ');
153    return true;
154  }
155  bool ConvertIntImplInnerSlow(const IntDigits &as_digits,
156                               const FormatConversionSpecImpl conv,
157                               FormatSinkImpl *sink) {
158    size_t fill = 0;
159    if (conv.width() >= 0)
160      fill = static_cast<size_t>(conv.width());
161    string_view formatted = as_digits.without_neg_or_zero();
162    ReducePadding(formatted, &fill);
163    string_view sign = SignColumn(as_digits.is_negative(), conv);
164    ReducePadding(sign, &fill);
165    string_view base_indicator = BaseIndicator(as_digits, conv);
166    ReducePadding(base_indicator, &fill);
167    bool precision_specified = conv.precision() >= 0;
168    size_t precision =
169        precision_specified ? static_cast<size_t>(conv.precision()) : size_t{1};
170    if (conv.has_alt_flag() &&
171        conv.conversion_char() == FormatConversionCharInternal::o) {
172      if (formatted.empty() || *formatted.begin() != '0') {
173        size_t needed = formatted.size() + 1;
174        precision = std::max(precision, needed);
175      }
176    }
177    size_t num_zeroes = Excess(formatted.size(), precision);
178    ReducePadding(num_zeroes, &fill);
179    size_t num_left_spaces = !conv.has_left_flag() ? fill : 0;
180    size_t num_right_spaces = conv.has_left_flag() ? fill : 0;
181    if (!precision_specified && conv.has_zero_flag()) {
182      num_zeroes += num_left_spaces;
183      num_left_spaces = 0;
184    }
185    sink->Append(num_left_spaces, ' ');
186    sink->Append(sign);
187    sink->Append(base_indicator);
188    sink->Append(num_zeroes, '0');
189    sink->Append(formatted);
190    sink->Append(num_right_spaces, ' ');
191    return true;
192  }
193  template <typename T>
194  bool ConvertFloatArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
195    if (conv.conversion_char() == FormatConversionCharInternal::v) {
196      conv.set_conversion_char(FormatConversionCharInternal::g);
197    }
198    return FormatConversionCharIsFloat(conv.conversion_char()) &&
199           ConvertFloatImpl(v, conv, sink);
200  }
201  inline bool ConvertStringArg(string_view v, const FormatConversionSpecImpl conv,
202                               FormatSinkImpl *sink) {
203    if (conv.is_basic()) {
204      sink->Append(v);
205      return true;
206    }
207    return sink->PutPaddedString(v, conv.width(), conv.precision(),
208                                 conv.has_left_flag());
209  }
210  }  
211  bool ConvertBoolArg(bool v, FormatSinkImpl *sink) {
212    if (v) {
213      sink->Append("true");
214    } else {
215      sink->Append("false");
216    }
217    return true;
218  }
219  template <typename T>
220  bool ConvertIntArg(T v, FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
221    using U = typename MakeUnsigned<T>::type;
222    IntDigits as_digits;
223    switch (static_cast<uint8_t>(conv.conversion_char())) {
224      case static_cast<uint8_t>(FormatConversionCharInternal::c):
225        return ConvertCharImpl(static_cast<char>(v), conv, sink);
226      case static_cast<uint8_t>(FormatConversionCharInternal::o):
227        as_digits.PrintAsOct(static_cast<U>(v));
228        break;
229      case static_cast<uint8_t>(FormatConversionCharInternal::x):
230        as_digits.PrintAsHexLower(static_cast<U>(v));
231        break;
232      case static_cast<uint8_t>(FormatConversionCharInternal::X):
233        as_digits.PrintAsHexUpper(static_cast<U>(v));
234        break;
235      case static_cast<uint8_t>(FormatConversionCharInternal::u):
236        as_digits.PrintAsDec(static_cast<U>(v));
237        break;
238      case static_cast<uint8_t>(FormatConversionCharInternal::d):
239      case static_cast<uint8_t>(FormatConversionCharInternal::i):
240      case static_cast<uint8_t>(FormatConversionCharInternal::v):
241        as_digits.PrintAsDec(v);
242        break;
243      case static_cast<uint8_t>(FormatConversionCharInternal::a):
244      case static_cast<uint8_t>(FormatConversionCharInternal::e):
245      case static_cast<uint8_t>(FormatConversionCharInternal::f):
246      case static_cast<uint8_t>(FormatConversionCharInternal::g):
247      case static_cast<uint8_t>(FormatConversionCharInternal::A):
248      case static_cast<uint8_t>(FormatConversionCharInternal::E):
249      case static_cast<uint8_t>(FormatConversionCharInternal::F):
250      case static_cast<uint8_t>(FormatConversionCharInternal::G):
251        return ConvertFloatImpl(static_cast<double>(v), conv, sink);
252      default:
253        ABSL_ASSUME(false);
254    }
255    if (conv.is_basic()) {
<span onclick='openModal()' class='match'>256      sink->Append(as_digits.with_neg_and_zero());
257      return true;
258    }
259    return ConvertIntImplInnerSlow(as_digits, conv, sink);
</span>260  }
261  template bool ConvertIntArg<char>(char v, FormatConversionSpecImpl conv,
262                                    FormatSinkImpl *sink);
263  template bool ConvertIntArg<signed char>(signed char v,
264                                           FormatConversionSpecImpl conv,
265                                           FormatSinkImpl *sink);
266  template bool ConvertIntArg<unsigned char>(unsigned char v,
267                                             FormatConversionSpecImpl conv,
268                                             FormatSinkImpl *sink);
269  template bool ConvertIntArg<short>(short v,  
270                                     FormatConversionSpecImpl conv,
271                                     FormatSinkImpl *sink);
272  template bool ConvertIntArg<unsigned short>(unsigned short v,  
273                                              FormatConversionSpecImpl conv,
274                                              FormatSinkImpl *sink);
275  template bool ConvertIntArg<int>(int v, FormatConversionSpecImpl conv,
276                                   FormatSinkImpl *sink);
277  template bool ConvertIntArg<unsigned int>(unsigned int v,
278                                            FormatConversionSpecImpl conv,
279                                            FormatSinkImpl *sink);
280  template bool ConvertIntArg<long>(long v,  
281                                    FormatConversionSpecImpl conv,
282                                    FormatSinkImpl *sink);
283  template bool ConvertIntArg<unsigned long>(unsigned long v,  
284                                             FormatConversionSpecImpl conv,
285                                             FormatSinkImpl *sink);
286  template bool ConvertIntArg<long long>(long long v,  
287                                         FormatConversionSpecImpl conv,
288                                         FormatSinkImpl *sink);
289  template bool ConvertIntArg<unsigned long long>(unsigned long long v,  
290                                                  FormatConversionSpecImpl conv,
291                                                  FormatSinkImpl *sink);
292  StringConvertResult FormatConvertImpl(const std::string &v,
293                                        const FormatConversionSpecImpl conv,
294                                        FormatSinkImpl *sink) {
295    return {ConvertStringArg(v, conv, sink)};
296  }
297  StringConvertResult FormatConvertImpl(string_view v,
298                                        const FormatConversionSpecImpl conv,
299                                        FormatSinkImpl *sink) {
300    return {ConvertStringArg(v, conv, sink)};
301  }
302  ArgConvertResult<FormatConversionCharSetUnion(
303      FormatConversionCharSetInternal::s, FormatConversionCharSetInternal::p)>
304  FormatConvertImpl(const char *v, const FormatConversionSpecImpl conv,
305                    FormatSinkImpl *sink) {
306    if (conv.conversion_char() == FormatConversionCharInternal::p)
307      return {FormatConvertImpl(VoidPtr(v), conv, sink).value};
308    size_t len;
309    if (v == nullptr) {
310      len = 0;
311    } else if (conv.precision() < 0) {
312      len = std::strlen(v);
313    } else {
314      len = static_cast<size_t>(std::find(v, v + conv.precision(), '\0') - v);
315    }
316    return {ConvertStringArg(string_view(v, len), conv, sink)};
317  }
318  ArgConvertResult<FormatConversionCharSetInternal::p> FormatConvertImpl(
319      VoidPtr v, const FormatConversionSpecImpl conv, FormatSinkImpl *sink) {
320    if (!v.value) {
321      sink->Append("(nil)");
322      return {true};
323    }
324    IntDigits as_digits;
325    as_digits.PrintAsHexLower(v.value);
326    return {ConvertIntImplInnerSlow(as_digits, conv, sink)};
327  }
328  FloatingConvertResult FormatConvertImpl(float v,
329                                          const FormatConversionSpecImpl conv,
330                                          FormatSinkImpl *sink) {
331    return {ConvertFloatArg(v, conv, sink)};
332  }
333  FloatingConvertResult FormatConvertImpl(double v,
334                                          const FormatConversionSpecImpl conv,
335                                          FormatSinkImpl *sink) {
336    return {ConvertFloatArg(v, conv, sink)};
337  }
338  FloatingConvertResult FormatConvertImpl(long double v,
339                                          const FormatConversionSpecImpl conv,
340                                          FormatSinkImpl *sink) {
341    return {ConvertFloatArg(v, conv, sink)};
342  }
343  CharConvertResult FormatConvertImpl(char v, const FormatConversionSpecImpl conv,
344                                      FormatSinkImpl *sink) {
345    return {ConvertIntArg(v, conv, sink)};
346  }
347  IntegralConvertResult FormatConvertImpl(signed char v,
348                                          const FormatConversionSpecImpl conv,
349                                          FormatSinkImpl *sink) {
350    return {ConvertIntArg(v, conv, sink)};
351  }
352  IntegralConvertResult FormatConvertImpl(unsigned char v,
353                                          const FormatConversionSpecImpl conv,
354                                          FormatSinkImpl *sink) {
355    return {ConvertIntArg(v, conv, sink)};
356  }
357  IntegralConvertResult FormatConvertImpl(short v,  
358                                          const FormatConversionSpecImpl conv,
359                                          FormatSinkImpl *sink) {
360    return {ConvertIntArg(v, conv, sink)};
361  }
362  IntegralConvertResult FormatConvertImpl(unsigned short v,  
363                                          const FormatConversionSpecImpl conv,
364                                          FormatSinkImpl *sink) {
365    return {ConvertIntArg(v, conv, sink)};
366  }
367  IntegralConvertResult FormatConvertImpl(int v,
368                                          const FormatConversionSpecImpl conv,
369                                          FormatSinkImpl *sink) {
370    return {ConvertIntArg(v, conv, sink)};
371  }
372  IntegralConvertResult FormatConvertImpl(unsigned v,
373                                          const FormatConversionSpecImpl conv,
374                                          FormatSinkImpl *sink) {
375    return {ConvertIntArg(v, conv, sink)};
376  }
377  IntegralConvertResult FormatConvertImpl(long v,  
378                                          const FormatConversionSpecImpl conv,
379                                          FormatSinkImpl *sink) {
380    return {ConvertIntArg(v, conv, sink)};
381  }
382  IntegralConvertResult FormatConvertImpl(unsigned long v,  
383                                          const FormatConversionSpecImpl conv,
384                                          FormatSinkImpl *sink) {
385    return {ConvertIntArg(v, conv, sink)};
386  }
387  IntegralConvertResult FormatConvertImpl(long long v,  
388                                          const FormatConversionSpecImpl conv,
389                                          FormatSinkImpl *sink) {
390    return {ConvertIntArg(v, conv, sink)};
391  }
392  IntegralConvertResult FormatConvertImpl(unsigned long long v,  
393                                          const FormatConversionSpecImpl conv,
394                                          FormatSinkImpl *sink) {
395    return {ConvertIntArg(v, conv, sink)};
396  }
397  IntegralConvertResult FormatConvertImpl(absl::int128 v,
398                                          const FormatConversionSpecImpl conv,
399                                          FormatSinkImpl *sink) {
400    return {ConvertIntArg(v, conv, sink)};
401  }
402  IntegralConvertResult FormatConvertImpl(absl::uint128 v,
403                                          const FormatConversionSpecImpl conv,
404                                          FormatSinkImpl *sink) {
405    return {ConvertIntArg(v, conv, sink)};
406  }
407  ABSL_INTERNAL_FORMAT_DISPATCH_OVERLOADS_EXPAND_();
408  }  
409  ABSL_NAMESPACE_END
410  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-proto.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-arg.cc</div>
                </div>
                <div class="column column_space"><pre><code>103    buf->remove_prefix(value.size());
104    return true;
105  }
106  ABSL_MUST_USE_RESULT absl::Span<char> EncodeMessageStart(
</pre></code></div>
                <div class="column column_space"><pre><code>256      sink->Append(as_digits.with_neg_and_zero());
257      return true;
258    }
259    return ConvertIntImplInnerSlow(as_digits, conv, sink);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    