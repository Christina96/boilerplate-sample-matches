
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "blobbox.h"
6  #include "crakedge.h" 
7  #include "edgblob.h"
8  #include "linefind.h"
9  #include "tabvector.h"
10  #if defined(USE_OPENCL)
11  #  include "openclwrapper.h" 
12  #endif
13  #include <algorithm>
14  namespace tesseract {
15  const int kThinLineFraction = 20;
16  const int kMinLineLengthFraction = 4;
17  const int kCrackSpacing = 100;
18  const int kLineFindGridSize = 50;
19  const int kMinThickLineWidth = 12;
20  const int kMaxLineResidue = 6;
21  const double kThickLengthMultiple = 0.75;
22  const double kMaxNonLineDensity = 0.25;
23  const double kMaxStaveHeight = 1.0;
24  const double kMinMusicPixelFraction = 0.75;
25  static void RemoveUnusedLineSegments(bool horizontal_lines, BLOBNBOX_LIST *line_bblobs,
26                                       Image line_pix) {
27    int height = pixGetHeight(line_pix);
28    BLOBNBOX_IT bbox_it(line_bblobs);
29    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
30      BLOBNBOX *blob = bbox_it.data();
31      if (blob->left_tab_type() != TT_VLINE) {
32        const TBOX &box = blob->bounding_box();
33        Box *pixbox = nullptr;
34        if (horizontal_lines) {
35          pixbox = boxCreate(box.bottom(), height - box.right(), box.height(), box.width());
36        } else {
37          pixbox = boxCreate(box.left(), height - box.top(), box.width(), box.height());
38        }
39        pixClearInRect(line_pix, pixbox);
40        boxDestroy(&pixbox);
41      }
42    }
43  }
44  static void SubtractLinesAndResidue(Image line_pix, Image non_line_pix,
45                                      Image src_pix) {
46    pixSubtract(src_pix, src_pix, line_pix);
47    Image residue_pix = pixSubtract(nullptr, src_pix, non_line_pix);
48    Image fat_line_pix = pixDilateBrick(nullptr, line_pix, 3, 3);
49    pixSeedfillBinary(fat_line_pix, fat_line_pix, residue_pix, 8);
50    pixSubtract(src_pix, src_pix, fat_line_pix);
51    fat_line_pix.destroy();
52    residue_pix.destroy();
53  }
54  static int MaxStrokeWidth(Image pix) {
55    Image dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);
56    int width = pixGetWidth(dist_pix);
57    int height = pixGetHeight(dist_pix);
58    int wpl = pixGetWpl(dist_pix);
59    l_uint32 *data = pixGetData(dist_pix);
60    int max_dist = 0;
61    for (int y = 0; y < height; ++y) {
62      for (int x = 0; x < width; ++x) {
63        int pixel = GET_DATA_BYTE(data, x);
64        if (pixel > max_dist) {
65          max_dist = pixel;
66        }
67      }
68      data += wpl;
69    }
70    dist_pix.destroy();
71    return max_dist * 2;
72  }
73  static int NumTouchingIntersections(Box *line_box, Image intersection_pix) {
74    if (intersection_pix == nullptr) {
75      return 0;
76    }
77    Image rect_pix = pixClipRectangle(intersection_pix, line_box, nullptr);
78    Boxa *boxa = pixConnComp(rect_pix, nullptr, 8);
79    rect_pix.destroy();
80    if (boxa == nullptr) {
81      return false;
82    }
83    int result = boxaGetCount(boxa);
84    boxaDestroy(&boxa);
85    return result;
86  }
87  static int CountPixelsAdjacentToLine(int line_width, Box *line_box, Image nonline_pix) {
88    l_int32 x, y, box_width, box_height;
89    boxGetGeometry(line_box, &x, &y, &box_width, &box_height);
90    if (box_width > box_height) {
91      int bottom = std::min(pixGetHeight(nonline_pix), y + box_height + line_width);
92      y = std::max(0, y - line_width);
93      box_height = bottom - y;
94    } else {
95      int right = std::min(pixGetWidth(nonline_pix), x + box_width + line_width);
96      x = std::max(0, x - line_width);
97      box_width = right - x;
98    }
99    Box *box = boxCreate(x, y, box_width, box_height);
100    Image rect_pix = pixClipRectangle(nonline_pix, box, nullptr);
101    boxDestroy(&box);
102    l_int32 result;
103    pixCountPixels(rect_pix, &result, nullptr);
104    rect_pix.destroy();
105    return result;
106  }
107  static int FilterFalsePositives(int resolution, Image nonline_pix, Image intersection_pix,
108                                  Image line_pix) {
109    int min_thick_length = static_cast<int>(resolution * kThickLengthMultiple);
110    Pixa *pixa = nullptr;
111    Boxa *boxa = pixConnComp(line_pix, &pixa, 8);
112    int nboxes = boxaGetCount(boxa);
113    int remaining_boxes = nboxes;
114    for (int i = 0; i < nboxes; ++i) {
115      Box *box = boxaGetBox(boxa, i, L_CLONE);
116      l_int32 x, y, box_width, box_height;
117      boxGetGeometry(box, &x, &y, &box_width, &box_height);
118      Image comp_pix = pixaGetPix(pixa, i, L_CLONE);
119      int max_width = MaxStrokeWidth(comp_pix);
120      comp_pix.destroy();
121      bool bad_line = false;
122      if (box_width >= kMinThickLineWidth && box_height >= kMinThickLineWidth &&
123          box_width < min_thick_length && box_height < min_thick_length &&
124          max_width > kMinThickLineWidth) {
125        bad_line = true;
126      }
127      if (!bad_line && (NumTouchingIntersections(box, intersection_pix) < 2)) {
128        int nonline_count = CountPixelsAdjacentToLine(max_width, box, nonline_pix);
129        if (nonline_count > box_height * box_width * kMaxNonLineDensity) {
130          bad_line = true;
131        }
132      }
133      if (bad_line) {
134        pixClearInRect(line_pix, box);
135        --remaining_boxes;
136      }
137      boxDestroy(&box);
138    }
139    pixaDestroy(&pixa);
140    boxaDestroy(&boxa);
141    return remaining_boxes;
142  }
143  static void ConvertBoxaToBlobs(int image_width, int image_height, Boxa **boxes,
144                                 C_BLOB_LIST *blobs) {
145    C_OUTLINE_LIST outlines;
146    C_OUTLINE_IT ol_it = &outlines;
147    int nboxes = boxaGetCount(*boxes);
148    for (int i = 0; i < nboxes; ++i) {
149      l_int32 x, y, width, height;
150      boxaGetBoxGeometry(*boxes, i, &x, &y, &width, &height);
151      ICOORD top_left(x, y);
152      ICOORD bot_right(x + width, y + height);
153      CRACKEDGE startpt;
154      startpt.pos = top_left;
155      auto *outline = new C_OUTLINE(&startpt, top_left, bot_right, 0);
156      ol_it.add_after_then_move(outline);
157    }
158    BLOCK block;
159    ICOORD page_tl(0, 0);
160    ICOORD page_br(image_width, image_height);
161    outlines_to_blobs(&block, page_tl, page_br, &outlines);
162    C_BLOB_IT blob_it(blobs);
163    blob_it.add_list_after(block.blob_list());
164    boxaDestroy(boxes);
165  }
166  static void GetLineBoxes(bool horizontal_lines, Image pix_lines, Image pix_intersections,
167                           C_BLOB_LIST *line_cblobs, BLOBNBOX_LIST *line_bblobs) {
168    int wpl = pixGetWpl(pix_lines);
169    int width = pixGetWidth(pix_lines);
170    int height = pixGetHeight(pix_lines);
171    l_uint32 *data = pixGetData(pix_lines);
172    if (horizontal_lines) {
173      for (int y = 0; y < height; ++y, data += wpl) {
174        for (int x = kCrackSpacing; x < width; x += kCrackSpacing) {
175          CLEAR_DATA_BIT(data, x);
176        }
177      }
178    } else {
179      for (int y = kCrackSpacing; y < height; y += kCrackSpacing) {
180        memset(data + wpl * y, 0, wpl * sizeof(*data));
181      }
182    }
183    Boxa *boxa = pixConnComp(pix_lines, nullptr, 8);
184    ConvertBoxaToBlobs(width, height, &boxa, line_cblobs);
185    C_BLOB_IT blob_it(line_cblobs);
186    BLOBNBOX_IT bbox_it(line_bblobs);
187    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
188      C_BLOB *cblob = blob_it.data();
189      auto *bblob = new BLOBNBOX(cblob);
190      bbox_it.add_to_end(bblob);
191      const TBOX &bbox = bblob->bounding_box();
192      Box *box = boxCreate(bbox.left(), bbox.bottom(), bbox.width(), bbox.height());
193      bblob->set_line_crossings(NumTouchingIntersections(box, pix_intersections));
194      boxDestroy(&box);
195      if (horizontal_lines) {
196        TBOX new_box(height - bbox.top(), bbox.left(), height - bbox.bottom(), bbox.right());
197        bblob->set_bounding_box(new_box);
198      } else {
199        TBOX new_box(bbox.left(), height - bbox.top(), bbox.right(), height - bbox.bottom());
200        bblob->set_bounding_box(new_box);
201      }
202    }
203  }
204  static void FindLineVectors(const ICOORD &bleft, const ICOORD &tright,
205                              BLOBNBOX_LIST *line_bblobs, int *vertical_x, int *vertical_y,
206                              TabVector_LIST *vectors) {
207    BLOBNBOX_IT bbox_it(line_bblobs);
208    int b_count = 0;
209    AlignedBlob blob_grid(kLineFindGridSize, bleft, tright);
210    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
211      BLOBNBOX *bblob = bbox_it.data();
212      bblob->set_left_tab_type(TT_MAYBE_ALIGNED);
213      bblob->set_left_rule(bleft.x());
214      bblob->set_right_rule(tright.x());
215      bblob->set_left_crossing_rule(bleft.x());
216      bblob->set_right_crossing_rule(tright.x());
217      blob_grid.InsertBBox(false, true, bblob);
218      ++b_count;
219    }
220    if (b_count == 0) {
221      return;
222    }
223    BlobGridSearch lsearch(&blob_grid);
224    BLOBNBOX *bbox;
225    TabVector_IT vector_it(vectors);
226    *vertical_x = 0;
227    *vertical_y = 1;
228    lsearch.StartFullSearch();
229    while ((bbox = lsearch.NextFullSearch()) != nullptr) {
230      if (bbox->left_tab_type() == TT_MAYBE_ALIGNED) {
231        const TBOX &box = bbox->bounding_box();
232        if (AlignedBlob::WithinTestRegion(2, box.left(), box.bottom())) {
233          tprintf("Finding line vector starting at bbox (%d,%d)\n", box.left(), box.bottom());
234        }
235        AlignedBlobParams align_params(*vertical_x, *vertical_y, box.width());
236        TabVector *vector =
237            blob_grid.FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
238        if (vector != nullptr) {
239          vector->Freeze();
240          vector_it.add_to_end(vector);
241        }
242      }
243    }
244  }
245  static Image FilterMusic(int resolution, Image pix_closed, Image pix_vline, Image pix_hline,
246                          bool &v_empty, bool &h_empty) {
247    int max_stave_height = static_cast<int>(resolution * kMaxStaveHeight);
248    Image intersection_pix = pix_vline & pix_hline;
249    Boxa *boxa = pixConnComp(pix_vline, nullptr, 8);
250    int nboxes = boxaGetCount(boxa);
251    Image music_mask = nullptr;
252    for (int i = 0; i < nboxes; ++i) {
253      Box *box = boxaGetBox(boxa, i, L_CLONE);
254      l_int32 x, y, box_width, box_height;
255      boxGetGeometry(box, &x, &y, &box_width, &box_height);
256      int joins = NumTouchingIntersections(box, intersection_pix);
257      if (joins >= 5 && (joins - 1) * max_stave_height >= 4 * box_height) {
258        if (music_mask == nullptr) {
259          music_mask = pixCreate(pixGetWidth(pix_vline), pixGetHeight(pix_vline), 1);
260        }
261        pixSetInRect(music_mask, box);
262      }
263      boxDestroy(&box);
264    }
265    boxaDestroy(&boxa);
266    intersection_pix.destroy();
267    if (music_mask != nullptr) {
268      pixSeedfillBinary(music_mask, music_mask, pix_closed, 8);
269      Boxa *boxa = pixConnComp(music_mask, nullptr, 8);
270      int nboxes = boxaGetCount(boxa);
271      for (int i = 0; i < nboxes; ++i) {
272        Box *box = boxaGetBox(boxa, i, L_CLONE);
273        Image rect_pix = pixClipRectangle(music_mask, box, nullptr);
274        l_int32 music_pixels;
275        pixCountPixels(rect_pix, &music_pixels, nullptr);
276        rect_pix.destroy();
277        rect_pix = pixClipRectangle(pix_closed, box, nullptr);
278        l_int32 all_pixels;
279        pixCountPixels(rect_pix, &all_pixels, nullptr);
280        rect_pix.destroy();
281        if (music_pixels < kMinMusicPixelFraction * all_pixels) {
282          pixClearInRect(music_mask, box);
283        }
284        boxDestroy(&box);
285      }
286      boxaDestroy(&boxa);
287      if (music_mask.isZero()) {
288        music_mask.destroy();
289      } else {
290        pixSubtract(pix_vline, pix_vline, music_mask);
291        pixSubtract(pix_hline, pix_hline, music_mask);
292        v_empty = pix_vline.isZero();
293        h_empty = pix_hline.isZero();
294      }
295    }
296    return music_mask;
297  }
298  static void GetLineMasks(int resolution, Image src_pix, Image *pix_vline, Image *pix_non_vline,
299                           Image *pix_hline, Image *pix_non_hline, Image *pix_intersections,
300                           Image *pix_music_mask, Pixa *pixa_display) {
301    Image pix_closed = nullptr;
302    Image pix_hollow = nullptr;
303    int max_line_width = resolution / kThinLineFraction;
304    int min_line_length = resolution / kMinLineLengthFraction;
305    if (pixa_display != nullptr) {
306      tprintf("Image resolution = %d, max line width = %d, min length=%d\n", resolution,
307              max_line_width, min_line_length);
308    }
309    int closing_brick = max_line_width / 3;
310  #ifdef USE_OPENCL
311    if (OpenclDevice::selectedDeviceIsOpenCL()) {
312      int clStatus =
313          OpenclDevice::initMorphCLAllocations(pixGetWpl(src_pix), pixGetHeight(src_pix), src_pix);
314      bool getpixclosed = pix_music_mask != nullptr;
315      OpenclDevice::pixGetLinesCL(nullptr, src_pix, pix_vline, pix_hline, &pix_closed, getpixclosed,
316                                  closing_brick, closing_brick, max_line_width, max_line_width,
317                                  min_line_length, min_line_length);
318    } else {
319  #endif
320      pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
321      if (pixa_display != nullptr) {
322        pixaAddPix(pixa_display, pix_closed, L_CLONE);
323      }
324      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
325      if (pixa_display != nullptr) {
326        pixaAddPix(pixa_display, pix_solid, L_CLONE);
327      }
328      pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
329      pix_solid.destroy();
330      if (pixa_display != nullptr) {
331        pixaAddPix(pixa_display, pix_hollow, L_CLONE);
332      }
333      *pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
334      *pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
335      pix_hollow.destroy();
336  #ifdef USE_OPENCL
337    }
338  #endif
339    bool v_empty = pix_vline->isZero();
340    bool h_empty = pix_hline->isZero();
341    if (pix_music_mask != nullptr) {
342      if (!v_empty && !h_empty) {
343        *pix_music_mask =
344            FilterMusic(resolution, pix_closed, *pix_vline, *pix_hline, v_empty, h_empty);
345      } else {
346        *pix_music_mask = nullptr;
347      }
348    }
349    pix_closed.destroy();
350    Image pix_nonlines = nullptr;
351    *pix_intersections = nullptr;
352    Image extra_non_hlines = nullptr;
353    if (!v_empty) {
354      pix_nonlines = pixSubtract(nullptr, src_pix, *pix_vline);
355      if (!h_empty) {
356        pixSubtract(pix_nonlines, pix_nonlines, *pix_hline);
357        *pix_intersections = *pix_vline & *pix_hline;
358        extra_non_hlines = pixSubtract(nullptr, *pix_vline, *pix_intersections);
359      }
360      *pix_non_vline = pixErodeBrick(nullptr, pix_nonlines, kMaxLineResidue, 1);
361      pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
362      if (!h_empty) {
363        *pix_non_vline |= *pix_hline;
364        pixSubtract(*pix_non_vline, *pix_non_vline, *pix_intersections);
365      }
366      if (!FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections, *pix_vline)) {
367        pix_vline->destroy(); 
368      }
369    } else {
370      pix_vline->destroy();
371      *pix_non_vline = nullptr;
372      if (!h_empty) {
373        pix_nonlines = pixSubtract(nullptr, src_pix, *pix_hline);
374      }
375    }
376    if (h_empty) {
377      pix_hline->destroy();
378      *pix_non_hline = nullptr;
379      if (v_empty) {
380        return;
381      }
382    } else {
383      *pix_non_hline = pixErodeBrick(nullptr, pix_nonlines, 1, kMaxLineResidue);
384      pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
385      if (extra_non_hlines != nullptr) {
386        *pix_non_hline |= extra_non_hlines;
387        extra_non_hlines.destroy();
388      }
389      if (!FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections, *pix_hline)) {
390        pix_hline->destroy(); 
391      }
392    }
393    if (pixa_display != nullptr) {
394      if (*pix_vline != nullptr) {
395        pixaAddPix(pixa_display, *pix_vline, L_CLONE);
396      }
397      if (*pix_hline != nullptr) {
398        pixaAddPix(pixa_display, *pix_hline, L_CLONE);
399      }
400      if (pix_nonlines != nullptr) {
401        pixaAddPix(pixa_display, pix_nonlines, L_CLONE);
402      }
403      if (*pix_non_vline != nullptr) {
404        pixaAddPix(pixa_display, *pix_non_vline, L_CLONE);
405      }
406      if (*pix_non_hline != nullptr) {
407        pixaAddPix(pixa_display, *pix_non_hline, L_CLONE);
408      }
409      if (*pix_intersections != nullptr) {
410        pixaAddPix(pixa_display, *pix_intersections, L_CLONE);
411      }
412      if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
413        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
414      }
415    }
416    pix_nonlines.destroy();
417  }
418  static void FindAndRemoveVLines(Image pix_intersections, int *vertical_x,
419                                  int *vertical_y, Image *pix_vline, Image pix_non_vline,
420                                  Image src_pix, TabVector_LIST *vectors) {
421    if (pix_vline == nullptr || *pix_vline == nullptr) {
422      return;
423    }
424    C_BLOB_LIST line_cblobs;
425    BLOBNBOX_LIST line_bblobs;
426    GetLineBoxes(false, *pix_vline, pix_intersections, &line_cblobs, &line_bblobs);
427    int width = pixGetWidth(src_pix);
428    int height = pixGetHeight(src_pix);
<span onclick='openModal()' class='match'>429    ICOORD bleft(0, 0);
430    ICOORD tright(width, height);
431    FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
</span>432    if (!vectors->empty()) {
433      RemoveUnusedLineSegments(false, &line_bblobs, *pix_vline);
434      SubtractLinesAndResidue(*pix_vline, pix_non_vline, src_pix);
435      ICOORD vertical;
436      vertical.set_with_shrink(*vertical_x, *vertical_y);
437      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
438    } else {
439      pix_vline->destroy();
440    }
441  }
442  static void FindAndRemoveHLines(Image pix_intersections, int vertical_x,
443                                  int vertical_y, Image *pix_hline, Image pix_non_hline,
444                                  Image src_pix, TabVector_LIST *vectors) {
445    if (pix_hline == nullptr || *pix_hline == nullptr) {
446      return;
447    }
448    C_BLOB_LIST line_cblobs;
449    BLOBNBOX_LIST line_bblobs;
450    GetLineBoxes(true, *pix_hline, pix_intersections, &line_cblobs, &line_bblobs);
451    int width = pixGetWidth(src_pix);
452    int height = pixGetHeight(src_pix);
453    ICOORD bleft(0, 0);
454    ICOORD tright(height, width);
455    FindLineVectors(bleft, tright, &line_bblobs, &vertical_x, &vertical_y, vectors);
456    if (!vectors->empty()) {
457      RemoveUnusedLineSegments(true, &line_bblobs, *pix_hline);
458      SubtractLinesAndResidue(*pix_hline, pix_non_hline, src_pix);
459      ICOORD vertical;
460      vertical.set_with_shrink(vertical_x, vertical_y);
461      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
462      TabVector_IT h_it(vectors);
463      for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
464        h_it.data()->XYFlip();
465      }
466    } else {
467      pix_hline->destroy();
468    }
469  }
470  void LineFinder::FindAndRemoveLines(int resolution, bool debug, Image pix, int *vertical_x,
471                                      int *vertical_y, Image *pix_music_mask, TabVector_LIST *v_lines,
472                                      TabVector_LIST *h_lines) {
473    if (pix == nullptr || vertical_x == nullptr || vertical_y == nullptr) {
474      tprintf("Error in parameters for LineFinder::FindAndRemoveLines\n");
475      return;
476    }
477    Image pix_vline = nullptr;
478    Image pix_non_vline = nullptr;
479    Image pix_hline = nullptr;
480    Image pix_non_hline = nullptr;
481    Image pix_intersections = nullptr;
482    Pixa *pixa_display = debug ? pixaCreate(0) : nullptr;
483    GetLineMasks(resolution, pix, &pix_vline, &pix_non_vline, &pix_hline, &pix_non_hline,
484                 &pix_intersections, pix_music_mask, pixa_display);
485    FindAndRemoveVLines(pix_intersections, vertical_x, vertical_y, &pix_vline,
486                        pix_non_vline, pix, v_lines);
487    pix_intersections.destroy();
488    if (pix_hline != nullptr) {
489      if (pix_vline != nullptr) {
490        pix_intersections = pix_vline & pix_hline;
491      }
492      if (!FilterFalsePositives(resolution, pix_non_hline, pix_intersections, pix_hline)) {
493        pix_hline.destroy();
494      }
495    }
496    FindAndRemoveHLines(pix_intersections, *vertical_x, *vertical_y, &pix_hline,
497                        pix_non_hline, pix, h_lines);
498    if (pixa_display != nullptr && pix_vline != nullptr) {
499      pixaAddPix(pixa_display, pix_vline, L_CLONE);
500    }
501    if (pixa_display != nullptr && pix_hline != nullptr) {
502      pixaAddPix(pixa_display, pix_hline, L_CLONE);
503    }
504    pix_intersections.destroy();
505    if (pix_vline != nullptr && pix_hline != nullptr) {
506      pix_intersections = pix_vline & pix_hline;
507      Image pix_join_residue = pixDilateBrick(nullptr, pix_intersections, 5, 5);
508      pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
509      pixSubtract(pix, pix, pix_join_residue);
510      pix_join_residue.destroy();
511    }
512    if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
513      if (pixa_display != nullptr) {
514        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
515      }
516      pixSubtract(pix, pix, *pix_music_mask);
517    }
518    if (pixa_display != nullptr) {
519      pixaAddPix(pixa_display, pix, L_CLONE);
520    }
521    pix_vline.destroy();
522    pix_non_vline.destroy();
523    pix_hline.destroy();
524    pix_non_hline.destroy();
525    pix_intersections.destroy();
526    if (pixa_display != nullptr) {
527      pixaConvertToPdf(pixa_display, resolution, 1.0f, 0, 0, "LineFinding", "vhlinefinding.pdf");
528      pixaDestroy(&pixa_display);
529    }
530  }
531  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "alignedblob.h"
5  #include "blobbox.h"
6  #include "crakedge.h" 
7  #include "edgblob.h"
8  #include "linefind.h"
9  #include "tabvector.h"
10  #if defined(USE_OPENCL)
11  #  include "openclwrapper.h" 
12  #endif
13  #include <algorithm>
14  namespace tesseract {
15  const int kThinLineFraction = 20;
16  const int kMinLineLengthFraction = 4;
17  const int kCrackSpacing = 100;
18  const int kLineFindGridSize = 50;
19  const int kMinThickLineWidth = 12;
20  const int kMaxLineResidue = 6;
21  const double kThickLengthMultiple = 0.75;
22  const double kMaxNonLineDensity = 0.25;
23  const double kMaxStaveHeight = 1.0;
24  const double kMinMusicPixelFraction = 0.75;
25  static void RemoveUnusedLineSegments(bool horizontal_lines, BLOBNBOX_LIST *line_bblobs,
26                                       Image line_pix) {
27    int height = pixGetHeight(line_pix);
28    BLOBNBOX_IT bbox_it(line_bblobs);
29    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
30      BLOBNBOX *blob = bbox_it.data();
31      if (blob->left_tab_type() != TT_VLINE) {
32        const TBOX &box = blob->bounding_box();
33        Box *pixbox = nullptr;
34        if (horizontal_lines) {
35          pixbox = boxCreate(box.bottom(), height - box.right(), box.height(), box.width());
36        } else {
37          pixbox = boxCreate(box.left(), height - box.top(), box.width(), box.height());
38        }
39        pixClearInRect(line_pix, pixbox);
40        boxDestroy(&pixbox);
41      }
42    }
43  }
44  static void SubtractLinesAndResidue(Image line_pix, Image non_line_pix,
45                                      Image src_pix) {
46    pixSubtract(src_pix, src_pix, line_pix);
47    Image residue_pix = pixSubtract(nullptr, src_pix, non_line_pix);
48    Image fat_line_pix = pixDilateBrick(nullptr, line_pix, 3, 3);
49    pixSeedfillBinary(fat_line_pix, fat_line_pix, residue_pix, 8);
50    pixSubtract(src_pix, src_pix, fat_line_pix);
51    fat_line_pix.destroy();
52    residue_pix.destroy();
53  }
54  static int MaxStrokeWidth(Image pix) {
55    Image dist_pix = pixDistanceFunction(pix, 4, 8, L_BOUNDARY_BG);
56    int width = pixGetWidth(dist_pix);
57    int height = pixGetHeight(dist_pix);
58    int wpl = pixGetWpl(dist_pix);
59    l_uint32 *data = pixGetData(dist_pix);
60    int max_dist = 0;
61    for (int y = 0; y < height; ++y) {
62      for (int x = 0; x < width; ++x) {
63        int pixel = GET_DATA_BYTE(data, x);
64        if (pixel > max_dist) {
65          max_dist = pixel;
66        }
67      }
68      data += wpl;
69    }
70    dist_pix.destroy();
71    return max_dist * 2;
72  }
73  static int NumTouchingIntersections(Box *line_box, Image intersection_pix) {
74    if (intersection_pix == nullptr) {
75      return 0;
76    }
77    Image rect_pix = pixClipRectangle(intersection_pix, line_box, nullptr);
78    Boxa *boxa = pixConnComp(rect_pix, nullptr, 8);
79    rect_pix.destroy();
80    if (boxa == nullptr) {
81      return false;
82    }
83    int result = boxaGetCount(boxa);
84    boxaDestroy(&boxa);
85    return result;
86  }
87  static int CountPixelsAdjacentToLine(int line_width, Box *line_box, Image nonline_pix) {
88    l_int32 x, y, box_width, box_height;
89    boxGetGeometry(line_box, &x, &y, &box_width, &box_height);
90    if (box_width > box_height) {
91      int bottom = std::min(pixGetHeight(nonline_pix), y + box_height + line_width);
92      y = std::max(0, y - line_width);
93      box_height = bottom - y;
94    } else {
95      int right = std::min(pixGetWidth(nonline_pix), x + box_width + line_width);
96      x = std::max(0, x - line_width);
97      box_width = right - x;
98    }
99    Box *box = boxCreate(x, y, box_width, box_height);
100    Image rect_pix = pixClipRectangle(nonline_pix, box, nullptr);
101    boxDestroy(&box);
102    l_int32 result;
103    pixCountPixels(rect_pix, &result, nullptr);
104    rect_pix.destroy();
105    return result;
106  }
107  static int FilterFalsePositives(int resolution, Image nonline_pix, Image intersection_pix,
108                                  Image line_pix) {
109    int min_thick_length = static_cast<int>(resolution * kThickLengthMultiple);
110    Pixa *pixa = nullptr;
111    Boxa *boxa = pixConnComp(line_pix, &pixa, 8);
112    int nboxes = boxaGetCount(boxa);
113    int remaining_boxes = nboxes;
114    for (int i = 0; i < nboxes; ++i) {
115      Box *box = boxaGetBox(boxa, i, L_CLONE);
116      l_int32 x, y, box_width, box_height;
117      boxGetGeometry(box, &x, &y, &box_width, &box_height);
118      Image comp_pix = pixaGetPix(pixa, i, L_CLONE);
119      int max_width = MaxStrokeWidth(comp_pix);
120      comp_pix.destroy();
121      bool bad_line = false;
122      if (box_width >= kMinThickLineWidth && box_height >= kMinThickLineWidth &&
123          box_width < min_thick_length && box_height < min_thick_length &&
124          max_width > kMinThickLineWidth) {
125        bad_line = true;
126      }
127      if (!bad_line && (NumTouchingIntersections(box, intersection_pix) < 2)) {
128        int nonline_count = CountPixelsAdjacentToLine(max_width, box, nonline_pix);
129        if (nonline_count > box_height * box_width * kMaxNonLineDensity) {
130          bad_line = true;
131        }
132      }
133      if (bad_line) {
134        pixClearInRect(line_pix, box);
135        --remaining_boxes;
136      }
137      boxDestroy(&box);
138    }
139    pixaDestroy(&pixa);
140    boxaDestroy(&boxa);
141    return remaining_boxes;
142  }
143  static void ConvertBoxaToBlobs(int image_width, int image_height, Boxa **boxes,
144                                 C_BLOB_LIST *blobs) {
145    C_OUTLINE_LIST outlines;
146    C_OUTLINE_IT ol_it = &outlines;
147    int nboxes = boxaGetCount(*boxes);
148    for (int i = 0; i < nboxes; ++i) {
149      l_int32 x, y, width, height;
150      boxaGetBoxGeometry(*boxes, i, &x, &y, &width, &height);
151      ICOORD top_left(x, y);
152      ICOORD bot_right(x + width, y + height);
153      CRACKEDGE startpt;
154      startpt.pos = top_left;
155      auto *outline = new C_OUTLINE(&startpt, top_left, bot_right, 0);
156      ol_it.add_after_then_move(outline);
157    }
158    BLOCK block;
<span onclick='openModal()' class='match'>159    ICOORD page_tl(0, 0);
160    ICOORD page_br(image_width, image_height);
161    outlines_to_blobs(&block, page_tl, page_br, &outlines);
</span>162    C_BLOB_IT blob_it(blobs);
163    blob_it.add_list_after(block.blob_list());
164    boxaDestroy(boxes);
165  }
166  static void GetLineBoxes(bool horizontal_lines, Image pix_lines, Image pix_intersections,
167                           C_BLOB_LIST *line_cblobs, BLOBNBOX_LIST *line_bblobs) {
168    int wpl = pixGetWpl(pix_lines);
169    int width = pixGetWidth(pix_lines);
170    int height = pixGetHeight(pix_lines);
171    l_uint32 *data = pixGetData(pix_lines);
172    if (horizontal_lines) {
173      for (int y = 0; y < height; ++y, data += wpl) {
174        for (int x = kCrackSpacing; x < width; x += kCrackSpacing) {
175          CLEAR_DATA_BIT(data, x);
176        }
177      }
178    } else {
179      for (int y = kCrackSpacing; y < height; y += kCrackSpacing) {
180        memset(data + wpl * y, 0, wpl * sizeof(*data));
181      }
182    }
183    Boxa *boxa = pixConnComp(pix_lines, nullptr, 8);
184    ConvertBoxaToBlobs(width, height, &boxa, line_cblobs);
185    C_BLOB_IT blob_it(line_cblobs);
186    BLOBNBOX_IT bbox_it(line_bblobs);
187    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
188      C_BLOB *cblob = blob_it.data();
189      auto *bblob = new BLOBNBOX(cblob);
190      bbox_it.add_to_end(bblob);
191      const TBOX &bbox = bblob->bounding_box();
192      Box *box = boxCreate(bbox.left(), bbox.bottom(), bbox.width(), bbox.height());
193      bblob->set_line_crossings(NumTouchingIntersections(box, pix_intersections));
194      boxDestroy(&box);
195      if (horizontal_lines) {
196        TBOX new_box(height - bbox.top(), bbox.left(), height - bbox.bottom(), bbox.right());
197        bblob->set_bounding_box(new_box);
198      } else {
199        TBOX new_box(bbox.left(), height - bbox.top(), bbox.right(), height - bbox.bottom());
200        bblob->set_bounding_box(new_box);
201      }
202    }
203  }
204  static void FindLineVectors(const ICOORD &bleft, const ICOORD &tright,
205                              BLOBNBOX_LIST *line_bblobs, int *vertical_x, int *vertical_y,
206                              TabVector_LIST *vectors) {
207    BLOBNBOX_IT bbox_it(line_bblobs);
208    int b_count = 0;
209    AlignedBlob blob_grid(kLineFindGridSize, bleft, tright);
210    for (bbox_it.mark_cycle_pt(); !bbox_it.cycled_list(); bbox_it.forward()) {
211      BLOBNBOX *bblob = bbox_it.data();
212      bblob->set_left_tab_type(TT_MAYBE_ALIGNED);
213      bblob->set_left_rule(bleft.x());
214      bblob->set_right_rule(tright.x());
215      bblob->set_left_crossing_rule(bleft.x());
216      bblob->set_right_crossing_rule(tright.x());
217      blob_grid.InsertBBox(false, true, bblob);
218      ++b_count;
219    }
220    if (b_count == 0) {
221      return;
222    }
223    BlobGridSearch lsearch(&blob_grid);
224    BLOBNBOX *bbox;
225    TabVector_IT vector_it(vectors);
226    *vertical_x = 0;
227    *vertical_y = 1;
228    lsearch.StartFullSearch();
229    while ((bbox = lsearch.NextFullSearch()) != nullptr) {
230      if (bbox->left_tab_type() == TT_MAYBE_ALIGNED) {
231        const TBOX &box = bbox->bounding_box();
232        if (AlignedBlob::WithinTestRegion(2, box.left(), box.bottom())) {
233          tprintf("Finding line vector starting at bbox (%d,%d)\n", box.left(), box.bottom());
234        }
235        AlignedBlobParams align_params(*vertical_x, *vertical_y, box.width());
236        TabVector *vector =
237            blob_grid.FindVerticalAlignment(align_params, bbox, vertical_x, vertical_y);
238        if (vector != nullptr) {
239          vector->Freeze();
240          vector_it.add_to_end(vector);
241        }
242      }
243    }
244  }
245  static Image FilterMusic(int resolution, Image pix_closed, Image pix_vline, Image pix_hline,
246                          bool &v_empty, bool &h_empty) {
247    int max_stave_height = static_cast<int>(resolution * kMaxStaveHeight);
248    Image intersection_pix = pix_vline & pix_hline;
249    Boxa *boxa = pixConnComp(pix_vline, nullptr, 8);
250    int nboxes = boxaGetCount(boxa);
251    Image music_mask = nullptr;
252    for (int i = 0; i < nboxes; ++i) {
253      Box *box = boxaGetBox(boxa, i, L_CLONE);
254      l_int32 x, y, box_width, box_height;
255      boxGetGeometry(box, &x, &y, &box_width, &box_height);
256      int joins = NumTouchingIntersections(box, intersection_pix);
257      if (joins >= 5 && (joins - 1) * max_stave_height >= 4 * box_height) {
258        if (music_mask == nullptr) {
259          music_mask = pixCreate(pixGetWidth(pix_vline), pixGetHeight(pix_vline), 1);
260        }
261        pixSetInRect(music_mask, box);
262      }
263      boxDestroy(&box);
264    }
265    boxaDestroy(&boxa);
266    intersection_pix.destroy();
267    if (music_mask != nullptr) {
268      pixSeedfillBinary(music_mask, music_mask, pix_closed, 8);
269      Boxa *boxa = pixConnComp(music_mask, nullptr, 8);
270      int nboxes = boxaGetCount(boxa);
271      for (int i = 0; i < nboxes; ++i) {
272        Box *box = boxaGetBox(boxa, i, L_CLONE);
273        Image rect_pix = pixClipRectangle(music_mask, box, nullptr);
274        l_int32 music_pixels;
275        pixCountPixels(rect_pix, &music_pixels, nullptr);
276        rect_pix.destroy();
277        rect_pix = pixClipRectangle(pix_closed, box, nullptr);
278        l_int32 all_pixels;
279        pixCountPixels(rect_pix, &all_pixels, nullptr);
280        rect_pix.destroy();
281        if (music_pixels < kMinMusicPixelFraction * all_pixels) {
282          pixClearInRect(music_mask, box);
283        }
284        boxDestroy(&box);
285      }
286      boxaDestroy(&boxa);
287      if (music_mask.isZero()) {
288        music_mask.destroy();
289      } else {
290        pixSubtract(pix_vline, pix_vline, music_mask);
291        pixSubtract(pix_hline, pix_hline, music_mask);
292        v_empty = pix_vline.isZero();
293        h_empty = pix_hline.isZero();
294      }
295    }
296    return music_mask;
297  }
298  static void GetLineMasks(int resolution, Image src_pix, Image *pix_vline, Image *pix_non_vline,
299                           Image *pix_hline, Image *pix_non_hline, Image *pix_intersections,
300                           Image *pix_music_mask, Pixa *pixa_display) {
301    Image pix_closed = nullptr;
302    Image pix_hollow = nullptr;
303    int max_line_width = resolution / kThinLineFraction;
304    int min_line_length = resolution / kMinLineLengthFraction;
305    if (pixa_display != nullptr) {
306      tprintf("Image resolution = %d, max line width = %d, min length=%d\n", resolution,
307              max_line_width, min_line_length);
308    }
309    int closing_brick = max_line_width / 3;
310  #ifdef USE_OPENCL
311    if (OpenclDevice::selectedDeviceIsOpenCL()) {
312      int clStatus =
313          OpenclDevice::initMorphCLAllocations(pixGetWpl(src_pix), pixGetHeight(src_pix), src_pix);
314      bool getpixclosed = pix_music_mask != nullptr;
315      OpenclDevice::pixGetLinesCL(nullptr, src_pix, pix_vline, pix_hline, &pix_closed, getpixclosed,
316                                  closing_brick, closing_brick, max_line_width, max_line_width,
317                                  min_line_length, min_line_length);
318    } else {
319  #endif
320      pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
321      if (pixa_display != nullptr) {
322        pixaAddPix(pixa_display, pix_closed, L_CLONE);
323      }
324      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
325      if (pixa_display != nullptr) {
326        pixaAddPix(pixa_display, pix_solid, L_CLONE);
327      }
328      pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
329      pix_solid.destroy();
330      if (pixa_display != nullptr) {
331        pixaAddPix(pixa_display, pix_hollow, L_CLONE);
332      }
333      *pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
334      *pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
335      pix_hollow.destroy();
336  #ifdef USE_OPENCL
337    }
338  #endif
339    bool v_empty = pix_vline->isZero();
340    bool h_empty = pix_hline->isZero();
341    if (pix_music_mask != nullptr) {
342      if (!v_empty && !h_empty) {
343        *pix_music_mask =
344            FilterMusic(resolution, pix_closed, *pix_vline, *pix_hline, v_empty, h_empty);
345      } else {
346        *pix_music_mask = nullptr;
347      }
348    }
349    pix_closed.destroy();
350    Image pix_nonlines = nullptr;
351    *pix_intersections = nullptr;
352    Image extra_non_hlines = nullptr;
353    if (!v_empty) {
354      pix_nonlines = pixSubtract(nullptr, src_pix, *pix_vline);
355      if (!h_empty) {
356        pixSubtract(pix_nonlines, pix_nonlines, *pix_hline);
357        *pix_intersections = *pix_vline & *pix_hline;
358        extra_non_hlines = pixSubtract(nullptr, *pix_vline, *pix_intersections);
359      }
360      *pix_non_vline = pixErodeBrick(nullptr, pix_nonlines, kMaxLineResidue, 1);
361      pixSeedfillBinary(*pix_non_vline, *pix_non_vline, pix_nonlines, 8);
362      if (!h_empty) {
363        *pix_non_vline |= *pix_hline;
364        pixSubtract(*pix_non_vline, *pix_non_vline, *pix_intersections);
365      }
366      if (!FilterFalsePositives(resolution, *pix_non_vline, *pix_intersections, *pix_vline)) {
367        pix_vline->destroy(); 
368      }
369    } else {
370      pix_vline->destroy();
371      *pix_non_vline = nullptr;
372      if (!h_empty) {
373        pix_nonlines = pixSubtract(nullptr, src_pix, *pix_hline);
374      }
375    }
376    if (h_empty) {
377      pix_hline->destroy();
378      *pix_non_hline = nullptr;
379      if (v_empty) {
380        return;
381      }
382    } else {
383      *pix_non_hline = pixErodeBrick(nullptr, pix_nonlines, 1, kMaxLineResidue);
384      pixSeedfillBinary(*pix_non_hline, *pix_non_hline, pix_nonlines, 8);
385      if (extra_non_hlines != nullptr) {
386        *pix_non_hline |= extra_non_hlines;
387        extra_non_hlines.destroy();
388      }
389      if (!FilterFalsePositives(resolution, *pix_non_hline, *pix_intersections, *pix_hline)) {
390        pix_hline->destroy(); 
391      }
392    }
393    if (pixa_display != nullptr) {
394      if (*pix_vline != nullptr) {
395        pixaAddPix(pixa_display, *pix_vline, L_CLONE);
396      }
397      if (*pix_hline != nullptr) {
398        pixaAddPix(pixa_display, *pix_hline, L_CLONE);
399      }
400      if (pix_nonlines != nullptr) {
401        pixaAddPix(pixa_display, pix_nonlines, L_CLONE);
402      }
403      if (*pix_non_vline != nullptr) {
404        pixaAddPix(pixa_display, *pix_non_vline, L_CLONE);
405      }
406      if (*pix_non_hline != nullptr) {
407        pixaAddPix(pixa_display, *pix_non_hline, L_CLONE);
408      }
409      if (*pix_intersections != nullptr) {
410        pixaAddPix(pixa_display, *pix_intersections, L_CLONE);
411      }
412      if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
413        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
414      }
415    }
416    pix_nonlines.destroy();
417  }
418  static void FindAndRemoveVLines(Image pix_intersections, int *vertical_x,
419                                  int *vertical_y, Image *pix_vline, Image pix_non_vline,
420                                  Image src_pix, TabVector_LIST *vectors) {
421    if (pix_vline == nullptr || *pix_vline == nullptr) {
422      return;
423    }
424    C_BLOB_LIST line_cblobs;
425    BLOBNBOX_LIST line_bblobs;
426    GetLineBoxes(false, *pix_vline, pix_intersections, &line_cblobs, &line_bblobs);
427    int width = pixGetWidth(src_pix);
428    int height = pixGetHeight(src_pix);
429    ICOORD bleft(0, 0);
430    ICOORD tright(width, height);
431    FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
432    if (!vectors->empty()) {
433      RemoveUnusedLineSegments(false, &line_bblobs, *pix_vline);
434      SubtractLinesAndResidue(*pix_vline, pix_non_vline, src_pix);
435      ICOORD vertical;
436      vertical.set_with_shrink(*vertical_x, *vertical_y);
437      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
438    } else {
439      pix_vline->destroy();
440    }
441  }
442  static void FindAndRemoveHLines(Image pix_intersections, int vertical_x,
443                                  int vertical_y, Image *pix_hline, Image pix_non_hline,
444                                  Image src_pix, TabVector_LIST *vectors) {
445    if (pix_hline == nullptr || *pix_hline == nullptr) {
446      return;
447    }
448    C_BLOB_LIST line_cblobs;
449    BLOBNBOX_LIST line_bblobs;
450    GetLineBoxes(true, *pix_hline, pix_intersections, &line_cblobs, &line_bblobs);
451    int width = pixGetWidth(src_pix);
452    int height = pixGetHeight(src_pix);
453    ICOORD bleft(0, 0);
454    ICOORD tright(height, width);
455    FindLineVectors(bleft, tright, &line_bblobs, &vertical_x, &vertical_y, vectors);
456    if (!vectors->empty()) {
457      RemoveUnusedLineSegments(true, &line_bblobs, *pix_hline);
458      SubtractLinesAndResidue(*pix_hline, pix_non_hline, src_pix);
459      ICOORD vertical;
460      vertical.set_with_shrink(vertical_x, vertical_y);
461      TabVector::MergeSimilarTabVectors(vertical, vectors, nullptr);
462      TabVector_IT h_it(vectors);
463      for (h_it.mark_cycle_pt(); !h_it.cycled_list(); h_it.forward()) {
464        h_it.data()->XYFlip();
465      }
466    } else {
467      pix_hline->destroy();
468    }
469  }
470  void LineFinder::FindAndRemoveLines(int resolution, bool debug, Image pix, int *vertical_x,
471                                      int *vertical_y, Image *pix_music_mask, TabVector_LIST *v_lines,
472                                      TabVector_LIST *h_lines) {
473    if (pix == nullptr || vertical_x == nullptr || vertical_y == nullptr) {
474      tprintf("Error in parameters for LineFinder::FindAndRemoveLines\n");
475      return;
476    }
477    Image pix_vline = nullptr;
478    Image pix_non_vline = nullptr;
479    Image pix_hline = nullptr;
480    Image pix_non_hline = nullptr;
481    Image pix_intersections = nullptr;
482    Pixa *pixa_display = debug ? pixaCreate(0) : nullptr;
483    GetLineMasks(resolution, pix, &pix_vline, &pix_non_vline, &pix_hline, &pix_non_hline,
484                 &pix_intersections, pix_music_mask, pixa_display);
485    FindAndRemoveVLines(pix_intersections, vertical_x, vertical_y, &pix_vline,
486                        pix_non_vline, pix, v_lines);
487    pix_intersections.destroy();
488    if (pix_hline != nullptr) {
489      if (pix_vline != nullptr) {
490        pix_intersections = pix_vline & pix_hline;
491      }
492      if (!FilterFalsePositives(resolution, pix_non_hline, pix_intersections, pix_hline)) {
493        pix_hline.destroy();
494      }
495    }
496    FindAndRemoveHLines(pix_intersections, *vertical_x, *vertical_y, &pix_hline,
497                        pix_non_hline, pix, h_lines);
498    if (pixa_display != nullptr && pix_vline != nullptr) {
499      pixaAddPix(pixa_display, pix_vline, L_CLONE);
500    }
501    if (pixa_display != nullptr && pix_hline != nullptr) {
502      pixaAddPix(pixa_display, pix_hline, L_CLONE);
503    }
504    pix_intersections.destroy();
505    if (pix_vline != nullptr && pix_hline != nullptr) {
506      pix_intersections = pix_vline & pix_hline;
507      Image pix_join_residue = pixDilateBrick(nullptr, pix_intersections, 5, 5);
508      pixSeedfillBinary(pix_join_residue, pix_join_residue, pix, 8);
509      pixSubtract(pix, pix, pix_join_residue);
510      pix_join_residue.destroy();
511    }
512    if (pix_music_mask != nullptr && *pix_music_mask != nullptr) {
513      if (pixa_display != nullptr) {
514        pixaAddPix(pixa_display, *pix_music_mask, L_CLONE);
515      }
516      pixSubtract(pix, pix, *pix_music_mask);
517    }
518    if (pixa_display != nullptr) {
519      pixaAddPix(pixa_display, pix, L_CLONE);
520    }
521    pix_vline.destroy();
522    pix_non_vline.destroy();
523    pix_hline.destroy();
524    pix_non_hline.destroy();
525    pix_intersections.destroy();
526    if (pixa_display != nullptr) {
527      pixaConvertToPdf(pixa_display, resolution, 1.0f, 0, 0, "LineFinding", "vhlinefinding.pdf");
528      pixaDestroy(&pixa_display);
529    }
530  }
531  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-linefind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>429    ICOORD bleft(0, 0);
430    ICOORD tright(width, height);
431    FindLineVectors(bleft, tright, &line_bblobs, vertical_x, vertical_y, vectors);
</pre></code></div>
                <div class="column column_space"><pre><code>159    ICOORD page_tl(0, 0);
160    ICOORD page_br(image_width, image_height);
161    outlines_to_blobs(&block, page_tl, page_br, &outlines);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    