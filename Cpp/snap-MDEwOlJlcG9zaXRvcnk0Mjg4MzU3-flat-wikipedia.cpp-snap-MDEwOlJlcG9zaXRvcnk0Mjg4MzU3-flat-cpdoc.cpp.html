
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikipedia.cpp</h3>
            <pre><code>1  #include "wikipedia.h"
2  PWikiDoc LoadXml(const PXmlDoc& XmlDoc){
3    return NULL;
4  }
<span onclick='openModal()' class='match'>5  PWikiBs TWikiBs::LoadBin(const TStr& FNm){
6    return NULL;
7  }
8  void TWikiBs::SaveBin(const TStr& FNm){
</span>9  }
10  PWikiBs TWikiBs::LoadXml(const TStr& FNm){
11    PSIn SIn=TFIn::New(FNm);
12    TXmlDoc::SkipTopTag(SIn);
13    PXmlDoc XmlDoc; int XmlDocs=0;
14    forever{
15      XmlDocs++;
16      if (XmlDocs%1000==0){
17        printf("%d Docs\r", XmlDocs);
18      }
19      XmlDoc=TXmlDoc::LoadTxt(SIn);
20      if (!XmlDoc->IsOk()){break;}
21    }
22    return NULL;
23  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cpdoc.cpp</h3>
            <pre><code>1  TStr TCpDoc::GetTxtStr() const {
2    TChA ChA;
3    ChA+=GetTitleStr(); ChA+=". ";
4    for (int ParN=0; ParN<GetPars(); ParN++){
5      if (ParN>0){ChA+=' ';}
6      ChA+=GetParStr(ParN);
7    }
8    return ChA;
9  }
10  TStr TCpDoc::GetHtmlStr() const {
11    TChA ChA;
12    ChA+="<HTML>\n";
13    ChA+="<HEAD><TITLE>"; ChA+=GetTitleStr(); ChA+="</TITLE></HEAD>\n";
14    ChA+="<BODY>\n";
15    ChA+="<H1>"; ChA+=GetTitleStr(); ChA+="</H1>\n";
16    for (int ParN=0; ParN<GetPars(); ParN++){
17      ChA+="<P>";
18      ChA+=GetParStr(ParN);
19      ChA+="</P>\n";
20    }
21    ChA+="</BODY>\n";
22    ChA+="</HTML>\n";
23    return ChA;
24  }
25  TStr TCpDoc::GetAllParStr() const {
26    TChA ChA;
27    for (int ParN=0; ParN<GetPars(); ParN++){
28      if (ParN>0){ChA+=' ';}
29      ChA+=GetParStr(ParN);
30    }
31    return ChA;
32  }
33  PSIn TCpDoc::FFirstCpd(const TStr& FNm){
34    PSIn SIn=TFIn::New(FNm);
35    return SIn;
36  }
<span onclick='openModal()' class='match'>37  PSIn TCpDoc::FFirstCpd(const PSIn& SIn){
38    return SIn;
39  }
40  bool TCpDoc::FNextCpd(const PSIn& SIn, PCpDoc& CpDoc){
</span>41    if (SIn->Eof()){
42      CpDoc=NULL; return false;
43    } else {
44      CpDoc=TCpDoc::Load(*SIn); return true;
45    }
46  }
47  PCpDoc TCpDoc::LoadHtmlDoc(const TStr& FNm){
48    PCpDoc CpDoc=TCpDoc::New();
49    PSIn HtmlSIn=TFIn::New(FNm);
50    TStr HtmlStr=TStr::LoadTxt(HtmlSIn);
51    CpDoc->DocNm=FNm;
52    CpDoc->ParStrV.Add(HtmlStr);
53    return CpDoc;
54  }
55  void TCpDoc::SaveHtmlToCpd(
56   const TStr& InHtmlFPath, const TStr& OutCpdFNm,
57   const bool& &bsol;*RecurseDirP*/, const int& MxDocs){
58    PSOut SOut=TFOut::New(OutCpdFNm);
59    TStrV FPathV; FPathV.Add(InHtmlFPath);
60    TStrV FExtV; FExtV.Add("html"); FExtV.Add("htm"); FExtV.Add("xml");
61    TFFile FFile(FPathV, FExtV, "", true); TStr FNm;
62    printf("Processing '%s' ...\n", InHtmlFPath.CStr());
63    int Docs=0;
64    while (FFile.Next(FNm)){
65      if ((MxDocs!=-1)&&(FFile.GetFNmN()>MxDocs)){break;}
66      Docs++; if (FFile.GetFNmN()%10==0){printf("%d\r", Docs);}
67      PCpDoc CpDoc=TCpDoc::LoadHtmlDoc(FNm);
68      CpDoc->Save(*SOut);
69    }
70    printf("%d\nDone.\n", Docs);
71  }
72  void TCpDoc::SaveTBsToCpd(
73   const TStr& InTBsFNm, const TStr& OutCpdFNm, const int& &bsol;*MxDocs*/){
74    TStr TxtBsNm=InTBsFNm.GetFBase();
75    TStr TxtBsFPath=InTBsFNm.GetFPath();
76    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
77    PSOut SOut=TFOut::New(OutCpdFNm);
78    TBlobPt TrvBlobPt=TxtBs->FFirstDocId(); TBlobPt DocId;
79    int DocN=0; TStr DocNm; TStr DocStr;
80    while (TxtBs->FNextDocId(TrvBlobPt, DocId)){
81      DocN++; if (DocN%100==0){printf("%d docs\r", DocN);}
82      TxtBs->GetDocNmStr(DocId, DocNm, DocStr);
83      PCpDoc CpDoc=TCpDoc::New();
84      CpDoc->DocNm=DocNm;
85      CpDoc->ParStrV.Add(DocStr, 1);
86      CpDoc->Save(*SOut);
87    }
88  }
89  void TCpDoc::SaveLnDocToCpd(
90   const TStr& LnDocFNm, const TStr& OutCpdFNm, const bool& NamedP, const int& MxDocs){
91    printf("Saving Line-Document '%s' to '%s' ...\n", LnDocFNm.CStr(), OutCpdFNm.CStr());
92    PSOut SOut=TFOut::New(OutCpdFNm);
93    TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
94    while (!FIn.Eof()){
95      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
96      printf("%d\r", Docs);
97      TChA DocNm;
98      if (NamedP){
99        Ch=FIn.GetCh();
100        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
101          DocNm+=Ch; Ch=FIn.GetCh();}
102        DocNm.Trunc();
103        if (DocNm.Empty()){Docs--; continue;}
104      }
105      TStrV CatNmV;
106      forever {
107        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
108        if (Ch=='!'){
109          if (!FIn.Eof()){Ch=FIn.GetCh();}
110          TChA CatNm;
111          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
112            CatNm+=Ch; Ch=FIn.GetCh();}
113          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
114        } else {
115          break;
116        }
117      }
118      TChA DocChA;
119      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
120        DocChA+=Ch; Ch=FIn.GetCh();}
121      if (DocNm.Empty()&&DocChA.Empty()){
122        continue;}
123      PCpDoc CpDoc=TCpDoc::New();
124      CpDoc->DocNm=DocNm;
125      CpDoc->ParStrV.Add(DocChA, 1);
126      for (int CatNmN=0; CatNmN<CatNmV.Len(); CatNmN++){
127        CpDoc->TopCdNmV.Add(CatNmV[CatNmN]);}
128      CpDoc->Save(*SOut);
129    }
130    printf("\nDone.\n");
131  }
132  const TStr TCpDoc::Reuters21578CpdFBase="Reuters21578.Cpd";
133  void TCpDoc::SaveReuters21578ToCpd(
134   const TStr& InFPath, const TStr& OutCpdFNm, const int& MxDocs){
135    PSOut SOut=TFOut::New(OutCpdFNm);
136    TFFile FFile(InFPath, ".SGM", false); TStr FNm; int Docs=0;
137    while (FFile.Next(FNm)){
138      printf("Processing file '%s'\n", FNm.CStr());
139      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
140      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
141        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
142        if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
143        PCpDoc CpDoc=TCpDoc::New();
144        PXmlDoc Doc=LDocV[LDocN];
145        PXmlTok DocTok=Doc->GetTok();
146        CpDoc->DocNm=DocTok->GetArgVal("NEWID");
147        CpDoc->DateStr=Doc->GetTagTok("REUTERS|DATE")->GetTokStr(false);
148        PXmlTok TitleTok=Doc->GetTagTok("REUTERS|TEXT|TITLE");
149        if (!TitleTok.Empty()){
150          CpDoc->TitleStr=TitleTok->GetTokStr(false);}
151        PXmlTok DatelineTok=Doc->GetTagTok("REUTERS|TEXT|DATELINE");
152        if (!DatelineTok.Empty()){
153          CpDoc->DatelineStr=DatelineTok->GetTokStr(false);}
154        TStr TextStr;
155        PXmlTok BodyTok=Doc->GetTagTok("REUTERS|TEXT|BODY");
156        if (!BodyTok.Empty()){
157          TextStr=BodyTok->GetTokStr(false);
158        } else {
159          PXmlTok TextTok=Doc->GetTagTok("REUTERS|TEXT");
160          if (!TextTok.Empty()){
161            TextStr=TextTok->GetTokStr(false);
162          }
163        }
164        CpDoc->ParStrV.Add(TextStr, 1);
165        TXmlTokV TopCatTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopCatTokV);
166        for (int TokN=0; TokN<TopCatTokV.Len(); TokN++){
167          TStr CatNm=TopCatTokV[TokN]->GetTokStr(false);
168          CpDoc->TopCdNmV.Add(CatNm);
169        }
170        CpDoc->Save(*SOut);
171      }
172      if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
173    }
174  }
175  const TStr TCpDoc::Reuters2000CpdFBase="Reuters2000.Cpd";
176  void TCpDoc::LoadReuters2000DocFromXml(const TStr& FNm,
177   TStr& DocId, TStr& DateStr, TStr& TitleStr,
178   TStr& HeadlineStr, TStr& BylineStr, TStr& DatelineStr,
179   TStrV& ParStrV,
180   TStrV& TopCdNmV, TStrV& GeoCdNmV, TStrV& IndCdNmV){
181    PXmlDoc Doc=TXmlDoc::LoadTxt(FNm);
182    DocId=Doc->GetTagTok("newsitem")->GetArgVal("itemid");
183    DateStr=Doc->GetTagTok("newsitem")->GetArgVal("date");
184    TitleStr=Doc->GetTagTok("newsitem|title")->GetTokStr(false);
185    HeadlineStr=Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
186    BylineStr=""; PXmlTok BylineTok;
187    if (Doc->IsTagTok("newsitem|byline", BylineTok)){
188      BylineStr=BylineTok->GetTokStr(false);}
189    DatelineStr=""; PXmlTok DatelineTok;
190    if (Doc->IsTagTok("newsitem|dateline", DatelineTok)){
191      DatelineStr=DatelineTok->GetTokStr(false);}
192    ParStrV.Clr(); TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
193    for (int ParTokN=0; ParTokN<ParTokV.Len(); ParTokN++){
194      TStr ParStr=ParTokV[ParTokN]->GetTokStr(false);
195      ParStrV.Add(ParStr);
196    }
197    TopCdNmV.Clr(); GeoCdNmV.Clr(); IndCdNmV.Clr();
198    TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
199    for (int CdsTokN=0; CdsTokN<CdsTokV.Len(); CdsTokN++){
200      PXmlTok CdsTok=CdsTokV[CdsTokN];
201      TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
202      if (CdsTok->GetArgVal("class")=="bip:topics:1.0"){
203        for (int CdTokN=0; CdTokN<CdTokV.Len(); CdTokN++){
204          TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
205          TopCdNmV.Add(CdNm);
206        }
207      } else
208      if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
209        for (int CdTokN=0; CdTokN<CdTokV.Len(); CdTokN++){
210          TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
211          GeoCdNmV.Add(CdNm);
212        }
213      } else
214      if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
215        for (int CdTokN=0; CdTokN<CdTokV.Len(); CdTokN++){
216          TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
217          IndCdNmV.Add(CdNm);
218        }
219      } else {
220        Fail;
221      }
222    }
223  }
224  PCpDoc TCpDoc::LoadReuters2000DocFromXml(const TStr& FNm){
225    PCpDoc CpDoc=TCpDoc::New();
226    LoadReuters2000DocFromXml(FNm,
227     CpDoc->DocNm, CpDoc->DateStr, CpDoc->TitleStr,
228     CpDoc->HeadlineStr, CpDoc->BylineStr, CpDoc->DatelineStr,
229     CpDoc->ParStrV,
230     CpDoc->TopCdNmV, CpDoc->GeoCdNmV, CpDoc->IndCdNmV);
231    return CpDoc;
232  }
233  void TCpDoc::SaveReuters2000ToCpd(
234   const TStr& InFPath, const TStr& OutCpdFNm, const int& MxDocs){
235    PSOut SOut=TFOut::New(OutCpdFNm);
236    TStrStrH DocIdToDateStrH;
237    TFFile FFile(InFPath, ".XML", true); TStr FNm;
238    while (FFile.Next(FNm)){
239      if ((MxDocs!=-1)&&(FFile.GetFNmN()>=MxDocs)){break;}
240      if ((1+FFile.GetFNmN())%100==0){
241        printf("Processing file '%s' (%d)\r", FNm.CStr(), 1+FFile.GetFNmN());}
242      PXmlDoc Doc=TXmlDoc::LoadTxt(FNm);
243      PCpDoc CpDoc=TCpDoc::New();
244      LoadReuters2000DocFromXml(FNm,
245       CpDoc->DocNm, CpDoc->DateStr, CpDoc->TitleStr,
246       CpDoc->HeadlineStr, CpDoc->BylineStr, CpDoc->DatelineStr,
247       CpDoc->ParStrV,
248       CpDoc->TopCdNmV, CpDoc->GeoCdNmV, CpDoc->IndCdNmV);
249      CpDoc->Save(*SOut);
250    }
251    printf("\n");
252  }
253  const TStr TCpDoc::AcmTechNewsCpdFBase="AcmTechNews.Cpd";
254  void TCpDoc::SaveAcmTechNewsToCpd(
255   const TStr& InFPath, const TStr& OutCpdFNm, const int& MxDocs){
256    PSOut SOut=TFOut::New(OutCpdFNm);
257    TFFile FFile(TStrV()+InFPath, TStrV()+".Html"+".Htm", "", true);
258    TStr FNm; int Docs=0;
259    while (FFile.Next(FNm)){
260      printf("Processing file '%s'\r", FNm.CStr());
261      PSIn SIn=TFIn::New(FNm);
262      THtmlLx Lx(SIn);
263      while (Lx.GetSym()!=hsyEof){
264        if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
265        Lx.MoveToBTagOrEof("<SPAN>");
266        if (Lx.GetArg("CLASS")!="title"){continue;}
267        Lx.MoveToBTagOrEof("<A>");
268        TStr TitleStr=Lx.GetStrToETag("<A>", false); TitleStr="";
269        Lx.MoveToETagOrEof("<SPAN>");
270        Lx.MoveToBTagOrEof("<P>");
271        TStr ParStr=Lx.GetStrToETag("<P>", false);
272        if (!ParStr.Empty()){
273          Docs++;
274          PCpDoc CpDoc=TCpDoc::New(TInt::GetStr(Docs), TitleStr, ParStr);
275          CpDoc->Save(*SOut);
276        }
277      }
278    }
279    printf("\n");
280  }
281  const TStr TCpDoc::CiaWFBCpdFBase="CiaWFB.Cpd";
282  void TCpDoc::SaveCiaWFBToCpd(
283   const TStr& InFPath, const TStr& OutCpdFNm, const int& MxDocs){
284    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(InFPath);
285    PSOut SOut=TFOut::New(OutCpdFNm);
286    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
287      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
288      TStr CountryNm=CiaWFBCountry->GetCountryNm();
289      TStr DescStr=CiaWFBCountry->GetDescStr();
290      PCpDoc CpDoc=TCpDoc::New(CountryNm, CountryNm, DescStr);
291      CpDoc->Save(*SOut);
292    }
293  }
294  const TStr TCpDoc::AsfaFBase="Asfa.Cpd";
295  void TCpDoc::SaveAsfaToCpd(const TStr& InFPath, const TStr& OutCpdFNm){
296    PSOut SOut=TFOut::New(OutCpdFNm);
297    TStrH AccessionIdH;
298    TFFile FFile(TStr::GetNrFPath(InFPath)+"*.Asfa"); TStr AsfaFNm;
299    while (FFile.Next(AsfaFNm)){
300      printf("Processing file '%s'\n", AsfaFNm.CStr());
301      PSIn SIn=TFIn::New(AsfaFNm);
302      TILx Lx(SIn, TFSet(iloRetEoln, iloExcept));
303      Lx.GetSym(syLn, syEof);
304      while (Lx.Sym!=syEof){
305        TStr QueryLnStr=Lx.Str;
306        TStrV QueryStrV; QueryLnStr.SplitOnAllCh('\t', QueryStrV, false);
307        IAssert(QueryStrV[0]=="Query");
308        Lx.GetSym(syLn); TStr RecNoLnStr=Lx.Str;
309        TStrV RecNoStrV; RecNoLnStr.SplitOnAllCh('\t', RecNoStrV, false);
310        IAssert(RecNoStrV[0]=="RecordNo");
311        TStr TitleStr, AbstractStr, PublicationYearStr, AccessionId;
312        TStrV AuthorNmV; TStrV TermNmV1, TermNmV2;
313        while (true){
314          Lx.GetSym(syLn); TStr FldLnStr=Lx.Str;
315          TStrV FldStrV; FldLnStr.SplitOnAllCh('\t', FldStrV, false);
316          if (FldStrV[0]=="----"){
317            if (!AccessionIdH.IsKey(AccessionId)){
318              AccessionIdH.AddKey(AccessionId);
319              PCpDoc CpDoc=TCpDoc::New();
320              CpDoc->DocNm=AccessionId;
321              CpDoc->DateStr=PublicationYearStr;
322              CpDoc->TitleStr=TitleStr;
323              CpDoc->ParStrV.Add(AbstractStr);
324              CpDoc->TopCdNmV=TermNmV1;
325              CpDoc->GeoCdNmV=TermNmV2;
326              CpDoc->IndCdNmV=AuthorNmV;
327              CpDoc->Save(*SOut);
328            } else {&bsol;*printf("[%s]", AccessionId.CStr());*/}
329            break;
330          } else
331          if (FldStrV[0]=="TI"){
332            TitleStr=FldStrV[2];
333          } else if (FldStrV[0]=="TI"){
334            TitleStr=FldStrV[2];
335          } else if (FldStrV[0]=="AU"){
336            FldStrV[2].SplitOnAllCh(';', AuthorNmV);
337            for (int StrN=0; StrN<AuthorNmV.Len(); StrN++){AuthorNmV[StrN].ToTrunc();}
338          } else if (FldStrV[0]=="AB"){
339            AbstractStr=FldStrV[2];
340          } else if (FldStrV[0]=="PY"){
341            PublicationYearStr=FldStrV[2];
342          } else if (FldStrV[0]=="DE"){
343            FldStrV[2].SplitOnAllCh(';', TermNmV1);
344            for (int StrN=0; StrN<TermNmV1.Len(); StrN++){TermNmV1[StrN].ToTrunc();}
345          } else if (FldStrV[0]=="CL"){
346            FldStrV[2].SplitOnAllCh(';', TermNmV2);
347            for (int StrN=0; StrN<TermNmV2.Len(); StrN++){TermNmV2[StrN].ToTrunc();}
348          } else if (FldStrV[0]=="AN"){
349            AccessionId=FldStrV[2];
350          }
351        }
352        printf("%d\r", AccessionIdH.Len());
353        Lx.GetSym(syLn, syEof);
354      }
355    }
356  }
357  void TCpDoc::SaveForNlpWin(const PSOut& SOut){
358    SOut->PutStr("DocId:");
359    SOut->PutStr(DocNm); SOut->PutLn();
360    SOut->PutStr(HeadlineStr); SOut->PutLn();
361    for (int ParStrN=0; ParStrN<ParStrV.Len(); ParStrN++){
362      SOut->PutStr(ParStrV[ParStrN]); SOut->PutLn();
363    }
364  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wikipedia.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cpdoc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>5  PWikiBs TWikiBs::LoadBin(const TStr& FNm){
6    return NULL;
7  }
8  void TWikiBs::SaveBin(const TStr& FNm){
</pre></code></div>
                <div class="column column_space"><pre><code>37  PSIn TCpDoc::FFirstCpd(const PSIn& SIn){
38    return SIn;
39  }
40  bool TCpDoc::FNextCpd(const PSIn& SIn, PCpDoc& CpDoc){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    