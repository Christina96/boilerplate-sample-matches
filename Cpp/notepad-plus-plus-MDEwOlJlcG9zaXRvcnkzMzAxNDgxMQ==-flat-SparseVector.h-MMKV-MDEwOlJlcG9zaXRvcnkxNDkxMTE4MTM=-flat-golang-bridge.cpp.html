
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.025125628140704%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</h3>
            <pre><code>1  #ifndef SPARSEVECTOR_H
2  #define SPARSEVECTOR_H
3  namespace Scintilla::Internal {
4  template <typename T>
5  class SparseVector {
6  private:
7  	Partitioning<Sci::Position> starts;
8  	SplitVector<T> values;
9  	T empty;	
10  	void ClearValue(Sci::Position partition) noexcept {
11  		values.SetValueAt(partition, T());
12  	}
13  public:
14  	SparseVector() : empty() {
15  		starts = Partitioning<Sci::Position>(8);
16  		values = SplitVector<T>();
17  		values.InsertEmpty(0, 2);
18  	}
19  	Sci::Position Length() const noexcept {
20  		return starts.Length();
21  	}
22  	Sci::Position Elements() const noexcept {
23  		return starts.Partitions();
24  	}
25  	Sci::Position PositionOfElement(Sci::Position element) const noexcept {
26  		return starts.PositionFromPartition(element);
27  	}
<span onclick='openModal()' class='match'>28  	Sci::Position ElementFromPosition(Sci::Position position) const noexcept {
29  		if (position < Length()) {
30  			return starts.PartitionFromPosition(position);
31  		} else {
32  			return starts.Partitions();
33  		}
34  	}
</span>35  	const T& ValueAt(Sci::Position position) const noexcept {
36  		assert(position <= Length());
37  		const Sci::Position partition = ElementFromPosition(position);
38  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
39  		if (startPartition == position) {
40  			return values.ValueAt(partition);
41  		} else {
42  			return empty;
43  		}
44  	}
45  	T Extract(Sci::Position position) {
46  		assert(position <= Length());
47  		const Sci::Position partition = ElementFromPosition(position);
48  		assert(partition >= 0);
49  		assert(partition <= starts.Partitions());
50  		assert(starts.PositionFromPartition(partition) == position);
51  		T value = std::move(values.operator[](partition));
52  		if ((partition > 0) && (partition < starts.Partitions())) {
53  			starts.RemovePartition(partition);
54  			values.Delete(partition);
55  		}
56  		Check();
57  		return value;
58  	}
59  	template <typename ParamType>
60  	void SetValueAt(Sci::Position position, ParamType &&value) {
61  		assert(position <= Length());
62  		const Sci::Position partition = ElementFromPosition(position);
63  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
64  		if (value == T()) {
65  			if (position == 0 || position == Length()) {
66  				ClearValue(partition);
67  			} else if (position == startPartition) {
68  				ClearValue(partition);
69  				starts.RemovePartition(partition);
70  				values.Delete(partition);
71  			}
72  		} else {
73  			if (position == startPartition) {
74  				ClearValue(partition);
75  				values.SetValueAt(partition, std::forward<ParamType>(value));
76  			} else {
77  				starts.InsertPartition(partition + 1, position);
78  				values.Insert(partition + 1, std::forward<ParamType>(value));
79  			}
80  		}
81  	}
82  	void InsertSpace(Sci::Position position, Sci::Position insertLength) {
83  		assert(position <= Length());
84  		const Sci::Position partition = starts.PartitionFromPosition(position);
85  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
86  		if (startPartition == position) {
87  			const bool positionOccupied = values.ValueAt(partition) != T();
88  			if (partition == 0) {
89  				if (positionOccupied) {
90  					starts.InsertPartition(1, 0);
91  					values.InsertEmpty(0, 1);
92  				}
93  				starts.InsertText(partition, insertLength);
94  			} else {
95  				if (positionOccupied) {
96  					starts.InsertText(partition - 1, insertLength);
97  				} else {
98  					starts.InsertText(partition, insertLength);
99  				}
100  			}
101  		} else {
102  			starts.InsertText(partition, insertLength);
103  		}
104  	}
105  	void DeletePosition(Sci::Position position) {
106  		assert(position < Length());
107  		Sci::Position partition = starts.PartitionFromPosition(position);
108  		const Sci::Position startPartition = starts.PositionFromPartition(partition);
109  		if (startPartition == position) {
110  			if (partition == 0) {
111  				ClearValue(0);
112  				if (starts.PositionFromPartition(1) == 1) {
113  					if (Elements() > 1) {
114  						starts.RemovePartition(partition + 1);
115  						values.Delete(partition);
116  					}
117  				}
118  			} else if (partition == starts.Partitions()) {
119  				ClearValue(partition);
120  				throw std::runtime_error("SparseVector: deleting end partition.");
121  			} else {
122  				ClearValue(partition);
123  				starts.RemovePartition(partition);
124  				values.Delete(partition);
125  				partition--;
126  			}
127  		}
128  		starts.InsertText(partition, -1);
129  		Check();
130  	}
131  	void DeleteAll() {
132  		starts = Partitioning<Sci::Position>(8);
133  		values = SplitVector<T>();
134  		values.InsertEmpty(0, 2);
135  	}
136  	void DeleteRange(Sci::Position position, Sci::Position deleteLength) {
137  		if (position > Length() || (deleteLength == 0)) {
138  			return;
139  		}
140  		const Sci::Position positionEnd = position + deleteLength;
141  		assert(positionEnd <= Length());
142  		if (position == 0) {
143  			while ((Elements() > 1) && (starts.PositionFromPartition(1) <= deleteLength)) {
144  				starts.RemovePartition(1);
145  				values.Delete(0);
146  			}
147  			starts.InsertText(0, -deleteLength);
148  			if (Length() == 0) {
149  				ClearValue(0);
150  			}
151  		} else {
152  			const Sci::Position partition = starts.PartitionFromPosition(position);
153  			const bool atPartitionStart = position == starts.PositionFromPartition(partition);
154  			const Sci::Position partitionDelete = partition + (atPartitionStart ? 0 : 1);
155  			assert(partitionDelete > 0);
156  			for (;;) {
157  				const Sci::Position positionAtIndex = starts.PositionFromPartition(partitionDelete);
158  				assert(position <= positionAtIndex);
159  				if (positionAtIndex >= positionEnd) {
160  					break;
161  				}
162  				assert(partitionDelete <= Elements());
163  				starts.RemovePartition(partitionDelete);
164  				values.Delete(partitionDelete);
165  			}
166  			starts.InsertText(partition - (atPartitionStart ? 1 : 0), -deleteLength);
167  		}
168  		Check();
169  	}
170  	Sci::Position PositionNext(Sci::Position start) const noexcept {
171  		const Sci::Position element = ElementFromPosition(start);
172  		if (element < Elements()) {
173  			return PositionOfElement(element + 1);
174  		}
175  		return Length() + 1;	
176  	}
177  	Sci::Position IndexAfter(Sci::Position position) const noexcept {
178  		assert(position < Length());
179  		if (position < 0)
180  			return 0;
181  		const Sci::Position partition = starts.PartitionFromPosition(position);
182  		return partition + 1;
183  	}
184  	void Check() const {
185  #ifdef CHECK_CORRECTNESS
186  		starts.Check();
187  		if (starts.Partitions() != values.Length() - 1) {
188  			throw std::runtime_error("SparseVector: Partitions and values different lengths.");
189  		}
190  #endif
191  	}
192  };
193  }
194  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-golang-bridge.cpp</h3>
            <pre><code>1  #ifndef CGO
2  #    include "MMKVPredef.h"
3  #    include "MMKV.h"
4  #    include "golang-bridge.h"
5  #    include <stdint.h>
6  #    include <string>
7  #    include <cstring>
8  using namespace mmkv;
9  using namespace std;
10  #    define MMKV_EXPORT extern "C" __attribute__((visibility("default"))) __attribute__((used))
11  void cLogHandler(MMKVLogLevel level, const char *file, int line, const char *function, const std::string &message);
12  MMKV_EXPORT void mmkvInitialize(GoStringWrap rootDir, int32_t logLevel, bool redirect) {
13      if (!rootDir.ptr) {
14          return;
15      }
16      mmkv::LogHandler handler = redirect ? cLogHandler : nullptr;
17      MMKV::initializeMMKV(string(rootDir.ptr, rootDir.length), (MMKVLogLevel) logLevel, handler);
18  }
19  MMKV_EXPORT void onExit() {
20      MMKV::onExit();
21  }
22  MMKV_EXPORT void *getMMKVWithID(GoStringWrap mmapID, int32_t mode, GoStringWrap cryptKey, GoStringWrap rootPath) {
23      MMKV *kv = nullptr;
24      if (!mmapID.ptr) {
25          return kv;
26      }
27      auto str = string(mmapID.ptr, mmapID.length);
28      bool done = false;
29      if (cryptKey.ptr) {
30          auto crypt = string(cryptKey.ptr, cryptKey.length);
31          if (crypt.length() > 0) {
32              if (rootPath.ptr) {
33                  auto path = string(rootPath.ptr, rootPath.length);
34                  kv = MMKV::mmkvWithID(str, (MMKVMode) mode, &crypt, &path);
35              } else {
36                  kv = MMKV::mmkvWithID(str, (MMKVMode) mode, &crypt, nullptr);
37              }
38              done = true;
39          }
40      }
41      if (!done) {
42          if (rootPath.ptr) {
43              auto path = string(rootPath.ptr, rootPath.length);
44              kv = MMKV::mmkvWithID(str, (MMKVMode) mode, nullptr, &path);
45          } else {
46              kv = MMKV::mmkvWithID(str, (MMKVMode) mode, nullptr, nullptr);
47          }
48      }
49      return kv;
50  }
51  MMKV_EXPORT void *getDefaultMMKV(int32_t mode, GoStringWrap cryptKey) {
52      MMKV *kv = nullptr;
53      if (cryptKey.ptr) {
54          auto crypt = string(cryptKey.ptr, cryptKey.length);
55          if (crypt.length() > 0) {
56              kv = MMKV::defaultMMKV((MMKVMode) mode, &crypt);
57          }
58      }
59      if (!kv) {
60          kv = MMKV::defaultMMKV((MMKVMode) mode, nullptr);
61      }
62      return kv;
63  }
64  MMKV_EXPORT const char *mmapID(void *handle) {
65      MMKV *kv = static_cast<MMKV *>(handle);
66      if (kv) {
67          return kv->mmapID().c_str();
68      }
69      return nullptr;
70  }
71  MMKV_EXPORT bool encodeBool(void *handle, GoStringWrap oKey, bool value) {
72      MMKV *kv = static_cast<MMKV *>(handle);
73      if (kv && oKey.ptr) {
74          auto key = string(oKey.ptr, oKey.length);
75          return kv->set((bool) value, key);
76      }
77      return false;
78  }
79  MMKV_EXPORT bool decodeBool(void *handle, GoStringWrap oKey, bool defaultValue) {
80      MMKV *kv = static_cast<MMKV *>(handle);
81      if (kv && oKey.ptr) {
82          auto key = string(oKey.ptr, oKey.length);
83          return kv->getBool(key, defaultValue);
84      }
85      return defaultValue;
86  }
87  MMKV_EXPORT bool encodeInt32(void *handle, GoStringWrap oKey, int32_t value) {
88      MMKV *kv = static_cast<MMKV *>(handle);
89      if (kv && oKey.ptr) {
90          auto key = string(oKey.ptr, oKey.length);
91          return kv->set((int32_t) value, key);
92      }
93      return false;
94  }
95  MMKV_EXPORT int32_t decodeInt32(void *handle, GoStringWrap oKey, int32_t defaultValue) {
96      MMKV *kv = static_cast<MMKV *>(handle);
97      if (kv && oKey.ptr) {
98          auto key = string(oKey.ptr, oKey.length);
99          return kv->getInt32(key, defaultValue);
100      }
101      return defaultValue;
102  }
103  MMKV_EXPORT bool encodeUInt32(void *handle, GoStringWrap oKey, uint32_t value) {
104      MMKV *kv = static_cast<MMKV *>(handle);
105      if (kv && oKey.ptr) {
106          auto key = string(oKey.ptr, oKey.length);
107          return kv->set(value, key);
108      }
109      return false;
110  }
111  MMKV_EXPORT uint32_t decodeUInt32(void *handle, GoStringWrap oKey, uint32_t defaultValue) {
112      MMKV *kv = static_cast<MMKV *>(handle);
113      if (kv && oKey.ptr) {
114          auto key = string(oKey.ptr, oKey.length);
115          return kv->getUInt32(key, defaultValue);
116      }
117      return defaultValue;
118  }
119  MMKV_EXPORT bool encodeInt64(void *handle, GoStringWrap oKey, int64_t value) {
120      MMKV *kv = static_cast<MMKV *>(handle);
121      if (kv && oKey.ptr) {
122          auto key = string(oKey.ptr, oKey.length);
123          return kv->set((int64_t) value, key);
124      }
125      return false;
126  }
127  MMKV_EXPORT int64_t decodeInt64(void *handle, GoStringWrap oKey, int64_t defaultValue) {
128      MMKV *kv = static_cast<MMKV *>(handle);
129      if (kv && oKey.ptr) {
130          auto key = string(oKey.ptr, oKey.length);
131          return kv->getInt64(key, defaultValue);
132      }
133      return defaultValue;
134  }
135  MMKV_EXPORT bool encodeUInt64(void *handle, GoStringWrap oKey, uint64_t value) {
136      MMKV *kv = static_cast<MMKV *>(handle);
137      if (kv && oKey.ptr) {
138          auto key = string(oKey.ptr, oKey.length);
139          return kv->set(value, key);
140      }
141      return false;
142  }
143  MMKV_EXPORT uint64_t decodeUInt64(void *handle, GoStringWrap oKey, uint64_t defaultValue) {
144      MMKV *kv = static_cast<MMKV *>(handle);
145      if (kv && oKey.ptr) {
146          auto key = string(oKey.ptr, oKey.length);
147          return kv->getUInt64(key, defaultValue);
148      }
149      return defaultValue;
150  }
151  MMKV_EXPORT bool encodeFloat(void *handle, GoStringWrap oKey, float value) {
152      MMKV *kv = static_cast<MMKV *>(handle);
153      if (kv && oKey.ptr) {
154          auto key = string(oKey.ptr, oKey.length);
155          return kv->set((float) value, key);
156      }
157      return false;
158  }
159  MMKV_EXPORT float decodeFloat(void *handle, GoStringWrap oKey, float defaultValue) {
160      MMKV *kv = static_cast<MMKV *>(handle);
161      if (kv && oKey.ptr) {
162          auto key = string(oKey.ptr, oKey.length);
163          return kv->getFloat(key, defaultValue);
164      }
165      return defaultValue;
166  }
167  MMKV_EXPORT bool encodeDouble(void *handle, GoStringWrap oKey, double value) {
168      MMKV *kv = static_cast<MMKV *>(handle);
169      if (kv && oKey.ptr) {
170          auto key = string(oKey.ptr, oKey.length);
171          return kv->set((double) value, key);
172      }
173      return false;
174  }
175  MMKV_EXPORT double decodeDouble(void *handle, GoStringWrap oKey, double defaultValue) {
176      MMKV *kv = static_cast<MMKV *>(handle);
177      if (kv && oKey.ptr) {
178          auto key = string(oKey.ptr, oKey.length);
179          return kv->getDouble(key, defaultValue);
180      }
181      return defaultValue;
182  }
183  MMKV_EXPORT bool encodeBytes(void *handle, GoStringWrap oKey, GoStringWrap oValue) {
184      MMKV *kv = static_cast<MMKV *>(handle);
185      if (kv && oKey.ptr) {
186          auto key = string(oKey.ptr, oKey.length);
187          if (oValue.ptr) {
188              auto value = MMBuffer((void *) oValue.ptr, oValue.length, MMBufferNoCopy);
189              return kv->set(value, key);
190          } else {
191              kv->removeValueForKey(key);
192              return true;
193          }
194      }
195      return false;
196  }
197  MMKV_EXPORT void *decodeBytes(void *handle, GoStringWrap oKey, uint64_t *lengthPtr) {
198      MMKV *kv = static_cast<MMKV *>(handle);
199      if (kv && oKey.ptr) {
200          auto key = string(oKey.ptr, oKey.length);
201          auto value = kv->getBytes(key);
202          if (value.length() > 0) {
203              if (value.isStoredOnStack()) {
204                  auto result = malloc(value.length());
205                  if (result) {
206                      memcpy(result, value.getPtr(), value.length());
207                      *lengthPtr = value.length();
208                  }
209                  return result;
210              } else {
211                  void *result = value.getPtr();
212                  *lengthPtr = value.length();
213                  value.detach();
214                  return result;
215              }
216          }
217      }
218      return nullptr;
219  }
220  #    ifndef MMKV_DISABLE_CRYPT
221  MMKV_EXPORT bool reKey(void *handle, GoStringWrap oKey) {
222      MMKV *kv = static_cast<MMKV *>(handle);
<span onclick='openModal()' class='match'>223      if (kv) {
224          if (oKey.ptr && oKey.length > 0) {
225              string key(oKey.ptr, oKey.length);
226              return kv->reKey(key);
227          } else {
228              return kv->reKey(string());
229          }
230      }
</span>231      return false;
232  }
233  MMKV_EXPORT void *cryptKey(void *handle, uint32_t *lengthPtr) {
234      MMKV *kv = static_cast<MMKV *>(handle);
235      if (kv && lengthPtr) {
236          auto cryptKey = kv->cryptKey();
237          if (cryptKey.length() > 0) {
238              auto ptr = malloc(cryptKey.length());
239              if (ptr) {
240                  memcpy(ptr, cryptKey.data(), cryptKey.length());
241                  *lengthPtr = cryptKey.length();
242                  return ptr;
243              }
244          }
245      }
246      return nullptr;
247  }
248  MMKV_EXPORT void checkReSetCryptKey(void *handle, GoStringWrap oKey) {
249      MMKV *kv = static_cast<MMKV *>(handle);
250      if (kv) {
251          if (oKey.ptr && oKey.length > 0) {
252              string key(oKey.ptr, oKey.length);
253              kv->checkReSetCryptKey(&key);
254          } else {
255              kv->checkReSetCryptKey(nullptr);
256          }
257      }
258  }
259  #    endif 
260  MMKV_EXPORT GoStringWrap *allKeys(void *handle, uint64_t *lengthPtr) {
261      MMKV *kv = static_cast<MMKV *>(handle);
262      if (kv) {
263          auto keys = kv->allKeys();
264          if (!keys.empty()) {
265              auto keyArray = (GoStringWrap *) calloc(keys.size(), sizeof(GoStringWrap));
266              if (!keyArray) {
267                  return nullptr;
268              }
269              for (size_t index = 0; index < keys.size(); index++) {
270                  auto &key = keys[index];
271                  auto &stringWrap = keyArray[index];
272                  stringWrap.length = static_cast<uint32_t>(key.length());
273                  stringWrap.ptr = (char *) malloc(key.length());
274                  if (stringWrap.ptr) {
275                      memcpy((void *) stringWrap.ptr, key.data(), key.length());
276                  }
277              }
278              *lengthPtr = keys.size();
279              return keyArray;
280          }
281      }
282      return nullptr;
283  }
284  MMKV_EXPORT bool containsKey(void *handle, GoStringWrap oKey) {
285      MMKV *kv = static_cast<MMKV *>(handle);
286      if (kv && oKey.ptr) {
287          auto key = string(oKey.ptr, oKey.length);
288          return kv->containsKey(key);
289      }
290      return false;
291  }
292  MMKV_EXPORT uint64_t count(void *handle) {
293      MMKV *kv = static_cast<MMKV *>(handle);
294      if (kv) {
295          return kv->count();
296      }
297      return 0;
298  }
299  MMKV_EXPORT uint64_t totalSize(void *handle) {
300      MMKV *kv = static_cast<MMKV *>(handle);
301      if (kv) {
302          return kv->totalSize();
303      }
304      return 0;
305  }
306  MMKV_EXPORT uint64_t actualSize(void *handle) {
307      MMKV *kv = static_cast<MMKV *>(handle);
308      if (kv) {
309          return kv->actualSize();
310      }
311      return 0;
312  }
313  MMKV_EXPORT void removeValueForKey(void *handle, GoStringWrap oKey) {
314      MMKV *kv = static_cast<MMKV *>(handle);
315      if (kv && oKey.ptr) {
316          auto key = string(oKey.ptr, oKey.length);
317          kv->removeValueForKey(key);
318      }
319  }
320  MMKV_EXPORT void removeValuesForKeys(void *handle, GoStringWrap *keyArray, uint64_t count) {
321      MMKV *kv = static_cast<MMKV *>(handle);
322      if (kv && keyArray && count > 0) {
323          vector<string> arrKeys;
324          arrKeys.reserve(count);
325          for (uint64_t index = 0; index < count; index++) {
326              auto &stringWrap = keyArray[index];
327              if (stringWrap.ptr && stringWrap.length > 0) {
328                  arrKeys.emplace_back(stringWrap.ptr, stringWrap.length);
329              }
330          }
331          if (!arrKeys.empty()) {
332              kv->removeValuesForKeys(arrKeys);
333          }
334      }
335  }
336  MMKV_EXPORT void clearAll(void *handle) {
337      MMKV *kv = static_cast<MMKV *>(handle);
338      if (kv) {
339          kv->clearAll();
340      }
341  }
342  MMKV_EXPORT void mmkvSync(void *handle, bool sync) {
343      MMKV *kv = static_cast<MMKV *>(handle);
344      if (kv) {
345          kv->sync((SyncFlag) sync);
346      }
347  }
348  MMKV_EXPORT void clearMemoryCache(void *handle) {
349      MMKV *kv = static_cast<MMKV *>(handle);
350      if (kv) {
351          kv->clearMemoryCache();
352      }
353  }
354  MMKV_EXPORT int32_t pageSize() {
355      return static_cast<int32_t>(DEFAULT_MMAP_SIZE);
356  }
357  MMKV_EXPORT const char *version() {
358      return MMKV_VERSION;
359  }
360  MMKV_EXPORT void trim(void *handle) {
361      MMKV *kv = static_cast<MMKV *>(handle);
362      if (kv) {
363          kv->trim();
364      }
365  }
366  MMKV_EXPORT void mmkvClose(void *handle) {
367      MMKV *kv = static_cast<MMKV *>(handle);
368      if (kv) {
369          kv->close();
370      }
371  }
372  MMKV_EXPORT bool backupOneToDirectory(GoStringWrap_t mmapID, GoStringWrap_t dstDir, GoStringWrap_t srcDir) {
373      if (!mmapID.ptr || !dstDir.ptr) {
374          return false;
375      }
376      auto id = string(mmapID.ptr, mmapID.length);
377      auto dst = string(dstDir.ptr, dstDir.length);
378      if (srcDir.ptr) {
379          auto src = string(srcDir.ptr, srcDir.length);
380          return MMKV::backupOneToDirectory(id, dst, &src);
381      }
382      return MMKV::backupOneToDirectory(id, dst, nullptr);
383  }
384  MMKV_EXPORT bool restoreOneFromDirectory(GoStringWrap_t mmapID, GoStringWrap_t srcDir, GoStringWrap_t dstDir) {
385      if (!mmapID.ptr || !srcDir.ptr) {
386          return false;
387      }
388      auto id = string(mmapID.ptr, mmapID.length);
389      auto src = string(srcDir.ptr, srcDir.length);
390      if (dstDir.ptr) {
391          auto dst = string(dstDir.ptr, dstDir.length);
392          return MMKV::restoreOneFromDirectory(id, src, &dst);
393      }
394      return MMKV::restoreOneFromDirectory(id, src, nullptr);
395  }
396  MMKV_EXPORT uint64_t backupAllToDirectory(GoStringWrap_t dstDir, GoStringWrap_t srcDir) {
397      if (!dstDir.ptr) {
398          return 0;
399      }
400      auto dst = string(dstDir.ptr, dstDir.length);
401      if (srcDir.ptr) {
402          auto src = string(srcDir.ptr, srcDir.length);
403          return MMKV::backupAllToDirectory(dst, &src);
404      }
405      return MMKV::backupAllToDirectory(dst, nullptr);
406  }
407  MMKV_EXPORT uint64_t restoreAllFromDirectory(GoStringWrap_t srcDir, GoStringWrap_t dstDir) {
408      if (!srcDir.ptr) {
409          return 0;
410      }
411      auto src = string(srcDir.ptr, srcDir.length);
412      if (dstDir.ptr) {
413          auto dst = string(dstDir.ptr, dstDir.length);
414          return MMKV::restoreAllFromDirectory(src, &dst);
415      }
416      return MMKV::restoreAllFromDirectory(src, nullptr);
417  }
418  extern "C" void myLogHandler(int64_t level, GoStringWrap file, int64_t line, GoStringWrap function, GoStringWrap message);
419  void cLogHandler(MMKVLogLevel level, const char *file, int line, const char *function, const std::string &message) {
420      GoStringWrap oFile { file, static_cast<int64_t>(strlen(file)) };
421      GoStringWrap oFunction { function, static_cast<int64_t>(strlen(function)) };
422      GoStringWrap oMessage { message.data(), static_cast<int64_t>(message.length()) };
423      myLogHandler(level, oFile, line, oFunction, oMessage);
424  }
425  void setWantsLogRedirect(bool redirect) {
426      if (redirect) {
427          MMKV::registerLogHandler(&cLogHandler);
428      } else {
429          MMKV::unRegisterLogHandler();
430      }
431  }
432  extern "C" int64_t myErrorHandler(GoStringWrap mmapID, int64_t error);
433  static MMKVRecoverStrategic cErrorHandler(const std::string &mmapID, MMKVErrorType errorType) {
434      GoStringWrap oID { mmapID.data(), static_cast<int64_t>(mmapID.length()) };
435      return static_cast<MMKVRecoverStrategic>(myErrorHandler(oID, static_cast<int64_t>(errorType)));
436  }
437  void setWantsErrorHandle(bool errorHandle) {
438      if (errorHandle) {
439          MMKV::registerErrorHandler(&cErrorHandler);
440      } else {
441          MMKV::unRegisterErrorHandler();
442      }
443  }
444  extern "C" void myContentChangeHandler(GoStringWrap mmapID);
445  static void cContentChangeHandler(const std::string &mmapID) {
446      GoStringWrap oID { mmapID.data(), static_cast<int64_t>(mmapID.length()) };
447      myContentChangeHandler(oID);
448  }
449  void setWantsContentChangeHandle(bool errorHandle) {
450      if (errorHandle) {
451          MMKV::registerContentChangeHandler(&cContentChangeHandler);
452      } else {
453          MMKV::unRegisterContentChangeHandler();
454      }
455  }
456  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SparseVector.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-golang-bridge.cpp</div>
                </div>
                <div class="column column_space"><pre><code>28  	Sci::Position ElementFromPosition(Sci::Position position) const noexcept {
29  		if (position < Length()) {
30  			return starts.PartitionFromPosition(position);
31  		} else {
32  			return starts.Partitions();
33  		}
34  	}
</pre></code></div>
                <div class="column column_space"><pre><code>223      if (kv) {
224          if (oKey.ptr && oKey.length > 0) {
225              string key(oKey.ptr, oKey.length);
226              return kv->reKey(key);
227          } else {
228              return kv->reKey(string());
229          }
230      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    