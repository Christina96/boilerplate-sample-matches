<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for thread_queue.h &amp; zookeeper_coordinator.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for thread_queue.h &amp; zookeeper_coordinator.h
      </h3>
<h1 align="center">
        9.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>thread_queue.h (39.39394%)<th>zookeeper_coordinator.h (5.676856%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(70-73)<td><a href="#" name="0">(68-71)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>thread_queue.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef	THREAD_QUEUE_H
2 #define	THREAD_QUEUE_H
3 #include &lt;string&gt;
4 #include &lt;boost/shared_ptr.hpp&gt;
5 #include "logger.h"
6 #include "util.h"
7 #include "connection.h"
8 using namespace std;
9 namespace gree {
10 namespace flare {
11 typedef class thread_queue thread_queue;
12 typedef boost::shared_ptr&lt;thread_queue&gt; shared_thread_queue;
13 class thread_queue {
14 protected:
15 	string							_ident;
16 	bool								_sync;
17 	int									_sync_ref_count;
18 	bool								_success;
19 	pthread_mutex_t			_mutex_sync;
20 	pthread_cond_t			_cond_sync;
21 	time_t							_timestamp;
22 public:
23 	thread_queue();
24 	thread_queue(string ident);
25 	virtual ~thread_queue();
26 	virtual int run(shared_connection c);
27 	int sync();
28 <a name="0"></a>	int sync_ref();
29 	int sync_unref();
30 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	virtual string get_ident() { return this-&gt;_ident; };
31 	bool is_success() { return this-&gt;_success; };
32 	time_t get_timestamp() { return this-&gt;_timestamp; };
33 };</b></font>
34 }	}	
#endif	</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zookeeper_coordinator.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef	__ZOOKEEPER_COORDINATOR_H__
2 #define	__ZOOKEEPER_COORDINATOR_H__
3 #include &lt;zookeeper/zookeeper.h&gt;
4 #include &lt;boost/tuple/tuple.hpp&gt;
5 #include &lt;boost/lexical_cast.hpp&gt;
6 #include &lt;boost/regex.hpp&gt;
7 #include &lt;vector&gt;
8 #include &lt;deque&gt;
9 #include "coordinator.h"
10 #include "zookeeper_lock.h"
11 using namespace std;
12 namespace gree {
13 namespace flare {
14 class zookeeper_coordinator : public coordinator
15 {
16 public:
17 	static const int		default_retry_count = 10;
18 	typedef boost::tuple&lt;string,string,int&gt; authority_type;
19 protected:
20 	class zk_operation : public operation
21 	{
22 		zookeeper_lock		_zklock;
23 		string						_message;
24 	public:
25 		zk_operation(zookeeper_coordinator *coord, const string&amp; connstring, const string&amp; path, const string&amp; message = ""):
26 				operation(coord),
27 				_zklock(connstring, path),
28 				_message(message) {
29 		}
30 		~zk_operation() {}
31 	public:
32 		int lock() { this-&gt;_zklock.set_message(this-&gt;_message); return this-&gt;_zklock.lock(); }
33 <a name="0"></a>		int unlock() { return this-&gt;_zklock.unlock(); }
34 		int wait_for_ownership() { return this-&gt;_zklock.wait_for_ownership(); }
35 		void set_message(const string&amp; message) { this-&gt;_message = message; }
36 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		string get_message() { return this-&gt;_message; }
37 		string get_lock_id() { return this-&gt;_zklock.get_id(); }
38 		string get_nickname() { return this-&gt;_zklock.get_nickname(); }
39 	};</b></font>
40 	struct ext_uri {
41 		string scheme;
42 		vector&lt;authority_type&gt; authorities;
43 		string path;
44 		string query;
45 		string fragment;
46 		ext_uri(string s) {
47 			static const char * auth_pattern = 
48 				"(?:([^:/@]*)@)?([^:@/]*)(?::(\\d+))?"; 			static const char * pattern = "\\A"
49 				"([^:]+)://" 				"([^,/]*)?(?:,([^,/]*))?(?:,([^,/]*))?(?:,([^,/]*))?(?:,([^,/]*))?" 				"(/[^\\?]*)(?:\\?([^#]*))?(?:#(.*))?" 				"\\z";
50 			vector&lt;string&gt; authstrings;
51 			static const boost::regex e(pattern);
52 			boost::smatch match;
53 			boost::regex_match(s, match, e);
54 			this-&gt;scheme    = match[1].str();
55 			authstrings.push_back(match[2].str());
56 			for (int i = 3; i &lt; 7; i++) {
57 				if (match[i].matched) {
58 					authstrings.push_back(match[i].str());
59 				}
60 			}
61 			for(vector&lt;string&gt;::iterator it = authstrings.begin(); it != authstrings.end(); it++) {
62 				static const boost::regex auth_e(auth_pattern);
63 				boost::smatch auth_match;
64 				boost::regex_match(*it, auth_match, auth_e);
65 				string user      = auth_match[1].str();
66 				string host      = auth_match[2].str();
67 				int port         = 0;
68 				try {
69 					port           = boost::lexical_cast&lt;int&gt;(auth_match[3].str());
70 				} catch (boost::bad_lexical_cast&amp; e) {}
71 				authorities.push_back(boost::make_tuple(user, host, port));
72 			}
73 			this-&gt;path      = match[7].str();
74 			this-&gt;query     = match[8].str();
75 			this-&gt;fragment  = match[9].str();
76 		}
77 	};
78 private:
79 	ext_uri						_uri;
80 	string						_myname;
81 	string						_connstring;
82 	zhandle_t*				_zhandle;
83 	clientid_t				_client_id;
84 	boost::function&lt;void (void)&gt;	_update_handler;
85 	pthread_mutex_t		_mutex_sync_nodemap;
86 	pthread_cond_t		_cond_sync_nodemap;
87 	bool							_sync_nodemap;
88 	int								_retry;
89 	bool							_is_initialized;
90 	deque&lt;shared_operation&gt; operation_pool;
91 	pthread_mutex_t		_mutex_operation_pool;
92 public:
93 	zookeeper_coordinator(const string&amp; coordinator_uri, const string&amp; myname);
94 	virtual ~zookeeper_coordinator();
95 	virtual int begin_operation(shared_operation&amp; operation, const string&amp; message);
96 	virtual int end_operation(shared_operation&amp; operation);
97 	virtual int store_state(const string&amp; flare_xml);
98 	virtual int restore_state(string&amp; flare_xml);
99 	int setup();
100 	bool is_initialized() { return this-&gt;_is_initialized; }
101 	string get_scheme() { return this-&gt;_uri.scheme; }
102 	vector&lt;boost::tuple&lt;string,string,int&gt; &gt; get_authorities() { return this-&gt;_uri.authorities; }
103 	string get_user()   { return this-&gt;_uri.authorities.front().get&lt;0&gt;(); }
104 	string get_host()   { return this-&gt;_uri.authorities.front().get&lt;1&gt;(); }
105 	int get_port()      { return this-&gt;_uri.authorities.front().get&lt;2&gt;(); }
106 	string get_path()   { return this-&gt;_uri.path; }
107 	void set_update_handler(boost::function&lt;void (void)&gt; fn) { this-&gt;_update_handler = fn; }
108 	int get_meta_variables(map&lt;string,string&gt;&amp; variables);
109 	zhandle_t* get_zhandle();
110 protected:
111 	void _close_zookeeper();
112 	boost::shared_ptr&lt;zk_operation&gt; _new_operation();
113 	boost::shared_ptr&lt;zk_operation&gt; _take_operation();
114 	void _put_operation(boost::shared_ptr&lt;zk_operation&gt; zkop);
115 	virtual void _handle_global_watch_event(int type, int state, const string&amp; path);
116 	virtual void _handle_nodemap_watch_event(int type, int state, const string&amp; path);
117 	virtual void _handle_sync_completion_event(int rc, const string&amp; value);
118 private:
119 	static void _nodemap_watcher_fn(zhandle_t* zh, int type, int state,
120 																	const char* path, void* watcherCtx);
121 	static void _global_watcher_fn(zhandle_t* zh, int type, int state,
122 																 const char* path, void* watcherCtx);
123 	static void _sync_completion_fn(int rc, const char *value, const void *data);
124 };
125 }	}	
#endif	</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
