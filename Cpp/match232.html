<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for thread_queue.h &amp; zookeeper_coordinator.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for thread_queue.h &amp; zookeeper_coordinator.h
      </h3>
<h1 align="center">
        9.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>thread_queue.h (39.39394%)<th>zookeeper_coordinator.h (5.676856%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(70-73)<td><a href="#" name="0">(68-71)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>thread_queue.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Flare
 * --------------
 * Copyright (C) 2008-2014 GREE, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 *	thread_queue.h
 *
 *	@author	Masaki Fujimoto &lt;fujimoto@php.net&gt;
 *
 *	$Id$
 */
#ifndef	THREAD_QUEUE_H
#define	THREAD_QUEUE_H

#include &lt;string&gt;

#include &lt;boost/shared_ptr.hpp&gt;

#include "logger.h"
#include "util.h"
#include "connection.h"

using namespace std;

namespace gree {
namespace flare {

typedef class thread_queue thread_queue;
typedef boost::shared_ptr&lt;thread_queue&gt; shared_thread_queue;

/**
 *	thread queue base class
 */
class thread_queue {
protected:
	string							_ident;
	bool								_sync;
	int									_sync_ref_count;
	bool								_success;
	pthread_mutex_t			_mutex_sync;
	pthread_cond_t			_cond_sync;
	time_t							_timestamp;

public:
	thread_queue();
	thread_queue(string ident);
	virtual ~thread_queue();

	virtual int run(shared_connection c);

	int sync();
<a name="0"></a>	int sync_ref();
	int sync_unref();

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	virtual string get_ident() { return this-&gt;_ident; };
	bool is_success() { return this-&gt;_success; };
	time_t get_timestamp() { return this-&gt;_timestamp; };
};</b></font>

}	// namespace flare
}	// namespace gree

#endif	// THREAD_QUEUE_H
// vim: foldmethod=marker tabstop=2 shiftwidth=2 autoindent
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>zookeeper_coordinator.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Flare
 * --------------
 * Copyright (C) 2008-2014 GREE, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
/**
 *	zookeeper_coordinator.h
 *
 *	@author	Kiyoshi Ikehara &lt;kiyoshi.ikehara@gree.net&gt;
 *
 *	$Id$
 */
#ifndef	__ZOOKEEPER_COORDINATOR_H__
#define	__ZOOKEEPER_COORDINATOR_H__

#include &lt;zookeeper/zookeeper.h&gt;
#include &lt;boost/tuple/tuple.hpp&gt;
#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;

#include "coordinator.h"
#include "zookeeper_lock.h"

using namespace std;

namespace gree {
namespace flare {

class zookeeper_coordinator : public coordinator
{
public:
	static const int		default_retry_count = 10;
	typedef boost::tuple&lt;string,string,int&gt; authority_type;

protected:
	class zk_operation : public operation
	{
		zookeeper_lock		_zklock;
		string						_message;
	public:
		zk_operation(zookeeper_coordinator *coord, const string&amp; connstring, const string&amp; path, const string&amp; message = ""):
				operation(coord),
				_zklock(connstring, path),
				_message(message) {
		}
		~zk_operation() {}
	public:
		int lock() { this-&gt;_zklock.set_message(this-&gt;_message); return this-&gt;_zklock.lock(); }
<a name="0"></a>		int unlock() { return this-&gt;_zklock.unlock(); }
		int wait_for_ownership() { return this-&gt;_zklock.wait_for_ownership(); }
		void set_message(const string&amp; message) { this-&gt;_message = message; }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		string get_message() { return this-&gt;_message; }
		string get_lock_id() { return this-&gt;_zklock.get_id(); }
		string get_nickname() { return this-&gt;_zklock.get_nickname(); }
	};</b></font>

	struct ext_uri {
		string scheme;
		vector&lt;authority_type&gt; authorities;
		string path;
		string query;
		string fragment;

		/**
		 *  scheme://[user@][host][:port]/[path][?query][#fragment]
		 */
		ext_uri(string s) {
			static const char * auth_pattern = 
				"(?:([^:/@]*)@)?([^:@/]*)(?::(\\d+))?"; // [userinfo@]host[:port]
			static const char * pattern = "\\A"
				"([^:]+)://" // scheme(1)
				"([^,/]*)?(?:,([^,/]*))?(?:,([^,/]*))?(?:,([^,/]*))?(?:,([^,/]*))?" // authority(2-6)
				"(/[^\\?]*)(?:\\?([^#]*))?(?:#(.*))?" // path?query#fragment(7-9)
				"\\z";

			vector&lt;string&gt; authstrings;
			static const boost::regex e(pattern);
			boost::smatch match;
			boost::regex_match(s, match, e);
			this-&gt;scheme    = match[1].str();
			authstrings.push_back(match[2].str());
			for (int i = 3; i &lt; 7; i++) {
				if (match[i].matched) {
					authstrings.push_back(match[i].str());
				}
			}
			for(vector&lt;string&gt;::iterator it = authstrings.begin(); it != authstrings.end(); it++) {
				static const boost::regex auth_e(auth_pattern);
				boost::smatch auth_match;
				boost::regex_match(*it, auth_match, auth_e);
				string user      = auth_match[1].str();
				string host      = auth_match[2].str();
				int port         = 0;
				try {
					port           = boost::lexical_cast&lt;int&gt;(auth_match[3].str());
				} catch (boost::bad_lexical_cast&amp; e) {}
				authorities.push_back(boost::make_tuple(user, host, port));
			}

			this-&gt;path      = match[7].str();
			this-&gt;query     = match[8].str();
			this-&gt;fragment  = match[9].str();
		}
	};

private:
	ext_uri						_uri;
	string						_myname;
	string						_connstring;
	zhandle_t*				_zhandle;
	clientid_t				_client_id;
	boost::function&lt;void (void)&gt;	_update_handler;
	pthread_mutex_t		_mutex_sync_nodemap;
	pthread_cond_t		_cond_sync_nodemap;
	bool							_sync_nodemap;
	int								_retry;
	bool							_is_initialized;
	deque&lt;shared_operation&gt; operation_pool;
	pthread_mutex_t		_mutex_operation_pool;

public:
	zookeeper_coordinator(const string&amp; coordinator_uri, const string&amp; myname);
	virtual ~zookeeper_coordinator();

	virtual int begin_operation(shared_operation&amp; operation, const string&amp; message);
	virtual int end_operation(shared_operation&amp; operation);
	virtual int store_state(const string&amp; flare_xml);
	virtual int restore_state(string&amp; flare_xml);

	int setup();
	bool is_initialized() { return this-&gt;_is_initialized; }
	string get_scheme() { return this-&gt;_uri.scheme; }
	vector&lt;boost::tuple&lt;string,string,int&gt; &gt; get_authorities() { return this-&gt;_uri.authorities; }
	string get_user()   { return this-&gt;_uri.authorities.front().get&lt;0&gt;(); }
	string get_host()   { return this-&gt;_uri.authorities.front().get&lt;1&gt;(); }
	int get_port()      { return this-&gt;_uri.authorities.front().get&lt;2&gt;(); }
	string get_path()   { return this-&gt;_uri.path; }
	void set_update_handler(boost::function&lt;void (void)&gt; fn) { this-&gt;_update_handler = fn; }
	int get_meta_variables(map&lt;string,string&gt;&amp; variables);
	zhandle_t* get_zhandle();

protected:
	void _close_zookeeper();
	boost::shared_ptr&lt;zk_operation&gt; _new_operation();
	boost::shared_ptr&lt;zk_operation&gt; _take_operation();
	void _put_operation(boost::shared_ptr&lt;zk_operation&gt; zkop);
	virtual void _handle_global_watch_event(int type, int state, const string&amp; path);
	virtual void _handle_nodemap_watch_event(int type, int state, const string&amp; path);
	virtual void _handle_sync_completion_event(int rc, const string&amp; value);

private:
	static void _nodemap_watcher_fn(zhandle_t* zh, int type, int state,
																	const char* path, void* watcherCtx);
	static void _global_watcher_fn(zhandle_t* zh, int type, int state,
																 const char* path, void* watcherCtx);
	static void _sync_completion_fn(int rc, const char *value, const void *data);
};

}	// namespace flare
}	// namespace gree

#endif	// __ZOOKEEPER_COORDINATOR_H__
// vim: foldmethod=marker tabstop=2 shiftwidth=2 autoindent
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
