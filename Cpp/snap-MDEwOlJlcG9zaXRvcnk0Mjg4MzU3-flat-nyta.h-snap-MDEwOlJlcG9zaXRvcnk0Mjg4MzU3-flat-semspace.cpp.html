
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.1194029850746268%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nyta.h</h3>
            <pre><code>1  #ifndef nyta_h
2  #define nyta_h
3  #include "base.h"
4  ClassTPV(TNytaDoc, PNytaDoc, TNytaDocV)
5  public:
6    TStr UrlStr;
7    TStr TitleXmlStr;
8    TStr SummaryXmlStr;
9    TStr DateStr;
10    TIntV TopicIdV;
11  public:
12    TNytaDoc():
13      UrlStr(), TitleXmlStr(), SummaryXmlStr(), DateStr(), TopicIdV(){}
14    TNytaDoc(const TNytaDoc& NytaDoc):
15      UrlStr(NytaDoc.UrlStr),
16      TitleXmlStr(NytaDoc.TitleXmlStr), SummaryXmlStr(NytaDoc.SummaryXmlStr),
17      DateStr(NytaDoc.DateStr), TopicIdV(NytaDoc.TopicIdV){}
18    TNytaDoc(const TStr& _UrlStr,
19     const TStr& _TitleXmlStr, const TStr& _SummaryXmlStr,
20     const TStr& _DateStr, const TIntV& _TopicIdV=TIntV()):
21      UrlStr(_UrlStr),
22      TitleXmlStr(_TitleXmlStr), SummaryXmlStr(_SummaryXmlStr),
23      DateStr(_DateStr), TopicIdV(_TopicIdV){}
24    static PNytaDoc New(){
25      return new TNytaDoc();}
26    static PNytaDoc New(const TStr& UrlStr,
27     const TStr& TitleXmlStr, const TStr& SummaryXmlStr,
28     const TStr& DateStr, const TIntV& TopicIdV=TIntV()){
29      return new TNytaDoc(UrlStr, TitleXmlStr, SummaryXmlStr, DateStr, TopicIdV);}
30    ~TNytaDoc(){}
31    TNytaDoc(TSIn& SIn):
32      UrlStr(SIn), TitleXmlStr(SIn), SummaryXmlStr(SIn), DateStr(SIn), TopicIdV(SIn){}
33    static PNytaDoc Load(TSIn& SIn){return new TNytaDoc(SIn);}
34    void Save(TSOut& SOut){
35      UrlStr.Save(SOut);
36      TitleXmlStr.Save(SOut); SummaryXmlStr.Save(SOut);
37      DateStr.Save(SOut); TopicIdV.Save(SOut);}
38    bool operator==(const TNytaDoc& NytaDoc) const {
39      return (DateStr==NytaDoc.DateStr)&&(UrlStr==NytaDoc.UrlStr);}
40    bool operator<(const TNytaDoc& NytaDoc) const {
41      return (DateStr<NytaDoc.DateStr)||
42       ((DateStr==NytaDoc.DateStr)&&(UrlStr<NytaDoc.UrlStr));}
43    TStr GetYMDDateStr() const {
44      return DateStr.GetSubStr(0, 3)+"-"+DateStr.GetSubStr(4, 5)+"-"+
45       DateStr.GetSubStr(6, 7);}
46    void AddTopicId(const int& TopicId){TopicIdV.AddUnique(TopicId);}
47    int GetTopicIds() const {return TopicIdV.Len();}
48    int GetTopicId(const int& TopicIdN) const {return TopicIdV[TopicIdN];}
49  };
50  class TNytTopic{
51  public:
52    TStrV TopicTagNmV;
53    TIntV DocIdV;
54  public:
55    TNytTopic(): TopicTagNmV(), DocIdV(){}
56    TNytTopic(const TNytTopic& NytTopic):
57      TopicTagNmV(NytTopic.TopicTagNmV), DocIdV(NytTopic.DocIdV){}
58    ~TNytTopic(){}
59    TNytTopic(TSIn& SIn): TopicTagNmV(SIn), DocIdV(SIn){}
60    void Save(TSOut& SOut){TopicTagNmV.Save(SOut); DocIdV.Save(SOut);}
61    TNytTopic& operator=(const TNytTopic& NytTopic){
62      if (this!=&NytTopic){
63        TopicTagNmV=NytTopic.TopicTagNmV; DocIdV=NytTopic.DocIdV;}
64      return *this;}
65    void AddTopicTag(const TStr& TopicTagNm){
66      TopicTagNmV.AddUnique(TopicTagNm);}
67    int GetTopicTags() const {return TopicTagNmV.Len();}
68    TStr GetTopicTagNm(const int& TopicTagN) const {
69      return TopicTagNmV[TopicTagN];}
70  };
71  ClassTPV(TNytaBs, PNytaBs, TNytaBsV)
72  private:
73    TNytaDocV NytaDocV;
74    THash<TStrV, TNytTopic> TokStrVToTopicH;
75    TStrIntVH TopicNmFirstTokStrToToksVH;
76    UndefAssign(TNytaBs);
77  public:
78    TNytaBs(): NytaDocV(){}
79    TNytaBs(const TNytaBs& NytaBs): NytaDocV(NytaBs.NytaDocV){}
80    static PNytaBs New(){return new TNytaBs();}
81    ~TNytaBs(){}
82    TNytaBs(TSIn& SIn): NytaDocV(SIn){}
83    static PNytaBs Load(TSIn& SIn){return new TNytaBs(SIn);}
84    void Save(TSOut& SOut){NytaDocV.Save(SOut);}
85    int GetDocs() const {return NytaDocV.Len();}
86    void AddDoc(const PNytaDoc& NytaDoc){NytaDocV.Add(NytaDoc);}
87    PNytaDoc GetDoc(const int& DocN) const {return NytaDocV[DocN];}
88    void SortDocs(){NytaDocV.Sort();}
89    void LoadNytTopics(const TStr& FPath);
90    void LoadGeoNames(const TStr& FPath);
91    void SaveNytTopicsTxt(const TStr& FNm);
92    void AnnotateWithNytTopics();
93    int AddTopicNm(const TStrV& TopicNmTokStrV,
94     const TStr& TopicTagNm1=TStr(), const TStr& TopicTagNm2=TStr(),
95     const TStr& TopicTagNm3=TStr());
96    int GetTopicNms() const {return TokStrVToTopicH.Len();}
97    TStr GetTopicNm(const int& TopicId) const;
98    bool IsTopic(const TStrV& TopicNmTokStrV, int& TopicId) const {
99      return TokStrVToTopicH.IsKey(TopicNmTokStrV, TopicId);}
100    int GetTopicId(const TStrV& TopicNmTokStrV) const {
101      return TokStrVToTopicH.GetKeyId(TopicNmTokStrV);}
102    void AddTopicDocId(const int& TopicId, const int& DocId){
103      TokStrVToTopicH[TopicId].DocIdV.AddUnique(DocId);}
104    int GetTopicDocIds(const int& TopicId) const {
105      return TokStrVToTopicH[TopicId].DocIdV.Len();}
106    int GetTopicDocId(const int& TopicId, const int& DocIdN) const {
107      return TokStrVToTopicH[TopicId].DocIdV[DocIdN];}
108    int GetTopicTags(const int& TopicId) const {
<span onclick='openModal()' class='match'>109      return TokStrVToTopicH[TopicId].TopicTagNmV.Len();}
110    TStr GetTopicTagNm(const int& TopicId, const int& TopicTagN) const {
111      return TokStrVToTopicH[TopicId].TopicTagNmV[TopicTagN];}
</span>112    static PNytaBs LoadBin(const TStr& FNm){
113      TFIn SIn(FNm); return Load(SIn);}
114    void SaveBin(const TStr& FNm){
115      TFOut SOut(FNm); Save(SOut);}
116    void SaveTxt(const TStr& FNm);
117    void SaveR2KXml(const TStr& FNm);
118  };
119  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</h3>
            <pre><code>1  THash<TStr, TSemSpace::TSemSpcLoadF> TSemSpace::TypeToLoadFH;
2  bool TSemSpace::Reg(const TStr& TypeNm, const TSemSpcLoadF& LoadF) {
3    IAssert(!TypeToLoadFH.IsKey(TypeNm));
4    TypeToLoadFH.AddDat(TypeNm, LoadF);
5    return true;
6  }
7  PSemSpace TSemSpace::Load(TSIn& SIn) {
8      TStr TypeNm(SIn);
9      int TypeKeyId=-1;
10      if (TypeToLoadFH.IsKey(TypeNm, TypeKeyId)){
11          TSemSpcLoadF LoadF=TypeToLoadFH[TypeKeyId];
12          return (*LoadF())(SIn);
13      } else {
14          return NULL;
15      }
16  }
17  double TSemSpace::GetAvgApprox(const TVec<PBowSpV>& BowSpV, const int& Dim) const {
18      PMom Mom = TMom::New();
19      for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
20          PBowSpV ProjSpV = this->ProjectSpV(BowSpV[DocN], Dim, false);
21          Mom->Add(ProjSpV->GetNorm());
22      }
23      Mom->Def();            
24      return Mom->GetMean();
25  }
26  int TSemSpace::GetDimNeededForApprox(const TVec<PBowSpV>& BowSpV, 
27          const double& ApproxThresh, double& ApproxVal, const int& MxDimDiff) const {
28      IAssert(0.0 < ApproxThresh && ApproxThresh < 1.0);
29      int BottomDim = 0, TopDim = this->GetVecs();
30      ApproxVal = GetAvgApprox(BowSpV, TopDim);
31      if (ApproxVal < ApproxThresh) { return TopDim; }
32      forever {
33          if (TopDim - BottomDim < MxDimDiff) {  return TopDim; }
34          IAssert(TopDim > BottomDim);
35          const int SemSpcDim = (TopDim + BottomDim) / 2;
36          ApproxVal = GetAvgApprox(BowSpV, SemSpcDim);
37          if (ApproxVal < ApproxThresh) {
38              IAssert(BottomDim < SemSpcDim);
39              BottomDim = SemSpcDim;
40          } else {
41              IAssert(TopDim > SemSpcDim);
42              TopDim = SemSpcDim;
43          }
44      }
45  }
46  PBowDocPart TSemSpace::GetBowDocPart(const PBowDocBs& BowDocBs,
47          const int& StartVecN, const int _Vecs, const double& Eps) const {
48      PBowDocPart BowDocPart = TBowDocPart::New();
49      const int Vecs = _Vecs == -1 ? this->GetVecs() : _Vecs;
50      IAssert(Vecs < this->GetVecs());
51      for (int VecN = StartVecN; VecN < Vecs; VecN++) {
52          PBowSpV PosSpV, NegSpV; 
53          this->GetVecBowSpV(VecN, PosSpV, NegSpV, Eps);
54          if (PosSpV->Len() > 0) {
55              PBowDocPartClust Clust = TBowDocPartClust::New(
56                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), PosSpV, NULL);
57              BowDocPart->AddClust(Clust);
58          }
59          if (NegSpV->Len() > 0) {
60              PBowDocPartClust Clust = TBowDocPartClust::New(
61                  BowDocBs, TStr::Fmt("Vec%dPos", VecN), 0.0, TIntV(), NegSpV, NULL);
62              BowDocPart->AddClust(Clust);
63          }
64      }
65      return BowDocPart;
66  }
67  void TSemSpace::GetVecBowSpV(const int& VecN, PBowSpV& PosSpV, 
68          PBowSpV& NegSpV, const double& Eps) const {
69      IAssert(0.0 <= Eps && Eps <= 1.0);
70      TFltV Vec; GetVec(VecN, Vec);
71      PosSpV = TBowSpV::New(); NegSpV = TBowSpV::New();
72      const int Len = Vec.Len();
73      for (int i = 0; i < Len; i++) {
74          if (Vec[i] > Eps) {
75              PosSpV->AddWIdWgt(i, Vec[i]);
76          } else if (-Vec[i] > Eps) {
77              NegSpV->AddWIdWgt(i, -Vec[i]);
78          }
79      }
80  }
81  void TSemSpace::GetWords(PBowDocBs BowDocBs, const int& VecN, 
82          const int& TopWords, const double& TopWordsWgtPrc, 
83          TStrFltPrV& PosWordStrWgtV, TStrFltPrV& NegWordStrWgtV) const {
84      PBowSpV PosSpV, NegSpV; this->GetVecBowSpV(VecN, PosSpV, NegSpV);
85      PosWordStrWgtV.Clr();
86      if (PosSpV->Len() > 0) {
87          PosSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, PosWordStrWgtV);
88      }
89      NegWordStrWgtV.Clr();
90      if (NegSpV->Len() > 0) {
91          NegSpV->GetWordStrWgtPrV(BowDocBs, TopWords, TopWordsWgtPrc, NegWordStrWgtV);
92      }
93  }
94  void TSemSpace::SaveTxt(const TStr& FNm, PBowDocBs BowDocBs, const int& TopWords, 
95          const double& TopWordsWgtPrc, const bool& ShowWgt) const {
96      PSOut Out = TFOut::New(FNm);
97      Out->PutStrLn("Semantic Space generation method: " + MethodeType);
98      Out->PutLn();
99      const int Vecs = GetVecs();
100      for (int VecN = 0; VecN < Vecs; VecN++) {
101          Out->PutStrLn(TStr::Fmt("Vector no.\t%d:", VecN));
102          TStrFltPrV PosWordStrWgtV, NegWordStrWgtV;
103          this->GetWords(BowDocBs, VecN, TopWords, TopWordsWgtPrc, 
104              PosWordStrWgtV, NegWordStrWgtV);
105          Out->PutStr("+\t");
106          for (int i = 0; i < PosWordStrWgtV.Len(); i++) {
107              if (ShowWgt) {
108                  Out->PutStr(TStr::Fmt("%s:%g\t", 
109                      PosWordStrWgtV[i].Val1.CStr(), PosWordStrWgtV[i].Val2.Val));
110              } else {
111                  Out->PutStr(TStr::Fmt("%s\t", PosWordStrWgtV[i].Val1.CStr()));
112              }
113          }
114          Out->PutLn(); 
115          Out->PutStr("-\t");
116          for (int i = 0; i < NegWordStrWgtV.Len(); i++) {
117              if (ShowWgt) {
118                  Out->PutStr(TStr::Fmt("%s:%g\t", 
119                      NegWordStrWgtV[i].Val1.CStr(), NegWordStrWgtV[i].Val2.Val));
120              } else {
121                  Out->PutStr(TStr::Fmt("%s\t", NegWordStrWgtV[i].Val1.CStr()));
122              }
123          }
124          Out->PutLn(2);
125      }
126  }
127  void TSemSpace::SaveTxtStat(const TStr& FNm, PSemSpace SemSp1, PBowDocBs BowBs1, 
128          PBowDocWgtBs BowWgt1, PSemSpace SemSp2, PBowDocBs BowBs2, 
129          PBowDocWgtBs BowWgt2, const bool& NormP, const TIntV& DIdV) {
130      printf("project first set...\n");
131      TIntV DIdV1 = DIdV; if (DIdV.Empty()) BowBs1->GetAllDIdV(DIdV1);
132      PBowDocBs Set1 = SemSp1->Project(BowBs1, BowWgt1, DIdV1, SemSp1->GetVecs(), NormP);
133      printf("project second set...\n");
134      TIntV DIdV2 = DIdV; if (DIdV.Empty()) BowBs2->GetAllDIdV(DIdV2);
135      PBowDocBs Set2 = SemSp2->Project(BowBs2, BowWgt2, DIdV2, SemSp2->GetVecs(), NormP);
136      IAssert(Set1->GetDocs() == Set2->GetDocs());
137      PSOut SOut = TFOut::New(FNm);
138      printf("comparing %s vs. %s...\n", 
139          SemSp1->GetMethodeType().CStr(), SemSp2->GetMethodeType().CStr());
140      SOut->PutStrLn("DId, ||Vec1||, ||Vec2||, <Vec1/||Vec1||,Vec2/||Vec2||>");
141      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
142          printf("%d\r", DocC);
143          TStr DocNm1 = BowBs1->GetDocNm(DIdV[DocC]), DocNm2 = BowBs2->GetDocNm(DIdV[DocC]);
144          IAssert(DocNm1.Left(DocNm1.Len() - 3) == DocNm2.Left(DocNm2.Len() - 3));
145          TStr NewDocNm1 = Set1->GetDocNm(DocC), NewDocNm2 = Set2->GetDocNm(DocC);
146          IAssertR(DocNm1 == NewDocNm1, DocNm1 + "!=" + NewDocNm1);
147          IAssertR(DocNm2 == NewDocNm2, DocNm2 + "!=" + NewDocNm2);
148          PBowSpV Vec1 = Set1->GetDocSpV(DocC);
149          PBowSpV Vec2 = Set2->GetDocSpV(DocC);
150          const double n1 = Vec1->GetNorm();
151          const double n2 = Vec2->GetNorm();
152          const double dp = (n1*n2 > 0.0) ? TBowLinAlg::DotProduct(Vec1, Vec2)/(n1*n2) : 0.0;
153          SOut->PutStrLn(TStr::Fmt("%d\t%.5f\t%.5f\t%.5f", DIdV[DocC].Val, n1, n2, dp));
154      }
155      SOut->Flush();
156      printf("\ndone\n");
157  }
158  void TSemSpace::SaveApproxStat(const TStr& FNm, 
159          const TVec<PBowSpV>& BowSpV, const int& Step) const {
160      PSOut SOut = TFOut::New(FNm);
161      SOut->PutStrLn("Testing approximation quality");
162      SOut->PutStrLn(TStr::Fmt("Average of norms should converge to 1.0 as dim->%d", GetVecs()));
163      SOut->PutStrLn("==============================================================");
164      for (int Dims = Step; Dims < GetVecs(); Dims+=Step) {  
165          PMom Mom = TMom::New();
166          for (int DocN = 0; DocN < BowSpV.Len(); DocN++) {
167              PBowSpV ProjSpV = ProjectSpV(BowSpV[DocN], Dims, false);
168              Mom->Add(ProjSpV->GetNorm());
169          }
170          Mom->Def();
171          SOut->PutStrLn(TStr::Fmt("Norm(dim:%d) = [avg: %.3f, sdev: %.3f]", Dims, Mom->GetMean(), Mom->GetSDev()));
172      }
173  }
174  bool TVecSemSpace::IsReg=TVecSemSpace::MkReg();
175  TVecSemSpace::TVecSemSpace(const TFltVV& BasisVV, 
176          const TStr& _MethodeType): TSemSpace(_MethodeType) {
177      const int Len = BasisVV.GetXDim();
178      const int Dim = BasisVV.GetYDim();
179      BasisV.Gen(Dim);
180      for (int VecN = 0; VecN < Dim; VecN++) {
181          BasisV[VecN].Gen(Len,0);
182          for (int i = 0; i < Len; i++) {
183              BasisV[VecN].Add(BasisVV(i, VecN)); }
184      }
185  }
186  TVecSemSpace::TVecSemSpace(PSVMTrainSet Set, PPartialGS R, 
187          const TVec<TFltV>& DrctV, const TStr& _MethodeType): TSemSpace(_MethodeType) { 
188      IAssert(Set->Len() == R->GetCols()); 
189      const int Dim = DrctV.Len();
190      const int DocN = R->GetCols(), AproxN = R->GetRows();
191      const TIntV& IdV = R->GetIdV();
192      BasisV.Gen(Dim, 0); TFltV AlphV(DocN);
193      TVec<TFltV> q(AproxN); R->GetBasisV(q);
194      TFltV ww(AproxN); 
195      for (int i = 0; i < Dim; i++) {
196          printf("\r%d", i);
197          const TFltV& w = DrctV[i];
198          IAssert(w.Len() <= AproxN);
199          ww.PutAll(0.0);
200          for (int j = 0; j < w.Len(); j++)
201              TLinAlg::AddVec(w[j], q[j], ww, ww);
202          AlphV.PutAll(0.0);
203          for (int j = 0; j < AproxN; j++)
204              AlphV[IdV[j]] = ww[j];
205          TFltV Col; Set->LinComb(AlphV, Col); BasisV.Add(Col);
206      }
207      printf("\n");
208  };
209  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName): TSemSpace("Matlab") {
210      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
211  }
212  TVecSemSpace::TVecSemSpace(const TStr& MatlabFName, 
213          const TStr& MapFName): TSemSpace("Matlab") {
214      TLAMisc::LoadMatlabTFltVV(MatlabFName, BasisV);
215      PSIn SIn = TFIn::New(MapFName);
216      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
217      int Words = BasisV[0].Len(); TIntV WIdV(Words, 0);
218      for (int WdN = 0; WdN < Words; WdN++) {
219          if (WdN % 100 == 0) { printf("%d\r", WdN); }
220          Lx.GetSym(syInt); WIdV.Add(Lx.Int);
221          Lx.GetSym(syInt); IAssertR((Lx.Int-1) == WdN, TStr::Fmt("line %d", WdN));
222          Lx.GetSym(syStr, syIdStr, syQStr);
223          Lx.GetSym(syEof, syEoln);
224      }
225      printf("\n"); IAssert(WIdV.IsSorted());
226      const int NewSize = WIdV.Last()+1;
227      for (int VecN = 0; VecN < BasisV.Len(); VecN++) {
228          TFltV NewVec(NewSize); NewVec.PutAll(0.0);
229          for (int WdN = 0; WdN < Words; WdN++) {
230              NewVec[WIdV[WdN]] = BasisV[VecN][WdN];
231          }
232          BasisV[VecN] = NewVec;
233      }
234  }
235  PBowDocBs TVecSemSpace::Project(const PBowDocBs& BowDocBs, 
236          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
237          const int& Vecs, const bool& NormP) const {
238      IAssert(Vecs <= BasisV.Len());
239      PBowDocBs NewBowDocBs = TBowDocBs::New();
240      for (int i = 0; i < Vecs; i++) {
241          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); }  
242      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
243          const int DId = DIdV[DocC];
244          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
245          for (int i = 0; i < Vecs; i++) {
246              const double Elt = TBowLinAlg::DotProduct(
247                  BasisV[i], BowDocWgtBs->GetSpV(DId));
248              PSpV.Add(TIntFltPr(i, Elt)); 
249              VecNorm += TMath::Sqr(Elt);
250          }
251          if (NormP && VecNorm > 0.0) {
252              VecNorm = sqrt(VecNorm);
253              for (int i = 0; i < Vecs; i++) {
254                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
255              }
256          }
257          const int CatN = BowDocBs->GetDocCIds(DId);
258          TStrV CatNmV(CatN, 0);
259          for (int CatC = 0; CatC < CatN; CatC++) { 
260              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
261          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
262      }
263      NewBowDocBs->AssertOk();
264      return NewBowDocBs;
265  }
266  PBowSpV TVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
267          const int& Vecs, const bool& NormP) const {
268      PSVMTrainSet Set = TBowTrainSet::New(1); 
269      Set->AddAttrV(0, SpV, 1.0);
270      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
271      for (int i = 0; i < Vecs; i++) {
272          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
273      if (NormP) { NewSpV->PutUnitNorm(); }
274      return NewSpV;
275  }
276  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
277          const bool& NormP, TIntFltKdV& ProjSpV) const {
278      ProjSpV.Gen(Vecs, 0);
279      for (int i = 0; i < Vecs; i++) {
280          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
281      if (NormP) { TLinAlg::Normalize(ProjSpV); }
282  }
283  void TVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
284          const bool& NormP, TFltV& ProjV) const {
285      ProjV.Gen(Vecs, 0);
286      for (int i = 0; i < Vecs; i++) {
287          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
288      if (NormP) { TLinAlg::Normalize(ProjV); }
289  }
290  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
291          const bool& NormP, TIntFltKdV& ProjSpV) const {
292      ProjSpV.Gen(Vecs, 0);
293      for (int i = 0; i < Vecs; i++) {
294          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
295      if (NormP) { TLinAlg::Normalize(ProjSpV); }   
296  }
297  void TVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
298          const bool& NormP, TFltV& ProjV) const {
299      ProjV.Gen(Vecs, 0);
300      for (int i = 0; i < Vecs; i++) {
301          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
302      if (NormP) { TLinAlg::Normalize(ProjV); }   
303  }
304  void TVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
305          const bool& NormP, TFltV& ProjV) const {
306      ProjV.Gen(Vecs, 0);
307      for (int i = 0; i < Vecs; i++) {
308          ProjV.Add(TLinAlg::DotProduct(BasisV[i], FullV)); }
309      if (NormP) { TLinAlg::Normalize(ProjV); }
310  }
311  bool TSpVecSemSpace::IsReg=TSpVecSemSpace::MkReg();
312  TSpVecSemSpace:: TSpVecSemSpace(const TVec<TIntFltKdV>& _BasisV, const TStr& _MethodeType): 
313        TSemSpace(_MethodeType), BasisV(_BasisV) { 
314      const int Vecs = BasisV.Len();
315      VecDim = 0;
316      for (int VecN = 0; VecN < Vecs; VecN++) {
317          VecDim = TInt::GetMx(VecDim, BasisV.Last().Last().Key);
318      }
319      VecDim++;
320  };
321  PBowDocBs TSpVecSemSpace::Project(const PBowDocBs& BowDocBs, 
322          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
323          const int& Vecs, const bool& NormP) const {
324      IAssert(Vecs <= BasisV.Len());
325      PBowDocBs NewBowDocBs = TBowDocBs::New();
326      for (int i = 0; i < Vecs; i++) {
327          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
328      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
329          const int DId = DIdV[DocC];
330          TIntFltPrV PSpV(Vecs, 0); double VecNorm = 0.0;
331          for (int i = 0; i < Vecs; i++) {
332              const double Elt = TBowLinAlg::DotProduct(
333                  BasisV[i], BowDocWgtBs->GetSpV(DId));
334              PSpV.Add(TIntFltPr(i, Elt)); 
335              VecNorm += TMath::Sqr(Elt);
336          }
337          if (NormP && VecNorm > 0.0) {
338              VecNorm = sqrt(VecNorm);
339              for (int i = 0; i < Vecs; i++) {
340                  PSpV[i].Val2 = PSpV[i].Val2 / VecNorm;
341              }
342          }
343          const int CatN = BowDocBs->GetDocCIds(DId);
344          TStrV CatNmV(CatN, 0);
345          for (int CatC = 0; CatC < CatN; CatC++) { 
346              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
347          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, PSpV); 
348      }
349      NewBowDocBs->AssertOk();
350      return NewBowDocBs;
351  }
352  PBowSpV TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, 
353          const int& Vecs, const bool& NormP) const {
354      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
355      for (int i = 0; i < Vecs; i++) {
356          NewSpV->AddWIdWgt(i, TBowLinAlg::DotProduct(BasisV[i], SpV)); }
357      if (NormP) { NewSpV->PutUnitNorm(); }
358      return NewSpV;
359  }
360  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
361          const bool& NormP, TIntFltKdV& ProjSpV) const {
362      ProjSpV.Gen(Vecs, 0);
363      for (int i = 0; i < Vecs; i++) {
364          ProjSpV.Add(TIntFltKd(i, TBowLinAlg::DotProduct(BasisV[i], SpV))); }
365      if (NormP) { TLinAlg::Normalize(ProjSpV); }
366  }
367  void TSpVecSemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
368          const bool& NormP, TFltV& ProjV) const {
369      ProjV.Gen(Vecs, 0);
370      for (int i = 0; i < Vecs; i++) {
371          ProjV.Add(TBowLinAlg::DotProduct(BasisV[i], SpV)); }
372      if (NormP) { TLinAlg::Normalize(ProjV); }
373  }
374  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
375          const bool& NormP, TIntFltKdV& ProjSpV) const {
376      ProjSpV.Gen(Vecs, 0);
377      for (int i = 0; i < Vecs; i++) {
378          ProjSpV.Add(TIntFltKd(i, TLinAlg::DotProduct(BasisV[i], SpV))); }
379      if (NormP) { TLinAlg::Normalize(ProjSpV); }  
380  }
381  void TSpVecSemSpace::ProjectSpV(const TIntFltKdV& SpV, const int& Vecs, 
382          const bool& NormP, TFltV& ProjV) const {
383      ProjV.Gen(Vecs, 0);
384      for (int i = 0; i < Vecs; i++) {
385          ProjV.Add(TLinAlg::DotProduct(BasisV[i], SpV)); }
386      if (NormP) { TLinAlg::Normalize(ProjV); }  
387  }
388  void TSpVecSemSpace::ProjectV(const TFltV& FullV, const int& Vecs, 
389          const bool& NormP, TFltV& ProjV) const {
390      ProjV.Gen(Vecs, 0);
391      for (int i = 0; i < Vecs; i++) {
392          ProjV.Add(TLinAlg::DotProduct(FullV, BasisV[i])); }
393      if (NormP) { TLinAlg::Normalize(ProjV); }     
394  }
395  int TSpVecSemSpace::GetVecLen() const {
396      const int Vecs = GetVecs(); int MxDim = 0;
397      for (int i = 0; i < Vecs; i++) {
398          MxDim = TInt::GetMx(BasisV[i].Last().Key, 0); }
399      return MxDim;
400  }
401  bool TKCCASemSpace::IsReg=TKCCASemSpace::MkReg();
402  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
403          const bool& NormP, TIntFltPrV& ProjSpV) const {
404      const int N = TrainSet->Len(); TFltV z(N, 0);
405      TFltV DotProdV(N, 0);
406      for (int i = 0; i < N; i++)
407          DotProdV.Add(TrainSet->DotProduct(i, SpV));
408      for (int i = 0; i < N; i++) 
409          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
410      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
411      for (int i = 0; i < Vecs; i++) {
412          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
413          ProjSpV.Add(TIntFltPr(i, Wgt));
414          Norm += TMath::Sqr(Wgt);
415      }
416      if (NormP) {
417          Norm = sqrt(Norm);
418          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Val2 /= Norm; }
419      }
420  }
421  TKCCASemSpace::TKCCASemSpace(PSVMTrainSet Set, PPartialGS R, const TVec<TFltV>& DrctV, const TStr& _MethodeType): 
422          TSemSpace(_MethodeType), TrainSet(Set) { 
423      IAssert(Set->Len() == R->GetCols()); 
424      BasisV = DrctV;
425      R->GetBasisV(GSBasisV);
426      const TIntV& DIdV = R->GetIdV();
427      const int Dim = R->GetRows();
428      TrainSet = TBowTrainSet::New(Dim);
429      for (int VecC = 0; VecC < Dim; VecC++) {
430          const int DocId = DIdV[VecC];
431          TrainSet->AddAttrV(Set->GetVecDId(DocId), Set->GetAttrBowV(DocId), Set->GetVecParam(DocId));
432      }
433      IAssert(GSBasisV.Len() == TrainSet->Len() && GSBasisV[0].Len() == TrainSet->Len());
434  }
435  PBowDocBs TKCCASemSpace::Project(const PBowDocBs& BowDocBs, 
436          const PBowDocWgtBs& BowDocWgtBs, const TIntV& DIdV, 
437          const int& Vecs, const bool& NormP) const {
438      IAssert(Vecs <= BasisV.Len());
439      PBowDocBs NewBowDocBs = TBowDocBs::New();
440      for (int i = 0; i < Vecs; i++) {
441          NewBowDocBs->AddWordStr("Comp" + TInt::GetStr(i)); } 
442      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
443      for (int DocC = 0, DocN = DIdV.Len(); DocC < DocN; DocC++) {
444          const int DId = DIdV[DocC];
445          TIntFltPrV ProjVec; 
446          ProjectSpV(BowDocWgtBs->GetSpV(DId), Vecs, NormP, ProjVec);
447          const int CatN = BowDocBs->GetDocCIds(DId);
448          TStrV CatNmV(CatN, 0);
449          for (int CatC = 0; CatC < CatN; CatC++) { 
450              CatNmV.Add(BowDocBs->GetCatNm(BowDocBs->GetDocCId(DId, CatC))); }
451          NewBowDocBs->AddDoc(BowDocBs->GetDocNm(DId), CatNmV, ProjVec); 
452      }
453      printf("\n");
454      NewBowDocBs->AssertOk();
455      return NewBowDocBs;
456  }
457  PBowSpV TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, 
458          const int& Vecs, const bool& NormP) const {
459      TIntFltPrV ProjVec; ProjectSpV(SpV, Vecs, NormP, ProjVec);
460      PBowSpV NewSpV = TBowSpV::New(-1, Vecs);
461      for (int i = 0; i < Vecs; i++) {
462          const TIntFltPr Wgt = ProjVec[i];
463          NewSpV->AddWIdWgt(Wgt.Val1, Wgt.Val2);
464      }
465      return NewSpV;
466  }
467  void TKCCASemSpace::ProjectSpV(const PBowSpV& SpV, const int& Vecs, 
468          const bool& NormP, TIntFltKdV& ProjSpV) const {
469      const int N = TrainSet->Len(); TFltV z(N, 0);
470      TFltV DotProdV(N, 0);
471      for (int i = 0; i < N; i++)
472          DotProdV.Add(TrainSet->DotProduct(i, SpV));
473      for (int i = 0; i < N; i++) 
474          z.Add(TLinAlg::DotProduct(GSBasisV[i], DotProdV));
475      ProjSpV.Gen(Vecs, 0); double Norm = 0.0;
476      for (int i = 0; i < Vecs; i++) {
477          const double Wgt = TLinAlg::DotProduct(z, BasisV[i]);
478          ProjSpV.Add(TIntFltKd(i, Wgt));
479          Norm += TMath::Sqr(Wgt);
480      }
481      if (NormP) {
482          Norm = sqrt(Norm);
483          for (int i = 0; i < Vecs; i++) { ProjSpV[i].Dat /= Norm; }
484      }
485  }
486  void TKCCASemSpace::GetVec(const int& VecN, TFltV& VecV) const {
487      const int GSDim = GSBasisV[0].Len();
488      const TFltV& w = BasisV[VecN];
489      IAssert(w.Len() == GSDim);
490      TFltV AlphV(GSDim); AlphV.PutAll(0.0);
491      for (int j = 0; j < GSDim; j++)
492          TLinAlg::AddVec(w[j], GSBasisV[j], AlphV, AlphV);
493      TrainSet->LinComb(AlphV, VecV);
494  }
495  void TSemSpaceAlg::CalcKCCA(const TFltVV& Ra, const TFltVV& Rb, 
496          const double& ta, const double& tb, const TKCCACorrNrmType& CorrNrmType, 
497          TVec<TFltV>& DrctAV, TVec<TFltV>& DrctBV, TFltV& CorrV) {
498      IAssert(Ra.GetCols() == Rb.GetCols());
499      const int Size = Ra.GetCols();
500      IAssert(Ra.GetRows() >= Rb.GetRows());
501      const int SubSizeA = Ra.GetRows();
502      const int SubSizeB = Rb.GetRows();
503      printf("step (2)...\n");
504      TFltVV R(SubSizeB, SubSizeB); 
505      for (int i = 0; i < SubSizeB; i++) {
506          for (int j = i; j < SubSizeB; j++) {
507              double res = 0.0;
508              for (int k = 0; k < Size; k++) {
509                  res += Rb(i,k) * Rb(j,k);  
510              }
511              R(i,j) = (1-tb)*res;
512          }
513          R(i,i) += tb;
514      }
515      TFltV Rp(SubSizeB);
516      printf("choleksy decomposition...");
517      TNumericalStuff::CholeskyDecomposition(R, Rp);
518      for (int i = 0; i < SubSizeB; i++) {
519          R(i,i) = Rp[i];  
520          for (int j = i+1; j < SubSizeB; j++)
521              R(i,j) = R(j,i); 
522      }
523      printf("invR...\n");
524      TNumericalStuff::InverseTriagonal(R);
525      printf("step (3)...\n");
526      TFltVV A(SubSizeA, SubSizeA);
527      printf("calculating: A...");
528      for (int i = 0; i < SubSizeA; i++) {
529          for (int j = i; j < SubSizeA; j++) {
530              double res = 0.0;
531              for (int k = 0; k < Size; k++) {
532                  res += Ra(i,k) * Ra(j,k);  
533              }
534              A(j,i) = A(i,j) = (1-ta)*res;
535          }
536          A(i,i) += ta;
537      }
538      printf("invA..."); 
539      TNumericalStuff::InverseSymetric(A);
540      TFltVV invA(SubSizeA, SubSizeA); 
541      for (int i = 0; i < SubSizeA; i++) {
542          invA(i,i) = A(i,i);
543          for (int j = i+1; j < SubSizeA; j++)
544              A(j,i) = invA(j,i) = invA(i,j) = A(i,j);
545      }
546      printf("invR'*Rb*Ra'*invA*Ra*Rb'*invR...");
547      printf("1..");
548      TFltVV RbRaT(SubSizeB, SubSizeA);
549      for (int i = 0; i < SubSizeB; i++) {
550          for (int j = 0; j < SubSizeA; j++) {
551              double res = 0.0;
552              for (int k = 0; k < Size; k++)
553                  res += Rb(i,k) * Ra(j,k);
554              RbRaT(i,j) = res;
555          }
556      }
557      printf("2..");
558      TFltVV B(SubSizeB, SubSizeA);
559      TLinAlg::Multiply(RbRaT, A, B);
560      A.Gen(SubSizeB, SubSizeB);
561      for (int i = 0; i < SubSizeB; i++) {
562          for (int j = 0; j < SubSizeB; j++) {
563              double sum = 0.0;
564              for (int k = 0; k < SubSizeA; k++)
565                  sum += B(i,k)*RbRaT(j,k);
566              A(i,j) = sum;
567          }
568      }
569      printf("3..");
570      B.Gen(SubSizeB, SubSizeB);
571      for (int i = 0; i < SubSizeB; i++) {
572          for (int j = 0; j < SubSizeB; j++) {
573              double sum = 0.0;
574              for (int k = 0; k <= i; k++)
575                  sum += R(k,i)*A(k,j);
576              B(i,j) = sum;
577          }
578      }
579      printf("4..");
580      for (int i = 0; i < SubSizeB; i++) {
581          for (int j = 0; j < SubSizeB; j++) {
582              double sum = 0.0;
583              for (int k = 0; k <= j; k++)
584                  sum += B(i,k)*R(k,j);
585              A(i,j) = sum;
586          }
587      }
588      printf("\nsolving eigneproblem...");
589      TFltV d(SubSizeB+1), e(SubSizeB+1);
590      printf("1..");
591      TNumericalStuff::SymetricToTridiag(A, SubSizeB, d, e);
592      TLAMisc::FillIdentity(B);
593      printf("2..");
594      TNumericalStuff::EigSymmetricTridiag(d, e, SubSizeB, B);
595      printf("3..");
596      TFltVV V(SubSizeB, SubSizeB);
597      TLinAlg::Multiply(A, B, V);
598      for (int i = 1; i <= SubSizeB; i++) d[i-1] = d[i];
599      d.DelLast(); 
600      printf("\nstep (4)...\n");
601      printf("Wb...");
602      for (int i = 0; i < SubSizeB; i++) {
603          for (int j = 0; j < SubSizeB; j++) {
604              double sum = 0.0;
605              for (int k = i; k < SubSizeB; k++)
606                  sum += R(i,k)*V(k,j);
607              B(i,j) = sum;
608          }
609      }
610      for (int j = 0; j < SubSizeB; j++) {
611          double norm = 0.0;
612          for (int i = 0; i < SubSizeB; i++)
613              norm += TMath::Sqr(B(i,j));
614          IAssert(norm > 0.0); norm = sqrt(norm);
615          for (int i = 0; i < SubSizeB; i++)
616              B(i,j) /= norm;
617      }
618      printf("Wa...");
619      V.Gen(SubSizeA, SubSizeB);
620      for (int i = 0; i < SubSizeA; i++) {
621          for (int j = 0; j < SubSizeB; j++) {
622              double sum = 0.0;
623              for (int k = 0; k < SubSizeA; k++)
624                  sum += invA(i,k)*RbRaT(j,k);
625              V(i,j) = sum;
626          }
627      }
628      A.Gen(SubSizeA, SubSizeB);
629      TLinAlg::Multiply(V, B, A);
630      for (int j = 0; j < SubSizeB; j++) {
631          double norm = 0.0;
632          for (int i = 0; i < SubSizeA; i++)
633              norm += TMath::Sqr(A(i,j));
634          IAssert(norm > 0.0); norm = sqrt(norm);
635          for (int i = 0; i < SubSizeA; i++)
636              A(i,j) /= norm;
637      }
638      Rp.Clr(); invA.Clr(); e.Clr(); R.Clr(); RbRaT.Clr(); V.Clr();
639      printf("\ndone...\n");
640      TFltIntKdV EigV(SubSizeB, 0);
641      for (int i = 0; i < SubSizeB; i++) EigV.Add(TFltIntKd(d[i], i));
642      EigV.Sort(false);
643      const int DrctN = SubSizeB-1; printf("SubSizeB = %d\n", SubSizeB);
644      DrctAV.Gen(DrctN); DrctBV.Gen(DrctN); CorrV.Gen(DrctN, 0);
645      TFltV RaTwa(Size), RbTwb(Size);
646      for (int i = 0; i < DrctN; i++) {
647          TFltV& wa = DrctAV[i]; wa.Gen(SubSizeA);
648          TFltV& wb = DrctBV[i]; wb.Gen(SubSizeB);
649          const int EigId = EigV[i+1].Dat;
650          CorrV.Add(EigV[i+1].Key);
651          for (int j = 0; j < SubSizeA; j++)
652              wa[j] = A(j, EigId);
653          for (int j = 0; j < SubSizeB; j++)
654              wb[j] = B(j, EigId);
655          if (CorrNrmType != kcntNone) {
656              double Corr = 1.0; 
657              if (CorrNrmType == kcntOne) { Corr = 1.0; }
658              else if (CorrNrmType == kcntEigVal) { Corr = CorrV.Last()/CorrV[0]; }
659              IAssert(Corr > 0.0);
660              TLinAlg::MultiplyT(Ra, wa, RaTwa);
661              const double KoefA = sqrt(Corr/TLinAlg::Norm2(RaTwa));
662              TLinAlg::MultiplyScalar(KoefA, wa, wa);
663              TLinAlg::MultiplyT(Ra, wa, RaTwa); 
664              IAssert(TFlt::Abs(TLinAlg::Norm2(RaTwa) - Corr) < 1e-7);
665              TLinAlg::MultiplyT(Rb, wb, RbTwb);
666              const double KoefB = sqrt(Corr/TLinAlg::Norm2(RbTwb));
667              TLinAlg::MultiplyScalar(KoefB, wb, wb);
668              TLinAlg::MultiplyT(Rb, wb, RbTwb); 
669              IAssert(TFlt::Abs(TLinAlg::Norm2(RbTwb) - Corr) < 1e-7);
670          }
671      }
672  }
673  void TSemSpaceAlg::CalcKCCA(PSVMTrainSet SetA, PSVMTrainSet SetB, const double& t, 
674          const int& SpaceDim, const double& Eps, PPartialGS& Ra, PPartialGS& Rb, 
675          const TKCCACorrNrmType& CorrNrmType, TVec<TFltV>& DrctAV, 
676          TVec<TFltV>& DrctBV, TFltV& EigV) {
677      IAssertR(SetA->Len() == SetB->Len() && SetB->Len() >= SpaceDim, 
678          TStr::Fmt("(SetA->Len() == %d) != (SetB->Len() == %d)", SetA->Len(), SetB->Len()));
679      IAssertR(0.0 <= t && t <= 1.0, TStr::Fmt("t=%d must be between 0.0 and 1.0!", t));
680      IAssertR(0.0 <= Eps && Eps < 1.0, TStr::Fmt("Eps=%d must be between 0.0 and 1.0!", Eps));
681      printf("step (1)...\n");
682      TFltVV RaVV, RbVV; 
683      printf("incomplete Cholesky... SetA\n");
684      Ra = TPartialGS::New(SetA(), SetA->Len(), Eps); Ra->GetDocVV(RaVV);
685      printf("incomplete Cholesky... SetB\n");
686      Rb = TPartialGS::New(SetB(), SetB->Len(), Eps); Rb->GetDocVV(RbVV);
687      const int NewSpaceDim = TInt::GetMn(RaVV.GetRows(), RbVV.GetRows());
688      if (RaVV.GetRows() > RbVV.GetRows()) {
689          CalcKCCA(RaVV, RbVV, t, t, CorrNrmType, DrctAV, DrctBV, EigV);
690      } else {
691          CalcKCCA(RbVV, RaVV, t, t, CorrNrmType, DrctBV, DrctAV, EigV);
692      }
693      IAssertR(DrctAV.Len() == NewSpaceDim-1  && DrctAV.Len() == NewSpaceDim-1,
694          TStr::Fmt("%d, %d != %d", DrctAV.Len(), DrctBV.Len(), NewSpaceDim-1));
695      if (DrctAV.Len() < SpaceDim) {
696          printf("SpaceDim is lowerd to %d!\n", DrctAV.Len());
697      } else {
698          DrctAV.Trunc(SpaceDim); DrctBV.Trunc(SpaceDim);
699      }
700  }
701  void TSemSpaceAlg::CalcKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
702          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
703          PSemSpace& SpB, TFltV& EigV, const TKCCACorrNrmType& CorrNrmType) {
704      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
705      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
706      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV;
707      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
708      SpA = TKCCASemSpace::New(SetA, Ra, DrctAV, "KCCA");
709      SpB = TKCCASemSpace::New(SetB, Rb, DrctBV, "KCCA");
710  }
711  void TSemSpaceAlg::CalcVecKCCA(const TVec<PBowSpV>& BowSpVA, const TVec<PBowSpV>& BowSpVB, 
712          const double& t, const int& SpaceDim, const double& Eps, PSemSpace& SpA, 
713          PSemSpace& SpB, const TKCCACorrNrmType& CorrNrmType) {
714      PSVMTrainSet SetA = TBowDocBs2TrainSet::NewBowNoCat(BowSpVA);
715      PSVMTrainSet SetB = TBowDocBs2TrainSet::NewBowNoCat(BowSpVB);
716      PPartialGS Ra, Rb; TVec<TFltV> DrctAV, DrctBV; TFltV EigV;
717      CalcKCCA(SetA, SetB, t, SpaceDim, Eps, Ra, Rb, CorrNrmType, DrctAV, DrctBV, EigV);
718      SpA = TVecSemSpace::New(SetA, Ra, DrctAV, "KCCA-Vec");
719      SpB = TVecSemSpace::New(SetB, Rb, DrctBV, "KCCA-Vec");
720  }
721  void TSemSpaceAlg::DecomposeKernelMatrix(PSVMTrainSet Set, const int& Dim, 
722          TVec<TFltV>& CompV, const bool& CenterMatrix) {
723      const int Size = Set->Len();
724      TFltVV K; TKernelUtil::CalcKernelMatrix(Set, K);
725      if (CenterMatrix) {
726          TKernelUtil::CenterKernelMatrix(K);
727      }
728      TFltV d(Size+1), e(Size+1);
729      TNumericalStuff::SymetricToTridiag(K, Size, d, e);
730      TFltVV V(Size, Size); TLAMisc::FillIdentity(V);
731      TNumericalStuff::EigSymmetricTridiag(d, e, Size, V);
732      TFltIntKdV EigV(Size, 0);
733      for (int i = 1; i <= Size; i++) {
734          EigV.Add(TFltIntKd(d[i], i-1));
735          d[i-1] = sqrt(1.0/d[i]);
736      }
737      EigV.Sort(false); d.DelLast();
738      CompV.Gen(Dim);
739      for (int i = 0; i < Dim; i++) {
740          const int ColId = EigV[i].Dat;
741          TFltV& v = CompV[i]; v.Gen(Size);
742          TLinAlg::Multiply(K, V, ColId, v); 
743          TLinAlg::MultiplyScalar(d[ColId], v, v);
744      }
745  }
746  PSemSpace TSemSpaceAlg::CalcKPCA(PSVMTrainSet Set) {
747      const int Dim = Set->Len(); TVec<TFltV> CompV;
748      DecomposeKernelMatrix(Set, Dim, CompV, true);
749      TVec<TFltV> PrCompV(CompV.Len());
750      for (int i = 0; i < PrCompV.Len(); i++)
751          Set->LinComb(CompV[i], PrCompV[i]);
752      return TVecSemSpace::New(PrCompV, "KPCA");
753  }
754  PSemSpace TSemSpaceAlg::CalcKPCA(const TVec<PBowSpV>& BowSpV) {
755      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
756      return CalcKPCA(Set);
757  }
758  PSemSpace TSemSpaceAlg::CalcKPCA(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV) {
759      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
760      return CalcKPCA(Set);
761  }
762  PSemSpace TSemSpaceAlg::CalcFullLSI(PSVMTrainSet Set, const int& SpaceDim) {
763      const int Dim = Set->Len(); TVec<TFltV> CompV;
764      DecomposeKernelMatrix(Set, Dim, CompV, false);
765      const int CompN = TInt::GetMn(CompV.Len(), SpaceDim+1);
766      TVec<TFltV> PrCompV(CompN-1);
767      for (int i = 1; i < CompN ; i++) {
768          Set->LinComb(CompV[i], PrCompV[i-1]);
769      }
770      return TVecSemSpace::New(PrCompV, "FullLSI");
771  }
772  PSemSpace TSemSpaceAlg::CalcFullLSI(const TVec<PBowSpV>& BowSpV, const int& SpaceDim) {
773      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowSpV);
774      return CalcFullLSI(Set, SpaceDim);
775  }
776  PSemSpace TSemSpaceAlg::CalcFullLSI(PBowDocWgtBs BowDocWgtBs, 
777          const TIntV& DIdV, const int& SpaceDim) {
778      PSVMTrainSet Set = TBowDocBs2TrainSet::NewBowNoCat(BowDocWgtBs, DIdV);
779      return CalcFullLSI(Set, SpaceDim);
780  }
781  PSemSpace TSemSpaceAlg::CalcSparseLSI(TMatrix& TermDocM, const int& _SpaceDim, 
782          const int& _MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
783      const int SpaceDim = TInt::GetMn(_SpaceDim, TermDocM.GetCols());
784      const int MaxLanczos = TInt::GetMn(_MaxLanczos, TermDocM.GetCols());
785      IAssertR(SpaceDim <= MaxLanczos, TStr::Fmt("%d <= %d", SpaceDim, MaxLanczos));
786      TFltV SgnV; TFltVV U, V; const int SgnN = SpaceDim;
787      if (TermDocM.GetCols() <= TermDocM.GetRows()) {
788          TSparseSVD::LanczosSVD(TermDocM, SgnN, 
789              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, U, V);
790      } else {
791  	    TermDocM.Transpose();
792  	    TSparseSVD::LanczosSVD(TermDocM, SgnN, 
793              TInt::GetMn(SgnN*4, MaxLanczos), ReOrtoType, SgnV, V, U);
794  	    TermDocM.Transpose();
795      }
796      IAssert(U.GetYDim() <= SgnN);
797      return TVecSemSpace::New(U, "SparseLSI");
<span onclick='openModal()' class='match'>798  }
799  PSemSpace TSemSpaceAlg::CalcSparseLSI(PSVMTrainSet Set, const int& SpaceDim, 
800          const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
801      TSTSetMatrix TermDocM(Set);
802      return CalcSparseLSI(TermDocM, SpaceDim, 
803          TInt::GetMn(MaxLanczos, Set->Len()), ReOrtoType);
804  }
</span>805  PSemSpace TSemSpaceAlg::CalcSparseLSI(const TVec<PBowSpV>& BowSpV,
806          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
807      TBowMatrix TermDocM(BowSpV);
808      return CalcSparseLSI(TermDocM, SpaceDim, 
809          TInt::GetMn(MaxLanczos, BowSpV.Len()), ReOrtoType);
810  }
811  PSemSpace TSemSpaceAlg::CalcSparseLSI(PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV,
812          const int& SpaceDim, const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
813      TBowMatrix TermDocM(BowDocWgtBs, DIdV);
814      return CalcSparseLSI(TermDocM, SpaceDim, 
815          TInt::GetMn(MaxLanczos, DIdV.Len()), ReOrtoType);
816  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nyta.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-semspace.cpp</div>
                <div class="column column_space"><pre><code>109      return TokStrVToTopicH[TopicId].TopicTagNmV.Len();}
110    TStr GetTopicTagNm(const int& TopicId, const int& TopicTagN) const {
111      return TokStrVToTopicH[TopicId].TopicTagNmV[TopicTagN];}
</pre></code></div>
                <div class="column column_space"><pre><code>798  }
799  PSemSpace TSemSpaceAlg::CalcSparseLSI(PSVMTrainSet Set, const int& SpaceDim, 
800          const int& MaxLanczos, const TSpSVDReOrtoType& ReOrtoType) {
801      TSTSetMatrix TermDocM(Set);
802      return CalcSparseLSI(TermDocM, SpaceDim, 
803          TInt::GetMn(MaxLanczos, Set->Len()), ReOrtoType);
804  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    