<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_CovIBUList.h &amp; ibex_CovSolverData.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_CovIBUList.h &amp; ibex_CovSolverData.h
      </h3>
<h1 align="center">
        40.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_CovIBUList.h (53.892216%)<th>ibex_CovSolverData.h (32.967033%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(155-167)<td><a href="#" name="0">(215-225)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(207-219)<td><a href="#" name="1">(260-272)</a><td align="center"><font color="#d00000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(59-89)<td><a href="#" name="2">(63-93)</a><td align="center"><font color="#830000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(191-199)<td><a href="#" name="3">(300-308)</a><td align="center"><font color="#640000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovIBUList.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef __IBEX_COV_IBU_LIST_H__
2 #define __IBEX_COV_IBU_LIST_H__
3 #include "ibex_CovIUList.h"
4 namespace ibex {
5 class CovIBUList : public CovIUList {
6 public:
7 	typedef enum { INNER, BOUNDARY, UNKNOWN } BoxStatus;
8 	typedef enum { INNER_PT, INNER_AND_OUTER_PT } BoundaryType;
9 	CovIBUList(size_t n, BoundaryType boundary_type=INNER_PT);
10 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	CovIBUList(const char* filename);
11 	CovIBUList(const Cov&amp; cov, bool copy=false);
12 	~CovIBUList();
13 	void save(const char* filename) const;
14 	virtual void add_inner(const IntervalVector&amp; x);
15 	virtual void add_boundary(const IntervalVector&amp; x);
16 	virtual void add_unknown(const IntervalVector&amp; x);</b></font>
17 	virtual void add(const IntervalVector&amp; x);
18 	BoxStatus status(int i) const;
19 	bool is_boundary(int i) const;
20 	bool is_unknown(int i) const;
21 	const IntervalVector&amp; boundary(int i) const;
22 	const IntervalVector&amp; unknown(int i) const;
23 	size_t nb_boundary() const;
24 	size_t nb_unknown() const;
25 	static std::string format();
26 	static const unsigned int FORMAT_VERSION;
27 	BoundaryType boundary_type() const;
28 protected:
29 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	static std::ifstream* read(const char* filename, CovIBUList&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
30 	static std::ofstream* write(const char* filename, const CovIBUList&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
31 	static void format(std::stringstream&amp; ss, const std::string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
32 	static const unsigned int subformat_level;</b></font>
33 	static const unsigned int subformat_number;
34 	struct Data {
35 		BoundaryType           _IBU_boundary_type;
36 		std::vector&lt;BoxStatus&gt; _IBU_status;       		std::vector&lt;size_t&gt;    _IBU_boundary;     		std::vector&lt;size_t&gt;    _IBU_unknown;      	} *data;
37 	bool own_data;
38 };
39 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CovIBUList&amp; cov);
40 <a name="3"></a>
41 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inline size_t CovIBUList::nb_boundary() const {
42 	return data-&gt;_IBU_boundary.size();
43 }
44 inline size_t CovIBUList::nb_unknown() const {
45 	return data-&gt;_IBU_unknown.size();
46 }
47 inline CovIBUList::BoxStatus CovIBUList::status(int i) const {</b></font>
48 	return (data-&gt;_IBU_status)[i];
49 }
50 inline bool CovIBUList::is_boundary(int i) const {
51 <a name="1"></a>	return status(i)==BOUNDARY;
52 }
53 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>inline bool CovIBUList::is_unknown(int i) const {
54 	return status(i)==UNKNOWN;
55 }
56 inline const IntervalVector&amp; CovIBUList::boundary(int i) const {
57 	return (*this)[data-&gt;_IBU_boundary[i]];
58 }
59 inline const IntervalVector&amp; CovIBUList::unknown(int i) const {
60 	return (*this)[data-&gt;_IBU_unknown[i]];
61 }
62 inline CovIBUList::BoundaryType CovIBUList::boundary_type() const {</b></font>
63 	return data-&gt;_IBU_boundary_type;
64 }
65 } 
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovSolverData.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef __IBEX_COV_SOLVER_DATA_H__
2 #define __IBEX_COV_SOLVER_DATA_H__
3 #include "ibex_CovManifold.h"
4 namespace ibex {
5 class CovSolverData : public CovManifold {
6 public:
7 	typedef enum { SOLUTION, BOUNDARY, UNKNOWN, PENDING } BoxStatus;
8 	CovSolverData(size_t n, size_t m, size_t nb_ineq=0, BoundaryType boundary_type=EQU_ONLY, const std::vector&lt;std::string&gt;&amp; var_names=std::vector&lt;std::string&gt;());
9 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	CovSolverData(const char* filename);
10 	CovSolverData(const Cov&amp; cov, bool copy=false);
11 	~CovSolverData();
12 	void save(const char* filename) const;
13 	virtual void add(const IntervalVector&amp; x);
14 	virtual void add_inner(const IntervalVector&amp; x);
15 	virtual void add_unknown(const IntervalVector&amp; x);</b></font>
16 	void add_boundary(const IntervalVector&amp; x);
17 	virtual void add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset);
18 	void add_solution(const IntervalVector&amp; existence);
19 	void add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity);
20 	virtual void add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset);
21 	virtual void add_pending(const IntervalVector&amp; x);
22 	BoxStatus status(int i) const;
23 	const IntervalVector&amp; pending(int j) const;
24 	const IntervalVector&amp; unknown(int j) const;
25 	std::vector&lt;std::string&gt;&amp; var_names();
26 	void set_solver_status(unsigned int status);
27 	unsigned int solver_status() const;
28 	void set_time(double time);
29 	double time() const;
30 	void set_nb_cells(unsigned long nb_cells);
31 	unsigned long nb_cells() const;
32 	size_t nb_pending() const;
33 	size_t nb_unknown() const;
34 	static std::string format();
35 	static const unsigned int FORMAT_VERSION;
36 protected:
37 	friend class Solver;
38 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	static std::ifstream* read(const char* filename, CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
39 	static std::ofstream* write(const char* filename, const CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
40 	static void format(std::stringstream&amp; ss, const std::string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);
41 	static void read_vars(std::ifstream&amp; f, size_t n, std::vector&lt;std::string&gt;&amp; var_names);</b></font>
42 	static void write_vars(std::ofstream&amp; f, const std::vector&lt;std::string&gt;&amp; var_names);
43 	static const unsigned int subformat_level;
44 	static const unsigned int subformat_number;
45 	struct Data {
46 		std::vector&lt;std::string&gt; _solver_var_names;
47 		unsigned int             _solver_solver_status;
48 		double                   _solver_time;
49 		unsigned long            _solver_nb_cells;
50 		std::vector&lt;BoxStatus&gt;   _solver_status;    		std::vector&lt;size_t&gt;      _solver_pending;   		std::vector&lt;size_t&gt;      _solver_unknown;   	} *data;
51 	bool own_data;
52 };
53 std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CovSolverData&amp; solver);
54 <a name="1"></a>
55 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>inline CovSolverData::BoxStatus CovSolverData::status(int i) const {
56 	return data-&gt;_solver_status[i];
57 }
58 inline const IntervalVector&amp; CovSolverData::pending(int j) const {
59 	return (*this)[data-&gt;_solver_pending[j]];
60 }
61 inline const IntervalVector&amp; CovSolverData::unknown(int j) const {
62 	return (*this)[data-&gt;_solver_unknown[j]];
63 }
64 inline std::vector&lt;std::string&gt;&amp; CovSolverData::var_names() {</b></font>
65 	return data-&gt;_solver_var_names;
66 }
67 inline void CovSolverData::set_solver_status(unsigned int status) {
68 	data-&gt;_solver_solver_status = status;
69 }
70 inline unsigned int CovSolverData::solver_status() const {
71 	return data-&gt;_solver_solver_status;
72 }
73 inline void CovSolverData::set_time(double time) {
74 	data-&gt;_solver_time = time;
75 }
76 inline double CovSolverData::time() const {
77 	return data-&gt;_solver_time;
78 }
79 inline void CovSolverData::set_nb_cells(unsigned long n) {
80 	data-&gt;_solver_nb_cells = n;
81 }
82 inline unsigned long CovSolverData::nb_cells() const {
83 <a name="3"></a>	return data-&gt;_solver_nb_cells;
84 }
85 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>inline size_t CovSolverData::nb_pending() const {
86 	return data-&gt;_solver_pending.size();
87 }
88 inline size_t CovSolverData::nb_unknown() const {
89 	return data-&gt;_solver_unknown.size();
90 }
91 inline void CovSolverData::add_boundary(const IntervalVector&amp; x) {</b></font>
92 	CovManifold::add_boundary(x);
93 }
94 inline void CovSolverData::add_solution(const IntervalVector&amp; existence) {
95 	CovManifold::add_solution(existence);
96 }
97 inline void CovSolverData::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity) {
98 	CovManifold::add_solution(existence, unicity);
99 }
100 } 
#endif </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
