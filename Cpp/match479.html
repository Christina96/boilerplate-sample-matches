<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_CovIBUList.h & ibex_CovSolverData.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_CovIBUList.h & ibex_CovSolverData.h
      </h3>
      <h1 align="center">
        40.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_CovIBUList.h (53.892216%)<TH>ibex_CovSolverData.h (32.967033%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match479-0.html#0',2,'match479-1.html#0',3)" NAME="0">(155-167)<TD><A HREF="javascript:ZweiFrames('match479-0.html#0',2,'match479-1.html#0',3)" NAME="0">(215-225)</A><TD ALIGN=center><FONT COLOR="#ff0000">33</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match479-0.html#1',2,'match479-1.html#1',3)" NAME="1">(207-219)<TD><A HREF="javascript:ZweiFrames('match479-0.html#1',2,'match479-1.html#1',3)" NAME="1">(260-272)</A><TD ALIGN=center><FONT COLOR="#d00000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match479-0.html#2',2,'match479-1.html#2',3)" NAME="2">(59-89)<TD><A HREF="javascript:ZweiFrames('match479-0.html#2',2,'match479-1.html#2',3)" NAME="2">(63-93)</A><TD ALIGN=center><FONT COLOR="#830000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match479-0.html#3',2,'match479-1.html#3',3)" NAME="3">(191-199)<TD><A HREF="javascript:ZweiFrames('match479-0.html#3',2,'match479-1.html#3',3)" NAME="3">(300-308)</A><TD ALIGN=center><FONT COLOR="#640000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovIBUList.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_CovIBUList.h
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 07, 2018
// Last update : Feb 28, 2019
//============================================================================

#ifndef __IBEX_COV_IBU_LIST_H__
#define __IBEX_COV_IBU_LIST_H__

#include &quot;ibex_CovIUList.h&quot;

namespace ibex {

/**
 * \ingroup data
 *
 * \brief Covering IBU list (with Inner, Boundary and Unknown boxes)
 *
 * A CovIBUList is a CovIUList where unknown boxes of the mother class
 * are separated into two groups:
 * - the 'boundary' boxes: boxes that are supposed to cross the boundary.
 *   The exact property of these box depends on the boundary_type field:
 *    - INNER_PT :           at least one point in the box belongs to the
 *                           set (while the box could not be proven to be
 *                           fully INNER);
 *    - INNER_AND_OUTER_PT:  at least one point in the box belongs to the
 *                           set and one point in the box does not belong
 *                           to the set (proves that it actually crosses
 *                           the boundary).
 * - the 'unknown' boxes: other boxes (no attached property).
 */
class CovIBUList : public CovIUList {
public:

	/**
	 * \brief Possible status of boxes in a IBU list.
	 */
	typedef enum { INNER, BOUNDARY, UNKNOWN } BoxStatus;

	/**
	 * \brief Type of a boundary box.
	 */
	typedef enum { INNER_PT, INNER_AND_OUTER_PT } BoundaryType;

	/**
	 * \brief Create a new, empty covering IBU list.
	 *
	 * \param n - the dimension of the covered set.
	 */
	CovIBUList(size_t n, BoundaryType boundary_type=INNER_PT);

<A NAME="2"></A>	/**
	 * \brief Load a IBU list from a COV file.
	 */
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match479-1.html#2',3,'match479-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	CovIBUList(const char* filename);

	/**
	 * \brief Conversion from a COV.
	 */
	CovIBUList(const Cov&amp; cov, bool copy=false);

	/**
	 * \brief Delete this
	 */
	~CovIBUList();

	/**
	 * \brief Save this as a COV file.
	 */
	void save(const char* filename) const;

	/**
	 * \brief Add a new 'inner' box at the end of the list.
	 */
	virtual void add_inner(const IntervalVector&amp; x);

	/**
	 * \brief Add a new 'boundary' box at the end of the list.
	 */
	virtual void add_boundary(const IntervalVector&amp; x);

	/**
	 * \brief Add a new 'unknown' box at the end of the list.
	 */
	virtual void add_unknown(const IntervalVector&amp; x);</B></FONT>

	/**
	 * \brief Add a new 'unknown' box at the end of the list.
	 */
	virtual void add(const IntervalVector&amp; x);

	/**
	 * \brief Status of the ith box.
	 */
	BoxStatus status(int i) const;

	/**
	 * \brief Whether the ith box is 'boundary'.
	 */
	bool is_boundary(int i) const;

	/**
	 * \brief Whether the ith box is 'unknown'.
	 */
	bool is_unknown(int i) const;

	/**
	 * \brief Get the ith boundary box.
	 */
	const IntervalVector&amp; boundary(int i) const;

	/**
	 * \brief Get the ith unknown box.
	 */
	const IntervalVector&amp; unknown(int i) const;

	/**
	 * \brief Number of boundary boxes
	 */
	size_t nb_boundary() const;

	/**
	 * \brief Number of unknown boxes
	 */
	size_t nb_unknown() const;

	/**
	 * \brief Display the format of a CovIBUList file.
	 */
	static std::string format();

	/**
	 * \brief COVIBUList file format version.
	 */
	static const unsigned int FORMAT_VERSION;

	/**
	 * \brief Type of boundary boxes.
	 *
	 * This type is applied globally to the COV structure
	 * (we cannot mix boundary boxes of different types in
	 * the same COV file).
	 */
	BoundaryType boundary_type() const;

protected:

<A NAME="0"></A>	/**
	 * \brief Load a IBU list from a COV file.
	 */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match479-1.html#0',3,'match479-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	static std::ifstream* read(const char* filename, CovIBUList&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	/**
	 * \brief Write a IBU list into a COV file.
	 */
	static std::ofstream* write(const char* filename, const CovIBUList&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	static void format(std::stringstream&amp; ss, const std::string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	/**
	 * \brief Subformat level.
	 */
	static const unsigned int subformat_level;</B></FONT>

	/**
	 * \brief Subformat identifying number.
	 */
	static const unsigned int subformat_number;

	struct Data {
		BoundaryType           _IBU_boundary_type;
		std::vector&lt;BoxStatus&gt; _IBU_status;       // status of the ith box
		std::vector&lt;size_t&gt;    _IBU_boundary;     // indices of 'boundary' boxes
		std::vector&lt;size_t&gt;    _IBU_unknown;      // indices of 'unknown' boxes
	} *data;

	bool own_data;
};

/**
 * \brief Stream out a IBU list.
 */
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CovIBUList&amp; cov);
<A NAME="3"></A>
/*================================== inline implementations ========================================*/

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match479-1.html#3',3,'match479-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inline size_t CovIBUList::nb_boundary() const {
	return data-&gt;_IBU_boundary.size();
}

inline size_t CovIBUList::nb_unknown() const {
	return data-&gt;_IBU_unknown.size();
}

inline CovIBUList::BoxStatus CovIBUList::status(int i) const {</B></FONT>
	return (data-&gt;_IBU_status)[i];
}

inline bool CovIBUList::is_boundary(int i) const {
<A NAME="1"></A>	return status(i)==BOUNDARY;
}

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match479-1.html#1',3,'match479-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>inline bool CovIBUList::is_unknown(int i) const {
	return status(i)==UNKNOWN;
}

inline const IntervalVector&amp; CovIBUList::boundary(int i) const {
	return (*this)[data-&gt;_IBU_boundary[i]];
}

inline const IntervalVector&amp; CovIBUList::unknown(int i) const {
	return (*this)[data-&gt;_IBU_unknown[i]];
}

inline CovIBUList::BoundaryType CovIBUList::boundary_type() const {</B></FONT>
	return data-&gt;_IBU_boundary_type;
}

} /* namespace ibex */

#endif /* __IBEX_COV_IBU_LIST_H__ */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_CovSolverData.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_CovSolverData.h
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Nov 08, 2018
// Last update : Feb 28, 2019
//============================================================================

#ifndef __IBEX_COV_SOLVER_DATA_H__
#define __IBEX_COV_SOLVER_DATA_H__

#include &quot;ibex_CovManifold.h&quot;

namespace ibex {
/**
 * \ingroup data
 *
 * \brief Solver (IbexSolve) data.
 *
 * The solver data is a 'manifold covering', i.e., a list of boxes covering
 * a manifold, potentially bounded by inequalities. This manifold is usually
 * implicitly represented in Ibex by a #System object. This object is
 * usually built by ibexsolve from a Minibex input file.
 *
 * Unknown boxes of the mother class are spread into two categories.
 * A CovManifold unknown box is either:
 *
 * - 'unknown' if the box has been processed (precision eps-min reached)
 *   but nothing could be proven.
 *
 * - 'pending' if the box has not been processed (the search has been
 *   interrupted because of a timeout/memory overflow).
 *
 * Furthermore, this class contains additional information about the last solving:
 * - variable names
 * - solver status
 * - number of cells
 * - running time.
 *
 */
class CovSolverData : public CovManifold {
public:

	/**
	 * \brief Possible status of a box in solver data.
	 */
	typedef enum { SOLUTION, BOUNDARY, UNKNOWN, PENDING } BoxStatus;

	/**
	 * \brief Create an empty solver data structure.
	 *
	 * \param n       - number of variables
	 * \param m       - number of equalities
	 * \param nb_ineq - number of inequalities (0 by default)
	 */
	CovSolverData(size_t n, size_t m, size_t nb_ineq=0, BoundaryType boundary_type=EQU_ONLY, const std::vector&lt;std::string&gt;&amp; var_names=std::vector&lt;std::string&gt;());

<A NAME="2"></A>	/**
	 * \brief Load solver data from a COV file.
	 */
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match479-0.html#2',2,'match479-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	CovSolverData(const char* filename);

	/**
	 * \brief Conversion from a COV.
	 */
	CovSolverData(const Cov&amp; cov, bool copy=false);

	/**
	 * \brief Delete this
	 */
	~CovSolverData();

	/**
	 * \brief Save this as a COV file.
	 */
	void save(const char* filename) const;

	/**
	 * \brief Add a new 'unknown' box at the end of the list.
	 */
	virtual void add(const IntervalVector&amp; x);

	/**
	 * \brief Add a new 'inner' box at the end of the list.
	 */
	virtual void add_inner(const IntervalVector&amp; x);

	/**
	 * \brief Add a new 'unknown' box at the end of the list.
	 */
	virtual void add_unknown(const IntervalVector&amp; x);</B></FONT>

	/**
	 * \brief Add a new 'boundary' box at the end of the list.
	 */
	void add_boundary(const IntervalVector&amp; x);

	/**
	 * \brief Add a new 'boundary' box at the end of the list.
	 */
	virtual void add_boundary(const IntervalVector&amp; x, const VarSet&amp; varset);

	/**
	 * \brief Add a new 'solution' box at the end of the list.
	 */
	void add_solution(const IntervalVector&amp; existence);

	/**
	 * \brief Add a new 'solution' box at the end of the list.
	 *
	 * \see CovManifold.
	 */
	void add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity);

	/**
	 * \brief Add a new 'solution' box at the end of the list.
	 *
	 * \see CovManifold.
	 */
	virtual void add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity, const VarSet&amp; varset);

	/**
	 * \brief Add a new 'pending' box at the end of the list.
	 */
	virtual void add_pending(const IntervalVector&amp; x);

	/**
	 * \brief Status of the ith box.
	 */
	BoxStatus status(int i) const;

	/**
	 * \brief The jth pending box.
	 */
	const IntervalVector&amp; pending(int j) const;

	/**
	 * \brief The jth unknown box.
	 */
	const IntervalVector&amp; unknown(int j) const;

	/**
	 * \brief Names of the variables.
	 *
	 * By default: empty vector.
	 */
	std::vector&lt;std::string&gt;&amp; var_names();

	/**
	 * \brief Set the status of the solver.
	 */
	void set_solver_status(unsigned int status);

	/*
	 * \brief Status of the last solving.
	 *
	 * Return type can be safely cast to Solver::Status.
	 *
	 * By default: SUCCESS (means &quot;unknown&quot; if time==-1)
	 */
	unsigned int solver_status() const;

	/**
	 * \brief Set the CPU running time.
	 */
	void set_time(double time);

	/*
	 * \brief CPU running time used to obtain this manifold.
	 *
	 * By default: -1 (means &quot;unknown&quot;).
	 */
	double time() const;

	/**
	 * \brief Set the number of cells.
	 */
	void set_nb_cells(unsigned long nb_cells);

	/**
	 * \brief Number of cells used to obtain this manifold.
	 *
	 * By default: 0 (means &quot;unknown&quot;).
	 */
	unsigned long nb_cells() const;

	/**
	 * \brief Number of pending boxes.
	 */
	size_t nb_pending() const;

	/**
	 * \brief Number of unknown boxes.
	 */
	size_t nb_unknown() const;

	/**
	 * \brief Display the format of a CovSolverData file.
	 */
	static std::string format();

	/**
	 * \brief COVSolverData file format version.
	 */
	static const unsigned int FORMAT_VERSION;

protected:
	friend class Solver;

<A NAME="0"></A>	/**
	 * \brief Load solver data from a COV file.
	 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match479-0.html#0',2,'match479-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	static std::ifstream* read(const char* filename, CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	/**
	 * \brief Write solver data into a COV file.
	 */
	static std::ofstream* write(const char* filename, const CovSolverData&amp; cov, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	static void format(std::stringstream&amp; ss, const std::string&amp; title, std::stack&lt;unsigned int&gt;&amp; format_id, std::stack&lt;unsigned int&gt;&amp; format_version);

	/* read the variable names */
	static void read_vars(std::ifstream&amp; f, size_t n, std::vector&lt;std::string&gt;&amp; var_names);</B></FONT>

	/* write the variable names */
	static void write_vars(std::ofstream&amp; f, const std::vector&lt;std::string&gt;&amp; var_names);

	/**
	 * \brief Subformat level.
	 */
	static const unsigned int subformat_level;

	/**
	 * \brief Subformat identifying number.
	 */
	static const unsigned int subformat_number;

	struct Data {
		std::vector&lt;std::string&gt; _solver_var_names;
		unsigned int             _solver_solver_status;
		double                   _solver_time;
		unsigned long            _solver_nb_cells;
		std::vector&lt;BoxStatus&gt;   _solver_status;    // status of the ith box
		std::vector&lt;size_t&gt;      _solver_pending;   // indices of pending boxes
		std::vector&lt;size_t&gt;      _solver_unknown;   // indices of unknown boxes
	} *data;

	bool own_data;
};

/**
 * \brief Stream out solver data.
 */
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CovSolverData&amp; solver);
<A NAME="1"></A>
/*================================== inline implementations ========================================*/

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match479-0.html#1',2,'match479-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>inline CovSolverData::BoxStatus CovSolverData::status(int i) const {
	return data-&gt;_solver_status[i];
}

inline const IntervalVector&amp; CovSolverData::pending(int j) const {
	return (*this)[data-&gt;_solver_pending[j]];
}

inline const IntervalVector&amp; CovSolverData::unknown(int j) const {
	return (*this)[data-&gt;_solver_unknown[j]];
}

inline std::vector&lt;std::string&gt;&amp; CovSolverData::var_names() {</B></FONT>
	return data-&gt;_solver_var_names;
}

inline void CovSolverData::set_solver_status(unsigned int status) {
	data-&gt;_solver_solver_status = status;
}

inline unsigned int CovSolverData::solver_status() const {
	return data-&gt;_solver_solver_status;
}

inline void CovSolverData::set_time(double time) {
	data-&gt;_solver_time = time;
}

inline double CovSolverData::time() const {
	return data-&gt;_solver_time;
}

inline void CovSolverData::set_nb_cells(unsigned long n) {
	data-&gt;_solver_nb_cells = n;
}

inline unsigned long CovSolverData::nb_cells() const {
<A NAME="3"></A>	return data-&gt;_solver_nb_cells;
}

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match479-0.html#3',2,'match479-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>inline size_t CovSolverData::nb_pending() const {
	return data-&gt;_solver_pending.size();
}

inline size_t CovSolverData::nb_unknown() const {
	return data-&gt;_solver_unknown.size();
}

inline void CovSolverData::add_boundary(const IntervalVector&amp; x) {</B></FONT>
	CovManifold::add_boundary(x);
}

inline void CovSolverData::add_solution(const IntervalVector&amp; existence) {
	CovManifold::add_solution(existence);
}

inline void CovSolverData::add_solution(const IntervalVector&amp; existence, const IntervalVector&amp; unicity) {
	CovManifold::add_solution(existence, unicity);
}

} /* namespace ibex */

#endif /* __IBEX_COV_SOLVER_DATA_H__ */
</PRE>
</div>
  </div>
</body>
</html>
