<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_ExprCopy.cpp & ibex_ExprSimplify2.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_ExprCopy.cpp & ibex_ExprSimplify2.cpp
      </h3>
      <h1 align="center">
        13.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_ExprCopy.cpp (23.243244%)<TH>ibex_ExprSimplify2.cpp (9.481808%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#0',2,'match898-1.html#0',3)" NAME="0">(97-105)<TD><A HREF="javascript:ZweiFrames('match898-0.html#0',2,'match898-1.html#0',3)" NAME="0">(403-411)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#1',2,'match898-1.html#1',3)" NAME="1">(67-77)<TD><A HREF="javascript:ZweiFrames('match898-0.html#1',2,'match898-1.html#1',3)" NAME="1">(141-173)</A><TD ALIGN=center><FONT COLOR="#bf0000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#2',2,'match898-1.html#2',3)" NAME="2">(114-116)<TD><A HREF="javascript:ZweiFrames('match898-0.html#2',2,'match898-1.html#2',3)" NAME="2">(251-260)</A><TD ALIGN=center><FONT COLOR="#b20000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#3',2,'match898-1.html#3',3)" NAME="3">(121-124)<TD><A HREF="javascript:ZweiFrames('match898-0.html#3',2,'match898-1.html#3',3)" NAME="3">(482-484)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#4',2,'match898-1.html#4',3)" NAME="4">(109-113)<TD><A HREF="javascript:ZweiFrames('match898-0.html#4',2,'match898-1.html#4',3)" NAME="4">(529-532)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match898-0.html#5',2,'match898-1.html#5',3)" NAME="5">(105-108)<TD><A HREF="javascript:ZweiFrames('match898-0.html#5',2,'match898-1.html#5',3)" NAME="5">(400-403)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprCopy.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_ExprCopy.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Apr 9, 2012
// Last Update : Apr 16, 2019
//============================================================================

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;cassert&gt;
#include &lt;sstream&gt;

#include &quot;ibex_ExprCopy.h&quot;
#include &quot;ibex_Function.h&quot;
#include &quot;ibex_Domain.h&quot;

using namespace std;

namespace ibex {

void varcopy(const Array&lt;const ExprSymbol&gt;&amp; src, Array&lt;const ExprSymbol&gt;&amp; dest) {
	assert(src.size()&lt;=dest.size());
	for (int i=0; i&lt;src.size(); i++) {
		dest.set_ref(i,ExprSymbol::new_(src[i].name, src[i].dim));
	}
}

bool varequals(const Array&lt;const ExprSymbol&gt;&amp; arg1, Array&lt;const ExprSymbol&gt;&amp; arg2) {
	if (arg1.size()!=arg2.size()) return false;
	for (int j=0; j&lt;arg1.size(); j++)
		if (arg1[j].dim!=arg2[j].dim) return false;
	return true;
}

const ExprNode&amp; var_component(const Array&lt;const ExprSymbol&gt;&amp; args, int i) {

	int n=0; // count the symbols
	int j=0; // count the number of components up to symbol n;
	while (n&lt;args.size() &amp;&amp; j&lt;=i) {
		const ExprNode&amp; x=args[n];
		if (j+x.dim.size() &gt; i) { // we have found the right symbol
			switch (x.dim.type()) {
			case Dim::SCALAR :      return x;
			case Dim::ROW_VECTOR:
			case Dim::COL_VECTOR:   return x[i-j];
			case Dim::MATRIX:       return x[(i-j) / x.dim.nb_cols()][(i-j) % x.dim.nb_cols()];
			}
		} else {
			j+=x.dim.size();
			n++;
		}
	}
	ibex_error(&quot;var_component: index exceeds size.&quot;);
}

const ExprNode&amp; ExprCopy::copy(const Array&lt;const ExprSymbol&gt;&amp; old_x, const Array&lt;const ExprNode&gt;&amp; new_x, const ExprNode&amp; y, bool shared) {

	if (!shared) cache.clean();

<A NAME="1"></A>	for (int i=0; i&lt;std::min(new_x.size(), old_x.size()); i++) {
		if (shared &amp;&amp; cache.found(old_x[i])) continue;
		cache.insert(old_x[i],&amp;new_x[i]);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match898-1.html#1',3,'match898-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}

	return *visit(y);
}

const ExprNode* ExprCopy::visit(const ExprNode&amp; e) {
	// ok, apply default (superclass) implementation
	return ExprVisitor&lt;const ExprNode*&gt;::visit(e);
}

const ExprNode* ExprCopy::visit(const ExprIndex&amp; i) {</B></FONT>
	return &amp;ExprIndex::new_(*visit(i.expr),i.index);
}

const ExprNode* ExprCopy::visit(const ExprSymbol&amp; x) {
	stringstream s;
	s &lt;&lt; &quot;[ExprCopy] no destination node for symbol&quot; &lt;&lt; x;
	ibex_error(s.str().c_str());
	return NULL;
}

const ExprNode* ExprCopy::visit(const ExprConstant&amp; c) {
	return &amp;c.copy();
}

const ExprNode* ExprCopy::nary(const ExprNAryOp&amp; e, std::function&lt;const ExprNAryOp&amp;(const Array&lt;const ExprNode&gt;&amp;)&gt; f) {
	Array&lt;const ExprNode&gt; args2(e.nb_args);
<A NAME="0"></A>	for (int i=0; i&lt;e.nb_args; i++) {
		args2.set_ref(i,*visit(e.arg(i)));
	}
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match898-1.html#0',3,'match898-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return &amp;f(args2);
}

const ExprNode* ExprCopy::visit(const ExprVector&amp; e) {
	return nary(e, [&amp;e](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprVector&amp; { return ExprVector::new_(args,e.orient); });
<A NAME="5"></A>}

const ExprNode* ExprCopy::visit(const ExprApply&amp; e) {
	return nary(e, [&amp;e](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprApply&amp; { return ExprApply::new_(*e.f,args); });</B></FONT><FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match898-1.html#5',3,'match898-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>
<A NAME="4"></A>}

const ExprNode* ExprCopy::visit(const ExprChi&amp; e) {</B></FONT>
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match898-1.html#4',3,'match898-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return nary(e, [](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprChi&amp; { return ExprChi::new_(args); });
}
<A NAME="2"></A>
const ExprNode* ExprCopy::visit(const ExprGenericBinaryOp&amp; e) {
	                                       	   	   	  return &amp;ExprGenericBinaryOp::new_(e.name,*visit(e.left),*visit(e.right)); }</B></FONT>
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match898-1.html#2',3,'match898-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>const ExprNode* ExprCopy::visit(const ExprAdd&amp; e)   { return &amp;(*visit(e.left) + *visit(e.right));; }
const ExprNode* ExprCopy::visit(const ExprMul&amp; e)   { return &amp;(*visit(e.left) * *visit(e.right)); }
const ExprNode* ExprCopy::visit(const ExprSub&amp; e)   { return &amp;(*visit(e.left) - *visit(e.right)); }</B></FONT>
const ExprNode* ExprCopy::visit(const ExprDiv&amp; e)   { return &amp;(*visit(e.left) / *visit(e.right)); }
<A NAME="3"></A>const ExprNode* ExprCopy::visit(const ExprMax&amp; e)   { return &amp;max(*visit(e.left),*visit(e.right)); }
const ExprNode* ExprCopy::visit(const ExprMin&amp; e)   { return &amp;min(*visit(e.left),*visit(e.right)); }
const ExprNode* ExprCopy::visit(const ExprAtan2&amp; e) { return &amp;atan2(*visit(e.left),*visit(e.right)); }
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match898-1.html#3',3,'match898-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>const ExprNode* ExprCopy::visit(const ExprPower&amp; e) { return &amp;pow(*visit(e.expr),e.expon); }
const ExprNode* ExprCopy::visit(const ExprGenericUnaryOp&amp; e)
													{ return &amp;ExprGenericUnaryOp::new_(e.name,*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprMinus&amp; e) { return &amp;(-*visit(e.expr)); }</B></FONT>
const ExprNode* ExprCopy::visit(const ExprTrans&amp; e) { return &amp;transpose(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSign&amp; e)  { return &amp;sign(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAbs&amp; e)   { return &amp;abs(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSqr&amp; e)   { return &amp;sqr(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSqrt&amp; e)  { return &amp;sqrt(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprExp&amp; e)   { return &amp;exp (*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprLog&amp; e)   { return &amp;log (*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprCos&amp; e)   { return &amp;cos (*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSin&amp; e)   { return &amp;sin (*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprTan&amp; e)   { return &amp;tan (*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprCosh&amp; e)  { return &amp;cosh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSinh&amp; e)  { return &amp;sinh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprTanh&amp; e)  { return &amp;tanh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAcos&amp; e)  { return &amp;acos(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAsin&amp; e)  { return &amp;asin(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAtan&amp; e)  { return &amp;atan(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAcosh&amp; e) { return &amp;acosh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAsinh&amp; e) { return &amp;asinh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprAtanh&amp; e) { return &amp;atanh(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprFloor&amp; e) { return &amp;floor(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprCeil&amp; e)  { return &amp;ceil(*visit(e.expr)); }
const ExprNode* ExprCopy::visit(const ExprSaw&amp; e)   { return &amp;saw (*visit(e.expr)); }

} // end ibex namespace





</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprSimplify2.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_ExprSimplify2.cpp
// Author      : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Mar 27, 2020
// Last update : May 15, 2020
//============================================================================

#include &quot;ibex_ExprSimplify2.h&quot;
#include &quot;ibex_ExprSubNodes.h&quot;
#include &quot;ibex_Expr.h&quot;
#include &quot;ibex_Map.h&quot;

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include &lt;algorithm&gt;


using namespace std;

namespace ibex {

namespace {

bool is_cst(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprConstant*&gt;(&amp;e)!=NULL;
}

bool is_mutable(const ExprNode&amp; e) {
	return ((const ExprConstant&amp;) e).is_mutable();
}

bool is_index(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprIndex*&gt;(&amp;e)!=NULL;
}

bool is_minus(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprMinus*&gt;(&amp;e)!=NULL;
}

bool is_trans(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprTrans*&gt;(&amp;e)!=NULL;
}

bool is_add(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprAdd*&gt;(&amp;e)!=NULL;
}

bool is_sub(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprSub*&gt;(&amp;e)!=NULL;
}

bool is_mul(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprMul*&gt;(&amp;e)!=NULL;
}

//bool is_div(const ExprNode&amp; e) {
//	return dynamic_cast&lt;const ExprDiv*&gt;(&amp;e)!=NULL;
//}

bool is_vec(const ExprNode&amp; e) {
	return dynamic_cast&lt;const ExprVector*&gt;(&amp;e)!=NULL;
}

const Domain&amp; to_cst(const ExprNode&amp; e) {
	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
	assert(c);
	return c-&gt;get();
}

const ExprNode&amp; left(const ExprNode&amp; e) {
	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
	assert(b);
	return b-&gt;left;
}

const ExprNode&amp; right(const ExprNode&amp; e) {
	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
	assert(b);
	return b-&gt;right;
}

const ExprNode&amp; expr(const ExprNode&amp; e) {
	const ExprUnaryOp* u=dynamic_cast&lt;const ExprUnaryOp*&gt;(&amp;e);
	assert(u);
	return u-&gt;expr;
}

} // end anonymous namespace

ExprSimplify2::ExprSimplify2(bool develop) : _2polynom(*this, develop) {

}

const ExprNode&amp; ExprSimplify2::rec(const ExprNode&amp; e) {
	record.push_back(&amp;e);
	return e;
}

const ExprNode&amp; ExprSimplify2::simplify(const ExprNode&amp; e) {
	const ExprNode&amp; _result = *visit(e);
	//cout  &lt;&lt; &quot;result=&quot; &lt;&lt; _result &lt;&lt; endl;
	const ExprNode&amp; result = _2polynom.get(_result)-&gt;to_expr(&amp;record);

	// If a node does not appear in the final expression
	// AND is not a node of the original expression, it has to be freed.

	ExprSubNodes old_nodes(e);
	ExprSubNodes new_nodes(result);

	/* All the new nodes created in the simplification process
	 * and that does not appear in the final expression have just
	 * to be deleted
	 */
	for (vector&lt;const ExprNode*&gt;::iterator it=record.begin(); it!=record.end(); ++it) {
		if (!new_nodes.found(**it)) {
			delete *it;
		}
	}
	record.clear(); // important for next call to simplify()

	vector&lt;const ExprNode*&gt; expr_symbols;

	/** All the old nodes that are neither symbols, locked
	 * or in the final expression also have to be deleted
	 */
	for (int i=0; i&lt;old_nodes.size(); i++) {
		if (!dynamic_cast&lt;const ExprSymbol*&gt;(&amp;old_nodes[i]) &amp;&amp;
				!new_nodes.found(old_nodes[i]) &amp;&amp;
				!lock.found(old_nodes[i])) {
			delete &amp;old_nodes[i];
		}
		// the list of fathers must also be recalculated
		// for all these nodes !!
		// and this is not as simple as the next commented loop
<A NAME="1"></A>		// as  the old nodes may have fathers &quot;alive&quot;
		// that do not belong to the new nodes.
		//			 ((ExprNode&amp;) old_nodes[i]).fathers.clear();
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#1',2,'match898-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}


	//	 for (int i=0; i&lt;new_nodes.size(); i++) {
	//		 if (dynamic_cast&lt;const ExprNAryOp*&gt;(&amp;new_nodes[i])) {
	//			 const ExprNAryOp&amp; nary=(const ExprNAryOp&amp;) new_nodes[i];
	//			 for (int j=0; j&lt;nary.nb_args; j++)
	//				 ((ExprNode&amp;) nary.args[j]).fathers.add(nary);
	//		 } else if (dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;new_nodes[i])) {
	//			 const ExprBinaryOp&amp; b=(const ExprBinaryOp&amp;) new_nodes[i];
	//			 ((ExprNode&amp;) b.left).fathers.add(b);
	//			 ((ExprNode&amp;) b.right).fathers.add(b);
	//		 } else if (dynamic_cast&lt;const ExprUnaryOp*&gt;(&amp;new_nodes[i])) {
	//			 const ExprUnaryOp&amp; u=(const ExprUnaryOp&amp;) new_nodes[i];
	//			 ((ExprNode&amp;) u.expr).fathers.add(u);
	//		 } else if (dynamic_cast&lt;const ExprIndex*&gt;(&amp;new_nodes[i])) {
	//			 const ExprIndex&amp; index=(const ExprIndex&amp;) new_nodes[i];
	//			 ((ExprNode&amp;) index.expr).fathers.add(index);
	//		 }
	//	 }

	//important: clear the cache, some nodes have been deleted!
	cache.clean();
	_2polynom.cleanup();

	return result;
}

const ExprNode* ExprSimplify2::visit(const ExprNode&amp; e) {
	return ExprVisitor&lt;const ExprNode*&gt;::visit(e);
}

const ExprNode* ExprSimplify2::visit(const ExprIndex&amp; e) {</B></FONT>

	const ExprNode* expr2 = visit(e.expr);
	assert(expr2-&gt;dim==e.expr.dim);

	if (is_cst(*expr2)) {
		if (is_mutable(*expr2))
			return &amp;rec(ExprConstant::new_mutable(to_cst(*expr2)[e.index]));
		else
			return &amp;rec(ExprConstant::new_(to_cst(*expr2)[e.index]));
	} else if (e.index.all()) {
		return &amp;*expr2;
	} else if (is_index(*expr2)) {
		const ExprIndex* id2= (const ExprIndex*) expr2;
		return &amp;rec(id2-&gt;expr[id2-&gt;index[e.index]]);
	} else if (is_minus(*expr2)) {
		return visit(rec(-rec(expr(*expr2)[e.index])));
	} else if (is_trans(*expr2)) {
		return visit(rec(expr(*expr2)[e.index.transpose()]));
	} else if (is_add(*expr2)) {
		return visit(rec(rec(left(*expr2)[e.index]) + rec(right(*expr2)[e.index])));
	} else if (is_sub(*expr2)) {
		return visit(rec(rec(left(*expr2)[e.index]) - rec(right(*expr2)[e.index])));
	} else if (is_mul(*expr2)) {
		if (left(*expr2).dim.is_scalar())
			if (is_cst(*expr2) &amp;&amp; !is_mutable(*expr2) &amp;&amp; to_cst(*expr2).is_zero())
				return &amp;rec(ExprConstant::new_matrix(Matrix::zeros(e.dim.nb_rows(),e.dim.nb_cols())));
			else
				return visit(rec(left(*expr2) * rec(right(*expr2)[e.index])));
		else
			return visit(rec(
				rec(left(*expr2)[e.index.rows(left(*expr2).dim,e.index.first_row(),e.index.last_row())]) *
				rec(right(*expr2)[e.index.cols(right(*expr2).dim,e.index.first_col(),e.index.last_col())])));
	} else if (is_vec(*expr2)) {
		vector&lt;const ExprNode*&gt; res;
		const DoubleIndex&amp; idx=e.index;
		const ExprVector&amp; v=(const ExprVector&amp;) *expr2;
		unsigned int i=0;
		if (v.row_vector()) {
			int c=0;
			while (c&lt;=idx.last_col()) {
				int n=v.arg(i).dim.nb_cols();
				int first_col=idx.first_col()-c;
				if (first_col&lt;n) { // can be negative
					int last_col=idx.last_col()-c;
					DoubleIndex e_idx=DoubleIndex(v.arg(i).dim,
							idx.first_row(), idx.last_row(),
							first_col&lt;0? 0 : first_col, last_col&gt;=n? n-1 : last_col);
					res.push_back(&amp; rec(v.arg(i)[e_idx]));
				}
				c+=n;
				assert(((int) i)&lt;v.nb_args);
				i++;
			}
		} else {
			int r=0;
			while (r&lt;=idx.last_row()) {
				int n=v.arg(i).dim.nb_rows();
				int first_row=idx.first_row()-r;
				if (first_row&lt;n) { // can be negative
					int last_row=idx.last_row()-r;
					DoubleIndex e_idx=DoubleIndex(v.arg(i).dim,
							first_row&lt;0? 0 : first_row, last_row&gt;=n? n-1 : last_row,
									idx.first_col(), idx.last_col());
					res.push_back(&amp; rec(v.arg(i)[e_idx]));
				}
				r+=n;
				assert(((int) i)&lt;v.nb_args);
				i++;
			}
		}
		if (res.size()==1)
			return visit(*res.back());
		else
			return visit(rec(ExprVector::new_(res,v.orient)));
<A NAME="2"></A>	} else if (expr2==&amp;e.expr) {
		return &amp;e;
	} else
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#2',2,'match898-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		return &amp;rec((*expr2)[e.index]);
}

const ExprNode* ExprSimplify2::visit(const ExprSymbol&amp; e) {
	return &amp;e;
}

const ExprNode* ExprSimplify2::visit(const ExprConstant&amp; e) {
	return &amp;e;
}</B></FONT>


// Note: I don't understand why I have to do these casts.
// The compiler should directly convert arguments to
//      std::function&lt;Domain(const Domain&amp;)&gt;
// or
//      std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt;
typedef Domain (*_domain_una_op)(const Domain&amp;);
typedef Domain (*_domain_bin_op)(const Domain&amp;, const Domain&amp;);


const ExprNode* ExprSimplify2::unary(const ExprUnaryOp&amp; e,
		std::function&lt;Domain(const Domain&amp;)&gt; fcst,
		std::function&lt;const ExprNode&amp;(const ExprNode&amp;)&gt; fctr) {

	const ExprNode* expr2=visit(e.expr);
	assert(expr2-&gt;dim==e.expr.dim);

	if (is_cst(*expr2)) {
		if (is_mutable(*expr2))
			return &amp;rec(fctr(*expr2));
		else
			return &amp;rec(ExprConstant::new_(fcst(to_cst(*expr2))));
	} else if (!e.dim.is_scalar()) { // for MINUS --&gt; distribute over components
		assert(dynamic_cast&lt;const ExprMinus*&gt;(&amp;e));
		bool row = e.dim.is_matrix() || e.dim.type()==Dim::ROW_VECTOR;
		// note: if e.expr is a vector, we don't necessarily iterate over
		// arguments of v, because dimensions may be non homogeneous (we let
		// the simplification of ExprIndex do the job..)
		Array&lt;const ExprNode&gt; args(e.dim.vec_size());
		for (int i=0; i&lt;e.dim.vec_size(); i++)
			args.set_ref(i, rec(fctr(rec((*expr2)[i]))));
		return visit(rec(ExprVector::new_(args, row ? ExprVector::ROW : ExprVector::COL)));
	} else if (expr2==&amp;e.expr) {
		return &amp;e;
	} else
		return &amp;rec(fctr(*expr2));
}

const ExprNode* ExprSimplify2::binary(const ExprBinaryOp&amp; e,
		std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt; fcst,
		std::function&lt;const ExprBinaryOp&amp;(const ExprNode&amp;, const ExprNode&amp;)&gt; fctr) {

	const ExprNode* l2=visit(e.left);
	assert(l2-&gt;dim==e.left.dim);
	const ExprNode* r2=visit(e.right);
	assert(r2-&gt;dim==e.right.dim);

	bool all_same = (l2==&amp;e.left &amp;&amp; r2==&amp;e.right);

	if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; is_cst(*r2) &amp;&amp; !is_mutable(*r2)) {
		return &amp;rec(ExprConstant::new_(fcst(to_cst(*l2), to_cst(*r2))));
	} else if ((!l2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*l2) || is_cst(*l2)))
			|| (!r2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*r2) || is_cst(*r2)))) { // for ADD and SUB --&gt; distribute addition / vector

		Array&lt;const ExprNode&gt; rows(e.dim.nb_rows());
		Array&lt;const ExprNode&gt; col (e.dim.nb_cols());

		for (int i=0; i&lt;e.dim.nb_rows(); i++) {
			col.clear();
			for (int j=0; j&lt;e.dim.nb_cols(); j++) {
				col.set_ref(j,rec(fctr(
						rec((*l2)[DoubleIndex::one_elt(e.dim,i,j)]),
						rec((*r2)[DoubleIndex::one_elt(e.dim,i,j)]))));
			}
			if (e.dim.nb_cols()&gt;1)
				rows.set_ref(i, rec(ExprVector::new_(col,ExprVector::ROW)));
			else
				rows.set_ref(i, col[0]);
		}

		if (e.dim.nb_rows()&gt;1)
			return visit(rec(ExprVector::new_(rows,ExprVector::COL)));
		else
			return visit(rows[0]);
	} else if (all_same) {
		return &amp;e;
	} else
		return &amp;rec(fctr(*l2,*r2));
}

const ExprNode* ExprSimplify2::nary(const ExprNAryOp&amp; e,
		std::function&lt;Domain(Array&lt;const Domain&gt;&amp;)&gt; fcst,
		std::function&lt;const ExprNAryOp&amp;(Array&lt;const ExprNode&gt;&amp;)&gt; f) {

	bool all_cst = true;
	bool all_same = true;
	Array&lt;const ExprNode&gt; args2(e.nb_args);
	for (int i=0; i&lt;e.nb_args; i++) {
		args2.set_ref(i,*visit(e.arg(i)));
		all_cst &amp;= ( is_cst(args2[i]) &amp;&amp; !is_mutable(args2[i]) );
		all_same &amp;= (&amp;args2[i]==&amp;e.arg(i));
	}

	if (all_cst) {
		Array&lt;const Domain&gt; arg_cst(e.nb_args);
		for (int i=0; i&lt;e.nb_args; i++) {
			arg_cst.set_ref(i, to_cst(args2[i]));
		}
		return &amp;rec(ExprConstant::new_(fcst(arg_cst)));
	} else if (all_same) {
		return &amp;e;
	} else {
		return &amp;rec(f(args2));
	}
}

const ExprNode* ExprSimplify2::visit(const ExprVector&amp; e) {
	// this block copy-pasted from nary(...)
	// &lt;&lt;--------------
	bool all_cst = true;
	bool all_same = true;
	Array&lt;const ExprNode&gt; args2(e.nb_args);
	for (int i=0; i&lt;e.nb_args; i++) {
		args2.set_ref(i,*visit(e.arg(i)));
		all_cst &amp;= ( is_cst(args2[i]) &amp;&amp; !is_mutable(args2[i]) );
		all_same &amp;= (&amp;args2[i]==&amp;e.arg(i));
	}

	if (all_cst) {
		Array&lt;const Domain&gt; arg_cst(e.nb_args);
		for (int i=0; i&lt;e.nb_args; i++) {
			arg_cst.set_ref(i, to_cst(args2[i]));
		}
		return &amp;rec(ExprConstant::new_(Domain(arg_cst, e.row_vector())));
	}
	// --------------&gt;&gt;
	else if (args2.size()==1)
		return &amp;args2[0]; // no rec here!
	else if (all_same) {
		return &amp;e;
	} else {
		return &amp;rec(ExprVector::new_(args2, e.orient));
	}
}

<A NAME="5"></A>const ExprNode* ExprSimplify2::visit(const ExprChi&amp; e) {
	return nary(e,
			[](Array&lt;const Domain&gt;&amp; args) { return chi(args[0],args[1],args[2]); },
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#5',2,'match898-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B><A NAME="0"></A>			[](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprChi&amp; { return ExprChi::new_(args); });
}

</B></FONT><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#0',2,'match898-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>const ExprNode* ExprSimplify2::visit(const ExprApply&amp; e) { return &amp;e; /* not implemented */ }

const ExprNode* ExprSimplify2::visit(const ExprGenericBinaryOp&amp; e) {
	return binary( e,
			e.eval,
			[&amp;e](const ExprNode&amp; x,const ExprNode&amp; y)-&gt;const ExprBinaryOp&amp; { return ExprGenericBinaryOp::new_(e.name,x,y);});
}

const ExprNode* ExprSimplify2::visit(const ExprAdd&amp; e)   { return binary(e, (_domain_bin_op) operator+, ExprAdd::new_); }</B></FONT>
const ExprNode* ExprSimplify2::visit(const ExprSub&amp; e)   { return binary(e, (_domain_bin_op) operator-, ExprSub::new_); }

const ExprNode* ExprSimplify2::visit(const ExprMul&amp; e)   {
	const ExprNode* l2=visit(e.left);
	assert(l2-&gt;dim==e.left.dim);
	const ExprNode* r2=visit(e.right);
	assert(r2-&gt;dim==e.right.dim);

	bool all_same = (l2==&amp;e.left &amp;&amp; r2==&amp;e.right);

	if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; is_cst(*r2) &amp;&amp; !is_mutable(*r2)) {
		return &amp;rec(ExprConstant::new_(to_cst(*l2) * to_cst(*r2)));
	} else if ((!l2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*l2) || is_cst(*l2)))
			|| (!r2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*r2) || is_cst(*r2)))) { // distribute multiplication / vector

		Array&lt;const ExprNode&gt; cols(r2-&gt;dim.nb_cols());
		if (l2-&gt;dim.is_scalar()) { // scalar*vector/matrix case
			// note: a row ExprVector of column is more efficient than a column ExprVector of rows.
			if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; to_cst(*l2).is_zero())
				return &amp;rec(ExprConstant::new_matrix(Matrix::zeros(r2-&gt;dim.nb_rows(),r2-&gt;dim.nb_cols())));

			Array&lt;const ExprNode&gt; col (r2-&gt;dim.nb_rows());
			for (int j=0; j&lt;r2-&gt;dim.nb_cols(); j++) {
				col.clear();
				for (int i=0; i&lt;r2-&gt;dim.nb_rows(); i++) {
					col.set_ref(i, rec((*l2)*rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,i,j)])));
				}
				if (r2-&gt;dim.nb_rows()&gt;1)
					cols.set_ref(j, rec(ExprVector::new_(col,ExprVector::COL)));
				else
					cols.set_ref(j, col[0]);
			}
		} else {
			Array&lt;const ExprNode&gt; col (l2-&gt;dim.nb_rows());
			for (int j=0; j&lt;r2-&gt;dim.nb_cols(); j++) {
				col.clear();
				for (int i=0; i&lt;l2-&gt;dim.nb_rows(); i++) {
					const ExprNode* e=NULL;

					for (int k=0; k&lt;l2-&gt;dim.nb_cols(); k++) {
						if (e)
							e = &amp; rec(*e +
									rec(rec((*l2)[DoubleIndex::one_elt(l2-&gt;dim,i,k)])*
											rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,k,j)]))
							);
						else
							e = &amp; rec(
									rec((*l2)[DoubleIndex::one_elt(l2-&gt;dim,i,k)])*
									rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,k,j)])
							);
					}
					col.set_ref(i,*e);
				}
				if (l2-&gt;dim.nb_rows()&gt;1)
					cols.set_ref(j, rec(ExprVector::new_(col,ExprVector::COL)));
				else
					cols.set_ref(j, col[0]);
			}
		}
		if (r2-&gt;dim.nb_cols()&gt;1) {
			return visit(rec(ExprVector::new_(cols,ExprVector::ROW)));
		}
		else
			return visit(cols[0]);
	} else if (all_same) {
		return &amp;e;
	} else
<A NAME="3"></A>		return &amp;rec((*l2)*(*r2));
}

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#3',2,'match898-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>const ExprNode* ExprSimplify2::visit(const ExprDiv&amp; e)   { return binary(e, (_domain_bin_op) operator/, ExprDiv::new_); }
const ExprNode* ExprSimplify2::visit(const ExprMax&amp; e)   { return binary(e, (_domain_bin_op) max,       ExprMax::new_); }
const ExprNode* ExprSimplify2::visit(const ExprMin&amp; e)   { return binary(e, (_domain_bin_op) min,       ExprMin::new_); }</B></FONT>
const ExprNode* ExprSimplify2::visit(const ExprAtan2&amp; e) { return binary(e, (_domain_bin_op) atan2,     ExprAtan2::new_); }



const ExprNode* ExprSimplify2::visit(const ExprPower&amp; e) {
	return unary(e,
			[&amp;e](const Domain&amp; x)-&gt;Domain { return pow(x,e.expon); },
			[&amp;e](const ExprNode&amp; expr)-&gt;const ExprNode&amp; { return ibex::pow(expr,e.expon); });
}

const ExprNode* ExprSimplify2::visit(const ExprTrans&amp; e) {

	const ExprNode* expr2 = visit(e.expr);

	if (is_cst(*expr2) &amp;&amp; !is_mutable(*expr2)) {
		return &amp;rec(ExprConstant::new_(transpose(to_cst(*expr2))));
	} else if (is_trans(*expr2)) {
		return &amp;expr(*expr2); // no need to visit again
	} else if (is_index(*expr2)) {
		const ExprIndex&amp; i=(const ExprIndex&amp;) *expr2;
		return visit(rec(i.expr[i.index.transpose()]));
	} else if (is_minus(*expr2)) {
		return visit(rec(-rec(transpose(expr(*expr2)))));
	} else if (is_add(*expr2)) {
		return visit(rec(rec(transpose(left(*expr2))) + rec(transpose(right(*expr2)))));
	} else if (is_sub(*expr2)) {
		return visit(rec(rec(transpose(left(*expr2))) - rec(transpose(right(*expr2)))));
	} else if (is_mul(*expr2)) {
		return visit(rec(rec(transpose(right(*expr2))) * rec(transpose(left(*expr2)))));
	} else if (is_vec(*expr2)) {
		const ExprVector&amp; ev=(const ExprVector&amp;) *expr2;
		// no need to visit again
		return &amp;rec(ExprVector::new_(ev.args, ev.orient==ExprVector::ROW? ExprVector::COL : ExprVector::ROW));
	} else if (e.dim.is_scalar())
		return expr2;
	else if (expr2==&amp;e.expr) {
		return &amp;e;
	} else {
		return &amp;rec(transpose(*expr2));
	}
}
<A NAME="4"></A>
const ExprNode* ExprSimplify2::visit(const ExprGenericUnaryOp&amp; e) {
	return unary(e, e.eval,
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match898-0.html#4',2,'match898-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			[&amp;e](const ExprNode&amp; x)-&gt;const ExprUnaryOp&amp; { return ExprGenericUnaryOp::new_(e.name,x);});
}

const ExprNode* ExprSimplify2::visit(const ExprMinus&amp; e) { return unary(e, (_domain_una_op) operator-, ExprMinus::new_); }</B></FONT>
const ExprNode* ExprSimplify2::visit(const ExprSqr&amp; e)   { return unary(e, (_domain_una_op) sqr,  ExprSqr::new_);  }
const ExprNode* ExprSimplify2::visit(const ExprSign&amp; e)  { return unary(e, (_domain_una_op) sign, ExprSign::new_);  }
const ExprNode* ExprSimplify2::visit(const ExprAbs&amp; e)   { return unary(e, (_domain_una_op) abs,  ExprAbs::new_);  }
const ExprNode* ExprSimplify2::visit(const ExprSqrt&amp; e)  { return unary(e, (_domain_una_op) sqrt, ExprSqrt::new_); }
const ExprNode* ExprSimplify2::visit(const ExprExp&amp; e)   { return unary(e, (_domain_una_op) exp,  ExprExp::new_); }
const ExprNode* ExprSimplify2::visit(const ExprLog&amp; e)   { return unary(e, (_domain_una_op) log,  ExprLog::new_); }
const ExprNode* ExprSimplify2::visit(const ExprCos&amp; e)   { return unary(e, (_domain_una_op) cos,  ExprCos::new_); }
const ExprNode* ExprSimplify2::visit(const ExprSin&amp; e)   { return unary(e, (_domain_una_op) sin,  ExprSin::new_); }
const ExprNode* ExprSimplify2::visit(const ExprTan&amp; e)   { return unary(e, (_domain_una_op) tan,  ExprTan::new_); }
const ExprNode* ExprSimplify2::visit(const ExprCosh&amp; e)  { return unary(e, (_domain_una_op) cosh, ExprCosh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprSinh&amp; e)  { return unary(e, (_domain_una_op) sinh, ExprSinh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprTanh&amp; e)  { return unary(e, (_domain_una_op) tanh, ExprTanh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAcos&amp; e)  { return unary(e, (_domain_una_op) acos, ExprAcos::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAsin&amp; e)  { return unary(e, (_domain_una_op) asin, ExprAsin::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAtan&amp; e)  { return unary(e, (_domain_una_op) atan, ExprAtan::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAcosh&amp; e) { return unary(e, (_domain_una_op) acosh,ExprAcosh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAsinh&amp; e) { return unary(e, (_domain_una_op) asinh,ExprAsinh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprAtanh&amp; e) { return unary(e, (_domain_una_op) atanh,ExprAtanh::new_); }
const ExprNode* ExprSimplify2::visit(const ExprFloor&amp; e) { return unary(e, (_domain_una_op) floor,ExprFloor::new_); }
const ExprNode* ExprSimplify2::visit(const ExprCeil&amp; e)  { return unary(e, (_domain_una_op) ceil, ExprCeil::new_); }
const ExprNode* ExprSimplify2::visit(const ExprSaw&amp; e)   { return unary(e, (_domain_una_op) saw,  ExprSaw::new_);  }

} // namespace ibex
</PRE>
</div>
  </div>
</body>
</html>
