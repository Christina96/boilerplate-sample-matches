<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ibex_ExprCopy.cpp &amp; ibex_ExprSimplify2.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ibex_ExprCopy.cpp &amp; ibex_ExprSimplify2.cpp
      </h3>
<h1 align="center">
        13.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ibex_ExprCopy.cpp (23.243244%)<th>ibex_ExprSimplify2.cpp (9.481808%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-105)<td><a href="#" name="0">(403-411)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(67-77)<td><a href="#" name="1">(141-173)</a><td align="center"><font color="#bf0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(114-116)<td><a href="#" name="2">(251-260)</a><td align="center"><font color="#b20000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(121-124)<td><a href="#" name="3">(482-484)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(109-113)<td><a href="#" name="4">(529-532)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(105-108)<td><a href="#" name="5">(400-403)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprCopy.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdlib.h&gt;
2 #include &lt;stdio.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;cassert&gt;
5 #include &lt;sstream&gt;
6 #include "ibex_ExprCopy.h"
7 #include "ibex_Function.h"
8 #include "ibex_Domain.h"
9 using namespace std;
10 namespace ibex {
11 void varcopy(const Array&lt;const ExprSymbol&gt;&amp; src, Array&lt;const ExprSymbol&gt;&amp; dest) {
12 	assert(src.size()&lt;=dest.size());
13 	for (int i=0; i&lt;src.size(); i++) {
14 		dest.set_ref(i,ExprSymbol::new_(src[i].name, src[i].dim));
15 	}
16 }
17 bool varequals(const Array&lt;const ExprSymbol&gt;&amp; arg1, Array&lt;const ExprSymbol&gt;&amp; arg2) {
18 	if (arg1.size()!=arg2.size()) return false;
19 	for (int j=0; j&lt;arg1.size(); j++)
20 		if (arg1[j].dim!=arg2[j].dim) return false;
21 	return true;
22 }
23 const ExprNode&amp; var_component(const Array&lt;const ExprSymbol&gt;&amp; args, int i) {
24 	int n=0; 	int j=0; 	while (n&lt;args.size() &amp;&amp; j&lt;=i) {
25 		const ExprNode&amp; x=args[n];
26 		if (j+x.dim.size() &gt; i) { 			switch (x.dim.type()) {
27 			case Dim::SCALAR :      return x;
28 			case Dim::ROW_VECTOR:
29 			case Dim::COL_VECTOR:   return x[i-j];
30 			case Dim::MATRIX:       return x[(i-j) / x.dim.nb_cols()][(i-j) % x.dim.nb_cols()];
31 			}
32 		} else {
33 			j+=x.dim.size();
34 			n++;
35 		}
36 	}
37 	ibex_error("var_component: index exceeds size.");
38 }
39 const ExprNode&amp; ExprCopy::copy(const Array&lt;const ExprSymbol&gt;&amp; old_x, const Array&lt;const ExprNode&gt;&amp; new_x, const ExprNode&amp; y, bool shared) {
40 	if (!shared) cache.clean();
41 <a name="1"></a>	for (int i=0; i&lt;std::min(new_x.size(), old_x.size()); i++) {
42 		if (shared &amp;&amp; cache.found(old_x[i])) continue;
43 		cache.insert(old_x[i],&amp;new_x[i]);
44 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
45 	return *visit(y);
46 }
47 const ExprNode* ExprCopy::visit(const ExprNode&amp; e) {
48 	return ExprVisitor&lt;const ExprNode*&gt;::visit(e);
49 }
50 const ExprNode* ExprCopy::visit(const ExprIndex&amp; i) {</b></font>
51 	return &amp;ExprIndex::new_(*visit(i.expr),i.index);
52 }
53 const ExprNode* ExprCopy::visit(const ExprSymbol&amp; x) {
54 	stringstream s;
55 	s &lt;&lt; "[ExprCopy] no destination node for symbol" &lt;&lt; x;
56 	ibex_error(s.str().c_str());
57 	return NULL;
58 }
59 const ExprNode* ExprCopy::visit(const ExprConstant&amp; c) {
60 	return &amp;c.copy();
61 }
62 const ExprNode* ExprCopy::nary(const ExprNAryOp&amp; e, std::function&lt;const ExprNAryOp&amp;(const Array&lt;const ExprNode&gt;&amp;)&gt; f) {
63 	Array&lt;const ExprNode&gt; args2(e.nb_args);
64 <a name="0"></a>	for (int i=0; i&lt;e.nb_args; i++) {
65 		args2.set_ref(i,*visit(e.arg(i)));
66 	}
67 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return &amp;f(args2);
68 }
69 const ExprNode* ExprCopy::visit(const ExprVector&amp; e) {
70 	return nary(e, [&amp;e](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprVector&amp; { return ExprVector::new_(args,e.orient); });
71 <a name="5"></a>}
72 const ExprNode* ExprCopy::visit(const ExprApply&amp; e) {
73 	return nary(e, [&amp;e](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprApply&amp; { return ExprApply::new_(*e.f,args); });</b></font><font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
74 <a name="4"></a>}
75 const ExprNode* ExprCopy::visit(const ExprChi&amp; e) {</b></font>
76 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return nary(e, [](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprChi&amp; { return ExprChi::new_(args); });
77 }
78 <a name="2"></a>
79 const ExprNode* ExprCopy::visit(const ExprGenericBinaryOp&amp; e) {
80 	                                       	   	   	  return &amp;ExprGenericBinaryOp::new_(e.name,*visit(e.left),*visit(e.right)); }</b></font>
81 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>const ExprNode* ExprCopy::visit(const ExprAdd&amp; e)   { return &amp;(*visit(e.left) + *visit(e.right));; }
82 const ExprNode* ExprCopy::visit(const ExprMul&amp; e)   { return &amp;(*visit(e.left) * *visit(e.right)); }
83 const ExprNode* ExprCopy::visit(const ExprSub&amp; e)   { return &amp;(*visit(e.left) - *visit(e.right)); }</b></font>
84 const ExprNode* ExprCopy::visit(const ExprDiv&amp; e)   { return &amp;(*visit(e.left) / *visit(e.right)); }
85 <a name="3"></a>const ExprNode* ExprCopy::visit(const ExprMax&amp; e)   { return &amp;max(*visit(e.left),*visit(e.right)); }
86 const ExprNode* ExprCopy::visit(const ExprMin&amp; e)   { return &amp;min(*visit(e.left),*visit(e.right)); }
87 const ExprNode* ExprCopy::visit(const ExprAtan2&amp; e) { return &amp;atan2(*visit(e.left),*visit(e.right)); }
88 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>const ExprNode* ExprCopy::visit(const ExprPower&amp; e) { return &amp;pow(*visit(e.expr),e.expon); }
89 const ExprNode* ExprCopy::visit(const ExprGenericUnaryOp&amp; e)
90 													{ return &amp;ExprGenericUnaryOp::new_(e.name,*visit(e.expr)); }
91 const ExprNode* ExprCopy::visit(const ExprMinus&amp; e) { return &amp;(-*visit(e.expr)); }</b></font>
92 const ExprNode* ExprCopy::visit(const ExprTrans&amp; e) { return &amp;transpose(*visit(e.expr)); }
93 const ExprNode* ExprCopy::visit(const ExprSign&amp; e)  { return &amp;sign(*visit(e.expr)); }
94 const ExprNode* ExprCopy::visit(const ExprAbs&amp; e)   { return &amp;abs(*visit(e.expr)); }
95 const ExprNode* ExprCopy::visit(const ExprSqr&amp; e)   { return &amp;sqr(*visit(e.expr)); }
96 const ExprNode* ExprCopy::visit(const ExprSqrt&amp; e)  { return &amp;sqrt(*visit(e.expr)); }
97 const ExprNode* ExprCopy::visit(const ExprExp&amp; e)   { return &amp;exp (*visit(e.expr)); }
98 const ExprNode* ExprCopy::visit(const ExprLog&amp; e)   { return &amp;log (*visit(e.expr)); }
99 const ExprNode* ExprCopy::visit(const ExprCos&amp; e)   { return &amp;cos (*visit(e.expr)); }
100 const ExprNode* ExprCopy::visit(const ExprSin&amp; e)   { return &amp;sin (*visit(e.expr)); }
101 const ExprNode* ExprCopy::visit(const ExprTan&amp; e)   { return &amp;tan (*visit(e.expr)); }
102 const ExprNode* ExprCopy::visit(const ExprCosh&amp; e)  { return &amp;cosh(*visit(e.expr)); }
103 const ExprNode* ExprCopy::visit(const ExprSinh&amp; e)  { return &amp;sinh(*visit(e.expr)); }
104 const ExprNode* ExprCopy::visit(const ExprTanh&amp; e)  { return &amp;tanh(*visit(e.expr)); }
105 const ExprNode* ExprCopy::visit(const ExprAcos&amp; e)  { return &amp;acos(*visit(e.expr)); }
106 const ExprNode* ExprCopy::visit(const ExprAsin&amp; e)  { return &amp;asin(*visit(e.expr)); }
107 const ExprNode* ExprCopy::visit(const ExprAtan&amp; e)  { return &amp;atan(*visit(e.expr)); }
108 const ExprNode* ExprCopy::visit(const ExprAcosh&amp; e) { return &amp;acosh(*visit(e.expr)); }
109 const ExprNode* ExprCopy::visit(const ExprAsinh&amp; e) { return &amp;asinh(*visit(e.expr)); }
110 const ExprNode* ExprCopy::visit(const ExprAtanh&amp; e) { return &amp;atanh(*visit(e.expr)); }
111 const ExprNode* ExprCopy::visit(const ExprFloor&amp; e) { return &amp;floor(*visit(e.expr)); }
112 const ExprNode* ExprCopy::visit(const ExprCeil&amp; e)  { return &amp;ceil(*visit(e.expr)); }
113 const ExprNode* ExprCopy::visit(const ExprSaw&amp; e)   { return &amp;saw (*visit(e.expr)); }
114 } 
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_ExprSimplify2.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "ibex_ExprSimplify2.h"
2 #include "ibex_ExprSubNodes.h"
3 #include "ibex_Expr.h"
4 #include "ibex_Map.h"
5 #include &lt;iostream&gt;
6 #include &lt;typeinfo&gt;
7 #include &lt;algorithm&gt;
8 using namespace std;
9 namespace ibex {
10 namespace {
11 bool is_cst(const ExprNode&amp; e) {
12 	return dynamic_cast&lt;const ExprConstant*&gt;(&amp;e)!=NULL;
13 }
14 bool is_mutable(const ExprNode&amp; e) {
15 	return ((const ExprConstant&amp;) e).is_mutable();
16 }
17 bool is_index(const ExprNode&amp; e) {
18 	return dynamic_cast&lt;const ExprIndex*&gt;(&amp;e)!=NULL;
19 }
20 bool is_minus(const ExprNode&amp; e) {
21 	return dynamic_cast&lt;const ExprMinus*&gt;(&amp;e)!=NULL;
22 }
23 bool is_trans(const ExprNode&amp; e) {
24 	return dynamic_cast&lt;const ExprTrans*&gt;(&amp;e)!=NULL;
25 }
26 bool is_add(const ExprNode&amp; e) {
27 	return dynamic_cast&lt;const ExprAdd*&gt;(&amp;e)!=NULL;
28 }
29 bool is_sub(const ExprNode&amp; e) {
30 	return dynamic_cast&lt;const ExprSub*&gt;(&amp;e)!=NULL;
31 }
32 bool is_mul(const ExprNode&amp; e) {
33 	return dynamic_cast&lt;const ExprMul*&gt;(&amp;e)!=NULL;
34 }
35 bool is_vec(const ExprNode&amp; e) {
36 	return dynamic_cast&lt;const ExprVector*&gt;(&amp;e)!=NULL;
37 }
38 const Domain&amp; to_cst(const ExprNode&amp; e) {
39 	const ExprConstant* c=dynamic_cast&lt;const ExprConstant*&gt;(&amp;e);
40 	assert(c);
41 	return c-&gt;get();
42 }
43 const ExprNode&amp; left(const ExprNode&amp; e) {
44 	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
45 	assert(b);
46 	return b-&gt;left;
47 }
48 const ExprNode&amp; right(const ExprNode&amp; e) {
49 	const ExprBinaryOp* b=dynamic_cast&lt;const ExprBinaryOp*&gt;(&amp;e);
50 	assert(b);
51 	return b-&gt;right;
52 }
53 const ExprNode&amp; expr(const ExprNode&amp; e) {
54 	const ExprUnaryOp* u=dynamic_cast&lt;const ExprUnaryOp*&gt;(&amp;e);
55 	assert(u);
56 	return u-&gt;expr;
57 }
58 } 
59 ExprSimplify2::ExprSimplify2(bool develop) : _2polynom(*this, develop) {
60 }
61 const ExprNode&amp; ExprSimplify2::rec(const ExprNode&amp; e) {
62 	record.push_back(&amp;e);
63 	return e;
64 }
65 const ExprNode&amp; ExprSimplify2::simplify(const ExprNode&amp; e) {
66 	const ExprNode&amp; _result = *visit(e);
67 	const ExprNode&amp; result = _2polynom.get(_result)-&gt;to_expr(&amp;record);
68 	ExprSubNodes old_nodes(e);
69 	ExprSubNodes new_nodes(result);
70 	for (vector&lt;const ExprNode*&gt;::iterator it=record.begin(); it!=record.end(); ++it) {
71 		if (!new_nodes.found(**it)) {
72 			delete *it;
73 		}
74 	}
75 	record.clear(); 
76 	vector&lt;const ExprNode*&gt; expr_symbols;
77 	for (int i=0; i&lt;old_nodes.size(); i++) {
78 		if (!dynamic_cast&lt;const ExprSymbol*&gt;(&amp;old_nodes[i]) &amp;&amp;
79 				!new_nodes.found(old_nodes[i]) &amp;&amp;
80 				!lock.found(old_nodes[i])) {
81 			delete &amp;old_nodes[i];
82 		}
83 <a name="1"></a>		<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
84 	cache.clean();
85 	_2polynom.cleanup();
86 	return result;
87 }
88 const ExprNode* ExprSimplify2::visit(const ExprNode&amp; e) {
89 	return ExprVisitor&lt;const ExprNode*&gt;::visit(e);
90 }
91 const ExprNode* ExprSimplify2::visit(const ExprIndex&amp; e) {</b></font>
92 	const ExprNode* expr2 = visit(e.expr);
93 	assert(expr2-&gt;dim==e.expr.dim);
94 	if (is_cst(*expr2)) {
95 		if (is_mutable(*expr2))
96 			return &amp;rec(ExprConstant::new_mutable(to_cst(*expr2)[e.index]));
97 		else
98 			return &amp;rec(ExprConstant::new_(to_cst(*expr2)[e.index]));
99 	} else if (e.index.all()) {
100 		return &amp;*expr2;
101 	} else if (is_index(*expr2)) {
102 		const ExprIndex* id2= (const ExprIndex*) expr2;
103 		return &amp;rec(id2-&gt;expr[id2-&gt;index[e.index]]);
104 	} else if (is_minus(*expr2)) {
105 		return visit(rec(-rec(expr(*expr2)[e.index])));
106 	} else if (is_trans(*expr2)) {
107 		return visit(rec(expr(*expr2)[e.index.transpose()]));
108 	} else if (is_add(*expr2)) {
109 		return visit(rec(rec(left(*expr2)[e.index]) + rec(right(*expr2)[e.index])));
110 	} else if (is_sub(*expr2)) {
111 		return visit(rec(rec(left(*expr2)[e.index]) - rec(right(*expr2)[e.index])));
112 	} else if (is_mul(*expr2)) {
113 		if (left(*expr2).dim.is_scalar())
114 			if (is_cst(*expr2) &amp;&amp; !is_mutable(*expr2) &amp;&amp; to_cst(*expr2).is_zero())
115 				return &amp;rec(ExprConstant::new_matrix(Matrix::zeros(e.dim.nb_rows(),e.dim.nb_cols())));
116 			else
117 				return visit(rec(left(*expr2) * rec(right(*expr2)[e.index])));
118 		else
119 			return visit(rec(
120 				rec(left(*expr2)[e.index.rows(left(*expr2).dim,e.index.first_row(),e.index.last_row())]) *
121 				rec(right(*expr2)[e.index.cols(right(*expr2).dim,e.index.first_col(),e.index.last_col())])));
122 	} else if (is_vec(*expr2)) {
123 		vector&lt;const ExprNode*&gt; res;
124 		const DoubleIndex&amp; idx=e.index;
125 		const ExprVector&amp; v=(const ExprVector&amp;) *expr2;
126 		unsigned int i=0;
127 		if (v.row_vector()) {
128 			int c=0;
129 			while (c&lt;=idx.last_col()) {
130 				int n=v.arg(i).dim.nb_cols();
131 				int first_col=idx.first_col()-c;
132 				if (first_col&lt;n) { 					int last_col=idx.last_col()-c;
133 					DoubleIndex e_idx=DoubleIndex(v.arg(i).dim,
134 							idx.first_row(), idx.last_row(),
135 							first_col&lt;0? 0 : first_col, last_col&gt;=n? n-1 : last_col);
136 					res.push_back(&amp; rec(v.arg(i)[e_idx]));
137 				}
138 				c+=n;
139 				assert(((int) i)&lt;v.nb_args);
140 				i++;
141 			}
142 		} else {
143 			int r=0;
144 			while (r&lt;=idx.last_row()) {
145 				int n=v.arg(i).dim.nb_rows();
146 				int first_row=idx.first_row()-r;
147 				if (first_row&lt;n) { 					int last_row=idx.last_row()-r;
148 					DoubleIndex e_idx=DoubleIndex(v.arg(i).dim,
149 							first_row&lt;0? 0 : first_row, last_row&gt;=n? n-1 : last_row,
150 									idx.first_col(), idx.last_col());
151 					res.push_back(&amp; rec(v.arg(i)[e_idx]));
152 				}
153 				r+=n;
154 				assert(((int) i)&lt;v.nb_args);
155 				i++;
156 			}
157 		}
158 		if (res.size()==1)
159 			return visit(*res.back());
160 		else
161 			return visit(rec(ExprVector::new_(res,v.orient)));
162 <a name="2"></a>	} else if (expr2==&amp;e.expr) {
163 		return &amp;e;
164 	} else
165 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return &amp;rec((*expr2)[e.index]);
166 }
167 const ExprNode* ExprSimplify2::visit(const ExprSymbol&amp; e) {
168 	return &amp;e;
169 }
170 const ExprNode* ExprSimplify2::visit(const ExprConstant&amp; e) {
171 	return &amp;e;
172 }</b></font>
173 typedef Domain (*_domain_una_op)(const Domain&amp;);
174 typedef Domain (*_domain_bin_op)(const Domain&amp;, const Domain&amp;);
175 const ExprNode* ExprSimplify2::unary(const ExprUnaryOp&amp; e,
176 		std::function&lt;Domain(const Domain&amp;)&gt; fcst,
177 		std::function&lt;const ExprNode&amp;(const ExprNode&amp;)&gt; fctr) {
178 	const ExprNode* expr2=visit(e.expr);
179 	assert(expr2-&gt;dim==e.expr.dim);
180 	if (is_cst(*expr2)) {
181 		if (is_mutable(*expr2))
182 			return &amp;rec(fctr(*expr2));
183 		else
184 			return &amp;rec(ExprConstant::new_(fcst(to_cst(*expr2))));
185 	} else if (!e.dim.is_scalar()) { 		assert(dynamic_cast&lt;const ExprMinus*&gt;(&amp;e));
186 		bool row = e.dim.is_matrix() || e.dim.type()==Dim::ROW_VECTOR;
187 		Array&lt;const ExprNode&gt; args(e.dim.vec_size());
188 		for (int i=0; i&lt;e.dim.vec_size(); i++)
189 			args.set_ref(i, rec(fctr(rec((*expr2)[i]))));
190 		return visit(rec(ExprVector::new_(args, row ? ExprVector::ROW : ExprVector::COL)));
191 	} else if (expr2==&amp;e.expr) {
192 		return &amp;e;
193 	} else
194 		return &amp;rec(fctr(*expr2));
195 }
196 const ExprNode* ExprSimplify2::binary(const ExprBinaryOp&amp; e,
197 		std::function&lt;Domain(const Domain&amp;, const Domain&amp;)&gt; fcst,
198 		std::function&lt;const ExprBinaryOp&amp;(const ExprNode&amp;, const ExprNode&amp;)&gt; fctr) {
199 	const ExprNode* l2=visit(e.left);
200 	assert(l2-&gt;dim==e.left.dim);
201 	const ExprNode* r2=visit(e.right);
202 	assert(r2-&gt;dim==e.right.dim);
203 	bool all_same = (l2==&amp;e.left &amp;&amp; r2==&amp;e.right);
204 	if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; is_cst(*r2) &amp;&amp; !is_mutable(*r2)) {
205 		return &amp;rec(ExprConstant::new_(fcst(to_cst(*l2), to_cst(*r2))));
206 	} else if ((!l2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*l2) || is_cst(*l2)))
207 			|| (!r2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*r2) || is_cst(*r2)))) { 
208 		Array&lt;const ExprNode&gt; rows(e.dim.nb_rows());
209 		Array&lt;const ExprNode&gt; col (e.dim.nb_cols());
210 		for (int i=0; i&lt;e.dim.nb_rows(); i++) {
211 			col.clear();
212 			for (int j=0; j&lt;e.dim.nb_cols(); j++) {
213 				col.set_ref(j,rec(fctr(
214 						rec((*l2)[DoubleIndex::one_elt(e.dim,i,j)]),
215 						rec((*r2)[DoubleIndex::one_elt(e.dim,i,j)]))));
216 			}
217 			if (e.dim.nb_cols()&gt;1)
218 				rows.set_ref(i, rec(ExprVector::new_(col,ExprVector::ROW)));
219 			else
220 				rows.set_ref(i, col[0]);
221 		}
222 		if (e.dim.nb_rows()&gt;1)
223 			return visit(rec(ExprVector::new_(rows,ExprVector::COL)));
224 		else
225 			return visit(rows[0]);
226 	} else if (all_same) {
227 		return &amp;e;
228 	} else
229 		return &amp;rec(fctr(*l2,*r2));
230 }
231 const ExprNode* ExprSimplify2::nary(const ExprNAryOp&amp; e,
232 		std::function&lt;Domain(Array&lt;const Domain&gt;&amp;)&gt; fcst,
233 		std::function&lt;const ExprNAryOp&amp;(Array&lt;const ExprNode&gt;&amp;)&gt; f) {
234 	bool all_cst = true;
235 	bool all_same = true;
236 	Array&lt;const ExprNode&gt; args2(e.nb_args);
237 	for (int i=0; i&lt;e.nb_args; i++) {
238 		args2.set_ref(i,*visit(e.arg(i)));
239 		all_cst &amp;= ( is_cst(args2[i]) &amp;&amp; !is_mutable(args2[i]) );
240 		all_same &amp;= (&amp;args2[i]==&amp;e.arg(i));
241 	}
242 	if (all_cst) {
243 		Array&lt;const Domain&gt; arg_cst(e.nb_args);
244 		for (int i=0; i&lt;e.nb_args; i++) {
245 			arg_cst.set_ref(i, to_cst(args2[i]));
246 		}
247 		return &amp;rec(ExprConstant::new_(fcst(arg_cst)));
248 	} else if (all_same) {
249 		return &amp;e;
250 	} else {
251 		return &amp;rec(f(args2));
252 	}
253 }
254 const ExprNode* ExprSimplify2::visit(const ExprVector&amp; e) {
255 	bool all_cst = true;
256 	bool all_same = true;
257 	Array&lt;const ExprNode&gt; args2(e.nb_args);
258 	for (int i=0; i&lt;e.nb_args; i++) {
259 		args2.set_ref(i,*visit(e.arg(i)));
260 		all_cst &amp;= ( is_cst(args2[i]) &amp;&amp; !is_mutable(args2[i]) );
261 		all_same &amp;= (&amp;args2[i]==&amp;e.arg(i));
262 	}
263 	if (all_cst) {
264 		Array&lt;const Domain&gt; arg_cst(e.nb_args);
265 		for (int i=0; i&lt;e.nb_args; i++) {
266 			arg_cst.set_ref(i, to_cst(args2[i]));
267 		}
268 		return &amp;rec(ExprConstant::new_(Domain(arg_cst, e.row_vector())));
269 	}
270 	else if (args2.size()==1)
271 		return &amp;args2[0]; 	else if (all_same) {
272 		return &amp;e;
273 	} else {
274 		return &amp;rec(ExprVector::new_(args2, e.orient));
275 	}
276 }
277 <a name="5"></a>const ExprNode* ExprSimplify2::visit(const ExprChi&amp; e) {
278 	return nary(e,
279 			[](Array&lt;const Domain&gt;&amp; args) { return chi(args[0],args[1],args[2]); },
280 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b><a name="0"></a>			[](const Array&lt;const ExprNode&gt;&amp; args)-&gt;const ExprChi&amp; { return ExprChi::new_(args); });
281 }
282 </b></font><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>const ExprNode* ExprSimplify2::visit(const ExprApply&amp; e) { return &amp;e; 
283 const ExprNode* ExprSimplify2::visit(const ExprGenericBinaryOp&amp; e) {
284 	return binary( e,
285 			e.eval,
286 			[&amp;e](const ExprNode&amp; x,const ExprNode&amp; y)-&gt;const ExprBinaryOp&amp; { return ExprGenericBinaryOp::new_(e.name,x,y);});
287 }
288 const ExprNode* ExprSimplify2::visit(const ExprAdd&amp; e)   { return binary(e, (_domain_bin_op) operator+, ExprAdd::new_); }</b></font>
289 const ExprNode* ExprSimplify2::visit(const ExprSub&amp; e)   { return binary(e, (_domain_bin_op) operator-, ExprSub::new_); }
290 const ExprNode* ExprSimplify2::visit(const ExprMul&amp; e)   {
291 	const ExprNode* l2=visit(e.left);
292 	assert(l2-&gt;dim==e.left.dim);
293 	const ExprNode* r2=visit(e.right);
294 	assert(r2-&gt;dim==e.right.dim);
295 	bool all_same = (l2==&amp;e.left &amp;&amp; r2==&amp;e.right);
296 	if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; is_cst(*r2) &amp;&amp; !is_mutable(*r2)) {
297 		return &amp;rec(ExprConstant::new_(to_cst(*l2) * to_cst(*r2)));
298 	} else if ((!l2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*l2) || is_cst(*l2)))
299 			|| (!r2-&gt;dim.is_scalar() &amp;&amp; (is_vec(*r2) || is_cst(*r2)))) { 
300 		Array&lt;const ExprNode&gt; cols(r2-&gt;dim.nb_cols());
301 		if (l2-&gt;dim.is_scalar()) { 			if (is_cst(*l2) &amp;&amp; !is_mutable(*l2) &amp;&amp; to_cst(*l2).is_zero())
302 				return &amp;rec(ExprConstant::new_matrix(Matrix::zeros(r2-&gt;dim.nb_rows(),r2-&gt;dim.nb_cols())));
303 			Array&lt;const ExprNode&gt; col (r2-&gt;dim.nb_rows());
304 			for (int j=0; j&lt;r2-&gt;dim.nb_cols(); j++) {
305 				col.clear();
306 				for (int i=0; i&lt;r2-&gt;dim.nb_rows(); i++) {
307 					col.set_ref(i, rec((*l2)*rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,i,j)])));
308 				}
309 				if (r2-&gt;dim.nb_rows()&gt;1)
310 					cols.set_ref(j, rec(ExprVector::new_(col,ExprVector::COL)));
311 				else
312 					cols.set_ref(j, col[0]);
313 			}
314 		} else {
315 			Array&lt;const ExprNode&gt; col (l2-&gt;dim.nb_rows());
316 			for (int j=0; j&lt;r2-&gt;dim.nb_cols(); j++) {
317 				col.clear();
318 				for (int i=0; i&lt;l2-&gt;dim.nb_rows(); i++) {
319 					const ExprNode* e=NULL;
320 					for (int k=0; k&lt;l2-&gt;dim.nb_cols(); k++) {
321 						if (e)
322 							e = &amp; rec(*e +
323 									rec(rec((*l2)[DoubleIndex::one_elt(l2-&gt;dim,i,k)])*
324 											rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,k,j)]))
325 							);
326 						else
327 							e = &amp; rec(
328 									rec((*l2)[DoubleIndex::one_elt(l2-&gt;dim,i,k)])*
329 									rec((*r2)[DoubleIndex::one_elt(r2-&gt;dim,k,j)])
330 							);
331 					}
332 					col.set_ref(i,*e);
333 				}
334 				if (l2-&gt;dim.nb_rows()&gt;1)
335 					cols.set_ref(j, rec(ExprVector::new_(col,ExprVector::COL)));
336 				else
337 					cols.set_ref(j, col[0]);
338 			}
339 		}
340 		if (r2-&gt;dim.nb_cols()&gt;1) {
341 			return visit(rec(ExprVector::new_(cols,ExprVector::ROW)));
342 		}
343 		else
344 			return visit(cols[0]);
345 	} else if (all_same) {
346 		return &amp;e;
347 	} else
348 <a name="3"></a>		return &amp;rec((*l2)*(*r2));
349 }
350 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>const ExprNode* ExprSimplify2::visit(const ExprDiv&amp; e)   { return binary(e, (_domain_bin_op) operator/, ExprDiv::new_); }
351 const ExprNode* ExprSimplify2::visit(const ExprMax&amp; e)   { return binary(e, (_domain_bin_op) max,       ExprMax::new_); }
352 const ExprNode* ExprSimplify2::visit(const ExprMin&amp; e)   { return binary(e, (_domain_bin_op) min,       ExprMin::new_); }</b></font>
353 const ExprNode* ExprSimplify2::visit(const ExprAtan2&amp; e) { return binary(e, (_domain_bin_op) atan2,     ExprAtan2::new_); }
354 const ExprNode* ExprSimplify2::visit(const ExprPower&amp; e) {
355 	return unary(e,
356 			[&amp;e](const Domain&amp; x)-&gt;Domain { return pow(x,e.expon); },
357 			[&amp;e](const ExprNode&amp; expr)-&gt;const ExprNode&amp; { return ibex::pow(expr,e.expon); });
358 }
359 const ExprNode* ExprSimplify2::visit(const ExprTrans&amp; e) {
360 	const ExprNode* expr2 = visit(e.expr);
361 	if (is_cst(*expr2) &amp;&amp; !is_mutable(*expr2)) {
362 		return &amp;rec(ExprConstant::new_(transpose(to_cst(*expr2))));
363 	} else if (is_trans(*expr2)) {
364 		return &amp;expr(*expr2); 	} else if (is_index(*expr2)) {
365 		const ExprIndex&amp; i=(const ExprIndex&amp;) *expr2;
366 		return visit(rec(i.expr[i.index.transpose()]));
367 	} else if (is_minus(*expr2)) {
368 		return visit(rec(-rec(transpose(expr(*expr2)))));
369 	} else if (is_add(*expr2)) {
370 		return visit(rec(rec(transpose(left(*expr2))) + rec(transpose(right(*expr2)))));
371 	} else if (is_sub(*expr2)) {
372 		return visit(rec(rec(transpose(left(*expr2))) - rec(transpose(right(*expr2)))));
373 	} else if (is_mul(*expr2)) {
374 		return visit(rec(rec(transpose(right(*expr2))) * rec(transpose(left(*expr2)))));
375 	} else if (is_vec(*expr2)) {
376 		const ExprVector&amp; ev=(const ExprVector&amp;) *expr2;
377 		return &amp;rec(ExprVector::new_(ev.args, ev.orient==ExprVector::ROW? ExprVector::COL : ExprVector::ROW));
378 	} else if (e.dim.is_scalar())
379 		return expr2;
380 	else if (expr2==&amp;e.expr) {
381 		return &amp;e;
382 	} else {
383 		return &amp;rec(transpose(*expr2));
384 	}
385 }
386 <a name="4"></a>
387 const ExprNode* ExprSimplify2::visit(const ExprGenericUnaryOp&amp; e) {
388 	return unary(e, e.eval,
389 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			[&amp;e](const ExprNode&amp; x)-&gt;const ExprUnaryOp&amp; { return ExprGenericUnaryOp::new_(e.name,x);});
390 }
391 const ExprNode* ExprSimplify2::visit(const ExprMinus&amp; e) { return unary(e, (_domain_una_op) operator-, ExprMinus::new_); }</b></font>
392 const ExprNode* ExprSimplify2::visit(const ExprSqr&amp; e)   { return unary(e, (_domain_una_op) sqr,  ExprSqr::new_);  }
393 const ExprNode* ExprSimplify2::visit(const ExprSign&amp; e)  { return unary(e, (_domain_una_op) sign, ExprSign::new_);  }
394 const ExprNode* ExprSimplify2::visit(const ExprAbs&amp; e)   { return unary(e, (_domain_una_op) abs,  ExprAbs::new_);  }
395 const ExprNode* ExprSimplify2::visit(const ExprSqrt&amp; e)  { return unary(e, (_domain_una_op) sqrt, ExprSqrt::new_); }
396 const ExprNode* ExprSimplify2::visit(const ExprExp&amp; e)   { return unary(e, (_domain_una_op) exp,  ExprExp::new_); }
397 const ExprNode* ExprSimplify2::visit(const ExprLog&amp; e)   { return unary(e, (_domain_una_op) log,  ExprLog::new_); }
398 const ExprNode* ExprSimplify2::visit(const ExprCos&amp; e)   { return unary(e, (_domain_una_op) cos,  ExprCos::new_); }
399 const ExprNode* ExprSimplify2::visit(const ExprSin&amp; e)   { return unary(e, (_domain_una_op) sin,  ExprSin::new_); }
400 const ExprNode* ExprSimplify2::visit(const ExprTan&amp; e)   { return unary(e, (_domain_una_op) tan,  ExprTan::new_); }
401 const ExprNode* ExprSimplify2::visit(const ExprCosh&amp; e)  { return unary(e, (_domain_una_op) cosh, ExprCosh::new_); }
402 const ExprNode* ExprSimplify2::visit(const ExprSinh&amp; e)  { return unary(e, (_domain_una_op) sinh, ExprSinh::new_); }
403 const ExprNode* ExprSimplify2::visit(const ExprTanh&amp; e)  { return unary(e, (_domain_una_op) tanh, ExprTanh::new_); }
404 const ExprNode* ExprSimplify2::visit(const ExprAcos&amp; e)  { return unary(e, (_domain_una_op) acos, ExprAcos::new_); }
405 const ExprNode* ExprSimplify2::visit(const ExprAsin&amp; e)  { return unary(e, (_domain_una_op) asin, ExprAsin::new_); }
406 const ExprNode* ExprSimplify2::visit(const ExprAtan&amp; e)  { return unary(e, (_domain_una_op) atan, ExprAtan::new_); }
407 const ExprNode* ExprSimplify2::visit(const ExprAcosh&amp; e) { return unary(e, (_domain_una_op) acosh,ExprAcosh::new_); }
408 const ExprNode* ExprSimplify2::visit(const ExprAsinh&amp; e) { return unary(e, (_domain_una_op) asinh,ExprAsinh::new_); }
409 const ExprNode* ExprSimplify2::visit(const ExprAtanh&amp; e) { return unary(e, (_domain_una_op) atanh,ExprAtanh::new_); }
410 const ExprNode* ExprSimplify2::visit(const ExprFloor&amp; e) { return unary(e, (_domain_una_op) floor,ExprFloor::new_); }
411 const ExprNode* ExprSimplify2::visit(const ExprCeil&amp; e)  { return unary(e, (_domain_una_op) ceil, ExprCeil::new_); }
412 const ExprNode* ExprSimplify2::visit(const ExprSaw&amp; e)   { return unary(e, (_domain_una_op) saw,  ExprSaw::new_);  }
} </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
