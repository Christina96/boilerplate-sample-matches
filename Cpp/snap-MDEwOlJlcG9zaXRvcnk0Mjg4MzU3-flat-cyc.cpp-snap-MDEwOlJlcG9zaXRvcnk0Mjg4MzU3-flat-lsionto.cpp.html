
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.568872243029546%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</h3>
            <pre><code>1  #include "cyc.h"
2  TStr TCycVrtx::GetCycVrtxFlagStr(const TCycVrtxFlag& CycVrtxFlag){
3    switch (CycVrtxFlag){
4      case cvfUndef: return "Undef";
5      case cvfNum: return "Num";
6      case cvfStr: return "Str";
7      case cvfCycL: return "CycL";
8      case cvfCycLConst: return "CycLConst"; 
9      case cvfCycLExpr: return "CycLExpr";
10      case cvfCycLPred: return "CycLPred";
11      case cvfBackLink: return "BackLink";
12      case cvfHumanOk: return "HumanOk";
13      case cvfHumanRelevant: return "HumanRelevant";
14      case cfvHumanIrrelevant: return "HumanIrrelevant";
15      case cfvHumanClarifying: return "HumanClarifying";
16      default: Fail; return "";
17    }
18  }
19  TStr TCycVrtx::GetFlagStr() const {
20    TChA ChA;
21    ChA+='[';
22    for (int FlagId=cvfMn; FlagId<cvfMx; FlagId++){
23      if (IsFlag(FlagId)){
24        if (ChA.Len()>1){ChA+=' ';}
25        ChA+=GetCycVrtxFlagStr(TCycVrtxFlag(FlagId));
26      }
27    }
28    ChA+=']';
29    return ChA;
30  }
31  int TCycBs::AddVNm(const TStr& VNm){
32    int VId;
33    if (VNmToVrtxH.IsKey(VNm.CStr(), VId)){
34      return VId;
35    } else {
36      VId=VNmToVrtxH.AddKey(VNm);
37      TCycVrtx& Vrtx=VNmToVrtxH[VId];
38      Vrtx.PutVId(VId);
39      if (VNm.IsPrefix("~")){
40        Vrtx.SetFlag(cvfBackLink);
41      } else
42      if (VNm.IsPrefix("#$")&&(!VNm.IsChIn(' '))){
43        Vrtx.SetFlag(cvfCycL);
44        if (VNm.Len()>2){
45          char Ch=VNm[2];
46          if (('a'<=Ch)&&(Ch<='z')){
47            Vrtx.SetFlag(cvfCycLPred);
48          } else {
49            Vrtx.SetFlag(cvfCycLConst);
50          }
51        }
52      } else
53      if (VNm.IsPrefix("(#$")){
54        Vrtx.SetFlag(cvfCycL);
55        Vrtx.SetFlag(cvfCycLExpr);
56      } else {
57        if (VNm.IsFlt()){
58          Vrtx.SetFlag(cvfNum);
59        } else {
60          Vrtx.SetFlag(cvfStr);
61        }
62      }
63      return VId;
64    }
65  }
66  void TCycBs::GetRelNmV(TStrV& RelNmV){
67    TStrH RelNmH;
68    for (int VId=0; VId<GetVIds(); VId++){
69      TStr VNm=GetVNm(VId);
70      TCycVrtx& Vrtx=GetVrtx(VId);
71      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
72        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
73        TStr RelNm=GetVNm(Edge.GetRelId());
74        RelNmH.AddKey(RelNm);
75      }
76    }
77    RelNmH.GetKeyV(RelNmV);
78  }
79  TStr TCycBs::GetDocStrFromCycLConstStr(const TStr& CycLConstStr){
80    TChA ChA=CycLConstStr;
81    TChA DstChA;
82    if ((ChA.Len()>2)&&(ChA[0]=='#')&&(ChA[1]=='$')){
83      int ChN=2;
84      while (ChN<ChA.Len()){
85        if (DstChA.Len()>0){DstChA+=' ';}
86        if ((ChA[ChN]=='-')||(ChA[ChN]=='_')||(ChA[ChN]==':')){
87          DstChA+="-"; ChN++;
88        } else
89        if (('0'<=ChA[ChN])&&(ChA[ChN]<='9')){
90          do {
91            DstChA+=ChA[ChN]; ChN++;
92          } while ((ChN<ChA.Len())&&('0'<=ChA[ChN])&&(ChA[ChN]<='9'));
93        } else
94        if (('a'<=ChA[ChN])&&(ChA[ChN]<='z')){
95          do {
96            DstChA+=ChA[ChN]; ChN++;
97          } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
98        } else
99        if (('A'<=ChA[ChN])&&(ChA[ChN]<='Z')){
100          if ((ChN+1<ChA.Len())&&('a'<=ChA[ChN+1])&&(ChA[ChN+1]<='z')){
101            do {
102              DstChA+=ChA[ChN]; ChN++;
103            } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
104          } else {
105            do {
106              DstChA+=ChA[ChN]; ChN++;
107            } while (((ChN==ChA.Len()-1)&&('A'<=ChA[ChN])&&(ChA[ChN]<='Z'))||
108              ((ChN+1<ChA.Len())&&('A'<=ChA[ChN+1])&&(ChA[ChN+1]<='Z')));
109          }
110        } else {
111          DstChA=""; break;
112        }
113      }
114    } else {
115      DstChA="";
116    }
117    return DstChA;
118  }
119  PLwOnto TCycBs::LoadCycVoc(const TStr& CycBsFNm, const bool& HumanOkOnlyP){
120    printf("Loading Cyc-Base from Binary-File '%s' ... ", CycBsFNm.CStr());
121    PCycBs CycBs=TCycBs::LoadBin(CycBsFNm);
122    int VIds=CycBs->GetVIds();
123    printf("Done.\n");
124    PLwOnto LwOnto=TLwOnto::New();
125    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
126    PLwTermType C_TermType=TLwTermType::New(0, "Class", EnLangId);
127    PLwTermType L_TermType=TLwTermType::New(1, "Lexical", EnLangId);
128    int C_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(C_TermType);
129    int L_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(L_TermType);
130    {printf("Creating link-types ...");
131    TStrV RelNmV; CycBs->GetRelNmV(RelNmV);
132    for (int RelNmN=0; RelNmN<RelNmV.Len(); RelNmN++){
133      TStr RelNm=RelNmV[RelNmN];
134      if (RelNm[0]=='~'){continue;}
135      PLwLinkType LinkType=TLwLinkType::New(RelNmN, RelNm, EnLangId, "");
136      LwOnto->GetLinkTypeBs()->AddLinkType(LinkType);
137    }
138    printf(" Done. (%d)\n", LwOnto->GetLinkTypeBs()->GetLinkTypes());}
139    {printf("Creating terms ...\n");
140    for (int VId=0; VId<VIds; VId++){
141      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
142      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
143      if (Vrtx.IsFlag(cvfCycLPred)){continue;}
144      if ((!Vrtx.IsFlag(cvfStr))&&
145       (HumanOkOnlyP&&(!Vrtx.IsFlag(cvfHumanOk)))){continue;}
146      TStr VNm=CycBs->GetVNm(VId);
147      int TermTypeId=(Vrtx.IsFlag(cvfStr)) ? L_TermTypeId : C_TermTypeId;
148      PLwTerm Term=TLwTerm::New(VId, VNm, EnLangId, TermTypeId);
149      LwOnto->GetTermBs()->AddTerm(Term);
150    }
151    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
152    {printf("Creating links ...\n");
153    for (int VId=0; VId<VIds; VId++){
154      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
155      if (!LwOnto->GetTermBs()->IsTermId(VId)){continue;}
156      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
157      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
158        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
159        int DstVId=Edge.GetDstVId();
160        if (!LwOnto->GetTermBs()->IsTermId(DstVId)){continue;}
161        TStr RelNm=CycBs->GetVNm(Edge.GetRelId());
162        if (LwOnto->GetLinkTypeBs()->IsLinkType(RelNm, EnLangId)){
163          int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(RelNm, EnLangId);
164          LwOnto->GetLinkBs()->AddLink(VId, LinkTypeId, DstVId);
165        }
166      }
167    }
168    printf("Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
169    return LwOnto;
170  }
171  void TCycBs::SaveTxt(const TStr& FNm){
172    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
173    for (int VId=0; VId<GetVIds(); VId++){
174      TStr VNm=GetVNm(VId);
175      TCycVrtx& Vrtx=GetVrtx(VId);
176      TStr FlagStr=Vrtx.GetFlagStr();
177      fprintf(fOut, "(%d) %s - %s\n", VId, VNm.CStr(), FlagStr.CStr());
178      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
179        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, "     %d. [%s] --> %s\n", 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
183      }
184    }
185  }
186  void TCycBs::_SaveTaxonomyTxt(FILE* fOut, 
187   const int& Lev, TIntPrV& RelIdVIdPrV, TIntIntH& VIdToLevH){
188    for (int VidN=0; VidN<RelIdVIdPrV.Len(); VidN++){
189      int FromRelId=RelIdVIdPrV[VidN].Val1;
190      int SrcVId=RelIdVIdPrV[VidN].Val2;
191      TStr SrcVNm=GetVNm(SrcVId);
192      TCycVrtx& SrcVrtx=GetVrtx(SrcVId);
193      if (!SrcVrtx.IsFlag(cvfHumanOk)){continue;}
194      TStr FlagStr=SrcVrtx.GetFlagStr();
195      if (FromRelId==-1){
196        if (Lev>0){fprintf(fOut, "===upper");} else {fprintf(fOut, "===lower");}
197        fprintf(fOut, "=======================================================\n");
198        fprintf(fOut, "%s - %s\n", SrcVNm.CStr(), FlagStr.CStr());
199      } else {
200        TStr FromRelNm=GetVNm(FromRelId);
201        fprintf(fOut, "%*c[%s] --> %s\n", (Lev-1)*5, ' ', FromRelNm.CStr(), SrcVNm.CStr());
202      }
203      TIntPrV UpRelIdVIdPrV;
204      for (int EdgeN=0; EdgeN<SrcVrtx.GetEdges(); EdgeN++){
205        TCycEdge& Edge=SrcVrtx.GetEdge(EdgeN);
206        int RelId=Edge.GetRelId();
207        int DstVId=Edge.GetDstVId();
208        TStr RelNm=GetVNm(RelId);
209        TStr DstVNm=GetVNm(DstVId);
210        if (Lev>0){
211          if ((RelNm=="#$isa")||(RelNm=="#$genls")){
212            if (!VIdToLevH.IsKey(DstVId)){
213              VIdToLevH.AddDat(DstVId, Lev+1);
214              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
215            }
216          }
217        } else {
218          if ((RelNm=="~#$isa")||(RelNm=="~#$genls")){
219            if (!VIdToLevH.IsKey(DstVId)){
220              VIdToLevH.AddDat(DstVId, Lev-1);
221              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
222            }
223          }
224        }
225      } 
226      if (Lev>0){
227        _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);
228      } else {
229        _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);
230      }
231    }
232  }
233  void TCycBs::SaveTaxonomyTxt(const TStr& FNm){
234    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
235    for (int VId=0; VId<GetVIds(); VId++){
236      printf("%d/%d (%.1f%%)\r", 1+VId, GetVIds(), 100.0*(1+VId)/GetVIds());
237      {int Lev=0;
238      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
239      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
240      _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);}
241      {int Lev=0;
242      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
243      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
244      _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);}
245    }
246    printf("\n");
247  }
248  void TCycBs::SaveStatTxt(const TStr& FNm){
249    PMom CommentLenMom=TMom::New();
250    PMom StrsLenMom=TMom::New();
251    PMom HumanOk_StrsLenMom=TMom::New();
252    PMom ClassesPerStrMom=TMom::New();
253    PMom StrsPerClassMom=TMom::New();
254    PMom HumanOk_StrsPerClassMom=TMom::New();
255    PMom IsasPerClassMom=TMom::New();
256    PMom HumanOk_IsasPerClassMom=TMom::New();
257    PMom GenlsPerClassMom=TMom::New();
258    PMom HumanOk_GenlsPerClassMom=TMom::New();
259    PMom IsasGenlsPerClassMom=TMom::New();
260    PMom HumanOk_IsasGenlsPerClassMom=TMom::New();
261    int Classes=0;
262    int HumanOk_Classes=0;
263    int Comments=0;
264    int HumanOk_Comments=0;
265    for (int VId=0; VId<GetVIds(); VId++){
266      TStr VNm=GetVNm(VId);
267      TCycVrtx& Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
272      int Isas=0; int Genls=0;
273      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
274        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx& DstVrtx=GetVrtx(Edge.GetDstVId());
278        if (RelNm=="#$comment"){
279          CommentLenMom->Add(DstVNm.Len());
280          Comments++; 
281          if (Vrtx.IsFlag(cvfHumanOk)){HumanOk_Comments++;}
282        }
283        if (DstVrtx.IsFlag(cvfStr)){StrsLen+=DstVNm.Len();}
284        if (Vrtx.IsFlag(cvfStr)){ClassesPerStrInstance++;}
285        if (RelNm=="#$nameString"){NmStrs++;}
286        if (RelNm=="~#$nameString"){BackLinkNmStrs++;}
287        if (RelNm=="#$isa"){Isas++;}
288        if (RelNm=="#$genls"){Genls++;}
289      }
290      if (Vrtx.IsFlag(cvfCycL)){Classes++;}
291      if (Vrtx.IsFlag(cvfCycL)){StrsLenMom->Add(StrsLen);}
292      if (Vrtx.IsFlag(cvfStr)){ClassesPerStrMom->Add(BackLinkNmStrs);}
293      if (Vrtx.IsFlag(cvfCycL)){StrsPerClassMom->Add(NmStrs);}
294      if (Vrtx.IsFlag(cvfCycL)){IsasPerClassMom->Add(Isas);}
295      if (Vrtx.IsFlag(cvfCycL)){GenlsPerClassMom->Add(Genls);}
296      if (Vrtx.IsFlag(cvfCycL)){IsasGenlsPerClassMom->Add(Isas+Genls);}
297      if (Vrtx.IsFlag(cvfHumanOk)){
298        if (Vrtx.IsFlag(cvfCycL)){HumanOk_Classes++;}
299        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsLenMom->Add(StrsLen);}
300        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsPerClassMom->Add(NmStrs);}
301        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasPerClassMom->Add(Isas);}
302        if (Vrtx.IsFlag(cvfCycL)){HumanOk_GenlsPerClassMom->Add(Genls);}
303        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasGenlsPerClassMom->Add(Isas+Genls);}
304      }
305    }
306    CommentLenMom->Def();
307    StrsLenMom->Def();
308    HumanOk_StrsLenMom->Def();
309    ClassesPerStrMom->Def();
310    StrsPerClassMom->Def();
311    HumanOk_StrsPerClassMom->Def();
312    IsasPerClassMom->Def();
313    HumanOk_IsasPerClassMom->Def();
314    GenlsPerClassMom->Def();
315    HumanOk_GenlsPerClassMom->Def();
316    IsasGenlsPerClassMom->Def();
317    HumanOk_IsasGenlsPerClassMom->Def();
318    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
319    fprintf(fOut, "CommentLen: %s\n", CommentLenMom->GetStr().CStr());
320    fprintf(fOut, "StrsLen: %s\n", StrsLenMom->GetStr().CStr());
321    fprintf(fOut, "HumanOk_StrsLen: %s\n", HumanOk_StrsLenMom->GetStr().CStr());
322    fprintf(fOut, "ClassesPerStr: %s\n", ClassesPerStrMom->GetStr().CStr());
323    fprintf(fOut, "StrsPerClass: %s\n", StrsPerClassMom->GetStr().CStr());
324    fprintf(fOut, "HumanOk_StrsPerClass: %s\n", HumanOk_StrsPerClassMom->GetStr().CStr());
325    fprintf(fOut, "IsasPerClass: %s\n", IsasPerClassMom->GetStr().CStr());
326    fprintf(fOut, "HumanOk_IsasPerClass: %s\n", HumanOk_IsasPerClassMom->GetStr().CStr());
327    fprintf(fOut, "GenlsPerClass: %s\n", GenlsPerClassMom->GetStr().CStr());
328    fprintf(fOut, "HumanOk_GenlsPerClass: %s\n", HumanOk_GenlsPerClassMom->GetStr().CStr());
329    fprintf(fOut, "IsasGenlsPerClass: %s\n", IsasGenlsPerClassMom->GetStr().CStr());
330    fprintf(fOut, "HumanOk_IsasGenlsPerClass: %s\n", HumanOk_IsasGenlsPerClassMom->GetStr().CStr());
331    fprintf(fOut, "Classes: %d\n", Classes);
332    fprintf(fOut, "HumanOk_Classes: %d\n", HumanOk_Classes);
333    fprintf(fOut, "Comments: %d\n", Comments);
334    fprintf(fOut, "HumanOk_Comments: %d\n", HumanOk_Comments);
335    fprintf(fOut, "End");}
336  }
337  PCycBs TCycBs::LoadCycXmlDump(const TStr& FPath){
338    TStr NrFPath=TStr::GetNrFPath(FPath);
339    TStr CycLexiconFNm=NrFPath+"lexicon-dump.xml";
340    TStr CycTaxonomyFNm=NrFPath+"taxonomy-dump.xml";
341    TStr CycRelevanceFNm=NrFPath+"relevance-dump.xml";
342    TStr CycKBaseFNm=NrFPath+"kb-dump.xml";                                                 
343    PCycBs CycBs=TCycBs::New();
344    {printf("Processing Lexicon %s ...\n", CycLexiconFNm.CStr());
345    PSIn CycLexiconSIn=TFIn::New(CycLexiconFNm);
346    PXmlDoc XmlDoc; int XmlDocs=0;
347    TStr PrevCycWStr; TStr PrevCycLStr;
348    forever{
349      XmlDocs++; if (XmlDocs%1000==0){printf("%d Docs\r", XmlDocs);}
350      XmlDoc=TXmlDoc::LoadTxt(CycLexiconSIn);
351      if (!XmlDoc->IsOk()){
352        printf("%s - %s\n", PrevCycWStr.CStr(), PrevCycLStr.CStr());
353        Fail;
354      }
355      PXmlTok TopTok=XmlDoc->GetTok();
356      if (TopTok->IsTag("end")){break;}
357      IAssert(TopTok->IsTag("word"));
358      TStr CycWStr=TopTok->GetArgVal("string");
359      TStr CycLStr=TopTok->GetArgVal("cycl");
360      PrevCycWStr=CycWStr; PrevCycLStr;
361      CycBs->AddEdge(CycLStr, "#$nameString", CycWStr);
362      CycBs->AddEdge(CycWStr, "~#$nameString", CycLStr);
363    }
364    printf("%d Docs\nDone.\n", XmlDocs);}
365    {printf("Processing Taxonomy %s ...\n", CycTaxonomyFNm.CStr());
366    PSIn CycTaxonomySIn=TFIn::New(CycTaxonomyFNm);
367    PXmlDoc XmlDoc; int XmlDocs=0;
368    TStr PrevSrcCycLStr;
369    forever{
370      XmlDocs++;
371      if (XmlDocs%1000==0){
372        printf("%d Docs\r", XmlDocs);}
373      XmlDoc=TXmlDoc::LoadTxt(CycTaxonomySIn);
374      if (!XmlDoc->IsOk()){
375        printf("%s\n", PrevSrcCycLStr.CStr());
376        Fail;
377      }
378      PXmlTok TopTok=XmlDoc->GetTok();
379      if (TopTok->IsTag("end")){break;}
380      IAssert(TopTok->IsTag("term"));
381      TStr SrcCycLStr=TopTok->GetArgVal("cycl");
382      PrevSrcCycLStr=SrcCycLStr;
383      for (int SubTokN=0; SubTokN<TopTok->GetSubToks(); SubTokN++){
384        PXmlTok SubTok=TopTok->GetSubTok(SubTokN);
385        TStr DstCycLStr=SubTok->GetTagNm();
386        if (SubTok->IsTag("isa")){
387          DstCycLStr=SubTok->GetArgVal("value");
388          CycBs->AddEdge(SrcCycLStr, "#$isa", DstCycLStr);
389          CycBs->AddEdge(DstCycLStr, "~#$isa", SrcCycLStr);
390        } else
<span onclick='openModal()' class='match'>391        if (SubTok->IsTag("genl")){
392          DstCycLStr=SubTok->GetArgVal("value");
393          CycBs->AddEdge(SrcCycLStr, "#$genls", DstCycLStr);
394          CycBs->AddEdge(DstCycLStr, "~#$genls", SrcCycLStr);
395        } else {
396          Fail;
397        }
398      }
399    }
400    printf("%d Docs\nDone.\n", XmlDocs);}
</span>401    {printf("Processing Relevance %s ...\n", CycRelevanceFNm.CStr());
402    PSIn CycRelevanceSIn=TFIn::New(CycRelevanceFNm);
403    PXmlDoc XmlDoc; int XmlDocs=0;
404    TStr PrevCycStr;
405    forever{
406      XmlDocs++;
407      if (XmlDocs%1000==0){
408        printf("%d Docs\r", XmlDocs);}
409      XmlDoc=TXmlDoc::LoadTxt(CycRelevanceSIn);
410      if (!XmlDoc->IsOk()){
411        printf("%s\n", PrevCycStr.CStr());
412        Fail;
413      }
414      PXmlTok TopTok=XmlDoc->GetTok();
415      if (TopTok->IsTag("end")){break;}
416      IAssert(TopTok->IsTag("term"));
417      TStr CycStr=TopTok->GetArgVal("cyc");
418      PrevCycStr=CycStr;
419      if (CycBs->IsVNm(CycStr)){
420        if (TopTok->GetArgVal("thcl")=="T"){
421          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanRelevant, true);}
422        if (TopTok->GetArgVal("irrel")=="T"){
423          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanIrrelevant, true);}
424        if (TopTok->GetArgVal("clarifying")=="T"){
425          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanClarifying, true);}
426        if ((TopTok->GetArgVal("thcl")=="T")||(TopTok->GetArgVal("clarifying")=="T")){
427          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanOk, true);}
428      } else {
429      }
430    }
431    printf("%d Docs\nDone.\n", XmlDocs);}
432    {printf("Processing KBase %s ...\n", CycKBaseFNm.CStr());
433    PSIn CycKBaseSIn=TFIn::New(CycKBaseFNm);
434    PXmlDoc XmlDoc; int XmlDocs=0;
435    TStr PrevCycLStr; TStrV PrevArgCycLStrV;
436    TStrIntH HdCycLToFq;
437    forever{
438      XmlDocs++;
439      if (XmlDocs%1000==0){
440        printf("%d Docs\r", XmlDocs);}
441      XmlDoc=TXmlDoc::LoadTxt(CycKBaseSIn);
442      if (!XmlDoc->IsOk()){
443        printf("%s\n", PrevCycLStr.CStr());
444        for (int ArgN=0; ArgN<PrevArgCycLStrV.Len(); ArgN++){
445          printf(" [%s]", PrevArgCycLStrV[ArgN].CStr());}
446        printf("\n");
447        Fail;
448      }
449      PXmlTok TopTok=XmlDoc->GetTok();
450      if (TopTok->IsTag("end")){break;}
451      IAssert(TopTok->IsTag("sentence"));
452      TStr CycLStr=TopTok->GetArgVal("cycl");
453      TXmlTokV ArgXmlTokV; XmlDoc->GetTagTokV("sentence|arg", ArgXmlTokV);
454      TStrV ArgCycLStrV;
455      for (int ArgN=0; ArgN<ArgXmlTokV.Len(); ArgN++){
456        PXmlTok Tok=ArgXmlTokV[ArgN];
457        IAssert(Tok->IsTag("arg"));
458        if (Tok->IsArg("cycl")){
459          TStr ArgCycLStr=Tok->GetArgVal("cycl");
460          ArgCycLStrV.Add(ArgCycLStr);
461        } else {
462          ArgCycLStrV.Add("Empty");
463        }
464      }
465      PrevCycLStr=CycLStr;
466      PrevArgCycLStrV=ArgCycLStrV;
467      if (ArgCycLStrV.Len()>0){
468        HdCycLToFq.AddDat(ArgCycLStrV[0]+" - "+TInt::GetStr(ArgCycLStrV.Len()-1))++;}
469      if (ArgCycLStrV.Len()==3){
470        TStr PredNm=ArgCycLStrV[0];
471        if ((PredNm!="#$isa")&&(PredNm!="#$termOfUnit")&&(PredNm!="#$genls")){
472          TStr BackLinkPredNm=TStr("~")+PredNm;
473          TStr Arg1=ArgCycLStrV[1];
474          TStr Arg2=ArgCycLStrV[2];
475          CycBs->AddEdge(Arg1, PredNm, Arg2);
476          CycBs->AddEdge(Arg2, BackLinkPredNm, Arg1);
477        }
478      }
479    }
480    {TFOut CycLSOut("CycKB-CycLFq.Stat.Txt"); FILE* fCycL=CycLSOut.GetFileId();
481    TIntStrPrV FqCycLStrPrV; HdCycLToFq.GetDatKeyPrV(FqCycLStrPrV); 
482    FqCycLStrPrV.Sort(false);
483    for (int CycLN=0; CycLN<FqCycLStrPrV.Len(); CycLN++){
484      fprintf(fCycL, "%6d. %s\n", 1+FqCycLStrPrV[CycLN].Val1, FqCycLStrPrV[CycLN].Val2.CStr());
485    }}
486    printf("%d Docs\nDone.\n", XmlDocs);}
487    return CycBs;
488  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</h3>
            <pre><code>1  #include "lsionto.h"
2  void TOntoConcept::GenMedoid(PBowDocWgtBs BowDocWgtBs) {
3      TFltIntKdV WgtDIdV;
4      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
5          const int DId = DIdV[DIdN];
6          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
7          const double Wgt = TBowSim::GetCosSim(ConceptSpV, DocSpV);
8          WgtDIdV.Add(TFltIntKd(Wgt, DId));
9      }
10      const int TopN = 33;
11      TFltIntKdV TopWgtDIdV;
12      if (WgtDIdV.Len() > TopN) {
13          TFltIntKdHp::GetTopV(htMin, TopN, WgtDIdV, TopWgtDIdV, true);
14      } else { 
15          TopWgtDIdV = WgtDIdV; TopWgtDIdV.Sort(false);
16      }
17      GetSwitchedKdV<TFlt, TInt>(TopWgtDIdV, MedoidDIdWgtV);
18  }
19  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
20          const int _Id, const TIntV& _DIdV): Id(_Id), DIdV(_DIdV)  { 
21      ResetCentroidSpV(BowDocWgtBs);
22      CptNm = GetKeyWdStr(BowDocBs, 3, 1.0, ", ", false, false);
23      SvmKeyWdSpV = TBowSpV::New();
24      if (!DIdV.IsSorted()) { DIdV.Sort(); }
25      Compactness = Clarity = -1.0;
26  };
27  TOntoConcept::TOntoConcept(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, const int _Id, 
28          const TStr& _CptNm, const TIntV& _DIdV): Id(_Id), CptNm(_CptNm), DIdV(_DIdV) { 
29      ResetCentroidSpV(BowDocWgtBs);
30      SvmKeyWdSpV = TBowSpV::New();
31      if (!DIdV.IsSorted()) { DIdV.Sort(); }
32      Compactness = Clarity = -1.0;
33  };
34  void TOntoConcept::ResetCentroidSpV(PBowDocWgtBs BowDocWgtBs) {
35      ConceptSpV = TBowClust::GetConceptSpV(BowDocWgtBs, NULL, DIdV);
36      GenMedoid(BowDocWgtBs);
37      IsValid = true;
38  }
39  void TOntoConcept::SetDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& _DIdV) {
40      if (Id == 0) return; 
41      DIdV = _DIdV; if (!DIdV.IsSorted()) { DIdV.Sort(); }
42      ResetCentroidSpV(BowDocWgtBs);
43  }
44  void TOntoConcept::AddDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
45      DIdV.Union(SubDIdV);
46      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
47      else { IsValid = false; }
48  }
49  void TOntoConcept::AddDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
50      if (DIdV.SearchBin(DId) == -1) { DIdV.AddSorted(DId); }
51      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
52      else { IsValid = false; }
53  }
54  void TOntoConcept::DelDIdV(PBowDocWgtBs BowDocWgtBs, const TIntV& SubDIdV) {
55      if (Id == 0) return; 
56      DIdV.Diff(SubDIdV);
57      if (!BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
58      else { IsValid = false; }
59  }
60  bool TOntoConcept::DelDId(PBowDocWgtBs BowDocWgtBs, const int& DId) {
61      if (Id == 0) return false; 
62      bool DocDeletedP = DIdV.DelIfIn(DId);
63      if (DocDeletedP && !BowDocWgtBs.Empty()) { ResetCentroidSpV(BowDocWgtBs); }
64      else { IsValid = false; }
65      return DocDeletedP;
66  }
67  TStr TOntoConcept::GetKeyWdStr(PBowDocBs BowDocBs, const int& TopWords, 
68          const double& TopWordsWgtPrc, const TStr& SepStr, 
69          const bool& ShowWeights, const bool& UseMedoidP) const { 
70      if (!UseMedoidP) {
71          return ConceptSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
72      } else {
73          if (MedoidDIdWgtV.Empty()) { return "Empty concept"; }
74          TStr KeyWdStr = BowDocBs->GetDocNm(MedoidDIdWgtV[0].Key);
75          const int DIds = TInt::GetMn(TopWords, MedoidDIdWgtV.Len());
76          for (int DIdN = 1; DIdN < DIds; DIdN++) {
77              const int DId = MedoidDIdWgtV[DIdN].Key;
78              TStr DocNm = BowDocBs->GetDocNm(DId);
79              KeyWdStr += SepStr; KeyWdStr += DocNm;
80          }
81          return KeyWdStr;
82      }
83  }
84  TStr TOntoConcept::GetSvmKeyWdStr(PBowDocBs BowDocBs, const int& TopWords,
85          const double& TopWordsWgtPrc, const TStr& SepStr, const bool& ShowWeights) const {
86      return SvmKeyWdSpV->GetStr(BowDocBs, TopWords, TopWordsWgtPrc, SepStr, ShowWeights); 
87  }
88  void TOntoConcept::CalcCptMd(PBowDocBs BowDocBs, const TIntV& ContextDIdV,
89          const double& SvmC, const double& SvmJ, const int& SvmTime) {
90      if (Id == 0) return;
91      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, 
92          bwwtLogDFNrmTFIDF, 0.0, 0, ContextDIdV);
93      PSVMTrainSet TrainSet = TBowDocBs2TrainSet::NewBowAllCatV(
94          BowDocWgtBs, ContextDIdV, DIdV);
95      CptMd = TSVMModel::NewClsLinear(TrainSet, SvmC, SvmJ, TIntV(), 
96          TSVMLearnParam::Lin(SvmTime));
97      CptMd->MakeProb(TrainSet);
98  }
99  TStr TOntoRltType::SubCptOfRltStr = "SubConcept-Of";
100  TStr TOntoRltType::SimilarRltStr = "Similar";
101  void TOntoAlg::SuggestKMeans(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
102          const TIntV& DIdV, const int& _NewConceptN, PUniqueId UniqueId, 
103          TOntoConceptV& NewConceptV) {
104      const int NewConceptN = TInt::GetMn(DIdV.Len(), _NewConceptN);
105      NewConceptV.Clr(); if (NewConceptN < 2) return;
106      TIntV FullDIdV; BowDocWgtBs->GetDIdV(FullDIdV);
107      BowDocWgtBs->SetDIdV(DIdV);
108      PBowSim BowSim = TBowSim::New(bstCos);
109      PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
110          TNotify::StdNotify, BowDocWgtBs, BowDocBs, 
111          BowSim, TRnd(1), NewConceptN, 1, 10, 1);
112      BowDocWgtBs->SetDIdV(FullDIdV);
113      IAssert(BowDocPart->GetClusts() == NewConceptN);
114      NewConceptV.Gen(NewConceptN, 0);
115      for (int ClustC = 0; ClustC < NewConceptN; ClustC++) {
116          PBowDocPartClust Clust = BowDocPart->GetClust(ClustC);
117          TIntV CptDIdV; Clust->GetDIdV(CptDIdV);
118          NewConceptV.Add(TOntoConcept::New(BowDocBs,
119              BowDocWgtBs, UniqueId->GetNextId(), CptDIdV));
120      }
121  }
122  void TOntoAlg::SuggestCat(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs,
123          const TIntV& DIdV, PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
124      TIntIntVH CIdDIdVH;
125      for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
126          const int DId = DIdV[DocN];
127          const int DocCIds = BowDocBs->GetDocCIds(DId);
128          for (int DocCIdN = 0; DocCIdN < DocCIds; DocCIdN++) {
129              const int DocCId = BowDocBs->GetDocCId(DId, DocCIdN);
130              if (CIdDIdVH.IsKey(DocCId)) {
131                  CIdDIdVH.GetDat(DocCId).Add(DId);
132              } else {
133                  CIdDIdVH.AddDat(DocCId, TIntV::GetV(DId));
134              }
135          }
136      }
137      TIntKdV DocsKeyIdV(CIdDIdVH.Len(), 0);
138      int KeyId = CIdDIdVH.FFirstKeyId();
139      while (CIdDIdVH.FNextKeyId(KeyId)) {
140          const int Docs = CIdDIdVH[KeyId].Len();
141          DocsKeyIdV.Add(TIntKd(Docs, KeyId));
142      }
143      DocsKeyIdV.Sort(false);
144      NewConceptV.Gen(CIdDIdVH.Len(), 0);
145      for (int CptN = 0; CptN < DocsKeyIdV.Len(); CptN++) {
146          const int CptKeyId = DocsKeyIdV[CptN].Dat;
147          const TIntV& CptDIdV = CIdDIdVH[CptKeyId];
148          TStr CptNm = BowDocBs->GetCatNm(CIdDIdVH.GetKey(CptKeyId));
149          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
150              UniqueId->GetNextId(), CptNm, CptDIdV));
151      }
152  }
153  void TOntoAlg::SuggestLwOntoCfier(PBowDocBs BowDocBs, PBowDocWgtBs BowDocWgtBs, 
154          const TIntV& DIdV, PLwOntoCfier LwOntoCfier, const int& _NewConcepts, 
155          PUniqueId UniqueId, TOntoConceptV& NewConceptV) {
156      TIntH TermIdFqH; TIntIntVH TermIdDIdVH;
157      for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
158          const int DId = DIdV[DIdN];
159          TStr DocStr = BowDocBs->GetDocStr(DId);
160          TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
161          LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
162          if (!SimTermIdPrV.Empty()) { 
163              const int TermId = SimTermIdPrV[0].Val2;
164              if (TermIdFqH.IsKey(TermId)) { 
165                  TermIdFqH(TermId)++; 
166                  TermIdDIdVH(TermId).Add(DId);
167              } else { 
168                  TermIdFqH.AddDat(TermId, 1); 
169                  TermIdDIdVH.AddDat(TermId, TIntV::GetV(DId));
170              }
171          }
172      }
173      TIntPrV TermFqIdV; TermIdFqH.GetDatKeyPrV(TermFqIdV); TermFqIdV.Sort(false);
174      const int NewConcepts = TInt::GetMn(_NewConcepts, TermFqIdV.Len());
175      NewConceptV.Gen(NewConcepts, 0);
176      PLwTermBs TermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
177      for (int NewConceptN = 0; NewConceptN < NewConcepts; NewConceptN++) {
178          const int TermId = TermFqIdV[NewConceptN].Val2;
179          const TIntV& CptDIdV = TermIdDIdVH(TermId);
180          TStr TermNm = TermBs->GetTerm(TermId)->GetTermNm();
181          NewConceptV.Add(TOntoConcept::New(BowDocBs, BowDocWgtBs, 
182              UniqueId->GetNextId(), TermNm, CptDIdV));
183      }
184  }
185  TStr TOntoExportPTO::GetUri(const int& Id, const TStr& Nm) {
186      TChA CleanChA; bool ToUc = true;
187      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
188          char Ch = Nm[ChN];
189          if (TCh::IsAlpha(Ch)) { 
190              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
191              CleanChA += Ch; 
192          } else { ToUc = true; }
193      }
194      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
195  }
196  void TOntoExportPTO::StartExport() {
197      SOut->PutStrLn("<?xml version='1.0' encoding='UTF-8'?>");
198      SOut->PutStrLn("");
199      SOut->PutStrLn("<!DOCTYPE rdf:RDF [");
200      SOut->PutStrLn("    <!ENTITY rdf  'http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#'>");
201      SOut->PutStrLn("    <!ENTITY rdfs 'http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#'>");
202      SOut->PutStrLn("    <!ENTITY owl  'http:&bsol;&bsol;www.w3.org/2002/07/owl#'>");
203      SOut->PutStrLn("    <!ENTITY xsd  'http:&bsol;&bsol;www.w3.org/2001/XMLSchema#' >");
204      SOut->PutStrLn("    <!ENTITY ptop 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont#'>");
205      SOut->PutStrLn("    <!ENTITY psys 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>");
206      SOut->PutStrLn("    <!ENTITY protonkm  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm#'>");
207      if (DigLibP) { SOut->PutStrLn("    <!ENTITY diglib 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>"); }
208      SOut->PutStrLn("    <!ENTITY jsikm  'http:&bsol;&bsol;kt.ijs.si/blazf/jsikm#'>");
209      SOut->PutStrLn("]>");
210      SOut->PutStrLn("");
211      SOut->PutStrLn("<rdf:RDF");
212      SOut->PutStrLn("    xmlns:owl=\"&owl;\"");
213      SOut->PutStrLn("    xmlns:rdf=\"&rdf;\"");
214      SOut->PutStrLn("    xmlns:rdfs=\"&rdfs;\"");
215      SOut->PutStrLn("    xmlns:psys=\"&psys;\"");
216      SOut->PutStrLn("    xmlns:ptop=\"&ptop;\"");
217      SOut->PutStrLn("    xmlns:protonkm=\"&protonkm;\"");
218      SOut->PutStrLn("    xmlns=\"&protonkm;\"");
219      if (DigLibP) { SOut->PutStrLn("    xmlns:diglib=\"&diglib;\""); }
220      SOut->PutStrLn("    xmlns:jsikm=\"&jsikm;\"");
221      SOut->PutStrLn("    xml:base=\"&protonkm;\""); 
222      SOut->PutStrLn(">");
223      SOut->PutStrLn("");
224      SOut->PutStrLn("<owl:Ontology rdf:about=\"\">");
225      SOut->PutStrLn("  <rdfs:comment>PROTON Topics (from Inspec Thesaurus) ordered by algorithm X</rdfs:comment>");
226      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons\"/>");
227      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont\"/>");
228      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu\"/>");
229      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm\"/>");
230      if (DigLibP) { SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>"); }
231      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>");
232      SOut->PutStrLn("  <owl:versionInfo>\"0.1\"</owl:versionInfo>");
233      SOut->PutStrLn("</owl:Ontology>");
234      SOut->PutStrLn("");
235  }
236  void TOntoExportPTO::EndExport() {
237      SOut->PutStrLn("</rdf:RDF>");
238      SOut->Flush();
239  }
240  void TOntoExportPTO::PutCpt(const int& CptId, const TStr CptNm, 
241          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, const TIntV& DIdV, 
242          PBowDocBs BowDocBs, PBowSpV KeyWdSpV, PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
243      SOut->PutStrLn("<ptop:Topic rdf:about=\"#Cpt" + GetUri(CptId, CptNm) + "\">");
244      SOut->PutStrLn("  <psys:description>" + CptNm + "</psys:description>");
245      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
246          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
247          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
248          SOut->PutStrLn("  <ptop:subTopicOf rdf:resource=\"#Cpt" + 
249              GetUri(SuperCptId, SuperCptNm) + "\" />");
250      }
251      if (DigLibP) {
252          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
253              const int DId = DIdV[DIdN];
254              TStr DNm = BowDocBs->GetDocNm(DId);
255              SOut->PutStrLn("  <diglib:hasArticle rdf:resource=\"#Doc" + 
256                  GetUri(DId, DNm) + "\" />");
257          }
258      }
259      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenClassProperties rdf:resource=\"#CLS_PROP_%d\" />", CptId));
260      SOut->PutStrLn("</ptop:Topic>");
261      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenClassProperties rdf:about=\"#CLS_PROP_%d\">", CptId));
262      TStr KeyWdStr = KeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
263      SOut->PutStrLn("  <jsikm:hasCentroidKeywords>" + KeyWdStr + "</jsikm:hasCentroidKeywords>");
264      TStr SvmKeyWdStr = SvmKeyWdSpV->GetStr(BowDocBs, 10, 1.0, ", ", false, true);
265      SOut->PutStrLn("  <jsikm:hasSVMKeywords>" + SvmKeyWdStr + "</jsikm:hasSVMKeywords>");
266      SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
267      SOut->PutStrLn("");
268  }
269  void TOntoExportPTO::PutDoc(const int& DId, const TStr& DocTitle, 
270          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
271      SOut->PutStrLn("<ptop:Document rdf:about=\"#Doc" + GetUri(DId, DocTitle) + "\">");
272      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
273          const int CptId = CptIdNmV[CptIdN].Val1;
274          TStr CptNm = CptIdNmV[CptIdN].Val2;
275          SOut->PutStrLn("  <ptop:hasSubject rdf:resource=\"#Cpt" + 
276              GetUri(CptId, CptNm) + "\" />");
277      }
278      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
279      CleanDocAbstract.ChangeChAll('\n', ' '); CleanDocAbstract.ChangeChAll('\n', ' ');
280      SOut->PutStrLn(TStr::Fmt("  <ptop:documentAbstract>%s</ptop:documentAbstract>", CleanDocAbstract.CStr()));
281      SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenInstanceProperties rdf:resource=\"#INST_PROP_%d\" />", DId));
282      SOut->PutStrLn("</ptop:Document>");
283      TStr ShortBowFNm = BowFNmStr.GetFMid() + BowFNmStr.GetFExt();
284      SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenInstanceProperties rdf:about=\"#INST_PROP_%d\">", DId));
285      SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
286      SOut->PutStrLn("</jsikm:OntoGenInstanceProperties>");
287      SOut->PutStrLn("");
288  }
289  void TOntoExportProlog::StartExport() {
290      SOut->PutStrLn("% OntoGen export in Prolog.");
291  }
292  void TOntoExportProlog::EndExport() {
293      SOut->Flush();
294  }
295  void TOntoExportProlog::PutCpt(const int& CptId, const TStr CptNm, 
296          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
297          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
298          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
299      SOut->PutStrLn(TStr::Fmt("class( %s, label, '%s' ).", 
300          GetCptLabel(CptId).CStr(), CptNm.CStr()));
301      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
302          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
303          SOut->PutStrLn(TStr::Fmt("subClassOf( %s, %s ).", 
304              GetCptLabel(CptId).CStr(), GetCptLabel(SuperCptId).CStr()));
305      }
306  }
307  void TOntoExportProlog::PutDoc(const int& DId, const TStr& DocTitle, 
308          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
309      TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
310      CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
311      TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
312      CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
313      CleanDocAbstract.DelChAll('\r');
314      SOut->PutStrLn(TStr::Fmt("instance( %s, label, '%s' ).", 
315          GetInstLabel(DId).CStr(), CleanDocTitle.CStr()));
316      SOut->PutStrLn(TStr::Fmt("instance( %s, text, '%s' ).", 
317          GetInstLabel(DId).CStr(), CleanDocAbstract.CStr()));
318      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
319          const int CptId = CptIdNmV[CptIdN].Val1;
320          SOut->PutStrLn(TStr::Fmt("instanceOf( %s, %s ).", 
321              GetInstLabel(DId).CStr(), GetCptLabel(CptId).CStr()));
322      }
323  }
324  TStr TOntoExportOWL::GetUri(const int& Id, const TStr& Nm) {
325      TChA CleanChA; bool ToUc = true;
326      for (int ChN = 0; ChN < Nm.Len(); ChN++) {
327          char Ch = Nm[ChN];
328          if (TCh::IsAlpha(Ch)) { 
329              if (ToUc) { Ch = TCh::GetUc(Ch); ToUc = false;}
330              CleanChA += Ch; 
331          } else { ToUc = true; }
332      }
333      return TInt::GetStr(Id) + "_" + TStr(CleanChA);
334  }
335  void TOntoExportOWL::StartExport() {
336      SOut->PutStrLn("<?xml version=\"1.0\"?>");
337      SOut->PutStrLn("<rdf:RDF");
338      SOut->PutStrLn("    xmlns:rdf=\"http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#\"");
339      SOut->PutStrLn("    xmlns:xsd=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema#\"");
340      SOut->PutStrLn("    xmlns:rdfs=\"http:&bsol;&bsol;www.w3.org/2000/01/rdf-schema#\"");
341      SOut->PutStrLn("    xmlns:owl=\"http:&bsol;&bsol;www.w3.org/2002/07/owl#\"");
342      SOut->PutStrLn("    xmlns=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl#\"");
343      SOut->PutStrLn("    xml:base=\"http:&bsol;&bsol;www.owl-ontologies.com/Ontology1150050933.owl\">");
344      SOut->PutStrLn("");
345      SOut->PutStrLn("<owl:Ontology rdf:about=\"OntoGen OWL export\"/>");
346      SOut->PutStrLn("");
347  }
348  void TOntoExportOWL::EndExport() {
349      SOut->PutStrLn("");
350      SOut->PutStrLn("</rdf:RDF>");
351      SOut->Flush();
352  }
353  void TOntoExportOWL::PutCpt(const int& CptId, const TStr CptNm, 
354          const TIntStrPrV& SubCptIdNmV, const TIntStrPrV& SuperCptIdNmV, 
355          const TIntV& DIdV, PBowDocBs BowDocBs, PBowSpV KeyWdSpV, 
356          PBowSpV SvmKeyWdSpV, PBowSpV SvmNormalSpV) {
357      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(CptId, CptNm) + "\">");
358      SOut->PutStrLn("  <rdfs:label>" + CptNm + "</rdfs:label>");
359      for (int SuperCptN = 0; SuperCptN < SuperCptIdNmV.Len(); SuperCptN++) {
360          const int SuperCptId = SuperCptIdNmV[SuperCptN].Val1;
361          TStr SuperCptNm = SuperCptIdNmV[SuperCptN].Val2;
362          SOut->PutStrLn("  <rdfs:subClassOf rdf:resource=\"#Cpt" + 
363              GetUri(SuperCptId, SuperCptNm) + "\"/>");
364      }
365      SOut->PutStrLn("</owl:Class>");
366      SOut->PutStrLn("");
367  }
368  void TOntoExportOWL::PutDoc(const int& DId, const TStr& DocTitle, 
369          const TStr& DocAbstract, const TIntStrPrV& CptIdNmV) {
370      if (!StoreDocsP) { return; }
371      for (int CptIdN = 0; CptIdN < CptIdNmV.Len(); CptIdN++) {
372          const int CptId = CptIdNmV[CptIdN].Val1;
373          TStr CptNm = CptIdNmV[CptIdN].Val2;
374          SOut->PutStrLn("<Cpt" + GetUri(CptId, CptNm) + " rdf:ID=\"Doc" + 
375              GetUri(DId, DocTitle) + "\">");
376          if (CptIdN == 0) {
377              TStr CleanDocTitle = DocTitle; CleanDocTitle.DelChAll('\'');
378              CleanDocTitle.DelChAll('\n'); CleanDocTitle.DelChAll('\r');
379              SOut->PutStrLn("  <rdfs:label>" + CleanDocTitle + "</rdfs:label>");
380              if (StoreAbstractsP) {
381                  TStr CleanDocAbstract = TXmlDoc::GetXmlStr(DocAbstract);
382                  CleanDocAbstract.DelChAll('\''); CleanDocAbstract.DelChAll('\n'); 
383                  CleanDocAbstract.DelChAll('\r');
384                  SOut->PutStrLn("  <rdfs:comment>" + CleanDocAbstract + "</rdfs:label>");
385              }
386          }
387          SOut->PutStrLn("</Cpt" + GetUri(CptId, CptNm) + ">");
388      }
389      SOut->PutStrLn("");
390  }
391  void TOntoExportOWL::PutRltType(const TStr& RltNm, const bool& DirectedP,
392          const bool& TransitiveP) {
393      SOut->PutStrLn("<owl:ObjectProperty rdf:ID=\"" + RltNm + "\"/>");
394      SOut->PutStrLn("");    
395  }
396  void TOntoExportOWL::PutRlt(const TStr& RltNm, const int& SrcCptId, 
397          const TStr SrcCptNm, const int& DstCptId, const TStr DstCptNm) {
398      SOut->PutStrLn("<owl:Class rdf:ID=\"Cpt" + GetUri(SrcCptId, SrcCptNm) + "\">");
399      SOut->PutStrLn("  <rdfs:subClassOf><owl:Restriction>");
400      SOut->PutStrLn("    <owl:onProperty rdf:resource=\"#" + RltNm + "\"/>");
401      SOut->PutStrLn("    <owl:someValuesFrom>");
402      SOut->PutStrLn("      <owl:Class rdf:ID=\"Cpt" + GetUri(DstCptId, DstCptNm) + "\"/>");
403      SOut->PutStrLn("    </owl:someValuesFrom>");
404      SOut->PutStrLn("  </owl:Restriction></rdfs:subClassOf>");
405      SOut->PutStrLn("</owl:Class>");
406      SOut->PutStrLn("");    
407  }
408  TOntology::TOntology(PBowDocBs _BowDocBs, PBowDocWgtBs _BowDocWgtBs, 
409      const TBowSimType& BowSimType): BowDocBs(_BowDocBs), 
410          BowDocWgtBs(_BowDocWgtBs) {
411      BowSim = TBowSim::New(BowSimType);
412      OntoGraph = TGGraph::New();
413      UniqueId = TUniqueId::New(0);
414      GenerateEmptyOnto();
415  }
416  void TOntology::GenerateEmptyOnto() {
417      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
418      POntoConcept RootCpt = TOntoConcept::New(BowDocBs, 
419          BowDocWgtBs, UniqueId->GetNextId(), AllDIdV);
420      RootCpt->SetName("root");
421      AddConcept(RootCpt, -1);
422      OntoGraph->GetPp()->AddPpStr("BoldVNm", "", "root");
423      RltTypeV.Add(TOntoRltType(TOntoRltType::SubCptOfRltStr, true, true));
424      RltTypeV.Add(TOntoRltType(TOntoRltType::SimilarRltStr, false, false));
425  }
426  void TOntology::RefreshCptIdPosH() {
427      CptIdPosH.Clr();
428      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
429          const int CptId = ConceptV[CptC]->GetId();
430          IAssertR(!CptIdPosH.IsKey(CptId), "Concept ID not unique!");
431          CptIdPosH.AddDat(CptId, CptC);
432      }
433  }
434  void TOntology::ReconnectToRoot() {
435      for (int CptC = 0; CptC < ConceptV.Len(); CptC++) {
436          const int CptId = ConceptV[CptC]->GetId();
437          if (!IsRootCpt(CptId) && !HasSuperCpt(CptId)) {
438              AddRlt(CptId, 0, TOntoRltType::SubCptOfRltStr);
439          }
440      }
441  }
442  void TOntology::AddRltsFromList(TIntStrPrV& InRltV, 
443          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
444      for (int InEdN = 0; InEdN < InRltV.Len(); InEdN++) {
445          const int CptId1 = InRltV[InEdN].Val1;
446          TStr RltNm1 = InRltV[InEdN].Val2; Assert(IsRltDir(RltNm1));
447          for (int OutEdN = 0; OutEdN < OutRltV.Len(); OutEdN++) {
448              const int CptId2 = OutRltV[OutEdN].Val1;
449              TStr RltNm2 = OutRltV[OutEdN].Val2; Assert(IsRltDir(RltNm2));
450              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
451                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
452                  if (!IsRltTransitive(RltNm1)) continue;
453                  AddRlt(CptId1, CptId2, RltNm1);
454              }
455          }
456      }
457      for (int InEdN = 0; InEdN < UndirRltV.Len(); InEdN++) {
458          const int CptId1 = UndirRltV[InEdN].Val1;
459          TStr RltNm1 = UndirRltV[InEdN].Val2; Assert(!IsRltDir(RltNm1));
460          for (int OutEdN = 0; OutEdN < UndirRltV.Len(); OutEdN++) {
461              const int CptId2 = UndirRltV[OutEdN].Val1;
462              TStr RltNm2 = UndirRltV[OutEdN].Val2; Assert(!IsRltDir(RltNm2));
463              if (CptId1 != CptId2 && RltNm1 == RltNm2) {
464                  if (IsRlt(CptId1, CptId2, RltNm1)) continue;
465                  if (!IsRltTransitive(RltNm1)) continue;
466                  AddRlt(CptId1, CptId2, RltNm1);
467              }
468          }
469      }
470  }
471  void TOntology::AddSonDIdV(const int& CptId, TIntV& SonDIdV) {
472      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
473      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
474          const int SubCptId = SubCptIdV[SubCptIdN];
475          TIntV SubCptDIdV; GetCptDIdV(SubCptId, SubCptDIdV);
476          SonDIdV.Union(SubCptDIdV);
477          AddSonDIdV(SubCptId, SonDIdV);
478      }
479  }
480  void TOntology::CfyDIdR(const int& DId, const TIntV& CptIdV, TIntFltKdV& CfyResV) {
481      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
482          const int CptId = CptIdV[CptIdN];
483          POntoConcept Cpt = GetConcept(CptId);
484          if (Cpt->IsCptMd()) {
485              bool IsDocInCpt; double Prob;
486              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
487              if (IsDocInCpt) {
488                  CfyResV.Add(TIntFltKd(CptId, Prob));
489                  TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
490                  CfyDIdR(DId, SubCptIdV, CfyResV);
491              }
492          }
493      }
494  }
495  void TOntology::Export(POntoExport OntoExport) {
496      OntoExport->StartExport();
497      TIntV CptIdV; GetCptIdV(CptIdV);
498      TIntIntVH DIdCptIdVH;
499      for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
500          const int CptId = CptIdV[CptN];
501          TStr CptNm = TXmlDoc::GetXmlStr(GetCptName(CptId));
502          if (OntoExport->IsCptAlwaysSvm()) { ExtractKeywords(CptId); }
503          TIntStrPrV SubCptIdNmV;
504          if (OntoExport->IsCptSubCptLink()) {
505              TIntStrPrV CptInRltV; GetCptInRltV(CptId, CptInRltV);
506              for (int SubCptN = 0; SubCptN < CptInRltV.Len(); SubCptN++) {
507                  TStr RltNm = CptInRltV[SubCptN].Val2;
508                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
509                      const int SubCptId = CptInRltV[SubCptN].Val1;
510                      TStr SubCptNm = GetCptName(SubCptId);
511                      SubCptIdNmV.Add(TIntStrPr(SubCptId, SubCptNm));
512                  }
513              }
514          }
515          TIntStrPrV SuperCptIdNmV;
516          if (OntoExport->IsCptSuperCptLink()) {
517              TIntStrPrV CptOutRltV; GetCptOutRltV(CptId, CptOutRltV);
518              for (int SuperCptN = 0; SuperCptN < CptOutRltV.Len(); SuperCptN++) {
519                  TStr RltNm = CptOutRltV[SuperCptN].Val2;
520                  if (RltNm == TOntoRltType::SubCptOfRltStr) {
521                      const int SuperCptId = CptOutRltV[SuperCptN].Val1;
522                      TStr SuperCptNm = GetCptName(SuperCptId);
523                      SuperCptIdNmV.Add(TIntStrPr(SuperCptId, SuperCptNm));
524                  }
525              }
526          }
527          TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
528          for (int DocN = 0; DocN < CptDIdV.Len(); DocN++) {
529              const int DId = CptDIdV[DocN];
530              if (DIdCptIdVH.IsKey(DId)) {
531                  DIdCptIdVH.GetDat(DId).Add(CptId);
532              } else {
533                  DIdCptIdVH.AddDat(DId, TIntV::GetV(CptId));
534              }
535          }
536          if (!OntoExport->IsCptDocLink()) { CptDIdV.Clr(); }
537          OntoExport->PutCpt(CptId, CptNm, SubCptIdNmV, SuperCptIdNmV, 
538              CptDIdV, BowDocBs, GetConcept(CptId)->GetCentroidSpV(), 
539              GetConcept(CptId)->GetSvmSpV(), TBowSpV::New(-1));
540      }
541      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
542      for (int DocN = 0; DocN < AllDIdV.Len(); DocN++) {
543          const int DId = AllDIdV[DocN];
544          TStr DocTitle = BowDocBs->GetDocNm(DId);
545          TStr DocAbstract = BowDocBs->GetDocStr(DId);
546          TIntStrPrV CptIdNmV;
547          if (DIdCptIdVH.IsKey(DId) && OntoExport->IsDocCptLink()) {
548              TIntV& DocCptIdV = DIdCptIdVH.GetDat(DId);
549              for (int DocCptIdN = 0; DocCptIdN < DocCptIdV.Len(); DocCptIdN++) {
550                  const int CptId = DocCptIdV[DocCptIdN];
551                  TStr CptNm = GetCptName(CptId);
552                  CptIdNmV.Add(TIntStrPr(CptId, CptNm));
553              }
554          }
555          OntoExport->PutDoc(DId, DocTitle, DocAbstract, CptIdNmV);
556      }        
557      if (OntoExport->IsRlt()) {
558          const int RltTypes = GetRltTypes();
559          for (int RltTypeN = 0; RltTypeN < RltTypes; RltTypeN++) {
560              TStr RltTypeNm = GetRltTypeNm(RltTypeN);
561              if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
562                  OntoExport->PutRltType(RltTypeNm, 
563                      IsRltDir(RltTypeNm), IsRltTransitive(RltTypeNm));
564              }
565          }
566          for (int CptN = 0; CptN < CptIdV.Len(); CptN++) {
567              const int SrcCptId = CptIdV[CptN];
568              TStr SrcCptNm = GetCptName(SrcCptId);
569              TIntStrPrV CptOutRltV; GetCptOutRltV(SrcCptId, CptOutRltV);
570              for (int OutRltN = 0; OutRltN < CptOutRltV.Len(); OutRltN++) {
571                  const TStr& RltTypeNm = CptOutRltV[OutRltN].Val2;
572                  if (RltTypeNm != TOntoRltType::SubCptOfRltStr) {
573                      const int DstCptId = CptOutRltV[OutRltN].Val1;
574                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
575                          DstCptId, GetCptName(DstCptId));
576                  }
577              }
578              TIntStrPrV CptUndirRltV; GetCptUndirRltV(SrcCptId, CptUndirRltV);
579              for (int UndirRltN = 0; UndirRltN < CptUndirRltV.Len(); UndirRltN++) {
580                  const TStr& RltTypeNm = CptUndirRltV[UndirRltN].Val2;
581                  const int DstCptId = CptUndirRltV[UndirRltN].Val1;
582                  if (SrcCptId < DstCptId) {
583                      OntoExport->PutRlt(RltTypeNm, SrcCptId, SrcCptNm,
584                          DstCptId, GetCptName(DstCptId));
585                  }
586              }
587          }
588      }
589      OntoExport->EndExport();
590  }
591  void TOntology::GetCptIdV(TIntV& CptIdV) {
592      CptIdV.Gen(ConceptV.Len(), 0);
593      for (int CptIdN = 0; CptIdN < ConceptV.Len(); CptIdN++) {
594          CptIdV.Add(ConceptV[CptIdN]->GetId());
595      }
596      CptIdV.Sort();
597  }
598  void TOntology::SetCptName(const int& CptId, const TStr& NewName) {
599      GetConcept(CptId)->SetName(NewName);
600      OntoGraph->GetVrtx(CptId)->PutDNm(NewName);
601  }
602  void TOntology::SetCptDIdV(const int& CptId, const TIntV& _NewDIdV, const bool& PropagateP) {
603      if (PropagateP) {
604          TIntV NewDIdV = _NewDIdV;
605          if (!NewDIdV.IsSorted()) { NewDIdV.Sort(); }
606          TIntV OldDIdV; GetCptDIdV(CptId, OldDIdV);
607          TIntV BothDIdV; OldDIdV.Union(NewDIdV, BothDIdV);
608          TIntV AddDIdV; BothDIdV.Diff(OldDIdV, AddDIdV);
609          AddUpDIdV(CptId, AddDIdV);
610          TIntV DelDIdV; BothDIdV.Diff(NewDIdV, DelDIdV);
611          DelDownDIdV(CptId, DelDIdV);
612      } else {
613          GetConcept(CptId)->SetDIdV(BowDocWgtBs, _NewDIdV);
614      }
615  }
616  void TOntology::GetCptSimV(const int& CptId, TFltIntKdV& SimCptIdV) {
617      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
618      SimCptIdV.Gen(GetConcepts() - 1, 0);
619      for (int CptN = 0; CptN < GetConcepts(); CptN++) {
620          const int CptId2 = ConceptV[CptN]->GetId();
621          if (CptId != CptId2) {
622              PBowSpV CptSpV2 = ConceptV[CptN]->GetCentroidSpV();
623              SimCptIdV.Add(TFltIntKd(BowSim->GetSim(CptSpV, CptSpV2), CptId2));
624          }
625      }
626      SimCptIdV.Sort(false);
627  }
628  void TOntology::CalcCptMd(const int& CptId, const double& SvmC, 
629          const double& SvmJ, const int& SvmTime) {
630      if (IsRootCpt(CptId)) return;
631      TIntV ContextDIdV; BowDocBs->GetAllDIdV(ContextDIdV);
632      GetConcept(CptId)->CalcCptMd(BowDocBs, ContextDIdV, SvmC, SvmJ, SvmTime);
633  }
634  void TOntology::CfyDId(const int& DId, TIntFltKdV& CfyResV) {
635      const int CptIds = GetConcepts(); CfyResV.Gen(CptIds, 0);
636      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
637          const int CptId = GetCptId(CptIdN);
638          POntoConcept Cpt = GetConcept(CptId);
639          if (Cpt->IsCptMd()) {
640              bool IsDocInCpt; double Prob;
641              Cpt->CfyDocSpV(BowDocWgtBs->GetSpV(DId), IsDocInCpt, Prob);
642              if (IsDocInCpt) {
643                  CfyResV.Add(TIntFltKd(CptId, Prob));
644              } else {
645                  CfyResV.Add(TIntFltKd(CptId, Prob - 1.0));
646              }
647          } else if (IsRootCpt(CptId)) {
648              CfyResV.Add(TIntFltKd(CptId, 1.0));
649          } else {
650              CfyResV.Add(TIntFltKd(CptId, -1.0));
651          }
652      }
653      CfyResV.Sort();
654  }
655  void TOntology::IncludeLnDocs(const TStr& LnDocFNm, TIntV& NewDIdV) {
656      TBowFl::LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, true, -1, true);    
657      NewDIdV.Sort(); ReCalcWgtBs(); 
658      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
659  }
660  void TOntology::IncludeFolder(const TStr& FPath, TIntV& NewDIdV, const bool& RecurseDirP) {
661      TBowFl::LoadHtmlTxt(BowDocBs, FPath, NewDIdV, RecurseDirP, -1, true);
662      NewDIdV.Sort(); ReCalcWgtBs(); 
663      GetRootCpt()->AddDIdV(BowDocWgtBs, NewDIdV); 
664  }
665  void TOntology::AddDocToCptV(const int& DId, const TIntV& CptIdV, const bool& UpdateCentroidP) {
666      for (int CptIdN = 0; CptIdN < CptIdV.Len(); CptIdN++) {
667          const int CptId = CptIdV[CptIdN];
668          if (UpdateCentroidP) {
669              GetConcept(CptId)->AddDId(BowDocWgtBs, DId);
670          } else {
671              GetConcept(CptId)->AddDId(NULL, DId);
672          }
673      }
674  }
675  void TOntology::ResetAllCptKeyWd() {
676      const int CptIds = GetConcepts();
677      for (int CptIdN = 0; CptIdN < CptIds; CptIdN++) {
678          const int CptId = GetCptId(CptIdN);
679          if (!GetConcept(CptId)->IsCentroidValid()) {
680              GetConcept(CptId)->ResetCentroidSpV(BowDocWgtBs);
681          }
682      }
683  }
684  void TOntology::GetSubCptIdV(const int& CptId, TIntV& SubCptIdV) {
685      TIntStrPrV InRltV; GetCptInRltV(CptId, InRltV);
686      SubCptIdV.Gen(InRltV.Len(), 0);
687      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) {
688          if (InRltV[InRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
689              SubCptIdV.Add(InRltV[InRltN].Val1);
690          }
691      }
692      SubCptIdV.Sort();
693  }
694  void TOntology::GetSuperCptIdV(const int& CptId, TIntV& SuperCptIdV) {
695      TIntStrPrV OutRltV; GetCptOutRltV(CptId, OutRltV);
696      SuperCptIdV.Gen(OutRltV.Len(), 0);
697      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
698          if (OutRltV[OutRltN].Val2 == TOntoRltType::SubCptOfRltStr) {
699              SuperCptIdV.Add(OutRltV[OutRltN].Val1);
700          }
701      }
702      SuperCptIdV.Sort();
703  }
704  void TOntology::GetCptUnusedDIdV(const int& CptId, TIntV& DIdV) {
705      GetConcept(CptId)->GetDIdV(DIdV);
706      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
707      for (int SubCptN = 0; SubCptN < SubCptIdV.Len(); SubCptN++) {
708          const int SubCptId = SubCptIdV[SubCptN];
709          TIntV SubDIdV; GetConcept(SubCptId)->GetDIdV(SubDIdV);
710          DIdV.Diff(SubDIdV);
711      }   
712  }
713  void TOntology::GetCptContextDIdV(const int& CptId, 
714          TIntV& ContextDIdV, const bool& AddSonDIdP) {
715      ContextDIdV.Clr();
716      GetConcept(CptId)->GetDIdV(ContextDIdV);
717      if (HasSuperCpt(CptId)) {
718          TIntV SuperCptIdV, SuperDIdV; GetSuperCptIdV(CptId, SuperCptIdV);
719          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
720              const int SuperCptId = SuperCptIdV[SuperCptIdN];
721              GetConcept(SuperCptId)->GetDIdV(SuperDIdV);    
722              ContextDIdV.Union(SuperDIdV);
723          }
724      }
725      if (AddSonDIdP) AddSonDIdV(CptId, ContextDIdV);
726  }
727  void TOntology::GetInconsistDIdV(const int& CptId, TIntV& InconsistDIdV) {
728      InconsistDIdV.Clr();
729      TIntV SonDIdV; AddSonDIdV(CptId, SonDIdV);
730      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
731      SonDIdV.Union(CptDIdV); 
732      SonDIdV.Diff(CptDIdV, InconsistDIdV);
733  }
734  void TOntology::GetCptDocSimV(const int& CptId, const TIntV& DIdV, TFltV& CptDocSimV) {
735      PBowSpV CptSpV = GetConcept(CptId)->GetCentroidSpV();
736      const int Docs = DIdV.Len(); CptDocSimV.Gen(Docs, 0);
737      for (int DocN = 0; DocN < Docs; DocN++) {
738          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[DocN]);
739          CptDocSimV.Add(BowSim->GetSim(CptSpV, DocSpV));
740      }
741  }
742  void TOntology::AddUpDIdV(const int& CptId, const TIntV& SubDIdV) {
743      GetConcept(CptId)->AddDIdV(BowDocWgtBs, SubDIdV);
744      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
745      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
746          const int SuperCptId = SuperCptIdV[SuperCptIdN];
747          if (!IsRootCpt(SuperCptId)) { AddUpDIdV(SuperCptId, SubDIdV); }
748      }
749  }
750  void TOntology::DelUpDIdV(const int& CptId, const TIntV& SubDIdV) {
751      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
752      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
753      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
754          const int SuperCptId = SuperCptIdV[SuperCptIdN];
755          if (!IsRootCpt(SuperCptId)) { DelUpDIdV(SuperCptId, SubDIdV); }
756      }
757  }
758  void TOntology::DelDownDIdV(const int& CptId, const TIntV& SubDIdV) {
759      GetConcept(CptId)->DelDIdV(BowDocWgtBs, SubDIdV);
760      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
761      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
762          const int SubCptId = SubCptIdV[SubCptIdN];
763          DelDownDIdV(SubCptId, SubDIdV);
764      }
765  }
766  void TOntology::DelDownDId(const int& CptId, const int& DId) {
767      GetConcept(CptId)->DelDId(BowDocWgtBs, DId);
768      TIntV SubCptIdV; GetSubCptIdV(CptId, SubCptIdV);
769      for (int SubCptIdN = 0; SubCptIdN < SubCptIdV.Len(); SubCptIdN++) {
770          const int SubCptId = SubCptIdV[SubCptIdN];
771          DelDownDId(SubCptId, DId);
772      }
773  }
774  void TOntology::GetCptInRltV(const int& CptId, TIntStrPrV& InRltV) {
775      POntoConcept Cpt = GetConcept(CptId);
776      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
777      InRltV.Gen(CptVrtx->GetInEIds(), 0);
778      for (int InEIdN = 0; InEIdN < CptVrtx->GetInEIds(); InEIdN++) {
779          PEdge InEdge = OntoGraph->GetEdge(CptVrtx->GetInEId(InEIdN));
780          if (InEdge->IsDir()) 
781              InRltV.Add(TIntStrPr(InEdge->GetOtherVId(CptVrtx), InEdge->GetDNm()));
782      }
783      InRltV.Sort();
784  }
785  void TOntology::GetCptOutRltV(const int& CptId, TIntStrPrV& OutRltV) {
786      POntoConcept Cpt = GetConcept(CptId);
787      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
788      OutRltV.Gen(CptVrtx->GetOutEIds(), 0);
789      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
790          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
791          if (OutEdge->IsDir()) 
792              OutRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
793      }
794      OutRltV.Sort();
795  }
796  void TOntology::GetCptUndirRltV(const int& CptId, TIntStrPrV& UndirRltV) {
797      POntoConcept Cpt = GetConcept(CptId);
798      PVrtx CptVrtx = OntoGraph->GetVrtx(CptId);
799      UndirRltV.Gen(CptVrtx->GetOutEIds(), 0);
800      for (int OutEIdN = 0; OutEIdN < CptVrtx->GetOutEIds(); OutEIdN++) {
801          PEdge OutEdge = OntoGraph->GetEdge(CptVrtx->GetOutEId(OutEIdN));
802          if (!OutEdge->IsDir()) 
803              UndirRltV.Add(TIntStrPr(OutEdge->GetOtherVId(CptVrtx), OutEdge->GetDNm()));
804      }
805      UndirRltV.Sort();
806  }
807  void TOntology::GetCptRltV(const int& CptId, TIntStrPrV& InRltV, 
808          TIntStrPrV& OutRltV, TIntStrPrV& UndirRltV) {
809      GetCptInRltV(CptId, InRltV);
810      GetCptOutRltV(CptId, OutRltV); 
811      GetCptUndirRltV(CptId, UndirRltV); 
812  }
813  int TOntology::GetRltTypeN(const TStr& RltTypeNm) const {
814      for (int RltTypeN = 0; RltTypeN < RltTypeV.Len(); RltTypeN++) {
815          if (RltTypeV[RltTypeN].IsType(RltTypeNm)) {
816              return RltTypeN;
817          }
818      }
819      return -1;
820  }
821  bool TOntology::IsRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
822      Assert(IsCptId(CptId1) && IsCptId(CptId2));
823      PEdge Edge; 
824      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
825          return (Edge->GetDNm() == RltTypeNm);
826      }
827      return false;
828  }
829  void TOntology::AddRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
830      Assert(IsCptId(CptId1) && IsCptId(CptId2));
831      const bool IsDir = IsRltDir(RltTypeNm);
832      PEdge NewEdge = TGEdge::New(OntoGraph->GetVrtx(CptId1), 
833          OntoGraph->GetVrtx(CptId2), RltTypeNm, IsDir);
834      NewEdge->PutDNm(RltTypeNm);
835      OntoGraph->AddEdge(NewEdge);
836  }
837  bool TOntology::DelRlt(const int& CptId1, const int& CptId2, const TStr& RltTypeNm) {
838      Assert(IsCptId(CptId1) && IsCptId(CptId2));
839      PEdge Edge; bool DeletedP = false;
840      if (OntoGraph->IsVrtxsEdge(CptId1, CptId2, IsRltDir(RltTypeNm), Edge)) {
841          if (Edge->GetDNm() == RltTypeNm) {
842              OntoGraph->DelEdge(Edge);
843              DeletedP = true;
844          } else {
845              InfoNotify("There is no such relationship!!");
846          }
847      } else {
848          InfoNotify("There is no such relationship");
849          AssertR(false, TStr("There is no such relationship"));
850      }
851      ReconnectToRoot();
852      return DeletedP;
853  }
854  void TOntology::SuggestConcepts(const TIntV& DIdV, const TOntoSuggestAlgType& AlgType, 
855          const int& NewConceptN, TOntoConceptV& NewConceptV) {
856      NewConceptV.Clr();
857      if ((DIdV.Len() > NewConceptN) || (NewConceptN == -1)) {
858          if (AlgType == osatKMeans) {
859              TOntoAlg::SuggestKMeans(BowDocBs, BowDocWgtBs, DIdV, 
860                  NewConceptN, UniqueId, NewConceptV);
861          } else if (AlgType == osatCat) {
862              TOntoAlg::SuggestCat(BowDocBs, BowDocWgtBs, DIdV, 
863                  UniqueId, NewConceptV);
864          }
865      }
866  }
867  void TOntology::SuggestSubconcepts(const int& CptId, const TOntoSuggestAlgType& AlgType, 
868          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
869      TIntV DIdV; 
870      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
871      else {  GetConcept(CptId)->GetDIdV(DIdV); }
872      SuggestConcepts(DIdV, AlgType, NewConceptN, NewConceptV);
873  }
874  void TOntology::SuggestSubconcepts(const int& CptId, const PLwOntoCfier& LwOntoCfier,
875          const int& NewConceptN, const bool& UnusedDocsP, TOntoConceptV& NewConceptV) {
876      TIntV DIdV; 
877      if (UnusedDocsP){ GetCptUnusedDIdV(CptId, DIdV); }
878      else {  GetConcept(CptId)->GetDIdV(DIdV); }
879      NewConceptV.Clr();
880      if (DIdV.Len() > NewConceptN) {
881          TOntoAlg::SuggestLwOntoCfier(BowDocBs, BowDocWgtBs,
882              DIdV, LwOntoCfier, NewConceptN, UniqueId, NewConceptV);
883      }
884  }
885  POntoConcept TOntology::GenSubconcept(const TStr& NewCptNm, const TIntV& NewCptDIdV) {
886      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
887          UniqueId->GetNextId(), NewCptNm, NewCptDIdV);
888  }
889  POntoConcept TOntology::GenSubconcept(const TIntV& NewCptDIdV) {
890      return TOntoConcept::New(BowDocBs, BowDocWgtBs, 
891          UniqueId->GetNextId(), NewCptDIdV);
892  }
893  void TOntology::SuggestConceptNm(const int& CptId, const TVec<PLwOntoCfier>& LwOntoCfierV, 
894          const int& MxSuggestNms, TStrV& SuggestNmV, TIntV& SuggestSuppV, TIntV& SuggestVocNV) {
895      TIntPrIntH TermIdVocNFqH; TIntV DIdV; GetCptDIdV(CptId, DIdV); 
896      for (int VocN = 0; VocN < LwOntoCfierV.Len(); VocN++) {
897          PLwOntoCfier LwOntoCfier = LwOntoCfierV[VocN];
898          PLwTermBs LwTermBs = LwOntoCfier->GetLwOnto()->GetTermBs();
899          for (int DIdN = 0; DIdN < DIdV.Len(); DIdN++) {
900              const int DId = DIdV[DIdN];
901              TStr DocStr = BowDocBs->GetDocStr(DId);
902              TSimTermIdPrV SimTermIdPrV; SimTermIdPrV.Sort(false);
903              LwOntoCfier->ClassifyStr(DocStr, SimTermIdPrV);
904              const int TermIds = TInt::GetMn(3, SimTermIdPrV.Len());
905              for (int TermIdN = 0; TermIdN < TermIds; TermIdN++) {
906                  const int TermId = SimTermIdPrV[TermIdN].Val2;
907                  TIntPr TermIdVocN(TermId, VocN);
908                  TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
<span onclick='openModal()' class='match'>909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
</span>914      TIntIntPrPrV TermFqIdVocNV; TermIdVocNFqH.GetDatKeyPrV(TermFqIdVocNV); 
915      TermFqIdVocNV.Sort(false);
916      SuggestNmV.Clr(); SuggestSuppV.Clr(); SuggestVocNV.Clr();
917      const int SuggestNms = TInt::GetMn(MxSuggestNms, TermFqIdVocNV.Len());
918      for (int SuggestNmN = 0; SuggestNmN < SuggestNms; SuggestNmN++) {
919          const int TermId = TermFqIdVocNV[SuggestNmN].Val2.Val1;
920          const int Supp = TermFqIdVocNV[SuggestNmN].Val1;
921          const int VocN = TermFqIdVocNV[SuggestNmN].Val2.Val2;
922          PLwTermBs LwTermBs = LwOntoCfierV[VocN]->GetLwOnto()->GetTermBs();
923          TStr TermNm = LwTermBs->GetTerm(TermId)->GetTermNm();
924          SuggestNmV.Add(TermNm); 
925          SuggestSuppV.Add(Supp); 
926          SuggestVocNV.Add(VocN);
927      }
928  }
929  void TOntology::AddConcept(const POntoConcept& NewCpt, const int& FatherCptId) {
930      const int NewCptId = NewCpt->GetId();
931      IAssertR(!IsCptId(NewCptId), "There already is a conceptwith the same ID!");
932      ConceptV.Add(NewCpt); RefreshCptIdPosH();
933      TStr NewCptIdStr = TStr::Fmt("Cpt%d", NewCptId);
934      PVrtx NewCptVrtx = TGVrtx::New(NewCptId, NewCptIdStr);
935      TStr Name = NewCpt->GetName(); Name.ChangeChAll(' ', '\\');
936      NewCptVrtx->PutDNm(Name); 
937      NewCptVrtx->PutShape("Rect");
938      OntoGraph->AddVrtx(NewCptVrtx);
939      if (FatherCptId >= 0) {
940          IAssertR(IsCptId(FatherCptId), "There is no such concept!");
941          AddRlt(NewCptId, FatherCptId, TOntoRltType::SubCptOfRltStr);
942      } else {
943          IAssert(ConceptV.Len() == 1);
944      }
945  }
946  void TOntology::BreakConcept(const int& OldCptId, const TOntoConceptV& NewCptV) {
947      if (IsRootCpt(OldCptId)) return; 
948      IAssert(!NewCptV.Empty());
949      IAssertR(IsCptId(OldCptId), "There is no such concept!");
950      for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
951          POntoConcept NewCpt = NewCptV[CptC];
952          const int NewCptId = NewCpt->GetId();
953          IAssertR(!IsCptId(NewCptId), 
954              "There already is a concept with the same ID!");
955          ConceptV.Add(NewCpt); RefreshCptIdPosH();
956          TStr Name = NewCpt->GetName(); Name.ChangeStrAll(" ", "\\");
957          PVrtx v = TGVrtx::New(NewCptId, Name.CStr());
958          OntoGraph->AddVrtx(v);
959      }
960      TIntStrPrV InRltV, OutRltV, UndirRltV;
961      GetCptRltV(OldCptId, InRltV, OutRltV, UndirRltV);
962      for (int InRltN = 0; InRltN < InRltV.Len(); InRltN++) { 
963          const int VrtxId1 = InRltV[InRltN].Val1;
964          TStr RltNm = InRltV[InRltN].Val2;
965          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
966              const int NewCptId = NewCptV[CptC]->GetId();
967              AddRlt(VrtxId1, NewCptId, RltNm);
968          }
969      }
970      for (int OutRltN = 0; OutRltN < OutRltV.Len(); OutRltN++) {
971          const int VrtxId2 = OutRltV[OutRltN].Val1;
972          TStr RltNm = OutRltV[OutRltN].Val2;
973          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
974              const int NewCptId = NewCptV[CptC]->GetId();
975              AddRlt(NewCptId, VrtxId2, RltNm);
976          }
977      }
978      for (int UndirRltN = 0; UndirRltN < UndirRltV.Len(); UndirRltN++) {
979          const int VrtxId2 = UndirRltV[UndirRltN].Val1;
980          TStr RltNm = UndirRltV[UndirRltN].Val2;
981          for (int CptC = 0; CptC < NewCptV.Len(); CptC++) {
982              const int NewCptId = NewCptV[CptC]->GetId();
983              AddRlt(NewCptId, VrtxId2, RltNm);
984          }
985      }
986      ConceptV.Del(CptIdPosH.GetDat(OldCptId)); RefreshCptIdPosH();
987      OntoGraph->DelVrtx(OldCptId); ReconnectToRoot();
988  }
989  void TOntology::PruneSubconcept(const POntoConcept& SubCpt, const int& FatherCptId) {
990      if (FatherCptId == 0) return; 
991      IAssertR(IsCptId(FatherCptId), "There is no such concept!");
992      TIntV SubCptDIdV; SubCpt->GetDIdV(SubCptDIdV);
993      GetConcept(FatherCptId)->DelDIdV(BowDocWgtBs, SubCptDIdV);
994  }
995  void TOntology::DeleteConcept(const int& CptId, const bool& DoRedirect) {
996      if (IsRootCpt(CptId)) return; 
997      IAssertR(IsCptId(CptId), "There is no such concept!");
998      if (DoRedirect) {
999          TIntStrPrV InRltV, OutRltV, UndirRltV;
1000          GetCptRltV(CptId, InRltV, OutRltV, UndirRltV);
1001          AddRltsFromList(InRltV, OutRltV, UndirRltV);
1002      }
1003      ConceptV.Del(CptIdPosH.GetDat(CptId)); RefreshCptIdPosH();
1004      OntoGraph->DelVrtx(CptId); ReconnectToRoot();
1005  }
1006  void TOntology::UniteConcepts(const int& CptId1, const int& CptId2) {
1007  }
1008  void TOntology::CopyConcept(const int& CptId, const int NewFatherCptId, const bool& MoveP) {
1009      if (IsRootCpt(CptId)) return; 
1010      IAssertR(IsCptId(CptId), "There is no such concept!");
1011      IAssertR(IsCptId(NewFatherCptId), "There is no such concept!");
1012      TIntV SuperCptIdV; GetSuperCptIdV(CptId, SuperCptIdV);
1013      SuperCptIdV.DelIfIn(NewFatherCptId);
1014      if (SuperCptIdV.Empty()) return; 
1015      AddRlt(CptId, NewFatherCptId, TOntoRltType::SubCptOfRltStr);
1016      for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1017          const int SuperCptId = SuperCptIdV[SuperCptIdN];
1018          DelRlt(CptId, SuperCptId, TOntoRltType::SubCptOfRltStr);
1019      }
1020      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1021      if (MoveP) {
1022          for (int SuperCptIdN = 0; SuperCptIdN < SuperCptIdV.Len(); SuperCptIdN++) {
1023              const int SuperCptId = SuperCptIdV[SuperCptIdN];
1024              DelUpDIdV(SuperCptId, CptDIdV);
1025          }
1026      }
1027      AddUpDIdV(NewFatherCptId, CptDIdV);
1028  }
1029  void TOntology::NewConcept() {
1030      POntoConcept Cpt = TOntoConcept::New(BowDocBs, 
1031          BowDocWgtBs, UniqueId->GetNextId(), "New Concept", TIntV());
1032      IAssert(ConceptV[0]->GetId() == 0);
1033      AddConcept(Cpt, 0);
1034  }
1035  void TOntology::ExtractKeywords(const int& CptId) {
1036      if (IsRootCpt(CptId)) return;
1037      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1038      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1039      PBowSpV SvmSpV;
1040      if (CptDIdV.Len() > 0) {
1041          SvmSpV = TBowSVMMd::GetKeywords(BowDocBs, ContextDIdV, CptDIdV, 50, 1.0, 5.0);
1042      } else {
1043          SvmSpV = TBowSpV::New();
1044      }
1045      GetConcept(CptId)->SetSvmSpV(SvmSpV);
1046  }
1047  void TOntology::CalcCptCompactness(const int& CptId) {
1048      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV);
1049      if (CptDIdV.Len() > 0) {
1050          PBowSpV CentroidSpV = GetConcept(CptId)->GetCentroidSpV();
1051          double Qual = 0.0; 
1052          for (int DIdN = 0; DIdN < CptDIdV.Len(); DIdN++) {
1053              const int DId = CptDIdV[DIdN];
1054              PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
1055              Qual += BowSim->GetSim(CentroidSpV, DocSpV);
1056          }
1057          GetConcept(CptId)->SetCompactness(Qual / CptDIdV.Len());
1058      } else {
1059          GetConcept(CptId)->SetCompactness(1.0);
1060      }
1061  }
1062  void TOntology::CalcCptClarity(const int& CptId) {
1063      if (IsRootCpt(CptId)) return;
1064      TIntV ContextDIdV; GetCptContextDIdV(CptId, ContextDIdV);
1065      TIntV CptDIdV; GetCptDIdV(CptId, CptDIdV); 
1066      if (CptDIdV.Len() > 20) {
1067          TCfyRes CfyRes = TBowSVMMd::CrossValidClsLinear(
1068              5, 1, BowDocBs, BowDocWgtBs, ContextDIdV, CptDIdV, 1, 5.0);
1069          const double Clarity = CfyRes.BreakEvenPoint();
1070          GetConcept(CptId)->SetClarity(Clarity);
1071      }
1072  }
1073  void TOntology::PrepareGraph(const int& SelectedCptId) {
1074      IAssert(GetConcepts() > 0);
1075      if (IsCptId(SelectedCptId)) {
1076          TStr VrtxNm = OntoGraph->GetVrtx(SelectedCptId)->GetDNm();
1077          OntoGraph->GetPp()->PutValStr("BoldVNm", VrtxNm);
1078      }
1079  }
1080  void TOntology::PlaceGraph() {
1081      IAssert(GetConcepts() > 0);
1082      PVrtx RootVrtx = OntoGraph->GetVrtx(0);
1083      OntoGraph->PlaceGraphAsStar(RootVrtx, TOntoRltType::SubCptOfRltStr);
1084      OntoGraph->RescaleXY(0.1, RootVrtx);
1085  }
1086  void TOntology::ExportPTO(const TStr& FNm, const bool& DigLibP) { 
1087      PSOut SOut = TFOut::New(FNm);
1088      TStr BowFNm = FNm + ".bow"; BowDocBs->SaveBin(BowFNm);
1089      POntoExport OntoExport = TOntoExportPTO::New(SOut, DigLibP, BowFNm);
1090      this->Export(OntoExport);
1091  }
1092  void TOntology::ExportProlog(const TStr& FNm) {
1093      PSOut SOut = TFOut::New(FNm);
1094      POntoExport OntoExport = TOntoExportProlog::New(SOut);
1095      this->Export(OntoExport);
1096  }
1097  void TOntology::ExportOwl(const TStr& FNm, const bool& StoreDocsP, const bool& StoreAbstractsP) {
1098      PSOut SOut = TFOut::New(FNm);
1099      POntoExport OntoExport = TOntoExportOWL::New(SOut, StoreDocsP, StoreAbstractsP);
1100      this->Export(OntoExport);
1101  }
1102  POntology TOntology::ImportPTO(const TStr& RdfFNm, const TStr& BowFNm) {
1103      PBowDocBs BowDocBs = TBowDocBs::LoadBin(BowFNm);
1104      const int MnWordFq = BowDocBs->GetDocs() > 111 ? 5 : 3;
1105      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(
1106          BowDocBs, bwwtLogDFNrmTFIDF, 0.2, MnWordFq);
1107      POntology Onto = TOntology::New(BowDocBs, BowDocWgtBs, bstCos);
1108      PXmlDoc Rdf = TXmlDoc::LoadTxt(RdfFNm);
1109      IAssertR(Rdf->IsOk(), "Wrong RDF format");
1110      TStrIntH TopicUriIdH;
1111      PXmlTok RootTok; IAssert(Rdf->IsTagTok("rdf:RDF", RootTok));
1112      TXmlTokV TopicV; RootTok->GetTagTokV("ptop:Topic", TopicV);
1113      TXmlTokV DocV; RootTok->GetTagTokV("ptop:Document", DocV);
1114      TXmlTokV DocPropV; RootTok->GetTagTokV("jsikm:OntoGenInstanceProperties", DocPropV);
1115      TIntIntVH TopicIdDocIdVH; TopicIdDocIdVH.AddDat(0, TIntV());
1116      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1117          PXmlTok TopicTok = TopicV[TopicN];
1118          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1119          TStr TopicName = TopicTok->GetTagTok("psys:description")->GetTagTokStr("");
1120          int UnderScorePos = TopicURI.SearchCh('_');
1121          TStr TopicURIPrefix = TopicURI.Left(UnderScorePos);
1122          if (TopicURIPrefix != "#Cpt0" && TopicURI != "#TOP_0") {
1123              const int TopicId = Onto->UniqueId->GetNextId(); 
1124              POntoConcept TopicCpt = TOntoConcept::New(Onto->BowDocBs, 
1125                  Onto->BowDocWgtBs, TopicId, TopicName, TIntV());
1126              Onto->AddConcept(TopicCpt, 0);
1127              TopicUriIdH.AddDat(TopicURI, TopicId);
1128              TopicIdDocIdVH.AddDat(TopicId, TIntV());
1129          } else {
1130              Onto->SetCptName(0, TopicName);
1131              TopicUriIdH.AddDat(TopicURI, 0);
1132          }        
1133      }
1134      for (int TopicN = 0; TopicN < TopicV.Len(); TopicN++) {
1135          PXmlTok TopicTok = TopicV[TopicN];
1136          TStr TopicURI = TopicTok->GetArgVal("rdf:about");
1137          const int TopicId = TopicUriIdH.GetDat(TopicURI);
1138          bool ConnectedToRoot = false;
1139          if (TopicId > 0) {
1140              TXmlTokV SuperTopicV; TopicTok->GetTagTokV("ptop:subTopicOf", SuperTopicV);
1141              for (int SupTopN = 0; SupTopN < SuperTopicV.Len(); SupTopN++) {
1142                  TStr SuperTopicURI = SuperTopicV[SupTopN]->GetArgVal("rdf:resource");
1143                  const int SuperTopicId = TopicUriIdH.GetDat(SuperTopicURI);
1144                  if (SuperTopicId == 0) {
1145                      ConnectedToRoot = true;
1146                  } else {            
1147                      Onto->AddRlt(TopicId, SuperTopicId, TOntoRltType::SubCptOfRltStr);
1148                  }
1149              }
1150              if (!ConnectedToRoot) {
1151                  Onto->DelRlt(TopicId, 0, TOntoRltType::SubCptOfRltStr);
1152              }
1153          }
1154      }
1155      TStrIntH DocPropIdH;
1156      for (int DocN = 0; DocN < DocPropV.Len(); DocN++) {
1157          PXmlTok DocPropTok = DocPropV[DocN];
1158          TStr DocPropURI = DocPropTok->GetArgVal("rdf:about");
1159          TStr Link = DocPropTok->GetTagTok("jsikm:locationOfInstance")->GetTagTokStr("");
1160          TStrV LinkPartV; Link.SplitOnAllCh('#', LinkPartV);
1161          IAssert(LinkPartV.Len() == 2);
1162          const int DocId = LinkPartV[1].GetInt();
1163          IAssert(BowDocBs->IsDId(DocId));
1164          DocPropIdH.AddDat(DocPropURI, DocId);
1165      }
1166      for (int DocN = 0; DocN < DocV.Len(); DocN++) {
1167          PXmlTok DocTok = DocV[DocN];
1168          TStr DocPropURI = DocTok->GetTagTok("jsikm:hasOntoGenInstanceProperties")->GetArgVal("rdf:resource");
1169          const int DocId = DocPropIdH.GetDat(DocPropURI);
1170          TopicIdDocIdVH.GetDat(0).Add(DocId);
1171          TXmlTokV SubjectTopicV; DocTok->GetTagTokV("ptop:hasSubject", SubjectTopicV);
1172          for (int SubjectN = 0; SubjectN < SubjectTopicV.Len(); SubjectN++) {
1173              PXmlTok SubjectTok = SubjectTopicV[SubjectN];
1174              TStr SubjectUri = SubjectTok->GetArgVal("rdf:resource");
1175              const int SubjectId = TopicUriIdH.GetDat(SubjectUri);
1176              if (SubjectId > 0) {
1177                  IAssert(TopicIdDocIdVH.IsKey(SubjectId));
1178                  TopicIdDocIdVH.GetDat(SubjectId).Add(DocId);
1179              }
1180          }
1181      }
1182      int KeyId = TopicIdDocIdVH.FFirstKeyId();
1183      while (TopicIdDocIdVH.FNextKeyId(KeyId)) {
1184          const int TopicId = TopicIdDocIdVH.GetKey(KeyId);
1185          Onto->SetCptDIdV(TopicId, TopicIdDocIdVH.GetDat(TopicId), false);
1186      }
1187      return Onto;
1188  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lsionto.cpp</div>
                </div>
                <div class="column column_space"><pre><code>391        if (SubTok->IsTag("genl")){
392          DstCycLStr=SubTok->GetArgVal("value");
393          CycBs->AddEdge(SrcCycLStr, "#$genls", DstCycLStr);
394          CycBs->AddEdge(DstCycLStr, "~#$genls", SrcCycLStr);
395        } else {
396          Fail;
397        }
398      }
399    }
400    printf("%d Docs\nDone.\n", XmlDocs);}
</pre></code></div>
                <div class="column column_space"><pre><code>909                  if (TermIdVocNFqH.IsKey(TermIdVocN)) { TermIdVocNFqH(TermIdVocN)++; } 
910                  else { TermIdVocNFqH.AddDat(TermIdVocN, 1); }
911              }             
912          }
913      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    