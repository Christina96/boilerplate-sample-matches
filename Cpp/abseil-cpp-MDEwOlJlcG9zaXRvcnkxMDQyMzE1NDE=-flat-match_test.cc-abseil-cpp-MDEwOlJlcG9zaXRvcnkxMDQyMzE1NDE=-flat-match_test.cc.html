
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-match_test.cc</h3>
            <pre><code>1  #include "absl/strings/match.h"
2  #include "gtest/gtest.h"
3  namespace {
4  TEST(MatchTest, StartsWith) {
5    const std::string s1("123\0abc", 7);
6    const absl::string_view a("foobar");
7    const absl::string_view b(s1);
8    const absl::string_view e;
9    EXPECT_TRUE(absl::StartsWith(a, a));
10    EXPECT_TRUE(absl::StartsWith(a, "foo"));
11    EXPECT_TRUE(absl::StartsWith(a, e));
12    EXPECT_TRUE(absl::StartsWith(b, s1));
13    EXPECT_TRUE(absl::StartsWith(b, b));
14    EXPECT_TRUE(absl::StartsWith(b, e));
15    EXPECT_TRUE(absl::StartsWith(e, ""));
16    EXPECT_FALSE(absl::StartsWith(a, b));
17    EXPECT_FALSE(absl::StartsWith(b, a));
18    EXPECT_FALSE(absl::StartsWith(e, a));
19  }
20  TEST(MatchTest, EndsWith) {
21    const std::string s1("123\0abc", 7);
22    const absl::string_view a("foobar");
23    const absl::string_view b(s1);
24    const absl::string_view e;
25    EXPECT_TRUE(absl::EndsWith(a, a));
26    EXPECT_TRUE(absl::EndsWith(a, "bar"));
27    EXPECT_TRUE(absl::EndsWith(a, e));
28    EXPECT_TRUE(absl::EndsWith(b, s1));
29    EXPECT_TRUE(absl::EndsWith(b, b));
30    EXPECT_TRUE(absl::EndsWith(b, e));
31    EXPECT_TRUE(absl::EndsWith(e, ""));
32    EXPECT_FALSE(absl::EndsWith(a, b));
33    EXPECT_FALSE(absl::EndsWith(b, a));
34    EXPECT_FALSE(absl::EndsWith(e, a));
35  }
36  TEST(MatchTest, Contains) {
37    absl::string_view a("abcdefg");
38    absl::string_view b("abcd");
39    absl::string_view c("efg");
40    absl::string_view d("gh");
41    EXPECT_TRUE(absl::StrContains(a, a));
42    EXPECT_TRUE(absl::StrContains(a, b));
43    EXPECT_TRUE(absl::StrContains(a, c));
44    EXPECT_FALSE(absl::StrContains(a, d));
45    EXPECT_TRUE(absl::StrContains("", ""));
46    EXPECT_TRUE(absl::StrContains("abc", ""));
47    EXPECT_FALSE(absl::StrContains("", "a"));
48  }
49  TEST(MatchTest, ContainsChar) {
50    absl::string_view a("abcdefg");
51    absl::string_view b("abcd");
52    EXPECT_TRUE(absl::StrContains(a, 'a'));
53    EXPECT_TRUE(absl::StrContains(a, 'b'));
54    EXPECT_TRUE(absl::StrContains(a, 'e'));
55    EXPECT_FALSE(absl::StrContains(a, 'h'));
56    EXPECT_TRUE(absl::StrContains(b, 'a'));
57    EXPECT_TRUE(absl::StrContains(b, 'b'));
58    EXPECT_FALSE(absl::StrContains(b, 'e'));
59    EXPECT_FALSE(absl::StrContains(b, 'h'));
60    EXPECT_FALSE(absl::StrContains("", 'a'));
61    EXPECT_FALSE(absl::StrContains("", 'a'));
62  }
63  TEST(MatchTest, ContainsNull) {
64    const std::string s = "foo";
65    const char* cs = "foo";
66    const absl::string_view sv("foo");
67    const absl::string_view sv2("foo\0bar", 4);
68    EXPECT_EQ(s, "foo");
69    EXPECT_EQ(sv, "foo");
70    EXPECT_NE(sv2, "foo");
71    EXPECT_TRUE(absl::EndsWith(s, sv));
72    EXPECT_TRUE(absl::StartsWith(cs, sv));
73    EXPECT_TRUE(absl::StrContains(cs, sv));
74    EXPECT_FALSE(absl::StrContains(cs, sv2));
75  }
76  TEST(MatchTest, EqualsIgnoreCase) {
77    std::string text = "the";
78    absl::string_view data(text);
79    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "The"));
80    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "THE"));
81    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "the"));
82    EXPECT_FALSE(absl::EqualsIgnoreCase(data, "Quick"));
83    EXPECT_FALSE(absl::EqualsIgnoreCase(data, "then"));
84  }
85  TEST(MatchTest, StartsWithIgnoreCase) {
86    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", "foo"));
87    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", "Fo"));
88    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", ""));
89    EXPECT_FALSE(absl::StartsWithIgnoreCase("foo", "fooo"));
90    EXPECT_FALSE(absl::StartsWithIgnoreCase("", "fo"));
91  }
92  TEST(MatchTest, EndsWithIgnoreCase) {
93    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", "foo"));
94    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", "Oo"));
95    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", ""));
96    EXPECT_FALSE(absl::EndsWithIgnoreCase("foo", "fooo"));
97    EXPECT_FALSE(absl::EndsWithIgnoreCase("", "fo"));
98  }
99  TEST(MatchTest, ContainsIgnoreCase) {
100    EXPECT_TRUE(absl::StrContainsIgnoreCase("foo", "foo"));
101    EXPECT_TRUE(absl::StrContainsIgnoreCase("FOO", "Foo"));
102    EXPECT_TRUE(absl::StrContainsIgnoreCase("--FOO", "Foo"));
103    EXPECT_TRUE(absl::StrContainsIgnoreCase("FOO--", "Foo"));
104    EXPECT_FALSE(absl::StrContainsIgnoreCase("BAR", "Foo"));
105    EXPECT_FALSE(absl::StrContainsIgnoreCase("BAR", "Foo"));
106    EXPECT_TRUE(absl::StrContainsIgnoreCase("123456", "123456"));
107    EXPECT_TRUE(absl::StrContainsIgnoreCase("123456", "234"));
108    EXPECT_TRUE(absl::StrContainsIgnoreCase("", ""));
109    EXPECT_TRUE(absl::StrContainsIgnoreCase("abc", ""));
110    EXPECT_FALSE(absl::StrContainsIgnoreCase("", "a"));
111  }
112  TEST(MatchTest, ContainsCharIgnoreCase) {
113    absl::string_view a("AaBCdefg!");
114    absl::string_view b("AaBCd!");
115    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'a'));
116    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'A'));
117    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'b'));
118    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'B'));
119    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'e'));
120    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'E'));
121    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, 'h'));
122    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, 'H'));
123    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, '!'));
124    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, '?'));
125    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'a'));
126    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'A'));
127    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'b'));
128    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'B'));
129    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'e'));
130    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'E'));
131    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'h'));
132    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'H'));
133    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, '!'));
134    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, '?'));
135    EXPECT_FALSE(absl::StrContainsIgnoreCase("", 'a'));
136    EXPECT_FALSE(absl::StrContainsIgnoreCase("", 'A'));
137    EXPECT_FALSE(absl::StrContainsIgnoreCase("", '0'));
138  }
139  TEST(MatchTest, FindLongestCommonPrefix) {
140    EXPECT_EQ(absl::FindLongestCommonPrefix("", ""), "");
141    EXPECT_EQ(absl::FindLongestCommonPrefix("", "abc"), "");
142    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", ""), "");
143    EXPECT_EQ(absl::FindLongestCommonPrefix("ab", "abc"), "ab");
144    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "ab"), "ab");
145    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "abd"), "ab");
146    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "abcd"), "abc");
147    EXPECT_EQ(absl::FindLongestCommonPrefix("abcd", "abcd"), "abcd");
148    EXPECT_EQ(absl::FindLongestCommonPrefix("abcd", "efgh"), "");
149    EXPECT_EQ(absl::FindLongestCommonPrefix(
<span onclick='openModal()' class='match'>150                  absl::string_view("1234 abcdef").substr(5, 5),
151                  absl::string_view("5678 abcdef").substr(5, 3)),
152              "abc");
153  }
154  TEST(MatchTest, FindLongestCommonPrefixLoad16Mismatch) {
</span>155    const std::string x1 = "abcdefgh";
156    const std::string x2 = "abcde_";
157    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
158    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
159  }
160  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesNoLast) {
161    const std::string x1 = "abcdef";
162    const std::string x2 = "abcdef";
163    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdef");
164    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdef");
165  }
166  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesLastCharMismatches) {
167    const std::string x1 = "abcdefg";
168    const std::string x2 = "abcdef_h";
169    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdef");
170    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdef");
171  }
172  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesLastMatches) {
173    const std::string x1 = "abcde";
174    const std::string x2 = "abcdefgh";
175    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
176    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
177  }
178  TEST(MatchTest, FindLongestCommonPrefixSize8Load64Mismatches) {
179    const std::string x1 = "abcdefghijk";
180    const std::string x2 = "abcde_g_";
181    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
182    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
183  }
184  TEST(MatchTest, FindLongestCommonPrefixSize8Load64Matches) {
185    const std::string x1 = "abcdefgh";
186    const std::string x2 = "abcdefgh";
187    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdefgh");
188    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdefgh");
189  }
190  TEST(MatchTest, FindLongestCommonPrefixSize15Load64Mismatches) {
191    const std::string x1 = "012345670123456";
192    const std::string x2 = "0123456701_34_6";
193    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "0123456701");
194    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "0123456701");
195  }
196  TEST(MatchTest, FindLongestCommonPrefixSize15Load64Matches) {
197    const std::string x1 = "012345670123456";
198    const std::string x2 = "0123456701234567";
199    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "012345670123456");
200    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "012345670123456");
201  }
202  TEST(MatchTest, FindLongestCommonPrefixSizeFirstByteOfLast8BytesMismatch) {
203    const std::string x1 = "012345670123456701234567";
204    const std::string x2 = "0123456701234567_1234567";
205    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "0123456701234567");
206    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "0123456701234567");
207  }
208  TEST(MatchTest, FindLongestCommonPrefixLargeLastCharMismatches) {
209    const std::string x1(300, 'x');
210    std::string x2 = x1;
211    x2.back() = '#';
212    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), std::string(299, 'x'));
213    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), std::string(299, 'x'));
214  }
215  TEST(MatchTest, FindLongestCommonPrefixLargeFullMatch) {
216    const std::string x1(300, 'x');
217    const std::string x2 = x1;
218    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), std::string(300, 'x'));
219    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), std::string(300, 'x'));
220  }
221  TEST(MatchTest, FindLongestCommonSuffix) {
222    EXPECT_EQ(absl::FindLongestCommonSuffix("", ""), "");
223    EXPECT_EQ(absl::FindLongestCommonSuffix("", "abc"), "");
224    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", ""), "");
225    EXPECT_EQ(absl::FindLongestCommonSuffix("bc", "abc"), "bc");
226    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", "bc"), "bc");
227    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", "dbc"), "bc");
228    EXPECT_EQ(absl::FindLongestCommonSuffix("bcd", "abcd"), "bcd");
229    EXPECT_EQ(absl::FindLongestCommonSuffix("abcd", "abcd"), "abcd");
230    EXPECT_EQ(absl::FindLongestCommonSuffix("abcd", "efgh"), "");
231    EXPECT_EQ(absl::FindLongestCommonSuffix(
232                  absl::string_view("1234 abcdef").substr(5, 5),
233                  absl::string_view("5678 abcdef").substr(7, 3)),
234              "cde");
235  }
236  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-match_test.cc</h3>
            <pre><code>1  #include "absl/strings/match.h"
2  #include "gtest/gtest.h"
3  namespace {
4  TEST(MatchTest, StartsWith) {
5    const std::string s1("123\0abc", 7);
6    const absl::string_view a("foobar");
7    const absl::string_view b(s1);
8    const absl::string_view e;
9    EXPECT_TRUE(absl::StartsWith(a, a));
10    EXPECT_TRUE(absl::StartsWith(a, "foo"));
11    EXPECT_TRUE(absl::StartsWith(a, e));
12    EXPECT_TRUE(absl::StartsWith(b, s1));
13    EXPECT_TRUE(absl::StartsWith(b, b));
14    EXPECT_TRUE(absl::StartsWith(b, e));
15    EXPECT_TRUE(absl::StartsWith(e, ""));
16    EXPECT_FALSE(absl::StartsWith(a, b));
17    EXPECT_FALSE(absl::StartsWith(b, a));
18    EXPECT_FALSE(absl::StartsWith(e, a));
19  }
20  TEST(MatchTest, EndsWith) {
21    const std::string s1("123\0abc", 7);
22    const absl::string_view a("foobar");
23    const absl::string_view b(s1);
24    const absl::string_view e;
25    EXPECT_TRUE(absl::EndsWith(a, a));
26    EXPECT_TRUE(absl::EndsWith(a, "bar"));
27    EXPECT_TRUE(absl::EndsWith(a, e));
28    EXPECT_TRUE(absl::EndsWith(b, s1));
29    EXPECT_TRUE(absl::EndsWith(b, b));
30    EXPECT_TRUE(absl::EndsWith(b, e));
31    EXPECT_TRUE(absl::EndsWith(e, ""));
32    EXPECT_FALSE(absl::EndsWith(a, b));
33    EXPECT_FALSE(absl::EndsWith(b, a));
34    EXPECT_FALSE(absl::EndsWith(e, a));
35  }
36  TEST(MatchTest, Contains) {
37    absl::string_view a("abcdefg");
38    absl::string_view b("abcd");
39    absl::string_view c("efg");
40    absl::string_view d("gh");
41    EXPECT_TRUE(absl::StrContains(a, a));
42    EXPECT_TRUE(absl::StrContains(a, b));
43    EXPECT_TRUE(absl::StrContains(a, c));
44    EXPECT_FALSE(absl::StrContains(a, d));
45    EXPECT_TRUE(absl::StrContains("", ""));
46    EXPECT_TRUE(absl::StrContains("abc", ""));
47    EXPECT_FALSE(absl::StrContains("", "a"));
48  }
49  TEST(MatchTest, ContainsChar) {
50    absl::string_view a("abcdefg");
51    absl::string_view b("abcd");
52    EXPECT_TRUE(absl::StrContains(a, 'a'));
53    EXPECT_TRUE(absl::StrContains(a, 'b'));
54    EXPECT_TRUE(absl::StrContains(a, 'e'));
55    EXPECT_FALSE(absl::StrContains(a, 'h'));
56    EXPECT_TRUE(absl::StrContains(b, 'a'));
57    EXPECT_TRUE(absl::StrContains(b, 'b'));
58    EXPECT_FALSE(absl::StrContains(b, 'e'));
59    EXPECT_FALSE(absl::StrContains(b, 'h'));
60    EXPECT_FALSE(absl::StrContains("", 'a'));
61    EXPECT_FALSE(absl::StrContains("", 'a'));
62  }
63  TEST(MatchTest, ContainsNull) {
64    const std::string s = "foo";
65    const char* cs = "foo";
66    const absl::string_view sv("foo");
67    const absl::string_view sv2("foo\0bar", 4);
68    EXPECT_EQ(s, "foo");
69    EXPECT_EQ(sv, "foo");
70    EXPECT_NE(sv2, "foo");
71    EXPECT_TRUE(absl::EndsWith(s, sv));
72    EXPECT_TRUE(absl::StartsWith(cs, sv));
73    EXPECT_TRUE(absl::StrContains(cs, sv));
74    EXPECT_FALSE(absl::StrContains(cs, sv2));
75  }
76  TEST(MatchTest, EqualsIgnoreCase) {
77    std::string text = "the";
78    absl::string_view data(text);
79    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "The"));
80    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "THE"));
81    EXPECT_TRUE(absl::EqualsIgnoreCase(data, "the"));
82    EXPECT_FALSE(absl::EqualsIgnoreCase(data, "Quick"));
83    EXPECT_FALSE(absl::EqualsIgnoreCase(data, "then"));
84  }
85  TEST(MatchTest, StartsWithIgnoreCase) {
86    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", "foo"));
87    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", "Fo"));
88    EXPECT_TRUE(absl::StartsWithIgnoreCase("foo", ""));
89    EXPECT_FALSE(absl::StartsWithIgnoreCase("foo", "fooo"));
90    EXPECT_FALSE(absl::StartsWithIgnoreCase("", "fo"));
91  }
92  TEST(MatchTest, EndsWithIgnoreCase) {
93    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", "foo"));
94    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", "Oo"));
95    EXPECT_TRUE(absl::EndsWithIgnoreCase("foo", ""));
96    EXPECT_FALSE(absl::EndsWithIgnoreCase("foo", "fooo"));
97    EXPECT_FALSE(absl::EndsWithIgnoreCase("", "fo"));
98  }
99  TEST(MatchTest, ContainsIgnoreCase) {
100    EXPECT_TRUE(absl::StrContainsIgnoreCase("foo", "foo"));
101    EXPECT_TRUE(absl::StrContainsIgnoreCase("FOO", "Foo"));
102    EXPECT_TRUE(absl::StrContainsIgnoreCase("--FOO", "Foo"));
103    EXPECT_TRUE(absl::StrContainsIgnoreCase("FOO--", "Foo"));
104    EXPECT_FALSE(absl::StrContainsIgnoreCase("BAR", "Foo"));
105    EXPECT_FALSE(absl::StrContainsIgnoreCase("BAR", "Foo"));
106    EXPECT_TRUE(absl::StrContainsIgnoreCase("123456", "123456"));
107    EXPECT_TRUE(absl::StrContainsIgnoreCase("123456", "234"));
108    EXPECT_TRUE(absl::StrContainsIgnoreCase("", ""));
109    EXPECT_TRUE(absl::StrContainsIgnoreCase("abc", ""));
110    EXPECT_FALSE(absl::StrContainsIgnoreCase("", "a"));
111  }
112  TEST(MatchTest, ContainsCharIgnoreCase) {
113    absl::string_view a("AaBCdefg!");
114    absl::string_view b("AaBCd!");
115    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'a'));
116    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'A'));
117    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'b'));
118    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'B'));
119    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'e'));
120    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, 'E'));
121    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, 'h'));
122    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, 'H'));
123    EXPECT_TRUE(absl::StrContainsIgnoreCase(a, '!'));
124    EXPECT_FALSE(absl::StrContainsIgnoreCase(a, '?'));
125    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'a'));
126    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'A'));
127    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'b'));
128    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, 'B'));
129    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'e'));
130    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'E'));
131    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'h'));
132    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, 'H'));
133    EXPECT_TRUE(absl::StrContainsIgnoreCase(b, '!'));
134    EXPECT_FALSE(absl::StrContainsIgnoreCase(b, '?'));
135    EXPECT_FALSE(absl::StrContainsIgnoreCase("", 'a'));
136    EXPECT_FALSE(absl::StrContainsIgnoreCase("", 'A'));
137    EXPECT_FALSE(absl::StrContainsIgnoreCase("", '0'));
138  }
139  TEST(MatchTest, FindLongestCommonPrefix) {
140    EXPECT_EQ(absl::FindLongestCommonPrefix("", ""), "");
141    EXPECT_EQ(absl::FindLongestCommonPrefix("", "abc"), "");
142    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", ""), "");
143    EXPECT_EQ(absl::FindLongestCommonPrefix("ab", "abc"), "ab");
144    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "ab"), "ab");
145    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "abd"), "ab");
146    EXPECT_EQ(absl::FindLongestCommonPrefix("abc", "abcd"), "abc");
147    EXPECT_EQ(absl::FindLongestCommonPrefix("abcd", "abcd"), "abcd");
148    EXPECT_EQ(absl::FindLongestCommonPrefix("abcd", "efgh"), "");
149    EXPECT_EQ(absl::FindLongestCommonPrefix(
<span onclick='openModal()' class='match'>150                  absl::string_view("1234 abcdef").substr(5, 5),
151                  absl::string_view("5678 abcdef").substr(5, 3)),
152              "abc");
153  }
154  TEST(MatchTest, FindLongestCommonPrefixLoad16Mismatch) {
</span>155    const std::string x1 = "abcdefgh";
156    const std::string x2 = "abcde_";
157    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
158    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
159  }
160  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesNoLast) {
161    const std::string x1 = "abcdef";
162    const std::string x2 = "abcdef";
163    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdef");
164    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdef");
165  }
166  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesLastCharMismatches) {
167    const std::string x1 = "abcdefg";
168    const std::string x2 = "abcdef_h";
169    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdef");
170    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdef");
171  }
172  TEST(MatchTest, FindLongestCommonPrefixLoad16MatchesLastMatches) {
173    const std::string x1 = "abcde";
174    const std::string x2 = "abcdefgh";
175    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
176    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
177  }
178  TEST(MatchTest, FindLongestCommonPrefixSize8Load64Mismatches) {
179    const std::string x1 = "abcdefghijk";
180    const std::string x2 = "abcde_g_";
181    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcde");
182    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcde");
183  }
184  TEST(MatchTest, FindLongestCommonPrefixSize8Load64Matches) {
185    const std::string x1 = "abcdefgh";
186    const std::string x2 = "abcdefgh";
187    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "abcdefgh");
188    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "abcdefgh");
189  }
190  TEST(MatchTest, FindLongestCommonPrefixSize15Load64Mismatches) {
191    const std::string x1 = "012345670123456";
192    const std::string x2 = "0123456701_34_6";
193    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "0123456701");
194    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "0123456701");
195  }
196  TEST(MatchTest, FindLongestCommonPrefixSize15Load64Matches) {
197    const std::string x1 = "012345670123456";
198    const std::string x2 = "0123456701234567";
199    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "012345670123456");
200    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "012345670123456");
201  }
202  TEST(MatchTest, FindLongestCommonPrefixSizeFirstByteOfLast8BytesMismatch) {
203    const std::string x1 = "012345670123456701234567";
204    const std::string x2 = "0123456701234567_1234567";
205    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), "0123456701234567");
206    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), "0123456701234567");
207  }
208  TEST(MatchTest, FindLongestCommonPrefixLargeLastCharMismatches) {
209    const std::string x1(300, 'x');
210    std::string x2 = x1;
211    x2.back() = '#';
212    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), std::string(299, 'x'));
213    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), std::string(299, 'x'));
214  }
215  TEST(MatchTest, FindLongestCommonPrefixLargeFullMatch) {
216    const std::string x1(300, 'x');
217    const std::string x2 = x1;
218    EXPECT_EQ(absl::FindLongestCommonPrefix(x1, x2), std::string(300, 'x'));
219    EXPECT_EQ(absl::FindLongestCommonPrefix(x2, x1), std::string(300, 'x'));
220  }
221  TEST(MatchTest, FindLongestCommonSuffix) {
222    EXPECT_EQ(absl::FindLongestCommonSuffix("", ""), "");
223    EXPECT_EQ(absl::FindLongestCommonSuffix("", "abc"), "");
224    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", ""), "");
225    EXPECT_EQ(absl::FindLongestCommonSuffix("bc", "abc"), "bc");
226    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", "bc"), "bc");
227    EXPECT_EQ(absl::FindLongestCommonSuffix("abc", "dbc"), "bc");
228    EXPECT_EQ(absl::FindLongestCommonSuffix("bcd", "abcd"), "bcd");
229    EXPECT_EQ(absl::FindLongestCommonSuffix("abcd", "abcd"), "abcd");
230    EXPECT_EQ(absl::FindLongestCommonSuffix("abcd", "efgh"), "");
231    EXPECT_EQ(absl::FindLongestCommonSuffix(
232                  absl::string_view("1234 abcdef").substr(5, 5),
233                  absl::string_view("5678 abcdef").substr(7, 3)),
234              "cde");
235  }
236  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-match_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-match_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>150                  absl::string_view("1234 abcdef").substr(5, 5),
151                  absl::string_view("5678 abcdef").substr(5, 3)),
152              "abc");
153  }
154  TEST(MatchTest, FindLongestCommonPrefixLoad16Mismatch) {
</pre></code></div>
                <div class="column column_space"><pre><code>150                  absl::string_view("1234 abcdef").substr(5, 5),
151                  absl::string_view("5678 abcdef").substr(5, 3)),
152              "abc");
153  }
154  TEST(MatchTest, FindLongestCommonPrefixLoad16Mismatch) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    