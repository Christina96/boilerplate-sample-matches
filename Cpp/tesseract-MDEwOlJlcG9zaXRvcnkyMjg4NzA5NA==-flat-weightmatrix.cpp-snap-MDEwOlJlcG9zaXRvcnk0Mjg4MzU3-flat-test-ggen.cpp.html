
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.082785808147175%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-weightmatrix.cpp</h3>
            <pre><code>1  #include "weightmatrix.h"
2  #include <cassert> 
3  #include "intsimdmatrix.h"
4  #include "simddetect.h" 
5  #include "statistc.h"
6  #include "tprintf.h"    
7  namespace tesseract {
8  #if defined(ANDROID)
9  static inline TFloat log2(TFloat n) {
10    return log(n) / log(2.0);
11  }
12  #endif 
13  const int kAdamCorrectionIterations = 200000;
14  const TFloat kAdamEpsilon = 1e-8;
15  #ifdef FAST_FLOAT
16  static void DoubleToFloat(const GENERIC_2D_ARRAY<double> &src, GENERIC_2D_ARRAY<float> &dst) {
17    const auto dim1 = src.dim1();
18    const auto dim2 = src.dim2();
19    dst.ResizeNoInit(dim1, dim2);
20    for (int i = 0; i < dim1; ++i) {
21      const auto *src_i = src[i];
22      auto *dst_i = dst[i];
23      for (int j = 0; j < dim2; ++j) {
24        dst_i[j] = static_cast<float>(src_i[j]);
25      }
26    }
27  }
28  #endif
29  static void FloatToDouble(const GENERIC_2D_ARRAY<float> &src, GENERIC_2D_ARRAY<double> &dst) {
30    const auto dim1 = src.dim1();
31    const auto dim2 = src.dim2();
32    dst.ResizeNoInit(dim1, dim2);
33    for (int i = 0; i < dim1; ++i) {
34      const auto *src_i = src[i];
35      auto *dst_i = dst[i];
36      for (int j = 0; j < dim2; ++j) {
37        dst_i[j] = static_cast<double>(src_i[j]);
38      }
39    }
40  }
41  static bool DeSerialize(TFile *fp, GENERIC_2D_ARRAY<TFloat> &tfloat_array) {
42  #ifdef FAST_FLOAT
43    GENERIC_2D_ARRAY<double> double_array;
44    if (!double_array.DeSerialize(fp)) {
45      return false;
46    }
47    DoubleToFloat(double_array, tfloat_array);
48    return true;
49  #else
50    return tfloat_array.DeSerialize(fp);
51  #endif
52  }
53  static bool Serialize(TFile *fp, const GENERIC_2D_ARRAY<TFloat> &tfloat_array) {
54  #ifdef FAST_FLOAT
55    GENERIC_2D_ARRAY<double> double_array;
56    FloatToDouble(tfloat_array, double_array);
57    return double_array.Serialize(fp);
58  #else
59    return tfloat_array.Serialize(fp);
60  #endif
61  }
62  static inline void MatrixDotVectorInternal(const GENERIC_2D_ARRAY<TFloat> &w, bool add_bias_fwd,
63                                             bool skip_bias_back, const TFloat *u, TFloat *v) {
64    int num_results = w.dim1() - skip_bias_back;
65    int extent = w.dim2() - add_bias_fwd;
66    for (int i = 0; i < num_results; ++i) {
67      const TFloat *wi = w[i];
68      TFloat total = DotProduct(wi, u, extent);
69      if (add_bias_fwd) {
70        total += wi[extent]; 
71      }
72      v[i] = total;
73    }
74  }
75  void TransposedArray::Transpose(const GENERIC_2D_ARRAY<TFloat> &input) {
76    int width = input.dim1();
77    int num_features = input.dim2();
78    ResizeNoInit(num_features, width);
79    for (int t = 0; t < width; ++t) {
80      WriteStrided(t, input[t]);
81    }
82  }
83  TransposedArray::~TransposedArray() = default;
84  int WeightMatrix::InitWeightsFloat(int no, int ni, bool use_adam, float weight_range,
85                                     TRand *randomizer) {
86    int_mode_ = false;
87    wf_.Resize(no, ni, 0.0);
88    if (randomizer != nullptr) {
89      for (int i = 0; i < no; ++i) {
90        for (int j = 0; j < ni; ++j) {
91          wf_[i][j] = randomizer->SignedRand(weight_range);
92        }
93      }
94    }
95    use_adam_ = use_adam;
96    InitBackward();
97    return ni * no;
98  }
99  int WeightMatrix::RemapOutputs(const std::vector<int> &code_map) {
100    GENERIC_2D_ARRAY<TFloat> old_wf(wf_);
<span onclick='openModal()' class='match'>101    int old_no = wf_.dim1();
102    int new_no = code_map.size();
103    int ni = wf_.dim2();
104    std::vector<TFloat> means(ni, 0.0);
105    for (int c = 0; c < old_no; ++c) {
</span>106      const TFloat *weights = wf_[c];
107      for (int i = 0; i < ni; ++i) {
108        means[i] += weights[i];
109      }
110    }
111    for (auto &mean : means) {
112      mean /= old_no;
113    }
114    wf_.Resize(new_no, ni, 0.0);
115    InitBackward();
116    for (int dest = 0; dest < new_no; ++dest) {
117      int src = code_map[dest];
118      const TFloat *src_data = src >= 0 ? old_wf[src] : means.data();
119      memcpy(wf_[dest], src_data, ni * sizeof(*src_data));
120    }
121    return ni * new_no;
122  }
123  void WeightMatrix::ConvertToInt() {
124    wi_.ResizeNoInit(wf_.dim1(), wf_.dim2());
125    scales_.reserve(wi_.dim1());
126    int dim2 = wi_.dim2();
127    for (int t = 0; t < wi_.dim1(); ++t) {
128      TFloat *f_line = wf_[t];
129      int8_t *i_line = wi_[t];
130      TFloat max_abs = 0;
131      for (int f = 0; f < dim2; ++f) {
132        TFloat abs_val = fabs(f_line[f]);
133        if (abs_val > max_abs) {
134          max_abs = abs_val;
135        }
136      }
137      TFloat scale = max_abs / INT8_MAX;
138      scales_.push_back(scale / INT8_MAX);
139      if (scale == 0.0) {
140        scale = 1.0;
141      }
142      for (int f = 0; f < dim2; ++f) {
143        i_line[f] = IntCastRounded(f_line[f] / scale);
144      }
145    }
146    wf_.Resize(1, 1, 0.0);
147    int_mode_ = true;
148    if (IntSimdMatrix::intSimdMatrix) {
149      int32_t rounded_num_out;
150      IntSimdMatrix::intSimdMatrix->Init(wi_, shaped_w_, rounded_num_out);
151      scales_.resize(rounded_num_out);
152    }
153  }
154  void WeightMatrix::InitBackward() {
155    int no = int_mode_ ? wi_.dim1() : wf_.dim1();
156    int ni = int_mode_ ? wi_.dim2() : wf_.dim2();
157    dw_.Resize(no, ni, 0.0);
158    updates_.Resize(no, ni, 0.0);
159    wf_t_.Transpose(wf_);
160    if (use_adam_) {
161      dw_sq_sum_.Resize(no, ni, 0.0);
162    }
163  }
164  const int kInt8Flag = 1;
165  const int kAdamFlag = 4;
166  const int kDoubleFlag = 128;
167  bool WeightMatrix::Serialize(bool training, TFile *fp) const {
168    uint8_t mode = (int_mode_ ? kInt8Flag : 0) | (use_adam_ ? kAdamFlag : 0) | kDoubleFlag;
169    if (!fp->Serialize(&mode)) {
170      return false;
171    }
172    if (int_mode_) {
173      if (!wi_.Serialize(fp)) {
174        return false;
175      }
176      uint32_t size = scales_.size();
177      if (!fp->Serialize(&size)) {
178        return false;
179      }
180      for (auto scale : scales_) {
181        double value = scale * INT8_MAX;
182        if (!fp->Serialize(&value)) {
183          return false;
184        }
185      }
186    } else {
187      if (!tesseract::Serialize(fp, wf_)) {
188        return false;
189      }
190      if (training) {
191        if (!tesseract::Serialize(fp, updates_)) {
192          return false;
193        }
194        if (use_adam_ && !tesseract::Serialize(fp, dw_sq_sum_)) {
195          return false;
196        }
197      }
198    }
199    return true;
200  }
201  bool WeightMatrix::DeSerialize(bool training, TFile *fp) {
202    uint8_t mode;
203    if (!fp->DeSerialize(&mode)) {
204      return false;
205    }
206    int_mode_ = (mode & kInt8Flag) != 0;
207    use_adam_ = (mode & kAdamFlag) != 0;
208    if ((mode & kDoubleFlag) == 0) {
209      return DeSerializeOld(training, fp);
210    }
211    if (int_mode_) {
212      if (!wi_.DeSerialize(fp)) {
213        return false;
214      }
215      uint32_t size;
216      if (!fp->DeSerialize(&size)) {
217        return false;
218      }
219  #ifdef FAST_FLOAT
220      scales_.reserve(size);
221      for (auto n = size; n > 0; n--) {
222        double val;
223        if (!fp->DeSerialize(&val)) {
224          return false;
225        }
226        scales_.push_back(val / INT8_MAX);
227      }
228  #else
229      scales_.resize(size);
230      if (!fp->DeSerialize(&scales_[0], size)) {
231        return false;
232      }
233      for (auto &scale : scales_) {
234        scale /= INT8_MAX;
235      }
236  #endif
237      if (IntSimdMatrix::intSimdMatrix) {
238        int32_t rounded_num_out;
239        IntSimdMatrix::intSimdMatrix->Init(wi_, shaped_w_, rounded_num_out);
240        scales_.resize(rounded_num_out);
241      }
242    } else {
243      if (!tesseract::DeSerialize(fp, wf_)) {
244        return false;
245      }
246      if (training) {
247        InitBackward();
248        if (!tesseract::DeSerialize(fp, updates_)) {
249          return false;
250        }
251        if (use_adam_) {
252          if (!tesseract::DeSerialize(fp, dw_sq_sum_)) {
253            return false;
254          }
255        }
256      }
257    }
258    return true;
259  }
260  bool WeightMatrix::DeSerializeOld(bool training, TFile *fp) {
261  #ifdef FAST_FLOAT
262    ASSERT_HOST(!"not implemented");
263    return false;
264  #else
265    if (int_mode_) {
266      if (!wi_.DeSerialize(fp)) {
267        return false;
268      }
269      std::vector<float> old_scales;
270      if (!fp->DeSerialize(old_scales)) {
271        return false;
272      }
273      scales_.reserve(old_scales.size());
274      for (float old_scale : old_scales) {
275        scales_.push_back(old_scale);
276      }
277    } else {
278      GENERIC_2D_ARRAY<float> float_array;
279      if (!float_array.DeSerialize(fp)) {
280        return false;
281      }
282      FloatToDouble(float_array, wf_);
283    }
284    if (training) {
285      InitBackward();
286      GENERIC_2D_ARRAY<float> float_array;
287      if (!float_array.DeSerialize(fp)) {
288        return false;
289      }
290      FloatToDouble(float_array, updates_);
291      if (!float_array.DeSerialize(fp)) {
292        return false;
293      }
294    }
295    return true;
296  #endif
297  }
298  void WeightMatrix::MatrixDotVector(const TFloat *u, TFloat *v) const {
299    assert(!int_mode_);
300    MatrixDotVectorInternal(wf_, true, false, u, v);
301  }
302  void WeightMatrix::MatrixDotVector(const int8_t *u, TFloat *v) const {
303    assert(int_mode_);
304    if (IntSimdMatrix::intSimdMatrix) {
305      IntSimdMatrix::intSimdMatrix->matrixDotVectorFunction(wi_.dim1(), wi_.dim2(), &shaped_w_[0],
306                                                            &scales_[0], u, v);
307    } else {
308      IntSimdMatrix::MatrixDotVector(wi_, scales_, u, v);
309    }
310  }
311  void WeightMatrix::MultiplyAccumulate(const TFloat *v, TFloat *inout) {
312    assert(!int_mode_);
313    assert(wf_.dim1() == 1);
314    int n = wf_.dim2();
315    const TFloat *u = wf_[0];
316    for (int i = 0; i < n; ++i) {
317      inout[i] += u[i] * v[i];
318    }
319  }
320  void WeightMatrix::VectorDotMatrix(const TFloat *u, TFloat *v) const {
321    assert(!int_mode_);
322    MatrixDotVectorInternal(wf_t_, false, true, u, v);
323  }
324  void WeightMatrix::SumOuterTransposed(const TransposedArray &u, const TransposedArray &v,
325                                        bool in_parallel) {
326    assert(!int_mode_);
327    int num_outputs = dw_.dim1();
328    assert(u.dim1() == num_outputs);
329    assert(u.dim2() == v.dim2());
330    int num_inputs = dw_.dim2() - 1;
331    int num_samples = u.dim2();
332    assert(v.dim1() == num_inputs);
333  #ifdef _OPENMP
334  #  pragma omp parallel for num_threads(4) if (in_parallel)
335  #endif
336    for (int i = 0; i < num_outputs; ++i) {
337      TFloat *dwi = dw_[i];
338      const TFloat *ui = u[i];
339      for (int j = 0; j < num_inputs; ++j) {
340        dwi[j] = DotProduct(ui, v[j], num_samples);
341      }
342      TFloat total = 0;
343      for (int k = 0; k < num_samples; ++k) {
344        total += ui[k];
345      }
346      dwi[num_inputs] = total;
347    }
348  }
349  void WeightMatrix::Update(float learning_rate, float momentum, float adam_beta, int num_samples) {
350    assert(!int_mode_);
351    if (use_adam_ && momentum > 0.0f && num_samples > 0 && num_samples < kAdamCorrectionIterations) {
352      learning_rate *= sqrt(1.0f - pow(adam_beta, num_samples));
353      learning_rate /= 1.0f - pow(momentum, num_samples);
354    }
355    if (use_adam_ && num_samples > 0 && momentum > 0.0f) {
356      dw_sq_sum_.SumSquares(dw_, adam_beta);
357      dw_ *= learning_rate * (1.0f - momentum);
358      updates_ *= momentum;
359      updates_ += dw_;
360      wf_.AdamUpdate(updates_, dw_sq_sum_, learning_rate * kAdamEpsilon);
361    } else {
362      dw_ *= learning_rate;
363      updates_ += dw_;
364      if (momentum > 0.0f) {
365        wf_ += updates_;
366      }
367      if (momentum >= 0.0f) {
368        updates_ *= momentum;
369      }
370    }
371    wf_t_.Transpose(wf_);
372  }
373  void WeightMatrix::AddDeltas(const WeightMatrix &other) {
374    assert(dw_.dim1() == other.dw_.dim1());
375    assert(dw_.dim2() == other.dw_.dim2());
376    dw_ += other.dw_;
377  }
378  void WeightMatrix::CountAlternators(const WeightMatrix &other, TFloat *same,
379                                      TFloat *changed) const {
380    int num_outputs = updates_.dim1();
381    int num_inputs = updates_.dim2();
382    assert(num_outputs == other.updates_.dim1());
383    assert(num_inputs == other.updates_.dim2());
384    for (int i = 0; i < num_outputs; ++i) {
385      const TFloat *this_i = updates_[i];
386      const TFloat *other_i = other.updates_[i];
387      for (int j = 0; j < num_inputs; ++j) {
388        TFloat product = this_i[j] * other_i[j];
389        if (product < 0.0) {
390          *changed -= product;
391        } else {
392          *same += product;
393        }
394      }
395    }
396  }
397  const int kHistogramBuckets = 16;
398  static void HistogramWeight(TFloat weight, STATS *histogram) {
399    int bucket = kHistogramBuckets - 1;
400    if (weight != 0.0) {
401      TFloat logval = -log2(fabs(weight));
402      bucket = ClipToRange(IntCastRounded(logval), 0, kHistogramBuckets - 1);
403    }
404    histogram->add(bucket, 1);
405  }
406  void WeightMatrix::Debug2D(const char *msg) {
407    STATS histogram(0, kHistogramBuckets - 1);
408    if (int_mode_) {
409      for (int i = 0; i < wi_.dim1(); ++i) {
410        for (int j = 0; j < wi_.dim2(); ++j) {
411          HistogramWeight(wi_[i][j] * scales_[i], &histogram);
412        }
413      }
414    } else {
415      for (int i = 0; i < wf_.dim1(); ++i) {
416        for (int j = 0; j < wf_.dim2(); ++j) {
417          HistogramWeight(wf_[i][j], &histogram);
418        }
419      }
420    }
421    tprintf("%s\n", msg);
422    histogram.print();
423  }
424  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-ggen.cpp</h3>
            <pre><code>1  #include <gtest/gtest.h>
2  #include "Snap.h"
3  class GGenTest { };  
4  TEST(GGenTest, GenGrid) {
5    const int RowsStart = 1;
6    const int RowsEnd = 20;
7    const int ColsStart = 1;
8    const int ColsEnd = 15;
9    PUNGraph UNGraph;
10    PNGraph NGraph;
11    for (int Rows = RowsStart; Rows < RowsEnd; Rows++) {
12      for (int Cols = ColsStart; Cols < ColsEnd; Cols++) {
13        int NumEdges = 0;
14        if (Cols > 1) {
15          NumEdges += (Rows - 1) * 2;
16        }
17        else {
18          NumEdges += Rows - 1;
19        }
20        if (Rows > 1) {
21          NumEdges += (Cols - 1) * 2;
22        }
23        else {
24          NumEdges += Cols - 1;
25        }
26        if (Rows > 1 && Cols > 1) {
27          if (Cols >= 2) {
28            NumEdges += Cols - 2;
29          }
30          if (Rows >= 2) {
31            NumEdges += Rows - 2;
32          }
33          if (Rows >= 3 || Cols >= 3) {
34            NumEdges += (Rows-2) * (Cols-2) * 2;
35          }
36        }
37        UNGraph = TSnap::GenGrid<PUNGraph>(Rows, Cols, false);
38        EXPECT_FALSE(UNGraph->Empty());
39        EXPECT_TRUE(UNGraph->IsOk());
40        EXPECT_EQ(Rows*Cols, UNGraph->GetNodes());
41        EXPECT_EQ(NumEdges, UNGraph->GetEdges());
42        int NodeCount = 0;
43        int EdgeCount = 0;
44        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
45          NodeCount++;
46          for (int e = 0; e < NI.GetOutDeg(); e++) {
47            EdgeCount++;
48          }
49        }
50        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
51        EXPECT_EQ(EdgeCount/2, UNGraph->GetEdges());
52        EdgeCount = 0;
53        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
54          EdgeCount++;
55        }
56        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
57        NGraph = TSnap::GenGrid<PNGraph>(Rows, Cols, true);
58        EXPECT_FALSE(NGraph->Empty());
59        EXPECT_TRUE(NGraph->IsOk());
60        EXPECT_EQ(Rows*Cols, NGraph->GetNodes());
61        EXPECT_EQ(NumEdges, NGraph->GetEdges());
62        NodeCount = 0;
63        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
64          NodeCount++;
65          for (int e = 0; e < NI.GetOutDeg(); e++) {
66            EdgeCount++;
67          }
68        }
69        EXPECT_EQ(NodeCount, NGraph->GetNodes());
70        EXPECT_EQ(EdgeCount/2, NGraph->GetEdges());
71        EdgeCount = 0;
72        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
73          EdgeCount++;
74        }
75        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
76      } 
77    } 
78  }
79  TEST(GGenTest, GenStar) {
80    const int NNodesMax = 1000;
81    PUNGraph UNGraph;
82    PNGraph NGraph;
83    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
84      int NumEdges = NNodes-1;
85      UNGraph = TSnap::GenStar<PUNGraph>(NNodes, false);
86      EXPECT_FALSE(UNGraph->Empty());
87      EXPECT_TRUE(UNGraph->IsOk());
88      EXPECT_EQ(NumEdges, UNGraph->GetEdges());
89      int NodeCount = 0;
90      int EdgeCount = 0;
91      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
92        NodeCount++;
93        for (int e = 0; e < NI.GetOutDeg(); e++) {
94          EdgeCount++;
95        }
96      }
97      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
98      EXPECT_EQ(EdgeCount/2, UNGraph->GetEdges());
99      EdgeCount = 0;
100      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
101        EdgeCount++;
102      }
103      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
104      NGraph = TSnap::GenStar<PNGraph>(NNodes, true);
105      EXPECT_FALSE(NGraph->Empty());
106      EXPECT_TRUE(NGraph->IsOk());
107      EXPECT_EQ(NumEdges, NGraph->GetEdges());
108      NodeCount = 0;
109      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
110        NodeCount++;
111        for (int e = 0; e < NI.GetOutDeg(); e++) {
112          EdgeCount++;
113        }
114      }
115      EXPECT_EQ(NodeCount, NGraph->GetNodes());
116      EXPECT_EQ(EdgeCount/2, NGraph->GetEdges());
117      EdgeCount = 0;
118      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
119        EdgeCount++;
120      }
121      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
122    } 
123  }
124  TEST(GGenTest, GenCircle) {
125    const int NNodesMax = 500;
126    const int NodeOutDegMax = 5;
127    PUNGraph UNGraph;
128    PNGraph NGraph;
129    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
130      for (int NodeOutDeg = 1; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
131        UNGraph = TSnap::GenCircle<PUNGraph>(NNodes, NodeOutDeg, false);
132        EXPECT_FALSE(UNGraph->Empty());
133        EXPECT_TRUE(UNGraph->IsOk());
134        int NodeCount = 0;
135        int EdgeCount = 0;
136        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
137          NodeCount++;
138        }
139        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
140        EdgeCount = 0;
141        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
142          EdgeCount++;
143        }
144        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
145        NGraph = TSnap::GenCircle<PNGraph>(NNodes, NodeOutDeg, true);
146        EXPECT_FALSE(NGraph->Empty());
147        EXPECT_TRUE(NGraph->IsOk());
148        NodeCount = 0;
149        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
150          NodeCount++;
151        }
152        EXPECT_EQ(NodeCount, NGraph->GetNodes());
153        EdgeCount = 0;
154        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
155          EdgeCount++;
156        }
157        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
158      }
159    } 
160  }
161  TEST(GGenTest, GenFull) {
162    const int NNodesMax = 100;
163    PUNGraph UNGraph;
164    PNGraph NGraph;
165    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
166      UNGraph = TSnap::GenFull<PUNGraph>(NNodes);
167      EXPECT_FALSE(UNGraph->Empty());
168      EXPECT_TRUE(UNGraph->IsOk());
169      int NumEdges = NNodes * (NNodes - 1) / 2;
170      EXPECT_EQ(NumEdges, UNGraph->GetEdges());
171      int NodeCount = 0;
172      int EdgeCount = 0;
173      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
174        NodeCount++;
175      }
176      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
177      EdgeCount = 0;
178      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
179        EdgeCount++;
180      }
181      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
182      NGraph = TSnap::GenFull<PNGraph>(NNodes);
183      EXPECT_FALSE(NGraph->Empty());
184      EXPECT_TRUE(NGraph->IsOk());
185      NumEdges = NNodes * (NNodes - 1);
186      EXPECT_EQ(NumEdges, NGraph->GetEdges());
187      NodeCount = 0;
188      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
189        NodeCount++;
190      }
191      EXPECT_EQ(NodeCount, NGraph->GetNodes());
192      EdgeCount = 0;
193      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
194        EdgeCount++;
195      }
196      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
197    } 
198  }
199  TEST(GGenTest, GenTree) {
200    const int FanoutMax = 10;
201    const int LevelsMax = 5;
202    PUNGraph UNGraph;
203    PNGraph NGraph;
204    for (int Fanout = 2; Fanout < FanoutMax; Fanout++) {
205      for (int Levels = 1; Levels < LevelsMax; Levels++) {
206        UNGraph = TSnap::GenTree<PUNGraph>(Fanout, Levels, false);
207        EXPECT_FALSE(UNGraph->Empty());
208        EXPECT_TRUE(UNGraph->IsOk());
209        int NodeCount = 0;
210        int EdgeCount = 0;
211        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
212          NodeCount++;
213        }
214        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
215        EdgeCount = 0;
216        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
217          EdgeCount++;
218        }
219        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
220        NGraph = TSnap::GenTree<PNGraph>(Fanout, Levels, true, true);
221        EXPECT_FALSE(NGraph->Empty());
222        EXPECT_TRUE(NGraph->IsOk());
223        NodeCount = 0;
224        for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
225          NodeCount++;
226        }
227        EXPECT_EQ(NodeCount, NGraph->GetNodes());
228        EdgeCount = 0;
229        for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
230          EdgeCount++;
231        }
232        EXPECT_EQ(EdgeCount, NGraph->GetEdges());
233      } 
234    } 
235  }
236  TEST(GGenTest, GenBaraHierar) {
237    const int LevelsMax = 8;
238    PUNGraph UNGraph;
239    PNGraph NGraph;
240    for (int Levels = 1; Levels < LevelsMax; Levels++) {
241      UNGraph = TSnap::GenBaraHierar<PUNGraph>(Levels);
242      EXPECT_FALSE(UNGraph->Empty());
243      EXPECT_TRUE(UNGraph->IsOk());
244      int NodeCount = 0;
245      int EdgeCount = 0;
246      for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
247        NodeCount++;
248      }
249      EXPECT_EQ(NodeCount, UNGraph->GetNodes());
250      EdgeCount = 0;
251      for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
252        EdgeCount++;
253      }
254      EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
255      NGraph = TSnap::GenBaraHierar<PNGraph>(Levels);
256      EXPECT_FALSE(NGraph->Empty());
257      EXPECT_TRUE(NGraph->IsOk());
258      NodeCount = 0;
259      for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
260        NodeCount++;
261      }
262      EXPECT_EQ(NodeCount, NGraph->GetNodes());
263      EdgeCount = 0;
264      for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
265        EdgeCount++;
266      }
267      EXPECT_EQ(EdgeCount, NGraph->GetEdges());
268    } 
269  }
270  TEST(GGenTest, GenRndGnm) {
271    const int NNodesMax = 30;
<span onclick='openModal()' class='match'>272    const int NEdgesMax = 50;
273    int NodeCount = 0;
274    int EdgeCount = 0;
275    PUNGraph UNGraph;
276    PNGraph NGraph;
277    TInt::Rnd.PutSeed(0);
278    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
</span>279      for (int NEdges = 0; NEdges < NEdgesMax; NEdges++) {
280        if (NNodes * (NNodes-1) / 2 >= NEdges) {
281          UNGraph = TSnap::GenRndGnm<PUNGraph>(NNodes, NEdges, false, TInt::Rnd);
282          EXPECT_FALSE(UNGraph->Empty());
283          EXPECT_TRUE(UNGraph->IsOk());
284          NodeCount = 0;
285          EdgeCount = 0;
286          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
287            NodeCount++;
288          }
289          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
290          EdgeCount = 0;
291          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
292            EdgeCount++;
293          }
294          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
295        }
296        else if (NNodes * (NNodes-1) >= NEdges) {
297          NGraph = TSnap::GenRndGnm<PNGraph>(NNodes, NEdges, true, TInt::Rnd);
298          EXPECT_FALSE(NGraph->Empty());
299          EXPECT_TRUE(NGraph->IsOk());
300          NodeCount = 0;
301          for (TNGraph::TNodeI NI = NGraph->BegNI(); NI < NGraph->EndNI(); NI++) {
302            NodeCount++;
303          }
304          EXPECT_EQ(NodeCount, NGraph->GetNodes());
305          EdgeCount = 0;
306          for (TNGraph::TEdgeI NI = NGraph->BegEI(); NI < NGraph->EndEI(); NI++) {
307            EdgeCount++;
308          }
309          EXPECT_EQ(EdgeCount, NGraph->GetEdges());
310        }
311      } 
312    } 
313  }
314  TEST(GGenTest, GenRndBipart) {
315    const int LeftNodesMin = 8;
316    const int LeftNodesMax = 20;
317    const int RightNodesMin = 8;
318    const int RightNodesMax = 50;
319    const int EdgesMin = 5;
320    const int EdgesMax = 30;
321    PBPGraph Graph;
322    TInt::Rnd.PutSeed(0);
323    for (int LeftNodes = LeftNodesMin; LeftNodes < LeftNodesMax; LeftNodes++) {
324      for (int RightNodes = RightNodesMin; RightNodes < RightNodesMax; RightNodes++) {
325        for (int Edges = EdgesMin;  Edges < EdgesMax; Edges++) {
326          if (Edges > LeftNodes * RightNodes) {
327            continue;
328          }
329          Graph = TSnap::GenRndBipart(LeftNodes, RightNodes, Edges, TInt::Rnd);
330          EXPECT_FALSE(Graph->Empty());
331          int NodeCount = 0;
332          int EdgeCount = 0;
333          for (TBPGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
334            NodeCount++;
335          }
336          EXPECT_EQ(NodeCount, Graph->GetNodes());
337          EdgeCount = 0;
338          for (TBPGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
339            EdgeCount++;
340          }
341          EXPECT_EQ(EdgeCount, Graph->GetEdges());
342        } 
343      } 
344    } 
345  }
346  TEST(GGenTest, GenRndPowerLaw) {
347    const int NNodesMin = 10;
348    const int NNodesMax = 1000;
349    const double PowerExpMin = 2.0;
350    const double PowerExpMax = 3.0;
351    int NodeCount = 0;
352    int EdgeCount = 0;
353    PUNGraph UNGraph;
354    TInt::Rnd.PutSeed(0);
355    for (int NNodes = NNodesMin; NNodes <= NNodesMax; NNodes += (NNodesMax - NNodesMin)/2) {
356      for (double PowerExp = PowerExpMin; PowerExp <= PowerExpMax; PowerExp += 1.0) {
357        UNGraph = TSnap::GenRndPowerLaw(NNodes, PowerExp);
358        EXPECT_FALSE(UNGraph->Empty());
359        EXPECT_TRUE(UNGraph->IsOk());
360        NodeCount = 0;
361        EdgeCount = 0;
362        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
363          NodeCount++;
364        }
365        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
366        EdgeCount = 0;
367        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
368          EdgeCount++;
369        }
370        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
371      } 
372    } 
373  }
374  TEST(GGenTest, DISABLED_GenDegSeq) {
375    const int NNodesMax = 15;
376    const int NumIterations = 10;  
377    PUNGraph UNGraph;
378    TIntV DegSeqV;
379    TInt::Rnd.PutSeed(0);
380    int NodeCount = 0;
381    int EdgeCount = 0;
382    for (int i = 0; i < NumIterations; i++) {
383      for (int NNodes = 4; NNodes < NNodesMax; NNodes+=NNodesMax/5) {
384        DegSeqV.Gen(NNodes);
385        int DegSum = 0;
386        for (int n = 0; n < DegSeqV.Len()/4; n++) {
387          DegSeqV[n] = TInt::Rnd.GetUniDevInt(1, NNodes/2);
388          DegSum += DegSeqV[n];
389        }
390        for (int n = DegSeqV.Len()/4; n < DegSeqV.Len(); n++) {
391          DegSeqV[n] = 1;
392          DegSum += DegSeqV[n];
393        }
394        if (DegSum % 2 != 0) {
395          DegSeqV[(int)TInt::Rnd.GetUniDevInt(NNodes)]++;
396        }
397        DegSeqV.Sort();
398        DegSeqV.Reverse();
399        printf("NNodes=%d, ", NNodes);
400        printf("DegSeqV = { ");
401        for (int i = 0; i < DegSeqV.Len(); i++) {
402          printf("%d ", (int)DegSeqV[i]);
403        }
404        printf("}\n");
405        UNGraph = TSnap::GenDegSeq(DegSeqV);
406        EXPECT_FALSE(UNGraph->Empty());
407        EXPECT_TRUE(UNGraph->IsOk());
408        NodeCount = 0;
409        EdgeCount = 0;
410        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
411          NodeCount++;
412        }
413        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
414        EdgeCount = 0;
415        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
416          EdgeCount++;
417        }
418        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
419      }
420    }
421  }
422  TEST(GGenTest, GenPrefAttach) {
423    const int NNodesMax = 100;
424    const int NodeOutDegMax = 15;
425    PUNGraph UNGraph;
426    for (int NNodes = 0; NNodes < NNodesMax; NNodes++) {
427      for (int NodeOutDeg = 0; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
428        int NodeCount = 0;
429        int EdgeCount = 0;
430        UNGraph = TSnap::GenPrefAttach(NNodes, NodeOutDeg);
431        EXPECT_FALSE(UNGraph->Empty());
432        EXPECT_TRUE(UNGraph->IsOk());
433        NodeCount = 0;
434        EdgeCount = 0;
435        for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
436          NodeCount++;
437        }
438        EXPECT_EQ(NodeCount, UNGraph->GetNodes());
439        EdgeCount = 0;
440        for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
441          EdgeCount++;
442        }
443        EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
444      } 
445    } 
446  }
447  TEST(GGenTest, GenGeoPrefAttach) {
448    const int NNodesMax = 100;
449    const int NodeOutDegMax = 15;
450    const double BetaMax = 2.0;
451    PUNGraph UNGraph;
452    PNGraph NGraph;
453    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
454      for (int NodeOutDeg = 0; NodeOutDeg < NodeOutDegMax; NodeOutDeg++) {
455        for (double Beta = -1*BetaMax; Beta < BetaMax; Beta += 0.2) {
456          int NodeCount = 0;
457          int EdgeCount = 0;
458          UNGraph = TSnap::GenGeoPrefAttach(NNodes, NodeOutDeg, Beta);
459          EXPECT_FALSE(UNGraph->Empty());
460          EXPECT_TRUE(UNGraph->IsOk());
461          NodeCount = 0;
462          EdgeCount = 0;
463          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
464            NodeCount++;
465          }
466          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
467          EdgeCount = 0;
468          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
469            EdgeCount++;
470          }
471          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
472        } 
473      } 
474    } 
475  }
476  TEST(GGenTest, GenSmallWorld) {
477    const int NNodesMax = 1000;
478    const double RewireProbMax = 1.0;
479    PUNGraph UNGraph;
480    for (int NNodes = 1; NNodes < NNodesMax; NNodes+=NNodesMax/20) {
481      for (int NodeOutDeg = 1; NodeOutDeg < 10; NodeOutDeg++) {
482        for (double RewireProb = 0.0; RewireProb <= RewireProbMax; RewireProb += 0.2) {
483          int NodeCount = 0;
484          int EdgeCount = 0;
485          if (NNodes <= NodeOutDeg) {
486            continue;
487          }
488          UNGraph = TSnap::GenSmallWorld(NNodes, NodeOutDeg, RewireProb);
489          EXPECT_FALSE(UNGraph->Empty());
490          EXPECT_TRUE(UNGraph->IsOk());
491          NodeCount = 0;
492          EdgeCount = 0;
493          for (TUNGraph::TNodeI NI = UNGraph->BegNI(); NI < UNGraph->EndNI(); NI++) {
494            NodeCount++;
495          }
496          EXPECT_EQ(NodeCount, UNGraph->GetNodes());
497          EdgeCount = 0;
498          for (TUNGraph::TEdgeI NI = UNGraph->BegEI(); NI < UNGraph->EndEI(); NI++) {
499            EdgeCount++;
500          }
501          EXPECT_EQ(EdgeCount, UNGraph->GetEdges());
502        } 
503      } 
504    } 
505  }
506  TEST(GGenTest, GenForestFire) {
507    const int NNodesMax = 1000;
508    const double FwdProbMax = 1.0;
509    const double BckProbMax = 1.0;
510    for (int NNodes = 0; NNodes < NNodesMax; NNodes += NNodesMax/2) {
511      for (double FwdProb = 0.1; FwdProb < FwdProbMax; FwdProb += 0.5) {
512        for (double BckProb = 0.1; BckProb < BckProbMax; BckProb += 0.5) {
513          int NodeCount = 0;
514          int EdgeCount = 0;
515          PNGraph Graph = TSnap::GenForestFire(NNodes, FwdProb, BckProb);
516          if (0 != NNodes) {
517            EXPECT_FALSE(Graph->Empty());
518          }
519          EXPECT_TRUE(Graph->IsOk());
520          NodeCount = 0;
521          EdgeCount = 0;
522          for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
523            NodeCount++;
524          }
525          EXPECT_EQ(NodeCount, Graph->GetNodes());
526          EdgeCount = 0;
527          for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
528            EdgeCount++;
529          }
530          EXPECT_EQ(EdgeCount, Graph->GetEdges());
531        } 
532      } 
533    } 
534  }
535  TEST(GGenTest, GenCopyModel) {
536    const int NNodesMax = 100;
537    const double BetaMax = 2.0;
538    PNGraph Graph;
539    for (int NNodes = 0; NNodes < NNodesMax; NNodes++) {
540      for (double Beta = -1*BetaMax; Beta < BetaMax; Beta += 0.2) {
541        int NodeCount = 0;
542        int EdgeCount = 0;
543        Graph = TSnap::GenCopyModel(NNodes, Beta);
544        EXPECT_FALSE(Graph->Empty());
545        EXPECT_TRUE(Graph->IsOk());
546        NodeCount = 0;
547        EdgeCount = 0;
548        for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
549          NodeCount++;
550        }
551        EXPECT_EQ(NodeCount, Graph->GetNodes());
552        EdgeCount = 0;
553        for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
554          EdgeCount++;
555        }
556        EXPECT_EQ(EdgeCount, Graph->GetEdges());
557      } 
558    } 
559  }
560  TEST(GGenTest, GenRMat) {
561    const int NNodesMax = 10000;
562    const int NEdgesMax = 100;
563    int NodeCount = 0;
564    int EdgeCount = 0;
565    PNGraph Graph;
566    TInt::Rnd.PutSeed(0);
567    TFlt A, B, C;
568    TFltTrV Vals;
569    Vals.Add(TFltTr(0.15, 0.2, 0.35));
570    Vals.Add(TFltTr(0.2, 0.2, 0.55));
571    Vals.Add(TFltTr(0.4, 0.15, 0.2));
572    for (int NNodes = 50; NNodes < NNodesMax; NNodes+=NNodesMax/2) {
573      for (int NEdges = 5; NEdges < NEdgesMax; NEdges+=NEdgesMax/4) {
574        for (int i = 0; i < Vals.Len(); i++) {
575          A = Vals[i].Val1;
576          B = Vals[i].Val2;
577          C = Vals[i].Val3;
578          Graph = TSnap::GenRMat(NNodes, NEdges, A, B, C);
579          EXPECT_FALSE(Graph->Empty());
580          EXPECT_TRUE(Graph->IsOk());
581          NodeCount = 0;
582          EdgeCount = 0;
583          for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
584            NodeCount++;
585          }
586          EXPECT_EQ(NodeCount, Graph->GetNodes());
587          EdgeCount = 0;
588          for (TNGraph::TEdgeI NI = Graph->BegEI(); NI < Graph->EndEI(); NI++) {
589            EdgeCount++;
590          }
591          EXPECT_EQ(EdgeCount, Graph->GetEdges());
592        }
593      } 
594    } 
595  }
596  template <class PGraph> void TestRewire(const PGraph& Graph) {
597    PGraph GraphOut;
598    TIntPrV DegToCntV;
599    TIntPrV DegToCntV1;
600    int CntLoops;
601    GraphOut = TSnap::GenRewire(Graph, 10, TInt::Rnd);
602    TSnap::GetDegCnt(Graph, DegToCntV);
603    TSnap::GetDegCnt(GraphOut, DegToCntV1);
604    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
605    for (int i = 0; i < DegToCntV.Len(); i++) {
606      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
607    }
608    TSnap::GetInDegCnt(Graph, DegToCntV);
609    TSnap::GetInDegCnt(GraphOut, DegToCntV1);
610    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
611    for (int i = 0; i < DegToCntV.Len(); i++) {
612      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
613    }
614    TSnap::GetOutDegCnt(Graph, DegToCntV);
615    TSnap::GetOutDegCnt(GraphOut, DegToCntV1);
616    EXPECT_EQ(DegToCntV.Len(), DegToCntV1.Len());
617    for (int i = 0; i < DegToCntV.Len(); i++) {
618      EXPECT_EQ(DegToCntV[i].Val1.Val, DegToCntV1[i].Val1.Val);
619    }
620    CntLoops = TSnap::CntSelfEdges<PGraph>(GraphOut);
621    EXPECT_EQ(CntLoops, 0);
622  }
623  TEST(GGenRewire, GenRewire) {
624    PNGraph GraphFF;
625    PNGraph Graph;
626    PUNGraph UGraph;
627    const int NNodes = 100000;
628    const double FwdProb = 0.35;
629    const double BckProb = 0.32;
630    GraphFF = TSnap::GenForestFire(NNodes, FwdProb, BckProb);
631    TestRewire<PNGraph>(GraphFF);
632    UGraph = TSnap::ConvertGraph<PUNGraph, PNGraph>(GraphFF);
633    TestRewire<PUNGraph>(UGraph);
634  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-weightmatrix.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-test-ggen.cpp</div>
                <div class="column column_space"><pre><code>101    int old_no = wf_.dim1();
102    int new_no = code_map.size();
103    int ni = wf_.dim2();
104    std::vector<TFloat> means(ni, 0.0);
105    for (int c = 0; c < old_no; ++c) {
</pre></code></div>
                <div class="column column_space"><pre><code>272    const int NEdgesMax = 50;
273    int NodeCount = 0;
274    int EdgeCount = 0;
275    PUNGraph UNGraph;
276    PNGraph NGraph;
277    TInt::Rnd.PutSeed(0);
278    for (int NNodes = 1; NNodes < NNodesMax; NNodes++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    