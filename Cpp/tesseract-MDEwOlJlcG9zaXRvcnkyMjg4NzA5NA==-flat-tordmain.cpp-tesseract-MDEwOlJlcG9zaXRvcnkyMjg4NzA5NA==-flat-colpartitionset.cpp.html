
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tordmain.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "tordmain.h"
6  #include "arrayaccess.h" 
7  #include "blobbox.h"     
8  #include "ccstruct.h"    
9  #include "clst.h"        
10  #include "coutln.h"      
11  #include "drawtord.h"    
12  #include "edgblob.h"     
13  #include "errcode.h"     
14  #include "makerow.h"     
15  #include "ocrblock.h"    
16  #include "ocrrow.h"      
17  #include "params.h"      
18  #include "pdblock.h"     
19  #include "points.h"      
20  #include "polyblk.h"     
21  #include "quadratc.h"    
22  #include "quspline.h"    
23  #include "rect.h"        
24  #include "scrollview.h"  
25  #include "statistc.h"    
26  #include "stepblob.h"    
27  #include "textord.h"     
28  #include "tprintf.h"     
29  #include "werd.h"        
30  #include <allheaders.h> 
31  #include <cfloat>  
32  #include <cmath>   
33  #include <cstdint> 
34  #include <memory>
35  namespace tesseract {
36  #define MAX_NEAREST_DIST 600 
37  void SetBlobStrokeWidth(Image pix, BLOBNBOX *blob) {
38    int pix_height = pixGetHeight(pix);
39    const TBOX &box = blob->bounding_box();
40    int width = box.width();
41    int height = box.height();
42    Box *blob_pix_box = boxCreate(box.left(), pix_height - box.top(), width, height);
43    Image pix_blob = pixClipRectangle(pix, blob_pix_box, nullptr);
44    boxDestroy(&blob_pix_box);
45    Image dist_pix = pixDistanceFunction(pix_blob, 4, 8, L_BOUNDARY_BG);
46    pix_blob.destroy();
47    uint32_t *data = pixGetData(dist_pix);
48    int wpl = pixGetWpl(dist_pix);
49    STATS h_stats(0, width);
50    for (int y = 0; y < height; ++y) {
51      uint32_t *pixels = data + y * wpl;
52      int prev_pixel = 0;
53      int pixel = GET_DATA_BYTE(pixels, 0);
54      for (int x = 1; x < width; ++x) {
55        int next_pixel = GET_DATA_BYTE(pixels, x);
56        if (prev_pixel < pixel && (y == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) &&
57            (y == height - 1 || pixel == GET_DATA_BYTE(pixels + wpl, x - 1))) {
58          if (pixel > next_pixel) {
59            h_stats.add(pixel * 2 - 1, 1);
60          } else if (pixel == next_pixel && x + 1 < width && pixel > GET_DATA_BYTE(pixels, x + 1)) {
61            h_stats.add(pixel * 2, 1);
62          }
63        }
64        prev_pixel = pixel;
65        pixel = next_pixel;
66      }
67    }
68    STATS v_stats(0, height);
69    for (int x = 0; x < width; ++x) {
70      int prev_pixel = 0;
71      int pixel = GET_DATA_BYTE(data, x);
72      for (int y = 1; y < height; ++y) {
73        uint32_t *pixels = data + y * wpl;
74        int next_pixel = GET_DATA_BYTE(pixels, x);
75        if (prev_pixel < pixel && (x == 0 || pixel == GET_DATA_BYTE(pixels - wpl, x - 1)) &&
76            (x == width - 1 || pixel == GET_DATA_BYTE(pixels - wpl, x + 1))) {
77          if (pixel > next_pixel) {
78            v_stats.add(pixel * 2 - 1, 1);
79          } else if (pixel == next_pixel && y + 1 < height &&
80                     pixel > GET_DATA_BYTE(pixels + wpl, x)) {
81            v_stats.add(pixel * 2, 1);
82          }
83        }
84        prev_pixel = pixel;
85        pixel = next_pixel;
86      }
87    }
88    dist_pix.destroy();
89    if (h_stats.get_total() >= (width + height) / 4) {
90      blob->set_horz_stroke_width(h_stats.ile(0.5f));
91      if (v_stats.get_total() >= (width + height) / 4) {
92        blob->set_vert_stroke_width(v_stats.ile(0.5f));
93      } else {
94        blob->set_vert_stroke_width(0.0f);
95      }
96    } else {
97      if (v_stats.get_total() >= (width + height) / 4 || v_stats.get_total() > h_stats.get_total()) {
98        blob->set_horz_stroke_width(0.0f);
99        blob->set_vert_stroke_width(v_stats.ile(0.5f));
100      } else {
101        blob->set_horz_stroke_width(h_stats.get_total() > 2 ? h_stats.ile(0.5f) : 0.0f);
102        blob->set_vert_stroke_width(0.0f);
103      }
104    }
105  }
106  void assign_blobs_to_blocks2(Image pix,
107                               BLOCK_LIST *blocks,           
108                               TO_BLOCK_LIST *port_blocks) { 
109    BLOCK_IT block_it = blocks;
110    C_BLOB_IT blob_it;       
111    BLOBNBOX_IT port_box_it; 
112    TO_BLOCK_IT port_block_it = port_blocks;
113    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
114      auto block = block_it.data();
115      auto port_block = new TO_BLOCK(block);
116      port_box_it.set_to_list(&port_block->blobs);
117      blob_it.set_to_list(block->blob_list());
118      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
119        auto blob = blob_it.extract();
120        auto newblob = new BLOBNBOX(blob); 
121        newblob->set_owns_cblob(true);
122        SetBlobStrokeWidth(pix, newblob);
123        port_box_it.add_after_then_move(newblob);
124      }
125      port_box_it.set_to_list(&port_block->noise_blobs);
126      blob_it.set_to_list(block->reject_blobs());
127      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
128        auto blob = blob_it.extract();
129        auto newblob = new BLOBNBOX(blob); 
130        newblob->set_owns_cblob(true);
131        SetBlobStrokeWidth(pix, newblob);
132        port_box_it.add_after_then_move(newblob);
133      }
134      port_block_it.add_after_then_move(port_block);
135    }
136  }
137  void Textord::find_components(Image pix, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks) {
138    int width = pixGetWidth(pix);
139    int height = pixGetHeight(pix);
140    if (width > INT16_MAX || height > INT16_MAX) {
141      tprintf("Input image too large! (%d, %d)\n", width, height);
142      return; 
143    }
144    BLOCK_IT block_it(blocks); 
145    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
146      BLOCK *block = block_it.data();
147      if (block->pdblk.poly_block() == nullptr || block->pdblk.poly_block()->IsText()) {
148        extract_edges(pix, block);
149      }
150    }
151    assign_blobs_to_blocks2(pix, blocks, to_blocks);
152    ICOORD page_tr(width, height);
153    filter_blobs(page_tr, to_blocks, !textord_test_landscape);
154  }
155  void Textord::filter_blobs(ICOORD page_tr,        
156                             TO_BLOCK_LIST *blocks, 
157                             bool testing_on) {     
158    TO_BLOCK_IT block_it = blocks;                  
159    TO_BLOCK *block;                                
160  #ifndef GRAPHICS_DISABLED
161    if (to_win != nullptr) {
162      to_win->Clear();
163    }
164  #endif 
165    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
166      block = block_it.data();
167      block->line_size = filter_noise_blobs(&block->blobs, &block->noise_blobs, &block->small_blobs,
168                                            &block->large_blobs);
169      if (block->line_size == 0) {
170        block->line_size = 1;
171      }
172      block->line_spacing =
173          block->line_size *
174          (tesseract::CCStruct::kDescenderFraction + tesseract::CCStruct::kXHeightFraction +
175           2 * tesseract::CCStruct::kAscenderFraction) /
176          tesseract::CCStruct::kXHeightFraction;
177      block->line_size *= textord_min_linesize;
178      block->max_blob_size = block->line_size * textord_excess_blobsize;
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_blobs && testing_on) {
181        if (to_win == nullptr) {
182          create_to_win(page_tr);
183        }
184        block->plot_graded_blobs(to_win);
185      }
186      if (textord_show_boxes && testing_on) {
187        if (to_win == nullptr) {
188          create_to_win(page_tr);
189        }
190        plot_box_list(to_win, &block->noise_blobs, ScrollView::WHITE);
191        plot_box_list(to_win, &block->small_blobs, ScrollView::WHITE);
192        plot_box_list(to_win, &block->large_blobs, ScrollView::WHITE);
193        plot_box_list(to_win, &block->blobs, ScrollView::WHITE);
194      }
195  #endif 
196    }
197  }
198  float Textord::filter_noise_blobs(BLOBNBOX_LIST *src_list,     
199                                    BLOBNBOX_LIST *noise_list,   
200                                    BLOBNBOX_LIST *small_list,   
201                                    BLOBNBOX_LIST *large_list) { 
202    int16_t height;                                              
203    int16_t width;                                               
204    BLOBNBOX *blob;                                              
205    float initial_x;                                             
206    BLOBNBOX_IT src_it = src_list;                               
207    BLOBNBOX_IT noise_it = noise_list;
208    BLOBNBOX_IT small_it = small_list;
209    BLOBNBOX_IT large_it = large_list;
210    STATS size_stats(0, MAX_NEAREST_DIST - 1);
211    float min_y; 
212    float max_y;
213    float max_x;
214    float max_height; 
215    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
216      blob = src_it.data();
217      if (blob->bounding_box().height() < textord_max_noise_size) {
218        noise_it.add_after_then_move(src_it.extract());
219      } else if (blob->enclosed_area() >= blob->bounding_box().height() *
220                                              blob->bounding_box().width() *
221                                              textord_noise_area_ratio) {
222        small_it.add_after_then_move(src_it.extract());
223      }
224    }
225    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
226      size_stats.add(src_it.data()->bounding_box().height(), 1);
227    }
228    initial_x = size_stats.ile(textord_initialx_ile);
229    max_y = ceil(initial_x *
230                 (tesseract::CCStruct::kDescenderFraction + tesseract::CCStruct::kXHeightFraction +
231                  2 * tesseract::CCStruct::kAscenderFraction) /
232                 tesseract::CCStruct::kXHeightFraction);
233    min_y = std::floor(initial_x / 2);
234    max_x = ceil(initial_x * textord_width_limit);
235    small_it.move_to_first();
236    for (small_it.mark_cycle_pt(); !small_it.cycled_list(); small_it.forward()) {
237      height = small_it.data()->bounding_box().height();
238      if (height > max_y) {
239        large_it.add_after_then_move(small_it.extract());
240      } else if (height >= min_y) {
241        src_it.add_after_then_move(small_it.extract());
242      }
243    }
244    size_stats.clear();
245    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
246      height = src_it.data()->bounding_box().height();
247      width = src_it.data()->bounding_box().width();
248      if (height < min_y) {
249        small_it.add_after_then_move(src_it.extract());
250      } else if (height > max_y || width > max_x) {
251        large_it.add_after_then_move(src_it.extract());
252      } else {
253        size_stats.add(height, 1);
254      }
255    }
256    max_height = size_stats.ile(textord_initialasc_ile);
257    max_height *= tesseract::CCStruct::kXHeightCapRatio;
258    if (max_height > initial_x) {
259      initial_x = max_height;
260    }
261    return initial_x;
262  }
263  void Textord::cleanup_nontext_block(BLOCK *block) {
264    ROW_IT row_it(block->row_list());
265    if (row_it.empty()) {
266      const TBOX &box = block->pdblk.bounding_box();
267      float height = box.height();
268      int32_t xstarts[2] = {box.left(), box.right()};
269      double coeffs[3] = {0.0, 0.0, static_cast<double>(box.bottom())};
270      ROW *row = new ROW(1, xstarts, coeffs, height / 2.0f, height / 4.0f, height / 4.0f, 0, 1);
271      row_it.add_after_then_move(row);
272    }
273    for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
274      ROW *row = row_it.data();
275      WERD_IT w_it(row->word_list());
276      if (w_it.empty()) {
277        TBOX box = block->row_list()->singleton() ? block->pdblk.bounding_box() : row->bounding_box();
278        C_BLOB *blob = C_BLOB::FakeBlob(box);
<span onclick='openModal()' class='match'>279        C_BLOB_LIST blobs;
280        C_BLOB_IT blob_it(&blobs);
281        blob_it.add_after_then_move(blob);
282        WERD *word = new WERD(&blobs, 0, nullptr);
</span>283        w_it.add_after_then_move(word);
284      }
285      for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
286        WERD *word = w_it.data();
287        ASSERT_HOST(!word->cblob_list()->empty());
288      }
289      row->recalc_bounding_box();
290    }
291  }
292  void Textord::cleanup_blocks(bool clean_noise, BLOCK_LIST *blocks) {
293    BLOCK_IT block_it = blocks; 
294    ROW_IT row_it;              
295    int num_rows = 0;
296    int num_rows_all = 0;
297    int num_blocks = 0;
298    int num_blocks_all = 0;
299    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
300      BLOCK *block = block_it.data();
301      if (block->pdblk.poly_block() != nullptr && !block->pdblk.poly_block()->IsText()) {
302        cleanup_nontext_block(block);
303        continue;
304      }
305      num_rows = 0;
306      num_rows_all = 0;
307      if (clean_noise) {
308        row_it.set_to_list(block->row_list());
309        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
310          ROW *row = row_it.data();
311          ++num_rows_all;
312          clean_small_noise_from_words(row);
313          if ((textord_noise_rejrows && !row->word_list()->empty() && clean_noise_from_row(row)) ||
314              row->word_list()->empty()) {
315            delete row_it.extract(); 
316          } else {
317            if (textord_noise_rejwords) {
318              clean_noise_from_words(row_it.data());
319            }
320            if (textord_blshift_maxshift >= 0) {
321              tweak_row_baseline(row, textord_blshift_maxshift, textord_blshift_xfraction);
322            }
323            ++num_rows;
324          }
325        }
326      }
327      if (block->row_list()->empty()) {
328        delete block_it.extract(); 
329      } else {
330        ++num_blocks;
331      }
332      ++num_blocks_all;
333      if (textord_noise_debug) {
334        tprintf("cleanup_blocks: # rows = %d / %d\n", num_rows, num_rows_all);
335      }
336    }
337    if (textord_noise_debug) {
338      tprintf("cleanup_blocks: # blocks = %d / %d\n", num_blocks, num_blocks_all);
339    }
340  }
341  bool Textord::clean_noise_from_row( 
342      ROW *row                        
343  ) {
344    bool testing_on;
345    TBOX blob_box;            
346    C_BLOB *blob;             
347    C_OUTLINE *outline;       
348    WERD *word;               
349    int32_t blob_size;        
350    int32_t trans_count = 0;  
351    int32_t trans_threshold;  
352    int32_t dot_count;        
353    int32_t norm_count;       
354    int32_t super_norm_count; 
355    WERD_IT word_it = row->word_list();
356    C_BLOB_IT blob_it;   
357    C_OUTLINE_IT out_it; 
358    testing_on = textord_test_y > row->base_line(textord_test_x) && textord_show_blobs &&
359                 textord_test_y < row->base_line(textord_test_x) + row->x_height();
360    dot_count = 0;
361    norm_count = 0;
362    super_norm_count = 0;
363    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
364      word = word_it.data(); 
365      blob_it.set_to_list(word->cblob_list());
366      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
367        blob = blob_it.data();
368        if (!word->flag(W_DONT_CHOP)) {
369          out_it.set_to_list(blob->out_list());
370          for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
371            outline = out_it.data();
372            blob_box = outline->bounding_box();
373            blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
374            if (blob_size < textord_noise_sizelimit * row->x_height()) {
375              dot_count++; 
376            }
377            if (!outline->child()->empty() &&
378                blob_box.height() < (1 + textord_noise_syfract) * row->x_height() &&
379                blob_box.height() > (1 - textord_noise_syfract) * row->x_height() &&
380                blob_box.width() < (1 + textord_noise_sxfract) * row->x_height() &&
381                blob_box.width() > (1 - textord_noise_sxfract) * row->x_height()) {
382              super_norm_count++; 
383            }
384          }
385        } else {
386          super_norm_count++;
387        }
388        blob_box = blob->bounding_box();
389        blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
390        if (blob_size >= textord_noise_sizelimit * row->x_height() &&
391            blob_size < row->x_height() * 2) {
392          trans_threshold = blob_size / textord_noise_sizefraction;
393          trans_count = blob->count_transitions(trans_threshold);
394          if (trans_count < textord_noise_translimit) {
395            norm_count++;
396          }
397        } else if (blob_box.height() > row->x_height() * 2 &&
398                   (!word_it.at_first() || !blob_it.at_first())) {
399          dot_count += 2;
400        }
401        if (testing_on) {
402          tprintf("Blob at (%d,%d) -> (%d,%d), ols=%d, tc=%d, bldiff=%g\n", blob_box.left(),
403                  blob_box.bottom(), blob_box.right(), blob_box.top(), blob->out_list()->length(),
404                  trans_count, blob_box.bottom() - row->base_line(blob_box.left()));
405        }
406      }
407    }
408    if (textord_noise_debug) {
409      tprintf("Row ending at (%d,%g):", blob_box.right(), row->base_line(blob_box.right()));
410      tprintf(" R=%g, dc=%d, nc=%d, %s\n",
411              norm_count > 0 ? static_cast<float>(dot_count) / norm_count : 9999, dot_count,
412              norm_count,
413              dot_count > norm_count * textord_noise_normratio && dot_count > 2 ? "REJECTED"
414                                                                                : "ACCEPTED");
415    }
416    return super_norm_count < textord_noise_sncount &&
417           dot_count > norm_count * textord_noise_rowratio && dot_count > 2;
418  }
419  void Textord::clean_noise_from_words( 
420      ROW *row                          
421  ) {
422    TBOX blob_box;           
423    C_BLOB *blob;            
424    C_OUTLINE *outline;      
425    WERD *word;              
426    int32_t blob_size;       
427    int32_t trans_count;     
428    int32_t trans_threshold; 
429    int32_t dot_count;       
430    int32_t norm_count;      
431    int32_t dud_words;       
432    int32_t ok_words;        
433    int32_t word_index;      
434    WERD_IT word_it = row->word_list();
435    C_BLOB_IT blob_it;   
436    C_OUTLINE_IT out_it; 
437    ok_words = word_it.length();
438    if (ok_words == 0 || textord_no_rejects) {
439      return;
440    }
441    std::vector<int8_t> word_dud(ok_words);
442    dud_words = 0;
443    ok_words = 0;
444    word_index = 0;
445    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
446      word = word_it.data(); 
447      dot_count = 0;
448      norm_count = 0;
449      blob_it.set_to_list(word->cblob_list());
450      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
451        blob = blob_it.data();
452        if (!word->flag(W_DONT_CHOP)) {
453          out_it.set_to_list(blob->out_list());
454          for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
455            outline = out_it.data();
456            blob_box = outline->bounding_box();
457            blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
458            if (blob_size < textord_noise_sizelimit * row->x_height()) {
459              dot_count++; 
460            }
461            if (!outline->child()->empty() &&
462                blob_box.height() < (1 + textord_noise_syfract) * row->x_height() &&
463                blob_box.height() > (1 - textord_noise_syfract) * row->x_height() &&
464                blob_box.width() < (1 + textord_noise_sxfract) * row->x_height() &&
465                blob_box.width() > (1 - textord_noise_sxfract) * row->x_height()) {
466              norm_count++; 
467            }
468          }
469        } else {
470          norm_count++;
471        }
472        blob_box = blob->bounding_box();
473        blob_size = blob_box.width() > blob_box.height() ? blob_box.width() : blob_box.height();
474        if (blob_size >= textord_noise_sizelimit * row->x_height() &&
475            blob_size < row->x_height() * 2) {
476          trans_threshold = blob_size / textord_noise_sizefraction;
477          trans_count = blob->count_transitions(trans_threshold);
478          if (trans_count < textord_noise_translimit) {
479            norm_count++;
480          }
481        } else if (blob_box.height() > row->x_height() * 2 &&
482                   (!word_it.at_first() || !blob_it.at_first())) {
483          dot_count += 2;
484        }
485      }
486      if (dot_count > 2 && !word->flag(W_REP_CHAR)) {
487        if (dot_count > norm_count * textord_noise_normratio * 2) {
488          word_dud[word_index] = 2;
489        } else if (dot_count > norm_count * textord_noise_normratio) {
490          word_dud[word_index] = 1;
491        } else {
492          word_dud[word_index] = 0;
493        }
494      } else {
495        word_dud[word_index] = 0;
496      }
497      if (word_dud[word_index] == 2) {
498        dud_words++;
499      } else {
500        ok_words++;
501      }
502      word_index++;
503    }
504    word_index = 0;
505    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
506      if (word_dud[word_index] == 2 || (word_dud[word_index] == 1 && dud_words > ok_words)) {
507        word = word_it.data(); 
508        word->CleanNoise(textord_noise_sizelimit * row->x_height());
509      }
510      word_index++;
511    }
512  }
513  void Textord::clean_small_noise_from_words(ROW *row) {
514    WERD_IT word_it(row->word_list());
515    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
516      WERD *word = word_it.data();
517      int min_size = static_cast<int>(textord_noise_hfract * word->bounding_box().height() + 0.5);
518      C_BLOB_IT blob_it(word->cblob_list());
519      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
520        C_BLOB *blob = blob_it.data();
521        C_OUTLINE_IT out_it(blob->out_list());
522        for (out_it.mark_cycle_pt(); !out_it.cycled_list(); out_it.forward()) {
523          C_OUTLINE *outline = out_it.data();
524          outline->RemoveSmallRecursive(min_size, &out_it);
525        }
526        if (blob->out_list()->empty()) {
527          delete blob_it.extract();
528        }
529      }
530      if (word->cblob_list()->empty()) {
531        if (!word_it.at_last()) {
532          WERD *next_word = word_it.data_relative(1);
533          if (next_word->flag(W_FUZZY_NON)) {
534            next_word->set_flag(W_FUZZY_NON, false);
535          }
536        }
537        delete word_it.extract();
538      }
539    }
540  }
541  struct BlockGroup {
542    BlockGroup() : rotation(1.0f, 0.0f), angle(0.0f), min_xheight(1.0f) {}
543    explicit BlockGroup(BLOCK *block)
544        : bounding_box(block->pdblk.bounding_box())
545        , rotation(block->re_rotation())
546        , angle(block->re_rotation().angle())
547        , min_xheight(block->x_height()) {
548      blocks.push_back(block);
549    }
550    TBOX bounding_box;
551    FCOORD rotation;
552    float angle;
553    float min_xheight;
554    std::vector<BLOCK *> blocks;
555  };
556  void Textord::TransferDiacriticsToBlockGroups(BLOBNBOX_LIST *diacritic_blobs, BLOCK_LIST *blocks) {
557    const double kMaxAngleDiff = 0.01; 
558    std::vector<std::unique_ptr<BlockGroup>> groups;
559    BLOCK_IT bk_it(blocks);
560    for (bk_it.mark_cycle_pt(); !bk_it.cycled_list(); bk_it.forward()) {
561      BLOCK *block = bk_it.data();
562      if (block->pdblk.poly_block() != nullptr && !block->pdblk.poly_block()->IsText()) {
563        continue;
564      }
565      float block_angle = block->re_rotation().angle();
566      int best_g = 0;
567      float best_angle_diff = FLT_MAX;
568      for (const auto &group : groups) {
569        double angle_diff = std::fabs(block_angle - group->angle);
570        if (angle_diff > M_PI) {
571          angle_diff = fabs(angle_diff - 2.0 * M_PI);
572        }
573        if (angle_diff < best_angle_diff) {
574          best_angle_diff = angle_diff;
575          best_g = &group - &groups[0];
576        }
577      }
578      if (best_angle_diff > kMaxAngleDiff) {
579        groups.push_back(std::make_unique<BlockGroup>(block));
580      } else {
581        groups[best_g]->blocks.push_back(block);
582        groups[best_g]->bounding_box += block->pdblk.bounding_box();
583        float x_height = block->x_height();
584        if (x_height < groups[best_g]->min_xheight) {
585          groups[best_g]->min_xheight = x_height;
586        }
587      }
588    }
589    std::vector<std::unique_ptr<WordWithBox>> word_ptrs;
590    for (const auto &group : groups) {
591      if (group->bounding_box.null_box()) {
592        continue;
593      }
594      WordGrid word_grid(group->min_xheight, group->bounding_box.botleft(),
595                         group->bounding_box.topright());
596      for (auto b : group->blocks) {
597        ROW_IT row_it(b->row_list());
598        for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
599          ROW *row = row_it.data();
600          WERD_IT w_it(row->word_list());
601          for (w_it.mark_cycle_pt(); !w_it.cycled_list(); w_it.forward()) {
602            WERD *word = w_it.data();
603            auto box_word = std::make_unique<WordWithBox>(word);
604            word_grid.InsertBBox(true, true, box_word.get());
605            word_ptrs.emplace_back(std::move(box_word));
606          }
607        }
608      }
609      FCOORD rotation = group->rotation;
610      rotation.set_y(-rotation.y());
611      TransferDiacriticsToWords(diacritic_blobs, rotation, &word_grid);
612    }
613  }
614  void Textord::TransferDiacriticsToWords(BLOBNBOX_LIST *diacritic_blobs, const FCOORD &rotation,
615                                          WordGrid *word_grid) {
616    WordSearch ws(word_grid);
617    BLOBNBOX_IT b_it(diacritic_blobs);
618    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
619      BLOBNBOX *blobnbox = b_it.data();
620      TBOX blob_box = blobnbox->bounding_box();
621      blob_box.rotate(rotation);
622      ws.StartRectSearch(blob_box);
623      WordWithBox *best_above_word = nullptr;
624      WordWithBox *best_below_word = nullptr;
625      int best_above_distance = 0;
626      int best_below_distance = 0;
627      for (WordWithBox *word = ws.NextRectSearch(); word != nullptr; word = ws.NextRectSearch()) {
628        if (word->word()->flag(W_REP_CHAR)) {
629          continue;
630        }
631        TBOX word_box = word->true_bounding_box();
632        int x_distance = blob_box.x_gap(word_box);
633        int y_distance = blob_box.y_gap(word_box);
634        if (x_distance > 0) {
635          if (word_box.major_y_overlap(blob_box) && blob_box.left() > word_box.right()) {
636            x_distance /= 2;
637          }
638          y_distance += x_distance;
639        }
640        if (word_box.y_middle() > blob_box.y_middle() &&
641            (best_above_word == nullptr || y_distance < best_above_distance)) {
642          best_above_word = word;
643          best_above_distance = y_distance;
644        }
645        if (word_box.y_middle() <= blob_box.y_middle() &&
646            (best_below_word == nullptr || y_distance < best_below_distance)) {
647          best_below_word = word;
648          best_below_distance = y_distance;
649        }
650      }
651      bool above_good = best_above_word != nullptr &&
652                        (best_below_word == nullptr ||
653                         best_above_distance < best_below_distance + blob_box.height());
654      bool below_good = best_below_word != nullptr && best_below_word != best_above_word &&
655                        (best_above_word == nullptr ||
656                         best_below_distance < best_above_distance + blob_box.height());
657      if (below_good) {
658        C_BLOB *copied_blob = C_BLOB::deep_copy(blobnbox->cblob());
659        copied_blob->rotate(rotation);
660        C_BLOB_IT blob_it(best_below_word->RejBlobs());
661        blob_it.add_to_end(copied_blob);
662      }
663      if (above_good) {
664        C_BLOB *copied_blob = C_BLOB::deep_copy(blobnbox->cblob());
665        copied_blob->rotate(rotation);
666        C_BLOB_IT blob_it(best_above_word->RejBlobs());
667        blob_it.add_to_end(copied_blob);
668      }
669    }
670  }
671  void tweak_row_baseline(ROW *row, double blshift_maxshift, double blshift_xfraction) {
672    TBOX blob_box;      
673    C_BLOB *blob;       
674    WERD *word;         
675    int32_t blob_count; 
676    int32_t src_index;  
677    int32_t dest_index; 
678    float ydiff;        
679    float x_centre;     
680    WERD_IT word_it = row->word_list();
681    C_BLOB_IT blob_it; 
682    blob_count = 0;
683    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
684      word = word_it.data(); 
685      blob_count += word->cblob_list()->length();
686    }
687    if (blob_count == 0) {
688      return;
689    }
690    std::vector<int32_t> xstarts(blob_count + row->baseline.segments + 1);
691    std::vector<double> coeffs((blob_count + row->baseline.segments) * 3);
692    src_index = 0;
693    dest_index = 0;
694    xstarts[0] = row->baseline.xcoords[0];
695    for (word_it.mark_cycle_pt(); !word_it.cycled_list(); word_it.forward()) {
696      word = word_it.data(); 
697      blob_it.set_to_list(word->cblob_list());
698      for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
699        blob = blob_it.data();
700        blob_box = blob->bounding_box();
701        x_centre = (blob_box.left() + blob_box.right()) / 2.0;
702        ydiff = blob_box.bottom() - row->base_line(x_centre);
703        if (ydiff < 0) {
704          ydiff = -ydiff / row->x_height();
705        } else {
706          ydiff = ydiff / row->x_height();
707        }
708        if (ydiff < blshift_maxshift && blob_box.height() / row->x_height() > blshift_xfraction) {
709          if (xstarts[dest_index] >= x_centre) {
710            xstarts[dest_index] = blob_box.left();
711          }
712          coeffs[dest_index * 3] = 0;
713          coeffs[dest_index * 3 + 1] = 0;
714          coeffs[dest_index * 3 + 2] = blob_box.bottom();
715          dest_index++;
716          xstarts[dest_index] = blob_box.right() + 1;
717        } else {
718          if (xstarts[dest_index] <= x_centre) {
719            while (row->baseline.xcoords[src_index + 1] <= x_centre &&
720                   src_index < row->baseline.segments - 1) {
721              if (row->baseline.xcoords[src_index + 1] > xstarts[dest_index]) {
722                coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
723                coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
724                coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
725                dest_index++;
726                xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
727              }
728              src_index++;
729            }
730            coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
731            coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
732            coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
733            dest_index++;
734            xstarts[dest_index] = row->baseline.xcoords[src_index + 1];
735          }
736        }
737      }
738    }
739    while (src_index < row->baseline.segments &&
740           row->baseline.xcoords[src_index + 1] <= xstarts[dest_index]) {
741      src_index++;
742    }
743    while (src_index < row->baseline.segments) {
744      coeffs[dest_index * 3] = row->baseline.quadratics[src_index].a;
745      coeffs[dest_index * 3 + 1] = row->baseline.quadratics[src_index].b;
746      coeffs[dest_index * 3 + 2] = row->baseline.quadratics[src_index].c;
747      dest_index++;
748      src_index++;
749      xstarts[dest_index] = row->baseline.xcoords[src_index];
750    }
751    row->baseline = QSPLINE(dest_index, &xstarts[0], &coeffs[0]);
752  }
753  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitionset.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartitionset.h"
5  #include "tablefind.h"
6  #include "workingpartset.h"
7  namespace tesseract {
8  const double kMinColumnWidth = 2.0 / 3;
9  ColPartitionSet::ColPartitionSet(ColPartition_LIST *partitions) {
10    ColPartition_IT it(&parts_);
11    it.add_list_after(partitions);
12    ComputeCoverage();
13  }
14  ColPartitionSet::ColPartitionSet(ColPartition *part) {
15    ColPartition_IT it(&parts_);
16    it.add_after_then_move(part);
17    ComputeCoverage();
18  }
19  int ColPartitionSet::GoodColumnCount() const {
20    int num_good_cols = 0;
21    ColPartition_IT it(const_cast<ColPartition_LIST *>(&parts_));
22    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
23      if (it.data()->good_width()) {
24        ++num_good_cols;
25      }
26    }
27    return num_good_cols;
28  }
29  ColPartition *ColPartitionSet::GetColumnByIndex(int index) {
30    ColPartition_IT it(&parts_);
31    it.mark_cycle_pt();
32    for (int i = 0; i < index && !it.cycled_list(); ++i, it.forward()) {
33      ;
34    }
35    if (it.cycled_list()) {
36      return nullptr;
37    }
38    return it.data();
39  }
40  ColPartition *ColPartitionSet::ColumnContaining(int x, int y) {
41    ColPartition_IT it(&parts_);
42    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
43      ColPartition *part = it.data();
44      if (part->ColumnContains(x, y)) {
45        return part;
46      }
47    }
48    return nullptr;
49  }
50  void ColPartitionSet::RelinquishParts() {
51    ColPartition_IT it(&parts_);
52    while (!it.empty()) {
53      it.extract();
54      it.forward();
55    }
56  }
57  void ColPartitionSet::ImproveColumnCandidate(const WidthCallback &cb,
58                                               PartSetVector *src_sets) {
59    int set_size = src_sets->size();
60    for (int i = 0; i < set_size; ++i) {
61      ColPartitionSet *column_set = src_sets->at(i);
62      if (column_set == nullptr) {
63        continue;
64      }
65      ColPartition_IT part_it(&parts_);
66      ASSERT_HOST(!part_it.empty());
67      int prev_right = INT32_MIN;
68      part_it.mark_cycle_pt();
69      ColPartition_IT col_it(&column_set->parts_);
70      for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
71        ColPartition *col_part = col_it.data();
72        if (col_part->blob_type() < BRT_UNKNOWN) {
73          continue; 
74        }
75        int col_left = col_part->left_key();
76        int col_right = col_part->right_key();
77        ColPartition *part = part_it.data();
78        while (!part_it.at_last() && part->right_key() < col_left) {
79          prev_right = part->right_key();
80          part_it.forward();
81          part = part_it.data();
82        }
83        int part_left = part->left_key();
84        int part_right = part->right_key();
85        if (part_right < col_left || col_right < part_left) {
86          AddPartition(col_part->ShallowCopy(), &part_it);
87          continue;
88        }
89        bool part_width_ok = cb(part->KeyWidth(part_left, part_right));
90        if (col_left < part_left && col_left > prev_right) {
91          int col_box_left = col_part->BoxLeftKey();
92          bool tab_width_ok = cb(part->KeyWidth(col_left, part_right));
93          bool box_width_ok = cb(part->KeyWidth(col_box_left, part_right));
94          if (tab_width_ok || (!part_width_ok)) {
95            part->CopyLeftTab(*col_part, false);
96            part->SetColumnGoodness(cb);
97          } else if (col_box_left < part_left &&
98                     (box_width_ok || !part_width_ok)) {
99            part->CopyLeftTab(*col_part, true);
100            part->SetColumnGoodness(cb);
101          }
102          part_left = part->left_key();
103        }
104        if (col_right > part_right &&
105            (part_it.at_last() ||
106             part_it.data_relative(1)->left_key() > col_right)) {
107          int col_box_right = col_part->BoxRightKey();
108          bool tab_width_ok = cb(part->KeyWidth(part_left, col_right));
109          bool box_width_ok = cb(part->KeyWidth(part_left, col_box_right));
110          if (tab_width_ok || (!part_width_ok)) {
111            part->CopyRightTab(*col_part, false);
112            part->SetColumnGoodness(cb);
113          } else if (col_box_right > part_right &&
114                     (box_width_ok || !part_width_ok)) {
115            part->CopyRightTab(*col_part, true);
116            part->SetColumnGoodness(cb);
117          }
118        }
119      }
120    }
121    ComputeCoverage();
122  }
123  void ColPartitionSet::AddToColumnSetsIfUnique(PartSetVector *column_sets,
124                                                const WidthCallback &cb) {
125    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
126                                           bounding_box_.bottom());
127    if (debug) {
128      tprintf("Considering new column candidate:\n");
129      Print();
130    }
131    if (!LegalColumnCandidate()) {
132      if (debug) {
133        tprintf("Not a legal column candidate:\n");
134        Print();
135      }
136      delete this;
137      return;
138    }
139    for (unsigned i = 0; i < column_sets->size(); ++i) {
140      ColPartitionSet *columns = column_sets->at(i);
141      bool better = good_coverage_ > columns->good_coverage_;
142      if (good_coverage_ == columns->good_coverage_) {
143        better = good_column_count_ > columns->good_column_count_;
144        if (good_column_count_ == columns->good_column_count_) {
145          better = bad_coverage_ > columns->bad_coverage_;
146        }
147      }
148      if (better) {
149        if (debug) {
150          tprintf("Good one\n");
151        }
152        column_sets->insert(column_sets->begin() + i, this);
153        return;
154      }
155      if (columns->CompatibleColumns(false, this, cb)) {
156        if (debug) {
157          tprintf("Duplicate\n");
158        }
159        delete this;
160        return; 
161      }
162    }
163    if (debug) {
164      tprintf("Added to end\n");
165    }
166    column_sets->push_back(this);
167  }
168  bool ColPartitionSet::CompatibleColumns(bool debug, ColPartitionSet *other,
169                                          const WidthCallback &cb) {
170    if (debug) {
171      tprintf("CompatibleColumns testing compatibility\n");
172      Print();
173      other->Print();
174    }
175    if (other->parts_.empty()) {
176      if (debug) {
177        tprintf("CompatibleColumns true due to empty other\n");
178      }
179      return true;
180    }
181    ColPartition_IT it(&other->parts_);
182    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
183      ColPartition *part = it.data();
184      if (part->blob_type() < BRT_UNKNOWN) {
185        if (debug) {
186          tprintf("CompatibleColumns ignoring image partition\n");
187          part->Print();
188        }
189        continue; 
190      }
191      int y = part->MidY();
192      int left = part->bounding_box().left();
193      int right = part->bounding_box().right();
194      ColPartition *left_col = ColumnContaining(left, y);
195      ColPartition *right_col = ColumnContaining(right, y);
196      if (right_col == nullptr || left_col == nullptr) {
197        if (debug) {
198          tprintf("CompatibleColumns false due to partition edge outside\n");
199          part->Print();
200        }
201        return false; 
202      }
203      if (right_col != left_col && cb(right - left)) {
204        if (debug) {
205          tprintf("CompatibleColumns false due to good width in multiple cols\n");
206          part->Print();
207        }
208        return false; 
209      }
210      ColPartition_IT it2 = it;
211      while (!it2.at_last()) {
212        it2.forward();
213        ColPartition *next_part = it2.data();
214        if (!BLOBNBOX::IsTextType(next_part->blob_type())) {
215          continue; 
216        }
217        int next_left = next_part->bounding_box().left();
218        if (next_left == right) {
219          break; 
220        }
221        ColPartition *next_left_col = ColumnContaining(next_left, y);
222        if (right_col == next_left_col) {
223          if (part->good_width() && next_part->good_width()) {
224            if (debug) {
225              int next_right = next_part->bounding_box().right();
226              tprintf("CompatibleColumns false due to 2 parts of good width\n");
227              tprintf("part1 %d-%d, part2 %d-%d\n", left, right, next_left,
228                      next_right);
229              right_col->Print();
230            }
231            return false;
232          }
233        }
234        break;
235      }
236    }
237    if (debug) {
238      tprintf("CompatibleColumns true!\n");
239    }
240    return true;
241  }
242  int ColPartitionSet::UnmatchedWidth(ColPartitionSet *part_set) {
243    int total_width = 0;
244    ColPartition_IT it(&part_set->parts_);
245    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
246      ColPartition *part = it.data();
247      if (!BLOBNBOX::IsTextType(part->blob_type())) {
248        continue; 
249      }
250      int y = part->MidY();
251      BLOBNBOX_C_IT box_it(part->boxes());
252      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
253        const TBOX &box = it.data()->bounding_box();
254        int x = (box.left() + box.right()) / 2;
255        ColPartition *col = ColumnContaining(x, y);
256        if (col == nullptr) {
257          total_width += box.width();
258        }
259      }
260    }
261    return total_width;
262  }
263  bool ColPartitionSet::LegalColumnCandidate() {
264    ColPartition_IT it(&parts_);
265    if (it.empty()) {
266      return false;
267    }
268    bool any_text_parts = false;
269    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
270      ColPartition *part = it.data();
271      if (BLOBNBOX::IsTextType(part->blob_type())) {
272        if (!part->IsLegal()) {
273          return false; 
274        }
275        any_text_parts = true;
276      }
277      if (!it.at_last()) {
278        ColPartition *next_part = it.data_relative(1);
279        if (next_part->left_key() < part->right_key()) {
280          return false;
281        }
282      }
283    }
284    return any_text_parts;
285  }
286  ColPartitionSet *ColPartitionSet::Copy(bool good_only) {
287    ColPartition_LIST copy_parts;
288    ColPartition_IT src_it(&parts_);
289    ColPartition_IT dest_it(&copy_parts);
290    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
291      ColPartition *part = src_it.data();
292      if (BLOBNBOX::IsTextType(part->blob_type()) &&
293          (!good_only || part->good_width() || part->good_column())) {
294        dest_it.add_after_then_move(part->ShallowCopy());
295      }
296    }
297    if (dest_it.empty()) {
298      return nullptr;
299    }
300    return new ColPartitionSet(&copy_parts);
301  }
302  void ColPartitionSet::GetColumnBoxes(int y_bottom, int y_top,
303                                       ColSegment_LIST *segments) {
304    ColPartition_IT it(&parts_);
305    ColSegment_IT col_it(segments);
306    col_it.move_to_last();
307    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
308      ColPartition *part = it.data();
309      ICOORD bot_left(part->LeftAtY(y_top), y_bottom);
310      ICOORD top_right(part->RightAtY(y_bottom), y_top);
311      auto *col_seg = new ColSegment();
312      col_seg->InsertBox(TBOX(bot_left, top_right));
313      col_it.add_after_then_move(col_seg);
314    }
315  }
316  #ifndef GRAPHICS_DISABLED
317  void ColPartitionSet::DisplayColumnEdges(int y_bottom, int y_top,
318                                           ScrollView *win) {
319    ColPartition_IT it(&parts_);
320    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
321      ColPartition *part = it.data();
322      win->Line(part->LeftAtY(y_top), y_top, part->LeftAtY(y_bottom), y_bottom);
323      win->Line(part->RightAtY(y_top), y_top, part->RightAtY(y_bottom), y_bottom);
324    }
325  }
326  #endif 
327  ColumnSpanningType ColPartitionSet::SpanningType(
328      int resolution, int left, int right, int height, int y, int left_margin,
329      int right_margin, int *first_col, int *last_col, int *first_spanned_col) {
330    *first_col = -1;
331    *last_col = -1;
332    *first_spanned_col = -1;
333    int margin_columns = 0;
334    ColPartition_IT it(&parts_);
335    int col_index = 1;
336    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward(), col_index += 2) {
337      ColPartition *part = it.data();
338      if (part->ColumnContains(left, y) ||
339          (it.at_first() && part->ColumnContains(left + height, y))) {
340        *first_col = col_index;
341        if (part->ColumnContains(right, y) ||
342            (it.at_last() && part->ColumnContains(right - height, y))) {
343          *last_col = col_index;
344          return CST_FLOWING;
345        }
346        if (left_margin <= part->LeftAtY(y)) {
347          *first_spanned_col = col_index;
348          margin_columns = 1;
349        }
350      } else if (part->ColumnContains(right, y) ||
351                 (it.at_last() && part->ColumnContains(right - height, y))) {
352        if (*first_col < 0) {
353          *first_col = col_index - 1;
354        }
355        if (right_margin >= part->RightAtY(y)) {
356          if (margin_columns == 0) {
357            *first_spanned_col = col_index;
358          }
359          ++margin_columns;
360        }
361        *last_col = col_index;
362        break;
363      } else if (left < part->LeftAtY(y) && right > part->RightAtY(y)) {
364        if (*first_col < 0) {
365          *first_col = col_index - 1;
366        }
367        if (margin_columns == 0) {
368          *first_spanned_col = col_index;
369        }
370        *last_col = col_index;
371      } else if (right < part->LeftAtY(y)) {
372        *last_col = col_index - 1;
373        if (*first_col < 0) {
374          *first_col = col_index - 1;
375        }
376        break;
377      }
378    }
379    if (*first_col < 0) {
380      *first_col = col_index - 1; 
381    }
382    if (*last_col < 0) {
383      *last_col = col_index - 1; 
384    }
385    ASSERT_HOST(*first_col >= 0 && *last_col >= 0);
386    ASSERT_HOST(*first_col <= *last_col);
387    if (*first_col == *last_col && right - left < kMinColumnWidth * resolution) {
388      return CST_NOISE;
389    } else if (margin_columns <= 1) {
390      if (margin_columns == 1 && parts_.singleton()) {
391        return CST_HEADING;
392      }
393      return CST_PULLOUT;
394    }
395    return CST_HEADING;
396  }
397  void ColPartitionSet::ChangeWorkColumns(const ICOORD &bleft,
398                                          const ICOORD &tright, int resolution,
399                                          ColPartition_LIST *used_parts,
400                                          WorkingPartSet_LIST *working_set_list) {
<span onclick='openModal()' class='match'>401    WorkingPartSet_LIST work_src;
402    WorkingPartSet_IT src_it(&work_src);
403    src_it.add_list_after(working_set_list);
404    src_it.move_to_first();
</span>405    WorkingPartSet_IT dest_it(working_set_list);
406    BLOCK_LIST completed_blocks;
407    TO_BLOCK_LIST to_blocks;
408    WorkingPartSet *first_new_set = nullptr;
409    WorkingPartSet *working_set = nullptr;
410    ColPartition_IT col_it(&parts_);
411    for (col_it.mark_cycle_pt(); !col_it.cycled_list(); col_it.forward()) {
412      ColPartition *column = col_it.data();
413      while (!src_it.empty() &&
414             ((working_set = src_it.data())->column() == nullptr ||
415              working_set->column()->right_key() <= column->left_key())) {
416        src_it.extract();
417        working_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
418                                            &completed_blocks, &to_blocks);
419        delete working_set;
420        src_it.forward();
421      }
422      working_set = new WorkingPartSet(nullptr);
423      dest_it.add_after_then_move(working_set);
424      if (first_new_set == nullptr) {
425        first_new_set = working_set;
426      }
427      working_set = src_it.empty() ? nullptr : src_it.data();
428      if (working_set != nullptr &&
429          working_set->column()->MatchingColumns(*column)) {
430        working_set->set_column(column);
431        dest_it.add_after_then_move(src_it.extract());
432        src_it.forward();
433        first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
434        first_new_set = nullptr;
435      } else {
436        working_set = new WorkingPartSet(column);
437        dest_it.add_after_then_move(working_set);
438      }
439    }
440    while (!src_it.empty()) {
441      working_set = src_it.extract();
442      working_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
443                                          &completed_blocks, &to_blocks);
444      delete working_set;
445      src_it.forward();
446    }
447    working_set = new WorkingPartSet(nullptr);
448    dest_it.add_after_then_move(working_set);
449    if (first_new_set == nullptr) {
450      first_new_set = working_set;
451    }
452    first_new_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
453  }
454  void ColPartitionSet::AccumulateColumnWidthsAndGaps(int *total_width,
455                                                      int *width_samples,
456                                                      int *total_gap,
457                                                      int *gap_samples) {
458    ColPartition_IT it(&parts_);
459    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
460      ColPartition *part = it.data();
461      *total_width += part->ColumnWidth();
462      ++*width_samples;
463      if (!it.at_last()) {
464        ColPartition *next_part = it.data_relative(1);
465        int part_left = part->right_key();
466        int part_right = next_part->left_key();
467        int gap = part->KeyWidth(part_left, part_right);
468        *total_gap += gap;
469        ++*gap_samples;
470      }
471    }
472  }
473  void ColPartitionSet::Print() {
474    ColPartition_IT it(&parts_);
475    tprintf(
476        "Partition set of %d parts, %d good, coverage=%d+%d"
477        " (%d,%d)->(%d,%d)\n",
478        it.length(), good_column_count_, good_coverage_, bad_coverage_,
479        bounding_box_.left(), bounding_box_.bottom(), bounding_box_.right(),
480        bounding_box_.top());
481    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
482      ColPartition *part = it.data();
483      part->Print();
484    }
485  }
486  void ColPartitionSet::AddPartition(ColPartition *new_part,
487                                     ColPartition_IT *it) {
488    AddPartitionCoverageAndBox(*new_part);
489    int new_right = new_part->right_key();
490    if (it->data()->left_key() >= new_right) {
491      it->add_before_stay_put(new_part);
492    } else {
493      it->add_after_stay_put(new_part);
494    }
495  }
496  void ColPartitionSet::ComputeCoverage() {
497    ColPartition_IT it(&parts_);
498    good_column_count_ = 0;
499    good_coverage_ = 0;
500    bad_coverage_ = 0;
501    bounding_box_ = TBOX();
502    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
503      ColPartition *part = it.data();
504      AddPartitionCoverageAndBox(*part);
505    }
506  }
507  void ColPartitionSet::AddPartitionCoverageAndBox(const ColPartition &part) {
508    bounding_box_ += part.bounding_box();
509    int coverage = part.ColumnWidth();
510    if (part.good_width()) {
511      good_coverage_ += coverage;
512      good_column_count_ += 2;
513    } else {
514      if (part.blob_type() < BRT_UNKNOWN) {
515        coverage /= 2;
516      }
517      if (part.good_column()) {
518        ++good_column_count_;
519      }
520      bad_coverage_ += coverage;
521    }
522  }
523  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tordmain.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartitionset.cpp</div>
                </div>
                <div class="column column_space"><pre><code>279        C_BLOB_LIST blobs;
280        C_BLOB_IT blob_it(&blobs);
281        blob_it.add_after_then_move(blob);
282        WERD *word = new WERD(&blobs, 0, nullptr);
</pre></code></div>
                <div class="column column_space"><pre><code>401    WorkingPartSet_LIST work_src;
402    WorkingPartSet_IT src_it(&work_src);
403    src_it.add_list_after(working_set_list);
404    src_it.move_to_first();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    