
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</h3>
            <pre><code>1  #pragma once
2  #include "Scintilla.h"
3  #include "ScintillaRef.h"
4  #include "SciLexer.h"
5  #include "Buffer.h"
6  #include "colors.h"
7  #include "UserDefineDialog.h"
8  #include "rgba_icons.h"
9  #ifndef WM_MOUSEWHEEL
10  #define WM_MOUSEWHEEL 0x020A
11  #endif 
12  #ifndef WM_MOUSEHWHEEL
13  #define WM_MOUSEHWHEEL 0x020E
14  #endif 
15  #ifndef WM_APPCOMMAND
16  #define WM_APPCOMMAND                   0x0319
17  #define APPCOMMAND_BROWSER_BACKWARD       1
18  #define APPCOMMAND_BROWSER_FORWARD        2
19  #define FAPPCOMMAND_MASK  0xF000
20  #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
21  #endif 
22  class NppParameters;
23  #define NB_WORD_LIST 4
24  #define WORD_LIST_LEN 256
25  typedef sptr_t(*SCINTILLA_FUNC) (void *, unsigned int, uptr_t, sptr_t);
26  typedef void * SCINTILLA_PTR;
27  #define WM_DOCK_USERDEFINE_DLG      (SCINTILLA_USER + 1)
28  #define WM_UNDOCK_USERDEFINE_DLG    (SCINTILLA_USER + 2)
29  #define WM_CLOSE_USERDEFINE_DLG     (SCINTILLA_USER + 3)
30  #define WM_REMOVE_USERLANG          (SCINTILLA_USER + 4)
31  #define WM_RENAME_USERLANG          (SCINTILLA_USER + 5)
32  #define WM_REPLACEALL_INOPENEDDOC   (SCINTILLA_USER + 6)
33  #define WM_FINDALL_INOPENEDDOC      (SCINTILLA_USER + 7)
34  #define WM_DOOPEN                   (SCINTILLA_USER + 8)
35  #define WM_FINDINFILES              (SCINTILLA_USER + 9)
36  #define WM_REPLACEINFILES           (SCINTILLA_USER + 10)
37  #define WM_FINDALL_INCURRENTDOC     (SCINTILLA_USER + 11)
38  #define WM_FRSAVE_INT               (SCINTILLA_USER + 12)
39  #define WM_FRSAVE_STR               (SCINTILLA_USER + 13)
40  #define WM_FINDALL_INCURRENTFINDER  (SCINTILLA_USER + 14)
41  #define WM_FINDINPROJECTS           (SCINTILLA_USER + 15)
42  #define WM_REPLACEINPROJECTS        (SCINTILLA_USER + 16)
43  const int NB_FOLDER_STATE = 7;
44  const int CP_CHINESE_TRADITIONAL = 950;
45  const int CP_CHINESE_SIMPLIFIED = 936;
46  const int CP_JAPANESE = 932;
47  const int CP_KOREAN = 949;
48  const int CP_GREEK = 1253;
49  #define LIST_NONE 0
50  #define LIST_0 1
51  #define LIST_1 2
52  #define LIST_2 4
53  #define LIST_3 8
54  #define LIST_4 16
55  #define LIST_5 32
56  #define LIST_6 64
57  #define LIST_7 128
58  #define LIST_8 256
59  const bool fold_uncollapse = true;
60  const bool fold_collapse = false;
61  #define MAX_FOLD_COLLAPSE_LEVEL	8
62  enum TextCase : UCHAR
63  {
64  	UPPERCASE,
65  	LOWERCASE,
66  	TITLECASE_FORCE,
67  	TITLECASE_BLEND,
68  	SENTENCECASE_FORCE,
69  	SENTENCECASE_BLEND,
70  	INVERTCASE,
71  	RANDOMCASE
72  };
73  const UCHAR MASK_FORMAT = 0x03;
74  const UCHAR BASE_10 = 0x00; 
75  const UCHAR BASE_16 = 0x01; 
76  const UCHAR BASE_08 = 0x02; 
77  const UCHAR BASE_02 = 0x03; 
78  const int MARK_BOOKMARK = 20;
79  const int MARK_HIDELINESBEGIN = 19;
80  const int MARK_HIDELINESEND = 18;
81  constexpr char g_ZWSP[] = "\xE2\x80\x8B";
82  const std::vector<std::vector<const char*>> g_ccUniEolChars =
83  {
84  	{"\x00", "NUL", "U+0000"},               
85  	{"\x01", "SOH", "U+0001"},               
86  	{"\x02", "STX", "U+0002"},               
87  	{"\x03", "ETX", "U+0003"},               
88  	{"\x04", "EOT", "U+0004"},               
89  	{"\x05", "ENQ", "U+0005"},               
90  	{"\x06", "ACK", "U+0006"},               
91  	{"\a", "BEL", "U+0007"},                 
92  	{"\b", "BS", "U+0008"},                  
93  	{"\v", "VT", "U+000B"},                  
94  	{"\f", "FF", "U+000C"},                  
95  	{"\x0E", "SO", "U+000E"},                
96  	{"\x0F", "SI", "U+000F"},                
97  	{"\x10", "DLE", "U+0010"},               
98  	{"\x11", "DC1", "U+0011"},               
99  	{"\x12", "DC2", "U+0012"},               
100  	{"\x13", "DC3", "U+0013"},               
101  	{"\x14", "DC4", "U+0014"},               
102  	{"\x15", "NAK", "U+0015"},               
103  	{"\x16", "SYN", "U+0016"},               
104  	{"\x17", "ETB", "U+0017"},               
105  	{"\x18", "CAN", "U+0018"},               
106  	{"\x19", "EM", "U+0019"},                
107  	{"\x1A", "SUB", "U+001A"},               
108  	{"\x1B", "ESC", "U+001B"},               
109  	{"\x1C", "FS", "U+001C"},                
110  	{"\x1D", "GS", "U+001D"},                
111  	{"\x1E", "RS", "U+001E"},                
112  	{"\x1F", "US", "U+001F"},                
113  	{"\x7F", "DEL", "U+007F"},               
114  	{"\xC2\x80", "PAD", "U+0080"},           
115  	{"\xC2\x81", "HOP", "U+0081"},           
116  	{"\xC2\x82", "BPH", "U+0082"},           
117  	{"\xC2\x83", "NBH", "U+0083"},           
118  	{"\xC2\x84", "IND", "U+0084"},           
119  	{"\xC2\x86", "SSA", "U+0086"},           
120  	{"\xC2\x87", "ESA", "U+0087"},           
121  	{"\xC2\x88", "HTS", "U+0088"},           
122  	{"\xC2\x89", "HTJ", "U+0089"},           
123  	{"\xC2\x8A", "LTS", "U+008A"},           
124  	{"\xC2\x8B", "PLD", "U+008B"},           
125  	{"\xC2\x8C", "PLU", "U+008C"},           
126  	{"\xC2\x8D", "RI", "U+008D"},            
127  	{"\xC2\x8E", "SS2", "U+008E"},           
128  	{"\xC2\x8F", "SS3", "U+008F"},           
129  	{"\xC2\x90", "DCS", "U+0090"},           
130  	{"\xC2\x91", "PU1", "U+0091"},           
131  	{"\xC2\x92", "PU2", "U+0092"},           
132  	{"\xC2\x93", "STS", "U+0093"},           
133  	{"\xC2\x94", "CCH", "U+0094"},           
134  	{"\xC2\x95", "MW", "U+0095"},            
135  	{"\xC2\x96", "SPA", "U+0096"},           
136  	{"\xC2\x97", "EPA", "U+0097"},           
137  	{"\xC2\x98", "SOS", "U+0098"},           
138  	{"\xC2\x99", "SGCI", "U+0099"},          
139  	{"\xC2\x9A", "SCI", "U+009A"},           
140  	{"\xC2\x9B", "CSI", "U+009B"},           
141  	{"\xC2\x9C", "ST", "U+009C"},            
142  	{"\xC2\x9D", "OSC", "U+009D"},           
143  	{"\xC2\x9E", "PM", "U+009E"},            
144  	{"\xC2\x9F", "APC", "U+009F"},           
145  	{"\xC2\x85", "NEL", "U+0085"},           
146  	{"\xE2\x80\xA8", "LS", "U+2028"},        
147  	{"\xE2\x80\xA9", "PS", "U+2029"}         
148  };
149  const std::vector<std::vector<const char*>> g_nonPrintingChars =
150  {
151  	{"\xC2\xA0", "NBSP", "U+00A0"},          
152  	{"\xC2\xAD", "SHY", "U+00AD"},           
153  	{"\xD8\x9C", "ALM", "U+061C"},           
154  	{"\xDC\x8F", "SAM", "U+070F"},           
155  	{"\xE1\x9A\x80", "OSPM", "U+1680"},      
156  	{"\xE1\xA0\x8E", "MVS", "U+180E"},       
157  	{"\xE2\x80\x80", "NQSP", "U+2000"},      
158  	{"\xE2\x80\x81", "MQSP", "U+2001"},      
159  	{"\xE2\x80\x82", "ENSP", "U+2002"},      
160  	{"\xE2\x80\x83", "EMSP", "U+2003"},      
161  	{"\xE2\x80\x84", "3/MSP", "U+2004"},     
162  	{"\xE2\x80\x85", "4/MSP", "U+2005"},     
163  	{"\xE2\x80\x86", "6/MSP", "U+2006"},     
164  	{"\xE2\x80\x87", "FSP", "U+2007"},       
165  	{"\xE2\x80\x88", "PSP", "U+2008"},       
166  	{"\xE2\x80\x89", "THSP", "U+2009"},      
167  	{"\xE2\x80\x8A", "HSP", "U+200A"},       
168  	{"\xE2\x80\x8B", "ZWSP", "U+200B"},      
169  	{"\xE2\x80\x8C", "ZWNJ", "U+200C"},      
170  	{"\xE2\x80\x8D", "ZWJ", "U+200D"},       
171  	{"\xE2\x80\x8E", "LRM", "U+200E"},       
172  	{"\xE2\x80\x8F", "RLM", "U+200F"},       
173  	{"\xE2\x80\xAA", "LRE", "U+202A"},       
174  	{"\xE2\x80\xAB", "RLE", "U+202B"},       
175  	{"\xE2\x80\xAC", "PDF", "U+202C"},       
176  	{"\xE2\x80\xAD", "LRO", "U+202D"},       
177  	{"\xE2\x80\xAE", "RLO", "U+202E"},       
178  	{"\xE2\x80\xAF", "NNBSP", "U+202F"},     
179  	{"\xE2\x81\x9F", "MMSP", "U+205F"},      
180  	{"\xE2\x81\xA0", "WJ", "U+2060"},        
181  	{"\xE2\x81\xA1", "(FA)", "U+2061"},      
182  	{"\xE2\x81\xA2", "(IT)", "U+2062"},      
183  	{"\xE2\x81\xA3", "(IS)", "U+2063"},      
184  	{"\xE2\x81\xA4", "(IP)", "U+2064"},      
185  	{"\xE2\x81\xA6", "LRI", "U+2066"},       
186  	{"\xE2\x81\xA7", "RLI", "U+2067"},       
187  	{"\xE2\x81\xA8", "FSI", "U+2068"},       
188  	{"\xE2\x81\xA9", "PDI", "U+2069"},       
189  	{"\xE2\x81\xAA", "ISS", "U+206A"},       
190  	{"\xE2\x81\xAB", "ASS", "U+206B"},       
191  	{"\xE2\x81\xAC", "IAFS", "U+206C"},      
192  	{"\xE2\x81\xAD", "AAFS", "U+206D"},      
193  	{"\xE2\x81\xAE", "NADS", "U+206E"},      
194  	{"\xE2\x81\xAF", "NODS", "U+206F"},      
195  	{"\xE3\x80\x80", "IDSP", "U+3000"},      
196  	{"\xEF\xBB\xBF", "ZWNBSP", "U+FEFF"},    
197  	{"\xEF\xBF\xB9", "IAA", "U+FFF9"},       
198  	{"\xEF\xBF\xBA", "IAS", "U+FFFA"},       
199  	{"\xEF\xBF\xBB", "IAT", "U+FFFB"}        
200  };
201  int getNbDigits(int aNum, int base);
202  TCHAR* int2str(TCHAR* str, int strLen, int number, int base, int nbDigits, ColumnEditorParam::leadingChoice lead);
203  typedef LRESULT (WINAPI *CallWindowProcFunc) (WNDPROC,HWND,UINT,WPARAM,LPARAM);
204  const bool L2R = true;
205  const bool R2L = false;
206  struct ColumnModeInfo {
207  	intptr_t _selLpos = 0;
208  	intptr_t _selRpos = 0;
209  	intptr_t _order = -1; 
210  	bool _direction = L2R; 
211  	intptr_t _nbVirtualAnchorSpc = 0;
212  	intptr_t _nbVirtualCaretSpc = 0;
213  	ColumnModeInfo(intptr_t lPos, intptr_t rPos, intptr_t order, bool dir = L2R, intptr_t vAnchorNbSpc = 0, intptr_t vCaretNbSpc = 0)
214  		: _selLpos(lPos), _selRpos(rPos), _order(order), _direction(dir), _nbVirtualAnchorSpc(vAnchorNbSpc), _nbVirtualCaretSpc(vCaretNbSpc){};
215  	bool isValid() const {
216  		return (_order >= 0 && _selLpos >= 0 && _selRpos >= 0 && _selLpos <= _selRpos);
217  	};
218  };
219  struct SortInSelectOrder {
220  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
221  		return (l._order < r._order);
222  	}
223  };
224  struct SortInPositionOrder {
225  	bool operator() (ColumnModeInfo & l, ColumnModeInfo & r) {
226  		return (l._selLpos < r._selLpos);
227  	}
228  };
229  typedef std::vector<ColumnModeInfo> ColumnModeInfos;
230  struct LanguageNameInfo {
231  	const TCHAR* _langName = nullptr;
232  	const TCHAR* _shortName = nullptr;
233  	const TCHAR* _longName = nullptr;
234  	LangType _langID = L_TEXT;
235  	const char* _lexerID = nullptr;
236  };
237  #define URL_INDIC 8
238  class ISorter;
239  class ScintillaEditView : public Window
240  {
241  friend class Finder;
242  public:
243  	ScintillaEditView(): Window() {
244  		++_refCount;
245  	};
246  	virtual ~ScintillaEditView()
247  	{
248  		--_refCount;
249  		if ((!_refCount)&&(_SciInit))
250  		{
251  			Scintilla_ReleaseResources();
252  			for (BufferStyleMap::iterator it(_hotspotStyles.begin()); it != _hotspotStyles.end(); ++it )
253  			{
254  				delete it->second;
255  			}
256  		}
257  	};
258  	virtual void destroy()
259  	{
260  		::DestroyWindow(_hSelf);
261  		_hSelf = NULL;
262  		_pScintillaFunc = NULL;
263  	};
264  	virtual void init(HINSTANCE hInst, HWND hPere);
265  	LRESULT execute(UINT Msg, WPARAM wParam=0, LPARAM lParam=0) const {
266  		try {
267  			return (_pScintillaFunc) ? _pScintillaFunc(_pScintillaPtr, Msg, wParam, lParam) : -1;
268  		}
269  		catch (...)
270  		{
271  			return -1;
272  		}
273  	};
274  	void activateBuffer(BufferID buffer, bool force = false);
275  	void getCurrentFoldStates(std::vector<size_t> & lineStateVector);
276  	void syncFoldStateWith(const std::vector<size_t> & lineStateVectorNew);
277  	void getText(char *dest, size_t start, size_t end) const;
278  	void getGenericText(TCHAR *dest, size_t destlen, size_t start, size_t end) const;
279  	void getGenericText(TCHAR *dest, size_t deslen, size_t start, size_t end, intptr_t* mstart, intptr_t* mend) const;
280  	generic_string getGenericTextAsString(size_t start, size_t end) const;
281  	void insertGenericTextFrom(size_t position, const TCHAR *text2insert) const;
282  	void replaceSelWith(const char * replaceText);
283  	intptr_t getSelectedTextCount() {
284  		Sci_CharacterRangeFull range = getSelection();
285  		return (range.cpMax - range.cpMin);
286  	};
287  	void getVisibleStartAndEndPosition(intptr_t* startPos, intptr_t* endPos);
288      char * getWordFromRange(char * txt, size_t size, size_t pos1, size_t pos2);
289  	char * getSelectedText(char * txt, size_t size, bool expand = true);
290      char * getWordOnCaretPos(char * txt, size_t size);
291      TCHAR * getGenericWordOnCaretPos(TCHAR * txt, int size);
292  	TCHAR * getGenericSelectedText(TCHAR * txt, int size, bool expand = true);
293  	intptr_t searchInTarget(const TCHAR * Text2Find, size_t lenOfText2Find, size_t fromPos, size_t toPos) const;
294  	void appandGenericText(const TCHAR * text2Append) const;
295  	void addGenericText(const TCHAR * text2Append) const;
296  	void addGenericText(const TCHAR * text2Append, intptr_t* mstart, intptr_t* mend) const;
297  	intptr_t replaceTarget(const TCHAR * str2replace, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
298  	intptr_t replaceTargetRegExMode(const TCHAR * re, intptr_t fromTargetPos = -1, intptr_t toTargetPos = -1) const;
299  	void showAutoComletion(size_t lenEntered, const TCHAR * list);
300  	void showCallTip(size_t startPos, const TCHAR * def);
301  	generic_string getLine(size_t lineNumber);
302  	void getLine(size_t lineNumber, TCHAR * line, size_t lineBufferLen);
<span onclick='openModal()' class='match'>303  	void addText(size_t length, const char *buf);
304  	void insertNewLineAboveCurrentLine();
305  	void insertNewLineBelowCurrentLine();
</span>306  	void saveCurrentPos();
307  	void restoreCurrentPosPreStep();
308  	void restoreCurrentPosPostStep();
309  	void beginOrEndSelect(bool isColumnMode);
310  	bool beginEndSelectedIsStarted() const {
311  		return _beginSelectPosition != -1;
312  	};
313  	size_t getCurrentDocLen() const {
314  		return size_t(execute(SCI_GETLENGTH));
315  	};
316  	Sci_CharacterRangeFull getSelection() const {
317  		Sci_CharacterRangeFull crange{};
318  		crange.cpMin = execute(SCI_GETSELECTIONSTART);
319  		crange.cpMax = execute(SCI_GETSELECTIONEND);
320  		return crange;
321  	};
322  	void getWordToCurrentPos(TCHAR * str, intptr_t strLen) const {
323  		auto caretPos = execute(SCI_GETCURRENTPOS);
324  		auto startPos = execute(SCI_WORDSTARTPOSITION, caretPos, true);
325  		str[0] = '\0';
326  		if ((caretPos - startPos) < strLen)
327  			getGenericText(str, strLen, startPos, caretPos);
328  	};
329      void doUserDefineDlg(bool willBeShown = true, bool isRTL = false) {
330          _userDefineDlg.doDialog(willBeShown, isRTL);
331      };
332      static UserDefineDialog * getUserDefineDlg() {return &_userDefineDlg;};
333      void setCaretColorWidth(int color, int width = 1) const {
334          execute(SCI_SETCARETFORE, color);
335          execute(SCI_SETCARETWIDTH, width);
336      };
337  	void beSwitched() {
338  		_userDefineDlg.setScintilla(this);
339  	};
340      static const int _SC_MARGE_LINENUMBER;
341      static const int _SC_MARGE_SYMBOL;
342      static const int _SC_MARGE_FOLDER;
343      static const int _SC_MARGE_CHANGEHISTORY;
344      void showMargin(int whichMarge, bool willBeShowed = true);
345      void showChangeHistoryMargin(bool willBeShowed = true);
346      bool hasMarginShowed(int witchMarge) {
347  		return (execute(SCI_GETMARGINWIDTHN, witchMarge, 0) != 0);
348      };
349      void updateBeginEndSelectPosition(bool is_insert, size_t position, size_t length);
350      void marginClick(Sci_Position position, int modifiers);
351      void setMakerStyle(folderStyle style) {
352  		bool display;
353  		if (style == FOLDER_STYLE_NONE)
354  		{
355  			style = FOLDER_STYLE_BOX;
356  			display = false;
357  		}
358  		else
359  		{
360  			display = true;
361  		}
362  		COLORREF foldfgColor = white, foldbgColor = grey, activeFoldFgColor = red;
363  		getFoldColor(foldfgColor, foldbgColor, activeFoldFgColor);
364  		for (int i = 0 ; i < NB_FOLDER_STATE ; ++i)
365  			defineMarker(_markersArray[FOLDER_TYPE][i], _markersArray[style][i], foldfgColor, foldbgColor, activeFoldFgColor);
366  		showMargin(ScintillaEditView::_SC_MARGE_FOLDER, display);
367      };
368  	void setWrapMode(lineWrapMethod meth) {
369  		int mode = (meth == LINEWRAP_ALIGNED)?SC_WRAPINDENT_SAME:\
370  				(meth == LINEWRAP_INDENT)?SC_WRAPINDENT_INDENT:SC_WRAPINDENT_FIXED;
371  		execute(SCI_SETWRAPINDENTMODE, mode);
372  	};
373  	void showWSAndTab(bool willBeShowed = true) {
374  		execute(SCI_SETVIEWWS, willBeShowed?SCWS_VISIBLEALWAYS:SCWS_INVISIBLE);
375  		execute(SCI_SETWHITESPACESIZE, 2, 0);
376  	};
377  	bool isShownSpaceAndTab() {
378  		return (execute(SCI_GETVIEWWS) != 0);
379  	};
380  	void showEOL(bool willBeShowed = true) {
381  		execute(SCI_SETVIEWEOL, willBeShowed);
382  	};
383  	bool isShownEol() {
384  		return (execute(SCI_GETVIEWEOL) != 0);
385  	};
386  	void showNpc(bool willBeShowed = true, bool isSearchResult = false);
387  	bool isShownNpc() {
388  		auto& svp = NppParameters::getInstance().getSVP();
389  		return svp._npcShow;
390  	};
391  	void maintainStateForNpc() {
392  		const auto& svp = NppParameters::getInstance().getSVP();
393  		const bool isShownNpc = svp._npcShow;
394  		const bool isShownCcUniEol = svp._ccUniEolShow;
395  		if (isShownNpc && isShownCcUniEol)
396  		{
397  			showNpc(true);
398  			showCcUniEol(true);
399  			if (svp._eolMode != svp.roundedRectangleText)
400  			{
401  				setCRLF();
402  			}
403  		}
404  		else if (!isShownNpc && isShownCcUniEol)
405  		{
406  			showNpc(false);
407  		}
408  		else
409  		{
410  			showCcUniEol(false);
411  		}
412  	}
413  	void showCcUniEol(bool willBeShowed = true, bool isSearchResult = false);
414  	bool isShownCcUniEol() {
415  		auto& svp = NppParameters::getInstance().getSVP();
416  		return svp._ccUniEolShow;
417  	};
418  	void showInvisibleChars(bool willBeShowed = true) {
419  		showNpc(willBeShowed);
420  		showCcUniEol(willBeShowed);
421  		showWSAndTab(willBeShowed);
422  		showEOL(willBeShowed);
423  	};
424  	void showIndentGuideLine(bool willBeShowed = true);
425  	bool isShownIndentGuide() const {
426  		return (execute(SCI_GETINDENTATIONGUIDES) != 0);
427  	};
428      void wrap(bool willBeWrapped = true) {
429          execute(SCI_SETWRAPMODE, willBeWrapped);
430      };
431      bool isWrap() const {
432          return (execute(SCI_GETWRAPMODE) == SC_WRAP_WORD);
433      };
434  	bool isWrapSymbolVisible() const {
435  		return (execute(SCI_GETWRAPVISUALFLAGS) != SC_WRAPVISUALFLAG_NONE);
436  	};
437      void showWrapSymbol(bool willBeShown = true) {
438  		execute(SCI_SETWRAPVISUALFLAGSLOCATION, SC_WRAPVISUALFLAGLOC_DEFAULT);
439  		execute(SCI_SETWRAPVISUALFLAGS, willBeShown?SC_WRAPVISUALFLAG_END:SC_WRAPVISUALFLAG_NONE);
440      };
441  	intptr_t getCurrentLineNumber()const {
442  		return execute(SCI_LINEFROMPOSITION, execute(SCI_GETCURRENTPOS));
443  	};
444  	intptr_t lastZeroBasedLineNumber() const {
445  		auto endPos = execute(SCI_GETLENGTH);
446  		return execute(SCI_LINEFROMPOSITION, endPos);
447  	};
448  	intptr_t getCurrentXOffset()const{
449  		return execute(SCI_GETXOFFSET);
450  	};
451  	void setCurrentXOffset(long xOffset){
452  		execute(SCI_SETXOFFSET,xOffset);
453  	};
454  	void scroll(intptr_t column, intptr_t line){
455  		execute(SCI_LINESCROLL, column, line);
456  	};
457  	intptr_t getCurrentPointX()const{
458  		return execute(SCI_POINTXFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
459  	};
460  	intptr_t getCurrentPointY()const{
461  		return execute(SCI_POINTYFROMPOSITION, 0, execute(SCI_GETCURRENTPOS));
462  	};
463  	intptr_t getTextHeight()const{
464  		return execute(SCI_TEXTHEIGHT);
465  	};
466  	int getTextZoneWidth() const;
467  	void gotoLine(intptr_t line){
468  		if (line < execute(SCI_GETLINECOUNT))
469  			execute(SCI_GOTOLINE,line);
470  	};
471  	intptr_t getCurrentColumnNumber() const {
472          return execute(SCI_GETCOLUMN, execute(SCI_GETCURRENTPOS));
473      };
474  	std::pair<size_t, size_t> getSelectedCharsAndLinesCount(long long maxSelectionsForLineCount = -1) const;
475  	size_t getUnicodeSelectedLength() const;
476  	intptr_t getLineLength(size_t line) const {
477  		return execute(SCI_GETLINEENDPOSITION, line) - execute(SCI_POSITIONFROMLINE, line);
478  	};
479  	intptr_t getLineIndent(size_t line) const {
480  		return execute(SCI_GETLINEINDENTATION, line);
481  	};
482  	void setLineIndent(size_t line, size_t indent) const;
483  	void updateLineNumbersMargin(bool forcedToHide) {
484  		const ScintillaViewParams& svp = NppParameters::getInstance().getSVP();
485  		if (forcedToHide)
486  		{
487  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
488  		}
489  		else if (svp._lineNumberMarginShow)
490  		{
491  			updateLineNumberWidth();
492  		}
493  		else
494  		{
495  			execute(SCI_SETMARGINWIDTHN, _SC_MARGE_LINENUMBER, 0);
496  		}
497  	}
498  	void updateLineNumberWidth();
499  	void performGlobalStyles();
500  	void expand(size_t& line, bool doExpand, bool force = false, intptr_t visLevels = 0, intptr_t level = -1);
501  	std::pair<size_t, size_t> getSelectionLinesRange(intptr_t selectionNumber = -1) const;
502      void currentLinesUp() const;
503      void currentLinesDown() const;
504  	intptr_t caseConvertRange(intptr_t start, intptr_t end, TextCase caseToConvert);
505  	void changeCase(__inout wchar_t * const strWToConvert, const int & nbChars, const TextCase & caseToConvert) const;
506  	void convertSelectedTextTo(const TextCase & caseToConvert);
507  	void setMultiSelections(const ColumnModeInfos & cmi);
508      void convertSelectedTextToLowerCase() {
509  		if ((NppParameters::getInstance()).isTransparentAvailable())
510  			convertSelectedTextTo(LOWERCASE);
511  		else
512  			execute(SCI_LOWERCASE);
513  	};
514      void convertSelectedTextToUpperCase() {
515  		if ((NppParameters::getInstance()).isTransparentAvailable())
516  			convertSelectedTextTo(UPPERCASE);
517  		else
518  			execute(SCI_UPPERCASE);
519  	};
520  	void convertSelectedTextToNewerCase(const TextCase & caseToConvert) {
521  		if ((NppParameters::getInstance()).isTransparentAvailable())
522  			convertSelectedTextTo(caseToConvert);
523  		else
524  			::MessageBox(_hSelf, TEXT("This function needs a newer OS version."), TEXT("Change Case Error"), MB_OK | MB_ICONHAND);
525  	};
526  	bool isFoldIndentationBased() const;
527  	void collapseFoldIndentationBased(int level2Collapse, bool mode);
528  	void collapse(int level2Collapse, bool mode);
529  	void foldAll(bool mode);
530  	void fold(size_t line, bool mode);
531  	bool isFolded(size_t line) const {
532  		return (execute(SCI_GETFOLDEXPANDED, line) != 0);
533  	};
534  	bool isCurrentLineFolded() const;
535  	void foldCurrentPos(bool mode);
536  	int getCodepage() const {return _codepage;};
537  	ColumnModeInfos getColumnModeSelectInfo();
538  	void columnReplace(ColumnModeInfos & cmi, const TCHAR *str);
539  	void columnReplace(ColumnModeInfos & cmi, int initial, int incr, int repeat, UCHAR format, ColumnEditorParam::leadingChoice lead);
540  	void clearIndicator(int indicatorNumber) {
541  		size_t docStart = 0;
542  		size_t docEnd = getCurrentDocLen();
543  		execute(SCI_SETINDICATORCURRENT, indicatorNumber);
544  		execute(SCI_INDICATORCLEARRANGE, docStart, docEnd - docStart);
545  	};
546  	bool getIndicatorRange(size_t indicatorNumber, size_t* from = NULL, size_t* to = NULL, size_t* cur = NULL);
547  	static LanguageNameInfo _langNameInfoArray[L_EXTERNAL+1];
548  	void bufferUpdated(Buffer * buffer, int mask);
549  	BufferID getCurrentBufferID() { return _currentBufferID; };
550  	Buffer * getCurrentBuffer() { return _currentBuffer; };
551  	void setCurrentBuffer(Buffer *buf2set) { _currentBuffer = buf2set; };
552  	void styleChange();
553  	void hideLines();
554  	bool markerMarginClick(intptr_t lineNumber);	
555  	void notifyMarkers(Buffer * buf, bool isHide, size_t location, bool del);
556  	void runMarkers(bool doHide, size_t searchStart, bool endOfDoc, bool doDelete);
557  	bool isSelecting() const {
558  		static Sci_CharacterRangeFull previousSelRange = getSelection();
559  		Sci_CharacterRangeFull currentSelRange = getSelection();
560  		if (currentSelRange.cpMin == currentSelRange.cpMax)
561  		{
562  			previousSelRange = currentSelRange;
563  			return false;
564  		}
565  		if ((previousSelRange.cpMin == currentSelRange.cpMin) || (previousSelRange.cpMax == currentSelRange.cpMax))
566  		{
567  			previousSelRange = currentSelRange;
568  			return true;
569  		}
570  		previousSelRange = currentSelRange;
571  		return false;
572  	};
573  	bool isPythonStyleIndentation(LangType typeDoc) const{
574  		return (typeDoc == L_PYTHON || typeDoc == L_COFFEESCRIPT || typeDoc == L_HASKELL ||\
575  			typeDoc == L_C || typeDoc == L_CPP || typeDoc == L_OBJC || typeDoc == L_CS || typeDoc == L_JAVA ||\
576  			typeDoc == L_PHP || typeDoc == L_JS || typeDoc == L_JAVASCRIPT || typeDoc == L_MAKEFILE ||\
577  			typeDoc == L_ASN1 || typeDoc == L_GDSCRIPT);
578  	};
579  	void defineDocType(LangType typeDoc);	
580  	void addCustomWordChars();
581  	void restoreDefaultWordChars();
582  	void setWordChars();
583  	void setCRLF(long color = -1);
584  	void setNpcAndCcUniEOL(long color = -1);
585  	void mouseWheel(WPARAM wParam, LPARAM lParam) {
586  		scintillaNew_Proc(_hSelf, WM_MOUSEWHEEL, wParam, lParam);
587  	};
588  	void setHotspotStyle(const Style& styleToSet);
589      void setTabSettings(Lang *lang);
590  	bool isWrapRestoreNeeded() const {return _wrapRestoreNeeded;};
591  	void setWrapRestoreNeeded(bool isWrapRestoredNeeded) {_wrapRestoreNeeded = isWrapRestoredNeeded;};
592  	bool isCJK() const {
593  		return ((_codepage == CP_CHINESE_TRADITIONAL) || (_codepage == CP_CHINESE_SIMPLIFIED) ||
594  			    (_codepage == CP_JAPANESE) || (_codepage == CP_KOREAN));
595  	};
596  	void scrollPosToCenter(size_t pos);
597  	generic_string getEOLString();
598  	void setBorderEdge(bool doWithBorderEdge);
599  	void sortLines(size_t fromLine, size_t toLine, ISorter *pSort);
600  	void changeTextDirection(bool isRTL);
601  	bool isTextDirectionRTL() const;
602  	void setPositionRestoreNeeded(bool val) { _positionRestoreNeeded = val; };
603  	void markedTextToClipboard(int indiStyle, bool doAll = false);
604  	void removeAnyDuplicateLines();
605  protected:
606  	static bool _SciInit;
607  	static int _refCount;
608      static UserDefineDialog _userDefineDlg;
609      static const int _markersArray[][NB_FOLDER_STATE];
610  	static LRESULT CALLBACK scintillaStatic_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
611  	LRESULT scintillaNew_Proc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
612  	SCINTILLA_FUNC _pScintillaFunc = nullptr;
613  	SCINTILLA_PTR  _pScintillaPtr = nullptr;
614  	static WNDPROC _scintillaDefaultProc;
615  	CallWindowProcFunc _callWindowProc = nullptr;
616  	BufferID attachDefaultDoc();
617  	BufferID _currentBufferID = nullptr;
618  	Buffer * _currentBuffer = nullptr;
619  	int _codepage = CP_ACP;
620  	bool _wrapRestoreNeeded = false;
621  	bool _positionRestoreNeeded = false;
622  	uint32_t _restorePositionRetryCount = 0;
623  	typedef std::unordered_map<int, Style> StyleMap;
624  	typedef std::unordered_map<BufferID, StyleMap*> BufferStyleMap;
625  	BufferStyleMap _hotspotStyles;
626  	intptr_t _beginSelectPosition = -1;
627  	static std::string _defaultCharList;
628  	void restyleBuffer();
629  	const char * getCompleteKeywordList(std::basic_string<char> & kwl, LangType langType, int keywordIndex);
630  	void setKeywords(LangType langType, const char *keywords, int index);
631  	void setLexer(LangType langID, int whichList);
632  	bool setLexerFromLangID(int langID);
633  	void makeStyle(LangType langType, const TCHAR **keywordArray = NULL);
634  	void setStyle(Style styleToSet);			
635  	void setSpecialStyle(const Style & styleToSet);	
636  	void setSpecialIndicator(const Style & styleToSet) {
637  		execute(SCI_INDICSETFORE, styleToSet._styleID, styleToSet._bgColor);
638  	};
639  	void setXmlLexer(LangType type);
640   	void setCppLexer(LangType type);
641  	void setJsLexer();
642  	void setTclLexer();
643      void setObjCLexer(LangType type);
644  	void setUserLexer(const TCHAR *userLangName = NULL);
645  	void setExternalLexer(LangType typeDoc);
646  	void setEmbeddedJSLexer();
647      void setEmbeddedPhpLexer();
648      void setEmbeddedAspLexer();
649  	void setJsonLexer(bool isJson5 = false);
650  	void setTypeScriptLexer();
651  	void setCssLexer() {
652  		setLexer(L_CSS, LIST_0 | LIST_1 | LIST_4 | LIST_6);
653  	};
654  	void setLuaLexer() {
655  		setLexer(L_LUA, LIST_0 | LIST_1 | LIST_2 | LIST_3);
656  	};
657  	void setMakefileLexer() {
658  		setLexer(L_MAKEFILE, LIST_NONE);
659  	};
660  	void setPropsLexer(bool isPropsButNotIni = true) {
661  		LangType L_id = isPropsButNotIni ? L_PROPS : L_INI;
662  		setLexer(L_id, LIST_NONE);
663  		execute(SCI_STYLESETEOLFILLED, SCE_PROPS_SECTION, true);
664  	};
665  	void setSqlLexer() {
666  		const bool kbBackSlash = NppParameters::getInstance().getNppGUI()._backSlashIsEscapeCharacterForSql;
667  		setLexer(L_SQL, LIST_0 | LIST_1 | LIST_4);
668  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("sql.backslash.escapes"), reinterpret_cast<LPARAM>(kbBackSlash ? "1" : "0"));
669  	};
670  	void setMSSqlLexer() {
671  		setLexer(L_MSSQL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
672  	};
673  	void setBashLexer() {
674  		setLexer(L_BASH, LIST_0);
675  	};
676  	void setVBLexer() {
677  		setLexer(L_VB, LIST_0);
678  	};
679  	void setPascalLexer() {
680  		setLexer(L_PASCAL, LIST_0);
681  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
682  	};
683  	void setPerlLexer() {
684  		setLexer(L_PERL, LIST_0);
685  	};
686  	void setPythonLexer() {
687  		setLexer(L_PYTHON, LIST_0 | LIST_1);
688  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.quotes.python"), reinterpret_cast<LPARAM>("1"));
689  	};
690  	void setGDScriptLexer() {
691  		setLexer(L_GDSCRIPT, LIST_0 | LIST_1);
692  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.keywords2.no.sub.identifiers"), reinterpret_cast<LPARAM>("1"));
693  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.gdscript.whinge.level"), reinterpret_cast<LPARAM>("1"));
694  	};
695  	void setBatchLexer() {
696  		setLexer(L_BATCH, LIST_0);
697  	};
698  	void setTeXLexer() {
699  		for (int i = 0 ; i < 4 ; ++i)
700  			execute(SCI_SETKEYWORDS, i, reinterpret_cast<LPARAM>(TEXT("")));
701  		setLexer(L_TEX, LIST_NONE);
702  	};
703  	void setNsisLexer() {
704  		setLexer(L_NSIS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
705  	};
706  	void setFortranLexer() {
707  		setLexer(L_FORTRAN, LIST_0 | LIST_1 | LIST_2);
708  	};
709  	void setFortran77Lexer() {
710  		setLexer(L_FORTRAN_77, LIST_0 | LIST_1 | LIST_2);
711  	};
712  	void setLispLexer(){
713  		setLexer(L_LISP, LIST_0 | LIST_1);
714  	};
715  	void setSchemeLexer(){
716  		setLexer(L_SCHEME, LIST_0 | LIST_1);
717  	};
718  	void setAsmLexer(){
719  		setLexer(L_ASM, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6 | LIST_7);
720  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.syntax.based"), reinterpret_cast<LPARAM>("1"));
721  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.comment.multiline"), reinterpret_cast<LPARAM>("1"));
722  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.asm.comment.explicit"), reinterpret_cast<LPARAM>("1"));
723  	};
724  	void setDiffLexer(){
725  		setLexer(L_DIFF, LIST_NONE);
726  	};
727  	void setPostscriptLexer(){
728  		setLexer(L_PS, LIST_0 | LIST_1 | LIST_2 | LIST_3);
729  	};
730  	void setRubyLexer(){
731  		setLexer(L_RUBY, LIST_0);
732  		execute(SCI_STYLESETEOLFILLED, SCE_RB_POD, true);
733  	};
734  	void setSmalltalkLexer(){
735  		setLexer(L_SMALLTALK, LIST_0);
736  	};
737  	void setVhdlLexer(){
738  		setLexer(L_VHDL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
739  	};
740  	void setKixLexer(){
741  		setLexer(L_KIX, LIST_0 | LIST_1 | LIST_2);
742  	};
743  	void setAutoItLexer(){
744  		setLexer(L_AU3, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
745  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
746  	};
747  	void setCamlLexer(){
748  		setLexer(L_CAML, LIST_0 | LIST_1 | LIST_2);
749  	};
750  	void setAdaLexer(){
751  		setLexer(L_ADA, LIST_0);
752  	};
753  	void setVerilogLexer(){
754  		setLexer(L_VERILOG, LIST_0 | LIST_1);
755  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
756  	};
757  	void setMatlabLexer(){
758  		setLexer(L_MATLAB, LIST_0);
759  	};
760  	void setHaskellLexer(){
761  		setLexer(L_HASKELL, LIST_0);
762  	};
763  	void setInnoLexer() {
764  		setLexer(L_INNO, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
765  	};
766  	void setCmakeLexer() {
767  		setLexer(L_CMAKE, LIST_0 | LIST_1 | LIST_2);
768  	};
769  	void setYamlLexer() {
770  		setLexer(L_YAML, LIST_0);
771  	};
772      void setCobolLexer() {
773  		setLexer(L_COBOL, LIST_0 | LIST_1 | LIST_2);
774  	};
775      void setGui4CliLexer() {
776  		setLexer(L_GUI4CLI, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4);
777  	};
778      void setDLexer() {
779  		setLexer(L_D, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
780  	};
781      void setPowerShellLexer() {
782  		setLexer(L_POWERSHELL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
783  	};
784      void setRLexer() {
785  		setLexer(L_R, LIST_0 | LIST_1 | LIST_2);
786  	};
787      void setCoffeeScriptLexer() {
788  		setLexer(L_COFFEESCRIPT, LIST_0 | LIST_1 | LIST_2  | LIST_3);
789  	};
790  	void setBaanCLexer() {
791  		setLexer(L_BAANC, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6 | LIST_7 | LIST_8);
792  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("lexer.baan.styling.within.preprocessor"), reinterpret_cast<LPARAM>("1"));
793  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$:"));
794  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.preprocessor"), reinterpret_cast<LPARAM>("1"));
795  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.syntax.based"), reinterpret_cast<LPARAM>("1"));
796  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.keywords.based"), reinterpret_cast<LPARAM>("1"));
797  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.sections"), reinterpret_cast<LPARAM>("1"));
798  		execute(SCI_SETPROPERTY, reinterpret_cast<WPARAM>("fold.baan.inner.level"), reinterpret_cast<LPARAM>("1"));
799  		execute(SCI_STYLESETEOLFILLED, SCE_BAAN_STRINGEOL, true);
800  	};
801  	void setSrecLexer() {
802  		setLexer(L_SREC, LIST_NONE);
803  	};
804  	void setIHexLexer() {
805  		setLexer(L_IHEX, LIST_NONE);
806  	};
807  	void setTEHexLexer() {
808  		setLexer(L_TEHEX, LIST_NONE);
809  	};
810  	void setAsn1Lexer() {
811  		setLexer(L_ASN1, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
812  	};
813  	void setAVSLexer() {
814  		setLexer(L_AVS, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
815  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
816  	};
817  	void setBlitzBasicLexer() {
818  		setLexer(L_BLITZBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
819  	};
820  	void setPureBasicLexer() {
821  		setLexer(L_PUREBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
822  	};
823  	void setFreeBasicLexer() {
824  		setLexer(L_FREEBASIC, LIST_0 | LIST_1 | LIST_2 | LIST_3); 
825  	};
826  	void setCsoundLexer() {
827  		setLexer(L_CSOUND, LIST_0 | LIST_1 | LIST_2);
828  		execute(SCI_STYLESETEOLFILLED, SCE_CSOUND_STRINGEOL, true);
829  	};
830  	void setErlangLexer() {
831  		setLexer(L_ERLANG, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5); 
832  	};
833  	void setESCRIPTLexer() {
834  		setLexer(L_ESCRIPT, LIST_0 | LIST_1 | LIST_2); 
835  	};
836  	void setForthLexer() {
837  		setLexer(L_FORTH, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
838  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
839  	};
840  	void setLatexLexer() {
841  		setLexer(L_LATEX, LIST_NONE); 
842  	};
843  	void setMMIXALLexer() {
844  		setLexer(L_MMIXAL, LIST_0 | LIST_1 | LIST_2); 
845  	};
846  	void setNimrodLexer() {
847  		setLexer(L_NIM, LIST_0);
848  	};
849  	void setNncrontabLexer() {
850  		setLexer(L_NNCRONTAB, LIST_0 | LIST_1 | LIST_2); 
851  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789%-"));
852  	};
853  	void setOScriptLexer() {
854  		setLexer(L_OSCRIPT, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5);
855  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$"));
856  	};
857  	void setREBOLLexer() {
858  		setLexer(L_REBOL, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6);
859  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!.'+-*&|=_~"));
860  	};
861  	void setRegistryLexer() {
862  		setLexer(L_REGISTRY, LIST_NONE); 
863  	};
864  	void setRustLexer() {
865  		setLexer(L_RUST, LIST_0 | LIST_1 | LIST_2 | LIST_3 | LIST_4 | LIST_5 | LIST_6); 
866  		execute(SCI_SETWORDCHARS, 0, reinterpret_cast<LPARAM>("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#"));
867  	};
868  	void setSpiceLexer() {
869  		setLexer(L_SPICE, LIST_0 | LIST_1 | LIST_2); 
870  	};
871  	void setTxt2tagsLexer() {
872  		setLexer(L_TXT2TAGS, LIST_NONE); 
873  	};
874  	void setVisualPrologLexer() {
875  		setLexer(L_VISUALPROLOG, LIST_0 | LIST_1 | LIST_2 | LIST_3);
876  	}
877  	void setHollywoodLexer() {
878  		setLexer(L_HOLLYWOOD, LIST_0 | LIST_1 | LIST_2 | LIST_3);
879  	};	
880  	void setSearchResultLexer() {
881  		if (execute(SCI_GETLEXER) == SCLEX_SEARCHRESULT)
882  		{
883  			makeStyle(L_SEARCHRESULT, nullptr);
884  			return;
885  		}
886  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_FILE_HEADER, true);
887  		execute(SCI_STYLESETEOLFILLED, SCE_SEARCHRESULT_SEARCH_HEADER, true);
888  		setLexer(L_SEARCHRESULT, LIST_NONE);
889  	};
890  	bool isNeededFolderMarge(LangType typeDoc) const {
891  		switch (typeDoc)
892  		{
893  			case L_ASCII:
894  			case L_BATCH:
895  			case L_TEXT:
896  			case L_MAKEFILE:
897  			case L_HASKELL:
898  			case L_SMALLTALK:
899  			case L_KIX:
900  			case L_ADA:
901  				return false;
902  			default:
903  				return true;
904  		}
905  	};
906      void defineMarker(int marker, int markerType, COLORREF fore, COLORREF back, COLORREF foreActive) {
907  	    execute(SCI_MARKERDEFINE, marker, markerType);
908  	    execute(SCI_MARKERSETFORE, marker, fore);
909  	    execute(SCI_MARKERSETBACK, marker, back);
910  		execute(SCI_MARKERSETBACKSELECTED, marker, foreActive);
911  	};
912  	int codepage2CharSet() const {
913  		switch (_codepage)
914  		{
915  			case CP_CHINESE_TRADITIONAL : return SC_CHARSET_CHINESEBIG5;
916  			case CP_CHINESE_SIMPLIFIED : return SC_CHARSET_GB2312;
917  			case CP_KOREAN : return SC_CHARSET_HANGUL;
918  			case CP_JAPANESE : return SC_CHARSET_SHIFTJIS;
919  			case CP_GREEK : return SC_CHARSET_GREEK;
920  			default : return 0;
921  		}
922  	};
923  	std::pair<size_t, size_t> getWordRange();
924  	bool expandWordSelection();
925  	void getFoldColor(COLORREF& fgColor, COLORREF& bgColor, COLORREF& activeFgColor);
926  };
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaCall.h</h3>
            <pre><code>1  #ifndef SCINTILLACALL_H
2  #define SCINTILLACALL_H
3  namespace Scintilla {
4  enum class Message;	
5  struct TextRangeFull;
6  struct TextToFindFull;
7  struct RangeToFormatFull;
8  using FunctionDirect = intptr_t(*)(intptr_t ptr, unsigned int iMessage, uintptr_t wParam, intptr_t lParam, int *pStatus);
9  struct Failure {
10  	Scintilla::Status status;
11  	explicit Failure(Scintilla::Status status_) noexcept : status(status_) {
12  	}
13  };
14  struct Span {
15  	Position start;
16  	Position end;
17  	explicit Span(Position position) noexcept : start(position), end(position) {
18  	}
19  	Span(Position start_, Position end_) noexcept : start(start_), end(end_) {
20  	}
21  	Position Length() const noexcept {
22  		if (end > start)
23  			return end - start;
24  		else
25  			return start - end;
26  	}
27  	bool operator==(const Span &other) const noexcept {
28  		return (other.start == start) && (other.end == end);
29  	}
30  };
31  class ScintillaCall {
32  	FunctionDirect fn;
33  	intptr_t ptr;
34  	intptr_t CallPointer(Message msg, uintptr_t wParam, void *s);
35  	intptr_t CallString(Message msg, uintptr_t wParam, const char *s);
36  	std::string CallReturnString(Message msg, uintptr_t wParam);
37  public:
38  	Scintilla::Status statusLastCall;
39  	ScintillaCall() noexcept;
40  	void SetFnPtr(FunctionDirect fn_, intptr_t ptr_) noexcept;
41  	bool IsValid() const noexcept;
42  	intptr_t Call(Message msg, uintptr_t wParam=0, intptr_t lParam=0);
43  	Position LineStart(Line line);
44  	Position LineEnd(Line line);
45  	Span SelectionSpan();
46  	Span TargetSpan();
47  	void SetTarget(Span span);
48  	void ColouriseAll();
49  	char CharacterAt(Position position);
50  	int UnsignedStyleAt(Position position);
51  	std::string StringOfSpan(Span span);
52  	std::string StringOfRange(Span span);
53  	Position ReplaceTarget(std::string_view text);
54  	Position ReplaceTargetRE(std::string_view text);
55  	Position ReplaceTargetMinimal(std::string_view text);
56  	Position SearchInTarget(std::string_view text);
57  	Span SpanSearchInTarget(std::string_view text);
58  /&bsol;**\(\*\n\)
59  	void AddText(Position length, const char *text);
60  	void AddStyledText(Position length, const char *c);
61  	void InsertText(Position pos, const char *text);
62  	void ChangeInsertion(Position length, const char *text);
63  	void ClearAll();
64  	void DeleteRange(Position start, Position lengthDelete);
65  	void ClearDocumentStyle();
66  	Position Length();
67  	int CharAt(Position pos);
68  	Position CurrentPos();
69  	Position Anchor();
70  	int StyleAt(Position pos);
71  	int StyleIndexAt(Position pos);
72  	void Redo();
73  	void SetUndoCollection(bool collectUndo);
74  	void SelectAll();
75  	void SetSavePoint();
76  	Position GetStyledText(void *tr);
77  	Position GetStyledTextFull(TextRangeFull *tr);
78  	bool CanRedo();
79  	Line MarkerLineFromHandle(int markerHandle);
80  	void MarkerDeleteHandle(int markerHandle);
81  	int MarkerHandleFromLine(Line line, int which);
82  	int MarkerNumberFromLine(Line line, int which);
83  	bool UndoCollection();
84  	Scintilla::WhiteSpace ViewWS();
85  	void SetViewWS(Scintilla::WhiteSpace viewWS);
86  	Scintilla::TabDrawMode TabDrawMode();
87  	void SetTabDrawMode(Scintilla::TabDrawMode tabDrawMode);
88  	Position PositionFromPoint(int x, int y);
89  	Position PositionFromPointClose(int x, int y);
90  	void GotoLine(Line line);
91  	void GotoPos(Position caret);
92  	void SetAnchor(Position anchor);
93  	Position GetCurLine(Position length, char *text);
94  	std::string GetCurLine(Position length);
95  	Position EndStyled();
96  	void ConvertEOLs(Scintilla::EndOfLine eolMode);
97  	Scintilla::EndOfLine EOLMode();
98  	void SetEOLMode(Scintilla::EndOfLine eolMode);
99  	void StartStyling(Position start, int unused);
100  	void SetStyling(Position length, int style);
101  	bool BufferedDraw();
102  	void SetBufferedDraw(bool buffered);
103  	void SetTabWidth(int tabWidth);
104  	int TabWidth();
105  	void SetTabMinimumWidth(int pixels);
106  	int TabMinimumWidth();
107  	void ClearTabStops(Line line);
108  	void AddTabStop(Line line, int x);
109  	int GetNextTabStop(Line line, int x);
110  	void SetCodePage(int codePage);
111  	void SetFontLocale(const char *localeName);
112  	int FontLocale(char *localeName);
113  	std::string FontLocale();
114  	Scintilla::IMEInteraction IMEInteraction();
115  	void SetIMEInteraction(Scintilla::IMEInteraction imeInteraction);
116  	void MarkerDefine(int markerNumber, Scintilla::MarkerSymbol markerSymbol);
117  	void MarkerSetFore(int markerNumber, Colour fore);
118  	void MarkerSetBack(int markerNumber, Colour back);
119  	void MarkerSetBackSelected(int markerNumber, Colour back);
120  	void MarkerSetForeTranslucent(int markerNumber, ColourAlpha fore);
121  	void MarkerSetBackTranslucent(int markerNumber, ColourAlpha back);
122  	void MarkerSetBackSelectedTranslucent(int markerNumber, ColourAlpha back);
123  	void MarkerSetStrokeWidth(int markerNumber, int hundredths);
124  	void MarkerEnableHighlight(bool enabled);
125  	int MarkerAdd(Line line, int markerNumber);
126  	void MarkerDelete(Line line, int markerNumber);
127  	void MarkerDeleteAll(int markerNumber);
128  	int MarkerGet(Line line);
129  	Line MarkerNext(Line lineStart, int markerMask);
130  	Line MarkerPrevious(Line lineStart, int markerMask);
131  	void MarkerDefinePixmap(int markerNumber, const char *pixmap);
132  	void MarkerAddSet(Line line, int markerSet);
133  	void MarkerSetAlpha(int markerNumber, Scintilla::Alpha alpha);
134  	Scintilla::Layer MarkerGetLayer(int markerNumber);
135  	void MarkerSetLayer(int markerNumber, Scintilla::Layer layer);
136  	void SetMarginTypeN(int margin, Scintilla::MarginType marginType);
137  	Scintilla::MarginType MarginTypeN(int margin);
138  	void SetMarginWidthN(int margin, int pixelWidth);
139  	int MarginWidthN(int margin);
140  	void SetMarginMaskN(int margin, int mask);
141  	int MarginMaskN(int margin);
142  	void SetMarginSensitiveN(int margin, bool sensitive);
143  	bool MarginSensitiveN(int margin);
144  	void SetMarginCursorN(int margin, Scintilla::CursorShape cursor);
145  	Scintilla::CursorShape MarginCursorN(int margin);
146  	void SetMarginBackN(int margin, Colour back);
147  	Colour MarginBackN(int margin);
148  	void SetMargins(int margins);
149  	int Margins();
150  	void StyleClearAll();
151  	void StyleSetFore(int style, Colour fore);
152  	void StyleSetBack(int style, Colour back);
153  	void StyleSetBold(int style, bool bold);
154  	void StyleSetItalic(int style, bool italic);
155  	void StyleSetSize(int style, int sizePoints);
156  	void StyleSetFont(int style, const char *fontName);
157  	void StyleSetEOLFilled(int style, bool eolFilled);
158  	void StyleResetDefault();
159  	void StyleSetUnderline(int style, bool underline);
160  	Colour StyleGetFore(int style);
161  	Colour StyleGetBack(int style);
162  	bool StyleGetBold(int style);
163  	bool StyleGetItalic(int style);
164  	int StyleGetSize(int style);
165  	int StyleGetFont(int style, char *fontName);
166  	std::string StyleGetFont(int style);
167  	bool StyleGetEOLFilled(int style);
168  	bool StyleGetUnderline(int style);
169  	Scintilla::CaseVisible StyleGetCase(int style);
170  	Scintilla::CharacterSet StyleGetCharacterSet(int style);
171  	bool StyleGetVisible(int style);
172  	bool StyleGetChangeable(int style);
173  	bool StyleGetHotSpot(int style);
174  	void StyleSetCase(int style, Scintilla::CaseVisible caseVisible);
175  	void StyleSetSizeFractional(int style, int sizeHundredthPoints);
176  	int StyleGetSizeFractional(int style);
177  	void StyleSetWeight(int style, Scintilla::FontWeight weight);
178  	Scintilla::FontWeight StyleGetWeight(int style);
179  	void StyleSetCharacterSet(int style, Scintilla::CharacterSet characterSet);
180  	void StyleSetHotSpot(int style, bool hotspot);
181  	void StyleSetCheckMonospaced(int style, bool checkMonospaced);
182  	bool StyleGetCheckMonospaced(int style);
183  	void StyleSetInvisibleRepresentation(int style, const char *representation);
184  	int StyleGetInvisibleRepresentation(int style, char *representation);
185  	std::string StyleGetInvisibleRepresentation(int style);
186  	void SetElementColour(Scintilla::Element element, ColourAlpha colourElement);
187  	ColourAlpha ElementColour(Scintilla::Element element);
188  	void ResetElementColour(Scintilla::Element element);
189  	bool ElementIsSet(Scintilla::Element element);
190  	bool ElementAllowsTranslucent(Scintilla::Element element);
191  	ColourAlpha ElementBaseColour(Scintilla::Element element);
192  	void SetSelFore(bool useSetting, Colour fore);
193  	void SetSelBack(bool useSetting, Colour back);
194  	Scintilla::Alpha SelAlpha();
195  	void SetSelAlpha(Scintilla::Alpha alpha);
196  	bool SelEOLFilled();
197  	void SetSelEOLFilled(bool filled);
198  	Scintilla::Layer SelectionLayer();
199  	void SetSelectionLayer(Scintilla::Layer layer);
200  	Scintilla::Layer CaretLineLayer();
201  	void SetCaretLineLayer(Scintilla::Layer layer);
202  	bool CaretLineHighlightSubLine();
203  	void SetCaretLineHighlightSubLine(bool subLine);
204  	void SetCaretFore(Colour fore);
205  	void AssignCmdKey(int keyDefinition, int sciCommand);
206  	void ClearCmdKey(int keyDefinition);
207  	void ClearAllCmdKeys();
208  	void SetStylingEx(Position length, const char *styles);
209  	void StyleSetVisible(int style, bool visible);
210  	int CaretPeriod();
211  	void SetCaretPeriod(int periodMilliseconds);
212  	void SetWordChars(const char *characters);
213  	int WordChars(char *characters);
214  	std::string WordChars();
215  	void SetCharacterCategoryOptimization(int countCharacters);
216  	int CharacterCategoryOptimization();
217  	void BeginUndoAction();
218  	void EndUndoAction();
219  	void IndicSetStyle(int indicator, Scintilla::IndicatorStyle indicatorStyle);
220  	Scintilla::IndicatorStyle IndicGetStyle(int indicator);
221  	void IndicSetFore(int indicator, Colour fore);
222  	Colour IndicGetFore(int indicator);
223  	void IndicSetUnder(int indicator, bool under);
224  	bool IndicGetUnder(int indicator);
225  	void IndicSetHoverStyle(int indicator, Scintilla::IndicatorStyle indicatorStyle);
226  	Scintilla::IndicatorStyle IndicGetHoverStyle(int indicator);
227  	void IndicSetHoverFore(int indicator, Colour fore);
228  	Colour IndicGetHoverFore(int indicator);
229  	void IndicSetFlags(int indicator, Scintilla::IndicFlag flags);
230  	Scintilla::IndicFlag IndicGetFlags(int indicator);
231  	void IndicSetStrokeWidth(int indicator, int hundredths);
232  	int IndicGetStrokeWidth(int indicator);
233  	void SetWhitespaceFore(bool useSetting, Colour fore);
234  	void SetWhitespaceBack(bool useSetting, Colour back);
235  	void SetWhitespaceSize(int size);
236  	int WhitespaceSize();
237  	void SetLineState(Line line, int state);
238  	int LineState(Line line);
239  	int MaxLineState();
240  	bool CaretLineVisible();
241  	void SetCaretLineVisible(bool show);
242  	Colour CaretLineBack();
243  	void SetCaretLineBack(Colour back);
244  	int CaretLineFrame();
245  	void SetCaretLineFrame(int width);
246  	void StyleSetChangeable(int style, bool changeable);
<span onclick='openModal()' class='match'>247  	void AutoCShow(Position lengthEntered, const char *itemList);
248  	void AutoCCancel();
249  	bool AutoCActive();
</span>250  	Position AutoCPosStart();
251  	void AutoCComplete();
252  	void AutoCStops(const char *characterSet);
253  	void AutoCSetSeparator(int separatorCharacter);
254  	int AutoCGetSeparator();
255  	void AutoCSelect(const char *select);
256  	void AutoCSetCancelAtStart(bool cancel);
257  	bool AutoCGetCancelAtStart();
258  	void AutoCSetFillUps(const char *characterSet);
259  	void AutoCSetChooseSingle(bool chooseSingle);
260  	bool AutoCGetChooseSingle();
261  	void AutoCSetIgnoreCase(bool ignoreCase);
262  	bool AutoCGetIgnoreCase();
263  	void UserListShow(int listType, const char *itemList);
264  	void AutoCSetAutoHide(bool autoHide);
265  	bool AutoCGetAutoHide();
266  	void AutoCSetOptions(Scintilla::AutoCompleteOption options);
267  	Scintilla::AutoCompleteOption AutoCGetOptions();
268  	void AutoCSetDropRestOfWord(bool dropRestOfWord);
269  	bool AutoCGetDropRestOfWord();
270  	void RegisterImage(int type, const char *xpmData);
271  	void ClearRegisteredImages();
272  	int AutoCGetTypeSeparator();
273  	void AutoCSetTypeSeparator(int separatorCharacter);
274  	void AutoCSetMaxWidth(int characterCount);
275  	int AutoCGetMaxWidth();
276  	void AutoCSetMaxHeight(int rowCount);
277  	int AutoCGetMaxHeight();
278  	void SetIndent(int indentSize);
279  	int Indent();
280  	void SetUseTabs(bool useTabs);
281  	bool UseTabs();
282  	void SetLineIndentation(Line line, int indentation);
283  	int LineIndentation(Line line);
284  	Position LineIndentPosition(Line line);
285  	Position Column(Position pos);
286  	Position CountCharacters(Position start, Position end);
287  	Position CountCodeUnits(Position start, Position end);
288  	void SetHScrollBar(bool visible);
289  	bool HScrollBar();
290  	void SetIndentationGuides(Scintilla::IndentView indentView);
291  	Scintilla::IndentView IndentationGuides();
292  	void SetHighlightGuide(Position column);
293  	Position HighlightGuide();
294  	Position LineEndPosition(Line line);
295  	int CodePage();
296  	Colour CaretFore();
297  	bool ReadOnly();
298  	void SetCurrentPos(Position caret);
299  	void SetSelectionStart(Position anchor);
300  	Position SelectionStart();
301  	void SetSelectionEnd(Position caret);
302  	Position SelectionEnd();
303  	void SetEmptySelection(Position caret);
304  	void SetPrintMagnification(int magnification);
305  	int PrintMagnification();
306  	void SetPrintColourMode(Scintilla::PrintOption mode);
307  	Scintilla::PrintOption PrintColourMode();
308  	Position FindText(Scintilla::FindOption searchFlags, void *ft);
309  	Position FindTextFull(Scintilla::FindOption searchFlags, TextToFindFull *ft);
310  	Position FormatRange(bool draw, void *fr);
311  	Position FormatRangeFull(bool draw, RangeToFormatFull *fr);
312  	void SetChangeHistory(Scintilla::ChangeHistoryOption changeHistory);
313  	Scintilla::ChangeHistoryOption ChangeHistory();
314  	Line FirstVisibleLine();
315  	Position GetLine(Line line, char *text);
316  	std::string GetLine(Line line);
317  	Line LineCount();
318  	void AllocateLines(Line lines);
319  	void SetMarginLeft(int pixelWidth);
320  	int MarginLeft();
321  	void SetMarginRight(int pixelWidth);
322  	int MarginRight();
323  	bool Modify();
324  	void SetSel(Position anchor, Position caret);
325  	Position GetSelText(char *text);
326  	std::string GetSelText();
327  	Position GetTextRange(void *tr);
328  	Position GetTextRangeFull(TextRangeFull *tr);
329  	void HideSelection(bool hide);
330  	bool SelectionHidden();
331  	int PointXFromPosition(Position pos);
332  	int PointYFromPosition(Position pos);
333  	Line LineFromPosition(Position pos);
334  	Position PositionFromLine(Line line);
335  	void LineScroll(Position columns, Line lines);
336  	void ScrollCaret();
337  	void ScrollRange(Position secondary, Position primary);
338  	void ReplaceSel(const char *text);
339  	void SetReadOnly(bool readOnly);
340  	void Null();
341  	bool CanPaste();
342  	bool CanUndo();
343  	void EmptyUndoBuffer();
344  	void Undo();
345  	void Cut();
346  	void Copy();
347  	void Paste();
348  	void Clear();
349  	void SetText(const char *text);
350  	Position GetText(Position length, char *text);
351  	std::string GetText(Position length);
352  	Position TextLength();
353  	void *DirectFunction();
354  	void *DirectStatusFunction();
355  	void *DirectPointer();
356  	void SetOvertype(bool overType);
357  	bool Overtype();
358  	void SetCaretWidth(int pixelWidth);
359  	int CaretWidth();
360  	void SetTargetStart(Position start);
361  	Position TargetStart();
362  	void SetTargetStartVirtualSpace(Position space);
363  	Position TargetStartVirtualSpace();
364  	void SetTargetEnd(Position end);
365  	Position TargetEnd();
366  	void SetTargetEndVirtualSpace(Position space);
367  	Position TargetEndVirtualSpace();
368  	void SetTargetRange(Position start, Position end);
369  	Position TargetText(char *text);
370  	std::string TargetText();
371  	void TargetFromSelection();
372  	void TargetWholeDocument();
373  	Position ReplaceTarget(Position length, const char *text);
374  	Position ReplaceTargetRE(Position length, const char *text);
375  	Position ReplaceTargetMinimal(Position length, const char *text);
376  	Position SearchInTarget(Position length, const char *text);
377  	void SetSearchFlags(Scintilla::FindOption searchFlags);
378  	Scintilla::FindOption SearchFlags();
379  	void CallTipShow(Position pos, const char *definition);
380  	void CallTipCancel();
381  	bool CallTipActive();
382  	Position CallTipPosStart();
383  	void CallTipSetPosStart(Position posStart);
384  	void CallTipSetHlt(Position highlightStart, Position highlightEnd);
385  	void CallTipSetBack(Colour back);
386  	void CallTipSetFore(Colour fore);
387  	void CallTipSetForeHlt(Colour fore);
388  	void CallTipUseStyle(int tabSize);
389  	void CallTipSetPosition(bool above);
390  	Line VisibleFromDocLine(Line docLine);
391  	Line DocLineFromVisible(Line displayLine);
392  	Line WrapCount(Line docLine);
393  	void SetFoldLevel(Line line, Scintilla::FoldLevel level);
394  	Scintilla::FoldLevel FoldLevel(Line line);
395  	Line LastChild(Line line, Scintilla::FoldLevel level);
396  	Line FoldParent(Line line);
397  	void ShowLines(Line lineStart, Line lineEnd);
398  	void HideLines(Line lineStart, Line lineEnd);
399  	bool LineVisible(Line line);
400  	bool AllLinesVisible();
401  	void SetFoldExpanded(Line line, bool expanded);
402  	bool FoldExpanded(Line line);
403  	void ToggleFold(Line line);
404  	void ToggleFoldShowText(Line line, const char *text);
405  	void FoldDisplayTextSetStyle(Scintilla::FoldDisplayTextStyle style);
406  	Scintilla::FoldDisplayTextStyle FoldDisplayTextGetStyle();
407  	void SetDefaultFoldDisplayText(const char *text);
408  	int GetDefaultFoldDisplayText(char *text);
409  	std::string GetDefaultFoldDisplayText();
410  	void FoldLine(Line line, Scintilla::FoldAction action);
411  	void FoldChildren(Line line, Scintilla::FoldAction action);
412  	void ExpandChildren(Line line, Scintilla::FoldLevel level);
413  	void FoldAll(Scintilla::FoldAction action);
414  	void EnsureVisible(Line line);
415  	void SetAutomaticFold(Scintilla::AutomaticFold automaticFold);
416  	Scintilla::AutomaticFold AutomaticFold();
417  	void SetFoldFlags(Scintilla::FoldFlag flags);
418  	void EnsureVisibleEnforcePolicy(Line line);
419  	void SetTabIndents(bool tabIndents);
420  	bool TabIndents();
421  	void SetBackSpaceUnIndents(bool bsUnIndents);
422  	bool BackSpaceUnIndents();
423  	void SetMouseDwellTime(int periodMilliseconds);
424  	int MouseDwellTime();
425  	Position WordStartPosition(Position pos, bool onlyWordCharacters);
426  	Position WordEndPosition(Position pos, bool onlyWordCharacters);
427  	bool IsRangeWord(Position start, Position end);
428  	void SetIdleStyling(Scintilla::IdleStyling idleStyling);
429  	Scintilla::IdleStyling IdleStyling();
430  	void SetWrapMode(Scintilla::Wrap wrapMode);
431  	Scintilla::Wrap WrapMode();
432  	void SetWrapVisualFlags(Scintilla::WrapVisualFlag wrapVisualFlags);
433  	Scintilla::WrapVisualFlag WrapVisualFlags();
434  	void SetWrapVisualFlagsLocation(Scintilla::WrapVisualLocation wrapVisualFlagsLocation);
435  	Scintilla::WrapVisualLocation WrapVisualFlagsLocation();
436  	void SetWrapStartIndent(int indent);
437  	int WrapStartIndent();
438  	void SetWrapIndentMode(Scintilla::WrapIndentMode wrapIndentMode);
439  	Scintilla::WrapIndentMode WrapIndentMode();
440  	void SetLayoutCache(Scintilla::LineCache cacheMode);
441  	Scintilla::LineCache LayoutCache();
442  	void SetScrollWidth(int pixelWidth);
443  	int ScrollWidth();
444  	void SetScrollWidthTracking(bool tracking);
445  	bool ScrollWidthTracking();
446  	int TextWidth(int style, const char *text);
447  	void SetEndAtLastLine(bool endAtLastLine);
448  	bool EndAtLastLine();
449  	int TextHeight(Line line);
450  	void SetVScrollBar(bool visible);
451  	bool VScrollBar();
452  	void AppendText(Position length, const char *text);
453  	Scintilla::PhasesDraw PhasesDraw();
454  	void SetPhasesDraw(Scintilla::PhasesDraw phases);
455  	void SetFontQuality(Scintilla::FontQuality fontQuality);
456  	Scintilla::FontQuality FontQuality();
457  	void SetFirstVisibleLine(Line displayLine);
458  	void SetMultiPaste(Scintilla::MultiPaste multiPaste);
459  	Scintilla::MultiPaste MultiPaste();
460  	int Tag(int tagNumber, char *tagValue);
461  	std::string Tag(int tagNumber);
462  	void LinesJoin();
463  	void LinesSplit(int pixelWidth);
464  	void SetFoldMarginColour(bool useSetting, Colour back);
465  	void SetFoldMarginHiColour(bool useSetting, Colour fore);
466  	void SetAccessibility(Scintilla::Accessibility accessibility);
467  	Scintilla::Accessibility Accessibility();
468  	void LineDown();
469  	void LineDownExtend();
470  	void LineUp();
471  	void LineUpExtend();
472  	void CharLeft();
473  	void CharLeftExtend();
474  	void CharRight();
475  	void CharRightExtend();
476  	void WordLeft();
477  	void WordLeftExtend();
478  	void WordRight();
479  	void WordRightExtend();
480  	void Home();
481  	void HomeExtend();
482  	void LineEnd();
483  	void LineEndExtend();
484  	void DocumentStart();
485  	void DocumentStartExtend();
486  	void DocumentEnd();
487  	void DocumentEndExtend();
488  	void PageUp();
489  	void PageUpExtend();
490  	void PageDown();
491  	void PageDownExtend();
492  	void EditToggleOvertype();
493  	void Cancel();
494  	void DeleteBack();
495  	void Tab();
496  	void BackTab();
497  	void NewLine();
498  	void FormFeed();
499  	void VCHome();
500  	void VCHomeExtend();
501  	void ZoomIn();
502  	void ZoomOut();
503  	void DelWordLeft();
504  	void DelWordRight();
505  	void DelWordRightEnd();
506  	void LineCut();
507  	void LineDelete();
508  	void LineTranspose();
509  	void LineReverse();
510  	void LineDuplicate();
511  	void LowerCase();
512  	void UpperCase();
513  	void LineScrollDown();
514  	void LineScrollUp();
515  	void DeleteBackNotLine();
516  	void HomeDisplay();
517  	void HomeDisplayExtend();
518  	void LineEndDisplay();
519  	void LineEndDisplayExtend();
520  	void HomeWrap();
521  	void HomeWrapExtend();
522  	void LineEndWrap();
523  	void LineEndWrapExtend();
524  	void VCHomeWrap();
525  	void VCHomeWrapExtend();
526  	void LineCopy();
527  	void MoveCaretInsideView();
528  	Position LineLength(Line line);
529  	void BraceHighlight(Position posA, Position posB);
530  	void BraceHighlightIndicator(bool useSetting, int indicator);
531  	void BraceBadLight(Position pos);
532  	void BraceBadLightIndicator(bool useSetting, int indicator);
533  	Position BraceMatch(Position pos, int maxReStyle);
534  	Position BraceMatchNext(Position pos, Position startPos);
535  	bool ViewEOL();
536  	void SetViewEOL(bool visible);
537  	void *DocPointer();
538  	void SetDocPointer(void *doc);
539  	void SetModEventMask(Scintilla::ModificationFlags eventMask);
540  	Position EdgeColumn();
541  	void SetEdgeColumn(Position column);
542  	Scintilla::EdgeVisualStyle EdgeMode();
543  	void SetEdgeMode(Scintilla::EdgeVisualStyle edgeMode);
544  	Colour EdgeColour();
545  	void SetEdgeColour(Colour edgeColour);
546  	void MultiEdgeAddLine(Position column, Colour edgeColour);
547  	void MultiEdgeClearAll();
548  	Position MultiEdgeColumn(int which);
549  	void SearchAnchor();
550  	Position SearchNext(Scintilla::FindOption searchFlags, const char *text);
551  	Position SearchPrev(Scintilla::FindOption searchFlags, const char *text);
552  	Line LinesOnScreen();
553  	void UsePopUp(Scintilla::PopUp popUpMode);
554  	bool SelectionIsRectangle();
555  	void SetZoom(int zoomInPoints);
556  	int Zoom();
557  	void *CreateDocument(Position bytes, Scintilla::DocumentOption documentOptions);
558  	void AddRefDocument(void *doc);
559  	void ReleaseDocument(void *doc);
560  	Scintilla::DocumentOption DocumentOptions();
561  	Scintilla::ModificationFlags ModEventMask();
562  	void SetCommandEvents(bool commandEvents);
563  	bool CommandEvents();
564  	void SetFocus(bool focus);
565  	bool Focus();
566  	void SetStatus(Scintilla::Status status);
567  	Scintilla::Status Status();
568  	void SetMouseDownCaptures(bool captures);
569  	bool MouseDownCaptures();
570  	void SetMouseWheelCaptures(bool captures);
571  	bool MouseWheelCaptures();
572  	void SetCursor(Scintilla::CursorShape cursorType);
573  	Scintilla::CursorShape Cursor();
574  	void SetControlCharSymbol(int symbol);
575  	int ControlCharSymbol();
576  	void WordPartLeft();
577  	void WordPartLeftExtend();
578  	void WordPartRight();
579  	void WordPartRightExtend();
580  	void SetVisiblePolicy(Scintilla::VisiblePolicy visiblePolicy, int visibleSlop);
581  	void DelLineLeft();
582  	void DelLineRight();
583  	void SetXOffset(int xOffset);
584  	int XOffset();
585  	void ChooseCaretX();
586  	void GrabFocus();
587  	void SetXCaretPolicy(Scintilla::CaretPolicy caretPolicy, int caretSlop);
588  	void SetYCaretPolicy(Scintilla::CaretPolicy caretPolicy, int caretSlop);
589  	void SetPrintWrapMode(Scintilla::Wrap wrapMode);
590  	Scintilla::Wrap PrintWrapMode();
591  	void SetHotspotActiveFore(bool useSetting, Colour fore);
592  	Colour HotspotActiveFore();
593  	void SetHotspotActiveBack(bool useSetting, Colour back);
594  	Colour HotspotActiveBack();
595  	void SetHotspotActiveUnderline(bool underline);
596  	bool HotspotActiveUnderline();
597  	void SetHotspotSingleLine(bool singleLine);
598  	bool HotspotSingleLine();
599  	void ParaDown();
600  	void ParaDownExtend();
601  	void ParaUp();
602  	void ParaUpExtend();
603  	Position PositionBefore(Position pos);
604  	Position PositionAfter(Position pos);
605  	Position PositionRelative(Position pos, Position relative);
606  	Position PositionRelativeCodeUnits(Position pos, Position relative);
607  	void CopyRange(Position start, Position end);
608  	void CopyText(Position length, const char *text);
609  	void SetSelectionMode(Scintilla::SelectionMode selectionMode);
610  	Scintilla::SelectionMode SelectionMode();
611  	bool MoveExtendsSelection();
612  	Position GetLineSelStartPosition(Line line);
613  	Position GetLineSelEndPosition(Line line);
614  	void LineDownRectExtend();
615  	void LineUpRectExtend();
616  	void CharLeftRectExtend();
617  	void CharRightRectExtend();
618  	void HomeRectExtend();
619  	void VCHomeRectExtend();
620  	void LineEndRectExtend();
621  	void PageUpRectExtend();
622  	void PageDownRectExtend();
623  	void StutteredPageUp();
624  	void StutteredPageUpExtend();
625  	void StutteredPageDown();
626  	void StutteredPageDownExtend();
627  	void WordLeftEnd();
628  	void WordLeftEndExtend();
629  	void WordRightEnd();
630  	void WordRightEndExtend();
631  	void SetWhitespaceChars(const char *characters);
632  	int WhitespaceChars(char *characters);
633  	std::string WhitespaceChars();
634  	void SetPunctuationChars(const char *characters);
635  	int PunctuationChars(char *characters);
636  	std::string PunctuationChars();
637  	void SetCharsDefault();
638  	int AutoCGetCurrent();
639  	int AutoCGetCurrentText(char *text);
640  	std::string AutoCGetCurrentText();
641  	void AutoCSetCaseInsensitiveBehaviour(Scintilla::CaseInsensitiveBehaviour behaviour);
642  	Scintilla::CaseInsensitiveBehaviour AutoCGetCaseInsensitiveBehaviour();
643  	void AutoCSetMulti(Scintilla::MultiAutoComplete multi);
644  	Scintilla::MultiAutoComplete AutoCGetMulti();
645  	void AutoCSetOrder(Scintilla::Ordering order);
646  	Scintilla::Ordering AutoCGetOrder();
647  	void Allocate(Position bytes);
648  	Position TargetAsUTF8(char *s);
649  	std::string TargetAsUTF8();
650  	void SetLengthForEncode(Position bytes);
651  	Position EncodedFromUTF8(const char *utf8, char *encoded);
652  	std::string EncodedFromUTF8(const char *utf8);
653  	Position FindColumn(Line line, Position column);
654  	Scintilla::CaretSticky CaretSticky();
655  	void SetCaretSticky(Scintilla::CaretSticky useCaretStickyBehaviour);
656  	void ToggleCaretSticky();
657  	void SetPasteConvertEndings(bool convert);
658  	bool PasteConvertEndings();
659  	void ReplaceRectangular(Position length, const char *text);
660  	void SelectionDuplicate();
661  	void SetCaretLineBackAlpha(Scintilla::Alpha alpha);
662  	Scintilla::Alpha CaretLineBackAlpha();
663  	void SetCaretStyle(Scintilla::CaretStyle caretStyle);
664  	Scintilla::CaretStyle CaretStyle();
665  	void SetIndicatorCurrent(int indicator);
666  	int IndicatorCurrent();
667  	void SetIndicatorValue(int value);
668  	int IndicatorValue();
669  	void IndicatorFillRange(Position start, Position lengthFill);
670  	void IndicatorClearRange(Position start, Position lengthClear);
671  	int IndicatorAllOnFor(Position pos);
672  	int IndicatorValueAt(int indicator, Position pos);
673  	Position IndicatorStart(int indicator, Position pos);
674  	Position IndicatorEnd(int indicator, Position pos);
675  	void SetPositionCache(int size);
676  	int PositionCache();
677  	void SetLayoutThreads(int threads);
678  	int LayoutThreads();
679  	void CopyAllowLine();
680  	void *CharacterPointer();
681  	void *RangePointer(Position start, Position lengthRange);
682  	Position GapPosition();
683  	void IndicSetAlpha(int indicator, Scintilla::Alpha alpha);
684  	Scintilla::Alpha IndicGetAlpha(int indicator);
685  	void IndicSetOutlineAlpha(int indicator, Scintilla::Alpha alpha);
686  	Scintilla::Alpha IndicGetOutlineAlpha(int indicator);
687  	void SetExtraAscent(int extraAscent);
688  	int ExtraAscent();
689  	void SetExtraDescent(int extraDescent);
690  	int ExtraDescent();
691  	int MarkerSymbolDefined(int markerNumber);
692  	void MarginSetText(Line line, const char *text);
693  	int MarginGetText(Line line, char *text);
694  	std::string MarginGetText(Line line);
695  	void MarginSetStyle(Line line, int style);
696  	int MarginGetStyle(Line line);
697  	void MarginSetStyles(Line line, const char *styles);
698  	int MarginGetStyles(Line line, char *styles);
699  	std::string MarginGetStyles(Line line);
700  	void MarginTextClearAll();
701  	void MarginSetStyleOffset(int style);
702  	int MarginGetStyleOffset();
703  	void SetMarginOptions(Scintilla::MarginOption marginOptions);
704  	Scintilla::MarginOption MarginOptions();
705  	void AnnotationSetText(Line line, const char *text);
706  	int AnnotationGetText(Line line, char *text);
707  	std::string AnnotationGetText(Line line);
708  	void AnnotationSetStyle(Line line, int style);
709  	int AnnotationGetStyle(Line line);
710  	void AnnotationSetStyles(Line line, const char *styles);
711  	int AnnotationGetStyles(Line line, char *styles);
712  	std::string AnnotationGetStyles(Line line);
713  	int AnnotationGetLines(Line line);
714  	void AnnotationClearAll();
715  	void AnnotationSetVisible(Scintilla::AnnotationVisible visible);
716  	Scintilla::AnnotationVisible AnnotationGetVisible();
717  	void AnnotationSetStyleOffset(int style);
718  	int AnnotationGetStyleOffset();
719  	void ReleaseAllExtendedStyles();
720  	int AllocateExtendedStyles(int numberStyles);
721  	void AddUndoAction(int token, Scintilla::UndoFlags flags);
722  	Position CharPositionFromPoint(int x, int y);
723  	Position CharPositionFromPointClose(int x, int y);
724  	void SetMouseSelectionRectangularSwitch(bool mouseSelectionRectangularSwitch);
725  	bool MouseSelectionRectangularSwitch();
726  	void SetMultipleSelection(bool multipleSelection);
727  	bool MultipleSelection();
728  	void SetAdditionalSelectionTyping(bool additionalSelectionTyping);
729  	bool AdditionalSelectionTyping();
730  	void SetAdditionalCaretsBlink(bool additionalCaretsBlink);
731  	bool AdditionalCaretsBlink();
732  	void SetAdditionalCaretsVisible(bool additionalCaretsVisible);
733  	bool AdditionalCaretsVisible();
734  	int Selections();
735  	bool SelectionEmpty();
736  	void ClearSelections();
737  	void SetSelection(Position caret, Position anchor);
738  	void AddSelection(Position caret, Position anchor);
739  	void DropSelectionN(int selection);
740  	void SetMainSelection(int selection);
741  	int MainSelection();
742  	void SetSelectionNCaret(int selection, Position caret);
743  	Position SelectionNCaret(int selection);
744  	void SetSelectionNAnchor(int selection, Position anchor);
745  	Position SelectionNAnchor(int selection);
746  	void SetSelectionNCaretVirtualSpace(int selection, Position space);
747  	Position SelectionNCaretVirtualSpace(int selection);
748  	void SetSelectionNAnchorVirtualSpace(int selection, Position space);
749  	Position SelectionNAnchorVirtualSpace(int selection);
750  	void SetSelectionNStart(int selection, Position anchor);
751  	Position SelectionNStart(int selection);
752  	Position SelectionNStartVirtualSpace(int selection);
753  	void SetSelectionNEnd(int selection, Position caret);
754  	Position SelectionNEndVirtualSpace(int selection);
755  	Position SelectionNEnd(int selection);
756  	void SetRectangularSelectionCaret(Position caret);
757  	Position RectangularSelectionCaret();
758  	void SetRectangularSelectionAnchor(Position anchor);
759  	Position RectangularSelectionAnchor();
760  	void SetRectangularSelectionCaretVirtualSpace(Position space);
761  	Position RectangularSelectionCaretVirtualSpace();
762  	void SetRectangularSelectionAnchorVirtualSpace(Position space);
763  	Position RectangularSelectionAnchorVirtualSpace();
764  	void SetVirtualSpaceOptions(Scintilla::VirtualSpace virtualSpaceOptions);
765  	Scintilla::VirtualSpace VirtualSpaceOptions();
766  	void SetRectangularSelectionModifier(int modifier);
767  	int RectangularSelectionModifier();
768  	void SetAdditionalSelFore(Colour fore);
769  	void SetAdditionalSelBack(Colour back);
770  	void SetAdditionalSelAlpha(Scintilla::Alpha alpha);
771  	Scintilla::Alpha AdditionalSelAlpha();
772  	void SetAdditionalCaretFore(Colour fore);
773  	Colour AdditionalCaretFore();
774  	void RotateSelection();
775  	void SwapMainAnchorCaret();
776  	void MultipleSelectAddNext();
777  	void MultipleSelectAddEach();
778  	int ChangeLexerState(Position start, Position end);
779  	Line ContractedFoldNext(Line lineStart);
780  	void VerticalCentreCaret();
781  	void MoveSelectedLinesUp();
782  	void MoveSelectedLinesDown();
783  	void SetIdentifier(int identifier);
784  	int Identifier();
785  	void RGBAImageSetWidth(int width);
786  	void RGBAImageSetHeight(int height);
787  	void RGBAImageSetScale(int scalePercent);
788  	void MarkerDefineRGBAImage(int markerNumber, const char *pixels);
789  	void RegisterRGBAImage(int type, const char *pixels);
790  	void ScrollToStart();
791  	void ScrollToEnd();
792  	void SetTechnology(Scintilla::Technology technology);
793  	Scintilla::Technology Technology();
794  	void *CreateLoader(Position bytes, Scintilla::DocumentOption documentOptions);
795  	void FindIndicatorShow(Position start, Position end);
796  	void FindIndicatorFlash(Position start, Position end);
797  	void FindIndicatorHide();
798  	void VCHomeDisplay();
799  	void VCHomeDisplayExtend();
800  	bool CaretLineVisibleAlways();
801  	void SetCaretLineVisibleAlways(bool alwaysVisible);
802  	void SetLineEndTypesAllowed(Scintilla::LineEndType lineEndBitSet);
803  	Scintilla::LineEndType LineEndTypesAllowed();
804  	Scintilla::LineEndType LineEndTypesActive();
805  	void SetRepresentation(const char *encodedCharacter, const char *representation);
806  	int Representation(const char *encodedCharacter, char *representation);
807  	std::string Representation(const char *encodedCharacter);
808  	void ClearRepresentation(const char *encodedCharacter);
809  	void ClearAllRepresentations();
810  	void SetRepresentationAppearance(const char *encodedCharacter, Scintilla::RepresentationAppearance appearance);
811  	Scintilla::RepresentationAppearance RepresentationAppearance(const char *encodedCharacter);
812  	void SetRepresentationColour(const char *encodedCharacter, ColourAlpha colour);
813  	ColourAlpha RepresentationColour(const char *encodedCharacter);
814  	void EOLAnnotationSetText(Line line, const char *text);
815  	int EOLAnnotationGetText(Line line, char *text);
816  	std::string EOLAnnotationGetText(Line line);
817  	void EOLAnnotationSetStyle(Line line, int style);
818  	int EOLAnnotationGetStyle(Line line);
819  	void EOLAnnotationClearAll();
820  	void EOLAnnotationSetVisible(Scintilla::EOLAnnotationVisible visible);
821  	Scintilla::EOLAnnotationVisible EOLAnnotationGetVisible();
822  	void EOLAnnotationSetStyleOffset(int style);
823  	int EOLAnnotationGetStyleOffset();
824  	bool SupportsFeature(Scintilla::Supports feature);
825  	Scintilla::LineCharacterIndexType LineCharacterIndex();
826  	void AllocateLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
827  	void ReleaseLineCharacterIndex(Scintilla::LineCharacterIndexType lineCharacterIndex);
828  	Line LineFromIndexPosition(Position pos, Scintilla::LineCharacterIndexType lineCharacterIndex);
829  	Position IndexPositionFromLine(Line line, Scintilla::LineCharacterIndexType lineCharacterIndex);
830  	void StartRecord();
831  	void StopRecord();
832  	int Lexer();
833  	void Colourise(Position start, Position end);
834  	void SetProperty(const char *key, const char *value);
835  	void SetKeyWords(int keyWordSet, const char *keyWords);
836  	int Property(const char *key, char *value);
837  	std::string Property(const char *key);
838  	int PropertyExpanded(const char *key, char *value);
839  	std::string PropertyExpanded(const char *key);
840  	int PropertyInt(const char *key, int defaultValue);
841  	int LexerLanguage(char *language);
842  	std::string LexerLanguage();
843  	void *PrivateLexerCall(int operation, void *pointer);
844  	int PropertyNames(char *names);
845  	std::string PropertyNames();
846  	Scintilla::TypeProperty PropertyType(const char *name);
847  	int DescribeProperty(const char *name, char *description);
848  	std::string DescribeProperty(const char *name);
849  	int DescribeKeyWordSets(char *descriptions);
850  	std::string DescribeKeyWordSets();
851  	Scintilla::LineEndType LineEndTypesSupported();
852  	int AllocateSubStyles(int styleBase, int numberStyles);
853  	int SubStylesStart(int styleBase);
854  	int SubStylesLength(int styleBase);
855  	int StyleFromSubStyle(int subStyle);
856  	int PrimaryStyleFromStyle(int style);
857  	void FreeSubStyles();
858  	void SetIdentifiers(int style, const char *identifiers);
859  	int DistanceToSecondaryStyles();
860  	int SubStyleBases(char *styles);
861  	std::string SubStyleBases();
862  	int NamedStyles();
863  	int NameOfStyle(int style, char *name);
864  	std::string NameOfStyle(int style);
865  	int TagsOfStyle(int style, char *tags);
866  	std::string TagsOfStyle(int style);
867  	int DescriptionOfStyle(int style, char *description);
868  	std::string DescriptionOfStyle(int style);
869  	void SetILexer(void *ilexer);
870  	Scintilla::Bidirectional Bidirectional();
871  	void SetBidirectional(Scintilla::Bidirectional bidirectional);
872  };
873  }
874  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditView.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaCall.h</div>
                </div>
                <div class="column column_space"><pre><code>303  	void addText(size_t length, const char *buf);
304  	void insertNewLineAboveCurrentLine();
305  	void insertNewLineBelowCurrentLine();
</pre></code></div>
                <div class="column column_space"><pre><code>247  	void AutoCShow(Position lengthEntered, const char *itemList);
248  	void AutoCCancel();
249  	bool AutoCActive();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    