
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 41, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Common.cpp</h3>
            <pre><code>1  #include &lt;algorithm&gt;
2  #include &lt;stdexcept&gt;
3  #include &lt;shlwapi.h&gt;
4  #include &lt;uxtheme.h&gt;
5  #include &lt;cassert&gt;
6  #include &lt;codecvt&gt;
7  #include &lt;locale&gt;
8  #include &quot;StaticDialog.h&quot;
9  #include &quot;CustomFileDialog.h&quot;
10  #include &quot;FileInterface.h&quot;
11  #include &quot;Common.h&quot;
12  #include &quot;Utf8.h&quot;
13  #include &lt;Parameters.h&gt;
14  #include &quot;Buffer.h&quot;
15  void printInt(int int2print)
16  {
17  	TCHAR str[32];
18  	wsprintf(str, TEXT(&quot;%d&quot;), int2print);
19  	::MessageBox(NULL, str, TEXT(&quot;&quot;), MB_OK);
20  }
21  void printStr(const TCHAR *str2print)
22  {
23  	::MessageBox(NULL, str2print, TEXT(&quot;&quot;), MB_OK);
24  }
25  generic_string commafyInt(size_t n)
26  {
27  	generic_stringstream ss;
28  	ss.imbue(std::locale(&quot;&quot;));
29  	ss &lt;&lt; n;
30  	return ss.str();
31  }
32  std::string getFileContent(const TCHAR *file2read)
33  {
34  	if (!::PathFileExists(file2read))
35  		return &quot;&quot;;
36  	const size_t blockSize = 1024;
37  	char data[blockSize];
38  	std::string wholeFileContent = &quot;&quot;;
39  	FILE *fp = _wfopen(file2read, TEXT(&quot;rb&quot;));
40  	size_t lenFile = 0;
41  	do
42  	{
43  		lenFile = fread(data, 1, blockSize, fp);
44  		if (lenFile &lt;= 0) break;
45  		wholeFileContent.append(data, lenFile);
46  	}
47  	while (lenFile &gt; 0);
48  	fclose(fp);
49  	return wholeFileContent;
50  }
51  char getDriveLetter()
52  {
53  	char drive = &#x27;\0&#x27;;
54  	TCHAR current[MAX_PATH];
55  	::GetCurrentDirectory(MAX_PATH, current);
56  	int driveNbr = ::PathGetDriveNumber(current);
57  	if (driveNbr != -1)
58  		drive = &#x27;A&#x27; + char(driveNbr);
59  	return drive;
60  }
61  generic_string relativeFilePathToFullFilePath(const TCHAR *relativeFilePath)
62  {
63  	generic_string fullFilePathName;
64  	TCHAR fullFileName[MAX_PATH];
65  	BOOL isRelative = ::PathIsRelative(relativeFilePath);
66  	if (isRelative)
67  	{
68  		::GetFullPathName(relativeFilePath, MAX_PATH, fullFileName, NULL);
69  		fullFilePathName += fullFileName;
70  	}
71  	else
72  	{
73  		if ((relativeFilePath[0] == &#x27;\\&#x27; &amp;&amp; relativeFilePath[1] != &#x27;\\&#x27;) || relativeFilePath[0] == &#x27;/&#x27;)
74  		{
75  			fullFilePathName += getDriveLetter();
76  			fullFilePathName += &#x27;:&#x27;;
77  		}
78  		fullFilePathName += relativeFilePath;
79  	}
80  	return fullFilePathName;
81  }
82  void writeFileContent(const TCHAR *file2write, const char *content2write)
83  {
84  	Win32_IO_File file(file2write);
85  	if (file.isOpened())
86  		file.writeStr(content2write);
87  }
88  void writeLog(const TCHAR *logFileName, const char *log2write)
89  {
90  	const DWORD accessParam{ GENERIC_READ | GENERIC_WRITE };
91  	const DWORD shareParam{ FILE_SHARE_READ | FILE_SHARE_WRITE };
92  	const DWORD dispParam{ OPEN_ALWAYS }; 
93  	const DWORD attribParam{ FILE_ATTRIBUTE_NORMAL };
94  	HANDLE hFile = ::CreateFileW(logFileName, accessParam, shareParam, NULL, dispParam, attribParam, NULL);
95  	if (hFile != INVALID_HANDLE_VALUE)
96  	{
97  		LARGE_INTEGER offset{};
98  		offset.QuadPart = 0;
99  		::SetFilePointerEx(hFile, offset, NULL, FILE_END);
100  		SYSTEMTIME currentTime = {};
101  		::GetLocalTime(&amp;currentTime);
102  		generic_string dateTimeStrW = getDateTimeStrFrom(TEXT(&quot;yyyy-MM-dd HH:mm:ss&quot;), currentTime);
103  		std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;&gt; converter;
104  		std::string log2writeStr = converter.to_bytes(dateTimeStrW);
105  		log2writeStr += &quot;  &quot;;
106  		log2writeStr += log2write;
107  		log2writeStr += &quot;\n&quot;;
108  		DWORD bytes_written = 0;
109  		::WriteFile(hFile, log2writeStr.c_str(), static_cast&lt;DWORD&gt;(log2writeStr.length()), &amp;bytes_written, NULL);
110  		::FlushFileBuffers(hFile);
111  		::CloseHandle(hFile);
112  	}
113  }
114  generic_string folderBrowser(HWND parent, const generic_string &amp; title, int outputCtrlID, const TCHAR *defaultStr)
115  {
116  	generic_string folderName;
117  	CustomFileDialog dlg(parent);
118  	dlg.setTitle(title.c_str());
119  	TCHAR directory[MAX_PATH] = {};
120  	if (outputCtrlID != 0)
121  		::GetDlgItemText(parent, outputCtrlID, directory, _countof(directory));
122  	directory[_countof(directory) - 1] = &#x27;\0&#x27;;
123  	if (!directory[0] &amp;&amp; defaultStr)
124  		dlg.setFolder(defaultStr);
125  	else if (directory[0])
126  		dlg.setFolder(directory);
127  	folderName = dlg.pickFolder();
128  	if (!folderName.empty())
129  	{
130  		if (outputCtrlID != 0)
131  			::SetDlgItemText(parent, outputCtrlID, folderName.c_str());
132  	}
133  	return folderName;
134  }
135  generic_string getFolderName(HWND parent, const TCHAR *defaultDir)
136  {
137  	return folderBrowser(parent, TEXT(&quot;Select a folder&quot;), 0, defaultDir);
138  }
139  void ClientRectToScreenRect(HWND hWnd, RECT* rect)
140  {
141  	POINT		pt{};
142  	pt.x		 = rect-&gt;left;
143  	pt.y		 = rect-&gt;top;
144  	::ClientToScreen( hWnd, &amp;pt );
145  	rect-&gt;left   = pt.x;
146  	rect-&gt;top    = pt.y;
147  	pt.x		 = rect-&gt;right;
148  	pt.y		 = rect-&gt;bottom;
149  	::ClientToScreen( hWnd, &amp;pt );
150  	rect-&gt;right  = pt.x;
151  	rect-&gt;bottom = pt.y;
152  }
153  std::vector&lt;generic_string&gt; tokenizeString(const generic_string &amp; tokenString, const char delim)
154  {
155  	std::vector&lt;generic_string&gt; tokens;
156  	generic_string::size_type lastPos = tokenString.find_first_not_of(delim, 0);
157      generic_string::size_type pos     = tokenString.find_first_of(delim, lastPos);
158      while (pos != std::string::npos || lastPos != std::string::npos)
159      {
160          tokens.push_back(tokenString.substr(lastPos, pos - lastPos));
161          lastPos = tokenString.find_first_not_of(delim, pos);
162          pos = tokenString.find_first_of(delim, lastPos);
163      }
164  	return tokens;
165  }
166  void ScreenRectToClientRect(HWND hWnd, RECT* rect)
167  {
168  	POINT		pt{};
169  	pt.x		 = rect-&gt;left;
170  	pt.y		 = rect-&gt;top;
171  	::ScreenToClient( hWnd, &amp;pt );
172  	rect-&gt;left   = pt.x;
173  	rect-&gt;top    = pt.y;
174  	pt.x		 = rect-&gt;right;
175  	pt.y		 = rect-&gt;bottom;
176  	::ScreenToClient( hWnd, &amp;pt );
177  	rect-&gt;right  = pt.x;
178  	rect-&gt;bottom = pt.y;
179  }
180  int filter(unsigned int code, struct _EXCEPTION_POINTERS *)
181  {
182      if (code == EXCEPTION_ACCESS_VIOLATION)
183          return EXCEPTION_EXECUTE_HANDLER;
184      return EXCEPTION_CONTINUE_SEARCH;
185  }
186  bool isInList(const TCHAR *token, const TCHAR *list)
187  {
188  	if ((!token) || (!list))
189  		return false;
190  	const size_t wordLen = 64;
191  	size_t listLen = lstrlen(list);
192  	TCHAR word[wordLen] = { &#x27;\0&#x27; };
193  	size_t i = 0;
194  	size_t j = 0;
195  	for (; i &lt;= listLen; ++i)
196  	{
197  		if ((list[i] == &#x27; &#x27;)||(list[i] == &#x27;\0&#x27;))
198  		{
199  			if (j != 0)
200  			{
<span onclick='openModal()' class='match'>201  				word[j] = &#x27;\0&#x27;;
202  				j = 0;
203  				if (!wcsicmp(token, word))
204  					return true;
205  			}
206  		}
207  		else
208  		{
209  			word[j] = list[i];
210  			++j;
211  			if (j &gt;= wordLen)
</span>212  				return false;
213  		}
214  	}
215  	return false;
216  }
217  generic_string purgeMenuItemString(const TCHAR * menuItemStr, bool keepAmpersand)
218  {
219  	const size_t cleanedNameLen = 64;
220  	TCHAR cleanedName[cleanedNameLen] = TEXT(&quot;&quot;);
221  	size_t j = 0;
222  	size_t menuNameLen = lstrlen(menuItemStr);
223  	if (menuNameLen &gt;= cleanedNameLen)
224  		menuNameLen = cleanedNameLen - 1;
225  	for (size_t k = 0 ; k &lt; menuNameLen ; ++k)
226  	{
227  		if (menuItemStr[k] == &#x27;\t&#x27;)
228  		{
229  			cleanedName[k] = 0;
230  			break;
231  		}
232  		else
233  		{
234  			if (menuItemStr[k] == &#x27;&amp;&#x27;)
235  			{
236  				if (keepAmpersand)
237  					cleanedName[j++] = menuItemStr[k];
238  			}
239  			else
240  				cleanedName[j++] = menuItemStr[k];
241  		}
242  	}
243  	cleanedName[j] = 0;
244  	return cleanedName;
245  }
246  const wchar_t * WcharMbcsConvertor::char2wchar(const char * mbcs2Convert, size_t codepage, int lenMbcs, int* pLenWc, int* pBytesNotProcessed)
247  {
248  	if (!mbcs2Convert)
249  		return nullptr;
250  	if (lenMbcs == 0 || (lenMbcs == -1 &amp;&amp; mbcs2Convert[0] == 0))
251  	{
252  		_wideCharStr.empty();
253  		return _wideCharStr;
254  	}
255  	UINT cp = static_cast&lt;UINT&gt;(codepage);
256  	int bytesNotProcessed = 0;
257  	int lenWc = 0;
258  	if (lenMbcs == -1)
259  	{
260  		lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs, NULL, 0);
261  	}
262  	else if (lenMbcs != -1 &amp;&amp; cp == CP_UTF8) 
263  	{
264  		int indexOfLastChar = Utf8::characterStart(mbcs2Convert, lenMbcs-1); 
265  		if (indexOfLastChar != 0 &amp;&amp; !Utf8::isValid(mbcs2Convert+indexOfLastChar, lenMbcs-indexOfLastChar)) 
266  		{
267  			bytesNotProcessed = lenMbcs-indexOfLastChar;
268  		}
269  		lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs-bytesNotProcessed, NULL, 0);
270  	}
271  	else 
272  	{
273  		lenWc = MultiByteToWideChar(cp, (lenMbcs == -1) ? 0 : MB_ERR_INVALID_CHARS, mbcs2Convert, lenMbcs, NULL, 0);
274  		if (lenWc == 0 &amp;&amp; GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
275  		{
276  			if (lenMbcs &gt; 1) lenWc = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, mbcs2Convert, lenMbcs-1, NULL, 0);
277  			if (lenWc == 0) 
278  			{
279  				lenWc = MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs, NULL, 0);
280  			}
281  			else
282  			{
283  				bytesNotProcessed = 1;
284  			}
285  		}
286  	}
287  	if (lenWc &gt; 0)
288  	{
289  		_wideCharStr.sizeTo(lenWc);
290  		MultiByteToWideChar(cp, 0, mbcs2Convert, lenMbcs-bytesNotProcessed, _wideCharStr, lenWc);
291  	}
292  	else
293  		_wideCharStr.empty();
294  	if (pLenWc)
295  		*pLenWc = lenWc;
296  	if (pBytesNotProcessed)
297  		*pBytesNotProcessed = bytesNotProcessed;
298  	return _wideCharStr;
299  }
300  const wchar_t * WcharMbcsConvertor::char2wchar(const char * mbcs2Convert, size_t codepage, intptr_t* mstart, intptr_t* mend)
301  {
302  	if (!mbcs2Convert) return NULL;
303  	UINT cp = static_cast&lt;UINT&gt;(codepage);
304  	int len = MultiByteToWideChar(cp, 0, mbcs2Convert, -1, NULL, 0);
305  	if (len &gt; 0)
306  	{
307  		_wideCharStr.sizeTo(len);
308  		len = MultiByteToWideChar(cp, 0, mbcs2Convert, -1, _wideCharStr, len);
309  		if ((size_t)*mstart &lt; strlen(mbcs2Convert) &amp;&amp; (size_t)*mend &lt;= strlen(mbcs2Convert))
310  		{
311  			*mstart = MultiByteToWideChar(cp, 0, mbcs2Convert, static_cast&lt;int&gt;(*mstart), _wideCharStr, 0);
312  			*mend   = MultiByteToWideChar(cp, 0, mbcs2Convert, static_cast&lt;int&gt;(*mend), _wideCharStr, 0);
313  			if (*mstart &gt;= len || *mend &gt;= len)
314  			{
315  				*mstart = 0;
316  				*mend = 0;
317  			}
318  		}
319  	}
320  	else
321  	{
322  		_wideCharStr.empty();
323  		*mstart = 0;
324  		*mend = 0;
325  	}
326  	return _wideCharStr;
327  }
328  const char* WcharMbcsConvertor::wchar2char(const wchar_t * wcharStr2Convert, size_t codepage, int lenWc, int* pLenMbcs)
329  {
330  	if (!wcharStr2Convert)
331  		return nullptr;
332  	UINT cp = static_cast&lt;UINT&gt;(codepage);
333  	int lenMbcs = WideCharToMultiByte(cp, 0, wcharStr2Convert, lenWc, NULL, 0, NULL, NULL);
334  	if (lenMbcs &gt; 0)
335  	{
336  		_multiByteStr.sizeTo(lenMbcs);
337  		WideCharToMultiByte(cp, 0, wcharStr2Convert, lenWc, _multiByteStr, lenMbcs, NULL, NULL);
338  	}
339  	else
340  		_multiByteStr.empty();
341  	if (pLenMbcs)
342  		*pLenMbcs = lenMbcs;
343  	return _multiByteStr;
344  }
345  const char * WcharMbcsConvertor::wchar2char(const wchar_t * wcharStr2Convert, size_t codepage, intptr_t* mstart, intptr_t* mend)
346  {
347  	if (!wcharStr2Convert)
348  		return nullptr;
349  	UINT cp = static_cast&lt;UINT&gt;(codepage);
350  	int len = WideCharToMultiByte(cp, 0, wcharStr2Convert, -1, NULL, 0, NULL, NULL);
351  	if (len &gt; 0)
352  	{
353  		_multiByteStr.sizeTo(len);
354  		len = WideCharToMultiByte(cp, 0, wcharStr2Convert, -1, _multiByteStr, len, NULL, NULL); 
355          if (*mstart &lt; lstrlenW(wcharStr2Convert) &amp;&amp; *mend &lt; lstrlenW(wcharStr2Convert))
356          {
357  			*mstart = WideCharToMultiByte(cp, 0, wcharStr2Convert, (int)*mstart, NULL, 0, NULL, NULL);
358  			*mend = WideCharToMultiByte(cp, 0, wcharStr2Convert, (int)*mend, NULL, 0, NULL, NULL);
359  			if (*mstart &gt;= len || *mend &gt;= len)
360  			{
361  				*mstart = 0;
362  				*mend = 0;
363  			}
364  		}
365  	}
366  	else
367  		_multiByteStr.empty();
368  	return _multiByteStr;
369  }
370  std::wstring string2wstring(const std::string &amp; rString, UINT codepage)
371  {
372  	int len = MultiByteToWideChar(codepage, 0, rString.c_str(), -1, NULL, 0);
373  	if (len &gt; 0)
374  	{
375  		std::vector&lt;wchar_t&gt; vw(len);
376  		MultiByteToWideChar(codepage, 0, rString.c_str(), -1, &amp;vw[0], len);
377  		return &amp;vw[0];
378  	}
379  	return std::wstring();
380  }
381  std::string wstring2string(const std::wstring &amp; rwString, UINT codepage)
382  {
383  	int len = WideCharToMultiByte(codepage, 0, rwString.c_str(), -1, NULL, 0, NULL, NULL);
384  	if (len &gt; 0)
385  	{
386  		std::vector&lt;char&gt; vw(len);
387  		WideCharToMultiByte(codepage, 0, rwString.c_str(), -1, &amp;vw[0], len, NULL, NULL);
388  		return &amp;vw[0];
389  	}
390  	return std::string();
391  }
392  template &lt;typename T&gt;
393  generic_string convertFileName(T beg, T end)
394  {
395  	generic_string strTmp;
396  	for (T it = beg; it != end; ++it)
397  	{
398  		if (*it == &#x27;&amp;&#x27;) strTmp.push_back(&#x27;&amp;&#x27;);
399  		strTmp.push_back(*it);
400  	}
401  	return strTmp;
402  }
403  generic_string intToString(int val)
404  {
405  	std::vector&lt;TCHAR&gt; vt;
406  	bool isNegative = val &lt; 0;
407  	vt.push_back(&#x27;0&#x27; + static_cast&lt;TCHAR&gt;(std::abs(val % 10)));
408  	val /= 10;
409  	while (val != 0)
410  	{
411  		vt.push_back(&#x27;0&#x27; + static_cast&lt;TCHAR&gt;(std::abs(val % 10)));
412  		val /= 10;
413  	}
414  	if (isNegative)
415  		vt.push_back(&#x27;-&#x27;);
416  	return generic_string(vt.rbegin(), vt.rend());
417  }
418  generic_string uintToString(unsigned int val)
419  {
420  	std::vector&lt;TCHAR&gt; vt;
421  	vt.push_back(&#x27;0&#x27; + static_cast&lt;TCHAR&gt;(val % 10));
422  	val /= 10;
423  	while (val != 0)
424  	{
425  		vt.push_back(&#x27;0&#x27; + static_cast&lt;TCHAR&gt;(val % 10));
426  		val /= 10;
427  	}
428  	return generic_string(vt.rbegin(), vt.rend());
429  }
430  generic_string BuildMenuFileName(int filenameLen, unsigned int pos, const generic_string &amp;filename, bool ordinalNumber)
431  {
432  	generic_string strTemp;
433  	if (ordinalNumber)
434  	{
435  		if (pos &lt; 9)
436  		{
437  			strTemp.push_back(&#x27;&amp;&#x27;);
438  			strTemp.push_back(&#x27;1&#x27; + static_cast&lt;TCHAR&gt;(pos));
439  		}
440  		else if (pos == 9)
441  		{
442  			strTemp.append(TEXT(&quot;1&amp;0&quot;));
443  		}
444  		else
445  		{
446  			div_t splitDigits = div(pos + 1, 10);
447  			strTemp.append(uintToString(splitDigits.quot));
448  			strTemp.push_back(&#x27;&amp;&#x27;);
449  			strTemp.append(uintToString(splitDigits.rem));
450  		}
451  		strTemp.append(TEXT(&quot;: &quot;));
452  	}
453  	else
454  	{
455  		strTemp.push_back(&#x27;&amp;&#x27;);
456  	}
457  	if (filenameLen &gt; 0)
458  	{
459  		std::vector&lt;TCHAR&gt; vt(filenameLen + 1);
460  		PathCompactPathEx(&amp;vt[0], filename.c_str(), filenameLen + 1, 0);
461  		strTemp.append(convertFileName(vt.begin(), vt.begin() + lstrlen(&amp;vt[0])));
462  	}
463  	else
464  	{
465  		generic_string::const_iterator it = filename.begin();
466  		if (filenameLen == 0)
467  			it += PathFindFileName(filename.c_str()) - filename.c_str();
468  		if (filename.end() - it &lt; MAX_PATH)
469  		{
470  			strTemp.append(convertFileName(it, filename.end()));
471  		}
472  		else
473  		{
474  			strTemp.append(convertFileName(it, it + MAX_PATH / 2 - 3));
475  			strTemp.append(TEXT(&quot;...&quot;));
476  			strTemp.append(convertFileName(filename.end() - MAX_PATH / 2, filename.end()));
477  		}
478  	}
479  	return strTemp;
480  }
481  generic_string PathRemoveFileSpec(generic_string&amp; path)
482  {
483      generic_string::size_type lastBackslash = path.find_last_of(TEXT(&#x27;\\&#x27;));
484      if (lastBackslash == generic_string::npos)
485      {
486          if (path.size() &gt;= 2 &amp;&amp; path[1] == TEXT(&#x27;:&#x27;))  
487              path.erase(2);
488          else
489              path.erase();
490      }
491      else
492      {
493          if (lastBackslash == 2 &amp;&amp; path[1] == TEXT(&#x27;:&#x27;) &amp;&amp; path.size() &gt;= 3)  
494              path.erase(3);
495          else if (lastBackslash == 0 &amp;&amp; path.size() &gt; 1) 
496              path.erase(1);
497          else
498              path.erase(lastBackslash);
499      }
500  	return path;
501  }
502  generic_string pathAppend(generic_string&amp; strDest, const generic_string&amp; str2append)
503  {
504  	if (strDest.empty() &amp;&amp; str2append.empty()) 
505  	{
506  		strDest = TEXT(&quot;\\&quot;);
507  		return strDest;
508  	}
509  	if (strDest.empty() &amp;&amp; !str2append.empty()) 
510  	{
511  		strDest = str2append;
512  		return strDest;
513  	}
514  	if (strDest[strDest.length() - 1] == &#x27;\\&#x27; &amp;&amp; (!str2append.empty() &amp;&amp; str2append[0] == &#x27;\\&#x27;)) 
515  	{
516  		strDest.erase(strDest.length() - 1, 1);
517  		strDest += str2append;
518  		return strDest;
519  	}
520  	if ((strDest[strDest.length() - 1] == &#x27;\\&#x27; &amp;&amp; (!str2append.empty() &amp;&amp; str2append[0] != &#x27;\\&#x27;)) 
521  		|| (strDest[strDest.length() - 1] != &#x27;\\&#x27; &amp;&amp; (!str2append.empty() &amp;&amp; str2append[0] == &#x27;\\&#x27;))) 
522  	{
523  		strDest += str2append;
524  		return strDest;
525  	}
526  	strDest += TEXT(&quot;\\&quot;);
527  	strDest += str2append;
528  	return strDest;
529  }
530  COLORREF getCtrlBgColor(HWND hWnd)
531  {
532  	COLORREF crRet = CLR_INVALID;
533  	if (hWnd &amp;&amp; IsWindow(hWnd))
534  	{
535  		RECT rc;
536  		if (GetClientRect(hWnd, &amp;rc))
537  		{
538  			HDC hDC = GetDC(hWnd);
539  			if (hDC)
540  			{
541  				HDC hdcMem = CreateCompatibleDC(hDC);
542  				if (hdcMem)
543  				{
544  					HBITMAP hBmp = CreateCompatibleBitmap(hDC,
545  					rc.right, rc.bottom);
546  					if (hBmp)
547  					{
548  						HGDIOBJ hOld = SelectObject(hdcMem, hBmp);
549  						if (hOld)
550  						{
551  							if (SendMessage(hWnd, WM_ERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(hdcMem), 0))
552  							{
553  								crRet = GetPixel(hdcMem, 2, 2); 
554  							}
555  							SelectObject(hdcMem, hOld);
556  						}
557  						DeleteObject(hBmp);
558  					}
559  					DeleteDC(hdcMem);
560  				}
561  				ReleaseDC(hWnd, hDC);
562  			}
563  		}
564  	}
565  	return crRet;
566  }
567  generic_string stringToUpper(generic_string strToConvert)
568  {
569      std::transform(strToConvert.begin(), strToConvert.end(), strToConvert.begin(), 
570          [](wchar_t ch){ return static_cast&lt;wchar_t&gt;(towupper(ch)); }
571      );
572      return strToConvert;
573  }
574  generic_string stringToLower(generic_string strToConvert)
575  {
576      std::transform(strToConvert.begin(), strToConvert.end(), strToConvert.begin(), ::towlower);
577      return strToConvert;
578  }
579  generic_string stringReplace(generic_string subject, const generic_string&amp; search, const generic_string&amp; replace)
580  {
581  	size_t pos = 0;
582  	while ((pos = subject.find(search, pos)) != std::string::npos)
583  	{
584  		subject.replace(pos, search.length(), replace);
585  		pos += replace.length();
586  	}
587  	return subject;
588  }
589  std::vector&lt;generic_string&gt; stringSplit(const generic_string&amp; input, const generic_string&amp; delimiter)
590  {
591  	size_t start = 0U;
592  	size_t end = input.find(delimiter);
593  	std::vector&lt;generic_string&gt; output;
594  	const size_t delimiterLength = delimiter.length();
595  	while (end != std::string::npos)
596  	{
597  		output.push_back(input.substr(start, end - start));
598  		start = end + delimiterLength;
599  		end = input.find(delimiter, start);
600  	}
601  	output.push_back(input.substr(start, end));
602  	return output;
603  }
604  bool str2numberVector(generic_string str2convert, std::vector&lt;size_t&gt;&amp; numVect)
605  {
606  	numVect.clear();
607  	for (auto i : str2convert)
608  	{
609  		switch (i)
610  		{
611  		case &#x27; &#x27;:
612  		case &#x27;0&#x27;: case &#x27;1&#x27;:	case &#x27;2&#x27;: case &#x27;3&#x27;:	case &#x27;4&#x27;:
613  		case &#x27;5&#x27;: case &#x27;6&#x27;:	case &#x27;7&#x27;: case &#x27;8&#x27;:	case &#x27;9&#x27;:
614  		{
615  		}
616  		break;
617  		default:
618  			return false;
619  		}
620  	}
621  	std::vector&lt;generic_string&gt; v = stringSplit(str2convert, TEXT(&quot; &quot;));
622  	for (const auto&amp; i : v)
623  	{
624  		if (!i.empty() &amp;&amp; i.length() &lt; 5)
625  		{
626  			numVect.push_back(std::stoi(i));
627  		}
628  	}
629  	return true;
630  }
631  generic_string stringJoin(const std::vector&lt;generic_string&gt;&amp; strings, const generic_string&amp; separator)
632  {
633  	generic_string joined;
634  	size_t length = strings.size();
635  	for (size_t i = 0; i &lt; length; ++i)
636  	{
637  		joined += strings.at(i);
638  		if (i != length - 1)
639  		{
640  			joined += separator;
641  		}
642  	}
643  	return joined;
644  }
645  generic_string stringTakeWhileAdmissable(const generic_string&amp; input, const generic_string&amp; admissable)
646  {
647  	size_t idx = input.find_first_not_of(admissable);
648  	if (idx == std::string::npos)
649  	{
650  		return input;
651  	}
652  	else
653  	{
654  		return input.substr(0, idx);
655  	}
656  }
657  double stodLocale(const generic_string&amp; str, [[maybe_unused]] _locale_t loc, size_t* idx)
658  {
659  	const wchar_t* ptr = str.c_str();
660  	errno = 0;
661  	wchar_t* eptr;
662  #ifdef __MINGW32__
663  	double ans = ::wcstod(ptr, &amp;eptr);
664  #else
665  	double ans = ::_wcstod_l(ptr, &amp;eptr, loc);
666  #endif
667  	if (ptr == eptr)
668  		throw std::invalid_argument(&quot;invalid stod argument&quot;);
669  	if (errno == ERANGE)
670  		throw std::out_of_range(&quot;stod argument out of range&quot;);
671  	if (idx != NULL)
672  		*idx = (size_t)(eptr - ptr);
673  	return ans;
674  }
675  static TCHAR ToUpperInvariant(TCHAR input)
676  {
677  	TCHAR result;
678  	LONG lres = LCMapString(LOCALE_INVARIANT, LCMAP_UPPERCASE, &amp;input, 1, &amp;result, 1);
679  	if (lres == 0)
680  	{
681  		assert(false and &quot;LCMapString failed to convert a character to upper case&quot;);
682  		result = input;
683  	}
684  	return result;
685  }
686  int OrdinalIgnoreCaseCompareStrings(LPCTSTR sz1, LPCTSTR sz2)
687  {
688  	if (sz1 == sz2)
689  	{
690  		return 0;
691  	}
692  	if (sz1 == nullptr) sz1 = _T(&quot;&quot;);
693  	if (sz2 == nullptr) sz2 = _T(&quot;&quot;);
694  	for (;; sz1++, sz2++)
695  	{
696  		const TCHAR c1 = *sz1;
697  		const TCHAR c2 = *sz2;
698  		if (c1 == c2)
699  		{
700  			if (c1 == 0)
701  			{
702  				return 0; 
703  			}
704  		}
705  		else
706  		{
707  			if (c1 == 0 || c2 == 0)
708  			{
709  				return (c1-c2); 
710  			}
711  			const TCHAR u1 = ToUpperInvariant(c1);
712  			const TCHAR u2 = ToUpperInvariant(c2);
713  			if (u1 != u2)
714  			{
715  				return (u1-u2); 
716  			}
717  		}
718  	}
719  }
720  bool str2Clipboard(const generic_string &amp;str2cpy, HWND hwnd)
721  {
722  	size_t len2Allocate = (str2cpy.size() + 1) * sizeof(TCHAR);
723  	HGLOBAL hglbCopy = ::GlobalAlloc(GMEM_MOVEABLE, len2Allocate);
724  	if (hglbCopy == NULL)
725  	{
726  		return false;
727  	}
728  	if (!::OpenClipboard(hwnd))
729  	{
730  		::GlobalFree(hglbCopy);
731  		::CloseClipboard();
732  		return false;
733  	}
734  	if (!::EmptyClipboard())
735  	{
736  		::GlobalFree(hglbCopy);
737  		::CloseClipboard();
738  		return false;
739  	}
740  	TCHAR *pStr = (TCHAR *)::GlobalLock(hglbCopy);
741  	if (pStr == NULL)
742  	{
743  		::GlobalUnlock(hglbCopy);
744  		::GlobalFree(hglbCopy);
745  		::CloseClipboard();
746  		return false;
747  	}
748  	wcscpy_s(pStr, len2Allocate / sizeof(TCHAR), str2cpy.c_str());
749  	::GlobalUnlock(hglbCopy);
750  	unsigned int clipBoardFormat = CF_UNICODETEXT;
751  	if (::SetClipboardData(clipBoardFormat, hglbCopy) == NULL)
752  	{
753  		::GlobalFree(hglbCopy);
754  		::CloseClipboard();
755  		return false;
756  	}
757  	if (!::CloseClipboard())
758  	{
759  		return false;
760  	}
761  	return true;
762  }
763  bool buf2Clipborad(const std::vector&lt;Buffer*&gt;&amp; buffers, bool isFullPath, HWND hwnd)
764  {
765  	const generic_string crlf = _T(&quot;\r\n&quot;);
766  	generic_string selection;
767  	for (auto&amp;&amp; buf : buffers)
768  	{
769  		if (buf)
770  		{
771  			const TCHAR* fileName = isFullPath ? buf-&gt;getFullPathName() : buf-&gt;getFileName();
772  			if (fileName)
773  				selection += fileName;
774  		}
775  		if (!selection.empty() &amp;&amp; !selection.ends_with(crlf))
776  			selection += crlf;
777  	}
778  	if (!selection.empty())
779  		return str2Clipboard(selection, hwnd);
780  	return false;
781  }
782  bool matchInList(const TCHAR *fileName, const std::vector&lt;generic_string&gt; &amp; patterns)
783  {
784  	bool is_matched = false;
785  	for (size_t i = 0, len = patterns.size(); i &lt; len; ++i)
786  	{
787  		if (patterns[i].length() &gt; 1 &amp;&amp; patterns[i][0] == &#x27;!&#x27;)
788  		{
789  			if (PathMatchSpec(fileName, patterns[i].c_str() + 1))
790  				return false;
791  			continue;
792  		} 
793  		if (PathMatchSpec(fileName, patterns[i].c_str()))
794  			is_matched = true;
795  	}
796  	return is_matched;
797  }
798  bool matchInExcludeDirList(const TCHAR* dirName, const std::vector&lt;generic_string&gt;&amp; patterns, size_t level)
799  {
800  	for (size_t i = 0, len = patterns.size(); i &lt; len; ++i)
801  	{
802  		size_t patterLen = patterns[i].length();
803  		if (patterLen &gt; 3 &amp;&amp; patterns[i][0] == &#x27;!&#x27; &amp;&amp; patterns[i][1] == &#x27;+&#x27; &amp;&amp; patterns[i][2] == &#x27;\\&#x27;) 
804  		{
805  			if (PathMatchSpec(dirName, patterns[i].c_str() + 3))
806  				return true;
807  		}
808  		else if (patterLen &gt; 2 &amp;&amp; patterns[i][0] == &#x27;!&#x27; &amp;&amp; patterns[i][1] == &#x27;\\&#x27;) 
809  		{
810  			if (level == 1)
811  				if (PathMatchSpec(dirName, patterns[i].c_str() + 2))
812  					return true;
813  		}
814  	}
815  	return false;
816  }
817  bool allPatternsAreExclusion(const std::vector&lt;generic_string&gt; patterns)
818  {
819  	bool oneInclusionPatternFound = false;
820  	for (size_t i = 0, len = patterns.size(); i &lt; len; ++i)
821  	{
822  		if (patterns[i][0] != &#x27;!&#x27;)
823  		{
824  			oneInclusionPatternFound = true;
825  			break;
826  		}
827  	}
828  	return !oneInclusionPatternFound;
829  }
830  generic_string GetLastErrorAsString(DWORD errorCode)
831  {
832  	generic_string errorMsg(_T(&quot;&quot;));
833  	if (errorCode == 0)
834  		errorCode = GetLastError();
835  	if (errorCode == 0)
836  		return errorMsg; 
837  	LPWSTR messageBuffer = nullptr;
838  	FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
839  		nullptr, errorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&amp;messageBuffer, 0, nullptr);
840  	errorMsg += messageBuffer;
841  	LocalFree(messageBuffer);
842  	return errorMsg;
843  }
844  HWND CreateToolTip(int toolID, HWND hDlg, HINSTANCE hInst, const PTSTR pszText, bool isRTL)
845  {
846  	if (!toolID || !hDlg || !pszText)
847  	{
848  		return NULL;
849  	}
850  	HWND hwndTool = GetDlgItem(hDlg, toolID);
851  	if (!hwndTool)
852  	{
853  		return NULL;
854  	}
855  	HWND hwndTip = CreateWindowEx(isRTL ? WS_EX_LAYOUTRTL : 0, TOOLTIPS_CLASS, NULL,
856  		WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON,
857  		CW_USEDEFAULT, CW_USEDEFAULT,
858  		CW_USEDEFAULT, CW_USEDEFAULT,
859  		hDlg, NULL,
860  		hInst, NULL);
861  	if (!hwndTip)
862  	{
863  		return NULL;
864  	}
865  	NppDarkMode::setDarkTooltips(hwndTip, NppDarkMode::ToolTipsType::tooltip);
866  	TOOLINFO toolInfo = {};
867  	toolInfo.cbSize = sizeof(toolInfo);
868  	toolInfo.hwnd = hDlg;
869  	toolInfo.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
870  	toolInfo.uId = (UINT_PTR)hwndTool;
871  	toolInfo.lpszText = pszText;
872  	if (!SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&amp;toolInfo))
873  	{
874  		DestroyWindow(hwndTip);
875  		return NULL;
876  	}
877  	SendMessage(hwndTip, TTM_ACTIVATE, TRUE, 0);
878  	SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, 200);
879  	SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((15000), (0)));
880  	return hwndTip;
881  }
882  HWND CreateToolTipRect(int toolID, HWND hWnd, HINSTANCE hInst, const PTSTR pszText, const RECT rc)
883  {
884  	if (!toolID || !hWnd || !pszText)
885  	{
886  		return NULL;
887  	}
888  	HWND hwndTip = CreateWindowEx(0, TOOLTIPS_CLASS, NULL,
889  		WS_POPUP | TTS_ALWAYSTIP | TTS_BALLOON,
890  		CW_USEDEFAULT, CW_USEDEFAULT,
891  		CW_USEDEFAULT, CW_USEDEFAULT,
892  		hWnd, NULL,
893  		hInst, NULL);
894  	if (!hwndTip)
895  	{
896  		return NULL;
897  	}
898  	TOOLINFO toolInfo = {};
899  	toolInfo.cbSize = sizeof(toolInfo);
900  	toolInfo.hwnd = hWnd;
901  	toolInfo.uFlags = TTF_SUBCLASS;
902  	toolInfo.uId = toolID;
903  	toolInfo.lpszText = pszText;
904  	toolInfo.rect = rc;
905  	if (!SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&amp;toolInfo))
906  	{
907  		DestroyWindow(hwndTip);
908  		return NULL;
909  	}
910  	SendMessage(hwndTip, TTM_ACTIVATE, TRUE, 0);
911  	SendMessage(hwndTip, TTM_SETMAXTIPWIDTH, 0, 200);
912  	SendMessage(hwndTip, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELPARAM((15000), (0)));
913  	return hwndTip;
914  }
915  bool isCertificateValidated(const generic_string &amp; fullFilePath, const generic_string &amp; subjectName2check)
916  {
917  	bool isOK = false;
918  	HCERTSTORE hStore = NULL;
919  	HCRYPTMSG hMsg = NULL;
920  	PCCERT_CONTEXT pCertContext = NULL;
921  	BOOL result = FALSE;
922  	DWORD dwEncoding = 0;
923  	DWORD dwContentType = 0;
924  	DWORD dwFormatType = 0;
925  	PCMSG_SIGNER_INFO pSignerInfo = NULL;
926  	DWORD dwSignerInfo = 0;
927  	CERT_INFO CertInfo{};
928  	LPTSTR szName = NULL;
929  	generic_string subjectName;
930  	try {
931  		result = CryptQueryObject(CERT_QUERY_OBJECT_FILE,
932  			fullFilePath.c_str(),
933  			CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
934  			CERT_QUERY_FORMAT_FLAG_BINARY,
935  			0,
936  			&amp;dwEncoding,
937  			&amp;dwContentType,
938  			&amp;dwFormatType,
939  			&amp;hStore,
940  			&amp;hMsg,
941  			NULL);
942  		if (!result)
943  		{
944  			generic_string errorMessage = TEXT(&quot;Check certificate of &quot;) + fullFilePath + TEXT(&quot; : &quot;);
945  			errorMessage += GetLastErrorAsString(GetLastError());
946  			throw errorMessage;
947  		}
948  		result = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &amp;dwSignerInfo);
949  		if (!result)
950  		{
951  			generic_string errorMessage = TEXT(&quot;CryptMsgGetParam first call: &quot;);
952  			errorMessage += GetLastErrorAsString(GetLastError());
953  			throw errorMessage;
954  		}
955  		pSignerInfo = (PCMSG_SIGNER_INFO)LocalAlloc(LPTR, dwSignerInfo);
956  		if (!pSignerInfo)
957  		{
958  			generic_string errorMessage = TEXT(&quot;CryptMsgGetParam memory allocation problem: &quot;);
959  			errorMessage += GetLastErrorAsString(GetLastError());
960  			throw errorMessage;
961  		}
962  		result = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, &amp;dwSignerInfo);
963  		if (!result)
964  		{
965  			generic_string errorMessage = TEXT(&quot;CryptMsgGetParam: &quot;);
966  			errorMessage += GetLastErrorAsString(GetLastError());
967  			throw errorMessage;
968  		}
969  		CertInfo.Issuer = pSignerInfo-&gt;Issuer;
970  		CertInfo.SerialNumber = pSignerInfo-&gt;SerialNumber;
971  		pCertContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, (PVOID)&amp;CertInfo, NULL);
972  		if (!pCertContext)
973  		{
974  			generic_string errorMessage = TEXT(&quot;Certificate context: &quot;);
975  			errorMessage += GetLastErrorAsString(GetLastError());
976  			throw errorMessage;
977  		}
978  		DWORD dwData;
979  		dwData = CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);
980  		if (dwData &lt;= 1)
981  		{
982  			throw generic_string(TEXT(&quot;Certificate checking error: getting data size problem.&quot;));
983  		}
984  		szName = (LPTSTR)LocalAlloc(LPTR, dwData * sizeof(TCHAR));
985  		if (!szName)
986  		{
987  			throw generic_string(TEXT(&quot;Certificate checking error: memory allocation problem.&quot;));
988  		}
989  		if (CertGetNameString(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, szName, dwData) &lt;= 1)
990  		{
991  			throw generic_string(TEXT(&quot;Cannot get certificate info.&quot;));
992  		}
993  		subjectName = szName;
994  		if (subjectName != subjectName2check)
995  		{
996  			throw generic_string(TEXT(&quot;Certificate checking error: the certificate is not matched.&quot;));
997  		}
998  		isOK = true;
999  	}
1000  	catch (const generic_string&amp; s)
1001  	{
1002  		MessageBox(NULL, s.c_str(), TEXT(&quot;Certificate checking&quot;), MB_OK);
1003  	}
1004  	catch (...)
1005  	{
1006  		generic_string errorMessage = TEXT(&quot;Unknown exception occured. &quot;);
1007  		errorMessage += GetLastErrorAsString(GetLastError());
1008  		MessageBox(NULL, errorMessage.c_str(), TEXT(&quot;Certificate checking&quot;), MB_OK);
1009  	}
1010  	if (pSignerInfo != NULL) LocalFree(pSignerInfo);
1011  	if (pCertContext != NULL) CertFreeCertificateContext(pCertContext);
1012  	if (hStore != NULL) CertCloseStore(hStore, 0);
1013  	if (hMsg != NULL) CryptMsgClose(hMsg);
1014  	if (szName != NULL) LocalFree(szName);
1015  	return isOK;
1016  }
1017  bool isAssoCommandExisting(LPCTSTR FullPathName)
1018  {
1019  	bool isAssoCommandExisting = false;
1020  	bool isFileExisting = PathFileExists(FullPathName) != FALSE;
1021  	if (isFileExisting)
1022  	{
1023  		PTSTR ext = PathFindExtension(FullPathName);
1024  		HRESULT hres;
1025  		wchar_t buffer[MAX_PATH] = TEXT(&quot;&quot;);
1026  		DWORD bufferLen = MAX_PATH;
1027  		hres = AssocQueryString(ASSOCF_VERIFY|ASSOCF_INIT_IGNOREUNKNOWN, ASSOCSTR_COMMAND, ext, NULL, buffer, &amp;bufferLen);
1028          isAssoCommandExisting = (hres == S_OK)                  
1029  			&amp;&amp; (wcsstr(buffer, TEXT(&quot;notepad++.exe&quot;)) == NULL); 
1030  	}
1031  	return isAssoCommandExisting;
1032  }
1033  std::wstring s2ws(const std::string&amp; str)
1034  {
1035  	using convert_typeX = std::codecvt_utf8&lt;wchar_t&gt;;
1036  	std::wstring_convert&lt;convert_typeX, wchar_t&gt; converterX(&quot;Error in Notepad++ string conversion s2ws!&quot;, L&quot;Error in Notepad++ string conversion s2ws!&quot;);
1037  	return converterX.from_bytes(str);
1038  }
1039  std::string ws2s(const std::wstring&amp; wstr)
1040  {
1041  	using convert_typeX = std::codecvt_utf8&lt;wchar_t&gt;;
1042  	std::wstring_convert&lt;convert_typeX, wchar_t&gt; converterX(&quot;Error in Notepad++ string conversion ws2s!&quot;, L&quot;Error in Notepad++ string conversion ws2s!&quot;);
1043  	return converterX.to_bytes(wstr);
1044  }
1045  bool deleteFileOrFolder(const generic_string&amp; f2delete)
1046  {
1047  	auto len = f2delete.length();
1048  	TCHAR* actionFolder = new TCHAR[len + 2];
1049  	wcscpy_s(actionFolder, len + 2, f2delete.c_str());
1050  	actionFolder[len] = 0;
1051  	actionFolder[len + 1] = 0;
1052  	SHFILEOPSTRUCT fileOpStruct = {};
1053  	fileOpStruct.hwnd = NULL;
1054  	fileOpStruct.pFrom = actionFolder;
1055  	fileOpStruct.pTo = NULL;
1056  	fileOpStruct.wFunc = FO_DELETE;
1057  	fileOpStruct.fFlags = FOF_NOCONFIRMATION | FOF_SILENT | FOF_ALLOWUNDO;
1058  	fileOpStruct.fAnyOperationsAborted = false;
1059  	fileOpStruct.hNameMappings = NULL;
1060  	fileOpStruct.lpszProgressTitle = NULL;
1061  	int res = SHFileOperation(&amp;fileOpStruct);
1062  	delete[] actionFolder;
1063  	return (res == 0);
1064  }
1065  void getFilesInFolder(std::vector&lt;generic_string&gt;&amp; files, const generic_string&amp; extTypeFilter, const generic_string&amp; inFolder)
1066  {
1067  	generic_string filter = inFolder;
1068  	pathAppend(filter, extTypeFilter);
1069  	WIN32_FIND_DATA foundData;
1070  	HANDLE hFindFile = ::FindFirstFile(filter.c_str(), &amp;foundData);
1071  	if (hFindFile != INVALID_HANDLE_VALUE &amp;&amp; !(foundData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
1072  	{
1073  		generic_string foundFullPath = inFolder;
1074  		pathAppend(foundFullPath, foundData.cFileName);
1075  		files.push_back(foundFullPath);
1076  		while (::FindNextFile(hFindFile, &amp;foundData))
1077  		{
1078  			generic_string foundFullPath2 = inFolder;
1079  			pathAppend(foundFullPath2, foundData.cFileName);
1080  			files.push_back(foundFullPath2);
1081  		}
1082  	}
1083  	::FindClose(hFindFile);
1084  }
1085  void trim(generic_string&amp; str)
1086  {
1087  	generic_string::size_type pos = str.find_last_not_of(&#x27; &#x27;);
1088  	if (pos != generic_string::npos)
1089  	{
1090  		str.erase(pos + 1);
1091  		pos = str.find_first_not_of(&#x27; &#x27;);
1092  		if (pos != generic_string::npos) str.erase(0, pos);
1093  	}
1094  	else str.erase(str.begin(), str.end());
1095  }
1096  int nbDigitsFromNbLines(size_t nbLines)
1097  {
1098  	int nbDigits = 0; 
1099  	if (nbLines &lt; 10) nbDigits = 1;
1100  	else if (nbLines &lt; 100) nbDigits = 2;
1101  	else if (nbLines &lt; 1000) nbDigits = 3;
1102  	else if (nbLines &lt; 10000) nbDigits = 4;
1103  	else if (nbLines &lt; 100000) nbDigits = 5;
1104  	else if (nbLines &lt; 1000000) nbDigits = 6;
1105  	else 
1106  	{
1107  		nbDigits = 7;
1108  		nbLines /= 10000000;
1109  		while (nbLines)
1110  		{
1111  			nbLines /= 10;
1112  			++nbDigits;
1113  		}
1114  	}
1115  	return nbDigits;
1116  }
1117  namespace
1118  {
1119  	constexpr TCHAR timeFmtEscapeChar = 0x1;
1120  	constexpr TCHAR middayFormat[] = _T(&quot;tt&quot;);
1121  	generic_string getMiddayString(const TCHAR* localeName, const SYSTEMTIME&amp; st)
1122  	{
1123  		generic_string midday;
1124  		midday.resize(MAX_PATH);
1125  		int ret = GetTimeFormatEx(localeName, 0, &amp;st, middayFormat, &amp;midday[0], static_cast&lt;int&gt;(midday.size()));
1126  		if (ret &gt; 0)
1127  			midday.resize(ret - 1); 
1128  		else
1129  			midday.clear();
1130  		return midday;
1131  	}
1132  	bool escapeTimeFormat(generic_string&amp; format)
1133  	{
1134  		bool modified = false;
1135  		for (auto&amp; ch : format)
1136  		{
1137  			if (ch == middayFormat[0])
1138  			{
1139  				ch = timeFmtEscapeChar;
1140  				modified = true;
1141  			}
1142  		}
1143  		return modified;
1144  	}
1145  	void unescapeTimeFormat(generic_string&amp; format, const generic_string&amp; midday)
1146  	{
1147  		if (midday.empty())
1148  		{
1149  			auto it = std::remove(format.begin(), format.end(), timeFmtEscapeChar);
1150  			if (it != format.end())
1151  				format.erase(it, format.end());
1152  		}
1153  		else
1154  		{
1155  			size_t i = 0;
1156  			while ((i = format.find(timeFmtEscapeChar, i)) != generic_string::npos)
1157  			{
1158  				if (i + 1 &lt; format.size() &amp;&amp; format[i + 1] == timeFmtEscapeChar)
1159  				{
1160  					format.erase(i, std::size(middayFormat) - 1);
1161  					format.insert(i, midday);
1162  				}
1163  				else
1164  				{
1165  					format[i] = midday[0];
1166  				}
1167  			}
1168  		}
1169  	}
1170  }
1171  generic_string getDateTimeStrFrom(const generic_string&amp; dateTimeFormat, const SYSTEMTIME&amp; st)
1172  {
1173  	const TCHAR* localeName = LOCALE_NAME_USER_DEFAULT;
1174  	const DWORD flags = 0;
1175  	constexpr int bufferSize = MAX_PATH;
1176  	TCHAR buffer[bufferSize] = {};
1177  	int ret = 0;
1178  	generic_string newFormat = dateTimeFormat;
1179  	const bool hasMiddayFormat = escapeTimeFormat(newFormat);
1180  	ret = GetTimeFormatEx(localeName, flags, &amp;st, newFormat.c_str(), buffer, bufferSize);
1181  	if (ret != 0)
1182  	{
1183  		ret = GetDateFormatEx(localeName, flags, &amp;st, buffer, buffer, bufferSize, nullptr);
1184  	}
1185  	if (ret != 0)
1186  	{
1187  		if (hasMiddayFormat)
1188  		{
1189  			const generic_string midday = getMiddayString(localeName, st);
1190  			generic_string result = buffer;
1191  			unescapeTimeFormat(result, midday);
1192  			return result;
1193  		}
1194  		return buffer;
1195  	}
1196  	return {};
1197  }
1198  HFONT createFont(const TCHAR* fontName, int fontSize, bool isBold, HWND hDestParent)
1199  {
1200  	HDC hdc = GetDC(hDestParent);
1201  	LOGFONT logFont = {};
1202  	logFont.lfHeight = -MulDiv(fontSize, GetDeviceCaps(hdc, LOGPIXELSY), 72);
1203  	if (isBold)
1204  		logFont.lfWeight = FW_BOLD;
1205  	wcscpy_s(logFont.lfFaceName, fontName);
1206  	HFONT newFont = CreateFontIndirect(&amp;logFont);
1207  	ReleaseDC(hDestParent, hdc);
1208  	return newFont;
1209  }
1210  bool isWin32NamespacePrefixedFileName(const generic_string&amp; fileName)
1211  {
1212  	return (fileName.starts_with(TEXT(&quot;\\\\?\\&quot;)) || fileName.starts_with(TEXT(&quot;&amp;bsol;&amp;bsol;?/&quot;)));
1213  }
1214  bool isWin32NamespacePrefixedFileName(const TCHAR* szFileName)
1215  {
1216  	const generic_string fileName = szFileName;
1217  	return isWin32NamespacePrefixedFileName(fileName);
1218  }
1219  bool isUnsupportedFileName(const generic_string&amp; fileName)
1220  {
1221  	bool isUnsupported = true;
1222  	if ((fileName.size() &gt; 0) &amp;&amp; (fileName.size() &lt; MAX_PATH))
1223  	{
1224  		if (!fileName.ends_with(_T(&#x27;.&#x27;)) &amp;&amp; !fileName.ends_with(_T(&#x27; &#x27;)))
1225  		{
1226  			bool invalidASCIIChar = false;
1227  			for (size_t pos = 0; pos &lt; fileName.size(); ++pos)
1228  			{
1229  				TCHAR c = fileName.at(pos);
1230  				if (c &lt;= 31)
1231  				{
1232  					invalidASCIIChar = true;
1233  				}
1234  				else
1235  				{
1236  					switch (c)
1237  					{
1238  						case &#x27;&lt;&#x27;:
1239  						case &#x27;&gt;&#x27;:
1240  						case &#x27;&quot;&#x27;:
1241  						case &#x27;|&#x27;:
1242  							invalidASCIIChar = true;
1243  							break;
1244  					}
1245  				}
1246  				if (invalidASCIIChar)
1247  					break;
1248  			}
1249  			if (!invalidASCIIChar)
1250  			{
1251  				generic_string fileNameOnly;
1252  				size_t pos = fileName.find_first_of(TEXT(&quot;.&quot;));
1253  				if (pos != std::string::npos)
1254  					fileNameOnly = fileName.substr(0, pos);
1255  				else
1256  					fileNameOnly = fileName;
1257  				pos = fileNameOnly.find_last_of(TEXT(&quot;\\&quot;));
1258  				if (pos == std::string::npos)
1259  					pos = fileNameOnly.find_last_of(TEXT(&quot;/&quot;));
1260  				if (pos != std::string::npos)
1261  					fileNameOnly = fileNameOnly.substr(pos + 1);
1262  				const std::vector&lt;generic_string&gt;  reservedWin32NamespaceDeviceList{
1263  				TEXT(&quot;CON&quot;), TEXT(&quot;PRN&quot;), TEXT(&quot;AUX&quot;), TEXT(&quot;NUL&quot;),
1264  				TEXT(&quot;COM1&quot;), TEXT(&quot;COM2&quot;), TEXT(&quot;COM3&quot;), TEXT(&quot;COM4&quot;), TEXT(&quot;COM5&quot;), TEXT(&quot;COM6&quot;), TEXT(&quot;COM7&quot;), TEXT(&quot;COM8&quot;), TEXT(&quot;COM9&quot;),
1265  				TEXT(&quot;LPT1&quot;), TEXT(&quot;LPT2&quot;), TEXT(&quot;LPT3&quot;), TEXT(&quot;LPT4&quot;), TEXT(&quot;LPT5&quot;), TEXT(&quot;LPT6&quot;), TEXT(&quot;LPT7&quot;), TEXT(&quot;LPT8&quot;), TEXT(&quot;LPT9&quot;)
1266  				};
1267  				if (std::find(reservedWin32NamespaceDeviceList.begin(), reservedWin32NamespaceDeviceList.end(), fileNameOnly) == reservedWin32NamespaceDeviceList.end())
1268  				{
1269  					isUnsupported = false;
1270  				}
1271  			}
1272  		}
1273  	}
1274  	return isUnsupported;
1275  }
1276  bool isUnsupportedFileName(const TCHAR* szFileName)
1277  {
1278  	const generic_string fileName = szFileName;
1279  	return isUnsupportedFileName(fileName);
1280  }
1281  Version::Version(const generic_string&amp; versionStr)
1282  {
1283  	try {
1284  		auto ss = tokenizeString(versionStr, &#x27;.&#x27;);
1285  		if (ss.size() &gt; 4)
1286  		{
1287  			std::wstring msg(L&quot;\&quot;&quot;);
1288  			msg += versionStr;
1289  			msg += L&quot;\&quot;&quot;;
1290  			msg += TEXT(&quot;: Version parts are more than 4. The string to parse is not a valid version format. Let&#x27;s make it default value in catch block.&quot;);
1291  			throw msg;
1292  		}
1293  		int i = 0;
1294  		std::vector&lt;unsigned long*&gt; v = { &amp;_major, &amp;_minor, &amp;_patch, &amp;_build };
1295  		for (const auto&amp; s : ss)
1296  		{
1297  			if (!isNumber(s))
1298  			{
1299  				std::wstring msg(L&quot;\&quot;&quot;);
1300  				msg += versionStr;
1301  				msg += L&quot;\&quot;&quot;;
1302  				msg += TEXT(&quot;: One of version character is not number. The string to parse is not a valid version format. Let&#x27;s make it default value in catch block.&quot;);
1303  				throw msg;
1304  			}
1305  			*(v[i]) = std::stoi(s);
1306  			++i;
1307  		}
1308  	}
1309  #ifdef DEBUG
1310  	catch (const std::wstring&amp; s)
1311  	{
1312  		_major = 0;
1313  		_minor = 0;
1314  		_patch = 0;
1315  		_build = 0;
1316  		throw s;
1317  	}
1318  #endif
1319  	catch (...)
1320  	{
1321  		_major = 0;
1322  		_minor = 0;
1323  		_patch = 0;
1324  		_build = 0;
1325  #ifdef DEBUG
1326  		throw std::wstring(TEXT(&quot;Unknown exception from \&quot;Version::Version(const generic_string&amp; versionStr)\&quot;&quot;));
1327  #endif
1328  	}
1329  }
1330  void Version::setVersionFrom(const generic_string&amp; filePath)
1331  {
1332  	if (!filePath.empty() &amp;&amp; ::PathFileExists(filePath.c_str()))
1333  	{
1334  		DWORD uselessArg = 0; 
1335  		DWORD bufferSize = ::GetFileVersionInfoSize(filePath.c_str(), &amp;uselessArg);
1336  		if (bufferSize &lt;= 0)
1337  			return;
1338  		unsigned char* buffer = new unsigned char[bufferSize];
1339  		::GetFileVersionInfo(filePath.c_str(), 0, bufferSize, buffer);
1340  		VS_FIXEDFILEINFO* lpFileInfo = nullptr;
1341  		UINT cbFileInfo = 0;
1342  		VerQueryValue(buffer, TEXT(&quot;\\&quot;), reinterpret_cast&lt;LPVOID*&gt;(&amp;lpFileInfo), &amp;cbFileInfo);
1343  		if (cbFileInfo)
1344  		{
1345  			_major = (lpFileInfo-&gt;dwFileVersionMS &amp; 0xFFFF0000) &gt;&gt; 16;
1346  			_minor = lpFileInfo-&gt;dwFileVersionMS &amp; 0x0000FFFF;
1347  			_patch = (lpFileInfo-&gt;dwFileVersionLS &amp; 0xFFFF0000) &gt;&gt; 16;
1348  			_build = lpFileInfo-&gt;dwFileVersionLS &amp; 0x0000FFFF;
1349  		}
1350  		delete[] buffer;
1351  	}
1352  }
1353  generic_string Version::toString()
1354  {
1355  	if (_build == 0 &amp;&amp; _patch == 0 &amp;&amp; _minor == 0 &amp;&amp; _major == 0) 
1356  	{
1357  		return TEXT(&quot;&quot;);
1358  	}
1359  	else if (_build == 0 &amp;&amp; _patch == 0 &amp;&amp; _minor == 0) 
1360  	{
1361  		return std::to_wstring(_major);
1362  	}
1363  	else if (_build == 0 &amp;&amp; _patch == 0) 
1364  	{
1365  		std::wstring v = std::to_wstring(_major);
1366  		v += TEXT(&quot;.&quot;);
1367  		v += std::to_wstring(_minor);
1368  		return v;
1369  	}
1370  	else if (_build == 0) 
1371  	{
1372  		std::wstring v = std::to_wstring(_major);
1373  		v += TEXT(&quot;.&quot;);
1374  		v += std::to_wstring(_minor);
1375  		v += TEXT(&quot;.&quot;);
1376  		v += std::to_wstring(_patch);
1377  		return v;
1378  	}
1379  	std::wstring ver = std::to_wstring(_major);
1380  	ver += TEXT(&quot;.&quot;);
1381  	ver += std::to_wstring(_minor);
1382  	ver += TEXT(&quot;.&quot;);
1383  	ver += std::to_wstring(_patch);
1384  	ver += TEXT(&quot;.&quot;);
1385  	ver += std::to_wstring(_build);
1386  	return ver;
1387  }
1388  int Version::compareTo(const Version&amp; v2c) const
1389  {
1390  	if (_major &gt; v2c._major)
1391  		return 1;
1392  	else if (_major &lt; v2c._major)
1393  		return -1;
1394  	else 
1395  	{
1396  		if (_minor &gt; v2c._minor)
1397  			return 1;
1398  		else if (_minor &lt; v2c._minor)
1399  			return -1;
1400  		else 
1401  		{
1402  			if (_patch &gt; v2c._patch)
1403  				return 1;
1404  			else if (_patch &lt; v2c._patch)
1405  				return -1;
1406  			else 
1407  			{
1408  				if (_build &gt; v2c._build)
1409  					return 1;
1410  				else if (_build &lt; v2c._build)
1411  					return -1;
1412  				else 
1413  				{
1414  					return 0;
1415  				}
1416  			}
1417  		}
1418  	}
1419  }
1420  bool Version::isCompatibleTo(const Version&amp; from, const Version&amp; to) const
1421  {
1422  	if (empty()) 
1423  		return false;
1424  	if (from.empty() &amp;&amp; to.empty()) 
1425  	{
1426  		return true;
1427  	}
1428  	if (from &lt;= *this &amp;&amp; to &gt;= *this) 
1429  	{
1430  		return true;
1431  	}
1432  	if (from &lt;= *this &amp;&amp; to.empty()) 
1433  	{
1434  		return true;
1435  	}
1436  	return false;
1437  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EncodingMapper.cpp</h3>
            <pre><code>1  #include &lt;string.h&gt;
2  #include &quot;EncodingMapper.h&quot;
3  #include &quot;Scintilla.h&quot;
4  static EncodingUnit encodings[] = {
5      {1250,  &quot;windows-1250&quot;},                                                                    
6      {1251,  &quot;windows-1251&quot;},                                                                    
7      {1252,  &quot;windows-1252&quot;},                                                                    
8      {1253,  &quot;windows-1253&quot;},                                                                    
9      {1254,  &quot;windows-1254&quot;},                                                                    
10      {1255,  &quot;windows-1255&quot;},                                                                    
11      {1256,  &quot;windows-1256&quot;},                                                                    
12      {1257,  &quot;windows-1257&quot;},                                                                    
13      {1258,  &quot;windows-1258&quot;},                                                                    
14      {28591, &quot;latin1 ISO_8859-1 ISO-8859-1 CP819 IBM819 csISOLatin1 iso-ir-100 l1&quot;},             
15      {28592, &quot;latin2 ISO_8859-2 ISO-8859-2 csISOLatin2 iso-ir-101 l2&quot;},                          
16      {28593, &quot;latin3 ISO_8859-3 ISO-8859-3 csISOLatin3 iso-ir-109 l3&quot;},                          
17      {28594, &quot;latin4 ISO_8859-4 ISO-8859-4 csISOLatin4 iso-ir-110 l4&quot;},                          
18      {28595, &quot;cyrillic ISO_8859-5 ISO-8859-5 csISOLatinCyrillic iso-ir-144&quot;},                    
19      {28596, &quot;arabic ISO_8859-6 ISO-8859-6 csISOLatinArabic iso-ir-127 ASMO-708 ECMA-114&quot;},      
20      {28597, &quot;greek ISO_8859-7 ISO-8859-7 csISOLatinGreek greek8 iso-ir-126 ELOT_928 ECMA-118&quot;}, 
21      {28598, &quot;hebrew ISO_8859-8 ISO-8859-8 csISOLatinHebrew iso-ir-138&quot;},                        
22      {28599, &quot;latin5 ISO_8859-9 ISO-8859-9 csISOLatin5 iso-ir-148 l5&quot;},                          
23      {-1,    &quot;&quot;&amp;bsol;*&quot;latin6 ISO_8859-10 ISO-8859-10 csISOLatin6 iso-ir-157 l6&quot;*/},                  
24      {-1,    &quot;&quot;&amp;bsol;*&quot;ISO_8859-11 ISO-8859-11&quot;*/},                                                   
25      {28603, &quot;ISO_8859-13 ISO-8859-13&quot;},                                                         
26      {28604, &quot;iso-celtic latin8 ISO_8859-14 ISO-8859-14 18 iso-ir-199&quot;},                         
27      {28605, &quot;Latin-9 ISO_8859-15 ISO-8859-15&quot;},                                                 
28      {-1,    &quot;&quot;&amp;bsol;*&quot;latin10 ISO_8859-16 ISO-8859-16 110 iso-ir-226&quot;*/},                            
29      {437,   &quot;IBM437 cp437 437 csPC8CodePage437&quot;},                                               
30      {720,   &quot;IBM720 cp720 oem720 720&quot;},                                                         
31      {737,   &quot;IBM737 cp737 oem737 737&quot;},                                                         
32      {775,   &quot;IBM775 cp775 oem775 775&quot;},                                                         
33      {850,   &quot;IBM850 cp850 oem850 850&quot;},                                                         
34      {852,   &quot;IBM852 cp852 oem852 852&quot;},                                                         
35      {855,   &quot;IBM855 cp855 oem855 855 csIBM855&quot;},                                                
36      {857,   &quot;IBM857 cp857 oem857 857&quot;},                                                         
37      {858,   &quot;IBM858 cp858 oem858 858&quot;},                                                         
38      {860,   &quot;IBM860 cp860 oem860 860&quot;},                                                         
39      {861,   &quot;IBM861 cp861 oem861 861&quot;},                                                         
40      {862,   &quot;IBM862 cp862 oem862 862&quot;},                                                         
41      {863,   &quot;IBM863 cp863 oem863 863&quot;},                                                         
42      {865,   &quot;IBM865 cp865 oem865 865&quot;},                                                         
43      {866,   &quot;IBM866 cp866 oem866 866&quot;},                                                         
44      {869,   &quot;IBM869 cp869 oem869 869&quot;},                                                         
45      {950,   &quot;big5 csBig5&quot;},                                                                     
46      {936,   &quot;gb2312 gbk csGB2312 gb18030&quot;},                                                     
47      {932,   &quot;Shift_JIS MS_Kanji csShiftJIS csWindows31J&quot;},                                      
48      {949,   &quot;windows-949 korean&quot;},                                                              
49      {51949, &quot;euc-kr csEUCKR&quot;},                                                                  
50      {874,   &quot;tis-620&quot;},                                                                         
51      {10007, &quot;x-mac-cyrillic xmaccyrillic&quot;},                                                     
52      {21866, &quot;koi8_u&quot;},                                                                          
53      {20866, &quot;koi8_r csKOI8R&quot;}                                                                   
54  };
55  bool isInListA(const char *token, const char *list)
56  {
57  	if ((!token) || (!list))
58  		return false;
59  	char word[64] = { &#x27;\0&#x27; };
60  	size_t i = 0;
61  	size_t j = 0;
62  	for (size_t len = strlen(list); i &lt;= len; ++i)
63  	{
64  		if ((list[i] == &#x27; &#x27;)||(list[i] == &#x27;\0&#x27;))
65  		{
66  			if (j != 0)
67  			{
<span onclick='openModal()' class='match'>68  				word[j] = &#x27;\0&#x27;;
69  				j = 0;
70  				if (!stricmp(token, word))
71  					return true;
72  			}
73  		}
74  		else 
75  		{
76  			word[j] = list[i];
77  			++j;
78  		}
</span>79  	}
80  	return false;
81  }
82  int EncodingMapper::getEncodingFromIndex(int index) const
83  {
84  	size_t nbItem = sizeof(encodings)/sizeof(EncodingUnit);
85  	if (index &lt; 0 || (size_t)index &gt;= nbItem)
86  		return -1;
87  	return encodings[index]._codePage;
88  }
89  int EncodingMapper::getIndexFromEncoding(int encoding) const
90  {
91  	bool found = false;
92  	int nbItem = sizeof(encodings)/sizeof(EncodingUnit);
93  	int i = 0;
94  	if (encoding == -1)
95  		return -1;
96  	for ( ; i &lt; nbItem; ++i)
97  	{
98  		if (encodings[i]._codePage == encoding)
99  		{
100  			found = true;
101  			break;
102  		}
103  	}
104  	return found ? i : -1;
105  }
106  int EncodingMapper::getEncodingFromString(const char *encodingAlias) const
107  {
108  	if (isInListA(encodingAlias, &quot;utf-8 utf8&quot;))
109  		return SC_CP_UTF8;
110  	size_t nbItem = sizeof(encodings)/sizeof(EncodingUnit);
111  	int enc = -1;
112  	for (size_t i = 0 ; i &lt; nbItem ; ++i)
113  	{
114  		if (isInListA(encodingAlias, encodings[i]._aliasList))
115  		{
116  			enc = encodings[i]._codePage;
117  			break;
118  		}
119  	}
120  	return enc;
121  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Common.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EncodingMapper.cpp</div>
                </div>
                <div class="column column_space"><pre><code>201  				word[j] = &#x27;\0&#x27;;
202  				j = 0;
203  				if (!wcsicmp(token, word))
204  					return true;
205  			}
206  		}
207  		else
208  		{
209  			word[j] = list[i];
210  			++j;
211  			if (j &gt;= wordLen)
</pre></code></div>
                <div class="column column_space"><pre><code>68  				word[j] = &#x27;\0&#x27;;
69  				j = 0;
70  				if (!stricmp(token, word))
71  					return true;
72  			}
73  		}
74  		else 
75  		{
76  			word[j] = list[i];
77  			++j;
78  		}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    