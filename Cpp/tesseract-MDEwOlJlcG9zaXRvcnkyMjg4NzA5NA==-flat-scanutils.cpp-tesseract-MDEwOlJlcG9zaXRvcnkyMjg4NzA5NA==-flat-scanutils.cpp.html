
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <climits> 
6  #include <cmath>
7  #include <cstdarg>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstring>
12  #include <limits> 
13  #include "scanutils.h"
14  enum Flags {
15    FL_SPLAT = 0x01, 
16    FL_INV = 0x02,   
17    FL_WIDTH = 0x04, 
18    FL_MINUS = 0x08, 
19  };
20  enum Ranks {
21    RANK_CHAR = -2,
22    RANK_SHORT = -1,
23    RANK_INT = 0,
24    RANK_LONG = 1,
25    RANK_LONGLONG = 2,
26    RANK_PTR = std::numeric_limits<int>::max() 
27  };
28  const enum Ranks kMinRank = RANK_CHAR;
29  const enum Ranks kMaxRank = RANK_LONGLONG;
30  const enum Ranks kIntMaxRank = RANK_LONGLONG;
31  const enum Ranks kSizeTRank = RANK_LONG;
32  const enum Ranks kPtrDiffRank = RANK_LONG;
33  enum Bail {
34    BAIL_NONE = 0, 
35    BAIL_EOF,      
36    BAIL_ERR       
37  };
38  inline size_t LongBit() {
39    return CHAR_BIT * sizeof(long);
40  }
41  static inline int SkipSpace(FILE *s) {
42    int p;
43    while (isascii(p = fgetc(s)) && isspace(p)) {
44      ;
45    }
46    ungetc(p, s); 
47    return p;
48  }
49  static inline void SetBit(unsigned long *bitmap, unsigned int bit) {
50    bitmap[bit / LongBit()] |= 1UL << (bit % LongBit());
51  }
52  static inline int TestBit(unsigned long *bitmap, unsigned int bit) {
53    return static_cast<int>(bitmap[bit / LongBit()] >> (bit % LongBit())) & 1;
54  }
55  static inline int DigitValue(int ch, int base) {
56    if (ch >= '0' && ch <= '9') {
57      if (base >= 10 || ch <= '7') {
58        return ch - '0';
59      }
60    } else if (ch >= 'A' && ch <= 'Z' && base == 16) {
61      return ch - 'A' + 10;
62    } else if (ch >= 'a' && ch <= 'z' && base == 16) {
63      return ch - 'a' + 10;
64    }
65    return -1;
66  }
67  static uintmax_t streamtoumax(FILE *s, int base) {
68    int minus = 0;
69    uintmax_t v = 0;
70    int d, c = 0;
71    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
72      ;
73    }
74    if (c == '-' || c == '+') {
75      minus = (c == '-');
76      c = fgetc(s);
77    }
78    if (base == 0) {
79      if (c == '0') {
<span onclick='openModal()' class='match'>80        c = fgetc(s);
81        if (c == 'x' || c == 'X') {
82          base = 16;
</span>83          c = fgetc(s);
84        } else {
85          base = 8;
86        }
87      }
88    } else if (base == 16) {
89      if (c == '0') {
90        c = fgetc(s);
91        if (c == 'x' || c == 'X') {
92          c = fgetc(s);
93        }
94      }
95    }
96    for (; (c != EOF) && (d = DigitValue(c, base)) >= 0; c = fgetc(s)) {
97      v = v * base + d;
98    }
99    ungetc(c, s);
100    return minus ? -v : v;
101  }
102  static double streamtofloat(FILE *s) {
103    bool minus = false;
104    uint64_t v = 0;
105    int d, c;
106    uint64_t k = 1;
107    uint64_t w = 0;
108    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
109      ;
110    }
111    if (c == '-' || c == '+') {
112      minus = (c == '-');
113      c = fgetc(s);
114    }
115    for (; c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
116      v = v * 10 + d;
117    }
118    if (c == '.') {
119      for (c = fgetc(s); c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
120        w = w * 10 + d;
121        k *= 10;
122      }
123    }
124    double f = v + static_cast<double>(w) / k;
125    if (c == 'e' || c == 'E') {
126      c = fgetc(s);
127      int expsign = 1;
128      if (c == '-' || c == '+') {
129        expsign = (c == '-') ? -1 : 1;
130        c = fgetc(s);
131      }
132      int exponent = 0;
133      for (; (c != EOF) && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
134        exponent = exponent * 10 + d;
135      }
136      exponent *= expsign;
137      f *= pow(10.0, static_cast<double>(exponent));
138    }
139    ungetc(c, s);
140    return minus ? -f : f;
141  }
142  static int tvfscanf(FILE *stream, const char *format, va_list ap);
143  int tfscanf(FILE *stream, const char *format, ...) {
144    va_list ap;
145    int rv;
146    va_start(ap, format);
147    rv = tvfscanf(stream, format, ap);
148    va_end(ap);
149    return rv;
150  }
151  static int tvfscanf(FILE *stream, const char *format, va_list ap) {
152    const char *p = format;
153    char ch;
154    int q = 0;
155    uintmax_t val = 0;
156    int rank = RANK_INT; 
157    unsigned int width = UINT_MAX;
158    int base;
159    int flags = 0;
160    enum {
161      ST_NORMAL,      
162      ST_FLAGS,       
163      ST_WIDTH,       
164      ST_MODIFIERS,   
165      ST_MATCH_INIT,  
166      ST_MATCH,       
167      ST_MATCH_RANGE, 
168    } state = ST_NORMAL;
169    char *sarg = nullptr; 
170    enum Bail bail = BAIL_NONE;
171    int converted = 0; 
172    unsigned long
173        matchmap[((1 << CHAR_BIT) + (CHAR_BIT * sizeof(long) - 1)) / (CHAR_BIT * sizeof(long))];
174    int matchinv = 0; 
175    unsigned char range_start = 0;
176    auto start_off = std::ftell(stream);
177    SkipSpace(stream);
178    while ((ch = *p++) && !bail) {
179      switch (state) {
180        case ST_NORMAL:
181          if (ch == '%') {
182            state = ST_FLAGS;
183            flags = 0;
184            rank = RANK_INT;
185            width = UINT_MAX;
186          } else if (isascii(ch) && isspace(ch)) {
187            SkipSpace(stream);
188          } else {
189            if (fgetc(stream) != ch) {
190              bail = BAIL_ERR; 
191            }
192          }
193          break;
194        case ST_FLAGS:
195          if (ch == '*') {
196            flags |= FL_SPLAT;
197          } else if ('0' <= ch && ch <= '9') {
198            width = (ch - '0');
199            state = ST_WIDTH;
200            flags |= FL_WIDTH;
201          } else {
202            state = ST_MODIFIERS;
203            p--; 
204          }
205          break;
206        case ST_WIDTH:
207          if (ch >= '0' && ch <= '9') {
208            width = width * 10 + (ch - '0');
209          } else {
210            state = ST_MODIFIERS;
211            p--; 
212          }
213          break;
214        case ST_MODIFIERS:
215          switch (ch) {
216            case 'h':
217              rank--; 
218              break;
219            case 'l':
220              rank++; 
221              break;
222            case 'j':
223              rank = kIntMaxRank;
224              break;
225            case 'z':
226              rank = kSizeTRank;
227              break;
228            case 't':
229              rank = kPtrDiffRank;
230              break;
231            case 'L':
232            case 'q':
233              rank = RANK_LONGLONG; 
234              break;
235            default:
236              state = ST_NORMAL;   
237              if (rank < kMinRank) { 
238                rank = kMinRank;
239              } else if (rank > kMaxRank) {
240                rank = kMaxRank;
241              }
242              switch (ch) {
243                case 'P': 
244                case 'p': 
245                  rank = RANK_PTR;
246                  base = 0;
247                  goto scan_int;
248                case 'i': 
249                  base = 0;
250                  goto scan_int;
251                case 'd': 
252                  base = 10;
253                  goto scan_int;
254                case 'o': 
255                  base = 8;
256                  goto scan_int;
257                case 'u': 
258                  base = 10;
259                  goto scan_int;
260                case 'x': 
261                case 'X':
262                  base = 16;
263                  goto scan_int;
264                case 'n': 
265                  val = std::ftell(stream) - start_off;
266                  goto set_integer;
267                scan_int:
268                  q = SkipSpace(stream);
269                  if (q <= 0) {
270                    bail = BAIL_EOF;
271                    break;
272                  }
273                  val = streamtoumax(stream, base);
274                set_integer:
275                  if (!(flags & FL_SPLAT)) {
276                    converted++;
277                    switch (rank) {
278                      case RANK_CHAR:
279                        *va_arg(ap, unsigned char *) = static_cast<unsigned char>(val);
280                        break;
281                      case RANK_SHORT:
282                        *va_arg(ap, unsigned short *) = static_cast<unsigned short>(val);
283                        break;
284                      case RANK_INT:
285                        *va_arg(ap, unsigned int *) = static_cast<unsigned int>(val);
286                        break;
287                      case RANK_LONG:
288                        *va_arg(ap, unsigned long *) = static_cast<unsigned long>(val);
289                        break;
290                      case RANK_LONGLONG:
291                        *va_arg(ap, unsigned long long *) = static_cast<unsigned long long>(val);
292                        break;
293                      case RANK_PTR:
294                        *va_arg(ap, void **) = reinterpret_cast<void *>(static_cast<uintptr_t>(val));
295                        break;
296                    }
297                  }
298                  break;
299                case 'f': 
300                case 'g':
301                case 'G':
302                case 'e':
303                case 'E':
304                  q = SkipSpace(stream);
305                  if (q <= 0) {
306                    bail = BAIL_EOF;
307                    break;
308                  }
309                  {
310                    double fval = streamtofloat(stream);
311                    if (!(flags & FL_SPLAT)) {
312                      if (rank == RANK_INT) {
313                        *va_arg(ap, float *) = static_cast<float>(fval);
314                      } else if (rank == RANK_LONG) {
315                        *va_arg(ap, double *) = static_cast<double>(fval);
316                      }
317                      converted++;
318                    }
319                  }
320                  break;
321                case 'c':                                 
322                  width = (flags & FL_WIDTH) ? width : 1; 
323                  sarg = va_arg(ap, char *);
324                  while (width--) {
325                    if ((q = fgetc(stream)) <= 0) {
326                      bail = BAIL_EOF;
327                      break;
328                    }
329                    if (!(flags & FL_SPLAT)) {
330                      *sarg++ = q;
331                      converted++;
332                    }
333                  }
334                  break;
335                case 's': 
336                {
337                  if (!(flags & FL_SPLAT)) {
338                    sarg = va_arg(ap, char *);
339                  }
340                  unsigned length = 0;
341                  while (width--) {
342                    q = fgetc(stream);
343                    if ((isascii(q) && isspace(q)) || (q <= 0)) {
344                      ungetc(q, stream);
345                      break;
346                    }
347                    if (!(flags & FL_SPLAT)) {
348                      sarg[length] = q;
349                    }
350                    length++;
351                  }
352                  if (length == 0) {
353                    bail = BAIL_EOF;
354                  } else if (!(flags & FL_SPLAT)) {
355                    sarg[length] = '\0'; 
356                    converted++;
357                  }
358                } break;
359                case '[': 
360                  sarg = va_arg(ap, char *);
361                  state = ST_MATCH_INIT;
362                  matchinv = 0;
363                  memset(matchmap, 0, sizeof matchmap);
364                  break;
365                case '%': 
366                  if (fgetc(stream) != '%') {
367                    bail = BAIL_ERR;
368                  }
369                  break;
370                default:           
371                  bail = BAIL_ERR; 
372                  break;
373              }
374          }
375          break;
376        case ST_MATCH_INIT: 
377          if (ch == '^' && !(flags & FL_INV)) {
378            matchinv = 1;
379          } else {
380            SetBit(matchmap, static_cast<unsigned char>(ch));
381            state = ST_MATCH;
382          }
383          break;
384        case ST_MATCH: 
385          if (ch == ']') {
386            goto match_run;
387          } else if (ch == '-') {
388            range_start = static_cast<unsigned char>(ch);
389            state = ST_MATCH_RANGE;
390          } else {
391            SetBit(matchmap, static_cast<unsigned char>(ch));
392          }
393          break;
394        case ST_MATCH_RANGE: 
395          if (ch == ']') {
396            SetBit(matchmap, static_cast<unsigned char>('-'));
397            goto match_run;
398          } else {
399            int i;
400            for (i = range_start; i < (static_cast<unsigned char>(ch)); i++) {
401              SetBit(matchmap, i);
402            }
403            state = ST_MATCH;
404          }
405          break;
406        match_run: 
407          char *oarg = sarg;
408          while (width) {
409            q = fgetc(stream);
410            auto qc = static_cast<unsigned char>(q);
411            if (q <= 0 || !(TestBit(matchmap, qc) ^ matchinv)) {
412              ungetc(q, stream);
413              break;
414            }
415            if (!(flags & FL_SPLAT)) {
416              *sarg = q;
417            }
418            sarg++;
419          }
420          if (oarg == sarg) {
421            bail = (q <= 0) ? BAIL_EOF : BAIL_ERR;
422          } else if (!(flags & FL_SPLAT)) {
423            *sarg = '\0';
424            converted++;
425          }
426          break;
427      }
428    }
429    if (bail == BAIL_EOF && !converted) {
430      converted = -1; 
431    }
432    return converted;
433  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <climits> 
6  #include <cmath>
7  #include <cstdarg>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstring>
12  #include <limits> 
13  #include "scanutils.h"
14  enum Flags {
15    FL_SPLAT = 0x01, 
16    FL_INV = 0x02,   
17    FL_WIDTH = 0x04, 
18    FL_MINUS = 0x08, 
19  };
20  enum Ranks {
21    RANK_CHAR = -2,
22    RANK_SHORT = -1,
23    RANK_INT = 0,
24    RANK_LONG = 1,
25    RANK_LONGLONG = 2,
26    RANK_PTR = std::numeric_limits<int>::max() 
27  };
28  const enum Ranks kMinRank = RANK_CHAR;
29  const enum Ranks kMaxRank = RANK_LONGLONG;
30  const enum Ranks kIntMaxRank = RANK_LONGLONG;
31  const enum Ranks kSizeTRank = RANK_LONG;
32  const enum Ranks kPtrDiffRank = RANK_LONG;
33  enum Bail {
34    BAIL_NONE = 0, 
35    BAIL_EOF,      
36    BAIL_ERR       
37  };
38  inline size_t LongBit() {
39    return CHAR_BIT * sizeof(long);
40  }
41  static inline int SkipSpace(FILE *s) {
42    int p;
43    while (isascii(p = fgetc(s)) && isspace(p)) {
44      ;
45    }
46    ungetc(p, s); 
47    return p;
48  }
49  static inline void SetBit(unsigned long *bitmap, unsigned int bit) {
50    bitmap[bit / LongBit()] |= 1UL << (bit % LongBit());
51  }
52  static inline int TestBit(unsigned long *bitmap, unsigned int bit) {
53    return static_cast<int>(bitmap[bit / LongBit()] >> (bit % LongBit())) & 1;
54  }
55  static inline int DigitValue(int ch, int base) {
56    if (ch >= '0' && ch <= '9') {
57      if (base >= 10 || ch <= '7') {
58        return ch - '0';
59      }
60    } else if (ch >= 'A' && ch <= 'Z' && base == 16) {
61      return ch - 'A' + 10;
62    } else if (ch >= 'a' && ch <= 'z' && base == 16) {
63      return ch - 'a' + 10;
64    }
65    return -1;
66  }
67  static uintmax_t streamtoumax(FILE *s, int base) {
68    int minus = 0;
69    uintmax_t v = 0;
70    int d, c = 0;
71    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
72      ;
73    }
74    if (c == '-' || c == '+') {
75      minus = (c == '-');
76      c = fgetc(s);
77    }
78    if (base == 0) {
79      if (c == '0') {
<span onclick='openModal()' class='match'>80        c = fgetc(s);
81        if (c == 'x' || c == 'X') {
82          base = 16;
</span>83          c = fgetc(s);
84        } else {
85          base = 8;
86        }
87      }
88    } else if (base == 16) {
89      if (c == '0') {
90        c = fgetc(s);
91        if (c == 'x' || c == 'X') {
92          c = fgetc(s);
93        }
94      }
95    }
96    for (; (c != EOF) && (d = DigitValue(c, base)) >= 0; c = fgetc(s)) {
97      v = v * base + d;
98    }
99    ungetc(c, s);
100    return minus ? -v : v;
101  }
102  static double streamtofloat(FILE *s) {
103    bool minus = false;
104    uint64_t v = 0;
105    int d, c;
106    uint64_t k = 1;
107    uint64_t w = 0;
108    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
109      ;
110    }
111    if (c == '-' || c == '+') {
112      minus = (c == '-');
113      c = fgetc(s);
114    }
115    for (; c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
116      v = v * 10 + d;
117    }
118    if (c == '.') {
119      for (c = fgetc(s); c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
120        w = w * 10 + d;
121        k *= 10;
122      }
123    }
124    double f = v + static_cast<double>(w) / k;
125    if (c == 'e' || c == 'E') {
126      c = fgetc(s);
127      int expsign = 1;
128      if (c == '-' || c == '+') {
129        expsign = (c == '-') ? -1 : 1;
130        c = fgetc(s);
131      }
132      int exponent = 0;
133      for (; (c != EOF) && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
134        exponent = exponent * 10 + d;
135      }
136      exponent *= expsign;
137      f *= pow(10.0, static_cast<double>(exponent));
138    }
139    ungetc(c, s);
140    return minus ? -f : f;
141  }
142  static int tvfscanf(FILE *stream, const char *format, va_list ap);
143  int tfscanf(FILE *stream, const char *format, ...) {
144    va_list ap;
145    int rv;
146    va_start(ap, format);
147    rv = tvfscanf(stream, format, ap);
148    va_end(ap);
149    return rv;
150  }
151  static int tvfscanf(FILE *stream, const char *format, va_list ap) {
152    const char *p = format;
153    char ch;
154    int q = 0;
155    uintmax_t val = 0;
156    int rank = RANK_INT; 
157    unsigned int width = UINT_MAX;
158    int base;
159    int flags = 0;
160    enum {
161      ST_NORMAL,      
162      ST_FLAGS,       
163      ST_WIDTH,       
164      ST_MODIFIERS,   
165      ST_MATCH_INIT,  
166      ST_MATCH,       
167      ST_MATCH_RANGE, 
168    } state = ST_NORMAL;
169    char *sarg = nullptr; 
170    enum Bail bail = BAIL_NONE;
171    int converted = 0; 
172    unsigned long
173        matchmap[((1 << CHAR_BIT) + (CHAR_BIT * sizeof(long) - 1)) / (CHAR_BIT * sizeof(long))];
174    int matchinv = 0; 
175    unsigned char range_start = 0;
176    auto start_off = std::ftell(stream);
177    SkipSpace(stream);
178    while ((ch = *p++) && !bail) {
179      switch (state) {
180        case ST_NORMAL:
181          if (ch == '%') {
182            state = ST_FLAGS;
183            flags = 0;
184            rank = RANK_INT;
185            width = UINT_MAX;
186          } else if (isascii(ch) && isspace(ch)) {
187            SkipSpace(stream);
188          } else {
189            if (fgetc(stream) != ch) {
190              bail = BAIL_ERR; 
191            }
192          }
193          break;
194        case ST_FLAGS:
195          if (ch == '*') {
196            flags |= FL_SPLAT;
197          } else if ('0' <= ch && ch <= '9') {
198            width = (ch - '0');
199            state = ST_WIDTH;
200            flags |= FL_WIDTH;
201          } else {
202            state = ST_MODIFIERS;
203            p--; 
204          }
205          break;
206        case ST_WIDTH:
207          if (ch >= '0' && ch <= '9') {
208            width = width * 10 + (ch - '0');
209          } else {
210            state = ST_MODIFIERS;
211            p--; 
212          }
213          break;
214        case ST_MODIFIERS:
215          switch (ch) {
216            case 'h':
217              rank--; 
218              break;
219            case 'l':
220              rank++; 
221              break;
222            case 'j':
223              rank = kIntMaxRank;
224              break;
225            case 'z':
226              rank = kSizeTRank;
227              break;
228            case 't':
229              rank = kPtrDiffRank;
230              break;
231            case 'L':
232            case 'q':
233              rank = RANK_LONGLONG; 
234              break;
235            default:
236              state = ST_NORMAL;   
237              if (rank < kMinRank) { 
238                rank = kMinRank;
239              } else if (rank > kMaxRank) {
240                rank = kMaxRank;
241              }
242              switch (ch) {
243                case 'P': 
244                case 'p': 
245                  rank = RANK_PTR;
246                  base = 0;
247                  goto scan_int;
248                case 'i': 
249                  base = 0;
250                  goto scan_int;
251                case 'd': 
252                  base = 10;
253                  goto scan_int;
254                case 'o': 
255                  base = 8;
256                  goto scan_int;
257                case 'u': 
258                  base = 10;
259                  goto scan_int;
260                case 'x': 
261                case 'X':
262                  base = 16;
263                  goto scan_int;
264                case 'n': 
265                  val = std::ftell(stream) - start_off;
266                  goto set_integer;
267                scan_int:
268                  q = SkipSpace(stream);
269                  if (q <= 0) {
270                    bail = BAIL_EOF;
271                    break;
272                  }
273                  val = streamtoumax(stream, base);
274                set_integer:
275                  if (!(flags & FL_SPLAT)) {
276                    converted++;
277                    switch (rank) {
278                      case RANK_CHAR:
279                        *va_arg(ap, unsigned char *) = static_cast<unsigned char>(val);
280                        break;
281                      case RANK_SHORT:
282                        *va_arg(ap, unsigned short *) = static_cast<unsigned short>(val);
283                        break;
284                      case RANK_INT:
285                        *va_arg(ap, unsigned int *) = static_cast<unsigned int>(val);
286                        break;
287                      case RANK_LONG:
288                        *va_arg(ap, unsigned long *) = static_cast<unsigned long>(val);
289                        break;
290                      case RANK_LONGLONG:
291                        *va_arg(ap, unsigned long long *) = static_cast<unsigned long long>(val);
292                        break;
293                      case RANK_PTR:
294                        *va_arg(ap, void **) = reinterpret_cast<void *>(static_cast<uintptr_t>(val));
295                        break;
296                    }
297                  }
298                  break;
299                case 'f': 
300                case 'g':
301                case 'G':
302                case 'e':
303                case 'E':
304                  q = SkipSpace(stream);
305                  if (q <= 0) {
306                    bail = BAIL_EOF;
307                    break;
308                  }
309                  {
310                    double fval = streamtofloat(stream);
311                    if (!(flags & FL_SPLAT)) {
312                      if (rank == RANK_INT) {
313                        *va_arg(ap, float *) = static_cast<float>(fval);
314                      } else if (rank == RANK_LONG) {
315                        *va_arg(ap, double *) = static_cast<double>(fval);
316                      }
317                      converted++;
318                    }
319                  }
320                  break;
321                case 'c':                                 
322                  width = (flags & FL_WIDTH) ? width : 1; 
323                  sarg = va_arg(ap, char *);
324                  while (width--) {
325                    if ((q = fgetc(stream)) <= 0) {
326                      bail = BAIL_EOF;
327                      break;
328                    }
329                    if (!(flags & FL_SPLAT)) {
330                      *sarg++ = q;
331                      converted++;
332                    }
333                  }
334                  break;
335                case 's': 
336                {
337                  if (!(flags & FL_SPLAT)) {
338                    sarg = va_arg(ap, char *);
339                  }
340                  unsigned length = 0;
341                  while (width--) {
342                    q = fgetc(stream);
343                    if ((isascii(q) && isspace(q)) || (q <= 0)) {
344                      ungetc(q, stream);
345                      break;
346                    }
347                    if (!(flags & FL_SPLAT)) {
348                      sarg[length] = q;
349                    }
350                    length++;
351                  }
352                  if (length == 0) {
353                    bail = BAIL_EOF;
354                  } else if (!(flags & FL_SPLAT)) {
355                    sarg[length] = '\0'; 
356                    converted++;
357                  }
358                } break;
359                case '[': 
360                  sarg = va_arg(ap, char *);
361                  state = ST_MATCH_INIT;
362                  matchinv = 0;
363                  memset(matchmap, 0, sizeof matchmap);
364                  break;
365                case '%': 
366                  if (fgetc(stream) != '%') {
367                    bail = BAIL_ERR;
368                  }
369                  break;
370                default:           
371                  bail = BAIL_ERR; 
372                  break;
373              }
374          }
375          break;
376        case ST_MATCH_INIT: 
377          if (ch == '^' && !(flags & FL_INV)) {
378            matchinv = 1;
379          } else {
380            SetBit(matchmap, static_cast<unsigned char>(ch));
381            state = ST_MATCH;
382          }
383          break;
384        case ST_MATCH: 
385          if (ch == ']') {
386            goto match_run;
387          } else if (ch == '-') {
388            range_start = static_cast<unsigned char>(ch);
389            state = ST_MATCH_RANGE;
390          } else {
391            SetBit(matchmap, static_cast<unsigned char>(ch));
392          }
393          break;
394        case ST_MATCH_RANGE: 
395          if (ch == ']') {
396            SetBit(matchmap, static_cast<unsigned char>('-'));
397            goto match_run;
398          } else {
399            int i;
400            for (i = range_start; i < (static_cast<unsigned char>(ch)); i++) {
401              SetBit(matchmap, i);
402            }
403            state = ST_MATCH;
404          }
405          break;
406        match_run: 
407          char *oarg = sarg;
408          while (width) {
409            q = fgetc(stream);
410            auto qc = static_cast<unsigned char>(q);
411            if (q <= 0 || !(TestBit(matchmap, qc) ^ matchinv)) {
412              ungetc(q, stream);
413              break;
414            }
415            if (!(flags & FL_SPLAT)) {
416              *sarg = q;
417            }
418            sarg++;
419          }
420          if (oarg == sarg) {
421            bail = (q <= 0) ? BAIL_EOF : BAIL_ERR;
422          } else if (!(flags & FL_SPLAT)) {
423            *sarg = '\0';
424            converted++;
425          }
426          break;
427      }
428    }
429    if (bail == BAIL_EOF && !converted) {
430      converted = -1; 
431    }
432    return converted;
433  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</div>
                </div>
                <div class="column column_space"><pre><code>80        c = fgetc(s);
81        if (c == 'x' || c == 'X') {
82          base = 16;
</pre></code></div>
                <div class="column column_space"><pre><code>80        c = fgetc(s);
81        if (c == 'x' || c == 'X') {
82          base = 16;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    