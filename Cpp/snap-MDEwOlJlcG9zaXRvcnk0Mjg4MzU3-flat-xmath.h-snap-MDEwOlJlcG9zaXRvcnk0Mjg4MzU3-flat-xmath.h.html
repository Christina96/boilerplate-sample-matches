
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 102, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</h3>
            <pre><code>1  #include "bd.h"
2  class TMath{
3  public:
4    static double E;
5    static double Pi;
6    static double LogOf2;
7    static double Inv(const double& x){IAssert(x!=0.0); return (1.0/x);}
8    static double Sqr(const double& x){return x*x;}
9    static double Sqrt(const double& x){IAssert(!(x<0.0)); return sqrt(x);}
10    static double Log(const double& Val){return log(Val);}
11    static double Log2(const double& Val){return log(Val)/LogOf2;}
12    static double Round(const double& Val){
13      return (Val>0)?floor(Val+0.5):ceil(Val-0.5);}
14    static double Round(const double & Val, int Decs){
15      const double pwr=pow(10.0, Decs); return Round(Val * pwr) / pwr;}
16    static int Fac(const int& Val){
17      if (Val<=1){return 1;} else {return Val*Fac(Val-1);}}
18    static int Choose(const int& N, const int& K){ 
19      return Fac(N)/(Fac(K)*Fac(N-K)); }
20    static uint Pow2(const int& pow){return uint(1u<<pow);}
21    static double Power(const double& Base, const double& Exponent){
22      return exp(log(Base)*Exponent);}
23    template <typename T>
24    static int Sign(const T& Val){return Val<0?-1:(Val>0?1:0);}
25    template <class T>
26    static const T& Mx(const T& LVal, const T& RVal) {
27      return LVal > RVal ? LVal : RVal;}
28    template <class T>
29    static const T& Mn(const T& LVal, const T& RVal){
30      return LVal < RVal ? LVal : RVal;}
31    template <class T>
32    static const T& Mx(const T& Val1, const T& Val2, const T& Val3) {
33      if (Val1 > Val2) {
34        if (Val1 > Val3) return Val1;
35        else return Val3;
36      } else {
37        if (Val2 > Val3) return Val2;
38        else return Val3;
39      }
40    }
41    template <class T>
42    static const T& Mn(const T& Val1, const T& Val2, const T& Val3) {
43      if(Val1 < Val2) {
44        if (Val1 < Val3) return Val1;
45        else return Val3;
46      } else {
47        if (Val2 < Val3) return Val2;
48        else return Val3;
49      }
50    }
51    template <class T>
52    static const T& Median(const T& Val1, const T& Val2, const T& Val3) {
53      if (Val1 < Val2) {
54        if (Val2 < Val3) return Val2;
55        else if (Val3 < Val1) return Val1;
56        else return Val3;
57      } else {
58        if (Val1 < Val3) return Val1;
59        else if (Val3 < Val2)  return Val2;
60        else return Val3;
61      }
62    }
63    template <class T>
64    static const T& InRange(const T& Val, const T& Mn, const T& Mx) {
65      IAssert(Mn <= Mx); return Val < Mn ? Mn : (Val > Mx ? Mx : Val);}
66    template <class T>
67    static bool IsInRange(const T& Val, const T& Mn, const T& Mx) {
68      IAssert(Mn <= Mx); return Val >= Mn && Val <= Mx;}
69    template <class T>
70    static bool IsInEps(const T& Val, const T& Eps) {
71      return Val >= -Eps && Val <= Eps;}
72  };
73  class TSpecFunc{
74  public:
75    static void GammaPSeries&bsol;*gser*/(
76     double& gamser, const double& a, const double& x, double& gln);
77    static void GammaQContFrac&bsol;*gcf*/(
78     double& gammcf, const double& a, const double& x, double& gln);
79    static double GammaQ&bsol;*gammq*/(const double& a, const double& x);
80    static double LnGamma&bsol;*gammln*/(const double& xx);
81    static double BetaCf&bsol;*betacf*/(
82     const double& a, const double& b, const double& x);
83    static double BetaI(const double& a, const double& b, const double& x);
84    static void LinearFit( 
85     const TVec<TFltPr>& XY, double& A, double& B,
86     double& SigA, double& SigB, double& Chi2, double& R2);
87    static void PowerFit( 
88     const TVec<TFltPr>& XY, double& A, double& B,
89     double& SigA, double& SigB, double& Chi2, double& R2);
90    static void LogFit( 
91     const TVec<TFltPr>& XY, double& A, double& B,
92     double& SigA, double& SigB, double& Chi2, double& R2);
93    static void ExpFit( 
94     const TVec<TFltPr>& XY, double& A, double& B,
95     double& SigA, double& SigB, double& Chi2, double& R2);
96  public:
97    static double LnComb(const int& n, const int& k);
98  public:
99    static double Entropy(const TIntV& ValV);
100    static double Entropy(const TFltV& ValV);
101    static void EntropyFracDim(const TIntV& ValV, TFltV& EntropyV);
102    static void EntropyFracDim(const TFltV& ValV, TFltV& EntropyV);
103  public:
104    static double EntropyBias(const double& B); 
105    static double GetPowerCoef(const TFltV& XValV, double MinX=-1.0); 
106    static double GetPowerCoef(const TFltPrV& XValCntV, double MinX=-1.0); 
107  };
108  ClassTPV(TMom, PMom, TMomV)
109  private:
110    TBool DefP;
111    TFltPrV ValWgtV;
112    TFlt SumW, ValSumW;
113    TInt Vals;
114    TBool UsableP;
115    TFlt UnusableVal;
116    TFlt Mn, Mx;
117    TFlt Mean, Vari, SDev, SErr;
118    TFlt Median, Quart1, Quart3;
119    TFlt Mode;
120    TFltV DecileV; 
121    TFltV PercentileV; 
122  public:
123    TMom():
124      DefP(false), ValWgtV(),
125      SumW(), ValSumW(), Vals(),
126      UsableP(false), UnusableVal(-1),
127      Mn(), Mx(),
128      Mean(), Vari(), SDev(), SErr(),
129      Median(), Quart1(), Quart3(), Mode(),
130      DecileV(), PercentileV(){}
131    TMom(const TMom& Mom):
132      DefP(Mom.DefP), ValWgtV(Mom.ValWgtV),
133      SumW(Mom.SumW), ValSumW(Mom.ValSumW), Vals(Mom.Vals),
134      UsableP(Mom.UsableP), UnusableVal(Mom.UnusableVal),
135      Mn(Mom.Mn), Mx(Mom.Mx),
136      Mean(Mom.Mean), Vari(Mom.Vari), SDev(Mom.SDev), SErr(Mom.SErr),
137      Median(Mom.Median), Quart1(Mom.Quart1), Quart3(Mom.Quart3), Mode(Mom.Mode),
138      DecileV(Mom.DecileV), PercentileV(Mom.PercentileV){}
139    static PMom New(){return PMom(new TMom());}
140    static void NewV(TMomV& MomV, const int& Moms){
141      MomV.Gen(Moms); for (int MomN=0; MomN<Moms; MomN++){MomV[MomN]=New();}}
142    static void NewVV(TVVec<PMom>& MomVV, const int& XMoms, const int& YMoms){
143      MomVV.Gen(XMoms, YMoms);
144      for (int XMomN=0; XMomN<XMoms; XMomN++){
145        for (int YMomN=0; YMomN<YMoms; YMomN++){
146          MomVV.At(XMomN, YMomN)=New();}}}
147    TMom(const TFltV& _ValV);
148    static PMom New(const TFltV& ValV){
149      return PMom(new TMom(ValV));}
150    TMom(TSIn& SIn):
151      DefP(SIn),
152      ValWgtV(SIn),
153      SumW(SIn), ValSumW(SIn), Vals(SIn),
154      UsableP(SIn), UnusableVal(SIn),
155      Mn(SIn), Mx(SIn),
156      Mean(SIn), Vari(SIn), SDev(SIn), SErr(SIn),
157      Median(SIn), Quart1(SIn), Quart3(SIn), Mode(SIn),
158      DecileV(SIn), PercentileV(SIn){}
159    static PMom Load(TSIn& SIn){return new TMom(SIn);}
160    void Save(TSOut& SOut) const {
161      DefP.Save(SOut);
162      ValWgtV.Save(SOut);
163      SumW.Save(SOut); ValSumW.Save(SOut); Vals.Save(SOut);
164      UsableP.Save(SOut); UnusableVal.Save(SOut);
165      Mn.Save(SOut); Mx.Save(SOut);
166      Mean.Save(SOut); Vari.Save(SOut); SDev.Save(SOut); SErr.Save(SOut);
167      Median.Save(SOut); Quart1.Save(SOut); Quart3.Save(SOut); Mode.Save(SOut);
168      DecileV.Save(SOut); PercentileV.Save(SOut);}
169    TMom& operator=(const TMom& Mom){
170      Assert(!DefP); DefP=Mom.DefP;
171      ValWgtV=Mom.ValWgtV;
172      SumW=Mom.SumW; ValSumW=Mom.ValSumW; Vals=Mom.Vals;
173      UsableP=Mom.UsableP; UnusableVal=Mom.UnusableVal;
174      Mn=Mom.Mn; Mx=Mom.Mx;
175      Mean=Mom.Mean; Vari=Mom.Vari; SDev=Mom.SDev; SErr=Mom.SErr;
176      Median=Mom.Median; Quart1=Mom.Quart1; Quart3=Mom.Quart3; Mode=Mom.Mode;
177      DecileV=Mom.DecileV; PercentileV=Mom.PercentileV;
178      return *this;}
179    bool operator==(const TMom& Mom) const {
180      return Vals==Mom.Vals;}
181    bool operator<(const TMom& Mom) const {
182      return Vals<Mom.Vals;}
183    void Def();
184    static void DefV(TMomV& MomV){
185      for (int MomN=0; MomN<MomV.Len(); MomN++){MomV[MomN]->Def();}}
186    static void DefVV(TVVec<PMom>& MomVV){
187      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
188        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
189          MomVV.At(XMomN, YMomN)->Def();}}}
190    bool IsDef() const {return DefP;}
191    void Add(const TFlt& Val, const TFlt& Wgt=1){Assert(!DefP);
192      ValWgtV.Add(TFltPr(Val, Wgt)); SumW+=Wgt; ValSumW+=Wgt*Val; Vals++;}
193    double GetWgt() const {return SumW;}
194    int GetVals() const {return Vals;}
195    TFlt GetVal(const int& ValN) const {IAssert(!IsDef()); return ValWgtV[ValN].Val1;}
196    bool IsUsable() const {Assert(DefP); return UsableP;}
197    static bool IsUsableV(const TMomV& MomV){
198      for (int MomN=0; MomN<MomV.Len(); MomN++){
199        if (!MomV[MomN]->IsUsable()){return false;}}
200      return true;}
201    static bool IsUsableVV(const TVVec<PMom>& MomVV){
202      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
203        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
204          if (!MomVV.At(XMomN, YMomN)->IsUsable()){return false;}}}
205      return true;}
206    double GetMn() const {Assert(DefP&&UsableP); return Mn;}
207    double GetMx() const {Assert(DefP&&UsableP); return Mx;}
208    double GetExtent() const {Assert(DefP&&UsableP); return Mx-Mn;}
209    double GetMean() const {Assert(DefP&&UsableP); return Mean;}
210    double GetVari() const {Assert(DefP&&UsableP); return Vari;}
211    double GetSDev() const {Assert(DefP&&UsableP); return SDev;}
212    double GetSErr() const {Assert(DefP&&UsableP); return SErr;}
213    double GetMedian() const {Assert(DefP&&UsableP); return Median;}
214    double GetQuart1() const {Assert(DefP&&UsableP); return Quart1;}
215    double GetQuart3() const {Assert(DefP&&UsableP); return Quart3;}
216    double GetMode() const {Assert(DefP&&UsableP); return Mode;}
217    double GetDecile(const int& DecileN) const {
218      Assert(DefP&&UsableP); return DecileV[DecileN];}
219    double GetPercentile(const int& PercentileN) const {
220      Assert(DefP&&UsableP); return PercentileV[PercentileN];}
221    double GetByNm(const TStr& MomNm) const;
222    TStr GetStrByNm(const TStr& MomNm, char* FmtStr=NULL) const;
223    TStr GetStr(const char& SepCh=' ', const char& DelimCh=':',
224     const bool& DecileP=true, const bool& PercentileP=true, const TStr& FmtStr="%g") const;
225    static TStr GetNmVStr(const TStr& VarPfx,
226     const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true);
227    TStr GetValVStr(const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true) const;
228  };
229  typedef TVVec<PMom> TMomVV;
230  typedef THash<TInt, PMom> TIntMomH;
231  typedef THash<TInt, TMomV> TIntMomVH;
232  typedef THash<TInt, TMomVV> TIntMomVVH;
233  ClassTP(TCorr, PCorr)
234  private:
235    int ValVLen;
236    double CorrCf;
237    double CorrCfPrb;
238    double FisherZ;
239  public:
240    TCorr(){}
241    TCorr(const TFltV& ValV1, const TFltV& ValV2);
242    static PCorr New(const TFltV& ValV1, const TFltV& ValV2){
243      return PCorr(new TCorr(ValV1, ValV2));}
244    TCorr(TSIn&){Fail;}
245    static PCorr Load(TSIn& SIn){return new TCorr(SIn);}
246    void Save(TSOut&){Fail;}
247    TCorr& operator=(const TCorr&){Fail; return *this;}
248    double GetCorrCf() const {return CorrCf;}
249    double GetCorrCfPrb() const {return CorrCfPrb;}
250    TStr GetStr() const;
251  };
252  class TStatTest {
253  private:
254    static void AveVar(const TFltV& ValV, double& Ave, double& Var);
255    static double KsProb(const double& Alam);
256  public:
257    static void ChiSquareOne(
258     const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
259     double& ChiSquareVal, double& SignificancePrb);
260    static void ChiSquareTwo(
261     const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
262     double& ChiSquareVal, double& SignificancePrb);
263    static void TTest(
264     const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb);
265    static void KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal);
266    static void KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal);
267  };
268  ClassTP(TComb, PComb)
269  public:
270    int Items;
271    int Order;
272    int CombN;
273    TIntV ItemV;
274  public:
275    TComb(): Items(-1), Order(-1), CombN(-1), ItemV(){}
276    TComb(const int& _Items, const int& _Order):
277      Items(_Items), Order(_Order), CombN(0), ItemV(){
278      IAssert((Order>0)&&(Order<=Items));}
279    static PComb New(const int& Items, const int& Order){
280      return PComb(new TComb(Items, Order));}
281    ~TComb(){}
282    TComb(TSIn&){Fail;}
283    static PComb Load(TSIn& SIn){return new TComb(SIn);}
284    void Save(TSOut&){Fail;}
285    TComb& operator=(const TComb&){Fail; return *this;}
286    bool GetNext();
287    TIntV& GetItemV(){return ItemV;}
288    int GetCombN() const {return CombN;}
289    int GetCombs() const;
290    void Wr();
291  };
292  ClassTP(TLinReg, PLinReg)
293  public:
294    TFltVV XVV;
295    TFltV YV;
296    TFltV SigV;
297    int Recs, Vars;
<span onclick='openModal()' class='match'>298    TFltVV CovarVV; 
299    TFltV CfV; 
300    double ChiSq;
301    void GetXV(const int RecN, TFltV& VarV) const {
302      VarV.Gen(Vars+1);
303      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
304    }
305    double GetY(const int RecN) const {return YV[RecN-1];}
306    double GetSig(const int RecN) const {return SigV[RecN-1];}
307    void NR_covsrt(TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit);
</span>308    void NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m);
309    void NR_lfit();
310  public:
311    TLinReg(){}
312    static PLinReg New(
313     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
314    ~TLinReg(){}
315    TLinReg(TSIn&){Fail;}
316    static PLinReg Load(TSIn& SIn){return new TLinReg(SIn);}
317    void Save(TSOut&){Fail;}
318    TLinReg& operator=(const TLinReg&){Fail; return *this;}
319    int GetRecs() const {return Recs;}
320    int GetVars() const {return Vars;}
321    double GetCf(const int& VarN) const {return CfV[VarN+1];}
322    double GetCfUncer(const int& VarN) const {
323      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
324    double GetCovar(const int& VarN1, const int& VarN2) const {
325      return CovarVV.At(VarN1+1, VarN2+1);}
326    double GetChiSq() const {return ChiSq;}
327    static double LinInterp(const double& x1, const double& y1,
328     const double& x2, const double& y2, const double& AtX) _CMPWARN{
329      if (x1 == x2) return (y1+y2)/2.0;
330      const double k = (y2 - y1) / (x2 - x1);
331      return k*(AtX - x1) + y1;
332    }
333    void Wr() const;
334  };
335  ClassTP(TSvd, PSvd)
336  public:
337    TFltVV XVV;
338    TFltV YV;
339    TFltV SigV;
340    int Recs, Vars;
341    TFltVV CovarVV; 
342    TFltV CfV; 
343    double ChiSq;
344    void GetXV(const int RecN, TFltV& VarV) const {
345      VarV.Gen(Vars+1);
346      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
347    }
348    double GetY(const int RecN) const {return YV[RecN-1];}
349    double GetSig(const int RecN) const {return SigV[RecN-1];}
350    static double NR_SIGN(double a, double b){return b >= 0.0 ? fabs(a) : -fabs(a);}
351    static double NR_FMAX(double maxarg1, double maxarg2){
352      return maxarg1 > maxarg2 ? maxarg1 : maxarg2;}
353    static int NR_IMIN(int iminarg1, int iminarg2){
354      return iminarg1 < iminarg2 ? iminarg1 : iminarg2;}
355    static double NR_pythag(double a, double b);
356    static void NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v);
357    void NR_svbksb(
358     TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x);
359    void NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm);
360    void NR_svdfit();
361  public:
362    TSvd(){}
363    static PSvd New(
364     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
365    ~TSvd(){}
366    TSvd(TSIn&){Fail;}
367    static PSvd Load(TSIn& SIn){return new TSvd(SIn);}
368    void Save(TSOut&){Fail;}
369    TSvd& operator=(const TSvd&){Fail; return *this;}
370    int GetRecs() const {return Recs;}
371    int GetVars() const {return Vars;}
372    double GetCf(const int& VarN) const {return CfV[VarN+1];}
373    double GetCfUncer(const int& VarN) const {
374      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
375    double GetCovar(const int& VarN1, const int& VarN2) const {
376      return CovarVV.At(VarN1+1, VarN2+1);}
377    double GetChiSq() const {return ChiSq;}
378    void GetCfV(TFltV& _CfV);
379    void GetCfUncerV(TFltV& CfUncerV);
380    static void Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
381    static void Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
382    void Wr() const;
383  };
384  class THist {
385  private:
386  	TFlt MnVal;
387  	TFlt MxVal;
388      TIntV BucketV;
389  	TFlt BucketSize;
390      TInt Vals;
391  public:
392      THist() { }
393      THist(const double& _MnVal, const double& _MxVal, const int& Buckets):
394        MnVal(_MnVal), MxVal(_MxVal), BucketV(Buckets) {
395        BucketSize = (MxVal == MnVal) ? 1.0 : (1.01 * double(MxVal - MnVal) / double(Buckets)); }
396      void Add(const double& Val, const bool& OnlyInP);
397  	int GetVals() const { return Vals; }
398  	int GetBuckets() const { return BucketV.Len(); }
399  	double GetBucketMn(const int& BucketN) const { return MnVal + BucketN * BucketSize; }
400  	double GetBucketMx(const int& BucketN) const { return MnVal + (BucketN + 1) * BucketSize; }
401  	int GetBucketVal(const int& BucketN) const { return BucketV[BucketN]; }
402  	double GetBucketValPerc(const int& BucketN) const { 
403  		return (Vals > 0) ? (double(BucketV[BucketN]) / double(Vals)) : 0.0; }
404      void SaveStat(const TStr& ValNm, TSOut& FOut) const;
405      void SaveTxt(const TStr& ValNm, const TStr& FNm) const {
406          TFOut FOut(FNm); SaveStat(ValNm, FOut); }
407  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</h3>
            <pre><code>1  #include "bd.h"
2  class TMath{
3  public:
4    static double E;
5    static double Pi;
6    static double LogOf2;
7    static double Inv(const double& x){IAssert(x!=0.0); return (1.0/x);}
8    static double Sqr(const double& x){return x*x;}
9    static double Sqrt(const double& x){IAssert(!(x<0.0)); return sqrt(x);}
10    static double Log(const double& Val){return log(Val);}
11    static double Log2(const double& Val){return log(Val)/LogOf2;}
12    static double Round(const double& Val){
13      return (Val>0)?floor(Val+0.5):ceil(Val-0.5);}
14    static double Round(const double & Val, int Decs){
15      const double pwr=pow(10.0, Decs); return Round(Val * pwr) / pwr;}
16    static int Fac(const int& Val){
17      if (Val<=1){return 1;} else {return Val*Fac(Val-1);}}
18    static int Choose(const int& N, const int& K){ 
19      return Fac(N)/(Fac(K)*Fac(N-K)); }
20    static uint Pow2(const int& pow){return uint(1u<<pow);}
21    static double Power(const double& Base, const double& Exponent){
22      return exp(log(Base)*Exponent);}
23    template <typename T>
24    static int Sign(const T& Val){return Val<0?-1:(Val>0?1:0);}
25    template <class T>
26    static const T& Mx(const T& LVal, const T& RVal) {
27      return LVal > RVal ? LVal : RVal;}
28    template <class T>
29    static const T& Mn(const T& LVal, const T& RVal){
30      return LVal < RVal ? LVal : RVal;}
31    template <class T>
32    static const T& Mx(const T& Val1, const T& Val2, const T& Val3) {
33      if (Val1 > Val2) {
34        if (Val1 > Val3) return Val1;
35        else return Val3;
36      } else {
37        if (Val2 > Val3) return Val2;
38        else return Val3;
39      }
40    }
41    template <class T>
42    static const T& Mn(const T& Val1, const T& Val2, const T& Val3) {
43      if(Val1 < Val2) {
44        if (Val1 < Val3) return Val1;
45        else return Val3;
46      } else {
47        if (Val2 < Val3) return Val2;
48        else return Val3;
49      }
50    }
51    template <class T>
52    static const T& Median(const T& Val1, const T& Val2, const T& Val3) {
53      if (Val1 < Val2) {
54        if (Val2 < Val3) return Val2;
55        else if (Val3 < Val1) return Val1;
56        else return Val3;
57      } else {
58        if (Val1 < Val3) return Val1;
59        else if (Val3 < Val2)  return Val2;
60        else return Val3;
61      }
62    }
63    template <class T>
64    static const T& InRange(const T& Val, const T& Mn, const T& Mx) {
65      IAssert(Mn <= Mx); return Val < Mn ? Mn : (Val > Mx ? Mx : Val);}
66    template <class T>
67    static bool IsInRange(const T& Val, const T& Mn, const T& Mx) {
68      IAssert(Mn <= Mx); return Val >= Mn && Val <= Mx;}
69    template <class T>
70    static bool IsInEps(const T& Val, const T& Eps) {
71      return Val >= -Eps && Val <= Eps;}
72  };
73  class TSpecFunc{
74  public:
75    static void GammaPSeries&bsol;*gser*/(
76     double& gamser, const double& a, const double& x, double& gln);
77    static void GammaQContFrac&bsol;*gcf*/(
78     double& gammcf, const double& a, const double& x, double& gln);
79    static double GammaQ&bsol;*gammq*/(const double& a, const double& x);
80    static double LnGamma&bsol;*gammln*/(const double& xx);
81    static double BetaCf&bsol;*betacf*/(
82     const double& a, const double& b, const double& x);
83    static double BetaI(const double& a, const double& b, const double& x);
84    static void LinearFit( 
85     const TVec<TFltPr>& XY, double& A, double& B,
86     double& SigA, double& SigB, double& Chi2, double& R2);
87    static void PowerFit( 
88     const TVec<TFltPr>& XY, double& A, double& B,
89     double& SigA, double& SigB, double& Chi2, double& R2);
90    static void LogFit( 
91     const TVec<TFltPr>& XY, double& A, double& B,
92     double& SigA, double& SigB, double& Chi2, double& R2);
93    static void ExpFit( 
94     const TVec<TFltPr>& XY, double& A, double& B,
95     double& SigA, double& SigB, double& Chi2, double& R2);
96  public:
97    static double LnComb(const int& n, const int& k);
98  public:
99    static double Entropy(const TIntV& ValV);
100    static double Entropy(const TFltV& ValV);
101    static void EntropyFracDim(const TIntV& ValV, TFltV& EntropyV);
102    static void EntropyFracDim(const TFltV& ValV, TFltV& EntropyV);
103  public:
104    static double EntropyBias(const double& B); 
105    static double GetPowerCoef(const TFltV& XValV, double MinX=-1.0); 
106    static double GetPowerCoef(const TFltPrV& XValCntV, double MinX=-1.0); 
107  };
108  ClassTPV(TMom, PMom, TMomV)
109  private:
110    TBool DefP;
111    TFltPrV ValWgtV;
112    TFlt SumW, ValSumW;
113    TInt Vals;
114    TBool UsableP;
115    TFlt UnusableVal;
116    TFlt Mn, Mx;
117    TFlt Mean, Vari, SDev, SErr;
118    TFlt Median, Quart1, Quart3;
119    TFlt Mode;
120    TFltV DecileV; 
121    TFltV PercentileV; 
122  public:
123    TMom():
124      DefP(false), ValWgtV(),
125      SumW(), ValSumW(), Vals(),
126      UsableP(false), UnusableVal(-1),
127      Mn(), Mx(),
128      Mean(), Vari(), SDev(), SErr(),
129      Median(), Quart1(), Quart3(), Mode(),
130      DecileV(), PercentileV(){}
131    TMom(const TMom& Mom):
132      DefP(Mom.DefP), ValWgtV(Mom.ValWgtV),
133      SumW(Mom.SumW), ValSumW(Mom.ValSumW), Vals(Mom.Vals),
134      UsableP(Mom.UsableP), UnusableVal(Mom.UnusableVal),
135      Mn(Mom.Mn), Mx(Mom.Mx),
136      Mean(Mom.Mean), Vari(Mom.Vari), SDev(Mom.SDev), SErr(Mom.SErr),
137      Median(Mom.Median), Quart1(Mom.Quart1), Quart3(Mom.Quart3), Mode(Mom.Mode),
138      DecileV(Mom.DecileV), PercentileV(Mom.PercentileV){}
139    static PMom New(){return PMom(new TMom());}
140    static void NewV(TMomV& MomV, const int& Moms){
141      MomV.Gen(Moms); for (int MomN=0; MomN<Moms; MomN++){MomV[MomN]=New();}}
142    static void NewVV(TVVec<PMom>& MomVV, const int& XMoms, const int& YMoms){
143      MomVV.Gen(XMoms, YMoms);
144      for (int XMomN=0; XMomN<XMoms; XMomN++){
145        for (int YMomN=0; YMomN<YMoms; YMomN++){
146          MomVV.At(XMomN, YMomN)=New();}}}
147    TMom(const TFltV& _ValV);
148    static PMom New(const TFltV& ValV){
149      return PMom(new TMom(ValV));}
150    TMom(TSIn& SIn):
151      DefP(SIn),
152      ValWgtV(SIn),
153      SumW(SIn), ValSumW(SIn), Vals(SIn),
154      UsableP(SIn), UnusableVal(SIn),
155      Mn(SIn), Mx(SIn),
156      Mean(SIn), Vari(SIn), SDev(SIn), SErr(SIn),
157      Median(SIn), Quart1(SIn), Quart3(SIn), Mode(SIn),
158      DecileV(SIn), PercentileV(SIn){}
159    static PMom Load(TSIn& SIn){return new TMom(SIn);}
160    void Save(TSOut& SOut) const {
161      DefP.Save(SOut);
162      ValWgtV.Save(SOut);
163      SumW.Save(SOut); ValSumW.Save(SOut); Vals.Save(SOut);
164      UsableP.Save(SOut); UnusableVal.Save(SOut);
165      Mn.Save(SOut); Mx.Save(SOut);
166      Mean.Save(SOut); Vari.Save(SOut); SDev.Save(SOut); SErr.Save(SOut);
167      Median.Save(SOut); Quart1.Save(SOut); Quart3.Save(SOut); Mode.Save(SOut);
168      DecileV.Save(SOut); PercentileV.Save(SOut);}
169    TMom& operator=(const TMom& Mom){
170      Assert(!DefP); DefP=Mom.DefP;
171      ValWgtV=Mom.ValWgtV;
172      SumW=Mom.SumW; ValSumW=Mom.ValSumW; Vals=Mom.Vals;
173      UsableP=Mom.UsableP; UnusableVal=Mom.UnusableVal;
174      Mn=Mom.Mn; Mx=Mom.Mx;
175      Mean=Mom.Mean; Vari=Mom.Vari; SDev=Mom.SDev; SErr=Mom.SErr;
176      Median=Mom.Median; Quart1=Mom.Quart1; Quart3=Mom.Quart3; Mode=Mom.Mode;
177      DecileV=Mom.DecileV; PercentileV=Mom.PercentileV;
178      return *this;}
179    bool operator==(const TMom& Mom) const {
180      return Vals==Mom.Vals;}
181    bool operator<(const TMom& Mom) const {
182      return Vals<Mom.Vals;}
183    void Def();
184    static void DefV(TMomV& MomV){
185      for (int MomN=0; MomN<MomV.Len(); MomN++){MomV[MomN]->Def();}}
186    static void DefVV(TVVec<PMom>& MomVV){
187      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
188        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
189          MomVV.At(XMomN, YMomN)->Def();}}}
190    bool IsDef() const {return DefP;}
191    void Add(const TFlt& Val, const TFlt& Wgt=1){Assert(!DefP);
192      ValWgtV.Add(TFltPr(Val, Wgt)); SumW+=Wgt; ValSumW+=Wgt*Val; Vals++;}
193    double GetWgt() const {return SumW;}
194    int GetVals() const {return Vals;}
195    TFlt GetVal(const int& ValN) const {IAssert(!IsDef()); return ValWgtV[ValN].Val1;}
196    bool IsUsable() const {Assert(DefP); return UsableP;}
197    static bool IsUsableV(const TMomV& MomV){
198      for (int MomN=0; MomN<MomV.Len(); MomN++){
199        if (!MomV[MomN]->IsUsable()){return false;}}
200      return true;}
201    static bool IsUsableVV(const TVVec<PMom>& MomVV){
202      for (int XMomN=0; XMomN<MomVV.GetXDim(); XMomN++){
203        for (int YMomN=0; YMomN<MomVV.GetYDim(); YMomN++){
204          if (!MomVV.At(XMomN, YMomN)->IsUsable()){return false;}}}
205      return true;}
206    double GetMn() const {Assert(DefP&&UsableP); return Mn;}
207    double GetMx() const {Assert(DefP&&UsableP); return Mx;}
208    double GetExtent() const {Assert(DefP&&UsableP); return Mx-Mn;}
209    double GetMean() const {Assert(DefP&&UsableP); return Mean;}
210    double GetVari() const {Assert(DefP&&UsableP); return Vari;}
211    double GetSDev() const {Assert(DefP&&UsableP); return SDev;}
212    double GetSErr() const {Assert(DefP&&UsableP); return SErr;}
213    double GetMedian() const {Assert(DefP&&UsableP); return Median;}
214    double GetQuart1() const {Assert(DefP&&UsableP); return Quart1;}
215    double GetQuart3() const {Assert(DefP&&UsableP); return Quart3;}
216    double GetMode() const {Assert(DefP&&UsableP); return Mode;}
217    double GetDecile(const int& DecileN) const {
218      Assert(DefP&&UsableP); return DecileV[DecileN];}
219    double GetPercentile(const int& PercentileN) const {
220      Assert(DefP&&UsableP); return PercentileV[PercentileN];}
221    double GetByNm(const TStr& MomNm) const;
222    TStr GetStrByNm(const TStr& MomNm, char* FmtStr=NULL) const;
223    TStr GetStr(const char& SepCh=' ', const char& DelimCh=':',
224     const bool& DecileP=true, const bool& PercentileP=true, const TStr& FmtStr="%g") const;
225    static TStr GetNmVStr(const TStr& VarPfx,
226     const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true);
227    TStr GetValVStr(const char& SepCh='\t', const bool& DecileP=true, const bool& PercentileP=true) const;
228  };
229  typedef TVVec<PMom> TMomVV;
230  typedef THash<TInt, PMom> TIntMomH;
231  typedef THash<TInt, TMomV> TIntMomVH;
232  typedef THash<TInt, TMomVV> TIntMomVVH;
233  ClassTP(TCorr, PCorr)
234  private:
235    int ValVLen;
236    double CorrCf;
237    double CorrCfPrb;
238    double FisherZ;
239  public:
240    TCorr(){}
241    TCorr(const TFltV& ValV1, const TFltV& ValV2);
242    static PCorr New(const TFltV& ValV1, const TFltV& ValV2){
243      return PCorr(new TCorr(ValV1, ValV2));}
244    TCorr(TSIn&){Fail;}
245    static PCorr Load(TSIn& SIn){return new TCorr(SIn);}
246    void Save(TSOut&){Fail;}
247    TCorr& operator=(const TCorr&){Fail; return *this;}
248    double GetCorrCf() const {return CorrCf;}
249    double GetCorrCfPrb() const {return CorrCfPrb;}
250    TStr GetStr() const;
251  };
252  class TStatTest {
253  private:
254    static void AveVar(const TFltV& ValV, double& Ave, double& Var);
255    static double KsProb(const double& Alam);
256  public:
257    static void ChiSquareOne(
258     const TFltV& ObservedBinV, const TFltV& ExpectedBinV,
259     double& ChiSquareVal, double& SignificancePrb);
260    static void ChiSquareTwo(
261     const TFltV& ObservedBin1V, const TFltV& ObservedBin2V,
262     double& ChiSquareVal, double& SignificancePrb);
263    static void TTest(
264     const TFltV& ValV1, const TFltV& ValV2, double& TTestVal, double& TTestPrb);
265    static void KsTest(const TFltV& ValV1, const TFltV& ValV2, double& DStat, double& PVal);
266    static void KsTest(const TFltPrV& ValCntV1, const TFltPrV& ValCntV2, double& DStat, double& PVal);
267  };
268  ClassTP(TComb, PComb)
269  public:
270    int Items;
271    int Order;
272    int CombN;
273    TIntV ItemV;
274  public:
275    TComb(): Items(-1), Order(-1), CombN(-1), ItemV(){}
276    TComb(const int& _Items, const int& _Order):
277      Items(_Items), Order(_Order), CombN(0), ItemV(){
278      IAssert((Order>0)&&(Order<=Items));}
279    static PComb New(const int& Items, const int& Order){
280      return PComb(new TComb(Items, Order));}
281    ~TComb(){}
282    TComb(TSIn&){Fail;}
283    static PComb Load(TSIn& SIn){return new TComb(SIn);}
284    void Save(TSOut&){Fail;}
285    TComb& operator=(const TComb&){Fail; return *this;}
286    bool GetNext();
287    TIntV& GetItemV(){return ItemV;}
288    int GetCombN() const {return CombN;}
289    int GetCombs() const;
290    void Wr();
291  };
292  ClassTP(TLinReg, PLinReg)
293  public:
294    TFltVV XVV;
295    TFltV YV;
296    TFltV SigV;
297    int Recs, Vars;
298    TFltVV CovarVV; 
299    TFltV CfV; 
300    double ChiSq;
301    void GetXV(const int RecN, TFltV& VarV) const {
302      VarV.Gen(Vars+1);
303      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
304    }
305    double GetY(const int RecN) const {return YV[RecN-1];}
306    double GetSig(const int RecN) const {return SigV[RecN-1];}
307    void NR_covsrt(TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit);
308    void NR_gaussj(TFltVV& a, const int& n, TFltVV& b, const int& m);
309    void NR_lfit();
310  public:
311    TLinReg(){}
312    static PLinReg New(
313     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
314    ~TLinReg(){}
315    TLinReg(TSIn&){Fail;}
316    static PLinReg Load(TSIn& SIn){return new TLinReg(SIn);}
317    void Save(TSOut&){Fail;}
318    TLinReg& operator=(const TLinReg&){Fail; return *this;}
319    int GetRecs() const {return Recs;}
320    int GetVars() const {return Vars;}
321    double GetCf(const int& VarN) const {return CfV[VarN+1];}
322    double GetCfUncer(const int& VarN) const {
323      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
324    double GetCovar(const int& VarN1, const int& VarN2) const {
325      return CovarVV.At(VarN1+1, VarN2+1);}
326    double GetChiSq() const {return ChiSq;}
327    static double LinInterp(const double& x1, const double& y1,
328     const double& x2, const double& y2, const double& AtX) _CMPWARN{
329      if (x1 == x2) return (y1+y2)/2.0;
330      const double k = (y2 - y1) / (x2 - x1);
331      return k*(AtX - x1) + y1;
332    }
333    void Wr() const;
334  };
335  ClassTP(TSvd, PSvd)
336  public:
337    TFltVV XVV;
338    TFltV YV;
339    TFltV SigV;
340    int Recs, Vars;
<span onclick='openModal()' class='match'>341    TFltVV CovarVV; 
342    TFltV CfV; 
343    double ChiSq;
344    void GetXV(const int RecN, TFltV& VarV) const {
345      VarV.Gen(Vars+1);
346      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
347    }
348    double GetY(const int RecN) const {return YV[RecN-1];}
349    double GetSig(const int RecN) const {return SigV[RecN-1];}
350    static double NR_SIGN(double a, double b){return b >= 0.0 ? fabs(a) : -fabs(a);}
</span>351    static double NR_FMAX(double maxarg1, double maxarg2){
352      return maxarg1 > maxarg2 ? maxarg1 : maxarg2;}
353    static int NR_IMIN(int iminarg1, int iminarg2){
354      return iminarg1 < iminarg2 ? iminarg1 : iminarg2;}
355    static double NR_pythag(double a, double b);
356    static void NR_svdcmp(TFltVV& a, int m, int n, TFltV& w, TFltVV& v);
357    void NR_svbksb(
358     TFltVV& u, TFltV& w, TFltVV& v, int m, int n, TFltV& b, TFltV& x);
359    void NR_svdvar(TFltVV& v, int ma, TFltV& w, TFltVV& cvm);
360    void NR_svdfit();
361  public:
362    TSvd(){}
363    static PSvd New(
364     const TFltVV& XVV, const TFltV& YV, const TFltV& SigV=TFltV());
365    ~TSvd(){}
366    TSvd(TSIn&){Fail;}
367    static PSvd Load(TSIn& SIn){return new TSvd(SIn);}
368    void Save(TSOut&){Fail;}
369    TSvd& operator=(const TSvd&){Fail; return *this;}
370    int GetRecs() const {return Recs;}
371    int GetVars() const {return Vars;}
372    double GetCf(const int& VarN) const {return CfV[VarN+1];}
373    double GetCfUncer(const int& VarN) const {
374      return sqrt(double(CovarVV.At(VarN+1, VarN+1)));}
375    double GetCovar(const int& VarN1, const int& VarN2) const {
376      return CovarVV.At(VarN1+1, VarN2+1);}
377    double GetChiSq() const {return ChiSq;}
378    void GetCfV(TFltV& _CfV);
379    void GetCfUncerV(TFltV& CfUncerV);
380    static void Svd(const TFltVV& InMtx, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
381    static void Svd1Based(const TFltVV& InMtx1, TFltVV& LSingV, TFltV& SingValV, TFltVV& RSingV);
382    void Wr() const;
383  };
384  class THist {
385  private:
386  	TFlt MnVal;
387  	TFlt MxVal;
388      TIntV BucketV;
389  	TFlt BucketSize;
390      TInt Vals;
391  public:
392      THist() { }
393      THist(const double& _MnVal, const double& _MxVal, const int& Buckets):
394        MnVal(_MnVal), MxVal(_MxVal), BucketV(Buckets) {
395        BucketSize = (MxVal == MnVal) ? 1.0 : (1.01 * double(MxVal - MnVal) / double(Buckets)); }
396      void Add(const double& Val, const bool& OnlyInP);
397  	int GetVals() const { return Vals; }
398  	int GetBuckets() const { return BucketV.Len(); }
399  	double GetBucketMn(const int& BucketN) const { return MnVal + BucketN * BucketSize; }
400  	double GetBucketMx(const int& BucketN) const { return MnVal + (BucketN + 1) * BucketSize; }
401  	int GetBucketVal(const int& BucketN) const { return BucketV[BucketN]; }
402  	double GetBucketValPerc(const int& BucketN) const { 
403  		return (Vals > 0) ? (double(BucketV[BucketN]) / double(Vals)) : 0.0; }
404      void SaveStat(const TStr& ValNm, TSOut& FOut) const;
405      void SaveTxt(const TStr& ValNm, const TStr& FNm) const {
406          TFOut FOut(FNm); SaveStat(ValNm, FOut); }
407  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmath.h</div>
                </div>
                <div class="column column_space"><pre><code>298    TFltVV CovarVV; 
299    TFltV CfV; 
300    double ChiSq;
301    void GetXV(const int RecN, TFltV& VarV) const {
302      VarV.Gen(Vars+1);
303      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
304    }
305    double GetY(const int RecN) const {return YV[RecN-1];}
306    double GetSig(const int RecN) const {return SigV[RecN-1];}
307    void NR_covsrt(TFltVV& CovarVV, const int& Vars, const TIntV& ia, const int& mfit);
</pre></code></div>
                <div class="column column_space"><pre><code>341    TFltVV CovarVV; 
342    TFltV CfV; 
343    double ChiSq;
344    void GetXV(const int RecN, TFltV& VarV) const {
345      VarV.Gen(Vars+1);
346      for (int VarN=0; VarN<Vars; VarN++){VarV[VarN+1]=XVV.At(RecN-1, VarN);}
347    }
348    double GetY(const int RecN) const {return YV[RecN-1];}
349    double GetSig(const int RecN) const {return SigV[RecN-1];}
350    static double NR_SIGN(double a, double b){return b >= 0.0 ? fabs(a) : -fabs(a);}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    