
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 48, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-c_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_C_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_C_REGEX_TRAITS_HPP_INCLUDED
3  #include <boost/regex/config.hpp>
4  #include <boost/regex/v5/regex_workaround.hpp>
5  #include <cctype>
6  namespace boost{
7     namespace BOOST_REGEX_DETAIL_NS {
8        enum
9        {
10           char_class_space = 1 << 0,
11           char_class_print = 1 << 1,
12           char_class_cntrl = 1 << 2,
13           char_class_upper = 1 << 3,
14           char_class_lower = 1 << 4,
15           char_class_alpha = 1 << 5,
16           char_class_digit = 1 << 6,
17           char_class_punct = 1 << 7,
18           char_class_xdigit = 1 << 8,
19           char_class_alnum = char_class_alpha | char_class_digit,
20           char_class_graph = char_class_alnum | char_class_punct,
21           char_class_blank = 1 << 9,
22           char_class_word = 1 << 10,
23           char_class_unicode = 1 << 11,
24           char_class_horizontal = 1 << 12,
25           char_class_vertical = 1 << 13
26        };
27     }
28  template <class charT>
29  struct c_regex_traits;
30  template<>
31  struct c_regex_traits<char>
32  {
33     c_regex_traits(){}
34     typedef char char_type;
35     typedef std::size_t size_type;
36     typedef std::string string_type;
37     struct locale_type{};
38     typedef std::uint32_t char_class_type;
39     static size_type length(const char_type* p) 
40     { 
41        return (std::strlen)(p); 
42     }
43     char translate(char c) const 
44     { 
45        return c; 
46     }
47     char translate_nocase(char c) const 
48     { 
49        return static_cast<char>((std::tolower)(static_cast<unsigned char>(c))); 
50     }
51     static string_type  transform(const char* p1, const char* p2);
52     static string_type  transform_primary(const char* p1, const char* p2);
53     static char_class_type  lookup_classname(const char* p1, const char* p2);
54     static string_type  lookup_collatename(const char* p1, const char* p2);
55     static bool  isctype(char, char_class_type);
56     static int  value(char, int);
57     locale_type imbue(locale_type l)
58     { return l; }
59     locale_type getloc()const
60     { return locale_type(); }
61  private:
62     c_regex_traits(const c_regex_traits&);
63     c_regex_traits& operator=(const c_regex_traits&);
64  };
65  #ifndef BOOST_NO_WREGEX
66  template<>
67  struct c_regex_traits<wchar_t>
68  {
69     c_regex_traits(){}
70     typedef wchar_t char_type;
71     typedef std::size_t size_type;
72     typedef std::wstring string_type;
73     struct locale_type{};
74     typedef std::uint32_t char_class_type;
75     static size_type length(const char_type* p) 
76     { 
77        return (std::wcslen)(p); 
78     }
79     wchar_t translate(wchar_t c) const 
80     { 
81        return c; 
82     }
83     wchar_t translate_nocase(wchar_t c) const 
84     { 
85        return (std::towlower)(c); 
86     }
87     static string_type  transform(const wchar_t* p1, const wchar_t* p2);
88     static string_type  transform_primary(const wchar_t* p1, const wchar_t* p2);
89     static char_class_type  lookup_classname(const wchar_t* p1, const wchar_t* p2);
90     static string_type  lookup_collatename(const wchar_t* p1, const wchar_t* p2);
91     static bool  isctype(wchar_t, char_class_type);
92     static int  value(wchar_t, int);
93     locale_type imbue(locale_type l)
94     { return l; }
95     locale_type getloc()const
96     { return locale_type(); }
97  private:
98     c_regex_traits(const c_regex_traits&);
99     c_regex_traits& operator=(const c_regex_traits&);
100  };
101  #endif 
102  inline c_regex_traits<char>::string_type  c_regex_traits<char>::transform(const char* p1, const char* p2)
103  {
104     std::string result(10, ' ');
105     std::size_t s = result.size();
106     std::size_t r;
107     std::string src(p1, p2);
108     while (s < (r = std::strxfrm(&*result.begin(), src.c_str(), s)))
109     {
110  #if defined(_CPPLIB_VER)
111        if (r == INT_MAX)
112        {
113           result.erase();
114           result.insert(result.begin(), static_cast<char>(0));
115           return result;
116        }
117  #endif
118        result.append(r - s + 3, ' ');
119        s = result.size();
120     }
121     result.erase(r);
122     return result;
123  }
124  inline c_regex_traits<char>::string_type  c_regex_traits<char>::transform_primary(const char* p1, const char* p2)
125  {
126     static char s_delim;
127     static const int s_collate_type = ::boost::BOOST_REGEX_DETAIL_NS::find_sort_syntax(static_cast<c_regex_traits<char>*>(0), &s_delim);
128     std::string result;
129     switch (s_collate_type)
130     {
131     case ::boost::BOOST_REGEX_DETAIL_NS::sort_C:
132     case ::boost::BOOST_REGEX_DETAIL_NS::sort_unknown:
133     {
134        result.assign(p1, p2);
135        for (std::string::size_type i = 0; i < result.size(); ++i)
136           result[i] = static_cast<char>((std::tolower)(static_cast<unsigned char>(result[i])));
137        result = transform(&*result.begin(), &*result.begin() + result.size());
138        break;
139     }
140     case ::boost::BOOST_REGEX_DETAIL_NS::sort_fixed:
141     {
142        result = transform(p1, p2);
143        result.erase(s_delim);
144        break;
145     }
146     case ::boost::BOOST_REGEX_DETAIL_NS::sort_delim:
147        result = transform(p1, p2);
148        if ((!result.empty()) && (result[0] == s_delim))
149           break;
150        std::size_t i;
151        for (i = 0; i < result.size(); ++i)
152        {
153           if (result[i] == s_delim)
154              break;
155        }
156        result.erase(i);
157        break;
158     }
159     if (result.empty())
160        result = std::string(1, char(0));
161     return result;
162  }
163  inline c_regex_traits<char>::char_class_type  c_regex_traits<char>::lookup_classname(const char* p1, const char* p2)
164  {
165     using namespace BOOST_REGEX_DETAIL_NS;
166     static const char_class_type masks[] =
167     {
168        0,
169        char_class_alnum,
170        char_class_alpha,
171        char_class_blank,
172        char_class_cntrl,
173        char_class_digit,
174        char_class_digit,
175        char_class_graph,
176        char_class_horizontal,
177        char_class_lower,
178        char_class_lower,
179        char_class_print,
180        char_class_punct,
181        char_class_space,
182        char_class_space,
183        char_class_upper,
184        char_class_unicode,
185        char_class_upper,
186        char_class_vertical,
187        char_class_alnum | char_class_word,
188        char_class_alnum | char_class_word,
189        char_class_xdigit,
190     };
191     int idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
192     if (idx < 0)
193     {
194        std::string s(p1, p2);
195        for (std::string::size_type i = 0; i < s.size(); ++i)
196           s[i] = static_cast<char>((std::tolower)(static_cast<unsigned char>(s[i])));
197        idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(&*s.begin(), &*s.begin() + s.size());
198     }
199     BOOST_REGEX_ASSERT(std::size_t(idx) + 1u < sizeof(masks) / sizeof(masks[0]));
200     return masks[idx + 1];
201  }
202  inline bool  c_regex_traits<char>::isctype(char c, char_class_type mask)
203  {
204     using namespace BOOST_REGEX_DETAIL_NS;
205     return
206        ((mask & char_class_space) && (std::isspace)(static_cast<unsigned char>(c)))
207        || ((mask & char_class_print) && (std::isprint)(static_cast<unsigned char>(c)))
208        || ((mask & char_class_cntrl) && (std::iscntrl)(static_cast<unsigned char>(c)))
209        || ((mask & char_class_upper) && (std::isupper)(static_cast<unsigned char>(c)))
210        || ((mask & char_class_lower) && (std::islower)(static_cast<unsigned char>(c)))
211        || ((mask & char_class_alpha) && (std::isalpha)(static_cast<unsigned char>(c)))
212        || ((mask & char_class_digit) && (std::isdigit)(static_cast<unsigned char>(c)))
213        || ((mask & char_class_punct) && (std::ispunct)(static_cast<unsigned char>(c)))
214        || ((mask & char_class_xdigit) && (std::isxdigit)(static_cast<unsigned char>(c)))
215        || ((mask & char_class_blank) && (std::isspace)(static_cast<unsigned char>(c)) && !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c))
216        || ((mask & char_class_word) && (c == '_'))
217        || ((mask & char_class_vertical) && (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == '\v')))
218        || ((mask & char_class_horizontal) && (std::isspace)(static_cast<unsigned char>(c)) && !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) && (c != '\v'));
219  }
220  inline c_regex_traits<char>::string_type  c_regex_traits<char>::lookup_collatename(const char* p1, const char* p2)
221  {
222     std::string s(p1, p2);
223     s = ::boost::BOOST_REGEX_DETAIL_NS::lookup_default_collate_name(s);
224     if (s.empty() && (p2 - p1 == 1))
225        s.append(1, *p1);
226     return s;
227  }
228  inline int  c_regex_traits<char>::value(char c, int radix)
229  {
230     char b[2] = { c, '\0', };
231     char* ep;
232     int result = std::strtol(b, &ep, radix);
233     if (ep == b)
234        return -1;
235     return result;
236  }
237  #ifndef BOOST_NO_WREGEX
238  inline c_regex_traits<wchar_t>::string_type  c_regex_traits<wchar_t>::transform(const wchar_t* p1, const wchar_t* p2)
239  {
240     std::size_t r;
241     std::size_t s = 10;
242     std::wstring src(p1, p2);
243     std::wstring result(s, L' ');
244     while (s < (r = std::wcsxfrm(&*result.begin(), src.c_str(), s)))
245     {
246  #if defined(_CPPLIB_VER)
247        if (r == INT_MAX)
248        {
249           result.erase();
250           result.insert(result.begin(), static_cast<wchar_t>(0));
251           return result;
252        }
253  #endif
254        result.append(r - s + 3, L' ');
255        s = result.size();
256     }
257     result.erase(r);
258     return result;
259  }
260  inline c_regex_traits<wchar_t>::string_type  c_regex_traits<wchar_t>::transform_primary(const wchar_t* p1, const wchar_t* p2)
261  {
262     static wchar_t s_delim;
263     static const int s_collate_type = ::boost::BOOST_REGEX_DETAIL_NS::find_sort_syntax(static_cast<const c_regex_traits<wchar_t>*>(0), &s_delim);
264     std::wstring result;
265     switch (s_collate_type)
266     {
267     case ::boost::BOOST_REGEX_DETAIL_NS::sort_C:
268     case ::boost::BOOST_REGEX_DETAIL_NS::sort_unknown:
269     {
270        result.assign(p1, p2);
271        for (std::wstring::size_type i = 0; i < result.size(); ++i)
272           result[i] = (std::towlower)(result[i]);
273        result = c_regex_traits<wchar_t>::transform(&*result.begin(), &*result.begin() + result.size());
274        break;
275     }
276     case ::boost::BOOST_REGEX_DETAIL_NS::sort_fixed:
277     {
278        result = c_regex_traits<wchar_t>::transform(&*result.begin(), &*result.begin() + result.size());
279        result.erase(s_delim);
280        break;
281     }
282     case ::boost::BOOST_REGEX_DETAIL_NS::sort_delim:
283        result = c_regex_traits<wchar_t>::transform(&*result.begin(), &*result.begin() + result.size());
284        if ((!result.empty()) && (result[0] == s_delim))
285           break;
286        std::size_t i;
287        for (i = 0; i < result.size(); ++i)
288        {
289           if (result[i] == s_delim)
290              break;
291        }
292        result.erase(i);
293        break;
294     }
295     if (result.empty())
296        result = std::wstring(1, char(0));
297     return result;
298  }
299  inline c_regex_traits<wchar_t>::char_class_type  c_regex_traits<wchar_t>::lookup_classname(const wchar_t* p1, const wchar_t* p2)
300  {
301     using namespace BOOST_REGEX_DETAIL_NS;
302     static const char_class_type masks[] =
303     {
304        0,
305        char_class_alnum,
306        char_class_alpha,
307        char_class_blank,
308        char_class_cntrl,
309        char_class_digit,
310        char_class_digit,
311        char_class_graph,
312        char_class_horizontal,
313        char_class_lower,
314        char_class_lower,
315        char_class_print,
316        char_class_punct,
317        char_class_space,
318        char_class_space,
319        char_class_upper,
320        char_class_unicode,
321        char_class_upper,
322        char_class_vertical,
323        char_class_alnum | char_class_word,
324        char_class_alnum | char_class_word,
325        char_class_xdigit,
326     };
327     int idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
328     if (idx < 0)
329     {
330        std::wstring s(p1, p2);
331        for (std::wstring::size_type i = 0; i < s.size(); ++i)
332           s[i] = (std::towlower)(s[i]);
333        idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(&*s.begin(), &*s.begin() + s.size());
334     }
335     BOOST_REGEX_ASSERT(idx + 1 < static_cast<int>(sizeof(masks) / sizeof(masks[0])));
336     return masks[idx + 1];
337  }
338  inline bool  c_regex_traits<wchar_t>::isctype(wchar_t c, char_class_type mask)
339  {
340     using namespace BOOST_REGEX_DETAIL_NS;
341     return
342        ((mask & char_class_space) && (std::iswspace)(c))
343        || ((mask & char_class_print) && (std::iswprint)(c))
344        || ((mask & char_class_cntrl) && (std::iswcntrl)(c))
345        || ((mask & char_class_upper) && (std::iswupper)(c))
346        || ((mask & char_class_lower) && (std::iswlower)(c))
347        || ((mask & char_class_alpha) && (std::iswalpha)(c))
348        || ((mask & char_class_digit) && (std::iswdigit)(c))
349        || ((mask & char_class_punct) && (std::iswpunct)(c))
350        || ((mask & char_class_xdigit) && (std::iswxdigit)(c))
351        || ((mask & char_class_blank) && (std::iswspace)(c) && !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c))
352        || ((mask & char_class_word) && (c == '_'))
353        || ((mask & char_class_unicode) && (c & ~static_cast<wchar_t>(0xff)))
354        || ((mask & char_class_vertical) && (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == L'\v')))
355        || ((mask & char_class_horizontal) && (std::iswspace)(c) && !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) && (c != L'\v'));
356  }
357  inline c_regex_traits<wchar_t>::string_type  c_regex_traits<wchar_t>::lookup_collatename(const wchar_t* p1, const wchar_t* p2)
358  {
359     std::string name;
360     for (const wchar_t* pos = p1; pos != p2; ++pos)
361        name.push_back((char)*pos);
362     name = ::boost::BOOST_REGEX_DETAIL_NS::lookup_default_collate_name(name);
<span onclick='openModal()' class='match'>363     if (!name.empty())
364        return string_type(name.begin(), name.end());
365     if (p2 - p1 == 1)
366        return string_type(1, *p1);
367     return string_type();
368  }
369  inline int  c_regex_traits<wchar_t>::value(wchar_t c, int radix)
</span>370  {
371  #ifdef BOOST_BORLANDC
372     if ((std::iswxdigit)(c) == 0)
373        return -1;
374  #endif
375     wchar_t b[2] = { c, '\0', };
376     wchar_t* ep;
377     int result = std::wcstol(b, &ep, radix);
378     if (ep == b)
379        return -1;
380     return result;
381  }
382  #endif
383  }
384  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
3  #include <boost/regex/config.hpp>
4  #include <cstdint>
5  #include <locale>
6  #include <type_traits>
7  #include <boost/regex/pattern_except.hpp>
8  #include <boost/regex/v5/regex_traits_defaults.hpp>
9  #ifdef BOOST_HAS_THREADS
10  #include <mutex>
11  #endif
12  #include <boost/regex/v5/primary_transform.hpp>
13  #include <boost/regex/v5/object_cache.hpp>
14  #include <climits>
15  #include <ios>
16  #include <istream>
17  #ifdef BOOST_REGEX_MSVC
18  #pragma warning(push)
19  #pragma warning(disable:4786 4251)
20  #endif
21  namespace boost{ 
22  template <class charT>
23  class cpp_regex_traits;
24  namespace BOOST_REGEX_DETAIL_NS{
25  template <class charT,
26            class traits = ::std::char_traits<charT> >
27  class parser_buf : public ::std::basic_streambuf<charT, traits>
28  {
29     typedef ::std::basic_streambuf<charT, traits> base_type;
30     typedef typename base_type::int_type int_type;
31     typedef typename base_type::char_type char_type;
32     typedef typename base_type::pos_type pos_type;
33     typedef ::std::streamsize streamsize;
34     typedef typename base_type::off_type off_type;
35  public:
36     parser_buf() : base_type() { setbuf(0, 0); }
37     const charT* getnext() { return this->gptr(); }
38  protected:
39     std::basic_streambuf<charT, traits>* setbuf(char_type* s, streamsize n) override;
40     typename parser_buf<charT, traits>::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which) override;
41     typename parser_buf<charT, traits>::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) override;
42  private:
43     parser_buf& operator=(const parser_buf&);
44     parser_buf(const parser_buf&);
45  };
46  template<class charT, class traits>
47  std::basic_streambuf<charT, traits>*
48  parser_buf<charT, traits>::setbuf(char_type* s, streamsize n)
49  {
50     this->setg(s, s, s + n);
51     return this;
52  }
53  template<class charT, class traits>
54  typename parser_buf<charT, traits>::pos_type
55  parser_buf<charT, traits>::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
56  {
57     if(which & ::std::ios_base::out)
58        return pos_type(off_type(-1));
59     std::ptrdiff_t size = this->egptr() - this->eback();
60     std::ptrdiff_t pos = this->gptr() - this->eback();
61     charT* g = this->eback();
62     switch(static_cast<std::intmax_t>(way))
63     {
64     case ::std::ios_base::beg:
65        if((off < 0) || (off > size))
66           return pos_type(off_type(-1));
67        else
68           this->setg(g, g + off, g + size);
69        break;
70     case ::std::ios_base::end:
71        if((off < 0) || (off > size))
72           return pos_type(off_type(-1));
73        else
74           this->setg(g, g + size - off, g + size);
75        break;
76     case ::std::ios_base::cur:
77     {
78        std::ptrdiff_t newpos = static_cast<std::ptrdiff_t>(pos + off);
79        if((newpos < 0) || (newpos > size))
80           return pos_type(off_type(-1));
81        else
82           this->setg(g, g + newpos, g + size);
83        break;
84     }
85     default: ;
86     }
87  #ifdef BOOST_REGEX_MSVC
88  #pragma warning(push)
89  #pragma warning(disable:4244)
90  #endif
91     return static_cast<pos_type>(this->gptr() - this->eback());
92  #ifdef BOOST_REGEX_MSVC
93  #pragma warning(pop)
94  #endif
95  }
96  template<class charT, class traits>
97  typename parser_buf<charT, traits>::pos_type
98  parser_buf<charT, traits>::seekpos(pos_type sp, ::std::ios_base::openmode which)
99  {
100     if(which & ::std::ios_base::out)
101        return pos_type(off_type(-1));
102     off_type size = static_cast<off_type>(this->egptr() - this->eback());
103     charT* g = this->eback();
104     if(off_type(sp) <= size)
105     {
106        this->setg(g, g + off_type(sp), g + size);
107     }
108     return pos_type(off_type(-1));
109  }
110  template <class charT>
111  struct cpp_regex_traits_base
112  {
113     cpp_regex_traits_base(const std::locale& l)
114     { (void)imbue(l); }
115     std::locale imbue(const std::locale& l);
116     std::locale m_locale;
117     std::ctype<charT> const* m_pctype;
118     std::messages<charT> const* m_pmessages;
119     std::collate<charT> const* m_pcollate;
120     bool operator<(const cpp_regex_traits_base& b)const
121     {
122        if(m_pctype == b.m_pctype)
123        {
124           if(m_pmessages == b.m_pmessages)
125           {
126              return m_pcollate < b.m_pcollate;
127           }
128           return m_pmessages < b.m_pmessages;
129        }
130        return m_pctype < b.m_pctype;
131     }
132     bool operator==(const cpp_regex_traits_base& b)const
133     {
134        return (m_pctype == b.m_pctype) 
135           && (m_pmessages == b.m_pmessages) 
136           && (m_pcollate == b.m_pcollate);
137     }
138  };
139  template <class charT>
140  std::locale cpp_regex_traits_base<charT>::imbue(const std::locale& l)
141  {
142     std::locale result(m_locale);
143     m_locale = l;
144     m_pctype = &std::use_facet<std::ctype<charT>>(l);
145     m_pmessages = std::has_facet<std::messages<charT> >(l) ? &std::use_facet<std::messages<charT> >(l) : 0;
146     m_pcollate = &std::use_facet<std::collate<charT> >(l);
147     return result;
148  }
149  template <class charT>
150  class cpp_regex_traits_char_layer : public cpp_regex_traits_base<charT>
151  {
152     typedef std::basic_string<charT> string_type;
153     typedef std::map<charT, regex_constants::syntax_type> map_type;
154     typedef typename map_type::const_iterator map_iterator_type;
155  public:
156     cpp_regex_traits_char_layer(const std::locale& l)
157        : cpp_regex_traits_base<charT>(l)
158     {
159        init();
160     }
161     cpp_regex_traits_char_layer(const cpp_regex_traits_base<charT>& b)
162        : cpp_regex_traits_base<charT>(b)
163     {
164        init();
165     }
166     void init();
167     regex_constants::syntax_type syntax_type(charT c)const
168     {
169        map_iterator_type i = m_char_map.find(c);
170        return ((i == m_char_map.end()) ? 0 : i->second);
171     }
172     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
173     {
174        map_iterator_type i = m_char_map.find(c);
175        if(i == m_char_map.end())
176        {
177           if(this->m_pctype->is(std::ctype_base::lower, c)) return regex_constants::escape_type_class;
178           if(this->m_pctype->is(std::ctype_base::upper, c)) return regex_constants::escape_type_not_class;
179           return 0;
180        }
181        return i->second;
182     }
183  private:
184     string_type get_default_message(regex_constants::syntax_type);
185     map_type m_char_map;
186  };
187  template <class charT>
188  void cpp_regex_traits_char_layer<charT>::init()
189  {
190  #ifndef __IBMCPP__
191     typename std::messages<charT>::catalog cat = static_cast<std::messages<char>::catalog>(-1);
192  #else
193     typename std::messages<charT>::catalog cat = reinterpret_cast<std::messages<char>::catalog>(-1);
194  #endif
195     std::string cat_name(cpp_regex_traits<charT>::get_catalog_name());
196     if((!cat_name.empty()) && (this->m_pmessages != 0))
197     {
198        cat = this->m_pmessages->open(
199           cat_name, 
200           this->m_locale);
201        if((int)cat < 0)
202        {
203           std::string m("Unable to open message catalog: ");
204           std::runtime_error err(m + cat_name);
205           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
206        }
207     }
208     if((int)cat >= 0)
209     {
210  #ifndef BOOST_NO_EXCEPTIONS
211        try{
212  #endif
213           for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
214           {
215              string_type mss = this->m_pmessages->get(cat, 0, i, get_default_message(i));
216              for(typename string_type::size_type j = 0; j < mss.size(); ++j)
217              {
218                 m_char_map[mss[j]] = i;
219              }
220           }
221           this->m_pmessages->close(cat);
222  #ifndef BOOST_NO_EXCEPTIONS
223        }
224        catch(...)
225        {
226           if(this->m_pmessages)
227              this->m_pmessages->close(cat);
228           throw;
229        }
230  #endif
231     }
232     else
233     {
234        for(regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
235        {
236           const char* ptr = get_default_syntax(i);
237           while(ptr && *ptr)
238           {
239              m_char_map[this->m_pctype->widen(*ptr)] = i;
240              ++ptr;
241           }
242        }
243     }
244  }
245  template <class charT>
246  typename cpp_regex_traits_char_layer<charT>::string_type 
247     cpp_regex_traits_char_layer<charT>::get_default_message(regex_constants::syntax_type i)
248  {
249     const char* ptr = get_default_syntax(i);
250     string_type result;
251     while(ptr && *ptr)
252     {
253        result.append(1, this->m_pctype->widen(*ptr));
254        ++ptr;
255     }
256     return result;
257  }
258  template <>
259  class cpp_regex_traits_char_layer<char> : public cpp_regex_traits_base<char>
260  {
261     typedef std::string string_type;
262  public:
263     cpp_regex_traits_char_layer(const std::locale& l)
264     : cpp_regex_traits_base<char>(l)
265     {
266        init();
267     }
268     cpp_regex_traits_char_layer(const cpp_regex_traits_base<char>& l)
269     : cpp_regex_traits_base<char>(l)
270     {
271        init();
272     }
273     regex_constants::syntax_type syntax_type(char c)const
274     {
275        return m_char_map[static_cast<unsigned char>(c)];
276     }
277     regex_constants::escape_syntax_type escape_syntax_type(char c) const
278     {
279        return m_char_map[static_cast<unsigned char>(c)];
280     }
281  private:
282     regex_constants::syntax_type m_char_map[1u << CHAR_BIT];
283     void init();
284  };
285  template <class charT>
286  class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer<charT>
287  {
288  public:
289     typedef typename cpp_regex_traits<charT>::char_class_type      char_class_type;
290     typedef typename std::ctype<charT>::mask                       native_mask_type;
291     typedef typename std::make_unsigned<native_mask_type>::type    unsigned_native_mask_type;
292     static const char_class_type mask_blank = 1u << 24;
293     static const char_class_type mask_word = 1u << 25;
294     static const char_class_type mask_unicode = 1u << 26;
295     static const char_class_type mask_horizontal = 1u << 27;
296     static const char_class_type mask_vertical = 1u << 28;
297     typedef std::basic_string<charT> string_type;
298     typedef charT char_type;
299     cpp_regex_traits_implementation(const std::locale& l)
300        : cpp_regex_traits_char_layer<charT>(l)
301     {
302        init();
303     }
304     cpp_regex_traits_implementation(const cpp_regex_traits_base<charT>& l)
305        : cpp_regex_traits_char_layer<charT>(l)
306     {
307        init();
308     }
309     std::string error_string(regex_constants::error_type n) const
310     {
311        if(!m_error_strings.empty())
312        {
313           std::map<int, std::string>::const_iterator p = m_error_strings.find(n);
314           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p->second;
315        }
316        return get_default_error_string(n);
317     }
318     char_class_type lookup_classname(const charT* p1, const charT* p2) const
319     {
320        char_class_type result = lookup_classname_imp(p1, p2);
321        if(result == 0)
322        {
323           string_type temp(p1, p2);
324           this->m_pctype->tolower(&*temp.begin(), &*temp.begin() + temp.size());
325           result = lookup_classname_imp(&*temp.begin(), &*temp.begin() + temp.size());
326        }
327        return result;
328     }
329     string_type lookup_collatename(const charT* p1, const charT* p2) const;
330     string_type transform_primary(const charT* p1, const charT* p2) const;
331     string_type transform(const charT* p1, const charT* p2) const;
332  private:
333     std::map<int, std::string>     m_error_strings;   
334     std::map<string_type, char_class_type>  m_custom_class_names; 
335     std::map<string_type, string_type>      m_custom_collate_names; 
336     unsigned                       m_collate_type;    
337     charT                          m_collate_delim;   
338     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
339     void init();
340  };
341  template <class charT>
342  typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_blank;
343  template <class charT>
344  typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_word;
345  template <class charT>
346  typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_unicode;
347  template <class charT>
348  typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_vertical;
349  template <class charT>
350  typename cpp_regex_traits_implementation<charT>::char_class_type const cpp_regex_traits_implementation<charT>::mask_horizontal;
351  template <class charT>
352  typename cpp_regex_traits_implementation<charT>::string_type 
353     cpp_regex_traits_implementation<charT>::transform_primary(const charT* p1, const charT* p2) const
354  {
355     BOOST_REGEX_ASSERT(*p2 == 0);
356     string_type result;
357  #if defined(_CPPLIB_VER)
358     if(*p1 == 0)
359     {
360        return string_type(1, charT(0));
361     }
362  #endif
363  #ifndef BOOST_NO_EXCEPTIONS
364     try{
365  #endif
366        switch(m_collate_type)
367        {
368        case sort_C:
369        case sort_unknown:
370           {
371              result.assign(p1, p2);
372              this->m_pctype->tolower(&*result.begin(), &*result.begin() + result.size());
373              result = this->m_pcollate->transform(&*result.begin(), &*result.begin() + result.size());
374              break;
375           }
376        case sort_fixed:
377           {
378              result.assign(this->m_pcollate->transform(p1, p2));
379              result.erase(this->m_collate_delim);
380              break;
381           }
382        case sort_delim:
383              result.assign(this->m_pcollate->transform(p1, p2));
384              std::size_t i;
385              for(i = 0; i < result.size(); ++i)
386              {
387                 if(result[i] == m_collate_delim)
388                    break;
389              }
390              result.erase(i);
391              break;
392        }
393  #ifndef BOOST_NO_EXCEPTIONS
394     }catch(...){}
395  #endif
396     while((!result.empty()) && (charT(0) == *result.rbegin()))
397        result.erase(result.size() - 1);
398     if(result.empty())
399     {
400        result = string_type(1, charT(0));
401     }
402     return result;
403  }
404  template <class charT>
405  typename cpp_regex_traits_implementation<charT>::string_type 
406     cpp_regex_traits_implementation<charT>::transform(const charT* p1, const charT* p2) const
407  {
408     BOOST_REGEX_ASSERT(*p2 == 0);
409     string_type result, result2;
410  #if defined(_CPPLIB_VER)
411     if(*p1 == 0)
412     {
413        return result;
414     }
415  #endif
416  #ifndef BOOST_NO_EXCEPTIONS
417     try{
418  #endif
419        result = this->m_pcollate->transform(p1, p2);
420        while((!result.empty()) && (charT(0) == *result.rbegin()))
421           result.erase(result.size() - 1);
422        typedef typename std::make_unsigned<charT>::type uchar_type;
423        result2.reserve(result.size() * 2 + 2);
424        for(unsigned i = 0; i < result.size(); ++i)
425        {
426           if(static_cast<uchar_type>(result[i]) == (std::numeric_limits<uchar_type>::max)())
427           {
428              result2.append(1, charT((std::numeric_limits<uchar_type>::max)())).append(1, charT('b'));
429           }
430           else
431           {
432              result2.append(1, static_cast<charT>(1 + static_cast<uchar_type>(result[i]))).append(1, charT('b') - 1);
433           }
434        }
435        BOOST_REGEX_ASSERT(std::find(result2.begin(), result2.end(), charT(0)) == result2.end());
436  #ifndef BOOST_NO_EXCEPTIONS
437     }
438     catch(...)
439     {
440     }
441  #endif
442     return result2;
443  }
444  template <class charT>
445  typename cpp_regex_traits_implementation<charT>::string_type 
446     cpp_regex_traits_implementation<charT>::lookup_collatename(const charT* p1, const charT* p2) const
447  {
448     typedef typename std::map<string_type, string_type>::const_iterator iter_type;
449     if(!m_custom_collate_names.empty())
450     {
451        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
452        if(pos != m_custom_collate_names.end())
453           return pos->second;
454     }
455     std::string name(p1, p2);
456     name = lookup_default_collate_name(name);
<span onclick='openModal()' class='match'>457     if(!name.empty())
458        return string_type(name.begin(), name.end());
459     if(p2 - p1 == 1)
460        return string_type(1, *p1);
461     return string_type();
462  }
463  template <class charT>
</span>464  void cpp_regex_traits_implementation<charT>::init()
465  {
466  #ifndef __IBMCPP__
467     typename std::messages<charT>::catalog cat = static_cast<std::messages<char>::catalog>(-1);
468  #else
469     typename std::messages<charT>::catalog cat = reinterpret_cast<std::messages<char>::catalog>(-1);
470  #endif
471     std::string cat_name(cpp_regex_traits<charT>::get_catalog_name());
472     if((!cat_name.empty()) && (this->m_pmessages != 0))
473     {
474        cat = this->m_pmessages->open(
475           cat_name, 
476           this->m_locale);
477        if((int)cat < 0)
478        {
479           std::string m("Unable to open message catalog: ");
480           std::runtime_error err(m + cat_name);
481           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
482        }
483     }
484     if((int)cat >= 0)
485     {
486        for(boost::regex_constants::error_type i = static_cast<boost::regex_constants::error_type>(0); 
487           i <= boost::regex_constants::error_unknown; 
488           i = static_cast<boost::regex_constants::error_type>(i + 1))
489        {
490           const char* p = get_default_error_string(i);
491           string_type default_message;
492           while(*p)
493           {
494              default_message.append(1, this->m_pctype->widen(*p));
495              ++p;
496           }
497           string_type s = this->m_pmessages->get(cat, 0, i+200, default_message);
498           std::string result;
499           for(std::string::size_type j = 0; j < s.size(); ++j)
500           {
501              result.append(1, this->m_pctype->narrow(s[j], 0));
502           }
503           m_error_strings[i] = result;
504        }
505        static const char_class_type masks[16] = 
506        {
507           static_cast<unsigned_native_mask_type>(std::ctype<charT>::alnum),
508           static_cast<unsigned_native_mask_type>(std::ctype<charT>::alpha),
509           static_cast<unsigned_native_mask_type>(std::ctype<charT>::cntrl),
510           static_cast<unsigned_native_mask_type>(std::ctype<charT>::digit),
511           static_cast<unsigned_native_mask_type>(std::ctype<charT>::graph),
512           cpp_regex_traits_implementation<charT>::mask_horizontal,
513           static_cast<unsigned_native_mask_type>(std::ctype<charT>::lower),
514           static_cast<unsigned_native_mask_type>(std::ctype<charT>::print),
515           static_cast<unsigned_native_mask_type>(std::ctype<charT>::punct),
516           static_cast<unsigned_native_mask_type>(std::ctype<charT>::space),
517           static_cast<unsigned_native_mask_type>(std::ctype<charT>::upper),
518           cpp_regex_traits_implementation<charT>::mask_vertical,
519           static_cast<unsigned_native_mask_type>(std::ctype<charT>::xdigit),
520           cpp_regex_traits_implementation<charT>::mask_blank,
521           cpp_regex_traits_implementation<charT>::mask_word,
522           cpp_regex_traits_implementation<charT>::mask_unicode,
523        };
524        static const string_type null_string;
525        for(unsigned int j = 0; j <= 13; ++j)
526        {
527           string_type s(this->m_pmessages->get(cat, 0, j+300, null_string));
528           if(!s.empty())
529              this->m_custom_class_names[s] = masks[j];
530        }
531     }
532     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &m_collate_delim);
533  }
534  template <class charT>
535  typename cpp_regex_traits_implementation<charT>::char_class_type 
536     cpp_regex_traits_implementation<charT>::lookup_classname_imp(const charT* p1, const charT* p2) const
537  {
538     static const char_class_type masks[22] = 
539     {
540        0,
541        static_cast<unsigned_native_mask_type>(std::ctype<char>::alnum),
542        static_cast<unsigned_native_mask_type>(std::ctype<char>::alpha),
543        cpp_regex_traits_implementation<charT>::mask_blank,
544        static_cast<unsigned_native_mask_type>(std::ctype<char>::cntrl),
545        static_cast<unsigned_native_mask_type>(std::ctype<char>::digit),
546        static_cast<unsigned_native_mask_type>(std::ctype<char>::digit),
547        static_cast<unsigned_native_mask_type>(std::ctype<char>::graph),
548        cpp_regex_traits_implementation<charT>::mask_horizontal,
549        static_cast<unsigned_native_mask_type>(std::ctype<char>::lower),
550        static_cast<unsigned_native_mask_type>(std::ctype<char>::lower),
551        static_cast<unsigned_native_mask_type>(std::ctype<char>::print),
552        static_cast<unsigned_native_mask_type>(std::ctype<char>::punct),
553        static_cast<unsigned_native_mask_type>(std::ctype<char>::space),
554        static_cast<unsigned_native_mask_type>(std::ctype<char>::space),
555        static_cast<unsigned_native_mask_type>(std::ctype<char>::upper),
556        cpp_regex_traits_implementation<charT>::mask_unicode,
557        static_cast<unsigned_native_mask_type>(std::ctype<char>::upper),
558        cpp_regex_traits_implementation<charT>::mask_vertical,
559        static_cast<unsigned_native_mask_type>(std::ctype<char>::alnum) | cpp_regex_traits_implementation<charT>::mask_word, 
560        static_cast<unsigned_native_mask_type>(std::ctype<char>::alnum) | cpp_regex_traits_implementation<charT>::mask_word, 
561        static_cast<unsigned_native_mask_type>(std::ctype<char>::xdigit),
562     };
563     if(!m_custom_class_names.empty())
564     {
565        typedef typename std::map<std::basic_string<charT>, char_class_type>::const_iterator map_iter;
566        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
567        if(pos != m_custom_class_names.end())
568           return pos->second;
569     }
570     std::size_t state_id = 1 + BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
571     BOOST_REGEX_ASSERT(state_id < sizeof(masks) / sizeof(masks[0]));
572     return masks[state_id];
573  }
574  template <class charT>
575  inline std::shared_ptr<const cpp_regex_traits_implementation<charT> > create_cpp_regex_traits(const std::locale& l)
576  {
577     cpp_regex_traits_base<charT> key(l);
578     return ::boost::object_cache<cpp_regex_traits_base<charT>, cpp_regex_traits_implementation<charT> >::get(key, 5);
579  }
580  } 
581  template <class charT>
582  class cpp_regex_traits
583  {
584  private:
585     typedef std::ctype<charT>            ctype_type;
586  public:
587     typedef charT                        char_type;
588     typedef std::size_t                  size_type;
589     typedef std::basic_string<char_type> string_type;
590     typedef std::locale                  locale_type;
591     typedef std::uint_least32_t          char_class_type;
592     struct boost_extensions_tag{};
593     cpp_regex_traits()
594        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits<charT>(std::locale()))
595     { }
596     static size_type length(const char_type* p)
597     {
598        return std::char_traits<charT>::length(p);
599     }
600     regex_constants::syntax_type syntax_type(charT c)const
601     {
602        return m_pimpl->syntax_type(c);
603     }
604     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
605     {
606        return m_pimpl->escape_syntax_type(c);
607     }
608     charT translate(charT c) const
609     {
610        return c;
611     }
612     charT translate_nocase(charT c) const
613     {
614        return m_pimpl->m_pctype->tolower(c);
615     }
616     charT translate(charT c, bool icase) const
617     {
618        return icase ? m_pimpl->m_pctype->tolower(c) : c;
619     }
620     charT tolower(charT c) const
621     {
622        return m_pimpl->m_pctype->tolower(c);
623     }
624     charT toupper(charT c) const
625     {
626        return m_pimpl->m_pctype->toupper(c);
627     }
628     string_type transform(const charT* p1, const charT* p2) const
629     {
630        return m_pimpl->transform(p1, p2);
631     }
632     string_type transform_primary(const charT* p1, const charT* p2) const
633     {
634        return m_pimpl->transform_primary(p1, p2);
635     }
636     char_class_type lookup_classname(const charT* p1, const charT* p2) const
637     {
638        return m_pimpl->lookup_classname(p1, p2);
639     }
640     string_type lookup_collatename(const charT* p1, const charT* p2) const
641     {
642        return m_pimpl->lookup_collatename(p1, p2);
643     }
644     bool isctype(charT c, char_class_type f) const
645     {
646        typedef typename std::ctype<charT>::mask ctype_mask;
647        static const ctype_mask mask_base = 
648           static_cast<ctype_mask>(
649              std::ctype<charT>::alnum 
650              | std::ctype<charT>::alpha
651              | std::ctype<charT>::cntrl
652              | std::ctype<charT>::digit
653              | std::ctype<charT>::graph
654              | std::ctype<charT>::lower
655              | std::ctype<charT>::print
656              | std::ctype<charT>::punct
657              | std::ctype<charT>::space
658              | std::ctype<charT>::upper
659              | std::ctype<charT>::xdigit);
660        if((f & mask_base) 
661           && (m_pimpl->m_pctype->is(
662              static_cast<ctype_mask>(f & mask_base), c)))
663           return true;
664        else if((f & BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_unicode) && BOOST_REGEX_DETAIL_NS::is_extended(c))
665           return true;
666        else if((f & BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_word) && (c == '_'))
667           return true;
668        else if((f & BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_blank) 
669           && m_pimpl->m_pctype->is(std::ctype<charT>::space, c)
670           && !BOOST_REGEX_DETAIL_NS::is_separator(c))
671           return true;
672        else if((f & BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_vertical) 
673           && (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == '\v')))
674           return true;
675        else if((f & BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_horizontal) 
676           && this->isctype(c, std::ctype<charT>::space) && !this->isctype(c, BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT>::mask_vertical))
677           return true;
678  #ifdef __CYGWIN__
679        else if((f & std::ctype<charT>::xdigit) == std::ctype<charT>::xdigit)
680        {
681           if((c >= 'a') && (c <= 'f'))
682              return true;
683           if((c >= 'A') && (c <= 'F'))
684              return true;
685        }
686  #endif
687        return false;
688     }
689     std::intmax_t toi(const charT*& p1, const charT* p2, int radix)const;
690     int value(charT c, int radix)const
691     {
692        const charT* pc = &c;
693        return (int)toi(pc, pc + 1, radix);
694     }
695     locale_type imbue(locale_type l)
696     {
697        std::locale result(getloc());
698        m_pimpl = BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits<charT>(l);
699        return result;
700     }
701     locale_type getloc()const
702     {
703        return m_pimpl->m_locale;
704     }
705     std::string error_string(regex_constants::error_type n) const
706     {
707        return m_pimpl->error_string(n);
708     }
709     static std::string catalog_name(const std::string& name);
710     static std::string get_catalog_name();
711  private:
712     std::shared_ptr<const BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation<charT> > m_pimpl;
713     static std::string& get_catalog_name_inst();
714  #ifdef BOOST_HAS_THREADS
715     static std::mutex& get_mutex_inst();
716  #endif
717  };
718  template <class charT>
719  std::intmax_t cpp_regex_traits<charT>::toi(const charT*& first, const charT* last, int radix)const
720  {
721     BOOST_REGEX_DETAIL_NS::parser_buf<charT>   sbuf;            
722     std::basic_istream<charT>      is(&sbuf);       
723     last = std::find(first, last, std::use_facet<std::numpunct<charT>>(is.getloc()).thousands_sep());
724     sbuf.pubsetbuf(const_cast<charT*>(static_cast<const charT*>(first)), static_cast<std::streamsize>(last-first));
725     is.clear();
726     if(std::abs(radix) == 16) is >> std::hex;
727     else if(std::abs(radix) == 8) is >> std::oct;
728     else is >> std::dec;
729     std::intmax_t val;
730     if(is >> val)
731     {
732        first = first + ((last - first) - sbuf.in_avail());
733        return val;
734     }
735     else
736        return -1;
737  }
738  template <class charT>
739  std::string cpp_regex_traits<charT>::catalog_name(const std::string& name)
740  {
741  #ifdef BOOST_HAS_THREADS
742     std::lock_guard<std::mutex> lk(get_mutex_inst());
743  #endif
744     std::string result(get_catalog_name_inst());
745     get_catalog_name_inst() = name;
746     return result;
747  }
748  template <class charT>
749  std::string& cpp_regex_traits<charT>::get_catalog_name_inst()
750  {
751     static std::string s_name;
752     return s_name;
753  }
754  template <class charT>
755  std::string cpp_regex_traits<charT>::get_catalog_name()
756  {
757  #ifdef BOOST_HAS_THREADS
758     std::lock_guard<std::mutex> lk(get_mutex_inst());
759  #endif
760     std::string result(get_catalog_name_inst());
761     return result;
762  }
763  #ifdef BOOST_HAS_THREADS
764  template <class charT>
765  std::mutex& cpp_regex_traits<charT>::get_mutex_inst()
766  {
767     static std::mutex s_mutex;
768     return s_mutex;
769  }
770  #endif
771  namespace BOOST_REGEX_DETAIL_NS {
772     inline void cpp_regex_traits_char_layer<char>::init()
773     {
774        std::memset(m_char_map, 0, sizeof(m_char_map));
775  #ifndef __IBMCPP__
776        std::messages<char>::catalog cat = static_cast<std::messages<char>::catalog>(-1);
777  #else
778        std::messages<char>::catalog cat = reinterpret_cast<std::messages<char>::catalog>(-1);
779  #endif
780        std::string cat_name(cpp_regex_traits<char>::get_catalog_name());
781        if ((!cat_name.empty()) && (m_pmessages != 0))
782        {
783           cat = this->m_pmessages->open(
784              cat_name,
785              this->m_locale);
786           if ((int)cat < 0)
787           {
788              std::string m("Unable to open message catalog: ");
789              std::runtime_error err(m + cat_name);
790              boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
791           }
792        }
793        if ((int)cat >= 0)
794        {
795  #ifndef BOOST_NO_EXCEPTIONS
796           try {
797  #endif
798              for (regex_constants::syntax_type i = 1; i < regex_constants::syntax_max; ++i)
799              {
800                 string_type mss = this->m_pmessages->get(cat, 0, i, get_default_syntax(i));
801                 for (string_type::size_type j = 0; j < mss.size(); ++j)
802                 {
803                    m_char_map[static_cast<unsigned char>(mss[j])] = i;
804                 }
805              }
806              this->m_pmessages->close(cat);
807  #ifndef BOOST_NO_EXCEPTIONS
808           }
809           catch (...)
810           {
811              this->m_pmessages->close(cat);
812              throw;
813           }
814  #endif
815        }
816        else
817        {
818           for (regex_constants::syntax_type j = 1; j < regex_constants::syntax_max; ++j)
819           {
820              const char* ptr = get_default_syntax(j);
821              while (ptr && *ptr)
822              {
823                 m_char_map[static_cast<unsigned char>(*ptr)] = j;
824                 ++ptr;
825              }
826           }
827        }
828        unsigned char i = 'A';
829        do
830        {
831           if (m_char_map[i] == 0)
832           {
833              if (this->m_pctype->is(std::ctype_base::lower, i))
834                 m_char_map[i] = regex_constants::escape_type_class;
835              else if (this->m_pctype->is(std::ctype_base::upper, i))
836                 m_char_map[i] = regex_constants::escape_type_not_class;
837           }
838        } while (0xFF != i++);
839     }
840  } 
841  } 
842  #ifdef BOOST_REGEX_MSVC
843  #pragma warning(pop)
844  #endif
845  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-c_regex_traits.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</div>
                </div>
                <div class="column column_space"><pre><code>363     if (!name.empty())
364        return string_type(name.begin(), name.end());
365     if (p2 - p1 == 1)
366        return string_type(1, *p1);
367     return string_type();
368  }
369  inline int  c_regex_traits<wchar_t>::value(wchar_t c, int radix)
</pre></code></div>
                <div class="column column_space"><pre><code>457     if(!name.empty())
458        return string_type(name.begin(), name.end());
459     if(p2 - p1 == 1)
460        return string_type(1, *p1);
461     return string_type();
462  }
463  template <class charT>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    