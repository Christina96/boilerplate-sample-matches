
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ds.h</h3>
            <pre><code>1  template &lt;class TRec&gt;
2  class TAPt{
3  private:
4    TRec* Addr;
5  public:
6    TAPt(): Addr(NULL){}
7    TAPt(const TAPt&amp; Pt): Addr(Pt.Addr){}
8    TAPt(TRec* _Addr): Addr(_Addr){}
9    TAPt(TSIn&amp;){Fail;}
10    void Save(TSOut&amp;) const {Fail;}
11    TAPt&amp; operator=(const TAPt&amp; Pt){Addr=Pt.Addr; return *this;}
12    TAPt&amp; operator=(TRec* _Addr){Addr=_Addr; return *this;}
13    bool operator==(const TAPt&amp; Pt) const {return *Addr==*Pt.Addr;}
14    bool operator!=(const TAPt&amp; Pt) const {return *Addr!=*Pt.Addr;}
15    bool operator&lt;(const TAPt&amp; Pt) const {return *Addr&lt;*Pt.Addr;}
16    TRec* operator-&gt;() const {Assert(Addr!=NULL); return Addr;}
17    TRec&amp; operator*() const {Assert(Addr!=NULL); return *Addr;}
18    TRec&amp; operator[](const int&amp; RecN) const {
19      Assert(Addr!=NULL); return Addr[RecN];}
20    TRec* operator()() const {return Addr;}
21    bool Empty() const {return Addr==NULL;}
22  };
23  template &lt;class TVal1, class TVal2&gt;
24  class TPair{
25  public:
26    TVal1 Val1;
27    TVal2 Val2;
28  public:
29    TPair(): Val1(), Val2(){}
30    TPair(const TPair&amp; Pair): Val1(Pair.Val1), Val2(Pair.Val2){}
31    TPair(const TVal1&amp; _Val1, const TVal2&amp; _Val2): Val1(_Val1), Val2(_Val2){}
32    explicit TPair(TSIn&amp; SIn): Val1(SIn), Val2(SIn){}
33    void Save(TSOut&amp; SOut) const {
34      Val1.Save(SOut); Val2.Save(SOut);}
35    void Load(TSIn&amp; SIn) {Val1.Load(SIn); Val2.Load(SIn);}
36    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
37    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
38    TPair&amp; operator=(const TPair&amp; Pair){
39      if (this!=&amp;Pair){Val1=Pair.Val1; Val2=Pair.Val2;} return *this;}
40    bool operator==(const TPair&amp; Pair) const {
41      return (Val1==Pair.Val1)&amp;&amp;(Val2==Pair.Val2);}
42    bool operator&lt;(const TPair&amp; Pair) const {
43      return (Val1&lt;Pair.Val1)||((Val1==Pair.Val1)&amp;&amp;(Val2&lt;Pair.Val2));}
44    int GetMemUsed() const {return Val1.GetMemUsed()+Val2.GetMemUsed();}
45    int GetPrimHashCd() const {return TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()); }
46    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val1.GetSecHashCd()); }
47    void GetVal(TVal1&amp; _Val1, TVal2&amp; _Val2) const {_Val1=Val1; _Val2=Val2;}
48    const TVal1&amp; GetVal1() const { return Val1;}
49    const TVal2&amp; GetVal2() const { return Val2;}
50    TStr GetStr() const {
51      return TStr(&quot;Pair(&quot;)+Val1.GetStr()+&quot;, &quot;+Val2.GetStr()+&quot;)&quot;;}
52  };
53  template &lt;class TVal1, class TVal2, class TSizeTy&gt;
54  void GetSwitchedPrV(const TVec&lt;TPair&lt;TVal1, TVal2&gt;, TSizeTy&gt;&amp; SrcPrV, TVec&lt;TPair&lt;TVal2, TVal1&gt;, TSizeTy&gt;&amp; DstPrV){
55    const TSizeTy Prs = SrcPrV.Len();
56    DstPrV.Gen(Prs, 0);
57    for (TSizeTy PrN=0; PrN&lt;Prs; PrN++){
58      const TPair&lt;TVal1, TVal2&gt;&amp; SrcPr=SrcPrV[PrN];
59      DstPrV.Add(TPair&lt;TVal2, TVal1&gt;(SrcPr.Val2, SrcPr.Val1));
60    }
61  }
62  typedef TPair&lt;TBool, TCh&gt; TBoolChPr;
63  typedef TPair&lt;TBool, TFlt&gt; TBoolFltPr;
64  typedef TPair&lt;TUCh, TInt&gt; TUChIntPr;
65  typedef TPair&lt;TUCh, TUInt64&gt; TUChUInt64Pr;
66  typedef TPair&lt;TUCh, TStr&gt; TUChStrPr;
67  typedef TPair&lt;TInt, TBool&gt; TIntBoolPr;
68  typedef TPair&lt;TInt, TCh&gt; TIntChPr;
69  typedef TPair&lt;TInt, TInt&gt; TIntPr;
70  typedef TPair&lt;TInt, TUInt64&gt; TIntUInt64Pr;
71  typedef TPair&lt;TInt, TIntPr&gt; TIntIntPrPr;
72  typedef TPair&lt;TInt, TVec&lt;TInt, int&gt; &gt; TIntIntVPr;
73  typedef TPair&lt;TInt, TFlt&gt; TIntFltPr;
74  typedef TPair&lt;TInt, TStr&gt; TIntStrPr;
75  typedef TPair&lt;TInt, TStrV&gt; TIntStrVPr;
76  typedef TPair&lt;TIntPr, TInt&gt; TIntPrIntPr;
77  typedef TPair&lt;TUInt, TUInt&gt; TUIntUIntPr;
78  typedef TPair&lt;TUInt, TInt&gt; TUIntIntPr;
79  typedef TPair&lt;TUInt64, TInt&gt; TUInt64IntPr;
80  typedef TPair&lt;TUInt64, TUInt64&gt; TUInt64Pr;
81  typedef TPair&lt;TUInt64, TFlt&gt; TUInt64FltPr;
82  typedef TPair&lt;TUInt64, TStr&gt; TUInt64StrPr;
83  typedef TPair&lt;TFlt, TInt&gt; TFltIntPr;
84  typedef TPair&lt;TFlt, TUInt64&gt; TFltUInt64Pr;
85  typedef TPair&lt;TFlt, TFlt&gt; TFltPr;
86  typedef TPair&lt;TFlt, TStr&gt; TFltStrPr;
87  typedef TPair&lt;TAscFlt, TInt&gt; TAscFltIntPr;
88  typedef TPair&lt;TAscFlt, TAscFlt&gt; TAscFltPr;
89  typedef TPair&lt;TFlt, TStr&gt; TFltStrPr;
90  typedef TPair&lt;TAscFlt, TStr&gt; TAscFltStrPr;
91  typedef TPair&lt;TStr, TInt&gt; TStrIntPr;
92  typedef TPair&lt;TStr, TFlt&gt; TStrFltPr;
93  typedef TPair&lt;TStr, TStr&gt; TStrPr;
94  typedef TPair&lt;TStr, TStrV&gt; TStrStrVPr;
95  typedef TPair&lt;TStrV, TInt&gt; TStrVIntPr;
96  typedef TPair&lt;TInt, TIntPr&gt; TIntIntPrPr;
97  typedef TPair&lt;TInt, TStrPr&gt; TIntStrPrPr;
98  typedef TPair&lt;TFlt, TStrPr&gt; TFltStrPrPr;
99  typedef TPair&lt;TVec&lt;TInt, int&gt;, TVec&lt;TFlt, int&gt; &gt; TIntVFltVPr;
100  template &lt;class TVal1, class TVal2&gt;
101  class TCmpPairByVal2 {
102  private:
103    bool IsAsc;
104  public:
105    TCmpPairByVal2(const bool&amp; AscSort=true) : IsAsc(AscSort) { }
106    bool operator () (const TPair&lt;TVal1, TVal2&gt;&amp; P1, const TPair&lt;TVal1, TVal2&gt;&amp; P2) const {
107      if (IsAsc) { return P1.Val2 &lt; P2.Val2; } else { return P2.Val2 &lt; P1.Val2; }
108    }
109  };
110  template &lt;class TVal1, class TVal2, class TVal3&gt;
111  class TTriple{
112  public:
113    TVal1 Val1;
114    TVal2 Val2;
115    TVal3 Val3;
116  public:
117    TTriple(): Val1(), Val2(), Val3(){}
118    TTriple(const TTriple&amp; Triple):
119      Val1(Triple.Val1), Val2(Triple.Val2), Val3(Triple.Val3){}
120    TTriple(const TVal1&amp; _Val1, const TVal2&amp; _Val2, const TVal3&amp; _Val3):
121      Val1(_Val1), Val2(_Val2), Val3(_Val3){}
122    explicit TTriple(TSIn&amp; SIn): Val1(SIn), Val2(SIn), Val3(SIn){}
123    void Save(TSOut&amp; SOut) const {
124      Val1.Save(SOut); Val2.Save(SOut); Val3.Save(SOut);}
125    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
126    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
127    TTriple&amp; operator=(const TTriple&amp; Triple){
128      if (this!=&amp;Triple){Val1=Triple.Val1; Val2=Triple.Val2; Val3=Triple.Val3;}
129      return *this;}
130    bool operator==(const TTriple&amp; Triple) const {
131      return (Val1==Triple.Val1)&amp;&amp;(Val2==Triple.Val2)&amp;&amp;(Val3==Triple.Val3);}
132    bool operator&lt;(const TTriple&amp; Triple) const {
133      return (Val1&lt;Triple.Val1)||((Val1==Triple.Val1)&amp;&amp;(Val2&lt;Triple.Val2))||
134       ((Val1==Triple.Val1)&amp;&amp;(Val2==Triple.Val2)&amp;&amp;(Val3&lt;Triple.Val3));}
135    int GetPrimHashCd() const {return  TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()), Val3.GetPrimHashCd()); }
136    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val3.GetSecHashCd()), Val1.GetSecHashCd()); }
137    int GetMemUsed() const {return Val1.GetMemUsed()+Val2.GetMemUsed()+Val3.GetMemUsed();}
138    void GetVal(TVal1&amp; _Val1, TVal2&amp; _Val2, TVal3&amp; _Val3) const {
139      _Val1=Val1; _Val2=Val2; _Val3=Val3;}
140    const TVal1&amp; GetVal1() const { return Val1;}
141    const TVal2&amp; GetVal2() const { return Val2;}
142    const TVal3&amp; GetVal3() const { return Val3;}
143  };
144  typedef TTriple&lt;TCh, TCh, TCh&gt; TChTr;
145  typedef TTriple&lt;TCh, TInt, TInt&gt; TChIntIntTr;
146  typedef TTriple&lt;TUCh, TInt, TInt&gt; TUChIntIntTr;
147  typedef TTriple&lt;TInt, TInt, TInt&gt; TIntTr;
148  typedef TTriple&lt;TUInt64, TUInt64, TUInt64&gt; TUInt64Tr;
149  typedef TTriple&lt;TInt, TStr, TInt&gt; TIntStrIntTr;
150  typedef TTriple&lt;TInt, TInt, TStr&gt; TIntIntStrTr;
151  typedef TTriple&lt;TInt, TInt, TFlt&gt; TIntIntFltTr;
152  typedef TTriple&lt;TInt, TFlt, TInt&gt; TIntFltIntTr;
153  typedef TTriple&lt;TInt, TFlt, TFlt&gt; TIntFltFltTr;
154  typedef TTriple&lt;TInt, TStr, TStr&gt; TIntStrStrTr;
155  typedef TTriple&lt;TInt, TVec&lt;TInt, int&gt;, TInt&gt; TIntIntVIntTr;
156  typedef TTriple&lt;TInt, TInt, TVec&lt;TInt, int&gt; &gt; TIntIntIntVTr;
157  typedef TTriple&lt;TFlt, TFlt, TFlt&gt; TFltTr;
158  typedef TTriple&lt;TFlt, TInt, TInt&gt; TFltIntIntTr;
159  typedef TTriple&lt;TFlt, TFlt, TInt&gt; TFltFltIntTr;
160  typedef TTriple&lt;TFlt, TFlt, TStr&gt; TFltFltStrTr;
161  typedef TTriple&lt;TChA, TChA, TChA&gt; TChATr;
162  typedef TTriple&lt;TStr, TStr, TStr&gt; TStrTr;
163  typedef TTriple&lt;TStr, TInt, TInt&gt; TStrIntIntTr;
164  typedef TTriple&lt;TStr, TFlt, TFlt&gt; TStrFltFltTr;
165  typedef TTriple&lt;TStr, TStr, TInt&gt; TStrStrIntTr;
166  typedef TTriple&lt;TStr, TInt, TStrV&gt; TStrIntStrVTr;
167  template &lt;class TVal1, class TVal2, class TVal3&gt;
168  class TCmpTripleByVal2 {
169  private:
170    bool IsAsc;
171  public:
172    TCmpTripleByVal2(const bool&amp; AscSort=true) : IsAsc(AscSort) { }
173    bool operator () (const TTriple&lt;TVal1, TVal2, TVal3&gt;&amp; T1, const TTriple&lt;TVal1, TVal2, TVal3&gt;&amp; T2) const {
174      if (IsAsc) { return T1.Val2 &lt; T2.Val2; } else { return T2.Val2 &lt; T1.Val2; }
175    }
176  };
177  template &lt;class TVal1, class TVal2, class TVal3&gt;
178  class TCmpTripleByVal3 {
179  private:
180    bool IsAsc;
181  public:
182    TCmpTripleByVal3(const bool&amp; AscSort=true) : IsAsc(AscSort) { }
183    bool operator () (const TTriple&lt;TVal1, TVal2, TVal3&gt;&amp; T1, const TTriple&lt;TVal1, TVal2, TVal3&gt;&amp; T2) const {
184      if (IsAsc) { return T1.Val3 &lt; T2.Val3; } else { return T2.Val3 &lt; T1.Val3; }
185    }
186  };
187  template &lt;class TVal1, class TVal2, class TVal3, class TVal4&gt;
188  class TQuad{
189  public:
190    TVal1 Val1;
191    TVal2 Val2;
192    TVal3 Val3;
193    TVal4 Val4;
194  public:
195    TQuad():
196      Val1(), Val2(), Val3(), Val4(){}
197    TQuad(const TQuad&amp; Quad):
198      Val1(Quad.Val1), Val2(Quad.Val2), Val3(Quad.Val3), Val4(Quad.Val4){}
199    TQuad(const TVal1&amp; _Val1, const TVal2&amp; _Val2, const TVal3&amp; _Val3, const TVal4&amp; _Val4):
200      Val1(_Val1), Val2(_Val2), Val3(_Val3), Val4(_Val4){}
201    explicit TQuad(TSIn&amp; SIn):
202      Val1(SIn), Val2(SIn), Val3(SIn), Val4(SIn){}
203    void Save(TSOut&amp; SOut) const {
204      Val1.Save(SOut); Val2.Save(SOut); Val3.Save(SOut); Val4.Save(SOut);}
205    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
206    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
207    TQuad&amp; operator=(const TQuad&amp; Quad){
208      if (this!=&amp;Quad){
209        Val1=Quad.Val1; Val2=Quad.Val2; Val3=Quad.Val3; Val4=Quad.Val4;}
210      return *this;}
211    bool operator==(const TQuad&amp; Quad) const {
212      return (Val1==Quad.Val1)&amp;&amp;(Val2==Quad.Val2)&amp;&amp;(Val3==Quad.Val3)&amp;&amp;(Val4==Quad.Val4);}
213    bool operator&lt;(const TQuad&amp; Quad) const {
214      return (Val1&lt;Quad.Val1)||((Val1==Quad.Val1)&amp;&amp;(Val2&lt;Quad.Val2))||
215       ((Val1==Quad.Val1)&amp;&amp;(Val2==Quad.Val2)&amp;&amp;(Val3&lt;Quad.Val3))||
216       ((Val1==Quad.Val1)&amp;&amp;(Val2==Quad.Val2)&amp;&amp;(Val3==Quad.Val3)&amp;&amp;(Val4&lt;Quad.Val4));}
217    int GetPrimHashCd() const {return  TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val1.GetPrimHashCd(), Val2.GetPrimHashCd()), TPairHashImpl::GetHashCd(Val3.GetPrimHashCd(), Val4.GetPrimHashCd())); }
218    int GetSecHashCd() const {return TPairHashImpl::GetHashCd(TPairHashImpl::GetHashCd(Val2.GetSecHashCd(), Val3.GetSecHashCd()), TPairHashImpl::GetHashCd(Val4.GetSecHashCd(), Val1.GetSecHashCd())); }
219    void GetVal(TVal1&amp; _Val1, TVal2&amp; _Val2, TVal3&amp; _Val3, TVal4&amp; _Val4) const {
220      _Val1=Val1; _Val2=Val2; _Val3=Val3; _Val4=Val4;}
221    const TVal1&amp; GetVal1() const { return Val1;}
222    const TVal2&amp; GetVal2() const { return Val2;}
223    const TVal3&amp; GetVal3() const { return Val3;}
224    const TVal4&amp; GetVal4() const { return Val4;}
225  };
226  typedef TQuad&lt;TStr, TStr, TInt, TInt&gt; TStrStrIntIntQu;
227  typedef TQuad&lt;TStr, TStr, TStr, TStr&gt; TStrQu;
228  typedef TQuad&lt;TInt, TInt, TInt, TInt&gt; TIntQu;
229  typedef TQuad&lt;TFlt, TFlt, TFlt, TFlt&gt; TFltQu;
230  typedef TQuad&lt;TFlt, TInt, TInt, TInt&gt; TFltIntIntIntQu;
231  typedef TQuad&lt;TInt, TStr, TInt, TInt&gt; TIntStrIntIntQu;
232  typedef TQuad&lt;TInt, TInt, TFlt, TFlt&gt; TIntIntFltFltQu;
233  template&lt;class TVal, int NVals&gt;
234  class TTuple {
235  private:
236    TVal ValV [NVals];
237  public:
238    TTuple(){}
239    TTuple(const TVal&amp; InitVal) { for (int i=0; i&lt;Len(); i++) ValV[i]=InitVal; }
240    TTuple(const TTuple&amp; Tup) { for (int i=0; i&lt;Len(); i++) ValV[i]=Tup[i]; }
241    TTuple(TSIn&amp; SIn) { for (int i=0; i&lt;Len(); i++) ValV[i].Load(SIn); }
242    void Save(TSOut&amp; SOut) const { for (int i=0; i&lt;Len(); i++) ValV[i].Save(SOut); }
243    void Load(TSIn&amp; SIn) { for (int i=0; i&lt;Len(); i++) ValV[i].Load(SIn); }
244    int Len() const { return NVals; }
245    TVal&amp; operator[] (const int&amp; ValN) { return ValV[ValN]; }
246    const TVal&amp; operator[] (const int&amp; ValN) const { return ValV[ValN]; }
247    TTuple&amp; operator = (const TTuple&amp; Tup) { if (this != &amp; Tup) {
248      for (int i=0; i&lt;Len(); i++) ValV[i]=Tup[i]; } return *this; }
249    bool operator == (const TTuple&amp; Tup) const {
250      if (Len()!=Tup.Len()) { return false; }  if (&amp;Tup==this) { return true; }
251      for (int i=0; i&lt;Len(); i++) if(ValV[i]!=Tup[i]){return false;} return true; }
252    bool operator &lt; (const TTuple&amp; Tup) const {
253      if (Len() == Tup.Len()) { for (int i=0; i&lt;Len(); i++) {
254        if(ValV[i]&lt;Tup[i]){return true;} else if(ValV[i]&gt;Tup[i]){return false;} } return false; }
255      else { return Len() &lt; Tup.Len(); } }
256    void Sort(const bool&amp; Asc=true);
257    int FindMx() const;
258    int FindMn() const;
259    int GetPrimHashCd() const { int hc = 0;
260      for (int i = 0; i &lt; NVals; i++) { hc = TPairHashImpl::GetHashCd(hc, ValV[i].GetPrimHashCd()); }
261      return hc; }
262    int GetSecHashCd() const { int hc = 0;
263      for (int i = 1; i &lt; NVals; i++) { hc = TPairHashImpl::GetHashCd(hc, ValV[i].GetSecHashCd()); }
264      if (NVals &gt; 0) { hc = TPairHashImpl::GetHashCd(hc, ValV[0].GetSecHashCd()); }
265      return hc; }
266    TStr GetStr() const { TChA ValsStr;
267      for (int i=0; i&lt;Len(); i++) { ValsStr+=&quot; &quot;+ValV[i].GetStr(); }
268      return TStr::Fmt(&quot;Tuple(%d):&quot;, Len())+ValsStr; }
269  };
270  template&lt;class TVal, int NVals&gt;
271  void TTuple&lt;TVal, NVals&gt;::Sort(const bool&amp; Asc) {
272    TVec&lt;TVal, int&gt; V(NVals);
273    for (int i=0; i&lt;NVals; i++) { V.Add(ValV[i]); }
274    V.Sort(Asc);
275    for (int i=0; i&lt;NVals; i++) { ValV[i] = V[i]; }
276  }
277  template&lt;class TVal, int NVals&gt;
278  int TTuple&lt;TVal, NVals&gt;::FindMx() const {
279    TVal MxVal = ValV[0];
280    int ValN = 0;
281    for (int i = 1; i &lt; NVals; i++) {
282      if (MxVal&lt;ValV[i]) {
283        MxVal=ValV[i]; ValN=i;
284      }
285    }
286    return ValN;
287  }
288  template&lt;class TVal, int NVals&gt;
289  int TTuple&lt;TVal, NVals&gt;::FindMn() const {
290    TVal MnVal = ValV[0];
291    int ValN = 0;
292    for (int i = 1; i &lt; NVals; i++) {
293      if (MnVal&gt;ValV[i]) {
294        MnVal=ValV[i]; ValN=i;
295      }
296    }
297    return ValN;
298  }
299  template &lt;class TKey, class TDat&gt;
300  class TKeyDat{
301  public:
302    TKey Key;
303    TDat Dat;
304  public:
305    TKeyDat(): Key(), Dat(){}
306    TKeyDat(const TKeyDat&amp; KeyDat): Key(KeyDat.Key), Dat(KeyDat.Dat){}
307    explicit TKeyDat(const TKey&amp; _Key): Key(_Key), Dat(){}
308    TKeyDat(const TKey&amp; _Key, const TDat&amp; _Dat): Key(_Key), Dat(_Dat){}
309    explicit TKeyDat(TSIn&amp; SIn): Key(SIn), Dat(SIn){}
310    void Save(TSOut&amp; SOut) const {Key.Save(SOut); Dat.Save(SOut);}
311    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
312    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
313    TKeyDat&amp; operator=(const TKeyDat&amp; KeyDat){
314      if (this!=&amp;KeyDat){Key=KeyDat.Key; Dat=KeyDat.Dat;} return *this;}
315    bool operator==(const TKeyDat&amp; KeyDat) const {return Key==KeyDat.Key;}
316    bool operator&lt;(const TKeyDat&amp; KeyDat) const {return Key&lt;KeyDat.Key;}
317    int GetPrimHashCd() const {return Key.GetPrimHashCd();}
318    int GetSecHashCd() const {return Key.GetSecHashCd();}
319  };
320  template &lt;class TKey, class TDat&gt;
321  void GetSwitchedKdV(const TVec&lt;TKeyDat&lt;TKey, TDat&gt;, int&gt;&amp; SrcKdV, TVec&lt;TKeyDat&lt;TDat, TKey&gt;, int&gt;&amp; DstKdV){
322    const int Kds=SrcKdV.Len();
323    DstKdV.Gen(Kds, 0);
324    for (int KdN=0; KdN&lt;Kds; KdN++){
325      const TKeyDat&lt;TKey, TDat&gt;&amp; SrcKd=SrcKdV[KdN];
326      DstKdV.Add(TKeyDat&lt;TDat, TKey&gt;(SrcKd.Dat, SrcKd.Key));
327    }
328  }
329  typedef TKeyDat&lt;TInt, TInt&gt; TIntKd;
330  typedef TKeyDat&lt;TInt, TUInt64&gt; TIntUInt64Kd;
331  typedef TKeyDat&lt;TInt, TFlt&gt; TIntFltKd;
332  typedef TKeyDat&lt;TIntPr, TFlt&gt; TIntPrFltKd;
333  typedef TKeyDat&lt;TInt, TFltPr&gt; TIntFltPrKd;
334  typedef TKeyDat&lt;TInt, TSFlt&gt; TIntSFltKd;
335  typedef TKeyDat&lt;TInt, TStr&gt; TIntStrKd;
336  typedef TKeyDat&lt;TUInt, TInt&gt; TUIntIntKd;
337  typedef TKeyDat&lt;TUInt, TUInt&gt; TUIntKd;
338  typedef TKeyDat&lt;TUInt64, TInt&gt; TUInt64IntKd;
339  typedef TKeyDat&lt;TUInt64, TFlt&gt; TUInt64FltKd;
340  typedef TKeyDat&lt;TUInt64, TStr&gt; TUInt64StrKd;
341  typedef TKeyDat&lt;TFlt, TBool&gt; TFltBoolKd;
342  typedef TKeyDat&lt;TFlt, TInt&gt; TFltIntKd;
343  typedef TKeyDat&lt;TFlt, TUInt64&gt; TFltUInt64Kd;
344  typedef TKeyDat&lt;TFlt, TIntPr&gt; TFltIntPrKd;
345  typedef TKeyDat&lt;TFlt, TUInt&gt; TFltUIntKd;
346  typedef TKeyDat&lt;TFlt, TFlt&gt; TFltKd;
347  typedef TKeyDat&lt;TFlt, TStr&gt; TFltStrKd;
348  typedef TKeyDat&lt;TFlt, TBool&gt; TFltBoolKd;
349  typedef TKeyDat&lt;TFlt, TIntBoolPr&gt; TFltIntBoolPrKd;
350  typedef TKeyDat&lt;TAscFlt, TInt&gt; TAscFltIntKd;
351  typedef TKeyDat&lt;TStr, TBool&gt; TStrBoolKd;
352  typedef TKeyDat&lt;TStr, TInt&gt; TStrIntKd;
353  typedef TKeyDat&lt;TStr, TFlt&gt; TStrFltKd;
354  typedef TKeyDat&lt;TStr, TAscFlt&gt; TStrAscFltKd;
355  typedef TKeyDat&lt;TStr, TStr&gt; TStrKd;
356  template &lt;class TVal1, class TVal2&gt;
357  class TCmpKeyDatByDat {
358  private:
359    bool IsAsc;
360  public:
361    TCmpKeyDatByDat(const bool&amp; AscSort=true) : IsAsc(AscSort) { }
362    bool operator () (const TKeyDat&lt;TVal1, TVal2&gt;&amp; P1, const TKeyDat&lt;TVal1, TVal2&gt;&amp; P2) const {
363      if (IsAsc) { return P1.Dat &lt; P2.Dat; } else { return P2.Dat &lt; P1.Dat; }
364    }
365  };
366  template &lt;class TVal, class TSizeTy = int&gt;
367  class TVec{
368  public:
369    typedef TVal* TIter;  
370  protected:
371    TSizeTy MxVals; 
372    TSizeTy Vals;   
373    TVal* ValT;     
374    bool IsShM; 
375    void Resize(const TSizeTy&amp; _MxVals=-1);
376    TStr GetXOutOfBoundsErrMsg(const TSizeTy&amp; ValN) const;
377  public:
378    TVec(): MxVals(0), Vals(0), ValT(NULL), IsShM(false) {}
379    TVec(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec);
380    explicit TVec(const TSizeTy&amp; _Vals){
381      IsShM = false;
382      IAssert(0&lt;=_Vals); MxVals=Vals=_Vals;
383      if (_Vals==0){ValT=NULL;} else {ValT=new TVal[_Vals];}}
384    TVec(const TSizeTy&amp; _MxVals, const TSizeTy&amp; _Vals){
385      IsShM = false;
386      IAssert((0&lt;=_Vals)&amp;&amp;(_Vals&lt;=_MxVals)); MxVals=_MxVals; Vals=_Vals;
387      if (_MxVals==0){ValT=NULL;} else {ValT=new TVal[_MxVals];}}
388    explicit TVec(TVal *_ValT, const TSizeTy&amp; _Vals):
389      MxVals(-1), Vals(_Vals), ValT(_ValT), IsShM(false){}
390    ~TVec() {if ((ValT!=NULL) &amp;&amp; (MxVals!=-1)) {delete[] ValT;}}
391    explicit TVec(TSIn&amp; SIn): MxVals(0), Vals(0), ValT(NULL), IsShM(false) {Load(SIn);}
392    void LoadShM(TShMIn&amp; ShMIn);
393    template &lt;typename TLoadShMElem&gt;
394    void LoadShM(TShMIn&amp; ShMIn, TLoadShMElem LoadFromShMFn) {
395      if ((ValT!=NULL) &amp;&amp; (MxVals!=-1)) {delete[] ValT;}
396      ShMIn.Load(MxVals);
397      ShMIn.Load(Vals);
398      if (MxVals == 0) {
399        ValT = NULL;
400      } else {
401          ValT=new TVal[MxVals];
402          for (TSizeTy ValN=0; ValN&lt;Vals; ValN++) {
403            LoadFromShMFn(ValT+ValN, ShMIn);
404          }
405      }
406      IsShM = false;
407    }
408    void Load(TSIn&amp; SIn);
409    void Save(TSOut&amp; SOut) const;
410    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
411    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
412    TVec&lt;TVal, TSizeTy&gt;&amp; operator=(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec);
413    TVec&lt;TVal, TSizeTy&gt;&amp; operator+(const TVal&amp; Val){Add(Val); return *this;}
414    bool operator==(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const;
415    bool operator&lt;(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const;
416    const TVal&amp; operator[](const TSizeTy&amp; ValN) const {
417      AssertR((0&lt;=ValN)&amp;&amp;(ValN&lt;Vals), GetXOutOfBoundsErrMsg(ValN));
418      return ValT[ValN];}
419    TVal&amp; operator[](const TSizeTy&amp; ValN){
420      AssertR((0&lt;=ValN)&amp;&amp;(ValN&lt;Vals), GetXOutOfBoundsErrMsg(ValN));
421      return ValT[ValN];}
422    TSizeTy GetMemUsed() const {
423      return TSizeTy(2*sizeof(TSizeTy)+sizeof(TVal*)+MxVals*sizeof(TVal));}
424    TSizeTy GetMemSize() const {
425      return TSizeTy(2*sizeof(TVal)+sizeof(TSizeTy)*Vals);}
426    int GetPrimHashCd() const;
427    int GetSecHashCd() const;
428    void Gen(const TSizeTy&amp; _Vals){ IAssert(0&lt;=_Vals);
429      if (ValT!=NULL &amp;&amp; MxVals!=-1){delete[] ValT;} MxVals=Vals=_Vals;
430      if (MxVals==0){ValT=NULL;} else {ValT=new TVal[MxVals];}}
431    void Gen(const TSizeTy&amp; _MxVals, const TSizeTy&amp; _Vals){ IAssert((0&lt;=_Vals)&amp;&amp;(_Vals&lt;=_MxVals));
432      if (ValT!=NULL  &amp;&amp; MxVals!=-1){delete[] ValT;} MxVals=_MxVals; Vals=_Vals;
433      if (_MxVals==0){ValT=NULL;} else {ValT=new TVal[_MxVals];}}
434    void GenExt(TVal *_ValT, const TSizeTy&amp; _Vals){
435      if (ValT!=NULL &amp;&amp; MxVals!=-1){delete[] ValT;}
436      MxVals=-1; Vals=_Vals; ValT=_ValT;}
437    bool IsExt() const {return MxVals==-1;}
438    void Reserve(const TSizeTy&amp; _MxVals){Resize(_MxVals);}
439    void Reserve(const TSizeTy&amp; _MxVals, const TSizeTy&amp; _Vals){ IAssert((0&lt;=_Vals)&amp;&amp;(_Vals&lt;=_MxVals)); Resize(_MxVals); Vals=_Vals;}
440    void Clr(const bool&amp; DoDel=true, const TSizeTy&amp; NoDelLim=-1);
441    void Trunc(const TSizeTy&amp; _Vals=-1);
442    void Reduce(const TSizeTy&amp; _Vals=-1) {Vals = _Vals;}
443    void Pack();
444    void MoveFrom(TVec&lt;TVal, TSizeTy&gt;&amp; Vec);
445    void CopyUniqueFrom(TVec&lt;TVal, TSizeTy&gt;&amp; Vec, TInt Offset, TInt Sz);
446    void Swap(TVec&lt;TVal, TSizeTy&gt;&amp; Vec);
447    bool Empty() const {return Vals==0;}
448    TSizeTy Len() const {return Vals;}
449    TSizeTy Reserved() const {return MxVals;}
450    const TVal&amp; Last() const {return GetVal(Len()-1);}
451    TVal&amp; Last(){return GetVal(Len()-1);}
452    TSizeTy LastValN() const {return Len()-1;}
453    const TVal&amp; LastLast() const { AssertR(1&lt;Vals, GetXOutOfBoundsErrMsg(Vals-2)); return ValT[Vals-2];}
454    TVal&amp; LastLast(){ AssertR(1&lt;Vals, GetXOutOfBoundsErrMsg(Vals-2)); return ValT[Vals-2];}
455    const TVal&amp; GetRndVal(TRnd&amp; Rnd=TInt::Rnd) const { return GetVal(Rnd.GetUniDevInt(Len())); }
456    TVal&amp; GetRndVal(TRnd&amp; Rnd=TInt::Rnd) { return GetVal(Rnd.GetUniDevInt(Len())); }
457    TIter BegI() const {return ValT;}
458    TIter EndI() const {return ValT+Vals;}
459    TIter GetI(const TSizeTy&amp; ValN) const {return ValT+ValN;}
460    TSizeTy Add(){ AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
461      if (Vals==MxVals){Resize();} return Vals++;}
462    TSizeTy Add(const TVal&amp; Val){ AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
463      if (Vals==MxVals){Resize();} ValT[Vals]=Val; return Vals++;}
464    TSizeTy Add(TVal&amp; Val){ AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
465      if (Vals==MxVals){Resize();} ValT[Vals]=Val; return Vals++;}
466    TSizeTy Add(const TVal&amp; Val, const TSizeTy&amp; ResizeLen){ AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
467      if (Vals==MxVals){Resize(MxVals+ResizeLen);} ValT[Vals]=Val; return Vals++;}
468  #ifdef USE_OPENMP
469    TSizeTy AddMP(const TVal&amp; Val){ const int Idx = __sync_fetch_and_add(&amp;Vals, 1);
470       ValT[Idx]=Val; return Idx;}
471    TSizeTy MoveLastMP(const TVal&amp; Val, int Inc){ const int Idx = __sync_fetch_and_add(&amp;Vals, Inc);
472    return Idx;}
473  #endif
474    TSizeTy AddV(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV);
475    TSizeTy AddSorted(const TVal&amp; Val, const bool&amp; Asc=true, const TSizeTy&amp; _MxVals=-1);
476    TSizeTy AddBackSorted(const TVal&amp; Val, const bool&amp; Asc);
477    TSizeTy AddMerged(const TVal&amp; Val);
478    TSizeTy AddVMerged(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV);
479    TSizeTy AddUnique(const TVal&amp; Val);
480    const TVal&amp; GetVal(const TSizeTy&amp; ValN) const {return operator[](ValN);}
481    TVal&amp; GetVal(const TSizeTy&amp; ValN){return operator[](ValN);}
482    void SetVal(const TSizeTy&amp; ValN, const TVal&amp; Val){
483      EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
484      AssertR((0&lt;=ValN)&amp;&amp;(ValN&lt;Vals), GetXOutOfBoundsErrMsg(ValN)); ValT[ValN] = Val;}
485    void GetSubValV(const TSizeTy&amp; BValN, const TSizeTy&amp; EValN, TVec&lt;TVal, TSizeTy&gt;&amp; ValV) const;
486    void Ins(const TSizeTy&amp; ValN, const TVal&amp; Val);
487    void Del(const TSizeTy&amp; ValN);
488    void Del(const TSizeTy&amp; MnValN, const TSizeTy&amp; MxValN);
489    void DelLast(){Del(Len()-1);}
490    bool DelIfIn(const TVal&amp; Val);
491    void DelAll(const TVal&amp; Val);
492    void PutAll(const TVal&amp; Val);
493    void Swap(const TSizeTy&amp; ValN1, const TSizeTy&amp; ValN2){EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
494      const TVal Val=ValT[ValN1]; ValT[ValN1]=ValT[ValN2]; ValT[ValN2]=Val;}
495    static void SwapI(TIter LVal, TIter RVal){const TVal Val=*LVal; *LVal=*RVal; *RVal=Val;}
496    bool NextPerm();
497    bool PrevPerm();
498    TSizeTy GetPivotValN(const TSizeTy&amp; LValN, const TSizeTy&amp; RValN) const;
499    void BSort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc);
500    void ISort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc);
501    TSizeTy Partition(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc);
502    void QSort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc);
503    void Sort(const bool&amp; Asc=true);
504    bool IsSorted(const bool&amp; Asc=true) const;
505    void Shuffle(TRnd&amp; Rnd);
506    void Reverse();
507    void Reverse(TSizeTy LValN, TSizeTy RValN){ Assert(LValN&gt;=0 &amp;&amp; RValN&lt;Len()); while (LValN &lt; RValN){Swap(LValN++, RValN--);} }
508    void Merge();
509    template &lt;class TCmp&gt;
510    static TIter GetPivotValNCmp(const TIter&amp; BI, const TIter&amp; EI, const TCmp&amp; Cmp) {
511      TSizeTy SubVals=TSizeTy(EI-BI); if (SubVals &gt; TInt::Mx-1) { SubVals = TInt::Mx-1; }
512      const TSizeTy ValN1=TInt::GetRnd(SubVals), ValN2=TInt::GetRnd(SubVals), ValN3=TInt::GetRnd(SubVals);
513      const TVal&amp; Val1 = *(BI+ValN1);  const TVal&amp; Val2 = *(BI+ValN2); const TVal&amp; Val3 = *(BI+ValN3);
514      if (Cmp(Val1, Val2)) {
515        if (Cmp(Val2, Val3)) return BI+ValN2;
516        else if (Cmp(Val3, Val1)) return BI+ValN1;
517        else return BI+ValN3;
518      } else {
519        if (Cmp(Val1, Val3)) return BI+ValN1;
520        else if (Cmp(Val3, Val2)) return BI+ValN2;
521        else return BI+ValN3; } }
522    template &lt;class TCmp&gt;
523    static TIter PartitionCmp(TIter BI, TIter EI, const TVal Pivot, const TCmp&amp; Cmp) {
524      forever {
525        while (Cmp(*BI, Pivot)){++BI;}  --EI;
526        while (Cmp(Pivot, *EI)){--EI;}
527        if (!(BI&lt;EI)){return BI;}  SwapI(BI, EI);  ++BI; } }
528    template &lt;class TCmp&gt;
529    static void BSortCmp(TIter BI, TIter EI, const TCmp&amp; Cmp) {
530      for (TIter i = BI; i != EI; ++i) {
531        for (TIter j = EI-1; j != i; --j) {
532          if (Cmp(*j, *(j-1))) { SwapI(j, j-1); } } } }
533    template &lt;class TCmp&gt;
534    static void ISortCmp(TIter BI, TIter EI, const TCmp&amp; Cmp) {
535      if (BI + 1 &lt; EI) {
536        for (TIter i = BI, j; i != EI; ++i) { TVal Tmp=*i;  j=i;
537          while (j &gt; BI &amp;&amp; Cmp(Tmp, *(j-1))) { *j = *(j-1); --j; } *j=Tmp; } } }
538    template &lt;class TCmp&gt;
539    static void QSortCmp(TIter BI, TIter EI, const TCmp&amp; Cmp) {
540      if (BI + 1 &lt; EI) {
541        if (EI - BI &lt; 20) { ISortCmp(BI, EI, Cmp); }
542        else { const TVal Val = *GetPivotValNCmp(BI, EI, Cmp);
543          TIter Split = PartitionCmp(BI, EI, Val, Cmp);
544          QSortCmp(BI, Split, Cmp);  QSortCmp(Split, EI, Cmp); } } }
545    template &lt;class TCmp&gt;
546    void SortCmp(const TCmp&amp; Cmp){ QSortCmp(BegI(), EndI(), Cmp);}
547    template &lt;class TCmp&gt;
548    bool IsSortedCmp(const TCmp&amp; Cmp) const {
549      if (EndI() == BegI()) return true;
550      for (TIter i = BegI(); i != EndI()-1; ++i) {
551        if (Cmp(*(i+1), *i)){return false;} } return true; }
552    void Intrs(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV);
553    void Union(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV);
554    void Diff(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV);
555    void Intrs(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const;
556    void Union(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const;
557    void Diff(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const;
558    TSizeTy IntrsLen(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV) const;
559    TSizeTy UnionLen(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV) const;
560    TSizeTy Count(const TVal&amp; Val) const;
561    TSizeTy SearchBin(const TVal&amp; Val) const;
562    TSizeTy SearchBin(const TVal&amp; Val, TSizeTy&amp; InsValN) const;
563    TSizeTy SearchBinLeft(const TVal&amp; Val, TSizeTy&amp; InsValN) const;
564    TSizeTy SearchForw(const TVal&amp; Val, const TSizeTy&amp; BValN=0) const;
565    TSizeTy SearchBack(const TVal&amp; Val) const;
566    TSizeTy SearchVForw(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, const TSizeTy&amp; BValN=0) const;
567    bool IsIn(const TVal&amp; Val) const {return SearchForw(Val)!=-1;}
568    bool IsIn(const TVal&amp; Val, TSizeTy&amp; ValN) const { ValN=SearchForw(Val); return ValN!=-1;}
569    bool IsInBin(const TVal&amp; Val) const {return SearchBin(Val)!=-1;}
570    const TVal&amp; GetDat(const TVal&amp; Val) const { return GetVal(SearchForw(Val));}
571    TVal&amp; GetAddDat(const TVal&amp; Val){ AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
572      const TSizeTy ValN=SearchForw(Val); if (ValN==-1){Add(Val); return Last();} else {return GetVal(ValN);}}
573    TSizeTy GetMxValN() const;
574    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1){
575      TVec&lt;TVal, TSizeTy&gt; V(1, 0); V.Add(Val1); return V;}
576    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2){
577      TVec&lt;TVal, TSizeTy&gt; V(2, 0); V.Add(Val1); V.Add(Val2); return V;}
578    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3){
579      TVec&lt;TVal, TSizeTy&gt; V(3, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); return V;}
580    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4){
581      TVec&lt;TVal, TSizeTy&gt; V(4, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); return V;}
582    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4, const TVal&amp; Val5){
583      TVec&lt;TVal, TSizeTy&gt; V(5, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); return V;}
584    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4, const TVal&amp; Val5, const TVal&amp; Val6){
585      TVec&lt;TVal, TSizeTy&gt; V(6, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); return V;}
586    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4, const TVal&amp; Val5, const TVal&amp; Val6, const TVal&amp; Val7){
587      TVec&lt;TVal, TSizeTy&gt; V(7, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); return V;}
588    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4, const TVal&amp; Val5, const TVal&amp; Val6, const TVal&amp; Val7, const TVal&amp; Val8){
589      TVec&lt;TVal, TSizeTy&gt; V(8, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); V.Add(Val8); return V;}
590    static TVec&lt;TVal, TSizeTy&gt; GetV(const TVal&amp; Val1, const TVal&amp; Val2, const TVal&amp; Val3, const TVal&amp; Val4, const TVal&amp; Val5, const TVal&amp; Val6, const TVal&amp; Val7, const TVal&amp; Val8, const TVal&amp; Val9){
591      TVec&lt;TVal, TSizeTy&gt; V(9, 0); V.Add(Val1); V.Add(Val2); V.Add(Val3); V.Add(Val4); V.Add(Val5); V.Add(Val6); V.Add(Val7); V.Add(Val8); V.Add(Val9); return V;}
592  };
593  template &lt;class TVal, class TSizeTy&gt;
594  void TVec&lt;TVal, TSizeTy&gt;::Resize(const TSizeTy&amp; _MxVals){
595    IAssertR(MxVals!=-1 || IsShM, TStr::Fmt(&quot;Can not increase the capacity of the vector. %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, GetTypeNm(*this).CStr()).CStr());
596    IAssertR(MxVals!=(TInt::Mx-1024), TStr::Fmt(&quot;Buffer size at maximum. %s. [Program refuses to allocate more memory. Solution-1: Send your test case to developers.]&quot;, GetTypeNm(*this).CStr()).CStr());
597    TSizeTy OldMxVals = MxVals;
598    if (MxVals == -1) {MxVals = Vals;}
599    if (_MxVals==-1){
600      if (Vals==0){MxVals=16;} else {MxVals*=2;}
601    } else {
602      if (_MxVals&lt;=MxVals){return;} else {MxVals=_MxVals;}
603    }
604    if (MxVals &lt; 0) {
605      MxVals = TInt::Mx-1024;
606    }
607    if (ValT==NULL){
608      try {
609        ValT=new TVal[MxVals];
610      }
611      catch (std::exception Ex){
612        FailR(TStr::Fmt(&quot;TVec::Resize: %s, Length:%s, Capacity:%s, New capacity:%s, Type:%s [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;,
613          Ex.what(), TInt::GetStr(Vals).CStr(), TInt::GetStr(MxVals).CStr(), TInt::GetStr(_MxVals).CStr(), GetTypeNm(*this).CStr()).CStr());}
614    } else {
615      TVal* NewValT = NULL;
616      try {
617        NewValT=new TVal[MxVals];
618      }
619      catch (std::exception Ex){
620        FailR(TStr::Fmt(&quot;TVec::Resize: %s, Length:%s, Capacity:%s, New capacity:%s, Type:%s [Program failed to allocate more memory. Solution-1: Get a bigger machine and a 64-bit compiler.]&quot;,
621          Ex.what(), TInt::GetStr(Vals).CStr(), TInt::GetStr(MxVals).CStr(), TInt::GetStr(_MxVals).CStr(), GetTypeNm(*this).CStr()).CStr());}
622      IAssert(NewValT!=NULL);
623      for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){NewValT[ValN]=ValT[ValN];}
624      if (OldMxVals != -1) {delete[] ValT;} ValT=NewValT;
625    }
626    IsShM = false;
627  }
628  template &lt;class TVal, class TSizeTy&gt;
629  TStr TVec&lt;TVal, TSizeTy&gt;::GetXOutOfBoundsErrMsg(const TSizeTy&amp; ValN) const {
630    return TStr()+
631    &quot;Index:&quot;+TInt::GetStr(ValN)+
632    &quot; Vals:&quot;+TInt::GetStr(Vals)+
633    &quot; MxVals:&quot;+TInt::GetStr(MxVals)+
634    &quot; Type:&quot;+GetTypeNm(*this);
635  }
636  template &lt;class TVal, class TSizeTy&gt;
637  TVec&lt;TVal, TSizeTy&gt;::TVec(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec){
638    MxVals=Vec.MxVals;
639    Vals=Vec.Vals;
640    if (MxVals==0) {ValT=NULL;} else {ValT=new TVal[MxVals];}
641    for (TSizeTy ValN=0; ValN&lt;Vec.Vals; ValN++){ValT[ValN]=Vec.ValT[ValN];}
642    IsShM = false;
643  }
644  template &lt;class TVal, class TSizeTy&gt;
645  void TVec&lt;TVal, TSizeTy&gt;::LoadShM(TShMIn&amp; ShMIn) {
646    if ((ValT!=NULL) &amp;&amp; (MxVals!=-1)) {delete[] ValT;}
647    ShMIn.Load(MxVals);
648    MxVals = -1;
649    ShMIn.Load(Vals);
650    if (MxVals == 0) {
651      ValT = NULL;
652    } else {
653        ValT = (TVal*)(ShMIn.AdvanceCursor(Vals*sizeof(TVal)));
654        IsShM = true;
655    }
656  }
657  template &lt;class TVal, class TSizeTy&gt;
658  void TVec&lt;TVal, TSizeTy&gt;::Load(TSIn&amp; SIn){
659    if ( (ValT!=NULL) &amp;&amp; (MxVals!=-1)) {delete[] ValT;}
660    SIn.Load(MxVals); SIn.Load(Vals); MxVals=Vals;
661    if ( MxVals==0 ){ValT=NULL;} else {ValT=new TVal[MxVals];}
662    for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){ValT[ValN]=TVal(SIn);}
663  }
664  template &lt;class TVal, class TSizeTy&gt;
665  void TVec&lt;TVal, TSizeTy&gt;::Save(TSOut&amp; SOut) const {
666    if (MxVals!=-1){SOut.Save(MxVals);} else {SOut.Save(Vals);}
667    SOut.Save(Vals);
668    for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){ValT[ValN].Save(SOut);}
669  }
670  template &lt;class TVal, class TSizeTy&gt;
671  TVec&lt;TVal, TSizeTy&gt;&amp; TVec&lt;TVal, TSizeTy&gt;::operator=(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec){
672    if (this!=&amp;Vec){
673      if ((ValT!=NULL)&amp;&amp;(MxVals!=-1)){delete[] ValT;}
674      MxVals=Vals=Vec.Vals;
675      if (MxVals==0){ValT=NULL;} else {ValT=new TVal[MxVals];}
676      for (TSizeTy ValN=0; ValN&lt;Vec.Vals; ValN++){ValT[ValN]=Vec.ValT[ValN];}
677    }
678    return *this;
679  }
680  template &lt;class TVal, class TSizeTy&gt;
681  bool TVec&lt;TVal, TSizeTy&gt;::operator==(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const {
682    if (this==&amp;Vec){return true;}
683    if (Len()!=Vec.Len()){return false;}
684    for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){
685      if (ValT[ValN]!=Vec.ValT[ValN]){return false;}}
686    return true;
687  }
688  template &lt;class TVal, class TSizeTy&gt;
689  bool TVec&lt;TVal, TSizeTy&gt;::operator&lt;(const TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const {
690    if (this==&amp;Vec){return false;}
691    if (Len()==Vec.Len()){
692      for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){
693        if (ValT[ValN]&lt;Vec.ValT[ValN]){return true;}
694        else if (ValT[ValN]&gt;Vec.ValT[ValN]){return false;}
695        else {}
696      }
697      return false;
698    } else {
699      return Len()&lt;Vec.Len();
700    }
701  }
702  template &lt;class TVal, class TSizeTy&gt;
703  int TVec&lt;TVal, TSizeTy&gt;::GetPrimHashCd() const {
704    int hc = 0;
705    for (TSizeTy i=0; i&lt;Vals; i++){
706      hc = TPairHashImpl::GetHashCd(hc, ValT[i].GetPrimHashCd());
707    }
708    return hc;
709  }
710  template &lt;class TVal, class TSizeTy&gt;
711  int TVec&lt;TVal, TSizeTy&gt;::GetSecHashCd() const {
712    int hc = 0;
713    for (TSizeTy i=0; i&lt;Vals; i++){
714      hc = TPairHashImpl::GetHashCd(hc, ValT[i].GetSecHashCd());
715    }
716    if (Vals &gt; 0) {
717      hc = TPairHashImpl::GetHashCd(hc, ValT[0].GetSecHashCd()); }
718    return hc;
719  }
720  template &lt;class TVal, class TSizeTy&gt;
721  void TVec&lt;TVal, TSizeTy&gt;::Clr(const bool&amp; DoDel, const TSizeTy&amp; NoDelLim){
722    if ((DoDel)||((!DoDel)&amp;&amp;(NoDelLim!=-1)&amp;&amp;(MxVals&gt;NoDelLim))){
723      if ((ValT!=NULL)&amp;&amp;(MxVals!=-1)){delete[] ValT;}
724      MxVals=Vals=0; ValT=NULL;
725    } else {
726      IAssertR(MxVals!=-1 || IsShM, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
727      Vals=0;
728    }
729  }
730  template &lt;class TVal, class TSizeTy&gt;
731  void TVec&lt;TVal, TSizeTy&gt;::Trunc(const TSizeTy&amp; _Vals){
732    EAssertR(!(MxVals==-1 &amp;&amp; IsShM), &quot;Cannot truncate a shared memory vector&quot;);
733    IAssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
734    IAssert((_Vals==-1)||(_Vals&gt;=0));
735    if ((_Vals!=-1)&amp;&amp;(_Vals&gt;=Vals)){
736      return;
737    } else
738      if (((_Vals==-1)&amp;&amp;(Vals==0))||(_Vals==0)){
739        if (ValT!=NULL){delete[] ValT;}
740        MxVals=Vals=0; ValT=NULL;
741      } else {
742        if (_Vals==-1){
743          if (MxVals==Vals){return;} else {MxVals=Vals;}
744        } else {
745          MxVals=Vals=_Vals;
746        }
747        TVal* NewValT=new TVal[MxVals];
748        IAssert(NewValT!=NULL);
749        for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){NewValT[ValN]=ValT[ValN];}
750        delete[] ValT; ValT=NewValT;
751      }
752  }
753  template &lt;class TVal, class TSizeTy&gt;
754  void TVec&lt;TVal, TSizeTy&gt;::Pack(){
755    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot pack accessed shared memory&quot;);
756    IAssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
757    if (Vals==0){
758      if (ValT!=NULL){delete[] ValT;} ValT=NULL;
759    } else
760      if (Vals&lt;MxVals){
761        MxVals=Vals;
762        TVal* NewValT=new TVal[MxVals];
763        IAssert(NewValT!=NULL);
764        for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){NewValT[ValN]=ValT[ValN];}
765        delete[] ValT; ValT=NewValT;
766      }
767  }
768  template &lt;class TVal, class TSizeTy&gt;
769  void TVec&lt;TVal, TSizeTy&gt;::MoveFrom(TVec&lt;TVal, TSizeTy&gt;&amp; Vec){
770    if (this!=&amp;Vec){
771      if (ValT!=NULL &amp;&amp; MxVals!=-1){delete[] ValT;}
772      MxVals=Vec.MxVals; Vals=Vec.Vals; ValT=Vec.ValT;
773      Vec.MxVals=0; Vec.Vals=0; Vec.ValT=NULL;
774    }
775  }
776  template &lt;class TVal, class TSizeTy&gt;
777  void TVec&lt;TVal, TSizeTy&gt;::CopyUniqueFrom(TVec&lt;TVal, TSizeTy&gt;&amp; Vec, TInt Offset, TInt Sz){
778    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
779    if (this!=&amp;Vec){
780      if (ValT!=NULL &amp;&amp; MxVals!=-1 &amp;&amp; MxVals &lt; Sz){
781        delete[] ValT;
782        ValT=new TVal[Sz];
783      }
784      if (Sz == 0) { Vals = 0; return; }
785      ValT[0] = Vec.ValT[Offset];
786      Vals = 1;
787      for (TSizeTy ValN=1; ValN&lt;Sz; ValN++){
788        if (ValT[Vals-1] != Vec.ValT[Offset+ValN]) {
789          ValT[Vals++] = Vec.ValT[Offset+ValN];
790        }
791      }
792    }
793  }
794  template &lt;class TVal, class TSizeTy&gt;
795  void TVec&lt;TVal, TSizeTy&gt;::Swap(TVec&lt;TVal, TSizeTy&gt;&amp; Vec){
796    if (this!=&amp;Vec){
797      ::Swap(MxVals, Vec.MxVals);
798      ::Swap(Vals, Vec.Vals);
799      ::Swap(ValT, Vec.ValT);
800    }
801  }
802  template &lt;class TVal, class TSizeTy&gt;
803  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddV(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV){
804    AssertR(MxVals!=-1 || IsShM, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
805    for (TSizeTy ValN=0; ValN&lt;ValV.Vals; ValN++){Add(ValV[ValN]);}
806    return Len();
807  }
808  template &lt;class TVal, class TSizeTy&gt;
809  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddSorted(const TVal&amp; Val, const bool&amp; Asc, const TSizeTy&amp; _MxVals){
810    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
811    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
812    TSizeTy ValN=Add(Val);
813    if (Asc){
814      while ((ValN&gt;0)&amp;&amp;(ValT[ValN]&lt;ValT[ValN-1])){
815        Swap(ValN, ValN-1); ValN--;}
816    } else {
817      while ((ValN&gt;0)&amp;&amp;(ValT[ValN]&gt;ValT[ValN-1])){
818        Swap(ValN, ValN-1); ValN--;}
819    }
820    if ((_MxVals!=-1)&amp;&amp;(Len()&gt;_MxVals)){Del(_MxVals, Len()-1);}
821    return ValN;
822  }
823  template &lt;class TVal, class TSizeTy&gt;
824  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddBackSorted(const TVal&amp; Val, const bool&amp; Asc){
825    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
826    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
827    Add();
828    TSizeTy ValN=Vals-2;
829    while ((ValN&gt;=0)&amp;&amp;((Asc&amp;&amp;(Val&lt;ValT[ValN]))||(!Asc&amp;&amp;(Val&gt;ValT[ValN])))){
830      ValT[ValN+1]=ValT[ValN]; ValN--;}
831    ValT[ValN+1]=Val;
832    return ValN+1;
833  }
834  template &lt;class TVal, class TSizeTy&gt;
835  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddMerged(const TVal&amp; Val){
836    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
837    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
838    TSizeTy ValN=SearchBin(Val);
839    if (ValN==-1){return AddSorted(Val);}
840    else {GetVal(ValN)=Val; return -1;}
841  }
842  template &lt;class TVal, class TSizeTy&gt;
843  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddVMerged(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV){
844    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
845    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
846    for (TSizeTy ValN=0; ValN&lt;ValV.Vals; ValN++){AddMerged(ValV[ValN]);}
847    return Len();
848  }
849  template &lt;class TVal, class TSizeTy&gt;
850  TSizeTy TVec&lt;TVal, TSizeTy&gt;::AddUnique(const TVal&amp; Val){
851    AssertR(MxVals!=-1 || IsShM, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
852    TSizeTy ValN=SearchForw(Val);
853    if (ValN==-1){return Add(Val);}
854    else {GetVal(ValN)=Val; return -1;}
855  }
856  template &lt;class TVal, class TSizeTy&gt;
857  void TVec&lt;TVal, TSizeTy&gt;::GetSubValV(const TSizeTy&amp; _BValN, const TSizeTy&amp; _EValN, TVec&lt;TVal, TSizeTy&gt;&amp; SubValV) const {
858    const TSizeTy BValN=TInt::GetInRng(_BValN, 0, Len()-1);
859    const TSizeTy EValN=TInt::GetInRng(_EValN, 0, Len()-1);
860    const TSizeTy SubVals=TInt::GetMx(0, EValN-BValN+1);
861    SubValV.Gen(SubVals, 0);
862    for (TSizeTy ValN=BValN; ValN&lt;=EValN; ValN++){
863      SubValV.Add(GetVal(ValN));}
864  }
865  template &lt;class TVal, class TSizeTy&gt;
866  void TVec&lt;TVal, TSizeTy&gt;::Ins(const TSizeTy&amp; ValN, const TVal&amp; Val){
867    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
868    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
869    Add();  Assert((0&lt;=ValN)&amp;&amp;(ValN&lt;Vals));
870    for (TSizeTy MValN=Vals-2; MValN&gt;=ValN; MValN--){ValT[MValN+1]=ValT[MValN];}
871    ValT[ValN]=Val;
872  }
873  template &lt;class TVal, class TSizeTy&gt;
874  void TVec&lt;TVal, TSizeTy&gt;::Del(const TSizeTy&amp; ValN){
875    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
876    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
877    Assert((0&lt;=ValN)&amp;&amp;(ValN&lt;Vals));
878    for (TSizeTy MValN=ValN+1; MValN&lt;Vals; MValN++){
879      ValT[MValN-1]=ValT[MValN];}
880    ValT[--Vals]=TVal();
881  }
882  template &lt;class TVal, class TSizeTy&gt;
883  void TVec&lt;TVal, TSizeTy&gt;::Del(const TSizeTy&amp; MnValN, const TSizeTy&amp; MxValN){
884    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
885    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
886    Assert((0&lt;=MnValN)&amp;&amp;(MnValN&lt;Vals)&amp;&amp;(0&lt;=MxValN)&amp;&amp;(MxValN&lt;Vals));
887    Assert(MnValN&lt;=MxValN);
888    for (TSizeTy ValN=MxValN+1; ValN&lt;Vals; ValN++){
889      ValT[MnValN+ValN-MxValN-1]=ValT[ValN];}
890    for (TSizeTy ValN=Vals-MxValN+MnValN-1; ValN&lt;Vals; ValN++){
891      ValT[ValN]=TVal();}
892    Vals-=MxValN-MnValN+1;
893  }
894  template &lt;class TVal, class TSizeTy&gt;
895  bool TVec&lt;TVal, TSizeTy&gt;::DelIfIn(const TVal&amp; Val){
896    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
897    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
898    TSizeTy ValN=SearchForw(Val);
899    if (ValN!=-1){Del(ValN); return true;}
900    else {return false;}
901  }
902  template &lt;class TVal, class TSizeTy&gt;
903  void TVec&lt;TVal, TSizeTy&gt;::DelAll(const TVal&amp; Val){
904    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
905    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
906    TSizeTy ValN;
907    while ((ValN=SearchForw(Val))!=-1){Del(ValN);}
908  }
909  template &lt;class TVal, class TSizeTy&gt;
910  void TVec&lt;TVal, TSizeTy&gt;::PutAll(const TVal&amp; Val){
911    EAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
912    for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){ValT[ValN]=Val;}
913  }
914  template &lt;class TVal, class TSizeTy&gt;
915  void TVec&lt;TVal, TSizeTy&gt;::BSort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc){
916    for (TSizeTy ValN1=MnLValN; ValN1&lt;=MxRValN; ValN1++){
917      for (TSizeTy ValN2=MxRValN; ValN2&gt;ValN1; ValN2--){
918        if (Asc){
919          if (ValT[ValN2]&lt;ValT[ValN2-1]){Swap(ValN2, ValN2-1);}
920        } else {
921          if (ValT[ValN2]&gt;ValT[ValN2-1]){Swap(ValN2, ValN2-1);}
922        }
923      }
924    }
925  }
926  template &lt;class TVal, class TSizeTy&gt;
927  void TVec&lt;TVal, TSizeTy&gt;::ISort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc){
928    if (MnLValN&lt;MxRValN){
929      for (TSizeTy ValN1=MnLValN+1; ValN1&lt;=MxRValN; ValN1++){
930        TVal Val=ValT[ValN1]; TSizeTy ValN2=ValN1;
931        if (Asc){
932          while ((ValN2&gt;MnLValN)&amp;&amp;(ValT[ValN2-1]&gt;Val)){
933            ValT[ValN2]=ValT[ValN2-1]; ValN2--;}
934        } else {
935          while ((ValN2&gt;MnLValN)&amp;&amp;(ValT[ValN2-1]&lt;Val)){
936            ValT[ValN2]=ValT[ValN2-1]; ValN2--;}
937        }
938        ValT[ValN2]=Val;
939      }
940    }
941  }
942  template &lt;class TVal, class TSizeTy&gt;
943  TSizeTy TVec&lt;TVal, TSizeTy&gt;::GetPivotValN(const TSizeTy&amp; LValN, const TSizeTy&amp; RValN) const {
944    TSizeTy SubVals=RValN-LValN+1;
945    if (SubVals &gt; TInt::Mx-1) { SubVals = TInt::Mx-1; }
946    const TSizeTy ValN1=LValN+TInt::GetRnd(int(SubVals));
947    const TSizeTy ValN2=LValN+TInt::GetRnd(int(SubVals));
948    const TSizeTy ValN3=LValN+TInt::GetRnd(int(SubVals));
949    const TVal&amp; Val1=ValT[ValN1];
950    const TVal&amp; Val2=ValT[ValN2];
951    const TVal&amp; Val3=ValT[ValN3];
952    if (Val1&lt;Val2){
953      if (Val2&lt;Val3){return ValN2;}
954      else if (Val3&lt;Val1){return ValN1;}
955      else {return ValN3;}
956    } else {
957      if (Val1&lt;Val3){return ValN1;}
958      else if (Val3&lt;Val2){return ValN2;}
959      else {return ValN3;}
960    }
961  }
962  template &lt;class TVal, class TSizeTy&gt;
963  TSizeTy TVec&lt;TVal, TSizeTy&gt;::Partition(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc){
964    TSizeTy PivotValN=GetPivotValN(MnLValN, MxRValN);
965    Swap(PivotValN, MnLValN);
966    TVal PivotVal=ValT[MnLValN];
967    TSizeTy LValN=MnLValN-1;  TSizeTy RValN=MxRValN+1;
968    forever {
969      if (Asc){
970        do {RValN--;} while (ValT[RValN]&gt;PivotVal);
971        do {LValN++;} while (ValT[LValN]&lt;PivotVal);
972      } else {
973        do {RValN--;} while (ValT[RValN]&lt;PivotVal);
974        do {LValN++;} while (ValT[LValN]&gt;PivotVal);
975      }
976      if (LValN&lt;RValN){Swap(LValN, RValN);}
977      else {return RValN;}
978    };
979  }
980  template &lt;class TVal, class TSizeTy&gt;
981  void TVec&lt;TVal, TSizeTy&gt;::QSort(const TSizeTy&amp; MnLValN, const TSizeTy&amp; MxRValN, const bool&amp; Asc){
982    if (MnLValN&lt;MxRValN){
983      if (MxRValN-MnLValN&lt;20){
984        ISort(MnLValN, MxRValN, Asc);
985      } else {
986        TSizeTy SplitValN=Partition(MnLValN, MxRValN, Asc);
987        QSort(MnLValN, SplitValN, Asc);
988        QSort(SplitValN+1, MxRValN, Asc);
989      }
990    }
991  }
992  template &lt;class TVal, class TSizeTy&gt;
993  void TVec&lt;TVal, TSizeTy&gt;::Sort(const bool&amp; Asc){
994    QSort(0, Len()-1, Asc);
995  }
996  template &lt;class TVal, class TSizeTy&gt;
997  bool TVec&lt;TVal, TSizeTy&gt;::IsSorted(const bool&amp; Asc) const {
998    if (Asc){
999      for (TSizeTy ValN=0; ValN&lt;Vals-1; ValN++){
1000        if (ValT[ValN]&gt;ValT[ValN+1]){return false;}}
1001    } else {
1002      for (TSizeTy ValN=0; ValN&lt;Vals-1; ValN++){
1003        if (ValT[ValN]&lt;ValT[ValN+1]){return false;}}
1004    }
1005    return true;
1006  }
1007  template &lt;class TVal, class TSizeTy&gt;
1008  void TVec&lt;TVal, TSizeTy&gt;::Shuffle(TRnd&amp; Rnd){
1009    if (Len() &lt; TInt::Mx) {
1010      for (TSizeTy ValN=0; ValN&lt;Vals-1; ValN++){
1011        const int Range = int(Vals-ValN);
1012        Swap(ValN, ValN+Rnd.GetUniDevInt(Range));
1013      }
1014    } else {
1015      for (TSizeTy ValN=0; ValN&lt;Vals-1; ValN++){
1016        const TSizeTy Range = Vals-ValN;
1017        Swap(ValN, TSizeTy(ValN+Rnd.GetUniDevInt64(Range)));
1018      }
1019    }
1020  }
1021  template &lt;class TVal, class TSizeTy&gt;
1022  void TVec&lt;TVal, TSizeTy&gt;::Reverse(){
1023    for (TSizeTy ValN=0; ValN&lt;Vals/2; ValN++){
1024      Swap(ValN, Vals-ValN-1);}
1025  }
1026  template &lt;class TVal, class TSizeTy&gt;
1027  void TVec&lt;TVal, TSizeTy&gt;::Merge(){
1028    IAssertR(!(IsShM &amp;&amp; (MxVals == -1)), &quot;Cannot write to shared memory&quot;);
1029    AssertR(MxVals!=-1, &quot;This vector was obtained from TVecPool. Such vectors cannot change its size!&quot;);
1030    TVec&lt;TVal, TSizeTy&gt; SortedVec(*this); SortedVec.Sort();
1031    Clr();
1032    for (TSizeTy ValN=0; ValN&lt;SortedVec.Len(); ValN++){
1033      if ((ValN==0)||(SortedVec[ValN-1]!=SortedVec[ValN])){
1034        Add(SortedVec[ValN]);}
1035    }
1036  }
1037  template &lt;class TVal, class TSizeTy&gt;
1038  bool TVec&lt;TVal, TSizeTy&gt;::NextPerm() {
1039    TSizeTy First = 0, Last = Len(), Next = Len()-1;
1040    if (Last &lt; 2) return false;
1041    for(; ; ) {
1042      TSizeTy Next1 = Next;
1043      if (GetVal(--Next) &lt; GetVal(Next1)) { 
1044        TSizeTy Mid = Last;
1045        for (; GetVal(Next) &gt;= GetVal(--Mid); ) { }
1046        Swap(Next, Mid);
1047        Reverse(Next1, Last-1);
1048        return true;
1049      }
1050      if (Next == First) { 
1051        Reverse();
1052        return false;
1053      }
1054    }
1055  }
1056  template &lt;class TVal, class TSizeTy&gt;
1057  bool TVec&lt;TVal, TSizeTy&gt;::PrevPerm() {
1058    TSizeTy First = 0, Last = Len(), Next = Len()-1;
1059    if (Last &lt; 2) return false;
1060    for(; ; ) {
1061      TSizeTy Next1 = Next;
1062      if (GetVal(--Next) &gt;= GetVal(Next1)) { 
1063        TSizeTy Mid = Last;
1064        for (; GetVal(Next) &lt; GetVal(--Mid); ) { }
1065        Swap(Next, Mid);
1066        Reverse(Next1, Last);
1067        return true;
1068      }
1069      if (Next == First) { 
1070        Reverse();
1071        return false;
1072      }
1073    }
1074  }
1075  template &lt;class TVal, class TSizeTy&gt;
1076  void TVec&lt;TVal, TSizeTy&gt;::Intrs(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV){
1077    TVec&lt;TVal, TSizeTy&gt; IntrsVec;
1078    Intrs(ValV, IntrsVec);
1079    MoveFrom(IntrsVec);
1080  }
1081  template &lt;class TVal, class TSizeTy&gt;
1082  void TVec&lt;TVal, TSizeTy&gt;::Union(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV){
1083    TVec&lt;TVal, TSizeTy&gt; UnionVec;
1084    Union(ValV, UnionVec);
1085    MoveFrom(UnionVec);
1086  }
1087  template &lt;class TVal, class TSizeTy&gt;
1088  void TVec&lt;TVal, TSizeTy&gt;::Diff(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV){
1089    TVec&lt;TVal, TSizeTy&gt; DiffVec;
1090    Diff(ValV, DiffVec);
1091    MoveFrom(DiffVec);
1092  }
1093  template &lt;class TVal, class TSizeTy&gt;
1094  void TVec&lt;TVal, TSizeTy&gt;::Intrs(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const {
1095    DstValV.Clr();
1096    TSizeTy ValN1=0, ValN2=0;
1097    while ((ValN1&lt;Len())&amp;&amp;(ValN2&lt;ValV.Len())){
1098      const TVal&amp; Val1=GetVal(ValN1);
1099      while ((ValN2&lt;ValV.Len())&amp;&amp;(Val1&gt;ValV.GetVal(ValN2))){
1100        ValN2++;}
1101      if ((ValN2&lt;ValV.Len())&amp;&amp;(Val1==ValV.GetVal(ValN2))){
1102        DstValV.Add(Val1); ValN2++;}
1103      ValN1++;
1104    }
1105  }
1106  template &lt;class TVal, class TSizeTy&gt;
1107  void TVec&lt;TVal, TSizeTy&gt;::Union(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const {
1108    DstValV.Gen(TInt::GetMx(Len(), ValV.Len()), 0);
1109    TSizeTy ValN1=0, ValN2=0;
1110    while ((ValN1&lt;Len())&amp;&amp;(ValN2&lt;ValV.Len())){
1111      const TVal&amp; Val1=GetVal(ValN1);
1112      const TVal&amp; Val2=ValV.GetVal(ValN2);
1113      if (Val1&lt;Val2){DstValV.Add(Val1); ValN1++;}
1114      else if (Val1&gt;Val2){DstValV.Add(Val2); ValN2++;}
1115      else {DstValV.Add(Val1); ValN1++; ValN2++;}
1116    }
1117    for (TSizeTy RestValN1=ValN1; RestValN1&lt;Len(); RestValN1++){
1118      DstValV.Add(GetVal(RestValN1));}
1119    for (TSizeTy RestValN2=ValN2; RestValN2&lt;ValV.Len(); RestValN2++){
1120      DstValV.Add(ValV.GetVal(RestValN2));}
1121  }
1122  template &lt;class TVal, class TSizeTy&gt;
1123  void TVec&lt;TVal, TSizeTy&gt;::Diff(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, TVec&lt;TVal, TSizeTy&gt;&amp; DstValV) const {
1124    DstValV.Clr();
1125    TSizeTy ValN1=0, ValN2=0;
1126    while (ValN1&lt;Len() &amp;&amp; ValN2&lt;ValV.Len()) {
1127      const TVal&amp; Val1 = GetVal(ValN1);
1128      while (ValN2&lt;ValV.Len() &amp;&amp; Val1&gt;ValV.GetVal(ValN2)) ValN2++;
1129      if (ValN2&lt;ValV.Len()) {
1130        if (Val1!=ValV.GetVal(ValN2)) { DstValV.Add(Val1); }
1131        ValN1++;
1132      }
1133    }
1134    for (TSizeTy RestValN1=ValN1; RestValN1&lt;Len(); RestValN1++){
1135      DstValV.Add(GetVal(RestValN1));}
1136  }
1137  template &lt;class TVal, class TSizeTy&gt;
1138  TSizeTy TVec&lt;TVal, TSizeTy&gt;::IntrsLen(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV) const {
1139    TSizeTy Cnt=0, ValN1=0, ValN2=0;
1140    while ((ValN1&lt;Len())&amp;&amp;(ValN2&lt;ValV.Len())){
1141      const TVal&amp; Val1=GetVal(ValN1);
1142      while ((ValN2&lt;ValV.Len())&amp;&amp;(Val1&gt;ValV.GetVal(ValN2))){
1143        ValN2++;}
1144      if ((ValN2&lt;ValV.Len())&amp;&amp;(Val1==ValV.GetVal(ValN2))){
1145        ValN2++; Cnt++;}
1146      ValN1++;
1147    }
1148    return Cnt;
1149  }
1150  template &lt;class TVal, class TSizeTy&gt;
1151  TSizeTy TVec&lt;TVal, TSizeTy&gt;::UnionLen(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV) const {
1152    TSizeTy Cnt = 0, ValN1 = 0, ValN2 = 0;
1153    while ((ValN1 &lt; Len()) &amp;&amp; (ValN2 &lt; ValV.Len())) {
1154      const TVal&amp; Val1 = GetVal(ValN1);
1155      const TVal&amp; Val2 = ValV.GetVal(ValN2);
1156      if (Val1 &lt; Val2) {
1157        Cnt++; ValN1++;
1158      } else if (Val1 &gt; Val2) {
1159        Cnt++; ValN2++;
1160      } else {
1161        Cnt++; ValN1++; ValN2++;
1162      }
1163    }
1164    Cnt += (Len() - ValN1) + (ValV.Len() - ValN2);
1165    return Cnt;
1166  }
1167  template &lt;class TVal, class TSizeTy&gt;
1168  TSizeTy TVec&lt;TVal, TSizeTy&gt;::Count(const TVal&amp; Val) const {
1169    TSizeTy Count = 0;
1170    for (TSizeTy i = 0; i &lt; Len(); i++){
1171      if (Val == ValT[i]){Count++;}}
1172    return Count;
1173  }
1174  template &lt;class TVal, class TSizeTy&gt;
1175  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchBin(const TVal&amp; Val) const {
1176    TSizeTy LValN=0, RValN=Len()-1;
1177    while (RValN&gt;=LValN){
1178      TSizeTy ValN=(LValN+RValN)/2;
1179      if (Val==ValT[ValN]){return ValN;}
1180      if (Val&lt;ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1181    }
1182    return -1;
1183  }
1184  template &lt;class TVal, class TSizeTy&gt;
1185  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchBin(const TVal&amp; Val, TSizeTy&amp; InsValN) const {
1186    TSizeTy LValN=0, RValN=Len()-1;
1187    while (RValN&gt;=LValN){
1188      TSizeTy ValN=(LValN+RValN)/2;
1189      if (Val==ValT[ValN]){InsValN=ValN; return ValN;}
1190      if (Val&lt;ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1191    }
1192    InsValN=LValN; return -1;
1193  }
1194  template &lt;class TVal, class TSizeTy&gt;
1195  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchBinLeft(const TVal&amp; Val, TSizeTy&amp; InsValN) const {
1196    TSizeTy LValN=0, RValN=Len()-1;
1197    while (RValN&gt;=LValN){
1198      TSizeTy ValN=(LValN+RValN)/2;
1199      if (Val==ValT[ValN]){InsValN=ValN; return ValN;}
1200      if (Val&lt;ValT[ValN]){RValN=ValN-1;} else {LValN=ValN+1;}
1201    }
1202    InsValN=RValN; return -1;
1203  }
1204  template &lt;class TVal, class TSizeTy&gt;
1205  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchForw(const TVal&amp; Val, const TSizeTy&amp; BValN) const {
1206    for (TSizeTy ValN=BValN; ValN&lt;Vals; ValN++){
1207      if (Val==ValT[ValN]){return ValN;}}
1208    return -1;
1209  }
1210  template &lt;class TVal, class TSizeTy&gt;
1211  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchBack(const TVal&amp; Val) const {
1212    for (TSizeTy ValN=Vals-1; ValN&gt;=0; ValN--){
1213      if (Val==ValT[ValN]){return ValN;}}
1214    return -1;
1215  }
1216  template &lt;class TVal, class TSizeTy&gt;
1217  TSizeTy TVec&lt;TVal, TSizeTy&gt;::SearchVForw(const TVec&lt;TVal, TSizeTy&gt;&amp; ValV, const TSizeTy&amp; BValN) const {
1218    TSizeTy ValVLen=ValV.Len();
1219    for (TSizeTy ValN=BValN; ValN&lt;Vals-ValVLen+1; ValN++){
1220      bool Found=true;
1221      for (TSizeTy SubValN=0; SubValN&lt;ValVLen; SubValN++){
1222        if (ValV[SubValN]!=GetVal(ValN+SubValN)){Found=false; break;}
1223      }
1224      if (Found){return ValN;}
1225    }
1226    return -1;
1227  }
1228  template &lt;class TVal, class TSizeTy&gt;
1229  TSizeTy TVec&lt;TVal, TSizeTy&gt;::GetMxValN() const {
1230    if (Vals==0){return -1;}
1231    TSizeTy MxValN=0;
1232    for (TSizeTy ValN=1; ValN&lt;Vals; ValN++){
1233      if (ValT[ValN]&gt;ValT[MxValN]){MxValN=ValN;}
1234    }
1235    return MxValN;
1236  }
1237  typedef TVec&lt;TBool&gt; TBoolV;
1238  typedef TVec&lt;TCh&gt; TChV;
1239  typedef TVec&lt;TUCh&gt; TUChV;
1240  typedef TVec&lt;TUInt&gt; TUIntV;
1241  typedef TVec&lt;TInt&gt; TIntV;
1242  typedef TVec&lt;TUInt64&gt; TUInt64V;
1243  typedef TVec&lt;TFlt&gt; TFltV;
1244  typedef TVec&lt;TSFlt&gt; TSFltV;
1245  typedef TVec&lt;TAscFlt&gt; TAscFltV;
1246  typedef TVec&lt;TStr&gt; TStrV;
1247  typedef TVec&lt;TChA&gt; TChAV;
1248  typedef TVec&lt;TIntPr&gt; TIntPrV;
1249  typedef TVec&lt;TIntTr&gt; TIntTrV;
1250  typedef TVec&lt;TIntQu&gt; TIntQuV;
1251  typedef TVec&lt;TFltPr&gt; TFltPrV;
1252  typedef TVec&lt;TFltTr&gt; TFltTrV;
1253  typedef TVec&lt;TIntKd&gt; TIntKdV;
1254  typedef TVec&lt;TUChIntPr&gt; TUChIntPrV;
1255  typedef TVec&lt;TUChUInt64Pr&gt; TUChUInt64PrV;
1256  typedef TVec&lt;TIntUInt64Pr&gt; TIntUInt64PrV;
1257  typedef TVec&lt;TIntUInt64Kd&gt; TIntUInt64KdV;
1258  typedef TVec&lt;TIntFltPr&gt; TIntFltPrV;
1259  typedef TVec&lt;TIntFltPrKd&gt; TIntFltPrKdV;
1260  typedef TVec&lt;TFltIntPr&gt; TFltIntPrV;
1261  typedef TVec&lt;TFltUInt64Pr&gt; TFltUInt64PrV;
1262  typedef TVec&lt;TFltStrPr&gt; TFltStrPrV;
1263  typedef TVec&lt;TAscFltStrPr&gt; TAscFltStrPrV;
1264  typedef TVec&lt;TIntStrPr&gt; TIntStrPrV;
1265  typedef TVec&lt;TIntIntStrTr&gt; TIntIntStrTrV;
1266  typedef TVec&lt;TIntIntFltTr&gt; TIntIntFltTrV;
1267  typedef TVec&lt;TIntFltIntTr&gt; TIntFltIntTrV;
1268  typedef TVec&lt;TIntStrIntTr&gt; TIntStrIntTrV;
1269  typedef TVec&lt;TIntStrStrTr&gt; TIntStrStrTrV;
1270  typedef TVec&lt;TIntKd&gt; TIntKdV;
1271  typedef TVec&lt;TUIntIntKd&gt; TUIntIntKdV;
1272  typedef TVec&lt;TIntFltKd&gt; TIntFltKdV;
1273  typedef TVec&lt;TIntPrFltKd&gt; TIntPrFltKdV;
1274  typedef TVec&lt;TIntStrKd&gt; TIntStrKdV;
1275  typedef TVec&lt;TIntStrPrPr&gt; TIntStrPrPrV;
1276  typedef TVec&lt;TIntStrVPr&gt; TIntStrVPrV;
1277  typedef TVec&lt;TIntIntVIntTr&gt; TIntIntVIntTrV;
1278  typedef TVec&lt;TIntIntIntVTr&gt; TIntIntIntVTrV;
1279  typedef TVec&lt;TUInt64IntPr&gt; TUInt64IntPrV;
1280  typedef TVec&lt;TUInt64FltPr&gt; TUInt64FltPrV;
1281  typedef TVec&lt;TUInt64StrPr&gt; TUInt64StrPrV;
1282  typedef TVec&lt;TUInt64IntKd&gt; TUInt64IntKdV;
1283  typedef TVec&lt;TUInt64FltKd&gt; TUInt64FltKdV;
1284  typedef TVec&lt;TUInt64StrKd&gt; TUInt64StrKdV;
1285  typedef TVec&lt;TFltBoolKd&gt; TFltBoolKdV;
1286  typedef TVec&lt;TFltIntKd&gt; TFltIntKdV;
1287  typedef TVec&lt;TFltUInt64Kd&gt; TFltUInt64KdV;
1288  typedef TVec&lt;TFltIntPrKd&gt; TFltIntPrKdV;
1289  typedef TVec&lt;TFltKd&gt; TFltKdV;
1290  typedef TVec&lt;TFltStrKd&gt; TFltStrKdV;
1291  typedef TVec&lt;TFltStrPrPr&gt; TFltStrPrPrV;
1292  typedef TVec&lt;TFltIntIntTr&gt; TFltIntIntTrV;
1293  typedef TVec&lt;TFltFltStrTr&gt; TFltFltStrTrV;
1294  typedef TVec&lt;TAscFltIntPr&gt; TAscFltIntPrV;
1295  typedef TVec&lt;TAscFltIntKd&gt; TAscFltIntKdV;
1296  typedef TVec&lt;TStrPr&gt; TStrPrV;
1297  typedef TVec&lt;TStrIntPr&gt; TStrIntPrV;
1298  typedef TVec&lt;TStrFltPr&gt; TStrFltPrV;
1299  typedef TVec&lt;TStrIntKd&gt; TStrIntKdV;
1300  typedef TVec&lt;TStrFltKd&gt; TStrFltKdV;
1301  typedef TVec&lt;TStrAscFltKd&gt; TStrAscFltKdV;
1302  typedef TVec&lt;TStrTr&gt; TStrTrV;
1303  typedef TVec&lt;TStrQu&gt; TStrQuV;
1304  typedef TVec&lt;TStrFltFltTr&gt; TStrFltFltTrV;
1305  typedef TVec&lt;TStrStrIntTr&gt; TStrStrIntTrV;
1306  typedef TVec&lt;TStrKd&gt; TStrKdV;
1307  typedef TVec&lt;TStrStrVPr&gt; TStrStrVPrV;
1308  typedef TVec&lt;TStrVIntPr&gt; TStrVIntPrV;
1309  typedef TVec&lt;TFltIntIntIntQu&gt; TFltIntIntIntQuV;
1310  typedef TVec&lt;TIntStrIntIntQu&gt; TIntStrIntIntQuV;
1311  typedef TVec&lt;TIntIntPrPr&gt; TIntIntPrPrV;
1312  typedef TVec&lt;TFltV&gt; TFltVFltV;
1313  template &lt;class TVal, class TSizeTy=int&gt;
1314  class TVecPool {
1315  public:
1316    typedef TPt&lt;TVecPool&lt;TVal, TSizeTy&gt; &gt; PVecPool;
1317    typedef TVec&lt;TVal, TSizeTy&gt; TValV;
1318  private:
1319    TCRef CRef;
1320    TBool FastCopy;
1321    TSize GrowBy, MxVals, Vals;
1322    TVal EmptyVal;                
1323    TVal *ValBf;                  
1324    TVec&lt;uint64, int&gt; IdToOffV;   
1325  private:
1326    void Resize(const TSize&amp; _MxVals);
1327  public:
1328    TVecPool(const TSize&amp; ExpectVals=0, const TSize&amp; _GrowBy=1000000, const bool&amp; _FastCopy=false, const TVal&amp; _EmptyVal=TVal());
1329    TVecPool(const TVecPool&lt;TVal, TSizeTy&gt;&amp; Pool);
1330    TVecPool(TSIn&amp; SIn);
1331    ~TVecPool() { if (ValBf != NULL) { delete [] ValBf; } ValBf=NULL; }
1332    static PVecPool New(const TSize&amp; ExpectVals=0, const TSize&amp; GrowBy=1000000, const bool&amp; FastCopy=false) {
1333      return new TVecPool(ExpectVals, GrowBy, FastCopy); }
1334    static PVecPool Load(TSIn&amp; SIn) { return new TVecPool(SIn); }
1335    static PVecPool Load(const TStr&amp; FNm) { TFIn FIn(FNm); return Load(FIn); }
1336    void Save(TSOut&amp; SOut) const;
1337    TVecPool&amp; operator = (const TVecPool&amp; Pool);
1338    int GetVecs() const { return IdToOffV.Len(); }
1339    TSize GetVals() const { return Vals; }
1340    bool IsVId(const int&amp; VId) const { return (0 &lt;= VId) &amp;&amp; (VId &lt; IdToOffV.Len()); }
1341    uint64 Reserved() const { return MxVals; }
1342    void Reserve(const TSize&amp; MxVals) { Resize(MxVals); }
1343    const TVal&amp; GetEmptyVal() const { return EmptyVal; }
1344    void SetEmptyVal(const TVal&amp; _EmptyVal) { EmptyVal = _EmptyVal; }
1345    uint64 GetMemUsed() const {
1346      return sizeof(TCRef)+sizeof(TBool)+3*sizeof(TSize)+sizeof(TVal*)+MxVals*sizeof(TVal);}
1347    int AddV(const TValV&amp; ValV);
1348    int AddEmptyV(const int&amp; ValVLen);
1349    int GetVLen(const int&amp; VId) const { if (VId==0){return 0;} else {return int(IdToOffV[VId]-IdToOffV[VId-1]);}}
1350    TVal* GetValVPt(const int&amp; VId) const {
1351      if (GetVLen(VId)==0){return (TVal*)&amp;EmptyVal;}
1352      else {return ValBf+IdToOffV[VId-1];}}
1353    void GetV(const int&amp; VId, TValV&amp; ValV) const {
1354      if (GetVLen(VId)==0){ValV.Clr();}
1355      else { ValV.GenExt(GetValVPt(VId), GetVLen(VId)); } }
1356    void PutV(const int&amp; VId, const TValV&amp; ValV) {
1357      IAssert(IsVId(VId) &amp;&amp; GetVLen(VId) == ValV.Len());
1358      if (FastCopy) {
1359        memcpy(GetValVPt(VId), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1360      else { TVal* ValPt = GetValVPt(VId);
1361        for (::TSize ValN=0; ValN &lt; ::TSize(ValV.Len()); ValN++, ValPt++) { *ValPt=ValV[ValN]; }
1362      } }
1363    void CompactPool(const TVal&amp; DelVal);
1364    void ShuffleAll(TRnd&amp; Rnd=TInt::Rnd);
1365    void Clr(bool DoDel = true) {
1366      IdToOffV.Clr(DoDel);  MxVals=0;  Vals=0;
1367      if (DoDel &amp;&amp; ValBf!=NULL) { delete [] ValBf; ValBf=NULL;}
1368      if (! DoDel) { PutAll(EmptyVal); } }
1369    void PutAll(const TVal&amp; Val) {
1370      for (TSize ValN = 0; ValN &lt; MxVals; ValN++) { ValBf[ValN]=Val; } }
1371    friend class TPt&lt;TVecPool&lt;TVal&gt; &gt;;
1372  };
1373  template &lt;class TVal, class TSizeTy&gt;
1374  void TVecPool&lt;TVal, TSizeTy&gt;::Resize(const TSize&amp; _MxVals){
1375    if (_MxVals &lt;= MxVals){ return; } else { MxVals = _MxVals; }
1376    if (ValBf == NULL) {
1377      try { ValBf = new TVal [MxVals]; }
1378      catch (std::exception Ex) {
1379        FailR(TStr::Fmt(&quot;TVecPool::Resize 1: %s, MxVals: %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), TInt::GetStr(uint64(_MxVals)).CStr()).CStr()); }
1380      IAssert(ValBf != NULL);
1381      if (EmptyVal != TVal()) { PutAll(EmptyVal); }
1382    } else {
1383      TVal* NewValBf = NULL;
1384      try { NewValBf = new TVal [MxVals]; }
1385      catch (std::exception Ex) {
1386        FailR(TStr::Fmt(&quot;TVecPool::Resize 1: %s, MxVals: %s. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), TInt::GetStr(uint64(_MxVals)).CStr()).CStr()); }
1387      IAssert(NewValBf != NULL);
1388      if (FastCopy) {
1389        memcpy(NewValBf, ValBf, Vals*sizeof(TVal)); }
1390      else {
1391        for (TSize ValN = 0; ValN &lt; Vals; ValN++){ NewValBf[ValN] = ValBf[ValN]; } }
1392      if (EmptyVal != TVal()) { 
1393        for (TSize ValN = Vals; ValN &lt; MxVals; ValN++) { NewValBf[ValN] = EmptyVal; }
1394      }
1395      delete [] ValBf;
1396      ValBf = NewValBf;
1397    }
1398  }
1399  template &lt;class TVal, class TSizeTy&gt;
1400  TVecPool&lt;TVal, TSizeTy&gt;::TVecPool(const TSize&amp; ExpectVals, const TSize&amp; _GrowBy, const bool&amp; _FastCopy, const TVal&amp; _EmptyVal) : GrowBy(_GrowBy), MxVals(0), Vals(0), EmptyVal(_EmptyVal), ValBf(NULL) {
1401    IdToOffV.Add(0);
1402    Resize(ExpectVals);
1403  }
1404  template &lt;class TVal, class TSizeTy&gt;
1405  TVecPool&lt;TVal, TSizeTy&gt;::TVecPool(const TVecPool&amp; Pool) : FastCopy(Pool.FastCopy), GrowBy(Pool.GrowBy), MxVals(Pool.MxVals), Vals(Pool.Vals), EmptyVal(Pool.EmptyVal), IdToOffV(Pool.IdToOffV) {
1406    try {
1407      ValBf = new TVal [MxVals]; }
1408    catch (std::exception Ex) {
1409      FailR(TStr::Fmt(&quot;TVecPool::TVecPool: %s, MxVals: %s. [Program failed to allocate memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), TInt::GetStr(uint64(MxVals)).CStr()).CStr()); }
1410    IAssert(ValBf != NULL);
1411    if (FastCopy) {
1412      memcpy(ValBf, Pool.ValBf, MxVals*sizeof(TVal)); }
1413    else {
1414      for (TSize ValN = 0; ValN &lt; MxVals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1415  }
1416  template &lt;class TVal, class TSizeTy&gt;
1417  TVecPool&lt;TVal, TSizeTy&gt;::TVecPool(TSIn&amp; SIn) : FastCopy(SIn) {
1418    uint64 _GrowBy, _MxVals, _Vals;
1419    SIn.Load(_GrowBy); SIn.Load(_MxVals);  SIn.Load(_Vals);
1420    IAssertR(_GrowBy&lt;TSizeMx &amp;&amp; _MxVals&lt;TSizeMx &amp;&amp; _Vals&lt;TSizeMx, &quot;This is a 64-bit vector pool. Use a 64-bit compiler.&quot;);
1421    GrowBy=TSize(_GrowBy);  MxVals=TSize(_Vals);  Vals=TSize(_Vals); 
1422    EmptyVal = TVal(SIn);
1423    if (MxVals==0) { ValBf = NULL; } else { ValBf = new TVal [MxVals]; }
1424    for (TSize ValN = 0; ValN &lt; Vals; ValN++) { ValBf[ValN] = TVal(SIn); }
1425    { TInt MxVals(SIn), Vals(SIn);
1426      IdToOffV.Gen(Vals);
1427      for (int ValN = 0; ValN &lt; Vals; ValN++) {
1428        uint64 Offset;  SIn.Load(Offset);  IAssert(Offset &lt; TSizeMx);
1429        IdToOffV[ValN]=TSize(Offset);
1430      } }
1431  }
1432  template &lt;class TVal, class TSizeTy&gt;
1433  void TVecPool&lt;TVal, TSizeTy&gt;::Save(TSOut&amp; SOut) const {
1434    SOut.Save(FastCopy);
1435    uint64 _GrowBy=GrowBy, _MxVals=MxVals, _Vals=Vals;
1436    SOut.Save(_GrowBy); SOut.Save(_MxVals);  SOut.Save(_Vals);
1437    SOut.Save(EmptyVal);
1438    for (TSize ValN = 0; ValN &lt; Vals; ValN++) { ValBf[ValN].Save(SOut); }
1439    { SOut.Save(IdToOffV.Len());  SOut.Save(IdToOffV.Len());
1440      for (int ValN = 0; ValN &lt; IdToOffV.Len(); ValN++) {
1441        const uint64 Offset=IdToOffV[ValN];  SOut.Save(Offset);
1442      } }
1443  }
1444  template &lt;class TVal, class TSizeTy&gt;
1445  TVecPool&lt;TVal, TSizeTy&gt;&amp; TVecPool&lt;TVal, TSizeTy&gt;::operator = (const TVecPool&amp; Pool) {
1446    if (this!=&amp;Pool) {
1447      FastCopy = Pool.FastCopy;
1448      GrowBy = Pool.GrowBy;
1449      MxVals = Pool.MxVals;
1450      Vals = Pool.Vals;
1451      EmptyVal = Pool.EmptyVal;
1452      IdToOffV=Pool.IdToOffV;
1453      try {
1454        ValBf = new TVal [MxVals]; }
1455      catch (std::exception Ex) {
1456        FailR(TStr::Fmt(&quot;TVecPool::operator=: %s, MxVals: %s. [Program failed to allocate memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), TInt::GetStr(uint64(MxVals)).CStr()).CStr()); }
1457      IAssert(ValBf != NULL);
1458      if (FastCopy) {
1459        memcpy(ValBf, Pool.ValBf, Vals*sizeof(TVal)); }
1460      else {
1461        for (TSize ValN = 0; ValN &lt; Vals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1462    }
1463    return *this;
1464  }
1465  template &lt;class TVal, class TSizeTy&gt;
1466  int TVecPool&lt;TVal, TSizeTy&gt;::AddV(const TValV&amp; ValV) {
1467    const TSize ValVLen = ValV.Len();
1468    if (ValVLen == 0) { return 0; }
1469    if (MxVals &lt; Vals+ValVLen) { Resize(Vals+MAX(ValVLen, GrowBy)); }
1470    if (FastCopy) { memcpy(ValBf+Vals, ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1471    else { for (TSize ValN=0; ValN &lt; ValVLen; ValN++) { ValBf[Vals+ValN]=ValV[ValN]; } }
1472    Vals+=ValVLen;  IdToOffV.Add(Vals);
1473    return IdToOffV.Len()-1;
1474  }
1475  template &lt;class TVal, class TSizeTy&gt;
1476  int TVecPool&lt;TVal, TSizeTy&gt;::AddEmptyV(const int&amp; ValVLen) {
1477    if (ValVLen==0){return 0;}
1478    if (MxVals &lt; Vals+ValVLen){Resize(Vals+MAX(TSize(ValVLen), GrowBy)); }
1479    Vals+=ValVLen; IdToOffV.Add(Vals);
1480    return IdToOffV.Len()-1;
1481  }
1482  template &lt;class TVal, class TSizeTy&gt;
1483  void TVecPool&lt;TVal, TSizeTy&gt;::CompactPool(const TVal&amp; DelVal) {
1484    ::TSize TotalDel=0, NDel=0;
1485    for (int vid = 1; vid &lt; IdToOffV.Len(); vid++) {
1486      const uint Len = GetVLen(vid);
1487      TVal* ValV = GetValVPt(vid);
1488      if (TotalDel &gt; 0) { IdToOffV[vid-1] -= TotalDel; } 
1489      if (Len == 0) { continue; }
1490      NDel = 0;
1491      for (TVal* v = ValV; v &lt; ValV+Len-NDel; v++) {
1492        if (*v == DelVal) {
1493          TVal* Beg = v;
1494          while (*v == DelVal &amp;&amp; v &lt; ValV+Len) { v++; NDel++; }
1495          memcpy(Beg, v, sizeof(TVal)*int(Len - ::TSize(v - ValV)));
1496          v -= NDel;
1497        }
1498      }
1499      memcpy(ValV-TotalDel, ValV, sizeof(TVal)*Len);  
1500      TotalDel += NDel;
1501    }
1502    IdToOffV.Last() -= TotalDel;
1503    for (::TSize i = Vals-TotalDel; i &lt; Vals; i++) { ValBf[i] = EmptyVal; }
1504    Vals -= TotalDel;
1505  }
1506  template &lt;class TVal, class TSizeTy&gt;
1507  void TVecPool&lt;TVal, TSizeTy&gt;::ShuffleAll(TRnd&amp; Rnd) {
1508    for (::TSize n = Vals-1; n &gt; 0; n--) {
1509      const ::TSize k = ::TSize(((uint64(Rnd.GetUniDevInt())&lt;&lt;32) | uint64(Rnd.GetUniDevInt())) % (n+1));
1510      const TVal Tmp = ValBf[n];
1511      ValBf[n] = ValBf[k];
1512      ValBf[k] = Tmp;
1513    }
1514  }
1515  namespace TGLib_OLD {
1516  template&lt;class TVal&gt;
1517  class TVecPool {
1518  public:
1519    typedef TPt&lt;TVecPool&lt;TVal&gt; &gt; PVecPool;
1520    typedef TVec&lt;TVal&gt; TValV;
1521  private:
1522    TCRef CRef;
1523    TBool FastCopy;
1524    ::TSize GrowBy, MxVals, Vals;
1525    TVal EmptyVal;           
1526    TVal *ValBf;             
1527    TVec&lt; ::TSize&gt; IdToOffV; 
1528  private:
1529    void Resize(const ::TSize&amp; _MxVals);
1530  public:
1531    TVecPool(const ::TSize&amp; ExpectVals=0, const ::TSize&amp; _GrowBy=1000000, const bool&amp; _FastCopy=false, const TVal&amp; _EmptyVal=TVal());
1532    TVecPool(const TVecPool&amp; Pool);
1533    TVecPool(TSIn&amp; SIn);
1534    ~TVecPool() { if (ValBf != NULL) { delete [] ValBf; } ValBf=NULL; }
1535    static PVecPool New(const ::TSize&amp; ExpectVals=0, const ::TSize&amp; GrowBy=1000000, const bool&amp; FastCopy=false) {
1536      return new TVecPool(ExpectVals, GrowBy, FastCopy); }
1537    static PVecPool Load(TSIn&amp; SIn) { return new TVecPool(SIn); }
1538    static PVecPool Load(const TStr&amp; FNm) { TFIn FIn(FNm); return Load(FIn); }
1539    void Save(TSOut&amp; SOut) const;
1540    TVecPool&amp; operator = (const TVecPool&amp; Pool);
1541    ::TSize GetVals() const { return Vals; }
1542    ::TSize GetVecs() const { return IdToOffV.Len(); }
1543    bool IsVId(const int&amp; VId) const { return (0 &lt;= VId) &amp;&amp; (VId &lt; IdToOffV.Len()); }
1544    ::TSize Reserved() const { return MxVals; }
1545    void Reserve(const ::TSize&amp; MxVals) { Resize(MxVals); }
1546    const TVal&amp; GetEmptyVal() const { return EmptyVal; }
1547    void SetEmptyVal(const TVal&amp; _EmptyVal) { EmptyVal = _EmptyVal; }
1548    ::TSize GetMemUsed() const {
1549      return sizeof(TCRef)+sizeof(TBool)+3*sizeof(TSize)+sizeof(TVal*)+MxVals*sizeof(TVal);}
1550    int AddV(const TValV&amp; ValV);
1551    int AddEmptyV(const int&amp; ValVLen);
1552    uint GetVLen(const int&amp; VId) const {
1553      if (VId==0){return 0;}
1554      else {return uint(IdToOffV[VId]-IdToOffV[VId-1]);}}
1555    TVal* GetValVPt(const int&amp; VId) const {
1556      if (GetVLen(VId)==0){return (TVal*)&amp;EmptyVal;}
1557      else {return ValBf+IdToOffV[VId-1];}}
1558    void GetV(const int&amp; VId, TValV&amp; ValV) const {
1559      if (GetVLen(VId)==0){ValV.Clr();}
1560      else { ValV.GenExt(GetValVPt(VId), GetVLen(VId)); } }
1561    void PutV(const int&amp; VId, const TValV&amp; ValV) {
1562      IAssert(IsVId(VId) &amp;&amp; GetVLen(VId) == ValV.Len());
1563      if (FastCopy) {
1564        memcpy(GetValVPt(VId), ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1565      else { TVal* ValPt = GetValVPt(VId);
1566        for (uint ValN=0; ValN &lt; uint(ValV.Len()); ValN++, ValPt++) { *ValPt=ValV[ValN]; }
1567      }
1568    }
1569    void CompactPool(const TVal&amp; DelVal); 
1570    void ShuffleAll(TRnd&amp; Rnd=TInt::Rnd); 
1571    void Clr(bool DoDel = true) {
1572      IdToOffV.Clr(DoDel);  MxVals=0;  Vals=0;
1573      if (DoDel &amp;&amp; ValBf!=NULL) { delete [] ValBf; ValBf=NULL;}
1574      if (! DoDel) { PutAll(EmptyVal); }
1575    }
1576    void PutAll(const TVal&amp; Val) {
1577      for (TSize ValN = 0; ValN &lt; MxVals; ValN++) { ValBf[ValN]=Val; } }
1578    friend class TPt&lt;TVecPool&lt;TVal&gt; &gt;;
1579  };
1580  template &lt;class TVal&gt;
1581  void TVecPool&lt;TVal&gt;::Resize(const ::TSize&amp; _MxVals){
1582    if (_MxVals &lt;= MxVals){ return; } else { MxVals = _MxVals; }
1583    if (ValBf == NULL) {
1584      try { ValBf = new TVal [MxVals]; }
1585      catch (std::exception Ex) {
1586        FailR(TStr::Fmt(&quot;TVecPool::Resize 1: %s, MxVals: %d. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), _MxVals).CStr()); }
1587      IAssert(ValBf != NULL);
1588      if (EmptyVal != TVal()) { PutAll(EmptyVal); }
1589    } else {
1590      TVal* NewValBf = NULL;
1591      try { NewValBf = new TVal [MxVals]; }
1592      catch (std::exception Ex) { FailR(TStr::Fmt(&quot;TVecPool::Resize 2: %s, MxVals: %d. [Program failed to allocate more memory. Solution: Get a bigger machine and a 64-bit compiler.]&quot;, Ex.what(), _MxVals).CStr()); }
1593      IAssert(NewValBf != NULL);
1594      if (FastCopy) {
1595        memcpy(NewValBf, ValBf, Vals*sizeof(TVal)); }
1596      else {
1597        for (TSize ValN = 0; ValN &lt; Vals; ValN++){ NewValBf[ValN] = ValBf[ValN]; } }
1598      if (EmptyVal != TVal()) { 
1599        for (TSize ValN = Vals; ValN &lt; MxVals; ValN++) { NewValBf[ValN] = EmptyVal; }
1600      }
1601      delete [] ValBf;
1602      ValBf = NewValBf;
1603    }
1604  }
1605  template &lt;class TVal&gt;
1606  TVecPool&lt;TVal&gt;::TVecPool(const ::TSize&amp; ExpectVals, const ::TSize&amp; _GrowBy, const bool&amp; _FastCopy, const TVal&amp; _EmptyVal) :
1607    GrowBy(_GrowBy), MxVals(0), Vals(0), EmptyVal(_EmptyVal), ValBf(NULL) {
1608    IdToOffV.Add(0);
1609    Resize(ExpectVals);
1610  }
1611  template &lt;class TVal&gt;
1612  TVecPool&lt;TVal&gt;::TVecPool(const TVecPool&amp; Pool):
1613    FastCopy(Pool.FastCopy), GrowBy(Pool.GrowBy),
1614    MxVals(Pool.MxVals), Vals(Pool.Vals), EmptyVal(Pool.EmptyVal), IdToOffV(Pool.IdToOffV) {
1615    try { ValBf = new TVal [MxVals]; }
1616    catch (std::exception Ex) { FailR(TStr::Fmt(&quot;TVecPool::TVecPool: %s, MxVals: %d&quot;, Ex.what(), MxVals).CStr()); }
1617    IAssert(ValBf != NULL);
1618    if (FastCopy) {
1619      memcpy(ValBf, Pool.ValBf, MxVals*sizeof(TVal)); }
1620    else {
1621      for (TSize ValN = 0; ValN &lt; MxVals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1622  }
1623  template &lt;class TVal&gt;
1624  TVecPool&lt;TVal&gt;::TVecPool(TSIn&amp; SIn):
1625    FastCopy(SIn) {
1626    uint64 _GrowBy, _MxVals, _Vals;
1627    SIn.Load(_GrowBy); SIn.Load(_MxVals);  SIn.Load(_Vals);
1628    IAssert(_GrowBy&lt;TSizeMx &amp;&amp; _MxVals&lt;TSizeMx &amp;&amp; _Vals&lt;TSizeMx);
1629    GrowBy=TSize(_GrowBy);  MxVals=TSize(_Vals);  Vals=TSize(_Vals); 
1630    EmptyVal = TVal(SIn);
1631    if (MxVals==0) { ValBf = NULL; } else { ValBf = new TVal [MxVals]; }
1632    for (TSize ValN = 0; ValN &lt; Vals; ValN++) { ValBf[ValN] = TVal(SIn); }
1633    { TInt MxVals(SIn), Vals(SIn);
1634    IdToOffV.Gen(Vals);
1635    for (int ValN = 0; ValN &lt; Vals; ValN++) {
1636      uint64 Offset;  SIn.Load(Offset);  IAssert(Offset &lt; TSizeMx);
1637      IdToOffV[ValN]=TSize(Offset);
1638    } }
1639  }
1640  template &lt;class TVal&gt;
1641  void TVecPool&lt;TVal&gt;::Save(TSOut&amp; SOut) const {
1642    SOut.Save(FastCopy);
1643    uint64 _GrowBy=GrowBy, _MxVals=MxVals, _Vals=Vals;
1644    SOut.Save(_GrowBy); SOut.Save(_MxVals);  SOut.Save(_Vals);
1645    SOut.Save(EmptyVal);
1646    for (TSize ValN = 0; ValN &lt; Vals; ValN++) { ValBf[ValN].Save(SOut); }
1647    { SOut.Save(IdToOffV.Len());  SOut.Save(IdToOffV.Len());
1648    for (int ValN = 0; ValN &lt; IdToOffV.Len(); ValN++) {
1649      const uint64 Offset=IdToOffV[ValN];  SOut.Save(Offset);
1650    } }
1651  }
1652  template &lt;class TVal&gt;
1653  TVecPool&lt;TVal&gt;&amp; TVecPool&lt;TVal&gt;::operator = (const TVecPool&amp; Pool) {
1654    if (this!=&amp;Pool) {
1655      FastCopy = Pool.FastCopy;
1656      GrowBy = Pool.GrowBy;
1657      MxVals = Pool.MxVals;
1658      Vals = Pool.Vals;
1659      EmptyVal = Pool.EmptyVal;
1660      IdToOffV=Pool.IdToOffV;
1661      try { ValBf = new TVal [MxVals]; }
1662      catch (std::exception Ex) { FailR(TStr::Fmt(&quot;TVec::operator= : %s, MxVals: %d&quot;, Ex.what(), MxVals).CStr()); }
1663      IAssert(ValBf != NULL);
1664      if (FastCopy) {
1665        memcpy(ValBf, Pool.ValBf, Vals*sizeof(TVal)); }
1666      else {
1667        for (uint64 ValN = 0; ValN &lt; Vals; ValN++){ ValBf[ValN] = Pool.ValBf[ValN]; } }
1668    }
1669    return *this;
1670  }
1671  template&lt;class TVal&gt;
1672  int TVecPool&lt;TVal&gt;::AddV(const TValV&amp; ValV) {
1673    const ::TSize ValVLen = ValV.Len();
1674    if (ValVLen == 0) { return 0; }
1675    if (MxVals &lt; Vals+ValVLen) { Resize(Vals+MAX(ValVLen, GrowBy)); }
1676    if (FastCopy) { memcpy(ValBf+Vals, ValV.BegI(), sizeof(TVal)*ValV.Len()); }
1677    else { for (uint ValN=0; ValN &lt; ValVLen; ValN++) { ValBf[Vals+ValN]=ValV[ValN]; } }
1678    Vals+=ValVLen;  IdToOffV.Add(Vals);
1679    return IdToOffV.Len()-1;
1680  }
1681  template&lt;class TVal&gt;
1682  int TVecPool&lt;TVal&gt;::AddEmptyV(const int&amp; ValVLen) {
1683    if (ValVLen==0){return 0;}
1684    if (MxVals &lt; Vals+ValVLen){Resize(Vals+MAX(TSize(ValVLen), GrowBy)); }
1685    Vals+=ValVLen; IdToOffV.Add(Vals);
1686    return IdToOffV.Len()-1;
1687  }
1688  template&lt;class TVal&gt;
1689  void TVecPool&lt;TVal&gt;::CompactPool(const TVal&amp; DelVal) {
1690    ::TSize TotalDel=0, NDel=0;
1691    for (int vid = 1; vid &lt; IdToOffV.Len(); vid++) {
1692      const uint Len = GetVLen(vid);
1693      TVal* ValV = GetValVPt(vid);
1694      if (TotalDel &gt; 0) { IdToOffV[vid-1] -= TotalDel; } 
1695      if (Len == 0) { continue; }
1696      NDel = 0;
1697      for (TVal* v = ValV; v &lt; ValV+Len-NDel; v++) {
1698        if (*v == DelVal) {
1699          TVal* Beg = v;
1700          while (*v == DelVal &amp;&amp; v &lt; ValV+Len) { v++; NDel++; }
1701          memcpy(Beg, v, sizeof(TVal)*int(Len - ::TSize(v - ValV)));
1702          v -= NDel;
1703        }
1704      }
1705      memcpy(ValV-TotalDel, ValV, sizeof(TVal)*Len);  
1706      TotalDel += NDel;
1707    }
1708    IdToOffV.Last() -= TotalDel;
1709    for (::TSize i = Vals-TotalDel; i &lt; Vals; i++) { ValBf[i] = EmptyVal; }
1710    Vals -= TotalDel;
1711  }
1712  template&lt;class TVal&gt;
1713  void TVecPool&lt;TVal&gt;::ShuffleAll(TRnd&amp; Rnd) {
1714    for (::TSize n = Vals-1; n &gt; 0; n--) {
1715      const ::TSize k = ::TSize(((uint64(Rnd.GetUniDevInt())&lt;&lt;32) | uint64(Rnd.GetUniDevInt())) % (n+1));
1716      const TVal Tmp = ValBf[n];
1717      ValBf[n] = ValBf[k];
1718      ValBf[k] = Tmp;
1719    }
1720  }
1721  }; 
1722  typedef TVecPool&lt;TInt&gt; TIntVecPool;
1723  typedef TPt&lt;TIntVecPool&gt; PIntVecPool;
1724  template &lt;class TVal&gt;
1725  class PVec{
1726  private:
1727    TCRef CRef;
1728  public:
1729    TVec&lt;TVal&gt; V;
1730  public:
1731    PVec&lt;TVal&gt;(): V(){}
1732    PVec&lt;TVal&gt;(const PVec&lt;TVal&gt;&amp; Vec): V(Vec.V){}
1733    static TPt&lt;PVec&lt;TVal&gt; &gt; New(){
1734      return new PVec&lt;TVal&gt;();}
1735    PVec&lt;TVal&gt;(const int&amp; MxVals, const int&amp; Vals): V(MxVals, Vals){}
1736    static TPt&lt;PVec&lt;TVal&gt; &gt; New(const int&amp; MxVals, const int&amp; Vals){
1737      return new PVec&lt;TVal&gt;(MxVals, Vals);}
1738    PVec&lt;TVal&gt;(const TVec&lt;TVal&gt;&amp; _V): V(_V){}
1739    static TPt&lt;PVec&lt;TVal&gt; &gt; New(const TVec&lt;TVal&gt;&amp; V){
1740      return new PVec&lt;TVal&gt;(V);}
1741    explicit PVec&lt;TVal&gt;(TSIn&amp; SIn): V(SIn){}
1742    static TPt&lt;PVec&lt;TVal&gt; &gt; Load(TSIn&amp; SIn){return new PVec&lt;TVal&gt;(SIn);}
1743    void Save(TSOut&amp; SOut) const {V.Save(SOut);}
1744    PVec&lt;TVal&gt;&amp; operator=(const PVec&lt;TVal&gt;&amp; Vec){
1745      if (this!=&amp;Vec){V=Vec.V;} return *this;}
1746    bool operator==(const PVec&lt;TVal&gt;&amp; Vec) const {return V==Vec.V;}
1747    bool operator&lt;(const PVec&lt;TVal&gt;&amp; Vec) const {return V&lt;Vec.V;}
1748    TVal&amp; operator[](const int&amp; ValN) const {return V[ValN];}
1749    bool Empty() const {return V.Empty();}
1750    int Len() const {return V.Len();}
1751    TVal GetVal(const int&amp; ValN) const {return V[ValN];}
1752    int Add(const TVal&amp; Val){return V.Add(Val);}
1753    friend class TPt&lt;PVec&lt;TVal&gt; &gt;;
1754  };
1755  typedef PVec&lt;TFlt&gt; TFltVP;
1756  typedef TPt&lt;TFltVP&gt; PFltV;
1757  typedef PVec&lt;TAscFlt&gt; TAscFltVP;
1758  typedef TPt&lt;TAscFltVP&gt; PAscFltV;
1759  typedef PVec&lt;TStr&gt; TStrVP;
1760  typedef TPt&lt;TStrVP&gt; PStrV;
1761  template &lt;class TVal, class TSizeTy = int&gt;
1762  class TVVec{
1763  private:
1764    TInt64 XDim, YDim;
1765    TVec&lt;TVal, TSizeTy&gt; ValV;
1766  public:
1767    TVVec(): XDim(), YDim(), ValV(){}
1768    TVVec(const TVVec&amp; Vec):
1769      XDim(Vec.XDim), YDim(Vec.YDim), ValV(Vec.ValV){}
1770    TVVec(const TSizeTy&amp; _XDim, const TSizeTy&amp; _YDim):
1771      XDim(), YDim(), ValV(){Gen(_XDim, _YDim);}
1772    explicit TVVec(const TVec&lt;TVal,TSizeTy&gt;&amp; _ValV, const TSizeTy&amp; _XDim, const TSizeTy&amp; _YDim):
1773      XDim(_XDim), YDim(_YDim), ValV(_ValV){ IAssert(ValV.Len()==XDim*YDim); }
1774    explicit TVVec(TSIn&amp; SIn) {Load(SIn);}
1775    void Load(TSIn&amp; SIn){XDim.Load(SIn); YDim.Load(SIn); ValV.Load(SIn);}
1776    void Save(TSOut&amp; SOut) const {
1777      XDim.Save(SOut); YDim.Save(SOut); ValV.Save(SOut);}
1778    TVVec&lt;TVal, TSizeTy&gt;&amp; operator=(const TVVec&lt;TVal, TSizeTy&gt;&amp; Vec){
1779      if (this!=&amp;Vec){XDim=Vec.XDim; YDim=Vec.YDim; ValV=Vec.ValV;} return *this;}
1780    bool operator==(const TVVec&amp; Vec) const {
1781      return (XDim==Vec.XDim)&amp;&amp;(YDim==Vec.YDim)&amp;&amp;(ValV==Vec.ValV);}
1782    bool Empty() const {return ValV.Len()==0;}
1783    void Clr(){XDim=0; YDim=0; ValV.Clr();}
1784    void Gen(const TSizeTy&amp; _XDim, const TSizeTy&amp; _YDim){
1785      Assert((_XDim&gt;=0)&amp;&amp;(_YDim&gt;=0));
1786      XDim=_XDim; YDim=_YDim; ValV.Gen(XDim*YDim);}
1787    TSizeTy GetXDim() const {return XDim;}
1788    TSizeTy GetYDim() const {return YDim;}
1789    TSizeTy GetRows() const {return XDim;}
1790    TSizeTy GetCols() const {return YDim;}
1791    TVec&lt;TVal, TSizeTy&gt;&amp; Get1DVec(){return ValV;}
1792    const TVal&amp; At(const TSizeTy&amp; X, const TSizeTy&amp; Y) const {
1793      Assert((0&lt;=X)&amp;&amp;(X&lt;TSizeTy(XDim))&amp;&amp;(0&lt;=Y)&amp;&amp;(Y&lt;TSizeTy(YDim)));
1794      return ValV[X*YDim+Y];}
1795    TVal&amp; At(const TSizeTy&amp; X, const TSizeTy&amp; Y){
1796      Assert((0&lt;=X)&amp;&amp;(X&lt;TSizeTy(XDim))&amp;&amp;(0&lt;=Y)&amp;&amp;(Y&lt;TSizeTy(YDim)));
1797      return ValV[X*YDim+Y];}
1798    TVal&amp; operator()(const TSizeTy&amp; X, const TSizeTy&amp; Y){
1799      return At(X, Y);}
1800    const TVal&amp; operator()(const TSizeTy&amp; X, const TSizeTy&amp; Y) const {
1801      return At(X, Y);}
1802    void PutXY(const TSizeTy&amp; X, const TSizeTy&amp; Y, const TVal&amp; Val){At(X, Y)=Val;}
1803    void PutAll(const TVal&amp; Val){ValV.PutAll(Val);}
1804    void PutX(const TSizeTy&amp; X, const TVal&amp; Val){
1805      for (TSizeTy Y=0; Y&lt;TSizeTy(YDim); Y++){At(X, Y)=Val;}}
1806    void PutY(const TSizeTy&amp; Y, const TVal&amp; Val){
1807      for (TSizeTy X=0; X&lt;TSizeTy(XDim); X++){At(X, Y)=Val;}}
1808    TVal GetXY(const TSizeTy&amp; X, const TSizeTy&amp; Y) const {
1809      Assert((0&lt;=X)&amp;&amp;(X&lt;TSizeTy(XDim))&amp;&amp;(0&lt;=Y)&amp;&amp;(Y&lt;TSizeTy(YDim)));
1810      return ValV[X*YDim+Y];}
1811    void GetRow(const TSizeTy&amp; RowN, TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const;
1812    void GetCol(const TSizeTy&amp; ColN, TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const;
1813    void SwapX(const TSizeTy&amp; X1, const TSizeTy&amp; X2);
1814    void SwapY(const TSizeTy&amp; Y1, const TSizeTy&amp; Y2);
1815    void Swap(TVVec&lt;TVal, TSizeTy&gt;&amp; Vec);
1816    void ShuffleX(TRnd&amp; Rnd);
1817    void ShuffleY(TRnd&amp; Rnd);
1818    void GetMxValXY(TSizeTy&amp; X, TSizeTy&amp; Y) const;
1819    void CopyFrom(const TVVec&lt;TVal, TSizeTy&gt;&amp; VVec);
1820    void AddXDim();
1821    void AddYDim();
1822    void DelX(const TSizeTy&amp; X);
1823    void DelY(const TSizeTy&amp; Y);
1824  };
1825  template &lt;class TVal, class TSizeTy&gt;
1826  void TVVec&lt;TVal, TSizeTy&gt;::SwapX(const TSizeTy&amp; X1, const TSizeTy&amp; X2){
1827    for (TSizeTy Y=0; Y&lt;TSizeTy(YDim); Y++){
1828      TVal Val=At(X1, Y); At(X1, Y)=At(X2, Y); At(X2, Y)=Val;}
1829  }
1830  template &lt;class TVal, class TSizeTy&gt;
1831  void TVVec&lt;TVal, TSizeTy&gt;::SwapY(const TSizeTy&amp; Y1, const TSizeTy&amp; Y2){
1832    for (TSizeTy X=0; X&lt;TSizeTy(XDim); X++){
1833      TVal Val=At(X, Y1); At(X, Y1)=At(X, Y2); At(X, Y2)=Val;}
1834  }
1835  template &lt;class TVal, class TSizeTy&gt;
1836  void TVVec&lt;TVal, TSizeTy&gt;::Swap(TVVec&lt;TVal, TSizeTy&gt;&amp; Vec){  
1837    if (this!=&amp;Vec){
1838      ::Swap(XDim, Vec.XDim);
1839      ::Swap(YDim, Vec.YDim);
1840      ValV.Swap(Vec.ValV);
1841    }
1842  }
1843  template &lt;class TVal, class TSizeTy&gt;
1844  void TVVec&lt;TVal, TSizeTy&gt;::ShuffleX(TRnd&amp; Rnd){
1845    for (TSizeTy X=0; X&lt;XDim-1; X++){SwapX(X, X+Rnd.GetUniDevInt(XDim-X));}
1846  }
1847  template &lt;class TVal, class TSizeTy&gt;
1848  void TVVec&lt;TVal, TSizeTy&gt;::ShuffleY(TRnd&amp; Rnd){
1849    for (TSizeTy Y=0; Y&lt;YDim-1; Y++){SwapY(Y, Y+Rnd.GetUniDevInt(YDim-Y));}
1850  }
1851  template &lt;class TVal, class TSizeTy&gt;
1852  void TVVec&lt;TVal, TSizeTy&gt;::GetMxValXY(TSizeTy&amp; X, TSizeTy&amp; Y) const {
1853    TSizeTy MxValN=ValV.GetMxValN();
1854    Y=MxValN%YDim;
1855    X=MxValN/YDim;
1856  }
1857  template &lt;class TVal, class TSizeTy&gt;
1858  void TVVec&lt;TVal, TSizeTy&gt;::CopyFrom(const TVVec&lt;TVal, TSizeTy&gt;&amp; VVec){
1859    TSizeTy CopyXDim = (GetXDim() &lt; VVec.GetXDim()) ? GetXDim() : VVec.GetXDim();
1860    TSizeTy CopyYDim = (GetYDim() &lt; VVec.GetYDim()) ? GetYDim() : VVec.GetYDim();
1861    for (TSizeTy X=0; X&lt;CopyXDim; X++){
1862      for (TSizeTy Y=0; Y&lt;CopyYDim; Y++){
1863        At(X, Y)=VVec.At(X, Y);
1864      }
1865    }
1866  }
1867  template &lt;class TVal, class TSizeTy&gt;
1868  void TVVec&lt;TVal, TSizeTy&gt;::AddXDim(){
1869    TVVec&lt;TVal, TSizeTy&gt; NewVVec(XDim+1, YDim);
1870    NewVVec.CopyFrom(*this);
1871    *this=NewVVec;
1872  }
1873  template &lt;class TVal, class TSizeTy&gt;
1874  void TVVec&lt;TVal, TSizeTy&gt;::AddYDim(){
1875    TVVec&lt;TVal, TSizeTy&gt; NewVVec(XDim, YDim+1);
1876    NewVVec.CopyFrom(*this);
1877    *this=NewVVec;
1878  }
1879  template &lt;class TVal, class TSizeTy&gt;
1880  void TVVec&lt;TVal, TSizeTy&gt;::DelX(const TSizeTy&amp; X){
1881    TVVec&lt;TVal, TSizeTy&gt; NewVVec(XDim-1, YDim);
1882    for (TSizeTy Y=0; Y&lt;YDim; Y++){
1883      for (TSizeTy LX=0; LX&lt;X; LX++){
1884        NewVVec.At(LX, Y)=At(LX, Y);}
1885      for (TSizeTy RX=X+1; RX&lt;XDim; RX++){
1886        NewVVec.At(RX-1, Y)=At(RX, Y);}
1887    }
1888    *this=NewVVec;
1889  }
1890  template &lt;class TVal, class TSizeTy&gt;
1891  void TVVec&lt;TVal, TSizeTy&gt;::DelY(const TSizeTy&amp; Y){
1892    TVVec&lt;TVal, TSizeTy&gt; NewVVec(XDim, YDim-1);
1893    for (TSizeTy X=0; X&lt;XDim; X++){
1894      for (TSizeTy LY=0; LY&lt;Y; LY++){
1895        NewVVec.At(X, LY)=At(X, LY);}
1896      for (TSizeTy RY=Y+1; RY&lt;YDim; RY++){
1897        NewVVec.At(X, RY-1)=At(X, RY);}
1898    }
1899    *this=NewVVec;
1900  }
1901  template &lt;class TVal, class TSizeTy &gt;
1902  void TVVec&lt;TVal, TSizeTy&gt;::GetRow(const TSizeTy&amp; RowN, TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const {
1903    Vec.Gen(GetCols(), 0);
1904    for (TSizeTy col = 0; col &lt; GetCols(); col++) {
1905      Vec.Add(At(RowN, col));
1906    }
1907  }
1908  template &lt;class TVal, class TSizeTy&gt;
1909  void TVVec&lt;TVal, TSizeTy&gt;::GetCol(const TSizeTy&amp; ColN, TVec&lt;TVal, TSizeTy&gt;&amp; Vec) const {
1910    Vec.Gen(GetRows(), 0);
1911    for (TSizeTy row = 0; row &lt; GetRows(); row++) {
1912      Vec.Add(At(row, ColN));
1913    }
1914  }
1915  typedef TVVec&lt;TBool&gt; TBoolVV;
1916  typedef TVVec&lt;TCh&gt; TChVV;
1917  typedef TVVec&lt;TInt&gt; TIntVV;
1918  typedef TVVec&lt;TSFlt&gt; TSFltVV;
1919  typedef TVVec&lt;TFlt&gt; TFltVV;
1920  typedef TVVec&lt;TStr&gt; TStrVV;
1921  typedef TVVec&lt;TIntPr&gt; TIntPrVV;
1922  template &lt;class TVal, class TSizeTy = int&gt;
1923  class TVVVec{
1924  private:
1925    TInt64 XDim, YDim, ZDim;
1926    TVec&lt;TVal, TSizeTy&gt; ValV;
1927  public:
1928    TVVVec(): XDim(), YDim(), ZDim(), ValV(){}
1929    TVVVec(const TVVVec&amp; Vec):
1930      XDim(Vec.XDim), YDim(Vec.YDim), ZDim(Vec.ZDim), ValV(Vec.ValV){}
1931    TVVVec(const TSizeTy&amp; _XDim, const TSizeTy&amp; _YDim, const TSizeTy&amp; _ZDim):
1932      XDim(), YDim(), ZDim(), ValV(){Gen(_XDim, _YDim, _ZDim);}
1933    explicit TVVVec(TSIn&amp; SIn):
1934      XDim(SIn), YDim(SIn), ZDim(SIn), ValV(SIn){}
1935    void Save(TSOut&amp; SOut) const {
1936      XDim.Save(SOut); YDim.Save(SOut); ZDim.Save(SOut); ValV.Save(SOut);}
1937    TVVVec&lt;TVal, TSizeTy&gt;&amp; operator=(const TVVVec&lt;TVal, TSizeTy&gt;&amp; Vec){
1938      XDim=Vec.XDim; YDim=Vec.YDim; ZDim=Vec.ZDim; ValV=Vec.ValV;
1939      return *this;
1940    }
1941    bool operator==(const TVVVec&amp; Vec) const {
1942      return (XDim==Vec.XDim)&amp;&amp;(YDim==Vec.YDim)&amp;&amp;(ZDim==Vec.ZDim)&amp;&amp;
1943       (ValV==Vec.ValV);}
1944    bool Empty() const {return ValV.Len()==0;}
1945    void Clr(){XDim=0; YDim=0; ZDim=0; ValV.Clr();}
1946    void Gen(const TSizeTy&amp; _XDim, const TSizeTy&amp; _YDim, const TSizeTy&amp; _ZDim){
1947      Assert((_XDim&gt;=0)&amp;&amp;(_YDim&gt;=0)&amp;&amp;(_ZDim&gt;=0));
1948      XDim=_XDim; YDim=_YDim; ZDim=_ZDim; ValV.Gen(XDim*YDim*ZDim);}
1949    TVal&amp; At(const TSizeTy&amp; X, const TSizeTy&amp; Y, const TSizeTy&amp; Z){
1950      Assert((0&lt;=X)&amp;&amp;(X&lt;TSizeTy(XDim))&amp;&amp;(0&lt;=Y)&amp;&amp;(Y&lt;TSizeTy(YDim))&amp;&amp;(0&lt;=Z)&amp;&amp;(Z&lt;TSizeTy(ZDim)));
1951      return ValV[X*YDim*ZDim+Y*ZDim+Z];}
1952    const TVal&amp; At(const TSizeTy&amp; X, const TSizeTy&amp; Y, const TSizeTy&amp; Z) const {
1953      Assert((0&lt;=X)&amp;&amp;(X&lt;TSizeTy(XDim))&amp;&amp;(0&lt;=Y)&amp;&amp;(Y&lt;TSizeTy(YDim))&amp;&amp;(0&lt;=Z)&amp;&amp;(Z&lt;TSizeTy(ZDim)));
1954      return ValV[X*YDim*ZDim+Y*ZDim+Z];}
1955    TVal&amp; operator()(const TSizeTy&amp; X, const TSizeTy&amp; Y, const TSizeTy&amp; Z){
1956      return At(X, Y, Z);}
1957    const TVal&amp; operator()(const TSizeTy&amp; X, const TSizeTy&amp; Y, const TSizeTy&amp; Z) const {
1958      return At(X, Y, Z);}
1959    TSizeTy GetXDim() const {return XDim;}
1960    TSizeTy GetYDim() const {return YDim;}
1961    TSizeTy GetZDim() const {return ZDim;}
1962  };
1963  typedef TVVVec&lt;TInt&gt; TIntVVV;
1964  typedef TVVVec&lt;TFlt&gt; TFltVVV;
1965  template &lt;class TVal&gt;
1966  class TTree{
1967  private:
1968    TVec&lt;TTriple&lt;TInt, TIntV, TVal&gt; &gt; NodeV; 
1969  public:
1970    TTree(): NodeV(){}
1971    TTree(const TTree&amp; Tree): NodeV(Tree.NodeV){}
1972    explicit TTree(TSIn&amp; SIn): NodeV(SIn){}
1973    void Save(TSOut&amp; SOut) const {NodeV.Save(SOut);}
1974    void LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm=&quot;&quot;);
1975    void SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const;
1976    TTree&amp; operator=(const TTree&amp; Tree){if (this!=&amp;Tree){NodeV=Tree.NodeV;} return *this;}
1977    bool operator==(const TTree&amp; Tree) const {return NodeV==Tree.NodeV;}
1978    bool operator&lt;(const TTree&amp; Tree) const {return false;}
1979    int GetPrimHashCd() const {return NodeV.GetPrimHashCd();}
1980    int GetSecHashCd() const {return NodeV.GetSecHashCd();}
1981    int GetMemUsed() const {return NodeV.GetMemUsed();}
1982    void Clr(){NodeV.Clr();}
1983    int AddNode(const int&amp; ParentNodeId, const TVal&amp; NodeVal=TVal()){
1984      IAssert(((ParentNodeId==-1)&amp;&amp;(NodeV.Len()==0))||(NodeV.Len()&gt;0));
1985      if (ParentNodeId!=-1){NodeV[ParentNodeId].Val2.Add(NodeV.Len());}
1986      return NodeV.Add(TTriple&lt;TInt, TIntV, TVal&gt;(ParentNodeId, TIntV(), NodeVal));}
1987    int AddRoot(const TVal&amp; NodeVal=TVal()){
1988      return AddNode(-1, NodeVal);}
1989    int GetNodes() const {return NodeV.Len();}
1990    void GetNodeIdV(TIntV&amp; NodeIdV, const int&amp; NodeId=0);
1991    int GetParentNodeId(const int&amp; NodeId) const {return NodeV[NodeId].Val1;}
1992    int GetChildren(const int&amp; NodeId) const {return NodeV[NodeId].Val2.Len();}
1993    int GetChildNodeId(const int&amp; NodeId, const int&amp; ChildN) const {return NodeV[NodeId].Val2[ChildN];}
1994    TVal&amp; GetNodeVal(const int&amp; NodeId){return NodeV[NodeId].Val3;}
1995    void GenRandomTree(const int&amp; Nodes, TRnd&amp; Rnd);
1996    void DelNode(const int&amp; NodeId);
1997    void CopyTree(const int&amp; SrcNodeId, TTree&amp; DstTree, const int&amp; DstParentNodeId=-1);
1998    void WrTree(const int&amp; NodeId=0, const int&amp; Lev=0);
1999  };
2000  template &lt;class TVal&gt;
2001  void TTree&lt;TVal&gt;::GetNodeIdV(TIntV&amp; NodeIdV, const int&amp; NodeId){
2002    if (NodeId==0){NodeIdV.Clr(); if (GetNodes()==0){return;}}
2003    else if (GetParentNodeId(NodeId)==-1){return;}
2004    NodeIdV.Add(NodeId);
2005    for (int ChildN=0; ChildN&lt;GetChildren(NodeId); ChildN++){
2006      int ChildNodeId=GetChildNodeId(NodeId, ChildN);
2007      if (ChildNodeId!=-1){
2008        GetNodeIdV(NodeIdV, ChildNodeId);
2009      }
2010    }
2011  }
2012  template &lt;class TVal&gt;
2013  void TTree&lt;TVal&gt;::GenRandomTree(const int&amp; Nodes, TRnd&amp; Rnd){
2014    Clr();
2015    if (Nodes&gt;0){
2016      AddRoot(TVal());
2017      for (int NodeN=1; NodeN&lt;Nodes; NodeN++){
2018        int ParentNodeId=Rnd.GetUniDevInt(0, GetNodes()-1);
2019        AddNode(ParentNodeId, TVal());
2020      }
2021    }
2022  }
2023  template &lt;class TVal&gt;
2024  void TTree&lt;TVal&gt;::DelNode(const int&amp; NodeId){
2025    if (NodeId==0){
2026      Clr();
2027    } else {
2028      TIntV&amp; ChildNodeIdV=NodeV[GetParentNodeId(NodeId)].Val2;
2029      int ChildNodeIdN=ChildNodeIdV.SearchForw(NodeId);
2030      ChildNodeIdV[ChildNodeIdN]=-1;
2031    }
2032  }
2033  template &lt;class TVal&gt;
2034  void TTree&lt;TVal&gt;::CopyTree(const int&amp; SrcNodeId, TTree&amp; DstTree, const int&amp; DstParentNodeId){
2035    int DstNodeId=DstTree.AddNode(DstParentNodeId, GetNodeVal(SrcNodeId));
2036    for (int ChildN=0; ChildN&lt;GetChildren(SrcNodeId); ChildN++){
2037      int ChildNodeId=GetChildNodeId(SrcNodeId, ChildN);
2038      if (ChildNodeId!=-1){
2039        CopyTree(ChildNodeId, DstTree, DstNodeId);
2040      }
2041    }
2042  }
2043  template &lt;class TVal&gt;
2044  void TTree&lt;TVal&gt;::WrTree(const int&amp; NodeId, const int&amp; Lev){
2045    for (int LevN=0; LevN&lt;Lev; LevN++){printf(&quot;| &quot;);}
2046    printf(&quot;%d (%d)\n&quot;, NodeId, GetChildren(NodeId));
2047    for (int ChildN=0; ChildN&lt;GetChildren(NodeId); ChildN++){
2048      int ChildNodeId=GetChildNodeId(NodeId, ChildN);
2049      if (ChildNodeId!=-1){
2050        WrTree(ChildNodeId, Lev+1);
2051      }
2052    }
2053  }
2054  typedef TTree&lt;TInt&gt; TIntTree;
2055  typedef TTree&lt;TFlt&gt; TFltTree;
2056  typedef TTree&lt;TStr&gt; TStrTree;
2057  typedef TTree&lt;TStrIntPr&gt; TStrIntPrTree;
2058  typedef TTree&lt;TStrIntStrVTr&gt; TStrIntStrVTrTree;
2059  template &lt;class TVal&gt;
2060  class TSStack{
2061  private:
2062    TVec&lt;TVal&gt; ValV;
2063  public:
2064    TSStack(): ValV(){}
2065    TSStack(const int&amp; MxVals): ValV(MxVals, 0){}
2066    TSStack(const TSStack&amp; Stack): ValV(Stack.ValV){}
2067    explicit TSStack(TSIn&amp; SIn): ValV(SIn){}
2068    void Save(TSOut&amp; SOut) const {ValV.Save(SOut);}
2069    TSStack&amp; operator=(const TSStack&amp; Stack){
2070      if (this!=&amp;Stack){ValV=Stack.ValV;} return *this;}
2071    bool operator==(const TSStack&amp; Stack) const {return this==&amp;Stack;}
2072    const TVal&amp; operator[](const int&amp; ValN) const {return ValV[ValV.Len()-ValN-1];}
2073    TVal&amp; operator[](const int&amp; ValN) {return ValV[ValV.Len()-ValN-1];}
2074    bool Empty(){return ValV.Len()==0;}
2075    void Clr(const bool&amp; DoDel=false) {ValV.Clr(DoDel);}
2076    bool IsIn(const TVal&amp; Val) const {return ValV.IsIn(Val);}
2077    int Len(){return ValV.Len();}
2078    TVal&amp; Top(){Assert(0&lt;ValV.Len()); return ValV.Last();}
2079    const TVal&amp; Top() const {Assert(0&lt;ValV.Len()); return ValV.Last();}
2080    void Push(){ValV.Add();}
2081    void Push(const TVal&amp; Val){ValV.Add(Val);}
2082    void Pop(){Assert(0&lt;ValV.Len()); ValV.DelLast();}
2083  };
2084  typedef TSStack&lt;TInt&gt; TIntS;
2085  typedef TSStack&lt;TBoolChPr&gt; TBoolChS;
2086  template &lt;class TVal&gt;
2087  class TQQueue{
2088  private:
2089    TInt MxLast, MxLen;
2090    TInt First, Last;
2091    TVec&lt;TVal&gt; ValV;
2092  public:
2093    TQQueue(const int&amp; _MxLast=64, const int&amp; _MxLen=-1):
2094      MxLast(_MxLast), MxLen(_MxLen), First(0), Last(0), ValV(){
2095      Assert(int(MxLast)&gt;0); Assert((MxLen==-1)||(int(MxLen)&gt;0));}
2096    TQQueue(const TQQueue&amp; Queue):
2097      MxLast(Queue.MxLast), MxLen(Queue.MxLen),
2098      First(Queue.First), Last(Queue.Last), ValV(Queue.ValV){}
2099    explicit TQQueue(TSIn&amp; SIn):
2100      MxLast(SIn), MxLen(SIn), First(SIn), Last(SIn), ValV(SIn){}
2101    void Save(TSOut&amp; SOut) const {
2102      MxLast.Save(SOut); MxLen.Save(SOut);
2103      First.Save(SOut); Last.Save(SOut); ValV.Save(SOut);}
2104    TQQueue&amp; operator=(const TQQueue&amp; Queue){
2105      if (this!=&amp;Queue){MxLast=Queue.MxLast; MxLen=Queue.MxLen;
2106        First=Queue.First; Last=Queue.Last; ValV=Queue.ValV;}
2107      return *this;}
2108    const TVal&amp; operator[](const int&amp; ValN) const {Assert((0&lt;=ValN)&amp;&amp;(ValN&lt;Len()));
2109      return ValV[Last+ValN];}
2110    void Clr(const bool&amp; DoDel=true){ValV.Clr(DoDel); First=Last=0;}
2111    void Gen(const int&amp; _MxLast=64, const int&amp; _MxLen=-1){
2112      MxLast=_MxLast; MxLen=_MxLen; First=0; Last=0; ValV.Clr();}
2113    void GetSubValV(const int&amp; _BValN, const int&amp; _EValN, TVec&lt;TVal&gt;&amp; SubValV) const {
2114      int BValN=TInt::GetMx(0, _BValN);
2115      int EValN=TInt::GetMn(Len()-1, _EValN);
2116      SubValV.Gen(EValN-BValN+1);
2117      for (int ValN=BValN; ValN&lt;=EValN; ValN++){
2118        SubValV[ValN-BValN]=ValV[Last+ValN];}
2119    }
2120    bool Empty() const {return First==Last;}
2121    int Len() const {return First-Last;}
2122    const TVal&amp; Top() const {
2123      Assert(First!=Last); return ValV[Last];}
2124    void Pop(){
2125      IAssert(First!=Last); Last++;
2126      if (First==Last){ValV.Clr(); First=Last=0;}}
2127    void Push(const TVal&amp; Val){
2128      if (Last&gt;MxLast){ValV.Del(0, Last-1); First-=Last; Last=0;}
2129      if ((MxLen!=-1)&amp;&amp;(MxLen==Len())){Pop();}
2130      First++; ValV.Add(Val);}
2131    void Shuffle(TRnd&amp; Rnd){
2132      TVec&lt;TVal&gt; ValV(Len(), 0); while (!Empty()){ValV.Add(Top()); Pop();}
2133      ValV.Shuffle(Rnd); Clr();
2134      for (int ValN=0; ValN&lt;ValV.Len(); ValN++){Push(ValV[ValN]);}}
2135  };
2136  typedef TQQueue&lt;TInt&gt; TIntQ;
2137  typedef TQQueue&lt;TFlt&gt; TFltQ;
2138  typedef TQQueue&lt;TStr&gt; TStrQ;
2139  typedef TQQueue&lt;TIntPr&gt; TIntPrQ;
2140  typedef TQQueue&lt;TIntStrPr&gt; TIntStrPrQ;
2141  typedef TQQueue&lt;TFltV&gt; TFltVQ;
2142  typedef TQQueue&lt;TAscFltV&gt; TAscFltVQ;
2143  typedef TVec&lt;TQQueue&lt;TInt&gt; &gt; TIntQV;
2144  template &lt;class TVal&gt;
2145  class TLstNd{
2146  public:
2147    TLstNd* PrevNd;
2148    TLstNd* NextNd;
2149    TVal Val;
2150  public:
2151    TLstNd(): PrevNd(NULL), NextNd(NULL), Val(){}
2152    TLstNd(const TLstNd&amp;);
2153    TLstNd(TLstNd* _PrevNd, TLstNd* _NextNd, const TVal&amp; _Val):
2154      PrevNd(_PrevNd), NextNd(_NextNd), Val(_Val){}
2155    TLstNd&amp; operator=(const TLstNd&amp;);
2156    bool IsPrev() const {return (PrevNd != NULL); }
2157    bool IsNext() const {return (NextNd != NULL); }
2158    TLstNd* Prev() const {Assert(this!=NULL); return PrevNd;}
2159    TLstNd* Next() const {Assert(this!=NULL); return NextNd;}
2160    TVal&amp; GetVal(){Assert(this!=NULL); return Val;}
2161    const TVal&amp; GetVal() const {Assert(this!=NULL); return Val;}
2162  };
2163  template &lt;class TVal&gt;
2164  class TLst{
2165  public:
2166    typedef TLstNd&lt;TVal&gt;* PLstNd;
2167  private:
2168    int Nds;
2169    PLstNd FirstNd;
2170    PLstNd LastNd;
2171  public:
2172    TLst(): Nds(0), FirstNd(NULL), LastNd(NULL){}
2173    TLst(const TLst&amp;);
2174    ~TLst(){Clr();}
2175    explicit TLst(TSIn&amp; SIn);
2176    void Save(TSOut&amp; SOut) const;
2177    TLst&amp; operator=(const TLst&amp;);
2178    void Clr(){
2179      PLstNd Nd=FirstNd;
2180      while (Nd!=NULL){PLstNd NextNd=Nd-&gt;NextNd; delete Nd; Nd=NextNd;}
2181      Nds=0; FirstNd=NULL; LastNd=NULL;}
2182    bool Empty() const {return Nds==0;}
2183    int Len() const {return Nds;}
2184    PLstNd First() const {return FirstNd;}
2185    PLstNd Last() const {return LastNd;}
2186    TVal&amp; FirstVal() const {return FirstNd-&gt;GetVal();}
2187    TVal&amp; LastVal() const {return LastNd-&gt;GetVal();}
2188    PLstNd AddFront(const TVal&amp; Val);
2189    PLstNd AddBack(const TVal&amp; Val);
2190    PLstNd AddFrontSorted(const TVal&amp; Val, const bool&amp; Asc=true);
2191    PLstNd AddBackSorted(const TVal&amp; Val, const bool&amp; Asc=true);
2192    void PutFront(const PLstNd&amp; Nd);
2193    void PutBack(const PLstNd&amp; Nd);
2194    PLstNd Ins(const PLstNd&amp; Nd, const TVal&amp; Val);
2195    void Del(const TVal&amp; Val);
2196    void Del(const PLstNd&amp; Nd);
2197    void DelFirst() { PLstNd DelNd = FirstNd; Del(DelNd); }
2198    void DelLast() { PLstNd DelNd = LastNd; Del(DelNd); }
2199    PLstNd SearchForw(const TVal&amp; Val);
2200    PLstNd SearchBack(const TVal&amp; Val);
2201    friend class TLstNd&lt;TVal&gt;;
2202  };
<span onclick='openModal()' class='match'>2203  template &lt;class TVal&gt;
2204  TLst&lt;TVal&gt;::TLst(TSIn&amp; SIn):
2205    Nds(0), FirstNd(NULL), LastNd(NULL){
</span>2206    int CheckNds=0; SIn.Load(CheckNds);
2207    for (int NdN=0; NdN&lt;CheckNds; NdN++){AddBack(TVal(SIn));}
2208    Assert(Nds==CheckNds);
2209  }
2210  template &lt;class TVal&gt;
2211  void TLst&lt;TVal&gt;::Save(TSOut&amp; SOut) const {
2212    SOut.Save(Nds);
2213    PLstNd Nd=FirstNd; int CheckNds=0;
2214    while (Nd!=NULL){
2215      Nd-&gt;Val.Save(SOut); Nd=Nd-&gt;NextNd; CheckNds++;}
2216    IAssert(Nds==CheckNds);
2217  }
2218  template &lt;class TVal&gt;
2219  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::AddFront(const TVal&amp; Val){
2220    PLstNd Nd=new TLstNd&lt;TVal&gt;(NULL, FirstNd, Val);
2221    if (FirstNd!=NULL){FirstNd-&gt;PrevNd=Nd; FirstNd=Nd;}
2222    else {FirstNd=Nd; LastNd=Nd;}
2223    Nds++; return Nd;
2224  }
2225  template &lt;class TVal&gt;
2226  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::AddBack(const TVal&amp; Val){
2227    PLstNd Nd=new TLstNd&lt;TVal&gt;(LastNd, NULL, Val);
2228    if (LastNd!=NULL){LastNd-&gt;NextNd=Nd; LastNd=Nd;}
2229    else {FirstNd=Nd; LastNd=Nd;}
2230    Nds++; return Nd;
2231  }
2232  template &lt;class TVal&gt;
2233  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::AddFrontSorted(const TVal&amp; Val, const bool&amp; Asc){
2234    PLstNd Nd=First();
2235    if (Nd==NULL){
2236      return Ins(Nd, Val);
2237    } else {
2238      while ((Nd!=NULL)&amp;&amp;((Asc&amp;&amp;(Val&gt;Nd()))||(!Asc&amp;&amp;(Val&lt;Nd())))){
2239        Nd=Nd-&gt;Next();}
2240      if (Nd==NULL){return Ins(Nd-&gt;Last(), Val);}
2241      else {return Ins(Nd-&gt;Prev(), Val);}
2242    }
2243  }
2244  template &lt;class TVal&gt;
2245  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::AddBackSorted(const TVal&amp; Val, const bool&amp; Asc){
2246    PLstNd Nd=Last();
2247    while ((Nd!=NULL)&amp;&amp;((Asc&amp;&amp;(Val&lt;Nd-&gt;Val))||(!Asc&amp;&amp;(Val&gt;Nd-&gt;Val)))){
2248      Nd=Nd-&gt;Prev();}
2249    return Ins(Nd, Val);
2250  }
2251  template &lt;class TVal&gt;
2252  void TLst&lt;TVal&gt;::PutFront(const PLstNd&amp; Nd){
2253    Assert(Nd!=NULL);
2254    if (Nd-&gt;PrevNd==NULL){FirstNd=Nd-&gt;NextNd;}
2255    else {Nd-&gt;PrevNd-&gt;NextNd=Nd-&gt;NextNd;}
2256    if (Nd-&gt;NextNd==NULL){LastNd=Nd-&gt;PrevNd;}
2257    else {Nd-&gt;NextNd-&gt;PrevNd=Nd-&gt;PrevNd;}
2258    Nd-&gt;PrevNd=NULL; Nd-&gt;NextNd=FirstNd;
2259    if (FirstNd!=NULL){FirstNd-&gt;PrevNd=Nd; FirstNd=Nd;}
2260    else {FirstNd=Nd; LastNd=Nd;}
2261  }
2262  template &lt;class TVal&gt;
2263  void TLst&lt;TVal&gt;::PutBack(const PLstNd&amp; Nd){
2264    Assert(Nd!=NULL);
2265    if (Nd-&gt;PrevNd==NULL){FirstNd=Nd-&gt;NextNd;}
2266    else {Nd-&gt;PrevNd-&gt;NextNd=Nd-&gt;NextNd;}
2267    if (Nd-&gt;NextNd==NULL){LastNd=Nd-&gt;PrevNd;}
2268    else {Nd-&gt;NextNd-&gt;PrevNd=Nd-&gt;PrevNd;}
2269    Nd-&gt;PrevNd=LastNd; Nd-&gt;NextNd=NULL;
2270    if (LastNd!=NULL){LastNd-&gt;NextNd=Nd; LastNd=Nd;}
2271    else {FirstNd=Nd; LastNd=Nd;}
2272  }
2273  template &lt;class TVal&gt;
2274  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::Ins(const PLstNd&amp; Nd, const TVal&amp; Val){
2275    if (Nd==NULL){return AddFront(Val);}
2276    else if (Nd-&gt;NextNd==NULL){return AddBack(Val);}
2277    else {
2278      PLstNd NewNd=new TLstNd&lt;TVal&gt;(Nd, Nd-&gt;NextNd, Val);
2279      Nd-&gt;NextNd=NewNd; NewNd-&gt;NextNd-&gt;PrevNd=Nd;
2280      Nds++; return Nd;
2281    }
2282  }
2283  template &lt;class TVal&gt;
2284  void TLst&lt;TVal&gt;::Del(const TVal&amp; Val){
2285    PLstNd Nd=SearchForw(Val);
2286    if (Nd!=NULL){Del(Nd);}
2287  }
2288  template &lt;class TVal&gt;
2289  void TLst&lt;TVal&gt;::Del(const PLstNd&amp; Nd){
2290    Assert(Nd!=NULL);
2291    if (Nd-&gt;PrevNd==NULL){FirstNd=Nd-&gt;NextNd;}
2292    else {Nd-&gt;PrevNd-&gt;NextNd=Nd-&gt;NextNd;}
2293    if (Nd-&gt;NextNd==NULL){LastNd=Nd-&gt;PrevNd;}
2294    else {Nd-&gt;NextNd-&gt;PrevNd=Nd-&gt;PrevNd;}
2295    Nds--; delete Nd;
2296  }
2297  template &lt;class TVal&gt;
2298  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::SearchForw(const TVal&amp; Val){
2299    PLstNd Nd=First();
2300    while (Nd!=NULL){
2301      if (Nd-&gt;GetVal()==Val){return Nd;}
2302      Nd=Nd-&gt;Next();
2303    }
2304    return NULL;
2305  }
2306  template &lt;class TVal&gt;
2307  TLstNd&lt;TVal&gt;* TLst&lt;TVal&gt;::SearchBack(const TVal&amp; Val){
2308    PLstNd Nd=Last();
2309    while (Nd!=NULL){
2310      if (Nd-&gt;GetVal()==Val){return Nd;}
2311      Nd=Nd-&gt;Prev();
2312    }
2313    return NULL;
2314  }
2315  typedef TLst&lt;TInt&gt; TIntL;
2316  typedef TLstNd&lt;TInt&gt;* PIntLN;
2317  typedef TLst&lt;TIntKd&gt; TIntKdL;
2318  typedef TLstNd&lt;TIntKd&gt;* PIntKdLN;
2319  typedef TLst&lt;TFlt&gt; TFltL;
2320  typedef TLstNd&lt;TFlt&gt;* PFltLN;
2321  typedef TLst&lt;TFltIntKd&gt; TFltIntKdL;
2322  typedef TLstNd&lt;TFltIntKd&gt;* PFltIntKdLN;
2323  typedef TLst&lt;TAscFltIntKd&gt; TAscFltIntKdL;
2324  typedef TLstNd&lt;TAscFltIntKd&gt;* PAscFltIntKdLN;
2325  typedef TLst&lt;TStr&gt; TStrL;
2326  typedef TLstNd&lt;TStr&gt;* PStrLN;
2327  template &lt;class THd, class TRec&gt;
2328  class TFRec{
2329  private:
2330    PFRnd FRnd;
2331  public:
2332    TFRec(const TStr&amp; FNm, const TFAccess&amp; FAccess, const bool&amp; CreateIfNo):
2333      FRnd(PFRnd(new TFRnd(FNm, FAccess, CreateIfNo, sizeof(THd), sizeof(TRec)))){}
2334    TFRec(const TFRec&amp;);
2335    TFRec&amp; operator=(const TFRec&amp;);
2336    void SetRecN(const int&amp; RecN){FRnd-&gt;SetRecN(RecN);}
2337    int GetRecN(){return FRnd-&gt;GetRecN();}
2338    int GetRecs(){return FRnd-&gt;GetRecs();}
2339    void GetHd(THd&amp; Hd){FRnd-&gt;GetHd(&amp;Hd);}
2340    void PutHd(const THd&amp; Hd){FRnd-&gt;PutHd(&amp;Hd);}
2341    void GetRec(TRec&amp; Rec, const int&amp; RecN=-1){FRnd-&gt;GetRec(&amp;Rec, RecN);}
2342    void PutRec(const TRec&amp; Rec, const int&amp; RecN=-1){FRnd-&gt;PutRec(&amp;Rec, RecN);}
2343  };
2344  template &lt;class TFuncPt&gt;
2345  class TFunc{
2346  private:
2347    TFuncPt FuncPt;
2348  public:
2349    TFunc(): FuncPt(NULL){}
2350    TFunc(const TFunc&amp; Func): FuncPt(Func.FuncPt){}
2351    TFunc(const TFuncPt&amp; _FuncPt): FuncPt(_FuncPt){}
2352    TFunc(TSIn&amp;){Fail;}
2353    void Save(TSOut&amp;) const {Fail;}
2354    TFunc&amp; operator=(const TFunc&amp; Func){
2355      if (this!=&amp;Func){FuncPt=Func.FuncPt;} return *this;}
2356    bool operator==(const TFunc&amp; Func) const {
2357      return FuncPt==Func.FuncPt;}
2358    bool operator&lt;(const TFunc&amp;) const {
2359      Fail; return false;}
2360    TFuncPt operator()() const {return FuncPt;}
2361  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmlser.h</h3>
            <pre><code>1  #ifndef _xmlser_h
2  #define _xmlser_h
<span onclick='openModal()' class='match'>3  template &lt;class TRec&gt;
4  TPt&lt;TRec&gt;::TPt(TSIn&amp; SIn):
5      Addr(NULL){TBool IsNull(SIn);
</span>6      if (!IsNull){TPt Pt=TRec::Load(SIn); Addr=Pt.Addr; MkRef();}}
7  template &lt;class TRec&gt;
8  TPt&lt;TRec&gt;::TPt(TSIn&amp; SIn, void* ThisPt):
9      Addr(NULL){TBool IsNull(SIn);
10      if (!IsNull){TPt Pt=TRec::Load(SIn, ThisPt); Addr=Pt.Addr; MkRef();}}
11  template &lt;class TRec&gt;
12  void TPt&lt;TRec&gt;::Save(TSOut&amp; SOut) const {
13      if (Addr==NULL){TBool(true).Save(SOut);}
14      else {TBool(false).Save(SOut); Addr-&gt;Save(SOut);}}
15  template &lt;class TRec&gt;
16  void TPt&lt;TRec&gt;::LoadXml(const TPt&lt;TXmlTok&gt;&amp; XmlTok, const TStr&amp; Nm){
17    XLoadHd(Nm);
18    bool NullP=TXmlObjSer::GetBoolArg(XmlTok, &quot;Null&quot;);
19    if (NullP){
20      Addr=NULL;
21    } else {
22      Addr=new TRec(); MkRef();
23      Addr-&gt;LoadXml(XmlTok, &quot;-&quot;);
24    }
25  }
26  template &lt;class TRec&gt;
27  void TPt&lt;TRec&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
28    if (Addr==NULL){
29      XSaveBETagArg(Nm, &quot;Null&quot;, TBool::GetStr(true));
30    } else {
31      XSaveHdArg(Nm, &quot;Null&quot;, TBool::GetStr(false));
32      Addr-&gt;SaveXml(SOut, &quot;-&quot;);
33    }
34  }
35  template &lt;class TRec&gt;
36  bool IsXLoadFromFileOk(const TStr&amp; FNm, const TStr&amp; Nm, TRec&amp; Rec, TStr&amp; MsgStr){
37    bool Ok=true;
38    try {
39      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(FNm);
40      if (XmlDoc-&gt;IsOk()){
41        PXmlTok XmlTok=XmlDoc-&gt;GetTok();
42        Rec.LoadXml(XmlTok, Nm);
43      } else {
44        Ok=false; MsgStr=XmlDoc-&gt;GetMsgStr();
45      }
46    }
47    catch (PExcept Except){
48      Ok=false; MsgStr=Except-&gt;GetMsgStr();
49    }
50    return Ok;
51  }
52  template &lt;class TRec&gt;
53  void XLoadFromFile(const TStr&amp; FNm, const TStr&amp; Nm, TRec&amp; Rec){
54    TStr MsgStr;
55    if (!IsXLoadFromFileOk(FNm, Nm, Rec, MsgStr)){
56      TExcept::Throw(MsgStr);
57    }
58  }
59  template &lt;class TVal1, class TVal2&gt;
60  void TPair&lt;TVal1, TVal2&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
61  	XLoadHd(Nm); XLoad(Val1); XLoad(Val2);}
62  template &lt;class TVal1, class TVal2&gt;
63  void TPair&lt;TVal1, TVal2&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
64  	XSaveHd(Nm); XSave(Val1); XSave(Val2);}
65  template &lt;class TVal1, class TVal2, class TVal3&gt;
66  void TTriple&lt;TVal1, TVal2, TVal3&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
67  	XLoadHd(Nm); XLoad(Val1); XLoad(Val2); XLoad(Val3);}
68  template &lt;class TVal1, class TVal2, class TVal3&gt;
69  void TTriple&lt;TVal1, TVal2, TVal3&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
70  	XSaveHd(Nm); XSave(Val1); XSave(Val2); XSave(Val3);}
71  template &lt;class TVal1, class TVal2, class TVal3, class TVal4&gt;
72  void TQuad&lt; TVal1, TVal2, TVal3, TVal4&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
73  	XLoadHd(Nm); XLoad(Val1); XLoad(Val2); XLoad(Val3); XLoad(Val4);}
74  template &lt;class TVal1, class TVal2, class TVal3, class TVal4&gt;
75  void TQuad&lt; TVal1, TVal2, TVal3, TVal4&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
76  	XSaveHd(Nm); XSave(Val1); XSave(Val2); XSave(Val3); XSave(Val4);}
77  template &lt;class TKey, class TDat&gt;
78  void TKeyDat&lt; TKey, TDat&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
79  	XLoadHd(Nm); XLoad(Key); XLoad(Dat);}
80  template &lt;class TKey, class TDat&gt;
81  void TKeyDat&lt; TKey, TDat&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
82  	XSaveHd(Nm); XSave(Key); XSave(Dat);}
83  template &lt;class TVal, class TSizeTy&gt;
84  void TVec&lt;TVal, TSizeTy&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
85    XLoadHd(Nm);
86    TSizeTy SubToks=XmlTok-&gt;GetSubToks(); Gen(SubToks, 0);
87    for (TSizeTy SubTokN=0; SubTokN&lt;SubToks; SubTokN++){
88      PXmlTok SubTok=XmlTok-&gt;GetSubTok(SubTokN);
89      TVal Val; Val.LoadXml(SubTok, TStr()); Add(Val);
90    }
91  }
92  template &lt;class TVal, class TSizeTy&gt;
93  void TVec&lt;TVal, TSizeTy&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
94    XSaveHdArg(Nm, &quot;Vals&quot;, TInt::GetStr(Vals));
95    for (TSizeTy ValN=0; ValN&lt;Vals; ValN++){ValT[ValN].SaveXml(SOut, TStr());}
96  }
97  template &lt;class TKey, class TDat&gt;
98  void THashKeyDat&lt; TKey, TDat&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
99  	XLoadHd(Nm); XLoad(Key); XLoad(Dat);}
100  template &lt;class TKey, class TDat&gt;
101  void THashKeyDat&lt; TKey, TDat&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm) const {
102  	XSaveHd(Nm); XSave(Key); XSave(Dat);}
103  template&lt;class TKey, class TDat, class THashFunc&gt;
104  void THash&lt; TKey, TDat, THashFunc&gt;::LoadXml(const PXmlTok&amp; XmlTok, const TStr&amp; Nm){
105    XLoadHd(Nm); TVec&lt;THashKeyDat&lt;TKey, TDat&gt; &gt; KeyDatV; XLoad(KeyDatV); XLoad(AutoSizeP);
106  	for (int KeyDatN=0; KeyDatN&lt;KeyDatV.Len(); KeyDatN++){
107  		AddDat(KeyDatV[KeyDatN].Key, KeyDatV[KeyDatN].Dat);}}
108  template&lt;class TKey, class TDat, class THashFunc&gt;
109  void THash&lt; TKey, TDat, THashFunc&gt;::SaveXml(TSOut&amp; SOut, const TStr&amp; Nm){
110    Defrag(); XSaveHd(Nm); XSave(KeyDatV); XSave(AutoSizeP);}
111  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ds.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xmlser.h</div>
                </div>
                <div class="column column_space"><pre><code>2203  template &lt;class TVal&gt;
2204  TLst&lt;TVal&gt;::TLst(TSIn&amp; SIn):
2205    Nds(0), FirstNd(NULL), LastNd(NULL){
</pre></code></div>
                <div class="column column_space"><pre><code>3  template &lt;class TRec&gt;
4  TPt&lt;TRec&gt;::TPt(TSIn&amp; SIn):
5      Addr(NULL){TBool IsNull(SIn);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    