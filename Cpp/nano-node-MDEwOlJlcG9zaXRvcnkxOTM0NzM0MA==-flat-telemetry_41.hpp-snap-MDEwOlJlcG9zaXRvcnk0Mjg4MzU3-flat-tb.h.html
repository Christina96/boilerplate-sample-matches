
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.610966057441253%, Tokens: 10</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-telemetry_41.hpp</h3>
            <pre><code>1  #pragma once
2  #include <nano/lib/utility.hpp>
3  #include <nano/node/common.hpp>
4  #include <nano/node/messages.hpp>
5  #include <nano/node/nodeconfig.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/multi_index/hashed_index.hpp>
8  #include <boost/multi_index/member.hpp>
9  #include <boost/multi_index/ordered_index.hpp>
10  #include <boost/multi_index_container.hpp>
11  #include <functional>
12  #include <memory>
13  #include <optional>
14  #include <thread>
15  namespace mi = boost::multi_index;
16  namespace nano
17  {
18  class node;
19  class network;
20  class node_observers;
21  class stats;
22  class ledger;
23  class thread_pool;
24  class unchecked_map;
25  namespace transport
26  {
27  	class channel;
28  }
29  class telemetry
30  {
31  public:
32  	struct config
33  	{
34  		bool enable_ongoing_requests{ true };
<span onclick='openModal()' class='match'>35  		bool enable_ongoing_broadcasts{ true };
36  		config (nano::node_config const & config, nano::node_flags const & flags) :
37  			enable_ongoing_requests{ !flags.disable_ongoing_telemetry_requests },
38  			enable_ongoing_broadcasts{ !flags.disable_providing_telemetry_metrics }
39  		{
40  		}
</span>41  	};
42  public:
43  	telemetry (config const &, nano::node &, nano::network &, nano::node_observers &, nano::network_params &, nano::stats &);
44  	~telemetry ();
45  	void start ();
46  	void stop ();
47  	void process (nano::telemetry_ack const &, std::shared_ptr<nano::transport::channel> const &);
48  	void trigger ();
49  	std::size_t size () const;
50  	std::optional<nano::telemetry_data> get_telemetry (nano::endpoint const &) const;
51  	std::unordered_map<nano::endpoint, nano::telemetry_data> get_all_telemetries () const;
52  public: 
53  	std::unique_ptr<nano::container_info_component> collect_container_info (std::string const & name);
54  private: 
55  	nano::node & node;
56  	nano::network & network;
57  	nano::node_observers & observers;
58  	nano::network_params & network_params;
59  	nano::stats & stats;
60  	const config config_m;
61  private:
62  	struct entry
63  	{
64  		nano::endpoint endpoint;
65  		nano::telemetry_data data;
66  		std::chrono::steady_clock::time_point last_updated;
67  		std::shared_ptr<nano::transport::channel> channel;
68  	};
69  private:
70  	bool request_predicate () const;
71  	bool broadcast_predicate () const;
72  	void run ();
73  	void run_requests ();
74  	void run_broadcasts ();
75  	void cleanup ();
76  	void request (std::shared_ptr<nano::transport::channel> &);
77  	void broadcast (std::shared_ptr<nano::transport::channel> &, nano::telemetry_data const &);
78  	bool verify (nano::telemetry_ack const &, std::shared_ptr<nano::transport::channel> const &) const;
79  	bool check_timeout (entry const &) const;
80  private:
81  	class tag_sequenced {};
82  	class tag_endpoint {};
83  	using ordered_telemetries = boost::multi_index_container<entry,
84  	mi::indexed_by<
85  		mi::sequenced<mi::tag<tag_sequenced>>,
86  		mi::hashed_unique<mi::tag<tag_endpoint>,
87  			mi::member<entry, nano::endpoint, &entry::endpoint>>
88  	>>;
89  	ordered_telemetries telemetries;
90  	bool triggered{ false };
91  	std::chrono::steady_clock::time_point last_request{};
92  	std::chrono::steady_clock::time_point last_broadcast{};
93  	bool stopped{ false };
94  	mutable nano::mutex mutex{ mutex_identifier (mutexes::telemetry) };
95  	nano::condition_variable condition;
96  	std::thread thread;
97  private:
98  	static std::size_t constexpr max_size = 1024;
99  };
100  nano::telemetry_data consolidate_telemetry_data (std::vector<telemetry_data> const & telemetry_data);
101  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</h3>
            <pre><code>1  ClassHdTP(TTb, PTb);
2  typedef enum {
3    tsvcUndef, tsvcIgnore, tsvcLabel, tsvcClass, tsvcAttr} TTbSufixVarCat;
4  ClassTPV(TTbVarType, PTbVarType, TTbVarTypeV)
5  private:
6    TBool DefP;
7    TB32Set AlwVTSet;
8    TB32Set FixVTSet;
9    TBool DscIntP, DscOrdP;
10    TInt MnIntDsc, MxIntDsc;
11    TStrV DscToNmV;
12    TStrIntH NmToDscH;
13    TFlt MnFlt, MxFlt;
14  public:
15    TTbVarType():
16      AlwVTSet(TB32Set().Fill()), FixVTSet(),
17      DscIntP(false), DscOrdP(false),
18      MnIntDsc(0), MxIntDsc(0),
19      DscToNmV(), NmToDscH(10),
20      MnFlt(TFlt::Mx), MxFlt(TFlt::Mn){}
21    TTbVarType(TSIn& SIn):
22      DefP(SIn),
23      AlwVTSet(SIn), FixVTSet(SIn),
24      DscIntP(SIn), DscOrdP(SIn),
25      MnIntDsc(SIn), MxIntDsc(SIn),
26      DscToNmV(SIn), NmToDscH(SIn),
27      MnFlt(SIn), MxFlt(SIn){
28      Assert(DefP);}
29    static PTbVarType Load(TSIn& SIn){return new TTbVarType(SIn);}
30    void Save(TSOut& SOut){
31      Assert(DefP); DefP.Save(SOut),
32      FixVTSet.Save(SOut); AlwVTSet.Save(SOut);
33      DscIntP.Save(SOut); DscOrdP.Save(SOut);
34      MnIntDsc.Save(SOut); MxIntDsc.Save(SOut);
35      DscToNmV.Save(SOut); NmToDscH.Save(SOut);
36      MnFlt.Save(SOut); MxFlt.Save(SOut);}
37    void Def(){Assert(!DefP); DefP=true;}
38    bool IsDef() const {return DefP;}
39    TTbVarType& operator=(const TTbVarType& TbVarType){
40      Assert(!DefP); DefP=TbVarType.DefP;
41      FixVTSet=TbVarType.FixVTSet; AlwVTSet=TbVarType.AlwVTSet;
42      DscIntP=TbVarType.DscIntP; DscOrdP=TbVarType.DscOrdP;
43      MnIntDsc=TbVarType.MnIntDsc; MxIntDsc=TbVarType.MxIntDsc;
44      DscToNmV=TbVarType.DscToNmV; NmToDscH=TbVarType.NmToDscH;
45      MnFlt=TbVarType.MnFlt; MxFlt=TbVarType.MxFlt; return *this;}
46    bool operator==(const TTbVarType& TbVarType) const {
47      Assert(DefP);
48      if (this==&TbVarType){return true;}
49      return (DefP==TbVarType.DefP)&&
50       (AlwVTSet==TbVarType.AlwVTSet)&&(FixVTSet==TbVarType.FixVTSet)&&
51       (DscIntP==TbVarType.DscIntP)&&(DscOrdP==TbVarType.DscOrdP)&&
52       (MnIntDsc==TbVarType.MnIntDsc)&&(MxIntDsc==TbVarType.MxIntDsc)&&
53       (DscToNmV==TbVarType.DscToNmV)&&
54       (MnFlt==TbVarType.MnFlt)&&(MxFlt==TbVarType.MxFlt);}
55    TB32Set GetAlwVTSet() const {return AlwVTSet;}
56    void SetAlwVTSet(const TB32Set& _AlwVTSet){
57      Assert(!DefP); AlwVTSet=_AlwVTSet;}
58    TB32Set GetFixVTSet() const {return FixVTSet;}
59    void SetDscFix(const int& _MnIntDsc, const int& _MxIntDsc){
60      Assert(!DefP && !FixVTSet.In(tvtDsc) && (_MnIntDsc<=_MxIntDsc));
61      FixVTSet.Incl(tvtDsc);
62      DscIntP=true; DscOrdP=true; MnIntDsc=_MnIntDsc; MxIntDsc=_MxIntDsc;}
63    void SetDscFix(bool _DscOrd=false){
64      Assert(!DefP && !FixVTSet.In(tvtDsc) && (DscToNmV.Len()==0));
65      FixVTSet.Incl(tvtDsc);
66      DscIntP=false; DscOrdP=_DscOrd; MnIntDsc=0; MxIntDsc=0;}
67    int AddDscNm(const TStr& Str){
68      Assert(!DefP && FixVTSet.In(tvtDsc) && !DscIntP);
69      Assert(NmToDscH.GetKeyId(Str)==-1);
70      return NmToDscH.AddDat(Str, TInt(DscToNmV.Add(Str)));}
71    void SetFltFix(const double& _MnFlt, const double& _MxFlt){
72      Assert(!DefP && !FixVTSet.In(tvtFlt) && (_MnFlt<=_MxFlt));
73      FixVTSet.Incl(tvtFlt);
74      MnFlt=_MnFlt; MxFlt=_MxFlt;}
75    bool IsDsc() const {Assert(DefP);
76      return AlwVTSet.In(tvtDsc) && (FixVTSet.In(tvtDsc) || DscToNmV.Len()>0);}
77    bool IsDscInt() const {Assert(IsDsc()); return DscIntP;}
78    bool IsDscSym() const {Assert(IsDsc()); return !DscIntP;}
79    bool IsDscOrd() const {Assert(IsDsc()); return DscOrdP;}
80    int GetDscs() const {Assert(IsDsc());
81      if (DscIntP){return MxIntDsc-MnIntDsc+1;} else {return DscToNmV.Len();}}
82    int GetMnIntDsc() const {Assert(IsDscInt()); return MnIntDsc;}
83    int GetMxIntDsc() const {Assert(IsDscInt()); return MxIntDsc;}
84    TStr GetDscStr(const int& Dsc) const {return DscToNmV[Dsc];}
85    void GetDscStrV(TStrV& DscStrV) const {
86      Assert(IsDscSym()); int Dscs=GetDscs(); DscStrV.Gen(Dscs, 0);
87      for (int Dsc=0; Dsc<Dscs; Dsc++){DscStrV.Add(GetDscStr(Dsc));}}
88    bool IsFlt() const {Assert(DefP);
89      return AlwVTSet.In(tvtFlt) && (FixVTSet.In(tvtFlt) || (MnFlt<=MxFlt));}
90    double GetFltRange() const {Assert(IsFlt()); return MxFlt-MnFlt;}
91    double GetMnFlt() const {Assert(IsFlt()); return MnFlt;}
92    double GetMxFlt() const {Assert(IsFlt()); return MxFlt;}
93    TStr GetStr() const;
94    bool IsValOk(const TTbVal& Val);
95    TTbVal GetDscVal(const TStr& Str);
96    TTbVal GetDscVal(const int& Dsc);
97    TTbVal GetIntDscVal(const int& Int);
98    TTbVal GetFltVal(const double& Flt);
99    TTbVal GetVal(const TTbVal& Val);
100    double GetNrmFlt(const TTbVal& Val);
101    TStr GetValStr(const TTbVal& Val);
102    static PTbVarType GetDscBoolVarType();
103    static PTbVarType GetDscIntVarType(
104     const int& MnIntDsc, const int& MxIntDsc);
105    static PTbVarType GetDscNmVVarType(
106     const TStrV& NmV, const bool& DscOrdP=false);
107    static PTbVarType GetFltVarType(
108     const double& MnFlt=TFlt::Mn, const double& MxFlt=TFlt::Mx);
109    static TTbSufixVarCat GetSufixVarCat(const TStr& VarNm);
110    static bool IsSuffixVarNm(const PTb& Tb);
111  };
112  ClassTPV(TTbVar, PTbVar, TTbVarV)
113  private:
114    UndefCopy(TTbVar);
115  public:
116    TTbVar(){}
117    virtual ~TTbVar(){}
118    TTbVar(TSIn&){}
119    static PTbVar Load(TSIn&){Fail; return NULL;}
120    virtual void Save(TSOut&){}
121    TTbVar& operator=(const TTbVar&){return *this;}
122    bool operator==(const TTbVar& TbVar) const {
123      return (GetNm()==TbVar.GetNm())&&(GetVarType()==TbVar.GetVarType())&&
124       (GetActVTSet()==TbVar.GetActVTSet());}
125    virtual TStr GetNm() const=0;
126    virtual PTbVarType GetVarType() const=0;
127    virtual TB32Set GetActVTSet() const=0;
128    virtual void DefVarType()=0;
129    virtual TTbVal GetDscVal(const TStr& Str)=0;
130    virtual TTbVal GetDscVal(const int& Dsc)=0;
131    virtual TTbVal GetFltVal(const double& Flt)=0;
132    virtual TTbVal GetVal(const TTbVal& Val)=0;
133  };
134  ClassTPV(TTbTup, PTbTup, TTbTupV)
135  private:
136    UndefCopy(TTbTup);
137  public:
138    TTbTup(){}
139    TTbTup(TSIn&){}
140    virtual ~TTbTup(){}
141    static PTbTup Load(TSIn&){Fail; return NULL;}
142    virtual void Save(TSOut&){}
143    TTbTup& operator=(const TTbTup&){return *this;}
144    virtual void PutNm(const TStr& _Nm)=0;
145    virtual TStr GetNm()=0;
146    virtual void PutVal(int VarN, const TTbVal& Val)=0;
147    virtual TTbVal GetVal(int VarN)=0;
148  };
149  ClassTPV(TTb, PTb, TTbV)
150  private:
151    TStr Nm;
152    UndefCopyAssign(TTb);
153  public:
154    TTb(): Nm("Untitled-Table"){}
155    virtual ~TTb(){}
156    TTb(TSIn& SIn): Nm(SIn){}
157    static PTb Load(TSIn& SIn);
158    virtual void Save(TSOut& SOut){GetTypeNm(*this).Save(SOut); Nm.Save(SOut);}
159    void PutNm(const TStr& _Nm){Nm=_Nm;}
160    TStr GetNm(){return Nm;}
161    void AddTb(const PTb& Tb);
162    PTb GetSubTb(const TIntV& TupNV, const TIntV& VarNV, const PTb& Tb);
163    virtual int AddVar(const PTbVar& TbVar)=0;
164    virtual void DefVarTypes()=0;
165    virtual int GetVars()=0;
166    virtual PTbVar GetVar(const int& VarN)=0;
167    virtual int GetVarN(const TStr& Nm)=0;
168    virtual int AddTup(const TStr& Nm)=0;
169    int AddTup(){return AddTup(TStr());}
170    virtual int GetTups()=0;
171    virtual TStr GetTupNm(const int& TupN)=0;
172    virtual int GetTupN(const TStr& Nm)=0;
173    virtual void PutDsc(const int& TupN, const int& VarN, const TStr& Str)=0;
174    virtual void PutDsc(const int& TupN, const int& VarN, const int& Dsc)=0;
175    virtual void PutFlt(const int& TupN, const int& VarN, const double& Flt)=0;
176    virtual void PutVal(const int& TupN, const int& VarN, const TTbVal& Val)=0;
177    virtual TTbVal GetVal(const int& TupN, const int& VarN)=0;
178    virtual TStr GetValStr(const int& TupN, const int& VarN)=0;
179    static PTb LoadFile(const TStr& FNm, const TStr& FType, const TStr& MemRep);
180    static PTb LoadTxtSpc(const TStr& FNm, const PTb& Tb);
181    static PTb LoadTxtTab(const TStr& FNm, const PTb& Tb);
182    static PTb LoadTxtCsv(const TStr& FNm, const PTb& Tb);
183    void SaveTxt(const TStr& FNm, const bool& SaveTupNm=true);
184    void SaveAssis(const TStr& FNm);
185  };
186  class TGTbVar: public TTbVar{
187  private:
188    TStr Nm;
189    PTbVarType VarType;
190    TB32Set ActVTSet;
191  public:
<span onclick='openModal()' class='match'>192    TGTbVar(): TTbVar(), Nm(), VarType(), ActVTSet(){}
193    TGTbVar(const TStr& _Nm, const PTbVarType& _VarType):
194      TTbVar(), Nm(_Nm), VarType(_VarType), ActVTSet(){}
195    TGTbVar(TSIn& SIn):
196      TTbVar(SIn), Nm(SIn), VarType(SIn), ActVTSet(SIn){}
197    void Save(TSOut& SOut){
198      TTbVar::Save(SOut); Nm.Save(SOut); VarType.Save(SOut); ActVTSet.Save(SOut);}
</span>199    TGTbVar& operator=(const TGTbVar& GTbVar){
200      TTbVar::operator=(GTbVar);
201      Nm=GTbVar.Nm; ActVTSet=GTbVar.ActVTSet; VarType=GTbVar.VarType;
202      return *this;}
203    TStr GetNm() const {return Nm;}
204    PTbVarType GetVarType() const {return VarType;}
205    TB32Set GetActVTSet() const {return ActVTSet;}
206    void DefVarType(){VarType->Def();}
207    TTbVal GetDscVal(const TStr& Str){
208      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Str);}
209    TTbVal GetDscVal(const int& Dsc){
210      ActVTSet.Incl(tvtDsc); return VarType->GetDscVal(Dsc);}
211    TTbVal GetFltVal(const double& Flt){
212      ActVTSet.Incl(tvtFlt); return VarType->GetFltVal(Flt);}
213    TTbVal GetVal(const TTbVal& Val){
214      ActVTSet.Incl(Val.GetValTag()); return VarType->GetVal(Val);}
215  };
216  class TGTbTup: public TTbTup{
217    TStr Nm;
218    TTbValV ValV;
219  public:
220    TGTbTup(): TTbTup(), Nm(), ValV(){}
221    TGTbTup(const TStr& _Nm, const int& Vars): TTbTup(), Nm(_Nm), ValV(Vars){}
222    TGTbTup(TSIn& SIn): TTbTup(SIn), Nm(SIn), ValV(SIn){}
223    virtual ~TGTbTup(){}
224    void Save(TSOut& SOut){TTbTup::Save(SOut); Nm.Save(SOut); ValV.Save(SOut);}
225    TGTbTup& operator=(const TGTbTup& GTbTup){
226      TTbTup::operator=(GTbTup); Nm=GTbTup.Nm; ValV=GTbTup.ValV; return *this;}
227    void PutNm(const TStr& _Nm){Nm=_Nm;}
228    TStr GetNm(){return Nm;}
229    void PutVal(int VarN, const TTbVal& Val){ValV[VarN]=Val;}
230    TTbVal GetVal(int VarN){return ValV[VarN];}
231  };
232  class TGTb: public TTb{
233  private:
234    TTbVarV VarV;
235    TStrIntH VarNmToNH;
236    TTbTupV TupV;
237    TStrIntH TupNmToNH;
238  public:
239    TGTb(const int& MxVars=0, const int& MxTups=0):
240      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
241      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
242    TGTb(TSIn& SIn):
243      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
244      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
245    void Save(TSOut& SOut){
246      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
247      TupV.Save(SOut); SOut.SaveCs();}
248    int AddVar(const PTbVar& TbVar);
249    void DefVarTypes();
250    int GetVars(){return VarV.Len();}
251    PTbVar GetVar(const int& VarN){return VarV[VarN];}
252    int GetVarN(const TStr& Nm){return VarNmToNH.GetDat(Nm);}
253    int AddTup(const TStr& Nm);
254    int GetTups(){return TupV.Len();}
255    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
256    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
257    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
258      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
259    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
260      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
261    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
262      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
263    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
264      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
265    TTbVal GetVal(const int& TupN, const int& VarN){
266      return TupV[TupN]->GetVal(VarN);}
267    TStr GetValStr(const int& TupN, const int& VarN);
268  };
269  class TBTb: public TTb{
270  private:
271    TTbVarV VarV;
272    TStrIntH VarNmToNH;
273    TTbTupV TupV;
274    TStrIntH TupNmToNH;
275  public:
276    TBTb(const int& MxVars=0, const int& MxTups=0):
277      TTb(), VarV(MxVars, 0), VarNmToNH(MxVars>0?MxVars:100),
278      TupV(MxTups, 0), TupNmToNH(MxTups>0?MxTups:100){}
279    TBTb(TSIn& SIn):
280      TTb(SIn), VarV(SIn), VarNmToNH(SIn),
281      TupV(SIn), TupNmToNH(SIn){SIn.LoadCs();}
282    void Save(TSOut& SOut){
283      TTb::Save(SOut); VarV.Save(SOut); VarNmToNH.Save(SOut);
284      TupV.Save(SOut); SOut.SaveCs();}
285    int AddVar(const PTbVar& TbVar);
286    void DefVarTypes(){}
287    int GetVars(){return VarNmToNH.Len();}
288    PTbVar GetVar(const int& &bsol;*VarN*/){Fail; return NULL;}
289    int GetVarN(const TStr& Nm){return VarNmToNH.GetKeyId(Nm);}
290    int AddTup(const TStr& Nm);
291    int GetTups(){return TupV.Len();}
292    TStr GetTupNm(const int& TupN){return TupV[TupN]->GetNm();}
293    int GetTupN(const TStr& Nm){return TupNmToNH.GetDat(Nm);}
294    void PutDsc(const int& TupN, const int& VarN, const TStr& Str){
295      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Str));}
296    void PutDsc(const int& TupN, const int& VarN, const int& Dsc){
297      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetDscVal(Dsc));}
298    void PutFlt(const int& TupN, const int& VarN, const double& Flt){
299      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetFltVal(Flt));}
300    void PutVal(const int& TupN, const int& VarN, const TTbVal& Val){
301      TupV[TupN]->PutVal(VarN, VarV[VarN]->GetVal(Val));}
302    TTbVal GetVal(const int& TupN, const int& VarN){
303      return TupV[TupN]->GetVal(VarN);}
304    TStr GetValStr(const int& TupN, const int& VarN);
305  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-telemetry_41.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tb.h</div>
                <div class="column column_space"><pre><code>35  		bool enable_ongoing_broadcasts{ true };
36  		config (nano::node_config const & config, nano::node_flags const & flags) :
37  			enable_ongoing_requests{ !flags.disable_ongoing_telemetry_requests },
38  			enable_ongoing_broadcasts{ !flags.disable_providing_telemetry_metrics }
39  		{
40  		}
</pre></code></div>
                <div class="column column_space"><pre><code>192    TGTbVar(): TTbVar(), Nm(), VarType(), ActVTSet(){}
193    TGTbVar(const TStr& _Nm, const PTbVarType& _VarType):
194      TTbVar(), Nm(_Nm), VarType(_VarType), ActVTSet(){}
195    TGTbVar(TSIn& SIn):
196      TTbVar(SIn), Nm(SIn), VarType(SIn), ActVTSet(SIn){}
197    void Save(TSOut& SOut){
198      TTbVar::Save(SOut); Nm.Save(SOut); VarType.Save(SOut); ActVTSet.Save(SOut);}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    