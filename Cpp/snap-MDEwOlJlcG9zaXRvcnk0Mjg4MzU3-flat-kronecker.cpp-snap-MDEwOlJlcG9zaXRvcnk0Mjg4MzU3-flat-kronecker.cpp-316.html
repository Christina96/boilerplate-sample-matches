
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;kronecker.h&quot;
3  const double TKronMtx::NInf = -DBL_MAX;
4  TRnd TKronMtx::Rnd = TRnd(0);
5  TKronMtx::TKronMtx(const TFltV&amp; SeedMatrix) : SeedMtx(SeedMatrix) {
6    MtxDim = (int) sqrt((double)SeedMatrix.Len());
7    IAssert(MtxDim*MtxDim == SeedMtx.Len());
8  }
9  void TKronMtx::SaveTxt(const TStr&amp; OutFNm) const {
10    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
11    for (int i = 0; i &lt; GetDim(); i++) {
12      for (int j = 0; j &lt; GetDim(); j++) {
13        if (j &gt; 0) fprintf(F, &quot;\t&quot;);
14        fprintf(F, &quot;%f&quot;, At(i,j)); }
15      fprintf(F, &quot;\n&quot;);
16    }
17    fclose(F);
18  }
19  TKronMtx&amp; TKronMtx::operator = (const TKronMtx&amp; Kronecker) {
20    if (this != &amp;Kronecker){
21      MtxDim=Kronecker.MtxDim;
22      SeedMtx=Kronecker.SeedMtx;
23    }
24    return *this;
25  }
26  bool TKronMtx::IsProbMtx() const {
27    for (int i = 0; i &lt; Len(); i++) {
28      if (At(i) &lt; 0.0 || At(i) &gt; 1.0) return false;
29    }
30    return true;
31  }
32  void TKronMtx::SetRndMtx(const int&amp; PrmMtxDim, const double&amp; MinProb) {
33    MtxDim = PrmMtxDim;
34    SeedMtx.Gen(MtxDim*MtxDim);
35    for (int p = 0; p &lt; SeedMtx.Len(); p++) {
36      do {
37        SeedMtx[p] = TKronMtx::Rnd.GetUniDev();
38      } while (SeedMtx[p] &lt; MinProb);
39    }
40  }
41  void TKronMtx::SetEpsMtx(const double&amp; Eps1, const double&amp; Eps0, const int&amp; Eps1Val, const int&amp; Eps0Val) {
42    for (int i = 0; i &lt; Len(); i++) {
43      double&amp; Val = At(i);
44      if (Val == Eps1Val) Val = double(Eps1);
45      else if (Val == Eps0Val) Val = double(Eps0);
46    }
47  }
48  void TKronMtx::SetForEdges(const int&amp; Nodes, const int&amp; Edges) {
49    const int KronIter = GetKronIter(Nodes);
50    const double EZero = pow((double) Edges, 1.0/double(KronIter));
51    const double Factor = EZero / GetMtxSum();
52    for (int i = 0; i &lt; Len(); i++) {
53      At(i) *= Factor;
54      if (At(i) &gt; 1) { At(i) = 1; }
55    }
56  }
57  void TKronMtx::AddRndNoise(const double&amp; SDev) {
58    Dump(&quot;before&quot;);
59    double NewVal;
60    int c =0;
61    for (int i = 0; i &lt; Len(); i++) {
62      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) &lt; 0.01 || NewVal&gt;0.99) &amp;&amp; c &lt;1000; c++) { }
63      if (c &lt; 999) { At(i) = NewVal; } else { printf(&quot;XXXXX\n&quot;); }
64    }
65    Dump(&quot;after&quot;);
66  }
67  TStr TKronMtx::GetMtxStr() const {
68    TChA ChA(&quot;[&quot;);
69    for (int i = 0; i &lt; Len(); i++) {
70      ChA += TStr::Fmt(&quot;%g&quot;, At(i));
71      if ((i+1)%GetDim()==0 &amp;&amp; (i+1&lt;Len())) { ChA += &quot;; &quot;; }
72      else if (i+1&lt;Len()) { ChA += &quot;, &quot;; }
73    }
74    ChA += &quot;]&quot;;
75    return TStr(ChA);
76  }
77  void TKronMtx::ToOneMinusMtx() {
78    for (int i = 0; i &lt; Len(); i++) {
79      IAssert(At(i) &gt;= 0.0 &amp;&amp; At(i) &lt;= 1.0);
80      At(i) = 1.0 - At(i);
81    }
82  }
83  void TKronMtx::GetLLMtx(TKronMtx&amp; LLMtx) {
84    LLMtx.GenMtx(MtxDim);
85    for (int i = 0; i &lt; Len(); i++) {
86      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
87      else { LLMtx.At(i) = NInf; }
88    }
89  }
90  void TKronMtx::GetProbMtx(TKronMtx&amp; ProbMtx) {
91    ProbMtx.GenMtx(MtxDim);
92    for (int i = 0; i &lt; Len(); i++) {
93      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
94      else { ProbMtx.At(i) = 0.0; }
95    }
96  }
97  void TKronMtx::Swap(TKronMtx&amp; KronMtx) {
98    ::Swap(MtxDim, KronMtx.MtxDim);
99    SeedMtx.Swap(KronMtx.SeedMtx);
100  }
101  int TKronMtx::GetNodes(const int&amp; NIter) const {
102    return (int) pow(double(GetDim()), double(NIter));
103  }
104  int TKronMtx::GetEdges(const int&amp; NIter) const {
105    return (int) pow(double(GetMtxSum()), double(NIter));
106  }
107  int TKronMtx::GetKronIter(const int&amp; Nodes) const {
108    return (int) ceil(log(double(Nodes)) / log(double(GetDim()))); 
109  }
110  int TKronMtx::GetNZeroK(const PNGraph&amp; Graph) const {
111   return GetNodes(GetKronIter(Graph-&gt;GetNodes()));
112  }
113  double TKronMtx::GetEZero(const int&amp; Edges, const int&amp; KronIters) const {
114    return pow((double) Edges, 1.0/double(KronIters));
115  }
116  double TKronMtx::GetMtxSum() const {
117    double Sum = 0;
118    for (int i = 0; i &lt; Len(); i++) {
119      Sum += At(i); }
120    return Sum;
121  }
122  double TKronMtx::GetRowSum(const int&amp; RowId) const {
123    double Sum = 0;
124    for (int c = 0; c &lt; GetDim(); c++) {
125      Sum += At(RowId, c); }
126    return Sum;
127  }
128  double TKronMtx::GetColSum(const int&amp; ColId) const {
129    double Sum = 0;
130    for (int r = 0; r &lt; GetDim(); r++) {
131      Sum += At(r, ColId); }
132    return Sum;
133  }
134  double TKronMtx::GetEdgeProb(int NId1, int NId2, const int&amp; NKronIters) const {
135    double Prob = 1.0;
136    for (int level = 0; level &lt; NKronIters; level++) {
137      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
138      if (Prob == 0.0) { return 0.0; }
139      NId1 /= MtxDim;  NId2 /= MtxDim;
140    }
141    return Prob;
142  }
143  double TKronMtx::GetNoEdgeProb(int NId1, int NId2, const int&amp; NKronIters) const {
144    return 1.0 - GetEdgeProb(NId1, NId2, NKronIters);
145  }
146  double TKronMtx::GetEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
147    double LL = 0.0;
148    for (int level = 0; level &lt; NKronIters; level++) {
149      const double&amp; LLVal = At(NId1 % MtxDim, NId2 % MtxDim);
150      if (LLVal == NInf) return NInf;
151      LL += LLVal;
152      NId1 /= MtxDim;  NId2 /= MtxDim;
153    }
154    return LL;
155  }
156  double TKronMtx::GetNoEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
157    return log(1.0 - exp(GetEdgeLL(NId1, NId2, NKronIters)));
158  }
159  double TKronMtx::GetApxNoEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
160    const double EdgeLL = GetEdgeLL(NId1, NId2, NKronIters);
161    return -exp(EdgeLL) - 0.5*exp(2*EdgeLL);
162  }
163  bool TKronMtx::IsEdgePlace(int NId1, int NId2, const int&amp; NKronIters, const double&amp; ProbTresh) const {
164    double Prob = 1.0;
165    for (int level = 0; level &lt; NKronIters; level++) {
166      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
167      if (ProbTresh &gt; Prob) { return false; }
168      NId1 /= MtxDim;  NId2 /= MtxDim;
169    }
170    return true;
171  }
172  double TKronMtx::GetEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
173    const int ThetaX = ParamId % GetDim();
174    const int ThetaY = ParamId / GetDim();
175    int ThetaCnt = 0;
176    for (int level = 0; level &lt; NKronIters; level++) {
177      if ((NId1 % MtxDim) == ThetaX &amp;&amp; (NId2 % MtxDim) == ThetaY) {
178        ThetaCnt++; }
179      NId1 /= MtxDim;  NId2 /= MtxDim;
180    }
181    return double(ThetaCnt) / exp(At(ParamId));
182  }
183  double TKronMtx::GetNoEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
184    const int&amp; ThetaX = ParamId % GetDim();
185    const int&amp; ThetaY = ParamId / GetDim();
186    int ThetaCnt = 0;
187    double DLL = 0, LL = 0;
188    for (int level = 0; level &lt; NKronIters; level++) {
189      const int X = NId1 % MtxDim;
190      const int Y = NId2 % MtxDim;
191      const double LVal = At(X, Y);
192      if (X == ThetaX &amp;&amp; Y == ThetaY) {
193        if (ThetaCnt != 0) { DLL += LVal; }
194        ThetaCnt++;
195      } else { DLL += LVal; }
196      LL += LVal;
197      NId1 /= MtxDim;  NId2 /= MtxDim;
198    }
199    return -ThetaCnt*exp(DLL) / (1.0 - exp(LL));
200  }
201  double TKronMtx::GetApxNoEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
202    const int&amp; ThetaX = ParamId % GetDim();
203    const int&amp; ThetaY = ParamId / GetDim();
204    int ThetaCnt = 0;
205    double DLL = 0;
206    for (int level = 0; level &lt; NKronIters; level++) {
207      const int X = NId1 % MtxDim;
208      const int Y = NId2 % MtxDim;
209      const double LVal = At(X, Y); IAssert(LVal &gt; NInf);
210      if (X == ThetaX &amp;&amp; Y == ThetaY) {
211        if (ThetaCnt != 0) { DLL += LVal; }
212        ThetaCnt++;
213      } else { DLL += LVal; }
214      NId1 /= MtxDim;  NId2 /= MtxDim;
215    }
216    return -ThetaCnt*exp(DLL) - ThetaCnt*exp(At(ThetaX, ThetaY)+2*DLL);
217  }
218  uint TKronMtx::GetNodeSig(const double&amp; OneProb) {
219    uint Sig = 0;
220    for (int i = 0; i &lt; (int)(8*sizeof(uint)); i++) {
221      if (TKronMtx::Rnd.GetUniDev() &lt; OneProb) {
222        Sig |= (1u&lt;&lt;i); }
223    }
224    return Sig;
225  }
226  double TKronMtx::GetEdgeProb(const uint&amp; NId1Sig, const uint&amp; NId2Sig, const int&amp; NIter) const {
227    Assert(GetDim() == 2);
228    double Prob = 1.0;
229    for (int i = 0; i &lt; NIter; i++) {
230      const uint Mask = (1u&lt;&lt;i);
231      const uint Bit1 = NId1Sig &amp; Mask;
232      const uint Bit2 = NId2Sig &amp; Mask;
233      Prob *= At(int(Bit1!=0), int(Bit2!=0));
234    }
235    return Prob;
236  }
237  PNGraph TKronMtx::GenThreshGraph(const double&amp; Thresh) const {
238    PNGraph Graph = TNGraph::New();
239    for (int i = 0; i &lt; GetDim(); i++) {
240      Graph-&gt;AddNode(i); }
241    for (int r = 0; r &lt; GetDim(); r++) {
242      for (int c = 0; c &lt; GetDim(); c++) {
243        if (At(r, c) &gt;= Thresh) { Graph-&gt;AddEdge(r, c); }
244      }
245    }
246    return Graph;
247  }
248  PNGraph TKronMtx::GenRndGraph(const double&amp; RndFact) const {
249    PNGraph Graph = TNGraph::New();
250    for (int i = 0; i &lt; GetDim(); i++) {
251      Graph-&gt;AddNode(i); }
252    for (int r = 0; r &lt; GetDim(); r++) {
253      for (int c = 0; c &lt; GetDim(); c++) {
254        if (RndFact * At(r, c) &gt;= TKronMtx::Rnd.GetUniDev()) { Graph-&gt;AddEdge(r, c); }
255      }
256    }
257    return Graph;
258  }
259  int TKronMtx::GetKronIter(const int&amp; GNodes, const int&amp; SeedMtxSz) {
260    return (int) ceil(log(double(GNodes)) / log(double(SeedMtxSz)));
261  }
262  PNGraph TKronMtx::GenKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir, const int&amp; Seed) {
263    const TKronMtx&amp; SeedGraph = SeedMtx;
264    const int NNodes = SeedGraph.GetNodes(NIter);
265    printf(&quot;  Kronecker: %d nodes, %s...\n&quot;, NNodes, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
266    PNGraph Graph = TNGraph::New(NNodes, -1);
267    TExeTm ExeTm;
268    TRnd Rnd(Seed);
269    int edges = 0;
270    for (int node1 = 0; node1 &lt; NNodes; node1++) {
271      Graph-&gt;AddNode(node1); }
272    if (IsDir) {
273      for (int node1 = 0; node1 &lt; NNodes; node1++) {
274        for (int node2 = 0; node2 &lt; NNodes; node2++) {
275          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
276            Graph-&gt;AddEdge(node1, node2);
277            edges++;
278          }
279        }
280        if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
281      }
282    } else {
283      for (int node1 = 0; node1 &lt; NNodes; node1++) {
284        for (int node2 = node1; node2 &lt; NNodes; node2++) {
285          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
286            Graph-&gt;AddEdge(node1, node2);
287            Graph-&gt;AddEdge(node2, node1);
288            edges++;
289          }
290        }
291        if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
292      }
293    }
294    printf(&quot;\r             %d edges [%s]\n&quot;, Graph-&gt;GetEdges(), ExeTm.GetTmStr());
295    return Graph;
296  }
297  PNGraph TKronMtx::GenFastKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir, const int&amp; Seed) {
298    const TKronMtx&amp; SeedGraph = SeedMtx;
299    const int MtxDim = SeedGraph.GetDim();
300    const double MtxSum = SeedGraph.GetMtxSum();
301    const int NNodes = SeedGraph.GetNodes(NIter);
302    const int NEdges = SeedGraph.GetEdges(NIter);
303    printf(&quot;  FastKronecker: %d nodes, %d edges, %s...\n&quot;, NNodes, NEdges, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
304    PNGraph Graph = TNGraph::New(NNodes, -1);
305    TRnd Rnd(Seed);
306    TExeTm ExeTm;
307    TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
308    double CumProb = 0.0;
309    for (int r = 0; r &lt; MtxDim; r++) {
310      for (int c = 0; c &lt; MtxDim; c++) {
311        const double Prob = SeedGraph.At(r, c);
312        if (Prob &gt; 0.0) {
313          CumProb += Prob;
314          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
315        }
316      }
317    }
318    for (int i = 0; i &lt; NNodes; i++) {
319      Graph-&gt;AddNode(i); }
320    int Rng, Row, Col, Collision=0, n = 0;
321    for (int edges = 0; edges &lt; NEdges; ) {
322      Rng=NNodes;  Row=0;  Col=0;
323      for (int iter = 0; iter &lt; NIter; iter++) {
324        const double&amp; Prob = Rnd.GetUniDev();
325        n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
326        const int MtxRow = ProbToRCPosV[n].Val2;
327        const int MtxCol = ProbToRCPosV[n].Val3;
328        Rng /= MtxDim;
329        Row += MtxRow * Rng;
330        Col += MtxCol * Rng;
331      }
332      if (! Graph-&gt;IsEdge(Row, Col)) { 
333        Graph-&gt;AddEdge(Row, Col);  edges++;
334        if (! IsDir) {
335          if (Row != Col) Graph-&gt;AddEdge(Col, Row);
336          edges++;
337        }
338      } else { Collision++; }
339    }
340    printf(&quot;             collisions: %d (%.4f)\n&quot;, Collision, Collision/(double)Graph-&gt;GetEdges());
341    return Graph;
342  }
343  PNGraph TKronMtx::GenFastKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const int&amp; Edges, const bool&amp; IsDir, const int&amp; Seed) {
344    const TKronMtx&amp; SeedGraph = SeedMtx;
345    const int MtxDim = SeedGraph.GetDim();
346    const double MtxSum = SeedGraph.GetMtxSum();
347    const int NNodes = SeedGraph.GetNodes(NIter);
348    const int NEdges = Edges;
349    printf(&quot;  RMat Kronecker: %d nodes, %d edges, %s...\n&quot;, NNodes, NEdges, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
350    PNGraph Graph = TNGraph::New(NNodes, -1);
351    TRnd Rnd(Seed);
352    TExeTm ExeTm;
353    TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
354    double CumProb = 0.0;
355    for (int r = 0; r &lt; MtxDim; r++) {
356      for (int c = 0; c &lt; MtxDim; c++) {
357        const double Prob = SeedGraph.At(r, c);
358        if (Prob &gt; 0.0) {
359          CumProb += Prob;
360          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
361        }
362      }
363    }
364    for (int i = 0; i &lt; NNodes; i++) {
365      Graph-&gt;AddNode(i); }
366    int Rng, Row, Col, Collision=0, n = 0;
367    for (int edges = 0; edges &lt; NEdges; ) {
368      Rng=NNodes;  Row=0;  Col=0;
369      for (int iter = 0; iter &lt; NIter; iter++) {
370        const double&amp; Prob = Rnd.GetUniDev();
371        n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
372        const int MtxRow = ProbToRCPosV[n].Val2;
373        const int MtxCol = ProbToRCPosV[n].Val3;
374        Rng /= MtxDim;
375        Row += MtxRow * Rng;
376        Col += MtxCol * Rng;
377      }
378      if (! Graph-&gt;IsEdge(Row, Col)) { 
379        Graph-&gt;AddEdge(Row, Col);  edges++;
380        if (! IsDir) {
381          if (Row != Col) Graph-&gt;AddEdge(Col, Row);
382          edges++;
383        }
384      } else { Collision++; }
385    }
386    printf(&quot;             collisions: %d (%.4f)\n&quot;, Collision, Collision/(double)Graph-&gt;GetEdges());
387    return Graph;
388  }
389  PNGraph TKronMtx::GenDetKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir) {
390    const TKronMtx&amp; SeedGraph = SeedMtx;
391    const int NNodes = SeedGraph.GetNodes(NIter);
392    printf(&quot;  Deterministic Kronecker: %d nodes, %s...\n&quot;, NNodes, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
393    PNGraph Graph = TNGraph::New(NNodes, -1);
394    TExeTm ExeTm;
395    int edges = 0;
396    for (int node1 = 0; node1 &lt; NNodes; node1++) { Graph-&gt;AddNode(node1); }
397    for (int node1 = 0; node1 &lt; NNodes; node1++) {
398      for (int node2 = 0; node2 &lt; NNodes; node2++) {
399        if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
400          Graph-&gt;AddEdge(node1, node2);
401          edges++;
402        }
403      }
404      if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
405    }
406    return Graph;
407  }
408  void TKronMtx::PlotCmpGraphs(const TKronMtx&amp; SeedMtx, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
409    const int KronIters = SeedMtx.GetKronIter(Graph-&gt;GetNodes());
410    PNGraph KronG, WccG;
411    const bool FastGen = true;
412    if (FastGen) { KronG = TKronMtx::GenFastKronecker(SeedMtx, KronIters, true, 0); }
413    else { KronG = TKronMtx::GenKronecker(SeedMtx, KronIters, true, 0); }
414    TSnap::DelZeroDegNodes(KronG);
415    WccG = TSnap::GetMxWcc(KronG);
416    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
417    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdScc | gsdClustCf | gsdSngVec | gsdSngVal);
418    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
419    GS.Add(KronG, TSecTm(2), TStr::Fmt(&quot;KRONECKER  K(%d, %d)&quot;, KronG-&gt;GetNodes(), KronG-&gt;GetEdges()));
420    GS.Add(WccG, TSecTm(3),  TStr::Fmt(&quot;KRONECKER  wccK(%d, %d)&quot;, WccG-&gt;GetNodes(), WccG-&gt;GetEdges()));
421    const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
422    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
423    GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
424    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
425    GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
426    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
427    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
428    GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
429    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
430    GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
431    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
432    GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
433    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
434    GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
435    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
436    GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
437  }
438  void TKronMtx::PlotCmpGraphs(const TKronMtx&amp; SeedMtx1, const TKronMtx&amp; SeedMtx2, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
439    const int KronIters1 = SeedMtx1.GetKronIter(Graph-&gt;GetNodes());
440    const int KronIters2 = SeedMtx2.GetKronIter(Graph-&gt;GetNodes());
441    PNGraph KronG1, KronG2;
442    const bool FastGen = true;
443    if (FastGen) {
444      KronG1 = TKronMtx::GenFastKronecker(SeedMtx1, KronIters1, true, 0);
445      KronG2 = TKronMtx::GenFastKronecker(SeedMtx2, KronIters2, false, 0); } 
446    else {
447      KronG1 = TKronMtx::GenKronecker(SeedMtx1, KronIters1, true, 0);
448      KronG2 = TKronMtx::GenKronecker(SeedMtx2, KronIters2, true, 0);  }
449    TSnap::DelZeroDegNodes(KronG1);
450    TSnap::DelZeroDegNodes(KronG2);
451    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
452    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
453    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
454    GS.Add(KronG1, TSecTm(2), TStr::Fmt(&quot;KRONECKER1  K(%d, %d) %s&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtx1.GetMtxStr().CStr()));
455    GS.Add(KronG2, TSecTm(3),  TStr::Fmt(&quot;KRONECKER2  K(%d, %d) %s&quot;, KronG2-&gt;GetNodes(), KronG2-&gt;GetEdges(), SeedMtx2.GetMtxStr().CStr()));
456    const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
457    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
458    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
459    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
460    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
461    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
462    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
463    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
464    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
465    GS.ImposeDistr(gsdTriadPart, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
466    GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
467    GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
468    GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
469    GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
470    GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
471    GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
472    GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
473    GS.ImposeDistr(gsdTriadPart, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
474  }
475  void TKronMtx::PlotCmpGraphs(const TVec&lt;TKronMtx&gt;&amp; SeedMtxV, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
476    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
477    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal);
478    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
479    for (int m = 0; m &lt; SeedMtxV.Len(); m++) {
480      const int KronIters = SeedMtxV[m].GetKronIter(Graph-&gt;GetNodes());
481      PNGraph KronG1 = TKronMtx::GenFastKronecker(SeedMtxV[m], KronIters, true, 0);
482      printf(&quot;*** K(%d, %d) n0=%d\n&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtxV[m].GetDim());
483      TSnap::DelZeroDegNodes(KronG1);
484      printf(&quot; del zero deg K(%d, %d) n0=%d\n&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), m);
485      GS.Add(KronG1, TSecTm(m+2), TStr::Fmt(&quot;K(%d, %d) n0^k=%d n0=%d&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtxV[m].GetNZeroK(Graph), SeedMtxV[m].GetDim()));
486      const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
487      GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLines, Style);
488      GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
489      GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLines, Style);
490      GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
491      GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLines, Style);
492      GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLines, Style);
493      GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
494      GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLines, Style);
495      GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
496      GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLines, Style);
497      GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
498      GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLines, Style);
499      GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
500      GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLines, Style);
501      GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
502    }
503  }
504  void TKronMtx::KronMul(const TKronMtx&amp; Left, const TKronMtx&amp; Right, TKronMtx&amp; Result) {
505    const int LDim = Left.GetDim();
506    const int RDim = Right.GetDim();
507    Result.GenMtx(LDim * RDim);
508    for (int r1 = 0; r1 &lt; LDim; r1++) {
509      for (int c1 = 0; c1 &lt; LDim; c1++) {
510        const double&amp; Val = Left.At(r1, c1);
511        for (int r2 = 0; r2 &lt; RDim; r2++) {
512          for (int c2 = 0; c2 &lt; RDim; c2++) {
513            Result.At(r1*RDim+r2, c1*RDim+c2) = Val * Right.At(r2, c2);
514          }
515        }
516      }
517    }
518  }
519  void TKronMtx::KronSum(const TKronMtx&amp; Left, const TKronMtx&amp; Right, TKronMtx&amp; Result) {
520    const int LDim = Left.GetDim();
521    const int RDim = Right.GetDim();
522    Result.GenMtx(LDim * RDim);
523    for (int r1 = 0; r1 &lt; LDim; r1++) {
524      for (int c1 = 0; c1 &lt; LDim; c1++) {
525        const double&amp; Val = Left.At(r1, c1);
526        for (int r2 = 0; r2 &lt; RDim; r2++) {
527          for (int c2 = 0; c2 &lt; RDim; c2++) {
528            if (Val == NInf || Right.At(r2, c2) == NInf) {
529              Result.At(r1*RDim+r2, c1*RDim+c2) = NInf; }
530            else {
531              Result.At(r1*RDim+r2, c1*RDim+c2) = Val + Right.At(r2, c2); }
532          }
533        }
534      }
535    }
536  }
537  void TKronMtx::KronPwr(const TKronMtx&amp; KronMtx, const int&amp; NIter, TKronMtx&amp; OutMtx) {
538    OutMtx = KronMtx;
539    TKronMtx NewOutMtx;
540    for (int iter = 0; iter &lt; NIter; iter++) {
541      KronMul(OutMtx, KronMtx, NewOutMtx);
542      NewOutMtx.Swap(OutMtx);
543    }
544  }
545  void TKronMtx::Dump(const TStr&amp; MtxNm, const bool&amp; Sort) const {
546    if (! MtxNm.Empty()) printf(&quot;%s\n&quot;, MtxNm.CStr());
547    double Sum=0.0;
548    TFltV ValV = SeedMtx;
549    if (Sort) { ValV.Sort(false); }
550    for (int i = 0; i &lt; ValV.Len(); i++) {
551      printf(&quot;  %10.4g&quot;, ValV[i]());
552      Sum += ValV[i];
553      if ((i+1) % GetDim() == 0) { printf(&quot;\n&quot;); }
554    }
555    printf(&quot; (sum:%.4f)\n&quot;, Sum);
556  }
557  double TKronMtx::GetAvgAbsErr(const TKronMtx&amp; Kron1, const TKronMtx&amp; Kron2) {
558    TFltV P1 = Kron1.GetMtx();
559    TFltV P2 = Kron2.GetMtx();
560    IAssert(P1.Len() == P2.Len());
561    P1.Sort();  P2.Sort();
562    double delta = 0.0;
563    for (int i = 0; i &lt; P1.Len(); i++) {
564      delta += fabs(P1[i] - P2[i]);
565    }
566    return delta/P1.Len();
567  }
568  double TKronMtx::GetAvgFroErr(const TKronMtx&amp; Kron1, const TKronMtx&amp; Kron2) {
569    TFltV P1 = Kron1.GetMtx();
570    TFltV P2 = Kron2.GetMtx();
571    IAssert(P1.Len() == P2.Len());
572    P1.Sort();  P2.Sort();
573    double delta = 0.0;
574    for (int i = 0; i &lt; P1.Len(); i++) {
575      delta += pow(P1[i] - P2[i], 2);
576    }
577    return sqrt(delta/P1.Len());
578  }
579  TKronMtx TKronMtx::GetMtx(TStr MatlabMtxStr) {
580    TStrV RowStrV, ColStrV;
581    MatlabMtxStr.ChangeChAll(&#x27;,&#x27;, &#x27; &#x27;);
582    MatlabMtxStr.SplitOnAllCh(&#x27;;&#x27;, RowStrV);  IAssert(! RowStrV.Empty());
583    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
584    const int Rows = RowStrV.Len();
585    const int Cols = ColStrV.Len();
586    IAssert(Rows == Cols);
587    TKronMtx Mtx(Rows);
588    for (int r = 0; r &lt; Rows; r++) {
589      RowStrV[r].SplitOnWs(ColStrV);
590      IAssert(ColStrV.Len() == Cols);
591      for (int c = 0; c &lt; Cols; c++) {
592        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
593    }
594    return Mtx;
595  }
596  TKronMtx TKronMtx::GetRndMtx(const int&amp; Dim, const double&amp; MinProb) {
597    TKronMtx Mtx;
598    Mtx.SetRndMtx(Dim, MinProb);
599    return Mtx;
600  }
601  TKronMtx TKronMtx::GetInitMtx(const int&amp; Dim, const int&amp; Nodes, const int&amp; Edges) {
602    const double MxParam = 0.8+TKronMtx::Rnd.GetUniDev()/5.0;
603    const double MnParam = 0.2-TKronMtx::Rnd.GetUniDev()/5.0;
604    const double Step = (MxParam-MnParam) / (Dim*Dim-1);
605    TFltV ParamV(Dim*Dim);
606    if (Dim == 1) { ParamV.PutAll(0.5); } 
607    else {
608      for (int p = 0; p &lt; ParamV.Len(); p++) {
609        ParamV[p] = MxParam - p*Step; }
610    }
611    TKronMtx Mtx(ParamV);
612    Mtx.SetForEdges(Nodes, Edges);
613    return Mtx;
614  }
615  TKronMtx TKronMtx::GetInitMtx(const TStr&amp; MtxStr, const int&amp; Dim, const int&amp; Nodes, const int&amp; Edges) {
616    TKronMtx Mtx(Dim);
617    if (TCh::IsNum(MtxStr[0])) { Mtx = TKronMtx::GetMtx(MtxStr); }
618    else if (MtxStr[0] == &#x27;r&#x27;) { Mtx = TKronMtx::GetRndMtx(Dim, 0.1); }
619    else if (MtxStr[0] == &#x27;a&#x27;) {
620      const double Prob = TKronMtx::Rnd.GetUniDev();
621      if (Prob &lt; 0.4) {
622        Mtx = TKronMtx::GetInitMtx(Dim, Nodes, Edges); }
623      else { 
624        const double Max = 0.9+TKronMtx::Rnd.GetUniDev()/10.0;
625        const double Min = 0.1-TKronMtx::Rnd.GetUniDev()/10.0;
626        const double Med = (Max-Min)/2.0;
627        Mtx.At(0,0)      = Max;       Mtx.At(0,Dim-1) = Med;
628        Mtx.At(Dim-1, 0) = Med;  Mtx.At(Dim-1, Dim-1) = Min;
629        for (int i = 1; i &lt; Dim-1; i++) {
630          Mtx.At(i,i) = Max - double(i)*(Max-Min)/double(Dim-1);
631          Mtx.At(i, 0) = Mtx.At(0, i) = Max - double(i)*(Max-Med)/double(Dim-1);
632          Mtx.At(i, Dim-1) = Mtx.At(Dim-1, i) = Med - double(i)*(Med-Min)/double(Dim-1);
633        }
634        for (int i = 1; i &lt; Dim-1; i++) {
635          for (int j = 1; j &lt; Dim-1; j++) {
636            if (i &gt;= j) { continue; }
637            Mtx.At(i,j) = Mtx.At(j,i) = Mtx.At(i,i) - (j-i)*(Mtx.At(i,i)-Mtx.At(i,Dim-1))/(Dim-i-1);
638          }
639        }
640        Mtx.AddRndNoise(0.1);
641      }
642    } else { FailR(&quot;Wrong mtx: matlab str, or random (r), or all (a)&quot;); }
643    Mtx.SetForEdges(Nodes, Edges);
644    return Mtx;
645  }
646  TKronMtx TKronMtx::GetMtxFromNm(const TStr&amp; MtxNm) {
647    if (MtxNm == &quot;3chain&quot;) return TKronMtx::GetMtx(&quot;1 1 0; 1 1 1; 0 1 1&quot;);
648    else if (MtxNm == &quot;4star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1; 1 1 0 0 ; 1 0 1 0; 1 0 0 1&quot;);
649    else if (MtxNm == &quot;4chain&quot;) return TKronMtx::GetMtx(&quot;1 1 0 0; 1 1 1 0 ; 0 1 1 1; 0 0 1 1&quot;);
650    else if (MtxNm == &quot;4square&quot;) return TKronMtx::GetMtx(&quot;1 1 0 1; 1 1 1 0 ; 0 1 1 1; 1 0 1 1&quot;);
651    else if (MtxNm == &quot;5star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 0; 1 0 0 0 1&quot;);
652    else if (MtxNm == &quot;6star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1 1; 1 1 0 0 0 0; 1 0 1 0 0 0; 1 0 0 1 0 0; 1 0 0 0 1 0; 1 0 0 0 0 1&quot;);
653    else if (MtxNm == &quot;7star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1 1 1; 1 1 0 0 0 0 0; 1 0 1 0 0 0 0; 1 0 0 1 0 0 0; 1 0 0 0 1 0 0; 1 0 0 0 0 1 0; 1 0 0 0 0 0 1&quot;);
654    else if (MtxNm == &quot;5burst&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 0; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 1; 0 0 0 1 1&quot;);
655    else if (MtxNm == &quot;7burst&quot;) return TKronMtx::GetMtx(&quot;1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 1; 0 0 0 0 1 1 0; 0 0 0 0 1 0 1&quot;);
656    else if (MtxNm == &quot;7cross&quot;) return TKronMtx::GetMtx(&quot;1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 0; 0 0 0 0 1 1 1; 0 0 0 0 0 1 1&quot;);
657    FailR(TStr::Fmt(&quot;Unknow matrix: &#x27;%s&#x27;&quot;, MtxNm.CStr()).CStr());
658    return TKronMtx();
659  }
660  TKronMtx TKronMtx::LoadTxt(const TStr&amp; MtxFNm) {
661    PSs Ss = TSs::LoadTxt(ssfTabSep, MtxFNm);
662    IAssertR(Ss-&gt;GetXLen() == Ss-&gt;GetYLen(), &quot;Not a square matrix&quot;);
663    IAssert(Ss-&gt;GetYLen() == Ss-&gt;GetXLen());
664    TKronMtx Mtx(Ss-&gt;GetYLen());
665    for (int r = 0; r &lt; Ss-&gt;GetYLen(); r++) {
666      for (int c = 0; c &lt; Ss-&gt;GetXLen(); c++) {
667        Mtx.At(r, c) = (double) Ss-&gt;At(c, r).GetFlt(); }
668    }
669    return Mtx;
670  }
671  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TFltV&amp; ParamV, const double&amp; PermPSwapNd): PermSwapNodeProb(PermPSwapNd) {
672    InitLL(GraphPt, TKronMtx(ParamV));
673  }
674  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const double&amp; PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
675    InitLL(GraphPt, ParamMtx);
676  }
677  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const TIntV&amp; NodeIdPermV, const double&amp; PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
678    InitLL(GraphPt, ParamMtx);
679    NodePerm = NodeIdPermV;
680    SetIPerm(NodePerm);
681  }
682  PKroneckerLL TKroneckerLL::New(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const double&amp; PermPSwapNd) {
683    return new TKroneckerLL(GraphPt, ParamMtx, PermPSwapNd);
684  }
685  PKroneckerLL TKroneckerLL::New(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const TIntV&amp; NodeIdPermV, const double&amp; PermPSwapNd) {
686    return new TKroneckerLL(GraphPt, ParamMtx, NodeIdPermV, PermPSwapNd);
687  }
688  void TKroneckerLL::SetPerm(const char&amp; PermId) {
689    if (PermId == &#x27;o&#x27;) { SetOrderPerm(); }
690    else if (PermId == &#x27;d&#x27;) { SetDegPerm(); }
691    else if (PermId == &#x27;r&#x27;) { SetRndPerm(); }
692    else if (PermId == &#x27;b&#x27;) { SetBestDegPerm(); }
693    else FailR(&quot;Unknown permutation type (o,d,r)&quot;);
694  }
695  void TKroneckerLL::SetOrderPerm() {
696    NodePerm.Gen(Nodes, 0);
697    for (int i = 0; i &lt; Graph-&gt;GetNodes(); i++) {
698      NodePerm.Add(i); }
699    SetIPerm(NodePerm);
700  }
701  void TKroneckerLL::SetRndPerm() {
702    NodePerm.Gen(Nodes, 0);
703    for (int i = 0; i &lt; Graph-&gt;GetNodes(); i++) {
704      NodePerm.Add(i); }
705    NodePerm.Shuffle(TKronMtx::Rnd);
706    SetIPerm(NodePerm);
707  }
708  void TKroneckerLL::SetDegPerm() {
709    TIntPrV DegNIdV;
710    for (TNGraph::TNodeI NI = Graph-&gt;BegNI(); NI &lt; Graph-&gt;EndNI(); NI++) {
711      DegNIdV.Add(TIntPr(NI.GetDeg(), NI.GetId()));
712    }
713    DegNIdV.Sort(false);
714    NodePerm.Gen(DegNIdV.Len(), 0);
715    for (int i = 0; i &lt; DegNIdV.Len(); i++) {
716      NodePerm.Add(DegNIdV[i].Val2);
717    }
718    SetIPerm(NodePerm);
719  }
720  void TKroneckerLL::SetBestDegPerm() {
721    NodePerm.Gen(Nodes);
722    const int NZero = ProbMtx.GetDim();
723    TFltIntPrV DegV(Nodes), CDegV(Nodes);
724    TFltV Row(NZero);
725    TFltV Col(NZero);
726    for(int i = 0; i &lt; NZero; i++) {
727  	  for(int j = 0; j &lt; NZero; j++) {
728  		  Row[i] += ProbMtx.At(i, j);
729  		  Col[i] += ProbMtx.At(j, i);
730  	  }
731    }
732    for(int i = 0; i &lt; Nodes; i++) {
733  	  TNGraph::TNodeI NodeI = Graph-&gt;GetNI(i);
734  	  int NId = i;
735  	  double RowP = 1.0, ColP = 1.0;
736  	  for(int j = 0; j &lt; KronIters; j++) {
737  		  int Bit = NId % NZero;
738  		  RowP *= Row[Bit];		ColP *= Col[Bit];
739  		  NId /= NZero;
740  	  }
741  	  CDegV[i] = TFltIntPr(RowP + ColP, i);
742  	  DegV[i] = TFltIntPr(NodeI.GetDeg(), i);
743    }
744    DegV.Sort(false);		CDegV.Sort(false);
745    for(int i = 0; i &lt; Nodes; i++) {
746  	  NodePerm[DegV[i].Val2] = CDegV[i].Val2;
747    }
748    SetIPerm(NodePerm);
749  }
750  void TKroneckerLL::SetIPerm(const TIntV&amp; Perm) {
751  	InvertPerm.Gen(Perm.Len());
752  	for (int i = 0; i &lt; Perm.Len(); i++) {
753  		InvertPerm[Perm[i]] = i;
754  	}
755  }
756  void TKroneckerLL::SetGraph(const PNGraph&amp; GraphPt) {
757    Graph = GraphPt;
758    bool NodesOk = true;
759    for (int nid = 0; nid &lt; Graph-&gt;GetNodes(); nid++) {
760      if (! Graph-&gt;IsNode(nid)) { NodesOk=false; break; } }
761    if (! NodesOk) {
762      TIntV NIdV;  GraphPt-&gt;GetNIdV(NIdV);
763      Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
764      for (int nid = 0; nid &lt; Graph-&gt;GetNodes(); nid++) {
765        IAssert(Graph-&gt;IsNode(nid)); }
766    }
767    Nodes = Graph-&gt;GetNodes();
768    IAssert(LLMtx.GetDim() &gt; 1 &amp;&amp; LLMtx.Len() == ProbMtx.Len());
769    KronIters = (int) ceil(log(double(Nodes)) / log(double(ProbMtx.GetDim())));
770      GEdgeV.Gen(Graph-&gt;GetEdges(), 0);
771      for (TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
772        if (EI.GetSrcNId() != EI.GetDstNId()) {
773          GEdgeV.Add(TIntTr(EI.GetSrcNId(), EI.GetDstNId(), -1));
774        }
775      }
776    RealNodes = Nodes;
777    RealEdges = Graph-&gt;GetEdges();
778    LEdgeV = TIntTrV();
779    LSelfEdge = 0;
780  }
781  void TKroneckerLL::AppendIsoNodes() {
782    Nodes = (int) pow((double)ProbMtx.GetDim(), KronIters);
783    for (int nid = Graph-&gt;GetNodes(); nid &lt; Nodes; nid++) {
784  	  Graph-&gt;AddNode(nid);
785    }
786  }
787  void TKroneckerLL::RestoreGraph(const bool RestoreNodes) {
788  	int NId1, NId2;
789  	for (int e = 0; e &lt; LEdgeV.Len(); e++) {
790      	NId1 = LEdgeV[e].Val1;  NId2 = LEdgeV[e].Val2;
791  		Graph-&gt;DelEdge(NId1, NId2);
792  	}
793  	if(LEdgeV.Len() - LSelfEdge)
794  		GEdgeV.Del(GEdgeV.Len() - LEdgeV.Len() + LSelfEdge, GEdgeV.Len() - 1);
795  	LEdgeV.Clr();
796  	LSelfEdge = 0;
797  	if(RestoreNodes) {
798  		for(int i = Graph-&gt;GetNodes()-1; i &gt;= RealNodes; i--) {
799  			Graph-&gt;DelNode(i);
800  		}
801  	}
802  }
803  double TKroneckerLL::GetFullGraphLL() const {
804    double ElemCnt = 1;
805    const double dim = LLMtx.GetDim();
806    for (int i = 1; i &lt; KronIters; i++) {
807      ElemCnt = dim*dim*ElemCnt + TMath::Power(dim, 2*i);
808    }
809    return ElemCnt * LLMtx.GetMtxSum();
810  }
811  double TKroneckerLL::GetFullRowLL(int RowId) const {
812    double RowLL = 0.0;
813    const int MtxDim = LLMtx.GetDim();
814    for (int level = 0; level &lt; KronIters; level++) {
815      RowLL += LLMtx.GetRowSum(RowId % MtxDim);
816      RowId /= MtxDim;
817    }
818    return RowLL;
819  }
820  double TKroneckerLL::GetFullColLL(int ColId) const {
821    double ColLL = 0.0;
822    const int MtxDim = LLMtx.GetDim();
823    for (int level = 0; level &lt; KronIters; level++) {
824      ColLL += LLMtx.GetColSum(ColId % MtxDim);
825      ColId /= MtxDim;
826    }
827    return ColLL;
828  }
829  double TKroneckerLL::GetEmptyGraphLL() const {
830    double LL = 0;
831    for (int NId1 = 0; NId1 &lt; LLMtx.GetNodes(KronIters); NId1++) {
832      for (int NId2 = 0; NId2 &lt; LLMtx.GetNodes(KronIters); NId2++) {
833        LL = LL + LLMtx.GetNoEdgeLL(NId1, NId2, KronIters);
834      }
835    }
836    return LL;
837  }
838  double TKroneckerLL::GetApxEmptyGraphLL() const {
839    double Sum=0.0, SumSq=0.0;
840    for (int i = 0; i &lt; ProbMtx.Len(); i++) {
841      Sum += ProbMtx.At(i);
842      SumSq += TMath::Sqr(ProbMtx.At(i));
843    }
844    return -pow(Sum, KronIters) - 0.5*pow(SumSq, KronIters);
845  }
846  void TKroneckerLL::InitLL(const TFltV&amp; ParamV) {
847    InitLL(TKronMtx(ParamV));
848  }
849  void TKroneckerLL::InitLL(const TKronMtx&amp; ParamMtx) {
850    IAssert(ParamMtx.IsProbMtx());
851    ProbMtx = ParamMtx;
852    ProbMtx.GetLLMtx(LLMtx);
853    LogLike = TKronMtx::NInf;
854    if (GradV.Len() != ProbMtx.Len()) {
855      GradV.Gen(ProbMtx.Len()); }
856    GradV.PutAll(0.0);
857  }
858  void TKroneckerLL::InitLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx) {
859    IAssert(ParamMtx.IsProbMtx());
860    ProbMtx = ParamMtx;
861    ProbMtx.GetLLMtx(LLMtx);
862    SetGraph(GraphPt);
863    LogLike = TKronMtx::NInf;
864    if (GradV.Len() != ProbMtx.Len()) {
865      GradV.Gen(ProbMtx.Len()); }
866    GradV.PutAll(0.0);
867  }
868  double TKroneckerLL::CalcGraphLL() {
869    LogLike = GetEmptyGraphLL(); 
870    for (int nid = 0; nid &lt; Nodes; nid++) {
871      const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
872      const int SrcNId = NodePerm[nid];
873      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
874        const int DstNId = NodePerm[Node.GetOutNId(e)];
875        LogLike = LogLike - LLMtx.GetNoEdgeLL(SrcNId, DstNId, KronIters)
876          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
877      }
878    }
879    return LogLike;
880  }
881  double TKroneckerLL::CalcApxGraphLL() {
882    LogLike = GetApxEmptyGraphLL(); 
883    for (int nid = 0; nid &lt; Nodes; nid++) {
884      const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
885      const int SrcNId = NodePerm[nid];
886      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
887        const int DstNId = NodePerm[Node.GetOutNId(e)];
888        LogLike = LogLike - LLMtx.GetApxNoEdgeLL(SrcNId, DstNId, KronIters)
889          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
890      }
891    }
892    return LogLike;
893  }
894  double TKroneckerLL::NodeLLDelta(const int&amp; NId) const {
895    if (! Graph-&gt;IsNode(NId)) { return 0.0; } 
896    double Delta = 0.0;
897    const TNGraph::TNodeI Node = Graph-&gt;GetNI(NId);
898    const int SrcRow = NodePerm[NId];
899    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
900      const int DstCol = NodePerm[Node.GetOutNId(e)];
901      Delta += - LLMtx.GetApxNoEdgeLL(SrcRow, DstCol, KronIters)
902        + LLMtx.GetEdgeLL(SrcRow, DstCol, KronIters);
903    }
904    const int SrcCol = NodePerm[NId];
905    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
906      const int DstRow = NodePerm[Node.GetInNId(e)];
907      Delta += - LLMtx.GetApxNoEdgeLL(DstRow, SrcCol, KronIters)
908        + LLMtx.GetEdgeLL(DstRow, SrcCol, KronIters);
909    }
910    if (Graph-&gt;IsEdge(NId, NId)) {
911      Delta += + LLMtx.GetApxNoEdgeLL(SrcRow, SrcCol, KronIters)
912        - LLMtx.GetEdgeLL(SrcRow, SrcCol, KronIters);
913      IAssert(SrcRow == SrcCol);
914    }
915    return Delta;
916  }
917  double TKroneckerLL::SwapNodesLL(const int&amp; NId1, const int&amp; NId2) {
918    LogLike = LogLike - NodeLLDelta(NId1) - NodeLLDelta(NId2);
919    const int PrevId1 = NodePerm[NId1], PrevId2 = NodePerm[NId2];
920    if (Graph-&gt;IsEdge(NId1, NId2)) {
921      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId1, PrevId2, KronIters)
922        + LLMtx.GetEdgeLL(PrevId1, PrevId2, KronIters); }
923    if (Graph-&gt;IsEdge(NId2, NId1)) {
924      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId2, PrevId1, KronIters)
925        + LLMtx.GetEdgeLL(PrevId2, PrevId1, KronIters); }
926    NodePerm.Swap(NId1, NId2);
927    InvertPerm.Swap(NodePerm[NId1], NodePerm[NId2]);
928    LogLike = LogLike + NodeLLDelta(NId1) + NodeLLDelta(NId2);
929    const int NewId1 = NodePerm[NId1], NewId2 = NodePerm[NId2];
930    if (Graph-&gt;IsEdge(NId1, NId2)) {
931      LogLike += + LLMtx.GetApxNoEdgeLL(NewId1, NewId2, KronIters)
932        - LLMtx.GetEdgeLL(NewId1, NewId2, KronIters); }
933    if (Graph-&gt;IsEdge(NId2, NId1)) {
934      LogLike += + LLMtx.GetApxNoEdgeLL(NewId2, NewId1, KronIters)
935        - LLMtx.GetEdgeLL(NewId2, NewId1, KronIters); }
936    return LogLike;
937  }
938  bool TKroneckerLL::SampleNextPerm(int&amp; NId1, int&amp; NId2) {
939    if (TKronMtx::Rnd.GetUniDev() &lt; PermSwapNodeProb) {
940      NId1 = TKronMtx::Rnd.GetUniDevInt(Nodes);
941      NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes);
942      while (NId2 == NId1) { NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes); }
943    } else {
944      const int e = TKronMtx::Rnd.GetUniDevInt(GEdgeV.Len());
945      NId1 = GEdgeV[e].Val1;  NId2 = GEdgeV[e].Val2;
946    }
947    const double U = TKronMtx::Rnd.GetUniDev();
948    const double OldLL = LogLike;
949    const double NewLL = SwapNodesLL(NId1, NId2);
950    const double LogU = log(U);
951    if (LogU &gt; NewLL - OldLL) { 
952      LogLike = OldLL;
953      NodePerm.Swap(NId2, NId1); 
954  	InvertPerm.Swap(NodePerm[NId2], NodePerm[NId1]); 
955      return false;
956    }
957    return true; 
958  }
959  double TKroneckerLL::GetEmptyGraphDLL(const int&amp; ParamId) const {
960    double DLL = 0.0;
961    for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
962      for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
963        DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
964      }
965    }
966    return DLL;
967  }
968  double TKroneckerLL::GetApxEmptyGraphDLL(const int&amp; ParamId) const {
969    double Sum=0.0, SumSq=0.0;
970    for (int i = 0; i &lt; ProbMtx.Len(); i++) {
971      Sum += ProbMtx.At(i);
972      SumSq += TMath::Sqr(ProbMtx.At(i));
973    }
974    return -KronIters*pow(Sum, KronIters-1) - KronIters*pow(SumSq, KronIters-1)*ProbMtx.At(ParamId);
975  }
976  const TFltV&amp; TKroneckerLL::CalcGraphDLL() {
977    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
978      double DLL = 0.0;
979      for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
980        for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
981          if (Graph-&gt;IsEdge(NId1, NId2)) {
982            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
983          } else {
984            DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
985          }
986        }
987      }
988      GradV[ParamId] = DLL;
989    }
990    return GradV;
991  }
992  const TFltV&amp; TKroneckerLL::CalcFullApxGraphDLL() {
993    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
994      double DLL = 0.0;
995      for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
996        for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
997          if (Graph-&gt;IsEdge(NId1, NId2)) {
998            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
999          } else {
1000            DLL += LLMtx.GetApxNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
1001          }
1002        }
1003      }
1004      GradV[ParamId] = DLL;
1005    }
1006    return GradV;
1007  }
1008  const TFltV&amp; TKroneckerLL::CalcApxGraphDLL() {
1009    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
1010      double DLL = GetApxEmptyGraphDLL(ParamId);
1011      for (int nid = 0; nid &lt; Nodes; nid++) {
1012        const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
1013        const int SrcNId = NodePerm[nid];
1014        for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
1015          const int DstNId = NodePerm[Node.GetOutNId(e)];
1016          DLL = DLL - LLMtx.GetApxNoEdgeDLL(ParamId, SrcNId, DstNId, KronIters)
1017            + LLMtx.GetEdgeDLL(ParamId, SrcNId, DstNId, KronIters);
1018        }
1019      }
1020      GradV[ParamId] = DLL;
1021    }
1022    return GradV;
1023  }
1024  double TKroneckerLL::NodeDLLDelta(const int ParamId, const int&amp; NId) const {
1025    if (! Graph-&gt;IsNode(NId)) { return 0.0; } 
1026    double Delta = 0.0;
1027    const TNGraph::TNodeI Node = Graph-&gt;GetNI(NId);
1028    const int SrcRow = NodePerm[NId];
1029    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
1030      const int DstCol = NodePerm[Node.GetOutNId(e)];
1031      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, DstCol, KronIters)
1032        + LLMtx.GetEdgeDLL(ParamId, SrcRow, DstCol, KronIters);
1033    }
1034    const int SrcCol = NodePerm[NId];
1035    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
1036      const int DstRow = NodePerm[Node.GetInNId(e)];
1037      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, DstRow, SrcCol, KronIters)
1038        + LLMtx.GetEdgeDLL(ParamId, DstRow, SrcCol, KronIters);
1039    }
1040    if (Graph-&gt;IsEdge(NId, NId)) {
1041      Delta += + LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, SrcCol, KronIters)
1042        - LLMtx.GetEdgeDLL(ParamId, SrcRow, SrcCol, KronIters);
1043      IAssert(SrcRow == SrcCol);
1044    }
1045    return Delta;
1046  }
1047  void TKroneckerLL::UpdateGraphDLL(const int&amp; SwapNId1, const int&amp; SwapNId2) {
1048    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
1049      NodePerm.Swap(SwapNId1, SwapNId2);
1050      TFlt&amp; DLL = GradV[ParamId];
1051      DLL = DLL - NodeDLLDelta(ParamId, SwapNId1) - NodeDLLDelta(ParamId, SwapNId2);
1052      const int PrevId1 = NodePerm[SwapNId1], PrevId2 = NodePerm[SwapNId2];
1053      if (Graph-&gt;IsEdge(SwapNId1, SwapNId2)) {
1054        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId1, PrevId2, KronIters)
1055          + LLMtx.GetEdgeDLL(ParamId, PrevId1, PrevId2, KronIters); }
1056      if (Graph-&gt;IsEdge(SwapNId2, SwapNId1)) {
1057        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId2, PrevId1, KronIters)
1058          + LLMtx.GetEdgeDLL(ParamId, PrevId2, PrevId1, KronIters); }
1059      NodePerm.Swap(SwapNId1, SwapNId2);
1060      DLL = DLL + NodeDLLDelta(ParamId, SwapNId1) + NodeDLLDelta(ParamId, SwapNId2);
1061      const int NewId1 = NodePerm[SwapNId1], NewId2 = NodePerm[SwapNId2];
1062      if (Graph-&gt;IsEdge(SwapNId1, SwapNId2)) {
1063        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId1, NewId2, KronIters)
1064          - LLMtx.GetEdgeDLL(ParamId, NewId1, NewId2, KronIters); }
1065      if (Graph-&gt;IsEdge(SwapNId2, SwapNId1)) {
1066        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId2, NewId1, KronIters)
1067          - LLMtx.GetEdgeDLL(ParamId, NewId2, NewId1, KronIters); }
1068    }
1069  }
1070  void TKroneckerLL::SampleGradient(const int&amp; WarmUp, const int&amp; NSamples, double&amp; AvgLL, TFltV&amp; AvgGradV) {
1071    printf(&quot;SampleGradient: %s (%s warm-up):&quot;, TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1072    int NId1=0, NId2=0, NAccept=0;
1073    TExeTm ExeTm1;
1074    if (WarmUp &gt; 0) {
1075      CalcApxGraphLL();
1076      for (int s = 0; s &lt; WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1077      printf(&quot;  warm-up:%s,&quot;, ExeTm1.GetTmStr());  ExeTm1.Tick();
1078    }
1079    CalcApxGraphLL(); 
1080    CalcApxGraphDLL();
1081    AvgLL = 0;
1082    AvgGradV.Gen(LLMtx.Len());  AvgGradV.PutAll(0.0);
1083    printf(&quot;  sampl&quot;);
1084    for (int s = 0; s &lt; NSamples; s++) {
1085      if (SampleNextPerm(NId1, NId2)) { 
1086        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1087      for (int m = 0; m &lt; LLMtx.Len(); m++) { AvgGradV[m] += GradV[m]; }
1088      AvgLL += GetLL();
1089    }
1090    printf(&quot;ing&quot;);
1091    AvgLL = AvgLL / double(NSamples);
1092    for (int m = 0; m &lt; LLMtx.Len(); m++) {
1093      AvgGradV[m] = AvgGradV[m] / double(NSamples); }
1094    printf(&quot;:%s (%.0f/s), accept %.1f%%\n&quot;, ExeTm1.GetTmStr(), double(NSamples)/ExeTm1.GetSecs(),
1095      double(100*NAccept)/double(NSamples));
1096  }
1097  double TKroneckerLL::GradDescent(const int&amp; NIter, const double&amp; LrnRate, double MnStep, double MxStep, const int&amp; WarmUp, const int&amp; NSamples) {
1098    printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1099    printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges());
1100    printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1101    TExeTm IterTm, TotalTm;
1102    double OldLL=-1e10, CurLL=0;
1103    const double EZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1104    TFltV CurGradV, LearnRateV(GetParams()), LastStep(GetParams());
1105    LearnRateV.PutAll(LrnRate);
1106    TKronMtx NewProbMtx = ProbMtx;
1107    if(DebugMode) {  
1108  	  LLV.Gen(NIter, 0);
<span onclick='openModal()' class='match'>1109  	  MtxV.Gen(NIter, 0);
1110    }
1111    for (int Iter = 0; Iter &lt; NIter; Iter++) {
1112      printf(&quot;%03d] &quot;, Iter);
</span>1113      SampleGradient(WarmUp, NSamples, CurLL, CurGradV);
1114      for (int p = 0; p &lt; GetParams(); p++) {
1115        LearnRateV[p] *= 0.95;
1116        if (Iter &lt; 1) {
1117          while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; }
1118          while (fabs(LearnRateV[p]*CurGradV[p]) &lt; 0.02) { LearnRateV[p] *= (1.0/0.95); } 
1119        } else {
1120          while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1121          while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1122          if (MxStep &gt; 3*MnStep) { MxStep *= 0.95; }
1123        }
1124        NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1125        if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1126        if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1127      }
1128      printf(&quot;  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1129        ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1130      printf(&quot;  currLL: %.4f, deltaLL: %.4f\n&quot;, CurLL, CurLL-OldLL); 
1131      for (int p = 0; p &lt; GetParams(); p++) {
1132        printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1133          ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1134      }
1135      if (Iter+1 &lt; NIter) { 
1136        ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx); }
1137      OldLL=CurLL;
1138      printf(&quot;\n&quot;);  fflush(stdout);
1139  	if(DebugMode) {  
1140  		LLV.Add(CurLL);
1141  		MtxV.Add(NewProbMtx);
1142  	}
1143    }
1144    printf(&quot;TotalExeTm: %s %g\n&quot;, TotalTm.GetStr(), TotalTm.GetSecs());
1145    ProbMtx.Dump(&quot;FITTED PARAMS&quot;, false);
1146    return CurLL;
1147  }
1148  double TKroneckerLL::GradDescent2(const int&amp; NIter, const double&amp; LrnRate, double MnStep, double MxStep, const int&amp; WarmUp, const int&amp; NSamples) {
1149    printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1150    printf(&quot;GradDescent2\n&quot;);
1151    printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges());
1152    printf(&quot;Skip moves that make likelihood smaller\n&quot;);
1153    printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1154    TExeTm IterTm, TotalTm;
1155    double CurLL=0, NewLL=0;
1156    const double EZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1157    TFltV CurGradV, NewGradV, LearnRateV(GetParams()), LastStep(GetParams());
1158    LearnRateV.PutAll(LrnRate);
1159    TKronMtx NewProbMtx=ProbMtx, CurProbMtx=ProbMtx;
1160    bool GoodMove = false;
1161    for (int Iter = 0; Iter &lt; NIter; Iter++) {
1162      printf(&quot;%03d] &quot;, Iter);
1163      if (! GoodMove) { SampleGradient(WarmUp, NSamples, CurLL, CurGradV); }
1164      CurProbMtx = ProbMtx;
1165      for (int p = 0; p &lt; GetParams(); p++) {
1166        while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1167        while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1168        NewProbMtx.At(p) = CurProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1169        if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1170        if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1171        LearnRateV[p] *= 0.95;
1172      }
1173      printf(&quot;  &quot;);
1174      ProbMtx=NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1175      SampleGradient(WarmUp, NSamples, NewLL, NewGradV);
1176      if (NewLL &gt; CurLL) { 
1177        printf(&quot;== Good move:\n&quot;);
1178        printf(&quot;  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1179          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1180        printf(&quot;  currLL: %.4f  deltaLL: %.4f\n&quot;, CurLL, NewLL-CurLL); 
1181        for (int p = 0; p &lt; GetParams(); p++) {
1182          printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1183            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1184        CurLL = NewLL;
1185        CurGradV = NewGradV;
1186        GoodMove = true;
1187      } else {
1188        printf(&quot;** BAD move:\n&quot;);
1189        printf(&quot;  *trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1190          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1191        printf(&quot;  *curLL:  %.4f  deltaLL: %.4f\n&quot;, CurLL, NewLL-CurLL); 
1192        for (int p = 0; p &lt; GetParams(); p++) {
1193          printf(&quot;   b%d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1194            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1195        ProbMtx = CurProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1196        GoodMove = false;
1197      }
1198      printf(&quot;\n&quot;);  fflush(stdout);
1199    }
1200    printf(&quot;TotalExeTm: %s %g\n&quot;, TotalTm.GetStr(), TotalTm.GetSecs());
1201    ProbMtx.Dump(&quot;FITTED PARAMS\n&quot;, false);
1202    return CurLL;
1203  }
1204  void TKroneckerLL::SetRandomEdges(const int&amp; NEdges, const bool isDir) {
1205  	int count = 0, added = 0, collision = 0;
1206  	const int MtxDim = ProbMtx.GetDim();
1207  	const double MtxSum = ProbMtx.GetMtxSum();
1208  	TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
1209  	double CumProb = 0.0;
1210  	for(int r = 0; r &lt; MtxDim; r++) {
1211  		for(int c = 0; c &lt; MtxDim; c++) {
1212  			const double Prob = ProbMtx.At(r, c);
1213  			if (Prob &gt; 0.0) {
1214  				CumProb += Prob;
1215  				ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
1216  			}
1217  		}
1218  	}
1219  	int Rng, Row, Col, n, NId1, NId2;
1220  	while(added &lt; NEdges) {
1221  		Rng = Nodes;	Row = 0;	Col = 0;
1222  		for (int iter = 0; iter &lt; KronIters; iter++) {
1223  			const double&amp; Prob = TKronMtx::Rnd.GetUniDev();
1224  			n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
1225  			const int MtxRow = ProbToRCPosV[n].Val2;
1226  			const int MtxCol = ProbToRCPosV[n].Val3;
1227  			Rng /= MtxDim;
1228  			Row += MtxRow * Rng;
1229  			Col += MtxCol * Rng;
1230  		}
1231  		count++;
1232  		NId1 = InvertPerm[Row];	NId2 = InvertPerm[Col];
1233  		if(EMType != kronEdgeMiss &amp;&amp; IsObsEdge(NId1, NId2)) {
1234  			continue;
1235  		}
1236  		if (! Graph-&gt;IsEdge(NId1, NId2)) {
1237  			Graph-&gt;AddEdge(NId1, NId2);
1238  			if(NId1 != NId2)	{ GEdgeV.Add(TIntTr(NId1, NId2, LEdgeV.Len())); }
1239  			else { LSelfEdge++; }
1240  			LEdgeV.Add(TIntTr(NId1, NId2, GEdgeV.Len()-1));
1241  			added++;
1242  			if (! isDir) {
1243  				if (NId1 != NId2) {
1244  				   Graph-&gt;AddEdge(NId2, NId1);
1245  				   GEdgeV.Add(TIntTr(NId2, NId1, LEdgeV.Len()));
1246  				   LEdgeV.Add(TIntTr(NId2, NId1, GEdgeV.Len()-1));
1247  				   added++;
1248  				}
1249  			}
1250  		} else { collision ++; }
1251  	}
1252  }
1253  void TKroneckerLL::MetroGibbsSampleSetup(const int&amp; WarmUp) {
1254  	double alpha = log(ProbMtx.GetMtxSum()) / log(double(ProbMtx.GetDim()));
1255  	int NId1 = 0, NId2 = 0;
1256  	int NMissing;
1257  	RestoreGraph(false);
1258  	if(EMType == kronEdgeMiss) {
1259  		CalcApxGraphLL();
1260  		for (int s = 0; s &lt; WarmUp; s++)	SampleNextPerm(NId1, NId2);
1261  	}
1262  	if(EMType == kronFutureLink) {
1263  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) - pow(double(RealNodes), alpha));
1264  	} else if(EMType == kronEdgeMiss) {
1265  		NMissing = MissEdges;
1266  	} else {
1267  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) * (1.0 - pow(double(RealNodes) / double(Nodes), 2)));
1268  	}
1269  	NMissing = (NMissing &lt; 1) ? 1 : NMissing;
1270  	SetRandomEdges(NMissing, true);
1271  	CalcApxGraphLL();
1272  	for (int s = 0; s &lt; WarmUp; s++)	SampleNextPerm(NId1, NId2);
1273  }
1274  void TKroneckerLL::MetroGibbsSampleNext(const int&amp; WarmUp, const bool DLLUpdate) {
1275  	int NId1 = 0, NId2 = 0, hit = 0, GId = 0;
1276  	TIntTr EdgeToRemove, NewEdge;
1277  	double RndAccept;
1278  	if(LEdgeV.Len()) {
1279  		for(int i = 0; i &lt; WarmUp; i++) {
1280  			hit = TKronMtx::Rnd.GetUniDevInt(LEdgeV.Len());
1281  			NId1 = LEdgeV[hit].Val1;	NId2 = LEdgeV[hit].Val2;
1282  			GId = LEdgeV[hit].Val3;
1283  			SetRandomEdges(1, true);
1284  			NewEdge = LEdgeV.Last();
1285  			RndAccept = (1.0 - exp(LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters))) / (1.0 - exp(LLMtx.GetEdgeLL(NId1, NId2, KronIters)));
1286  			RndAccept = (RndAccept &gt; 1.0) ? 1.0 : RndAccept;
1287  			if(TKronMtx::Rnd.GetUniDev() &gt; RndAccept) { 
1288  				Graph-&gt;DelEdge(NewEdge.Val1, NewEdge.Val2);
1289  				if(NewEdge.Val1 != NewEdge.Val2) {	GEdgeV.DelLast();	}
1290  				else {	LSelfEdge--;	}
1291  				LEdgeV.DelLast();
1292  			} else {	
1293  				Graph-&gt;DelEdge(NId1, NId2);
1294  				LEdgeV[hit] = LEdgeV.Last();
1295  				LEdgeV.DelLast();
1296  				if(NId1 == NId2) {
1297  					LSelfEdge--;
1298  					if(NewEdge.Val1 != NewEdge.Val2) {
1299  						GEdgeV[GEdgeV.Len()-1].Val3 = hit;
1300  					}
1301  				} else {
1302  					IAssertR(GEdgeV.Last().Val3 &gt;= 0, &quot;Invalid indexing&quot;);
1303  					GEdgeV[GId] = GEdgeV.Last();
1304  					if(NewEdge.Val1 != NewEdge.Val2) {
1305  						GEdgeV[GId].Val3 = hit;
1306  					}
1307  					LEdgeV[GEdgeV[GId].Val3].Val3 = GId;
1308  					GEdgeV.DelLast();
1309  				}
1310        			LogLike += LLMtx.GetApxNoEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1311        			LogLike += -LLMtx.GetApxNoEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters);
1312  				if(DLLUpdate) {
1313    					for (int p = 0; p &lt; LLMtx.Len(); p++) {
1314  						GradV[p] += LLMtx.GetApxNoEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1315  						GradV[p] += -LLMtx.GetApxNoEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters);
1316  					}
1317  				}
1318  			}
1319  		}
1320  	}
1321  	for (int s = 0; s &lt; WarmUp; s++) {
1322  		if(SampleNextPerm(NId1, NId2)) {
1323  			if(DLLUpdate)	UpdateGraphDLL(NId1, NId2);
1324  		}
1325  	}
1326  }
1327  void TKroneckerLL::RunEStep(const int&amp; GibbsWarmUp, const int&amp; WarmUp, const int&amp; NSamples, TFltV&amp; LLV, TVec&lt;TFltV&gt;&amp; DLLV) {
1328  	TExeTm ExeTm, TotalTm;
1329  	LLV.Gen(NSamples, 0);
1330  	DLLV.Gen(NSamples, 0);
1331  	ExeTm.Tick();
1332  	for(int i = 0; i &lt; 2; i++)	MetroGibbsSampleSetup(WarmUp);
1333  	printf(&quot;  Warm-Up [%u] : %s\n&quot;, WarmUp, ExeTm.GetTmStr());
1334  	CalcApxGraphLL();
1335  	for(int i = 0; i &lt; GibbsWarmUp; i++)	MetroGibbsSampleNext(10, false);
1336  	printf(&quot;  Gibbs Warm-Up [%u] : %s\n&quot;, GibbsWarmUp, ExeTm.GetTmStr());
1337  	ExeTm.Tick();
1338  	CalcApxGraphLL();
1339  	CalcApxGraphDLL();
1340  	for(int i = 0; i &lt; NSamples; i++) {
1341  		MetroGibbsSampleNext(50, false);
1342  		LLV.Add(LogLike);
1343  		DLLV.Add(GradV);
1344  		int OnePercent = (i+1) % (NSamples / 10);
1345  		if(OnePercent == 0) {
1346  			int TenPercent = ((i+1) / (NSamples / 10)) * 10;
1347  			printf(&quot;  %3u%% done : %s\n&quot;, TenPercent, ExeTm.GetTmStr());
1348  		}
1349  	}
1350  }
1351  double TKroneckerLL::RunMStep(const TFltV&amp; LLV, const TVec&lt;TFltV&gt;&amp; DLLV, const int&amp; GradIter, const double&amp; LrnRate, double MnStep, double MxStep) {
1352  	TExeTm IterTm, TotalTm;
1353  	double OldLL=LogLike, CurLL=0;
1354  	const double alpha = log(double(RealEdges)) / log(double(RealNodes));
1355  	const double EZero = pow(double(ProbMtx.GetDim()), alpha);
1356  	TFltV CurGradV(GetParams()), LearnRateV(GetParams()), LastStep(GetParams());
1357  	LearnRateV.PutAll(LrnRate);
1358  	TKronMtx NewProbMtx = ProbMtx;
1359  	const int NSamples = LLV.Len();
1360  	const int ReCalcLen = NSamples / 10;
1361  	for (int s = 0; s &lt; LLV.Len(); s++) {
1362  		CurLL += LLV[s];
1363  		for(int p = 0; p &lt; GetParams(); p++) { CurGradV[p] += DLLV[s][p]; }
1364  	}
1365  	CurLL /= NSamples;
1366  	for(int p = 0; p &lt; GetParams(); p++) { CurGradV[p] /= NSamples; }
1367  	double MaxLL = CurLL;
1368  	TKronMtx MaxProbMtx = ProbMtx;
1369  	TKronMtx OldProbMtx = ProbMtx;
1370  	for (int Iter = 0; Iter &lt; GradIter; Iter++) {
1371  		printf(&quot;    %03d] &quot;, Iter+1);
1372  		IterTm.Tick();
1373  		for (int p = 0; p &lt; GetParams(); p++) {
1374  			if (Iter &lt; 1) {
1375  				while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; }
1376  				while (fabs(LearnRateV[p]*CurGradV[p]) &lt; 5 * MnStep) { LearnRateV[p] *= (1.0/0.95); } 
1377  			} else {
1378  				while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1379  				while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1380  				if (MxStep &gt; 3*MnStep) { MxStep *= 0.95; }
1381  			}
1382  			NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1383  			if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1384  			if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1385  			LearnRateV[p] *= 0.95;
1386  		}
1387  		printf(&quot;  trueE0: %.2f (%u from %u),  estE0: %.2f (%u from %u),  ERR: %f\n&quot;, EZero, RealEdges(), RealNodes(), ProbMtx.GetMtxSum(), Graph-&gt;GetEdges(), Graph-&gt;GetNodes(), fabs(EZero-ProbMtx.GetMtxSum()));
1388  		printf(&quot;      currLL: %.4f, deltaLL: %.4f\n&quot;, CurLL, CurLL-OldLL); 
1389  		for (int p = 0; p &lt; GetParams(); p++) {
1390  			printf(&quot;      %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1391  			ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1392  		}
1393  		OldLL=CurLL;
1394  		if(Iter == GradIter - 1) {
1395  			break;
1396  		}
1397  		CurLL = 0;
1398  		CurGradV.PutAll(0.0);
1399  		TFltV OneDLL;
1400  		CalcApxGraphLL();
1401  		CalcApxGraphDLL();
1402  		for(int s = 0; s &lt; NSamples; s++) {
1403  			ProbMtx = OldProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1404  			MetroGibbsSampleNext(10, true);
1405  			ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1406  			if(s % ReCalcLen == ReCalcLen/2) {
1407  				CurLL += CalcApxGraphLL();
1408  				OneDLL = CalcApxGraphDLL();
1409  			} else {
1410  				CurLL += LogLike;
1411  				OneDLL = GradV;
1412  			}
1413  			for(int p = 0; p &lt; GetParams(); p++) {
1414  				CurGradV[p] += OneDLL[p];
1415  			}
1416  		}
1417  		CurLL /= NSamples;
1418  		if(MaxLL &lt; CurLL) {
1419  			MaxLL = CurLL;	MaxProbMtx = ProbMtx;
1420  		}
1421  		printf(&quot;    Time: %s\n&quot;, IterTm.GetTmStr());
1422  		printf(&quot;\n&quot;);  fflush(stdout);
1423  	}
1424  	ProbMtx = MaxProbMtx;	ProbMtx.GetLLMtx(LLMtx);
1425  	printf(&quot;    FinalLL : %f,   TotalExeTm: %s\n&quot;, MaxLL, TotalTm.GetTmStr());
1426  	ProbMtx.Dump(&quot;    FITTED PARAMS&quot;, false);
1427  	return MaxLL;
1428  }
1429  void TKroneckerLL::RunKronEM(const int&amp; EMIter, const int&amp; GradIter, double LrnRate, double MnStep, double MxStep, const int&amp; GibbsWarmUp, const int&amp; WarmUp, const int&amp; NSamples, const TKronEMType&amp; Type, const int&amp; NMissing) {
1430  	printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1431  	printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, int(RealNodes), int(RealEdges));
1432  	printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1433  	TFltV LLV(NSamples);
1434  	TVec&lt;TFltV&gt; DLLV(NSamples);
1435  	EMType = Type;
1436  	MissEdges = NMissing;
1437  	AppendIsoNodes();
1438  	SetRndPerm();
1439  	if(DebugMode) {
1440  		LLV.Gen(EMIter, 0);
1441  		MtxV.Gen(EMIter, 0);
1442  	}
1443  	for(int i = 0; i &lt; EMIter; i++) {
1444  		printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1445  		printf(&quot;%03d EM-iter] E-Step\n&quot;, i+1);
1446  		RunEStep(GibbsWarmUp, WarmUp, NSamples, LLV, DLLV);
1447  		printf(&quot;\n\n&quot;);
1448  		printf(&quot;%03d EM-iter] M-Step\n&quot;, i+1);
1449  		double CurLL = RunMStep(LLV, DLLV, GradIter, LrnRate, MnStep, MxStep);
1450  		printf(&quot;\n\n&quot;);
1451  		if(DebugMode) {
1452  			LLV.Add(CurLL);
1453  			MtxV.Add(ProbMtx);
1454  		}
1455  	}
1456  	RestoreGraph();
1457  }
1458  void GetMinMax(const TFltPrV&amp; XYValV, double&amp; Min, double&amp; Max, const bool&amp; ResetMinMax) {
1459    if (ResetMinMax) { Min = TFlt::Mx;  Max = TFlt::Mn; }
1460    for (int i = 0; i &lt; XYValV.Len(); i++) {
1461      Min = TMath::Mn(Min, XYValV[i].Val2.Val);
1462      Max = TMath::Mx(Max, XYValV[i].Val2.Val);
1463    }
1464  }
1465  void PlotGrad(const TFltPrV&amp; EstLLV, const TFltPrV&amp; TrueLLV, const TVec&lt;TFltPrV&gt;&amp; GradVV, const TFltPrV&amp; AcceptV, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1466    double Min, Max, Min1, Max1;
1467    { TGnuPlot GP(&quot;sLL-&quot;+OutFNm, TStr::Fmt(&quot;Log-likelihood (avg 1k samples). %s&quot;, Desc.CStr()), true);
1468    GP.AddPlot(EstLLV, gpwLines, &quot;Esimated LL&quot;, &quot;linewidth 1&quot;);
1469    if (! TrueLLV.Empty()) { GP.AddPlot(TrueLLV, gpwLines, &quot;TRUE LL&quot;, &quot;linewidth 1&quot;); }
1470    GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Log-likelihood&quot;);
1471    GP.SavePng(); }
1472    { TGnuPlot GP(&quot;sAcc-&quot;+OutFNm, TStr::Fmt(&quot;Pct. accepted rnd moves (over 1k samples). %s&quot;, Desc.CStr()), true);
1473    GP.AddPlot(AcceptV, gpwLines, &quot;Pct accepted swaps&quot;, &quot;linewidth 1&quot;);
1474    GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Pct accept permutation swaps&quot;);
1475    GP.SavePng(); }
1476    TGnuPlot GPAll(&quot;sGradAll-&quot;+OutFNm, TStr::Fmt(&quot;Gradient (avg 1k samples). %s&quot;, Desc.CStr()), true);
1477    GetMinMax(GradVV[0], Min1, Max1, true);
1478    for (int g = 0; g &lt; GradVV.Len(); g++) {
1479      GPAll.AddPlot(GradVV[g], gpwLines, TStr::Fmt(&quot;param %d&quot;, g+1), &quot;linewidth 1&quot;);
1480      GetMinMax(GradVV[g], Min1, Max1, false);
1481      TGnuPlot GP(TStr::Fmt(&quot;sGrad%02d-&quot;, g+1)+OutFNm, TStr::Fmt(&quot;Gradient (avg 1k samples). %s&quot;, Desc.CStr()), true);
1482      GP.AddPlot(GradVV[g], gpwLines, TStr::Fmt(&quot;param id %d&quot;, g+1), &quot;linewidth 1&quot;);
1483      GetMinMax(GradVV[g], Min, Max, true);
1484      GP.SetYRange((int)floor(Min-1), (int)ceil(Max+1));
1485      GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Gradient&quot;);
1486      GP.SavePng();
1487    }
1488    GPAll.SetYRange((int)floor(Min1-1), (int)ceil(Max1+1));
1489    GPAll.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Gradient&quot;);
1490    GPAll.SavePng();
1491  }
1492  void PlotAutoCorrelation(const TFltV&amp; ValV, const int&amp; MaxK, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1493    double Avg=0.0, Var=0.0;
1494    for (int i = 0; i &lt; ValV.Len(); i++) { Avg += ValV[i]; }
1495    Avg /= (double) ValV.Len();
1496    for (int i = 0; i &lt; ValV.Len(); i++) { Var += TMath::Sqr(ValV[i]-Avg); }
1497    TFltPrV ACorrV;
1498    for (int k = 0; k &lt; TMath::Mn(ValV.Len(), MaxK); k++) {
1499      double corr = 0.0;
1500      for (int i = 0; i &lt; ValV.Len() - k; i++) {
1501        corr += (ValV[i]-Avg)*(ValV[i+k]-Avg);
1502      }
1503      ACorrV.Add(TFltPr(k, corr/Var));
1504    }
1505    TGnuPlot GP(&quot;sAutoCorr-&quot;+OutFNm, TStr::Fmt(&quot;AutoCorrelation (%d samples). %s&quot;, ValV.Len(), Desc.CStr()), true);
1506    GP.AddPlot(ACorrV, gpwLines, &quot;&quot;, &quot;linewidth 1&quot;);
1507    GP.SetXYLabel(&quot;Lag, k&quot;, &quot;Autocorrelation, r_k&quot;);
1508    GP.SavePng();
1509  }
1510  TFltV TKroneckerLL::TestSamplePerm(const TStr&amp; OutFNm, const int&amp; WarmUp, const int&amp; NSamples, const TKronMtx&amp; TrueMtx, const bool&amp; DoPlot) {
1511    printf(&quot;Sample permutations: %s (warm-up: %s)\n&quot;, TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1512    int NId1=0, NId2=0, NAccept=0;
1513    TExeTm ExeTm;
1514    const int PlotLen = NSamples/1000+1;
1515    double TrueLL=-1, AvgLL=0.0;
1516    TFltV AvgGradV(GetParams());
1517    TFltPrV TrueLLV(PlotLen, 0); 
1518    TFltPrV EstLLV(PlotLen, 0);  
1519    TFltPrV AcceptV;             
1520    TFltV SampleLLV(NSamples, 0);
1521    TVec&lt;TFltPrV&gt; GradVV(GetParams());
1522    for (int g = 0; g &lt; GetParams(); g++) {
1523      GradVV[g].Gen(PlotLen, 0); }
1524    if (! TrueMtx.Empty()) {
1525      TIntV PermV=NodePerm;  TKronMtx CurMtx=ProbMtx;  ProbMtx.Dump();
1526      InitLL(TrueMtx);  SetOrderPerm();  CalcApxGraphLL();  printf(&quot;TrueLL: %f\n&quot;, LogLike());
1527      TrueLL=LogLike;  InitLL(CurMtx); NodePerm=PermV;
1528    }
1529    CalcApxGraphLL();
1530    printf(&quot;LogLike at start:       %f\n&quot;, LogLike());
1531    if (WarmUp &gt; 0) {
1532      EstLLV.Add(TFltPr(0, LogLike));
1533      if (TrueLL != -1) { TrueLLV.Add(TFltPr(0, TrueLL)); }
1534      for (int s = 0; s &lt; WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1535      printf(&quot;  warm-up:%s,&quot;, ExeTm.GetTmStr());  ExeTm.Tick();
1536    }
1537    printf(&quot;LogLike afterm warm-up: %f\n&quot;, LogLike());
1538    CalcApxGraphLL(); 
1539    CalcApxGraphDLL();
1540    EstLLV.Add(TFltPr(WarmUp, LogLike));
1541    if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp, TrueLL)); }
1542    printf(&quot;  recalculated:         %f\n&quot;, LogLike());
1543    printf(&quot;  sampling (average per 1000 samples)\n&quot;);
1544    TVec&lt;TFltV&gt; SamplVV(5);
1545    for (int s = 0; s &lt; NSamples; s++) {
1546      if (SampleNextPerm(NId1, NId2)) { 
1547        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1548      for (int m = 0; m &lt; AvgGradV.Len(); m++) { AvgGradV[m] += GradV[m]; }
1549      AvgLL += GetLL();
1550      SampleLLV.Add(GetLL());
1551      if (s &gt; 0 &amp;&amp; s % 1000 == 0) {
1552        printf(&quot;.&quot;);
1553        for (int g = 0; g &lt; AvgGradV.Len(); g++) {
1554          GradVV[g].Add(TFltPr(WarmUp+s, AvgGradV[g] / 1000.0)); }
1555        EstLLV.Add(TFltPr(WarmUp+s, AvgLL / 1000.0));
1556        if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp+s, TrueLL)); }
1557        AcceptV.Add(TFltPr(WarmUp+s, NAccept/1000.0));
1558        if (s % 100000 == 0 &amp;&amp; DoPlot) {
1559          const TStr Desc = TStr::Fmt(&quot;P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s&quot;, PermSwapNodeProb(),
1560            Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1561          PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1562          for (int n = 0; n &lt; SamplVV.Len(); n++) {
1563            PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt(&quot;%s-n%d&quot;, OutFNm.CStr(), n), Desc); }
1564          printf(&quot;  samples: %d, time: %s, samples/s: %.1f\n&quot;, s, ExeTm.GetTmStr(), double(s+1)/ExeTm.GetSecs());
1565        }
1566        AvgLL = 0;  AvgGradV.PutAll(0);  NAccept=0;
1567      }
1568    }
1569    if (DoPlot) {
1570      const TStr Desc = TStr::Fmt(&quot;P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s&quot;, PermSwapNodeProb(),
1571        Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1572      PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1573      for (int n = 0; n &lt; SamplVV.Len(); n++) {
1574        PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt(&quot;%s-n%d&quot;, OutFNm.CStr(), n), Desc); }
1575    }
1576    return SampleLLV; 
1577  }
1578  void McMcGetAvgAvg(const TFltV&amp; AvgJV, double&amp; AvgAvg) {
1579    AvgAvg = 0.0;
1580    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1581      AvgAvg += AvgJV[j]; }
1582    AvgAvg /= AvgJV.Len();
1583  }
1584  void McMcGetAvgJ(const TVec&lt;TFltV&gt;&amp; ChainLLV, TFltV&amp; AvgJV) {
1585    for (int j = 0; j &lt; ChainLLV.Len(); j++) {
1586      const TFltV&amp; ChainV = ChainLLV[j];
1587      double Avg = 0;
1588      for (int i = 0; i &lt; ChainV.Len(); i++) {
1589        Avg += ChainV[i];
1590      }
1591      AvgJV.Add(Avg/ChainV.Len());
1592    }
1593  }
1594  double TKroneckerLL::CalcChainR2(const TVec&lt;TFltV&gt;&amp; ChainLLV) {
1595    const double J = ChainLLV.Len();
1596    const double K = ChainLLV[0].Len();
1597    TFltV AvgJV;    McMcGetAvgJ(ChainLLV, AvgJV);
1598    double AvgAvg;  McMcGetAvgAvg(AvgJV, AvgAvg);
1599    IAssert(AvgJV.Len() == ChainLLV.Len());
1600    double InChainVar=0, OutChainVar=0;
1601    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1602      OutChainVar += TMath::Sqr(AvgJV[j] - AvgAvg); }
1603    OutChainVar = OutChainVar * (K/double(J-1));
1604    printf(&quot;*** %g chains of len %g\n&quot;, J, K);
1605    printf(&quot;  ** between chain var: %f\n&quot;, OutChainVar);
1606    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1607      const TFltV&amp; ChainV = ChainLLV[j];
1608      for (int k = 0; k &lt; ChainV.Len(); k++) {
1609        InChainVar += TMath::Sqr(ChainV[k] - AvgJV[j]); }
1610    }
1611    InChainVar = InChainVar * 1.0/double(J*(K-1));
1612    printf(&quot;  ** within chain var: %f\n&quot;, InChainVar);
1613    const double PostVar = (K-1)/K * InChainVar + 1.0/K * OutChainVar;
1614    printf(&quot;  ** posterior var: %f\n&quot;, PostVar);
1615    const double ScaleRed = sqrt(PostVar/InChainVar);
1616    printf(&quot;  ** scale reduction (&lt; 1.2): %f\n\n&quot;, ScaleRed);
1617    return ScaleRed;
1618  }
1619  void TKroneckerLL::ChainGelmapRubinPlot(const TVec&lt;TFltV&gt;&amp; ChainLLV, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1620    TFltPrV LenR2V; 
1621    TVec&lt;TFltV&gt; SmallLLV(ChainLLV.Len());
1622    const int K = ChainLLV[0].Len();
1623    const int Buckets=1000;
1624    const int BucketSz = K/Buckets;
1625    for (int b = 1; b &lt; Buckets; b++) {
1626      const int End = TMath::Mn(BucketSz*b, K-1);
1627      for (int c = 0; c &lt; ChainLLV.Len(); c++) {
1628        ChainLLV[c].GetSubValV(0, End, SmallLLV[c]); }
1629      LenR2V.Add(TFltPr(End, TKroneckerLL::CalcChainR2(SmallLLV)));
1630    }
1631    LenR2V.Add(TFltPr(K, TKroneckerLL::CalcChainR2(ChainLLV)));
1632    TGnuPlot::PlotValV(LenR2V, TStr::Fmt(&quot;gelman-%s&quot;, OutFNm.CStr()), TStr::Fmt(&quot;%s. %d chains of len %d. BucketSz: %d.&quot;,
1633      Desc.CStr(), ChainLLV.Len(), ChainLLV[0].Len(), BucketSz), &quot;Chain length&quot;, &quot;Potential scale reduction&quot;);
1634  }
1635  TFltQu TKroneckerLL::TestKronDescent(const bool&amp; DoExact, const bool&amp; TruePerm, double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const TKronMtx&amp; TrueParam) {
1636    printf(&quot;Test gradient descent on a synthetic kronecker graphs:\n&quot;);
1637    if (DoExact) { printf(&quot;  -- Exact gradient calculations\n&quot;); }
1638    else { printf(&quot;  -- Approximate gradient calculations\n&quot;); }
1639    if (TruePerm) { printf(&quot;  -- No permutation sampling (use true permutation)\n&quot;); }
1640    else { printf(&quot;  -- Sample permutations (start with degree permutation)\n&quot;); }
1641    TExeTm IterTm;
1642    int Iter;
1643    double OldLL=0, MyLL=0, AvgAbsErr, AbsSumErr;
1644    TFltV MyGradV, SDevV;
1645    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1646    if (TruePerm) {
1647      SetOrderPerm();
1648    }
1649    else {
1650      printf(&quot;DEGREE  PERMUTATION\n&quot;);  SetDegPerm();
1651    }
1652    for (Iter = 0; Iter &lt; 100; Iter++) {
1653      if (TruePerm) {
1654        if (DoExact) { CalcGraphDLL();  CalcGraphLL(); } 
1655        else { CalcApxGraphDLL();  CalcApxGraphLL(); }   
1656        MyLL = LogLike;  MyGradV = GradV;
1657      } else {
1658        printf(&quot;.&quot;);
1659        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1660      }
1661      printf(&quot;%d] LL: %g, &quot;, Iter, MyLL);
1662      AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1663      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueParam.GetMtxSum());
1664      printf(&quot;  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n&quot;, AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1665      for (int p = 0; p &lt; GetParams(); p++) {
1666        LearnRateV[p] *= 0.9;
1667        while (fabs(LearnRateV[p]*MyGradV[p]) &gt; 0.1) { LearnRateV[p] *= 0.9; }
1668        while (fabs(LearnRateV[p]*MyGradV[p]) &lt; 0.001) { LearnRateV[p] *= (1.0/0.9); }
1669        printf(&quot;    %d]  %f  &lt;--  %f + %f    lrnRate:%g\n&quot;, p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1670          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), LearnRateV[p]());
1671        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1672        if (ProbMtx.At(p) &gt; 0.99) { ProbMtx.At(p)=0.99; }
1673        if (ProbMtx.At(p) &lt; 0.01) { ProbMtx.At(p)=0.01; }
1674      }
1675      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1676      if (AvgAbsErr &lt; 0.01) { printf(&quot;***CONVERGED!\n&quot;);  break; }
1677      printf(&quot;\n&quot;);  fflush(stdout);
1678    }
1679    TrueParam.Dump(&quot;True  Thetas&quot;, true);
1680    ProbMtx.Dump(&quot;Final Thetas&quot;, true);
1681    printf(&quot;  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n&quot;, AvgAbsErr, AbsSumErr, Iter);
1682    printf(&quot;Iteration run time: %s, sec: %g\n\n&quot;, IterTm.GetTmStr(), IterTm.GetSecs());
1683    return TFltQu(AvgAbsErr, AbsSumErr, Iter, IterTm.GetSecs());
1684  }
1685  void PlotTrueAndEst(const TStr&amp; OutFNm, const TStr&amp; Desc, const TStr&amp; YLabel, const TFltPrV&amp; EstV, const TFltPrV&amp; TrueV) {
1686    TGnuPlot GP(OutFNm, Desc.CStr(), true);
1687    GP.AddPlot(EstV, gpwLinesPoints, YLabel, &quot;linewidth 1 pointtype 6 pointsize 1&quot;);
1688    if (! TrueV.Empty()) { GP.AddPlot(TrueV, gpwLines, &quot;TRUE&quot;); }
1689    GP.SetXYLabel(&quot;Gradient descent iterations&quot;, YLabel);
1690    GP.SavePng();
1691  }
1692  void TKroneckerLL::GradDescentConvergence(const TStr&amp; OutFNm, const TStr&amp; Desc1, const bool&amp; SamplePerm, const int&amp; NIters,
1693   double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const int&amp; AvgKGraphs, const TKronMtx&amp; TrueParam) {
1694    TExeTm IterTm;
1695    int Iter;
1696    double OldLL=0, MyLL=0, AvgAbsErr=0, AbsSumErr=0;
1697    TFltV MyGradV, SDevV;
1698    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1699    TFltPrV EZeroV, DiamV, Lambda1V, Lambda2V, AvgAbsErrV, AvgLLV;
1700    TFltPrV TrueEZeroV, TrueDiamV, TrueLambda1V, TrueLambda2V, TrueLLV;
1701    TFltV SngValV;  TSnap::GetSngVals(Graph, 2, SngValV);  SngValV.Sort(false);
1702    const double TrueEZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1703    const double TrueEffDiam = TSnap::GetAnfEffDiam(Graph, false, 10);
1704    const double TrueLambda1 = SngValV[0];
1705    const double TrueLambda2 = SngValV[1];
1706    if (! TrueParam.Empty()) {
1707      const TKronMtx CurParam = ProbMtx;  ProbMtx.Dump();
1708      InitLL(TrueParam);  SetOrderPerm();  CalcApxGraphLL(); printf(&quot;TrueLL: %f\n&quot;, LogLike());
1709      OldLL = LogLike;  InitLL(CurParam);
1710    }
1711    const double TrueLL = OldLL;
1712    if (! SamplePerm) { SetOrderPerm(); } else { SetDegPerm(); }
1713    for (Iter = 0; Iter &lt; NIters; Iter++) {
1714      if (! SamplePerm) {
1715        CalcApxGraphDLL();  CalcApxGraphLL();   
1716        MyLL = LogLike;  MyGradV = GradV;
1717      } else {
1718        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1719      }
1720      double SumDiam=0, SumSngVal1=0, SumSngVal2=0;
1721      for (int trial = 0; trial &lt; AvgKGraphs; trial++) {
1722        PNGraph KronGraph = TKronMtx::GenFastKronecker(ProbMtx, KronIters, true, 0); 
1723        SngValV.Clr(true);  TSnap::GetSngVals(KronGraph, 2, SngValV);  SngValV.Sort(false);
1724        SumDiam += TSnap::GetAnfEffDiam(KronGraph, false, 10);
1725        SumSngVal1 += SngValV[0];  SumSngVal2 += SngValV[1];
1726      }
1727      AvgLLV.Add(TFltPr(Iter, MyLL));
1728      EZeroV.Add(TFltPr(Iter, ProbMtx.GetMtxSum()));
1729      DiamV.Add(TFltPr(Iter, SumDiam/double(AvgKGraphs)));
1730      Lambda1V.Add(TFltPr(Iter, SumSngVal1/double(AvgKGraphs)));
1731      Lambda2V.Add(TFltPr(Iter, SumSngVal2/double(AvgKGraphs)));
1732      TrueLLV.Add(TFltPr(Iter, TrueLL));
1733      TrueEZeroV.Add(TFltPr(Iter, TrueEZero));
1734      TrueDiamV.Add(TFltPr(Iter, TrueEffDiam));
1735      TrueLambda1V.Add(TFltPr(Iter, TrueLambda1));
1736      TrueLambda2V.Add(TFltPr(Iter, TrueLambda2));
1737      if (Iter % 10 == 0) {
1738        const TStr Desc = TStr::Fmt(&quot;%s. Iter: %d, G(%d, %d)  K(%d, %d)&quot;, Desc1.Empty()?OutFNm.CStr():Desc1.CStr(),
1739          Iter, Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), ProbMtx.GetNodes(KronIters), ProbMtx.GetEdges(KronIters));
1740        PlotTrueAndEst(&quot;LL.&quot;+OutFNm, Desc, &quot;Average LL&quot;, AvgLLV, TrueLLV);
1741        PlotTrueAndEst(&quot;E0.&quot;+OutFNm, Desc, &quot;E0 (expected number of edges)&quot;, EZeroV, TrueEZeroV);
1742        PlotTrueAndEst(&quot;Diam.&quot;+OutFNm+&quot;-Diam&quot;, Desc, &quot;Effective diameter&quot;, DiamV, TrueDiamV);
1743        PlotTrueAndEst(&quot;Lambda1.&quot;+OutFNm, Desc, &quot;Lambda 1&quot;, Lambda1V, TrueLambda1V);
1744        PlotTrueAndEst(&quot;Lambda2.&quot;+OutFNm, Desc, &quot;Lambda 2&quot;, Lambda2V, TrueLambda2V);
1745        if (! TrueParam.Empty()) {
1746          PlotTrueAndEst(&quot;AbsErr.&quot;+OutFNm, Desc, &quot;Average Absolute Error&quot;, AvgAbsErrV, TFltPrV()); }
1747      }
1748      if (! TrueParam.Empty()) {
1749        AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1750        AvgAbsErrV.Add(TFltPr(Iter, AvgAbsErr));
1751      } else { AvgAbsErr = 1.0; }
1752      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueEZero);
1753      for (int p = 0; p &lt; GetParams(); p++) {
1754        LearnRateV[p] *= 0.99;
1755        while (fabs(LearnRateV[p]*MyGradV[p]) &gt; 0.1) { LearnRateV[p] *= 0.99; printf(&quot;.&quot;);}
1756        while (fabs(LearnRateV[p]*MyGradV[p]) &lt; 0.002) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1757        printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f,  Rate:%g\n&quot;, p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1758          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), MyGradV[p](), LearnRateV[p]());
1759        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1760        if (ProbMtx.At(p) &gt; 1.0) { ProbMtx.At(p)=1.0; }
1761        if (ProbMtx.At(p) &lt; 0.001) { ProbMtx.At(p)=0.001; }
1762      }
1763      printf(&quot;%d] LL: %g, &quot;, Iter, MyLL);
1764      printf(&quot;  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n&quot;, AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1765      if (AvgAbsErr &lt; 0.001) { printf(&quot;***CONVERGED!\n&quot;);  break; }
1766      printf(&quot;\n&quot;);  fflush(stdout);
1767      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1768    }
1769    TrueParam.Dump(&quot;True  Thetas&quot;, true);
1770    ProbMtx.Dump(&quot;Final Thetas&quot;, true);
1771    printf(&quot;  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n&quot;, AvgAbsErr, AbsSumErr, Iter);
1772    printf(&quot;Iteration run time: %s, sec: %g\n\n&quot;, IterTm.GetTmStr(), IterTm.GetSecs());
1773  }
1774  void TKroneckerLL::TestBicCriterion(const TStr&amp; OutFNm, const TStr&amp; Desc1, const PNGraph&amp; G, const int&amp; GradIters,
1775   double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const int&amp; TrueN0) {
1776    TFltPrV BicV, MdlV, LLV;
1777    const double rndGP = G-&gt;GetEdges()/TMath::Sqr(double(G-&gt;GetNodes()));
1778    const double RndGLL = G-&gt;GetEdges()*log(rndGP )+ (TMath::Sqr(double(G-&gt;GetNodes()))-G-&gt;GetEdges())*log(1-rndGP);
1779    LLV.Add(TFltPr(1, RndGLL));
1780    BicV.Add(TFltPr(1, -RndGLL + 0.5*TMath::Sqr(1)*log(TMath::Sqr(G-&gt;GetNodes()))));
1781    MdlV.Add(TFltPr(1, -RndGLL + 32*TMath::Sqr(1)+2*(log((double)1)+log((double)G-&gt;GetNodes()))));
1782    for (int NZero = 2; NZero &lt; 10; NZero++) {
1783      const TKronMtx InitKronMtx = TKronMtx::GetInitMtx(NZero, G-&gt;GetNodes(), G-&gt;GetEdges());
1784      InitKronMtx.Dump(&quot;INIT PARAM&quot;, true);
1785      TKroneckerLL KronLL(G, InitKronMtx);
1786      KronLL.SetPerm(&#x27;d&#x27;); 
1787      const double LastLL = KronLL.GradDescent(GradIters, LearnRate, 0.001, 0.01, WarmUp, NSamples);
1788      LLV.Add(TFltPr(NZero, LastLL));
1789      BicV.Add(TFltPr(NZero, -LastLL + 0.5*TMath::Sqr(NZero)*log(TMath::Sqr(G-&gt;GetNodes()))));
1790      MdlV.Add(TFltPr(NZero, -LastLL + 32*TMath::Sqr(NZero)+2*(log((double)NZero)+log((double)KronLL.GetKronIters()))));
1791      { TGnuPlot GP(&quot;LL-&quot;+OutFNm, Desc1);
1792      GP.AddPlot(LLV, gpwLinesPoints, &quot;Log-likelihood&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1793      GP.SetXYLabel(&quot;NZero&quot;, &quot;Log-Likelihood&quot;);  GP.SavePng(); }
1794      { TGnuPlot GP(&quot;BIC-&quot;+OutFNm, Desc1);
1795      GP.AddPlot(BicV, gpwLinesPoints, &quot;BIC&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1796      GP.SetXYLabel(&quot;NZero&quot;, &quot;BIC&quot;);  GP.SavePng(); }
1797      { TGnuPlot GP(&quot;MDL-&quot;+OutFNm, Desc1);
1798      GP.AddPlot(MdlV, gpwLinesPoints, &quot;MDL&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1799      GP.SetXYLabel(&quot;NZero&quot;, &quot;MDL&quot;);  GP.SavePng(); }
1800    }
1801  }
1802  void TKroneckerLL::TestGradDescent(const int&amp; KronIters, const int&amp; KiloSamples, const TStr&amp; Permutation) {
1803    const TStr OutFNm = TStr::Fmt(&quot;grad-%s%d-%dk&quot;, Permutation.CStr(), KronIters, KiloSamples);
1804    TKronMtx KronParam = TKronMtx::GetMtx(&quot;0.8 0.6; 0.6 0.4&quot;);
1805    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, KronIters, true, 0);
1806    TKroneckerLL KronLL(Graph, KronParam);
1807    TVec&lt;TFltV&gt; GradVV(4), SDevVV(4);  TFltV XValV;
1808    int NId1 = 0, NId2 = 0, NAccept = 0;
1809    TVec&lt;TMom&gt; GradMomV(4);
1810    TExeTm ExeTm;
1811    if (Permutation == &quot;r&quot;) KronLL.SetRndPerm();
1812    else if (Permutation == &quot;d&quot;) KronLL.SetDegPerm();
1813    else if (Permutation == &quot;o&quot;) KronLL.SetOrderPerm();
1814    else FailR(&quot;Unknown permutation (r,d,o)&quot;);
1815    KronLL.CalcApxGraphLL();
1816    KronLL.CalcApxGraphDLL();
1817    for (int s = 0; s &lt; 1000*KiloSamples; s++) {
1818      if (KronLL.SampleNextPerm(NId1, NId2)) { 
1819        KronLL.UpdateGraphDLL(NId1, NId2);  NAccept++; }
1820      if (s &gt; 50000) { 
1821        for (int m = 0; m &lt; 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1822        if ((s+1) % 1000 == 0) {
1823          printf(&quot;.&quot;);
1824          for (int m = 0; m &lt; 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1825          XValV.Add((s+1));
1826          if ((s+1) % 100000 == 0) {
1827            TGnuPlot GP(OutFNm, TStr::Fmt(&quot;Gradient vs. samples. %d nodes, %d edges&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()), true);
1828            for (int g = 0; g &lt; GradVV.Len(); g++) {
1829              GP.AddPlot(XValV, GradVV[g], gpwLines, TStr::Fmt(&quot;grad %d&quot;, g)); }
1830            GP.SetXYLabel(&quot;sample index&quot;,&quot;log Gradient&quot;);
1831            GP.SavePng();
1832          }
1833        }
1834      }
1835    }
1836    printf(&quot;\n&quot;);
1837    for (int m = 0; m &lt; 4; m++) {
1838      GradMomV[m].Def();
1839      printf(&quot;grad %d: mean: %12f  sDev: %12f  median: %12f\n&quot;, m,
1840        GradMomV[m].GetMean(), GradMomV[m].GetSDev(), GradMomV[m].GetMedian());
1841    }
1842  }
1843  int TKronNoise::RemoveNodeNoise(PNGraph&amp; Graph, const int&amp; NNodes, const bool Random) {
1844  	IAssert(NNodes &gt; 0 &amp;&amp; NNodes &lt; (Graph-&gt;GetNodes() / 2));
1845  	int i = 0;
1846  	TIntV ShufflePerm;
1847  	Graph-&gt;GetNIdV(ShufflePerm);
1848  	if(Random) {
1849  		ShufflePerm.Shuffle(TKronMtx::Rnd);
1850  		for(i = 0; i &lt; NNodes; i++) {
1851  			Graph-&gt;DelNode(int(ShufflePerm[i]));
1852  		}
1853  	} else {
1854  		for(i = 0; i &lt; NNodes; i++) {
1855  			Graph-&gt;DelNode(int(ShufflePerm[ShufflePerm.Len() - 1 - i]));
1856  		}
1857  	}
1858  	return Graph-&gt;GetNodes();
1859  }
1860  int TKronNoise::RemoveNodeNoise(PNGraph&amp; Graph, const double&amp; Rate, const bool Random) {
1861  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1862  	return TKronNoise::RemoveNodeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetNodes())), Random);
1863  }
1864  int TKronNoise::FlipEdgeNoise(PNGraph&amp; Graph, const int&amp; NEdges, const bool Random) {
1865  	IAssert(NEdges &gt; 0 &amp;&amp; NEdges &lt; Graph-&gt;GetEdges());
1866  	const int Nodes = Graph-&gt;GetNodes();
1867  	const int Edges = Graph-&gt;GetEdges();
1868  	int Src, Dst;
1869  	TIntV NIdV, TempV;
1870  	TIntPrV ToAdd, ToDel;
1871  	Graph-&gt;GetNIdV(NIdV);
1872  	ToAdd.Gen(NEdges / 2, 0);
1873  	for(int i = 0; i &lt; NEdges / 2; i++) {
1874  		Src = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1875  		Dst = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1876  		if(Graph-&gt;IsEdge(Src, Dst)) {	i--;	continue;	}
1877  		ToAdd.Add(TIntPr(Src, Dst));
1878  	}
1879  	ToDel.Gen(Edges, 0);
1880  	for(TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
1881  		ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1882  	}
1883  	ToDel.Shuffle(TKronMtx::Rnd);
1884  	for(int i = 0; i &lt; NEdges / 2; i++) {
1885  		Graph-&gt;DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1886  		Graph-&gt;AddEdge(ToAdd[i].Val1, ToAdd[i].Val2);
1887  	}
1888  	return Graph-&gt;GetEdges();
1889  }
1890  int TKronNoise::FlipEdgeNoise(PNGraph&amp; Graph, const double&amp; Rate, const bool Random) {
1891  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1892  	return TKronNoise::FlipEdgeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetEdges())), Random);
1893  }
1894  int TKronNoise::RemoveEdgeNoise(PNGraph&amp; Graph, const int&amp; NEdges) {
1895  	IAssert(NEdges &gt; 0 &amp;&amp; NEdges &lt; Graph-&gt;GetEdges());
1896  	TIntPrV ToDel;
1897  	ToDel.Gen(Graph-&gt;GetEdges(), 0);
1898  	for(TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
1899  		if(EI.GetSrcNId() != EI.GetDstNId()) {
1900  			ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1901  		}
1902  	}
1903  	ToDel.Shuffle(TKronMtx::Rnd);
1904  	for(int i = 0; i &lt; NEdges; i++) {
1905  		Graph-&gt;DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1906  	}
1907  	return Graph-&gt;GetEdges();
1908  }
1909  int TKronNoise::RemoveEdgeNoise(PNGraph&amp; Graph, const double&amp; Rate) {
1910  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1911  	return TKronNoise::RemoveEdgeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetEdges())));
1912  }
1913  void TKronMaxLL::SetPerm(const char&amp; PermId) {
1914    if (PermId == &#x27;o&#x27;) KronLL.SetOrderPerm();
1915    else if (PermId == &#x27;d&#x27;) KronLL.SetDegPerm();
1916    else if (PermId == &#x27;r&#x27;) KronLL.SetRndPerm();
1917    else FailR(&quot;Unknown permutation type (o,d,r)&quot;);
1918  }
1919  void TKronMaxLL::RoundTheta(const TFltV&amp; ThetaV, TFltV&amp; NewThetaV) {
1920    NewThetaV.Gen(ThetaV.Len());
1921    for (int i = 0; i &lt; ThetaV.Len(); i++) {
1922      NewThetaV[i] = TMath::Round(ThetaV[i], 3); }
1923  }
1924  void TKronMaxLL::RoundTheta(const TFltV&amp; ThetaV, TKronMtx&amp; Kronecker) {
1925    Kronecker.GenMtx((int)sqrt((double)ThetaV.Len()));
1926    for (int i = 0; i &lt; ThetaV.Len(); i++) {
1927      Kronecker.At(i) = TMath::Round(ThetaV[i], 3); }
1928  }
1929  void TKronMaxLL::Test() {
1930    TKronMtx::PutRndSeed(1);
1931    TKronMtx KronParam = TKronMtx::GetMtx(&quot;0.8 0.7; 0.6 0.5&quot;);
1932    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, 8, true, 1);
1933    TKronMaxLL KronMaxLL(Graph, TFltV::GetV(0.9, 0.7, 0.5, 0.3));
1934    KronMaxLL.SetPerm(&#x27;d&#x27;);
1935  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</h3>
            <pre><code>1  #include &quot;stdafx.h&quot;
2  #include &quot;kronecker.h&quot;
3  const double TKronMtx::NInf = -DBL_MAX;
4  TRnd TKronMtx::Rnd = TRnd(0);
5  TKronMtx::TKronMtx(const TFltV&amp; SeedMatrix) : SeedMtx(SeedMatrix) {
6    MtxDim = (int) sqrt((double)SeedMatrix.Len());
7    IAssert(MtxDim*MtxDim == SeedMtx.Len());
8  }
9  void TKronMtx::SaveTxt(const TStr&amp; OutFNm) const {
10    FILE *F = fopen(OutFNm.CStr(), &quot;wt&quot;);
11    for (int i = 0; i &lt; GetDim(); i++) {
12      for (int j = 0; j &lt; GetDim(); j++) {
13        if (j &gt; 0) fprintf(F, &quot;\t&quot;);
14        fprintf(F, &quot;%f&quot;, At(i,j)); }
15      fprintf(F, &quot;\n&quot;);
16    }
17    fclose(F);
18  }
19  TKronMtx&amp; TKronMtx::operator = (const TKronMtx&amp; Kronecker) {
20    if (this != &amp;Kronecker){
21      MtxDim=Kronecker.MtxDim;
22      SeedMtx=Kronecker.SeedMtx;
23    }
24    return *this;
25  }
26  bool TKronMtx::IsProbMtx() const {
27    for (int i = 0; i &lt; Len(); i++) {
28      if (At(i) &lt; 0.0 || At(i) &gt; 1.0) return false;
29    }
30    return true;
31  }
32  void TKronMtx::SetRndMtx(const int&amp; PrmMtxDim, const double&amp; MinProb) {
33    MtxDim = PrmMtxDim;
34    SeedMtx.Gen(MtxDim*MtxDim);
35    for (int p = 0; p &lt; SeedMtx.Len(); p++) {
36      do {
37        SeedMtx[p] = TKronMtx::Rnd.GetUniDev();
38      } while (SeedMtx[p] &lt; MinProb);
39    }
40  }
41  void TKronMtx::SetEpsMtx(const double&amp; Eps1, const double&amp; Eps0, const int&amp; Eps1Val, const int&amp; Eps0Val) {
42    for (int i = 0; i &lt; Len(); i++) {
43      double&amp; Val = At(i);
44      if (Val == Eps1Val) Val = double(Eps1);
45      else if (Val == Eps0Val) Val = double(Eps0);
46    }
47  }
48  void TKronMtx::SetForEdges(const int&amp; Nodes, const int&amp; Edges) {
49    const int KronIter = GetKronIter(Nodes);
50    const double EZero = pow((double) Edges, 1.0/double(KronIter));
51    const double Factor = EZero / GetMtxSum();
52    for (int i = 0; i &lt; Len(); i++) {
53      At(i) *= Factor;
54      if (At(i) &gt; 1) { At(i) = 1; }
55    }
56  }
57  void TKronMtx::AddRndNoise(const double&amp; SDev) {
58    Dump(&quot;before&quot;);
59    double NewVal;
60    int c =0;
61    for (int i = 0; i &lt; Len(); i++) {
62      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) &lt; 0.01 || NewVal&gt;0.99) &amp;&amp; c &lt;1000; c++) { }
63      if (c &lt; 999) { At(i) = NewVal; } else { printf(&quot;XXXXX\n&quot;); }
64    }
65    Dump(&quot;after&quot;);
66  }
67  TStr TKronMtx::GetMtxStr() const {
68    TChA ChA(&quot;[&quot;);
69    for (int i = 0; i &lt; Len(); i++) {
70      ChA += TStr::Fmt(&quot;%g&quot;, At(i));
71      if ((i+1)%GetDim()==0 &amp;&amp; (i+1&lt;Len())) { ChA += &quot;; &quot;; }
72      else if (i+1&lt;Len()) { ChA += &quot;, &quot;; }
73    }
74    ChA += &quot;]&quot;;
75    return TStr(ChA);
76  }
77  void TKronMtx::ToOneMinusMtx() {
78    for (int i = 0; i &lt; Len(); i++) {
79      IAssert(At(i) &gt;= 0.0 &amp;&amp; At(i) &lt;= 1.0);
80      At(i) = 1.0 - At(i);
81    }
82  }
83  void TKronMtx::GetLLMtx(TKronMtx&amp; LLMtx) {
84    LLMtx.GenMtx(MtxDim);
85    for (int i = 0; i &lt; Len(); i++) {
86      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
87      else { LLMtx.At(i) = NInf; }
88    }
89  }
90  void TKronMtx::GetProbMtx(TKronMtx&amp; ProbMtx) {
91    ProbMtx.GenMtx(MtxDim);
92    for (int i = 0; i &lt; Len(); i++) {
93      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
94      else { ProbMtx.At(i) = 0.0; }
95    }
96  }
97  void TKronMtx::Swap(TKronMtx&amp; KronMtx) {
98    ::Swap(MtxDim, KronMtx.MtxDim);
99    SeedMtx.Swap(KronMtx.SeedMtx);
100  }
101  int TKronMtx::GetNodes(const int&amp; NIter) const {
102    return (int) pow(double(GetDim()), double(NIter));
103  }
104  int TKronMtx::GetEdges(const int&amp; NIter) const {
105    return (int) pow(double(GetMtxSum()), double(NIter));
106  }
107  int TKronMtx::GetKronIter(const int&amp; Nodes) const {
108    return (int) ceil(log(double(Nodes)) / log(double(GetDim()))); 
109  }
110  int TKronMtx::GetNZeroK(const PNGraph&amp; Graph) const {
111   return GetNodes(GetKronIter(Graph-&gt;GetNodes()));
112  }
113  double TKronMtx::GetEZero(const int&amp; Edges, const int&amp; KronIters) const {
114    return pow((double) Edges, 1.0/double(KronIters));
115  }
116  double TKronMtx::GetMtxSum() const {
117    double Sum = 0;
118    for (int i = 0; i &lt; Len(); i++) {
119      Sum += At(i); }
120    return Sum;
121  }
122  double TKronMtx::GetRowSum(const int&amp; RowId) const {
123    double Sum = 0;
124    for (int c = 0; c &lt; GetDim(); c++) {
125      Sum += At(RowId, c); }
126    return Sum;
127  }
128  double TKronMtx::GetColSum(const int&amp; ColId) const {
129    double Sum = 0;
130    for (int r = 0; r &lt; GetDim(); r++) {
131      Sum += At(r, ColId); }
132    return Sum;
133  }
134  double TKronMtx::GetEdgeProb(int NId1, int NId2, const int&amp; NKronIters) const {
135    double Prob = 1.0;
136    for (int level = 0; level &lt; NKronIters; level++) {
137      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
138      if (Prob == 0.0) { return 0.0; }
139      NId1 /= MtxDim;  NId2 /= MtxDim;
140    }
141    return Prob;
142  }
143  double TKronMtx::GetNoEdgeProb(int NId1, int NId2, const int&amp; NKronIters) const {
144    return 1.0 - GetEdgeProb(NId1, NId2, NKronIters);
145  }
146  double TKronMtx::GetEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
147    double LL = 0.0;
148    for (int level = 0; level &lt; NKronIters; level++) {
149      const double&amp; LLVal = At(NId1 % MtxDim, NId2 % MtxDim);
150      if (LLVal == NInf) return NInf;
151      LL += LLVal;
152      NId1 /= MtxDim;  NId2 /= MtxDim;
153    }
154    return LL;
155  }
156  double TKronMtx::GetNoEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
157    return log(1.0 - exp(GetEdgeLL(NId1, NId2, NKronIters)));
158  }
159  double TKronMtx::GetApxNoEdgeLL(int NId1, int NId2, const int&amp; NKronIters) const {
160    const double EdgeLL = GetEdgeLL(NId1, NId2, NKronIters);
161    return -exp(EdgeLL) - 0.5*exp(2*EdgeLL);
162  }
163  bool TKronMtx::IsEdgePlace(int NId1, int NId2, const int&amp; NKronIters, const double&amp; ProbTresh) const {
164    double Prob = 1.0;
165    for (int level = 0; level &lt; NKronIters; level++) {
166      Prob *= At(NId1 % MtxDim, NId2 % MtxDim);
167      if (ProbTresh &gt; Prob) { return false; }
168      NId1 /= MtxDim;  NId2 /= MtxDim;
169    }
170    return true;
171  }
172  double TKronMtx::GetEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
173    const int ThetaX = ParamId % GetDim();
174    const int ThetaY = ParamId / GetDim();
175    int ThetaCnt = 0;
176    for (int level = 0; level &lt; NKronIters; level++) {
177      if ((NId1 % MtxDim) == ThetaX &amp;&amp; (NId2 % MtxDim) == ThetaY) {
178        ThetaCnt++; }
179      NId1 /= MtxDim;  NId2 /= MtxDim;
180    }
181    return double(ThetaCnt) / exp(At(ParamId));
182  }
183  double TKronMtx::GetNoEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
184    const int&amp; ThetaX = ParamId % GetDim();
185    const int&amp; ThetaY = ParamId / GetDim();
186    int ThetaCnt = 0;
187    double DLL = 0, LL = 0;
188    for (int level = 0; level &lt; NKronIters; level++) {
189      const int X = NId1 % MtxDim;
190      const int Y = NId2 % MtxDim;
191      const double LVal = At(X, Y);
192      if (X == ThetaX &amp;&amp; Y == ThetaY) {
193        if (ThetaCnt != 0) { DLL += LVal; }
194        ThetaCnt++;
195      } else { DLL += LVal; }
196      LL += LVal;
197      NId1 /= MtxDim;  NId2 /= MtxDim;
198    }
199    return -ThetaCnt*exp(DLL) / (1.0 - exp(LL));
200  }
201  double TKronMtx::GetApxNoEdgeDLL(const int&amp; ParamId, int NId1, int NId2, const int&amp; NKronIters) const {
202    const int&amp; ThetaX = ParamId % GetDim();
203    const int&amp; ThetaY = ParamId / GetDim();
204    int ThetaCnt = 0;
205    double DLL = 0;
206    for (int level = 0; level &lt; NKronIters; level++) {
207      const int X = NId1 % MtxDim;
208      const int Y = NId2 % MtxDim;
209      const double LVal = At(X, Y); IAssert(LVal &gt; NInf);
210      if (X == ThetaX &amp;&amp; Y == ThetaY) {
211        if (ThetaCnt != 0) { DLL += LVal; }
212        ThetaCnt++;
213      } else { DLL += LVal; }
214      NId1 /= MtxDim;  NId2 /= MtxDim;
215    }
216    return -ThetaCnt*exp(DLL) - ThetaCnt*exp(At(ThetaX, ThetaY)+2*DLL);
217  }
218  uint TKronMtx::GetNodeSig(const double&amp; OneProb) {
219    uint Sig = 0;
220    for (int i = 0; i &lt; (int)(8*sizeof(uint)); i++) {
221      if (TKronMtx::Rnd.GetUniDev() &lt; OneProb) {
222        Sig |= (1u&lt;&lt;i); }
223    }
224    return Sig;
225  }
226  double TKronMtx::GetEdgeProb(const uint&amp; NId1Sig, const uint&amp; NId2Sig, const int&amp; NIter) const {
227    Assert(GetDim() == 2);
228    double Prob = 1.0;
229    for (int i = 0; i &lt; NIter; i++) {
230      const uint Mask = (1u&lt;&lt;i);
231      const uint Bit1 = NId1Sig &amp; Mask;
232      const uint Bit2 = NId2Sig &amp; Mask;
233      Prob *= At(int(Bit1!=0), int(Bit2!=0));
234    }
235    return Prob;
236  }
237  PNGraph TKronMtx::GenThreshGraph(const double&amp; Thresh) const {
238    PNGraph Graph = TNGraph::New();
239    for (int i = 0; i &lt; GetDim(); i++) {
240      Graph-&gt;AddNode(i); }
241    for (int r = 0; r &lt; GetDim(); r++) {
242      for (int c = 0; c &lt; GetDim(); c++) {
243        if (At(r, c) &gt;= Thresh) { Graph-&gt;AddEdge(r, c); }
244      }
245    }
246    return Graph;
247  }
248  PNGraph TKronMtx::GenRndGraph(const double&amp; RndFact) const {
249    PNGraph Graph = TNGraph::New();
250    for (int i = 0; i &lt; GetDim(); i++) {
251      Graph-&gt;AddNode(i); }
252    for (int r = 0; r &lt; GetDim(); r++) {
253      for (int c = 0; c &lt; GetDim(); c++) {
254        if (RndFact * At(r, c) &gt;= TKronMtx::Rnd.GetUniDev()) { Graph-&gt;AddEdge(r, c); }
255      }
256    }
257    return Graph;
258  }
259  int TKronMtx::GetKronIter(const int&amp; GNodes, const int&amp; SeedMtxSz) {
260    return (int) ceil(log(double(GNodes)) / log(double(SeedMtxSz)));
261  }
262  PNGraph TKronMtx::GenKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir, const int&amp; Seed) {
263    const TKronMtx&amp; SeedGraph = SeedMtx;
264    const int NNodes = SeedGraph.GetNodes(NIter);
265    printf(&quot;  Kronecker: %d nodes, %s...\n&quot;, NNodes, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
266    PNGraph Graph = TNGraph::New(NNodes, -1);
267    TExeTm ExeTm;
268    TRnd Rnd(Seed);
269    int edges = 0;
270    for (int node1 = 0; node1 &lt; NNodes; node1++) {
271      Graph-&gt;AddNode(node1); }
272    if (IsDir) {
273      for (int node1 = 0; node1 &lt; NNodes; node1++) {
274        for (int node2 = 0; node2 &lt; NNodes; node2++) {
275          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
276            Graph-&gt;AddEdge(node1, node2);
277            edges++;
278          }
279        }
280        if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
281      }
282    } else {
283      for (int node1 = 0; node1 &lt; NNodes; node1++) {
284        for (int node2 = node1; node2 &lt; NNodes; node2++) {
285          if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
286            Graph-&gt;AddEdge(node1, node2);
287            Graph-&gt;AddEdge(node2, node1);
288            edges++;
289          }
290        }
291        if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
292      }
293    }
294    printf(&quot;\r             %d edges [%s]\n&quot;, Graph-&gt;GetEdges(), ExeTm.GetTmStr());
295    return Graph;
296  }
297  PNGraph TKronMtx::GenFastKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir, const int&amp; Seed) {
298    const TKronMtx&amp; SeedGraph = SeedMtx;
299    const int MtxDim = SeedGraph.GetDim();
300    const double MtxSum = SeedGraph.GetMtxSum();
301    const int NNodes = SeedGraph.GetNodes(NIter);
302    const int NEdges = SeedGraph.GetEdges(NIter);
303    printf(&quot;  FastKronecker: %d nodes, %d edges, %s...\n&quot;, NNodes, NEdges, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
304    PNGraph Graph = TNGraph::New(NNodes, -1);
305    TRnd Rnd(Seed);
306    TExeTm ExeTm;
307    TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
308    double CumProb = 0.0;
309    for (int r = 0; r &lt; MtxDim; r++) {
310      for (int c = 0; c &lt; MtxDim; c++) {
311        const double Prob = SeedGraph.At(r, c);
312        if (Prob &gt; 0.0) {
313          CumProb += Prob;
314          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
315        }
316      }
317    }
318    for (int i = 0; i &lt; NNodes; i++) {
319      Graph-&gt;AddNode(i); }
320    int Rng, Row, Col, Collision=0, n = 0;
321    for (int edges = 0; edges &lt; NEdges; ) {
322      Rng=NNodes;  Row=0;  Col=0;
323      for (int iter = 0; iter &lt; NIter; iter++) {
324        const double&amp; Prob = Rnd.GetUniDev();
325        n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
326        const int MtxRow = ProbToRCPosV[n].Val2;
327        const int MtxCol = ProbToRCPosV[n].Val3;
328        Rng /= MtxDim;
329        Row += MtxRow * Rng;
330        Col += MtxCol * Rng;
331      }
332      if (! Graph-&gt;IsEdge(Row, Col)) { 
333        Graph-&gt;AddEdge(Row, Col);  edges++;
334        if (! IsDir) {
335          if (Row != Col) Graph-&gt;AddEdge(Col, Row);
336          edges++;
337        }
338      } else { Collision++; }
339    }
340    printf(&quot;             collisions: %d (%.4f)\n&quot;, Collision, Collision/(double)Graph-&gt;GetEdges());
341    return Graph;
342  }
343  PNGraph TKronMtx::GenFastKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const int&amp; Edges, const bool&amp; IsDir, const int&amp; Seed) {
344    const TKronMtx&amp; SeedGraph = SeedMtx;
345    const int MtxDim = SeedGraph.GetDim();
346    const double MtxSum = SeedGraph.GetMtxSum();
347    const int NNodes = SeedGraph.GetNodes(NIter);
348    const int NEdges = Edges;
349    printf(&quot;  RMat Kronecker: %d nodes, %d edges, %s...\n&quot;, NNodes, NEdges, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
350    PNGraph Graph = TNGraph::New(NNodes, -1);
351    TRnd Rnd(Seed);
352    TExeTm ExeTm;
353    TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
354    double CumProb = 0.0;
355    for (int r = 0; r &lt; MtxDim; r++) {
356      for (int c = 0; c &lt; MtxDim; c++) {
357        const double Prob = SeedGraph.At(r, c);
358        if (Prob &gt; 0.0) {
359          CumProb += Prob;
360          ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
361        }
362      }
363    }
364    for (int i = 0; i &lt; NNodes; i++) {
365      Graph-&gt;AddNode(i); }
366    int Rng, Row, Col, Collision=0, n = 0;
367    for (int edges = 0; edges &lt; NEdges; ) {
368      Rng=NNodes;  Row=0;  Col=0;
369      for (int iter = 0; iter &lt; NIter; iter++) {
370        const double&amp; Prob = Rnd.GetUniDev();
371        n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
372        const int MtxRow = ProbToRCPosV[n].Val2;
373        const int MtxCol = ProbToRCPosV[n].Val3;
374        Rng /= MtxDim;
375        Row += MtxRow * Rng;
376        Col += MtxCol * Rng;
377      }
378      if (! Graph-&gt;IsEdge(Row, Col)) { 
379        Graph-&gt;AddEdge(Row, Col);  edges++;
380        if (! IsDir) {
381          if (Row != Col) Graph-&gt;AddEdge(Col, Row);
382          edges++;
383        }
384      } else { Collision++; }
385    }
386    printf(&quot;             collisions: %d (%.4f)\n&quot;, Collision, Collision/(double)Graph-&gt;GetEdges());
387    return Graph;
388  }
389  PNGraph TKronMtx::GenDetKronecker(const TKronMtx&amp; SeedMtx, const int&amp; NIter, const bool&amp; IsDir) {
390    const TKronMtx&amp; SeedGraph = SeedMtx;
391    const int NNodes = SeedGraph.GetNodes(NIter);
392    printf(&quot;  Deterministic Kronecker: %d nodes, %s...\n&quot;, NNodes, IsDir ? &quot;Directed&quot;:&quot;UnDirected&quot;);
393    PNGraph Graph = TNGraph::New(NNodes, -1);
394    TExeTm ExeTm;
395    int edges = 0;
396    for (int node1 = 0; node1 &lt; NNodes; node1++) { Graph-&gt;AddNode(node1); }
397    for (int node1 = 0; node1 &lt; NNodes; node1++) {
398      for (int node2 = 0; node2 &lt; NNodes; node2++) {
399        if (SeedGraph.IsEdgePlace(node1, node2, NIter, Rnd.GetUniDev())) {
400          Graph-&gt;AddEdge(node1, node2);
401          edges++;
402        }
403      }
404      if (node1 % 1000 == 0) printf(&quot;\r...%dk, %dk&quot;, node1/1000, edges/1000);
405    }
406    return Graph;
407  }
408  void TKronMtx::PlotCmpGraphs(const TKronMtx&amp; SeedMtx, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
409    const int KronIters = SeedMtx.GetKronIter(Graph-&gt;GetNodes());
410    PNGraph KronG, WccG;
411    const bool FastGen = true;
412    if (FastGen) { KronG = TKronMtx::GenFastKronecker(SeedMtx, KronIters, true, 0); }
413    else { KronG = TKronMtx::GenKronecker(SeedMtx, KronIters, true, 0); }
414    TSnap::DelZeroDegNodes(KronG);
415    WccG = TSnap::GetMxWcc(KronG);
416    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
417    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdScc | gsdClustCf | gsdSngVec | gsdSngVal);
418    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
419    GS.Add(KronG, TSecTm(2), TStr::Fmt(&quot;KRONECKER  K(%d, %d)&quot;, KronG-&gt;GetNodes(), KronG-&gt;GetEdges()));
420    GS.Add(WccG, TSecTm(3),  TStr::Fmt(&quot;KRONECKER  wccK(%d, %d)&quot;, WccG-&gt;GetNodes(), WccG-&gt;GetEdges()));
421    const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
422    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
423    GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
424    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
425    GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
426    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
427    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
428    GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
429    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
430    GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
431    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
432    GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
433    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
434    GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
435    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
436    GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
437  }
438  void TKronMtx::PlotCmpGraphs(const TKronMtx&amp; SeedMtx1, const TKronMtx&amp; SeedMtx2, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
439    const int KronIters1 = SeedMtx1.GetKronIter(Graph-&gt;GetNodes());
440    const int KronIters2 = SeedMtx2.GetKronIter(Graph-&gt;GetNodes());
441    PNGraph KronG1, KronG2;
442    const bool FastGen = true;
443    if (FastGen) {
444      KronG1 = TKronMtx::GenFastKronecker(SeedMtx1, KronIters1, true, 0);
445      KronG2 = TKronMtx::GenFastKronecker(SeedMtx2, KronIters2, false, 0); } 
446    else {
447      KronG1 = TKronMtx::GenKronecker(SeedMtx1, KronIters1, true, 0);
448      KronG2 = TKronMtx::GenKronecker(SeedMtx2, KronIters2, true, 0);  }
449    TSnap::DelZeroDegNodes(KronG1);
450    TSnap::DelZeroDegNodes(KronG2);
451    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
452    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
453    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
454    GS.Add(KronG1, TSecTm(2), TStr::Fmt(&quot;KRONECKER1  K(%d, %d) %s&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtx1.GetMtxStr().CStr()));
455    GS.Add(KronG2, TSecTm(3),  TStr::Fmt(&quot;KRONECKER2  K(%d, %d) %s&quot;, KronG2-&gt;GetNodes(), KronG2-&gt;GetEdges(), SeedMtx2.GetMtxStr().CStr()));
456    const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
457    GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
458    GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
459    GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
460    GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
461    GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
462    GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
463    GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
464    GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
465    GS.ImposeDistr(gsdTriadPart, FNmPref, Desc1, false, false, gpwLinesPoints, Style);
466    GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
467    GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
468    GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
469    GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
470    GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
471    GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
472    GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
473    GS.ImposeDistr(gsdTriadPart, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLinesPoints, Style);
474  }
475  void TKronMtx::PlotCmpGraphs(const TVec&lt;TKronMtx&gt;&amp; SeedMtxV, const PNGraph&amp; Graph, const TStr&amp; FNmPref, const TStr&amp; Desc) {
476    const TStr Desc1 = TStr::Fmt(&quot;%s&quot;, Desc.CStr());
477    TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdScc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal);
478    GS.Add(Graph, TSecTm(1), TStr::Fmt(&quot;GRAPH  G(%d, %d)&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()));
479    for (int m = 0; m &lt; SeedMtxV.Len(); m++) {
480      const int KronIters = SeedMtxV[m].GetKronIter(Graph-&gt;GetNodes());
481      PNGraph KronG1 = TKronMtx::GenFastKronecker(SeedMtxV[m], KronIters, true, 0);
482      printf(&quot;*** K(%d, %d) n0=%d\n&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtxV[m].GetDim());
483      TSnap::DelZeroDegNodes(KronG1);
484      printf(&quot; del zero deg K(%d, %d) n0=%d\n&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), m);
485      GS.Add(KronG1, TSecTm(m+2), TStr::Fmt(&quot;K(%d, %d) n0^k=%d n0=%d&quot;, KronG1-&gt;GetNodes(), KronG1-&gt;GetEdges(), SeedMtxV[m].GetNZeroK(Graph), SeedMtxV[m].GetDim()));
486      const TStr Style = &quot;linewidth 1 pointtype 6 pointsize 1&quot;;
487      GS.ImposeDistr(gsdInDeg, FNmPref, Desc1, false, false, gpwLines, Style);
488      GS.ImposeDistr(gsdInDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
489      GS.ImposeDistr(gsdOutDeg, FNmPref, Desc1, false, false, gpwLines, Style);
490      GS.ImposeDistr(gsdOutDeg, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
491      GS.ImposeDistr(gsdHops, FNmPref, Desc1, false, false, gpwLines, Style);
492      GS.ImposeDistr(gsdClustCf, FNmPref, Desc1, false, false, gpwLines, Style);
493      GS.ImposeDistr(gsdClustCf, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
494      GS.ImposeDistr(gsdSngVal, FNmPref, Desc1, false, false, gpwLines, Style);
495      GS.ImposeDistr(gsdSngVal, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
496      GS.ImposeDistr(gsdSngVec, FNmPref, Desc1, false, false, gpwLines, Style);
497      GS.ImposeDistr(gsdSngVec, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
498      GS.ImposeDistr(gsdWcc, FNmPref, Desc1, false, false, gpwLines, Style);
499      GS.ImposeDistr(gsdWcc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
500      GS.ImposeDistr(gsdScc, FNmPref, Desc1, false, false, gpwLines, Style);
501      GS.ImposeDistr(gsdScc, FNmPref+&quot;-B&quot;, Desc1, true, false, gpwLines, Style);
502    }
503  }
504  void TKronMtx::KronMul(const TKronMtx&amp; Left, const TKronMtx&amp; Right, TKronMtx&amp; Result) {
505    const int LDim = Left.GetDim();
506    const int RDim = Right.GetDim();
507    Result.GenMtx(LDim * RDim);
508    for (int r1 = 0; r1 &lt; LDim; r1++) {
509      for (int c1 = 0; c1 &lt; LDim; c1++) {
510        const double&amp; Val = Left.At(r1, c1);
511        for (int r2 = 0; r2 &lt; RDim; r2++) {
512          for (int c2 = 0; c2 &lt; RDim; c2++) {
513            Result.At(r1*RDim+r2, c1*RDim+c2) = Val * Right.At(r2, c2);
514          }
515        }
516      }
517    }
518  }
519  void TKronMtx::KronSum(const TKronMtx&amp; Left, const TKronMtx&amp; Right, TKronMtx&amp; Result) {
520    const int LDim = Left.GetDim();
521    const int RDim = Right.GetDim();
522    Result.GenMtx(LDim * RDim);
523    for (int r1 = 0; r1 &lt; LDim; r1++) {
524      for (int c1 = 0; c1 &lt; LDim; c1++) {
525        const double&amp; Val = Left.At(r1, c1);
526        for (int r2 = 0; r2 &lt; RDim; r2++) {
527          for (int c2 = 0; c2 &lt; RDim; c2++) {
528            if (Val == NInf || Right.At(r2, c2) == NInf) {
529              Result.At(r1*RDim+r2, c1*RDim+c2) = NInf; }
530            else {
531              Result.At(r1*RDim+r2, c1*RDim+c2) = Val + Right.At(r2, c2); }
532          }
533        }
534      }
535    }
536  }
537  void TKronMtx::KronPwr(const TKronMtx&amp; KronMtx, const int&amp; NIter, TKronMtx&amp; OutMtx) {
538    OutMtx = KronMtx;
539    TKronMtx NewOutMtx;
540    for (int iter = 0; iter &lt; NIter; iter++) {
541      KronMul(OutMtx, KronMtx, NewOutMtx);
542      NewOutMtx.Swap(OutMtx);
543    }
544  }
545  void TKronMtx::Dump(const TStr&amp; MtxNm, const bool&amp; Sort) const {
546    if (! MtxNm.Empty()) printf(&quot;%s\n&quot;, MtxNm.CStr());
547    double Sum=0.0;
548    TFltV ValV = SeedMtx;
549    if (Sort) { ValV.Sort(false); }
550    for (int i = 0; i &lt; ValV.Len(); i++) {
551      printf(&quot;  %10.4g&quot;, ValV[i]());
552      Sum += ValV[i];
553      if ((i+1) % GetDim() == 0) { printf(&quot;\n&quot;); }
554    }
555    printf(&quot; (sum:%.4f)\n&quot;, Sum);
556  }
557  double TKronMtx::GetAvgAbsErr(const TKronMtx&amp; Kron1, const TKronMtx&amp; Kron2) {
558    TFltV P1 = Kron1.GetMtx();
559    TFltV P2 = Kron2.GetMtx();
560    IAssert(P1.Len() == P2.Len());
561    P1.Sort();  P2.Sort();
562    double delta = 0.0;
563    for (int i = 0; i &lt; P1.Len(); i++) {
564      delta += fabs(P1[i] - P2[i]);
565    }
566    return delta/P1.Len();
567  }
568  double TKronMtx::GetAvgFroErr(const TKronMtx&amp; Kron1, const TKronMtx&amp; Kron2) {
569    TFltV P1 = Kron1.GetMtx();
570    TFltV P2 = Kron2.GetMtx();
571    IAssert(P1.Len() == P2.Len());
572    P1.Sort();  P2.Sort();
573    double delta = 0.0;
574    for (int i = 0; i &lt; P1.Len(); i++) {
575      delta += pow(P1[i] - P2[i], 2);
576    }
577    return sqrt(delta/P1.Len());
578  }
579  TKronMtx TKronMtx::GetMtx(TStr MatlabMtxStr) {
580    TStrV RowStrV, ColStrV;
581    MatlabMtxStr.ChangeChAll(&#x27;,&#x27;, &#x27; &#x27;);
582    MatlabMtxStr.SplitOnAllCh(&#x27;;&#x27;, RowStrV);  IAssert(! RowStrV.Empty());
583    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
584    const int Rows = RowStrV.Len();
585    const int Cols = ColStrV.Len();
586    IAssert(Rows == Cols);
587    TKronMtx Mtx(Rows);
588    for (int r = 0; r &lt; Rows; r++) {
589      RowStrV[r].SplitOnWs(ColStrV);
590      IAssert(ColStrV.Len() == Cols);
591      for (int c = 0; c &lt; Cols; c++) {
592        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
593    }
594    return Mtx;
595  }
596  TKronMtx TKronMtx::GetRndMtx(const int&amp; Dim, const double&amp; MinProb) {
597    TKronMtx Mtx;
598    Mtx.SetRndMtx(Dim, MinProb);
599    return Mtx;
600  }
601  TKronMtx TKronMtx::GetInitMtx(const int&amp; Dim, const int&amp; Nodes, const int&amp; Edges) {
602    const double MxParam = 0.8+TKronMtx::Rnd.GetUniDev()/5.0;
603    const double MnParam = 0.2-TKronMtx::Rnd.GetUniDev()/5.0;
604    const double Step = (MxParam-MnParam) / (Dim*Dim-1);
605    TFltV ParamV(Dim*Dim);
606    if (Dim == 1) { ParamV.PutAll(0.5); } 
607    else {
608      for (int p = 0; p &lt; ParamV.Len(); p++) {
609        ParamV[p] = MxParam - p*Step; }
610    }
611    TKronMtx Mtx(ParamV);
612    Mtx.SetForEdges(Nodes, Edges);
613    return Mtx;
614  }
615  TKronMtx TKronMtx::GetInitMtx(const TStr&amp; MtxStr, const int&amp; Dim, const int&amp; Nodes, const int&amp; Edges) {
616    TKronMtx Mtx(Dim);
617    if (TCh::IsNum(MtxStr[0])) { Mtx = TKronMtx::GetMtx(MtxStr); }
618    else if (MtxStr[0] == &#x27;r&#x27;) { Mtx = TKronMtx::GetRndMtx(Dim, 0.1); }
619    else if (MtxStr[0] == &#x27;a&#x27;) {
620      const double Prob = TKronMtx::Rnd.GetUniDev();
621      if (Prob &lt; 0.4) {
622        Mtx = TKronMtx::GetInitMtx(Dim, Nodes, Edges); }
623      else { 
624        const double Max = 0.9+TKronMtx::Rnd.GetUniDev()/10.0;
625        const double Min = 0.1-TKronMtx::Rnd.GetUniDev()/10.0;
626        const double Med = (Max-Min)/2.0;
627        Mtx.At(0,0)      = Max;       Mtx.At(0,Dim-1) = Med;
628        Mtx.At(Dim-1, 0) = Med;  Mtx.At(Dim-1, Dim-1) = Min;
629        for (int i = 1; i &lt; Dim-1; i++) {
630          Mtx.At(i,i) = Max - double(i)*(Max-Min)/double(Dim-1);
631          Mtx.At(i, 0) = Mtx.At(0, i) = Max - double(i)*(Max-Med)/double(Dim-1);
632          Mtx.At(i, Dim-1) = Mtx.At(Dim-1, i) = Med - double(i)*(Med-Min)/double(Dim-1);
633        }
634        for (int i = 1; i &lt; Dim-1; i++) {
635          for (int j = 1; j &lt; Dim-1; j++) {
636            if (i &gt;= j) { continue; }
637            Mtx.At(i,j) = Mtx.At(j,i) = Mtx.At(i,i) - (j-i)*(Mtx.At(i,i)-Mtx.At(i,Dim-1))/(Dim-i-1);
638          }
639        }
640        Mtx.AddRndNoise(0.1);
641      }
642    } else { FailR(&quot;Wrong mtx: matlab str, or random (r), or all (a)&quot;); }
643    Mtx.SetForEdges(Nodes, Edges);
644    return Mtx;
645  }
646  TKronMtx TKronMtx::GetMtxFromNm(const TStr&amp; MtxNm) {
647    if (MtxNm == &quot;3chain&quot;) return TKronMtx::GetMtx(&quot;1 1 0; 1 1 1; 0 1 1&quot;);
648    else if (MtxNm == &quot;4star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1; 1 1 0 0 ; 1 0 1 0; 1 0 0 1&quot;);
649    else if (MtxNm == &quot;4chain&quot;) return TKronMtx::GetMtx(&quot;1 1 0 0; 1 1 1 0 ; 0 1 1 1; 0 0 1 1&quot;);
650    else if (MtxNm == &quot;4square&quot;) return TKronMtx::GetMtx(&quot;1 1 0 1; 1 1 1 0 ; 0 1 1 1; 1 0 1 1&quot;);
651    else if (MtxNm == &quot;5star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 0; 1 0 0 0 1&quot;);
652    else if (MtxNm == &quot;6star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1 1; 1 1 0 0 0 0; 1 0 1 0 0 0; 1 0 0 1 0 0; 1 0 0 0 1 0; 1 0 0 0 0 1&quot;);
653    else if (MtxNm == &quot;7star&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 1 1 1; 1 1 0 0 0 0 0; 1 0 1 0 0 0 0; 1 0 0 1 0 0 0; 1 0 0 0 1 0 0; 1 0 0 0 0 1 0; 1 0 0 0 0 0 1&quot;);
654    else if (MtxNm == &quot;5burst&quot;) return TKronMtx::GetMtx(&quot;1 1 1 1 0; 1 1 0 0 0; 1 0 1 0 0; 1 0 0 1 1; 0 0 0 1 1&quot;);
655    else if (MtxNm == &quot;7burst&quot;) return TKronMtx::GetMtx(&quot;1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 1; 0 0 0 0 1 1 0; 0 0 0 0 1 0 1&quot;);
656    else if (MtxNm == &quot;7cross&quot;) return TKronMtx::GetMtx(&quot;1 0 0 1 0 0 0; 0 1 0 1 0 0 0; 0 0 1 1 0 0 0; 1 1 1 1 1 0 0; 0 0 0 1 1 1 0; 0 0 0 0 1 1 1; 0 0 0 0 0 1 1&quot;);
657    FailR(TStr::Fmt(&quot;Unknow matrix: &#x27;%s&#x27;&quot;, MtxNm.CStr()).CStr());
658    return TKronMtx();
659  }
660  TKronMtx TKronMtx::LoadTxt(const TStr&amp; MtxFNm) {
661    PSs Ss = TSs::LoadTxt(ssfTabSep, MtxFNm);
662    IAssertR(Ss-&gt;GetXLen() == Ss-&gt;GetYLen(), &quot;Not a square matrix&quot;);
663    IAssert(Ss-&gt;GetYLen() == Ss-&gt;GetXLen());
664    TKronMtx Mtx(Ss-&gt;GetYLen());
665    for (int r = 0; r &lt; Ss-&gt;GetYLen(); r++) {
666      for (int c = 0; c &lt; Ss-&gt;GetXLen(); c++) {
667        Mtx.At(r, c) = (double) Ss-&gt;At(c, r).GetFlt(); }
668    }
669    return Mtx;
670  }
671  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TFltV&amp; ParamV, const double&amp; PermPSwapNd): PermSwapNodeProb(PermPSwapNd) {
672    InitLL(GraphPt, TKronMtx(ParamV));
673  }
674  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const double&amp; PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
675    InitLL(GraphPt, ParamMtx);
676  }
677  TKroneckerLL::TKroneckerLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const TIntV&amp; NodeIdPermV, const double&amp; PermPSwapNd) : PermSwapNodeProb(PermPSwapNd) {
678    InitLL(GraphPt, ParamMtx);
679    NodePerm = NodeIdPermV;
680    SetIPerm(NodePerm);
681  }
682  PKroneckerLL TKroneckerLL::New(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const double&amp; PermPSwapNd) {
683    return new TKroneckerLL(GraphPt, ParamMtx, PermPSwapNd);
684  }
685  PKroneckerLL TKroneckerLL::New(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx, const TIntV&amp; NodeIdPermV, const double&amp; PermPSwapNd) {
686    return new TKroneckerLL(GraphPt, ParamMtx, NodeIdPermV, PermPSwapNd);
687  }
688  void TKroneckerLL::SetPerm(const char&amp; PermId) {
689    if (PermId == &#x27;o&#x27;) { SetOrderPerm(); }
690    else if (PermId == &#x27;d&#x27;) { SetDegPerm(); }
691    else if (PermId == &#x27;r&#x27;) { SetRndPerm(); }
692    else if (PermId == &#x27;b&#x27;) { SetBestDegPerm(); }
693    else FailR(&quot;Unknown permutation type (o,d,r)&quot;);
694  }
695  void TKroneckerLL::SetOrderPerm() {
696    NodePerm.Gen(Nodes, 0);
697    for (int i = 0; i &lt; Graph-&gt;GetNodes(); i++) {
698      NodePerm.Add(i); }
699    SetIPerm(NodePerm);
700  }
701  void TKroneckerLL::SetRndPerm() {
702    NodePerm.Gen(Nodes, 0);
703    for (int i = 0; i &lt; Graph-&gt;GetNodes(); i++) {
704      NodePerm.Add(i); }
705    NodePerm.Shuffle(TKronMtx::Rnd);
706    SetIPerm(NodePerm);
707  }
708  void TKroneckerLL::SetDegPerm() {
709    TIntPrV DegNIdV;
710    for (TNGraph::TNodeI NI = Graph-&gt;BegNI(); NI &lt; Graph-&gt;EndNI(); NI++) {
711      DegNIdV.Add(TIntPr(NI.GetDeg(), NI.GetId()));
712    }
713    DegNIdV.Sort(false);
714    NodePerm.Gen(DegNIdV.Len(), 0);
715    for (int i = 0; i &lt; DegNIdV.Len(); i++) {
716      NodePerm.Add(DegNIdV[i].Val2);
717    }
718    SetIPerm(NodePerm);
719  }
720  void TKroneckerLL::SetBestDegPerm() {
721    NodePerm.Gen(Nodes);
722    const int NZero = ProbMtx.GetDim();
723    TFltIntPrV DegV(Nodes), CDegV(Nodes);
724    TFltV Row(NZero);
725    TFltV Col(NZero);
726    for(int i = 0; i &lt; NZero; i++) {
727  	  for(int j = 0; j &lt; NZero; j++) {
728  		  Row[i] += ProbMtx.At(i, j);
729  		  Col[i] += ProbMtx.At(j, i);
730  	  }
731    }
732    for(int i = 0; i &lt; Nodes; i++) {
733  	  TNGraph::TNodeI NodeI = Graph-&gt;GetNI(i);
734  	  int NId = i;
735  	  double RowP = 1.0, ColP = 1.0;
736  	  for(int j = 0; j &lt; KronIters; j++) {
737  		  int Bit = NId % NZero;
738  		  RowP *= Row[Bit];		ColP *= Col[Bit];
739  		  NId /= NZero;
740  	  }
741  	  CDegV[i] = TFltIntPr(RowP + ColP, i);
742  	  DegV[i] = TFltIntPr(NodeI.GetDeg(), i);
743    }
744    DegV.Sort(false);		CDegV.Sort(false);
745    for(int i = 0; i &lt; Nodes; i++) {
746  	  NodePerm[DegV[i].Val2] = CDegV[i].Val2;
747    }
748    SetIPerm(NodePerm);
749  }
750  void TKroneckerLL::SetIPerm(const TIntV&amp; Perm) {
751  	InvertPerm.Gen(Perm.Len());
752  	for (int i = 0; i &lt; Perm.Len(); i++) {
753  		InvertPerm[Perm[i]] = i;
754  	}
755  }
756  void TKroneckerLL::SetGraph(const PNGraph&amp; GraphPt) {
757    Graph = GraphPt;
758    bool NodesOk = true;
759    for (int nid = 0; nid &lt; Graph-&gt;GetNodes(); nid++) {
760      if (! Graph-&gt;IsNode(nid)) { NodesOk=false; break; } }
761    if (! NodesOk) {
762      TIntV NIdV;  GraphPt-&gt;GetNIdV(NIdV);
763      Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
764      for (int nid = 0; nid &lt; Graph-&gt;GetNodes(); nid++) {
765        IAssert(Graph-&gt;IsNode(nid)); }
766    }
767    Nodes = Graph-&gt;GetNodes();
768    IAssert(LLMtx.GetDim() &gt; 1 &amp;&amp; LLMtx.Len() == ProbMtx.Len());
769    KronIters = (int) ceil(log(double(Nodes)) / log(double(ProbMtx.GetDim())));
770      GEdgeV.Gen(Graph-&gt;GetEdges(), 0);
771      for (TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
772        if (EI.GetSrcNId() != EI.GetDstNId()) {
773          GEdgeV.Add(TIntTr(EI.GetSrcNId(), EI.GetDstNId(), -1));
774        }
775      }
776    RealNodes = Nodes;
777    RealEdges = Graph-&gt;GetEdges();
778    LEdgeV = TIntTrV();
779    LSelfEdge = 0;
780  }
781  void TKroneckerLL::AppendIsoNodes() {
782    Nodes = (int) pow((double)ProbMtx.GetDim(), KronIters);
783    for (int nid = Graph-&gt;GetNodes(); nid &lt; Nodes; nid++) {
784  	  Graph-&gt;AddNode(nid);
785    }
786  }
787  void TKroneckerLL::RestoreGraph(const bool RestoreNodes) {
788  	int NId1, NId2;
789  	for (int e = 0; e &lt; LEdgeV.Len(); e++) {
790      	NId1 = LEdgeV[e].Val1;  NId2 = LEdgeV[e].Val2;
791  		Graph-&gt;DelEdge(NId1, NId2);
792  	}
793  	if(LEdgeV.Len() - LSelfEdge)
794  		GEdgeV.Del(GEdgeV.Len() - LEdgeV.Len() + LSelfEdge, GEdgeV.Len() - 1);
795  	LEdgeV.Clr();
796  	LSelfEdge = 0;
797  	if(RestoreNodes) {
798  		for(int i = Graph-&gt;GetNodes()-1; i &gt;= RealNodes; i--) {
799  			Graph-&gt;DelNode(i);
800  		}
801  	}
802  }
803  double TKroneckerLL::GetFullGraphLL() const {
804    double ElemCnt = 1;
805    const double dim = LLMtx.GetDim();
806    for (int i = 1; i &lt; KronIters; i++) {
807      ElemCnt = dim*dim*ElemCnt + TMath::Power(dim, 2*i);
808    }
809    return ElemCnt * LLMtx.GetMtxSum();
810  }
811  double TKroneckerLL::GetFullRowLL(int RowId) const {
812    double RowLL = 0.0;
813    const int MtxDim = LLMtx.GetDim();
814    for (int level = 0; level &lt; KronIters; level++) {
815      RowLL += LLMtx.GetRowSum(RowId % MtxDim);
816      RowId /= MtxDim;
817    }
818    return RowLL;
819  }
820  double TKroneckerLL::GetFullColLL(int ColId) const {
821    double ColLL = 0.0;
822    const int MtxDim = LLMtx.GetDim();
823    for (int level = 0; level &lt; KronIters; level++) {
824      ColLL += LLMtx.GetColSum(ColId % MtxDim);
825      ColId /= MtxDim;
826    }
827    return ColLL;
828  }
829  double TKroneckerLL::GetEmptyGraphLL() const {
830    double LL = 0;
831    for (int NId1 = 0; NId1 &lt; LLMtx.GetNodes(KronIters); NId1++) {
832      for (int NId2 = 0; NId2 &lt; LLMtx.GetNodes(KronIters); NId2++) {
833        LL = LL + LLMtx.GetNoEdgeLL(NId1, NId2, KronIters);
834      }
835    }
836    return LL;
837  }
838  double TKroneckerLL::GetApxEmptyGraphLL() const {
839    double Sum=0.0, SumSq=0.0;
840    for (int i = 0; i &lt; ProbMtx.Len(); i++) {
841      Sum += ProbMtx.At(i);
842      SumSq += TMath::Sqr(ProbMtx.At(i));
843    }
844    return -pow(Sum, KronIters) - 0.5*pow(SumSq, KronIters);
845  }
846  void TKroneckerLL::InitLL(const TFltV&amp; ParamV) {
847    InitLL(TKronMtx(ParamV));
848  }
849  void TKroneckerLL::InitLL(const TKronMtx&amp; ParamMtx) {
850    IAssert(ParamMtx.IsProbMtx());
851    ProbMtx = ParamMtx;
852    ProbMtx.GetLLMtx(LLMtx);
853    LogLike = TKronMtx::NInf;
854    if (GradV.Len() != ProbMtx.Len()) {
855      GradV.Gen(ProbMtx.Len()); }
856    GradV.PutAll(0.0);
857  }
858  void TKroneckerLL::InitLL(const PNGraph&amp; GraphPt, const TKronMtx&amp; ParamMtx) {
859    IAssert(ParamMtx.IsProbMtx());
860    ProbMtx = ParamMtx;
861    ProbMtx.GetLLMtx(LLMtx);
862    SetGraph(GraphPt);
863    LogLike = TKronMtx::NInf;
864    if (GradV.Len() != ProbMtx.Len()) {
865      GradV.Gen(ProbMtx.Len()); }
866    GradV.PutAll(0.0);
867  }
868  double TKroneckerLL::CalcGraphLL() {
869    LogLike = GetEmptyGraphLL(); 
870    for (int nid = 0; nid &lt; Nodes; nid++) {
871      const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
872      const int SrcNId = NodePerm[nid];
873      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
874        const int DstNId = NodePerm[Node.GetOutNId(e)];
875        LogLike = LogLike - LLMtx.GetNoEdgeLL(SrcNId, DstNId, KronIters)
876          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
877      }
878    }
879    return LogLike;
880  }
881  double TKroneckerLL::CalcApxGraphLL() {
882    LogLike = GetApxEmptyGraphLL(); 
883    for (int nid = 0; nid &lt; Nodes; nid++) {
884      const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
885      const int SrcNId = NodePerm[nid];
886      for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
887        const int DstNId = NodePerm[Node.GetOutNId(e)];
888        LogLike = LogLike - LLMtx.GetApxNoEdgeLL(SrcNId, DstNId, KronIters)
889          + LLMtx.GetEdgeLL(SrcNId, DstNId, KronIters);
890      }
891    }
892    return LogLike;
893  }
894  double TKroneckerLL::NodeLLDelta(const int&amp; NId) const {
895    if (! Graph-&gt;IsNode(NId)) { return 0.0; } 
896    double Delta = 0.0;
897    const TNGraph::TNodeI Node = Graph-&gt;GetNI(NId);
898    const int SrcRow = NodePerm[NId];
899    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
900      const int DstCol = NodePerm[Node.GetOutNId(e)];
901      Delta += - LLMtx.GetApxNoEdgeLL(SrcRow, DstCol, KronIters)
902        + LLMtx.GetEdgeLL(SrcRow, DstCol, KronIters);
903    }
904    const int SrcCol = NodePerm[NId];
905    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
906      const int DstRow = NodePerm[Node.GetInNId(e)];
907      Delta += - LLMtx.GetApxNoEdgeLL(DstRow, SrcCol, KronIters)
908        + LLMtx.GetEdgeLL(DstRow, SrcCol, KronIters);
909    }
910    if (Graph-&gt;IsEdge(NId, NId)) {
911      Delta += + LLMtx.GetApxNoEdgeLL(SrcRow, SrcCol, KronIters)
912        - LLMtx.GetEdgeLL(SrcRow, SrcCol, KronIters);
913      IAssert(SrcRow == SrcCol);
914    }
915    return Delta;
916  }
917  double TKroneckerLL::SwapNodesLL(const int&amp; NId1, const int&amp; NId2) {
918    LogLike = LogLike - NodeLLDelta(NId1) - NodeLLDelta(NId2);
919    const int PrevId1 = NodePerm[NId1], PrevId2 = NodePerm[NId2];
920    if (Graph-&gt;IsEdge(NId1, NId2)) {
921      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId1, PrevId2, KronIters)
922        + LLMtx.GetEdgeLL(PrevId1, PrevId2, KronIters); }
923    if (Graph-&gt;IsEdge(NId2, NId1)) {
924      LogLike += - LLMtx.GetApxNoEdgeLL(PrevId2, PrevId1, KronIters)
925        + LLMtx.GetEdgeLL(PrevId2, PrevId1, KronIters); }
926    NodePerm.Swap(NId1, NId2);
927    InvertPerm.Swap(NodePerm[NId1], NodePerm[NId2]);
928    LogLike = LogLike + NodeLLDelta(NId1) + NodeLLDelta(NId2);
929    const int NewId1 = NodePerm[NId1], NewId2 = NodePerm[NId2];
930    if (Graph-&gt;IsEdge(NId1, NId2)) {
931      LogLike += + LLMtx.GetApxNoEdgeLL(NewId1, NewId2, KronIters)
932        - LLMtx.GetEdgeLL(NewId1, NewId2, KronIters); }
933    if (Graph-&gt;IsEdge(NId2, NId1)) {
934      LogLike += + LLMtx.GetApxNoEdgeLL(NewId2, NewId1, KronIters)
935        - LLMtx.GetEdgeLL(NewId2, NewId1, KronIters); }
936    return LogLike;
937  }
938  bool TKroneckerLL::SampleNextPerm(int&amp; NId1, int&amp; NId2) {
939    if (TKronMtx::Rnd.GetUniDev() &lt; PermSwapNodeProb) {
940      NId1 = TKronMtx::Rnd.GetUniDevInt(Nodes);
941      NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes);
942      while (NId2 == NId1) { NId2 = TKronMtx::Rnd.GetUniDevInt(Nodes); }
943    } else {
944      const int e = TKronMtx::Rnd.GetUniDevInt(GEdgeV.Len());
945      NId1 = GEdgeV[e].Val1;  NId2 = GEdgeV[e].Val2;
946    }
947    const double U = TKronMtx::Rnd.GetUniDev();
948    const double OldLL = LogLike;
949    const double NewLL = SwapNodesLL(NId1, NId2);
950    const double LogU = log(U);
951    if (LogU &gt; NewLL - OldLL) { 
952      LogLike = OldLL;
953      NodePerm.Swap(NId2, NId1); 
954  	InvertPerm.Swap(NodePerm[NId2], NodePerm[NId1]); 
955      return false;
956    }
957    return true; 
958  }
959  double TKroneckerLL::GetEmptyGraphDLL(const int&amp; ParamId) const {
960    double DLL = 0.0;
961    for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
962      for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
963        DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
964      }
965    }
966    return DLL;
967  }
968  double TKroneckerLL::GetApxEmptyGraphDLL(const int&amp; ParamId) const {
969    double Sum=0.0, SumSq=0.0;
970    for (int i = 0; i &lt; ProbMtx.Len(); i++) {
971      Sum += ProbMtx.At(i);
972      SumSq += TMath::Sqr(ProbMtx.At(i));
973    }
974    return -KronIters*pow(Sum, KronIters-1) - KronIters*pow(SumSq, KronIters-1)*ProbMtx.At(ParamId);
975  }
976  const TFltV&amp; TKroneckerLL::CalcGraphDLL() {
977    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
978      double DLL = 0.0;
979      for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
980        for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
981          if (Graph-&gt;IsEdge(NId1, NId2)) {
982            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
983          } else {
984            DLL += LLMtx.GetNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
985          }
986        }
987      }
988      GradV[ParamId] = DLL;
989    }
990    return GradV;
991  }
992  const TFltV&amp; TKroneckerLL::CalcFullApxGraphDLL() {
993    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
994      double DLL = 0.0;
995      for (int NId1 = 0; NId1 &lt; Nodes; NId1++) {
996        for (int NId2 = 0; NId2 &lt; Nodes; NId2++) {
997          if (Graph-&gt;IsEdge(NId1, NId2)) {
998            DLL += LLMtx.GetEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
999          } else {
1000            DLL += LLMtx.GetApxNoEdgeDLL(ParamId, NodePerm[NId1], NodePerm[NId2], KronIters);
1001          }
1002        }
1003      }
1004      GradV[ParamId] = DLL;
1005    }
1006    return GradV;
1007  }
1008  const TFltV&amp; TKroneckerLL::CalcApxGraphDLL() {
1009    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
1010      double DLL = GetApxEmptyGraphDLL(ParamId);
1011      for (int nid = 0; nid &lt; Nodes; nid++) {
1012        const TNGraph::TNodeI Node = Graph-&gt;GetNI(nid);
1013        const int SrcNId = NodePerm[nid];
1014        for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
1015          const int DstNId = NodePerm[Node.GetOutNId(e)];
1016          DLL = DLL - LLMtx.GetApxNoEdgeDLL(ParamId, SrcNId, DstNId, KronIters)
1017            + LLMtx.GetEdgeDLL(ParamId, SrcNId, DstNId, KronIters);
1018        }
1019      }
1020      GradV[ParamId] = DLL;
1021    }
1022    return GradV;
1023  }
1024  double TKroneckerLL::NodeDLLDelta(const int ParamId, const int&amp; NId) const {
1025    if (! Graph-&gt;IsNode(NId)) { return 0.0; } 
1026    double Delta = 0.0;
1027    const TNGraph::TNodeI Node = Graph-&gt;GetNI(NId);
1028    const int SrcRow = NodePerm[NId];
1029    for (int e = 0; e &lt; Node.GetOutDeg(); e++) {
1030      const int DstCol = NodePerm[Node.GetOutNId(e)];
1031      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, DstCol, KronIters)
1032        + LLMtx.GetEdgeDLL(ParamId, SrcRow, DstCol, KronIters);
1033    }
1034    const int SrcCol = NodePerm[NId];
1035    for (int e = 0; e &lt; Node.GetInDeg(); e++) {
1036      const int DstRow = NodePerm[Node.GetInNId(e)];
1037      Delta += - LLMtx.GetApxNoEdgeDLL(ParamId, DstRow, SrcCol, KronIters)
1038        + LLMtx.GetEdgeDLL(ParamId, DstRow, SrcCol, KronIters);
1039    }
1040    if (Graph-&gt;IsEdge(NId, NId)) {
1041      Delta += + LLMtx.GetApxNoEdgeDLL(ParamId, SrcRow, SrcCol, KronIters)
1042        - LLMtx.GetEdgeDLL(ParamId, SrcRow, SrcCol, KronIters);
1043      IAssert(SrcRow == SrcCol);
1044    }
1045    return Delta;
1046  }
1047  void TKroneckerLL::UpdateGraphDLL(const int&amp; SwapNId1, const int&amp; SwapNId2) {
1048    for (int ParamId = 0; ParamId &lt; LLMtx.Len(); ParamId++) {
1049      NodePerm.Swap(SwapNId1, SwapNId2);
1050      TFlt&amp; DLL = GradV[ParamId];
1051      DLL = DLL - NodeDLLDelta(ParamId, SwapNId1) - NodeDLLDelta(ParamId, SwapNId2);
1052      const int PrevId1 = NodePerm[SwapNId1], PrevId2 = NodePerm[SwapNId2];
1053      if (Graph-&gt;IsEdge(SwapNId1, SwapNId2)) {
1054        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId1, PrevId2, KronIters)
1055          + LLMtx.GetEdgeDLL(ParamId, PrevId1, PrevId2, KronIters); }
1056      if (Graph-&gt;IsEdge(SwapNId2, SwapNId1)) {
1057        DLL += - LLMtx.GetApxNoEdgeDLL(ParamId, PrevId2, PrevId1, KronIters)
1058          + LLMtx.GetEdgeDLL(ParamId, PrevId2, PrevId1, KronIters); }
1059      NodePerm.Swap(SwapNId1, SwapNId2);
1060      DLL = DLL + NodeDLLDelta(ParamId, SwapNId1) + NodeDLLDelta(ParamId, SwapNId2);
1061      const int NewId1 = NodePerm[SwapNId1], NewId2 = NodePerm[SwapNId2];
1062      if (Graph-&gt;IsEdge(SwapNId1, SwapNId2)) {
1063        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId1, NewId2, KronIters)
1064          - LLMtx.GetEdgeDLL(ParamId, NewId1, NewId2, KronIters); }
1065      if (Graph-&gt;IsEdge(SwapNId2, SwapNId1)) {
1066        DLL += + LLMtx.GetApxNoEdgeDLL(ParamId, NewId2, NewId1, KronIters)
1067          - LLMtx.GetEdgeDLL(ParamId, NewId2, NewId1, KronIters); }
1068    }
1069  }
1070  void TKroneckerLL::SampleGradient(const int&amp; WarmUp, const int&amp; NSamples, double&amp; AvgLL, TFltV&amp; AvgGradV) {
1071    printf(&quot;SampleGradient: %s (%s warm-up):&quot;, TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1072    int NId1=0, NId2=0, NAccept=0;
1073    TExeTm ExeTm1;
1074    if (WarmUp &gt; 0) {
1075      CalcApxGraphLL();
1076      for (int s = 0; s &lt; WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1077      printf(&quot;  warm-up:%s,&quot;, ExeTm1.GetTmStr());  ExeTm1.Tick();
1078    }
1079    CalcApxGraphLL(); 
1080    CalcApxGraphDLL();
1081    AvgLL = 0;
1082    AvgGradV.Gen(LLMtx.Len());  AvgGradV.PutAll(0.0);
1083    printf(&quot;  sampl&quot;);
1084    for (int s = 0; s &lt; NSamples; s++) {
1085      if (SampleNextPerm(NId1, NId2)) { 
1086        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1087      for (int m = 0; m &lt; LLMtx.Len(); m++) { AvgGradV[m] += GradV[m]; }
1088      AvgLL += GetLL();
1089    }
1090    printf(&quot;ing&quot;);
1091    AvgLL = AvgLL / double(NSamples);
1092    for (int m = 0; m &lt; LLMtx.Len(); m++) {
1093      AvgGradV[m] = AvgGradV[m] / double(NSamples); }
1094    printf(&quot;:%s (%.0f/s), accept %.1f%%\n&quot;, ExeTm1.GetTmStr(), double(NSamples)/ExeTm1.GetSecs(),
1095      double(100*NAccept)/double(NSamples));
1096  }
1097  double TKroneckerLL::GradDescent(const int&amp; NIter, const double&amp; LrnRate, double MnStep, double MxStep, const int&amp; WarmUp, const int&amp; NSamples) {
1098    printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1099    printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges());
1100    printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1101    TExeTm IterTm, TotalTm;
1102    double OldLL=-1e10, CurLL=0;
1103    const double EZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1104    TFltV CurGradV, LearnRateV(GetParams()), LastStep(GetParams());
1105    LearnRateV.PutAll(LrnRate);
1106    TKronMtx NewProbMtx = ProbMtx;
1107    if(DebugMode) {  
1108  	  LLV.Gen(NIter, 0);
1109  	  MtxV.Gen(NIter, 0);
1110    }
1111    for (int Iter = 0; Iter &lt; NIter; Iter++) {
1112      printf(&quot;%03d] &quot;, Iter);
1113      SampleGradient(WarmUp, NSamples, CurLL, CurGradV);
1114      for (int p = 0; p &lt; GetParams(); p++) {
1115        LearnRateV[p] *= 0.95;
1116        if (Iter &lt; 1) {
1117          while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; }
1118          while (fabs(LearnRateV[p]*CurGradV[p]) &lt; 0.02) { LearnRateV[p] *= (1.0/0.95); } 
1119        } else {
1120          while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1121          while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1122          if (MxStep &gt; 3*MnStep) { MxStep *= 0.95; }
1123        }
1124        NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1125        if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1126        if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1127      }
1128      printf(&quot;  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1129        ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1130      printf(&quot;  currLL: %.4f, deltaLL: %.4f\n&quot;, CurLL, CurLL-OldLL); 
1131      for (int p = 0; p &lt; GetParams(); p++) {
1132        printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1133          ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1134      }
1135      if (Iter+1 &lt; NIter) { 
1136        ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx); }
1137      OldLL=CurLL;
1138      printf(&quot;\n&quot;);  fflush(stdout);
1139  	if(DebugMode) {  
1140  		LLV.Add(CurLL);
1141  		MtxV.Add(NewProbMtx);
1142  	}
1143    }
1144    printf(&quot;TotalExeTm: %s %g\n&quot;, TotalTm.GetStr(), TotalTm.GetSecs());
1145    ProbMtx.Dump(&quot;FITTED PARAMS&quot;, false);
1146    return CurLL;
1147  }
1148  double TKroneckerLL::GradDescent2(const int&amp; NIter, const double&amp; LrnRate, double MnStep, double MxStep, const int&amp; WarmUp, const int&amp; NSamples) {
1149    printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1150    printf(&quot;GradDescent2\n&quot;);
1151    printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges());
1152    printf(&quot;Skip moves that make likelihood smaller\n&quot;);
1153    printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1154    TExeTm IterTm, TotalTm;
1155    double CurLL=0, NewLL=0;
1156    const double EZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1157    TFltV CurGradV, NewGradV, LearnRateV(GetParams()), LastStep(GetParams());
1158    LearnRateV.PutAll(LrnRate);
1159    TKronMtx NewProbMtx=ProbMtx, CurProbMtx=ProbMtx;
1160    bool GoodMove = false;
1161    for (int Iter = 0; Iter &lt; NIter; Iter++) {
1162      printf(&quot;%03d] &quot;, Iter);
1163      if (! GoodMove) { SampleGradient(WarmUp, NSamples, CurLL, CurGradV); }
1164      CurProbMtx = ProbMtx;
1165      for (int p = 0; p &lt; GetParams(); p++) {
1166        while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1167        while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1168        NewProbMtx.At(p) = CurProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1169        if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1170        if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1171        LearnRateV[p] *= 0.95;
1172      }
1173      printf(&quot;  &quot;);
1174      ProbMtx=NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1175      SampleGradient(WarmUp, NSamples, NewLL, NewGradV);
1176      if (NewLL &gt; CurLL) { 
1177        printf(&quot;== Good move:\n&quot;);
1178        printf(&quot;  trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1179          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1180        printf(&quot;  currLL: %.4f  deltaLL: %.4f\n&quot;, CurLL, NewLL-CurLL); 
1181        for (int p = 0; p &lt; GetParams(); p++) {
1182          printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1183            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1184        CurLL = NewLL;
1185        CurGradV = NewGradV;
1186        GoodMove = true;
1187      } else {
1188        printf(&quot;** BAD move:\n&quot;);
1189        printf(&quot;  *trueE0: %.2f (%d),  estE0: %.2f (%d),  ERR: %f\n&quot;, EZero, Graph-&gt;GetEdges(),
1190          ProbMtx.GetMtxSum(), ProbMtx.GetEdges(KronIters), fabs(EZero-ProbMtx.GetMtxSum()));
1191        printf(&quot;  *curLL:  %.4f  deltaLL: %.4f\n&quot;, CurLL, NewLL-CurLL); 
1192        for (int p = 0; p &lt; GetParams(); p++) {
1193          printf(&quot;   b%d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1194            CurProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]()); }
1195        ProbMtx = CurProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1196        GoodMove = false;
1197      }
1198      printf(&quot;\n&quot;);  fflush(stdout);
1199    }
1200    printf(&quot;TotalExeTm: %s %g\n&quot;, TotalTm.GetStr(), TotalTm.GetSecs());
1201    ProbMtx.Dump(&quot;FITTED PARAMS\n&quot;, false);
1202    return CurLL;
1203  }
1204  void TKroneckerLL::SetRandomEdges(const int&amp; NEdges, const bool isDir) {
1205  	int count = 0, added = 0, collision = 0;
1206  	const int MtxDim = ProbMtx.GetDim();
1207  	const double MtxSum = ProbMtx.GetMtxSum();
1208  	TVec&lt;TFltIntIntTr&gt; ProbToRCPosV; 
1209  	double CumProb = 0.0;
1210  	for(int r = 0; r &lt; MtxDim; r++) {
1211  		for(int c = 0; c &lt; MtxDim; c++) {
1212  			const double Prob = ProbMtx.At(r, c);
1213  			if (Prob &gt; 0.0) {
1214  				CumProb += Prob;
1215  				ProbToRCPosV.Add(TFltIntIntTr(CumProb/MtxSum, r, c));
1216  			}
1217  		}
1218  	}
1219  	int Rng, Row, Col, n, NId1, NId2;
1220  	while(added &lt; NEdges) {
1221  		Rng = Nodes;	Row = 0;	Col = 0;
1222  		for (int iter = 0; iter &lt; KronIters; iter++) {
1223  			const double&amp; Prob = TKronMtx::Rnd.GetUniDev();
1224  			n = 0; while(Prob &gt; ProbToRCPosV[n].Val1) { n++; }
1225  			const int MtxRow = ProbToRCPosV[n].Val2;
1226  			const int MtxCol = ProbToRCPosV[n].Val3;
1227  			Rng /= MtxDim;
1228  			Row += MtxRow * Rng;
1229  			Col += MtxCol * Rng;
1230  		}
1231  		count++;
1232  		NId1 = InvertPerm[Row];	NId2 = InvertPerm[Col];
1233  		if(EMType != kronEdgeMiss &amp;&amp; IsObsEdge(NId1, NId2)) {
1234  			continue;
1235  		}
1236  		if (! Graph-&gt;IsEdge(NId1, NId2)) {
1237  			Graph-&gt;AddEdge(NId1, NId2);
1238  			if(NId1 != NId2)	{ GEdgeV.Add(TIntTr(NId1, NId2, LEdgeV.Len())); }
1239  			else { LSelfEdge++; }
1240  			LEdgeV.Add(TIntTr(NId1, NId2, GEdgeV.Len()-1));
1241  			added++;
1242  			if (! isDir) {
1243  				if (NId1 != NId2) {
1244  				   Graph-&gt;AddEdge(NId2, NId1);
1245  				   GEdgeV.Add(TIntTr(NId2, NId1, LEdgeV.Len()));
1246  				   LEdgeV.Add(TIntTr(NId2, NId1, GEdgeV.Len()-1));
1247  				   added++;
1248  				}
1249  			}
1250  		} else { collision ++; }
1251  	}
1252  }
1253  void TKroneckerLL::MetroGibbsSampleSetup(const int&amp; WarmUp) {
1254  	double alpha = log(ProbMtx.GetMtxSum()) / log(double(ProbMtx.GetDim()));
1255  	int NId1 = 0, NId2 = 0;
1256  	int NMissing;
1257  	RestoreGraph(false);
1258  	if(EMType == kronEdgeMiss) {
1259  		CalcApxGraphLL();
1260  		for (int s = 0; s &lt; WarmUp; s++)	SampleNextPerm(NId1, NId2);
1261  	}
1262  	if(EMType == kronFutureLink) {
1263  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) - pow(double(RealNodes), alpha));
1264  	} else if(EMType == kronEdgeMiss) {
1265  		NMissing = MissEdges;
1266  	} else {
1267  		NMissing = (int) (pow(ProbMtx.GetMtxSum(), KronIters) * (1.0 - pow(double(RealNodes) / double(Nodes), 2)));
1268  	}
1269  	NMissing = (NMissing &lt; 1) ? 1 : NMissing;
1270  	SetRandomEdges(NMissing, true);
1271  	CalcApxGraphLL();
1272  	for (int s = 0; s &lt; WarmUp; s++)	SampleNextPerm(NId1, NId2);
1273  }
1274  void TKroneckerLL::MetroGibbsSampleNext(const int&amp; WarmUp, const bool DLLUpdate) {
1275  	int NId1 = 0, NId2 = 0, hit = 0, GId = 0;
1276  	TIntTr EdgeToRemove, NewEdge;
1277  	double RndAccept;
1278  	if(LEdgeV.Len()) {
1279  		for(int i = 0; i &lt; WarmUp; i++) {
1280  			hit = TKronMtx::Rnd.GetUniDevInt(LEdgeV.Len());
1281  			NId1 = LEdgeV[hit].Val1;	NId2 = LEdgeV[hit].Val2;
1282  			GId = LEdgeV[hit].Val3;
1283  			SetRandomEdges(1, true);
1284  			NewEdge = LEdgeV.Last();
1285  			RndAccept = (1.0 - exp(LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters))) / (1.0 - exp(LLMtx.GetEdgeLL(NId1, NId2, KronIters)));
1286  			RndAccept = (RndAccept &gt; 1.0) ? 1.0 : RndAccept;
1287  			if(TKronMtx::Rnd.GetUniDev() &gt; RndAccept) { 
1288  				Graph-&gt;DelEdge(NewEdge.Val1, NewEdge.Val2);
1289  				if(NewEdge.Val1 != NewEdge.Val2) {	GEdgeV.DelLast();	}
1290  				else {	LSelfEdge--;	}
1291  				LEdgeV.DelLast();
1292  			} else {	
1293  				Graph-&gt;DelEdge(NId1, NId2);
1294  				LEdgeV[hit] = LEdgeV.Last();
1295  				LEdgeV.DelLast();
1296  				if(NId1 == NId2) {
1297  					LSelfEdge--;
1298  					if(NewEdge.Val1 != NewEdge.Val2) {
1299  						GEdgeV[GEdgeV.Len()-1].Val3 = hit;
1300  					}
1301  				} else {
1302  					IAssertR(GEdgeV.Last().Val3 &gt;= 0, &quot;Invalid indexing&quot;);
1303  					GEdgeV[GId] = GEdgeV.Last();
1304  					if(NewEdge.Val1 != NewEdge.Val2) {
1305  						GEdgeV[GId].Val3 = hit;
1306  					}
1307  					LEdgeV[GEdgeV[GId].Val3].Val3 = GId;
1308  					GEdgeV.DelLast();
1309  				}
1310        			LogLike += LLMtx.GetApxNoEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeLL(EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1311        			LogLike += -LLMtx.GetApxNoEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeLL(NewEdge.Val1, NewEdge.Val2, KronIters);
1312  				if(DLLUpdate) {
1313    					for (int p = 0; p &lt; LLMtx.Len(); p++) {
1314  						GradV[p] += LLMtx.GetApxNoEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters) - LLMtx.GetEdgeDLL(p, EdgeToRemove.Val1, EdgeToRemove.Val2, KronIters);
1315  						GradV[p] += -LLMtx.GetApxNoEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters) + LLMtx.GetEdgeDLL(p, NewEdge.Val1, NewEdge.Val2, KronIters);
1316  					}
1317  				}
1318  			}
1319  		}
1320  	}
1321  	for (int s = 0; s &lt; WarmUp; s++) {
1322  		if(SampleNextPerm(NId1, NId2)) {
1323  			if(DLLUpdate)	UpdateGraphDLL(NId1, NId2);
1324  		}
1325  	}
1326  }
1327  void TKroneckerLL::RunEStep(const int&amp; GibbsWarmUp, const int&amp; WarmUp, const int&amp; NSamples, TFltV&amp; LLV, TVec&lt;TFltV&gt;&amp; DLLV) {
1328  	TExeTm ExeTm, TotalTm;
1329  	LLV.Gen(NSamples, 0);
1330  	DLLV.Gen(NSamples, 0);
1331  	ExeTm.Tick();
1332  	for(int i = 0; i &lt; 2; i++)	MetroGibbsSampleSetup(WarmUp);
1333  	printf(&quot;  Warm-Up [%u] : %s\n&quot;, WarmUp, ExeTm.GetTmStr());
1334  	CalcApxGraphLL();
1335  	for(int i = 0; i &lt; GibbsWarmUp; i++)	MetroGibbsSampleNext(10, false);
1336  	printf(&quot;  Gibbs Warm-Up [%u] : %s\n&quot;, GibbsWarmUp, ExeTm.GetTmStr());
1337  	ExeTm.Tick();
1338  	CalcApxGraphLL();
1339  	CalcApxGraphDLL();
1340  	for(int i = 0; i &lt; NSamples; i++) {
1341  		MetroGibbsSampleNext(50, false);
1342  		LLV.Add(LogLike);
1343  		DLLV.Add(GradV);
1344  		int OnePercent = (i+1) % (NSamples / 10);
1345  		if(OnePercent == 0) {
1346  			int TenPercent = ((i+1) / (NSamples / 10)) * 10;
1347  			printf(&quot;  %3u%% done : %s\n&quot;, TenPercent, ExeTm.GetTmStr());
1348  		}
1349  	}
1350  }
1351  double TKroneckerLL::RunMStep(const TFltV&amp; LLV, const TVec&lt;TFltV&gt;&amp; DLLV, const int&amp; GradIter, const double&amp; LrnRate, double MnStep, double MxStep) {
1352  	TExeTm IterTm, TotalTm;
1353  	double OldLL=LogLike, CurLL=0;
1354  	const double alpha = log(double(RealEdges)) / log(double(RealNodes));
1355  	const double EZero = pow(double(ProbMtx.GetDim()), alpha);
1356  	TFltV CurGradV(GetParams()), LearnRateV(GetParams()), LastStep(GetParams());
1357  	LearnRateV.PutAll(LrnRate);
1358  	TKronMtx NewProbMtx = ProbMtx;
1359  	const int NSamples = LLV.Len();
1360  	const int ReCalcLen = NSamples / 10;
1361  	for (int s = 0; s &lt; LLV.Len(); s++) {
1362  		CurLL += LLV[s];
1363  		for(int p = 0; p &lt; GetParams(); p++) { CurGradV[p] += DLLV[s][p]; }
1364  	}
1365  	CurLL /= NSamples;
1366  	for(int p = 0; p &lt; GetParams(); p++) { CurGradV[p] /= NSamples; }
1367  	double MaxLL = CurLL;
1368  	TKronMtx MaxProbMtx = ProbMtx;
1369  	TKronMtx OldProbMtx = ProbMtx;
1370  	for (int Iter = 0; Iter &lt; GradIter; Iter++) {
1371  		printf(&quot;    %03d] &quot;, Iter+1);
1372  		IterTm.Tick();
1373  		for (int p = 0; p &lt; GetParams(); p++) {
1374  			if (Iter &lt; 1) {
1375  				while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; }
1376  				while (fabs(LearnRateV[p]*CurGradV[p]) &lt; 5 * MnStep) { LearnRateV[p] *= (1.0/0.95); } 
1377  			} else {
1378  				while (fabs(LearnRateV[p]*CurGradV[p]) &gt; MxStep) { LearnRateV[p] *= 0.95; printf(&quot;.&quot;);}
1379  				while (fabs(LearnRateV[p]*CurGradV[p]) &lt; MnStep) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1380  				if (MxStep &gt; 3*MnStep) { MxStep *= 0.95; }
1381  			}
1382  			NewProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*CurGradV[p];
1383  			if (NewProbMtx.At(p) &gt; 0.9999) { NewProbMtx.At(p)=0.9999; }
1384  			if (NewProbMtx.At(p) &lt; 0.0001) { NewProbMtx.At(p)=0.0001; }
1385  			LearnRateV[p] *= 0.95;
1386  		}
1387  		printf(&quot;  trueE0: %.2f (%u from %u),  estE0: %.2f (%u from %u),  ERR: %f\n&quot;, EZero, RealEdges(), RealNodes(), ProbMtx.GetMtxSum(), Graph-&gt;GetEdges(), Graph-&gt;GetNodes(), fabs(EZero-ProbMtx.GetMtxSum()));
1388  		printf(&quot;      currLL: %.4f, deltaLL: %.4f\n&quot;, CurLL, CurLL-OldLL); 
1389  		for (int p = 0; p &lt; GetParams(); p++) {
1390  			printf(&quot;      %d]  %f  &lt;--  %f + %9f   Grad: %9.1f   Rate: %g\n&quot;, p, NewProbMtx.At(p),
1391  			ProbMtx.At(p), (double)(LearnRateV[p]*CurGradV[p]), CurGradV[p](), LearnRateV[p]());
1392  		}
1393  		OldLL=CurLL;
1394  		if(Iter == GradIter - 1) {
1395  			break;
1396  		}
1397  		CurLL = 0;
1398  		CurGradV.PutAll(0.0);
1399  		TFltV OneDLL;
1400  		CalcApxGraphLL();
1401  		CalcApxGraphDLL();
1402  		for(int s = 0; s &lt; NSamples; s++) {
1403  			ProbMtx = OldProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1404  			MetroGibbsSampleNext(10, true);
1405  			ProbMtx = NewProbMtx;  ProbMtx.GetLLMtx(LLMtx);
1406  			if(s % ReCalcLen == ReCalcLen/2) {
1407  				CurLL += CalcApxGraphLL();
1408  				OneDLL = CalcApxGraphDLL();
1409  			} else {
1410  				CurLL += LogLike;
1411  				OneDLL = GradV;
1412  			}
1413  			for(int p = 0; p &lt; GetParams(); p++) {
1414  				CurGradV[p] += OneDLL[p];
1415  			}
1416  		}
1417  		CurLL /= NSamples;
1418  		if(MaxLL &lt; CurLL) {
1419  			MaxLL = CurLL;	MaxProbMtx = ProbMtx;
1420  		}
1421  		printf(&quot;    Time: %s\n&quot;, IterTm.GetTmStr());
1422  		printf(&quot;\n&quot;);  fflush(stdout);
1423  	}
1424  	ProbMtx = MaxProbMtx;	ProbMtx.GetLLMtx(LLMtx);
1425  	printf(&quot;    FinalLL : %f,   TotalExeTm: %s\n&quot;, MaxLL, TotalTm.GetTmStr());
1426  	ProbMtx.Dump(&quot;    FITTED PARAMS&quot;, false);
1427  	return MaxLL;
1428  }
1429  void TKroneckerLL::RunKronEM(const int&amp; EMIter, const int&amp; GradIter, double LrnRate, double MnStep, double MxStep, const int&amp; GibbsWarmUp, const int&amp; WarmUp, const int&amp; NSamples, const TKronEMType&amp; Type, const int&amp; NMissing) {
1430  	printf(&quot;\n----------------------------------------------------------------------\n&quot;);
1431  	printf(&quot;Fitting graph on %d nodes, %d edges\n&quot;, int(RealNodes), int(RealEdges));
1432  	printf(&quot;Kron iters:  %d (== %d nodes)\n\n&quot;, KronIters(), ProbMtx.GetNodes(KronIters()));
1433  	TFltV LLV(NSamples);
1434  	TVec&lt;TFltV&gt; DLLV(NSamples);
1435  	EMType = Type;
1436  	MissEdges = NMissing;
1437  	AppendIsoNodes();
1438  	SetRndPerm();
1439  	if(DebugMode) {
1440  		LLV.Gen(EMIter, 0);
<span onclick='openModal()' class='match'>1441  		MtxV.Gen(EMIter, 0);
1442  	}
1443  	for(int i = 0; i &lt; EMIter; i++) {
1444  		printf(&quot;\n----------------------------------------------------------------------\n&quot;);
</span>1445  		printf(&quot;%03d EM-iter] E-Step\n&quot;, i+1);
1446  		RunEStep(GibbsWarmUp, WarmUp, NSamples, LLV, DLLV);
1447  		printf(&quot;\n\n&quot;);
1448  		printf(&quot;%03d EM-iter] M-Step\n&quot;, i+1);
1449  		double CurLL = RunMStep(LLV, DLLV, GradIter, LrnRate, MnStep, MxStep);
1450  		printf(&quot;\n\n&quot;);
1451  		if(DebugMode) {
1452  			LLV.Add(CurLL);
1453  			MtxV.Add(ProbMtx);
1454  		}
1455  	}
1456  	RestoreGraph();
1457  }
1458  void GetMinMax(const TFltPrV&amp; XYValV, double&amp; Min, double&amp; Max, const bool&amp; ResetMinMax) {
1459    if (ResetMinMax) { Min = TFlt::Mx;  Max = TFlt::Mn; }
1460    for (int i = 0; i &lt; XYValV.Len(); i++) {
1461      Min = TMath::Mn(Min, XYValV[i].Val2.Val);
1462      Max = TMath::Mx(Max, XYValV[i].Val2.Val);
1463    }
1464  }
1465  void PlotGrad(const TFltPrV&amp; EstLLV, const TFltPrV&amp; TrueLLV, const TVec&lt;TFltPrV&gt;&amp; GradVV, const TFltPrV&amp; AcceptV, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1466    double Min, Max, Min1, Max1;
1467    { TGnuPlot GP(&quot;sLL-&quot;+OutFNm, TStr::Fmt(&quot;Log-likelihood (avg 1k samples). %s&quot;, Desc.CStr()), true);
1468    GP.AddPlot(EstLLV, gpwLines, &quot;Esimated LL&quot;, &quot;linewidth 1&quot;);
1469    if (! TrueLLV.Empty()) { GP.AddPlot(TrueLLV, gpwLines, &quot;TRUE LL&quot;, &quot;linewidth 1&quot;); }
1470    GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Log-likelihood&quot;);
1471    GP.SavePng(); }
1472    { TGnuPlot GP(&quot;sAcc-&quot;+OutFNm, TStr::Fmt(&quot;Pct. accepted rnd moves (over 1k samples). %s&quot;, Desc.CStr()), true);
1473    GP.AddPlot(AcceptV, gpwLines, &quot;Pct accepted swaps&quot;, &quot;linewidth 1&quot;);
1474    GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Pct accept permutation swaps&quot;);
1475    GP.SavePng(); }
1476    TGnuPlot GPAll(&quot;sGradAll-&quot;+OutFNm, TStr::Fmt(&quot;Gradient (avg 1k samples). %s&quot;, Desc.CStr()), true);
1477    GetMinMax(GradVV[0], Min1, Max1, true);
1478    for (int g = 0; g &lt; GradVV.Len(); g++) {
1479      GPAll.AddPlot(GradVV[g], gpwLines, TStr::Fmt(&quot;param %d&quot;, g+1), &quot;linewidth 1&quot;);
1480      GetMinMax(GradVV[g], Min1, Max1, false);
1481      TGnuPlot GP(TStr::Fmt(&quot;sGrad%02d-&quot;, g+1)+OutFNm, TStr::Fmt(&quot;Gradient (avg 1k samples). %s&quot;, Desc.CStr()), true);
1482      GP.AddPlot(GradVV[g], gpwLines, TStr::Fmt(&quot;param id %d&quot;, g+1), &quot;linewidth 1&quot;);
1483      GetMinMax(GradVV[g], Min, Max, true);
1484      GP.SetYRange((int)floor(Min-1), (int)ceil(Max+1));
1485      GP.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Gradient&quot;);
1486      GP.SavePng();
1487    }
1488    GPAll.SetYRange((int)floor(Min1-1), (int)ceil(Max1+1));
1489    GPAll.SetXYLabel(&quot;Sample Index (time)&quot;, &quot;Gradient&quot;);
1490    GPAll.SavePng();
1491  }
1492  void PlotAutoCorrelation(const TFltV&amp; ValV, const int&amp; MaxK, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1493    double Avg=0.0, Var=0.0;
1494    for (int i = 0; i &lt; ValV.Len(); i++) { Avg += ValV[i]; }
1495    Avg /= (double) ValV.Len();
1496    for (int i = 0; i &lt; ValV.Len(); i++) { Var += TMath::Sqr(ValV[i]-Avg); }
1497    TFltPrV ACorrV;
1498    for (int k = 0; k &lt; TMath::Mn(ValV.Len(), MaxK); k++) {
1499      double corr = 0.0;
1500      for (int i = 0; i &lt; ValV.Len() - k; i++) {
1501        corr += (ValV[i]-Avg)*(ValV[i+k]-Avg);
1502      }
1503      ACorrV.Add(TFltPr(k, corr/Var));
1504    }
1505    TGnuPlot GP(&quot;sAutoCorr-&quot;+OutFNm, TStr::Fmt(&quot;AutoCorrelation (%d samples). %s&quot;, ValV.Len(), Desc.CStr()), true);
1506    GP.AddPlot(ACorrV, gpwLines, &quot;&quot;, &quot;linewidth 1&quot;);
1507    GP.SetXYLabel(&quot;Lag, k&quot;, &quot;Autocorrelation, r_k&quot;);
1508    GP.SavePng();
1509  }
1510  TFltV TKroneckerLL::TestSamplePerm(const TStr&amp; OutFNm, const int&amp; WarmUp, const int&amp; NSamples, const TKronMtx&amp; TrueMtx, const bool&amp; DoPlot) {
1511    printf(&quot;Sample permutations: %s (warm-up: %s)\n&quot;, TInt::GetMegaStr(NSamples).CStr(), TInt::GetMegaStr(WarmUp).CStr());
1512    int NId1=0, NId2=0, NAccept=0;
1513    TExeTm ExeTm;
1514    const int PlotLen = NSamples/1000+1;
1515    double TrueLL=-1, AvgLL=0.0;
1516    TFltV AvgGradV(GetParams());
1517    TFltPrV TrueLLV(PlotLen, 0); 
1518    TFltPrV EstLLV(PlotLen, 0);  
1519    TFltPrV AcceptV;             
1520    TFltV SampleLLV(NSamples, 0);
1521    TVec&lt;TFltPrV&gt; GradVV(GetParams());
1522    for (int g = 0; g &lt; GetParams(); g++) {
1523      GradVV[g].Gen(PlotLen, 0); }
1524    if (! TrueMtx.Empty()) {
1525      TIntV PermV=NodePerm;  TKronMtx CurMtx=ProbMtx;  ProbMtx.Dump();
1526      InitLL(TrueMtx);  SetOrderPerm();  CalcApxGraphLL();  printf(&quot;TrueLL: %f\n&quot;, LogLike());
1527      TrueLL=LogLike;  InitLL(CurMtx); NodePerm=PermV;
1528    }
1529    CalcApxGraphLL();
1530    printf(&quot;LogLike at start:       %f\n&quot;, LogLike());
1531    if (WarmUp &gt; 0) {
1532      EstLLV.Add(TFltPr(0, LogLike));
1533      if (TrueLL != -1) { TrueLLV.Add(TFltPr(0, TrueLL)); }
1534      for (int s = 0; s &lt; WarmUp; s++) { SampleNextPerm(NId1, NId2); }
1535      printf(&quot;  warm-up:%s,&quot;, ExeTm.GetTmStr());  ExeTm.Tick();
1536    }
1537    printf(&quot;LogLike afterm warm-up: %f\n&quot;, LogLike());
1538    CalcApxGraphLL(); 
1539    CalcApxGraphDLL();
1540    EstLLV.Add(TFltPr(WarmUp, LogLike));
1541    if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp, TrueLL)); }
1542    printf(&quot;  recalculated:         %f\n&quot;, LogLike());
1543    printf(&quot;  sampling (average per 1000 samples)\n&quot;);
1544    TVec&lt;TFltV&gt; SamplVV(5);
1545    for (int s = 0; s &lt; NSamples; s++) {
1546      if (SampleNextPerm(NId1, NId2)) { 
1547        UpdateGraphDLL(NId1, NId2);  NAccept++; }
1548      for (int m = 0; m &lt; AvgGradV.Len(); m++) { AvgGradV[m] += GradV[m]; }
1549      AvgLL += GetLL();
1550      SampleLLV.Add(GetLL());
1551      if (s &gt; 0 &amp;&amp; s % 1000 == 0) {
1552        printf(&quot;.&quot;);
1553        for (int g = 0; g &lt; AvgGradV.Len(); g++) {
1554          GradVV[g].Add(TFltPr(WarmUp+s, AvgGradV[g] / 1000.0)); }
1555        EstLLV.Add(TFltPr(WarmUp+s, AvgLL / 1000.0));
1556        if (TrueLL != -1) { TrueLLV.Add(TFltPr(WarmUp+s, TrueLL)); }
1557        AcceptV.Add(TFltPr(WarmUp+s, NAccept/1000.0));
1558        if (s % 100000 == 0 &amp;&amp; DoPlot) {
1559          const TStr Desc = TStr::Fmt(&quot;P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s&quot;, PermSwapNodeProb(),
1560            Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1561          PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1562          for (int n = 0; n &lt; SamplVV.Len(); n++) {
1563            PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt(&quot;%s-n%d&quot;, OutFNm.CStr(), n), Desc); }
1564          printf(&quot;  samples: %d, time: %s, samples/s: %.1f\n&quot;, s, ExeTm.GetTmStr(), double(s+1)/ExeTm.GetSecs());
1565        }
1566        AvgLL = 0;  AvgGradV.PutAll(0);  NAccept=0;
1567      }
1568    }
1569    if (DoPlot) {
1570      const TStr Desc = TStr::Fmt(&quot;P(NodeSwap)=%g. Nodes: %d, Edges: %d, Params: %d, WarmUp: %s, Samples: %s&quot;, PermSwapNodeProb(),
1571        Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), GetParams(), TInt::GetMegaStr(WarmUp).CStr(), TInt::GetMegaStr(NSamples).CStr());
1572      PlotGrad(EstLLV, TrueLLV, GradVV, AcceptV, OutFNm, Desc);
1573      for (int n = 0; n &lt; SamplVV.Len(); n++) {
1574        PlotAutoCorrelation(SamplVV[n], 1000, TStr::Fmt(&quot;%s-n%d&quot;, OutFNm.CStr(), n), Desc); }
1575    }
1576    return SampleLLV; 
1577  }
1578  void McMcGetAvgAvg(const TFltV&amp; AvgJV, double&amp; AvgAvg) {
1579    AvgAvg = 0.0;
1580    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1581      AvgAvg += AvgJV[j]; }
1582    AvgAvg /= AvgJV.Len();
1583  }
1584  void McMcGetAvgJ(const TVec&lt;TFltV&gt;&amp; ChainLLV, TFltV&amp; AvgJV) {
1585    for (int j = 0; j &lt; ChainLLV.Len(); j++) {
1586      const TFltV&amp; ChainV = ChainLLV[j];
1587      double Avg = 0;
1588      for (int i = 0; i &lt; ChainV.Len(); i++) {
1589        Avg += ChainV[i];
1590      }
1591      AvgJV.Add(Avg/ChainV.Len());
1592    }
1593  }
1594  double TKroneckerLL::CalcChainR2(const TVec&lt;TFltV&gt;&amp; ChainLLV) {
1595    const double J = ChainLLV.Len();
1596    const double K = ChainLLV[0].Len();
1597    TFltV AvgJV;    McMcGetAvgJ(ChainLLV, AvgJV);
1598    double AvgAvg;  McMcGetAvgAvg(AvgJV, AvgAvg);
1599    IAssert(AvgJV.Len() == ChainLLV.Len());
1600    double InChainVar=0, OutChainVar=0;
1601    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1602      OutChainVar += TMath::Sqr(AvgJV[j] - AvgAvg); }
1603    OutChainVar = OutChainVar * (K/double(J-1));
1604    printf(&quot;*** %g chains of len %g\n&quot;, J, K);
1605    printf(&quot;  ** between chain var: %f\n&quot;, OutChainVar);
1606    for (int j = 0; j &lt; AvgJV.Len(); j++) {
1607      const TFltV&amp; ChainV = ChainLLV[j];
1608      for (int k = 0; k &lt; ChainV.Len(); k++) {
1609        InChainVar += TMath::Sqr(ChainV[k] - AvgJV[j]); }
1610    }
1611    InChainVar = InChainVar * 1.0/double(J*(K-1));
1612    printf(&quot;  ** within chain var: %f\n&quot;, InChainVar);
1613    const double PostVar = (K-1)/K * InChainVar + 1.0/K * OutChainVar;
1614    printf(&quot;  ** posterior var: %f\n&quot;, PostVar);
1615    const double ScaleRed = sqrt(PostVar/InChainVar);
1616    printf(&quot;  ** scale reduction (&lt; 1.2): %f\n\n&quot;, ScaleRed);
1617    return ScaleRed;
1618  }
1619  void TKroneckerLL::ChainGelmapRubinPlot(const TVec&lt;TFltV&gt;&amp; ChainLLV, const TStr&amp; OutFNm, const TStr&amp; Desc) {
1620    TFltPrV LenR2V; 
1621    TVec&lt;TFltV&gt; SmallLLV(ChainLLV.Len());
1622    const int K = ChainLLV[0].Len();
1623    const int Buckets=1000;
1624    const int BucketSz = K/Buckets;
1625    for (int b = 1; b &lt; Buckets; b++) {
1626      const int End = TMath::Mn(BucketSz*b, K-1);
1627      for (int c = 0; c &lt; ChainLLV.Len(); c++) {
1628        ChainLLV[c].GetSubValV(0, End, SmallLLV[c]); }
1629      LenR2V.Add(TFltPr(End, TKroneckerLL::CalcChainR2(SmallLLV)));
1630    }
1631    LenR2V.Add(TFltPr(K, TKroneckerLL::CalcChainR2(ChainLLV)));
1632    TGnuPlot::PlotValV(LenR2V, TStr::Fmt(&quot;gelman-%s&quot;, OutFNm.CStr()), TStr::Fmt(&quot;%s. %d chains of len %d. BucketSz: %d.&quot;,
1633      Desc.CStr(), ChainLLV.Len(), ChainLLV[0].Len(), BucketSz), &quot;Chain length&quot;, &quot;Potential scale reduction&quot;);
1634  }
1635  TFltQu TKroneckerLL::TestKronDescent(const bool&amp; DoExact, const bool&amp; TruePerm, double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const TKronMtx&amp; TrueParam) {
1636    printf(&quot;Test gradient descent on a synthetic kronecker graphs:\n&quot;);
1637    if (DoExact) { printf(&quot;  -- Exact gradient calculations\n&quot;); }
1638    else { printf(&quot;  -- Approximate gradient calculations\n&quot;); }
1639    if (TruePerm) { printf(&quot;  -- No permutation sampling (use true permutation)\n&quot;); }
1640    else { printf(&quot;  -- Sample permutations (start with degree permutation)\n&quot;); }
1641    TExeTm IterTm;
1642    int Iter;
1643    double OldLL=0, MyLL=0, AvgAbsErr, AbsSumErr;
1644    TFltV MyGradV, SDevV;
1645    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1646    if (TruePerm) {
1647      SetOrderPerm();
1648    }
1649    else {
1650      printf(&quot;DEGREE  PERMUTATION\n&quot;);  SetDegPerm();
1651    }
1652    for (Iter = 0; Iter &lt; 100; Iter++) {
1653      if (TruePerm) {
1654        if (DoExact) { CalcGraphDLL();  CalcGraphLL(); } 
1655        else { CalcApxGraphDLL();  CalcApxGraphLL(); }   
1656        MyLL = LogLike;  MyGradV = GradV;
1657      } else {
1658        printf(&quot;.&quot;);
1659        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1660      }
1661      printf(&quot;%d] LL: %g, &quot;, Iter, MyLL);
1662      AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1663      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueParam.GetMtxSum());
1664      printf(&quot;  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n&quot;, AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1665      for (int p = 0; p &lt; GetParams(); p++) {
1666        LearnRateV[p] *= 0.9;
1667        while (fabs(LearnRateV[p]*MyGradV[p]) &gt; 0.1) { LearnRateV[p] *= 0.9; }
1668        while (fabs(LearnRateV[p]*MyGradV[p]) &lt; 0.001) { LearnRateV[p] *= (1.0/0.9); }
1669        printf(&quot;    %d]  %f  &lt;--  %f + %f    lrnRate:%g\n&quot;, p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1670          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), LearnRateV[p]());
1671        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1672        if (ProbMtx.At(p) &gt; 0.99) { ProbMtx.At(p)=0.99; }
1673        if (ProbMtx.At(p) &lt; 0.01) { ProbMtx.At(p)=0.01; }
1674      }
1675      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1676      if (AvgAbsErr &lt; 0.01) { printf(&quot;***CONVERGED!\n&quot;);  break; }
1677      printf(&quot;\n&quot;);  fflush(stdout);
1678    }
1679    TrueParam.Dump(&quot;True  Thetas&quot;, true);
1680    ProbMtx.Dump(&quot;Final Thetas&quot;, true);
1681    printf(&quot;  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n&quot;, AvgAbsErr, AbsSumErr, Iter);
1682    printf(&quot;Iteration run time: %s, sec: %g\n\n&quot;, IterTm.GetTmStr(), IterTm.GetSecs());
1683    return TFltQu(AvgAbsErr, AbsSumErr, Iter, IterTm.GetSecs());
1684  }
1685  void PlotTrueAndEst(const TStr&amp; OutFNm, const TStr&amp; Desc, const TStr&amp; YLabel, const TFltPrV&amp; EstV, const TFltPrV&amp; TrueV) {
1686    TGnuPlot GP(OutFNm, Desc.CStr(), true);
1687    GP.AddPlot(EstV, gpwLinesPoints, YLabel, &quot;linewidth 1 pointtype 6 pointsize 1&quot;);
1688    if (! TrueV.Empty()) { GP.AddPlot(TrueV, gpwLines, &quot;TRUE&quot;); }
1689    GP.SetXYLabel(&quot;Gradient descent iterations&quot;, YLabel);
1690    GP.SavePng();
1691  }
1692  void TKroneckerLL::GradDescentConvergence(const TStr&amp; OutFNm, const TStr&amp; Desc1, const bool&amp; SamplePerm, const int&amp; NIters,
1693   double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const int&amp; AvgKGraphs, const TKronMtx&amp; TrueParam) {
1694    TExeTm IterTm;
1695    int Iter;
1696    double OldLL=0, MyLL=0, AvgAbsErr=0, AbsSumErr=0;
1697    TFltV MyGradV, SDevV;
1698    TFltV LearnRateV(GetParams());  LearnRateV.PutAll(LearnRate);
1699    TFltPrV EZeroV, DiamV, Lambda1V, Lambda2V, AvgAbsErrV, AvgLLV;
1700    TFltPrV TrueEZeroV, TrueDiamV, TrueLambda1V, TrueLambda2V, TrueLLV;
1701    TFltV SngValV;  TSnap::GetSngVals(Graph, 2, SngValV);  SngValV.Sort(false);
1702    const double TrueEZero = pow((double) Graph-&gt;GetEdges(), 1.0/double(KronIters));
1703    const double TrueEffDiam = TSnap::GetAnfEffDiam(Graph, false, 10);
1704    const double TrueLambda1 = SngValV[0];
1705    const double TrueLambda2 = SngValV[1];
1706    if (! TrueParam.Empty()) {
1707      const TKronMtx CurParam = ProbMtx;  ProbMtx.Dump();
1708      InitLL(TrueParam);  SetOrderPerm();  CalcApxGraphLL(); printf(&quot;TrueLL: %f\n&quot;, LogLike());
1709      OldLL = LogLike;  InitLL(CurParam);
1710    }
1711    const double TrueLL = OldLL;
1712    if (! SamplePerm) { SetOrderPerm(); } else { SetDegPerm(); }
1713    for (Iter = 0; Iter &lt; NIters; Iter++) {
1714      if (! SamplePerm) {
1715        CalcApxGraphDLL();  CalcApxGraphLL();   
1716        MyLL = LogLike;  MyGradV = GradV;
1717      } else {
1718        SampleGradient(WarmUp, NSamples, MyLL, MyGradV);
1719      }
1720      double SumDiam=0, SumSngVal1=0, SumSngVal2=0;
1721      for (int trial = 0; trial &lt; AvgKGraphs; trial++) {
1722        PNGraph KronGraph = TKronMtx::GenFastKronecker(ProbMtx, KronIters, true, 0); 
1723        SngValV.Clr(true);  TSnap::GetSngVals(KronGraph, 2, SngValV);  SngValV.Sort(false);
1724        SumDiam += TSnap::GetAnfEffDiam(KronGraph, false, 10);
1725        SumSngVal1 += SngValV[0];  SumSngVal2 += SngValV[1];
1726      }
1727      AvgLLV.Add(TFltPr(Iter, MyLL));
1728      EZeroV.Add(TFltPr(Iter, ProbMtx.GetMtxSum()));
1729      DiamV.Add(TFltPr(Iter, SumDiam/double(AvgKGraphs)));
1730      Lambda1V.Add(TFltPr(Iter, SumSngVal1/double(AvgKGraphs)));
1731      Lambda2V.Add(TFltPr(Iter, SumSngVal2/double(AvgKGraphs)));
1732      TrueLLV.Add(TFltPr(Iter, TrueLL));
1733      TrueEZeroV.Add(TFltPr(Iter, TrueEZero));
1734      TrueDiamV.Add(TFltPr(Iter, TrueEffDiam));
1735      TrueLambda1V.Add(TFltPr(Iter, TrueLambda1));
1736      TrueLambda2V.Add(TFltPr(Iter, TrueLambda2));
1737      if (Iter % 10 == 0) {
1738        const TStr Desc = TStr::Fmt(&quot;%s. Iter: %d, G(%d, %d)  K(%d, %d)&quot;, Desc1.Empty()?OutFNm.CStr():Desc1.CStr(),
1739          Iter, Graph-&gt;GetNodes(), Graph-&gt;GetEdges(), ProbMtx.GetNodes(KronIters), ProbMtx.GetEdges(KronIters));
1740        PlotTrueAndEst(&quot;LL.&quot;+OutFNm, Desc, &quot;Average LL&quot;, AvgLLV, TrueLLV);
1741        PlotTrueAndEst(&quot;E0.&quot;+OutFNm, Desc, &quot;E0 (expected number of edges)&quot;, EZeroV, TrueEZeroV);
1742        PlotTrueAndEst(&quot;Diam.&quot;+OutFNm+&quot;-Diam&quot;, Desc, &quot;Effective diameter&quot;, DiamV, TrueDiamV);
1743        PlotTrueAndEst(&quot;Lambda1.&quot;+OutFNm, Desc, &quot;Lambda 1&quot;, Lambda1V, TrueLambda1V);
1744        PlotTrueAndEst(&quot;Lambda2.&quot;+OutFNm, Desc, &quot;Lambda 2&quot;, Lambda2V, TrueLambda2V);
1745        if (! TrueParam.Empty()) {
1746          PlotTrueAndEst(&quot;AbsErr.&quot;+OutFNm, Desc, &quot;Average Absolute Error&quot;, AvgAbsErrV, TFltPrV()); }
1747      }
1748      if (! TrueParam.Empty()) {
1749        AvgAbsErr = TKronMtx::GetAvgAbsErr(ProbMtx, TrueParam);
1750        AvgAbsErrV.Add(TFltPr(Iter, AvgAbsErr));
1751      } else { AvgAbsErr = 1.0; }
1752      AbsSumErr = fabs(ProbMtx.GetMtxSum() - TrueEZero);
1753      for (int p = 0; p &lt; GetParams(); p++) {
1754        LearnRateV[p] *= 0.99;
1755        while (fabs(LearnRateV[p]*MyGradV[p]) &gt; 0.1) { LearnRateV[p] *= 0.99; printf(&quot;.&quot;);}
1756        while (fabs(LearnRateV[p]*MyGradV[p]) &lt; 0.002) { LearnRateV[p] *= (1.0/0.95); printf(&quot;*&quot;);}
1757        printf(&quot;    %d]  %f  &lt;--  %f + %9f   Grad: %9.1f,  Rate:%g\n&quot;, p, ProbMtx.At(p) + LearnRateV[p]*MyGradV[p],
1758          ProbMtx.At(p), (double)(LearnRateV[p]*MyGradV[p]), MyGradV[p](), LearnRateV[p]());
1759        ProbMtx.At(p) = ProbMtx.At(p) + LearnRateV[p]*MyGradV[p];
1760        if (ProbMtx.At(p) &gt; 1.0) { ProbMtx.At(p)=1.0; }
1761        if (ProbMtx.At(p) &lt; 0.001) { ProbMtx.At(p)=0.001; }
1762      }
1763      printf(&quot;%d] LL: %g, &quot;, Iter, MyLL);
1764      printf(&quot;  avgAbsErr: %.4f, absSumErr: %.4f, newLL: %.2f, deltaLL: %.2f\n&quot;, AvgAbsErr, AbsSumErr, MyLL, OldLL-MyLL);
1765      if (AvgAbsErr &lt; 0.001) { printf(&quot;***CONVERGED!\n&quot;);  break; }
1766      printf(&quot;\n&quot;);  fflush(stdout);
1767      ProbMtx.GetLLMtx(LLMtx);  OldLL = MyLL;
1768    }
1769    TrueParam.Dump(&quot;True  Thetas&quot;, true);
1770    ProbMtx.Dump(&quot;Final Thetas&quot;, true);
1771    printf(&quot;  AvgAbsErr: %f\n  AbsSumErr: %f\n  Iterations: %d\n&quot;, AvgAbsErr, AbsSumErr, Iter);
1772    printf(&quot;Iteration run time: %s, sec: %g\n\n&quot;, IterTm.GetTmStr(), IterTm.GetSecs());
1773  }
1774  void TKroneckerLL::TestBicCriterion(const TStr&amp; OutFNm, const TStr&amp; Desc1, const PNGraph&amp; G, const int&amp; GradIters,
1775   double LearnRate, const int&amp; WarmUp, const int&amp; NSamples, const int&amp; TrueN0) {
1776    TFltPrV BicV, MdlV, LLV;
1777    const double rndGP = G-&gt;GetEdges()/TMath::Sqr(double(G-&gt;GetNodes()));
1778    const double RndGLL = G-&gt;GetEdges()*log(rndGP )+ (TMath::Sqr(double(G-&gt;GetNodes()))-G-&gt;GetEdges())*log(1-rndGP);
1779    LLV.Add(TFltPr(1, RndGLL));
1780    BicV.Add(TFltPr(1, -RndGLL + 0.5*TMath::Sqr(1)*log(TMath::Sqr(G-&gt;GetNodes()))));
1781    MdlV.Add(TFltPr(1, -RndGLL + 32*TMath::Sqr(1)+2*(log((double)1)+log((double)G-&gt;GetNodes()))));
1782    for (int NZero = 2; NZero &lt; 10; NZero++) {
1783      const TKronMtx InitKronMtx = TKronMtx::GetInitMtx(NZero, G-&gt;GetNodes(), G-&gt;GetEdges());
1784      InitKronMtx.Dump(&quot;INIT PARAM&quot;, true);
1785      TKroneckerLL KronLL(G, InitKronMtx);
1786      KronLL.SetPerm(&#x27;d&#x27;); 
1787      const double LastLL = KronLL.GradDescent(GradIters, LearnRate, 0.001, 0.01, WarmUp, NSamples);
1788      LLV.Add(TFltPr(NZero, LastLL));
1789      BicV.Add(TFltPr(NZero, -LastLL + 0.5*TMath::Sqr(NZero)*log(TMath::Sqr(G-&gt;GetNodes()))));
1790      MdlV.Add(TFltPr(NZero, -LastLL + 32*TMath::Sqr(NZero)+2*(log((double)NZero)+log((double)KronLL.GetKronIters()))));
1791      { TGnuPlot GP(&quot;LL-&quot;+OutFNm, Desc1);
1792      GP.AddPlot(LLV, gpwLinesPoints, &quot;Log-likelihood&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1793      GP.SetXYLabel(&quot;NZero&quot;, &quot;Log-Likelihood&quot;);  GP.SavePng(); }
1794      { TGnuPlot GP(&quot;BIC-&quot;+OutFNm, Desc1);
1795      GP.AddPlot(BicV, gpwLinesPoints, &quot;BIC&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1796      GP.SetXYLabel(&quot;NZero&quot;, &quot;BIC&quot;);  GP.SavePng(); }
1797      { TGnuPlot GP(&quot;MDL-&quot;+OutFNm, Desc1);
1798      GP.AddPlot(MdlV, gpwLinesPoints, &quot;MDL&quot;, &quot;linewidth 1 pointtype 6 pointsize 2&quot;);
1799      GP.SetXYLabel(&quot;NZero&quot;, &quot;MDL&quot;);  GP.SavePng(); }
1800    }
1801  }
1802  void TKroneckerLL::TestGradDescent(const int&amp; KronIters, const int&amp; KiloSamples, const TStr&amp; Permutation) {
1803    const TStr OutFNm = TStr::Fmt(&quot;grad-%s%d-%dk&quot;, Permutation.CStr(), KronIters, KiloSamples);
1804    TKronMtx KronParam = TKronMtx::GetMtx(&quot;0.8 0.6; 0.6 0.4&quot;);
1805    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, KronIters, true, 0);
1806    TKroneckerLL KronLL(Graph, KronParam);
1807    TVec&lt;TFltV&gt; GradVV(4), SDevVV(4);  TFltV XValV;
1808    int NId1 = 0, NId2 = 0, NAccept = 0;
1809    TVec&lt;TMom&gt; GradMomV(4);
1810    TExeTm ExeTm;
1811    if (Permutation == &quot;r&quot;) KronLL.SetRndPerm();
1812    else if (Permutation == &quot;d&quot;) KronLL.SetDegPerm();
1813    else if (Permutation == &quot;o&quot;) KronLL.SetOrderPerm();
1814    else FailR(&quot;Unknown permutation (r,d,o)&quot;);
1815    KronLL.CalcApxGraphLL();
1816    KronLL.CalcApxGraphDLL();
1817    for (int s = 0; s &lt; 1000*KiloSamples; s++) {
1818      if (KronLL.SampleNextPerm(NId1, NId2)) { 
1819        KronLL.UpdateGraphDLL(NId1, NId2);  NAccept++; }
1820      if (s &gt; 50000) { 
1821        for (int m = 0; m &lt; 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1822        if ((s+1) % 1000 == 0) {
1823          printf(&quot;.&quot;);
1824          for (int m = 0; m &lt; 4; m++) { GradVV[m].Add(KronLL.GradV[m]); }
1825          XValV.Add((s+1));
1826          if ((s+1) % 100000 == 0) {
1827            TGnuPlot GP(OutFNm, TStr::Fmt(&quot;Gradient vs. samples. %d nodes, %d edges&quot;, Graph-&gt;GetNodes(), Graph-&gt;GetEdges()), true);
1828            for (int g = 0; g &lt; GradVV.Len(); g++) {
1829              GP.AddPlot(XValV, GradVV[g], gpwLines, TStr::Fmt(&quot;grad %d&quot;, g)); }
1830            GP.SetXYLabel(&quot;sample index&quot;,&quot;log Gradient&quot;);
1831            GP.SavePng();
1832          }
1833        }
1834      }
1835    }
1836    printf(&quot;\n&quot;);
1837    for (int m = 0; m &lt; 4; m++) {
1838      GradMomV[m].Def();
1839      printf(&quot;grad %d: mean: %12f  sDev: %12f  median: %12f\n&quot;, m,
1840        GradMomV[m].GetMean(), GradMomV[m].GetSDev(), GradMomV[m].GetMedian());
1841    }
1842  }
1843  int TKronNoise::RemoveNodeNoise(PNGraph&amp; Graph, const int&amp; NNodes, const bool Random) {
1844  	IAssert(NNodes &gt; 0 &amp;&amp; NNodes &lt; (Graph-&gt;GetNodes() / 2));
1845  	int i = 0;
1846  	TIntV ShufflePerm;
1847  	Graph-&gt;GetNIdV(ShufflePerm);
1848  	if(Random) {
1849  		ShufflePerm.Shuffle(TKronMtx::Rnd);
1850  		for(i = 0; i &lt; NNodes; i++) {
1851  			Graph-&gt;DelNode(int(ShufflePerm[i]));
1852  		}
1853  	} else {
1854  		for(i = 0; i &lt; NNodes; i++) {
1855  			Graph-&gt;DelNode(int(ShufflePerm[ShufflePerm.Len() - 1 - i]));
1856  		}
1857  	}
1858  	return Graph-&gt;GetNodes();
1859  }
1860  int TKronNoise::RemoveNodeNoise(PNGraph&amp; Graph, const double&amp; Rate, const bool Random) {
1861  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1862  	return TKronNoise::RemoveNodeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetNodes())), Random);
1863  }
1864  int TKronNoise::FlipEdgeNoise(PNGraph&amp; Graph, const int&amp; NEdges, const bool Random) {
1865  	IAssert(NEdges &gt; 0 &amp;&amp; NEdges &lt; Graph-&gt;GetEdges());
1866  	const int Nodes = Graph-&gt;GetNodes();
1867  	const int Edges = Graph-&gt;GetEdges();
1868  	int Src, Dst;
1869  	TIntV NIdV, TempV;
1870  	TIntPrV ToAdd, ToDel;
1871  	Graph-&gt;GetNIdV(NIdV);
1872  	ToAdd.Gen(NEdges / 2, 0);
1873  	for(int i = 0; i &lt; NEdges / 2; i++) {
1874  		Src = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1875  		Dst = NIdV[TKronMtx::Rnd.GetUniDevInt(Nodes)];
1876  		if(Graph-&gt;IsEdge(Src, Dst)) {	i--;	continue;	}
1877  		ToAdd.Add(TIntPr(Src, Dst));
1878  	}
1879  	ToDel.Gen(Edges, 0);
1880  	for(TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
1881  		ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1882  	}
1883  	ToDel.Shuffle(TKronMtx::Rnd);
1884  	for(int i = 0; i &lt; NEdges / 2; i++) {
1885  		Graph-&gt;DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1886  		Graph-&gt;AddEdge(ToAdd[i].Val1, ToAdd[i].Val2);
1887  	}
1888  	return Graph-&gt;GetEdges();
1889  }
1890  int TKronNoise::FlipEdgeNoise(PNGraph&amp; Graph, const double&amp; Rate, const bool Random) {
1891  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1892  	return TKronNoise::FlipEdgeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetEdges())), Random);
1893  }
1894  int TKronNoise::RemoveEdgeNoise(PNGraph&amp; Graph, const int&amp; NEdges) {
1895  	IAssert(NEdges &gt; 0 &amp;&amp; NEdges &lt; Graph-&gt;GetEdges());
1896  	TIntPrV ToDel;
1897  	ToDel.Gen(Graph-&gt;GetEdges(), 0);
1898  	for(TNGraph::TEdgeI EI = Graph-&gt;BegEI(); EI &lt; Graph-&gt;EndEI(); EI++) {
1899  		if(EI.GetSrcNId() != EI.GetDstNId()) {
1900  			ToDel.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
1901  		}
1902  	}
1903  	ToDel.Shuffle(TKronMtx::Rnd);
1904  	for(int i = 0; i &lt; NEdges; i++) {
1905  		Graph-&gt;DelEdge(ToDel[i].Val1, ToDel[i].Val2);
1906  	}
1907  	return Graph-&gt;GetEdges();
1908  }
1909  int TKronNoise::RemoveEdgeNoise(PNGraph&amp; Graph, const double&amp; Rate) {
1910  	IAssert(Rate &gt; 0 &amp;&amp; Rate &lt; 0.5);
1911  	return TKronNoise::RemoveEdgeNoise(Graph, (int) floor(Rate * double(Graph-&gt;GetEdges())));
1912  }
1913  void TKronMaxLL::SetPerm(const char&amp; PermId) {
1914    if (PermId == &#x27;o&#x27;) KronLL.SetOrderPerm();
1915    else if (PermId == &#x27;d&#x27;) KronLL.SetDegPerm();
1916    else if (PermId == &#x27;r&#x27;) KronLL.SetRndPerm();
1917    else FailR(&quot;Unknown permutation type (o,d,r)&quot;);
1918  }
1919  void TKronMaxLL::RoundTheta(const TFltV&amp; ThetaV, TFltV&amp; NewThetaV) {
1920    NewThetaV.Gen(ThetaV.Len());
1921    for (int i = 0; i &lt; ThetaV.Len(); i++) {
1922      NewThetaV[i] = TMath::Round(ThetaV[i], 3); }
1923  }
1924  void TKronMaxLL::RoundTheta(const TFltV&amp; ThetaV, TKronMtx&amp; Kronecker) {
1925    Kronecker.GenMtx((int)sqrt((double)ThetaV.Len()));
1926    for (int i = 0; i &lt; ThetaV.Len(); i++) {
1927      Kronecker.At(i) = TMath::Round(ThetaV[i], 3); }
1928  }
1929  void TKronMaxLL::Test() {
1930    TKronMtx::PutRndSeed(1);
1931    TKronMtx KronParam = TKronMtx::GetMtx(&quot;0.8 0.7; 0.6 0.5&quot;);
1932    PNGraph Graph  = TKronMtx::GenFastKronecker(KronParam, 8, true, 1);
1933    TKronMaxLL KronMaxLL(Graph, TFltV::GetV(0.9, 0.7, 0.5, 0.3));
1934    KronMaxLL.SetPerm(&#x27;d&#x27;);
1935  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-kronecker.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1109  	  MtxV.Gen(NIter, 0);
1110    }
1111    for (int Iter = 0; Iter &lt; NIter; Iter++) {
1112      printf(&quot;%03d] &quot;, Iter);
</pre></code></div>
                <div class="column column_space"><pre><code>1441  		MtxV.Gen(EMIter, 0);
1442  	}
1443  	for(int i = 0; i &lt; EMIter; i++) {
1444  		printf(&quot;\n----------------------------------------------------------------------\n&quot;);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    