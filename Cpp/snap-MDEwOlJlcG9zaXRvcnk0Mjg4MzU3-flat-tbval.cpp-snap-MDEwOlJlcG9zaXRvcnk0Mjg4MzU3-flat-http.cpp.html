
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.176709546377793%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbval.cpp</h3>
            <pre><code>1  bool TTbVal::operator==(const TTbVal& TbVal) const {
2    if (ValTag!=TbVal.ValTag){
3      return false;
4    } else {
5      switch (ValTag){
6        case tvtDsc: return Val.Dsc==TbVal.Val.Dsc;
7        case tvtFlt: return Val.Flt==TbVal.Val.Flt;
8        default: return true;
9      }
10    }
11  }
12  bool TTbVal::operator<(const TTbVal& TbVal) const {
13    if (ValTag<TbVal.ValTag){
14      return false;
15    } else {
16      switch (ValTag){
17        case tvtDsc: return Val.Dsc<TbVal.Val.Dsc;
18        case tvtFlt: return Val.Flt<TbVal.Val.Flt;
19        default: return true;
20      }
21    }
22  }
23  TStr TTbVal::GetValTagStr(const int& ValTag){
24    switch (ValTag){
25      case tvtUndef: return "<Undef>";
26      case tvtUnknw: return "<Unknw>";
27      case tvtUnimp: return "<Unimp>";
28      case tvtUnapp: return "<Unapp>";
29      case tvtDsc: return "<Dsc>";
30      case tvtFlt: return "<Flt>";
31      default: Fail; return TStr();
32    }
33  }
34  TStr TTbVal::GetStr() const {
35    switch (ValTag){
36      case tvtUndef: Fail; return TStr();
37      case tvtUnknw: return TStr('?');
38      case tvtUnimp: return TStr('*');
39      case tvtUnapp: return TStr('/');
40      case tvtDsc: return TInt::GetStr(Val.Dsc);
41      case tvtFlt: return TFlt::GetStr(Val.Flt);
42      default: Fail; return TStr();
43    }
44  }
45  const TTbVal TTbVal::NegVal(false);
46  const TTbVal TTbVal::PosVal(true);
47  const int TTbVal::BoolVals=2;
48  PTbValSet TTbValSet::Load(TSIn& SIn){
49    TStr TypeNm(SIn);
50    if (TypeNm==TTypeNm<TTbValSetExp>()){return new TTbValSetExp(SIn);}
51    else if (TypeNm==TTypeNm<TTbValSetSel>()){return new TTbValSetSel(SIn);}
52    else {Fail; return NULL;}
53  }
54  bool TTbValSetExp::In(const TTbVal& Val){
55    switch (LOp){
56      case loNot: Assert(TbValSetV.Len()==1); return !TbValSetV[0]->In(Val);
57      case loAnd:{
58        bool Ok=true; int TbValSetN=0;
59        while (Ok&&(TbValSetN<TbValSetV.Len())){
60          Ok=TbValSetV[TbValSetN++]->In(Val);}
61        return Ok;}
62      case loOr:{
63        bool Ok=false; int TbValSetN=0;
64        while (!Ok&&(TbValSetN<TbValSetV.Len())){
65          Ok=TbValSetV[TbValSetN++]->In(Val);}
66        return Ok;}
67      default: Fail; return false;
68    }
69  }
70  int TTbValSetExp::InN(const TTbVal& Val){
71    Assert(LOp==loOr);
72    bool Ok=false; int TbValSetN=0;
73    while (!Ok&&(TbValSetN<TbValSetV.Len())){Ok=TbValSetV[TbValSetN++]->In(Val);}
74    if (TbValSetN<TbValSetV.Len()){return TbValSetN;} else {return -1;}
75  }
76  void TTbValSplit::AddBinSplitDscValsPerBits(const int& Dscs, const TB32Set& BSet){
77    uint DscBSet=BSet.GetUInt();
78    for (int Dsc=0; Dsc<Dscs; Dsc++){
79      if (DscBSet%2){AddSplitVal(0, TTbVal(Dsc));}
80      else {AddSplitVal(1, TTbVal(Dsc));}
81      DscBSet/=2;
82    }
83  }
84  int TTbValSplit::GetSplitN(const TTbVal& TbVal) const {
85    int Splits=GetSplits();
86    for (int SplitN=0; SplitN<Splits; SplitN++){
87      if (TbValVV[SplitN].IsIn(TbVal)){return SplitN;}
88    }
89    return -1;
90  }
91  TStr TTbValSplit::GetStr() const {
92    TChA ChA;
93    ChA+="Split"; ChA+=":[";
94    int Splits=GetSplits();
95    for (int SplitN=0; SplitN<Splits; SplitN++){
96      if (SplitN>0){ChA+=' ';}
97      ChA+='S'; ChA+=TInt::GetStr(SplitN); ChA+=":[";
<span onclick='openModal()' class='match'>98      int SplitVals=GetSplitVals(SplitN);
99      for (int ValN=0; ValN<SplitVals; ValN++){
100        TTbVal TbVal=GetSplitVal(SplitN, ValN);
101        if (ValN>0){ChA+=' ';}
</span>102        ChA+='V'; ChA+=TbVal.GetStr();
103      }
104      ChA+="]";
105    }
106    ChA+="]";
107    return ChA;
108  }
109  PTbValSplit TTbValSplit::GetBoolValSplit(){
110    static PTbValSplit BoolValSplit;
111    if (BoolValSplit.Empty()){
112      BoolValSplit=PTbValSplit(new TTbValSplit(2));
113      BoolValSplit->AddSplitVal(0, TTbVal::NegVal);
114      BoolValSplit->AddSplitVal(1, TTbVal::PosVal);
115    }
116    return BoolValSplit;
117  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.cpp</h3>
            <pre><code>1  const TStr THttp::HttpStr="http";
2  const TStr THttp::SlashStr="/";
3  const TStr THttp::ColonStr=":";
4  const TStr THttp::ContTypeFldNm="Content-Type";
5  const TStr THttp::ContLenFldNm="Content-Length";
6  const TStr THttp::HostFldNm="Host";
7  const TStr THttp::AcceptRangesFldNm="Accept-Ranges";
8  const TStr THttp::CacheCtrlFldNm="Cache-Control";
9  const TStr THttp::AcceptFldNm="Accept";
10  const TStr THttp::SrvFldNm="Server";
11  const TStr THttp::ConnFldNm="Connection";
12  const TStr THttp::FetchIdFldNm="FetchId";
13  const TStr THttp::LocFldNm="Location";
14  const TStr THttp::SetCookieFldNm="Set-Cookie";
15  const TStr THttp::CookieFldNm="Cookie";
16  const TStr THttp::TextFldVal="text/";
17  const TStr THttp::TextPlainFldVal="text/plain";
18  const TStr THttp::TextHtmlFldVal="text/html";
19  const TStr THttp::TextXmlFldVal="text/xml";
20  const TStr THttp::TextWmlFldVal="text/vnd.wap.wml";
21  const TStr THttp::TextJavaScriptFldVal="text/javascript";
22  const TStr THttp::TextCssFldVal="text/css";
23  const TStr THttp::ImageIcoFldVal="image/x-icon";
24  const TStr THttp::ImagePngFldVal="image/png";
25  const TStr THttp::ImageGifFldVal="image/gif";
26  const TStr THttp::ImageJpgFldVal="image/jpg";
27  const TStr THttp::AppOctetFldVal="application/octet-stream";
28  const TStr THttp::AppSoapXmlFldVal="application/soap+xml";
29  const TStr THttp::AppW3FormFldVal="application/x-www-form-urlencoded";
30  const TStr THttp::AppJSonFldVal = "application/json";
31  const TStr THttp::ConnKeepAliveFldVal="keep-alive";
32  bool THttp::IsHtmlFExt(const TStr& FExt){
33    TStr UcFExt=FExt.GetUc();
34    return ((UcFExt==TFile::HtmlFExt.GetUc())||(UcFExt==TFile::HtmFExt.GetUc()));
35  }
36  bool THttp::IsGifFExt(const TStr& FExt){
37    return (FExt.GetUc()==TFile::GifFExt.GetUc());
38  }
39  const int THttp::DfPortN=80;
40  const int THttp::OkStatusCd=200;
41  const int THttp::RedirStatusCd=300;
42  const int THttp::BadRqStatusCd=400;
43  const int THttp::ErrStatusCd=400;
44  const int THttp::ErrNotFoundStatusCd=404;
45  const int THttp::InternalErrStatusCd=500;
46  TStr THttp::GetReasonPhrase(const int& StatusCd){
47    switch (StatusCd){
48      case 200: return "OK";
49      case 201: return "Created";
50      case 202: return "Accepted";
51      case 204: return "No Content";
52      case 300: return "Multiple Choices";
53      case 301: return "Moved Permanently";
54      case 302: return "Moved Temporarily";
55      case 304: return "Not Modified";
56      case 400: return "Bad Request";
57      case 401: return "Unauthorized";
58      case 403: return "Forbidden";
59      case 404: return "Not Found";
60      case 500: return "Internal Server Error";
61      case 501: return "Not Implemented";
62      case 502: return "Bad Gateway";
63      case 503: return "Service Unavailable";
64      default: return TStr("Unknown Status Code ")+TInt::GetStr(StatusCd);
65    }
66  }
67  const TStr THttp::GetMethodNm="GET";
68  const TStr THttp::HeadMethodNm="HEAD";
69  const TStr THttp::PostMethodNm="POST";
70  const TStr THttp::UndefMethodNm="UndefinedMethod";
71  typedef enum {hpctUndef, hpctAlpha, hpctDigit, hpctCtl, hpctSpec} THttpChTy;
72  class THttpChDef{
73  private:
74    TIntV ChTyV;
75    TChV LcChV;
76    void SetLcCh(const TStr& Str);
77    void SetChTy(const THttpChTy& ChTy, const char& Ch);
78    void SetChTy(const THttpChTy& ChTy, const TStr& Str);
79  public:
80    THttpChDef();
81    THttpChDef& operator=(const THttpChDef&){Fail; return *this;}
82    int GetChTy(const char& Ch){return ChTyV[Ch-TCh::Mn];}
83    bool IsAlpha(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctAlpha);}
84    bool IsDigit(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctDigit);}
85    bool IsCtl(const char& Ch){return ChTyV[Ch-TCh::Mn]==int(hpctCtl);}
86    bool IsLws(const char& Ch){
87      return (Ch==' ')||(Ch==TCh::TabCh)||(Ch==TCh::CrCh)||(Ch==TCh::LfCh);}
88    bool IsText(const char& Ch){return !IsCtl(Ch)||IsLws(Ch);}
89    bool IsSpec(const char& Ch){
90      return (ChTyV[Ch-TCh::Mn]==int(hpctSpec))||(Ch==9)||(Ch==32);}
91    bool IsCr(const char& Ch){return Ch==13;}
92    bool IsLf(const char& Ch){return Ch==10;}
93    bool IsSp(const char& Ch){return Ch==32;}
94    bool IsHt(const char& Ch){return Ch==9;}
95    bool IsDQuote(const char& Ch){return Ch=='"';}
96    char GetLcCh(const char& Ch){return LcChV[Ch-TCh::Mn];}
97    TStr GetLcStr(const TStr& Str);
98  };
99  void THttpChDef::SetChTy(const THttpChTy& ChTy, const char& Ch){
100    IAssert(ChTyV[Ch-TCh::Mn]==int(hpctUndef)); ChTyV[Ch-TCh::Mn]=TInt(ChTy);}
101  void THttpChDef::SetChTy(const THttpChTy& ChTy, const TStr& Str){
102    for (int ChN=0; ChN<Str.Len(); ChN++){SetChTy(ChTy, Str[ChN]);}}
103  void THttpChDef::SetLcCh(const TStr& Str){
104    for (int ChN=1; ChN<Str.Len(); ChN++){LcChV[Str[ChN]-TCh::Mn]=TCh(Str[0]);}}
105  THttpChDef::THttpChDef():
106    ChTyV(TCh::Vals), LcChV(TCh::Vals){
107    ChTyV.PutAll(TInt(hpctUndef));
108    SetChTy(hpctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
109    SetChTy(hpctAlpha, "abcdefghijklmnopqrstuvwxyz");
110    SetChTy(hpctDigit, "0123456789");
111    for (char Ch=0; Ch<=31; Ch++){SetChTy(hpctCtl, Ch);}
112    SetChTy(hpctCtl, 127);
113    SetChTy(hpctSpec, "()<>@,;:\\\"/[]?={}"); 
114    {for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){LcChV[Ch-TCh::Mn]=TCh(char(Ch));}}
115    SetLcCh("aA"); SetLcCh("bB"); SetLcCh("cC"); SetLcCh("dD"); SetLcCh("eE");
116    SetLcCh("fF"); SetLcCh("gG"); SetLcCh("hH"); SetLcCh("iI"); SetLcCh("jJ");
117    SetLcCh("kK"); SetLcCh("lL"); SetLcCh("mM"); SetLcCh("nN"); SetLcCh("oO");
118    SetLcCh("pP"); SetLcCh("qQ"); SetLcCh("rR"); SetLcCh("sS"); SetLcCh("tT");
119    SetLcCh("uU"); SetLcCh("vV"); SetLcCh("wW"); SetLcCh("xX"); SetLcCh("yY");
120    SetLcCh("zZ");
121  }
122  TStr THttpChDef::GetLcStr(const TStr& Str){
123    TChA LcStr;
124    for (int ChN=0; ChN<Str.Len(); ChN++){LcStr+=GetLcCh(Str[ChN]);}
125    return LcStr;
126  }
127  typedef enum {
128    heUnexpectedEof, hePeriodExpected, heTokenExpected, heInvalidToken,
129    heTSpecExpected, heInvalidTSpec, heNumExpected, heInvalidNumPlaces,
130    heCrLfExpected, heMethodNmExpected, heUrlEmpty, heBadUrl,
131    heBadSearchStr} THttpExCd;
132  class THttpEx{
133  private:
134    THttpExCd HttpExCd;
135  public:
136    THttpEx(const THttpExCd& _HttpExCd): HttpExCd(_HttpExCd){}
137  };
138  class THttpLx{
139  private:
140    static THttpChDef ChDef;
141    PSIn SIn;
142    TBoolChS EofChPrS;
143    char Ch;
144    bool AtEof;
145    TMem SfMem;
146  public:
147    THttpLx(const PSIn& _SIn):
148      SIn(_SIn), EofChPrS(), Ch(' '), AtEof(false), SfMem(50000){
149      GetFirstCh();}
150    THttpLx& operator=(const THttpLx&){Fail; return *this;}
151    bool Eof(){return AtEof;}
152    int Len(){return EofChPrS.Len()+SIn->Len();}
153    char GetFirstCh();
154    char GetCh();
155    void GetRest();
156    void PutCh(const char& _Ch){
157      EofChPrS.Push(TBoolChPr(AtEof, Ch)); Ch=_Ch; AtEof=false; SfMem.Pop();}
158    void ClrMemSf(){SfMem.Clr();}
159    TMem& GetMemSf(){return SfMem;}
160    THttpRqMethod GetRqMethod();
161    PUrl GetUrl();
162    TStr GetUrlStr();
163    bool IsRespStatusLn();
164    TStr GetRespReasonPhrase();
165    void GetWs();
166    bool IsLws();
167    void GetLws();
168    bool IsCrLf();
169    void GetCrLf();
170    void GetPeriod();
171    TStr GetToken(const TStr& ExpectStr=TStr());
172    TStr GetSpec(const TStr& ExpectStr=TStr());
173    int GetInt(const int& RqPlaces=-1);
174    TStr GetFldVal();
175    static TStr GetNrStr(const TStr& Str){return ChDef.GetLcStr(Str);}
176  };
177  THttpChDef THttpLx::ChDef;
178  char THttpLx::GetFirstCh(){
179    if (SIn->Eof()){
180      if (AtEof){throw THttpEx(heUnexpectedEof);}
181      AtEof=true; return 0;
182    } else {
183      Ch=SIn->GetCh(); return Ch;
184    }
185  }
186  char THttpLx::GetCh(){
187    if (EofChPrS.Empty()){
188      if (SIn->Eof()){
189        if (AtEof){throw THttpEx(heUnexpectedEof);}
190        AtEof=true; SfMem+=Ch; Ch=TCh::NullCh; return Ch;
191      } else {
192        SfMem+=Ch; Ch=SIn->GetCh(); return Ch;
193      }
194    } else {
195      SfMem+=Ch;
196      AtEof=EofChPrS.Top().Val1; Ch=EofChPrS.Top().Val2; EofChPrS.Pop();
197      return Ch;
198    }
199  }
200  void THttpLx::GetRest(){
201    while ((!SIn->Eof())&&(!EofChPrS.Empty())){GetCh();}
202    if (!SIn->Eof()){SfMem+=Ch;}
203    TMem RestMem; TMem::LoadMem(SIn, RestMem);
204    SfMem+=RestMem;
205  }
206  THttpRqMethod THttpLx::GetRqMethod(){
207    TChA MethodNm;
208    while (!Eof() && ChDef.IsAlpha(Ch)){
209      MethodNm+=Ch; GetCh();}
210    THttpRqMethod Method=hrmUndef;
211    if (MethodNm==THttp::GetMethodNm){Method=hrmGet;}
212    else if (MethodNm==THttp::HeadMethodNm){Method=hrmHead;}
213    else if (MethodNm==THttp::PostMethodNm){Method=hrmPost;}
214    if (Method==hrmUndef){throw THttpEx(heMethodNmExpected);}
215    return Method;
216  }
217  PUrl THttpLx::GetUrl(){
218    TChA UrlChA;
219    while ((!Eof())&&(!ChDef.IsSp(Ch))){
220      UrlChA+=Ch; GetCh();}
221    if (UrlChA.Empty()){
222      throw THttpEx(heUrlEmpty);}
223    static TStr LocalBaseUrlStr="http:&bsol;&bsol;localhost/";
224    PUrl Url=PUrl(new TUrl(UrlChA, LocalBaseUrlStr));
225    if (!Url->IsOk()){
226      throw THttpEx(heBadUrl);}
227    return Url;
228  }
229  TStr THttpLx::GetUrlStr(){
230    TChA UrlChA;
231    while ((!Eof())&&(!ChDef.IsSp(Ch))){
232      UrlChA+=Ch; GetCh();}
233    if (UrlChA.Empty()){
234      throw THttpEx(heUrlEmpty);}
235    return UrlChA;
236  }
237  bool THttpLx::IsRespStatusLn(){
238    static const TChA MouldChA="http/N.N NNN ";
239    TChA TestChA(MouldChA);
240    int TestLen=TestChA.Len();
241    if (1+Len()<TestLen){return false;}
242    TestChA.PutCh(0, ChDef.GetLcCh(Ch));
243    {for (int ChN=1; ChN<TestLen; ChN++){
244      TestChA.PutCh(ChN, ChDef.GetLcCh(GetCh()));}}
245    {for (int ChN=1; ChN<TestLen; ChN++){
246      PutCh(TestChA[TestLen-ChN-1]);}}
247    {for (int ChN=0; ChN<MouldChA.Len(); ChN++){
248      if (MouldChA[ChN]=='N'){
249        if (!ChDef.IsDigit(TestChA[ChN])){return false;}
250      } else {
251        if (MouldChA[ChN]!=TestChA[ChN]){return false;}
252      }
253    }}
254    return true;
255  }
256  TStr THttpLx::GetRespReasonPhrase(){
257    GetLws();
258    TChA RPStr;
259    while (!Eof()&&ChDef.IsText(Ch)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)){
260      RPStr+=Ch; GetCh();}
261    return RPStr;
262  }
263  void THttpLx::GetWs(){
264    while (!Eof()&&((Ch==' ')||(Ch==TCh::TabCh))){GetCh();}
265  }
266  bool THttpLx::IsLws(){
267    if ((Ch==' ')||(Ch==TCh::TabCh)){
268      return true;
269    } else
270    if (Ch==TCh::CrCh){
271      GetCh();
272      if (Ch==TCh::LfCh){
273        GetCh(); bool Ok=(Ch==' ')||(Ch==TCh::TabCh);
274        PutCh(TCh::LfCh); PutCh(TCh::CrCh); return Ok;
275      } else {
276        PutCh(TCh::CrCh); return false;
277      }
278    } else
279    if (Ch==TCh::LfCh){
280      GetCh(); bool Ok=(Ch==' ')||(Ch==TCh::TabCh);
281      PutCh(TCh::LfCh); return Ok;
282    } else {
283      return false;
284    }
285  }
286  void THttpLx::GetLws(){
287    forever {
288      while ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
289      if (Ch==TCh::CrCh){
290        GetCh();
291        if (Ch==TCh::LfCh){
292          GetCh();
293          if ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
294          else {PutCh(TCh::LfCh); PutCh(TCh::CrCh); break;}
295        } else {
296          PutCh(TCh::CrCh); break;
297        }
298      } else
299      if (Ch==TCh::LfCh){
300        GetCh();
301        if ((Ch==' ')||(Ch==TCh::TabCh)){GetCh();}
302        else {PutCh(TCh::LfCh); break;}
303      } else {
304        break;
305      }
306    }
307  }
308  bool THttpLx::IsCrLf(){
309    if (Ch==TCh::CrCh){
310      GetCh(); bool Ok=(Ch==TCh::LfCh); PutCh(TCh::CrCh); return Ok;
311    } else
312    if (Ch==TCh::LfCh){
313      return true;
314    } else {
315      return false;
316    }
317  }
318  void THttpLx::GetCrLf(){
319    if (Ch==TCh::CrCh){
320      GetCh();
321      if (Ch==TCh::LfCh){GetCh();} else {throw THttpEx(heCrLfExpected);}
322    } else
323    if (Ch==TCh::LfCh){
324      GetCh();
325    } else {
326      throw THttpEx(heCrLfExpected);
327    }
328  }
329  void THttpLx::GetPeriod(){
330    GetWs();
331    if (Ch!='.'){throw THttpEx(hePeriodExpected);}
332    GetCh();
333  }
334  TStr THttpLx::GetToken(const TStr& ExpectStr){
335    GetLws();
336    TChA TokenStr;
337    while (!Eof() && !ChDef.IsCtl(Ch) && !ChDef.IsSpec(Ch)){
338      TokenStr+=Ch; GetCh();}
339    if (TokenStr.Empty()){throw THttpEx(heTokenExpected);}
340    if (!ExpectStr.Empty()){
341      if (GetNrStr(ExpectStr)!=GetNrStr(TokenStr)){
342        throw THttpEx(heInvalidToken);}
343    }
344    return TokenStr;
345  }
346  TStr THttpLx::GetSpec(const TStr& ExpectStr){
347    GetLws();
348    if (!ChDef.IsSpec(Ch)){throw THttpEx(heTSpecExpected);}
349    TStr SpecStr(Ch); GetCh();
350    if (!ExpectStr.Empty()){
351      if (ExpectStr!=SpecStr){throw THttpEx(heInvalidTSpec);}}
352    return SpecStr;
353  }
354  int THttpLx::GetInt(const int& RqPlaces){
355    GetLws();
356    if (!ChDef.IsDigit(Ch)){throw THttpEx(heNumExpected);}
357    int Int=0; int CurPlaces=0;
358    do {Int=Int*10+Ch-'0'; CurPlaces++; GetCh();
359    } while ((CurPlaces<RqPlaces)&&(ChDef.IsDigit(Ch)));
360    if (RqPlaces!=-1){
361      if (CurPlaces!=RqPlaces){throw THttpEx(heInvalidNumPlaces);}}
362    return Int;
363  }
364  TStr THttpLx::GetFldVal(){
365    TChA FldValStr;
366    do {
367      GetLws();
368      while (!Eof()&&ChDef.IsText(Ch)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)){
369        FldValStr+=Ch; GetCh();}
370      if (IsLws()){FldValStr+=' ';}
371    } while (IsLws());
372    return FldValStr;
373  }
374  class THttpChRet{
375    PSIn SIn;
376    int Chs, ChN;
377    THttpExCd HttpExCd;
378  public:
379    THttpChRet(const PSIn& _SIn, const THttpExCd& _HttpExCd):
380      SIn(_SIn), Chs(SIn->Len()), ChN(0), HttpExCd(_HttpExCd){}
381    THttpChRet& operator=(const THttpChRet&){Fail; return *this;}
382    bool Eof(){return ChN==Chs;}
383    char GetCh(){
384      if (ChN>=Chs){throw THttpEx(HttpExCd);}
385      ChN++; return SIn->GetCh();}
386  };
387  void THttpRq::ParseSearch(const TStr& SearchStr){
388    PSIn SIn=TStrIn::New(SearchStr);
389    THttpChRet ChRet(SIn, heBadSearchStr);
390    try {
391    if (ChRet.Eof()){return;}
392    if (ChRet.GetCh()!='?'){
393      throw THttpEx(heBadSearchStr);}
394    TChA KeyNm; TChA ValStr;
395    while (!ChRet.Eof()){
396      char Ch; KeyNm.Clr(); ValStr.Clr();
397      while ((Ch=ChRet.GetCh())!='='){
398        switch (Ch){
399          case '%':{
400            char Ch1=ChRet.GetCh();
401  		  if (!TCh::IsHex(Ch1)) { throw THttpEx(heBadSearchStr); }
402  		  char Ch2=ChRet.GetCh();
403  		  if (!TCh::IsHex(Ch2)) { throw THttpEx(heBadSearchStr); }
404            KeyNm.AddCh(char(16*TCh::GetHex(Ch1)+TCh::GetHex(Ch2)));} break;
405          case '+': KeyNm.AddCh(' '); break;
406          case '&': throw THttpEx(heBadSearchStr);
407          default: KeyNm.AddCh(Ch);
408        }
409      }
410      if (Ch!='='){
411        throw THttpEx(heBadSearchStr);}
412      while ((!ChRet.Eof())&&((Ch=ChRet.GetCh())!='&')){
413        switch (Ch){
414          case '%':{
415            char Ch1=ChRet.GetCh();
416  		  if (!TCh::IsHex(Ch1)) { throw THttpEx(heBadSearchStr); }
417            char Ch2=ChRet.GetCh();
418  		  if (!TCh::IsHex(Ch2)) { throw THttpEx(heBadSearchStr); }
419            ValStr.AddCh(char(16*TCh::GetHex(Ch1)+TCh::GetHex(Ch2)));} break;
420          case '+': ValStr.AddCh(' '); break;
421          case '&': throw THttpEx(heBadSearchStr);
422          default: ValStr.AddCh(Ch);
423        }
424      }
425      UrlEnv->AddToKeyVal(KeyNm, ValStr);
426      }
427    }
428    catch (const THttpEx&){Ok=false;}
429  }
430  void THttpRq::ParseHttpRq(const PSIn& SIn){
431    THttpLx Lx(SIn);
432    Ok=false;
433    CompleteP=false;
434    Method=Lx.GetRqMethod();
435    Lx.GetWs();
436    TStr UrlStr=Lx.GetUrlStr();
437    Lx.GetWs();
438    Lx.GetToken(THttp::HttpStr); Lx.GetSpec(THttp::SlashStr);
439    MajorVerN=Lx.GetInt(1); Lx.GetPeriod(); MinorVerN=Lx.GetInt(1);
440    Lx.GetCrLf();
441    while ((!Lx.Eof())&&(!Lx.IsCrLf())){
442      TStr FldNm=Lx.GetToken(); Lx.GetSpec(THttp::ColonStr);
443      TStr FldVal=Lx.GetFldVal();
444      Lx.GetCrLf();
445      TStr NrFldNm=THttpLx::GetNrStr(FldNm);
446      FldNmToValH.AddDat(NrFldNm, FldVal);
447    }
448    if (!Lx.IsCrLf()){return;} 
449    Lx.GetCrLf();
450    HdStr=Lx.GetMemSf().GetAsStr();
451    Lx.ClrMemSf();
452    Lx.GetRest();
453    BodyMem=Lx.GetMemSf();
454    int ContLen=GetFldVal(THttp::ContLenFldNm).GetInt(-1);
455    if (ContLen==-1){
456      CompleteP=true;
457    } else {
458      if (ContLen<=BodyMem.Len()){
459        CompleteP=true;
460        BodyMem.Trunc(ContLen);
461      } else {
462        CompleteP=false;
463      }
464    }
465    if (CompleteP){
466      const TStr LocalBaseUrlStr="http:&bsol;&bsol;localhost/";
467      Url=TUrl::New(UrlStr, LocalBaseUrlStr);
468      if (!Url->IsOk()){
469        throw THttpEx(heBadUrl);}
470    }
471    TStr SearchStr;
472    if (Method==hrmGet){
473      SearchStr=Url->GetSearchStr();
474    } else
475    if ((Method==hrmPost)&&(
476     (!IsFldNm(THttp::ContTypeFldNm))||
477     (GetFldVal(THttp::ContTypeFldNm)==THttp::TextHtmlFldVal)||
478     (GetFldVal(THttp::ContTypeFldNm)==THttp::AppW3FormFldVal))){
479      SearchStr=TStr("?")+BodyMem.GetAsStr();
480    }
481    ParseSearch(SearchStr);
482    Ok=true;
483  }
484  THttpRq::THttpRq(const PSIn& SIn):
485    Ok(false), MajorVerN(0), MinorVerN(0), Method(hrmUndef),
486    FldNmToValH(), UrlEnv(TUrlEnv::New()),
487    HdStr(), BodyMem(){
488    try {
489      ParseHttpRq(SIn);
490    }
491    catch (const THttpEx&){Ok=false;}
492  }
493  THttpRq::THttpRq(
494   const THttpRqMethod& _Method, const PUrl& _Url,
495   const TStr& ContTypeFldVal, const TMem& _BodyMem, const int& FetchId):
496    Ok(false),
497    MajorVerN(1), MinorVerN(0),
498    Method(_Method),
499    Url(_Url),
500    FldNmToValH(),
501    UrlEnv(TUrlEnv::New()),
502    HdStr(), BodyMem(_BodyMem){
503    TChA HdChA;
504    if (Url->IsOk()){
505      TStr AbsPath=Url->GetPathStr()+Url->GetSearchStr();
506      HdChA+=GetMethodNm(); HdChA+=' '; HdChA+=AbsPath; HdChA+=" HTTP/1.0\r\n";
507    }
508    if (!ContTypeFldVal.Empty()){
509      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::ContTypeFldNm), ContTypeFldVal);
510      HdChA+=THttpLx::GetNrStr(THttp::ContTypeFldNm); HdChA+=": ";
511      HdChA+=ContTypeFldVal; HdChA+="\r\n";
512    }
513    if (Url->IsOk()){
514      TStr HostNm=Url->GetHostNm();
515      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::HostFldNm), HostNm);
516      HdChA+=THttpLx::GetNrStr(THttp::HostFldNm); HdChA+=": ";
517      HdChA+=HostNm; HdChA+="\r\n";
518      ParseSearch(Url->GetSearchStr());
519    }
520    if (Url->IsOk()&&(FetchId!=-1)){
521      TStr FetchIdStr=TInt::GetStr(FetchId);
522      FldNmToValH.AddDat(THttpLx::GetNrStr(THttp::FetchIdFldNm), FetchIdStr);
523      HdChA+=THttpLx::GetNrStr(THttp::FetchIdFldNm); HdChA+=": ";
524      HdChA+=FetchIdStr; HdChA+="\r\n";
525    }
526    if (Url->IsOk()){
527      HdChA+="\r\n";
528      HdStr=HdChA;
529    }
530    Ok=true;
531  }
532  const TStr& THttpRq::GetMethodNm() const {
533    switch (Method){
534      case hrmGet: return THttp::GetMethodNm;
535      case hrmHead: return THttp::HeadMethodNm;
536      case hrmPost: return THttp::PostMethodNm;
537      default: return  THttp::UndefMethodNm;
538    }
539  }
540  bool THttpRq::IsFldNm(const TStr& FldNm) const {
541    return FldNmToValH.IsKey(THttpLx::GetNrStr(FldNm));
542  }
543  TStr THttpRq::GetFldVal(const TStr& FldNm) const {
544    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
545    if (FldNmToValH.IsKey(NrFldNm)){
546      return FldNmToValH.GetDat(NrFldNm);
547    } else {
548      return TStr();
549    }
550  }
551  bool THttpRq::IsFldVal(const TStr& FldNm, const TStr& FldVal) const {
552    return THttpLx::GetNrStr(FldVal)==THttpLx::GetNrStr(GetFldVal(FldNm));
553  }
554  void THttpRq::AddFldVal(const TStr& FldNm, const TStr& FldVal){
555    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
556    FldNmToValH.AddDat(NrFldNm, FldVal);
557  }
558  const TStrStrH& THttpRq::GetFldValH() const {
559  	return FldNmToValH;
560  }
561  TStr THttpRq::GetStr() const {
562    TChA ChA;
563    ChA+=GetMethodNm(); ChA+=' ';
564    ChA+=Url->GetUrlStr(); ChA+=' ';
565    ChA+="HTTP/1.0\r\n";
566    for (int FldN=0; FldN<FldNmToValH.Len(); FldN++){
567      ChA+=FldNmToValH.GetKey(FldN); ChA+=": ";
568      ChA+=FldNmToValH[FldN]; ChA+="\r\n";
569    }
570    if (!BodyMem.Empty()) {
571      ChA+=THttp::ContLenFldNm; ChA+=": ";
572      ChA+=TInt::GetStr(BodyMem.Len()); ChA+="\r\n";
573    }
574    ChA+="\r\n";
575    ChA+=BodyMem.GetAsStr();
576    return ChA;
577  }
578  void THttpResp::AddHdFld(const TStr& FldNm, const TStr& FldVal, TChA& HdChA){
579    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
580    FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
581    HdChA+=FldNm; HdChA+=": "; HdChA+=FldVal; HdChA+="\r\n";
582  }
583  void THttpResp::ParseHttpResp(const PSIn& SIn){
584    THttpLx Lx(SIn);
585    if (Lx.Eof()){
586      MajorVerN=0; MinorVerN=9; StatusCd=204;
587      HdStr.Clr(); BodyMem.Clr();
588    } else {
589      if (Lx.IsRespStatusLn()){
590        Lx.GetToken(THttp::HttpStr); Lx.GetSpec(THttp::SlashStr);
591        MajorVerN=Lx.GetInt(1); Lx.GetPeriod(); MinorVerN=Lx.GetInt(1);
592        StatusCd=Lx.GetInt(3);
593        ReasonPhrase=Lx.GetRespReasonPhrase();
594        Lx.GetCrLf();
595        while (!Lx.IsCrLf()){
596          TStr FldNm=Lx.GetToken(); Lx.GetSpec(THttp::ColonStr);
597          TStr FldVal=Lx.GetFldVal();
598          Lx.GetCrLf();
599          TStr NrFldNm=THttpLx::GetNrStr(FldNm);
600          FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
601        }
602        Lx.GetCrLf();
603        HdStr=Lx.GetMemSf().GetAsStr();
604        Lx.ClrMemSf();
605        Lx.GetRest();
606        BodyMem=Lx.GetMemSf();
607      } else {
608        MajorVerN=0; MinorVerN=9; StatusCd=200;
609        HdStr.Clr();
610        Lx.ClrMemSf();
611        Lx.GetRest();
612        BodyMem=Lx.GetMemSf();
613      }
614    }
615    Ok=true;
616  }
617  THttpResp::THttpResp(const int& _StatusCd, const TStr& ContTypeVal,
618   const bool& CacheCtrlP, const PSIn& BodySIn, const TStr LocStr):
619    Ok(true), MajorVerN(1), MinorVerN(0), StatusCd(_StatusCd), ReasonPhrase(),
620    FldNmToValVH(20), HdStr(), BodyMem(){
621    ReasonPhrase=THttp::GetReasonPhrase(StatusCd);
622    TChA HdChA;
623    HdChA+="HTTP/"; HdChA+=TInt::GetStr(MajorVerN); HdChA+=".";
624    HdChA+=TInt::GetStr(MinorVerN); HdChA+=' ';
625    HdChA+=TInt::GetStr(StatusCd); HdChA+=' ';
626    HdChA+=ReasonPhrase;
627    HdChA+="\r\n";
628    if (!LocStr.Empty()){
629      AddHdFld("Location", LocStr, HdChA);}
630    if (!BodySIn.Empty()){
631      AddHdFld(THttp::ContTypeFldNm, ContTypeVal, HdChA);
632      AddHdFld(THttp::AcceptRangesFldNm, "bytes", HdChA);
633      TStr ContLenVal=TInt::GetStr(BodySIn->Len());
634      AddHdFld(THttp::ContLenFldNm, ContLenVal, HdChA);
635      if (!CacheCtrlP){
636        AddHdFld(THttp::CacheCtrlFldNm, "no-cache", HdChA);}
637    }
638    HdChA+="\r\n";
639    HdStr=HdChA;
640    if (!BodySIn.Empty()){
641      TMem::LoadMem(BodySIn, BodyMem);}
642  }
643  THttpResp::THttpResp(const PSIn& SIn):
644    Ok(false), MajorVerN(0), MinorVerN(0), StatusCd(-1), ReasonPhrase(),
645    FldNmToValVH(20), HdStr(), BodyMem(){
646    try {
647      ParseHttpResp(SIn);
648    }
649    catch (const THttpEx&){Ok=false;}
650  }
651  bool THttpResp::IsFldNm(const TStr& FldNm) const {
652    return FldNmToValVH.IsKey(THttpLx::GetNrStr(FldNm));
653  }
654  TStr THttpResp::GetFldVal(const TStr& FldNm, const int& ValN) const {
655    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
656    if (FldNmToValVH.IsKey(NrFldNm)){
657      const TStrV& ValV=FldNmToValVH.GetDat(NrFldNm);
658      if (ValV.Len()>0){return ValV[ValN];} else {return TStr();}
659    } else {
660      return TStr();
661    }
662  }
663  void THttpResp::GetFldValV(const TStr& FldNm, TStrV& FldValV) const {
664    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
665    if (FldNmToValVH.IsKey(NrFldNm)){
666      FldValV=FldNmToValVH.GetDat(NrFldNm);
667    } else {
668      FldValV.Clr();
669    }
670  }
671  bool THttpResp::IsFldVal(const TStr& FldNm, const TStr& FldVal) const {
672    return THttpLx::GetNrStr(FldVal)==THttpLx::GetNrStr(GetFldVal(FldNm));
673  }
674  void THttpResp::AddFldVal(const TStr& FldNm, const TStr& FldVal){
675    TStr NrFldNm=THttpLx::GetNrStr(FldNm);
676    FldNmToValVH.AddDat(NrFldNm).Add(FldVal);
677    if (HdStr.IsSuffix("\r\n\r\n")){
678      TChA HdChA=HdStr;
679      HdChA.Pop(); HdChA.Pop(); 
680      HdChA+=NrFldNm; HdChA+=": "; HdChA+=FldVal;
681      HdChA+="\r\n\r\n";
682      HdStr=HdChA;
683    }
684  }
685  void THttpResp::GetCookieKeyValDmPathQuV(TStrQuV& CookieKeyValDmPathQuV){
686    CookieKeyValDmPathQuV.Clr();
687    TStrV CookieFldValV; GetFldValV(THttp::SetCookieFldNm, CookieFldValV);
688    for (int CookieN=0; CookieN<CookieFldValV.Len(); CookieN++){
<span onclick='openModal()' class='match'>689      TStr CookieFldVal=CookieFldValV[CookieN];
690      TStrV KeyValStrV;
691      CookieFldVal.SplitOnAllCh(';', KeyValStrV, true);
692      TStrPrV KeyValPrV; TStr DmNm; TStr PathStr;
693      for (int KeyValStrN=0; KeyValStrN<KeyValStrV.Len(); KeyValStrN++){
694        TStr KeyValStr=KeyValStrV[KeyValStrN];
695        TStr KeyNm; TStr ValStr; 
696        if (KeyValStr.IsChIn('=')){
</span>697          KeyValStrV[KeyValStrN].SplitOnCh(KeyNm, '=', ValStr);
698          KeyNm.ToTrunc(); ValStr.ToTrunc();
699        } else {
700          KeyNm=KeyValStr.GetTrunc();
701        }
702        if (KeyNm=="expires"){}
703        else if (KeyNm=="domain"){DmNm=ValStr;}
704        else if (KeyNm=="path"){PathStr=ValStr;}
705        else if (KeyNm=="expires"){}
706        else if (KeyNm=="secure"){}
707        else if (KeyNm=="httponly"){}
708        else if (!KeyNm.Empty()){
709          KeyValPrV.Add(TStrPr(KeyNm, ValStr));
710        }
711      }
712      for (int KeyValPrN=0; KeyValPrN<KeyValPrV.Len(); KeyValPrN++){
713        TStr KeyNm=KeyValPrV[KeyValPrN].Val1;
714        TStr ValStr=KeyValPrV[KeyValPrN].Val2;
715        CookieKeyValDmPathQuV.Add(TStrQu(KeyNm, ValStr, DmNm, PathStr));
716      }
717    }
718  }
719  PSIn THttpResp::GetSIn() const {
720    TMOut MOut(HdStr.Len()+BodyMem.Len());
721    MOut.PutStr(HdStr); MOut.PutMem(BodyMem);
722    return MOut.GetSIn();
723  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-tbval.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-http.cpp</div>
                </div>
                <div class="column column_space"><pre><code>98      int SplitVals=GetSplitVals(SplitN);
99      for (int ValN=0; ValN<SplitVals; ValN++){
100        TTbVal TbVal=GetSplitVal(SplitN, ValN);
101        if (ValN>0){ChA+=' ';}
</pre></code></div>
                <div class="column column_space"><pre><code>689      TStr CookieFldVal=CookieFldValV[CookieN];
690      TStrV KeyValStrV;
691      CookieFldVal.SplitOnAllCh(';', KeyValStrV, true);
692      TStrPrV KeyValPrV; TStr DmNm; TStr PathStr;
693      for (int KeyValStrN=0; KeyValStrN<KeyValStrV.Len(); KeyValStrN++){
694        TStr KeyValStr=KeyValStrV[KeyValStrN];
695        TStr KeyNm; TStr ValStr; 
696        if (KeyValStr.IsChIn('=')){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    