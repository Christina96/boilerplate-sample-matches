
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.cpp</h3>
            <pre><code>1  #include &lt;nano/crypto_lib/random_pool.hpp&gt;
2  #include &lt;nano/lib/config.hpp&gt;
3  #include &lt;nano/lib/jsonconfig.hpp&gt;
4  #include &lt;nano/lib/rpcconfig.hpp&gt;
5  #include &lt;nano/lib/tomlconfig.hpp&gt;
6  #include &lt;nano/node/nodeconfig.hpp&gt;
7  #include &lt;nano/node/transport/transport.hpp&gt;
8  #include &lt;boost/format.hpp&gt;
9  #include &lt;cryptopp/words.h&gt;
10  namespace
11  {
12  char const * preconfigured_peers_key = &quot;preconfigured_peers&quot;;
13  char const * signature_checker_threads_key = &quot;signature_checker_threads&quot;;
14  char const * pow_sleep_interval_key = &quot;pow_sleep_interval&quot;;
15  std::string const default_live_peer_network = nano::get_env_or_default (&quot;NANO_DEFAULT_PEER&quot;, &quot;peering.nano.org&quot;);
16  std::string const default_beta_peer_network = nano::get_env_or_default (&quot;NANO_DEFAULT_PEER&quot;, &quot;peering-beta.nano.org&quot;);
17  std::string const default_test_peer_network = nano::get_env_or_default (&quot;NANO_DEFAULT_PEER&quot;, &quot;peering-test.nano.org&quot;);
18  }
19  nano::node_config::node_config (nano::network_params &amp; network_params) :
20  	node_config (std::nullopt, nano::logging (), network_params)
21  {
22  }
23  nano::node_config::node_config (const std::optional&lt;uint16_t&gt; &amp; peering_port_a, nano::logging const &amp; logging_a, nano::network_params &amp; network_params) :
24  	network_params{ network_params },
25  	peering_port{ peering_port_a },
26  	logging{ logging_a },
27  	websocket_config{ network_params.network },
28  	ipc_config{ network_params.network },
29  	external_address{ boost::asio::ip::address_v6{}.to_string () }
30  {
31  	if (peering_port == 0)
32  	{
33  	}
34  	switch (network_params.network.network ())
35  	{
36  		case nano::networks::nano_dev_network:
37  			enable_voting = true;
38  			preconfigured_representatives.push_back (network_params.ledger.genesis-&gt;account ());
39  			break;
40  		case nano::networks::nano_beta_network:
41  		{
42  			preconfigured_peers.emplace_back (default_beta_peer_network);
43  			nano::account offline_representative;
44  			release_assert (!offline_representative.decode_account (&quot;nano_1defau1t9off1ine9rep99999999999999999999999999999999wgmuzxxy&quot;));
45  			preconfigured_representatives.emplace_back (offline_representative);
46  			break;
47  		}
48  		case nano::networks::nano_live_network:
49  			preconfigured_peers.emplace_back (default_live_peer_network);
50  			preconfigured_representatives.emplace_back (&quot;A30E0A32ED41C8607AA9212843392E853FCBCB4E7CB194E35C94F07F91DE59EF&quot;);
51  			preconfigured_representatives.emplace_back (&quot;67556D31DDFC2A440BF6147501449B4CB9572278D034EE686A6BEE29851681DF&quot;);
52  			preconfigured_representatives.emplace_back (&quot;5C2FBB148E006A8E8BA7A75DD86C9FE00C83F5FFDBFD76EAA09531071436B6AF&quot;);
53  			preconfigured_representatives.emplace_back (&quot;AE7AC63990DAAAF2A69BF11C913B928844BF5012355456F2F164166464024B29&quot;);
54  			preconfigured_representatives.emplace_back (&quot;BD6267D6ECD8038327D2BCC0850BDF8F56EC0414912207E81BCF90DFAC8A4AAA&quot;);
55  			preconfigured_representatives.emplace_back (&quot;2399A083C600AA0572F5E36247D978FCFC840405F8D4B6D33161C0066A55F431&quot;);
56  			preconfigured_representatives.emplace_back (&quot;2298FAB7C61058E77EA554CB93EDEEDA0692CBFCC540AB213B2836B29029E23A&quot;);
57  			preconfigured_representatives.emplace_back (&quot;3FE80B4BC842E82C1C18ABFEEC47EA989E63953BC82AC411F304D13833D52A56&quot;);
58  			break;
59  		case nano::networks::nano_test_network:
60  			preconfigured_peers.push_back (default_test_peer_network);
61  			preconfigured_representatives.push_back (network_params.ledger.genesis-&gt;account ());
62  			break;
63  		default:
64  			debug_assert (false);
65  			break;
66  	}
67  }
68  nano::error nano::node_config::serialize_toml (nano::tomlconfig &amp; toml) const
69  {
70  	if (peering_port.has_value ())
71  	{
72  		toml.put (&quot;peering_port&quot;, *peering_port, &quot;Node peering port.\ntype:uint16&quot;);
73  	}
74  	toml.put (&quot;bootstrap_fraction_numerator&quot;, bootstrap_fraction_numerator, &quot;Change bootstrap threshold (online stake / 256 * bootstrap_fraction_numerator).\ntype:uint32&quot;);
75  	toml.put (&quot;receive_minimum&quot;, receive_minimum.to_string_dec (), &quot;Minimum receive amount. Only affects node wallets. A large amount is recommended to avoid automatic work generation for tiny transactions.\ntype:string,amount,raw&quot;);
76  	toml.put (&quot;online_weight_minimum&quot;, online_weight_minimum.to_string_dec (), &quot;When calculating online weight, the node is forced to assume at least this much voting weight is online, thus setting a floor for voting weight to confirm transactions at online_weight_minimum * \&quot;quorum delta\&quot;.\ntype:string,amount,raw&quot;);
77  	toml.put (&quot;election_hint_weight_percent&quot;, election_hint_weight_percent, &quot;Percentage of online weight to hint at starting an election. Defaults to 10.\ntype:uint32,[5,50]&quot;);
78  	toml.put (&quot;password_fanout&quot;, password_fanout, &quot;Password fanout factor.\ntype:uint64&quot;);
79  	toml.put (&quot;io_threads&quot;, io_threads, &quot;Number of threads dedicated to I/O operations. Defaults to the number of CPU threads, and at least 4.\ntype:uint64&quot;);
80  	toml.put (&quot;network_threads&quot;, network_threads, &quot;Number of threads dedicated to processing network messages. Defaults to the number of CPU threads, and at least 4.\ntype:uint64&quot;);
81  	toml.put (&quot;work_threads&quot;, work_threads, &quot;Number of threads dedicated to CPU generated work. Defaults to all available CPU threads.\ntype:uint64&quot;);
82  	toml.put (&quot;background_threads&quot;, background_threads, &quot;Number of threads dedicated to background node work, including handling of RPC requests. Defaults to all available CPU threads.\ntype:uint64&quot;);
83  	toml.put (&quot;signature_checker_threads&quot;, signature_checker_threads, &quot;Number of additional threads dedicated to signature verification. Defaults to number of CPU threads / 2.\ntype:uint64&quot;);
84  	toml.put (&quot;enable_voting&quot;, enable_voting, &quot;Enable or disable voting. Enabling this option requires additional system resources, namely increased CPU, bandwidth and disk usage.\ntype:bool&quot;);
85  	toml.put (&quot;bootstrap_connections&quot;, bootstrap_connections, &quot;Number of outbound bootstrap connections. Must be a power of 2. Defaults to 4.\nWarning: a larger amount of connections may use substantially more system memory.\ntype:uint64&quot;);
86  	toml.put (&quot;bootstrap_connections_max&quot;, bootstrap_connections_max, &quot;Maximum number of inbound bootstrap connections. Defaults to 64.\nWarning: a larger amount of connections may use additional system memory.\ntype:uint64&quot;);
87  	toml.put (&quot;bootstrap_initiator_threads&quot;, bootstrap_initiator_threads, &quot;Number of threads dedicated to concurrent bootstrap attempts. Defaults to 1.\nWarning: a larger amount of attempts may use additional system memory and disk IO.\ntype:uint64&quot;);
88  	toml.put (&quot;bootstrap_serving_threads&quot;, bootstrap_serving_threads, &quot;Number of threads dedicated to serving bootstrap data to other peers. Defaults to half the number of CPU threads, and at least 2.\ntype:uint64&quot;);
89  	toml.put (&quot;bootstrap_frontier_request_count&quot;, bootstrap_frontier_request_count, &quot;Number frontiers per bootstrap frontier request. Defaults to 1048576.\ntype:uint32,[1024..4294967295]&quot;);
90  	toml.put (&quot;block_processor_batch_max_time&quot;, block_processor_batch_max_time.count (), &quot;The maximum time the block processor can continuously process blocks for.\ntype:milliseconds&quot;);
91  	toml.put (&quot;block_process_timeout&quot;, block_process_timeout.count (), &quot;Time to wait for block processing result.\ntype:seconds&quot;);
92  	toml.put (&quot;allow_local_peers&quot;, allow_local_peers, &quot;Enable or disable local host peering.\ntype:bool&quot;);
93  	toml.put (&quot;vote_minimum&quot;, vote_minimum.to_string_dec (), &quot;Local representatives do not vote if the delegated weight is under this threshold. Saves on system resources.\ntype:string,amount,raw&quot;);
94  	toml.put (&quot;vote_generator_delay&quot;, vote_generator_delay.count (), &quot;Delay before votes are sent to allow for efficient bundling of hashes in votes.\ntype:milliseconds&quot;);
95  	toml.put (&quot;vote_generator_threshold&quot;, vote_generator_threshold, &quot;Number of bundled hashes required for an additional generator delay.\ntype:uint64,[1..11]&quot;);
96  	toml.put (&quot;unchecked_cutoff_time&quot;, unchecked_cutoff_time.count (), &quot;Number of seconds before deleting an unchecked entry.\nWarning: lower values (e.g., 3600 seconds, or 1 hour) may result in unsuccessful bootstraps, especially a bootstrap from scratch.\ntype:seconds&quot;);
97  	toml.put (&quot;tcp_io_timeout&quot;, tcp_io_timeout.count (), &quot;Timeout for TCP connect-, read- and write operations.\nWarning: a low value (e.g., below 5 seconds) may result in TCP connections failing.\ntype:seconds&quot;);
98  	toml.put (&quot;pow_sleep_interval&quot;, pow_sleep_interval.count (), &quot;Time to sleep between batch work generation attempts. Reduces max CPU usage at the expense of a longer generation time.\ntype:nanoseconds&quot;);
99  	toml.put (&quot;external_address&quot;, external_address, &quot;The external address of this node (NAT). If not set, the node will request this information via UPnP.\ntype:string,ip&quot;);
100  	toml.put (&quot;external_port&quot;, external_port, &quot;The external port number of this node (NAT). Only used if external_address is set.\ntype:uint16&quot;);
101  	toml.put (&quot;tcp_incoming_connections_max&quot;, tcp_incoming_connections_max, &quot;Maximum number of incoming TCP connections.\ntype:uint64&quot;);
102  	toml.put (&quot;use_memory_pools&quot;, use_memory_pools, &quot;If true, allocate memory from memory pools. Enabling this may improve performance. Memory is never released to the OS.\ntype:bool&quot;);
103  	toml.put (&quot;confirmation_history_size&quot;, confirmation_history_size, &quot;Maximum confirmation history size. If tracking the rate of block confirmations, the websocket feature is recommended instead.\ntype:uint64&quot;);
104  	toml.put (&quot;active_elections_size&quot;, active_elections_size, &quot;Number of active elections. Elections beyond this limit have limited survival time.\nWarning: modifying this value may result in a lower confirmation rate.\ntype:uint64,[250..]&quot;);
105  	toml.put (&quot;bandwidth_limit&quot;, bandwidth_limit, &quot;Outbound traffic limit in bytes/sec after which messages will be dropped.\nNote: changing to unlimited bandwidth (0) is not recommended for limited connections.\ntype:uint64&quot;);
106  	toml.put (&quot;bandwidth_limit_burst_ratio&quot;, bandwidth_limit_burst_ratio, &quot;Burst ratio for outbound traffic shaping.\ntype:double&quot;);
107  	toml.put (&quot;bootstrap_bandwidth_limit&quot;, bootstrap_bandwidth_limit, &quot;Outbound bootstrap traffic limit in bytes/sec after which messages will be dropped.\nNote: changing to unlimited bandwidth (0) is not recommended for limited connections.\ntype:uint64&quot;);
108  	toml.put (&quot;bootstrap_bandwidth_burst_ratio&quot;, bootstrap_bandwidth_burst_ratio, &quot;Burst ratio for outbound bootstrap traffic.\ntype:double&quot;);
109  	toml.put (&quot;conf_height_processor_batch_min_time&quot;, conf_height_processor_batch_min_time.count (), &quot;Minimum write batching time when there are blocks pending confirmation height.\ntype:milliseconds&quot;);
110  	toml.put (&quot;backup_before_upgrade&quot;, backup_before_upgrade, &quot;Backup the ledger database before performing upgrades.\nWarning: uses more disk storage and increases startup time when upgrading.\ntype:bool&quot;);
111  	toml.put (&quot;max_work_generate_multiplier&quot;, max_work_generate_multiplier, &quot;Maximum allowed difficulty multiplier for work generation.\ntype:double,[1..]&quot;);
112  	toml.put (&quot;frontiers_confirmation&quot;, serialize_frontiers_confirmation (frontiers_confirmation), &quot;Mode controlling frontier confirmation rate.\ntype:string,{auto,always,disabled}&quot;);
113  	toml.put (&quot;max_queued_requests&quot;, max_queued_requests, &quot;Limit for number of queued confirmation requests for one channel, after which new requests are dropped until the queue drops below this value.\ntype:uint32&quot;);
114  	toml.put (&quot;rep_crawler_weight_minimum&quot;, rep_crawler_weight_minimum.to_string_dec (), &quot;Rep crawler minimum weight, if this is less than minimum principal weight then this is taken as the minimum weight a rep must have to be tracked. If you want to track all reps set this to 0. If you do not want this to influence anything then set it to max value. This is only useful for debugging or for people who really know what they are doing.\ntype:string,amount,raw&quot;);
115  	toml.put (&quot;backlog_scan_batch_size&quot;, backlog_scan_batch_size, &quot;Number of accounts per second to process when doing backlog population scan. Increasing this value will help unconfirmed frontiers get into election prioritization queue faster, however it will also increase resource usage. \ntype:uint&quot;);
116  	toml.put (&quot;backlog_scan_frequency&quot;, backlog_scan_frequency, &quot;Backlog scan divides the scan into smaller batches, number of which is controlled by this value. Higher frequency helps to utilize resources more uniformly, however it also introduces more overhead. The resulting number of accounts per single batch is `backlog_scan_batch_size / backlog_scan_frequency` \ntype:uint&quot;);
117  	auto work_peers_l (toml.create_array (&quot;work_peers&quot;, &quot;A list of \&quot;address:port\&quot; entries to identify work peers.&quot;));
118  	for (auto i (work_peers.begin ()), n (work_peers.end ()); i != n; ++i)
119  	{
120  		work_peers_l-&gt;push_back (boost::str (boost::format (&quot;%1%:%2%&quot;) % i-&gt;first % i-&gt;second));
121  	}
122  	auto preconfigured_peers_l (toml.create_array (&quot;preconfigured_peers&quot;, &quot;A list of \&quot;address\&quot; (hostname or ipv6 notation ip address) entries to identify preconfigured peers.\nThe contents of the NANO_DEFAULT_PEER environment variable are added to preconfigured_peers.&quot;));
123  	for (auto i (preconfigured_peers.begin ()), n (preconfigured_peers.end ()); i != n; ++i)
124  	{
125  		preconfigured_peers_l-&gt;push_back (*i);
126  	}
127  	auto preconfigured_representatives_l (toml.create_array (&quot;preconfigured_representatives&quot;, &quot;A list of representative account addresses used when creating new accounts in internal wallets.&quot;));
128  	for (auto i (preconfigured_representatives.begin ()), n (preconfigured_representatives.end ()); i != n; ++i)
129  	{
130  		preconfigured_representatives_l-&gt;push_back (i-&gt;to_account ());
131  	}
132  	nano::tomlconfig experimental_l;
133  	auto secondary_work_peers_l (experimental_l.create_array (&quot;secondary_work_peers&quot;, &quot;A list of \&quot;address:port\&quot; entries to identify work peers for secondary work generation.&quot;));
134  	for (auto i (secondary_work_peers.begin ()), n (secondary_work_peers.end ()); i != n; ++i)
135  	{
136  		secondary_work_peers_l-&gt;push_back (boost::str (boost::format (&quot;%1%:%2%&quot;) % i-&gt;first % i-&gt;second));
137  	}
138  	experimental_l.put (&quot;max_pruning_age&quot;, max_pruning_age.count (), &quot;Time limit for blocks age after pruning.\ntype:seconds&quot;);
139  	experimental_l.put (&quot;max_pruning_depth&quot;, max_pruning_depth, &quot;Limit for full blocks in chain after pruning.\ntype:uint64&quot;);
140  	toml.put_child (&quot;experimental&quot;, experimental_l);
141  	nano::tomlconfig callback_l;
142  	callback_l.put (&quot;address&quot;, callback_address, &quot;Callback address.\ntype:string,ip&quot;);
143  	callback_l.put (&quot;port&quot;, callback_port, &quot;Callback port number.\ntype:uint16&quot;);
144  	callback_l.put (&quot;target&quot;, callback_target, &quot;Callback target path.\ntype:string,uri&quot;);
145  	toml.put_child (&quot;httpcallback&quot;, callback_l);
146  	nano::tomlconfig logging_l;
147  	logging.serialize_toml (logging_l);
148  	toml.put_child (&quot;logging&quot;, logging_l);
149  	nano::tomlconfig websocket_l;
150  	websocket_config.serialize_toml (websocket_l);
151  	toml.put_child (&quot;websocket&quot;, websocket_l);
152  	nano::tomlconfig ipc_l;
153  	ipc_config.serialize_toml (ipc_l);
154  	toml.put_child (&quot;ipc&quot;, ipc_l);
155  	nano::tomlconfig diagnostics_l;
156  	diagnostics_config.serialize_toml (diagnostics_l);
157  	toml.put_child (&quot;diagnostics&quot;, diagnostics_l);
158  	nano::tomlconfig stat_l;
159  	stats_config.serialize_toml (stat_l);
160  	toml.put_child (&quot;statistics&quot;, stat_l);
161  	nano::tomlconfig rocksdb_l;
162  	rocksdb_config.serialize_toml (rocksdb_l);
163  	toml.put_child (&quot;rocksdb&quot;, rocksdb_l);
164  	nano::tomlconfig lmdb_l;
165  	lmdb_config.serialize_toml (lmdb_l);
166  	toml.put_child (&quot;lmdb&quot;, lmdb_l);
167  	nano::tomlconfig optimistic_l;
168  	optimistic_scheduler.serialize (optimistic_l);
169  	toml.put_child (&quot;optimistic_scheduler&quot;, optimistic_l);
170  	nano::tomlconfig bootstrap_ascending_l;
171  	bootstrap_ascending.serialize (bootstrap_ascending_l);
172  	toml.put_child (&quot;bootstrap_ascending&quot;, bootstrap_ascending_l);
173  	return toml.get_error ();
174  }
175  nano::error nano::node_config::deserialize_toml (nano::tomlconfig &amp; toml)
176  {
177  	try
178  	{
179  		if (toml.has_key (&quot;httpcallback&quot;))
180  		{
181  			auto callback_l (toml.get_required_child (&quot;httpcallback&quot;));
182  			callback_l.get&lt;std::string&gt; (&quot;address&quot;, callback_address);
183  			callback_l.get&lt;uint16_t&gt; (&quot;port&quot;, callback_port);
<span onclick='openModal()' class='match'>184  			callback_l.get&lt;std::string&gt; (&quot;target&quot;, callback_target);
185  		}
</span>186  		if (toml.has_key (&quot;logging&quot;))
187  		{
188  			auto logging_l (toml.get_required_child (&quot;logging&quot;));
189  			logging.deserialize_toml (logging_l);
190  		}
191  		if (toml.has_key (&quot;websocket&quot;))
192  		{
193  			auto websocket_config_l (toml.get_required_child (&quot;websocket&quot;));
194  			websocket_config.deserialize_toml (websocket_config_l);
195  		}
196  		if (toml.has_key (&quot;ipc&quot;))
197  		{
198  			auto ipc_config_l (toml.get_required_child (&quot;ipc&quot;));
199  			ipc_config.deserialize_toml (ipc_config_l);
200  		}
201  		if (toml.has_key (&quot;diagnostics&quot;))
202  		{
203  			auto diagnostics_config_l (toml.get_required_child (&quot;diagnostics&quot;));
204  			diagnostics_config.deserialize_toml (diagnostics_config_l);
205  		}
206  		if (toml.has_key (&quot;statistics&quot;))
207  		{
208  			auto stats_config_l (toml.get_required_child (&quot;statistics&quot;));
209  			stats_config.deserialize_toml (stats_config_l);
210  		}
211  		if (toml.has_key (&quot;rocksdb&quot;))
212  		{
213  			auto rocksdb_config_l (toml.get_required_child (&quot;rocksdb&quot;));
214  			rocksdb_config.deserialize_toml (rocksdb_config_l);
215  		}
216  		if (toml.has_key (&quot;optimistic_scheduler&quot;))
217  		{
218  			auto config_l = toml.get_required_child (&quot;optimistic_scheduler&quot;);
219  			optimistic_scheduler.deserialize (config_l);
220  		}
221  		if (toml.has_key (&quot;bootstrap_ascending&quot;))
222  		{
223  			auto config_l = toml.get_required_child (&quot;bootstrap_ascending&quot;);
224  			bootstrap_ascending.deserialize (config_l);
225  		}
226  		if (toml.has_key (&quot;work_peers&quot;))
227  		{
228  			work_peers.clear ();
229  			toml.array_entries_required&lt;std::string&gt; (&quot;work_peers&quot;, [this] (std::string const &amp; entry_a) {
230  				this-&gt;deserialize_address (entry_a, this-&gt;work_peers);
231  			});
232  		}
233  		if (toml.has_key (preconfigured_peers_key))
234  		{
235  			preconfigured_peers.clear ();
236  			toml.array_entries_required&lt;std::string&gt; (preconfigured_peers_key, [this] (std::string entry) {
237  				preconfigured_peers.push_back (entry);
238  			});
239  		}
240  		if (toml.has_key (&quot;preconfigured_representatives&quot;))
241  		{
242  			preconfigured_representatives.clear ();
243  			toml.array_entries_required&lt;std::string&gt; (&quot;preconfigured_representatives&quot;, [this, &amp;toml] (std::string entry) {
244  				nano::account representative{};
245  				if (representative.decode_account (entry))
246  				{
247  					toml.get_error ().set (&quot;Invalid representative account: &quot; + entry);
248  				}
249  				preconfigured_representatives.push_back (representative);
250  			});
251  		}
252  		if (preconfigured_representatives.empty ())
253  		{
254  			toml.get_error ().set (&quot;At least one representative account must be set&quot;);
255  		}
256  		auto receive_minimum_l (receive_minimum.to_string_dec ());
257  		if (toml.has_key (&quot;receive_minimum&quot;))
258  		{
259  			receive_minimum_l = toml.get&lt;std::string&gt; (&quot;receive_minimum&quot;);
260  		}
261  		if (receive_minimum.decode_dec (receive_minimum_l))
262  		{
263  			toml.get_error ().set (&quot;receive_minimum contains an invalid decimal amount&quot;);
264  		}
265  		auto online_weight_minimum_l (online_weight_minimum.to_string_dec ());
266  		if (toml.has_key (&quot;online_weight_minimum&quot;))
267  		{
268  			online_weight_minimum_l = toml.get&lt;std::string&gt; (&quot;online_weight_minimum&quot;);
269  		}
270  		if (online_weight_minimum.decode_dec (online_weight_minimum_l))
271  		{
272  			toml.get_error ().set (&quot;online_weight_minimum contains an invalid decimal amount&quot;);
273  		}
274  		auto vote_minimum_l (vote_minimum.to_string_dec ());
275  		if (toml.has_key (&quot;vote_minimum&quot;))
276  		{
277  			vote_minimum_l = toml.get&lt;std::string&gt; (&quot;vote_minimum&quot;);
278  		}
279  		if (vote_minimum.decode_dec (vote_minimum_l))
280  		{
281  			toml.get_error ().set (&quot;vote_minimum contains an invalid decimal amount&quot;);
282  		}
283  		auto delay_l = vote_generator_delay.count ();
284  		toml.get (&quot;vote_generator_delay&quot;, delay_l);
285  		vote_generator_delay = std::chrono::milliseconds (delay_l);
286  		toml.get&lt;unsigned&gt; (&quot;vote_generator_threshold&quot;, vote_generator_threshold);
287  		auto block_processor_batch_max_time_l = block_processor_batch_max_time.count ();
288  		toml.get (&quot;block_processor_batch_max_time&quot;, block_processor_batch_max_time_l);
289  		block_processor_batch_max_time = std::chrono::milliseconds (block_processor_batch_max_time_l);
290  		auto block_process_timeout_l = block_process_timeout.count ();
291  		toml.get (&quot;block_process_timeout&quot;, block_process_timeout_l);
292  		block_process_timeout = std::chrono::seconds{ block_process_timeout_l };
293  		auto unchecked_cutoff_time_l = static_cast&lt;unsigned long&gt; (unchecked_cutoff_time.count ());
294  		toml.get (&quot;unchecked_cutoff_time&quot;, unchecked_cutoff_time_l);
295  		unchecked_cutoff_time = std::chrono::seconds (unchecked_cutoff_time_l);
296  		auto tcp_io_timeout_l = static_cast&lt;unsigned long&gt; (tcp_io_timeout.count ());
297  		toml.get (&quot;tcp_io_timeout&quot;, tcp_io_timeout_l);
298  		tcp_io_timeout = std::chrono::seconds (tcp_io_timeout_l);
299  		if (toml.has_key (&quot;peering_port&quot;))
300  		{
301  			std::uint16_t peering_port_l{};
302  			toml.get_required&lt;uint16_t&gt; (&quot;peering_port&quot;, peering_port_l);
303  			peering_port = peering_port_l;
304  		}
305  		toml.get&lt;unsigned&gt; (&quot;bootstrap_fraction_numerator&quot;, bootstrap_fraction_numerator);
306  		toml.get&lt;unsigned&gt; (&quot;election_hint_weight_percent&quot;, election_hint_weight_percent);
307  		toml.get&lt;unsigned&gt; (&quot;password_fanout&quot;, password_fanout);
308  		toml.get&lt;unsigned&gt; (&quot;io_threads&quot;, io_threads);
309  		toml.get&lt;unsigned&gt; (&quot;work_threads&quot;, work_threads);
310  		toml.get&lt;unsigned&gt; (&quot;network_threads&quot;, network_threads);
311  		toml.get&lt;unsigned&gt; (&quot;background_threads&quot;, background_threads);
312  		toml.get&lt;unsigned&gt; (&quot;bootstrap_connections&quot;, bootstrap_connections);
313  		toml.get&lt;unsigned&gt; (&quot;bootstrap_connections_max&quot;, bootstrap_connections_max);
314  		toml.get&lt;unsigned&gt; (&quot;bootstrap_initiator_threads&quot;, bootstrap_initiator_threads);
315  		toml.get&lt;unsigned&gt; (&quot;bootstrap_serving_threads&quot;, bootstrap_serving_threads);
316  		toml.get&lt;uint32_t&gt; (&quot;bootstrap_frontier_request_count&quot;, bootstrap_frontier_request_count);
317  		toml.get&lt;bool&gt; (&quot;enable_voting&quot;, enable_voting);
318  		toml.get&lt;bool&gt; (&quot;allow_local_peers&quot;, allow_local_peers);
319  		toml.get&lt;unsigned&gt; (signature_checker_threads_key, signature_checker_threads);
320  		if (toml.has_key (&quot;lmdb&quot;))
321  		{
322  			auto lmdb_config_l (toml.get_required_child (&quot;lmdb&quot;));
323  			lmdb_config.deserialize_toml (lmdb_config_l);
324  		}
325  		boost::asio::ip::address_v6 external_address_l;
326  		toml.get&lt;boost::asio::ip::address_v6&gt; (&quot;external_address&quot;, external_address_l);
327  		external_address = external_address_l.to_string ();
328  		toml.get&lt;uint16_t&gt; (&quot;external_port&quot;, external_port);
329  		toml.get&lt;unsigned&gt; (&quot;tcp_incoming_connections_max&quot;, tcp_incoming_connections_max);
330  		auto pow_sleep_interval_l (pow_sleep_interval.count ());
331  		toml.get (pow_sleep_interval_key, pow_sleep_interval_l);
332  		pow_sleep_interval = std::chrono::nanoseconds (pow_sleep_interval_l);
333  		toml.get&lt;bool&gt; (&quot;use_memory_pools&quot;, use_memory_pools);
334  		toml.get&lt;std::size_t&gt; (&quot;confirmation_history_size&quot;, confirmation_history_size);
335  		toml.get&lt;std::size_t&gt; (&quot;active_elections_size&quot;, active_elections_size);
336  		toml.get&lt;std::size_t&gt; (&quot;bandwidth_limit&quot;, bandwidth_limit);
337  		toml.get&lt;double&gt; (&quot;bandwidth_limit_burst_ratio&quot;, bandwidth_limit_burst_ratio);
338  		toml.get&lt;std::size_t&gt; (&quot;bootstrap_bandwidth_limit&quot;, bootstrap_bandwidth_limit);
339  		toml.get&lt;double&gt; (&quot;bootstrap_bandwidth_burst_ratio&quot;, bootstrap_bandwidth_burst_ratio);
340  		toml.get&lt;bool&gt; (&quot;backup_before_upgrade&quot;, backup_before_upgrade);
341  		auto conf_height_processor_batch_min_time_l (conf_height_processor_batch_min_time.count ());
342  		toml.get (&quot;conf_height_processor_batch_min_time&quot;, conf_height_processor_batch_min_time_l);
343  		conf_height_processor_batch_min_time = std::chrono::milliseconds (conf_height_processor_batch_min_time_l);
344  		toml.get&lt;double&gt; (&quot;max_work_generate_multiplier&quot;, max_work_generate_multiplier);
345  		toml.get&lt;uint32_t&gt; (&quot;max_queued_requests&quot;, max_queued_requests);
346  		auto rep_crawler_weight_minimum_l (rep_crawler_weight_minimum.to_string_dec ());
347  		if (toml.has_key (&quot;rep_crawler_weight_minimum&quot;))
348  		{
349  			rep_crawler_weight_minimum_l = toml.get&lt;std::string&gt; (&quot;rep_crawler_weight_minimum&quot;);
350  		}
351  		if (rep_crawler_weight_minimum.decode_dec (rep_crawler_weight_minimum_l))
352  		{
353  			toml.get_error ().set (&quot;rep_crawler_weight_minimum contains an invalid decimal amount&quot;);
354  		}
355  		if (toml.has_key (&quot;frontiers_confirmation&quot;))
356  		{
357  			auto frontiers_confirmation_l (toml.get&lt;std::string&gt; (&quot;frontiers_confirmation&quot;));
358  			frontiers_confirmation = deserialize_frontiers_confirmation (frontiers_confirmation_l);
359  		}
360  		toml.get&lt;unsigned&gt; (&quot;backlog_scan_batch_size&quot;, backlog_scan_batch_size);
361  		toml.get&lt;unsigned&gt; (&quot;backlog_scan_frequency&quot;, backlog_scan_frequency);
362  		if (toml.has_key (&quot;experimental&quot;))
363  		{
364  			auto experimental_config_l (toml.get_required_child (&quot;experimental&quot;));
365  			if (experimental_config_l.has_key (&quot;secondary_work_peers&quot;))
366  			{
367  				secondary_work_peers.clear ();
368  				experimental_config_l.array_entries_required&lt;std::string&gt; (&quot;secondary_work_peers&quot;, [this] (std::string const &amp; entry_a) {
369  					this-&gt;deserialize_address (entry_a, this-&gt;secondary_work_peers);
370  				});
371  			}
372  			auto max_pruning_age_l (max_pruning_age.count ());
373  			experimental_config_l.get (&quot;max_pruning_age&quot;, max_pruning_age_l);
374  			max_pruning_age = std::chrono::seconds (max_pruning_age_l);
375  			experimental_config_l.get&lt;uint64_t&gt; (&quot;max_pruning_depth&quot;, max_pruning_depth);
376  		}
377  		if (election_hint_weight_percent &lt; 5 || election_hint_weight_percent &gt; 50)
378  		{
379  			toml.get_error ().set (&quot;election_hint_weight_percent must be a number between 5 and 50&quot;);
380  		}
381  		if (password_fanout &lt; 16 || password_fanout &gt; 1024 * 1024)
382  		{
383  			toml.get_error ().set (&quot;password_fanout must be a number between 16 and 1048576&quot;);
384  		}
385  		if (io_threads == 0)
386  		{
387  			toml.get_error ().set (&quot;io_threads must be non-zero&quot;);
388  		}
389  		if (active_elections_size &lt;= 250 &amp;&amp; !network_params.network.is_dev_network ())
390  		{
391  			toml.get_error ().set (&quot;active_elections_size must be greater than 250&quot;);
392  		}
393  		if (bandwidth_limit &gt; std::numeric_limits&lt;std::size_t&gt;::max ())
394  		{
395  			toml.get_error ().set (&quot;bandwidth_limit unbounded = 0, default = 10485760, max = 18446744073709551615&quot;);
396  		}
397  		if (vote_generator_threshold &lt; 1 || vote_generator_threshold &gt; 11)
398  		{
399  			toml.get_error ().set (&quot;vote_generator_threshold must be a number between 1 and 11&quot;);
400  		}
401  		if (max_work_generate_multiplier &lt; 1)
402  		{
403  			toml.get_error ().set (&quot;max_work_generate_multiplier must be greater than or equal to 1&quot;);
404  		}
405  		if (frontiers_confirmation == nano::frontiers_confirmation_mode::invalid)
406  		{
407  			toml.get_error ().set (&quot;frontiers_confirmation value is invalid (available: always, auto, disabled)&quot;);
408  		}
409  		if (block_processor_batch_max_time &lt; network_params.node.process_confirmed_interval)
410  		{
411  			toml.get_error ().set ((boost::format (&quot;block_processor_batch_max_time value must be equal or larger than %1%ms&quot;) % network_params.node.process_confirmed_interval.count ()).str ());
412  		}
413  		if (max_pruning_age &lt; std::chrono::seconds (5 * 60) &amp;&amp; !network_params.network.is_dev_network ())
414  		{
415  			toml.get_error ().set (&quot;max_pruning_age must be greater than or equal to 5 minutes&quot;);
416  		}
417  		if (bootstrap_frontier_request_count &lt; 1024)
418  		{
419  			toml.get_error ().set (&quot;bootstrap_frontier_request_count must be greater than or equal to 1024&quot;);
420  		}
421  	}
422  	catch (std::runtime_error const &amp; ex)
423  	{
424  		toml.get_error ().set (ex.what ());
425  	}
426  	return toml.get_error ();
427  }
428  std::string nano::node_config::serialize_frontiers_confirmation (nano::frontiers_confirmation_mode mode_a) const
429  {
430  	switch (mode_a)
431  	{
432  		case nano::frontiers_confirmation_mode::always:
433  			return &quot;always&quot;;
434  		case nano::frontiers_confirmation_mode::automatic:
435  			return &quot;auto&quot;;
436  		case nano::frontiers_confirmation_mode::disabled:
437  			return &quot;disabled&quot;;
438  		default:
439  			return &quot;auto&quot;;
440  	}
441  }
442  nano::frontiers_confirmation_mode nano::node_config::deserialize_frontiers_confirmation (std::string const &amp; string_a)
443  {
444  	if (string_a == &quot;always&quot;)
445  	{
446  		return nano::frontiers_confirmation_mode::always;
447  	}
448  	else if (string_a == &quot;auto&quot;)
449  	{
450  		return nano::frontiers_confirmation_mode::automatic;
451  	}
452  	else if (string_a == &quot;disabled&quot;)
453  	{
454  		return nano::frontiers_confirmation_mode::disabled;
455  	}
456  	else
457  	{
458  		return nano::frontiers_confirmation_mode::invalid;
459  	}
460  }
461  void nano::node_config::deserialize_address (std::string const &amp; entry_a, std::vector&lt;std::pair&lt;std::string, uint16_t&gt;&gt; &amp; container_a) const
462  {
463  	auto port_position (entry_a.rfind (&#x27;:&#x27;));
464  	bool result = (port_position == -1);
465  	if (!result)
466  	{
467  		auto port_str (entry_a.substr (port_position + 1));
468  		uint16_t port;
469  		result |= parse_port (port_str, port);
470  		if (!result)
471  		{
472  			auto address (entry_a.substr (0, port_position));
473  			container_a.emplace_back (address, port);
474  		}
475  	}
476  }
477  nano::account nano::node_config::random_representative () const
478  {
479  	debug_assert (!preconfigured_representatives.empty ());
480  	std::size_t index (nano::random_pool::generate_word32 (0, static_cast&lt;CryptoPP::word32&gt; (preconfigured_representatives.size () - 1)));
481  	auto result (preconfigured_representatives[index]);
482  	return result;
483  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</h3>
            <pre><code>1  #include &lt;nano/boost/asio/ip/address_v6.hpp&gt;
2  #include &lt;nano/lib/config.hpp&gt;
3  #include &lt;nano/lib/rpcconfig.hpp&gt;
4  #include &lt;nano/lib/tomlconfig.hpp&gt;
5  #include &lt;boost/dll/runtime_symbol_info.hpp&gt;
6  nano::error nano::rpc_secure_config::serialize_toml (nano::tomlconfig &amp; toml) const
7  {
8  	toml.put (&quot;enable&quot;, enable, &quot;Enable or disable TLS support.\ntype:bool&quot;);
9  	toml.put (&quot;verbose_logging&quot;, verbose_logging, &quot;Enable or disable verbose logging.\ntype:bool&quot;);
10  	toml.put (&quot;server_key_passphrase&quot;, server_key_passphrase, &quot;Server key passphrase.\ntype:string&quot;);
11  	toml.put (&quot;server_cert_path&quot;, server_cert_path, &quot;Directory containing certificates.\ntype:string,path&quot;);
12  	toml.put (&quot;server_key_path&quot;, server_key_path, &quot;Path to server key PEM file.\ntype:string,path&quot;);
13  	toml.put (&quot;server_dh_path&quot;, server_dh_path, &quot;Path to Diffie-Hellman params file.\ntype:string,path&quot;);
14  	toml.put (&quot;client_certs_path&quot;, client_certs_path, &quot;Directory containing client certificates.\ntype:string&quot;);
15  	return toml.get_error ();
16  }
17  nano::error nano::rpc_secure_config::deserialize_toml (nano::tomlconfig &amp; toml)
18  {
19  	toml.get&lt;bool&gt; (&quot;enable&quot;, enable);
20  	toml.get&lt;bool&gt; (&quot;verbose_logging&quot;, verbose_logging);
21  	toml.get&lt;std::string&gt; (&quot;server_key_passphrase&quot;, server_key_passphrase);
22  	toml.get&lt;std::string&gt; (&quot;server_cert_path&quot;, server_cert_path);
23  	toml.get&lt;std::string&gt; (&quot;server_key_path&quot;, server_key_path);
24  	toml.get&lt;std::string&gt; (&quot;server_dh_path&quot;, server_dh_path);
<span onclick='openModal()' class='match'>25  	toml.get&lt;std::string&gt; (&quot;client_certs_path&quot;, client_certs_path);
26  	return toml.get_error ();
</span>27  }
28  nano::rpc_config::rpc_config (nano::network_constants &amp; network_constants) :
29  	rpc_process{ network_constants },
30  	address{ boost::asio::ip::address_v6::loopback ().to_string () }
31  {
32  }
33  nano::rpc_config::rpc_config (nano::network_constants &amp; network_constants, uint16_t port_a, bool enable_control_a) :
34  	rpc_process{ network_constants },
35  	address{ boost::asio::ip::address_v6::loopback ().to_string () },
36  	port{ port_a },
37  	enable_control{ enable_control_a }
38  {
39  }
40  nano::error nano::rpc_config::serialize_toml (nano::tomlconfig &amp; toml) const
41  {
42  	toml.put (&quot;address&quot;, address, &quot;Bind address for the RPC server.\ntype:string,ip&quot;);
43  	toml.put (&quot;port&quot;, port, &quot;Listening port for the RPC server.\ntype:uint16&quot;);
44  	toml.put (&quot;enable_control&quot;, enable_control, &quot;Enable or disable control-level requests.\nWARNING: Enabling this gives anyone with RPC access the ability to stop the node and access wallet funds.\ntype:bool&quot;);
45  	toml.put (&quot;max_json_depth&quot;, max_json_depth, &quot;Maximum number of levels in JSON requests.\ntype:uint8&quot;);
46  	toml.put (&quot;max_request_size&quot;, max_request_size, &quot;Maximum number of bytes allowed in request bodies.\ntype:uint64&quot;);
47  	nano::tomlconfig rpc_process_l;
48  	rpc_process_l.put (&quot;io_threads&quot;, rpc_process.io_threads, &quot;Number of threads used to serve IO.\ntype:uint32&quot;);
49  	rpc_process_l.put (&quot;ipc_address&quot;, rpc_process.ipc_address, &quot;Address of IPC server.\ntype:string,ip&quot;);
50  	rpc_process_l.put (&quot;ipc_port&quot;, rpc_process.ipc_port, &quot;Listening port of IPC server.\ntype:uint16&quot;);
51  	rpc_process_l.put (&quot;num_ipc_connections&quot;, rpc_process.num_ipc_connections, &quot;Number of IPC connections to establish.\ntype:uint32&quot;);
52  	toml.put_child (&quot;process&quot;, rpc_process_l);
53  	nano::tomlconfig rpc_logging_l;
54  	rpc_logging_l.put (&quot;log_rpc&quot;, rpc_logging.log_rpc, &quot;Whether to log RPC calls.\ntype:bool&quot;);
55  	toml.put_child (&quot;logging&quot;, rpc_logging_l);
56  	return toml.get_error ();
57  }
58  nano::error nano::rpc_config::deserialize_toml (nano::tomlconfig &amp; toml)
59  {
60  	if (!toml.empty ())
61  	{
62  		auto rpc_secure_l (toml.get_optional_child (&quot;secure&quot;));
63  		if (rpc_secure_l)
64  		{
65  			return nano::error (&quot;The RPC secure configuration has moved to config-tls.toml. Please update the configuration.&quot;);
66  		}
67  		boost::asio::ip::address_v6 address_l;
68  		toml.get_optional&lt;boost::asio::ip::address_v6&gt; (&quot;address&quot;, address_l, boost::asio::ip::address_v6::loopback ());
69  		address = address_l.to_string ();
70  		toml.get_optional&lt;uint16_t&gt; (&quot;port&quot;, port);
71  		toml.get_optional&lt;bool&gt; (&quot;enable_control&quot;, enable_control);
72  		toml.get_optional&lt;uint8_t&gt; (&quot;max_json_depth&quot;, max_json_depth);
73  		toml.get_optional&lt;uint64_t&gt; (&quot;max_request_size&quot;, max_request_size);
74  		auto rpc_logging_l (toml.get_optional_child (&quot;logging&quot;));
75  		if (rpc_logging_l)
76  		{
77  			rpc_logging_l-&gt;get_optional&lt;bool&gt; (&quot;log_rpc&quot;, rpc_logging.log_rpc);
78  		}
79  		auto rpc_process_l (toml.get_optional_child (&quot;process&quot;));
80  		if (rpc_process_l)
81  		{
82  			rpc_process_l-&gt;get_optional&lt;unsigned&gt; (&quot;io_threads&quot;, rpc_process.io_threads);
83  			rpc_process_l-&gt;get_optional&lt;uint16_t&gt; (&quot;ipc_port&quot;, rpc_process.ipc_port);
84  			boost::asio::ip::address_v6 ipc_address_l;
85  			rpc_process_l-&gt;get_optional&lt;boost::asio::ip::address_v6&gt; (&quot;ipc_address&quot;, ipc_address_l, boost::asio::ip::address_v6::loopback ());
86  			rpc_process.ipc_address = address_l.to_string ();
87  			rpc_process_l-&gt;get_optional&lt;unsigned&gt; (&quot;num_ipc_connections&quot;, rpc_process.num_ipc_connections);
88  		}
89  	}
90  	return toml.get_error ();
91  }
92  nano::rpc_process_config::rpc_process_config (nano::network_constants &amp; network_constants) :
93  	network_constants{ network_constants },
94  	ipc_address{ boost::asio::ip::address_v6::loopback ().to_string () }
95  {
96  }
97  namespace nano
98  {
99  nano::error read_rpc_config_toml (boost::filesystem::path const &amp; data_path_a, nano::rpc_config &amp; config_a, std::vector&lt;std::string&gt; const &amp; config_overrides)
100  {
101  	nano::error error;
102  	auto toml_config_path = nano::get_rpc_toml_config_path (data_path_a);
103  	nano::tomlconfig toml;
104  	std::stringstream config_overrides_stream;
105  	for (auto const &amp; entry : config_overrides)
106  	{
107  		config_overrides_stream &lt;&lt; entry &lt;&lt; std::endl;
108  	}
109  	config_overrides_stream &lt;&lt; std::endl;
110  	if (!error)
111  	{
112  		if (boost::filesystem::exists (toml_config_path))
113  		{
114  			error = toml.read (config_overrides_stream, toml_config_path);
115  		}
116  		else
117  		{
118  			error = toml.read (config_overrides_stream);
119  		}
120  	}
121  	if (!error)
122  	{
123  		error = config_a.deserialize_toml (toml);
124  	}
125  	return error;
126  }
127  std::string get_default_rpc_filepath ()
128  {
129  	boost::system::error_code err;
130  	auto running_executable_filepath = boost::dll::program_location (err);
131  	auto rpc_filepath = running_executable_filepath.parent_path () / &quot;nano_rpc&quot;;
132  	if (running_executable_filepath.has_extension ())
133  	{
134  		rpc_filepath.replace_extension (running_executable_filepath.extension ());
135  	}
136  	return rpc_filepath.string ();
137  }
138  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-nodeconfig.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</div>
                </div>
                <div class="column column_space"><pre><code>184  			callback_l.get&lt;std::string&gt; (&quot;target&quot;, callback_target);
185  		}
</pre></code></div>
                <div class="column column_space"><pre><code>25  	toml.get&lt;std::string&gt; (&quot;client_certs_path&quot;, client_certs_path);
26  	return toml.get_error ();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    