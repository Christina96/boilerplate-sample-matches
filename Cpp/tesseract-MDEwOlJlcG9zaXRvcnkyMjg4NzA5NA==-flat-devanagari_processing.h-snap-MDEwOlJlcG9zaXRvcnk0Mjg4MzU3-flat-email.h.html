
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.385964912280701%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-devanagari_processing.h</h3>
            <pre><code>1  #ifndef TESSERACT_TEXTORD_DEVNAGARI_PROCESSING_H_
2  #define TESSERACT_TEXTORD_DEVNAGARI_PROCESSING_H_
3  #include <allheaders.h>
4  #include "ocrblock.h"
5  #include "params.h"
6  struct Pix;
7  struct Box;
8  struct Boxa;
9  namespace tesseract {
10  extern INT_VAR_H(devanagari_split_debuglevel);
11  extern BOOL_VAR_H(devanagari_split_debugimage);
12  class TBOX;
13  class DebugPixa;
14  class PixelHistogram {
15  public:
16    PixelHistogram() {
17      hist_ = nullptr;
18      length_ = 0;
19    }
20    ~PixelHistogram() {
21      Clear();
22    }
23    void Clear() {
24      delete[] hist_;
25      length_ = 0;
26    }
<span onclick='openModal()' class='match'>27    int *hist() const {
28      return hist_;
29    }
30    int length() const {
31      return length_;
32    }
</span>33    void ConstructVerticalCountHist(Image pix);
34    void ConstructHorizontalCountHist(Image pix);
35    int GetHistogramMaximum(int *count) const;
36  private:
37    int *hist_;
38    int length_;
39  };
40  class ShiroRekhaSplitter {
41  public:
42    enum SplitStrategy {
43      NO_SPLIT = 0,  
44      MINIMAL_SPLIT, 
45      MAXIMAL_SPLIT  
46    };
47    ShiroRekhaSplitter();
48    virtual ~ShiroRekhaSplitter();
49    bool Split(bool split_for_pageseg, DebugPixa *pixa_debug);
50    void Clear();
51    void RefreshSegmentationWithNewBlobs(C_BLOB_LIST *new_blobs);
52    bool HasDifferentSplitStrategies() const {
53      return pageseg_split_strategy_ != ocr_split_strategy_;
54    }
55    void set_segmentation_block_list(BLOCK_LIST *block_list) {
56      segmentation_block_list_ = block_list;
57    }
58    static const int kUnspecifiedXheight = -1;
59    void set_global_xheight(int xheight) {
60      global_xheight_ = xheight;
61    }
62    void set_perform_close(bool perform) {
63      perform_close_ = perform;
64    }
65    Image splitted_image() {
66      return splitted_image_;
67    }
68    void set_orig_pix(Image pix);
69    Image orig_pix() {
70      return orig_pix_;
71    }
72    SplitStrategy ocr_split_strategy() const {
73      return ocr_split_strategy_;
74    }
75    void set_ocr_split_strategy(SplitStrategy strategy) {
76      ocr_split_strategy_ = strategy;
77    }
78    SplitStrategy pageseg_split_strategy() const {
79      return pageseg_split_strategy_;
80    }
81    void set_pageseg_split_strategy(SplitStrategy strategy) {
82      pageseg_split_strategy_ = strategy;
83    }
84    BLOCK_LIST *segmentation_block_list() {
85      return segmentation_block_list_;
86    }
87    static int GetModeHeight(Image pix);
88  private:
89    static void PerformClose(Image pix, int xheight_estimate);
90    int GetXheightForCC(Box *cc_bbox);
91    void SplitWordShiroRekha(SplitStrategy split_strategy, Image pix, int xheight, int word_left,
92                             int word_top, Boxa *regions_to_clear);
93    Box *GetBoxForTBOX(const TBOX &tbox) const;
94    static void GetShiroRekhaYExtents(Image word_pix, int *shirorekha_top, int *shirorekha_bottom,
95                                      int *shirorekha_ylevel);
96    Image orig_pix_;       
97    Image splitted_image_; 
98    SplitStrategy pageseg_split_strategy_;
99    SplitStrategy ocr_split_strategy_;
100    Image debug_image_;
101    BLOCK_LIST *segmentation_block_list_;
102    int global_xheight_;
103    bool perform_close_; 
104  };
105  } 
106  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.h</h3>
            <pre><code>1  #ifndef email_h
2  #define email_h
3  #include "base.h"
4  ClassTP(TEMailAliasBs, PEMailAliasBs)
5  private:
6    TStrStrPrH EAddrToPersonNmDepNmPrH;
7    UndefCopyAssign(TEMailAliasBs);
8  public:
9    TEMailAliasBs():
10      EAddrToPersonNmDepNmPrH(){}
11    static PEMailAliasBs New(){
12      return new TEMailAliasBs();}
13    TEMailAliasBs(TSIn& SIn):
14      EAddrToPersonNmDepNmPrH(SIn){}
15    static PEMailAliasBs Load(TSIn& SIn){return new TEMailAliasBs(SIn);}
16    void Save(TSOut& SOut) const {
17      EAddrToPersonNmDepNmPrH.Save(SOut);}
18    bool IsEAddr(const TStr& EAddr) const {
19      return EAddrToPersonNmDepNmPrH.IsKey(EAddr);}
20    TStr GetPersonNm(const TStr& EAddr) const {
21      if (IsEAddr(EAddr)){
22        return EAddrToPersonNmDepNmPrH.GetDat(EAddr).Val1;
23      } else {return "";}}
24    TStr GetDepNm(const TStr& EAddr) const {
25      if (IsEAddr(EAddr)){
26        return EAddrToPersonNmDepNmPrH.GetDat(EAddr).Val2;
27      } else {return "";}}
28    static PEMailAliasBs LoadSsTxt(const TStr& FNm);
29  };
30  ClassTPV(TEMailTsact, PEMailTsact, TEMailTsactV)
31  public:
32    TInt SrcEAddrId;
33    TIntV DstEAddrIdV;
34    TTm Tm;
35  public:
36    TEMailTsact():
37      SrcEAddrId(), DstEAddrIdV(), Tm(){}
38    TEMailTsact(const TEMailTsact& EMailTsact):
39      SrcEAddrId(EMailTsact.SrcEAddrId), DstEAddrIdV(EMailTsact.DstEAddrIdV),
40      Tm(EMailTsact.Tm){}
41    TEMailTsact(
42     const TInt& _SrcEAddrId, const TIntV& _DstEAddrVId, const TTm& _Tm):
43      SrcEAddrId(_SrcEAddrId), DstEAddrIdV(_DstEAddrVId), Tm(_Tm){}
44    static PEMailTsact New(
45     const TInt& SrcEAddrId, const TIntV& DstEAddrIdV, const TTm& Tm){
46      return new TEMailTsact(SrcEAddrId, DstEAddrIdV, Tm);}
47    TEMailTsact(TSIn& SIn):
48      SrcEAddrId(SIn), DstEAddrIdV(SIn), Tm(SIn){}
49    void Save(TSOut& SOut) const {
50      SrcEAddrId.Save(SOut); DstEAddrIdV.Save(SOut); Tm.Save(SOut);}
51    TEMailTsact& operator=(const TEMailTsact& EMailTsact){
52      SrcEAddrId=EMailTsact.SrcEAddrId; DstEAddrIdV=EMailTsact.DstEAddrIdV;
53      Tm=EMailTsact.Tm; return *this;}
54    bool operator==(const TEMailTsact& EMailTsact) const {
55      return Tm==EMailTsact.Tm;}
56    bool operator<(const TEMailTsact& EMailTsact) const {
57      return Tm<EMailTsact.Tm;}
58  };
59  ClassTP(TEMailTsactBs, PEMailTsactBs)
60  private:
61    TStrHash<TIntPr> EAddrStrToSrcFqDstFqPrH;
62    TVec<TEMailTsact> EMailTsactV;
63    UndefCopyAssign(TEMailTsactBs);
64  public:
65    TEMailTsactBs():
66      EAddrStrToSrcFqDstFqPrH(), EMailTsactV(){}
67    static PEMailTsactBs New(){
68      return new TEMailTsactBs();}
69    TEMailTsactBs(TSIn& SIn):
70      EAddrStrToSrcFqDstFqPrH(SIn), EMailTsactV(SIn){}
71    static PEMailTsactBs Load(TSIn& SIn){return new TEMailTsactBs(SIn);}
72    void Save(TSOut& SOut) const {
73      EAddrStrToSrcFqDstFqPrH.Save(SOut); EMailTsactV.Save(SOut);}
74    int GetEAddrs() const {return EAddrStrToSrcFqDstFqPrH.Len();}
75    TStr GetEAddr(const int& EAddrId) const {
76      return EAddrStrToSrcFqDstFqPrH.GetKey(EAddrId);}
77    static bool IsEAddrOk(const TStr& EAddr);
78    int GetTsacts() const {return EMailTsactV.Len();}
79    int AddTsact(const TStr& SrcEAddr, const TStrV& DstEAddrV, const TTm& Tm);
80    TEMailTsact& GetTsact(const int& TsactN){
81      return EMailTsactV[TsactN];}
82    static PEMailTsactBs LoadBin(const TStr& FNm){
83      TFIn SIn(FNm); return Load(SIn);}
84    static void SaveBin(const TStr& FNm, const PEMailTsactBs& EMailTsactBs);
85    void SaveBin(const TStr& FNm){
86      TFOut SOut(FNm); Save(SOut);}
87  };
88  ClassTPV(TEml, PEml, TEmlV)
89  public:
90    TStr OwnerNm;
91    TStrV FromAddrStrV;
92    TStrV ToAddrStrV;
93    TTm Tm;
94    TStr SubjStr;
95    TStr ContStr;
96  public:
97    TEml():
98      OwnerNm(), FromAddrStrV(), ToAddrStrV(), Tm(), SubjStr(), ContStr(){}
99    static PEml New(){return new TEml();}
100    TEml(const TEml& Eml):
101      OwnerNm(Eml.OwnerNm), 
102      FromAddrStrV(Eml.FromAddrStrV), ToAddrStrV(Eml.ToAddrStrV), 
103      Tm(Eml.Tm), SubjStr(Eml.SubjStr), ContStr(Eml.ContStr){}
104    TEml(TSIn& SIn):
105      OwnerNm(SIn), FromAddrStrV(SIn), ToAddrStrV(SIn), Tm(SIn), SubjStr(SIn), ContStr(SIn){}
106    static PEml Load(TSIn& SIn){return new TEml(SIn);}
107    void Save(TSOut& SOut) const {
108      OwnerNm.Save(SOut);
109      FromAddrStrV.Save(SOut); ToAddrStrV.Save(SOut); Tm.Save(SOut); 
110      SubjStr.Save(SOut); ContStr.Save(SOut);}
111    TEml& operator=(const TEml& Eml){
112      OwnerNm=Eml.OwnerNm;
113      FromAddrStrV=Eml.FromAddrStrV; ToAddrStrV=Eml.ToAddrStrV; Tm=Eml.Tm; 
114      SubjStr=Eml.SubjStr; ContStr=Eml.ContStr; return *this;}
115    bool operator==(const TEml& Eml) const {
116      return Tm==Eml.Tm;}
117    bool operator<(const TEml& Eml) const {
118      return Tm<Eml.Tm;}
119    TStr GetOwnerNm() const {return OwnerNm;}
120    int GetFromEAddrs() const {return FromAddrStrV.Len();}
<span onclick='openModal()' class='match'>121    TStr GetFromEAddr(const int& EAddrN) const {return FromAddrStrV[EAddrN];}
122    int GetToEAddrs() const {return ToAddrStrV.Len();}
</span>123    TStr GetToEAddr(const int& EAddrN) const {return ToAddrStrV[EAddrN];}
124    TTm GetTm() const {return Tm;}
125    TStr GetSubjStr() const {return SubjStr;}
126    TStr GetContStr() const {return ContStr;}
127    TTm GetTmFromRfc2822DateTimeStr(const TStr& DateTimeStr);
128    void ExtrMergeToAddrStrV(const TStr& FldVal, TStrV& AddrStrV);
129    bool IsFieldNmCh(const uchar& Ch) const;
130    void ToNrEncoding(const TStr& ContTransferEncVal, TChA& ChA);
131    void ExtrAddBoundaryStr(const TStr& ContTypeVal, TStrV& BoundaryStrV) const;
132    bool Eof(const PSIn& SIn){return SIn->Eof();}
133    char GetCh(const PSIn& SIn){return SIn->Eof() ? 0 : SIn->GetCh();}
134    bool LoadField(const PSIn& SIn, TChA& FldNm, TChA& FldVal, TChA& LcFldVal);
135    void LoadMessage(const PSIn& SIn);
136    static PEml LoadEml(const TStr& FNm, const TStr& OwnerNm);
137  };
138  ClassTP(TEmlBs, PEmlBs)
139  private:
140    THash<TStr, PEml> NmToEmlH;
141    TStrIntVH EAddrStrToEmlIdVH;
142    UndefAssign(TEmlBs);
143  public:
144    TEmlBs(): NmToEmlH(), EAddrStrToEmlIdVH(){}
145    static PEmlBs New(){return new TEmlBs();}
146    TEmlBs(const TEmlBs& EmlBs):
147      NmToEmlH(EmlBs.NmToEmlH),
148      EAddrStrToEmlIdVH(EmlBs.EAddrStrToEmlIdVH){}
149    ~TEmlBs(){}
150    TEmlBs(TSIn& SIn):
151      NmToEmlH(SIn), EAddrStrToEmlIdVH(SIn){}
152    static PEmlBs Load(TSIn& SIn){return new TEmlBs(SIn);}
153    void Save(TSOut& SOut){
154      NmToEmlH.Save(SOut); EAddrStrToEmlIdVH.Save(SOut);}
155    int GetEmls() const {return NmToEmlH.Len();}
156    void AddEml(const TStr& EmlNm, const PEml& Eml);
157    void DelEml(const TStr& EmlNm);
158    PEml GetEml(const TStr& EmlNm) const {return NmToEmlH.GetDat(EmlNm);}
159    void GetEmlNmV(TStrV& EmlNmV) const {NmToEmlH.GetKeyV(EmlNmV);}
160    void GetTmEmlNmPrV(TTmStrPrV& TmEmlNmPrV) const;
161    int GetEAddrs() const {return EAddrStrToEmlIdVH.Len();}
162    TStr GetEAddrStr(const int& EAddrN) const {return EAddrStrToEmlIdVH.GetKey(EAddrN);}
163    int GetEAddrFq(const int& EAddrN) const {return EAddrStrToEmlIdVH[EAddrN].Len();}
164    void AddEAddr(const TStr& EAddrStr, const int& EmlP){
165      EAddrStrToEmlIdVH.AddDat(EAddrStr).AddBackSorted(EmlP, true);}
166    void DelEAddr(const TStr& EAddrStr, const int& EmlP){
167      EAddrStrToEmlIdVH.GetDat(EAddrStr).DelIfIn(EmlP);}
168    void GetEAddrStrV(TStrV& EAddrStrV) const {
169      EAddrStrToEmlIdVH.GetKeyV(EAddrStrV);}
170    void GetEAddrEmlPV(const TStr& EAddrStr, TIntV& EmlPV){
171      EmlPV=EAddrStrToEmlIdVH.GetDat(EAddrStr);}
172    void LoadWinMailAccount(const TStr& FPath, const TStr& OwnerNm, const int& MxEmls=-1);
173    void LoadEnronEMail(const TStr& FPath, const int& MxEmls=-1);
174    static PEmlBs LoadBin(const TStr& FNm){
175      TFIn SIn(FNm); return Load(SIn);}
176    void SaveBin(const TStr& FNm){
177      TFOut SOut(FNm); Save(SOut);}
178    void SaveTxt(const TStr& FNm);
179    void SaveTxtEAddr(const TStr& FNm);
180  };
181  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-devanagari_processing.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.h</div>
                </div>
                <div class="column column_space"><pre><code>27    int *hist() const {
28      return hist_;
29    }
30    int length() const {
31      return length_;
32    }
</pre></code></div>
                <div class="column column_space"><pre><code>121    TStr GetFromEAddr(const int& EAddrN) const {return FromAddrStrV[EAddrN];}
122    int GetToEAddrs() const {return ToAddrStrV.Len();}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    