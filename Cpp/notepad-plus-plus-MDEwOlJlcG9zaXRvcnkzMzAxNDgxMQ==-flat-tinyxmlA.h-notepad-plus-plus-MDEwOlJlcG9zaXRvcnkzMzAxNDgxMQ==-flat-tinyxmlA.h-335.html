
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.h</h3>
            <pre><code>1  #ifndef TINYXMLA_INCLUDED
2  #define TINYXMLA_INCLUDED
3  #ifdef _MSC_VER
4  #pragma warning( push )
5  #pragma warning( disable : 4458 ) 
6  #pragma warning( disable : 4530 )
7  #pragma warning( disable : 4786 )
8  #endif
9  #if defined( _DEBUG ) &amp;&amp; !defined( DEBUG )
10  #define DEBUG
11  #endif
12  #if defined( DEBUG ) &amp;&amp; defined( _MSC_VER )
13  #include &lt;windows.h&gt;
14  #define TIXMLA_LOG OutputDebugString
15  #else
16  #define TIXMLA_LOG printf
17  #endif
18  #ifdef TIXMLA_USE_STL
19  	#define TIXMLA_STRING	std::string
20  	#define TIXMLA_ISTREAM	std::istream
21  	#define TIXMLA_OSTREAM	std::ostream
22  #else
23  	#include &quot;tinystrA.h&quot;
24  	#define TIXMLA_STRING	TiXmlStringA
25  	#define TIXMLA_OSTREAM	TiXmlOutStreamA
26  #endif
27  #include &lt;stdio.h&gt;
28  #include &lt;assert.h&gt;
29  #include &lt;string&gt;
30  #include &lt;tchar.h&gt;
31  #include &quot;Common.h&quot;
32  class TiXmlDocumentA;
33  class TiXmlElementA;
34  class TiXmlCommentA;
35  class TiXmlUnknownA;
36  class TiXmlAttributeA;
37  class TiXmlTextA;
38  class TiXmlDeclarationA;
39  class TiXmlParsingDataA;
40  struct TiXmlCursorA
41  {
42  	TiXmlCursorA()		{ Clear(); }
43  	void Clear()		{ row = col = -1; }
44  	int row;	
45  	int col;	
46  };
47  enum 
48  { 
49  	TIXMLA_SUCCESS,
50  	TIXMLA_NO_ATTRIBUTE,
51  	TIXMLA_WRONG_TYPE
52  };
53  class TiXmlBaseA
54  {
55  	friend class TiXmlNodeA;
56  	friend class TiXmlElementA;
57  	friend class TiXmlDocumentA;
58  public:
59  	TiXmlBaseA()								{}
60  	virtual ~TiXmlBaseA()					{}
61  	virtual void Print( FILE* cfile, int depth ) const = 0;
62  	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
63  	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
64  	int Row() const			{ return location.row + 1; }
65  	int Column() const		{ return location.col + 1; }	
66  protected:
67  	class StringToBuffer
68  	{
69  	  public:
70  		StringToBuffer( const TIXMLA_STRING&amp; str );
71  		~StringToBuffer();
72  		char* buffer;
73  	};
74  	static const char*	SkipWhiteSpace( const char* );
75  	inline static bool	IsWhiteSpace( int c )		{ return ( isspace( c ) || c == &#x27;\n&#x27; || c == &#x27;\r&#x27; ); }
76  	virtual void StreamOut (TIXMLA_OSTREAM *) const = 0;
77  	#ifdef TIXMLA_USE_STL
78  	    static bool	StreamWhiteSpace( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
79  	    static bool StreamTo( TIXMLA_ISTREAM * in, int character, TIXMLA_STRING * tag );
80  	#endif
81  	static const char* ReadName( const char* p, TIXMLA_STRING* name );
82  	static const char* ReadText(	const char* in,				
83  									TIXMLA_STRING* text,			
84  									bool ignoreWhiteSpace,		
85  									const char* endTag,			
86  									bool ignoreCase );			
87  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data ) = 0;
88  	static const char* GetEntity( const char* in, char* value );
89  	inline static const char* GetChar( const char* p, char* _value )
90  	{
91  		assert( p );
92  		if ( *p == &#x27;&amp;&#x27; )
93  		{
94  			return GetEntity( p, _value );
95  		}
96  		else
97  		{
98  			*_value = *p;
99  			return p+1;
100  		}
101  	}
102  	static void PutString( const TIXMLA_STRING&amp; str, TIXMLA_OSTREAM* out );
103  	static void PutString( const TIXMLA_STRING&amp; str, TIXMLA_STRING* out );
104  	static bool StringEqual(	const char* p,
105  								const char* endTag,
106  								bool ignoreCase );
107  	enum
108  	{
109  		TIXMLA_NO_ERROR = 0,
110  		TIXMLA_ERROR,
111  		TIXMLA_ERROR_OPENING_FILE,
112  		TIXMLA_ERROR_OUT_OF_MEMORY,
113  		TIXMLA_ERROR_PARSING_ELEMENT,
114  		TIXMLA_ERROR_FAILED_TO_READ_ELEMENT_NAME,
115  		TIXMLA_ERROR_READING_ELEMENT_VALUE,
116  		TIXMLA_ERROR_READING_ATTRIBUTES,
117  		TIXMLA_ERROR_PARSING_EMPTY,
118  		TIXMLA_ERROR_READING_END_TAG,
119  		TIXMLA_ERROR_PARSING_UNKNOWN,
120  		TIXMLA_ERROR_PARSING_COMMENT,
121  		TIXMLA_ERROR_PARSING_DECLARATION,
122  		TIXMLA_ERROR_DOCUMENT_EMPTY,
123  		TIXMLA_ERROR_STRING_COUNT
124  	};
125  	static const char* errorString[ TIXMLA_ERROR_STRING_COUNT ];
126  	TiXmlCursorA location;
127  private:
128  	struct Entity
129  	{
130  		const char*     str;
131  		unsigned int	strLength;
132  		char		    chr;
133  	};
134  	enum
135  	{
136  		NUM_ENTITY = 5,
137  		MAX_ENTITY_LENGTH = 6
138  	};
139  	static Entity entity[ NUM_ENTITY ];
140  	static bool condenseWhiteSpace;
141  };
142  class TiXmlNodeA : public TiXmlBaseA
143  {
144  	friend class TiXmlDocumentA;
145  	friend class TiXmlElementA;
146  public:
147  	#ifdef TIXMLA_USE_STL	
148  	    friend std::istream&amp; operator &gt;&gt; (std::istream&amp; in, TiXmlNodeA&amp; base);
149  	    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const TiXmlNodeA&amp; base);
150  		friend std::string&amp; operator&lt;&lt; (std::string&amp; out, const TiXmlNodeA&amp; base );
151  	#else
152  	    friend TIXMLA_OSTREAM&amp; operator&lt;&lt; (TIXMLA_OSTREAM&amp; out, const TiXmlNodeA&amp; base);
153  	#endif
154  	enum NodeType
155  	{
156  		DOCUMENT,
157  		ELEMENT,
158  		COMMENT,
159  		UNKNOWN,
160  		TEXT,
161  		DECLARATION,
162  		TYPECOUNT
163  	};
164  	virtual ~TiXmlNodeA();
165  	const char * Value() const { return value.c_str (); }
166  	void SetValue(const char * _value) { value = _value;}
167      #ifdef TIXMLA_USE_STL
168  	void SetValue( const std::string&amp; _value )    
169  	{	  
170  		StringToBuffer buf( _value );
171  		SetValue( buf.buffer ? buf.buffer : &quot;&quot; );    	
172  	}	
173  	#endif
174  	void Clear();
175  	TiXmlNodeA* Parent() const					{ return parent; }
176  	TiXmlNodeA* FirstChild()	const	{ return firstChild; }		
177  	TiXmlNodeA* FirstChild( const char * value ) const;			
178  	TiXmlNodeA* LastChild() const	{ return lastChild; }		
179  	TiXmlNodeA* LastChild( const char * value ) const;			
180      #ifdef TIXMLA_USE_STL
181  	TiXmlNodeA* FirstChild( const std::string&amp; _value ) const	{	return FirstChild (_value.c_str ());	}	
182  	TiXmlNodeA* LastChild( const std::string&amp; _value ) const		{	return LastChild (_value.c_str ());	}	
183  	#endif
184  	TiXmlNodeA* IterateChildren( TiXmlNodeA* previous ) const;
185  	TiXmlNodeA* IterateChildren( const char * value, TiXmlNodeA* previous ) const;
186      #ifdef TIXMLA_USE_STL
187  	TiXmlNodeA* IterateChildren( const std::string&amp; _value, TiXmlNodeA* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	
188  	#endif
189  	TiXmlNodeA* InsertEndChild( const TiXmlNodeA&amp; addThis );
190  	TiXmlNodeA* LinkEndChild( TiXmlNodeA* addThis );
191  	TiXmlNodeA* InsertBeforeChild( TiXmlNodeA* beforeThis, const TiXmlNodeA&amp; addThis );
192  	TiXmlNodeA* InsertAfterChild(  TiXmlNodeA* afterThis, const TiXmlNodeA&amp; addThis );
193  	TiXmlNodeA* ReplaceChild( TiXmlNodeA* replaceThis, const TiXmlNodeA&amp; withThis );
194  	bool RemoveChild( TiXmlNodeA* removeThis );
195  	TiXmlNodeA* PreviousSibling() const			{ return prev; }
196  	TiXmlNodeA* PreviousSibling( const char * ) const;
197      #ifdef TIXMLA_USE_STL
198  	TiXmlNodeA* PreviousSibling( const std::string&amp; _value ) const	{	return PreviousSibling (_value.c_str ());	}	
199  	TiXmlNodeA* NextSibling( const std::string&amp; _value) const		{	return NextSibling (_value.c_str ());	}	
200  	#endif
201  	TiXmlNodeA* NextSibling() const				{ return next; }
202  	TiXmlNodeA* NextSibling( const char * ) const;
203  	TiXmlElementA* NextSiblingElement() const;
204  	TiXmlElementA* NextSiblingElement( const char * ) const;
205      #ifdef TIXMLA_USE_STL
206  	TiXmlElementA* NextSiblingElement( const std::string&amp; _value) const	{	return NextSiblingElement (_value.c_str ());	}	
207  	#endif
208  	TiXmlElementA* FirstChildElement()	const;
209  	TiXmlElementA* FirstChildElement( const char * value ) const;
210      #ifdef TIXMLA_USE_STL
211  	TiXmlElementA* FirstChildElement( const std::string&amp; _value ) const	{	return FirstChildElement (_value.c_str ());	}	
212  	#endif
213  	virtual int Type() const	{ return type; }
214  	TiXmlDocumentA* GetDocument() const;
215  	bool NoChildren() const						{ return !firstChild; }
216  	TiXmlDocumentA* ToDocument()	const		{ return ( type == DOCUMENT ) ? (TiXmlDocumentA*) this : 0; } 
217  	TiXmlElementA*  ToElement() const		{ return ( type == ELEMENT  ) ? (TiXmlElementA*)  this : 0; } 
218  	TiXmlCommentA*  ToComment() const		{ return ( type == COMMENT  ) ? (TiXmlCommentA*)  this : 0; } 
219  	TiXmlUnknownA*  ToUnknown() const		{ return ( type == UNKNOWN  ) ? (TiXmlUnknownA*)  this : 0; } 
220  	TiXmlTextA*	   ToText()    const		{ return ( type == TEXT     ) ? (TiXmlTextA*)     this : 0; } 
221  	TiXmlDeclarationA* ToDeclaration() const	{ return ( type == DECLARATION ) ? (TiXmlDeclarationA*) this : 0; } 
222  	virtual TiXmlNodeA* Clone() const = 0;
223  	void  SetUserData( void* user )			{ userData = user; }
224  	void* GetUserData()						{ return userData; }
225  protected:
226  	TiXmlNodeA( NodeType type );
227  	#ifdef TIXMLA_USE_STL
228  	    virtual void StreamIn( TIXMLA_ISTREAM* in, TIXMLA_STRING* tag ) = 0;
229  	#endif
230  	TiXmlNodeA* Identify( const char* start );
231  	void CopyToClone( TiXmlNodeA* target ) const	{ target-&gt;SetValue (value.c_str() );
232  												  target-&gt;userData = userData; }
233  	TIXMLA_STRING SValue() const	{ return value ; }
234  	TiXmlNodeA*		parent;
235  	NodeType		type;
236  	TiXmlNodeA*		firstChild;
237  	TiXmlNodeA*		lastChild;
238  	TIXMLA_STRING	value;
239  	TiXmlNodeA*		prev;
240  	TiXmlNodeA*		next;
241  	void*			userData;
242  };
243  class TiXmlAttributeA : public TiXmlBaseA
244  {
245  	friend class TiXmlAttributeSetA;
246  public:
247  	TiXmlAttributeA()
248  	{
249  		document = 0;
250  		prev = next = 0;
251  	}
252  	#ifdef TIXMLA_USE_STL
253  	TiXmlAttributeA( const std::string&amp; _name, const std::string&amp; _value )
254  	{
255  		name = _name;
256  		value = _value;
257  		document = 0;
258  		prev = next = 0;
259  	}
260  	#endif
261  	TiXmlAttributeA( const char * _name, const char * _value )
262  	{
263  		name = _name;
264  		value = _value;
265  		document = 0;
266  		prev = next = 0;
267  	}
268  	const char*     Name()  const		{ return name.c_str (); }		
269  	const char*     Value() const		{ return value.c_str (); }		
270  	int             IntValue() const;									
271  	double          DoubleValue() const;								
272  	int QueryIntValue( int* value ) const;
273  	int QueryDoubleValue( double* value ) const;
274  	void SetName( const char* _name )	{ name = _name; }				
275  	void SetValue( const char* _value )	{ value = _value; }				
276  	void SetIntValue( int value );										
277  	void SetDoubleValue( double value );								
278      #ifdef TIXMLA_USE_STL
279  	void SetName( const std::string&amp; _name )	
280  	{	
281  		StringToBuffer buf( _name );
282  		SetName ( buf.buffer ? buf.buffer : &quot;error&quot; );	
283  	}
284  	void SetValue( const std::string&amp; _value )	
285  	{	
286  		StringToBuffer buf( _value );
287  		SetValue( buf.buffer ? buf.buffer : &quot;error&quot; );	
288  	}
289  	#endif
290  	TiXmlAttributeA* Next() const;
291  	TiXmlAttributeA* Previous() const;
292  	bool operator==( const TiXmlAttributeA&amp; rhs ) const { return rhs.name == name; }
293  	bool operator&lt;( const TiXmlAttributeA&amp; rhs )	 const { return name &lt; rhs.name; }
294  	bool operator&gt;( const TiXmlAttributeA&amp; rhs )  const { return name &gt; rhs.name; }
295  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
296  	virtual void Print( FILE* cfile, int depth ) const;
297  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
298  	void SetDocument( TiXmlDocumentA* doc )	{ document = doc; }
299  private:
300  	TiXmlDocumentA*	document;	
301  	TIXMLA_STRING name;
302  	TIXMLA_STRING value;
303  	TiXmlAttributeA*	prev;
304  	TiXmlAttributeA*	next;
305  };
306  class TiXmlAttributeSetA
307  {
308  public:
309  	TiXmlAttributeSetA();
310  	~TiXmlAttributeSetA();
311  	void Add( TiXmlAttributeA* attribute );
312  	void Remove( TiXmlAttributeA* attribute );
313  	TiXmlAttributeA* First() const	{ return ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
314  	TiXmlAttributeA* Last()  const	{ return ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
315  	TiXmlAttributeA*	Find( const char * name ) const;
316  private:
317  	TiXmlAttributeA sentinel;
318  };
319  class TiXmlElementA : public TiXmlNodeA
320  {
321  public:
322  	TiXmlElementA (const char * in_value);
323  	#ifdef TIXMLA_USE_STL
324  	TiXmlElementA( const std::string&amp; _value ) : 	TiXmlNodeA( TiXmlNodeA::ELEMENT )
325  	{
326  		firstChild = lastChild = 0;
327  		value = _value;
328  	}
329  	#endif
330  	virtual ~TiXmlElementA();
331  	const char* Attribute( const char* name ) const;
332  	const char* Attribute( const char* name, int* i ) const;
333  	const char* Attribute( const char* name, double* d ) const;
334  	int QueryIntAttribute( const char* name, int* value ) const;
335  	int QueryDoubleAttribute( const char* name, double* value ) const;
336  	void SetAttribute( const char* name, const char * value );
337      #ifdef TIXMLA_USE_STL
338  	const char* Attribute( const std::string&amp; name ) const				{ return Attribute( name.c_str() ); }
339  	const char* Attribute( const std::string&amp; name, int* i ) const		{ return Attribute( name.c_str(), i ); }
340  	void SetAttribute( const std::string&amp; name, const std::string&amp; _value )	
341  	{	
342  		StringToBuffer n( name );
343  		StringToBuffer v( _value );
344  		if ( n.buffer &amp;&amp; v.buffer )
345  			SetAttribute (n.buffer, v.buffer );	
346  	}	
347  	void SetAttribute( const std::string&amp; name, int _value )	
348  	{	
349  		StringToBuffer n( name );
350  		if ( n.buffer )
351  			SetAttribute (n.buffer, _value);	
352  	}	
353  	#endif
354  	void SetAttribute( const char * name, int value );
355  	void RemoveAttribute( const char * name );
356      #ifdef TIXMLA_USE_STL
357  	void RemoveAttribute( const std::string&amp; name )	{	RemoveAttribute (name.c_str ());	}	
358  	#endif
359  	TiXmlAttributeA* FirstAttribute() const	{ return attributeSet.First(); }		
360  	TiXmlAttributeA* LastAttribute()	const 	{ return attributeSet.Last(); }		
361  	virtual TiXmlNodeA* Clone() const;
362  	virtual void Print( FILE* cfile, int depth ) const;
363  protected:
364  	#ifdef TIXMLA_USE_STL
365  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
366  	#endif
367  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
368  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
369  	const char* ReadValue( const char* in, TiXmlParsingDataA* prevData );
370  private:
371  	TiXmlAttributeSetA attributeSet;
372  };
373  class TiXmlCommentA : public TiXmlNodeA
374  {
375  public:
376  	TiXmlCommentA() : TiXmlNodeA( TiXmlNodeA::COMMENT ) {}
377  	virtual ~TiXmlCommentA()	{}
378  	virtual TiXmlNodeA* Clone() const;
379  	virtual void Print( FILE* cfile, int depth ) const;
380  protected:
381  	#ifdef TIXMLA_USE_STL
382  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
383  	#endif
384  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
385  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
386  };
387  class TiXmlTextA : public TiXmlNodeA
388  {
389  	friend class TiXmlElementA;
390  public:
391  	TiXmlTextA (const char * initValue) : TiXmlNodeA (TiXmlNodeA::TEXT)
392  	{
393  		SetValue( initValue );
394  	}
395  	virtual ~TiXmlTextA() {}
396  	#ifdef TIXMLA_USE_STL
<span onclick='openModal()' class='match'>397  	TiXmlTextA( const std::string&amp; initValue ) : TiXmlNodeA (TiXmlNodeA::TEXT)
398  	{
399  		SetValue( initValue );
</span>400  	}
401  	#endif
402  	virtual void Print( FILE* cfile, int depth ) const;
403  protected :
404  	virtual TiXmlNodeA* Clone() const;
405  	virtual void StreamOut ( TIXMLA_OSTREAM * out ) const;
406  	bool Blank() const;	
407  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
408  	#ifdef TIXMLA_USE_STL
409  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
410  	#endif
411  };
412  class TiXmlDeclarationA : public TiXmlNodeA
413  {
414  public:
415  	TiXmlDeclarationA()   : TiXmlNodeA( TiXmlNodeA::DECLARATION ) {}
416  #ifdef TIXMLA_USE_STL
417  	TiXmlDeclarationA(	const std::string&amp; _version,
418  						const std::string&amp; _encoding,
419  						const std::string&amp; _standalone )
420  			: TiXmlNodeA( TiXmlNodeA::DECLARATION )
421  	{
422  		version = _version;
423  		encoding = _encoding;
424  		standalone = _standalone;
425  	}
426  #endif
427  	TiXmlDeclarationA(	const char* _version,
428  						const char* _encoding,
429  						const char* _standalone );
430  	virtual ~TiXmlDeclarationA()	{}
431  	const char * Version() const		{ return version.c_str (); }
432  	const char * Encoding() const		{ return encoding.c_str (); }
433  	const char * Standalone() const		{ return standalone.c_str (); }
434  	virtual TiXmlNodeA* Clone() const;
435  	virtual void Print( FILE* cfile, int depth ) const;
436  protected:
437  	#ifdef TIXMLA_USE_STL
438  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
439  	#endif
440  	virtual void StreamOut ( TIXMLA_OSTREAM * out) const;
441  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
442  private:
443  	TIXMLA_STRING version;
444  	TIXMLA_STRING encoding;
445  	TIXMLA_STRING standalone;
446  };
447  class TiXmlUnknownA : public TiXmlNodeA
448  {
449  public:
450  	TiXmlUnknownA() : TiXmlNodeA( TiXmlNodeA::UNKNOWN ) {}
451  	virtual ~TiXmlUnknownA() {}
452  	virtual TiXmlNodeA* Clone() const;
453  	virtual void Print( FILE* cfile, int depth ) const;
454  protected:
455  	#ifdef TIXMLA_USE_STL
456  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
457  	#endif
458  	virtual void StreamOut ( TIXMLA_OSTREAM * out ) const;
459  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
460  };
461  class TiXmlDocumentA : public TiXmlNodeA
462  {
463  public:
464  	TiXmlDocumentA();
465  	TiXmlDocumentA( const char * documentName );
466  	#ifdef TIXMLA_USE_STL
467  	TiXmlDocumentA( const std::string&amp; documentName ) :
468  	    TiXmlNodeA( TiXmlNodeA::DOCUMENT )
469  	{
470          value = documentName;
471  		error = false;
472  	}
473  	#endif
474  	virtual ~TiXmlDocumentA() {}
475  	bool LoadFile();
476  	bool SaveFile() const;
477  	bool LoadFile( const char * filename );
478  	bool SaveFile( const char * filename ) const;
479  	bool LoadUnicodeFilePath( const TCHAR* filename );
480  	bool SaveUnicodeFilePath( const TCHAR* filename ) const;
481  	#ifdef TIXMLA_USE_STL
482  	bool LoadFile( const std::string&amp; filename )			
483  	{
484  		StringToBuffer f( filename );
485  		return ( f.buffer &amp;&amp; LoadFile( f.buffer ));
486  	}
487  	bool SaveFile( const std::string&amp; filename ) const		
488  	{
489  		StringToBuffer f( filename );
490  		return ( f.buffer &amp;&amp; SaveFile( f.buffer ));
491  	}
492  	#endif
493  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data = 0 );
494  	TiXmlElementA* RootElement() const		{ return FirstChildElement(); }
495  	bool Error() const						{ return error; }
496  	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
497  	int ErrorId()	const					{ return errorId; }
498  	int ErrorRow()	{ return errorLocation.row+1; }
499  	int ErrorCol()	{ return errorLocation.col+1; }	
500  	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
501  	int TabSize() const	{ return tabsize; }
502  	void ClearError()						{	error = false; 
503  												errorId = 0; 
504  												errorDesc = &quot;&quot;; 
505  												errorLocation.row = errorLocation.col = 0; 
506  											}
507  	void Print() const						{ Print( stdout, 0 ); }
508  	virtual void Print( FILE* cfile, int depth = 0 ) const;
509  	void SetError( int err, const char* errorLocation, TiXmlParsingDataA* prevData );
510  protected :
511  	virtual void StreamOut ( TIXMLA_OSTREAM * out) const;
512  	virtual TiXmlNodeA* Clone() const;
513  	#ifdef TIXMLA_USE_STL
514  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
515  	#endif
516  private:
517  	bool error;
518  	int  errorId;
519  	TIXMLA_STRING errorDesc;
520  	int tabsize;
521  	TiXmlCursorA errorLocation;
522  };
523  class TiXmlHandleA
524  {
525  public:
526  	TiXmlHandleA( TiXmlNodeA* node )			{ this-&gt;node = node; }
527  	TiXmlHandleA( const TiXmlHandleA&amp; ref )	{ this-&gt;node = ref.node; }
528  	TiXmlHandleA FirstChild() const;
529  	TiXmlHandleA FirstChild( const char * value ) const;
530  	TiXmlHandleA FirstChildElement() const;
531  	TiXmlHandleA FirstChildElement( const char * value ) const;
532  	TiXmlHandleA Child( const char* value, int index ) const;
533  	TiXmlHandleA Child( int index ) const;
534  	TiXmlHandleA ChildElement( const char* value, int index ) const;
535  	TiXmlHandleA ChildElement( int index ) const;
536  	#ifdef TIXMLA_USE_STL
537  	TiXmlHandleA FirstChild( const std::string&amp; _value ) const			{ return FirstChild( _value.c_str() ); }
538  	TiXmlHandleA FirstChildElement( const std::string&amp; _value ) const		{ return FirstChildElement( _value.c_str() ); }
539  	TiXmlHandleA Child( const std::string&amp; _value, int index ) const			{ return Child( _value.c_str(), index ); }
540  	TiXmlHandleA ChildElement( const std::string&amp; _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
541  	#endif
542  	TiXmlNodeA* Node() const			{ return node; } 
543  	TiXmlElementA* Element() const	{ return ( ( node &amp;&amp; node-&gt;ToElement() ) ? node-&gt;ToElement() : 0 ); }
544  	TiXmlTextA* Text() const			{ return ( ( node &amp;&amp; node-&gt;ToText() ) ? node-&gt;ToText() : 0 ); }
545  private:
546  	TiXmlNodeA* node;
547  };
548  #ifdef _MSC_VER
549  #pragma warning( pop )
550  #endif
551  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.h</h3>
            <pre><code>1  #ifndef TINYXMLA_INCLUDED
2  #define TINYXMLA_INCLUDED
3  #ifdef _MSC_VER
4  #pragma warning( push )
5  #pragma warning( disable : 4458 ) 
6  #pragma warning( disable : 4530 )
7  #pragma warning( disable : 4786 )
8  #endif
9  #if defined( _DEBUG ) &amp;&amp; !defined( DEBUG )
10  #define DEBUG
11  #endif
12  #if defined( DEBUG ) &amp;&amp; defined( _MSC_VER )
13  #include &lt;windows.h&gt;
14  #define TIXMLA_LOG OutputDebugString
15  #else
16  #define TIXMLA_LOG printf
17  #endif
18  #ifdef TIXMLA_USE_STL
19  	#define TIXMLA_STRING	std::string
20  	#define TIXMLA_ISTREAM	std::istream
21  	#define TIXMLA_OSTREAM	std::ostream
22  #else
23  	#include &quot;tinystrA.h&quot;
24  	#define TIXMLA_STRING	TiXmlStringA
25  	#define TIXMLA_OSTREAM	TiXmlOutStreamA
26  #endif
27  #include &lt;stdio.h&gt;
28  #include &lt;assert.h&gt;
29  #include &lt;string&gt;
30  #include &lt;tchar.h&gt;
31  #include &quot;Common.h&quot;
32  class TiXmlDocumentA;
33  class TiXmlElementA;
34  class TiXmlCommentA;
35  class TiXmlUnknownA;
36  class TiXmlAttributeA;
37  class TiXmlTextA;
38  class TiXmlDeclarationA;
39  class TiXmlParsingDataA;
40  struct TiXmlCursorA
41  {
42  	TiXmlCursorA()		{ Clear(); }
43  	void Clear()		{ row = col = -1; }
44  	int row;	
45  	int col;	
46  };
47  enum 
48  { 
49  	TIXMLA_SUCCESS,
50  	TIXMLA_NO_ATTRIBUTE,
51  	TIXMLA_WRONG_TYPE
52  };
53  class TiXmlBaseA
54  {
55  	friend class TiXmlNodeA;
56  	friend class TiXmlElementA;
57  	friend class TiXmlDocumentA;
58  public:
59  	TiXmlBaseA()								{}
60  	virtual ~TiXmlBaseA()					{}
61  	virtual void Print( FILE* cfile, int depth ) const = 0;
62  	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
63  	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
64  	int Row() const			{ return location.row + 1; }
65  	int Column() const		{ return location.col + 1; }	
66  protected:
67  	class StringToBuffer
68  	{
69  	  public:
70  		StringToBuffer( const TIXMLA_STRING&amp; str );
71  		~StringToBuffer();
72  		char* buffer;
73  	};
74  	static const char*	SkipWhiteSpace( const char* );
75  	inline static bool	IsWhiteSpace( int c )		{ return ( isspace( c ) || c == &#x27;\n&#x27; || c == &#x27;\r&#x27; ); }
76  	virtual void StreamOut (TIXMLA_OSTREAM *) const = 0;
77  	#ifdef TIXMLA_USE_STL
78  	    static bool	StreamWhiteSpace( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
79  	    static bool StreamTo( TIXMLA_ISTREAM * in, int character, TIXMLA_STRING * tag );
80  	#endif
81  	static const char* ReadName( const char* p, TIXMLA_STRING* name );
82  	static const char* ReadText(	const char* in,				
83  									TIXMLA_STRING* text,			
84  									bool ignoreWhiteSpace,		
85  									const char* endTag,			
86  									bool ignoreCase );			
87  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data ) = 0;
88  	static const char* GetEntity( const char* in, char* value );
89  	inline static const char* GetChar( const char* p, char* _value )
90  	{
91  		assert( p );
92  		if ( *p == &#x27;&amp;&#x27; )
93  		{
94  			return GetEntity( p, _value );
95  		}
96  		else
97  		{
98  			*_value = *p;
99  			return p+1;
100  		}
101  	}
102  	static void PutString( const TIXMLA_STRING&amp; str, TIXMLA_OSTREAM* out );
103  	static void PutString( const TIXMLA_STRING&amp; str, TIXMLA_STRING* out );
104  	static bool StringEqual(	const char* p,
105  								const char* endTag,
106  								bool ignoreCase );
107  	enum
108  	{
109  		TIXMLA_NO_ERROR = 0,
110  		TIXMLA_ERROR,
111  		TIXMLA_ERROR_OPENING_FILE,
112  		TIXMLA_ERROR_OUT_OF_MEMORY,
113  		TIXMLA_ERROR_PARSING_ELEMENT,
114  		TIXMLA_ERROR_FAILED_TO_READ_ELEMENT_NAME,
115  		TIXMLA_ERROR_READING_ELEMENT_VALUE,
116  		TIXMLA_ERROR_READING_ATTRIBUTES,
117  		TIXMLA_ERROR_PARSING_EMPTY,
118  		TIXMLA_ERROR_READING_END_TAG,
119  		TIXMLA_ERROR_PARSING_UNKNOWN,
120  		TIXMLA_ERROR_PARSING_COMMENT,
121  		TIXMLA_ERROR_PARSING_DECLARATION,
122  		TIXMLA_ERROR_DOCUMENT_EMPTY,
123  		TIXMLA_ERROR_STRING_COUNT
124  	};
125  	static const char* errorString[ TIXMLA_ERROR_STRING_COUNT ];
126  	TiXmlCursorA location;
127  private:
128  	struct Entity
129  	{
130  		const char*     str;
131  		unsigned int	strLength;
132  		char		    chr;
133  	};
134  	enum
135  	{
136  		NUM_ENTITY = 5,
137  		MAX_ENTITY_LENGTH = 6
138  	};
139  	static Entity entity[ NUM_ENTITY ];
140  	static bool condenseWhiteSpace;
141  };
142  class TiXmlNodeA : public TiXmlBaseA
143  {
144  	friend class TiXmlDocumentA;
145  	friend class TiXmlElementA;
146  public:
147  	#ifdef TIXMLA_USE_STL	
148  	    friend std::istream&amp; operator &gt;&gt; (std::istream&amp; in, TiXmlNodeA&amp; base);
149  	    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const TiXmlNodeA&amp; base);
150  		friend std::string&amp; operator&lt;&lt; (std::string&amp; out, const TiXmlNodeA&amp; base );
151  	#else
152  	    friend TIXMLA_OSTREAM&amp; operator&lt;&lt; (TIXMLA_OSTREAM&amp; out, const TiXmlNodeA&amp; base);
153  	#endif
154  	enum NodeType
155  	{
156  		DOCUMENT,
157  		ELEMENT,
158  		COMMENT,
159  		UNKNOWN,
160  		TEXT,
161  		DECLARATION,
162  		TYPECOUNT
163  	};
164  	virtual ~TiXmlNodeA();
165  	const char * Value() const { return value.c_str (); }
166  	void SetValue(const char * _value) { value = _value;}
167      #ifdef TIXMLA_USE_STL
168  	void SetValue( const std::string&amp; _value )    
169  	{	  
170  		StringToBuffer buf( _value );
171  		SetValue( buf.buffer ? buf.buffer : &quot;&quot; );    	
172  	}	
173  	#endif
174  	void Clear();
175  	TiXmlNodeA* Parent() const					{ return parent; }
176  	TiXmlNodeA* FirstChild()	const	{ return firstChild; }		
177  	TiXmlNodeA* FirstChild( const char * value ) const;			
178  	TiXmlNodeA* LastChild() const	{ return lastChild; }		
179  	TiXmlNodeA* LastChild( const char * value ) const;			
180      #ifdef TIXMLA_USE_STL
181  	TiXmlNodeA* FirstChild( const std::string&amp; _value ) const	{	return FirstChild (_value.c_str ());	}	
182  	TiXmlNodeA* LastChild( const std::string&amp; _value ) const		{	return LastChild (_value.c_str ());	}	
183  	#endif
184  	TiXmlNodeA* IterateChildren( TiXmlNodeA* previous ) const;
185  	TiXmlNodeA* IterateChildren( const char * value, TiXmlNodeA* previous ) const;
186      #ifdef TIXMLA_USE_STL
187  	TiXmlNodeA* IterateChildren( const std::string&amp; _value, TiXmlNodeA* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	
188  	#endif
189  	TiXmlNodeA* InsertEndChild( const TiXmlNodeA&amp; addThis );
190  	TiXmlNodeA* LinkEndChild( TiXmlNodeA* addThis );
191  	TiXmlNodeA* InsertBeforeChild( TiXmlNodeA* beforeThis, const TiXmlNodeA&amp; addThis );
192  	TiXmlNodeA* InsertAfterChild(  TiXmlNodeA* afterThis, const TiXmlNodeA&amp; addThis );
193  	TiXmlNodeA* ReplaceChild( TiXmlNodeA* replaceThis, const TiXmlNodeA&amp; withThis );
194  	bool RemoveChild( TiXmlNodeA* removeThis );
195  	TiXmlNodeA* PreviousSibling() const			{ return prev; }
196  	TiXmlNodeA* PreviousSibling( const char * ) const;
197      #ifdef TIXMLA_USE_STL
198  	TiXmlNodeA* PreviousSibling( const std::string&amp; _value ) const	{	return PreviousSibling (_value.c_str ());	}	
199  	TiXmlNodeA* NextSibling( const std::string&amp; _value) const		{	return NextSibling (_value.c_str ());	}	
200  	#endif
201  	TiXmlNodeA* NextSibling() const				{ return next; }
202  	TiXmlNodeA* NextSibling( const char * ) const;
203  	TiXmlElementA* NextSiblingElement() const;
204  	TiXmlElementA* NextSiblingElement( const char * ) const;
205      #ifdef TIXMLA_USE_STL
206  	TiXmlElementA* NextSiblingElement( const std::string&amp; _value) const	{	return NextSiblingElement (_value.c_str ());	}	
207  	#endif
208  	TiXmlElementA* FirstChildElement()	const;
209  	TiXmlElementA* FirstChildElement( const char * value ) const;
210      #ifdef TIXMLA_USE_STL
211  	TiXmlElementA* FirstChildElement( const std::string&amp; _value ) const	{	return FirstChildElement (_value.c_str ());	}	
212  	#endif
213  	virtual int Type() const	{ return type; }
214  	TiXmlDocumentA* GetDocument() const;
215  	bool NoChildren() const						{ return !firstChild; }
216  	TiXmlDocumentA* ToDocument()	const		{ return ( type == DOCUMENT ) ? (TiXmlDocumentA*) this : 0; } 
217  	TiXmlElementA*  ToElement() const		{ return ( type == ELEMENT  ) ? (TiXmlElementA*)  this : 0; } 
218  	TiXmlCommentA*  ToComment() const		{ return ( type == COMMENT  ) ? (TiXmlCommentA*)  this : 0; } 
219  	TiXmlUnknownA*  ToUnknown() const		{ return ( type == UNKNOWN  ) ? (TiXmlUnknownA*)  this : 0; } 
220  	TiXmlTextA*	   ToText()    const		{ return ( type == TEXT     ) ? (TiXmlTextA*)     this : 0; } 
221  	TiXmlDeclarationA* ToDeclaration() const	{ return ( type == DECLARATION ) ? (TiXmlDeclarationA*) this : 0; } 
222  	virtual TiXmlNodeA* Clone() const = 0;
223  	void  SetUserData( void* user )			{ userData = user; }
224  	void* GetUserData()						{ return userData; }
225  protected:
226  	TiXmlNodeA( NodeType type );
227  	#ifdef TIXMLA_USE_STL
228  	    virtual void StreamIn( TIXMLA_ISTREAM* in, TIXMLA_STRING* tag ) = 0;
229  	#endif
230  	TiXmlNodeA* Identify( const char* start );
231  	void CopyToClone( TiXmlNodeA* target ) const	{ target-&gt;SetValue (value.c_str() );
232  												  target-&gt;userData = userData; }
233  	TIXMLA_STRING SValue() const	{ return value ; }
234  	TiXmlNodeA*		parent;
235  	NodeType		type;
236  	TiXmlNodeA*		firstChild;
237  	TiXmlNodeA*		lastChild;
238  	TIXMLA_STRING	value;
239  	TiXmlNodeA*		prev;
240  	TiXmlNodeA*		next;
241  	void*			userData;
242  };
243  class TiXmlAttributeA : public TiXmlBaseA
244  {
245  	friend class TiXmlAttributeSetA;
246  public:
247  	TiXmlAttributeA()
248  	{
249  		document = 0;
250  		prev = next = 0;
251  	}
252  	#ifdef TIXMLA_USE_STL
253  	TiXmlAttributeA( const std::string&amp; _name, const std::string&amp; _value )
254  	{
255  		name = _name;
256  		value = _value;
257  		document = 0;
258  		prev = next = 0;
259  	}
260  	#endif
261  	TiXmlAttributeA( const char * _name, const char * _value )
262  	{
263  		name = _name;
264  		value = _value;
265  		document = 0;
266  		prev = next = 0;
267  	}
268  	const char*     Name()  const		{ return name.c_str (); }		
269  	const char*     Value() const		{ return value.c_str (); }		
270  	int             IntValue() const;									
271  	double          DoubleValue() const;								
272  	int QueryIntValue( int* value ) const;
273  	int QueryDoubleValue( double* value ) const;
274  	void SetName( const char* _name )	{ name = _name; }				
275  	void SetValue( const char* _value )	{ value = _value; }				
276  	void SetIntValue( int value );										
277  	void SetDoubleValue( double value );								
278      #ifdef TIXMLA_USE_STL
279  	void SetName( const std::string&amp; _name )	
280  	{	
281  		StringToBuffer buf( _name );
282  		SetName ( buf.buffer ? buf.buffer : &quot;error&quot; );	
283  	}
284  	void SetValue( const std::string&amp; _value )	
285  	{	
286  		StringToBuffer buf( _value );
287  		SetValue( buf.buffer ? buf.buffer : &quot;error&quot; );	
288  	}
289  	#endif
290  	TiXmlAttributeA* Next() const;
291  	TiXmlAttributeA* Previous() const;
292  	bool operator==( const TiXmlAttributeA&amp; rhs ) const { return rhs.name == name; }
293  	bool operator&lt;( const TiXmlAttributeA&amp; rhs )	 const { return name &lt; rhs.name; }
294  	bool operator&gt;( const TiXmlAttributeA&amp; rhs )  const { return name &gt; rhs.name; }
295  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
296  	virtual void Print( FILE* cfile, int depth ) const;
297  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
298  	void SetDocument( TiXmlDocumentA* doc )	{ document = doc; }
299  private:
300  	TiXmlDocumentA*	document;	
301  	TIXMLA_STRING name;
302  	TIXMLA_STRING value;
303  	TiXmlAttributeA*	prev;
304  	TiXmlAttributeA*	next;
305  };
306  class TiXmlAttributeSetA
307  {
308  public:
309  	TiXmlAttributeSetA();
310  	~TiXmlAttributeSetA();
311  	void Add( TiXmlAttributeA* attribute );
312  	void Remove( TiXmlAttributeA* attribute );
313  	TiXmlAttributeA* First() const	{ return ( sentinel.next == &amp;sentinel ) ? 0 : sentinel.next; }
314  	TiXmlAttributeA* Last()  const	{ return ( sentinel.prev == &amp;sentinel ) ? 0 : sentinel.prev; }
315  	TiXmlAttributeA*	Find( const char * name ) const;
316  private:
317  	TiXmlAttributeA sentinel;
318  };
319  class TiXmlElementA : public TiXmlNodeA
320  {
321  public:
322  	TiXmlElementA (const char * in_value);
323  	#ifdef TIXMLA_USE_STL
324  	TiXmlElementA( const std::string&amp; _value ) : 	TiXmlNodeA( TiXmlNodeA::ELEMENT )
325  	{
326  		firstChild = lastChild = 0;
327  		value = _value;
328  	}
329  	#endif
330  	virtual ~TiXmlElementA();
331  	const char* Attribute( const char* name ) const;
332  	const char* Attribute( const char* name, int* i ) const;
333  	const char* Attribute( const char* name, double* d ) const;
334  	int QueryIntAttribute( const char* name, int* value ) const;
335  	int QueryDoubleAttribute( const char* name, double* value ) const;
336  	void SetAttribute( const char* name, const char * value );
337      #ifdef TIXMLA_USE_STL
338  	const char* Attribute( const std::string&amp; name ) const				{ return Attribute( name.c_str() ); }
339  	const char* Attribute( const std::string&amp; name, int* i ) const		{ return Attribute( name.c_str(), i ); }
340  	void SetAttribute( const std::string&amp; name, const std::string&amp; _value )	
341  	{	
342  		StringToBuffer n( name );
343  		StringToBuffer v( _value );
344  		if ( n.buffer &amp;&amp; v.buffer )
345  			SetAttribute (n.buffer, v.buffer );	
346  	}	
347  	void SetAttribute( const std::string&amp; name, int _value )	
348  	{	
349  		StringToBuffer n( name );
350  		if ( n.buffer )
351  			SetAttribute (n.buffer, _value);	
352  	}	
353  	#endif
354  	void SetAttribute( const char * name, int value );
355  	void RemoveAttribute( const char * name );
356      #ifdef TIXMLA_USE_STL
357  	void RemoveAttribute( const std::string&amp; name )	{	RemoveAttribute (name.c_str ());	}	
358  	#endif
359  	TiXmlAttributeA* FirstAttribute() const	{ return attributeSet.First(); }		
360  	TiXmlAttributeA* LastAttribute()	const 	{ return attributeSet.Last(); }		
361  	virtual TiXmlNodeA* Clone() const;
362  	virtual void Print( FILE* cfile, int depth ) const;
363  protected:
364  	#ifdef TIXMLA_USE_STL
365  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
366  	#endif
367  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
368  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
369  	const char* ReadValue( const char* in, TiXmlParsingDataA* prevData );
370  private:
371  	TiXmlAttributeSetA attributeSet;
372  };
373  class TiXmlCommentA : public TiXmlNodeA
374  {
375  public:
376  	TiXmlCommentA() : TiXmlNodeA( TiXmlNodeA::COMMENT ) {}
377  	virtual ~TiXmlCommentA()	{}
378  	virtual TiXmlNodeA* Clone() const;
379  	virtual void Print( FILE* cfile, int depth ) const;
380  protected:
381  	#ifdef TIXMLA_USE_STL
382  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
383  	#endif
384  	virtual void StreamOut( TIXMLA_OSTREAM * out ) const;
385  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
386  };
387  class TiXmlTextA : public TiXmlNodeA
388  {
389  	friend class TiXmlElementA;
390  public:
391  	TiXmlTextA (const char * initValue) : TiXmlNodeA (TiXmlNodeA::TEXT)
392  	{
393  		SetValue( initValue );
394  	}
395  	virtual ~TiXmlTextA() {}
396  	#ifdef TIXMLA_USE_STL
397  	TiXmlTextA( const std::string&amp; initValue ) : TiXmlNodeA (TiXmlNodeA::TEXT)
398  	{
399  		SetValue( initValue );
400  	}
401  	#endif
402  	virtual void Print( FILE* cfile, int depth ) const;
403  protected :
404  	virtual TiXmlNodeA* Clone() const;
405  	virtual void StreamOut ( TIXMLA_OSTREAM * out ) const;
406  	bool Blank() const;	
407  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
408  	#ifdef TIXMLA_USE_STL
409  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
410  	#endif
411  };
412  class TiXmlDeclarationA : public TiXmlNodeA
413  {
414  public:
415  	TiXmlDeclarationA()   : TiXmlNodeA( TiXmlNodeA::DECLARATION ) {}
416  #ifdef TIXMLA_USE_STL
417  	TiXmlDeclarationA(	const std::string&amp; _version,
418  						const std::string&amp; _encoding,
419  						const std::string&amp; _standalone )
420  			: TiXmlNodeA( TiXmlNodeA::DECLARATION )
421  	{
422  		version = _version;
423  		encoding = _encoding;
424  		standalone = _standalone;
425  	}
426  #endif
427  	TiXmlDeclarationA(	const char* _version,
428  						const char* _encoding,
429  						const char* _standalone );
430  	virtual ~TiXmlDeclarationA()	{}
431  	const char * Version() const		{ return version.c_str (); }
432  	const char * Encoding() const		{ return encoding.c_str (); }
433  	const char * Standalone() const		{ return standalone.c_str (); }
434  	virtual TiXmlNodeA* Clone() const;
435  	virtual void Print( FILE* cfile, int depth ) const;
436  protected:
437  	#ifdef TIXMLA_USE_STL
438  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
439  	#endif
440  	virtual void StreamOut ( TIXMLA_OSTREAM * out) const;
441  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
442  private:
443  	TIXMLA_STRING version;
444  	TIXMLA_STRING encoding;
445  	TIXMLA_STRING standalone;
446  };
447  class TiXmlUnknownA : public TiXmlNodeA
448  {
449  public:
450  	TiXmlUnknownA() : TiXmlNodeA( TiXmlNodeA::UNKNOWN ) {}
451  	virtual ~TiXmlUnknownA() {}
452  	virtual TiXmlNodeA* Clone() const;
453  	virtual void Print( FILE* cfile, int depth ) const;
454  protected:
455  	#ifdef TIXMLA_USE_STL
456  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
457  	#endif
458  	virtual void StreamOut ( TIXMLA_OSTREAM * out ) const;
459  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data );
460  };
461  class TiXmlDocumentA : public TiXmlNodeA
462  {
463  public:
464  	TiXmlDocumentA();
465  	TiXmlDocumentA( const char * documentName );
466  	#ifdef TIXMLA_USE_STL
<span onclick='openModal()' class='match'>467  	TiXmlDocumentA( const std::string&amp; documentName ) :
468  	    TiXmlNodeA( TiXmlNodeA::DOCUMENT )
469  	{
470          value = documentName;
</span>471  		error = false;
472  	}
473  	#endif
474  	virtual ~TiXmlDocumentA() {}
475  	bool LoadFile();
476  	bool SaveFile() const;
477  	bool LoadFile( const char * filename );
478  	bool SaveFile( const char * filename ) const;
479  	bool LoadUnicodeFilePath( const TCHAR* filename );
480  	bool SaveUnicodeFilePath( const TCHAR* filename ) const;
481  	#ifdef TIXMLA_USE_STL
482  	bool LoadFile( const std::string&amp; filename )			
483  	{
484  		StringToBuffer f( filename );
485  		return ( f.buffer &amp;&amp; LoadFile( f.buffer ));
486  	}
487  	bool SaveFile( const std::string&amp; filename ) const		
488  	{
489  		StringToBuffer f( filename );
490  		return ( f.buffer &amp;&amp; SaveFile( f.buffer ));
491  	}
492  	#endif
493  	virtual const char* Parse( const char* p, TiXmlParsingDataA* data = 0 );
494  	TiXmlElementA* RootElement() const		{ return FirstChildElement(); }
495  	bool Error() const						{ return error; }
496  	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
497  	int ErrorId()	const					{ return errorId; }
498  	int ErrorRow()	{ return errorLocation.row+1; }
499  	int ErrorCol()	{ return errorLocation.col+1; }	
500  	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
501  	int TabSize() const	{ return tabsize; }
502  	void ClearError()						{	error = false; 
503  												errorId = 0; 
504  												errorDesc = &quot;&quot;; 
505  												errorLocation.row = errorLocation.col = 0; 
506  											}
507  	void Print() const						{ Print( stdout, 0 ); }
508  	virtual void Print( FILE* cfile, int depth = 0 ) const;
509  	void SetError( int err, const char* errorLocation, TiXmlParsingDataA* prevData );
510  protected :
511  	virtual void StreamOut ( TIXMLA_OSTREAM * out) const;
512  	virtual TiXmlNodeA* Clone() const;
513  	#ifdef TIXMLA_USE_STL
514  	    virtual void StreamIn( TIXMLA_ISTREAM * in, TIXMLA_STRING * tag );
515  	#endif
516  private:
517  	bool error;
518  	int  errorId;
519  	TIXMLA_STRING errorDesc;
520  	int tabsize;
521  	TiXmlCursorA errorLocation;
522  };
523  class TiXmlHandleA
524  {
525  public:
526  	TiXmlHandleA( TiXmlNodeA* node )			{ this-&gt;node = node; }
527  	TiXmlHandleA( const TiXmlHandleA&amp; ref )	{ this-&gt;node = ref.node; }
528  	TiXmlHandleA FirstChild() const;
529  	TiXmlHandleA FirstChild( const char * value ) const;
530  	TiXmlHandleA FirstChildElement() const;
531  	TiXmlHandleA FirstChildElement( const char * value ) const;
532  	TiXmlHandleA Child( const char* value, int index ) const;
533  	TiXmlHandleA Child( int index ) const;
534  	TiXmlHandleA ChildElement( const char* value, int index ) const;
535  	TiXmlHandleA ChildElement( int index ) const;
536  	#ifdef TIXMLA_USE_STL
537  	TiXmlHandleA FirstChild( const std::string&amp; _value ) const			{ return FirstChild( _value.c_str() ); }
538  	TiXmlHandleA FirstChildElement( const std::string&amp; _value ) const		{ return FirstChildElement( _value.c_str() ); }
539  	TiXmlHandleA Child( const std::string&amp; _value, int index ) const			{ return Child( _value.c_str(), index ); }
540  	TiXmlHandleA ChildElement( const std::string&amp; _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
541  	#endif
542  	TiXmlNodeA* Node() const			{ return node; } 
543  	TiXmlElementA* Element() const	{ return ( ( node &amp;&amp; node-&gt;ToElement() ) ? node-&gt;ToElement() : 0 ); }
544  	TiXmlTextA* Text() const			{ return ( ( node &amp;&amp; node-&gt;ToText() ) ? node-&gt;ToText() : 0 ); }
545  private:
546  	TiXmlNodeA* node;
547  };
548  #ifdef _MSC_VER
549  #pragma warning( pop )
550  #endif
551  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-tinyxmlA.h</div>
                </div>
                <div class="column column_space"><pre><code>397  	TiXmlTextA( const std::string&amp; initValue ) : TiXmlNodeA (TiXmlNodeA::TEXT)
398  	{
399  		SetValue( initValue );
</pre></code></div>
                <div class="column column_space"><pre><code>467  	TiXmlDocumentA( const std::string&amp; documentName ) :
468  	    TiXmlNodeA( TiXmlNodeA::DOCUMENT )
469  	{
470          value = documentName;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    