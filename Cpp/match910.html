<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_mpc.cpp &amp; test_mp4.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_mpc.cpp &amp; test_mp4.cpp
      </h3>
<h1 align="center">
        11.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_mpc.cpp (44.444443%)<th>test_mp4.cpp (6.763285%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(68-114)<td><a href="#" name="0">(573-602)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(127-148)<td><a href="#" name="1">(157-177)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mpc.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;apetag.h&gt;
#include &lt;id3v1tag.h&gt;
#include &lt;tstringlist.h&gt;
#include &lt;tbytevectorlist.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;mpcfile.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include "utils.h"
using namespace std;
using namespace TagLib;
class TestMPC : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestMPC);
  CPPUNIT_TEST(testPropertiesSV8);
  CPPUNIT_TEST(testPropertiesSV7);
  CPPUNIT_TEST(testPropertiesSV5);
  CPPUNIT_TEST(testPropertiesSV4);
  CPPUNIT_TEST(testFuzzedFile1);
  CPPUNIT_TEST(testFuzzedFile2);
  CPPUNIT_TEST(testFuzzedFile3);
  CPPUNIT_TEST(testFuzzedFile4);
  CPPUNIT_TEST(testStripAndProperties);
  CPPUNIT_TEST(testRepeatedSave);
  CPPUNIT_TEST_SUITE_END();
public:
  void testPropertiesSV8()
  {
    MPC::File f(TEST_FILE_PATH_C("sv8_header.mpc"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(8, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(1, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(1497, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(1, f.audioProperties()-&gt;bitrate());
<a name="0"></a>    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(66014U, f.audioProperties()-&gt;sampleFrames());
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
  void testPropertiesSV7()
  {
    MPC::File f(TEST_FILE_PATH_C("click.mpc"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(7, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(40, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(318, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1760U, f.audioProperties()-&gt;sampleFrames());
    CPPUNIT_ASSERT_EQUAL(14221, f.audioProperties()-&gt;trackGain());
    CPPUNIT_ASSERT_EQUAL(19848, f.audioProperties()-&gt;trackPeak());
    CPPUNIT_ASSERT_EQUAL(14221, f.audioProperties()-&gt;albumGain());
    CPPUNIT_ASSERT_EQUAL(19848, f.audioProperties()-&gt;albumPeak());
  }
  void testPropertiesSV5()
  {
    MPC::File f(TEST_FILE_PATH_C("sv5_header.mpc"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(5, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(26, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(26371, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1162944U, f.audioProperties()-&gt;sampleFrames());
  }
  void testPropertiesSV4()
  {
    MPC::File f(TEST_FILE_PATH_C("sv4_header.mpc"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(4, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(26, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(26371, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1162944U, f.audioProperties()-&gt;sampleFrames());
  }
  void testFuzzedFile1()
  {</b></font>
    MPC::File f(TEST_FILE_PATH_C("zerodiv.mpc"));
    CPPUNIT_ASSERT(f.isValid());
  }
  void testFuzzedFile2()
  {
    MPC::File f(TEST_FILE_PATH_C("infloop.mpc"));
    CPPUNIT_ASSERT(f.isValid());
  }
<a name="1"></a>
  void testFuzzedFile3()
  {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    MPC::File f(TEST_FILE_PATH_C("segfault.mpc"));
    CPPUNIT_ASSERT(f.isValid());
  }
  void testFuzzedFile4()
  {
    MPC::File f(TEST_FILE_PATH_C("segfault2.mpc"));
    CPPUNIT_ASSERT(f.isValid());
  }
  void testStripAndProperties()
  {
    ScopedFileCopy copy("click", ".mpc");
    {
      MPC::File f(copy.fileName().c_str());
      f.APETag(true)-&gt;setTitle("APE");
      f.ID3v1Tag(true)-&gt;setTitle("ID3v1");
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());</b></font>
      CPPUNIT_ASSERT_EQUAL(String("APE"), f.properties()["TITLE"].front());
      f.strip(MPC::File::APE);
      CPPUNIT_ASSERT_EQUAL(String("ID3v1"), f.properties()["TITLE"].front());
      f.strip(MPC::File::ID3v1);
      CPPUNIT_ASSERT(f.properties().isEmpty());
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(!f.hasAPETag());
      CPPUNIT_ASSERT(!f.hasID3v1Tag());
      CPPUNIT_ASSERT(f.properties()["TITLE"].isEmpty());
      CPPUNIT_ASSERT(f.properties().isEmpty());
    }
  }
  void testRepeatedSave()
  {
    ScopedFileCopy copy("click", ".mpc");
    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(!f.hasAPETag());
      CPPUNIT_ASSERT(!f.hasID3v1Tag());
      f.APETag(true)-&gt;setTitle("01234 56789 ABCDE FGHIJ");
      f.save();
      f.APETag()-&gt;setTitle("0");
      f.save();
      f.ID3v1Tag(true)-&gt;setTitle("01234 56789 ABCDE FGHIJ");
      f.APETag()-&gt;setTitle("01234 56789 ABCDE FGHIJ 01234 56789 ABCDE FGHIJ 01234 56789");
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.hasAPETag());
      CPPUNIT_ASSERT(f.hasID3v1Tag());
    }
  }
};
CPPUNIT_TEST_SUITE_REGISTRATION(TestMPC);
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mp4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;tag.h&gt;
#include &lt;mp4tag.h&gt;
#include &lt;tbytevectorlist.h&gt;
#include &lt;tbytevectorstream.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;mp4atom.h&gt;
#include &lt;mp4file.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include "plainfile.h"
#include "utils.h"
using namespace std;
using namespace TagLib;
class TestMP4 : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestMP4);
  CPPUNIT_TEST(testPropertiesAAC);
  CPPUNIT_TEST(testPropertiesAACWithoutBitrate);
  CPPUNIT_TEST(testPropertiesALAC);
  CPPUNIT_TEST(testPropertiesALACWithoutBitrate);
  CPPUNIT_TEST(testPropertiesM4V);
  CPPUNIT_TEST(testFreeForm);
  CPPUNIT_TEST(testCheckValid);
  CPPUNIT_TEST(testHasTag);
  CPPUNIT_TEST(testIsEmpty);
  CPPUNIT_TEST(testUpdateStco);
  CPPUNIT_TEST(testSaveExisingWhenIlstIsLast);
  CPPUNIT_TEST(test64BitAtom);
  CPPUNIT_TEST(testGnre);
  CPPUNIT_TEST(testCovrRead);
  CPPUNIT_TEST(testCovrWrite);
  CPPUNIT_TEST(testCovrRead2);
  CPPUNIT_TEST(testProperties);
  CPPUNIT_TEST(testPropertiesAllSupported);
  CPPUNIT_TEST(testPropertiesMovement);
  CPPUNIT_TEST(testFuzzedFile);
  CPPUNIT_TEST(testRepeatedSave);
  CPPUNIT_TEST(testWithZeroLengthAtom);
  CPPUNIT_TEST(testEmptyValuesRemoveItems);
  CPPUNIT_TEST(testRemoveMetadata);
  CPPUNIT_TEST(testNonFullMetaAtom);
  CPPUNIT_TEST_SUITE_END();
public:
  void testPropertiesAAC()
  {
    MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }
  void testPropertiesAACWithoutBitrate()
  {
    ByteVector aacData = PlainFile(TEST_FILE_PATH_C("has-tags.m4a")).readAll();
    CPPUNIT_ASSERT_GREATER(1960U, aacData.size());
    CPPUNIT_ASSERT_EQUAL(ByteVector("mp4a"), aacData.mid(1890, 4));
    for (int offset = 1956; offset &lt; 1960; ++offset) {
      aacData[offset] = 0;
    }
    ByteVectorStream aacStream(aacData);
    MP4::File f(&amp;aacStream);
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }
  void testPropertiesALAC()
  {
    MP4::File f(TEST_FILE_PATH_C("empty_alac.m4a"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
  }
  void testPropertiesALACWithoutBitrate()
  {
    ByteVector alacData = PlainFile(TEST_FILE_PATH_C("empty_alac.m4a")).readAll();
    CPPUNIT_ASSERT_GREATER(474U, alacData.size());
    CPPUNIT_ASSERT_EQUAL(ByteVector("alac"), alacData.mid(446, 4));
    for (int offset = 470; offset &lt; 474; ++offset) {
      alacData[offset] = 0;
    }
    ByteVectorStream alacStream(alacData);
    MP4::File f(&amp;alacStream);
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
  }
  void testPropertiesM4V()
  {
    MP4::File f(TEST_FILE_PATH_C("blank_video.m4v"));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(975, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(96, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
<a name="1"></a>    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }
  void testCheckValid()
  {
    MP4::File f(TEST_FILE_PATH_C("empty.aiff"));
    CPPUNIT_ASSERT(!f.isValid());
  }
  void testHasTag()
  {
    {
      MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
    }
    ScopedFileCopy copy("no-tags", ".m4a");
    {
      MP4::File f(copy.fileName().c_str());</b></font>
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      f.tag()-&gt;setTitle("TITLE");
      f.save();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
    }
  }
  void testIsEmpty()
  {
    MP4::Tag t1;
    CPPUNIT_ASSERT(t1.isEmpty());
    t1.setArtist("Foo");
    CPPUNIT_ASSERT(!t1.isEmpty());
    MP4::Tag t2;
    t2.setItem("foo", "bar");
    CPPUNIT_ASSERT(!t2.isEmpty());
  }
  void testUpdateStco()
  {
    ScopedFileCopy copy("no-tags", ".3g2");
    string filename = copy.fileName();
    ByteVectorList data1;
    {
      MP4::File f(filename.c_str());
      f.tag()-&gt;setArtist(ByteVector(3000, 'x'));
      MP4::Atoms a(&amp;f);
      MP4::Atom *stco = a.find("moov")-&gt;findall("stco", true)[0];
      f.seek(stco-&gt;offset + 12);
      ByteVector data = f.readBlock(stco-&gt;length - 12);
      unsigned int count = data.mid(0, 4).toUInt();
      int pos = 4;
      while (count--) {
        unsigned int offset = data.mid(pos, 4).toUInt();
        f.seek(offset);
        data1.append(f.readBlock(20));
        pos += 4;
      }
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      MP4::Atoms a(&amp;f);
      MP4::Atom *stco = a.find("moov")-&gt;findall("stco", true)[0];
      f.seek(stco-&gt;offset + 12);
      ByteVector data = f.readBlock(stco-&gt;length - 12);
      unsigned int count = data.mid(0, 4).toUInt();
      int pos = 4, i = 0;
      while (count--) {
        unsigned int offset = data.mid(pos, 4).toUInt();
        f.seek(offset);
        CPPUNIT_ASSERT_EQUAL(data1[i], f.readBlock(20));
        pos += 4;
        i++;
      }
    }
  }
  void testFreeForm()
  {
    ScopedFileCopy copy("has-tags", ".m4a");
    string filename = copy.fileName();
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains("----:com.apple.iTunes:iTunNORM"));
      f.tag()-&gt;setItem("----:org.kde.TagLib:Foo", StringList("Bar"));
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains("----:org.kde.TagLib:Foo"));
      CPPUNIT_ASSERT_EQUAL(String("Bar"),
                           f.tag()-&gt;item("----:org.kde.TagLib:Foo").toStringList().front());
      f.save();
    }
  }
  void testSaveExisingWhenIlstIsLast()
  {
    ScopedFileCopy copy("ilst-is-last", ".m4a");
    string filename = copy.fileName();
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(String("82,164"),
        f.tag()-&gt;item("----:com.apple.iTunes:replaygain_track_minmax").toStringList().front());
      CPPUNIT_ASSERT_EQUAL(String("Pearl Jam"), f.tag()-&gt;artist());
      f.tag()-&gt;setComment("foo");
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(String("82,164"),
                           f.tag()-&gt;item("----:com.apple.iTunes:replaygain_track_minmax").toStringList().front());
      CPPUNIT_ASSERT_EQUAL(String("Pearl Jam"), f.tag()-&gt;artist());
      CPPUNIT_ASSERT_EQUAL(String("foo"), f.tag()-&gt;comment());
    }
  }
  void test64BitAtom()
  {
    ScopedFileCopy copy("64bit", ".mp4");
    string filename = copy.fileName();
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;itemMap()["cpil"].toBool());
      MP4::Atoms atoms(&amp;f);
      MP4::Atom *moov = atoms.atoms[0];
      CPPUNIT_ASSERT_EQUAL(long(77), moov-&gt;length);
      f.tag()-&gt;setItem("pgap", true);
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("cpil").toBool());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("pgap").toBool());
      MP4::Atoms atoms(&amp;f);
      MP4::Atom *moov = atoms.atoms[0];
      CPPUNIT_ASSERT_EQUAL(long(77 + 25 + 974), moov-&gt;length);
    }
  }
  void testGnre()
  {
    MP4::File f(TEST_FILE_PATH_C("gnre.m4a"));
    CPPUNIT_ASSERT_EQUAL(TagLib::String("Ska"), f.tag()-&gt;genre());
  }
  void testCovrRead()
  {
    MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
    CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
    MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
  }
  void testCovrWrite()
  {
    ScopedFileCopy copy("has-tags", ".m4a");
    string filename = copy.fileName();
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
      MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
      l.append(MP4::CoverArt(MP4::CoverArt::PNG, "foo"));
      f.tag()-&gt;setItem("covr", l);
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
      MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
      CPPUNIT_ASSERT_EQUAL((unsigned int)3, l.size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[2].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)3, l[2].data().size());
    }
  }
  void testCovrRead2()
  {
    MP4::File f(TEST_FILE_PATH_C("covr-junk.m4a"));
    CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
    MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
  }
  void testProperties()
  {
    MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
    PropertyMap tags = f.properties();
    CPPUNIT_ASSERT_EQUAL(StringList("Test Artist"), tags["ARTIST"]);
    tags["TRACKNUMBER"] = StringList("2/4");
    tags["DISCNUMBER"] = StringList("3/5");
    tags["BPM"] = StringList("123");
    tags["ARTIST"] = StringList("Foo Bar");
    tags["COMPILATION"] = StringList("1");
    f.setProperties(tags);
    tags = f.properties();
    CPPUNIT_ASSERT(f.tag()-&gt;contains("trkn"));
    CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item("trkn").toIntPair().first);
    CPPUNIT_ASSERT_EQUAL(4, f.tag()-&gt;item("trkn").toIntPair().second);
    CPPUNIT_ASSERT_EQUAL(StringList("2/4"), tags["TRACKNUMBER"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("disk"));
    CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item("disk").toIntPair().first);
    CPPUNIT_ASSERT_EQUAL(5, f.tag()-&gt;item("disk").toIntPair().second);
    CPPUNIT_ASSERT_EQUAL(StringList("3/5"), tags["DISCNUMBER"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("tmpo"));
    CPPUNIT_ASSERT_EQUAL(123, f.tag()-&gt;item("tmpo").toInt());
    CPPUNIT_ASSERT_EQUAL(StringList("123"), tags["BPM"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("\251ART"));
    CPPUNIT_ASSERT_EQUAL(StringList("Foo Bar"), f.tag()-&gt;item("\251ART").toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList("Foo Bar"), tags["ARTIST"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("cpil"));
    CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("cpil").toBool());
    CPPUNIT_ASSERT_EQUAL(StringList("1"), tags["COMPILATION"]);
    tags["COMPILATION"] = StringList("0");
    f.setProperties(tags);
    tags = f.properties();
    CPPUNIT_ASSERT(f.tag()-&gt;contains("cpil"));
    CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item("cpil").toBool());
    CPPUNIT_ASSERT_EQUAL(StringList("0"), tags["COMPILATION"]);
    tags["TRACKNUMBER"] = StringList();
    tags["DISCNUMBER"] = StringList();
    tags["BPM"] = StringList();
    tags["COMPILATION"] = StringList();
    f.setProperties(tags);
  }
  void testPropertiesAllSupported()
  {
    PropertyMap tags;
    tags["ALBUM"] = StringList("Album");
    tags["ALBUMARTIST"] = StringList("Album Artist");
    tags["ALBUMARTISTSORT"] = StringList("Album Artist Sort");
    tags["ALBUMSORT"] = StringList("Album Sort");
    tags["ARTIST"] = StringList("Artist");
    tags["ARTISTS"] = StringList("Artists");
    tags["ARTISTSORT"] = StringList("Artist Sort");
    tags["ASIN"] = StringList("ASIN");
    tags["BARCODE"] = StringList("Barcode");
    tags["BPM"] = StringList("123");
    tags["CATALOGNUMBER"] = StringList("Catalog Number");
    tags["COMMENT"] = StringList("Comment");
    tags["COMPILATION"] = StringList("1");
    tags["COMPOSER"] = StringList("Composer");
    tags["COMPOSERSORT"] = StringList("Composer Sort");
    tags["CONDUCTOR"] = StringList("Conductor");
    tags["COPYRIGHT"] = StringList("2021 Copyright");
    tags["DATE"] = StringList("2021-01-03 12:29:23");
    tags["DISCNUMBER"] = StringList("3/5");
    tags["DISCSUBTITLE"] = StringList("Disc Subtitle");
    tags["DJMIXER"] = StringList("DJ Mixer");
    tags["ENCODEDBY"] = StringList("Encoded by");
    tags["ENGINEER"] = StringList("Engineer");
    tags["GAPLESSPLAYBACK"] = StringList("1");
    tags["GENRE"] = StringList("Genre");
    tags["GROUPING"] = StringList("Grouping");
    tags["ISRC"] = StringList("UKAAA0500001");
    tags["LABEL"] = StringList("Label");
    tags["LANGUAGE"] = StringList("eng");
    tags["LICENSE"] = StringList("License");
    tags["LYRICIST"] = StringList("Lyricist");
    tags["LYRICS"] = StringList("Lyrics");
    tags["MEDIA"] = StringList("Media");
    tags["MIXER"] = StringList("Mixer");
    tags["MOOD"] = StringList("Mood");
    tags["MOVEMENTCOUNT"] = StringList("3");
    tags["MOVEMENTNAME"] = StringList("Movement Name");
    tags["MOVEMENTNUMBER"] = StringList("2");
    tags["MUSICBRAINZ_ALBUMARTISTID"] = StringList("MusicBrainz_AlbumartistID");
    tags["MUSICBRAINZ_ALBUMID"] = StringList("MusicBrainz_AlbumID");
    tags["MUSICBRAINZ_ARTISTID"] = StringList("MusicBrainz_ArtistID");
    tags["MUSICBRAINZ_RELEASEGROUPID"] = StringList("MusicBrainz_ReleasegroupID");
    tags["MUSICBRAINZ_RELEASETRACKID"] = StringList("MusicBrainz_ReleasetrackID");
    tags["MUSICBRAINZ_TRACKID"] = StringList("MusicBrainz_TrackID");
    tags["MUSICBRAINZ_WORKID"] = StringList("MusicBrainz_WorkID");
    tags["ORIGINALDATE"] = StringList("2021-01-03 13:52:19");
    tags["PODCAST"] = StringList("1");
    tags["PODCASTCATEGORY"] = StringList("Podcast Category");
    tags["PODCASTDESC"] = StringList("Podcast Description");
    tags["PODCASTID"] = StringList("Podcast ID");
    tags["PODCASTURL"] = StringList("Podcast URL");
    tags["PRODUCER"] = StringList("Producer");
    tags["RELEASECOUNTRY"] = StringList("Release Country");
    tags["RELEASESTATUS"] = StringList("Release Status");
    tags["RELEASETYPE"] = StringList("Release Type");
    tags["REMIXER"] = StringList("Remixer");
    tags["SCRIPT"] = StringList("Script");
    tags["SHOWSORT"] = StringList("Show Sort");
    tags["SHOWWORKMOVEMENT"] = StringList("1");
    tags["SUBTITLE"] = StringList("Subtitle");
    tags["TITLE"] = StringList("Title");
    tags["TITLESORT"] = StringList("Title Sort");
    tags["TRACKNUMBER"] = StringList("2/4");
    tags["TVEPISODE"] = StringList("3");
    tags["TVEPISODEID"] = StringList("TV Episode ID");
    tags["TVNETWORK"] = StringList("TV Network");
    tags["TVSEASON"] = StringList("2");
    tags["TVSHOW"] = StringList("TV Show");
    tags["WORK"] = StringList("Work");
    ScopedFileCopy copy("no-tags", ".m4a");
    {
      MP4::File f(copy.fileName().c_str());
      PropertyMap properties = f.properties();
      CPPUNIT_ASSERT(properties.isEmpty());
      f.setProperties(tags);
      f.save();
    }
    {
      const MP4::File f(copy.fileName().c_str());
      PropertyMap properties = f.properties();
      if (tags != properties) {
        CPPUNIT_ASSERT_EQUAL(tags.toString(), properties.toString());
      }
      CPPUNIT_ASSERT(tags == properties);
    }
  }
  void testPropertiesMovement()
  {
    MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
    PropertyMap tags = f.properties();
    tags["WORK"] = StringList("Foo");
    tags["MOVEMENTNAME"] = StringList("Bar");
    tags["MOVEMENTNUMBER"] = StringList("2");
    tags["MOVEMENTCOUNT"] = StringList("3");
    tags["SHOWWORKMOVEMENT"] = StringList("1");
    f.setProperties(tags);
    tags = f.properties();
    CPPUNIT_ASSERT(f.tag()-&gt;contains("\251wrk"));
    CPPUNIT_ASSERT_EQUAL(StringList("Foo"), f.tag()-&gt;item("\251wrk").toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList("Foo"), tags["WORK"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvn"));
    CPPUNIT_ASSERT_EQUAL(StringList("Bar"), f.tag()-&gt;item("\251mvn").toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList("Bar"), tags["MOVEMENTNAME"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvi"));
    CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item("\251mvi").toInt());
    CPPUNIT_ASSERT_EQUAL(StringList("2"), tags["MOVEMENTNUMBER"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("\251mvc"));
    CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item("\251mvc").toInt());
    CPPUNIT_ASSERT_EQUAL(StringList("3"), tags["MOVEMENTCOUNT"]);
    CPPUNIT_ASSERT(f.tag()-&gt;contains("shwm"));
    CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item("shwm").toBool());
    CPPUNIT_ASSERT_EQUAL(StringList("1"), tags["SHOWWORKMOVEMENT"]);
    tags["SHOWWORKMOVEMENT"] = StringList("0");
    f.setProperties(tags);
    tags = f.properties();
    CPPUNIT_ASSERT(f.tag()-&gt;contains("shwm"));
    CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item("shwm").toBool());
    CPPUNIT_ASSERT_EQUAL(StringList("0"), tags["SHOWWORKMOVEMENT"]);
    tags["WORK"] = StringList();
    tags["MOVEMENTNAME"] = StringList();
    tags["MOVEMENTNUMBER"] = StringList();
<a name="0"></a>    tags["MOVEMENTCOUNT"] = StringList();
    tags["SHOWWORKMOVEMENT"] = StringList();
    f.setProperties(tags);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
  void testFuzzedFile()
  {
    MP4::File f(TEST_FILE_PATH_C("infloop.m4a"));
    CPPUNIT_ASSERT(f.isValid());
  }
  void testRepeatedSave()
  {
    ScopedFileCopy copy("no-tags", ".m4a");
    MP4::File f(copy.fileName().c_str());
    f.tag()-&gt;setTitle("0123456789");
    f.save();
    f.save();
    CPPUNIT_ASSERT_EQUAL(2862L, f.find("0123456789"));
    CPPUNIT_ASSERT_EQUAL(-1L, f.find("0123456789", 2863));
  }
  void testWithZeroLengthAtom()
  {
    MP4::File f(TEST_FILE_PATH_C("zero-length-mdat.m4a"));
    CPPUNIT_ASSERT(f.isValid());
    CPPUNIT_ASSERT_EQUAL(1115, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(22050, f.audioProperties()-&gt;sampleRate());
  }
  void testEmptyValuesRemoveItems()
  {</b></font>
    const MP4::File f(TEST_FILE_PATH_C("has-tags.m4a"));
    MP4::Tag *tag = f.tag();
    const String testTitle("Title");
    const String testArtist("Artist");
    const String testAlbum("Album");
    const String testComment("Comment");
    const String testGenre("Genre");
    const String nullString;
    const unsigned int testYear = 2020;
    const unsigned int testTrack = 1;
    const unsigned int zeroUInt = 0;
    tag-&gt;setTitle(testTitle);
    CPPUNIT_ASSERT_EQUAL(testTitle, tag-&gt;title());
    CPPUNIT_ASSERT(tag-&gt;contains("\251nam"));
    tag-&gt;setArtist(testArtist);
    CPPUNIT_ASSERT_EQUAL(testArtist, tag-&gt;artist());
    CPPUNIT_ASSERT(tag-&gt;contains("\251ART"));
    tag-&gt;setAlbum(testAlbum);
    CPPUNIT_ASSERT_EQUAL(testAlbum, tag-&gt;album());
    CPPUNIT_ASSERT(tag-&gt;contains("\251alb"));
    tag-&gt;setComment(testComment);
    CPPUNIT_ASSERT_EQUAL(testComment, tag-&gt;comment());
    CPPUNIT_ASSERT(tag-&gt;contains("\251cmt"));
    tag-&gt;setGenre(testGenre);
    CPPUNIT_ASSERT_EQUAL(testGenre, tag-&gt;genre());
    CPPUNIT_ASSERT(tag-&gt;contains("\251gen"));
    tag-&gt;setYear(testYear);
    CPPUNIT_ASSERT_EQUAL(testYear, tag-&gt;year());
    CPPUNIT_ASSERT(tag-&gt;contains("\251day"));
    tag-&gt;setTrack(testTrack);
    CPPUNIT_ASSERT_EQUAL(testTrack, tag-&gt;track());
    CPPUNIT_ASSERT(tag-&gt;contains("trkn"));
    tag-&gt;setTitle(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;title());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251nam"));
    tag-&gt;setArtist(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;artist());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251ART"));
    tag-&gt;setAlbum(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;album());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251alb"));
    tag-&gt;setComment(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;comment());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251cmt"));
    tag-&gt;setGenre(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;genre());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251gen"));
    tag-&gt;setYear(zeroUInt);
    CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;year());
    CPPUNIT_ASSERT(!tag-&gt;contains("\251day"));
    tag-&gt;setTrack(zeroUInt);
    CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;track());
    CPPUNIT_ASSERT(!tag-&gt;contains("trkn"));
  }
  void testRemoveMetadata()
  {
    ScopedFileCopy copy("no-tags", ".m4a");
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      MP4::Tag *tag = f.tag();
      CPPUNIT_ASSERT(tag-&gt;isEmpty());
      tag-&gt;setTitle("TITLE");
      f.save();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
      CPPUNIT_ASSERT(!f.tag()-&gt;isEmpty());
      f.strip();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      CPPUNIT_ASSERT(f.tag()-&gt;isEmpty());
      CPPUNIT_ASSERT(fileEqual(
        copy.fileName(),
        TEST_FILE_PATH_C("no-tags.m4a")));
    }
  }
  void testNonFullMetaAtom()
  {
    {
      MP4::File f(TEST_FILE_PATH_C("non-full-meta.m4a"));
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
      CPPUNIT_ASSERT(f.tag()-&gt;contains("covr"));
      MP4::CoverArtList l = f.tag()-&gt;item("covr").toCoverArtList();
      CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
      PropertyMap properties = f.properties();
      CPPUNIT_ASSERT_EQUAL(StringList("Test Artist!!!!"), properties["ARTIST"]);
      CPPUNIT_ASSERT_EQUAL(StringList("FAAC 1.24"), properties["ENCODEDBY"]);
    }
  }
};
CPPUNIT_TEST_SUITE_REGISTRATION(TestMP4);
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
