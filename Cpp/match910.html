<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_mpc.cpp & test_mp4.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_mpc.cpp & test_mp4.cpp
      </h3>
      <h1 align="center">
        11.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_mpc.cpp (44.444443%)<TH>test_mp4.cpp (6.763285%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match910-0.html#0',2,'match910-1.html#0',3)" NAME="0">(68-114)<TD><A HREF="javascript:ZweiFrames('match910-0.html#0',2,'match910-1.html#0',3)" NAME="0">(573-602)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match910-0.html#1',2,'match910-1.html#1',3)" NAME="1">(127-148)<TD><A HREF="javascript:ZweiFrames('match910-0.html#1',2,'match910-1.html#1',3)" NAME="1">(157-177)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mpc.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright           : (C) 2012 by Lukas Lalinsky
    email               : lukas@oxygene.sk
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;apetag.h&gt;
#include &lt;id3v1tag.h&gt;
#include &lt;tstringlist.h&gt;
#include &lt;tbytevectorlist.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;mpcfile.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &quot;utils.h&quot;

using namespace std;
using namespace TagLib;

class TestMPC : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestMPC);
  CPPUNIT_TEST(testPropertiesSV8);
  CPPUNIT_TEST(testPropertiesSV7);
  CPPUNIT_TEST(testPropertiesSV5);
  CPPUNIT_TEST(testPropertiesSV4);
  CPPUNIT_TEST(testFuzzedFile1);
  CPPUNIT_TEST(testFuzzedFile2);
  CPPUNIT_TEST(testFuzzedFile3);
  CPPUNIT_TEST(testFuzzedFile4);
  CPPUNIT_TEST(testStripAndProperties);
  CPPUNIT_TEST(testRepeatedSave);
  CPPUNIT_TEST_SUITE_END();

public:

  void testPropertiesSV8()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;sv8_header.mpc&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(8, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(1, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(1497, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(1, f.audioProperties()-&gt;bitrate());
<A NAME="0"></A>    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(66014U, f.audioProperties()-&gt;sampleFrames());
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match910-1.html#0',3,'match910-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  }

  void testPropertiesSV7()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;click.mpc&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(7, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(40, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(318, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1760U, f.audioProperties()-&gt;sampleFrames());
    CPPUNIT_ASSERT_EQUAL(14221, f.audioProperties()-&gt;trackGain());
    CPPUNIT_ASSERT_EQUAL(19848, f.audioProperties()-&gt;trackPeak());
    CPPUNIT_ASSERT_EQUAL(14221, f.audioProperties()-&gt;albumGain());
    CPPUNIT_ASSERT_EQUAL(19848, f.audioProperties()-&gt;albumPeak());
  }

  void testPropertiesSV5()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;sv5_header.mpc&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(5, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(26, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(26371, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1162944U, f.audioProperties()-&gt;sampleFrames());
  }

  void testPropertiesSV4()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;sv4_header.mpc&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(4, f.audioProperties()-&gt;mpcVersion());
    CPPUNIT_ASSERT_EQUAL(26, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(26371, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(1162944U, f.audioProperties()-&gt;sampleFrames());
  }

  void testFuzzedFile1()
  {</B></FONT>
    MPC::File f(TEST_FILE_PATH_C(&quot;zerodiv.mpc&quot;));
    CPPUNIT_ASSERT(f.isValid());
  }

  void testFuzzedFile2()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;infloop.mpc&quot;));
    CPPUNIT_ASSERT(f.isValid());
  }
<A NAME="1"></A>
  void testFuzzedFile3()
  {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match910-1.html#1',3,'match910-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    MPC::File f(TEST_FILE_PATH_C(&quot;segfault.mpc&quot;));
    CPPUNIT_ASSERT(f.isValid());
  }

  void testFuzzedFile4()
  {
    MPC::File f(TEST_FILE_PATH_C(&quot;segfault2.mpc&quot;));
    CPPUNIT_ASSERT(f.isValid());
  }

  void testStripAndProperties()
  {
    ScopedFileCopy copy(&quot;click&quot;, &quot;.mpc&quot;);

    {
      MPC::File f(copy.fileName().c_str());
      f.APETag(true)-&gt;setTitle(&quot;APE&quot;);
      f.ID3v1Tag(true)-&gt;setTitle(&quot;ID3v1&quot;);
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());</B></FONT>
      CPPUNIT_ASSERT_EQUAL(String(&quot;APE&quot;), f.properties()[&quot;TITLE&quot;].front());
      f.strip(MPC::File::APE);
      CPPUNIT_ASSERT_EQUAL(String(&quot;ID3v1&quot;), f.properties()[&quot;TITLE&quot;].front());
      f.strip(MPC::File::ID3v1);
      CPPUNIT_ASSERT(f.properties().isEmpty());
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(!f.hasAPETag());
      CPPUNIT_ASSERT(!f.hasID3v1Tag());
      CPPUNIT_ASSERT(f.properties()[&quot;TITLE&quot;].isEmpty());
      CPPUNIT_ASSERT(f.properties().isEmpty());
    }
  }

  void testRepeatedSave()
  {
    ScopedFileCopy copy(&quot;click&quot;, &quot;.mpc&quot;);

    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(!f.hasAPETag());
      CPPUNIT_ASSERT(!f.hasID3v1Tag());

      f.APETag(true)-&gt;setTitle(&quot;01234 56789 ABCDE FGHIJ&quot;);
      f.save();

      f.APETag()-&gt;setTitle(&quot;0&quot;);
      f.save();

      f.ID3v1Tag(true)-&gt;setTitle(&quot;01234 56789 ABCDE FGHIJ&quot;);
      f.APETag()-&gt;setTitle(&quot;01234 56789 ABCDE FGHIJ 01234 56789 ABCDE FGHIJ 01234 56789&quot;);
      f.save();
    }
    {
      MPC::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.hasAPETag());
      CPPUNIT_ASSERT(f.hasID3v1Tag());
    }
  }

};

CPPUNIT_TEST_SUITE_REGISTRATION(TestMPC);
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mp4.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/***************************************************************************
    copyright           : (C) 2008 by Lukas Lalinsky
    email               : lukas@oxygene.sk
 ***************************************************************************/

/***************************************************************************
 *   This library is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Lesser General Public License version   *
 *   2.1 as published by the Free Software Foundation.                     *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful, but   *
 *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 *                                                                         *
 *   Alternatively, this file is available under the Mozilla Public        *
 *   License Version 1.1.  You may obtain a copy of the License at         *
 *   http://www.mozilla.org/MPL/                                           *
 ***************************************************************************/

#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;tag.h&gt;
#include &lt;mp4tag.h&gt;
#include &lt;tbytevectorlist.h&gt;
#include &lt;tbytevectorstream.h&gt;
#include &lt;tpropertymap.h&gt;
#include &lt;mp4atom.h&gt;
#include &lt;mp4file.h&gt;
#include &lt;cppunit/extensions/HelperMacros.h&gt;
#include &quot;plainfile.h&quot;
#include &quot;utils.h&quot;

using namespace std;
using namespace TagLib;

class TestMP4 : public CppUnit::TestFixture
{
  CPPUNIT_TEST_SUITE(TestMP4);
  CPPUNIT_TEST(testPropertiesAAC);
  CPPUNIT_TEST(testPropertiesAACWithoutBitrate);
  CPPUNIT_TEST(testPropertiesALAC);
  CPPUNIT_TEST(testPropertiesALACWithoutBitrate);
  CPPUNIT_TEST(testPropertiesM4V);
  CPPUNIT_TEST(testFreeForm);
  CPPUNIT_TEST(testCheckValid);
  CPPUNIT_TEST(testHasTag);
  CPPUNIT_TEST(testIsEmpty);
  CPPUNIT_TEST(testUpdateStco);
  CPPUNIT_TEST(testSaveExisingWhenIlstIsLast);
  CPPUNIT_TEST(test64BitAtom);
  CPPUNIT_TEST(testGnre);
  CPPUNIT_TEST(testCovrRead);
  CPPUNIT_TEST(testCovrWrite);
  CPPUNIT_TEST(testCovrRead2);
  CPPUNIT_TEST(testProperties);
  CPPUNIT_TEST(testPropertiesAllSupported);
  CPPUNIT_TEST(testPropertiesMovement);
  CPPUNIT_TEST(testFuzzedFile);
  CPPUNIT_TEST(testRepeatedSave);
  CPPUNIT_TEST(testWithZeroLengthAtom);
  CPPUNIT_TEST(testEmptyValuesRemoveItems);
  CPPUNIT_TEST(testRemoveMetadata);
  CPPUNIT_TEST(testNonFullMetaAtom);
  CPPUNIT_TEST_SUITE_END();

public:

  void testPropertiesAAC()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }

  void testPropertiesAACWithoutBitrate()
  {
    ByteVector aacData = PlainFile(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;)).readAll();
    CPPUNIT_ASSERT_GREATER(1960U, aacData.size());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;mp4a&quot;), aacData.mid(1890, 4));
    // Set the bitrate to zero
    for (int offset = 1956; offset &lt; 1960; ++offset) {
      aacData[offset] = 0;
    }
    ByteVectorStream aacStream(aacData);
    MP4::File f(&amp;aacStream);
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3708, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }

  void testPropertiesALAC()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;empty_alac.m4a&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
  }

  void testPropertiesALACWithoutBitrate()
  {
    ByteVector alacData = PlainFile(TEST_FILE_PATH_C(&quot;empty_alac.m4a&quot;)).readAll();
    CPPUNIT_ASSERT_GREATER(474U, alacData.size());
    CPPUNIT_ASSERT_EQUAL(ByteVector(&quot;alac&quot;), alacData.mid(446, 4));
    // Set the bitrate to zero
    for (int offset = 470; offset &lt; 474; ++offset) {
      alacData[offset] = 0;
    }
    ByteVectorStream alacStream(alacData);
    MP4::File f(&amp;alacStream);
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(3, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(3705, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
    CPPUNIT_ASSERT_EQUAL(MP4::Properties::ALAC, f.audioProperties()-&gt;codec());
  }

  void testPropertiesM4V()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;blank_video.m4v&quot;));
    CPPUNIT_ASSERT(f.audioProperties());
    CPPUNIT_ASSERT_EQUAL(0, f.audioProperties()-&gt;lengthInSeconds());
    CPPUNIT_ASSERT_EQUAL(975, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(96, f.audioProperties()-&gt;bitrate());
    CPPUNIT_ASSERT_EQUAL(2, f.audioProperties()-&gt;channels());
<A NAME="1"></A>    CPPUNIT_ASSERT_EQUAL(44100, f.audioProperties()-&gt;sampleRate());
    CPPUNIT_ASSERT_EQUAL(16, f.audioProperties()-&gt;bitsPerSample());
    CPPUNIT_ASSERT_EQUAL(false, f.audioProperties()-&gt;isEncrypted());
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match910-0.html#1',2,'match910-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    CPPUNIT_ASSERT_EQUAL(MP4::Properties::AAC, f.audioProperties()-&gt;codec());
  }

  void testCheckValid()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;empty.aiff&quot;));
    CPPUNIT_ASSERT(!f.isValid());
  }

  void testHasTag()
  {
    {
      MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
    }

    ScopedFileCopy copy(&quot;no-tags&quot;, &quot;.m4a&quot;);

    {
      MP4::File f(copy.fileName().c_str());</B></FONT>
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      f.tag()-&gt;setTitle(&quot;TITLE&quot;);
      f.save();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
    }
  }

  void testIsEmpty()
  {
    MP4::Tag t1;
    CPPUNIT_ASSERT(t1.isEmpty());
    t1.setArtist(&quot;Foo&quot;);
    CPPUNIT_ASSERT(!t1.isEmpty());

    MP4::Tag t2;
    t2.setItem(&quot;foo&quot;, &quot;bar&quot;);
    CPPUNIT_ASSERT(!t2.isEmpty());
  }

  void testUpdateStco()
  {
    ScopedFileCopy copy(&quot;no-tags&quot;, &quot;.3g2&quot;);
    string filename = copy.fileName();

    ByteVectorList data1;

    {
      MP4::File f(filename.c_str());
      f.tag()-&gt;setArtist(ByteVector(3000, 'x'));

      MP4::Atoms a(&amp;f);
      MP4::Atom *stco = a.find(&quot;moov&quot;)-&gt;findall(&quot;stco&quot;, true)[0];
      f.seek(stco-&gt;offset + 12);
      ByteVector data = f.readBlock(stco-&gt;length - 12);
      unsigned int count = data.mid(0, 4).toUInt();
      int pos = 4;
      while (count--) {
        unsigned int offset = data.mid(pos, 4).toUInt();
        f.seek(offset);
        data1.append(f.readBlock(20));
        pos += 4;
      }

      f.save();
    }

    {
      MP4::File f(filename.c_str());

      MP4::Atoms a(&amp;f);
      MP4::Atom *stco = a.find(&quot;moov&quot;)-&gt;findall(&quot;stco&quot;, true)[0];
      f.seek(stco-&gt;offset + 12);
      ByteVector data = f.readBlock(stco-&gt;length - 12);
      unsigned int count = data.mid(0, 4).toUInt();
      int pos = 4, i = 0;
      while (count--) {
        unsigned int offset = data.mid(pos, 4).toUInt();
        f.seek(offset);
        CPPUNIT_ASSERT_EQUAL(data1[i], f.readBlock(20));
        pos += 4;
        i++;
      }
    }
  }

  void testFreeForm()
  {
    ScopedFileCopy copy(&quot;has-tags&quot;, &quot;.m4a&quot;);
    string filename = copy.fileName();

    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;----:com.apple.iTunes:iTunNORM&quot;));
      f.tag()-&gt;setItem(&quot;----:org.kde.TagLib:Foo&quot;, StringList(&quot;Bar&quot;));
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;----:org.kde.TagLib:Foo&quot;));
      CPPUNIT_ASSERT_EQUAL(String(&quot;Bar&quot;),
                           f.tag()-&gt;item(&quot;----:org.kde.TagLib:Foo&quot;).toStringList().front());
      f.save();
    }
  }

  void testSaveExisingWhenIlstIsLast()
  {
    ScopedFileCopy copy(&quot;ilst-is-last&quot;, &quot;.m4a&quot;);
    string filename = copy.fileName();

    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(String(&quot;82,164&quot;),
        f.tag()-&gt;item(&quot;----:com.apple.iTunes:replaygain_track_minmax&quot;).toStringList().front());
      CPPUNIT_ASSERT_EQUAL(String(&quot;Pearl Jam&quot;), f.tag()-&gt;artist());
      f.tag()-&gt;setComment(&quot;foo&quot;);
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(String(&quot;82,164&quot;),
                           f.tag()-&gt;item(&quot;----:com.apple.iTunes:replaygain_track_minmax&quot;).toStringList().front());
      CPPUNIT_ASSERT_EQUAL(String(&quot;Pearl Jam&quot;), f.tag()-&gt;artist());
      CPPUNIT_ASSERT_EQUAL(String(&quot;foo&quot;), f.tag()-&gt;comment());
    }
  }

  void test64BitAtom()
  {
    ScopedFileCopy copy(&quot;64bit&quot;, &quot;.mp4&quot;);
    string filename = copy.fileName();

    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;itemMap()[&quot;cpil&quot;].toBool());

      MP4::Atoms atoms(&amp;f);
      MP4::Atom *moov = atoms.atoms[0];
      CPPUNIT_ASSERT_EQUAL(long(77), moov-&gt;length);

      f.tag()-&gt;setItem(&quot;pgap&quot;, true);
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item(&quot;cpil&quot;).toBool());
      CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item(&quot;pgap&quot;).toBool());

      MP4::Atoms atoms(&amp;f);
      MP4::Atom *moov = atoms.atoms[0];
      // original size + 'pgap' size + padding
      CPPUNIT_ASSERT_EQUAL(long(77 + 25 + 974), moov-&gt;length);
    }
  }

  void testGnre()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;gnre.m4a&quot;));
    CPPUNIT_ASSERT_EQUAL(TagLib::String(&quot;Ska&quot;), f.tag()-&gt;genre());
  }

  void testCovrRead()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));
    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;covr&quot;));
    MP4::CoverArtList l = f.tag()-&gt;item(&quot;covr&quot;).toCoverArtList();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
  }

  void testCovrWrite()
  {
    ScopedFileCopy copy(&quot;has-tags&quot;, &quot;.m4a&quot;);
    string filename = copy.fileName();

    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;covr&quot;));
      MP4::CoverArtList l = f.tag()-&gt;item(&quot;covr&quot;).toCoverArtList();
      l.append(MP4::CoverArt(MP4::CoverArt::PNG, &quot;foo&quot;));
      f.tag()-&gt;setItem(&quot;covr&quot;, l);
      f.save();
    }
    {
      MP4::File f(filename.c_str());
      CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;covr&quot;));
      MP4::CoverArtList l = f.tag()-&gt;item(&quot;covr&quot;).toCoverArtList();
      CPPUNIT_ASSERT_EQUAL((unsigned int)3, l.size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[2].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)3, l[2].data().size());
    }
  }

  void testCovrRead2()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;covr-junk.m4a&quot;));
    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;covr&quot;));
    MP4::CoverArtList l = f.tag()-&gt;item(&quot;covr&quot;).toCoverArtList();
    CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
    CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
    CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());
  }

  void testProperties()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));

    PropertyMap tags = f.properties();

    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Test Artist&quot;), tags[&quot;ARTIST&quot;]);

    tags[&quot;TRACKNUMBER&quot;] = StringList(&quot;2/4&quot;);
    tags[&quot;DISCNUMBER&quot;] = StringList(&quot;3/5&quot;);
    tags[&quot;BPM&quot;] = StringList(&quot;123&quot;);
    tags[&quot;ARTIST&quot;] = StringList(&quot;Foo Bar&quot;);
    tags[&quot;COMPILATION&quot;] = StringList(&quot;1&quot;);
    f.setProperties(tags);

    tags = f.properties();

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;trkn&quot;));
    CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item(&quot;trkn&quot;).toIntPair().first);
    CPPUNIT_ASSERT_EQUAL(4, f.tag()-&gt;item(&quot;trkn&quot;).toIntPair().second);
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;2/4&quot;), tags[&quot;TRACKNUMBER&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;disk&quot;));
    CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item(&quot;disk&quot;).toIntPair().first);
    CPPUNIT_ASSERT_EQUAL(5, f.tag()-&gt;item(&quot;disk&quot;).toIntPair().second);
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;3/5&quot;), tags[&quot;DISCNUMBER&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;tmpo&quot;));
    CPPUNIT_ASSERT_EQUAL(123, f.tag()-&gt;item(&quot;tmpo&quot;).toInt());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;123&quot;), tags[&quot;BPM&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;\251ART&quot;));
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Foo Bar&quot;), f.tag()-&gt;item(&quot;\251ART&quot;).toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Foo Bar&quot;), tags[&quot;ARTIST&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;cpil&quot;));
    CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item(&quot;cpil&quot;).toBool());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;1&quot;), tags[&quot;COMPILATION&quot;]);

    tags[&quot;COMPILATION&quot;] = StringList(&quot;0&quot;);
    f.setProperties(tags);

    tags = f.properties();

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;cpil&quot;));
    CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item(&quot;cpil&quot;).toBool());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;0&quot;), tags[&quot;COMPILATION&quot;]);

    // Empty properties do not result in access violations
    // when converting integers
    tags[&quot;TRACKNUMBER&quot;] = StringList();
    tags[&quot;DISCNUMBER&quot;] = StringList();
    tags[&quot;BPM&quot;] = StringList();
    tags[&quot;COMPILATION&quot;] = StringList();
    f.setProperties(tags);
  }

  void testPropertiesAllSupported()
  {
    PropertyMap tags;
    tags[&quot;ALBUM&quot;] = StringList(&quot;Album&quot;);
    tags[&quot;ALBUMARTIST&quot;] = StringList(&quot;Album Artist&quot;);
    tags[&quot;ALBUMARTISTSORT&quot;] = StringList(&quot;Album Artist Sort&quot;);
    tags[&quot;ALBUMSORT&quot;] = StringList(&quot;Album Sort&quot;);
    tags[&quot;ARTIST&quot;] = StringList(&quot;Artist&quot;);
    tags[&quot;ARTISTS&quot;] = StringList(&quot;Artists&quot;);
    tags[&quot;ARTISTSORT&quot;] = StringList(&quot;Artist Sort&quot;);
    tags[&quot;ASIN&quot;] = StringList(&quot;ASIN&quot;);
    tags[&quot;BARCODE&quot;] = StringList(&quot;Barcode&quot;);
    tags[&quot;BPM&quot;] = StringList(&quot;123&quot;);
    tags[&quot;CATALOGNUMBER&quot;] = StringList(&quot;Catalog Number&quot;);
    tags[&quot;COMMENT&quot;] = StringList(&quot;Comment&quot;);
    tags[&quot;COMPILATION&quot;] = StringList(&quot;1&quot;);
    tags[&quot;COMPOSER&quot;] = StringList(&quot;Composer&quot;);
    tags[&quot;COMPOSERSORT&quot;] = StringList(&quot;Composer Sort&quot;);
    tags[&quot;CONDUCTOR&quot;] = StringList(&quot;Conductor&quot;);
    tags[&quot;COPYRIGHT&quot;] = StringList(&quot;2021 Copyright&quot;);
    tags[&quot;DATE&quot;] = StringList(&quot;2021-01-03 12:29:23&quot;);
    tags[&quot;DISCNUMBER&quot;] = StringList(&quot;3/5&quot;);
    tags[&quot;DISCSUBTITLE&quot;] = StringList(&quot;Disc Subtitle&quot;);
    tags[&quot;DJMIXER&quot;] = StringList(&quot;DJ Mixer&quot;);
    tags[&quot;ENCODEDBY&quot;] = StringList(&quot;Encoded by&quot;);
    tags[&quot;ENGINEER&quot;] = StringList(&quot;Engineer&quot;);
    tags[&quot;GAPLESSPLAYBACK&quot;] = StringList(&quot;1&quot;);
    tags[&quot;GENRE&quot;] = StringList(&quot;Genre&quot;);
    tags[&quot;GROUPING&quot;] = StringList(&quot;Grouping&quot;);
    tags[&quot;ISRC&quot;] = StringList(&quot;UKAAA0500001&quot;);
    tags[&quot;LABEL&quot;] = StringList(&quot;Label&quot;);
    tags[&quot;LANGUAGE&quot;] = StringList(&quot;eng&quot;);
    tags[&quot;LICENSE&quot;] = StringList(&quot;License&quot;);
    tags[&quot;LYRICIST&quot;] = StringList(&quot;Lyricist&quot;);
    tags[&quot;LYRICS&quot;] = StringList(&quot;Lyrics&quot;);
    tags[&quot;MEDIA&quot;] = StringList(&quot;Media&quot;);
    tags[&quot;MIXER&quot;] = StringList(&quot;Mixer&quot;);
    tags[&quot;MOOD&quot;] = StringList(&quot;Mood&quot;);
    tags[&quot;MOVEMENTCOUNT&quot;] = StringList(&quot;3&quot;);
    tags[&quot;MOVEMENTNAME&quot;] = StringList(&quot;Movement Name&quot;);
    tags[&quot;MOVEMENTNUMBER&quot;] = StringList(&quot;2&quot;);
    tags[&quot;MUSICBRAINZ_ALBUMARTISTID&quot;] = StringList(&quot;MusicBrainz_AlbumartistID&quot;);
    tags[&quot;MUSICBRAINZ_ALBUMID&quot;] = StringList(&quot;MusicBrainz_AlbumID&quot;);
    tags[&quot;MUSICBRAINZ_ARTISTID&quot;] = StringList(&quot;MusicBrainz_ArtistID&quot;);
    tags[&quot;MUSICBRAINZ_RELEASEGROUPID&quot;] = StringList(&quot;MusicBrainz_ReleasegroupID&quot;);
    tags[&quot;MUSICBRAINZ_RELEASETRACKID&quot;] = StringList(&quot;MusicBrainz_ReleasetrackID&quot;);
    tags[&quot;MUSICBRAINZ_TRACKID&quot;] = StringList(&quot;MusicBrainz_TrackID&quot;);
    tags[&quot;MUSICBRAINZ_WORKID&quot;] = StringList(&quot;MusicBrainz_WorkID&quot;);
    tags[&quot;ORIGINALDATE&quot;] = StringList(&quot;2021-01-03 13:52:19&quot;);
    tags[&quot;PODCAST&quot;] = StringList(&quot;1&quot;);
    tags[&quot;PODCASTCATEGORY&quot;] = StringList(&quot;Podcast Category&quot;);
    tags[&quot;PODCASTDESC&quot;] = StringList(&quot;Podcast Description&quot;);
    tags[&quot;PODCASTID&quot;] = StringList(&quot;Podcast ID&quot;);
    tags[&quot;PODCASTURL&quot;] = StringList(&quot;Podcast URL&quot;);
    tags[&quot;PRODUCER&quot;] = StringList(&quot;Producer&quot;);
    tags[&quot;RELEASECOUNTRY&quot;] = StringList(&quot;Release Country&quot;);
    tags[&quot;RELEASESTATUS&quot;] = StringList(&quot;Release Status&quot;);
    tags[&quot;RELEASETYPE&quot;] = StringList(&quot;Release Type&quot;);
    tags[&quot;REMIXER&quot;] = StringList(&quot;Remixer&quot;);
    tags[&quot;SCRIPT&quot;] = StringList(&quot;Script&quot;);
    tags[&quot;SHOWSORT&quot;] = StringList(&quot;Show Sort&quot;);
    tags[&quot;SHOWWORKMOVEMENT&quot;] = StringList(&quot;1&quot;);
    tags[&quot;SUBTITLE&quot;] = StringList(&quot;Subtitle&quot;);
    tags[&quot;TITLE&quot;] = StringList(&quot;Title&quot;);
    tags[&quot;TITLESORT&quot;] = StringList(&quot;Title Sort&quot;);
    tags[&quot;TRACKNUMBER&quot;] = StringList(&quot;2/4&quot;);
    tags[&quot;TVEPISODE&quot;] = StringList(&quot;3&quot;);
    tags[&quot;TVEPISODEID&quot;] = StringList(&quot;TV Episode ID&quot;);
    tags[&quot;TVNETWORK&quot;] = StringList(&quot;TV Network&quot;);
    tags[&quot;TVSEASON&quot;] = StringList(&quot;2&quot;);
    tags[&quot;TVSHOW&quot;] = StringList(&quot;TV Show&quot;);
    tags[&quot;WORK&quot;] = StringList(&quot;Work&quot;);

    ScopedFileCopy copy(&quot;no-tags&quot;, &quot;.m4a&quot;);
    {
      MP4::File f(copy.fileName().c_str());
      PropertyMap properties = f.properties();
      CPPUNIT_ASSERT(properties.isEmpty());
      f.setProperties(tags);
      f.save();
    }
    {
      const MP4::File f(copy.fileName().c_str());
      PropertyMap properties = f.properties();
      if (tags != properties) {
        CPPUNIT_ASSERT_EQUAL(tags.toString(), properties.toString());
      }
      CPPUNIT_ASSERT(tags == properties);
    }
  }

  void testPropertiesMovement()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));

    PropertyMap tags = f.properties();

    tags[&quot;WORK&quot;] = StringList(&quot;Foo&quot;);
    tags[&quot;MOVEMENTNAME&quot;] = StringList(&quot;Bar&quot;);
    tags[&quot;MOVEMENTNUMBER&quot;] = StringList(&quot;2&quot;);
    tags[&quot;MOVEMENTCOUNT&quot;] = StringList(&quot;3&quot;);
    tags[&quot;SHOWWORKMOVEMENT&quot;] = StringList(&quot;1&quot;);
    f.setProperties(tags);

    tags = f.properties();

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;\251wrk&quot;));
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Foo&quot;), f.tag()-&gt;item(&quot;\251wrk&quot;).toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Foo&quot;), tags[&quot;WORK&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;\251mvn&quot;));
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Bar&quot;), f.tag()-&gt;item(&quot;\251mvn&quot;).toStringList());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;Bar&quot;), tags[&quot;MOVEMENTNAME&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;\251mvi&quot;));
    CPPUNIT_ASSERT_EQUAL(2, f.tag()-&gt;item(&quot;\251mvi&quot;).toInt());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;2&quot;), tags[&quot;MOVEMENTNUMBER&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;\251mvc&quot;));
    CPPUNIT_ASSERT_EQUAL(3, f.tag()-&gt;item(&quot;\251mvc&quot;).toInt());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;3&quot;), tags[&quot;MOVEMENTCOUNT&quot;]);

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;shwm&quot;));
    CPPUNIT_ASSERT_EQUAL(true, f.tag()-&gt;item(&quot;shwm&quot;).toBool());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;1&quot;), tags[&quot;SHOWWORKMOVEMENT&quot;]);

    tags[&quot;SHOWWORKMOVEMENT&quot;] = StringList(&quot;0&quot;);
    f.setProperties(tags);

    tags = f.properties();

    CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;shwm&quot;));
    CPPUNIT_ASSERT_EQUAL(false, f.tag()-&gt;item(&quot;shwm&quot;).toBool());
    CPPUNIT_ASSERT_EQUAL(StringList(&quot;0&quot;), tags[&quot;SHOWWORKMOVEMENT&quot;]);

    tags[&quot;WORK&quot;] = StringList();
    tags[&quot;MOVEMENTNAME&quot;] = StringList();
    tags[&quot;MOVEMENTNUMBER&quot;] = StringList();
<A NAME="0"></A>    tags[&quot;MOVEMENTCOUNT&quot;] = StringList();
    tags[&quot;SHOWWORKMOVEMENT&quot;] = StringList();
    f.setProperties(tags);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match910-0.html#0',2,'match910-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  }

  void testFuzzedFile()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;infloop.m4a&quot;));
    CPPUNIT_ASSERT(f.isValid());
  }

  void testRepeatedSave()
  {
    ScopedFileCopy copy(&quot;no-tags&quot;, &quot;.m4a&quot;);

    MP4::File f(copy.fileName().c_str());
    f.tag()-&gt;setTitle(&quot;0123456789&quot;);
    f.save();
    f.save();
    CPPUNIT_ASSERT_EQUAL(2862L, f.find(&quot;0123456789&quot;));
    CPPUNIT_ASSERT_EQUAL(-1L, f.find(&quot;0123456789&quot;, 2863));
  }

  void testWithZeroLengthAtom()
  {
    MP4::File f(TEST_FILE_PATH_C(&quot;zero-length-mdat.m4a&quot;));
    CPPUNIT_ASSERT(f.isValid());
    CPPUNIT_ASSERT_EQUAL(1115, f.audioProperties()-&gt;lengthInMilliseconds());
    CPPUNIT_ASSERT_EQUAL(22050, f.audioProperties()-&gt;sampleRate());
  }

  void testEmptyValuesRemoveItems()
  {</B></FONT>
    const MP4::File f(TEST_FILE_PATH_C(&quot;has-tags.m4a&quot;));
    MP4::Tag *tag = f.tag();
    const String testTitle(&quot;Title&quot;);
    const String testArtist(&quot;Artist&quot;);
    const String testAlbum(&quot;Album&quot;);
    const String testComment(&quot;Comment&quot;);
    const String testGenre(&quot;Genre&quot;);
    const String nullString;
    const unsigned int testYear = 2020;
    const unsigned int testTrack = 1;
    const unsigned int zeroUInt = 0;

    tag-&gt;setTitle(testTitle);
    CPPUNIT_ASSERT_EQUAL(testTitle, tag-&gt;title());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251nam&quot;));
    tag-&gt;setArtist(testArtist);
    CPPUNIT_ASSERT_EQUAL(testArtist, tag-&gt;artist());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251ART&quot;));
    tag-&gt;setAlbum(testAlbum);
    CPPUNIT_ASSERT_EQUAL(testAlbum, tag-&gt;album());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251alb&quot;));
    tag-&gt;setComment(testComment);
    CPPUNIT_ASSERT_EQUAL(testComment, tag-&gt;comment());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251cmt&quot;));
    tag-&gt;setGenre(testGenre);
    CPPUNIT_ASSERT_EQUAL(testGenre, tag-&gt;genre());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251gen&quot;));
    tag-&gt;setYear(testYear);
    CPPUNIT_ASSERT_EQUAL(testYear, tag-&gt;year());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;\251day&quot;));
    tag-&gt;setTrack(testTrack);
    CPPUNIT_ASSERT_EQUAL(testTrack, tag-&gt;track());
    CPPUNIT_ASSERT(tag-&gt;contains(&quot;trkn&quot;));

    tag-&gt;setTitle(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;title());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251nam&quot;));
    tag-&gt;setArtist(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;artist());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251ART&quot;));
    tag-&gt;setAlbum(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;album());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251alb&quot;));
    tag-&gt;setComment(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;comment());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251cmt&quot;));
    tag-&gt;setGenre(nullString);
    CPPUNIT_ASSERT_EQUAL(nullString, tag-&gt;genre());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251gen&quot;));
    tag-&gt;setYear(zeroUInt);
    CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;year());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;\251day&quot;));
    tag-&gt;setTrack(zeroUInt);
    CPPUNIT_ASSERT_EQUAL(zeroUInt, tag-&gt;track());
    CPPUNIT_ASSERT(!tag-&gt;contains(&quot;trkn&quot;));
  }

  void testRemoveMetadata()
  {
    ScopedFileCopy copy(&quot;no-tags&quot;, &quot;.m4a&quot;);

    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      MP4::Tag *tag = f.tag();
      CPPUNIT_ASSERT(tag-&gt;isEmpty());
      tag-&gt;setTitle(&quot;TITLE&quot;);
      f.save();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());
      CPPUNIT_ASSERT(!f.tag()-&gt;isEmpty());
      f.strip();
    }
    {
      MP4::File f(copy.fileName().c_str());
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(!f.hasMP4Tag());
      CPPUNIT_ASSERT(f.tag()-&gt;isEmpty());
      CPPUNIT_ASSERT(fileEqual(
        copy.fileName(),
        TEST_FILE_PATH_C(&quot;no-tags.m4a&quot;)));
    }
  }

  void testNonFullMetaAtom()
  {
    {
      MP4::File f(TEST_FILE_PATH_C(&quot;non-full-meta.m4a&quot;));
      CPPUNIT_ASSERT(f.isValid());
      CPPUNIT_ASSERT(f.hasMP4Tag());

      CPPUNIT_ASSERT(f.tag()-&gt;contains(&quot;covr&quot;));
      MP4::CoverArtList l = f.tag()-&gt;item(&quot;covr&quot;).toCoverArtList();
      CPPUNIT_ASSERT_EQUAL((unsigned int)2, l.size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::PNG, l[0].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)79, l[0].data().size());
      CPPUNIT_ASSERT_EQUAL(MP4::CoverArt::JPEG, l[1].format());
      CPPUNIT_ASSERT_EQUAL((unsigned int)287, l[1].data().size());

      PropertyMap properties = f.properties();
      CPPUNIT_ASSERT_EQUAL(StringList(&quot;Test Artist!!!!&quot;), properties[&quot;ARTIST&quot;]);
      CPPUNIT_ASSERT_EQUAL(StringList(&quot;FAAC 1.24&quot;), properties[&quot;ENCODEDBY&quot;]);
    }
  }
};

CPPUNIT_TEST_SUITE_REGISTRATION(TestMP4);
</PRE>
</div>
  </div>
</body>
</html>
