
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.cpp</h3>
            <pre><code>1  namespace {
2  class TVectorBuilder2
3  {
4  public:
5  	TIntV v;
6  	TVectorBuilder2(int i) { v.Add(i); }
7  	operator TIntV() const { return v; }
8  	TVectorBuilder2& operator ,(int i) { v.Add(i); return *this; }
9  };
10  class TVectorBuilder
11  {
12  public:
13  	operator TIntV() const { return TIntV(); }
14  	TVectorBuilder2 operator ,(int i) { return TVectorBuilder2(i); }
15  };
16  TVectorBuilder VB;
17  TStr CombinePath(const TStr& s, const TStr& t)
18  {
19  	int n = s.Len(); if (n <= 0) return t;
20  	if (s[n - 1] == '\\' || s[n - 1] == '/' || s[n - 1] == ':') return s + t;
21  	return s + "\\" + t;
22  }
23  void AssertEq(const TIntV& v1, const TIntV& v2, const TStr& explanation, FILE *f)
24  {
25  	const int n = v1.Len();
26  	bool ok = (n == v2.Len());
27  	if (ok) for (int i = 0; i < n && ok; i++) ok = ok && (v1[i] == v2[i]);
28  	if (! ok)
29  	{
30  		if (! f) f = stderr;
31  		fprintf(f, "%s: [", explanation.CStr());
32  		for (int i = 0; i < v1.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(v1[i]));
33  		fprintf(f, "] != [");
34  		for (int i = 0; i < v2.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(v2[i]));
35  		fprintf(f, "]\n");
36  		Fail;
37  	}
38  }
39  };
40  uint TUniCodec::GetRndUint(TRnd& rnd)
41  {
42  	uint u = rnd.GetUniDevUInt(256) & 0xff;
43  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
44  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
45  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
46  	return u;
47  }
48  uint TUniCodec::GetRndUint(TRnd& rnd, uint minVal, uint maxVal)
49  {
50  	if (minVal == TUInt::Mn && maxVal == TUInt::Mx) return GetRndUint(rnd);
51  	uint range = maxVal - minVal + 1;
52  	if (range > (uint(1) << (8 * sizeof(uint) - 1)))
53  		while (true) { uint u = GetRndUint(rnd); if (u < range) return minVal + u; }
54  	uint mask = 1;
55  	while (mask < range) mask <<= 1;
56  	mask -= 1;
57  	while (true) { uint u = GetRndUint(rnd) & mask; if (u < range) return minVal + u; }
58  }
59  bool TUniCodec::IsMachineLittleEndian()
60  {
61  	static bool isLE, initialized = false;
62  	if (initialized) return isLE;
63  	int i = 1;
64  	if(*(char *)&i == 1) isLE = true;
65  	else isLE = false;
66  	initialized = true;
67  	return isLE;
68  }
69  void TUniCodec::TestUtf8(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest, FILE *f)
70  {
71  	TIntV dest;
72  	if (f) {
73  		fprintf(f, "Settings: %s  %s  %s   replacementChar = %x\n",
74  			(errorHandling == uehAbort ? "abort" : errorHandling == uehThrow ? "throw" : errorHandling == uehIgnore ? "ignore" : errorHandling == uehReplace ? "replace" : "????"),
75  			(strict ? "STRICT" : ""), (skipBom ? "skipBom" : ""), uint(replacementChar));
76  		fprintf(f, "src: "); for (int i = 0; i < src.Len(); i++) fprintf(f, (decode ? " %02x" : " %x"), uint(src[i])); }
77  	try
78  	{
79  		size_t retVal = (decode ? DecodeUtf8(src, 0, src.Len(), dest, true) : EncodeUtf8(src, 0, src.Len(), dest, true));
80  		if (f) {
81  			fprintf(f, "\n -> dest:    "); for (int i = 0; i < dest.Len(); i++) fprintf(f, (decode ? " %x" :  " %02x"), uint(dest[i]));
82  			fprintf(f, "\n    expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, (decode ? " %x" :  " %02x"), uint(expectedDest[i]));
83  			fprintf(f, "\n    retVal = %llu (expected %llu)\n", static_cast<long long unsigned int> (retVal), static_cast<long long unsigned int> (expectedRetVal)); }
84  		if (retVal != expectedRetVal)
85  			printf("!!!");
86  		IAssert(retVal == expectedRetVal); IAssert(! expectedThrow);
87  		if (dest.Len() != expectedDest.Len())
88  			printf("!!!");
89  		IAssert(dest.Len() == expectedDest.Len());
90  		for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == expectedDest[i]);
91  	}
92  	catch (TUnicodeException e)
93  	{
94  		if (f) {
95  			fprintf(f, "\n -> expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, " %x", uint(expectedDest[i]));
96  			fprintf(f, "\n    exception \"%s\" at %d (char 0x%02x)\n", e.message.CStr(), int(e.srcIdx), uint(e.srcChar)); }
97  		IAssert(expectedThrow);
98  	}
99  }
100  void TUniCodec::TestDecodeUtf8(TRnd& rnd, const TStr& testCaseDesc)
101  {
102  	TIntV src; TIntV expectedDest; int expectedRetVal = 0;
103  	bool expectedAbort = false;
104  	FILE *f = 0; 
105  	for (int i = 0; i < testCaseDesc.Len(); )
106  	{
107  		IAssert(i + 2 <= testCaseDesc.Len());
108  		const char c = testCaseDesc[i], d = testCaseDesc[i + 1]; i += 2;
109  		uint cp = 0; int nBytes = -1, minBytes = -1; bool eighties = false;
110  		IAssert('1' <= d && d <= '6'); nBytes = d - '0';
111  		if (c == 'A') { cp = GetRndUint(rnd, 0u, 0x7fu); minBytes = 1; } 
112  		else if (c == 'B') { cp = GetRndUint(rnd, 0x80u, 0x7ffu); minBytes = 2; } 
113  		else if (c == 'C') { cp = GetRndUint(rnd, 0x800u, 0xffffu); minBytes = 3; } 
114  		else if (c == 'D') { cp = GetRndUint(rnd, 0x10000u, 0x10ffffu); minBytes = 4; } 
115  		else if (c == 'E') { cp = GetRndUint(rnd, 0x110000u, 0x1fffffu); minBytes = 4; } 
116  		else if (c == 'F') { cp = GetRndUint(rnd, 0x200000u, 0x3ffffffu); minBytes = 5; } 
117  		else if (c == 'G') { cp = GetRndUint(rnd, 0x4000000u, 0x7fffffffu); minBytes = 6; } 
118  		else if (c == 'H') { cp = GetRndUint(rnd, 0x80000000u, 0xffffffffu); minBytes = 6; } 
119  		else if (c == 'X') { cp = 0xfffe; minBytes = 3; }
120  		else if (c == 'Y') { cp = 0xfeff; minBytes = 3; }
121  		else if (c == 'Z') { eighties = true; minBytes = 1; } 
122  		else Fail;
123  		IAssert(nBytes >= minBytes);
124  		int nToDel = 0;
125  		if (i < testCaseDesc.Len()) {
126  			const char e = testCaseDesc[i];
127  			if (e >= 'a' && e <= 'e') { i += 1; nToDel = e - 'a' + 1; }}
128  		IAssert(nToDel < nBytes);
129  		bool errHere = false;
130  		if (eighties) errHere = true;
131  		else if (nToDel > 0) errHere = true;
132  		else if (strict && (cp >= 0x10ffff || nBytes > minBytes)) errHere = true;
133  		if (! expectedAbort) {
134  			if (! errHere) {
135  				if (src.Len() == 0 && (cp == 0xfffe || cp == 0xfeff) && skipBom) { }
136  				else { expectedDest.Add(cp); expectedRetVal += 1; } }
137  			else if (errorHandling == uehReplace) {
138  				if (eighties) for (int j = 0; j < nBytes; j++) expectedDest.Add(replacementChar);
139  				else expectedDest.Add(replacementChar); }
140  			if (errHere && (errorHandling == uehAbort || errorHandling == uehThrow)) expectedAbort = true; }
141  		if (eighties) for (int j = 0; j < nBytes; j++) src.Add(GetRndUint(rnd, 0x80, 0xff));
142  		else if (nBytes == 1) src.Add(cp);
143  		else {
144  			int mask = (1 << nBytes) - 1; mask <<= (8 - nBytes);
145  			src.Add(mask | (uint(cp) >> (6 * (nBytes - 1))));
146  			for (int j = 1; j < nBytes - nToDel; j++) src.Add(0x80 | ((cp >> (6 * (nBytes - j - 1))) & _0011_1111)); }
147  	}
148  	if (f) fprintf(f, "Test case: \"%s\"\n", testCaseDesc.CStr());
149  	TestUtf8(true, expectedRetVal, expectedAbort && (errorHandling == uehThrow), src, expectedDest, f);
150  }
151  void TUniCodec::TestUtf8()
152  {
153  	TIntV utf8ReplCh; EncodeUtf8((TVectorBuilder(), replacementChar).v, 0, 1, utf8ReplCh, true);
154  	for (int skipBom_ = 0; skipBom_ < 2; skipBom_++)
155  	for (int strict_ = 0; strict_ < 2; strict_++)
156  	for (int errMode_ = 0; errMode_ < 4; errMode_++)
157  	{
158  		strict = (strict_ == 1); errorHandling = TUnicodeErrorHandling(errMode_); skipBom = (skipBom_ == 1);
159  		TRnd rnd = TRnd(123);
160  		for (int i = 0; i < 10; i++)
161  		{
162  			TestDecodeUtf8(rnd, "X3A1A2A3A4A5A6B2B3B4B5B6C3C4C5C6D4D5D6E5E6F6G6");
163  			TestDecodeUtf8(rnd, "X3A5dA6d");
164  			TestDecodeUtf8(rnd, "X3A1B2C3D4E4F5A1G6H6Y3X3A1");
165  			TestDecodeUtf8(rnd, "X3A1B2C3D4E4F5A2G6H6Y3X3A1");
166  			TestDecodeUtf8(rnd, "Y3A1B2C3D4E4F5A1G6H6Y3X3A1");
167  			TestDecodeUtf8(rnd, "A1B2C3D4E4F5A1G6H6Y3X3A1");
168  			TestDecodeUtf8(rnd, "G6A1A1D4E4A1B2");
169  			TestDecodeUtf8(rnd, "D4A1A1C3A1B2A1B2");
170  			TestDecodeUtf8(rnd, "D4A1A1C3A1B2A1B2D4a");
171  			TestDecodeUtf8(rnd, "X3A1B2C3D5E4F5A1G6H6Y3X3A1");
172  			TestDecodeUtf8(rnd, "X3A1B2C3D4E5F5A1G6H6Y3X3A1");
173  			TestDecodeUtf8(rnd, "X3A1B2C3D4aE4F5A1G6H6Y3X3A1");
174  			TestDecodeUtf8(rnd, "X3A1B2C3D4bE4F5A1G6H6Y3X3A1");
175  			TestDecodeUtf8(rnd, "X3A2aA3aA4aA5aA6aB2aB3aB4aB5aB6aC3aC4aC5aC6aD4aD5aD6aE5aE6aF6aG6a");
176  			TestDecodeUtf8(rnd, "X3A3bA4bA5bA6aB3bB4bB5bB6bC3bC4bC5bC6bD4bD5bD6bE5bE6bF6bG6b");
177  			TestDecodeUtf8(rnd, "X3A4cA5cA6cB4cB5cB6cC4cC5cC6cD4cD5cD6cE5cE6cF6cG6c");
178  			TestDecodeUtf8(rnd, "X3A5dA6dB5dB6dC5dC6dD5dD6dE5dE6dF6dG6d");
179  			TestDecodeUtf8(rnd, "X3A6eB6eC6eD6eE6eF6eG6e");
180  		}
181  		TIntV src, expectedDest, src2;
182  		expectedDest.Gen(1); src.Reserve(6); src2.Gen(1);
183  		for (int pow = 8; pow <= 32; pow++)
184  		{
185  			uint uFrom, uTo;
186  			if (pow == 8) uFrom = 0, uTo = 1u << pow;
187  			else if (pow == 32) uFrom = TUInt::Mx - (1u << 8), uTo = TUInt::Mx;
188  			else uFrom = (1u << pow) - (1u << 8), uTo = (1u << pow) + (1u << 8);
189  			printf("%u..%u          \r", uFrom, uTo);
190  			for (uint u = uFrom; ; u++)
191  			{
192  				int nBytes = 0;
193  				if (u < (1u << 7)) nBytes = 1;
194  				else if (u < (1u << 11)) nBytes = 2;
195  				else if (u < (1u << 16)) nBytes = 3;
196  				else if (u < (1u << 21)) nBytes = 4;
197  				else if (u < (1u << 26)) nBytes = 5;
198  				else nBytes = 6;
199  				src.Gen(6, nBytes);
200  				if (nBytes == 1) src[0] = u;
201  				else {
202  					src[0] = (((1 << nBytes) - 1) << (8 - nBytes)) | (u >> (6 * (nBytes - 1)));
203  					for (int i = 1; i < nBytes; i++) src[i] = 0x80 | ((u >> (6 * (nBytes - i - 1))) & _0011_1111); }
204  				bool err = (strict && u > 0x10ffff);
205  				expectedDest.Reserve(1, 0);
206  				if (err && errorHandling == uehReplace) expectedDest.Add(replacementChar);
207  				else if (! err) expectedDest.Add(u);
208  				int erv = (err ? 0 : 1);
209  				if (skipBom && (u == 0xfeff || u == 0xfffe)) expectedDest.Clr(), erv = 0;
210  				TestUtf8(true, erv, (err && errorHandling == uehThrow), src, expectedDest, 0);
211  				src2[0] = u;
212  				if (err) {
213  					if (errorHandling == uehReplace) src = utf8ReplCh;
214  					else src.Clr(false); }
215  				TestUtf8(false, (err ? 0 : 1), (err && errorHandling == uehThrow), src2, src, 0);
216  				if (u == uTo) break;
217  			}
218  		}
219  	}
220  }
221  void TUniCodec::WordsToBytes(const TIntV& src, TIntV& dest)
222  {
223  	dest.Clr();
224  	bool isLE = IsMachineLittleEndian();
225  	for (int i = 0; i < src.Len(); i++) {
226  		int c = src[i] & 0xffff;
227  		if (isLE) { dest.Add(c & 0xff); dest.Add((c >> 8) & 0xff); }
228  		else { dest.Add((c >> 8) & 0xff); dest.Add(c & 0xff); } }
229  }
230  void TUniCodec::TestUtf16(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest,
231  	const TUtf16BomHandling bomHandling, const TUniByteOrder defaultByteOrder, const bool insertBom,
232  	FILE *f)
233  {
234  	TIntV srcBytes, expectedDestBytes;
235  	WordsToBytes(src, srcBytes); WordsToBytes(expectedDest, expectedDestBytes);
236  	TIntV dest;
237  	if (f) {
238  		fprintf(f, "Settings: %s  %s  %s  %s  %s replacementChar = %x  \n",
239  			(errorHandling == uehAbort ? "abort" : errorHandling == uehThrow ? "throw" : errorHandling == uehIgnore ? "ignore" : errorHandling == uehReplace ? "replace" : "????"),
240  			(strict ? "STRICT" : ""), (decode ? (skipBom ? "skipBom" : "") : (insertBom ? "insrtBom" : "")),
241  			(bomHandling == bomAllowed ? "bomAllowed" : bomHandling == bomRequired ? "bomRequired" : "bomIgnored"),
242  			(defaultByteOrder == boBigEndian ? "boBigEndian" : defaultByteOrder == boLittleEndian ? "boLittleEndian" : "boMachineEndian"),
243  			uint(replacementChar));
244  		fprintf(f, "src: "); for (int i = 0; i < src.Len(); i++) fprintf(f, (decode ? " %04x" : " %x"), uint(src[i])); }
245  	for (int useBytes = 0; useBytes < 2; useBytes++)
246  	{
247  		const char *fmt = (useBytes ? " %02x" : " %04x");
248  		try
249  		{
250  			dest.Clr();
251  			size_t retVal;
252  			if (! useBytes) {
253  				if (decode) retVal = DecodeUtf16FromWords(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder);
254  				else retVal = EncodeUtf16ToWords(src, 0, src.Len(), dest, true, insertBom, defaultByteOrder); }
255  			else {
256  				if (decode) retVal = DecodeUtf16FromBytes(srcBytes, 0, srcBytes.Len(), dest, true, bomHandling, defaultByteOrder);
257  				else retVal = EncodeUtf16ToBytes(src, 0, src.Len(), dest, true, insertBom, defaultByteOrder); }
258  			const TIntV& ed = (useBytes && ! decode ? expectedDestBytes : expectedDest);
259  			if (f) {
260  				fprintf(f, "\n -> dest:    "); for (int i = 0; i < dest.Len(); i++) fprintf(f, (decode ? " %x" :  fmt), uint(dest[i]));
261  				fprintf(f, "\n    expDest  "); for (int i = 0; i < ed.Len(); i++) fprintf(f, (decode ? " %x" :  fmt), uint(ed[i]));
262  				fprintf(f, "\n    retVal = %llu (expected %llu)\n", static_cast<long long unsigned int> (retVal), static_cast<long long unsigned int> (expectedRetVal)); }
263  			bool ok = true;
264  			if (retVal != expectedRetVal) ok = false;
265  			if (dest.Len() != ed.Len()) ok = false;
266  			if (ok) for (int i = 0; i < dest.Len(); i++) if (dest[i] != ed[i]) ok = false;
267  			if (! ok)
268  			{
269  				printf("!!!\n");
270  			}
271  			IAssert(retVal == expectedRetVal); IAssert(! expectedThrow);
272  			IAssert(dest.Len() == ed.Len());
273  			for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == ed[i]);
274  		}
275  		catch (TUnicodeException e)
276  		{
277  			if (f) {
278  				fprintf(f, "\n -> expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, (decode ? " %x" : fmt), uint(expectedDest[i]));
279  				fprintf(f, "\n    exception \"%s\" at %d (char 0x%02x)\n", e.message.CStr(), int(e.srcIdx), uint(e.srcChar)); }
280  			IAssert(expectedThrow);
281  		}
282  	}
283  }
284  void TUniCodec::TestDecodeUtf16(TRnd& rnd, const TStr& testCaseDesc,
285  	const TUtf16BomHandling bomHandling,
286  	const TUniByteOrder defaultByteOrder,
287  	const bool insertBom)
288  {
289  	TIntV src; TIntV expectedDest; int expectedRetVal = 0;
290  	bool expectedAbort = false;
291  	FILE *f = 0;
292  	bool isMachineLe = IsMachineLittleEndian();
293  	bool isDefaultLe = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && isMachineLe));
294  	bool swap = (isMachineLe != isDefaultLe);
295  	if (insertBom) {
296  		src.Add(swap ? 0xfffe : 0xfeff);
297  		if (! skipBom) { expectedRetVal += 1; expectedDest.Add(0xfeff); } }
298  	else if (bomHandling == bomRequired) {
299  		expectedAbort = true; expectedRetVal = -1; }
300  	for (int i = 0; i < testCaseDesc.Len(); )
301  	{
302  		const char c = testCaseDesc[i++];
303  		uint cp = 0; int nWords = -1;
304  		if (c == 'X' || c == 'Y') IAssert(i > 1); 
305  		if (c == 'A') { cp = GetRndUint(rnd, 0u, Utf16FirstSurrogate - 1); nWords = 1; } 
306  		else if (c == 'B') { cp = GetRndUint(rnd, Utf16FirstSurrogate, Utf16FirstSurrogate + 1023); nWords = 1; } 
307  		else if (c == 'C') { cp = GetRndUint(rnd, Utf16SecondSurrogate, Utf16SecondSurrogate + 1023); nWords = 1; } 
308  		else if (c == 'D') { do { cp = GetRndUint(rnd, Utf16SecondSurrogate + 1024, 0xffffu); } while (cp == 0xfffe || cp == 0xfeff); nWords = 1; } 
309  		else if (c == 'E') { cp = GetRndUint(rnd, 0x10000u, 0x10ffffu); nWords = 2; } 
310  		else if (c == 'X') { cp = 0xfffe; nWords = 1; }
311  		else if (c == 'Y') { cp = 0xfeff; nWords = 1; }
312  		else Fail;
313  		if (c == 'B' && i < testCaseDesc.Len()) IAssert(testCaseDesc[i] != 'C');
314  		int nToDel = 0;
315  		if (i < testCaseDesc.Len()) {
316  			const char e = testCaseDesc[i];
317  			if (e >= 'a') { i += 1; nToDel = 1; }}
318  		IAssert((nWords == 1 && nToDel == 0) || (nWords == 2 && (nToDel == 0 || nToDel == 1)));
319  		if (nWords == 2 && nToDel == 1 && i < testCaseDesc.Len()) IAssert(testCaseDesc[i] != 'C');
320  		bool errHere = false;
321  		if (Utf16FirstSurrogate <= cp && cp <= Utf16FirstSurrogate + 1023) errHere = true;
322  		else if (cp > 0x10ffff) { Fail; errHere = true; }
323  		else if (nToDel > 0) errHere = true;
324  		else if (strict && (Utf16SecondSurrogate <= cp && cp <= Utf16SecondSurrogate + 1023)) errHere = true;
325  		if (! expectedAbort) {
326  			if (! errHere) {
327  				if (src.Len() == 0 && (cp == 0xfffe || cp == 0xfeff) && skipBom) { }
328  				else { expectedDest.Add(cp); expectedRetVal += 1; } }
329  			else if (errorHandling == uehReplace) {
330  				expectedDest.Add(replacementChar); }
331  			if (errHere && (errorHandling == uehAbort || errorHandling == uehThrow)) expectedAbort = true; }
332  		if (nWords == 1) src.Add(swap ? SwapBytes(cp) : cp);
333  		else {
334  			int c1 = ((cp - 0x10000) >> 10) & 1023; c1 += Utf16FirstSurrogate;
335  			int c2 = (cp - 0x10000) & 1023; c2 += Utf16SecondSurrogate;
336  			src.Add(swap ? SwapBytes(c1) : c1);
337  			if (nToDel == 0) src.Add(swap ? SwapBytes(c2) : c2); }
338  	}
339  	if (f) fprintf(f, "Test case: \"%s\"\n", testCaseDesc.CStr());
340  	TestUtf16(true, expectedRetVal, expectedAbort && (errorHandling == uehThrow), src, expectedDest, bomHandling, defaultByteOrder, false, f);
341  }
342  void TUniCodec::TestUtf16()
343  {
344  	TIntV utf16ReplCh; utf16ReplCh.Add(replacementChar);
345  	for (int skipBom_ = 0; skipBom_ < 2; skipBom_++)
346  	for (int strict_ = 0; strict_ < 2; strict_++)
347  	for (int errMode_ = 0; errMode_ < 4; errMode_++)
348  	for (int bomHandling_ = 0; bomHandling_ < 3; bomHandling_++)
349  	for (int byteOrder_ = 0; byteOrder_ < 3; byteOrder_++)
350  	for (int insertBom_ = 0; insertBom_ < 2; insertBom_++)
351  	{
352  		strict = (strict_ == 1); errorHandling = TUnicodeErrorHandling(errMode_); skipBom = (skipBom_ == 1);
353  		bool insertBom = (insertBom_ == 1);
354  		TUniByteOrder byteOrder = (TUniByteOrder) byteOrder_;
355  		TUtf16BomHandling bomHandling = (TUtf16BomHandling) bomHandling_;
356  		TRnd rnd = TRnd(123);
357  		for (int i = 0; i < 10; i++)
358  		{
359  			TestDecodeUtf16(rnd, "A", bomHandling, byteOrder, insertBom);
360  			TestDecodeUtf16(rnd, "AAA", bomHandling, byteOrder, insertBom);
361  			TestDecodeUtf16(rnd, "B", bomHandling, byteOrder, insertBom);
362  			TestDecodeUtf16(rnd, "DDAADADAAADDDAA", bomHandling, byteOrder, insertBom);
363  			TestDecodeUtf16(rnd, "DEEEDAAEEDADEEAAEEADEEDDAA", bomHandling, byteOrder, insertBom);
364  			TestDecodeUtf16(rnd, "DEaEaEDAAEaEDADEaEAAEEADEEDDAA", bomHandling, byteOrder, insertBom);
365  			TestDecodeUtf16(rnd, "CABDEBACCEaB", bomHandling, byteOrder, insertBom);
366  			TestDecodeUtf16(rnd, "EaEEEEaBBACABXABYXXEaYDDXBDCEA", bomHandling, byteOrder, insertBom);
367  			TestDecodeUtf16(rnd, "EaEEEEaBDCAAXADYXXEaYDDXDCEA", bomHandling, byteOrder, insertBom);
368  		}
369  		TIntV src, expectedDest, src2;
370  		expectedDest.Gen(1); src.Reserve(6); src2.Gen(1);
371  		for (int pow = 8; pow <= 32; pow++)
372  		{
373  			uint uFrom, uTo;
374  			if (pow == 8) uFrom = 0, uTo = 1u << pow;
375  			else if (pow == 32) uFrom = TUInt::Mx - (1u << 8), uTo = TUInt::Mx;
376  			else uFrom = (1u << pow) - (1u << 8), uTo = (1u << pow) + (1u << 8);
377  			printf("%u..%u          \r", uFrom, uTo);
378  			for (uint u = uFrom; ; u++)
379  			{
380  				int nWords = 0;
381  				if (u < 0x10000) nWords = 1;
382  				else nWords = 2;
383  				bool isMachineLe = IsMachineLittleEndian(), isDestLe = (byteOrder == boLittleEndian || (byteOrder == boMachineEndian && isMachineLe));
384  				bool swap = (isMachineLe != isDestLe);
385  				bool err = (u > 0x10ffff) || (Utf16FirstSurrogate <= u && u <= Utf16FirstSurrogate + 1023) || (strict && Utf16SecondSurrogate <= u && u <= Utf16SecondSurrogate + 1023);
386  				src.Gen(3, (err ? 0 : nWords) + (insertBom ? 1 : 0));
387  				if (insertBom) src[0] = (swap ? 0xfffe : 0xfeff);
388  				if (! ((u > 0x10ffff) || (Utf16FirstSurrogate <= u && u <= Utf16FirstSurrogate + 1023)))
389  				{
390  					if (nWords == 1) src[insertBom ? 1 : 0] = (swap ? SwapBytes(u) : u);
391  					else {
392  						int u1 = Utf16FirstSurrogate + (((u - 0x10000) >> 10) & 1023);
393  						int u2 = Utf16SecondSurrogate + ((u - 0x10000) & 1023);
394  						src[insertBom ? 1 : 0] = (swap ? SwapBytes(u1) : u1);
395  						src[insertBom ? 2 : 1] = (swap ? SwapBytes(u2) : u2); }
396  					if (! ((u == 0xfffe || u == 0xfeff) && bomHandling == bomAllowed && ! insertBom)) 
397  					{
398  						expectedDest.Reserve(2, 0);
399  						if (insertBom && ! skipBom) expectedDest.Add(0xfeff);
400  						if (err && errorHandling == uehReplace) expectedDest.Add(replacementChar);
401  						else if (! err) expectedDest.Add(u);
402  						int erv = (err ? 0 : expectedDest.Len());
403  						if (skipBom && (u == 0xfeff || u == 0xfffe) && ! insertBom) expectedDest.Clr(), erv = 0;
404  						bool errD = err;
405  						if (bomHandling == bomRequired && ! insertBom) {
406  							expectedDest.Clr(false);
407  							if (u == 0xfeff || u == 0xfffe) { erv = (skipBom ? 0 : 1); if (! skipBom) expectedDest.Add(0xfeff); }
408  							else { erv = -1; errD = true;
409  								 }}
410  						TestUtf16(true, erv, (errD && errorHandling == uehThrow), src, expectedDest, bomHandling, byteOrder, insertBom, 0);
411  					}
412  				}
413  				src2[0] = u;
414  				if (err) {
415  					src.Clr(false); if (insertBom) src.Add(swap ? 0xfffe : 0xfeff);
416  					if (errorHandling == uehReplace) {
417  						src.Add(swap ? SwapBytes(replacementChar) : replacementChar);
418  					}}
419  				TestUtf16(false, (err ? 0 : 1) + (insertBom ? 1 : 0), (err && errorHandling == uehThrow), src2, src, bomHandling, byteOrder, insertBom, 0);
420  				if (u == uTo) break;
421  			}
422  		}
423  	}
424  }
425  void TUniCaseFolding::LoadTxt(const TStr& fileName)
426  {
427  	Clr();
428  	TUniChDb::TUcdFileReader reader; reader.Open(fileName);
429  	TStrV fields;
430  	while (reader.GetNextLine(fields))
431  	{
432  		int cp = reader.ParseCodePoint(fields[0]);
433  		const TStr status = fields[1], mapsTo = fields[2];
434  		if (status == "C" || status == "S" || status == "T") {
435  			TIntH &dest = (status == "C" ? cfCommon : status == "S" ? cfSimple : cfTurkic);
436  			IAssert(! dest.IsKey(cp));
437  			int cp2 = reader.ParseCodePoint(mapsTo);
438  			dest.AddDat(cp, cp2); }
439  		else if (status == "F") {
440  			TIntIntVH &dest = cfFull;
441  			IAssert(! dest.IsKey(cp));
442  			TIntV cps; reader.ParseCodePointList(mapsTo, cps); IAssert(cps.Len() > 0);
443  			dest.AddDat(cp, cps); }
444  		else
445  			FailR(status.CStr());
446  	}
447  	printf("TUniCaseFolding(\"%s\"): %d common, %d simple, %d full, %d Turkic.\n",
448  		fileName.CStr(), cfCommon.Len(), cfSimple.Len(), cfFull.Len(), cfTurkic.Len());
449  }
450  void TUniCaseFolding::Test(const TIntV& src, const TIntV& expectedDest, const bool full, const bool turkic, FILE *f)
451  {
452  	fprintf(f, "TUniCaseFolding(%s%s): ", (full ? "full" : "simple"), (turkic ? ", turkic" : ""));
453  	for (int i = 0; i < src.Len(); i++) fprintf(f, " %04x", int(src[i]));
454  	TIntV dest; Fold(src, 0, src.Len(), dest, true, full, turkic);
455  	fprintf(f, "\n  -> ");
456  	for (int i = 0; i < dest.Len(); i++) fprintf(f, " %04x", int(dest[i]));
457  	fprintf(f, "\n");
458  	IAssert(dest.Len() == expectedDest.Len());
459  	for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == expectedDest[i]);
460  }
461  void TUniCaseFolding::Test()
462  {
463  	FILE *f = stderr;
464  	TVectorBuilder VB;
465  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x69, 0x63, 0xdf), false, false, f);
466  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x131, 0x63, 0xdf), false, true, f);
467  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x69, 0x63, 0x73, 0x73), true, false, f);
468  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x131, 0x63, 0x73, 0x73), true, true, f);
469  }
470  const ushort TUniChInfo::LineBreak_Unknown = TUniChInfo::GetLineBreakCode('X', 'X');
471  const ushort TUniChInfo::LineBreak_ComplexContext = TUniChInfo::GetLineBreakCode('S', 'A');
472  const ushort TUniChInfo::LineBreak_Numeric = TUniChInfo::GetLineBreakCode('N', 'U');
473  const ushort TUniChInfo::LineBreak_InfixNumeric = TUniChInfo::GetLineBreakCode('I', 'S');
474  const ushort TUniChInfo::LineBreak_Quotation = TUniChInfo::GetLineBreakCode('Q', 'U');
475  void TUniChDb::TestWbFindNonIgnored(const TIntV& src) const
476  {
477  	int n = src.Len();
478  	TBoolV isIgnored; isIgnored.Gen(n);
479  	for (int i = 0; i < n; i++) isIgnored[i] = IsWbIgnored(src[i]);
480  	TIntV prevNonIgnored, nextNonIgnored, curOrNextNonIgnored;
481  	prevNonIgnored.Gen(n); nextNonIgnored.Gen(n); curOrNextNonIgnored.Gen(n);
482  	FILE *f = 0; 
483  	for (int srcIdx = 0; srcIdx < n; srcIdx++) for (int srcLen = 1; srcLen < n - srcIdx; srcLen++)
484  	{
485  		int prev = -1;
486  		for (int i = 0; i < srcLen; i++) {
487  			prevNonIgnored[i] = prev;
488  			if (! isIgnored[srcIdx + i]) prev = srcIdx + i; }
489  		int next = srcIdx + srcLen;
490  		for (int i = srcLen - 1; i >= 0; i--) {
491  			nextNonIgnored[i] = next;
492  			if (! isIgnored[srcIdx + i]) next = srcIdx + i;
493  			curOrNextNonIgnored[i] = next; }
494  		if (f) {
495  			fprintf(f, "\nIndex:     "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", srcIdx + i);
496  			fprintf(f, "\nNonIgn:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %s", (isIgnored[srcIdx + i] ? " ." : " Y"));
497  			fprintf(f, "\nPrevNI:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(prevNonIgnored[i]));
498  			fprintf(f, "\nNextNI:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(nextNonIgnored[i]));
499  			fprintf(f, "\nCurNextNI: "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(curOrNextNonIgnored[i]));
500  			fprintf(f, "\n"); }
501  		for (int i = 0; i < srcLen; i++)
502  		{
503  			size_t s;
504  			s = size_t(srcIdx + i); WbFindNextNonIgnored(src, s, size_t(srcIdx + srcLen));
505  			IAssert(s == size_t(nextNonIgnored[i]));
506  			s = size_t(srcIdx + i); WbFindCurOrNextNonIgnored(src, s, size_t(srcIdx + srcLen));
507  			IAssert(s == size_t(curOrNextNonIgnored[i]));
508  			s = size_t(srcIdx + i); bool ok = WbFindPrevNonIgnored(src, size_t(srcIdx), s);
509  			if (prevNonIgnored[i] < 0) { IAssert(! ok); IAssert(s == size_t(srcIdx)); }
510  			else { IAssert(ok); IAssert(s == size_t(prevNonIgnored[i])); }
511  		}
512  	}
513  }
514  void TUniChDb::TestWbFindNonIgnored() const
515  {
516  	TIntV chIgnored, chNonIgnored;
517  	FILE *f = 0; 
518  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) {
519  		const int cp = h.GetKey(i); const TUniChInfo& ci = h[i];
520  		if (f) fprintf(f, "%04x: flags %08x props %08x %08x script \"%s\"\n", cp,
521  			ci.flags, ci.properties, ci.propertiesX, GetScriptName(ci.script).CStr());
522  		(IsWbIgnored(h[i]) ? chIgnored : chNonIgnored).Add(h.GetKey(i));
523  	}
524  	chIgnored.Sort(); chNonIgnored.Sort();
525  	printf("TUniChDb::TestWbNonIgnored: %d ignored, %d nonignored chars.\n", chIgnored.Len(), chNonIgnored.Len());
526  	TRnd rnd = TRnd(123);
527  	for (int iter = 0; iter <= 50; iter++)
528  	{
529  		int percIgnored = 2 * iter;
530  		for (int n = 0; n <= 20; n++)
531  		{
532  			TIntV v; v.Gen(n);
533  			for (int i = 0; i < n; i++) {
534  				TIntV& chars = (rnd.GetUniDevInt(100) < percIgnored) ? chIgnored : chNonIgnored;
535  				int j = rnd.GetUniDevInt(chars.Len());
536  				v.Add(chars[j]); }
537  			TestWbFindNonIgnored(v);
538  		}
539  	}
540  }
541  void TUniChDb::TestFindNextWordOrSentenceBoundary(const TStr& basePath, bool sentence)
542  {
543  	TUcdFileReader reader; TStrV fields;
544  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), (sentence ? GetSentenceBreakTestFn() : GetWordBreakTestFn())));
545  	int nLines = 0; TRnd rnd = TRnd(123);
546  	while (reader.GetNextLine(fields))
547  	{
548  		nLines += 1;
549  		IAssert(fields.Len() == 1);
550  		TStrV parts; fields[0].SplitOnWs(parts);
551  		const int n = parts.Len(); IAssert((n % 2) == 1);
552  		TIntV chars; TBoolV isBreak, isPredicted, isPredicted2;
553  		for (int i = 0; i < n; i++)
554  		{
555  			const TStr& s = parts[i];
556  			if ((i % 2) == 0) {
557  				if (s == "\xc3\x97") 
558  					isBreak.Add(false);
559  				else if (s == "\xc3\xb7") 
560  					isBreak.Add(true);
561  				else FailR(s.CStr()); }
562  			else chars.Add(reader.ParseCodePoint(s));
563  		}
564  		const int m = n / 2; IAssert(chars.Len() == m); IAssert(isBreak.Len() == m + 1);
565  		IAssert(isBreak[0]); IAssert(isBreak[m]);
566  		isPredicted.Gen(m + 1); isPredicted.PutAll(false);
567  		if (AlwaysFalse()) { printf("%3d", nLines); for (int i = 0; i < m; i++) printf(" %04x", int(chars[i])); printf("\n"); }
568  		for (int nBefore = 0; nBefore < 5; nBefore++)
569  		{
570  			TIntV chars2; for (int i = 0; i < nBefore; i++) chars2.Add(0, rnd.GetUniDevInt(0x10ffff + 1));
571  			chars2.AddV(chars);
572  			size_t position = (nBefore > 0 ? nBefore - 1 : nBefore); size_t prevPosition = position;
573  			while (sentence ? FindNextSentenceBoundary(chars2, nBefore, m, position) : FindNextWordBoundary(chars2, nBefore, m, position))
574  			{
575  				IAssert(prevPosition < position);
576  				IAssert(position <= size_t(nBefore + m));
577  				isPredicted[int(position) - nBefore] = true;
578  				prevPosition = position;
579  			}
580  			IAssert(position == size_t(nBefore + m));
581  			if (sentence) FindSentenceBoundaries(chars2, nBefore, m, isPredicted2);
582  			else FindWordBoundaries(chars2, nBefore, m, isPredicted2);
583  			IAssert(isPredicted2.Len() == m + 1);
584  			bool ok = true;
585  			if (nBefore == 0) isPredicted[0] = true;
586  			for (int i = 0; i <= m; i++) {
587  				if (isBreak[i] != isPredicted[i]) ok = false;
588  				IAssert(isPredicted2[i] == isPredicted[i]); }
589  			FILE *f = stderr;
590  			if (! ok)
591  			{
592  				fprintf(f, "\nError in line %d:\n", nLines);
593  				fprintf(f, "True:      ");
594  				for (int i = 0; i <= m; i++) {
595  					fprintf(f, "%s ", (isBreak[i] ? "|" : "."));
596  					if (i < m) fprintf(f, "%04x ", int(chars[i + nBefore])); }
597  				fprintf(f, "\nPredicted: ");
598  				for (int i = 0; i <= m; i++) {
599  					fprintf(f, "%s ", (isPredicted[i] ? "|" : "."));
600  					if (i < m) {
601  						const int cp = chars[i + nBefore];
602  						TStr s = sentence ? TUniChInfo::GetSbFlagsStr(GetSbFlags(cp)) : TUniChInfo::GetWbFlagsStr(GetWbFlags(cp));
603  						if (IsWbIgnored(cp)) s = "*" + s;
604  						fprintf(f, "%4s ", s.CStr()); }}
605  				fprintf(f, "\n");
606  				Fail;
607  			}
608  			for (int i = 0; i < m; i++) {
609  				position = i + nBefore; bool ok = sentence ? FindNextSentenceBoundary(chars2, nBefore, m, position) : FindNextWordBoundary(chars2, nBefore, m, position);
610  				IAssert(ok); 
611  				IAssert(size_t(i + nBefore) < position); IAssert(position <= size_t(nBefore + m));
612  				position -= nBefore;
613  				for (int j = i + 1; j < int(position); j++)
614  					IAssert(! isBreak[j]);
615  				IAssert(isBreak[int(position)]); }
616  		}
617  	}
618  	reader.Close();
619  	printf("TUniChDb::TestFindNext%sBoundary: %d lines processed.\n", (sentence ? "Sentence" : "Word"), nLines);
620  }
621  void TUniChDb::TestComposition(const TStr& basePath)
622  {
623  	TUcdFileReader reader; TStrV fields; int nLines = 0;
624  	reader.Open(CombinePath(basePath, GetNormalizationTestFn()));
625  	bool inPart1 = false; TIntH testedInPart1;
626  	while (reader.GetNextLine(fields))
627  	{
628  		nLines += 1;
629  		if (fields.Len() == 1) {
630  			IAssert(fields[0].IsPrefix("@Part"));
631  			inPart1 = (fields[0] == "@Part1"); continue; }
632  		IAssert(fields.Len() == 6);
633  		IAssert(fields[5].Len() == 0);
634  		TIntV c1, c2, c3, c4, c5;
635  		reader.ParseCodePointList(fields[0], c1);
636  		reader.ParseCodePointList(fields[1], c2);
637  		reader.ParseCodePointList(fields[2], c3);
638  		reader.ParseCodePointList(fields[3], c4);
639  		reader.ParseCodePointList(fields[4], c5);
640  		TIntV v;
641  #define AssE_(v1, v2, expl) AssertEq(v1, v2, TStr(expl) + " (line " + TInt::GetStr(nLines) + ")", 0)
642  #define NFC_(cmpWith, operand) DecomposeAndCompose(operand, 0, operand.Len(), v, false); AssE_(cmpWith, v, #cmpWith " == NFC(" #operand ")")
643  #define NFD_(cmpWith, operand) Decompose(operand, 0, operand.Len(), v, false); AssE_(cmpWith, v, #cmpWith " == NFD(" #operand ")")
644  #define NFKC_(cmpWith, operand) DecomposeAndCompose(operand, 0, operand.Len(), v, true); AssE_(cmpWith, v, #cmpWith " == NFKC(" #operand ")")
645  #define NFKD_(cmpWith, operand) Decompose(operand, 0, operand.Len(), v, true); AssE_(cmpWith, v, #cmpWith " == NFKD(" #operand ")")
646  		NFD_(c3, c1);   
647  		NFD_(c3, c2);   
648  		NFD_(c3, c3);   
649  		NFD_(c5, c4);   
650  		NFD_(c5, c5);   
651  		NFC_(c2, c1);   
652  		NFC_(c2, c2);   
653  		NFC_(c2, c3);   
654  		NFC_(c4, c4);   
655  		NFC_(c4, c5);   
656  		NFKD_(c5, c1);   
657  		NFKD_(c5, c2);   
658  		NFKD_(c5, c3);   
659  		NFKD_(c5, c4);   
660  		NFKD_(c5, c5);   
661  		NFKC_(c4, c1);   
662  		NFKC_(c4, c2);   
663  		NFKC_(c4, c3);   
664  		NFKC_(c4, c4);   
665  		NFKC_(c4, c5);   
666  		if (inPart1) {
667  			IAssert(c1.Len() == 1);
668  			testedInPart1.AddKey(c1[0]); }
669  	}
670  	reader.Close();
671  	int nOther = 0;
672  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
673  	{
674  		const int cp = h.GetKey(i), nLines = -1;
675  		if (testedInPart1.IsKey(cp)) continue;
676  		TIntV x, v; x.Add(cp);
677  		NFC_(x, x);    
678  		NFD_(x, x);    
679  		NFKC_(x, x);   
680  		NFKD_(x, x);   
681  		nOther += 1;
682  	}
683  #undef AssE_
684  #undef NFC_
685  #undef NFD_
686  #undef NFKC_
687  #undef NFKD_
688  	printf("TUniChDb::TestComposition: %d lines processed + %d other individual codepoints.\n", nLines, nOther);
689  }
690  void TUniChDb::TestCaseConversion(const TStr& source, const TStr& trueLc,
691  								  const TStr& trueTc, const TStr& trueUc,
692  								  bool turkic, bool lithuanian)
693  {
694  	TIntV src;
695  	TUcdFileReader::ParseCodePointList(source, src);
696  	FILE *f = stderr;
697  	for (int i = 0; i < 3; i++)
698  	{
699  		TCaseConversion how = (i == 0) ? ccLower : (i == 1) ? ccTitle : ccUpper;
700  		const TStr &trueDestS = (how == ccLower ? trueLc : how == ccTitle ? trueTc : trueUc);
701  		TIntV trueDest; TUcdFileReader::ParseCodePointList(trueDestS, trueDest);
702  		TIntV dest;
703  		GetCaseConverted(src, 0, src.Len(), dest, true, how, turkic, lithuanian);
704  		bool ok = (dest.Len() == trueDest.Len());
705  		if (ok) for (int i = 0; i < dest.Len() && ok; i++) ok = ok && (dest[i] == trueDest[i]);
706  		if (ok) continue;
707  		fprintf(f, "%s(", (how == ccLower ? "toLowercase" : how == ccTitle ? "toTitlecase" : "toUppercase"));
708  		for (int i = 0; i < src.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(src[i]));
709  		fprintf(f, ")\nCorrect:   (");
710  		for (int i = 0; i < trueDest.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(trueDest[i]));
711  		fprintf(f, ")\nOur output:(");
712  		for (int i = 0; i < dest.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(dest[i]));
713  		fprintf(f, ")\n");
714  		IAssert(ok);
715  	}
716  }
717  void TUniChDb::TestCaseConversions()
718  {
719  	const TStr F = "0046 ", L = "004C ", S = "0053 ", T = "0054 ", W = "0057 ";
720  	const TStr f = "0066 ", l = "006c ", s = "0073 ", t = "0074 ", w = "0077 ";
721  	const TStr ss = "00df ", ffl = "fb04 ", longs = "017f ", longst = "fb05 ", wRing = "1e98 ", Ring = "030a ";
722  	const TStr DZ = "01c4 ", Dz = "01c5 ", dz = "01c6 ";
723  	const TStr space = "0020 ", Grave = "0300 ";
724  	TestCaseConversion(
725  		F + L + s + t + space + Dz + w + T + ss + wRing + space + longs + DZ + space + dz + longst,  
726  		f + l + s + t + space + dz + w + t + ss + wRing + space + longs + dz + space + dz + longst,  
727  		F + l + s + t + space + Dz + w + t + ss + wRing + space + S + dz + space + Dz + longst,      
728  		F + L + S + T + space + DZ + W + T + S + S + W + Ring + space + S + DZ + space + DZ + S + T, 
729  		false, false);
730  	const TStr I = "0049 ", J = "004a ", i = "0069 ", j = "006a ", iDotless = "0131 ", IDot = "0130 ", DotA = "0307 ";
731  	TestCaseConversion(
732  		s + I + t + i + w + iDotless + f + IDot + l + space + iDotless + DotA + f + I + DotA + s, 
733  		s + i + t + i + w + iDotless + f + i + DotA + l + space + iDotless + DotA + f + i + DotA + s, 
734  		S + i + t + i + w + iDotless + f + i + DotA + l + space + I + DotA + f + i + DotA + s, 
735  		S + I + T + I + W + I + F + IDot + L + space + I + DotA + F + I + DotA + S, 
736  		false, false);
737  	const TStr Sigma = "03a3 ", sigma = "03c3 ", fsigma = "03c2 ";
738  	TestCaseConversion(
739  		Sigma + s + space + s + Sigma  + space + s + Sigma + s + space + Sigma + S + Sigma  + space + Sigma, 
740  		sigma + s + space + s + fsigma + space + s + sigma + s + space + sigma + s + fsigma + space + sigma, 
741  		Sigma + s + space + S + fsigma + space + S + sigma + s + space + Sigma + s + fsigma + space + Sigma, 
742  		Sigma + S + space + S + Sigma  + space + S + Sigma + S + space + Sigma + S + Sigma  + space + Sigma, 
743  		false, false);
744  	TestCaseConversion(
745  		sigma + s + space + s + sigma  + space + s + sigma + s + space + sigma + S + sigma  + space + sigma, 
746  		sigma + s + space + s + sigma  + space + s + sigma + s + space + sigma + s + sigma  + space + sigma, 
747  		Sigma + s + space + S + sigma  + space + S + sigma + s + space + Sigma + s + sigma  + space + Sigma, 
748  		Sigma + S + space + S + Sigma  + space + S + Sigma + S + space + Sigma + S + Sigma  + space + Sigma, 
749  		false, false);
750  	TestCaseConversion(
751  		fsigma + s + space + s + fsigma + space + s + fsigma + s + space + fsigma + S + fsigma  + space + fsigma, 
752  		fsigma + s + space + s + fsigma + space + s + fsigma + s + space + fsigma + s + fsigma  + space + fsigma, 
753  		Sigma  + s + space + S + fsigma + space + S + fsigma + s + space + Sigma  + s + fsigma  + space + Sigma, 
754  		Sigma  + S + space + S + Sigma  + space + S + Sigma  + S + space + Sigma  + S + Sigma   + space + Sigma, 
755  		false, false);
756  	const TStr nonSA = "0315 0321 0322 "; 
757  	TestCaseConversion(
758  		s + I + t + i + w + iDotless + f + IDot + l + space + iDotless + DotA + f + I + DotA + J + DotA + I + Grave + DotA + I + DotA + DotA + I + nonSA + DotA + s, 
759  		s + iDotless + t + i + w + iDotless + f + i + l + space + iDotless + DotA + f + i + j + DotA + iDotless + Grave + DotA + i + DotA + i + nonSA + s, 
760  		S + iDotless + t + i + w + iDotless + f + i + l + space + I + DotA + f + i + j + DotA + iDotless + Grave + DotA + i + DotA + i + nonSA + s, 
761  		S + I + T + IDot + W + I + F + IDot + L + space + I + DotA + F + I + DotA + J + DotA + I + Grave + DotA + I + DotA + DotA + I + nonSA + DotA + S, 
762  		true, false); 
763  	TestCaseConversion(
764  		I + Grave + t + I + DotA + f + I + nonSA + DotA + j + space + I + nonSA + DotA + space + I + Grave + t, 
765  		iDotless + Grave + t + i + f + i + nonSA + j + space + i + nonSA + space + iDotless + Grave + t, 
766  		I + Grave + t + i + f + i + nonSA + j + space + I + nonSA + DotA + space + I + Grave + t, 
767  		I + Grave + T + I + DotA + F + I + nonSA + DotA + J + space + I + nonSA + DotA + space + I + Grave + T, 
768  		true, false); 
769  	TestCaseConversion(
770  		i + DotA + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + I + DotA + t + DotA + i + DotA + Grave, 
771  		i + DotA + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + i + DotA + DotA + t + DotA + i + DotA + Grave, 
772  		I + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + i + DotA + DotA + t + DotA + i + DotA + Grave, 
773  		I + T + I + Grave + DotA + F + I + DotA + F + I + nonSA + I + DotA + T + DotA + I + Grave, 
774  		false, true); 
775  	TestCaseConversion(
776  		J +        Grave + space + J +        nonSA + DotA + space + j + Grave + space + j + DotA + space + J + nonSA + J +        nonSA + Grave + space + j + nonSA, 
777  		j + DotA + Grave + space + j + DotA + nonSA + DotA + space + j + Grave + space + j + DotA + space + j + nonSA + j + DotA + nonSA + Grave + space + j + nonSA, 
778  		J +        Grave + space + J +        nonSA + DotA + space + J + Grave + space + J +        space + J + nonSA + j + DotA + nonSA + Grave + space + J + nonSA, 
779  		J +        Grave + space + J +        nonSA + DotA + space + J + Grave + space + J +        space + J + nonSA + J +        nonSA + Grave + space + J + nonSA, 
780  		false, true); 
781  }
782  void TUniChDb::LoadTxt_ProcessDecomposition(TUniChInfo& ci, TStr s)
783  {
784  	if (s.Empty()) return;
785  	if (s[0] == '<') {
786  		int i = s.SearchCh('>'); IAssert(i > 0);
787  		ci.flags |= ucfCompatibilityDecomposition;
788  		s = s.GetSubStr(i + 1, s.Len() - 1); s.ToTrunc(); }
789  	TIntV dec; TUcdFileReader::ParseCodePointList(s, dec);
790  	IAssert(dec.Len() > 0);
791  	ci.decompOffset = decompositions.Len();
792  	decompositions.AddV(dec); decompositions.Add(-1);
793  }
794  void TUniChDb::InitPropList(const TStr& basePath)
795  {
796  	TUcdFileReader reader; TStrV fields; int nCps = 0, nLines = 0;
797  	reader.Open(CombinePath(basePath, GetPropListFn()));
798  	TSubcatHelper helper(*this);
799  	while (reader.GetNextLine(fields))
800  	{
801  		IAssert(fields.Len() == 2);
802  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
803  		TStr s = fields[1];
804  		TUniChProperties prop = TUniChProperties(0); TUniChPropertiesX propx = TUniChPropertiesX(0);
805  		if (s == "White_Space") prop = ucfPrWhiteSpace;
806  		else if (s == "Bidi_Control") prop = ucfPrBidiControl;
807  		else if (s == "Join_Control") prop = ucfPrJoinControl;
808  		else if (s == "Dash") prop = ucfPrDash;
809  		else if (s == "Hyphen") prop = ucfPrHyphen;
810  		else if (s == "Quotation_Mark") prop = ucfPrQuotationMark;
811  		else if (s == "Terminal_Punctuation") prop = ucfPrTerminalPunctuation;
812  		else if (s == "Other_Math") propx = ucfPxOtherMath;
813  		else if (s == "Hex_Digit") prop = ucfPrHexDigit;
814  		else if (s == "ASCII_Hex_Digit") prop = ucfPrAsciiHexDigit;
815  		else if (s == "Other_Alphabetic") propx = ucfPxOtherAlphabetic;
816  		else if (s == "Ideographic") prop = ucfPrIdeographic;
817  		else if (s == "Diacritic") prop = ucfPrDiacritic;
818  		else if (s == "Extender") prop = ucfPrExtender;
819  		else if (s == "Other_Lowercase") propx = ucfPxOtherLowercase;
820  		else if (s == "Other_Uppercase") propx = ucfPxOtherUppercase;
821  		else if (s == "Noncharacter_Code_Point") prop = ucfPrNoncharacterCodePoint;
822  		else if (s == "Other_Grapheme_Extend") propx = ucfPxOtherGraphemeExtend;
823  		else if (s == "IDS_Binary_Operator") propx = ucfPxIdsBinaryOperator;
824  		else if (s == "IDS_Trinary_Operator") propx = ucfPxIdsTrinaryOperator;
825  		else if (s == "Radical") propx = ucfPxRadical;
826  		else if (s == "Unified_Ideograph") propx = ucfPxUnifiedIdeograph;
827  		else if (s == "Other_Default_Ignorable_Code_Point") propx = ucfPxOtherDefaultIgnorableCodePoint;
828  		else if (s == "Deprecated") prop = ucfPrDeprecated;
829  		else if (s == "Soft_Dotted") prop = ucfPrSoftDotted;
830  		else if (s == "Logical_Order_Exception") prop = ucfPrLogicalOrderException;
831  		else if (s == "Other_ID_Start") propx = ucfPxOtherIdStart;
832  		else if (s == "Other_ID_Continue") propx = ucfPxOtherIdContinue;
833  		else if (s == "STerm") prop = ucfPrSTerm;
834  		else if (s == "Variation_Selector") prop = ucfPrVariationSelector;
835  		else if (s == "Pattern_White_Space") prop = ucfPrPatternWhiteSpace;
836  		else if (s == "Pattern_Syntax") prop = ucfPrPatternSyntax;
837  		else FailR(s.CStr());
838  		helper.ProcessComment(reader);
839  		for (int cp = from; cp <= to; cp++) {
840  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
841  			TUniChInfo &ci = h[i]; helper.TestCat(cp);
842  			if (prop) { IAssert(! ci.IsProperty(prop)); ci.SetProperty(prop); }
843  			if (propx) { IAssert(! ci.IsPropertyX(propx)); ci.SetPropertyX(propx); }
844  			nCps++; }
845  		nLines++;
846  	}
847  	reader.Close();
848  	printf("TUniChDb::InitPropList: %d lines, %d code points.\n", nLines, nCps);
849  }
850  void TUniChDb::InitDerivedCoreProperties(const TStr& basePath)
851  {
852  	TUcdFileReader reader; TStrV fields; int nCps = 0, nLines = 0;
853  	reader.Open(CombinePath(basePath, GetDerivedCorePropsFn()));
854  	TSubcatHelper helper(*this);
855  	while (reader.GetNextLine(fields))
856  	{
857  		IAssert(fields.Len() == 2);
858  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
859  		TStr s = fields[1];
860  		TUniChFlags flag = ucfCompatibilityDecomposition;
861  		if (s == "Math") flag = ucfDcpMath;
862  		else if (s == "Alphabetic") flag = ucfDcpAlphabetic;
863  		else if (s == "Lowercase") flag = ucfDcpLowercase;
864  		else if (s == "Uppercase") flag = ucfDcpUppercase;
865  		else if (s == "ID_Start") flag = ucfDcpIdStart;
866  		else if (s == "ID_Continue") flag = ucfDcpIdContinue;
867  		else if (s == "XID_Start") flag = ucfDcpXidStart;
868  		else if (s == "XID_Continue") flag = ucfDcpXidContinue;
869  		else if (s == "Default_Ignorable_Code_Point") flag = ucfDcpDefaultIgnorableCodePoint;
870  		else if (s == "Grapheme_Extend") flag = ucfDcpGraphemeExtend;
871  		else if (s == "Grapheme_Base") flag = ucfDcpGraphemeBase;
872  		else if (s == "Grapheme_Link") continue; 
873  		else FailR(s.CStr());
874  		helper.ProcessComment(reader);
875  		for (int cp = from; cp <= to; cp++) {
876  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
877  			helper.TestCat(cp);
878  			TUniChInfo &ci = h[i]; IAssert(! ci.IsDcpFlag(flag));
879  			ci.SetDcpFlag(flag); nCps++; }
880  		nLines++;
881  	}
882  	reader.Close();
883  	printf("TUniChDb::InitDerivedCoreProperties: %d lines, %d code points.\n", nLines, nCps);
884  }
885  void TUniChDb::InitLineBreaks(const TStr& basePath)
886  {
887  	ushort xx = TUniChInfo::LineBreak_Unknown;
888  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) h[i].lineBreak = xx;
889  	TUcdFileReader reader; TStrV fields;
890  	reader.Open(CombinePath(basePath, GetLineBreakFn()));
891  	int nLines = 0, nCps = 0;
892  	while (reader.GetNextLine(fields))
893  	{
894  		IAssert(fields.Len() == 2);
895  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
896  		TStr s = fields[1]; IAssert(s.Len() == 2);
897  		ushort us = TUniChInfo::GetLineBreakCode(s[0], s[1]);
898  		if (us == xx) continue;
899  		for (int cp = from; cp <= to; cp++) {
900  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp);
901  				printf("TUniChDb::InitLineBreaks: warning, adding codepoint %d, its category will remain unknown.\n", cp); }
902  			IAssert(h[i].lineBreak == xx);
903  			h[i].lineBreak = us; nCps++; }
904  		nLines++;
905  	}
906  	reader.Close();
907  	printf("TUniChDb::InitLineBreaks: %d lines, %d codepoints processed (excluding \'xx\' values).\n", nLines, nCps);
908  }
909  void TUniChDb::InitScripts(const TStr& basePath)
910  {
911  	TUcdFileReader reader; TStrV fields;
912  	reader.Open(CombinePath(basePath, GetScriptsFn()));
913  	TSubcatHelper helper(*this);
914  	while (reader.GetNextLine(fields))
915  	{
916  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
917  		TStr scriptName = fields[1];
918  		int scriptNo = scripts.GetKeyId(scriptName);
919  		if (scriptNo < 0) { scriptNo = scripts.AddKey(scriptName); scripts[scriptNo] = 0; }
920  		IAssert(scriptNo >= 0 && scriptNo < SCHAR_MAX); 
921  		scripts[scriptNo] += 1;
922  		helper.ProcessComment(reader);
923  		for (int cp = from; cp <= to; cp++) {
924  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
925  			helper.TestCat(cp);
926  			TUniChInfo &ci = h[i]; ci.script = scriptNo; }
927  	}
928  	reader.Close();
929  	scripts.AddDat(GetScriptNameUnknown()) = 0;
930  	printf("TUniChDb::InitScripts: %d scripts: ", scripts.Len());
931  	if (AlwaysFalse()) for (int i = scripts.FFirstKeyId(); scripts.FNextKeyId(i); )
932  		printf("  %d:%s (%d)", i, scripts.GetKey(i).CStr(), int(scripts[i]));
933  	printf("\n");
934  }
935  void TUniChDb::InitWordAndSentenceBoundaryFlags(const TStr& basePath)
936  {
937  	int katakana = GetScriptByName(GetScriptNameKatakana()); IAssert(katakana >= 0);
938  	int hiragana = GetScriptByName(GetScriptNameHiragana()); IAssert(hiragana >= 0);
939  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
940  	{
941  		const int cp = h.GetKey(i); TUniChInfo& ci = h[i];
942  		ci.ClrWbAndSbFlags();
943  		if (ci.subCat  == ucOtherFormat && cp != 0x200c && cp != 0x200d) ci.SetWbFlag(ucfWbFormat);
944  		if (ci.script == katakana) ci.SetWbFlag(ucfWbKatakana);
945  		if (ci.lineBreak == TUniChInfo::LineBreak_InfixNumeric && cp != 0x3a) ci.SetWbFlag(ucfWbMidNum);
946  		if (ci.lineBreak == TUniChInfo::LineBreak_Numeric) ci.SetWbFlag(ucfWbNumeric);
947  		if (ci.subCat == ucPunctuationConnector) ci.SetWbFlag(ucfWbExtendNumLet);
948  		if (cp == 0xa || cp == 0xd || cp == 0x85 || cp == 0x2028 || cp == 0x2029) ci.SetSbFlag(ucfSbSep);
949  		if (ci.subCat == ucOtherFormat && cp != 0x200c && cp != 0x200d) ci.SetSbFlag(ucfSbFormat);
950  		if (ci.IsWhiteSpace() && ! ci.IsSbFlag(ucfSbSep) && cp != 0xa0) ci.SetSbFlag(ucfSbSp);
951  		if (ci.IsLowercase() && ! ci.IsGraphemeExtend()) ci.SetSbFlag(ucfSbLower);
952  		if (ci.IsUppercase() || ci.subCat == ucLetterTitlecase) ci.SetSbFlag(ucfSbUpper);
953  		if ((ci.IsAlphabetic() || cp == 0xa0 || cp == 0x5f3) && ! ci.IsSbFlag(ucfSbLower) && ! ci.IsSbFlag(ucfSbUpper) && ! ci.IsGraphemeExtend()) ci.SetSbFlag(ucfSbOLetter);
954  		if (ci.lineBreak == TUniChInfo::LineBreak_Numeric) ci.SetSbFlag(ucfSbNumeric);
955  		if (cp == 0x2e) ci.SetSbFlag(ucfSbATerm);
956  		if (ci.IsSTerminal() && cp != 0x2e) ci.SetSbFlag(ucfSbSTerm);
957  		if ((ci.subCat == ucPunctuationOpen || ci.subCat == ucPunctuationClose || ci.lineBreak == TUniChInfo::LineBreak_Quotation) && cp != 0x5f3 && ! ci.IsSbFlag(ucfSbATerm) && ! ci.IsSbFlag(ucfSbSTerm)) ci.SetSbFlag(ucfSbClose);
958  	}
959  	TIntV v = (VB, 0x3031, 0x3032, 0x3033, 0x3034, 0x3035, 0x309b, 0x309c, 0x30a0, 0x30fc, 0xff70, 0xff9e, 0xff9f);
960  	for (int i = 0; i < v.Len(); i++) h.GetDat(v[i]).SetWbFlag(ucfWbKatakana);
961  	v = (VB, 0x27, 0xb7, 0x5f4, 0x2019, 0x2027, 0x3a);
962  	for (int i = 0; i < v.Len(); i++) h.GetDat(v[i]).SetWbFlag(ucfWbMidLetter);
963  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
964  	{
965  		const int cp = h.GetKey(i); TUniChInfo& ci = h[i];
966  		if ((ci.IsAlphabetic() || cp == 0x5f3) && ! ci.IsIdeographic() && ! ci.IsWbFlag(ucfWbKatakana) && ci.lineBreak != TUniChInfo::LineBreak_ComplexContext && ci.script != hiragana && ! ci.IsGraphemeExtend())
967  			ci.SetWbFlag(ucfWbALetter);
968  	}
969  	{TUcdFileReader reader; TStrV fields;
970  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), GetWordBreakPropertyFn()));
971  	THash<TInt, TInt> hh;
972  	while (reader.GetNextLine(fields))
973  	{
974  		IAssert(fields.Len() == 2);
975  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
976  		TStr s = fields[1];
977  		TUniChFlags flag = ucfCompatibilityDecomposition;
978  		if (s == "Format") flag = ucfWbFormat;
979  		else if (s == "Katakana") flag = ucfWbKatakana;
980  		else if (s == "ALetter") flag = ucfWbALetter;
981  		else if (s == "MidLetter") flag = ucfWbMidLetter;
982  		else if (s == "MidNum") flag = ucfWbMidNum;
983  		else if (s == "Numeric") flag = ucfWbNumeric;
984  		else if (s == "ExtendNumLet") flag = ucfWbExtendNumLet;
985  		else FailR(s.CStr());
986  		for (int c = from; c <= to; c++) {
987  			int i = hh.GetKeyId(c); if (i < 0) hh.AddDat(c, flag);
988  			else hh[i].Val |= flag; }
989  	}
990  	reader.Close();
991  	TIntV cps; for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) cps.Add(h.GetKey(i));
992  	for (int i = hh.FFirstKeyId(); hh.FNextKeyId(i); ) cps.Add(hh.GetKey(i));
993  	cps.Sort(); cps.Merge();
994  	for (int i = 0; i < cps.Len(); i++)
995  	{
996  		int cp = cps[i];
997  		int flags1 = 0; if (h.IsKey(cp)) flags1 = h.GetDat(cp).GetWbFlags();
998  		int flags2 = 0; if (hh.IsKey(cp)) flags2 = hh.GetDat(cp);
999  		flags1 &= ~ucfSbSep; flags2 &= ~ucfSbSep;
1000  		if (flags1 != flags2) {
1001  			printf("cp = %04x: flags1 = %08x flags2 = %08x xor = %08x\n", cp, flags1, flags2, flags1 ^ flags2);
1002  			Fail; }
1003  	}}
1004  	{TUcdFileReader reader; TStrV fields;
1005  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), GetSentenceBreakPropertyFn()));
1006  	THash<TInt, TInt> hh;
1007  	while (reader.GetNextLine(fields))
1008  	{
1009  		IAssert(fields.Len() == 2);
1010  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
1011  		TStr s = fields[1];
1012  		TUniChFlags flag = ucfCompatibilityDecomposition;
1013  		if (s == "Sep") flag = ucfSbSep;
1014  		else if (s == "Format") flag = ucfSbFormat;
1015  		else if (s == "Sp") flag = ucfSbSp;
1016  		else if (s == "Lower") flag = ucfSbLower;
1017  		else if (s == "Upper") flag = ucfSbUpper;
1018  		else if (s == "OLetter") flag = ucfSbOLetter;
1019  		else if (s == "Numeric") flag = ucfSbNumeric;
1020  		else if (s == "ATerm") flag = ucfSbATerm;
1021  		else if (s == "STerm") flag = ucfSbSTerm;
1022  		else if (s == "Close") flag = ucfSbClose;
1023  		else FailR(s.CStr());
1024  		for (int c = from; c <= to; c++) {
1025  			int i = hh.GetKeyId(c); if (i < 0) hh.AddDat(c, flag);
1026  			else hh[i].Val |= flag; }
1027  	}
1028  	reader.Close();
1029  	TIntV cps; for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) cps.Add(h.GetKey(i));
1030  	for (int i = hh.FFirstKeyId(); hh.FNextKeyId(i); ) cps.Add(hh.GetKey(i));
1031  	cps.Sort(); cps.Merge();
1032  	for (int i = 0; i < cps.Len(); i++)
1033  	{
1034  		int cp = cps[i];
1035  		int flags1 = 0; if (h.IsKey(cp)) flags1 = h.GetDat(cp).GetSbFlags();
1036  		int flags2 = 0; if (hh.IsKey(cp)) flags2 = hh.GetDat(cp);
1037  		if (flags1 != flags2) {
1038  			printf("cp = %04x: flags1 = %08x [%s] flags2 = %08x [%s] xor = %08x\n", cp,
1039  				flags1, TUniChInfo::GetSbFlagsStr(flags1).CStr(),
1040  				flags2, TUniChInfo::GetSbFlagsStr(flags2).CStr(),
1041  				flags1 ^ flags2);
1042  			Fail; }
1043  	}}
1044  }
1045  void TUniChDb::InitSpecialCasing(const TStr& basePath)
1046  {
1047  	TUcdFileReader reader; TStrV fields;
1048  	reader.Open(CombinePath(basePath, GetSpecialCasingFn()));
1049  	while (reader.GetNextLine(fields))
1050  	{
1051  		IAssert(fields.Len() == 5 || fields.Len() == 6);
1052  		IAssert(fields.Last().Empty());
1053  		TStr conditions = "";
1054  		if (fields.Len() == 6) conditions = fields[4];
1055  		conditions.ToTrunc(); if (! conditions.Empty()) continue;
1056  		const int cp = reader.ParseCodePoint(fields[0]);
1057  		TIntV v; reader.ParseCodePointList(fields[1], v);
1058  		specialCasingLower.AddDat(cp, v);
1059  		reader.ParseCodePointList(fields[2], v);
1060  		specialCasingTitle.AddDat(cp, v);
1061  		reader.ParseCodePointList(fields[3], v);
1062  		specialCasingUpper.AddDat(cp, v);
1063  	}
1064  	reader.Close();
1065  }
1066  void TUniChDb::LoadTxt(const TStr& basePath)
1067  {
1068  	Clr();
1069  	h = THash<TInt, TUniChInfo>(196613, true);
1070  	caseFolding.LoadTxt(CombinePath(basePath, GetCaseFoldingFn()));
1071  	TUcdFileReader reader; TStrV fields; TIntH seen;
1072  	reader.Open(CombinePath(basePath, GetUnicodeDataFn()));
1073  	while (reader.GetNextLine(fields))
1074  	{
1075  		int cp = reader.ParseCodePoint(fields[0]);
1076  		IAssert(! seen.IsKey(cp)); seen.AddKey(cp);
1077  		TUniChInfo& ci = h.AddDat(cp);
1078  		ci.nameOffset = charNames.AddStr(fields[1]);
1079  		TStr& s = fields[2]; IAssert(s.Len() == 2);
1080  		ci.chCat = s[0]; ci.chSubCat = s[1];
1081  		s = fields[3]; IAssert(s.Len() > 0);
1082  		int i; bool ok = s.IsInt(true, TUCh::Mn, TUCh::Mx, i); IAssertR(ok, s);
1083  		ci.combClass = (uchar) i;
1084  		LoadTxt_ProcessDecomposition(ci, fields[5]);
1085  		s = fields[12]; ci.simpleUpperCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1086  		s = fields[13]; ci.simpleLowerCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1087  		s = fields[14]; ci.simpleTitleCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1088  		ci.InitAfterLoad(); 
1089  	}
1090  	reader.Close();
1091  	InitScripts(basePath);
1092  	InitPropList(basePath);
1093  	InitDerivedCoreProperties(basePath);
1094  	InitLineBreaks(basePath);
1095  	InitSpecialCasing(basePath);
1096  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1097  	{
1098  		TUniChInfo& ci = h[i];
1099  		int ofs = ci.decompOffset; if (ofs < 0) continue;
1100  		int n = 0; while (decompositions[ofs + n] >= 0) n++;
1101  		IAssert(n > 0);
1102  		if (n == 1) { ci.flags |= ucfCompositionExclusion; continue; }
1103  		int cp1 = decompositions[ofs];
1104  		IAssert(h.IsKey(cp1));
1105  		uchar ccc = h.GetDat(cp1).combClass;
1106  		if (ccc != TUniChInfo::ccStarter) { ci.flags |= ucfCompositionExclusion; continue; }
1107  	}
1108  	reader.Open(CombinePath(basePath, GetCompositionExclusionsFn()));
1109  	int nExclusionTable = 0;
1110  	while (reader.GetNextLine(fields))
1111  	{
1112  		IAssert(fields.Len() == 1);
1113  		int cp = reader.ParseCodePoint(fields[0]);
1114  		int i = h.GetKeyId(cp); IAssert(i >= 0);
1115  		h[i].flags |= ucfCompositionExclusion;
1116  		nExclusionTable++;
1117  	}
1118  	reader.Close();
1119  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1120  	{
1121  		int cp = h.GetKey(i);
1122  		TUniChInfo& ci = h[i];
1123  		int ofs = ci.decompOffset; if (ofs < 0) continue;
1124  		if (ci.IsCompositionExclusion()) continue;
1125  		if (ci.IsCompatibilityDecomposition()) continue;
1126  		int n = 0; while (decompositions[ofs + n] >= 0) n++;
1127  		if (n != 2) continue;
1128  		TIntPr pr = TIntPr(decompositions[ofs], decompositions[ofs + 1]);
1129  		IAssert(! inverseDec.IsKey(pr));
1130  		IAssert(ci.combClass == TUniChInfo::ccStarter);
1131  		inverseDec.AddDat(pr, cp);
1132  	}
1133  	printf("TUniChDb(%s): %d chars in h, %d in decomp inverse index; %d in decomp vector; %d in exclusion table\n",
1134  		basePath.CStr(), h.Len(), inverseDec.Len(), decompositions.Len(), nExclusionTable);
1135  	InitWordAndSentenceBoundaryFlags(basePath); 
1136  	for (int cp = HangulSBase; cp < HangulSBase + HangulSCount; cp++)
1137  	{
1138  		int j = h.GetKeyId(cp); if (j < 0) continue;
1139  		TUniChInfo& ci = h[j];
1140  		if (ci.combClass == TUniChInfo::ccInvalid) ci.combClass = TUniChInfo::ccStarter;
1141  		IAssert(ci.combClass == TUniChInfo::ccStarter);
1142  	}
1143  	const int oldHLen = h.Len();
1144  	int scriptUnknown = GetScriptByName(GetScriptNameUnknown());
1145  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1146  	{
1147  		int cp = h.GetKey(i); TUniChInfo &ci = h[i];
1148  		if (ci.simpleLowerCaseMapping < 0) ci.simpleLowerCaseMapping = cp;
1149  		if (ci.simpleUpperCaseMapping < 0) ci.simpleUpperCaseMapping = cp;
1150  		if (ci.simpleTitleCaseMapping < 0) ci.simpleTitleCaseMapping = cp;
1151  		if (ci.script < 0) ci.script = scriptUnknown;
1152  	}
1153  	IAssert(h.Len() == oldHLen);
1154  }
1155  void TUniChDb::SaveBin(const TStr& fnBinUcd)
1156  {
1157  	PSOut SOut=TFOut::New(fnBinUcd);
1158  	Save(*SOut);
1159  }
1160  void TUniChDb::InitAfterLoad()
1161  {
1162  	scriptUnknown = GetScriptByName(GetScriptNameUnknown()); IAssert(scriptUnknown >= 0);
1163  }
1164  void TUniChDb::Test(const TStr& basePath)
1165  {
1166  	TStr fnBin = CombinePath(basePath, GetBinFn());
1167  	if (true || ! TFile::Exists(fnBin))
1168  	{
1169  		LoadTxt(basePath);
1170  		{PSOut SOut = TFOut::New(fnBin);
1171  		Save(*SOut);}
1172  	}
1173  	this->~TUniChDb();
1174  	new(this) TUniChDb();
1175  	{PSIn SIn = TFIn::New(fnBin);
1176  	Load(*SIn);}
1177  	caseFolding.Test();
1178  	TestWbFindNonIgnored();
1179  	TestFindNextWordOrSentenceBoundary(basePath, true);
1180  	TestFindNextWordOrSentenceBoundary(basePath, false);
1181  	TestComposition(basePath);
1182  	TestCaseConversions();
1183  }
1184  const int TEncoding_ISO8859_2::toUnicodeTable[6 * 16] =
1185  {
1186  	 0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7, 0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
1187  	 0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7, 0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
1188  	 0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
1189  	 0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
1190  	 0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
1191  	 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
1192  };
1193  const int TEncoding_ISO8859_2::fromUnicodeTable1[14 * 16] = {
1194  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1,     -1,
1195  	 0x00b0,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1, 0x00b8,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1196  	     -1, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1197  	     -1,     -1,     -1, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1,     -1, 0x00da,     -1, 0x00dc, 0x00dd,     -1, 0x00df,
1198  	     -1, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1199  	     -1,     -1,     -1, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1,     -1, 0x00fa,     -1, 0x00fc, 0x00fd,     -1,     -1,
1200  	     -1,     -1, 0x00c3, 0x00e3, 0x00a1, 0x00b1, 0x00c6, 0x00e6,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8, 0x00cf, 0x00ef,
1201  	 0x00d0, 0x00f0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ca, 0x00ea, 0x00cc, 0x00ec,     -1,     -1,     -1,     -1,
1202  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1203  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5, 0x00e5,     -1,     -1, 0x00a5, 0x00b5,     -1,
1204  	     -1, 0x00a3, 0x00b3, 0x00d1, 0x00f1,     -1,     -1, 0x00d2, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1205  	 0x00d5, 0x00f5,     -1,     -1, 0x00c0, 0x00e0,     -1,     -1, 0x00d8, 0x00f8, 0x00a6, 0x00b6,     -1,     -1, 0x00aa, 0x00ba,
1206  	 0x00a9, 0x00b9, 0x00de, 0x00fe, 0x00ab, 0x00bb,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d9, 0x00f9,
1207  	 0x00db, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ac, 0x00bc, 0x00af, 0x00bf, 0x00ae, 0x00be,     -1
1208  };
1209  const int TEncoding_ISO8859_2::fromUnicodeTable2[2 * 16] = {
1210  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00b7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1211  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a2, 0x00ff,     -1, 0x00b2,     -1, 0x00bd,     -1,     -1
1212  };
1213  const int TEncoding_ISO8859_3::toUnicodeTable[6 * 16] = {
1214  	 0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4,     -1, 0x0124, 0x00a7, 0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad,     -1, 0x017b,
1215  	 0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7, 0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd,     -1, 0x017c,
1216  	 0x00c0, 0x00c1, 0x00c2,     -1, 0x00c4, 0x010a, 0x0108, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
1217  	     -1, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7, 0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,
1218  	 0x00e0, 0x00e1, 0x00e2,     -1, 0x00e4, 0x010b, 0x0109, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
1219  	     -1, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7, 0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9
1220  };
1221  const int TEncoding_ISO8859_3::fromUnicodeTable1[14 * 16] = {
1222  	 0x00a0,     -1,     -1, 0x00a3, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1,     -1,
1223  	 0x00b0,     -1, 0x00b2, 0x00b3, 0x00b4, 0x00b5,     -1, 0x00b7, 0x00b8,     -1,     -1,     -1,     -1, 0x00bd,     -1,     -1,
1224  	 0x00c0, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
1225  	     -1, 0x00d1, 0x00d2, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1, 0x00d9, 0x00da, 0x00db, 0x00dc,     -1,     -1, 0x00df,
1226  	 0x00e0, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
1227  	     -1, 0x00f1, 0x00f2, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1, 0x00f9, 0x00fa, 0x00fb, 0x00fc,     -1,     -1,     -1,
1228  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c6, 0x00e6, 0x00c5, 0x00e5,     -1,     -1,     -1,     -1,
1229  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d8, 0x00f8, 0x00ab, 0x00bb,
1230  	 0x00d5, 0x00f5,     -1,     -1, 0x00a6, 0x00b6, 0x00a1, 0x00b1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1231  	 0x00a9, 0x00b9,     -1,     -1, 0x00ac, 0x00bc,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1232  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1233  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00de, 0x00fe, 0x00aa, 0x00ba,
1234  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00dd, 0x00fd,     -1,     -1,
1235  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00af, 0x00bf,     -1,     -1,     -1,
1236  };
1237  const int TEncoding_ISO8859_3::fromUnicodeTable2[2] = {
1238  	 0x00a2, 0x00ff
1239  };
1240  const int TEncoding_ISO8859_4::toUnicodeTable[6 * 16] = {
1241  	 0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7, 0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af,
1242  	 0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7, 0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,
1243  	 0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,
1244  	 0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,
1245  	 0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,
1246  	 0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9
1247  };
1248  const int TEncoding_ISO8859_4::fromUnicodeTable1[14 * 16] = {
1249  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1, 0x00af,
1250  	 0x00b0,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1, 0x00b8,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1251  	     -1, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6,     -1,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1252  	     -1,     -1,     -1,     -1, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8,     -1, 0x00da, 0x00db, 0x00dc,     -1,     -1, 0x00df,
1253  	     -1, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6,     -1,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1254  	     -1,     -1,     -1,     -1, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8,     -1, 0x00fa, 0x00fb, 0x00fc,     -1,     -1,     -1,
1255  	 0x00c0, 0x00e0,     -1,     -1, 0x00a1, 0x00b1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8,     -1,     -1,
1256  	 0x00d0, 0x00f0, 0x00aa, 0x00ba,     -1,     -1, 0x00cc, 0x00ec, 0x00ca, 0x00ea,     -1,     -1,     -1,     -1,     -1,     -1,
1257  	     -1,     -1, 0x00ab, 0x00bb,     -1,     -1,     -1,     -1, 0x00a5, 0x00b5, 0x00cf, 0x00ef,     -1,     -1, 0x00c7, 0x00e7,
1258  	     -1,     -1,     -1,     -1,     -1,     -1, 0x00d3, 0x00f3, 0x00a2,     -1,     -1, 0x00a6, 0x00b6,     -1,     -1,     -1,
1259  	     -1,     -1,     -1,     -1,     -1, 0x00d1, 0x00f1,     -1,     -1,     -1, 0x00bd, 0x00bf, 0x00d2, 0x00f2,     -1,     -1,
1260  	     -1,     -1,     -1,     -1,     -1,     -1, 0x00a3, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1261  	 0x00a9, 0x00b9,     -1,     -1,     -1,     -1, 0x00ac, 0x00bc, 0x00dd, 0x00fd, 0x00de, 0x00fe,     -1,     -1,     -1,     -1,
1262  	     -1,     -1, 0x00d9, 0x00f9,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ae, 0x00be,     -1,
1263  };
1264  const int TEncoding_ISO8859_4::fromUnicodeTable2[2 * 16] = {
1265  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00b7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1266  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ff,     -1, 0x00b2,     -1,     -1,     -1,     -1
1267  };
1268  const int TEncoding_CP437::toUnicodeTable[8 * 16] = {
1269  	 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
1270  	 0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9, 0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
1271  	 0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
1272  	 0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
1273  	 0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f, 0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
1274  	 0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
1275  	 0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
1276  	 0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248, 0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
1277  };
1278  const int TEncoding_CP437::fromUnicodeTable1[6 * 16] = {
1279  	 0x00ff, 0x00ad, 0x009b, 0x009c,     -1, 0x009d,     -1,     -1,     -1,     -1, 0x00a6, 0x00ae, 0x00aa,     -1,     -1,     -1,
1280  	 0x00f8, 0x00f1, 0x00fd,     -1,     -1, 0x00e6,     -1, 0x00fa,     -1,     -1, 0x00a7, 0x00af, 0x00ac, 0x00ab,     -1, 0x00a8,
1281  	     -1,     -1,     -1,     -1, 0x008e, 0x008f, 0x0092, 0x0080,     -1, 0x0090,     -1,     -1,     -1,     -1,     -1,     -1,
1282  	     -1, 0x00a5,     -1,     -1,     -1,     -1, 0x0099,     -1,     -1,     -1,     -1,     -1, 0x009a,     -1,     -1, 0x00e1,
<span onclick='openModal()' class='match'>1283  	 0x0085, 0x00a0, 0x0083,     -1, 0x0084, 0x0086, 0x0091, 0x0087, 0x008a, 0x0082, 0x0088, 0x0089, 0x008d, 0x00a1, 0x008c, 0x008b,
1284  	     -1, 0x00a4, 0x0095, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1, 0x0097, 0x00a3, 0x0096, 0x0081,     -1,     -1, 0x0098,
</span>1285  };
1286  const int TEncoding_CP437::fromUnicodeTable2[4 * 16] = {
1287  	     -1,     -1,     -1, 0x00e2,     -1,     -1,     -1,     -1, 0x00e9,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1288  	     -1,     -1,     -1, 0x00e4,     -1,     -1, 0x00e8,     -1,     -1, 0x00ea,     -1,     -1,     -1,     -1,     -1,     -1,
1289  	     -1, 0x00e0,     -1,     -1, 0x00eb, 0x00ee,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1290  	 0x00e3,     -1,     -1, 0x00e5, 0x00e7,     -1, 0x00ed,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1291  };
1292  const int TEncoding_CP437::fromUnicodeTable3[6 * 16] = {
1293  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f9, 0x00fb,     -1,     -1,     -1, 0x00ec,     -1,
1294  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ef,     -1,     -1,     -1,     -1,     -1,     -1,
1295  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1296  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1297  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1298  	     -1, 0x00f0,     -1,     -1, 0x00f3, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1299  };
1300  const int TEncoding_CP437::fromUnicodeTable4[11 * 16] = {
1301  	 0x00c4,     -1, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00da,     -1,     -1,     -1,
1302  	 0x00bf,     -1,     -1,     -1, 0x00c0,     -1,     -1,     -1, 0x00d9,     -1,     -1,     -1, 0x00c3,     -1,     -1,     -1,
1303  	     -1,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c2,     -1,     -1,     -1,
1304  	     -1,     -1,     -1,     -1, 0x00c1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5,     -1,     -1,     -1,
1305  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1306  	 0x00cd, 0x00ba, 0x00d5, 0x00d6, 0x00c9, 0x00b8, 0x00b7, 0x00bb, 0x00d4, 0x00d3, 0x00c8, 0x00be, 0x00bd, 0x00bc, 0x00c6, 0x00c7,
1307  	 0x00cc, 0x00b5, 0x00b6, 0x00b9, 0x00d1, 0x00d2, 0x00cb, 0x00cf, 0x00d0, 0x00ca, 0x00d8, 0x00d7, 0x00ce,     -1,     -1,     -1,
1308  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1309  	 0x00df,     -1,     -1,     -1, 0x00dc,     -1,     -1,     -1, 0x00db,     -1,     -1,     -1, 0x00dd,     -1,     -1,     -1,
1310  	 0x00de, 0x00b0, 0x00b1, 0x00b2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1311  	 0x00fe,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1
1312  };
1313  const int TEncoding_CP852::toUnicodeTable[8 * 16] = {
1314  	 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x016f, 0x0107, 0x00e7, 0x0142, 0x00eb, 0x0150, 0x0151, 0x00ee, 0x0179, 0x00c4, 0x0106,
1315  	 0x00c9, 0x0139, 0x013a, 0x00f4, 0x00f6, 0x013d, 0x013e, 0x015a, 0x015b, 0x00d6, 0x00dc, 0x0164, 0x0165, 0x0141, 0x00d7, 0x010d,
1316  	 0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x0104, 0x0105, 0x017d, 0x017e, 0x0118, 0x0119, 0x00ac, 0x017a, 0x010c, 0x015f, 0x00ab, 0x00bb,
1317  	 0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1, 0x00c2, 0x011a, 0x015e, 0x2563, 0x2551, 0x2557, 0x255d, 0x017b, 0x017c, 0x2510,
1318  	 0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x0102, 0x0103, 0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x00a4,
1319  	 0x0111, 0x0110, 0x010e, 0x00cb, 0x010f, 0x0147, 0x00cd, 0x00ce, 0x011b, 0x2518, 0x250c, 0x2588, 0x2584, 0x0162, 0x016e, 0x2580,
1320  	 0x00d3, 0x00df, 0x00d4, 0x0143, 0x0144, 0x0148, 0x0160, 0x0161, 0x0154, 0x00da, 0x0155, 0x0170, 0x00fd, 0x00dd, 0x0163, 0x00b4,
1321  	 0x00ad, 0x02dd, 0x02db, 0x02c7, 0x02d8, 0x00a7, 0x00f7, 0x00b8, 0x00b0, 0x00a8, 0x02d9, 0x0171, 0x0158, 0x0159, 0x25a0, 0x00a0
1322  };
1323  const int TEncoding_CP852::fromUnicodeTable1[14 * 16] = {
1324  	 0x00ff,     -1,     -1,     -1, 0x00cf,     -1,     -1, 0x00f5, 0x00f9,     -1,     -1, 0x00ae, 0x00aa, 0x00f0,     -1,     -1,
1325  	 0x00f8,     -1,     -1,     -1, 0x00ef,     -1,     -1,     -1, 0x00f7,     -1,     -1, 0x00af,     -1,     -1,     -1,     -1,
1326  	     -1, 0x00b5, 0x00b6,     -1, 0x008e,     -1,     -1, 0x0080,     -1, 0x0090,     -1, 0x00d3,     -1, 0x00d6, 0x00d7,     -1,
1327  	     -1,     -1,     -1, 0x00e0, 0x00e2,     -1, 0x0099, 0x009e,     -1,     -1, 0x00e9,     -1, 0x009a, 0x00ed,     -1, 0x00e1,
1328  	     -1, 0x00a0, 0x0083,     -1, 0x0084,     -1,     -1, 0x0087,     -1, 0x0082,     -1, 0x0089,     -1, 0x00a1, 0x008c,     -1,
1329  	     -1,     -1,     -1, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1,     -1, 0x00a3,     -1, 0x0081, 0x00ec,     -1,     -1,
1330  	     -1,     -1, 0x00c6, 0x00c7, 0x00a4, 0x00a5, 0x008f, 0x0086,     -1,     -1,     -1,     -1, 0x00ac, 0x009f, 0x00d2, 0x00d4,
1331  	 0x00d1, 0x00d0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a8, 0x00a9, 0x00b7, 0x00d8,     -1,     -1,     -1,     -1,
1332  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1333  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x0091, 0x0092,     -1,     -1, 0x0095, 0x0096,     -1,
1334  	     -1, 0x009d, 0x0088, 0x00e3, 0x00e4,     -1,     -1, 0x00d5, 0x00e5,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1335  	 0x008a, 0x008b,     -1,     -1, 0x00e8, 0x00ea,     -1,     -1, 0x00fc, 0x00fd, 0x0097, 0x0098,     -1,     -1, 0x00b8, 0x00ad,
1336  	 0x00e6, 0x00e7, 0x00dd, 0x00ee, 0x009b, 0x009c,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00de, 0x0085,
1337  	 0x00eb, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008d, 0x00ab, 0x00bd, 0x00be, 0x00a6, 0x00a7,     -1
1338  };
1339  const int TEncoding_CP852::fromUnicodeTable2[2* 16] = {
1340  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1341  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f4, 0x00fa,     -1, 0x00f2,     -1, 0x00f1,     -1,     -1
1342  };
1343  const int TEncoding_CP852::fromUnicodeTable3[11 * 16] = {
1344  	 0x00c4,     -1, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00da,     -1,     -1,     -1,
1345  	 0x00bf,     -1,     -1,     -1, 0x00c0,     -1,     -1,     -1, 0x00d9,     -1,     -1,     -1, 0x00c3,     -1,     -1,     -1,
1346  	     -1,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c2,     -1,     -1,     -1,
1347  	     -1,     -1,     -1,     -1, 0x00c1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5,     -1,     -1,     -1,
1348  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1349  	 0x00cd, 0x00ba,     -1,     -1, 0x00c9,     -1,     -1, 0x00bb,     -1,     -1, 0x00c8,     -1,     -1, 0x00bc,     -1,     -1,
1350  	 0x00cc,     -1,     -1, 0x00b9,     -1,     -1, 0x00cb,     -1,     -1, 0x00ca,     -1,     -1, 0x00ce,     -1,     -1,     -1,
1351  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1352  	 0x00df,     -1,     -1,     -1, 0x00dc,     -1,     -1,     -1, 0x00db,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1353  	     -1, 0x00b0, 0x00b1, 0x00b2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1354  	 0x00fe,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1
1355  };
1356  const int TEncoding_CP1250::toUnicodeTable[8 * 16] = {
1357  	 0x20ac,     -1, 0x201a,     -1, 0x201e, 0x2026, 0x2020, 0x2021,     -1, 0x2030, 0x0160, 0x2039, 0x015a, 0x0164, 0x017d, 0x0179,
1358  	     -1, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,     -1, 0x2122, 0x0161, 0x203a, 0x015b, 0x0165, 0x017e, 0x017a,
1359  	 0x00a0, 0x02c7, 0x02d8, 0x0141, 0x00a4, 0x0104, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x015e, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x017b,
1360  	 0x00b0, 0x00b1, 0x02db, 0x0142, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x0105, 0x015f, 0x00bb, 0x013d, 0x02dd, 0x013e, 0x017c,
1361  	 0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
1362  	 0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
1363  	 0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
1364  	 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
1365  };
1366  const int TEncoding_CP1250::fromUnicodeTable1[14 * 16] = {
1367  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1, 0x00a6, 0x00a7, 0x00a8, 0x00a9,     -1, 0x00ab, 0x00ac, 0x00ad, 0x00ae,     -1,
1368  	 0x00b0, 0x00b1,     -1,     -1, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8,     -1,     -1, 0x00bb,     -1,     -1,     -1,     -1,
1369  	     -1, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1370  	     -1,     -1,     -1, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1,     -1, 0x00da,     -1, 0x00dc, 0x00dd,     -1, 0x00df,
1371  	     -1, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1372  	     -1,     -1,     -1, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1,     -1, 0x00fa,     -1, 0x00fc, 0x00fd,     -1,     -1,
1373  	     -1,     -1, 0x00c3, 0x00e3, 0x00a5, 0x00b9, 0x00c6, 0x00e6,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8, 0x00cf, 0x00ef,
1374  	 0x00d0, 0x00f0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ca, 0x00ea, 0x00cc, 0x00ec,     -1,     -1,     -1,     -1,
1375  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1376  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5, 0x00e5,     -1,     -1, 0x00bc, 0x00be,     -1,
1377  	     -1, 0x00a3, 0x00b3, 0x00d1, 0x00f1,     -1,     -1, 0x00d2, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1378  	 0x00d5, 0x00f5,     -1,     -1, 0x00c0, 0x00e0,     -1,     -1, 0x00d8, 0x00f8, 0x008c, 0x009c,     -1,     -1, 0x00aa, 0x00ba,
1379  	 0x008a, 0x009a, 0x00de, 0x00fe, 0x008d, 0x009d,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d9, 0x00f9,
1380  	 0x00db, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008f, 0x009f, 0x00af, 0x00bf, 0x008e, 0x009e,     -1,
1381  };
1382  const int TEncoding_CP1250::fromUnicodeTable2[2 * 16] = {
1383  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1384  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a2, 0x00ff,     -1, 0x00b2,     -1, 0x00bd,     -1,     -1,
1385  };
1386  const int TEncoding_CP1250::fromUnicodeTable3[3 * 16] = {
1387  	     -1,     -1,     -1, 0x0096, 0x0097,     -1,     -1,     -1, 0x0091, 0x0092, 0x0082,     -1, 0x0093, 0x0094, 0x0084,     -1,
1388  	 0x0086, 0x0087, 0x0095,     -1,     -1,     -1, 0x0085,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1389  	 0x0089,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008b, 0x009b,     -1,     -1,     -1,     -1,     -1,
1390  };
1391  const int TEncoding_YuAscii::uniChars[10] =     {  0x106,  0x107,  0x10c,  0x10d,  0x160,  0x161,  0x17d,  0x17e,   0x110,  0x111  };
1392  const int TEncoding_YuAscii::yuAsciiChars[10] = {   0x5d,   0x7d,   0x5e,   0x7e,   0x5b,   0x7b,   0x40,   0x60,    0x5c,   0x7c  };
1393  void TUnicode::InitCodecs()
1394  {
1395  	ClrCodecs();
1396  	RegisterCodec("ISO-8859-1 ISO_8859-1 ISO_8859-1:1987 ISO-IR-100 CP819 IBM819 LATIN1 L1 csISOLatin1 ISO8859-1 ISO8859_1 CP28591", TCodecBase::New<TCodec_ISO8859_1>());
1397  	RegisterCodec("ISO-8859-2 ISO_8859-2 ISO_8859-2:1987 ISO-IR-101 LATIN2 L2 csISOLatin2 ISO8859-2 ISO8859_2 CP28592", TCodecBase::New<TCodec_ISO8859_2>());
1398  	RegisterCodec("ISO-8859-3 ISO_8859-3 ISO_8859-3:1988 ISO-IR-109 LATIN3 L3 csISOLatin3 ISO8859-3 ISO8859_3 CP28593", TCodecBase::New<TCodec_ISO8859_3>());
1399  	RegisterCodec("ISO-8859-4 ISO_8859-4 ISO_8859-4:1988 ISO-IR-110 LATIN4 L4 csISOLatin4 ISO8859-4 ISO8859_4 CP28594", TCodecBase::New<TCodec_ISO8859_4>());
1400  	RegisterCodec("YUASCII YU-ASCII YU_ASCII", TCodecBase::New<TCodec_YuAscii>());
1401  	RegisterCodec("CP1250 Windows-1250 MS-EE", TCodecBase::New<TCodec_CP1250>());
1402  	RegisterCodec("CP852 cp852_DOSLatin2 DOSLatin2", TCodecBase::New<TCodec_CP852>());
1403  	RegisterCodec("CP437 cp437_DOSLatinUS DOSLatinUS", TCodecBase::New<TCodec_CP437>());
1404  }
1405  void TUnicode::EncodeUtf8(const uint& c, TChA& dest) {
1406  	if (c > 0x10ffff) {
1407  		throw TExcept::New(TStr::Fmt("Unkown Unicode character %u", c)); }
1408  	if (c < 0x80u)
1409  		dest.AddCh(char(c & 0xffu));
1410  	else if (c < 0x800u) {
1411  		dest.AddCh(char(TUniCodec::_1100_0000 | ((c >> 6) & TUniCodec::_0001_1111)));
1412  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1413  	else if (c < 0x10000u) {
1414  		dest.AddCh(char(TUniCodec::_1110_0000 | ((c >> 12) & TUniCodec::_0000_1111)));
1415  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1416  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1417  	else if (c < 0x200000u) {
1418  		dest.AddCh(char(TUniCodec::_1111_0000 | ((c >> 18) & TUniCodec::_0000_0111)));
1419  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1420  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1421  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1422  	else if (c < 0x4000000u) {
1423  		dest.AddCh(char(TUniCodec::_1111_1000 | ((c >> 24) & TUniCodec::_0000_0011)));
1424  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 18) & TUniCodec::_0011_1111)));
1425  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1426  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1427  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1428  	else {
1429  		dest.AddCh(char(TUniCodec::_1111_1100 | ((c >> 30) & TUniCodec::_0000_0011)));
1430  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 24) & TUniCodec::_0011_1111)));
1431  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 18) & TUniCodec::_0011_1111)));
1432  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1433  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1434  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1435  }
1436  TStr TUnicode::EncodeUtf8(const uint& Ch) {
1437  	TChA ChA; EncodeUtf8(Ch, ChA); return ChA;
1438  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.cpp</h3>
            <pre><code>1  namespace {
2  class TVectorBuilder2
3  {
4  public:
5  	TIntV v;
6  	TVectorBuilder2(int i) { v.Add(i); }
7  	operator TIntV() const { return v; }
8  	TVectorBuilder2& operator ,(int i) { v.Add(i); return *this; }
9  };
10  class TVectorBuilder
11  {
12  public:
13  	operator TIntV() const { return TIntV(); }
14  	TVectorBuilder2 operator ,(int i) { return TVectorBuilder2(i); }
15  };
16  TVectorBuilder VB;
17  TStr CombinePath(const TStr& s, const TStr& t)
18  {
19  	int n = s.Len(); if (n <= 0) return t;
20  	if (s[n - 1] == '\\' || s[n - 1] == '/' || s[n - 1] == ':') return s + t;
21  	return s + "\\" + t;
22  }
23  void AssertEq(const TIntV& v1, const TIntV& v2, const TStr& explanation, FILE *f)
24  {
25  	const int n = v1.Len();
26  	bool ok = (n == v2.Len());
27  	if (ok) for (int i = 0; i < n && ok; i++) ok = ok && (v1[i] == v2[i]);
28  	if (! ok)
29  	{
30  		if (! f) f = stderr;
31  		fprintf(f, "%s: [", explanation.CStr());
32  		for (int i = 0; i < v1.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(v1[i]));
33  		fprintf(f, "] != [");
34  		for (int i = 0; i < v2.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(v2[i]));
35  		fprintf(f, "]\n");
36  		Fail;
37  	}
38  }
39  };
40  uint TUniCodec::GetRndUint(TRnd& rnd)
41  {
42  	uint u = rnd.GetUniDevUInt(256) & 0xff;
43  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
44  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
45  	u <<= 8; u |= (rnd.GetUniDevUInt(256) & 0xff);
46  	return u;
47  }
48  uint TUniCodec::GetRndUint(TRnd& rnd, uint minVal, uint maxVal)
49  {
50  	if (minVal == TUInt::Mn && maxVal == TUInt::Mx) return GetRndUint(rnd);
51  	uint range = maxVal - minVal + 1;
52  	if (range > (uint(1) << (8 * sizeof(uint) - 1)))
53  		while (true) { uint u = GetRndUint(rnd); if (u < range) return minVal + u; }
54  	uint mask = 1;
55  	while (mask < range) mask <<= 1;
56  	mask -= 1;
57  	while (true) { uint u = GetRndUint(rnd) & mask; if (u < range) return minVal + u; }
58  }
59  bool TUniCodec::IsMachineLittleEndian()
60  {
61  	static bool isLE, initialized = false;
62  	if (initialized) return isLE;
63  	int i = 1;
64  	if(*(char *)&i == 1) isLE = true;
65  	else isLE = false;
66  	initialized = true;
67  	return isLE;
68  }
69  void TUniCodec::TestUtf8(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest, FILE *f)
70  {
71  	TIntV dest;
72  	if (f) {
73  		fprintf(f, "Settings: %s  %s  %s   replacementChar = %x\n",
74  			(errorHandling == uehAbort ? "abort" : errorHandling == uehThrow ? "throw" : errorHandling == uehIgnore ? "ignore" : errorHandling == uehReplace ? "replace" : "????"),
75  			(strict ? "STRICT" : ""), (skipBom ? "skipBom" : ""), uint(replacementChar));
76  		fprintf(f, "src: "); for (int i = 0; i < src.Len(); i++) fprintf(f, (decode ? " %02x" : " %x"), uint(src[i])); }
77  	try
78  	{
79  		size_t retVal = (decode ? DecodeUtf8(src, 0, src.Len(), dest, true) : EncodeUtf8(src, 0, src.Len(), dest, true));
80  		if (f) {
81  			fprintf(f, "\n -> dest:    "); for (int i = 0; i < dest.Len(); i++) fprintf(f, (decode ? " %x" :  " %02x"), uint(dest[i]));
82  			fprintf(f, "\n    expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, (decode ? " %x" :  " %02x"), uint(expectedDest[i]));
83  			fprintf(f, "\n    retVal = %llu (expected %llu)\n", static_cast<long long unsigned int> (retVal), static_cast<long long unsigned int> (expectedRetVal)); }
84  		if (retVal != expectedRetVal)
85  			printf("!!!");
86  		IAssert(retVal == expectedRetVal); IAssert(! expectedThrow);
87  		if (dest.Len() != expectedDest.Len())
88  			printf("!!!");
89  		IAssert(dest.Len() == expectedDest.Len());
90  		for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == expectedDest[i]);
91  	}
92  	catch (TUnicodeException e)
93  	{
94  		if (f) {
95  			fprintf(f, "\n -> expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, " %x", uint(expectedDest[i]));
96  			fprintf(f, "\n    exception \"%s\" at %d (char 0x%02x)\n", e.message.CStr(), int(e.srcIdx), uint(e.srcChar)); }
97  		IAssert(expectedThrow);
98  	}
99  }
100  void TUniCodec::TestDecodeUtf8(TRnd& rnd, const TStr& testCaseDesc)
101  {
102  	TIntV src; TIntV expectedDest; int expectedRetVal = 0;
103  	bool expectedAbort = false;
104  	FILE *f = 0; 
105  	for (int i = 0; i < testCaseDesc.Len(); )
106  	{
107  		IAssert(i + 2 <= testCaseDesc.Len());
108  		const char c = testCaseDesc[i], d = testCaseDesc[i + 1]; i += 2;
109  		uint cp = 0; int nBytes = -1, minBytes = -1; bool eighties = false;
110  		IAssert('1' <= d && d <= '6'); nBytes = d - '0';
111  		if (c == 'A') { cp = GetRndUint(rnd, 0u, 0x7fu); minBytes = 1; } 
112  		else if (c == 'B') { cp = GetRndUint(rnd, 0x80u, 0x7ffu); minBytes = 2; } 
113  		else if (c == 'C') { cp = GetRndUint(rnd, 0x800u, 0xffffu); minBytes = 3; } 
114  		else if (c == 'D') { cp = GetRndUint(rnd, 0x10000u, 0x10ffffu); minBytes = 4; } 
115  		else if (c == 'E') { cp = GetRndUint(rnd, 0x110000u, 0x1fffffu); minBytes = 4; } 
116  		else if (c == 'F') { cp = GetRndUint(rnd, 0x200000u, 0x3ffffffu); minBytes = 5; } 
117  		else if (c == 'G') { cp = GetRndUint(rnd, 0x4000000u, 0x7fffffffu); minBytes = 6; } 
118  		else if (c == 'H') { cp = GetRndUint(rnd, 0x80000000u, 0xffffffffu); minBytes = 6; } 
119  		else if (c == 'X') { cp = 0xfffe; minBytes = 3; }
120  		else if (c == 'Y') { cp = 0xfeff; minBytes = 3; }
121  		else if (c == 'Z') { eighties = true; minBytes = 1; } 
122  		else Fail;
123  		IAssert(nBytes >= minBytes);
124  		int nToDel = 0;
125  		if (i < testCaseDesc.Len()) {
126  			const char e = testCaseDesc[i];
127  			if (e >= 'a' && e <= 'e') { i += 1; nToDel = e - 'a' + 1; }}
128  		IAssert(nToDel < nBytes);
129  		bool errHere = false;
130  		if (eighties) errHere = true;
131  		else if (nToDel > 0) errHere = true;
132  		else if (strict && (cp >= 0x10ffff || nBytes > minBytes)) errHere = true;
133  		if (! expectedAbort) {
134  			if (! errHere) {
135  				if (src.Len() == 0 && (cp == 0xfffe || cp == 0xfeff) && skipBom) { }
136  				else { expectedDest.Add(cp); expectedRetVal += 1; } }
137  			else if (errorHandling == uehReplace) {
138  				if (eighties) for (int j = 0; j < nBytes; j++) expectedDest.Add(replacementChar);
139  				else expectedDest.Add(replacementChar); }
140  			if (errHere && (errorHandling == uehAbort || errorHandling == uehThrow)) expectedAbort = true; }
141  		if (eighties) for (int j = 0; j < nBytes; j++) src.Add(GetRndUint(rnd, 0x80, 0xff));
142  		else if (nBytes == 1) src.Add(cp);
143  		else {
144  			int mask = (1 << nBytes) - 1; mask <<= (8 - nBytes);
145  			src.Add(mask | (uint(cp) >> (6 * (nBytes - 1))));
146  			for (int j = 1; j < nBytes - nToDel; j++) src.Add(0x80 | ((cp >> (6 * (nBytes - j - 1))) & _0011_1111)); }
147  	}
148  	if (f) fprintf(f, "Test case: \"%s\"\n", testCaseDesc.CStr());
149  	TestUtf8(true, expectedRetVal, expectedAbort && (errorHandling == uehThrow), src, expectedDest, f);
150  }
151  void TUniCodec::TestUtf8()
152  {
153  	TIntV utf8ReplCh; EncodeUtf8((TVectorBuilder(), replacementChar).v, 0, 1, utf8ReplCh, true);
154  	for (int skipBom_ = 0; skipBom_ < 2; skipBom_++)
155  	for (int strict_ = 0; strict_ < 2; strict_++)
156  	for (int errMode_ = 0; errMode_ < 4; errMode_++)
157  	{
158  		strict = (strict_ == 1); errorHandling = TUnicodeErrorHandling(errMode_); skipBom = (skipBom_ == 1);
159  		TRnd rnd = TRnd(123);
160  		for (int i = 0; i < 10; i++)
161  		{
162  			TestDecodeUtf8(rnd, "X3A1A2A3A4A5A6B2B3B4B5B6C3C4C5C6D4D5D6E5E6F6G6");
163  			TestDecodeUtf8(rnd, "X3A5dA6d");
164  			TestDecodeUtf8(rnd, "X3A1B2C3D4E4F5A1G6H6Y3X3A1");
165  			TestDecodeUtf8(rnd, "X3A1B2C3D4E4F5A2G6H6Y3X3A1");
166  			TestDecodeUtf8(rnd, "Y3A1B2C3D4E4F5A1G6H6Y3X3A1");
167  			TestDecodeUtf8(rnd, "A1B2C3D4E4F5A1G6H6Y3X3A1");
168  			TestDecodeUtf8(rnd, "G6A1A1D4E4A1B2");
169  			TestDecodeUtf8(rnd, "D4A1A1C3A1B2A1B2");
170  			TestDecodeUtf8(rnd, "D4A1A1C3A1B2A1B2D4a");
171  			TestDecodeUtf8(rnd, "X3A1B2C3D5E4F5A1G6H6Y3X3A1");
172  			TestDecodeUtf8(rnd, "X3A1B2C3D4E5F5A1G6H6Y3X3A1");
173  			TestDecodeUtf8(rnd, "X3A1B2C3D4aE4F5A1G6H6Y3X3A1");
174  			TestDecodeUtf8(rnd, "X3A1B2C3D4bE4F5A1G6H6Y3X3A1");
175  			TestDecodeUtf8(rnd, "X3A2aA3aA4aA5aA6aB2aB3aB4aB5aB6aC3aC4aC5aC6aD4aD5aD6aE5aE6aF6aG6a");
176  			TestDecodeUtf8(rnd, "X3A3bA4bA5bA6aB3bB4bB5bB6bC3bC4bC5bC6bD4bD5bD6bE5bE6bF6bG6b");
177  			TestDecodeUtf8(rnd, "X3A4cA5cA6cB4cB5cB6cC4cC5cC6cD4cD5cD6cE5cE6cF6cG6c");
178  			TestDecodeUtf8(rnd, "X3A5dA6dB5dB6dC5dC6dD5dD6dE5dE6dF6dG6d");
179  			TestDecodeUtf8(rnd, "X3A6eB6eC6eD6eE6eF6eG6e");
180  		}
181  		TIntV src, expectedDest, src2;
182  		expectedDest.Gen(1); src.Reserve(6); src2.Gen(1);
183  		for (int pow = 8; pow <= 32; pow++)
184  		{
185  			uint uFrom, uTo;
186  			if (pow == 8) uFrom = 0, uTo = 1u << pow;
187  			else if (pow == 32) uFrom = TUInt::Mx - (1u << 8), uTo = TUInt::Mx;
188  			else uFrom = (1u << pow) - (1u << 8), uTo = (1u << pow) + (1u << 8);
189  			printf("%u..%u          \r", uFrom, uTo);
190  			for (uint u = uFrom; ; u++)
191  			{
192  				int nBytes = 0;
193  				if (u < (1u << 7)) nBytes = 1;
194  				else if (u < (1u << 11)) nBytes = 2;
195  				else if (u < (1u << 16)) nBytes = 3;
196  				else if (u < (1u << 21)) nBytes = 4;
197  				else if (u < (1u << 26)) nBytes = 5;
198  				else nBytes = 6;
199  				src.Gen(6, nBytes);
200  				if (nBytes == 1) src[0] = u;
201  				else {
202  					src[0] = (((1 << nBytes) - 1) << (8 - nBytes)) | (u >> (6 * (nBytes - 1)));
203  					for (int i = 1; i < nBytes; i++) src[i] = 0x80 | ((u >> (6 * (nBytes - i - 1))) & _0011_1111); }
204  				bool err = (strict && u > 0x10ffff);
205  				expectedDest.Reserve(1, 0);
206  				if (err && errorHandling == uehReplace) expectedDest.Add(replacementChar);
207  				else if (! err) expectedDest.Add(u);
208  				int erv = (err ? 0 : 1);
209  				if (skipBom && (u == 0xfeff || u == 0xfffe)) expectedDest.Clr(), erv = 0;
210  				TestUtf8(true, erv, (err && errorHandling == uehThrow), src, expectedDest, 0);
211  				src2[0] = u;
212  				if (err) {
213  					if (errorHandling == uehReplace) src = utf8ReplCh;
214  					else src.Clr(false); }
215  				TestUtf8(false, (err ? 0 : 1), (err && errorHandling == uehThrow), src2, src, 0);
216  				if (u == uTo) break;
217  			}
218  		}
219  	}
220  }
221  void TUniCodec::WordsToBytes(const TIntV& src, TIntV& dest)
222  {
223  	dest.Clr();
224  	bool isLE = IsMachineLittleEndian();
225  	for (int i = 0; i < src.Len(); i++) {
226  		int c = src[i] & 0xffff;
227  		if (isLE) { dest.Add(c & 0xff); dest.Add((c >> 8) & 0xff); }
228  		else { dest.Add((c >> 8) & 0xff); dest.Add(c & 0xff); } }
229  }
230  void TUniCodec::TestUtf16(bool decode, size_t expectedRetVal, bool expectedThrow, const TIntV& src, const TIntV& expectedDest,
231  	const TUtf16BomHandling bomHandling, const TUniByteOrder defaultByteOrder, const bool insertBom,
232  	FILE *f)
233  {
234  	TIntV srcBytes, expectedDestBytes;
235  	WordsToBytes(src, srcBytes); WordsToBytes(expectedDest, expectedDestBytes);
236  	TIntV dest;
237  	if (f) {
238  		fprintf(f, "Settings: %s  %s  %s  %s  %s replacementChar = %x  \n",
239  			(errorHandling == uehAbort ? "abort" : errorHandling == uehThrow ? "throw" : errorHandling == uehIgnore ? "ignore" : errorHandling == uehReplace ? "replace" : "????"),
240  			(strict ? "STRICT" : ""), (decode ? (skipBom ? "skipBom" : "") : (insertBom ? "insrtBom" : "")),
241  			(bomHandling == bomAllowed ? "bomAllowed" : bomHandling == bomRequired ? "bomRequired" : "bomIgnored"),
242  			(defaultByteOrder == boBigEndian ? "boBigEndian" : defaultByteOrder == boLittleEndian ? "boLittleEndian" : "boMachineEndian"),
243  			uint(replacementChar));
244  		fprintf(f, "src: "); for (int i = 0; i < src.Len(); i++) fprintf(f, (decode ? " %04x" : " %x"), uint(src[i])); }
245  	for (int useBytes = 0; useBytes < 2; useBytes++)
246  	{
247  		const char *fmt = (useBytes ? " %02x" : " %04x");
248  		try
249  		{
250  			dest.Clr();
251  			size_t retVal;
252  			if (! useBytes) {
253  				if (decode) retVal = DecodeUtf16FromWords(src, 0, src.Len(), dest, true, bomHandling, defaultByteOrder);
254  				else retVal = EncodeUtf16ToWords(src, 0, src.Len(), dest, true, insertBom, defaultByteOrder); }
255  			else {
256  				if (decode) retVal = DecodeUtf16FromBytes(srcBytes, 0, srcBytes.Len(), dest, true, bomHandling, defaultByteOrder);
257  				else retVal = EncodeUtf16ToBytes(src, 0, src.Len(), dest, true, insertBom, defaultByteOrder); }
258  			const TIntV& ed = (useBytes && ! decode ? expectedDestBytes : expectedDest);
259  			if (f) {
260  				fprintf(f, "\n -> dest:    "); for (int i = 0; i < dest.Len(); i++) fprintf(f, (decode ? " %x" :  fmt), uint(dest[i]));
261  				fprintf(f, "\n    expDest  "); for (int i = 0; i < ed.Len(); i++) fprintf(f, (decode ? " %x" :  fmt), uint(ed[i]));
262  				fprintf(f, "\n    retVal = %llu (expected %llu)\n", static_cast<long long unsigned int> (retVal), static_cast<long long unsigned int> (expectedRetVal)); }
263  			bool ok = true;
264  			if (retVal != expectedRetVal) ok = false;
265  			if (dest.Len() != ed.Len()) ok = false;
266  			if (ok) for (int i = 0; i < dest.Len(); i++) if (dest[i] != ed[i]) ok = false;
267  			if (! ok)
268  			{
269  				printf("!!!\n");
270  			}
271  			IAssert(retVal == expectedRetVal); IAssert(! expectedThrow);
272  			IAssert(dest.Len() == ed.Len());
273  			for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == ed[i]);
274  		}
275  		catch (TUnicodeException e)
276  		{
277  			if (f) {
278  				fprintf(f, "\n -> expDest  "); for (int i = 0; i < expectedDest.Len(); i++) fprintf(f, (decode ? " %x" : fmt), uint(expectedDest[i]));
279  				fprintf(f, "\n    exception \"%s\" at %d (char 0x%02x)\n", e.message.CStr(), int(e.srcIdx), uint(e.srcChar)); }
280  			IAssert(expectedThrow);
281  		}
282  	}
283  }
284  void TUniCodec::TestDecodeUtf16(TRnd& rnd, const TStr& testCaseDesc,
285  	const TUtf16BomHandling bomHandling,
286  	const TUniByteOrder defaultByteOrder,
287  	const bool insertBom)
288  {
289  	TIntV src; TIntV expectedDest; int expectedRetVal = 0;
290  	bool expectedAbort = false;
291  	FILE *f = 0;
292  	bool isMachineLe = IsMachineLittleEndian();
293  	bool isDefaultLe = (defaultByteOrder == boLittleEndian || (defaultByteOrder == boMachineEndian && isMachineLe));
294  	bool swap = (isMachineLe != isDefaultLe);
295  	if (insertBom) {
296  		src.Add(swap ? 0xfffe : 0xfeff);
297  		if (! skipBom) { expectedRetVal += 1; expectedDest.Add(0xfeff); } }
298  	else if (bomHandling == bomRequired) {
299  		expectedAbort = true; expectedRetVal = -1; }
300  	for (int i = 0; i < testCaseDesc.Len(); )
301  	{
302  		const char c = testCaseDesc[i++];
303  		uint cp = 0; int nWords = -1;
304  		if (c == 'X' || c == 'Y') IAssert(i > 1); 
305  		if (c == 'A') { cp = GetRndUint(rnd, 0u, Utf16FirstSurrogate - 1); nWords = 1; } 
306  		else if (c == 'B') { cp = GetRndUint(rnd, Utf16FirstSurrogate, Utf16FirstSurrogate + 1023); nWords = 1; } 
307  		else if (c == 'C') { cp = GetRndUint(rnd, Utf16SecondSurrogate, Utf16SecondSurrogate + 1023); nWords = 1; } 
308  		else if (c == 'D') { do { cp = GetRndUint(rnd, Utf16SecondSurrogate + 1024, 0xffffu); } while (cp == 0xfffe || cp == 0xfeff); nWords = 1; } 
309  		else if (c == 'E') { cp = GetRndUint(rnd, 0x10000u, 0x10ffffu); nWords = 2; } 
310  		else if (c == 'X') { cp = 0xfffe; nWords = 1; }
311  		else if (c == 'Y') { cp = 0xfeff; nWords = 1; }
312  		else Fail;
313  		if (c == 'B' && i < testCaseDesc.Len()) IAssert(testCaseDesc[i] != 'C');
314  		int nToDel = 0;
315  		if (i < testCaseDesc.Len()) {
316  			const char e = testCaseDesc[i];
317  			if (e >= 'a') { i += 1; nToDel = 1; }}
318  		IAssert((nWords == 1 && nToDel == 0) || (nWords == 2 && (nToDel == 0 || nToDel == 1)));
319  		if (nWords == 2 && nToDel == 1 && i < testCaseDesc.Len()) IAssert(testCaseDesc[i] != 'C');
320  		bool errHere = false;
321  		if (Utf16FirstSurrogate <= cp && cp <= Utf16FirstSurrogate + 1023) errHere = true;
322  		else if (cp > 0x10ffff) { Fail; errHere = true; }
323  		else if (nToDel > 0) errHere = true;
324  		else if (strict && (Utf16SecondSurrogate <= cp && cp <= Utf16SecondSurrogate + 1023)) errHere = true;
325  		if (! expectedAbort) {
326  			if (! errHere) {
327  				if (src.Len() == 0 && (cp == 0xfffe || cp == 0xfeff) && skipBom) { }
328  				else { expectedDest.Add(cp); expectedRetVal += 1; } }
329  			else if (errorHandling == uehReplace) {
330  				expectedDest.Add(replacementChar); }
331  			if (errHere && (errorHandling == uehAbort || errorHandling == uehThrow)) expectedAbort = true; }
332  		if (nWords == 1) src.Add(swap ? SwapBytes(cp) : cp);
333  		else {
334  			int c1 = ((cp - 0x10000) >> 10) & 1023; c1 += Utf16FirstSurrogate;
335  			int c2 = (cp - 0x10000) & 1023; c2 += Utf16SecondSurrogate;
336  			src.Add(swap ? SwapBytes(c1) : c1);
337  			if (nToDel == 0) src.Add(swap ? SwapBytes(c2) : c2); }
338  	}
339  	if (f) fprintf(f, "Test case: \"%s\"\n", testCaseDesc.CStr());
340  	TestUtf16(true, expectedRetVal, expectedAbort && (errorHandling == uehThrow), src, expectedDest, bomHandling, defaultByteOrder, false, f);
341  }
342  void TUniCodec::TestUtf16()
343  {
344  	TIntV utf16ReplCh; utf16ReplCh.Add(replacementChar);
345  	for (int skipBom_ = 0; skipBom_ < 2; skipBom_++)
346  	for (int strict_ = 0; strict_ < 2; strict_++)
347  	for (int errMode_ = 0; errMode_ < 4; errMode_++)
348  	for (int bomHandling_ = 0; bomHandling_ < 3; bomHandling_++)
349  	for (int byteOrder_ = 0; byteOrder_ < 3; byteOrder_++)
350  	for (int insertBom_ = 0; insertBom_ < 2; insertBom_++)
351  	{
352  		strict = (strict_ == 1); errorHandling = TUnicodeErrorHandling(errMode_); skipBom = (skipBom_ == 1);
353  		bool insertBom = (insertBom_ == 1);
354  		TUniByteOrder byteOrder = (TUniByteOrder) byteOrder_;
355  		TUtf16BomHandling bomHandling = (TUtf16BomHandling) bomHandling_;
356  		TRnd rnd = TRnd(123);
357  		for (int i = 0; i < 10; i++)
358  		{
359  			TestDecodeUtf16(rnd, "A", bomHandling, byteOrder, insertBom);
360  			TestDecodeUtf16(rnd, "AAA", bomHandling, byteOrder, insertBom);
361  			TestDecodeUtf16(rnd, "B", bomHandling, byteOrder, insertBom);
362  			TestDecodeUtf16(rnd, "DDAADADAAADDDAA", bomHandling, byteOrder, insertBom);
363  			TestDecodeUtf16(rnd, "DEEEDAAEEDADEEAAEEADEEDDAA", bomHandling, byteOrder, insertBom);
364  			TestDecodeUtf16(rnd, "DEaEaEDAAEaEDADEaEAAEEADEEDDAA", bomHandling, byteOrder, insertBom);
365  			TestDecodeUtf16(rnd, "CABDEBACCEaB", bomHandling, byteOrder, insertBom);
366  			TestDecodeUtf16(rnd, "EaEEEEaBBACABXABYXXEaYDDXBDCEA", bomHandling, byteOrder, insertBom);
367  			TestDecodeUtf16(rnd, "EaEEEEaBDCAAXADYXXEaYDDXDCEA", bomHandling, byteOrder, insertBom);
368  		}
369  		TIntV src, expectedDest, src2;
370  		expectedDest.Gen(1); src.Reserve(6); src2.Gen(1);
371  		for (int pow = 8; pow <= 32; pow++)
372  		{
373  			uint uFrom, uTo;
374  			if (pow == 8) uFrom = 0, uTo = 1u << pow;
375  			else if (pow == 32) uFrom = TUInt::Mx - (1u << 8), uTo = TUInt::Mx;
376  			else uFrom = (1u << pow) - (1u << 8), uTo = (1u << pow) + (1u << 8);
377  			printf("%u..%u          \r", uFrom, uTo);
378  			for (uint u = uFrom; ; u++)
379  			{
380  				int nWords = 0;
381  				if (u < 0x10000) nWords = 1;
382  				else nWords = 2;
383  				bool isMachineLe = IsMachineLittleEndian(), isDestLe = (byteOrder == boLittleEndian || (byteOrder == boMachineEndian && isMachineLe));
384  				bool swap = (isMachineLe != isDestLe);
385  				bool err = (u > 0x10ffff) || (Utf16FirstSurrogate <= u && u <= Utf16FirstSurrogate + 1023) || (strict && Utf16SecondSurrogate <= u && u <= Utf16SecondSurrogate + 1023);
386  				src.Gen(3, (err ? 0 : nWords) + (insertBom ? 1 : 0));
387  				if (insertBom) src[0] = (swap ? 0xfffe : 0xfeff);
388  				if (! ((u > 0x10ffff) || (Utf16FirstSurrogate <= u && u <= Utf16FirstSurrogate + 1023)))
389  				{
390  					if (nWords == 1) src[insertBom ? 1 : 0] = (swap ? SwapBytes(u) : u);
391  					else {
392  						int u1 = Utf16FirstSurrogate + (((u - 0x10000) >> 10) & 1023);
393  						int u2 = Utf16SecondSurrogate + ((u - 0x10000) & 1023);
394  						src[insertBom ? 1 : 0] = (swap ? SwapBytes(u1) : u1);
395  						src[insertBom ? 2 : 1] = (swap ? SwapBytes(u2) : u2); }
396  					if (! ((u == 0xfffe || u == 0xfeff) && bomHandling == bomAllowed && ! insertBom)) 
397  					{
398  						expectedDest.Reserve(2, 0);
399  						if (insertBom && ! skipBom) expectedDest.Add(0xfeff);
400  						if (err && errorHandling == uehReplace) expectedDest.Add(replacementChar);
401  						else if (! err) expectedDest.Add(u);
402  						int erv = (err ? 0 : expectedDest.Len());
403  						if (skipBom && (u == 0xfeff || u == 0xfffe) && ! insertBom) expectedDest.Clr(), erv = 0;
404  						bool errD = err;
405  						if (bomHandling == bomRequired && ! insertBom) {
406  							expectedDest.Clr(false);
407  							if (u == 0xfeff || u == 0xfffe) { erv = (skipBom ? 0 : 1); if (! skipBom) expectedDest.Add(0xfeff); }
408  							else { erv = -1; errD = true;
409  								 }}
410  						TestUtf16(true, erv, (errD && errorHandling == uehThrow), src, expectedDest, bomHandling, byteOrder, insertBom, 0);
411  					}
412  				}
413  				src2[0] = u;
414  				if (err) {
415  					src.Clr(false); if (insertBom) src.Add(swap ? 0xfffe : 0xfeff);
416  					if (errorHandling == uehReplace) {
417  						src.Add(swap ? SwapBytes(replacementChar) : replacementChar);
418  					}}
419  				TestUtf16(false, (err ? 0 : 1) + (insertBom ? 1 : 0), (err && errorHandling == uehThrow), src2, src, bomHandling, byteOrder, insertBom, 0);
420  				if (u == uTo) break;
421  			}
422  		}
423  	}
424  }
425  void TUniCaseFolding::LoadTxt(const TStr& fileName)
426  {
427  	Clr();
428  	TUniChDb::TUcdFileReader reader; reader.Open(fileName);
429  	TStrV fields;
430  	while (reader.GetNextLine(fields))
431  	{
432  		int cp = reader.ParseCodePoint(fields[0]);
433  		const TStr status = fields[1], mapsTo = fields[2];
434  		if (status == "C" || status == "S" || status == "T") {
435  			TIntH &dest = (status == "C" ? cfCommon : status == "S" ? cfSimple : cfTurkic);
436  			IAssert(! dest.IsKey(cp));
437  			int cp2 = reader.ParseCodePoint(mapsTo);
438  			dest.AddDat(cp, cp2); }
439  		else if (status == "F") {
440  			TIntIntVH &dest = cfFull;
441  			IAssert(! dest.IsKey(cp));
442  			TIntV cps; reader.ParseCodePointList(mapsTo, cps); IAssert(cps.Len() > 0);
443  			dest.AddDat(cp, cps); }
444  		else
445  			FailR(status.CStr());
446  	}
447  	printf("TUniCaseFolding(\"%s\"): %d common, %d simple, %d full, %d Turkic.\n",
448  		fileName.CStr(), cfCommon.Len(), cfSimple.Len(), cfFull.Len(), cfTurkic.Len());
449  }
450  void TUniCaseFolding::Test(const TIntV& src, const TIntV& expectedDest, const bool full, const bool turkic, FILE *f)
451  {
452  	fprintf(f, "TUniCaseFolding(%s%s): ", (full ? "full" : "simple"), (turkic ? ", turkic" : ""));
453  	for (int i = 0; i < src.Len(); i++) fprintf(f, " %04x", int(src[i]));
454  	TIntV dest; Fold(src, 0, src.Len(), dest, true, full, turkic);
455  	fprintf(f, "\n  -> ");
456  	for (int i = 0; i < dest.Len(); i++) fprintf(f, " %04x", int(dest[i]));
457  	fprintf(f, "\n");
458  	IAssert(dest.Len() == expectedDest.Len());
459  	for (int i = 0; i < dest.Len(); i++) IAssert(dest[i] == expectedDest[i]);
460  }
461  void TUniCaseFolding::Test()
462  {
463  	FILE *f = stderr;
464  	TVectorBuilder VB;
465  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x69, 0x63, 0xdf), false, false, f);
466  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x131, 0x63, 0xdf), false, true, f);
467  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x69, 0x63, 0x73, 0x73), true, false, f);
468  	Test((VB, 0x41, 0x62, 0x49, 0x43, 0xdf), (VB, 0x61, 0x62, 0x131, 0x63, 0x73, 0x73), true, true, f);
469  }
470  const ushort TUniChInfo::LineBreak_Unknown = TUniChInfo::GetLineBreakCode('X', 'X');
471  const ushort TUniChInfo::LineBreak_ComplexContext = TUniChInfo::GetLineBreakCode('S', 'A');
472  const ushort TUniChInfo::LineBreak_Numeric = TUniChInfo::GetLineBreakCode('N', 'U');
473  const ushort TUniChInfo::LineBreak_InfixNumeric = TUniChInfo::GetLineBreakCode('I', 'S');
474  const ushort TUniChInfo::LineBreak_Quotation = TUniChInfo::GetLineBreakCode('Q', 'U');
475  void TUniChDb::TestWbFindNonIgnored(const TIntV& src) const
476  {
477  	int n = src.Len();
478  	TBoolV isIgnored; isIgnored.Gen(n);
479  	for (int i = 0; i < n; i++) isIgnored[i] = IsWbIgnored(src[i]);
480  	TIntV prevNonIgnored, nextNonIgnored, curOrNextNonIgnored;
481  	prevNonIgnored.Gen(n); nextNonIgnored.Gen(n); curOrNextNonIgnored.Gen(n);
482  	FILE *f = 0; 
483  	for (int srcIdx = 0; srcIdx < n; srcIdx++) for (int srcLen = 1; srcLen < n - srcIdx; srcLen++)
484  	{
485  		int prev = -1;
486  		for (int i = 0; i < srcLen; i++) {
487  			prevNonIgnored[i] = prev;
488  			if (! isIgnored[srcIdx + i]) prev = srcIdx + i; }
489  		int next = srcIdx + srcLen;
490  		for (int i = srcLen - 1; i >= 0; i--) {
491  			nextNonIgnored[i] = next;
492  			if (! isIgnored[srcIdx + i]) next = srcIdx + i;
493  			curOrNextNonIgnored[i] = next; }
494  		if (f) {
495  			fprintf(f, "\nIndex:     "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", srcIdx + i);
496  			fprintf(f, "\nNonIgn:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %s", (isIgnored[srcIdx + i] ? " ." : " Y"));
497  			fprintf(f, "\nPrevNI:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(prevNonIgnored[i]));
498  			fprintf(f, "\nNextNI:    "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(nextNonIgnored[i]));
499  			fprintf(f, "\nCurNextNI: "); for (int i = 0; i < srcLen; i++) fprintf(f, " %2d", int(curOrNextNonIgnored[i]));
500  			fprintf(f, "\n"); }
501  		for (int i = 0; i < srcLen; i++)
502  		{
503  			size_t s;
504  			s = size_t(srcIdx + i); WbFindNextNonIgnored(src, s, size_t(srcIdx + srcLen));
505  			IAssert(s == size_t(nextNonIgnored[i]));
506  			s = size_t(srcIdx + i); WbFindCurOrNextNonIgnored(src, s, size_t(srcIdx + srcLen));
507  			IAssert(s == size_t(curOrNextNonIgnored[i]));
508  			s = size_t(srcIdx + i); bool ok = WbFindPrevNonIgnored(src, size_t(srcIdx), s);
509  			if (prevNonIgnored[i] < 0) { IAssert(! ok); IAssert(s == size_t(srcIdx)); }
510  			else { IAssert(ok); IAssert(s == size_t(prevNonIgnored[i])); }
511  		}
512  	}
513  }
514  void TUniChDb::TestWbFindNonIgnored() const
515  {
516  	TIntV chIgnored, chNonIgnored;
517  	FILE *f = 0; 
518  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) {
519  		const int cp = h.GetKey(i); const TUniChInfo& ci = h[i];
520  		if (f) fprintf(f, "%04x: flags %08x props %08x %08x script \"%s\"\n", cp,
521  			ci.flags, ci.properties, ci.propertiesX, GetScriptName(ci.script).CStr());
522  		(IsWbIgnored(h[i]) ? chIgnored : chNonIgnored).Add(h.GetKey(i));
523  	}
524  	chIgnored.Sort(); chNonIgnored.Sort();
525  	printf("TUniChDb::TestWbNonIgnored: %d ignored, %d nonignored chars.\n", chIgnored.Len(), chNonIgnored.Len());
526  	TRnd rnd = TRnd(123);
527  	for (int iter = 0; iter <= 50; iter++)
528  	{
529  		int percIgnored = 2 * iter;
530  		for (int n = 0; n <= 20; n++)
531  		{
532  			TIntV v; v.Gen(n);
533  			for (int i = 0; i < n; i++) {
534  				TIntV& chars = (rnd.GetUniDevInt(100) < percIgnored) ? chIgnored : chNonIgnored;
535  				int j = rnd.GetUniDevInt(chars.Len());
536  				v.Add(chars[j]); }
537  			TestWbFindNonIgnored(v);
538  		}
539  	}
540  }
541  void TUniChDb::TestFindNextWordOrSentenceBoundary(const TStr& basePath, bool sentence)
542  {
543  	TUcdFileReader reader; TStrV fields;
544  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), (sentence ? GetSentenceBreakTestFn() : GetWordBreakTestFn())));
545  	int nLines = 0; TRnd rnd = TRnd(123);
546  	while (reader.GetNextLine(fields))
547  	{
548  		nLines += 1;
549  		IAssert(fields.Len() == 1);
550  		TStrV parts; fields[0].SplitOnWs(parts);
551  		const int n = parts.Len(); IAssert((n % 2) == 1);
552  		TIntV chars; TBoolV isBreak, isPredicted, isPredicted2;
553  		for (int i = 0; i < n; i++)
554  		{
555  			const TStr& s = parts[i];
556  			if ((i % 2) == 0) {
557  				if (s == "\xc3\x97") 
558  					isBreak.Add(false);
559  				else if (s == "\xc3\xb7") 
560  					isBreak.Add(true);
561  				else FailR(s.CStr()); }
562  			else chars.Add(reader.ParseCodePoint(s));
563  		}
564  		const int m = n / 2; IAssert(chars.Len() == m); IAssert(isBreak.Len() == m + 1);
565  		IAssert(isBreak[0]); IAssert(isBreak[m]);
566  		isPredicted.Gen(m + 1); isPredicted.PutAll(false);
567  		if (AlwaysFalse()) { printf("%3d", nLines); for (int i = 0; i < m; i++) printf(" %04x", int(chars[i])); printf("\n"); }
568  		for (int nBefore = 0; nBefore < 5; nBefore++)
569  		{
570  			TIntV chars2; for (int i = 0; i < nBefore; i++) chars2.Add(0, rnd.GetUniDevInt(0x10ffff + 1));
571  			chars2.AddV(chars);
572  			size_t position = (nBefore > 0 ? nBefore - 1 : nBefore); size_t prevPosition = position;
573  			while (sentence ? FindNextSentenceBoundary(chars2, nBefore, m, position) : FindNextWordBoundary(chars2, nBefore, m, position))
574  			{
575  				IAssert(prevPosition < position);
576  				IAssert(position <= size_t(nBefore + m));
577  				isPredicted[int(position) - nBefore] = true;
578  				prevPosition = position;
579  			}
580  			IAssert(position == size_t(nBefore + m));
581  			if (sentence) FindSentenceBoundaries(chars2, nBefore, m, isPredicted2);
582  			else FindWordBoundaries(chars2, nBefore, m, isPredicted2);
583  			IAssert(isPredicted2.Len() == m + 1);
584  			bool ok = true;
585  			if (nBefore == 0) isPredicted[0] = true;
586  			for (int i = 0; i <= m; i++) {
587  				if (isBreak[i] != isPredicted[i]) ok = false;
588  				IAssert(isPredicted2[i] == isPredicted[i]); }
589  			FILE *f = stderr;
590  			if (! ok)
591  			{
592  				fprintf(f, "\nError in line %d:\n", nLines);
593  				fprintf(f, "True:      ");
594  				for (int i = 0; i <= m; i++) {
595  					fprintf(f, "%s ", (isBreak[i] ? "|" : "."));
596  					if (i < m) fprintf(f, "%04x ", int(chars[i + nBefore])); }
597  				fprintf(f, "\nPredicted: ");
598  				for (int i = 0; i <= m; i++) {
599  					fprintf(f, "%s ", (isPredicted[i] ? "|" : "."));
600  					if (i < m) {
601  						const int cp = chars[i + nBefore];
602  						TStr s = sentence ? TUniChInfo::GetSbFlagsStr(GetSbFlags(cp)) : TUniChInfo::GetWbFlagsStr(GetWbFlags(cp));
603  						if (IsWbIgnored(cp)) s = "*" + s;
604  						fprintf(f, "%4s ", s.CStr()); }}
605  				fprintf(f, "\n");
606  				Fail;
607  			}
608  			for (int i = 0; i < m; i++) {
609  				position = i + nBefore; bool ok = sentence ? FindNextSentenceBoundary(chars2, nBefore, m, position) : FindNextWordBoundary(chars2, nBefore, m, position);
610  				IAssert(ok); 
611  				IAssert(size_t(i + nBefore) < position); IAssert(position <= size_t(nBefore + m));
612  				position -= nBefore;
613  				for (int j = i + 1; j < int(position); j++)
614  					IAssert(! isBreak[j]);
615  				IAssert(isBreak[int(position)]); }
616  		}
617  	}
618  	reader.Close();
619  	printf("TUniChDb::TestFindNext%sBoundary: %d lines processed.\n", (sentence ? "Sentence" : "Word"), nLines);
620  }
621  void TUniChDb::TestComposition(const TStr& basePath)
622  {
623  	TUcdFileReader reader; TStrV fields; int nLines = 0;
624  	reader.Open(CombinePath(basePath, GetNormalizationTestFn()));
625  	bool inPart1 = false; TIntH testedInPart1;
626  	while (reader.GetNextLine(fields))
627  	{
628  		nLines += 1;
629  		if (fields.Len() == 1) {
630  			IAssert(fields[0].IsPrefix("@Part"));
631  			inPart1 = (fields[0] == "@Part1"); continue; }
632  		IAssert(fields.Len() == 6);
633  		IAssert(fields[5].Len() == 0);
634  		TIntV c1, c2, c3, c4, c5;
635  		reader.ParseCodePointList(fields[0], c1);
636  		reader.ParseCodePointList(fields[1], c2);
637  		reader.ParseCodePointList(fields[2], c3);
638  		reader.ParseCodePointList(fields[3], c4);
639  		reader.ParseCodePointList(fields[4], c5);
640  		TIntV v;
641  #define AssE_(v1, v2, expl) AssertEq(v1, v2, TStr(expl) + " (line " + TInt::GetStr(nLines) + ")", 0)
642  #define NFC_(cmpWith, operand) DecomposeAndCompose(operand, 0, operand.Len(), v, false); AssE_(cmpWith, v, #cmpWith " == NFC(" #operand ")")
643  #define NFD_(cmpWith, operand) Decompose(operand, 0, operand.Len(), v, false); AssE_(cmpWith, v, #cmpWith " == NFD(" #operand ")")
644  #define NFKC_(cmpWith, operand) DecomposeAndCompose(operand, 0, operand.Len(), v, true); AssE_(cmpWith, v, #cmpWith " == NFKC(" #operand ")")
645  #define NFKD_(cmpWith, operand) Decompose(operand, 0, operand.Len(), v, true); AssE_(cmpWith, v, #cmpWith " == NFKD(" #operand ")")
646  		NFD_(c3, c1);   
647  		NFD_(c3, c2);   
648  		NFD_(c3, c3);   
649  		NFD_(c5, c4);   
650  		NFD_(c5, c5);   
651  		NFC_(c2, c1);   
652  		NFC_(c2, c2);   
653  		NFC_(c2, c3);   
654  		NFC_(c4, c4);   
655  		NFC_(c4, c5);   
656  		NFKD_(c5, c1);   
657  		NFKD_(c5, c2);   
658  		NFKD_(c5, c3);   
659  		NFKD_(c5, c4);   
660  		NFKD_(c5, c5);   
661  		NFKC_(c4, c1);   
662  		NFKC_(c4, c2);   
663  		NFKC_(c4, c3);   
664  		NFKC_(c4, c4);   
665  		NFKC_(c4, c5);   
666  		if (inPart1) {
667  			IAssert(c1.Len() == 1);
668  			testedInPart1.AddKey(c1[0]); }
669  	}
670  	reader.Close();
671  	int nOther = 0;
672  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
673  	{
674  		const int cp = h.GetKey(i), nLines = -1;
675  		if (testedInPart1.IsKey(cp)) continue;
676  		TIntV x, v; x.Add(cp);
677  		NFC_(x, x);    
678  		NFD_(x, x);    
679  		NFKC_(x, x);   
680  		NFKD_(x, x);   
681  		nOther += 1;
682  	}
683  #undef AssE_
684  #undef NFC_
685  #undef NFD_
686  #undef NFKC_
687  #undef NFKD_
688  	printf("TUniChDb::TestComposition: %d lines processed + %d other individual codepoints.\n", nLines, nOther);
689  }
690  void TUniChDb::TestCaseConversion(const TStr& source, const TStr& trueLc,
691  								  const TStr& trueTc, const TStr& trueUc,
692  								  bool turkic, bool lithuanian)
693  {
694  	TIntV src;
695  	TUcdFileReader::ParseCodePointList(source, src);
696  	FILE *f = stderr;
697  	for (int i = 0; i < 3; i++)
698  	{
699  		TCaseConversion how = (i == 0) ? ccLower : (i == 1) ? ccTitle : ccUpper;
700  		const TStr &trueDestS = (how == ccLower ? trueLc : how == ccTitle ? trueTc : trueUc);
701  		TIntV trueDest; TUcdFileReader::ParseCodePointList(trueDestS, trueDest);
702  		TIntV dest;
703  		GetCaseConverted(src, 0, src.Len(), dest, true, how, turkic, lithuanian);
704  		bool ok = (dest.Len() == trueDest.Len());
705  		if (ok) for (int i = 0; i < dest.Len() && ok; i++) ok = ok && (dest[i] == trueDest[i]);
706  		if (ok) continue;
707  		fprintf(f, "%s(", (how == ccLower ? "toLowercase" : how == ccTitle ? "toTitlecase" : "toUppercase"));
708  		for (int i = 0; i < src.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(src[i]));
709  		fprintf(f, ")\nCorrect:   (");
710  		for (int i = 0; i < trueDest.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(trueDest[i]));
711  		fprintf(f, ")\nOur output:(");
712  		for (int i = 0; i < dest.Len(); i++) fprintf(f, "%s%04x", (i == 0 ? "" : " "), int(dest[i]));
713  		fprintf(f, ")\n");
714  		IAssert(ok);
715  	}
716  }
717  void TUniChDb::TestCaseConversions()
718  {
719  	const TStr F = "0046 ", L = "004C ", S = "0053 ", T = "0054 ", W = "0057 ";
720  	const TStr f = "0066 ", l = "006c ", s = "0073 ", t = "0074 ", w = "0077 ";
721  	const TStr ss = "00df ", ffl = "fb04 ", longs = "017f ", longst = "fb05 ", wRing = "1e98 ", Ring = "030a ";
722  	const TStr DZ = "01c4 ", Dz = "01c5 ", dz = "01c6 ";
723  	const TStr space = "0020 ", Grave = "0300 ";
724  	TestCaseConversion(
725  		F + L + s + t + space + Dz + w + T + ss + wRing + space + longs + DZ + space + dz + longst,  
726  		f + l + s + t + space + dz + w + t + ss + wRing + space + longs + dz + space + dz + longst,  
727  		F + l + s + t + space + Dz + w + t + ss + wRing + space + S + dz + space + Dz + longst,      
728  		F + L + S + T + space + DZ + W + T + S + S + W + Ring + space + S + DZ + space + DZ + S + T, 
729  		false, false);
730  	const TStr I = "0049 ", J = "004a ", i = "0069 ", j = "006a ", iDotless = "0131 ", IDot = "0130 ", DotA = "0307 ";
731  	TestCaseConversion(
732  		s + I + t + i + w + iDotless + f + IDot + l + space + iDotless + DotA + f + I + DotA + s, 
733  		s + i + t + i + w + iDotless + f + i + DotA + l + space + iDotless + DotA + f + i + DotA + s, 
734  		S + i + t + i + w + iDotless + f + i + DotA + l + space + I + DotA + f + i + DotA + s, 
735  		S + I + T + I + W + I + F + IDot + L + space + I + DotA + F + I + DotA + S, 
736  		false, false);
737  	const TStr Sigma = "03a3 ", sigma = "03c3 ", fsigma = "03c2 ";
738  	TestCaseConversion(
739  		Sigma + s + space + s + Sigma  + space + s + Sigma + s + space + Sigma + S + Sigma  + space + Sigma, 
740  		sigma + s + space + s + fsigma + space + s + sigma + s + space + sigma + s + fsigma + space + sigma, 
741  		Sigma + s + space + S + fsigma + space + S + sigma + s + space + Sigma + s + fsigma + space + Sigma, 
742  		Sigma + S + space + S + Sigma  + space + S + Sigma + S + space + Sigma + S + Sigma  + space + Sigma, 
743  		false, false);
744  	TestCaseConversion(
745  		sigma + s + space + s + sigma  + space + s + sigma + s + space + sigma + S + sigma  + space + sigma, 
746  		sigma + s + space + s + sigma  + space + s + sigma + s + space + sigma + s + sigma  + space + sigma, 
747  		Sigma + s + space + S + sigma  + space + S + sigma + s + space + Sigma + s + sigma  + space + Sigma, 
748  		Sigma + S + space + S + Sigma  + space + S + Sigma + S + space + Sigma + S + Sigma  + space + Sigma, 
749  		false, false);
750  	TestCaseConversion(
751  		fsigma + s + space + s + fsigma + space + s + fsigma + s + space + fsigma + S + fsigma  + space + fsigma, 
752  		fsigma + s + space + s + fsigma + space + s + fsigma + s + space + fsigma + s + fsigma  + space + fsigma, 
753  		Sigma  + s + space + S + fsigma + space + S + fsigma + s + space + Sigma  + s + fsigma  + space + Sigma, 
754  		Sigma  + S + space + S + Sigma  + space + S + Sigma  + S + space + Sigma  + S + Sigma   + space + Sigma, 
755  		false, false);
756  	const TStr nonSA = "0315 0321 0322 "; 
757  	TestCaseConversion(
758  		s + I + t + i + w + iDotless + f + IDot + l + space + iDotless + DotA + f + I + DotA + J + DotA + I + Grave + DotA + I + DotA + DotA + I + nonSA + DotA + s, 
759  		s + iDotless + t + i + w + iDotless + f + i + l + space + iDotless + DotA + f + i + j + DotA + iDotless + Grave + DotA + i + DotA + i + nonSA + s, 
760  		S + iDotless + t + i + w + iDotless + f + i + l + space + I + DotA + f + i + j + DotA + iDotless + Grave + DotA + i + DotA + i + nonSA + s, 
761  		S + I + T + IDot + W + I + F + IDot + L + space + I + DotA + F + I + DotA + J + DotA + I + Grave + DotA + I + DotA + DotA + I + nonSA + DotA + S, 
762  		true, false); 
763  	TestCaseConversion(
764  		I + Grave + t + I + DotA + f + I + nonSA + DotA + j + space + I + nonSA + DotA + space + I + Grave + t, 
765  		iDotless + Grave + t + i + f + i + nonSA + j + space + i + nonSA + space + iDotless + Grave + t, 
766  		I + Grave + t + i + f + i + nonSA + j + space + I + nonSA + DotA + space + I + Grave + t, 
767  		I + Grave + T + I + DotA + F + I + nonSA + DotA + J + space + I + nonSA + DotA + space + I + Grave + T, 
768  		true, false); 
769  	TestCaseConversion(
770  		i + DotA + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + I + DotA + t + DotA + i + DotA + Grave, 
771  		i + DotA + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + i + DotA + DotA + t + DotA + i + DotA + Grave, 
772  		I + t + i + Grave + DotA + f + i + DotA + DotA + f + i + nonSA + DotA + i + DotA + DotA + t + DotA + i + DotA + Grave, 
773  		I + T + I + Grave + DotA + F + I + DotA + F + I + nonSA + I + DotA + T + DotA + I + Grave, 
774  		false, true); 
775  	TestCaseConversion(
776  		J +        Grave + space + J +        nonSA + DotA + space + j + Grave + space + j + DotA + space + J + nonSA + J +        nonSA + Grave + space + j + nonSA, 
777  		j + DotA + Grave + space + j + DotA + nonSA + DotA + space + j + Grave + space + j + DotA + space + j + nonSA + j + DotA + nonSA + Grave + space + j + nonSA, 
778  		J +        Grave + space + J +        nonSA + DotA + space + J + Grave + space + J +        space + J + nonSA + j + DotA + nonSA + Grave + space + J + nonSA, 
779  		J +        Grave + space + J +        nonSA + DotA + space + J + Grave + space + J +        space + J + nonSA + J +        nonSA + Grave + space + J + nonSA, 
780  		false, true); 
781  }
782  void TUniChDb::LoadTxt_ProcessDecomposition(TUniChInfo& ci, TStr s)
783  {
784  	if (s.Empty()) return;
785  	if (s[0] == '<') {
786  		int i = s.SearchCh('>'); IAssert(i > 0);
787  		ci.flags |= ucfCompatibilityDecomposition;
788  		s = s.GetSubStr(i + 1, s.Len() - 1); s.ToTrunc(); }
789  	TIntV dec; TUcdFileReader::ParseCodePointList(s, dec);
790  	IAssert(dec.Len() > 0);
791  	ci.decompOffset = decompositions.Len();
792  	decompositions.AddV(dec); decompositions.Add(-1);
793  }
794  void TUniChDb::InitPropList(const TStr& basePath)
795  {
796  	TUcdFileReader reader; TStrV fields; int nCps = 0, nLines = 0;
797  	reader.Open(CombinePath(basePath, GetPropListFn()));
798  	TSubcatHelper helper(*this);
799  	while (reader.GetNextLine(fields))
800  	{
801  		IAssert(fields.Len() == 2);
802  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
803  		TStr s = fields[1];
804  		TUniChProperties prop = TUniChProperties(0); TUniChPropertiesX propx = TUniChPropertiesX(0);
805  		if (s == "White_Space") prop = ucfPrWhiteSpace;
806  		else if (s == "Bidi_Control") prop = ucfPrBidiControl;
807  		else if (s == "Join_Control") prop = ucfPrJoinControl;
808  		else if (s == "Dash") prop = ucfPrDash;
809  		else if (s == "Hyphen") prop = ucfPrHyphen;
810  		else if (s == "Quotation_Mark") prop = ucfPrQuotationMark;
811  		else if (s == "Terminal_Punctuation") prop = ucfPrTerminalPunctuation;
812  		else if (s == "Other_Math") propx = ucfPxOtherMath;
813  		else if (s == "Hex_Digit") prop = ucfPrHexDigit;
814  		else if (s == "ASCII_Hex_Digit") prop = ucfPrAsciiHexDigit;
815  		else if (s == "Other_Alphabetic") propx = ucfPxOtherAlphabetic;
816  		else if (s == "Ideographic") prop = ucfPrIdeographic;
817  		else if (s == "Diacritic") prop = ucfPrDiacritic;
818  		else if (s == "Extender") prop = ucfPrExtender;
819  		else if (s == "Other_Lowercase") propx = ucfPxOtherLowercase;
820  		else if (s == "Other_Uppercase") propx = ucfPxOtherUppercase;
821  		else if (s == "Noncharacter_Code_Point") prop = ucfPrNoncharacterCodePoint;
822  		else if (s == "Other_Grapheme_Extend") propx = ucfPxOtherGraphemeExtend;
823  		else if (s == "IDS_Binary_Operator") propx = ucfPxIdsBinaryOperator;
824  		else if (s == "IDS_Trinary_Operator") propx = ucfPxIdsTrinaryOperator;
825  		else if (s == "Radical") propx = ucfPxRadical;
826  		else if (s == "Unified_Ideograph") propx = ucfPxUnifiedIdeograph;
827  		else if (s == "Other_Default_Ignorable_Code_Point") propx = ucfPxOtherDefaultIgnorableCodePoint;
828  		else if (s == "Deprecated") prop = ucfPrDeprecated;
829  		else if (s == "Soft_Dotted") prop = ucfPrSoftDotted;
830  		else if (s == "Logical_Order_Exception") prop = ucfPrLogicalOrderException;
831  		else if (s == "Other_ID_Start") propx = ucfPxOtherIdStart;
832  		else if (s == "Other_ID_Continue") propx = ucfPxOtherIdContinue;
833  		else if (s == "STerm") prop = ucfPrSTerm;
834  		else if (s == "Variation_Selector") prop = ucfPrVariationSelector;
835  		else if (s == "Pattern_White_Space") prop = ucfPrPatternWhiteSpace;
836  		else if (s == "Pattern_Syntax") prop = ucfPrPatternSyntax;
837  		else FailR(s.CStr());
838  		helper.ProcessComment(reader);
839  		for (int cp = from; cp <= to; cp++) {
840  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
841  			TUniChInfo &ci = h[i]; helper.TestCat(cp);
842  			if (prop) { IAssert(! ci.IsProperty(prop)); ci.SetProperty(prop); }
843  			if (propx) { IAssert(! ci.IsPropertyX(propx)); ci.SetPropertyX(propx); }
844  			nCps++; }
845  		nLines++;
846  	}
847  	reader.Close();
848  	printf("TUniChDb::InitPropList: %d lines, %d code points.\n", nLines, nCps);
849  }
850  void TUniChDb::InitDerivedCoreProperties(const TStr& basePath)
851  {
852  	TUcdFileReader reader; TStrV fields; int nCps = 0, nLines = 0;
853  	reader.Open(CombinePath(basePath, GetDerivedCorePropsFn()));
854  	TSubcatHelper helper(*this);
855  	while (reader.GetNextLine(fields))
856  	{
857  		IAssert(fields.Len() == 2);
858  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
859  		TStr s = fields[1];
860  		TUniChFlags flag = ucfCompatibilityDecomposition;
861  		if (s == "Math") flag = ucfDcpMath;
862  		else if (s == "Alphabetic") flag = ucfDcpAlphabetic;
863  		else if (s == "Lowercase") flag = ucfDcpLowercase;
864  		else if (s == "Uppercase") flag = ucfDcpUppercase;
865  		else if (s == "ID_Start") flag = ucfDcpIdStart;
866  		else if (s == "ID_Continue") flag = ucfDcpIdContinue;
867  		else if (s == "XID_Start") flag = ucfDcpXidStart;
868  		else if (s == "XID_Continue") flag = ucfDcpXidContinue;
869  		else if (s == "Default_Ignorable_Code_Point") flag = ucfDcpDefaultIgnorableCodePoint;
870  		else if (s == "Grapheme_Extend") flag = ucfDcpGraphemeExtend;
871  		else if (s == "Grapheme_Base") flag = ucfDcpGraphemeBase;
872  		else if (s == "Grapheme_Link") continue; 
873  		else FailR(s.CStr());
874  		helper.ProcessComment(reader);
875  		for (int cp = from; cp <= to; cp++) {
876  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
877  			helper.TestCat(cp);
878  			TUniChInfo &ci = h[i]; IAssert(! ci.IsDcpFlag(flag));
879  			ci.SetDcpFlag(flag); nCps++; }
880  		nLines++;
881  	}
882  	reader.Close();
883  	printf("TUniChDb::InitDerivedCoreProperties: %d lines, %d code points.\n", nLines, nCps);
884  }
885  void TUniChDb::InitLineBreaks(const TStr& basePath)
886  {
887  	ushort xx = TUniChInfo::LineBreak_Unknown;
888  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) h[i].lineBreak = xx;
889  	TUcdFileReader reader; TStrV fields;
890  	reader.Open(CombinePath(basePath, GetLineBreakFn()));
891  	int nLines = 0, nCps = 0;
892  	while (reader.GetNextLine(fields))
893  	{
894  		IAssert(fields.Len() == 2);
895  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
896  		TStr s = fields[1]; IAssert(s.Len() == 2);
897  		ushort us = TUniChInfo::GetLineBreakCode(s[0], s[1]);
898  		if (us == xx) continue;
899  		for (int cp = from; cp <= to; cp++) {
900  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp);
901  				printf("TUniChDb::InitLineBreaks: warning, adding codepoint %d, its category will remain unknown.\n", cp); }
902  			IAssert(h[i].lineBreak == xx);
903  			h[i].lineBreak = us; nCps++; }
904  		nLines++;
905  	}
906  	reader.Close();
907  	printf("TUniChDb::InitLineBreaks: %d lines, %d codepoints processed (excluding \'xx\' values).\n", nLines, nCps);
908  }
909  void TUniChDb::InitScripts(const TStr& basePath)
910  {
911  	TUcdFileReader reader; TStrV fields;
912  	reader.Open(CombinePath(basePath, GetScriptsFn()));
913  	TSubcatHelper helper(*this);
914  	while (reader.GetNextLine(fields))
915  	{
916  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
917  		TStr scriptName = fields[1];
918  		int scriptNo = scripts.GetKeyId(scriptName);
919  		if (scriptNo < 0) { scriptNo = scripts.AddKey(scriptName); scripts[scriptNo] = 0; }
920  		IAssert(scriptNo >= 0 && scriptNo < SCHAR_MAX); 
921  		scripts[scriptNo] += 1;
922  		helper.ProcessComment(reader);
923  		for (int cp = from; cp <= to; cp++) {
924  			int i = h.GetKeyId(cp); if (i < 0) { i = h.AddKey(cp); helper.SetCat(cp); }
925  			helper.TestCat(cp);
926  			TUniChInfo &ci = h[i]; ci.script = scriptNo; }
927  	}
928  	reader.Close();
929  	scripts.AddDat(GetScriptNameUnknown()) = 0;
930  	printf("TUniChDb::InitScripts: %d scripts: ", scripts.Len());
931  	if (AlwaysFalse()) for (int i = scripts.FFirstKeyId(); scripts.FNextKeyId(i); )
932  		printf("  %d:%s (%d)", i, scripts.GetKey(i).CStr(), int(scripts[i]));
933  	printf("\n");
934  }
935  void TUniChDb::InitWordAndSentenceBoundaryFlags(const TStr& basePath)
936  {
937  	int katakana = GetScriptByName(GetScriptNameKatakana()); IAssert(katakana >= 0);
938  	int hiragana = GetScriptByName(GetScriptNameHiragana()); IAssert(hiragana >= 0);
939  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
940  	{
941  		const int cp = h.GetKey(i); TUniChInfo& ci = h[i];
942  		ci.ClrWbAndSbFlags();
943  		if (ci.subCat  == ucOtherFormat && cp != 0x200c && cp != 0x200d) ci.SetWbFlag(ucfWbFormat);
944  		if (ci.script == katakana) ci.SetWbFlag(ucfWbKatakana);
945  		if (ci.lineBreak == TUniChInfo::LineBreak_InfixNumeric && cp != 0x3a) ci.SetWbFlag(ucfWbMidNum);
946  		if (ci.lineBreak == TUniChInfo::LineBreak_Numeric) ci.SetWbFlag(ucfWbNumeric);
947  		if (ci.subCat == ucPunctuationConnector) ci.SetWbFlag(ucfWbExtendNumLet);
948  		if (cp == 0xa || cp == 0xd || cp == 0x85 || cp == 0x2028 || cp == 0x2029) ci.SetSbFlag(ucfSbSep);
949  		if (ci.subCat == ucOtherFormat && cp != 0x200c && cp != 0x200d) ci.SetSbFlag(ucfSbFormat);
950  		if (ci.IsWhiteSpace() && ! ci.IsSbFlag(ucfSbSep) && cp != 0xa0) ci.SetSbFlag(ucfSbSp);
951  		if (ci.IsLowercase() && ! ci.IsGraphemeExtend()) ci.SetSbFlag(ucfSbLower);
952  		if (ci.IsUppercase() || ci.subCat == ucLetterTitlecase) ci.SetSbFlag(ucfSbUpper);
953  		if ((ci.IsAlphabetic() || cp == 0xa0 || cp == 0x5f3) && ! ci.IsSbFlag(ucfSbLower) && ! ci.IsSbFlag(ucfSbUpper) && ! ci.IsGraphemeExtend()) ci.SetSbFlag(ucfSbOLetter);
954  		if (ci.lineBreak == TUniChInfo::LineBreak_Numeric) ci.SetSbFlag(ucfSbNumeric);
955  		if (cp == 0x2e) ci.SetSbFlag(ucfSbATerm);
956  		if (ci.IsSTerminal() && cp != 0x2e) ci.SetSbFlag(ucfSbSTerm);
957  		if ((ci.subCat == ucPunctuationOpen || ci.subCat == ucPunctuationClose || ci.lineBreak == TUniChInfo::LineBreak_Quotation) && cp != 0x5f3 && ! ci.IsSbFlag(ucfSbATerm) && ! ci.IsSbFlag(ucfSbSTerm)) ci.SetSbFlag(ucfSbClose);
958  	}
959  	TIntV v = (VB, 0x3031, 0x3032, 0x3033, 0x3034, 0x3035, 0x309b, 0x309c, 0x30a0, 0x30fc, 0xff70, 0xff9e, 0xff9f);
960  	for (int i = 0; i < v.Len(); i++) h.GetDat(v[i]).SetWbFlag(ucfWbKatakana);
961  	v = (VB, 0x27, 0xb7, 0x5f4, 0x2019, 0x2027, 0x3a);
962  	for (int i = 0; i < v.Len(); i++) h.GetDat(v[i]).SetWbFlag(ucfWbMidLetter);
963  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
964  	{
965  		const int cp = h.GetKey(i); TUniChInfo& ci = h[i];
966  		if ((ci.IsAlphabetic() || cp == 0x5f3) && ! ci.IsIdeographic() && ! ci.IsWbFlag(ucfWbKatakana) && ci.lineBreak != TUniChInfo::LineBreak_ComplexContext && ci.script != hiragana && ! ci.IsGraphemeExtend())
967  			ci.SetWbFlag(ucfWbALetter);
968  	}
969  	{TUcdFileReader reader; TStrV fields;
970  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), GetWordBreakPropertyFn()));
971  	THash<TInt, TInt> hh;
972  	while (reader.GetNextLine(fields))
973  	{
974  		IAssert(fields.Len() == 2);
975  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
976  		TStr s = fields[1];
977  		TUniChFlags flag = ucfCompatibilityDecomposition;
978  		if (s == "Format") flag = ucfWbFormat;
979  		else if (s == "Katakana") flag = ucfWbKatakana;
980  		else if (s == "ALetter") flag = ucfWbALetter;
981  		else if (s == "MidLetter") flag = ucfWbMidLetter;
982  		else if (s == "MidNum") flag = ucfWbMidNum;
983  		else if (s == "Numeric") flag = ucfWbNumeric;
984  		else if (s == "ExtendNumLet") flag = ucfWbExtendNumLet;
985  		else FailR(s.CStr());
986  		for (int c = from; c <= to; c++) {
987  			int i = hh.GetKeyId(c); if (i < 0) hh.AddDat(c, flag);
988  			else hh[i].Val |= flag; }
989  	}
990  	reader.Close();
991  	TIntV cps; for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) cps.Add(h.GetKey(i));
992  	for (int i = hh.FFirstKeyId(); hh.FNextKeyId(i); ) cps.Add(hh.GetKey(i));
993  	cps.Sort(); cps.Merge();
994  	for (int i = 0; i < cps.Len(); i++)
995  	{
996  		int cp = cps[i];
997  		int flags1 = 0; if (h.IsKey(cp)) flags1 = h.GetDat(cp).GetWbFlags();
998  		int flags2 = 0; if (hh.IsKey(cp)) flags2 = hh.GetDat(cp);
999  		flags1 &= ~ucfSbSep; flags2 &= ~ucfSbSep;
1000  		if (flags1 != flags2) {
1001  			printf("cp = %04x: flags1 = %08x flags2 = %08x xor = %08x\n", cp, flags1, flags2, flags1 ^ flags2);
1002  			Fail; }
1003  	}}
1004  	{TUcdFileReader reader; TStrV fields;
1005  	reader.Open(CombinePath(CombinePath(basePath, GetAuxiliaryDir()), GetSentenceBreakPropertyFn()));
1006  	THash<TInt, TInt> hh;
1007  	while (reader.GetNextLine(fields))
1008  	{
1009  		IAssert(fields.Len() == 2);
1010  		int from, to; reader.ParseCodePointRange(fields[0], from, to);
1011  		TStr s = fields[1];
1012  		TUniChFlags flag = ucfCompatibilityDecomposition;
1013  		if (s == "Sep") flag = ucfSbSep;
1014  		else if (s == "Format") flag = ucfSbFormat;
1015  		else if (s == "Sp") flag = ucfSbSp;
1016  		else if (s == "Lower") flag = ucfSbLower;
1017  		else if (s == "Upper") flag = ucfSbUpper;
1018  		else if (s == "OLetter") flag = ucfSbOLetter;
1019  		else if (s == "Numeric") flag = ucfSbNumeric;
1020  		else if (s == "ATerm") flag = ucfSbATerm;
1021  		else if (s == "STerm") flag = ucfSbSTerm;
1022  		else if (s == "Close") flag = ucfSbClose;
1023  		else FailR(s.CStr());
1024  		for (int c = from; c <= to; c++) {
1025  			int i = hh.GetKeyId(c); if (i < 0) hh.AddDat(c, flag);
1026  			else hh[i].Val |= flag; }
1027  	}
1028  	reader.Close();
1029  	TIntV cps; for (int i = h.FFirstKeyId(); h.FNextKeyId(i); ) cps.Add(h.GetKey(i));
1030  	for (int i = hh.FFirstKeyId(); hh.FNextKeyId(i); ) cps.Add(hh.GetKey(i));
1031  	cps.Sort(); cps.Merge();
1032  	for (int i = 0; i < cps.Len(); i++)
1033  	{
1034  		int cp = cps[i];
1035  		int flags1 = 0; if (h.IsKey(cp)) flags1 = h.GetDat(cp).GetSbFlags();
1036  		int flags2 = 0; if (hh.IsKey(cp)) flags2 = hh.GetDat(cp);
1037  		if (flags1 != flags2) {
1038  			printf("cp = %04x: flags1 = %08x [%s] flags2 = %08x [%s] xor = %08x\n", cp,
1039  				flags1, TUniChInfo::GetSbFlagsStr(flags1).CStr(),
1040  				flags2, TUniChInfo::GetSbFlagsStr(flags2).CStr(),
1041  				flags1 ^ flags2);
1042  			Fail; }
1043  	}}
1044  }
1045  void TUniChDb::InitSpecialCasing(const TStr& basePath)
1046  {
1047  	TUcdFileReader reader; TStrV fields;
1048  	reader.Open(CombinePath(basePath, GetSpecialCasingFn()));
1049  	while (reader.GetNextLine(fields))
1050  	{
1051  		IAssert(fields.Len() == 5 || fields.Len() == 6);
1052  		IAssert(fields.Last().Empty());
1053  		TStr conditions = "";
1054  		if (fields.Len() == 6) conditions = fields[4];
1055  		conditions.ToTrunc(); if (! conditions.Empty()) continue;
1056  		const int cp = reader.ParseCodePoint(fields[0]);
1057  		TIntV v; reader.ParseCodePointList(fields[1], v);
1058  		specialCasingLower.AddDat(cp, v);
1059  		reader.ParseCodePointList(fields[2], v);
1060  		specialCasingTitle.AddDat(cp, v);
1061  		reader.ParseCodePointList(fields[3], v);
1062  		specialCasingUpper.AddDat(cp, v);
1063  	}
1064  	reader.Close();
1065  }
1066  void TUniChDb::LoadTxt(const TStr& basePath)
1067  {
1068  	Clr();
1069  	h = THash<TInt, TUniChInfo>(196613, true);
1070  	caseFolding.LoadTxt(CombinePath(basePath, GetCaseFoldingFn()));
1071  	TUcdFileReader reader; TStrV fields; TIntH seen;
1072  	reader.Open(CombinePath(basePath, GetUnicodeDataFn()));
1073  	while (reader.GetNextLine(fields))
1074  	{
1075  		int cp = reader.ParseCodePoint(fields[0]);
1076  		IAssert(! seen.IsKey(cp)); seen.AddKey(cp);
1077  		TUniChInfo& ci = h.AddDat(cp);
1078  		ci.nameOffset = charNames.AddStr(fields[1]);
1079  		TStr& s = fields[2]; IAssert(s.Len() == 2);
1080  		ci.chCat = s[0]; ci.chSubCat = s[1];
1081  		s = fields[3]; IAssert(s.Len() > 0);
1082  		int i; bool ok = s.IsInt(true, TUCh::Mn, TUCh::Mx, i); IAssertR(ok, s);
1083  		ci.combClass = (uchar) i;
1084  		LoadTxt_ProcessDecomposition(ci, fields[5]);
1085  		s = fields[12]; ci.simpleUpperCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1086  		s = fields[13]; ci.simpleLowerCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1087  		s = fields[14]; ci.simpleTitleCaseMapping = (! s.Empty() ? reader.ParseCodePoint(s) : -1);
1088  		ci.InitAfterLoad(); 
1089  	}
1090  	reader.Close();
1091  	InitScripts(basePath);
1092  	InitPropList(basePath);
1093  	InitDerivedCoreProperties(basePath);
1094  	InitLineBreaks(basePath);
1095  	InitSpecialCasing(basePath);
1096  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1097  	{
1098  		TUniChInfo& ci = h[i];
1099  		int ofs = ci.decompOffset; if (ofs < 0) continue;
1100  		int n = 0; while (decompositions[ofs + n] >= 0) n++;
1101  		IAssert(n > 0);
1102  		if (n == 1) { ci.flags |= ucfCompositionExclusion; continue; }
1103  		int cp1 = decompositions[ofs];
1104  		IAssert(h.IsKey(cp1));
1105  		uchar ccc = h.GetDat(cp1).combClass;
1106  		if (ccc != TUniChInfo::ccStarter) { ci.flags |= ucfCompositionExclusion; continue; }
1107  	}
1108  	reader.Open(CombinePath(basePath, GetCompositionExclusionsFn()));
1109  	int nExclusionTable = 0;
1110  	while (reader.GetNextLine(fields))
1111  	{
1112  		IAssert(fields.Len() == 1);
1113  		int cp = reader.ParseCodePoint(fields[0]);
1114  		int i = h.GetKeyId(cp); IAssert(i >= 0);
1115  		h[i].flags |= ucfCompositionExclusion;
1116  		nExclusionTable++;
1117  	}
1118  	reader.Close();
1119  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1120  	{
1121  		int cp = h.GetKey(i);
1122  		TUniChInfo& ci = h[i];
1123  		int ofs = ci.decompOffset; if (ofs < 0) continue;
1124  		if (ci.IsCompositionExclusion()) continue;
1125  		if (ci.IsCompatibilityDecomposition()) continue;
1126  		int n = 0; while (decompositions[ofs + n] >= 0) n++;
1127  		if (n != 2) continue;
1128  		TIntPr pr = TIntPr(decompositions[ofs], decompositions[ofs + 1]);
1129  		IAssert(! inverseDec.IsKey(pr));
1130  		IAssert(ci.combClass == TUniChInfo::ccStarter);
1131  		inverseDec.AddDat(pr, cp);
1132  	}
1133  	printf("TUniChDb(%s): %d chars in h, %d in decomp inverse index; %d in decomp vector; %d in exclusion table\n",
1134  		basePath.CStr(), h.Len(), inverseDec.Len(), decompositions.Len(), nExclusionTable);
1135  	InitWordAndSentenceBoundaryFlags(basePath); 
1136  	for (int cp = HangulSBase; cp < HangulSBase + HangulSCount; cp++)
1137  	{
1138  		int j = h.GetKeyId(cp); if (j < 0) continue;
1139  		TUniChInfo& ci = h[j];
1140  		if (ci.combClass == TUniChInfo::ccInvalid) ci.combClass = TUniChInfo::ccStarter;
1141  		IAssert(ci.combClass == TUniChInfo::ccStarter);
1142  	}
1143  	const int oldHLen = h.Len();
1144  	int scriptUnknown = GetScriptByName(GetScriptNameUnknown());
1145  	for (int i = h.FFirstKeyId(); h.FNextKeyId(i); )
1146  	{
1147  		int cp = h.GetKey(i); TUniChInfo &ci = h[i];
1148  		if (ci.simpleLowerCaseMapping < 0) ci.simpleLowerCaseMapping = cp;
1149  		if (ci.simpleUpperCaseMapping < 0) ci.simpleUpperCaseMapping = cp;
1150  		if (ci.simpleTitleCaseMapping < 0) ci.simpleTitleCaseMapping = cp;
1151  		if (ci.script < 0) ci.script = scriptUnknown;
1152  	}
1153  	IAssert(h.Len() == oldHLen);
1154  }
1155  void TUniChDb::SaveBin(const TStr& fnBinUcd)
1156  {
1157  	PSOut SOut=TFOut::New(fnBinUcd);
1158  	Save(*SOut);
1159  }
1160  void TUniChDb::InitAfterLoad()
1161  {
1162  	scriptUnknown = GetScriptByName(GetScriptNameUnknown()); IAssert(scriptUnknown >= 0);
1163  }
1164  void TUniChDb::Test(const TStr& basePath)
1165  {
1166  	TStr fnBin = CombinePath(basePath, GetBinFn());
1167  	if (true || ! TFile::Exists(fnBin))
1168  	{
1169  		LoadTxt(basePath);
1170  		{PSOut SOut = TFOut::New(fnBin);
1171  		Save(*SOut);}
1172  	}
1173  	this->~TUniChDb();
1174  	new(this) TUniChDb();
1175  	{PSIn SIn = TFIn::New(fnBin);
1176  	Load(*SIn);}
1177  	caseFolding.Test();
1178  	TestWbFindNonIgnored();
1179  	TestFindNextWordOrSentenceBoundary(basePath, true);
1180  	TestFindNextWordOrSentenceBoundary(basePath, false);
1181  	TestComposition(basePath);
1182  	TestCaseConversions();
1183  }
1184  const int TEncoding_ISO8859_2::toUnicodeTable[6 * 16] =
1185  {
1186  	 0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7, 0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
1187  	 0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7, 0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
1188  	 0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
1189  	 0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
1190  	 0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
1191  	 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
1192  };
1193  const int TEncoding_ISO8859_2::fromUnicodeTable1[14 * 16] = {
1194  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1,     -1,
1195  	 0x00b0,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1, 0x00b8,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1196  	     -1, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1197  	     -1,     -1,     -1, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1,     -1, 0x00da,     -1, 0x00dc, 0x00dd,     -1, 0x00df,
1198  	     -1, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1199  	     -1,     -1,     -1, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1,     -1, 0x00fa,     -1, 0x00fc, 0x00fd,     -1,     -1,
1200  	     -1,     -1, 0x00c3, 0x00e3, 0x00a1, 0x00b1, 0x00c6, 0x00e6,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8, 0x00cf, 0x00ef,
1201  	 0x00d0, 0x00f0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ca, 0x00ea, 0x00cc, 0x00ec,     -1,     -1,     -1,     -1,
1202  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1203  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5, 0x00e5,     -1,     -1, 0x00a5, 0x00b5,     -1,
1204  	     -1, 0x00a3, 0x00b3, 0x00d1, 0x00f1,     -1,     -1, 0x00d2, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1205  	 0x00d5, 0x00f5,     -1,     -1, 0x00c0, 0x00e0,     -1,     -1, 0x00d8, 0x00f8, 0x00a6, 0x00b6,     -1,     -1, 0x00aa, 0x00ba,
1206  	 0x00a9, 0x00b9, 0x00de, 0x00fe, 0x00ab, 0x00bb,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d9, 0x00f9,
1207  	 0x00db, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ac, 0x00bc, 0x00af, 0x00bf, 0x00ae, 0x00be,     -1
1208  };
1209  const int TEncoding_ISO8859_2::fromUnicodeTable2[2 * 16] = {
1210  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00b7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1211  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a2, 0x00ff,     -1, 0x00b2,     -1, 0x00bd,     -1,     -1
1212  };
1213  const int TEncoding_ISO8859_3::toUnicodeTable[6 * 16] = {
1214  	 0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4,     -1, 0x0124, 0x00a7, 0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad,     -1, 0x017b,
1215  	 0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7, 0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd,     -1, 0x017c,
1216  	 0x00c0, 0x00c1, 0x00c2,     -1, 0x00c4, 0x010a, 0x0108, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
1217  	     -1, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7, 0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,
1218  	 0x00e0, 0x00e1, 0x00e2,     -1, 0x00e4, 0x010b, 0x0109, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
1219  	     -1, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7, 0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9
1220  };
1221  const int TEncoding_ISO8859_3::fromUnicodeTable1[14 * 16] = {
1222  	 0x00a0,     -1,     -1, 0x00a3, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1,     -1,
1223  	 0x00b0,     -1, 0x00b2, 0x00b3, 0x00b4, 0x00b5,     -1, 0x00b7, 0x00b8,     -1,     -1,     -1,     -1, 0x00bd,     -1,     -1,
1224  	 0x00c0, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
1225  	     -1, 0x00d1, 0x00d2, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1, 0x00d9, 0x00da, 0x00db, 0x00dc,     -1,     -1, 0x00df,
1226  	 0x00e0, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
1227  	     -1, 0x00f1, 0x00f2, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1, 0x00f9, 0x00fa, 0x00fb, 0x00fc,     -1,     -1,     -1,
1228  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c6, 0x00e6, 0x00c5, 0x00e5,     -1,     -1,     -1,     -1,
1229  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d8, 0x00f8, 0x00ab, 0x00bb,
1230  	 0x00d5, 0x00f5,     -1,     -1, 0x00a6, 0x00b6, 0x00a1, 0x00b1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1231  	 0x00a9, 0x00b9,     -1,     -1, 0x00ac, 0x00bc,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1232  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1233  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00de, 0x00fe, 0x00aa, 0x00ba,
1234  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00dd, 0x00fd,     -1,     -1,
1235  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00af, 0x00bf,     -1,     -1,     -1,
1236  };
1237  const int TEncoding_ISO8859_3::fromUnicodeTable2[2] = {
1238  	 0x00a2, 0x00ff
1239  };
1240  const int TEncoding_ISO8859_4::toUnicodeTable[6 * 16] = {
1241  	 0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7, 0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af,
1242  	 0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7, 0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,
1243  	 0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,
1244  	 0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,
1245  	 0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,
1246  	 0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9
1247  };
1248  const int TEncoding_ISO8859_4::fromUnicodeTable1[14 * 16] = {
1249  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1,     -1, 0x00a7, 0x00a8,     -1,     -1,     -1,     -1, 0x00ad,     -1, 0x00af,
1250  	 0x00b0,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1, 0x00b8,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1251  	     -1, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6,     -1,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1252  	     -1,     -1,     -1,     -1, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8,     -1, 0x00da, 0x00db, 0x00dc,     -1,     -1, 0x00df,
1253  	     -1, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6,     -1,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1254  	     -1,     -1,     -1,     -1, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8,     -1, 0x00fa, 0x00fb, 0x00fc,     -1,     -1,     -1,
1255  	 0x00c0, 0x00e0,     -1,     -1, 0x00a1, 0x00b1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8,     -1,     -1,
1256  	 0x00d0, 0x00f0, 0x00aa, 0x00ba,     -1,     -1, 0x00cc, 0x00ec, 0x00ca, 0x00ea,     -1,     -1,     -1,     -1,     -1,     -1,
1257  	     -1,     -1, 0x00ab, 0x00bb,     -1,     -1,     -1,     -1, 0x00a5, 0x00b5, 0x00cf, 0x00ef,     -1,     -1, 0x00c7, 0x00e7,
1258  	     -1,     -1,     -1,     -1,     -1,     -1, 0x00d3, 0x00f3, 0x00a2,     -1,     -1, 0x00a6, 0x00b6,     -1,     -1,     -1,
1259  	     -1,     -1,     -1,     -1,     -1, 0x00d1, 0x00f1,     -1,     -1,     -1, 0x00bd, 0x00bf, 0x00d2, 0x00f2,     -1,     -1,
1260  	     -1,     -1,     -1,     -1,     -1,     -1, 0x00a3, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1261  	 0x00a9, 0x00b9,     -1,     -1,     -1,     -1, 0x00ac, 0x00bc, 0x00dd, 0x00fd, 0x00de, 0x00fe,     -1,     -1,     -1,     -1,
1262  	     -1,     -1, 0x00d9, 0x00f9,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ae, 0x00be,     -1,
1263  };
1264  const int TEncoding_ISO8859_4::fromUnicodeTable2[2 * 16] = {
1265  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00b7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1266  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ff,     -1, 0x00b2,     -1,     -1,     -1,     -1
1267  };
1268  const int TEncoding_CP437::toUnicodeTable[8 * 16] = {
1269  	 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
1270  	 0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9, 0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
1271  	 0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
1272  	 0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
1273  	 0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f, 0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
1274  	 0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
1275  	 0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
1276  	 0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248, 0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
1277  };
1278  const int TEncoding_CP437::fromUnicodeTable1[6 * 16] = {
1279  	 0x00ff, 0x00ad, 0x009b, 0x009c,     -1, 0x009d,     -1,     -1,     -1,     -1, 0x00a6, 0x00ae, 0x00aa,     -1,     -1,     -1,
1280  	 0x00f8, 0x00f1, 0x00fd,     -1,     -1, 0x00e6,     -1, 0x00fa,     -1,     -1, 0x00a7, 0x00af, 0x00ac, 0x00ab,     -1, 0x00a8,
1281  	     -1,     -1,     -1,     -1, 0x008e, 0x008f, 0x0092, 0x0080,     -1, 0x0090,     -1,     -1,     -1,     -1,     -1,     -1,
1282  	     -1, 0x00a5,     -1,     -1,     -1,     -1, 0x0099,     -1,     -1,     -1,     -1,     -1, 0x009a,     -1,     -1, 0x00e1,
<span onclick='openModal()' class='match'>1283  	 0x0085, 0x00a0, 0x0083,     -1, 0x0084, 0x0086, 0x0091, 0x0087, 0x008a, 0x0082, 0x0088, 0x0089, 0x008d, 0x00a1, 0x008c, 0x008b,
1284  	     -1, 0x00a4, 0x0095, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1, 0x0097, 0x00a3, 0x0096, 0x0081,     -1,     -1, 0x0098,
</span>1285  };
1286  const int TEncoding_CP437::fromUnicodeTable2[4 * 16] = {
1287  	     -1,     -1,     -1, 0x00e2,     -1,     -1,     -1,     -1, 0x00e9,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1288  	     -1,     -1,     -1, 0x00e4,     -1,     -1, 0x00e8,     -1,     -1, 0x00ea,     -1,     -1,     -1,     -1,     -1,     -1,
1289  	     -1, 0x00e0,     -1,     -1, 0x00eb, 0x00ee,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1290  	 0x00e3,     -1,     -1, 0x00e5, 0x00e7,     -1, 0x00ed,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1291  };
1292  const int TEncoding_CP437::fromUnicodeTable3[6 * 16] = {
1293  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f9, 0x00fb,     -1,     -1,     -1, 0x00ec,     -1,
1294  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ef,     -1,     -1,     -1,     -1,     -1,     -1,
1295  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1296  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f7,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1297  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1298  	     -1, 0x00f0,     -1,     -1, 0x00f3, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1299  };
1300  const int TEncoding_CP437::fromUnicodeTable4[11 * 16] = {
1301  	 0x00c4,     -1, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00da,     -1,     -1,     -1,
1302  	 0x00bf,     -1,     -1,     -1, 0x00c0,     -1,     -1,     -1, 0x00d9,     -1,     -1,     -1, 0x00c3,     -1,     -1,     -1,
1303  	     -1,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c2,     -1,     -1,     -1,
1304  	     -1,     -1,     -1,     -1, 0x00c1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5,     -1,     -1,     -1,
1305  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1306  	 0x00cd, 0x00ba, 0x00d5, 0x00d6, 0x00c9, 0x00b8, 0x00b7, 0x00bb, 0x00d4, 0x00d3, 0x00c8, 0x00be, 0x00bd, 0x00bc, 0x00c6, 0x00c7,
1307  	 0x00cc, 0x00b5, 0x00b6, 0x00b9, 0x00d1, 0x00d2, 0x00cb, 0x00cf, 0x00d0, 0x00ca, 0x00d8, 0x00d7, 0x00ce,     -1,     -1,     -1,
1308  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1309  	 0x00df,     -1,     -1,     -1, 0x00dc,     -1,     -1,     -1, 0x00db,     -1,     -1,     -1, 0x00dd,     -1,     -1,     -1,
1310  	 0x00de, 0x00b0, 0x00b1, 0x00b2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1311  	 0x00fe,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1
1312  };
1313  const int TEncoding_CP852::toUnicodeTable[8 * 16] = {
1314  	 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x016f, 0x0107, 0x00e7, 0x0142, 0x00eb, 0x0150, 0x0151, 0x00ee, 0x0179, 0x00c4, 0x0106,
1315  	 0x00c9, 0x0139, 0x013a, 0x00f4, 0x00f6, 0x013d, 0x013e, 0x015a, 0x015b, 0x00d6, 0x00dc, 0x0164, 0x0165, 0x0141, 0x00d7, 0x010d,
1316  	 0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x0104, 0x0105, 0x017d, 0x017e, 0x0118, 0x0119, 0x00ac, 0x017a, 0x010c, 0x015f, 0x00ab, 0x00bb,
1317  	 0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1, 0x00c2, 0x011a, 0x015e, 0x2563, 0x2551, 0x2557, 0x255d, 0x017b, 0x017c, 0x2510,
1318  	 0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x0102, 0x0103, 0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x00a4,
1319  	 0x0111, 0x0110, 0x010e, 0x00cb, 0x010f, 0x0147, 0x00cd, 0x00ce, 0x011b, 0x2518, 0x250c, 0x2588, 0x2584, 0x0162, 0x016e, 0x2580,
1320  	 0x00d3, 0x00df, 0x00d4, 0x0143, 0x0144, 0x0148, 0x0160, 0x0161, 0x0154, 0x00da, 0x0155, 0x0170, 0x00fd, 0x00dd, 0x0163, 0x00b4,
1321  	 0x00ad, 0x02dd, 0x02db, 0x02c7, 0x02d8, 0x00a7, 0x00f7, 0x00b8, 0x00b0, 0x00a8, 0x02d9, 0x0171, 0x0158, 0x0159, 0x25a0, 0x00a0
1322  };
1323  const int TEncoding_CP852::fromUnicodeTable1[14 * 16] = {
1324  	 0x00ff,     -1,     -1,     -1, 0x00cf,     -1,     -1, 0x00f5, 0x00f9,     -1,     -1, 0x00ae, 0x00aa, 0x00f0,     -1,     -1,
1325  	 0x00f8,     -1,     -1,     -1, 0x00ef,     -1,     -1,     -1, 0x00f7,     -1,     -1, 0x00af,     -1,     -1,     -1,     -1,
1326  	     -1, 0x00b5, 0x00b6,     -1, 0x008e,     -1,     -1, 0x0080,     -1, 0x0090,     -1, 0x00d3,     -1, 0x00d6, 0x00d7,     -1,
1327  	     -1,     -1,     -1, 0x00e0, 0x00e2,     -1, 0x0099, 0x009e,     -1,     -1, 0x00e9,     -1, 0x009a, 0x00ed,     -1, 0x00e1,
1328  	     -1, 0x00a0, 0x0083,     -1, 0x0084,     -1,     -1, 0x0087,     -1, 0x0082,     -1, 0x0089,     -1, 0x00a1, 0x008c,     -1,
1329  	     -1,     -1,     -1, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1,     -1, 0x00a3,     -1, 0x0081, 0x00ec,     -1,     -1,
1330  	     -1,     -1, 0x00c6, 0x00c7, 0x00a4, 0x00a5, 0x008f, 0x0086,     -1,     -1,     -1,     -1, 0x00ac, 0x009f, 0x00d2, 0x00d4,
1331  	 0x00d1, 0x00d0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a8, 0x00a9, 0x00b7, 0x00d8,     -1,     -1,     -1,     -1,
1332  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1333  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x0091, 0x0092,     -1,     -1, 0x0095, 0x0096,     -1,
1334  	     -1, 0x009d, 0x0088, 0x00e3, 0x00e4,     -1,     -1, 0x00d5, 0x00e5,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1335  	 0x008a, 0x008b,     -1,     -1, 0x00e8, 0x00ea,     -1,     -1, 0x00fc, 0x00fd, 0x0097, 0x0098,     -1,     -1, 0x00b8, 0x00ad,
1336  	 0x00e6, 0x00e7, 0x00dd, 0x00ee, 0x009b, 0x009c,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00de, 0x0085,
1337  	 0x00eb, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008d, 0x00ab, 0x00bd, 0x00be, 0x00a6, 0x00a7,     -1
1338  };
1339  const int TEncoding_CP852::fromUnicodeTable2[2* 16] = {
1340  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1341  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00f4, 0x00fa,     -1, 0x00f2,     -1, 0x00f1,     -1,     -1
1342  };
1343  const int TEncoding_CP852::fromUnicodeTable3[11 * 16] = {
1344  	 0x00c4,     -1, 0x00b3,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00da,     -1,     -1,     -1,
1345  	 0x00bf,     -1,     -1,     -1, 0x00c0,     -1,     -1,     -1, 0x00d9,     -1,     -1,     -1, 0x00c3,     -1,     -1,     -1,
1346  	     -1,     -1,     -1,     -1, 0x00b4,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c2,     -1,     -1,     -1,
1347  	     -1,     -1,     -1,     -1, 0x00c1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5,     -1,     -1,     -1,
1348  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1349  	 0x00cd, 0x00ba,     -1,     -1, 0x00c9,     -1,     -1, 0x00bb,     -1,     -1, 0x00c8,     -1,     -1, 0x00bc,     -1,     -1,
1350  	 0x00cc,     -1,     -1, 0x00b9,     -1,     -1, 0x00cb,     -1,     -1, 0x00ca,     -1,     -1, 0x00ce,     -1,     -1,     -1,
1351  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1352  	 0x00df,     -1,     -1,     -1, 0x00dc,     -1,     -1,     -1, 0x00db,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1353  	     -1, 0x00b0, 0x00b1, 0x00b2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1354  	 0x00fe,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1
1355  };
1356  const int TEncoding_CP1250::toUnicodeTable[8 * 16] = {
1357  	 0x20ac,     -1, 0x201a,     -1, 0x201e, 0x2026, 0x2020, 0x2021,     -1, 0x2030, 0x0160, 0x2039, 0x015a, 0x0164, 0x017d, 0x0179,
1358  	     -1, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,     -1, 0x2122, 0x0161, 0x203a, 0x015b, 0x0165, 0x017e, 0x017a,
1359  	 0x00a0, 0x02c7, 0x02d8, 0x0141, 0x00a4, 0x0104, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x015e, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x017b,
1360  	 0x00b0, 0x00b1, 0x02db, 0x0142, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x0105, 0x015f, 0x00bb, 0x013d, 0x02dd, 0x013e, 0x017c,
1361  	 0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
1362  	 0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7, 0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
1363  	 0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
1364  	 0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7, 0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
1365  };
1366  const int TEncoding_CP1250::fromUnicodeTable1[14 * 16] = {
1367  	 0x00a0,     -1,     -1,     -1, 0x00a4,     -1, 0x00a6, 0x00a7, 0x00a8, 0x00a9,     -1, 0x00ab, 0x00ac, 0x00ad, 0x00ae,     -1,
1368  	 0x00b0, 0x00b1,     -1,     -1, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8,     -1,     -1, 0x00bb,     -1,     -1,     -1,     -1,
1369  	     -1, 0x00c1, 0x00c2,     -1, 0x00c4,     -1,     -1, 0x00c7,     -1, 0x00c9,     -1, 0x00cb,     -1, 0x00cd, 0x00ce,     -1,
1370  	     -1,     -1,     -1, 0x00d3, 0x00d4,     -1, 0x00d6, 0x00d7,     -1,     -1, 0x00da,     -1, 0x00dc, 0x00dd,     -1, 0x00df,
1371  	     -1, 0x00e1, 0x00e2,     -1, 0x00e4,     -1,     -1, 0x00e7,     -1, 0x00e9,     -1, 0x00eb,     -1, 0x00ed, 0x00ee,     -1,
1372  	     -1,     -1,     -1, 0x00f3, 0x00f4,     -1, 0x00f6, 0x00f7,     -1,     -1, 0x00fa,     -1, 0x00fc, 0x00fd,     -1,     -1,
1373  	     -1,     -1, 0x00c3, 0x00e3, 0x00a5, 0x00b9, 0x00c6, 0x00e6,     -1,     -1,     -1,     -1, 0x00c8, 0x00e8, 0x00cf, 0x00ef,
1374  	 0x00d0, 0x00f0,     -1,     -1,     -1,     -1,     -1,     -1, 0x00ca, 0x00ea, 0x00cc, 0x00ec,     -1,     -1,     -1,     -1,
1375  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1 ,
1376  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00c5, 0x00e5,     -1,     -1, 0x00bc, 0x00be,     -1,
1377  	     -1, 0x00a3, 0x00b3, 0x00d1, 0x00f1,     -1,     -1, 0x00d2, 0x00f2,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1378  	 0x00d5, 0x00f5,     -1,     -1, 0x00c0, 0x00e0,     -1,     -1, 0x00d8, 0x00f8, 0x008c, 0x009c,     -1,     -1, 0x00aa, 0x00ba,
1379  	 0x008a, 0x009a, 0x00de, 0x00fe, 0x008d, 0x009d,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00d9, 0x00f9,
1380  	 0x00db, 0x00fb,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008f, 0x009f, 0x00af, 0x00bf, 0x008e, 0x009e,     -1,
1381  };
1382  const int TEncoding_CP1250::fromUnicodeTable2[2 * 16] = {
1383  	     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1384  	     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x00a2, 0x00ff,     -1, 0x00b2,     -1, 0x00bd,     -1,     -1,
1385  };
1386  const int TEncoding_CP1250::fromUnicodeTable3[3 * 16] = {
1387  	     -1,     -1,     -1, 0x0096, 0x0097,     -1,     -1,     -1, 0x0091, 0x0092, 0x0082,     -1, 0x0093, 0x0094, 0x0084,     -1,
1388  	 0x0086, 0x0087, 0x0095,     -1,     -1,     -1, 0x0085,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
1389  	 0x0089,     -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1, 0x008b, 0x009b,     -1,     -1,     -1,     -1,     -1,
1390  };
1391  const int TEncoding_YuAscii::uniChars[10] =     {  0x106,  0x107,  0x10c,  0x10d,  0x160,  0x161,  0x17d,  0x17e,   0x110,  0x111  };
1392  const int TEncoding_YuAscii::yuAsciiChars[10] = {   0x5d,   0x7d,   0x5e,   0x7e,   0x5b,   0x7b,   0x40,   0x60,    0x5c,   0x7c  };
1393  void TUnicode::InitCodecs()
1394  {
1395  	ClrCodecs();
1396  	RegisterCodec("ISO-8859-1 ISO_8859-1 ISO_8859-1:1987 ISO-IR-100 CP819 IBM819 LATIN1 L1 csISOLatin1 ISO8859-1 ISO8859_1 CP28591", TCodecBase::New<TCodec_ISO8859_1>());
1397  	RegisterCodec("ISO-8859-2 ISO_8859-2 ISO_8859-2:1987 ISO-IR-101 LATIN2 L2 csISOLatin2 ISO8859-2 ISO8859_2 CP28592", TCodecBase::New<TCodec_ISO8859_2>());
1398  	RegisterCodec("ISO-8859-3 ISO_8859-3 ISO_8859-3:1988 ISO-IR-109 LATIN3 L3 csISOLatin3 ISO8859-3 ISO8859_3 CP28593", TCodecBase::New<TCodec_ISO8859_3>());
1399  	RegisterCodec("ISO-8859-4 ISO_8859-4 ISO_8859-4:1988 ISO-IR-110 LATIN4 L4 csISOLatin4 ISO8859-4 ISO8859_4 CP28594", TCodecBase::New<TCodec_ISO8859_4>());
1400  	RegisterCodec("YUASCII YU-ASCII YU_ASCII", TCodecBase::New<TCodec_YuAscii>());
1401  	RegisterCodec("CP1250 Windows-1250 MS-EE", TCodecBase::New<TCodec_CP1250>());
1402  	RegisterCodec("CP852 cp852_DOSLatin2 DOSLatin2", TCodecBase::New<TCodec_CP852>());
1403  	RegisterCodec("CP437 cp437_DOSLatinUS DOSLatinUS", TCodecBase::New<TCodec_CP437>());
1404  }
1405  void TUnicode::EncodeUtf8(const uint& c, TChA& dest) {
1406  	if (c > 0x10ffff) {
1407  		throw TExcept::New(TStr::Fmt("Unkown Unicode character %u", c)); }
1408  	if (c < 0x80u)
1409  		dest.AddCh(char(c & 0xffu));
1410  	else if (c < 0x800u) {
1411  		dest.AddCh(char(TUniCodec::_1100_0000 | ((c >> 6) & TUniCodec::_0001_1111)));
1412  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1413  	else if (c < 0x10000u) {
1414  		dest.AddCh(char(TUniCodec::_1110_0000 | ((c >> 12) & TUniCodec::_0000_1111)));
1415  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1416  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1417  	else if (c < 0x200000u) {
1418  		dest.AddCh(char(TUniCodec::_1111_0000 | ((c >> 18) & TUniCodec::_0000_0111)));
1419  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1420  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1421  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1422  	else if (c < 0x4000000u) {
1423  		dest.AddCh(char(TUniCodec::_1111_1000 | ((c >> 24) & TUniCodec::_0000_0011)));
1424  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 18) & TUniCodec::_0011_1111)));
1425  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1426  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1427  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1428  	else {
1429  		dest.AddCh(char(TUniCodec::_1111_1100 | ((c >> 30) & TUniCodec::_0000_0011)));
1430  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 24) & TUniCodec::_0011_1111)));
1431  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 18) & TUniCodec::_0011_1111)));
1432  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 12) & TUniCodec::_0011_1111)));
1433  		dest.AddCh(char(TUniCodec::_1000_0000 | ((c >> 6) & TUniCodec::_0011_1111)));
1434  		dest.AddCh(char(TUniCodec::_1000_0000 | (c & TUniCodec::_0011_1111))); }
1435  }
1436  TStr TUnicode::EncodeUtf8(const uint& Ch) {
1437  	TChA ChA; EncodeUtf8(Ch, ChA); return ChA;
1438  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-unicode.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1283  	 0x0085, 0x00a0, 0x0083,     -1, 0x0084, 0x0086, 0x0091, 0x0087, 0x008a, 0x0082, 0x0088, 0x0089, 0x008d, 0x00a1, 0x008c, 0x008b,
1284  	     -1, 0x00a4, 0x0095, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1, 0x0097, 0x00a3, 0x0096, 0x0081,     -1,     -1, 0x0098,
</pre></code></div>
                <div class="column column_space"><pre><code>1283  	 0x0085, 0x00a0, 0x0083,     -1, 0x0084, 0x0086, 0x0091, 0x0087, 0x008a, 0x0082, 0x0088, 0x0089, 0x008d, 0x00a1, 0x008c, 0x008b,
1284  	     -1, 0x00a4, 0x0095, 0x00a2, 0x0093,     -1, 0x0094, 0x00f6,     -1, 0x0097, 0x00a3, 0x0096, 0x0081,     -1,     -1, 0x0098,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    