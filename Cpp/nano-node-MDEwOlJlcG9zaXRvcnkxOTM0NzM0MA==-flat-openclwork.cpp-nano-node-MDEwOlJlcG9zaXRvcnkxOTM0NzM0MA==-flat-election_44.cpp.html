
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclwork.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/work.hpp>
3  #include <nano/node/openclconfig.hpp>
4  #include <nano/node/openclwork.hpp>
5  #include <nano/node/wallet.hpp>
6  #include <boost/format.hpp>
7  #include <array>
8  #include <string>
9  #include <vector>
10  #if defined(__APPLE__)
11  bool nano::opencl_loaded{ true };
12  #else
13  bool nano::opencl_loaded{ false };
14  #endif
15  namespace
16  {
17  std::string opencl_program = R"%%%(
18  enum Blake2b_IV {
19      iv0 = 0x6a09e667f3bcc908UL,
20      iv1 = 0xbb67ae8584caa73bUL,
21      iv2 = 0x3c6ef372fe94f82bUL,
22      iv3 = 0xa54ff53a5f1d36f1UL,
23      iv4 = 0x510e527fade682d1UL,
24      iv5 = 0x9b05688c2b3e6c1fUL,
25      iv6 = 0x1f83d9abfb41bd6bUL,
26      iv7 = 0x5be0cd19137e2179UL,
27  };
28  enum IV_Derived {
29      nano_xor_iv0 = 0x6a09e667f2bdc900UL,  
30      nano_xor_iv4 = 0x510e527fade682f9UL,  
31      nano_xor_iv6 = 0xe07c265404be4294UL,  
32  };
33  #ifdef cl_amd_media_ops
34  #pragma OPENCL EXTENSION cl_amd_media_ops : enable
35  static inline ulong rotr64(ulong x, int shift)
36  {
37      uint2 x2 = as_uint2(x);
38      if (shift < 32)
39          return as_ulong(amd_bitalign(x2.s10, x2, shift));
40      return as_ulong(amd_bitalign(x2, x2.s10, (shift - 32)));
41  }
42  #else
43  static inline ulong rotr64(ulong x, int shift)
44  {
45      return rotate(x, 64UL - shift);
46  }
47  #endif
48  #define G32(m0, m1, m2, m3, vva, vb1, vb2, vvc, vd1, vd2) \
49      do {                                                  \
50          vva += (ulong2)(vb1 + m0, vb2 + m2);              \
51          vd1 = rotr64(vd1 ^ vva.s0, 32);                   \
52          vd2 = rotr64(vd2 ^ vva.s1, 32);                   \
53          vvc += (ulong2)(vd1, vd2);                        \
54          vb1 = rotr64(vb1 ^ vvc.s0, 24);                   \
55          vb2 = rotr64(vb2 ^ vvc.s1, 24);                   \
56          vva += (ulong2)(vb1 + m1, vb2 + m3);              \
57          vd1 = rotr64(vd1 ^ vva.s0, 16);                   \
58          vd2 = rotr64(vd2 ^ vva.s1, 16);                   \
59          vvc += (ulong2)(vd1, vd2);                        \
60          vb1 = rotr64(vb1 ^ vvc.s0, 63);                   \
61          vb2 = rotr64(vb2 ^ vvc.s1, 63);                   \
62      } while (0)
63  #define G2v(m0, m1, m2, m3, a, b, c, d)                                   \
64      G32(m0, m1, m2, m3, vv[a / 2], vv[b / 2].s0, vv[b / 2].s1, vv[c / 2], \
65          vv[d / 2].s0, vv[d / 2].s1)
66  #define G2v_split(m0, m1, m2, m3, a, vb1, vb2, c, vd1, vd2) \
67      G32(m0, m1, m2, m3, vv[a / 2], vb1, vb2, vv[c / 2], vd1, vd2)
68  #define ROUND(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, \
69                m15)                                                             \
70      do {                                                                       \
71          G2v(m0, m1, m2, m3, 0, 4, 8, 12);                                      \
72          G2v(m4, m5, m6, m7, 2, 6, 10, 14);                                     \
73          G2v_split(m8, m9, m10, m11, 0, vv[5 / 2].s1, vv[6 / 2].s0, 10,         \
74                    vv[15 / 2].s1, vv[12 / 2].s0);                               \
75          G2v_split(m12, m13, m14, m15, 2, vv[7 / 2].s1, vv[4 / 2].s0, 8,        \
76                    vv[13 / 2].s1, vv[14 / 2].s0);                               \
77      } while (0)
78  static inline ulong blake2b(ulong const nonce, __constant ulong *h)
79  {
80      ulong2 vv[8] = {
81          {nano_xor_iv0, iv1}, {iv2, iv3},          {iv4, iv5},
82          {iv6, iv7},          {iv0, iv1},          {iv2, iv3},
83          {nano_xor_iv4, iv5}, {nano_xor_iv6, iv7},
84      };
85      ROUND(nonce, h[0], h[1], h[2], h[3], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
86      ROUND(0, 0, h[3], 0, 0, 0, 0, 0, h[0], 0, nonce, h[1], 0, 0, 0, h[2]);
87      ROUND(0, 0, 0, nonce, 0, h[1], 0, 0, 0, 0, h[2], 0, 0, h[0], 0, h[3]);
88      ROUND(0, 0, h[2], h[0], 0, 0, 0, 0, h[1], 0, 0, 0, h[3], nonce, 0, 0);
89      ROUND(0, nonce, 0, 0, h[1], h[3], 0, 0, 0, h[0], 0, 0, 0, 0, h[2], 0);
90      ROUND(h[1], 0, 0, 0, nonce, 0, 0, h[2], h[3], 0, 0, 0, 0, 0, h[0], 0);
91      ROUND(0, 0, h[0], 0, 0, 0, h[3], 0, nonce, 0, 0, h[2], 0, h[1], 0, 0);
92      ROUND(0, 0, 0, 0, 0, h[0], h[2], 0, 0, nonce, 0, h[3], 0, 0, h[1], 0);
93      ROUND(0, 0, 0, 0, 0, h[2], nonce, 0, 0, h[1], 0, 0, h[0], h[3], 0, 0);
94      ROUND(0, h[1], 0, h[3], 0, 0, h[0], 0, 0, 0, 0, 0, h[2], 0, 0, nonce);
95      ROUND(nonce, h[0], h[1], h[2], h[3], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
96      ROUND(0, 0, h[3], 0, 0, 0, 0, 0, h[0], 0, nonce, h[1], 0, 0, 0, h[2]);
97      return nano_xor_iv0 ^ vv[0].s0 ^ vv[4].s0;
98  }
99  #undef G32
100  #undef G2v
101  #undef G2v_split
102  #undef ROUND
103  __kernel void nano_work(__constant ulong *attempt,
104                          __global ulong *result_a,
105                          __constant uchar *item_a,
106                          __constant ulong *difficulty)
107  {
108      const ulong attempt_l = *attempt + get_global_id(0);
109      if (blake2b(attempt_l, item_a) >= *difficulty)
110          *result_a = attempt_l;
111  }
112  )%%%";
113  }
114  nano::opencl_environment::opencl_environment (bool & error_a)
115  {
116  	if (nano::opencl_loaded)
117  	{
118  		cl_uint platformIdCount = 0;
119  		clGetPlatformIDs (0, nullptr, &platformIdCount);
120  		std::vector<cl_platform_id> platformIds (platformIdCount);
121  		clGetPlatformIDs (platformIdCount, platformIds.data (), nullptr);
122  		for (auto i (platformIds.begin ()), n (platformIds.end ()); i != n; ++i)
123  		{
124  			nano::opencl_platform platform;
125  			platform.platform = *i;
126  			cl_uint deviceIdCount = 0;
127  			clGetDeviceIDs (*i, CL_DEVICE_TYPE_ALL, 0, nullptr, &deviceIdCount);
128  			std::vector<cl_device_id> deviceIds (deviceIdCount);
129  			clGetDeviceIDs (*i, CL_DEVICE_TYPE_ALL, deviceIdCount, deviceIds.data (), nullptr);
130  			for (auto j (deviceIds.begin ()), m (deviceIds.end ()); j != m; ++j)
131  			{
132  				platform.devices.push_back (*j);
133  			}
134  			platforms.push_back (platform);
135  		}
136  	}
137  	else
138  	{
139  		error_a = true;
140  	}
141  }
142  void nano::opencl_environment::dump (std::ostream & stream)
143  {
144  	if (nano::opencl_loaded)
145  	{
146  		auto index (0);
<span onclick='openModal()' class='match'>147  		std::size_t device_count (0);
148  		for (auto & i : platforms)
149  		{
150  			device_count += i.devices.size ();
</span>151  		}
152  		stream << boost::str (boost::format ("OpenCL found %1% platforms and %2% devices\n") % platforms.size () % device_count);
153  		for (auto i (platforms.begin ()), n (platforms.end ()); i != n; ++i, ++index)
154  		{
155  			std::vector<unsigned> queries = { CL_PLATFORM_PROFILE, CL_PLATFORM_VERSION, CL_PLATFORM_NAME, CL_PLATFORM_VENDOR, CL_PLATFORM_EXTENSIONS };
156  			stream << "Platform: " << index << std::endl;
157  			for (auto j (queries.begin ()), m (queries.end ()); j != m; ++j)
158  			{
159  				std::size_t platformInfoCount = 0;
160  				clGetPlatformInfo (i->platform, *j, 0, nullptr, &platformInfoCount);
161  				std::vector<char> info (platformInfoCount);
162  				clGetPlatformInfo (i->platform, *j, info.size (), info.data (), nullptr);
163  				stream << info.data () << std::endl;
164  			}
165  			for (auto j (i->devices.begin ()), m (i->devices.end ()); j != m; ++j)
166  			{
167  				std::vector<unsigned> queries = { CL_DEVICE_NAME, CL_DEVICE_VENDOR, CL_DEVICE_PROFILE };
168  				stream << "Device: " << j - i->devices.begin () << std::endl;
169  				for (auto k (queries.begin ()), o (queries.end ()); k != o; ++k)
170  				{
171  					std::size_t platformInfoCount = 0;
172  					clGetDeviceInfo (*j, *k, 0, nullptr, &platformInfoCount);
173  					std::vector<char> info (platformInfoCount);
174  					clGetDeviceInfo (*j, *k, info.size (), info.data (), nullptr);
175  					stream << '\t' << info.data () << std::endl;
176  				}
177  				std::size_t deviceTypeCount = 0;
178  				clGetDeviceInfo (*j, CL_DEVICE_TYPE, 0, nullptr, &deviceTypeCount);
179  				std::vector<uint8_t> deviceTypeInfo (deviceTypeCount);
180  				clGetDeviceInfo (*j, CL_DEVICE_TYPE, deviceTypeCount, deviceTypeInfo.data (), 0);
181  				std::string device_type_string;
182  				switch (deviceTypeInfo[0])
183  				{
184  					case CL_DEVICE_TYPE_ACCELERATOR:
185  						device_type_string = "ACCELERATOR";
186  						break;
187  					case CL_DEVICE_TYPE_CPU:
188  						device_type_string = "CPU";
189  						break;
190  					case CL_DEVICE_TYPE_CUSTOM:
191  						device_type_string = "CUSTOM";
192  						break;
193  					case CL_DEVICE_TYPE_DEFAULT:
194  						device_type_string = "DEFAULT";
195  						break;
196  					case CL_DEVICE_TYPE_GPU:
197  						device_type_string = "GPU";
198  						break;
199  					default:
200  						device_type_string = "Unknown";
201  						break;
202  				}
203  				stream << '\t' << device_type_string << std::endl;
204  				std::size_t compilerAvailableCount = 0;
205  				clGetDeviceInfo (*j, CL_DEVICE_COMPILER_AVAILABLE, 0, nullptr, &compilerAvailableCount);
206  				std::vector<uint8_t> compilerAvailableInfo (compilerAvailableCount);
207  				clGetDeviceInfo (*j, CL_DEVICE_COMPILER_AVAILABLE, compilerAvailableCount, compilerAvailableInfo.data (), 0);
208  				stream << "\tCompiler available: " << (compilerAvailableInfo[0] ? "true" : "false") << std::endl;
209  				std::size_t computeUnitsAvailableCount = 0;
210  				clGetDeviceInfo (*j, CL_DEVICE_MAX_COMPUTE_UNITS, 0, nullptr, &computeUnitsAvailableCount);
211  				std::vector<uint8_t> computeUnitsAvailableInfo (computeUnitsAvailableCount);
212  				clGetDeviceInfo (*j, CL_DEVICE_MAX_COMPUTE_UNITS, computeUnitsAvailableCount, computeUnitsAvailableInfo.data (), 0);
213  				uint64_t computeUnits (computeUnitsAvailableInfo[0] | (computeUnitsAvailableInfo[1] << 8) | (computeUnitsAvailableInfo[2] << 16) | (computeUnitsAvailableInfo[3] << 24));
214  				stream << "\tCompute units available: " << computeUnits << std::endl;
215  				cl_ulong size{ 0 };
216  				clGetDeviceInfo (*j, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof (cl_ulong), &size, 0);
217  				stream << "\tMemory size" << std::endl;
218  				stream << "\t\tConstant buffer: " << size << std::endl;
219  				clGetDeviceInfo (*j, CL_DEVICE_LOCAL_MEM_SIZE, sizeof (cl_ulong), &size, 0);
220  				stream << "\t\tLocal memory   : " << size << std::endl;
221  				clGetDeviceInfo (*j, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof (cl_ulong), &size, 0);
222  				stream << "\t\tGlobal memory  : " << size << std::endl;
223  				clGetDeviceInfo (*j, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, sizeof (cl_ulong), &size, 0);
224  				stream << "\t\tGlobal cache   : " << size << std::endl;
225  				clGetDeviceInfo (*j, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof (cl_ulong), &size, 0);
226  				stream << "\t\tMax allocation : " << size << std::endl;
227  			}
228  		}
229  	}
230  	else
231  	{
232  		stream << boost::str (boost::format ("OpenCL library could not be found\n"));
233  	}
234  }
235  nano::opencl_work::opencl_work (bool & error_a, nano::opencl_config const & config_a, nano::opencl_environment & environment_a, nano::logger_mt & logger_a, nano::work_thresholds & work) :
236  	config (config_a),
237  	context (0),
238  	attempt_buffer (0),
239  	result_buffer (0),
240  	item_buffer (0),
241  	difficulty_buffer (0),
242  	program (0),
243  	kernel (0),
244  	queue (0),
245  	logger (logger_a),
246  	work{ work }
247  {
248  	error_a |= config.platform >= environment_a.platforms.size ();
249  	if (!error_a)
250  	{
251  		auto & platform (environment_a.platforms[config.platform]);
252  		error_a |= config.device >= platform.devices.size ();
253  		if (!error_a)
254  		{
255  			nano::random_pool::generate_block (reinterpret_cast<uint8_t *> (rand.s.data ()), rand.s.size () * sizeof (decltype (rand.s)::value_type));
256  			std::array<cl_device_id, 1> selected_devices;
257  			selected_devices[0] = platform.devices[config.device];
258  			cl_context_properties contextProperties[] = {
259  				CL_CONTEXT_PLATFORM,
260  				reinterpret_cast<cl_context_properties> (platform.platform),
261  				0, 0
262  			};
263  			cl_int createContextError (0);
264  			context = clCreateContext (contextProperties, static_cast<cl_uint> (selected_devices.size ()), selected_devices.data (), nullptr, nullptr, &createContextError);
265  			error_a |= createContextError != CL_SUCCESS;
266  			if (!error_a)
267  			{
268  				cl_int queue_error (0);
269  				queue = clCreateCommandQueue (context, selected_devices[0], 0, &queue_error);
270  				error_a |= queue_error != CL_SUCCESS;
271  				if (!error_a)
272  				{
273  					cl_int attempt_error (0);
274  					attempt_buffer = clCreateBuffer (context, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, sizeof (uint64_t), nullptr, &attempt_error);
275  					error_a |= attempt_error != CL_SUCCESS;
276  					if (!error_a)
277  					{
278  						cl_int result_error (0);
279  						result_buffer = clCreateBuffer (context, CL_MEM_WRITE_ONLY | CL_MEM_HOST_READ_ONLY, sizeof (uint64_t), nullptr, &result_error);
280  						error_a |= result_error != CL_SUCCESS;
281  						if (!error_a)
282  						{
283  							cl_int item_error (0);
284  							std::size_t item_size (sizeof (nano::uint256_union));
285  							item_buffer = clCreateBuffer (context, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, item_size, nullptr, &item_error);
286  							error_a |= item_error != CL_SUCCESS;
287  							if (!error_a)
288  							{
289  								cl_int difficulty_error (0);
290  								difficulty_buffer = clCreateBuffer (context, CL_MEM_READ_ONLY | CL_MEM_HOST_WRITE_ONLY, sizeof (uint64_t), nullptr, &difficulty_error);
291  								error_a |= difficulty_error != CL_SUCCESS;
292  								if (!error_a)
293  								{
294  									cl_int program_error (0);
295  									char const * program_data (opencl_program.data ());
296  									std::size_t program_length (opencl_program.size ());
297  									program = clCreateProgramWithSource (context, 1, &program_data, &program_length, &program_error);
298  									error_a |= program_error != CL_SUCCESS;
299  									if (!error_a)
300  									{
301  										auto clBuildProgramError (clBuildProgram (program, static_cast<cl_uint> (selected_devices.size ()), selected_devices.data (), "-D __APPLE__", nullptr, nullptr));
302  										error_a |= clBuildProgramError != CL_SUCCESS;
303  										if (!error_a)
304  										{
305  											cl_int kernel_error (0);
306  											kernel = clCreateKernel (program, "nano_work", &kernel_error);
307  											error_a |= kernel_error != CL_SUCCESS;
308  											if (!error_a)
309  											{
310  												cl_int arg0_error (clSetKernelArg (kernel, 0, sizeof (attempt_buffer), &attempt_buffer));
311  												error_a |= arg0_error != CL_SUCCESS;
312  												if (!error_a)
313  												{
314  													cl_int arg1_error (clSetKernelArg (kernel, 1, sizeof (result_buffer), &result_buffer));
315  													error_a |= arg1_error != CL_SUCCESS;
316  													if (!error_a)
317  													{
318  														cl_int arg2_error (clSetKernelArg (kernel, 2, sizeof (item_buffer), &item_buffer));
319  														error_a |= arg2_error != CL_SUCCESS;
320  														if (!error_a)
321  														{
322  															cl_int arg3_error (clSetKernelArg (kernel, 3, sizeof (difficulty_buffer), &difficulty_buffer));
323  															error_a |= arg3_error != CL_SUCCESS;
324  															if (!error_a)
325  															{
326  															}
327  															else
328  															{
329  																logger.always_log (boost::str (boost::format ("Bind argument 3 error %1%") % arg3_error));
330  															}
331  														}
332  														else
333  														{
334  															logger.always_log (boost::str (boost::format ("Bind argument 2 error %1%") % arg2_error));
335  														}
336  													}
337  													else
338  													{
339  														logger.always_log (boost::str (boost::format ("Bind argument 1 error %1%") % arg1_error));
340  													}
341  												}
342  												else
343  												{
344  													logger.always_log (boost::str (boost::format ("Bind argument 0 error %1%") % arg0_error));
345  												}
346  											}
347  											else
348  											{
349  												logger.always_log (boost::str (boost::format ("Create kernel error %1%") % kernel_error));
350  											}
351  										}
352  										else
353  										{
354  											logger.always_log (boost::str (boost::format ("Build program error %1%") % clBuildProgramError));
355  											for (auto i (selected_devices.begin ()), n (selected_devices.end ()); i != n; ++i)
356  											{
357  												std::size_t log_size (0);
358  												clGetProgramBuildInfo (program, *i, CL_PROGRAM_BUILD_LOG, 0, nullptr, &log_size);
359  												std::vector<char> log (log_size);
360  												clGetProgramBuildInfo (program, *i, CL_PROGRAM_BUILD_LOG, log.size (), log.data (), nullptr);
361  												logger.always_log (log.data ());
362  											}
363  										}
364  									}
365  									else
366  									{
367  										logger.always_log (boost::str (boost::format ("Create program error %1%") % program_error));
368  									}
369  								}
370  								else
371  								{
372  									logger.always_log (boost::str (boost::format ("Difficulty buffer error %1%") % difficulty_error));
373  								}
374  							}
375  							else
376  							{
377  								logger.always_log (boost::str (boost::format ("Item buffer error %1%") % item_error));
378  							}
379  						}
380  						else
381  						{
382  							logger.always_log (boost::str (boost::format ("Result buffer error %1%") % result_error));
383  						}
384  					}
385  					else
386  					{
387  						logger.always_log (boost::str (boost::format ("Attempt buffer error %1%") % attempt_error));
388  					}
389  				}
390  				else
391  				{
392  					logger.always_log (boost::str (boost::format ("Unable to create command queue %1%") % queue_error));
393  				}
394  			}
395  			else
396  			{
397  				logger.always_log (boost::str (boost::format ("Unable to create context %1%") % createContextError));
398  			}
399  		}
400  		else
401  		{
402  			logger.always_log (boost::str (boost::format ("Requested device %1%, and only have %2%") % config.device % platform.devices.size ()));
403  		}
404  	}
405  	else
406  	{
407  		logger.always_log (boost::str (boost::format ("Requested platform %1% and only have %2%") % config.platform % environment_a.platforms.size ()));
408  	}
409  }
410  nano::opencl_work::~opencl_work ()
411  {
412  	if (kernel != 0)
413  	{
414  		clReleaseKernel (kernel);
415  	}
416  	if (program != 0)
417  	{
418  		clReleaseProgram (program);
419  	}
420  	if (context != 0)
421  	{
422  		clReleaseContext (context);
423  	}
424  }
425  boost::optional<uint64_t> nano::opencl_work::generate_work (nano::work_version const version_a, nano::root const & root_a, uint64_t const difficulty_a)
426  {
427  	std::atomic<int> ticket_l{ 0 };
428  	return generate_work (version_a, root_a, difficulty_a, ticket_l);
429  }
430  boost::optional<uint64_t> nano::opencl_work::generate_work (nano::work_version const version_a, nano::root const & root_a, uint64_t const difficulty_a, std::atomic<int> & ticket_a)
431  {
432  	nano::lock_guard<nano::mutex> lock{ mutex };
433  	bool error (false);
434  	int ticket_l (ticket_a);
435  	uint64_t result (0);
436  	unsigned thread_count (config.threads);
437  	std::size_t work_size[] = { thread_count, 0, 0 };
438  	while (work.difficulty (version_a, root_a, result) < difficulty_a && !error && ticket_a == ticket_l)
439  	{
440  		result = rand.next ();
441  		cl_int write_error1 = clEnqueueWriteBuffer (queue, attempt_buffer, false, 0, sizeof (uint64_t), &result, 0, nullptr, nullptr);
442  		if (write_error1 == CL_SUCCESS)
443  		{
444  			cl_int write_error2 = clEnqueueWriteBuffer (queue, item_buffer, false, 0, sizeof (nano::root), root_a.bytes.data (), 0, nullptr, nullptr);
445  			if (write_error2 == CL_SUCCESS)
446  			{
447  				cl_int write_error3 = clEnqueueWriteBuffer (queue, difficulty_buffer, false, 0, sizeof (uint64_t), &difficulty_a, 0, nullptr, nullptr);
448  				if (write_error3 == CL_SUCCESS)
449  				{
450  					cl_int enqueue_error = clEnqueueNDRangeKernel (queue, kernel, 1, nullptr, work_size, nullptr, 0, nullptr, nullptr);
451  					if (enqueue_error == CL_SUCCESS)
452  					{
453  						cl_int read_error1 = clEnqueueReadBuffer (queue, result_buffer, false, 0, sizeof (uint64_t), &result, 0, nullptr, nullptr);
454  						if (read_error1 == CL_SUCCESS)
455  						{
456  							cl_int finishError = clFinish (queue);
457  							if (finishError == CL_SUCCESS)
458  							{
459  							}
460  							else
461  							{
462  								error = true;
463  								logger.always_log (boost::str (boost::format ("Error finishing queue %1%") % finishError));
464  							}
465  						}
466  						else
467  						{
468  							error = true;
469  							logger.always_log (boost::str (boost::format ("Error reading result %1%") % read_error1));
470  						}
471  					}
472  					else
473  					{
474  						error = true;
475  						logger.always_log (boost::str (boost::format ("Error enqueueing kernel %1%") % enqueue_error));
476  					}
477  				}
478  				else
479  				{
480  					error = true;
481  					logger.always_log (boost::str (boost::format ("Error writing item %1%") % write_error3));
482  				}
483  			}
484  			else
485  			{
486  				error = true;
487  				logger.always_log (boost::str (boost::format ("Error writing item %1%") % write_error2));
488  			}
489  		}
490  		else
491  		{
492  			error = true;
493  			logger.always_log (boost::str (boost::format ("Error writing attempt %1%") % write_error1));
494  		}
495  	}
496  	boost::optional<uint64_t> value;
497  	if (!error)
498  	{
499  		value = result;
500  	}
501  	return value;
502  }
503  std::unique_ptr<nano::opencl_work> nano::opencl_work::create (bool create_a, nano::opencl_config const & config_a, nano::logger_mt & logger_a, nano::work_thresholds & work)
504  {
505  	std::unique_ptr<nano::opencl_work> result;
506  	if (create_a)
507  	{
508  		auto error (false);
509  		nano::opencl_environment environment (error);
510  		std::stringstream stream;
511  		environment.dump (stream);
512  		logger_a.always_log (stream.str ());
513  		if (!error)
514  		{
515  			result.reset (new nano::opencl_work (error, config_a, environment, logger_a, work));
516  			if (error)
517  			{
518  				result.reset ();
519  			}
520  		}
521  	}
522  	return result;
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-election_44.cpp</h3>
            <pre><code>1  #include <nano/node/confirmation_solicitor.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/network.hpp>
4  #include <nano/node/node.hpp>
5  #include <boost/format.hpp>
6  using namespace std::chrono;
7  std::chrono::milliseconds nano::election::base_latency () const
8  {
9  	return node.network_params.network.is_dev_network () ? 25ms : 1000ms;
10  }
11  nano::election_vote_result::election_vote_result (bool replay_a, bool processed_a)
12  {
13  	replay = replay_a;
14  	processed = processed_a;
15  }
16  nano::election::election (nano::node & node_a, std::shared_ptr<nano::block> const & block_a, std::function<void (std::shared_ptr<nano::block> const &)> const & confirmation_action_a, std::function<void (nano::account const &)> const & live_vote_action_a, nano::election_behavior election_behavior_a) :
17  	confirmation_action (confirmation_action_a),
18  	live_vote_action (live_vote_action_a),
19  	node (node_a),
20  	behavior_m (election_behavior_a),
21  	status ({ block_a, 0, 0, std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now ().time_since_epoch ()), std::chrono::duration_values<std::chrono::milliseconds>::zero (), 0, 1, 0, nano::election_status_type::ongoing }),
22  	height (block_a->sideband ().height),
23  	root (block_a->root ()),
24  	qualified_root (block_a->qualified_root ())
25  {
26  	last_votes.emplace (nano::account::null (), nano::vote_info{ std::chrono::steady_clock::now (), 0, block_a->hash () });
27  	last_blocks.emplace (block_a->hash (), block_a);
28  }
29  void nano::election::confirm_once (nano::unique_lock<nano::mutex> & lock_a, nano::election_status_type type_a)
30  {
31  	debug_assert (lock_a.owns_lock ());
32  	nano::unique_lock<nano::mutex> election_winners_lk{ node.active.election_winner_details_mutex };
33  	if (state_m.exchange (nano::election::state_t::confirmed) != nano::election::state_t::confirmed && (node.active.election_winner_details.count (status.winner->hash ()) == 0))
34  	{
35  		node.active.election_winner_details.emplace (status.winner->hash (), shared_from_this ());
36  		election_winners_lk.unlock ();
37  		status.election_end = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now ().time_since_epoch ());
38  		status.election_duration = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now () - election_start);
39  		status.confirmation_request_count = confirmation_request_count;
40  		status.block_count = nano::narrow_cast<decltype (status.block_count)> (last_blocks.size ());
41  		status.voter_count = nano::narrow_cast<decltype (status.voter_count)> (last_votes.size ());
42  		status.type = type_a;
43  		auto const status_l = status;
44  		lock_a.unlock ();
45  		node.background ([node_l = node.shared (), status_l, confirmation_action_l = confirmation_action] () {
46  			node_l->process_confirmed (status_l);
47  			if (confirmation_action_l)
48  			{
49  				confirmation_action_l (status_l.winner);
50  			}
51  		});
52  	}
53  	else
54  	{
55  		lock_a.unlock ();
56  	}
57  }
58  bool nano::election::valid_change (nano::election::state_t expected_a, nano::election::state_t desired_a) const
59  {
60  	bool result = false;
61  	switch (expected_a)
62  	{
63  		case nano::election::state_t::passive:
64  			switch (desired_a)
65  			{
66  				case nano::election::state_t::active:
67  				case nano::election::state_t::confirmed:
68  				case nano::election::state_t::expired_unconfirmed:
69  					result = true;
70  					break;
71  				default:
72  					break;
73  			}
74  			break;
75  		case nano::election::state_t::active:
76  			switch (desired_a)
77  			{
78  				case nano::election::state_t::confirmed:
79  				case nano::election::state_t::expired_unconfirmed:
80  					result = true;
81  					break;
82  				default:
83  					break;
84  			}
85  			break;
86  		case nano::election::state_t::confirmed:
87  			switch (desired_a)
88  			{
89  				case nano::election::state_t::expired_confirmed:
90  					result = true;
91  					break;
92  				default:
93  					break;
94  			}
95  			break;
96  		case nano::election::state_t::expired_unconfirmed:
97  		case nano::election::state_t::expired_confirmed:
98  			break;
99  	}
100  	return result;
101  }
102  bool nano::election::state_change (nano::election::state_t expected_a, nano::election::state_t desired_a)
103  {
104  	bool result = true;
105  	if (valid_change (expected_a, desired_a))
106  	{
107  		if (state_m.compare_exchange_strong (expected_a, desired_a))
108  		{
109  			state_start = std::chrono::steady_clock::now ().time_since_epoch ();
110  			result = false;
111  		}
112  	}
113  	return result;
114  }
115  bool nano::election::confirmed (nano::unique_lock<nano::mutex> & lock) const
116  {
117  	return node.block_confirmed (status.winner->hash ());
118  }
119  std::chrono::milliseconds nano::election::confirm_req_time () const
120  {
121  	switch (behavior ())
122  	{
123  		case election_behavior::normal:
124  		case election_behavior::hinted:
125  			return base_latency () * 5;
126  		case election_behavior::optimistic:
127  			return base_latency () * 2;
128  	}
129  	debug_assert (false);
130  	return {};
131  }
132  void nano::election::send_confirm_req (nano::confirmation_solicitor & solicitor_a)
133  {
134  	if (confirm_req_time () < (std::chrono::steady_clock::now () - last_req))
135  	{
136  		nano::lock_guard<nano::mutex> guard{ mutex };
137  		if (!solicitor_a.add (*this))
138  		{
139  			last_req = std::chrono::steady_clock::now ();
140  			++confirmation_request_count;
141  		}
142  	}
143  }
144  void nano::election::transition_active ()
145  {
146  	state_change (nano::election::state_t::passive, nano::election::state_t::active);
147  }
148  bool nano::election::confirmed () const
149  {
150  	nano::unique_lock<nano::mutex> lock{ mutex };
151  	return confirmed (lock);
152  }
153  bool nano::election::status_confirmed () const
154  {
155  	return state_m == nano::election::state_t::confirmed || state_m == nano::election::state_t::expired_confirmed;
156  }
157  bool nano::election::failed () const
158  {
159  	return state_m == nano::election::state_t::expired_unconfirmed;
160  }
161  void nano::election::broadcast_block (nano::confirmation_solicitor & solicitor_a)
162  {
163  	if (base_latency () * 15 < std::chrono::steady_clock::now () - last_block)
164  	{
165  		nano::lock_guard<nano::mutex> guard{ mutex };
166  		if (!solicitor_a.broadcast (*this))
167  		{
168  			last_block = std::chrono::steady_clock::now ();
169  		}
170  	}
171  }
172  void nano::election::broadcast_vote ()
173  {
174  	nano::unique_lock<nano::mutex> lock{ mutex };
175  	if (last_vote + std::chrono::milliseconds (node.config.network_params.network.vote_broadcast_interval) < std::chrono::steady_clock::now ())
176  	{
177  		broadcast_vote_impl (lock);
178  		last_vote = std::chrono::steady_clock::now ();
179  	}
180  }
181  bool nano::election::transition_time (nano::confirmation_solicitor & solicitor_a)
182  {
183  	bool result = false;
184  	switch (state_m)
185  	{
186  		case nano::election::state_t::passive:
187  			if (base_latency () * passive_duration_factor < std::chrono::steady_clock::now ().time_since_epoch () - state_start.load ())
188  			{
189  				state_change (nano::election::state_t::passive, nano::election::state_t::active);
190  			}
191  			break;
192  		case nano::election::state_t::active:
193  			broadcast_vote ();
194  			broadcast_block (solicitor_a);
195  			send_confirm_req (solicitor_a);
196  			break;
197  		case nano::election::state_t::confirmed:
198  			result = true; 
199  			state_change (nano::election::state_t::confirmed, nano::election::state_t::expired_confirmed);
200  			break;
201  		case nano::election::state_t::expired_unconfirmed:
202  		case nano::election::state_t::expired_confirmed:
203  			debug_assert (false);
204  			break;
205  	}
206  	if (!confirmed () && time_to_live () < std::chrono::steady_clock::now () - election_start)
207  	{
208  		nano::lock_guard<nano::mutex> guard{ mutex };
209  		if (!state_change (state_m.load (), nano::election::state_t::expired_unconfirmed))
210  		{
211  			result = true; 
212  			if (node.config.logging.election_expiration_tally_logging ())
213  			{
214  				log_votes (tally_impl (), "Election expired: ");
215  			}
216  			status.type = nano::election_status_type::stopped;
217  		}
218  	}
219  	return result;
220  }
221  std::chrono::milliseconds nano::election::time_to_live () const
222  {
223  	switch (behavior ())
224  	{
225  		case election_behavior::normal:
226  			return std::chrono::milliseconds (5 * 60 * 1000);
227  		case election_behavior::hinted:
228  		case election_behavior::optimistic:
229  			return std::chrono::milliseconds (30 * 1000);
230  	}
231  	debug_assert (false);
232  	return {};
233  }
234  std::chrono::seconds nano::election::cooldown_time (nano::uint128_t weight) const
235  {
236  	auto online_stake = node.online_reps.trended ();
237  	if (weight > online_stake / 20) 
238  	{
239  		return std::chrono::seconds{ 1 };
240  	}
241  	if (weight > online_stake / 100) 
242  	{
243  		return std::chrono::seconds{ 5 };
244  	}
245  	return std::chrono::seconds{ 15 };
246  }
247  bool nano::election::have_quorum (nano::tally_t const & tally_a) const
248  {
249  	auto i (tally_a.begin ());
250  	++i;
251  	auto second (i != tally_a.end () ? i->first : 0);
252  	auto delta_l (node.online_reps.delta ());
253  	release_assert (tally_a.begin ()->first >= second);
254  	bool result{ (tally_a.begin ()->first - second) >= delta_l };
255  	return result;
256  }
257  nano::tally_t nano::election::tally () const
258  {
259  	nano::lock_guard<nano::mutex> guard{ mutex };
260  	return tally_impl ();
261  }
262  nano::tally_t nano::election::tally_impl () const
263  {
264  	std::unordered_map<nano::block_hash, nano::uint128_t> block_weights;
265  	std::unordered_map<nano::block_hash, nano::uint128_t> final_weights_l;
266  	for (auto const & [account, info] : last_votes)
267  	{
268  		auto rep_weight (node.ledger.weight (account));
269  		block_weights[info.hash] += rep_weight;
270  		if (info.timestamp == std::numeric_limits<uint64_t>::max ())
271  		{
272  			final_weights_l[info.hash] += rep_weight;
273  		}
274  	}
275  	last_tally = block_weights;
276  	nano::tally_t result;
277  	for (auto const & [hash, amount] : block_weights)
278  	{
279  		auto block (last_blocks.find (hash));
280  		if (block != last_blocks.end ())
281  		{
282  			result.emplace (amount, block->second);
283  		}
284  	}
285  	if (!final_weights_l.empty () && !result.empty ())
286  	{
287  		auto winner_hash (result.begin ()->second->hash ());
288  		auto find_final (final_weights_l.find (winner_hash));
289  		if (find_final != final_weights_l.end ())
290  		{
291  			final_weight = find_final->second;
292  		}
293  	}
294  	return result;
295  }
296  void nano::election::confirm_if_quorum (nano::unique_lock<nano::mutex> & lock_a)
297  {
298  	debug_assert (lock_a.owns_lock ());
299  	auto tally_l (tally_impl ());
300  	debug_assert (!tally_l.empty ());
301  	auto winner (tally_l.begin ());
302  	auto block_l (winner->second);
303  	auto const & winner_hash_l (block_l->hash ());
304  	status.tally = winner->first;
305  	status.final_tally = final_weight;
306  	auto const & status_winner_hash_l (status.winner->hash ());
<span onclick='openModal()' class='match'>307  	nano::uint128_t sum (0);
308  	for (auto & i : tally_l)
309  	{
310  		sum += i.first;
</span>311  	}
312  	if (sum >= node.online_reps.delta () && winner_hash_l != status_winner_hash_l)
313  	{
314  		status.winner = block_l;
315  		remove_votes (status_winner_hash_l);
316  		node.block_processor.force (block_l);
317  	}
318  	if (have_quorum (tally_l))
319  	{
320  		if (node.ledger.cache.final_votes_confirmation_canary.load () && !is_quorum.exchange (true) && node.config.enable_voting && node.wallets.reps ().voting > 0)
321  		{
322  			auto hash = status.winner->hash ();
323  			lock_a.unlock ();
324  			node.final_generator.add (root, hash);
325  			lock_a.lock ();
326  		}
327  		if (!node.ledger.cache.final_votes_confirmation_canary.load () || final_weight >= node.online_reps.delta ())
328  		{
329  			if (node.config.logging.vote_logging () || (node.config.logging.election_fork_tally_logging () && last_blocks.size () > 1))
330  			{
331  				log_votes (tally_l);
332  			}
333  			confirm_once (lock_a, nano::election_status_type::active_confirmed_quorum);
334  		}
335  	}
336  }
337  void nano::election::log_votes (nano::tally_t const & tally_a, std::string const & prefix_a) const
338  {
339  	std::stringstream tally;
340  	std::string line_end (node.config.logging.single_line_record () ? "\t" : "\n");
341  	tally << boost::str (boost::format ("%1%%2%Vote tally for root %3%, final weight:%4%") % prefix_a % line_end % root.to_string () % final_weight);
342  	for (auto i (tally_a.begin ()), n (tally_a.end ()); i != n; ++i)
343  	{
344  		tally << boost::str (boost::format ("%1%Block %2% weight %3%") % line_end % i->second->hash ().to_string () % i->first.convert_to<std::string> ());
345  	}
346  	for (auto i (last_votes.begin ()), n (last_votes.end ()); i != n; ++i)
347  	{
348  		if (i->first != nullptr)
349  		{
350  			tally << boost::str (boost::format ("%1%%2% %3% %4%") % line_end % i->first.to_account () % std::to_string (i->second.timestamp) % i->second.hash.to_string ());
351  		}
352  	}
353  	node.logger.try_log (tally.str ());
354  }
355  std::shared_ptr<nano::block> nano::election::find (nano::block_hash const & hash_a) const
356  {
357  	std::shared_ptr<nano::block> result;
358  	nano::lock_guard<nano::mutex> guard{ mutex };
359  	if (auto existing = last_blocks.find (hash_a); existing != last_blocks.end ())
360  	{
361  		result = existing->second;
362  	}
363  	return result;
364  }
365  nano::election_vote_result nano::election::vote (nano::account const & rep, uint64_t timestamp_a, nano::block_hash const & block_hash_a, vote_source vote_source_a)
366  {
367  	auto weight = node.ledger.weight (rep);
368  	if (!node.network_params.network.is_dev_network () && weight <= node.minimum_principal_weight ())
369  	{
370  		return nano::election_vote_result (false, false);
371  	}
372  	nano::unique_lock<nano::mutex> lock{ mutex };
373  	auto last_vote_it (last_votes.find (rep));
374  	if (last_vote_it != last_votes.end ())
375  	{
376  		auto last_vote_l (last_vote_it->second);
377  		if (last_vote_l.timestamp > timestamp_a)
378  		{
379  			return nano::election_vote_result (true, false);
380  		}
381  		if (last_vote_l.timestamp == timestamp_a && !(last_vote_l.hash < block_hash_a))
382  		{
383  			return nano::election_vote_result (true, false);
384  		}
385  		auto max_vote = timestamp_a == std::numeric_limits<uint64_t>::max () && last_vote_l.timestamp < timestamp_a;
386  		bool past_cooldown = true;
387  		if (vote_source_a == vote_source::live)
388  		{
389  			const auto cooldown = cooldown_time (weight);
390  			past_cooldown = last_vote_l.time <= std::chrono::steady_clock::now () - cooldown;
391  		}
392  		if (!max_vote && !past_cooldown)
393  		{
394  			return nano::election_vote_result (false, false);
395  		}
396  	}
397  	last_votes[rep] = { std::chrono::steady_clock::now (), timestamp_a, block_hash_a };
398  	if (vote_source_a == vote_source::live)
399  	{
400  		live_vote_action (rep);
401  	}
402  	node.stats.inc (nano::stat::type::election, vote_source_a == vote_source::live ? nano::stat::detail::vote_new : nano::stat::detail::vote_cached);
403  	if (!confirmed (lock))
404  	{
405  		confirm_if_quorum (lock);
406  	}
407  	return nano::election_vote_result (false, true);
408  }
409  bool nano::election::publish (std::shared_ptr<nano::block> const & block_a)
410  {
411  	nano::unique_lock<nano::mutex> lock{ mutex };
412  	auto result = confirmed (lock);
413  	if (!result && last_blocks.size () >= max_blocks && last_blocks.find (block_a->hash ()) == last_blocks.end ())
414  	{
415  		if (!replace_by_weight (lock, block_a->hash ()))
416  		{
417  			result = true;
418  			node.network.publish_filter.clear (block_a);
419  		}
420  		debug_assert (lock.owns_lock ());
421  	}
422  	if (!result)
423  	{
424  		auto existing = last_blocks.find (block_a->hash ());
425  		if (existing == last_blocks.end ())
426  		{
427  			last_blocks.emplace (std::make_pair (block_a->hash (), block_a));
428  		}
429  		else
430  		{
431  			result = true;
432  			existing->second = block_a;
433  			if (status.winner->hash () == block_a->hash ())
434  			{
435  				status.winner = block_a;
436  				node.network.flood_block (block_a, nano::transport::buffer_drop_policy::no_limiter_drop);
437  			}
438  		}
439  	}
440  	return result;
441  }
442  nano::election_extended_status nano::election::current_status () const
443  {
444  	nano::lock_guard<nano::mutex> guard{ mutex };
445  	nano::election_status status_l = status;
446  	status_l.confirmation_request_count = confirmation_request_count;
447  	status_l.block_count = nano::narrow_cast<decltype (status_l.block_count)> (last_blocks.size ());
448  	status_l.voter_count = nano::narrow_cast<decltype (status_l.voter_count)> (last_votes.size ());
449  	return nano::election_extended_status{ status_l, last_votes, tally_impl () };
450  }
451  std::shared_ptr<nano::block> nano::election::winner () const
452  {
453  	nano::lock_guard<nano::mutex> guard{ mutex };
454  	return status.winner;
455  }
456  void nano::election::broadcast_vote_impl (nano::unique_lock<nano::mutex> & lock)
457  {
458  	debug_assert (!mutex.try_lock ());
459  	if (node.config.enable_voting && node.wallets.reps ().voting > 0)
460  	{
461  		node.stats.inc (nano::stat::type::election, nano::stat::detail::generate_vote);
462  		if (confirmed (lock) || have_quorum (tally_impl ()))
463  		{
464  			node.stats.inc (nano::stat::type::election, nano::stat::detail::generate_vote_final);
465  			node.final_generator.add (root, status.winner->hash ()); 
466  		}
467  		else
468  		{
469  			node.stats.inc (nano::stat::type::election, nano::stat::detail::generate_vote_normal);
470  			node.generator.add (root, status.winner->hash ()); 
471  		}
472  	}
473  }
474  void nano::election::remove_votes (nano::block_hash const & hash_a)
475  {
476  	debug_assert (!mutex.try_lock ());
477  	if (node.config.enable_voting && node.wallets.reps ().voting > 0)
478  	{
479  		auto list_generated_votes (node.history.votes (root, hash_a));
480  		for (auto const & vote : list_generated_votes)
481  		{
482  			last_votes.erase (vote->account);
483  		}
484  		node.history.erase (root);
485  	}
486  }
487  void nano::election::remove_block (nano::block_hash const & hash_a)
488  {
489  	debug_assert (!mutex.try_lock ());
490  	if (status.winner->hash () != hash_a)
491  	{
492  		if (auto existing = last_blocks.find (hash_a); existing != last_blocks.end ())
493  		{
494  			for (auto i (last_votes.begin ()); i != last_votes.end ();)
495  			{
496  				if (i->second.hash == hash_a)
497  				{
498  					i = last_votes.erase (i);
499  				}
500  				else
501  				{
502  					++i;
503  				}
504  			}
505  			node.network.publish_filter.clear (existing->second);
506  			last_blocks.erase (hash_a);
507  		}
508  	}
509  }
510  bool nano::election::replace_by_weight (nano::unique_lock<nano::mutex> & lock_a, nano::block_hash const & hash_a)
511  {
512  	debug_assert (lock_a.owns_lock ());
513  	nano::block_hash replaced_block (0);
514  	auto winner_hash (status.winner->hash ());
515  	std::vector<std::pair<nano::block_hash, nano::uint128_t>> sorted;
516  	sorted.reserve (last_tally.size ());
517  	std::copy (last_tally.begin (), last_tally.end (), std::back_inserter (sorted));
518  	lock_a.unlock ();
519  	std::sort (sorted.begin (), sorted.end (), [] (auto const & left, auto const & right) { return left.second < right.second; });
520  	auto inactive_existing = node.inactive_vote_cache.find (hash_a);
521  	auto inactive_tally = inactive_existing ? inactive_existing->tally : 0;
522  	if (inactive_tally > 0 && sorted.size () < max_blocks)
523  	{
524  		for (auto const & [hash, block] : blocks ())
525  		{
526  			if (std::find_if (sorted.begin (), sorted.end (), [&hash = hash] (auto const & item_a) { return item_a.first == hash; }) == sorted.end () && hash != winner_hash)
527  			{
528  				replaced_block = hash;
529  				break;
530  			}
531  		}
532  	}
533  	else if (inactive_tally > 0 && inactive_tally > sorted.front ().second)
534  	{
535  		if (sorted.front ().first != winner_hash)
536  		{
537  			replaced_block = sorted.front ().first;
538  		}
539  		else if (inactive_tally > sorted[1].second)
540  		{
541  			replaced_block = sorted[1].first;
542  		}
543  	}
544  	bool replaced (false);
545  	if (!replaced_block.is_zero ())
546  	{
547  		node.active.erase_hash (replaced_block);
548  		lock_a.lock ();
549  		remove_block (replaced_block);
550  		replaced = true;
551  	}
552  	else
553  	{
554  		lock_a.lock ();
555  	}
556  	return replaced;
557  }
558  void nano::election::force_confirm (nano::election_status_type type_a)
559  {
560  	release_assert (node.network_params.network.is_dev_network ());
561  	nano::unique_lock<nano::mutex> lock{ mutex };
562  	confirm_once (lock, type_a);
563  }
564  std::unordered_map<nano::block_hash, std::shared_ptr<nano::block>> nano::election::blocks () const
565  {
566  	nano::lock_guard<nano::mutex> guard{ mutex };
567  	return last_blocks;
568  }
569  std::unordered_map<nano::account, nano::vote_info> nano::election::votes () const
570  {
571  	nano::lock_guard<nano::mutex> guard{ mutex };
572  	return last_votes;
573  }
574  std::vector<nano::vote_with_weight_info> nano::election::votes_with_weight () const
575  {
576  	std::multimap<nano::uint128_t, nano::vote_with_weight_info, std::greater<nano::uint128_t>> sorted_votes;
577  	std::vector<nano::vote_with_weight_info> result;
578  	auto votes_l (votes ());
579  	for (auto const & vote_l : votes_l)
580  	{
581  		if (vote_l.first != nullptr)
582  		{
583  			auto amount (node.ledger.cache.rep_weights.representation_get (vote_l.first));
584  			nano::vote_with_weight_info vote_info{ vote_l.first, vote_l.second.time, vote_l.second.timestamp, vote_l.second.hash, amount };
585  			sorted_votes.emplace (std::move (amount), vote_info);
586  		}
587  	}
588  	result.reserve (sorted_votes.size ());
589  	std::transform (sorted_votes.begin (), sorted_votes.end (), std::back_inserter (result), [] (auto const & entry) { return entry.second; });
590  	return result;
591  }
592  nano::stat::detail nano::to_stat_detail (nano::election_behavior behavior)
593  {
594  	switch (behavior)
595  	{
596  		case nano::election_behavior::normal:
597  		{
598  			return nano::stat::detail::normal;
599  		}
600  		case nano::election_behavior::hinted:
601  		{
602  			return nano::stat::detail::hinted;
603  		}
604  		case nano::election_behavior::optimistic:
605  		{
606  			return nano::stat::detail::optimistic;
607  		}
608  	}
609  	debug_assert (false, "unknown election behavior");
610  	return {};
611  }
612  nano::election_behavior nano::election::behavior () const
613  {
614  	return behavior_m;
615  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-openclwork.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-election_44.cpp</div>
                </div>
                <div class="column column_space"><pre><code>147  		std::size_t device_count (0);
148  		for (auto & i : platforms)
149  		{
150  			device_count += i.devices.size ();
</pre></code></div>
                <div class="column column_space"><pre><code>307  	nano::uint128_t sum (0);
308  	for (auto & i : tally_l)
309  	{
310  		sum += i.first;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    