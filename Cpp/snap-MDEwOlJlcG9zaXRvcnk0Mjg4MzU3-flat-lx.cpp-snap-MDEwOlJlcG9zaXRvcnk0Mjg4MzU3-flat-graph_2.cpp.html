
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.475037821482601%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lx.cpp</h3>
            <pre><code>1  void TLxChDef::SetUcCh(const TStr& Str){
2    for (int CC=1; CC<Str.Len(); CC++){
3      UcChV[Str[CC]-TCh::Mn]=TCh(Str[0]);}
4  }
5  void TLxChDef::SetChTy(const TLxChTy& ChTy, const TStr& Str){
6    for (int CC=0; CC<Str.Len(); CC++){
7      ChTyV[Str[CC]-TCh::Mn]=TInt(ChTy);}
8  }
9  TLxChDef::TLxChDef(const TLxChDefTy& ChDefTy):
10    ChTyV(TCh::Vals), UcChV(TCh::Vals){
11    if (ChDefTy==lcdtUsAscii){
12      ChTyV.PutAll(TInt(lctSpace));
13      SetChTy(lctNum, "0123456789");
14      SetChTy(lctAlpha, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
15      SetChTy(lctAlpha, "abcdefghijklmnopqrstuvwxyz");
16      SetChTy(lctAlpha, "@_");
17      SetChTy(lctSSym, "\"'.,:;+-*/%!#|&<=>?()[]{}");
18      SetChTy(lctTerm, TStr(TCh::CrCh));
19      SetChTy(lctTerm, TStr(TCh::LfCh));
20      SetChTy(lctTerm, TStr(TCh::EofCh));
21      for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}
22      SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("Dd"); SetUcCh("Ee");
23      SetUcCh("Ff"); SetUcCh("Gg"); SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj");
24      SetUcCh("Kk"); SetUcCh("Ll"); SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo");
25      SetUcCh("Pp"); SetUcCh("Qq"); SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("Tt");
26      SetUcCh("Uu"); SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy");
27      SetUcCh("Zz");
28    } else
29    if (ChDefTy==lcdtYuAscii){
30      ChTyV.PutAll(TInt(lctSpace));
31      SetChTy(lctNum, "0123456789");
32      SetChTy(lctAlpha, "ABC^]D\\EFGHIJKLMNOPQRS[TUVWXYZ@");
33      SetChTy(lctAlpha, "abc~}d|efghijklmnopqrs{tuvwxyz`");
34      SetChTy(lctAlpha, "_");
35      SetChTy(lctSSym, "\".,:;+-*/%!#&<=>?()");
36      SetChTy(lctTerm, TStr(TCh::CrCh));
37      SetChTy(lctTerm, TStr(TCh::LfCh));
38      SetChTy(lctTerm, TStr(TCh::EofCh));
39      for (int Ch=TCh::Mn; Ch<=TCh::Mx; Ch++){UcChV[Ch-TCh::Mn]=TCh(char(Ch));}
40      SetUcCh("Aa"); SetUcCh("Bb"); SetUcCh("Cc"); SetUcCh("^~"); SetUcCh("]}");
41      SetUcCh("Dd"); SetUcCh("\\|"); SetUcCh("Ee"); SetUcCh("Ff"); SetUcCh("Gg");
42      SetUcCh("Hh"); SetUcCh("Ii"); SetUcCh("Jj"); SetUcCh("Kk"); SetUcCh("Ll");
43      SetUcCh("Mm"); SetUcCh("Nn"); SetUcCh("Oo"); SetUcCh("Pp"); SetUcCh("Qq");
44      SetUcCh("Rr"); SetUcCh("Ss"); SetUcCh("[{"); SetUcCh("Tt"); SetUcCh("Uu");
45      SetUcCh("Vv"); SetUcCh("Ww"); SetUcCh("Xx"); SetUcCh("Yy"); SetUcCh("Zz");
46      SetUcCh("@`");
47    } else {
48      Fail;
49    }
50  }
51  bool TLxChDef::IsNmStr(const TStr& Str) const {
52    if (Str.Len()==0){return false;}
53    if (!IsAlpha(Str.GetCh(0))){return false;}
54    for (int ChN=1; ChN<Str.Len(); ChN++){
55      if (!IsAlNum(Str.GetCh(ChN))){return false;}}
56    return true;
57  }
58  TStr TLxChDef::GetUcStr(const TStr& Str) const {
59    TChA UcStr;
60    for (int ChN=0; ChN<Str.Len(); ChN++){
61      UcStr.AddCh(GetUc(Str.GetCh(ChN)));}
62    return UcStr;
63  }
64  PLxChDef TLxChDef::GetChDef(const TLxChDefTy& ChDefTy){
65    static PLxChDef UsAsciiChDef=NULL;
66    static PLxChDef YuAsciiChDef=NULL;
67    switch (ChDefTy){
68      case lcdtUsAscii:
69        if (UsAsciiChDef.Empty()){UsAsciiChDef=TLxChDef::New(lcdtUsAscii);}
70        return UsAsciiChDef;
71      case lcdtYuAscii:
72        if (YuAsciiChDef.Empty()){YuAsciiChDef=TLxChDef::New(lcdtYuAscii);}
73        return YuAsciiChDef;
74      default: Fail; return NULL;
75    }
76  }
77  const TStr TLxSymStr::UndefStr="<undefined>";
78  const TStr TLxSymStr::LnStr="<line>";
79  const TStr TLxSymStr::TabStr="<tab>";
80  const TStr TLxSymStr::IntStr="<integer>";
81  const TStr TLxSymStr::FltStr="<float>";
82  const TStr TLxSymStr::StrStr="<string>";
83  const TStr TLxSymStr::IdStrStr="<id-string>";
84  const TStr TLxSymStr::QStrStr="<q-string>";
85  const TStr TLxSymStr::PeriodStr=".";
86  const TStr TLxSymStr::DPeriodStr="..";
87  const TStr TLxSymStr::CommaStr=",";
88  const TStr TLxSymStr::ColonStr=":";
89  const TStr TLxSymStr::DColonStr="::";
90  const TStr TLxSymStr::SemicolonStr=";";
91  const TStr TLxSymStr::PlusStr="+";
92  const TStr TLxSymStr::MinusStr="-";
93  const TStr TLxSymStr::AsteriskStr="*";
94  const TStr TLxSymStr::SlashStr="/";
95  const TStr TLxSymStr::PercentStr="%";
96  const TStr TLxSymStr::ExclamationStr="!";
97  const TStr TLxSymStr::VBarStr="|";
98  const TStr TLxSymStr::AmpersandStr="&";
99  const TStr TLxSymStr::QuestionStr="?";
100  const TStr TLxSymStr::HashStr="#";
101  const TStr TLxSymStr::EqStr="=";
102  const TStr TLxSymStr::NEqStr="<>";
103  const TStr TLxSymStr::LssStr="<";
104  const TStr TLxSymStr::GtrStr=">";
105  const TStr TLxSymStr::LEqStr="<=";
106  const TStr TLxSymStr::GEqStr=">=";
107  const TStr TLxSymStr::LParenStr="(";
108  const TStr TLxSymStr::RParenStr=")";
109  const TStr TLxSymStr::LBracketStr="[";
110  const TStr TLxSymStr::RBracketStr="]";
111  const TStr TLxSymStr::LBraceStr="{";
112  const TStr TLxSymStr::RBraceStr="}";
113  const TStr TLxSymStr::EolnStr="<end-of-line>";
114  const TStr TLxSymStr::EofStr="<end-of-file>";
115  TStr TLxSymStr::GetSymStr(const TLxSym& Sym){
116    switch (Sym){
117      case syUndef: return UndefStr;
118      case syLn: return LnStr;
119      case syTab: return TabStr;
120      case syInt: return IntStr;
121      case syFlt: return FltStr;
122      case syStr: return StrStr;
123      case syIdStr: return IdStrStr;
124      case syQStr: return QStrStr;
125      case syPeriod: return PeriodStr;
126      case syDPeriod: return DPeriodStr;
127      case syComma: return CommaStr;
128      case syColon: return ColonStr;
129      case syDColon: return DColonStr;
130      case sySemicolon: return SemicolonStr;
131      case syPlus: return PlusStr;
132      case syMinus: return MinusStr;
133      case syAsterisk: return AsteriskStr;
134      case sySlash: return SlashStr;
135      case syPercent: return PercentStr;
136      case syExclamation: return ExclamationStr;
137      case syVBar: return VBarStr;
138      case syAmpersand: return AmpersandStr;
139      case syQuestion: return QuestionStr;
140      case syHash: return HashStr;
141      case syEq: return EqStr;
142      case syNEq: return NEqStr;
143      case syLss: return LssStr;
144      case syGtr: return GtrStr;
145      case syLEq: return LEqStr;
146      case syGEq: return GEqStr;
147      case syLParen: return LParenStr;
148      case syRParen: return RParenStr;
149      case syLBracket: return LBracketStr;
150      case syRBracket: return RBracketStr;
151      case syLBrace: return LBraceStr;
152      case syRBrace: return RBraceStr;
153      case syEoln: return EolnStr;
154      case syEof: return EofStr;
155      default: Fail; return TStr();
156    }
157  }
158  TLxSym TLxSymStr::GetSSym(const TStr& Str){
159    static TStrIntH StrToLxSymH(100);
160    if (StrToLxSymH.Len()==0){
161      StrToLxSymH.AddDat(PeriodStr, syPeriod);
162      StrToLxSymH.AddDat(DPeriodStr, syDPeriod);
163      StrToLxSymH.AddDat(CommaStr, syComma);
164      StrToLxSymH.AddDat(ColonStr, syColon);
165      StrToLxSymH.AddDat(DColonStr, syDColon);
166      StrToLxSymH.AddDat(SemicolonStr, sySemicolon);
167      StrToLxSymH.AddDat(PlusStr, syPlus);
168      StrToLxSymH.AddDat(MinusStr, syMinus);
169      StrToLxSymH.AddDat(AsteriskStr, syAsterisk);
170      StrToLxSymH.AddDat(SlashStr, sySlash);
171      StrToLxSymH.AddDat(PercentStr, syPercent);
172      StrToLxSymH.AddDat(ExclamationStr, syExclamation);
173      StrToLxSymH.AddDat(VBarStr, syVBar);
174      StrToLxSymH.AddDat(AmpersandStr, syAmpersand);
175      StrToLxSymH.AddDat(QuestionStr, syQuestion);
176      StrToLxSymH.AddDat(HashStr, syHash);
177      StrToLxSymH.AddDat(EqStr, syEq);
178      StrToLxSymH.AddDat(NEqStr, syNEq);
179      StrToLxSymH.AddDat(LssStr, syLss);
180      StrToLxSymH.AddDat(GtrStr, syGtr);
181      StrToLxSymH.AddDat(LEqStr, syLEq);
182      StrToLxSymH.AddDat(GEqStr, syGEq);
183      StrToLxSymH.AddDat(LParenStr, syLParen);
184      StrToLxSymH.AddDat(RParenStr, syRParen);
185      StrToLxSymH.AddDat(LBracketStr, syLBracket);
186      StrToLxSymH.AddDat(RBracketStr, syRBracket);
187      StrToLxSymH.AddDat(LBraceStr, syLBrace);
188      StrToLxSymH.AddDat(RBraceStr, syRBrace);
189    }
190    int KeyId=StrToLxSymH.GetKeyId(Str);
191    if (KeyId==-1){
192      return syUndef;
193    } else {
194      return TLxSym(int(StrToLxSymH[KeyId]));
195    }
196  }
197  bool TLxSymStr::IsSep(const TLxSym& PrevSym, const TLxSym& Sym){
198    static TFSet SepPrevSymSet=TFSet()|
199      syUndef|syColon|syDColon|syEq|
200      syLParen|syRParen|syLBracket|syRBracket|syLBrace|syRBrace|
201      syEoln|syEof;
202    static TFSet SepSymSet=TFSet()|
203      syPeriod|syComma|syColon|syDColon|sySemicolon|
204      syEq|
205      syExclamation|syQuestion|
206      syLParen|syRParen|syLBracket|syRBracket|syLBrace|syRBrace|
207      syEoln|syEof;
208    return !SepPrevSymSet.In(PrevSym) && !SepSymSet.In(Sym);
209  }
210  TILxSymSt::TILxSymSt():
211    Sym(syUndef),
212    Str(), UcStr(), CmtStr(),
213    Bool(false), Int(0), Flt(0),
214    SymLnN(-1), SymLnChN(-1), SymChN(-1){}
215  TILxSymSt::TILxSymSt(const TILxSymSt& SymSt):
216    Sym(SymSt.Sym),
217    Str(SymSt.Str), UcStr(SymSt.UcStr), CmtStr(SymSt.CmtStr),
218    Bool(SymSt.Bool), Int(SymSt.Int), Flt(SymSt.Flt),
219    SymLnN(SymSt.SymLnN), SymLnChN(SymSt.SymLnChN), SymChN(SymSt.SymChN){Fail;}
220  TILxSymSt::TILxSymSt(TILx& Lx):
221    Sym(Lx.Sym),
222    Str(Lx.Str), UcStr(Lx.UcStr), CmtStr(Lx.CmtStr),
223    Bool(Lx.Bool), Int(Lx.Int), Flt(Lx.Flt),
224    SymLnN(Lx.SymLnN), SymLnChN(Lx.SymLnChN), SymChN(Lx.SymChN){}
225  void TILxSymSt::Restore(TILx& Lx){
226    Lx.Sym=Sym;
227    Lx.Str=Str; Lx.UcStr=UcStr; Lx.CmtStr=CmtStr;
228    Lx.Bool=Bool; Lx.Int=Int; Lx.Flt=Flt;
229    Lx.SymLnN=SymLnN; Lx.SymLnChN=SymLnChN; Lx.SymChN=SymChN;}
230  TILx::TILx(const PSIn& _SIn, const TFSet& OptSet, const TLxChDefTy& ChDefTy):
231    ChDef(TLxChDef::GetChDef(ChDefTy)),
232    SIn(_SIn), RSIn(*SIn),
233    PrevCh(' '), Ch(' '), LnN(0), LnChN(0-1), ChN(0-1),
234    PrevSymStStack(), RwStrH(50),
235    IsCmtAlw(false), IsRetEoln(false), IsSigNum(false),
236    IsUniStr(false), IsCsSens(false), IsExcept(false),
237    IsTabSep(false), IsList(false),
238    Sym(syUndef),
239    Str(), UcStr(), CmtStr(),
240    Bool(false), Int(0), Flt(0),
241    SymLnN(-1), SymLnChN(-1), SymChN(-1){
242    for (int Opt=0; Opt<iloMx; Opt++){
243      if (OptSet.In(Opt)){SetOpt(Opt, true);}}
244  }
245  void TILx::SetOpt(const int& Opt, const bool& Val){
246    switch (Opt){
247      case iloCmtAlw: IsCmtAlw=Val; break;
248      case iloRetEoln: IsRetEoln=Val; break;
249      case iloSigNum: IsSigNum=Val; break;
250      case iloUniStr: IsUniStr=Val; break;
251      case iloCsSens: IsCsSens=Val; break;
252      case iloExcept: IsExcept=Val; break;
253      case iloTabSep: IsTabSep=Val; break;
254      case iloList: IsList=Val; break;
255      default: Fail;
256    }
257  }
258  TLxSym TILx::AddRw(const TStr& Str){
259    IAssert(RwStrH.Len()<syMxRw-syMnRw+1);
260    TStr UcStr=ChDef->GetUcStr(Str);
261    IAssert(!RwStrH.IsKey(UcStr));
262    TLxSym RwSym=TLxSym(syMnRw+RwStrH.Len());
263    RwStrH.AddDat(Str, TInt(int(RwSym)));
264    return RwSym;
265  }
266  PSIn TILx::GetSIn(const char& SepCh){
267    IAssert(PrevSymStStack.Empty());
268    while ((Ch!=TCh::EofCh)&&(Ch!=SepCh)){GetCh();}
269    return SIn;
270  }
271  TLxSym TILx::GetSym(const TFSet& Expect){
272    CmtStr.Clr();
273    if (!PrevSymStStack.Empty()){
274      PrevSymStStack.Top().Restore(*this); PrevSymStStack.Pop();
275    } else
276    if (Expect.In(syLn)){
277      if (Ch==TCh::EofCh){
278        Sym=syEof;
279      } else {
280        Str.Clr();
281        if (IsBof()){GetCh();}
282        while (!ChDef->IsTerm(Ch)){Str.AddCh(Ch); GetCh();}
283        bool _IsRetEoln=IsRetEoln; IsRetEoln=true;
284        GetSym(TFSet()|syEoln|syEof); Sym=syLn;
285        IsRetEoln=_IsRetEoln;
286      }
287    } else
288    if (IsTabSep){
289      if (IsBof()){GetCh();}
290      if (Ch==TCh::TabCh){ 
291        Sym=syTab; GetCh();
292      } else
293      if (ChDef->IsTerm(Ch)){ 
294        bool _IsRetEoln=IsRetEoln; IsRetEoln=true; IsTabSep=false;
295        GetSym(TFSet()|syEoln|syEof);
296        IsRetEoln=_IsRetEoln; IsTabSep=true;
297      } else {
298        Str.Clr();
299        while ((!ChDef->IsTerm(Ch))&&(Ch!=TCh::TabCh)){
300          Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
301        Sym=syStr; QuoteP=false;
302      }
303    } else {
304      while (ChDef->IsSpace(Ch)){GetCh();}
305      SymLnN=LnN; SymLnChN=LnChN; SymChN=ChN;
306      if (ChDef->IsAlpha(Ch)){
307        if (IsUniStr){Sym=syStr;} else {Sym=syIdStr;}
308        Str.Clr(); UcStr.Clr(); QuoteP=false;
309        do {Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch));}
310        while (ChDef->IsAlNum(GetCh()));
311        if (!RwStrH.Empty()){
312          TStr RwStr=Str; if (!IsCsSens){RwStr=UcStr;}
313          int SymKeyId=RwStrH.GetKeyId(RwStr);
314          if (SymKeyId!=-1){Sym=TLxSym(int(RwStrH[SymKeyId]));}
315        }
316        if (Expect.In(syBool)){
317          Sym=syBool; IAssert(TBool::IsValStr(Str));
318          Bool=TBool::GetValFromStr(Str);
319        }
320      } else
321      if ((Ch=='"')||(Ch=='\'')){
322        if (IsUniStr){Sym=syStr;} else {Sym=syQStr;}
323        Str.Clr(); UcStr.Clr(); QuoteP=true; QuoteCh=Ch;
324        GetCh();
325        forever{
326          while ((Ch!=QuoteCh)&&(Ch!='\\')&&(Ch!=TCh::EofCh)){
327            Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
328          if (Ch==TCh::EofCh){
329            Sym=syUndef; break;
330          } else if (Ch==QuoteCh){
331            GetCh(); break;
332          } else {
333            GetCh();
334            switch (Ch){
335              case '"': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
336              case '\\': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
337              case '\'': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
338              case '/': Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
339              case 'b': Str.AddCh('\b'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
340              case 'f': Str.AddCh('\f'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
341              case 'n': Str.AddCh('\n'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
342              case 'r': Str.AddCh('\r'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
343              case 't': Str.AddCh('\t'); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh(); break;
344              case 'u': {
345                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
346                int UChCd = TCh::GetHex(Ch);
347                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
348                UChCd = 16 * UChCd + TCh::GetHex(Ch);
349                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
350                UChCd = 16 * UChCd + TCh::GetHex(Ch);
351                GetCh(); EAssertR(TCh::IsHex(Ch), "Invalid hexadecimal digit in unicode escape");
352                UChCd = 16 * UChCd + TCh::GetHex(Ch);
353                TUnicode::EncodeUtf8(UChCd, Str);
354  			  TUnicode::EncodeUtf8(UChCd, UcStr); }
355                GetCh(); break; 
356              default: Sym=syUndef; break;
357            }
358            if (Sym==syUndef){
359              throw PExcept(new TExcept("Invalid Escape Sequence in Quoted String"));}
360          }
361        }
362      } else
363      if ((ChDef->IsNum(Ch))||(IsSigNum&&((Ch=='+')||(Ch=='-')))){
364        Str.Clr(); bool IntP=true;
365        do {Str.AddCh(Ch);} while (ChDef->IsNum(GetCh()));
366        if (Expect.In(syFlt)){
367          if (Ch=='.'){
368            Str.AddCh(Ch); IntP=false;
369            while (ChDef->IsNum(GetCh())){Str.AddCh(Ch);}
370          }
371          if ((Ch=='e')||(Ch=='E')){
372            Str.AddCh(Ch); GetCh(); IntP=false;
373            if ((Ch=='+')||(Ch=='-')){Str.AddCh(Ch); GetCh();}
374            while (ChDef->IsNum(Ch)){Str.AddCh(Ch); GetCh();}
375          }
376        }
377        UcStr=Str;
378        if (IntP&&(Expect.In(syInt))){
379          Sym=syInt; Int=atoi(Str.CStr());
380        } else {
381          Sym=syFlt; Flt=atof(Str.CStr());
382        }
383      } else
384      if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
385        Sym=syEoln;
386        if (Ch==TCh::CrCh){if (GetCh()==TCh::LfCh){GetCh();}} else
387        if (Ch==TCh::LfCh){if (GetCh()==TCh::CrCh){GetCh();}}
388        LnN++; LnChN=0; if (!IsRetEoln){GetSym(Expect);}
389      } else
390      if (Ch=='/'){
391        GetCh();
392        if ((IsCmtAlw)&&(Ch=='/')){
393          TChA _CmtStr;
394          do {_CmtStr+=GetCh();} while (!ChDef->IsTerm(Ch));
395          _CmtStr.Pop(); _CmtStr.Trunc();
396          if (Ch==TCh::CrCh){
397            if (GetCh()==TCh::LfCh){GetCh();}
398          } else
399          if (Ch==TCh::LfCh){
400            if (GetCh()==TCh::CrCh){GetCh();}
401          }
402          if (IsRetEoln){Sym=syEoln;} else {GetSym(Expect);}
403          CmtStr=_CmtStr;
404        } else
405        if (Ch=='*'){
406          TChA _CmtStr;
407          do {
408            while (GetCh()!='*'){_CmtStr+=Ch;}
409            _CmtStr+=GetCh();
410          } while (Ch!='/');
411          _CmtStr.Pop(); _CmtStr.Pop(); _CmtStr.Trunc();
412          GetCh(); GetSym(Expect);
413          CmtStr=_CmtStr;
414        } else {
415          Sym=sySlash;
416        }
417      } else
418      if (Ch==TCh::EofCh){
419        Sym=syEof;
420      } else {
421        switch (Ch){
422          case '.':
423            if (GetCh()=='.'){Sym=syDPeriod; GetCh();}
424            else {Sym=syPeriod;} break;
425          case ',': Sym=syComma; GetCh(); break;
426          case ':':
427            if (GetCh()==':'){Sym=syDColon; GetCh();}
428            else {Sym=syColon;} break;
429          case ';': Sym=sySemicolon; GetCh(); break;
430          case '+': Sym=syPlus; GetCh(); break;
431          case '-': Sym=syMinus; GetCh(); break;
432          case '*': Sym=syAsterisk; GetCh(); break;
433          case '/': Sym=sySlash; GetCh(); break;
434          case '%': Sym=syPercent; GetCh(); break;
435          case '!': Sym=syExclamation; GetCh(); break;
436          case '|': Sym=syVBar; GetCh(); break;
437          case '&': Sym=syAmpersand; GetCh(); break;
438          case '=': Sym=syEq; GetCh(); break;
439          case '<':
440            GetCh();
441            if (Ch=='='){Sym=syLEq; GetCh();}
442            else if (Ch=='>'){Sym=syNEq; GetCh();}
443            else {Sym=syLss;} break;
444          case '>':
445            if (GetCh()=='='){Sym=syGEq; GetCh();}
446            else {Sym=syGtr;} break;
447          case '?': Sym=syQuestion; GetCh(); break;
448          case '#':
449            if (IsCmtAlw){
450              TChA _CmtStr;
451              do {_CmtStr+=GetCh();} while (!ChDef->IsTerm(Ch));
452              _CmtStr.Pop(); _CmtStr.Trunc();
453              if (Ch==TCh::CrCh){
454                if (GetCh()==TCh::LfCh){GetCh();}
455              } else
456              if (Ch==TCh::LfCh){
457                if (GetCh()==TCh::CrCh){GetCh();}
458              }
459              if (IsRetEoln){Sym=syEoln;} else {GetSym(Expect);}
460              CmtStr=_CmtStr;
461            } else {
462              Sym=syHash; GetCh();
463            }
464            break;
465          case '(': Sym=syLParen; GetCh(); break;
466          case ')': Sym=syRParen; GetCh(); break;
467          case '[': Sym=syLBracket; GetCh(); break;
468          case ']': Sym=syRBracket; GetCh(); break;
469          case '{': Sym=syLBrace; GetCh(); break;
470          case '}': Sym=syRBrace; GetCh(); break;
471          default: Sym=syUndef; GetCh(); break;
472        }
473      }
474    }
475    if ((!Expect.In(Sym))&&(!Expect.Empty())){
476      if (IsExcept){
477       TStr MsgStr=
478        TStr("Unexpected symbol (")+GetSymStr()+") ["+GetFPosStr()+"]";
479       throw PExcept(new TExcept(MsgStr));
480      } else {
481        Fail;
482      }
483    }
484    return Sym;
485  }
486  TStr TILx::GetStrToCh(const char& ToCh){
487    Sym=syStr; Str.Clr(); UcStr.Clr();
488    while ((Ch!=ToCh)&&(Ch!=TCh::EofCh)){
489      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
490    return Str;
491  }
492  TStr TILx::GetStrToEolnOrCh(const char& ToCh){
493    Sym=syStr; Str.Clr(); UcStr.Clr();
494    while ((Ch!=ToCh)&&(Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
495      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
496    return Str;
497  }
498  TStr TILx::GetStrToEoln(const bool& DoTrunc){
499    Sym=syStr; Str.Clr(); UcStr.Clr();
500    while ((Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
501      Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
502    if (DoTrunc){Str.ToTrunc(); UcStr.ToTrunc();}
503    return Str;
504  }
505  TStr TILx::GetStrToEolnAndCh(const char& ToCh){
506    Sym=syStr; Str.Clr(); UcStr.Clr();
507    if (IsBof()){GetCh();}
508    forever {
509      if (Ch==TCh::EofCh){break;}
510      if (((ChN==0)||(PrevCh==TCh::CrCh)||(PrevCh==TCh::LfCh))&&(Ch==ToCh)){
511        GetCh(); break;}
512      else {Str.AddCh(Ch); UcStr.AddCh(ChDef->GetUc(Ch)); GetCh();}
513    }
514    return Str;
515  }
516  void TILx::SkipToEoln(){
517    while ((Ch!=TCh::CrCh)&&(Ch!=TCh::LfCh)&&(Ch!=TCh::EofCh)){
518      GetCh();}
519    if (Ch==TCh::CrCh){if (GetCh()==TCh::LfCh){GetCh();}} else
520    if (Ch==TCh::LfCh){if (GetCh()==TCh::CrCh){GetCh();}}
521  }
522  TLxSym TILx::PeekSym(const int& Syms){
523    TILxSymSt CurSymSt(*this);
524    TSStack<TILxSymSt> SymStStack;
525    for (int SymN=0; SymN<Syms; SymN++){
526      GetSym(); SymStStack.Push(TILxSymSt(*this));}
527    TLxSym PeekedSym=Sym;
528    while (!SymStStack.Empty()){
529      SymStStack.Top().Restore(*this); SymStStack.Pop();
530      PutSym();
531    }
532    CurSymSt.Restore(*this);
533    return PeekedSym;
534  }
535  TStr TILx::GetSymStr() const {
536    switch (Sym){
537      case syInt: return Str;
538      case syFlt: return Str;
539      case syStr: return Str;
540      case syIdStr: return Str;
541      case syQStr: return Str;
542      default:
543        if ((syMnRw<=Sym)&&(Sym<=syMxRw)){return Str;}
544        else {return TLxSymStr::GetSymStr(Sym);}
545    }
546  }
547  TStr TILx::GetFPosStr() const {
548    TChA ChA;
549    ChA+="File:"; ChA+=SIn->GetSNm();
550    ChA+=" Line:"; ChA+=TInt::GetStr(LnN+1);
551    ChA+=" Char:"; ChA+=TInt::GetStr(LnChN);
552    return ChA;
553  }
554  TStr TILx::GetQStr(const TStr& Str, const bool& QuoteP, const char& QuoteCh){
555    if (QuoteP){
556      TChA ChA;
557      ChA+=QuoteCh;
558      int StrLen=Str.Len();
559      for (int ChN=0; ChN<StrLen; ChN++){
560        char Ch=Str.CStr()[ChN];
561        if (Ch==QuoteCh){ChA+=QuoteCh; ChA+=QuoteCh;}
562        else {ChA+=Ch;}
563      }
564      ChA+=QuoteCh;
565      return ChA;
566    } else {
567      return Str;
568    }
569  }
570  void TILx::GetVarBoolV(const TStr& VarNm, TBoolV& BoolV, const bool& NewLn){
571    BoolV.Clr();
572    GetVar(VarNm, true, NewLn);
573    while (GetSym(syRBracket, syBool)==syQStr){
574      BoolV.Add(Bool); if (NewLn){GetEoln();}}
575    if (NewLn){GetEoln();}
576  }
577  void TILx::GetVarIntV(const TStr& VarNm, TIntV& IntV, const bool& NewLn){
578    IntV.Clr();
579    GetVar(VarNm, true, NewLn);
580    while (GetSym(syRBracket, syInt)==syInt){
581      IntV.Add(Int); if (NewLn){GetEoln();}}
582    if (NewLn){GetEoln();}
583  }
584  void TILx::GetVarFltV(const TStr& VarNm, TFltV& FltV, const bool& NewLn){
585    FltV.Clr();
586    GetVar(VarNm, true, NewLn);
587    while (GetSym(syRBracket, syFlt)==syFlt){
588      FltV.Add(Flt); if (NewLn){GetEoln();}}
589    if (NewLn){GetEoln();}
590  }
591  void TILx::GetVarStrV(const TStr& VarNm, TStrV& StrV, const bool& NewLn){
592    StrV.Clr();
593    GetVar(VarNm, true, NewLn);
594    while (GetSym(syRBracket, syQStr)==syQStr){
595      StrV.Add(Str); if (NewLn){GetEoln();}}
596    if (NewLn){GetEoln();}
597  }
598  void TILx::GetVarStrPrV(const TStr& VarNm, TStrPrV& StrPrV, const bool& NewLn){
599    StrPrV.Clr();
600    GetVar(VarNm, true, NewLn);
601    while (GetSym(syRBracket, syLBracket)==syLBracket){
602      TStr Str1=GetQStr(); TStr Str2=GetQStr();
603      GetSym(syRBracket);
604      StrPrV.Add(TStrPr(Str1, Str2)); if (NewLn){GetEoln();}
605    }
606    if (NewLn){GetEoln();}
607  }
608  void TILx::GetVarStrVV(const TStr& VarNm, TVec<TStrV>& StrVV, const bool& NewLn){
609    StrVV.Clr();
610    GetVar(VarNm, true, NewLn);
611    while (GetSym(syRBracket, syLBracket)==syLBracket){
612      StrVV.Add();
613      while (GetSym(syQStr, syRBracket)==syQStr){
614        StrVV.Last().Add(Str);}
615      if (NewLn){GetEoln();}
616    }
617    if (NewLn){GetEoln();}
618  }
619  void TILx::GetLnV(const TStr& FNm, TStrV& LnV){
620    TFIn SIn(FNm); LnV.Clr(); TChA Ln;
621    if (!SIn.Eof()){
622      char Ch=SIn.GetCh();
623      while (!SIn.Eof()){
624        if ((Ch==TCh::CrCh)||(Ch==TCh::LfCh)){
625          if (!SIn.Eof()){
626            char PrevCh=Ch; Ch=SIn.GetCh();
627            if (!SIn.Eof()){
628              if (PrevCh==TCh::CrCh){if (Ch==TCh::LfCh){Ch=SIn.GetCh();}} else
629              if (PrevCh==TCh::LfCh){if (Ch==TCh::CrCh){Ch=SIn.GetCh();}}
630            }
631          }
632          LnV.Add(Ln); Ln.Clr();
633        } else {
634          Ln+=Ch; Ch=SIn.GetCh();
635        }
636      }
637      if (!Ln.Empty()){
638        LnV.Add(Ln);}
639    }
640  }
641  void TOLx::PutSep(const TLxSym& Sym){
642    if (TLxSymStr::IsSep(PrevSym, Sym)){
643      if (IsTabSep){RSOut.PutCh(TCh::TabCh);} else {RSOut.PutCh(' ');}}
644    PrevSym=Sym;
645  }
646  TOLx::TOLx(const PSOut& _SOut, const TFSet& OptSet, const TLxChDefTy& ChDefTy):
647    ChDef(TLxChDef::GetChDef(ChDefTy)), SOut(_SOut), RSOut(*SOut),
648    IsCmtAlw(false), IsFrcEoln(false), IsSigNum(false),
649    IsUniStr(false), IsCsSens(false), IsTabSep(false), IsVarIndent(false),
650    VarIndentLev(0),
651    RwStrH(50), RwSymH(50), PrevSym(syUndef){
652    for (int Opt=0; Opt<oloMx; Opt++){
653      if (OptSet.In(Opt)){SetOpt(Opt, true);}}
654  }
655  void TOLx::SetOpt(const int& Opt, const bool& Val){
656    switch (Opt){
657      case oloCmtAlw: IsCmtAlw=Val; break;
658      case oloFrcEoln: IsFrcEoln=Val; break;
659      case oloSigNum: IsSigNum=Val; break;
660      case oloUniStr: IsUniStr=Val; break;
661      case oloCsSens: IsCsSens=Val; break;
662      case oloTabSep: IsTabSep=Val; break;
663      case oloVarIndent: IsVarIndent=Val; break;
664      default: Fail;
665    }
666  }
667  TLxSym TOLx::AddRw(const TStr& Str){
668    IAssert(RwStrH.Len()<syMxRw-syMnRw+1);
669    TStr UcStr=ChDef->GetUcStr(Str);
670    IAssert(!RwStrH.IsKey(UcStr));
671    TLxSym RwSym=TLxSym(syMnRw+RwStrH.Len());
672    RwStrH.AddDat(Str, TInt(int(RwSym)));
673    RwSymH.AddDat(TInt(int(RwSym)), Str);
674    return RwSym;
675  }
<span onclick='openModal()' class='match'>676  void TOLx::PutSym(const TLxSym& Sym){
677    TStr Str;
678    if ((syMnRw<=Sym)&&(Sym<=syMxRw)){
679      Str=Str=RwSymH[Sym];
680    } else {
681      Str=TLxSymStr::GetSymStr(Sym);
682    }
</span>683    PutSep(Sym); RSOut.PutStr(Str);
684  }
685  void TOLx::PutVarBoolV(const TStr& VarNm, const TBoolV& BoolV,
686   const bool& NewLn, const bool& CheckIdStr){
687    PutVar(VarNm, true, NewLn, CheckIdStr);
688    for (int BoolN=0; BoolN<BoolV.Len(); BoolN++){
689      if (IsVarIndent){PutIndent(VarIndentLev);}
690      PutBool(BoolV[BoolN]);
691      if (NewLn){PutLn();}
692    }
693    PutVarEnd(true, NewLn);
694  }
695  void TOLx::PutVarIntV(const TStr& VarNm, const TIntV& IntV,
696   const bool& NewLn, const bool& CheckIdStr){
697    PutVar(VarNm, true, NewLn, CheckIdStr);
698    for (int IntN=0; IntN<IntV.Len(); IntN++){
699      if (IsVarIndent){PutIndent(VarIndentLev);}
700      PutInt(IntV[IntN]);
701      if (NewLn){PutLn();}
702    }
703    PutVarEnd(true, NewLn);
704  }
705  void TOLx::PutVarFltV(const TStr& VarNm, const TFltV& FltV,
706   const bool& NewLn, const bool& CheckIdStr){
707    PutVar(VarNm, true, NewLn, CheckIdStr);
708    for (int FltN=0; FltN<FltV.Len(); FltN++){
709      if (IsVarIndent){PutIndent(VarIndentLev);}
710      PutFlt(FltV[FltN]);
711      if (NewLn){PutLn();}
712    }
713    PutVarEnd(true, NewLn);
714  }
715  void TOLx::PutVarStrV(const TStr& VarNm, const TStrV& StrV,
716   const bool& NewLn, const bool& CheckIdStr){
717    PutVar(VarNm, true, NewLn, CheckIdStr);
718    for (int StrN=0; StrN<StrV.Len(); StrN++){
719      if (IsVarIndent){PutIndent(VarIndentLev);}
720      PutQStr(StrV[StrN]);
721      if (NewLn){PutLn();}
722    }
723    PutVarEnd(true, NewLn);
724  }
725  void TOLx::PutVarStrPrV(const TStr& VarNm, const TStrPrV& StrPrV,
726   const bool& NewLn, const bool& CheckIdStr){
727    PutVar(VarNm, true, NewLn, CheckIdStr);
728    for (int StrPrN=0; StrPrN<StrPrV.Len(); StrPrN++){
729      if (IsVarIndent){PutIndent(VarIndentLev);}
730      PutSym(syLBracket);
731      PutQStr(StrPrV[StrPrN].Val1); PutQStr(StrPrV[StrPrN].Val2);
732      PutSym(syRBracket);
733      if (NewLn){PutLn();}
734    }
735    PutVarEnd(true, NewLn);
736  }
737  void TOLx::PutVarStrVV(const TStr& VarNm, const TVec<TStrV>& StrVV,
738   const bool& NewLn, const bool& CheckIdStr){
739    PutVar(VarNm, true, NewLn, CheckIdStr);
740    for (int StrVN=0; StrVN<StrVV.Len(); StrVN++){
741      if (IsVarIndent){PutIndent(VarIndentLev);}
742      PutSym(syLBracket);
743      for (int StrN=0; StrN<StrVV[StrVN].Len(); StrN++){
744        PutQStr(StrVV[StrVN][StrN]);}
745      PutSym(syRBracket);
746      if (NewLn){PutLn();}
747    }
748    PutVarEnd(true, NewLn);
749  }
750  char TPreproc::GetCh(){
751    Assert(Ch!=TCh::EofCh);
752    PrevCh=Ch;
753    Ch=((SIn->Eof()) ? TCh::EofCh : SIn->GetCh());
754    return Ch;
755  }
756  bool TPreproc::IsSubstId(const TStr& SubstId, TStr& SubstValStr) const {
757    if (SubstIdToKeyIdValPrVH.IsKey(SubstId)){
758      const TStrPrV& KeyIdValPrV=SubstIdToKeyIdValPrVH.GetDat(SubstId);
759      for (int KeyN=0; KeyN<KeyIdValPrV.Len(); KeyN++){
760        if (SubstKeyIdV.IsIn(KeyIdValPrV[KeyN].Val1)){
761          SubstValStr=KeyIdValPrV[KeyN].Val2;
762          return true;
763        }
764      }
765      return false;
766    } else {
767      return false;
768    }
769  }
770  TPreproc::TPreproc(const TStr& InFNm, const TStr& OutFNm,
771   const TStr& SubstFNm, const TStrV& _SubstKeyIdV):
772    SIn(), SubstKeyIdV(_SubstKeyIdV),
773    PrevCh('\0'), Ch('\0'){
774    if (!SubstFNm.Empty()){
775      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SubstFNm);
776      TXmlTokV SubstTokV; XmlDoc->GetTok()->GetTagTokV("Subst", SubstTokV);
777      for (int SubstTokN=0; SubstTokN<SubstTokV.Len(); SubstTokN++){
778        PXmlTok SubstTok=SubstTokV[SubstTokN];
779        TStr SubstId=SubstTok->GetArgVal("Id", "");
780        if (!SubstId.Empty()){
781          TStrPrV& KeyIdValPrV=SubstIdToKeyIdValPrVH.AddDat(SubstId);
782          TXmlTokV StrTokV; SubstTok->GetTagTokV("Str", StrTokV);
783          for (int StrTokN=0; StrTokN<StrTokV.Len(); StrTokN++){
784            PXmlTok StrTok=StrTokV[StrTokN];
785            TStr KeyId=StrTok->GetArgVal("Key", "");
786            TStr ValStr=StrTok->GetTokStr(false);
787            if (!KeyId.Empty()){
788              KeyIdValPrV.Add(TStrPr(KeyId, ValStr));
789            }
790          }
791        }
792      }
793    }
794    SIn=TFIn::New(InFNm);
795    PSOut SOut=TFOut::New(OutFNm);
796    bool CopyModeP=false; bool IgnoreModeP=false;
797    GetCh();
798    while (Ch!=TCh::EofCh){
799      if (isalpha(Ch)||(((PrevCh=='\0')||(PrevCh=='\r')||(PrevCh=='\n'))&&(Ch=='#'))){
800        TChA IdChA;
801        do {
802          IdChA+=Ch; GetCh();
803        } while ((Ch!=TCh::EofCh)&&(isalnum(Ch)));
804        if (IdChA=="#ifdef"){
805          TChA CondKeyIdChA;
806          while ((Ch!=TCh::EofCh)&&(Ch!='\n')&&(Ch!='\r')){
807            CondKeyIdChA+=Ch; GetCh();}
808          if (Ch=='\n'){GetCh(); if (Ch=='\r'){GetCh();}}
809          else if (Ch=='\r'){GetCh(); if (Ch=='\n'){GetCh();}}
810          CondKeyIdChA.Trunc();
811          IAssert(CopyModeP==false);
812          IAssert(IgnoreModeP==false);
813          if (SubstKeyIdV.IsIn(CondKeyIdChA)){
814            CopyModeP=true; IgnoreModeP=false;
815          } else {
816            CopyModeP=false; IgnoreModeP=true;
817          }
818        } else
819        if (IdChA=="#endif"){
820          while ((Ch!=TCh::EofCh)&&(Ch!='\n')&&(Ch!='\r')){
821            GetCh();}
822          if (Ch=='\n'){GetCh(); if (Ch=='\r'){GetCh();}}
823          else if (Ch=='\r'){GetCh(); if (Ch=='\n'){GetCh();}}
824          IAssert(CopyModeP||IgnoreModeP);
825          CopyModeP=false; IgnoreModeP=false;
826        } else {
827          TStr SubstValStr;
828          if ((!CopyModeP)&&(IsSubstId(IdChA, SubstValStr))){
829            if (!IgnoreModeP){SOut->PutStr(SubstValStr);}
830          } else {
831            if (!IgnoreModeP){SOut->PutStr(IdChA);}
832          }
833        }
834      } else {
835        if (!IgnoreModeP){SOut->PutCh(Ch);}
836        GetCh();
837      }
838    }
839  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_2.cpp</h3>
            <pre><code>1  bool TUNGraph::HasFlag(const TGraphFlag& Flag) const {
2    return HasGraphFlag(TUNGraph::TNet, Flag);
3  }
<span onclick='openModal()' class='match'>4  int TUNGraph::AddNode(int NId) {
5    if (NId == -1) {
6      NId = MxNId;  MxNId++;
7    } else {
8      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
9      MxNId = TMath::Mx(NId+1, MxNId());
10    }
</span>11    NodeH.AddDat(NId, TNode(NId));
12    return NId;
13  }
14  int TUNGraph::AddNodeUnchecked(int NId) {
15    if (IsNode(NId)) { return -1;}
16    MxNId = TMath::Mx(NId+1, MxNId());
17    NodeH.AddDat(NId, TNode(NId));
18    return NId;
19  }
20  int TUNGraph::AddNode(const int& NId, const TIntV& NbrNIdV) {
21    int NewNId;
22    if (NId == -1) {
23      NewNId = MxNId;  MxNId++;
24    } else {
25      IAssertR(! IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
26      NewNId = NId;
27      MxNId = TMath::Mx(NewNId+1, MxNId());
28    }
29    TNode& Node = NodeH.AddDat(NewNId);
30    Node.Id = NewNId;
31    Node.NIdV = NbrNIdV;
32    Node.NIdV.Sort();
33    NEdges += Node.GetDeg();
34    for (int i = 0; i < NbrNIdV.Len(); i++) {
35      GetNode(NbrNIdV[i]).NIdV.AddSorted(NewNId);
36    }
37    return NewNId;
38  }
39  int TUNGraph::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId) {
40    int NewNId;
41    if (NId == -1) {
42      NewNId = MxNId;  MxNId++;
43    } else {
44      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
45      NewNId = NId;
46      MxNId = TMath::Mx(NewNId+1, MxNId()); 
47    }
48    TNode& Node = NodeH.AddDat(NewNId);
49    Node.Id = NewNId;
50    Node.NIdV.GenExt(Pool.GetValVPt(NIdVId), Pool.GetVLen(NIdVId));
51    Node.NIdV.Sort();
52    NEdges += Node.GetDeg();
53    return NewNId;
54  }
55  void TUNGraph::DelNode(const int& NId) {
56    { AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
57    TNode& Node = GetNode(NId);
58    NEdges -= Node.GetDeg();
59    for (int e = 0; e < Node.GetDeg(); e++) {
60      const int nbr = Node.GetNbrNId(e);
61      if (nbr == NId) { continue; }
62      TNode& N = GetNode(nbr);
63      const int n = N.NIdV.SearchBin(NId);
64      IAssert(n != -1); 
65      if (n!= -1) { N.NIdV.Del(n); }
66    } }
67    NodeH.DelKey(NId);
68  }
69  int TUNGraph::GetEdges() const {
70    return NEdges;
71  }
72  int TUNGraph::AddEdge(const int& SrcNId, const int& DstNId) {
73    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
74    if (IsEdge(SrcNId, DstNId)) { return -2; } 
75    GetNode(SrcNId).NIdV.AddSorted(DstNId);
76    if (SrcNId!=DstNId) { 
77      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
78    NEdges++;
79    return -1; 
80  }
81  int TUNGraph::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
82    GetNode(SrcNId).NIdV.Add(DstNId);
83    if (SrcNId!=DstNId) { 
84      GetNode(DstNId).NIdV.Add(SrcNId); }
85    NEdges++;
86    return -1; 
87  }
88  int TUNGraph::AddEdge2(const int& SrcNId, const int& DstNId) {
89    if (! IsNode(SrcNId)) { AddNode(SrcNId); }
90    if (! IsNode(DstNId)) { AddNode(DstNId); }
91    if (GetNode(SrcNId).IsNbrNId(DstNId)) { return -2; } 
92    GetNode(SrcNId).NIdV.AddSorted(DstNId);
93    if (SrcNId!=DstNId) { 
94      GetNode(DstNId).NIdV.AddSorted(SrcNId); }
95    NEdges++;
96    return -1; 
97  }
98  void TUNGraph::DelEdge(const int& SrcNId, const int& DstNId) {
99    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
100    { TNode& N = GetNode(SrcNId);
101    const int n = N.NIdV.SearchBin(DstNId);
102    if (n!= -1) { N.NIdV.Del(n);  NEdges--; } }
103    if (SrcNId != DstNId) { 
104      TNode& N = GetNode(DstNId);
105      const int n = N.NIdV.SearchBin(SrcNId);
106      if (n!= -1) { N.NIdV.Del(n); }
107    }
108  }
109  bool TUNGraph::IsEdge(const int& SrcNId, const int& DstNId) const {
110    if (! IsNode(SrcNId) || ! IsNode(DstNId)) return false;
111    return GetNode(SrcNId).IsNbrNId(DstNId);
112  }
113  TUNGraph::TEdgeI TUNGraph::GetEI(const int& SrcNId, const int& DstNId) const {
114    const int MnNId = TMath::Mn(SrcNId, DstNId);
115    const int MxNId = TMath::Mx(SrcNId, DstNId);
116    const TNodeI SrcNI = GetNI(MnNId);
117    const int NodeN = SrcNI.NodeHI.GetDat().NIdV.SearchBin(MxNId);
118    IAssert(NodeN != -1);
119    return TEdgeI(SrcNI, EndNI(), NodeN);
120  }
121  void TUNGraph::GetNIdV(TIntV& NIdV) const {
122    NIdV.Gen(GetNodes(), 0);
123    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
124      NIdV.Add(NodeH.GetKey(N)); }
125  }
126  void TUNGraph::Defrag(const bool& OnlyNodeLinks) {
127    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
128      NodeH[n].NIdV.Pack();
129    }
130    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
131      NodeH.Defrag();
132    }
133  }
134  bool TUNGraph::IsOk(const bool& ThrowExcept) const {
135    bool RetVal = true;
136    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
137      const TNode& Node = NodeH[N];
138      if (! Node.NIdV.IsSorted()) {
139        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", Node.GetId());
140        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
141        RetVal=false;
142      }
143      int prevNId = -1;
144      for (int e = 0; e < Node.GetDeg(); e++) {
145        if (! IsNode(Node.GetNbrNId(e))) {
146          const TStr Msg = TStr::Fmt("Edge %d --> %d: node %d does not exist.",
147            Node.GetId(), Node.GetNbrNId(e), Node.GetNbrNId(e));
148          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
149          RetVal=false;
150        }
151        if (e > 0 && prevNId == Node.GetNbrNId(e)) {
152          const TStr Msg = TStr::Fmt("Node %d has duplicate edge %d --> %d.",
153            Node.GetId(), Node.GetId(), Node.GetNbrNId(e));
154          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
155          RetVal=false;
156        }
157        prevNId = Node.GetNbrNId(e);
158      }
159    }
160    int EdgeCnt = 0;
161    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) { EdgeCnt++; }
162    if (EdgeCnt != GetEdges()) {
163      const TStr Msg = TStr::Fmt("Number of edges counter is corrupted: GetEdges():%d, EdgeCount:%d.", GetEdges(), EdgeCnt);
164      if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); }
165      RetVal=false;
166    }
167    return RetVal;
168  }
169  void TUNGraph::Dump(FILE *OutF) const {
170    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
171    fprintf(OutF, "-------------------------------------------------\nUndirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
172    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
173      const TNode& Node = NodeH[N];
174      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
175      for (int edge = 0; edge < Node.GetDeg(); edge++) {
176        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
177      fprintf(OutF, "\n");
178    }
179    fprintf(OutF, "\n");
180  }
181  PUNGraph TUNGraph::GetSmallGraph() {
182    PUNGraph Graph = TUNGraph::New();
183    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
184    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
185    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
186    Graph->AddEdge(1,2);
187    return Graph;
188  }
189  bool TNGraph::HasFlag(const TGraphFlag& Flag) const {
190    return HasGraphFlag(TNGraph::TNet, Flag);
191  }
192  int TNGraph::AddNode(int NId) {
193    if (NId == -1) {
194      NId = MxNId;  MxNId++;
195    } else {
196      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
197      MxNId = TMath::Mx(NId+1, MxNId());
198    }
199    NodeH.AddDat(NId, TNode(NId));
200    return NId;
201  }
202  int TNGraph::AddNodeUnchecked(int NId) {
203    if (IsNode(NId)) { return NId;}
204    MxNId = TMath::Mx(NId+1, MxNId());
205    NodeH.AddDat(NId, TNode(NId));
206    return NId;
207  }
208  int TNGraph::AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV) {
209    int NewNId;
210    if (NId == -1) {
211      NewNId = MxNId;  MxNId++;
212    } else {
213      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
214      NewNId = NId;
215      MxNId = TMath::Mx(NewNId+1, MxNId());
216    }
217    TNode& Node = NodeH.AddDat(NewNId);
218    Node.Id = NewNId;
219    Node.InNIdV = InNIdV;
220    Node.OutNIdV = OutNIdV;
221    Node.InNIdV.Sort();
222    Node.OutNIdV.Sort();
223    return NewNId;
224  }
225  int TNGraph::AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId) {
226    int NewNId;
227    if (NId == -1) {
228      NewNId = MxNId;  MxNId++;
229    } else {
230      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
231      NewNId = NId;
232      MxNId = TMath::Mx(NewNId+1, MxNId());
233    }
234    TNode& Node = NodeH.AddDat(NewNId);
235    Node.Id = NewNId;
236    Node.InNIdV.GenExt(Pool.GetValVPt(SrcVId), Pool.GetVLen(SrcVId));
237    Node.OutNIdV.GenExt(Pool.GetValVPt(DstVId), Pool.GetVLen(DstVId));
238    Node.InNIdV.Sort();
239    Node.OutNIdV.Sort();
240    return NewNId;
241  }
242  void TNGraph::DelNode(const int& NId) {
243    { TNode& Node = GetNode(NId);
244    for (int e = 0; e < Node.GetOutDeg(); e++) {
245    const int nbr = Node.GetOutNId(e);
246    if (nbr == NId) { continue; }
247      TNode& N = GetNode(nbr);
248      const int n = N.InNIdV.SearchBin(NId);
249      if (n!= -1) { N.InNIdV.Del(n); }
250    }
251    for (int e = 0; e < Node.GetInDeg(); e++) {
252    const int nbr = Node.GetInNId(e);
253    if (nbr == NId) { continue; }
254      TNode& N = GetNode(nbr);
255      const int n = N.OutNIdV.SearchBin(NId);
256      if (n!= -1) { N.OutNIdV.Del(n); }
257    } }
258    NodeH.DelKey(NId);
259  }
260  int TNGraph::GetEdges() const {
261    int edges=0;
262    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
263      edges+=NodeH[N].GetOutDeg();
264    }
265    return edges;
266  }
267  int TNGraph::AddEdge(const int& SrcNId, const int& DstNId) {
268    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
269    if (IsEdge(SrcNId, DstNId)) { return -2; }
270    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
271    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
272    return -1; 
273  }
274  int TNGraph::AddEdgeUnchecked(const int& SrcNId, const int& DstNId) {
275    GetNode(SrcNId).OutNIdV.Add(DstNId);
276    GetNode(DstNId).InNIdV.Add(SrcNId);
277    return -1; 
278  }
279  int TNGraph::AddEdge2(const int& SrcNId, const int& DstNId) {
280    if (! IsNode(SrcNId)) { AddNode(SrcNId); }
281    if (! IsNode(DstNId)) { AddNode(DstNId); }
282    if (GetNode(SrcNId).IsOutNId(DstNId)) { return -2; } 
283    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
284    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
285    return -1; 
286  }
287  void TNGraph::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
288    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
289    { TNode& N = GetNode(SrcNId);
290    const int n = N.OutNIdV.SearchBin(DstNId);
291    if (n!= -1) { N.OutNIdV.Del(n); } }
292    { TNode& N = GetNode(DstNId);
293    const int n = N.InNIdV.SearchBin(SrcNId);
294    if (n!= -1) { N.InNIdV.Del(n); } }
295    if (! IsDir) {
296      { TNode& N = GetNode(SrcNId);
297      const int n = N.InNIdV.SearchBin(DstNId);
298      if (n!= -1) { N.InNIdV.Del(n); } }
299      { TNode& N = GetNode(DstNId);
300      const int n = N.OutNIdV.SearchBin(SrcNId);
301      if (n!= -1) { N.OutNIdV.Del(n); } }
302    }
303  }
304  bool TNGraph::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
305    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
306    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
307    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
308  }
309  TNGraph::TEdgeI TNGraph::GetEI(const int& SrcNId, const int& DstNId) const {
310    const TNodeI SrcNI = GetNI(SrcNId);
311    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
312    IAssert(NodeN != -1);
313    return TEdgeI(SrcNI, EndNI(), NodeN);
314  }
315  void TNGraph::GetNIdV(TIntV& NIdV) const {
316    NIdV.Gen(GetNodes(), 0);
317    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
318      NIdV.Add(NodeH.GetKey(N)); }
319  }
320  void TNGraph::Defrag(const bool& OnlyNodeLinks) {
321    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
322      TNode& Node = NodeH[n];
323      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
324    }
325    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
326  }
327  bool TNGraph::IsOk(const bool& ThrowExcept) const {
328    bool RetVal = true;
329    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
330      const TNode& Node = NodeH[N];
331      if (! Node.OutNIdV.IsSorted()) {
332        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
333        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
334      }
335      if (! Node.InNIdV.IsSorted()) {
336        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
337        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
338      }
339      int prevNId = -1;
340      for (int e = 0; e < Node.GetOutDeg(); e++) {
341        if (! IsNode(Node.GetOutNId(e))) {
342          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
343            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
344          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
345        }
346        if (e > 0 && prevNId == Node.GetOutNId(e)) {
347          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
348            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
349          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
350        }
351        prevNId = Node.GetOutNId(e);
352      }
353      prevNId = -1;
354      for (int e = 0; e < Node.GetInDeg(); e++) {
355        if (! IsNode(Node.GetInNId(e))) {
356          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
357            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
358          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
359        }
360        if (e > 0 && prevNId == Node.GetInNId(e)) {
361          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
362            Node.GetId(), Node.GetId(), Node.GetInNId(e));
363          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
364        }
365        prevNId = Node.GetInNId(e);
366      }
367    }
368    return RetVal;
369  }
370  void TNGraph::Dump(FILE *OutF) const {
371    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
372    fprintf(OutF, "-------------------------------------------------\nDirected Node Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
373    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
374      const TNode& Node = NodeH[N];
375      fprintf(OutF, "  %*d]\n", NodePlaces, Node.GetId());
376      fprintf(OutF, "    in [%d]", Node.GetInDeg());
377      for (int edge = 0; edge < Node.GetInDeg(); edge++) {
378        fprintf(OutF, " %*d", NodePlaces, Node.GetInNId(edge)); }
379      fprintf(OutF, "\n    out[%d]", Node.GetOutDeg());
380      for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
381        fprintf(OutF, " %*d", NodePlaces, Node.GetOutNId(edge)); }
382      fprintf(OutF, "\n");
383    }
384    fprintf(OutF, "\n");
385  }
386  PNGraph TNGraph::GetSmallGraph() {
387    PNGraph G = TNGraph::New();
388    for (int i = 0; i < 5; i++) { G->AddNode(i); }
389    G->AddEdge(0,1); G->AddEdge(1,2); G->AddEdge(0,2);
390    G->AddEdge(1,3); G->AddEdge(3,4); G->AddEdge(2,3);
391    return G;
392  }
393  bool TNEGraph::HasFlag(const TGraphFlag& Flag) const {
394    return HasGraphFlag(TNEGraph::TNet, Flag);
395  }
396  bool TNEGraph::TNodeI::IsInNId(const int& NId) const {
397    const TNode& Node = NodeHI.GetDat();
398    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
399      if (NId == Graph->GetEdge(Node.GetInEId(edge)).GetSrcNId())
400        return true;
401    }
402    return false;
403  }
404  bool TNEGraph::TNodeI::IsOutNId(const int& NId) const {
405    const TNode& Node = NodeHI.GetDat();
406    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
407      if (NId == Graph->GetEdge(Node.GetOutEId(edge)).GetDstNId())
408        return true;
409    }
410    return false;
411  }
412  int TNEGraph::AddNode(int NId) {
413    if (NId == -1) {
414      NId = MxNId;  MxNId++;
415    } else {
416      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
417      MxNId = TMath::Mx(NId+1, MxNId());
418    }
419    NodeH.AddDat(NId, TNode(NId));
420    return NId;
421  }
422  void TNEGraph::DelNode(const int& NId) {
423    const TNode& Node = GetNode(NId);
424    for (int out = 0; out < Node.GetOutDeg(); out++) {
425      const int EId = Node.GetOutEId(out);
426      const TEdge& Edge = GetEdge(EId);
427      IAssert(Edge.GetSrcNId() == NId);
428      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
429      EdgeH.DelKey(EId);
430    }
431    for (int in = 0; in < Node.GetInDeg(); in++) {
432      const int EId = Node.GetInEId(in);
433      const TEdge& Edge = GetEdge(EId);
434      IAssert(Edge.GetDstNId() == NId);
435      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
436      EdgeH.DelKey(EId);
437    }
438    NodeH.DelKey(NId);
439  }
440  int TNEGraph::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
441    if (EId == -1) { EId = MxEId;  MxEId++; }
442    else { MxEId = TMath::Mx(EId+1, MxEId()); }
443    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
444    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
445    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
446    GetNode(SrcNId).OutEIdV.AddSorted(EId);
447    GetNode(DstNId).InEIdV.AddSorted(EId);
448    return EId;
449  }
450  void TNEGraph::DelEdge(const int& EId) {
451    IAssert(IsEdge(EId));
452    const int SrcNId = GetEdge(EId).GetSrcNId();
453    const int DstNId = GetEdge(EId).GetDstNId();
454    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
455    GetNode(DstNId).InEIdV.DelIfIn(EId);
456    EdgeH.DelKey(EId);
457  }
458  void TNEGraph::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
459    int EId;
460    IAssert(IsEdge(SrcNId, DstNId, EId, IsDir)); 
461    while (IsEdge(SrcNId, DstNId, EId, IsDir)) {
462      GetNode(SrcNId).OutEIdV.DelIfIn(EId);
463      GetNode(DstNId).InEIdV.DelIfIn(EId);
464    }
465    EdgeH.DelKey(EId);
466  }
467  bool TNEGraph::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
468    const TNode& SrcNode = GetNode(SrcNId);
469    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
470      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
471      if (DstNId == Edge.GetDstNId()) {
472        EId = Edge.GetId();  return true; }
473    }
474    if (! IsDir) {
475      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
476      const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
477      if (DstNId == Edge.GetSrcNId()) {
478        EId = Edge.GetId();  return true; }
479      }
480    }
481    return false;
482  }
483  void TNEGraph::GetNIdV(TIntV& NIdV) const {
484    NIdV.Gen(GetNodes(), 0);
485    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
486      NIdV.Add(NodeH.GetKey(N)); }
487  }
488  void TNEGraph::GetEIdV(TIntV& EIdV) const {
489    EIdV.Gen(GetEdges(), 0);
490    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
491      EIdV.Add(EdgeH.GetKey(E));
492    }
493  }
494  void TNEGraph::Defrag(const bool& OnlyNodeLinks) {
495    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid); ) {
496      TNode& Node = NodeH[kid];
497      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
498    }
499    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
500    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
501  }
502  bool TNEGraph::IsOk(const bool& ThrowExcept) const {
503  bool RetVal = true;
504    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
505      const TNode& Node = NodeH[N];
506      if (! Node.OutEIdV.IsSorted()) {
507        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
508        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
509      }
510      if (! Node.InEIdV.IsSorted()) {
511        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
512        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
513      }
514      int prevEId = -1;
515      for (int e = 0; e < Node.GetOutDeg(); e++) {
516        if (! IsEdge(Node.GetOutEId(e))) {
517          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
518          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
519        }
520        if (e > 0 && prevEId == Node.GetOutEId(e)) {
521          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
522          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
523        }
524        prevEId = Node.GetOutEId(e);
525      }
526      prevEId = -1;
527      for (int e = 0; e < Node.GetInDeg(); e++) {
528        if (! IsEdge(Node.GetInEId(e))) {
529          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
530          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
531        }
532        if (e > 0 && prevEId == Node.GetInEId(e)) {
533          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
534          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
535        }
536        prevEId = Node.GetInEId(e);
537      }
538    }
539    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
540      const TEdge& Edge = EdgeH[E];
541      if (! IsNode(Edge.GetSrcNId())) {
542        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
543        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
544      }
545      if (! IsNode(Edge.GetDstNId())) {
546        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
547        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
548      }
549    }
550    return RetVal;
551  }
552  void TNEGraph::Dump(FILE *OutF) const {
553    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
554    const int EdgePlaces = (int) ceil(log10((double) GetEdges()));
555    fprintf(OutF, "-------------------------------------------------\nDirected Node-Edge Graph: nodes: %d, edges: %d\n", GetNodes(), GetEdges());
556    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
557      fprintf(OutF, "  %*d]\n", NodePlaces, NodeI.GetId());
558      fprintf(OutF, "    in[%d]", NodeI.GetInDeg());
559      for (int edge = 0; edge < NodeI.GetInDeg(); edge++) {
560        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetInEId(edge)); }
561      fprintf(OutF, "\n    out[%d]", NodeI.GetOutDeg());
562      for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
563        fprintf(OutF, " %*d", EdgePlaces, NodeI.GetOutEId(edge)); }
564      fprintf(OutF, "\n");
565    }
566    for (TEdgeI EdgeI = BegEI(); EdgeI < EndEI(); EdgeI++) {
567      fprintf(OutF, "  %*d]  %*d  ->  %*d\n", EdgePlaces, EdgeI.GetId(), NodePlaces, EdgeI.GetSrcNId(), NodePlaces, EdgeI.GetDstNId());
568    }
569    fprintf(OutF, "\n");
570  }
571  PNEGraph TNEGraph::GetSmallGraph() {
572    PNEGraph Graph = TNEGraph::New();
573    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
574    Graph->AddEdge(0,1);  Graph->AddEdge(0,2);
575    Graph->AddEdge(0,3);  Graph->AddEdge(0,4);
576    Graph->AddEdge(1,2);  Graph->AddEdge(1,2);
577    return Graph;
578  }
579  int TBPGraph::AddNode(int NId, const bool& LeftNode) {
580    if (NId == -1) { NId = MxNId;  MxNId++; }
581    else if (IsLNode(NId)) { IAssertR(LeftNode, TStr::Fmt("Node with id %s already exists on the 'left'.", NId));  return NId; }
582    else if (IsRNode(NId)) { IAssertR(! LeftNode, TStr::Fmt("Node with id %s already exists on the 'right'.", NId));  return NId; }
583    else { MxNId = TMath::Mx(NId+1, MxNId()); }
584    if (LeftNode) { LeftH.AddDat(NId, TNode(NId)); }
585    else { RightH.AddDat(NId, TNode(NId)); }
586    return NId;
587  }
588  void TBPGraph::DelNode(const int& NId) {
589    AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
590    THash<TInt, TNode>& SrcH = IsLNode(NId) ? LeftH : RightH;
591    THash<TInt, TNode>& DstH = IsLNode(NId) ? RightH : LeftH;
592    { TNode& Node = SrcH.GetDat(NId);
593    for (int e = 0; e < Node.GetOutDeg(); e++) {
594      const int nbr = Node.GetOutNId(e);
595      IAssertR(nbr != NId, "Bipartite graph has a loop!");
596      TNode& N = DstH.GetDat(nbr);
597      const int n = N.NIdV.SearchBin(NId);
598      IAssert(n!= -1); 
599      N.NIdV.Del(n);
600    } }
601    SrcH.DelKey(NId);
602  }
603  int TBPGraph::GetEdges() const {
604    int Edges = 0;
605    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
606      Edges += LeftH[N].GetDeg(); }
607    return Edges;
608  }
609  int TBPGraph::AddEdge(const int& LeftNId, const int& RightNId) {
610    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
611    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
612    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
613    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
614    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
615    const int LNId = IsLL ? LeftNId : RightNId; 
616    const int RNId = IsLL ? RightNId : LeftNId; 
617    if (LeftH.GetDat(LNId).IsOutNId(RNId)) { return -2; } 
618    LeftH.GetDat(LNId).NIdV.AddSorted(RNId);
619    RightH.GetDat(RNId).NIdV.AddSorted(LNId);
620    return -1; 
621  }
622  void TBPGraph::DelEdge(const int& LeftNId, const int& RightNId) {
623    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
624    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
625    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
626    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
627    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
628    const int LNId = IsLL ? LeftNId : RightNId; 
629    const int RNId = IsLL ? RightNId : LeftNId; 
630    { TIntV& NIdV = LeftH.GetDat(LNId).NIdV;
631    const int n = NIdV.SearchBin(RNId);
632    if (n != -1) { NIdV.Del(n); } }
633    { TIntV& NIdV = RightH.GetDat(RNId).NIdV;
634    const int n = NIdV.SearchBin(LNId);
635    if (n != -1) { NIdV.Del(n); } }
636  }
637  bool TBPGraph::IsEdge(const int& LeftNId, const int& RightNId) const {
638    if (! IsNode(LeftNId) || ! IsNode(RightNId)) { return false; }
639    return IsLNode(LeftNId) ? LeftH.GetDat(LeftNId).IsOutNId(RightNId) : RightH.GetDat(LeftNId).IsOutNId(RightNId);
640  }
641  TBPGraph::TEdgeI TBPGraph::GetEI(const int& LeftNId, const int& RightNId) const {
642    const bool IsLL = IsLNode(LeftNId), IsLR = IsRNode(LeftNId);
643    const bool IsRL = IsLNode(RightNId), IsRR = IsRNode(RightNId);
644    IAssertR((IsLL||IsLR)&&(IsRL||IsRR), TStr::Fmt("%d or %d is not a node.", LeftNId, RightNId).CStr());
645    IAssertR(LeftNId!=RightNId, "No self-edges are allowed."); 
646    IAssertR((IsLL&&!IsLR&&!IsRL&&IsRR)||(!IsLL&&IsLR&&IsRL&&!IsRR), "One node should be on the 'left' and the other on the 'right'.");
647    const int LNId = IsLL ? LeftNId : RightNId; 
648    const int RNId = IsLL ? RightNId : LeftNId; 
649    const TNodeI SrcNI = GetNI(LNId);
650    const int NodeN = SrcNI.LeftHI.GetDat().NIdV.SearchBin(RNId);
651    IAssertR(NodeN != -1, "Right edge endpoint does not exists!");
652    return TEdgeI(SrcNI, EndNI(), NodeN);
653  }
654  int TBPGraph::GetRndNId(TRnd& Rnd) { 
655    const int NNodes = GetNodes();
656    if (Rnd.GetUniDevInt(NNodes) < GetLNodes()) {
657      return GetRndLNId(Rnd); }
658    else {
659      return GetRndRNId(Rnd); }
660  }
661  int TBPGraph::GetRndLNId(TRnd& Rnd) { 
662    return LeftH.GetKey(LeftH.GetRndKeyId(Rnd, 0.8)); 
663  }
664  int TBPGraph::GetRndRNId(TRnd& Rnd) { 
665    return RightH.GetKey(RightH.GetRndKeyId(Rnd, 0.8)); 
666  }
667  void TBPGraph::GetNIdV(TIntV& NIdV) const {
668    NIdV.Gen(GetNodes(), 0);
669    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
670      NIdV.Add(LeftH.GetKey(N)); }
671    for (int N=RightH.FFirstKeyId(); RightH.FNextKeyId(N); ) {
672      NIdV.Add(RightH.GetKey(N)); }
673  }
674  void TBPGraph::GetLNIdV(TIntV& NIdV) const {
675    NIdV.Gen(GetLNodes(), 0);
676    for (int N=LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
677      NIdV.Add(LeftH.GetKey(N)); }
678  }
679  void TBPGraph::GetRNIdV(TIntV& NIdV) const {
680    NIdV.Gen(GetRNodes(), 0);
681    for (int N=RightH.FFirstKeyId(); RightH.FNextKeyId(N); ) {
682      NIdV.Add(RightH.GetKey(N)); }
683  }
684  void TBPGraph::Reserve(const int& Nodes, const int& Edges) { 
685    if (Nodes>0) { LeftH.Gen(Nodes/2); RightH.Gen(Nodes/2); } 
686  }
687  void TBPGraph::Defrag(const bool& OnlyNodeLinks) {
688    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
689      LeftH[n].NIdV.Pack(); }
690    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
691      RightH[n].NIdV.Pack(); }
692    if (! OnlyNodeLinks && ! LeftH.IsKeyIdEqKeyN()) { LeftH.Defrag(); }
693    if (! OnlyNodeLinks && ! RightH.IsKeyIdEqKeyN()) { RightH.Defrag(); }
694  }
695  bool TBPGraph::IsOk(const bool& ThrowExcept) const {
696    bool RetVal = false;
697    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
698      if (! LeftH[n].NIdV.IsSorted()) {
699        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", LeftH[n].GetId());
700        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
701    }
702    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
703      if (! RightH[n].NIdV.IsSorted()) {
704        const TStr Msg = TStr::Fmt("Neighbor list of node %d is not sorted.", RightH[n].GetId());
705        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
706    }
707    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
708      if (RightH.IsKey(LeftH[n].GetId())) {
709        const TStr Msg = TStr::Fmt("'Left' node %d also appears on the 'right'.", LeftH[n].GetId());
710        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
711    } 
712    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
713      if (LeftH.IsKey(RightH[n].GetId())) {
714        const TStr Msg = TStr::Fmt("'Right' node %d also appears on the 'left'.", RightH[n].GetId());
715        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
716    }
717    for (int n = LeftH.FFirstKeyId(); LeftH.FNextKeyId(n); ) {
718      for (int e = 0; e < LeftH[n].NIdV.Len(); e++) {
719        if (! RightH.IsKey(LeftH[n].NIdV[e]) || ! RightH.GetDat(LeftH[n].NIdV[e]).NIdV.IsIn(LeftH[n].GetId())) {
720          const TStr Msg = TStr::Fmt("'Left' node %d does not point to the 'right' node %d.", LeftH[n].GetId(), LeftH[n].NIdV[e]());
721          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
722      }
723    }
724    for (int n = RightH.FFirstKeyId(); RightH.FNextKeyId(n); ) {
725      for (int e = 0; e < RightH[n].NIdV.Len(); e++) {
726        if (! LeftH.IsKey(RightH[n].NIdV[e]) || ! LeftH.GetDat(RightH[n].NIdV[e]).NIdV.IsIn(RightH[n].GetId())) {
727          const TStr Msg = TStr::Fmt("'Left' node %d does not point to the 'right' node %d.", RightH[n].GetId(), RightH[n].NIdV[e]());
728          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false; }
729      }
730    }
731    return RetVal;
732  }
733  void TBPGraph::Dump(FILE *OutF) const {
734    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
735    fprintf(OutF, "-------------------------------------------------\nBipartite Graph: nodes: %d+%d=%d, edges: %d\n", GetLNodes(), GetRNodes(), GetNodes(), GetEdges());
736    for (int N = LeftH.FFirstKeyId(); LeftH.FNextKeyId(N); ) {
737      const TNode& Node = LeftH[N];
738      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
739      for (int edge = 0; edge < Node.GetDeg(); edge++) {
740        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
741      fprintf(OutF, "\n");
742    }
743    fprintf(OutF, "\n");
744  }
745  PBPGraph TBPGraph::GetSmallGraph() {
746    PBPGraph BP = TBPGraph::New();
747    BP->AddNode(0, true);
748    BP->AddNode(1, true);
749    BP->AddNode(2, false);
750    BP->AddNode(3, false);
751    BP->AddNode(4, false);
752    BP->AddEdge(0, 2);
753    BP->AddEdge(0, 3);
754    BP->AddEdge(1, 2);
755    BP->AddEdge(1, 3);
756    BP->AddEdge(1, 4);
757    return BP;
758  }
759  bool THGraph::HasFlag(const TGraphFlag& Flag) const {
760    return HasGraphFlag(THGraph::TNet, Flag);
761  }
762  int THGraph::AddNode(int NId, TStr NName) {
763    if (NId == -1) {
764      NId = MxNId;  MxNId++;
765    } else {
766      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
767      MxNId = TMath::Mx(NId+1, MxNId());
768    }
769    NodeH.AddDat(NId, TNode(NId, NName));
770    return NId;
771  }
772  int THGraph::AddNodeUnchecked(int NId, TStr NName) {
773    if (IsNode(NId)) { return -1;}
774    MxNId = TMath::Mx(NId+1, MxNId());
775    NodeH.AddDat(NId, TNode(NId, NName));
776    return NId;
777  }
778  void THGraph::DelNode(const int& NId) {
779    AssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist", NId));
780    TNode& Node = GetNode(NId);
781    int EId = Node.EIdV.GetVal(0);
782    int NumNei;
783    TIntSet& ENIdsHS = GetEdge(EId).NeiNIdSH;
784    for (int e = 0; e < Node.GetDeg(); e++) {
785      EId = Node.EIdV.GetVal(e);
786      ENIdsHS = GetEdge(EId).NeiNIdSH;
787      int iKey;
788      for (int i=0; i < ENIdsHS.Len(); i++) {
789        iKey = ENIdsHS.GetKey(i);
790        if (iKey == NId) { continue; }
791        GetNode(iKey).DelNeighbor(NId);
792      }
793      NumNei = ENIdsHS.Len();
794      N2Edges = N2Edges - (NumNei*(NumNei-1))/2 + ((NumNei-1)*(NumNei-2))/2;
795      if (ENIdsHS.Len() > 2) {
796        GetEdge(EId).NeiNIdSH.DelKey(NId);
797      } else { DelEdge(EId); }
798      NodeH.DelKey(NId);
799    }
800    delete &Node;
801  }
802  void THGraph::TNode::UpdEInfo(const int& EId, const TIntSet& ENodesHS){
803    if (! EIdV.IsIn(EId)) {
804      EIdV.Add(EId);
805      for (int j = 0; j < ENodesHS.Len(); j++) {
806        if (Id == ENodesHS.GetKey(j)) { continue; }
807        if (! NbrNIdENumH.IsKey(ENodesHS.GetKey(j))) {
808          NbrNIdENumH.AddDat(ENodesHS.GetKey(j), 1);
809        } else {
810          NbrNIdENumH.AddDat(ENodesHS.GetKey(j), 1 + NbrNIdENumH.GetDat(ENodesHS.GetKey(j)));
811        }
812      }
813    }
814  }
815  inline THGraph::TEdge::TEdge( THGraph* GraphPt, const TIntSet& NodeIdsHS) {
816    TInt EIdCandidate = GraphPt->NEdges;
817    while (GraphPt->EdgeH.IsKey(EIdCandidate)) { EIdCandidate++; }
818    TEdge(EIdCandidate, NodeIdsHS, GraphPt);
819  }
820  inline THGraph::TEdge::TEdge( THGraph* GraphPt, const TIntV& NodeIdsV) {
821    TInt EIdCandidate = GraphPt->NEdges;
822    while (GraphPt->EdgeH.IsKey(EIdCandidate)) { EIdCandidate++; }
823    TEdge(EIdCandidate, NodeIdsV, GraphPt);
824  }
825  void THGraph::TEdge::UpdNEInfo(const TIntSet& ENodesHS){
826    for (int i = 0; i < ENodesHS.Len(); i++) {
827      Graph->GetNode(ENodesHS.GetKey(i)).UpdEInfo(Id, ENodesHS);
828    }
829  }
830  bool THGraph::IsEdge(const TIntSet& NIdH) {
831    if (NIdH.Len() < 2) { return false; }
832    if (! IsNode(NIdH.GetKey(0))) { return false; }
833    int NId = NIdH.GetKey(0);
834    TIntSet SharedEIdsH;
835    NodeH.GetDat(NId).GetEIDs(SharedEIdsH);
836    for (int n = 1; n< NIdH.Len(); n++){
837      int N1Id = NIdH.GetKey(n);
838      TIntSet NeiEIdH;
839      NodeH.GetDat(N1Id).GetEIDs(NeiEIdH);
840      TIntersect(SharedEIdsH, NeiEIdH);
841      if (SharedEIdsH.Len()==0) { return false; }
842    }
843    for (THashSetKeyI<TInt> e = SharedEIdsH.BegI(); e < SharedEIdsH.EndI(); e++) {
844      if(GetEI(e.GetKey()).Len() == NIdH.Len()) {
845        return true;
846      }
847    }
848    return false;
849  }
850  int THGraph::AddEdge(const TIntSet& NIdH, int& EId) {
851    if (IsEdge(NIdH)) { return -1; }
852    EId = TMath::Mx(EId, MxEId());
853    MxEId = EId + 1;
854    IAssertR(!IsEdgeId(EId), TStr::Fmt("EdgeId %d already exists", EId));
855    EdgeH.AddDat(EId, TEdge(EId, NIdH, this));
856    EdgeH.GetDat(EId).UpdNEInfo(NIdH);
857    NEdges++;
858    N2Edges += (NIdH.Len() * (NIdH.Len()-1))/2;
859    return EId;
860  }
861  int THGraph::AssertNodes(const TIntSet& NodesIS) {
862    int NKey;
863    for (int N=0; N < NodesIS.Len(); N++) {
864      NKey = NodesIS.GetKey(N);
865      if (! IsNode(NKey)) {return NKey;}
866    }
867    return -1;
868  }
869  void THGraph::DelEdge(const int& EId) {
870    IAssertR(IsEdgeId(EId), TStr::Fmt("EdgeId %d not found", EId));
871    TIntSet NodeIdsHS = GetEdge(EId).NeiNIdSH;
872    int iKey, jKey;
873    for (int i=NodeIdsHS.FFirstKeyId(); NodeIdsHS.FNextKeyId(i); ) {
874      iKey = NodeIdsHS.GetKey(i);
875      for (int j=NodeIdsHS.FFirstKeyId(); NodeIdsHS.FNextKeyId(j); ) {
876        if (i==j) { continue; }
877        jKey = NodeIdsHS.GetKey(j);
878        GetNode(iKey).DelNeighbor(jKey);
879      }
880    }
881    EdgeH.DelKey(EId);
882    int ESize = GetEdge(EId).NeiNIdSH.Len();
883    NEdges--;
884    N2Edges -= (ESize*(ESize-1))/2;
885    delete &GetEdge(EId);
886  }
887  void THGraph::GetNIdV(TIntV& NIdV) const {
888    NIdV.Gen(GetNodes(), 0);
889    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
890      NIdV.Add(NodeH.GetKey(N)); }
891  }
892  void THGraph::Defrag(const bool& OnlyNodeLinks) {
893    int nKey;
894    for (int n = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(n); ) {
895      nKey = EdgeH.GetKey(n);
896      if (! EdgeH.GetDat(nKey).NeiNIdSH.IsKeyIdEqKeyN()) {
897        EdgeH.GetDat(nKey).NeiNIdSH.Defrag();
898      }
899    }
900    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
901      nKey = NodeH.GetKey(n);
902      NodeH.GetDat(nKey).EIdV.Pack();
903      if (! NodeH.GetDat(nKey).NbrNIdENumH.IsKeyIdEqKeyN()) {
904        NodeH.GetDat(nKey).NbrNIdENumH.Defrag();
905      }
906    }
907    if (! OnlyNodeLinks) {
908      if (! NodeH.IsKeyIdEqKeyN()){ NodeH.Defrag(); }
909      if (! EdgeH.IsKeyIdEqKeyN()){ EdgeH.Defrag(); }
910    }
911  }
912  void THGraph::PrintEdge(const int EId) {
913    if (! EdgeH.IsKey(EId)) {
914      printf("\nEdge Not Found!\n");
915    }
916    TIntV NV;
917    TStr EStr("Edge nodes: ");
918    EdgeH.GetDat(EId).GetNodesV(NV);
919    for (int i = 0; i < NV.Len(); i++) {
920      EStr += (" " + NV[i].GetStr());
921    }
922    EStr += "\n";
923    printf(EStr.GetCStr());
924  }
925  void THGraph::Dump(FILE *OutF) const {
926    const int NodePlaces = (int) ceil(log10((double) GetNodes()));
927    int NKey;
928    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
929      NKey = NodeH.GetKey(N);
930      const TNode& Node = NodeH.GetDat(NKey);
931      fprintf(OutF, "  %*d [%d] ", NodePlaces, Node.GetId(), Node.GetDeg());
932      for (int edge = 0; edge < Node.GetDeg(); edge++) {
933        fprintf(OutF, " %*d", NodePlaces, Node.GetNbrNId(edge)); }
934      fprintf(OutF, "\n");
935    }
936    fprintf(OutF, "\n");
937  }
938  PHGraph THGraph::GetSmallGraph() {
939    PHGraph Graph = THGraph::New();
940    for (int i = 0; i < 5; i++) { Graph->AddNode(i); }
941    TIntV EV(3);
942    int el[] = {0,1,3};
943    for (int i = 0; i < 3; i++)
944      EV.Add(el[i]);
945    Graph->AddEdge(EV);
946    return Graph;
947  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lx.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph_2.cpp</div>
                </div>
                <div class="column column_space"><pre><code>676  void TOLx::PutSym(const TLxSym& Sym){
677    TStr Str;
678    if ((syMnRw<=Sym)&&(Sym<=syMxRw)){
679      Str=Str=RwSymH[Sym];
680    } else {
681      Str=TLxSymStr::GetSymStr(Sym);
682    }
</pre></code></div>
                <div class="column column_space"><pre><code>4  int TUNGraph::AddNode(int NId) {
5    if (NId == -1) {
6      NId = MxNId;  MxNId++;
7    } else {
8      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
9      MxNId = TMath::Mx(NId+1, MxNId());
10    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    