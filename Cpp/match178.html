<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ConfigurableDomain.h & ConfigurableDomains.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ConfigurableDomain.h & ConfigurableDomains.h
      </h3>
      <h1 align="center">
        16.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ConfigurableDomain.h (16.666666%)<TH>ConfigurableDomains.h (16.883118%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match178-0.html#0',2,'match178-1.html#0',3)" NAME="0">(85-91)<TD><A HREF="javascript:ZweiFrames('match178-0.html#0',2,'match178-1.html#0',3)" NAME="0">(123-128)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match178-0.html#1',2,'match178-1.html#1',3)" NAME="1">(63-77)<TD><A HREF="javascript:ZweiFrames('match178-0.html#1',2,'match178-1.html#1',3)" NAME="1">(102-116)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomain.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#pragma once

#include &quot;XmlSerializingContext.h&quot;
#include &quot;XmlDomainImportContext.h&quot;
#include &quot;XmlDomainExportContext.h&quot;
#include &quot;SyncerSet.h&quot;
#include &quot;Results.h&quot;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;

class CConfigurableElement;
class CDomainConfiguration;
class CParameterBlackboard;
class CSelectionCriteriaDefinition;

class CConfigurableDomain : public CElement
{
    typedef std::list&lt;CConfigurableElement *&gt;::const_iterator ConfigurableElementListIterator;
    typedef std::map&lt;const CConfigurableElement *, CSyncerSet *&gt;::const_iterator
        ConfigurableElementToSyncerSetMapIterator;

public:
    CConfigurableDomain() = default;
    CConfigurableDomain(const std::string &amp;strName);
    ~CConfigurableDomain() override;

    // Sequence awareness
    void setSequenceAwareness(bool bSequenceAware);
<A NAME="1"></A>    bool getSequenceAwareness() const;

    // Configuration Management
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match178-1.html#1',3,'match178-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    bool createConfiguration(const std::string &amp;strName,
                             const CParameterBlackboard *pMainBlackboard, std::string &amp;strError);
    bool deleteConfiguration(const std::string &amp;strName, std::string &amp;strError);
    bool renameConfiguration(const std::string &amp;strName, const std::string &amp;strNewName,
                             std::string &amp;strError);

    /** Restore a configuration
     *
     * @param[in] configurationName the configuration name
     * @param[in] mainBlackboard the application main blackboard
     * @param[in] autoSync boolean which indicates if auto sync mechanism is on
     * @param[out] errors, errors encountered during restoration
     * @return true if success false otherwise
     */
    bool restoreConfiguration(const std::string &amp;configurationName,</B></FONT>
                              CParameterBlackboard *mainBlackboard, bool autoSync,
                              core::Results &amp;errors) const;

    bool saveConfiguration(const std::string &amp;strName, const CParameterBlackboard *pMainBlackboard,
<A NAME="0"></A>                           std::string &amp;strError);
    bool setElementSequence(const std::string &amp;strConfiguration,
                            const std::vector&lt;std::string&gt; &amp;astrNewElementSequence,
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match178-1.html#0',3,'match178-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                            std::string &amp;strError);
    bool getElementSequence(const std::string &amp;strConfiguration, std::string &amp;strResult) const;
    bool setApplicationRule(const std::string &amp;strConfiguration,
                            const std::string &amp;strApplicationRule,
                            const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition,
                            std::string &amp;strError);
    bool clearApplicationRule(const std::string &amp;strConfiguration, std::string &amp;strError);</B></FONT>
    bool getApplicationRule(const std::string &amp;strConfiguration, std::string &amp;strResult) const;

    // Last applied configuration name
    std::string getLastAppliedConfigurationName() const;

    // Pending configuration name
    std::string getPendingConfigurationName() const;

    // Associated Configurable elements
    void gatherConfigurableElements(
        std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const;
    void listAssociatedToElements(std::string &amp;strResult) const;

    /** Add a configurable element to the domain
     *
     * @param[in] pConfigurableElement pointer to the element to add
     * @param[in] pMainBlackboard pointer to the application main blackboard
     * @param[out] infos useful information we can provide to client
     * @return true if succeed false otherwise
     */
    bool addConfigurableElement(CConfigurableElement *pConfigurableElement,
                                const CParameterBlackboard *pMainBlackboard, core::Results &amp;infos);

    bool removeConfigurableElement(CConfigurableElement *pConfigurableElement,
                                   std::string &amp;strError);

    // Blackboard Configuration and Base Offset retrieval
    CParameterBlackboard *findConfigurationBlackboard(
        const std::string &amp;strConfiguration, const CConfigurableElement *pConfigurableElement,
        size_t &amp;baseOffset, bool &amp;bIsLastApplied, std::string &amp;strError) const;

    /** Split the domain in two.
     * Remove an element of a domain and create a new domain which owns the element.
     *
     * @param[in] pConfigurableElement pointer to the element to remove
     * @param[out] infos useful information we can provide to client
     * @return true if succeed false otherwise
     */
    bool split(CConfigurableElement *pConfigurableElement, core::Results &amp;infos);

    // Ensure validity on whole domain from main blackboard
    void validate(const CParameterBlackboard *pMainBlackboard);

    /** Apply the configuration if required
     *
     * @param[in] pParameterBlackboard the blackboard to synchronize
     * @param[in] pSyncerSet pointer to the set containing application syncers
     * @param[in] bForced boolean used to force configuration application
     * @param[out] info string containing useful information we can provide to client
     */
    void apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet *pSyncerSet, bool bForced,
               std::string &amp;info) const;

    // Return applicable configuration validity for given configurable element
    bool isApplicableConfigurationValid(const CConfigurableElement *pConfigurableElement) const;

    // From IXmlSink
    bool fromXml(const CXmlElement &amp;xmlElement,
                 CXmlSerializingContext &amp;serializingContext) override;

    // From IXmlSource
    void toXml(CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const override;
    void childrenToXml(CXmlElement &amp;xmlElement,
                       CXmlSerializingContext &amp;serializingContext) const override;

    // Class kind
    std::string getKind() const override;

protected:
    // Content dumping
    std::string logValue(utility::ErrorContext &amp;errorContext) const override;

private:
    // Get pending configuration
    const CDomainConfiguration *getPendingConfiguration() const;

    // Search for an applicable configuration
    const CDomainConfiguration *findApplicableDomainConfiguration() const;

    // Returns true if children dynamic creation is to be dealt with (here, will allow child
    // deletion upon clean)
    bool childrenAreDynamic() const override;

    // Ensure validity on areas related to configurable element
    void validateAreas(const CConfigurableElement *pConfigurableElement,
                       const CParameterBlackboard *pMainBlackboard);

    // Attempt validation for all configurable element's areas, relying on already existing valid
    // configuration inside domain
    void autoValidateAll();

    // Attempt validation for one configurable element's areas, relying on already existing valid
    // configuration inside domain
    void autoValidateAreas(const CConfigurableElement *pConfigurableElement);

    // Attempt configuration validation for all configurable elements' areas, relying on already
    // existing valid configuration inside domain
    bool autoValidateConfiguration(CDomainConfiguration *pDomainConfiguration);

    // Search for a valid configuration for given configurable element
    const CDomainConfiguration *findValidDomainConfiguration(
        const CConfigurableElement *pConfigurableElement) const;

    // In case configurable element was removed
    void computeSyncSet();

    // Check configurable element already attached
    bool containsConfigurableElement(
        const CConfigurableElement *pConfigurableCandidateElement) const;

    /** Merge any descended configurable element to this one
     *
     * @param[in] newElement pointer to element which has potential descendants which can be merged
     * @param[out] infos useful information we can provide to client
     */
    void mergeAlreadyAssociatedDescendantConfigurableElements(CConfigurableElement *newElement,
                                                              core::Results &amp;infos);

    void mergeConfigurations(CConfigurableElement *pToConfigurableElement,
                             CConfigurableElement *pFromConfigurableElement);

    /** Actually realize the association between the domain and a configurable  element
     *
     * @param[in] pConfigurableElement pointer to the element to add
     * @param[out] infos useful information we can provide to client
     * @param[in] (optional) pMainBlackboard, pointer to the application main blackboard
     *            Default value is NULL, when provided, blackboard area concerning the configurable
     *            element are validated.
     */
    void doAddConfigurableElement(CConfigurableElement *pConfigurableElement, core::Results &amp;infos,
                                  const CParameterBlackboard *pMainBlackboard = nullptr);

    void doRemoveConfigurableElement(CConfigurableElement *pConfigurableElement,
                                     bool bRecomputeSyncSet);

    // XML parsing
    /**
     * Deserialize domain configurations from an Xml document and add them to
     * the domain.
     *
     * @param[in] xmlElement the XML element to be parsed
     * @param[in] serializingContext context for the deserialization
     *
     * @return false if an error occurs, true otherwise.
     */
    bool parseDomainConfigurations(const CXmlElement &amp;xmlElement,
                                   CXmlDomainImportContext &amp;serializingContext);
    /**
     * Deserialize domain elements from an Xml document and add them to
     * the domain.
     *
     * @param[in] xmlElement the XML element to be parsed
     * @param[in] serializingContext context for the deserialization
     *
     * @return false if an error occurs, true otherwise.
     */
    bool parseConfigurableElements(const CXmlElement &amp;xmlElement,
                                   CXmlDomainImportContext &amp;serializingContext);
    /**
     * Deserialize settings from an Xml document and add them to
     * the domain.
     *
     * @param[in] xmlElement the XML element to be parsed
     * @param[in] xmlDomainImportContext context for the deserialization
     *
     * @return false if an error occurs, true otherwise.
     */
    bool parseSettings(const CXmlElement &amp;xmlElement, CXmlDomainImportContext &amp;serializingContext);

    // XML composing
    void composeDomainConfigurations(CXmlElement &amp;xmlElement,
                                     CXmlSerializingContext &amp;serializingContext) const;
    void composeConfigurableElements(CXmlElement &amp;xmlElement) const;
    void composeSettings(CXmlElement &amp;xmlElement, CXmlDomainExportContext &amp;context) const;

    // Syncer set retrieval from configurable element
    CSyncerSet *getSyncerSet(const CConfigurableElement *pConfigurableElement) const;

    // Configuration retrieval
    CDomainConfiguration *findConfiguration(const std::string &amp;strConfiguration,
                                            std::string &amp;strError);
    const CDomainConfiguration *findConfiguration(const std::string &amp;strConfiguration,
                                                  std::string &amp;strError) const;

    // Configurable elements
    std::list&lt;CConfigurableElement *&gt; _configurableElementList;

    // Associated syncer sets
    std::map&lt;const CConfigurableElement *, CSyncerSet *&gt; _configurableElementToSyncerSetMap;

    // Sequence awareness
    bool _bSequenceAware{false};

    // Syncer set used to ensure propoer synchronization of restored configurable elements
    CSyncerSet _syncerSet;

    // Last applied configuration
    mutable const CDomainConfiguration *_pLastAppliedConfiguration{nullptr};
};
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomains.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#pragma once

#include &quot;Element.h&quot;
#include &quot;Results.h&quot;
#include &lt;set&gt;
#include &lt;string&gt;

class CParameterBlackboard;
class CConfigurableElement;
class CSyncerSet;
class CConfigurableDomain;
class CSelectionCriteriaDefinition;

class CConfigurableDomains : public CElement
{
public:
    // Configuration/Domains handling
    /// Domains
    bool createDomain(const std::string &amp;strName, std::string &amp;strError);

    /*
     * Adds a domain object to configurable domains. The ConfigurableDomains
     * object takes ownership of the ConfigurableDomain object.
     *
     * @param[in] pDomain the domain object.
     * @param[in] bOverwrite if false, will refuse to overwrite an existing
     * domain, otherwise, an existing domain with the same name will first be
     * removed.
     * @param[in,out] strError error message
     *
     * @returns true if the domain was successfully added
     */
    bool addDomain(CConfigurableDomain &amp;domain, bool bOverwrite, std::string &amp;strError);

    /**
     * Delete a domain by name
     *
     * @param[in] strName name of the domain to be deleted
     * @param[in,out] strError error message
     *
     * @returns true of the domain was sucessfully deleted, false otherwise (i.e.
     * the domain didn't exist).
     */
    bool deleteDomain(const std::string &amp;strName, std::string &amp;strError);
    void deleteAllDomains();
    bool renameDomain(const std::string &amp;strName, const std::string &amp;strNewName,
                      std::string &amp;strError);
    bool setSequenceAwareness(const std::string &amp;strDomain, bool bSequenceAware,
                              std::string &amp;strError);
    bool getSequenceAwareness(const std::string &amp;strDomain, bool &amp;bSequenceAware,
                              std::string &amp;strError) const;
    bool listDomainElements(const std::string &amp;strDomain, std::string &amp;strResult) const;

    /** Split a domain in two.
     * Remove an element of a domain and create a new domain which owns the element.
     *
     * @param[in] domainName the domain name
     * @param[in] element pointer to the element to remove
     * @param[out] infos useful information we can provide to client
     * @return true if succeed false otherwise
     */
    bool split(const std::string &amp;domainName, CConfigurableElement *element, core::Results &amp;infos);

    void listAssociatedElements(std::string &amp;strResult) const;
    void listConflictingElements(std::string &amp;strResult) const;
    void listDomains(std::string &amp;strResult) const;
    /// Configurations
    bool listConfigurations(const std::string &amp;strDomain, std::string &amp;strResult) const;
    bool createConfiguration(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
<A NAME="1"></A>                             const CParameterBlackboard *pMainBlackboard, std::string &amp;strError);
    bool deleteConfiguration(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                             std::string &amp;strError);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178-0.html#1',2,'match178-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    bool renameConfiguration(const std::string &amp;strDomain, const std::string &amp;strConfigurationName,
                             const std::string &amp;strNewConfigurationName, std::string &amp;strError);

    /** Restore a configuration
     *
     * @param[in] strDomain the domain name
     * @param[in] strConfiguration the configuration name
     * @param[in] pMainBlackboard the application main blackboard
     * @param[in] bAutoSync boolean which indicates if auto sync mechanism is on
     * @param[out] errors, errors encountered during restoration
     * @return true if success false otherwise
     */
    bool restoreConfiguration(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                              CParameterBlackboard *pMainBlackboard, bool bAutoSync,
                              core::Results &amp;errors) const;</B></FONT>

    bool saveConfiguration(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                           const CParameterBlackboard *pMainBlackboard, std::string &amp;strError);
<A NAME="0"></A>    bool setElementSequence(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                            const std::vector&lt;std::string&gt; &amp;astrNewElementSequence,
                            std::string &amp;strError);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178-0.html#0',2,'match178-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    bool getElementSequence(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                            std::string &amp;strResult) const;
    bool setApplicationRule(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                            const std::string &amp;strApplicationRule,
                            const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition,
                            std::string &amp;strError);</B></FONT>
    bool clearApplicationRule(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                              std::string &amp;strError);
    bool getApplicationRule(const std::string &amp;strDomain, const std::string &amp;strConfiguration,
                            std::string &amp;strResult) const;

    // Last applied configurations
    void listLastAppliedConfigurations(std::string &amp;strResult) const;

    /** Associate a configurable element to a domain
     *
     * @param[in] domainName the domain name
     * @param[in] element pointer to the element to add
     * @param[in] mainBlackboard pointer to the application main blackboard
     * @param[out] infos useful information we can provide to client
     * @return true if succeed false otherwise
     */
    bool addConfigurableElementToDomain(const std::string &amp;domainName,
                                        CConfigurableElement *element,
                                        const CParameterBlackboard *mainBlackboard,
                                        core::Results &amp;infos);

    bool removeConfigurableElementFromDomain(const std::string &amp;strDomain,
                                             CConfigurableElement *pConfigurableElement,
                                             std::string &amp;strError);

    // Configuration Blackboard for element
    CParameterBlackboard *findConfigurationBlackboard(
        const std::string &amp;strDomain, const std::string &amp;strConfiguration,
        const CConfigurableElement *pConfigurableElement, size_t &amp;baseOffset, bool &amp;bIsLastApplied,
        std::string &amp;strError) const;

    const CConfigurableDomain *findConfigurableDomain(const std::string &amp;strDomain,
                                                      std::string &amp;strError) const;

    // From IXmlSource
    void toXml(CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const override;

    // Ensure validity on whole domains from main blackboard
    void validate(const CParameterBlackboard *pMainBlackboard);

    /** Apply the configuration if required
     *
     * @param[in] pParameterBlackboard the blackboard to synchronize
     * @param[in] syncerSet the set containing application syncers
     * @param[in] bForce boolean used to force configuration application
     * @param[out] infos useful information we can provide to client
     */
    void apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet &amp;syncerSet, bool bForce,
               core::Results &amp;infos) const;

    // Class kind
    std::string getKind() const override;

private:
    /** Delete a domain
     *
     * @param(in] configurableDomain domain to be deleted
     * @param[in,out] strError error message
     * @returns true of the domain was sucessfully deleted, false otherwise (i.e.
     * the domain didn't exist).
     */
    void deleteDomain(CConfigurableDomain &amp;configurableDomain);
    // Returns true if children dynamic creation is to be dealt with
    bool childrenAreDynamic() const override;
    // Gather owned configurable elements owned by any domain
    void gatherAllOwnedConfigurableElements(
        std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const;
    // Domain retrieval
    CConfigurableDomain *findConfigurableDomain(const std::string &amp;strDomain,
                                                std::string &amp;strError);
};
</PRE>
</div>
  </div>
</body>
</html>
