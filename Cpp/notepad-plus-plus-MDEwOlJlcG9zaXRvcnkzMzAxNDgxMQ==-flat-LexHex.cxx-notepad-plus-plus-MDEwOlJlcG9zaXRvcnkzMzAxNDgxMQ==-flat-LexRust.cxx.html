
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHex.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsNewline(const int ch);
20  static int GetHexaNibble(char hd);
21  static int GetHexaChar(char hd1, char hd2);
22  static int GetHexaChar(Sci_PositionU pos, Accessor &styler);
23  static bool ForwardWithinLine(StyleContext &sc, Sci_Position nb = 1);
24  static bool PosInSameRecord(Sci_PositionU pos1, Sci_PositionU pos2, Accessor &styler);
25  static Sci_Position CountByteCount(Sci_PositionU startPos, Sci_Position uncountedDigits, Accessor &styler);
26  static int CalcChecksum(Sci_PositionU startPos, Sci_Position cnt, bool twosCompl, Accessor &styler);
27  static Sci_PositionU GetSrecRecStartPosition(Sci_PositionU pos, Accessor &styler);
28  static int GetSrecByteCount(Sci_PositionU recStartPos, Accessor &styler);
29  static Sci_Position CountSrecByteCount(Sci_PositionU recStartPos, Accessor &styler);
30  static int GetSrecAddressFieldSize(Sci_PositionU recStartPos, Accessor &styler);
31  static int GetSrecAddressFieldType(Sci_PositionU recStartPos, Accessor &styler);
32  static int GetSrecDataFieldType(Sci_PositionU recStartPos, Accessor &styler);
33  static Sci_Position GetSrecRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &styler);
34  static int GetSrecChecksum(Sci_PositionU recStartPos, Accessor &styler);
35  static int CalcSrecChecksum(Sci_PositionU recStartPos, Accessor &styler);
36  static Sci_PositionU GetIHexRecStartPosition(Sci_PositionU pos, Accessor &styler);
37  static int GetIHexByteCount(Sci_PositionU recStartPos, Accessor &styler);
38  static Sci_Position CountIHexByteCount(Sci_PositionU recStartPos, Accessor &styler);
39  static int GetIHexAddressFieldType(Sci_PositionU recStartPos, Accessor &styler);
40  static int GetIHexDataFieldType(Sci_PositionU recStartPos, Accessor &styler);
41  static int GetIHexRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &styler);
42  static int GetIHexChecksum(Sci_PositionU recStartPos, Accessor &styler);
43  static int CalcIHexChecksum(Sci_PositionU recStartPos, Accessor &styler);
44  static int GetTEHexDigitCount(Sci_PositionU recStartPos, Accessor &styler);
45  static Sci_Position CountTEHexDigitCount(Sci_PositionU recStartPos, Accessor &styler);
46  static int GetTEHexAddressFieldType(Sci_PositionU recStartPos, Accessor &styler);
47  static int GetTEHexChecksum(Sci_PositionU recStartPos, Accessor &styler);
48  static int CalcTEHexChecksum(Sci_PositionU recStartPos, Accessor &styler);
49  static inline bool IsNewline(const int ch)
50  {
51      return (ch == '\n' || ch == '\r');
52  }
53  static int GetHexaNibble(char hd)
54  {
55  	int hexValue = 0;
56  	if (hd >= '0' && hd <= '9') {
57  		hexValue += hd - '0';
58  	} else if (hd >= 'A' && hd <= 'F') {
59  		hexValue += hd - 'A' + 10;
60  	} else if (hd >= 'a' && hd <= 'f') {
61  		hexValue += hd - 'a' + 10;
62  	} else {
63  		return -1;
64  	}
65  	return hexValue;
66  }
67  static int GetHexaChar(char hd1, char hd2)
68  {
69  	int hexValue = 0;
70  	if (hd1 >= '0' && hd1 <= '9') {
71  		hexValue += 16 * (hd1 - '0');
72  	} else if (hd1 >= 'A' && hd1 <= 'F') {
73  		hexValue += 16 * (hd1 - 'A' + 10);
74  	} else if (hd1 >= 'a' && hd1 <= 'f') {
75  		hexValue += 16 * (hd1 - 'a' + 10);
76  	} else {
77  		return -1;
78  	}
79  	if (hd2 >= '0' && hd2 <= '9') {
80  		hexValue += hd2 - '0';
81  	} else if (hd2 >= 'A' && hd2 <= 'F') {
82  		hexValue += hd2 - 'A' + 10;
83  	} else if (hd2 >= 'a' && hd2 <= 'f') {
84  		hexValue += hd2 - 'a' + 10;
85  	} else {
86  		return -1;
87  	}
88  	return hexValue;
89  }
90  static int GetHexaChar(Sci_PositionU pos, Accessor &styler)
91  {
92  	char highNibble, lowNibble;
93  	highNibble = styler.SafeGetCharAt(pos);
94  	lowNibble = styler.SafeGetCharAt(pos + 1);
95  	return GetHexaChar(highNibble, lowNibble);
96  }
97  static bool ForwardWithinLine(StyleContext &sc, Sci_Position nb)
98  {
99  	for (Sci_Position i = 0; i < nb; i++) {
100  		if (sc.atLineEnd) {
101  			sc.SetState(SCE_HEX_DEFAULT);
102  			sc.Forward();
103  			return false;
104  		} else {
105  			sc.Forward();
106  		}
107  	}
108  	return true;
109  }
110  static bool PosInSameRecord(Sci_PositionU pos1, Sci_PositionU pos2, Accessor &styler)
111  {
112  	return styler.GetLine(pos1) == styler.GetLine(pos2);
113  }
114  static Sci_Position CountByteCount(Sci_PositionU startPos, Sci_Position uncountedDigits, Accessor &styler)
115  {
116  	Sci_Position cnt;
117  	Sci_PositionU pos;
118  	pos = startPos;
119  	while (!IsNewline(styler.SafeGetCharAt(pos, '\n'))) {
120  		pos++;
121  	}
122  	cnt = static_cast<Sci_Position>(pos - startPos) - uncountedDigits;
123  	if (cnt >= 0) {
124  		cnt++;
125  	}
126  	cnt /= 2;
127  	return cnt;
128  }
129  static int CalcChecksum(Sci_PositionU startPos, Sci_Position cnt, bool twosCompl, Accessor &styler)
130  {
131  	int cs = 0;
132  	for (Sci_PositionU pos = startPos; pos < startPos + cnt; pos += 2) {
133  		int val = GetHexaChar(pos, styler);
134  		if (val < 0) {
135  			return val;
136  		}
137  		cs += val;
138  	}
139  	if (twosCompl) {
140  		return -cs & 0xFF;
141  	} else {
142  		return ~cs & 0xFF;
143  	}
144  }
145  static Sci_PositionU GetSrecRecStartPosition(Sci_PositionU pos, Accessor &styler)
146  {
147  	while (styler.SafeGetCharAt(pos) != 'S') {
148  		pos--;
149  	}
150  	return pos;
151  }
152  static int GetSrecByteCount(Sci_PositionU recStartPos, Accessor &styler)
153  {
154  	int val;
155  	val = GetHexaChar(recStartPos + 2, styler);
156  	if (val < 0) {
157  	       val = 0;
158  	}
159  	return val;
160  }
161  static Sci_Position CountSrecByteCount(Sci_PositionU recStartPos, Accessor &styler)
162  {
163  	return CountByteCount(recStartPos, 4, styler);
164  }
165  static int GetSrecAddressFieldSize(Sci_PositionU recStartPos, Accessor &styler)
166  {
167  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
168  		case '0':
169  		case '1':
170  		case '5':
171  		case '9':
172  			return 2; 
173  		case '2':
174  		case '6':
175  		case '8':
176  			return 3; 
177  		case '3':
178  		case '7':
179  			return 4; 
180  		default:
181  			return 0;
182  	}
183  }
184  static int GetSrecAddressFieldType(Sci_PositionU recStartPos, Accessor &styler)
185  {
186  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
187  		case '0':
188  			return SCE_HEX_NOADDRESS;
189  		case '1':
190  		case '2':
191  		case '3':
192  			return SCE_HEX_DATAADDRESS;
193  		case '5':
194  		case '6':
195  			return SCE_HEX_RECCOUNT;
196  		case '7':
197  		case '8':
198  		case '9':
199  			return SCE_HEX_STARTADDRESS;
200  		default: 
201  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
202  	}
203  }
204  static int GetSrecDataFieldType(Sci_PositionU recStartPos, Accessor &styler)
205  {
206  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
207  		case '0':
208  		case '1':
209  		case '2':
210  		case '3':
211  			return SCE_HEX_DATA_ODD;
212  		case '5':
213  		case '6':
214  		case '7':
215  		case '8':
216  		case '9':
217  			return SCE_HEX_DATA_EMPTY;
218  		default: 
219  			return SCE_HEX_DATA_UNKNOWN;
220  	}
221  }
222  static Sci_Position GetSrecRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &styler)
223  {
224  	switch (styler.SafeGetCharAt(recStartPos + 1)) {
225  		case '5':
226  		case '6':
227  		case '7':
228  		case '8':
229  		case '9':
230  			return 0;
231  		default:
232  			return GetSrecByteCount(recStartPos, styler)
233  				- GetSrecAddressFieldSize(recStartPos, styler)
234  				- 1; 
235  	}
236  }
237  static int GetSrecChecksum(Sci_PositionU recStartPos, Accessor &styler)
238  {
239  	int byteCount;
240  	byteCount = GetSrecByteCount(recStartPos, styler);
241  	return GetHexaChar(recStartPos + 2 + byteCount * 2, styler);
242  }
243  static int CalcSrecChecksum(Sci_PositionU recStartPos, Accessor &styler)
244  {
245  	Sci_Position byteCount;
246  	byteCount = GetSrecByteCount(recStartPos, styler);
247  	return CalcChecksum(recStartPos + 2, byteCount * 2, false, styler);
248  }
249  static Sci_PositionU GetIHexRecStartPosition(Sci_PositionU pos, Accessor &styler)
250  {
251  	while (styler.SafeGetCharAt(pos) != ':') {
252  		pos--;
253  	}
254  	return pos;
255  }
256  static int GetIHexByteCount(Sci_PositionU recStartPos, Accessor &styler)
257  {
258  	int val;
259  	val = GetHexaChar(recStartPos + 1, styler);
260  	if (val < 0) {
261  	       val = 0;
262  	}
263  	return val;
264  }
265  static Sci_Position CountIHexByteCount(Sci_PositionU recStartPos, Accessor &styler)
266  {
267  	return CountByteCount(recStartPos, 11, styler);
268  }
269  static int GetIHexAddressFieldType(Sci_PositionU recStartPos, Accessor &styler)
270  {
271  	if (!PosInSameRecord(recStartPos, recStartPos + 7, styler)) {
272  		return SCE_HEX_ADDRESSFIELD_UNKNOWN;
273  	}
274  	switch (GetHexaChar(recStartPos + 7, styler)) {
275  		case 0x00:
276  			return SCE_HEX_DATAADDRESS;
277  		case 0x01:
278  		case 0x02:
279  		case 0x03:
280  		case 0x04:
281  		case 0x05:
282  			return SCE_HEX_NOADDRESS;
283  		default: 
284  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
285  	}
286  }
287  static int GetIHexDataFieldType(Sci_PositionU recStartPos, Accessor &styler)
288  {
289  	switch (GetHexaChar(recStartPos + 7, styler)) {
290  		case 0x00:
291  			return SCE_HEX_DATA_ODD;
292  		case 0x01:
293  			return SCE_HEX_DATA_EMPTY;
294  		case 0x02:
295  		case 0x04:
296  			return SCE_HEX_EXTENDEDADDRESS;
297  		case 0x03:
298  		case 0x05:
299  			return SCE_HEX_STARTADDRESS;
300  		default: 
301  			return SCE_HEX_DATA_UNKNOWN;
302  	}
303  }
304  static int GetIHexRequiredDataFieldSize(Sci_PositionU recStartPos, Accessor &styler)
305  {
306  	switch (GetHexaChar(recStartPos + 7, styler)) {
307  		case 0x01:
308  			return 0;
309  		case 0x02:
310  		case 0x04:
311  			return 2;
312  		case 0x03:
313  		case 0x05:
314  			return 4;
315  		default:
316  			return GetIHexByteCount(recStartPos, styler);
317  	}
318  }
319  static int GetIHexChecksum(Sci_PositionU recStartPos, Accessor &styler)
320  {
321  	int byteCount;
322  	byteCount = GetIHexByteCount(recStartPos, styler);
323  	return GetHexaChar(recStartPos + 9 + byteCount * 2, styler);
324  }
325  static int CalcIHexChecksum(Sci_PositionU recStartPos, Accessor &styler)
326  {
327  	int byteCount;
328  	byteCount = GetIHexByteCount(recStartPos, styler);
329  	return CalcChecksum(recStartPos + 1, 8 + byteCount * 2, true, styler);
330  }
331  static int GetTEHexDigitCount(Sci_PositionU recStartPos, Accessor &styler)
332  {
333  	int val = GetHexaChar(recStartPos + 1, styler);
334  	if (val < 0)
335  	       val = 0;
336  	return val;
337  }
338  static Sci_Position CountTEHexDigitCount(Sci_PositionU recStartPos, Accessor &styler)
339  {
340  	Sci_PositionU pos;
341  	pos = recStartPos+1;
342  	while (!IsNewline(styler.SafeGetCharAt(pos, '\n'))) {
343  		pos++;
344  	}
345  	return static_cast<Sci_Position>(pos - (recStartPos+1));
346  }
347  static int GetTEHexAddressFieldType(Sci_PositionU recStartPos, Accessor &styler)
348  {
349  	switch (styler.SafeGetCharAt(recStartPos + 3)) {
350  		case '6':
351  			return SCE_HEX_DATAADDRESS;
352  		case '8':
353  			return SCE_HEX_STARTADDRESS;
354  		default: 
355  			return SCE_HEX_ADDRESSFIELD_UNKNOWN;
356  	}
357  }
358  static int GetTEHexChecksum(Sci_PositionU recStartPos, Accessor &styler)
359  {
360  	return GetHexaChar(recStartPos+4, styler);
361  }
362  static int CalcTEHexChecksum(Sci_PositionU recStartPos, Accessor &styler)
363  {
364  	Sci_PositionU pos = recStartPos +1;
365  	Sci_PositionU length = GetTEHexDigitCount(recStartPos, styler);
366  	int cs = GetHexaNibble(styler.SafeGetCharAt(pos++));
367  	cs += GetHexaNibble(styler.SafeGetCharAt(pos++));
368  	cs += GetHexaNibble(styler.SafeGetCharAt(pos++));
369  	pos += 2;
370  	for (; pos <= recStartPos + length; ++pos) {
371  		int val = GetHexaNibble(styler.SafeGetCharAt(pos));
372  		if (val < 0) {
373  			return val;
374  		}
375  		cs += val;
376  	}
377  	return cs & 0xFF;
378  }
379  static void ColouriseSrecDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &styler)
380  {
381  	StyleContext sc(startPos, length, initStyle, styler);
382  	while (sc.More()) {
383  		Sci_PositionU recStartPos;
384  		Sci_Position reqByteCount;
385  		Sci_Position dataFieldSize;
386  		int byteCount, addrFieldSize, addrFieldType, dataFieldType;
387  		int cs1, cs2;
388  		switch (sc.state) {
389  			case SCE_HEX_DEFAULT:
390  				if (sc.atLineStart && sc.Match('S')) {
391  					sc.SetState(SCE_HEX_RECSTART);
392  				}
393  				ForwardWithinLine(sc);
394  				break;
395  			case SCE_HEX_RECSTART:
396  				recStartPos = sc.currentPos - 1;
397  				addrFieldType = GetSrecAddressFieldType(recStartPos, styler);
398  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
399  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
400  				} else {
401  					sc.SetState(SCE_HEX_RECTYPE);
402  				}
403  				ForwardWithinLine(sc);
404  				break;
405  			case SCE_HEX_RECTYPE:
406  			case SCE_HEX_RECTYPE_UNKNOWN:
407  				recStartPos = sc.currentPos - 2;
408  				byteCount = GetSrecByteCount(recStartPos, styler);
409  				reqByteCount = GetSrecAddressFieldSize(recStartPos, styler)
410  						+ GetSrecRequiredDataFieldSize(recStartPos, styler)
411  						+ 1; 
412  				if (byteCount == CountSrecByteCount(recStartPos, styler)
413  						&& byteCount == reqByteCount) {
414  					sc.SetState(SCE_HEX_BYTECOUNT);
415  				} else {
416  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
417  				}
418  				ForwardWithinLine(sc, 2);
419  				break;
420  			case SCE_HEX_BYTECOUNT:
421  			case SCE_HEX_BYTECOUNT_WRONG:
422  				recStartPos = sc.currentPos - 4;
423  				addrFieldSize = GetSrecAddressFieldSize(recStartPos, styler);
424  				addrFieldType = GetSrecAddressFieldType(recStartPos, styler);
425  				sc.SetState(addrFieldType);
426  				ForwardWithinLine(sc, addrFieldSize * 2);
427  				break;
428  			case SCE_HEX_NOADDRESS:
429  			case SCE_HEX_DATAADDRESS:
430  			case SCE_HEX_RECCOUNT:
431  			case SCE_HEX_STARTADDRESS:
432  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
433  				recStartPos = GetSrecRecStartPosition(sc.currentPos, styler);
434  				dataFieldType = GetSrecDataFieldType(recStartPos, styler);
435  				dataFieldSize = GetSrecRequiredDataFieldSize(recStartPos, styler);
436  				sc.SetState(dataFieldType);
437  				if (dataFieldType == SCE_HEX_DATA_ODD) {
438  					for (int i = 0; i < dataFieldSize * 2; i++) {
439  						if ((i & 0x3) == 0) {
440  							sc.SetState(SCE_HEX_DATA_ODD);
441  						} else if ((i & 0x3) == 2) {
442  							sc.SetState(SCE_HEX_DATA_EVEN);
443  						}
444  						if (!ForwardWithinLine(sc)) {
445  							break;
446  						}
447  					}
448  				} else {
449  					ForwardWithinLine(sc, dataFieldSize * 2);
450  				}
451  				break;
452  			case SCE_HEX_DATA_ODD:
453  			case SCE_HEX_DATA_EVEN:
454  			case SCE_HEX_DATA_EMPTY:
455  			case SCE_HEX_DATA_UNKNOWN:
456  				recStartPos = GetSrecRecStartPosition(sc.currentPos, styler);
457  				cs1 = CalcSrecChecksum(recStartPos, styler);
458  				cs2 = GetSrecChecksum(recStartPos, styler);
459  				if (cs1 != cs2 || cs1 < 0 || cs2 < 0) {
460  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
461  				} else {
462  					sc.SetState(SCE_HEX_CHECKSUM);
463  				}
464  				ForwardWithinLine(sc, 2);
465  				break;
466  			case SCE_HEX_CHECKSUM:
467  			case SCE_HEX_CHECKSUM_WRONG:
468  			case SCE_HEX_GARBAGE:
469  				sc.SetState(SCE_HEX_GARBAGE);
470  				ForwardWithinLine(sc);
471  				break;
472  			default:
473  				sc.SetState(SCE_HEX_DEFAULT);
474  				break;
475  		}
476  	}
477  	sc.Complete();
478  }
479  static void ColouriseIHexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &styler)
480  {
481  	StyleContext sc(startPos, length, initStyle, styler);
482  	while (sc.More()) {
483  		Sci_PositionU recStartPos;
484  		int byteCount, addrFieldType, dataFieldSize, dataFieldType;
485  		int cs1, cs2;
486  		switch (sc.state) {
487  			case SCE_HEX_DEFAULT:
488  				if (sc.atLineStart && sc.Match(':')) {
489  					sc.SetState(SCE_HEX_RECSTART);
490  				}
491  				ForwardWithinLine(sc);
492  				break;
493  			case SCE_HEX_RECSTART:
494  				recStartPos = sc.currentPos - 1;
495  				byteCount = GetIHexByteCount(recStartPos, styler);
496  				dataFieldSize = GetIHexRequiredDataFieldSize(recStartPos, styler);
497  				if (byteCount == CountIHexByteCount(recStartPos, styler)
498  						&& byteCount == dataFieldSize) {
499  					sc.SetState(SCE_HEX_BYTECOUNT);
500  				} else {
501  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
502  				}
503  				ForwardWithinLine(sc, 2);
504  				break;
505  			case SCE_HEX_BYTECOUNT:
506  			case SCE_HEX_BYTECOUNT_WRONG:
507  				recStartPos = sc.currentPos - 3;
508  				addrFieldType = GetIHexAddressFieldType(recStartPos, styler);
509  				sc.SetState(addrFieldType);
510  				ForwardWithinLine(sc, 4);
511  				break;
512  			case SCE_HEX_NOADDRESS:
513  			case SCE_HEX_DATAADDRESS:
514  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
515  				recStartPos = sc.currentPos - 7;
516  				addrFieldType = GetIHexAddressFieldType(recStartPos, styler);
517  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
518  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
519  				} else {
520  					sc.SetState(SCE_HEX_RECTYPE);
521  				}
522  				ForwardWithinLine(sc, 2);
523  				break;
524  			case SCE_HEX_RECTYPE:
525  			case SCE_HEX_RECTYPE_UNKNOWN:
526  				recStartPos = sc.currentPos - 9;
527  				dataFieldType = GetIHexDataFieldType(recStartPos, styler);
528  				dataFieldSize = GetIHexRequiredDataFieldSize(recStartPos, styler);
529  				sc.SetState(dataFieldType);
530  				if (dataFieldType == SCE_HEX_DATA_ODD) {
531  					for (int i = 0; i < dataFieldSize * 2; i++) {
532  						if ((i & 0x3) == 0) {
533  							sc.SetState(SCE_HEX_DATA_ODD);
534  						} else if ((i & 0x3) == 2) {
535  							sc.SetState(SCE_HEX_DATA_EVEN);
536  						}
537  						if (!ForwardWithinLine(sc)) {
538  							break;
539  						}
540  					}
541  				} else {
542  					ForwardWithinLine(sc, dataFieldSize * 2);
543  				}
544  				break;
545  			case SCE_HEX_DATA_ODD:
546  			case SCE_HEX_DATA_EVEN:
547  			case SCE_HEX_DATA_EMPTY:
548  			case SCE_HEX_EXTENDEDADDRESS:
549  			case SCE_HEX_STARTADDRESS:
550  			case SCE_HEX_DATA_UNKNOWN:
551  				recStartPos = GetIHexRecStartPosition(sc.currentPos, styler);
552  				cs1 = CalcIHexChecksum(recStartPos, styler);
553  				cs2 = GetIHexChecksum(recStartPos, styler);
554  				if (cs1 != cs2 || cs1 < 0 || cs2 < 0) {
555  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
556  				} else {
557  					sc.SetState(SCE_HEX_CHECKSUM);
558  				}
559  				ForwardWithinLine(sc, 2);
560  				break;
561  			case SCE_HEX_CHECKSUM:
562  			case SCE_HEX_CHECKSUM_WRONG:
563  			case SCE_HEX_GARBAGE:
564  				sc.SetState(SCE_HEX_GARBAGE);
565  				ForwardWithinLine(sc);
566  				break;
567  			default:
568  				sc.SetState(SCE_HEX_DEFAULT);
569  				break;
570  		}
571  	}
572  	sc.Complete();
573  }
574  static void FoldIHexDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler)
575  {
576  	Sci_PositionU endPos = startPos + length;
577  	Sci_Position lineCurrent = styler.GetLine(startPos);
578  	int levelCurrent = SC_FOLDLEVELBASE;
579  	if (lineCurrent > 0)
580  		levelCurrent = styler.LevelAt(lineCurrent - 1);
<span onclick='openModal()' class='match'>581  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
582  	int levelNext = SC_FOLDLEVELBASE; 
583  	for (Sci_PositionU i = startPos; i < endPos; i++) {
</span>584  		bool atEOL = i == (lineStartNext - 1);
585  		int style = styler.StyleAt(i);
586  		if (style == SCE_HEX_EXTENDEDADDRESS) {
587  			levelNext = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
588  		} else if (style == SCE_HEX_DATAADDRESS
589  			|| (style == SCE_HEX_DEFAULT
590  				&& i == (Sci_PositionU)styler.LineStart(lineCurrent))) {
591  			if (levelCurrent & SC_FOLDLEVELHEADERFLAG) {
592  				levelNext = SC_FOLDLEVELBASE + 1;
593  			} else {
594  				levelNext = levelCurrent;
595  			}
596  		}
597  		if (atEOL || (i == endPos - 1)) {
598  			styler.SetLevel(lineCurrent, levelNext);
599  			lineCurrent++;
600  			lineStartNext = styler.LineStart(lineCurrent + 1);
601  			levelCurrent = levelNext;
602  			levelNext = SC_FOLDLEVELBASE;
603  		}
604  	}
605  }
606  static void ColouriseTEHexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[], Accessor &styler)
607  {
608  	StyleContext sc(startPos, length, initStyle, styler);
609  	while (sc.More()) {
610  		Sci_PositionU recStartPos;
611  		int digitCount, addrFieldType;
612  		int cs1, cs2;
613  		switch (sc.state) {
614  			case SCE_HEX_DEFAULT:
615  				if (sc.atLineStart && sc.Match('%')) {
616  					sc.SetState(SCE_HEX_RECSTART);
617  				}
618  				ForwardWithinLine(sc);
619  				break;
620  			case SCE_HEX_RECSTART:
621  				recStartPos = sc.currentPos - 1;
622  				if (GetTEHexDigitCount(recStartPos, styler) == CountTEHexDigitCount(recStartPos, styler)) {
623  					sc.SetState(SCE_HEX_BYTECOUNT);
624  				} else {
625  					sc.SetState(SCE_HEX_BYTECOUNT_WRONG);
626  				}
627  				ForwardWithinLine(sc, 2);
628  				break;
629  			case SCE_HEX_BYTECOUNT:
630  			case SCE_HEX_BYTECOUNT_WRONG:
631  				recStartPos = sc.currentPos - 3;
632  				addrFieldType = GetTEHexAddressFieldType(recStartPos, styler);
633  				if (addrFieldType == SCE_HEX_ADDRESSFIELD_UNKNOWN) {
634  					sc.SetState(SCE_HEX_RECTYPE_UNKNOWN);
635  				} else {
636  					sc.SetState(SCE_HEX_RECTYPE);
637  				}
638  				ForwardWithinLine(sc);
639  				break;
640  			case SCE_HEX_RECTYPE:
641  			case SCE_HEX_RECTYPE_UNKNOWN:
642  				recStartPos = sc.currentPos - 4;
643  				cs1 = CalcTEHexChecksum(recStartPos, styler);
644  				cs2 = GetTEHexChecksum(recStartPos, styler);
645  				if (cs1 != cs2 || cs1 < 0 || cs2 < 0) {
646  					sc.SetState(SCE_HEX_CHECKSUM_WRONG);
647  				} else {
648  					sc.SetState(SCE_HEX_CHECKSUM);
649  				}
650  				ForwardWithinLine(sc, 2);
651  				break;
652  			case SCE_HEX_CHECKSUM:
653  			case SCE_HEX_CHECKSUM_WRONG:
654  				recStartPos = sc.currentPos - 6;
655  				addrFieldType = GetTEHexAddressFieldType(recStartPos, styler);
656  				sc.SetState(addrFieldType);
657  				ForwardWithinLine(sc, 9);
658  				break;
659  			case SCE_HEX_DATAADDRESS:
660  			case SCE_HEX_STARTADDRESS:
661  			case SCE_HEX_ADDRESSFIELD_UNKNOWN:
662  				recStartPos = sc.currentPos - 15;
663  				digitCount = GetTEHexDigitCount(recStartPos, styler) - 14;
664  				sc.SetState(SCE_HEX_DATA_ODD);
665  				for (int i = 0; i < digitCount; i++) {
666  					if ((i & 0x3) == 0) {
667  						sc.SetState(SCE_HEX_DATA_ODD);
668  					} else if ((i & 0x3) == 2) {
669  						sc.SetState(SCE_HEX_DATA_EVEN);
670  					}
671  					if (!ForwardWithinLine(sc)) {
672  						break;
673  					}
674  				}
675  				break;
676  			case SCE_HEX_DATA_ODD:
677  			case SCE_HEX_DATA_EVEN:
678  			case SCE_HEX_GARBAGE:
679  				sc.SetState(SCE_HEX_GARBAGE);
680  				ForwardWithinLine(sc);
681  				break;
682  			default:
683  				sc.SetState(SCE_HEX_DEFAULT);
684  				break;
685  		}
686  	}
687  	sc.Complete();
688  }
689  LexerModule lmSrec(SCLEX_SREC, ColouriseSrecDoc, "srec", 0, NULL);
690  LexerModule lmIHex(SCLEX_IHEX, ColouriseIHexDoc, "ihex", FoldIHexDoc, NULL);
691  LexerModule lmTEHex(SCLEX_TEHEX, ColouriseTEHexDoc, "tehex", 0, NULL);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "PropSetSimple.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "Accessor.h"
18  #include "StyleContext.h"
19  #include "CharacterSet.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  static const int NUM_RUST_KEYWORD_LISTS = 7;
26  static const int MAX_RUST_IDENT_CHARS = 1023;
27  static bool IsStreamCommentStyle(int style) {
28  	return style == SCE_RUST_COMMENTBLOCK ||
29  		   style == SCE_RUST_COMMENTBLOCKDOC;
30  }
31  struct OptionsRust {
32  	bool fold;
33  	bool foldSyntaxBased;
34  	bool foldComment;
35  	bool foldCommentMultiline;
36  	bool foldCommentExplicit;
37  	std::string foldExplicitStart;
38  	std::string foldExplicitEnd;
39  	bool foldExplicitAnywhere;
40  	bool foldCompact;
41  	int  foldAtElseInt;
42  	bool foldAtElse;
43  	OptionsRust() {
44  		fold = false;
45  		foldSyntaxBased = true;
46  		foldComment = false;
47  		foldCommentMultiline = true;
48  		foldCommentExplicit = true;
49  		foldExplicitStart = "";
50  		foldExplicitEnd   = "";
51  		foldExplicitAnywhere = false;
52  		foldCompact = true;
53  		foldAtElseInt = -1;
54  		foldAtElse = false;
55  	}
56  };
57  static const char * const rustWordLists[NUM_RUST_KEYWORD_LISTS + 1] = {
58  			"Primary keywords and identifiers",
59  			"Built in types",
60  			"Other keywords",
61  			"Keywords 4",
62  			"Keywords 5",
63  			"Keywords 6",
64  			"Keywords 7",
65  			0,
66  		};
67  struct OptionSetRust : public OptionSet<OptionsRust> {
68  	OptionSetRust() {
69  		DefineProperty("fold", &OptionsRust::fold);
70  		DefineProperty("fold.comment", &OptionsRust::foldComment);
71  		DefineProperty("fold.compact", &OptionsRust::foldCompact);
72  		DefineProperty("fold.at.else", &OptionsRust::foldAtElse);
73  		DefineProperty("fold.rust.syntax.based", &OptionsRust::foldSyntaxBased,
74  			"Set this property to 0 to disable syntax based folding.");
75  		DefineProperty("fold.rust.comment.multiline", &OptionsRust::foldCommentMultiline,
76  			"Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
77  		DefineProperty("fold.rust.comment.explicit", &OptionsRust::foldCommentExplicit,
78  			"Set this property to 0 to disable folding explicit fold points when fold.comment=1.");
79  		DefineProperty("fold.rust.explicit.start", &OptionsRust::foldExplicitStart,
80  			"The string to use for explicit fold start points, replacing the standard 
81  		DefineProperty("fold.rust.explicit.end", &OptionsRust::foldExplicitEnd,
82  			"The string to use for explicit fold end points, replacing the standard 
83  		DefineProperty("fold.rust.explicit.anywhere", &OptionsRust::foldExplicitAnywhere,
84  			"Set this property to 1 to enable explicit fold points anywhere, not just in line comments.");
85  		DefineProperty("lexer.rust.fold.at.else", &OptionsRust::foldAtElseInt,
86  			"This option enables Rust folding on a \"} else {\" line of an if statement.");
87  		DefineWordListSets(rustWordLists);
88  	}
89  };
90  class LexerRust : public DefaultLexer {
91  	WordList keywords[NUM_RUST_KEYWORD_LISTS];
92  	OptionsRust options;
93  	OptionSetRust osRust;
94  public:
95  	LexerRust() : DefaultLexer("rust", SCLEX_RUST) {
96  	}
97  	virtual ~LexerRust() {
98  	}
99  	void SCI_METHOD Release() override {
100  		delete this;
101  	}
102  	int SCI_METHOD Version() const override {
103  		return lvRelease5;
104  	}
105  	const char * SCI_METHOD PropertyNames() override {
106  		return osRust.PropertyNames();
107  	}
108  	int SCI_METHOD PropertyType(const char *name) override {
109  		return osRust.PropertyType(name);
110  	}
111  	const char * SCI_METHOD DescribeProperty(const char *name) override {
112  		return osRust.DescribeProperty(name);
113  	}
114  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
115  	const char * SCI_METHOD PropertyGet(const char *key) override {
116  		return osRust.PropertyGet(key);
117  	}
118  	const char * SCI_METHOD DescribeWordListSets() override {
119  		return osRust.DescribeWordListSets();
120  	}
121  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
122  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
123  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
124  	void * SCI_METHOD PrivateCall(int, void *) override {
125  		return 0;
126  	}
127  	static ILexer5 *LexerFactoryRust() {
128  		return new LexerRust();
129  	}
130  };
131  Sci_Position SCI_METHOD LexerRust::PropertySet(const char *key, const char *val) {
132  	if (osRust.PropertySet(&options, key, val)) {
133  		return 0;
134  	}
135  	return -1;
136  }
137  Sci_Position SCI_METHOD LexerRust::WordListSet(int n, const char *wl) {
138  	Sci_Position firstModification = -1;
139  	if (n < NUM_RUST_KEYWORD_LISTS) {
140  		WordList *wordListN = &keywords[n];
141  		WordList wlNew;
142  		wlNew.Set(wl);
143  		if (*wordListN != wlNew) {
144  			wordListN->Set(wl);
145  			firstModification = 0;
146  		}
147  	}
148  	return firstModification;
149  }
150  static bool IsWhitespace(int c) {
151      return c == ' ' || c == '\t' || c == '\r' || c == '\n';
152  }
153  static bool IsIdentifierStart(int ch) {
154  	return (IsASCII(ch) && (isalpha(ch) || ch == '_')) || !IsASCII(ch);
155  }
156  static bool IsIdentifierContinue(int ch) {
157  	return (IsASCII(ch) && (isalnum(ch) || ch == '_')) || !IsASCII(ch);
158  }
159  static void ScanWhitespace(Accessor& styler, Sci_Position& pos, Sci_Position max) {
160  	while (IsWhitespace(styler.SafeGetCharAt(pos, '\0')) && pos < max) {
161  		if (pos == styler.LineEnd(styler.GetLine(pos)))
162  			styler.SetLineState(styler.GetLine(pos), 0);
163  		pos++;
164  	}
165  	styler.ColourTo(pos-1, SCE_RUST_DEFAULT);
166  }
167  static void GrabString(char* s, Accessor& styler, Sci_Position start, Sci_Position len) {
168  	for (Sci_Position ii = 0; ii < len; ii++)
169  		s[ii] = styler[ii + start];
170  	s[len] = '\0';
171  }
172  static void ScanIdentifier(Accessor& styler, Sci_Position& pos, WordList *keywords) {
173  	Sci_Position start = pos;
174  	while (IsIdentifierContinue(styler.SafeGetCharAt(pos, '\0')))
175  		pos++;
176  	if (styler.SafeGetCharAt(pos, '\0') == '!') {
177  		pos++;
178  		styler.ColourTo(pos - 1, SCE_RUST_MACRO);
179  	} else {
180  		char s[MAX_RUST_IDENT_CHARS + 1];
181  		Sci_Position len = pos - start;
182  		len = len > MAX_RUST_IDENT_CHARS ? MAX_RUST_IDENT_CHARS : len;
183  		GrabString(s, styler, start, len);
184  		bool keyword = false;
185  		for (int ii = 0; ii < NUM_RUST_KEYWORD_LISTS; ii++) {
186  			if (keywords[ii].InList(s)) {
187  				styler.ColourTo(pos - 1, SCE_RUST_WORD + ii);
188  				keyword = true;
189  				break;
190  			}
191  		}
192  		if (!keyword) {
193  			styler.ColourTo(pos - 1, SCE_RUST_IDENTIFIER);
194  		}
195  	}
196  }
197  static bool ScanDigits(Accessor& styler, Sci_Position& pos, int base) {
198  	Sci_Position old_pos = pos;
199  	for (;;) {
200  		int c = styler.SafeGetCharAt(pos, '\0');
201  		if (IsADigit(c, base) || c == '_')
202  			pos++;
203  		else
204  			break;
205  	}
206  	return old_pos != pos;
207  }
208  static void ScanNumber(Accessor& styler, Sci_Position& pos) {
209  	int base = 10;
210  	int c = styler.SafeGetCharAt(pos, '\0');
211  	int n = styler.SafeGetCharAt(pos + 1, '\0');
212  	bool error = false;
213  	if (c == '0' && n == 'x') {
214  		pos += 2;
215  		base = 16;
216  	} else if (c == '0' && n == 'b') {
217  		pos += 2;
218  		base = 2;
219  	} else if (c == '0' && n == 'o') {
220  		pos += 2;
221  		base = 8;
222  	}
223  	error |= !ScanDigits(styler, pos, base);
224  	c = styler.SafeGetCharAt(pos, '\0');
225  	if (c == 'u' || c == 'i') {
226  		pos++;
227  		c = styler.SafeGetCharAt(pos, '\0');
228  		n = styler.SafeGetCharAt(pos + 1, '\0');
229  		if (c == '8') {
230  			pos++;
231  		} else if (c == '1' && n == '6') {
232  			pos += 2;
233  		} else if (c == '3' && n == '2') {
234  			pos += 2;
235  		} else if (c == '6' && n == '4') {
236  			pos += 2;
237  		} else if (styler.Match(pos, "128")) {
238  			pos += 3;
239  		} else if (styler.Match(pos, "size")) {
240  			pos += 4;
241  		} else {
242  			error = true;
243  		}
244  	} else if (!error) {
245  		n = styler.SafeGetCharAt(pos + 1, '\0');
246  		if (c == '.' && !(IsIdentifierStart(n) || n == '.')) {
247  			error |= base != 10;
248  			pos++;
249  			ScanDigits(styler, pos, 10);
250  		}
251  		c = styler.SafeGetCharAt(pos, '\0');
252  		if (c == 'e' || c == 'E') {
253  			error |= base != 10;
254  			pos++;
255  			c = styler.SafeGetCharAt(pos, '\0');
256  			if (c == '-' || c == '+')
257  				pos++;
258  			error |= !ScanDigits(styler, pos, 10);
259  		}
260  		c = styler.SafeGetCharAt(pos, '\0');
261  		if (c == 'f') {
262  			error |= base != 10;
263  			pos++;
264  			c = styler.SafeGetCharAt(pos, '\0');
265  			n = styler.SafeGetCharAt(pos + 1, '\0');
266  			if (c == '3' && n == '2') {
267  				pos += 2;
268  			} else if (c == '6' && n == '4') {
269  				pos += 2;
270  			} else {
271  				error = true;
272  			}
273  		}
274  	}
275  	if (error)
276  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
277  	else
278  		styler.ColourTo(pos - 1, SCE_RUST_NUMBER);
279  }
280  static bool IsOneCharOperator(int c) {
281  	return c == ';' || c == ',' || c == '(' || c == ')'
282  	    || c == '{' || c == '}' || c == '[' || c == ']'
283  	    || c == '@' || c == '#' || c == '~' || c == '+'
284  	    || c == '*' || c == '/' || c == '^' || c == '%'
285  	    || c == '.' || c == ':' || c == '!' || c == '<'
286  	    || c == '>' || c == '=' || c == '-' || c == '&'
287  	    || c == '|' || c == '$' || c == '?';
288  }
289  static bool IsTwoCharOperator(int c, int n) {
290  	return (c == '.' && n == '.') || (c == ':' && n == ':')
291  	    || (c == '!' && n == '=') || (c == '<' && n == '<')
292  	    || (c == '<' && n == '=') || (c == '>' && n == '>')
293  	    || (c == '>' && n == '=') || (c == '=' && n == '=')
294  	    || (c == '=' && n == '>') || (c == '-' && n == '>')
295  	    || (c == '&' && n == '&') || (c == '|' && n == '|')
296  	    || (c == '-' && n == '=') || (c == '&' && n == '=')
297  	    || (c == '|' && n == '=') || (c == '+' && n == '=')
298  	    || (c == '*' && n == '=') || (c == '/' && n == '=')
299  	    || (c == '^' && n == '=') || (c == '%' && n == '=');
300  }
301  static bool IsThreeCharOperator(int c, int n, int n2) {
302  	return (c == '<' && n == '<' && n2 == '=')
303  	    || (c == '>' && n == '>' && n2 == '=');
304  }
305  static bool IsValidCharacterEscape(int c) {
306  	return c == 'n'  || c == 'r' || c == 't' || c == '\\'
307  	    || c == '\'' || c == '"' || c == '0';
308  }
309  static bool IsValidStringEscape(int c) {
310  	return IsValidCharacterEscape(c) || c == '\n' || c == '\r';
311  }
312  static bool ScanNumericEscape(Accessor &styler, Sci_Position& pos, Sci_Position num_digits, bool stop_asap) {
313  	for (;;) {
314  		int c = styler.SafeGetCharAt(pos, '\0');
315  		if (!IsADigit(c, 16))
316  			break;
317  		num_digits--;
318  		pos++;
319  		if (num_digits == 0 && stop_asap)
320  			return true;
321  	}
322  	if (num_digits == 0) {
323  		return true;
324  	} else {
325  		return false;
326  	}
327  }
328  static void ScanCharacterLiteralOrLifetime(Accessor &styler, Sci_Position& pos, bool ascii_only) {
329  	pos++;
330  	int c = styler.SafeGetCharAt(pos, '\0');
331  	int n = styler.SafeGetCharAt(pos + 1, '\0');
332  	bool done = false;
333  	bool valid_lifetime = !ascii_only && IsIdentifierStart(c);
334  	bool valid_char = true;
335  	bool first = true;
336  	while (!done) {
337  		switch (c) {
338  			case '\\':
339  				done = true;
340  				if (IsValidCharacterEscape(n)) {
341  					pos += 2;
342  				} else if (n == 'x') {
343  					pos += 2;
344  					valid_char = ScanNumericEscape(styler, pos, 2, false);
345  				} else if (n == 'u' && !ascii_only) {
346  					pos += 2;
347  					if (styler.SafeGetCharAt(pos, '\0') != '{') {
348  						valid_char = ScanNumericEscape(styler, pos, 4, false);
349  					} else {
350  						int n_digits = 0;
351  						while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
352  						}
353  						if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
354  							pos++;
355  						else
356  							valid_char = false;
357  					}
358  				} else if (n == 'U' && !ascii_only) {
359  					pos += 2;
360  					valid_char = ScanNumericEscape(styler, pos, 8, false);
361  				} else {
362  					valid_char = false;
363  				}
364  				break;
365  			case '\'':
366  				valid_char = !first;
367  				done = true;
368  				break;
369  			case '\t':
370  			case '\n':
371  			case '\r':
372  			case '\0':
373  				valid_char = false;
374  				done = true;
375  				break;
376  			default:
377  				if (ascii_only && !IsASCII((char)c)) {
378  					done = true;
379  					valid_char = false;
380  				} else if (!IsIdentifierContinue(c) && !first) {
381  					done = true;
382  				} else {
383  					pos++;
384  				}
385  				break;
386  		}
387  		c = styler.SafeGetCharAt(pos, '\0');
388  		n = styler.SafeGetCharAt(pos + 1, '\0');
389  		first = false;
390  	}
391  	if (styler.SafeGetCharAt(pos, '\0') == '\'') {
392  		valid_lifetime = false;
393  	} else {
394  		valid_char = false;
395  	}
396  	if (valid_lifetime) {
397  		styler.ColourTo(pos - 1, SCE_RUST_LIFETIME);
398  	} else if (valid_char) {
399  		pos++;
400  		styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTECHARACTER : SCE_RUST_CHARACTER);
401  	} else {
402  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
403  	}
404  }
405  enum CommentState {
406  	UnknownComment,
407  	DocComment,
408  	NotDocComment
409  };
410  static void ResumeBlockComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state, int level) {
411  	int c = styler.SafeGetCharAt(pos, '\0');
412  	bool maybe_doc_comment = false;
413  	if (c == '*') {
414  		int n = styler.SafeGetCharAt(pos + 1, '\0');
415  		if (n != '*' && n != '/') {
416  			maybe_doc_comment = true;
417  		}
418  	} else if (c == '!') {
419  		maybe_doc_comment = true;
420  	}
421  	for (;;) {
422  		int n = styler.SafeGetCharAt(pos + 1, '\0');
423  		if (pos == styler.LineEnd(styler.GetLine(pos)))
424  			styler.SetLineState(styler.GetLine(pos), level);
425  		if (c == '*') {
426  			pos++;
427  			if (n == '/') {
428  				pos++;
429  				level--;
430  				if (level == 0) {
431  					styler.SetLineState(styler.GetLine(pos), 0);
432  					if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
433  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
434  					else
435  						styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
436  					break;
437  				}
438  			}
439  		} else if (c == '/') {
440  			pos++;
441  			if (n == '*') {
442  				pos++;
443  				level++;
444  			}
445  		}
446  		else if (pos < max) {
447  			pos++;
448  		}
449  		if (pos >= max) {
450  			if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
451  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCKDOC);
452  			else
453  				styler.ColourTo(pos - 1, SCE_RUST_COMMENTBLOCK);
454  			break;
455  		}
456  		c = styler.SafeGetCharAt(pos, '\0');
457  	}
458  }
459  static void ResumeLineComment(Accessor &styler, Sci_Position& pos, Sci_Position max, CommentState state) {
460  	bool maybe_doc_comment = false;
461  	int c = styler.SafeGetCharAt(pos, '\0');
462  	if (c == '/') {
463  		if (pos < max) {
464  			pos++;
465  			c = styler.SafeGetCharAt(pos, '\0');
466  			if (c != '/') {
467  				maybe_doc_comment = true;
468  			}
469  		}
470  	} else if (c == '!') {
471  		maybe_doc_comment = true;
472  	}
473  	pos = styler.LineEnd(styler.GetLine(pos));
474  	styler.SetLineState(styler.GetLine(pos), SCE_RUST_DEFAULT);
475  	if (state == DocComment || (state == UnknownComment && maybe_doc_comment))
476  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINEDOC);
477  	else
478  		styler.ColourTo(pos - 1, SCE_RUST_COMMENTLINE);
479  }
480  static void ScanComments(Accessor &styler, Sci_Position& pos, Sci_Position max) {
481  	pos++;
482  	int c = styler.SafeGetCharAt(pos, '\0');
483  	pos++;
484  	if (c == '/')
485  		ResumeLineComment(styler, pos, max, UnknownComment);
486  	else if (c == '*')
487  		ResumeBlockComment(styler, pos, max, UnknownComment, 1);
488  }
489  static void ResumeString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
490  	int c = styler.SafeGetCharAt(pos, '\0');
491  	bool error = false;
492  	while (c != '"' && !error) {
493  		if (pos >= max) {
494  			error = true;
495  			break;
496  		}
497  		if (pos == styler.LineEnd(styler.GetLine(pos)))
498  			styler.SetLineState(styler.GetLine(pos), 0);
499  		if (c == '\\') {
500  			int n = styler.SafeGetCharAt(pos + 1, '\0');
501  			if (IsValidStringEscape(n)) {
502  				pos += 2;
503  			} else if (n == 'x') {
504  				pos += 2;
505  				error = !ScanNumericEscape(styler, pos, 2, true);
506  			} else if (n == 'u' && !ascii_only) {
507  				pos += 2;
508  				if (styler.SafeGetCharAt(pos, '\0') != '{') {
509  					error = !ScanNumericEscape(styler, pos, 4, true);
510  				} else {
511  					int n_digits = 0;
512  					while (IsADigit(styler.SafeGetCharAt(++pos, '\0'), 16) && n_digits++ < 6) {
513  					}
514  					if (n_digits > 0 && styler.SafeGetCharAt(pos, '\0') == '}')
515  						pos++;
516  					else
517  						error = true;
518  				}
519  			} else if (n == 'U' && !ascii_only) {
520  				pos += 2;
521  				error = !ScanNumericEscape(styler, pos, 8, true);
522  			} else {
523  				pos += 1;
524  				error = true;
525  			}
526  		} else {
527  			if (ascii_only && !IsASCII((char)c))
528  				error = true;
529  			else
530  				pos++;
531  		}
532  		c = styler.SafeGetCharAt(pos, '\0');
533  	}
534  	if (!error)
535  		pos++;
536  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRING : SCE_RUST_STRING);
537  }
538  static void ResumeRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, int num_hashes, bool ascii_only) {
539  	for (;;) {
540  		if (pos == styler.LineEnd(styler.GetLine(pos)))
541  			styler.SetLineState(styler.GetLine(pos), num_hashes);
542  		int c = styler.SafeGetCharAt(pos, '\0');
543  		if (c == '"') {
544  			pos++;
545  			int trailing_num_hashes = 0;
546  			while (styler.SafeGetCharAt(pos, '\0') == '#' && trailing_num_hashes < num_hashes) {
547  				trailing_num_hashes++;
548  				pos++;
549  			}
550  			if (trailing_num_hashes == num_hashes) {
551  				styler.SetLineState(styler.GetLine(pos), 0);
552  				break;
553  			}
554  		} else if (pos >= max) {
555  			break;
556  		} else {
557  			if (ascii_only && !IsASCII((char)c))
558  				break;
559  			pos++;
560  		}
561  	}
562  	styler.ColourTo(pos - 1, ascii_only ? SCE_RUST_BYTESTRINGR : SCE_RUST_STRINGR);
563  }
564  static void ScanRawString(Accessor &styler, Sci_Position& pos, Sci_Position max, bool ascii_only) {
565  	pos++;
566  	int num_hashes = 0;
567  	while (styler.SafeGetCharAt(pos, '\0') == '#') {
568  		num_hashes++;
569  		pos++;
570  	}
571  	if (styler.SafeGetCharAt(pos, '\0') != '"') {
572  		styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
573  	} else {
574  		pos++;
575  		ResumeRawString(styler, pos, max, num_hashes, ascii_only);
576  	}
577  }
578  void SCI_METHOD LexerRust::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
579  	PropSetSimple props;
580  	Accessor styler(pAccess, &props);
581  	Sci_Position pos = startPos;
582  	Sci_Position max = pos + length;
583  	styler.StartAt(pos);
584  	styler.StartSegment(pos);
585  	if (initStyle == SCE_RUST_COMMENTBLOCK || initStyle == SCE_RUST_COMMENTBLOCKDOC) {
586  		ResumeBlockComment(styler, pos, max, initStyle == SCE_RUST_COMMENTBLOCKDOC ? DocComment : NotDocComment, styler.GetLineState(styler.GetLine(pos) - 1));
587  	} else if (initStyle == SCE_RUST_COMMENTLINE || initStyle == SCE_RUST_COMMENTLINEDOC) {
588  		ResumeLineComment(styler, pos, max, initStyle == SCE_RUST_COMMENTLINEDOC ? DocComment : NotDocComment);
589  	} else if (initStyle == SCE_RUST_STRING) {
590  		ResumeString(styler, pos, max, false);
591  	} else if (initStyle == SCE_RUST_BYTESTRING) {
592  		ResumeString(styler, pos, max, true);
593  	} else if (initStyle == SCE_RUST_STRINGR) {
594  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), false);
595  	} else if (initStyle == SCE_RUST_BYTESTRINGR) {
596  		ResumeRawString(styler, pos, max, styler.GetLineState(styler.GetLine(pos) - 1), true);
597  	}
598  	while (pos < max) {
599  		int c = styler.SafeGetCharAt(pos, '\0');
600  		int n = styler.SafeGetCharAt(pos + 1, '\0');
601  		int n2 = styler.SafeGetCharAt(pos + 2, '\0');
602  		if (pos == 0 && c == '#' && n == '!' && n2 != '[') {
603  			pos += 2;
604  			ResumeLineComment(styler, pos, max, NotDocComment);
605  		} else if (IsWhitespace(c)) {
606  			ScanWhitespace(styler, pos, max);
607  		} else if (c == '/' && (n == '/' || n == '*')) {
608  			ScanComments(styler, pos, max);
609  		} else if (c == 'r' && (n == '#' || n == '"')) {
610  			ScanRawString(styler, pos, max, false);
611  		} else if (c == 'b' && n == 'r' && (n2 == '#' || n2 == '"')) {
612  			pos++;
613  			ScanRawString(styler, pos, max, true);
614  		} else if (c == 'b' && n == '"') {
615  			pos += 2;
616  			ResumeString(styler, pos, max, true);
617  		} else if (c == 'b' && n == '\'') {
618  			pos++;
619  			ScanCharacterLiteralOrLifetime(styler, pos, true);
620  		} else if (IsIdentifierStart(c)) {
621  			ScanIdentifier(styler, pos, keywords);
622  		} else if (IsADigit(c)) {
623  			ScanNumber(styler, pos);
624  		} else if (IsThreeCharOperator(c, n, n2)) {
625  			pos += 3;
626  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
627  		} else if (IsTwoCharOperator(c, n)) {
628  			pos += 2;
629  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
630  		} else if (IsOneCharOperator(c)) {
631  			pos++;
632  			styler.ColourTo(pos - 1, SCE_RUST_OPERATOR);
633  		} else if (c == '\'') {
634  			ScanCharacterLiteralOrLifetime(styler, pos, false);
635  		} else if (c == '"') {
636  			pos++;
637  			ResumeString(styler, pos, max, false);
638  		} else {
639  			pos++;
640  			styler.ColourTo(pos - 1, SCE_RUST_LEXERROR);
641  		}
642  	}
643  	styler.ColourTo(pos - 1, SCE_RUST_DEFAULT);
644  	styler.Flush();
645  }
646  void SCI_METHOD LexerRust::Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
647  	if (!options.fold)
648  		return;
649  	LexAccessor styler(pAccess);
650  	Sci_PositionU endPos = startPos + length;
651  	int visibleChars = 0;
652  	bool inLineComment = false;
653  	Sci_Position lineCurrent = styler.GetLine(startPos);
654  	int levelCurrent = SC_FOLDLEVELBASE;
655  	if (lineCurrent > 0)
656  		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
<span onclick='openModal()' class='match'>657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
</span>660  	char chNext = styler[startPos];
661  	int styleNext = styler.StyleAt(startPos);
662  	int style = initStyle;
663  	const bool userDefinedFoldMarkers = !options.foldExplicitStart.empty() && !options.foldExplicitEnd.empty();
664  	for (Sci_PositionU i = startPos; i < endPos; i++) {
665  		char ch = chNext;
666  		chNext = styler.SafeGetCharAt(i + 1);
667  		int stylePrev = style;
668  		style = styleNext;
669  		styleNext = styler.StyleAt(i + 1);
670  		bool atEOL = i == (lineStartNext-1);
671  		if ((style == SCE_RUST_COMMENTLINE) || (style == SCE_RUST_COMMENTLINEDOC))
672  			inLineComment = true;
673  		if (options.foldComment && options.foldCommentMultiline && IsStreamCommentStyle(style) && !inLineComment) {
674  			if (!IsStreamCommentStyle(stylePrev)) {
675  				levelNext++;
676  			} else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
677  				levelNext--;
678  			}
679  		}
680  		if (options.foldComment && options.foldCommentExplicit && ((style == SCE_RUST_COMMENTLINE) || options.foldExplicitAnywhere)) {
681  			if (userDefinedFoldMarkers) {
682  				if (styler.Match(i, options.foldExplicitStart.c_str())) {
683  					levelNext++;
684  				} else if (styler.Match(i, options.foldExplicitEnd.c_str())) {
685  					levelNext--;
686  				}
687  			} else {
688  				if ((ch == '/') && (chNext == '/')) {
689  					char chNext2 = styler.SafeGetCharAt(i + 2);
690  					if (chNext2 == '{') {
691  						levelNext++;
692  					} else if (chNext2 == '}') {
693  						levelNext--;
694  					}
695  				}
696  			}
697  		}
698  		if (options.foldSyntaxBased && (style == SCE_RUST_OPERATOR)) {
699  			if (ch == '{') {
700  				if (levelMinCurrent > levelNext) {
701  					levelMinCurrent = levelNext;
702  				}
703  				levelNext++;
704  			} else if (ch == '}') {
705  				levelNext--;
706  			}
707  		}
708  		if (!IsASpace(ch))
709  			visibleChars++;
710  		if (atEOL || (i == endPos-1)) {
711  			int levelUse = levelCurrent;
712  			if (options.foldSyntaxBased && options.foldAtElse) {
713  				levelUse = levelMinCurrent;
714  			}
715  			int lev = levelUse | levelNext << 16;
716  			if (visibleChars == 0 && options.foldCompact)
717  				lev |= SC_FOLDLEVELWHITEFLAG;
718  			if (levelUse < levelNext)
719  				lev |= SC_FOLDLEVELHEADERFLAG;
720  			if (lev != styler.LevelAt(lineCurrent)) {
721  				styler.SetLevel(lineCurrent, lev);
722  			}
723  			lineCurrent++;
724  			lineStartNext = styler.LineStart(lineCurrent+1);
725  			levelCurrent = levelNext;
726  			levelMinCurrent = levelCurrent;
727  			if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
728  				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
729  			}
730  			visibleChars = 0;
731  			inLineComment = false;
732  		}
733  	}
734  }
735  LexerModule lmRust(SCLEX_RUST, LexerRust::LexerFactoryRust, "rust", rustWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexHex.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRust.cxx</div>
                </div>
                <div class="column column_space"><pre><code>581  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
582  	int levelNext = SC_FOLDLEVELBASE; 
583  	for (Sci_PositionU i = startPos; i < endPos; i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>657  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent+1);
658  	int levelMinCurrent = levelCurrent;
659  	int levelNext = levelCurrent;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    