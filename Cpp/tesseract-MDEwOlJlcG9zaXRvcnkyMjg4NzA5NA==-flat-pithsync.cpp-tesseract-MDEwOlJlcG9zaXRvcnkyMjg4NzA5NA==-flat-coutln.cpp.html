
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pithsync.cpp</h3>
            <pre><code>1  #include "pithsync.h"
2  #include "makerow.h"
3  #include "pitsync1.h"
4  #include "topitch.h"
5  #include "tprintf.h"
6  #include <cfloat> 
7  #include <cmath>
8  #include <vector> 
9  namespace tesseract {
10  void FPCUTPT::setup(      
11      FPCUTPT *cutpts,      
12      int16_t array_origin, 
13      STATS *projection,    
14      int16_t zero_count,   
15      int16_t pitch,        
16      int16_t x,            
17      int16_t offset        
18  ) {
19    int16_t half_pitch = pitch / 2 - 1;
20    uint32_t lead_flag; 
21    int32_t ind;        
22    if (half_pitch > 31) {
23      half_pitch = 31;
24    } else if (half_pitch < 0) {
25      half_pitch = 0;
26    }
27    lead_flag = 1 << half_pitch;
28    pred = nullptr;
29    mean_sum = 0;
30    sq_sum = offset * offset;
31    cost = sq_sum;
32    faked = false;
33    terminal = false;
34    fake_count = 0;
35    xpos = x;
36    region_index = 0;
37    mid_cuts = 0;
38    if (x == array_origin) {
39      back_balance = 0;
40      fwd_balance = 0;
41      for (ind = 0; ind <= half_pitch; ind++) {
42        fwd_balance >>= 1;
43        if (projection->pile_count(ind) > zero_count) {
44          fwd_balance |= lead_flag;
45        }
46      }
47    } else {
48      back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
49      back_balance &= lead_flag + (lead_flag - 1);
50      if (projection->pile_count(x) > zero_count) {
51        back_balance |= 1;
52      }
53      fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
54      if (projection->pile_count(x + half_pitch) > zero_count) {
55        fwd_balance |= lead_flag;
56      }
57    }
58  }
59  void FPCUTPT::assign(       
60      FPCUTPT *cutpts,        
61      int16_t array_origin,   
62      int16_t x,              
63      bool faking,            
64      bool mid_cut,           
65      int16_t offset,         
66      STATS *projection,      
67      float projection_scale, 
68      int16_t zero_count,     
69      int16_t pitch,          
70      int16_t pitch_error     
71  ) {
72    int index;             
73    int balance_index;     
74    int16_t balance_count; 
75    int16_t r_index;       
76    FPCUTPT *segpt;        
77    int32_t dist;          
78    double sq_dist;        
79    double mean;           
80    double total;          
81    double factor;         
82    int16_t half_pitch = pitch / 2 - 1;
83    uint32_t lead_flag; 
84    if (half_pitch > 31) {
85      half_pitch = 31;
86    } else if (half_pitch < 0) {
87      half_pitch = 0;
88    }
89    lead_flag = 1 << half_pitch;
90    back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
91    back_balance &= lead_flag + (lead_flag - 1);
92    if (projection->pile_count(x) > zero_count) {
93      back_balance |= 1;
94    }
95    fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
96    if (projection->pile_count(x + half_pitch) > zero_count) {
97      fwd_balance |= lead_flag;
98    }
99    xpos = x;
100    cost = FLT_MAX;
101    pred = nullptr;
102    faked = faking;
103    terminal = false;
104    region_index = 0;
105    fake_count = INT16_MAX;
106    for (index = x - pitch - pitch_error; index <= x - pitch + pitch_error; index++) {
107      if (index >= array_origin) {
108        segpt = &cutpts[index - array_origin];
109        dist = x - segpt->xpos;
110        if (!segpt->terminal && segpt->fake_count < INT16_MAX) {
111          balance_count = 0;
112          if (textord_balance_factor > 0) {
113            if (textord_fast_pitch_test) {
114              lead_flag = back_balance ^ segpt->fwd_balance;
115              balance_count = 0;
116              while (lead_flag != 0) {
117                balance_count++;
118                lead_flag &= lead_flag - 1;
119              }
120            } else {
121              for (balance_index = 0; index + balance_index < x - balance_index; balance_index++) {
122                balance_count += (projection->pile_count(index + balance_index) <= zero_count) ^
123                                 (projection->pile_count(x - balance_index) <= zero_count);
124              }
125            }
126            balance_count =
127                static_cast<int16_t>(balance_count * textord_balance_factor / projection_scale);
128          }
129          r_index = segpt->region_index + 1;
130          total = segpt->mean_sum + dist;
131          balance_count += offset;
132          sq_dist = dist * dist + segpt->sq_sum + balance_count * balance_count;
133          mean = total / r_index;
134          factor = mean - pitch;
135          factor *= factor;
136          factor += sq_dist / (r_index)-mean * mean;
137          if (factor < cost && segpt->fake_count + faked <= fake_count) {
138            cost = factor; 
139            pred = segpt;  
140            mean_sum = total;
141            sq_sum = sq_dist;
142            fake_count = segpt->fake_count + faked;
143            mid_cuts = segpt->mid_cuts + mid_cut;
144            region_index = r_index;
145          }
146        }
147      }
148    }
149  }
150  void FPCUTPT::assign_cheap( 
151      FPCUTPT *cutpts,        
152      int16_t array_origin,   
153      int16_t x,              
154      bool faking,            
155      bool mid_cut,           
156      int16_t offset,         
157      STATS *projection,      
158      float projection_scale, 
159      int16_t zero_count,     
160      int16_t pitch,          
161      int16_t pitch_error     
162  ) {
163    int index;             
164    int16_t balance_count; 
165    int16_t r_index;       
166    FPCUTPT *segpt;        
167    int32_t dist;          
168    double sq_dist;        
169    double mean;           
170    double total;          
171    double factor;         
172    int16_t half_pitch = pitch / 2 - 1;
173    uint32_t lead_flag; 
174    if (half_pitch > 31) {
175      half_pitch = 31;
176    } else if (half_pitch < 0) {
177      half_pitch = 0;
178    }
179    lead_flag = 1 << half_pitch;
180    back_balance = cutpts[x - 1 - array_origin].back_balance << 1;
181    back_balance &= lead_flag + (lead_flag - 1);
182    if (projection->pile_count(x) > zero_count) {
183      back_balance |= 1;
184    }
185    fwd_balance = cutpts[x - 1 - array_origin].fwd_balance >> 1;
186    if (projection->pile_count(x + half_pitch) > zero_count) {
187      fwd_balance |= lead_flag;
188    }
189    xpos = x;
190    cost = FLT_MAX;
191    pred = nullptr;
192    faked = faking;
193    terminal = false;
194    region_index = 0;
195    fake_count = INT16_MAX;
196    index = x - pitch;
197    if (index >= array_origin) {
198      segpt = &cutpts[index - array_origin];
199      dist = x - segpt->xpos;
200      if (!segpt->terminal && segpt->fake_count < INT16_MAX) {
201        balance_count = 0;
202        if (textord_balance_factor > 0) {
203          lead_flag = back_balance ^ segpt->fwd_balance;
204          balance_count = 0;
205          while (lead_flag != 0) {
206            balance_count++;
207            lead_flag &= lead_flag - 1;
208          }
209          balance_count =
210              static_cast<int16_t>(balance_count * textord_balance_factor / projection_scale);
211        }
212        r_index = segpt->region_index + 1;
213        total = segpt->mean_sum + dist;
214        balance_count += offset;
215        sq_dist = dist * dist + segpt->sq_sum + balance_count * balance_count;
216        mean = total / r_index;
217        factor = mean - pitch;
218        factor *= factor;
219        factor += sq_dist / (r_index)-mean * mean;
220        cost = factor; 
221        pred = segpt;  
222        mean_sum = total;
223        sq_sum = sq_dist;
224        fake_count = segpt->fake_count + faked;
225        mid_cuts = segpt->mid_cuts + mid_cut;
226        region_index = r_index;
227      }
228    }
229  }
230  double check_pitch_sync2(    
231      BLOBNBOX_IT *blob_it,    
232      int16_t blob_count,      
233      int16_t pitch,           
234      int16_t pitch_error,     
235      STATS *projection,       
236      int16_t projection_left, 
237      int16_t projection_right, float projection_scale,
238      int16_t &occupation_count, 
239      FPSEGPT_LIST *seg_list,    
240      int16_t start,             
241      int16_t end                
242  ) {
243    bool faking;                  
244    bool mid_cut;                 
245    int16_t x;                    
246    int16_t blob_index;           
247    int16_t left_edge;            
248    int16_t right_edge;           
249    int16_t array_origin;         
250    int16_t offset;               
251    int16_t zero_count;           
252    int16_t best_left_x = 0;      
253    int16_t best_right_x = 0;     
254    TBOX this_box;                
255    TBOX next_box;                
256    FPSEGPT *segpt;               
257    double best_cost;             
258    double mean_sum;              
259    FPCUTPT *best_end;            
<span onclick='openModal()' class='match'>260    int16_t best_fake;            
261    int16_t best_count;           
262    BLOBNBOX_IT this_it;          
263    FPSEGPT_IT seg_it = seg_list; 
264    zero_count = 0;
</span>265    if (pitch < 3) {
266      pitch = 3; 
267    }
268    if ((pitch - 3) / 2 < pitch_error) {
269      pitch_error = (pitch - 3) / 2;
270    }
271    this_it = *blob_it;
272    this_box = box_next(&this_it); 
273    for (left_edge = projection_left;
274         projection->pile_count(left_edge) == 0 && left_edge < projection_right; left_edge++) {
275      ;
276    }
277    for (right_edge = projection_right;
278         projection->pile_count(right_edge) == 0 && right_edge > left_edge; right_edge--) {
279      ;
280    }
281    ASSERT_HOST(right_edge >= left_edge);
282    if (pitsync_linear_version >= 4) {
283      return check_pitch_sync3(projection_left, projection_right, zero_count, pitch, pitch_error,
284                               projection, projection_scale, occupation_count, seg_list, start, end);
285    }
286    array_origin = left_edge - pitch;
287    std::vector<FPCUTPT> cutpts(right_edge - left_edge + pitch * 2 + 1);
288    for (x = array_origin; x < left_edge; x++) {
289      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x, 0);
290    }
291    for (offset = 0; offset <= pitch_error; offset++, x++) {
292      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x,
293                                     offset);
294    }
295    this_it = *blob_it;
296    best_cost = FLT_MAX;
297    best_end = nullptr;
298    this_box = box_next(&this_it); 
299    next_box = box_next(&this_it); 
300    blob_index = 1;
301    while (x < right_edge - pitch_error) {
302      if (x > this_box.right() + pitch_error && blob_index < blob_count) {
303        this_box = next_box;
304        next_box = box_next(&this_it);
305        blob_index++;
306      }
307      faking = false;
308      mid_cut = false;
309      if (x <= this_box.left()) {
310        offset = 0;
311      } else if (x <= this_box.left() + pitch_error) {
312        offset = x - this_box.left();
313      } else if (x >= this_box.right()) {
314        offset = 0;
315      } else if (x >= next_box.left() && blob_index < blob_count) {
316        offset = x - next_box.left();
317        if (this_box.right() - x < offset) {
318          offset = this_box.right() - x;
319        }
320      } else if (x >= this_box.right() - pitch_error) {
321        offset = this_box.right() - x;
322      } else if (x - this_box.left() > pitch * pitsync_joined_edge &&
323                 this_box.right() - x > pitch * pitsync_joined_edge) {
324        mid_cut = true;
325        offset = 0;
326      } else {
327        faking = true;
328        offset = projection->pile_count(x);
329      }
330      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, faking, mid_cut, offset,
331                                      projection, projection_scale, zero_count, pitch, pitch_error);
332      x++;
333    }
334    best_fake = INT16_MAX;
335    best_cost = INT32_MAX;
336    best_count = INT16_MAX;
337    while (x < right_edge + pitch) {
338      offset = x < right_edge ? right_edge - x : 0;
339      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, false, false, offset, projection,
340                                      projection_scale, zero_count, pitch, pitch_error);
341      cutpts[x - array_origin].terminal = true;
342      if (cutpts[x - array_origin].index() + cutpts[x - array_origin].fake_count <=
343          best_count + best_fake) {
344        if (cutpts[x - array_origin].fake_count < best_fake ||
345            (cutpts[x - array_origin].fake_count == best_fake &&
346             cutpts[x - array_origin].cost_function() < best_cost)) {
347          best_fake = cutpts[x - array_origin].fake_count;
348          best_cost = cutpts[x - array_origin].cost_function();
349          best_left_x = x;
350          best_right_x = x;
351          best_count = cutpts[x - array_origin].index();
352        } else if (cutpts[x - array_origin].fake_count == best_fake && x == best_right_x + 1 &&
353                   cutpts[x - array_origin].cost_function() == best_cost) {
354          best_right_x = x;
355        }
356      }
357      x++;
358    }
359    ASSERT_HOST(best_fake < INT16_MAX);
360    best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
361    if (this_box.right() == textord_test_x && this_box.top() == textord_test_y) {
362      for (x = left_edge - pitch; x < right_edge + pitch; x++) {
363        tprintf("x=%d, C=%g, s=%g, sq=%g, prev=%d\n", x, cutpts[x - array_origin].cost_function(),
364                cutpts[x - array_origin].sum(), cutpts[x - array_origin].squares(),
365                cutpts[x - array_origin].previous()->position());
366      }
367    }
368    occupation_count = -1;
369    do {
370      for (x = best_end->position() - pitch + pitch_error;
371           x < best_end->position() - pitch_error && projection->pile_count(x) == 0; x++) {
372        ;
373      }
374      if (x < best_end->position() - pitch_error) {
375        occupation_count++;
376      }
377      segpt = new FPSEGPT(best_end);
378      seg_it.add_before_then_move(segpt);
379      best_end = best_end->previous();
380    } while (best_end != nullptr);
381    seg_it.move_to_last();
382    mean_sum = seg_it.data()->sum();
383    mean_sum = mean_sum * mean_sum / best_count;
384    if (seg_it.data()->squares() - mean_sum < 0) {
385      tprintf("Impossible sqsum=%g, mean=%g, total=%d\n", seg_it.data()->squares(),
386              seg_it.data()->sum(), best_count);
387    }
388    return seg_it.data()->squares() - mean_sum;
389  }
390  double check_pitch_sync3(    
391      int16_t projection_left, 
392      int16_t projection_right, int16_t zero_count,
393      int16_t pitch,             
394      int16_t pitch_error,       
395      STATS *projection,         
396      float projection_scale,    
397      int16_t &occupation_count, 
398      FPSEGPT_LIST *seg_list,    
399      int16_t start,             
400      int16_t end                
401  ) {
402    bool faking;                  
403    bool mid_cut;                 
404    int16_t left_edge;            
405    int16_t right_edge;           
406    int16_t x;                    
407    int16_t array_origin;         
408    int16_t offset;               
409    int16_t projection_offset;    
410    int16_t prev_zero;            
411    int16_t next_zero;            
412    int16_t zero_offset;          
413    int16_t best_left_x = 0;      
414    int16_t best_right_x = 0;     
415    FPSEGPT *segpt;               
416    int minindex;                 
417    int test_index;               
418    double best_cost;             
419    double mean_sum;              
420    FPCUTPT *best_end;            
421    int16_t best_fake;            
422    int16_t best_count;           
423    FPSEGPT_IT seg_it = seg_list; 
424    end = (end - start) % pitch;
425    if (pitch < 3) {
426      pitch = 3; 
427    }
428    if ((pitch - 3) / 2 < pitch_error) {
429      pitch_error = (pitch - 3) / 2;
430    }
431    zero_offset = static_cast<int16_t>(pitch * pitsync_joined_edge);
432    for (left_edge = projection_left;
433         projection->pile_count(left_edge) == 0 && left_edge < projection_right; left_edge++) {
434      ;
435    }
436    for (right_edge = projection_right;
437         projection->pile_count(right_edge) == 0 && right_edge > left_edge; right_edge--) {
438      ;
439    }
440    array_origin = left_edge - pitch;
441    std::vector<FPCUTPT> cutpts(right_edge - left_edge + pitch * 2 + 1);
442    std::vector<bool> mins(pitch_error * 2 + 1);
443    for (x = array_origin; x < left_edge; x++) {
444      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x, 0);
445    }
446    prev_zero = left_edge - 1;
447    for (offset = 0; offset <= pitch_error; offset++, x++) {
448      cutpts[x - array_origin].setup(&cutpts[0], array_origin, projection, zero_count, pitch, x,
449                                     offset);
450    }
451    best_cost = FLT_MAX;
452    best_end = nullptr;
453    for (offset = -pitch_error, minindex = 0; offset < pitch_error; offset++, minindex++) {
454      mins[minindex] = projection->local_min(x + offset);
455    }
456    next_zero = x + zero_offset + 1;
457    for (offset = next_zero - 1; offset >= x; offset--) {
458      if (projection->pile_count(offset) <= zero_count) {
459        next_zero = offset;
460        break;
461      }
462    }
463    while (x < right_edge - pitch_error) {
464      mins[minindex] = projection->local_min(x + pitch_error);
465      minindex++;
466      if (minindex > pitch_error * 2) {
467        minindex = 0;
468      }
469      faking = false;
470      mid_cut = false;
471      offset = 0;
472      if (projection->pile_count(x) <= zero_count) {
473        prev_zero = x;
474      } else {
475        for (offset = 1; offset <= pitch_error; offset++) {
476          if (projection->pile_count(x + offset) <= zero_count ||
477              projection->pile_count(x - offset) <= zero_count) {
478            break;
479          }
480        }
481      }
482      if (offset > pitch_error) {
483        if (x - prev_zero > zero_offset && next_zero - x > zero_offset) {
484          for (offset = 0; offset <= pitch_error; offset++) {
485            test_index = minindex + pitch_error + offset;
486            if (test_index > pitch_error * 2) {
487              test_index -= pitch_error * 2 + 1;
488            }
489            if (mins[test_index]) {
490              break;
491            }
492            test_index = minindex + pitch_error - offset;
493            if (test_index > pitch_error * 2) {
494              test_index -= pitch_error * 2 + 1;
495            }
496            if (mins[test_index]) {
497              break;
498            }
499          }
500        }
501        if (offset > pitch_error) {
502          offset = projection->pile_count(x);
503          faking = true;
504        } else {
505          projection_offset = static_cast<int16_t>(projection->pile_count(x) / projection_scale);
506          if (projection_offset > offset) {
507            offset = projection_offset;
508          }
509          mid_cut = true;
510        }
511      }
512      if ((start == 0 && end == 0) || !textord_fast_pitch_test ||
513          (x - projection_left - start) % pitch <= end) {
514        cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, faking, mid_cut, offset,
515                                        projection, projection_scale, zero_count, pitch, pitch_error);
516      } else {
517        cutpts[x - array_origin].assign_cheap(&cutpts[0], array_origin, x, faking, mid_cut, offset,
518                                              projection, projection_scale, zero_count, pitch,
519                                              pitch_error);
520      }
521      x++;
522      if (next_zero < x || next_zero == x + zero_offset) {
523        next_zero = x + zero_offset + 1;
524      }
525      if (projection->pile_count(x + zero_offset) <= zero_count) {
526        next_zero = x + zero_offset;
527      }
528    }
529    best_fake = INT16_MAX;
530    best_cost = INT32_MAX;
531    best_count = INT16_MAX;
532    while (x < right_edge + pitch) {
533      offset = x < right_edge ? right_edge - x : 0;
534      cutpts[x - array_origin].assign(&cutpts[0], array_origin, x, false, false, offset, projection,
535                                      projection_scale, zero_count, pitch, pitch_error);
536      cutpts[x - array_origin].terminal = true;
537      if (cutpts[x - array_origin].index() + cutpts[x - array_origin].fake_count <=
538          best_count + best_fake) {
539        if (cutpts[x - array_origin].fake_count < best_fake ||
540            (cutpts[x - array_origin].fake_count == best_fake &&
541             cutpts[x - array_origin].cost_function() < best_cost)) {
542          best_fake = cutpts[x - array_origin].fake_count;
543          best_cost = cutpts[x - array_origin].cost_function();
544          best_left_x = x;
545          best_right_x = x;
546          best_count = cutpts[x - array_origin].index();
547        } else if (cutpts[x - array_origin].fake_count == best_fake && x == best_right_x + 1 &&
548                   cutpts[x - array_origin].cost_function() == best_cost) {
549          best_right_x = x;
550        }
551      }
552      x++;
553    }
554    ASSERT_HOST(best_fake < INT16_MAX);
555    best_end = &cutpts[(best_left_x + best_right_x) / 2 - array_origin];
556    occupation_count = -1;
557    do {
558      for (x = best_end->position() - pitch + pitch_error;
559           x < best_end->position() - pitch_error && projection->pile_count(x) == 0; x++) {
560      }
561      if (x < best_end->position() - pitch_error) {
562        occupation_count++;
563      }
564      segpt = new FPSEGPT(best_end);
565      seg_it.add_before_then_move(segpt);
566      best_end = best_end->previous();
567    } while (best_end != nullptr);
568    seg_it.move_to_last();
569    mean_sum = seg_it.data()->sum();
570    mean_sum = mean_sum * mean_sum / best_count;
571    if (seg_it.data()->squares() - mean_sum < 0) {
572      tprintf("Impossible sqsum=%g, mean=%g, total=%d\n", seg_it.data()->squares(),
573              seg_it.data()->sum(), best_count);
574    }
575    return seg_it.data()->squares() - mean_sum;
576  }
577  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "coutln.h"
5  #include "arrayaccess.h" 
6  #include "blobs.h"       
7  #include "crakedge.h"    
8  #include "environ.h"     
9  #include "errcode.h"     
10  #include "normalis.h"    
11  #include "helpers.h" 
12  #include <allheaders.h> 
13  #include "pix.h"        
14  #include <algorithm> 
15  #include <cmath>     
16  #include <cstdlib>   
17  #include <cstring>   
18  namespace tesseract {
19  ICOORD C_OUTLINE::step_coords[4] = {ICOORD(-1, 0), ICOORD(0, -1), ICOORD(1, 0), ICOORD(0, 1)};
20  C_OUTLINE::C_OUTLINE(CRACKEDGE *startpt, ICOORD bot_left, ICOORD top_right, int16_t length)
21      : box(bot_left, top_right), start(startpt->pos), offsets(nullptr) {
22    int16_t stepindex; 
23    CRACKEDGE *edgept; 
24    stepcount = length; 
25    if (length == 0) {
26      return;
27    }
28    steps.resize(step_mem());
29    edgept = startpt;
30    for (stepindex = 0; stepindex < length; stepindex++) {
31      set_step(stepindex, edgept->stepdir);
32      edgept = edgept->next;
33    }
34  }
35  C_OUTLINE::C_OUTLINE(
36      ICOORD startpt, DIR128 *new_steps,
37      int16_t length 
38      )
39      : start(startpt), offsets(nullptr) {
40    int8_t dirdiff;    
41    DIR128 prevdir;    
42    DIR128 dir;        
43    DIR128 lastdir;    
44    TBOX new_box;      
45    int16_t stepindex; 
46    int16_t srcindex;  
47    ICOORD pos;        
48    pos = startpt;
49    stepcount = length; 
50    ASSERT_HOST(length >= 0);
51    steps.resize(step_mem()); 
52    lastdir = new_steps[length - 1];
53    prevdir = lastdir;
54    for (stepindex = 0, srcindex = 0; srcindex < length; stepindex++, srcindex++) {
55      new_box = TBOX(pos, pos);
56      box += new_box;
57      dir = new_steps[srcindex];
58      set_step(stepindex, dir);
59      dirdiff = dir - prevdir;
60      pos += step(stepindex);
61      if ((dirdiff == 64 || dirdiff == -64) && stepindex > 0) {
62        stepindex -= 2; 
63        prevdir = stepindex >= 0 ? step_dir(stepindex) : lastdir;
64      } else {
65        prevdir = dir;
66      }
67    }
68    ASSERT_HOST(pos.x() == startpt.x() && pos.y() == startpt.y());
69    do {
70      dirdiff = step_dir(stepindex - 1) - step_dir(0);
71      if (dirdiff == 64 || dirdiff == -64) {
72        start += step(0);
73        stepindex -= 2; 
74        for (int i = 0; i < stepindex; ++i) {
75          set_step(i, step_dir(i + 1));
76        }
77      }
78    } while (stepindex > 1 && (dirdiff == 64 || dirdiff == -64));
79    stepcount = stepindex;
80    ASSERT_HOST(stepcount >= 4);
81  }
82  C_OUTLINE::C_OUTLINE(C_OUTLINE *srcline, FCOORD rotation) : offsets(nullptr) {
83    TBOX new_box;      
84    int16_t stepindex; 
85    int16_t dirdiff;   
<span onclick='openModal()' class='match'>86    ICOORD pos;        
87    ICOORD prevpos;    
88    ICOORD destpos;                
89    int16_t destindex = INT16_MAX; 
90    DIR128 dir;                    
</span>91    uint8_t new_step;
92    stepcount = srcline->stepcount * 2;
93    if (stepcount == 0) {
94      box = srcline->box;
95      box.rotate(rotation);
96      return;
97    }
98    steps.resize(step_mem());
99    for (int iteration = 0; iteration < 2; ++iteration) {
100      DIR128 round1 = iteration == 0 ? 32 : 0;
101      DIR128 round2 = iteration != 0 ? 32 : 0;
102      pos = srcline->start;
103      prevpos = pos;
104      prevpos.rotate(rotation);
105      start = prevpos;
106      box = TBOX(start, start);
107      destindex = 0;
108      for (stepindex = 0; stepindex < srcline->stepcount; stepindex++) {
109        pos += srcline->step(stepindex);
110        destpos = pos;
111        destpos.rotate(rotation);
112        while (destpos.x() != prevpos.x() || destpos.y() != prevpos.y()) {
113          dir = DIR128(FCOORD(destpos - prevpos));
114          dir += 64; 
115          new_step = dir.get_dir();
116          if (new_step & 31) {
117            set_step(destindex++, dir + round1);
118            prevpos += step(destindex - 1);
119            if (destindex < 2 ||
120                ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) != -64 &&
121                 dirdiff != 64)) {
122              set_step(destindex++, dir + round2);
123              prevpos += step(destindex - 1);
124            } else {
125              prevpos -= step(destindex - 1);
126              destindex--;
127              prevpos -= step(destindex - 1);
128              set_step(destindex - 1, dir + round2);
129              prevpos += step(destindex - 1);
130            }
131          } else {
132            set_step(destindex++, dir);
133            prevpos += step(destindex - 1);
134          }
135          while (destindex >= 2 &&
136                 ((dirdiff = step_dir(destindex - 1) - step_dir(destindex - 2)) == -64 ||
137                  dirdiff == 64)) {
138            prevpos -= step(destindex - 1);
139            prevpos -= step(destindex - 2);
140            destindex -= 2; 
141          }
142          new_box = TBOX(destpos, destpos);
143          box += new_box;
144        }
145      }
146      ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
147      while (destindex > 1) {
148        dirdiff = step_dir(destindex - 1) - step_dir(0);
149        if (dirdiff != 64 && dirdiff != -64) {
150          break;
151        }
152        start += step(0);
153        destindex -= 2;
154        for (int i = 0; i < destindex; ++i) {
155          set_step(i, step_dir(i + 1));
156        }
157      }
158      if (destindex >= 4) {
159        break;
160      }
161    }
162    ASSERT_HOST(destindex <= stepcount);
163    stepcount = destindex;
164    destpos = start;
165    for (stepindex = 0; stepindex < stepcount; stepindex++) {
166      destpos += step(stepindex);
167    }
168    ASSERT_HOST(destpos.x() == start.x() && destpos.y() == start.y());
169  }
170  void C_OUTLINE::FakeOutline(const TBOX &box, C_OUTLINE_LIST *outlines) {
171    C_OUTLINE_IT ol_it(outlines);
172    CRACKEDGE start;
173    start.pos = box.topleft();
174    auto *outline = new C_OUTLINE(&start, box.topleft(), box.botright(), 0);
175    ol_it.add_to_end(outline);
176  }
177  int32_t C_OUTLINE::area() const {
178    int stepindex;       
179    int32_t total_steps; 
180    int32_t total;       
181    ICOORD pos;          
182    ICOORD next_step;    
183    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
184    pos = start_pos();
185    total_steps = pathlength();
186    total = 0;
187    for (stepindex = 0; stepindex < total_steps; stepindex++) {
188      next_step = step(stepindex);
189      if (next_step.x() < 0) {
190        total += pos.y();
191      } else if (next_step.x() > 0) {
192        total -= pos.y();
193      }
194      pos += next_step;
195    }
196    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
197      total += it.data()->area(); 
198    }
199    return total;
200  }
201  int32_t C_OUTLINE::perimeter() const {
202    int32_t total_steps; 
203    C_OUTLINE_IT it(const_cast<C_OUTLINE_LIST *>(&children));
204    total_steps = pathlength();
205    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
206      total_steps += it.data()->pathlength(); 
207    }
208    return total_steps;
209  }
210  int32_t C_OUTLINE::outer_area() const {
211    int stepindex;       
212    int32_t total_steps; 
213    int32_t total;       
214    ICOORD pos;          
215    ICOORD next_step;    
216    pos = start_pos();
217    total_steps = pathlength();
218    if (total_steps == 0) {
219      return box.area();
220    }
221    total = 0;
222    for (stepindex = 0; stepindex < total_steps; stepindex++) {
223      next_step = step(stepindex);
224      if (next_step.x() < 0) {
225        total += pos.y();
226      } else if (next_step.x() > 0) {
227        total -= pos.y();
228      }
229      pos += next_step;
230    }
231    return total;
232  }
233  int32_t C_OUTLINE::count_transitions(int32_t threshold) {
234    bool first_was_max_x; 
235    bool first_was_max_y;
236    bool looking_for_max_x; 
237    bool looking_for_min_x;
238    bool looking_for_max_y; 
239    bool looking_for_min_y;
240    int stepindex;       
241    int32_t total_steps; 
242    int32_t max_x, min_x, max_y, min_y;
243    int32_t initial_x, initial_y; 
244    int32_t total;                
245    ICOORD pos;                   
246    ICOORD next_step;             
247    pos = start_pos();
248    total_steps = pathlength();
249    total = 0;
250    max_x = min_x = pos.x();
251    max_y = min_y = pos.y();
252    looking_for_max_x = true;
253    looking_for_min_x = true;
254    looking_for_max_y = true;
255    looking_for_min_y = true;
256    first_was_max_x = false;
257    first_was_max_y = false;
258    initial_x = pos.x();
259    initial_y = pos.y(); 
260    for (stepindex = 0; stepindex < total_steps; stepindex++) {
261      next_step = step(stepindex);
262      pos += next_step;
263      if (next_step.x() < 0) {
264        if (looking_for_max_x && pos.x() < min_x) {
265          min_x = pos.x();
266        }
267        if (looking_for_min_x && max_x - pos.x() > threshold) {
268          if (looking_for_max_x) {
269            initial_x = max_x;
270            first_was_max_x = false;
271          }
272          total++;
273          looking_for_max_x = true;
274          looking_for_min_x = false;
275          min_x = pos.x(); 
276        }
277      } else if (next_step.x() > 0) {
278        if (looking_for_min_x && pos.x() > max_x) {
279          max_x = pos.x();
280        }
281        if (looking_for_max_x && pos.x() - min_x > threshold) {
282          if (looking_for_min_x) {
283            initial_x = min_x; 
284            first_was_max_x = true;
285          }
286          total++;
287          looking_for_max_x = false;
288          looking_for_min_x = true;
289          max_x = pos.x();
290        }
291      } else if (next_step.y() < 0) {
292        if (looking_for_max_y && pos.y() < min_y) {
293          min_y = pos.y();
294        }
295        if (looking_for_min_y && max_y - pos.y() > threshold) {
296          if (looking_for_max_y) {
297            initial_y = max_y; 
298            first_was_max_y = false;
299          }
300          total++;
301          looking_for_max_y = true;
302          looking_for_min_y = false;
303          min_y = pos.y(); 
304        }
305      } else {
306        if (looking_for_min_y && pos.y() > max_y) {
307          max_y = pos.y();
308        }
309        if (looking_for_max_y && pos.y() - min_y > threshold) {
310          if (looking_for_min_y) {
311            initial_y = min_y; 
312            first_was_max_y = true;
313          }
314          total++;
315          looking_for_max_y = false;
316          looking_for_min_y = true;
317          max_y = pos.y();
318        }
319      }
320    }
321    if (first_was_max_x && looking_for_min_x) {
322      if (max_x - initial_x > threshold) {
323        total++;
324      } else {
325        total--;
326      }
327    } else if (!first_was_max_x && looking_for_max_x) {
328      if (initial_x - min_x > threshold) {
329        total++;
330      } else {
331        total--;
332      }
333    }
334    if (first_was_max_y && looking_for_min_y) {
335      if (max_y - initial_y > threshold) {
336        total++;
337      } else {
338        total--;
339      }
340    } else if (!first_was_max_y && looking_for_max_y) {
341      if (initial_y - min_y > threshold) {
342        total++;
343      } else {
344        total--;
345      }
346    }
347    return total;
348  }
349  bool C_OUTLINE::operator<(const C_OUTLINE &other) const {
350    int16_t count = 0; 
351    ICOORD pos;        
352    int32_t stepindex; 
353    if (!box.overlap(other.box)) {
354      return false; 
355    }
356    if (stepcount == 0) {
357      return other.box.contains(this->box);
358    }
359    pos = start;
360    for (stepindex = 0; stepindex < stepcount && (count = other.winding_number(pos)) == INTERSECTING;
361         stepindex++) {
362      pos += step(stepindex); 
363    }
364    if (count == INTERSECTING) {
365      pos = other.start;
366      for (stepindex = 0;
367           stepindex < other.stepcount && (count = winding_number(pos)) == INTERSECTING;
368           stepindex++) {
369        pos += other.step(stepindex);
370      }
371      return count == INTERSECTING || count == 0;
372    }
373    return count != 0;
374  }
375  int16_t C_OUTLINE::winding_number(ICOORD point) const {
376    int16_t stepindex; 
377    int16_t count;     
378    ICOORD vec;        
379    ICOORD stepvec;    
380    int32_t cross;     
381    vec = start - point; 
382    count = 0;
383    for (stepindex = 0; stepindex < stepcount; stepindex++) {
384      stepvec = step(stepindex); 
385      if (vec.y() <= 0 && vec.y() + stepvec.y() > 0) {
386        cross = vec * stepvec; 
387        if (cross > 0) {
388          count++; 
389        } else if (cross == 0) {
390          return INTERSECTING; 
391        }
392      } else if (vec.y() > 0 && vec.y() + stepvec.y() <= 0) {
393        cross = vec * stepvec;
394        if (cross < 0) {
395          count--; 
396        } else if (cross == 0) {
397          return INTERSECTING; 
398        }
399      }
400      vec += stepvec; 
401    }
402    return count; 
403  }
404  int16_t C_OUTLINE::turn_direction() const { 
405    DIR128 prevdir;                           
406    DIR128 dir;                               
407    int16_t stepindex;                        
408    int8_t dirdiff;                           
409    int16_t count;                            
410    if (stepcount == 0) {
411      return 128;
412    }
413    count = 0;
414    prevdir = step_dir(stepcount - 1);
415    for (stepindex = 0; stepindex < stepcount; stepindex++) {
416      dir = step_dir(stepindex);
417      dirdiff = dir - prevdir;
418      ASSERT_HOST(dirdiff == 0 || dirdiff == 32 || dirdiff == -32);
419      count += dirdiff;
420      prevdir = dir;
421    }
422    ASSERT_HOST(count == 128 || count == -128);
423    return count; 
424  }
425  void C_OUTLINE::reverse() {      
426    DIR128 halfturn = MODULUS / 2; 
427    DIR128 stepdir;                
428    int16_t stepindex;             
429    int16_t farindex;              
430    int16_t halfsteps;             
431    halfsteps = (stepcount + 1) / 2;
432    for (stepindex = 0; stepindex < halfsteps; stepindex++) {
433      farindex = stepcount - stepindex - 1;
434      stepdir = step_dir(stepindex);
435      set_step(stepindex, step_dir(farindex) + halfturn);
436      set_step(farindex, stepdir + halfturn);
437    }
438  }
439  void C_OUTLINE::move(const ICOORD vec) {
440    C_OUTLINE_IT it(&children); 
441    box.move(vec);
442    start += vec;
443    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
444      it.data()->move(vec); 
445    }
446  }
447  bool C_OUTLINE::IsLegallyNested() const {
448    if (stepcount == 0) {
449      return true;
450    }
451    int64_t parent_area = outer_area();
452    C_OUTLINE_IT child_it(const_cast<C_OUTLINE_LIST *>(&children));
453    for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
454      const C_OUTLINE *child = child_it.data();
455      if (child->outer_area() * parent_area > 0 || !child->IsLegallyNested()) {
456        return false;
457      }
458    }
459    return true;
460  }
461  void C_OUTLINE::RemoveSmallRecursive(int min_size, C_OUTLINE_IT *it) {
462    if (box.width() < min_size || box.height() < min_size) {
463      ASSERT_HOST(this == it->data());
464      delete it->extract(); 
465    } else if (!children.empty()) {
466      C_OUTLINE_IT child_it(&children);
467      for (child_it.mark_cycle_pt(); !child_it.cycled_list(); child_it.forward()) {
468        C_OUTLINE *child = child_it.data();
469        child->RemoveSmallRecursive(min_size, &child_it);
470      }
471    }
472  }
473  static void ComputeGradient(const l_uint32 *data, int wpl, int x, int y, int width, int height,
474                              ICOORD *gradient) {
475    const l_uint32 *line = data + y * wpl;
476    int pix_x_y = x < width && y < height ? GET_DATA_BYTE(line, x) : 255;
477    int pix_x_prevy = x < width && y > 0 ? GET_DATA_BYTE(line - wpl, x) : 255;
478    int pix_prevx_prevy = x > 0 && y > 0 ? GET_DATA_BYTE(line - wpl, x - 1) : 255;
479    int pix_prevx_y = x > 0 && y < height ? GET_DATA_BYTE(line, x - 1) : 255;
480    gradient->set_x(pix_x_y + pix_x_prevy - (pix_prevx_y + pix_prevx_prevy));
481    gradient->set_y(pix_x_prevy + pix_prevx_prevy - (pix_x_y + pix_prevx_y));
482  }
483  static bool EvaluateVerticalDiff(const l_uint32 *data, int wpl, int diff_sign, int x, int y,
484                                   int height, int *best_diff, int *best_sum, int *best_y) {
485    if (y <= 0 || y >= height) {
486      return false;
487    }
488    const l_uint32 *line = data + y * wpl;
489    int pixel1 = GET_DATA_BYTE(line - wpl, x);
490    int pixel2 = GET_DATA_BYTE(line, x);
491    int diff = (pixel2 - pixel1) * diff_sign;
492    if (diff > *best_diff) {
493      *best_diff = diff;
494      *best_sum = pixel1 + pixel2;
495      *best_y = y;
496    }
497    return diff > 0;
498  }
499  static bool EvaluateHorizontalDiff(const l_uint32 *line, int diff_sign, int x, int width,
500                                     int *best_diff, int *best_sum, int *best_x) {
501    if (x <= 0 || x >= width) {
502      return false;
503    }
504    int pixel1 = GET_DATA_BYTE(line, x - 1);
505    int pixel2 = GET_DATA_BYTE(line, x);
506    int diff = (pixel2 - pixel1) * diff_sign;
507    if (diff > *best_diff) {
508      *best_diff = diff;
509      *best_sum = pixel1 + pixel2;
510      *best_x = x;
511    }
512    return diff > 0;
513  }
514  void C_OUTLINE::ComputeEdgeOffsets(int threshold, Image pix) {
515    if (pixGetDepth(pix) != 8) {
516      return;
517    }
518    const l_uint32 *data = pixGetData(pix);
519    int wpl = pixGetWpl(pix);
520    int width = pixGetWidth(pix);
521    int height = pixGetHeight(pix);
522    bool negative = flag(COUT_INVERSE);
523    delete[] offsets;
524    offsets = new EdgeOffset[stepcount];
525    ICOORD pos = start;
526    ICOORD prev_gradient;
527    ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &prev_gradient);
528    for (int s = 0; s < stepcount; ++s) {
529      ICOORD step_vec = step(s);
530      TPOINT pt1(pos);
531      pos += step_vec;
532      TPOINT pt2(pos);
533      ICOORD next_gradient;
534      ComputeGradient(data, wpl, pos.x(), height - pos.y(), width, height, &next_gradient);
535      ICOORD gradient = prev_gradient + next_gradient;
536      int best_diff = 0;
537      int offset = 0;
538      if (pt1.y == pt2.y && abs(gradient.y()) * 2 >= abs(gradient.x())) {
539        int diff_sign = (pt1.x > pt2.x) == negative ? 1 : -1;
540        int x = std::min(pt1.x, pt2.x);
541        int y = height - pt1.y;
542        int best_sum = 0;
543        int best_y = y;
544        EvaluateVerticalDiff(data, wpl, diff_sign, x, y, height, &best_diff, &best_sum, &best_y);
545        int test_y = y;
546        do {
547          ++test_y;
548        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
549                                      &best_y));
550        test_y = y;
551        do {
552          --test_y;
553        } while (EvaluateVerticalDiff(data, wpl, diff_sign, x, test_y, height, &best_diff, &best_sum,
554                                      &best_y));
555        offset = diff_sign * (best_sum / 2 - threshold) + (y - best_y) * best_diff;
556      } else if (pt1.x == pt2.x && abs(gradient.x()) * 2 >= abs(gradient.y())) {
557        int diff_sign = (pt1.y > pt2.y) == negative ? 1 : -1;
558        int x = pt1.x;
559        int y = height - std::max(pt1.y, pt2.y);
560        const l_uint32 *line = pixGetData(pix) + y * wpl;
561        int best_sum = 0;
562        int best_x = x;
563        EvaluateHorizontalDiff(line, diff_sign, x, width, &best_diff, &best_sum, &best_x);
564        int test_x = x;
565        do {
566          ++test_x;
567        } while (
568            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
569        test_x = x;
570        do {
571          --test_x;
572        } while (
573            EvaluateHorizontalDiff(line, diff_sign, test_x, width, &best_diff, &best_sum, &best_x));
574        offset = diff_sign * (threshold - best_sum / 2) + (best_x - x) * best_diff;
575      }
576      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
577      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
578      if (negative) {
579        gradient = -gradient;
580      }
581      offsets[s].direction = Modulo(FCOORD::binary_angle_plus_pi(gradient.angle()) + 64, 256);
582      prev_gradient = next_gradient;
583    }
584  }
585  void C_OUTLINE::ComputeBinaryOffsets() {
586    delete[] offsets;
587    offsets = new EdgeOffset[stepcount];
588    int dir_counts[4];
589    int pos_totals[4];
590    memset(dir_counts, 0, sizeof(dir_counts));
591    memset(pos_totals, 0, sizeof(pos_totals));
592    ICOORD pos = start;
593    ICOORD tail_pos = pos;
594    tail_pos -= step(stepcount - 1);
595    tail_pos -= step(stepcount - 2);
596    ICOORD head_pos = tail_pos;
597    for (int s = -2; s < 2; ++s) {
598      increment_step(s, 1, &head_pos, dir_counts, pos_totals);
599    }
600    for (int s = 0; s < stepcount; pos += step(s++)) {
601      increment_step(s + 2, 1, &head_pos, dir_counts, pos_totals);
602      int dir_index = chain_code(s);
603      ICOORD step_vec = step(s);
604      int best_diff = 0;
605      int offset = 0;
606      if (dir_counts[dir_index] >= 2 ||
607          (dir_counts[dir_index] == 1 && dir_counts[Modulo(dir_index - 1, 4)] == 2 &&
608           dir_counts[Modulo(dir_index + 1, 4)] == 2)) {
609        best_diff = dir_counts[dir_index];
610        int edge_pos = step_vec.x() == 0 ? pos.x() : pos.y();
611        offset = pos_totals[dir_index] - best_diff * edge_pos;
612      }
613      offsets[s].offset_numerator = ClipToRange<int>(offset, -INT8_MAX, INT8_MAX);
614      offsets[s].pixel_diff = ClipToRange<int>(best_diff, 0, UINT8_MAX);
615      FCOORD direction(head_pos.x() - tail_pos.x(), head_pos.y() - tail_pos.y());
616      offsets[s].direction = direction.to_direction();
617      increment_step(s - 2, -1, &tail_pos, dir_counts, pos_totals);
618    }
619  }
620  void C_OUTLINE::render(int left, int top, Image pix) const {
621    ICOORD pos = start;
622    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
623      ICOORD next_step = step(stepindex);
624      if (next_step.y() < 0) {
625        pixRasterop(pix, 0, top - pos.y(), pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
626      } else if (next_step.y() > 0) {
627        pixRasterop(pix, 0, top - pos.y() - 1, pos.x() - left, 1, PIX_NOT(PIX_DST), nullptr, 0, 0);
628      }
629      pos += next_step;
630    }
631  }
632  void C_OUTLINE::render_outline(int left, int top, Image pix) const {
633    ICOORD pos = start;
634    for (int stepindex = 0; stepindex < stepcount; ++stepindex) {
635      ICOORD next_step = step(stepindex);
636      if (next_step.y() < 0) {
637        pixSetPixel(pix, pos.x() - left, top - pos.y(), 1);
638      } else if (next_step.y() > 0) {
639        pixSetPixel(pix, pos.x() - left - 1, top - pos.y() - 1, 1);
640      } else if (next_step.x() < 0) {
641        pixSetPixel(pix, pos.x() - left - 1, top - pos.y(), 1);
642      } else if (next_step.x() > 0) {
643        pixSetPixel(pix, pos.x() - left, top - pos.y() - 1, 1);
644      }
645      pos += next_step;
646    }
647  }
648  #ifndef GRAPHICS_DISABLED
649  void C_OUTLINE::plot(ScrollView *window, ScrollView::Color colour) const {
650    int16_t stepindex; 
651    ICOORD pos;        
652    DIR128 stepdir;    
653    pos = start; 
654    window->Pen(colour);
655    if (stepcount == 0) {
656      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
657      return;
658    }
659    window->SetCursor(pos.x(), pos.y());
660    stepindex = 0;
661    while (stepindex < stepcount) {
662      pos += step(stepindex); 
663      stepdir = step_dir(stepindex);
664      stepindex++; 
665      while (stepindex < stepcount && stepdir.get_dir() == step_dir(stepindex).get_dir()) {
666        pos += step(stepindex);
667        stepindex++;
668      }
669      window->DrawTo(pos.x(), pos.y());
670    }
671  }
672  void C_OUTLINE::plot_normed(const DENORM &denorm, ScrollView::Color colour,
673                              ScrollView *window) const {
674    window->Pen(colour);
675    if (stepcount == 0) {
676      window->Rectangle(box.left(), box.top(), box.right(), box.bottom());
677      return;
678    }
679    const DENORM *root_denorm = denorm.RootDenorm();
680    ICOORD pos = start; 
681    FCOORD f_pos = sub_pixel_pos_at_index(pos, 0);
682    FCOORD pos_normed;
683    denorm.NormTransform(root_denorm, f_pos, &pos_normed);
684    window->SetCursor(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
685    for (int s = 0; s < stepcount; pos += step(s++)) {
686      int edge_weight = edge_strength_at_index(s);
687      if (edge_weight == 0) {
688        continue;
689      }
690      FCOORD f_pos = sub_pixel_pos_at_index(pos, s);
691      FCOORD pos_normed;
692      denorm.NormTransform(root_denorm, f_pos, &pos_normed);
693      window->DrawTo(IntCastRounded(pos_normed.x()), IntCastRounded(pos_normed.y()));
694    }
695  }
696  #endif
697  C_OUTLINE &C_OUTLINE::operator=(const C_OUTLINE &source) {
698    box = source.box;
699    start = source.start;
700    if (!children.empty()) {
701      children.clear();
702    }
703    children.deep_copy(&source.children, &deep_copy);
704    delete[] offsets;
705    offsets = nullptr;
706    stepcount = source.stepcount;
707    if (stepcount > 0) {
708      steps.resize(step_mem());
709      memmove(&steps[0], &source.steps[0], step_mem());
710      if (source.offsets != nullptr) {
711        offsets = new EdgeOffset[stepcount];
712        memcpy(offsets, source.offsets, stepcount * sizeof(*offsets));
713      }
714    }
715    return *this;
716  }
717  void C_OUTLINE::increment_step(int s, int increment, ICOORD *pos, int *dir_counts,
718                                 int *pos_totals) const {
719    int step_index = Modulo(s, stepcount);
720    int dir_index = chain_code(step_index);
721    dir_counts[dir_index] += increment;
722    ICOORD step_vec = step(step_index);
723    if (step_vec.x() == 0) {
724      pos_totals[dir_index] += pos->x() * increment;
725    } else {
726      pos_totals[dir_index] += pos->y() * increment;
727    }
728    *pos += step_vec;
729  }
730  ICOORD C_OUTLINE::chain_step(int chaindir) {
731    return step_coords[chaindir % 4];
732  }
733  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-pithsync.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-coutln.cpp</div>
                </div>
                <div class="column column_space"><pre><code>260    int16_t best_fake;            
261    int16_t best_count;           
262    BLOBNBOX_IT this_it;          
263    FPSEGPT_IT seg_it = seg_list; 
264    zero_count = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>86    ICOORD pos;        
87    ICOORD prevpos;    
88    ICOORD destpos;                
89    int16_t destindex = INT16_MAX; 
90    DIR128 dir;                    
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    