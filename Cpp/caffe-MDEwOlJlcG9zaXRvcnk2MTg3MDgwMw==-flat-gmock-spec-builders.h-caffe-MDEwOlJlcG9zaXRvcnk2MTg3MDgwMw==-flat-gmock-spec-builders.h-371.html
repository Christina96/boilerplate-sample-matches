
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
3  #include &lt;map&gt;
4  #include &lt;set&gt;
5  #include &lt;sstream&gt;
6  #include &lt;string&gt;
7  #include &lt;vector&gt;
8  #if GTEST_HAS_EXCEPTIONS
9  # include &lt;stdexcept&gt;  
10  #endif
11  #include &quot;gmock/gmock-actions.h&quot;
12  #include &quot;gmock/gmock-cardinalities.h&quot;
13  #include &quot;gmock/gmock-matchers.h&quot;
14  #include &quot;gmock/internal/gmock-internal-utils.h&quot;
15  #include &quot;gmock/internal/gmock-port.h&quot;
16  #include &quot;gtest/gtest.h&quot;
17  namespace testing {
18  class Expectation;
19  class ExpectationSet;
20  namespace internal {
21  template &lt;typename F&gt; class FunctionMocker;
22  class ExpectationBase;
23  template &lt;typename F&gt; class TypedExpectation;
24  class ExpectationTester;
25  template &lt;typename F&gt; class FunctionMockerBase;
26  GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
27  class UntypedActionResultHolderBase;
28  class GTEST_API_ UntypedFunctionMockerBase {
29   public:
30    UntypedFunctionMockerBase();
31    virtual ~UntypedFunctionMockerBase();
32    bool VerifyAndClearExpectationsLocked()
33        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
34    virtual void ClearDefaultActionsLocked()
35        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;
36    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
37        const void* untyped_args,
38        const string&amp; call_description) const = 0;
39    virtual UntypedActionResultHolderBase* UntypedPerformAction(
40        const void* untyped_action,
41        const void* untyped_args) const = 0;
42    virtual void UntypedDescribeUninterestingCall(
43        const void* untyped_args,
44        ::std::ostream* os) const
45            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
46    virtual const ExpectationBase* UntypedFindMatchingExpectation(
47        const void* untyped_args,
48        const void** untyped_action, bool* is_excessive,
49        ::std::ostream* what, ::std::ostream* why)
50            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
51    virtual void UntypedPrintArgs(const void* untyped_args,
52                                  ::std::ostream* os) const = 0;
53    void RegisterOwner(const void* mock_obj)
54        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
55    void SetOwnerAndName(const void* mock_obj, const char* name)
56        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
57    const void* MockObject() const
58        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
59    const char* Name() const
60        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
61    const UntypedActionResultHolderBase* UntypedInvokeWith(
62        const void* untyped_args)
63            GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
64   protected:
65    typedef std::vector&lt;const void*&gt; UntypedOnCallSpecs;
66    typedef std::vector&lt;internal::linked_ptr&lt;ExpectationBase&gt; &gt;
67    UntypedExpectations;
68    Expectation GetHandleOf(ExpectationBase* exp);
69    const void* mock_obj_;  
70    const char* name_;  
71    UntypedOnCallSpecs untyped_on_call_specs_;
72    UntypedExpectations untyped_expectations_;
73  };  
74  class UntypedOnCallSpecBase {
75   public:
76    UntypedOnCallSpecBase(const char* a_file, int a_line)
77        : file_(a_file), line_(a_line), last_clause_(kNone) {}
78    const char* file() const { return file_; }
79    int line() const { return line_; }
80   protected:
81    enum Clause {
82      kNone,
83      kWith,
84      kWillByDefault
85    };
86    void AssertSpecProperty(bool property, const string&amp; failure_message) const {
87      Assert(property, file_, line_, failure_message);
88    }
89    void ExpectSpecProperty(bool property, const string&amp; failure_message) const {
90      Expect(property, file_, line_, failure_message);
91    }
92    const char* file_;
93    int line_;
94    Clause last_clause_;
95  };  
96  template &lt;typename F&gt;
97  class OnCallSpec : public UntypedOnCallSpecBase {
98   public:
99    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
100    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
101    OnCallSpec(const char* a_file, int a_line,
102               const ArgumentMatcherTuple&amp; matchers)
103        : UntypedOnCallSpecBase(a_file, a_line),
104          matchers_(matchers),
105          extra_matcher_(A&lt;const ArgumentTuple&amp;&gt;()) {
106    }
107    OnCallSpec&amp; With(const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m) {
108      ExpectSpecProperty(last_clause_ &lt; kWith,
109                         &quot;.With() cannot appear &quot;
110                         &quot;more than once in an ON_CALL().&quot;);
111      last_clause_ = kWith;
112      extra_matcher_ = m;
113      return *this;
114    }
115    OnCallSpec&amp; WillByDefault(const Action&lt;F&gt;&amp; action) {
116      ExpectSpecProperty(last_clause_ &lt; kWillByDefault,
117                         &quot;.WillByDefault() must appear &quot;
118                         &quot;exactly once in an ON_CALL().&quot;);
119      last_clause_ = kWillByDefault;
120      ExpectSpecProperty(!action.IsDoDefault(),
121                         &quot;DoDefault() cannot be used in ON_CALL().&quot;);
122      action_ = action;
123      return *this;
124    }
125    bool Matches(const ArgumentTuple&amp; args) const {
126      return TupleMatches(matchers_, args) &amp;&amp; extra_matcher_.Matches(args);
127    }
128    const Action&lt;F&gt;&amp; GetAction() const {
129      AssertSpecProperty(last_clause_ == kWillByDefault,
130                         &quot;.WillByDefault() must appear exactly &quot;
131                         &quot;once in an ON_CALL().&quot;);
132      return action_;
133    }
134   private:
135    ArgumentMatcherTuple matchers_;
136    Matcher&lt;const ArgumentTuple&amp;&gt; extra_matcher_;
137    Action&lt;F&gt; action_;
138  };  
139  enum CallReaction {
140    kAllow,
141    kWarn,
142    kFail,
143    kDefault = kWarn  
144  };
145  }  
146  class GTEST_API_ Mock {
147   public:
148    static void AllowLeak(const void* mock_obj)
149        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
150    static bool VerifyAndClearExpectations(void* mock_obj)
151        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
152    static bool VerifyAndClear(void* mock_obj)
153        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
154   private:
155    friend class internal::UntypedFunctionMockerBase;
156    template &lt;typename F&gt;
157    friend class internal::FunctionMockerBase;
158    template &lt;typename M&gt;
159    friend class NiceMock;
160    template &lt;typename M&gt;
161    friend class NaggyMock;
162    template &lt;typename M&gt;
163    friend class StrictMock;
164    static void AllowUninterestingCalls(const void* mock_obj)
165        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
166    static void WarnUninterestingCalls(const void* mock_obj)
167        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
168    static void FailUninterestingCalls(const void* mock_obj)
169        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
170    static void UnregisterCallReaction(const void* mock_obj)
171        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
172    static internal::CallReaction GetReactionOnUninterestingCalls(
173        const void* mock_obj)
174            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
175    static bool VerifyAndClearExpectationsLocked(void* mock_obj)
176        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
177    static void ClearDefaultActionsLocked(void* mock_obj)
178        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
179    static void Register(
180        const void* mock_obj,
181        internal::UntypedFunctionMockerBase* mocker)
182            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
183    static void RegisterUseByOnCallOrExpectCall(
184        const void* mock_obj, const char* file, int line)
185            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
186    static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
187        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
188  };  
189  class GTEST_API_ Expectation {
190   public:
191    Expectation();
192    ~Expectation();
193    Expectation(internal::ExpectationBase&amp; exp);  
194    bool operator==(const Expectation&amp; rhs) const {
195      return expectation_base_ == rhs.expectation_base_;
196    }
197    bool operator!=(const Expectation&amp; rhs) const { return !(*this == rhs); }
198   private:
199    friend class ExpectationSet;
200    friend class Sequence;
201    friend class ::testing::internal::ExpectationBase;
202    friend class ::testing::internal::UntypedFunctionMockerBase;
203    template &lt;typename F&gt;
204    friend class ::testing::internal::FunctionMockerBase;
205    template &lt;typename F&gt;
206    friend class ::testing::internal::TypedExpectation;
207    class Less {
208     public:
209      bool operator()(const Expectation&amp; lhs, const Expectation&amp; rhs) const {
210        return lhs.expectation_base_.get() &lt; rhs.expectation_base_.get();
211      }
212    };
213    typedef ::std::set&lt;Expectation, Less&gt; Set;
214    Expectation(
215        const internal::linked_ptr&lt;internal::ExpectationBase&gt;&amp; expectation_base);
216    const internal::linked_ptr&lt;internal::ExpectationBase&gt;&amp;
217    expectation_base() const {
218      return expectation_base_;
219    }
220    internal::linked_ptr&lt;internal::ExpectationBase&gt; expectation_base_;
221  };
222  class ExpectationSet {
223   public:
224    typedef Expectation::Set::const_iterator const_iterator;
225    typedef Expectation::Set::value_type value_type;
226    ExpectationSet() {}
227    ExpectationSet(internal::ExpectationBase&amp; exp) {  
228      *this += Expectation(exp);
229    }
230    ExpectationSet(const Expectation&amp; e) {  
231      *this += e;
232    }
233    bool operator==(const ExpectationSet&amp; rhs) const {
234      return expectations_ == rhs.expectations_;
235    }
236    bool operator!=(const ExpectationSet&amp; rhs) const { return !(*this == rhs); }
237    ExpectationSet&amp; operator+=(const Expectation&amp; e) {
238      expectations_.insert(e);
239      return *this;
240    }
241    int size() const { return static_cast&lt;int&gt;(expectations_.size()); }
242    const_iterator begin() const { return expectations_.begin(); }
243    const_iterator end() const { return expectations_.end(); }
244   private:
245    Expectation::Set expectations_;
246  };
247  class GTEST_API_ Sequence {
248   public:
249    Sequence() : last_expectation_(new Expectation) {}
250    void AddExpectation(const Expectation&amp; expectation) const;
251   private:
252    internal::linked_ptr&lt;Expectation&gt; last_expectation_;
253  };  
254  class GTEST_API_ InSequence {
255   public:
256    InSequence();
257    ~InSequence();
258   private:
259    bool sequence_created_;
260    GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  
261  } GTEST_ATTRIBUTE_UNUSED_;
262  namespace internal {
263  GTEST_API_ extern ThreadLocal&lt;Sequence*&gt; g_gmock_implicit_sequence;
264  class GTEST_API_ ExpectationBase {
265   public:
266    ExpectationBase(const char* file, int line, const string&amp; source_text);
267    virtual ~ExpectationBase();
268    const char* file() const { return file_; }
269    int line() const { return line_; }
270    const char* source_text() const { return source_text_.c_str(); }
271    const Cardinality&amp; cardinality() const { return cardinality_; }
272    void DescribeLocationTo(::std::ostream* os) const {
273      *os &lt;&lt; FormatFileLocation(file(), line()) &lt;&lt; &quot; &quot;;
274    }
275    void DescribeCallCountTo(::std::ostream* os) const
276        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
277    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;
278   protected:
279    friend class ::testing::Expectation;
280    friend class UntypedFunctionMockerBase;
281    enum Clause {
282      kNone,
283      kWith,
284      kTimes,
285      kInSequence,
286      kAfter,
287      kWillOnce,
288      kWillRepeatedly,
289      kRetiresOnSaturation
290    };
291    typedef std::vector&lt;const void*&gt; UntypedActions;
292    virtual Expectation GetHandle() = 0;
293    void AssertSpecProperty(bool property, const string&amp; failure_message) const {
294      Assert(property, file_, line_, failure_message);
295    }
296    void ExpectSpecProperty(bool property, const string&amp; failure_message) const {
297      Expect(property, file_, line_, failure_message);
298    }
299    void SpecifyCardinality(const Cardinality&amp; cardinality);
300    bool cardinality_specified() const { return cardinality_specified_; }
301    void set_cardinality(const Cardinality&amp; a_cardinality) {
302      cardinality_ = a_cardinality;
303    }
304    void RetireAllPreRequisites()
305        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
306    bool is_retired() const
307        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
308      g_gmock_mutex.AssertHeld();
309      return retired_;
310    }
311    void Retire()
312        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
313      g_gmock_mutex.AssertHeld();
314      retired_ = true;
315    }
316    bool IsSatisfied() const
317        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
318      g_gmock_mutex.AssertHeld();
319      return cardinality().IsSatisfiedByCallCount(call_count_);
320    }
321    bool IsSaturated() const
322        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
323      g_gmock_mutex.AssertHeld();
324      return cardinality().IsSaturatedByCallCount(call_count_);
325    }
326    bool IsOverSaturated() const
327        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
328      g_gmock_mutex.AssertHeld();
329      return cardinality().IsOverSaturatedByCallCount(call_count_);
330    }
331    bool AllPrerequisitesAreSatisfied() const
332        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
333    void FindUnsatisfiedPrerequisites(ExpectationSet* result) const
334        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
335    int call_count() const
336        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
337      g_gmock_mutex.AssertHeld();
338      return call_count_;
339    }
340    void IncrementCallCount()
341        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
342      g_gmock_mutex.AssertHeld();
343      call_count_++;
344    }
345    void CheckActionCountIfNotDone() const
346        GTEST_LOCK_EXCLUDED_(mutex_);
347    friend class ::testing::Sequence;
348    friend class ::testing::internal::ExpectationTester;
349    template &lt;typename Function&gt;
350    friend class TypedExpectation;
351    void UntypedTimes(const Cardinality&amp; a_cardinality);
352    const char* file_;          
353    int line_;                  
354    const string source_text_;  
355    bool cardinality_specified_;
356    Cardinality cardinality_;            
357    ExpectationSet immediate_prerequisites_;
358    int call_count_;  
359    bool retired_;    
360    UntypedActions untyped_actions_;
361    bool extra_matcher_specified_;
362    bool repeated_action_specified_;  
363    bool retires_on_saturation_;
364    Clause last_clause_;
365    mutable bool action_count_checked_;  
366    mutable Mutex mutex_;  
367    GTEST_DISALLOW_ASSIGN_(ExpectationBase);
368  };  
369  template &lt;typename F&gt;
370  class TypedExpectation : public ExpectationBase {
371   public:
372    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
373    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
374    typedef typename Function&lt;F&gt;::Result Result;
375    TypedExpectation(FunctionMockerBase&lt;F&gt;* owner,
376                     const char* a_file, int a_line, const string&amp; a_source_text,
377                     const ArgumentMatcherTuple&amp; m)
378        : ExpectationBase(a_file, a_line, a_source_text),
379          owner_(owner),
380          matchers_(m),
381          extra_matcher_(A&lt;const ArgumentTuple&amp;&gt;()),
382          repeated_action_(DoDefault()) {}
383    virtual ~TypedExpectation() {
384      CheckActionCountIfNotDone();
385      for (UntypedActions::const_iterator it = untyped_actions_.begin();
386           it != untyped_actions_.end(); ++it) {
387        delete static_cast&lt;const Action&lt;F&gt;*&gt;(*it);
388      }
389    }
390    TypedExpectation&amp; With(const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m) {
391      if (last_clause_ == kWith) {
392        ExpectSpecProperty(false,
393                           &quot;.With() cannot appear &quot;
394                           &quot;more than once in an EXPECT_CALL().&quot;);
395      } else {
396        ExpectSpecProperty(last_clause_ &lt; kWith,
397                           &quot;.With() must be the first &quot;
398                           &quot;clause in an EXPECT_CALL().&quot;);
399      }
400      last_clause_ = kWith;
401      extra_matcher_ = m;
402      extra_matcher_specified_ = true;
403      return *this;
404    }
405    TypedExpectation&amp; Times(const Cardinality&amp; a_cardinality) {
406      ExpectationBase::UntypedTimes(a_cardinality);
407      return *this;
408    }
409    TypedExpectation&amp; Times(int n) {
410      return Times(Exactly(n));
411    }
412    TypedExpectation&amp; InSequence(const Sequence&amp; s) {
413      ExpectSpecProperty(last_clause_ &lt;= kInSequence,
414                         &quot;.InSequence() cannot appear after .After(),&quot;
415                         &quot; .WillOnce(), .WillRepeatedly(), or &quot;
416                         &quot;.RetiresOnSaturation().&quot;);
417      last_clause_ = kInSequence;
418      s.AddExpectation(GetHandle());
419      return *this;
420    }
421    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2) {
422      return InSequence(s1).InSequence(s2);
423    }
424    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
425                                 const Sequence&amp; s3) {
426      return InSequence(s1, s2).InSequence(s3);
427    }
428    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
429                                 const Sequence&amp; s3, const Sequence&amp; s4) {
430      return InSequence(s1, s2, s3).InSequence(s4);
431    }
432    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
433                                 const Sequence&amp; s3, const Sequence&amp; s4,
434                                 const Sequence&amp; s5) {
435      return InSequence(s1, s2, s3, s4).InSequence(s5);
436    }
437    TypedExpectation&amp; After(const ExpectationSet&amp; s) {
438      ExpectSpecProperty(last_clause_ &lt;= kAfter,
439                         &quot;.After() cannot appear after .WillOnce(),&quot;
440                         &quot; .WillRepeatedly(), or &quot;
441                         &quot;.RetiresOnSaturation().&quot;);
442      last_clause_ = kAfter;
443      for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {
444        immediate_prerequisites_ += *it;
445      }
446      return *this;
447    }
448    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2) {
449      return After(s1).After(s2);
450    }
451    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
452                            const ExpectationSet&amp; s3) {
453      return After(s1, s2).After(s3);
454    }
455    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
456                            const ExpectationSet&amp; s3, const ExpectationSet&amp; s4) {
457      return After(s1, s2, s3).After(s4);
458    }
459    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
460                            const ExpectationSet&amp; s3, const ExpectationSet&amp; s4,
461                            const ExpectationSet&amp; s5) {
462      return After(s1, s2, s3, s4).After(s5);
463    }
464    TypedExpectation&amp; WillOnce(const Action&lt;F&gt;&amp; action) {
465      ExpectSpecProperty(last_clause_ &lt;= kWillOnce,
466                         &quot;.WillOnce() cannot appear after &quot;
467                         &quot;.WillRepeatedly() or .RetiresOnSaturation().&quot;);
468      last_clause_ = kWillOnce;
469      untyped_actions_.push_back(new Action&lt;F&gt;(action));
470      if (!cardinality_specified()) {
471        set_cardinality(Exactly(static_cast&lt;int&gt;(untyped_actions_.size())));
472      }
473      return *this;
474    }
475    TypedExpectation&amp; WillRepeatedly(const Action&lt;F&gt;&amp; action) {
476      if (last_clause_ == kWillRepeatedly) {
477        ExpectSpecProperty(false,
478                           &quot;.WillRepeatedly() cannot appear &quot;
479                           &quot;more than once in an EXPECT_CALL().&quot;);
480      } else {
481        ExpectSpecProperty(last_clause_ &lt; kWillRepeatedly,
482                           &quot;.WillRepeatedly() cannot appear &quot;
483                           &quot;after .RetiresOnSaturation().&quot;);
484      }
485      last_clause_ = kWillRepeatedly;
486      repeated_action_specified_ = true;
487      repeated_action_ = action;
488      if (!cardinality_specified()) {
489        set_cardinality(AtLeast(static_cast&lt;int&gt;(untyped_actions_.size())));
490      }
491      CheckActionCountIfNotDone();
492      return *this;
493    }
494    TypedExpectation&amp; RetiresOnSaturation() {
495      ExpectSpecProperty(last_clause_ &lt; kRetiresOnSaturation,
496                         &quot;.RetiresOnSaturation() cannot appear &quot;
497                         &quot;more than once.&quot;);
498      last_clause_ = kRetiresOnSaturation;
499      retires_on_saturation_ = true;
500      CheckActionCountIfNotDone();
501      return *this;
502    }
503    const ArgumentMatcherTuple&amp; matchers() const {
504      return matchers_;
505    }
506    const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; extra_matcher() const {
507      return extra_matcher_;
508    }
509    const Action&lt;F&gt;&amp; repeated_action() const { return repeated_action_; }
510    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {
511      if (extra_matcher_specified_) {
512        *os &lt;&lt; &quot;    Expected args: &quot;;
513        extra_matcher_.DescribeTo(os);
514        *os &lt;&lt; &quot;\n&quot;;
515      }
516    }
517   private:
518    template &lt;typename Function&gt;
519    friend class FunctionMockerBase;
520    virtual Expectation GetHandle() {
521      return owner_-&gt;GetHandleOf(this);
522    }
<span onclick='openModal()' class='match'>523    bool Matches(const ArgumentTuple&amp; args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) &amp;&amp; extra_matcher_.Matches(args);
</span>527    }
528    bool ShouldHandleArguments(const ArgumentTuple&amp; args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
532      return !is_retired() &amp;&amp; AllPrerequisitesAreSatisfied() &amp;&amp; Matches(args);
533    }
534    void ExplainMatchResultTo(
535        const ArgumentTuple&amp; args,
536        ::std::ostream* os) const
537            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
538      g_gmock_mutex.AssertHeld();
539      if (is_retired()) {
540        *os &lt;&lt; &quot;         Expected: the expectation is active\n&quot;
541            &lt;&lt; &quot;           Actual: it is retired\n&quot;;
542      } else if (!Matches(args)) {
543        if (!TupleMatches(matchers_, args)) {
544          ExplainMatchFailureTupleTo(matchers_, args, os);
545        }
546        StringMatchResultListener listener;
547        if (!extra_matcher_.MatchAndExplain(args, &amp;listener)) {
548          *os &lt;&lt; &quot;    Expected args: &quot;;
549          extra_matcher_.DescribeTo(os);
550          *os &lt;&lt; &quot;\n           Actual: don&#x27;t match&quot;;
551          internal::PrintIfNotEmpty(listener.str(), os);
552          *os &lt;&lt; &quot;\n&quot;;
553        }
554      } else if (!AllPrerequisitesAreSatisfied()) {
555        *os &lt;&lt; &quot;         Expected: all pre-requisites are satisfied\n&quot;
556            &lt;&lt; &quot;           Actual: the following immediate pre-requisites &quot;
557            &lt;&lt; &quot;are not satisfied:\n&quot;;
558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&amp;unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
562             it != unsatisfied_prereqs.end(); ++it) {
563          it-&gt;expectation_base()-&gt;DescribeLocationTo(os);
564          *os &lt;&lt; &quot;pre-requisite #&quot; &lt;&lt; i++ &lt;&lt; &quot;\n&quot;;
565        }
566        *os &lt;&lt; &quot;                   (end of pre-requisites)\n&quot;;
567      } else {
568        *os &lt;&lt; &quot;The call matches the expectation.\n&quot;;
569      }
570    }
571    const Action&lt;F&gt;&amp; GetCurrentAction(
572        const FunctionMockerBase&lt;F&gt;* mocker,
573        const ArgumentTuple&amp; args) const
574            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
575      g_gmock_mutex.AssertHeld();
576      const int count = call_count();
577      Assert(count &gt;= 1, __FILE__, __LINE__,
578             &quot;call_count() is &lt;= 0 when GetCurrentAction() is &quot;
579             &quot;called - this should never happen.&quot;);
580      const int action_count = static_cast&lt;int&gt;(untyped_actions_.size());
581      if (action_count &gt; 0 &amp;&amp; !repeated_action_specified_ &amp;&amp;
582          count &gt; action_count) {
583        ::std::stringstream ss;
584        DescribeLocationTo(&amp;ss);
585        ss &lt;&lt; &quot;Actions ran out in &quot; &lt;&lt; source_text() &lt;&lt; &quot;...\n&quot;
586           &lt;&lt; &quot;Called &quot; &lt;&lt; count &lt;&lt; &quot; times, but only &quot;
587           &lt;&lt; action_count &lt;&lt; &quot; WillOnce()&quot;
588           &lt;&lt; (action_count == 1 ? &quot; is&quot; : &quot;s are&quot;) &lt;&lt; &quot; specified - &quot;;
589        mocker-&gt;DescribeDefaultActionTo(args, &amp;ss);
590        Log(kWarning, ss.str(), 1);
591      }
592      return count &lt;= action_count ?
593          *static_cast&lt;const Action&lt;F&gt;*&gt;(untyped_actions_[count - 1]) :
594          repeated_action();
595    }
596    const Action&lt;F&gt;* GetActionForArguments(
597        const FunctionMockerBase&lt;F&gt;* mocker,
598        const ArgumentTuple&amp; args,
599        ::std::ostream* what,
600        ::std::ostream* why)
601            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
602      g_gmock_mutex.AssertHeld();
603      if (IsSaturated()) {
604        IncrementCallCount();
605        *what &lt;&lt; &quot;Mock function called more times than expected - &quot;;
606        mocker-&gt;DescribeDefaultActionTo(args, what);
607        DescribeCallCountTo(why);
608        return NULL;
609      }
610      IncrementCallCount();
611      RetireAllPreRequisites();
612      if (retires_on_saturation_ &amp;&amp; IsSaturated()) {
613        Retire();
614      }
615      *what &lt;&lt; &quot;Mock function call matches &quot; &lt;&lt; source_text() &lt;&lt;&quot;...\n&quot;;
616      return &amp;(GetCurrentAction(mocker, args));
617    }
618    FunctionMockerBase&lt;F&gt;* const owner_;
619    ArgumentMatcherTuple matchers_;
620    Matcher&lt;const ArgumentTuple&amp;&gt; extra_matcher_;
621    Action&lt;F&gt; repeated_action_;
622    GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);
623  };  
624  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
625                                  const char* file, int line,
626                                  const string&amp; message);
627  template &lt;typename F&gt;
628  class MockSpec {
629   public:
630    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
631    typedef typename internal::Function&lt;F&gt;::ArgumentMatcherTuple
632        ArgumentMatcherTuple;
633    explicit MockSpec(internal::FunctionMockerBase&lt;F&gt;* function_mocker)
634        : function_mocker_(function_mocker) {}
635    internal::OnCallSpec&lt;F&gt;&amp; InternalDefaultActionSetAt(
636        const char* file, int line, const char* obj, const char* call) {
637      LogWithLocation(internal::kInfo, file, line,
638          string(&quot;ON_CALL(&quot;) + obj + &quot;, &quot; + call + &quot;) invoked&quot;);
639      return function_mocker_-&gt;AddNewOnCallSpec(file, line, matchers_);
640    }
641    internal::TypedExpectation&lt;F&gt;&amp; InternalExpectedAt(
642        const char* file, int line, const char* obj, const char* call) {
643      const string source_text(string(&quot;EXPECT_CALL(&quot;) + obj + &quot;, &quot; + call + &quot;)&quot;);
644      LogWithLocation(internal::kInfo, file, line, source_text + &quot; invoked&quot;);
645      return function_mocker_-&gt;AddNewExpectation(
646          file, line, source_text, matchers_);
647    }
648   private:
649    template &lt;typename Function&gt;
650    friend class internal::FunctionMocker;
651    void SetMatchers(const ArgumentMatcherTuple&amp; matchers) {
652      matchers_ = matchers;
653    }
654    internal::FunctionMockerBase&lt;F&gt;* const function_mocker_;
655    ArgumentMatcherTuple matchers_;
656    GTEST_DISALLOW_ASSIGN_(MockSpec);
657  };  
658  #ifdef _MSC_VER
659  # pragma warning(push)          
660  # pragma warning(disable:4355)  
661  #endif  
662  class UntypedActionResultHolderBase {
663   public:
664    virtual ~UntypedActionResultHolderBase() {}
665    virtual void PrintAsActionResult(::std::ostream* os) const = 0;
666  };
667  template &lt;typename T&gt;
668  class ActionResultHolder : public UntypedActionResultHolderBase {
669   public:
670    explicit ActionResultHolder(T a_value) : value_(a_value) {}
671    T GetValueAndDelete() const {
672      T retval(value_);
673      delete this;
674      return retval;
675    }
676    virtual void PrintAsActionResult(::std::ostream* os) const {
677      *os &lt;&lt; &quot;\n          Returns: &quot;;
678      UniversalPrinter&lt;T&gt;::Print(value_, os);
679    }
680    template &lt;typename F&gt;
681    static ActionResultHolder* PerformDefaultAction(
682        const FunctionMockerBase&lt;F&gt;* func_mocker,
683        const typename Function&lt;F&gt;::ArgumentTuple&amp; args,
684        const string&amp; call_description) {
685      return new ActionResultHolder(
686          func_mocker-&gt;PerformDefaultAction(args, call_description));
687    }
688    template &lt;typename F&gt;
689    static ActionResultHolder*
690    PerformAction(const Action&lt;F&gt;&amp; action,
691                  const typename Function&lt;F&gt;::ArgumentTuple&amp; args) {
692      return new ActionResultHolder(action.Perform(args));
693    }
694   private:
695    T value_;
696    GTEST_DISALLOW_ASSIGN_(ActionResultHolder);
697  };
698  template &lt;&gt;
699  class ActionResultHolder&lt;void&gt; : public UntypedActionResultHolderBase {
700   public:
701    void GetValueAndDelete() const { delete this; }
702    virtual void PrintAsActionResult(::std::ostream* &amp;bsol;* os */) const {}
703    template &lt;typename F&gt;
704    static ActionResultHolder* PerformDefaultAction(
705        const FunctionMockerBase&lt;F&gt;* func_mocker,
706        const typename Function&lt;F&gt;::ArgumentTuple&amp; args,
707        const string&amp; call_description) {
708      func_mocker-&gt;PerformDefaultAction(args, call_description);
709      return NULL;
710    }
711    template &lt;typename F&gt;
712    static ActionResultHolder* PerformAction(
713        const Action&lt;F&gt;&amp; action,
714        const typename Function&lt;F&gt;::ArgumentTuple&amp; args) {
715      action.Perform(args);
716      return NULL;
717    }
718  };
719  template &lt;typename F&gt;
720  class FunctionMockerBase : public UntypedFunctionMockerBase {
721   public:
722    typedef typename Function&lt;F&gt;::Result Result;
723    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
724    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
725    FunctionMockerBase() : current_spec_(this) {}
726    virtual ~FunctionMockerBase()
727          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
728      MutexLock l(&amp;g_gmock_mutex);
729      VerifyAndClearExpectationsLocked();
730      Mock::UnregisterLocked(this);
731      ClearDefaultActionsLocked();
732    }
733    const OnCallSpec&lt;F&gt;* FindOnCallSpec(
734        const ArgumentTuple&amp; args) const {
735      for (UntypedOnCallSpecs::const_reverse_iterator it
736               = untyped_on_call_specs_.rbegin();
737           it != untyped_on_call_specs_.rend(); ++it) {
738        const OnCallSpec&lt;F&gt;* spec = static_cast&lt;const OnCallSpec&lt;F&gt;*&gt;(*it);
739        if (spec-&gt;Matches(args))
740          return spec;
741      }
742      return NULL;
743    }
744    Result PerformDefaultAction(const ArgumentTuple&amp; args,
745                                const string&amp; call_description) const {
746      const OnCallSpec&lt;F&gt;* const spec =
747          this-&gt;FindOnCallSpec(args);
748      if (spec != NULL) {
749        return spec-&gt;GetAction().Perform(args);
750      }
751      const string message = call_description +
752          &quot;\n    The mock function has no default action &quot;
753          &quot;set, and its return type has no default value set.&quot;;
754  #if GTEST_HAS_EXCEPTIONS
755      if (!DefaultValue&lt;Result&gt;::Exists()) {
756        throw std::runtime_error(message);
757      }
758  #else
759      Assert(DefaultValue&lt;Result&gt;::Exists(), &quot;&quot;, -1, message);
760  #endif
761      return DefaultValue&lt;Result&gt;::Get();
762    }
763    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
764        const void* untyped_args,  
765        const string&amp; call_description) const {
766      const ArgumentTuple&amp; args =
767          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
768      return ResultHolder::PerformDefaultAction(this, args, call_description);
769    }
770    virtual UntypedActionResultHolderBase* UntypedPerformAction(
771        const void* untyped_action, const void* untyped_args) const {
772      const Action&lt;F&gt; action = *static_cast&lt;const Action&lt;F&gt;*&gt;(untyped_action);
773      const ArgumentTuple&amp; args =
774          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
775      return ResultHolder::PerformAction(action, args);
776    }
777    virtual void ClearDefaultActionsLocked()
778        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
779      g_gmock_mutex.AssertHeld();
780      UntypedOnCallSpecs specs_to_delete;
781      untyped_on_call_specs_.swap(specs_to_delete);
782      g_gmock_mutex.Unlock();
783      for (UntypedOnCallSpecs::const_iterator it =
784               specs_to_delete.begin();
785           it != specs_to_delete.end(); ++it) {
786        delete static_cast&lt;const OnCallSpec&lt;F&gt;*&gt;(*it);
787      }
788      g_gmock_mutex.Lock();
789    }
790   protected:
791    template &lt;typename Function&gt;
792    friend class MockSpec;
793    typedef ActionResultHolder&lt;Result&gt; ResultHolder;
794    Result InvokeWith(const ArgumentTuple&amp; args)
795          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
796      return static_cast&lt;const ResultHolder*&gt;(
797          this-&gt;UntypedInvokeWith(&amp;args))-&gt;GetValueAndDelete();
798    }
799    OnCallSpec&lt;F&gt;&amp; AddNewOnCallSpec(
800        const char* file, int line,
801        const ArgumentMatcherTuple&amp; m)
802            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
803      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
804      OnCallSpec&lt;F&gt;* const on_call_spec = new OnCallSpec&lt;F&gt;(file, line, m);
805      untyped_on_call_specs_.push_back(on_call_spec);
806      return *on_call_spec;
807    }
808    TypedExpectation&lt;F&gt;&amp; AddNewExpectation(
809        const char* file,
810        int line,
811        const string&amp; source_text,
812        const ArgumentMatcherTuple&amp; m)
813            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
814      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
815      TypedExpectation&lt;F&gt;* const expectation =
816          new TypedExpectation&lt;F&gt;(this, file, line, source_text, m);
817      const linked_ptr&lt;ExpectationBase&gt; untyped_expectation(expectation);
818      untyped_expectations_.push_back(untyped_expectation);
819      Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();
820      if (implicit_sequence != NULL) {
821        implicit_sequence-&gt;AddExpectation(Expectation(untyped_expectation));
822      }
823      return *expectation;
824    }
825    MockSpec&lt;F&gt;&amp; current_spec() { return current_spec_; }
826   private:
827    template &lt;typename Func&gt; friend class TypedExpectation;
828    void DescribeDefaultActionTo(const ArgumentTuple&amp; args,
829                                 ::std::ostream* os) const {
830      const OnCallSpec&lt;F&gt;* const spec = FindOnCallSpec(args);
831      if (spec == NULL) {
832        *os &lt;&lt; (internal::type_equals&lt;Result, void&gt;::value ?
833                &quot;returning directly.\n&quot; :
834                &quot;returning default value.\n&quot;);
835      } else {
836        *os &lt;&lt; &quot;taking default action specified at:\n&quot;
837            &lt;&lt; FormatFileLocation(spec-&gt;file(), spec-&gt;line()) &lt;&lt; &quot;\n&quot;;
838      }
839    }
840    virtual void UntypedDescribeUninterestingCall(
841        const void* untyped_args,
842        ::std::ostream* os) const
843            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
844      const ArgumentTuple&amp; args =
845          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
846      *os &lt;&lt; &quot;Uninteresting mock function call - &quot;;
847      DescribeDefaultActionTo(args, os);
848      *os &lt;&lt; &quot;    Function call: &quot; &lt;&lt; Name();
849      UniversalPrint(args, os);
850    }
851    virtual const ExpectationBase* UntypedFindMatchingExpectation(
852        const void* untyped_args,
853        const void** untyped_action, bool* is_excessive,
854        ::std::ostream* what, ::std::ostream* why)
855            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
856      const ArgumentTuple&amp; args =
857          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
858      MutexLock l(&amp;g_gmock_mutex);
859      TypedExpectation&lt;F&gt;* exp = this-&gt;FindMatchingExpectationLocked(args);
860      if (exp == NULL) {  
861        this-&gt;FormatUnexpectedCallMessageLocked(args, what, why);
862        return NULL;
863      }
864      *is_excessive = exp-&gt;IsSaturated();
865      const Action&lt;F&gt;* action = exp-&gt;GetActionForArguments(this, args, what, why);
866      if (action != NULL &amp;&amp; action-&gt;IsDoDefault())
867        action = NULL;  
868      *untyped_action = action;
869      return exp;
870    }
871    virtual void UntypedPrintArgs(const void* untyped_args,
872                                  ::std::ostream* os) const {
873      const ArgumentTuple&amp; args =
874          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
875      UniversalPrint(args, os);
876    }
877    TypedExpectation&lt;F&gt;* FindMatchingExpectationLocked(
878        const ArgumentTuple&amp; args) const
879            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
880      g_gmock_mutex.AssertHeld();
881      for (typename UntypedExpectations::const_reverse_iterator it =
882               untyped_expectations_.rbegin();
883           it != untyped_expectations_.rend(); ++it) {
884        TypedExpectation&lt;F&gt;* const exp =
885            static_cast&lt;TypedExpectation&lt;F&gt;*&gt;(it-&gt;get());
886        if (exp-&gt;ShouldHandleArguments(args)) {
887          return exp;
888        }
889      }
890      return NULL;
891    }
892    void FormatUnexpectedCallMessageLocked(
893        const ArgumentTuple&amp; args,
894        ::std::ostream* os,
895        ::std::ostream* why) const
896            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
897      g_gmock_mutex.AssertHeld();
898      *os &lt;&lt; &quot;\nUnexpected mock function call - &quot;;
899      DescribeDefaultActionTo(args, os);
900      PrintTriedExpectationsLocked(args, why);
901    }
902    void PrintTriedExpectationsLocked(
903        const ArgumentTuple&amp; args,
904        ::std::ostream* why) const
905            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
906      g_gmock_mutex.AssertHeld();
907      const int count = static_cast&lt;int&gt;(untyped_expectations_.size());
908      *why &lt;&lt; &quot;Google Mock tried the following &quot; &lt;&lt; count &lt;&lt; &quot; &quot;
909           &lt;&lt; (count == 1 ? &quot;expectation, but it didn&#x27;t match&quot; :
910               &quot;expectations, but none matched&quot;)
911           &lt;&lt; &quot;:\n&quot;;
912      for (int i = 0; i &lt; count; i++) {
913        TypedExpectation&lt;F&gt;* const expectation =
914            static_cast&lt;TypedExpectation&lt;F&gt;*&gt;(untyped_expectations_[i].get());
915        *why &lt;&lt; &quot;\n&quot;;
916        expectation-&gt;DescribeLocationTo(why);
917        if (count &gt; 1) {
918          *why &lt;&lt; &quot;tried expectation #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot;;
919        }
920        *why &lt;&lt; expectation-&gt;source_text() &lt;&lt; &quot;...\n&quot;;
921        expectation-&gt;ExplainMatchResultTo(args, why);
922        expectation-&gt;DescribeCallCountTo(why);
923      }
924    }
925    MockSpec&lt;F&gt; current_spec_;
926    GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);
927  };  
928  #ifdef _MSC_VER
929  # pragma warning(pop)  
930  #endif  
931  void ReportUninterestingCall(CallReaction reaction, const string&amp; msg);
932  }  
933  using internal::MockSpec;
934  template &lt;typename T&gt;
935  inline const T&amp; Const(const T&amp; x) { return x; }
936  inline Expectation::Expectation(internal::ExpectationBase&amp; exp)  
937      : expectation_base_(exp.GetHandle().expectation_base()) {}
938  }  
939  #define GMOCK_ON_CALL_IMPL_(obj, call) \
940      ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \
941                                                      #obj, #call)
942  #define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)
943  #define GMOCK_EXPECT_CALL_IMPL_(obj, call) \
944      ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)
945  #define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)
946  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</h3>
            <pre><code>1  #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
2  #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
3  #include &lt;map&gt;
4  #include &lt;set&gt;
5  #include &lt;sstream&gt;
6  #include &lt;string&gt;
7  #include &lt;vector&gt;
8  #if GTEST_HAS_EXCEPTIONS
9  # include &lt;stdexcept&gt;  
10  #endif
11  #include &quot;gmock/gmock-actions.h&quot;
12  #include &quot;gmock/gmock-cardinalities.h&quot;
13  #include &quot;gmock/gmock-matchers.h&quot;
14  #include &quot;gmock/internal/gmock-internal-utils.h&quot;
15  #include &quot;gmock/internal/gmock-port.h&quot;
16  #include &quot;gtest/gtest.h&quot;
17  namespace testing {
18  class Expectation;
19  class ExpectationSet;
20  namespace internal {
21  template &lt;typename F&gt; class FunctionMocker;
22  class ExpectationBase;
23  template &lt;typename F&gt; class TypedExpectation;
24  class ExpectationTester;
25  template &lt;typename F&gt; class FunctionMockerBase;
26  GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
27  class UntypedActionResultHolderBase;
28  class GTEST_API_ UntypedFunctionMockerBase {
29   public:
30    UntypedFunctionMockerBase();
31    virtual ~UntypedFunctionMockerBase();
32    bool VerifyAndClearExpectationsLocked()
33        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
34    virtual void ClearDefaultActionsLocked()
35        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;
36    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
37        const void* untyped_args,
38        const string&amp; call_description) const = 0;
39    virtual UntypedActionResultHolderBase* UntypedPerformAction(
40        const void* untyped_action,
41        const void* untyped_args) const = 0;
42    virtual void UntypedDescribeUninterestingCall(
43        const void* untyped_args,
44        ::std::ostream* os) const
45            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
46    virtual const ExpectationBase* UntypedFindMatchingExpectation(
47        const void* untyped_args,
48        const void** untyped_action, bool* is_excessive,
49        ::std::ostream* what, ::std::ostream* why)
50            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;
51    virtual void UntypedPrintArgs(const void* untyped_args,
52                                  ::std::ostream* os) const = 0;
53    void RegisterOwner(const void* mock_obj)
54        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
55    void SetOwnerAndName(const void* mock_obj, const char* name)
56        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
57    const void* MockObject() const
58        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
59    const char* Name() const
60        GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
61    const UntypedActionResultHolderBase* UntypedInvokeWith(
62        const void* untyped_args)
63            GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
64   protected:
65    typedef std::vector&lt;const void*&gt; UntypedOnCallSpecs;
66    typedef std::vector&lt;internal::linked_ptr&lt;ExpectationBase&gt; &gt;
67    UntypedExpectations;
68    Expectation GetHandleOf(ExpectationBase* exp);
69    const void* mock_obj_;  
70    const char* name_;  
71    UntypedOnCallSpecs untyped_on_call_specs_;
72    UntypedExpectations untyped_expectations_;
73  };  
74  class UntypedOnCallSpecBase {
75   public:
76    UntypedOnCallSpecBase(const char* a_file, int a_line)
77        : file_(a_file), line_(a_line), last_clause_(kNone) {}
78    const char* file() const { return file_; }
79    int line() const { return line_; }
80   protected:
81    enum Clause {
82      kNone,
83      kWith,
84      kWillByDefault
85    };
86    void AssertSpecProperty(bool property, const string&amp; failure_message) const {
87      Assert(property, file_, line_, failure_message);
88    }
89    void ExpectSpecProperty(bool property, const string&amp; failure_message) const {
90      Expect(property, file_, line_, failure_message);
91    }
92    const char* file_;
93    int line_;
94    Clause last_clause_;
95  };  
96  template &lt;typename F&gt;
97  class OnCallSpec : public UntypedOnCallSpecBase {
98   public:
99    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
100    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
101    OnCallSpec(const char* a_file, int a_line,
102               const ArgumentMatcherTuple&amp; matchers)
103        : UntypedOnCallSpecBase(a_file, a_line),
104          matchers_(matchers),
105          extra_matcher_(A&lt;const ArgumentTuple&amp;&gt;()) {
106    }
107    OnCallSpec&amp; With(const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m) {
108      ExpectSpecProperty(last_clause_ &lt; kWith,
109                         &quot;.With() cannot appear &quot;
110                         &quot;more than once in an ON_CALL().&quot;);
111      last_clause_ = kWith;
112      extra_matcher_ = m;
113      return *this;
114    }
115    OnCallSpec&amp; WillByDefault(const Action&lt;F&gt;&amp; action) {
116      ExpectSpecProperty(last_clause_ &lt; kWillByDefault,
117                         &quot;.WillByDefault() must appear &quot;
118                         &quot;exactly once in an ON_CALL().&quot;);
119      last_clause_ = kWillByDefault;
120      ExpectSpecProperty(!action.IsDoDefault(),
121                         &quot;DoDefault() cannot be used in ON_CALL().&quot;);
122      action_ = action;
123      return *this;
124    }
125    bool Matches(const ArgumentTuple&amp; args) const {
126      return TupleMatches(matchers_, args) &amp;&amp; extra_matcher_.Matches(args);
127    }
128    const Action&lt;F&gt;&amp; GetAction() const {
129      AssertSpecProperty(last_clause_ == kWillByDefault,
130                         &quot;.WillByDefault() must appear exactly &quot;
131                         &quot;once in an ON_CALL().&quot;);
132      return action_;
133    }
134   private:
135    ArgumentMatcherTuple matchers_;
136    Matcher&lt;const ArgumentTuple&amp;&gt; extra_matcher_;
137    Action&lt;F&gt; action_;
138  };  
139  enum CallReaction {
140    kAllow,
141    kWarn,
142    kFail,
143    kDefault = kWarn  
144  };
145  }  
146  class GTEST_API_ Mock {
147   public:
148    static void AllowLeak(const void* mock_obj)
149        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
150    static bool VerifyAndClearExpectations(void* mock_obj)
151        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
152    static bool VerifyAndClear(void* mock_obj)
153        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
154   private:
155    friend class internal::UntypedFunctionMockerBase;
156    template &lt;typename F&gt;
157    friend class internal::FunctionMockerBase;
158    template &lt;typename M&gt;
159    friend class NiceMock;
160    template &lt;typename M&gt;
161    friend class NaggyMock;
162    template &lt;typename M&gt;
163    friend class StrictMock;
164    static void AllowUninterestingCalls(const void* mock_obj)
165        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
166    static void WarnUninterestingCalls(const void* mock_obj)
167        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
168    static void FailUninterestingCalls(const void* mock_obj)
169        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
170    static void UnregisterCallReaction(const void* mock_obj)
171        GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
172    static internal::CallReaction GetReactionOnUninterestingCalls(
173        const void* mock_obj)
174            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
175    static bool VerifyAndClearExpectationsLocked(void* mock_obj)
176        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
177    static void ClearDefaultActionsLocked(void* mock_obj)
178        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
179    static void Register(
180        const void* mock_obj,
181        internal::UntypedFunctionMockerBase* mocker)
182            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
183    static void RegisterUseByOnCallOrExpectCall(
184        const void* mock_obj, const char* file, int line)
185            GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
186    static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)
187        GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);
188  };  
189  class GTEST_API_ Expectation {
190   public:
191    Expectation();
192    ~Expectation();
193    Expectation(internal::ExpectationBase&amp; exp);  
194    bool operator==(const Expectation&amp; rhs) const {
195      return expectation_base_ == rhs.expectation_base_;
196    }
197    bool operator!=(const Expectation&amp; rhs) const { return !(*this == rhs); }
198   private:
199    friend class ExpectationSet;
200    friend class Sequence;
201    friend class ::testing::internal::ExpectationBase;
202    friend class ::testing::internal::UntypedFunctionMockerBase;
203    template &lt;typename F&gt;
204    friend class ::testing::internal::FunctionMockerBase;
205    template &lt;typename F&gt;
206    friend class ::testing::internal::TypedExpectation;
207    class Less {
208     public:
209      bool operator()(const Expectation&amp; lhs, const Expectation&amp; rhs) const {
210        return lhs.expectation_base_.get() &lt; rhs.expectation_base_.get();
211      }
212    };
213    typedef ::std::set&lt;Expectation, Less&gt; Set;
214    Expectation(
215        const internal::linked_ptr&lt;internal::ExpectationBase&gt;&amp; expectation_base);
216    const internal::linked_ptr&lt;internal::ExpectationBase&gt;&amp;
217    expectation_base() const {
218      return expectation_base_;
219    }
220    internal::linked_ptr&lt;internal::ExpectationBase&gt; expectation_base_;
221  };
222  class ExpectationSet {
223   public:
224    typedef Expectation::Set::const_iterator const_iterator;
225    typedef Expectation::Set::value_type value_type;
226    ExpectationSet() {}
227    ExpectationSet(internal::ExpectationBase&amp; exp) {  
228      *this += Expectation(exp);
229    }
230    ExpectationSet(const Expectation&amp; e) {  
231      *this += e;
232    }
233    bool operator==(const ExpectationSet&amp; rhs) const {
234      return expectations_ == rhs.expectations_;
235    }
236    bool operator!=(const ExpectationSet&amp; rhs) const { return !(*this == rhs); }
237    ExpectationSet&amp; operator+=(const Expectation&amp; e) {
238      expectations_.insert(e);
239      return *this;
240    }
241    int size() const { return static_cast&lt;int&gt;(expectations_.size()); }
242    const_iterator begin() const { return expectations_.begin(); }
243    const_iterator end() const { return expectations_.end(); }
244   private:
245    Expectation::Set expectations_;
246  };
247  class GTEST_API_ Sequence {
248   public:
249    Sequence() : last_expectation_(new Expectation) {}
250    void AddExpectation(const Expectation&amp; expectation) const;
251   private:
252    internal::linked_ptr&lt;Expectation&gt; last_expectation_;
253  };  
254  class GTEST_API_ InSequence {
255   public:
256    InSequence();
257    ~InSequence();
258   private:
259    bool sequence_created_;
260    GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  
261  } GTEST_ATTRIBUTE_UNUSED_;
262  namespace internal {
263  GTEST_API_ extern ThreadLocal&lt;Sequence*&gt; g_gmock_implicit_sequence;
264  class GTEST_API_ ExpectationBase {
265   public:
266    ExpectationBase(const char* file, int line, const string&amp; source_text);
267    virtual ~ExpectationBase();
268    const char* file() const { return file_; }
269    int line() const { return line_; }
270    const char* source_text() const { return source_text_.c_str(); }
271    const Cardinality&amp; cardinality() const { return cardinality_; }
272    void DescribeLocationTo(::std::ostream* os) const {
273      *os &lt;&lt; FormatFileLocation(file(), line()) &lt;&lt; &quot; &quot;;
274    }
275    void DescribeCallCountTo(::std::ostream* os) const
276        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
277    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;
278   protected:
279    friend class ::testing::Expectation;
280    friend class UntypedFunctionMockerBase;
281    enum Clause {
282      kNone,
283      kWith,
284      kTimes,
285      kInSequence,
286      kAfter,
287      kWillOnce,
288      kWillRepeatedly,
289      kRetiresOnSaturation
290    };
291    typedef std::vector&lt;const void*&gt; UntypedActions;
292    virtual Expectation GetHandle() = 0;
293    void AssertSpecProperty(bool property, const string&amp; failure_message) const {
294      Assert(property, file_, line_, failure_message);
295    }
296    void ExpectSpecProperty(bool property, const string&amp; failure_message) const {
297      Expect(property, file_, line_, failure_message);
298    }
299    void SpecifyCardinality(const Cardinality&amp; cardinality);
300    bool cardinality_specified() const { return cardinality_specified_; }
301    void set_cardinality(const Cardinality&amp; a_cardinality) {
302      cardinality_ = a_cardinality;
303    }
304    void RetireAllPreRequisites()
305        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
306    bool is_retired() const
307        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
308      g_gmock_mutex.AssertHeld();
309      return retired_;
310    }
311    void Retire()
312        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
313      g_gmock_mutex.AssertHeld();
314      retired_ = true;
315    }
316    bool IsSatisfied() const
317        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
318      g_gmock_mutex.AssertHeld();
319      return cardinality().IsSatisfiedByCallCount(call_count_);
320    }
321    bool IsSaturated() const
322        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
323      g_gmock_mutex.AssertHeld();
324      return cardinality().IsSaturatedByCallCount(call_count_);
325    }
326    bool IsOverSaturated() const
327        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
328      g_gmock_mutex.AssertHeld();
329      return cardinality().IsOverSaturatedByCallCount(call_count_);
330    }
331    bool AllPrerequisitesAreSatisfied() const
332        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
333    void FindUnsatisfiedPrerequisites(ExpectationSet* result) const
334        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);
335    int call_count() const
336        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
337      g_gmock_mutex.AssertHeld();
338      return call_count_;
339    }
340    void IncrementCallCount()
341        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
342      g_gmock_mutex.AssertHeld();
343      call_count_++;
344    }
345    void CheckActionCountIfNotDone() const
346        GTEST_LOCK_EXCLUDED_(mutex_);
347    friend class ::testing::Sequence;
348    friend class ::testing::internal::ExpectationTester;
349    template &lt;typename Function&gt;
350    friend class TypedExpectation;
351    void UntypedTimes(const Cardinality&amp; a_cardinality);
352    const char* file_;          
353    int line_;                  
354    const string source_text_;  
355    bool cardinality_specified_;
356    Cardinality cardinality_;            
357    ExpectationSet immediate_prerequisites_;
358    int call_count_;  
359    bool retired_;    
360    UntypedActions untyped_actions_;
361    bool extra_matcher_specified_;
362    bool repeated_action_specified_;  
363    bool retires_on_saturation_;
364    Clause last_clause_;
365    mutable bool action_count_checked_;  
366    mutable Mutex mutex_;  
367    GTEST_DISALLOW_ASSIGN_(ExpectationBase);
368  };  
369  template &lt;typename F&gt;
370  class TypedExpectation : public ExpectationBase {
371   public:
372    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
373    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
374    typedef typename Function&lt;F&gt;::Result Result;
375    TypedExpectation(FunctionMockerBase&lt;F&gt;* owner,
376                     const char* a_file, int a_line, const string&amp; a_source_text,
377                     const ArgumentMatcherTuple&amp; m)
378        : ExpectationBase(a_file, a_line, a_source_text),
379          owner_(owner),
380          matchers_(m),
381          extra_matcher_(A&lt;const ArgumentTuple&amp;&gt;()),
382          repeated_action_(DoDefault()) {}
383    virtual ~TypedExpectation() {
384      CheckActionCountIfNotDone();
385      for (UntypedActions::const_iterator it = untyped_actions_.begin();
386           it != untyped_actions_.end(); ++it) {
387        delete static_cast&lt;const Action&lt;F&gt;*&gt;(*it);
388      }
389    }
390    TypedExpectation&amp; With(const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m) {
391      if (last_clause_ == kWith) {
392        ExpectSpecProperty(false,
393                           &quot;.With() cannot appear &quot;
394                           &quot;more than once in an EXPECT_CALL().&quot;);
395      } else {
396        ExpectSpecProperty(last_clause_ &lt; kWith,
397                           &quot;.With() must be the first &quot;
398                           &quot;clause in an EXPECT_CALL().&quot;);
399      }
400      last_clause_ = kWith;
401      extra_matcher_ = m;
402      extra_matcher_specified_ = true;
403      return *this;
404    }
405    TypedExpectation&amp; Times(const Cardinality&amp; a_cardinality) {
406      ExpectationBase::UntypedTimes(a_cardinality);
407      return *this;
408    }
409    TypedExpectation&amp; Times(int n) {
410      return Times(Exactly(n));
411    }
412    TypedExpectation&amp; InSequence(const Sequence&amp; s) {
413      ExpectSpecProperty(last_clause_ &lt;= kInSequence,
414                         &quot;.InSequence() cannot appear after .After(),&quot;
415                         &quot; .WillOnce(), .WillRepeatedly(), or &quot;
416                         &quot;.RetiresOnSaturation().&quot;);
417      last_clause_ = kInSequence;
418      s.AddExpectation(GetHandle());
419      return *this;
420    }
421    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2) {
422      return InSequence(s1).InSequence(s2);
423    }
424    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
425                                 const Sequence&amp; s3) {
426      return InSequence(s1, s2).InSequence(s3);
427    }
428    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
429                                 const Sequence&amp; s3, const Sequence&amp; s4) {
430      return InSequence(s1, s2, s3).InSequence(s4);
431    }
432    TypedExpectation&amp; InSequence(const Sequence&amp; s1, const Sequence&amp; s2,
433                                 const Sequence&amp; s3, const Sequence&amp; s4,
434                                 const Sequence&amp; s5) {
435      return InSequence(s1, s2, s3, s4).InSequence(s5);
436    }
437    TypedExpectation&amp; After(const ExpectationSet&amp; s) {
438      ExpectSpecProperty(last_clause_ &lt;= kAfter,
439                         &quot;.After() cannot appear after .WillOnce(),&quot;
440                         &quot; .WillRepeatedly(), or &quot;
441                         &quot;.RetiresOnSaturation().&quot;);
442      last_clause_ = kAfter;
443      for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {
444        immediate_prerequisites_ += *it;
445      }
446      return *this;
447    }
448    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2) {
449      return After(s1).After(s2);
450    }
451    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
452                            const ExpectationSet&amp; s3) {
453      return After(s1, s2).After(s3);
454    }
455    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
456                            const ExpectationSet&amp; s3, const ExpectationSet&amp; s4) {
457      return After(s1, s2, s3).After(s4);
458    }
459    TypedExpectation&amp; After(const ExpectationSet&amp; s1, const ExpectationSet&amp; s2,
460                            const ExpectationSet&amp; s3, const ExpectationSet&amp; s4,
461                            const ExpectationSet&amp; s5) {
462      return After(s1, s2, s3, s4).After(s5);
463    }
464    TypedExpectation&amp; WillOnce(const Action&lt;F&gt;&amp; action) {
465      ExpectSpecProperty(last_clause_ &lt;= kWillOnce,
466                         &quot;.WillOnce() cannot appear after &quot;
467                         &quot;.WillRepeatedly() or .RetiresOnSaturation().&quot;);
468      last_clause_ = kWillOnce;
469      untyped_actions_.push_back(new Action&lt;F&gt;(action));
470      if (!cardinality_specified()) {
471        set_cardinality(Exactly(static_cast&lt;int&gt;(untyped_actions_.size())));
472      }
473      return *this;
474    }
475    TypedExpectation&amp; WillRepeatedly(const Action&lt;F&gt;&amp; action) {
476      if (last_clause_ == kWillRepeatedly) {
477        ExpectSpecProperty(false,
478                           &quot;.WillRepeatedly() cannot appear &quot;
479                           &quot;more than once in an EXPECT_CALL().&quot;);
480      } else {
481        ExpectSpecProperty(last_clause_ &lt; kWillRepeatedly,
482                           &quot;.WillRepeatedly() cannot appear &quot;
483                           &quot;after .RetiresOnSaturation().&quot;);
484      }
485      last_clause_ = kWillRepeatedly;
486      repeated_action_specified_ = true;
487      repeated_action_ = action;
488      if (!cardinality_specified()) {
489        set_cardinality(AtLeast(static_cast&lt;int&gt;(untyped_actions_.size())));
490      }
491      CheckActionCountIfNotDone();
492      return *this;
493    }
494    TypedExpectation&amp; RetiresOnSaturation() {
495      ExpectSpecProperty(last_clause_ &lt; kRetiresOnSaturation,
496                         &quot;.RetiresOnSaturation() cannot appear &quot;
497                         &quot;more than once.&quot;);
498      last_clause_ = kRetiresOnSaturation;
499      retires_on_saturation_ = true;
500      CheckActionCountIfNotDone();
501      return *this;
502    }
503    const ArgumentMatcherTuple&amp; matchers() const {
504      return matchers_;
505    }
506    const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; extra_matcher() const {
507      return extra_matcher_;
508    }
509    const Action&lt;F&gt;&amp; repeated_action() const { return repeated_action_; }
510    virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {
511      if (extra_matcher_specified_) {
512        *os &lt;&lt; &quot;    Expected args: &quot;;
513        extra_matcher_.DescribeTo(os);
514        *os &lt;&lt; &quot;\n&quot;;
515      }
516    }
517   private:
518    template &lt;typename Function&gt;
519    friend class FunctionMockerBase;
520    virtual Expectation GetHandle() {
521      return owner_-&gt;GetHandleOf(this);
522    }
523    bool Matches(const ArgumentTuple&amp; args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) &amp;&amp; extra_matcher_.Matches(args);
527    }
<span onclick='openModal()' class='match'>528    bool ShouldHandleArguments(const ArgumentTuple&amp; args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
</span>532      return !is_retired() &amp;&amp; AllPrerequisitesAreSatisfied() &amp;&amp; Matches(args);
533    }
534    void ExplainMatchResultTo(
535        const ArgumentTuple&amp; args,
536        ::std::ostream* os) const
537            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
538      g_gmock_mutex.AssertHeld();
539      if (is_retired()) {
540        *os &lt;&lt; &quot;         Expected: the expectation is active\n&quot;
541            &lt;&lt; &quot;           Actual: it is retired\n&quot;;
542      } else if (!Matches(args)) {
543        if (!TupleMatches(matchers_, args)) {
544          ExplainMatchFailureTupleTo(matchers_, args, os);
545        }
546        StringMatchResultListener listener;
547        if (!extra_matcher_.MatchAndExplain(args, &amp;listener)) {
548          *os &lt;&lt; &quot;    Expected args: &quot;;
549          extra_matcher_.DescribeTo(os);
550          *os &lt;&lt; &quot;\n           Actual: don&#x27;t match&quot;;
551          internal::PrintIfNotEmpty(listener.str(), os);
552          *os &lt;&lt; &quot;\n&quot;;
553        }
554      } else if (!AllPrerequisitesAreSatisfied()) {
555        *os &lt;&lt; &quot;         Expected: all pre-requisites are satisfied\n&quot;
556            &lt;&lt; &quot;           Actual: the following immediate pre-requisites &quot;
557            &lt;&lt; &quot;are not satisfied:\n&quot;;
558        ExpectationSet unsatisfied_prereqs;
559        FindUnsatisfiedPrerequisites(&amp;unsatisfied_prereqs);
560        int i = 0;
561        for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();
562             it != unsatisfied_prereqs.end(); ++it) {
563          it-&gt;expectation_base()-&gt;DescribeLocationTo(os);
564          *os &lt;&lt; &quot;pre-requisite #&quot; &lt;&lt; i++ &lt;&lt; &quot;\n&quot;;
565        }
566        *os &lt;&lt; &quot;                   (end of pre-requisites)\n&quot;;
567      } else {
568        *os &lt;&lt; &quot;The call matches the expectation.\n&quot;;
569      }
570    }
571    const Action&lt;F&gt;&amp; GetCurrentAction(
572        const FunctionMockerBase&lt;F&gt;* mocker,
573        const ArgumentTuple&amp; args) const
574            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
575      g_gmock_mutex.AssertHeld();
576      const int count = call_count();
577      Assert(count &gt;= 1, __FILE__, __LINE__,
578             &quot;call_count() is &lt;= 0 when GetCurrentAction() is &quot;
579             &quot;called - this should never happen.&quot;);
580      const int action_count = static_cast&lt;int&gt;(untyped_actions_.size());
581      if (action_count &gt; 0 &amp;&amp; !repeated_action_specified_ &amp;&amp;
582          count &gt; action_count) {
583        ::std::stringstream ss;
584        DescribeLocationTo(&amp;ss);
585        ss &lt;&lt; &quot;Actions ran out in &quot; &lt;&lt; source_text() &lt;&lt; &quot;...\n&quot;
586           &lt;&lt; &quot;Called &quot; &lt;&lt; count &lt;&lt; &quot; times, but only &quot;
587           &lt;&lt; action_count &lt;&lt; &quot; WillOnce()&quot;
588           &lt;&lt; (action_count == 1 ? &quot; is&quot; : &quot;s are&quot;) &lt;&lt; &quot; specified - &quot;;
589        mocker-&gt;DescribeDefaultActionTo(args, &amp;ss);
590        Log(kWarning, ss.str(), 1);
591      }
592      return count &lt;= action_count ?
593          *static_cast&lt;const Action&lt;F&gt;*&gt;(untyped_actions_[count - 1]) :
594          repeated_action();
595    }
596    const Action&lt;F&gt;* GetActionForArguments(
597        const FunctionMockerBase&lt;F&gt;* mocker,
598        const ArgumentTuple&amp; args,
599        ::std::ostream* what,
600        ::std::ostream* why)
601            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
602      g_gmock_mutex.AssertHeld();
603      if (IsSaturated()) {
604        IncrementCallCount();
605        *what &lt;&lt; &quot;Mock function called more times than expected - &quot;;
606        mocker-&gt;DescribeDefaultActionTo(args, what);
607        DescribeCallCountTo(why);
608        return NULL;
609      }
610      IncrementCallCount();
611      RetireAllPreRequisites();
612      if (retires_on_saturation_ &amp;&amp; IsSaturated()) {
613        Retire();
614      }
615      *what &lt;&lt; &quot;Mock function call matches &quot; &lt;&lt; source_text() &lt;&lt;&quot;...\n&quot;;
616      return &amp;(GetCurrentAction(mocker, args));
617    }
618    FunctionMockerBase&lt;F&gt;* const owner_;
619    ArgumentMatcherTuple matchers_;
620    Matcher&lt;const ArgumentTuple&amp;&gt; extra_matcher_;
621    Action&lt;F&gt; repeated_action_;
622    GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);
623  };  
624  GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
625                                  const char* file, int line,
626                                  const string&amp; message);
627  template &lt;typename F&gt;
628  class MockSpec {
629   public:
630    typedef typename internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
631    typedef typename internal::Function&lt;F&gt;::ArgumentMatcherTuple
632        ArgumentMatcherTuple;
633    explicit MockSpec(internal::FunctionMockerBase&lt;F&gt;* function_mocker)
634        : function_mocker_(function_mocker) {}
635    internal::OnCallSpec&lt;F&gt;&amp; InternalDefaultActionSetAt(
636        const char* file, int line, const char* obj, const char* call) {
637      LogWithLocation(internal::kInfo, file, line,
638          string(&quot;ON_CALL(&quot;) + obj + &quot;, &quot; + call + &quot;) invoked&quot;);
639      return function_mocker_-&gt;AddNewOnCallSpec(file, line, matchers_);
640    }
641    internal::TypedExpectation&lt;F&gt;&amp; InternalExpectedAt(
642        const char* file, int line, const char* obj, const char* call) {
643      const string source_text(string(&quot;EXPECT_CALL(&quot;) + obj + &quot;, &quot; + call + &quot;)&quot;);
644      LogWithLocation(internal::kInfo, file, line, source_text + &quot; invoked&quot;);
645      return function_mocker_-&gt;AddNewExpectation(
646          file, line, source_text, matchers_);
647    }
648   private:
649    template &lt;typename Function&gt;
650    friend class internal::FunctionMocker;
651    void SetMatchers(const ArgumentMatcherTuple&amp; matchers) {
652      matchers_ = matchers;
653    }
654    internal::FunctionMockerBase&lt;F&gt;* const function_mocker_;
655    ArgumentMatcherTuple matchers_;
656    GTEST_DISALLOW_ASSIGN_(MockSpec);
657  };  
658  #ifdef _MSC_VER
659  # pragma warning(push)          
660  # pragma warning(disable:4355)  
661  #endif  
662  class UntypedActionResultHolderBase {
663   public:
664    virtual ~UntypedActionResultHolderBase() {}
665    virtual void PrintAsActionResult(::std::ostream* os) const = 0;
666  };
667  template &lt;typename T&gt;
668  class ActionResultHolder : public UntypedActionResultHolderBase {
669   public:
670    explicit ActionResultHolder(T a_value) : value_(a_value) {}
671    T GetValueAndDelete() const {
672      T retval(value_);
673      delete this;
674      return retval;
675    }
676    virtual void PrintAsActionResult(::std::ostream* os) const {
677      *os &lt;&lt; &quot;\n          Returns: &quot;;
678      UniversalPrinter&lt;T&gt;::Print(value_, os);
679    }
680    template &lt;typename F&gt;
681    static ActionResultHolder* PerformDefaultAction(
682        const FunctionMockerBase&lt;F&gt;* func_mocker,
683        const typename Function&lt;F&gt;::ArgumentTuple&amp; args,
684        const string&amp; call_description) {
685      return new ActionResultHolder(
686          func_mocker-&gt;PerformDefaultAction(args, call_description));
687    }
688    template &lt;typename F&gt;
689    static ActionResultHolder*
690    PerformAction(const Action&lt;F&gt;&amp; action,
691                  const typename Function&lt;F&gt;::ArgumentTuple&amp; args) {
692      return new ActionResultHolder(action.Perform(args));
693    }
694   private:
695    T value_;
696    GTEST_DISALLOW_ASSIGN_(ActionResultHolder);
697  };
698  template &lt;&gt;
699  class ActionResultHolder&lt;void&gt; : public UntypedActionResultHolderBase {
700   public:
701    void GetValueAndDelete() const { delete this; }
702    virtual void PrintAsActionResult(::std::ostream* &amp;bsol;* os */) const {}
703    template &lt;typename F&gt;
704    static ActionResultHolder* PerformDefaultAction(
705        const FunctionMockerBase&lt;F&gt;* func_mocker,
706        const typename Function&lt;F&gt;::ArgumentTuple&amp; args,
707        const string&amp; call_description) {
708      func_mocker-&gt;PerformDefaultAction(args, call_description);
709      return NULL;
710    }
711    template &lt;typename F&gt;
712    static ActionResultHolder* PerformAction(
713        const Action&lt;F&gt;&amp; action,
714        const typename Function&lt;F&gt;::ArgumentTuple&amp; args) {
715      action.Perform(args);
716      return NULL;
717    }
718  };
719  template &lt;typename F&gt;
720  class FunctionMockerBase : public UntypedFunctionMockerBase {
721   public:
722    typedef typename Function&lt;F&gt;::Result Result;
723    typedef typename Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
724    typedef typename Function&lt;F&gt;::ArgumentMatcherTuple ArgumentMatcherTuple;
725    FunctionMockerBase() : current_spec_(this) {}
726    virtual ~FunctionMockerBase()
727          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
728      MutexLock l(&amp;g_gmock_mutex);
729      VerifyAndClearExpectationsLocked();
730      Mock::UnregisterLocked(this);
731      ClearDefaultActionsLocked();
732    }
733    const OnCallSpec&lt;F&gt;* FindOnCallSpec(
734        const ArgumentTuple&amp; args) const {
735      for (UntypedOnCallSpecs::const_reverse_iterator it
736               = untyped_on_call_specs_.rbegin();
737           it != untyped_on_call_specs_.rend(); ++it) {
738        const OnCallSpec&lt;F&gt;* spec = static_cast&lt;const OnCallSpec&lt;F&gt;*&gt;(*it);
739        if (spec-&gt;Matches(args))
740          return spec;
741      }
742      return NULL;
743    }
744    Result PerformDefaultAction(const ArgumentTuple&amp; args,
745                                const string&amp; call_description) const {
746      const OnCallSpec&lt;F&gt;* const spec =
747          this-&gt;FindOnCallSpec(args);
748      if (spec != NULL) {
749        return spec-&gt;GetAction().Perform(args);
750      }
751      const string message = call_description +
752          &quot;\n    The mock function has no default action &quot;
753          &quot;set, and its return type has no default value set.&quot;;
754  #if GTEST_HAS_EXCEPTIONS
755      if (!DefaultValue&lt;Result&gt;::Exists()) {
756        throw std::runtime_error(message);
757      }
758  #else
759      Assert(DefaultValue&lt;Result&gt;::Exists(), &quot;&quot;, -1, message);
760  #endif
761      return DefaultValue&lt;Result&gt;::Get();
762    }
763    virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(
764        const void* untyped_args,  
765        const string&amp; call_description) const {
766      const ArgumentTuple&amp; args =
767          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
768      return ResultHolder::PerformDefaultAction(this, args, call_description);
769    }
770    virtual UntypedActionResultHolderBase* UntypedPerformAction(
771        const void* untyped_action, const void* untyped_args) const {
772      const Action&lt;F&gt; action = *static_cast&lt;const Action&lt;F&gt;*&gt;(untyped_action);
773      const ArgumentTuple&amp; args =
774          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
775      return ResultHolder::PerformAction(action, args);
776    }
777    virtual void ClearDefaultActionsLocked()
778        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
779      g_gmock_mutex.AssertHeld();
780      UntypedOnCallSpecs specs_to_delete;
781      untyped_on_call_specs_.swap(specs_to_delete);
782      g_gmock_mutex.Unlock();
783      for (UntypedOnCallSpecs::const_iterator it =
784               specs_to_delete.begin();
785           it != specs_to_delete.end(); ++it) {
786        delete static_cast&lt;const OnCallSpec&lt;F&gt;*&gt;(*it);
787      }
788      g_gmock_mutex.Lock();
789    }
790   protected:
791    template &lt;typename Function&gt;
792    friend class MockSpec;
793    typedef ActionResultHolder&lt;Result&gt; ResultHolder;
794    Result InvokeWith(const ArgumentTuple&amp; args)
795          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
796      return static_cast&lt;const ResultHolder*&gt;(
797          this-&gt;UntypedInvokeWith(&amp;args))-&gt;GetValueAndDelete();
798    }
799    OnCallSpec&lt;F&gt;&amp; AddNewOnCallSpec(
800        const char* file, int line,
801        const ArgumentMatcherTuple&amp; m)
802            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
803      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
804      OnCallSpec&lt;F&gt;* const on_call_spec = new OnCallSpec&lt;F&gt;(file, line, m);
805      untyped_on_call_specs_.push_back(on_call_spec);
806      return *on_call_spec;
807    }
808    TypedExpectation&lt;F&gt;&amp; AddNewExpectation(
809        const char* file,
810        int line,
811        const string&amp; source_text,
812        const ArgumentMatcherTuple&amp; m)
813            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
814      Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);
815      TypedExpectation&lt;F&gt;* const expectation =
816          new TypedExpectation&lt;F&gt;(this, file, line, source_text, m);
817      const linked_ptr&lt;ExpectationBase&gt; untyped_expectation(expectation);
818      untyped_expectations_.push_back(untyped_expectation);
819      Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();
820      if (implicit_sequence != NULL) {
821        implicit_sequence-&gt;AddExpectation(Expectation(untyped_expectation));
822      }
823      return *expectation;
824    }
825    MockSpec&lt;F&gt;&amp; current_spec() { return current_spec_; }
826   private:
827    template &lt;typename Func&gt; friend class TypedExpectation;
828    void DescribeDefaultActionTo(const ArgumentTuple&amp; args,
829                                 ::std::ostream* os) const {
830      const OnCallSpec&lt;F&gt;* const spec = FindOnCallSpec(args);
831      if (spec == NULL) {
832        *os &lt;&lt; (internal::type_equals&lt;Result, void&gt;::value ?
833                &quot;returning directly.\n&quot; :
834                &quot;returning default value.\n&quot;);
835      } else {
836        *os &lt;&lt; &quot;taking default action specified at:\n&quot;
837            &lt;&lt; FormatFileLocation(spec-&gt;file(), spec-&gt;line()) &lt;&lt; &quot;\n&quot;;
838      }
839    }
840    virtual void UntypedDescribeUninterestingCall(
841        const void* untyped_args,
842        ::std::ostream* os) const
843            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
844      const ArgumentTuple&amp; args =
845          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
846      *os &lt;&lt; &quot;Uninteresting mock function call - &quot;;
847      DescribeDefaultActionTo(args, os);
848      *os &lt;&lt; &quot;    Function call: &quot; &lt;&lt; Name();
849      UniversalPrint(args, os);
850    }
851    virtual const ExpectationBase* UntypedFindMatchingExpectation(
852        const void* untyped_args,
853        const void** untyped_action, bool* is_excessive,
854        ::std::ostream* what, ::std::ostream* why)
855            GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {
856      const ArgumentTuple&amp; args =
857          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
858      MutexLock l(&amp;g_gmock_mutex);
859      TypedExpectation&lt;F&gt;* exp = this-&gt;FindMatchingExpectationLocked(args);
860      if (exp == NULL) {  
861        this-&gt;FormatUnexpectedCallMessageLocked(args, what, why);
862        return NULL;
863      }
864      *is_excessive = exp-&gt;IsSaturated();
865      const Action&lt;F&gt;* action = exp-&gt;GetActionForArguments(this, args, what, why);
866      if (action != NULL &amp;&amp; action-&gt;IsDoDefault())
867        action = NULL;  
868      *untyped_action = action;
869      return exp;
870    }
871    virtual void UntypedPrintArgs(const void* untyped_args,
872                                  ::std::ostream* os) const {
873      const ArgumentTuple&amp; args =
874          *static_cast&lt;const ArgumentTuple*&gt;(untyped_args);
875      UniversalPrint(args, os);
876    }
877    TypedExpectation&lt;F&gt;* FindMatchingExpectationLocked(
878        const ArgumentTuple&amp; args) const
879            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
880      g_gmock_mutex.AssertHeld();
881      for (typename UntypedExpectations::const_reverse_iterator it =
882               untyped_expectations_.rbegin();
883           it != untyped_expectations_.rend(); ++it) {
884        TypedExpectation&lt;F&gt;* const exp =
885            static_cast&lt;TypedExpectation&lt;F&gt;*&gt;(it-&gt;get());
886        if (exp-&gt;ShouldHandleArguments(args)) {
887          return exp;
888        }
889      }
890      return NULL;
891    }
892    void FormatUnexpectedCallMessageLocked(
893        const ArgumentTuple&amp; args,
894        ::std::ostream* os,
895        ::std::ostream* why) const
896            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
897      g_gmock_mutex.AssertHeld();
898      *os &lt;&lt; &quot;\nUnexpected mock function call - &quot;;
899      DescribeDefaultActionTo(args, os);
900      PrintTriedExpectationsLocked(args, why);
901    }
902    void PrintTriedExpectationsLocked(
903        const ArgumentTuple&amp; args,
904        ::std::ostream* why) const
905            GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
906      g_gmock_mutex.AssertHeld();
907      const int count = static_cast&lt;int&gt;(untyped_expectations_.size());
908      *why &lt;&lt; &quot;Google Mock tried the following &quot; &lt;&lt; count &lt;&lt; &quot; &quot;
909           &lt;&lt; (count == 1 ? &quot;expectation, but it didn&#x27;t match&quot; :
910               &quot;expectations, but none matched&quot;)
911           &lt;&lt; &quot;:\n&quot;;
912      for (int i = 0; i &lt; count; i++) {
913        TypedExpectation&lt;F&gt;* const expectation =
914            static_cast&lt;TypedExpectation&lt;F&gt;*&gt;(untyped_expectations_[i].get());
915        *why &lt;&lt; &quot;\n&quot;;
916        expectation-&gt;DescribeLocationTo(why);
917        if (count &gt; 1) {
918          *why &lt;&lt; &quot;tried expectation #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot;;
919        }
920        *why &lt;&lt; expectation-&gt;source_text() &lt;&lt; &quot;...\n&quot;;
921        expectation-&gt;ExplainMatchResultTo(args, why);
922        expectation-&gt;DescribeCallCountTo(why);
923      }
924    }
925    MockSpec&lt;F&gt; current_spec_;
926    GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);
927  };  
928  #ifdef _MSC_VER
929  # pragma warning(pop)  
930  #endif  
931  void ReportUninterestingCall(CallReaction reaction, const string&amp; msg);
932  }  
933  using internal::MockSpec;
934  template &lt;typename T&gt;
935  inline const T&amp; Const(const T&amp; x) { return x; }
936  inline Expectation::Expectation(internal::ExpectationBase&amp; exp)  
937      : expectation_base_(exp.GetHandle().expectation_base()) {}
938  }  
939  #define GMOCK_ON_CALL_IMPL_(obj, call) \
940      ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \
941                                                      #obj, #call)
942  #define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)
943  #define GMOCK_EXPECT_CALL_IMPL_(obj, call) \
944      ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)
945  #define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)
946  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-spec-builders.h</div>
                </div>
                <div class="column column_space"><pre><code>523    bool Matches(const ArgumentTuple&amp; args) const
524        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
525      g_gmock_mutex.AssertHeld();
526      return TupleMatches(matchers_, args) &amp;&amp; extra_matcher_.Matches(args);
</pre></code></div>
                <div class="column column_space"><pre><code>528    bool ShouldHandleArguments(const ArgumentTuple&amp; args) const
529        GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
530      g_gmock_mutex.AssertHeld();
531      CheckActionCountIfNotDone();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    