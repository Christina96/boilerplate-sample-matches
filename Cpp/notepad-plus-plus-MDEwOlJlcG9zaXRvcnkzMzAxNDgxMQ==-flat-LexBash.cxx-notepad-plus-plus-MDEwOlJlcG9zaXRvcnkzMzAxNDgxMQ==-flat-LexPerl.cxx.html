
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</h3>
            <pre><code>1  #include <cstdlib>
2  #include <cassert>
3  #include <cstring>
4  #include <cstdio>
5  #include <cstdarg>
6  #include <string>
7  #include <string_view>
8  #include <vector>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "StringCopy.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "LexerModule.h"
20  #include "OptionSet.h"
21  #include "SubStyles.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define HERE_DELIM_MAX			256
27  #undef PEDANTIC_OCTAL
28  #define BASH_BASE_ERROR			65
29  #define BASH_BASE_DECIMAL		66
30  #define BASH_BASE_HEX			67
31  #ifdef PEDANTIC_OCTAL
32  #define BASH_BASE_OCTAL			68
33  #define	BASH_BASE_OCTAL_ERROR	69
34  #endif
35  enum class CmdState {
36  	Body,
37  	Start,
38  	Word,
39  	Test,
40  	Arithmetic,
41  	Delimiter,
42  };
43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
58  	HereDoc,		
59  	Backtick,		
60  	Parameter,		
61  	Command,		
62  	CommandInside,	
63  	Arithmetic,		
64  };
65  #define BASH_QUOTE_STACK_MAX	7
66  constexpr int commandSubstitutionFlag = 0x40;
67  constexpr int MaskCommand(int state) noexcept {
68  	return state & ~commandSubstitutionFlag;
69  }
70  constexpr int translateBashDigit(int ch) noexcept {
71  	if (ch >= '0' && ch <= '9') {
72  		return ch - '0';
73  	} else if (ch >= 'a' && ch <= 'z') {
74  		return ch - 'a' + 10;
75  	} else if (ch >= 'A' && ch <= 'Z') {
76  		return ch - 'A' + 36;
77  	} else if (ch == '@') {
78  		return 62;
79  	} else if (ch == '_') {
80  		return 63;
81  	}
82  	return BASH_BASE_ERROR;
83  }
84  int getBashNumberBase(char *s) noexcept {
85  	int i = 0;
86  	int base = 0;
87  	while (*s) {
88  		base = base * 10 + (*s++ - '0');
89  		i++;
90  	}
91  	if (base > 64 || i > 2) {
92  		return BASH_BASE_ERROR;
93  	}
94  	return base;
95  }
96  constexpr int opposite(int ch) noexcept {
97  	if (ch == '(') return ')';
98  	if (ch == '[') return ']';
99  	if (ch == '{') return '}';
100  	if (ch == '<') return '>';
101  	return ch;
102  }
103  int GlobScan(StyleContext &sc) {
104  	int c = 0;
105  	int sLen = 0;
106  	int pCount = 0;
107  	int hash = 0;
108  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
109  		if (IsASpace(c)) {
110  			return 0;
111  		} else if (c == '\'' || c == '\"') {
112  			if (hash != 2) return 0;
113  		} else if (c == '#' && hash == 0) {
114  			hash = (sLen == 1) ? 2:1;
115  		} else if (c == '(') {
116  			pCount++;
117  		} else if (c == ')') {
118  			if (pCount == 0) {
119  				if (hash) return sLen;
120  				return 0;
121  			}
122  			pCount--;
123  		}
124  	}
125  	return 0;
126  }
127  bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
128  	const Sci_Position pos = styler.LineStart(line);
129  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
130  	for (Sci_Position i = pos; i < eol_pos; i++) {
131  		const char ch = styler[i];
132  		if (ch == '#')
133  			return true;
134  		else if (ch != ' ' && ch != '\t')
135  			return false;
136  	}
137  	return false;
138  }
139  struct OptionsBash {
140  	bool fold = false;
141  	bool foldComment = false;
142  	bool foldCompact = true;
143  	bool stylingInsideString = false;
144  	bool stylingInsideBackticks = false;
145  	bool stylingInsideParameter = false;
146  	bool stylingInsideHeredoc = false;
147  	int commandSubstitution = static_cast<int>(CommandSubstitution::Backtick);
148  	[[nodiscard]] bool stylingInside(int state) const noexcept {
149  		switch (state) {
150  		case SCE_SH_STRING:
151  			return stylingInsideString;
152  		case SCE_SH_BACKTICKS:
153  			return stylingInsideBackticks;
154  		case SCE_SH_PARAM:
155  			return stylingInsideParameter;
156  		case SCE_SH_HERE_Q:
157  			return stylingInsideHeredoc;
158  		default:
159  			return false;
160  		}
161  	}
162  };
163  const char * const bashWordListDesc[] = {
164  	"Keywords",
165  	nullptr
166  };
167  struct OptionSetBash : public OptionSet<OptionsBash> {
168  	OptionSetBash() {
169  		DefineProperty("fold", &OptionsBash::fold);
170  		DefineProperty("fold.comment", &OptionsBash::foldComment);
171  		DefineProperty("fold.compact", &OptionsBash::foldCompact);
172  		DefineProperty("lexer.bash.styling.inside.string", &OptionsBash::stylingInsideString,
173  			"Set this property to 1 to highlight shell expansions inside string.");
174  		DefineProperty("lexer.bash.styling.inside.backticks", &OptionsBash::stylingInsideBackticks,
175  			"Set this property to 1 to highlight shell expansions inside backticks.");
176  		DefineProperty("lexer.bash.styling.inside.parameter", &OptionsBash::stylingInsideParameter,
177  			"Set this property to 1 to highlight shell expansions inside ${} parameter expansion.");
178  		DefineProperty("lexer.bash.styling.inside.heredoc", &OptionsBash::stylingInsideHeredoc,
179  			"Set this property to 1 to highlight shell expansions inside here document.");
180  		DefineProperty("lexer.bash.command.substitution", &OptionsBash::commandSubstitution,
181  			"Set how to highlight $() command substitution. "
182  			"0 (the default) highlighted as backticks. "
183  			"1 highlighted inside. "
184  			"2 highlighted inside with extra scope tracking.");
185  		DefineWordListSets(bashWordListDesc);
186  	}
187  };
188  class QuoteCls {	
189  public:
190  	int Count = 0;
191  	int Up = '\0';
192  	int Down = '\0';
193  	QuoteStyle Style = QuoteStyle::Literal;
194  	int Outer = SCE_SH_DEFAULT;
195  	void Clear() noexcept {
196  		Count = 0;
197  		Up	  = '\0';
198  		Down  = '\0';
199  		Style = QuoteStyle::Literal;
200  		Outer = SCE_SH_DEFAULT;
201  	}
202  	void Start(int u, QuoteStyle s, int outer) noexcept {
203  		Count = 1;
204  		Up    = u;
205  		Down  = opposite(Up);
206  		Style = s;
207  		Outer = outer;
208  	}
209  };
210  class QuoteStackCls {	
211  public:
212  	int Depth = 0;
213  	int State = SCE_SH_DEFAULT;
214  	CommandSubstitution commandSubstitution = CommandSubstitution::Backtick;
215  	int insideCommand = 0;
216  	QuoteCls Current;
217  	QuoteCls Stack[BASH_QUOTE_STACK_MAX];
218  	[[nodiscard]] bool Empty() const noexcept {
219  		return Current.Up == '\0';
220  	}
221  	void Start(int u, QuoteStyle s, int outer) noexcept {
222  		if (Empty()) {
223  			Current.Start(u, s, outer);
224  		} else {
225  			Push(u, s, outer);
226  		}
227  	}
228  	void Push(int u, QuoteStyle s, int outer) noexcept {
229  		if (Depth >= BASH_QUOTE_STACK_MAX) {
230  			return;
231  		}
232  		Stack[Depth] = Current;
233  		Depth++;
234  		Current.Start(u, s, outer);
235  	}
236  	void Pop() noexcept {
237  		if (Depth == 0) {
238  			Clear();
239  			return;
240  		}
241  		if (insideCommand != 0) {
242  			insideCommand = 0;
243  			for (int i = 0; i < Depth; i++) {
244  				if (Stack[i].Style == QuoteStyle::CommandInside) {
245  					insideCommand = commandSubstitutionFlag;
246  					break;
247  				}
248  			}
249  		}
250  		Depth--;
251  		Current = Stack[Depth];
252  	}
253  	void Clear() noexcept {
254  		Depth = 0;
255  		State = SCE_SH_DEFAULT;
256  		insideCommand = 0;
257  		Current.Clear();
258  	}
259  	bool CountDown(StyleContext &sc, CmdState &cmdState) {
260  		Current.Count--;
261  		if (Current.Count == 1 && sc.Match(')', ')')) {
262  			Current.Count--;
263  			sc.Forward();
264  		}
265  		if (Current.Count == 0) {
266  			cmdState = CmdState::Body;
267  			const int outer = Current.Outer;
268  			Pop();
269  			sc.ForwardSetState(outer | insideCommand);
270  			return true;
271  		}
272  		return false;
273  	}
274  	void Expand(StyleContext &sc, CmdState &cmdState, bool stylingInside) {
275  		const int state = sc.state;
276  		QuoteStyle style = QuoteStyle::Literal;
277  		State = state;
278  		sc.SetState(SCE_SH_SCALAR);
279  		sc.Forward();
280  		if (sc.ch == '{') {
281  			style = QuoteStyle::Parameter;
282  			sc.ChangeState(SCE_SH_PARAM);
283  		} else if (sc.ch == '\'') {
284  			style = QuoteStyle::CString;
285  			sc.ChangeState(SCE_SH_STRING);
286  		} else if (sc.ch == '"') {
287  			style = QuoteStyle::LString;
288  			sc.ChangeState(SCE_SH_STRING);
289  		} else if (sc.ch == '(' || sc.ch == '[') {
290  			if (sc.ch == '[' || sc.chNext == '(') {
291  				style = QuoteStyle::Arithmetic;
292  				cmdState = CmdState::Arithmetic;
293  				sc.ChangeState(SCE_SH_OPERATOR);
294  			} else {
295  				if (stylingInside && commandSubstitution >= CommandSubstitution::Inside) {
296  					style = QuoteStyle::CommandInside;
297  					cmdState = CmdState::Delimiter;
298  					sc.ChangeState(SCE_SH_OPERATOR);
299  					if (commandSubstitution == CommandSubstitution::InsideTrack) {
300  						insideCommand = commandSubstitutionFlag;
301  					}
302  				} else {
303  					style = QuoteStyle::Command;
304  					sc.ChangeState(SCE_SH_BACKTICKS);
305  				}
306  			}
307  			if (sc.Match('(', '(') && state == SCE_SH_DEFAULT && Depth == 0) {
308  				style = QuoteStyle::Literal;
309  			}
310  		} else if (sc.ch == '`') {	
311  			style = QuoteStyle::Backtick;
312  			sc.ChangeState(SCE_SH_BACKTICKS);
313  		} else {
314  		}
315  		if (!stylingInside) {
316  			sc.ChangeState(state);
317  		} else {
318  			sc.ChangeState(sc.state | insideCommand);
319  		}
320  		if (style != QuoteStyle::Literal) {
321  			Start(sc.ch, style, state);
322  			sc.Forward();
323  		}
324  	}
325  };
326  const char styleSubable[] = { SCE_SH_IDENTIFIER, SCE_SH_SCALAR, 0 };
327  const LexicalClass lexicalClasses[] = {
328  	0, "SCE_SH_DEFAULT", "default", "White space",
329  	1, "SCE_SH_ERROR", "error", "Error",
330  	2, "SCE_SH_COMMENTLINE", "comment line", "Line comment: #",
331  	3, "SCE_SH_NUMBER", "literal numeric", "Number",
332  	4, "SCE_SH_WORD", "keyword", "Keyword",
333  	5, "SCE_SH_STRING", "literal string", "String",
334  	6, "SCE_SH_CHARACTER", "literal string", "Single quoted string",
335  	7, "SCE_SH_OPERATOR", "operator", "Operators",
336  	8, "SCE_SH_IDENTIFIER", "identifier", "Identifiers",
337  	9, "SCE_SH_SCALAR", "identifier", "Scalar variable",
338  	10, "SCE_SH_PARAM", "identifier", "Parameter",
339  	11, "SCE_SH_BACKTICKS", "literal string", "Backtick quoted command",
340  	12, "SCE_SH_HERE_DELIM", "operator", "Heredoc delimiter",
341  	13, "SCE_SH_HERE_Q", "literal string", "Heredoc quoted string",
342  };
343  }
344  class LexerBash final : public DefaultLexer {
345  	WordList keywords;
346  	WordList cmdDelimiter;
347  	WordList bashStruct;
348  	WordList bashStruct_in;
349  	OptionsBash options;
350  	OptionSetBash osBash;
351  	enum { ssIdentifier, ssScalar };
352  	SubStyles subStyles;
353  public:
354  	LexerBash() :
355  		DefaultLexer("bash", SCLEX_BASH, lexicalClasses, ELEMENTS(lexicalClasses)),
356  		subStyles(styleSubable, 0x80, 0x40, 0) {
357  		cmdDelimiter.Set("| || |& & && ; ;; ( ) { }");
358  		bashStruct.Set("if elif fi while until else then do done esac eval");
359  		bashStruct_in.Set("for case select");
360  	}
361  	void SCI_METHOD Release() override {
362  		delete this;
363  	}
364  	int SCI_METHOD Version() const override {
365  		return lvRelease5;
366  	}
367  	const char * SCI_METHOD PropertyNames() override {
368  		return osBash.PropertyNames();
369  	}
370  	int SCI_METHOD PropertyType(const char* name) override {
371  		return osBash.PropertyType(name);
372  	}
373  	const char * SCI_METHOD DescribeProperty(const char *name) override {
374  		return osBash.DescribeProperty(name);
375  	}
376  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
377  	const char * SCI_METHOD PropertyGet(const char* key) override {
378  		return osBash.PropertyGet(key);
379  	}
380  	const char * SCI_METHOD DescribeWordListSets() override {
381  		return osBash.DescribeWordListSets();
382  	}
383  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
384  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
385  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
386  	void * SCI_METHOD PrivateCall(int, void *) override {
387  		return nullptr;
388  	}
389  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
390  		return subStyles.Allocate(styleBase, numberStyles);
391  	}
392  	int SCI_METHOD SubStylesStart(int styleBase) override {
393  		return subStyles.Start(styleBase);
394  	}
395  	int SCI_METHOD SubStylesLength(int styleBase) override {
396  		return subStyles.Length(styleBase);
397  	}
398  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
399  		const int styleBase = subStyles.BaseStyle(subStyle);
400  		return styleBase;
401  	}
402  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
403  		return style;
404  	}
405  	void SCI_METHOD FreeSubStyles() override {
406  		subStyles.Free();
407  	}
408  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
409  		subStyles.SetIdentifiers(style, identifiers);
410  	}
411  	int SCI_METHOD DistanceToSecondaryStyles() override {
412  		return 0;
413  	}
414  	const char *SCI_METHOD GetSubStyleBases() override {
415  		return styleSubable;
416  	}
417  	static ILexer5 *LexerFactoryBash() {
418  		return new LexerBash();
419  	}
420  };
421  Sci_Position SCI_METHOD LexerBash::PropertySet(const char *key, const char *val) {
422  	if (osBash.PropertySet(&options, key, val)) {
423  		return 0;
424  	}
425  	return -1;
426  }
427  Sci_Position SCI_METHOD LexerBash::WordListSet(int n, const char *wl) {
428  	WordList *wordListN = nullptr;
429  	switch (n) {
430  	case 0:
431  		wordListN = &keywords;
432  		break;
433  	}
434  	Sci_Position firstModification = -1;
435  	if (wordListN) {
436  		if (wordListN->Set(wl)) {
437  			firstModification = 0;
438  		}
439  	}
440  	return firstModification;
441  }
442  void SCI_METHOD LexerBash::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
443  	const CharacterSet setWordStart(CharacterSet::setAlpha, "_");
444  	const CharacterSet setWord(CharacterSet::setAlphaNum, "._+-");
445  	CharacterSet setMetaCharacter(CharacterSet::setNone, "|&;()<> \t\r\n");
446  	setMetaCharacter.Add(0);
447  	const CharacterSet setBashOperator(CharacterSet::setNone, "^&%()-+=|{}[]:;>,*/<?!.~@");
448  	const CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMACahGLNn");
449  	const CharacterSet setParam(CharacterSet::setAlphaNum, "_");
450  	const CharacterSet setHereDoc(CharacterSet::setAlpha, "_\\-+!%*,./:?@[]^`{}~");
451  	const CharacterSet setHereDoc2(CharacterSet::setAlphaNum, "_-+!%*,./:=?@[]^`{}~");
452  	const CharacterSet setLeftShift(CharacterSet::setDigits, "$");
453  	class HereDocCls {	
454  	public:
455  		int State = 0;			
456  		int Quote = '\0';		
457  		bool Quoted = false;		
458  		bool Escaped = false;		
459  		bool Indent = false;		
460  		int DelimiterLength = 0;	
461  		char Delimiter[HERE_DELIM_MAX]{};	
462  		HereDocCls() noexcept = default;
463  		void Append(int ch) {
464  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
465  			Delimiter[DelimiterLength] = '\0';
466  		}
467  	};
468  	HereDocCls HereDoc;
469  	QuoteStackCls QuoteStack;
470  	QuoteStack.commandSubstitution = static_cast<CommandSubstitution>(options.commandSubstitution);
471  	const WordClassifier &classifierIdentifiers = subStyles.Classifier(SCE_SH_IDENTIFIER);
472  	const WordClassifier &classifierScalars = subStyles.Classifier(SCE_SH_SCALAR);
473  	int numBase = 0;
474  	int digit = 0;
475  	const Sci_PositionU endPos = startPos + length;
476  	CmdState cmdState = CmdState::Start;
477  	TestExprType testExprType = TestExprType::Test;
478  	LexAccessor styler(pAccess);
479  	Sci_Position ln = styler.GetLine(startPos);
480  	if (ln > 0 && startPos == static_cast<Sci_PositionU>(styler.LineStart(ln)))
481  		ln--;
482  	for (;;) {
483  		startPos = styler.LineStart(ln);
484  		if (ln == 0 || styler.GetLineState(ln) == static_cast<int>(CmdState::Start))
485  			break;
486  		ln--;
487  	}
488  	initStyle = SCE_SH_DEFAULT;
489  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
490  	while (sc.More()) {
491  		if (sc.atLineStart) {
492  			if (MaskCommand(sc.state) == SCE_SH_STRING
493  			 || MaskCommand(sc.state) == SCE_SH_BACKTICKS
494  			 || MaskCommand(sc.state) == SCE_SH_CHARACTER
495  			 || MaskCommand(sc.state) == SCE_SH_HERE_Q
496  			 || MaskCommand(sc.state) == SCE_SH_COMMENTLINE
497  			 || MaskCommand(sc.state) == SCE_SH_PARAM) {
498  				styler.SetLineState(sc.currentLine, static_cast<int>(CmdState::Body));
499  			} else {
500  				if (sc.currentLine > 0) {
501  					if ((sc.GetRelative(-3) == '\\' && sc.GetRelative(-2) == '\r' && sc.chPrev == '\n')
502  					 || sc.GetRelative(-2) == '\\') {	
503  					} else
504  						cmdState = CmdState::Start;
505  				}
506  				const CmdState state = QuoteStack.Empty() ? cmdState : CmdState::Body;
507  				styler.SetLineState(sc.currentLine, static_cast<int>(state));
508  			}
509  		}
510  		CmdState cmdStateNew = CmdState::Body;
511  		if (cmdState == CmdState::Test || cmdState == CmdState::Arithmetic || cmdState == CmdState::Word)
512  			cmdStateNew = cmdState;
513  		const int stylePrev = MaskCommand(sc.state);
514  		const int insideCommand = QuoteStack.insideCommand;
515  		switch (MaskCommand(sc.state)) {
516  			case SCE_SH_OPERATOR:
517  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
518  				if (cmdState == CmdState::Delimiter)		
519  					cmdStateNew = CmdState::Start;
520  				else if (sc.chPrev == '\\')			
521  					cmdStateNew = cmdState;
522  				break;
523  			case SCE_SH_WORD:
524  				if (!setWord.Contains(sc.ch)) {
525  					char s[500];
526  					sc.GetCurrent(s, sizeof(s));
527  					int identifierStyle = SCE_SH_IDENTIFIER | insideCommand;
528  					const int subStyle = classifierIdentifiers.ValueFor(s);
529  					if (subStyle >= 0) {
530  						identifierStyle = subStyle | insideCommand;
531  					}
532  					char s2[10];
533  					s2[0] = static_cast<char>(sc.ch);
534  					s2[1] = '\0';
535  					const bool keywordEnds = IsASpace(sc.ch) || cmdDelimiter.InList(s2);
536  					if (cmdState == CmdState::Word) {
537  						if (strcmp(s, "in") == 0 && keywordEnds)
538  							cmdStateNew = CmdState::Body;
539  						else if (strcmp(s, "do") == 0 && keywordEnds)
540  							cmdStateNew = CmdState::Start;
541  						else
542  							sc.ChangeState(identifierStyle);
543  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
544  						break;
545  					}
546  					if (strcmp(s, "test") == 0) {
547  						if (cmdState == CmdState::Start && keywordEnds) {
548  							cmdStateNew = CmdState::Test;
549  							testExprType = TestExprType::Test;
550  						} else
551  							sc.ChangeState(identifierStyle);
552  					}
553  					else if (bashStruct.InList(s)) {
554  						if (cmdState == CmdState::Start && keywordEnds)
555  							cmdStateNew = CmdState::Start;
556  						else
557  							sc.ChangeState(identifierStyle);
558  					}
559  					else if (bashStruct_in.InList(s)) {
560  						if (cmdState == CmdState::Start && keywordEnds)
561  							cmdStateNew = CmdState::Word;
562  						else
563  							sc.ChangeState(identifierStyle);
564  					}
565  					else if (s[0] == '-') {
566  						if (cmdState != CmdState::Test)
567  							sc.ChangeState(identifierStyle);
568  					}
569  					else if (cmdState != CmdState::Start
570  						  || !(keywords.InList(s) && keywordEnds)) {
571  						sc.ChangeState(identifierStyle);
572  					}
573  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
574  				}
575  				break;
576  			case SCE_SH_IDENTIFIER:
577  				if (sc.chPrev == '\\' || !setWord.Contains(sc.ch) ||
578  					  (cmdState == CmdState::Arithmetic && !setWordStart.Contains(sc.ch))) {
579  					char s[500];
580  					sc.GetCurrent(s, sizeof(s));
581  					const int subStyle = classifierIdentifiers.ValueFor(s);
582  					if (subStyle >= 0) {
583  						sc.ChangeState(subStyle | insideCommand);
584  					}
585  					if (sc.chPrev == '\\') {	
586  						sc.Forward();
587  					}
588  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
589  				}
590  				break;
591  			case SCE_SH_NUMBER:
592  				digit = translateBashDigit(sc.ch);
593  				if (numBase == BASH_BASE_DECIMAL) {
594  					if (sc.ch == '#') {
595  						char s[10];
596  						sc.GetCurrent(s, sizeof(s));
597  						numBase = getBashNumberBase(s);
598  						if (numBase != BASH_BASE_ERROR)
599  							break;
600  					} else if (IsADigit(sc.ch))
601  						break;
602  				} else if (numBase == BASH_BASE_HEX) {
603  					if (IsADigit(sc.ch, 16))
604  						break;
605  #ifdef PEDANTIC_OCTAL
606  				} else if (numBase == BASH_BASE_OCTAL ||
607  						   numBase == BASH_BASE_OCTAL_ERROR) {
608  					if (digit <= 7)
609  						break;
610  					if (digit <= 9) {
611  						numBase = BASH_BASE_OCTAL_ERROR;
612  						break;
613  					}
614  #endif
615  				} else if (numBase == BASH_BASE_ERROR) {
616  					if (digit <= 9)
617  						break;
618  				} else {	
619  					if (digit != BASH_BASE_ERROR) {
620  						if (numBase <= 36) {
621  							if (digit >= 36) digit -= 26;
622  						}
623  						if (digit < numBase)
624  							break;
625  						if (digit <= 9) {
626  							numBase = BASH_BASE_ERROR;
627  							break;
628  						}
629  					}
630  				}
631  				if (numBase == BASH_BASE_ERROR
632  #ifdef PEDANTIC_OCTAL
633  					|| numBase == BASH_BASE_OCTAL_ERROR
634  #endif
635  				) {
636  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
637  				}
638  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
639  				break;
640  			case SCE_SH_COMMENTLINE:
641  				if (sc.MatchLineEnd() && sc.chPrev != '\\') {
642  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
643  				}
644  				break;
645  			case SCE_SH_HERE_DELIM:
646  				if (HereDoc.State == 0) { 
647  					HereDoc.Quote = sc.chNext;
648  					HereDoc.Quoted = false;
<span onclick='openModal()' class='match'>649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
652  					if (sc.chNext == '\'' || sc.chNext == '\"') {	
</span>653  						sc.Forward();
654  						HereDoc.Quoted = true;
655  						HereDoc.State = 1;
656  					} else if (setHereDoc.Contains(sc.chNext) ||
657  					           (sc.chNext == '=' && cmdState != CmdState::Arithmetic)) {
658  						HereDoc.State = 1;
659  					} else if (sc.chNext == '<') {	
660  						sc.Forward();
661  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
662  					} else if (IsASpace(sc.chNext)) {
663  					} else if (setLeftShift.Contains(sc.chNext) ||
664  					           (sc.chNext == '=' && cmdState == CmdState::Arithmetic)) {
665  						sc.ChangeState(SCE_SH_OPERATOR | insideCommand);
666  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
667  					} else {
668  						HereDoc.State = 1;
669  					}
670  				} else if (HereDoc.State == 1) { 
671  					if ((HereDoc.Quote == '\'' && sc.ch != HereDoc.Quote) ||
672  					    (HereDoc.Quoted && sc.ch != HereDoc.Quote && sc.ch != '\\') ||
673  					    (HereDoc.Quote != '\'' && sc.chPrev == '\\') ||
674  					    (setHereDoc2.Contains(sc.ch))) {
675  						HereDoc.Append(sc.ch);
676  					} else if (HereDoc.Quoted && sc.ch == HereDoc.Quote) {	
677  						sc.ForwardSetState(SCE_SH_DEFAULT);
678  					} else if (sc.ch == '\\') {
679  						HereDoc.Escaped = true;
680  						if (HereDoc.Quoted && sc.chNext != HereDoc.Quote && sc.chNext != '\\') {
681  							HereDoc.Append(sc.ch);
682  						} else {
683  						}
684  					} else if (!HereDoc.Quoted) {
685  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
686  					}
687  					if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {	
688  						sc.SetState(SCE_SH_ERROR | insideCommand);
689  						HereDoc.State = 0;
690  					}
691  				}
692  				break;
693  			case SCE_SH_SCALAR:	
694  				if (!setParam.Contains(sc.ch)) {
695  					char s[500];
696  					sc.GetCurrent(s, sizeof(s));
697  					const int subStyle = classifierScalars.ValueFor(&s[1]); 
698  					if (subStyle >= 0) {
699  						sc.ChangeState(subStyle | insideCommand);
700  					}
701  					if (sc.LengthCurrent() == 1) {
702  						sc.Forward();
703  					}
704  					sc.SetState(QuoteStack.State | insideCommand);
705  					continue;
706  				}
707  				break;
708  			case SCE_SH_HERE_Q:
709  				if (sc.atLineStart && QuoteStack.Current.Style == QuoteStyle::HereDoc) {
710  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
711  					if (HereDoc.Indent) { 
712  						while (sc.ch == '\t') {
713  							sc.Forward();
714  						}
715  					}
716  					if ((static_cast<Sci_Position>(sc.currentPos + HereDoc.DelimiterLength) == sc.lineEnd) &&
717  						(HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter))) {
718  						while (!sc.MatchLineEnd()) {
719  							sc.Forward();
720  						}
721  						QuoteStack.Pop();
722  						sc.SetState(SCE_SH_DEFAULT | QuoteStack.insideCommand);
723  						break;
724  					}
725  				}
726  				if (HereDoc.Quoted || HereDoc.Escaped) {
727  					break;
728  				}
729  				[[fallthrough]];
730  			case SCE_SH_STRING:	
731  			case SCE_SH_PARAM: 
732  			case SCE_SH_BACKTICKS:
733  				if (sc.ch == '\\') {
734  					if (QuoteStack.Current.Style != QuoteStyle::Literal)
735  						sc.Forward();
736  				} else if (sc.ch == QuoteStack.Current.Down) {
737  					if (QuoteStack.CountDown(sc, cmdState)) {
738  						continue;
739  					}
740  				} else if (sc.ch == QuoteStack.Current.Up) {
741  					QuoteStack.Current.Count++;
742  				} else {
743  					if (QuoteStack.Current.Style == QuoteStyle::String ||
744  						QuoteStack.Current.Style == QuoteStyle::HereDoc ||
745  						QuoteStack.Current.Style == QuoteStyle::LString
746  					) {	
747  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
748  						if (sc.ch == '`') {
749  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
750  							if (stylingInside) {
751  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
752  							}
753  						} else if (sc.ch == '$') {
754  							QuoteStack.Expand(sc, cmdState, stylingInside);
755  							continue;
756  						}
757  					} else if (QuoteStack.Current.Style == QuoteStyle::Command ||
758  							   QuoteStack.Current.Style == QuoteStyle::Parameter ||
759  							   QuoteStack.Current.Style == QuoteStyle::Backtick
760  					) {	
761  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
762  						if (sc.ch == '\'') {
763  							if (stylingInside) {
764  								QuoteStack.State = sc.state;
765  								sc.SetState(SCE_SH_CHARACTER | insideCommand);
766  							} else {
767  								QuoteStack.Push(sc.ch, QuoteStyle::Literal, sc.state);
768  							}
769  						} else if (sc.ch == '\"') {
770  							QuoteStack.Push(sc.ch, QuoteStyle::String, sc.state);
771  							if (stylingInside) {
772  								sc.SetState(SCE_SH_STRING | insideCommand);
773  							}
774  						} else if (sc.ch == '`') {
775  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
776  							if (stylingInside) {
777  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
778  							}
779  						} else if (sc.ch == '$') {
780  							QuoteStack.Expand(sc, cmdState, stylingInside);
781  							continue;
782  						}
783  					}
784  				}
785  				break;
786  			case SCE_SH_CHARACTER: 
787  				if (sc.ch == '\'') {
788  					sc.ForwardSetState(QuoteStack.State | insideCommand);
789  					continue;
790  				}
791  				break;
792  		}
793  		if (HereDoc.State == 1 && sc.MatchLineEnd()) {
794  			HereDoc.State = 2;
795  			if (HereDoc.Quoted) {
796  				if (MaskCommand(sc.state) == SCE_SH_HERE_DELIM) {
797  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
798  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
799  				} else {
800  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
801  					QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
802  				}
803  			} else if (HereDoc.DelimiterLength == 0) {
804  				sc.ChangeState(SCE_SH_ERROR | insideCommand);
805  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
806  			} else {
807  				sc.SetState(SCE_SH_HERE_Q | insideCommand);
808  				QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
809  			}
810  		}
811  		if (stylePrev != SCE_SH_DEFAULT && MaskCommand(sc.state) == SCE_SH_DEFAULT) {
812  			cmdState = cmdStateNew;
813  		}
814  		if (MaskCommand(sc.state) == SCE_SH_DEFAULT) {
815  			if (sc.ch == '\\') {
816  				sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
817  				if (sc.chNext == '\r' || sc.chNext == '\n')
818  					sc.SetState(SCE_SH_OPERATOR | insideCommand);
819  			} else if (IsADigit(sc.ch)) {
820  				sc.SetState(SCE_SH_NUMBER | insideCommand);
821  				numBase = BASH_BASE_DECIMAL;
822  				if (sc.ch == '0') {	
823  					if (sc.chNext == 'x' || sc.chNext == 'X') {
824  						numBase = BASH_BASE_HEX;
825  						sc.Forward();
826  					} else if (IsADigit(sc.chNext)) {
827  #ifdef PEDANTIC_OCTAL
828  						numBase = BASH_BASE_OCTAL;
829  #else
830  						numBase = BASH_BASE_HEX;
831  #endif
832  					}
833  				}
834  			} else if (setWordStart.Contains(sc.ch)) {
835  				sc.SetState(SCE_SH_WORD | insideCommand);
836  			} else if (sc.ch == '#') {
837  				if (stylePrev != SCE_SH_WORD && stylePrev != SCE_SH_IDENTIFIER &&
838  					(sc.currentPos == 0 || setMetaCharacter.Contains(sc.chPrev))) {
839  					sc.SetState(SCE_SH_COMMENTLINE | insideCommand);
840  				} else {
841  					sc.SetState(SCE_SH_WORD | insideCommand);
842  				}
843  				if (cmdState == CmdState::Arithmetic) {
844  					if (sc.chPrev == '[') {	
845  						sc.SetState(SCE_SH_WORD | insideCommand);
846  						if (sc.chNext == '#') {
847  							sc.Forward();
848  						}
849  					} else if (sc.Match("##^") && IsUpperCase(sc.GetRelative(3))) {	
850  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
851  						sc.Forward(3);
852  					} else if (sc.chNext == '#' && !IsASpace(sc.GetRelative(2))) {	
853  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
854  						sc.Forward(2);
855  					} else if (setWordStart.Contains(sc.chNext)) {	
856  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
857  					}
858  				}
859  			} else if (sc.ch == '\"') {
860  				sc.SetState(SCE_SH_STRING | insideCommand);
861  				QuoteStack.Start(sc.ch, QuoteStyle::String, SCE_SH_DEFAULT);
862  			} else if (sc.ch == '\'') {
863  				QuoteStack.State = SCE_SH_DEFAULT;
864  				sc.SetState(SCE_SH_CHARACTER | insideCommand);
865  			} else if (sc.ch == '`') {
866  				sc.SetState(SCE_SH_BACKTICKS | insideCommand);
867  				QuoteStack.Start(sc.ch, QuoteStyle::Backtick, SCE_SH_DEFAULT);
868  			} else if (sc.ch == '$') {
869  				QuoteStack.Expand(sc, cmdState, true);
870  				continue;
871  			} else if (cmdState != CmdState::Arithmetic && sc.Match('<', '<')) {
872  				sc.SetState(SCE_SH_HERE_DELIM | insideCommand);
873  				HereDoc.State = 0;
874  				if (sc.GetRelative(2) == '-') {	
875  					HereDoc.Indent = true;
876  					sc.Forward();
877  				} else {
878  					HereDoc.Indent = false;
879  				}
880  			} else if (sc.ch == '-'	&&	
881  					   setSingleCharOp.Contains(sc.chNext) &&
882  					   !setWord.Contains(sc.GetRelative(2)) &&
883  					   IsASpace(sc.chPrev)) {
884  				sc.SetState(SCE_SH_WORD | insideCommand);
885  				sc.Forward();
886  			} else if (setBashOperator.Contains(sc.ch)) {
887  				bool isCmdDelim = false;
888  				sc.SetState(SCE_SH_OPERATOR | insideCommand);
889  				if (QuoteStack.Current.Style == QuoteStyle::Arithmetic || QuoteStack.Current.Style == QuoteStyle::CommandInside) {
890  					if (sc.ch == QuoteStack.Current.Down) {
891  						if (QuoteStack.CountDown(sc, cmdState)) {
892  							continue;
893  						}
894  					} else if (sc.ch == QuoteStack.Current.Up) {
895  						QuoteStack.Current.Count++;
896  					}
897  				}
898  				if (cmdState != CmdState::Arithmetic && sc.ch == '(' && sc.chNext != '(') {
899  					const int i = GlobScan(sc);
900  					if (i > 1) {
901  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
902  						sc.Forward(i + 1);
903  						continue;
904  					}
905  				}
906  				if (cmdState == CmdState::Start
907  				 || cmdState == CmdState::Body) {
908  					if (sc.Match('(', '(')) {
909  						cmdState = CmdState::Arithmetic;
910  						sc.Forward();
911  					} else if (sc.Match('[', '[') && IsASpace(sc.GetRelative(2))) {
912  						cmdState = CmdState::Test;
913  						testExprType = TestExprType::DoubleBracket;
914  						sc.Forward();
915  					} else if (sc.ch == '[' && IsASpace(sc.chNext)) {
916  						cmdState = CmdState::Test;
917  						testExprType = TestExprType::SingleBracket;
918  					}
919  				}
920  				if (cmdState == CmdState::Word && sc.Match('(', '(')) {
921  					cmdState = CmdState::Arithmetic;
922  					sc.Forward(2);
923  					continue;
924  				}
925  				if (cmdState == CmdState::Start
926  				 || cmdState == CmdState::Body
927  				 || cmdState == CmdState::Word
928  				 || (cmdState == CmdState::Test && testExprType == TestExprType::Test)) {
929  					char s[10];
930  					s[0] = static_cast<char>(sc.ch);
931  					if (setBashOperator.Contains(sc.chNext)) {
932  						s[1] = static_cast<char>(sc.chNext);
933  						s[2] = '\0';
934  						isCmdDelim = cmdDelimiter.InList(s);
935  						if (isCmdDelim)
936  							sc.Forward();
937  					}
938  					if (!isCmdDelim) {
939  						s[1] = '\0';
940  						isCmdDelim = cmdDelimiter.InList(s);
941  					}
942  					if (isCmdDelim) {
943  						cmdState = CmdState::Delimiter;
944  						sc.Forward();
945  						continue;
946  					}
947  				}
948  				if (cmdState == CmdState::Arithmetic && sc.Match(')', ')')) {
949  					cmdState = CmdState::Body;
950  					sc.Forward();
951  				} else if (cmdState == CmdState::Test && IsASpace(sc.chPrev)) {
952  					if (sc.Match(']', ']') && testExprType == TestExprType::DoubleBracket) {
953  						sc.Forward();
954  						cmdState = CmdState::Body;
955  					} else if (sc.ch == ']' && testExprType == TestExprType::SingleBracket) {
956  						cmdState = CmdState::Body;
957  					}
958  				}
959  			}
960  		}
961  		sc.Forward();
962  	}
963  	sc.Complete();
964  	if (MaskCommand(sc.state) == SCE_SH_HERE_Q) {
965  		styler.ChangeLexerState(sc.currentPos, styler.Length());
966  	}
967  	sc.Complete();
968  }
969  void SCI_METHOD LexerBash::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess) {
970  	if(!options.fold)
971  		return;
972  	LexAccessor styler(pAccess);
973  	const Sci_PositionU endPos = startPos + length;
974  	int visibleChars = 0;
975  	int skipHereCh = 0;
976  	Sci_Position lineCurrent = styler.GetLine(startPos);
977  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
978  	int levelCurrent = levelPrev;
979  	char chNext = styler[startPos];
980  	int styleNext = MaskCommand(styler.StyleIndexAt(startPos));
981  	char word[8] = { '\0' }; 
982  	unsigned int wordlen = 0;
983  	for (Sci_PositionU i = startPos; i < endPos; i++) {
984  		const char ch = chNext;
985  		chNext = styler.SafeGetCharAt(i + 1);
986  		const int style = styleNext;
987  		styleNext = MaskCommand(styler.StyleIndexAt(i + 1));
988  		const bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
989  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler))
990  		{
991  			if (!IsCommentLine(lineCurrent - 1, styler)
992  				&& IsCommentLine(lineCurrent + 1, styler))
993  				levelCurrent++;
994  			else if (IsCommentLine(lineCurrent - 1, styler)
995  					 && !IsCommentLine(lineCurrent + 1, styler))
996  				levelCurrent--;
997  		}
998  		if (style == SCE_SH_WORD) {
999  			if ((wordlen + 1) < sizeof(word))
1000  				word[wordlen++] = ch;
1001  			if (styleNext != style) {
1002  				word[wordlen] = '\0';
1003  				wordlen = 0;
1004  				if (strcmp(word, "if") == 0 || strcmp(word, "case") == 0 || strcmp(word, "do") == 0) {
1005  					levelCurrent++;
1006  				} else if (strcmp(word, "fi") == 0 || strcmp(word, "esac") == 0 || strcmp(word, "done") == 0) {
1007  					levelCurrent--;
1008  				}
1009  			}
1010  		}
1011  		if (style == SCE_SH_OPERATOR) {
1012  			if (ch == '{') {
1013  				levelCurrent++;
1014  			} else if (ch == '}') {
1015  				levelCurrent--;
1016  			}
1017  		}
1018  		if (style == SCE_SH_HERE_DELIM) {
1019  			if (ch == '<' && chNext == '<') {
1020  				if (styler.SafeGetCharAt(i + 2) == '<') {
1021  					skipHereCh = 1;
1022  				} else {
1023  					if (skipHereCh == 0) {
1024  						levelCurrent++;
1025  					} else {
1026  						skipHereCh = 0;
1027  					}
1028  				}
1029  			}
1030  		} else if (style == SCE_SH_HERE_Q && styler.StyleAt(i+1) == SCE_SH_DEFAULT) {
1031  			levelCurrent--;
1032  		}
1033  		if (atEOL) {
1034  			int lev = levelPrev;
1035  			if (visibleChars == 0 && options.foldCompact)
1036  				lev |= SC_FOLDLEVELWHITEFLAG;
1037  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1038  				lev |= SC_FOLDLEVELHEADERFLAG;
1039  			if (lev != styler.LevelAt(lineCurrent)) {
1040  				styler.SetLevel(lineCurrent, lev);
1041  			}
1042  			lineCurrent++;
1043  			levelPrev = levelCurrent;
1044  			visibleChars = 0;
1045  		}
1046  		if (!isspacechar(ch))
1047  			visibleChars++;
1048  	}
1049  	const int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1050  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1051  }
1052  LexerModule lmBash(SCLEX_BASH, LexerBash::LexerFactoryBash, "bash", bashWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <map>
10  #include <functional>
11  #include "ILexer.h"
12  #include "Scintilla.h"
13  #include "SciLexer.h"
14  #include "WordList.h"
15  #include "LexAccessor.h"
16  #include "StyleContext.h"
17  #include "CharacterSet.h"
18  #include "LexerModule.h"
19  #include "OptionSet.h"
20  #include "DefaultLexer.h"
21  using namespace Scintilla;
22  using namespace Lexilla;
23  #define HERE_DELIM_MAX 256		
24  #define PERLNUM_BINARY		1	
25  #define PERLNUM_OCTAL		2
26  #define PERLNUM_FLOAT_EXP	3	
27  #define PERLNUM_HEX			4	
28  #define PERLNUM_DECIMAL		5	
29  #define PERLNUM_VECTOR		6
30  #define PERLNUM_V_VECTOR	7
31  #define PERLNUM_BAD			8
32  #define BACK_NONE		0	
33  #define BACK_OPERATOR	1	
34  #define BACK_KEYWORD	2	
35  #define SUB_BEGIN		0	
36  #define SUB_HAS_PROTO	1	
37  #define SUB_HAS_ATTRIB	2	
38  #define SUB_HAS_MODULE	3	
39  #define SUB_HAS_SUB		4	
40  #define	INTERPOLATE_SHIFT	(SCE_PL_STRING_VAR - SCE_PL_STRING)
41  static bool isPerlKeyword(Sci_PositionU start, Sci_PositionU end, WordList &keywords, LexAccessor &styler) {
42  	char s[100];
43  	Sci_PositionU i, len = end - start;
44  	if (len > 30) { len = 30; }
45  	for (i = 0; i < len; i++, start++) s[i] = styler[start];
46  	s[i] = '\0';
47  	return keywords.InList(s);
48  }
49  static int disambiguateBareword(LexAccessor &styler, Sci_PositionU bk, Sci_PositionU fw,
50          int backFlag, Sci_PositionU backPos, Sci_PositionU endPos) {
51  	int result = 0;
52  	bool moreback = false;		
53  	bool brace = false;			
54  	if (backFlag == BACK_NONE)
55  		return result;
56  	if (backPos <= static_cast<Sci_PositionU>(styler.LineStart(styler.GetLine(bk))))
57  		moreback = true;
58  	bk = backPos - 1;
59  	int ch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
60  	if (ch == '{' && !moreback) {
61  		brace = true;
62  	} else if ((ch == '&' && styler.SafeGetCharAt(bk - 1) != '&')
63  	        || styler.Match(bk - 1, "->")
64  	        || styler.Match(bk - 1, "::")
65  	        || styler.Match(bk - 2, "sub")) {
66  		result |= 1;
67  	}
68  	if ((ch == '{' || ch == '(' || ch == '['|| ch == ',')
69  	        && fw < endPos) {
70  		while (IsASpaceOrTab(ch = static_cast<unsigned char>(styler.SafeGetCharAt(fw)))
71  		        && fw < endPos) {
72  			fw++;
73  		}
74  		if ((ch == '}' && brace)
75  		        || styler.Match(fw, "=>")) {
76  			result |= 2;
77  		}
78  	}
79  	return result;
80  }
81  static void skipWhitespaceComment(LexAccessor &styler, Sci_PositionU &p) {
82  	while (p > 0) {
83  		const int style = styler.StyleAt(p);
84  		if (style != SCE_PL_DEFAULT && style != SCE_PL_COMMENTLINE)
85  			break;
86  		p--;
87  	}
88  }
89  static int findPrevLexeme(LexAccessor &styler, Sci_PositionU &bk, int &style) {
90  	skipWhitespaceComment(styler, bk);
91  	if (bk == 0)
92  		return 0;
93  	int sz = 1;
94  	style = styler.StyleAt(bk);
95  	while (bk > 0) {	
96  		if (styler.StyleAt(bk - 1) == style) {
97  			bk--; sz++;
98  		} else
99  			break;
100  	}
101  	return sz;
102  }
103  static int styleBeforeBracePair(LexAccessor &styler, Sci_PositionU bk) {
104  	int braceCount = 1;
105  	if (bk == 0)
106  		return SCE_PL_DEFAULT;
107  	while (--bk > 0) {
108  		if (styler.StyleAt(bk) == SCE_PL_OPERATOR) {
109  			int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
110  			if (bkch == ';') {	
111  				break;
112  			} else if (bkch == '}') {
113  				braceCount++;
114  			} else if (bkch == '{') {
115  				if (--braceCount == 0) break;
116  			}
117  		}
118  	}
119  	if (bk > 0 && braceCount == 0) {
120  		bk--;
121  		skipWhitespaceComment(styler, bk);
122  		return styler.StyleAt(bk);
123  	}
124  	return SCE_PL_DEFAULT;
125  }
126  static int styleCheckIdentifier(LexAccessor &styler, Sci_PositionU bk) {
127  	if (styler.SafeGetCharAt(bk) == '>')	
128  		return 1;
129  	while (bk > 0 && styler.StyleAt(bk) == SCE_PL_IDENTIFIER) {
130  		bk--;
131  	}
132  	while (bk > 0) {
133  		int bkstyle = styler.StyleAt(bk);
134  		if (bkstyle == SCE_PL_DEFAULT
135  		        || bkstyle == SCE_PL_COMMENTLINE) {
136  		} else if (bkstyle == SCE_PL_OPERATOR) {
137  			if (styler.Match(bk - 1, "->") || styler.Match(bk - 1, "::"))
138  				return 2;
139  		} else
140  			return 3;	
141  		bk--;
142  	}
143  	return 0;
144  }
145  static int podLineScan(LexAccessor &styler, Sci_PositionU &pos, Sci_PositionU endPos) {
146  	int state = -1;
147  	while (pos < endPos) {
148  		int ch = static_cast<unsigned char>(styler.SafeGetCharAt(pos));
149  		if (ch == '\n' || ch == '\r') {
150  			if (ch == '\r' && styler.SafeGetCharAt(pos + 1) == '\n') pos++;
151  			break;
152  		}
153  		if (IsASpaceOrTab(ch)) {	
154  			if (state == -1)
155  				state = SCE_PL_DEFAULT;
156  		} else if (state == SCE_PL_DEFAULT) {	
157  			state = SCE_PL_POD_VERB;
158  		} else if (state != SCE_PL_POD_VERB) {	
159  			state = SCE_PL_POD;
160  		}
161  		pos++;
162  	}
163  	if (state == -1)
164  		state = SCE_PL_DEFAULT;
165  	return state;
166  }
167  static bool styleCheckSubPrototype(LexAccessor &styler, Sci_PositionU bk) {
168  	styler.Flush();
169  	int state = SUB_BEGIN;
170  	do {
171  		int style2 = SCE_PL_DEFAULT;
172  		Sci_PositionU pos2 = bk;
173  		int len2 = findPrevLexeme(styler, pos2, style2);
174  		int style1 = SCE_PL_DEFAULT;
175  		Sci_PositionU pos1 = pos2;
176  		if (pos1 > 0) pos1--;
177  		int len1 = findPrevLexeme(styler, pos1, style1);
178  		if (len1 == 0 || len2 == 0)		
179  			break;
180  		if (style1 == SCE_PL_OPERATOR && len1 == 1 &&
181  		    styler.SafeGetCharAt(pos1) == ':') {	
182  			if (style2 == SCE_PL_IDENTIFIER || style2 == SCE_PL_WORD) {
183  				if (len2 == 9 && styler.Match(pos2, "prototype")) {	
184  					if (state == SUB_BEGIN) {
185  						state = SUB_HAS_PROTO;
186  					} else
187  						break;
188  				} else {	
189  					if (state == SUB_HAS_PROTO || state == SUB_HAS_ATTRIB) {
190  						state = SUB_HAS_ATTRIB;
191  					} else
192  						break;
193  				}
194  			} else
195  				break;
196  		} else if (style1 == SCE_PL_OPERATOR && len1 == 2 &&
197  		           styler.Match(pos1, "::")) {	
198  			if (style2 == SCE_PL_IDENTIFIER) {	
199  				state = SUB_HAS_MODULE;
200  			} else
201  				break;
202  		} else if (style1 == SCE_PL_WORD && len1 == 3 &&
203  		           styler.Match(pos1, "sub")) {	
204  			if (style2 == SCE_PL_IDENTIFIER) {	
205  				state = SUB_HAS_SUB;
206  			} else
207  				break;
208  		} else
209  			break;
210  		bk = pos1;			
211  		if (bk > 0) bk--;
212  	} while (state != SUB_HAS_SUB);
213  	return (state == SUB_HAS_SUB);
214  }
215  static int actualNumStyle(int numberStyle) {
216  	if (numberStyle == PERLNUM_VECTOR || numberStyle == PERLNUM_V_VECTOR) {
217  		return SCE_PL_STRING;
218  	} else if (numberStyle == PERLNUM_BAD) {
219  		return SCE_PL_ERROR;
220  	}
221  	return SCE_PL_NUMBER;
222  }
223  static int opposite(int ch) {
224  	if (ch == '(') return ')';
225  	if (ch == '[') return ']';
226  	if (ch == '{') return '}';
227  	if (ch == '<') return '>';
228  	return ch;
229  }
230  static bool IsCommentLine(Sci_Position line, LexAccessor &styler) {
231  	Sci_Position pos = styler.LineStart(line);
232  	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
233  	for (Sci_Position i = pos; i < eol_pos; i++) {
234  		char ch = styler[i];
235  		int style = styler.StyleAt(i);
236  		if (ch == '#' && style == SCE_PL_COMMENTLINE)
237  			return true;
238  		else if (!IsASpaceOrTab(ch))
239  			return false;
240  	}
241  	return false;
242  }
243  static bool IsPackageLine(Sci_Position line, LexAccessor &styler) {
244  	Sci_Position pos = styler.LineStart(line);
245  	int style = styler.StyleAt(pos);
246  	if (style == SCE_PL_WORD && styler.Match(pos, "package")) {
247  		return true;
248  	}
249  	return false;
250  }
251  static int PodHeadingLevel(Sci_Position pos, LexAccessor &styler) {
252  	int lvl = static_cast<unsigned char>(styler.SafeGetCharAt(pos + 5));
253  	if (lvl >= '1' && lvl <= '4') {
254  		return lvl - '0';
255  	}
256  	return 0;
257  }
258  struct OptionsPerl {
259  	bool fold;
260  	bool foldComment;
261  	bool foldCompact;
262  	bool foldPOD;            
263  	bool foldPackage;        
264  	bool foldCommentExplicit;
265  	bool foldAtElse;
266  	OptionsPerl() {
267  		fold = false;
268  		foldComment = false;
269  		foldCompact = true;
270  		foldPOD = true;
271  		foldPackage = true;
272  		foldCommentExplicit = true;
273  		foldAtElse = false;
274  	}
275  };
276  static const char *const perlWordListDesc[] = {
277  	"Keywords",
278  	0
279  };
280  struct OptionSetPerl : public OptionSet<OptionsPerl> {
281  	OptionSetPerl() {
282  		DefineProperty("fold", &OptionsPerl::fold);
283  		DefineProperty("fold.comment", &OptionsPerl::foldComment);
284  		DefineProperty("fold.compact", &OptionsPerl::foldCompact);
285  		DefineProperty("fold.perl.pod", &OptionsPerl::foldPOD,
286  		        "Set to 0 to disable folding Pod blocks when using the Perl lexer.");
287  		DefineProperty("fold.perl.package", &OptionsPerl::foldPackage,
288  		        "Set to 0 to disable folding packages when using the Perl lexer.");
289  		DefineProperty("fold.perl.comment.explicit", &OptionsPerl::foldCommentExplicit,
290  		        "Set to 0 to disable explicit folding.");
291  		DefineProperty("fold.perl.at.else", &OptionsPerl::foldAtElse,
292  		               "This option enables Perl folding on a \"} else {\" line of an if statement.");
293  		DefineWordListSets(perlWordListDesc);
294  	}
295  };
296  class LexerPerl : public DefaultLexer {
297  	CharacterSet setWordStart;
298  	CharacterSet setWord;
299  	CharacterSet setSpecialVar;
300  	CharacterSet setControlVar;
301  	WordList keywords;
302  	OptionsPerl options;
303  	OptionSetPerl osPerl;
304  public:
305  	LexerPerl() :
306  		DefaultLexer("perl", SCLEX_PERL),
307  		setWordStart(CharacterSet::setAlpha, "_", 0x80, true),
308  		setWord(CharacterSet::setAlphaNum, "_", 0x80, true),
309  		setSpecialVar(CharacterSet::setNone, "\"$;<>&`'+,./\\%:=~!?@[]"),
310  		setControlVar(CharacterSet::setNone, "ACDEFHILMNOPRSTVWX") {
311  	}
312  	virtual ~LexerPerl() {
313  	}
314  	void SCI_METHOD Release() override {
315  		delete this;
316  	}
317  	int SCI_METHOD Version() const override {
318  		return lvRelease5;
319  	}
320  	const char *SCI_METHOD PropertyNames() override {
321  		return osPerl.PropertyNames();
322  	}
323  	int SCI_METHOD PropertyType(const char *name) override {
324  		return osPerl.PropertyType(name);
325  	}
326  	const char *SCI_METHOD DescribeProperty(const char *name) override {
327  		return osPerl.DescribeProperty(name);
328  	}
329  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
330  	const char * SCI_METHOD PropertyGet(const char *key) override {
331  		return osPerl.PropertyGet(key);
332  	}
333  	const char *SCI_METHOD DescribeWordListSets() override {
334  		return osPerl.DescribeWordListSets();
335  	}
336  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
337  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
338  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
339  	void *SCI_METHOD PrivateCall(int, void *) override {
340  		return 0;
341  	}
342  	static ILexer5 *LexerFactoryPerl() {
343  		return new LexerPerl();
344  	}
345  	int InputSymbolScan(StyleContext &sc);
346  	void InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern=false);
347  };
348  Sci_Position SCI_METHOD LexerPerl::PropertySet(const char *key, const char *val) {
349  	if (osPerl.PropertySet(&options, key, val)) {
350  		return 0;
351  	}
352  	return -1;
353  }
354  Sci_Position SCI_METHOD LexerPerl::WordListSet(int n, const char *wl) {
355  	WordList *wordListN = 0;
356  	switch (n) {
357  	case 0:
358  		wordListN = &keywords;
359  		break;
360  	}
361  	Sci_Position firstModification = -1;
362  	if (wordListN) {
363  		WordList wlNew;
364  		wlNew.Set(wl);
365  		if (*wordListN != wlNew) {
366  			wordListN->Set(wl);
367  			firstModification = 0;
368  		}
369  	}
370  	return firstModification;
371  }
372  int LexerPerl::InputSymbolScan(StyleContext &sc) {
373  	int c, sLen = 0;
374  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
375  		if (c == '\r' || c == '\n') {
376  			return 0;
377  		} else if (c == '>') {
378  			if (sc.Match("<=>"))	
379  				return 0;
380  			return sLen;
381  		}
382  	}
383  	return 0;
384  }
385  void LexerPerl::InterpolateSegment(StyleContext &sc, int maxSeg, bool isPattern) {
386  	while (maxSeg > 0) {
387  		bool isVar = false;
388  		int sLen = 0;
389  		if ((maxSeg > 1) && (sc.ch == '$' || sc.ch == '@')) {
390  			bool braces = false;
391  			sLen = 1;
392  			if (sc.ch == '$' && sc.chNext == '#') {	
393  				sLen++;
394  			}
395  			while ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '$'))	
396  				sLen++;
397  			if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '{')) {	
398  				sLen++;
399  				braces = true;
400  			}
401  			if (maxSeg > sLen) {
402  				int c = sc.GetRelativeCharacter(sLen);
403  				if (setWordStart.Contains(c)) {	
404  					sLen++;
405  					isVar = true;
406  					while (maxSeg > sLen) {
407  						if (!setWord.Contains(sc.GetRelativeCharacter(sLen)))
408  							break;
409  						sLen++;
410  					}
411  				} else if (braces && IsADigit(c) && (sLen == 2)) {	
412  					sLen++;
413  					isVar = true;
414  				}
415  			}
416  			if (braces) {
417  				if ((maxSeg > sLen) && (sc.GetRelativeCharacter(sLen) == '}')) {	
418  					sLen++;
419  				} else
420  					isVar = false;
421  			}
422  		}
423  		if (!isVar && (maxSeg > 1)) {	
424  			int c = sc.chNext;
425  			if (sc.ch == '$') {
426  				sLen = 1;
427  				if (IsADigit(c)) {	
428  					sLen++;
429  					isVar = true;
430  					while ((maxSeg > sLen) && IsADigit(sc.GetRelativeCharacter(sLen)))
431  						sLen++;
432  				} else if (setSpecialVar.Contains(c)) {	
433  					sLen++;
434  					isVar = true;
435  				} else if (!isPattern && ((c == '(') || (c == ')') || (c == '|'))) {	
436  					sLen++;
437  					isVar = true;
438  				} else if (c == '^') {	
439  					sLen++;
440  					if ((maxSeg > sLen) && setControlVar.Contains(sc.GetRelativeCharacter(sLen))) {
441  						sLen++;
442  						isVar = true;
443  					}
444  				}
445  			} else if (sc.ch == '@') {
446  				sLen = 1;
447  				if (!isPattern && ((c == '+') || (c == '-'))) {	
448  					sLen++;
449  					isVar = true;
450  				}
451  			}
452  		}
453  		if (isVar) {	
454  			if (sc.state < SCE_PL_STRING_VAR)
455  				sc.SetState(sc.state + INTERPOLATE_SHIFT);
456  			sc.Forward(sLen);
457  			maxSeg -= sLen;
458  		} else {
459  			if (sc.state >= SCE_PL_STRING_VAR)
460  				sc.SetState(sc.state - INTERPOLATE_SHIFT);
461  			sc.Forward();
462  			maxSeg--;
463  		}
464  	}
465  	if (sc.state >= SCE_PL_STRING_VAR)
466  		sc.SetState(sc.state - INTERPOLATE_SHIFT);
467  }
468  void SCI_METHOD LexerPerl::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
469  	LexAccessor styler(pAccess);
470  	WordList reWords;
471  	reWords.Set("elsif if split while");
472  	CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMAC");
473  	CharacterSet setPerlOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;>,?!.~");
474  	CharacterSet setQDelim(CharacterSet::setNone, "qrwx");
475  	CharacterSet setModifiers(CharacterSet::setAlpha);
476  	CharacterSet setPreferRE(CharacterSet::setNone, "*/<%");
477  	CharacterSet setVar(CharacterSet::setAlphaNum, "#$_'", 0x80, true);
478  	CharacterSet setArray(CharacterSet::setAlpha, "#$_+-", 0x80, true);
479  	CharacterSet setHash(CharacterSet::setAlpha, "#$_!^+-", 0x80, true);
480  	CharacterSet &setPOD = setModifiers;
481  	CharacterSet setNonHereDoc(CharacterSet::setDigits, "=$@");
482  	CharacterSet setHereDocDelim(CharacterSet::setAlphaNum, "_");
483  	CharacterSet setSubPrototype(CharacterSet::setNone, "\\[$@%&*+];_ \t");
484  	CharacterSet setRepetition(CharacterSet::setDigits, ")\"'");
485  	CharacterSet setFormatStart(CharacterSet::setAlpha, "_=");
486  	CharacterSet &setFormat = setHereDocDelim;
487  	class HereDocCls {	
488  	public:
489  		int State;
490  		int Quote;		
491  		bool Quoted;		
492  		bool StripIndent;	
493  		int DelimiterLength;	
494  		char Delimiter[HERE_DELIM_MAX];	
495  		HereDocCls() {
496  			State = 0;
497  			Quote = 0;
498  			Quoted = false;
499  			StripIndent = false;
500  			DelimiterLength = 0;
501  			Delimiter[0] = '\0';
502  		}
503  		void Append(int ch) {
504  			Delimiter[DelimiterLength++] = static_cast<char>(ch);
505  			Delimiter[DelimiterLength] = '\0';
506  		}
507  		~HereDocCls() {
508  		}
509  	};
510  	HereDocCls HereDoc;		
511  	class QuoteCls {	
512  	public:
513  		int Rep;
514  		int Count;
515  		int Up, Down;
516  		QuoteCls() {
517  			New(1);
518  		}
519  		void New(int r = 1) {
520  			Rep   = r;
521  			Count = 0;
522  			Up    = '\0';
523  			Down  = '\0';
524  		}
525  		void Open(int u) {
526  			Count++;
527  			Up    = u;
528  			Down  = opposite(Up);
529  		}
530  	};
531  	QuoteCls Quote;
532  	int numState = PERLNUM_DECIMAL;
533  	int dotCount = 0;
534  	Sci_PositionU endPos = startPos + length;
535  	if (initStyle == SCE_PL_HERE_Q
536  	    || initStyle == SCE_PL_HERE_QQ
537  	    || initStyle == SCE_PL_HERE_QX
538  	    || initStyle == SCE_PL_FORMAT
539  	    || initStyle == SCE_PL_HERE_QQ_VAR
540  	    || initStyle == SCE_PL_HERE_QX_VAR
541  	   ) {
542  		int delim = (initStyle == SCE_PL_FORMAT) ? SCE_PL_FORMAT_IDENT:SCE_PL_HERE_DELIM;
543  		while ((startPos > 1) && (styler.StyleAt(startPos) != delim)) {
544  			startPos--;
545  		}
546  		startPos = styler.LineStart(styler.GetLine(startPos));
547  		initStyle = styler.StyleAt(startPos - 1);
548  	}
549  	if (initStyle == SCE_PL_STRING
550  	    || initStyle == SCE_PL_STRING_QQ
551  	    || initStyle == SCE_PL_BACKTICKS
552  	    || initStyle == SCE_PL_STRING_QX
553  	    || initStyle == SCE_PL_REGEX
554  	    || initStyle == SCE_PL_STRING_QR
555  	    || initStyle == SCE_PL_REGSUBST
556  	    || initStyle == SCE_PL_STRING_VAR
557  	    || initStyle == SCE_PL_STRING_QQ_VAR
558  	    || initStyle == SCE_PL_BACKTICKS_VAR
559  	    || initStyle == SCE_PL_STRING_QX_VAR
560  	    || initStyle == SCE_PL_REGEX_VAR
561  	    || initStyle == SCE_PL_STRING_QR_VAR
562  	    || initStyle == SCE_PL_REGSUBST_VAR
563  	   ) {
564  		int otherStyle = (initStyle >= SCE_PL_STRING_VAR) ?
565  			initStyle - INTERPOLATE_SHIFT : initStyle + INTERPOLATE_SHIFT;
566  		while (startPos > 1) {
567  			int st = styler.StyleAt(startPos - 1);
568  			if ((st != initStyle) && (st != otherStyle))
569  				break;
570  			startPos--;
571  		}
572  		initStyle = SCE_PL_DEFAULT;
573  	} else if (initStyle == SCE_PL_STRING_Q
574  	        || initStyle == SCE_PL_STRING_QW
575  	        || initStyle == SCE_PL_XLAT
576  	        || initStyle == SCE_PL_CHARACTER
577  	        || initStyle == SCE_PL_NUMBER
578  	        || initStyle == SCE_PL_IDENTIFIER
579  	        || initStyle == SCE_PL_ERROR
580  	        || initStyle == SCE_PL_SUB_PROTOTYPE
581  	   ) {
582  		while ((startPos > 1) && (styler.StyleAt(startPos - 1) == initStyle)) {
583  			startPos--;
584  		}
585  		initStyle = SCE_PL_DEFAULT;
586  	} else if (initStyle == SCE_PL_POD
587  	        || initStyle == SCE_PL_POD_VERB
588  	          ) {
589  		Sci_Position ln = styler.GetLine(startPos);
590  		if (ln > 0) {
591  			initStyle = styler.StyleAt(styler.LineStart(--ln));
592  			if (initStyle == SCE_PL_POD || initStyle == SCE_PL_POD_VERB) {
593  				while (ln > 0 && styler.GetLineState(ln) == SCE_PL_DEFAULT)
594  					ln--;
595  			}
596  			startPos = styler.LineStart(++ln);
597  			initStyle = styler.StyleAt(startPos - 1);
598  		} else {
599  			startPos = 0;
600  			initStyle = SCE_PL_DEFAULT;
601  		}
602  	}
603  	int backFlag = BACK_NONE;
604  	Sci_PositionU backPos = startPos;
605  	if (backPos > 0) {
606  		backPos--;
607  		skipWhitespaceComment(styler, backPos);
608  		if (styler.StyleAt(backPos) == SCE_PL_OPERATOR)
609  			backFlag = BACK_OPERATOR;
610  		else if (styler.StyleAt(backPos) == SCE_PL_WORD)
611  			backFlag = BACK_KEYWORD;
612  		backPos++;
613  	}
614  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
615  	for (; sc.More(); sc.Forward()) {
616  		switch (sc.state) {
617  		case SCE_PL_OPERATOR:
618  			sc.SetState(SCE_PL_DEFAULT);
619  			backFlag = BACK_OPERATOR;
620  			backPos = sc.currentPos;
621  			break;
622  		case SCE_PL_IDENTIFIER:		
623  			if ((!setWord.Contains(sc.ch) && sc.ch != '\'')
624  			        || sc.Match('.', '.')
625  			        || sc.chPrev == '>') {	
626  				sc.SetState(SCE_PL_DEFAULT);
627  			}
628  			break;
629  		case SCE_PL_WORD:		
630  			if (!setWord.Contains(sc.ch)) {
631  				char s[100];
632  				sc.GetCurrent(s, sizeof(s));
633  				if ((strcmp(s, "__DATA__") == 0) || (strcmp(s, "__END__") == 0)) {
634  					sc.ChangeState(SCE_PL_DATASECTION);
635  				} else {
636  					if ((strcmp(s, "format") == 0)) {
637  						sc.SetState(SCE_PL_FORMAT_IDENT);
638  						HereDoc.State = 0;
639  					} else {
640  						sc.SetState(SCE_PL_DEFAULT);
641  					}
642  					backFlag = BACK_KEYWORD;
643  					backPos = sc.currentPos;
644  				}
645  			}
646  			break;
647  		case SCE_PL_SCALAR:
648  		case SCE_PL_ARRAY:
649  		case SCE_PL_HASH:
650  		case SCE_PL_SYMBOLTABLE:
651  			if (sc.Match(':', ':')) {	
652  				sc.Forward();
653  			} else if (!setVar.Contains(sc.ch)) {
654  				if (sc.LengthCurrent() == 1) {
655  					sc.Forward();
656  				}
657  				sc.SetState(SCE_PL_DEFAULT);
658  			}
659  			break;
660  		case SCE_PL_NUMBER:
661  			if (sc.ch == '.') {
662  				if (sc.chNext == '.') {
663  				} else if (numState <= PERLNUM_FLOAT_EXP) {
664  					sc.SetState(SCE_PL_OPERATOR);
665  					break;
666  				} else {	
667  					dotCount++;
668  					if (numState == PERLNUM_DECIMAL) {
669  						if (dotCount <= 1)	
670  							break;
671  						if (IsADigit(sc.chNext)) {	
672  							numState = PERLNUM_VECTOR;
673  							break;
674  						}
675  					} else if (numState == PERLNUM_HEX) {
676  						if (dotCount <= 1 && IsADigit(sc.chNext, 16)) {
677  							break;	
678  						} else {
679  							sc.SetState(SCE_PL_OPERATOR);
680  							break;
681  						}
682  					} else if (IsADigit(sc.chNext))	
683  						break;
684  				}
685  			} else if (sc.ch == '_') {
686  				break;
687  			} else if (numState == PERLNUM_DECIMAL) {
688  				if (sc.ch == 'E' || sc.ch == 'e') {	
689  					numState = PERLNUM_FLOAT_EXP;
690  					if (sc.chNext == '+' || sc.chNext == '-') {
691  						sc.Forward();
692  					}
693  					break;
694  				} else if (IsADigit(sc.ch))
695  					break;
696  			} else if (numState == PERLNUM_HEX) {
697  				if (sc.ch == 'P' || sc.ch == 'p') {	
698  					numState = PERLNUM_FLOAT_EXP;
699  					if (sc.chNext == '+' || sc.chNext == '-') {
700  						sc.Forward();
701  					}
702  					break;
703  				} else if (IsADigit(sc.ch, 16))
704  					break;
705  			} else if (numState == PERLNUM_VECTOR || numState == PERLNUM_V_VECTOR) {
706  				if (IsADigit(sc.ch))	
707  					break;
708  				if (setWord.Contains(sc.ch) && dotCount == 0) {	
709  					sc.ChangeState(SCE_PL_IDENTIFIER);
710  					break;
711  				}
712  			} else if (IsADigit(sc.ch)) {
713  				if (numState == PERLNUM_FLOAT_EXP) {
714  					break;
715  				} else if (numState == PERLNUM_OCTAL) {
716  					if (sc.ch <= '7') break;
717  				} else if (numState == PERLNUM_BINARY) {
718  					if (sc.ch <= '1') break;
719  				}
720  				numState = PERLNUM_BAD;
721  				break;
722  			}
723  			sc.ChangeState(actualNumStyle(numState));
724  			sc.SetState(SCE_PL_DEFAULT);
725  			break;
726  		case SCE_PL_COMMENTLINE:
727  			if (sc.atLineStart) {
728  				sc.SetState(SCE_PL_DEFAULT);
729  			}
730  			break;
731  		case SCE_PL_HERE_DELIM:
732  			if (HereDoc.State == 0) { 
733  				int delim_ch = sc.chNext;
734  				Sci_Position ws_skip = 0;
735  				HereDoc.State = 1;	
736  				HereDoc.Quote = sc.chNext;
737  				HereDoc.Quoted = false;
<span onclick='openModal()' class='match'>738  				HereDoc.StripIndent = false;
739  				HereDoc.DelimiterLength = 0;
740  				HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
741  				if (delim_ch == '~') { 
</span>742  					sc.Forward();
743  					HereDoc.StripIndent = true;
744  					HereDoc.Quote = delim_ch = sc.chNext;
745  				}
746  				if (IsASpaceOrTab(delim_ch)) {
747  					Sci_PositionU i = sc.currentPos + 1;
748  					while ((i < endPos) && IsASpaceOrTab(delim_ch)) {
749  						i++;
750  						delim_ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
751  					}
752  					ws_skip = i - sc.currentPos - 1;
753  				}
754  				if (delim_ch == '\'' || delim_ch == '"' || delim_ch == '`') {
755  					sc.Forward(ws_skip + 1);
756  					HereDoc.Quote = delim_ch;
757  					HereDoc.Quoted = true;
758  				} else if ((ws_skip == 0 && setNonHereDoc.Contains(sc.chNext))
759  				        || ws_skip > 0) {
760  					sc.ChangeState(SCE_PL_OPERATOR);
761  					sc.ForwardSetState(SCE_PL_DEFAULT);
762  					backFlag = BACK_OPERATOR;
763  					backPos = sc.currentPos;
764  					HereDoc.State = 0;
765  				} else {
766  					if (ws_skip == 0 && HereDoc.Quote == '\\')
767  						sc.Forward();
768  				}
769  			} else if (HereDoc.State == 1) { 
770  				backFlag = BACK_NONE;
771  				if (HereDoc.Quoted) { 
772  					if (sc.ch == HereDoc.Quote) { 
773  						sc.ForwardSetState(SCE_PL_DEFAULT);
774  					} else if (!sc.atLineEnd) {
775  						if (sc.Match('\\', static_cast<char>(HereDoc.Quote))) { 
776  							sc.Forward();
777  						}
778  						if (sc.ch != '\r') {	
779  							int i = 0;			
780  							while (i < sc.width) {
781  								HereDoc.Append(static_cast<unsigned char>(styler.SafeGetCharAt(sc.currentPos + i)));
782  								i++;
783  							}
784  						}
785  					}
786  				} else { 
787  					if (setHereDocDelim.Contains(sc.ch)) {
788  						HereDoc.Append(sc.ch);
789  					} else {
790  						sc.SetState(SCE_PL_DEFAULT);
791  					}
792  				}
793  				if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {
794  					sc.SetState(SCE_PL_ERROR);
795  					HereDoc.State = 0;
796  				}
797  			}
798  			break;
799  		case SCE_PL_HERE_Q:
800  		case SCE_PL_HERE_QQ:
801  		case SCE_PL_HERE_QX:
802  			sc.Complete();
803  			if (HereDoc.StripIndent) {
804  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
805  					sc.Forward();
806  			}
807  			if (HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter)) {
808  				int c = sc.GetRelative(HereDoc.DelimiterLength);
809  				if (c == '\r' || c == '\n') {	
810  					sc.ForwardBytes(HereDoc.DelimiterLength);
811  					sc.SetState(SCE_PL_DEFAULT);
812  					backFlag = BACK_NONE;
813  					HereDoc.State = 0;
814  					if (!sc.atLineEnd)
815  						sc.Forward();
816  					break;
817  				}
818  			}
819  			if (sc.state == SCE_PL_HERE_Q) {	
820  				while (!sc.atLineEnd)
821  					sc.Forward();
822  				break;
823  			}
824  			while (!sc.atLineEnd) {		
825  				int c, sLen = 0, endType = 0;
826  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
827  					if (c == '\\') {
828  						endType = 1; break;
829  					} else if (c == '\r' || c == '\n') {
830  						endType = 2; break;
831  					}
832  					sLen++;
833  				}
834  				if (sLen > 0)	
835  					InterpolateSegment(sc, sLen);
836  				if (endType == 1) {
837  					sc.Forward();
838  					if (sc.ch != '\r' && sc.ch != '\n')
839  						sc.Forward();
840  				} else if (endType == 2) {
841  					if (!sc.atLineEnd)
842  						sc.Forward();
843  				}
844  			}
845  			break;
846  		case SCE_PL_POD:
847  		case SCE_PL_POD_VERB: {
848  				Sci_PositionU fw = sc.currentPos;
849  				Sci_Position ln = styler.GetLine(fw);
850  				if (sc.atLineStart && sc.Match("=cut")) {	
851  					sc.SetState(SCE_PL_POD);
852  					sc.Forward(4);
853  					sc.SetState(SCE_PL_DEFAULT);
854  					styler.SetLineState(ln, SCE_PL_POD);
855  					break;
856  				}
857  				int pod = podLineScan(styler, fw, endPos);	
858  				styler.SetLineState(ln, pod);
859  				if (pod == SCE_PL_DEFAULT) {
860  					if (sc.state == SCE_PL_POD_VERB) {
861  						Sci_PositionU fw2 = fw;
862  						while (fw2 < (endPos - 1) && pod == SCE_PL_DEFAULT) {
863  							fw = fw2++;	
864  							pod = podLineScan(styler, fw2, endPos);
865  							styler.SetLineState(styler.GetLine(fw2), pod);
866  						}
867  						if (pod == SCE_PL_POD) {	
868  							sc.SetState(SCE_PL_POD);
869  						} else
870  							fw = fw2;
871  					}
872  				} else {
873  					if (pod == SCE_PL_POD_VERB	
874  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD)) {
875  						pod = SCE_PL_POD;
876  						styler.SetLineState(ln, pod);
877  					} else if (pod == SCE_PL_POD
878  					        && (styler.GetLineState(ln - 1) == SCE_PL_POD_VERB)) {
879  						pod = SCE_PL_POD_VERB;
880  						styler.SetLineState(ln, pod);
881  					}
882  					sc.SetState(pod);
883  				}
884  				sc.ForwardBytes(fw - sc.currentPos);	
885  			}
886  			break;
887  		case SCE_PL_REGEX:
888  		case SCE_PL_STRING_QR:
889  			if (Quote.Rep <= 0) {
890  				if (!setModifiers.Contains(sc.ch))
891  					sc.SetState(SCE_PL_DEFAULT);
892  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
893  				Quote.Open(sc.ch);
894  			} else {
895  				int c, sLen = 0, endType = 0;
896  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
897  					if (IsASpace(c)) {
898  						break;
899  					} else if (c == '\\' && Quote.Up != '\\') {
900  						endType = 1; break;
901  					} else if (c == Quote.Down) {
902  						Quote.Count--;
903  						if (Quote.Count == 0) {
904  							Quote.Rep--;
905  							break;
906  						}
907  					} else if (c == Quote.Up)
908  						Quote.Count++;
909  					sLen++;
910  				}
911  				if (sLen > 0) {	
912  					if (Quote.Up != '\'') {
913  						InterpolateSegment(sc, sLen, true);
914  					} else		
915  						sc.Forward(sLen);
916  				}
917  				if (endType == 1)
918  					sc.Forward();
919  			}
920  			break;
921  		case SCE_PL_REGSUBST:
922  		case SCE_PL_XLAT:
923  			if (Quote.Rep <= 0) {
924  				if (!setModifiers.Contains(sc.ch))
925  					sc.SetState(SCE_PL_DEFAULT);
926  			} else if (!Quote.Up && !IsASpace(sc.ch)) {
927  				Quote.Open(sc.ch);
928  			} else {
929  				int c, sLen = 0, endType = 0;
930  				bool isPattern = (Quote.Rep == 2);
931  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
932  					if (c == '\\' && Quote.Up != '\\') {
933  						endType = 2; break;
934  					} else if (Quote.Count == 0 && Quote.Rep == 1) {
935  						if (IsASpace(c)) {
936  						} else if (c == '#' && IsASpaceOrTab(sc.GetRelativeCharacter(sLen - 1))) {
937  							endType = 3;
938  						} else
939  							Quote.Open(c);
940  						break;
941  					} else if (c == Quote.Down) {
942  						Quote.Count--;
943  						if (Quote.Count == 0) {
944  							Quote.Rep--;
945  							endType = 1;
946  						}
947  						if (Quote.Up == Quote.Down)
948  							Quote.Count++;
949  						if (endType == 1)
950  							break;
951  					} else if (c == Quote.Up) {
952  						Quote.Count++;
953  					} else if (IsASpace(c))
954  						break;
955  					sLen++;
956  				}
957  				if (sLen > 0) {	
958  					if (sc.state == SCE_PL_REGSUBST && Quote.Up != '\'') {
959  						InterpolateSegment(sc, sLen, isPattern);
960  					} else		
961  						sc.Forward(sLen);
962  				}
963  				if (endType == 2) {
964  					sc.Forward();
965  				} else if (endType == 3)
966  					sc.SetState(SCE_PL_DEFAULT);
967  			}
968  			break;
969  		case SCE_PL_STRING_Q:
970  		case SCE_PL_STRING_QQ:
971  		case SCE_PL_STRING_QX:
972  		case SCE_PL_STRING_QW:
973  		case SCE_PL_STRING:
974  		case SCE_PL_CHARACTER:
975  		case SCE_PL_BACKTICKS:
976  			if (!Quote.Down && !IsASpace(sc.ch)) {
977  				Quote.Open(sc.ch);
978  			} else {
979  				int c, sLen = 0, endType = 0;
980  				while ((c = sc.GetRelativeCharacter(sLen)) != 0) {
981  					if (IsASpace(c)) {
982  						break;
983  					} else if (c == '\\' && Quote.Up != '\\') {
984  						endType = 2; break;
985  					} else if (c == Quote.Down) {
986  						Quote.Count--;
987  						if (Quote.Count == 0) {
988  							endType = 3; break;
989  						}
990  					} else if (c == Quote.Up)
991  						Quote.Count++;
992  					sLen++;
993  				}
994  				if (sLen > 0) {	
995  					switch (sc.state) {
996  					case SCE_PL_STRING:
997  					case SCE_PL_STRING_QQ:
998  					case SCE_PL_BACKTICKS:
999  						InterpolateSegment(sc, sLen);
1000  						break;
1001  					case SCE_PL_STRING_QX:
1002  						if (Quote.Up != '\'') {
1003  							InterpolateSegment(sc, sLen);
1004  							break;
1005  						}
1006  					default:	
1007  						sc.Forward(sLen);
1008  					}
1009  				}
1010  				if (endType == 2) {
1011  					sc.Forward();
1012  				} else if (endType == 3)
1013  					sc.ForwardSetState(SCE_PL_DEFAULT);
1014  			}
1015  			break;
1016  		case SCE_PL_SUB_PROTOTYPE: {
1017  				int i = 0;
1018  				while (setSubPrototype.Contains(sc.GetRelative(i)))
1019  					i++;
1020  				if (sc.GetRelative(i) == ')') {	
1021  					sc.ForwardBytes(i);
1022  					sc.ForwardSetState(SCE_PL_DEFAULT);
1023  				} else {
1024  					sc.ChangeState(SCE_PL_OPERATOR);
1025  					sc.SetState(SCE_PL_DEFAULT);
1026  				}
1027  			}
1028  			break;
1029  		case SCE_PL_FORMAT: {
1030  				sc.Complete();
1031  				if (sc.Match('.')) {
1032  					sc.Forward();
1033  					if (sc.atLineEnd || ((sc.ch == '\r' && sc.chNext == '\n')))
1034  						sc.SetState(SCE_PL_DEFAULT);
1035  				}
1036  				while (!sc.atLineEnd)
1037  					sc.Forward();
1038  			}
1039  			break;
1040  		case SCE_PL_ERROR:
1041  			break;
1042  		}
1043  		switch (sc.state) {
1044  		case SCE_PL_FORMAT_IDENT:
1045  			if (IsASpaceOrTab(sc.ch)) {		
1046  				sc.ChangeState(SCE_PL_DEFAULT);
1047  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1048  					sc.Forward();
1049  				sc.SetState(SCE_PL_FORMAT_IDENT);
1050  			}
1051  			if (setFormatStart.Contains(sc.ch)) {	
1052  				if (sc.ch != '=') {
1053  					do {
1054  						sc.Forward();
1055  					} while (setFormat.Contains(sc.ch));
1056  				}
1057  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
1058  					sc.Forward();
1059  				if (sc.ch == '=') {
1060  					sc.ForwardSetState(SCE_PL_DEFAULT);
1061  					HereDoc.State = 3;
1062  				} else {
1063  					sc.ChangeState(SCE_PL_IDENTIFIER);
1064  					sc.SetState(SCE_PL_DEFAULT);
1065  				}
1066  			} else {
1067  				sc.ChangeState(SCE_PL_DEFAULT);	
1068  			}
1069  			backFlag = BACK_NONE;
1070  			break;
1071  		}
1072  		if (HereDoc.State == 1 && sc.atLineEnd) {
1073  			int st_new = SCE_PL_HERE_QQ;
1074  			HereDoc.State = 2;
1075  			if (HereDoc.Quoted) {
1076  				if (sc.state == SCE_PL_HERE_DELIM) {
1077  					sc.ChangeState(SCE_PL_ERROR);
1078  				}
1079  				switch (HereDoc.Quote) {
1080  				case '\'':
1081  					st_new = SCE_PL_HERE_Q;
1082  					break;
1083  				case '"' :
1084  					st_new = SCE_PL_HERE_QQ;
1085  					break;
1086  				case '`' :
1087  					st_new = SCE_PL_HERE_QX;
1088  					break;
1089  				}
1090  			} else {
1091  				if (HereDoc.Quote == '\\')
1092  					st_new = SCE_PL_HERE_Q;
1093  			}
1094  			sc.SetState(st_new);
1095  		}
1096  		if (HereDoc.State == 3 && sc.atLineEnd) {
1097  			HereDoc.State = 0;
1098  			sc.SetState(SCE_PL_FORMAT);
1099  		}
1100  		if (sc.state == SCE_PL_DEFAULT) {
1101  			if (IsADigit(sc.ch) ||
1102  			        (IsADigit(sc.chNext) && (sc.ch == '.' || sc.ch == 'v'))) {
1103  				sc.SetState(SCE_PL_NUMBER);
1104  				backFlag = BACK_NONE;
1105  				numState = PERLNUM_DECIMAL;
1106  				dotCount = 0;
1107  				if (sc.ch == '0') {		
1108  					if (sc.chNext == 'x' || sc.chNext == 'X') {
1109  						numState = PERLNUM_HEX;
1110  					} else if (sc.chNext == 'b' || sc.chNext == 'B') {
1111  						numState = PERLNUM_BINARY;
1112  					} else if (IsADigit(sc.chNext)) {
1113  						numState = PERLNUM_OCTAL;
1114  					}
1115  					if (numState != PERLNUM_DECIMAL) {
1116  						sc.Forward();
1117  					}
1118  				} else if (sc.ch == 'v') {		
1119  					numState = PERLNUM_V_VECTOR;
1120  				}
1121  			} else if (setWord.Contains(sc.ch)) {
1122  				sc.SetState(SCE_PL_WORD);
1123  				if (sc.chPrev == ':' && sc.GetRelative(-2) == ':') {
1124  					sc.ChangeState(SCE_PL_IDENTIFIER);
1125  				}
1126  				Sci_PositionU bk = sc.currentPos;
1127  				Sci_PositionU fw = sc.currentPos + 1;
1128  				if (sc.ch == 's' && !setWord.Contains(sc.chNext)) {
1129  					sc.ChangeState(SCE_PL_REGSUBST);
1130  					Quote.New(2);
1131  				} else if (sc.ch == 'm' && !setWord.Contains(sc.chNext)) {
1132  					sc.ChangeState(SCE_PL_REGEX);
1133  					Quote.New();
1134  				} else if (sc.ch == 'q' && !setWord.Contains(sc.chNext)) {
1135  					sc.ChangeState(SCE_PL_STRING_Q);
1136  					Quote.New();
1137  				} else if (sc.ch == 'y' && !setWord.Contains(sc.chNext)) {
1138  					sc.ChangeState(SCE_PL_XLAT);
1139  					Quote.New(2);
1140  				} else if (sc.Match('t', 'r') && !setWord.Contains(sc.GetRelative(2))) {
1141  					sc.ChangeState(SCE_PL_XLAT);
1142  					Quote.New(2);
1143  					sc.Forward();
1144  					fw++;
1145  				} else if (sc.ch == 'q' && setQDelim.Contains(sc.chNext)
1146  				        && !setWord.Contains(sc.GetRelative(2))) {
1147  					if (sc.chNext == 'q') sc.ChangeState(SCE_PL_STRING_QQ);
1148  					else if (sc.chNext == 'x') sc.ChangeState(SCE_PL_STRING_QX);
1149  					else if (sc.chNext == 'r') sc.ChangeState(SCE_PL_STRING_QR);
1150  					else sc.ChangeState(SCE_PL_STRING_QW);	
1151  					Quote.New();
1152  					sc.Forward();
1153  					fw++;
1154  				} else if (sc.ch == 'x' && (sc.chNext == '=' ||	
1155  				        !setWord.Contains(sc.chNext) ||
1156  				        (setRepetition.Contains(sc.chPrev) && IsADigit(sc.chNext)))) {
1157  					sc.ChangeState(SCE_PL_OPERATOR);
1158  				}
1159  				if (sc.state == SCE_PL_WORD) {
1160  					while (setWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(fw))))
1161  						fw++;
1162  					if (!isPerlKeyword(styler.GetStartSegment(), fw, keywords, styler)) {
1163  						sc.ChangeState(SCE_PL_IDENTIFIER);
1164  					}
1165  				}
1166  				if (sc.state != SCE_PL_IDENTIFIER && bk > 0) {
1167  					if (disambiguateBareword(styler, bk, fw, backFlag, backPos, endPos))
1168  						sc.ChangeState(SCE_PL_IDENTIFIER);
1169  				}
1170  				backFlag = BACK_NONE;
1171  			} else if (sc.ch == '#') {
1172  				sc.SetState(SCE_PL_COMMENTLINE);
1173  			} else if (sc.ch == '\"') {
1174  				sc.SetState(SCE_PL_STRING);
1175  				Quote.New();
1176  				Quote.Open(sc.ch);
1177  				backFlag = BACK_NONE;
1178  			} else if (sc.ch == '\'') {
1179  				if (sc.chPrev == '&' && setWordStart.Contains(sc.chNext)) {
1180  					sc.SetState(SCE_PL_IDENTIFIER);
1181  				} else {
1182  					sc.SetState(SCE_PL_CHARACTER);
1183  					Quote.New();
1184  					Quote.Open(sc.ch);
1185  				}
1186  				backFlag = BACK_NONE;
1187  			} else if (sc.ch == '`') {
1188  				sc.SetState(SCE_PL_BACKTICKS);
1189  				Quote.New();
1190  				Quote.Open(sc.ch);
1191  				backFlag = BACK_NONE;
1192  			} else if (sc.ch == '$') {
1193  				sc.SetState(SCE_PL_SCALAR);
1194  				if (sc.chNext == '{') {
1195  					sc.ForwardSetState(SCE_PL_OPERATOR);
1196  				} else if (IsASpace(sc.chNext)) {
1197  					sc.ForwardSetState(SCE_PL_DEFAULT);
1198  				} else {
1199  					sc.Forward();
1200  					if (sc.Match('`', '`') || sc.Match(':', ':')) {
1201  						sc.Forward();
1202  					}
1203  				}
1204  				backFlag = BACK_NONE;
1205  			} else if (sc.ch == '@') {
1206  				sc.SetState(SCE_PL_ARRAY);
1207  				if (setArray.Contains(sc.chNext)) {
1208  				} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1209  					sc.ForwardBytes(2);
1210  				} else if (sc.chNext == '{' || sc.chNext == '[') {
1211  					sc.ForwardSetState(SCE_PL_OPERATOR);
1212  				} else {
1213  					sc.ChangeState(SCE_PL_OPERATOR);
1214  				}
1215  				backFlag = BACK_NONE;
1216  			} else if (setPreferRE.Contains(sc.ch)) {
1217  				bool preferRE = false;
1218  				bool isHereDoc = sc.Match('<', '<');
1219  				bool hereDocSpace = false;		
1220  				Sci_PositionU bk = (sc.currentPos > 0) ? sc.currentPos - 1: 0;
1221  				sc.Complete();
1222  				styler.Flush();
1223  				if (styler.StyleAt(bk) == SCE_PL_DEFAULT)
1224  					hereDocSpace = true;
1225  				skipWhitespaceComment(styler, bk);
1226  				if (bk == 0) {
1227  					preferRE = true;
1228  				} else {
1229  					int bkstyle = styler.StyleAt(bk);
1230  					int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
1231  					switch (bkstyle) {
1232  					case SCE_PL_OPERATOR:
1233  						preferRE = true;
1234  						if (bkch == ')' || bkch == ']') {
1235  							preferRE = false;
1236  						} else if (bkch == '}') {
1237  							bkstyle = styleBeforeBracePair(styler, bk);
1238  							if (bkstyle == SCE_PL_SCALAR
1239  							        || bkstyle == SCE_PL_ARRAY
1240  							        || bkstyle == SCE_PL_HASH
1241  							        || bkstyle == SCE_PL_SYMBOLTABLE
1242  							        || bkstyle == SCE_PL_OPERATOR) {
1243  								preferRE = false;
1244  							}
1245  						} else if (bkch == '+' || bkch == '-') {
1246  							if (bkch == static_cast<unsigned char>(styler.SafeGetCharAt(bk - 1))
1247  							        && bkch != static_cast<unsigned char>(styler.SafeGetCharAt(bk - 2)))
1248  								preferRE = false;
1249  						}
1250  						break;
1251  					case SCE_PL_IDENTIFIER:
1252  						preferRE = true;
1253  						bkstyle = styleCheckIdentifier(styler, bk);
1254  						if ((bkstyle == 1) || (bkstyle == 2)) {
1255  							preferRE = false;
1256  						} else if (bkstyle == 3) {
1257  							if (sc.ch == '/') {
1258  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1259  									preferRE = false;
1260  							} else if (sc.ch == '*' || sc.ch == '%') {
1261  								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1262  									preferRE = false;
1263  							} else if (sc.ch == '<') {
1264  								if (IsASpace(sc.chNext) || sc.chNext == '=')
1265  									preferRE = false;
1266  							}
1267  						}
1268  						break;
1269  					case SCE_PL_SCALAR:		
1270  						if (isHereDoc && hereDocSpace)	
1271  							preferRE = true;
1272  						break;
1273  					case SCE_PL_WORD:
1274  						preferRE = true;
1275  						if (sc.ch == '/') {
1276  							Sci_PositionU bkend = bk + 1;
1277  							while (bk > 0 && styler.StyleAt(bk - 1) == SCE_PL_WORD) {
1278  								bk--;
1279  							}
1280  							if (isPerlKeyword(bk, bkend, reWords, styler))
1281  								break;
1282  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
1283  								preferRE = false;
1284  						} else if (sc.ch == '*' || sc.ch == '%') {
1285  							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
1286  								preferRE = false;
1287  						} else if (sc.ch == '<') {
1288  							if (IsASpace(sc.chNext) || sc.chNext == '=')
1289  								preferRE = false;
1290  						}
1291  						break;
1292  					case SCE_PL_POD:
1293  					case SCE_PL_HERE_Q:
1294  					case SCE_PL_HERE_QQ:
1295  					case SCE_PL_HERE_QX:
1296  						preferRE = true;
1297  						break;
1298  					}
1299  				}
1300  				backFlag = BACK_NONE;
1301  				if (isHereDoc) {	
1302  					if (sc.Match("<<>>")) {		
1303  						sc.SetState(SCE_PL_OPERATOR);
1304  						sc.Forward(3);
1305  					} else if (preferRE) {
1306  						sc.SetState(SCE_PL_HERE_DELIM);
1307  						HereDoc.State = 0;
1308  					} else {		
1309  						sc.SetState(SCE_PL_OPERATOR);
1310  						sc.Forward();
1311  					}
1312  				} else if (sc.ch == '*') {	
1313  					if (preferRE) {
1314  						sc.SetState(SCE_PL_SYMBOLTABLE);
1315  						if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1316  							sc.ForwardBytes(2);
1317  						} else if (sc.chNext == '{') {
1318  							sc.ForwardSetState(SCE_PL_OPERATOR);
1319  						} else {
1320  							sc.Forward();
1321  						}
1322  					} else {
1323  						sc.SetState(SCE_PL_OPERATOR);
1324  						if (sc.chNext == '*') 	
1325  							sc.Forward();
1326  					}
1327  				} else if (sc.ch == '%') {	
1328  					if (preferRE) {
1329  						sc.SetState(SCE_PL_HASH);
1330  						if (setHash.Contains(sc.chNext)) {
1331  							sc.Forward();
1332  						} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
1333  							sc.ForwardBytes(2);
1334  						} else if (sc.chNext == '{') {
1335  							sc.ForwardSetState(SCE_PL_OPERATOR);
1336  						} else {
1337  							sc.ChangeState(SCE_PL_OPERATOR);
1338  						}
1339  					} else {
1340  						sc.SetState(SCE_PL_OPERATOR);
1341  					}
1342  				} else if (sc.ch == '<') {	
1343  					if (preferRE) {
1344  						int i = InputSymbolScan(sc);
1345  						if (i > 0) {
1346  							sc.SetState(SCE_PL_IDENTIFIER);
1347  							sc.Forward(i);
1348  						} else {
1349  							sc.SetState(SCE_PL_OPERATOR);
1350  						}
1351  					} else {
1352  						sc.SetState(SCE_PL_OPERATOR);
1353  					}
1354  				} else {			
1355  					if (preferRE) {
1356  						sc.SetState(SCE_PL_REGEX);
1357  						Quote.New();
1358  						Quote.Open(sc.ch);
1359  					} else {		
1360  						sc.SetState(SCE_PL_OPERATOR);
1361  						if (sc.chNext == '/') {
1362  							sc.Forward();
1363  						}
1364  					}
1365  				}
1366  			} else if (sc.ch == '='		
1367  			        && setPOD.Contains(sc.chNext)
1368  			        && sc.atLineStart) {
1369  				sc.SetState(SCE_PL_POD);
1370  				backFlag = BACK_NONE;
1371  			} else if (sc.ch == '-' && setWordStart.Contains(sc.chNext)) {	
1372  				Sci_PositionU bk = sc.currentPos;
1373  				Sci_PositionU fw = 2;
1374  				if (setSingleCharOp.Contains(sc.chNext) &&	
1375  				        !setWord.Contains(sc.GetRelative(2))) {
1376  					sc.SetState(SCE_PL_WORD);
1377  				} else {
1378  					while (setWord.Contains(sc.GetRelative(fw)))
1379  						fw++;
1380  					sc.SetState(SCE_PL_OPERATOR);
1381  				}
1382  				if (disambiguateBareword(styler, bk, bk + fw, backFlag, backPos, endPos) & 2) {
1383  					sc.ChangeState(SCE_PL_IDENTIFIER);
1384  				}
1385  				backFlag = BACK_NONE;
1386  			} else if (sc.ch == '(' && sc.currentPos > 0) {	
1387  				sc.Complete();
1388  				if (styleCheckSubPrototype(styler, sc.currentPos - 1)) {
1389  					sc.SetState(SCE_PL_SUB_PROTOTYPE);
1390  					backFlag = BACK_NONE;
1391  				} else {
1392  					sc.SetState(SCE_PL_OPERATOR);
1393  				}
1394  			} else if (setPerlOperator.Contains(sc.ch)) {	
1395  				sc.SetState(SCE_PL_OPERATOR);
1396  				if (sc.Match('.', '.')) {	
1397  					sc.Forward();
1398  					if (sc.chNext == '.') sc.Forward();
1399  				}
1400  			} else if (sc.ch == 4 || sc.ch == 26) {		
1401  				sc.SetState(SCE_PL_DATASECTION);
1402  			} else {
1403  				sc.Complete();
1404  			}
1405  		}
1406  	}
1407  	sc.Complete();
1408  	if (sc.state == SCE_PL_HERE_Q
1409  	        || sc.state == SCE_PL_HERE_QQ
1410  	        || sc.state == SCE_PL_HERE_QX
1411  	        || sc.state == SCE_PL_FORMAT) {
1412  		styler.ChangeLexerState(sc.currentPos, styler.Length());
1413  	}
1414  	sc.Complete();
1415  }
1416  #define PERL_HEADFOLD_SHIFT		4
1417  #define PERL_HEADFOLD_MASK		0xF0
1418  void SCI_METHOD LexerPerl::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;* initStyle */, IDocument *pAccess) {
1419  	if (!options.fold)
1420  		return;
1421  	LexAccessor styler(pAccess);
1422  	Sci_PositionU endPos = startPos + length;
1423  	int visibleChars = 0;
1424  	Sci_Position lineCurrent = styler.GetLine(startPos);
1425  	if (startPos > 0) {
1426  		if (lineCurrent > 0) {
1427  			lineCurrent--;
1428  			startPos = styler.LineStart(lineCurrent);
1429  		}
1430  	}
1431  	int levelPrev = SC_FOLDLEVELBASE;
1432  	if (lineCurrent > 0)
1433  		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
1434  	int levelCurrent = levelPrev;
1435  	char chNext = styler[startPos];
1436  	char chPrev = styler.SafeGetCharAt(startPos - 1);
1437  	int styleNext = styler.StyleAt(startPos);
1438  	bool isPackageLine = false;
1439  	int podHeading = 0;
1440  	for (Sci_PositionU i = startPos; i < endPos; i++) {
1441  		char ch = chNext;
1442  		chNext = styler.SafeGetCharAt(i + 1);
1443  		int style = styleNext;
1444  		styleNext = styler.StyleAt(i + 1);
1445  		int stylePrevCh = (i) ? styler.StyleAt(i - 1):SCE_PL_DEFAULT;
1446  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
1447  		bool atLineStart = ((chPrev == '\r') || (chPrev == '\n')) || i == 0;
1448  		if (options.foldComment && atEOL && IsCommentLine(lineCurrent, styler)) {
1449  			if (!IsCommentLine(lineCurrent - 1, styler)
1450  			        && IsCommentLine(lineCurrent + 1, styler))
1451  				levelCurrent++;
1452  			else if (IsCommentLine(lineCurrent - 1, styler)
1453  			        && !IsCommentLine(lineCurrent + 1, styler))
1454  				levelCurrent--;
1455  		}
1456  		if (style == SCE_PL_OPERATOR) {
1457  			if (ch == '{') {
1458  				if (options.foldAtElse && levelCurrent < levelPrev)
1459  					--levelPrev;
1460  				levelCurrent++;
1461  			} else if (ch == '}') {
1462  				levelCurrent--;
1463  			}
1464  			if (ch == '[') {
1465  				if (options.foldAtElse && levelCurrent < levelPrev)
1466  					--levelPrev;
1467  				levelCurrent++;
1468  			} else if (ch == ']') {
1469  				levelCurrent--;
1470  			}
1471  		} else if (style == SCE_PL_STRING_QW) {
1472  			if (stylePrevCh != style)
1473  				levelCurrent++;
1474  			else if (styleNext != style)
1475  				levelCurrent--;
1476  		}
1477  		if (options.foldPOD && atLineStart) {
1478  			if (style == SCE_PL_POD) {
1479  				if (stylePrevCh != SCE_PL_POD && stylePrevCh != SCE_PL_POD_VERB)
1480  					levelCurrent++;
1481  				else if (styler.Match(i, "=cut"))
1482  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1483  				else if (styler.Match(i, "=head"))
1484  					podHeading = PodHeadingLevel(i, styler);
1485  			} else if (style == SCE_PL_DATASECTION) {
1486  				if (ch == '=' && IsASCII(chNext) && isalpha(chNext) && levelCurrent == SC_FOLDLEVELBASE)
1487  					levelCurrent++;
1488  				else if (styler.Match(i, "=cut") && levelCurrent > SC_FOLDLEVELBASE)
1489  					levelCurrent = (levelCurrent & ~PERL_HEADFOLD_MASK) - 1;
1490  				else if (styler.Match(i, "=head"))
1491  					podHeading = PodHeadingLevel(i, styler);
1492  				else if (stylePrevCh != SCE_PL_DATASECTION)
1493  					levelCurrent = SC_FOLDLEVELBASE;
1494  			}
1495  		}
1496  		if (options.foldPackage && atLineStart) {
1497  			if (IsPackageLine(lineCurrent, styler)
1498  			        && !IsPackageLine(lineCurrent + 1, styler))
1499  				isPackageLine = true;
1500  		}
1501  		switch (style) {
1502  		case SCE_PL_HERE_QQ :
1503  		case SCE_PL_HERE_Q :
1504  		case SCE_PL_HERE_QX :
1505  			switch (stylePrevCh) {
1506  			case SCE_PL_HERE_QQ :
1507  			case SCE_PL_HERE_Q :
1508  			case SCE_PL_HERE_QX :
1509  				break;
1510  			default :
1511  				levelCurrent++;
1512  				break;
1513  			}
1514  			break;
1515  		default:
1516  			switch (stylePrevCh) {
1517  			case SCE_PL_HERE_QQ :
1518  			case SCE_PL_HERE_Q :
1519  			case SCE_PL_HERE_QX :
1520  				levelCurrent--;
1521  				break;
1522  			default :
1523  				break;
1524  			}
1525  			break;
1526  		}
1527  		if (options.foldCommentExplicit && style == SCE_PL_COMMENTLINE && ch == '#') {
1528  			if (chNext == '{') {
1529  				levelCurrent++;
1530  			} else if (levelCurrent > SC_FOLDLEVELBASE  && chNext == '}') {
1531  				levelCurrent--;
1532  			}
1533  		}
1534  		if (atEOL) {
1535  			int lev = levelPrev;
1536  			if (podHeading > 0) {
1537  				levelCurrent = (lev & ~PERL_HEADFOLD_MASK) | (podHeading << PERL_HEADFOLD_SHIFT);
1538  				lev = levelCurrent - 1;
1539  				lev |= SC_FOLDLEVELHEADERFLAG;
1540  				podHeading = 0;
1541  			}
1542  			if (isPackageLine) {
1543  				lev = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
1544  				levelCurrent = SC_FOLDLEVELBASE + 1;
1545  				isPackageLine = false;
1546  			}
1547  			lev |= levelCurrent << 16;
1548  			if (visibleChars == 0 && options.foldCompact)
1549  				lev |= SC_FOLDLEVELWHITEFLAG;
1550  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1551  				lev |= SC_FOLDLEVELHEADERFLAG;
1552  			if (lev != styler.LevelAt(lineCurrent)) {
1553  				styler.SetLevel(lineCurrent, lev);
1554  			}
1555  			lineCurrent++;
1556  			levelPrev = levelCurrent;
1557  			visibleChars = 0;
1558  		}
1559  		if (!isspacechar(ch))
1560  			visibleChars++;
1561  		chPrev = ch;
1562  	}
1563  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1564  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1565  }
1566  LexerModule lmPerl(SCLEX_PERL, LexerPerl::LexerFactoryPerl, "perl", perlWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPerl.cxx</div>
                </div>
                <div class="column column_space"><pre><code>649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
652  					if (sc.chNext == '\'' || sc.chNext == '\"') {	
</pre></code></div>
                <div class="column column_space"><pre><code>738  				HereDoc.StripIndent = false;
739  				HereDoc.DelimiterLength = 0;
740  				HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
741  				if (delim_ch == '~') { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    