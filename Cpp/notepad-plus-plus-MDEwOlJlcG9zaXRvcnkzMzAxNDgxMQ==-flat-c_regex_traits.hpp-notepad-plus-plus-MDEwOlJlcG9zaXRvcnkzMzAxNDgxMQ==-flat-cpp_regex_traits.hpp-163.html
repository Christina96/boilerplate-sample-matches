
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 48, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-c_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_C_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_C_REGEX_TRAITS_HPP_INCLUDED
3  #include &lt;boost/regex/config.hpp&gt;
4  #include &lt;boost/regex/v5/regex_workaround.hpp&gt;
5  #include &lt;cctype&gt;
6  namespace boost{
7     namespace BOOST_REGEX_DETAIL_NS {
8        enum
9        {
10           char_class_space = 1 &lt;&lt; 0,
11           char_class_print = 1 &lt;&lt; 1,
12           char_class_cntrl = 1 &lt;&lt; 2,
13           char_class_upper = 1 &lt;&lt; 3,
14           char_class_lower = 1 &lt;&lt; 4,
15           char_class_alpha = 1 &lt;&lt; 5,
16           char_class_digit = 1 &lt;&lt; 6,
17           char_class_punct = 1 &lt;&lt; 7,
18           char_class_xdigit = 1 &lt;&lt; 8,
19           char_class_alnum = char_class_alpha | char_class_digit,
20           char_class_graph = char_class_alnum | char_class_punct,
21           char_class_blank = 1 &lt;&lt; 9,
22           char_class_word = 1 &lt;&lt; 10,
23           char_class_unicode = 1 &lt;&lt; 11,
24           char_class_horizontal = 1 &lt;&lt; 12,
25           char_class_vertical = 1 &lt;&lt; 13
26        };
27     }
28  template &lt;class charT&gt;
29  struct c_regex_traits;
30  template&lt;&gt;
31  struct c_regex_traits&lt;char&gt;
32  {
33     c_regex_traits(){}
34     typedef char char_type;
35     typedef std::size_t size_type;
36     typedef std::string string_type;
37     struct locale_type{};
38     typedef std::uint32_t char_class_type;
39     static size_type length(const char_type* p) 
40     { 
41        return (std::strlen)(p); 
42     }
43     char translate(char c) const 
44     { 
45        return c; 
46     }
47     char translate_nocase(char c) const 
48     { 
49        return static_cast&lt;char&gt;((std::tolower)(static_cast&lt;unsigned char&gt;(c))); 
50     }
51     static string_type  transform(const char* p1, const char* p2);
52     static string_type  transform_primary(const char* p1, const char* p2);
53     static char_class_type  lookup_classname(const char* p1, const char* p2);
54     static string_type  lookup_collatename(const char* p1, const char* p2);
55     static bool  isctype(char, char_class_type);
56     static int  value(char, int);
57     locale_type imbue(locale_type l)
58     { return l; }
59     locale_type getloc()const
60     { return locale_type(); }
61  private:
62     c_regex_traits(const c_regex_traits&amp;);
63     c_regex_traits&amp; operator=(const c_regex_traits&amp;);
64  };
65  #ifndef BOOST_NO_WREGEX
66  template&lt;&gt;
67  struct c_regex_traits&lt;wchar_t&gt;
68  {
69     c_regex_traits(){}
70     typedef wchar_t char_type;
71     typedef std::size_t size_type;
72     typedef std::wstring string_type;
73     struct locale_type{};
74     typedef std::uint32_t char_class_type;
75     static size_type length(const char_type* p) 
76     { 
77        return (std::wcslen)(p); 
78     }
79     wchar_t translate(wchar_t c) const 
80     { 
81        return c; 
82     }
83     wchar_t translate_nocase(wchar_t c) const 
84     { 
85        return (std::towlower)(c); 
86     }
87     static string_type  transform(const wchar_t* p1, const wchar_t* p2);
88     static string_type  transform_primary(const wchar_t* p1, const wchar_t* p2);
89     static char_class_type  lookup_classname(const wchar_t* p1, const wchar_t* p2);
90     static string_type  lookup_collatename(const wchar_t* p1, const wchar_t* p2);
91     static bool  isctype(wchar_t, char_class_type);
92     static int  value(wchar_t, int);
93     locale_type imbue(locale_type l)
94     { return l; }
95     locale_type getloc()const
96     { return locale_type(); }
97  private:
98     c_regex_traits(const c_regex_traits&amp;);
99     c_regex_traits&amp; operator=(const c_regex_traits&amp;);
100  };
101  #endif 
102  inline c_regex_traits&lt;char&gt;::string_type  c_regex_traits&lt;char&gt;::transform(const char* p1, const char* p2)
103  {
104     std::string result(10, &#x27; &#x27;);
105     std::size_t s = result.size();
106     std::size_t r;
107     std::string src(p1, p2);
108     while (s &lt; (r = std::strxfrm(&amp;*result.begin(), src.c_str(), s)))
109     {
110  #if defined(_CPPLIB_VER)
111        if (r == INT_MAX)
112        {
113           result.erase();
114           result.insert(result.begin(), static_cast&lt;char&gt;(0));
115           return result;
116        }
117  #endif
118        result.append(r - s + 3, &#x27; &#x27;);
119        s = result.size();
120     }
121     result.erase(r);
122     return result;
123  }
124  inline c_regex_traits&lt;char&gt;::string_type  c_regex_traits&lt;char&gt;::transform_primary(const char* p1, const char* p2)
125  {
126     static char s_delim;
127     static const int s_collate_type = ::boost::BOOST_REGEX_DETAIL_NS::find_sort_syntax(static_cast&lt;c_regex_traits&lt;char&gt;*&gt;(0), &amp;s_delim);
128     std::string result;
129     switch (s_collate_type)
130     {
131     case ::boost::BOOST_REGEX_DETAIL_NS::sort_C:
132     case ::boost::BOOST_REGEX_DETAIL_NS::sort_unknown:
133     {
134        result.assign(p1, p2);
135        for (std::string::size_type i = 0; i &lt; result.size(); ++i)
136           result[i] = static_cast&lt;char&gt;((std::tolower)(static_cast&lt;unsigned char&gt;(result[i])));
137        result = transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
138        break;
139     }
140     case ::boost::BOOST_REGEX_DETAIL_NS::sort_fixed:
141     {
142        result = transform(p1, p2);
143        result.erase(s_delim);
144        break;
145     }
146     case ::boost::BOOST_REGEX_DETAIL_NS::sort_delim:
147        result = transform(p1, p2);
148        if ((!result.empty()) &amp;&amp; (result[0] == s_delim))
149           break;
150        std::size_t i;
151        for (i = 0; i &lt; result.size(); ++i)
152        {
153           if (result[i] == s_delim)
154              break;
155        }
156        result.erase(i);
157        break;
158     }
159     if (result.empty())
160        result = std::string(1, char(0));
161     return result;
162  }
163  inline c_regex_traits&lt;char&gt;::char_class_type  c_regex_traits&lt;char&gt;::lookup_classname(const char* p1, const char* p2)
164  {
165     using namespace BOOST_REGEX_DETAIL_NS;
166     static const char_class_type masks[] =
167     {
168        0,
169        char_class_alnum,
170        char_class_alpha,
171        char_class_blank,
172        char_class_cntrl,
173        char_class_digit,
174        char_class_digit,
175        char_class_graph,
176        char_class_horizontal,
177        char_class_lower,
178        char_class_lower,
179        char_class_print,
180        char_class_punct,
181        char_class_space,
182        char_class_space,
183        char_class_upper,
184        char_class_unicode,
185        char_class_upper,
186        char_class_vertical,
187        char_class_alnum | char_class_word,
188        char_class_alnum | char_class_word,
189        char_class_xdigit,
190     };
191     int idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
192     if (idx &lt; 0)
193     {
194        std::string s(p1, p2);
195        for (std::string::size_type i = 0; i &lt; s.size(); ++i)
196           s[i] = static_cast&lt;char&gt;((std::tolower)(static_cast&lt;unsigned char&gt;(s[i])));
197        idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(&amp;*s.begin(), &amp;*s.begin() + s.size());
198     }
199     BOOST_REGEX_ASSERT(std::size_t(idx) + 1u &lt; sizeof(masks) / sizeof(masks[0]));
200     return masks[idx + 1];
201  }
202  inline bool  c_regex_traits&lt;char&gt;::isctype(char c, char_class_type mask)
203  {
204     using namespace BOOST_REGEX_DETAIL_NS;
205     return
206        ((mask &amp; char_class_space) &amp;&amp; (std::isspace)(static_cast&lt;unsigned char&gt;(c)))
207        || ((mask &amp; char_class_print) &amp;&amp; (std::isprint)(static_cast&lt;unsigned char&gt;(c)))
208        || ((mask &amp; char_class_cntrl) &amp;&amp; (std::iscntrl)(static_cast&lt;unsigned char&gt;(c)))
209        || ((mask &amp; char_class_upper) &amp;&amp; (std::isupper)(static_cast&lt;unsigned char&gt;(c)))
210        || ((mask &amp; char_class_lower) &amp;&amp; (std::islower)(static_cast&lt;unsigned char&gt;(c)))
211        || ((mask &amp; char_class_alpha) &amp;&amp; (std::isalpha)(static_cast&lt;unsigned char&gt;(c)))
212        || ((mask &amp; char_class_digit) &amp;&amp; (std::isdigit)(static_cast&lt;unsigned char&gt;(c)))
213        || ((mask &amp; char_class_punct) &amp;&amp; (std::ispunct)(static_cast&lt;unsigned char&gt;(c)))
214        || ((mask &amp; char_class_xdigit) &amp;&amp; (std::isxdigit)(static_cast&lt;unsigned char&gt;(c)))
215        || ((mask &amp; char_class_blank) &amp;&amp; (std::isspace)(static_cast&lt;unsigned char&gt;(c)) &amp;&amp; !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c))
216        || ((mask &amp; char_class_word) &amp;&amp; (c == &#x27;_&#x27;))
217        || ((mask &amp; char_class_vertical) &amp;&amp; (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == &#x27;\v&#x27;)))
218        || ((mask &amp; char_class_horizontal) &amp;&amp; (std::isspace)(static_cast&lt;unsigned char&gt;(c)) &amp;&amp; !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) &amp;&amp; (c != &#x27;\v&#x27;));
219  }
220  inline c_regex_traits&lt;char&gt;::string_type  c_regex_traits&lt;char&gt;::lookup_collatename(const char* p1, const char* p2)
221  {
222     std::string s(p1, p2);
223     s = ::boost::BOOST_REGEX_DETAIL_NS::lookup_default_collate_name(s);
224     if (s.empty() &amp;&amp; (p2 - p1 == 1))
225        s.append(1, *p1);
226     return s;
227  }
228  inline int  c_regex_traits&lt;char&gt;::value(char c, int radix)
229  {
230     char b[2] = { c, &#x27;\0&#x27;, };
231     char* ep;
232     int result = std::strtol(b, &amp;ep, radix);
233     if (ep == b)
234        return -1;
235     return result;
236  }
237  #ifndef BOOST_NO_WREGEX
238  inline c_regex_traits&lt;wchar_t&gt;::string_type  c_regex_traits&lt;wchar_t&gt;::transform(const wchar_t* p1, const wchar_t* p2)
239  {
240     std::size_t r;
241     std::size_t s = 10;
242     std::wstring src(p1, p2);
243     std::wstring result(s, L&#x27; &#x27;);
244     while (s &lt; (r = std::wcsxfrm(&amp;*result.begin(), src.c_str(), s)))
245     {
246  #if defined(_CPPLIB_VER)
247        if (r == INT_MAX)
248        {
249           result.erase();
250           result.insert(result.begin(), static_cast&lt;wchar_t&gt;(0));
251           return result;
252        }
253  #endif
254        result.append(r - s + 3, L&#x27; &#x27;);
255        s = result.size();
256     }
257     result.erase(r);
258     return result;
259  }
260  inline c_regex_traits&lt;wchar_t&gt;::string_type  c_regex_traits&lt;wchar_t&gt;::transform_primary(const wchar_t* p1, const wchar_t* p2)
261  {
262     static wchar_t s_delim;
263     static const int s_collate_type = ::boost::BOOST_REGEX_DETAIL_NS::find_sort_syntax(static_cast&lt;const c_regex_traits&lt;wchar_t&gt;*&gt;(0), &amp;s_delim);
264     std::wstring result;
265     switch (s_collate_type)
266     {
267     case ::boost::BOOST_REGEX_DETAIL_NS::sort_C:
268     case ::boost::BOOST_REGEX_DETAIL_NS::sort_unknown:
269     {
270        result.assign(p1, p2);
271        for (std::wstring::size_type i = 0; i &lt; result.size(); ++i)
272           result[i] = (std::towlower)(result[i]);
273        result = c_regex_traits&lt;wchar_t&gt;::transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
274        break;
275     }
276     case ::boost::BOOST_REGEX_DETAIL_NS::sort_fixed:
277     {
278        result = c_regex_traits&lt;wchar_t&gt;::transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
279        result.erase(s_delim);
280        break;
281     }
282     case ::boost::BOOST_REGEX_DETAIL_NS::sort_delim:
283        result = c_regex_traits&lt;wchar_t&gt;::transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
284        if ((!result.empty()) &amp;&amp; (result[0] == s_delim))
285           break;
286        std::size_t i;
287        for (i = 0; i &lt; result.size(); ++i)
288        {
289           if (result[i] == s_delim)
290              break;
291        }
292        result.erase(i);
293        break;
294     }
295     if (result.empty())
296        result = std::wstring(1, char(0));
297     return result;
298  }
299  inline c_regex_traits&lt;wchar_t&gt;::char_class_type  c_regex_traits&lt;wchar_t&gt;::lookup_classname(const wchar_t* p1, const wchar_t* p2)
300  {
301     using namespace BOOST_REGEX_DETAIL_NS;
302     static const char_class_type masks[] =
303     {
304        0,
305        char_class_alnum,
306        char_class_alpha,
307        char_class_blank,
308        char_class_cntrl,
309        char_class_digit,
310        char_class_digit,
311        char_class_graph,
312        char_class_horizontal,
313        char_class_lower,
314        char_class_lower,
315        char_class_print,
316        char_class_punct,
317        char_class_space,
318        char_class_space,
319        char_class_upper,
320        char_class_unicode,
321        char_class_upper,
322        char_class_vertical,
323        char_class_alnum | char_class_word,
324        char_class_alnum | char_class_word,
325        char_class_xdigit,
326     };
327     int idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
328     if (idx &lt; 0)
329     {
330        std::wstring s(p1, p2);
331        for (std::wstring::size_type i = 0; i &lt; s.size(); ++i)
332           s[i] = (std::towlower)(s[i]);
333        idx = ::boost::BOOST_REGEX_DETAIL_NS::get_default_class_id(&amp;*s.begin(), &amp;*s.begin() + s.size());
334     }
335     BOOST_REGEX_ASSERT(idx + 1 &lt; static_cast&lt;int&gt;(sizeof(masks) / sizeof(masks[0])));
336     return masks[idx + 1];
337  }
338  inline bool  c_regex_traits&lt;wchar_t&gt;::isctype(wchar_t c, char_class_type mask)
339  {
340     using namespace BOOST_REGEX_DETAIL_NS;
341     return
342        ((mask &amp; char_class_space) &amp;&amp; (std::iswspace)(c))
343        || ((mask &amp; char_class_print) &amp;&amp; (std::iswprint)(c))
344        || ((mask &amp; char_class_cntrl) &amp;&amp; (std::iswcntrl)(c))
345        || ((mask &amp; char_class_upper) &amp;&amp; (std::iswupper)(c))
346        || ((mask &amp; char_class_lower) &amp;&amp; (std::iswlower)(c))
347        || ((mask &amp; char_class_alpha) &amp;&amp; (std::iswalpha)(c))
348        || ((mask &amp; char_class_digit) &amp;&amp; (std::iswdigit)(c))
349        || ((mask &amp; char_class_punct) &amp;&amp; (std::iswpunct)(c))
350        || ((mask &amp; char_class_xdigit) &amp;&amp; (std::iswxdigit)(c))
351        || ((mask &amp; char_class_blank) &amp;&amp; (std::iswspace)(c) &amp;&amp; !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c))
352        || ((mask &amp; char_class_word) &amp;&amp; (c == &#x27;_&#x27;))
353        || ((mask &amp; char_class_unicode) &amp;&amp; (c &amp; ~static_cast&lt;wchar_t&gt;(0xff)))
354        || ((mask &amp; char_class_vertical) &amp;&amp; (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == L&#x27;\v&#x27;)))
355        || ((mask &amp; char_class_horizontal) &amp;&amp; (std::iswspace)(c) &amp;&amp; !::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) &amp;&amp; (c != L&#x27;\v&#x27;));
356  }
357  inline c_regex_traits&lt;wchar_t&gt;::string_type  c_regex_traits&lt;wchar_t&gt;::lookup_collatename(const wchar_t* p1, const wchar_t* p2)
358  {
359     std::string name;
360     for (const wchar_t* pos = p1; pos != p2; ++pos)
361        name.push_back((char)*pos);
362     name = ::boost::BOOST_REGEX_DETAIL_NS::lookup_default_collate_name(name);
<span onclick='openModal()' class='match'>363     if (!name.empty())
364        return string_type(name.begin(), name.end());
365     if (p2 - p1 == 1)
366        return string_type(1, *p1);
367     return string_type();
368  }
369  inline int  c_regex_traits&lt;wchar_t&gt;::value(wchar_t c, int radix)
</span>370  {
371  #ifdef BOOST_BORLANDC
372     if ((std::iswxdigit)(c) == 0)
373        return -1;
374  #endif
375     wchar_t b[2] = { c, &#x27;\0&#x27;, };
376     wchar_t* ep;
377     int result = std::wcstol(b, &amp;ep, radix);
378     if (ep == b)
379        return -1;
380     return result;
381  }
382  #endif
383  }
384  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</h3>
            <pre><code>1  #ifndef BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
2  #define BOOST_CPP_REGEX_TRAITS_HPP_INCLUDED
3  #include &lt;boost/regex/config.hpp&gt;
4  #include &lt;cstdint&gt;
5  #include &lt;locale&gt;
6  #include &lt;type_traits&gt;
7  #include &lt;boost/regex/pattern_except.hpp&gt;
8  #include &lt;boost/regex/v5/regex_traits_defaults.hpp&gt;
9  #ifdef BOOST_HAS_THREADS
10  #include &lt;mutex&gt;
11  #endif
12  #include &lt;boost/regex/v5/primary_transform.hpp&gt;
13  #include &lt;boost/regex/v5/object_cache.hpp&gt;
14  #include &lt;climits&gt;
15  #include &lt;ios&gt;
16  #include &lt;istream&gt;
17  #ifdef BOOST_REGEX_MSVC
18  #pragma warning(push)
19  #pragma warning(disable:4786 4251)
20  #endif
21  namespace boost{ 
22  template &lt;class charT&gt;
23  class cpp_regex_traits;
24  namespace BOOST_REGEX_DETAIL_NS{
25  template &lt;class charT,
26            class traits = ::std::char_traits&lt;charT&gt; &gt;
27  class parser_buf : public ::std::basic_streambuf&lt;charT, traits&gt;
28  {
29     typedef ::std::basic_streambuf&lt;charT, traits&gt; base_type;
30     typedef typename base_type::int_type int_type;
31     typedef typename base_type::char_type char_type;
32     typedef typename base_type::pos_type pos_type;
33     typedef ::std::streamsize streamsize;
34     typedef typename base_type::off_type off_type;
35  public:
36     parser_buf() : base_type() { setbuf(0, 0); }
37     const charT* getnext() { return this-&gt;gptr(); }
38  protected:
39     std::basic_streambuf&lt;charT, traits&gt;* setbuf(char_type* s, streamsize n) override;
40     typename parser_buf&lt;charT, traits&gt;::pos_type seekpos(pos_type sp, ::std::ios_base::openmode which) override;
41     typename parser_buf&lt;charT, traits&gt;::pos_type seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) override;
42  private:
43     parser_buf&amp; operator=(const parser_buf&amp;);
44     parser_buf(const parser_buf&amp;);
45  };
46  template&lt;class charT, class traits&gt;
47  std::basic_streambuf&lt;charT, traits&gt;*
48  parser_buf&lt;charT, traits&gt;::setbuf(char_type* s, streamsize n)
49  {
50     this-&gt;setg(s, s, s + n);
51     return this;
52  }
53  template&lt;class charT, class traits&gt;
54  typename parser_buf&lt;charT, traits&gt;::pos_type
55  parser_buf&lt;charT, traits&gt;::seekoff(off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which)
56  {
57     if(which &amp; ::std::ios_base::out)
58        return pos_type(off_type(-1));
59     std::ptrdiff_t size = this-&gt;egptr() - this-&gt;eback();
60     std::ptrdiff_t pos = this-&gt;gptr() - this-&gt;eback();
61     charT* g = this-&gt;eback();
62     switch(static_cast&lt;std::intmax_t&gt;(way))
63     {
64     case ::std::ios_base::beg:
65        if((off &lt; 0) || (off &gt; size))
66           return pos_type(off_type(-1));
67        else
68           this-&gt;setg(g, g + off, g + size);
69        break;
70     case ::std::ios_base::end:
71        if((off &lt; 0) || (off &gt; size))
72           return pos_type(off_type(-1));
73        else
74           this-&gt;setg(g, g + size - off, g + size);
75        break;
76     case ::std::ios_base::cur:
77     {
78        std::ptrdiff_t newpos = static_cast&lt;std::ptrdiff_t&gt;(pos + off);
79        if((newpos &lt; 0) || (newpos &gt; size))
80           return pos_type(off_type(-1));
81        else
82           this-&gt;setg(g, g + newpos, g + size);
83        break;
84     }
85     default: ;
86     }
87  #ifdef BOOST_REGEX_MSVC
88  #pragma warning(push)
89  #pragma warning(disable:4244)
90  #endif
91     return static_cast&lt;pos_type&gt;(this-&gt;gptr() - this-&gt;eback());
92  #ifdef BOOST_REGEX_MSVC
93  #pragma warning(pop)
94  #endif
95  }
96  template&lt;class charT, class traits&gt;
97  typename parser_buf&lt;charT, traits&gt;::pos_type
98  parser_buf&lt;charT, traits&gt;::seekpos(pos_type sp, ::std::ios_base::openmode which)
99  {
100     if(which &amp; ::std::ios_base::out)
101        return pos_type(off_type(-1));
102     off_type size = static_cast&lt;off_type&gt;(this-&gt;egptr() - this-&gt;eback());
103     charT* g = this-&gt;eback();
104     if(off_type(sp) &lt;= size)
105     {
106        this-&gt;setg(g, g + off_type(sp), g + size);
107     }
108     return pos_type(off_type(-1));
109  }
110  template &lt;class charT&gt;
111  struct cpp_regex_traits_base
112  {
113     cpp_regex_traits_base(const std::locale&amp; l)
114     { (void)imbue(l); }
115     std::locale imbue(const std::locale&amp; l);
116     std::locale m_locale;
117     std::ctype&lt;charT&gt; const* m_pctype;
118     std::messages&lt;charT&gt; const* m_pmessages;
119     std::collate&lt;charT&gt; const* m_pcollate;
120     bool operator&lt;(const cpp_regex_traits_base&amp; b)const
121     {
122        if(m_pctype == b.m_pctype)
123        {
124           if(m_pmessages == b.m_pmessages)
125           {
126              return m_pcollate &lt; b.m_pcollate;
127           }
128           return m_pmessages &lt; b.m_pmessages;
129        }
130        return m_pctype &lt; b.m_pctype;
131     }
132     bool operator==(const cpp_regex_traits_base&amp; b)const
133     {
134        return (m_pctype == b.m_pctype) 
135           &amp;&amp; (m_pmessages == b.m_pmessages) 
136           &amp;&amp; (m_pcollate == b.m_pcollate);
137     }
138  };
139  template &lt;class charT&gt;
140  std::locale cpp_regex_traits_base&lt;charT&gt;::imbue(const std::locale&amp; l)
141  {
142     std::locale result(m_locale);
143     m_locale = l;
144     m_pctype = &amp;std::use_facet&lt;std::ctype&lt;charT&gt;&gt;(l);
145     m_pmessages = std::has_facet&lt;std::messages&lt;charT&gt; &gt;(l) ? &amp;std::use_facet&lt;std::messages&lt;charT&gt; &gt;(l) : 0;
146     m_pcollate = &amp;std::use_facet&lt;std::collate&lt;charT&gt; &gt;(l);
147     return result;
148  }
149  template &lt;class charT&gt;
150  class cpp_regex_traits_char_layer : public cpp_regex_traits_base&lt;charT&gt;
151  {
152     typedef std::basic_string&lt;charT&gt; string_type;
153     typedef std::map&lt;charT, regex_constants::syntax_type&gt; map_type;
154     typedef typename map_type::const_iterator map_iterator_type;
155  public:
156     cpp_regex_traits_char_layer(const std::locale&amp; l)
157        : cpp_regex_traits_base&lt;charT&gt;(l)
158     {
159        init();
160     }
161     cpp_regex_traits_char_layer(const cpp_regex_traits_base&lt;charT&gt;&amp; b)
162        : cpp_regex_traits_base&lt;charT&gt;(b)
163     {
164        init();
165     }
166     void init();
167     regex_constants::syntax_type syntax_type(charT c)const
168     {
169        map_iterator_type i = m_char_map.find(c);
170        return ((i == m_char_map.end()) ? 0 : i-&gt;second);
171     }
172     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
173     {
174        map_iterator_type i = m_char_map.find(c);
175        if(i == m_char_map.end())
176        {
177           if(this-&gt;m_pctype-&gt;is(std::ctype_base::lower, c)) return regex_constants::escape_type_class;
178           if(this-&gt;m_pctype-&gt;is(std::ctype_base::upper, c)) return regex_constants::escape_type_not_class;
179           return 0;
180        }
181        return i-&gt;second;
182     }
183  private:
184     string_type get_default_message(regex_constants::syntax_type);
185     map_type m_char_map;
186  };
187  template &lt;class charT&gt;
188  void cpp_regex_traits_char_layer&lt;charT&gt;::init()
189  {
190  #ifndef __IBMCPP__
191     typename std::messages&lt;charT&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
192  #else
193     typename std::messages&lt;charT&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
194  #endif
195     std::string cat_name(cpp_regex_traits&lt;charT&gt;::get_catalog_name());
196     if((!cat_name.empty()) &amp;&amp; (this-&gt;m_pmessages != 0))
197     {
198        cat = this-&gt;m_pmessages-&gt;open(
199           cat_name, 
200           this-&gt;m_locale);
201        if((int)cat &lt; 0)
202        {
203           std::string m(&quot;Unable to open message catalog: &quot;);
204           std::runtime_error err(m + cat_name);
205           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
206        }
207     }
208     if((int)cat &gt;= 0)
209     {
210  #ifndef BOOST_NO_EXCEPTIONS
211        try{
212  #endif
213           for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
214           {
215              string_type mss = this-&gt;m_pmessages-&gt;get(cat, 0, i, get_default_message(i));
216              for(typename string_type::size_type j = 0; j &lt; mss.size(); ++j)
217              {
218                 m_char_map[mss[j]] = i;
219              }
220           }
221           this-&gt;m_pmessages-&gt;close(cat);
222  #ifndef BOOST_NO_EXCEPTIONS
223        }
224        catch(...)
225        {
226           if(this-&gt;m_pmessages)
227              this-&gt;m_pmessages-&gt;close(cat);
228           throw;
229        }
230  #endif
231     }
232     else
233     {
234        for(regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
235        {
236           const char* ptr = get_default_syntax(i);
237           while(ptr &amp;&amp; *ptr)
238           {
239              m_char_map[this-&gt;m_pctype-&gt;widen(*ptr)] = i;
240              ++ptr;
241           }
242        }
243     }
244  }
245  template &lt;class charT&gt;
246  typename cpp_regex_traits_char_layer&lt;charT&gt;::string_type 
247     cpp_regex_traits_char_layer&lt;charT&gt;::get_default_message(regex_constants::syntax_type i)
248  {
249     const char* ptr = get_default_syntax(i);
250     string_type result;
251     while(ptr &amp;&amp; *ptr)
252     {
253        result.append(1, this-&gt;m_pctype-&gt;widen(*ptr));
254        ++ptr;
255     }
256     return result;
257  }
258  template &lt;&gt;
259  class cpp_regex_traits_char_layer&lt;char&gt; : public cpp_regex_traits_base&lt;char&gt;
260  {
261     typedef std::string string_type;
262  public:
263     cpp_regex_traits_char_layer(const std::locale&amp; l)
264     : cpp_regex_traits_base&lt;char&gt;(l)
265     {
266        init();
267     }
268     cpp_regex_traits_char_layer(const cpp_regex_traits_base&lt;char&gt;&amp; l)
269     : cpp_regex_traits_base&lt;char&gt;(l)
270     {
271        init();
272     }
273     regex_constants::syntax_type syntax_type(char c)const
274     {
275        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
276     }
277     regex_constants::escape_syntax_type escape_syntax_type(char c) const
278     {
279        return m_char_map[static_cast&lt;unsigned char&gt;(c)];
280     }
281  private:
282     regex_constants::syntax_type m_char_map[1u &lt;&lt; CHAR_BIT];
283     void init();
284  };
285  template &lt;class charT&gt;
286  class cpp_regex_traits_implementation : public cpp_regex_traits_char_layer&lt;charT&gt;
287  {
288  public:
289     typedef typename cpp_regex_traits&lt;charT&gt;::char_class_type      char_class_type;
290     typedef typename std::ctype&lt;charT&gt;::mask                       native_mask_type;
291     typedef typename std::make_unsigned&lt;native_mask_type&gt;::type    unsigned_native_mask_type;
292     static const char_class_type mask_blank = 1u &lt;&lt; 24;
293     static const char_class_type mask_word = 1u &lt;&lt; 25;
294     static const char_class_type mask_unicode = 1u &lt;&lt; 26;
295     static const char_class_type mask_horizontal = 1u &lt;&lt; 27;
296     static const char_class_type mask_vertical = 1u &lt;&lt; 28;
297     typedef std::basic_string&lt;charT&gt; string_type;
298     typedef charT char_type;
299     cpp_regex_traits_implementation(const std::locale&amp; l)
300        : cpp_regex_traits_char_layer&lt;charT&gt;(l)
301     {
302        init();
303     }
304     cpp_regex_traits_implementation(const cpp_regex_traits_base&lt;charT&gt;&amp; l)
305        : cpp_regex_traits_char_layer&lt;charT&gt;(l)
306     {
307        init();
308     }
309     std::string error_string(regex_constants::error_type n) const
310     {
311        if(!m_error_strings.empty())
312        {
313           std::map&lt;int, std::string&gt;::const_iterator p = m_error_strings.find(n);
314           return (p == m_error_strings.end()) ? std::string(get_default_error_string(n)) : p-&gt;second;
315        }
316        return get_default_error_string(n);
317     }
318     char_class_type lookup_classname(const charT* p1, const charT* p2) const
319     {
320        char_class_type result = lookup_classname_imp(p1, p2);
321        if(result == 0)
322        {
323           string_type temp(p1, p2);
324           this-&gt;m_pctype-&gt;tolower(&amp;*temp.begin(), &amp;*temp.begin() + temp.size());
325           result = lookup_classname_imp(&amp;*temp.begin(), &amp;*temp.begin() + temp.size());
326        }
327        return result;
328     }
329     string_type lookup_collatename(const charT* p1, const charT* p2) const;
330     string_type transform_primary(const charT* p1, const charT* p2) const;
331     string_type transform(const charT* p1, const charT* p2) const;
332  private:
333     std::map&lt;int, std::string&gt;     m_error_strings;   
334     std::map&lt;string_type, char_class_type&gt;  m_custom_class_names; 
335     std::map&lt;string_type, string_type&gt;      m_custom_collate_names; 
336     unsigned                       m_collate_type;    
337     charT                          m_collate_delim;   
338     char_class_type lookup_classname_imp(const charT* p1, const charT* p2) const;
339     void init();
340  };
341  template &lt;class charT&gt;
342  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_blank;
343  template &lt;class charT&gt;
344  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_word;
345  template &lt;class charT&gt;
346  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode;
347  template &lt;class charT&gt;
348  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical;
349  template &lt;class charT&gt;
350  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type const cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal;
351  template &lt;class charT&gt;
352  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
353     cpp_regex_traits_implementation&lt;charT&gt;::transform_primary(const charT* p1, const charT* p2) const
354  {
355     BOOST_REGEX_ASSERT(*p2 == 0);
356     string_type result;
357  #if defined(_CPPLIB_VER)
358     if(*p1 == 0)
359     {
360        return string_type(1, charT(0));
361     }
362  #endif
363  #ifndef BOOST_NO_EXCEPTIONS
364     try{
365  #endif
366        switch(m_collate_type)
367        {
368        case sort_C:
369        case sort_unknown:
370           {
371              result.assign(p1, p2);
372              this-&gt;m_pctype-&gt;tolower(&amp;*result.begin(), &amp;*result.begin() + result.size());
373              result = this-&gt;m_pcollate-&gt;transform(&amp;*result.begin(), &amp;*result.begin() + result.size());
374              break;
375           }
376        case sort_fixed:
377           {
378              result.assign(this-&gt;m_pcollate-&gt;transform(p1, p2));
379              result.erase(this-&gt;m_collate_delim);
380              break;
381           }
382        case sort_delim:
383              result.assign(this-&gt;m_pcollate-&gt;transform(p1, p2));
384              std::size_t i;
385              for(i = 0; i &lt; result.size(); ++i)
386              {
387                 if(result[i] == m_collate_delim)
388                    break;
389              }
390              result.erase(i);
391              break;
392        }
393  #ifndef BOOST_NO_EXCEPTIONS
394     }catch(...){}
395  #endif
396     while((!result.empty()) &amp;&amp; (charT(0) == *result.rbegin()))
397        result.erase(result.size() - 1);
398     if(result.empty())
399     {
400        result = string_type(1, charT(0));
401     }
402     return result;
403  }
404  template &lt;class charT&gt;
405  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
406     cpp_regex_traits_implementation&lt;charT&gt;::transform(const charT* p1, const charT* p2) const
407  {
408     BOOST_REGEX_ASSERT(*p2 == 0);
409     string_type result, result2;
410  #if defined(_CPPLIB_VER)
411     if(*p1 == 0)
412     {
413        return result;
414     }
415  #endif
416  #ifndef BOOST_NO_EXCEPTIONS
417     try{
418  #endif
419        result = this-&gt;m_pcollate-&gt;transform(p1, p2);
420        while((!result.empty()) &amp;&amp; (charT(0) == *result.rbegin()))
421           result.erase(result.size() - 1);
422        typedef typename std::make_unsigned&lt;charT&gt;::type uchar_type;
423        result2.reserve(result.size() * 2 + 2);
424        for(unsigned i = 0; i &lt; result.size(); ++i)
425        {
426           if(static_cast&lt;uchar_type&gt;(result[i]) == (std::numeric_limits&lt;uchar_type&gt;::max)())
427           {
428              result2.append(1, charT((std::numeric_limits&lt;uchar_type&gt;::max)())).append(1, charT(&#x27;b&#x27;));
429           }
430           else
431           {
432              result2.append(1, static_cast&lt;charT&gt;(1 + static_cast&lt;uchar_type&gt;(result[i]))).append(1, charT(&#x27;b&#x27;) - 1);
433           }
434        }
435        BOOST_REGEX_ASSERT(std::find(result2.begin(), result2.end(), charT(0)) == result2.end());
436  #ifndef BOOST_NO_EXCEPTIONS
437     }
438     catch(...)
439     {
440     }
441  #endif
442     return result2;
443  }
444  template &lt;class charT&gt;
445  typename cpp_regex_traits_implementation&lt;charT&gt;::string_type 
446     cpp_regex_traits_implementation&lt;charT&gt;::lookup_collatename(const charT* p1, const charT* p2) const
447  {
448     typedef typename std::map&lt;string_type, string_type&gt;::const_iterator iter_type;
449     if(!m_custom_collate_names.empty())
450     {
451        iter_type pos = m_custom_collate_names.find(string_type(p1, p2));
452        if(pos != m_custom_collate_names.end())
453           return pos-&gt;second;
454     }
455     std::string name(p1, p2);
456     name = lookup_default_collate_name(name);
<span onclick='openModal()' class='match'>457     if(!name.empty())
458        return string_type(name.begin(), name.end());
459     if(p2 - p1 == 1)
460        return string_type(1, *p1);
461     return string_type();
462  }
463  template &lt;class charT&gt;
</span>464  void cpp_regex_traits_implementation&lt;charT&gt;::init()
465  {
466  #ifndef __IBMCPP__
467     typename std::messages&lt;charT&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
468  #else
469     typename std::messages&lt;charT&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
470  #endif
471     std::string cat_name(cpp_regex_traits&lt;charT&gt;::get_catalog_name());
472     if((!cat_name.empty()) &amp;&amp; (this-&gt;m_pmessages != 0))
473     {
474        cat = this-&gt;m_pmessages-&gt;open(
475           cat_name, 
476           this-&gt;m_locale);
477        if((int)cat &lt; 0)
478        {
479           std::string m(&quot;Unable to open message catalog: &quot;);
480           std::runtime_error err(m + cat_name);
481           boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
482        }
483     }
484     if((int)cat &gt;= 0)
485     {
486        for(boost::regex_constants::error_type i = static_cast&lt;boost::regex_constants::error_type&gt;(0); 
487           i &lt;= boost::regex_constants::error_unknown; 
488           i = static_cast&lt;boost::regex_constants::error_type&gt;(i + 1))
489        {
490           const char* p = get_default_error_string(i);
491           string_type default_message;
492           while(*p)
493           {
494              default_message.append(1, this-&gt;m_pctype-&gt;widen(*p));
495              ++p;
496           }
497           string_type s = this-&gt;m_pmessages-&gt;get(cat, 0, i+200, default_message);
498           std::string result;
499           for(std::string::size_type j = 0; j &lt; s.size(); ++j)
500           {
501              result.append(1, this-&gt;m_pctype-&gt;narrow(s[j], 0));
502           }
503           m_error_strings[i] = result;
504        }
505        static const char_class_type masks[16] = 
506        {
507           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::alnum),
508           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::alpha),
509           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::cntrl),
510           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::digit),
511           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::graph),
512           cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal,
513           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::lower),
514           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::print),
515           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::punct),
516           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::space),
517           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::upper),
518           cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical,
519           static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;charT&gt;::xdigit),
520           cpp_regex_traits_implementation&lt;charT&gt;::mask_blank,
521           cpp_regex_traits_implementation&lt;charT&gt;::mask_word,
522           cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode,
523        };
524        static const string_type null_string;
525        for(unsigned int j = 0; j &lt;= 13; ++j)
526        {
527           string_type s(this-&gt;m_pmessages-&gt;get(cat, 0, j+300, null_string));
528           if(!s.empty())
529              this-&gt;m_custom_class_names[s] = masks[j];
530        }
531     }
532     m_collate_type = BOOST_REGEX_DETAIL_NS::find_sort_syntax(this, &amp;m_collate_delim);
533  }
534  template &lt;class charT&gt;
535  typename cpp_regex_traits_implementation&lt;charT&gt;::char_class_type 
536     cpp_regex_traits_implementation&lt;charT&gt;::lookup_classname_imp(const charT* p1, const charT* p2) const
537  {
538     static const char_class_type masks[22] = 
539     {
540        0,
541        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum),
542        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alpha),
543        cpp_regex_traits_implementation&lt;charT&gt;::mask_blank,
544        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::cntrl),
545        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::digit),
546        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::digit),
547        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::graph),
548        cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal,
549        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::lower),
550        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::lower),
551        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::print),
552        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::punct),
553        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::space),
554        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::space),
555        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::upper),
556        cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode,
557        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::upper),
558        cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical,
559        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum) | cpp_regex_traits_implementation&lt;charT&gt;::mask_word, 
560        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::alnum) | cpp_regex_traits_implementation&lt;charT&gt;::mask_word, 
561        static_cast&lt;unsigned_native_mask_type&gt;(std::ctype&lt;char&gt;::xdigit),
562     };
563     if(!m_custom_class_names.empty())
564     {
565        typedef typename std::map&lt;std::basic_string&lt;charT&gt;, char_class_type&gt;::const_iterator map_iter;
566        map_iter pos = m_custom_class_names.find(string_type(p1, p2));
567        if(pos != m_custom_class_names.end())
568           return pos-&gt;second;
569     }
570     std::size_t state_id = 1 + BOOST_REGEX_DETAIL_NS::get_default_class_id(p1, p2);
571     BOOST_REGEX_ASSERT(state_id &lt; sizeof(masks) / sizeof(masks[0]));
572     return masks[state_id];
573  }
574  template &lt;class charT&gt;
575  inline std::shared_ptr&lt;const cpp_regex_traits_implementation&lt;charT&gt; &gt; create_cpp_regex_traits(const std::locale&amp; l)
576  {
577     cpp_regex_traits_base&lt;charT&gt; key(l);
578     return ::boost::object_cache&lt;cpp_regex_traits_base&lt;charT&gt;, cpp_regex_traits_implementation&lt;charT&gt; &gt;::get(key, 5);
579  }
580  } 
581  template &lt;class charT&gt;
582  class cpp_regex_traits
583  {
584  private:
585     typedef std::ctype&lt;charT&gt;            ctype_type;
586  public:
587     typedef charT                        char_type;
588     typedef std::size_t                  size_type;
589     typedef std::basic_string&lt;char_type&gt; string_type;
590     typedef std::locale                  locale_type;
591     typedef std::uint_least32_t          char_class_type;
592     struct boost_extensions_tag{};
593     cpp_regex_traits()
594        : m_pimpl(BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits&lt;charT&gt;(std::locale()))
595     { }
596     static size_type length(const char_type* p)
597     {
598        return std::char_traits&lt;charT&gt;::length(p);
599     }
600     regex_constants::syntax_type syntax_type(charT c)const
601     {
602        return m_pimpl-&gt;syntax_type(c);
603     }
604     regex_constants::escape_syntax_type escape_syntax_type(charT c) const
605     {
606        return m_pimpl-&gt;escape_syntax_type(c);
607     }
608     charT translate(charT c) const
609     {
610        return c;
611     }
612     charT translate_nocase(charT c) const
613     {
614        return m_pimpl-&gt;m_pctype-&gt;tolower(c);
615     }
616     charT translate(charT c, bool icase) const
617     {
618        return icase ? m_pimpl-&gt;m_pctype-&gt;tolower(c) : c;
619     }
620     charT tolower(charT c) const
621     {
622        return m_pimpl-&gt;m_pctype-&gt;tolower(c);
623     }
624     charT toupper(charT c) const
625     {
626        return m_pimpl-&gt;m_pctype-&gt;toupper(c);
627     }
628     string_type transform(const charT* p1, const charT* p2) const
629     {
630        return m_pimpl-&gt;transform(p1, p2);
631     }
632     string_type transform_primary(const charT* p1, const charT* p2) const
633     {
634        return m_pimpl-&gt;transform_primary(p1, p2);
635     }
636     char_class_type lookup_classname(const charT* p1, const charT* p2) const
637     {
638        return m_pimpl-&gt;lookup_classname(p1, p2);
639     }
640     string_type lookup_collatename(const charT* p1, const charT* p2) const
641     {
642        return m_pimpl-&gt;lookup_collatename(p1, p2);
643     }
644     bool isctype(charT c, char_class_type f) const
645     {
646        typedef typename std::ctype&lt;charT&gt;::mask ctype_mask;
647        static const ctype_mask mask_base = 
648           static_cast&lt;ctype_mask&gt;(
649              std::ctype&lt;charT&gt;::alnum 
650              | std::ctype&lt;charT&gt;::alpha
651              | std::ctype&lt;charT&gt;::cntrl
652              | std::ctype&lt;charT&gt;::digit
653              | std::ctype&lt;charT&gt;::graph
654              | std::ctype&lt;charT&gt;::lower
655              | std::ctype&lt;charT&gt;::print
656              | std::ctype&lt;charT&gt;::punct
657              | std::ctype&lt;charT&gt;::space
658              | std::ctype&lt;charT&gt;::upper
659              | std::ctype&lt;charT&gt;::xdigit);
660        if((f &amp; mask_base) 
661           &amp;&amp; (m_pimpl-&gt;m_pctype-&gt;is(
662              static_cast&lt;ctype_mask&gt;(f &amp; mask_base), c)))
663           return true;
664        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_unicode) &amp;&amp; BOOST_REGEX_DETAIL_NS::is_extended(c))
665           return true;
666        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_word) &amp;&amp; (c == &#x27;_&#x27;))
667           return true;
668        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_blank) 
669           &amp;&amp; m_pimpl-&gt;m_pctype-&gt;is(std::ctype&lt;charT&gt;::space, c)
670           &amp;&amp; !BOOST_REGEX_DETAIL_NS::is_separator(c))
671           return true;
672        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical) 
673           &amp;&amp; (::boost::BOOST_REGEX_DETAIL_NS::is_separator(c) || (c == &#x27;\v&#x27;)))
674           return true;
675        else if((f &amp; BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_horizontal) 
676           &amp;&amp; this-&gt;isctype(c, std::ctype&lt;charT&gt;::space) &amp;&amp; !this-&gt;isctype(c, BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt;::mask_vertical))
677           return true;
678  #ifdef __CYGWIN__
679        else if((f &amp; std::ctype&lt;charT&gt;::xdigit) == std::ctype&lt;charT&gt;::xdigit)
680        {
681           if((c &gt;= &#x27;a&#x27;) &amp;&amp; (c &lt;= &#x27;f&#x27;))
682              return true;
683           if((c &gt;= &#x27;A&#x27;) &amp;&amp; (c &lt;= &#x27;F&#x27;))
684              return true;
685        }
686  #endif
687        return false;
688     }
689     std::intmax_t toi(const charT*&amp; p1, const charT* p2, int radix)const;
690     int value(charT c, int radix)const
691     {
692        const charT* pc = &amp;c;
693        return (int)toi(pc, pc + 1, radix);
694     }
695     locale_type imbue(locale_type l)
696     {
697        std::locale result(getloc());
698        m_pimpl = BOOST_REGEX_DETAIL_NS::create_cpp_regex_traits&lt;charT&gt;(l);
699        return result;
700     }
701     locale_type getloc()const
702     {
703        return m_pimpl-&gt;m_locale;
704     }
705     std::string error_string(regex_constants::error_type n) const
706     {
707        return m_pimpl-&gt;error_string(n);
708     }
709     static std::string catalog_name(const std::string&amp; name);
710     static std::string get_catalog_name();
711  private:
712     std::shared_ptr&lt;const BOOST_REGEX_DETAIL_NS::cpp_regex_traits_implementation&lt;charT&gt; &gt; m_pimpl;
713     static std::string&amp; get_catalog_name_inst();
714  #ifdef BOOST_HAS_THREADS
715     static std::mutex&amp; get_mutex_inst();
716  #endif
717  };
718  template &lt;class charT&gt;
719  std::intmax_t cpp_regex_traits&lt;charT&gt;::toi(const charT*&amp; first, const charT* last, int radix)const
720  {
721     BOOST_REGEX_DETAIL_NS::parser_buf&lt;charT&gt;   sbuf;            
722     std::basic_istream&lt;charT&gt;      is(&amp;sbuf);       
723     last = std::find(first, last, std::use_facet&lt;std::numpunct&lt;charT&gt;&gt;(is.getloc()).thousands_sep());
724     sbuf.pubsetbuf(const_cast&lt;charT*&gt;(static_cast&lt;const charT*&gt;(first)), static_cast&lt;std::streamsize&gt;(last-first));
725     is.clear();
726     if(std::abs(radix) == 16) is &gt;&gt; std::hex;
727     else if(std::abs(radix) == 8) is &gt;&gt; std::oct;
728     else is &gt;&gt; std::dec;
729     std::intmax_t val;
730     if(is &gt;&gt; val)
731     {
732        first = first + ((last - first) - sbuf.in_avail());
733        return val;
734     }
735     else
736        return -1;
737  }
738  template &lt;class charT&gt;
739  std::string cpp_regex_traits&lt;charT&gt;::catalog_name(const std::string&amp; name)
740  {
741  #ifdef BOOST_HAS_THREADS
742     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
743  #endif
744     std::string result(get_catalog_name_inst());
745     get_catalog_name_inst() = name;
746     return result;
747  }
748  template &lt;class charT&gt;
749  std::string&amp; cpp_regex_traits&lt;charT&gt;::get_catalog_name_inst()
750  {
751     static std::string s_name;
752     return s_name;
753  }
754  template &lt;class charT&gt;
755  std::string cpp_regex_traits&lt;charT&gt;::get_catalog_name()
756  {
757  #ifdef BOOST_HAS_THREADS
758     std::lock_guard&lt;std::mutex&gt; lk(get_mutex_inst());
759  #endif
760     std::string result(get_catalog_name_inst());
761     return result;
762  }
763  #ifdef BOOST_HAS_THREADS
764  template &lt;class charT&gt;
765  std::mutex&amp; cpp_regex_traits&lt;charT&gt;::get_mutex_inst()
766  {
767     static std::mutex s_mutex;
768     return s_mutex;
769  }
770  #endif
771  namespace BOOST_REGEX_DETAIL_NS {
772     inline void cpp_regex_traits_char_layer&lt;char&gt;::init()
773     {
774        std::memset(m_char_map, 0, sizeof(m_char_map));
775  #ifndef __IBMCPP__
776        std::messages&lt;char&gt;::catalog cat = static_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
777  #else
778        std::messages&lt;char&gt;::catalog cat = reinterpret_cast&lt;std::messages&lt;char&gt;::catalog&gt;(-1);
779  #endif
780        std::string cat_name(cpp_regex_traits&lt;char&gt;::get_catalog_name());
781        if ((!cat_name.empty()) &amp;&amp; (m_pmessages != 0))
782        {
783           cat = this-&gt;m_pmessages-&gt;open(
784              cat_name,
785              this-&gt;m_locale);
786           if ((int)cat &lt; 0)
787           {
788              std::string m(&quot;Unable to open message catalog: &quot;);
789              std::runtime_error err(m + cat_name);
790              boost::BOOST_REGEX_DETAIL_NS::raise_runtime_error(err);
791           }
792        }
793        if ((int)cat &gt;= 0)
794        {
795  #ifndef BOOST_NO_EXCEPTIONS
796           try {
797  #endif
798              for (regex_constants::syntax_type i = 1; i &lt; regex_constants::syntax_max; ++i)
799              {
800                 string_type mss = this-&gt;m_pmessages-&gt;get(cat, 0, i, get_default_syntax(i));
801                 for (string_type::size_type j = 0; j &lt; mss.size(); ++j)
802                 {
803                    m_char_map[static_cast&lt;unsigned char&gt;(mss[j])] = i;
804                 }
805              }
806              this-&gt;m_pmessages-&gt;close(cat);
807  #ifndef BOOST_NO_EXCEPTIONS
808           }
809           catch (...)
810           {
811              this-&gt;m_pmessages-&gt;close(cat);
812              throw;
813           }
814  #endif
815        }
816        else
817        {
818           for (regex_constants::syntax_type j = 1; j &lt; regex_constants::syntax_max; ++j)
819           {
820              const char* ptr = get_default_syntax(j);
821              while (ptr &amp;&amp; *ptr)
822              {
823                 m_char_map[static_cast&lt;unsigned char&gt;(*ptr)] = j;
824                 ++ptr;
825              }
826           }
827        }
828        unsigned char i = &#x27;A&#x27;;
829        do
830        {
831           if (m_char_map[i] == 0)
832           {
833              if (this-&gt;m_pctype-&gt;is(std::ctype_base::lower, i))
834                 m_char_map[i] = regex_constants::escape_type_class;
835              else if (this-&gt;m_pctype-&gt;is(std::ctype_base::upper, i))
836                 m_char_map[i] = regex_constants::escape_type_not_class;
837           }
838        } while (0xFF != i++);
839     }
840  } 
841  } 
842  #ifdef BOOST_REGEX_MSVC
843  #pragma warning(pop)
844  #endif
845  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-c_regex_traits.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-cpp_regex_traits.hpp</div>
                </div>
                <div class="column column_space"><pre><code>363     if (!name.empty())
364        return string_type(name.begin(), name.end());
365     if (p2 - p1 == 1)
366        return string_type(1, *p1);
367     return string_type();
368  }
369  inline int  c_regex_traits&lt;wchar_t&gt;::value(wchar_t c, int radix)
</pre></code></div>
                <div class="column column_space"><pre><code>457     if(!name.empty())
458        return string_type(name.begin(), name.end());
459     if(p2 - p1 == 1)
460        return string_type(1, *p1);
461     return string_type();
462  }
463  template &lt;class charT&gt;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    