
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5839793281653747%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SplitterContainer.h</h3>
            <pre><code>1  #pragma once
2  #include "Splitter.h"
3  #include "menuCmdID.h"
4  #define SPC_CLASS_NAME TEXT("splitterContainer")
5  #define ROTATION_LEFT 2000
6  #define ROTATION_RIGHT 2001
7  enum class DIRECTION
8  {
9  	RIGHT,
10  	LEFT
11  };
12  class SplitterContainer : public Window
13  {
14  public :
15  	virtual ~SplitterContainer() = default;
16  	void create(Window *pWin0, Window *pWin1, int splitterSize,
17  		SplitterMode mode = SplitterMode::DYNAMIC, int ratio = 50, bool _isVertical = true);
18  	void destroy();
19  	void reSizeTo(RECT & rc);
20  	virtual void display(bool toShow = true) const;
21  	virtual void redraw(bool forceUpdate = false) const;
22  	void setWin0(Window* pWin)
23  	{
24  		_pWin0 = pWin;
25  	}
26  	void setWin1(Window* pWin)
27  	{
28  		_pWin1 = pWin;
29  	}
30  	bool isVertical() const
31  	{
32  		return ((_dwSplitterStyle & SV_VERTICAL) != 0);
33  	}
34  private :
<span onclick='openModal()' class='match'>35  	Window* _pWin0 = nullptr; 
36  	Window* _pWin1 = nullptr; 
37  	Splitter _splitter;
38  	int _splitterSize = 0;
39  	int _ratio = 0;
40  	int _x = 0;
41  	int _y = 0;
</span>42  	HMENU _hPopupMenu = NULL;
43  	DWORD _dwSplitterStyle = (SV_ENABLERDBLCLK | SV_ENABLELDBLCLK | SV_RESIZEWTHPERCNT);
44  	SplitterMode _splitterMode = SplitterMode::DYNAMIC;
45  	static bool _isRegistered;
46  	static LRESULT CALLBACK staticWinProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam);
47  	LRESULT runProc(UINT Message, WPARAM wParam, LPARAM lParam);
48  	void rotateTo(DIRECTION direction);
49  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</h3>
            <pre><code>1  #include "cyc.h"
2  TStr TCycVrtx::GetCycVrtxFlagStr(const TCycVrtxFlag& CycVrtxFlag){
3    switch (CycVrtxFlag){
4      case cvfUndef: return "Undef";
5      case cvfNum: return "Num";
6      case cvfStr: return "Str";
7      case cvfCycL: return "CycL";
8      case cvfCycLConst: return "CycLConst"; 
9      case cvfCycLExpr: return "CycLExpr";
10      case cvfCycLPred: return "CycLPred";
11      case cvfBackLink: return "BackLink";
12      case cvfHumanOk: return "HumanOk";
13      case cvfHumanRelevant: return "HumanRelevant";
14      case cfvHumanIrrelevant: return "HumanIrrelevant";
15      case cfvHumanClarifying: return "HumanClarifying";
16      default: Fail; return "";
17    }
18  }
19  TStr TCycVrtx::GetFlagStr() const {
20    TChA ChA;
21    ChA+='[';
22    for (int FlagId=cvfMn; FlagId<cvfMx; FlagId++){
23      if (IsFlag(FlagId)){
24        if (ChA.Len()>1){ChA+=' ';}
25        ChA+=GetCycVrtxFlagStr(TCycVrtxFlag(FlagId));
26      }
27    }
28    ChA+=']';
29    return ChA;
30  }
31  int TCycBs::AddVNm(const TStr& VNm){
32    int VId;
33    if (VNmToVrtxH.IsKey(VNm.CStr(), VId)){
34      return VId;
35    } else {
36      VId=VNmToVrtxH.AddKey(VNm);
37      TCycVrtx& Vrtx=VNmToVrtxH[VId];
38      Vrtx.PutVId(VId);
39      if (VNm.IsPrefix("~")){
40        Vrtx.SetFlag(cvfBackLink);
41      } else
42      if (VNm.IsPrefix("#$")&&(!VNm.IsChIn(' '))){
43        Vrtx.SetFlag(cvfCycL);
44        if (VNm.Len()>2){
45          char Ch=VNm[2];
46          if (('a'<=Ch)&&(Ch<='z')){
47            Vrtx.SetFlag(cvfCycLPred);
48          } else {
49            Vrtx.SetFlag(cvfCycLConst);
50          }
51        }
52      } else
53      if (VNm.IsPrefix("(#$")){
54        Vrtx.SetFlag(cvfCycL);
55        Vrtx.SetFlag(cvfCycLExpr);
56      } else {
57        if (VNm.IsFlt()){
58          Vrtx.SetFlag(cvfNum);
59        } else {
60          Vrtx.SetFlag(cvfStr);
61        }
62      }
63      return VId;
64    }
65  }
66  void TCycBs::GetRelNmV(TStrV& RelNmV){
67    TStrH RelNmH;
68    for (int VId=0; VId<GetVIds(); VId++){
69      TStr VNm=GetVNm(VId);
70      TCycVrtx& Vrtx=GetVrtx(VId);
71      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
72        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
73        TStr RelNm=GetVNm(Edge.GetRelId());
74        RelNmH.AddKey(RelNm);
75      }
76    }
77    RelNmH.GetKeyV(RelNmV);
78  }
79  TStr TCycBs::GetDocStrFromCycLConstStr(const TStr& CycLConstStr){
80    TChA ChA=CycLConstStr;
81    TChA DstChA;
82    if ((ChA.Len()>2)&&(ChA[0]=='#')&&(ChA[1]=='$')){
83      int ChN=2;
84      while (ChN<ChA.Len()){
85        if (DstChA.Len()>0){DstChA+=' ';}
86        if ((ChA[ChN]=='-')||(ChA[ChN]=='_')||(ChA[ChN]==':')){
87          DstChA+="-"; ChN++;
88        } else
89        if (('0'<=ChA[ChN])&&(ChA[ChN]<='9')){
90          do {
91            DstChA+=ChA[ChN]; ChN++;
92          } while ((ChN<ChA.Len())&&('0'<=ChA[ChN])&&(ChA[ChN]<='9'));
93        } else
94        if (('a'<=ChA[ChN])&&(ChA[ChN]<='z')){
95          do {
96            DstChA+=ChA[ChN]; ChN++;
97          } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
98        } else
99        if (('A'<=ChA[ChN])&&(ChA[ChN]<='Z')){
100          if ((ChN+1<ChA.Len())&&('a'<=ChA[ChN+1])&&(ChA[ChN+1]<='z')){
101            do {
102              DstChA+=ChA[ChN]; ChN++;
103            } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
104          } else {
105            do {
106              DstChA+=ChA[ChN]; ChN++;
107            } while (((ChN==ChA.Len()-1)&&('A'<=ChA[ChN])&&(ChA[ChN]<='Z'))||
108              ((ChN+1<ChA.Len())&&('A'<=ChA[ChN+1])&&(ChA[ChN+1]<='Z')));
109          }
110        } else {
111          DstChA=""; break;
112        }
113      }
114    } else {
115      DstChA="";
116    }
117    return DstChA;
118  }
119  PLwOnto TCycBs::LoadCycVoc(const TStr& CycBsFNm, const bool& HumanOkOnlyP){
120    printf("Loading Cyc-Base from Binary-File '%s' ... ", CycBsFNm.CStr());
121    PCycBs CycBs=TCycBs::LoadBin(CycBsFNm);
122    int VIds=CycBs->GetVIds();
123    printf("Done.\n");
124    PLwOnto LwOnto=TLwOnto::New();
125    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
126    PLwTermType C_TermType=TLwTermType::New(0, "Class", EnLangId);
127    PLwTermType L_TermType=TLwTermType::New(1, "Lexical", EnLangId);
128    int C_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(C_TermType);
129    int L_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(L_TermType);
130    {printf("Creating link-types ...");
131    TStrV RelNmV; CycBs->GetRelNmV(RelNmV);
132    for (int RelNmN=0; RelNmN<RelNmV.Len(); RelNmN++){
133      TStr RelNm=RelNmV[RelNmN];
134      if (RelNm[0]=='~'){continue;}
135      PLwLinkType LinkType=TLwLinkType::New(RelNmN, RelNm, EnLangId, "");
136      LwOnto->GetLinkTypeBs()->AddLinkType(LinkType);
137    }
138    printf(" Done. (%d)\n", LwOnto->GetLinkTypeBs()->GetLinkTypes());}
139    {printf("Creating terms ...\n");
140    for (int VId=0; VId<VIds; VId++){
141      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
142      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
143      if (Vrtx.IsFlag(cvfCycLPred)){continue;}
144      if ((!Vrtx.IsFlag(cvfStr))&&
145       (HumanOkOnlyP&&(!Vrtx.IsFlag(cvfHumanOk)))){continue;}
146      TStr VNm=CycBs->GetVNm(VId);
147      int TermTypeId=(Vrtx.IsFlag(cvfStr)) ? L_TermTypeId : C_TermTypeId;
148      PLwTerm Term=TLwTerm::New(VId, VNm, EnLangId, TermTypeId);
149      LwOnto->GetTermBs()->AddTerm(Term);
150    }
151    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
152    {printf("Creating links ...\n");
153    for (int VId=0; VId<VIds; VId++){
154      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
155      if (!LwOnto->GetTermBs()->IsTermId(VId)){continue;}
156      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
157      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
158        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
159        int DstVId=Edge.GetDstVId();
160        if (!LwOnto->GetTermBs()->IsTermId(DstVId)){continue;}
161        TStr RelNm=CycBs->GetVNm(Edge.GetRelId());
162        if (LwOnto->GetLinkTypeBs()->IsLinkType(RelNm, EnLangId)){
163          int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(RelNm, EnLangId);
164          LwOnto->GetLinkBs()->AddLink(VId, LinkTypeId, DstVId);
165        }
166      }
167    }
168    printf("Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
169    return LwOnto;
170  }
171  void TCycBs::SaveTxt(const TStr& FNm){
172    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
173    for (int VId=0; VId<GetVIds(); VId++){
174      TStr VNm=GetVNm(VId);
175      TCycVrtx& Vrtx=GetVrtx(VId);
176      TStr FlagStr=Vrtx.GetFlagStr();
177      fprintf(fOut, "(%d) %s - %s\n", VId, VNm.CStr(), FlagStr.CStr());
178      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
179        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, "     %d. [%s] --> %s\n", 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
183      }
184    }
185  }
186  void TCycBs::_SaveTaxonomyTxt(FILE* fOut, 
187   const int& Lev, TIntPrV& RelIdVIdPrV, TIntIntH& VIdToLevH){
188    for (int VidN=0; VidN<RelIdVIdPrV.Len(); VidN++){
189      int FromRelId=RelIdVIdPrV[VidN].Val1;
190      int SrcVId=RelIdVIdPrV[VidN].Val2;
191      TStr SrcVNm=GetVNm(SrcVId);
192      TCycVrtx& SrcVrtx=GetVrtx(SrcVId);
193      if (!SrcVrtx.IsFlag(cvfHumanOk)){continue;}
194      TStr FlagStr=SrcVrtx.GetFlagStr();
195      if (FromRelId==-1){
196        if (Lev>0){fprintf(fOut, "===upper");} else {fprintf(fOut, "===lower");}
197        fprintf(fOut, "=======================================================\n");
198        fprintf(fOut, "%s - %s\n", SrcVNm.CStr(), FlagStr.CStr());
199      } else {
200        TStr FromRelNm=GetVNm(FromRelId);
201        fprintf(fOut, "%*c[%s] --> %s\n", (Lev-1)*5, ' ', FromRelNm.CStr(), SrcVNm.CStr());
202      }
203      TIntPrV UpRelIdVIdPrV;
204      for (int EdgeN=0; EdgeN<SrcVrtx.GetEdges(); EdgeN++){
205        TCycEdge& Edge=SrcVrtx.GetEdge(EdgeN);
206        int RelId=Edge.GetRelId();
207        int DstVId=Edge.GetDstVId();
208        TStr RelNm=GetVNm(RelId);
209        TStr DstVNm=GetVNm(DstVId);
210        if (Lev>0){
211          if ((RelNm=="#$isa")||(RelNm=="#$genls")){
212            if (!VIdToLevH.IsKey(DstVId)){
213              VIdToLevH.AddDat(DstVId, Lev+1);
214              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
215            }
216          }
217        } else {
218          if ((RelNm=="~#$isa")||(RelNm=="~#$genls")){
219            if (!VIdToLevH.IsKey(DstVId)){
220              VIdToLevH.AddDat(DstVId, Lev-1);
221              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
222            }
223          }
224        }
225      } 
226      if (Lev>0){
227        _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);
228      } else {
229        _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);
230      }
231    }
232  }
233  void TCycBs::SaveTaxonomyTxt(const TStr& FNm){
234    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
235    for (int VId=0; VId<GetVIds(); VId++){
236      printf("%d/%d (%.1f%%)\r", 1+VId, GetVIds(), 100.0*(1+VId)/GetVIds());
237      {int Lev=0;
238      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
239      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
240      _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);}
241      {int Lev=0;
242      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
243      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
244      _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);}
245    }
246    printf("\n");
247  }
248  void TCycBs::SaveStatTxt(const TStr& FNm){
249    PMom CommentLenMom=TMom::New();
250    PMom StrsLenMom=TMom::New();
251    PMom HumanOk_StrsLenMom=TMom::New();
252    PMom ClassesPerStrMom=TMom::New();
253    PMom StrsPerClassMom=TMom::New();
254    PMom HumanOk_StrsPerClassMom=TMom::New();
255    PMom IsasPerClassMom=TMom::New();
256    PMom HumanOk_IsasPerClassMom=TMom::New();
257    PMom GenlsPerClassMom=TMom::New();
258    PMom HumanOk_GenlsPerClassMom=TMom::New();
259    PMom IsasGenlsPerClassMom=TMom::New();
260    PMom HumanOk_IsasGenlsPerClassMom=TMom::New();
261    int Classes=0;
262    int HumanOk_Classes=0;
263    int Comments=0;
264    int HumanOk_Comments=0;
265    for (int VId=0; VId<GetVIds(); VId++){
266      TStr VNm=GetVNm(VId);
<span onclick='openModal()' class='match'>267      TCycVrtx& Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
</span>272      int Isas=0; int Genls=0;
273      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
274        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx& DstVrtx=GetVrtx(Edge.GetDstVId());
278        if (RelNm=="#$comment"){
279          CommentLenMom->Add(DstVNm.Len());
280          Comments++; 
281          if (Vrtx.IsFlag(cvfHumanOk)){HumanOk_Comments++;}
282        }
283        if (DstVrtx.IsFlag(cvfStr)){StrsLen+=DstVNm.Len();}
284        if (Vrtx.IsFlag(cvfStr)){ClassesPerStrInstance++;}
285        if (RelNm=="#$nameString"){NmStrs++;}
286        if (RelNm=="~#$nameString"){BackLinkNmStrs++;}
287        if (RelNm=="#$isa"){Isas++;}
288        if (RelNm=="#$genls"){Genls++;}
289      }
290      if (Vrtx.IsFlag(cvfCycL)){Classes++;}
291      if (Vrtx.IsFlag(cvfCycL)){StrsLenMom->Add(StrsLen);}
292      if (Vrtx.IsFlag(cvfStr)){ClassesPerStrMom->Add(BackLinkNmStrs);}
293      if (Vrtx.IsFlag(cvfCycL)){StrsPerClassMom->Add(NmStrs);}
294      if (Vrtx.IsFlag(cvfCycL)){IsasPerClassMom->Add(Isas);}
295      if (Vrtx.IsFlag(cvfCycL)){GenlsPerClassMom->Add(Genls);}
296      if (Vrtx.IsFlag(cvfCycL)){IsasGenlsPerClassMom->Add(Isas+Genls);}
297      if (Vrtx.IsFlag(cvfHumanOk)){
298        if (Vrtx.IsFlag(cvfCycL)){HumanOk_Classes++;}
299        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsLenMom->Add(StrsLen);}
300        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsPerClassMom->Add(NmStrs);}
301        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasPerClassMom->Add(Isas);}
302        if (Vrtx.IsFlag(cvfCycL)){HumanOk_GenlsPerClassMom->Add(Genls);}
303        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasGenlsPerClassMom->Add(Isas+Genls);}
304      }
305    }
306    CommentLenMom->Def();
307    StrsLenMom->Def();
308    HumanOk_StrsLenMom->Def();
309    ClassesPerStrMom->Def();
310    StrsPerClassMom->Def();
311    HumanOk_StrsPerClassMom->Def();
312    IsasPerClassMom->Def();
313    HumanOk_IsasPerClassMom->Def();
314    GenlsPerClassMom->Def();
315    HumanOk_GenlsPerClassMom->Def();
316    IsasGenlsPerClassMom->Def();
317    HumanOk_IsasGenlsPerClassMom->Def();
318    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
319    fprintf(fOut, "CommentLen: %s\n", CommentLenMom->GetStr().CStr());
320    fprintf(fOut, "StrsLen: %s\n", StrsLenMom->GetStr().CStr());
321    fprintf(fOut, "HumanOk_StrsLen: %s\n", HumanOk_StrsLenMom->GetStr().CStr());
322    fprintf(fOut, "ClassesPerStr: %s\n", ClassesPerStrMom->GetStr().CStr());
323    fprintf(fOut, "StrsPerClass: %s\n", StrsPerClassMom->GetStr().CStr());
324    fprintf(fOut, "HumanOk_StrsPerClass: %s\n", HumanOk_StrsPerClassMom->GetStr().CStr());
325    fprintf(fOut, "IsasPerClass: %s\n", IsasPerClassMom->GetStr().CStr());
326    fprintf(fOut, "HumanOk_IsasPerClass: %s\n", HumanOk_IsasPerClassMom->GetStr().CStr());
327    fprintf(fOut, "GenlsPerClass: %s\n", GenlsPerClassMom->GetStr().CStr());
328    fprintf(fOut, "HumanOk_GenlsPerClass: %s\n", HumanOk_GenlsPerClassMom->GetStr().CStr());
329    fprintf(fOut, "IsasGenlsPerClass: %s\n", IsasGenlsPerClassMom->GetStr().CStr());
330    fprintf(fOut, "HumanOk_IsasGenlsPerClass: %s\n", HumanOk_IsasGenlsPerClassMom->GetStr().CStr());
331    fprintf(fOut, "Classes: %d\n", Classes);
332    fprintf(fOut, "HumanOk_Classes: %d\n", HumanOk_Classes);
333    fprintf(fOut, "Comments: %d\n", Comments);
334    fprintf(fOut, "HumanOk_Comments: %d\n", HumanOk_Comments);
335    fprintf(fOut, "End");}
336  }
337  PCycBs TCycBs::LoadCycXmlDump(const TStr& FPath){
338    TStr NrFPath=TStr::GetNrFPath(FPath);
339    TStr CycLexiconFNm=NrFPath+"lexicon-dump.xml";
340    TStr CycTaxonomyFNm=NrFPath+"taxonomy-dump.xml";
341    TStr CycRelevanceFNm=NrFPath+"relevance-dump.xml";
342    TStr CycKBaseFNm=NrFPath+"kb-dump.xml";                                                 
343    PCycBs CycBs=TCycBs::New();
344    {printf("Processing Lexicon %s ...\n", CycLexiconFNm.CStr());
345    PSIn CycLexiconSIn=TFIn::New(CycLexiconFNm);
346    PXmlDoc XmlDoc; int XmlDocs=0;
347    TStr PrevCycWStr; TStr PrevCycLStr;
348    forever{
349      XmlDocs++; if (XmlDocs%1000==0){printf("%d Docs\r", XmlDocs);}
350      XmlDoc=TXmlDoc::LoadTxt(CycLexiconSIn);
351      if (!XmlDoc->IsOk()){
352        printf("%s - %s\n", PrevCycWStr.CStr(), PrevCycLStr.CStr());
353        Fail;
354      }
355      PXmlTok TopTok=XmlDoc->GetTok();
356      if (TopTok->IsTag("end")){break;}
357      IAssert(TopTok->IsTag("word"));
358      TStr CycWStr=TopTok->GetArgVal("string");
359      TStr CycLStr=TopTok->GetArgVal("cycl");
360      PrevCycWStr=CycWStr; PrevCycLStr;
361      CycBs->AddEdge(CycLStr, "#$nameString", CycWStr);
362      CycBs->AddEdge(CycWStr, "~#$nameString", CycLStr);
363    }
364    printf("%d Docs\nDone.\n", XmlDocs);}
365    {printf("Processing Taxonomy %s ...\n", CycTaxonomyFNm.CStr());
366    PSIn CycTaxonomySIn=TFIn::New(CycTaxonomyFNm);
367    PXmlDoc XmlDoc; int XmlDocs=0;
368    TStr PrevSrcCycLStr;
369    forever{
370      XmlDocs++;
371      if (XmlDocs%1000==0){
372        printf("%d Docs\r", XmlDocs);}
373      XmlDoc=TXmlDoc::LoadTxt(CycTaxonomySIn);
374      if (!XmlDoc->IsOk()){
375        printf("%s\n", PrevSrcCycLStr.CStr());
376        Fail;
377      }
378      PXmlTok TopTok=XmlDoc->GetTok();
379      if (TopTok->IsTag("end")){break;}
380      IAssert(TopTok->IsTag("term"));
381      TStr SrcCycLStr=TopTok->GetArgVal("cycl");
382      PrevSrcCycLStr=SrcCycLStr;
383      for (int SubTokN=0; SubTokN<TopTok->GetSubToks(); SubTokN++){
384        PXmlTok SubTok=TopTok->GetSubTok(SubTokN);
385        TStr DstCycLStr=SubTok->GetTagNm();
386        if (SubTok->IsTag("isa")){
387          DstCycLStr=SubTok->GetArgVal("value");
388          CycBs->AddEdge(SrcCycLStr, "#$isa", DstCycLStr);
389          CycBs->AddEdge(DstCycLStr, "~#$isa", SrcCycLStr);
390        } else
391        if (SubTok->IsTag("genl")){
392          DstCycLStr=SubTok->GetArgVal("value");
393          CycBs->AddEdge(SrcCycLStr, "#$genls", DstCycLStr);
394          CycBs->AddEdge(DstCycLStr, "~#$genls", SrcCycLStr);
395        } else {
396          Fail;
397        }
398      }
399    }
400    printf("%d Docs\nDone.\n", XmlDocs);}
401    {printf("Processing Relevance %s ...\n", CycRelevanceFNm.CStr());
402    PSIn CycRelevanceSIn=TFIn::New(CycRelevanceFNm);
403    PXmlDoc XmlDoc; int XmlDocs=0;
404    TStr PrevCycStr;
405    forever{
406      XmlDocs++;
407      if (XmlDocs%1000==0){
408        printf("%d Docs\r", XmlDocs);}
409      XmlDoc=TXmlDoc::LoadTxt(CycRelevanceSIn);
410      if (!XmlDoc->IsOk()){
411        printf("%s\n", PrevCycStr.CStr());
412        Fail;
413      }
414      PXmlTok TopTok=XmlDoc->GetTok();
415      if (TopTok->IsTag("end")){break;}
416      IAssert(TopTok->IsTag("term"));
417      TStr CycStr=TopTok->GetArgVal("cyc");
418      PrevCycStr=CycStr;
419      if (CycBs->IsVNm(CycStr)){
420        if (TopTok->GetArgVal("thcl")=="T"){
421          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanRelevant, true);}
422        if (TopTok->GetArgVal("irrel")=="T"){
423          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanIrrelevant, true);}
424        if (TopTok->GetArgVal("clarifying")=="T"){
425          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanClarifying, true);}
426        if ((TopTok->GetArgVal("thcl")=="T")||(TopTok->GetArgVal("clarifying")=="T")){
427          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanOk, true);}
428      } else {
429      }
430    }
431    printf("%d Docs\nDone.\n", XmlDocs);}
432    {printf("Processing KBase %s ...\n", CycKBaseFNm.CStr());
433    PSIn CycKBaseSIn=TFIn::New(CycKBaseFNm);
434    PXmlDoc XmlDoc; int XmlDocs=0;
435    TStr PrevCycLStr; TStrV PrevArgCycLStrV;
436    TStrIntH HdCycLToFq;
437    forever{
438      XmlDocs++;
439      if (XmlDocs%1000==0){
440        printf("%d Docs\r", XmlDocs);}
441      XmlDoc=TXmlDoc::LoadTxt(CycKBaseSIn);
442      if (!XmlDoc->IsOk()){
443        printf("%s\n", PrevCycLStr.CStr());
444        for (int ArgN=0; ArgN<PrevArgCycLStrV.Len(); ArgN++){
445          printf(" [%s]", PrevArgCycLStrV[ArgN].CStr());}
446        printf("\n");
447        Fail;
448      }
449      PXmlTok TopTok=XmlDoc->GetTok();
450      if (TopTok->IsTag("end")){break;}
451      IAssert(TopTok->IsTag("sentence"));
452      TStr CycLStr=TopTok->GetArgVal("cycl");
453      TXmlTokV ArgXmlTokV; XmlDoc->GetTagTokV("sentence|arg", ArgXmlTokV);
454      TStrV ArgCycLStrV;
455      for (int ArgN=0; ArgN<ArgXmlTokV.Len(); ArgN++){
456        PXmlTok Tok=ArgXmlTokV[ArgN];
457        IAssert(Tok->IsTag("arg"));
458        if (Tok->IsArg("cycl")){
459          TStr ArgCycLStr=Tok->GetArgVal("cycl");
460          ArgCycLStrV.Add(ArgCycLStr);
461        } else {
462          ArgCycLStrV.Add("Empty");
463        }
464      }
465      PrevCycLStr=CycLStr;
466      PrevArgCycLStrV=ArgCycLStrV;
467      if (ArgCycLStrV.Len()>0){
468        HdCycLToFq.AddDat(ArgCycLStrV[0]+" - "+TInt::GetStr(ArgCycLStrV.Len()-1))++;}
469      if (ArgCycLStrV.Len()==3){
470        TStr PredNm=ArgCycLStrV[0];
471        if ((PredNm!="#$isa")&&(PredNm!="#$termOfUnit")&&(PredNm!="#$genls")){
472          TStr BackLinkPredNm=TStr("~")+PredNm;
473          TStr Arg1=ArgCycLStrV[1];
474          TStr Arg2=ArgCycLStrV[2];
475          CycBs->AddEdge(Arg1, PredNm, Arg2);
476          CycBs->AddEdge(Arg2, BackLinkPredNm, Arg1);
477        }
478      }
479    }
480    {TFOut CycLSOut("CycKB-CycLFq.Stat.Txt"); FILE* fCycL=CycLSOut.GetFileId();
481    TIntStrPrV FqCycLStrPrV; HdCycLToFq.GetDatKeyPrV(FqCycLStrPrV); 
482    FqCycLStrPrV.Sort(false);
483    for (int CycLN=0; CycLN<FqCycLStrPrV.Len(); CycLN++){
484      fprintf(fCycL, "%6d. %s\n", 1+FqCycLStrPrV[CycLN].Val1, FqCycLStrPrV[CycLN].Val2.CStr());
485    }}
486    printf("%d Docs\nDone.\n", XmlDocs);}
487    return CycBs;
488  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-SplitterContainer.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>35  	Window* _pWin0 = nullptr; 
36  	Window* _pWin1 = nullptr; 
37  	Splitter _splitter;
38  	int _splitterSize = 0;
39  	int _ratio = 0;
40  	int _x = 0;
41  	int _y = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>267      TCycVrtx& Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    