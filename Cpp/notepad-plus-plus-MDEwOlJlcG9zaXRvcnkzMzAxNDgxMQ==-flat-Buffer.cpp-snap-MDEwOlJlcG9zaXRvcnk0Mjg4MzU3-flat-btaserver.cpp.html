
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.5931721194879087%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</h3>
            <pre><code>1  #include <deque>
2  #include <algorithm>
3  #include <time.h>
4  #include <locale>
5  #include <codecvt>
6  #include <sys/stat.h>
7  #include "Buffer.h"
8  #include "Scintilla.h"
9  #include "ILexer.h"
10  #include "Lexilla.h"
11  #include "Parameters.h"
12  #include "Notepad_plus.h"
13  #include "ScintillaEditView.h"
14  #include "EncodingMapper.h"
15  #include "uchardet.h"
16  #include "FileInterface.h"
17  static const int blockSize = 128 * 1024 + 4;
18  static const int CR = 0x0D;
19  static const int LF = 0x0A;
20  long Buffer::_recentTagCtr = 0;
21  namespace 
22  {
23  	static EolType getEOLFormatForm(const char* const data, size_t length, EolType defvalue = EolType::osdefault)
24  	{
25  		assert(length == 0 || (data != nullptr && "invalid buffer for getEOLFormatForm()"));
26  		for (size_t i = 0; i != length; ++i)
27  		{
28  			if (data[i] == CR)
29  			{
30  				if (i + 1 < length && data[i + 1] == LF)
31  					return EolType::windows;
32  				return EolType::macos;
33  			}
34  			if (data[i] == LF)
35  				return EolType::unix;
36  		}
37  		return defvalue; 
38  	}
39  } 
40  Buffer::Buffer(FileManager * pManager, BufferID id, Document doc, DocFileStatus type, const TCHAR *fileName, bool isLargeFile)
41  	: _pManager(pManager) , _id(id), _doc(doc), _lang(L_TEXT), _isLargeFile(isLargeFile)
42  {
43  	NppParameters& nppParamInst = NppParameters::getInstance();
44  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
45  	_eolFormat = ndds._format;
46  	_unicodeMode = ndds._unicodeMode;
47  	_encoding = ndds._codepage;
48  	if (_encoding != -1)
49  		_unicodeMode = uniCookie;
50  	_currentStatus = type;
51  	setFileName(fileName);
52  	updateTimeStamp();
53  	checkFileState();
54  	_canNotify = true;
55  }
56  void Buffer::doNotify(int mask)
57  {
58  	if (_canNotify)
59  	{
60  		assert(_pManager != nullptr);
61  		_pManager->beNotifiedOfBufferChange(this, mask);
62  	}
63  }
64  void Buffer::setDirty(bool dirty)
65  {
66  	_isDirty = dirty;
67  	doNotify(BufferChangeDirty);
68  }
69  void Buffer::setEncoding(int encoding)
70  {
71  	_encoding = encoding;
72  	doNotify(BufferChangeUnicode | BufferChangeDirty);
73  }
74  void Buffer::setUnicodeMode(UniMode mode)
75  {
76  	_unicodeMode = mode;
77  	doNotify(BufferChangeUnicode | BufferChangeDirty);
78  }
79  void Buffer::setLangType(LangType lang, const TCHAR* userLangName)
80  {
81  	if (lang == _lang && lang != L_USER)
82  		return;
83  	_lang = lang;
84  	if (_lang == L_USER)
85  		_userLangExt = userLangName;
86  	_needLexer = true;	
87  	doNotify(BufferChangeLanguage|BufferChangeLexing);
88  }
89  void Buffer::updateTimeStamp()
90  {
91  	FILETIME timeStampLive = {};
92  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
93  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
94  	{
95  		timeStampLive = attributes.ftLastWriteTime;
96  	}
97  	LONG res = CompareFileTime(&_timeStamp, &timeStampLive);
98  	if (res == -1 || res == 1)
99  	{
100  		if (res == 1)
101  		{
102  			NppParameters& nppParam = NppParameters::getInstance();
103  			if (nppParam.doNppLogNetworkDriveIssue())
104  			{
105  				generic_string issueFn = nppLogNetworkDriveIssue;
106  				issueFn += TEXT(".log");
107  				generic_string nppIssueLog = nppParam.getUserPath();
108  				pathAppend(nppIssueLog, issueFn);
109  				std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
110  				std::string msg = converter.to_bytes(_fullPathName);
111  				char buf[1024];
112  				sprintf(buf, "  in updateTimeStamp(): timeStampLive (%lu/%lu) < _timeStamp (%lu/%lu)", timeStampLive.dwLowDateTime, timeStampLive.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
113  				msg += buf;
114  				writeLog(nppIssueLog.c_str(), msg.c_str());
115  			}
116  		}
117  		_timeStamp = timeStampLive;
118  		doNotify(BufferChangeTimestamp);
119  	}
120  }
121  void Buffer::setFileName(const TCHAR *fn)
122  {
<span onclick='openModal()' class='match'>123  	NppParameters& nppParamInst = NppParameters::getInstance();
124  	if (_fullPathName == fn)
125  	{
126  		updateTimeStamp();
127  		doNotify(BufferChangeTimestamp);
128  		return;
129  	}
130  	_fullPathName = fn;
131  	_fileName = PathFindFileName(_fullPathName.c_str());
132  	LangType determinatedLang = L_TEXT;
133  	TCHAR *ext = PathFindExtension(_fullPathName.c_str());
</span>134  	if (*ext == '.') 
135  	{
136  		ext += 1;
137  		const TCHAR* langName = nppParamInst.getUserDefinedLangNameFromExt(ext, _fileName);
138  		if (langName)
139  		{
140  			determinatedLang = L_USER;
141  			_userLangExt = langName;
142  		}
143  		else 
144  		{
145  			_userLangExt.clear();
146  			determinatedLang = nppParamInst.getLangFromExt(ext);
147  		}
148  	}
149  	if (determinatedLang == L_TEXT)	
150  	{
151  		if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("makefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("GNUmakefile")) == 0))
152  			determinatedLang = L_MAKEFILE;
153  		else if (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("CmakeLists.txt")) == 0)
154  			determinatedLang = L_CMAKE;
155  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConstruct")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("SConscript")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("wscript")) == 0))
156  			determinatedLang = L_PYTHON;
157  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Rakefile")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("Vagrantfile")) == 0))
158  			determinatedLang = L_RUBY;
159  		else if ((OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("crontab")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("PKGBUILD")) == 0) || (OrdinalIgnoreCaseCompareStrings(_fileName, TEXT("APKBUILD")) == 0))
160  			determinatedLang = L_BASH;
161  	}
162  	updateTimeStamp();
163  	BufferStatusInfo lang2Change = BufferChangeNone;
164  	if (!_hasLangBeenSetFromMenu && (determinatedLang != _lang || _lang == L_USER))
165  	{
166  		if (_isLargeFile)
167  		{
168  			_lang = L_TEXT;
169  		}
170  		else
171  		{
172  			_lang = determinatedLang;
173  			lang2Change = BufferChangeLanguage;
174  		}
175  	}
176  	doNotify(BufferChangeFilename | BufferChangeTimestamp | lang2Change);
177  }
178  bool Buffer::checkFileState() 
179  {
180  	if (_currentStatus == DOC_UNNAMED || isMonitoringOn())
181  		return false;
182  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
183  	bool isWow64Off = false;
184  	NppParameters& nppParam = NppParameters::getInstance();
185  	if (!PathFileExists(_fullPathName.c_str()))
186  	{
187  		nppParam.safeWow64EnableWow64FsRedirection(FALSE);
188  		isWow64Off = true;
189  	}
190  	bool isOK = false;
191  	if (_currentStatus != DOC_DELETED && !PathFileExists(_fullPathName.c_str()))	
192  	{
193  		_currentStatus = DOC_DELETED;
194  		_isFileReadOnly = false;
195  		_isDirty = true;	
196  		_timeStamp = {};
197  		doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
198  		isOK = true;
199  	}
200  	else if (_currentStatus == DOC_DELETED && PathFileExists(_fullPathName.c_str()))
201  	{	
202  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
203  		{
204  			_isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
205  			_currentStatus = DOC_MODIFIED;
206  			_timeStamp = attributes.ftLastWriteTime;
207  			if (_reloadFromDiskRequestGuard.try_lock())
208  			{
209  				doNotify(BufferChangeStatus | BufferChangeReadonly | BufferChangeTimestamp);
210  				_reloadFromDiskRequestGuard.unlock();
211  			}
212  			isOK = true;
213  		}
214  	}
215  	else if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
216  	{
217  		int mask = 0;	
218  		bool isFileReadOnly = attributes.dwFileAttributes & FILE_ATTRIBUTE_READONLY;
219  		if (isFileReadOnly != _isFileReadOnly)
220  		{
221  			_isFileReadOnly = isFileReadOnly;
222  			mask |= BufferChangeReadonly;
223  		}
224  		LONG res = CompareFileTime(&_timeStamp, &attributes.ftLastWriteTime);
225  		if (res == -1 || res == 1)
226  		{
227  			if (res == 1)
228  			{
229  				NppParameters& nppParam = NppParameters::getInstance();
230  				if (nppParam.doNppLogNetworkDriveIssue())
231  				{
232  					generic_string issueFn = nppLogNetworkDriveIssue;
233  					issueFn += TEXT(".log");
234  					generic_string nppIssueLog = nppParam.getUserPath();
235  					pathAppend(nppIssueLog, issueFn);
236  					std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
237  					std::string msg = converter.to_bytes(_fullPathName);
238  					char buf[1024];
239  					sprintf(buf, "  in checkFileState(): attributes.ftLastWriteTime (%lu/%lu) < _timeStamp (%lu/%lu)", attributes.ftLastWriteTime.dwLowDateTime, attributes.ftLastWriteTime.dwHighDateTime, _timeStamp.dwLowDateTime, _timeStamp.dwHighDateTime);
240  					msg += buf;
241  					writeLog(nppIssueLog.c_str(), msg.c_str());
242  				}
243  			}
244  			_timeStamp = attributes.ftLastWriteTime;
245  			mask |= BufferChangeTimestamp;
246  			_currentStatus = DOC_MODIFIED;
247  			mask |= BufferChangeStatus;	
248  		}
249  		if (mask != 0)
250  		{
251  			if (_reloadFromDiskRequestGuard.try_lock())
252  			{
253  				doNotify(mask);
254  				_reloadFromDiskRequestGuard.unlock();
255  				return true;
256  			}
257  		}
258  		return false;
259  	}
260  	if (isWow64Off)
261  	{
262  		nppParam.safeWow64EnableWow64FsRedirection(TRUE);
263  	}
264  	return isOK;
265  }
266  void Buffer::reload()
267  {
268  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
269  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
270  	{
271  		_timeStamp = attributes.ftLastWriteTime;
272  		_currentStatus = DOC_NEEDRELOAD;
273  		doNotify(BufferChangeTimestamp | BufferChangeStatus);
274  	}
275  }
276  int64_t Buffer::getFileLength() const
277  {
278  	if (_currentStatus == DOC_UNNAMED)
279  		return -1;
280  	WIN32_FILE_ATTRIBUTE_DATA attributes{};
281  	if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
282  	{
283  		LARGE_INTEGER size{};
284  		size.LowPart = attributes.nFileSizeLow;
285  		size.HighPart = attributes.nFileSizeHigh;
286  		return size.QuadPart;
287  	}
288  	return -1;
289  }
290  generic_string Buffer::getFileTime(fileTimeType ftt) const
291  {
292  	generic_string result;
293  	if (_currentStatus != DOC_UNNAMED)
294  	{
295  		WIN32_FILE_ATTRIBUTE_DATA attributes{};
296  		if (GetFileAttributesEx(_fullPathName.c_str(), GetFileExInfoStandard, &attributes) != 0)
297  		{
298  			FILETIME rawtime;
299  			switch (ftt)
300  			{
301  				case ft_created:
302  					rawtime = attributes.ftCreationTime;
303  					break;
304  				case ft_modified:
305  					rawtime = attributes.ftLastWriteTime;
306  					break;
307  				default:
308  					rawtime = attributes.ftLastAccessTime;
309  					break;
310  			}
311  			SYSTEMTIME utcSystemTime, localSystemTime;
312  			FileTimeToSystemTime(&rawtime, &utcSystemTime);
313  			SystemTimeToTzSpecificLocalTime(nullptr, &utcSystemTime, &localSystemTime);
314  			const size_t dateTimeStrLen = 256;
315  			TCHAR bufDate[dateTimeStrLen] = {'\0'};
316  			GetDateFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufDate, dateTimeStrLen);
317  			result += bufDate;
318  			result += ' ';
319  			TCHAR bufTime[dateTimeStrLen] = {'\0'};
320  			GetTimeFormat(LOCALE_USER_DEFAULT, 0, &localSystemTime, nullptr, bufTime, dateTimeStrLen);
321  			result += bufTime;
322  		}
323  	}
324  	return result;
325  }
326  void Buffer::setPosition(const Position & pos, ScintillaEditView * identifier)
327  {
328  	int index = indexOfReference(identifier);
329  	if (index == -1)
330  		return;
331  	_positions[index] = pos;
332  }
333  Position& Buffer::getPosition(ScintillaEditView* identifier)
334  {
335  	int index = indexOfReference(identifier);
336  	return _positions.at(index);
337  }
338  void Buffer::setHeaderLineState(const std::vector<size_t> & folds, ScintillaEditView * identifier)
339  {
340  	int index = indexOfReference(identifier);
341  	if (index == -1)
342  		return;
343  	std::vector<size_t> & local = _foldStates[index];
344  	local.clear();
345  	size_t size = folds.size();
346  	for (size_t i = 0; i < size; ++i)
347  		local.push_back(folds[i]);
348  }
349  const std::vector<size_t> & Buffer::getHeaderLineState(const ScintillaEditView * identifier) const
350  {
351  	int index = indexOfReference(identifier);
352  	return _foldStates.at(index);
353  }
354  Lang * Buffer::getCurrentLang() const
355  {
356  	NppParameters& nppParam = NppParameters::getInstance();
357  	int i = 0;
358  	Lang *l = nppParam.getLangFromIndex(i);
359  	++i;
360  	while (l)
361  	{
362  		if (l->_langID == _lang)
363  			return l;
364  		l = nppParam.getLangFromIndex(i);
365  		++i;
366  	}
367  	return nullptr;
368  }
369  int Buffer::indexOfReference(const ScintillaEditView * identifier) const
370  {
371  	size_t size = _referees.size();
372  	for (size_t i = 0; i < size; ++i)
373  	{
374  		if (_referees[i] == identifier)
375  			return static_cast<int>(i);
376  	}
377  	return -1;	
378  }
379  int Buffer::addReference(ScintillaEditView * identifier)
380  {
381  	if (indexOfReference(identifier) != -1)
382  		return _references;
383  	_referees.push_back(identifier);
384  	_positions.push_back(Position());
385  	_foldStates.push_back(std::vector<size_t>());
386  	++_references;
387  	return _references;
388  }
389  int Buffer::removeReference(ScintillaEditView * identifier)
390  {
391  	int indexToPop = indexOfReference(identifier);
392  	if (indexToPop == -1)
393  		return _references;
394  	_referees.erase(_referees.begin() + indexToPop);
395  	_positions.erase(_positions.begin() + indexToPop);
396  	_foldStates.erase(_foldStates.begin() + indexToPop);
397  	_references--;
398  	return _references;
399  }
400  void Buffer::setHideLineChanged(bool isHide, size_t location)
401  {
402  	for (int i = 0; i < _references; ++i)
403  		_referees.at(i)->notifyMarkers(this, isHide, location, false); 
404  	if (!isHide) 
405  	{
406  		for (int i = 0; i < _references; ++i)
407  			_referees.at(i)->notifyMarkers(this, isHide, location, true);
408  	}
409  }
410  void Buffer::setDeferredReload() 
411  {
412  	_isDirty = false;	
413  	_needReloading = true;
414  	doNotify(BufferChangeDirty);
415  }
416  bool Buffer::allowBraceMach() const
417  {
418  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
419  	return (!_isLargeFile || nppGui._largeFileRestriction._allowBraceMatch) || !nppGui._largeFileRestriction._isEnabled;
420  }
421  bool Buffer::allowAutoCompletion() const
422  {
423  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
424  	return (!_isLargeFile || nppGui._largeFileRestriction._allowAutoCompletion) || !nppGui._largeFileRestriction._isEnabled;
425  }
426  bool Buffer::allowSmartHilite() const
427  {
428  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
429  	return (!_isLargeFile || nppGui._largeFileRestriction._allowSmartHilite) || !nppGui._largeFileRestriction._isEnabled;
430  }
431  bool Buffer::allowClickableLink() const
432  {
433  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
434  	return (!_isLargeFile || nppGui._largeFileRestriction._allowClickableLink) || !nppGui._largeFileRestriction._isEnabled;
435  }
436  FileManager::~FileManager()
437  {
438  	for (std::vector<Buffer *>::iterator it = _buffers.begin(), end = _buffers.end(); it != end; ++it)
439  	{
440  		delete *it;
441  	}
442  }
443  void FileManager::init(Notepad_plus * pNotepadPlus, ScintillaEditView * pscratchTilla)
444  {
445  	_pNotepadPlus = pNotepadPlus;
446  	_pscratchTilla = pscratchTilla;
447  	_pscratchTilla->execute(SCI_SETUNDOCOLLECTION, false);	
448  	_scratchDocDefault = (Document)_pscratchTilla->execute(SCI_GETDOCPOINTER);
449  	_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, _scratchDocDefault);
450  }
451  void FileManager::checkFilesystemChanges(bool bCheckOnlyCurrentBuffer)
452  {
453  	if (bCheckOnlyCurrentBuffer)
454  	{
455  		Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
456  		buffer->checkFileState();
457  	}
458  	else
459  	{
460  		for (int i = int(_nbBufs) - 1; i >= 0; i--)
461  		{
462  			if (i >= int(_nbBufs))
463  			{
464  				if (_nbBufs == 0)
465  					return;
466  				i = int(_nbBufs) - 1;
467  			}
468  			_buffers[i]->checkFileState();	
469  		}
470  	}
471  }
472  size_t FileManager::getNbDirtyBuffers() const
473  {
474  	size_t nb_dirtyBufs = 0;
475  	for (size_t i = 0; i < _nbBufs; ++i)
476  	{
477  		if (_buffers[i]->_isDirty)
478  			++nb_dirtyBufs;
479  	}
480  	return nb_dirtyBufs;
481  }
482  int FileManager::getBufferIndexByID(BufferID id)
483  {
484  	for (size_t i = 0; i < _nbBufs; ++i)
485  	{
486  		if (_buffers[i]->_id == id)
487  			return static_cast<int>(i);
488  	}
489  	return -1;
490  }
491  Buffer* FileManager::getBufferByIndex(size_t index)
492  {
493  	if (index >= _buffers.size())
494  		return nullptr;
495  	return _buffers.at(index);
496  }
497  void FileManager::beNotifiedOfBufferChange(Buffer* theBuf, int mask)
498  {
499  	_pNotepadPlus->notifyBufferChanged(theBuf, mask);
500  }
501  void FileManager::addBufferReference(BufferID buffer, ScintillaEditView * identifier)
502  {
503  	Buffer* buf = getBufferByID(buffer);
504  	buf->addReference(identifier);
505  }
506  void FileManager::closeBuffer(BufferID id, ScintillaEditView * identifier)
507  {
508  	int index = getBufferIndexByID(id);
509  	Buffer* buf = getBufferByIndex(index);
510  	int refs = buf->removeReference(identifier);
511  	if (!refs) 
512  	{
513  		_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, buf->_doc);	
514  		_buffers.erase(_buffers.begin() + index);
515  		delete buf;
516  		_nbBufs--;
517  	}
518  }
519  BufferID FileManager::loadFile(const TCHAR* filename, Document doc, int encoding, const TCHAR* backupFileName, FILETIME fileNameTimestamp)
520  {
521  	if (!filename)
522  		return BUFFER_INVALID;
523  	int64_t fileSize = -1;
524  	const TCHAR* pPath = filename;
525  	if (!::PathFileExists(pPath))
526  	{
527  		pPath = backupFileName;
528  	}
529  	if (pPath)
530  	{
531  		FILE* fp = _wfopen(pPath, TEXT("rb"));
532  		if (fp)
533  		{
534  			_fseeki64(fp, 0, SEEK_END);
535  			fileSize = _ftelli64(fp);
536  			fclose(fp);
537  		}
538  	}
539  	NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
540  	bool isLargeFile = false;
541  	if (nppGui._largeFileRestriction._isEnabled)
542  		isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
543  	if (isLargeFile && nppGui._largeFileRestriction._deactivateWordWrap)
544  	{
545  		bool isWrap = _pNotepadPlus->_pEditView->isWrap();
546  		if (isWrap)
547  		{
548  			_pNotepadPlus->command(IDM_VIEW_WRAP);
549  		}
550  	}
551  	bool ownDoc = false;
552  	if (!doc)
553  	{
554  		doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT, 0, isLargeFile ? SC_DOCUMENTOPTION_STYLES_NONE | SC_DOCUMENTOPTION_TEXT_LARGE : 0);
555  		ownDoc = true;
556  	}
557  	WCHAR fullpath[MAX_PATH] = { 0 };
558  	if (isWin32NamespacePrefixedFileName(filename))
559  	{
560  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
561  	}
562  	else
563  	{
564  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
565  		if (wcschr(fullpath, '~'))
566  		{
567  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
568  		}
569  	}
570  	bool isSnapshotMode = backupFileName != NULL && PathFileExists(backupFileName);
571  	if (isSnapshotMode && !PathFileExists(fullpath)) 
572  	{
573  		wcscpy_s(fullpath, MAX_PATH, filename); 
574  	}
575  	Utf8_16_Read UnicodeConvertor;	
576  	char* data = new char[blockSize + 8]; 
577  	LoadedFileFormat loadedFileFormat;
578  	loadedFileFormat._encoding = encoding;
579  	loadedFileFormat._eolFormat = EolType::unknown;
580  	loadedFileFormat._language = L_TEXT;
581  	bool res = loadFileData(doc, fileSize, backupFileName ? backupFileName : fullpath, data, &UnicodeConvertor, loadedFileFormat);
582  	delete[] data;
583  	if (res)
584  	{
585  		Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_REGULAR, fullpath, isLargeFile);
586  		BufferID id = newBuf;
587  		newBuf->_id = id;
588  		if (backupFileName != NULL)
589  		{
590  			newBuf->_backupFileName = backupFileName;
591  			if (!PathFileExists(fullpath))
592  				newBuf->_currentStatus = DOC_UNNAMED;
593  		}
594  		const FILETIME zeroTimeStamp = {};
595  		LONG res = CompareFileTime(&fileNameTimestamp, &zeroTimeStamp);
596  		if (res != 0) 
597  			newBuf->_timeStamp = fileNameTimestamp;
598  		_buffers.push_back(newBuf);
599  		++_nbBufs;
600  		Buffer* buf = _buffers.at(_nbBufs - 1);
601  		buf->setEncoding(-1);
602  		if (!newBuf->_isLargeFile && ((buf->getLangType() == L_TEXT) && (loadedFileFormat._language != L_TEXT)))
603  			buf->setLangType(loadedFileFormat._language);
604  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
605  		++_nextBufferID;
606  		return id;
607  	}
608  	else 
609  	{
610  		if (ownDoc)
611  			_pscratchTilla->execute(SCI_RELEASEDOCUMENT, 0, doc);	
612  		return BUFFER_INVALID;
613  	}
614  }
615  bool FileManager::reloadBuffer(BufferID id)
616  {
617  	Buffer* buf = getBufferByID(id);
618  	Document doc = buf->getDocument();
619  	Utf8_16_Read UnicodeConvertor;
620  	LoadedFileFormat loadedFileFormat;
621  	loadedFileFormat._encoding = buf->getEncoding();
622  	loadedFileFormat._eolFormat = EolType::unknown;
623  	loadedFileFormat._language = buf->getLangType();
624  	buf->setLoadedDirty(false);	
625  	FILE* fp = _wfopen(buf->getFullPathName(), TEXT("rb"));
626  	if (!fp)
627  		return false;
628  	_fseeki64(fp, 0, SEEK_END);
629  	int64_t fileSize = _ftelli64(fp);
630  	fclose(fp);
631  	char* data = new char[blockSize + 8]; 
632  	buf->_canNotify = false;	
633  	bool res = loadFileData(doc, fileSize, buf->getFullPathName(), data, &UnicodeConvertor, loadedFileFormat);
634  	buf->_canNotify = true;
635  	delete[] data;
636  	if (res)
637  	{
638  		buf->setUnsync(false);
639  		buf->setDirty(false); 
640  		buf->setSavePointDirty(false);
641  		setLoadedBufferEncodingAndEol(buf, UnicodeConvertor, loadedFileFormat._encoding, loadedFileFormat._eolFormat);
642  	}
643  	return res;
644  }
645  void FileManager::setLoadedBufferEncodingAndEol(Buffer* buf, const Utf8_16_Read& UnicodeConvertor, int encoding, EolType bkformat)
646  {
647  	if (encoding == -1)
648  	{
649  		NppParameters& nppParamInst = NppParameters::getInstance();
650  		const NewDocDefaultSettings & ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
651  		UniMode um = UnicodeConvertor.getEncoding();
652  		if (um == uni7Bit)
653  			um = (ndds._openAnsiAsUtf8) ? uniCookie : uni8Bit;
654  		buf->setUnicodeMode(um);
655  	}
656  	else
657  	{
658  		buf->setEncoding((encoding == SC_CP_UTF8)?-1:encoding);
659  		buf->setUnicodeMode(uniCookie);
660  	}
661  	if (bkformat != EolType::unknown)
662  		buf->setEolFormat(bkformat);
663  }
664  bool FileManager::reloadBufferDeferred(BufferID id)
665  {
666  	Buffer* buf = getBufferByID(id);
667  	buf->setDeferredReload();
668  	return true;
669  }
670  bool FileManager::deleteFile(BufferID id)
671  {
672  	Buffer* buf = getBufferByID(id);
673  	generic_string fileNamePath = buf->getFullPathName();
674  	fileNamePath.append(1, '\0');
675  	if (!PathFileExists(fileNamePath.c_str()))
676  		return false;
677  	SHFILEOPSTRUCT fileOpStruct = {};
678  	fileOpStruct.hwnd = NULL;
679  	fileOpStruct.pFrom = fileNamePath.c_str();
680  	fileOpStruct.pTo = NULL;
681  	fileOpStruct.wFunc = FO_DELETE;
682  	fileOpStruct.fFlags = FOF_ALLOWUNDO;
683  	fileOpStruct.fAnyOperationsAborted = false;
684  	fileOpStruct.hNameMappings         = NULL;
685  	fileOpStruct.lpszProgressTitle     = NULL;
686  	return SHFileOperation(&fileOpStruct) == 0;
687  }
688  bool FileManager::moveFile(BufferID id, const TCHAR * newFileName)
689  {
690  	Buffer* buf = getBufferByID(id);
691  	const TCHAR *fileNamePath = buf->getFullPathName();
692  	if (::MoveFileEx(fileNamePath, newFileName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH) == 0)
693  		return false;
694  	buf->setFileName(newFileName);
695  	return true;
696  }
697  std::mutex backup_mutex;
698  bool FileManager::backupCurrentBuffer()
699  {
700  	Buffer* buffer = _pNotepadPlus->getCurrentBuffer();
701  	if (buffer->isLargeFile())
702  		return false;
703  	std::lock_guard<std::mutex> lock(backup_mutex);
704  	bool result = false;
705  	bool hasModifForSession = false;
706  	if (buffer->isDirty())
707  	{
708  		if (buffer->isModified()) 
709  		{
710  			UniMode mode = buffer->getUnicodeMode();
711  			if (mode == uniCookie)
712  				mode = uni8Bit;	
713  			Utf8_16_Write UnicodeConvertor;
714  			UnicodeConvertor.setEncoding(mode);
715  			int encoding = buffer->getEncoding();
716  			generic_string backupFilePath = buffer->getBackupFileName();
717  			if (backupFilePath.empty())
718  			{
719  				backupFilePath = NppParameters::getInstance().getUserPath();
720  				backupFilePath += TEXT("\\backup\\");
721  				if (!PathFileExists(backupFilePath.c_str()))
722  				{
723  					::CreateDirectory(backupFilePath.c_str(), NULL);
724  				}
725  				backupFilePath += buffer->getFileName();
726  				const int temBufLen = 32;
727  				TCHAR tmpbuf[temBufLen];
728  				time_t ltime = time(0);
729  				struct tm* today = localtime(&ltime);
730  				if (!today)
731  					return false;
732  				wcsftime(tmpbuf, temBufLen, L"%Y-%m-%d_%H%M%S", today);
733  				backupFilePath += L"@";
734  				backupFilePath += tmpbuf;
735  				buffer->setBackupFileName(backupFilePath);
736  				hasModifForSession = true;
737  			}
738  			TCHAR fullpath[MAX_PATH];
739  			::GetFullPathName(backupFilePath.c_str(), MAX_PATH, fullpath, NULL);
740  			if (wcschr(fullpath, '~'))
741  			{
742  				::GetLongPathName(fullpath, fullpath, MAX_PATH);
743  			}
744  			DWORD dwFileAttribs = ::GetFileAttributes(fullpath);
745  			if (dwFileAttribs & FILE_ATTRIBUTE_READONLY) 
746  			{
747  				dwFileAttribs ^= FILE_ATTRIBUTE_READONLY;
748  				::SetFileAttributes(fullpath, dwFileAttribs);
749  			}
750  			if (UnicodeConvertor.openFile(fullpath))
751  			{
752  				size_t lengthDoc = _pNotepadPlus->_pEditView->getCurrentDocLen();
753  				char* buf = (char*)_pNotepadPlus->_pEditView->execute(SCI_GETCHARACTERPOINTER);	
754  				boolean isWrittenSuccessful = false;
755  				if (encoding == -1) 
756  				{
757  					isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
758  					if (lengthDoc == 0)
759  						isWrittenSuccessful = true;
760  				}
761  				else
762  				{
763  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
764  					size_t grabSize;
765  					for (size_t i = 0; i < lengthDoc; i += grabSize)
766  					{
767  						grabSize = lengthDoc - i;
768  						if (grabSize > blockSize)
769  							grabSize = blockSize;
770  						int newDataLen = 0;
771  						int incompleteMultibyteChar = 0;
772  						const char *newData = wmc.encode(SC_CP_UTF8, encoding, buf+i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
773  						grabSize -= incompleteMultibyteChar;
774  						isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
775  					}
776  					if (lengthDoc == 0)
777  						isWrittenSuccessful = true;
778  				}
779  				UnicodeConvertor.closeFile();
780  				if (isWrittenSuccessful) 
781  				{
782  					buffer->setModifiedStatus(false);
783  					result = true;	
784  				}
785  			}
786  		}
787  		else 
788  		{
789  			result = true;
790  		}
791  	}
792  	else 
793  	{
794  		generic_string backupFilePath = buffer->getBackupFileName();
795  		if (!backupFilePath.empty())
796  		{
797  			generic_string file2Delete = buffer->getBackupFileName();
798  			buffer->setBackupFileName(generic_string());
799  			result = (::DeleteFile(file2Delete.c_str()) != 0);
800  			hasModifForSession = true;
801  		}
802  		result = true; 
803  	}
804  	if (result && hasModifForSession)
805  	{
806  		_pNotepadPlus->saveCurrentSession();
807  	}
808  	return result;
809  }
810  bool FileManager::deleteBufferBackup(BufferID id)
811  {
812  	Buffer* buffer = getBufferByID(id);
813  	bool result = true;
814  	generic_string backupFilePath = buffer->getBackupFileName();
815  	if (!backupFilePath.empty())
816  	{
817  		buffer->setBackupFileName(generic_string());
818  		result = (::DeleteFile(backupFilePath.c_str()) != 0);
819  	}
820  	return result;
821  }
822  std::mutex save_mutex;
823  SavingStatus FileManager::saveBuffer(BufferID id, const TCHAR * filename, bool isCopy)
824  {
825  	std::lock_guard<std::mutex> lock(save_mutex);
826  	Buffer* buffer = getBufferByID(id);
827  	bool isHiddenOrSys = false;
828  	DWORD attrib = 0;
829  	WCHAR fullpath[MAX_PATH] = { 0 };
830  	if (isWin32NamespacePrefixedFileName(filename))
831  	{
832  		wcsncpy_s(fullpath, _countof(fullpath), filename, _TRUNCATE);
833  	}
834  	else
835  	{
836  		::GetFullPathName(filename, MAX_PATH, fullpath, NULL);
837  		if (wcschr(fullpath, '~'))
838  		{
839  			::GetLongPathName(fullpath, fullpath, MAX_PATH);
840  		}
841  	}
842  	if (PathFileExists(fullpath))
843  	{
844  		attrib = ::GetFileAttributes(fullpath);
845  		if (attrib != INVALID_FILE_ATTRIBUTES)
846  		{
847  			isHiddenOrSys = (attrib & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0;
848  			if (isHiddenOrSys)
849  				::SetFileAttributes(filename, attrib & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
850  		}
851  	}
852  	UniMode mode = buffer->getUnicodeMode();
853  	if (mode == uniCookie)
854  		mode = uni8Bit;	
855  	Utf8_16_Write UnicodeConvertor;
856  	UnicodeConvertor.setEncoding(mode);
857  	int encoding = buffer->getEncoding();
858  	if (UnicodeConvertor.openFile(fullpath))
859  	{
860  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);	
861  		size_t lengthDoc = _pscratchTilla->getCurrentDocLen();
862  		char* buf = (char*)_pscratchTilla->execute(SCI_GETCHARACTERPOINTER);	
863  		boolean isWrittenSuccessful = false;
864  		if (encoding == -1) 
865  		{
866  			isWrittenSuccessful = UnicodeConvertor.writeFile(buf, lengthDoc);
867  			if (lengthDoc == 0)
868  				isWrittenSuccessful = true;
869  		}
870  		else
871  		{
872  			WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
873  			if (lengthDoc == 0)
874  			{
875  				isWrittenSuccessful = UnicodeConvertor.writeFile(buf, 0);
876  			}
877  			else
878  			{
879  				size_t grabSize;
880  				for (size_t i = 0; i < lengthDoc; i += grabSize)
881  				{
882  					grabSize = lengthDoc - i;
883  					if (grabSize > blockSize)
884  						grabSize = blockSize;
885  					int newDataLen = 0;
886  					int incompleteMultibyteChar = 0;
887  					const char* newData = wmc.encode(SC_CP_UTF8, encoding, buf + i, static_cast<int>(grabSize), &newDataLen, &incompleteMultibyteChar);
888  					grabSize -= incompleteMultibyteChar;
889  					isWrittenSuccessful = UnicodeConvertor.writeFile(newData, newDataLen);
890  				}
891  			}
892  		}
893  		UnicodeConvertor.closeFile();
894  		if (!isWrittenSuccessful)
895  		{
896  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
897  			return SavingStatus::SaveWritingFailed;
898  		}
899  		if (isHiddenOrSys)
900  			::SetFileAttributes(fullpath, attrib);
901  		if (isCopy) 
902  		{
903  			_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
904  			return SavingStatus::SaveOK;	
905  		}
906  		buffer->setFileName(fullpath);
907  		if (!buffer->isLargeFile() && buffer->_lang == L_TEXT)
908  		{
909  			LangType detectedLang = detectLanguageFromTextBegining((unsigned char*)buf, lengthDoc);
910  			if (detectedLang != L_TEXT)
911  			{
912  				buffer->_lang = detectedLang;
913  				buffer->doNotify(BufferChangeFilename | BufferChangeTimestamp | BufferChangeLanguage);
914  			}
915  		}
916  		buffer->setDirty(false);
917  		buffer->setUnsync(false);
918  		buffer->setSavePointDirty(false);
919  		buffer->setStatus(DOC_REGULAR);
920  		buffer->checkFileState();
921  		_pscratchTilla->execute(SCI_SETSAVEPOINT);
922  		_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
923  		generic_string backupFilePath = buffer->getBackupFileName();
924  		if (!backupFilePath.empty())
925  		{
926  			buffer->setBackupFileName(generic_string());
927  			::DeleteFile(backupFilePath.c_str());
928  		}
929  		return SavingStatus::SaveOK;
930  	}
931  	else
932  	{
933  		return SavingStatus::SaveOpenFailed;
934  	}
935  }
936  size_t FileManager::nextUntitledNewNumber() const
937  {
938  	std::vector<size_t> usedNumbers;
939  	for (size_t i = 0; i < _buffers.size(); i++)
940  	{
941  		Buffer *buf = _buffers.at(i);
942  		if (buf->isUntitled())
943  		{
944  			bool isVisible = false;
945  			for (size_t k = 0; k < buf->_referees.size(); k++)
946  			{
947  				if (buf->_referees[k]->isVisible())
948  				{
949  					isVisible = true;
950  					break;
951  				}
952  			}
953  			if (isVisible)
954  			{
955  				if (buf->indexOfReference(_pNotepadPlus->_pEditView) > -1 || buf->indexOfReference(_pNotepadPlus->_pNonEditView) > -1)
956  				{
957  					generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
958  					TCHAR* numberStr = buf->_fileName + newTitle.length();
959  					int usedNumber = _wtoi(numberStr);
960  					usedNumbers.push_back(usedNumber);
961  				}
962  			}
963  		}
964  	}
965  	size_t newNumber = 1;
966  	bool numberAvailable = true;
967  	bool found = false;
968  	do
969  	{
970  		for (size_t j = 0; j < usedNumbers.size(); j++)
971  		{
972  			numberAvailable = true;
973  			found = false;
974  			if (usedNumbers[j] == newNumber)
975  			{
976  				numberAvailable = false;
977  				found = true;
978  				break;
979  			}
980  		}
981  		if (!numberAvailable)
982  			newNumber++;
983  		if (!found)
984  			break;
985  	} while (!numberAvailable);
986  	return newNumber;
987  }
988  BufferID FileManager::newEmptyDocument()
989  {
990  	generic_string newTitle = ((NppParameters::getInstance()).getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
991  	TCHAR nb[10];
992  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
993  	newTitle += nb;
994  	Document doc = (Document)_pscratchTilla->execute(SCI_CREATEDOCUMENT);	
995  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
996  	NppParameters& nppParamInst = NppParameters::getInstance();
997  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
998  	newBuf->_lang = ndds._lang;
999  	BufferID id = newBuf;
1000  	newBuf->_id = id;
1001  	_buffers.push_back(newBuf);
1002  	++_nbBufs;
1003  	++_nextBufferID;
1004  	return id;
1005  }
1006  BufferID FileManager::bufferFromDocument(Document doc, bool dontIncrease, bool dontRef)
1007  {
1008  	NppParameters& nppParamInst = NppParameters::getInstance();
1009  	generic_string newTitle = (nppParamInst.getNativeLangSpeaker())->getLocalizedStrFromID("tab-untitled-string", UNTITLED_STR);
1010  	TCHAR nb[10];
1011  	wsprintf(nb, TEXT("%d"), static_cast<int>(nextUntitledNewNumber()));
1012  	newTitle += nb;
1013  	if (!dontRef)
1014  		_pscratchTilla->execute(SCI_ADDREFDOCUMENT, 0, doc);	
1015  	Buffer* newBuf = new Buffer(this, _nextBufferID, doc, DOC_UNNAMED, newTitle.c_str(), false);
1016  	BufferID id = newBuf;
1017  	newBuf->_id = id;
1018  	const NewDocDefaultSettings& ndds = (nppParamInst.getNppGUI()).getNewDocDefaultSettings();
1019  	newBuf->_lang = ndds._lang;
1020  	_buffers.push_back(newBuf);
1021  	++_nbBufs;
1022  	if (!dontIncrease)
1023  		++_nextBufferID;
1024  	return id;
1025  }
1026  int FileManager::detectCodepage(char* buf, size_t len)
1027  {
1028  	int codepage = -1;
1029  	uchardet_t ud = uchardet_new();
1030  	uchardet_handle_data(ud, buf, len);
1031  	uchardet_data_end(ud);
1032  	const char* cs = uchardet_get_charset(ud);
1033  	if (stricmp(cs, "TIS-620") != 0) 
1034  		codepage = EncodingMapper::getInstance().getEncodingFromString(cs);
1035  	uchardet_delete(ud);
1036  	return codepage;
1037  }
1038  LangType FileManager::detectLanguageFromTextBegining(const unsigned char *data, size_t dataLen)
1039  {
1040  	struct FirstLineLanguages
1041  	{
1042  		std::string pattern;
1043  		LangType lang;
1044  	};
1045  	if (dataLen <= 3)
1046  		return L_TEXT;
1047  	size_t i = 0;
1048  	if ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) || 
1049  		(data[0] == 0xFE && data[1] == 0xFF && data[2] == 0x00) || 
1050  		(data[0] == 0xFF && data[1] == 0xFE && data[2] == 0x00))   
1051  		i += 3;
1052  	for (; i < dataLen; ++i)
1053  	{
1054  		if (data[i] != ' ' && data[i] != '\t' && data[i] != '\n' && data[i] != '\r')
1055  			break;
1056  	}
1057  	const size_t longestLength = 40; 
1058  	std::string buf2Test = std::string((const char *)data + i, longestLength);
1059  	auto cr = buf2Test.find("\r");
1060  	auto nl = buf2Test.find("\n");
1061  	auto crnl = std::min<size_t>(cr, nl);
1062  	if (crnl != std::string::npos && crnl < longestLength)
1063  		buf2Test = std::string((const char *)data + i, crnl);
1064  	std::string shebang = "#!";
1065  	size_t foundPos = buf2Test.find(shebang);
1066  	if (foundPos == 0)
1067  	{
1068  		const size_t NB_SHEBANG_LANGUAGES = 6;
1069  		FirstLineLanguages ShebangLangs[NB_SHEBANG_LANGUAGES] = {
1070  			{ "sh",		L_BASH },
1071  			{ "python", L_PYTHON },
1072  			{ "perl",	L_PERL },
1073  			{ "php",	L_PHP },
1074  			{ "ruby",	L_RUBY },
1075  			{ "node",	L_JAVASCRIPT }
1076  		};
1077  		for (i = 0; i < NB_SHEBANG_LANGUAGES; ++i)
1078  		{
1079  			if (buf2Test.find(ShebangLangs[i].pattern) != std::string::npos)
1080  			{
1081  				return ShebangLangs[i].lang;
1082  			}
1083  		}
1084  		return L_TEXT;
1085  	}
1086  	const size_t NB_FIRST_LINE_LANGUAGES = 5;
1087  	FirstLineLanguages languages[NB_FIRST_LINE_LANGUAGES] = {
1088  		{ "<?xml",			L_XML },
1089  		{ "<?php",			L_PHP },
1090  		{ "<html",			L_HTML },
1091  		{ "<!DOCTYPE html",	L_HTML },
1092  		{ "<?",				L_PHP } 
1093  	};
1094  	for (i = 0; i < NB_FIRST_LINE_LANGUAGES; ++i)
1095  	{
1096  		foundPos = buf2Test.find(languages[i].pattern);
1097  		if (foundPos == 0)
1098  		{
1099  			return languages[i].lang;
1100  		}
1101  	}
1102  	return L_TEXT;
1103  }
1104  bool FileManager::loadFileData(Document doc, int64_t fileSize, const TCHAR * filename, char* data, Utf8_16_Read * unicodeConvertor, LoadedFileFormat& fileFormat)
1105  {
1106  	FILE *fp = _wfopen(filename, TEXT("rb"));
1107  	if (!fp)
1108  		return false;
1109  	int64_t bufferSizeRequested = fileSize + std::min<int64_t>(1LL << 20, fileSize / 6);
1110  	NppParameters& nppParam = NppParameters::getInstance();
1111  	NativeLangSpeaker* pNativeSpeaker = nppParam.getNativeLangSpeaker();
1112  	if (bufferSizeRequested > INT_MAX)
1113  	{
1114  		if (nppParam.archType() == IMAGE_FILE_MACHINE_I386)
1115  		{
1116  			pNativeSpeaker->messageBox("FileTooBigToOpen",
1117  				_pNotepadPlus->_pEditView->getHSelf(),
1118  				TEXT("File is too big to be opened by Notepad++"),
1119  				TEXT("File size problem"),
1120  				MB_OK | MB_APPLMODAL);
1121  			fclose(fp);
1122  			return false;
1123  		}
1124  		else 
1125  		{
1126  			int res = pNativeSpeaker->messageBox("WantToOpenHugeFile",
1127  				_pNotepadPlus->_pEditView->getHSelf(),
1128  				TEXT("Opening a huge file of 2GB+ could take several minutes.\nDo you want to open it?"),
1129  				TEXT("Opening huge file warning"),
1130  				MB_YESNO | MB_APPLMODAL);
1131  			if (res == IDYES)
1132  			{
1133  			}
1134  			else
1135  			{
1136  				fclose(fp);
1137  				return false;
1138  			}
1139  		}
1140  	}
1141  	_pscratchTilla->execute(SCI_SETSTATUS, SC_STATUS_OK); 
1142  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, doc);
1143  	bool ro = _pscratchTilla->execute(SCI_GETREADONLY) != 0;
1144  	if (ro)
1145  	{
1146  		_pscratchTilla->execute(SCI_SETREADONLY, false);
1147  	}
1148  	_pscratchTilla->execute(SCI_CLEARALL);
1149  	if (fileFormat._language < L_EXTERNAL)
1150  	{
1151  		const char* lexerNameID = ScintillaEditView::_langNameInfoArray[fileFormat._language]._lexerID;
1152  		_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(CreateLexer(lexerNameID)));
1153  	}
1154  	else
1155  	{
1156  		int id = fileFormat._language - L_EXTERNAL;
1157  		ExternalLangContainer& externalLexer = nppParam.getELCFromIndex(id);
1158  		const char* lexerName = externalLexer._name.c_str();
1159  		if (externalLexer.fnCL)
1160  			_pscratchTilla->execute(SCI_SETILEXER, 0, reinterpret_cast<LPARAM>(externalLexer.fnCL(lexerName)));
1161  	}
1162  	if (fileFormat._encoding != -1)
1163  		_pscratchTilla->execute(SCI_SETCODEPAGE, SC_CP_UTF8);
1164  	bool success = true;
1165  	EolType format = EolType::unknown;
1166  	int sciStatus = SC_STATUS_OK;
1167  	TCHAR szException[64] = { '\0' };
1168  	__try
1169  	{
1170  		_pscratchTilla->execute(SCI_ALLOCATE, WPARAM(bufferSizeRequested));
1171  		sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1172  		if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1173  			throw std::runtime_error("Scintilla error");
1174  		size_t lenFile = 0;
1175  		size_t lenConvert = 0;	
1176  		bool isFirstTime = true;
1177  		int incompleteMultibyteChar = 0;
1178  		do
1179  		{
1180  			lenFile = fread(data + incompleteMultibyteChar, 1, blockSize - incompleteMultibyteChar, fp) + incompleteMultibyteChar;
1181  			if (ferror(fp) != 0)
1182  			{
1183  				success = false;
1184  				break;
1185  			}
1186  			if (lenFile == 0) break;
1187              if (isFirstTime)
1188              {
1189  				NppGUI& nppGui = NppParameters::getInstance().getNppGUI();
1190                  if (Utf8_16_Read::determineEncoding((unsigned char *)data, lenFile) != uni8Bit)
1191                  {
1192  					fileFormat._encoding = -1;
1193  				}
1194  				else if (fileFormat._encoding == -1)
1195  				{
1196  					if (nppGui._detectEncoding)
1197  						fileFormat._encoding = detectCodepage(data, lenFile);
1198                  }
1199  				bool isLargeFile = fileSize >= nppGui._largeFileRestriction._largeFileSizeDefInByte;
1200  				if (!isLargeFile && fileFormat._language == L_TEXT)
1201  				{
1202  					fileFormat._language = detectLanguageFromTextBegining((unsigned char *)data, lenFile);
1203  				}
1204                  isFirstTime = false;
1205              }
1206  			if (fileFormat._encoding != -1)
1207  			{
1208  				if (fileFormat._encoding == SC_CP_UTF8)
1209  				{
1210  					_pscratchTilla->execute(SCI_APPENDTEXT, lenFile, reinterpret_cast<LPARAM>(data));
1211  				}
1212  				else
1213  				{
1214  					WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
1215  					int newDataLen = 0;
1216  					const char *newData = wmc.encode(fileFormat._encoding, SC_CP_UTF8, data, static_cast<int32_t>(lenFile), &newDataLen, &incompleteMultibyteChar);
1217  					_pscratchTilla->execute(SCI_APPENDTEXT, newDataLen, reinterpret_cast<LPARAM>(newData));
1218  				}
1219  				if (format == EolType::unknown)
1220  					format = getEOLFormatForm(data, lenFile, EolType::unknown);
1221  			}
1222  			else
1223  			{
1224  				lenConvert = unicodeConvertor->convert(data, lenFile);
1225  				_pscratchTilla->execute(SCI_APPENDTEXT, lenConvert, reinterpret_cast<LPARAM>(unicodeConvertor->getNewBuf()));
1226  				if (format == EolType::unknown)
1227  					format = getEOLFormatForm(unicodeConvertor->getNewBuf(), unicodeConvertor->getNewSize(), EolType::unknown);
1228  			}
1229  			sciStatus = static_cast<int>(_pscratchTilla->execute(SCI_GETSTATUS));
1230  			if ((sciStatus > SC_STATUS_OK) && (sciStatus < SC_STATUS_WARN_START))
1231  				throw std::runtime_error("Scintilla error");
1232  			if (incompleteMultibyteChar != 0)
1233  			{
1234  				memcpy(data, data + blockSize - incompleteMultibyteChar, incompleteMultibyteChar);
1235  			}
1236  		}
1237  		while (lenFile > 0);
1238  	}
1239  	__except(EXCEPTION_EXECUTE_HANDLER)
1240  	{
1241  		switch (sciStatus)
1242  		{
1243  			case SC_STATUS_OK:
1244  #if defined(__GNUC__)
1245  				_stprintf_s(szException, _countof(szException), TEXT("unknown exception"));
1246  #else
1247  				_stprintf_s(szException, _countof(szException), TEXT("0x%X (SEH)"), ::GetExceptionCode());
1248  #endif
1249  				break;
1250  			case SC_STATUS_BADALLOC:
1251  			{
1252  				pNativeSpeaker->messageBox("FileTooBigToOpen",
1253  					_pNotepadPlus->_pEditView->getHSelf(),
1254  					TEXT("File is too big to be opened by Notepad++"),
1255  					TEXT("Exception: File size problem"),
1256  					MB_OK | MB_APPLMODAL);
1257  			}
1258  			[[fallthrough]];
1259  			case SC_STATUS_FAILURE:
1260  			default:
1261  				_stprintf_s(szException, _countof(szException), TEXT("%d (Scintilla)"), sciStatus);
1262  				break;
1263  		}
1264  		if (sciStatus != SC_STATUS_BADALLOC)
1265  		{
1266  			pNativeSpeaker->messageBox("FileLoadingException",
1267  				_pNotepadPlus->_pEditView->getHSelf(),
1268  				TEXT("An error occurred while loading the file!"),
1269  				TEXT("Exception code: $STR_REPLACE$"),
1270  				MB_OK | MB_APPLMODAL,
1271  				0,
1272  				szException);
1273  		}
1274  		success = false;
1275  	}
1276  	fclose(fp);
1277  	if (format == EolType::unknown)
1278  	{
1279  		const NewDocDefaultSettings & ndds = (nppParam.getNppGUI()).getNewDocDefaultSettings(); 
1280  		fileFormat._eolFormat = ndds._format;
1281  		if ((fileSize == 0) && (fileFormat._encoding < 1))
1282  		{
1283  			if (ndds._unicodeMode == uniCookie && ndds._openAnsiAsUtf8)
1284  				fileFormat._encoding = SC_CP_UTF8;
1285  		}
1286  	}
1287  	else
1288  	{
1289  		fileFormat._eolFormat = format;
1290  	}
1291  	_pscratchTilla->execute(SCI_EMPTYUNDOBUFFER);
1292  	_pscratchTilla->execute(SCI_SETSAVEPOINT);
1293  	if (ro)
1294  		_pscratchTilla->execute(SCI_SETREADONLY, true);
1295  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, _scratchDocDefault);
1296  	return success;
1297  }
1298  BufferID FileManager::getBufferFromName(const TCHAR* name)
1299  {
1300  	for (auto buf : _buffers)
1301  	{
1302  		if (OrdinalIgnoreCaseCompareStrings(name, buf->getFullPathName()) == 0)
1303  		{
1304  			if (buf->_referees[0]->isVisible())
1305  			{
1306  				return buf->getID();
1307  			}
1308  		}
1309  	}
1310  	return BUFFER_INVALID;
1311  }
1312  BufferID FileManager::getBufferFromDocument(Document doc)
1313  {
1314  	for (size_t i = 0; i < _nbBufs; ++i)
1315  	{
1316  		if (_buffers[i]->_doc == doc)
1317  			return _buffers[i]->_id;
1318  	}
1319  	return BUFFER_INVALID;
1320  }
1321  bool FileManager::createEmptyFile(const TCHAR * path)
1322  {
1323  	Win32_IO_File file(path);
1324  	return file.isOpened();
1325  }
1326  int FileManager::getFileNameFromBuffer(BufferID id, TCHAR * fn2copy)
1327  {
1328  	if (getBufferIndexByID(id) == -1)
1329  		return -1;
1330  	Buffer* buf = getBufferByID(id);
1331  	if (fn2copy)
1332  		lstrcpy(fn2copy, buf->getFullPathName());
1333  	return lstrlen(buf->getFullPathName());
1334  }
1335  size_t FileManager::docLength(Buffer* buffer) const
1336  {
1337  	Document curDoc = _pscratchTilla->execute(SCI_GETDOCPOINTER);
1338  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, buffer->_doc);
1339  	size_t docLen = _pscratchTilla->getCurrentDocLen();
1340  	_pscratchTilla->execute(SCI_SETDOCPOINTER, 0, curDoc);
1341  	return docLen;
1342  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btaserver.cpp</h3>
            <pre><code>1  #include "btaserver.h"
2  int TBTAServer::MnSeverity = 3;
3  int TBTAServer::ListItemsPerPage = 20;
4  int TBTAServer::DetailItemsPerPage = 10;
5  int TBTAServer::ListEventsPerPage = 10;
6  int64 TBTAServer::RootCouseTimeWnd = int64(24*3600) * int64(1000);  
7  int TBTAServer::RootCouseEventWnd = 300;
8  int64 TBTAServer::BoardTimeWnd = int64(4*3600) * int64(1000);  
9  int TBTAServer::BoardEventWnd = 5000;
10  int TBTAServer::MnBeforeCount = 5;
11  double TBTAServer::MxChiProb = 0.05;
12  double TBTAServer::MnChiVal = 0.01;
13  double TBTAServer::MnCorrProb = 0.001;
14  int TBTAServer::MnIpNumsPerPlot = 20;
15  int TBTAServer::GetTotalFq(const TIntPrV& IdFqV) {
16      int TotalFq = 0;
17      for (int IdFqN = 0; IdFqN < IdFqV.Len(); IdFqN++) {
18          TotalFq += IdFqV[IdFqN].Val2; }
19      return TotalFq;
20  }
21  TStr TBTAServer::TruncStr(const TStr& FullStr, const int& MxLen) {
22      if (FullStr.Len() > MxLen) {
23          return FullStr.GetSubStr(0, MxLen-1) + "...";
24      } else { return FullStr; }
25  }
26  TTm TBTAServer::GetBreakDate(const int& Days) const { 
27      TTm BreakDate = BtaEventBs->GetLastTime();
28      BreakDate.DelDays(Days);
29      return BreakDate;
30  }
31  void TBTAServer::GetIpNumEventCount(const int& IpNumId, const TTm& StartDate, 
32          const TTm& BreakDate, const TTm& EndDate, double& AvgCount, int& LastCount) const {
33      int OldCount = 0; LastCount = 0;
34      const TIntV& EventV = BtaCorrBs->GetIpNumEventV(IpNumId);
35      for (int EventN = 0; EventN < EventV.Len(); EventN++) {
36          TTm EventDate = BtaEventBs->GetEvent(EventV[EventN]).GetFirstTm();
37          if (EventDate < StartDate || EventDate > EndDate) { continue; }
38          if (EventDate < BreakDate) { OldCount++; }
39          else { LastCount++; }
40      }
41      const double NormFactor = TBtaLongProj::GetNormFact(StartDate, BreakDate, EndDate);
42      AvgCount = NormFactor * double(OldCount);
43  }
44  void TBTAServer::MakeEventsPage(const TIntV& EventV, const TStr& SortTypeStr,
45          const int& PageNum, TChA& HtmlChA) {
46      HtmlChA += "<h1>Alarms</h1>\n";                   
47      HtmlChA += TStr::Fmt("<p>Number of alarms: <b>%d</b> (severity > 2)<br>\n", EventV.Len());
48      TStr LatestAlarm = BtaEventBs->GetEvent(EventV.Last()).GetFirstTm().GetWebLogDateTimeStr();
49      HtmlChA += "Time of the latest alarm: <b>" + LatestAlarm + "</b><br>\n";
50      TStr OldestAlarm = BtaEventBs->GetEvent(EventV[0]).GetFirstTm().GetWebLogDateTimeStr();
51      HtmlChA += "Time of the oldest alarm: <b>" + OldestAlarm + "</b></p>\n";
52      TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
53      PlotEventV("", EventV, PlotFNm);
54      PlotFNm.ChangeChAll('/', '-');
55      HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
56      HtmlChA += "<h2>List of recent alarms</h2>\n";
57      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/events?page=%d&sort=%s\">Previous</a>\n", PageNum-1, SortTypeStr.CStr()); }
58      HtmlChA += TStr::Fmt("<a href=\"/events?page=%d&sort=%s\">Next</a>\n", PageNum+1, SortTypeStr.CStr());
59      MakeEventList(EventV, true, PageNum, HtmlChA);
60      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/events?page=%d&sort=%s\">Previous</a>\n", PageNum-1, SortTypeStr.CStr()); }
61      HtmlChA += TStr::Fmt("<a href=\"/events?page=%d&sort=%s\">Next</a>\n", PageNum+1, SortTypeStr.CStr());
62  }
63  void TBTAServer::MakeEventPage(const int& EventId, TChA& HtmlChA) {
64      if (EventId < 0 || EventId >= BtaEventBs->GetEvents()) { 
65          HtmlChA += "<p>Wrong event Id!</p>"; return; }
66      HtmlChA += "<h1>Alarm statistics</h1>\n";       
67      EventStat(EventId, HtmlChA);
68      HtmlChA += "<p><a href=\"/event_full?id=" + 
69          TInt::GetStr(EventId) + "\">Show all fields</a></p>";
70      HtmlChA += "<h2>Pattern of related events</h2>\n";       
71      EventRootCause(EventId, HtmlChA);
72      HtmlChA += "<h2>Devices predicted to fail</h2>\n";
73      EventPredIpNums(EventId, HtmlChA);
74  }
75  void TBTAServer::MakeEventFullPage(const int& EventId, TChA& HtmlChA) {
76      HtmlChA += "<h1>Alarm database fields</h1>\n";       
77      HtmlChA += "<p><a href=\"/event?id=" + 
78          TInt::GetStr(EventId) + "\">Back to alarm statistics</a></p>";
79      EventFullStat(EventId, HtmlChA);
80  }
81  void TBTAServer::MakeIpNumPage(const int& IpNumId, TChA& HtmlChA) {
82      HtmlChA += "<h1>Device statistics</h1>\n";       
83      if (BtaCorrBs->IsIpNumId(IpNumId)) { 
84          TStr IpNumNm = BtaDevDefBs->GetIpNumNm(IpNumId);
85          HtmlChA += TStr::Fmt("<p><b>Device IP:</b> %s<br>\n", IpNumNm.CStr());
86          HtmlChA += TStr::Fmt("<b>Device project:</b> %s<br>\n", GetProjLink(IpNumId).CStr());
87          HtmlChA += TStr::Fmt("<b>Number of alarms:</b> %d</p>\n", BtaCorrBs->GetIpNumIdEvents(IpNumId));
88          HtmlChA += "<h2>Recent alarms</h2>\n";       
89          HtmlChA += TStr::Fmt("<p><a href=\"/d_events?id=%d\">Show all alarms</a></p>\n", IpNumId);
90          TIntV EventV = BtaCorrBs->GetIpNumEventV(IpNumId);
91          TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
92          PlotEventV(BtaDevDefBs->GetIpNumNm(IpNumId), EventV, PlotFNm);
93          PlotFNm.ChangeChAll('/', '-');
94          HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
95          MakeEventList(EventV, false, 0, HtmlChA);
96          HtmlChA += "<h2>Correlated devices</h2>\n";       
97          IpNumDevCorrStat(IpNumId, HtmlChA);
98      } else {
99          HtmlChA += "<p><b>Device not in the database!</b></p>";                    
100      }   
101  }
102  void TBTAServer::MakeProjectPage(const int& ProjId, TChA& HtmlChA) {
103      HtmlChA += "<h1>Project statistics</h1>\n";
104      ShortProjStat(ProjId, HtmlChA);
105      HtmlChA += "<h2>Recent alarms</h2>\n";
106      HtmlChA += TStr::Fmt("<p><a href=\"/p_events?id=%d\">Show all alarms</a></p>\n", ProjId);
107      TIntV EventV = BtaCorrBs->GetProjEventV(ProjId);
108      TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
109      PlotEventV(BtaDevDefBs->GetProjNm(ProjId), EventV, PlotFNm);
110      PlotFNm.ChangeChAll('/', '-');
111      HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
112      MakeEventList(EventV, false, 0, HtmlChA);
113      HtmlChA += "<h2>Devices predicted to fail</h2>\n";
114      EventShortPredIpNums(EventV.Last(), HtmlChA);
115  }
116  void TBTAServer::MakeIpNumEventsPage(const int& IpNumId, 
117          const TIntV& EventV, const int& PageNum, TChA& HtmlChA) {
118      HtmlChA += "<h1>Device's alarms</h1>\n";                   
119      ShortIpNumStat(IpNumId, HtmlChA);
120      HtmlChA += "<h2>List of alarms</h2>\n";                   
121      TStr LatestAlarm = BtaEventBs->GetEvent(EventV.Last()).GetFirstTm().GetWebLogDateTimeStr();
122      HtmlChA += "Time of the latest alarm: <b>" + LatestAlarm + "</b><br>\n";
123      TStr OldestAlarm = BtaEventBs->GetEvent(EventV[0]).GetFirstTm().GetWebLogDateTimeStr();
124      HtmlChA += "Time of the oldest alarm: <b>" + OldestAlarm + "</b></p>\n";
125      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/d_events?id=%d&page=%d\">Previous</a>\n", IpNumId, PageNum-1); }
126      HtmlChA += TStr::Fmt("<a href=\"/d_events?id=%d&page=%d\">Next</a>\n", IpNumId, PageNum+1);
127      MakeEventList(EventV, false, PageNum, HtmlChA);
128      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/d_events?id=%d&page=%d\">Previous</a>\n", IpNumId, PageNum-1); }
129      HtmlChA += TStr::Fmt("<a href=\"/d_events?id=%d&page=%d\">Next</a>\n", IpNumId, PageNum+1);
130  }
131  void TBTAServer::MakeProjEventsPage(const int& ProjId, const TIntV& EventV,
132          const int& PageNum, TChA& HtmlChA) {
133      HtmlChA += "<h1>Project's alarms</h1>\n";                   
134      ShortProjStat(ProjId, HtmlChA);
135      HtmlChA += "<h2>List of alarms</h2>\n";                   
136      TStr LatestAlarm = BtaEventBs->GetEvent(EventV.Last()).GetFirstTm().GetWebLogDateTimeStr();
137      HtmlChA += "Time of the latest alarm: <b>" + LatestAlarm + "</b><br>\n";
138      TStr OldestAlarm = BtaEventBs->GetEvent(EventV[0]).GetFirstTm().GetWebLogDateTimeStr();
139      HtmlChA += "Time of the oldest alarm: <b>" + OldestAlarm + "</b></p>\n";
140      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/p_events?id=%d&page=%d\">Previous</a>\n", ProjId, PageNum-1); }
141      HtmlChA += TStr::Fmt("<a href=\"/p_events?id=%d&page=%d\">Next</a>\n", ProjId, PageNum+1);
142      MakeEventList(EventV, false, PageNum, HtmlChA);
143      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/p_events?id=%d&page=%d\">Previous</a>\n", ProjId, PageNum-1); }
144      HtmlChA += TStr::Fmt("<a href=\"/p_events?id=%d&page=%d\">Next</a>\n", ProjId, PageNum+1);
145  }
146  void TBTAServer::MakeIpNumCorrEventPage(const int& IpNumId, 
147          const int& CorrIpNumId, const int& PageNum, TChA& HtmlChA) {
148      HtmlChA += "<h1>Alarms behind device-device correlation</h1>\n";
149      HtmlChA += "<h2>First device</h2>\n";
150      ShortIpNumStat(IpNumId, HtmlChA);
151      HtmlChA += "<h2>Second device</h2>\n";
152      ShortIpNumStat(CorrIpNumId, HtmlChA);
153      HtmlChA += "<h2>List of correlating alarms</h2>\n";
154      const TIntV& EventV = BtaCorrBs->GetIpNumEventV(IpNumId);
155      const TIntV& CorrEventV = BtaCorrBs->GetIpNumEventV(CorrIpNumId);
156      TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
157      PlotEventV(BtaDevDefBs->GetIpNumNm(IpNumId), EventV, 
158          BtaDevDefBs->GetIpNumNm(CorrIpNumId), CorrEventV, PlotFNm);
159      PlotFNm.ChangeChAll('/', '-');
160      HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
161      if (BtaCorrBs->IsIpNumIdPrCorr(IpNumId, CorrIpNumId)) {
162          const TIntPrV& EventPrV = BtaCorrBs->GetIpNumCorrIpNumPrEventV(IpNumId, CorrIpNumId);
163          HtmlChA += TStr::Fmt("<p><b>Number of correlated alarm pairs:</b>%d</p>\n", EventPrV.Len());
164          if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/dd_events?page=%d&id=%d&corrid=%d\">Previous</a>\n", PageNum-1, IpNumId, CorrIpNumId); }
165          HtmlChA += TStr::Fmt("<a href=\"/dd_events?page=%d&id=%d&corrid=%d\">Next</a>\n", PageNum+1, IpNumId, CorrIpNumId);
166          MakeEventPrList(EventPrV, PageNum, HtmlChA);
167          if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/dd_events?page=%d&id=%d&corrid=%d\">Previous</a>\n", PageNum-1, IpNumId, CorrIpNumId); }
168          HtmlChA += TStr::Fmt("<a href=\"/dd_events?page=%d&id=%d&corrid=%d\">Next</a>\n", PageNum+1, IpNumId, CorrIpNumId);
169      }
170  }
171  void TBTAServer::MakeLongPage(const TIntV& SortProjIdV, 
172          const int& PageNum, const TStr& PeriodStr, TChA& HtmlChA) {
173      HtmlChA += "<h1>Projects with change trend</h1>\n";                   
174      if (PeriodStr == "week") { HtmlChA += "<p><b>[last week vs. history]</b>, "; } 
175      else { HtmlChA += "<p><a href=\"/long?period=week\">[last week vs. history]</a>, "; }
176      if (PeriodStr == "month") { HtmlChA += "<b>[last month vs. history]</b></p>"; }
177      else {HtmlChA += "<a href=\"/long?period=month\">[last month vs. history]</a></p>"; }
178      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/long?page=%d&period=%s\">Previous</a>\n", PageNum-1, PeriodStr.CStr()); }
179      HtmlChA += TStr::Fmt("<a href=\"/long?page=%d&period=%s\">Next</a>\n", PageNum+1, PeriodStr.CStr());
180      MakeLongProjList(SortProjIdV, PageNum, PeriodStr, HtmlChA);
181      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/long?page=%d&period=%s\">Previous</a>\n", PageNum-1, PeriodStr.CStr()); }
182      HtmlChA += TStr::Fmt("<a href=\"/long?page=%d&period=%s\">Next</a>\n", PageNum+1, PeriodStr.CStr());    
183  }
184  void TBTAServer::MakeProjLongPage(const int& ProjId,
185          const int& PageNum, const TStr& PeriodStr, TChA& HtmlChA) {
186      HtmlChA += "<h1>Devices with change trends</h1>\n";                   
187      ShortProjStat(ProjId, HtmlChA, true);
188      HtmlChA += "<h2>List of device trends</h2>\n";                   
189      if (PeriodStr == "week") { HtmlChA += "<p><b>[last week vs. history]</b>, "; } 
190      else { HtmlChA += TStr::Fmt("<p><a href=\"/p_long?id=%d&period=week\">[last week vs. history]</a>, ", ProjId); }
191      if (PeriodStr == "month") { HtmlChA += "<b>[last month vs. history]</b></p>"; }
192      else {HtmlChA += TStr::Fmt("<a href=\"/p_long?id=%d&period=month\">[last month vs. history]</a></p>", ProjId); }
193      TStr PlotFNm = TFile::GetUniqueFNm("IpNum.plt");
194      TTm StartDate = BtaEventBs->GetFirstTime();
195      TTm BreakDate = GetBreakDate(PeriodStr == "week" ? 7 : 30);
196      TTm EndDate = BtaEventBs->GetLastTime();
197      PlotLongIpNum(BtaDevDefBs->GetProjNm(ProjId), PlotFNm, ProjId, 
198          StartDate, BreakDate, EndDate, PeriodStr, MnIpNumsPerPlot, true);
199      HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
200      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/p_long?id=%d&page=%d&period=%s\">Previous</a>\n", ProjId, PageNum-1, PeriodStr.CStr()); }
201      HtmlChA += TStr::Fmt("<a href=\"/p_long?id=%d&page=%d&period=%s\">Next</a>\n", ProjId, PageNum+1, PeriodStr.CStr());
202      MakeLongIpNumList(ProjId, PageNum, PeriodStr, HtmlChA);
203      if (PageNum > 0) { HtmlChA += TStr::Fmt("<a href=\"/long?id=%d&page=%d&period=%s\">Previous</a>\n", ProjId, PageNum-1, PeriodStr.CStr()); }
204      HtmlChA += TStr::Fmt("<a href=\"/p_long?id=%d&page=%d&period=%s\">Next</a>\n", ProjId, PageNum+1, PeriodStr.CStr());    
205  }
206  void TBTAServer::MakeShortEventPage(const int& EventId, TChA& HtmlChA) {
207  	EventShortStat(EventId, HtmlChA);
208      HtmlChA += "<hr>";
209      HtmlChA += "<b>Related Traps:</b><br>";
210      EventShortRootCause(EventId, HtmlChA);
211  }
212  void TBTAServer::MakeShortPredIpNumsPage(const int& EventId, TChA& HtmlChA) {
213  	EventShortStat(EventId, HtmlChA);
214      HtmlChA += "<hr>";
215      HtmlChA += "<b>Devices predicted to fail:</b><br>";
216      EventShortPredIpNums(EventId, HtmlChA);
217  }
218  void TBTAServer::MakeShortIpNumPage(const int& EventId, TChA& HtmlChA) {
219      const int IpNumId = BtaEventBs->GetEvent(EventId).GetIpNumId();
220      const TIntV& IpNumEventV = BtaCorrBs->GetIpNumEventV(IpNumId);
221  	EventShortStat(EventId, HtmlChA);
222      HtmlChA += "<hr>";
223      HtmlChA += "<b>Device event trend</b><br>";
224      TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
225      PlotEventV("", IpNumEventV, PlotFNm, 500, 250);
226      PlotFNm.ChangeChAll('/', '-');
227      HtmlChA += "<img src=\"" + PlotFNm + ".png\"><br>";
228      HtmlChA += "<hr>";
229      HtmlChA += "<b>Recent events</b><br>";
230      MakeShortEventList(IpNumEventV, HtmlChA);
231  }
232  void TBTAServer::MakeBoardPage(const int& ProjCount, const int& RefreshTmSec, TChA& HtmlChA) {
233      HtmlChA += "<html><head>\n";
234      HtmlChA += "<title>Prediction Board</title>\n";
235      HtmlChA += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";
236      HtmlChA += TStr::Fmt("<meta http-equiv=\"REFRESH\" content=\"%d;url=board?count=%d&refresh=%d\"></HEAD>", 
237          RefreshTmSec, ProjCount + 1, RefreshTmSec);
238      HtmlChA += "<link href=\"board.css\" type=\"text/css\" rel=\"stylesheet\">\n";
239      HtmlChA += "</head><body>\n";
240      TIntKdV AllProjIdFqV;
241      BtaEventBs->GetMostActiveProjs(BoardTimeWnd, 
242          BoardEventWnd, MnSeverity, AllProjIdFqV);
243      TFltIntKdV ScoreProjIdV; THash<TInt, TFltIntPrV> ProbIpNumIdVH;
244      const int MxPredIpNums = 2; const int MxProjs = 6;
245      for (int ProjIdN = 0; ProjIdN < AllProjIdFqV.Len(); ProjIdN++) {
246          const int ProjId = AllProjIdFqV[ProjIdN].Key;
247          const int LastEventN = BtaCorrBs->GetProjEventV(ProjId).Last();
248          TIntFltH IpNumIdProbH;
249          BtaCorrBs->GetNextIpNumIdProb(LastEventN, ProjId, 
250              BtaEventBs, 100, 600, IpNumIdProbH);
251          if (IpNumIdProbH.Empty()) { continue;}
252          TFltIntPrV ProbIpNumIdV; 
253          IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV); 
254          ProbIpNumIdV.Sort(false);        
255          if (ProbIpNumIdV.Len() > MxPredIpNums) { 
256              ProbIpNumIdV.Trunc(MxPredIpNums); }
257          ScoreProjIdV.Add(TFltIntKd(ProbIpNumIdV[0].Val1, ProjId));
258          ProbIpNumIdVH.AddDat(ProjId, ProbIpNumIdV);
259          if (ScoreProjIdV.Len() >= 2*MxProjs) { break; }
260      } 
261      ScoreProjIdV.Sort(false);
262      if (ScoreProjIdV.Len() > MxProjs) { ScoreProjIdV.Trunc(MxProjs); }
263      if (ScoreProjIdV.Len() > 0) {
264          const int SelProjIdN = ProjCount % ScoreProjIdV.Len();
265  	    HtmlChA += "<div class=\"window\">\n";
266    	    HtmlChA += "<div class=\"project_list\">\n";
267          for (int ProjIdN = 0; ProjIdN < ScoreProjIdV.Len(); ProjIdN++) {
268              const int ProjId = ScoreProjIdV[ProjIdN].Dat;
269              const TFltIntPrV& ProbIpNumIdV = ProbIpNumIdVH.GetDat(ProjId);
270              if (ProjIdN == SelProjIdN) { 
271      	        HtmlChA += "<div class=\"project selected\">\n";
272              } else {
273      	        HtmlChA += "<div class=\"project\">\n";
274              }
275              TStr ProjNm = BtaDevDefBs->GetProjNm(ProjId);
276  	        HtmlChA += "<div class=\"project_title\">" + ProjNm + "</div>\n";
277              for (int IpNumN = 0; IpNumN < ProbIpNumIdV.Len(); IpNumN++) {
278                  const int IpNumId = ProbIpNumIdV[IpNumN].Val2;
279                  TStr IpNumNm = BtaDevDefBs->GetIpNumNm(IpNumId);
280  	            HtmlChA += "<div class=\"project_device\">" + IpNumNm + "</div>\n";
281              }
282  	        HtmlChA += "</div>\n";
283          }
284          HtmlChA += "</div>\n";
285          HtmlChA += "<div class=\"project_details\">\n";
286          const int SelProjId = ScoreProjIdV[SelProjIdN].Dat;
287          TStr SelProjNm = BtaDevDefBs->GetProjNm(SelProjId);
288          HtmlChA += "<div class=\"project_detail_title\">" + SelProjNm + "</div>\n";
289          HtmlChA += "<div class=\"project_detail_hist\">\n";
290          const TIntV& ProjEventV = BtaCorrBs->GetProjEventV(SelProjId);
291          TStr PlotFNm = TFile::GetUniqueFNm("img/EventPlot.plt");
292          PlotEventV("", ProjEventV, PlotFNm, 680, 200); PlotFNm.ChangeChAll('/', '-');
293          HtmlChA += "<p><img src=\"" + PlotFNm + ".png\"></p>";
294          HtmlChA += "</div>\n";
295          HtmlChA += "<div class=\"project_detail_h2\">Last trap:</div>\n";
296          HtmlChA += "<div class=\"project_detail_event_list\">\n";
297          {
298              const int LastEventN = ProjEventV.Last();
299              const TBtaEvent& LastEvent = BtaEventBs->GetEvent(LastEventN);
300              TStr IpNumNm = BtaDevDefBs->GetIpNumNm(LastEvent.GetIpNumId());       
301              TBtaEventDat LastEventDat; 
302              BtaEventBs->GetEventDat(LastEvent.GetBlobPt(), LastEventDat);
303              HtmlChA += "<div class=\"project_detail_event\">\n";
304              HtmlChA += "<b>Device ID:</b> " + IpNumNm + "<br>\n";
305              HtmlChA += "<b>First Time:</b> " + LastEventDat.GetFirstTm() + "<br>\n";
306              HtmlChA += "<b>Last Time:</b> " + LastEventDat.GetLastTm() + "<br>\n";
307              HtmlChA += "<b>Severity:</b> " + LastEventDat.GetSeverity() + "<br>\n";
308              HtmlChA += "<b>Summary:</b> " + LastEventDat.GetSummary() + "\n";
309              HtmlChA += "</div>\n";
310          }
311          HtmlChA += "</div>\n";
312          HtmlChA += "<div class=\"project_detail_h2\">Devices predicted to fail:</div>\n";
313          HtmlChA += "<div class=\"project_detail_device_list\">\n";
314          const TFltIntPrV& ProbIpNumIdV = ProbIpNumIdVH.GetDat(SelProjId);
315          for (int IpNumN = 0; IpNumN < ProbIpNumIdV.Len(); IpNumN++) {
316              const int IpNumId = ProbIpNumIdV[IpNumN].Val2;
317              TStr IpNumNm = BtaDevDefBs->GetIpNumNm(IpNumId);       
318              HtmlChA += "<div class=\"project_detail_device\">\n";
319              HtmlChA += "<b>Device ID:</b> " + IpNumNm + "<br>\n";
320              const int LastEventN = BtaCorrBs->GetIpNumEventV(IpNumId).Last();
321              const TBtaEvent& LastEvent = BtaEventBs->GetEvent(LastEventN);
322              TBtaEventDat LastEventDat; 
323              BtaEventBs->GetEventDat(LastEvent.GetBlobPt(), LastEventDat);
324              HtmlChA += "<b>Last trap:</b> " + LastEventDat.GetFirstTm() + "<br>\n";
325              HtmlChA += "<b>Summary:</b> " + LastEventDat.GetSummary() + "\n";
326              HtmlChA += "</div>\n";
327          }
328          HtmlChA += "</div>\n";
329          HtmlChA += "</div>\n";
330      }
331  	HtmlChA += "</body></html>";
332  }
333  TStr TBTAServer::GetIpNumLink(const int& IpNumId) {
334      TStr IpNumNm = BtaDevDefBs->GetIpNumNm(IpNumId);
335      return TStr::Fmt("<a href=\"/device?id=%d\">%s</a>", IpNumId, IpNumNm.CStr());
336  } 
337  TStr TBTAServer::GetProjLink(const int& IpNumId) {
338      TStr ProjStr;
339      if (BtaCorrBs->IsIpNumProj(IpNumId)) {
340          const int ProjId = BtaCorrBs->GetIpNumProjId(IpNumId);
341          TStr ProjNm = BtaDevDefBs->GetProjNm(ProjId);
342          ProjStr += TStr::Fmt("<a href=\"/project?id=%d\">%s</a>", ProjId, ProjNm.CStr());
343      } else {
344          ProjStr = "&nbsp;";
345      }
346      return ProjStr;
347  } 
348  TStr TBTAServer::GetProjLinkFromProj(const int& ProjId) {
349      TStr ProjNm = BtaDevDefBs->GetProjNm(ProjId);
350      return TStr::Fmt("<a href=\"/project?id=%d\">%s</a>", ProjId, ProjNm.CStr());
351  } 
352  TStr TBTAServer::GetBar(const double& Val, const double& _MxVal) {
353      double MxVal = TFlt::GetMx(_MxVal, TFlt::Eps);
354      if (MxVal < 1.0) { MxVal *= 1.2; }
355      return TStr::Fmt("<div style=\"width: %d%%; background-color: #cc0033;\">&nbsp;</div>", 
356          TInt::GetMn(TFlt::Round(100.0 * Val / MxVal), 100));
357  }
358  void TBTAServer::EventStat(const int& EventId, TChA& HtmlChA) {
359      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
360      TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
361      HtmlChA += "<p><b>#</b> " + TInt(EventId+1).GetStr() + "</br>";
362      HtmlChA += "<b>NodeId:</b> " + EventDat.GetNodeId() + "<br>";
363      HtmlChA += "<b>First occurance:</b> " + EventDat.GetFirstTm() + "<br>";
364      HtmlChA += "<b>Last occurance:</b> " + EventDat.GetLastTm() + "<br>";
365      HtmlChA += "<b>IP:</b> " + GetIpNumLink(Event.GetIpNumId()) + "<br>";
366      HtmlChA += "<b>Case Id:</b> " + EventDat.GetIR() + "<br>";
367      HtmlChA += "<b>Severity:</b> " + EventDat.GetSeverity() + "<br>";
368      HtmlChA += "<b>Project:</b> " + GetProjLinkFromProj(Event.GetProjId()) + "<br>";
369      HtmlChA += "<b>Summary:</b> " + EventDat.GetSummary() + "</p>";
370  }
371  void TBTAServer::EventShortStat(const int& EventId, TChA& HtmlChA) {
372      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
373      TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
374  	HtmlChA += "<small><b>Trap " + TInt(EventId+1).GetStr() + ":</b></br>";
375  	HtmlChA += "<b>IP:</b> " + BtaDevDefBs->GetIpNumNm(Event.GetIpNumId()) + ", ";
376      HtmlChA += "<b>Severity:</b> " + EventDat.GetSeverity() + ", ";
377      HtmlChA += "<b>Project:</b> " + BtaDevDefBs->GetProjNm(Event.GetProjId()) + "<br>";
378      HtmlChA += "<b>Summary:</b> " + EventDat.GetSummary() + "</small><br>";
379  }
380  void TBTAServer::EventFullStat(const int& EventId, TChA& HtmlChA) {
381      TBtaEvent Event = BtaEventBs->GetEvent(EventId);
382      TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
383      const TStrStrH& FldNmToValH = EventDat.FldNmToValH;
384      int KeyId = FldNmToValH.FFirstKeyId();
385      HtmlChA += "<p>";
386      while (FldNmToValH.FNextKeyId(KeyId)) {
387          TStr FldNm = FldNmToValH.GetKey(KeyId);
388          TStr FldVal = FldNmToValH[KeyId];
389          HtmlChA += "<b>" + FldNm + ":</b> " + FldVal + "<br>\n";
390      }
391      HtmlChA += "</p>";
392  }
393  void TBTAServer::EventRootCause(const int& EventId, TChA& HtmlChA) {
394      TIntFltKdV EventIdScoreV; TStrV CorrTypeV;
395      BtaCorrBs->EventRootCause(BtaEventBs, EventId, RootCouseEventWnd, 
396          RootCouseTimeWnd, EventIdScoreV, CorrTypeV);
397      HtmlChA += "<table border=\"1\">\n";
398      DisplayEventHeader(false, true, true, HtmlChA);
399      const int IpNumId = BtaEventBs->GetEvent(EventId).GetIpNumId();
400      for (int EventIdScoreN = 0; EventIdScoreN < EventIdScoreV.Len(); EventIdScoreN++) {
401          const int ScoreEventId = EventIdScoreV[EventIdScoreN].Key;
402          const double Score = EventIdScoreV[EventIdScoreN].Dat;
403          const int ScoreIpNumId = BtaEventBs->GetEvent(ScoreEventId).GetIpNumId();
404          TBtaEvent ScoreEvent = BtaEventBs->GetEvent(ScoreEventId);
405          TBtaEventDat ScoreEventDat; 
406          BtaEventBs->GetEventDat(ScoreEvent.GetBlobPt(), ScoreEventDat);
407          if (CorrTypeV[EventIdScoreN] == "Prob") {
408              DisplayEventRow(ScoreEventId, ScoreEvent, ScoreEventDat, 
409                  false, true, Score, 1.0, ScoreIpNumId, IpNumId, HtmlChA);
410          } else {
411              DisplayEventRow(ScoreEventId, ScoreEvent, ScoreEventDat, 
412                  false, true, Score, 1.0, ScoreIpNumId, -1, HtmlChA);
413          }
414      }
415      HtmlChA += "</table>\n";
416  }
417  void TBTAServer::EventShortRootCause(const int& EventId, TChA& HtmlChA) {
418      TIntFltKdV EventIdScoreV; TStrV CorrTypeV;
419      BtaCorrBs->EventRootCause(BtaEventBs, EventId, RootCouseEventWnd, 
420          RootCouseTimeWnd, EventIdScoreV, CorrTypeV);
421      HtmlChA += "<table border=\"1\">\n";
422      DisplayShortEventHeader(true, HtmlChA);
423      for (int EventIdScoreN = 0; EventIdScoreN < EventIdScoreV.Len(); EventIdScoreN++) {
424          const int ScoreEventId = EventIdScoreV[EventIdScoreN].Key;
425          const double Score = EventIdScoreV[EventIdScoreN].Dat;
426          TBtaEvent ScoreEvent = BtaEventBs->GetEvent(ScoreEventId);
427          TBtaEventDat ScoreEventDat; 
428          BtaEventBs->GetEventDat(ScoreEvent.GetBlobPt(), ScoreEventDat);
429          DisplayShortEventRow(ScoreEventId, ScoreEvent, 
430              ScoreEventDat, true, Score, 1.0, HtmlChA);
431      }
432      HtmlChA += "</table>\n";
433  }
434  void TBTAServer::EventPredIpNums(const int& EventId, TChA& HtmlChA) {
435      const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
436      const int CurrIpNumId = Event.GetIpNumId();
<span onclick='openModal()' class='match'>437      const int CurrProjId = Event.GetProjId();
438      TIntFltH IpNumIdProbH;
439      BtaCorrBs->GetNextIpNumIdProb(EventId, 
440          CurrProjId, BtaEventBs, 100, 600, IpNumIdProbH);
441      if (IpNumIdProbH.Empty()) { return; }
442      TFltIntPrV ProbIpNumIdV; IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV); ProbIpNumIdV.Sort(false);
443      HtmlChA += "<table border=\"1\">\n";
444      HtmlChA += "<tr>";
445      HtmlChA += "<td>#</td>";
446      HtmlChA += "<td>Device</td>";
</span>447      HtmlChA += "<td>Probability</td>";
448      HtmlChA += "<td>Next alarm</td>";
449      HtmlChA += "</tr>\n";
450      double MxProb = 0.0; int ProbIpNumIdN = 0, RowCount = 0;
451      while (ProbIpNumIdN < ProbIpNumIdV.Len()) {
452          const int IpNumId = ProbIpNumIdV[ProbIpNumIdN].Val2; 
453          const int ProjId = BtaCorrBs->GetIpNumProjId(IpNumId);
454          ProbIpNumIdN++; if (ProjId != CurrProjId) { continue; }
455          const double Prob = ProbIpNumIdV[ProbIpNumIdN].Val1;
456          if (RowCount == 0) { MxProb = Prob; }
457          HtmlChA += "<tr>";
458          HtmlChA += "<td>" + TInt(RowCount+1).GetStr() + "</td>";
459          HtmlChA += "<td>" + GetIpNumLink(IpNumId) + " (" + GetProjLink(IpNumId) + ")</td>";
460          HtmlChA += "<td>" + GetBar(Prob, MxProb) + "</td>";
461          const int NextEventN = BtaEventBs->GetNextEvent(EventId+1, IpNumId);
462          if (NextEventN != -1) {
463              const TBtaEvent& NextEvent = BtaEventBs->GetEvent(NextEventN);
464              HtmlChA += TStr::Fmt("<td><a href=\"/event?id=%d\">%d</a></td>", NextEventN, NextEventN);
465          } else {
466              HtmlChA += "<td>--</td>";
467          }
468          HtmlChA += "</tr>\n";
469          RowCount++; if (RowCount >= 5) { break; }
470      }
471      HtmlChA += "</table>\n";
472  }
473  void TBTAServer::EventShortPredIpNums(const int& EventId, TChA& HtmlChA) {
474      const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
475      const int CurrIpNumId = Event.GetIpNumId();
476      const int CurrProjId = Event.GetProjId();
477      TIntFltH IpNumIdProbH;
478      BtaCorrBs->GetNextIpNumIdProb(EventId, 
479          CurrProjId, BtaEventBs, 100, 600, IpNumIdProbH);
480      if (IpNumIdProbH.Empty()) { return; }
481      TFltIntPrV ProbIpNumIdV; IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV); ProbIpNumIdV.Sort(false);
482      HtmlChA += "<table border=\"1\">\n";
483      HtmlChA += "<tr>";
484      HtmlChA += "<td>#</td>";
485      HtmlChA += "<td>Device</td>";
486      HtmlChA += "<td>Probability</td>";
487      HtmlChA += "</tr>\n";
488      double MxProb = 0.0; int ProbIpNumIdN = 0, RowCount = 0;
489      while (ProbIpNumIdN < ProbIpNumIdV.Len()) {
490          const int IpNumId = ProbIpNumIdV[ProbIpNumIdN].Val2; 
491          const int ProjId = BtaCorrBs->GetIpNumProjId(IpNumId);
492          ProbIpNumIdN++; if (ProjId != CurrProjId) { continue; }
493          const double Prob = ProbIpNumIdV[ProbIpNumIdN].Val1;
494          if (RowCount == 0) { MxProb = Prob; }
495          HtmlChA += "<tr>";
496          HtmlChA += "<td>" + TInt(RowCount+1).GetStr() + "</td>";
497          HtmlChA += "<td>" + GetIpNumLink(IpNumId) + " (" + GetProjLink(IpNumId) + ")</td>";
498          HtmlChA += "<td>" + GetBar(Prob, MxProb) + "</td>";
499          HtmlChA += "</tr>\n";
500          RowCount++; if (RowCount >= 5) { break; }
501      }
502      HtmlChA += "</table>\n";
503  }
504  void TBTAServer::DisplayEventHeader(const bool& HdSortP, 
505          const bool& ScoreP, const bool& LinkP, TChA& HtmlChA) {
506      HtmlChA += "<tr>";
507      if (HdSortP) {
508          HtmlChA += "<td># (<a href=\"/events?sort=all\">all</a>)</td>";
509          HtmlChA += "<td>First</td>";
510          HtmlChA += "<td>Last</td>";
511          HtmlChA += "<td>Device IP</td>";
512          HtmlChA += "<td>CaseID (<a href=\"/events?sort=case_id\">filter</a>)</td>";
513      } else { 
514          HtmlChA += "<td>#</td>";
515          HtmlChA += "<td>First</td>";
516          HtmlChA += "<td>Device IP</td>";
517          HtmlChA += "<td>CaseID (IR)</td>";
518      }
519      HtmlChA += "<td>Severity</td>";
520      HtmlChA += "<td>Project</td>";
521      HtmlChA += "<td width=\"250\">Summary</td>";
522      if (ScoreP) { HtmlChA += "<td>Score</td>"; }
523      if (LinkP) { HtmlChA += "<td></td>"; }
524      HtmlChA += "</tr>\n";
525  }
526  void TBTAServer::DisplayEventRow(const int& EventN, const TBtaEvent& Event, 
527          const TBtaEventDat& EventDat, const bool& HdSortP, const bool& ScoreP, 
528          const double& Score, const double& MxScore, const int& IpNumId, 
529          const int& CorrIpNumId, TChA& HtmlChA) {
530      HtmlChA += "<tr>";
531      HtmlChA += TStr::Fmt("<td><a href=\"/event?id=%d\">%d</a> ", EventN, EventN);
532      HtmlChA += TStr::Fmt("(<a onClick=\"window.open('/related_traps?id=%d\','omnibus_view','menubar=0,resizable=1,scrollbars=1,width=600,height=500');\">Omnibus</a>)</td>", EventN);
533      HtmlChA += "<td>" + EventDat.GetFirstTm() + "</td>";
534      if (HdSortP) { HtmlChA += "<td>" + EventDat.GetLastTm() + "</td>"; }
535      HtmlChA += "<td>" + GetIpNumLink(Event.GetIpNumId()) + "</td>";
536      HtmlChA += "<td>" + EventDat.GetIR() + "</td>";
537      HtmlChA += "<td>" + EventDat.GetSeverity() + "</td>";
538      HtmlChA += "<td>" + GetProjLinkFromProj(Event.GetProjId()) + "</td>";
539      HtmlChA += "<td><small>" + EventDat.GetSummary() + "</small></td>";
540      if (ScoreP) { 
541          HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(Score, MxScore).CStr()); 
542      }
543      if (IpNumId != -1 && CorrIpNumId != -1) {
544          HtmlChA += TStr::Fmt("<td><a href=\"/dd_events?id=%d&corrid=%d\">historic co-occucerence</a></td>",
545              IpNumId, CorrIpNumId);
546      } else if (IpNumId != -1 && CorrIpNumId == -1) {
547          HtmlChA += "<td>similar summary text</td>";
548      }
549      HtmlChA += "</tr>\n";
550  }
551  void TBTAServer::DisplayShortEventHeader(const bool& ScoreP, TChA& HtmlChA) {
552      HtmlChA += "<tr>";
553      HtmlChA += "<td>Trap</td>";
554      HtmlChA += "<td>Device</td>";
555      HtmlChA += "<td width=\"150\">Summary</td>";
556      if (ScoreP) { HtmlChA += "<td width=\"20\"></td>"; }
557      HtmlChA += "</tr>\n";
558  }
559  void TBTAServer::DisplayShortEventRow(const int& EventN, const TBtaEvent& Event, 
560          const TBtaEventDat& EventDat, const bool& ScoreP, const double& Score, 
561          const double& MxScore, TChA& HtmlChA) {
562      HtmlChA += "<tr>";
563      HtmlChA += "<td><a href=\"/related_traps?id=" + TInt::GetStr(EventN) + "\">" + 
564          TInt(EventN).GetStr() + "</a></td>";
565      HtmlChA += "<td>" + BtaDevDefBs->GetIpNumNm(Event.GetIpNumId()) + "</td>";
566      HtmlChA += "<td><small>" + EventDat.GetSummary() + "</small></td>";
567      if (ScoreP) { HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(Score, MxScore).CStr()); }
568      HtmlChA += "</tr>\n";
569  }
570  void TBTAServer::MakeEventList(const TIntV& EventV, 
571          const bool& HdSortP, const int& DispPageN, TChA& HtmlChA) {
572      HtmlChA += "<table border=\"1\">\n";
573      DisplayEventHeader(HdSortP, false, false, HtmlChA);
574      const int Events = EventV.Len(); 
575      int EventN = Events - DispPageN*ListEventsPerPage;
576      const int MnEventN = TInt::GetMx(Events - (DispPageN+1)*ListEventsPerPage, 0);
577      while (EventN > MnEventN) {
578          EventN--;
579          TBtaEvent Event = BtaEventBs->GetEvent(EventV[EventN]);
580          TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
581          if (Event.GetIpNumId() != -1 && Event.GetProjId() != -1) {
582              DisplayEventRow(EventV[EventN], Event, 
583                  EventDat, HdSortP, false, 0.0, 0.1, -1, -1, HtmlChA);
584          } else { 
585              printf("Error: EventN == %d, IpNumId == %d, ProjId  == %d\n", 
586                  EventV[EventN].Val, Event.GetIpNumId(), Event.GetProjId()); 
587          }
588      }
589      HtmlChA += "</table>\n";
590  }
591  void TBTAServer::MakeEventPrList(const TIntPrV& EventPrV, const int& DispPageN, TChA& HtmlChA) {
592      TIntIntVH EventIdIdVH; 
593      const int EventPrs = EventPrV.Len();
594      for (int EventPrN = 0; EventPrN < EventPrs; EventPrN++) {
595          const TIntPr& EventPr = EventPrV[EventPrs - EventPrN - 1];
596          EventIdIdVH.AddDat(EventPr.Val1).Add(EventPr.Val2);
597      }
598      HtmlChA += "<table border=\"1\">\n";
599      HtmlChA += "<tr>";
600      HtmlChA += "<td>#</td>";
601      HtmlChA += "<td>Time</td>";
602      HtmlChA += "<td>Device IP</td>";
603      HtmlChA += "<td>Summary</td>";
604      HtmlChA += "<td>Correlated with event sequence</td>";
605      HtmlChA += "</tr>\n";
606      const int Events = EventIdIdVH.Len(); 
607      int EventKeyId = EventIdIdVH.FFirstKeyId(), PageN = 0, EventsOnLastPage = 0;
608      while (EventIdIdVH.FNextKeyId(EventKeyId) && !(PageN > DispPageN)) {
609          if (PageN == DispPageN) {
610              const int EventId = EventIdIdVH.GetKey(EventKeyId);
611              TBtaEvent Event = BtaEventBs->GetEvent(EventId);
612              TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
613              HtmlChA += "<tr valign=\"top\">";
614              HtmlChA += "<td><a href=\"/event?id=" + TInt::GetStr(EventId) + 
615                  "\">" + TInt(EventId).GetStr() + "</a></td>";
616              HtmlChA += "<td>" + EventDat.GetFirstTm() + "</td>";
617              HtmlChA += "<td>" + GetIpNumLink(Event.GetIpNumId()) + "</td>";
618              HtmlChA += "<td>" + TruncStr(EventDat.GetSummary(), 60) + "</td>";
619              HtmlChA += "<td>\n";
620              HtmlChA += "<table border=\"1\">";
621              HtmlChA += "<tr>";
622              HtmlChA += "<td>#</td>";
623              HtmlChA += "<td>Time</td>";
624              HtmlChA += "<td>Device IP</td>";
625              HtmlChA += "<td>Summary</td>";
626              HtmlChA += "</tr>\n";
627              const TIntV& CorrEventIdV = EventIdIdVH[EventKeyId];
628              for (int CorrEventIdN = 0; CorrEventIdN < CorrEventIdV.Len(); CorrEventIdN++) {
629                  const int CorrEventId = CorrEventIdV[CorrEventIdN];
630                  TBtaEvent CorrEvent = BtaEventBs->GetEvent(CorrEventId);
631                  TBtaEventDat CorrEventDat; BtaEventBs->GetEventDat(
632                      CorrEvent.GetBlobPt(), CorrEventDat);
633                  HtmlChA += "<tr valign=\"top\">";
634                  HtmlChA += "<td><a href=\"/event?id=" + TInt::GetStr(CorrEventId) + 
635                      "\">" + TInt(CorrEventId).GetStr() + "</a></td>";
636                  HtmlChA += "<td>" + CorrEventDat.GetFirstTm() + "</td>";
637                  HtmlChA += "<td>" + GetIpNumLink(CorrEvent.GetIpNumId()) + "</td>";
638                  HtmlChA += "<td>" + TruncStr(CorrEventDat.GetSummary(), 60) + "</td>";
639                  HtmlChA += "</tr>";
640              }
641              HtmlChA += "</table>\n";
642              HtmlChA += "</td></tr>\n";
643              HtmlChA += "<tr><td colspan=\"5\">&nbsp;</td></tr>";
644          }
645          EventsOnLastPage += EventIdIdVH[EventKeyId].Len();
646          if (EventsOnLastPage > ListEventsPerPage) { 
647              PageN++; EventsOnLastPage = 0; 
648          }
649      }
650      HtmlChA += "</table>\n";
651  }
652  void TBTAServer::MakeShortEventList(const TIntV& EventV, TChA& HtmlChA) {
653      HtmlChA += "<table border=\"1\">\n";
654      DisplayShortEventHeader(false, HtmlChA);
655      const int Events = TInt::GetMn(ListEventsPerPage, EventV.Len());
656      for (int EventN = 0; EventN < Events; EventN++) {
657          TBtaEvent Event = BtaEventBs->GetEvent(EventV[EventN]);
658          TBtaEventDat EventDat; BtaEventBs->GetEventDat(Event.GetBlobPt(), EventDat);
659          if (Event.GetIpNumId() != -1 && Event.GetProjId() != -1) {
660              DisplayShortEventRow(EventV[EventN], Event, EventDat, false, 0.0, 1.0, HtmlChA);
661          } else { 
662              printf("Error: EventN == %d, IpNumId == %d, ProjId  == %d\n", 
663                  EventV[EventN].Val, Event.GetIpNumId(), Event.GetProjId()); 
664          }
665      }
666      HtmlChA += "</table>\n";
667  }
668  void TBTAServer::IpNumDevCorrStat(const int& IpNumId, TChA& HtmlChA) {
669      TIntFltKdV CorrIpNumIdV;
670      BtaCorrBs->GetIpNumCorrDevices(IpNumId, true, DetailItemsPerPage, CorrIpNumIdV);
671      HtmlChA += "<table border=\"1\">\n";
672      HtmlChA += "<tr>";
673      HtmlChA += "<td>#</td>";
674      HtmlChA += "<td>Device</td>";
675      HtmlChA += "<td>Correlation</td>";
676      HtmlChA += "<td>When does it fire alarms?</td>";
677      HtmlChA += "</tr>\n";
678      for (int CorrIpNumIdN = 0; CorrIpNumIdN < CorrIpNumIdV.Len(); CorrIpNumIdN++) {
679          const int CorrIpNumId = CorrIpNumIdV[CorrIpNumIdN].Key;
680          const double CorrProb = TFlt::Abs(CorrIpNumIdV[CorrIpNumIdN].Dat);
681          const int Sign = TFlt::Sign(CorrIpNumIdV[CorrIpNumIdN].Dat);
682          const double MxCorrProb = TFlt::Abs(CorrIpNumIdV[0].Dat);
683          if (CorrProb < MnCorrProb) { break; }
684          HtmlChA += "<tr>";
685          HtmlChA += "<td>" + TInt(CorrIpNumIdN+1).GetStr() + "</td>";
686          HtmlChA += "<td>" + GetIpNumLink(CorrIpNumId) + " (" + GetProjLink(CorrIpNumId) + ")</td>";
687          HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(CorrProb, MxCorrProb).CStr());            
688          if (Sign > 0) { 
689              HtmlChA += TStr::Fmt("<td>after (<a href=\"/dd_events?id=%d&corrid=%d\">correlated alarms</a>)</td>",
690                  IpNumId, CorrIpNumId);
691          } else { 
692              HtmlChA += TStr::Fmt("<td>before (<a href=\"/dd_events?id=%d&corrid=%d\">correlated alarms</a>)</td>",
693                  CorrIpNumId, IpNumId);
694          }
695          HtmlChA += "</tr>\n";
696      }
697      HtmlChA += "</table>\n";
698  }
699  void TBTAServer::ShortIpNumStat(const int& IpNumId, TChA& HtmlChA) {
700      TStr IpNumNm = BtaDevDefBs->GetIpNumNm(IpNumId);
701      HtmlChA += TStr::Fmt("<p><b>Device IP:</b> %s<br>\n", 
702          GetIpNumLink(IpNumId).CStr());
703      HtmlChA += TStr::Fmt("<b>Device project:</b> %s<br>\n", 
704          GetProjLink(IpNumId).CStr());
705      HtmlChA += TStr::Fmt("<b>Number of alarms:</b> %d</p>\n", 
706          BtaCorrBs->GetIpNumIdEvents(IpNumId));
707  }
708  void TBTAServer::MakeIpNumPrList(const TIntV& DevKeyIdV, const int& DispPageN, TChA& HtmlChA) {
709      HtmlChA += "<table border=\"1\">\n";
710      HtmlChA += "<tr>";
711      HtmlChA += "<td>#</td>";
712      HtmlChA += "<td>First device</td>";
713      HtmlChA += "<td>Second device</td>";
714      HtmlChA += "<td>Correlation</td>";
715      HtmlChA += "<td></td>";
716      HtmlChA += "</tr>\n";
717      const TIntPrIntPrVH& IpNumIdPrToFqH = BtaCorrBs->GetIpNumIdPrH();
718      const TIntPr& FirstIpNumIdPr = IpNumIdPrToFqH.GetKey(DevKeyIdV[0]);
719      const double MxCorrProb = BtaCorrBs->ProbCorrIpNumIdGivenIpNumId(
720          FirstIpNumIdPr.Val1, FirstIpNumIdPr.Val2);
721      const int StartItemN = DispPageN*ListItemsPerPage;
722      const int EndItemN = (DispPageN+1)*ListItemsPerPage;
723      const int DevKeyIds = DevKeyIdV.Len();
724      int DevKeyIdN = 0, ItemN = 0; 
725      while (DevKeyIdN < DevKeyIds && ItemN < EndItemN) {
726          const TIntPr& IpNumIdPr = IpNumIdPrToFqH.GetKey(DevKeyIdV[DevKeyIdN]);
727          const int IpNumId = IpNumIdPr.Val1, CorrIpNumId = IpNumIdPr.Val2;
728          DevKeyIdN++;
729          if (IpNumId == CorrIpNumId) { continue; }
730          ItemN++; if (ItemN < StartItemN) { continue; }
731          HtmlChA += "<tr>";
732          HtmlChA += "<td>" + TInt(ItemN).GetStr() + "</td>";
733          HtmlChA += "<td>" + GetIpNumLink(IpNumId) + " (" + GetProjLink(IpNumId) + ")</td>";
734          HtmlChA += "<td>" + GetIpNumLink(CorrIpNumId) + " (" + GetProjLink(CorrIpNumId) + ")</td>";
735          if (BtaCorrBs->IsIpNumId(IpNumId)) {
736              const double CorrProb = BtaCorrBs->ProbCorrIpNumIdGivenIpNumId(IpNumId, CorrIpNumId);
737              HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(CorrProb, MxCorrProb).CStr());
738          } else {
739              HtmlChA += "<td></td>";
740          }
741          HtmlChA += TStr::Fmt("<td><a href=\"/dd_events?id=%d&corrid=%d\">correlated alarms</a></td>",
742              IpNumId, CorrIpNumId);
743          HtmlChA += "</tr>\n";
744      }
745      HtmlChA += "</table>\n";
746  }
747  void TBTAServer::ProjWithinCorrStat(const int& ProjId, TChA& HtmlChA) {
748      HtmlChA += "<table border=\"1\">\n";
749      HtmlChA += "<tr>";
750      HtmlChA += "<td>#</td>";
751      HtmlChA += "<td>First device</td>";
752      HtmlChA += "<td>Second device</td>";
753      HtmlChA += "<td>Correlation</td>";
754      HtmlChA += "<td></td>";
755      HtmlChA += "</tr>\n";
756      TIntPrFltKdV CorrIpNumIdPrProbV;
757      BtaCorrBs->GetProjCorrDevices(ProjId, 
758          DetailItemsPerPage, CorrIpNumIdPrProbV);
759      const int IpNumPrs = CorrIpNumIdPrProbV.Len();
760      if (IpNumPrs > 0) {
761          double MxCorrProb = CorrIpNumIdPrProbV[0].Dat;
762          for (int IpNumPrN = 0; IpNumPrN < IpNumPrs; IpNumPrN++) {
763              const int IpNumId = CorrIpNumIdPrProbV[IpNumPrN].Key.Val1;
764              const int CorrIpNumId = CorrIpNumIdPrProbV[IpNumPrN].Key.Val2;
765              const double CorrProb = CorrIpNumIdPrProbV[IpNumPrN].Dat;
766              if (CorrProb < MnCorrProb) { break; }
767              HtmlChA += "<tr>";
768              HtmlChA += "<td>" + TInt(IpNumPrN+1).GetStr() + "</td>";
769              HtmlChA += "<td>" + GetIpNumLink(IpNumId) + "</td>";
770              HtmlChA += "<td>" + GetIpNumLink(CorrIpNumId) + "</td>";
771              HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(CorrProb, MxCorrProb).CStr());
772              HtmlChA += TStr::Fmt("<td><a href=\"/dd_events?id=%d&corrid=%d\">correlated alarms</a></td>",
773                  IpNumId, CorrIpNumId);
774              HtmlChA += "</tr>\n";
775          }
776      }
777      HtmlChA += "</table>\n";
778  }
779  void TBTAServer::ShortProjStat(const int& ProjId, TChA& HtmlChA, const bool& ProjNmLinkP) {
780      TStr ProjNm = BtaDevDefBs->GetProjNm(ProjId);
781      if (!ProjNmLinkP) { 
782          HtmlChA += TStr::Fmt("<p>Project name: <b>%s</b></p>\n", 
783              ProjNm.CStr()); 
784      } else { 
785          HtmlChA += TStr::Fmt("<p>Project name: <b>%s</b></p>\n", 
786              GetProjLinkFromProj(ProjId).CStr()); 
787      }
788      int BeforeCount, WeekAfterCount, MonthAfterCount;
789      TTm StartDate = BtaEventBs->GetFirstTime(), EndDate = BtaEventBs->GetLastTime();
790      TTm WeekBreakDate = GetBreakDate(7), MonthBreakDate = GetBreakDate(30);
791      PBtaLongProj LongProj = BtaLongBs->GetLongProjFromId(ProjId);
792      LongProj->Count(StartDate, WeekBreakDate, EndDate, BeforeCount, WeekAfterCount);
793      LongProj->Count(StartDate, MonthBreakDate, EndDate, BeforeCount, MonthAfterCount);
794      const int TotalCount = BeforeCount + MonthAfterCount;
795      const bool IsWeekTrendPosP = LongProj->IsTrendPos(StartDate, WeekBreakDate, EndDate);
796      const bool IsMonthTrendPosP = LongProj->IsTrendPos(StartDate, MonthBreakDate, EndDate);
797      const double WeekChiProb = LongProj->ChiSquare(StartDate, WeekBreakDate, EndDate);
798      const double MonthChiProb = LongProj->ChiSquare(StartDate, MonthBreakDate, EndDate);  
799      HtmlChA += TStr::Fmt("</p>Number of alarms: <b>%d</b> (severity > 2)<br>\n", TotalCount);
800      if (WeekChiProb < 0.05) {
801          HtmlChA += TStr::Fmt("Number of alarms in last 7 days: <b>%d</b> (%s)<br>\n", 
802              WeekAfterCount, IsWeekTrendPosP ? "increasing" : "decreasing");
803      } else {
804          HtmlChA += TStr::Fmt("Number of alarms in last 7 days: <b>%d</b><br>\n", WeekAfterCount);
805      }
806      if (MonthChiProb < 0.05) {
807          HtmlChA += TStr::Fmt("Number of alarms in last 30 days: <b>%d</b> (%s)</p>\n", 
808              MonthAfterCount, IsMonthTrendPosP ? "increasing" : "decreasing");
809      } else {
810          HtmlChA += TStr::Fmt("Number of alarms in last 30 days: <b>%d</b></p>\n", MonthAfterCount);
811      }
812  }
813  void TBTAServer::MakeLongProjList(const TIntV& SortProjIdV, 
814          const int& DispPageN, const TStr& PeriodStr, TChA& HtmlChA) {
815      HtmlChA += "<table border=\"1\">\n";
816      HtmlChA += "<tr>";
817      HtmlChA += "<td>#</td>";
818      HtmlChA += "<td>Project</td>";
819      HtmlChA += "<td>Significance</td>";
820      HtmlChA += "<td></td>";
821      HtmlChA += "</tr>\n";
822      TTm StartDate = BtaEventBs->GetFirstTime();
823      TTm BreakDate = GetBreakDate(PeriodStr == "week" ? 7 : 30);
824      TTm EndDate = BtaEventBs->GetLastTime();
825      const int Projs = TInt::GetMn((DispPageN+1)*ListItemsPerPage, SortProjIdV.Len());
826      for (int ProjN = DispPageN*ListItemsPerPage; ProjN < Projs; ProjN++) {
827          const int ProjId = SortProjIdV[ProjN];
828          PBtaLongProj LongProj = BtaLongBs->GetLongProjFromId(ProjId);
829          const double ChiProb = MxChiProb - LongProj->ChiSquare(StartDate, BreakDate, EndDate);
830          int BeforeCount, AfterCount; LongProj->Count(
831              StartDate, BreakDate, EndDate, BeforeCount, AfterCount);
832          const bool IsTrendPosP = LongProj->IsTrendPos(StartDate, BreakDate, EndDate);
833          HtmlChA += "<tr>";
834          HtmlChA += TStr::Fmt("<td>%d</td>", ProjN + 1);
835          HtmlChA += TStr::Fmt("<td>%s</td>", GetProjLinkFromProj(ProjId).CStr());
836          HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(ChiProb, MxChiProb).CStr());
837          HtmlChA += TStr::Fmt("<td><a href=\"/p_long?id=%d&period=%s\">Show Details</td>",
838              ProjId, PeriodStr.CStr());
839          HtmlChA += "</tr>\n";
840      }
841      HtmlChA += "</table>\n";
842  }
843  void TBTAServer::MakeLongIpNumList(const int& ProjId, 
844          const int& DispPageN, const TStr& PeriodStr, TChA& HtmlChA) {
845      HtmlChA += "<table border=\"1\">\n";
846      HtmlChA += "<tr>";
847      HtmlChA += "<td>#</td>";
848      HtmlChA += "<td>Device IP</td>";
849      HtmlChA += "<td>Significance</td>";
850      HtmlChA += "<td>Avg. alarms</td>";
851      HtmlChA += "<td>In last " + PeriodStr + "</td>";
852      HtmlChA += "<td>Trend</td>";
853      HtmlChA += "</tr>\n";
854      TTm StartDate = BtaEventBs->GetFirstTime();
855      TTm BreakDate = GetBreakDate(PeriodStr == "week" ? 7 : 30);
856      TTm EndDate = BtaEventBs->GetLastTime();
857      PBtaLongProj LongProj = BtaLongBs->GetLongProjFromId(ProjId);
858      TIntFltKdV IpNumIdWgtV; LongProj->GetIpNumWgtV(StartDate, BreakDate, EndDate, IpNumIdWgtV);
859      const double MxIpNumWgt = IpNumIdWgtV[0].Dat;
860      const int IpNums = TInt::GetMn((DispPageN+1)*ListItemsPerPage, IpNumIdWgtV.Len());
861      for (int IpNumN = DispPageN*ListItemsPerPage; IpNumN < IpNums; IpNumN++) {
862          const int IpNumId = IpNumIdWgtV[IpNumN].Key;
863          const double IpNumWgt = IpNumIdWgtV[IpNumN].Dat;
864          if ((IpNumWgt / MxIpNumWgt) < MnChiVal) { break; }
865          double AvgCount; int LastCount; 
866          GetIpNumEventCount(IpNumId, StartDate, BreakDate, EndDate, AvgCount, LastCount);
867          const bool IsTrendPosP = (double(LastCount) > AvgCount);
868          HtmlChA += "<tr>";
869          HtmlChA += TStr::Fmt("<td>%d</td>", IpNumN + 1);
870          HtmlChA += TStr::Fmt("<td>%s</td>", GetIpNumLink(IpNumId).CStr());
871          HtmlChA += TStr::Fmt("<td>%s</td>", GetBar(IpNumWgt, MxIpNumWgt).CStr());
872          HtmlChA += TStr::Fmt("<td>%.2f</td>", AvgCount);
873          HtmlChA += TStr::Fmt("<td>%d</td>", LastCount);
874          HtmlChA += TStr::Fmt("<td>%s</td>", IsTrendPosP ? "+" : "-");
875          HtmlChA += "</tr>\n";
876      }
877      HtmlChA += "</table>\n";
878  }
879  void TBTAServer::RunGnuPlot(const TStr& PlotFNm) const {
880    TStr GPPath = GnuPlotPath;
881    IAssertR(TFile::Exists(GPPath), TStr("GnuPlot not found at '")+GnuPlotPath+"'. Set TGnuPlot::GnuPlotPath.");
882    system(TStr::Fmt("%s %s", GPPath.CStr(), PlotFNm.CStr()).CStr());
883  }
884  void TBTAServer::PlotEventV(const TStr& TitleStr, const TIntV& EventV, 
885          const TStr& PlotFNm, const int& Width, const int& Height) {
886      TUInt64H DateCountH;
887      for (int EventIdN = 0; EventIdN < EventV.Len(); EventIdN++) {
888          const int EventId = EventV[EventIdN];
889          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
890          TTm EventTm = Event.GetFirstTm();
891          TTm DayEventTm(EventTm.GetYear(), EventTm.GetMonth(), EventTm.GetDay());
892          DateCountH.AddDat(TTm::GetMSecsFromTm(DayEventTm))++;
893      }
894      TUInt64IntPrV DateCountV;
895      DateCountH.GetKeyDatPrV(DateCountV);
896      DateCountV.Sort(true);
897      int MxCount = 0;
898      {
899          TFOut DataFOut(PlotFNm + ".tab"); 
900          DataFOut.PutStrLn("# day count");
901          for (int DayN = 0; DayN < DateCountV.Len(); DayN++) {
902              MxCount = TInt::GetMx(MxCount, DateCountV[DayN].Val2); 
903              DataFOut.PutStrLn(TStr::Fmt("%d %d", DayN+1, DateCountV[DayN].Val2));
904          }
905          DataFOut.Flush();
906      }
907      double MxCountFlt = (double)MxCount * 1.15;
908      {
909          TFOut PlotFOut(PlotFNm);
910          PlotFOut.PutStrLn("# event plot");
911          PlotFOut.PutStrLn(TStr::Fmt("set autoscale"));
912          PlotFOut.PutStrLn(TStr::Fmt("set xrange [0:%d]", DateCountV.Len() + 1));
913          PlotFOut.PutStrLn(TStr::Fmt("set yrange [0:%.2f]", MxCountFlt));
914          PlotFOut.PutStrLn(TStr::Fmt("set terminal png large size %d,%d", Width, Height));
915          PlotFOut.PutStrLn(TStr::Fmt("set output '%s.png'", PlotFNm.CStr()));
916          PlotFOut.PutStrLn(TStr::Fmt("set boxwidth 0.8"));
917          PlotFOut.PutStr(TStr::Fmt("set xtics rotate  ( "));
918          const int Dates = DateCountV.Len() > 10 ? 10 : DateCountV.Len();
919          double DayDiff = double(DateCountV.Len()) / double(Dates);
920          for (int DateN = 0; DateN < Dates; DateN++) {
921              const int DayN = TFlt::Round(DateN * DayDiff);
922              IAssertR(0 <= DayN && DayN < DateCountV.Len(), TInt::GetStr(DayN));
923              const uint64 DateMSecs = DateCountV[DayN].Val1.Val;
924              TStr DateStr = TTm::GetTmFromMSecs(DateMSecs).GetWebLogDateStr();
925              if (DateN != 0) { PlotFOut.PutStr(", "); }
926              PlotFOut.PutStr(TStr::Fmt("\" %s\" %d", DateStr.CStr(), DayN+1));
927          }
928          PlotFOut.PutStrLn(")");
929          PlotFOut.PutStrLn("set xlabel \"Time\"");
930          PlotFOut.PutStrLn(TStr::Fmt("plot \"%s.tab\" using 1:2 title \"%s\" with boxes", 
931              PlotFNm.CStr(), TitleStr.CStr()));
932      }
933      RunGnuPlot(PlotFNm);
934  }
935  void TBTAServer::PlotEventV(const TStr& TitleStr, const TIntV& EventV, 
936          const TStr& CorrTitleStr, const TIntV& CorrEventV, const TStr& PlotFNm) {
937      TUInt64IntPrH DateCountH;
938      for (int EventIdN = 0; EventIdN < EventV.Len(); EventIdN++) {
939          const int EventId = EventV[EventIdN];
940          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
941          TTm EventTm = Event.GetFirstTm();
942          TTm DayEventTm(EventTm.GetYear(), EventTm.GetMonth(), EventTm.GetDay());
943          DateCountH.AddDat(TTm::GetMSecsFromTm(DayEventTm)).Val1++;
944      }
945      for (int EventIdN = 0; EventIdN < CorrEventV.Len(); EventIdN++) {
946          const int EventId = CorrEventV[EventIdN];
947          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
948          TTm EventTm = Event.GetFirstTm();
949          TTm DayEventTm(EventTm.GetYear(), EventTm.GetMonth(), EventTm.GetDay());
950          DateCountH.AddDat(TTm::GetMSecsFromTm(DayEventTm)).Val2++;
951      }
952      TUInt64IntPrPrV DateCountV;
953      DateCountH.GetKeyDatPrV(DateCountV);
954      DateCountV.Sort(true);
955      int MxCount = 0;
956      {
957          TFOut DataFOut(PlotFNm + ".tab"); 
958          DataFOut.PutStrLn("# day count");
959          for (int DayN = 0; DayN < DateCountV.Len(); DayN++) {
960              MxCount = TInt::GetMx(MxCount, DateCountV[DayN].Val2.Val1); 
961              MxCount = TInt::GetMx(MxCount, DateCountV[DayN].Val2.Val2); 
962              DataFOut.PutStrLn(TStr::Fmt("%d %d %d", DayN+1, 
963                  DateCountV[DayN].Val2.Val1, DateCountV[DayN].Val2.Val2));
964          }
965          DataFOut.Flush();
966      }
967      double MxCountFlt = (double)MxCount * 1.25;
968      {
969          TFOut PlotFOut(PlotFNm);
970          PlotFOut.PutStrLn("# event plot");
971          PlotFOut.PutStrLn(TStr::Fmt("set autoscale"));
972          PlotFOut.PutStrLn(TStr::Fmt("set xrange [0:%d]", DateCountV.Len() + 1));
973          PlotFOut.PutStrLn(TStr::Fmt("set yrange [0:%.2f]", MxCountFlt));
974          PlotFOut.PutStrLn(TStr::Fmt("set terminal png large size 700,300"));
975          PlotFOut.PutStrLn(TStr::Fmt("set output '%s.png'", PlotFNm.CStr()));
976          PlotFOut.PutStrLn(TStr::Fmt("set boxwidth 0.4"));
977          PlotFOut.PutStr(TStr::Fmt("set xtics rotate  ( "));
978          const int Dates = DateCountV.Len() > 10 ? 10 : DateCountV.Len();
979          double DayDiff = double(DateCountV.Len()) / double(Dates);
980          for (int DateN = 0; DateN < Dates; DateN++) {
981              const int DayN = TFlt::Round(DateN * DayDiff);
982              IAssertR(0 <= DayN && DayN < DateCountV.Len(), TInt::GetStr(DayN));
983              const uint64 DateMSecs = DateCountV[DayN].Val1.Val;
984              TStr DateStr = TTm::GetTmFromMSecs(DateMSecs).GetWebLogDateStr();
985              if (DateN != 0) { PlotFOut.PutStr(", "); }
986              PlotFOut.PutStr(TStr::Fmt("\" %s\" %d", DateStr.CStr(), DayN+1));
987          }
988          PlotFOut.PutStrLn(")");
989          PlotFOut.PutStrLn("set xlabel \"Time\"");
990          PlotFOut.PutStrLn("set ylabel \"Number of alarms\"");
991          PlotFOut.PutStr(TStr::Fmt("plot \"%s.tab\" using ($1-0.22):2 title \"%s\" with boxes, ", 
992              PlotFNm.CStr(), TitleStr.CStr()));
993          PlotFOut.PutStrLn(TStr::Fmt("\"%s.tab\" using ($1+0.22):3 title \"%s\" with boxes", 
994              PlotFNm.CStr(), CorrTitleStr.CStr()));
995      }
996      RunGnuPlot(PlotFNm);
997  }
998  void TBTAServer::PlotLongIpNum(const TStr& TitleStr, const TStr& PlotFNm,
999          const int& ProjId, const TTm& StartDate, const TTm& BreakDate, 
1000          const TTm& EndDate, const TStr& PeriodStr, const int& MxIpNums, 
1001          const bool& BigP) {
1002      PBtaLongProj LongProj = BtaLongBs->GetLongProjFromId(ProjId);
1003      TIntFltKdV IpNumIdWgtV; LongProj->GetIpNumWgtV(
1004          StartDate, BreakDate, EndDate, IpNumIdWgtV);
1005      if (IpNumIdWgtV.Len() > MxIpNums) { IpNumIdWgtV.Trunc(MxIpNums); }
1006      int MxCount = 0;
1007      {
1008          TFOut DataFOut(PlotFNm + ".tab"); 
1009          DataFOut.PutStrLn("# ipnum count");
1010          for (int IpNumN = 0; IpNumN < IpNumIdWgtV.Len(); IpNumN++) {
1011              const int IpNumId = IpNumIdWgtV[IpNumN].Key;
1012              double AvgCount; int LastCount; 
1013              GetIpNumEventCount(IpNumId, StartDate, 
1014                      BreakDate, EndDate, AvgCount, LastCount);
1015              MxCount = TInt::GetMx(MxCount, int(ceil(AvgCount))); 
1016              MxCount = TInt::GetMx(MxCount, LastCount); 
1017              DataFOut.PutStrLn(TStr::Fmt("%d %.2f %d", IpNumN+1, AvgCount, LastCount));
1018          }
1019          DataFOut.Flush();
1020      }
1021      double MxCountFlt = (double)MxCount * 1.25;
1022      {
1023          TFOut PlotFOut(PlotFNm);
1024          PlotFOut.PutStrLn("# event plot");
1025          PlotFOut.PutStrLn(TStr::Fmt("set autoscale"));
1026          PlotFOut.PutStrLn(TStr::Fmt("set xrange [0:%d]", IpNumIdWgtV.Len() + 1));
1027          PlotFOut.PutStrLn(TStr::Fmt("set yrange [0:%.2f]", MxCountFlt));
1028          if (BigP) { PlotFOut.PutStrLn(TStr::Fmt("set terminal png large size 700,300")); }
1029          else { PlotFOut.PutStrLn(TStr::Fmt("set terminal png large size 300,100")); }
1030          PlotFOut.PutStrLn(TStr::Fmt("set output '%s.png'", PlotFNm.CStr()));
1031          PlotFOut.PutStrLn(TStr::Fmt("set boxwidth 0.4"));
1032          if (BigP) {
1033              PlotFOut.PutStr(TStr::Fmt("set xtics rotate  ( "));
1034              for (int IpNumN = 0; IpNumN < IpNumIdWgtV.Len(); IpNumN++) {
1035                  const int IpNumId = IpNumIdWgtV[IpNumN].Key;
1036                  TStr IpNumStr = BtaEventBs->GetDevDefBs()->GetIpNumNm(IpNumId);
1037                  if (IpNumN != 0) { PlotFOut.PutStr(", "); }
1038                  PlotFOut.PutStr(TStr::Fmt("\" %s\" %d", IpNumStr.CStr(), IpNumN+1));
1039              }
1040              PlotFOut.PutStrLn(")");
1041          }
1042          PlotFOut.PutStrLn("set xlabel \"Time\"");
1043          PlotFOut.PutStrLn("set ylabel \"Number of alarms\"");
1044          TStr TitleStr = "Average", LastTitleStr = "In last " + PeriodStr;
1045          PlotFOut.PutStr(TStr::Fmt("plot \"%s.tab\" using ($1-0.22):2 title \"%s\" with boxes, ", 
1046              PlotFNm.CStr(), TitleStr.CStr()));
1047          PlotFOut.PutStrLn(TStr::Fmt("\"%s.tab\" using ($1+0.22):3 title \"%s\" with boxes", 
1048              PlotFNm.CStr(), LastTitleStr.CStr()));
1049      }
1050      RunGnuPlot(PlotFNm);    
1051  }
1052  int TBTAServer::ProcessNewBuffer() {
1053      TIntV EventIdV; BtaEventBs->AddNewBuffer(EventIdV);
1054      for (int EventIdN = 0; EventIdN < EventIdV.Len(); EventIdN++) {
1055          const int EventId = EventIdV[EventIdN];
1056          BtaCorrBs->AddEvent(BtaEventBs, EventId);
1057          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
1058          if (Event.GetIpNumId() == -1 || Event.GetProjId() == -1) { continue; }
1059          if (Event.GetSeverity() < MnSeverity) { continue; }
1060          AllEventIdV.Add(EventId);
1061          if (Event.GetCaseId() == -1) { continue; }
1062          CaseIdEventIdV.Add(EventId);
1063      }
1064      TFOut LogFOut("btalarms.log", true);
1065      LogFOut.PutStrLn(TStr::Fmt("[%s] processed %d new alarms!", 
1066          TTm::GetCurLocTm().GetWebLogDateTimeStr().CStr(), EventIdV.Len()));
1067      return EventIdV.Len();
1068  }
1069  void TBTAServer::ProcessDumpBuffer() {
1070      ProcessNewBuffer();
1071      BtaEventBs->SaveBin(TFile::GetUniqueFNm(DumpFPath + "BTAlarms.bta"));
1072      BtaCorrBs->SaveBin(TFile::GetUniqueFNm(DumpFPath + "BTAlarms.btc"));
1073      BtaLongBs->SaveBin(TFile::GetUniqueFNm(DumpFPath + "BTAlarms.btl"));
1074      BtaEventBs->SaveDumpBuffer();
1075      TFOut LogFOut("btalarms.log", true);
1076      LogFOut.PutStrLn(TStr::Fmt("[%s] dump completed!", 
1077          TTm::GetCurLocTm().GetWebLogDateTimeStr().CStr()));
1078  }
1079  int TBTAServer::RescueFromDumpBuffer() {
1080      TIntV EventIdV; BtaEventBs->RescueDumpBuffer(EventIdV);
1081      for (int EventIdN = 0; EventIdN < EventIdV.Len(); EventIdN++) {
1082          const int EventId = EventIdV[EventIdN];
1083          BtaCorrBs->AddEvent(BtaEventBs, EventId);
1084          const TBtaEvent& Event = BtaEventBs->GetEvent(EventId);
1085          if (Event.GetIpNumId() == -1 || Event.GetProjId() == -1) { continue; }
1086          if (Event.GetSeverity() < MnSeverity) { continue; }
1087          AllEventIdV.Add(EventId);
1088          if (Event.GetCaseId() == -1) { continue; }
1089          CaseIdEventIdV.Add(EventId);
1090      }
1091      TFOut LogFOut("btalarms.log", true);
1092      LogFOut.PutStrLn(TStr::Fmt("[%s] rescued %d alarms!", 
1093          TTm::GetCurLocTm().GetWebLogDateTimeStr().CStr(), EventIdV.Len()));
1094      return EventIdV.Len();
1095  }
1096  void TBTAServer::SaveAndExit() {
1097      ProcessNewBuffer();
1098      BtaEventBs->SaveBin(BinFPath + "BTAlarms.bta");
1099      BtaCorrBs->SaveBin(BinFPath + "BTAlarms.btc");
1100      BtaLongBs->SaveBin(BinFPath + "BTAlarms.btl");
1101      BtaEventBs->SaveDumpBuffer();
1102      TFOut LogFOut("btalarms.log", true);
1103      LogFOut.PutStrLn(TStr::Fmt("[%s] save completed!", 
1104          TTm::GetCurLocTm().GetWebLogDateTimeStr().CStr()));
1105      ExitProcess(0);
1106  }
1107  TBTAServer::TBTAServer(const int& WebSrvPortN, const TStr& _BinFPath, 
1108          const TStr& _DumpFPath, const POdbcDb& OdbcDb, const TStr& _GnuPlotPath):   
1109              TWebSrv(WebSrvPortN, true, TNotify::StdNotify) {
1110      printf("Starting server \n");
1111      BinFPath = _BinFPath; DumpFPath = _DumpFPath; GnuPlotPath = _GnuPlotPath;
1112      BtaEventBs = TBtaEventBs::LoadBin(BinFPath + "BTAlarms.bta", OdbcDb);
1113      BtaDevDefBs = BtaEventBs->GetDevDefBs();
1114      BtaCorrBs = TBtaCorrBs::LoadBin(BinFPath + "BTAlarms.btc");
1115      BtaLongBs = TBtaLongBs::LoadBin(BinFPath + "BTAlarms.btl");
1116      RescueFromDumpBuffer();
1117      const int Events = BtaEventBs->GetEvents();
1118      printf(" No. of events: %d\n", Events);
1119      {printf("Loading events ");   
1120      for (int EventN = 0; EventN < Events; EventN++) {
1121          TBtaEvent Event = BtaEventBs->GetEvent(EventN);
1122          if (Event.GetIpNumId() == -1 || Event.GetProjId() == -1) { continue; }
1123          if (Event.GetSeverity() < MnSeverity) { continue; }
1124          AllEventIdV.Add(EventN);
1125          if (Event.GetCaseId() == -1) { continue; }
1126          CaseIdEventIdV.Add(EventN);
1127      } printf(".");}
1128      {printf(" LongProj ");
1129      TFltIntKdV WeekChiProjIdV, WeekKsProjIdV, MonthChiProjIdV, MonthKsProjIdV; printf(".");
1130      TTm StartDate = BtaEventBs->GetFirstTime(), EndDate = BtaEventBs->GetLastTime(); printf(".");
1131      TTm WeekBreakDate = GetBreakDate(7), MonthBreakDate = GetBreakDate(30); printf(".");
1132      int ProjKeyId = BtaLongBs->FFirstKeyId(); printf(".");
1133      int AllCount = 0, WeekSkipCount = 0, MonthSkipCount = 0;
1134      while (BtaLongBs->FNextKeyId(ProjKeyId)) {
1135          AllCount++;
1136          const int ProjId = BtaLongBs->GetProjId(ProjKeyId);
1137          PBtaLongProj LongProj = BtaLongBs->GetLongProj(ProjKeyId);
1138          int BeforeCount, AfterCount;
1139          LongProj->Count(StartDate, WeekBreakDate, EndDate, BeforeCount, AfterCount);
1140          const bool IsWeekTrendPosP = LongProj->IsTrendPos(StartDate, WeekBreakDate, EndDate);
1141          if (BeforeCount > MnBeforeCount &bsol;*&& IsWeekTrendPosP*/) {
1142              const double WeekChi = LongProj->ChiSquare(StartDate, WeekBreakDate, EndDate);
1143              WeekChiProjIdV.Add(TFltIntKd(WeekChi, ProjId));
1144          } else { WeekSkipCount++; }
1145          LongProj->Count(StartDate, MonthBreakDate, EndDate, BeforeCount, AfterCount);
1146          const bool IsMonthTrendPosP = LongProj->IsTrendPos(StartDate, MonthBreakDate, EndDate);
1147          if (BeforeCount > MnBeforeCount &bsol;*&& IsMonthTrendPosP*/) {
1148              const double MonthChi = LongProj->ChiSquare(StartDate, MonthBreakDate, EndDate);
1149              MonthChiProjIdV.Add(TFltIntKd(MonthChi, ProjId));
1150          } else { MonthSkipCount++; }
1151      }
1152      printf("(%d/%d/%d)", AllCount, WeekSkipCount, MonthSkipCount);
1153      WeekChiProjIdV.Sort(true); WeekChiSortProjIdV.Clr();
1154      for (int EltN = 0; EltN < WeekChiProjIdV.Len(); EltN++) {
1155          if (WeekChiProjIdV[EltN].Key > MxChiProb) { break; }
1156          WeekChiSortProjIdV.Add(WeekChiProjIdV[EltN].Dat); }
1157      WeekChiSortProjIdV.Pack(); 
1158      MonthChiProjIdV.Sort(true); MonthChiSortProjIdV.Clr();
1159      for (int EltN = 0; EltN < MonthChiProjIdV.Len(); EltN++) {
1160          if (MonthChiProjIdV[EltN].Key > MxChiProb) { break; }
1161          MonthChiSortProjIdV.Add(MonthChiProjIdV[EltN].Dat); }
1162      MonthChiSortProjIdV.Pack();
1163      printf(".");}
1164      printf(" Done\n");
1165  }
1166  void TBTAServer::OnHttpRq(const int& SockId, const PHttpRq& HttpRq) {
1167      if (!HttpRq->IsOk()) { return; }
1168      PUrl RqUrl=HttpRq->GetUrl();
1169      if (!RqUrl->IsOk()) { return; }
1170      PUrl HttpRqUrl = HttpRq->GetUrl();
1171      TStr UrlStr = HttpRqUrl->GetUrlStr();
1172      TStr CmdNm = HttpRqUrl->GetPathSeg(0);
1173      TStr FullQueryStr = HttpRqUrl->GetSearchStr();
1174      PUrlEnv HttpRqUrlEnv=HttpRq->GetUrlEnv();
1175      TStr TimeNow = TTm::GetCurLocTm().GetWebLogDateTimeStr(true);
1176      printf("[%s] Request %s %s\n", TimeNow.CStr(), CmdNm.CStr(), FullQueryStr.CStr());
1177      PHttpResp HttpResp;
1178      if (CmdNm == "style.css") {
1179          PSIn BodySIn = TFIn::New("style.css");
1180          HttpResp = THttpResp::New(THttp::OkStatusCd, "text/css", false, BodySIn);
1181      } else if (CmdNm == "board.css") {
1182          PSIn BodySIn = TFIn::New("board.css");
1183          HttpResp = THttpResp::New(THttp::OkStatusCd, "text/css", false, BodySIn);
1184      } else if (CmdNm.Right(4) == ".png") {
1185          TStr ImgFNm = "./" + CmdNm; 
1186          ImgFNm.ChangeChAll('-', '/');
1187          PSIn BodySIn = TFIn::New(ImgFNm);
1188          HttpResp = THttpResp::New(THttp::OkStatusCd, "image/png", false, BodySIn);
1189      } else if (CmdNm == "process") { 
1190          TStr MsgStr; 
1191          try {
1192              TStr ProcessType = HttpRqUrlEnv->GetVal("type", 0, "new");
1193              if (ProcessType == "new") {
1194                  const int NewEvents = ProcessNewBuffer();
1195                  MsgStr = TStr::Fmt("Loaded %d new alarms!", NewEvents);
1196              } else if (ProcessType == "dump") {
1197                  ProcessDumpBuffer();
1198                  MsgStr = "Dump successful!";
1199              } else if (ProcessType == "exit") {
1200                  SaveAndExit();
1201                  MsgStr = "Exit successful!";
1202              }
1203          } catch (PExcept Except) {
1204              printf("Exception: %s", Except->GetMsgStr().CStr());
1205          }
1206  		PSIn BodySIn = TMIn::New(MsgStr);
1207  		HttpResp = THttpResp::New(THttp::OkStatusCd, 
1208  			THttp::TextHtmlFldVal, false, BodySIn);
1209      } else if (CmdNm == "board") { 
1210          TStr ProjCountStr = HttpRqUrlEnv->GetVal("count", 0, "0");
1211          const int ProjCount = ProjCountStr.IsInt() ? ProjCountStr.GetInt() : 0;
1212          TStr RefreshTmSecStr = HttpRqUrlEnv->GetVal("refresh", 0, "10");
1213          const int RefreshTmSec = RefreshTmSecStr.IsInt() ? RefreshTmSecStr.GetInt() : 10;
1214          TChA HtmlChA;
1215          MakeBoardPage(ProjCount, RefreshTmSec, HtmlChA);
1216  		PSIn BodySIn = TMIn::New(HtmlChA);
1217  		HttpResp = THttpResp::New(THttp::OkStatusCd, 
1218  			THttp::TextHtmlFldVal, false, BodySIn);
1219      } else if ((CmdNm == "related_traps") || 
1220          (CmdNm == "predicted_traps") || (CmdNm == "trap_device")) {
1221  		const bool RelatedTrapsP = (CmdNm == "related_traps");
1222          const bool PredictedTrapsP = (CmdNm == "predicted_traps");
1223  		const bool TrapDeviceP = (CmdNm == "trap_device");
1224          TStr EventIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1225          if (EventIdStr.IsInt()) {
1226              const int EventId = EventIdStr.GetInt();
1227  			TChA HtmlChA;
1228  			HtmlChA += "<html><head>\n";
1229  			HtmlChA += "<title>BT Alarms Explorer</title>\n";
1230  			HtmlChA += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";
1231  			HtmlChA += "<link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\">\n";
1232  			HtmlChA += "</head><body>\n";
1233  			if (RelatedTrapsP) { 
1234  				HtmlChA += "[ Related Traps | ";
1235  				HtmlChA += "<a href=\"/predicted_traps?id=" + 
1236                      EventIdStr + "\">Predicted Traps</a> |";
1237  				HtmlChA += "<a href=\"/trap_device?id=" + 
1238                      EventIdStr + "\">Device Histroy and Trends</a> ]";
1239              } else if (PredictedTrapsP) {
1240  				HtmlChA += "[ <a href=\"/related_traps?id=" +
1241                      EventIdStr + "\">Related Traps</a> |";
1242  				HtmlChA += "Predicted Traps |";
1243  				HtmlChA += "<a href=\"/trap_device?id=" + 
1244                      EventIdStr + "\">Device Histroy and Trends</a> ]";
1245  			} else {
1246  				HtmlChA += "[ <a href=\"/related_traps?id=" +
1247                      EventIdStr + "\">Related Traps</a> |";
1248  				HtmlChA += "<a href=\"/predicted_traps?id=" + 
1249                      EventIdStr + "\">Predicted Traps</a> |";
1250  				HtmlChA += "Device Histroy and Trends ]";
1251  			}
1252  			HtmlChA += "<br><hr>";
1253  			if (RelatedTrapsP) {
1254  				MakeShortEventPage(EventId, HtmlChA);
1255              } else if (PredictedTrapsP) {
1256                  MakeShortPredIpNumsPage(EventId, HtmlChA);
1257              } else if (TrapDeviceP) {
1258  				MakeShortIpNumPage(EventId, HtmlChA);
1259  			}
1260  			HtmlChA += "</body></html>";
1261  			PSIn BodySIn = TMIn::New(HtmlChA);
1262  			HttpResp = THttpResp::New(THttp::OkStatusCd, 
1263  				THttp::TextHtmlFldVal, false, BodySIn);
1264          } else {
1265              printf("Wrong parameter id '%s' ..;\n", EventIdStr.CStr());
1266          }
1267      } else if (CmdNm == "report") { 
1268          TStr ReportType = HttpRqUrlEnv->GetVal("type", 0, "related");
1269          TChA HtmlChA;
1270          HtmlChA += "<html><head>\n";
1271          HtmlChA += "<title>BT Alarms Explorer</title>\n";
1272          HtmlChA += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";
1273          HtmlChA += "<link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\">\n";
1274          HtmlChA += "</head><body>\n";
1275          if (ReportType == "related") {
1276              TStr ReportSubType = HttpRqUrlEnv->GetVal("subtype", 0, "all");
1277              const bool ProbP = ((ReportSubType == "all") || (ReportSubType == "prob"));
1278              const bool TextP = ((ReportSubType == "all") || (ReportSubType == "text"));
1279              TStr MxEventsStr = HttpRqUrlEnv->GetVal("events", 0, "");
1280              const int MxEvents = MxEventsStr.IsInt() ? MxEventsStr.GetInt() : 1000;
1281              TStr MnSeverityStr = HttpRqUrlEnv->GetVal("mnseverity", 0, "");
1282              const int MnSeverity = MnSeverityStr.IsInt() ? MnSeverityStr.GetInt() : 3;
1283              int AllEvents = 0;
1284              TIntV AllScoresCountV, ProbScoresCountV, TextScoresCountV; 
1285              BtaCorrBs->GetRootCauseStat(BtaEventBs, MxEvents, MnSeverity,
1286                  RootCouseEventWnd, RootCouseTimeWnd, ProbP, TextP, 
1287                  AllScoresCountV, ProbScoresCountV, TextScoresCountV, 
1288                  AllEvents);
1289              HtmlChA += TStr::Fmt(
1290                  "<b>Number of severe events (Severity > %d):</b> %d<br>\n", 
1291                  MnSeverity, AllEvents);
1292              HtmlChA += "<hr>\n";
1293              HtmlChA += "<table><tr>";
1294              HtmlChA += "<td>#related</td>";
1295              HtmlChA += "<td>#all_alarms</td>";
1296              HtmlChA += "<td>#prob_alarms</td>";
1297              HtmlChA += "<td>#text_alarms</td>";
1298              HtmlChA += "</tr>\n";
1299              for (int ScoresCountN = 0; ScoresCountN < AllScoresCountV.Len(); ScoresCountN++) {
1300                  HtmlChA += "<tr>\n";
1301                  HtmlChA += TStr::Fmt("<td>%d</td>\n", ScoresCountN);
1302                  HtmlChA += TStr::Fmt("<td>%d</td>\n", AllScoresCountV[ScoresCountN].Val);
1303                  HtmlChA += TStr::Fmt("<td>%d</td>\n", ProbScoresCountV[ScoresCountN].Val);
1304                  HtmlChA += TStr::Fmt("<td>%d</td>\n", TextScoresCountV[ScoresCountN].Val);
1305                  HtmlChA += "</tr>\n";
1306              }
1307              HtmlChA += "</table>";
1308          }
1309  		HtmlChA += "</body></html>";
1310          printf("\n\n%s\n\n", HtmlChA.CStr());
1311  		PSIn BodySIn = TMIn::New(HtmlChA);
1312  		HttpResp = THttpResp::New(THttp::OkStatusCd, 
1313  			THttp::TextHtmlFldVal, false, BodySIn);
1314  	} else {
1315          TChA HtmlChA;
1316          HtmlChA += "<html><head>\n";
1317          HtmlChA += "<title>BT Alarms Explorer</title>\n";
1318          HtmlChA += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n";
1319          HtmlChA += "<link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\">\n";
1320          HtmlChA += "</head><body>\n";
1321          HtmlChA += "<form action=\"/search\"><b><a href=\"/events\">Alarms</a></b>, ";
1322          HtmlChA += "<b><a href=\"/long\">Long-Term Trends</a></b> | ";
1323          HtmlChA += "Search: <input maxLength=\"256\" size=\"23\" name=\"q\"";
1324          if (!HttpRqUrlEnv->GetVal("q", 0, "").Empty()) {
1325              HtmlChA += "value=\"" + HttpRqUrlEnv->GetVal("q", 0, "") + "\""; }
1326          HtmlChA += ">";
1327          HtmlChA += "<input type=submit name=\"type\" value=\"device\">\n";
1328          HtmlChA += "<input type=submit name=\"type\" value=\"project\">\n";
1329          HtmlChA += "</form>";
1330          HtmlChA += "<hr>\n";
1331          if (CmdNm.Empty() || CmdNm == "events") {
1332              TStr SortTypeStr = HttpRqUrlEnv->GetVal("sort", 0, "all");
1333              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1334              if (PageNumStr.IsInt()) {
1335                  const int PageNum = PageNumStr.GetInt();
1336                  if (SortTypeStr == "all") {           
1337                      MakeEventsPage(AllEventIdV, SortTypeStr, PageNum, HtmlChA);
1338                  } else if (SortTypeStr == "case_id") {
1339                      MakeEventsPage(CaseIdEventIdV, SortTypeStr, PageNum, HtmlChA);
1340                  } else {
1341                      printf("Wrong parameter sort '%s' ..;\n", SortTypeStr.CStr());
1342                  }
1343              } else {
1344                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1345              }
1346          } else if (CmdNm == "search") {
1347              TStr QueryStr = HttpRqUrlEnv->GetVal("q", 0, "");
1348              TStr TypeStr = HttpRqUrlEnv->GetVal("type", 0, "");
1349              if (!QueryStr.Empty() && !TypeStr.Empty()) {
1350                  bool SearchOkP = true;
1351                  if (TypeStr == "device") {
1352                      PBtaDevDefBs BtaDevDefBs = BtaEventBs->GetDevDefBs();
1353                      if (BtaDevDefBs->IsIpNumId(QueryStr)) {
1354                          const int IpNumId = BtaDevDefBs->GetIpNumId(QueryStr);
1355                          MakeIpNumPage(IpNumId, HtmlChA);
1356                      } else { SearchOkP = false; }
1357                  } else if (TypeStr == "project") {
1358                      PBtaDevDefBs BtaDevDefBs = BtaEventBs->GetDevDefBs();
1359                      if (BtaDevDefBs->IsProjId(QueryStr)) {
1360                          const int ProjId = BtaDevDefBs->GetProjId(QueryStr);
1361                          MakeProjectPage(ProjId, HtmlChA);
1362                      } else { SearchOkP = false; }
1363                  } else { SearchOkP = false; }
1364                  if (!SearchOkP) { HtmlChA += "<b>No results found, try again.</b>\n"; }
1365              } else { 
1366                  printf("Wrong parameter page '%s' and '%s' ..;\n", 
1367                      QueryStr.CStr(), TypeStr.CStr());
1368              }            
1369          } else if (CmdNm == "event") {
1370              TStr EventIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1371              if (EventIdStr.IsInt()) {
1372                  const int EventId = EventIdStr.GetInt();
1373                  MakeEventPage(EventId, HtmlChA);
1374              } else {
1375                  printf("Wrong parameter id '%s' ..;\n", EventIdStr.CStr());
1376              }
1377          } else if (CmdNm == "event_full") {
1378              TStr EventIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1379              if (EventIdStr.IsInt()) {
1380                  const int EventId = EventIdStr.GetInt();
1381                  MakeEventFullPage(EventId, HtmlChA);
1382              } else {
1383                  printf("Wrong parameter id '%s' ..;\n", EventIdStr.CStr());
1384              }
1385          } else if (CmdNm == "device") {
1386              TStr IpNumIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1387              if (IpNumIdStr.IsInt()) {
1388                  const int IpNumId = IpNumIdStr.GetInt();
1389                  MakeIpNumPage(IpNumId, HtmlChA);                
1390              } else {
1391                  printf("Wrong parameter id '%s' ..;\n", IpNumIdStr.CStr());
1392              }
1393          } else if (CmdNm == "project") {
1394              TStr ProjIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1395              if (ProjIdStr.IsInt()) {
1396                  const int ProjId = ProjIdStr.GetInt();
1397                  MakeProjectPage(ProjId, HtmlChA);
1398              } else {
1399                  printf("Wrong parameter id '%s' ..;\n", ProjIdStr.CStr());
1400              }
1401          } else if (CmdNm == "d_events") {
1402              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1403              TStr IpNumIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1404              if (!PageNumStr.IsInt()) {
1405                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1406              } else if (!IpNumIdStr.IsInt()) {
1407                  printf("Wrong parameter id '%s' ..;\n", IpNumIdStr.CStr());
1408              } else {              
1409                  const int PageNum = PageNumStr.GetInt();
1410                  const int IpNumId = IpNumIdStr.GetInt();
1411                  if (BtaCorrBs->IsIpNumId(IpNumId)) {
1412                      const TIntV& EventV = BtaCorrBs->GetIpNumEventV(IpNumId); 
1413                      MakeIpNumEventsPage(IpNumId, EventV, PageNum, HtmlChA);
1414                  }
1415              }
1416          } else if (CmdNm == "p_events") {
1417              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1418              TStr ProjIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1419              if (!PageNumStr.IsInt()) {
1420                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1421              } else if (!ProjIdStr.IsInt()) {
1422                  printf("Wrong parameter id '%s' ..;\n", ProjIdStr.CStr());
1423              } else {              
1424                  const int PageNum = PageNumStr.GetInt();
1425                  const int ProjId = ProjIdStr.GetInt();
1426                  if (BtaCorrBs->IsProjId(ProjId)) {
1427                      const TIntV& EventV = BtaCorrBs->GetProjEventV(ProjId); 
1428                      MakeProjEventsPage(ProjId, EventV, PageNum, HtmlChA);
1429                  }
1430              }
1431          } else if (CmdNm == "dd_events") {
1432              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1433              TStr IpNumIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1434              TStr CorrIpNumIdStr = HttpRqUrlEnv->GetVal("corrid", 0, "0");
1435              if (!PageNumStr.IsInt()) {
1436                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1437              } else if (!IpNumIdStr.IsInt()) {
1438                  printf("Wrong parameter id '%s' ..;\n", IpNumIdStr.CStr());
1439              } else if (!CorrIpNumIdStr.IsInt()) {
1440                  printf("Wrong parameter corrid '%s' ..;\n", CorrIpNumIdStr.CStr());
1441              } else {              
1442                  const int PageNum = PageNumStr.GetInt();
1443                  const int IpNumId = IpNumIdStr.GetInt();
1444                  const int CorrIpNumId = CorrIpNumIdStr.GetInt();
1445                  MakeIpNumCorrEventPage(IpNumId, CorrIpNumId, PageNum, HtmlChA);
1446              }
1447          } else if (CmdNm == "long") {
1448              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1449              if (PageNumStr.IsInt()) {
1450                  TStr PeriodStr = HttpRqUrlEnv->GetVal("period", 0, "week");
1451                  const int PageNum = PageNumStr.GetInt();
1452                  if (PeriodStr == "week") {
1453                      MakeLongPage(WeekChiSortProjIdV, PageNum, PeriodStr, HtmlChA);
1454                  } else if (PeriodStr == "month") {
1455                      MakeLongPage(MonthChiSortProjIdV, PageNum, PeriodStr, HtmlChA);
1456                  }
1457              } else {
1458                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1459              }
1460          } else if (CmdNm == "p_long") {
1461              TStr ProjIdStr = HttpRqUrlEnv->GetVal("id", 0, "0");
1462              TStr PageNumStr = HttpRqUrlEnv->GetVal("page", 0, "0");
1463              if (!PageNumStr.IsInt()) {
1464                  printf("Wrong parameter page '%s' ..;\n", PageNumStr.CStr());
1465              } else if (!ProjIdStr.IsInt()) {
1466                  printf("Wrong parameter id '%s' ..;\n", ProjIdStr.CStr());
1467              } else {              
1468                  TStr PeriodStr = HttpRqUrlEnv->GetVal("period", 0, "week");
1469                  const int PageNum = PageNumStr.GetInt();
1470                  const int ProjId = ProjIdStr.GetInt();
1471                  if (PeriodStr == "week") {
1472                      MakeProjLongPage(ProjId, PageNum, PeriodStr, HtmlChA);
1473                  } else if (PeriodStr == "month") {
1474                      MakeProjLongPage(ProjId, PageNum, PeriodStr, HtmlChA);
1475                  }
1476              }
1477          }
1478          HtmlChA += "</body></html>";
1479          PSIn BodySIn = TMIn::New(HtmlChA);
1480          HttpResp = THttpResp::New(THttp::OkStatusCd, 
1481              THttp::TextHtmlFldVal, false, BodySIn);
1482      }
1483      SendHttpResp(SockId, HttpResp);
1484  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Buffer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-btaserver.cpp</div>
                </div>
                <div class="column column_space"><pre><code>123  	NppParameters& nppParamInst = NppParameters::getInstance();
124  	if (_fullPathName == fn)
125  	{
126  		updateTimeStamp();
127  		doNotify(BufferChangeTimestamp);
128  		return;
129  	}
130  	_fullPathName = fn;
131  	_fileName = PathFindFileName(_fullPathName.c_str());
132  	LangType determinatedLang = L_TEXT;
133  	TCHAR *ext = PathFindExtension(_fullPathName.c_str());
</pre></code></div>
                <div class="column column_space"><pre><code>437      const int CurrProjId = Event.GetProjId();
438      TIntFltH IpNumIdProbH;
439      BtaCorrBs->GetNextIpNumIdProb(EventId, 
440          CurrProjId, BtaEventBs, 100, 600, IpNumIdProbH);
441      if (IpNumIdProbH.Empty()) { return; }
442      TFltIntPrV ProbIpNumIdV; IpNumIdProbH.GetDatKeyPrV(ProbIpNumIdV); ProbIpNumIdV.Sort(false);
443      HtmlChA += "<table border=\"1\">\n";
444      HtmlChA += "<tr>";
445      HtmlChA += "<td>#</td>";
446      HtmlChA += "<td>Device</td>";
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    