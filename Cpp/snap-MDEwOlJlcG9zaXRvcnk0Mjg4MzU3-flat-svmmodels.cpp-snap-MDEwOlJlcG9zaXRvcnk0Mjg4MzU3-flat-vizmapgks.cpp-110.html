
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</h3>
            <pre><code>1  void TCrossValid::PrepareFolds(const int&amp; Folds, TIntV&amp; DIdV,
2          const int&amp; Seed, TVec&lt;TIntV&gt;&amp; DIdVFoldV) {
3      IAssert(Folds &gt; 1);
4      IAssertR(DIdV.Len()/Folds &gt; 1,
5          TStr::Fmt(&quot;To little documents per fold (%d/%d)&quot;, DIdV.Len(), Folds));
6      DIdVFoldV.Gen(Folds);
7      const int Len = DIdV.Len();
8      for (int FoldN = 0; FoldN &lt; Folds; FoldN++)
9          DIdVFoldV[FoldN].Gen(Len/Folds, 0);
10      int DocN = 0;
11      TRnd Rnd(Seed); DIdV.Shuffle(Rnd);
12      while (DocN &lt; Len) {
13          int FoldN = 0;
14          while (DocN &lt; Len &amp;&amp; FoldN &lt; Folds) {
15              DIdVFoldV[FoldN].Add(DIdV[DocN]);
16              FoldN++; DocN++;
17          }
18      }
19      DIdV.Sort();
20      for (int FoldN = 0; FoldN &lt; Folds; FoldN++) {
21          DIdVFoldV[FoldN].Sort();
22      }
23  }
24  void TCrossValid::PrepareSplit(const int&amp; FoldN, const TVec&lt;TIntV&gt;&amp; DIdVFoldV,
25                                 TIntV&amp; TrainSubDIdV, TIntV&amp; TestSubDIdV) {
26      TrainSubDIdV.Clr(); TestSubDIdV.Clr();
27      for (int n = 0; n &lt; DIdVFoldV.Len(); n++) {
28          if (n == FoldN) {
29              TestSubDIdV.AddV(DIdVFoldV[n]);
30          } else {
31              TrainSubDIdV.AddV(DIdVFoldV[n]);
32          }
33      }
34      TrainSubDIdV.Sort(); TestSubDIdV.Sort();
35  }
36  void TCrossValid::PrepareSubDIdV(const TIntV&amp; SubSet, const int&amp; DataSetLen, TIntV&amp; DIdV) {
37      if (SubSet.Empty()) {
38          DIdV.Gen(DataSetLen, 0);
39          for (int i = 0; i &lt; DataSetLen; i++) DIdV.Add(i);
40      } else {
41          DIdV = SubSet;
42      }
43  }
44  bool TSparseTrainSet::IsReg=TSparseTrainSet::MkReg();
45  TSparseTrainSet::TSparseTrainSet(const TIntV&amp; VecIdV, const int&amp; _MaxDim, const TFltV&amp; _ClsV,
46          const TFltV&amp; _NormV, const TVec&lt;TIntFltKdV&gt;&amp; _TrainV): TSVMTrainSet(ststSparse) {
47      if (VecIdV.Empty()) {
48          MaxDim = _MaxDim; ClsV = _ClsV;
49          NormV = _NormV; TrainV = _TrainV;
50      } else {
51          MaxDim = _MaxDim;
52          const int Vecs = VecIdV.Len();
53          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
54          for (int VecN = 0; VecN &lt; Vecs; VecN++) {
55              const int VecId = VecIdV[VecN];
56              ClsV.Add(_ClsV[VecId]);
57              NormV.Add(_NormV[VecId]);
58              TrainV.Add(_TrainV[VecId]);
59          }
60      }
61  }
62  void TSparseTrainSet::SaveTxt(const TStr&amp; OutFNm) const {
63      PSOut SOut = TFOut::New(OutFNm);
64      for (int VecN = 0; VecN &lt; TrainV.Len(); VecN++) {
65          const TIntFltKdV&amp; AttrV = TrainV[VecN];
66          SOut-&gt;PutStr(TStr::Fmt(&quot;%f&quot;, GetVecParam(VecN)));
67          for (int a = 0; a &lt; AttrV.Len(); a++) {
68              SOut-&gt;PutStr(TStr::Fmt(&quot; %d:%f&quot;, AttrV[a].Key(), AttrV[a].Dat()));
69          }
70          SOut-&gt;PutLn();
71      }
72      SOut-&gt;Flush();
73  }
74  void TSparseTrainSet::SaveMatlab(const TStr&amp; FName) const {
75      PSOut out = TFOut::New(FName);
76      int ColN = Len();
77      for (int ColId = 0; ColId &lt; ColN; ColId++) {
78          const TIntFltKdV&amp; Vec = TrainV[ColId];
79          for (int RowId = 0, RowN = Vec.Len(); RowId &lt; RowN; RowId++) {
80              out-&gt;PutStr(TInt::GetStr(Vec[RowId].Key + 1) + TStr(&quot; &quot;) + TInt::GetStr(ColId + 1) + TStr(&quot; &quot;));
81              out-&gt;PutStr(TFlt::GetStr(Vec[RowId].Dat, 20, 18));
82              out-&gt;PutCh(&#x27;\n&#x27;);
83          }
84      }
85  }
86  double TSparseTrainSet::DotProduct(const int&amp; VecId1, double* vec2, const int&amp; n) const {
87      double Res = 0.0;
88      const TIntFltKdV&amp; V1 = TrainV[VecId1];
89      for (int i = 0; i &lt; V1.Len(); i++) {
90          const int key = V1[i].Key;
91          if (key &lt; n) Res += V1[i].Dat * vec2[key];
92      }
93      return Res;
94  }
95  void TSparseTrainSet::AddVec(const int&amp; VecId1, double* vec2,
96          const int&amp; n, const double&amp; K) const {
97      const TIntFltKdV&amp; V1 = TrainV[VecId1];
98      for (int i = 0; i &lt; V1.Len(); i++) {
99          Assert(V1[i].Key &lt; n);
100          vec2[V1[i].Key] += K * V1[i].Dat;
101      }
102  }
103  int TSparseTrainSet::AddAttrV(const TIntFltKdV&amp; AttrV,
104          const double&amp; Cls, const bool&amp; Normalize) {
105      double Norm = TLinAlg::Norm2(AttrV);
106      IAssertR(Norm &gt;= 0.0, TStr::Fmt(&quot;%g (len = %d)&quot;, Norm, AttrV.Len()));
107      NormV.Add(Norm); TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
108      if (AttrV.Empty()) {
109          TrainV.Last().Add(TIntFltKd(1, 0.0));
110      } else {
111          MaxDim = TInt::GetMx(int(MaxDim), AttrV.Last().Key+1);
112          if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
113      }
114      return TrainV.Len()-1;
115  }
116  void TSparseTrainSet::Shuffle(TRnd&amp; Rnd) {
117      const int Vals = TrainV.Len();
118      for (int ValN=0; ValN&lt;Vals-1; ValN++) {
119          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
120          TrainV.Swap(ValN, NewValN);
121          ClsV.Swap(ValN, NewValN);
122          NormV.Swap(ValN, NewValN);
123      }
124  }
125  PSVMTrainSet TSparseTrainSet::LoadTxt(PSIn SIn, const bool&amp; Normalize, const int&amp; verbosity) {
126      TMem buffer;
127      TMem::LoadMem(SIn, buffer);
128      if (buffer[buffer.Len()-1] != &#x27;\n&#x27;) buffer += &#x27;\n&#x27;;  
129      int len = buffer.Len(), n = 0;
130      char ch, *s; int vecsP = 0, vecsM = 0, line = 0;
131      double cls; TIntFltKdV vec;
132      PSVMTrainSet docs = TSparseTrainSet::New();
133      if (len == 0) return docs;
134      ch = buffer[n++];
135      while (n &lt; len) {
136          line++;
137          vec.Clr(false);
138          if (ch != &#x27;#&#x27;) {
139              while (ch == &#x27; &#x27;) ch = buffer[n++]; 
140              TChA clsChA;
141              while (ch != &#x27; &#x27; &amp;&amp; ch != &#x27;\r&#x27; &amp;&amp; ch != &#x27;\n&#x27;) {
142                  clsChA += ch;
143                  ch = buffer[n++];
144              }
145              if (clsChA.Len() &gt; 0) {
146                  cls = strtod(clsChA.CStr(), &amp;s);
147                  int part = 0;
148                  TChA idChA, valChA;
149                  while (ch != &#x27;\r&#x27; &amp;&amp; ch != &#x27;\n&#x27; &amp;&amp; ch != &#x27;#&#x27;) {
150                      if (part == 0 &amp;&amp; ch == &#x27; &#x27;) {
151                      } else if (part == 0 &amp;&amp; ch != &#x27; &#x27;) {
152                          part = 1;     
153                          Assert(&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;);
154                          idChA += ch;
155                      } else if (part == 1 &amp;&amp; ch != &#x27;:&#x27;) {
156                          Assert(&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;);
157                          idChA += ch;  
158                      } else if (part == 1 &amp;&amp; ch == &#x27;:&#x27;) {
159                          part = 2;     
160                      } else if (part == 2 &amp;&amp; ch != &#x27; &#x27;) {
161                          Assert((&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;) || ch == &#x27;.&#x27;);
162                          valChA += ch; 
163                      } else if (part == 2 &amp;&amp; ch == &#x27; &#x27;) {
164                          int id = strtol(idChA.CStr(), &amp;s, 10);
165                          double val = strtod(valChA.CStr(), &amp;s);
166                          vec.Add(TIntFltKd(id, val));
167                          idChA.Clr(); valChA.Clr();
168                          part = 0;
169                      } else {
170                          printf(&quot;error in %d, unexpected charater %c!\n&quot;, line, ch);
171                          Assert(false);
172                      }
173                      ch = buffer[n++];
174                      if (part == 2 &amp;&amp; (ch == &#x27;\r&#x27; || ch == &#x27;\n&#x27; || ch == &#x27;#&#x27;)) {
175                          int id = strtol(idChA.CStr(), &amp;s, 10);
176                          double val = strtod(valChA.CStr(), &amp;s);
177                          vec.Add(TIntFltKd(id, val));
178                          idChA.Clr(); valChA.Clr();
179                          part = 0;
180                      }
181                  } 
182                  if (part != 0) printf(&quot;unexpected end of line %d\n&quot;, line);
183                  Assert(part == 0); 
184                  docs-&gt;AddAttrV(vec, cls, Normalize);
185                  if (cls &gt; 0) vecsP++;
186                  else vecsM++;
187                  if (verbosity &gt; 0 &amp;&amp; (vecsP + vecsM)%100 == 0) printf(&quot;%d\r&quot;, vecsP + vecsM);
188                  while (ch != &#x27;\n&#x27;) ch = buffer[n++]; 
189              }
190          } else {
191              while (ch != &#x27;\n&#x27;) ch = buffer[n++];
192          }
193          if (n &lt; len) ch = buffer[n++];
194      }
195      printf(&quot;\n&quot;);
196      if (verbosity &gt; 1)
197          printf(&quot;\ninput: %d = %d + %d vectors\n&quot;, vecsP + vecsM, vecsP, vecsM);
198      else if (verbosity &gt; 0)
199          printf(&quot;\n&quot;);
200      return docs;
201  }
202  bool TDenseTrainSet::IsReg=TDenseTrainSet::MkReg();
203  TDenseTrainSet::TDenseTrainSet(const TIntV&amp; VecIdV, const int&amp; _MaxDim, const TFltV&amp; _ClsV,
204          const TFltV&amp; _NormV, const TVec&lt;TFltV&gt;&amp; _TrainV): TSVMTrainSet(ststDense) {
205      if (VecIdV.Empty()) {
206          MaxDim = _MaxDim; ClsV = _ClsV;
207          NormV = _NormV; TrainV = _TrainV;
208      } else {
209          MaxDim = _MaxDim;
210          const int Vecs = VecIdV.Len();
211          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
212          for (int VecN = 0; VecN &lt; Vecs; VecN++) {
213              const int VecId = VecIdV[VecN];
214              ClsV.Add(_ClsV[VecId]);
215              NormV.Add(_NormV[VecId]);
216              TrainV.Add(_TrainV[VecId]);
217          }
218      }
219  }
220  PSVMTrainSet TDenseTrainSet::LoadFromSparse(PSVMTrainSet SparseSet) {
221      const int Vecs = SparseSet-&gt;Len();
222      const int Dims = SparseSet-&gt;Dim();
223      PSVMTrainSet DenseSet = TDenseTrainSet::New(Vecs);
224      TFltV AttrDenseV(Dims);
225      for (int VecN = 0; VecN &lt; SparseSet-&gt;Len(); VecN++) {
226          const TIntFltKdV&amp; AttrSparseV = SparseSet-&gt;GetAttrSparseV(VecN);
227          AttrDenseV.PutAll(0.0);
228          TLinAlg::AddVec(1.0, AttrSparseV, AttrDenseV);
229          DenseSet-&gt;AddAttrV(AttrDenseV, SparseSet-&gt;GetVecParam(VecN), false);
230      }
231      return DenseSet;
232  }
233  void TDenseTrainSet::SaveTxt(const TStr&amp; OutFNm) const {
234      PSOut SOut = TFOut::New(OutFNm);
235      for (int VecN = 0; VecN &lt; TrainV.Len(); VecN++) {
236          const TFltV&amp; AttrV = TrainV[VecN];
237          SOut-&gt;PutStr(TStr::Fmt(&quot;%f&quot;, GetVecParam(VecN)));
238          for (int a = 0; a &lt; AttrV.Len(); a++) {
239              SOut-&gt;PutStr(TStr::Fmt(&quot; %d:%f&quot;, a+1, AttrV[a]()));
240          }
241          SOut-&gt;PutLn();
242      }
243      SOut-&gt;Flush();
244  }
245  int TDenseTrainSet::AddAttrV(const TFltV&amp; AttrV, const double&amp; Cls, const bool&amp; Normalize) {
246      IAssert(!AttrV.Empty());
247      IAssert(MaxDim == 0 || AttrV.Len() == MaxDim);
248      MaxDim = AttrV.Len();
249      double Norm = TLinAlg::Norm2(AttrV); NormV.Add(Norm);
250      TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
251      if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
252      return TrainV.Len()-1;
253  }
254  double TDenseTrainSet::DotProduct(const int&amp; VecId1, double* vec2, const int&amp; n) const {
255      IAssert(n == MaxDim);
256      const TFltV&amp; V1 = TrainV[VecId1];
257      double Res = V1[0]*vec2[0];
258      for (int i = 1; i &lt; MaxDim; i++)
259          Res += V1[i]*vec2[i];
260      return Res;
261  }
262  void TDenseTrainSet::AddVec(const int&amp; VecId1, double* vec2,
263                              const int&amp; n, const double&amp; K) const {
264      IAssert(n == MaxDim);
265      const TFltV&amp; V1 = TrainV[VecId1];
266      for (int i = 0; i &lt; MaxDim; i++)
267          vec2[i] += K*V1[i];
268  }
269  void TDenseTrainSet::Shuffle(TRnd&amp; Rnd) {
270      const int Vals = TrainV.Len();
271      for (int ValN=0; ValN&lt;Vals-1; ValN++) {
272          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
273          TrainV.Swap(ValN, NewValN);
274          ClsV.Swap(ValN, NewValN);
275          NormV.Swap(ValN, NewValN);
276      }
277  }
278  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
279          const TFltVV&amp; Basis, const bool&amp; Normalize, const int&amp; NewDim) {
280      IAssert(NewDim == -1 || (NewDim &gt;= 0 &amp;&amp; NewDim &lt;= Basis.GetYDim()));
281      const int Dim = (NewDim == -1) ? Basis.GetYDim() : NewDim; 
282      const int Len = Basis.GetXDim();
283      TVec&lt;TFltV&gt; NewBasis(Dim);
284      for (int VecC = 0; VecC &lt; Dim; VecC++) {
285          NewBasis[VecC].Gen(Len,0);
286          for (int i = 0; i &lt; Len; i++) {
287              NewBasis[VecC].Add(Basis(i, VecC));
288          }
289      }
290      return ProjectLin(Set, NewBasis, Normalize);
291  }
292  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
293          const TVec&lt;TFltV&gt;&amp; Basis, const bool&amp; Normalize, const int&amp; NewDim) {
294      IAssert(NewDim == -1 || (NewDim &gt;= 0 &amp;&amp; NewDim &lt;= Basis.Len()));
295      const int VecN = Set-&gt;Len(); 
296      const int Dim = (NewDim == -1) ? Basis.Len() : NewDim; 
297      PSVMTrainSet NewSet = TDenseTrainSet::New(VecN);
298      for (int VecC = 0; VecC &lt; VecN; VecC++) {
299          if (VecC % 100 == 0) printf(&quot;%d\r&quot;, VecC);
300          TFltV Vec(Dim, 0);
301          for (int i = 0; i &lt; Dim; i++) {
302              Vec.Add(Set-&gt;DotProduct(VecC, Basis[i]));
303          }
304          NewSet-&gt;AddAttrV(Vec, Set-&gt;GetVecParam(VecC), Normalize);
305      }
306      printf(&quot;\n&quot;);
307      return NewSet;
308  }
309  bool TBowTrainSet::IsReg=TBowTrainSet::MkReg();
310  TBowTrainSet::TBowTrainSet(const TIntV&amp; VecIdV, const int&amp; _MaxDim, const TIntV&amp; _DIdV,
311          const TVec&lt;PBowSpV&gt;&amp; _TrainV, const TFltV&amp; _ClsV): TSVMTrainSet(ststBow) {
312      if (VecIdV.Empty()) {
313          MaxDim = _MaxDim; DIdV = _DIdV;
314          TrainV = _TrainV; ClsV = _ClsV;
315      } else {
316          MaxDim = _MaxDim;
317          const int Vecs = VecIdV.Len();
318          DIdV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0); ClsV.Gen(Vecs, 0);
319          for (int VecN = 0; VecN &lt; Vecs; VecN++) {
320              const int VecId = VecIdV[VecN];
321              DIdV.Add(_DIdV[VecId]);
322              TrainV.Add(_TrainV[VecId]);
323              ClsV.Add(_ClsV[VecId]);
324          }
325      }
326  }
327  void TBowTrainSet::SaveTxt(const TStr&amp; OutFNm) const {
328      PSOut SOut = TFOut::New(OutFNm);
329      for (int VecN = 0; VecN &lt; TrainV.Len(); VecN++) {
330          PBowSpV AttrV = TrainV[VecN];
331          SOut-&gt;PutStr(TStr::Fmt(&quot;%f&quot;, GetVecParam(VecN)));
332          for (int a = 0; a &lt; AttrV-&gt;Len(); a++) {
333              SOut-&gt;PutStr(TStr::Fmt(&quot; %d:%f&quot;, AttrV-&gt;GetWId(a), AttrV-&gt;GetWgt(a).Val));
334          }
335          SOut-&gt;PutLn();
336      }
337      SOut-&gt;Flush();
338  }
339  double TBowTrainSet::DotProduct(const int&amp; VecId1, double* vec2, const int&amp; n) const {
340      double res = 0.0;
341      TBowWIdWgtKd* vec1 = TrainV[VecId1]-&gt;BegI();
342      int len1 = TrainV[VecId1]-&gt;Len();
343      for (int i = 0; i &lt; len1; i++) {
344          Assert(vec1[i].Key &lt; n);
345          res += vec2[vec1[i].Key] * vec1[i].Dat;
346      }
347      return res;
348  }
349  void TBowTrainSet::AddVec(const int&amp; VecId1, double* vec2,
350                            const int&amp; n, const double&amp; K) const {
351      TBowWIdWgtKd* vec1 = TrainV[VecId1]-&gt;BegI();
352      int len1 = TrainV[VecId1]-&gt;Len();
353      for (int i = 0; i &lt; len1; i++) {
354          Assert(vec1[i].Key &lt; n);
355          vec2[vec1[i].Key] += K * vec1[i].Dat;
356      }
357  }
358  void TBowTrainSet::AddVec(const int&amp; VecId1, TFltV&amp; vec2, const double&amp; K) const {
359      PBowSpV vec1 = TrainV[VecId1]; int len1 = vec1-&gt;Len();
360      for (int i = 0; i &lt; len1; i++) {
361          Assert(vec1-&gt;GetWId(i) &lt; vec2.Len());
362          vec2[vec1-&gt;GetWId(i)] += K * vec1-&gt;GetWgt(i);
363      }
364  }
365  int TBowTrainSet::AddAttrV(const int&amp; DId, PBowSpV SpVec, const double&amp; Cls) {
366      DIdV.Add(DId); TrainV.Add(SpVec); ClsV.Add(Cls);
367      if (SpVec-&gt;GetWIds() &gt; 0) {
368          int VecDim = SpVec-&gt;GetWId(SpVec-&gt;GetWIds()-1);
369          MaxDim = MaxDim &gt; VecDim ? MaxDim() : VecDim + 1;
370      }
371      return TrainV.Len()-1;
372  }
373  void TBowTrainSet::Shuffle(TRnd&amp; Rnd) {
374      const int Vals = TrainV.Len();
375      for (int ValN=0; ValN&lt;Vals-1; ValN++) {
376          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
377          DIdV.Swap(ValN, NewValN);
378          TrainV.Swap(ValN, NewValN);
379          ClsV.Swap(ValN, NewValN);
380      }
381  }
382  bool TStringTrainSet::IsReg=TStringTrainSet::MkReg();
383  void TStringTrainSet::UpdateAlphN(const TIntV&amp; Vec) {
384      for (int i = 0, l = Vec.Len(); i &lt; l; i++)
385          AlphN = TInt::GetMx(AlphN, Vec[i]+1);
386      StrKer-&gt;UpdateAlphN(AlphN);
387  }
388  TStringTrainSet::TStringTrainSet(const TIntV&amp; VecIdV, const TFltV&amp; _ClsV,
389          const TFltV&amp; _NormV, const TVec&lt;TIntV&gt;&amp; _TrainV, PStrParser _Parser,
390          const int&amp; _AlphN, PStringKernel _StrKer): TSVMTrainSet(ststString) {
391      if (VecIdV.Empty()) {
392          ClsV = _ClsV; NormV = _NormV; TrainV = _TrainV;
393          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
394      } else {
395          const int Vecs = VecIdV.Len();
396          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
397          for (int VecN = 0; VecN &lt; Vecs; VecN++) {
398              const int VecId = VecIdV[VecN];
399              ClsV.Add(_ClsV[VecId]);
400              NormV.Add(_NormV[VecId]);
401              TrainV.Add(_TrainV[VecId]);
402          }
403          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
404      }
405      printf(&quot;AlphN = [%d =&gt; %d]\n&quot;, _AlphN, AlphN.Val);
406  }
407  int TStringTrainSet::AddAttrV(const TStr&amp; AttrV, const double&amp; Cls) {
408      TIntV ParsedAttrV; Parser-&gt;ProcessDocStr(AttrV, ParsedAttrV);
409      return AddAttrV(ParsedAttrV, Cls);
410  }
411  int TStringTrainSet::AddAttrV(const TIntV&amp; AttrV, const double&amp; Cls) {
412      IAssert(!AttrV.Empty());
413      UpdateAlphN(AttrV);
414      const double Norm = StrKer-&gt;CalcKernel(AttrV, AttrV);
415      ClsV.Add(Cls); NormV.Add(Norm);
416      TrainV.Add(AttrV); TrainV.Last().Pack();
417      return TrainV.Len()-1;
418  }
419  double TStringTrainSet::DotProduct(const int&amp; VecId1, const TStr&amp; Vec2) const {
420      TIntV ParsedVec2; Parser-&gt;ProcessDocStr(Vec2, ParsedVec2);
421      return DotProduct(VecId1, ParsedVec2);
422  }
423  double TStringTrainSet::DotProduct(const int&amp; VecId1, const TIntV&amp; Vec2) const {
424      const double Norm = StrKer-&gt;CalcKernel(Vec2, Vec2);
425      return StrKer-&gt;CalcKernel(TrainV[VecId1],Vec2) / sqrt(NormV[VecId1]*Norm);
426  }
427  void TStringTrainSet::Shuffle(TRnd&amp; Rnd) {
428      const int Vals = TrainV.Len();
429      for (int ValN=0; ValN&lt;Vals-1; ValN++) {
430          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
431          TrainV.Swap(ValN, NewValN);
432          ClsV.Swap(ValN, NewValN);
433          NormV.Swap(ValN, NewValN);
434      }
435  }
436  TSimMatrixTrainSet::TSimMatrixTrainSet(const TIntV&amp; VecIdV,
437          const TFltV&amp; _ClsV, const TFltVV&amp; _SimMatrix): TSVMTrainSet(ststSimMatrix) {
438      const int Vecs = VecIdV.Len();
439      SimMatrix.Gen(Vecs, Vecs); ClsV.Gen(Vecs, 0);
440      for (int i = 0; i &lt; Vecs; i++) {
441          const int VecId1 = VecIdV[i];
442          ClsV.Add(_ClsV[VecId1]);
443          for (int j = 0; j &lt; Vecs; j++) {
444              const int VecId2 = VecIdV[j];
445              SimMatrix(i, j) = _SimMatrix(VecId1, VecId2);
446          }
447      }
448  }
449  TSimMatrixTrainSet::TSimMatrixTrainSet(const TFltVV&amp; _SimMatrix,
450          const TFltV&amp; _ClsV): TSVMTrainSet(ststSimMatrix), SimMatrix(_SimMatrix) {
451      if (_ClsV.Empty()) {
452          ClsV.Gen(SimMatrix.GetXDim());
453          ClsV.PutAll(0.0);
454      } else {
455          ClsV = _ClsV;
456          Assert(ClsV.Len() == SimMatrix.GetXDim());
457      }
458  }
459  void TBowDocBs2TrainSet::MakeSpVec(PBowSpV BowVec, TIntFltKdV&amp; SpVec) {
460      const int BowVecLen = BowVec-&gt;GetWIds(); SpVec.Gen(BowVecLen, 0);
461      for (int WgtC = 0, WgtN = BowVecLen; WgtC &lt; WgtN; WgtC++) {
462          SpVec.Add(TIntFltKd(BowVec-&gt;GetWId(WgtC), BowVec-&gt;GetWgt(WgtC).Val));
463      }
464  }
465  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(
466          const TVec&lt;PBowSpV&gt;&amp; BowSpV, const double&amp; DefParam) {
467      int DocN = BowSpV.Len();
468      PSVMTrainSet docs = TBowTrainSet::New(DocN);
469      for (int DocC = 0; DocC &lt; DocN; DocC++) {
470          docs-&gt;AddAttrV(DocC, BowSpV[DocC], DefParam);
471      }
472      return docs;
473  }
474  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(PBowDocWgtBs BowDocWgtBs,
475          const TIntV&amp; DIdV, const double&amp; DefParam) {
476      int DocN = DIdV.Len();
477      PSVMTrainSet docs = TBowTrainSet::New(DocN);
478      for (int DocC = 0; DocC &lt; DocN; DocC++) {
479          int DId = DIdV[DocC];
480          PBowSpV SpV = BowDocWgtBs-&gt;GetSpV(DId);
481          docs-&gt;AddAttrV(DId, SpV, DefParam);
482      }
483      return docs;
484  }
485  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(
486          const TVec&lt;PBowSpV&gt;&amp; BowSpV, const double&amp; DefParam) {
487      int DocN = BowSpV.Len();
488      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
489      for (int DocC = 0; DocC &lt; DocN; DocC++) {
490          MakeSpVec(BowSpV[DocC], SpVec);
491          Set-&gt;AddAttrV(SpVec, DefParam, false);
492      }
493      return Set;
494  }
495  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(PBowDocWgtBs BowDocWgtBs,
496          const TIntV&amp; DIdV, const double&amp; DefParam) {
497      int DocN=DIdV.Len();
498      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
499      for (int DocC = 0; DocC &lt; DocN; DocC++) {
500          int DId = DIdV[DocC];
501          MakeSpVec(BowDocWgtBs-&gt;GetSpV(DId), SpVec);
502          Set-&gt;AddAttrV(SpVec, DefParam, false);
503      }
504      return Set;
505  }
506  PSVMTrainSet TBowDocBs2TrainSet::NewBowOneCat(const PBowDocBs&amp; BowDocBs,
507          PBowDocWgtBs BowDocWgtBs, const int&amp; CatId, const TIntV&amp; DIdV) {
508      int DocN = DIdV.Len();
509      PSVMTrainSet docs = TBowTrainSet::New(DocN);
510      for (int DocC = 0; DocC &lt; DocN; DocC++) {
511          int DId = DIdV[DocC];
512          if (BowDocBs-&gt;IsCatInDoc(DId, CatId)) {
513              PBowSpV SpV = BowDocWgtBs-&gt;GetSpV(DId);
514              docs-&gt;AddAttrV(DId, SpV, 1.0);
515          }
516      }
517      return docs;
518  }
519  PSVMTrainSet TBowDocBs2TrainSet::NewSparseOneCat(const PBowDocBs&amp; BowDocBs,
520          PBowDocWgtBs BowDocWgtBs, const int&amp; CatId, const TIntV&amp; DIdV) {
521      int DocN=DIdV.Len();
522      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
523      for (int DocC = 0; DocC &lt; DocN; DocC++) {
524          int DId = DIdV[DocC];
525          if (BowDocBs-&gt;IsCatInDoc(DId, CatId)) {
526              MakeSpVec(BowDocWgtBs-&gt;GetSpV(DId), SpVec);
527              Set-&gt;AddAttrV(SpVec, 1.0, false);
528          }
529      }
530      return Set;
531  }
532  PSVMTrainSet TBowDocBs2TrainSet::NewStringOneCat(const PBowDocBs&amp; BowDocBs,
533          const int&amp; CatId, const TIntV&amp; DIdV, PStrParser Parser, PStringKernel StrKer) {
534      int DocN=DIdV.Len();
535      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
536      for (int DocC = 0; DocC &lt; DocN; DocC++) {
537          int DId = DIdV[DocC];
538          if (BowDocBs-&gt;IsCatInDoc(DId, CatId)) {
539              TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
540              Set-&gt;AddAttrV(DocStr, 1.0);
541          }
542      }
543      return Set;
544  }
545  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCat(const PBowDocBs&amp; BowDocBs,
546          PBowDocWgtBs BowDocWgtBs, const int&amp; CatId, const TIntV&amp; DIdV,
547          const double&amp; SampleNegP) {
548      int Docs = DIdV.Len();
549      TIntV PosDIdV, NegDIdV;
550      for (int DocN = 0; DocN &lt; Docs; DocN++) {
551          const int DId = DIdV[DocN];
552          if(BowDocBs-&gt;IsCatInDoc(DId, CatId)) {
553              PosDIdV.Add(DId);
554          } else {
555              NegDIdV.Add(DId);
556          }
557      }
558      const int SampleSize = TFlt::Round(PosDIdV.Len() * SampleNegP);
559      if ((SampleSize &gt; 0) &amp;&amp; (NegDIdV.Len() &gt; SampleSize)) {
560          TRnd Rnd(1); NegDIdV.Shuffle(Rnd); NegDIdV.Trunc(SampleSize);
561      }
562      PSVMTrainSet docs = TBowTrainSet::New(NegDIdV.Len() + PosDIdV.Len());
563      for (int PosDocN = 0; PosDocN &lt; PosDIdV.Len(); PosDocN++) {
564          const int DId = PosDIdV[PosDocN]; docs-&gt;AddAttrV(DId, BowDocWgtBs-&gt;GetSpV(DId), 1.0); }
565      for (int NegDocN = 0; NegDocN &lt; NegDIdV.Len(); NegDocN++) {
566          const int DId = NegDIdV[NegDocN]; docs-&gt;AddAttrV(DId, BowDocWgtBs-&gt;GetSpV(DId), -1.0); }
567      return docs;
568  }
569  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCat(const PBowDocBs&amp; BowDocBs,
570          PBowDocWgtBs BowDocWgtBs, const int&amp; CatId, const TIntV&amp; DIdV) {
571      int DocN = DIdV.Len();
572      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
573      for (int DocC = 0; DocC &lt; DocN; DocC++) {
574          int DId = DIdV[DocC];
575          double param = BowDocBs-&gt;IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
576          MakeSpVec(BowDocWgtBs-&gt;GetSpV(DId), SpVec);
577          Set-&gt;AddAttrV(SpVec, param, false);
578      }
579      return Set;
580  }
581  PSVMTrainSet TBowDocBs2TrainSet::NewStringAllCat(const PBowDocBs&amp; BowDocBs,
582          const int&amp; CatId, const TIntV&amp; DIdV, PStrParser Parser, PStringKernel StrKer) {
583      int DocN = DIdV.Len();
584      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
585      for (int DocC = 0; DocC &lt; DocN; DocC++) {
586          int DId = DIdV[DocC];
587          double DocParam = BowDocBs-&gt;IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
588          TStr DocStr = BowDocBs-&gt;GetDocStr(DId);
589          Set-&gt;AddAttrV(DocStr, DocParam);
590      }
591      return Set;
592  }
593  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCatV(PBowDocWgtBs BowDocWgtBs,
594          const TIntV&amp; AllDIdV, const TIntV&amp; CatDIdV) {
595      int DocN = AllDIdV.Len();
596      PSVMTrainSet docs = TBowTrainSet::New(DocN);
597      for (int DocC = 0; DocC &lt; DocN; DocC++) {
598          int DId = AllDIdV[DocC];
599          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
600          PBowSpV SpV = BowDocWgtBs-&gt;GetSpV(DId);
601          docs-&gt;AddAttrV(DId, SpV, param);
602      }
603      return docs;
604  }
605  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCatV(PBowDocWgtBs BowDocWgtBs,
606          const TIntV&amp; AllDIdV, const TIntV&amp; CatDIdV) {
607      int DocN = AllDIdV.Len();
608      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
609      for (int DocC = 0; DocC &lt; DocN; DocC++) {
610          int DId = AllDIdV[DocC];
611          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
612          MakeSpVec(BowDocWgtBs-&gt;GetSpV(DId), SpVec);
613          Set-&gt;AddAttrV(SpVec, param, false);
614      }
615      return Set;
616  }
617  PSVMTrainSet TBowDocBs2TrainSet::NewBowFromCat(const PBowDocBs&amp; BowDocBs,
618          PBowDocWgtBs BowDocWgtBs, const TIntV&amp; AllDIdV) {
619      Fail; return NULL;
620  }
621  PSVMTrainSet TBowDocBs2TrainSet::NewSparseFromCat(const PBowDocBs&amp; BowDocBs,
622          PBowDocWgtBs BowDocWgtBs, const TIntV&amp; AllDIdV) {
623      Fail; return NULL;
624  }
625  PSVMTrainSet TBowDocBs2TrainSet::NewBow(PBowDocPart BowDocPart) {
626      int Clusts = BowDocPart-&gt;GetClusts();
627      PSVMTrainSet Set = TBowTrainSet::New(Clusts);
628      for (int ClustN = 0; ClustN &lt; Clusts; ClustN++) {
629          IAssert(BowDocPart-&gt;GetClust(ClustN)-&gt;IsConceptSpV());
630          Set-&gt;AddAttrV(ClustN, BowDocPart-&gt;GetClust(ClustN)-&gt;GetConceptSpV(), 1.0);
631      }
632      return Set;
633  }
634  PSVMTrainSet TBowDocBs2TrainSet::NewSparse(PBowDocPart BowDocPart) {
635      int Clusts = BowDocPart-&gt;GetClusts();
636      PSVMTrainSet Set = TSparseTrainSet::New(Clusts); TIntFltKdV SpVec;
637      for (int ClustN = 0; ClustN &lt; Clusts; ClustN++) {
638          IAssert(BowDocPart-&gt;GetClust(ClustN)-&gt;IsConceptSpV());
639          MakeSpVec(BowDocPart-&gt;GetClust(ClustN)-&gt;GetConceptSpV(), SpVec);
640          Set-&gt;AddAttrV(SpVec, 1.0, false);
641      }
642      return Set;
643  }
644  PSVMModel TSVMModel::MakeModel(const bool&amp; Linear,
645          const PKernel&amp; ker, const PSVMTrainSet&amp; TrainSet,
646          const TIntV&amp; SubSet, const TSVMModelParam&amp; ModelParam,
647          const TSVMLearnParam&amp; LearnParam) {
648      PSVMModel Model = TSVMModel::New();
649      Model-&gt;Linear = Linear;
650      TIntV DIdV; int Len;
651      if (SubSet.Len() != 0) {
652          TSVMFactory::train(Model-&gt;AlphaV, Model-&gt;Thresh.Val, Linear, ker,
653              TSVMTrainSubSet::New(TrainSet(), SubSet), ModelParam, LearnParam);
654          DIdV = SubSet; Len = SubSet.Len();
655      } else {
656          TSVMFactory::train(Model-&gt;AlphaV, Model-&gt;Thresh.Val,
657              Linear, ker, TrainSet(), ModelParam, LearnParam);
658          Len = TrainSet-&gt;Len(); DIdV.Gen(Len);
659          for (int i = 0; i &lt; Len; i++) { DIdV[i] = i; }
660      }
661      if (ModelParam.ModelType == smtClassifier) {
662          for (int i = 0; i &lt; Len; i++) {
663              Model-&gt;AlphaV[i] = TrainSet-&gt;GetVecParam(DIdV[i]) * Model-&gt;AlphaV[i];
664          }
665      } else if (ModelParam.ModelType == smtRegression) {
666          IAssert(Model-&gt;AlphaV.Len() == 2*Len);
667          for (int i = 0; i &lt; Len; i++) {
668              Model-&gt;AlphaV[i] = Model-&gt;AlphaV[i+Len] - Model-&gt;AlphaV[i];
669          }
670          Model-&gt;AlphaV.Trunc(Len);
671          Model-&gt;Thresh = -1.0 * Model-&gt;Thresh;
672      }
673      if (Linear) {
674          TrainSet-&gt;LinComb(DIdV, Model-&gt;AlphaV, Model-&gt;WgtV);
675      } else {
676          if (TrainSet-&gt;Type() != ststSimMatrix) {
677              TFltV NewAlphaV; TIntV VecIdV;
678              for (int VecN = 0; VecN &lt; Len; VecN++) {
679                  if (TFlt::Abs(Model-&gt;AlphaV[VecN]) &gt; EPSILON) {
680                      NewAlphaV.Add(Model-&gt;AlphaV[VecN]);
681                      VecIdV.Add(DIdV[VecN]);
682                  }
683              }
684              Model-&gt;AlphaV = NewAlphaV; 
685              Model-&gt;SupVecs = TrainSet-&gt;Clone(VecIdV);
686          } else {
687              TFltV NewAlphaV(TrainSet-&gt;Len()); NewAlphaV.PutAll(0.0);
688              for (int VecN = 0; VecN &lt; Len; VecN++) {
689                  NewAlphaV[DIdV[VecN]] = Model-&gt;AlphaV[VecN];
690              }
691              Model-&gt;AlphaV = NewAlphaV; 
692              Model-&gt;SupVecs = TrainSet;
693          }
694          Model-&gt;Kernel = ker;
695      }
696      Model-&gt;AlphaV.Pack();
697      return Model;
698  }
699  TCfyRes TSVMModel::CrossValidation(const int&amp; Folds, const int&amp;Seed, const bool&amp; Linear,
700          const PKernel&amp; ker, const PSVMTrainSet&amp; TrainSet, const TIntV&amp; SubSet,
701          const TSVMModelParam&amp; ModelParam, const TSVMLearnParam&amp; LearnParam) {
702      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet-&gt;Len(), DIdV);
703      TVec&lt;TIntV&gt; DIdVFoldV; TCrossValid::PrepareFolds(Folds, DIdV, Seed, DIdVFoldV);
704      TIntV TrainSubDIdV, TestSubDIdV; TCfyRes CfyRes;
705      double MarginSum = 0.0;
706      for (int FoldN = 0; FoldN &lt; Folds; FoldN++) {
707          printf(&quot;%d.. &quot;, FoldN);
708          TCrossValid::PrepareSplit(FoldN, DIdVFoldV, TrainSubDIdV, TestSubDIdV);
709          if (ModelParam.ModelType == smtOneClass) {
710              TIntV PosTrainSubDIdV;
711              for (int DIdN = 0; DIdN &lt; TrainSubDIdV.Len(); DIdN++) {
712                  const int DId = TrainSubDIdV[DIdN];
713                  if (TrainSet-&gt;GetVecParam(DId) &gt; 0.0) {
714                      PosTrainSubDIdV.Add(DId);
715                  }
716              }
717              TrainSubDIdV = PosTrainSubDIdV;
718          }
719          PSVMModel FoldModel = MakeModel(Linear, ker,
720              TrainSet, TrainSubDIdV, ModelParam, LearnParam);
721          TCfyRes FoldCfyRes = FoldModel-&gt;Test(TrainSet, TestSubDIdV);
722          MarginSum += FoldModel-&gt;GetMargin();
723          CfyRes.Add(FoldCfyRes);
724      } printf(&quot;\n&quot;);
725      CfyRes.Def();
726      CfyRes.AddStat(&quot;AvgMargin&quot;, MarginSum / Folds);
727      return CfyRes;
728  }
729  TSVMModel::TSVMModel(TSIn&amp; SIn) {
730      AlphaV.Load(SIn);
731      Thresh.Load(SIn);
732      Linear.Load(SIn);
733      if (Linear) {
734          WgtV.Load(SIn);
735      } else {
736          SupVecs = TSVMTrainSet::Load(SIn);
737          Kernel = TKernel::Load(SIn);
738      }
739  }
740  void TSVMModel::Save(TSOut&amp; SOut) {
741      AlphaV.Save(SOut);
742      Thresh.Save(SOut);
743      Linear.Save(SOut);
744      if (Linear) {
745          WgtV.Save(SOut);
746      } else {
747          SupVecs-&gt;Save(SOut);
748          Kernel-&gt;Save(SOut);
749      }
750  }
751  double TSVMModel::GetRes(const TIntFltKdV&amp; Vec) const {
752      double Result = Thresh;
753      if (Linear) {
754          Result += TLinAlg::DotProduct(WgtV, Vec);
755      } else {
756          IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
757          IAssert(SupVecs-&gt;Len() == AlphaV.Len());
758          const double Norm2 = TLinAlg::Norm2(Vec);
759          for (int i = 0; i &lt; AlphaV.Len(); i++) {
760              Result += AlphaV[i] * Kernel-&gt;Calc(
761                  SupVecs-&gt;DotProduct(i, Vec),
762                  Norm2, SupVecs-&gt;GetNorm2(i));
763          }
764      }
765      return Result;
766  }
767  double TSVMModel::GetRes(const TFltV&amp; Vec) const {
768      double Result = Thresh;
769      if (Linear) {
770          Result += TLinAlg::DotProduct(WgtV, Vec);
771      } else {
772          IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
773          IAssert(SupVecs-&gt;Len() == AlphaV.Len());
774          const double Norm2 = TLinAlg::Norm2(Vec);
775          for (int i = 0; i &lt; AlphaV.Len(); i++) {
776              Result += AlphaV[i] * Kernel-&gt;Calc(
777                  SupVecs-&gt;DotProduct(i, Vec),
778                  Norm2, SupVecs-&gt;GetNorm2(i));
779          }
780      }
781      return Result;
782  }
783  double TSVMModel::GetRes(const TStr&amp; Vec) const {
784      IAssert(!Linear); 
785      IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
786      IAssert(SupVecs-&gt;Len() == AlphaV.Len());
787      IAssert(SupVecs-&gt;Type() == ststString);
788      double Result = Thresh;
789      const double Norm2 = 1.0; 
790      for (int i = 0; i &lt; AlphaV.Len(); i++) {
791          Result += AlphaV[i] * Kernel-&gt;Calc(
792              SupVecs-&gt;DotProduct(i, Vec),
793              Norm2, SupVecs-&gt;GetNorm2(i));
794      }
795      return Result;
796  }
797  double TSVMModel::GetRes(const TIntV&amp; Vec) const {
798      IAssert(!Linear); 
799      IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
800      IAssert(SupVecs-&gt;Len() == AlphaV.Len());
801      IAssert(SupVecs-&gt;Type() == ststString);
802      double Result = Thresh;
803      const double Norm2 = 1.0; 
804      for (int i = 0; i &lt; AlphaV.Len(); i++) {
805          Result += AlphaV[i] * Kernel-&gt;Calc(
806              SupVecs-&gt;DotProduct(i, Vec),
807              Norm2, SupVecs-&gt;GetNorm2(i));
808      }
809      return Result;
810  }
811  double TSVMModel::GetRes(PBowSpV Vec) const {
812      double Result = Thresh;
813      if (Linear) {
814          Result += TBowLinAlg::DotProduct(WgtV, Vec);
815      } else {
816          IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
817          IAssert(SupVecs-&gt;Len() == AlphaV.Len());
818          IAssert(SupVecs-&gt;Type() == ststBow);
819          const double Norm2 = TMath::Sqr(Vec-&gt;GetNorm());
820          for (int i = 0; i &lt; AlphaV.Len(); i++) {
821              Result += AlphaV[i] * Kernel-&gt;Calc(
822                  SupVecs-&gt;DotProduct(i, Vec),
823                  Norm2, SupVecs-&gt;GetNorm2(i));
824          }
825      }
826      return Result;
827  }
828  double TSVMModel::GetRes(const int&amp; VecId) const {
829      IAssert(!Linear); 
830      IAssert(!SupVecs.Empty() &amp;&amp; ! Kernel.Empty());
831      IAssert(SupVecs-&gt;Len() == AlphaV.Len());
832      IAssert(0 &lt;= VecId &amp;&amp; VecId &lt; AlphaV.Len());
833      IAssert(SupVecs-&gt;Type() == ststSimMatrix);
834      double Result = Thresh;
835      const double Norm2 = SupVecs-&gt;GetNorm2(VecId);
836      for (int i = 0; i &lt; AlphaV.Len(); i++) {
837          Result += AlphaV[i] * Kernel-&gt;Calc(
838              SupVecs-&gt;DotProduct(i, VecId),
839              Norm2, SupVecs-&gt;GetNorm2(i));
840      }
841      return Result;
842  }
843  TCfyRes TSVMModel::Test(const PSVMTrainSet&amp; TestSet, const TIntV&amp; SubSet) const {
844      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TestSet-&gt;Len(), DIdV);
845      int Len = DIdV.Len(); TCountCfyRes Result;
846      for (int DocC = 0; DocC &lt; Len; DocC++) {
847          if (TestSet-&gt;Type() == ststSparse) {
848              Result.Add(GetRes(TestSet-&gt;GetAttrSparseV(DIdV[DocC])),
849                  TestSet-&gt;GetVecParam(DIdV[DocC]));
850          } else if (TestSet-&gt;Type() == ststDense) {
851              Result.Add(GetRes(TestSet-&gt;GetAttrDenseV(DIdV[DocC])),
852                  TestSet-&gt;GetVecParam(DIdV[DocC]));
853          } else if (TestSet-&gt;Type() == ststBow) {
854              Result.Add(GetRes(TestSet-&gt;GetAttrBowV(DIdV[DocC])),
855                  TestSet-&gt;GetVecParam(DIdV[DocC]));
856          } else if (TestSet-&gt;Type() == ststString) {
857              Result.Add(GetRes(TestSet-&gt;GetAttrStringV(DIdV[DocC])),
858                  TestSet-&gt;GetVecParam(DIdV[DocC]));
859          } else if (TestSet-&gt;Type() == ststSimMatrix) {
860              Result.Add(GetRes(DIdV[DocC]), TestSet-&gt;GetVecParam(DIdV[DocC]));
861          }
862      }
863      return Result.ToTCfyRes();
864  }
865  void TSVMModel::MakeProb(const PSVMTrainSet&amp; TrainSet, const TIntV&amp; SubSet) {
866      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet-&gt;Len(), DIdV);
867      int Docs = DIdV.Len();
868      TFltIntKdV DistParamV(Docs, 0);
869      for (int DocC = 0; DocC &lt; Docs; DocC++) {
870          double DistToHyperplane = 0.0;
871          if (TrainSet-&gt;Type() == ststSparse) {
872              DistToHyperplane = GetRes(TrainSet-&gt;GetAttrSparseV(DIdV[DocC]));
873          } else if (TrainSet-&gt;Type() == ststDense) {
874              DistToHyperplane = GetRes(TrainSet-&gt;GetAttrDenseV(DIdV[DocC]));
875          } else if (TrainSet-&gt;Type() == ststBow) {
876              DistToHyperplane = GetRes(TrainSet-&gt;GetAttrBowV(DIdV[DocC]));
877          } else if (TrainSet-&gt;Type() == ststString) {
878              DistToHyperplane = GetRes(TrainSet-&gt;GetAttrStringV(DIdV[DocC]));
879          } else if (TrainSet-&gt;Type() == ststSimMatrix) {
880              DistToHyperplane = GetRes(DIdV[DocC]);
881          }
882          DistParamV.Add(TFltIntKd(DistToHyperplane,
883              TFlt::Round(TrainSet-&gt;GetVecParam(DIdV[DocC]))));
884      }
885      Sigmoid = TSigmoid(DistParamV);
886      IsSigDef = true;
887  }
888  double TSVMModel::GetMargin() const {
889      if (IsLinear()) {
890          const double WgtNorm = TLinAlg::Norm(WgtV);
891          if (WgtNorm &gt; 0.0) { return 1.0 / WgtNorm; }
892          else { return 0.0; }
893      } else {
894          double WgtNorm2 = 0.0;
895          for (int i = 0; i &lt; AlphaV.Len(); i++) {
896              for (int j = 0; j &lt; AlphaV.Len(); j++) {
897                  WgtNorm2 += AlphaV[i]*AlphaV[j] * Kernel-&gt;CalcSet(SupVecs, i, j);
898              }
899          }
900          if (WgtNorm2 &gt; 0.0) { return 1.0 / sqrt(WgtNorm2); }
901          else { return 0.0; }
902      }
903  }
904  bool TBowSVMMd::IsReg=TBowSVMMd::MkReg();
905  TBowSVMMd::TBowSVMMd(TSIn&amp; SIn): TBowMd(SIn) {
906      CatNm.Load(SIn);
907      Model = TSVMModel::Load(SIn);
908  }
909  void TBowSVMMd::Save(TSOut &amp;SOut) {
910      TBowMd::Save(SOut);
911      CatNm.Save(SOut);
912      Model-&gt;Save(SOut);
913  }
914  void TBowSVMMd::GetLinComb(
915   const PBowDocBs&amp; BowDocBs, TFltStrPrV&amp; WgtStrPrV, double&amp; Tsh) const {
916    IAssert(IsLinComb());
917    TFltV WgtV; Model-&gt;GetWgtV(WgtV);
918    for (int WordId=0; WordId&lt;WgtV.Len(); WordId++){
919      if (WgtV[WordId]!=0.0){
920        if (BowDocBs.Empty()){
921          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], TInt::GetStr(WordId)));
922        } else {
923          TStr Str=BowDocBs-&gt;GetWordStr(WordId);
924          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], Str));
925        }
926      }
927    }
928    Tsh=Model-&gt;GetThresh();
929  }
930  PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
931          PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm, const TIntV&amp; TrainDIdV,
932          const double&amp; SampleNegP) {
933      IAssertR(BowDocBs-&gt;IsCatNm(CatNm), CatNm);
934      const int CId = BowDocBs-&gt;GetCId(CatNm);
935      return TBowDocBs2TrainSet::NewBowAllCat(BowDocBs,
936          BowDocWgtBs, CId, TrainDIdV, SampleNegP);
937  }
938  PSVMTrainSet TBowSVMMd::PrepareOneClassTrainSet(PBowDocBs BowDocBs,
939          PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm, const TIntV&amp; TrainDIdV) {
940      IAssertR(BowDocBs-&gt;IsCatNm(CatNm), CatNm);
941      const int CId = BowDocBs-&gt;GetCId(CatNm);
942      return TBowDocBs2TrainSet::NewBowOneCat(BowDocBs, BowDocWgtBs, CId, TrainDIdV);
943  }
944  inline PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
945          PBowDocWgtBs BowDocWgtBs, const TIntV&amp; AllDIdV, const TIntV&amp; CatDIdV) {
946      return TBowDocBs2TrainSet::NewSparseAllCatV(BowDocWgtBs, AllDIdV, CatDIdV);
947  }
948  PBowSpV TBowSVMMd::GetKeywords(const PSVMTrainSet&amp; TrainSet,
949          const PSVMModel&amp; SVMModel, const int WdN,
950          const double&amp; VecSign, const double&amp; WgtSign, const bool&amp; AvgOverSet) {
951      TFltV NormalV; SVMModel-&gt;GetWgtV(NormalV);
952      TIntFltKdV WIdWgtKdV;
953      TrainSet-&gt;GetKeywords(NormalV, WIdWgtKdV,
954          TIntV(), WdN, VecSign, WgtSign, AvgOverSet);
955      PBowSpV BowSpV = TBowSpV::New(-1, WIdWgtKdV.Len());
956      for (int WdN = 0; WdN &lt; WIdWgtKdV.Len(); WdN++) {
957          BowSpV-&gt;AddWIdWgt(WIdWgtKdV[WdN].Key, WIdWgtKdV[WdN].Dat);
958      }
959      return BowSpV;
960  }
961  inline void TBowSVMMd::GetCfy(const PBowSpV&amp; QueryBowSpV, TFltStrPrV&amp; WgtCatNmPrV) {
962      WgtCatNmPrV = TFltStrPrV::GetV(TFltStrPr(Model-&gt;IsProb() ?
963          Model-&gt;GetProbCfy(QueryBowSpV) : Model-&gt;GetRes(QueryBowSpV), CatNm));
964  }
965  TCfyRes TBowSVMMd::Test(PBowMd BowMd, PBowDocBs BowDocBs,
966          PBowDocWgtBs BowDocWgtBs, const TIntV&amp; DIdV, const TStr&amp; CatNm) {
967      TCountCfyRes Result; TFltStrPrV ResV;
968      IAssertR(BowDocBs-&gt;IsCatNm(CatNm), CatNm);
969      const int CId = BowDocBs-&gt;GetCId(CatNm);
970      for (int VecC = 0, VecN = DIdV.Len(); VecC &lt; VecN; VecC++) {
971          PBowSpV DocSpV = BowDocWgtBs-&gt;GetSpV(DIdV[VecC]);
972          ResV.Clr(); BowMd-&gt;GetCfy(DocSpV, ResV);
973          double PredCls = ResV.Len() &gt; 0 ? ResV[0].Val1() : -1.0;
974          double TrueCls = BowDocBs-&gt;IsCatInDoc(DIdV[VecC], CId) ? 1.0 : -1.0;
975          Result.Add(PredCls, TrueCls);
976      }
977      return Result.ToTCfyRes();
978  }
979  void TBowSVMMd::SaveTxt(const TStr&amp; FNm, const PBowDocBs&amp; BowDocBs,
980          const PBowDocWgtBs&amp; BowDocWgtBs) {
981      PSOut SOut = TFOut::New(FNm);
982      TIntV DIdV; BowDocBs-&gt;GetAllDIdV(DIdV);
983      TCfyRes Res = Test(this, BowDocBs, BowDocWgtBs, DIdV, this-&gt;GetCatNm());
984      Res.PrStat(&quot;Results on the training data&quot;, SOut);
985      SOut-&gt;PutLn();
986  }
987  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
988          const TStr&amp; CatNm, const TIntV&amp; TrainDIdV, const double&amp; C, const double&amp; j,
989          const bool&amp; ProbabilisticP, const TSVMLearnParam&amp; LearnParam) {
990      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
991      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
992      if (ProbabilisticP) Model-&gt;MakeProb(TrainSet);
993      return TBowSVMMd::New(BowDocBs, CatNm, Model);
994  }
995  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
996          const TIntV&amp; TrainDIdV, const TIntV&amp; CatDIdV, const double&amp; C, const double&amp; j,
997          const bool&amp; ProbabilisticP, const TSVMLearnParam&amp; LearnParam) {
998      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
999      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
1000      if (ProbabilisticP) Model-&gt;MakeProb(TrainSet);
1001      return TBowSVMMd::New(BowDocBs, &quot;unknown&quot;, Model);
1002  }
1003  PBowMd TBowSVMMd::NewCls(const PKernel&amp; ker, const PBowDocBs&amp; BowDocBs,
1004          PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm, const TIntV&amp; TrainDIdV,
1005          const double&amp; C, const double&amp; j, const bool&amp; ProbabilisticP,
1006          const TSVMLearnParam&amp; LearnParam) {
1007      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1008      PSVMModel Model = TSVMModel::NewCls(TrainSet, ker, C, j, TIntV(), LearnParam);
1009      if (ProbabilisticP) Model-&gt;MakeProb(TrainSet);
1010      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1011  }
1012  TCfyRes TBowSVMMd::CrossValidClsLinear(const int&amp; Folds, const int&amp;Seed,
1013          const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm,
1014          const TIntV&amp; TrainDIdV, const double&amp; C, const double&amp; j,
1015          const TSVMLearnParam&amp; LearnParam) {
1016      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1017      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1018  }
1019  TCfyRes TBowSVMMd::CrossValidClsLinear(const int&amp; Folds, const int&amp;Seed,
1020          const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs, const TIntV&amp; TrainDIdV,
1021          const TIntV&amp; CatDIdV, const double&amp; C, const double&amp; j,
1022          const TSVMLearnParam&amp; LearnParam) {
1023      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1024      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1025  }
1026  TCfyRes TBowSVMMd::CrossValidCls(const int&amp; Folds, const int&amp;Seed,
1027          const PKernel&amp; ker, const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
1028          const TStr&amp; CatNm, const TIntV&amp; TrainDIdV, const double&amp; C,
1029          const double&amp; j, const TSVMLearnParam&amp; LearnParam) {
1030      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1031      return TSVMModel::CrossValidCls(Folds, Seed, TrainSet, ker, C, j, TIntV(), LearnParam);
1032  }
1033  PBowMd TBowSVMMd::NewMultiClsLinear(const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
1034          const TIntV&amp; TrainDIdV, const double&amp; C, const double&amp; j,
1035          const bool&amp; SampleNegP, const TSVMLearnParam&amp; LearnParam) {
1036      const int Cats = BowDocBs-&gt;GetCats(); TBowMdV BowMdV(Cats, 0);
1037      for (int CatN = 0; CatN &lt; Cats; CatN++) {
1038          const TStr&amp; CatNm = BowDocBs-&gt;GetCatNm(CatN);
1039          PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs,
1040              BowDocWgtBs, CatNm, TrainDIdV, (SampleNegP ? j : -1.0));
1041          printf(&quot;(%4d/ %4d (Docs: %9d\r) &quot;, CatN+1, Cats, TrainSet-&gt;Len());
1042          PSVMModel Model = TSVMModel::NewClsLinear(
1043              TrainSet, C, j, TIntV(), LearnParam);
1044          Model-&gt;MakeProb(TrainSet);
1045          BowMdV.Add(TBowSVMMd::New(BowDocBs, CatNm, Model));
1046      } printf(&quot;\n&quot;);
1047      return new TBowMultiMd(BowDocBs, BowMdV);
1048  }
1049  TCfyRes TBowSVMMd::CrossValidMultiClsLinear(const int&amp; Folds, const int&amp; Seed,
1050          const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs, const double&amp; C,
1051          const double&amp; j, const bool&amp; SampleNegP, const TSVMLearnParam&amp; LearnParam) {
1052      TIntV AllDIdV; BowDocBs-&gt;GetAllDIdV(AllDIdV); AllDIdV.Sort();
1053      TIntPrV CIdDIdV; const int DIds = AllDIdV.Len();
1054      for (int DIdN = 0; DIdN &lt; DIds; DIdN++) {
1055          const int DId = AllDIdV[DIdN];
1056          const int CIds = BowDocBs-&gt;GetDocCIds(DId);
1057          for (int CIdN = 0; CIdN &lt; CIds; CIdN++) {
1058              const int CId = BowDocBs-&gt;GetDocCId(DId, CIdN);
1059              CIdDIdV.Add(TIntPr(CId, DId));
1060          }
1061      }
1062      CIdDIdV.Sort();
1063      TVec&lt;TIntV&gt; FoldV(Folds); int FoldN = 0;
1064      for (int CIdDIdN = 0; CIdDIdN &lt; CIdDIdV.Len(); CIdDIdN++) {
1065          const int DId = CIdDIdV[CIdDIdN].Val2;
1066          FoldV[FoldN].Add(DId);
1067          FoldN++;
1068          if (FoldN &gt;= Folds) { FoldN = 0; }
1069      }
1070      for (int FoldN = 0; FoldN &lt; Folds; FoldN++) { FoldV[FoldN].Sort(); }
1071      const int Cats = BowDocBs-&gt;GetCats(); TBowMdV BowMdV(Cats, 0);
1072      TVec&lt;TCountCfyRes&gt; CatCfyResV(Cats);
1073      for (int FoldN = 0; FoldN &lt; Folds; FoldN++) {
1074          printf(&quot;Fold %d ...\n&quot;, FoldN+1);
1075          TIntV TestDIdV = FoldV[FoldN];
1076          TIntV TrainDIdV; AllDIdV.Minus(TestDIdV, TrainDIdV);
1077          PBowMd FoldBowMd = TBowSVMMd::NewMultiClsLinear(BowDocBs,
1078              BowDocWgtBs, TrainDIdV, C, j, SampleNegP, LearnParam);
1079          for (int TestDIdN = 0; TestDIdN &lt; TestDIdV.Len(); TestDIdN++) {
1080              const int TestDId = TestDIdV[TestDIdN];
1081              TFltStrPrV WgtCatNmV;
1082              FoldBowMd-&gt;GetCfy(BowDocWgtBs-&gt;GetSpV(TestDId), WgtCatNmV);
1083              TIntH PredCIdH;
1084              if (!WgtCatNmV.Empty()) {
1085                  PredCIdH.AddKey(BowDocBs-&gt;GetCId(WgtCatNmV[0].Val2)); }
1086              const int CIds = BowDocBs-&gt;GetDocCIds(TestDId);
1087              for (int CIdN = 0; CIdN &lt; CIds; CIdN++) {
1088                  const int CId = BowDocBs-&gt;GetDocCId(TestDId, CIdN);
1089                  if (PredCIdH.IsKey(CId)) {
1090                      CatCfyResV[CId].Add(1.0, 1.0);
1091                      PredCIdH.DelKey(CId);
1092                  } else {
1093                      CatCfyResV[CId].Add(-1.0, 1.0);
1094                  }
1095              }
1096              if (!PredCIdH.Empty()) {
1097                  int KeyId = PredCIdH.FFirstKeyId();
1098                  while (PredCIdH.FNextKeyId(KeyId)) {
1099                      const int CId = PredCIdH.GetKey(KeyId);
1100                      CatCfyResV[CId].Add(1.0, -1.0);
1101                  }
1102              }
1103          }
1104      }
1105      return TCountCfyRes::ToMacroTCfyRes(CatCfyResV);
1106  }
1107  PBowMd TBowSVMMd::NewOneClassLinear(const PBowDocBs&amp; BowDocBs,
1108          PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm, const TIntV&amp; TrainDIdV,
1109          const double&amp; nu, const TSVMLearnParam&amp; LearnParam) {
1110      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1111      PSVMModel Model = TSVMModel::NewOneClassLinear(TrainSet, nu, TIntV(), LearnParam);
1112      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1113  }
1114  PBowMd TBowSVMMd::NewOneClass(const PKernel&amp; ker, const PBowDocBs&amp; BowDocBs,
1115          PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm, const TIntV&amp; TrainDIdV,
1116          const double&amp; nu, const TSVMLearnParam&amp; LearnParam) {
1117      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1118      PSVMModel Model = TSVMModel::NewOneClass(TrainSet, ker, nu, TIntV(), LearnParam);
1119      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1120  }
1121  TCfyRes TBowSVMMd::CrossValidOneClassLinear(const int&amp; Folds, const int&amp;Seed,
1122          const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr&amp; CatNm,
1123          const TIntV&amp; TrainDIdV, const double&amp; nu, const TSVMLearnParam&amp; LearnParam) {
1124      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1125      return TSVMModel::CrossValidOneClassLinear(Folds, Seed, TrainSet, nu, TIntV(), LearnParam);
1126  }
1127  TCfyRes TBowSVMMd::CrossValidOneClass(const int&amp; Folds, const int&amp;Seed,
1128          const PKernel&amp; ker, const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
1129          const TStr&amp; CatNm, const TIntV&amp; TrainDIdV, const double&amp; nu,
1130          const TSVMLearnParam&amp; LearnParam) {
1131      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1132      return TSVMModel::CrossValidOneClass(Folds, Seed, TrainSet, ker, nu, TIntV(), LearnParam);
1133  }
1134  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs&amp; BowDocBs, const TIntV&amp; TrainDIdV,
1135          const TIntV&amp; CatDIdV, const int WdN, const double&amp; C, const double&amp; j,
1136          const int&amp; Time, const TBowWordWgtType&amp; SvmWordWgtType, const double&amp; VecSign,
1137          const double&amp; WgtSign, const bool&amp; AvgOverSet) {
1138      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1139      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1140      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1141      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1142  }
1143  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
1144          const TIntV&amp; TrainDIdV, const TIntV&amp; CatDIdV, const int WdN, const double&amp; C,
1145          const double&amp; j, const int&amp; Time, const double&amp; VecSign, const double&amp; WgtSign,
1146          const bool&amp; AvgOverSet) {
1147      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1148      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1149      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1150  }
1151  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs&amp; BowDocBs, const TIntV&amp; TrainDIdV,
1152          const TStr&amp; CatNm, const int WdN, const double&amp; C, const double&amp; j,
1153          const int&amp; Time, const TBowWordWgtType&amp; SvmWordWgtType, const double&amp; VecSign,
1154          const double&amp; WgtSign, const bool&amp; AvgOverSet) {
1155      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1156      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1157      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1158      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1159  }
1160  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs&amp; BowDocBs, PBowDocWgtBs BowDocWgtBs,
1161          const TIntV&amp; TrainDIdV, const TStr&amp; CatNm, const int WdN, const double&amp; C,
1162          const double&amp; j, const int&amp; Time, const double&amp; VecSign, const double&amp; WgtSign,
1163          const bool&amp; AvgOverSet) {
1164      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1165      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1166      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1167  }
1168  void TSVMTrainSetCsv::TFtrGen::AddWds(const TStr&amp; Prefix,
1169          const PBowDocBs&amp; BowDocBs, int&amp; Offset) const {
1170      const int Vals = GetVals();
1171      for (int ValN = 0; ValN &lt; Vals; ValN++) {
1172          const int WId = BowDocBs-&gt;AddWordStr(
1173              TStr::Fmt(&quot;%s-%s&quot;, Prefix.CStr(), GetVal(ValN).CStr()));
1174          IAssert(Offset == WId); Offset++;
1175      }
1176  }
1177  TStr TSVMTrainSetCsv::TFtrGenNumeric::Type = &quot;NUM&quot;;
1178  double TSVMTrainSetCsv::TFtrGenNumeric::Trans(const double&amp; Val) const {
1179          return MnVal != MxVal ? (double(Val) - MnVal) / (MxVal - MnVal) : 0.0;
1180  }
1181  double TSVMTrainSetCsv::TFtrGenNumeric::GetFlt(const TStr&amp; Str) const {
1182      double Val = 0.0;
1183      if (!Str.IsFlt(Val)) {
1184          TExcept::Throw(TStr::Fmt(&quot;Number expected  but &#x27;%s&#x27; found!&quot;, Str.CStr())); }
1185      return Val;
1186  }
1187  void TSVMTrainSetCsv::TFtrGenNumeric::Update(const TStr&amp; Val) {
1188      double Flt = GetFlt(Val);
1189      MnVal = TFlt::GetMn(MnVal, Flt);
1190      MxVal = TFlt::GetMx(MxVal, Flt);
1191  }
1192  void TSVMTrainSetCsv::TFtrGenNumeric::Add(
1193          const TStr&amp; Val, TIntFltKdV&amp; SpV, int&amp; Offset) const {
1194      double Flt = GetFlt(Val);
1195      SpV.Add(TIntFltKd(Offset, Trans(Flt)));
1196      Offset++;
1197  }
1198  TStr TSVMTrainSetCsv::TFtrGenNominal::Type = &quot;NOM&quot;;
1199  void TSVMTrainSetCsv::TFtrGenNominal::Update(const TStr&amp; Val) {
1200      if (!Val.Empty()) { ValH.AddKey(Val); }
1201  }
1202  void TSVMTrainSetCsv::TFtrGenNominal::Add(
1203          const TStr&amp; Val, TIntFltKdV&amp; SpV, int&amp; Offset) const {
1204      if (ValH.IsKey(Val)) {
1205          SpV.Add(TIntFltKd(Offset + ValH.GetKeyId(Val), 1.0));
1206      }
1207      Offset += ValH.Len();
1208  }
1209  TStr TSVMTrainSetCsv::TFtrGenToken::Type = &quot;TOK&quot;;
1210  void TSVMTrainSetCsv::TFtrGenToken::GetTokenV(
1211          const TStr&amp; Str, TStrV&amp; TokenStrV) const {
1212      THtmlLx HtmlLx(TStrIn::New(Str));
1213      while (HtmlLx.Sym != hsyEof){
1214          if (HtmlLx.Sym == hsyStr){
1215              TStr TokenStr = HtmlLx.UcChA;
1216              if (SwSet.Empty() || !SwSet-&gt;IsIn(TokenStr)) {
1217                  if (!Stemmer.Empty()) {
1218                      TokenStr = Stemmer-&gt;GetStem(TokenStr); }
1219                  TokenStrV.Add(TokenStr);
1220              }
1221          }
1222          HtmlLx.GetSym();
1223      }
1224  }
1225  void TSVMTrainSetCsv::TFtrGenToken::Update(const TStr&amp; Val) {
1226      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1227      for (int TokenStrN = 0; TokenStrN &lt; TokenStrV.Len(); TokenStrN++) {
1228          const TStr&amp; TokenStr = TokenStrV[TokenStrN];
1229          TokenH.AddDat(TokenStr)++;
1230      }
1231      Docs++;
1232  }
1233  void TSVMTrainSetCsv::TFtrGenToken::Add(
1234          const TStr&amp; Val, TIntFltKdV&amp; SpV, int&amp; Offset) const {
1235      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1236      TIntH TokenFqH;
1237      for (int TokenStrN = 0; TokenStrN &lt; TokenStrV.Len(); TokenStrN++) {
1238          const TStr&amp; TokenStr = TokenStrV[TokenStrN];
1239          if (TokenH.IsKey(TokenStr)) {
1240              const int TokenId = TokenH.GetKeyId(TokenStr);
1241              TokenFqH.AddDat(TokenId)++;
1242          }
1243      }
1244      TIntFltKdV ValSpV(TokenFqH.Len(), 0);
1245      int KeyId = TokenFqH.FFirstKeyId();
1246      while (TokenFqH.FNextKeyId(KeyId)) {
1247          const int TokenId = TokenFqH.GetKey(KeyId);
1248          const int TokenFq = TokenFqH[KeyId];
1249          const int TokenDocFq = TokenH[TokenId];
1250          const double IDF = log(double(Docs) / double(TokenDocFq));
1251          ValSpV.Add(TIntFltKd(TokenId, double(TokenFq) * IDF));
1252      }
1253      ValSpV.Sort(); TLinAlg::NormalizeL1(ValSpV);
1254      for (int ValSpN = 0; ValSpN &lt; ValSpV.Len(); ValSpN++) {
1255          const int Key = ValSpV[ValSpN].Key + Offset;
1256          const double Dat = ValSpV[ValSpN].Dat;
1257          SpV.Add(TIntFltKd(Key, Dat));
1258      }
1259      Offset += TokenH.Len();
1260  }
1261  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::Type = &quot;SP-NUM&quot;;
1262  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Split(
1263          const TStr&amp; Str, int&amp; Id, TStr&amp; Val) const {
1264      if (!Str.IsChIn(&#x27;:&#x27;)) { TExcept::Throw(&quot;Wrong sparse numeric &#x27;&quot; + Str + &quot;&#x27;!&quot;); }
1265      TStr IdStr; Str.SplitOnCh(IdStr, &#x27;:&#x27;, Val);
1266      if (!IdStr.IsInt(Id)) { TExcept::Throw(&quot;Wrong sparse numeric &#x27;&quot; + Str + &quot;&#x27;!&quot;); }
1267  }
1268  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Update(const TStr&amp; Str) {
1269      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV);
1270      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1271          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1272          MxId = TInt::GetMx(Id, MxId);
1273          FtrGen.Update(Val);
1274      }
1275  }
1276  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Add(
1277          const TStr&amp; Str, TIntFltKdV&amp; SpV, int&amp; Offset) const {
1278      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV); TIntH UsedIdH;
1279      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1280          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1281          EAssertR(!UsedIdH.IsKey(Id), &quot;Field ID repeated in &#x27;&quot; + Str + &quot;&#x27;!&quot;);
1282          int TmpOffset = Offset + Id;
1283          FtrGen.Add(Val, SpV, TmpOffset);
1284          UsedIdH.AddKey(Id);
1285      }
1286      Offset += GetVals();
1287  }
1288  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::GetVal(const int&amp; ValN) const {
1289      const int FtrGenId = ValN / FtrGen.GetVals();
1290      const int FtrGenValN = ValN % FtrGen.GetVals();
1291      return TStr::Fmt(&quot;SP-%d-%d-%s&quot;, FtrGenId,
1292          FtrGenValN, FtrGen.GetVal(FtrGenValN).CStr());
1293  }
1294  TStr TSVMTrainSetCsv::TFtrGenMultiNom::Type = &quot;MULTI-NOM&quot;;
1295  void TSVMTrainSetCsv::TFtrGenMultiNom::Update(const TStr&amp; Str) {
<span onclick='openModal()' class='match'>1296      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV);
1297      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
</span>1299      }
1300  }
1301  void TSVMTrainSetCsv::TFtrGenMultiNom::Add(
1302          const TStr&amp; Str, TIntFltKdV&amp; SpV, int&amp; Offset) const {
1303      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV);
1304      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1305          int TmpOffset = Offset;
1306          FtrGen.Add(EltV[EltN], SpV, TmpOffset);
1307      }
1308      Offset += GetVals();
1309  }
1310  TStr TSVMTrainSetCsv::TFtrGenMultiNom::GetVal(const int&amp; ValN) const {
1311      return TStr::Fmt(&quot;MULTI-%d-%s&quot;, ValN, FtrGen.GetVal(ValN).CStr());
1312  }
1313  void TSVMTrainSetCsv::TFtrGenMultiNom::GetValV(const TStr&amp; Str, TStrV&amp; ValV) const {
1314      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV); ValV.Clr();
1315      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1316          const TStr&amp; Val = EltV[EltN];
1317          TStrV SubValV; FtrGen.GetValV(Val, SubValV);
1318          ValV.AddV(SubValV);
1319      }
1320  }
1321  PBowDocBs TSVMTrainSetCsv::LoadCsv(TStr&amp; FNm, const int&amp; ClassId,
1322          const TIntV&amp; IgnoreIdV, const int&amp; TrainLen) {
1323      THash&lt;TInt, PFtrGen&gt; FtrGenH;
1324      PFtrGen ClassFtrGen;
1325      PSIn SIn = TFIn::New(FNm);
1326      char SsCh = &#x27; &#x27;; TStrV FldValV;
1327      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1328      for (int FldValN = 0; FldValN &lt; FldValV.Len(); FldValN++) {
1329          const TStr&amp; FldVal = FldValV[FldValN];
1330          if (FldValN == ClassId) {
1331              if (FldVal == &quot;NOM&quot;) {
1332                  ClassFtrGen = TFtrGenNominal::New();
1333              } else if (FldVal == &quot;MULTI-NOM&quot;) {
1334                  ClassFtrGen = TFtrGenMultiNom::New();
1335              } else {
1336                  TExcept::Throw(&quot;Wrong class type &#x27;&quot; + FldVal + &quot;&#x27;, should be NOM or MULTI-NOM!&quot;);
1337              }
1338          } else if (!IgnoreIdV.IsIn(FldValN)) {
1339              if (FldVal == TFtrGenNumeric::Type) {
1340                  FtrGenH.AddDat(FldValN, TFtrGenNumeric::New());
1341              } else if (FldVal == TFtrGenNominal::Type) {
1342                  FtrGenH.AddDat(FldValN, TFtrGenNominal::New());
1343              } else if (FldVal == TFtrGenToken::Type) {
1344                  FtrGenH.AddDat(FldValN, TFtrGenToken::New(
1345                      TSwSet::New(swstNone), TStemmer::New(stmtNone)));
1346              } else if (FldVal == TFtrGenSparseNumeric::Type) {
1347                  FtrGenH.AddDat(FldValN, TFtrGenSparseNumeric::New());
1348              } else if (FldVal == TFtrGenMultiNom::Type) {
1349                  FtrGenH.AddDat(FldValN, TFtrGenMultiNom::New());
1350              } else {
1351                  TExcept::Throw(&quot;Wrong type &#x27;&quot; + FldVal + &quot;&#x27;!&quot;);
1352              }
1353          }
1354      }
1355      const int Flds = FldValV.Len();
1356      int Recs = 0;
1357      while (!SIn-&gt;Eof()) {
1358          if (Recs == TrainLen) { break; }
1359          Recs++; printf(&quot;%7d\r&quot;, Recs);
1360          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1361          EAssertR(FldValV.Len() == Flds,
1362              TStr::Fmt(&quot;Wrong number of fields in line %d! Found %d and expected %d!&quot;,
1363              Recs + 1, FldValV.Len(), Flds));
1364          try {
1365              for (int FldValN = 0; FldValN &lt; FldValV.Len(); FldValN++) {
1366                  const TStr&amp; FldVal = FldValV[FldValN];
1367                  if (FldValN == ClassId) {
1368                      ClassFtrGen-&gt;Update(FldVal);
1369                  } else if (FtrGenH.IsKey(FldValN)) {
1370                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1371                      FtrGen-&gt;Update(FldVal);
1372                  }
1373              }
1374          } catch (PExcept Ex) {
1375              TExcept::Throw(TStr::Fmt(&quot;Error in line %d: &#x27;%s&#x27;!&quot;,
1376                  Recs+1, Ex-&gt;GetMsgStr().CStr()));
1377          }
1378      }
1379      PBowDocBs BowDocBs = TBowDocBs::New();
1380      int WdsOffset = 0;
1381      for (int FtrGenId = 0; FtrGenId &lt; FtrGenH.Len(); FtrGenId++) {
1382          PFtrGen FtrGen = FtrGenH[FtrGenId];
1383          TStr Prefix = FtrGenH.GetKey(FtrGenId).GetStr();
1384          FtrGen-&gt;AddWds(Prefix, BowDocBs, WdsOffset);
1385      }
1386      SIn = TFIn::New(FNm); SsCh = &#x27; &#x27;;
1387      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1388      Recs = 0;
1389      while (!SIn-&gt;Eof()){
1390          Recs++; printf(&quot;%7d\r&quot;, Recs);
1391          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1392          EAssertR(FldValV.Len() == Flds,
1393              TStr::Fmt(&quot;Wrong number of fields in line %s! Found %d and expected %d!&quot;,
1394              Recs + 1, FldValV.Len(), Flds));
1395          TIntFltKdV FtrSpV; TStrV CatNmV; int Offset = 0;
1396          try {
1397              for (int FldValN = 0; FldValN &lt; FldValV.Len(); FldValN++) {
1398                  const TStr&amp; FldVal = FldValV[FldValN];
1399                  if (FldValN == ClassId) {
1400                      ClassFtrGen-&gt;GetValV(FldVal, CatNmV);
1401                  } else if (FtrGenH.IsKey(FldValN)) {
1402                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1403                      FtrGen-&gt;Add(FldVal, FtrSpV, Offset);
1404                  }
1405              }
1406          } catch (PExcept Ex) {
1407              TExcept::Throw(TStr::Fmt(&quot;Error in line %d: &#x27;%s&#x27;!&quot;,
1408                  Recs+1, Ex-&gt;GetMsgStr().CStr()));
1409          }
1410          const int WIds = FtrSpV.Len();
1411          TIntFltPrV WIdWgtPrV(WIds, 0);
1412          for (int WIdN = 0; WIdN &lt; WIds; WIdN++) {
1413              WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
1414          }
1415          BowDocBs-&gt;AddDoc(TStr::Fmt(&quot;Line-%d&quot;, Recs), CatNmV, WIdWgtPrV);
1416      }
1417      return BowDocBs;
1418  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</h3>
            <pre><code>1  #include &quot;vizmapgks.h&quot;
2  #include &lt;gkswf.h&gt;
3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
19  int TVizMapContext::SizePointCross = 2;
20  int TVizMapContext::PointNmWidth = 100;
21  int TVizMapContext::PointNmMxLines = 3;
22  double TVizMapContext::PointNmFontScale = 20.0;
23  int TVizMapContext::MgGlassWindowWidth = 150;
24  int TVizMapContext::RndKeyWdN = 3000;
25  double TVizMapContext::RelRadius = 0.2;
26  int TVizMapContext::KeyWdCandidates = 10;
27  double TVizMapContext::RelMnRptDist = 0.1;
28  double TVizMapContext::RelSparsity = 0.05;
29  void TVizMapContext::LoadColor() {
30      LandscapeCatColorV.Clr();
31      LandscapeCatColorV.Add(TGksColor(43, 76, 115));
32      LandscapeCatColorV.Add(TGksColor(53, 46, 115));
33      LandscapeCatColorV.Add(TGksColor(33, 106, 115));
34      LandscapeCatColorV.Add(TGksColor(63, 80, 170));
35      LandscapeCatColorV.Add(TGksColor(61, 106, 200));
36      LandscapeCatColorV.Add(TGksColor(71, 106, 190));
37      LandscapeCatColorV.Add(TGksColor(51, 106, 210));
38      LandscapeCatColorV.Add(TGksColor(81, 106, 180));
39      LandscapeCatColorV.Add(TGksColor(43, 91, 125));
40      LandscapeCatColorV.Add(TGksColor(43, 91, 135));
41      LandscapeCatColorV.Add(TGksColor(43, 91, 145));
42      LandscapeCatColorV.Add(TGksColor(43, 91, 155));
43      LandscapeCatColorV.Add(TGksColor(43, 106, 125));
44      LandscapeCatColorV.Add(TGksColor(43, 106, 135));
45      LandscapeCatColorV.Add(TGksColor(43, 106, 145));
46      LandscapeCatColorV.Add(TGksColor(43, 106, 155));
47  }
48  void TVizMapContext::LoadCatFullNms() {
49      CatFullNmH.AddDat(&quot;1POL&quot;, &quot;CURRENT NEWS - POLITICS&quot;);
50      CatFullNmH.AddDat(&quot;2ECO&quot;, &quot;CURRENT NEWS - ECONOMICS&quot;);
51      CatFullNmH.AddDat(&quot;3SPO&quot;, &quot;CURRENT NEWS - SPORT&quot;);
52      CatFullNmH.AddDat(&quot;4GEN&quot;, &quot;CURRENT NEWS - GENERAL&quot;);
53      CatFullNmH.AddDat(&quot;6INS&quot;, &quot;CURRENT NEWS - INSURANCE&quot;);
54      CatFullNmH.AddDat(&quot;7RSK&quot;, &quot;CURRENT NEWS - RISK NEWS&quot;);
55      CatFullNmH.AddDat(&quot;8YDB&quot;, &quot;TEMPORARY&quot;);
56      CatFullNmH.AddDat(&quot;9BNX&quot;, &quot;TEMPORARY&quot;);
57      CatFullNmH.AddDat(&quot;ADS10&quot;, &quot;CURRENT NEWS - ADVERTISING&quot;);
58      CatFullNmH.AddDat(&quot;BNW14&quot;, &quot;CURRENT NEWS - BUSINESS NEWS&quot;);
59      CatFullNmH.AddDat(&quot;BRP11&quot;, &quot;CURRENT NEWS - BRANDS&quot;);
60      CatFullNmH.AddDat(&quot;C11&quot;, &quot;STRATEGY/PLANS&quot;);
61      CatFullNmH.AddDat(&quot;C12&quot;, &quot;LEGAL/JUDICIAL&quot;);
62      CatFullNmH.AddDat(&quot;C13&quot;, &quot;REGULATION/POLICY&quot;);
63      CatFullNmH.AddDat(&quot;C14&quot;, &quot;SHARE LISTINGS&quot;);
64      CatFullNmH.AddDat(&quot;C15&quot;, &quot;PERFORMANCE&quot;);
65      CatFullNmH.AddDat(&quot;C151&quot;, &quot;ACCOUNTS/EARNINGS&quot;);
66      CatFullNmH.AddDat(&quot;C1511&quot;, &quot;ANNUAL RESULTS&quot;);
67      CatFullNmH.AddDat(&quot;C152&quot;, &quot;COMMENT/FORECASTS&quot;);
68      CatFullNmH.AddDat(&quot;C16&quot;, &quot;INSOLVENCY/LIQUIDITY&quot;);
69      CatFullNmH.AddDat(&quot;C17&quot;, &quot;FUNDING/CAPITAL&quot;);
70      CatFullNmH.AddDat(&quot;C171&quot;, &quot;SHARE CAPITAL&quot;);
71      CatFullNmH.AddDat(&quot;C172&quot;, &quot;BONDS/DEBT ISSUES&quot;);
72      CatFullNmH.AddDat(&quot;C173&quot;, &quot;LOANS/CREDITS&quot;);
73      CatFullNmH.AddDat(&quot;C174&quot;, &quot;CREDIT RATINGS&quot;);
74      CatFullNmH.AddDat(&quot;C18&quot;, &quot;OWNERSHIP CHANGES&quot;);
75      CatFullNmH.AddDat(&quot;C181&quot;, &quot;MERGERS/ACQUISITIONS&quot;);
76      CatFullNmH.AddDat(&quot;C182&quot;, &quot;ASSET TRANSFERS&quot;);
77      CatFullNmH.AddDat(&quot;C183&quot;, &quot;PRIVATISATIONS&quot;);
78      CatFullNmH.AddDat(&quot;C21&quot;, &quot;PRODUCTION/SERVICES&quot;);
79      CatFullNmH.AddDat(&quot;C22&quot;, &quot;NEW PRODUCTS/SERVICES&quot;);
80      CatFullNmH.AddDat(&quot;C23&quot;, &quot;RESEARCH/DEVELOPMENT&quot;);
81      CatFullNmH.AddDat(&quot;C24&quot;, &quot;CAPACITY/FACILITIES&quot;);
82      CatFullNmH.AddDat(&quot;C31&quot;, &quot;MARKETS/MARKETING&quot;);
83      CatFullNmH.AddDat(&quot;C311&quot;, &quot;DOMESTIC MARKETS&quot;);
84      CatFullNmH.AddDat(&quot;C312&quot;, &quot;EXTERNAL MARKETS&quot;);
85      CatFullNmH.AddDat(&quot;C313&quot;, &quot;MARKET SHARE&quot;);
86      CatFullNmH.AddDat(&quot;C32&quot;, &quot;ADVERTISING/PROMOTION&quot;);
87      CatFullNmH.AddDat(&quot;C33&quot;, &quot;CONTRACTS/ORDERS&quot;);
88      CatFullNmH.AddDat(&quot;C331&quot;, &quot;DEFENCE CONTRACTS&quot;);
89      CatFullNmH.AddDat(&quot;C34&quot;, &quot;MONOPOLIES/COMPETITION&quot;);
90      CatFullNmH.AddDat(&quot;C41&quot;, &quot;MANAGEMENT&quot;);
91      CatFullNmH.AddDat(&quot;C411&quot;, &quot;MANAGEMENT MOVES&quot;);
92      CatFullNmH.AddDat(&quot;C42&quot;, &quot;LABOUR&quot;);
93      CatFullNmH.AddDat(&quot;CCAT&quot;, &quot;CORPORATE/INDUSTRIAL&quot;);
94      CatFullNmH.AddDat(&quot;E11&quot;, &quot;ECONOMIC PERFORMANCE&quot;);
95      CatFullNmH.AddDat(&quot;E12&quot;, &quot;MONETARY/ECONOMIC&quot;);
96      CatFullNmH.AddDat(&quot;E121&quot;, &quot;MONEY SUPPLY&quot;);
97      CatFullNmH.AddDat(&quot;E13&quot;, &quot;INFLATION/PRICES&quot;);
98      CatFullNmH.AddDat(&quot;E131&quot;, &quot;CONSUMER PRICES&quot;);
99      CatFullNmH.AddDat(&quot;E132&quot;, &quot;WHOLESALE PRICES&quot;);
100      CatFullNmH.AddDat(&quot;E14&quot;, &quot;CONSUMER FINANCE&quot;);
101      CatFullNmH.AddDat(&quot;E141&quot;, &quot;PERSONAL INCOME&quot;);
102      CatFullNmH.AddDat(&quot;E142&quot;, &quot;CONSUMER CREDIT&quot;);
103      CatFullNmH.AddDat(&quot;E143&quot;, &quot;RETAIL SALES&quot;);
104      CatFullNmH.AddDat(&quot;E21&quot;, &quot;GOVERNMENT FINANCE&quot;);
105      CatFullNmH.AddDat(&quot;E211&quot;, &quot;EXPENDITURE/REVENUE&quot;);
106      CatFullNmH.AddDat(&quot;E212&quot;, &quot;GOVERNMENT BORROWING&quot;);
107      CatFullNmH.AddDat(&quot;E31&quot;, &quot;OUTPUT/CAPACITY&quot;);
108      CatFullNmH.AddDat(&quot;E311&quot;, &quot;INDUSTRIAL PRODUCTION&quot;);
109      CatFullNmH.AddDat(&quot;E312&quot;, &quot;CAPACITY UTILIZATION&quot;);
110      CatFullNmH.AddDat(&quot;E313&quot;, &quot;INVENTORIES&quot;);
111      CatFullNmH.AddDat(&quot;E41&quot;, &quot;EMPLOYMENT/LABOUR&quot;);
112      CatFullNmH.AddDat(&quot;E411&quot;, &quot;UNEMPLOYMENT&quot;);
113      CatFullNmH.AddDat(&quot;E51&quot;, &quot;TRADE/RESERVES&quot;);
114      CatFullNmH.AddDat(&quot;E511&quot;, &quot;BALANCE OF PAYMENTS&quot;);
115      CatFullNmH.AddDat(&quot;E512&quot;, &quot;MERCHANDISE TRADE&quot;);
116      CatFullNmH.AddDat(&quot;E513&quot;, &quot;RESERVES&quot;);
117      CatFullNmH.AddDat(&quot;E61&quot;, &quot;HOUSING STARTS&quot;);
118      CatFullNmH.AddDat(&quot;E71&quot;, &quot;LEADING INDICATORS&quot;);
119      CatFullNmH.AddDat(&quot;ECAT&quot;, &quot;ECONOMICS&quot;);
120      CatFullNmH.AddDat(&quot;ENT12&quot;, &quot;CURRENT NEWS - ENTERTAINMENT&quot;);
121      CatFullNmH.AddDat(&quot;G11&quot;, &quot;SOCIAL AFFAIRS&quot;);
122      CatFullNmH.AddDat(&quot;G111&quot;, &quot;HEALTH/SAFETY&quot;);
123      CatFullNmH.AddDat(&quot;G112&quot;, &quot;SOCIAL SECURITY&quot;);
124      CatFullNmH.AddDat(&quot;G113&quot;, &quot;EDUCATION/RESEARCH&quot;);
125      CatFullNmH.AddDat(&quot;G12&quot;, &quot;INTERNAL POLITICS&quot;);
126      CatFullNmH.AddDat(&quot;G13&quot;, &quot;INTERNATIONAL RELATIONS&quot;);
127      CatFullNmH.AddDat(&quot;G131&quot;, &quot;DEFENCE&quot;);
128      CatFullNmH.AddDat(&quot;G14&quot;, &quot;ENVIRONMENT&quot;);
129      CatFullNmH.AddDat(&quot;G15&quot;, &quot;EUROPEAN COMMUNITY&quot;);
130      CatFullNmH.AddDat(&quot;G151&quot;, &quot;EC INTERNAL MARKET&quot;);
131      CatFullNmH.AddDat(&quot;G152&quot;, &quot;EC CORPORATE POLICY&quot;);
132      CatFullNmH.AddDat(&quot;G153&quot;, &quot;EC AGRICULTURE POLICY&quot;);
133      CatFullNmH.AddDat(&quot;G154&quot;, &quot;EC MONETARY/ECONOMIC&quot;);
134      CatFullNmH.AddDat(&quot;G155&quot;, &quot;EC INSTITUTIONS&quot;);
135      CatFullNmH.AddDat(&quot;G156&quot;, &quot;EC ENVIRONMENT ISSUES&quot;);
136      CatFullNmH.AddDat(&quot;G157&quot;, &quot;EC COMPETITION/SUBSIDY&quot;);
137      CatFullNmH.AddDat(&quot;G158&quot;, &quot;EC EXTERNAL RELATIONS&quot;);
138      CatFullNmH.AddDat(&quot;G159&quot;, &quot;EC GENERAL&quot;);
139      CatFullNmH.AddDat(&quot;GCAT&quot;, &quot;GOVERNMENT/SOCIAL&quot;);
140      CatFullNmH.AddDat(&quot;GCRIM&quot;, &quot;CRIME, LAW ENFORCEMENT&quot;);
141      CatFullNmH.AddDat(&quot;GDEF&quot;, &quot;DEFENCE&quot;);
142      CatFullNmH.AddDat(&quot;GDIP&quot;, &quot;INTERNATIONAL RELATIONS&quot;);
143      CatFullNmH.AddDat(&quot;GDIS&quot;, &quot;DISASTERS AND ACCIDENTS&quot;);
144      CatFullNmH.AddDat(&quot;GEDU&quot;, &quot;EDUCATION&quot;);
145      CatFullNmH.AddDat(&quot;GENT&quot;, &quot;ARTS, CULTURE, ENTERTAINMENT&quot;);
146      CatFullNmH.AddDat(&quot;GENV&quot;, &quot;ENVIRONMENT AND NATURAL WORLD&quot;);
147      CatFullNmH.AddDat(&quot;GFAS&quot;, &quot;FASHION&quot;);
148      CatFullNmH.AddDat(&quot;GHEA&quot;, &quot;HEALTH&quot;);
149      CatFullNmH.AddDat(&quot;GJOB&quot;, &quot;LABOUR ISSUES&quot;);
150      CatFullNmH.AddDat(&quot;GMIL&quot;, &quot;MILLENNIUM ISSUES&quot;);
151      CatFullNmH.AddDat(&quot;GOBIT&quot;, &quot;OBITUARIES&quot;);
152      CatFullNmH.AddDat(&quot;GODD&quot;, &quot;HUMAN INTEREST&quot;);
153      CatFullNmH.AddDat(&quot;GPOL&quot;, &quot;DOMESTIC POLITICS&quot;);
154      CatFullNmH.AddDat(&quot;GPRO&quot;, &quot;BIOGRAPHIES, PERSONALITIES, PEOPLE&quot;);
155      CatFullNmH.AddDat(&quot;GREL&quot;, &quot;RELIGION&quot;);
156      CatFullNmH.AddDat(&quot;GSCI&quot;, &quot;SCIENCE AND TECHNOLOGY&quot;);
157      CatFullNmH.AddDat(&quot;GSPO&quot;, &quot;SPORTS&quot;);
158      CatFullNmH.AddDat(&quot;GTOUR&quot;, &quot;TRAVEL AND TOURISM&quot;);
159      CatFullNmH.AddDat(&quot;GVIO&quot;, &quot;WAR, CIVIL WAR&quot;);
160      CatFullNmH.AddDat(&quot;GVOTE&quot;, &quot;ELECTIONS&quot;);
161      CatFullNmH.AddDat(&quot;GWEA&quot;, &quot;WEATHER&quot;);
162      CatFullNmH.AddDat(&quot;GWELF&quot;, &quot;WELFARE, SOCIAL SERVICES&quot;);
163      CatFullNmH.AddDat(&quot;M11&quot;, &quot;EQUITY MARKETS&quot;);
164      CatFullNmH.AddDat(&quot;M12&quot;, &quot;BOND MARKETS&quot;);
165      CatFullNmH.AddDat(&quot;M13&quot;, &quot;MONEY MARKETS&quot;);
166      CatFullNmH.AddDat(&quot;M131&quot;, &quot;INTERBANK MARKETS&quot;);
167      CatFullNmH.AddDat(&quot;M132&quot;, &quot;FOREX MARKETS&quot;);
168      CatFullNmH.AddDat(&quot;M14&quot;, &quot;COMMODITY MARKETS&quot;);
169      CatFullNmH.AddDat(&quot;M141&quot;, &quot;SOFT COMMODITIES&quot;);
170      CatFullNmH.AddDat(&quot;M142&quot;, &quot;METALS TRADING&quot;);
171      CatFullNmH.AddDat(&quot;M143&quot;, &quot;ENERGY MARKETS&quot;);
172      CatFullNmH.AddDat(&quot;MCAT&quot;, &quot;MARKETS&quot;);
173      CatFullNmH.AddDat(&quot;MEUR&quot;, &quot;EURO CURRENCY&quot;);
174      CatFullNmH.AddDat(&quot;PRB13&quot;, &quot;CURRENT NEWS - PRESS RELEASE WIRES&quot;);
175  }
176  TFltRect TVizMapContext::GetZoomRect() {
177      if (!ZoomS.Empty()) {
178          return ZoomS.Top();
179      } else {
180          return TFltRect(0.0, 0.0, 1.0, 1.0);
181      }
182  }
183  void TVizMapContext::RenderLandscapeBmp() {
184      if (SelLandscape.Empty()) return;
185      TFltRect ZoomRect = GetZoomRect();
186      const int MaxWidth = SelLandscape-&gt;GetXDim();
187      const int MaxHeight = SelLandscape-&gt;GetYDim();
188      const int Width = TFlt::Round(ZoomRect.GetXLen()*MaxWidth);
189      const int Height = TFlt::Round(ZoomRect.GetYLen()*MaxHeight);
190      const int LeftX = TFlt::Round(ZoomRect.GetMnX()*MaxWidth);
191      const int TopY = TFlt::Round(ZoomRect.GetMnY()*MaxHeight);
192      if (Width &gt; 0 &amp;&amp; Height &gt; 0) {        
193          const TSFltVV&amp; HeightVV = SelLandscape-&gt;HeightVV();
194              Assert(SelLandscape-&gt;GetLevels() == 2);
195              const double First = SelLandscape-&gt;GetLevel(0);
196              const double Second = SelLandscape-&gt;GetLevel(1);
197              LandscapeBmp = TGksBitmap::New(Width, Height, ColorLandscapeAbove);
198              for (int X = 0; X &lt; Width; X++) {
199                  for (int Y = 0; Y &lt; Height; Y++) {
200                      double Val = HeightVV(LeftX+X, TopY+Y);
201                      if (Val &gt; Second) { Val = Second + 3*(Val - Second); }
202                      TGksColor PixelColor = ColorLandscapeAbove.Add(
203                          TFlt::Round(Val*34), TFlt::Round(Val*28), TFlt::Round(Val*24));
204                      if (Val &gt; Second) { PixelColor = PixelColor.Add(ColorAddSecondLevel); } 
205                      if (Val &gt; First) { PixelColor = PixelColor.Add(ColorAddFirstLevel); }
206                      LandscapeBmp-&gt;SetPixel(X, Y, PixelColor);
207                  }
208              }
209      } else {
210          LandscapeBmp = TGksBitmap::New(1, 1, ColorLandscapeAbove);
211      }
212  }
213  void TVizMapContext::ResetMgGlassSize() { 
214      TFltRect ZoomRect = GetZoomRect();
215      MgGlassSize = 0.2 * TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen()); 
216  }
217  void TVizMapContext::ResetMgGlassKeyWd(const int&amp; MgGlassKeyWds) {
218      MgGlassPoints = VizMapFrame-&gt;GenKeyWd(TFltV::GetV(MouseX, MouseY), 
219          MgGlassSize, MgGlassKeyWds, MgGlassKeyWdV, false, false);
220  }
221  void TVizMapContext::ResetKeyWd() {
222      TFltRect ZoomRect = GetZoomRect();
223      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
224      const double Radius = RelRadius * MnZoomRectSize; 
225      VizMapFrame-&gt;GenKeyWds(RndKeyWdN, Radius, KeyWdCandidates, 0, ZoomRect); 
226  }
227  void TVizMapContext::ResetNearPointN() {
228      double MnDist = TFlt::Mx;
229      NearPointN = -1;
230      int Points = VizMapFrame-&gt;GetPoints();
231      for (int PointN = 0; PointN &lt; Points; PointN++) {
232          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(PointN);
233          const double PointX = Point-&gt;GetPointX(), PointY = Point-&gt;GetPointY();
234          const double Dist = TMath::Sqr(PointX - MouseX) + 
235              TMath::Sqr(PointY - MouseY);
236          if (Dist &lt; MnDist) { MnDist = Dist; NearPointN = PointN; }
237      }
238      if (TMath::Sqrt(MnDist) &gt; 0.1) { NearPointN = -1; }
239  }
240  inline double TVizMapContext::GetMapCoord(const int&amp; ScreenCoord, 
241          const int&amp; ScreenLen, const double&amp; MapMn, const double&amp; MapLen) {
242      return MapMn + MapLen*(double(ScreenCoord)/double(ScreenLen));
243  }
244  inline int TVizMapContext::GetScreenCoord(const double&amp; MapCoord, const double&amp; MapMn, 
245          const double&amp; MapLen, const int&amp; ScreenLen) {
246      return TFlt::Round(ScreenLen * ((MapCoord - MapMn)/MapLen));
247  }
248  int TVizMapContext::GetEncoderClsid(const TStr&amp; EncoderType, CLSID* pClsid) {
249      const int StrLen = EncoderType.Len() + 1;
250      WCHAR* format = new WCHAR[StrLen];
251      const int Res = MultiByteToWideChar(CP_ACP, 0, 
252          EncoderType.CStr(), StrLen, format, StrLen);
253      UINT  num = 0;          
254      UINT  size = 0;         
255      Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;
256      Gdiplus::GetImageEncodersSize(&amp;num, &amp;size);
257      if (size == 0) { return -1; } 
258      pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
259      if(pImageCodecInfo == NULL) { return -1; } 
260      Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
261      for(UINT j = 0; j &lt; num; ++j) {
262          if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
263              *pClsid = pImageCodecInfo[j].Clsid;
264              free(pImageCodecInfo);
265              return j;  
266          }    
267      }
268      free(pImageCodecInfo);
269      return -1;  
270  }
271  void TVizMapContext::ResetFrame() {
272      if (VizMapFrame-&gt;GetLandscapes() &gt; 0) {
273          SelLandscape = VizMapFrame-&gt;GetLandscape(0); 
274          RenderLandscapeBmp();
275      }
276      ResetKeyWd(); SelPointV.Clr();
277  }
278  TVizMapContext::TVizMapContext(PVizMap _VizMap): 
279          VizMap(_VizMap), VizMapFrameN(0),
280          VizMapFrame(_VizMap-&gt;GetFirst()), SelMode(vmsmZoom), 
281          MgGlassPoints(0), MouseInP(false), LeftButtonDownP(false), 
282          MgGlassSize(0.2), NearPointN(-1) { 
283      LoadColor();
284      LoadCatFullNms();
285      ResetFrame();
286  }
287  void TVizMapContext::SetVizMapFrame(const int&amp; NewVizMapFrameN) {
288      VizMapFrameN = NewVizMapFrameN;
289      VizMapFrame = VizMap-&gt;GetVizMapFrame(VizMapFrameN);
290      ResetFrame();
291  }
292  void TVizMapContext::SaveVrml(const TStr&amp; VrmlFNm, bool ShowPointNmP, bool ShowKeyWdP) {    
293      VizMapFrame-&gt;SaveVrml(VrmlFNm, SelLandscape, ShowPointNmP, !ShowPointNmP,  ShowKeyWdP);
294  }
295  void TVizMapContext::PaintEmpty(PGks Gks) {
296      Gks-&gt;SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks-&gt;FillRect(-1, -1, Gks-&gt;GetWidth()+1, Gks-&gt;GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool&amp; ShowPointNmP, const int&amp; PointFontSize,
300          const int&amp; PointNmFontScale, const double&amp; PointWgtThreshold, const int&amp; CatId,
301          const bool&amp; ShowCatNmP, const bool&amp; ShowKeyWdP, const int&amp; KeyWdFontSize, 
302          const bool&amp; ShowMgGlassP, const int&amp; LegendGridWidth, const int&amp; LegendGridHeight) {
303      if (!SelLandscape.Empty()) { PaintLandscape(Gks); } 
304      else { PaintEmpty(Gks); }
305      PaintLegendGrid(Gks, LegendGridWidth, LegendGridHeight);
306      PaintLinks(Gks);
307      TVec&lt;TFltRect&gt; PointNmRectV;
308      if (ShowPointNmP) { 
309          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
310              PointWgtThreshold, CatId, ShowMgGlassP, PointNmRectV); 
311      } else { 
312          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
313              TFlt::Mx, CatId, ShowMgGlassP, PointNmRectV); 
314      }
315      if (ShowCatNmP &amp;&amp; !SelLandscape.Empty()) { 
316          PaintCatNms(Gks, KeyWdFontSize, PointNmRectV); };
317      if (ShowKeyWdP) { PaintKeyWds(Gks, KeyWdFontSize, PointNmRectV); }
318      if (LeftButtonDownP) { PaintZoomRect(Gks); }
319      else if (MouseInP &amp;&amp; ShowMgGlassP) { PaintMgGlass(Gks, KeyWdFontSize); }
320  }
321  void TVizMapContext::PaintLandscape(PGks Gks){
322      Gks-&gt;Bitmap(LandscapeBmp, -1, -1, Gks-&gt;GetWidth()+1, Gks-&gt;GetHeight()+1);
323  }
324  void TVizMapContext::PaintLegendGrid(PGks Gks, 
325          const int&amp; LegendGridWidth, const int&amp; LegendGridHeight) {
326      Gks-&gt;SetPen(TGksPen::New(ColorLegendGridColor));
327      for (int LineN = 1; LineN &lt; LegendGridWidth; LineN++) {
328          const double RelativeWidth = double(LineN) / double(LegendGridWidth);
329          const int X = TFlt::Round(RelativeWidth * Gks-&gt;GetWidth());
330          Gks-&gt;Line(X, -1, X, Gks-&gt;GetHeight());
331      }
332      for (int LineN = 1; LineN &lt; LegendGridHeight; LineN++) {
333          const double RelativeHeight = double(LineN) / double(LegendGridHeight);
334          const int Y = TFlt::Round(RelativeHeight * Gks-&gt;GetHeight());
335          Gks-&gt;Line(-1, Y, Gks-&gt;GetWidth(), Y);
336      }
337  }
338  void TVizMapContext::PaintLinks(PGks Gks) {
339      int Links = VizMapFrame-&gt;GetLinks();
340      TFltRect ZoomRect = GetZoomRect();
341      for (int LinkN = 0; LinkN &lt; Links; LinkN++) {
342          PVizMapLink Link = VizMapFrame-&gt;GetLink(LinkN);
343          PVizMapPoint SrcPoint = VizMapFrame-&gt;GetPoint(Link-&gt;GetSrcPointN());
344          PVizMapPoint DstPoint = VizMapFrame-&gt;GetPoint(Link-&gt;GetDstPointN());
345          const double SrcPointX = SrcPoint-&gt;GetPointX(), SrcPointY = SrcPoint-&gt;GetPointY();
346          const double DstPointX = DstPoint-&gt;GetPointX(), DstPointY = DstPoint-&gt;GetPointY();
347          const int SrcX = GetScreenCoord(SrcPointX, ZoomRect.GetMnX(), 
348              ZoomRect.GetXLen(), Gks-&gt;GetWidth());
349          const int SrcY = GetScreenCoord(SrcPointY, ZoomRect.GetMnY(), 
350              ZoomRect.GetYLen(), Gks-&gt;GetHeight());
351          const int DstX = GetScreenCoord(DstPointX, ZoomRect.GetMnX(), 
352              ZoomRect.GetXLen(), Gks-&gt;GetWidth());
353          const int DstY = GetScreenCoord(DstPointY, ZoomRect.GetMnY(), 
354              ZoomRect.GetYLen(), Gks-&gt;GetHeight());
355          PaintArrow(Gks, SrcX, SrcY, DstX, DstY, 3);
356      }
357  }
358  void TVizMapContext::PaintArrow(PGks Gks, const int&amp; SrcX, const int&amp; SrcY, 
359          const int&amp; DstX, const int&amp; DstY, const int&amp; Width) {
360      Gks-&gt;SetPen(TGksPen::New(ColorLink, gpmCopy, gpsSolid, Width));
361      Gks-&gt;Line(SrcX, SrcY, DstX, DstY);
362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
369      TLinAlg::Rotate(DirectionV[0], DirectionV[1], AngleRad, dxx, dyy);
370      const int dX2 = TFlt::Round(HeadSize*dxx);
371      const int dY2 = TFlt::Round(HeadSize*dyy);
372      TLinAlg::Rotate(DirectionV[0], DirectionV[1], -AngleRad, dxx, dyy);
373      const int dX3 = TFlt::Round(HeadSize*dxx);
374      const int dY3 = TFlt::Round(HeadSize*dyy);
375      TGksSPointV HeadPointV(3, 0);
376      HeadPointV.Add(TGksSPoint(DstX, DstY));
377      HeadPointV.Add(TGksSPoint(DstX-dX1+dX2, DstY-dY1+dY2));
378      HeadPointV.Add(TGksSPoint(DstX-dX1+dX3, DstY-dY1+dY3)); 
379      Gks-&gt;SetBrush(TGksBrush::New(ColorLink));
380      Gks-&gt;Polygon(HeadPointV);
381  }
382  void TVizMapContext::PaintPoints(PGks Gks, const int&amp; PointFontSize, 
383          const int&amp; PointNmFontScale, const double&amp; PointWgtThreshold, 
384          const int&amp; CatId, const bool&amp; ShowMgGlassP,
385          TVec&lt;TFltRect&gt;&amp; PointNmRectV) {
386      int Points = VizMapFrame-&gt;GetPoints();
387      TFltRect ZoomRect = GetZoomRect();
388      for (int PointN = 0; PointN &lt; Points; PointN++) {
389          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(PointN);
390          bool IsSelPointP = SelPointV.IsInBin(PointN);
391          if (IsSelPointP || ((NearPointN == PointN) &amp;&amp; !ShowMgGlassP)) { continue; }
392          const double PointX = Point-&gt;GetPointX(), PointY = Point-&gt;GetPointY();
393          if (ZoomRect.IsXYIn(PointX, PointY)) {
394              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
395                  ZoomRect.GetXLen(), Gks-&gt;GetWidth());
396              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
397                  ZoomRect.GetYLen(), Gks-&gt;GetHeight());
398              bool IsCatP = Point-&gt;IsCatId(CatId);
399              if (Point-&gt;IsPointNm() &amp;&amp; 
400                  ((Point-&gt;GetWgt() &gt; PointWgtThreshold) || IsSelPointP)) {
401                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
402                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
403              } else {
404                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
405              }
406          }
407      }
408      for (int SelPointN = 0; SelPointN &lt; SelPointV.Len(); SelPointN++) {
409          const int PointN = SelPointV[SelPointN];
410          if ((NearPointN == PointN) &amp;&amp; !ShowMgGlassP) { continue; }
411          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(PointN);
412          const double PointX = Point-&gt;GetPointX(), PointY = Point-&gt;GetPointY();
413          if (ZoomRect.IsXYIn(PointX, PointY)) {
414              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
415                  ZoomRect.GetXLen(), Gks-&gt;GetWidth());
416              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
417                  ZoomRect.GetYLen(), Gks-&gt;GetHeight());
418              bool IsCatP = Point-&gt;IsCatId(CatId);
419              if (Point-&gt;IsPointNm()) {
420                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
421                      PointFontSize, PointNmFontScale, true, IsCatP));
422              } else {
423                  PaintPointCross(Gks, X, Y, true, IsCatP);
424              }
425          }
426      }
427      if (!ShowMgGlassP &amp;&amp; (NearPointN != -1)) {
428          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(NearPointN);
429          const double PointX = Point-&gt;GetPointX(), PointY = Point-&gt;GetPointY();
430          if (ZoomRect.IsXYIn(PointX, PointY)) {
431              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
432                  ZoomRect.GetXLen(), Gks-&gt;GetWidth());
433              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
434                  ZoomRect.GetYLen(), Gks-&gt;GetHeight());
435              bool IsCatP = Point-&gt;IsCatId(CatId);
436              bool IsSelPointP = SelPointV.IsInBin(NearPointN);
437              if (Point-&gt;IsPointNm()) {
438                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
439                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
440              } else {
441                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
442              }
443          }
444      }
445  }
446  void TVizMapContext::PaintPointCross(PGks Gks, const int&amp; X, 
447          const int&amp; Y, const bool&amp; SelPointP, const bool&amp; IsCatP) {
448      Gks-&gt;SetPen(TGksPen::New(SelPointP ? ColorSelPointCross : ColorPointCross));
449      Gks-&gt;Line(X - SizePointCross, Y - SizePointCross, 
450                X + SizePointCross, Y + SizePointCross);
451      Gks-&gt;Line(X - SizePointCross, Y + SizePointCross, 
452                X + SizePointCross, Y - SizePointCross);
453      if (IsCatP) {
454          Gks-&gt;Line(X - SizePointCross + 1, Y - SizePointCross, 
455                    X + SizePointCross + 1, Y + SizePointCross);
456          Gks-&gt;Line(X - SizePointCross + 1, Y + SizePointCross, 
457                    X + SizePointCross + 1, Y - SizePointCross);
458      }
459  }
460  TFltRect TVizMapContext::PaintPointNm(PGks Gks, PVizMapPoint Point, const int&amp; X, 
461          const int&amp; Y, const int&amp; PointFontSize, const int&amp; PointNmFontScale, 
462          const bool&amp; SelPointP, const bool&amp; IsCatP) {
463      TStr PointNm = Point-&gt;GetPointNm(); 
464      PointNm.ChangeChAll(&#x27;_&#x27;, &#x27; &#x27;);
465      if (PointNm.IsStrIn(&quot;[[&quot;)) {
466          const int StartPos = PointNm.SearchStr(&quot;[[&quot;);
467          PointNm = PointNm.Left(StartPos - 1);
468      }
469      TGksColor FontColor = SelPointP ? ColorSelPointFont : ColorPointFont;
470      const int FontSize = PointFontSize + TFlt::Round(Point-&gt;GetWgt()*PointNmFontScale);
471      Gks-&gt;SetFont(TGksFont::New(&quot;ARIAL&quot;, FontSize, FontColor));
472      TStr ScreenPointNm = Gks-&gt;BreakTxt(PointNm, &quot; &quot;, &quot;&quot;, PointNmWidth, PointNmMxLines);
473      const int HalfTxtWidth = Gks-&gt;GetTxtWidth(ScreenPointNm) / 2;
474      const int HalfTxtHeight = Gks-&gt;GetTxtHeight(ScreenPointNm) / 2;
475      const int MnX = X - HalfTxtWidth;
476      int CurrY = Y - HalfTxtHeight;
<span onclick='openModal()' class='match'>477      TStrV LineV; ScreenPointNm.SplitOnAllCh(&#x27;\n&#x27;, LineV);
478      for (int LineN = 0; LineN &lt; LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks-&gt;GetTxtWidth(LineV[LineN]) / 2;
</span>480          const int LineHeight = Gks-&gt;GetTxtHeight(LineV[LineN]);
481          Gks-&gt;PutTxt(LineV[LineN], MnX + (HalfTxtWidth - HalfLineWidth), CurrY);
482          CurrY += LineHeight-3;
483      }
484      return TFltRect(X - HalfTxtWidth, Y - HalfTxtHeight,
485          X + HalfTxtWidth, Y + HalfTxtHeight - LineV.Len()*3);
486  }
487  void TVizMapContext::PaintCatNms(PGks Gks, const int&amp; KeyWdFontSize, 
488          TVec&lt;TFltRect&gt;&amp; PointNmRectV) {
489      TIntH CatH; TIntFltPrH CatPosH;
490      PBowDocBs BowDocBs = VizMapFrame-&gt;GetKeyWdBow();
491      const int Points = VizMapFrame-&gt;GetPoints();
492      for (int PointN = 0; PointN &lt; Points; PointN++) {
493          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(PointN);
494          const int DId = Point-&gt;GetDocId();
495          const int CIds = BowDocBs-&gt;GetDocCIds(DId);
496          for (int CIdN = 0; CIdN &lt; CIds; CIdN++) {
497              const int CId = BowDocBs-&gt;GetDocCId(DId, CIdN);
498              CatH.AddDat(CId)++;
499              CatPosH.AddDat(CId).Val1 += Point-&gt;GetPointX();
500              CatPosH.AddDat(CId).Val2 += Point-&gt;GetPointY();
501          }
502      }
503      CatH.SortByDat(false); 
504      const int TopCats = Points &gt; 100 ? 6 : 4; 
505      TFltRect ZoomRect = GetZoomRect();    
506      Gks-&gt;SetFont(TGksFont::New(&quot;ARIAL&quot;, KeyWdFontSize + 3, ColorCatNmFont));
507      TVec&lt;TFltRect&gt; CatNmRectV; TVec&lt;TFltV&gt; CatNmPosV;
508      const int MnSize = TInt::GetMn(Gks-&gt;GetWidth(), Gks-&gt;GetHeight());
509      const int MnDist = TFlt::Round(0.3 * double(MnSize));
510      int Cats = 0, CatKeyId = CatH.FFirstKeyId();
511      while (CatH.FNextKeyId(CatKeyId)) {
512          if (Cats == TopCats) { break; } 
513          if (double(CatH[CatKeyId]) / double(Points) &lt; 0.05) { break; } 
514          const int CId = CatH.GetKey(CatKeyId);
515          TStr CatNm = BowDocBs-&gt;GetCatNm(CId);
516          if (CatFullNmH.IsKey(CatNm)) {
517              CatNm = CatFullNmH.GetDat(CatNm);
518          } else { continue; }
519          TFltPr CatPos = CatPosH.GetDat(CId);
520          const int CatCount = CatH.GetDat(CId); IAssert(CatCount &gt; 0);
521          const double CatX = CatPos.Val1 / double(CatCount);
522          const double CatY = CatPos.Val2 / double(CatCount);
523          if (!ZoomRect.IsXYIn(CatX, CatY)) { continue; }
524          const int HalfTxtWidth = Gks-&gt;GetTxtWidth(CatNm) / 2;
525          const int HalfTxtHeight = Gks-&gt;GetTxtHeight(CatNm) / 2;
526          const int X = GetScreenCoord(CatX , ZoomRect.GetMnX(), 
527              ZoomRect.GetXLen(), Gks-&gt;GetWidth());
528          const int Y = GetScreenCoord(CatY, ZoomRect.GetMnY(), 
529              ZoomRect.GetYLen(), Gks-&gt;GetHeight());
530          int CatNmDist = MnSize; TFltV CatNmPos = TFltV::GetV(double(X), double(Y));
531          for (int CatNmPosN = 0; CatNmPosN &lt; CatNmPosV.Len(); CatNmPosN++) {
532              const double Dist = TLinAlg::EuclDist(CatNmPosV[CatNmPosN], CatNmPos);
533              CatNmDist = TInt::GetMn(TFlt::Round(Dist), CatNmDist);
534          }
535          if (CatNmDist &lt; MnDist) { continue; }
536          TFltRect CatNmRect(X - HalfTxtWidth, Y - HalfTxtHeight,
537              X + HalfTxtWidth, Y + HalfTxtHeight);
538          bool DoDraw = true; const int Rects = CatNmRectV.Len();
539          for (int RectN = 0; (RectN &lt; Rects) &amp;&amp; DoDraw; RectN++) {
540              DoDraw = !TFltRect::Intersection(CatNmRect, CatNmRectV[RectN]); }
541          if (!DoDraw) { continue; }
542          Gks-&gt;PutTxt(CatNm, X - HalfTxtWidth, Y - HalfTxtHeight); 
543          CatNmRectV.Add(CatNmRect); Cats++;
544          CatNmPosV.Add(CatNmPos);
545      }
546      PointNmRectV.AddV(CatNmRectV);
547  }
548  void TVizMapContext::PaintKeyWds(PGks Gks, const int&amp; KeyWdFontSize, 
549          TVec&lt;TFltRect&gt;&amp; PointNmRectV) {
550      Gks-&gt;SetFont(TGksFont::New(&quot;ARIAL&quot;, KeyWdFontSize, ColorKeyWdFont));
551      TFltRect ZoomRect = GetZoomRect();    
552      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
553      const double MnRptDist = RelMnRptDist * MnZoomRectSize;
554      const double Sparsity = RelSparsity * MnZoomRectSize;
555      TVizMapKeyWdV OkKeyWdV;
556      int KeyWds = VizMapFrame-&gt;GetKeyWds();
557      for (int KeyWdN = 0; KeyWdN &lt; KeyWds; KeyWdN++) {
558          PVizMapKeyWd KeyWd = VizMapFrame-&gt;GetKeyWd(KeyWdN);
559          TStr KeyWdStr = KeyWd-&gt;GetKeyWdStr().GetLc();
560          const double KeyWdX = KeyWd-&gt;GetKeyWdX();
561          const double KeyWdY = KeyWd-&gt;GetKeyWdY();
562          if (ZoomRect.IsXYIn(KeyWdX, KeyWdY)) {
563              const int X = GetScreenCoord(KeyWdX, ZoomRect.GetMnX(), 
564                  ZoomRect.GetXLen(), Gks-&gt;GetWidth());
565              const int Y = GetScreenCoord(KeyWdY, ZoomRect.GetMnY(), 
566                  ZoomRect.GetYLen(), Gks-&gt;GetHeight());
567              const int HalfTxtWidth = Gks-&gt;GetTxtWidth(KeyWdStr) / 2;
568              const int HalfTxtHeight = Gks-&gt;GetTxtHeight(KeyWdStr) / 2;
569              TFltRect KeyWdRect(X - HalfTxtWidth, Y - HalfTxtHeight,
570                  X + HalfTxtWidth, Y + HalfTxtHeight);
571              bool DoDrawP = true; const int Rects = PointNmRectV.Len();
572              for (int RectN = 0; RectN &lt; Rects; RectN++) {
573                  if (TFltRect::Intersection(KeyWdRect, PointNmRectV[RectN])) { 
574                      DoDrawP = false; break; }
575              }
576              if (!DoDrawP) { continue; } 
577              TFltV KeyWdCoodV = TFltV::GetV(KeyWdX, KeyWdY);
578              const int OkKeyWds = OkKeyWdV.Len(); bool KeyWdOkP = true;
579              for (int OkKeyWdN = 0; OkKeyWdN &lt; OkKeyWds; OkKeyWdN++) {
580                  PVizMapKeyWd OkKeyWd = OkKeyWdV[OkKeyWdN];
581                  TStr OkKeyWdStr = OkKeyWd-&gt;GetKeyWdStr().GetLc();
582                  const double Dist = TLinAlg::EuclDist(KeyWdCoodV, OkKeyWd-&gt;GetCoordV());
583                  if (Dist &lt; Sparsity) { KeyWdOkP = false; break; }
584                  if (OkKeyWdStr == KeyWdStr) {
585                      if (Dist &lt; MnRptDist) { KeyWdOkP = false; break; }
586                  }
587              }
588              if (!KeyWdOkP) { continue; } 
589              Gks-&gt;PutTxt(KeyWdStr, X - HalfTxtWidth, Y - HalfTxtHeight); 
590              PointNmRectV.Add(KeyWdRect); OkKeyWdV.Add(KeyWd);
591          }
592      }
593  }
594  void TVizMapContext::PaintZoomRect(PGks Gks) {
595      Gks-&gt;SetPen(TGksPen::New(ColorZoomRect, gpmCopy, gpsSolid, 2));
596      Gks-&gt;FrameRect(DownX, DownY, ScreenX, ScreenY);
597  }
598  void TVizMapContext::PaintMgGlass(PGks Gks, const int&amp; KeyWdFontSize) {
599      TFltRect ZoomRect = GetZoomRect();
600      int SizeX = TFlt::Round((MgGlassSize/ZoomRect.GetXLen()) * Gks-&gt;GetWidth());
601      int SizeY = TFlt::Round((MgGlassSize/ZoomRect.GetYLen()) * Gks-&gt;GetHeight());
602      Gks-&gt;SetBrush(TGksBrush::New(ColorMgGlass));
603      Gks-&gt;FillEllipse(ScreenX-SizeX, ScreenY-SizeY, ScreenX+SizeX, ScreenY+SizeY);
604      if (MgGlassKeyWdV.Len() &gt; 0) {
605          Gks-&gt;SetFont(TGksFont::New(&quot;ARIAL&quot;, KeyWdFontSize, TGksColor::GetBlack(), TFSet()|gfsBold));
606          TStr KeyWdStr = Gks-&gt;BreakTxt(MgGlassKeyWdV, &quot;, &quot;, &quot;,&quot;, MgGlassWindowWidth);       
607          TStr NearPointStr;
608          if (NearPointN != -1) {
609              PVizMapPoint NearPoint = VizMapFrame-&gt;GetPoint(NearPointN);
610              if (NearPoint-&gt;IsPointNm()) {
611                  TStr NearPointNm = NearPoint-&gt;GetPointNm();
612                  if (NearPointNm.IsStrIn(&quot;[[&quot;)) {
613                      const int StartPos = NearPointNm.SearchStr(&quot;[[&quot;);
614                      NearPointNm = NearPointNm.Left(StartPos - 1);
615                  }
616                  NearPointStr = Gks-&gt;BreakTxt(NearPointNm, 
617                      &quot; &quot;, &quot;&quot;, MgGlassWindowWidth, 1);
618                  NearPointStr.DelChAll(&#x27;\n&#x27;);
619                  NearPointStr += &quot;\n&quot;;
620              }
621          }
622          TStr DocCountStr = &quot;#documents = &quot; + MgGlassPoints.GetStr() + &quot;\n&quot;;
623          KeyWdStr = NearPointStr + DocCountStr + KeyWdStr;
624          int WndWidth = Gks-&gt;GetTxtWidth(KeyWdStr) + 6;
625          int WndHeight = Gks-&gt;GetTxtHeight(KeyWdStr) + 6;
626          int PosX = ScreenX + 20, PosY = ScreenY + 20;
627          if (PosX + WndWidth &gt; Gks-&gt;GetWidth()) {
628              PosX = ScreenX - 20 - WndWidth; }
629          if (PosY + WndHeight &gt; Gks-&gt;GetHeight()) {
630              PosY = ScreenY - 20 - WndHeight; }
631          Gks-&gt;SetBrush(TGksBrush::New(ColorMgGlassWndShadow));
632          Gks-&gt;FillRect(PosX + 5, PosY + 5, 
633              PosX + WndWidth + 5, PosY + WndHeight + 5);
634          Gks-&gt;SetBrush(TGksBrush::New(ColorMgGlassWnd));
635          Gks-&gt;SetPen(TGksPen::New(ColorMgGlassWndFrm));
636          Gks-&gt;Rectangle(PosX, PosY, 
637              PosX + WndWidth, PosY + WndHeight);
638          Gks-&gt;PutTxt(KeyWdStr, PosX+3, PosY+3);
639      }
640  }
641  void TVizMapContext::Export(const TStr&amp; FNm, const TStr&amp; EncoderType, const int&amp; Width, 
642          const int&amp; Height, const bool&amp; ShowPointNmP, const int&amp; PointFontSize, 
643          const int&amp; PointNmFontScale, const double&amp; PointWgtThreshold, const bool&amp; ShowCatNmP,
644          const bool&amp; ShowKeyWdP, const int&amp; KeyWdFontSize, const bool&amp; ShowMgGlassP, 
645          const int&amp; LegendGridWidth, const int&amp; LegendGridHeight) {
646      Gdiplus::Bitmap* Bmp = new Gdiplus::Bitmap(Width, Height);
647      Gdiplus::Graphics* g = Gdiplus::Graphics::FromImage(Bmp);
648      PGks BmpGks = TWfGks::New();
649      HDC HdcHandle = g-&gt;GetHDC(); BmpGks-&gt;BeginPaint(HdcHandle);
650      Paint(BmpGks, ShowPointNmP, PointFontSize, PointNmFontScale,
651          PointWgtThreshold, -1, ShowCatNmP, ShowKeyWdP, KeyWdFontSize, ShowMgGlassP, 
652          LegendGridWidth, LegendGridHeight);
653      BmpGks-&gt;EndPaint(); g-&gt;ReleaseHDC(HdcHandle);
654      WCHAR* FNmWChar = new WCHAR[FNm.Len() + 1];
655      const int Res = MultiByteToWideChar(CP_ACP, 0, 
656          FNm.CStr(), FNm.Len() + 1, FNmWChar, FNm.Len() + 1);
657      CLSID pngClsid; GetEncoderClsid(EncoderType, &amp;pngClsid);
658      Bmp-&gt;Save(FNmWChar, &amp;pngClsid, NULL);
659      delete FNmWChar; delete Bmp; delete g;
660  }
661  bool TVizMapContext::MouseMove(const int&amp; X, const int&amp; Y, 
662          const int&amp; Width, const int&amp; Height, const int&amp; MgGlassKeyWds) {
663      const int MoveDiff = TInt::Abs(X - ScreenX) + TInt::Abs(Y - ScreenY);
664      ScreenX = X; ScreenY = Y;
665      TFltRect ZoomRect = GetZoomRect();
666      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
667      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
668      if (!LeftButtonDownP &amp;&amp; (MoveDiff &gt; 0)) { 
669          ResetMgGlassKeyWd(MgGlassKeyWds);
670          ResetNearPointN();
671      }
672      return (MoveDiff &gt; 0);
673  }
674  void TVizMapContext::MouseLeftDown(const int&amp; X, 
675          const int&amp; Y, const int&amp; Width, const int&amp; Height) {
676      LeftButtonDownP = true;
677      DownX = X; DownY = Y;
678  }
679  void TVizMapContext::MouseLeftUp(const int&amp; X, 
680          const int&amp; Y, const int&amp; Width, const int&amp; Height) {
681      LeftButtonDownP = false;
682      TFltRect ZoomRect = GetZoomRect();
683      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
684      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
685      if (TInt::Abs(DownX - X) &gt; 10 &amp;&amp; TInt::Abs(DownY - Y) &gt; 10) {
686          const double StartX = GetMapCoord(DownX, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
687          const double StartY = GetMapCoord(DownY, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
688          if (IsZoomMode()) { 
689              ZoomIn(StartX, StartY, MouseX, MouseY); 
690          } else if (IsSelectMode()) {
691              Select(StartX, StartY, MouseX, MouseY);
692          }
693      } else {
694          SelectDoc(MouseX, MouseY);
695      }
696  }
697  void TVizMapContext::MouseWheel(const int&amp; Degree, const int&amp; MgGlassKeyWds) { 
698      MgGlassSize *= pow(TMath::E / 2, Degree); 
699      if (!LeftButtonDownP) { ResetMgGlassKeyWd(MgGlassKeyWds); }
700  }
701  void TVizMapContext::ZoomIn(const double&amp; X1, const double&amp; Y1, const double&amp; X2, const double&amp; Y2) { 
702      ZoomIn(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
703                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2))); 
704  }
705  void TVizMapContext::ZoomIn(const TFltRect&amp; ZoomInRect) { 
706      ZoomS.Push(ZoomInRect); 
707      RenderLandscapeBmp();
708      ResetMgGlassSize();
709      ResetKeyWd();
710  }
711  bool TVizMapContext::ZoomOut() { 
712      if (!ZoomS.Empty()) { 
713          ZoomS.Pop(); 
714          RenderLandscapeBmp(); 
715          ResetMgGlassSize();
716          ResetKeyWd();
717          return true;
718      } 
719      return false;
720  }
721  bool TVizMapContext::ZoomAll() { 
722      if (!ZoomS.Empty()) { 
723          ZoomS.Clr(); 
724          RenderLandscapeBmp(); 
725          ResetMgGlassSize();
726          ResetKeyWd();
727          return true;
728      }
729      return false;
730  }
731  void TVizMapContext::Select(const double&amp; X1, const double&amp; Y1, const double&amp; X2, const double&amp; Y2) {
732      Select(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
733                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2)));
734  }
735  void TVizMapContext::Select(const TFltRect&amp; SelRect) {
736      TIntV NewSelPointV; 
737      if (VizMapFrame-&gt;GetRectPointV(SelRect, NewSelPointV) &gt; 0) {
738          SelPointV.Union(NewSelPointV);
739      }
740  }
741  void TVizMapContext::Select(const int&amp; DocId) {
742      SelPointV.Clr();
743      int Points = VizMapFrame-&gt;GetPoints();
744      for (int PointN = 0; PointN &lt; Points; PointN++) {
745          PVizMapPoint Point = VizMapFrame-&gt;GetPoint(PointN);
746          if (Point-&gt;IsDocId() &amp;&amp; Point-&gt;GetDocId() == DocId) {
747              SelPointV.Add(PointN); break;
748          }
749      }
750      if (SelPointV.Empty()) {
751          const int Frames = VizMap-&gt;GetVizMapFrames();
752          for (int FrameN = 0; FrameN &lt; Frames; FrameN++) {
753              if (FrameN == VizMapFrameN) { continue; }
754              PVizMapFrame OtherFrame = VizMap-&gt;GetVizMapFrame(FrameN);
755              int Points = OtherFrame-&gt;GetPoints();
756              for (int PointN = 0; PointN &lt; Points; PointN++) {
757                  PVizMapPoint Point = OtherFrame-&gt;GetPoint(PointN);
758                  if (Point-&gt;IsDocId() &amp;&amp; Point-&gt;GetDocId() == DocId) {
759                      SelPointV.Add(PointN); SetVizMapFrame(FrameN); break;
760                  }
761              }
762          }
763      }
764  }
765  void TVizMapContext::GetSelectDIdV(TIntV&amp; DIdV) {
766      DIdV.Gen(SelPointV.Len(), 0);
767      const int SelPoints = SelPointV.Len();
768      for (int SelPointN = 0; SelPointN &lt; SelPoints; SelPointN++) {
769          DIdV.Add(VizMapFrame-&gt;GetPoint(SelPointV[SelPointN])-&gt;GetDocId());
770      }
771  }
772  void TVizMapContext::UnselectAll() {
773      SelPointV.Clr();
774  }
775  void TVizMapContext::SelectDoc(const double&amp; DocX, const double&amp; DocY) {
776      const int PointN = VizMapFrame-&gt;GetPointN(TFltV::GetV(DocX, DocY), 1.5);
777      if (IsZoomMode()) { 
778          if (PointN != -1) { 
779              SelPointV = TIntV::GetV(PointN); 
780          } else { 
781              SelPointV.Clr(); 
782          }
783      } else if (IsSelectMode()) {
784          if (PointN != -1) { 
785              if (SelPointV.IsInBin(PointN)) {
786                  SelPointV.DelIfIn(PointN);
787              } else {
788                  SelPointV.AddSorted(PointN); 
789              }
790          }
791      }
792  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1296      TStrV EltV; Str.SplitOnAllCh(&#x27;;&#x27;, EltV);
1297      for (int EltN = 0; EltN &lt; EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
</pre></code></div>
                <div class="column column_space"><pre><code>477      TStrV LineV; ScreenPointNm.SplitOnAllCh(&#x27;\n&#x27;, LineV);
478      for (int LineN = 0; LineN &lt; LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks-&gt;GetTxtWidth(LineV[LineN]) / 2;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    