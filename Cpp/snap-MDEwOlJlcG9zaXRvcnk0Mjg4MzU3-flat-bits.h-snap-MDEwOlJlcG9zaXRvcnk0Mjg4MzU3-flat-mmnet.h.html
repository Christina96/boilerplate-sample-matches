
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.363290537327627%, Tokens: 20</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.h</h3>
            <pre><code>1  #include "bd.h"
2  class TB1Def{
3  public:
4    typedef uchar TB1;
5    static const int B1Bits;
6    static const int MxP2Exp;
7    static const TB1 MxB1;
8    TB1* B1P2T;
9    int* B1BitsT;
10  public:
11    TB1Def();
12    ~TB1Def(){delete[] B1P2T; delete[] B1BitsT;}
13    TB1Def& operator=(const TB1Def&){Fail; return *this;}
14    static int GetB1Bits(const TB1& B1);
15    static uint GetP2(const int& P2Exp);
16    static int GetL2(const uchar& Val);
17    static bool GetBit(const int& BitN, const uchar& Val);
18    static const TB1Def B1Def;
19  };
20  class TB2Def{
21  public:
22    typedef unsigned short int TB2;
23    static const int B2Bits;
24    static const int MxP2Exp;
25    static const TB2 MxB2;
26    TB2* B2P2T;
27  public:
28    TB2Def();
29    ~TB2Def(){delete[] B2P2T;}
30    TB2Def& operator=(const TB2Def&){Fail; return *this;}
31    static int GetB2Bits(const TB2& B2);
32    static uint GetP2(const int& P2Exp);
33    static int GetL2(const TB2& Val);
34    static const TB2Def B2Def;
35  };
36  class TB4Def{
37  public:
38    typedef uint TB4;
39    static const int B4Bits;
40    static const int MxP2Exp;
41    static const TB4 MxB4;
42    TB4* B4P2T;
43  public:
44    TB4Def();
45    ~TB4Def(){delete[] B4P2T;}
46    TB4Def& operator=(const TB4Def&){Fail; return *this;}
47    static int GetB4Bits(const TB4& B4);
48    static uint GetP2(const int& P2Exp);
49    static int GetL2(const uint& Val);
50    static const TB4Def B4Def;
51  };
52  class TFSet{
53  private:
54    static const int B4s;
55    static const int Bits;
56    TUIntV B4V;
57  public:
58    TFSet(): B4V(4, 4){}
59    TFSet(const TFSet& FSet): B4V(FSet.B4V){}
60    TFSet(
61     const int& FlagN1, const int& FlagN2=-1, const int& FlagN3=-1,
62     const int& FlagN4=-1, const int& FlagN5=-1, const int& FlagN6=-1,
63     const int& FlagN7=-1, const int& FlagN8=-1, const int& FlagN9=-1);
64    TFSet(const TFSet& FSet1, const TFSet& FSet2):
65      B4V(4, 4){Incl(FSet1); Incl(FSet2);}
66    ~TFSet(){}
67    TFSet(TSIn& SIn): B4V(SIn){}
68    void Save(TSOut& SOut) const {B4V.Save(SOut);}
69    TFSet& operator=(const TFSet& FSet){
70      if (this!=&FSet){B4V=FSet.B4V;} return *this;}
71    bool operator==(const TFSet& FSet) const {return B4V==FSet.B4V;}
72    TFSet& operator|(const int& FlagN){Incl(FlagN); return *this;}
73    TFSet& operator|(const TFSet& FSet){Incl(FSet); return *this;}
74    void Clr(){
75      B4V[0]=0; B4V[1]=0; B4V[2]=0; B4V[3]=0;}
76    bool Empty() const {
77      return
78       (uint(B4V[0])==0)&&(uint(B4V[1])==0)&&
79       (uint(B4V[2])==0)&&(uint(B4V[3])==0);}
80    void Incl(const int& FlagN){
81      Assert((0<=FlagN)&&(FlagN<Bits));
82      B4V[FlagN/TB4Def::B4Def.B4Bits]|=
83       TB4Def::B4Def.B4P2T[FlagN%TB4Def::B4Def.B4Bits];}
84    void Incl(const TFSet& FSet){
85      B4V[0]|=FSet.B4V[0]; B4V[1]|=FSet.B4V[1];
86      B4V[2]|=FSet.B4V[2]; B4V[3]|=FSet.B4V[3];}
87    bool In(const int& FlagN) const {
88      Assert((0<=FlagN)&&(FlagN<Bits));
89      return (B4V[FlagN/TB4Def::B4Def.B4Bits] &
90       TB4Def::B4Def.B4P2T[FlagN%TB4Def::B4Def.B4Bits])!=0;}
91    static const TFSet EmptyFSet;
92  };
93  class TB8Set{
94  private:
95    static const int Bits;
96    TB1Def::TB1 B1;
97  public:
98    TB8Set(): B1(0){}
99    TB8Set(const TB8Set& B8Set): B1(B8Set.B1){}
100    TB8Set(const uchar& _B1): B1(_B1){}
101    TB8Set(TSIn& SIn){SIn.LoadBf(&B1, sizeof(TB1Def::TB1));}
102    void Save(TSOut& SOut) const {SOut.SaveBf(&B1, sizeof(TB1Def::TB1));}
103    TB8Set& operator=(const TB8Set& BSet){B1=BSet.B1; return *this;}
<span onclick='openModal()' class='match'>104    TB8Set& operator=(const uchar& _B1){B1=_B1; return *this;}
105    bool operator==(const TB8Set& BSet) const {return B1==BSet.B1;}
106    bool operator<(const TB8Set& BSet) const {return B1<BSet.B1;}
107    bool Empty() const {return B1==0;}
</span>108    TB8Set& Clr(){B1=0; return *this;}
109    TB8Set& Fill(){B1=TB1Def::B1Def.MxB1; return *this;}
110    bool IsPrefix(const TB8Set& BSet, const int& MnBitN) const {
111      Assert((0<=MnBitN)&&(MnBitN<Bits));
112      return (B1>>MnBitN)==(BSet.B1>>MnBitN);}
113    uchar GetUCh() const {return B1;}
114    void Incl(const int& BitN){
115      Assert((0<=BitN)&&(BitN<Bits));
116      B1|=TB1Def::B1Def.B1P2T[BitN];}
117    void Excl(const int& BitN){
118      Assert((0<=BitN)&&(BitN<Bits));
119      B1&=TB1Def::TB1(~(TB1Def::B1Def.B1P2T[BitN]));}
120    bool In(const int& BitN) const {
121      Assert((0<=BitN)&&(BitN<Bits));
122      return (B1 & TB1Def::B1Def.B1P2T[BitN])!=0;}
123    void SetBit(const int& BitN, const bool& Bool){
124      if (Bool) Incl(BitN); else Excl(BitN);}
125    bool GetBit(const int& BitN) const {
126      Assert((0<=BitN)&&(BitN<Bits));
127      return (B1 & TB1Def::B1Def.B1P2T[BitN])!=0;}
128    int GetBits() const {return Bits;}
129    int Get1s() const {return TB1Def::B1Def.GetB1Bits(B1);}
130    int Get0s() const {return Bits-Get1s();}
131    TStr GetStr() const;
132    void Wr();
133    void PutInt(const int& MnBitN, const int& MxBitN, const int& Val){
134      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
135      B1 &= TB1Def::TB1((~(TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1)) << MnBitN);
136      B1 |= TB1Def::TB1((Val & (TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1)) << MnBitN);}
137    int GetInt(const int& MnBitN, const int& MxBitN) const {
138      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
139      return (B1>>MnBitN) & (TB1Def::B1Def.B1P2T[MxBitN-MnBitN+1]-1);}
140    TB8Set& operator~(){B1=TB1Def::TB1(~B1); return *this;}
141    TB8Set& operator&=(const TB8Set& BSet){B1&=BSet.B1; return *this;}
142    TB8Set& operator|=(const TB8Set& BSet){B1|=BSet.B1; return *this;}
143    TB8Set& operator|=(const int& BitN){Incl(BitN); return *this;}
144    TB8Set& operator^=(const TB8Set& BSet){B1^=BSet.B1; return *this;}
145    TB8Set& operator>>=(const int& ShiftBits){B1>>=ShiftBits; return *this;}
146    TB8Set& operator<<=(const int& ShiftBits){B1<<=ShiftBits; return *this;}
147    friend TB8Set operator~(const TB8Set& BSet){
148      return ~TB8Set(BSet);}
149    friend TB8Set operator&(const TB8Set& LBSet, const TB8Set& RBSet){
150      return TB8Set(LBSet)&=RBSet;}
151    friend TB8Set operator|(const TB8Set& LBSet, const TB8Set& RBSet){
152      return TB8Set(LBSet)|=RBSet;}
153    friend TB8Set operator^(const TB8Set& LBSet, const TB8Set& RBSet){
154      return TB8Set(LBSet)^=RBSet;}
155  };
156  typedef TVec<TB8Set> TB8SetV;
157  class TB32Set{
158  private:
159    static const int Bits;
160    TB4Def::TB4 B4;
161  public:
162    TB32Set(): B4(0){}
163    TB32Set(const TB32Set& B32Set): B4(B32Set.B4){}
164    TB32Set(const uint& _B4): B4(_B4){}
165    TB32Set(TSIn& SIn){SIn.LoadBf(&B4, sizeof(TB4Def::TB4));}
166    void Save(TSOut& SOut) const {SOut.SaveBf(&B4, sizeof(TB4Def::TB4));}
167    TB32Set& operator=(const TB32Set& BSet){B4=BSet.B4; return *this;}
168    bool operator==(const TB32Set& BSet) const {return B4==BSet.B4;}
169    bool operator<(const TB32Set& BSet) const {return B4<BSet.B4;}
170    bool Empty() const {return B4==0;}
171    TB32Set& Clr(){B4=0; return *this;}
172    TB32Set& Fill(){B4=TB4Def::B4Def.MxB4; return *this;}
173    bool IsPrefix(const TB32Set& BSet, const int& MnBitN) const {
174      Assert((0<=MnBitN)&&(MnBitN<Bits));
175      return (B4>>MnBitN)==(BSet.B4>>MnBitN);}
176    uint GetUInt() const {return B4;}
177    void Incl(const int& BitN){
178      Assert((0<=BitN)&&(BitN<Bits));
179      B4|=TB4Def::B4Def.B4P2T[BitN];}
180    void Excl(const int& BitN){
181      Assert((0<=BitN)&&(BitN<Bits));
182      B4&=~TB4Def::B4Def.B4P2T[BitN];}
183    bool In(const int& BitN) const {
184      Assert((0<=BitN)&&(BitN<Bits));
185      return (B4 & TB4Def::B4Def.B4P2T[BitN])!=0;}
186    void SetBit(const int& BitN, const bool& Bool){
187      if (Bool) Incl(BitN); else Excl(BitN);}
188    bool GetBit(const int& BitN) const {
189      Assert((0<=BitN)&&(BitN<Bits));
190      return (B4 & TB4Def::B4Def.B4P2T[BitN])!=0;}
191    void SwitchBit(const int& BitN){
192      SetBit(BitN, !GetBit(BitN));}
193    int GetBits() const {return Bits;}
194    int Get1s() const {return TB4Def::B4Def.GetB4Bits(B4);}
195    int Get0s() const {return Bits-Get1s();}
196    TStr GetStr() const;
197    void Wr();
198    void PutInt(const int& MnBitN, const int& MxBitN, const int& Val){
199      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
200      B4 &= (~(TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1)) << MnBitN;
201      B4 |= (Val & (TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1)) << MnBitN;}
202    int GetInt(const int& MnBitN, const int& MxBitN) const {
203      Assert((0<=MnBitN)&&(MnBitN<=MxBitN)&&(MxBitN<Bits));
204      return (B4>>MnBitN) & (TB4Def::B4Def.B4P2T[MxBitN-MnBitN+1]-1);}
205    TB32Set& operator~(){B4=~B4; return *this;}
206    TB32Set& operator&=(const TB32Set& BSet){B4&=BSet.B4; return *this;}
207    TB32Set& operator|=(const TB32Set& BSet){B4|=BSet.B4; return *this;}
208    TB32Set& operator^=(const TB32Set& BSet){B4^=BSet.B4; return *this;}
209    TB32Set& operator>>=(const int& ShiftBits){B4>>=ShiftBits; return *this;}
210    TB32Set& operator<<=(const int& ShiftBits){B4<<=ShiftBits; return *this;}
211    friend TB32Set operator~(const TB32Set& BSet){
212      return ~TB32Set(BSet);}
213    friend TB32Set operator&(const TB32Set& LBSet, const TB32Set& RBSet){
214      return TB32Set(LBSet)&=RBSet;}
215    friend TB32Set operator|(const TB32Set& LBSet, const TB32Set& RBSet){
216      return TB32Set(LBSet)|=RBSet;}
217    friend TB32Set operator^(const TB32Set& LBSet, const TB32Set& RBSet){
218      return TB32Set(LBSet)^=RBSet;}
219  };
220  typedef TVec<TB32Set> TB32SetV;
221  ClassTPV(TBSet, PBSet, TBSetV)
222  private:
223    int B4s, Bits;
224    TB4Def::TB4 LastB4Mask;
225    TB4Def::TB4* B4T;
226    void SetLastB4(){B4T[B4s-1]&=LastB4Mask;}
227  public:
228    TBSet(): B4s(0), Bits(0), LastB4Mask(0), B4T(NULL){}
229    TBSet(const TBSet& BSet);
230    PBSet Clone() const {return PBSet(new TBSet(*this));}
231    TBSet(const int& _Bits):
232      B4s(0), Bits(0), LastB4Mask(0), B4T(NULL){Gen(_Bits);}
233    static PBSet New(const int& Bits){return PBSet(new TBSet(Bits));}
234    ~TBSet(){delete[] B4T;}
235    TBSet(TSIn& SIn){
236      SIn.Load(B4s); SIn.Load(Bits);
237      SIn.LoadBf(&LastB4Mask, sizeof(TB4Def::TB4));
238      B4T=(TB4Def::TB4*)SIn.LoadNewBf(B4s*sizeof(TB4Def::TB4));}
239    static PBSet Load(TSIn& SIn){return new TBSet(SIn);}
240    void Save(TSOut& SOut) const {
241      SOut.Save(B4s); SOut.Save(Bits);
242      SOut.SaveBf(&LastB4Mask, sizeof(TB4Def::TB4));
243      SOut.SaveBf(B4T, B4s*sizeof(TB4Def::TB4));}
244    TBSet& operator=(const TBSet& BSet);
245    bool operator==(const TBSet& BSet) const;
246    void Gen(const int& _Bits);
247    void Clr();
248    void Fill();
249    void Incl(const int& BitN){
250      Assert((0<=BitN)&&(BitN<Bits));
251      B4T[BitN/TB4Def::B4Def.B4Bits]|=
252       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits];}
253    void Excl(const int& BitN){
254      Assert((0<=BitN)&&(BitN<Bits));
255      B4T[BitN/TB4Def::B4Def.B4Bits]&=
256       ~TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits];}
257    bool In(const int& BitN) const {
258      Assert((0<=BitN)&&(BitN<Bits));
259      return (B4T[BitN/TB4Def::B4Def.B4Bits] &
260       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits])!=0;}
261    void SetBit(const int& BitN, const bool& Bool){
262      if (Bool){Incl(BitN);} else {Excl(BitN);}}
263    bool GetBit(const int& BitN) const {
264      Assert((0<=BitN)&&(BitN<Bits));
265      return (B4T[BitN/TB4Def::B4Def.B4Bits] &
266       TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits])!=0;}
267    void SwitchBit(const int& BitN){
268      SetBit(BitN, !GetBit(BitN));}
269    int GetBits() const {return Bits;}
270    int Get1s();
271    int Get0s(){return Bits-Get1s();}
272    uint64 GetUInt64() const {
273      Assert(Bits>=64); uint64 Val; memcpy(&Val, B4T, 8); return Val;}
274    void Wr();
275    TBSet& operator~(){
276      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=~B4T[B4N];} return *this;}
277    TBSet& operator&=(const TBSet& BSet){
278      Assert(B4s==BSet.B4s);
279      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]&=BSet.B4T[B4N];} return *this;}
280    TBSet& operator|=(const TBSet& BSet){
281      Assert(B4s==BSet.B4s);
282      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]|=BSet.B4T[B4N];} return *this;}
283    TBSet& operator|=(const int& BitN){
284      Incl(BitN); return *this;}
285    TBSet& operator^=(const TBSet& BSet){
286      Assert(B4s==BSet.B4s);
287      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]^=BSet.B4T[B4N];} return *this;}
288    friend TBSet operator~(const TBSet& BSet){
289      return ~TBSet(BSet);}
290    friend TBSet operator&(const TBSet& LBSet, const TBSet& RBSet){
291      return TBSet(LBSet)&=RBSet;}
292    friend TBSet operator|(const TBSet& LBSet, const TBSet& RBSet){
293      return TBSet(LBSet)|=RBSet;}
294    friend TBSet operator^(const TBSet& LBSet, const TBSet& RBSet){
295      return TBSet(LBSet)^=RBSet;}
296    friend TBSet operator&(const TBSet& LBSet, const int& BitN){
297      return TBSet(LBSet)&=BitN;}
298    friend TBSet operator|(const TBSet& LBSet, const int& BitN){
299      return TBSet(LBSet)|=BitN;}
300    friend TBSet operator^(const TBSet& LBSet, const int& BitN){
301      return TBSet(LBSet)^=BitN;}
302  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</h3>
            <pre><code>1  #ifndef MMNET_H
2  #define MMNET_H
3  class TMMNet;
4  typedef TPt<TMMNet> PMMNet;
5  class TModeNet;
6  class TCrossNet;
7  class TModeNet : public TNEANet {
8  public:
9    typedef TModeNet TNetMM;
10  public:
11    class TNodeI : public TNEANet::TNodeI {
12    public:
13      TNodeI() : TNEANet::TNodeI() { }
14      TNodeI(const THashIter& NodeHIter, const TModeNet* GraphPt) : TNEANet::TNodeI(NodeHIter, GraphPt) { }
15      TNodeI(const TNodeI& NodeI) : TNEANet::TNodeI(NodeI) { }
16      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
17      TNodeI& operator++ (int) { NodeHI++; return *this; }
18      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
19      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
20      void GetNeighborsByCrossNet(TStr& Name, TIntV& Neighbors, const bool isOutEId=false) {
21          const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetNeighborsByCrossNet(GetId(), Name, Neighbors, isOutEId); }
22      void GetCrossNetNames(TStrV& Names) { const TModeNet *TMGraph = static_cast<const TModeNet *>(Graph); TMGraph->GetCrossNetNames(Names); }
23      friend class TModeNet;
24    };
25  private:
26    TInt ModeId;
27    TMMNet *MMNet; 
28    THash<TStr, TBool> NeighborTypes; 
29  public:
30    TModeNet() : TNEANet(), ModeId(-1), MMNet(), NeighborTypes() { }
31    TModeNet(const int& TypeId) : TNEANet(), ModeId(TypeId), MMNet(), NeighborTypes() { }
32    explicit TModeNet(const int& Nodes, const int& Edges) : TNEANet(Nodes, Edges),
33      ModeId(-1), MMNet(), NeighborTypes(){ }
34    explicit TModeNet(const int& Nodes, const int& Edges, const int& TypeId) : TNEANet(Nodes, Edges),
35      ModeId(TypeId), MMNet(), NeighborTypes() { }
36    TModeNet(const TModeNet& Graph) :  TNEANet(true, Graph), ModeId(Graph.ModeId), MMNet(Graph.MMNet), NeighborTypes(Graph.NeighborTypes) { }
37    TModeNet(TSIn& SIn) : TNEANet(SIn), ModeId(SIn), MMNet(), NeighborTypes(SIn) { }
38  private:
39    TModeNet(const TModeNet& Graph, bool isSubModeGraph) : TNEANet(Graph, isSubModeGraph), ModeId(Graph.ModeId), MMNet(), NeighborTypes() {}
40  public:
41    void Save(TSOut& SOut) const {
42      TNEANet::Save(SOut); ModeId.Save(SOut); NeighborTypes.Save(SOut); SOut.Flush(); }
43    void LoadShM(TShMIn & ShMIn) {
44      TNEANet::LoadNetworkShM(ShMIn);
45      ModeId = TInt(ShMIn);
46      MMNet = NULL;
47      NeighborTypes.LoadShM(ShMIn);
48    }
49    void DelNode(const int& NId);
50    void GetCrossNetNames(TStrV& Names) const { NeighborTypes.GetKeyV(Names); }
51    void GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId=false) const;
52    TNodeI BegMMNI() const { return TNodeI(NodeH.BegI(), this); }
53    TNodeI EndMMNI() const { return TNodeI(NodeH.EndI(), this); }
54    TNodeI GetMMNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
55    void Clr();
56    TModeNet& operator = (const TModeNet& Graph) { 
57      if (this!=&Graph) {
58        MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH;
59        KeyToIndexTypeN=Graph.KeyToIndexTypeN; KeyToIndexTypeE=Graph.KeyToIndexTypeE;
60        KeyToDenseN = Graph.KeyToDenseN; KeyToDenseE = Graph.KeyToDenseE;
61        IntDefaultsN=Graph.IntDefaultsN; IntDefaultsE=Graph.IntDefaultsE; StrDefaultsN=Graph.StrDefaultsN; StrDefaultsE=Graph.StrDefaultsE;
62        FltDefaultsN=Graph.FltDefaultsN; FltDefaultsE=Graph.FltDefaultsE; VecOfIntVecsN=Graph.VecOfIntVecsN; VecOfIntVecsE=Graph.VecOfIntVecsE;
63        VecOfStrVecsN=Graph.VecOfStrVecsN; VecOfStrVecsE=Graph.VecOfStrVecsE; VecOfFltVecsN=Graph.VecOfFltVecsN; VecOfFltVecsE=Graph.VecOfFltVecsE;
64        VecOfIntVecVecsN=Graph.VecOfIntVecVecsN; VecOfIntVecVecsE=Graph.VecOfIntVecVecsE; 
65        VecOfIntHashVecsN = Graph.VecOfIntHashVecsN; VecOfIntHashVecsE = Graph.VecOfIntHashVecsE; SAttrN=Graph.SAttrN; SAttrE=Graph.SAttrE;
66        ModeId=Graph.ModeId; MMNet=Graph.MMNet; NeighborTypes=Graph.NeighborTypes;
67      }
68      return *this; 
69    }
70  private:
71    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const int linkId, const bool sameMode, bool isDir);
72    int AddNeighbor(const int& NId, const int& EId, const bool outEdge, const TStr& linkName, const bool sameMode, bool isDir);
73    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir);
74    int DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir);
75    TStr GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const;
76    void SetParentPointer(TMMNet* parent);
77    int AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir);
78    int AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense=true);
79    int AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs);
80    void RemoveCrossNets(TModeNet& Result, TStrV& CrossNets);
81    int DelNbrType(const TStr& CrossName);
82    int GetAttrTypeN(const TStr& attr) const;
83    void ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir);
84  public:
85    friend class TMMNet;
86    friend class TCrossNet;
87  };
88  class TCrossNet {
89  public:
90    class TCrossEdge {
91    private:
92      TInt EId;
93      TInt SrcNId, DstNId;
94    public:
95      TCrossEdge() : EId(-1), SrcNId(-1), DstNId(-1) { }
96      TCrossEdge(const int& Id, const int& SourceNId, const int& DestNId) :
97        EId(Id), SrcNId(SourceNId), DstNId(DestNId) { }
98      TCrossEdge(const TCrossEdge& MultiEdge) : EId(MultiEdge.EId), SrcNId(MultiEdge.SrcNId),
99          DstNId(MultiEdge.DstNId) { }
100      TCrossEdge(TSIn& SIn) : EId(SIn), SrcNId(SIn), DstNId(SIn) { }
101      void Save(TSOut& SOut) const { EId.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
102      int GetId() const { return EId; }
103      int GetSrcNId() const { return SrcNId; }
104      int GetDstNId() const { return DstNId; }
105      size_t GetMemUsed() const { return EId.GetMemUsed() + SrcNId.GetMemUsed() + DstNId.GetMemUsed(); }
106      friend class TCrossNet;
107    };
108    class TCrossEdgeI {
109    private:
110      typedef THash<TInt, TCrossEdge>::TIter THashIter;
111      THashIter CrossHI;
112      const TCrossNet *Graph;
113    public:
114      TCrossEdgeI() : CrossHI(), Graph(NULL) { }
115      TCrossEdgeI(const THashIter& CrossHIter, const TCrossNet *GraphPt) : CrossHI(CrossHIter), Graph(GraphPt) { }
116      TCrossEdgeI(const TCrossEdgeI& EdgeI) : CrossHI(EdgeI.CrossHI), Graph(EdgeI.Graph) { }
117      TCrossEdgeI& operator = (const TCrossEdgeI& EdgeI) { if (this!=&EdgeI) { CrossHI=EdgeI.CrossHI; Graph=EdgeI.Graph; }  return *this; }
118      TCrossEdgeI& operator++ (int) { CrossHI++; return *this; }
119      bool operator < (const TCrossEdgeI& EdgeI) const { return CrossHI < EdgeI.CrossHI; }
120      bool operator == (const TCrossEdgeI& EdgeI) const { return CrossHI == EdgeI.CrossHI; }
121      int GetId() const { return CrossHI.GetDat().GetId(); }
122      int GetSrcNId() const { return CrossHI.GetDat().GetSrcNId(); }
123      int GetDstNId() const { return CrossHI.GetDat().GetDstNId(); }
124      int GetSrcModeId() const { return Graph->GetMode1(); }
125      int GetDstModeId() const { return Graph->GetMode2(); }
126      bool IsDirected() const { return Graph->IsDirected(); }
127      friend class TCrossNet;
128    };
129    class TAIntI {
130    private:
131      typedef TIntV::TIter TIntVecIter;
132      TIntVecIter HI;
133      TStr attr;
134      const TCrossNet *Graph;
135    public:
136      TAIntI() : HI(), attr(), Graph(NULL) { }
137      TAIntI(const TIntVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
138      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
<span onclick='openModal()' class='match'>139      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
140      bool operator < (const TAIntI& I) const { return HI < I.HI; }
141      bool operator == (const TAIntI& I) const { return HI == I.HI; }
142      TInt GetDat() const { return HI[0]; }
</span>143      bool IsDeleted() const { return GetDat() == Graph->GetIntAttrDefaultE(attr); };
144      TAIntI& operator++(int) { HI++; return *this; }
145      friend class TCrossNet;
146    };
147    class TAStrI {
148    private:
149      typedef TStrV::TIter TStrVecIter;
150      TStrVecIter HI;
151      TStr attr;
152      const TCrossNet *Graph;
153    public:
154      TAStrI() : HI(), attr(), Graph(NULL) { }
155      TAStrI(const TStrVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
156      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
157      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
158      bool operator < (const TAStrI& I) const { return HI < I.HI; }
159      bool operator == (const TAStrI& I) const { return HI == I.HI; }
160      TStr GetDat() const { return HI[0]; }
161      bool IsDeleted() const { return GetDat() == Graph->GetStrAttrDefaultE(attr); };
162      TAStrI& operator++(int) { HI++; return *this; }
163      friend class TCrossNet;
164    };
165    class TAFltI {
166    private:
167      typedef TFltV::TIter TFltVecIter;
168      TFltVecIter HI;
169      TStr attr;
170      const TCrossNet *Graph;
171    public:
172      TAFltI() : HI(), attr(), Graph(NULL) { }
173      TAFltI(const TFltVecIter& HIter, TStr attribute, const TCrossNet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { attr = attribute; }
174      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { }
175      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
176      bool operator < (const TAFltI& I) const { return HI < I.HI; }
177      bool operator == (const TAFltI& I) const { return HI == I.HI; }
178      TFlt GetDat() const { return HI[0]; }
179      bool IsDeleted() const { return GetDat() == Graph->GetFltAttrDefaultE(attr); };
180      TAFltI& operator++(int) { HI++; return *this; }
181      friend class TCrossNet;
182    };
183  private:
184    class TLoadVecInit {
185    public:
186      TLoadVecInit() {}
187      template<typename TElem>
188      void operator() (TVec<TElem>* Node, TShMIn& ShMIn) {
189        Node->LoadShM(ShMIn);
190      }
191    };
192  private:
193    THash<TInt,TCrossEdge> CrossH; 
194    TInt MxEId;
195    TInt Mode1; 
196    TInt Mode2; 
197    TBool IsDirect;
198    TInt CrossNetId;
199    TMMNet* Net;
200    TStrIntPrH KeyToIndexTypeE;
201    THash<TStr, TInt> IntDefaultsE;
202    THash<TStr, TStr> StrDefaultsE;
203    THash<TStr, TFlt> FltDefaultsE;
204    TVec<TIntV> VecOfIntVecsE;
205    TVec<TStrV> VecOfStrVecsE;
206    TVec<TFltV> VecOfFltVecsE;
207    enum { IntType, StrType, FltType };
208  public:
209    TCrossNet() : CrossH(), MxEId(0), Mode1(-1), Mode2(-1), IsDirect(), CrossNetId(), Net(), KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(),
210      FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
211    TCrossNet(TInt MId1, TInt MId2, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(true),CrossNetId(LId), Net(),
212      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
213    TCrossNet(TInt MId1, TInt MId2, TBool IsDir, TInt LId) : CrossH(), MxEId(0), Mode1(MId1), Mode2(MId2), IsDirect(IsDir),CrossNetId(LId), Net(),
214      KeyToIndexTypeE(), IntDefaultsE(), StrDefaultsE(), FltDefaultsE(), VecOfIntVecsE(), VecOfStrVecsE(), VecOfFltVecsE() {}
215    TCrossNet(TSIn& SIn) : CrossH(SIn), MxEId(SIn), Mode1(SIn), Mode2(SIn), IsDirect(SIn), CrossNetId(SIn), Net(),
216      KeyToIndexTypeE(SIn), IntDefaultsE(SIn), StrDefaultsE(SIn), FltDefaultsE(SIn), VecOfIntVecsE(SIn), VecOfStrVecsE(SIn), VecOfFltVecsE(SIn) {}
217    TCrossNet(const TCrossNet& OtherTCrossNet) : CrossH(OtherTCrossNet.CrossH), MxEId(OtherTCrossNet.MxEId), Mode1(OtherTCrossNet.Mode1),
218      Mode2(OtherTCrossNet.Mode2), IsDirect(OtherTCrossNet.IsDirect), CrossNetId(OtherTCrossNet.CrossNetId),Net(OtherTCrossNet.Net), KeyToIndexTypeE(OtherTCrossNet.KeyToIndexTypeE), 
219      IntDefaultsE(OtherTCrossNet.IntDefaultsE), StrDefaultsE(OtherTCrossNet.StrDefaultsE), FltDefaultsE(OtherTCrossNet.FltDefaultsE), VecOfIntVecsE(OtherTCrossNet.VecOfIntVecsE),
220      VecOfStrVecsE(OtherTCrossNet.VecOfStrVecsE), VecOfFltVecsE(OtherTCrossNet.VecOfFltVecsE) {}
221    TCrossNet& operator=(const TCrossNet& OtherTCrossNet) {
222      CrossH = OtherTCrossNet.CrossH;
223      MxEId = OtherTCrossNet.MxEId;
224      Mode1 = OtherTCrossNet.Mode1;
225      Mode2 = OtherTCrossNet.Mode2;
226      CrossNetId = OtherTCrossNet.CrossNetId;
227      IsDirect = OtherTCrossNet.IsDirect;
228      Net = OtherTCrossNet.Net;
229      KeyToIndexTypeE = OtherTCrossNet.KeyToIndexTypeE;
230      IntDefaultsE = OtherTCrossNet.IntDefaultsE;
231      StrDefaultsE = OtherTCrossNet.StrDefaultsE;
232      FltDefaultsE = OtherTCrossNet.FltDefaultsE;
233      VecOfIntVecsE = OtherTCrossNet.VecOfIntVecsE;
234      VecOfStrVecsE = OtherTCrossNet.VecOfStrVecsE;
235      VecOfFltVecsE = OtherTCrossNet.VecOfFltVecsE;
236      return *this;
237    }
238  private:
239    void SetParentPointer(TMMNet* parent);
240    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
241    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
242    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
243    int GetAttrTypeE(const TStr& attr) const;
244    TCrossEdge& GetEdge(int eid) { return CrossH[eid]; }
245  public:
246    bool IsEdge(const int& EId) const { return CrossH.IsKey(EId); }
247    int GetMxEId() const { return MxEId; }
248    int GetEdges() const { return CrossH.Len(); }
249    void Clr();
250    int AddEdge(const int& sourceNId, const int& destNId, int EId=-1);
251    TCrossEdgeI GetEdgeI(const int& EId) const { return TCrossEdgeI(CrossH.GetI(EId), this); }
252    TCrossEdgeI BegEdgeI() const { return TCrossEdgeI(CrossH.BegI(), this); }
253    TCrossEdgeI EndEdgeI() const { return TCrossEdgeI(CrossH.EndI(), this); }
254    int DelEdge(const int& EId);
255    int GetMode1() const { return Mode1; }
256    int GetMode2() const {return Mode2; }
257    void Save(TSOut& SOut) const { CrossH.Save(SOut); MxEId.Save(SOut); Mode1.Save(SOut); Mode2.Save(SOut); IsDirect.Save(SOut); CrossNetId.Save(SOut); 
258      KeyToIndexTypeE.Save(SOut); IntDefaultsE.Save(SOut); StrDefaultsE.Save(SOut); FltDefaultsE.Save(SOut); VecOfIntVecsE.Save(SOut);
259      VecOfStrVecsE.Save(SOut); VecOfFltVecsE.Save(SOut); SOut.Flush(); }
260    void LoadShM(TShMIn& ShMIn) {
261      CrossH.LoadShM(ShMIn);
262      MxEId = TInt(ShMIn);
263      Mode1 = TInt(ShMIn);
264      Mode2 = TInt(ShMIn);
265      IsDirect = TBool(ShMIn);
266      CrossNetId = TInt(ShMIn);
267      Net = NULL;
268      KeyToIndexTypeE.LoadShM(ShMIn);
269      IntDefaultsE.LoadShM(ShMIn);
270      StrDefaultsE.LoadShM(ShMIn);
271      FltDefaultsE.LoadShM(ShMIn);
272      TLoadVecInit VecFn;
273      VecOfIntVecsE.LoadShM(ShMIn, VecFn);
274      VecOfStrVecsE.Load(ShMIn);
275      VecOfFltVecsE.Load(ShMIn);
276    }
277    bool IsDirected() const { return IsDirect;}
278    void AttrNameEI(const TInt& EId, TStrV& Names) const {
279      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
280    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
281    void AttrValueEI(const TInt& EId, TStrV& Values) const {
282      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
283    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
284    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
285      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
286    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
287    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
288      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
289    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const;
290    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
291      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
292    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
293    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
294      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
295    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const;
296    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
297      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
298    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const;
299    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
300      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
301    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const;
302    int AddIntAttrDatE(const TCrossEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeI.GetId(), value, attr); }
303    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
304    int AddStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeI.GetId(), value, attr); }
305    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
306    int AddFltAttrDatE(const TCrossEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeI.GetId(), value, attr); }
307    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
308    TInt GetIntAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetIntAttrDatE(EdgeI.GetId(), attr); }
309    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
310    TStr GetStrAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetStrAttrDatE(EdgeI.GetId(), attr); }
311    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
312    TFlt GetFltAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return GetFltAttrDatE(EdgeI.GetId(), attr); }
313    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
314    TAIntI BegEAIntI(const TStr& attr) const {
315      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
316    }
317    TAIntI EndEAIntI(const TStr& attr) const {
318      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
319    }
320    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
321      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
322    }
323    TAStrI BegEAStrI(const TStr& attr) const {
324      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);   }
325    TAStrI EndEAStrI(const TStr& attr) const {
326      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
327    }
328    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
329      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
330    }
331    TAFltI BegEAFltI(const TStr& attr) const {
332      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, this);
333    }
334    TAFltI EndEAFltI(const TStr& attr) const {
335      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, this);
336    }
337    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
338      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(CrossH.GetKeyId(EId)), attr, this);
339    }
340    int DelAttrDatE(const TCrossEdgeI& EdgeI, const TStr& attr) { return DelAttrDatE(EdgeI.GetId(), attr); } 
341    int DelAttrDatE(const int& EId, const TStr& attr); 
342    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
343    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
344    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
345    int DelAttrE(const TStr& attr);
346    bool IsAttrDeletedE(const int& EId, const TStr& attr) const;
347    bool IsIntAttrDeletedE(const int& EId, const TStr& attr) const;
348    bool IsStrAttrDeletedE(const int& EId, const TStr& attr) const;
349    bool IsFltAttrDeletedE(const int& EId, const TStr& attr) const;
350    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
351    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
352    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
353    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
354    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const;
355    friend class TMMNet;
356    friend class TModeNet;
357  };
358  class TMMNet {
359  public:
360    class TModeNetI {
361    protected:
362      typedef THash<TInt, TModeNet>::TIter THashIter;
363      THashIter ModeNetHI;
364      const TMMNet *Graph;
365    public:
366      TModeNetI() : ModeNetHI(), Graph(NULL) { }
367      TModeNetI(const THashIter& ModeNetHIter, const TMMNet* GraphPt) : ModeNetHI(ModeNetHIter), Graph(GraphPt) { }
368      TModeNetI(const TModeNetI& ModeNetI) : ModeNetHI(ModeNetI.ModeNetHI), Graph(ModeNetI.Graph) { }
369      TModeNetI& operator = (const TModeNetI& ModeNetI) { ModeNetHI = ModeNetI.ModeNetHI; Graph=ModeNetI.Graph; return *this; }
370      TModeNetI& operator++ (int) { ModeNetHI++; return *this; }
371      bool operator < (const TModeNetI& ModeNetI) const { return ModeNetHI < ModeNetI.ModeNetHI; }
372      bool operator == (const TModeNetI& ModeNetI) const { return ModeNetHI == ModeNetI.ModeNetHI; }
373      int GetModeId() { return ModeNetHI.GetKey(); }
374      TStr GetModeName() { return Graph->GetModeName(ModeNetHI.GetKey()); }
375      TModeNet& GetModeNet() { return Graph->GetModeNetById(GetModeId()); }
376      friend class TMMNet;
377    };
378    class TCrossNetI {
379    protected:
380      typedef THash<TInt, TCrossNet>::TIter THashIter;
381      THashIter CrossNetHI;
382      const TMMNet *Graph;
383    public:
384      TCrossNetI() : CrossNetHI(), Graph(NULL) { }
385      TCrossNetI(const THashIter& CrossNetHIter, const TMMNet* GraphPt) : CrossNetHI(CrossNetHIter), Graph(GraphPt) { }
386      TCrossNetI(const TCrossNetI& CrossNetI) : CrossNetHI(CrossNetI.CrossNetHI), Graph(CrossNetI.Graph) { }
387      TCrossNetI& operator = (const TCrossNetI& CrossNetI) { CrossNetHI = CrossNetI.CrossNetHI; Graph=CrossNetI.Graph; return *this; }
388      TCrossNetI& operator++ (int) { CrossNetHI++; return *this; }
389      bool operator < (const TCrossNetI& CrossNetI) const { return CrossNetHI < CrossNetI.CrossNetHI; }
390      bool operator == (const TCrossNetI& CrossNetI) const { return CrossNetHI == CrossNetI.CrossNetHI; }
391      int GetCrossId() { return CrossNetHI.GetKey(); }
392      TStr GetCrossName() { return Graph->GetCrossName(CrossNetHI.GetKey()); }
393      TCrossNet& GetCrossNet() { return Graph->GetCrossNetById(GetCrossId()); }
394      friend class TMMNet;
395    };
396  public:
397    TCRef CRef; 
398  private:
399    TInt MxModeId; 
400    TInt MxCrossNetId; 
401    THash<TInt, TModeNet> TModeNetH;
402    THash<TInt, TCrossNet> TCrossNetH;
403    THash<TInt,TStr> ModeIdToNameH;
404    THash<TStr,TInt> ModeNameToIdH;
405    THash<TInt,TStr> CrossIdToNameH;
406    THash<TStr,TInt> CrossNameToIdH;
407  public:
408    friend class TCrossNet;
409    friend class TModeNet;
410  private:
411    class TModeNetInit {
412    public:
413      TModeNetInit() {}
414      void operator() (TModeNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
415    };
416    class TCrossNetInit {
417    public:
418      TCrossNetInit() {}
419      void operator() (TCrossNet* Node, TShMIn& ShMIn) { Node->LoadShM(ShMIn);}
420    };
421  private:
422    void LoadNetworkShM(TShMIn& ShMIn);
423  public:
424    TMMNet() : CRef(), MxModeId(0), MxCrossNetId(0), TModeNetH(), TCrossNetH(), ModeIdToNameH(), ModeNameToIdH(), CrossIdToNameH(), CrossNameToIdH() {}
425    TMMNet(const TMMNet& OtherTMMNet) : MxModeId(OtherTMMNet.MxModeId), MxCrossNetId(OtherTMMNet.MxCrossNetId), TModeNetH(OtherTMMNet.TModeNetH), 
426      TCrossNetH(OtherTMMNet.TCrossNetH), ModeIdToNameH(OtherTMMNet.ModeIdToNameH), ModeNameToIdH(OtherTMMNet.ModeNameToIdH), CrossIdToNameH(OtherTMMNet.CrossIdToNameH), CrossNameToIdH(OtherTMMNet.CrossNameToIdH) {}
427    TMMNet(TSIn& SIn) : MxModeId(SIn), MxCrossNetId(SIn), TModeNetH(SIn), TCrossNetH(SIn), ModeIdToNameH(SIn), ModeNameToIdH(SIn), CrossIdToNameH(SIn), CrossNameToIdH(SIn) { 
428      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
429        it.GetDat().SetParentPointer(this);
430      }
431      for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
432        it.GetDat().SetParentPointer(this);
433      }
434    }
435    int AddModeNet(const TStr& ModeName);
436    int DelModeNet(const TInt& ModeId); 
437    int DelModeNet(const TStr& ModeName);
438    int AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir=true);
439    int AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir=true);
440    int DelCrossNet(const TInt& CrossNetId);
441    int DelCrossNet(const TStr& CrossNet);
442    void Save(TSOut& SOut) const { MxModeId.Save(SOut); MxCrossNetId.Save(SOut); TModeNetH.Save(SOut); 
443      TCrossNetH.Save(SOut); ModeIdToNameH.Save(SOut); ModeNameToIdH.Save(SOut); CrossIdToNameH.Save(SOut);
444      CrossNameToIdH.Save(SOut); SOut.Flush(); }
445    static PMMNet Load(TSIn& SIn) { return PMMNet(new TMMNet(SIn)); }
446    static PMMNet LoadShM(TShMIn& ShMIn) {
447      TMMNet* Network = new TMMNet();
448      Network->LoadNetworkShM(ShMIn);
449      return PMMNet(Network);
450    }
451    static PMMNet New() { return PMMNet(new TMMNet()); }
452    void ConvertToSparse() {
453      for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
454        it.GetDat().ConvertToSparse();
455      }
456    }
457    int GetModeId(const TStr& ModeName) const { if (ModeNameToIdH.IsKey(ModeName)) { return ModeNameToIdH.GetDat(ModeName); } else { return -1; }  }
458    TStr GetModeName(const TInt& ModeId) const { if (ModeIdToNameH.IsKey(ModeId)) { return ModeIdToNameH.GetDat(ModeId); } else {return TStr::GetNullStr();} }
459    int GetCrossId(const TStr& CrossName) const { if (CrossNameToIdH.IsKey(CrossName)) { return CrossNameToIdH.GetDat(CrossName); } else { return -1; }   }
460    TStr GetCrossName(const TInt& CrossId) const { if (CrossIdToNameH.IsKey(CrossId)) { return CrossIdToNameH.GetDat(CrossId); } else { return TStr::GetNullStr(); }  }
461    TModeNet& GetModeNetByName(const TStr& ModeName) const;
462    TModeNet& GetModeNetById(const TInt& ModeId) const;
463    TCrossNet& GetCrossNetByName(const TStr& CrossName) const;
464    TCrossNet& GetCrossNetById(const TInt& CrossId) const;
465    TCrossNetI GetCrossNetI(const int& Id) const { return TCrossNetI(TCrossNetH.GetI(Id), this); }
466    TCrossNetI BegCrossNetI() const { return TCrossNetI(TCrossNetH.BegI(), this); }
467    TCrossNetI EndCrossNetI() const { return TCrossNetI(TCrossNetH.EndI(), this); }
468    TModeNetI GetModeNetI(const int& Id) const { return TModeNetI(TModeNetH.GetI(Id), this); }
469    TModeNetI BegModeNetI() const { return TModeNetI(TModeNetH.BegI(), this); }
470    TModeNetI EndModeNetI() const { return TModeNetI(TModeNetH.EndI(), this); }
471    int GetModeNets() { return TModeNetH.Len(); }
472    int GetCrossNets() { return TCrossNetH.Len(); }
473    PMMNet GetSubgraphByCrossNet(TStrV& CrossNetTypes);
474    PMMNet GetSubgraphByModeNet(TStrV& ModeNetTypes);
475    PNEANet ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap);
476    PNEANet ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap);
477    #ifdef GCC_ATOMIC
478    PNEANetMP ToNetworkMP(TStrV& CrossNetNames);
479    #endif 
480  private:
481    void ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir);
482    int AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet);
483    int AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet);
484    int AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId);
485    int AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId);
486    void GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxVal) const;
487  };
488  namespace TSnap {
489  template <> struct IsMultiGraph<TModeNet> { enum { Val = 1 }; };
490  template <> struct IsDirected<TModeNet> { enum { Val = 1 }; };
491  }
492  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.h</div>
                <div class="column column_space"><pre><code>104    TB8Set& operator=(const uchar& _B1){B1=_B1; return *this;}
105    bool operator==(const TB8Set& BSet) const {return B1==BSet.B1;}
106    bool operator<(const TB8Set& BSet) const {return B1<BSet.B1;}
107    bool Empty() const {return B1==0;}
</pre></code></div>
                <div class="column column_space"><pre><code>139      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; attr = I.attr; return *this; }
140      bool operator < (const TAIntI& I) const { return HI < I.HI; }
141      bool operator == (const TAIntI& I) const { return HI == I.HI; }
142      TInt GetDat() const { return HI[0]; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    