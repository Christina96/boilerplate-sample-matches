
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.911330049261084%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-indexmapbidi.cpp</h3>
            <pre><code>1  #include "helpers.h"
2  #include "indexmapbidi.h"
3  #include "serialis.h"
4  namespace tesseract {
5  IndexMap::~IndexMap() = default;
6  int IndexMap::SparseToCompact(int sparse_index) const {
7    auto pos = std::upper_bound(compact_map_.begin(), compact_map_.end(), sparse_index);
8    if (pos > compact_map_.begin()) {
9      --pos;
10    }
11    auto result = pos - compact_map_.begin();
12    return compact_map_[result] == sparse_index ? result : -1;
13  }
14  void IndexMap::CopyFrom(const IndexMap &src) {
15    sparse_size_ = src.sparse_size_;
16    compact_map_ = src.compact_map_;
17  }
18  void IndexMap::CopyFrom(const IndexMapBiDi &src) {
19    sparse_size_ = src.SparseSize();
20    compact_map_ = src.compact_map_;
21  }
22  bool IndexMap::Serialize(FILE *fp) const {
23    return tesseract::Serialize(fp, &sparse_size_) && tesseract::Serialize(fp, compact_map_);
24  }
25  bool IndexMap::DeSerialize(bool swap, FILE *fp) {
26    uint32_t sparse_size;
27    if (!tesseract::DeSerialize(fp, &sparse_size)) {
28      return false;
29    }
30    if (swap) {
31      ReverseN(&sparse_size, sizeof(sparse_size));
32    }
33    if (sparse_size > UINT16_MAX) {
34      return false;
35    }
36    sparse_size_ = sparse_size;
37    return tesseract::DeSerialize(swap, fp, compact_map_);
38  }
39  IndexMapBiDi::~IndexMapBiDi() = default;
40  void IndexMapBiDi::InitAndSetupRange(int sparse_size, int start, int end) {
41    Init(sparse_size, false);
42    for (int i = start; i < end; ++i) {
43      SetMap(i, true);
44    }
45    Setup();
46  }
47  void IndexMapBiDi::Init(int size, bool all_mapped) {
48    if (!all_mapped) {
49      sparse_map_.clear();
50    }
51    sparse_map_.resize(size, -1);
52    if (all_mapped) {
53      for (int i = 0; i < size; ++i) {
54        sparse_map_[i] = i;
55      }
56    }
57  }
58  void IndexMapBiDi::SetMap(int sparse_index, bool mapped) {
59    sparse_map_[sparse_index] = mapped ? 0 : -1;
60  }
61  void IndexMapBiDi::Setup() {
62    int compact_size = 0;
63    for (int &i : sparse_map_) {
64      if (i >= 0) {
65        i = compact_size++;
66      }
67    }
68    compact_map_.clear();
69    compact_map_.resize(compact_size, -1);
70    for (size_t i = 0; i < sparse_map_.size(); ++i) {
71      if (sparse_map_[i] >= 0) {
72        compact_map_[sparse_map_[i]] = i;
73      }
74    }
75    sparse_size_ = sparse_map_.size();
76  }
77  void IndexMapBiDi::CopyFrom(const IndexMapBiDi &src) {
78    sparse_map_ = src.sparse_map_;
79    compact_map_ = src.compact_map_;
80    sparse_size_ = sparse_map_.size();
81  }
82  bool IndexMapBiDi::Merge(int compact_index1, int compact_index2) {
83    compact_index1 = MasterCompactIndex(compact_index1);
84    compact_index2 = MasterCompactIndex(compact_index2);
85    if (compact_index1 > compact_index2) {
86      int tmp = compact_index1;
87      compact_index1 = compact_index2;
88      compact_index2 = tmp;
89    } else if (compact_index1 == compact_index2) {
90      return false;
91    }
92    sparse_map_[compact_map_[compact_index2]] = compact_index1;
93    if (compact_index1 >= 0) {
94      compact_map_[compact_index2] = compact_map_[compact_index1];
95    }
96    return true;
97  }
98  void IndexMapBiDi::CompleteMerges() {
99    int compact_size = 0;
100    for (int &i : sparse_map_) {
101      int compact_index = MasterCompactIndex(i);
102      i = compact_index;
103      if (compact_index >= compact_size) {
104        compact_size = compact_index + 1;
105      }
106    }
107    compact_map_.clear();
108    compact_map_.resize(compact_size, -1);
109    for (size_t i = 0; i < sparse_map_.size(); ++i) {
110      if (sparse_map_[i] >= 0) {
111        if (compact_map_[sparse_map_[i]] == -1) {
112          compact_map_[sparse_map_[i]] = i;
113        }
114      }
115    }
116    std::vector<int32_t> tmp_compact_map(compact_size, -1);
117    compact_size = 0;
118    for (size_t i = 0; i < compact_map_.size(); ++i) {
119      if (compact_map_[i] >= 0) {
120        tmp_compact_map[i] = compact_size;
121        compact_map_[compact_size++] = compact_map_[i];
122      }
123    }
124    compact_map_.resize(compact_size);
125    for (int &i : sparse_map_) {
126      if (i >= 0) {
127        i = tmp_compact_map[i];
128      }
129    }
130  }
131  bool IndexMapBiDi::Serialize(FILE *fp) const {
132    if (!IndexMap::Serialize(fp)) {
133      return false;
134    }
135    std::vector<int32_t> remaining_pairs;
136    for (unsigned i = 0; i < sparse_map_.size(); ++i) {
137      if (sparse_map_[i] >= 0 && static_cast<unsigned>(compact_map_[sparse_map_[i]]) != i) {
138        remaining_pairs.push_back(i);
139        remaining_pairs.push_back(sparse_map_[i]);
140      }
141    }
142    return tesseract::Serialize(fp, remaining_pairs);
143  }
<span onclick='openModal()' class='match'>144  bool IndexMapBiDi::DeSerialize(bool swap, FILE *fp) {
145    if (!IndexMap::DeSerialize(swap, fp)) {
146      return false;
147    }
148    std::vector<int32_t> remaining_pairs;
149    if (!tesseract::DeSerialize(swap, fp, remaining_pairs)) {
150      return false;
151    }
</span>152    sparse_map_.clear();
153    sparse_map_.resize(sparse_size_, -1);
154    for (unsigned i = 0; i < compact_map_.size(); ++i) {
155      sparse_map_[compact_map_[i]] = i;
156    }
157    for (size_t i = 0; i < remaining_pairs.size(); ++i) {
158      int sparse_index = remaining_pairs[i++];
159      sparse_map_[sparse_index] = remaining_pairs[i];
160    }
161    return true;
162  }
163  int IndexMapBiDi::MapFeatures(const std::vector<int> &sparse, std::vector<int> *compact) const {
164    compact->clear();
165    int num_features = sparse.size();
166    int missed_features = 0;
167    int prev_good_feature = -1;
168    for (int f = 0; f < num_features; ++f) {
169      int feature = sparse_map_[sparse[f]];
170      if (feature >= 0) {
171        if (feature != prev_good_feature) {
172          compact->push_back(feature);
173          prev_good_feature = feature;
174        }
175      } else {
176        ++missed_features;
177      }
178    }
179    return missed_features;
180  }
181  } 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-matchers.cc</h3>
            <pre><code>1  #include "gmock/gmock-matchers.h"
2  #include "gmock/gmock-generated-matchers.h"
3  #include <string.h>
4  #include <sstream>
5  #include <string>
6  namespace testing {
7  Matcher<const internal::string&>::Matcher(const internal::string& s) {
8    *this = Eq(s);
9  }
10  Matcher<const internal::string&>::Matcher(const char* s) {
11    *this = Eq(internal::string(s));
12  }
13  Matcher<internal::string>::Matcher(const internal::string& s) { *this = Eq(s); }
14  Matcher<internal::string>::Matcher(const char* s) {
15    *this = Eq(internal::string(s));
16  }
17  #if GTEST_HAS_STRING_PIECE_
18  Matcher<const StringPiece&>::Matcher(const internal::string& s) {
19    *this = Eq(s);
20  }
21  Matcher<const StringPiece&>::Matcher(const char* s) {
22    *this = Eq(internal::string(s));
23  }
24  Matcher<const StringPiece&>::Matcher(StringPiece s) {
25    *this = Eq(s.ToString());
26  }
27  Matcher<StringPiece>::Matcher(const internal::string& s) {
28    *this = Eq(s);
29  }
30  Matcher<StringPiece>::Matcher(const char* s) {
31    *this = Eq(internal::string(s));
32  }
33  Matcher<StringPiece>::Matcher(StringPiece s) {
34    *this = Eq(s.ToString());
35  }
36  #endif  
37  namespace internal {
38  GTEST_API_ string JoinAsTuple(const Strings& fields) {
39    switch (fields.size()) {
40      case 0:
41        return "";
42      case 1:
43        return fields[0];
44      default:
45        string result = "(" + fields[0];
46        for (size_t i = 1; i < fields.size(); i++) {
47          result += ", ";
48          result += fields[i];
49        }
50        result += ")";
51        return result;
52    }
53  }
54  GTEST_API_ string FormatMatcherDescription(bool negation,
55                                             const char* matcher_name,
56                                             const Strings& param_values) {
57    string result = ConvertIdentifierNameToWords(matcher_name);
58    if (param_values.size() >= 1)
59      result += " " + JoinAsTuple(param_values);
60    return negation ? "not (" + result + ")" : result;
61  }
62  class MaxBipartiteMatchState {
63   public:
64    explicit MaxBipartiteMatchState(const MatchMatrix& graph)
65        : graph_(&graph),
66          left_(graph_->LhsSize(), kUnused),
67          right_(graph_->RhsSize(), kUnused) {
68    }
69    ElementMatcherPairs Compute() {
70      ::std::vector<char> seen;
71      for (size_t ilhs = 0; ilhs < graph_->LhsSize(); ++ilhs) {
72        GTEST_CHECK_(left_[ilhs] == kUnused)
73            << "ilhs: " << ilhs << ", left_[ilhs]: " << left_[ilhs];
74        seen.assign(graph_->RhsSize(), 0);
75        TryAugment(ilhs, &seen);
76      }
77      ElementMatcherPairs result;
78      for (size_t ilhs = 0; ilhs < left_.size(); ++ilhs) {
79        size_t irhs = left_[ilhs];
80        if (irhs == kUnused) continue;
81        result.push_back(ElementMatcherPair(ilhs, irhs));
82      }
83      return result;
84    }
85   private:
86    static const size_t kUnused = static_cast<size_t>(-1);
87    bool TryAugment(size_t ilhs, ::std::vector<char>* seen) {
88      for (size_t irhs = 0; irhs < graph_->RhsSize(); ++irhs) {
89        if ((*seen)[irhs])
90          continue;
91        if (!graph_->HasEdge(ilhs, irhs))
92          continue;
93        (*seen)[irhs] = 1;
94        if (right_[irhs] == kUnused || TryAugment(right_[irhs], seen)) {
95          left_[ilhs] = irhs;
96          right_[irhs] = ilhs;
97          return true;
98        }
99      }
100      return false;
101    }
102    const MatchMatrix* graph_;  
103    ::std::vector<size_t> left_;
104    ::std::vector<size_t> right_;
105    GTEST_DISALLOW_ASSIGN_(MaxBipartiteMatchState);
106  };
107  const size_t MaxBipartiteMatchState::kUnused;
108  GTEST_API_ ElementMatcherPairs
109  FindMaxBipartiteMatching(const MatchMatrix& g) {
110    return MaxBipartiteMatchState(g).Compute();
111  }
112  static void LogElementMatcherPairVec(const ElementMatcherPairs& pairs,
113                                       ::std::ostream* stream) {
114    typedef ElementMatcherPairs::const_iterator Iter;
115    ::std::ostream& os = *stream;
116    os << "{";
117    const char *sep = "";
118    for (Iter it = pairs.begin(); it != pairs.end(); ++it) {
119      os << sep << "\n  ("
120         << "element #" << it->first << ", "
121         << "matcher #" << it->second << ")";
122      sep = ",";
123    }
124    os << "\n}";
125  }
126  GTEST_API_ bool FindPairing(const MatchMatrix& matrix,
127                              MatchResultListener* listener) {
128    ElementMatcherPairs matches = FindMaxBipartiteMatching(matrix);
129    size_t max_flow = matches.size();
130    bool result = (max_flow == matrix.RhsSize());
131    if (!result) {
132      if (listener->IsInterested()) {
133        *listener << "where no permutation of the elements can "
134                     "satisfy all matchers, and the closest match is "
135                  << max_flow << " of " << matrix.RhsSize()
136                  << " matchers with the pairings:\n";
137        LogElementMatcherPairVec(matches, listener->stream());
138      }
139      return false;
140    }
141    if (matches.size() > 1) {
142      if (listener->IsInterested()) {
143        const char *sep = "where:\n";
144        for (size_t mi = 0; mi < matches.size(); ++mi) {
145          *listener << sep << " - element #" << matches[mi].first
146                    << " is matched by matcher #" << matches[mi].second;
147          sep = ",\n";
148        }
149      }
150    }
151    return true;
152  }
153  bool MatchMatrix::NextGraph() {
154    for (size_t ilhs = 0; ilhs < LhsSize(); ++ilhs) {
155      for (size_t irhs = 0; irhs < RhsSize(); ++irhs) {
156        char& b = matched_[SpaceIndex(ilhs, irhs)];
157        if (!b) {
158          b = 1;
159          return true;
160        }
161        b = 0;
162      }
163    }
164    return false;
165  }
166  void MatchMatrix::Randomize() {
167    for (size_t ilhs = 0; ilhs < LhsSize(); ++ilhs) {
168      for (size_t irhs = 0; irhs < RhsSize(); ++irhs) {
169        char& b = matched_[SpaceIndex(ilhs, irhs)];
170        b = static_cast<char>(rand() & 1);  
171      }
172    }
173  }
174  string MatchMatrix::DebugString() const {
175    ::std::stringstream ss;
176    const char *sep = "";
177    for (size_t i = 0; i < LhsSize(); ++i) {
178      ss << sep;
179      for (size_t j = 0; j < RhsSize(); ++j) {
180        ss << HasEdge(i, j);
181      }
182      sep = ";";
183    }
184    return ss.str();
185  }
186  void UnorderedElementsAreMatcherImplBase::DescribeToImpl(
<span onclick='openModal()' class='match'>187      ::std::ostream* os) const {
188    if (matcher_describers_.empty()) {
189      *os << "is empty";
190      return;
191    }
192    if (matcher_describers_.size() == 1) {
193      *os << "has " << Elements(1) << " and that element ";
194      matcher_describers_[0]->DescribeTo(os);
195      return;
196    }
</span>197    *os << "has " << Elements(matcher_describers_.size())
198        << " and there exists some permutation of elements such that:\n";
199    const char* sep = "";
200    for (size_t i = 0; i != matcher_describers_.size(); ++i) {
201      *os << sep << " - element #" << i << " ";
202      matcher_describers_[i]->DescribeTo(os);
203      sep = ", and\n";
204    }
205  }
206  void UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(
207      ::std::ostream* os) const {
208    if (matcher_describers_.empty()) {
209      *os << "isn't empty";
210      return;
211    }
212    if (matcher_describers_.size() == 1) {
213      *os << "doesn't have " << Elements(1)
214          << ", or has " << Elements(1) << " that ";
215      matcher_describers_[0]->DescribeNegationTo(os);
216      return;
217    }
218    *os << "doesn't have " << Elements(matcher_describers_.size())
219        << ", or there exists no permutation of elements such that:\n";
220    const char* sep = "";
221    for (size_t i = 0; i != matcher_describers_.size(); ++i) {
222      *os << sep << " - element #" << i << " ";
223      matcher_describers_[i]->DescribeTo(os);
224      sep = ", and\n";
225    }
226  }
227  bool UnorderedElementsAreMatcherImplBase::
228  VerifyAllElementsAndMatchersAreMatched(
229      const ::std::vector<string>& element_printouts,
230      const MatchMatrix& matrix,
231      MatchResultListener* listener) const {
232    bool result = true;
233    ::std::vector<char> element_matched(matrix.LhsSize(), 0);
234    ::std::vector<char> matcher_matched(matrix.RhsSize(), 0);
235    for (size_t ilhs = 0; ilhs < matrix.LhsSize(); ilhs++) {
236      for (size_t irhs = 0; irhs < matrix.RhsSize(); irhs++) {
237        char matched = matrix.HasEdge(ilhs, irhs);
238        element_matched[ilhs] |= matched;
239        matcher_matched[irhs] |= matched;
240      }
241    }
242    {
243      const char* sep =
244          "where the following matchers don't match any elements:\n";
245      for (size_t mi = 0; mi < matcher_matched.size(); ++mi) {
246        if (matcher_matched[mi])
247          continue;
248        result = false;
249        if (listener->IsInterested()) {
250          *listener << sep << "matcher #" << mi << ": ";
251          matcher_describers_[mi]->DescribeTo(listener->stream());
252          sep = ",\n";
253        }
254      }
255    }
256    {
257      const char* sep =
258          "where the following elements don't match any matchers:\n";
259      const char* outer_sep = "";
260      if (!result) {
261        outer_sep = "\nand ";
262      }
263      for (size_t ei = 0; ei < element_matched.size(); ++ei) {
264        if (element_matched[ei])
265          continue;
266        result = false;
267        if (listener->IsInterested()) {
268          *listener << outer_sep << sep << "element #" << ei << ": "
269                    << element_printouts[ei];
270          sep = ",\n";
271          outer_sep = "";
272        }
273      }
274    }
275    return result;
276  }
277  }  
278  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-indexmapbidi.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-gmock-matchers.cc</div>
                <div class="column column_space"><pre><code>144  bool IndexMapBiDi::DeSerialize(bool swap, FILE *fp) {
145    if (!IndexMap::DeSerialize(swap, fp)) {
146      return false;
147    }
148    std::vector<int32_t> remaining_pairs;
149    if (!tesseract::DeSerialize(swap, fp, remaining_pairs)) {
150      return false;
151    }
</pre></code></div>
                <div class="column column_space"><pre><code>187      ::std::ostream* os) const {
188    if (matcher_describers_.empty()) {
189      *os << "is empty";
190      return;
191    }
192    if (matcher_describers_.size() == 1) {
193      *os << "has " << Elements(1) << " and that element ";
194      matcher_describers_[0]->DescribeTo(os);
195      return;
196    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    