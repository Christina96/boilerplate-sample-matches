
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.387329013678906%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</h3>
            <pre><code>1  TStr TModeNet::GetNeighborCrossName(const TStr& CrossName, bool isOutEdge, const bool sameMode, bool isDir) const {
2    TStr Cpy(CrossName);
3    if (!isDir || !sameMode) { return Cpy; }
4    if (isOutEdge) {
5      Cpy += ":SRC";
6    } else {
7      Cpy += ":DST";
8    }
9    return Cpy;
10  }
11  void TModeNet::ClrNbr(const TStr& CrossNetName, const bool& outEdge, const bool& sameMode, bool& isDir) {
12    TStr Name = GetNeighborCrossName(CrossNetName, outEdge, sameMode, isDir);
13    TInt location = CheckDenseOrSparseN(Name);
14    int index = KeyToIndexTypeN.GetDat(Name).Val2;
15    if (location == 1) {
16      TVec<TIntV> Attrs(MxNId);
17      VecOfIntVecVecsN[index] = Attrs;
18    } else {
19      THash<TInt, TIntV> Attrs;
20      VecOfIntHashVecsN[index] = Attrs;
21    }
22  }
23  void TModeNet::Clr() {
24    TStrV CNets;
25    NeighborTypes.GetKeyV(CNets);
26    for (int i=0; i < CNets.Len(); i++) {
27      MMNet->GetCrossNetByName(CNets[i]).Clr();
28    }
29    TNEANet::Clr();
30  }
31  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const int linkId, const bool sameMode, bool isDir){
32    TStr CrossName = MMNet->GetCrossName(linkId);
33    return AddNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
34  }
35  int TModeNet::AddNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
36    if (!NeighborTypes.IsKey(CrossName)) {
37      AddNbrType(CrossName, sameMode, isDir);
38    }
39    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
40    return AppendIntVAttrDatN(NId, EId, Name); 
41  }
42  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TStr& CrossName, const bool sameMode, bool isDir){
43    if (!NeighborTypes.IsKey(CrossName)) {
44      return -1;
45    }
46    TStr Name = GetNeighborCrossName(CrossName, outEdge, sameMode, isDir);
47    return DelFromIntVAttrDatN(NId, EId, Name);
48  }
49  int TModeNet::DelNeighbor(const int& NId, const int& EId, bool outEdge, const TInt& linkId, const bool sameMode, bool isDir){
50    TStr CrossName = MMNet->GetCrossName(linkId);
51    return DelNeighbor(NId, EId, outEdge, CrossName, sameMode, isDir);
52  }
53  void TModeNet::DelNode(const int& NId) {
54    TStrV Names;
55    GetCrossNetNames(Names);
56    for (int i=0; i < Names.Len(); i++) {
57      TCrossNet& Cross = MMNet->GetCrossNetByName(Names[i]);
58      TIntV OutEIds;
59      GetNeighborsByCrossNet(NId, Names[i], OutEIds, true);
60      for (int j=0; j < OutEIds.Len(); j++) {
61        Cross.DelEdge(OutEIds[j].Val);
62      }
63      if (Cross.IsDirect && Cross.Mode1 == Cross.Mode2) {
64        TIntV InEIds;
65        GetNeighborsByCrossNet(NId, Names[i], InEIds, false);
66        for (int j=0; j < InEIds.Len(); j++) {
67          Cross.DelEdge(InEIds[j].Val);
68        }
69      }
70    }
71    TNEANet::DelNode(NId);
72  }
73  void TModeNet::SetParentPointer(TMMNet* parent) {
74    MMNet = parent;
75  }
76  int TModeNet::AddNbrType(const TStr& CrossName, const bool sameMode, bool isDir) {
77    if (NeighborTypes.IsKey(CrossName)) { return -1; } 
78    bool hasSingleVector = (!isDir || !sameMode);
79    NeighborTypes.AddDat(CrossName, hasSingleVector);
80    return 0;
81  }
82  int TModeNet::DelNbrType(const TStr& CrossName) {
83    bool hasSingleVector = NeighborTypes.GetDat(CrossName);
84    NeighborTypes.DelKey(CrossName);
85    if (hasSingleVector) {
86      return DelAttrN(CrossName);
87    } else {
88      TStr InName = GetNeighborCrossName(CrossName, true, true, true);
89      TStr OutName = GetNeighborCrossName(CrossName, false, true, true);
90      if (DelAttrN(InName) == -1 || DelAttrN(OutName) == -1) {
91        return -1;
92      }
93    }
94    return 0;
95  }
96  void TModeNet::GetNeighborsByCrossNet(const int& NId, TStr& Name, TIntV& Neighbors, const bool isOutEId) const{
97    TBool hasSingleVector = NeighborTypes.GetDat(Name);
<span onclick='openModal()' class='match'>98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
</span>105  int TModeNet::AddIntVAttrByVecN(const TStr& attr, TVec<TIntV>& Attrs, TBool UseDense){
106    TInt CurrLen;
107    if (UseDense) {
108      CurrLen = VecOfIntVecVecsN.Len();
109      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
110      KeyToDenseN.AddDat(attr, true);
111      VecOfIntVecVecsN.Add(Attrs);
112    } else {
113      THash<TInt, TIntV> NewHash;
114      CurrLen = VecOfIntHashVecsN.Len();
115      KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
116      KeyToDenseN.AddDat(attr, false);
117      for (int i=0; i< Attrs.Len(); i++) {
118        NewHash.AddDat(i, Attrs[i]);
119      }
120      VecOfIntHashVecsN.Add(NewHash);
121    }
122    return 0;
123  }
124  int TModeNet::AddIntVAttrByHashN(const TStr& attr, THash<TInt, TIntV>& Attrs){
125    TInt CurrLen;
126    THash<TInt, TIntV> NewHash;
127    CurrLen = VecOfIntHashVecsN.Len();
128    KeyToIndexTypeN.AddDat(attr, TIntPr(IntVType, CurrLen));
129    KeyToDenseN.AddDat(attr, false);
130    for (int i=0; i< Attrs.Len(); i++) {
131      NewHash.AddDat(i, Attrs[i]);
132    }
133    VecOfIntHashVecsN.Add(NewHash);
134    return 0;
135  }
136  void TModeNet::RemoveCrossNets(TModeNet& Result, TStrV& CrossNets) {
137    const TModeNet& self = *this;
138    Result = TModeNet(self, false);
139    for (TStrIntPrH::TIter it = KeyToIndexTypeN.BegI(); it < KeyToIndexTypeN.EndI(); it++) {
140      TStr AttrName = it.GetKey();
141      TInt AttrType = it.GetDat().GetVal1();
142      TInt AttrIndex = it.GetDat().GetVal2();
143      if (AttrType != IntVType) {
144        Result.KeyToIndexTypeN.AddDat(AttrName, it.GetDat());
145      } else {
146        TStr WithoutSuffix = AttrName;
147        bool removeSuffix = false;
148        if (AttrName.IsSuffix(":SRC") || AttrName.IsSuffix(":DST")) {
149          WithoutSuffix = AttrName.GetSubStr(0, AttrName.Len()-5);
150          removeSuffix = true;
151        }
152        bool isSingleVNbrAttr = (NeighborTypes.IsKey(AttrName) && NeighborTypes.GetDat(AttrName));
153        bool isMultiVNbrAttr = (removeSuffix && NeighborTypes.IsKey(WithoutSuffix) && !NeighborTypes.GetDat(WithoutSuffix));
154        if (isSingleVNbrAttr || isMultiVNbrAttr) {
155          TStr NbrName = isSingleVNbrAttr ? AttrName : WithoutSuffix;
156          if (CrossNets.IsIn(NbrName)) {
157            Result.AddNbrType(NbrName, removeSuffix, removeSuffix);
158            TInt location = CheckDenseOrSparseN(AttrName);
159            if (location == 1) {
160              TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
161              Result.AddIntVAttrByVecN(AttrName, Attrs);
162            } else {
163              THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
164              Result.AddIntVAttrByHashN(AttrName, Attrs);
165            }
166          }
167        } else {
168          TInt location = CheckDenseOrSparseN(AttrName);
169          if (location == 1) {
170            TVec<TIntV>& Attrs = VecOfIntVecVecsN[AttrIndex];
171            Result.AddIntVAttrByVecN(AttrName, Attrs);
172          } else {
173            THash<TInt, TIntV>& Attrs = VecOfIntHashVecsN[AttrIndex];
174            Result.AddIntVAttrByHashN(AttrName, Attrs);
175          }
176        }
177      }
178    }
179  }
180  int TModeNet::GetAttrTypeN(const TStr& attr) const {
181    if (KeyToIndexTypeN.IsKey(attr)) {
182      return KeyToIndexTypeN.GetDat(attr).Val1;
183    }
184    return -1;
185  }
186  int TCrossNet::GetAttrTypeE(const TStr& attr) const {
187    if (KeyToIndexTypeE.IsKey(attr)) {
188      return KeyToIndexTypeE.GetDat(attr).Val1;
189    }
190    return -1;
191  }
192  void TCrossNet::Clr() {
193    CrossH.Clr();
194    MxEId=0;
195    KeyToIndexTypeE.Clr();
196    IntDefaultsE.Clr();
197    StrDefaultsE.Clr();
198    FltDefaultsE.Clr();
199    VecOfIntVecsE.Clr();
200    VecOfStrVecsE.Clr();
201    VecOfFltVecsE.Clr(); 
202    Net->ClrNbr(Mode1, CrossNetId, true, Mode1==Mode2, IsDirect.Val);
203    Net->ClrNbr(Mode2, CrossNetId, false, Mode1==Mode2, IsDirect.Val); 
204  }
205  int TCrossNet::AddEdge(const int& sourceNId, const int& destNId, int EId){
206    if (EId == -1) { EId = MxEId;  MxEId++; }
207    else { MxEId = TMath::Mx(EId+1, MxEId()); }
208    if (Net != NULL) {
209      TModeNet& M1 = Net->TModeNetH.GetDat(this->Mode1);
210      TModeNet& M2 = Net->TModeNetH.GetDat(this->Mode2);
211      if (!M1.IsNode(sourceNId) || !M2.IsNode(destNId)) { return -1; }
212      TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
213      M1.AddNeighbor(sourceNId, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
214      M2.AddNeighbor(destNId, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
215    }
216    TCrossNet::TCrossEdge newEdge(EId, sourceNId, destNId);
217    CrossH.AddDat(EId, newEdge);
218    int i;
219    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
220      TVec<TInt>& IntVec = VecOfIntVecsE[i];
221      int KeyId = CrossH.GetKeyId(EId);
222      if (IntVec.Len() > KeyId) {
223        IntVec[KeyId] = TInt::Mn;
224      } else {
225        IntVec.Ins(KeyId, TInt::Mn);
226      }
227    }
228    TVec<TStr> DefIntVec = TVec<TStr>();
229    IntDefaultsE.GetKeyV(DefIntVec);
230    for (i = 0; i < DefIntVec.Len(); i++) {
231      TStr attr = DefIntVec[i];
232      TVec<TInt>& IntVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(DefIntVec[i]).Val2];
233      IntVec[CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
234    }
235    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
236      TVec<TStr>& StrVec = VecOfStrVecsE[i];
237      int KeyId = CrossH.GetKeyId(EId);
238      if (StrVec.Len() > KeyId) {
239        StrVec[KeyId] = TStr::GetNullStr();
240      } else {
241        StrVec.Ins(KeyId, TStr::GetNullStr());
242      }
243    }
244    TVec<TStr> DefStrVec = TVec<TStr>();
245    StrDefaultsE.GetKeyV(DefStrVec);
246    for (i = 0; i < DefStrVec.Len(); i++) {
247      TStr attr = DefStrVec[i];
248      TVec<TStr>& StrVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(DefStrVec[i]).Val2];
249      StrVec[CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
250    }
251    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
252      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
253      int KeyId = CrossH.GetKeyId(EId);
254      if (FltVec.Len() > KeyId) {
255        FltVec[KeyId] = TFlt::Mn;
256      } else {
257        FltVec.Ins(KeyId, TFlt::Mn);
258      }
259    }
260    TVec<TStr> DefFltVec = TVec<TStr>();
261    FltDefaultsE.GetKeyV(DefFltVec);
262    for (i = 0; i < DefFltVec.Len(); i++) {
263      TStr attr = DefFltVec[i];
264      TVec<TFlt>& FltVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(DefFltVec[i]).Val2];
265      FltVec[CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
266    }
267    return EId;
268  }
269  int TCrossNet::DelEdge(const int& EId) {
270    TCrossEdge& Edge = CrossH.GetDat(EId);
271    int srcNode = Edge.SrcNId;
272    int dstNode = Edge.DstNId;
273    TStr ThisCrossName = Net->GetCrossName(this->CrossNetId);
274    Net->GetModeNetById(this->Mode1).DelNeighbor(srcNode, EId, true, ThisCrossName, Mode1==Mode2, IsDirect);
275    Net->GetModeNetById(this->Mode2).DelNeighbor(dstNode, EId, false, ThisCrossName, Mode1==Mode2, IsDirect);
276    int i;
277    for (i = 0; i < VecOfIntVecsE.Len(); i++) {
278      TVec<TInt>& IntVec = VecOfIntVecsE[i];
279      IntVec[CrossH.GetKeyId(EId)] =  TInt::Mn;
280    }
281    for (i = 0; i < VecOfStrVecsE.Len(); i++) {
282      TVec<TStr>& StrVec = VecOfStrVecsE[i];
283      StrVec[CrossH.GetKeyId(EId)] =  TStr::GetNullStr();
284    }
285    for (i = 0; i < VecOfFltVecsE.Len(); i++) {
286      TVec<TFlt>& FltVec = VecOfFltVecsE[i];
287      FltVec[CrossH.GetKeyId(EId)] = TFlt::Mn;
288    }
289    CrossH.DelKey(EId);
290    return 0;
291  }
292  void TCrossNet::SetParentPointer(TMMNet* parent) {
293    Net = parent;
294  }
295  void TCrossNet::AttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
296    Names = TVec<TStr>();
297    while (!CrossHI.IsEnd()) {
298      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
299        Names.Add(CrossHI.GetKey());
300      }
301      CrossHI++;
302    }  
303  }
304  void TCrossNet::AttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
305    Values = TVec<TStr>();
306    while (!CrossHI.IsEnd()) {
307      if (!EdgeAttrIsDeleted(EId, CrossHI)) {
308        Values.Add(GetEdgeAttrValue(EId, CrossHI));
309      }
310      CrossHI++;
311    }  
312  }
313  void TCrossNet::IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
314    Names = TVec<TStr>();
315    while (!CrossHI.IsEnd()) {
316      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
317        Names.Add(CrossHI.GetKey());
318      }
319      CrossHI++;
320    }  
321  }
322  void TCrossNet::IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TIntV& Values) const {
323    Values = TVec<TInt>();
324    while (!CrossHI.IsEnd()) {
325      if (CrossHI.GetDat().Val1 == IntType && !EdgeAttrIsIntDeleted(EId, CrossHI)) {
326        TInt val = (this->VecOfIntVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
327        Values.Add(val);
328      }
329      CrossHI++;
330    }  
331  }
332  void TCrossNet::StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
333    Names = TVec<TStr>();
334    while (!CrossHI.IsEnd()) {
335      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
336        Names.Add(CrossHI.GetKey());
337      }
338      CrossHI++;
339    }  
340  }
341  void TCrossNet::StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Values) const {
342    Values = TVec<TStr>();
343    while (!CrossHI.IsEnd()) {
344      if (CrossHI.GetDat().Val1 == StrType && !EdgeAttrIsStrDeleted(EId, CrossHI)) {
345        TStr val = this->VecOfStrVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId);
346        Values.Add(val);
347      }
348      CrossHI++;
349    }  
350  }
351  void TCrossNet::FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TStrV& Names) const {
352    Names = TVec<TStr>();
353    while (!CrossHI.IsEnd()) {
354      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
355        Names.Add(CrossHI.GetKey());
356      }
357      CrossHI++;
358    }  
359  }
360  void TCrossNet::FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter CrossHI, TFltV& Values) const {
361    Values = TVec<TFlt>();
362    while (!CrossHI.IsEnd()) {
363      if (CrossHI.GetDat().Val1 == FltType && !EdgeAttrIsFltDeleted(EId, CrossHI)) {
364        TFlt val = (this->VecOfFltVecsE.GetVal(CrossHI.GetDat().Val2).GetVal(EId));
365        Values.Add(val);
366      }
367      CrossHI++;
368    }  
369  }
370  bool TCrossNet::IsAttrDeletedE(const int& EId, const TStr& attr) const {
371    bool IntDel = IsIntAttrDeletedE(EId, attr);
372    bool StrDel = IsStrAttrDeletedE(EId, attr);
373    bool FltDel = IsFltAttrDeletedE(EId, attr);
374    return IntDel || StrDel || FltDel;
375  }
376  bool TCrossNet::IsIntAttrDeletedE(const int& EId, const TStr& attr) const {
377    return EdgeAttrIsIntDeleted(EId, KeyToIndexTypeE.GetI(attr));
378  }
379  bool TCrossNet::IsStrAttrDeletedE(const int& EId, const TStr& attr) const {
380    return EdgeAttrIsStrDeleted(EId, KeyToIndexTypeE.GetI(attr));
381  }
382  bool TCrossNet::IsFltAttrDeletedE(const int& EId, const TStr& attr) const {
383    return EdgeAttrIsFltDeleted(EId, KeyToIndexTypeE.GetI(attr));
384  }
385  bool TCrossNet::EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
386    bool IntDel = EdgeAttrIsIntDeleted(EId, CrossHI);
387    bool StrDel = EdgeAttrIsStrDeleted(EId, CrossHI);
388    bool FltDel = EdgeAttrIsFltDeleted(EId, CrossHI);
389    return IntDel || StrDel || FltDel;
390  }
391  bool TCrossNet::EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
392    return (CrossHI.GetDat().Val1 == IntType &&
393      GetIntAttrDefaultE(CrossHI.GetKey()) == this->VecOfIntVecsE.GetVal(
394      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
395  }
396  bool TCrossNet::EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
397    return (CrossHI.GetDat().Val1 == StrType &&
398      GetStrAttrDefaultE(CrossHI.GetKey()) == this->VecOfStrVecsE.GetVal(
399      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
400  }
401  bool TCrossNet::EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
402    return (CrossHI.GetDat().Val1 == FltType &&
403      GetFltAttrDefaultE(CrossHI.GetKey()) == this->VecOfFltVecsE.GetVal(
404      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId)));
405  }
406  TStr TCrossNet::GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& CrossHI) const {
407    if (CrossHI.GetDat().Val1 == IntType) {
408      return (this->VecOfIntVecsE.GetVal(
409        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
410    } else if(CrossHI.GetDat().Val1 == StrType) {
411      return this->VecOfStrVecsE.GetVal(
412      this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId));
413    } else if (CrossHI.GetDat().Val1 == FltType) {
414      return (this->VecOfFltVecsE.GetVal(
415        this->KeyToIndexTypeE.GetDat(CrossHI.GetKey()).Val2).GetVal(CrossH.GetKeyId(EId))).GetStr();
416    }
417    return TStr::GetNullStr();
418  }
419  int TCrossNet::AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr) {
420    int i;
421    TInt CurrLen;
422    if (!IsEdge(EId)) {
423       return -1;
424    }
425    if (KeyToIndexTypeE.IsKey(attr)) {
426      TVec<TInt>& NewVec = VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
427      NewVec[CrossH.GetKeyId(EId)] = value;
428    } else {
429      CurrLen = VecOfIntVecsE.Len();
430      KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
431      TVec<TInt> NewVec = TVec<TInt>();
432      for (i = 0; i < MxEId; i++) {
433        NewVec.Ins(i, GetIntAttrDefaultE(attr));
434      }
435      NewVec[CrossH.GetKeyId(EId)] = value;
436      VecOfIntVecsE.Add(NewVec);
437    }
438    return 0;
439  }
440  int TCrossNet::AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr) {
441    int i;
442    TInt CurrLen;
443    if (!IsEdge(EId)) {
444       return -1;
445    }
446    if (KeyToIndexTypeE.IsKey(attr)) {
447      TVec<TStr>& NewVec = VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
448      NewVec[CrossH.GetKeyId(EId)] = value;
449    } else {
450      CurrLen = VecOfStrVecsE.Len();
451      KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
452      TVec<TStr> NewVec = TVec<TStr>();
453      for (i = 0; i < MxEId; i++) {
454        NewVec.Ins(i, GetStrAttrDefaultE(attr));
455      }
456      NewVec[CrossH.GetKeyId(EId)] = value;
457      VecOfStrVecsE.Add(NewVec);
458    }
459    return 0;
460  } 
461  int TCrossNet::AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr) {
462    int i;
463    TInt CurrLen;
464    if (!IsEdge(EId)) {
465       return -1;
466    }
467    if (KeyToIndexTypeE.IsKey(attr)) {
468      TVec<TFlt>& NewVec = VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2];
469      NewVec[CrossH.GetKeyId(EId)] = value;
470    } else {
471      CurrLen = VecOfFltVecsE.Len();
472      KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
473      TVec<TFlt> NewVec = TVec<TFlt>();
474      for (i = 0; i < MxEId; i++) {
475        NewVec.Ins(i, GetFltAttrDefaultE(attr));
476      }
477      NewVec[CrossH.GetKeyId(EId)] = value;
478      VecOfFltVecsE.Add(NewVec);
479    }
480    return 0;
481  }
482  TInt TCrossNet::GetIntAttrDatE(const int& EId, const TStr& attr) {
483    return VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
484  }
485  TStr TCrossNet::GetStrAttrDatE(const int& EId, const TStr& attr) {
486    return VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
487  }
488  TFlt TCrossNet::GetFltAttrDatE(const int& EId, const TStr& attr) {
489    return VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)];
490  }
491  int TCrossNet::DelAttrDatE(const int& EId, const TStr& attr) {
492    TInt vecType = KeyToIndexTypeE(attr).Val1;
493    if (vecType == IntType) {
494      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetIntAttrDefaultE(attr);
495    } else if (vecType == StrType) {
496      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetStrAttrDefaultE(attr);
497    } else if (vecType == FltType) {
498      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2][CrossH.GetKeyId(EId)] = GetFltAttrDefaultE(attr);
499    } else {
500      return -1;
501    }
502    return 0;
503  }
504  int TCrossNet::AddIntAttrE(const TStr& attr, TInt defaultValue){
505    int i;
506    TInt CurrLen;
507    TVec<TInt> NewVec;
508    CurrLen = VecOfIntVecsE.Len();
509    KeyToIndexTypeE.AddDat(attr, TIntPr(IntType, CurrLen));
510    NewVec = TVec<TInt>();
511    for (i = 0; i < MxEId; i++) {
512      NewVec.Ins(i, defaultValue);
513    }
514    VecOfIntVecsE.Add(NewVec);
515    if (!IntDefaultsE.IsKey(attr)) {
516      IntDefaultsE.AddDat(attr, defaultValue);
517    } else {
518      return -1;
519    }
520    return 0;
521  }
522  int TCrossNet::AddStrAttrE(const TStr& attr, TStr defaultValue) {
523    int i;
524    TInt CurrLen;
525    TVec<TStr> NewVec;
526    CurrLen = VecOfStrVecsE.Len();
527    KeyToIndexTypeE.AddDat(attr, TIntPr(StrType, CurrLen));
528    NewVec = TVec<TStr>();
529    for (i = 0; i < MxEId; i++) {
530      NewVec.Ins(i, defaultValue);
531    }
532    VecOfStrVecsE.Add(NewVec);
533    if (!StrDefaultsE.IsKey(attr)) {
534      StrDefaultsE.AddDat(attr, defaultValue);
535    } else {
536      return -1;
537    }
538    return 0;
539  }
540  int TCrossNet::AddFltAttrE(const TStr& attr, TFlt defaultValue) {
541    int i;
542    TInt CurrLen;
543    TVec<TFlt> NewVec;
544    CurrLen = VecOfFltVecsE.Len();
545    KeyToIndexTypeE.AddDat(attr, TIntPr(FltType, CurrLen));
546    NewVec = TVec<TFlt>();
547    for (i = 0; i < MxEId; i++) {
548      NewVec.Ins(i, defaultValue);
549    }
550    VecOfFltVecsE.Add(NewVec);
551    if (!FltDefaultsE.IsKey(attr)) {
552      FltDefaultsE.AddDat(attr, defaultValue);
553    } else {
554      return -1;
555    }
556    return 0;
557  }
558  int TCrossNet::DelAttrE(const TStr& attr) {
559    TInt vecType = KeyToIndexTypeE(attr).Val1;
560    if (vecType == IntType) {
561      VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TInt>();
562      if (IntDefaultsE.IsKey(attr)) {
563        IntDefaultsE.DelKey(attr);
564      }
565    } else if (vecType == StrType) {
566      VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TStr>();
567      if (StrDefaultsE.IsKey(attr)) {
568        StrDefaultsE.DelKey(attr);
569      }  
570    } else if (vecType == FltType) {
571      VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2] = TVec<TFlt>();
572      if (FltDefaultsE.IsKey(attr)) {
573        FltDefaultsE.DelKey(attr);
574      }
575    } else {
576      return -1;
577    }
578    KeyToIndexTypeE.DelKey(attr);
579    return 0;
580  }
581  void TMMNet::LoadNetworkShM(TShMIn& ShMIn) {
582    MxModeId = TInt(ShMIn);
583    MxCrossNetId = TInt(ShMIn);
584    TModeNetInit Fm;
585    TModeNetH.LoadShM(ShMIn, Fm);
586    TCrossNetInit Fc;
587    TCrossNetH.LoadShM(ShMIn, Fc);
588    ModeIdToNameH.LoadShM(ShMIn);
589    ModeNameToIdH.LoadShM(ShMIn);
590    CrossIdToNameH.LoadShM(ShMIn);
591    CrossNameToIdH.LoadShM(ShMIn);
592    for (THash<TInt, TModeNet>::TIter it = TModeNetH.BegI(); it < TModeNetH.EndI(); it++) {
593      it.GetDat().SetParentPointer(this);
594    }
595    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
596      it.GetDat().SetParentPointer(this);
597    }
598  }
599  int TMMNet::AddModeNet(const TStr& ModeName) {
600    if (ModeNameToIdH.IsKey(ModeName)) {
601      return -1;
602    }
603    TInt ModeId = TInt(MxModeId);
604    MxModeId++;
605    ModeIdToNameH.AddDat(ModeId, ModeName);
606    ModeNameToIdH.AddDat(ModeName, ModeId);
607    TModeNet NewGraph(ModeId);
608    NewGraph.SetParentPointer(this);
609    TModeNetH.AddDat(ModeId, NewGraph);
610    return ModeId;
611  }
612  int TMMNet::AddCrossNet(const TStr& ModeName1, const TStr& ModeName2, const TStr& CrossNetName, bool isDir) {
613    TInt ModeId1 = GetModeId(ModeName1);
614    TInt ModeId2 = GetModeId(ModeName2);
615    return AddCrossNet(ModeId1, ModeId2, CrossNetName, isDir);
616  }
617  int TMMNet::AddCrossNet(const TInt& ModeId1, const TInt& ModeId2, const TStr& CrossNetName, bool isDir) {
618    if (CrossNameToIdH.IsKey(CrossNetName)) {
619      return -1;
620    }
621    TInt CrossNetId = TInt(MxCrossNetId);
622    MxCrossNetId++;
623    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
624    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
625    TCrossNet Cross = TCrossNet(ModeId1, ModeId2, isDir, CrossNetId);
626    Cross.SetParentPointer(this);
627    TCrossNetH.AddDat(CrossNetId, Cross);
628    TModeNetH.GetDat(ModeId1).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
629    TModeNetH.GetDat(ModeId2).AddNbrType(CrossNetName, ModeId1==ModeId2, isDir);
630    return CrossNetId;
631  }
632  int TMMNet::DelCrossNet(const TInt& CrossNetId) {
633    return DelCrossNet(CrossIdToNameH.GetDat(CrossNetId));
634  }
635  int TMMNet::DelCrossNet(const TStr& CrossNet) {
636    IAssertR(CrossNameToIdH.IsKey(CrossNet),TStr::Fmt("No such link type: %s", CrossNet.CStr()));
637    TInt CrossNetId = CrossNameToIdH.GetDat(CrossNet);
638    TInt Mode1 = GetCrossNetById(CrossNetId).Mode1;
639    TInt Mode2 = GetCrossNetById(CrossNetId).Mode2;
640    if (GetModeNetById(Mode1).DelNbrType(CrossNet) == -1 || (Mode1 != Mode2 && GetModeNetById(Mode2).DelNbrType(CrossNet) == -1)) {
641      return -1;
642    }
643    CrossNameToIdH.DelKey(CrossNet);
644    CrossIdToNameH.DelKey(CrossNetId);
645    GetCrossNetById(CrossNetId).SetParentPointer(NULL);
646    TCrossNetH.DelKey(CrossNetId);
647    return 0;
648  }
649  int TMMNet::DelModeNet(const TInt& ModeId) {
650    TStrV CrossNets;
651    GetModeNetById(ModeId).GetCrossNetNames(CrossNets);
652    for (int i = 0; i < CrossNets.Len(); i++) {
653      if (DelCrossNet(CrossNets[i]) == -1) {
654        return -1;
655      }
656    }
657    TStr ModeName = ModeIdToNameH.GetDat(ModeId);
658    ModeNameToIdH.DelKey(ModeName);
659    ModeIdToNameH.DelKey(ModeId);
660    GetModeNetById(ModeId).SetParentPointer(NULL);
661    TModeNetH.DelKey(ModeId);
662    return 0;
663  }
664  int TMMNet::DelModeNet(const TStr& ModeName) {
665    IAssertR(ModeNameToIdH.IsKey(ModeName), TStr::Fmt("No such mode with name: %s", ModeName.CStr()));
666    return DelModeNet(ModeNameToIdH.GetDat(ModeName));
667  }
668  TModeNet& TMMNet::GetModeNetByName(const TStr& ModeName) const {
669    return GetModeNetById(ModeNameToIdH.GetDat(ModeName));
670  }
671  TModeNet& TMMNet::GetModeNetById(const TInt& ModeId) const {
672    TModeNet &Net = (const_cast<TMMNet *>(this))->TModeNetH.GetDat(ModeId);
673    return Net;
674  }
675  TCrossNet& TMMNet::GetCrossNetByName(const TStr& CrossName) const{
676    return GetCrossNetById(CrossNameToIdH.GetDat(CrossName));
677  }
678  TCrossNet& TMMNet::GetCrossNetById(const TInt& CrossId) const{
679    TCrossNet& CrossNet = (const_cast<TMMNet *>(this))->TCrossNetH.GetDat(CrossId);
680    return CrossNet;
681  }
682  int TMMNet::AddMode(const TStr& ModeName, const TInt& ModeId, const TModeNet& ModeNet) {
683    ModeIdToNameH.AddDat(ModeId, ModeName);
684    ModeNameToIdH.AddDat(ModeName, ModeId);
685    TModeNetH.AddDat(ModeId, ModeNet);
686    TModeNetH[ModeId].SetParentPointer(this);
687    return ModeId;
688  }
689  int TMMNet::AddCrossNet(const TStr& CrossNetName, const TInt& CrossNetId, const TCrossNet& CrossNet) {
690    CrossIdToNameH.AddDat(CrossNetId, CrossNetName);
691    CrossNameToIdH.AddDat(CrossNetName, CrossNetId);
692    TCrossNetH.AddDat(CrossNetId, CrossNet);
693    TCrossNetH[CrossNetId].SetParentPointer(this);
694    return CrossNetId;
695  }
696  void TMMNet::ClrNbr(const TInt& ModeId, const TInt& CrossNetId, const bool& outEdge, const bool& sameMode, bool& isDir) {
697    TStr CrossNetName = CrossIdToNameH[CrossNetId];
698    TModeNetH[ModeId].ClrNbr(CrossNetName, outEdge, sameMode, isDir);
699  }
700  PMMNet TMMNet::GetSubgraphByCrossNet(TStrV& CrossNetTypes) {
701    PMMNet Result = New();
702    TInt MxMode = 0;
703    TInt MxCross = 0;
704    TIntH ModeH;
705    for(int i = 0; i < CrossNetTypes.Len(); i++) {
706      TStr CrossName = CrossNetTypes[i];
707      TInt OldId = CrossNameToIdH.GetDat(CrossName);
708      TInt NewId = MxCross++;
709      TCrossNet NewCrossNet(TCrossNetH.GetDat(OldId));
710      TInt OldModeId1 = NewCrossNet.Mode1;
711      TInt OldModeId2 = NewCrossNet.Mode2;
712      TInt NewModeId1, NewModeId2;
713      if (ModeH.IsKey(OldModeId1)) {
714        NewModeId1 = ModeH.GetDat(OldModeId1);
715      } else {
716        NewModeId1 = MxMode++;
717        ModeH.AddDat(OldModeId1, NewModeId1);
718      }
719      if (ModeH.IsKey(OldModeId2)) {
720        NewModeId2 = ModeH.GetDat(OldModeId2);
721      } else {
722        NewModeId2 = MxMode++;
723        ModeH.AddDat(OldModeId2, NewModeId2);
724      }
725      NewCrossNet.Mode1 = NewModeId1;
726      NewCrossNet.Mode2 = NewModeId2;
727      NewCrossNet.CrossNetId = NewId;
728      Result->AddCrossNet(CrossName, NewId, NewCrossNet);
729    }
730    for(TIntH::TIter it = ModeH.BegI(); it < ModeH.EndI(); it++) {
731      TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
732      TInt NewModeId = it.GetDat();
733      TModeNet NewModeNet;
734      TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, CrossNetTypes);
735      NewModeNet.ModeId = NewModeId;
736      Result->AddMode(ModeName, NewModeId, NewModeNet);
737    }
738    Result->MxModeId = MxMode;
739    Result->MxCrossNetId = MxCross;
740    return Result;
741  }
742  PMMNet TMMNet::GetSubgraphByModeNet(TStrV& ModeNetTypes) {
743    THash<TInt, TBool> ModeTypeIds;
744    for (int i = 0; i < ModeNetTypes.Len(); i++) {
745      ModeTypeIds.AddDat(ModeNameToIdH.GetDat(ModeNetTypes[i]), true);
746    }
747    TStrV CrossNetTypes;
748    for (THash<TInt, TCrossNet>::TIter it = TCrossNetH.BegI(); it < TCrossNetH.EndI(); it++) {
749      TCrossNet& CrossNet = it.GetDat();
750      if (ModeTypeIds.IsKey(CrossNet.Mode1) && ModeTypeIds.IsKey(CrossNet.Mode2)) {
751        CrossNetTypes.Add(CrossIdToNameH.GetDat(it.GetKey()));
752        ModeTypeIds[CrossNet.Mode1] = false;
753        ModeTypeIds[CrossNet.Mode2] = false;
754      }
755    }
756    PMMNet Result = GetSubgraphByCrossNet(CrossNetTypes);
757    TInt MxMode = Result->MxModeId;
758    TStrV EmptyCrossNetTypes;
759    for (THash<TInt, TBool>::TIter it = ModeTypeIds.BegI(); it < ModeTypeIds.EndI(); it++) {
760      if (it.GetDat().Val) {
761        TStr ModeName = ModeIdToNameH.GetDat(it.GetKey());
762        TInt NewModeId = MxMode++;
763        TModeNet NewModeNet;
764        TModeNetH.GetDat(it.GetKey()).RemoveCrossNets(NewModeNet, EmptyCrossNetTypes);
765        NewModeNet.ModeId = NewModeId;
766        Result->AddMode(ModeName, NewModeId, NewModeNet);
767      }
768    }
769    Result->MxModeId = MxMode;
770    return Result;
771  }
772  PNEANet TMMNet::ToNetwork(TIntV& CrossNetTypes, TIntStrStrTrV& NodeAttrMap, TVec<TTriple<TInt, TStr, TStr> >& EdgeAttrMap) {
773    TIntPrIntH NodeMap;
774    THash<TIntPr, TIntPr> EdgeMap;
775    THashSet<TInt> Modes;
776    PNEANet NewNet = TNEANet::New();
777    for (int i = 0; i < CrossNetTypes.Len(); i++) {
778      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
779      TInt Mode1 = CrossNet.GetMode1();
780      TInt Mode2 = CrossNet.GetMode2();
781      Modes.AddKey(Mode1);
782      Modes.AddKey(Mode2);
783      bool isDirected = CrossNet.IsDirected();
784      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
785        int srcNode = EdgeI.GetSrcNId();
786        int dstNode = EdgeI.GetDstNId();
787        TIntPr SrcNodeMapping(Mode1, srcNode);
788        int srcId = 0;
789        if (NodeMap.IsKey(SrcNodeMapping)) {
790          srcId = NodeMap.GetDat(SrcNodeMapping);
791        } else {
792          srcId = NewNet->AddNode();
793          NodeMap.AddDat(SrcNodeMapping, srcId);
794        }
795        TIntPr DstNodeMapping(Mode2, dstNode);
796        int dstId = 0;
797        if (NodeMap.IsKey(DstNodeMapping)) {
798          dstId = NodeMap.GetDat(DstNodeMapping);
799        } else {
800          dstId = NewNet->AddNode();
801          NodeMap.AddDat(DstNodeMapping, dstId);
802        }
803        int edgeId = EdgeI.GetId();
804        TIntPr EdgeMapping(CrossNetTypes[i], edgeId);
805        int newEId = NewNet->AddEdge(srcId, dstId);
806        int otherEId = -1;
807        if (!isDirected) {
808          otherEId = NewNet->AddEdge(dstId, srcId);
809        }
810        EdgeMap.AddDat(EdgeMapping, TIntPr(newEId, otherEId));
811      }
812    }
813    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
814      TModeNet &ModeNet = GetModeNetById(it.GetKey());
815      TInt ModeId = it.GetKey();
816      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
817        TIntPr NodeKey(ModeId, NodeIt.GetId());
818        if (!NodeMap.IsKey(NodeKey)) {
819          int newId = NewNet->AddNode();
820          NodeMap.AddDat(NodeKey, newId);
821        }
822      }
823    }
824    NewNet->AddIntAttrN(TStr("Mode"));
825    NewNet->AddIntAttrN(TStr("Id"));
826    NewNet->AddIntAttrE(TStr("CrossNet"));
827    NewNet->AddIntAttrE(TStr("Id"));
828    for(TIntPrIntH::TIter it = NodeMap.BegI(); it != NodeMap.EndI(); it++) {
829      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal1(), TStr("Mode"));
830      NewNet->AddIntAttrDatN(it.GetDat(), it.GetKey().GetVal2(), TStr("Id"));
831    }
832    for(THash<TIntPr, TIntPr>::TIter it = EdgeMap.BegI(); it != EdgeMap.EndI(); it++) {
833      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal1(), TStr("CrossNet"));
834      NewNet->AddIntAttrDatE(it.GetDat().GetVal1(), it.GetKey().GetVal2(), TStr("Id"));
835      if (it.GetDat().GetVal2() != -1) {
836        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal1(), TStr("CrossNet"));
837        NewNet->AddIntAttrDatE(it.GetDat().GetVal2(), it.GetKey().GetVal2(), TStr("Id"));
838      }
839    }
840    for (int i = 0; i < NodeAttrMap.Len(); i++) {
841      TInt ModeId = NodeAttrMap[i].Val1;
842      TStr OrigAttr = NodeAttrMap[i].Val2;
843      TStr NewAttr = NodeAttrMap[i].Val3;
844      TModeNet& Net = GetModeNetById(ModeId);
845      int type = Net.GetAttrTypeN(OrigAttr);
846      if (type == TModeNet::IntType) {
847        NewNet->AddIntAttrN(NewAttr, Net.GetIntAttrDefaultN(OrigAttr));
848        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
849          TIntPr OldNId(ModeId, it.GetId());
850          int NewId = NodeMap.GetDat(OldNId);
851          int Val = Net.GetIntAttrDatN(it.GetId(), OrigAttr);
852          NewNet->AddIntAttrDatN(NewId, Val, NewAttr);
853        }
854      } else if (type == TModeNet::FltType) {
855        NewNet->AddFltAttrN(NewAttr, Net.GetFltAttrDefaultN(OrigAttr));
856        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
857          TIntPr OldNId(ModeId, it.GetId());
858          int NewId = NodeMap.GetDat(OldNId);
859          TFlt Val = Net.GetFltAttrDatN(it.GetId(), OrigAttr);
860          NewNet->AddFltAttrDatN(NewId, Val, NewAttr);
861        }
862      } else if (type == TModeNet::StrType) {
863        NewNet->AddStrAttrN(NewAttr, Net.GetStrAttrDefaultN(OrigAttr));
864        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
865          TIntPr OldNId(ModeId, it.GetId());
866          int NewId = NodeMap.GetDat(OldNId);
867          TStr Val = Net.GetStrAttrDatN(it.GetId(), OrigAttr);
868          NewNet->AddStrAttrDatN(NewId, Val, NewAttr);
869        }
870      } else if (type == TModeNet::IntVType) {
871        NewNet->AddIntVAttrN(NewAttr);
872        for(TModeNet::TNodeI it = Net.BegMMNI(); it != Net.EndMMNI(); it++) {
873          TIntPr OldNId(ModeId, it.GetId());
874          int NewId = NodeMap.GetDat(OldNId);
875          TIntV Val = Net.GetIntVAttrDatN(it.GetId(), OrigAttr);
876          NewNet->AddIntVAttrDatN(NewId, Val, NewAttr);
877        }
878      }
879    }
880    for (int i = 0; i < EdgeAttrMap.Len(); i++) {
881      TInt CrossId = EdgeAttrMap[i].Val1;
882      TStr OrigAttr = EdgeAttrMap[i].Val2;
883      TStr NewAttr = EdgeAttrMap[i].Val3;
884      TCrossNet& Net = GetCrossNetById(CrossId);
885      int type = Net.GetAttrTypeE(OrigAttr);
886      if (type == TCrossNet::IntType) {
887        NewNet->AddIntAttrE(NewAttr, Net.GetIntAttrDefaultE(OrigAttr));
888        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
889          TIntPr OldNId(CrossId, it.GetId());
890          TIntPr NewId = EdgeMap.GetDat(OldNId);
891          int Val = Net.GetIntAttrDatE(it.GetId(), OrigAttr);
892          NewNet->AddIntAttrDatE(NewId.Val1, Val, NewAttr);
893          if (NewId.Val2 != -1) {
894            NewNet->AddIntAttrDatE(NewId.Val2, Val, NewAttr);
895          }
896        }
897      } else if (type == TCrossNet::FltType) {
898        NewNet->AddFltAttrE(NewAttr, Net.GetFltAttrDefaultE(OrigAttr));
899        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++) {
900          TIntPr OldNId(CrossId, it.GetId());
901          TIntPr NewId = EdgeMap.GetDat(OldNId);
902          TFlt Val = Net.GetFltAttrDatE(it.GetId(), OrigAttr);
903          NewNet->AddFltAttrDatE(NewId.Val1, Val, NewAttr);
904          if (NewId.Val2 != -1) {
905            NewNet->AddFltAttrDatE(NewId.Val2, Val, NewAttr);
906          }
907        }
908      } else if (type == TCrossNet::StrType) {
909        NewNet->AddStrAttrE(NewAttr, Net.GetStrAttrDefaultE(OrigAttr));
910        for(TCrossNet::TCrossEdgeI it = Net.BegEdgeI(); it != Net.EndEdgeI(); it++){
911          TIntPr OldNId(CrossId, it.GetId());
912          TIntPr NewId = EdgeMap.GetDat(OldNId);
913          TStr Val = Net.GetStrAttrDatE(it.GetId(), OrigAttr);
914          NewNet->AddStrAttrDatE(NewId.Val1, Val, NewAttr);
915          if (NewId.Val2 != -1) {
916            NewNet->AddStrAttrDatE(NewId.Val2, Val, NewAttr);
917          }
918        }
919      }
920    }
921    return NewNet;
922  }
923  PNEANet TMMNet::ToNetwork2(TIntV& CrossNetTypes, TIntStrPrVH& NodeAttrMap, THash<TInt, TVec<TPair<TStr, TStr> > >& EdgeAttrMap) {
924    TIntPrIntH NodeMap;
925    THashSet<TInt> Modes;
926    PNEANet NewNet = TNEANet::New();
927    NewNet->AddIntAttrN(TStr("Mode"));
928    NewNet->AddIntAttrN(TStr("Id"));
929    NewNet->AddIntAttrE(TStr("CrossNet"));
930    NewNet->AddIntAttrE(TStr("Id"));
931    for (int i = 0; i < CrossNetTypes.Len(); i++) {
932      TCrossNet& CrossNet = GetCrossNetById(CrossNetTypes[i]);
933      TStrPrV CNetAttrs;
934      if (EdgeAttrMap.IsKey(CrossNetTypes[i])) {
935        CNetAttrs = EdgeAttrMap.GetDat(CrossNetTypes[i]);
936      }
937      TInt Mode1 = CrossNet.GetMode1();
938      TInt Mode2 = CrossNet.GetMode2();
939      TModeNet& Mode1Net = GetModeNetById(Mode1);
940      TModeNet& Mode2Net = GetModeNetById(Mode2);
941      TStrPrV Mode1Attrs;
942      if (NodeAttrMap.IsKey(Mode1)) {
943        Mode1Attrs = NodeAttrMap.GetDat(Mode1);
944      }
945      TStrPrV Mode2Attrs;
946      if (NodeAttrMap.IsKey(Mode2)) {
947        Mode2Attrs = NodeAttrMap.GetDat(Mode2);
948      } 
949      Modes.AddKey(Mode1);
950      Modes.AddKey(Mode2);
951      bool isDirected = CrossNet.IsDirected();
952      for(TCrossNet::TCrossEdgeI EdgeI = CrossNet.BegEdgeI(); EdgeI != CrossNet.EndEdgeI(); EdgeI++) {
953        int srcNode = EdgeI.GetSrcNId();
954        int dstNode = EdgeI.GetDstNId();
955        TIntPr SrcNodeMapping(Mode1, srcNode);
956        int srcId = 0;
957        if (NodeMap.IsKey(SrcNodeMapping)) {
958          srcId = NodeMap.GetDat(SrcNodeMapping);
959        } else {
960          srcId = NewNet->AddNode();
961          NodeMap.AddDat(SrcNodeMapping, srcId);
962          NewNet->AddIntAttrDatN(srcId, srcNode, TStr("Id"));
963          NewNet->AddIntAttrDatN(srcId, Mode1, TStr("Mode"));
964          AddNodeAttributes(NewNet, Mode1Net, Mode1Attrs, Mode1, srcNode, srcId);
965        }
966        TIntPr DstNodeMapping(Mode2, dstNode);
967        int dstId = 0;
968        if (NodeMap.IsKey(DstNodeMapping)) {
969          dstId = NodeMap.GetDat(DstNodeMapping);
970        } else {
971          dstId = NewNet->AddNode();
972          NodeMap.AddDat(DstNodeMapping, dstId);
973          NewNet->AddIntAttrDatN(dstId, dstNode, TStr("Id"));
974          NewNet->AddIntAttrDatN(dstId, Mode2, TStr("Mode"));
975          AddNodeAttributes(NewNet, Mode2Net, Mode2Attrs, Mode2, dstNode, dstId);
976        }
977        int edgeId = EdgeI.GetId();
978        int newEId = NewNet->AddEdge(srcId, dstId);
979        NewNet->AddIntAttrDatE(newEId, edgeId, TStr("Id"));
980        NewNet->AddIntAttrDatE(newEId, CrossNetTypes[i], TStr("CrossNet"));
981        AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, newEId);
982        if (!isDirected) {
983          int otherEId = NewNet->AddEdge(dstId, srcId);
984          NewNet->AddIntAttrDatE(otherEId, edgeId, TStr("Id"));
985          NewNet->AddIntAttrDatE(otherEId, CrossNetTypes[i], TStr("CrossNet"));
986          AddEdgeAttributes(NewNet, CrossNet, CNetAttrs, CrossNetTypes[i], edgeId, otherEId);
987        }
988      }
989    }
990    for (THashSet<TInt>::TIter it = Modes.BegI(); it != Modes.EndI(); it++) {
991      TInt ModeId = it.GetKey();
992      TModeNet &ModeNet = GetModeNetById(ModeId);
993      TStrPrV ModeAttrs = NodeAttrMap.GetDat(ModeId);
994      for(TModeNet::TNodeI NodeIt = ModeNet.BegMMNI(); NodeIt != ModeNet.EndMMNI(); NodeIt++) {
995        TIntPr NodeKey(ModeId, NodeIt.GetId());
996        if (!NodeMap.IsKey(NodeKey)) {
997          int newId = NewNet->AddNode();
998          NodeMap.AddDat(NodeKey, newId);
999          AddNodeAttributes(NewNet, ModeNet, ModeAttrs, ModeId, NodeIt.GetId(), newId);
1000        }
1001      }
1002    }
1003    return NewNet;
1004  }
1005  void TMMNet::GetPartitionRanges(TIntPrV& Partitions, const TInt& NumPartitions, const TInt& MxLen) const {
1006    if (MxLen <= NumPartitions) {
1007        Partitions.Add(TIntPr(0,MxLen));
1008    } else {
1009      TInt PartitionSize = MxLen/NumPartitions;
1010      TInt CurrStart = 0;
1011      bool done = false;
1012      while (!done) {
1013        TInt CurrEnd = CurrStart + PartitionSize;
1014        if (MxLen - CurrEnd < PartitionSize) {
1015          CurrEnd = MxLen;
1016          done = true;
1017        }
1018        Partitions.Add(TIntPr(CurrStart, CurrEnd));
1019        CurrStart = CurrEnd;
1020      }
1021    }
1022  }
1023  #ifdef GCC_ATOMIC
1024  PNEANetMP TMMNet::ToNetworkMP(TStrV& CrossNetNames) {
1025    TStrIntH CrossNetStart;
1026    THashSet<TInt> ModeSet;
1027    int offset = 0;
1028    int NumEdges = 0;
1029    TVec<TCrossNet> CrossNets;
1030    for (int i=0; i < CrossNetNames.Len(); i++) {
1031      CrossNets.Add(GetCrossNetByName(CrossNetNames[i]));
1032      CrossNetStart.AddDat(CrossNetNames[i], offset);
1033      TCrossNet& CrossNet = GetCrossNetByName(CrossNetNames[i]);
1034      int factor = CrossNet.IsDirected() ? 1 : 2;
1035      offset += (CrossNet.GetMxEId() * factor);
1036      NumEdges += (CrossNet.GetEdges() * factor);
1037      ModeSet.AddKey(CrossNet.GetMode1());
1038      ModeSet.AddKey(CrossNet.GetMode2());
1039    }
1040    int MxEId = offset;
1041    int NumNodes = 0;
1042    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1043      TModeNet& ModeNet = GetModeNetById(MI.GetKey());
1044      NumNodes += ModeNet.GetNodes();
1045    }
1046    THashMP<TIntPr, TInt> NodeMap(NumNodes);
1047    THashMP<TIntPr, TIntPr> EdgeMap(NumEdges);
1048    PNEANetMP NewNet = TNEANetMP::New(NumNodes, NumEdges);
1049    int num_threads = omp_get_max_threads();
1050    offset = 0;
1051    for (THashSet<TInt>::TIter MI = ModeSet.BegI(); MI < ModeSet.EndI(); MI++) {
1052      TInt ModeId = MI.GetKey();
1053      TModeNet& ModeNet = GetModeNetById(ModeId);
1054      TIntV KeyIds;
1055      ModeNet.NodeH.GetKeyV(KeyIds);
1056      TIntPrV NodePartitions;
1057      GetPartitionRanges(NodePartitions, num_threads, KeyIds.Len());
1058      int curr_nid;
1059      #pragma omp parallel for schedule(static) private(curr_nid)
1060      for (int i = 0; i < NodePartitions.Len(); i++) {
1061        TInt CurrStart = NodePartitions[i].GetVal1();
1062        TInt CurrEnd = NodePartitions[i].GetVal2();
1063        curr_nid = offset + CurrStart;
1064        for (int idx = CurrStart; idx < CurrEnd ; idx++) {
1065          int n_i = KeyIds[idx];
1066          if (ModeNet.IsNode(n_i)) {
1067            TIntV InNbrs;
1068            TIntV OutNbrs;
1069            for (int j=0; j < CrossNetNames.Len(); j++) {
1070              TStr CrossNetName = TStr(CrossNetNames[j].CStr());
1071              if (ModeNet.NeighborTypes.IsKey(CrossNetName)) {
1072                if (ModeNet.NeighborTypes.GetDat(CrossNetName)) {
1073                  TIntV Neighbors;
1074                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, Neighbors);
1075                  int edge_offset = CrossNetStart.GetDat(CrossNetName);
1076                  TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1077                  bool isDir = CrossNet.IsDirected();
1078                  bool isOutNbr = CrossNet.GetMode1() == ModeId;
1079                  int factor = isDir ? 1 : 2;
1080                  int id_offset = isDir || isOutNbr ? 0 : 1;
1081                  if (!isDir && CrossNet.GetMode1() == CrossNet.GetMode2()) {
1082                    id_offset = n_i == CrossNet.GetEdge(n_i).GetSrcNId() ? 0 : 1;
1083                  }
1084                  for (int k = 0; k < Neighbors.Len(); k++) {
1085                    if (isOutNbr && id_offset == 0) {
1086                      OutNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1087                    } else {
1088                      InNbrs.Add(edge_offset + Neighbors[k]*factor + id_offset);
1089                    }
1090                    if (!isDir) {
1091                      int opp_offset = id_offset == 1 ? 0 : 1;
1092                      if (isOutNbr && id_offset == 0) {
1093                        InNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1094                      } else {
1095                        OutNbrs.Add(edge_offset + Neighbors[k]*factor + opp_offset);
1096                      }
1097                    }
1098                  }
1099                } else {
1100                  TIntV TempOut;
1101                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempOut, true);
1102                  OutNbrs.AddV(TempOut);
1103                  TIntV TempIn;
1104                  ModeNet.GetNeighborsByCrossNet(n_i, CrossNetName, TempIn, false);
1105                  InNbrs.AddV(TempIn);
1106                }
1107              }
1108            }
1109            NewNet->AddNodeWithEdges(curr_nid, InNbrs, OutNbrs);
1110            TIntPr NodeKey(MI.GetKey(), n_i);
1111            NodeMap.AddDat(NodeKey, curr_nid);
1112            curr_nid++;
1113          }
1114        }
1115      }
1116      offset += KeyIds.Len();
1117    }
1118    NewNet->SetNodes(offset);
1119    for (int j=0; j < CrossNetNames.Len(); j++) {
1120      TStr CrossNetName = CrossNetNames[j];
1121      TCrossNet& CrossNet = GetCrossNetByName(CrossNetName);
1122      TInt CrossNetId = GetCrossId(CrossNetName);
1123      TInt Mode1 = CrossNet.GetMode1();
1124      TInt Mode2 = CrossNet.GetMode2();
1125      TIntPrV EdgePartitions;
1126      GetPartitionRanges(EdgePartitions, num_threads, CrossNet.MxEId);
1127      int curr_eid;
1128      offset = CrossNetStart.GetDat(CrossNetNames[j]);
1129      int factor = CrossNet.IsDirected() ? 1 : 2;
1130      #pragma omp parallel for schedule(static) private(curr_eid)
1131      for (int i = 0; i < EdgePartitions.Len(); i++) {
1132        TInt CurrStart = EdgePartitions[i].GetVal1();
1133        TInt CurrEnd = EdgePartitions[i].GetVal2();
1134        for (int e_i = CurrStart; e_i < CurrEnd ; e_i++) {
1135          curr_eid = offset + factor*e_i;
1136          if (CrossNet.IsEdge(e_i)) {
1137            int new_eid = curr_eid;
1138            TIntPr EdgeKey(CrossNetId, e_i);
1139            TCrossNet::TCrossEdgeI edge = CrossNet.GetEdgeI(e_i);
1140            int srcNode = edge.GetSrcNId();
1141            int dstNode = edge.GetDstNId();
1142            TIntPr NodeKeySrc(Mode1, srcNode);
1143            TIntPr NodeKeyDst(Mode2, dstNode);
1144            int newSrc = NodeMap.GetDat(NodeKeySrc);
1145            int newDst = NodeMap.GetDat(NodeKeyDst);
1146            NewNet->AddEdgeUnchecked(curr_eid, newSrc, newDst);
1147            curr_eid++;
1148            int otherEId = -1;
1149            if (!CrossNet.IsDirected()) {
1150              otherEId = curr_eid;
1151              NewNet->AddEdgeUnchecked(otherEId, newDst, newSrc);
1152            }
1153            EdgeMap.AddDat(EdgeKey, TIntPr(new_eid, otherEId));
1154          }
1155        }
1156      }
1157    }
1158    NewNet->SetEdges(MxEId);
1159    NewNet->ReserveAttr(2, 0, 0, 2, 0, 0);
1160    NewNet->AddIntAttrN(TStr("Mode"));
1161    NewNet->AddIntAttrN(TStr("Id"));
1162    NewNet->AddIntAttrE(TStr("CrossNet"));
1163    NewNet->AddIntAttrE(TStr("Id"));
1164    TIntPrV NewNodeIds;
1165    NodeMap.GetKeyV(NewNodeIds);
1166    #pragma omp parallel for schedule(static)
1167    for(int i = 0; i < NewNodeIds.Len(); i++) {
1168      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal1(), TStr("Mode"));
1169      NewNet->AddIntAttrDatN(NodeMap.GetDat(NewNodeIds[i]), NewNodeIds[i].GetVal2(), TStr("Id"));
1170    }
1171    TIntPrV NewEdgeIds;
1172    EdgeMap.GetKeyV(NewEdgeIds);
1173    #pragma omp parallel for schedule(static)
1174    for(int i = 0; i < NewEdgeIds.Len(); i++) {
1175      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1176      NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal1(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1177      if (EdgeMap.GetDat(NewEdgeIds[i]).GetVal2() != -1) {
1178        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal1(), TStr("CrossNet"));
1179        NewNet->AddIntAttrDatE(EdgeMap.GetDat(NewEdgeIds[i]).GetVal2(), NewEdgeIds[i].GetVal2(), TStr("Id"));
1180      }
1181    }
1182    return NewNet;
1183  }
1184  #endif 
1185  int TMMNet::AddNodeAttributes(PNEANet& NewNet, TModeNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int ModeId, int oldId, int NId) {
1186    for (int i = 0; i < Attrs.Len(); i++) {
1187      TStr OrigAttr = Attrs[i].Val1;
1188      TStr NewAttr = Attrs[i].Val2;
1189      int type = Net.GetAttrTypeN(OrigAttr);
1190      if (type == TModeNet::IntType) {
1191        TIntPr OldNId(ModeId, oldId);
1192        TInt Val = Net.GetIntAttrDatN(oldId, OrigAttr);
1193        NewNet->AddIntAttrDatN(NId, Val, NewAttr);
1194      } else if (type == TModeNet::FltType) {
1195        TIntPr OldNId(ModeId, oldId);
1196        TFlt Val = Net.GetFltAttrDatN(oldId, OrigAttr);
1197        NewNet->AddFltAttrDatN(NId, Val, NewAttr);
1198      } else if (type == TModeNet::StrType) {
1199        TIntPr OldNId(ModeId, oldId);
1200        TStr Val = Net.GetStrAttrDatN(oldId, OrigAttr);
1201        NewNet->AddStrAttrDatN(NId, Val, NewAttr);
1202      } else if (type == TModeNet::IntVType) {
1203        TIntPr OldNId(ModeId, oldId);
1204        TIntV Val = Net.GetIntVAttrDatN(oldId, OrigAttr);
1205        NewNet->AddIntVAttrDatN(NId, Val, NewAttr);
1206      }
1207    }
1208    return 0;
1209  }
1210  int TMMNet::AddEdgeAttributes(PNEANet& NewNet, TCrossNet& Net, TVec<TPair<TStr, TStr> >& Attrs, int CrossId, int oldId, int EId) {
1211    for (int i = 0; i < Attrs.Len(); i++) {
1212      TStr OrigAttr = Attrs[i].Val1;
1213      TStr NewAttr = Attrs[i].Val2;
1214      int type = Net.GetAttrTypeE(OrigAttr);
1215      if (type == TCrossNet::IntType) {
1216        TIntPr OldNId(CrossId, oldId);
1217        TInt Val = Net.GetIntAttrDatE(oldId, OrigAttr);
1218        NewNet->AddIntAttrDatE(EId, Val, NewAttr);
1219      } else if (type == TCrossNet::FltType) {
1220        TIntPr OldNId(CrossId, oldId);
1221        TFlt Val = Net.GetFltAttrDatE(oldId, OrigAttr);
1222        NewNet->AddFltAttrDatE(EId, Val, NewAttr);
1223      } else if (type == TCrossNet::StrType) {
1224        TIntPr OldNId(CrossId, oldId);
1225        TStr Val = Net.GetStrAttrDatE(oldId, OrigAttr);
1226        NewNet->AddStrAttrDatE(EId, Val, NewAttr);
1227      }
1228    }
1229    return 0;
1230  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</h3>
            <pre><code>1  const int TRnd::RndSeed=0;
2  const int TRnd::a=16807;
3  const int TRnd::m=2147483647;
4  const int TRnd::q=127773; 
5  const int TRnd::r=2836; 
6  void TRnd::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
7    XLoadHd(Nm);
8    Seed=TXmlObjSer::GetIntArg(XmlTok, "Seed");
9  }
10  void TRnd::SaveXml(TSOut& SOut, const TStr& Nm) const {
11    XSaveBETagArg(Nm, "Seed", TInt::GetStr(Seed));
12  }
13  void TRnd::PutSeed(const int& _Seed){
14    Assert(_Seed>=0);
15    if (_Seed==0){
16      Seed=abs(int(TSysTm::GetPerfTimerTicks()));
17    } else {
18      Seed=_Seed;
19    }
20  }
21  void TRnd::Move(const int& Steps){
22    for (int StepN=0; StepN<Steps; StepN++){GetNextSeed();}
23  }
24  bool TRnd::Check(){
25    int PSeed=Seed; Seed=1;
26    for (int SeedN=0; SeedN<10000; SeedN++){GetNextSeed();}
27    bool Ok=Seed==1043618065; Seed=PSeed; return Ok;
28  }
29  int TRnd::GetUniDevInt(const int& Range){
30    int Seed=GetNextSeed();
31    if (Range==0){return Seed;}
32    else {return Seed%Range;}
33  }
34  uint TRnd::GetUniDevUInt(const uint& Range){
35    uint Seed=uint(GetNextSeed()%0x10000)*0x10000+uint(GetNextSeed()%0x10000);
36    if (Range==0){return Seed;}
37    else {return Seed%Range;}
38  }
39  int64 TRnd::GetUniDevInt64(const int64& Range){
40    const int64 RndVal = int64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
41    if (Range==0){return RndVal;}
42    else {return RndVal%Range;}
43  }
44  uint64 TRnd::GetUniDevUInt64(const uint64& Range){
45   const uint64 RndVal = uint64((uint64(GetUniDevInt())<<32) | uint64(GetUniDevInt()));
46   if (Range==0){return RndVal;}
47   else {return RndVal%Range;}
48  }
49  double TRnd::GetNrmDev(){
50    double v1, v2, rsq;
51    do {
52      v1=2.0*GetUniDev()-1.0; 
53      v2=2.0*GetUniDev()-1.0; 
54      rsq=v1*v1+v2*v2; 
55    } while ((rsq>=1.0)||(rsq==0.0)); 
56    double fac=sqrt(-2.0*log(rsq)/rsq); 
57    return v1*fac;
58  }
59  double TRnd::GetNrmDev(
60   const double& Mean, const double& SDev, const double& Mn, const double& Mx){
61    double Val=Mean+GetNrmDev()*SDev;
62    if (Val<Mn){Val=Mn;}
63    if (Val>Mx){Val=Mx;}
64    return Val;
65  }
66  double TRnd::GetExpDev(){
67    double UniDev;
68    do {
69      UniDev=GetUniDev();
70    } while (UniDev==0.0);
71    return -log(UniDev);
72  }
73  double TRnd::GetExpDev(const double& Lambda) {
74    return GetExpDev()/Lambda;
75  }
76  double TRnd::GetGammaDev(const int& Order){
77    int j;
78    double am,e,s,v1,v2,x,y;
79    if (Order<1){Fail;}
80    if (Order<6) {
81      x=1.0;
82      for (j=1;j<=Order;j++) x *=GetUniDev();
83      x = -log(x);
84    } else {
85      do {
86        do {
87          do {
88            v1=2.0*GetUniDev()-1.0;
89            v2=2.0*GetUniDev()-1.0;
90          } while (v1*v1+v2*v2 > 1.0);
91          y=v2/v1;
92          am=Order-1;
93          s=sqrt(2.0*am+1.0);
94          x=s*y+am;
95        } while (x <= 0.0);
96        e=(1.0+y*y)*exp(am*log(x/am)-s*y);
97      } while (GetUniDev()>e);
98    }
99    return x;
100  }
101  double TRnd::GetPoissonDev(const double& Mean){
102    static double sq,alxm,g,oldm=(-1.0);
103    double em,t,y;
104    if (Mean < 12.0) {
105      if (Mean != oldm) {
106        oldm=Mean;
107        g=exp(-Mean);
108      }
109      em = -1;
110      t=1.0;
111      do {
112        ++em;
113        t *= GetUniDev();
114      } while (t>g);
115    } else {
116      if (Mean != oldm) {
117        oldm=Mean;
118        sq=sqrt(2.0*Mean);
119        alxm=log(Mean);
120        g=Mean*alxm-TSpecFunc::LnGamma(Mean+1.0);
121      }
122      do {
123        do {
124          y=tan(TMath::Pi*GetUniDev());
125          em=sq*y+Mean;
126        } while (em < 0.0);
127        em=floor(em);
128        t=0.9*(1.0+y*y)*exp(em*alxm-TSpecFunc::LnGamma(em+1.0)-g);
129      } while (GetUniDev()>t);
130    }
131    return em;
132  }
133  double TRnd::GetBinomialDev(const double& Prb, const int& Trials){
134    int j;
135    static int nold=(-1);
136    double am,em,g,angle,p,bnl,sq,t,y;
137    static double pold=(-1.0),pc,plog,pclog,en,oldg;
138    p=(Prb <= 0.5 ? Prb : 1.0-Prb);
139    am=Trials*p;
140    if (Trials < 25) {
141      bnl=0.0;
142      for (j=1;j<=Trials;j++)
143        if (GetUniDev() < p) ++bnl;
144    } else if (am < 1.0) {
145      g=exp(-am);
146      t=1.0;
147      for (j=0;j<=Trials;j++) {
148        t *= GetUniDev();
149        if (t < g) break;
150      }
151      bnl=(j <= Trials ? j : Trials);
152    } else {
153      if (Trials != nold) {
154        en=Trials;
155        oldg=TSpecFunc::LnGamma(en+1.0);
156        nold=Trials;
157      } if (p != pold) {
158        pc=1.0-p;
159        plog=log(p);
160        pclog=log(pc);
161        pold=p;
162      }
163      sq=sqrt(2.0*am*pc);
164      do {
165        do {
166          angle=TMath::Pi*GetUniDev();
167          y=tan(angle);
168          em=sq*y+am;
169        } while (em < 0.0 || em >= (en+1.0));
170        em=floor(em);
171        t=1.2*sq*(1.0+y*y)*exp(oldg-(em+1.0)
172          -TSpecFunc::LnGamma(en-em+1.0)+em*plog+(en-em)*pclog);
173      } while (GetUniDev() > t);
174      bnl=em;
175    }
176    if (p != Prb) bnl=Trials-bnl;
177    return bnl;
178  }
179  TRnd TRnd::LoadTxt(TILx& Lx){
180    return TRnd(Lx.GetInt());
181  }
182  void TRnd::SaveTxt(TOLx& Lx) const {
183    Lx.PutInt(Seed);
184  }
185  void TMem::Resize(const int& _MxBfL){
186    if (_MxBfL<=MxBfL){return;}
187    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
188    char* NewBf=new char[MxBfL]; IAssert(NewBf!=NULL);
189    if (BfL>0){memcpy(NewBf, Bf, BfL);}
190    if (Bf!=NULL){delete[] Bf;}
191    Bf=NewBf;
192  }
193  TMem::TMem(const TStr& Str):
194    MxBfL(Str.Len()), BfL(MxBfL), Bf(NULL){
195    if (MxBfL>0){
196      Bf=new char[MxBfL];
197      if (BfL>0){memcpy(Bf, Str.CStr(), BfL);}
198    }
199  }
200  void TMem::SaveXml(TSOut& SOut, const TStr& Nm) const {
201    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
202    SOut.PutStr(TXmlLx::GetXmlStrFromPlainMem(*this));
203  }
204  bool TMem::DoFitStr(const TStr& Str) const {
205    return DoFitLen(Str.Len()+1);
206  }
207  TMem& TMem::operator+=(const char& Ch){
208    if (BfL==MxBfL){Resize(BfL+1);}
209    Bf[BfL]=Ch; BfL++; return *this;
210  }
211  TMem& TMem::operator+=(const TMem& Mem){
212    int LBfL=Mem.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
213    if (LBfL>0){memcpy(&Bf[BfL], Mem(), LBfL);}
214    BfL+=LBfL; return *this;
215  }
216  TMem& TMem::operator+=(const TStr& Str){
217    int LBfL=Str.Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
218    if (LBfL>0){memcpy(Bf+BfL, Str.CStr(), LBfL);}
219    BfL+=LBfL; return *this;
220  }
221  TMem& TMem::operator+=(const PSIn& SIn){
222    int LBfL=SIn->Len(); if (BfL+LBfL>MxBfL){Resize(BfL+LBfL);}
223    char* LBf=new char[LBfL];
224    SIn->GetBf(LBf, LBfL);
225    if (LBfL>0){memcpy(Bf+BfL, LBf, LBfL);}
226    delete[] LBf;
227    BfL+=LBfL; return *this;
228  }
229  void TMem::Del(const int& BChN, const int& EChN){
230    if (BChN>EChN){return;}
231    if ((BChN==0)&&(EChN==BfL-1)){Clr(); return;}
232    IAssert((0<=BChN)&&(BChN<=EChN)&&(EChN<BfL));
233    memmove(Bf+BChN, Bf+EChN+1, BfL-EChN-1);
234    BfL-=(EChN-BChN+1);
235  }
236  void TMem::AddBf(const void* _Bf, const int& _BfL){
237  	IAssert((_BfL>=0) && (_Bf != NULL));
238    Reserve(Len() + _BfL, false);
239    memcpy(Bf + BfL, _Bf, _BfL);  
240     BfL+=_BfL;
241  }
242  TStr TMem::GetAsStr(const char& NewNullCh) const {
243    if (NewNullCh!='\0'){
244      TChA ChA(*this);
245      ChA.ChangeCh('\0', NewNullCh);
246      return ChA;
247    } else {
248      return TStr(*this);
249    }
250  }
251  TMemIn::TMemIn(const TMem& _Mem, const int& _BfC):
252    TSBase("Input-Memory"), TSIn("Input-Memory"), Mem(), Bf(_Mem()), BfC(_BfC), BfL(_Mem.Len()){}
253  int TMemIn::GetBf(const void* LBf, const TSize& LBfL){
254    Assert(TSize(BfC+LBfL)<=TSize(BfL));
255    int LBfS=0;
256    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
257      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
258    return LBfS;
259  }
260  bool TMemIn::GetNextLnBf(TChA& LnChA){
261    FailR(TStr::Fmt("TMemIn::GetNextLnBf: not implemented").CStr());
262    return false;
263  }
264  TMemOut::TMemOut(const PMem& _Mem): TSBase("Output-Memory"), TSOut("Output-Memory"), Mem(_Mem){}
265  int TMemOut::PutBf(const void* LBf, const TSize& LBfL){
266    int LBfS=0;
267    TMem& _Mem=*Mem;
268    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
269      char Ch=((char*)LBf)[LBfC];
270      LBfS+=Ch; _Mem+=Ch;
271    }
272    return LBfS;
273  }
274  void TChA::Resize(const int& _MxBfL){
275    if (_MxBfL<=MxBfL){return;}
276    else {if (MxBfL*2<_MxBfL){MxBfL=_MxBfL;} else {MxBfL*=2;}}
277    char* NewBf=new char[MxBfL+1]; IAssert(NewBf!=NULL);
278    strcpy(NewBf, Bf);
279    delete[] Bf; Bf=NewBf;
280  }
281  TChA::TChA(const TStr& Str){
282    Bf=new char[(MxBfL=BfL=Str.Len())+1];
283    strcpy(Bf, Str.CStr());
284  }
285  void TChA::SaveXml(TSOut& SOut, const TStr& Nm) const {
286    XSaveHdArg(Nm, "BfL", TInt::GetStr(BfL));
287    SOut.PutStr(TXmlLx::GetXmlStrFromPlainStr(*this));
288  }
289  TChA& TChA::operator=(const TChA& ChA){
290    if (this!=&ChA){
291      if (ChA.BfL>MxBfL){delete[] Bf; Bf=new char[(MxBfL=ChA.BfL)+1];}
292      BfL=ChA.BfL; strcpy(Bf, ChA.CStr());
293    }
294    return *this;
295  }
296  TChA& TChA::operator=(const TStr& Str){
297    if (Str.Len()>MxBfL){delete[] Bf; Bf=new char[(MxBfL=Str.Len())+1];}
298    BfL=Str.Len(); strcpy(Bf, Str.CStr());
299    return *this;
300  }
301  TChA& TChA::operator=(const char* CStr){
302    int CStrLen=int(strlen(CStr));
303    if (CStrLen>MxBfL){delete[] Bf; Bf=new char[(MxBfL=CStrLen)+1];}
304    BfL=CStrLen; strcpy(Bf, CStr);
305    return *this;
306  }
307  TChA& TChA::operator+=(const TMem& Mem) {
308    Resize(BfL+Mem.Len());
309    strcpy(Bf+BfL, Mem.GetBf()); BfL+=Mem.Len(); return *this;
310  }
311  TChA& TChA::operator+=(const TChA& ChA){
312    Resize(BfL+ChA.Len());
313    strcpy(Bf+BfL, ChA.CStr()); BfL+=ChA.Len(); return *this;
314  }
315  TChA& TChA::operator+=(const TStr& Str){
316    Resize(BfL+Str.Len());
317    strcpy(Bf+BfL, Str.CStr()); BfL+=Str.Len(); return *this;
318  }
319  TChA& TChA::operator+=(const char* CStr){
320    int CStrLen=(int)strlen(CStr); Resize(BfL+CStrLen);
321    strcpy(Bf+BfL, CStr); BfL+=CStrLen; return *this;
322  }
323  void TChA::Ins(const int& BChN, const char* CStr){
324    Assert((0<=BChN)&&(BChN<=BfL)); /&bsol;** ali je <= v (BChN<=BfL) upravicen?
325    int CStrLen=int(strlen(CStr)); Resize(BfL+CStrLen);
326    memmove(Bf+BChN+CStrLen, Bf+BChN, BfL-BChN+1);
327    memmove(Bf+BChN, CStr, CStrLen); BfL+=CStrLen;
328  }
329  void TChA::Del(const int& ChN){
330    Assert((0<=ChN)&&(ChN<BfL));
331    memmove(Bf+ChN, Bf+ChN+1, BfL-ChN);
332    BfL--;
333  }
334  void TChA::Trunc(){
335    int BChN=0; while ((BChN<BfL)&&(GetCh(BChN)<=' ')){BChN++;}
336    int EChN=BfL-1; while ((0<=EChN)&&(GetCh(EChN)<=' ')){EChN--;}
337    if (BChN<=EChN){
338      for (int ChN=BChN; ChN<=EChN; ChN++){
339        PutCh(ChN-BChN, GetCh(ChN));}
340      Trunc(EChN-BChN+1);
341    } else {
342      Clr();
343    }
344  }
345  void TChA::Reverse(){
346    for (int ChN=0; ChN<BfL/2; ChN++){
347      char Ch=Bf[ChN];
348      Bf[ChN]=Bf[BfL-ChN-1];
349      Bf[BfL-ChN-1]=Ch;
350    }
351  }
352  TChA TChA::GetSubStr(const int& _BChN, const int& _EChN) const {
353    int BChN=TInt::GetMx(_BChN, 0);
354    int EChN=TInt::GetMn(_EChN, Len()-1);
355    int Chs=EChN-BChN+1;
356    if (Chs<=0){return TStr::GetNullStr();}
357    else if (Chs==Len()){return *this;}
358    else {
359      return TChA(CStr()+BChN, Chs);
360    }
361  }
362  int TChA::CountCh(const char& Ch, const int& BChN) const {
363    int ChN=TInt::GetMx(BChN, 0);
364    const int ThisLen=Len();
365    int Cnt = 0;
366    while (ChN<ThisLen){if (Bf[ChN]==Ch){ Cnt++;} ChN++;}
367    return Cnt;
368  }
369  int TChA::SearchCh(const char& Ch, const int& BChN) const {
370    int ChN=TInt::GetMx(BChN, 0);
371    const int ThisLen=Len();
372    while (ChN<ThisLen){if (Bf[ChN]==Ch){return ChN;} ChN++;}
373    return -1;
374  }
375  int TChA::SearchChBack(const char& Ch, int BChN) const {
376    if (BChN >= Len() || BChN < 0) { BChN = Len()-1; }
377    for (int i = BChN; i >= 0; i--) {
378      if (GetCh(i) == Ch) { return i; }
379    }
380    return -1;
381  }
382  int TChA::SearchStr(const TChA& Str, const int& BChN) const {
383    return SearchStr(Str.CStr(), BChN);
384  }
385  int TChA::SearchStr(const TStr& Str, const int& BChN) const {
386    return SearchStr(Str.CStr(), BChN);
387  }
388  int TChA::SearchStr(const char* CStr, const int& BChN) const {
389    const char* BegPos=strstr(Bf+BChN, CStr);
390    if (BegPos==NULL){return -1;}
391    else {return int(BegPos-Bf);}
392  }
393  bool TChA::IsPrefix(const char* CStr, const int& BChN) const {
394    if (BChN+(int)strlen(CStr)>Len()){return false;}
395    const char* B = Bf+BChN;
396    const char* C = CStr;
397    while (*C!=0 && *B==*C) {
398      B++; C++;
399    }
400    if (*C==0){return true;}
401    else {return false;}
402  }
403  bool TChA::IsPrefix(const TStr& Str) const {
404    return IsPrefix(Str.CStr());
405  }
406  bool TChA::IsPrefix(const TChA& Str) const {
407    return IsPrefix(Str.CStr());
408  }
409  bool TChA::IsSuffix(const char* CStr) const {
410    if ((int)strlen(CStr) > Len()) { return false; }
411    const char* E = Bf+Len()-1;
412    const char* C = CStr+strlen(CStr)-1;
413    while (C >= CStr && *E==*C) {
414      E--;  C--;
415    }
416    if (C+1 == CStr) { return true; }
417    else { return false; }
418  }
419  bool TChA::IsSuffix(const TStr& Str) const {
420    return IsSuffix(Str.CStr());
421  }
422  bool TChA::IsSuffix(const TChA& Str) const {
423    return IsSuffix(Str.CStr());
424  }
425  void TChA::ChangeCh(const char& SrcCh, const char& DstCh){
426    int StrLen=Len();
427    for (int ChN=0; ChN<StrLen; ChN++){if (Bf[ChN]==SrcCh){Bf[ChN]=DstCh;}}
428  }
429  TChA& TChA::ToLc() {
430    char *c = Bf;
431    while (*c) {
432      *c = (char) tolower(*c);  c++;
433    }
434    return *this;
435  }
436  TChA& TChA::ToUc() {
437    char *c = Bf;
438    while (*c) {
439      *c = (char) toupper(*c); c++;
440    }
441    return *this;
442  }
443  TChA& TChA::ToTrunc(){
444    int StrLen=Len(); int BChN=0; int EChN=StrLen-1;
445    while ((BChN<StrLen)&&TCh::IsWs(GetCh(BChN))){BChN++;}
446    while ((EChN>=0)&&TCh::IsWs(GetCh(EChN))){EChN--;}
447    if ((BChN!=0)||(EChN!=StrLen-1)){
448      int DstChN=0;
449      for (int SrcChN=BChN; SrcChN<=EChN; SrcChN++){
450        PutCh(DstChN, GetCh(SrcChN)); DstChN++;}
451      Trunc(DstChN);
452    }
453    return *this;
454  }
455  void TChA::CompressWs(){
456    int StrLen=Len(); int SrcChN=0; int DstChN=0;
457    while ((SrcChN<StrLen)&&TCh::IsWs(GetCh(SrcChN))){SrcChN++;}
458    while (SrcChN<StrLen){
<span onclick='openModal()' class='match'>459      if ((TCh::IsWs(GetCh(SrcChN)))&&(DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
</span>465    if ((DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){DstChN--;}
466    Trunc(DstChN);
467  }
468  void TChA::Swap(const int& ChN1, const int& ChN2){
469    char Ch=GetCh(ChN1);
470    PutCh(ChN1, GetCh(ChN2));
471    PutCh(ChN2, Ch);
472  }
473  void TChA::Swap(TChA& ChA) {
474    ::Swap(MxBfL, ChA.MxBfL);
475    ::Swap(BfL, ChA.BfL);
476    ::Swap(Bf, ChA.Bf);
477  }
478  int TChA::GetPrimHashCd() const {
479    return TStrHashF_DJB::GetPrimHashCd(CStr());
480  }
481  int TChA::GetSecHashCd() const {
482    return TStrHashF_DJB::GetSecHashCd(CStr());
483  }
484  void TChA::LoadTxt(const PSIn& SIn, TChA& ChA){
485    delete[] ChA.Bf;
486    ChA.Bf=new char[(ChA.MxBfL=ChA.BfL=SIn->Len())+1];
487    SIn->GetBf(ChA.CStr(), SIn->Len()); ChA.Bf[ChA.BfL]=0;
488  }
489  void TChA::SaveTxt(const PSOut& SOut) const {
490    SOut->SaveBf(CStr(), Len());
491  }
492  TChAIn::TChAIn(const TChA& ChA, const int& _BfC):
493    TSBase("Input-Char-Array"), TSIn("Input-Char-Array"), Bf(ChA.CStr()), BfC(_BfC), BfL(ChA.Len()){}
494  int TChAIn::GetBf(const void* LBf, const TSize& LBfL){
495    Assert(TSize(BfC+LBfL)<=TSize(BfL));
496    int LBfS=0;
497    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
498      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
499    return LBfS;
500  }
501  bool TChAIn::GetNextLnBf(TChA& LnChA){
502    FailR(TStr::Fmt("TChAIn::GetNextLnBf: not implemented").CStr());
503    return false;
504  }
505  bool TRStr::IsUc() const {
506    int StrLen=Len();
507    for (int ChN=0; ChN<StrLen; ChN++){
508      if (('a'<=Bf[ChN])&&(Bf[ChN]<='z')){return false;}}
509    return true;
510  }
511  void TRStr::ToUc(){
512    int StrLen=Len();
513    for (int ChN=0; ChN<StrLen; ChN++){
514      Bf[ChN]=(char)toupper(Bf[ChN]);}}
515  bool TRStr::IsLc() const {
516    int StrLen=Len();
517    for (int ChN=0; ChN<StrLen; ChN++){
518      if (('A'<=Bf[ChN])&&(Bf[ChN]<='Z')){return false;}}
519    return true;
520  }
521  void TRStr::ToLc(){
522    int StrLen=Len();
523    for (int ChN=0; ChN<StrLen; ChN++){
524      Bf[ChN]=(char)tolower(Bf[ChN]);}
525  }
526  void TRStr::ToCap(){
527    int StrLen=Len();
528    if (StrLen>0){
529      Bf[0]=(char)toupper(Bf[0]);}
530    for (int ChN=1; ChN<StrLen; ChN++){
531      Bf[ChN]=(char)tolower(Bf[ChN]);}
532  }
533  void TRStr::ConvUsFromYuAscii(){
534    int StrLen=Len();
535    for (int ChN=0; ChN<StrLen; ChN++){
536      Bf[ChN]=TCh::GetUsFromYuAscii(Bf[ChN]);}
537  }
538  int TRStr::CmpI(const char* p, const char* r){
539    if (!p){return r ? (*r ? -1 : 0) : 0;}
540    if (!r){return (*p ? 1 : 0);}
541    while (*p && *r){
542      int i=int(toupper(*p++))-int(toupper(*r++));
543      if (i!=0){return i;}
544    }
545    return int(toupper(*p++))-int(toupper(*r++));
546  }
547  int TRStr::GetPrimHashCd() const {
548    return TStrHashF_DJB::GetPrimHashCd(Bf);
549  }
550  int TRStr::GetSecHashCd() const {
551    return TStrHashF_DJB::GetSecHashCd(Bf);
552  }
553  TRStr* TStr::GetRStr(const char* CStr){
554    int CStrLen;
555    if (CStr==NULL){CStrLen=0;} else {CStrLen=int(strlen(CStr));}
556    if (CStrLen==0){return TRStr::GetNullRStr();}
557    else {return new TRStr(CStr);}
558  }
559  void TStr::Optimize(){
560    char* CStr=RStr->CStr(); int CStrLen=int(strlen(CStr));
561    TRStr* NewRStr;
562    if (CStrLen==0){NewRStr=TRStr::GetNullRStr();}
563    else {NewRStr=RStr;}
564    NewRStr->MkRef(); RStr->UnRef(); RStr=NewRStr;
565  }
566  void TStr::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
567    XLoadHd(Nm);
568    TStr TokStr=XmlTok->GetTokStr(false);
569    operator=(TokStr);
570  }
571  void TStr::SaveXml(TSOut& SOut, const TStr& Nm) const {
572    TStr XmlStr=TXmlLx::GetXmlStrFromPlainStr(*this);
573    if (XmlStr.Empty()){XSaveBETag(Nm);}
574    else {XSaveHd(Nm); SOut.PutStr(XmlStr);}
575  }
576  TStr& TStr::ToUc(){
577    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToUc();
578    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
579    Optimize(); return *this;
580  }
581  TStr& TStr::ToLc(){
582    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToLc();
583    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
584    Optimize(); return *this;
585  }
586  TStr& TStr::ToCap(){
587    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ToCap();
588    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
589    Optimize(); return *this;
590  }
591  TStr& TStr::ToTrunc(){
592    int ThisLen=Len(); char* ThisBf=CStr();
593    int BChN=0; int EChN=ThisLen-1;
594    while ((BChN<ThisLen)&&TCh::IsWs(ThisBf[BChN])){BChN++;}
595    while ((EChN>=0)&&TCh::IsWs(ThisBf[EChN])){EChN--;}
596    *this=GetSubStr(BChN, EChN);
597    return *this;
598  }
599  TStr& TStr::ConvUsFromYuAscii(){
600    TRStr* NewRStr=new TRStr(RStr->CStr()); NewRStr->ConvUsFromYuAscii();
601    RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
602    Optimize(); return *this;
603  }
604  TStr& TStr::ToHex(){
605    TChA ChA;
606    int StrLen=Len();
607    for (int ChN=0; ChN<StrLen; ChN++){
608      uchar Ch=uchar(RStr->Bf[ChN]);
609      char MshCh=TCh::GetHexCh((Ch/16)%16);
610      char LshCh=TCh::GetHexCh(Ch%16);
611      ChA+=MshCh; ChA+=LshCh;
612    }
613    *this=ChA;
614    return *this;
615  }
616  TStr& TStr::FromHex(){
617    int StrLen=Len(); IAssert(StrLen%2==0);
618    TChA ChA; int ChN=0;
619    while (ChN<StrLen){
620      char MshCh=RStr->Bf[ChN]; ChN++;
621      char LshCh=RStr->Bf[ChN]; ChN++;
622      uchar Ch=uchar(TCh::GetHex(MshCh)*16+TCh::GetHex(LshCh));
623      ChA+=Ch;
624    }
625    *this=ChA;
626    return *this;
627  }
628  TStr TStr::GetSubStr(const int& _BChN, const int& _EChN) const {
629    int StrLen=Len();
630    int BChN=TInt::GetMx(_BChN, 0);
631    int EChN=TInt::GetMn(_EChN, StrLen-1);
632    int Chs=EChN-BChN+1;
633    if (Chs<=0){return TStr();}
634    else if (Chs==StrLen){return *this;}
635    else {
636      char* Bf=new char[Chs+1]; strncpy(Bf, CStr()+BChN, Chs); Bf[Chs]=0;
637      TStr Str(Bf); delete[] Bf;
638      return Str;
639    }
640  }
641  void TStr::InsStr(const int& BChN, const TStr& Str){
642    int ThisLen=Len();
643    IAssert((0<=BChN)&&(BChN<=ThisLen));
644    TStr NewStr;
645    if (BChN==0){
646      NewStr=Str+*this;
647    } else
648    if (BChN==ThisLen){
649      NewStr=*this+Str;
650    } else {
651      NewStr=GetSubStr(0, BChN-1)+Str+GetSubStr(BChN, ThisLen-1);
652    }
653    *this=NewStr;
654  }
655  void TStr::DelChAll(const char& Ch){
656    TChA ChA(*this);
657    int ChN=ChA.SearchCh(Ch);
658    while (ChN!=-1){
659      ChA.Del(ChN);
660      ChN=ChA.SearchCh(Ch);
661    }
662    *this=ChA;
663  }
664  void TStr::DelSubStr(const int& _BChN, const int& _EChN){
665    int BChN=TInt::GetMx(_BChN, 0);
666    int EChN=TInt::GetMn(_EChN, Len()-1);
667    int Chs=Len()-(EChN-BChN+1);
668    if (Chs==0){Clr();}
669    else if (Chs<Len()){
670      char* Bf=new char[Chs+1]; strncpy(Bf, CStr(), BChN);
671      strncpy(Bf+BChN, CStr()+EChN+1, Len()-EChN-1); Bf[Chs]=0;
672      TStr Str(Bf); delete[] Bf;
673      *this=Str;
674    }
675  }
676  bool TStr::DelStr(const TStr& Str){
677    int ChN=SearchStr(Str);
678    if (ChN==-1){
679      return false;
680    } else {
681      DelSubStr(ChN, ChN+Str.Len()-1);
682      return true;
683    }
684  }
685  TStr TStr::LeftOf(const char& SplitCh) const {
686    int ThisLen=Len(); const char* ThisBf=CStr();
687    int ChN=0;
688    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
689    return (ChN==ThisLen) ? "" : GetSubStr(0, ChN-1);
690  }
691  TStr TStr::LeftOfLast(const char& SplitCh) const {
692    const char* ThisBf=CStr();
693    int ChN=Len()-1;
694    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
695    return (ChN==-1) ? "" : GetSubStr(0, ChN-1);
696  }
697  TStr TStr::RightOf(const char& SplitCh) const {
698    int ThisLen=Len(); const char* ThisBf=CStr();
699    int ChN=0;
700    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
701    return (ChN==ThisLen) ? "" : GetSubStr(ChN+1, ThisLen-1);
702  }
703  TStr TStr::RightOfLast(const char& SplitCh) const {
704    int ThisLen=Len(); const char* ThisBf=CStr();
705    int ChN=Len()-1;
706    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
707    return (ChN==-1) ? "" : GetSubStr(ChN+1, ThisLen-1);
708  }
709  void TStr::SplitOnCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
710    int ThisLen=Len(); const char* ThisBf=CStr();
711    int ChN=0;
712    while ((ChN<ThisLen)&&(ThisBf[ChN]!=SplitCh)){ChN++;}
713    if (ChN==ThisLen){
714      LStr=GetSubStr(0, ThisLen-1); RStr="";
715    } else {
716      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
717    }
718  }
719  void TStr::SplitOnLastCh(TStr& LStr, const char& SplitCh, TStr& RStr) const {
720    int ThisLen=Len(); const char* ThisBf=CStr();
721    int ChN=Len()-1;
722    while ((ChN>=0)&&(ThisBf[ChN]!=SplitCh)){ChN--;}
723    if (ChN==-1){
724      LStr=""; RStr=*this;
725    } else
726    if (ChN==0){
727      LStr=""; RStr=GetSubStr(1, ThisLen-1);
728    } else {
729      LStr=GetSubStr(0, ChN-1); RStr=GetSubStr(ChN+1, ThisLen-1);
730    }
731  }
732  void TStr::SplitOnAllCh(
733   const char& SplitCh, TStrV& StrV, const bool& SkipEmpty) const {
734    StrV.Clr();
735    char* Bf=new char[Len()+1];
736    strcpy(Bf, CStr());
737    char* CurStrBf=Bf;
738    forever{
739      char* BfC=CurStrBf;
740      while ((*BfC!=0)&&(*BfC!=SplitCh)){BfC++;}
741      bool IsEnd=(*BfC=='\0');
742      *BfC=0;
743      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
744      if (IsEnd){break;}
745      CurStrBf=BfC+1;
746    }
747    delete[] Bf;
748  }
749  void TStr::SplitOnAllAnyCh(
750   const TStr& SplitChStr, TStrV& StrV, const bool& SkipEmpty) const {
751    StrV.Clr();
752    char* Bf=new char[Len()+1];
753    strcpy(Bf, CStr());
754    char* CurStrBf=Bf; 
755    const char* SplitChBf=SplitChStr.CStr();
756    forever{
757      char* BfC=CurStrBf; 
758      while (*BfC!=0){
759        const char* SplitChBfC=SplitChBf; 
760        while ((*SplitChBfC!=0)&&(*SplitChBfC!=*BfC)){SplitChBfC++;}
761        if (*SplitChBfC!=0){break;} 
762        BfC++;
763      }
764      bool IsEnd=(*BfC==0);
765      *BfC=0;
766      if ((BfC>CurStrBf)||(!SkipEmpty)){StrV.Add(TStr(CurStrBf));}
767      if (IsEnd){break;}
768      CurStrBf=BfC+1;
769    }
770    delete[] Bf;
771  }
772  void TStr::SplitOnWs(TStrV& StrV) const {
773    StrV.Clr();
774    char* Bf=new char[Len()+1];
775    strcpy(Bf, CStr());
776    char* StrBf=Bf;
777    forever{
778      while ((*StrBf!=0)&&(TCh::IsWs(*StrBf))){StrBf++;}
779      char* BfC=StrBf;
780      while ((*BfC!=0)&&(!TCh::IsWs(*BfC))){BfC++;}
781      bool IsEnd=(*BfC=='\0');
782      *BfC=0;
783      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
784      if (IsEnd){break;}
785      StrBf=BfC+1;
786    }
787    delete[] Bf;
788  }
789  void TStr::SplitOnNonAlNum(TStrV& StrV) const {
790    StrV.Clr();
791    char* Bf=new char[Len()+1];
792    strcpy(Bf, CStr());
793    char* StrBf=Bf;
794    forever{
795      while ((*StrBf!=0)&&(!TCh::IsAlNum(*StrBf))){StrBf++;}
796      char* BfC=StrBf;
797      while ((*BfC!=0)&&(TCh::IsAlNum(*BfC))){BfC++;}
798      bool IsEnd=(*BfC=='\0');
799      *BfC=0;
800      if (BfC>StrBf){StrV.Add(TStr(StrBf));}
801      if (IsEnd){break;}
802      StrBf=BfC+1;
803    }
804    delete[] Bf;
805  }
806  void TStr::SplitOnStr(const TStr& SplitStr, TStrV& StrV) const {
807    StrV.Clr();
808    int SplitStrLen=SplitStr.Len();
809    int PrevChN=0; int ChN=0;
810    while ((ChN=SearchStr(SplitStr, ChN))!=-1){
811      TStr SubStr=GetSubStr(PrevChN, ChN-1);
812      StrV.Add(SubStr);
813      PrevChN=ChN=ChN+SplitStrLen;
814    }
815    TStr LastSubStr=GetSubStr(PrevChN, Len()-1);
816    StrV.Add(LastSubStr);
817  }
818  void TStr::SplitOnStr(TStr& LeftStr, const TStr& MidStr, TStr& RightStr) const {
819    const int ChN=SearchStr(MidStr);
820    if (ChN==-1){
821      LeftStr=*this; RightStr=GetNullStr();
822    } else {
823      LeftStr=GetSubStr(0, ChN-1);
824      RightStr=GetSubStr(ChN+MidStr.Len(), Len()-1);
825    }
826  }
827  int TStr::CountCh(const char& Ch, const int& BChN) const {
828    const int ThisLen=Len();
829    const char* ThisBf=CStr();
830    int Chs=0;
831    for (int ChN=TInt::GetMx(BChN, 0); ChN<ThisLen; ChN++){
832      if (ThisBf[ChN]==Ch){Chs++;}
833    }
834    return Chs;
835  }
836  int TStr::SearchCh(const char& Ch, const int& BChN) const {
837    int ThisLen=Len(); const char* ThisBf=CStr();
838    int ChN=TInt::GetMx(BChN, 0);
839    while (ChN<ThisLen){
840      if (ThisBf[ChN]==Ch){return ChN;}
841      ChN++;
842    }
843    return -1;
844  }
845  int TStr::SearchChBack(const char& Ch, int BChN) const {
846    const int StrLen=Len();
847    if (BChN==-1||BChN>=StrLen){BChN=StrLen-1;}
848    const char* ThisBf=CStr();
849    const char* Pt=ThisBf + BChN;
850    while (Pt>=ThisBf) {
851      if (*Pt==Ch){return (int)(Pt-ThisBf);}
852      Pt--;
853    }
854    return -1;
855  }
856  int TStr::SearchStr(const TStr& Str, const int& BChN) const {
857    int NrBChN=TInt::GetMx(BChN, 0);
858    const char* StrPt=strstr((const char*)CStr()+NrBChN, Str.CStr());
859    if (StrPt==NULL){return -1;}
860    else {return int(StrPt-CStr());}
861  }
862  bool TStr::IsPrefix(const char *Str) const {
863  	size_t len = strlen(Str);
864  	size_t thisLen = Len();
865  	if (len > thisLen) {
866  		return false;
867  	} else {
868          size_t minLen = MIN(len, thisLen);
869  		int cmp = strncmp(Str, RStr->Bf, minLen);
870  		return cmp == 0;
871  	}
872  }
873  bool TStr::IsSuffix(const char *Str) const {
874  	size_t len = strlen(Str);
875  	size_t thisLen = Len();
876  	if (len > thisLen) {
877  		return false;
878  	} else {
879  		const char *ending = RStr->Bf + thisLen - len;
880  		int cmp = strncmp(Str, ending, len);
881  		return cmp == 0;
882  	}
883  }
884  int TStr::ChangeCh(const char& SrcCh, const char& DstCh, const int& BChN){
885    int ChN=SearchCh(SrcCh, BChN);
886    if (ChN!=-1){PutCh(ChN, DstCh);}
887    return ChN;
888  }
889  int TStr::ChangeChAll(const char& SrcCh, const char& DstCh){
890    int FirstChN=SearchCh(SrcCh);
891    if (FirstChN==-1){
892      return 0;
893    } else {
894      TRStr* NewRStr=new TRStr(RStr->CStr());
895      RStr->UnRef(); RStr=NewRStr; RStr->MkRef();
896      char* ThisBf=CStr(); int StrLen=Len(); int Changes=0;
897      for (int ChN=FirstChN; ChN<StrLen; ChN++){
898        if (ThisBf[ChN]==SrcCh){ThisBf[ChN]=DstCh; Changes++;}
899      }
900      Optimize();
901      return Changes;
902    }
903  }
904  int TStr::ChangeStr(const TStr& SrcStr, const TStr& DstStr, const int& BChN){
905    int ChN=SearchStr(SrcStr, BChN);
906    if (ChN==-1){
907      return -1;
908    } else {
909      DelSubStr(ChN, ChN+SrcStr.Len()-1);
910      InsStr(ChN, DstStr);
911      return ChN;
912    }
913  }
914  int TStr::ChangeStrAll(const TStr& SrcStr, const TStr& DstStr, const bool& FromStartP){
915    const int DstStrLen=DstStr.Len();
916    int Changes=0-1; int BChN=0-DstStrLen;
917    do {
918      Changes++;
919      if (FromStartP){BChN=0-DstStrLen;}
920      BChN+=DstStrLen;
921      BChN=ChangeStr(SrcStr, DstStr, BChN);
922    } while (BChN!=-1);
923    return Changes;
924  }
925  bool TStr::IsBool(bool& Val) const {
926    if (operator==("T")){Val=true; return true;}
927    else if (operator==("F")){Val=false; return true;}
928    else {return false;}
929  }
930  bool TStr::IsInt(
931   const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
932    int _Val=0;
933    bool Minus=false;
934    TChRet Ch(TStrIn::New(*this));
935    while (TCh::IsWs(Ch.GetCh())){}
936    if (Ch()=='+'){Minus=false; Ch.GetCh();}
937    if (Ch()=='-'){Minus=true; Ch.GetCh();}
938    if (!TCh::IsNum(Ch())){return false;}
939    _Val=TCh::GetNum(Ch());
940    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
941    if (Minus){_Val=-_Val;}
942    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
943    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
944  }
945  bool TStr::IsUInt(
946   const bool& Check, const uint& MnVal, const uint& MxVal, uint& Val) const {
947    uint _Val=0;
948    TChRet Ch(TStrIn::New(*this));
949    while (TCh::IsWs(Ch.GetCh())){}
950    if (Ch()=='+'){Ch.GetCh();}
951    if (!TCh::IsNum(Ch())){return false;}
952    _Val=TCh::GetNum(Ch());
953    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
954    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
955    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
956  }
957  bool TStr::IsHexInt( const bool& Check, const int& MnVal, const int& MxVal, int& Val) const {
958    int _Val=0;
959    bool Minus=false;
960    TChRet Ch(TStrIn::New(*this));
961    while (TCh::IsWs(Ch.GetCh())){}
962    if (Ch()=='+'){Minus=false; Ch.GetCh();}
963    if (Ch()=='-'){Minus=true; Ch.GetCh();}
964    if (Ch()=='0'){
965      Ch.GetCh();
966      if (tolower(Ch())=='x' ){
967        Ch.GetCh(); if (Ch.Eof()){return false;}
968      }
969    }
970    if (!Ch.Eof() && !TCh::IsHex(Ch())){return false;}
971    if (!Ch.Eof()) _Val = TCh::GetHex(Ch());
972    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
973    if (Minus){_Val=-_Val;}
974    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
975    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
976  }
977  bool TStr::IsInt64(
978   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
979    int64 _Val=0;
980    bool Minus=false;
981    TChRet Ch(TStrIn::New(*this));
982    while (TCh::IsWs(Ch.GetCh())){}
983    if (Ch()=='+'){Minus=false; Ch.GetCh();}
984    if (Ch()=='-'){Minus=true; Ch.GetCh();}
985    if (!TCh::IsNum(Ch())){return false;}
986    _Val=TCh::GetNum(Ch());
987    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
988    if (Minus){_Val=-_Val;}
989    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
990    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
991  }
992  bool TStr::IsUInt64(
993   const bool& Check, const uint64& MnVal, const uint64& MxVal, uint64& Val) const {
994    uint64 _Val=0;
995    TChRet Ch(TStrIn::New(*this));
996    while (TCh::IsWs(Ch.GetCh())){}
997    if (Ch()=='+'){Ch.GetCh();}
998    if (!TCh::IsNum(Ch())){return false;}
999    _Val=TCh::GetNum(Ch());
1000    while (TCh::IsNum(Ch.GetCh())){_Val=10*_Val+TCh::GetNum(Ch());}
1001    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1002    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1003  }
1004  bool TStr::IsHexInt64(
1005   const bool& Check, const int64& MnVal, const int64& MxVal, int64& Val) const {
1006    int64 _Val=0;
1007    bool Minus=false;
1008    TChRet Ch(TStrIn::New(*this));
1009    while (TCh::IsWs(Ch.GetCh())){}
1010    if (Ch()=='+'){Minus=false; Ch.GetCh();}
1011    if (Ch()=='-'){Minus=true; Ch.GetCh();}
1012    if (Ch()=='0'){
1013      Ch.GetCh();
1014      if (tolower(Ch())=='x' ){
1015        Ch.GetCh(); if (Ch.Eof()){return false;}
1016      }
1017    }
1018    if (!Ch.Eof()) _Val=TCh::GetHex(Ch());
1019    while (TCh::IsHex(Ch.GetCh())){_Val=16*_Val+TCh::GetHex(Ch());}
1020    if (Minus){_Val=-_Val;}
1021    if (Check&&((_Val<MnVal)||(_Val>MxVal))){return false;}
1022    if (Ch.Eof()){Val=_Val; return true;} else {return false;}
1023  }
1024  bool TStr::IsFlt(const bool& Check, const double& MnVal, const double& MxVal,
1025   double& Val, const char& DecDelimCh) const {
1026    TChRet Ch(TStrIn::New(*this));
1027    while (TCh::IsWs(Ch.GetCh())){}
1028    if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1029    if (!TCh::IsNum(Ch())&&Ch()!=DecDelimCh){return false;}
1030    while (TCh::IsNum(Ch.GetCh())){}
1031    if (Ch()==DecDelimCh){
1032      Ch.GetCh();
1033      while (TCh::IsNum(Ch.GetCh())){}
1034    }
1035    if ((Ch()=='e')||(Ch()=='E')){
1036      Ch.GetCh();
1037      if ((Ch()=='+')||(Ch()=='-')){Ch.GetCh();}
1038      if (!TCh::IsNum(Ch())){return false;}
1039      while (TCh::IsNum(Ch.GetCh())){}
1040    }
1041    if (!Ch.Eof()){return false;}
1042    double _Val=atof(CStr());
1043    if (Check&&((_Val<MnVal)||(_Val>MxVal))){
1044      return false;
1045    } else {
1046      Val=_Val; return true;
1047    }
1048  }
1049  bool TStr::IsWord(const bool& WsPrefixP, const bool& FirstUcAllowedP) const {
1050    TChRet Ch(TStrIn::New(*this));
1051    if (WsPrefixP){while (TCh::IsWs(Ch.GetCh())){}}
1052    else {Ch.GetCh();}
1053    if (!TCh::IsAlpha(Ch())){return false;}
1054    else if (!FirstUcAllowedP&&(TCh::IsUc(Ch()))){return false;}
1055    while (TCh::IsAlNum(Ch.GetCh())){}
1056    if (!Ch.Eof()){return false;}
1057    return true;
1058  }
1059  bool TStr::IsWs() const {
1060    TChRet Ch(TStrIn::New(*this));
1061    while (TCh::IsWs(Ch.GetCh())){}
1062    return Ch.Eof();
1063  }
1064  bool TStr::IsWcMatch(
1065   const int& StrBChN, const TStr& WcStr, const int& WcStrBChN, TStrV& StarStrV,
1066   const char& StarCh, const char& QuestCh) const {
1067    int StrLen=Len(); int WcStrLen=WcStr.Len();
1068    int StrChN=StrBChN; int WcStrChN=WcStrBChN;
1069    while ((StrChN<StrLen)&&(WcStrChN<WcStrLen)){
1070      if ((WcStr[WcStrChN]==QuestCh)||(GetCh(StrChN)==WcStr[WcStrChN])){
1071        StrChN++; WcStrChN++;
1072      } else
1073      if (WcStr[WcStrChN]==StarCh){
1074        TChA StarChA; 
1075        for (int AfterStrChN=StrChN; AfterStrChN<=StrLen; AfterStrChN++){
1076          if (AfterStrChN>StrChN){
1077            StarChA+=GetCh(AfterStrChN-1);}
1078          if (IsWcMatch(AfterStrChN, WcStr, WcStrChN+1, StarStrV, StarCh, QuestCh)){
1079            StarStrV.Add(StarChA); return true;
1080          }
1081        }
1082        return false;
1083      } else {
1084        return false;
1085      }
1086    }
1087    if (StrChN==StrLen){
1088      for (int AfterWcStrChN=WcStrChN; AfterWcStrChN<WcStrLen; AfterWcStrChN++){
1089        if (WcStr[AfterWcStrChN]!=StarCh){return false;}}
1090      return true;
1091    } else {
1092      return false;
1093    }
1094  }
1095  bool TStr::IsWcMatch(
1096   const TStr& WcStr, TStrV& StarStrV, const char& StarCh, const char& QuestCh) const {
1097    bool WcMatch=IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1098    if (WcMatch){
1099      StarStrV.Reverse();
1100      return true;
1101    } else {
1102      return false;
1103    }
1104  }
1105  bool TStr::IsWcMatch(
1106   const TStr& WcStr, const char& StarCh, const char& QuestCh) const {
1107    TStrV StarStrV;
1108    return IsWcMatch(0, WcStr, 0, StarStrV, StarCh, QuestCh);
1109  }
1110  bool TStr::IsWcMatch(const TStr& WcStr, const int& StarStrN, TStr& StarStr) const {
1111    TStrV StarStrV;
1112    if (IsWcMatch(WcStr, StarStrV)){
1113      if (StarStrV.Len()>StarStrN){
1114        StarStr=StarStrV[StarStrV.Len()-StarStrN-1];
1115      } else {
1116        StarStr="";
1117      }
1118      return true;
1119    } else {
1120      return false;
1121    }
1122  }
1123  bool TStr::IsWcMatch(const TStr& WcStr) const {
1124    TStrV StarStrV;
1125    return IsWcMatch(0, WcStr, 0, StarStrV);
1126  }
1127  TStr TStr::GetWcMatch(const TStr& WcStr, const int& StarStrN) const {
1128    TStrV StarStrV;
1129    if (IsWcMatch(WcStr, StarStrV)&&(StarStrV.Len()>=StarStrN)){
1130      IAssert(StarStrN>=0);
1131      return StarStrV[StarStrV.Len()-StarStrN-1];
1132    } else {
1133      return "";
1134    }
1135  }
1136  TStr TStr::GetFPath() const {
1137    int ThisLen=Len(); const char* ThisBf=CStr();
1138    int ChN=ThisLen-1;
1139    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1140    return GetSubStr(0, ChN);
1141  }
1142  TStr TStr::GetFBase() const {
1143    int ThisLen=Len(); const char* ThisBf=CStr();
1144    int ChN=ThisLen-1;
1145    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1146    return GetSubStr(ChN+1, ThisLen);
1147  }
1148  TStr TStr::GetFMid() const {
1149    int ThisLen=Len(); const char* ThisBf=CStr();
1150    int ChN=ThisLen-1;
1151    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&(ThisBf[ChN]!='.')){
1152      ChN--;}
1153    if (ChN<0){
1154      return *this;
1155    } else {
1156      if (ThisBf[ChN]=='.'){
1157        int EChN= --ChN;
1158        while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')){ChN--;}
1159        return GetSubStr(ChN+1, EChN);
1160      } else {
1161        return GetSubStr(ChN+1, ThisLen);
1162      }
1163    }
1164  }
1165  TStr TStr::GetFExt() const {
1166    int ThisLen=Len(); const char* ThisBf=CStr();
1167    int ChN=ThisLen-1;
1168    while ((ChN>=0)&&(ThisBf[ChN]!='/')&&(ThisBf[ChN]!='\\')&&
1169     (ThisBf[ChN]!='.')){ChN--;}
1170    if ((ChN>=0)&&(ThisBf[ChN]=='.')){return GetSubStr(ChN, Len());}
1171    else {return TStr();}
1172  }
1173  TStr TStr::GetNrFPath(const TStr& FPath){
1174    TChA NrFPath(FPath.Len()+4); NrFPath+=FPath;
1175    NrFPath.ChangeCh('\\', '/');
1176    if (NrFPath.Empty()){NrFPath="./";}
1177    if ((NrFPath.Len()>=2)&&isalpha(NrFPath[0])&&(NrFPath[1]==':')){
1178      if (NrFPath.Len()==2){NrFPath+="./";}
1179      if ((NrFPath[2]!='.')&&(NrFPath[2]!='/')){NrFPath.Ins(2, "./");}
1180      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1181    } else {
1182      if ((NrFPath[0]!='.')&&(NrFPath[0]!='/')){NrFPath.Ins(0, "./");}
1183      if (NrFPath[NrFPath.Len()-1]!='/'){NrFPath+="/";}
1184    }
1185    return NrFPath;
1186  }
1187  TStr TStr::GetNrFMid(const TStr& FMid){
1188    TChA NrFMid;
1189    int FMidLen=FMid.Len();
1190    for (int ChN=0; ChN<FMidLen; ChN++){
1191      char Ch=FMid[ChN];
1192      if (TCh::IsAlNum(Ch)){NrFMid+=Ch;} else {NrFMid+='_';}
1193    }
1194    return NrFMid;
1195  }
1196  TStr TStr::GetNrFExt(const TStr& FExt){
1197    if (FExt.Empty()||(FExt[0]=='.')){return FExt;}
1198    else {return TStr(".")+FExt;}
1199  }
1200  TStr TStr::GetNrNumFExt(const int& FExtN){
1201    TStr FExtNStr=TInt::GetStr(FExtN);
1202    while (FExtNStr.Len()<3){
1203      FExtNStr=TStr("0")+FExtNStr;}
1204    return FExtNStr;
1205  }
1206  TStr TStr::GetNrFNm(const TStr& FNm){
1207    return GetNrFPath(FNm.GetFPath())+FNm.GetFMid()+GetNrFExt(FNm.GetFExt());
1208  }
1209  TStr TStr::GetNrAbsFPath(const TStr& FPath, const TStr& BaseFPath){
1210    TStr NrBaseFPath;
1211    if (BaseFPath.Empty()){
1212      NrBaseFPath=GetNrFPath(TDir::GetCurDir());
1213    } else {
1214      NrBaseFPath=GetNrFPath(BaseFPath);
1215    }
1216    IAssert(IsAbsFPath(NrBaseFPath));
1217    TStr NrFPath=GetNrFPath(FPath);
1218    TStr NrAbsFPath;
1219    if (IsAbsFPath(NrFPath)){
1220      NrAbsFPath=NrFPath;
1221    } else {
1222      NrAbsFPath=GetNrFPath(NrBaseFPath+NrFPath);
1223    }
1224    NrAbsFPath.ChangeStrAll("/./", "/");
1225    NrAbsFPath.ChangeStrAll("\\.\\", "\\");
1226    return NrAbsFPath;
1227  }
1228  bool TStr::IsAbsFPath(const TStr& FPath){
1229    if ((FPath.Len()>=3)&&isalpha(FPath[0])&&(FPath[1]==':')&&
1230     ((FPath[2]=='/')||(FPath[2]=='\\'))){
1231      return true;
1232    }
1233    return false;
1234  }
1235  TStr TStr::PutFExt(const TStr& FNm, const TStr& FExt){
1236    return FNm.GetFPath()+FNm.GetFMid()+FExt;
1237  }
1238  TStr TStr::PutFExtIfEmpty(const TStr& FNm, const TStr& FExt){
1239    if (FNm.GetFExt().Empty()){
1240      return FNm.GetFPath()+FNm.GetFMid()+FExt;
1241    } else {
1242      return FNm;
1243    }
1244  }
1245  TStr TStr::PutFBase(const TStr& FNm, const TStr& FBase){
1246    return FNm.GetFPath()+FBase;
1247  }
1248  TStr TStr::PutFBaseIfEmpty(const TStr& FNm, const TStr& FBase){
1249    if (FNm.GetFBase().Empty()){
1250      return FNm.GetFPath()+FBase;
1251    } else {
1252      return FNm;
1253    }
1254  }
1255  TStr TStr::AddToFMid(const TStr& FNm, const TStr& ExtFMid){
1256    return FNm.GetFPath()+FNm.GetFMid()+ExtFMid+FNm.GetFExt();
1257  }
1258  TStr TStr::GetNumFNm(const TStr& FNm, const int& Num){
1259    return FNm.GetFPath()+FNm.GetFMid()+TInt::GetStr(Num, "%03d")+FNm.GetFExt();
1260  }
1261  TStr TStr::GetFNmStr(const TStr& Str, const bool& AlNumOnlyP){
1262    TChA FNm=Str;
1263    for (int ChN=0; ChN<FNm.Len(); ChN++){
1264      uchar Ch=FNm[ChN];
1265      if (AlNumOnlyP){
1266        if (
1267         (('0'<=Ch)&&(Ch<='9'))||
1268         (('A'<=Ch)&&(Ch<='Z'))||
1269         (('a'<=Ch)&&(Ch<='z'))||
1270         (Ch=='-')||(Ch=='_')){}
1271        else {Ch='_';}
1272      } else {
1273        if ((Ch<=' ')||(Ch=='/')||(Ch=='\\')||(Ch==':')||(Ch=='.')){
1274          Ch='_';}
1275      }
1276      FNm.PutCh(ChN, Ch);
1277    }
1278    return FNm;
1279  }
1280  TStr& TStr::GetChStr(const char& Ch){
1281    static char MnCh=char(CHAR_MIN);
1282    static char MxCh=char(CHAR_MAX);
1283    static int Chs=int(MxCh)-int(MnCh)+1;
1284    static TStrV ChStrV;
1285    if (ChStrV.Empty()){
1286      ChStrV.Gen(Chs);
1287      for (int ChN=0; ChN<Chs; ChN++){
1288        ChStrV[ChN]=TStr(char(MnCh+ChN), true);}
1289    }
1290    return ChStrV[int(Ch-MnCh)];
1291  }
1292  TStr& TStr::GetDChStr(const char& Ch1, const char& Ch2){
1293    Fail; 
1294    static TStrVV DChStrVV;
1295    if (DChStrVV.Empty()){
1296      DChStrVV.Gen(TCh::Vals, TCh::Vals);
1297      for (int Ch1N=0; Ch1N<TCh::Vals; Ch1N++){
1298        for (int Ch2N=0; Ch2N<TCh::Vals; Ch2N++){
1299          DChStrVV.At(Ch1N, Ch2N)=
1300           TStr(char(TCh::Mn+Ch1N), char(TCh::Mn+Ch2N), true);
1301        }
1302      }
1303    }
1304    return DChStrVV.At(int(Ch1-TCh::Mn), int(Ch2-TCh::Mn));
1305  }
1306  TStr TStr::GetStr(const TStr& Str, const char* FmtStr){
1307    if (FmtStr==NULL){
1308      return Str;
1309    } else {
1310      char Bf[1000];
1311      sprintf(Bf, FmtStr, Str.CStr());
1312      return TStr(Bf);
1313    }
1314  }
1315  TStr TStr::GetStr(const TStrV& StrV, const TStr& DelimiterStr){
1316    if (StrV.Empty()){return TStr();}
1317    TChA ResStr=StrV[0];
1318    for (int StrN=1; StrN<StrV.Len(); StrN++){
1319      ResStr+=DelimiterStr;
1320      ResStr+=StrV[StrN];
1321    }
1322    return ResStr;
1323  }
1324  TStr TStr::Fmt(const char *FmtStr, ...){
1325    char Bf[10*1024];
1326    va_list valist;
1327    va_start(valist, FmtStr);
1328    const int RetVal=vsnprintf(Bf, 10*1024-2, FmtStr, valist);
1329    va_end(valist);
1330    return RetVal!=-1 ? TStr(Bf) : TStr::GetNullStr();
1331  }
1332  TStr TStr::GetSpaceStr(const int& Spaces){
1333    static TStrV SpaceStrV;
1334    if (SpaceStrV.Len()==0){
1335      for (int SpaceStrN=0; SpaceStrN<10; SpaceStrN++){
1336        TChA SpaceChA;
1337        for (int ChN=0; ChN<SpaceStrN; ChN++){SpaceChA+=' ';}
1338        SpaceStrV.Add(SpaceChA);
1339      }
1340    }
1341    if ((0<=Spaces)&&(Spaces<SpaceStrV.Len())){
1342      return SpaceStrV[Spaces];
1343    } else {
1344      TChA SpaceChA;
1345      for (int ChN=0; ChN<Spaces; ChN++){SpaceChA+=' ';}
1346      return SpaceChA;
1347    }
1348  }
1349  TStr TStr::GetNullStr(){
1350    static TStr NullStr="";
1351    return NullStr;
1352  }
1353  TStr operator+(const TStr& LStr, const TStr& RStr){
1354    if (LStr.Empty()){return RStr;}
1355    else if (RStr.Empty()){return LStr;}
1356    else {return TStr(LStr)+=RStr;}
1357  }
1358  TStr operator+(const TStr& LStr, const char* RCStr){
1359    return TStr(LStr)+=RCStr;
1360  }
1361  TStrIn::TStrIn(const TStr& _Str):
1362    TSBase("Input-String"), TSIn("Input-String"), Str(_Str), Bf(Str.CStr()), BfC(0), BfL(Str.Len()){}
1363  int TStrIn::GetBf(const void* LBf, const TSize& LBfL){
1364    Assert(TSize(BfC+LBfL)<=TSize(BfL));
1365    int LBfS=0;
1366    for (TSize LBfC=0; LBfC<LBfL; LBfC++){
1367      LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
1368    return LBfS;
1369  }
1370  bool TStrIn::GetNextLnBf(TChA& LnChA){
1371    FailR(TStr::Fmt("TStrIn::GetNextLnBf: not implemented").CStr());
1372    return false;
1373  }
1374  void TStrPool::Resize(const uint& _MxBfL) {
1375    uint newSize = MxBfL;
1376    while (newSize < _MxBfL) {
1377      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1378      else if (newSize > 0) newSize *= 2;
1379      else newSize = TInt::GetMn(GrowBy, 1024);
1380      IAssertR(newSize >= MxBfL, TStr::Fmt("TStrPool::Resize: %u, %u [Size larger than 4Gb, which is not supported by TStrPool]", newSize, MxBfL).CStr());
1381    }
1382    if (newSize > MxBfL) {
1383      Bf = (char *) realloc(Bf, newSize);
1384      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1385      MxBfL = newSize;
1386    }
1387    IAssertR(MxBfL >= _MxBfL, TStr::Fmt("new size: %u, requested size: %u", MxBfL, _MxBfL).CStr());
1388  }
1389  TStrPool::TStrPool(const uint& MxBfLen, const uint& _GrowBy) : MxBfL(MxBfLen), BfL(0), GrowBy(_GrowBy), Bf(0) {
1390    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1391    AddStr(""); 
1392  }
1393  TStrPool::TStrPool(TSIn& SIn, bool LoadCompact) : MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1394    SIn.Load(MxBfL);  SIn.Load(BfL);  SIn.Load(GrowBy);
1395    if (LoadCompact) MxBfL = BfL;
1396    if (MxBfL > 0) { Bf = (char *) malloc(MxBfL); IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr()); }
1397    if (BfL > 0) SIn.LoadBf(Bf, BfL);
1398    SIn.LoadCs();
1399  }
1400  void TStrPool::Save(TSOut& SOut) const {
1401    SOut.Save(MxBfL);  SOut.Save(BfL);  SOut.Save(GrowBy);
1402    SOut.SaveBf(Bf, BfL);
1403    SOut.SaveCs();
1404  }
1405  TStrPool& TStrPool::operator = (const TStrPool& Pool) {
1406    if (this != &Pool) {
1407      GrowBy = Pool.GrowBy;  MxBfL = Pool.MxBfL;  BfL = Pool.BfL;
1408      if (Bf) free(Bf); else IAssertR(MxBfL == 0, TStr::Fmt("size: %u, expected size: 0", MxBfL).CStr());
1409      Bf = (char *) malloc(MxBfL);  IAssertR(Bf, TStr::Fmt("Can not resize buffer to %u bytes. [Program failed to allocate more memory. Solution: Get a bigger machine.]", MxBfL).CStr());  memcpy(Bf, Pool.Bf, BfL);
1410    }
1411    return *this;
1412  }
1413  uint TStrPool::AddStr(const char *Str, const uint& Len) {
1414    IAssertR(Len > 0, "String too short (length includes the null character)");  
1415    if (Len == 1 && BfL > 0) { return 0; } 
1416    Assert(Str);  Assert(Len > 0);
1417    if (BfL + Len > MxBfL) Resize(BfL + Len);
1418    memcpy(Bf + BfL, Str, Len);
1419    uint Pos = BfL;  BfL += Len;  return Pos;
1420  }
1421  int TStrPool::GetPrimHashCd(const char *CStr) {
1422    return TStrHashF_DJB::GetPrimHashCd(CStr);
1423  }
1424  int TStrPool::GetSecHashCd(const char *CStr) {
1425    return TStrHashF_DJB::GetSecHashCd(CStr);
1426  }
1427  void TStrPool64::Resize(const ::TSize& _MxBfL) {
1428    ::TSize newSize = MxBfL;
1429    while (newSize < _MxBfL) {
1430      if (newSize >= GrowBy && GrowBy > 0) newSize += GrowBy;
1431      else if (newSize > 0) newSize *= 2;
1432      else newSize = (GrowBy > ::TSize(1024)) ? ::TSize(1024) : GrowBy;
1433      IAssert(newSize >= MxBfL); 
1434    }
1435    if (newSize > MxBfL) {
1436      Bf = (char *) realloc(Bf, newSize);
1437      IAssertR(Bf, TStr::Fmt("old Bf size: %u, new size: %u", MxBfL, newSize).CStr());
1438      MxBfL = newSize;
1439    }
1440    IAssert(MxBfL >= _MxBfL);
1441  }
1442  TStrPool64::TStrPool64(::TSize _MxBfL, ::TSize _GrowBy):
1443      MxBfL(_MxBfL), BfL(0), GrowBy(_GrowBy), Bf(NULL) {
1444    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1445    AddStr("");
1446  }
1447  TStrPool64::TStrPool64(const TStrPool64& StrPool): 
1448    MxBfL(StrPool.MxBfL), BfL(StrPool.BfL), GrowBy(StrPool.GrowBy) {
1449    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1450    Bf = (char*)malloc(StrPool.MxBfL); IAssert(Bf != NULL); 
1451    memcpy(Bf, StrPool.Bf, BfL);
1452  }
1453  TStrPool64::TStrPool64(TSIn& SIn, bool LoadCompact): 
1454    MxBfL(0), BfL(0), GrowBy(0), Bf(0) {
1455    uint64 _GrowBy, _MxBfL, _BfL;
1456    SIn.Load(_GrowBy); SIn.Load(_MxBfL); SIn.Load(_BfL);
1457    GrowBy = (::TSize)_GrowBy; MxBfL = (::TSize)_MxBfL; BfL = (::TSize)_BfL;
1458    if (LoadCompact) { MxBfL = BfL; }
1459    if (MxBfL > 0) { Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); }
1460    for (::TSize BfN = 0; BfN < _BfL; BfN++) { Bf[BfN] = SIn.GetCh(); }
1461    SIn.LoadCs();
1462  }
1463  void TStrPool64::Save(TSOut& SOut) const {
1464    uint64 _GrowBy = GrowBy, _MxBfL = MxBfL, _BfL = BfL;
1465    SOut.Save(_GrowBy);  SOut.Save(_MxBfL);  SOut.Save(_BfL);
1466    for (::TSize BfN = 0; BfN < _BfL; BfN++) { SOut.PutCh(Bf[BfN]); }
1467    SOut.SaveCs();
1468  }
1469  TStrPool64& TStrPool64::operator=(const TStrPool64& StrPool) {
1470    if (this != &StrPool) {
1471    GrowBy = StrPool.GrowBy;  MxBfL = StrPool.MxBfL;  BfL = StrPool.BfL;
1472    if (Bf != NULL) { free(Bf); } else { IAssert(MxBfL == 0); }
1473    Bf = (char*)malloc(MxBfL); IAssert(Bf != NULL); 
1474    memcpy(Bf, StrPool.Bf, BfL);
1475    }
1476    return *this;
1477  }
1478  void TStrPool64::Clr(bool DoDel) { 
1479    BfL = 0; 
1480    if (DoDel && (Bf!=NULL)) { 
1481      free(Bf); 
1482      Bf = NULL; MxBfL = 0; 
1483    } 
1484  }
1485  uint64 TStrPool64::AddStr(const TStr& Str) {
1486    const int Len = Str.Len() + 1;
1487    if (BfL + Len > MxBfL) { Resize(BfL + Len); }
1488    memcpy(Bf + BfL, Str.CStr(), Len);
1489    ::TSize Offset = BfL;  BfL += Len;
1490    return uint64(Offset);
1491  }
1492  TStr TStrPool64::GetStr(const uint64& StrId) const {
1493    ::TSize Offset = (::TSize)StrId;
1494    return TStr(Bf + Offset);
1495  }
1496  void TVoid::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1497    XLoadHd(Nm);
1498  }
1499  void TVoid::SaveXml(TSOut& SOut, const TStr& Nm) const {
1500    XSaveBETag(Nm);
1501  }
1502  const bool TBool::Mn=0;
1503  const bool TBool::Mx=1;
1504  const int TBool::Vals=TBool::Mx-TBool::Mn+1;
1505  TRnd TBool::Rnd;
1506  const TStr TBool::FalseStr="F";
1507  const TStr TBool::TrueStr="T";
1508  const TStr TBool::NStr="N";
1509  const TStr TBool::YStr="Y";
1510  const TStr TBool::NoStr="No";
1511  const TStr TBool::YesStr="Yes";
1512  void TBool::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1513    XLoadHd(Nm);
1514    Val=TXmlObjSer::GetBoolArg(XmlTok, "Val");
1515  }
1516  void TBool::SaveXml(TSOut& SOut, const TStr& Nm) const {
1517    XSaveBETagArg(Nm, "Val", TBool::GetStr(Val));
1518  }
1519  bool TBool::IsValStr(const TStr& Str){
1520    TStr UcStr=Str.GetUc();
1521    return
1522     (UcStr==FalseStr)||(UcStr==TrueStr)||
1523     (UcStr==YStr)||(UcStr==NStr)||
1524     (UcStr==YesStr)||(UcStr==NoStr);
1525  }
1526  bool TBool::GetValFromStr(const TStr& Str){
1527    return (Str==TrueStr)||(Str==YStr)||(Str==YesStr);
1528  }
1529  bool TBool::GetValFromStr(const TStr& Str, const bool& DfVal){
1530    TStr UcStr=Str.GetUc();
1531    if (IsValStr(UcStr)){
1532      return (UcStr==TrueStr)||(UcStr==YStr)||(UcStr==YesStr);
1533    } else {
1534      return DfVal;
1535    }
1536  }
1537  const char TCh::Mn=CHAR_MIN;
1538  const char TCh::Mx=CHAR_MAX;
1539  const int TCh::Vals=int(TCh::Mx)-int(TCh::Mn)+1;
1540  const char TCh::NullCh=char(0);
1541  const char TCh::TabCh=char(9);
1542  const char TCh::LfCh=char(10);
1543  const char TCh::CrCh=char(13);
1544  const char TCh::EofCh=char(26);
1545  const char TCh::HashCh='#';
1546  void TCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1547    XLoadHd(Nm);
1548    Val=char(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1549  }
1550  void TCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1551    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1552  }
1553  char TCh::GetUsFromYuAscii(const char& Ch){
1554    switch (Ch){
1555      case '~': return 'c';
1556      case '^': return 'C';
1557      case '{': return 's';
1558      case '[': return 'S';
1559      case '`': return 'z';
1560      case '@': return 'Z';
1561      case '|': return 'd';
1562      case '\\': return 'D';
1563      default: return Ch;
1564    }
1565  }
1566  const uchar TUCh::Mn=0;
1567  const uchar TUCh::Mx=UCHAR_MAX;
1568  const int TUCh::Vals=int(TUCh::Mx)-int(TUCh::Mn)+1;
1569  void TUCh::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1570    XLoadHd(Nm);
1571    Val=uchar(TXmlObjSer::GetIntArg(XmlTok, "Val"));
1572  }
1573  void TUCh::SaveXml(TSOut& SOut, const TStr& Nm) const {
1574    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1575  }
1576  const int TInt::Mn=INT_MIN;
1577  const int TInt::Mx=INT_MAX;
1578  const int TInt::Kilo=1024;
1579  const int TInt::Mega=1024*1024;
1580  const int TInt::Giga=1024*1024*1024;
1581  TRnd TInt::Rnd;
1582  void TInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1583    XLoadHd(Nm);
1584    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1585  }
1586  void TInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1587    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1588  }
1589  TStr TInt::GetStr(const int& Val, const char* FmtStr){
1590    if (FmtStr==NULL){
1591      return GetStr(Val);
1592    } else {
1593      char Bf[255];
1594      sprintf(Bf, FmtStr, Val);
1595      return TStr(Bf);
1596    }
1597  }
1598  char* TInt::SaveFrugalInt(char *pDest, int i){
1599    i++;
1600    if (i >= 0 && i <= 127) { *pDest++ = char(i); return pDest; }
1601    if (i >= 128 && i < 128 + 8192) { i -= 128; *pDest++ = char(0x80 | (i & 0x7f));
1602      *pDest++ = char((i >> 7) & 0x3f); return pDest; }
1603    if (i <= -1 && i > -1 - 8192) { i = -1 - i;  *pDest++ = char(0x80 | (i & 0x7f));
1604      *pDest++ = char(0x40 | ((i >> 7) & 0x3f)); return pDest; }
1605    if (i >= 128 + 8192 && i < 128 + 8192 + 536870912) { i -= 128 + 8192;
1606      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1607      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char((i >> 22) & 0x7f); return pDest; }
1608    if (i <= -1 - 8192 && i > -1 - 8192 - 536870912) { i = (-1 - 8192) - i;
1609      *pDest++ = char(0x80 | (i & 0x7f)); *pDest++ = char(0x80 | ((i >> 7) & 0x7f));
1610      *pDest++ = char((i >> 14) & 0xff); *pDest++ = char(0x80 | ((i >> 22) & 0x7f)); return pDest; }
1611    IAssertR(false, TInt::GetStr(i)); return 0;
1612  }
1613  char* TInt::LoadFrugalInt(char *pSrc, int& i){
1614    i = 0;
1615    int ch = (int) ((unsigned char) (*pSrc++));
1616    if ((ch & 0x80) == 0) { i = ch; i--; return pSrc; }
1617    i = (ch & 0x7f);
1618    ch = (int) ((unsigned char) (*pSrc++));
1619    if ((ch & 0x80) == 0)
1620    {
1621      i |= (ch & 0x3f) << 7;
1622      if ((ch & 0x40) == 0) i += 128; else i = -1 - i;
1623      i--; return pSrc;
1624    }
1625    i |= (ch & 0x7f) << 7;
1626    ch = (int) ((unsigned char) (*pSrc++));
1627    i |= ch << 14;
1628    ch = (int) ((unsigned char) (*pSrc++));
1629    i |= (ch & 0x7f) << 22;
1630    if ((ch & 0x80) == 0) i += 128 + 8192; else i = (-1 - 8192) - i;
1631    i--; return pSrc;
1632  }
1633  void TInt::TestFrugalInt(){
1634    char buf[10], *p = &buf[0], *r, *s;
1635    int i, j;
1636  #define __TEST(from, to, len) \
1637    for (i = (from); i <= (to); i++) \
1638      { if ((i & 0xffff) == 0) printf("%d\r", i); \
1639        r = SaveFrugalInt(p, i); s = LoadFrugalInt(p, j); \
1640        IAssert(r == s); IAssert(i == j); IAssert(r - p == len); }
1641    __TEST(-1, 126, 1);
1642    __TEST(127, 127 + 8191, 2);
1643    __TEST(-2 - 8191, -2, 2);
1644    __TEST(127 + 8192, 127 + 8191 + (1 << 29), 4);
1645    __TEST(-2 - 8191 - (1 << 29), -2 - 8192, 4);
1646  #undef __TEST
1647  }
1648  void TInt::SaveFrugalIntV(TSOut& SOut, const TIntV& v){
1649    int count = v.Len();
1650    char *buf = new char[4 * (count + 1)], *pStart, *pEnd;
1651    pStart = buf + 4; pEnd = pStart;
1652    for (int i = 0; i < count; i++)
1653      pEnd = SaveFrugalInt(pEnd, v[i].Val);
1654    int size = int(pEnd - pStart);
1655    char *pSizeStart = buf;
1656    char *pSizeEnd = SaveFrugalInt(pSizeStart, size);
1657    while (pSizeEnd > pSizeStart) *(--pStart) = *(--pSizeEnd);
1658    SOut.PutBf(pStart, TSize(pEnd - pStart));
1659    delete[] buf;
1660  }
1661  void TInt::LoadFrugalIntV(TSIn& SIn, TIntV& v, bool clearVec){
1662    if (clearVec) v.Clr();
1663    char sizeBuf[4], *p, *pEnd;
1664    sizeBuf[0] = SIn.GetCh(); int count = 1;
1665    if (sizeBuf[0] & 0x80)
1666    {
1667      sizeBuf[1] = SIn.GetCh(); count++;
1668      if (sizeBuf[1] & 0x80) { sizeBuf[2] = SIn.GetCh();
1669        sizeBuf[3] = SIn.GetCh(); count += 2;}
1670    }
1671    int size;
1672    pEnd = LoadFrugalInt(&sizeBuf[0], size);
1673    IAssert(pEnd - &sizeBuf[0] == count);
1674    if (size <= 0) return;
1675    char *buf = new char[size];
1676    SIn.GetBf(buf, size);
1677    p = buf; pEnd = buf + size;
1678    while (p < pEnd)
1679      { int i; p = LoadFrugalInt(p, i); v.Add(i); }
1680    IAssert(p == pEnd);
1681    delete[] buf;
1682  }
1683  const uint TUInt::Mn=0;
1684  const uint TUInt::Mx=UINT_MAX;
1685  TRnd TUInt::Rnd;
1686  void TUInt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1687    XLoadHd(Nm);
1688    Val=TXmlObjSer::GetIntArg(XmlTok, "Val");
1689  }
1690  void TUInt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1691    XSaveBETagArg(Nm, "Val", TInt::GetStr(Val));
1692  }
1693  TStr TUInt::GetStr(const uint& Val, const char* FmtStr){
1694    if (FmtStr==NULL){
1695      return GetStr(Val);
1696    } else {
1697      char Bf[255];
1698      sprintf(Bf, FmtStr, Val);
1699      return TStr(Bf);
1700    }
1701  }
1702  bool TUInt::IsIpStr(const TStr& IpStr, uint& Ip, const char& SplitCh) {
1703  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1704      Ip = 0; int Byte = 0;
1705  	if (IpStrV.Len() != 4) { return false; }
1706  	if (!IpStrV[0].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (uint)Byte;
1707  	if (!IpStrV[1].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1708  	if (!IpStrV[2].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1709  	if (!IpStrV[3].IsInt(true, 0, 255, Byte)) { return false; }; Ip = (Ip << 8) | (uint)Byte;
1710  	return true;
1711  }
1712  uint TUInt::GetUIntFromIpStr(const TStr& IpStr, const char& SplitCh) {
1713  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV);
1714      uint Ip = 0; int Byte = 0;
1715  	EAssertR(IpStrV[0].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (uint)Byte;
1716  	EAssertR(IpStrV[1].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1717  	EAssertR(IpStrV[2].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1718  	EAssertR(IpStrV[3].IsInt(true, 0, 255, Byte), TStr::Fmt("Bad IP: '%s;", IpStr.CStr())); Ip = (Ip << 8) | (uint)Byte;
1719  	return Ip;
1720  }
1721  TStr TUInt::GetStrFromIpUInt(const uint& Ip) {
1722    return TStr::Fmt("%d.%d.%d.%d", ((Ip>>24) & 0xFF),
1723     ((Ip>>16) & 0xFF), ((Ip>>8) & 0xFF), (Ip & 0xFF));
1724  }
1725  bool TUInt::IsIpv6Str(const TStr& IpStr, const char& SplitCh) {
1726  	TStrV IpStrV; IpStr.SplitOnAllCh(SplitCh, IpStrV, false);
1727  	if (IpStrV.Len() > 8) { return false; }
1728  	int Group = 0;
1729  	for (int IpStrN = 0; IpStrN < IpStrV.Len(); IpStrN++) {
1730  		if (IpStrV[IpStrN].Empty()) { continue; }
1731  		if (IpStrV[IpStrN].IsHexInt(true, 0x0000, 0xFFFF, Group)) { continue; }
1732  		return false; 
1733  	}
1734  	return true;
1735  }
1736  #if defined (GLib_WIN32)
1737  const TUInt64 TUInt64::Mn(uint64(0x0000000000000000i64));
1738  const TUInt64 TUInt64::Mx(uint64(0xFFFFFFFFFFFFFFFFi64));
1739  #elif defined (GLib_BCB)
1740  const TUInt64 TUInt64::Mn(0x0000000000000000i64);
1741  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFi64);
1742  #else
1743  const TUInt64 TUInt64::Mn((uint64)0x0000000000000000LL);
1744  const TUInt64 TUInt64::Mx(0xFFFFFFFFFFFFFFFFLL);
1745  #endif
1746  void TUInt64::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1747    XLoadHd(Nm);
1748    Val=TXmlObjSer::GetInt64Arg(XmlTok, "Val");
1749  }
1750  void TUInt64::SaveXml(TSOut& SOut, const TStr& Nm) const {
1751    XSaveBETagArg(Nm, "Val", TUInt64::GetStr(Val));
1752  }
1753  const double TFlt::Mn=-DBL_MAX;
1754  const double TFlt::Mx=+DBL_MAX;
1755  const double TFlt::NInf=-DBL_MAX;
1756  const double TFlt::PInf=+DBL_MAX;
1757  const double TFlt::Eps=1e-16;
1758  const double TFlt::EpsHalf  =1e-7;
1759  TRnd TFlt::Rnd;
1760  void TFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1761    XLoadHd(Nm);
1762    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1763  }
1764  void TFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1765    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1766  }
1767  TStr TFlt::GetStr(const double& Val, const int& Width, const int& Prec){
1768    char Bf[255];
1769    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%g", Val);}
1770    else {sprintf(Bf, "%*.*f", Width, Prec, Val);}
1771    return TStr(Bf);
1772  }
1773  TStr TFlt::GetStr(const double& Val, const char* FmtStr){
1774    if (FmtStr==NULL){
1775      return GetStr(Val);
1776    } else {
1777      char Bf[255];
1778      sprintf(Bf, FmtStr, Val);
1779      return TStr(Bf);
1780    }
1781  }
1782  const sdouble TSFlt::Mn=-FLT_MIN;
1783  const sdouble TSFlt::Mx=+FLT_MAX;
1784  void TSFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1785    XLoadHd(Nm);
1786    Val=sdouble(TXmlObjSer::GetFltArg(XmlTok, "Val"));
1787  }
1788  void TSFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1789    XSaveBETagArg(Nm, "Val", TFlt::GetStr(Val));
1790  }
1791  const ldouble TLFlt::Mn=-LDBL_MAX;
1792  const ldouble TLFlt::Mx=+LDBL_MAX;
1793  void TLFlt::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1794    XLoadHd(Nm);
1795    Val=TXmlObjSer::GetFltArg(XmlTok, "Val");
1796  }
1797  void TLFlt::SaveXml(TSOut& SOut, const TStr& Nm) const {
1798    XSaveBETagArg(Nm, "Val", TFlt::GetStr(double(Val)));
1799  }
1800  TStr TLFlt::GetStr(const ldouble& Val, const int& Width, const int& Prec){
1801    char Bf[255];
1802    if ((Width==-1)&&(Prec==-1)){sprintf(Bf, "%Lg", Val);}
1803    else {sprintf(Bf, "%*.*Lf", Width, Prec, Val);}
1804    return TStr(Bf);
1805  }
1806  TStr TLFlt::GetStr(const ldouble& Val, const char* FmtStr){
1807    if (FmtStr==NULL){
1808      return GetStr(Val);
1809    } else {
1810      char Bf[255];
1811      sprintf(Bf, FmtStr, Val);
1812      return TStr(Bf);
1813    }
1814  }
1815  void TFltRect::LoadXml(const PXmlTok& XmlTok, const TStr& Nm){
1816    XLoadHd(Nm);
1817    MnX=TXmlObjSer::GetFltArg(XmlTok, "MnX");
1818    MnY=TXmlObjSer::GetFltArg(XmlTok, "MnY");
1819    MxX=TXmlObjSer::GetFltArg(XmlTok, "MxX");
1820    MxY=TXmlObjSer::GetFltArg(XmlTok, "MxY");
1821  }
1822  void TFltRect::SaveXml(TSOut& SOut, const TStr& Nm) const {
1823    XSaveBETagArg4(Nm,
1824     "MnX", TFlt::GetStr(double(MnX)), "MnY", TFlt::GetStr(double(MnY)),
1825     "MxX", TFlt::GetStr(double(MxX)), "MxY", TFlt::GetStr(double(MxY)));
1826  }
1827  bool TFltRect::Intersection(const TFltRect& Rect1, const TFltRect& Rect2){
1828    const double MnXX = TFlt::GetMx(Rect1.GetMnX(), Rect2.GetMnX());
1829    const double MnYY = TFlt::GetMx(Rect1.GetMnY(), Rect2.GetMnY());
1830    const double MxXX = TFlt::GetMn(Rect1.GetMxX(), Rect2.GetMxX());
1831    const double MxYY = TFlt::GetMn(Rect1.GetMxY(), Rect2.GetMxY());
1832    return (MnXX < MxXX) && (MnYY < MxYY);
1833  }
1834  TStr TFltRect::GetStr() const {
1835    TChA ChA;
1836    ChA+='(';
1837    ChA+=TFlt::GetStr(MnX, "%0.2f"); ChA+=',';
1838    ChA+=TFlt::GetStr(MnY, "%0.2f"); ChA+=',';
1839    ChA+=TFlt::GetStr(MxX, "%0.2f"); ChA+=',';
1840    ChA+=TFlt::GetStr(MxY, "%0.2f"); ChA+=')';
1841    return ChA;
1842  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mmnet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-dt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>98    if (hasSingleVector) {
99      Neighbors = GetIntVAttrDatN(NId, Name);
100    } else {
101      TStr DirectionalName = GetNeighborCrossName(Name, isOutEId, true, true);
102      Neighbors = GetIntVAttrDatN(NId, DirectionalName);
103    }
104  }
</pre></code></div>
                <div class="column column_space"><pre><code>459      if ((TCh::IsWs(GetCh(SrcChN)))&&(DstChN>0)&&(TCh::IsWs(GetCh(DstChN-1)))){
460        SrcChN++;
461      } else {
462        PutCh(DstChN, GetCh(SrcChN)); SrcChN++; DstChN++;
463      }
464    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    