<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for Logarithmic.cpp & Boolean.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for Logarithmic.cpp & Boolean.cpp
      </h3>
      <h1 align="center">
        35.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>Logarithmic.cpp (49.382717%)<TH>Boolean.cpp (28.169014%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match77-0.html#0',2,'match77-1.html#0',3)" NAME="0">(79-100)<TD><A HREF="javascript:ZweiFrames('match77-0.html#0',2,'match77-1.html#0',3)" NAME="0">(52-73)</A><TD ALIGN=center><FONT COLOR="#ff0000">28</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match77-0.html#1',2,'match77-1.html#1',3)" NAME="1">(101-114)<TD><A HREF="javascript:ZweiFrames('match77-0.html#1',2,'match77-1.html#1',3)" NAME="1">(152-165)</A><TD ALIGN=center><FONT COLOR="#6d0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>Logarithmic.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include &quot;Config.hpp&quot;
#include &quot;ParameterFramework.hpp&quot;
#include &quot;ElementHandle.hpp&quot;
#include &quot;Test.hpp&quot;
#include &quot;BinaryCopy.hpp&quot;

#include &lt;catch.hpp&gt;

#include &lt;string&gt;

using std::string;

namespace parameterFramework
{

const auto validLogarithmicInstances = Config{
    &amp;Config::instances,
    // Size is fixed at 32 and as such is optional */
    R&quot;(&lt;IntegerParameter Name=&quot;trivial&quot; Signed=&quot;true&quot;&gt; &lt;LogarithmicAdaptation SlopeNumerator=&quot;200&quot; LogarithmBase=&quot;10&quot;/&gt; &lt;/IntegerParameter&gt;
    &lt;IntegerParameter Name=&quot;nominal&quot; Size=&quot;32&quot; Signed=&quot;true&quot; Min=&quot;-144&quot; Max=&quot;30&quot;&gt; &lt;LogarithmicAdaptation SlopeNumerator=&quot;1&quot; LogarithmBase=&quot;10&quot;/&gt; &lt;/IntegerParameter&gt;)&quot;};
const auto &amp;invalidLogarithmicParameters = Tests&lt;string&gt;{
    {&quot;invalid Size(64)&quot;, &quot;&lt;IntegerParameter Name='nominal' Size='64' Signed='true' Min='-144' &quot;
                         &quot;Max='30'&gt; &lt;LogarithmicAdaptation SlopeNumerator='1' LogarithmBase='10'/&gt; &quot;
                         &quot;&lt;/IntegerParameter&gt;&quot;},
    {&quot;minimum &gt; maximum&quot;, &quot;&lt;IntegerParameter Name='nominal' Size='32' Signed='true' Min='30' &quot;
                          &quot;Max='-144'&gt; &lt;LogarithmicAdaptation SlopeNumerator='1' &quot;
                          &quot;LogarithmBase='10'/&gt; &lt;/IntegerParameter&gt;&quot;},
    {&quot;logBase =1&quot;, &quot;&lt;IntegerParameter Name='nominal' Size='32' Signed='true' Min='-144' Max='30'&gt; &quot;
                   &quot;&lt;LogarithmicAdaptation SlopeNumerator='1' LogarithmBase='1'/&gt; &quot;
                   &quot;&lt;/IntegerParameter&gt;&quot;},
    {&quot;logBase negative&quot;, &quot;&lt;IntegerParameter Name='nominal' Size='32' Signed='true' Min='-144' &quot;
                         &quot;Max='30'&gt; &lt;LogarithmicAdaptation SlopeNumerator='1' &quot;
                         &quot;LogarithmBase='-10'/&gt; &lt;/IntegerParameter&gt;&quot;}};

struct LogarithmicsPF : public ParameterFramework
{
    LogarithmicsPF() : ParameterFramework{std::move(validLogarithmicInstances)} {}
};

SCENARIO_METHOD(LazyPF, &quot;Invalid Logarithmic points XML structure&quot;, &quot;[Logarithmic Type]&quot;)
{
    for (auto &amp;vec : invalidLogarithmicParameters) {
        GIVEN (&quot;intentional error: &quot; + vec.title) {
            create(Config{&amp;Config::instances, vec.payload});
            THEN (&quot;Start should fail&quot;) {
<A NAME="0"></A>                CHECK_THROWS_AS(mPf-&gt;start(), Exception);
            }
        }
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match77-1.html#0',3,'match77-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    }
}

SCENARIO_METHOD(LogarithmicsPF, &quot;Logarithmic points&quot;, &quot;[Logarithmic Type]&quot;)
{
    GIVEN (&quot;A valid XML structure file&quot;) {
        THEN (&quot;Start should succeed&quot;) {
            CHECK_NOTHROW(start());
            REQUIRE_NOTHROW(setTuningMode(true));
            string path = &quot;/test/test/nominal&quot;;
            AND_THEN (&quot;Set/Get a Loagaritmic point parameter in real value space&quot;) {

                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(too high)&quot;, &quot;31&quot;}, {&quot;(too low)&quot;, &quot;-145&quot;}, {&quot;(not a number)&quot;, &quot;foobar&quot;},
                     }) {
                    GIVEN (&quot;Invalid value &quot; + vec.title) {
                        CHECK_THROWS_AS(setParameter(path, vec.payload), Exception);
                    }
                }
<A NAME="1"></A>                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(upper limit)&quot;, &quot;30&quot;},
                         {&quot;(lower limit)&quot;, &quot;-144&quot;},</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match77-1.html#1',3,'match77-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                         {&quot;(inside range)&quot;, &quot;0&quot;},
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(setParameter(path, vec.payload));
                        string getValueBack;
                        REQUIRE_NOTHROW(getParameter(path, getValueBack));
                        CHECK(getValueBack == vec.payload);
                    }
                }
            }
        }
    }
}
} // namespace parameterFramework</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>Boolean.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2017, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include &quot;Config.hpp&quot;
#include &quot;ParameterFramework.hpp&quot;
#include &quot;ElementHandle.hpp&quot;
#include &quot;Test.hpp&quot;

#include &lt;catch.hpp&gt;

#include &lt;string&gt;

using std::string;

namespace parameterFramework
{

const auto validBooleanInstances = Config{&amp;Config::instances,
                                          // Default for integers is unsigned/32bits
                                          R&quot;(&lt;BooleanParameter Name=&quot;Empty&quot;/&gt;
    &lt;BooleanParameter Name=&quot;nominal&quot;/&gt;)&quot;};
<A NAME="0"></A>
struct BooleanPF : public ParameterFramework
{
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match77-0.html#0',2,'match77-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    BooleanPF() : ParameterFramework{std::move(validBooleanInstances)} {}
};

SCENARIO_METHOD(BooleanPF, &quot;Boolean types&quot;, &quot;[Boolean types]&quot;)
{
    GIVEN (&quot;A valid XML structure file&quot;) {
        THEN (&quot;Start should succeed&quot;) {
            CHECK_NOTHROW(start());
            REQUIRE_NOTHROW(setTuningMode(true));
            string path = &quot;/test/test/nominal&quot;;

            AND_THEN (&quot;Set/Get a Boolean type parameter in real value space&quot;) {

                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(too high)&quot;, &quot;2&quot;}, {&quot;(too low)&quot;, &quot;-1&quot;}, {&quot;(not a number)&quot;, &quot;foobar&quot;},
                     }) {
                    GIVEN (&quot;Invalid value &quot; + vec.title) {
                        CHECK_THROWS_AS(setParameter(path, vec.payload), Exception);
                    }
                }
                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(upper limit)&quot;, &quot;1&quot;}, {&quot;(lower limit)&quot;, &quot;0&quot;},</B></FONT>
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(setParameter(path, vec.payload));
                        string getValueBack;
                        REQUIRE_NOTHROW(getParameter(path, getValueBack));
                        CHECK(getValueBack == vec.payload);
                    }
                }
            }

            AND_THEN (&quot;Set/Get boolean type parameter handle&quot;) {
                ElementHandle handle{*this, path};
                /** @FIXME: 'set' operations on a ParameterHandle are silently
                 * ignored in tuning mode. Does it make sense ? */
                REQUIRE_NOTHROW(setTuningMode(false));

                for (auto &amp;vec : Tests&lt;bool&gt;{
                         {&quot;(upper limit)&quot;, true}, {&quot;(lower limit)&quot;, false},
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(handle.setAsBoolean(vec.payload));
                        bool getValueBack;
                        REQUIRE_NOTHROW(handle.getAsBoolean(getValueBack));
                        CHECK(getValueBack == vec.payload);
                    }
                }
            }

            AND_THEN (&quot;Set/Get integer type parameter handle&quot;) {
                ElementHandle handle{*this, path};
                /** @FIXME: 'set' operations on a ParameterHandle are silently
                 * ignored in tuning mode. Does it make sense ? */
                REQUIRE_NOTHROW(setTuningMode(false));

                for (auto &amp;vec : Tests&lt;uint32_t&gt;{
                         {&quot;(upper limit)&quot;, 1}, {&quot;(lower limit)&quot;, 0},
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(handle.setAsInteger(vec.payload));
                        uint32_t getValueBack;
                        REQUIRE_NOTHROW(handle.getAsInteger(getValueBack));
                        CHECK(getValueBack == vec.payload);
                    }
                }
                for (auto &amp;vec : Tests&lt;uint32_t&gt;{
                         {&quot;(too high)&quot;, 2},
                     }) {
                    GIVEN (&quot;An invalid value &quot; + vec.title) {
                        CHECK_THROWS_AS(handle.setAsInteger(vec.payload), Exception);
                    }
                }
            }

            AND_THEN (&quot;Set/Get a Boolean type parameter in real value space&quot;) {
                ElementHandle handle{*this, path};
                REQUIRE_NOTHROW(setRawValueSpace(true));

                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(too high hexa)&quot;, &quot;0x2&quot;},
                         {&quot;(too high dec)&quot;, &quot;2&quot;},
                         {&quot;(too low hexa )&quot;, &quot;0xFF&quot;},
                         {&quot;(not a number)&quot;, &quot;foobar&quot;},
                     }) {
                    GIVEN (&quot;Invalid value &quot; + vec.title) {
                        CHECK_THROWS_AS(setParameter(path, vec.payload), Exception);
                    }
                }
                for (auto &amp;vec : Tests&lt;string&gt;{
                         {&quot;(TRUE hexa)&quot;, &quot;0x1&quot;}, {&quot;(TRUE dec)&quot;, &quot;1&quot;},
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(setParameter(path, vec.payload));
                        string getValueBack;
                        REQUIRE_NOTHROW(getParameter(path, getValueBack));
                        CHECK(getValueBack == &quot;1&quot;);
<A NAME="1"></A>                    }
                }
                for (auto &amp;vec : Tests&lt;string&gt;{
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match77-0.html#1',2,'match77-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>                         {&quot;(FALSE hexa)&quot;, &quot;0x0&quot;}, {&quot;(FALSE dec)&quot;, &quot;0&quot;},
                     }) {
                    GIVEN (&quot;A valid value &quot; + vec.title) {
                        CHECK_NOTHROW(setParameter(path, vec.payload));
                        string getValueBack;
                        REQUIRE_NOTHROW(getParameter(path, getValueBack));
                        CHECK(getValueBack == &quot;0&quot;);
                    }
                }
            }
        }
    }
}
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
