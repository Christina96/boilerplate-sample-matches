
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.099125364431487%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "Snap.h"
3  #include "rolx.h"
4  void PrintFeatures(const TIntFtrH& Features) {
5    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
6      printf("%d: [", HI.GetKey()());
7      const TFtr& Feature = HI.GetDat();
8      for (int i = 0; i < Feature.Len(); ++i) {
9        if (i > 0) {
10          printf(",");
11        }
12        printf("%f", Feature[i]());
13      }
14      printf("]\n");
15    }
16  }
17  TIntFtrH CreateEmptyFeatures(const PUNGraph Graph) {
18    TIntFtrH EmptyFeatures;
19    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
20      EmptyFeatures.AddDat(TInt(NI.GetId()), TFtr());
21    }
22    return EmptyFeatures;
23  }
24  TIntFtrH CreateEmptyFeatures(const TIntFtrH& Features) {
25    TIntFtrH EmptyFeatures;
26    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
27      EmptyFeatures.AddDat(HI.GetKey(), TFtr());
28    }
29    return EmptyFeatures;
30  }
31  int GetNumFeatures(const TIntFtrH& Features) {
32    return Features.BegI().GetDat().Len();
33  }
34  TFtr GetNthFeature(const TIntFtrH& Features, const int N) {
35    TFtr NthFeature;
36    IAssert(0 <= N && N < GetNumFeatures(Features));
37    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
38      NthFeature.Add(HI.GetDat()[N]);
39    }
40    return NthFeature;
41  }
42  TIntFtrH ExtractFeatures(const PUNGraph Graph) {
43    TIntFtrH Features = CreateEmptyFeatures(Graph);
44    AddNeighborhoodFeatures(Graph, Features);
45    printf("finish neighborhood features\n");
46    AddRecursiveFeatures(Graph, Features);
47    printf("finish recursive features\n");
48    return Features;
49  }
50  void AddNeighborhoodFeatures(const PUNGraph Graph, TIntFtrH& Features) {
51    AddLocalFeatures(Graph, Features);
52    printf("finish local features\n");
53    AddEgonetFeatures(Graph, Features);
54    printf("finish egonet features\n");
55  }
56  void AddRecursiveFeatures(const PUNGraph Graph, TIntFtrH& Features) {
57    int SimilarityThreshold = 0;
58    TIntFtrH RetainedFeatures = Features;
59    while (true) {
60      TIntFtrH NewFeatures = GenerateRecursiveFeatures(Graph, RetainedFeatures);
61      RetainedFeatures = PruneRecursiveFeatures(Graph, Features, NewFeatures,
62          SimilarityThreshold);
63      if (0 == GetNumFeatures(RetainedFeatures)) {
64        break;
65      }
66      AppendFeatures(Features, RetainedFeatures);
67      ++SimilarityThreshold;
68      printf("recursion %d: ", SimilarityThreshold);
69      printf("current feature number %d\n", GetNumFeatures(Features));
70    }
71  }
72  void AddLocalFeatures(const PUNGraph Graph, TIntFtrH& Features) {
73    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
74      Features.GetDat(TInt(NI.GetId())).Add(NI.GetInDeg());
75    }
76  }
77  void AddEgonetFeatures(const PUNGraph Graph, TIntFtrH& Features) {
78    for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
79      int NId = NI.GetId();
80      int ArndEdges;
81      PUNGraph Egonet = TSnap::GetEgonet(Graph, NId, ArndEdges);
82      Features.GetDat(NId).Add(Egonet->GetEdges());
83      Features.GetDat(NId).Add(ArndEdges);
84    }
85  }
86  TIntFtrH GenerateRecursiveFeatures(const PUNGraph Graph,
87      const TIntFtrH& CurrFeatures) {
88    const int NumCurrFeatures = GetNumFeatures(CurrFeatures);
89    if (0 == NumCurrFeatures) {
90      return CurrFeatures;
91    }
92    TIntFtrH NewFeatures = CreateEmptyFeatures(CurrFeatures);
93    for (int i = 0; i < NumCurrFeatures; ++i) {
94      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
95        float Sum = 0;
96        for (int j = 0; j < NI.GetInDeg(); ++j) {
97          int NbrNId = NI.GetInNId(j);
98          Sum += CurrFeatures.GetDat(NbrNId)[i]();
99        }
100        NewFeatures.GetDat(NI.GetId()).Add(Sum);
101        NewFeatures.GetDat(NI.GetId()).Add(0 == NI.GetInDeg()?
102            0 : (float(Sum) / NI.GetInDeg()));
103      }
104    }
105    return NewFeatures;
106  }
107  TIntFtrH PruneRecursiveFeatures(const PUNGraph Graph, const TIntFtrH& Features,
108      const TIntFtrH& NewFeatures, const int SimilarityThreshold) {
109    TIntFtrH AllFeatures = CreateEmptyFeatures(Features);
110    AppendFeatures(AllFeatures, Features);
111    AppendFeatures(AllFeatures, NewFeatures);
112    const float BinFraction = 0.5;
113    TIntFtrH LogBinFeatures = CalcVerticalLogBinning(AllFeatures, BinFraction);
114    PUNGraph FeatureGraph = BuildFeatureGraph(LogBinFeatures,
115        SimilarityThreshold);
116    return SummarizeConnectedComponents(FeatureGraph, Features, NewFeatures);
117  }
118  void AppendFeatures(TIntFtrH& DstFeatures, const TIntFtrH& SrcFeatures,
119      const int ColIdx) {
120    for (TIntFtrH::TIter HI = SrcFeatures.BegI();
121        HI < SrcFeatures.EndI();
122        HI++) {
123      const TFtr& Feature = HI.GetDat();
124      if (ColIdx >= 0) {
125        DstFeatures.GetDat(HI.GetKey()).Add(Feature[ColIdx]);
126      } else {
127        for (int i = 0; i < Feature.Len(); ++i) {
128          DstFeatures.GetDat(HI.GetKey()).Add(Feature[i]);
129        }
130      }
131    }
132  }
133  TIntFtrH CalcVerticalLogBinning(const TIntFtrH& Features,
134      const float BinFraction) {
135    const int NumFeatures = GetNumFeatures(Features);
136    TIntFtrH LogBinFeatures = CreateEmptyFeatures(Features);
137    for (int i = 0; i < NumFeatures; ++i) {
138      TVec<TInt> SortedNId = GetNIdSorted(Features, i);
139      AssignBinValue(SortedNId, BinFraction, LogBinFeatures);
140    }
141    return LogBinFeatures;
142  }
143  PUNGraph BuildFeatureGraph(const TIntFtrH& LogBinFeatures,
144      const int SimilarityThreshold) {
145    PUNGraph FeatureGraph = PUNGraph::New();
146    const int NumFeatures = GetNumFeatures(LogBinFeatures);
147    for (int i = 0; i < NumFeatures; ++i) {
148      FeatureGraph->AddNode(i);
149    }
150    for (int i = 0; i < NumFeatures; ++i) {
151      TFtr IthFeature = GetNthFeature(LogBinFeatures, i);
152      for (int j = i + 1; j < NumFeatures; ++j) {
153        TFtr JthFeature = GetNthFeature(LogBinFeatures, j);
154        if (IsSimilarFeature(IthFeature, JthFeature, SimilarityThreshold) &&
155            !FeatureGraph->IsEdge(i, j)) {
156          FeatureGraph->AddEdge(i, j);
157        }
158      }
159    }
160    return FeatureGraph;
161  }
162  TIntFtrH SummarizeConnectedComponents(const PUNGraph FeatureGraph,
163      const TIntFtrH& Features, const TIntFtrH& NewFeatures) {
164    TCnComV Wcc;
165    TSnap::GetWccs(FeatureGraph, Wcc);
166    TVec<TInt> RetainedIdx;
167    for (int i = 0; i < Wcc.Len(); ++i) {
168      RetainedIdx.Add(Wcc[i][0]);
169    }
170    RetainedIdx.Sort();
171    TIntFtrH RetainedFeatures = CreateEmptyFeatures(Features);
172    const int StartIdxNewFeatures = GetNumFeatures(Features);
173    for (int i = 0; i < RetainedIdx.Len(); ++i) {
174      const int IdxNewFeatures = RetainedIdx[i] - StartIdxNewFeatures;
175      if (IdxNewFeatures >= 0) {
176        AppendFeatures(RetainedFeatures, NewFeatures, IdxNewFeatures);
177      }
178    }
179    return RetainedFeatures;
180  }
181  TVec<TInt> GetNIdSorted(const TIntFtrH& Features, const int Idx) {
182    THash<TInt, TFlt> F;
183    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
184      F.AddDat(HI.GetKey(), HI.GetDat()[Idx]);
185    }
186    F.SortByDat();
187    TVec<TInt> SortedNId;
188    for (THash<TInt, TFlt>::TIter HI = F.BegI(); HI < F.EndI(); HI++) {
189      SortedNId.Add(HI.GetKey());
190    }
191    return SortedNId;
192  }
193  void AssignBinValue(const TVec<TInt>& SortedNId, const float BinFraction,
194      TIntFtrH& LogBinFeatures) {
195    int NumNodes = LogBinFeatures.Len();
196    int NumAssigned = 0;
197    int BinValue = 0;
198    while (NumAssigned < NumNodes) {
199      int NumToAssign = ceil(BinFraction * (NumNodes - NumAssigned));
200      for (int i = NumAssigned; i < NumAssigned + NumToAssign; ++i) {
201        int NId = SortedNId[i];
202        LogBinFeatures.GetDat(NId).Add(BinValue);
203      }
204      NumAssigned += NumToAssign;
205      ++BinValue;
206    }
207  }
208  bool IsSimilarFeature(const TFtr& F1, const TFtr& F2,
209      const int SimilarityThreshold) {
210    IAssert(F1.Len() == F2.Len());
211    for (int i = 0; i < F1.Len(); ++i) {
212      if (TFlt::Abs(F1[i] - F2[i]) > SimilarityThreshold) {
213        return false;
214      }
215    }
216    return true;
217  }
218  TFltVV ConvertFeatureToMatrix(const TIntFtrH& Features,
219      const TIntIntH& NodeIdMtxIdxH) {
220    const int NumNodes = Features.Len();
221    const int NumFeatures = GetNumFeatures(Features);
222    TFltVV FeaturesMtx(NumNodes, NumFeatures);
223    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
224      int i = GetMtxIdx(HI.GetKey(), NodeIdMtxIdxH);
225      for (int j = 0; j < NumFeatures; ++j) {
226        FeaturesMtx(i, j) = HI.GetDat()[j];
227      }
228    }
229    return FeaturesMtx;
230  }
231  void PrintMatrix(const TFltVV& Matrix) {
232    int XDim = Matrix.GetXDim();
233    int YDim = Matrix.GetYDim();
234    printf("[");
235    for (int i = 0; i < XDim; ++i) {
236      printf("[");
237      for (int j = 0; j < YDim; ++j) {
238        if (j != 0) {
239          printf(" ");
240        }
241        printf("%f", Matrix(i, j)());
242      }
243      printf("]\n");
244    }
245    printf("]\n");
246  }
247  TFltVV CreateRandMatrix(const int XDim, const int YDim) {
248    int Seed = 13;
249    TFltVV Matrix(XDim, YDim);
250    for (int i = 0; i < XDim; ++i) {
251      for (int j = 0; j < YDim; ++j) {
252        Matrix(i, j) = (double)Seed / 10007;
253        Seed = (Seed * 1871) % 10007;
254      }
255    }
256    return Matrix;
257  }
258  bool FltIsZero(const TFlt Number) {
259    return TFlt::Abs(Number) < TFlt::Eps;
260  }
261  void CalcNonNegativeFactorization(const TFltVV& V, const int NumRoles,
262      TFltVV& W, TFltVV& H, const double Threshold) {
263    double Cost = 100, NewCost = 0;
264    int NumNodes = V.GetXDim();
265    int NumFeatures = V.GetYDim();
266    W = CreateRandMatrix(NumNodes, NumRoles);
267    H = CreateRandMatrix(NumRoles, NumFeatures);
268    TFltVV NewW(NumNodes, NumRoles);
269    TFltVV NewH(NumRoles, NumFeatures);
270    TFltVV Product(NumNodes, NumFeatures);
271    TFltV Sum(NumRoles);
272    TFltVV *PW = &W, *PH = &H, *PNewW = &NewW, *PNewH = &NewH, *Tmp;
273    while (TFlt::Abs((NewCost - Cost)/Cost) > Threshold) {
274      TLinAlg::Multiply(*PW, *PH, Product);
275      Cost = NewCost;
276      NewCost = 0;
277      for (int i = 0; i < NumNodes; i++) {
278        for (int j = 0; j < NumFeatures; j++) {
279          NewCost += V(i, j) * TMath::Log(Product(i, j)) - Product(i, j);
280        }
281      }
282      for (int i = 0; i < NumNodes; i++) {
283        for (int a = 0; a < NumRoles; a++) {
284          double SumU = 0;
285          for (int u = 0; u < NumFeatures; ++u) {
286            if (!FltIsZero(Product(i, u))) {
287              SumU += V(i, u) / Product(i, u) * PH->At(a, u);
288            }
289          }
290          PNewW->At(i, a) = PW->At(i, a) * SumU;
291        }
292      }
293      for (int i = 0; i < NumRoles; i++) {
294        Sum[i] = 0;
295      }
296      for (int i = 0; i < NumNodes; i++) {
297        for (int j = 0; j < NumRoles; j++) {
298          Sum[j] += PNewW->At(i, j);
299        }
300      }
301      for (int i = 0; i < NumNodes; i++) {
302        for (int j = 0; j < NumRoles; j++) {
303          PNewW->At(i, j) /= Sum[j];
304        }
305      }
306      for (int a = 0; a < NumRoles; a++) {
307        for (int u = 0; u < NumFeatures; u++) {
308          double SumI = 0;
309          for (int i = 0; i < NumNodes; ++i) {
310            if (!FltIsZero(Product(i, u))) {
311              SumI += PW->At(i, a) * V(i, u) / Product(i, u);
312            }
313          }
314          PNewH->At(a, u) = PH->At(a, u) * SumI;
315        }
316      }
317      Tmp = PW; PW = PNewW; PNewW = Tmp;
318      Tmp = PH; PH = PNewH; PNewH = Tmp;
319    }
320  }
321  TFlt CalcDescriptionLength(const TFltVV& V, const TFltVV& G,
322      const TFltVV& F) {
323    int B = 64;
324    int M = B * V.GetYDim() * (V.GetXDim() + F.GetYDim());
325    TFlt E = 0;
326    TFltVV GF(G.GetXDim(), F.GetYDim());
327    TLinAlg::Multiply(G, F, GF);
328    for (int i = 0; i < V.GetXDim(); ++i) {
329      for (int j = 0; j < V.GetYDim(); ++j) {
330        TFlt ValueV = V(i, j);
331        TFlt ValueGF = GF(i, j);
332        if (FltIsZero(ValueV)) {
333          E += ValueGF;
334        } else if (!FltIsZero(ValueGF)) {
335          E += ValueV * TMath::Log(ValueV / ValueGF) - ValueV + ValueGF;
336        }
337      }
338    }
339    return M + E;
340  }
341  TIntIntH CreateNodeIdMtxIdxHash(const TIntFtrH& Features) {
342    TIntIntH H;
343    TInt Idx = 0;
344    for (TIntFtrH::TIter HI = Features.BegI(); HI < Features.EndI(); HI++) {
345      H.AddDat(HI.GetKey(), Idx);
346      Idx++;
347    }
348    return H;
349  }
350  int GetMtxIdx(const TInt NodeId, const TIntIntH& NodeIdMtxIdxH) {
351    return NodeIdMtxIdxH.GetDat(NodeId)();
352  }
353  int GetNodeId(const TInt MtxId, const TIntIntH& NodeIdMtxIdxH) {
354    for (TIntIntH::TIter HI = NodeIdMtxIdxH.BegI();
355        HI < NodeIdMtxIdxH.EndI();
356        HI++) {
357      if (HI.GetDat() == MtxId) {
358        return HI.GetKey()();
359      }
360    }
361    return -1;
362  }
363  TIntIntH FindRoles(const TFltVV& G, const TIntIntH& NodeIdMtxIdxH) {
364    TIntIntH Roles;
365    for (int i = 0; i < G.GetXDim(); i++) {
366      int Role = -1;
367      TFlt Max = TFlt::Mn;
368      for (int j = 0; j < G.GetYDim(); j ++) {
369        if (G(i, j) > Max) {
370          Max = G(i, j);
371          Role = j;
372        }
373      }
374      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
375      Roles.AddDat(NodeId, Role);
<span onclick='openModal()' class='match'>376    }
377    return Roles;
378  }
379  void PlotRoles(const PUNGraph Graph, const TIntIntH& Roles) {
380    TStr RoleToColor[10] = { "white", "black", "red", "green", "blue",
381        "yellow", "gold", "cyan", "magenta", "brown" };
</span>382    TIntStrH Color;
383    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
384      Color.AddDat(HI.GetKey(), RoleToColor[HI.GetDat()].CStr());
385    }
386    TSnap::DrawGViz(Graph, gvlDot, "gviz_plot.png", "Dot", 1, Color);
387  }
388  void PrintRoles(const TIntIntH& Roles) {
389    printf("--roles (node ID: role ID)--\n");
390    printf("{\n");
391    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
392      printf("(%d: %d)\n", HI.GetKey()(), HI.GetDat()());
393    }
394    printf("}\n");
395  }
396  void FPrintMatrix(const TFltVV& Matrix, const TStr& Path) {
397    FILE *Fp;
398    Fp = fopen(Path.CStr(), "w");
399    int XDim = Matrix.GetXDim();
400    int YDim = Matrix.GetYDim();
401    for (int i = 0; i < XDim; ++i) {
402      for (int j = 0; j < YDim; ++j) {
403        if (j != 0) {
404          fprintf(Fp, " ");
405        }
406        fprintf(Fp, "%f", Matrix(i, j)());
407      }
408      fprintf(Fp, "\n");
409    }
410    fclose(Fp);
411  }
412  void FPrintNodeMappings(const TIntIntH& NodeIdMtxIdxH, const TStr& Path) {
413    FILE *Fp;
414    Fp = fopen(Path.CStr(), "w");
415    fprintf(Fp, "# mappings from the feature line numbers to node IDs\n");
416    for (int i = 0; i < NodeIdMtxIdxH.Len(); i++) {
417      int NodeId = GetNodeId(i, NodeIdMtxIdxH);
418      fprintf(Fp, "%d %d\n", i, NodeId);
419    }
420    fclose(Fp);
421  }
422  void FPrintRoles(const TIntIntH& Roles, const TStr& Path) {
423    FILE *Fp;
424    Fp = fopen(Path.CStr(), "w");
425    fprintf(Fp, "--roles (node ID role ID)--\n\n");
426    for (TIntIntH::TIter HI = Roles.BegI(); HI < Roles.EndI(); HI++) {
427      fprintf(Fp, "%d\t%d\n", HI.GetKey()(), HI.GetDat()());
428    }
429    fclose(Fp);
430  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</h3>
            <pre><code>1  #include <windowsx.h>
2  #include "ProjectPanel.h"
3  #include "resource.h"
4  #include "CustomFileDialog.h"
5  #include "localization.h"
6  #include "Parameters.h"
7  #define INDEX_CLEAN_ROOT     0
8  #define INDEX_DIRTY_ROOT     1
9  #define INDEX_PROJECT        2
10  #define INDEX_OPEN_NODE	     3
11  #define INDEX_CLOSED_NODE    4
12  #define INDEX_LEAF           5
13  #define INDEX_LEAF_INVALID   6
14  ProjectPanel::~ProjectPanel()
15  {
16  	for (const auto& s : fullPathStrs)
17  	{
18  		delete s;
19  	}
20  }
21  intptr_t CALLBACK ProjectPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
22  {
23  	switch (message)
24  	{
25  		case WM_INITDIALOG :
26  		{
27  			ProjectPanel::initMenus();
28  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST;
29  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
30  								   0,0,0,0,_hSelf, nullptr, _hInst, nullptr);
31  			TBBUTTON tbButtons[2]{};
32  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
33  			generic_string workspace_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 0, PM_WORKSPACEMENUENTRY);
34  			generic_string edit_entry = pNativeSpeaker->getProjectPanelLangMenuStr("Entries", 1, PM_EDITMENUENTRY);
35  			tbButtons[0].idCommand = IDB_PROJECT_BTN;
36  			tbButtons[0].iBitmap = I_IMAGENONE;
37  			tbButtons[0].fsState = TBSTATE_ENABLED;
38  			tbButtons[0].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
39  			tbButtons[0].iString = (intptr_t)workspace_entry.c_str();
40  			tbButtons[1].idCommand = IDB_EDIT_BTN;
41  			tbButtons[1].iBitmap = I_IMAGENONE;
42  			tbButtons[1].fsState = TBSTATE_ENABLED;
43  			tbButtons[1].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
44  			tbButtons[1].iString = (intptr_t)edit_entry.c_str();
45  			SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
46  			SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
47  			SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0); 
48  			ShowWindow(_hToolbarMenu, SW_SHOW);
49  			_treeView.init(_hInst, _hSelf, ID_PROJECTTREEVIEW);
50  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 7, IDI_PROJECT_WORKSPACE, IDI_PROJECT_WORKSPACEDIRTY, IDI_PROJECT_PROJECT, IDI_PROJECT_FOLDEROPEN, IDI_PROJECT_FOLDERCLOSE, IDI_PROJECT_FILE, IDI_PROJECT_FILEINVALID);
51  			_treeView.addCanNotDropInList(INDEX_LEAF);
52  			_treeView.addCanNotDropInList(INDEX_LEAF_INVALID);
53  			_treeView.addCanNotDragOutList(INDEX_CLEAN_ROOT);
54  			_treeView.addCanNotDragOutList(INDEX_DIRTY_ROOT);
55  			_treeView.addCanNotDragOutList(INDEX_PROJECT);
56  			_treeView.display();
57  			if (!openWorkSpace(_workSpaceFilePath.c_str(), true))
58  				newWorkSpace();
59  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
60  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
61  			return TRUE;
62  		}
63  		case NPPM_INTERNAL_REFRESHDARKMODE:
64  		{
65  			if (static_cast<BOOL>(lParam) != TRUE)
66  			{
67  				NppDarkMode::autoThemeChildControls(_hSelf);
68  			}
69  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
70  			return TRUE;
71  		}
72  		case WM_MOUSEMOVE:
73  			if (_treeView.isDragging())
74  				_treeView.dragItem(_hSelf, LOWORD(lParam), HIWORD(lParam));
75  			break;
76  		case WM_LBUTTONUP:
77  			if (_treeView.isDragging())
78  				if (_treeView.dropItem())
79  					setWorkSpaceDirty(true);
80  			break;
81  		case WM_NOTIFY:
82  		{
83  			notified((LPNMHDR)lParam);
84  		}
85  		return TRUE;
86  		case WM_SIZE:
87  		{
88  			int width = LOWORD(lParam);
89  			int height = HIWORD(lParam);
90  			RECT toolbarMenuRect{};
91  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
92  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
93  			HWND hwnd = _treeView.getHSelf();
94  			if (hwnd)
95  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + 2, width, height - toolbarMenuRect.bottom - 2, TRUE);
96  			break;
97  		}
98  		case WM_CONTEXTMENU:
99  			if (!_treeView.isDragging())
100  			{
101  				int xPos = GET_X_LPARAM(lParam);
102  				int yPos = GET_Y_LPARAM(lParam);
103  				if (xPos == -1 && yPos == -1)
104  				{
105  					HTREEITEM selectedItem = _treeView.getSelection();
106  					if (selectedItem)
107  					{
108  						RECT selectedItemRect{};
109  						if (TreeView_GetItemRect(_treeView.getHSelf(), selectedItem, &selectedItemRect, TRUE))
110  						{
111  							showContextMenuFromMenuKey(selectedItem, (selectedItemRect.left + selectedItemRect.right) / 2, (selectedItemRect.top + selectedItemRect.bottom) / 2);
112  						}
113  					}
114  				}
115  				else
116  				{
117  					showContextMenu(xPos, yPos);
118  				}
119  			}
120  		return TRUE;
121  		case WM_COMMAND:
122  		{
123  			popupMenuCmd(LOWORD(wParam));
124  			break;
125  		}
126  		case WM_DESTROY:
127  		{
128  			_treeView.destroy();
129  			destroyMenus();
130  			::DestroyWindow(_hToolbarMenu);
131  			break;
132  		}
133  		default :
134  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
135  	}
136  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
137  }
138  bool ProjectPanel::checkIfNeedSave()
139  {
140  	if (_isDirty)
141  	{
142  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
143  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
144  		int res = pNativeSpeaker->messageBox("ProjectPanelChanged",
145  			_hSelf,
146  			TEXT("The workspace was modified. Do you want to save it?"),
147  			TEXT("$STR_REPLACE$"),
148  			MB_YESNOCANCEL | MB_ICONQUESTION,
149  			0,
150  			title);
151  		if (res == IDYES)
152  		{
153  			if (!saveWorkSpace())
154  				return false;
155  		}
156  		else if (res == IDNO)
157  		{
158  		}
159  		else
160  		{
161  			return false;
162  		}
163  	}
164  	return true;
165  }
166  void ProjectPanel::initMenus()
167  {
168  	_hWorkSpaceMenu = ::CreatePopupMenu();
169  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
170  	generic_string new_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWWS, PM_NEWWORKSPACE);
171  	generic_string open_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_OPENWS, PM_OPENWORKSPACE);
172  	generic_string reload_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_RELOADWS, PM_RELOADWORKSPACE);
173  	generic_string save_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEWS, PM_SAVEWORKSPACE);
174  	generic_string saveas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEASWS, PM_SAVEASWORKSPACE);
175  	generic_string saveacopyas_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_SAVEACOPYASWS, PM_SAVEACOPYASWORKSPACE);
176  	generic_string newproject_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_NEWPROJECT, PM_NEWPROJECTWORKSPACE);
177  	generic_string findinprojects_workspace = pNativeSpeaker->getProjectPanelLangMenuStr("WorkspaceMenu", IDM_PROJECT_FINDINPROJECTSWS, PM_FINDINFILESWORKSPACE);
178  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWWS, new_workspace.c_str());
179  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_OPENWS, open_workspace.c_str());
180  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RELOADWS, reload_workspace.c_str());
181  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEWS, save_workspace.c_str());
182  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEASWS, saveas_workspace.c_str());
183  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_SAVEACOPYASWS, saveacopyas_workspace.c_str());
184  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
185  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWPROJECT, newproject_workspace.c_str());
186  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, static_cast<UINT>(-1), 0);
187  	::InsertMenu(_hWorkSpaceMenu, 0, MF_BYCOMMAND, IDM_PROJECT_FINDINPROJECTSWS, findinprojects_workspace.c_str());
188  	generic_string edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
189  	generic_string edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
190  	generic_string edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
191  	generic_string edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
192  	generic_string edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
193  	generic_string edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
194  	generic_string edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("ProjectMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
195  	_hProjectMenu = ::CreatePopupMenu();
196  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
197  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
198  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
199  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
200  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER, edit_addfolder.c_str());
201  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES, edit_addfiles.c_str());
202  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
203  	::InsertMenu(_hProjectMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER, edit_remove.c_str());
204  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
205  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
206  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
207  	edit_addfolder = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_NEWFOLDER, PM_EDITNEWFOLDER);
208  	edit_addfiles = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILES, PM_EDITADDFILES);
209  	edit_addfilesRecursive = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_ADDFILESRECUSIVELY, PM_EDITADDFILESRECUSIVELY);
210  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FolderMenu", IDM_PROJECT_DELETEFOLDER, PM_EDITREMOVE);
211  	_hFolderMenu = ::CreatePopupMenu();
212  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP,        edit_moveup.c_str());
213  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN,      edit_movedown.c_str());
214  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
215  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME,        edit_rename.c_str());
216  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_NEWFOLDER,     edit_addfolder.c_str());
217  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILES,      edit_addfiles.c_str());
218  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_ADDFILESRECUSIVELY, edit_addfilesRecursive.c_str());
219  	::InsertMenu(_hFolderMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFOLDER,  edit_remove.c_str());
220  	edit_moveup = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEUP, PM_MOVEUPENTRY);
221  	edit_movedown = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MOVEDOWN, PM_MOVEDOWNENTRY);
222  	edit_rename = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_RENAME, PM_EDITRENAME);
223  	edit_remove = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_DELETEFILE, PM_EDITREMOVE);
224  	generic_string edit_modifyfile = pNativeSpeaker->getProjectPanelLangMenuStr("FileMenu", IDM_PROJECT_MODIFYFILEPATH, PM_EDITMODIFYFILE);
225  	_hFileMenu = ::CreatePopupMenu();
226  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEUP, edit_moveup.c_str());
227  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MOVEDOWN, edit_movedown.c_str());
228  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, UINT(-1), 0);
229  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_RENAME, edit_rename.c_str());
230  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_DELETEFILE, edit_remove.c_str());
231  	::InsertMenu(_hFileMenu, 0, MF_BYCOMMAND, IDM_PROJECT_MODIFYFILEPATH, edit_modifyfile.c_str());
232  }
233  void ProjectPanel::destroyMenus() 
234  {
235  	::DestroyMenu(_hWorkSpaceMenu);
236  	::DestroyMenu(_hProjectMenu);
237  	::DestroyMenu(_hFolderMenu);
238  	::DestroyMenu(_hFileMenu);
239  }
240  bool ProjectPanel::openWorkSpace(const TCHAR *projectFileName, bool force)
241  {
242  	if ((!force) && (_workSpaceFilePath.length() > 0))
243  	{ 
244  		generic_string newWorkspace = projectFileName;
245  		if (newWorkspace == _workSpaceFilePath)
246  			return true;
247  		if (!saveWorkspaceRequest())
248  			return true;
249  	}
250  	TiXmlDocument *pXmlDocProject = new TiXmlDocument(projectFileName);
251  	bool loadOkay = pXmlDocProject->LoadFile();
252  	if (!loadOkay)
253  	{
254  		delete pXmlDocProject;
255  		return false;
256  	}
257  	TiXmlNode *root = pXmlDocProject->FirstChild(TEXT("NotepadPlus"));
258  	if (!root) 
259  	{
260  		delete pXmlDocProject;
261  		return false;
262  	}
263  	TiXmlNode *childNode = root->FirstChildElement(TEXT("Project"));
264  	if (!childNode) 
265  	{
266  		delete pXmlDocProject;
267  		return false;
268  	}
269  	if (!::PathFileExists(projectFileName))
270  	{
271  		delete pXmlDocProject;
272  		return false;
273  	}
274  	_treeView.removeAllItems();
275  	_workSpaceFilePath = projectFileName;
276  	TCHAR * fileName = PathFindFileName(projectFileName);
277  	HTREEITEM rootItem = _treeView.addItem(fileName, TVI_ROOT, INDEX_CLEAN_ROOT);
278  	for ( ; childNode ; childNode = childNode->NextSibling(TEXT("Project")))
279  	{
280  		HTREEITEM projectItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), rootItem, INDEX_PROJECT);
281  		buildTreeFrom(childNode, projectItem);
282  	}
283  	setWorkSpaceDirty(false);
284  	_treeView.expand(rootItem);
285  	delete pXmlDocProject;
286  	return loadOkay;
287  }
288  void ProjectPanel::newWorkSpace()
289  {
290  	NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
291  	generic_string workspace = pNativeSpeaker->getAttrNameStr(PM_WORKSPACEROOTNAME, "ProjectManager", "WorkspaceRootName");
292  	_treeView.addItem(workspace.c_str(), TVI_ROOT, INDEX_CLEAN_ROOT);
293  	setWorkSpaceDirty(false);
294  	_workSpaceFilePath = TEXT("");
295  }
296  bool ProjectPanel::saveWorkSpace()
297  {
298  	if (_workSpaceFilePath == TEXT(""))
299  	{
300  		return saveWorkSpaceAs(false);
301  	}
302  	else
303  	{
304  		if (!writeWorkSpace())
305  			return false;
306  		setWorkSpaceDirty(false);
307  		return true;
308  	} 
309  }
310  bool ProjectPanel::writeWorkSpace(const TCHAR *projectFileName, bool doUpdateGUI)
311  {
312  	const TCHAR * fn2write = projectFileName?projectFileName:_workSpaceFilePath.c_str();
313  	TiXmlDocument projDoc(fn2write);
314  	TiXmlNode *root = projDoc.InsertEndChild(TiXmlElement(TEXT("NotepadPlus")));
315  	TCHAR textBuffer[MAX_PATH] = { '\0' };
316  	TVITEM tvItem{};
317  	tvItem.mask = TVIF_TEXT;
318  	tvItem.pszText = textBuffer;
319  	tvItem.cchTextMax = MAX_PATH;
320  	HTREEITEM tvRoot = _treeView.getRoot();
321  	if (!tvRoot)
322  		return false;
323  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
324  		tvProj != NULL;
325  		tvProj = _treeView.getNextSibling(tvProj))
326  	{
327  		tvItem.hItem = tvProj;
328  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
329  		TiXmlNode *projRoot = root->InsertEndChild(TiXmlElement(TEXT("Project")));
330  		projRoot->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
331  		buildProjectXml(projRoot, tvProj, fn2write);
332  	}
333  	if (!projDoc.SaveFile())
334  	{
335  		const TCHAR * title = _workSpaceFilePath.length() > 0 ? PathFindFileName (_workSpaceFilePath.c_str()) : _panelTitle.c_str();
336  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
337  		pNativeSpeaker->messageBox("ProjectPanelSaveError",
338  		_hSelf,
339  		TEXT("An error occurred while writing your workspace file.\nYour workspace has not been saved."),
340  		TEXT("$STR_REPLACE$"),
341  		MB_OK | MB_ICONERROR,
342  		0,
343  		title);
344  		return false;
345  	}
346  	TCHAR * fileName = PathFindFileName(fn2write);
347  	if (doUpdateGUI)
348  	{
349  		_treeView.renameItem(tvRoot, fileName);
350  	}
351  	return true;
352  }
353  void ProjectPanel::buildProjectXml(TiXmlNode *node, HTREEITEM hItem, const TCHAR* fn2write)
354  {
355  	TCHAR textBuffer[MAX_PATH] = { '\0' };
356  	TVITEM tvItem{};
357  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
358  	tvItem.pszText = textBuffer;
359  	tvItem.cchTextMax = MAX_PATH;
360  	for (HTREEITEM hItemNode = _treeView.getChildFrom(hItem);
361  		hItemNode != NULL;
362  		hItemNode = _treeView.getNextSibling(hItemNode))
363  	{
364  		tvItem.hItem = hItemNode;
365  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
366  		if (tvItem.lParam)
367  		{
368  			generic_string *fn = (generic_string *)tvItem.lParam;
369  			generic_string newFn = getRelativePath(*fn, fn2write);
370  			TiXmlNode *fileLeaf = node->InsertEndChild(TiXmlElement(TEXT("File")));
371  			fileLeaf->ToElement()->SetAttribute(TEXT("name"), newFn.c_str());
372  		}
373  		else
374  		{
375  			TiXmlNode *folderNode = node->InsertEndChild(TiXmlElement(TEXT("Folder")));
376  			folderNode->ToElement()->SetAttribute(TEXT("name"), tvItem.pszText);
377  			buildProjectXml(folderNode, hItemNode, fn2write);
378  		}
379  	}
380  }
381  bool ProjectPanel::enumWorkSpaceFiles(HTREEITEM tvFrom, const std::vector<generic_string> & patterns, std::vector<generic_string> & fileNames)
382  {
383  	TCHAR textBuffer[MAX_PATH] = { '\0' };
384  	TVITEM tvItem{};
385  	tvItem.mask = TVIF_TEXT | TVIF_PARAM;
386  	tvItem.pszText = textBuffer;
387  	tvItem.cchTextMax = MAX_PATH;
388  	HTREEITEM tvRoot = tvFrom ? tvFrom : _treeView.getRoot();
389  	if (!tvRoot) return false;
390  	for (HTREEITEM tvProj = _treeView.getChildFrom(tvRoot);
391  		tvProj != NULL;
392  		tvProj = _treeView.getNextSibling(tvProj))
393  	{
394  		tvItem.hItem = tvProj;
395  		SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
396  		if (tvItem.lParam)
397  		{
398  			if (matchInList(tvItem.pszText, patterns))
399  			{
400  				generic_string *fn = (generic_string *)tvItem.lParam;
401  				fileNames.push_back (*fn);
402  			}
403  		}
404  		else
405  		{
406  			if (!enumWorkSpaceFiles (tvProj, patterns, fileNames)) return false;
407  		}
<span onclick='openModal()' class='match'>408  	}
409  	return true;
410  }
411  generic_string ProjectPanel::getRelativePath(const generic_string & filePath, const TCHAR *workSpaceFileName)
412  {
413  	TCHAR wsfn[MAX_PATH] = { '\0' };
</span>414  	wcscpy_s(wsfn, workSpaceFileName);
415  	::PathRemoveFileSpec(wsfn);
416  	size_t pos_found = filePath.find(wsfn);
417  	if (pos_found == generic_string::npos)
418  		return filePath;
419  	const TCHAR *relativeFile = filePath.c_str() + lstrlen(wsfn);
420  	if (relativeFile[0] == '\\')
421  		++relativeFile;
422  	return relativeFile;
423  }
424  bool ProjectPanel::buildTreeFrom(TiXmlNode *projectRoot, HTREEITEM hParentItem)
425  {
426  	for (TiXmlNode *childNode = projectRoot->FirstChildElement();
427  		childNode ;
428  		childNode = childNode->NextSibling())
429  	{
430  		const TCHAR *v = childNode->Value();
431  		if (lstrcmp(TEXT("Folder"), v) == 0)
432  		{
433  			HTREEITEM addedItem = _treeView.addItem((childNode->ToElement())->Attribute(TEXT("name")), hParentItem, INDEX_CLOSED_NODE);
434  			if (!childNode->NoChildren())
435  			{
436  				bool isOK = buildTreeFrom(childNode, addedItem);
437  				if (!isOK)
438  					return false;
439  			}
440  		}
441  		else if (lstrcmp(TEXT("File"), v) == 0)
442  		{
443  			const TCHAR *strValue = (childNode->ToElement())->Attribute(TEXT("name"));
444  			generic_string fullPath = getAbsoluteFilePath(strValue);
445  			TCHAR *strValueLabel = ::PathFindFileName(strValue);
446  			int iImage = ::PathFileExists(fullPath.c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
447  			generic_string* fullPathStr = new generic_string(fullPath);
448  			fullPathStrs.push_back(fullPathStr);
449  			LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
450  			_treeView.addItem(strValueLabel, hParentItem, iImage, lParamFullPathStr);
451  		}
452  	}
453  	return true;
454  }
455  generic_string ProjectPanel::getAbsoluteFilePath(const TCHAR * relativePath)
456  {
457  	if (!::PathIsRelative(relativePath))
458  		return relativePath;
459  	TCHAR absolutePath[MAX_PATH] = { '\0' };
460  	wcscpy_s(absolutePath, _workSpaceFilePath.c_str());
461  	::PathRemoveFileSpec(absolutePath);
462  	::PathAppend(absolutePath, relativePath);
463  	return absolutePath;
464  }
465  void ProjectPanel::openSelectFile()
466  {
467  	TVITEM tvItem{};
468  	tvItem.mask = TVIF_PARAM;
469  	tvItem.hItem = _treeView.getSelection();
470  	::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
471  	NodeType nType = getNodeType(tvItem.hItem);
472  	generic_string *fn = (generic_string *)tvItem.lParam;
473  	if (nType == nodeType_file && fn)
474  	{
475  		tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
476  		if (::PathFileExists(fn->c_str()))
477  		{
478  			::PostMessage(_hParent, NPPM_DOOPEN, 0, reinterpret_cast<LPARAM>(fn->c_str()));
479  			tvItem.iImage = INDEX_LEAF;
480  			tvItem.iSelectedImage = INDEX_LEAF;
481  		}
482  		else
483  		{
484  			tvItem.iImage = INDEX_LEAF_INVALID;
485  			tvItem.iSelectedImage = INDEX_LEAF_INVALID;
486  		}
487  		TreeView_SetItem(_treeView.getHSelf(), &tvItem);
488  	}
489  }
490  void ProjectPanel::notified(LPNMHDR notification)
491  {
492  	if (notification->code == DMN_CLOSE)
493  	{
494  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_PROJECT_PANEL_1 + _panelID, 0);
495  		SetWindowLongPtr (getHSelf(), DWLP_MSGRESULT, _isClosed ? 0 : 1);
496  	}
497  	else if (notification->hwndFrom == _treeView.getHSelf())
498  	{
499  		TCHAR textBuffer[MAX_PATH] = { '\0' };
500  		TVITEM tvItem{};
501  		tvItem.mask = TVIF_TEXT | TVIF_PARAM;
502  		tvItem.pszText = textBuffer;
503  		tvItem.cchTextMax = MAX_PATH;
504  		switch (notification->code)
505  		{
506  			case NM_DBLCLK:
507  			{
508  				openSelectFile();
509  			}
510  			break;
511  			case NM_RETURN:
512  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1);
513  			break;
514  			case TVN_ENDLABELEDIT:
515  			{
516  				LPNMTVDISPINFO tvnotif = (LPNMTVDISPINFO)notification;
517  				if (!tvnotif->item.pszText)
518  					return;
519  				if (getNodeType(tvnotif->item.hItem) == nodeType_root)
520  					return;
521  				if (tvnotif->item.lParam) 
522  				{
523  					tvItem.hItem = _treeView.getSelection();
524  					::SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
525  					size_t len = lstrlen(tvItem.pszText);
526  					generic_string *filePath = (generic_string *)tvnotif->item.lParam;
527  					size_t found = filePath->rfind(tvItem.pszText);
528  					if (found != generic_string::npos)
529  						filePath->replace(found, len, tvnotif->item.pszText);
530  					tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
531  					if (::PathFileExists(filePath->c_str()))
532  					{
533  						tvItem.iImage = INDEX_LEAF;
534  						tvItem.iSelectedImage = INDEX_LEAF;
535  					}
536  					else
537  					{
538  						tvItem.iImage = INDEX_LEAF_INVALID;
539  						tvItem.iSelectedImage = INDEX_LEAF_INVALID;
540  					}
541  					TreeView_SetItem(_treeView.getHSelf(), &tvItem);
542  				}
543  				::SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&(tvnotif->item)));
544  				setWorkSpaceDirty(true);
545  			}
546  			break;
547  			case TVN_GETINFOTIP:
548  			{
549  				LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)notification;
550  				generic_string *str = NULL ;
551  				if (_treeView.getRoot() == lpGetInfoTip->hItem)
552  				{
553  					str = &_workSpaceFilePath;
554  				}
555  				else
556  				{
557  					str = (generic_string *)lpGetInfoTip->lParam;
558  					if (!str)
559  						return;
560  				}
561  				lpGetInfoTip->pszText = (LPTSTR)str->c_str();
562  				lpGetInfoTip->cchTextMax = static_cast<int32_t>(str->size());
563  			}
564  			break;
565  			case TVN_KEYDOWN:
566  			{
567  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
568  				if (ptvkd->wVKey == VK_DELETE)
569  				{
570  					HTREEITEM hItem = _treeView.getSelection();
571  					NodeType nType = getNodeType(hItem);
572  					if (nType == nodeType_project || nType == nodeType_folder)
573  						popupMenuCmd(IDM_PROJECT_DELETEFOLDER);
574  					else if (nType == nodeType_file)
575  						popupMenuCmd(IDM_PROJECT_DELETEFILE);
576  				}
577  				else if (ptvkd->wVKey == VK_RETURN)
578  				{
579  					HTREEITEM hItem = _treeView.getSelection();
580  					NodeType nType = getNodeType(hItem);
581  					if (nType == nodeType_file)
582  						openSelectFile();
583  					else
584  						_treeView.toggleExpandCollapse(hItem);
585  				}
586  				else if (ptvkd->wVKey == VK_UP)
587  				{
588  					if (0x80 & GetKeyState(VK_CONTROL))
589  					{
590  						popupMenuCmd(IDM_PROJECT_MOVEUP);
591  					}
592  				}
593  				else if (ptvkd->wVKey == VK_DOWN)
594  				{
595  					if (0x80 & GetKeyState(VK_CONTROL))
596  					{
597  						popupMenuCmd(IDM_PROJECT_MOVEDOWN);
598  					}
599  				}
600  				else if (ptvkd->wVKey == VK_F2)
601  					popupMenuCmd(IDM_PROJECT_RENAME);
602  			}
603  			break;
604  			case TVN_ITEMEXPANDED:
605  			{
606  				LPNMTREEVIEW nmtv = (LPNMTREEVIEW)notification;
607  				tvItem.hItem = nmtv->itemNew.hItem;
608  				tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
609  				if (getNodeType(nmtv->itemNew.hItem) == nodeType_folder)
610  				{
611  					if (nmtv->action == TVE_COLLAPSE)
612  					{
613  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
614  					}
615  					else if (nmtv->action == TVE_EXPAND)
616  					{
617  						_treeView.setItemImage(nmtv->itemNew.hItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
618  					}
619  				}
620  			}
621  			break;
622  			case TVN_BEGINDRAG:
623  			{
624  				_treeView.beginDrag((LPNMTREEVIEW)notification);
625  			}
626  			break;
627  		}
628  	}
629  }
630  void ProjectPanel::setWorkSpaceDirty(bool isDirty)
631  {
632  	_isDirty = isDirty;
633  	int iImg = _isDirty?INDEX_DIRTY_ROOT:INDEX_CLEAN_ROOT;
634  	_treeView.setItemImage(_treeView.getRoot(), iImg, iImg);
635  }
636  NodeType ProjectPanel::getNodeType(HTREEITEM hItem)
637  {
638  	TVITEM tvItem{};
639  	tvItem.hItem = hItem;
640  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
641  	SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
642  	if (tvItem.iImage == INDEX_CLEAN_ROOT || tvItem.iImage == INDEX_DIRTY_ROOT)
643  	{
644  		return nodeType_root;
645  	}
646  	else if (tvItem.iImage == INDEX_PROJECT)
647  	{
648  		return nodeType_project;
649  	}
650  	else if (!tvItem.lParam)
651  	{
652  		return nodeType_folder;
653  	}
654  	else
655  	{
656  		return nodeType_file;
657  	}
658  }
659  void ProjectPanel::showContextMenu(int x, int y)
660  {
661  	TVHITTESTINFO tvHitInfo{};
662  	tvHitInfo.pt.x = x;
663  	tvHitInfo.pt.y = y;
664  	tvHitInfo.flags = 0;
665  	ScreenToClient(_treeView.getHSelf(), &(tvHitInfo.pt));
666  	TreeView_HitTest(_treeView.getHSelf(), &tvHitInfo);
667  	if (tvHitInfo.hItem != NULL)
668  	{
669  		_treeView.selectItem(tvHitInfo.hItem);
670  		HMENU hMenu = getMenuHandler(tvHitInfo.hItem);
671  		TrackPopupMenu(hMenu,
672  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
673  			x, y, 0, _hSelf, NULL);
674  	}
675  }
676  void ProjectPanel::showContextMenuFromMenuKey(HTREEITEM selectedItem, int x, int y)
677  {
678  	POINT p{};
679  	p.x = x;
680  	p.y = y;
681  	ClientToScreen(_treeView.getHSelf(), &p);
682  	if (selectedItem != NULL)
683  	{
684  		HMENU hMenu = getMenuHandler(selectedItem);
685  		TrackPopupMenu(hMenu,
686  			NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
687  			x, y, 0, _hSelf, NULL);
688  	}
689  }
690  HMENU ProjectPanel::getMenuHandler(HTREEITEM selectedItem)
691  {
692  	NodeType nodeType = getNodeType(selectedItem);
693  	HMENU hMenu = NULL;
694  	if (nodeType == nodeType_root)
695  		hMenu = _hWorkSpaceMenu;
696  	else if (nodeType == nodeType_project)
697  		hMenu = _hProjectMenu;
698  	else if (nodeType == nodeType_folder)
699  		hMenu = _hFolderMenu;
700  	else 
701  		hMenu = _hFileMenu;
702  	return hMenu;
703  }
704  POINT ProjectPanel::getMenuDisplayPoint(int iButton)
705  {
706  	POINT p{};
707  	RECT btnRect{};
708  	SendMessage(_hToolbarMenu, TB_GETITEMRECT, iButton, reinterpret_cast<LPARAM>(&btnRect));
709  	p.x = btnRect.left;
710  	p.y = btnRect.top + btnRect.bottom;
711  	ClientToScreen(_hToolbarMenu, &p);
712  	return p;
713  }
714  HTREEITEM ProjectPanel::addFolder(HTREEITEM hTreeItem, const TCHAR *folderName)
715  {
716  	HTREEITEM addedItem = _treeView.addItem(folderName, hTreeItem, INDEX_CLOSED_NODE);
717  	TreeView_Expand(_treeView.getHSelf(), hTreeItem, TVE_EXPAND);
718  	TreeView_EditLabel(_treeView.getHSelf(), addedItem);
719  	if (getNodeType(hTreeItem) == nodeType_folder)
720  		_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
721  	return addedItem;
722  }
723  bool ProjectPanel::saveWorkspaceRequest()
724  { 
725  	if (_isDirty)
726  	{
727  		NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
728  		int res = pNativeSpeaker->messageBox("ProjectPanelOpenDoSaveDirtyWsOrNot",
729  					_hSelf,
730  					TEXT("The current workspace was modified. Do you want to save the current project?"),
731  					TEXT("Open Workspace"),
732  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
733  		if (res == IDYES)
734  		{
735  			if (!saveWorkSpace())
736  				return false;
737  		}
738  		else if (res == IDNO)
739  		{
740  		}
741  		else if (res == IDCANCEL) 
742  		{
743  			return false;
744  		}
745  	}
746  	return true;
747  }
748  void ProjectPanel::popupMenuCmd(int cmdID)
749  {
750  	HTREEITEM hTreeItem = _treeView.getSelection();
751  	if (!hTreeItem)
752  		return;
753  	switch (cmdID)
754  	{
755  		case IDB_PROJECT_BTN:
756  		{
757  		  POINT p = getMenuDisplayPoint(0);
758  		  TrackPopupMenu(_hWorkSpaceMenu,
759  			  NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
760  			  p.x, p.y, 0, _hSelf, NULL);
761  		}
762  		break;
763  		case IDB_EDIT_BTN:
764  		{
765  			POINT p = getMenuDisplayPoint(1);
766  			HMENU hMenu = NULL;
767  			NodeType nodeType = getNodeType(hTreeItem);
768  			if (nodeType == nodeType_project)
769  				hMenu = _hProjectMenu;
770  			else if (nodeType == nodeType_folder)
771  				hMenu = _hFolderMenu;
772  			else if (nodeType == nodeType_file)
773  				hMenu = _hFileMenu;
774  			if (hMenu)
775  				TrackPopupMenu(hMenu,
776  					NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
777  					p.x, p.y, 0, _hSelf, NULL);
778  		}
779  		break;
780  		case IDM_PROJECT_NEWPROJECT :
781  		{
782  			HTREEITEM root = _treeView.getRoot();
783  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
784  			generic_string newProjectLabel = pNativeSpeaker->getAttrNameStr(PM_NEWPROJECTNAME, "ProjectManager", "NewProjectName");
785  			HTREEITEM addedItem = _treeView.addItem(newProjectLabel.c_str(),  root, INDEX_PROJECT);
786  			setWorkSpaceDirty(true);
787  			_treeView.expand(hTreeItem);
788  			TreeView_EditLabel(_treeView.getHSelf(), addedItem);
789  		}
790  		break;
791  		case IDM_PROJECT_NEWWS :
792  		{
793  			if (_isDirty)
794  			{
795  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
796  				int res = pNativeSpeaker->messageBox("ProjectPanelNewDoSaveDirtyWsOrNot",
797  					_hSelf,
798  					TEXT("The current workspace was modified. Do you want to save the current project?"),
799  					TEXT("New Workspace"),
800  					MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL);
801  				if (res == IDYES)
802  				{
803  					if (!saveWorkSpace())
804  						return;
805  				}
806  				else if (res == IDNO)
807  				{
808  				}
809  				else if (res == IDCANCEL) 
810  				{
811  					return;
812  				}
813  			}
814  			_treeView.removeAllItems();
815  			newWorkSpace();
816  		}
817  		break;
818  		case IDM_PROJECT_RENAME :
819  			TreeView_EditLabel(_treeView.getHSelf(), hTreeItem);
820  		break;
821  		case IDM_PROJECT_NEWFOLDER :
822  		{
823  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
824  			generic_string newFolderLabel = pNativeSpeaker->getAttrNameStr(PM_NEWFOLDERNAME, "ProjectManager", "NewFolderName");
825  			addFolder(hTreeItem, newFolderLabel.c_str());
826  			setWorkSpaceDirty(true);
827  		}
828  		break;
829  		case IDM_PROJECT_MOVEDOWN :
830  		{
831  			if (_treeView.moveDown(hTreeItem))
832  				setWorkSpaceDirty(true);
833  		}
834  		break;
835  		case IDM_PROJECT_MOVEUP :
836  		{
837  			if (_treeView.moveUp(hTreeItem))
838  				setWorkSpaceDirty(true);
839  		}
840  		break;
841  		case IDM_PROJECT_ADDFILES :
842  		{
843  			addFiles(hTreeItem);
844  			if (getNodeType(hTreeItem) == nodeType_folder)
845  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
846  		}
847  		break;
848  		case IDM_PROJECT_ADDFILESRECUSIVELY :
849  		{
850  			addFilesFromDirectory(hTreeItem);
851  			if (getNodeType(hTreeItem) == nodeType_folder)
852  				_treeView.setItemImage(hTreeItem, INDEX_OPEN_NODE, INDEX_OPEN_NODE);
853  		}
854  		break;
855  		case IDM_PROJECT_OPENWS:
856  		{
857  			if (!saveWorkspaceRequest())
858  				break;
859  			CustomFileDialog fDlg(_hSelf);
860  			setFileExtFilter(fDlg);
861  			const generic_string fn = fDlg.doOpenSingleFileDlg();
862  			if (!fn.empty())
863  			{
864  				if (!openWorkSpace(fn.c_str(), true))
865  				{
866  					NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
867  					pNativeSpeaker->messageBox("ProjectPanelOpenFailed",
868  						_hSelf,
869  						TEXT("The workspace could not be opened.\rIt seems the file to open is not a valid project file."),
870  						TEXT("Open Workspace"),
871  						MB_OK);
872  					return;
873  				}
874  			}
875  		}
876  		break;
877  		case IDM_PROJECT_RELOADWS:
878  		{
879  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
880  			bool forceOpen = false;
881  			if (_isDirty)
882  			{
883  				int res = pNativeSpeaker->messageBox("ProjectPanelReloadDirty",
884  					_hSelf,
885  					TEXT("The current workspace was modified. Reloading will discard all modifications.\rDo you want to continue?"),
886  					TEXT("Reload Workspace"),
887  					MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);
888  				if (res == IDYES)
889  				{
890  					forceOpen = true;
891  				}
892  				else if (res == IDNO)
893  				{
894  					return;
895  				}
896  			}
897  			if (::PathFileExists(_workSpaceFilePath.c_str()))
898  			{
899  				openWorkSpace(_workSpaceFilePath.c_str(), forceOpen);
900  			}
901  			else
902  			{
903  				pNativeSpeaker->messageBox("ProjectPanelReloadError",
904  					_hSelf,
905  					TEXT("Cannot find the file to reload."),
906  					TEXT("Reload Workspace"),
907  					MB_OK);
908  			}
909  		}
910  		break;
911  		case IDM_PROJECT_SAVEWS:
912  			saveWorkSpace();
913  		break;
914  		case IDM_PROJECT_SAVEACOPYASWS:
915  		case IDM_PROJECT_SAVEASWS:
916  		{
917  			saveWorkSpaceAs(cmdID == IDM_PROJECT_SAVEACOPYASWS);
918  		}
919  		break;
920  		case IDM_PROJECT_FINDINPROJECTSWS:
921  		{
922  			::SendMessage(_hParent, NPPM_INTERNAL_FINDINPROJECTS, (WPARAM) 1 << _panelID, 0);
923  		}
924  		break;
925  		case IDM_PROJECT_DELETEFOLDER :
926  		{
927  			HTREEITEM parent = _treeView.getParent(hTreeItem);
928  			if (_treeView.getChildFrom(hTreeItem) != NULL)
929  			{
930  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
931  				int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFolderFromProject",
932  					_hSelf,
933  					TEXT("All the sub-items will be removed.\rAre you sure you want to remove this folder from the project?"),
934  					TEXT("Remove folder from project"),
935  					MB_YESNO);
936  				if (res == IDYES)
937  				{
938  					_treeView.removeItem(hTreeItem);
939  					setWorkSpaceDirty(true);
940  				}
941  			}
942  			else
943  			{
944  				_treeView.removeItem(hTreeItem);
945  				setWorkSpaceDirty(true);
946  			}
947  			if (getNodeType(parent) == nodeType_folder)
948  				_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
949  		}
950  		break;
951  		case IDM_PROJECT_DELETEFILE :
952  		{
953  			HTREEITEM parent = _treeView.getParent(hTreeItem);
954  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
955  			int res = pNativeSpeaker->messageBox("ProjectPanelRemoveFileFromProject",
956  				_hSelf,
957  				TEXT("Are you sure you want to remove this file from the project?"),
958  				TEXT("Remove file from project"),
959  				MB_YESNO);
960  			if (res == IDYES)
961  			{
962  				_treeView.removeItem(hTreeItem);
963  				setWorkSpaceDirty(true);
964  				if (getNodeType(parent) == nodeType_folder)
965  					_treeView.setItemImage(parent, INDEX_CLOSED_NODE, INDEX_CLOSED_NODE);
966  			}
967  		}
968  		break;
969  		case IDM_PROJECT_MODIFYFILEPATH :
970  		{
971  			FileRelocalizerDlg fileRelocalizerDlg;
972  			fileRelocalizerDlg.init(_hInst, _hParent);
973  			TCHAR textBuffer[MAX_PATH] = { '\0' };
974  			TVITEM tvItem{};
975  			tvItem.hItem = hTreeItem;
976  			tvItem.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
977  			tvItem.pszText = textBuffer;
978  			tvItem.cchTextMax = MAX_PATH;
979  			SendMessage(_treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
980  			if (!tvItem.lParam)
981  				return;
982  			generic_string * fn = (generic_string *)tvItem.lParam;
983  			if (fileRelocalizerDlg.doDialog(fn->c_str()) == 0)
984  			{
985  				generic_string newValue = fileRelocalizerDlg.getFullFilePath();
986  				if (*fn == newValue)
987  					return;
988  				*fn = newValue;
989  				TCHAR *strValueLabel = ::PathFindFileName(fn->c_str());
990  				wcscpy_s(textBuffer, strValueLabel);
991  				int iImage = ::PathFileExists(fn->c_str())?INDEX_LEAF:INDEX_LEAF_INVALID;
992  				tvItem.iImage = tvItem.iSelectedImage = iImage;
993  				SendMessage(_treeView.getHSelf(), TVM_SETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
994  				setWorkSpaceDirty(true);
995  			}
996  		}
997  		break;
998  	}
999  }
1000  bool ProjectPanel::saveWorkSpaceAs(bool saveCopyAs)
1001  {
1002  	CustomFileDialog fDlg(_hSelf);
1003  	setFileExtFilter(fDlg);
1004  	fDlg.setExtIndex(0);		
1005  	const generic_string fn = fDlg.doSaveDlg();
1006  	if (fn.empty())
1007  		return false;
1008  	if (!writeWorkSpace(fn.c_str(), !saveCopyAs))
1009  		return false;
1010  	if (!saveCopyAs)
1011  	{
1012  		_workSpaceFilePath = fn;
1013  		setWorkSpaceDirty(false);
1014  	}
1015  	return true;
1016  }
1017  void ProjectPanel::setFileExtFilter(CustomFileDialog & fDlg)
1018  {
1019  	const TCHAR *ext = NppParameters::getInstance().getNppGUI()._definedWorkspaceExt.c_str();
1020  	generic_string workspaceExt = TEXT("");
1021  	if (*ext != '\0')
1022  	{
1023  		if (*ext != '.')
1024  			workspaceExt += TEXT(".");
1025  		workspaceExt += ext;
1026  		fDlg.setExtFilter(TEXT("Workspace file"), workspaceExt.c_str());
1027  		fDlg.setDefExt(ext);
1028  	}
1029  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1030  }
1031  void ProjectPanel::addFiles(HTREEITEM hTreeItem)
1032  {
1033  	CustomFileDialog fDlg(_hSelf);
1034  	fDlg.setExtFilter(TEXT("All types"), TEXT(".*"));
1035  	const auto& fns = fDlg.doOpenMultiFilesDlg();
1036  	if (!fns.empty())
1037  	{
1038  		size_t sz = fns.size();
1039  		for (size_t i = 0 ; i < sz ; ++i)
1040  		{
1041  			TCHAR *strValueLabel = ::PathFindFileName(fns.at(i).c_str());
1042  			generic_string* pathFileStr = new generic_string(fns.at(i));
1043  			fullPathStrs.push_back(pathFileStr);
1044  			LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1045  			_treeView.addItem(strValueLabel, hTreeItem, INDEX_LEAF, lParamPathFileStr);
1046  		}
1047  		_treeView.expand(hTreeItem);
1048  		setWorkSpaceDirty(true);
1049  	}
1050  }
1051  void ProjectPanel::recursiveAddFilesFrom(const TCHAR *folderPath, HTREEITEM hTreeItem)
1052  {
1053  	bool isRecursive = true;
1054  	bool isInHiddenDir = false;
1055  	generic_string dirFilter(folderPath);
1056  	if (folderPath[lstrlen(folderPath)-1] != '\\')
1057  		dirFilter += TEXT("\\");
1058  	dirFilter += TEXT("*.*");
1059  	WIN32_FIND_DATA foundData;
1060  	std::vector<generic_string> files;
1061  	HANDLE hFile = ::FindFirstFile(dirFilter.c_str(), &foundData);
1062  	do {
1063  		if (hFile == INVALID_HANDLE_VALUE)
1064  			break;
1065  		if (foundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1066  		{
1067  			if (!isInHiddenDir && (foundData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
1068  			{
1069  			}
1070  			else if (isRecursive)
1071  			{
1072  				if ((OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT(".")) != 0) && (OrdinalIgnoreCaseCompareStrings(foundData.cFileName, TEXT("..")) != 0))
1073  				{
1074  					generic_string pathDir(folderPath);
1075  					if (folderPath[lstrlen(folderPath)-1] != '\\')
1076  						pathDir += TEXT("\\");
1077  					pathDir += foundData.cFileName;
1078  					pathDir += TEXT("\\");
1079  					HTREEITEM addedItem = addFolder(hTreeItem, foundData.cFileName);
1080  					recursiveAddFilesFrom(pathDir.c_str(), addedItem);
1081  				}
1082  			}
1083  		}
1084  		else
1085  		{
1086  			files.push_back(foundData.cFileName);
1087  		}
1088  	} while (::FindNextFile(hFile, &foundData));
1089  	for (size_t i = 0, len = files.size() ; i < len ; ++i)
1090  	{
1091  		generic_string pathFile(folderPath);
1092  		if (folderPath[lstrlen(folderPath)-1] != '\\')
1093  			pathFile += TEXT("\\");
1094  		pathFile += files[i];
1095  		generic_string* pathFileStr = new generic_string(pathFile);
1096  		fullPathStrs.push_back(pathFileStr);
1097  		LPARAM lParamPathFileStr = reinterpret_cast<LPARAM>(pathFileStr);
1098  		_treeView.addItem(files[i].c_str(), hTreeItem, INDEX_LEAF, lParamPathFileStr);
1099  	}
1100  	::FindClose(hFile);
1101  }
1102  void ProjectPanel::addFilesFromDirectory(HTREEITEM hTreeItem)
1103  {
1104  	if (_selDirOfFilesFromDirDlg == TEXT("") && _workSpaceFilePath != TEXT(""))
1105  	{
1106  		TCHAR dir[MAX_PATH] = { '\0' };
1107  		wcscpy_s(dir, _workSpaceFilePath.c_str());
1108  		::PathRemoveFileSpec(dir);
1109  		_selDirOfFilesFromDirDlg = dir;
1110  	}
1111  	generic_string dirPath;
1112  	if (_selDirOfFilesFromDirDlg != TEXT(""))
1113  		dirPath = getFolderName(_hSelf, _selDirOfFilesFromDirDlg.c_str());
1114  	else
1115  		dirPath = getFolderName(_hSelf);
1116  	if (dirPath != TEXT(""))
1117  	{
1118  		recursiveAddFilesFrom(dirPath.c_str(), hTreeItem);
1119  		_treeView.expand(hTreeItem);
1120  		setWorkSpaceDirty(true);
1121  		_selDirOfFilesFromDirDlg = dirPath;
1122  	}
1123  }
1124  intptr_t CALLBACK FileRelocalizerDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM) 
1125  {
1126  	switch (Message)
1127  	{
1128  		case WM_INITDIALOG:
1129  		{
1130  			::SetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, _fullFilePath.c_str());
1131  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
1132  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
1133  			return TRUE;
1134  		}
1135  		case WM_ERASEBKGND:
1136  		{
1137  			if (NppDarkMode::isEnabled())
1138  			{
1139  				RECT rect{};
1140  				GetClientRect(_hSelf, &rect);
1141  				::FillRect(reinterpret_cast<HDC>(wParam), &rect, NppDarkMode::getDarkerBackgroundBrush());
1142  				return TRUE;
1143  			}
1144  			break;
1145  		}
1146  		case WM_CTLCOLOREDIT:
1147  		{
1148  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1149  		}
1150  		case WM_PRINTCLIENT:
1151  		{
1152  			if (NppDarkMode::isEnabled())
1153  			{
1154  				return TRUE;
1155  			}
1156  			break;
1157  		}
1158  		case WM_COMMAND:
1159  		{
1160  			switch (wParam)
1161  			{
1162  				case IDOK :
1163  				{
1164  					TCHAR textBuf[MAX_PATH] = { '\0' };
1165  					::GetDlgItemText(_hSelf, IDC_EDIT_FILEFULLPATHNAME, textBuf, MAX_PATH);
1166  					_fullFilePath = textBuf;
1167  					::EndDialog(_hSelf, 0);
1168  				}
1169  				return TRUE;
1170  				case IDCANCEL :
1171  					::EndDialog(_hSelf, -1);
1172  				return TRUE;
1173  				default:
1174  					return FALSE;
1175  			}
1176  		}
1177  		default :
1178  			return FALSE;
1179  	}
1180  	return FALSE;
1181  }
1182  int FileRelocalizerDlg::doDialog(const TCHAR *fn, bool isRTL)
1183  {
1184  	_fullFilePath = fn;
1185  	if (isRTL)
1186  	{
1187  		DLGTEMPLATE *pMyDlgTemplate = NULL;
1188  		HGLOBAL hMyDlgTemplate = makeRTLResource(IDD_FILERELOCALIZER_DIALOG, &pMyDlgTemplate);
1189  		int result = static_cast<int32_t>(::DialogBoxIndirectParam(_hInst, pMyDlgTemplate, _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1190  		::GlobalFree(hMyDlgTemplate);
1191  		return result;
1192  	}
1193  	return static_cast<int32_t>(::DialogBoxParam(_hInst, MAKEINTRESOURCE(IDD_FILERELOCALIZER_DIALOG), _hParent, dlgProc, reinterpret_cast<LPARAM>(this)));
1194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rolx.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ProjectPanel.cpp</div>
                <div class="column column_space"><pre><code>376    }
377    return Roles;
378  }
379  void PlotRoles(const PUNGraph Graph, const TIntIntH& Roles) {
380    TStr RoleToColor[10] = { "white", "black", "red", "green", "blue",
381        "yellow", "gold", "cyan", "magenta", "brown" };
</pre></code></div>
                <div class="column column_space"><pre><code>408  	}
409  	return true;
410  }
411  generic_string ProjectPanel::getRelativePath(const generic_string & filePath, const TCHAR *workSpaceFileName)
412  {
413  	TCHAR wsfn[MAX_PATH] = { '\0' };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    