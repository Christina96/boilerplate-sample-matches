
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.458333333333332%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.cpp</h3>
            <pre><code>1  const int TB1Def::B1Bits=8;
2  const int TB1Def::MxP2Exp=TB1Def::B1Bits-1;
3  const TB1Def::TB1 TB1Def::MxB1=0xFF;
4  TB1Def::TB1Def(){
5    B1P2T=new TB1[B1Bits+1]; B1P2T[0]=1;
6    for (int BitN=1; BitN<B1Bits; BitN++){B1P2T[BitN]=TB1(2*B1P2T[BitN-1]);}
7    B1P2T[B1Bits]=0;
8    B1BitsT=new int[MxB1+1];
9    for (int B1N=0; B1N<MxB1+1; B1N++){
10      TB1 B1=(TB1)B1N; B1BitsT[B1]=0;
11      for (int BitN=0; BitN<B1Bits; BitN++){B1BitsT[B1N]+=B1%2; B1/=(TB1)2;}}
12  }
13  int TB1Def::GetB1Bits(const TB1& B1){
14    return B1Def.B1BitsT[B1];
15  }
16  uint TB1Def::GetP2(const int& P2Exp){
17    IAssert((0<=P2Exp)&&(P2Exp<=TB1Def::MxP2Exp));
18    return B1Def.B1P2T[P2Exp];
19  }
20  int TB1Def::GetL2(const uchar& Val){
21    int L2=0;
22    while ((L2<TB1Def::MxP2Exp)&&(Val>=B1Def.B1P2T[L2])){L2++;}
23    return L2-1;
24  }
25  bool TB1Def::GetBit(const int& BitN, const uchar& Val){
26    IAssert((0<=BitN)&&(BitN<=TB1Def::MxP2Exp));
27    return (Val & B1Def.B1P2T[BitN])!=0;
28  }
29  const TB1Def TB1Def::B1Def;
30  const int TB2Def::B2Bits=16;
31  const int TB2Def::MxP2Exp=TB2Def::B2Bits-1;
32  const TB2Def::TB2 TB2Def::MxB2=0xFFFF;
33  TB2Def::TB2Def(){
34    B2P2T=new TB2[B2Bits+1]; B2P2T[0]=1;
35    for (int BitN=1; BitN<B2Bits; BitN++){B2P2T[BitN]=TB2(2*B2P2T[BitN-1]);}
36    B2P2T[B2Bits]=0;
37  }
38  int TB2Def::GetB2Bits(const TB2& B2){
39    return
40     TB1Def::B1Def.B1BitsT[(B2>>(0*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1]+
41     TB1Def::B1Def.B1BitsT[(B2>>(1*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1];
42  }
43  uint TB2Def::GetP2(const int& P2Exp){
44    IAssert((0<=P2Exp)&&(P2Exp<=TB2Def::MxP2Exp));
45    return B2Def.B2P2T[P2Exp];
46  }
47  int TB2Def::GetL2(const TB2& Val){
48    int L2=0;
49    while ((L2<TB2Def::MxP2Exp)&&(Val>=B2Def.B2P2T[L2])){L2++;}
50    return L2-1;
51  }
52  const TB2Def TB2Def::B2Def;
53  const int TB4Def::B4Bits=32;
54  const int TB4Def::MxP2Exp=TB4Def::B4Bits-1;
55  const TB4Def::TB4 TB4Def::MxB4=0xFFFFFFFF;
56  TB4Def::TB4Def(){
57    B4P2T=new TB4[B4Bits+1]; B4P2T[0]=1;
58    for (int BitN=1; BitN<B4Bits; BitN++){B4P2T[BitN]=TB4(2*B4P2T[BitN-1]);}
59    B4P2T[B4Bits]=0;
60  }
61  int TB4Def::GetB4Bits(const TB4& B4){
62    return
63     TB1Def::B1Def.B1BitsT[(B4>>(0*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1]+
64     TB1Def::B1Def.B1BitsT[(B4>>(1*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1]+
65     TB1Def::B1Def.B1BitsT[(B4>>(2*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1]+
66     TB1Def::B1Def.B1BitsT[(B4>>(3*TB1Def::B1Def.B1Bits))&TB1Def::B1Def.MxB1];
67  }
68  uint TB4Def::GetP2(const int& P2Exp){
69    IAssert((0<=P2Exp)&&(P2Exp<=TB4Def::MxP2Exp));
70    return B4Def.B4P2T[P2Exp];
71  }
72  int TB4Def::GetL2(const uint& Val){
73    int L2=0;
74    while ((L2<TB4Def::MxP2Exp)&&(Val>=B4Def.B4P2T[L2])){L2++;}
75    return L2-1;
76  }
77  const TB4Def TB4Def::B4Def;
78  const int TFSet::B4s=4;
79  const int TFSet::Bits=TFSet::B4s*TB4Def::B4Bits;
80  TFSet::TFSet(
81   const int& FlagN1, const int& FlagN2, const int& FlagN3,
82   const int& FlagN4, const int& FlagN5, const int& FlagN6,
83   const int& FlagN7, const int& FlagN8, const int& FlagN9):
84    B4V(4, 4){
85    if (FlagN1!=-1){Incl(FlagN1);}
86    if (FlagN2!=-1){Incl(FlagN2);}
87    if (FlagN3!=-1){Incl(FlagN3);}
88    if (FlagN4!=-1){Incl(FlagN4);}
89    if (FlagN5!=-1){Incl(FlagN5);}
90    if (FlagN6!=-1){Incl(FlagN6);}
91    if (FlagN7!=-1){Incl(FlagN7);}
92    if (FlagN8!=-1){Incl(FlagN8);}
93    if (FlagN9!=-1){Incl(FlagN9);}
94  }
95  const TFSet TFSet::EmptyFSet;
96  const int TB8Set::Bits=8;
97  TStr TB8Set::GetStr() const {
98    TChA ChA;
99    for (int BitN=0; BitN<Bits; BitN++){
100      if (In(BitN)){ChA+='1';} else {ChA+='0';}}
101    return ChA;
102  }
103  void TB8Set::Wr(){
104    printf("[");
105    for (int BitN=0; BitN<Bits; BitN++){printf("%d", GetBit(BitN));}
106    printf("]\n");
107  }
108  const int TB32Set::Bits=32;
<span onclick='openModal()' class='match'>109  TStr TB32Set::GetStr() const {
110    TChA ChA;
111    for (int BitN=0; BitN<Bits; BitN++){
112      if (In(BitN)){ChA+='1';} else {ChA+='0';}}
</span>113    return ChA;
114  }
115  void TB32Set::Wr(){
116    printf("[");
117    for (int BitN=0; BitN<Bits; BitN++){printf("%d", GetBit(BitN));}
118    printf("]\n");
119  }
120  TBSet::TBSet(const TBSet& BSet):
121    B4s(0), Bits(0), LastB4Mask(0), B4T(NULL){
122    Gen(BSet.Bits);
123    for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=BSet.B4T[B4N];}
124  }
125  TBSet& TBSet::operator=(const TBSet& BSet){
126    if (this!=&BSet){
127      if (Bits!=BSet.Bits){Gen(BSet.Bits);}
128      for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=BSet.B4T[B4N];}}
129    return *this;
130  }
131  bool TBSet::operator==(const TBSet& BSet) const {
132    if (Bits!=BSet.Bits){return false;}
133    for (int B4N=0; B4N<B4s-1; B4N++){if (B4T[B4N]!=BSet.B4T[B4N]){return false;}}
134    return (B4s>0)&&((B4T[B4s-1]&LastB4Mask)==(BSet.B4T[B4s-1]&BSet.LastB4Mask));
135  }
136  void TBSet::Gen(const int& _Bits){
137    if (B4T!=NULL){delete[] B4T;}
138    Bits=_Bits;
139    B4T=new TB4Def::TB4[B4s=(Bits-1)/TB4Def::B4Def.B4Bits+1];
140    LastB4Mask=TB4Def::B4Def.MxB4;
141    for (int BitN=Bits; BitN<B4s*TB4Def::B4Def.B4Bits; BitN++){
142      LastB4Mask&= ~TB4Def::B4Def.B4P2T[BitN%TB4Def::B4Def.B4Bits];}
143    Clr();
144  }
145  void TBSet::Clr(){
146    for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=0;}}
147  void TBSet::Fill(){
148    for (int B4N=0; B4N<B4s; B4N++){B4T[B4N]=TB4Def::B4Def.MxB4;}}
149  int TBSet::Get1s(){
150    int Ones=0; SetLastB4();
151    for (int B4N=0; B4N<B4s; B4N++){Ones += TB4Def::B4Def.GetB4Bits(B4T[B4N]);}
152    return Ones;
153  }
154  void TBSet::Wr(){
155    for (int BitN=0; BitN<Bits; BitN++){printf("%d", GetBit(BitN));}
156  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</h3>
            <pre><code>1  #ifndef yanglib_agmattr1_h
2  #define yanglib_agmattr1_h
3  #include "Snap.h"
4  class TCesnaUtil {
5  public:
6  template<class PGraph>
7  static double GetConductance(const PGraph& Graph, const TIntSet& CmtyS, const int Edges) {
8    const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
9    int Edges2;
10    if (GraphType) { Edges2 = Edges >= 0 ? Edges : Graph->GetEdges(); }
11    else { Edges2 = Edges >= 0 ? 2 * Edges : Graph->GetEdges(); }
12    int Vol = 0,  Cut = 0; 
13    double Phi = 0.0;
14    for (int i = 0; i < CmtyS.Len(); i++) {
15      if (! Graph->IsNode(CmtyS[i])) { continue; }
16      typename PGraph::TObj::TNodeI  NI = Graph->GetNI(CmtyS[i]);
17      for (int e = 0; e < NI.GetOutDeg(); e++) {
18        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
19      }
20      Vol += NI.GetOutDeg();
21    }
22    if (Vol != Edges2) {
23      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
24      else if (Vol == 0) { Phi = 0.0; }
25      else { Phi = Cut / double(Vol); }
26    } else {
27      if (Vol == Edges2) { Phi = 1.0; }
28    }
29    return Phi;
30  }
31  template<class PGraph>
32    static void GenHoldOutPairs(const PGraph& G, TVec<TIntSet>& HoldOutSet, double HOFrac, TRnd& Rnd)  {
33      TIntPrV EdgeV(G->GetEdges(), 0);
34      for (typename PGraph::TObj::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
35        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
36      }
37      EdgeV.Shuffle(Rnd);
38      const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
39      HoldOutSet.Gen(G->GetNodes());
40      int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
41      if (GraphType) { HOTotal *= 2;}
42      int HOCnt = 0;
43      int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
44      printf("holding out %d edges...\n", HOEdges);
45      for (int he = 0; he < (int) HOEdges; he++) {
46        HoldOutSet[EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
47        if (! GraphType) { HoldOutSet[EdgeV[he].Val2].AddKey(EdgeV[he].Val1); }
48        HOCnt++;
49      }
50      printf("%d Edges hold out\n", HOCnt);
51      while(HOCnt++ < HOTotal) {
52        int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
53        int DstNID = Rnd.GetUniDevInt(G->GetNodes());
54        if (SrcNID == DstNID) { continue; }
55        HoldOutSet[SrcNID].AddKey(DstNID);
56        if (! GraphType) { HoldOutSet[DstNID].AddKey(SrcNID); }
57      }
58    }
59  template<class PGraph>
60    static void GetNbhCom(const PGraph& Graph, const int NID, TIntSet& NBCmtyS) {
61      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NID);
62      NBCmtyS.Gen(NI.GetDeg());
63      NBCmtyS.AddKey(NID);
64      for (int e = 0; e < NI.GetDeg(); e++) {
65        NBCmtyS.AddKey(NI.GetNbrNId(e));
66      }
67    }
68  template<class PGraph>
69    static void GetNIdPhiV(const PGraph& G, TFltIntPrV& NIdPhiV) {
70      NIdPhiV.Gen(G->GetNodes(), 0);
71      const int Edges = G->GetEdges();
72      TExeTm RunTm;
73      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
74        TIntSet NBCmty(NI.GetDeg() + 1);
75        double Phi;
76        if (NI.GetDeg() < 5) { 
77          Phi = 1.0; 
78        } else {
79          TCesnaUtil::GetNbhCom<PGraph>(G, NI.GetId(), NBCmty);
80          Phi = TCesnaUtil::GetConductance(G, NBCmty, Edges);
81        }
82        NIdPhiV.Add(TFltIntPr(Phi, NI.GetId()));
83      }
84      printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
85      fflush(stdout);
86    }
87    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& NodeNameH, const TSsFmt Sep = ssfTabSep) {
88      NIDAttrH.Clr();
89      NIDAttrH.Gen(NIDV.Len());
90      printf("nodes in the graph:%d\n", NIDV.Len());
91      for (int u = 0; u < NIDV.Len(); u++) { NIDAttrH.AddDat(NIDV[u]).Gen(0, 0); }
92      TSsParser Ss(InFNm, ssfTabSep);
93      while (Ss.Next()) {
94        TStr NodeName = Ss.GetFld(0);
95        TInt NID = NodeName.GetInt();
96        if (NodeNameH.Len() > 0 && ! NodeNameH.IsKey(NodeName)) { continue; }
97        if (NodeNameH.Len() > 0) { 
98          IAssertR(NodeNameH.IsKey(NodeName), TStr::Fmt("NodeName:%s", NodeName.CStr())); 
99          NID = NodeNameH.GetKeyId(NodeName);
100        }
101        if (! NIDAttrH.IsKey(NID)) { 
102          continue; } 
103        IAssertR(! NIDAttrH.GetDat(NID).IsIn(Ss.GetInt(1)), TStr::Fmt("NIdx:%d NID:%s, K:%d", NID.Val, NodeName.CStr(), Ss.GetInt(1)));
104        NIDAttrH.GetDat(NID).Add(Ss.GetInt(1));
105      }
106      printf("%s nodes, %s lines read \n",  TUInt64::GetStr(NIDAttrH.Len()).CStr(), TUInt64::GetStr(Ss.GetLineNo()).CStr());
107    }
108    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH) {
109      TStrHash<TInt> TmpH;
110      LoadNIDAttrHFromNIDKH(NIDV, InFNm, NIDAttrH, TmpH);
111    }
112    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
113      FILE* F = fopen(FNm.CStr(), "wt");
114      for (int u = 0; u < NIDAttrH.Len(); u++) {
115        int NID = NIDAttrH.GetKey(u);
116        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
117        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
118          int KID = NIDAttrH[u][k];
119          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
120          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
121        }
122      }
123      fclose(F);
124    }
125    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
126      TStrHash<TInt> TmpH;
127      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
128    }
129    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH) {
130      TStrHash<TInt> TmpH1, TmpH2;
131      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
132    }
133    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
134      FILE* F = fopen(FNm.CStr(), "wt");
135      for (int u = 0; u < NIDAttrH.Len(); u++) {
136        int NID = NIDAttrH.GetKey(u);
137        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
138        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
139          int KID = NIDAttrH[u][k];
140          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
141          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
142        }
143      }
144      fclose(F);
145    }
146    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
147      TStrHash<TInt> TmpH;
148      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
149    }
150    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH) {
151      TStrHash<TInt> TmpH1, TmpH2;
152      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
153    }
154    static int GetAttrs(const THash<TInt, TIntV>& NIDAttrH) {
155      int Attrs = 0;
156      for (int u = 0; u < NIDAttrH.Len(); u++) {
157        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
158          if (NIDAttrH[u][k] >= Attrs) { Attrs = NIDAttrH[u][k] + 1; }
159        }
160      }
161      return Attrs;
162    }
163    static void DumpNIDAttrHToMetis(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TIntV& NIDV) {
164      int AttrCnt = 0;
165      for (int u = 1; u < NIDV.Len(); u++) {
166        if (! NIDAttrH.IsKey(NIDV[u])) { continue; }
167        AttrCnt += NIDAttrH.GetDat(NIDV[u]).Len();
168      }
169      IAssert (NIDV[0] == -1);
170      FILE* F = fopen(FNm.CStr(), "wt");
171      fprintf(F, "%d %d\n", NIDV.Len() - 1, AttrCnt);
172      int TmpCnt = 0;
173      for (int u = 1; u < NIDV.Len(); u++) {
174        if (NIDAttrH.IsKey(NIDV[u])) {  
175          for (int k = 0; k < NIDAttrH.GetDat(NIDV[u]).Len(); k++) {
176            if (k > 0) { fprintf(F, " "); }
177            fprintf(F, "%d", NIDAttrH.GetDat(NIDV[u])[k].Val + 1);
178            TmpCnt++;
179          }
180        }
181        fprintf(F, "\n");
182      }
183      fclose(F);
184      IAssert(AttrCnt == TmpCnt);
185    }
186    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const TIntStrH& OldNameH, TIntStrH& NewNameH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
187      TIntH KIDCntH;
188      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
189        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
190          KIDCntH.AddDat(OldNIDAttrH[u][k])++;
191        }
192      }
193      KIDCntH.SortByDat(false);
194      TIntSet SelectedK(KIDCntH.Len());
195      for (int c = 0; c < KIDCntH.Len(); c++) {
196        double Frac = (double) KIDCntH[c].Val / (double) OldNIDAttrH.Len();
197        if (KIDCntH[c].Val < MinCnt) { continue; }
198        if (Frac > MaxFrac || Frac < MinFrac) { continue; }
199        SelectedK.AddKey(KIDCntH.GetKey(c));
200      }
201      printf("%d attributes selected from %d\n", SelectedK.Len(), KIDCntH.Len());
202      NewNIDAttrH.Gen(OldNIDAttrH.Len());
203      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
204        int NID = OldNIDAttrH.GetKey(u);
205        TIntV& AttrV = NewNIDAttrH.AddDat(NID);
206        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
207          if (! SelectedK.IsKey(OldNIDAttrH[u][k])) { continue; }
208          AttrV.Add(SelectedK.GetKeyId(OldNIDAttrH[u][k]));
209        }
210      }
211      if (! OldNameH.Empty()) {
212        NewNameH.Gen(SelectedK.Len());
213        for (int k = 0; k < SelectedK.Len(); k++) {
214          int OldKID = SelectedK.GetKey(k);
215          if (OldNameH.IsKey(OldKID)) {
216            NewNameH.AddDat(k, OldNameH.GetDat(OldKID));
217          }
218        }
219        printf("%d attributes names copied\n", NewNameH.Len());
220      }
221    }
222    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
223      TIntStrH TmpH1, TmpH2;
224      FilterLowEntropy(OldNIDAttrH, NewNIDAttrH, TmpH1, TmpH2, MinFrac, MaxFrac, MinCnt);
225    }
226  };
227  class TCesna { 
228  private:
229    PUNGraph G; 
230    TVec<TIntSet> X; 
231    TVec<TIntFltH> F; 
232    TVec<TFltV> W; 
233    TInt Attrs; 
234    TRnd Rnd; 
235    TIntSet NIDToIdx; 
236    TFlt RegCoef; 
237    TFltV SumFV; 
238    TInt NumComs; 
239    TVec<TIntSet> HOVIDSV; 
240    TVec<TIntSet> HOKIDSV; 
241  public:
242    TFlt MinVal; 
243    TFlt MaxVal; 
244    TFlt MinValW; 
245    TFlt MaxValW; 
246    TFlt NegWgt; 
247    TFlt LassoCoef; 
248    TFlt WeightAttr; 
249    TFlt PNoCom; 
250    TBool DoParallel; 
251    TCesna() { G = TUNGraph::New(10, -1); }
252    TCesna(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
253      MinVal(0.0), MaxVal(10.0), MinValW(-10.0), MaxValW(10.0), NegWgt(1.0), LassoCoef(1.0), WeightAttr(1.0) { SetGraph(GraphPt, NIDAttrH); NeighborComInit(InitComs); }
254    void Save(TSOut& SOut) {
255      G->Save(SOut);
256      X.Save(SOut);
257      F.Save(SOut);
258      W.Save(SOut);
259      Attrs.Save(SOut);
260      NIDToIdx.Save(SOut);
261      RegCoef.Save(SOut);
262      LassoCoef.Save(SOut);
263      SumFV.Save(SOut);
264      NumComs.Save(SOut);
265      HOVIDSV.Save(SOut);
266      HOKIDSV.Save(SOut);
267      MinVal.Save(SOut);
268      MaxVal.Save(SOut);
269      MinValW.Save(SOut);
270      MaxValW.Save(SOut);
271      NegWgt.Save(SOut);
272      PNoCom.Save(SOut);
273    }
274    void Load(TSIn& SIn, const int& RndSeed = 0) {
275      G->Load(SIn);
276      X.Load(SIn);
277      F.Load(SIn);
278      W.Load(SIn);
279      Attrs.Load(SIn);
280      NIDToIdx.Load(SIn);
281      RegCoef.Load(SIn);
282      LassoCoef.Load(SIn);
283      SumFV.Load(SIn);
284      NumComs.Load(SIn);
285      HOVIDSV.Load(SIn);
286      HOKIDSV.Load(SIn);
287      MinVal.Load(SIn);
288      MaxVal.Load(SIn);
289      MinValW.Load(SIn);
290      MaxValW.Load(SIn);
291      NegWgt.Load(SIn);
292      PNoCom.Load(SIn);
293    }
294    void SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH);
295    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
296    double GetRegCoef() { return RegCoef; }
297    void SetWeightAttr(const double _WeightAttr) { IAssert (_WeightAttr <= 1.0 && _WeightAttr >= 0.0); WeightAttr = _WeightAttr; }
298    double GetWeightAttr() { return WeightAttr; }
299    void SetLassoCoef(const double _LassoCoef) { LassoCoef = _LassoCoef; }
300    int GetAttrs() { return Attrs; }
301    double GetComFromNID(const int& NID, const int& CID) {
302      int NIdx = NIDToIdx.GetKeyId(NID);
303      if (F[NIdx].IsKey(CID)) {
304        return F[NIdx].GetDat(CID);
305      } else {
306        return 0.0;
307      }
308    }
309    double GetLassoCoef() { return LassoCoef; }
310    void InitW() { 
311      W.Gen(Attrs);
312      for (int k = 0; k < Attrs; k++) {
313        W[k].Gen(NumComs + 1);
314      }
315    }
316    void SetAttrHoldOut(const int NID, const int KID) {
317      int NIdx = NIDToIdx.GetKeyId(NID);
318      HOKIDSV[NIdx].AddKey(KID);
319    }
320    void SetAttrHoldOutForOneNode(const int NID) {
321      for (int k = 0; k < Attrs; k++) {
322        SetAttrHoldOut(NID, k);
323      }
324    }
325    void GetW(TVec<TFltV>& _W) { _W = W; }
326    void SetW(TVec<TFltV>& _W) { W = _W; }
327    void RandomInit(const int InitComs);
328    void NeighborComInit(const int InitComs);
329    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
330    int GetNumComs() { return NumComs; }
331    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
332    double Likelihood(const bool DoParallel = false);
333    double LikelihoodForRow(const int UID);
334    double LikelihoodForRow(const int UID, const TIntFltH& FU);
335    double LikelihoodAttrKForRow(const int UID, const int K) { return LikelihoodAttrKForRow(UID, K, F[UID]); }
336    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU) { return LikelihoodAttrKForRow(UID, K, FU, W[K]); }
337    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK);
338    double LikelihoodForWK(const int K, const TFltV& WK) {
339      double L = 0.0;
340      for (int u = 0; u < F.Len(); u++) {
341        if (HOKIDSV[u].IsKey(K)) { continue; }
342        L += LikelihoodAttrKForRow(u, K, F[u], WK);
343      }
344      for (int c = 0; c < WK.Len() - 1; c++) {
345        L -= LassoCoef * fabs(WK[c]);
346      } 
347      return L;
348    }
349    double LikelihoodForWK(const int K) { return LikelihoodForWK(K, W[K]); }
350    double LikelihoodAttr() {
351      double L = 0.0;
352      for (int k = 0; k < Attrs; k++) {
353        for (int u = 0; u < F.Len(); u++) {
354          if (HOKIDSV[u].IsKey(k)) { continue; }
355          L += LikelihoodAttrKForRow(u, k, F[u], W[k]);
356        }
357      }
358      return L;
359    }
360    double LikelihoodGraph() {
361      double L = Likelihood();
362      if (RegCoef > 0.0) { 
363        for (int u = 0; u < F.Len(); u++) {
364          L += RegCoef * Sum(F[u]);
365        }
366      }
367      if (RegCoef < 0.0) { 
368        for (int u = 0; u < F.Len(); u++) {
369          L -= RegCoef * Norm2(F[u]);
370        }
371      }
372      return L - WeightAttr * LikelihoodAttr();
373    }
374    void GenHoldOutAttr(const double HOFrac, TVec<TIntSet>& HOSetV) {
375      HOSetV.Gen(F.Len());
376      int HoldOutCnt = (int) ceil(HOFrac * G->GetNodes() * Attrs);
377      TIntPrSet NIDKIDSet(HoldOutCnt);
378      int Cnt = 0;
379      for (int h = 0; h < 10 * HoldOutCnt; h++) {
380        int UID = Rnd.GetUniDevInt(F.Len());
381        int KID = Rnd.GetUniDevInt(Attrs);
382        if (! NIDKIDSet.IsKey(TIntPr(UID, KID))) { 
383          NIDKIDSet.AddKey(TIntPr(UID, KID)); 
384          HOSetV[UID].AddKey(KID);
385          Cnt++;
386        }
387        if (Cnt >= HoldOutCnt) { break; }
388      }
389      printf("%d hold out pairs generated for attributes\n", Cnt);
390    }
391    void SetHoldOut(const double HOFrac) { 
392      TVec<TIntSet> HoldOut; 
393      TCesnaUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); 
394      GenHoldOutAttr(HOFrac, HOKIDSV);
395      HOVIDSV = HoldOut; 
396    }
397    void GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
398    void GradientForWK(TFltV& GradV, const int K) {
399      GradV.Gen(NumComs + 1);
400      for (int u = 0; u < F.Len(); u++) {
401        if (HOKIDSV[u].IsKey(K)) { continue; }
402        double Pred = PredictAttrK(u, K);
403        for (TIntFltH::TIter CI = F[u].BegI(); CI < F[u].EndI(); CI++) { 
404          GradV[CI.GetKey()] += (GetAttr(u, K) - Pred) * GetCom(u, CI.GetKey());
405        }
406        GradV[NumComs] += (GetAttr(u, K) - Pred);
407      }
408      for (int c = 0; c < GradV.Len() - 1; c++) {
409        GradV[c] -= LassoCoef * TMath::Sign(GetW(c, K));
410      }
411    }
412    void GetCmtyVV(TVec<TIntV>& CmtyVV);
413    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz = 3);
414    void GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3) {
415      TVec<TFltV> TmpV;
416      GetCmtyVV(CmtyVV, TmpV, Thres, MinSz); 
417    }
418    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck) {
419      GetCmtyVV(CmtyVV, Wck, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
420    }
421    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV);
422    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
423    int FindComs(TIntV& ComsV, const bool UseBIC = false, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1);
424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
425    void DisplayAttrs(const int TopK, const TStrHash<TInt>& NodeNameH) {
426      for (int u = 0; u < X.Len(); u++) {
427        if (NodeNameH.Len() > 0) {
428          printf("NID: %s\t Attrs: ", NodeNameH.GetKey(NIDToIdx[u]));
429        } else {
430          printf("NID: %d\t Attrs: ", NIDToIdx[u].Val);
431        }
432        for (int k = 0; k < X[u].Len(); k++) {
433          printf("%d, ", X[u][k].Val);
434        }
435        printf("\n");
436        if (u >= TopK) { break; }
437      }
438    }
439    double LikelihoodHoldOut();
440    double GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
441    double GetStepSizeByLineSearchForWK(const int K, const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10) {
442      double StepSize = 1.0;
443      double InitLikelihood = LikelihoodForWK(K);
444      TFltV NewVarV(DeltaV.Len());
445      IAssert(DeltaV.Len() == NumComs + 1);
446      for(int iter = 0; iter < MaxIter; iter++) {
447        for (int c = 0; c < DeltaV.Len(); c++){
448          double NewVal = W[K][c] + StepSize * DeltaV[c];
449          if (NewVal < MinValW) { NewVal = MinValW; }
450          if (NewVal > MaxValW) { NewVal = MaxValW; }
451          NewVarV[c] = NewVal;
452        }
453        if (LikelihoodForWK(K, NewVarV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
454          StepSize *= Beta;
455        } else {
456          break;
457        }
458        if (iter == MaxIter - 1) { 
459          StepSize = 0.0;
460          break;
461        }
462      }
463      return StepSize;
464    }
465    int GetPositiveW() {
466      int PosCnt = 0;
<span onclick='openModal()' class='match'>467      for (int c = 0; c < NumComs; c++) {
468        for (int k = 0; k < Attrs; k++) {
469          if (GetW(c, k) > 0.0) { PosCnt++; }
</span>470        }
471      }
472      return PosCnt;
473    }
474    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
475    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
476    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
477      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
478      if (ChunkSize == 0) { ChunkSize = 1; }
479      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
480    }
481    double inline GetCom(const int& NID, const int& CID) {
482      if (F[NID].IsKey(CID)) {
483        return F[NID].GetDat(CID);
484      } else {
485        return 0.0;
486      }
487    }
488    double inline GetAttr(const int& NID, const int& K) {
489      if (X[NID].IsKey(K)) {
490        return 1.0;
491      } else {
492        return 0.0;
493      }
494    }
495    void inline AddCom(const int& NID, const int& CID, const double& Val) {
496      if (F[NID].IsKey(CID)) {
497        SumFV[CID] -= F[NID].GetDat(CID);
498      }
499      F[NID].AddDat(CID) = Val;
500      SumFV[CID] += Val;
501    }
502    void inline DelCom(const int& NID, const int& CID) {
503      if (F[NID].IsKey(CID)) {
504        SumFV[CID] -= F[NID].GetDat(CID);
505        F[NID].DelKey(CID);
506      }
507    }
508    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
509      double DP = 0;
510      if (UV.Len() > VV.Len()) {
511        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
512          if (VV.IsKey(HI.GetKey())) { 
513            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
514          }
515        }
516      } else {
517        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
518          if (UV.IsKey(HI.GetKey())) { 
519            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
520          }
521        }
522      }
523      return DP;
524    }
525    double inline DotProduct(const int& UID, const int& VID) {
526      return DotProduct(F[UID], F[VID]);
527    }
528    double inline Prediction(const TIntFltH& FU, const TIntFltH& FV) {
529      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, FV);
530      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
531      return exp(- DP);
532    }
533    double inline PredictAttrK(const TIntFltH& FU, const TFltV& WK) {
534      double DP = 0.0;
535      for (TIntFltH::TIter FI = FU.BegI(); FI < FU.EndI(); FI++) {
536        DP += FI.GetDat() * WK[FI.GetKey()];
537      }
538      DP += WK.Last();
539      return Sigmoid(DP);
540    }
541    double inline PredictAttrK(const TIntFltH& FU, const int K) {
542      return PredictAttrK(FU, W[K]);
543    }
544    double inline PredictAttrK(const int UID, const int K) {
545      return PredictAttrK(F[UID], W[K]);
546    }
547    double inline GetW(const int CID, const int K) {
548      return W[K][CID];
549    }
550    double inline Prediction(const int& UID, const int& VID) {
551      return Prediction(F[UID], F[VID]);
552    }
553    double inline Sum(const TIntFltH& UV) {
554      double N = 0.0;
555      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
556        N += HI.GetDat();
557      }
558      return N;
559    }
560    double inline Norm2(const TIntFltH& UV) {
561      double N = 0.0;
562      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
563        N += HI.GetDat() * HI.GetDat();
564      }
565      return N;
566    }
567    double inline Sigmoid(const double X) {
568      return 1.0 / ( 1.0 + exp(-X));
569    }
570  };
571  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bits.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</div>
                </div>
                <div class="column column_space"><pre><code>109  TStr TB32Set::GetStr() const {
110    TChA ChA;
111    for (int BitN=0; BitN<Bits; BitN++){
112      if (In(BitN)){ChA+='1';} else {ChA+='0';}}
</pre></code></div>
                <div class="column column_space"><pre><code>467      for (int c = 0; c < NumComs; c++) {
468        for (int k = 0; k < Attrs; k++) {
469          if (GetW(c, k) > 0.0) { PosCnt++; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    