<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ConfigurableDomain.cpp &amp; BitParameterType.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ConfigurableDomain.cpp &amp; BitParameterType.cpp
      </h3>
<h1 align="center">
        5.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ConfigurableDomain.cpp (3.247632%)<th>BitParameterType.cpp (17.777779%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(102-117)<td><a href="#" name="0">(220-242)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(70-83)<td><a href="#" name="1">(197-211)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomain.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (c) 2011-2015, Intel Corporation
3  * All rights reserved.
4  *
5  * Redistribution and use in source and binary forms, with or without modification,
6  * are permitted provided that the following conditions are met:
7  *
8  * 1. Redistributions of source code must retain the above copyright notice, this
9  * list of conditions and the following disclaimer.
10  *
11  * 2. Redistributions in binary form must reproduce the above copyright notice,
12  * this list of conditions and the following disclaimer in the documentation and/or
13  * other materials provided with the distribution.
14  *
15  * 3. Neither the name of the copyright holder nor the names of its contributors
16  * may be used to endorse or promote products derived from this software without
17  * specific prior written permission.
18  *
19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
23  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
26  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29  */
30 #include "ConfigurableDomain.h"
31 #include "DomainConfiguration.h"
32 #include "ConfigurableElement.h"
33 #include "ConfigurationAccessContext.h"
34 #include "XmlDomainSerializingContext.h"
35 #include "XmlDomainImportContext.h"
36 #include "XmlDomainExportContext.h"
37 #include "Utility.h"
38 #include "AlwaysAssert.hpp"
39 #include &lt;cassert&gt;
40 #define base CElement
41 using std::string;
42 CConfigurableDomain::CConfigurableDomain(const string &amp;strName) : base(strName)
43 {
44 }
45 CConfigurableDomain::~CConfigurableDomain()
46 {
47     ConfigurableElementListIterator it;
48     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
49         CConfigurableElement *pConfigurableElement = *it;
50         pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
51     }
52     ConfigurableElementToSyncerSetMapIterator mapIt;
53     for (mapIt = _configurableElementToSyncerSetMap.begin();
54          mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
55 <a name="1"></a>
56         delete mapIt-&gt;second;
57     }
58 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
59 string CConfigurableDomain::getKind() const
60 {
61     return "ConfigurableDomain";
62 }
63 bool CConfigurableDomain::childrenAreDynamic() const
64 {
65     return true;
66 }
67 string CConfigurableDomain::logValue(utility::ErrorContext &amp; /*ctx*/) const</b></font>
68 {
69     return string("{") +
70            "Sequence aware: " + (_bSequenceAware ? "yes" : "no") +
71            ", Last applied configuration: " +
72            (_pLastAppliedConfiguration ? _pLastAppliedConfiguration-&gt;getName() : "&lt;none&gt;") +
73            "}";
74 }
75 void CConfigurableDomain::setSequenceAwareness(bool bSequenceAware)
76 {
77     if (_bSequenceAware != bSequenceAware) {
78 <a name="0"></a>
79         _bSequenceAware = bSequenceAware;
80     }
81 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
82 bool CConfigurableDomain::getSequenceAwareness() const
83 {
84     return _bSequenceAware;
85 }
86 void CConfigurableDomain::toXml(CXmlElement &amp;xmlElement,
87                                 CXmlSerializingContext &amp;serializingContext) const
88 {
89     base::toXml(xmlElement, serializingContext);
90     xmlElement.setAttribute("SequenceAware", _bSequenceAware);
91 }</b></font>
92 void CConfigurableDomain::childrenToXml(CXmlElement &amp;xmlElement,
93                                         CXmlSerializingContext &amp;serializingContext) const
94 {
95     composeDomainConfigurations(xmlElement, serializingContext);
96     composeConfigurableElements(xmlElement);
97     composeSettings(xmlElement, static_cast&lt;CXmlDomainExportContext &amp;&gt;(serializingContext));
98 }
99 void CConfigurableDomain::composeDomainConfigurations(
100     CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const
101 {
102     CXmlElement xmlConfigurationsElement;
103     xmlElement.createChild(xmlConfigurationsElement, "Configurations");
104     base::childrenToXml(xmlConfigurationsElement, serializingContext);
105 }
106 void CConfigurableDomain::composeConfigurableElements(CXmlElement &amp;xmlElement) const
107 {
108     CXmlElement xmlConfigurableElementsElement;
109     xmlElement.createChild(xmlConfigurableElementsElement, "ConfigurableElements");
110     ConfigurableElementListIterator it;
111     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
112         const CConfigurableElement *pConfigurableElement = *it;
113         CXmlElement xmlChildConfigurableElement;
114         xmlConfigurableElementsElement.createChild(xmlChildConfigurableElement,
115                                                    "ConfigurableElement");
116         xmlChildConfigurableElement.setAttribute("Path", pConfigurableElement-&gt;getPath());
117     }
118 }
119 void CConfigurableDomain::composeSettings(CXmlElement &amp;xmlElement,
120                                           CXmlDomainExportContext &amp;context) const
121 {
122     if (!context.withSettings()) {
123         return;
124     }
125     CXmlElement xmlSettingsElement;
126     xmlElement.createChild(xmlSettingsElement, "Settings");
127     size_t uiNbConfigurations = getNbChildren();
128     size_t uiChildConfiguration;
129     for (uiChildConfiguration = 0; uiChildConfiguration &lt; uiNbConfigurations;
130          uiChildConfiguration++) {
131         const CDomainConfiguration *pDomainConfiguration =
132             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChildConfiguration));
133         CXmlElement xmlConfigurationSettingsElement;
134         xmlSettingsElement.createChild(xmlConfigurationSettingsElement,
135                                        pDomainConfiguration-&gt;getXmlElementName());
136         xmlConfigurationSettingsElement.setNameAttribute(pDomainConfiguration-&gt;getName());
137         pDomainConfiguration-&gt;composeSettings(xmlConfigurationSettingsElement, context);
138     }
139 }
140 bool CConfigurableDomain::fromXml(const CXmlElement &amp;xmlElement,
141                                   CXmlSerializingContext &amp;serializingContext)
142 {
143     CXmlDomainImportContext &amp;xmlDomainImportContext =
144         static_cast&lt;CXmlDomainImportContext &amp;&gt;(serializingContext);
145     xmlElement.getAttribute("SequenceAware", _bSequenceAware);
146     std::string name;
147     xmlElement.getAttribute("Name", name);
148     setName(name);
149     if (!parseDomainConfigurations(xmlElement, xmlDomainImportContext) ||
150         !parseConfigurableElements(xmlElement, xmlDomainImportContext) ||
151         !parseSettings(xmlElement, xmlDomainImportContext)) {
152         return false;
153     }
154     if (xmlDomainImportContext.autoValidationRequired()) {
155         autoValidateAll();
156     }
157     return true;
158 }
159 bool CConfigurableDomain::parseDomainConfigurations(const CXmlElement &amp;xmlElement,
160                                                     CXmlDomainImportContext &amp;serializingContext)
161 {
162     assert(_configurableElementList.empty());
163     CXmlElement xmlConfigurationsElement;
164     xmlElement.getChildElement("Configurations", xmlConfigurationsElement);
165     return base::fromXml(xmlConfigurationsElement, serializingContext);
166 }
167 bool CConfigurableDomain::parseConfigurableElements(const CXmlElement &amp;xmlElement,
168                                                     CXmlDomainImportContext &amp;serializingContext)
169 {
170     CSystemClass &amp;systemClass = serializingContext.getSystemClass();
171     CXmlElement xmlConfigurableElementsElement;
172     xmlElement.getChildElement("ConfigurableElements", xmlConfigurableElementsElement);
173     CXmlElement::CChildIterator it(xmlConfigurableElementsElement);
174     CXmlElement xmlConfigurableElementElement;
175     while (it.next(xmlConfigurableElementElement)) {
176         string strConfigurableElementPath;
177         xmlConfigurableElementElement.getAttribute("Path", strConfigurableElementPath);
178         CPathNavigator pathNavigator(strConfigurableElementPath);
179         string strError;
180         if (!pathNavigator.navigateThrough(systemClass.getName(), strError)) {
181             serializingContext.setError(
182                 "Could not find configurable element of path " + strConfigurableElementPath +
183                 " from ConfigurableDomain description " + getName() + " (" + strError + ")");
184             return false;
185         }
186         CConfigurableElement *pConfigurableElement =
187             static_cast&lt;CConfigurableElement *&gt;(systemClass.findDescendant(pathNavigator));
188         if (!pConfigurableElement) {
189             serializingContext.setError("Could not find configurable element of path " +
190                                         strConfigurableElementPath +
191                                         " from ConfigurableDomain description " + getName());
192             return false;
193         }
194         core::Results infos;
195         if (!addConfigurableElement(pConfigurableElement, nullptr, infos)) {
196             strError = utility::asString(infos);
197             serializingContext.setError(strError);
198             return false;
199         }
200     }
201     return true;
202 }
203 bool CConfigurableDomain::parseSettings(const CXmlElement &amp;xmlElement,
204                                         CXmlDomainImportContext &amp;serializingContext)
205 {
206     if (!serializingContext.withSettings()) {
207         return true;
208     }
209     CXmlElement xmlSettingsElement;
210     if (!xmlElement.getChildElement("Settings", xmlSettingsElement)) {
211         return true;
212     }
213     CXmlElement::CChildIterator it(xmlSettingsElement);
214     CXmlElement xmlConfigurationSettingsElement;
215     while (it.next(xmlConfigurationSettingsElement)) {
216         CDomainConfiguration *pDomainConfiguration = static_cast&lt;CDomainConfiguration *&gt;(
217             findChild(xmlConfigurationSettingsElement.getNameAttribute()));
218         if (!pDomainConfiguration) {
219             serializingContext.setError("Could not find domain configuration referred to by"
220                                         " configurable domain \"" +
221                                         getName() + "\".");
222             return false;
223         }
224         if (!pDomainConfiguration-&gt;parseSettings(xmlConfigurationSettingsElement,
225                                                  serializingContext)) {
226             return false;
227         }
228     }
229     return true;
230 }
231 bool CConfigurableDomain::addConfigurableElement(CConfigurableElement *pConfigurableElement,
232                                                  const CParameterBlackboard *pMainBlackboard,
233                                                  core::Results &amp;infos)
234 {
235     if (containsConfigurableElement(pConfigurableElement)) {
236         infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
237                         " already associated to configuration domain " + getName());
238         return false;
239     }
240     if (pConfigurableElement-&gt;belongsTo(this)) {
241         infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
242                         " already owned by configuration domain " + getName());
243         return false;
244     }
245     doAddConfigurableElement(pConfigurableElement, infos, pMainBlackboard);
246     return true;
247 }
248 bool CConfigurableDomain::removeConfigurableElement(CConfigurableElement *pConfigurableElement,
249                                                     string &amp;strError)
250 {
251     if (!containsConfigurableElement(pConfigurableElement)) {
252         strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
253                    " not associated to configuration domain " + getName();
254         return false;
255     }
256     doRemoveConfigurableElement(pConfigurableElement, true);
257     return true;
258 }
259 /**
260 * Blackboard Configuration and Base Offset retrieval.
261 *
262 * This method fetches the Blackboard associated to the ConfigurableElement
263 * given in parameter, for a specific Configuration. The ConfigurableElement
264 * must belong to the Domain. If a Blackboard is found, the base offset of
265 * the ConfigurableElement is returned as well. This base offset corresponds to
266 * the offset of the ancestor of the ConfigurableElement associated to the Configuration.
267 *
268 * @param[in] strConfiguration                           Name of the Configuration.
269 * @param[in] pCandidateDescendantConfigurableElement    Pointer to a CConfigurableElement that
270 *                                                       belongs to the Domain.
271 * @param[out] baseOffset                              The base offset of the CConfigurableElement.
272 * @param[out] bIsLastApplied                            Boolean indicating that the Configuration is
273 *                                                       the last one applied of the Domain.
274 * @param[out] strError                                  Error message
275 *
276 * return Pointer to the Blackboard of the Configuration.
277 */
278 CParameterBlackboard *CConfigurableDomain::findConfigurationBlackboard(
279     const string &amp;strConfiguration,
280     const CConfigurableElement *pCandidateDescendantConfigurableElement, size_t &amp;baseOffset,
281     bool &amp;bIsLastApplied, string &amp;strError) const
282 {
283     const CDomainConfiguration *pDomainConfiguration =
284         static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
285     if (!pDomainConfiguration) {
286         strError = "Domain configuration " + strConfiguration + " not found";
287         return nullptr;
288     }
289     ConfigurableElementListIterator it;
290     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
291         const CConfigurableElement *pAssociatedConfigurableElement = *it;
292         if ((pCandidateDescendantConfigurableElement == pAssociatedConfigurableElement) ||
293             (pCandidateDescendantConfigurableElement-&gt;isDescendantOf(
294                 pAssociatedConfigurableElement))) {
295             baseOffset = pAssociatedConfigurableElement-&gt;getOffset();
296             bIsLastApplied = (pDomainConfiguration == _pLastAppliedConfiguration);
297             return pDomainConfiguration-&gt;getBlackboard(pAssociatedConfigurableElement);
298         }
299     }
300     strError = "Element not associated to the Domain";
301     return nullptr;
302 }
303 bool CConfigurableDomain::split(CConfigurableElement *pConfigurableElement, core::Results &amp;infos)
304 {
305     if (!containsConfigurableElement(pConfigurableElement)) {
306         std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
307                                " not associated to configuration domain " + getName();
308         infos.push_back(strError);
309         return false;
310     }
311     size_t uiNbConfigurableElementChildren = pConfigurableElement-&gt;getNbChildren();
312     if (!uiNbConfigurableElementChildren) {
313         std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
314                                " has no children to split configurable domain to";
315         infos.push_back(strError);
316         return false;
317     }
318     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurableElementChildren; uiChild++) {
319         CConfigurableElement *pChildConfigurableElement =
320             static_cast&lt;CConfigurableElement *&gt;(pConfigurableElement-&gt;getChild(uiChild));
321         doAddConfigurableElement(pChildConfigurableElement, infos);
322     }
323     size_t uiNbConfigurations = getNbChildren();
324     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
325         CDomainConfiguration *pDomainConfiguration =
326             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
327         pDomainConfiguration-&gt;split(pConfigurableElement);
328     }
329     doRemoveConfigurableElement(pConfigurableElement, false);
330     return true;
331 }
332 const CDomainConfiguration *CConfigurableDomain::getPendingConfiguration() const
333 {
334     const CDomainConfiguration *pApplicableDomainConfiguration =
335         findApplicableDomainConfiguration();
336     if (pApplicableDomainConfiguration) {
337         if (!_pLastAppliedConfiguration ||
338             (_pLastAppliedConfiguration != pApplicableDomainConfiguration)) {
339             return pApplicableDomainConfiguration;
340         }
341     }
342     return nullptr;
343 }
344 void CConfigurableDomain::apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet *pSyncerSet,
345                                 bool bForce, std::string &amp;strInfo) const
346 {
347     if (!pSyncerSet ^ _bSequenceAware) {
348         return;
349     }
350     if (bForce) {
351         _pLastAppliedConfiguration = nullptr;
352     }
353     const CDomainConfiguration *pApplicableDomainConfiguration =
354         findApplicableDomainConfiguration();
355     if (pApplicableDomainConfiguration) {
356         if (!_pLastAppliedConfiguration ||
357             _pLastAppliedConfiguration != pApplicableDomainConfiguration) {
358             strInfo = "Applying configuration '" + pApplicableDomainConfiguration-&gt;getName() +
359                       "' from domain '" + getName() + "'";
360             bool bSync = !pSyncerSet &amp;&amp; _bSequenceAware;
361             pApplicableDomainConfiguration-&gt;restore(pParameterBlackboard, bSync, nullptr);
362             _pLastAppliedConfiguration = pApplicableDomainConfiguration;
363             if (pSyncerSet &amp;&amp; !_bSequenceAware) {
364                 *pSyncerSet += _syncerSet;
365             }
366         }
367     }
368 }
369 bool CConfigurableDomain::isApplicableConfigurationValid(
370     const CConfigurableElement *pConfigurableElement) const
371 {
372     const CDomainConfiguration *pApplicableDomainConfiguration =
373         findApplicableDomainConfiguration();
374     return pApplicableDomainConfiguration &amp;&amp;
375            pApplicableDomainConfiguration-&gt;isValid(pConfigurableElement);
376 }
377 void CConfigurableDomain::computeSyncSet()
378 {
379     _syncerSet.clear();
380     ConfigurableElementToSyncerSetMapIterator mapIt;
381     for (mapIt = _configurableElementToSyncerSetMap.begin();
382          mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
383         const CSyncerSet *pSyncerSet = mapIt-&gt;second;
384         _syncerSet += *pSyncerSet;
385     }
386 }
387 bool CConfigurableDomain::createConfiguration(const string &amp;strName,
388                                               const CParameterBlackboard *pMainBlackboard,
389                                               string &amp;strError)
390 {
391     if (findChild(strName)) {
392         strError = "Already existing configuration";
393         return false;
394     }
395     auto pDomainConfiguration = new CDomainConfiguration(strName);
396     ConfigurableElementListIterator it;
397     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
398         const CConfigurableElement *pConfigurableElement = *it;
399         ;
400         CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
401         pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
402     }
403     addChild(pDomainConfiguration);
404     if (!autoValidateConfiguration(pDomainConfiguration)) {
405         pDomainConfiguration-&gt;validate(pMainBlackboard);
406     }
407     return true;
408 }
409 bool CConfigurableDomain::deleteConfiguration(const string &amp;strName, string &amp;strError)
410 {
411     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
412     if (!pDomainConfiguration) {
413         return false;
414     }
415     if (pDomainConfiguration == _pLastAppliedConfiguration) {
416         _pLastAppliedConfiguration = nullptr;
417     }
418     removeChild(pDomainConfiguration);
419     delete pDomainConfiguration;
420     return true;
421 }
422 void CConfigurableDomain::listAssociatedToElements(string &amp;strResult) const
423 {
424     ConfigurableElementListIterator it;
425     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
426         const CConfigurableElement *pConfigurableElement = *it;
427         strResult += pConfigurableElement-&gt;getPath() + "\n";
428     }
429 }
430 bool CConfigurableDomain::renameConfiguration(const string &amp;strName, const string &amp;strNewName,
431                                               string &amp;strError)
432 {
433     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
434     if (!pDomainConfiguration) {
435         return false;
436     }
437     return pDomainConfiguration-&gt;rename(strNewName, strError);
438 }
439 bool CConfigurableDomain::restoreConfiguration(const string &amp;configurationName,
440                                                CParameterBlackboard *mainBlackboard, bool autoSync,
441                                                core::Results &amp;errors) const
442 {
443     string error;
444     const CDomainConfiguration *configuration = findConfiguration(configurationName, error);
445     if (configuration == nullptr) {
446         errors.push_back(error);
447         return false;
448     }
449     bool bSuccess = configuration-&gt;restore(mainBlackboard, autoSync &amp;&amp; _bSequenceAware, &amp;errors);
450     _pLastAppliedConfiguration = configuration;
451     if (autoSync &amp;&amp; !_bSequenceAware) {
452         bSuccess &amp;= _syncerSet.sync(*mainBlackboard, false, &amp;errors);
453     }
454     return bSuccess;
455 }
456 bool CConfigurableDomain::saveConfiguration(const string &amp;strName,
457                                             const CParameterBlackboard *pMainBlackboard,
458                                             string &amp;strError)
459 {
460     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
461     if (!pDomainConfiguration) {
462         return false;
463     }
464     pDomainConfiguration-&gt;save(pMainBlackboard);
465     return true;
466 }
467 bool CConfigurableDomain::setElementSequence(const string &amp;strConfiguration,
468                                              const std::vector&lt;string&gt; &amp;astrNewElementSequence,
469                                              string &amp;strError)
470 {
471     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
472     if (!pDomainConfiguration) {
473         return false;
474     }
475     return pDomainConfiguration-&gt;setElementSequence(astrNewElementSequence, strError);
476 }
477 bool CConfigurableDomain::getElementSequence(const string &amp;strConfiguration,
478                                              string &amp;strResult) const
479 {
480     const CDomainConfiguration *pDomainConfiguration =
481         findConfiguration(strConfiguration, strResult);
482     if (!pDomainConfiguration) {
483         return false;
484     }
485     pDomainConfiguration-&gt;getElementSequence(strResult);
486     return true;
487 }
488 bool CConfigurableDomain::setApplicationRule(
489     const string &amp;strConfiguration, const string &amp;strApplicationRule,
490     const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition, string &amp;strError)
491 {
492     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
493     if (!pDomainConfiguration) {
494         return false;
495     }
496     return pDomainConfiguration-&gt;setApplicationRule(strApplicationRule,
497                                                     pSelectionCriteriaDefinition, strError);
498 }
499 bool CConfigurableDomain::clearApplicationRule(const string &amp;strConfiguration, string &amp;strError)
500 {
501     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
502     if (!pDomainConfiguration) {
503         return false;
504     }
505     pDomainConfiguration-&gt;clearApplicationRule();
506     return true;
507 }
508 bool CConfigurableDomain::getApplicationRule(const string &amp;strConfiguration,
509                                              string &amp;strResult) const
510 {
511     const CDomainConfiguration *pDomainConfiguration =
512         findConfiguration(strConfiguration, strResult);
513     if (!pDomainConfiguration) {
514         return false;
515     }
516     strResult = pDomainConfiguration-&gt;getApplicationRule();
517     return true;
518 }
519 string CConfigurableDomain::getLastAppliedConfigurationName() const
520 {
521     if (_pLastAppliedConfiguration) {
522         return _pLastAppliedConfiguration-&gt;getName();
523     }
524     return "&lt;none&gt;";
525 }
526 string CConfigurableDomain::getPendingConfigurationName() const
527 {
528     const CDomainConfiguration *pApplicableDomainConfiguration =
529         findApplicableDomainConfiguration();
530     if (!pApplicableDomainConfiguration) {
531         return "&lt;none&gt;";
532     }
533     if (pApplicableDomainConfiguration != _pLastAppliedConfiguration) {
534         return pApplicableDomainConfiguration-&gt;getName();
535     } else {
536         return "";
537     }
538 }
539 void CConfigurableDomain::validate(const CParameterBlackboard *pMainBlackboard)
540 {
541     size_t uiNbConfigurations = getNbChildren();
542     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
543         CDomainConfiguration *pDomainConfiguration =
544             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
545         pDomainConfiguration-&gt;validate(pMainBlackboard);
546     }
547 }
548 void CConfigurableDomain::validateAreas(const CConfigurableElement *pConfigurableElement,
549                                         const CParameterBlackboard *pMainBlackboard)
550 {
551     size_t uiNbConfigurations = getNbChildren();
552     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
553         CDomainConfiguration *pDomainConfiguration =
554             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
555         pDomainConfiguration-&gt;validate(pConfigurableElement, pMainBlackboard);
556     }
557 }
558 void CConfigurableDomain::autoValidateAll()
559 {
560     ConfigurableElementListIterator it;
561     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
562         const CConfigurableElement *pConfigurableElement = *it;
563         autoValidateAreas(pConfigurableElement);
564     }
565 }
566 void CConfigurableDomain::autoValidateAreas(const CConfigurableElement *pConfigurableElement)
567 {
568     const CDomainConfiguration *pValidDomainConfiguration =
569         findValidDomainConfiguration(pConfigurableElement);
570     if (!pValidDomainConfiguration) {
571         return;
572     }
573     size_t uiNbConfigurations = getNbChildren();
574     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
575         CDomainConfiguration *pDomainConfiguration =
576             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
577         if (pDomainConfiguration != pValidDomainConfiguration &amp;&amp;
578             !pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
579             pDomainConfiguration-&gt;validateAgainst(pValidDomainConfiguration, pConfigurableElement);
580         }
581     }
582 }
583 bool CConfigurableDomain::autoValidateConfiguration(CDomainConfiguration *pDomainConfiguration)
584 {
585     size_t uiNbConfigurations = getNbChildren();
586     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
587         const CDomainConfiguration *pPotententialValidDomainConfiguration =
588             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
589         if (pPotententialValidDomainConfiguration != pDomainConfiguration) {
590             pDomainConfiguration-&gt;validateAgainst(pPotententialValidDomainConfiguration);
591             return true;
592         }
593     }
594     return false;
595 }
596 const CDomainConfiguration *CConfigurableDomain::findValidDomainConfiguration(
597     const CConfigurableElement *pConfigurableElement) const
598 {
599     size_t uiNbConfigurations = getNbChildren();
600     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
601         const CDomainConfiguration *pDomainConfiguration =
602             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
603         if (pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
604             return pDomainConfiguration;
605         }
606     }
607     return nullptr;
608 }
609 const CDomainConfiguration *CConfigurableDomain::findApplicableDomainConfiguration() const
610 {
611     size_t uiNbConfigurations = getNbChildren();
612     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
613         const CDomainConfiguration *pDomainConfiguration =
614             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
615         if (pDomainConfiguration-&gt;isApplicable()) {
616             return pDomainConfiguration;
617         }
618     }
619     return nullptr;
620 }
621 void CConfigurableDomain::gatherConfigurableElements(
622     std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const
623 {
624     configurableElementSet.insert(_configurableElementList.begin(), _configurableElementList.end());
625 }
626 bool CConfigurableDomain::containsConfigurableElement(
627     const CConfigurableElement *pConfigurableCandidateElement) const
628 {
629     ConfigurableElementListIterator it;
630     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
631         if (pConfigurableCandidateElement == *it) {
632             return true;
633         }
634     }
635     return false;
636 }
637 void CConfigurableDomain::mergeAlreadyAssociatedDescendantConfigurableElements(
638     CConfigurableElement *newElement, core::Results &amp;infos)
639 {
640     std::list&lt;CConfigurableElement *&gt; mergedConfigurableElementList;
641     ConfigurableElementListIterator it;
642     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
643         CConfigurableElement *pConfigurablePotentialDescendantElement = *it;
644         if (pConfigurablePotentialDescendantElement-&gt;isDescendantOf(newElement)) {
645             infos.push_back("In domain '" + getName() +
646                             "', merging descendant configurable element's configurations '" +
647                             pConfigurablePotentialDescendantElement-&gt;getName() +
648                             "' into its ascendant '" + newElement-&gt;getName() + "' ones");
649             mergeConfigurations(newElement, pConfigurablePotentialDescendantElement);
650             mergedConfigurableElementList.push_back(pConfigurablePotentialDescendantElement);
651         }
652     }
653     for (it = mergedConfigurableElementList.begin(); it != mergedConfigurableElementList.end();
654          ++it) {
655         CConfigurableElement *pMergedConfigurableElement = *it;
656         doRemoveConfigurableElement(pMergedConfigurableElement, false);
657     }
658 }
659 void CConfigurableDomain::mergeConfigurations(CConfigurableElement *pToConfigurableElement,
660                                               CConfigurableElement *pFromConfigurableElement)
661 {
662     size_t uiNbConfigurations = getNbChildren();
663     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
664         CDomainConfiguration *pDomainConfiguration =
665             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
666         pDomainConfiguration-&gt;merge(pToConfigurableElement, pFromConfigurableElement);
667     }
668 }
669 void CConfigurableDomain::doAddConfigurableElement(CConfigurableElement *pConfigurableElement,
670                                                    core::Results &amp;infos,
671                                                    const CParameterBlackboard *pMainBlackboard)
672 {
673     pConfigurableElement-&gt;addAttachedConfigurableDomain(this);
674     auto pSyncerSet = new CSyncerSet;
675     pConfigurableElement-&gt;fillSyncerSet(*pSyncerSet);
676     _configurableElementToSyncerSetMap[pConfigurableElement] = pSyncerSet;
677     _syncerSet += *pSyncerSet;
678     size_t uiNbConfigurations = getNbChildren();
679     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
680         CDomainConfiguration *pDomainConfiguration =
681             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
682         pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
683     }
684     if (pMainBlackboard) {
685         infos.push_back("Validating domain '" + getName() +
686                         "' against main blackboard for configurable element '" +
687                         pConfigurableElement-&gt;getPath() + "'");
688         validateAreas(pConfigurableElement, pMainBlackboard);
689     }
690     mergeAlreadyAssociatedDescendantConfigurableElements(pConfigurableElement, infos);
691     _configurableElementList.push_back(pConfigurableElement);
692 }
693 void CConfigurableDomain::doRemoveConfigurableElement(CConfigurableElement *pConfigurableElement,
694                                                       bool bRecomputeSyncSet)
695 {
696     _configurableElementList.remove(pConfigurableElement);
697     CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
698     _configurableElementToSyncerSetMap.erase(pConfigurableElement);
699     delete pSyncerSet;
700     pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
701     size_t uiNbConfigurations = getNbChildren();
702     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
703         CDomainConfiguration *pDomainConfiguration =
704             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
705         pDomainConfiguration-&gt;removeConfigurableElement(pConfigurableElement);
706     }
707     if (bRecomputeSyncSet) {
708         computeSyncSet();
709     }
710 }
711 CSyncerSet *CConfigurableDomain::getSyncerSet(
712     const CConfigurableElement *pConfigurableElement) const
713 {
714     auto mapIt = _configurableElementToSyncerSetMap.find(pConfigurableElement);
715     ALWAYS_ASSERT(mapIt != _configurableElementToSyncerSetMap.end(),
716                   "Could not find syncer set for " &lt;&lt; getName() &lt;&lt; " configurable domain");
717     return mapIt-&gt;second;
718 }
719 CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
720                                                              string &amp;strError)
721 {
722     CDomainConfiguration *pDomainConfiguration =
723         static_cast&lt;CDomainConfiguration *&gt;(findChild(strConfiguration));
724     if (!pDomainConfiguration) {
725         strError = "Domain configuration " + strConfiguration + " not found";
726         return nullptr;
727     }
728     return pDomainConfiguration;
729 }
730 const CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
731                                                                    string &amp;strError) const
732 {
733     const CDomainConfiguration *pDomainConfiguration =
734         static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
735     if (!pDomainConfiguration) {
736         strError = "Domain configuration " + strConfiguration + " not found";
737         return nullptr;
738     }
739     return pDomainConfiguration;
740 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>BitParameterType.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (c) 2011-2015, Intel Corporation
3  * All rights reserved.
4  *
5  * Redistribution and use in source and binary forms, with or without modification,
6  * are permitted provided that the following conditions are met:
7  *
8  * 1. Redistributions of source code must retain the above copyright notice, this
9  * list of conditions and the following disclaimer.
10  *
11  * 2. Redistributions in binary form must reproduce the above copyright notice,
12  * this list of conditions and the following disclaimer in the documentation and/or
13  * other materials provided with the distribution.
14  *
15  * 3. Neither the name of the copyright holder nor the names of its contributors
16  * may be used to endorse or promote products derived from this software without
17  * specific prior written permission.
18  *
19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
23  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
26  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29  */
30 #include "BitParameterType.h"
31 #include "BitParameter.h"
32 #include &lt;stdlib.h&gt;
33 #include &lt;sstream&gt;
34 #include "ParameterAccessContext.h"
35 #include "BitParameterBlockType.h"
36 #include "Utility.h"
37 #define base CTypeElement
38 using std::string;
39 CBitParameterType::CBitParameterType(const string &amp;strName) : base(strName)
40 {
41 }
42 string CBitParameterType::getKind() const
43 {
44     return "BitParameter";
45 }
46 void CBitParameterType::showProperties(string &amp;strResult) const
47 {
48     base::showProperties(strResult);
49     strResult += "Bit pos: ";
50     strResult += std::to_string(_bitPos);
51     strResult += "\n";
52     strResult += "Bit size: ";
53     strResult += std::to_string(_uiBitSize);
54     strResult += "\n";
55     strResult += "Max: ";
56     strResult += std::to_string(_uiMax);
57     strResult += "\n";
58 }
59 bool CBitParameterType::fromXml(const CXmlElement &amp;xmlElement,
60                                 CXmlSerializingContext &amp;serializingContext)
61 {
62     xmlElement.getAttribute("Pos", _bitPos);
63     xmlElement.getAttribute("Size", _uiBitSize);
64     const CBitParameterBlockType *pBitParameterBlockType =
65         static_cast&lt;const CBitParameterBlockType *&gt;(getParent());
66     size_t uiParentBlockBitSize = pBitParameterBlockType-&gt;getSize() * 8;
67     if (_bitPos + _uiBitSize &gt; uiParentBlockBitSize) {
68         std::ostringstream strStream;
69         strStream &lt;&lt; "Pos and Size attributes inconsistent with maximum container element size ("
70                   &lt;&lt; uiParentBlockBitSize &lt;&lt; " bits) for " + getKind();
71         serializingContext.setError(strStream.str());
72         return false;
73     }
74     _uiMax = getMaxEncodableValue();
75     if (xmlElement.getAttribute("Max", _uiMax) &amp;&amp; (_uiMax &gt; getMaxEncodableValue())) {
76         std::ostringstream strStream;
77         strStream &lt;&lt; "Max attribute inconsistent with maximum encodable size ("
78                   &lt;&lt; getMaxEncodableValue() &lt;&lt; ") for " + getKind();
79         serializingContext.setError(strStream.str());
80         return false;
81     }
82     return base::fromXml(xmlElement, serializingContext);
83 }
84 bool CBitParameterType::toBlackboard(const string &amp;strValue, uint64_t &amp;uiValue,
85                                      CParameterAccessContext &amp;parameterAccessContext) const
86 {
87     uint64_t uiConvertedValue = strtoull(strValue.c_str(), nullptr, 0);
88     if (uiConvertedValue &gt; _uiMax) {
89         std::ostringstream strStream;
90         strStream &lt;&lt; "Value " &lt;&lt; strValue &lt;&lt; " standing out of admitted range [";
91         if (utility::isHexadecimal(strValue)) {
92             strStream &lt;&lt; "0x0, "
93                       &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; std::uppercase;
94         } else {
95             strStream &lt;&lt; "0, ";
96         }
97         strStream &lt;&lt; _uiMax &lt;&lt; "] for " + getKind();
98         parameterAccessContext.setError(strStream.str());
99         return false;
100     }
101     uiValue = (uiValue &amp; ~getMask()) | (uiConvertedValue &lt;&lt; _bitPos);
102     return true;
103 }
104 void CBitParameterType::fromBlackboard(string &amp;strValue, const uint64_t &amp;uiValue,
105                                        CParameterAccessContext &amp;parameterAccessContext) const
106 {
107     uint64_t uiConvertedValue = (uiValue &amp; getMask()) &gt;&gt; _bitPos;
108     std::ostringstream strStream;
109     if (parameterAccessContext.valueSpaceIsRaw() &amp;&amp; parameterAccessContext.outputRawFormatIsHex()) {
110         strStream &lt;&lt; "0x" &lt;&lt; std::hex &lt;&lt; std::uppercase;
111     }
112     strStream &lt;&lt; uiConvertedValue;
113     strValue = strStream.str();
114 }
115 bool CBitParameterType::toBlackboard(uint64_t uiUserValue, uint64_t &amp;uiValue,
116                                      CParameterAccessContext &amp;parameterAccessContext) const
117 {
118     if (uiUserValue &gt; _uiMax) {
119         parameterAccessContext.setError("Value out of range");
120         return false;
121     }
122     uiValue = (uiValue &amp; ~getMask()) | (uiUserValue &lt;&lt; _bitPos);
123     return true;
124 }
125 void CBitParameterType::fromBlackboard(uint32_t &amp;userValue, uint64_t value,
126 <a name="1"></a>                                       CParameterAccessContext &amp; /*ctx*/) const
127 {
128     userValue = static_cast&lt;uint32_t&gt;((value &amp; getMask()) &gt;&gt; _bitPos);
129 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
130 uint64_t CBitParameterType::merge(uint64_t uiOriginData, uint64_t uiNewData) const
131 {
132     return (uiOriginData &amp; ~getMask()) | (uiNewData &amp; getMask());
133 }
134 size_t CBitParameterType::getBitSize() const
135 {
136     return _uiBitSize;
137 }
138 CInstanceConfigurableElement *CBitParameterType::doInstantiate() const</b></font>
139 {
140     return new CBitParameter(getName(), this);
141 }
142 <a name="0"></a>uint64_t CBitParameterType::getMaxEncodableValue() const
143 {
144     return (uint64_t)-1L &gt;&gt; (8 * sizeof(uint64_t) - _uiBitSize);
145 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
146 uint64_t CBitParameterType::getMask() const
147 {
148     return getMaxEncodableValue() &lt;&lt; _bitPos;
149 }
150 void CBitParameterType::toXml(CXmlElement &amp;xmlElement,
151                               CXmlSerializingContext &amp;serializingContext) const
152 {
153     xmlElement.setAttribute("Pos", _bitPos);
154     xmlElement.setAttribute("Size", _uiBitSize);
155     xmlElement.setAttribute("Max", _uiMax);
156     base::toXml(xmlElement, serializingContext);
157 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
