
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.461131676361713%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #include "cluster.h"
3  #include "genericheap.h"
4  #include "kdpair.h"
5  #include "matrix.h"
6  #include "tprintf.h"
7  #include "helpers.h"
8  #include <cfloat> 
9  #include <cmath>  
10  #include <vector> 
11  namespace tesseract {
12  #define HOTELLING 1  
13  #define FTABLE_X 10  
14  #define FTABLE_Y 100 
15  const double FTable[FTABLE_Y][FTABLE_X] = {
16      {
17          4052.19,
18          4999.52,
19          5403.34,
20          5624.62,
21          5763.65,
22          5858.97,
23          5928.33,
24          5981.10,
25          6022.50,
26          6055.85,
27      },
28      {
29          98.502,
30          99.000,
31          99.166,
32          99.249,
33          99.300,
34          99.333,
35          99.356,
36          99.374,
37          99.388,
38          99.399,
39      },
40      {
41          34.116,
42          30.816,
43          29.457,
44          28.710,
45          28.237,
46          27.911,
47          27.672,
48          27.489,
49          27.345,
50          27.229,
51      },
52      {
53          21.198,
54          18.000,
55          16.694,
56          15.977,
57          15.522,
58          15.207,
59          14.976,
60          14.799,
61          14.659,
62          14.546,
63      },
64      {
65          16.258,
66          13.274,
67          12.060,
68          11.392,
69          10.967,
70          10.672,
71          10.456,
72          10.289,
73          10.158,
74          10.051,
75      },
76      {
77          13.745,
78          10.925,
79          9.780,
80          9.148,
81          8.746,
82          8.466,
83          8.260,
84          8.102,
85          7.976,
86          7.874,
87      },
88      {
89          12.246,
90          9.547,
91          8.451,
92          7.847,
93          7.460,
94          7.191,
95          6.993,
96          6.840,
97          6.719,
98          6.620,
99      },
100      {
101          11.259,
102          8.649,
103          7.591,
104          7.006,
105          6.632,
106          6.371,
107          6.178,
108          6.029,
109          5.911,
110          5.814,
111      },
112      {
113          10.561,
114          8.022,
115          6.992,
116          6.422,
117          6.057,
118          5.802,
119          5.613,
120          5.467,
121          5.351,
122          5.257,
123      },
124      {
125          10.044,
126          7.559,
127          6.552,
128          5.994,
129          5.636,
130          5.386,
131          5.200,
132          5.057,
133          4.942,
134          4.849,
135      },
136      {
137          9.646,
138          7.206,
139          6.217,
140          5.668,
141          5.316,
142          5.069,
143          4.886,
144          4.744,
145          4.632,
146          4.539,
147      },
148      {
149          9.330,
150          6.927,
151          5.953,
152          5.412,
153          5.064,
154          4.821,
155          4.640,
156          4.499,
157          4.388,
158          4.296,
159      },
160      {
161          9.074,
162          6.701,
163          5.739,
164          5.205,
165          4.862,
166          4.620,
167          4.441,
168          4.302,
169          4.191,
170          4.100,
171      },
172      {
173          8.862,
174          6.515,
175          5.564,
176          5.035,
177          4.695,
178          4.456,
179          4.278,
180          4.140,
181          4.030,
182          3.939,
183      },
184      {
185          8.683,
186          6.359,
187          5.417,
188          4.893,
189          4.556,
190          4.318,
191          4.142,
192          4.004,
193          3.895,
194          3.805,
195      },
196      {
197          8.531,
198          6.226,
199          5.292,
200          4.773,
201          4.437,
202          4.202,
203          4.026,
204          3.890,
205          3.780,
206          3.691,
207      },
208      {
209          8.400,
210          6.112,
211          5.185,
212          4.669,
213          4.336,
214          4.102,
215          3.927,
216          3.791,
217          3.682,
218          3.593,
219      },
220      {
221          8.285,
222          6.013,
223          5.092,
224          4.579,
225          4.248,
226          4.015,
227          3.841,
228          3.705,
229          3.597,
230          3.508,
231      },
232      {
233          8.185,
234          5.926,
235          5.010,
236          4.500,
237          4.171,
238          3.939,
239          3.765,
240          3.631,
241          3.523,
242          3.434,
243      },
244      {
245          8.096,
246          5.849,
247          4.938,
248          4.431,
249          4.103,
250          3.871,
251          3.699,
252          3.564,
253          3.457,
254          3.368,
255      },
256      {
257          8.017,
258          5.780,
259          4.874,
260          4.369,
261          4.042,
262          3.812,
263          3.640,
264          3.506,
265          3.398,
266          3.310,
267      },
268      {
269          7.945,
270          5.719,
271          4.817,
272          4.313,
273          3.988,
274          3.758,
275          3.587,
276          3.453,
277          3.346,
278          3.258,
279      },
280      {
281          7.881,
282          5.664,
283          4.765,
284          4.264,
285          3.939,
286          3.710,
287          3.539,
288          3.406,
289          3.299,
290          3.211,
291      },
292      {
293          7.823,
294          5.614,
295          4.718,
296          4.218,
297          3.895,
298          3.667,
299          3.496,
300          3.363,
301          3.256,
302          3.168,
303      },
304      {
305          7.770,
306          5.568,
307          4.675,
308          4.177,
309          3.855,
310          3.627,
311          3.457,
312          3.324,
313          3.217,
314          3.129,
315      },
316      {
317          7.721,
318          5.526,
319          4.637,
320          4.140,
321          3.818,
322          3.591,
323          3.421,
324          3.288,
325          3.182,
326          3.094,
327      },
328      {
329          7.677,
330          5.488,
331          4.601,
332          4.106,
333          3.785,
334          3.558,
335          3.388,
336          3.256,
337          3.149,
338          3.062,
339      },
340      {
341          7.636,
342          5.453,
343          4.568,
344          4.074,
345          3.754,
346          3.528,
347          3.358,
348          3.226,
349          3.120,
350          3.032,
351      },
352      {
353          7.598,
354          5.420,
355          4.538,
356          4.045,
357          3.725,
358          3.499,
359          3.330,
360          3.198,
361          3.092,
362          3.005,
363      },
364      {
365          7.562,
366          5.390,
367          4.510,
368          4.018,
369          3.699,
370          3.473,
371          3.305,
372          3.173,
373          3.067,
374          2.979,
375      },
376      {
377          7.530,
378          5.362,
379          4.484,
380          3.993,
381          3.675,
382          3.449,
383          3.281,
384          3.149,
385          3.043,
386          2.955,
387      },
388      {
389          7.499,
390          5.336,
391          4.459,
392          3.969,
393          3.652,
394          3.427,
395          3.258,
396          3.127,
397          3.021,
398          2.934,
399      },
400      {
401          7.471,
402          5.312,
403          4.437,
404          3.948,
405          3.630,
406          3.406,
407          3.238,
408          3.106,
409          3.000,
410          2.913,
411      },
412      {
413          7.444,
414          5.289,
415          4.416,
416          3.927,
417          3.611,
418          3.386,
419          3.218,
420          3.087,
421          2.981,
422          2.894,
423      },
424      {
425          7.419,
426          5.268,
427          4.396,
428          3.908,
429          3.592,
430          3.368,
431          3.200,
432          3.069,
433          2.963,
434          2.876,
435      },
436      {
437          7.396,
438          5.248,
439          4.377,
440          3.890,
441          3.574,
442          3.351,
443          3.183,
444          3.052,
445          2.946,
446          2.859,
447      },
448      {
449          7.373,
450          5.229,
451          4.360,
452          3.873,
453          3.558,
454          3.334,
455          3.167,
456          3.036,
457          2.930,
458          2.843,
459      },
460      {
461          7.353,
462          5.211,
463          4.343,
464          3.858,
465          3.542,
466          3.319,
467          3.152,
468          3.021,
469          2.915,
470          2.828,
471      },
472      {
473          7.333,
474          5.194,
475          4.327,
476          3.843,
477          3.528,
478          3.305,
479          3.137,
480          3.006,
481          2.901,
482          2.814,
483      },
484      {
485          7.314,
486          5.179,
487          4.313,
488          3.828,
489          3.514,
490          3.291,
491          3.124,
492          2.993,
493          2.888,
494          2.801,
495      },
496      {
497          7.296,
498          5.163,
499          4.299,
500          3.815,
501          3.501,
502          3.278,
503          3.111,
504          2.980,
505          2.875,
506          2.788,
507      },
508      {
509          7.280,
510          5.149,
511          4.285,
512          3.802,
513          3.488,
514          3.266,
515          3.099,
516          2.968,
517          2.863,
518          2.776,
519      },
520      {
521          7.264,
522          5.136,
523          4.273,
524          3.790,
525          3.476,
526          3.254,
527          3.087,
528          2.957,
529          2.851,
530          2.764,
531      },
532      {
533          7.248,
534          5.123,
535          4.261,
536          3.778,
537          3.465,
538          3.243,
539          3.076,
540          2.946,
541          2.840,
542          2.754,
543      },
544      {
545          7.234,
546          5.110,
547          4.249,
548          3.767,
549          3.454,
550          3.232,
551          3.066,
552          2.935,
553          2.830,
554          2.743,
555      },
556      {
557          7.220,
558          5.099,
559          4.238,
560          3.757,
561          3.444,
562          3.222,
563          3.056,
564          2.925,
565          2.820,
566          2.733,
567      },
568      {
569          7.207,
570          5.087,
571          4.228,
572          3.747,
573          3.434,
574          3.213,
575          3.046,
576          2.916,
577          2.811,
578          2.724,
579      },
580      {
581          7.194,
582          5.077,
583          4.218,
584          3.737,
585          3.425,
586          3.204,
587          3.037,
588          2.907,
589          2.802,
590          2.715,
591      },
592      {
593          7.182,
594          5.066,
595          4.208,
596          3.728,
597          3.416,
598          3.195,
599          3.028,
600          2.898,
601          2.793,
602          2.706,
603      },
604      {
605          7.171,
606          5.057,
607          4.199,
608          3.720,
609          3.408,
610          3.186,
611          3.020,
612          2.890,
613          2.785,
614          2.698,
615      },
616      {
617          7.159,
618          5.047,
619          4.191,
620          3.711,
621          3.400,
622          3.178,
623          3.012,
624          2.882,
625          2.777,
626          2.690,
627      },
628      {
629          7.149,
630          5.038,
631          4.182,
632          3.703,
633          3.392,
634          3.171,
635          3.005,
636          2.874,
637          2.769,
638          2.683,
639      },
640      {
641          7.139,
642          5.030,
643          4.174,
644          3.695,
645          3.384,
646          3.163,
647          2.997,
648          2.867,
649          2.762,
650          2.675,
651      },
652      {
653          7.129,
654          5.021,
655          4.167,
656          3.688,
657          3.377,
658          3.156,
659          2.990,
660          2.860,
661          2.755,
662          2.668,
663      },
664      {
665          7.119,
666          5.013,
667          4.159,
668          3.681,
669          3.370,
670          3.149,
671          2.983,
672          2.853,
673          2.748,
674          2.662,
675      },
676      {
677          7.110,
678          5.006,
679          4.152,
680          3.674,
681          3.363,
682          3.143,
683          2.977,
684          2.847,
685          2.742,
686          2.655,
687      },
688      {
689          7.102,
690          4.998,
691          4.145,
692          3.667,
693          3.357,
694          3.136,
695          2.971,
696          2.841,
697          2.736,
698          2.649,
699      },
700      {
701          7.093,
702          4.991,
703          4.138,
704          3.661,
705          3.351,
706          3.130,
707          2.965,
708          2.835,
709          2.730,
710          2.643,
711      },
712      {
713          7.085,
714          4.984,
715          4.132,
716          3.655,
717          3.345,
718          3.124,
719          2.959,
720          2.829,
721          2.724,
722          2.637,
723      },
724      {
725          7.077,
726          4.977,
727          4.126,
728          3.649,
729          3.339,
730          3.119,
731          2.953,
732          2.823,
733          2.718,
734          2.632,
735      },
736      {
737          7.070,
738          4.971,
739          4.120,
740          3.643,
741          3.333,
742          3.113,
743          2.948,
744          2.818,
745          2.713,
746          2.626,
747      },
748      {
749          7.062,
750          4.965,
751          4.114,
752          3.638,
753          3.328,
754          3.108,
755          2.942,
756          2.813,
757          2.708,
758          2.621,
759      },
760      {
761          7.055,
762          4.959,
763          4.109,
764          3.632,
765          3.323,
766          3.103,
767          2.937,
768          2.808,
769          2.703,
770          2.616,
771      },
772      {
773          7.048,
774          4.953,
775          4.103,
776          3.627,
777          3.318,
778          3.098,
779          2.932,
780          2.803,
781          2.698,
782          2.611,
783      },
784      {
785          7.042,
786          4.947,
787          4.098,
788          3.622,
789          3.313,
790          3.093,
791          2.928,
792          2.798,
793          2.693,
794          2.607,
795      },
796      {
797          7.035,
798          4.942,
799          4.093,
800          3.618,
801          3.308,
802          3.088,
803          2.923,
804          2.793,
805          2.689,
806          2.602,
807      },
808      {
809          7.029,
810          4.937,
811          4.088,
812          3.613,
813          3.304,
814          3.084,
815          2.919,
816          2.789,
817          2.684,
818          2.598,
819      },
820      {
821          7.023,
822          4.932,
823          4.083,
824          3.608,
825          3.299,
826          3.080,
827          2.914,
828          2.785,
829          2.680,
830          2.593,
831      },
832      {
833          7.017,
834          4.927,
835          4.079,
836          3.604,
837          3.295,
838          3.075,
839          2.910,
840          2.781,
841          2.676,
842          2.589,
843      },
844      {
845          7.011,
846          4.922,
847          4.074,
848          3.600,
849          3.291,
850          3.071,
851          2.906,
852          2.777,
853          2.672,
854          2.585,
855      },
856      {
857          7.006,
858          4.917,
859          4.070,
860          3.596,
861          3.287,
862          3.067,
863          2.902,
864          2.773,
865          2.668,
866          2.581,
867      },
868      {
869          7.001,
870          4.913,
871          4.066,
872          3.591,
873          3.283,
874          3.063,
875          2.898,
876          2.769,
877          2.664,
878          2.578,
879      },
880      {
881          6.995,
882          4.908,
883          4.062,
884          3.588,
885          3.279,
886          3.060,
887          2.895,
888          2.765,
889          2.660,
890          2.574,
891      },
892      {
893          6.990,
894          4.904,
895          4.058,
896          3.584,
897          3.275,
898          3.056,
899          2.891,
900          2.762,
901          2.657,
902          2.570,
903      },
904      {
905          6.985,
906          4.900,
907          4.054,
908          3.580,
909          3.272,
910          3.052,
911          2.887,
912          2.758,
913          2.653,
914          2.567,
915      },
916      {
917          6.981,
918          4.896,
919          4.050,
920          3.577,
921          3.268,
922          3.049,
923          2.884,
924          2.755,
925          2.650,
926          2.563,
927      },
928      {
929          6.976,
930          4.892,
931          4.047,
932          3.573,
933          3.265,
934          3.046,
935          2.881,
936          2.751,
937          2.647,
938          2.560,
939      },
940      {
941          6.971,
942          4.888,
943          4.043,
944          3.570,
945          3.261,
946          3.042,
947          2.877,
948          2.748,
949          2.644,
950          2.557,
951      },
952      {
953          6.967,
954          4.884,
955          4.040,
956          3.566,
957          3.258,
958          3.039,
959          2.874,
960          2.745,
961          2.640,
962          2.554,
963      },
964      {
965          6.963,
966          4.881,
967          4.036,
968          3.563,
969          3.255,
970          3.036,
971          2.871,
972          2.742,
973          2.637,
974          2.551,
975      },
976      {
977          6.958,
978          4.877,
979          4.033,
980          3.560,
981          3.252,
982          3.033,
983          2.868,
984          2.739,
985          2.634,
986          2.548,
987      },
988      {
989          6.954,
990          4.874,
991          4.030,
992          3.557,
993          3.249,
994          3.030,
995          2.865,
996          2.736,
997          2.632,
998          2.545,
999      },
1000      {
1001          6.950,
1002          4.870,
1003          4.027,
1004          3.554,
1005          3.246,
1006          3.027,
1007          2.863,
1008          2.733,
1009          2.629,
1010          2.542,
1011      },
1012      {
1013          6.947,
1014          4.867,
1015          4.024,
1016          3.551,
1017          3.243,
1018          3.025,
1019          2.860,
1020          2.731,
1021          2.626,
1022          2.539,
1023      },
1024      {
1025          6.943,
1026          4.864,
1027          4.021,
1028          3.548,
1029          3.240,
1030          3.022,
1031          2.857,
1032          2.728,
1033          2.623,
1034          2.537,
1035      },
1036      {
1037          6.939,
1038          4.861,
1039          4.018,
1040          3.545,
1041          3.238,
1042          3.019,
1043          2.854,
1044          2.725,
1045          2.621,
1046          2.534,
1047      },
1048      {
1049          6.935,
1050          4.858,
1051          4.015,
1052          3.543,
1053          3.235,
1054          3.017,
1055          2.852,
1056          2.723,
1057          2.618,
1058          2.532,
1059      },
1060      {
1061          6.932,
1062          4.855,
1063          4.012,
1064          3.540,
1065          3.233,
1066          3.014,
1067          2.849,
1068          2.720,
1069          2.616,
1070          2.529,
1071      },
1072      {
1073          6.928,
1074          4.852,
1075          4.010,
1076          3.538,
1077          3.230,
1078          3.012,
1079          2.847,
1080          2.718,
1081          2.613,
1082          2.527,
1083      },
1084      {
1085          6.925,
1086          4.849,
1087          4.007,
1088          3.535,
1089          3.228,
1090          3.009,
1091          2.845,
1092          2.715,
1093          2.611,
1094          2.524,
1095      },
1096      {
1097          6.922,
1098          4.846,
1099          4.004,
1100          3.533,
1101          3.225,
1102          3.007,
1103          2.842,
1104          2.713,
1105          2.609,
1106          2.522,
1107      },
1108      {
1109          6.919,
1110          4.844,
1111          4.002,
1112          3.530,
1113          3.223,
1114          3.004,
1115          2.840,
1116          2.711,
1117          2.606,
1118          2.520,
1119      },
1120      {
1121          6.915,
1122          4.841,
1123          3.999,
1124          3.528,
1125          3.221,
1126          3.002,
1127          2.838,
1128          2.709,
1129          2.604,
1130          2.518,
1131      },
1132      {
1133          6.912,
1134          4.838,
1135          3.997,
1136          3.525,
1137          3.218,
1138          3.000,
1139          2.835,
1140          2.706,
1141          2.602,
1142          2.515,
1143      },
1144      {
1145          6.909,
1146          4.836,
1147          3.995,
1148          3.523,
1149          3.216,
1150          2.998,
1151          2.833,
1152          2.704,
1153          2.600,
1154          2.513,
1155      },
1156      {
1157          6.906,
1158          4.833,
1159          3.992,
1160          3.521,
1161          3.214,
1162          2.996,
1163          2.831,
1164          2.702,
1165          2.598,
1166          2.511,
1167      },
1168      {
1169          6.904,
1170          4.831,
1171          3.990,
1172          3.519,
1173          3.212,
1174          2.994,
1175          2.829,
1176          2.700,
1177          2.596,
1178          2.509,
1179      },
1180      {
1181          6.901,
1182          4.829,
1183          3.988,
1184          3.517,
1185          3.210,
1186          2.992,
1187          2.827,
1188          2.698,
1189          2.594,
1190          2.507,
1191      },
1192      {
1193          6.898,
1194          4.826,
1195          3.986,
1196          3.515,
1197          3.208,
1198          2.990,
1199          2.825,
1200          2.696,
1201          2.592,
1202          2.505,
1203      },
1204      {6.895, 4.824, 3.984, 3.513, 3.206, 2.988, 2.823, 2.694, 2.590, 2.503}};
1205  #define MINVARIANCE 0.0004
1206  #define MINSAMPLESPERBUCKET 5
1207  #define MINSAMPLES (MINBUCKETS * MINSAMPLESPERBUCKET)
1208  #define MINSAMPLESNEEDED 1
1209  #define BUCKETTABLESIZE 1024
1210  #define NORMALEXTENT 3.0
1211  struct TEMPCLUSTER {
1212    CLUSTER *Cluster;
1213    CLUSTER *Neighbor;
1214  };
1215  using ClusterPair = tesseract::KDPairInc<float, TEMPCLUSTER *>;
1216  using ClusterHeap = tesseract::GenericHeap<ClusterPair>;
1217  struct STATISTICS {
1218    STATISTICS(size_t n) : CoVariance(n * n), Min(n), Max(n) {
1219    }
1220    float AvgVariance = 1.0f;
1221    std::vector<float> CoVariance;
1222    std::vector<float> Min; 
1223    std::vector<float> Max; 
1224  };
1225  struct BUCKETS {
1226    BUCKETS(size_t n) : NumberOfBuckets(n), Count(n), ExpectedCount(n) {
1227    }
1228    ~BUCKETS() {
1229    }
1230    DISTRIBUTION Distribution = normal; 
1231    uint32_t SampleCount = 0;         
1232    double Confidence = 0.0;          
1233    double ChiSquared = 0.0;          
1234    uint16_t NumberOfBuckets;         
1235    uint16_t Bucket[BUCKETTABLESIZE]; 
1236    std::vector<uint32_t> Count;      
1237    std::vector<float> ExpectedCount; 
1238  };
1239  struct CHISTRUCT {
1240    CHISTRUCT(uint16_t degreesOfFreedom, double alpha) : DegreesOfFreedom(degreesOfFreedom), Alpha(alpha) {
1241    }
1242    uint16_t DegreesOfFreedom = 0;
1243    double Alpha = 0.0;
1244    double ChiSquared = 0.0;
1245  };
1246  struct ClusteringContext {
1247    ClusterHeap *heap;       
1248    TEMPCLUSTER *candidates; 
1249    KDTREE *tree;            
1250    int32_t next;            
1251  };
1252  using DENSITYFUNC = double (*)(int32_t);
1253  using SOLVEFUNC = double (*)(CHISTRUCT *, double);
1254  #define Odd(N) ((N) % 2)
1255  #define Mirror(N, R) ((R) - (N)-1)
1256  #define Abs(N) (((N) < 0) ? (-(N)) : (N))
1257  #define SqrtOf2Pi 2.506628275
1258  static const double kNormalStdDev = BUCKETTABLESIZE / (2.0 * NORMALEXTENT);
1259  static const double kNormalVariance =
1260      (BUCKETTABLESIZE * BUCKETTABLESIZE) / (4.0 * NORMALEXTENT * NORMALEXTENT);
1261  static const double kNormalMagnitude = (2.0 * NORMALEXTENT) / (SqrtOf2Pi * BUCKETTABLESIZE);
1262  static const double kNormalMean = BUCKETTABLESIZE / 2;
1263  #define LOOKUPTABLESIZE 8
1264  #define MAXDEGREESOFFREEDOM MAXBUCKETS
1265  static const uint32_t kCountTable[LOOKUPTABLESIZE] = {MINSAMPLES, 200,  400, 600, 800,
1266                                                        1000,       1500, 2000}; 
1267  static const uint16_t kBucketsTable[LOOKUPTABLESIZE] = {
1268      MINBUCKETS, 16, 20, 24, 27, 30, 35, MAXBUCKETS}; 
1269  static void CreateClusterTree(CLUSTERER *Clusterer);
1270  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t Level);
1271  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance);
1272  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster);
1273  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config);
1274  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster);
1275  static PROTOTYPE *MakeDegenerateProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics,
1276                                        PROTOSTYLE Style, int32_t MinSamples);
1277  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1278                                        STATISTICS *Statistics);
1279  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1280                                       BUCKETS *Buckets);
1281  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1282                                        STATISTICS *Statistics, BUCKETS *Buckets);
1283  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1284                                   BUCKETS *NormalBuckets, double Confidence);
1285  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc);
1286  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics);
1287  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster);
1288  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1289  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1290  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics);
1291  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster);
1292  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence);
1293  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1294                             double Confidence);
1295  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence);
1296  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount);
1297  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha);
1298  static double NormalDensity(int32_t x);
1299  static double UniformDensity(int32_t x);
1300  static double Integral(double f1, double f2, double Dx);
1301  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
1302                          float Mean, float StdDev);
1303  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1304  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev);
1305  static bool DistributionOK(BUCKETS *Buckets);
1306  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets);
1307  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount);
1308  static void InitBuckets(BUCKETS *Buckets);
1309  static int AlphaMatch(void *arg1,  
1310                        void *arg2); 
1311  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy);
1312  static double ChiArea(CHISTRUCT *ChiParams, double x);
1313  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal);
1314  static double InvertMatrix(const float *input, int size, float *inv);
1315  CLUSTERER *MakeClusterer(int16_t SampleSize, const PARAM_DESC ParamDesc[]) {
1316    int i;
1317    auto Clusterer = new CLUSTERER;
1318    Clusterer->SampleSize = SampleSize;
1319    Clusterer->NumberOfSamples = 0;
1320    Clusterer->NumChar = 0;
1321    Clusterer->Root = nullptr;
1322    Clusterer->ProtoList = NIL_LIST;
1323    Clusterer->ParamDesc = new PARAM_DESC[SampleSize];
1324    for (i = 0; i < SampleSize; i++) {
1325      Clusterer->ParamDesc[i].Circular = ParamDesc[i].Circular;
1326      Clusterer->ParamDesc[i].NonEssential = ParamDesc[i].NonEssential;
1327      Clusterer->ParamDesc[i].Min = ParamDesc[i].Min;
1328      Clusterer->ParamDesc[i].Max = ParamDesc[i].Max;
1329      Clusterer->ParamDesc[i].Range = ParamDesc[i].Max - ParamDesc[i].Min;
1330      Clusterer->ParamDesc[i].HalfRange = Clusterer->ParamDesc[i].Range / 2;
1331      Clusterer->ParamDesc[i].MidRange = (ParamDesc[i].Max + ParamDesc[i].Min) / 2;
1332    }
1333    Clusterer->KDTree = MakeKDTree(SampleSize, ParamDesc);
1334    for (auto &d : Clusterer->bucket_cache) {
1335      for (auto &c : d) {
1336        c = nullptr;
1337      }
1338    }
1339    return Clusterer;
1340  } 
1341  SAMPLE *MakeSample(CLUSTERER *Clusterer, const float *Feature, uint32_t CharID) {
1342    int i;
1343    ASSERT_HOST(Clusterer->Root == nullptr);
1344    auto Sample = new SAMPLE(Clusterer->SampleSize);
1345    Sample->Clustered = false;
1346    Sample->Prototype = false;
1347    Sample->SampleCount = 1;
1348    Sample->Left = nullptr;
1349    Sample->Right = nullptr;
1350    Sample->CharID = CharID;
1351    for (i = 0; i < Clusterer->SampleSize; i++) {
1352      Sample->Mean[i] = Feature[i];
1353    }
1354    Clusterer->NumberOfSamples++;
1355    KDStore(Clusterer->KDTree, &Sample->Mean[0], Sample);
1356    if (CharID >= Clusterer->NumChar) {
1357      Clusterer->NumChar = CharID + 1;
1358    }
1359    return (Sample);
1360  } 
1361  LIST ClusterSamples(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1362    if (Clusterer->Root == nullptr) {
1363      CreateClusterTree(Clusterer);
1364    }
1365    FreeProtoList(&Clusterer->ProtoList);
1366    Clusterer->ProtoList = NIL_LIST;
1367    ComputePrototypes(Clusterer, Config);
1368    LIST proto_list = Clusterer->ProtoList;
1369    iterate(proto_list) {
1370      auto *proto = reinterpret_cast<PROTOTYPE *>(proto_list->first_node());
1371      proto->Cluster = nullptr;
1372    }
1373    return Clusterer->ProtoList;
1374  } 
1375  void FreeClusterer(CLUSTERER *Clusterer) {
1376    if (Clusterer != nullptr) {
1377      delete[] Clusterer->ParamDesc;
1378      delete Clusterer->KDTree;
1379      delete Clusterer->Root;
1380      for (auto &d : Clusterer->bucket_cache) {
1381        for (auto &c : d) {
1382          delete c;
1383        }
1384      }
1385      delete Clusterer;
1386    }
1387  } 
1388  void FreeProtoList(LIST *ProtoList) {
1389    destroy_nodes(*ProtoList, FreePrototype);
1390  } 
1391  void FreePrototype(void *arg) { 
1392    auto *Prototype = static_cast<PROTOTYPE *>(arg);
1393    if (Prototype->Cluster != nullptr) {
1394      Prototype->Cluster->Prototype = false;
1395    }
1396    if (Prototype->Style != spherical) {
1397      delete[] Prototype->Variance.Elliptical;
1398      delete[] Prototype->Magnitude.Elliptical;
1399      delete[] Prototype->Weight.Elliptical;
1400    }
1401    delete Prototype;
1402  } 
1403  CLUSTER *NextSample(LIST *SearchState) {
1404    CLUSTER *Cluster;
1405    if (*SearchState == NIL_LIST) {
1406      return (nullptr);
1407    }
1408    Cluster = reinterpret_cast<CLUSTER *>((*SearchState)->first_node());
1409    *SearchState = pop(*SearchState);
1410    for (;;) {
1411      if (Cluster->Left == nullptr) {
1412        return (Cluster);
1413      }
1414      *SearchState = push(*SearchState, Cluster->Right);
1415      Cluster = Cluster->Left;
1416    }
1417  } 
1418  float Mean(PROTOTYPE *Proto, uint16_t Dimension) {
1419    return (Proto->Mean[Dimension]);
1420  } 
1421  float StandardDeviation(PROTOTYPE *Proto, uint16_t Dimension) {
1422    switch (Proto->Style) {
1423      case spherical:
1424        return std::sqrt(Proto->Variance.Spherical);
1425      case elliptical:
1426        return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1427      case mixed:
1428        switch (Proto->Distrib[Dimension]) {
1429          case normal:
1430            return std::sqrt(Proto->Variance.Elliptical[Dimension]);
1431          case uniform:
1432          case D_random:
1433            return Proto->Variance.Elliptical[Dimension];
1434          case DISTRIBUTION_COUNT:
1435            ASSERT_HOST(!"Distribution count not allowed!");
1436        }
1437    }
1438    return 0.0f;
1439  } 
1440  static void CreateClusterTree(CLUSTERER *Clusterer) {
1441    ClusteringContext context;
1442    ClusterPair HeapEntry;
1443    context.tree = Clusterer->KDTree;
1444    context.candidates = new TEMPCLUSTER[Clusterer->NumberOfSamples];
1445    context.next = 0;
1446    context.heap = new ClusterHeap(Clusterer->NumberOfSamples);
1447    KDWalk(context.tree, MakePotentialClusters, &context);
1448    while (context.heap->Pop(&HeapEntry)) {
1449      TEMPCLUSTER *PotentialCluster = HeapEntry.data();
1450      if (PotentialCluster->Cluster->Clustered) {
1451        continue;
1452      }
1453      else if (PotentialCluster->Neighbor->Clustered) {
1454        PotentialCluster->Neighbor =
1455            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1456        if (PotentialCluster->Neighbor != nullptr) {
1457          context.heap->Push(&HeapEntry);
1458        }
1459      }
1460      else {
1461        PotentialCluster->Cluster = MakeNewCluster(Clusterer, PotentialCluster);
1462        PotentialCluster->Neighbor =
1463            FindNearestNeighbor(context.tree, PotentialCluster->Cluster, &HeapEntry.key());
1464        if (PotentialCluster->Neighbor != nullptr) {
1465          context.heap->Push(&HeapEntry);
1466        }
1467      }
1468    }
1469    Clusterer->Root = static_cast<CLUSTER *> RootOf(Clusterer->KDTree);
1470    delete context.tree;
1471    Clusterer->KDTree = nullptr;
1472    delete context.heap;
1473    delete[] context.candidates;
1474  } 
1475  static void MakePotentialClusters(ClusteringContext *context, CLUSTER *Cluster, int32_t &bsol;*Level*/) {
1476    ClusterPair HeapEntry;
1477    int next = context->next;
1478    context->candidates[next].Cluster = Cluster;
1479    HeapEntry.data() = &(context->candidates[next]);
1480    context->candidates[next].Neighbor =
1481        FindNearestNeighbor(context->tree, context->candidates[next].Cluster, &HeapEntry.key());
1482    if (context->candidates[next].Neighbor != nullptr) {
1483      context->heap->Push(&HeapEntry);
1484      context->next++;
1485    }
1486  } 
1487  static CLUSTER *FindNearestNeighbor(KDTREE *Tree, CLUSTER *Cluster, float *Distance)
1488  #define MAXNEIGHBORS 2
1489  #define MAXDISTANCE FLT_MAX
1490  {
1491    CLUSTER *Neighbor[MAXNEIGHBORS];
1492    float Dist[MAXNEIGHBORS];
1493    int NumberOfNeighbors;
1494    int32_t i;
1495    CLUSTER *BestNeighbor;
1496    KDNearestNeighborSearch(Tree, &Cluster->Mean[0], MAXNEIGHBORS, MAXDISTANCE, &NumberOfNeighbors,
1497                            reinterpret_cast<void **>(Neighbor), Dist);
1498    *Distance = MAXDISTANCE;
1499    BestNeighbor = nullptr;
1500    for (i = 0; i < NumberOfNeighbors; i++) {
1501      if ((Dist[i] < *Distance) && (Neighbor[i] != Cluster)) {
1502        *Distance = Dist[i];
1503        BestNeighbor = Neighbor[i];
1504      }
1505    }
1506    return BestNeighbor;
1507  } 
1508  static CLUSTER *MakeNewCluster(CLUSTERER *Clusterer, TEMPCLUSTER *TempCluster) {
1509    auto Cluster = new CLUSTER(Clusterer->SampleSize);
1510    Cluster->Clustered = false;
1511    Cluster->Prototype = false;
1512    Cluster->Left = TempCluster->Cluster;
1513    Cluster->Right = TempCluster->Neighbor;
1514    Cluster->CharID = -1;
1515    Cluster->Left->Clustered = true;
1516    Cluster->Right->Clustered = true;
1517    KDDelete(Clusterer->KDTree, &Cluster->Left->Mean[0], Cluster->Left);
1518    KDDelete(Clusterer->KDTree, &Cluster->Right->Mean[0], Cluster->Right);
1519    Cluster->SampleCount = MergeClusters(Clusterer->SampleSize, Clusterer->ParamDesc,
1520                                         Cluster->Left->SampleCount, Cluster->Right->SampleCount,
1521                                         &Cluster->Mean[0], &Cluster->Left->Mean[0], &Cluster->Right->Mean[0]);
1522    KDStore(Clusterer->KDTree, &Cluster->Mean[0], Cluster);
1523    return Cluster;
1524  } 
1525  int32_t MergeClusters(int16_t N, PARAM_DESC ParamDesc[], int32_t n1, int32_t n2, float m[],
1526                        float m1[], float m2[]) {
1527    int32_t i, n;
1528    n = n1 + n2;
1529    for (i = N; i > 0; i--, ParamDesc++, m++, m1++, m2++) {
1530      if (ParamDesc->Circular) {
1531        if ((*m2 - *m1) > ParamDesc->HalfRange) {
1532          *m = (n1 * *m1 + n2 * (*m2 - ParamDesc->Range)) / n;
1533          if (*m < ParamDesc->Min) {
1534            *m += ParamDesc->Range;
1535          }
1536        } else if ((*m1 - *m2) > ParamDesc->HalfRange) {
1537          *m = (n1 * (*m1 - ParamDesc->Range) + n2 * *m2) / n;
1538          if (*m < ParamDesc->Min) {
1539            *m += ParamDesc->Range;
1540          }
1541        } else {
1542          *m = (n1 * *m1 + n2 * *m2) / n;
1543        }
1544      } else {
1545        *m = (n1 * *m1 + n2 * *m2) / n;
1546      }
1547    }
1548    return n;
1549  } 
1550  static void ComputePrototypes(CLUSTERER *Clusterer, CLUSTERCONFIG *Config) {
1551    LIST ClusterStack = NIL_LIST;
1552    CLUSTER *Cluster;
1553    PROTOTYPE *Prototype;
1554    if (Clusterer->Root != nullptr) {
1555      ClusterStack = push(NIL_LIST, Clusterer->Root);
1556    }
1557    while (ClusterStack != NIL_LIST) {
1558      Cluster = reinterpret_cast<CLUSTER *>(ClusterStack->first_node());
1559      ClusterStack = pop(ClusterStack);
1560      Prototype = MakePrototype(Clusterer, Config, Cluster);
1561      if (Prototype != nullptr) {
1562        Clusterer->ProtoList = push(Clusterer->ProtoList, Prototype);
1563      } else {
1564        ClusterStack = push(ClusterStack, Cluster->Right);
1565        ClusterStack = push(ClusterStack, Cluster->Left);
1566      }
1567    }
1568  } 
1569  static PROTOTYPE *MakePrototype(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster) {
1570    PROTOTYPE *Proto;
1571    BUCKETS *Buckets;
1572    if (MultipleCharSamples(Clusterer, Cluster, Config->MaxIllegal)) {
1573      return nullptr;
1574    }
1575    auto Statistics = ComputeStatistics(Clusterer->SampleSize, Clusterer->ParamDesc, Cluster);
1576    Proto = MakeDegenerateProto(Clusterer->SampleSize, Cluster, Statistics, Config->ProtoStyle,
1577                                static_cast<int32_t>(Config->MinSamples * Clusterer->NumChar));
1578    if (Proto != nullptr) {
1579      delete Statistics;
1580      return Proto;
1581    }
1582    if (!Independent(Clusterer->ParamDesc, Clusterer->SampleSize, &Statistics->CoVariance[0],
1583                     Config->Independence)) {
1584      delete Statistics;
1585      return nullptr;
1586    }
1587    if (HOTELLING && Config->ProtoStyle == elliptical) {
1588      Proto = TestEllipticalProto(Clusterer, Config, Cluster, Statistics);
1589      if (Proto != nullptr) {
1590        delete Statistics;
1591        return Proto;
1592      }
1593    }
1594    Buckets = GetBuckets(Clusterer, normal, Cluster->SampleCount, Config->Confidence);
1595    switch (Config->ProtoStyle) {
1596      case spherical:
1597        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1598        break;
1599      case elliptical:
1600        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1601        break;
1602      case mixed:
1603        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1604        break;
1605      case automatic:
1606        Proto = MakeSphericalProto(Clusterer, Cluster, Statistics, Buckets);
1607        if (Proto != nullptr) {
1608          break;
1609        }
1610        Proto = MakeEllipticalProto(Clusterer, Cluster, Statistics, Buckets);
1611        if (Proto != nullptr) {
1612          break;
1613        }
1614        Proto = MakeMixedProto(Clusterer, Cluster, Statistics, Buckets, Config->Confidence);
1615        break;
1616    }
1617    delete Statistics;
1618    return Proto;
1619  } 
1620  static PROTOTYPE *MakeDegenerateProto( 
1621      uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics, PROTOSTYLE Style, int32_t MinSamples) {
1622    PROTOTYPE *Proto = nullptr;
1623    if (MinSamples < MINSAMPLESNEEDED) {
1624      MinSamples = MINSAMPLESNEEDED;
1625    }
1626    if (Cluster->SampleCount < MinSamples) {
1627      switch (Style) {
1628        case spherical:
1629          Proto = NewSphericalProto(N, Cluster, Statistics);
1630          break;
1631        case elliptical:
1632        case automatic:
1633          Proto = NewEllipticalProto(N, Cluster, Statistics);
1634          break;
1635        case mixed:
1636          Proto = NewMixedProto(N, Cluster, Statistics);
1637          break;
1638      }
1639      Proto->Significant = false;
1640    }
1641    return (Proto);
1642  } 
1643  static PROTOTYPE *TestEllipticalProto(CLUSTERER *Clusterer, CLUSTERCONFIG *Config, CLUSTER *Cluster,
1644                                        STATISTICS *Statistics) {
1645    const double kMagicSampleMargin = 0.0625;
1646    const double kFTableBoostMargin = 2.0;
1647    int N = Clusterer->SampleSize;
1648    CLUSTER *Left = Cluster->Left;
1649    CLUSTER *Right = Cluster->Right;
1650    if (Left == nullptr || Right == nullptr) {
1651      return nullptr;
1652    }
1653    int TotalDims = Left->SampleCount + Right->SampleCount;
1654    if (TotalDims < N + 1 || TotalDims < 2) {
1655      return nullptr;
1656    }
1657    std::vector<float> Covariance(static_cast<size_t>(N) * N);
1658    std::vector<float> Inverse(static_cast<size_t>(N) * N);
1659    std::vector<float> Delta(N);
1660    for (int i = 0; i < N; ++i) {
1661      int row_offset = i * N;
1662      if (!Clusterer->ParamDesc[i].NonEssential) {
1663        for (int j = 0; j < N; ++j) {
1664          if (!Clusterer->ParamDesc[j].NonEssential) {
1665            Covariance[j + row_offset] = Statistics->CoVariance[j + row_offset];
1666          } else {
1667            Covariance[j + row_offset] = 0.0f;
1668          }
1669        }
1670      } else {
1671        for (int j = 0; j < N; ++j) {
1672          if (i == j) {
1673            Covariance[j + row_offset] = 1.0f;
1674          } else {
1675            Covariance[j + row_offset] = 0.0f;
1676          }
1677        }
1678      }
1679    }
1680    double err = InvertMatrix(&Covariance[0], N, &Inverse[0]);
1681    if (err > 1) {
1682      tprintf("Clustering error: Matrix inverse failed with error %g\n", err);
1683    }
1684    int EssentialN = 0;
1685    for (int dim = 0; dim < N; ++dim) {
1686      if (!Clusterer->ParamDesc[dim].NonEssential) {
1687        Delta[dim] = Left->Mean[dim] - Right->Mean[dim];
1688        ++EssentialN;
1689      } else {
1690        Delta[dim] = 0.0f;
1691      }
1692    }
1693    double Tsq = 0.0;
1694    for (int x = 0; x < N; ++x) {
1695      double temp = 0.0;
1696      for (int y = 0; y < N; ++y) {
1697        temp += static_cast<double>(Inverse[y + N * x]) * Delta[y];
1698      }
1699      Tsq += Delta[x] * temp;
1700    }
1701    double F = Tsq * (TotalDims - EssentialN - 1) / ((TotalDims - 2) * EssentialN);
1702    int Fx = EssentialN;
1703    if (Fx > FTABLE_X) {
1704      Fx = FTABLE_X;
1705    }
1706    --Fx;
1707    int Fy = TotalDims - EssentialN - 1;
1708    if (Fy > FTABLE_Y) {
1709      Fy = FTABLE_Y;
1710    }
1711    --Fy;
1712    double FTarget = FTable[Fy][Fx];
1713    if (Config->MagicSamples > 0 && TotalDims >= Config->MagicSamples * (1.0 - kMagicSampleMargin) &&
1714        TotalDims <= Config->MagicSamples * (1.0 + kMagicSampleMargin)) {
1715      FTarget += kFTableBoostMargin;
1716    }
1717    if (F < FTarget) {
1718      return NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1719    }
1720    return nullptr;
1721  }
1722  static PROTOTYPE *MakeSphericalProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1723                                       BUCKETS *Buckets) {
1724    PROTOTYPE *Proto = nullptr;
1725    int i;
1726    for (i = 0; i < Clusterer->SampleSize; i++) {
1727      if (Clusterer->ParamDesc[i].NonEssential) {
1728        continue;
1729      }
1730      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1731                  sqrt(static_cast<double>(Statistics->AvgVariance)));
1732      if (!DistributionOK(Buckets)) {
1733        break;
1734      }
1735    }
1736    if (i >= Clusterer->SampleSize) {
1737      Proto = NewSphericalProto(Clusterer->SampleSize, Cluster, Statistics);
1738    }
1739    return (Proto);
1740  } 
1741  static PROTOTYPE *MakeEllipticalProto(CLUSTERER *Clusterer, CLUSTER *Cluster,
1742                                        STATISTICS *Statistics, BUCKETS *Buckets) {
1743    PROTOTYPE *Proto = nullptr;
1744    int i;
1745    for (i = 0; i < Clusterer->SampleSize; i++) {
1746      if (Clusterer->ParamDesc[i].NonEssential) {
1747        continue;
1748      }
1749      FillBuckets(Buckets, Cluster, i, &(Clusterer->ParamDesc[i]), Cluster->Mean[i],
1750                  sqrt(static_cast<double>(Statistics->CoVariance[i * (Clusterer->SampleSize + 1)])));
1751      if (!DistributionOK(Buckets)) {
1752        break;
1753      }
1754    }
1755    if (i >= Clusterer->SampleSize) {
1756      Proto = NewEllipticalProto(Clusterer->SampleSize, Cluster, Statistics);
1757    }
1758    return (Proto);
1759  } 
1760  static PROTOTYPE *MakeMixedProto(CLUSTERER *Clusterer, CLUSTER *Cluster, STATISTICS *Statistics,
1761                                   BUCKETS *NormalBuckets, double Confidence) {
1762    PROTOTYPE *Proto;
1763    int i;
1764    BUCKETS *UniformBuckets = nullptr;
1765    BUCKETS *RandomBuckets = nullptr;
1766    Proto = NewMixedProto(Clusterer->SampleSize, Cluster, Statistics);
1767    for (i = 0; i < Clusterer->SampleSize; i++) {
1768      if (Clusterer->ParamDesc[i].NonEssential) {
1769        continue;
1770      }
1771      FillBuckets(NormalBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1772                  std::sqrt(Proto->Variance.Elliptical[i]));
1773      if (DistributionOK(NormalBuckets)) {
1774        continue;
1775      }
1776      if (RandomBuckets == nullptr) {
1777        RandomBuckets = GetBuckets(Clusterer, D_random, Cluster->SampleCount, Confidence);
1778      }
1779      MakeDimRandom(i, Proto, &(Clusterer->ParamDesc[i]));
1780      FillBuckets(RandomBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1781                  Proto->Variance.Elliptical[i]);
1782      if (DistributionOK(RandomBuckets)) {
1783        continue;
1784      }
1785      if (UniformBuckets == nullptr) {
1786        UniformBuckets = GetBuckets(Clusterer, uniform, Cluster->SampleCount, Confidence);
1787      }
1788      MakeDimUniform(i, Proto, Statistics);
1789      FillBuckets(UniformBuckets, Cluster, i, &(Clusterer->ParamDesc[i]), Proto->Mean[i],
1790                  Proto->Variance.Elliptical[i]);
1791      if (DistributionOK(UniformBuckets)) {
1792        continue;
1793      }
1794      break;
1795    }
1796    if (i < Clusterer->SampleSize) {
1797      FreePrototype(Proto);
1798      Proto = nullptr;
1799    }
1800    return (Proto);
1801  } 
1802  static void MakeDimRandom(uint16_t i, PROTOTYPE *Proto, PARAM_DESC *ParamDesc) {
1803    Proto->Distrib[i] = D_random;
1804    Proto->Mean[i] = ParamDesc->MidRange;
1805    Proto->Variance.Elliptical[i] = ParamDesc->HalfRange;
1806    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1807    Proto->Magnitude.Elliptical[i] = 1.0 / ParamDesc->Range;
1808    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1809    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1810  } 
1811  static void MakeDimUniform(uint16_t i, PROTOTYPE *Proto, STATISTICS *Statistics) {
1812    Proto->Distrib[i] = uniform;
1813    Proto->Mean[i] = Proto->Cluster->Mean[i] + (Statistics->Min[i] + Statistics->Max[i]) / 2;
1814    Proto->Variance.Elliptical[i] = (Statistics->Max[i] - Statistics->Min[i]) / 2;
1815    if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1816      Proto->Variance.Elliptical[i] = MINVARIANCE;
1817    }
1818    Proto->TotalMagnitude /= Proto->Magnitude.Elliptical[i];
1819    Proto->Magnitude.Elliptical[i] = 1.0 / (2.0 * Proto->Variance.Elliptical[i]);
1820    Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1821    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1822  } 
1823  static STATISTICS *ComputeStatistics(int16_t N, PARAM_DESC ParamDesc[], CLUSTER *Cluster) {
1824    int i, j;
1825    LIST SearchState;
1826    SAMPLE *Sample;
1827    uint32_t SampleCountAdjustedForBias;
1828    auto Statistics = new STATISTICS(N);
1829    std::vector<float> Distance(N);
1830    InitSampleSearch(SearchState, Cluster);
1831    while ((Sample = NextSample(&SearchState)) != nullptr) {
1832      for (i = 0; i < N; i++) {
1833        Distance[i] = Sample->Mean[i] - Cluster->Mean[i];
1834        if (ParamDesc[i].Circular) {
1835          if (Distance[i] > ParamDesc[i].HalfRange) {
1836            Distance[i] -= ParamDesc[i].Range;
1837          }
1838          if (Distance[i] < -ParamDesc[i].HalfRange) {
1839            Distance[i] += ParamDesc[i].Range;
1840          }
1841        }
1842        if (Distance[i] < Statistics->Min[i]) {
1843          Statistics->Min[i] = Distance[i];
1844        }
1845        if (Distance[i] > Statistics->Max[i]) {
1846          Statistics->Max[i] = Distance[i];
1847        }
1848      }
1849      auto CoVariance = &Statistics->CoVariance[0];
1850      for (i = 0; i < N; i++) {
1851        for (j = 0; j < N; j++, CoVariance++) {
1852          *CoVariance += Distance[i] * Distance[j];
1853        }
1854      }
1855    }
1856    if (Cluster->SampleCount > 1) {
1857      SampleCountAdjustedForBias = Cluster->SampleCount - 1;
1858    } else {
1859      SampleCountAdjustedForBias = 1;
1860    }
1861    auto CoVariance = &Statistics->CoVariance[0];
1862    for (i = 0; i < N; i++) {
1863      for (j = 0; j < N; j++, CoVariance++) {
1864        *CoVariance /= SampleCountAdjustedForBias;
1865        if (j == i) {
1866          if (*CoVariance < MINVARIANCE) {
1867            *CoVariance = MINVARIANCE;
1868          }
1869          Statistics->AvgVariance *= *CoVariance;
1870        }
1871      }
1872    }
1873    Statistics->AvgVariance =
1874        static_cast<float>(pow(static_cast<double>(Statistics->AvgVariance), 1.0 / N));
1875    return Statistics;
1876  } 
1877  static PROTOTYPE *NewSphericalProto(uint16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1878    PROTOTYPE *Proto;
1879    Proto = NewSimpleProto(N, Cluster);
1880    Proto->Variance.Spherical = Statistics->AvgVariance;
1881    if (Proto->Variance.Spherical < MINVARIANCE) {
1882      Proto->Variance.Spherical = MINVARIANCE;
1883    }
1884    Proto->Magnitude.Spherical = 1.0 / sqrt(2.0 * M_PI * Proto->Variance.Spherical);
1885    Proto->TotalMagnitude = static_cast<float>(
1886        pow(static_cast<double>(Proto->Magnitude.Spherical), static_cast<double>(N)));
1887    Proto->Weight.Spherical = 1.0 / Proto->Variance.Spherical;
1888    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1889    return (Proto);
1890  } 
1891  static PROTOTYPE *NewEllipticalProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1892    PROTOTYPE *Proto;
1893    int i;
1894    Proto = NewSimpleProto(N, Cluster);
1895    Proto->Variance.Elliptical = new float[N];
1896    Proto->Magnitude.Elliptical = new float[N];
1897    Proto->Weight.Elliptical = new float[N];
1898    auto CoVariance = &Statistics->CoVariance[0];
1899    Proto->TotalMagnitude = 1.0;
1900    for (i = 0; i < N; i++, CoVariance += N + 1) {
1901      Proto->Variance.Elliptical[i] = *CoVariance;
1902      if (Proto->Variance.Elliptical[i] < MINVARIANCE) {
1903        Proto->Variance.Elliptical[i] = MINVARIANCE;
1904      }
1905      Proto->Magnitude.Elliptical[i] = 1.0f / sqrt(2.0f * M_PI * Proto->Variance.Elliptical[i]);
1906      Proto->Weight.Elliptical[i] = 1.0f / Proto->Variance.Elliptical[i];
1907      Proto->TotalMagnitude *= Proto->Magnitude.Elliptical[i];
1908    }
1909    Proto->LogMagnitude = log(static_cast<double>(Proto->TotalMagnitude));
1910    Proto->Style = elliptical;
1911    return (Proto);
1912  } 
1913  static PROTOTYPE *NewMixedProto(int16_t N, CLUSTER *Cluster, STATISTICS *Statistics) {
1914    auto Proto = NewEllipticalProto(N, Cluster, Statistics);
1915    Proto->Distrib.clear();
1916    Proto->Distrib.resize(N, normal);
1917    Proto->Style = mixed;
1918    return Proto;
1919  } 
1920  static PROTOTYPE *NewSimpleProto(int16_t N, CLUSTER *Cluster) {
1921    auto Proto = new PROTOTYPE;
1922    Proto->Mean = Cluster->Mean;
1923    Proto->Distrib.clear();
1924    Proto->Significant = true;
1925    Proto->Merged = false;
1926    Proto->Style = spherical;
1927    Proto->NumSamples = Cluster->SampleCount;
1928    Proto->Cluster = Cluster;
1929    Proto->Cluster->Prototype = true;
1930    return Proto;
1931  } 
1932  static bool Independent(PARAM_DESC *ParamDesc, int16_t N, float *CoVariance, float Independence) {
1933    int i, j;
1934    float *VARii; 
1935    float *VARjj; 
1936    float CorrelationCoeff;
1937    VARii = CoVariance;
1938    for (i = 0; i < N; i++, VARii += N + 1) {
1939      if (ParamDesc[i].NonEssential) {
1940        continue;
1941      }
1942      VARjj = VARii + N + 1;
1943      CoVariance = VARii + 1;
1944      for (j = i + 1; j < N; j++, CoVariance++, VARjj += N + 1) {
<span onclick='openModal()' class='match'>1945        if (ParamDesc[j].NonEssential) {
1946          continue;
1947        }
1948        if ((*VARii == 0.0) || (*VARjj == 0.0)) {
1949          CorrelationCoeff = 0.0;
1950        } else {
</span>1951          CorrelationCoeff = sqrt(std::sqrt(*CoVariance * *CoVariance / (*VARii * *VARjj)));
1952        }
1953        if (CorrelationCoeff > Independence) {
1954          return false;
1955        }
1956      }
1957    }
1958    return true;
1959  } 
1960  static BUCKETS *GetBuckets(CLUSTERER *clusterer, DISTRIBUTION Distribution, uint32_t SampleCount,
1961                             double Confidence) {
1962    uint16_t NumberOfBuckets = OptimumNumberOfBuckets(SampleCount);
1963    BUCKETS *Buckets = clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS];
1964    if (Buckets == nullptr) {
1965      Buckets = MakeBuckets(Distribution, SampleCount, Confidence);
1966      clusterer->bucket_cache[Distribution][NumberOfBuckets - MINBUCKETS] = Buckets;
1967    } else {
1968      if (SampleCount != Buckets->SampleCount) {
1969        AdjustBuckets(Buckets, SampleCount);
1970      }
1971      if (Confidence != Buckets->Confidence) {
1972        Buckets->Confidence = Confidence;
1973        Buckets->ChiSquared =
1974            ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1975      }
1976      InitBuckets(Buckets);
1977    }
1978    return Buckets;
1979  } 
1980  static BUCKETS *MakeBuckets(DISTRIBUTION Distribution, uint32_t SampleCount, double Confidence) {
1981    const DENSITYFUNC DensityFunction[] = {NormalDensity, UniformDensity, UniformDensity};
1982    int i, j;
1983    double BucketProbability;
1984    double NextBucketBoundary;
1985    double Probability;
1986    double ProbabilityDelta;
1987    double LastProbDensity;
1988    double ProbDensity;
1989    uint16_t CurrentBucket;
1990    bool Symmetrical;
1991    auto Buckets = new BUCKETS(OptimumNumberOfBuckets(SampleCount));
1992    Buckets->SampleCount = SampleCount;
1993    Buckets->Confidence = Confidence;
1994    Buckets->Distribution = Distribution;
1995    Symmetrical = true;
1996    Buckets->ChiSquared =
1997        ComputeChiSquared(DegreesOfFreedom(Distribution, Buckets->NumberOfBuckets), Confidence);
1998    if (Symmetrical) {
1999      BucketProbability = 1.0 / static_cast<double>(Buckets->NumberOfBuckets);
2000      CurrentBucket = Buckets->NumberOfBuckets / 2;
2001      if (Odd(Buckets->NumberOfBuckets)) {
2002        NextBucketBoundary = BucketProbability / 2;
2003      } else {
2004        NextBucketBoundary = BucketProbability;
2005      }
2006      Probability = 0.0;
2007      LastProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(BUCKETTABLESIZE / 2);
2008      for (i = BUCKETTABLESIZE / 2; i < BUCKETTABLESIZE; i++) {
2009        ProbDensity = (*DensityFunction[static_cast<int>(Distribution)])(i + 1);
2010        ProbabilityDelta = Integral(LastProbDensity, ProbDensity, 1.0);
2011        Probability += ProbabilityDelta;
2012        if (Probability > NextBucketBoundary) {
2013          if (CurrentBucket < Buckets->NumberOfBuckets - 1) {
2014            CurrentBucket++;
2015          }
2016          NextBucketBoundary += BucketProbability;
2017        }
2018        Buckets->Bucket[i] = CurrentBucket;
2019        Buckets->ExpectedCount[CurrentBucket] += static_cast<float>(ProbabilityDelta * SampleCount);
2020        LastProbDensity = ProbDensity;
2021      }
2022      Buckets->ExpectedCount[CurrentBucket] += static_cast<float>((0.5 - Probability) * SampleCount);
2023      for (i = 0, j = BUCKETTABLESIZE - 1; i < j; i++, j--) {
2024        Buckets->Bucket[i] = Mirror(Buckets->Bucket[j], Buckets->NumberOfBuckets);
2025      }
2026      for (i = 0, j = Buckets->NumberOfBuckets - 1; i <= j; i++, j--) {
2027        Buckets->ExpectedCount[i] += Buckets->ExpectedCount[j];
2028      }
2029    }
2030    return Buckets;
2031  } 
2032  static uint16_t OptimumNumberOfBuckets(uint32_t SampleCount) {
2033    uint8_t Last, Next;
2034    float Slope;
2035    if (SampleCount < kCountTable[0]) {
2036      return kBucketsTable[0];
2037    }
2038    for (Last = 0, Next = 1; Next < LOOKUPTABLESIZE; Last++, Next++) {
2039      if (SampleCount <= kCountTable[Next]) {
2040        Slope = static_cast<float>(kBucketsTable[Next] - kBucketsTable[Last]) /
2041                static_cast<float>(kCountTable[Next] - kCountTable[Last]);
2042        return (
2043            static_cast<uint16_t>(kBucketsTable[Last] + Slope * (SampleCount - kCountTable[Last])));
2044      }
2045    }
2046    return kBucketsTable[Last];
2047  } 
2048  static double ComputeChiSquared(uint16_t DegreesOfFreedom, double Alpha)
2049  #define CHIACCURACY 0.01
2050  #define MINALPHA (1e-200)
2051  {
2052    static LIST ChiWith[MAXDEGREESOFFREEDOM + 1];
2053    Alpha = ClipToRange(Alpha, MINALPHA, 1.0);
2054    if (Odd(DegreesOfFreedom)) {
2055      DegreesOfFreedom++;
2056    }
2057    CHISTRUCT SearchKey(0.0, Alpha);
2058    auto *found = search(ChiWith[DegreesOfFreedom], &SearchKey, AlphaMatch);
2059    auto OldChiSquared = reinterpret_cast<CHISTRUCT *>(found ? found->first_node() : nullptr);
2060    if (OldChiSquared == nullptr) {
2061      OldChiSquared = new CHISTRUCT(DegreesOfFreedom, Alpha);
2062      OldChiSquared->ChiSquared =
2063          Solve(ChiArea, OldChiSquared, static_cast<double>(DegreesOfFreedom), CHIACCURACY);
2064      ChiWith[DegreesOfFreedom] = push(ChiWith[DegreesOfFreedom], OldChiSquared);
2065    } else {
2066    }
2067    return (OldChiSquared->ChiSquared);
2068  } 
2069  static double NormalDensity(int32_t x) {
2070    double Distance;
2071    Distance = x - kNormalMean;
2072    return kNormalMagnitude * exp(-0.5 * Distance * Distance / kNormalVariance);
2073  } 
2074  static double UniformDensity(int32_t x) {
2075    constexpr auto UniformDistributionDensity = 1.0 / BUCKETTABLESIZE;
2076    if ((x >= 0) && (x <= BUCKETTABLESIZE)) {
2077      return UniformDistributionDensity;
2078    } else {
2079      return 0.0;
2080    }
2081  } 
2082  static double Integral(double f1, double f2, double Dx) {
2083    return (f1 + f2) * Dx / 2.0;
2084  } 
2085  static void FillBuckets(BUCKETS *Buckets, CLUSTER *Cluster, uint16_t Dim, PARAM_DESC *ParamDesc,
2086                          float Mean, float StdDev) {
2087    uint16_t BucketID;
2088    int i;
2089    LIST SearchState;
2090    SAMPLE *Sample;
2091    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2092      Buckets->Count[i] = 0;
2093    }
2094    if (StdDev == 0.0) {
2095      InitSampleSearch(SearchState, Cluster);
2096      i = 0;
2097      while ((Sample = NextSample(&SearchState)) != nullptr) {
2098        if (Sample->Mean[Dim] > Mean) {
2099          BucketID = Buckets->NumberOfBuckets - 1;
2100        } else if (Sample->Mean[Dim] < Mean) {
2101          BucketID = 0;
2102        } else {
2103          BucketID = i;
2104        }
2105        Buckets->Count[BucketID] += 1;
2106        i++;
2107        if (i >= Buckets->NumberOfBuckets) {
2108          i = 0;
2109        }
2110      }
2111    } else {
2112      InitSampleSearch(SearchState, Cluster);
2113      while ((Sample = NextSample(&SearchState)) != nullptr) {
2114        switch (Buckets->Distribution) {
2115          case normal:
2116            BucketID = NormalBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2117            break;
2118          case D_random:
2119          case uniform:
2120            BucketID = UniformBucket(ParamDesc, Sample->Mean[Dim], Mean, StdDev);
2121            break;
2122          default:
2123            BucketID = 0;
2124        }
2125        Buckets->Count[Buckets->Bucket[BucketID]] += 1;
2126      }
2127    }
2128  } 
2129  static uint16_t NormalBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2130    float X;
2131    if (ParamDesc->Circular) {
2132      if (x - Mean > ParamDesc->HalfRange) {
2133        x -= ParamDesc->Range;
2134      } else if (x - Mean < -ParamDesc->HalfRange) {
2135        x += ParamDesc->Range;
2136      }
2137    }
2138    X = ((x - Mean) / StdDev) * kNormalStdDev + kNormalMean;
2139    if (X < 0) {
2140      return 0;
2141    }
2142    if (X > BUCKETTABLESIZE - 1) {
2143      return (static_cast<uint16_t>(BUCKETTABLESIZE - 1));
2144    }
2145    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2146  } 
2147  static uint16_t UniformBucket(PARAM_DESC *ParamDesc, float x, float Mean, float StdDev) {
2148    float X;
2149    if (ParamDesc->Circular) {
2150      if (x - Mean > ParamDesc->HalfRange) {
2151        x -= ParamDesc->Range;
2152      } else if (x - Mean < -ParamDesc->HalfRange) {
2153        x += ParamDesc->Range;
2154      }
2155    }
2156    X = ((x - Mean) / (2 * StdDev) * BUCKETTABLESIZE + BUCKETTABLESIZE / 2.0);
2157    if (X < 0) {
2158      return 0;
2159    }
2160    if (X > BUCKETTABLESIZE - 1) {
2161      return static_cast<uint16_t>(BUCKETTABLESIZE - 1);
2162    }
2163    return static_cast<uint16_t>(floor(static_cast<double>(X)));
2164  } 
2165  static bool DistributionOK(BUCKETS *Buckets) {
2166    float FrequencyDifference;
2167    float TotalDifference;
2168    int i;
2169    TotalDifference = 0.0;
2170    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2171      FrequencyDifference = Buckets->Count[i] - Buckets->ExpectedCount[i];
2172      TotalDifference += (FrequencyDifference * FrequencyDifference) / Buckets->ExpectedCount[i];
2173    }
2174    if (TotalDifference > Buckets->ChiSquared) {
2175      return false;
2176    } else {
2177      return true;
2178    }
2179  } 
2180  static uint16_t DegreesOfFreedom(DISTRIBUTION Distribution, uint16_t HistogramBuckets) {
2181    static uint8_t DegreeOffsets[] = {3, 3, 1};
2182    uint16_t AdjustedNumBuckets;
2183    AdjustedNumBuckets = HistogramBuckets - DegreeOffsets[static_cast<int>(Distribution)];
2184    if (Odd(AdjustedNumBuckets)) {
2185      AdjustedNumBuckets++;
2186    }
2187    return (AdjustedNumBuckets);
2188  } 
2189  static void AdjustBuckets(BUCKETS *Buckets, uint32_t NewSampleCount) {
2190    int i;
2191    double AdjustFactor;
2192    AdjustFactor =
2193        ((static_cast<double>(NewSampleCount)) / (static_cast<double>(Buckets->SampleCount)));
2194    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2195      Buckets->ExpectedCount[i] *= AdjustFactor;
2196    }
2197    Buckets->SampleCount = NewSampleCount;
2198  } 
2199  static void InitBuckets(BUCKETS *Buckets) {
2200    int i;
2201    for (i = 0; i < Buckets->NumberOfBuckets; i++) {
2202      Buckets->Count[i] = 0;
2203    }
2204  } 
2205  static int AlphaMatch(void *arg1,   
2206                        void *arg2) { 
2207    auto *ChiStruct = static_cast<CHISTRUCT *>(arg1);
2208    auto *SearchKey = static_cast<CHISTRUCT *>(arg2);
2209    return (ChiStruct->Alpha == SearchKey->Alpha);
2210  } 
2211  static double Solve(SOLVEFUNC Function, void *FunctionParams, double InitialGuess, double Accuracy)
2212  #define INITIALDELTA 0.1
2213  #define DELTARATIO 0.1
2214  {
2215    double x;
2216    double f;
2217    double Slope;
2218    double Delta;
2219    double NewDelta;
2220    double xDelta;
2221    double LastPosX, LastNegX;
2222    x = InitialGuess;
2223    Delta = INITIALDELTA;
2224    LastPosX = FLT_MAX;
2225    LastNegX = -FLT_MAX;
2226    f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2227    while (Abs(LastPosX - LastNegX) > Accuracy) {
2228      if (f < 0) {
2229        LastNegX = x;
2230      } else {
2231        LastPosX = x;
2232      }
2233      Slope = ((*Function)(static_cast<CHISTRUCT *>(FunctionParams), x + Delta) - f) / Delta;
2234      xDelta = f / Slope;
2235      x -= xDelta;
2236      NewDelta = Abs(xDelta) * DELTARATIO;
2237      if (NewDelta < Delta) {
2238        Delta = NewDelta;
2239      }
2240      f = (*Function)(static_cast<CHISTRUCT *>(FunctionParams), x);
2241    }
2242    return (x);
2243  } 
2244  static double ChiArea(CHISTRUCT *ChiParams, double x) {
2245    int i, N;
2246    double SeriesTotal;
2247    double Denominator;
2248    double PowerOfx;
2249    N = ChiParams->DegreesOfFreedom / 2 - 1;
2250    SeriesTotal = 1;
2251    Denominator = 1;
2252    PowerOfx = 1;
2253    for (i = 1; i <= N; i++) {
2254      Denominator *= 2 * i;
2255      PowerOfx *= x;
2256      SeriesTotal += PowerOfx / Denominator;
2257    }
2258    return ((SeriesTotal * exp(-0.5 * x)) - ChiParams->Alpha);
2259  } 
2260  static bool MultipleCharSamples(CLUSTERER *Clusterer, CLUSTER *Cluster, float MaxIllegal)
2261  #define ILLEGAL_CHAR 2
2262  {
2263    static std::vector<uint8_t> CharFlags;
2264    LIST SearchState;
2265    SAMPLE *Sample;
2266    int32_t CharID;
2267    int32_t NumCharInCluster;
2268    int32_t NumIllegalInCluster;
2269    float PercentIllegal;
2270    NumCharInCluster = Cluster->SampleCount;
2271    NumIllegalInCluster = 0;
2272    if (Clusterer->NumChar > CharFlags.size()) {
2273      CharFlags.resize(Clusterer->NumChar);
2274    }
2275    for (auto &CharFlag : CharFlags) {
2276      CharFlag = false;
2277    }
2278    InitSampleSearch(SearchState, Cluster);
2279    while ((Sample = NextSample(&SearchState)) != nullptr) {
2280      CharID = Sample->CharID;
2281      if (CharFlags[CharID] == false) {
2282        CharFlags[CharID] = true;
2283      } else {
2284        if (CharFlags[CharID] == true) {
2285          NumIllegalInCluster++;
2286          CharFlags[CharID] = ILLEGAL_CHAR;
2287        }
2288        NumCharInCluster--;
2289        PercentIllegal = static_cast<float>(NumIllegalInCluster) / NumCharInCluster;
2290        if (PercentIllegal > MaxIllegal) {
2291          destroy(SearchState);
2292          return true;
2293        }
2294      }
2295    }
2296    return false;
2297  } 
2298  static double InvertMatrix(const float *input, int size, float *inv) {
2299    GENERIC_2D_ARRAY<double> U(size, size, 0.0);
2300    GENERIC_2D_ARRAY<double> U_inv(size, size, 0.0);
2301    GENERIC_2D_ARRAY<double> L(size, size, 0.0);
2302    int row;
2303    int col;
2304    for (row = 0; row < size; row++) {
2305      for (col = 0; col < size; col++) {
2306        U[row][col] = input[row * size + col];
2307        L[row][col] = row == col ? 1.0 : 0.0;
2308        U_inv[row][col] = 0.0;
2309      }
2310    }
2311    for (col = 0; col < size; ++col) {
2312      int best_row = 0;
2313      double best_pivot = -1.0;
2314      for (row = col; row < size; ++row) {
2315        if (Abs(U[row][col]) > best_pivot) {
2316          best_pivot = Abs(U[row][col]);
2317          best_row = row;
2318        }
2319      }
2320      if (best_row != col) {
2321        for (int k = 0; k < size; ++k) {
2322          double tmp = U[best_row][k];
2323          U[best_row][k] = U[col][k];
2324          U[col][k] = tmp;
2325          tmp = L[best_row][k];
2326          L[best_row][k] = L[col][k];
2327          L[col][k] = tmp;
2328        }
2329      }
2330      for (row = col + 1; row < size; ++row) {
2331        double ratio = -U[row][col] / U[col][col];
2332        for (int j = col; j < size; ++j) {
2333          U[row][j] += U[col][j] * ratio;
2334        }
2335        for (int k = 0; k < size; ++k) {
2336          L[row][k] += L[col][k] * ratio;
2337        }
2338      }
2339    }
2340    for (col = 0; col < size; ++col) {
2341      U_inv[col][col] = 1.0 / U[col][col];
2342      for (row = col - 1; row >= 0; --row) {
2343        double total = 0.0;
2344        for (int k = col; k > row; --k) {
2345          total += U[row][k] * U_inv[k][col];
2346        }
2347        U_inv[row][col] = -total / U[row][row];
2348      }
2349    }
2350    for (row = 0; row < size; row++) {
2351      for (col = 0; col < size; col++) {
2352        double sum = 0.0;
2353        for (int k = row; k < size; ++k) {
2354          sum += U_inv[row][k] * L[k][col];
2355        }
2356        inv[row * size + col] = sum;
2357      }
2358    }
2359    double error_sum = 0.0;
2360    for (row = 0; row < size; row++) {
2361      for (col = 0; col < size; col++) {
2362        double sum = 0.0;
2363        for (int k = 0; k < size; ++k) {
2364          sum += static_cast<double>(input[row * size + k]) * inv[k * size + col];
2365        }
2366        if (row != col) {
2367          error_sum += Abs(sum);
2368        }
2369      }
2370    }
2371    return error_sum;
2372  }
2373  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</h3>
            <pre><code>1  TStr TGixConst::WdGixFNm = "WdGix";
2  TStr TGixConst::WdGixDatFNm = "WdGix.Dat";
3  TStr TGixConst::WdGixBsFNm = "WdGixBs.MBlobBs";
4  TStr TGixConst::WdGixMDSFNm = "WdGixMDS.Dat";
5  TStr TGixConst::TrGixFNm = "TrGix";
6  TStr TGixConst::TrGixDatFNm = "TrGix.Dat";
7  TStr TGixConst::TrGixDocBsFNm = "TrGixDocBs.MBlobBs";
8  TStr TGixConst::TrGixSentBsFNm = "TrGixSentBs.MBlobBs";
9  TStr TGixConst::TrGixTrAttrBsFNm = "TrGixTrAttrBs.MBlobBs";
10  TStr TGixConst::MWdGixFNm = "MWdGix";
11  TStr TGixConst::MWdGixDatFNm = "MWdGix.Dat";
12  TStr TGixConst::MWdGixDocBsFNm = "MWdGixDocBs.MBlobBs";
13  TStr TGixConst::MWdGixBsFNm = "MWdGixBs.Dat";
14  int TWdGixItem::TitleBit = 0;
15  int TWdGixItem::NmObjBit = 1;
16  int TWdGixItem::AnchorBit = 2;
17  int TWdGixItem::EmphBit = 3;
18  TWdGixItem::TWdGixItem(const TBlobPt& BlobPt, const uchar& _Wgt, const uchar& _WdPos,
19          const bool& TitleP, const bool& NmObjP, const bool& AnchorP, const bool& EmphP):
20              Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()), WdPos(_WdPos) {
21      FSet.SetBit(TitleBit, TitleP);
22      FSet.SetBit(NmObjBit, NmObjP);
23      FSet.SetBit(AnchorBit, AnchorP);
24      FSet.SetBit(EmphBit, EmphP);
25  }
26  TWdGixItem::TWdGixItem(const uchar& _Seg, const uint& _Addr, const uchar& _Wgt,
27          const uchar& _WdPos, const bool& TitleP, const bool& NmObjP, const bool& AnchorP,
28          const bool& EmphP): Seg(_Seg), Addr(_Addr), Wgt(_Wgt), WdPos(_WdPos) {
29      FSet.SetBit(TitleBit, TitleP);
30      FSet.SetBit(NmObjBit, NmObjP);
31      FSet.SetBit(AnchorBit, AnchorP);
32      FSet.SetBit(EmphBit, EmphP);
33  }
34  TWdGixItem::TWdGixItem(TSIn& SIn) {
35      SIn.Load(Seg); SIn.Load(Addr);
36      SIn.Load(Wgt); SIn.Load(WdPos); FSet=TB8Set(SIn);
37  }
38  void TWdGixItem::Save(TSOut& SOut) const {
39      SOut.Save(Seg); SOut.Save(Addr);
40      SOut.Save(Wgt); SOut.Save(WdPos); FSet.Save(SOut);
41  }
42  inline bool TWdGixItem::operator==(const TWdGixItem& Item) const {
43      return (Seg == Item.Seg) && (Addr == Item.Addr); 
44  }
45  inline bool TWdGixItem::operator<(const TWdGixItem& Item) const {
46      return (Seg < Item.Seg) ||
47          ((Seg == Item.Seg) && (Addr < Item.Addr)); 
48  }
49  void TWdGix::LoadTags() {
50      TitleTagH.AddKey("<TITLE>");
51      NmObjTagH.AddKey("<NMOBJ>");
52      EmphTagH.AddKey("<EM>"); EmphTagH.AddKey("<A>"); EmphTagH.AddKey("<B>");
53      EmphTagH.AddKey("<I>"); EmphTagH.AddKey("<H1>"); EmphTagH.AddKey("<H2>");
54      EmphTagH.AddKey("<H3>"); EmphTagH.AddKey("<H4>"); EmphTagH.AddKey("<H5>");
55  }
56  TWdGix::TWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
57      FPath = _FPath; FAccess = _FAccess;
58      WGix = TWGix::New(TGixConst::WdGixFNm, FPath, FAccess, CacheSize);
59      if (FAccess == faCreate) {
60          Stemmer = TStemmer::New(stmtPorter, false);
61          SwSet = TSwSet::New(swstEn523);
62      } else {
63          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
64          TFIn FIn(WdGixDatFNm);
65          WordH.Load(FIn);
66          Stemmer = TStemmer::Load(FIn);
67          SwSet = TSwSet::Load(FIn);
68      }
69      LoadTags();
70  }
71  TWdGix::~TWdGix() {
72      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
73          TStr WdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixDatFNm;
74          TFOut FOut(WdGixDatFNm);
75          WordH.Save(FOut);
76          Stemmer->Save(FOut);
77          SwSet->Save(FOut);
78      }
79  }
80  void TWdGix::AddHtml(const TStr& HtmlStr, const TBlobPt& BlobPt, const uchar& Wgt) {
81      PSIn HtmlSIn = TStrIn::New(HtmlStr);
82      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
83      THash<TInt, TWdGixItemV> WIdToItemVH; uchar WdPos = 0;
84      bool TitleP = false, NmObjP = false; int EmphLv = 0;
85      while (HtmlLx.Sym != hsyEof) {
86          if (HtmlLx.Sym == hsyStr) {
87              TStr WordStr = HtmlLx.UcChA;
88              if (!SwSet->IsIn(WordStr)) {
89                  WordStr=Stemmer->GetStem(WordStr);
90                  const int WId = WordH.AddKey(WordStr);
91                  WdPos++;
92                  WIdToItemVH.AddDat(WId).Add(
93                      TWdGixItem(BlobPt, Wgt, WdPos, TitleP, NmObjP, false, (EmphLv>0)));
94              }
95          } else if (HtmlLx.Sym == hsyBTag) {
96              TStr TagStr = HtmlLx.UcChA;
97              if (TitleTagH.IsKey(TagStr)) { TitleP = true; }
98              if (NmObjTagH.IsKey(TagStr)) { NmObjP = true; }
99              if (EmphTagH.IsKey(TagStr)) { EmphLv++; }
100          } else if (HtmlLx.Sym == hsyETag) {
101              TStr TagStr = HtmlLx.UcChA;
102              if (TitleTagH.IsKey(TagStr)) { TitleP = false; }
103              if (NmObjTagH.IsKey(TagStr)) { NmObjP = false; }
104              if (EmphTagH.IsKey(TagStr)) { EmphLv--; EmphLv = TInt::GetMx(0, EmphLv); }
105          }
106          HtmlLx.GetSym();
107      }
108      int WdKeyId = WIdToItemVH.FFirstKeyId();
109      while (WIdToItemVH.FNextKeyId(WdKeyId)) {
110          const int WId = WIdToItemVH.GetKey(WdKeyId); WordH[WId]++;
111          const TWdGixItemV& ItemV = WIdToItemVH[WdKeyId];
112          const uchar Seg = ItemV[0].GetSeg();
113          const uint Addr = ItemV[0].GetAddr();
114          const uchar Count = uchar(TInt::GetMn(int(TUCh::Mx), ItemV.Len()));
115          bool TitleP = false, NmObjP = false, EmphP = false, AnchorP = false;
116          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
117              const TWdGixItem& Item = ItemV[ItemN];
118              TitleP = TitleP || Item.IsTitle();
119              NmObjP = NmObjP || Item.IsNmObj();
120              EmphP = EmphP || Item.IsAnchor();
121              AnchorP = AnchorP || Item.IsEmph();
122          }
123          TWdGixItem Item(Seg, Addr, Wgt, Count, TitleP, NmObjP, AnchorP, EmphP);
124          WGix->AddItem(WId, Item);
125      }
126  }
127  bool TWdGix::Search(const TStr& QueryStr, TWdGixItemV& ResItemV) {
128      PWGixExpItem WGixExp = TWGixExpItem::NewEmpty();
129      PSIn HtmlSIn = TStrIn::New(QueryStr);
130      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
131      while (HtmlLx.Sym != hsyEof) {
132          if (HtmlLx.Sym == hsyStr) {
133              TStr WordStr = HtmlLx.UcChA;
134              WordStr=Stemmer->GetStem(WordStr);
135              const int WId = WordH.GetKeyId(WordStr);
136              if (WId != -1) {
137                  PWGixExpItem WGixExpItem = TWGixExpItem::NewItem(WId);
138                  if (WGixExp->IsEmpty()) { WGixExp = WGixExpItem; }
139                  else { WGixExp = TWGixExpItem::NewAnd(WGixExp, WGixExpItem); }
140              }
141          }
142          HtmlLx.GetSym();
143      }
144      return WGixExp->Eval(WGix, ResItemV);
145  }
146  void TWdGixMDS::AddDate(const TBlobPt& DocBlobPt, const TTm& DateTime) {
147      TAddrPr AddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr());
148      const uint64 DateMSecs = TTm::GetMSecsFromTm(DateTime);
149      AddrPrToDateH.AddDat(AddrPr, DateMSecs);
150  }
151  inline uint64 TWdGixMDS::GetDateMSecs(const TBlobPt& DocBlobPt) const {
152      return AddrPrToDateH.GetDat(TAddrPr(DocBlobPt.GetSeg(), DocBlobPt.GetAddr()));
153  }
154  inline TTm TWdGixMDS::GetDateTTm(const TBlobPt& DocBlobPt) const {
155      return TTm::GetTmFromMSecs(GetDateMSecs(DocBlobPt));
156  }
157  void TWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
158          const TStrV& CatNmV, const TTm& DateTime) {
159      DocTitleV.Add(DocTitle);
160      DocTitleV.Last().DelChAll('\n');
161      DocTitleV.Last().DelChAll('\r');
162      DocStrV.Add(DocStr);
163      CatNmVV.Add(CatNmV);
164      DateTimeV.Add(DateTime);
165  }
166  void TWdGixRSet::SortByDate(const bool& Asc) {
167      typedef TPair<TUInt64, TInt> TUInt64IntPr;
168      TVec<TUInt64IntPr> TmMSecsDocNV;
169      const int Docs = GetDocs();
170      for (int DocN = 0; DocN < Docs; DocN++) {
171          uint64 TmMSecs = TTm::GetMSecsFromTm(DateTimeV[DocN]);
172          TmMSecsDocNV.Add(TUInt64IntPr(TmMSecs, DocN));
173      }
174      TmMSecsDocNV.Sort(Asc);
175      TStrV NewDocTitleV(Docs, 0), NewDocStrV(Docs, 0);
176      TVec<TStrV> NewCatNmVV(Docs, 0); TTmV NewDateTimeV(Docs, 0);
177      for (int NewDocN = 0; NewDocN < Docs; NewDocN++) {
178          const int OldDocN = TmMSecsDocNV[NewDocN].Val2;
179          NewDocTitleV.Add(DocTitleV[OldDocN]);
180          NewDocStrV.Add(DocStrV[OldDocN]);
181          NewCatNmVV.Add(CatNmVV[OldDocN]);
182          NewDateTimeV.Add(DateTimeV[OldDocN]);
183      }
184      DocTitleV = NewDocTitleV; DocStrV = NewDocStrV;
185      CatNmVV = NewCatNmVV; DateTimeV = NewDateTimeV;
186  }
187  void TWdGixRSet::PrintRes(PNotify Notify) {
188      const int Docs = GetDocs();
189      Notify->OnStatus(TStr::Fmt(
190          "All results: %d, Showing results from %d to %d",
191          AllDocs.Val, Docs, Docs + Offset.Val));
192      for (int DocN = 0; DocN < Docs; DocN++) {
193          TTm DateTime = DateTimeV[DocN];
194          if (DateTime.IsDef()) {
195              Notify->OnStatus(TStr::Fmt("[%d: %s] %s ...", DocN+1,
196                  DateTime.GetWebLogDateStr().CStr(),
197                  DocTitleV[DocN].Left(50).CStr()));
198          } else {
199              Notify->OnStatus(TStr::Fmt("[%d] %s ...", DocN+1,
200                  DocTitleV[DocN].Left(60).CStr()));
201          }
202      }
203      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
204          AllDocs.Val, Docs, Docs + Offset.Val));
205  }
206  PBowDocBs TWdGixRSet::GenBowDocBs() const {
207      PSwSet SwSet = TSwSet::New(swstEn523);
208      PStemmer Stemmer = TStemmer::New(stmtPorter, true);
209      PBowDocBs BowDocBs = TBowDocBs::New(SwSet, Stemmer, NULL);
210      const int Docs = GetDocs();
211      for (int DocN = 0; DocN < Docs; DocN++) {
212          const TStr& DocNm = DocTitleV[DocN];
213          const TStr& DocStr = DocStrV[DocN];
214          BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, true);
215      }
216      return BowDocBs;
217  }
218  void TWdGixBs::Filter(const TWgtWdGixItemKdV& InItemV,
219          const TWdGixBsGrouping& Grouping, TWgtWdGixItemKdV& OutItemV) {
220      OutItemV.Clr();
221      if (Grouping == wgbgName) {
222          TStrFltH NameToRankH; TStrH NameToItemNH;
223          const int Items = InItemV.Len();
224          for (int ItemN = 0; ItemN < Items; ItemN++) {
225              TBlobPt BlobPt = InItemV[ItemN].Dat.GetBlobPt();
226              TStr Name = GetDocTitle(BlobPt);
227              const double Rank = InItemV[ItemN].Key;
228              if (NameToRankH.IsKey(Name)) {
229                  const double OldRank = NameToRankH.GetDat(Name);
230                  if (Rank > OldRank) {
231                      NameToRankH.GetDat(Name) = Rank;
232                      NameToItemNH.GetDat(Name) = ItemN;
233                  }
234              } else {
235                  NameToRankH.AddDat(Name) = Rank;
236                  NameToItemNH.AddDat(Name) = ItemN;
237              }
238          }
239          int KeyId = NameToItemNH.FFirstKeyId();
240          while (NameToItemNH.FNextKeyId(KeyId)) {
241              const int ItemN = NameToItemNH[KeyId];
242              OutItemV.Add(InItemV[ItemN]);
243          }
244      } else if (Grouping == wgbgDate) {
245          Fail;
246      } else if (Grouping == wgbgDateTime) {
247          Fail;
248      }
249  }
250  TWdGixBs::TWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
251      FPath = _FPath; FAccess = _FAccess;
252      TStr WdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixBsFNm;
253      DocBBs = TMBlobBs::New(WdGixBsFNm, FAccess);
254      if (FAccess == faCreate) { WdGixMDS = TWdGixMDS::New(); }
255      else {
256          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
257          WdGixMDS = TWdGixMDS::LoadBin(WdGixMDSFNm);
258      }
259      WdGix = TWdGix::New(FPath, FAccess, CacheSize);
260  }
261  TWdGixBs::~TWdGixBs() {
262      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
263          TStr WdGixMDSFNm = TStr::GetNrFPath(FPath) + TGixConst::WdGixMDSFNm;
264          WdGixMDS->SaveBin(WdGixMDSFNm);
265      }
266  }
267  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
268          const TStrV& CatNmV, const TTm& DateTime, const uchar& Wgt) {
269      TMOut DocMOut;
270      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
271      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
272      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
273      WdGix->AddHtml(DocStr, DocBlobPt, Wgt);
274  }
275  void TWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStoreStr,
276          const TStr& DocIndexStr, const TStrV& CatNmV,
277          const TTm& DateTime, const uchar& Wgt) {
278      TMOut DocMOut;
279      DocTitle.Save(DocMOut); DocStoreStr.Save(DocMOut); CatNmV.Save(DocMOut);
280      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
281      if (DateTime.IsDef()) { WdGixMDS->AddDate(DocBlobPt, DateTime); }
282      WdGix->AddHtml(DocIndexStr, DocBlobPt, Wgt);
283  }
284  void TWdGixBs::GetDoc(const TBlobPt& BlobPt,
285          TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
286      PSIn SIn = DocBBs->GetBlob(BlobPt);
287      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
288  }
289  TStr TWdGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
290      PSIn SIn = DocBBs->GetBlob(BlobPt);
291      TStr DocTitle; DocTitle.Load(*SIn);
292      return DocTitle;
293  }
294  TStr TWdGixBs::GetDocStr(const TBlobPt& BlobPt) const {
295      PSIn SIn = DocBBs->GetBlob(BlobPt);
296      {TStr DocTitle; DocTitle.Load(*SIn);}
297      TStr DocStr; DocStr.Load(*SIn);
298      return DocStr;
299  }
300  TStrV TWdGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
301      PSIn SIn = DocBBs->GetBlob(BlobPt);
302      {TStr DocTitle; DocTitle.Load(*SIn);}
303      {TStr DocStr; DocStr.Load(*SIn);}
304      TStrV CatNmV; CatNmV.Load(*SIn);
305      return CatNmV;
306  }
307  PWdGixRSet TWdGixBs::SearchDoc(const TStr& QueryStr,
308          const TWdGixBsGrouping& Grouping, TWdGixRankFun& RankFun,
309          const int& Docs, const int& Offset, const TTm& MnDate,
310          const TTm& MxDate) {
311      printf("  Loading from Gix ...\n");
312      TWdGixItemV ResItemV; WdGix->Search(QueryStr, ResItemV);
313      printf("  Weighting %d hits ...\n", ResItemV.Len());
314      TWgtWdGixItemKdV FullWgtItemV(ResItemV.Len(), 0);
315      const bool CheckMnDateP = MnDate.IsDef();
316      const bool CheckMxDateP = MxDate.IsDef();
317      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
318          const TWdGixItem& Item = ResItemV[ItemN];
319          TTm DateTime = WdGixMDS->GetDateTTm(Item.GetBlobPt());
320          if (CheckMnDateP && DateTime < MnDate) { continue; }
321          if (CheckMxDateP && DateTime > MxDate) { continue; }
322          const double Wgt = RankFun(DateTime, Item.GetWgt(), Item.GetWdPos(),
323              Item.IsTitle(), Item.IsNmObj(), Item.IsAnchor(), Item.IsEmph());
324          FullWgtItemV.Add(TWgtWdGixItemKd(Wgt, Item));
325      }
326      printf("  Filtering ...\n");
327      if (Grouping != wgbgNone) {
328          TWgtWdGixItemKdV TmpWgtItemV;
329          Filter(FullWgtItemV, Grouping, TmpWgtItemV);
330          FullWgtItemV = TmpWgtItemV;
331      }
332      printf("  Sorting %d hits ...\n", FullWgtItemV.Len());
333      TWgtWdGixItemKdV WgtItemV;
334      if (Docs == -1) {
335          WgtItemV = FullWgtItemV;
336      } else if (ResItemV.Len() >= (Docs + Offset)) {
337          WgtItemV = FullWgtItemV;
338          WgtItemV.Sort(false); WgtItemV.Trunc(Docs + Offset);
339          WgtItemV.Sort(true); WgtItemV.Trunc(Docs);
340      } else if (ResItemV.Len() > Offset) {
341          WgtItemV = FullWgtItemV; WgtItemV.Sort(true);
342          WgtItemV.Trunc(FullWgtItemV.Len() - Offset);
343      } else {
344      }
345      WgtItemV.Sort(false);
346      printf("  Loading content for %d hits ...\n", WgtItemV.Len());
347      PWdGixRSet RSet = TWdGixRSet::New(
348          QueryStr, FullWgtItemV.Len(), Offset);
349      for (int ItemN = 0; ItemN < WgtItemV.Len(); ItemN++) {
350          const TWdGixItem& Item = WgtItemV[ItemN].Dat;
351          TBlobPt DocBlobPt = Item.GetBlobPt();
352          TStr DocTitle, DocStr; TStrV CatNmV;
353          GetDoc(DocBlobPt, DocTitle, DocStr, CatNmV);
354          TTm DateTime = WdGixMDS->GetDateTTm(DocBlobPt);
355          RSet->AddDoc(DocTitle, DocStr, CatNmV, DateTime);
356      }
357      printf("  Done\n");
358      return RSet;
359  }
360  void TWdGixBs::AddReuters(const TStr& XmlFNm) {
361      PXmlDoc Doc=TXmlDoc::LoadTxt(XmlFNm);
362      TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
363      TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
364      TChA DocChA; DocChA += "<doc>";
365      TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
366      DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
367      DocChA += "<body>";
368      TStr DocHeadline = Doc->GetTagTok("newsitem|headline")->GetTokStr(false);
369      DocChA += "<p><em>"; DocChA += TXmlDoc::GetXmlStr(DocHeadline); DocChA += "</em></p>\n";
370      TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
371      for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
372          TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
373          TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("enamex", NmObjTokV);
374          for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
375              TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
376              ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
377          }
378          DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
379      }
380      DocChA += "</body></doc>";
381      TStrV CatNmV;
382      TXmlTokV CdsTokV; Doc->GetTagTokV("newsitem|metadata|codes", CdsTokV);
383      for (int CdsTokN = 0; CdsTokN < CdsTokV.Len(); CdsTokN++){
384          PXmlTok CdsTok = CdsTokV[CdsTokN];
385          TXmlTokV CdTokV; CdsTok->GetTagTokV("code", CdTokV);
386          if (CdsTok->GetArgVal("class") == "bip:topics:1.0"){
387              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
388                  TStr CdNm = CdTokV[CdTokN]->GetArgVal("code");
389                  CatNmV.AddMerged(CdNm);
390              }
391          } else if (CdsTok->GetArgVal("class")=="bip:countries:1.0"){
392              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
393                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
394                  CatNmV.AddMerged(CdNm);
395              }
396          } else if (CdsTok->GetArgVal("class")=="bip:industries:1.0"){
397              for (int CdTokN = 0; CdTokN < CdTokV.Len(); CdTokN++){
398                  TStr CdNm=CdTokV[CdTokN]->GetArgVal("code");
399                  CatNmV.AddMerged(CdNm);
400              }
401          } else { Fail; }
402      }
403      AddDoc(DocTitle, DocChA, CatNmV, DateTm);
404  }
405  void TWdGixBs::IndexReuters(const TStr& FPath) {
406      PNotify Notify = TStdNotify::New();
407      Notify->OnStatus("Loading Reuters documents from " + FPath + " ...\n");
408      TFFile FFile(FPath, ".xml", true);
409      TStr XmlFNm; int Files = 0;
410      while (FFile.Next(XmlFNm)) {
411          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm); Files++; }
412          if (Files % 1000 == 0) { Notify->OnStatus(TStr::Fmt("F:%d\r", Files)); }
413      }
414      Notify->OnStatus(TStr::Fmt("F:%d\n", Files));
415  }
416  void TWdGixBs::IndexNmEnBs(const TStr& FNm) {
417      PNotify Notify = TStdNotify::New();
418      Notify->OnStatus("Loading name-entitites from " + FNm + " ...\n");
419      PNmEnBs NmEnBs = TNmEnBs::LoadBin(FNm, true);
420      int NmEnKeyId = NmEnBs->GetFFirstNmEn();
421      int NmEnN = 0; const int NmEns = NmEnBs->GetNmEns();
422      while (NmEnBs->GetFNextNmEn(NmEnKeyId)) {
423          if (NmEnN > 100000) { break; }
424          if (NmEnN % 1000 == 0) { Notify->OnStatus(TStr::Fmt("N:%d/%d\r", NmEnN, NmEns)); }
425          TStr NmEnStr = NmEnBs->GetNmEnStr(NmEnKeyId);
426          IAssertR(NmEnBs->IsNmEn(NmEnStr), NmEnStr);
427          THash<TUInt, TChA> DateIntToCtxH; THash<TUInt, TInt> DateIntToCountH;
428          const TIntV& NmEnCtxIdV = NmEnBs->GetCtxIdV(NmEnKeyId);
429          for (int CtxIdN = 0; CtxIdN < NmEnCtxIdV.Len(); CtxIdN++) {
430              const int CtxId = NmEnCtxIdV[CtxIdN];
431              TStr NmEnCtxStr = NmEnBs->GetCtxStr(CtxId);
432              TTm NmEnCtxTm = NmEnBs->GetCtxTm(CtxId);
433              const uint DateInt = TTm::GetDateIntFromTm(NmEnCtxTm);
434              DateIntToCtxH.AddDat(DateInt) += NmEnCtxStr;
435              DateIntToCountH.AddDat(DateInt)++;
436          }
437          int CtxKeyId = DateIntToCtxH.FFirstKeyId();
438          while (DateIntToCtxH.FNextKeyId(CtxKeyId)) {
439              const int DateInt = DateIntToCtxH.GetKey(CtxKeyId);
440              TTm CtxDate = TTm::GetTmFromDateTimeInt(DateInt);
441              TStr CtxStr = DateIntToCtxH[CtxKeyId];
442              const uchar Wgt = uchar(DateIntToCountH.GetDat(DateInt).Val);
443              AddDoc(NmEnStr, CtxStr, TStrV(), CtxDate, Wgt);
444          }
445          NmEnN++;
446      }
447      Notify->OnStatus(TStr::Fmt("N:%d/%d", NmEnN, NmEns));
448  }
449  void TWdGixBs::IndexNyt(const TStr& XmlFNm) {
450      PNotify Notify = TStdNotify::New();
451      Notify->OnStatus("Loading NYT documents from " + XmlFNm + " ...\n");
452      PSIn SIn = TFIn::New(XmlFNm); int Docs = 0;
453      TStr LastTitle = "";
454      forever {
455          if (Docs % 1000 == 0) { Notify->OnStatus(TStr::Fmt("Docs: %d\r", Docs)); }
456          PXmlDoc Doc = TXmlDoc::LoadTxt(SIn); Docs++;
457          if (!Doc->IsOk()) { printf("%s - %s\n", LastTitle.CStr(), Doc->GetMsgStr().CStr()); break; }
458          TStr DateStr = Doc->GetTagTok("newsitem")->GetArgVal("date");
459          TTm DateTm = TTm::GetTmFromWebLogDateTimeStr(DateStr, '-');
460          TChA DocChA; DocChA += "<doc>";
461          TStr DocTitle = Doc->GetTagTok("newsitem|title")->GetTokStr(false);
462          DocChA += "<title>"; DocChA += TXmlDoc::GetXmlStr(DocTitle); DocChA += "</title>";
463          DocChA += "<body>";
464          TXmlTokV ParTokV; Doc->GetTagTokV("newsitem|text|p", ParTokV);
465          for (int ParTokN = 0; ParTokN < ParTokV.Len(); ParTokN++){
466              TStr ParStr = TXmlDoc::GetXmlStr(ParTokV[ParTokN]->GetTokStr(false));
467              TXmlTokV NmObjTokV; ParTokV[ParTokN]->GetTagTokV("ent", NmObjTokV);
468              for (int NmObjTokN = 0; NmObjTokN < NmObjTokV.Len(); NmObjTokN++) {
469                  TStr NmObjStr = TXmlDoc::GetXmlStr(NmObjTokV[NmObjTokN]->GetTokStr(false));
470                  ParStr.ChangeStrAll(NmObjStr, "<nmobj>" + NmObjStr + "</nmobj>");
471              }
472              DocChA += "<p>"; DocChA += ParStr; DocChA += "</p>";
473          }
474          DocChA += "</body></doc>";
475          AddDoc(DocTitle, DocChA, TStrV(), DateTm);
476          LastTitle = DocTitle;
477      }
478      Notify->OnStatus(TStr::Fmt("Docs: %d", Docs));
479  }
480  TSearchTopics::TSearchTopics(PWdGixRSet RSet, const int& Topics) {
481      PBowDocBs BowDocBs = RSet->GenBowDocBs();
482      TRnd Rnd(1);
483      PBowDocPart BowDocPart = TBowClust::GetKMeansPart(
484          TNullNotify::New(), BowDocBs, TBowSim::New(bstCos), Rnd,
485          Topics, 1, 10, 1, bwwtLogDFNrmTFIDF, 0.0, 0);
486      TopicV.Gen(Topics, 0);
487      TIntH FrameH; THash<TInt, TIntH> FrameTopicHH;
488      for (int ClustN = 0; ClustN < BowDocPart->GetClusts(); ClustN++) {
489          PBowDocPartClust Clust = BowDocPart->GetClust(ClustN);
490          TStr TopicNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 3, 1, ", ", false, false);
491          TopicV.Add(TopicNm);
492          for (int DocN = 0; DocN < Clust->GetDocs(); DocN++) {
493              const int DocId = Clust->GetDId(DocN);
494              TTm DocDate = RSet->GetDocDateTime(DocId);
495              const uint FrameId = TTm::GetYearIntFromTm(DocDate);
496              FrameH.AddDat(FrameId)++;
497              FrameTopicHH.AddDat(FrameId).AddDat(ClustN)++;
498          }
499      }
500      const int Frames = FrameH.Len();
501      FrameV.Gen(Frames, 0);
502      TopicFrameFqVV.Gen(Topics, Frames); TopicFrameFqVV.PutAll(0.0);
503      FrameH.SortByKey(); int FrameKeyId = FrameH.FFirstKeyId();
504      while (FrameH.FNextKeyId(FrameKeyId)) {
505          int FrameId = FrameH.GetKey(FrameKeyId);
506          TTm FrameDate = TTm::GetTmFromDateTimeInt(FrameId);
507          TStr FrameNm = TStr::Fmt("%4d", FrameDate.GetYear());
508          const int FrameN = FrameV.Add(FrameNm);
509          const TIntH& TopicH = FrameTopicHH.GetDat(FrameId);
510          int TopicKeyId = TopicH.FFirstKeyId(); int CountSum = 0;
511          while (TopicH.FNextKeyId(TopicKeyId)) {
512              const int TopicN = TopicH.GetKey(TopicKeyId);
513              int TopicCount = TInt::Abs(TopicH.GetDat(TopicKeyId)) > 1000 ?
514                  0 : TopicH.GetDat(TopicKeyId)();
515              CountSum += TopicCount;
516              const double Fq = double(CountSum); 
517              TopicFrameFqVV(TopicN, FrameN) = Fq;
518          }
519      }
520  }
521  TTrGixItem::TTrGixItem(const TBlobPt& BlobPt, const int& _SubjectId,
522      const int& _PredicatId, const int& _ObjectId, const int& _WdId,
523      const uchar& Type, const uchar& Pos, const bool& Full, const bool& Stem,
524      const uchar& Hyper): Seg(BlobPt.GetSeg()), Addr(BlobPt.GetAddr()),
525          SubjectId(_SubjectId), PredicatId(_PredicatId), ObjectId(_ObjectId), WdId(_WdId) {
526      SetWordInfo(Type, Pos, Full, Stem, Hyper);
527      ClrMergeInfo();
528  }
529  TTrGixItem::TTrGixItem(TSIn& SIn) {
530      SIn.Load(Seg); SIn.Load(Addr);
531      SIn.Load(SubjectId);
532      SIn.Load(PredicatId);
533      SIn.Load(ObjectId);
534      SIn.Load(WdId);
535      SIn.Load(WdInfo);
536      ClrMergeInfo();
537  }
538  void TTrGixItem::Save(TSOut& SOut) const {
539      SOut.Save(Seg); SOut.Save(Addr);
540      SOut.Save(SubjectId);
541      SOut.Save(PredicatId);
542      SOut.Save(ObjectId);
543      SOut.Save(WdId);
544      SOut.Save(WdInfo);
545  }
546  bool TTrGixItem::operator==(const TTrGixItem& Item) const {
547      return ((Seg==Item.Seg)&&(Addr==Item.Addr)&&
548          (SubjectId==Item.SubjectId)&&
549          (PredicatId==Item.PredicatId)&&
550          (ObjectId==Item.ObjectId));
551  }
552  bool TTrGixItem::operator<(const TTrGixItem& Item) const {
553      return (Seg<Item.Seg) ||
554          ((Seg==Item.Seg)&&(Addr<Item.Addr)) ||
555          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId<Item.SubjectId)) ||
556          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId<Item.PredicatId)) ||
557          ((Seg==Item.Seg)&&(Addr==Item.Addr)&&(SubjectId==Item.SubjectId)&&(PredicatId==Item.PredicatId)&&(ObjectId<Item.ObjectId));
558  }
559  void TTrGixItem::SetWordInfo(const uchar& Type, const uchar& Pos,
560          const bool& Full, const bool& Stem, const uchar& Hyper) {
561      TTrGixItemWdInfo Info;
562      Info.Short = 0;
563      Info.Bits.Type = Type;
564      Info.Bits.Pos = Type;
565      Info.Bits.Full = Full ? 1 : 0;
566      Info.Bits.Stem = Stem ? 1 : 0;
567      Info.Bits.Hyper = Hyper;
568      WdInfo = Info.Short;
569  }
570  char TTrGix::SubjectType = 0;
571  char TTrGix::SubjectWdType = 1;
572  char TTrGix::SubjectAttrWdType = 2;
573  char TTrGix::SubjectStemType = 3;
574  char TTrGix::SubjectAttrStemType = 4;
575  char TTrGix::PredicatType = 5;
576  char TTrGix::PredicatWdType = 6;
577  char TTrGix::PredicatAttrWdType = 7;
578  char TTrGix::PredicatStemType = 8;
579  char TTrGix::PredicatAttrStemType = 9;
580  char TTrGix::ObjectType = 10;
581  char TTrGix::ObjectWdType = 11;
582  char TTrGix::ObjectAttrWdType = 12;
583  char TTrGix::ObjectStemType = 13;
584  char TTrGix::ObjectAttrStemType = 14;
585  void TTrGix::AddTrPart(const int& FullId, const char& Type, const int& SubjectId,
586          const int& PredicatId, const int& ObjectId, const TBlobPt& BlobPt) {
587      Gix->AddItem(TTrGixKey(FullId, Type),
588          TTrGixItem(BlobPt, SubjectId, PredicatId,
589              ObjectId, FullId, Type, 0, true, false, 0));
590  }
591  void TTrGix::AddTrPart(const TIntPrV& IdPrV, const char& WdType, const char& StemType,
592          const int& SubjectId, const int& PredicatId, const int& ObjectId,
593          const TBlobPt& BlobPt) {
594      for (int IdPrN = 0; IdPrN < IdPrV.Len(); IdPrN++) {
595          const int WdId = IdPrV[IdPrN].Val1;
596          Gix->AddItem(TTrGixKey(WdId, WdType),
597              TTrGixItem(BlobPt, SubjectId, PredicatId,
598                  ObjectId, WdId, WdType, IdPrN, false, false, 0));
599          const int StemId = IdPrV[IdPrN].Val2;
600          Gix->AddItem(TTrGixKey(StemId, StemType),
601              TTrGixItem(BlobPt, SubjectId, PredicatId,
602                  ObjectId, StemId, StemType, IdPrN, false, true, 0));
603      }
604  }
605  TTrGix::PTGixExpItem TTrGix::GetExactExp(const TStr& Str, const char& Type) {
606      TTrGixKey FullTrKey = TTrGixKey(GetWordId(Str, false), Type);
607      return TTGixExpItem::NewItem(FullTrKey);
608  }
609  TTrGix::PTGixExpItem TTrGix::GetPartExp(const TStr& Str, const char& WdType, const char& StemType) {
610      TIntPrV WordStemIdV; GetWordIdV(Str, WordStemIdV, false);
611      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
612      for (int WordStemIdN = 0; WordStemIdN < WordStemIdV.Len(); WordStemIdN++) {
613          TTrGixKey WdKey(WordStemIdV[WordStemIdN].Val1, WdType);
614          TTrGixKey StemKey(WordStemIdV[WordStemIdN].Val2, StemType);
615          PTGixExpItem ExpItem = TTGixExpItem::NewOr(
616              TTGixExpItem::NewItem(WdKey), TTGixExpItem::NewItem(StemKey));
617          if (Exp->IsEmpty()) { Exp = ExpItem; }
618          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
619      }
620      return Exp;
621  }
622  TTrGix::TTrGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
623      FPath = _FPath; FAccess = _FAccess;
624      Gix = TTGix::New(TGixConst::TrGixFNm, FPath, FAccess, CacheSize);
625      if (FAccess == faCreate) {
626          Stemmer = TStemmer::New(stmtPorter, true);
627      } else {
628          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
629          TFIn FIn(TrGixDatFNm);
630          WordH.Load(FIn);
631          Stemmer = TStemmer::Load(FIn);
632      }
633  }
634  TTrGix::~TTrGix() {
635      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
636          TStr TrGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDatFNm;
637          TFOut FOut(TrGixDatFNm);
638          WordH.Save(FOut);
639          Stemmer->Save(FOut);
640      }
641  }
642  int TTrGix::GetWordId(const TStr& WordStr, const bool& AddIfNotExistP) {
643      if (WordStr.Empty()) { return -1; }
644      if (AddIfNotExistP) { return WordH.AddKey(WordStr.GetUc()); }
645      else { return WordH.GetKeyId(WordStr.GetUc()); }
646  }
647  inline TStr TTrGix::GetWordStr(const int& WId) const {
648      return WId != -1 ? WordH.GetKey(WId) : "";
649  }
650  void TTrGix::GetWordIdV(const TStr& Str,
651          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
652      PSIn HtmlSIn = TStrIn::New(Str);
653      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
654      while (HtmlLx.Sym != hsyEof) {
655          if (HtmlLx.Sym == hsyStr) {
656              const TStr WordStr = HtmlLx.UcChA;
657              const int WordId = GetWordId(WordStr, AddIfNotExistP);
658              const int StemId = GetWordId(Stemmer->GetStem(WordStr), AddIfNotExistP);
659              WordStemIdV.Add(TIntPr(WordId, StemId));
660          }
661          HtmlLx.GetSym();
662      }
663  }
664  void TTrGix::GetWordIdV(const TStrV& WordStrV,
665          TIntPrV& WordStemIdV, const bool& AddIfNotExistP) {
666      for (int WordStrN = 0; WordStrN < WordStrV.Len(); WordStrN++) {
667          GetWordIdV(WordStrV[WordStrN], WordStemIdV, AddIfNotExistP);
668      }
669  }
670  void TTrGix::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
671          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
672          const TStrV& ObjectAttrV, const TBlobPt& BlobPt) {
673      const int SubjectId = GetWordId(SubjectStr, true);
674      const int PredicatId = GetWordId(PredicatStr, true);
675      const int ObjectId = GetWordId(ObjectStr, true);
676      AddTrPart(SubjectId, SubjectType, SubjectId, PredicatId, ObjectId, BlobPt);
677      AddTrPart(PredicatId, PredicatType, SubjectId, PredicatId, ObjectId, BlobPt);
678      AddTrPart(ObjectId, ObjectType, SubjectId, PredicatId, ObjectId, BlobPt);
679      TIntPrV SubjectWIdSIdV; GetWordIdV(SubjectStr, SubjectWIdSIdV, true);
680      TIntPrV SubjectAttrWIdSIdV; GetWordIdV(SubjectAttrV, SubjectAttrWIdSIdV, true);
681      TIntPrV PredicatWIdSIdV; GetWordIdV(PredicatStr, PredicatWIdSIdV, true);
682      TIntPrV PredicatAttrWIdSIdV; GetWordIdV(PredicatAttrV, PredicatAttrWIdSIdV, true);
683      TIntPrV ObjectWIdSIdV; GetWordIdV(ObjectStr, ObjectWIdSIdV, true);
684      TIntPrV ObjectAttrWIdSIdV; GetWordIdV(ObjectAttrV, ObjectAttrWIdSIdV, true);
685      AddTrPart(SubjectWIdSIdV, SubjectWdType, SubjectStemType,
686          SubjectId, PredicatId, ObjectId, BlobPt);
687      AddTrPart(SubjectAttrWIdSIdV, SubjectAttrWdType, SubjectAttrStemType,
688          SubjectId, PredicatId, ObjectId, BlobPt);
689      AddTrPart(PredicatWIdSIdV, PredicatWdType, PredicatStemType,
690          SubjectId, PredicatId, ObjectId, BlobPt);
691      AddTrPart(PredicatAttrWIdSIdV, PredicatAttrWdType, PredicatAttrStemType,
692          SubjectId, PredicatId, ObjectId, BlobPt);
693      AddTrPart(ObjectWIdSIdV, ObjectWdType, ObjectStemType,
694          SubjectId, PredicatId, ObjectId, BlobPt);
695      AddTrPart(ObjectAttrWIdSIdV, ObjectAttrWdType, ObjectAttrStemType,
696          SubjectId, PredicatId, ObjectId, BlobPt);
697  }
698  bool TTrGix::SearchExact(const TStr& SubjectStr, const TStr& PredicatStr,
699          const TStr& ObjectStr, TTrGixItemV& ResItemV) {
700      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
701      if (!SubjectStr.Empty()) {
702          PTGixExpItem ExpItem = GetExactExp(SubjectStr, SubjectType);
703          if (Exp->IsEmpty()) { Exp = ExpItem; }
704          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
705      }
706      if (!PredicatStr.Empty()) {
707          PTGixExpItem ExpItem = GetExactExp(PredicatStr, PredicatType);
708          if (Exp->IsEmpty()) { Exp = ExpItem; }
709          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
710      }
711      if (!ObjectStr.Empty()) {
712          PTGixExpItem ExpItem = GetExactExp(ObjectStr, ObjectType);
713          if (Exp->IsEmpty()) { Exp = ExpItem; }
714          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
715      }
716      return Exp->Eval(Gix, ResItemV);
717  }
718  bool TTrGix::SearchPart(const TStr& SubjectStr, const TStr& PredicatStr,
719          const TStr& ObjectStr, TTrGixItemV& ResItemV, const bool& IncExactP) {
720      PTGixExpItem Exp = TTGixExpItem::NewEmpty();
721      if (!SubjectStr.Empty()) {
722          PTGixExpItem ExpItem = GetPartExp(SubjectStr, SubjectWdType, SubjectStemType);
723          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(SubjectStr, SubjectType), ExpItem); }
724          if (Exp->IsEmpty()) { Exp = ExpItem; }
725          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
726      }
727      if (!PredicatStr.Empty()) {
728          PTGixExpItem ExpItem = GetPartExp(PredicatStr, PredicatWdType, PredicatStemType);
729          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(PredicatStr, PredicatType), ExpItem); }
730          if (Exp->IsEmpty()) { Exp = ExpItem; }
731          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
732      }
733      if (!ObjectStr.Empty()) {
734          PTGixExpItem ExpItem = GetPartExp(ObjectStr, ObjectWdType, ObjectStemType);
735          if (IncExactP) { TTGixExpItem::NewOr(GetExactExp(ObjectStr, ObjectType), ExpItem); }
736          if (Exp->IsEmpty()) { Exp = ExpItem; }
737          else { Exp = TTGixExpItem::NewAnd(Exp, ExpItem); }
738      }
739      return Exp->Eval(Gix, ResItemV);
740  }
741  void TTrGixRSet::AddTr(const TStrTr& TrStr, const TBlobPtV& TrAttrBlobPtV) {
742      TrStrV.Add(TrStr);
743      TrAttrBlobPtVV.Add(TrAttrBlobPtV);
744  }
745  void TTrGixRSet::GetSubjectV(TStrIntKdV& SubjectStrWgtV) {
746      TIntStrKdV SubjectWgtStrV;
747      for (int TrN = 0; TrN < GetTrs(); TrN++) {
748          const TStr& SubjectStr = TrStrV[TrN].Val1;
749          const int Wgt = GetTrCount(TrN);
750          SubjectWgtStrV.Add(TIntStrKd(Wgt, SubjectStr));
751      }
752      SubjectWgtStrV.Sort(false);
753      GetSwitchedKdV<TInt, TStr>(SubjectWgtStrV, SubjectStrWgtV);
754  }
755  void TTrGixRSet::GetPredicatV(TStrIntKdV& PredicatStrWgtV) {
756      TIntStrKdV PredicatWgtStrV;
757      for (int TrN = 0; TrN < GetTrs(); TrN++) {
758          const TStr& PredicatStr = TrStrV[TrN].Val2;
759          const int Wgt = GetTrCount(TrN);
760          PredicatWgtStrV.Add(TIntStrKd(Wgt, PredicatStr));
761      }
762      PredicatWgtStrV.Sort(false);
763      GetSwitchedKdV<TInt, TStr>(PredicatWgtStrV, PredicatStrWgtV);
764  }
765  void TTrGixRSet::GetObjectV(TStrIntKdV& ObjectStrWgtV) {
766      TIntStrKdV ObjectWgtStrV;
767      for (int TrN = 0; TrN < GetTrs(); TrN++) {
768          const TStr& ObjectStr = TrStrV[TrN].Val3;
769          const int Wgt = GetTrCount(TrN);
770          ObjectWgtStrV.Add(TIntStrKd(Wgt, ObjectStr));
771      }
772      ObjectWgtStrV.Sort(false);
773      GetSwitchedKdV<TInt, TStr>(ObjectWgtStrV, ObjectStrWgtV);
774  }
775  void TTrGixRSet::PrintRes(const bool& PrintSentsP, PNotify Notify) const {
776      printf("Query:\n");
777      printf("  Subject: '%s'\n", GetSubjectStr().CStr());
778      printf("  Predicat: '%s'\n", GetPredicatStr().CStr());
779      printf("  Object: '%s'\n", GetObjectStr().CStr());
780      printf("Displaying: %d - %d (All hits: %d)\n",
781          GetOffset()+1, Offset.Val+GetTrs()+1, GetAllTrs());
782      for (int TrN = 0; TrN < GetTrs(); TrN++) {
783          printf("%d. [%s <- %s -> %s], (Support:%d)\n", TrN+GetOffset()+1,
784              GetTrSubjectStr(TrN).CStr(), GetTrPredicatStr(TrN).CStr(),
785              GetTrObjectStr(TrN).CStr(), GetTrCount(TrN));
786      }
787  }
788  void TTrGixBs::GetAttrV(PXmlTok XmlTok, TStrV& AttrV) {
789      TXmlTokV AttrTokV; XmlTok->GetTagTokV("attrib", AttrTokV);
790      for (int AttrTokN = 0; AttrTokN < AttrTokV.Len(); AttrTokN++) {
791          PXmlTok AttrTok = AttrTokV[AttrTokN];
792          AttrV.Add(AttrTok->GetStrArgVal("word"));
793          GetAttrV(AttrTok, AttrV);
794      }
795  }
796  TTrGixBs::TTrGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
797      FPath = _FPath; FAccess = _FAccess;
798      TStr TrGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixDocBsFNm;
799      DocBBs = TMBlobBs::New(TrGixDocBsFNm, FAccess);
800      TStr TrGixSentBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixSentBsFNm;
801      SentBBs = TMBlobBs::New(TrGixSentBsFNm, FAccess);
802      TStr TrGixTrAttrBsFNm = TStr::GetNrFPath(FPath) + TGixConst::TrGixTrAttrBsFNm;
803      TrAttrBBs = TMBlobBs::New(TrGixTrAttrBsFNm, FAccess);
804      TrGix = TTrGix::New(FPath, FAccess, CacheSize);
805  }
806  TTrGixBs::~TTrGixBs() {
807      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
808      }
809  }
810  TBlobPt TTrGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr, const TStrV& CatNmV) {
811      TMOut DocMOut;
812      DocTitle.Save(DocMOut); DocStr.Save(DocMOut); CatNmV.Save(DocMOut);
813      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
814      return DocBlobPt;
815  }
816  TBlobPt TTrGixBs::AddSent(const TStr& SentStr) {
817      TMOut SentMOut; SentStr.Save(SentMOut);
818      TBlobPt SentBlobPt = SentBBs->PutBlob(SentMOut.GetSIn());
819      return SentBlobPt;
820  }
821  TBlobPt TTrGixBs::AddTrAttr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
822          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
823          const TStrV& ObjectAttrV, const TBlobPt& SentBlobPt, const TBlobPt& DocBlobPt) {
824      TMOut TrAttrMOut;
825      SubjectStr.Save(TrAttrMOut); SubjectAttrV.Save(TrAttrMOut);
826      PredicatStr.Save(TrAttrMOut); PredicatAttrV.Save(TrAttrMOut);
827      ObjectStr.Save(TrAttrMOut); ObjectAttrV.Save(TrAttrMOut);
828      SentBlobPt.Save(TrAttrMOut); DocBlobPt.Save(TrAttrMOut);
829      TBlobPt TrAttrBlobPt = TrAttrBBs->PutBlob(TrAttrMOut.GetSIn());
830      return TrAttrBlobPt;
831  }
832  void TTrGixBs::AddTr(const TStr& SubjectStr, const TStrV& SubjectAttrV,
833          const TStr& PredicatStr, const TStrV& PredicatAttrV, const TStr& ObjectStr,
834          const TStrV& ObjectAttrV, const TBlobPt& TrAttrBlobPt) {
835      TrGix->AddTr(SubjectStr, SubjectAttrV, PredicatStr,
836          PredicatAttrV, ObjectStr, ObjectAttrV, TrAttrBlobPt);
837  }
838  void TTrGixBs::GetDoc(const TBlobPt& DocBlobPt, TStr& DocTitle, TStr& DocStr, TStrV& CatNmV) const {
839      PSIn SIn = DocBBs->GetBlob(DocBlobPt);
840      DocTitle.Load(*SIn); DocStr.Load(*SIn); CatNmV.Load(*SIn);
841  }
842  TStr TTrGixBs::GetDocTitle(const TBlobPt& BlobPt) const {
843      PSIn SIn = DocBBs->GetBlob(BlobPt);
844      TStr DocTitle; DocTitle.Load(*SIn);
845      return DocTitle;
846  }
847  TStr TTrGixBs::GetDocStr(const TBlobPt& BlobPt) const {
848      PSIn SIn = DocBBs->GetBlob(BlobPt);
849      {TStr DocTitle; DocTitle.Load(*SIn);}
850      TStr DocStr; DocStr.Load(*SIn);
851      return DocStr;
852  }
853  TStrV TTrGixBs::GetDocCatNmV(const TBlobPt& BlobPt) const {
854      PSIn SIn = DocBBs->GetBlob(BlobPt);
855      {TStr DocTitle; DocTitle.Load(*SIn);}
856      {TStr DocStr; DocStr.Load(*SIn);}
857      TStrV CatNmV; CatNmV.Load(*SIn);
858      return CatNmV;
859  }
860  TStr TTrGixBs::GetSentStr(const TBlobPt& SentBlobPt) {
861      PSIn SIn = SentBBs->GetBlob(SentBlobPt);
862      return TStr(*SIn);
863  }
864  void TTrGixBs::GetTrAttr(const TBlobPt& TrAttrBlobPt, TStr& SubjectStr,
865          TStrV& SubjectAttrV, TStr& PredicatStr, TStrV& PredicatAttrV,
866          TStr& ObjectStr, TStrV& ObjectAttrV, TBlobPt& SentBlobPt,
867          TBlobPt& DocBlobPt) {
868      PSIn SIn = TrAttrBBs->GetBlob(TrAttrBlobPt);
869      SubjectStr.Load(*SIn); SubjectAttrV.Load(*SIn);
870      PredicatStr.Load(*SIn); PredicatAttrV.Load(*SIn);
871      ObjectStr.Load(*SIn); ObjectAttrV.Load(*SIn);
872      SentBlobPt = TBlobPt(*SIn); DocBlobPt = TBlobPt(*SIn);
873  }
874  PTrGixRSet TTrGixBs::SearchTr(const TStr& SubjectStr, const TStr& PredicatStr,
875          const TStr& ObjectStr, TTrGixRankFun& RankFun, const int& Docs,
876          const int& Offset, const bool& ExactP) {
877      TTrGixItemV ResItemV;
878      if (ExactP) { TrGix->SearchExact(SubjectStr, PredicatStr, ObjectStr, ResItemV); }
879      else { TrGix->SearchPart(SubjectStr, PredicatStr, ObjectStr, ResItemV, true); }
880      THash<TIntTr, TIntV> TrToItemVH;
881      for (int ItemN = 0; ItemN < ResItemV.Len(); ItemN++) {
882          const TTrGixItem& Item = ResItemV[ItemN];
883          TrToItemVH.AddDat(Item.GetIdTr()).Add(ItemN);
884      }
885      TFltIntKdV FullWgtTrKeyIdV;
886      int TrKeyId = TrToItemVH.FFirstKeyId();
887      while (TrToItemVH.FNextKeyId(TrKeyId)) {
888          const double Wgt = RankFun(TrToItemVH[TrKeyId].Len());
889          FullWgtTrKeyIdV.Add(TFltIntKd(Wgt, TrKeyId));
890      }
891      TFltIntKdV WgtTrKeyIdV;
892      if (Docs == -1) {
893          WgtTrKeyIdV = FullWgtTrKeyIdV;
894      } else if (ResItemV.Len() >= (Docs + Offset)) {
895          WgtTrKeyIdV = FullWgtTrKeyIdV;
896          WgtTrKeyIdV.Sort(false); WgtTrKeyIdV.Trunc(Docs + Offset);
897          WgtTrKeyIdV.Sort(true); WgtTrKeyIdV.Trunc(Docs);
898      } else if (ResItemV.Len() > Offset) {
899          WgtTrKeyIdV = FullWgtTrKeyIdV; WgtTrKeyIdV.Sort(true);
900          WgtTrKeyIdV.Trunc(FullWgtTrKeyIdV.Len() - Offset);
901      } else {
902      }
903      WgtTrKeyIdV.Sort(false);
904      PTrGixRSet RSet = TTrGixRSet::New(SubjectStr, PredicatStr,
905          ObjectStr, FullWgtTrKeyIdV.Len(), Offset);
906      for (int TrN = 0; TrN < WgtTrKeyIdV.Len(); TrN++) {
907          const int TrKeyId = WgtTrKeyIdV[TrN].Dat;
908          const TIntTr& WIdTr = TrToItemVH.GetKey(TrKeyId);
909          const TIntV& ItemV = TrToItemVH[TrKeyId];
910          TStr SubjectStr = TrGix->GetWordStr(WIdTr.Val1);
911          TStr PredicatStr = TrGix->GetWordStr(WIdTr.Val2);
912          TStr ObjectStr = TrGix->GetWordStr(WIdTr.Val3);
913          TStrTr TrStr(SubjectStr, PredicatStr, ObjectStr);
914          TBlobPtV TrAttrBlobPtV;
915          for (int ItemN = 0; ItemN < ItemV.Len(); ItemN++) {
916              const TTrGixItem& Item = ResItemV[ItemV[ItemN]];
917              TBlobPt TrAttrBlobPt = Item.GetBlobPt();
918              TrAttrBlobPtV.Add(TrAttrBlobPt);
919          }
920          RSet->AddTr(TrStr, TrAttrBlobPtV);
921      }
922      return RSet;
923  }
924  void TTrGixBs::AddReuters(const TStr& XmlFNm, int& Trs, const PSOut& CsvOut) {
925      PNotify Notify = TStdNotify::New();
926      TBlobPt EmptyDocBlobPt = AddDoc("No full document text!");
927      PSIn XmlSIn = TFIn::New(XmlFNm);
928      TXmlDoc::SkipTopTag(XmlSIn);
929      PXmlDoc XmlDoc; int XmlDocs = 0;
930      forever{
931          if (Trs % 100 == 0) { Notify->OnStatus(TStr::Fmt("%d\r", Trs)); }
932          XmlDocs++; XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
933          if (!XmlDoc->IsOk()) { break; }
934          PXmlTok TopTok = XmlDoc->GetTok();
935          if (TopTok->IsTag("sentence")){
936              TStr DocStr = ""; TBlobPt DocBlobPt = EmptyDocBlobPt;
937              TStr SentStr = TopTok->GetTagTok("originalSentence")->GetTokStr(false);
938              TBlobPt SentBlobPt = AddSent(SentStr);
939              TXmlTokV TrTokV; TopTok->GetTagTokV("triplet", TrTokV);
940              for (int TrTokN = 0; TrTokN < TrTokV.Len(); TrTokN++) {
941                  PXmlTok TrTok = TrTokV[TrTokN];
942                  TStr SubjectStr = TrTok->GetTagTok("subject")->GetStrArgVal("word");
943                  TStr PredicatStr = TrTok->GetTagTok("verb")->GetStrArgVal("word");
944                  TStr ObjectStr = TrTok->GetTagTok("object")->GetStrArgVal("word");
945                  TStrV SubjectAttrV; GetAttrV(TrTok->GetTagTok("subject"), SubjectAttrV);
946                  TStrV PredicatAttrV; GetAttrV(TrTok->GetTagTok("verb"), PredicatAttrV);
947                  TStrV ObjectAttrV; GetAttrV(TrTok->GetTagTok("object"), ObjectAttrV);
948                  TBlobPt TrAttrBlobPt = AddTrAttr(SubjectStr, SubjectAttrV,
949                      PredicatStr, PredicatAttrV, ObjectStr, ObjectAttrV,
950                      SentBlobPt, DocBlobPt);
951                  AddTr(SubjectStr, SubjectAttrV, PredicatStr, PredicatAttrV,
952                      ObjectStr, ObjectAttrV, TrAttrBlobPt);
953                  Trs++;
954                  if (!CsvOut.Empty()) {
955                      SubjectStr.DelChAll(','); CsvOut->PutStr(SubjectStr + ",");
956                      PredicatStr.DelChAll(','); CsvOut->PutStr(PredicatStr + ",");
957                      ObjectStr.DelChAll(','); CsvOut->PutStr(ObjectStr + ",");
958                      CsvOut->PutStr(TStr::Fmt("%u,", uint(SentBlobPt.GetSeg())));
959                      CsvOut->PutStr(TStr::Fmt("%u,", SentBlobPt.GetAddr()));
960                      CsvOut->PutStr(TStr::Fmt("%d,", SubjectAttrV.Len()));
961                      for (int AttrN = 0; AttrN < SubjectAttrV.Len(); AttrN++) {
962                          SubjectAttrV[AttrN].DelChAll(',');
963                          CsvOut->PutStr(SubjectAttrV[AttrN]);
964                          CsvOut->PutStr(",");
965                      }
966                      CsvOut->PutStr(TStr::Fmt("%d,", PredicatAttrV.Len()));
967                      for (int AttrN = 0; AttrN < PredicatAttrV.Len(); AttrN++) {
968                          PredicatAttrV[AttrN].DelChAll(',');
969                          CsvOut->PutStr(PredicatAttrV[AttrN]);
970                          CsvOut->PutStr(",");
971                      }
972                      CsvOut->PutStr(TStr::Fmt("%d,", ObjectAttrV.Len()));
973                      for (int AttrN = 0; AttrN < ObjectAttrV.Len(); AttrN++) {
974                          ObjectAttrV[AttrN].DelChAll(',');
975                          CsvOut->PutStr(ObjectAttrV[AttrN]);
976                          CsvOut->PutStr(",");
977                      }
978                      CsvOut->PutStr("-1"); CsvOut->PutLn();
979                  }
980              }
981          }
982      }
983      CsvOut->Flush();
984  }
985  void TTrGixBs::IndexReuters(const TStr& XmlFPath, const TStr& CsvFNm, const int& MxTrs) {
986      PNotify Notify = TStdNotify::New();
987      Notify->OnStatus("Loading Reuters documents from " + XmlFPath + " ...\n");
988      TFFile FFile(XmlFPath, ".xml", true); TStr XmlFNm; int Files = 0, Trs = 0;
989      PSOut CsvOut; if (!CsvFNm.Empty()) { CsvOut = TFOut::New(CsvFNm); }
990      while (FFile.Next(XmlFNm) && ((MxTrs == -11)||(MxTrs > Trs))) {
991          Notify->OnStatus(TStr::Fmt("Loading %3d : %s ...", Files+1, XmlFNm.CStr()));
992          if (TFile::Exists(XmlFNm)) { AddReuters(XmlFNm, Trs, CsvOut); Files++; }
993      }
994      Notify->OnStatus(TStr::Fmt("Triplets loaded: %d", Trs));
995  }
996  TMWdGixItem::TMWdGixItem(TSIn& SIn) {
997      SIn.Load(Seg); SIn.Load(Addr);
998      SIn.Load(WdFq); SIn.Load(DocWds);
999  }
1000  void TMWdGixItem::Save(TSOut& SOut) const {
1001      SOut.Save(Seg); SOut.Save(Addr);
1002      SOut.Save(WdFq); SOut.Save(DocWds);
1003  }
1004  inline bool TMWdGixItem::operator==(const TMWdGixItem& Item) const {
1005      return (Seg == Item.Seg) && (Addr == Item.Addr);
1006  }
1007  inline bool TMWdGixItem::operator<(const TMWdGixItem& Item) const {
1008      return (Seg < Item.Seg) || ((Seg == Item.Seg) && (Addr < Item.Addr));
1009  }
1010  void TMWdGixDefMerger::Union(TMWdGixItemV& DstV, const TMWdGixItemV& SrcV) const {
1011      TMWdGixItemV DstValV(TInt::GetMx(DstV.Len(), SrcV.Len()), 0);
1012      int ValN1 = 0; int ValN2 = 0;
1013      while ((ValN1<DstV.Len()) && (ValN2<SrcV.Len())){
1014          const TMWdGixItem& Val1 = DstV.GetVal(ValN1);
1015          const TMWdGixItem& Val2 = SrcV.GetVal(ValN2);
1016          if (Val1 < Val2) { DstValV.Add(Val1); ValN1++; }
1017          else if (Val1>Val2) { DstValV.Add(Val2); ValN2++; }
1018          else { DstValV.Add(TMWdGixItem(Val1, Val2)); ValN1++; ValN2++; }
1019      }
1020      for (int RestValN1=ValN1; RestValN1<DstV.Len(); RestValN1++){
1021          DstValV.Add(DstV.GetVal(RestValN1));}
1022      for (int RestValN2=ValN2; RestValN2<SrcV.Len(); RestValN2++){
1023          DstValV.Add(SrcV.GetVal(RestValN2));}
1024      DstV = DstValV;
1025  }
1026  void TMWdGixDefMerger::Def(const TInt& Key, TMWdGixItemV& ItemV) const  {
1027      const int WdDocFq = MWdGix->GetWdFq(Key);
1028      const int Docs = MWdGix->GetAllDocs();
1029      const double AvgDocWds = MWdGix->GetAvgDocWds();
1030      const int Items = ItemV.Len();
1031      for (int ItemN = 0; ItemN < Items; ItemN++) {
1032          TMWdGixItem& Item = ItemV[ItemN];
1033          const int WdFq = Item.GetWdFq();
1034          const int DocWds = Item.GetDocWds();
1035          const double Wgt = RankFun->WdRank(WdFq, DocWds, WdDocFq, Docs, AvgDocWds);
1036          Item.PutWgt(Wgt);
1037      }
1038  }
1039  TMWdGix::TMWdGix(const TStr& _FPath, const TFAccess& _FAccess, const int64& CacheSize) {
1040      FPath = _FPath; FAccess = _FAccess;
1041      printf("Loading '%s' .. ", FPath.CStr());
1042      if (FAccess == faCreate) { printf("create .. "); }
1043      if (FAccess == faRdOnly) { printf("read-only .. "); }
1044      printf("Cache[%s]\n", TUInt64::GetMegaStr(CacheSize).CStr());
1045      MWGix = TMWGix::New(TGixConst::MWdGixFNm, FPath, FAccess, CacheSize);
1046      if (FAccess != faCreate) {
1047          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1048          TFIn FIn(MWdGixDatFNm);
1049          WordH.Load(FIn);
1050          AllDocs.Load(FIn);
1051          AllWords.Load(FIn);
1052      }
1053  }
1054  TMWdGix::~TMWdGix() {
1055      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1056          printf("Closing %s: docs=%d, words=%d\n",
1057              FPath.CStr(), AllDocs.Val, AllWords.Val);
1058          TStr MWdGixDatFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDatFNm;
1059          TFOut FOut(MWdGixDatFNm);
1060          WordH.Save(FOut);
1061          AllDocs.Save(FOut);
1062          AllWords.Save(FOut);
1063      }
1064  }
1065  void TMWdGix::AddHtml(const TStr& DocStr, const TBlobPt& BlobPt) {
1066      PSIn HtmlSIn = TStrIn::New(DocStr);
1067      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1068      TIntH DocWIdH; int DocWds = 0;
1069      while (HtmlLx.Sym != hsyEof) {
1070          if (HtmlLx.Sym == hsyStr) {
1071              TStr WordStr = HtmlLx.UcChA;
1072              const int WId = WordH.AddKey(WordStr);
1073              DocWIdH.AddDat(WId)++;
1074              DocWds++;
1075          }
1076          HtmlLx.GetSym();
1077      }
1078      int WdKeyId = DocWIdH.FFirstKeyId();
1079      while (DocWIdH.FNextKeyId(WdKeyId)) {
1080          const int WId = DocWIdH.GetKey(WdKeyId);
1081          const int WdFq = DocWIdH[WdKeyId];
1082          WordH[WId]++; 
1083          TMWdGixKey Key(WId);
1084          TMWdGixItem Item(BlobPt, WdFq, DocWds);
1085          MWGix->AddItem(Key, Item);
1086      }
1087      AllDocs++; AllWords += DocWds;
1088  }
1089  bool TMWdGix::Search(const TStr& QueryStr,
1090          TMWdGixItemV& ResItemV, const TMWdGixDefMerger& Merger) {
1091      PMWGixExpItem MWGixExp = TMWGixExpItem::NewEmpty();
1092      PSIn HtmlSIn = TStrIn::New(QueryStr);
1093      THtmlLx HtmlLx(HtmlSIn); HtmlLx.GetSym();
1094      while (HtmlLx.Sym != hsyEof) {
1095          if (HtmlLx.Sym == hsyStr) {
1096              TStr WordStr = HtmlLx.UcChA;
1097              const int WId = WordH.GetKeyId(WordStr);
1098              if (WId != -1) {
1099                  PMWGixExpItem MWGixExpItem = TMWGixExpItem::NewItem(TMWdGixKey(WId));
1100                  if (MWGixExp->IsEmpty()) { MWGixExp = MWGixExpItem; }
1101                  else { MWGixExp = TMWGixExpItem::NewOr(MWGixExp, MWGixExpItem); }
1102              }
1103          }
1104          HtmlLx.GetSym();
1105      }
1106      return MWGixExp->Eval(MWGix, ResItemV, Merger);
1107  }
1108  TStr TMWdGixRSet::GetMainPara(const TStr& QueryStr, const TStr& FullStr) {
1109      PBowDocBs BowDocBs = TBowDocBs::New();
1110      BowDocBs->AddHtmlDoc("Query", TStrV(), QueryStr, false);
1111      TStrV ParaV; FullStr.SplitOnAllCh('\n', ParaV);
1112      if (ParaV.Empty()) { return ""; }
1113      for (int ParaN = 0; ParaN < ParaV.Len(); ParaN++) {
1114          BowDocBs->AddHtmlDoc("Doc" + TInt::GetStr(ParaN), TStrV(), ParaV[ParaN], false);
1115      }
1116      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF);
1117      PBowSpV QuerySpV = BowDocWgtBs->GetSpV(0); int MxParaN = 0;
1118      double MxParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(1));
1119      for (int ParaN = 1; ParaN < ParaV.Len(); ParaN++) {
1120          const double ParaSim = TBowSim::GetCosSim(QuerySpV, BowDocWgtBs->GetSpV(ParaN+1));
1121          if (ParaSim > MxParaSim) {
1122              MxParaSim = ParaSim;
1123              MxParaN = ParaN;
1124          }
1125      }
1126      return ParaV[MxParaN];
1127  }
1128  void TMWdGixRSet::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1129          const TStr& DocLang, const TStrV& KeyWdV) {
1130      DocTitleV.Add(DocTitle);
1131      DocTitleV.Last().DelChAll('\n');
1132      DocTitleV.Last().DelChAll('\r');
1133      DocStrV.Add(GetMainPara(LangQueryH.GetDat(DocLang), DocStr));
1134      DocLangV.Add(DocLang);
1135      KeyWdVV.Add(KeyWdV);
1136  }
1137  void TMWdGixRSet::PrintRes(PNotify Notify) {
1138      const int Docs = GetDocs();
1139      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1140          AllDocs.Val, Docs, Docs + Offset.Val));
1141      for (int DocN = 0; DocN < Docs; DocN++) {
1142          TStr DocStr = DocTitleV[DocN] + " - " + DocStrV[DocN];
1143          DocStr.DelChAll('\n'); DocStr.DelChAll('\r');
1144          Notify->OnStatus(TStr::Fmt("[%d:%s] %s ...", DocN+1,
1145              DocLangV[DocN].CStr(), DocStr.Left(60).CStr()));
1146      }
1147      Notify->OnStatus(TStr::Fmt("All results: %d, Showing results from %d to %d",
1148          AllDocs.Val, Docs, Docs + Offset.Val));
1149  }
1150  TStr TMWdGixRSet::GetWsXml(const TStrPrStrH& EurovocH) const {
1151      PXmlTok TopTok = TXmlTok::New("cca");
1152      TopTok->AddArg("allhits", GetAllDocs());
1153      for (int DocN = 0; DocN < GetDocs(); DocN++) {
1154          PXmlTok HitTok = TXmlTok::New("hit");
1155          HitTok->AddArg("rank", DocN+1);
1156          HitTok->AddArg("lang", DocLangV[DocN]);
1157          TStr Title = DocTitleV[DocN];
1158          if (Title.Len() > 100) { Title = Title.Left(100) + "..."; }
1159          TStr Snipet = DocStrV[DocN].Left(800);
1160          if (Snipet.Len() > 800) { Snipet = Snipet.Left(800) + "..."; }
1161          HitTok->AddSubTok(TXmlTok::New("title", Title));
1162          HitTok->AddSubTok(TXmlTok::New("snipet", Snipet));
1163          PXmlTok KeyWdTok = TXmlTok::New("keywords");
1164          const TStrV& KeyWdV = KeyWdVV[DocN]; int GoodKeyWds = 0;
1165          for (int KeyWdN = 0; KeyWdN < KeyWdV.Len(); KeyWdN++) {
1166              TStrPr KeyWd(QueryLang, KeyWdV[KeyWdN]);
1167              if (EurovocH.IsKey(KeyWd)) {
1168                  KeyWdTok->AddSubTok(TXmlTok::New("keyword", EurovocH.GetDat(KeyWd)));
1169                  GoodKeyWds++;
1170              }
1171          }
1172          HitTok->AddSubTok(KeyWdTok);
1173          if (GoodKeyWds == 0) { continue; }
1174          TopTok->AddSubTok(HitTok);
1175      }
1176      return TopTok->GetTokStr();
1177  }
1178  TMWdGixBs::TMWdGixBs(const TStr& _FPath, const TFAccess& _FAccess, const int64& _CacheSize) {
1179      FPath = _FPath; FAccess = _FAccess; CacheSize = _CacheSize;
1180      TStr MWdGixDocBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixDocBsFNm;
1181      DocBBs = TMBlobBs::New(MWdGixDocBsFNm, FAccess);
1182      if (FAccess != faCreate) {
1183          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1184          AlignPairBs = TAlignPairBs::LoadBin(MWdGixBsFNm);
1185          InitGixs(FAccess);
1186      }
1187  }
1188  TMWdGixBs::~TMWdGixBs() {
1189      if ((FAccess == faCreate) || (FAccess == faUpdate)) {
1190          TStr MWdGixBsFNm = TStr::GetNrFPath(FPath) + TGixConst::MWdGixBsFNm;
1191          AlignPairBs->SaveBin(MWdGixBsFNm);
1192      }
1193  }
1194  void TMWdGixBs::AddDoc(const TStr& DocTitle, const TStr& DocStr,
1195          const TStr& DocLang, const TStrV& KeyWdV) {
1196      TMOut DocMOut;
1197      DocTitle.Save(DocMOut); DocStr.Save(DocMOut);
1198      DocLang.Save(DocMOut); KeyWdV.Save(DocMOut);
1199      TBlobPt DocBlobPt = DocBBs->PutBlob(DocMOut.GetSIn());
1200      LangMWdGixH.GetDat(DocLang)->AddHtml(DocStr, DocBlobPt);
1201  }
1202  void TMWdGixBs::GetDoc(const TBlobPt& BlobPt, TStr& DocTitle,
1203          TStr& DocStr, TStr& DocLang, TStrV& KeyWdV) const {
1204      PSIn SIn = DocBBs->GetBlob(BlobPt);
1205      DocTitle.Load(*SIn); DocStr.Load(*SIn);
1206      DocLang.Load(*SIn); KeyWdV.Load(*SIn);
1207  }
1208  PMWdGixRSet TMWdGixBs::SearchDoc(const TStr& QueryStr, const TStr& QueryLang,
1209          const TStrV& TargetLangV, const int& Docs, const int& Offset,
1210          PMWdGixRankFun& RankFun) {
1211      if (!AlignPairBs->IsLang(QueryLang)) {
1212          return TMWdGixRSet::New(QueryStr, "", TStrStrH(), 0, 0); }
1213      const int Queries = TargetLangV.Len();
1214      printf("  Translationg %d queries ...\n", Queries);
1215      const int QueryLangId = AlignPairBs->GetLangId(QueryLang);
1216      TStrStrH LangQueryH;
1217      TWgtMWdGixIntItemKdV FullWgtLangItemV;
1218      for (int TargetLangN = 0; TargetLangN < Queries; TargetLangN++) {
1219          if (!AlignPairBs->IsLang(TargetLangV[TargetLangN])) { continue; }
1220          const TStr& TargetLang = TargetLangV[TargetLangN];
1221          const int TargetLangId = AlignPairBs->GetLangId(TargetLang);
1222          if (TargetLangId == QueryLangId) { continue; }
1223          TStr TargetQueryStr = AlignPairBs->MapQuery(
1224              AlignPairMap, QueryStr, QueryLangId, TargetLangId);
1225          LangQueryH.AddDat(TargetLang, TargetQueryStr);
1226          printf("  Query: '%s' -> '%s'\n", QueryStr.CStr(), TargetQueryStr.CStr());
1227          printf("  Loading from Gix ...\n");
1228          TMWdGixItemV LangResItemV;
1229          PMWdGix LangMWdGix = LangMWdGixH.GetDat(TargetLang);
1230          TMWdGixDefMerger LangMerger(LangMWdGix, RankFun);
1231          LangMWdGix->Search(TargetQueryStr, LangResItemV, LangMerger);
1232          double MxWgt = 0.0;
1233          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1234              const TMWdGixItem& Item = LangResItemV[ItemN];
1235              MxWgt = TFlt::GetMx(Item.GetWgt(), MxWgt);
1236          }
1237          printf("  MxWgt: %g\n", MxWgt);
1238          for (int ItemN = 0; ItemN < LangResItemV.Len(); ItemN++) {
1239              const TMWdGixItem& Item = LangResItemV[ItemN];
1240              const double Wgt = MxWgt > 0.0 ? Item.GetWgt() / MxWgt : 0.0;
1241              TMWdGixIntItemPr LangItemPr(TargetLangId, Item);
1242              FullWgtLangItemV.Add(TWgtMWdGixIntItemKd(Wgt, LangItemPr));
1243          }
1244      }
1245      FullWgtLangItemV.Sort(false);
1246      printf("  Sorting %d hits ...\n", FullWgtLangItemV.Len());
1247      TWgtMWdGixIntItemKdV WgtLangItemV;
1248      if (Docs == -1) {
1249          WgtLangItemV = FullWgtLangItemV;
1250      } else if (FullWgtLangItemV.Len() >= (Docs + Offset)) {
1251          WgtLangItemV = FullWgtLangItemV;
1252          WgtLangItemV.Sort(false); WgtLangItemV.Trunc(Docs + Offset);
1253          WgtLangItemV.Sort(true); WgtLangItemV.Trunc(Docs);
1254      } else if (FullWgtLangItemV.Len() > Offset) {
1255          WgtLangItemV = FullWgtLangItemV; WgtLangItemV.Sort(true);
1256          WgtLangItemV.Trunc(FullWgtLangItemV.Len() - Offset);
1257      } else {
1258      }
1259      WgtLangItemV.Sort(false);
1260      printf("  Loading content for %d hits ...\n", WgtLangItemV.Len());
1261      PMWdGixRSet RSet = TMWdGixRSet::New(QueryStr,
1262          QueryLang, LangQueryH, FullWgtLangItemV.Len(), Offset);
1263      for (int ItemN = 0; ItemN < WgtLangItemV.Len(); ItemN++) {
1264          const TMWdGixIntItemPr& LangItem = WgtLangItemV[ItemN].Dat;
1265          const TMWdGixItem& Item = LangItem.Val2;
1266          TBlobPt DocBlobPt = Item.GetBlobPt();
1267          TStr DocTitle, DocStr, DocLang; TStrV KeyWdV;
1268          GetDoc(DocBlobPt, DocTitle, DocStr, DocLang, KeyWdV);
1269          RSet->AddDoc(DocTitle, DocStr, DocLang, KeyWdV);
1270      }
1271      printf("  Done\n");
1272      return RSet;
1273  }
1274  void TMWdGixBs::AddAcquis(const TStr& XmlFNm, const TStr& Lang) {
1275      PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlFNm);
1276      if (!XmlDoc->IsOk()) { return; }
1277      PXmlTok TopTok = XmlDoc->GetTok();
1278      PXmlTok TextTok = TopTok->GetTagTok("text|body");
1279      if (TextTok.Empty()) { printf("  Bad file '%s'\n", XmlFNm.CStr()); return; }
1280      TStr DocTitle; TChA DocChA;
1281      for (int SubTokN = 0; SubTokN < TextTok->GetSubToks(); SubTokN++) {
1282          PXmlTok SubTok = TextTok->GetSubTok(SubTokN);
<span onclick='openModal()' class='match'>1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
</span>1287              for (int ParaN = 0; ParaN < SubTok->GetSubToks(); ParaN++) {
1288                  if (SubTok->IsTag()) {
1289                      DocChA += SubTok->GetSubTok(ParaN)->GetTokStr(false);
1290                      DocChA += '\n';
1291                  }
1292              }
1293              DocChA += '\n';
1294          }
1295      }
1296      TStrV KeyWdV;
1297      PXmlTok KeyWdTok = TopTok->GetTagTok("teiHeader|profileDesc|textClass");
1298      if (!KeyWdTok.Empty()) {
1299          for (int SubTokN = 0; SubTokN < KeyWdTok->GetSubToks(); SubTokN++) {
1300              PXmlTok SubTok = KeyWdTok->GetSubTok(SubTokN);
1301              if (!SubTok->IsTag()) { continue; }
1302              if (SubTok->IsArg("scheme")) {
1303                  KeyWdV.Add(SubTok->GetStrArgVal("scheme") + "-" + SubTok->GetTokStr(false));
1304              }
1305          }
1306      }
1307      if (!KeyWdV.Empty()) { AddDoc(DocTitle, DocChA, Lang, KeyWdV); }
1308  }
1309  void TMWdGixBs::IndexAcquis(const TStr& InFPath, PAlignPairBs _AlignPairBs,
1310          const int& MxDocs, const int64& IndexCacheSize) {
1311      AlignPairBs = _AlignPairBs;
1312      int LangId = AlignPairBs->FFirstLangId();
1313      while (AlignPairBs->FNextLangId(LangId)) {
1314          const TStr& Lang = AlignPairBs->GetLang(LangId);
1315          TStr LangFPath = InFPath + "/" + Lang;
1316          printf("Indexing %s ...\n", LangFPath.CStr());
1317          LangMWdGixH.AddDat(Lang) =
1318                  TMWdGix::New(FPath + "/" + Lang, FAccess, IndexCacheSize);
1319          TFFile FFile(LangFPath, ".xml", true);
1320          TStr XmlFNm; int XmlFNms = 0;
1321          while (FFile.Next(XmlFNm)) {
1322              if (XmlFNms == MxDocs) { break; }
1323              if (XmlFNms % 100 == 0) { printf("  %d\r", XmlFNms); }
1324              try { AddAcquis(XmlFNm, Lang); } catch (...) { }
1325              XmlFNms++;
1326          } printf("\n");
1327          LangMWdGixH.Clr();
1328      }
1329      InitGixs(faRdOnly);
1330  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cluster.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gsearch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1945        if (ParamDesc[j].NonEssential) {
1946          continue;
1947        }
1948        if ((*VARii == 0.0) || (*VARjj == 0.0)) {
1949          CorrelationCoeff = 0.0;
1950        } else {
</pre></code></div>
                <div class="column column_space"><pre><code>1283          if (!SubTok->IsTag()) { continue; }
1284          if (SubTok->GetTagNm() == "head") {
1285              DocTitle = SubTok->GetTokStr(false);
1286          } else if (SubTok->GetTagNm() == "div") {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    