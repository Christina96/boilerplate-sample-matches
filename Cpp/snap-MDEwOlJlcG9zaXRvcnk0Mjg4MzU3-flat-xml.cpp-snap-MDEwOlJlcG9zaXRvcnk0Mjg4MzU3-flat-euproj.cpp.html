
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</h3>
            <pre><code>1  TStrStrH TXmlObjSer::TypeNmToTagNmH;
2  TStr TXmlObjSer::GetTagNm(const TStr& TypeNm){
3    TStr& XmlTagNm=TypeNmToTagNmH.AddDat(TypeNm);
4    if (XmlTagNm.Empty()){
5      TChA XmlTagChA=TypeNm;
6      for (int ChN=0; ChN<XmlTagChA.Len(); ChN++){
7        char Ch=XmlTagChA[ChN];
8        if (!((('A'<=Ch)&&(Ch<='Z'))||(('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9')))){
9          XmlTagChA.PutCh(ChN, '_');
10        }
11      }
12      while ((XmlTagChA.Len()>0)&&(XmlTagChA.LastCh()=='_')){
13        XmlTagChA.Pop();}
14      XmlTagNm=XmlTagChA;
15    }
16    return XmlTagNm;
17  }
18  void TXmlObjSer::AssertXmlHd(
19   const PXmlTok& XmlTok, const TStr& Nm, const TStr& TypeNm){
20    EAssertR(!XmlTok.Empty(), "Xml-Token Empty");
21    if (!Nm.Empty()){
22      if (!XmlTok->IsTag()){
23        TStr ArgStr1="Expected: Tag";
24        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
25        TExcept::Throw("Invalid Xml-Token", ArgStr1, ArgStr2);
26      }
27      if (Nm!="-"){
28        if (!XmlTok->IsTag(Nm)){
29          TStr ArgStr1=TStr("Expected: ")+Nm;
30          TStr ArgStr2=TStr("Found: ")+XmlTok->GetStr();
31          TExcept::Throw("Invalid Xml-Tag", ArgStr1, ArgStr2);
32        }
33        TStr TypeArgVal=XmlTok->GetStrArgVal("Type");
34        if (TypeArgVal!=TypeNm){
35          TStr ArgStr1=TStr("Expected: ")+TypeNm;
36          TStr ArgStr2=TStr("Found: ")+TypeArgVal;
37          TExcept::Throw("Invalid Xml-Type", ArgStr1, ArgStr2);
38        }
39      }
40    } else {
41      if (!XmlTok->IsTag(TypeNm)){
42        TStr ArgStr1=TStr("Expected: ")+TypeNm;
43        TStr ArgStr2=TStr("Found: ")+XmlTok->GetSymStr();
44        TExcept::Throw("Invalid Xml-Type-Tag", ArgStr1, ArgStr2);
45      }
46    }
47  }
48  bool TXmlObjSer::GetBoolArg(const PXmlTok& XmlTok, const TStr& Nm){
<span onclick='openModal()' class='match'>49    TStr ValStr;
50    if (XmlTok->IsArg(Nm, ValStr)){
51      bool Val;
</span>52      if (ValStr.IsBool(Val)){
53        return Val;
54      } else {
55        TExcept::Throw("Invalid Xml-Argument Boolean-Value", Nm, ValStr);
56      }
57    } else {
58      TExcept::Throw("Xml-Argument Missing", Nm);
59    }
60    Fail; return 0;
61  }
62  int TXmlObjSer::GetIntArg(const PXmlTok& XmlTok, const TStr& Nm){
63    TStr ValStr;
64    if (XmlTok->IsArg(Nm, ValStr)){
65      int Val;
66      if (ValStr.IsInt(Val)){
67        return Val;
68      } else {
69        TExcept::Throw("Invalid Xml-Argument Integer-Value", Nm, ValStr);
70      }
71    } else {
72      TExcept::Throw("Xml-Argument Missing", Nm);
73    }
74    Fail; return 0;
75  }
76  int64 TXmlObjSer::GetInt64Arg(const PXmlTok& XmlTok, const TStr& Nm){
77    TStr ValStr;
78    if (XmlTok->IsArg(Nm, ValStr)){
79      int64 Val;
80      if (ValStr.IsInt64(Val)){
81        return Val;
82      } else {
83        TExcept::Throw("Invalid Xml-Argument Integer64-Value", Nm, ValStr);
84      }
85    } else {
86      TExcept::Throw("Xml-Argument Missing", Nm);
87    }
88    Fail; return 0;
89  }
90  double TXmlObjSer::GetFltArg(const PXmlTok& XmlTok, const TStr& Nm){
91    TStr ValStr;
92    if (XmlTok->IsArg(Nm, ValStr)){
93      double Val;
94      if (ValStr.IsFlt(Val)){
95        return Val;
96      } else {
97        TExcept::Throw("Invalid Xml-Argument Double-Value", Nm, ValStr);
98      }
99    } else {
100      TExcept::Throw("Xml-Argument Missing", Nm);
101    }
102    Fail; return 0;
103  }
104  TXmlObjSerTagNm::TXmlObjSerTagNm(
105   TSOut& _SOut, const bool& ETagP,
106   const TStr& Nm, const TStr& TypeNm,
107   const TStr& ArgNm, const TStr& ArgVal):
108    TagNm(), SOut(&_SOut){
109    if (Nm!="-"){
110      SOut->PutCh('<');
111      if (Nm.Empty()){
112        SOut->PutStr(TagNm=TypeNm);
113      } else {
114        SOut->PutStr(TagNm=Nm);
115        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
116      }
117      if (!ArgNm.Empty()){
118        SOut->PutCh(' '); SOut->PutStr(ArgNm); SOut->PutCh('=');
119        SOut->PutCh('"'); SOut->PutStr(ArgVal); SOut->PutCh('"');
120      }
121      if (ETagP){
122        SOut->PutCh('/'); TagNm="";}
123      SOut->PutCh('>');
124    }
125  }
126  TXmlObjSerTagNm::TXmlObjSerTagNm(
127   TSOut& _SOut, const bool& ETagP,
128   const TStr& Nm, const TStr& TypeNm,
129   const TStr& ArgNm1, const TStr& ArgVal1,
130   const TStr& ArgNm2, const TStr& ArgVal2,
131   const TStr& ArgNm3, const TStr& ArgVal3,
132   const TStr& ArgNm4, const TStr& ArgVal4):
133    TagNm(), SOut(&_SOut){
134    if (Nm!="-"){
135      SOut->PutCh('<');
136      if (Nm.Empty()){
137        SOut->PutStr(TagNm=TypeNm);
138      } else {
139        SOut->PutStr(TagNm=Nm);
140        SOut->PutStr(" Type=\""); SOut->PutStr(TypeNm); SOut->PutCh('"');
141      }
142      if (!ArgNm1.Empty()){
143        SOut->PutCh(' '); SOut->PutStr(ArgNm1); SOut->PutCh('=');
144        SOut->PutCh('"'); SOut->PutStr(ArgVal1); SOut->PutCh('"');
145      }
146      if (!ArgNm2.Empty()){
147        SOut->PutCh(' '); SOut->PutStr(ArgNm2); SOut->PutCh('=');
148        SOut->PutCh('"'); SOut->PutStr(ArgVal2); SOut->PutCh('"');
149      }
150      if (!ArgNm3.Empty()){
151        SOut->PutCh(' '); SOut->PutStr(ArgNm3); SOut->PutCh('=');
152        SOut->PutCh('"'); SOut->PutStr(ArgVal3); SOut->PutCh('"');
153      }
154      if (!ArgNm4.Empty()){
155        SOut->PutCh(' '); SOut->PutStr(ArgNm4); SOut->PutCh('=');
156        SOut->PutCh('"'); SOut->PutStr(ArgVal4); SOut->PutCh('"');
157      }
158      if (ETagP){
159        SOut->PutCh('/'); TagNm="";}
160      SOut->PutCh('>');
161    }
162  }
163  TXmlObjSerTagNm::~TXmlObjSerTagNm(){
164    if (!TagNm.Empty()){
165      SOut->PutCh('<'); SOut->PutCh('/'); SOut->PutStr(TagNm); SOut->PutCh('>');
166    }
167  }
168  void TXmlChDef::SetChTy(TBSet& ChSet, const int& MnCh, const int& MxCh){
169    IAssert((0<=MnCh)&&((MxCh==-1)||((MnCh<=MxCh)&&(MxCh<Chs))));
170    ChSet.Incl(MnCh);
171    for (int Ch=MnCh+1; Ch<=MxCh; Ch++){
172      ChSet.Incl(Ch);}
173  }
174  void TXmlChDef::SetChTy(TBSet& ChSet, const TStr& Str){
175    for (int ChN=0; ChN<Str.Len(); ChN++){
176      uchar Ch=Str[ChN];
177      ChSet.Incl(Ch);
178    }
179  }
180  void TXmlChDef::SetEntityVal(const TStr& Nm, const TStr& Val){
181    EntityNmToValH.AddDat(Nm, Val);
182  }
183  TXmlChDef::TXmlChDef():
184    Chs(TUCh::Vals),
185    CharChSet(), CombChSet(), ExtChSet(),
186    LetterChSet(), DigitChSet(), NameChSet(), PubidChSet(),
187    EntityNmToValH(100){
188    CharChSet.Gen(Chs);
189    SetChTy(CharChSet, 0x1); SetChTy(CharChSet, 0x3); SetChTy(CharChSet, 0x6);
190    SetChTy(CharChSet, 11); SetChTy(CharChSet, 24); SetChTy(CharChSet, 27);
191    SetChTy(CharChSet, 0x9); SetChTy(CharChSet, 0xA); SetChTy(CharChSet, 0xD);
192    SetChTy(CharChSet, 0x20, TUCh::Mx);
193    TBSet BaseChSet(Chs);
194    SetChTy(BaseChSet, 0x41, 0x5A); SetChTy(BaseChSet, 0x61, 0x7A);
195    SetChTy(BaseChSet, 0xC0, 0xD6); SetChTy(BaseChSet, 0xD8, 0xF6);
196    SetChTy(BaseChSet, 0xF8, 0xFF);
197    TBSet IdeoChSet(Chs);
198    CombChSet.Gen(Chs);
199    ExtChSet.Gen(Chs);
200    SetChTy(ExtChSet, 0xB7);
201    LetterChSet=BaseChSet|IdeoChSet;
202    DigitChSet.Gen(Chs);
203    SetChTy(DigitChSet, 0x30, 0x39);
204    NameChSet=LetterChSet|DigitChSet|
205     uchar('.')|uchar('-')|uchar('_')|uchar(':')|CombChSet;
206    PubidChSet.Gen(Chs);
207    SetChTy(PubidChSet, 0x20); SetChTy(PubidChSet, 0xD); SetChTy(PubidChSet, 0xA);
208    SetChTy(PubidChSet, 'a', 'z'); SetChTy(PubidChSet, 'A', 'Z');
209    SetChTy(PubidChSet, '0', '9'); SetChTy(PubidChSet, "-'()+,./:=?;!*#@$_%");
210    SetEntityVal("amp", "&");
211    SetEntityVal("lt", "<"); SetEntityVal("gt", ">");
212    SetEntityVal("apos", "'"); SetEntityVal("quot", "\"");
213  }
214  TXmlChDef TXmlLx::ChDef;
215  uchar TXmlLx::GetCh(){
216    EAssert(Ch!=TCh::EofCh);
217    PrevCh=Ch;
218    if (ChStack.Empty()){Ch=(RSIn.Eof()) ? TCh::EofCh : RSIn.GetCh();}
219    else {Ch=ChStack.Pop();}
220    ChN++; if (Ch==TCh::LfCh){LnN++; LnChN=0;} else {LnChN++;}
221    return Ch;
222  }
223  void TXmlLx::ToNrSpacing(){
224    if (Spacing==xspIntact){
225    } else
226    if (Spacing==xspPreserve){
227      int SrcChN=0; int DstChN=0;
228      while (SrcChN<TxtChA.Len()){
229        if (TxtChA[SrcChN]==TCh::CrCh){
230          TxtChA.PutCh(DstChN, TCh::LfCh); SrcChN++; DstChN++;
231          if ((SrcChN<TxtChA.Len())&&(TxtChA[SrcChN]==TCh::LfCh)){SrcChN++;}
232        } else {
233          if (SrcChN!=DstChN){
234            TxtChA.PutCh(DstChN, TxtChA[SrcChN]);}
235          SrcChN++; DstChN++;
236        }
237      }
238      TxtChA.Trunc(DstChN);
239    } else
240    if (Spacing==xspSeparate){
241      int SrcChN=0; int DstChN=0;
242      while (SrcChN<TxtChA.Len()){
243        if (ChDef.IsWs(TxtChA[SrcChN])){
244          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
245            SrcChN++;
246          } else {
247            TxtChA.PutCh(DstChN, ' ');
248            SrcChN++; DstChN++;
249          }
250        } else {
251          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
252          SrcChN++; DstChN++;
253        }
254      }
255      TxtChA.Trunc(DstChN);
256    } else
257    if (Spacing==xspTruncate){
258      int SrcChN=0; int DstChN=0;
259      while (SrcChN<TxtChA.Len()){
260        if (ChDef.IsWs(TxtChA[SrcChN])){
261          if ((DstChN>0)&&(TxtChA[DstChN-1]==' ')){
262            SrcChN++;
263          } else {
264            TxtChA.PutCh(DstChN, ' ');
265            SrcChN++; DstChN++;
266          }
267        } else {
268          TxtChA.PutCh(DstChN, TxtChA[SrcChN]);
269          SrcChN++; DstChN++;
270        }
271      }
272      TxtChA.Trunc(DstChN);
273      while ((TxtChA.Len()>0)&&(ChDef.IsWs(TxtChA.LastCh()))){
274        TxtChA.Pop();}
275    } else {
276      Fail;
277    }
278  }
279  void TXmlLx::GetWs(const bool& IsRq){
280    int WSpaces=0; TxtChA.Clr();
281    while (ChDef.IsWs(Ch)){
282      WSpaces++; TxtChA+=Ch; GetCh();}
283    if (IsRq&&(WSpaces==0)){
284      EThrow("White-space required.");}
285  }
286  TStr TXmlLx::GetReference(){
287    if (Ch=='#'){
288      TChA RefChA; int RefCd=0;
289      if (GetCh()=='x'){
290        forever {
291          GetCh();
292          if (TCh::IsHex(Ch)){
293            RefChA+=Ch;
294            RefCd=RefCd*16+TCh::GetHex(Ch);
295          } else {
296            break;
297          }
298        }
299      } else {
300        forever {
301          if (TCh::IsNum(Ch)){
302            RefChA+=Ch;
303            RefCd=RefCd*10+TCh::GetNum(Ch);
304          } else {
305            break;
306          }
307          GetCh();
308        }
309      }
310      if ((!RefChA.Empty())&&(Ch==';')){
311        GetCh();
312  	  if (RefCd < 0x80) {
313  	      uchar RefCh=uchar(RefCd);
314  		  return TStr(RefCh);
315  	  } else {
316  		  TStr ResStr = TUnicode::EncodeUtf8(RefCd);
317  		  return ResStr;
318  	  }
319      } else {
320        EThrow("Invalid Char-Reference."); Fail; return TStr();
321      }
322    } else {
323      TStr EntityNm=GetName();
324      if ((!EntityNm.Empty())&&(Ch==';')){
325        GetCh();
326        TStr EntityVal;
327        if (IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
328        else if (ChDef.IsEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
329        else {EThrow(TStr("Entity-Reference (")+EntityNm+") does not exist.");}
330        return EntityVal;
331      } else {
332        EThrow("Invalid Entity-Reference."); Fail; return TStr();
333      }
334    }
335  }
336  TStr TXmlLx::GetPEReference(){
337    TStr EntityNm=GetName();
338    if ((EntityNm.Empty())||(Ch!=';')){EThrow("Invalid PEntity-Reference.");}
339    GetCh();
340    TStr EntityVal;
341    if (IsPEntityNm(EntityNm, EntityVal)){&bsol;*intentionaly empty*/}
342    else {EThrow(TStr("PEntity-Reference (")+EntityNm+") does not exist.");}
343    return EntityVal;
344  }
345  void TXmlLx::GetEq(){
346    GetWs(false);
347    if (Ch=='='){GetCh();}
348    else {EThrow("Equality ('=') character expected.");}
349    GetWs(false);
350  }
351  TStr TXmlLx::GetName(){
352    TChA NmChA;
353    if (ChDef.IsFirstNameCh(Ch)){
354      do {NmChA+=Ch;} while (ChDef.IsName(GetCh()));
355    } else {
356      EThrow("Invalid first name character.");
357    }
358    return NmChA;
359  }
360  TStr TXmlLx::GetName(const TStr& RqNm){
361    TStr Nm=GetName();
362    if (Nm==RqNm){return RqNm;}
363    else {EThrow(TStr("Name '")+RqNm+"' expected."); Fail; return TStr();}
364  }
365  void TXmlLx::GetComment(){
366    if (GetCh()!='-'){EThrow("Invalid comment start.");}
367    TxtChA.Clr();
368    forever {
369      GetCh();
370      if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
371      if (Ch=='-'){
372        if (GetCh()=='-'){
373          if (GetCh()=='>'){GetCh(); break;} 
374          else {EThrow("Invalid comment end.");}
375        } else {
376          if (!ChDef.IsChar(Ch)){EThrow("Invalid comment character.");}
377          TxtChA+='-'; TxtChA+=Ch; 
378        }
379      } else {
380        TxtChA+=Ch; 
381      }
382    }
383  }
384  TStr TXmlLx::GetAttValue(){
385    uchar QCh=Ch;
386    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid attribute-value start.");}
387    TChA ValChA; GetCh();
388    forever {
389      if ((Ch=='<')||(!ChDef.IsChar(Ch))){
390        EThrow("Invalid attribute-value character.");}
391      if (Ch==QCh){GetCh(); break;} 
392      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
393      else {ValChA+=Ch; GetCh();} 
394    }
395    return ValChA;
396  }
397  TStr TXmlLx::GetVersionNum(){
398    char QCh=Ch;
399    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
400    TChA VerNumChA;
401    GetCh();
402    do {
403      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
404       (('0'<=Ch)&&(Ch<='9'))||(Ch=='_')||(Ch=='.')||(Ch==':')||(Ch=='-')){
405        VerNumChA+=Ch;
406      } else {
407        EThrow("Invalid version-number character.");
408      }
409      GetCh();
410    } while (Ch!=QCh);
411    GetCh();
412    return VerNumChA;
413  }
414  TStr TXmlLx::GetEncName(){
415    char QCh=Ch;
416    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
417    TChA EncNmChA;
418    GetCh();
419    if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))){EncNmChA+=Ch;}
420    else {EThrow("Invalid encoding-name character.");}
421    GetCh();
422    while (Ch!=QCh){
423      if ((('a'<=Ch)&&(Ch<='z'))||(('A'<=Ch)&&(Ch<='Z'))||
424       (('0'<=Ch)&&(Ch<='9'))||(Ch=='.')||(Ch=='_')||(Ch=='-')){EncNmChA+=Ch;}
425      else {EThrow("Invalid version-number character.");}
426      GetCh();
427    }
428    GetCh();
429    return EncNmChA;
430  }
431  TStr TXmlLx::GetStalVal(){
432    char QCh=Ch;
433    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
434    TChA StalChA;
435    GetCh();
436    while (Ch!=QCh){
437      if (('a'<=Ch)&&(Ch<='z')){StalChA+=Ch;}
438      else {EThrow("Invalid standalone-value character.");}
439      GetCh();
440    }
441    GetCh();
442    TStr StalVal=StalChA;
443    if ((StalVal=="yes")||(StalVal=="no")){return StalVal;}
444    else {EThrow("Invalid standalone-value."); Fail; return TStr();}
445  }
446  void TXmlLx::GetXmlDecl(){
447    GetWs(true);
448    TStr VerNm=GetName("version"); GetEq(); TStr VerVal=GetVersionNum();
449    if (VerVal!="1.0"){EThrow("Invalid XML version.");}
450    AddArg(VerNm, VerVal);
451    GetWs(false);
452    if (Ch!='?'){
453      TStr EncNm=GetName("encoding"); GetEq(); TStr EncVal=GetEncName();
454      AddArg(EncNm, EncVal);
455    }
456    GetWs(false);
457    if (Ch!='?'){
458      TStr StalNm=GetName("standalone"); GetEq(); TStr StalVal=GetStalVal();
459      AddArg(StalNm, StalVal);
460    }
461    GetWs(false);
462    if (Ch=='?'){
463      GetCh();
464      if (Ch=='>'){GetCh();}
465      else {EThrow("Invalid end-of-tag in XML-declaration.");}
466    } else {
467      EThrow("Invalid end-of-tag in XML-declaration.");
468    }
469  }
470  void TXmlLx::GetPI(){
471    GetWs(false);
472    TxtChA.Clr();
473    forever {
474      if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
475      if (Ch=='?'){
476        if (GetCh()=='>'){
477          GetCh(); break;
478        } else {
479          if (!ChDef.IsChar(Ch)){EThrow("Invalid PI character.");}
480          TxtChA+='?'; TxtChA+=Ch; 
481        }
482      } else {
483        TxtChA+=Ch; 
484      }
485      GetCh();
486    }
487  }
488  TStr TXmlLx::GetSystemLiteral(){
489    char QCh=Ch;
490    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
491    TChA LitChA; GetCh();
492    while (Ch!=QCh){
493      if (!ChDef.IsChar(Ch)){EThrow("Invalid System-Literal character.");}
494      LitChA+=Ch; GetCh();
495    }
496    GetCh();
497    return LitChA;
498  }
499  TStr TXmlLx::GetPubidLiteral(){
500    char QCh=Ch;
501    if ((Ch!='\'')&&(Ch!='"')){EThrow("Quote character (' or \") expected.");}
502    TChA LitChA; GetCh();
503    while (Ch!=QCh){
504      if (!ChDef.IsPubid(Ch)){EThrow("Invalid Public-Id-Literal character.");}
505      LitChA+=Ch; GetCh();
506    }
507    GetCh();
508    return LitChA;
509  }
510  void TXmlLx::GetExternalId(){
511    TStr ExtIdNm=GetName();
512    if (ExtIdNm=="SYSTEM"){
513      GetWs(true); GetSystemLiteral();
514    } else if (ExtIdNm=="PUBLIC"){
515      GetWs(true); GetPubidLiteral(); GetWs(true); GetSystemLiteral();
516    } else {
517      EThrow("Invalid external-id ('SYSTEM' or 'PUBLIC' expected).");
518    }
519  }
520  void TXmlLx::GetNData(){
521    GetName("NDATA"); GetWs(true); GetName();
522  }
523  void TXmlLx::GetDocTypeDecl(){
524    GetWs(true);
525    TStr DocTypeDeclNm=GetName();
526    GetWs(false);
527    if (Ch=='>'){GetCh(); return;}
528    if (Ch!='['){GetExternalId();}
529    GetWs(false);
530    if (Ch=='['){
531      GetCh();
532      GetWs(false);
533      while (Ch!=']'){
534        if (ChDef.IsWs(Ch)){GetWs(true);}
535        else if (Ch=='%'){GetPEReference();}
536        else {
537          GetSym();
538        }
539      }
540      GetCh();
541    }
542    GetWs(false);
543    if (Ch=='>'){GetCh();}
544    else {EThrow("Invalid end-of-tag in document-type-declaration.");}
545    TagNm=DocTypeDeclNm;
546  }
547  void TXmlLx::GetElement(){
548    TxtChA.Clr();
549    while (Ch!='>'){
550      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
551      TxtChA+=Ch; GetCh();
552    }
553    GetCh();
554  }
555  void TXmlLx::GetAttList(){
556    TxtChA.Clr();
557    while (Ch!='>'){
558      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
559      TxtChA+=Ch; GetCh();
560    }
561    GetCh();
562  }
563  TStr TXmlLx::GetEntityValue(){
564    uchar QCh=Ch;
565    if ((QCh!='"')&&(QCh!='\'')){EThrow("Invalid entity-value start.");}
566    TChA ValChA; GetCh();
567    forever {
568      if (!ChDef.IsChar(Ch)){EThrow("Invalid entity-value character.");}
569      if (Ch==QCh){GetCh(); break;} 
570      else if (Ch=='&'){GetCh(); ValChA+=GetReference();} 
571      else if (Ch=='%'){GetCh(); ValChA+=GetPEReference();} 
572      else {ValChA+=Ch; GetCh();} 
573    }
574    return ValChA;
575  }
576  void TXmlLx::GetEntity(){
577    GetWs(true); TStr EntityNm;
578    if (Ch=='%'){
579      GetCh(); GetWs(true); EntityNm=GetName(); GetWs(true);
580      if ((Ch=='\"')||(Ch=='\'')){
581        TStr EntityVal=GetEntityValue();
582        PutPEntityVal(EntityNm, EntityVal);
583      } else {
584        GetExternalId();
585        GetWs(false);
586        if (Ch!='>'){GetNData();}
587      }
588    } else {
589      EntityNm=GetName(); GetWs(true);
590      if ((Ch=='\"')||(Ch=='\'')){
591        TStr EntityVal=GetEntityValue();
592        PutEntityVal(EntityNm, EntityVal);
593      } else {
594        GetExternalId();
595      }
596    }
597    GetWs(false);
598    if (Ch=='>'){GetCh();}
599    else {EThrow("Invalid end-of-tag in entity-declaration.");}
600    TagNm=EntityNm;
601  }
602  void TXmlLx::GetNotation(){
603    TxtChA.Clr();
604    while (Ch!='>'){
605      if (!ChDef.IsChar(Ch)){EThrow("Invalid Element character.");}
606      TxtChA+=Ch; GetCh();
607    }
608    GetCh();
609  }
610  void TXmlLx::GetCDSect(){
611    if (Ch=='['){GetCh();}
612    else {EThrow("Invalid start of CDATA section.");}
613    TxtChA.Clr();
614    forever {
615      if (!ChDef.IsChar(Ch)){EThrow("Invalid CDATA character.");}
616      if ((Ch=='>')&&(TxtChA.Len()>=2)&&
617       (TxtChA.LastLastCh()==']') && (TxtChA.LastCh()==']')){
618        GetCh(); TxtChA.Pop(); TxtChA.Pop(); break;
619      } else {
620        TxtChA+=Ch; GetCh();
621      }
622    }
623  }
624  void TXmlLx::SkipWs(){
625    while (ChDef.IsWs(Ch)){GetCh();}
626  }
627  TXmlLxSym TXmlLx::GetSym(){
628    if (Ch=='<'){
629      GetCh(); ClrArgV();
630      if (Ch=='?'){
631        GetCh(); TagNm=GetName();
632        if (TagNm.GetLc()=="xml"){Sym=xsyXmlDecl; GetXmlDecl();}
633        else {Sym=xsyPI; GetPI();}
634      } else
635      if (Ch=='!'){
636        GetCh();
637        if (Ch=='['){
638          GetCh(); TagNm=GetName();
639          if (TagNm=="CDATA"){Sym=xsyQStr; GetCDSect();}
640          else {EThrow(TStr("Invalid tag after '<![' (")+TagNm+").");}
641        } else
642        if (Ch=='-'){
643          Sym=xsyComment; GetComment();
644        } else {
645          TagNm=GetName();
646          if (TagNm=="DOCTYPE"){GetDocTypeDecl(); Sym=xsyDocTypeDecl;}
647          else if (TagNm=="ELEMENT"){GetElement(); Sym=xsyElement;}
648          else if (TagNm=="ATTLIST"){GetAttList(); Sym=xsyAttList;}
649          else if (TagNm=="ENTITY"){GetEntity(); Sym=xsyEntity;}
650          else if (TagNm=="NOTATION"){GetNotation(); Sym=xsyNotation;}
651          else {EThrow(TStr("Invalid tag (")+TagNm+").");}
652        }
653      } else
654      if (Ch=='/'){
655        GetCh(); Sym=xsyETag; TagNm=GetName(); GetWs(false);
656        if (Ch=='>'){GetCh();}
657        else {EThrow("Invalid End-Tag.");}
658      } else {
659        TagNm=GetName(); GetWs(false);
660        while ((Ch!='>')&&(Ch!='/')){
661          TStr AttrNm=GetName();
662          GetEq();
663          TStr AttrVal=GetAttValue();
664          GetWs(false);
665          AddArg(AttrNm, AttrVal);
666        }
667        if (Ch=='/'){
668          if (GetCh()=='>'){Sym=xsySETag; GetCh();}
669          else {EThrow("Invalid Empty-Element-Tag.");}
670        } else {
671          Sym=xsySTag; GetCh();
672        }
673      }
674      if (Spacing==xspTruncate){SkipWs();}
675    } else
676    if (ChDef.IsWs(Ch)){
677      Sym=xsyWs; GetWs(true); ToNrSpacing();
678      if (Spacing==xspTruncate){GetSym();}
679    } else
680    if (Ch==TCh::EofCh){
681      Sym=xsyEof;
682    } else {
683      Sym=xsyStr; TxtChA.Clr();
684      forever {
685        if (!ChDef.IsChar(Ch)){
686          EThrow(TUInt::GetStr(Ch, "Invalid character (%d)."));}
687        if (Ch=='<'){break;} 
688        if (Ch=='&'){GetCh(); TxtChA+=GetReference();} 
689        else {
690          if ((Ch=='>')&&(TxtChA.Len()>=2)&&
691           (TxtChA.LastLastCh()==']')&&(TxtChA.LastCh()==']')){
692            EThrow("Forbidden substring ']]>' in character data.");}
693          TxtChA+=Ch; GetCh(); 
694        }
695      }
696      ToNrSpacing();
697    }
698    return Sym;
699  }
700  TStr TXmlLx::GetSymStr() const {
701    TChA SymChA;
702    switch (Sym){
703      case xsyUndef:
704        SymChA="{Undef}"; break;
705      case xsyWs:
706        SymChA+="{Space:'"; SymChA+=TStr(TxtChA).GetHex(); SymChA+="'}"; break;
707      case xsyComment:
708        SymChA+="<!--"; SymChA+=TxtChA; SymChA+="-->"; break;
709      case xsyXmlDecl:{
710        SymChA+="<?"; SymChA+=TagNm;
711        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
712          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
713          char ArgValQCh=GetArgValQCh(ArgVal);
714          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
715          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
716        }
717        SymChA+="?>"; break;}
718      case xsyPI:
719        SymChA+="<?"; SymChA+=TagNm;
720        if (!TxtChA.Empty()){SymChA+=' '; SymChA+=TxtChA;}
721        SymChA+="?>"; break;
722      case xsyDocTypeDecl:
723        SymChA+="<!DOCTYPE "; SymChA+=TagNm; SymChA+=">"; break;
724      case xsySTag:
725      case xsySETag:{
726        SymChA+="<"; SymChA+=TagNm;
727        for (int ArgN=0; ArgN<GetArgs(); ArgN++){
728          TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
729          char ArgValQCh=GetArgValQCh(ArgVal);
730          SymChA+=' '; SymChA+=ArgNm; SymChA+='=';
731          SymChA+=ArgValQCh; SymChA+=ArgVal; SymChA+=ArgValQCh;
732        }
733        if (Sym==xsySTag){SymChA+=">";}
734        else if (Sym==xsySETag){SymChA+="/>";}
735        else {Fail;}
736        break;}
737      case xsyETag:
738        SymChA+="</"; SymChA+=TagNm; SymChA+=">"; break;
739      case xsyStr:
740        SymChA="{String:'"; SymChA+=TxtChA; SymChA+="'}"; break;
741      case xsyQStr:
742        SymChA="{QString:'"; SymChA+=TxtChA; SymChA+="'}"; break;
743      case xsyEof:
744        SymChA="{Eof}"; break;
745      default: Fail;
746    }
747    return SymChA;
748  }
749  void TXmlLx::EThrow(const TStr& MsgStr) const {
750    TChA FPosChA;
751    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
752    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
753    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
754    FPosChA+="]";
755    TStr FullMsgStr=MsgStr+FPosChA;
756    TExcept::Throw(FullMsgStr);
757  }
758  TStr TXmlLx::GetFPosStr() const {
759    TChA FPosChA;
760    FPosChA+=" [File:"; FPosChA+=SIn->GetSNm();
761    FPosChA+=" Line:"; FPosChA+=TInt::GetStr(LnN);
762    FPosChA+=" Char:"; FPosChA+=TInt::GetStr(LnChN);
763    FPosChA+="]";
764    return FPosChA;
765  }
766  TStr TXmlLx::GetXmlLxSymStr(const TXmlLxSym& XmlLxSym){
767    switch (XmlLxSym){
768      case xsyUndef: return "Undef";
769      case xsyWs: return "White-Space";
770      case xsyComment: return "Comment";
771      case xsyXmlDecl: return "Declaration";
772      case xsyPI: return "PI";
773      case xsyDocTypeDecl: return "Document-Type";
774      case xsyElement: return "Element";
775      case xsyAttList: return "Attribute-List";
776      case xsyEntity: return "Entity";
777      case xsyNotation: return "Notation";
778      case xsyTag: return "Tag";
779      case xsySTag: return "Start-Tag";
780      case xsyETag: return "End-Tag";
781      case xsySETag: return "Start-End-Tag";
782      case xsyStr: return "String";
783      case xsyQStr: return "Quoted-String";
784      case xsyEof: return "Eon-Of-File";
785      default: return "Undef";
786    }
787  }
788  bool TXmlLx::IsTagNm(const TStr& Str){
789    TChA ChA=Str;
790    if (ChA.Len()>0){
791      if (TXmlLx::ChDef.IsFirstNameCh(ChA[0])){
792        for (int ChN=1; ChN<ChA.Len(); ChN++){
793          if (!TXmlLx::ChDef.IsName(ChA[ChN])){
794            return false;
795          }
796        }
797        return true;
798      } else {
799        return false;
800      }
801    } else {
802      return false;
803    }
804  }
805  TStr TXmlLx::GetXmlStrFromPlainMem(const TMem& PlainMem){
806    TChA XmlChA;
807    for (int ChN=0; ChN<PlainMem.Len(); ChN++){
808      uchar Ch=PlainMem[ChN];
809      if ((' '<=Ch)&&(Ch<='~')){
810        switch (Ch){
811          case '"': XmlChA+="&quot;"; break;
812          case '&': XmlChA+="&amp;"; break;
813          case '\'': XmlChA+="&apos;"; break;
814          case '<': XmlChA+="&lt;"; break;
815          case '>': XmlChA+="&gt;"; break;
816          default: XmlChA+=Ch;
817        }
818      } else
819      if ((Ch=='\r')||(Ch=='\n')){
820        XmlChA+=Ch;
821      } else {
822        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
823      }
824    }
825    return XmlChA;
826  }
827  TStr TXmlLx::GetXmlStrFromPlainStr(const TChA& PlainChA){
828    TChA XmlChA;
829    for (int ChN=0; ChN<PlainChA.Len(); ChN++){
830      uchar Ch=PlainChA[ChN];
831      if ((' '<=Ch)&&(Ch<='~')){
832        switch (Ch){
833          case '"': XmlChA+="&quot;"; break;
834          case '&': XmlChA+="&amp;"; break;
835          case '\'': XmlChA+="&apos;"; break;
836          case '<': XmlChA+="&lt;"; break;
837          case '>': XmlChA+="&gt;"; break;
838          default: XmlChA+=Ch;
839        }
840      } else
841      if ((Ch=='\r')||(Ch=='\n')){
842        XmlChA+=Ch;
843      } else {
844        XmlChA+='&'; XmlChA+='#'; XmlChA+=TUInt::GetStr(Ch); XmlChA+=';';
845      }
846    }
847    return XmlChA;
848  }
849  TStr TXmlLx::GetPlainStrFromXmlStr(const TStr& XmlStr){
850    TChA PlainChA;
851    TChRet Ch(TStrIn::New(XmlStr));
852    Ch.GetCh();
853    while (!Ch.Eof()){
854      if (Ch()!='&'){
855        PlainChA+=Ch(); Ch.GetCh();
856      } else {
857        if (Ch.GetCh()=='#'){
858          TChA RefChA; int RefCd=0;
859          if (Ch.GetCh()=='x'){
860            forever {
861              Ch.GetCh();
862              if (TCh::IsHex(Ch())){
863                RefChA+=Ch();
864                RefCd=RefCd*16+TCh::GetHex(Ch());
865              } else {
866                break;
867              }
868            }
869          } else {
870            forever {
871              if (TCh::IsNum(Ch())){
872                RefChA+=Ch();
873                RefCd=RefCd*10+TCh::GetNum(Ch());
874              } else {
875                break;
876              }
877              Ch.GetCh();
878            }
879          }
880          if ((!RefChA.Empty())&&(Ch()==';')){
881            Ch.GetCh();
882  		  if (RefCd < 0x80) {
883  			uchar RefCh=uchar(RefCd);
884  			PlainChA+=RefCh;
885  		  } else {
886  			TUnicode::EncodeUtf8(RefCd, PlainChA);
887  		  }
888          }
889        } else {
890          TChA EntityNm;
891          while ((!Ch.Eof())&&(Ch()!=';')){
892            EntityNm+=Ch(); Ch.GetCh();}
893          if ((!EntityNm.Empty())&&(Ch()==';')){
894            Ch.GetCh();
895            if (EntityNm=="quot"){PlainChA+='"';}
896            else if (EntityNm=="amp"){PlainChA+='&';}
897            else if (EntityNm=="apos"){PlainChA+='\'';}
898            else if (EntityNm=="lt"){PlainChA+='<';}
899            else if (EntityNm=="gt"){PlainChA+='>';}
900          }
901        }
902      }
903    }
904    return PlainChA;
905  }
906  TStr TXmlLx::GetUsAsciiStrFromXmlStr(const TStr& XmlStr){
907    TStr UsAsciiStr=XmlStr;
908    UsAsciiStr.ChangeStrAll("&#232;", "c");
909    UsAsciiStr.ChangeStrAll("&#200;", "C");
910    UsAsciiStr.ChangeStrAll("&#154;", "s");
911    UsAsciiStr.ChangeStrAll("&#138;", "S");
912    UsAsciiStr.ChangeStrAll("&#158;", "z");
913    UsAsciiStr.ChangeStrAll("&#142;", "Z");
914    TChA UsAsciiChA=TXmlLx::GetPlainStrFromXmlStr(UsAsciiStr);
915    for (int ChN=0; ChN<UsAsciiChA.Len(); ChN++){
916      char Ch=UsAsciiChA[ChN];
917      if ((Ch<' ')||('~'<Ch)){UsAsciiChA.PutCh(ChN, 'x');}
918    }
919    return UsAsciiChA;
920  }
921  TStr TXmlLx::GetChRefFromYuEntRef(const TStr& YuEntRefStr){
922    TStr ChRefStr=YuEntRefStr;
923    ChRefStr.ChangeStrAll("&ch;", "&#232;");
924    ChRefStr.ChangeStrAll("&Ch;", "&#200;");
925    ChRefStr.ChangeStrAll("&sh;", "&#154;");
926    ChRefStr.ChangeStrAll("&Sh;", "&#138;");
927    ChRefStr.ChangeStrAll("&zh;", "&#158;");
928    ChRefStr.ChangeStrAll("&Zh;", "&#142;");
929    ChRefStr.ChangeStrAll("&cs", "c");
930    ChRefStr.ChangeStrAll("&Cs;", "C");
931    ChRefStr.ChangeStrAll("&dz;", "dz");
932    ChRefStr.ChangeStrAll("&Dz;", "Dz");
933    return ChRefStr;
934  }
935  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm, const bool& DfVal) const {
936    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
937    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TBool::TrueStr);
938  }
939  bool TXmlTok::GetBoolArgVal(
940   const TStr& ArgNm, const TStr& TrueVal, const bool& DfVal) const {
941    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
942    return (ArgN==-1) ? DfVal : (ArgNmValV[ArgN].Dat==TrueVal);
943  }
944  bool TXmlTok::GetBoolArgVal(const TStr& ArgNm,
945   const TStr& TrueVal, const TStr& FalseVal, const bool& DfVal) const {
946    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
947    if (ArgN==-1){return DfVal;}
948    TStr ArgVal=ArgNmValV[ArgN].Dat;
949    if (ArgVal==TrueVal){return true;}
950    IAssert(ArgVal == FalseVal); return false;
951  }
952  int TXmlTok::GetIntArgVal(const TStr& ArgNm, const int& DfVal) const {
953    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
954    if (ArgN==-1){
955      return DfVal;
956    } else {
957      int Val;
958      if (ArgNmValV[ArgN].Dat.IsInt(Val)){return Val;} else {return DfVal;}
959    }
960  }
961  double TXmlTok::GetFltArgVal(const TStr& ArgNm, const double& DfVal) const {
962    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
963    if (ArgN==-1){
964      return DfVal;
965    } else {
966      double Val;
967      if (ArgNmValV[ArgN].Dat.IsFlt(Val)){return Val;} else {return DfVal;}
968    }
969  }
970  TStr TXmlTok::GetStrArgVal(const TStr& ArgNm, const TStr& DfVal) const {
971    int ArgN=ArgNmValV.SearchForw(TStrKd(ArgNm));
972    return (ArgN==-1) ? DfVal : ArgNmValV[ArgN].Dat;
973  }
974  void TXmlTok::PutSubTok(const PXmlTok& Tok, const int& SubTokN){
975    if (SubTokN==-1){
976      ClrSubTok(); AddSubTok(Tok);
977    } else {
978      SubTokV[SubTokN]=Tok;
979    }
980  }
981  PXmlTok TXmlTok::GetTagTok(const TStr& TagPath) const {
982    if (TagPath.Empty()){
983      return (TXmlTok*)this;
984    } else {
985      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
986      PXmlTok SubTok;
987      for (int SubTokN=0; SubTokN<SubTokV.Len(); SubTokN++){
988        SubTok=SubTokV[SubTokN];
989        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){break;}
990        else {SubTok=NULL;}
991      }
992      if ((SubTok.Empty())||(RestTagPath.Empty())){return SubTok;}
993      else {return SubTok->GetTagTok(RestTagPath);}
994    }
995  }
996  void TXmlTok::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
997    XmlTokV.Clr();
998    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
999    PXmlTok Tok=GetTagTok(PreTagPath);
1000    if (!Tok.Empty()){
1001      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1002        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1003        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1004          XmlTokV.Add(SubTok);}
1005      }
1006    }
1007  }
1008  void TXmlTok::GetTagValV(const TStr& TagNm, const bool& XmlP, TStrV& ValV) const {
1009    if ((Sym==xsyTag)&&(Str==TagNm)){
1010      ValV.Add(GetTokStr(XmlP));
1011    } else {
1012      for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1013        GetSubTok(SubTokN)->GetTagValV(TagNm, XmlP, ValV);}
1014    }
1015  }
1016  TStr TXmlTok::GetTagVal(const TStr& TagNm, const bool& XmlP) const {
1017    TStrV ValV; GetTagValV(TagNm, XmlP, ValV);
1018    if (ValV.Len()>0){return ValV[0];} else {return "";}
1019  }
1020  void TXmlTok::AddTokToChA(const bool& XmlP, TChA& ChA) const {
1021    switch (Sym){
1022      case xsyWs:
1023        ChA+=Str; break;
1024      case xsyStr:
1025        if (XmlP){ChA+=TXmlLx::GetXmlStrFromPlainStr(Str);} else {ChA+=Str;} break;
1026      case xsyQStr:
1027        if (XmlP){ChA+="<![CDATA[";}
1028        ChA+=Str;
1029        if (XmlP){ChA+="]]>";} break;
1030      case xsyTag:
1031        if (XmlP){
1032          ChA+='<'; ChA+=Str;
1033          for (int ArgN=0; ArgN<GetArgs(); ArgN++){
1034            TStr ArgNm; TStr ArgVal; GetArg(ArgN, ArgNm, ArgVal);
1035            if (XmlP){ArgVal=TXmlLx::GetXmlStrFromPlainStr(ArgVal);}
1036            char ArgValQCh=TXmlLx::GetArgValQCh(ArgVal);
1037            ChA+=' '; ChA+=ArgNm; ChA+='=';
1038            ChA+=ArgValQCh; ChA+=ArgVal; ChA+=ArgValQCh;
1039          }
1040        }
1041        if (GetSubToks()==0){
1042          if (XmlP){ChA+="/>";}
1043        } else {
1044          if (XmlP){ChA+=">";}
1045          for (int SubTokN=0; SubTokN<GetSubToks(); SubTokN++){
1046            GetSubTok(SubTokN)->AddTokToChA(XmlP, ChA);}
1047          if (XmlP){ChA+="</"; ChA+=Str; ChA+='>';}
1048        }
1049        break;
1050      default: Fail;
1051    }
1052  }
1053  TStr TXmlTok::GetTokVStr(const TXmlTokV& TokV, const bool& XmlP){
1054    TChA TokVChA;
1055    for (int TokN=0; TokN<TokV.Len(); TokN++){
1056      if (TokN>0){TokVChA+=' ';}
1057      TokVChA+=TokV[TokN]->GetTokStr(XmlP);
1058    }
1059    return TokVChA;
1060  }
1061  PXmlTok TXmlTok::GetTok(TXmlLx& Lx){
1062    switch (Lx.Sym){
1063      case xsyWs:
1064      case xsyStr:
1065      case xsyQStr:
1066        return TXmlTok::New(Lx.Sym, Lx.TxtChA);
1067      case xsySTag:
1068      case xsySETag:
1069        return TXmlTok::New(xsyTag, Lx.TagNm, Lx.ArgNmValKdV);
1070      default: Fail; return NULL;
1071    }
1072  }
1073  void TXmlDoc::LoadTxtMiscStar(TXmlLx& Lx){
1074    while ((Lx.Sym==xsyComment)||(Lx.Sym==xsyPI)||(Lx.Sym==xsyWs)){
1075      Lx.GetSym();}
1076  }
1077  PXmlTok TXmlDoc::LoadTxtElement(TXmlLx& Lx){
1078    PXmlTok Tok;
1079    if (Lx.Sym==xsySETag){
1080      Tok=TXmlTok::GetTok(Lx);
1081    } else
1082    if (Lx.Sym==xsySTag){
1083      Tok=TXmlTok::GetTok(Lx);
1084      forever {
1085        Lx.GetSym();
1086        if (Lx.Sym==xsyETag){
1087          if (Tok->GetStr()==Lx.TagNm){
1088            break;
1089          } else {
1090            TStr MsgStr=TStr("Invalid End-Tag '")+Lx.TagNm+
1091             "' ('"+Tok->GetStr()+"' expected).";
1092            Lx.EThrow(MsgStr);
1093          }
1094        } else {
1095          PXmlTok SubTok;
1096          switch (Lx.Sym){
1097            case xsySTag:
1098              SubTok=LoadTxtElement(Lx); break;
1099            case xsySETag:
1100            case xsyStr:
1101            case xsyQStr:
1102            case xsyWs:
1103              SubTok=TXmlTok::GetTok(Lx); break;
1104            case xsyPI:
1105            case xsyComment:
1106              break;
1107            default: Lx.EThrow("Content or End-Tag expected.");
1108          }
1109          if (!SubTok.Empty()){
1110            Tok->AddSubTok(SubTok);}
1111        }
1112      }
1113    } else
1114    if (Lx.Sym==xsyETag){
1115      TStr MsgStr=
1116       TStr("Xml-Element (Start-Tag or Empty-Element-Tag) required.")+
1117       TStr::GetStr(Lx.TagNm, " End-Tag </%s> encountered.");
1118      Lx.EThrow(MsgStr);
1119    } else {
1120      Lx.EThrow("Xml-Element (Start-Tag or Empty-Element-Tag) required.");
1121    }
1122    return Tok;
1123  }
1124  PXmlTok TXmlDoc::GetTagTok(const TStr& TagPath) const {
1125    if (TagPath.Empty()){
1126      return Tok;
1127    } else {
1128      TStr TagNm; TStr RestTagPath; TagPath.SplitOnCh(TagNm, '|', RestTagPath);
1129      if ((Tok->GetSym()==xsyTag)&&(Tok->GetStr()==TagNm)){
1130        if (RestTagPath.Empty()){return Tok;}
1131        else {return Tok->GetTagTok(RestTagPath);}
1132      } else {
1133        return NULL;
1134      }
1135    }
1136  }
1137  void TXmlDoc::PutTagTokStr(const TStr& TagPath, const TStr& TokStr) const {
1138    PXmlTok Tok=GetTagTok(TagPath);
1139    Tok->ClrSubTok();
1140    PXmlTok StrTok=TXmlTok::New(xsyStr, TokStr);
1141    Tok->AddSubTok(StrTok);
1142  }
1143  void TXmlDoc::GetTagTokV(const TStr& TagPath, TXmlTokV& XmlTokV) const {
1144    XmlTokV.Clr();
1145    TStr PreTagPath; TStr TagNm; TagPath.SplitOnLastCh(PreTagPath, '|', TagNm);
1146    PXmlTok Tok=GetTagTok(PreTagPath);
1147    if (!Tok.Empty()){
1148      for (int SubTokN=0; SubTokN<Tok->GetSubToks(); SubTokN++){
1149        PXmlTok SubTok=Tok->GetSubTok(SubTokN);
1150        if ((SubTok->GetSym()==xsyTag)&&(SubTok->GetStr()==TagNm)){
1151          XmlTokV.Add(SubTok);}
1152      }
1153    }
1154  }
1155  bool TXmlDoc::GetTagTokBoolArgVal(
1156   const TStr& TagPath, const TStr& ArgNm, const bool& DfVal) const {
1157    PXmlTok TagTok;
1158    if (IsTagTok(TagPath, TagTok)){
1159      return TagTok->GetBoolArgVal(ArgNm, DfVal);}
1160    else {return DfVal;}
1161  }
1162  int TXmlDoc::GetTagTokIntArgVal(
1163   const TStr& TagPath, const TStr& ArgNm, const int& DfVal) const {
1164    PXmlTok TagTok;
1165    if (IsTagTok(TagPath, TagTok)){
1166      return TagTok->GetIntArgVal(ArgNm, DfVal);}
1167    else {return DfVal;}
1168  }
1169  double TXmlDoc::GetTagTokFltArgVal(
1170   const TStr& TagPath, const TStr& ArgNm, const double& DfVal) const {
1171    PXmlTok TagTok;
1172    if (IsTagTok(TagPath, TagTok)){
1173      return TagTok->GetFltArgVal(ArgNm, DfVal);}
1174    else {return DfVal;}
1175  }
1176  TStr TXmlDoc::GetTagTokStrArgVal(
1177   const TStr& TagPath, const TStr& ArgNm, const TStr& DfVal) const {
1178    PXmlTok TagTok;
1179    if (IsTagTok(TagPath, TagTok)){
1180      return TagTok->GetStrArgVal(ArgNm, DfVal);}
1181    else {return DfVal;}
1182  }
1183  TStr TXmlDoc::GetXmlStr(const TStr& Str){
1184    TChA ChA=Str;
1185    TChA XmlChA;
1186    for (int ChN=0; ChN<ChA.Len(); ChN++){
1187      uchar Ch=ChA[ChN];
1188      if ((' '<=Ch)&&(Ch<='~')){
1189        if (Ch=='&'){XmlChA+="&amp;";}
1190        else if (Ch=='>'){XmlChA+="&lt;";}
1191        else if (Ch=='<'){XmlChA+="&gt;";}
1192        else if (Ch=='\''){XmlChA+="&apos;";}
1193        else if (Ch=='\"'){XmlChA+="&quot;";}
1194        else {XmlChA+=Ch;}
1195      } else {
1196        XmlChA+="&#"; XmlChA+=TUInt::GetStr(Ch); XmlChA+=";";
1197      }
1198    }
1199    return XmlChA;
1200  }
1201  bool TXmlDoc::SkipTopTag(const PSIn& SIn){
1202    bool Ok=true;
1203    TXmlLx Lx(SIn, xspIntact);
1204    try {
1205      Lx.GetSym();
1206      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1207      LoadTxtMiscStar(Lx);
1208      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1209      LoadTxtMiscStar(Lx);
1210      Ok=true;
1211    }
1212    catch (PExcept Except){
1213      Ok=false;
1214    }
1215    return Ok;
1216  }
1217  PXmlDoc TXmlDoc::LoadTxt(TXmlLx& Lx){
1218    PXmlDoc Doc=TXmlDoc::New();
1219    try {
1220      Lx.GetSym();
1221      if (Lx.Sym==xsyXmlDecl){Lx.GetSym();}
1222      LoadTxtMiscStar(Lx);
1223      if (Lx.Sym==xsyDocTypeDecl){Lx.GetSym();}
1224      LoadTxtMiscStar(Lx);
1225      Doc->Tok=LoadTxtElement(Lx);
1226      LoadTxtMiscStar(Lx);
1227      Doc->Ok=true; Doc->MsgStr="Ok";
1228    }
1229    catch (PExcept& Except){
1230      Doc->Ok=false; Doc->MsgStr=Except->GetMsgStr();
1231    }
1232    return Doc;
1233  }
1234  PXmlDoc TXmlDoc::LoadTxt(const PSIn& SIn, const TXmlSpacing& Spacing){
1235    TXmlLx Lx(SIn, Spacing); return LoadTxt(Lx);
1236  }
1237  PXmlDoc TXmlDoc::LoadTxt(const TStr& FNm, const TXmlSpacing& Spacing){
1238    PSIn SIn=TFIn::New(FNm); return LoadTxt(SIn, Spacing);
1239  }
1240  void TXmlDoc::LoadTxt(
1241   const TStr& FNm, TXmlDocV& XmlDocV, const TXmlSpacing& Spacing){
1242    XmlDocV.Clr();
1243    PSIn SIn=TFIn::New(FNm);
1244    TXmlLx Lx(SIn, Spacing);
1245    PXmlDoc XmlDoc;
1246    forever {
1247      Lx.SkipWs();
1248      XmlDoc=LoadTxt(Lx);
1249      if (XmlDoc->IsOk()){XmlDocV.Add(XmlDoc);}
1250      else {break;}
1251    }
1252  }
1253  PXmlDoc TXmlDoc::LoadStr(const TStr& Str){
1254    PSIn SIn=TStrIn::New(Str);
1255    return LoadTxt(SIn);
1256  }
1257  void TXmlDoc::SaveStr(TStr& Str){
1258    PSOut SOut=TMOut::New(); TMOut& MOut=*(TMOut*)SOut();
1259    SaveTxt(SOut);
1260    Str=MOut.GetAsStr();
1261  }
1262  TXmlLxSym TXmlParser::GetSym() {
1263    if (NextSym != xsyUndef) {
1264      Sym = NextSym;  NextSym=xsyUndef;
1265      SymStr=NextSymStr;  NextSymStr.Clr();
1266      return Sym;
1267    }
1268    SymStr.Clr();
1269    char Ch;
1270    while (TCh::IsWs(Ch=GetCh())) { }
1271    if (Ch == TCh::EofCh) { Sym = xsyEof; return xsyEof; }
1272    if (Ch == '<') { 
1273      Ch = GetCh();
1274      if (Ch == '/') { Sym = xsyETag; }
1275      else { Sym = xsySTag;  SymStr.Push(Ch); }
1276      while((Ch=GetCh())!='>' && Ch!=TCh::EofCh) { SymStr.Push(Ch); }
1277      const int StrLen = SymStr.Len();
1278      if (StrLen > 1 && SymStr[StrLen-1] == '/') {
1279        Sym = xsyETag; SymStr[StrLen-1] = 0;
1280        for (char *c = SymStr.CStr()+StrLen-2; TCh::IsWs(*c); c--) { *c=0; }
1281      }
1282    } else { 
1283      _SymStr.Clr();  _SymStr.Push(Ch);
1284      while (! RSIn.Eof() && RSIn.PeekCh() != '<') { _SymStr.Push(GetCh()); }
1285      GetPlainStrFromXmlStr(_SymStr, SymStr);
1286      Sym = xsyStr;
1287    }
1288    if (Ch == TCh::EofCh) { SymStr.Clr(); Sym = xsyEof; return xsyEof; }
1289    return Sym;
1290  }
1291  TXmlLxSym TXmlParser::GetSym(TChA& _SymStr) {
1292    GetSym();
1293    _SymStr = SymStr;
1294    return Sym;
1295  }
1296  TXmlLxSym TXmlParser::PeekSym() {
1297    if (NextSym == xsyUndef) {
1298      const TXmlLxSym TmpSim=Sym;
1299      const TChA TmpSymStr=SymStr;
1300      NextSym=GetSym(NextSymStr);
1301      Sym=TmpSim;
1302      SymStr=TmpSymStr;
1303    }
1304    return NextSym;
1305  }
1306  TXmlLxSym TXmlParser::PeekSym(TChA& _SymStr) {
1307    PeekSym();
1308    _SymStr = NextSymStr;
1309    return NextSym;
1310  }
1311  void TXmlParser::SkipTillTag(const TChA& _SymStr) {
1312    while(PeekSym() != xsyEof) {
1313      if (NextSymStr == _SymStr) { return; }
1314      GetSym();
1315    }
1316  }
1317  void TXmlParser::GetTagVal(const TChA& TagStr, TChA& TagVal) {
1318    EAssertR(GetTag(TagStr) == xsySTag, TStr::Fmt("Expected '<%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1319    EAssertR(GetSym(TagVal) == xsyStr, "Expected string tag.");
1320    EAssertR(GetTag(TagStr) == xsyETag, TStr::Fmt("Expected '</%s>'. Found '%s'", TagStr.CStr(), SymStr.CStr()).CStr());
1321  }
1322  TXmlLxSym TXmlParser::GetTag(const TChA& TagStr) {
1323    GetSym();
1324    EAssertR(TagStr==SymStr, TStr::Fmt("Expected xml symbol '%s'. Found '%s'",
1325      TagStr.CStr(), SymStr.CStr()).CStr());
1326    return Sym;
1327  }
1328  void TXmlParser::GetPlainStrFromXmlStr(const TChA& XmlStr, TChA& PlainChA) {
1329    static TChA EntityNm;
1330    PlainChA.Clr();
1331    const char *Ch = XmlStr.CStr();
1332    while (*Ch){
1333      if (*Ch!='&'){ PlainChA+=*Ch; Ch++; }
1334      else {
1335        if (*++Ch=='#'){
1336          TChA RefChA; int RefCd=0;
1337          if (*++Ch=='x'){
1338            forever {  Ch++;
1339              if (TCh::IsHex(*Ch)){ RefChA+=*Ch;  RefCd=RefCd*16+TCh::GetHex(*Ch); }
1340              else { break; } }
1341          } else { 
1342            forever {
1343              if (TCh::IsNum(*Ch)){ RefChA+=*Ch; RefCd=RefCd*10+TCh::GetNum(*Ch); }
1344              else { break; } Ch++; }
1345          }
1346          if ((!RefChA.Empty())&&(*Ch==';')){
1347            Ch++;  const uchar RefCh=uchar(RefCd);  PlainChA+=RefCh; }
1348        } else {
1349          EntityNm.Clr();
1350          while ((*Ch)&&(*Ch!=';')){EntityNm+=*Ch; Ch++;}
1351          if ((!EntityNm.Empty())&&(*Ch==';')){  Ch++;
1352            if (EntityNm=="quot"){PlainChA+='"';}
1353            else if (EntityNm=="amp"){PlainChA+='&';}
1354            else if (EntityNm=="apos"){PlainChA+='\'';}
1355            else if (EntityNm=="lt"){PlainChA+='<';}
1356            else if (EntityNm=="gt"){PlainChA+='>';}
1357          }
1358        }
1359      }
1360    }
1361  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-euproj.cpp</h3>
            <pre><code>1  #include "euproj.h"
2  #include "graph.h"
3  TStr TEpOrg::GetMultiLnOrgNm(
4   const TStr& OrgNm, const int& MnLnLen, const char& NewLnCh){
5    TChA OrgNmChA=OrgNm;
6    TChA MultiLnOrgNmChA; int LnLen=0;
7    for (int ChN=0; ChN<OrgNmChA.Len(); ChN++){
8      if ((LnLen>MnLnLen)&&(OrgNmChA[ChN]==' ')){
9        MultiLnOrgNmChA+=NewLnCh; LnLen=0;
10      } else {
11        MultiLnOrgNmChA+=OrgNmChA[ChN]; LnLen++;
12      }
13    }
14    return MultiLnOrgNmChA;
15  }
16  TStr TEpOrg::GetClbOrgNm(const int& ClbOrgN, const TEpBs* EpBs) const {
17    int ClbOrgId=ClbOrgIdToFqH.GetKey(ClbOrgN);
18    return EpBs->GetOrg(ClbOrgId)->GetOrgNm();
19  }
20  int TEpOrg::GetClbOrgFq(const TStr& ClbOrgNm, const TEpBs* EpBs) const {
21    int ClbOrgId=EpBs->GetOrgId(ClbOrgNm);
22    if (ClbOrgIdToFqH.IsKey(ClbOrgId)){
23      return ClbOrgIdToFqH.GetDat(ClbOrgId);}
24    else {return 0;}
25  }
26  void TEpOrg::GetClbOrgProjNmV(
27   const TStr& ClbOrgNm, TStrV& ProjNmV, const TEpBs* EpBs) const {
28    int ClbOrgId=EpBs->GetOrgId(ClbOrgNm);
29    ProjNmV=ClbOrgIdToProjNmVH.GetDat(ClbOrgId);
30  }
31  void TEpOrg::AddClbOrg(
32   const TStr& ClbOrgNm, const TStr& ProjNm, const TEpBs* EpBs){
33    int ClbOrgId=EpBs->GetOrgId(ClbOrgNm);
34    ClbOrgIdToFqH.AddDat(ClbOrgId)++;
35    ClbOrgIdToProjNmVH.AddDat(ClbOrgId).AddSorted(ProjNm);
36    SumClbOrgFq++;
37  }
38  void TEpCountry::AddOrg(const TStr& OrgNm, const TEpBs* EpBs){
39    int OrgId=EpBs->GetOrgId(OrgNm);
40    OrgIdToFqH.AddDat(OrgId)++;
41  }
42  TStr TEpCountry::GetOrgNm(const int& OrgN, const TEpBs* EpBs) const {
43    int OrgId=OrgIdToFqH.GetKey(OrgN);
44    return EpBs->GetOrg(OrgId)->GetOrgNm();
45  }
46  void TEpOfficer::AddOrg(const TStr& OrgNm, const TEpBs* EpBs){
47    int OrgId=EpBs->GetOrgId(OrgNm);
48    OrgIdToFqH.AddDat(OrgId)++;
49  }
50  void TEpProj::AddOrgNmRole(
51   const TStr& OrgNm, const TStr& OrgRoleNm, const TEpBs* EpBs){
52    int OrgId=EpBs->GetOrgId(OrgNm);
53    OrgIdRoleKdV.AddMerged(TIntStrKd(OrgId, OrgRoleNm));
54  }
55  TStr TEpProj::GetRole(const TStr& OrgNm, const TEpBs* EpBs) const {
56    int OrgId=EpBs->GetOrgId(OrgNm);
57    return OrgIdRoleKdV.GetDat(TIntStrKd(OrgId)).Dat;
58  }
59  TStr TEpProj::GetOrgNm(const int& OrgN, const TEpBs* EpBs) const {
60    int OrgId=OrgIdRoleKdV[OrgN].Key;
61    return EpBs->GetOrg(OrgId)->GetOrgNm();
62  }
63  void TEpDomain::AddOrg(const TStr& OrgNm, const TEpBs* EpBs){
64    int OrgId=EpBs->GetOrgId(OrgNm);
65    OrgIdToFqH.AddDat(OrgId)++;
66  }
67  TStr TEpDomain::GetOrgNm(const int& OrgN, const TEpBs* EpBs) const {
68    int OrgId=OrgIdToFqH.GetKey(OrgN);
69    return EpBs->GetOrg(OrgId)->GetOrgNm();
70  }
71  bool TEpDomain::IsOrg(const TStr& OrgNm, TInt& OrgFq, const TEpBs* EpBs) const {
72    int OrgId=EpBs->GetOrgId(OrgNm);
73    return OrgIdToFqH.IsKeyGetDat(OrgId, OrgFq);
74  }
75  void TEpUnit::AddOrg(const TStr& OrgNm, const TEpBs* EpBs){
76    int OrgId=EpBs->GetOrgId(OrgNm);
77    OrgIdToFqH.AddDat(OrgId)++;
78  }
79  TStr TEpUnit::GetOrgNm(const int& OrgN, const TEpBs* EpBs) const {
80    int OrgId=OrgIdToFqH.GetKey(OrgN);
81    return EpBs->GetOrg(OrgId)->GetOrgNm();
82  }
83  bool TEpUnit::IsOrg(const TStr& OrgNm, TInt& OrgFq, const TEpBs* EpBs) const {
84    int OrgId=EpBs->GetOrgId(OrgNm);
85    return OrgIdToFqH.IsKeyGetDat(OrgId, OrgFq);
86  }
87  TStr TEpBs::GetUnitDNm(const TStr& UnitNm){
88    if (UnitNm=="B1"){return "Health-Applications";}
89    if (UnitNm=="B2"){return "Handicapped&Eldely";}
90    if (UnitNm=="B3"){return "eGovernment";}
91    if (UnitNm=="B4"){return "Environment";}
92    if (UnitNm=="B5"){return "Transport&Tourism";}
93    if (UnitNm=="C1"){return "eWork";}
94    if (UnitNm=="C2"){return "eBusiness";}
95    if (UnitNm=="C3"){return "eCommerce";}
96    if (UnitNm=="C4"){return "Trust&Security";}
97    if (UnitNm=="D1"){return "ePublishing";}
98    if (UnitNm=="D2"){return "Cultural-Heritage";}
99    if (UnitNm=="D3"){return "eLearning";}
100    if (UnitNm=="D4"){return "Linguistics";}
101    if (UnitNm=="E1"){return "Networks";}
102    if (UnitNm=="E2"){return "Software";}
103    if (UnitNm=="E3"){return "Multimedia&Displays";}
104    if (UnitNm=="E4"){return "Mobile-Communications";}
105    if (UnitNm=="E5"){return "Peripherals&Microsystems";}
106    if (UnitNm=="E6"){return "Microelectronics";}
107    if (UnitNm=="F1"){return "Future&Emerging-Technologies";}
108    if (UnitNm=="F2"){return "Research-Networks";}
109    return UnitNm;
110  }
111  void TEpBs::GetOrgIdSetV(const int& OrgId,
112   const int& Depth, TBoolV& OrgIdSetV, int& OrgIdSetVTrues) const {
113    int Orgs=GetOrgs();
114    OrgIdSetV.Gen(Orgs);
115    if (Depth==-1){return;}
116    if (!OrgIdSetV[OrgId]){
117      OrgIdSetV[OrgId]=true; OrgIdSetVTrues++;}
118    if (Depth>0){
119      PEpOrg Org=GetOrg(OrgId);
120      int ClbOrgs=Org->GetClbOrgs();
121      for (int ClbOrgN=0; ClbOrgN<ClbOrgs; ClbOrgN++){
122        int ClbOrgId=Org->GetClbOrgId(ClbOrgN);
123        TBoolV SubOrgIdSetV;
124        GetOrgIdSetV(ClbOrgId, Depth-1, SubOrgIdSetV, OrgIdSetVTrues);
125        for (int SubOrgId=0; SubOrgId<Orgs; SubOrgId++){
126          OrgIdSetV[SubOrgId]=OrgIdSetV[SubOrgId]||SubOrgIdSetV[SubOrgId];
127        }
128      }
129    }
130  }
131  PMom TEpBs::GetDistMom(const int& StartOrgId) const {
132    PMom DistMom=TMom::New();
133    TIntV OrgDistV(GetOrgs()); OrgDistV.PutAll(-1);
134    TIntPrQ OpenOrgIdQ; OpenOrgIdQ.Push(TIntPr(StartOrgId, 0));
135    OrgDistV[StartOrgId]=0;
136    while (!OpenOrgIdQ.Empty()){
137      int OrgId=OpenOrgIdQ.Top().Val1;
138      int OrgDist=OpenOrgIdQ.Top().Val2;
139      OpenOrgIdQ.Pop();
140      IAssert(OrgDistV[OrgId]==OrgDist);
141      PEpOrg Org=GetOrg(OrgId);
142      int ClbOrgs=Org->GetClbOrgs();
143      for (int ClbOrgN=0; ClbOrgN<ClbOrgs; ClbOrgN++){
144        int ClbOrgId=Org->GetClbOrgId(ClbOrgN);
145        if (OrgDistV[ClbOrgId]==-1){
146          OpenOrgIdQ.Push(TIntPr(ClbOrgId, OrgDist+1));
147          OrgDistV[ClbOrgId]=OrgDist+1;
148          DistMom->Add(OrgDist+1);
149        }
150      }
151    }
152    DistMom->Def();
153    return DistMom;
154  }
155  PEpBs TEpBs::GetSelEpBs(const PSs& Ss,
156   const TStrV& SelOrgTypeNmV, const TStrV& SelCountryNmV,
157   const TStrV& SelDomainNmV, const TStrV& SelUnitNmV,
158   const TStrV& SelOfficerNmV, const TStrV& SelProjNmV){
159    int ProjRefFldN=Ss->GetFldX("Project Ref");
160    int ProjNmFldN=Ss->GetFldX("Acronym");
161    int DomainFldN=Ss->GetFldX("Domain / Key Action");
162    int UnitFldN=Ss->GetFldX("Unit");
163    int OfficerFldN=Ss->GetFldX("PO");
164    int OrgNmFldN=Ss->GetFldX("Legal Name");
165    int OrgCountryFldN=Ss->GetFldX("Legal Country");
166    int OrgTypeFldN=Ss->GetFldX("Type of organisation");
167    int OrgRoleFldN=Ss->GetFldX("Participant role");
168    PEpBs EpBs=TEpBs::New(Ss);
169    int PPRecs=Ss->GetYLen();
170    for (int PPRecN=1; PPRecN<PPRecs; PPRecN++){
171      if (PPRecN%100==0){printf("%d/%d\r", PPRecN, PPRecs);}
172      TStr ProjRef=Ss->GetVal(ProjRefFldN, PPRecN);
173      TStr ProjNm=Ss->GetVal(ProjNmFldN, PPRecN).GetTrunc();
174      TStr DomainNm=Ss->GetVal(DomainFldN, PPRecN);
175      TStr UnitNm=Ss->GetVal(UnitFldN, PPRecN);
176      TStr OfficerNm=Ss->GetVal(OfficerFldN, PPRecN);
177      TStr OrgNm=Ss->GetVal(OrgNmFldN, PPRecN);
178      TStr CountryNm=Ss->GetVal(OrgCountryFldN, PPRecN);
179      TStr OrgTypeNm=Ss->GetVal(OrgTypeFldN, PPRecN);
180      TStr OrgRoleNm=Ss->GetVal(OrgRoleFldN, PPRecN);
181      if ((!SelOrgTypeNmV.Empty())&&(!SelOrgTypeNmV.IsIn(OrgTypeNm))){continue;}
182      if ((!SelCountryNmV.Empty())&&(!SelCountryNmV.IsIn(CountryNm))){continue;}
183      if ((!SelDomainNmV.Empty())&&(!SelDomainNmV.IsIn(DomainNm))){continue;}
184      if ((!SelUnitNmV.Empty())&&(!SelUnitNmV.IsIn(UnitNm))){continue;}
185      if ((!SelOfficerNmV.Empty())&&(!SelOfficerNmV.IsIn(OfficerNm))){continue;}
186      if ((!SelProjNmV.Empty())&&(!SelProjNmV.IsIn(ProjNm))){continue;}
187      PEpOrg Org;
188      if (!EpBs->IsOrg(OrgNm, Org)){
189        Org=TEpOrg::New(OrgNm, OrgTypeNm, CountryNm); EpBs->AddOrg(Org);}
190      Org->AddProj(ProjNm);
191      PEpCountry Country;
192      if (!EpBs->IsCountry(CountryNm, Country)){
193        Country=TEpCountry::New(CountryNm); EpBs->AddCountry(Country);}
194      Country->AddOrg(OrgNm, EpBs());
195      Country->AddOrgType(OrgTypeNm);
196      Country->AddProj(ProjNm);
197      PEpOfficer Officer;
198      if (!EpBs->IsOfficer(OfficerNm, Officer)){
199        Officer=TEpOfficer::New(OfficerNm); EpBs->AddOfficer(Officer);}
200      Officer->AddOrg(OrgNm, EpBs());
201      Officer->AddProj(ProjNm);
202      Officer->AddCountry(CountryNm);
203      PEpProj Proj;
204      if (!EpBs->IsProj(ProjNm, Proj)){
205        Proj=TEpProj::New(ProjNm, ProjRef, DomainNm, UnitNm, OfficerNm);
206        EpBs->AddProj(Proj);}
207      Proj->AddOrgNmRole(OrgNm, OrgRoleNm, EpBs());
208      PEpDomain Domain;
209      if (!EpBs->IsDomain(DomainNm, Domain)){
210        Domain=TEpDomain::New(DomainNm); EpBs->AddDomain(Domain);}
211      Domain->AddOrg(OrgNm, EpBs());
212      Domain->AddProj(ProjNm);
213      Domain->AddCountry(CountryNm);
214      PEpUnit Unit;
215      if (!EpBs->IsUnit(UnitNm, Unit)){
216        Unit=TEpUnit::New(UnitNm); EpBs->AddUnit(Unit);}
217      Unit->AddOrg(OrgNm, EpBs());
218      Unit->AddProj(ProjNm);
219      Unit->AddCountry(CountryNm);
220    }
221    printf("\n");
222    int Projs=EpBs->GetProjs();
223    for (int ProjN=0; ProjN<Projs; ProjN++){
224      if (ProjN%1==0){printf("%d/%d\r", ProjN, Projs);}
225      PEpProj Proj=EpBs->GetProj(ProjN);
226      for (int MainOrgN=0; MainOrgN<Proj->GetOrgs(); MainOrgN++){
227        TStr MainOrgNm=Proj->GetOrgNm(MainOrgN, EpBs());
228        PEpOrg MainOrg=EpBs->GetOrg(MainOrgNm);
229        TStr MainCountryNm=MainOrg->GetCountryNm();
230        PEpCountry MainCountry=EpBs->GetCountry(MainCountryNm);
231        for (int ClbOrgN=0; ClbOrgN<Proj->GetOrgs(); ClbOrgN++){
232          if (MainOrgN==ClbOrgN){continue;}
233          TStr ClbOrgNm=Proj->GetOrgNm(ClbOrgN, EpBs());
234          PEpOrg ClbOrg=EpBs->GetOrg(ClbOrgNm);
235          TStr ClbCountryNm=ClbOrg->GetCountryNm();
236          MainOrg->AddClbOrg(ClbOrgNm, Proj->GetProjNm(), EpBs());
237          MainCountry->AddClbCountry(ClbCountryNm);
238        }
239      }
240    }
241    printf("\n");
242    return EpBs;
243  }
244  PEpBs TEpBs::GetSelEpBs(
245   const TStr& SelOrgTypeNm, const TStr& SelCountryNm,
246   const TStr& SelDomainNm, const TStr& SelUnitNm,
247   const TStr& SelOfficerNm, const TStr& SelProjNm) const {
248    TStrV SelOrgTypeNmV; TStrV SelCountryNmV; TStrV SelDomainNmV;
249    TStrV SelUnitNmV; TStrV SelOfficerNmV; TStrV SelProjNmV;
250    if (!SelOrgTypeNm.Empty()){SelOrgTypeNmV.Add(SelOrgTypeNm);}
251    if (!SelCountryNm.Empty()){SelCountryNmV.Add(SelCountryNm);}
252    if (!SelDomainNm.Empty()){SelDomainNmV.Add(SelDomainNm);}
253    if (!SelUnitNm.Empty()){SelUnitNmV.Add(SelUnitNm);}
254    if (!SelOfficerNm.Empty()){SelOfficerNmV.Add(SelOfficerNm);}
255    if (!SelProjNm.Empty()){SelProjNmV.Add(SelProjNm);}
256    return TEpBs::GetSelEpBs(Ss,
257     SelOrgTypeNmV, SelCountryNmV, SelDomainNmV,
258     SelUnitNmV, SelOfficerNmV, SelProjNmV);
259  }
260  PEpBs TEpBs::GetSelEpBs(
261   const TStrV& SelOrgTypeNmV, const TStrV& SelCountryNmV,
262   const TStrV& SelDomainNmV, const TStrV& SelUnitNmV,
263   const TStrV& SelOfficerNmV, const TStrV& SelProjNmV) const {
264    return TEpBs::GetSelEpBs(
265     Ss, SelOrgTypeNmV, SelCountryNmV,
266     SelDomainNmV, SelUnitNmV,
267     SelOfficerNmV, SelProjNmV);
268  }
269  PEpBs TEpBs::LoadTxt(const TStr& FNm){
270    PSs Ss=TSs::LoadTxt(ssfTabSep, FNm);
271    PEpBs EpBs=EpBs->GetSelEpBs(Ss,
272     TStrV(), TStrV(),
273     TStrV(), TStrV(),
274     TStrV(), TStrV());
275    return EpBs;
276  }
277  PEpBs TEpBs::LoadBinOrTxt(const TStr& BinFNm, const TStr& TxtFNm){
278    printf("Loading files ...\n");
279    PEpBs EpBs;
280    if (TFile::Exists(BinFNm)){
281      EpBs=TEpBs::LoadBin(BinFNm);
282    } else {
283      EpBs=LoadTxt(TxtFNm);
284      EpBs->SaveBin(BinFNm);
285    }
286    printf("Done.\n");
287    return EpBs;
288  }
289  void TEpBs::LoadBriefOrgNm(const TStr& FNm) const {
290    if (!TFile::Exists(FNm)){
291      printf("Brief-Organization-Names file doesn't exist (%s)\n", FNm.CStr());
292      return;
293    }
294    PSIn SIn=TFIn::New(FNm);
295    TILx Lx(SIn, TFSet()|iloRetEoln);
296    Lx.GetSym(syQStr, syEoln, syEof);
297    while (Lx.Sym!=syEof){
298      if (Lx.Sym!=syEoln){
299        TStr BriefOrgNm=Lx.Str;
300        TStr OrgNm=Lx.GetQStr();
301        Lx.GetSym(syEoln);
302        PEpOrg Org;
303        if (IsOrg(OrgNm, Org)){
304          Org->PutBriefOrgNm(BriefOrgNm);
305        }
306      }
307      Lx.GetSym(syQStr, syEoln, syEof);
308    }
309  }
310  void TEpBs::SaveTxtXmlGraph(const TStr& TxtFNm, const TStr& XmlFNm) const {
311    printf("Save Txt/Xml Graph to %s/%s ...\n", TxtFNm.CStr(), XmlFNm.CStr());
312    TFOut TxtFOut(TxtFNm); FILE* fTxt=TxtFOut.GetFileId();
313    TFOut XmlFOut(XmlFNm); FILE* fXml=XmlFOut.GetFileId();
314    fprintf(fXml, "<CollaborationGraph>\n");
315    fprintf(fTxt, "*organizations\t%d\n", GetOrgs());
316    for (int OrgId=0; OrgId<GetOrgs(); OrgId++){
317      PEpOrg Org=GetOrg(OrgId);
318      fprintf(fTxt, "%d", OrgId);
319      fprintf(fTxt, "\t%s", Org->GetOrgNm().CStr());
320      fprintf(fTxt, "\t%s", Org->GetCountryNm().CStr());
321      fprintf(fTxt, "\t%s\n", Org->GetOrgTypeNm().CStr());
322      fprintf(fXml, "<Org>");
323      fprintf(fXml, " <Id>%d</Id>", OrgId);
324      fprintf(fXml, " <Name>%s</Name>", TXmlLx::GetXmlStrFromPlainStr(Org->GetOrgNm()).CStr());
325      fprintf(fXml, " <Country>%s</Country>", TXmlLx::GetXmlStrFromPlainStr(Org->GetCountryNm()).CStr());
326      fprintf(fXml, " <Type>%s</Type>", TXmlLx::GetXmlStrFromPlainStr(Org->GetOrgTypeNm()).CStr());
327      fprintf(fXml, " </Org>\n");
328    }
329    int Clbs=0;
330    for (int SrcOrgId=0; SrcOrgId<GetOrgs(); SrcOrgId++){
331      PEpOrg SrcOrg=GetOrg(SrcOrgId);
332      for (int ProjN=0; ProjN<SrcOrg->GetProjs(); ProjN++){
333        TStr ProjNm=SrcOrg->GetProjNm(ProjN);
334        PEpProj Proj=GetProj(ProjNm);
335        for (int DstOrgN=0; DstOrgN<Proj->GetOrgs(); DstOrgN++){
336          int DstOrgId=Proj->GetOrgId(DstOrgN);
337          if (SrcOrgId>=DstOrgId){continue;}
338          Clbs++;
339        }
340      }
341    }
342    fprintf(fTxt, "*collaborations\t%d\n", Clbs);
343    {for (int SrcOrgId=0; SrcOrgId<GetOrgs(); SrcOrgId++){
344      PEpOrg SrcOrg=GetOrg(SrcOrgId);
345      for (int ProjN=0; ProjN<SrcOrg->GetProjs(); ProjN++){
346        TStr ProjNm=SrcOrg->GetProjNm(ProjN);
347        PEpProj Proj=GetProj(ProjNm);
348        TStr DomainNm=GetProj(ProjNm)->GetDomainNm();
349        TStr UnitNm=GetProj(ProjNm)->GetUnitNm();
350        for (int DstOrgN=0; DstOrgN<Proj->GetOrgs(); DstOrgN++){
351          int DstOrgId=Proj->GetOrgId(DstOrgN);
352          if (SrcOrgId>=DstOrgId){continue;}
353          fprintf(fTxt, "%d", SrcOrgId);
354          fprintf(fTxt, "\t%d", DstOrgId);
355          fprintf(fTxt, "\t%s", ProjNm.CStr());
356          fprintf(fTxt, "\t%s", DomainNm.CStr());
357          fprintf(fTxt, "\t%s\n", UnitNm.CStr());
358          fprintf(fXml, "<Clb>");
359          fprintf(fXml, " <SrcId>%d</SrcId>", SrcOrgId);
360          fprintf(fXml, " <DstId>%d</DstId>", DstOrgId);
361          fprintf(fXml, " <Proj>%s</Proj>", TXmlLx::GetXmlStrFromPlainStr(ProjNm).CStr());
362          fprintf(fXml, " <Domain>%s</Domain>", TXmlLx::GetXmlStrFromPlainStr(DomainNm).CStr());
363          fprintf(fXml, " <Unit>%s</Unit>", TXmlLx::GetXmlStrFromPlainStr(UnitNm).CStr());
364          fprintf(fXml, " </Clb>\n");
365        }
366      }
367    }}
368    fprintf(fXml, "</CollaborationGraph>\n");
369    printf("Done.\n");
370  }
371  void TEpBs::SaveTxtCountryClb(const TStr& TxtFNm, const TStr& GraphFNm) const {
372    printf("Save Country Collaboration to %s/%s ...\n", TxtFNm.CStr(), GraphFNm.CStr());
373    typedef TPair<TInt, PEpCountry> TFqCountryPr;
374    TVec<TFqCountryPr> FqCountryPrV;
375    TStrPrIntH CountryPrFqH;
376    for (int CountryN=0; CountryN<GetCountries(); CountryN++){
377      PEpCountry Country=GetCountry(CountryN);
378      TStr CountryNm=Country->GetCountryNm();
379      FqCountryPrV.Add(TFqCountryPr(Country->GetSumClbCountriesFq(), Country));
380      for (int ClbCountryN=0; ClbCountryN<Country->GetClbCountries(); ClbCountryN++){
381        TStr ClbCountryNm=Country->GetClbCountryNm(ClbCountryN);
382        int ClbCountryFq=Country->GetClbCountryFq(ClbCountryN);
383        CountryPrFqH.AddDat(TStrPr(CountryNm, ClbCountryNm))+=ClbCountryFq;
384      }
385    }
386    TFOut FOut(TxtFNm); FILE* fTxtOut=FOut.GetFileId();
387    TIntStrPrPrV FqCountryPrPrV; CountryPrFqH.GetDatKeyPrV(FqCountryPrPrV);
388    FqCountryPrPrV.Sort(false);
389    fprintf(fTxtOut, "*** All Countries Collaborations:\n");
390    for (int CountryPrN=0; CountryPrN<FqCountryPrPrV.Len(); CountryPrN++){
391      TStr CountryNm1=FqCountryPrPrV[CountryPrN].Val2.Val1;
392      TStr CountryNm2=FqCountryPrPrV[CountryPrN].Val2.Val2;
393      int Fq=FqCountryPrPrV[CountryPrN].Val1;
394      if ((CountryNm1>CountryNm2)||(Fq<5)){continue;}
395      fprintf(fTxtOut, "%6d: %s - %s\n", Fq, CountryNm1.CStr(), CountryNm2.CStr());
396    }
397    fprintf(fTxtOut, "\n");
398    FqCountryPrV.Sort(false);
399    {for (int CountryN=0; CountryN<FqCountryPrV.Len(); CountryN++){
400      PEpCountry Country=FqCountryPrV[CountryN].Val2;
401      TIntStrPrV FqClbCountryNmPrV;
402      Country->GetFqClbCountryNmPrV(FqClbCountryNmPrV);
403      FqClbCountryNmPrV.Sort(false);
404      fprintf(fTxtOut, "*** %s (%d collaborations) (rank %d/%d):\n",
405       Country->GetCountryNm().CStr(), Country->GetSumClbCountriesFq(),
406       1+CountryN, FqCountryPrV.Len());
407      for (int SubCountryN=0; SubCountryN<FqClbCountryNmPrV.Len(); SubCountryN++){
408        int Fq=FqClbCountryNmPrV[SubCountryN].Val1;
409        double FqPrc=double(Fq)/Country->GetSumClbCountriesFq();
410        TStr SubCountryNm=FqClbCountryNmPrV[SubCountryN].Val2;
411        if (FqPrc<0.001){continue;}
412        fprintf(fTxtOut, "   %2d. %s (%.2f%% / %d)\n",
413         1+SubCountryN, SubCountryNm.CStr(), 100*FqPrc, Fq);
414      }
415      fprintf(fTxtOut, "\n");
416    }}
417    PGraph Graph=TGraph::New();
418    TStrH CountryNmH;
419    {for (int CountryPrN=0; CountryPrN<FqCountryPrPrV.Len(); CountryPrN++){
420      if (CountryNmH.Len()>11){break;}
421      TStr CountryNm1=FqCountryPrPrV[CountryPrN].Val2.Val1;
422      TStr CountryNm2=FqCountryPrPrV[CountryPrN].Val2.Val2;
423      int Fq=FqCountryPrPrV[CountryPrN].Val1;
424      if (CountryNm1<=CountryNm2){continue;}
425      if (!CountryNmH.IsKey(CountryNm1)){
426        PEpCountry Country1=GetCountry(CountryNm1);
427        int CountryN1=GetCountryN(CountryNm1);
428        CountryNmH.AddKey(CountryNm1);
429        TStr VNm=CountryNm1+"\n("+TInt::GetStr(Country1->GetProjs())+"proj.)";
430        Graph->AddVrtx(TGVrtx::New(CountryN1, VNm));
431      }
432      if (!CountryNmH.IsKey(CountryNm2)){
433        PEpCountry Country2=GetCountry(CountryNm2);
434        int CountryN2=GetCountryN(CountryNm2);
435        CountryNmH.AddKey(CountryNm2);
436        TStr VNm=CountryNm2+"\n("+TInt::GetStr(Country2->GetProjs())+"proj.)";
437        Graph->AddVrtx(TGVrtx::New(CountryN2, VNm));
438      }
439      PVrtx Vrtx1=Graph->GetVrtx(GetCountryN(CountryNm1));
440      PVrtx Vrtx2=Graph->GetVrtx(GetCountryN(CountryNm2));
441      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TInt::GetStr(Fq), false);
442      Edge->PutWgt(1+log(Fq));
443      Graph->AddEdge(Edge);
444    }}
445    Graph->SetEdgeWidth(5);
446    Graph->SaveTxt(GraphFNm);
447    printf("Done.\n");
448  }
449  void TEpBs::SaveCountryClbTree(const TStr& CountryNm, const TStr& GraphFNm){
450    PGraph Graph=TGraph::New();
451    int RootCountryId=GetCountryN(CountryNm);
452    Graph->AddVrtx(TGVrtx::New(RootCountryId, CountryNm));
453    TIntV CountryDistV(GetCountries()); CountryDistV.PutAll(-1);
454    CountryDistV[RootCountryId]=0;
455    TIntPrQ OpenCountryIdDistPrQ; OpenCountryIdDistPrQ.Push(TIntPr(RootCountryId, 0));
456    while (!OpenCountryIdDistPrQ.Empty()){
457      int CountryId=OpenCountryIdDistPrQ.Top().Val1;
458      int CountryDist=OpenCountryIdDistPrQ.Top().Val2;
459      OpenCountryIdDistPrQ.Pop();
460      IAssert(CountryDistV[CountryId]==CountryDist);
461      PEpCountry Country=GetCountry(CountryId);
462      TStr CountryNm=Country->GetCountryNm();
463      printf("[%s:%d] ", CountryNm.CStr(), CountryDist);
464      if (CountryDist>0){continue;}
465      PVrtx SrcVrtx=Graph->GetVrtx(CountryId);
466      TIntStrPrV FqClbCountryNmPrV;
467      Country->GetFqClbCountryNmPrV(FqClbCountryNmPrV);
468      FqClbCountryNmPrV.Sort(false);
469      int SubCountries=FqClbCountryNmPrV.Len();
470      int CreatedSubCountries=0;
471      for (int SubCountryN=0; SubCountryN<SubCountries; SubCountryN++){
472        int SubCountryFq=FqClbCountryNmPrV[SubCountryN].Val1;
473        TStr SubCountryNm=FqClbCountryNmPrV[SubCountryN].Val2;
474        int SubCountryId=GetCountryN(SubCountryNm);
475        if ((CountryDistV[SubCountryId]==-1)&&(!SubCountryNm.IsStrIn("EMPTY"))){
476          int MxCreatedSubCountries=0;
477          switch (CountryDist){
478            case 0: MxCreatedSubCountries=70; break;
479            case 1: MxCreatedSubCountries=4; break;
480            case 2: MxCreatedSubCountries=2; break;
481            case 3: MxCreatedSubCountries=1; break;
482            case 4: MxCreatedSubCountries=1; break;
483            default: MxCreatedSubCountries=0; break;
484          }
485          CreatedSubCountries++;
486          if (CreatedSubCountries>MxCreatedSubCountries){break;}
487          OpenCountryIdDistPrQ.Push(TIntPr(SubCountryId, CountryDist+1));
488          CountryDistV[SubCountryId]=CountryDist+1;
489          TStr VNm=SubCountryNm;
490          PVrtx DstVrtx=TGVrtx::New(SubCountryId, VNm);
491          Graph->AddVrtx(DstVrtx);
492          TStr ENm=TInt::GetStr(SubCountryFq);
493          PEdge Edge=TGEdge::New(SrcVrtx, DstVrtx, ENm);
494          Edge->PutWgt(1+log(SubCountryFq));
495          Graph->AddEdge(Edge);
496        }
497      }
498    }
499    Graph->SetEdgeWidth(5);
500    Graph->SaveTxt(GraphFNm);
501  }
502  void TEpBs::SaveTxtCountryClbPerCap(
503   const TStr& TxtFNm, const TStr& GraphFNm, const PCiaWFBBs& CiaWFBBs) const {
504    printf("Save Country Collaboration Per Capita to %s/%s ...\n",
505     TxtFNm.CStr(), GraphFNm.CStr());
506    typedef TPair<TFlt, PEpCountry> TWgtCountryPr;
507    TVec<TWgtCountryPr> WgtCountryPrV;
508    TStrPrFltH CountryPrWgtH;
509    TStrPrIntH CountryPrFqH;
510    for (int CountryN=0; CountryN<GetCountries(); CountryN++){
511      PEpCountry Country=GetCountry(CountryN);
512      TStr CountryNm=Country->GetCountryNm();
<span onclick='openModal()' class='match'>513      PCiaWFBCountry CiaWFBCountry;
514      if (CiaWFBBs->IsCountry(CountryNm, CiaWFBCountry)){
515        double Population=CiaWFBCountry->GetFldValNum("Population");
</span>516        for (int ClbCountryN=0; ClbCountryN<Country->GetClbCountries(); ClbCountryN++){
517          TStr ClbCountryNm=Country->GetClbCountryNm(ClbCountryN);
518          PCiaWFBCountry ClbCiaWFBCountry;
519          if (CiaWFBBs->IsCountry(ClbCountryNm, ClbCiaWFBCountry)){
520            double ClbPopulation=ClbCiaWFBCountry->GetFldValNum("Population");
521            int ClbCountryFq=Country->GetClbCountryFq(ClbCountryN);
522            double ClbCountryWgt;
523            if (CountryNm==ClbCountryNm){ClbCountryWgt=ClbCountryFq/ClbPopulation;}
524            else {ClbCountryWgt=ClbCountryFq/(ClbPopulation+Population);}
525            CountryPrWgtH.AddDat(TStrPr(CountryNm, ClbCountryNm))+=ClbCountryWgt;
526            CountryPrFqH.AddDat(TStrPr(CountryNm, ClbCountryNm))+=ClbCountryFq;
527          }
528        }
529      }
530    }
531    TFOut FOut(TxtFNm); FILE* fTxtOut=FOut.GetFileId();
532    TFltStrPrPrV WgtCountryPrPrV; CountryPrWgtH.GetDatKeyPrV(WgtCountryPrPrV);
533    WgtCountryPrPrV.Sort(false);
534    fprintf(fTxtOut, "*** All Countries Collaborations Per Capita:\n");
535    fprintf(fTxtOut, "[Rank] [Population-Per-Collaboration] [Collaborations] [Country-Country] [Population]\n");
536    {int RankN=0;
537    for (int CountryPrN=0; CountryPrN<WgtCountryPrPrV.Len(); CountryPrN++){
538      TStr CountryNm1=WgtCountryPrPrV[CountryPrN].Val2.Val1;
539      TStr CountryNm2=WgtCountryPrPrV[CountryPrN].Val2.Val2;
540      double Wgt=WgtCountryPrPrV[CountryPrN].Val1;
541      int Fq=CountryPrFqH.GetDat(TStrPr(CountryNm1, CountryNm2));
542      double Population1=CiaWFBBs->GetCountry(CountryNm1)->GetFldValNum("Population");
543      double Population2=CiaWFBBs->GetCountry(CountryNm2)->GetFldValNum("Population");
544      if ((CountryNm1>CountryNm2)||(Wgt<0)){continue;}
545      if (CountryNm1==CountryNm2){
546        Wgt=Population1/Fq;
547        fprintf(fTxtOut, "%3d. %6.0f ppc (%5d colab.): %s - %s   (pop.: %.0f)\n",
548         ++RankN, Wgt, Fq, CountryNm1.CStr(), CountryNm2.CStr(), Population1);
549      } else {
550        Wgt=(Population1+Population2)/Fq;
551        fprintf(fTxtOut, "%3d. %6.0f ppc (%5d colab.): %s - %s   (pop.: %.0f=%.0f+%.0f)\n",
552         ++RankN, Wgt, Fq, CountryNm1.CStr(), CountryNm2.CStr(),
553         Population1+Population2, Population1, Population2);
554      }
555    }}
556    fprintf(fTxtOut, "\n");
557    PGraph Graph=TGraph::New();
558    TStrH CountryNmH;
559    for (int CountryPrN=0; CountryPrN<WgtCountryPrPrV.Len(); CountryPrN++){
560      if (CountryNmH.Len()>12){break;}
561      TStr CountryNm1=WgtCountryPrPrV[CountryPrN].Val2.Val1;
562      TStr CountryNm2=WgtCountryPrPrV[CountryPrN].Val2.Val2;
563      double Wgt=WgtCountryPrPrV[CountryPrN].Val1;
564      if (CountryNm1<=CountryNm2){continue;}
565      if (!CountryNmH.IsKey(CountryNm1)){
566        PEpCountry Country1=GetCountry(CountryNm1);
567        int CountryN1=GetCountryN(CountryNm1);
568        CountryNmH.AddKey(CountryNm1);
569        TStr VNm=CountryNm1+"\n("+TInt::GetStr(Country1->GetProjs())+"proj.)";
570        Graph->AddVrtx(TGVrtx::New(CountryN1, VNm));
571      }
572      if (!CountryNmH.IsKey(CountryNm2)){
573        PEpCountry Country2=GetCountry(CountryNm2);
574        int CountryN2=GetCountryN(CountryNm2);
575        CountryNmH.AddKey(CountryNm2);
576        TStr VNm=CountryNm2+"\n("+TInt::GetStr(Country2->GetProjs())+"proj.)";
577        Graph->AddVrtx(TGVrtx::New(CountryN2, VNm));
578      }
579      int Fq=CountryPrFqH.GetDat(TStrPr(CountryNm1, CountryNm2));
580      double Population1=CiaWFBBs->GetCountry(CountryNm1)->GetFldValNum("Population");
581      double Population2=CiaWFBBs->GetCountry(CountryNm2)->GetFldValNum("Population");
582      double PPCWgt=(Population1+Population2)/Fq;
583      PVrtx Vrtx1=Graph->GetVrtx(GetCountryN(CountryNm1));
584      PVrtx Vrtx2=Graph->GetVrtx(GetCountryN(CountryNm2));
585      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(PPCWgt, "%0.fppc"), false);
586      Edge->PutWgt(1+log(Wgt));
587      Graph->AddEdge(Edge);
588    }
589    Graph->SetEdgeWidth(5);
590    Graph->SaveTxt(GraphFNm);
591    printf("Done.\n");
592  }
593  void TEpBs::SaveTxtOrgClb(const TStr& FNm) const {
594    printf("Save Organization Collaboration to %s ...\n", FNm.CStr());
595    typedef TPair<TInt, PEpOrg> TFqOrgPr;
596    TVec<TFqOrgPr> FqOrgPrV;
597    TStrPrIntH OrgPrFqH;
598    for (int OrgN=0; OrgN<GetOrgs(); OrgN++){
599      PEpOrg Org=GetOrg(OrgN);
600      TStr OrgNm=Org->GetOrgNm();
601      FqOrgPrV.Add(TFqOrgPr(Org->GetSumClbOrgsFq(), Org));
602      for (int ClbOrgN=0; ClbOrgN<Org->GetClbOrgs(); ClbOrgN++){
603        TStr ClbOrgNm=Org->GetClbOrgNm(ClbOrgN, this);
604        int ClbOrgFq=Org->GetClbOrgFq(ClbOrgN);
605        OrgPrFqH.AddDat(TStrPr(OrgNm, ClbOrgNm))+=ClbOrgFq;
606      }
607    }
608    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
609    TIntStrPrPrV FqOrgPrPrV; OrgPrFqH.GetDatKeyPrV(FqOrgPrPrV);
610    FqOrgPrPrV.Sort(false);
611    fprintf(fOut, "*** All Organizations Collaborations:\n");
612    for (int OrgPrN=0; OrgPrN<FqOrgPrPrV.Len(); OrgPrN++){
613      TStr OrgNm1=FqOrgPrPrV[OrgPrN].Val2.Val1;
614      TStr OrgNm2=FqOrgPrPrV[OrgPrN].Val2.Val2;
615      int Fq=FqOrgPrPrV[OrgPrN].Val1;
616      if ((OrgNm1>OrgNm2)||(Fq<3)){continue;}
617      fprintf(fOut, "%6d: '%s' - '%s'\n", Fq, OrgNm1.CStr(), OrgNm2.CStr());
618    }
619    fprintf(fOut, "\n");
620    FqOrgPrV.Sort(false);
621    {for (int OrgN=0; OrgN<FqOrgPrV.Len(); OrgN++){
622      PEpOrg Org=FqOrgPrV[OrgN].Val2;
623      TIntPrV FqClbOrgIdPrV;
624      Org->GetFqClbOrgIdPrV(FqClbOrgIdPrV);
625      FqClbOrgIdPrV.Sort(false);
626      fprintf(fOut, "*** %s/%s (%d collaborations) (rank: %d/%d):\n",
627       Org->GetOrgNm().CStr(), Org->GetCountryNm().CStr(), Org->GetSumClbOrgsFq(),
628       1+OrgN, FqOrgPrV.Len());
629      if (FqClbOrgIdPrV.Len()==0){
630        fprintf(fOut, "   Projects: [");
631        for (int ProjN=0; ProjN<Org->GetProjs(); ProjN++){
632          TStr DomainNm=GetProj(Org->GetProjNm(ProjN))->GetDomainNm();
633          TStr UnitNm=GetProj(Org->GetProjNm(ProjN))->GetUnitNm();
634          fprintf(fOut, "'%s'/%s-%s ", Org->GetProjNm(ProjN).CStr(), DomainNm.CStr(), UnitNm.CStr());
635        }
636        fprintf(fOut, "]\n");
637      } else {
638        for (int ClbOrgN=0; ClbOrgN<FqClbOrgIdPrV.Len(); ClbOrgN++){
639          int ClbOrgId=FqClbOrgIdPrV[ClbOrgN].Val2;
640          TStr ClbOrgNm=GetOrg(ClbOrgId)->GetOrgNm();
641          TStr ClbCountryNm=GetOrg(ClbOrgNm)->GetCountryNm();
642          int Fq=Org->GetClbOrgFq(ClbOrgNm, this);
643          double FqPrc=double(Fq)/Org->GetSumClbOrgsFq();
644          TStrV ProjNmV; Org->GetClbOrgProjNmV(ClbOrgNm, ProjNmV, this);
645          fprintf(fOut, "   %2d. %s/%s (%.2f%% / %d)     [",
646           1+ClbOrgN, ClbOrgNm.CStr(), ClbCountryNm.CStr(), 100*FqPrc, Fq);
647          for (int ProjN=0; ProjN<ProjNmV.Len(); ProjN++){
648            TStr DomainNm=GetProj(ProjNmV[ProjN])->GetDomainNm();
649            TStr UnitNm=GetProj(ProjNmV[ProjN])->GetUnitNm();
650            fprintf(fOut, "'%s'/%s-%s ", ProjNmV[ProjN].CStr(), DomainNm.CStr(), UnitNm.CStr());
651          }
652          fprintf(fOut, "]\n");
653        }
654      }
655      fprintf(fOut, "\n");
656    }}
657    printf("Done.\n");
658  }
659  void TEpBs::SaveTxtDomainClb(const TStr& TxtFNm, const TStr& GraphFNm) const {
660    printf("Save Domain Collaboration to %s/%s ...\n", TxtFNm.CStr(), GraphFNm.CStr());
661    TStrPrFltH DomainPrToWgtH;
662    TStrPrFltH DomainPrToOrgsH;
663    for (int DomainN=0; DomainN<GetDomains(); DomainN++){
664      PEpDomain Domain=GetDomain(DomainN);
665      TStr DomainNm=Domain->GetDomainNm();
666      if (DomainNm=="#EMPTY"){continue;}
667      for (int OrgN=0; OrgN<Domain->GetOrgs(); OrgN++){
668        TStr OrgNm=Domain->GetOrgNm(OrgN, this);
669        int OrgFq=Domain->GetOrgFq(OrgN);
670        if (OrgNm=="#EMPTY"){continue;}
671        for (int SubDomainN=0; SubDomainN<GetDomains(); SubDomainN++){
672          PEpDomain SubDomain=GetDomain(SubDomainN);
673          TStr SubDomainNm=SubDomain->GetDomainNm();
674          if (SubDomainNm=="#EMPTY"){continue;}
675          TInt SubOrgFq;
676          if (SubDomain->IsOrg(OrgNm, SubOrgFq, this)){
677            if (DomainNm==SubDomainNm){SubOrgFq--;}
678            double ClbWgt=(OrgFq*SubOrgFq);
679            if (ClbWgt>0){
680              DomainPrToWgtH.AddDat(TStrPr(DomainNm, SubDomainNm))+=ClbWgt;}
681            DomainPrToOrgsH.AddDat(TStrPr(DomainNm, SubDomainNm))++;
682          }
683        }
684      }
685    }
686    TFOut TxtFOut(TxtFNm); FILE* fTxtOut=TxtFOut.GetFileId();
687    TFltStrPrPrV OrgsDomainPrPrV;
688    DomainPrToOrgsH.GetDatKeyPrV(OrgsDomainPrPrV);
689    OrgsDomainPrPrV.Sort(false);
690    fprintf(fTxtOut, "*** Number Of Organizations In Two Domains\n");
691    int OrgsDomainRank=0;
692    {for (int DomainPrN=0; DomainPrN<OrgsDomainPrPrV.Len(); DomainPrN++){
693      TStr DomainNm1=OrgsDomainPrPrV[DomainPrN].Val2.Val1;
694      TStr DomainNm2=OrgsDomainPrPrV[DomainPrN].Val2.Val2;
695      double ClbOrgs=OrgsDomainPrPrV[DomainPrN].Val1;
696      if (DomainNm1<DomainNm2){continue;}
697      OrgsDomainRank++;
698      fprintf(fTxtOut, "%3d. %6.0f: %s - %s\n",
699       OrgsDomainRank, ClbOrgs, DomainNm1.CStr(), DomainNm2.CStr());
700    }}
701    fprintf(fTxtOut, "\n");
702    TFltStrPrPrV WgtDomainPrPrV;
703    DomainPrToWgtH.GetDatKeyPrV(WgtDomainPrPrV);
704    WgtDomainPrPrV.Sort(false);
705    fprintf(fTxtOut, "*** Weighted Number Of Organizations In Two Domains\n");
706    int WgtDomainRank=0;
707    {for (int DomainPrN=0; DomainPrN<WgtDomainPrPrV.Len(); DomainPrN++){
708      TStr DomainNm1=WgtDomainPrPrV[DomainPrN].Val2.Val1;
709      TStr DomainNm2=WgtDomainPrPrV[DomainPrN].Val2.Val2;
710      double ClbWgt=WgtDomainPrPrV[DomainPrN].Val1;
711      if (DomainNm1<DomainNm2){continue;}
712      WgtDomainRank++;
713      fprintf(fTxtOut, "%3d. %6.0f: %s - %s\n",
714       WgtDomainRank, ClbWgt, DomainNm1.CStr(), DomainNm2.CStr());
715    }}
716    fprintf(fTxtOut, "\n");
717    PGraph Graph=TGraph::New();
718    {for (int DomainN=0; DomainN<GetDomains(); DomainN++){
719      TStr DomainNm=GetDomain(DomainN)->GetDomainNm();
720      if (DomainNm=="#EMPTY"){continue;}
721      Graph->AddVrtx(TGVrtx::New(DomainN, DomainNm));
722    }}
723    double SumGraphClbOrgs=0;
724    {for (int DomainPrN=0; DomainPrN<OrgsDomainPrPrV.Len(); DomainPrN++){
725      TStr DomainNm1=OrgsDomainPrPrV[DomainPrN].Val2.Val1;
726      TStr DomainNm2=OrgsDomainPrPrV[DomainPrN].Val2.Val2;
727      double ClbOrgs=OrgsDomainPrPrV[DomainPrN].Val1;
728      if (DomainNm1<=DomainNm2){continue;}
729      SumGraphClbOrgs+=ClbOrgs;
730    }}
731    double MnGraphClbOrgs=TFlt::Mx; double MxGraphClbOrgs=TFlt::Mn;
732    double SumGraphClbOrgsSF=0; int MxDomainPrN=0;
733    {for (int DomainPrN=0; DomainPrN<OrgsDomainPrPrV.Len(); DomainPrN++){
734      TStr DomainNm1=OrgsDomainPrPrV[DomainPrN].Val2.Val1;
735      TStr DomainNm2=OrgsDomainPrPrV[DomainPrN].Val2.Val2;
736      double ClbOrgs=OrgsDomainPrPrV[DomainPrN].Val1;
737      if (DomainNm1<=DomainNm2){continue;}
738      SumGraphClbOrgsSF+=ClbOrgs;
739      if (SumGraphClbOrgsSF>SumGraphClbOrgs*0.75){break;}
740      MnGraphClbOrgs=TFlt::GetMn(MnGraphClbOrgs, ClbOrgs);
741      MxGraphClbOrgs=TFlt::GetMx(MxGraphClbOrgs, ClbOrgs);
742      MxDomainPrN=DomainPrN;
743    }}
744    {for (int DomainPrN=0; DomainPrN<=MxDomainPrN; DomainPrN++){
745      TStr DomainNm1=OrgsDomainPrPrV[DomainPrN].Val2.Val1;
746      TStr DomainNm2=OrgsDomainPrPrV[DomainPrN].Val2.Val2;
747      double ClbOrgs=OrgsDomainPrPrV[DomainPrN].Val1;
748      if (DomainNm1<=DomainNm2){continue;}
749      PVrtx Vrtx1=Graph->GetVrtx(DomainNm1);
750      PVrtx Vrtx2=Graph->GetVrtx(DomainNm2);
751      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(ClbOrgs, "%.0f"), false);
752      Edge->PutWgt(ClbOrgs);
753      int Width=1+10*((ClbOrgs-MnGraphClbOrgs)/(MxGraphClbOrgs-MnGraphClbOrgs+1));
754      Edge->PutWidth(Width);
755      Graph->AddEdge(Edge);
756    }}
757    Graph->SaveTxt(GraphFNm);
758    printf("Done.\n");
759  }
760  void TEpBs::SaveTxtUnitClb(const TStr& TxtFNm, const TStr& GraphFNm) const {
761    printf("Save Unit Collaboration to %s/%s ...\n", TxtFNm.CStr(), GraphFNm.CStr());
762    int Units=GetUnits();
763    TStrPrFltH UnitPrToWgtH;
764    TStrPrFltH UnitPrToOrgsH;
765    for (int UnitN=0; UnitN<Units; UnitN++){
766      PEpUnit Unit=GetUnit(UnitN);
767      TStr UnitNm=Unit->GetUnitNm();
768      for (int OrgN=0; OrgN<Unit->GetOrgs(); OrgN++){
769        TStr OrgNm=Unit->GetOrgNm(OrgN, this);
770        int OrgFq=Unit->GetOrgFq(OrgN);
771        for (int SubUnitN=0; SubUnitN<Units; SubUnitN++){
772          PEpUnit SubUnit=GetUnit(SubUnitN);
773          TStr SubUnitNm=SubUnit->GetUnitNm();
774          TInt SubOrgFq;
775          if (SubUnit->IsOrg(OrgNm, SubOrgFq, this)){
776            if (UnitNm==SubUnitNm){SubOrgFq--;}
777            double ClbWgt=(OrgFq*SubOrgFq);
778            if (ClbWgt>0){
779              UnitPrToWgtH.AddDat(TStrPr(UnitNm, SubUnitNm))+=ClbWgt;}
780            UnitPrToOrgsH.AddDat(TStrPr(UnitNm, SubUnitNm))++;
781          }
782        }
783      }
784    }
785    TFOut TxtFOut(TxtFNm); FILE* fTxtOut=TxtFOut.GetFileId();
786    TFltStrPrPrV OrgsUnitPrPrV;
787    UnitPrToOrgsH.GetDatKeyPrV(OrgsUnitPrPrV);
788    OrgsUnitPrPrV.Sort(false);
789    fprintf(fTxtOut, "*** Number Of Organizations In Two Units\n");
790    {for (int UnitPrN=0; UnitPrN<OrgsUnitPrPrV.Len(); UnitPrN++){
791      TStr UnitNm1=OrgsUnitPrPrV[UnitPrN].Val2.Val1;
792      TStr UnitNm2=OrgsUnitPrPrV[UnitPrN].Val2.Val2;
793      double ClbOrgs=OrgsUnitPrPrV[UnitPrN].Val1;
794      if (UnitNm1<=UnitNm2){continue;}
795      fprintf(fTxtOut, "%6.0f: %s - %s (%s - %s)\n", ClbOrgs,
796       UnitNm1.CStr(), UnitNm2.CStr(),
797       GetUnitDNm(UnitNm1).CStr(), GetUnitDNm(UnitNm2).CStr());
798    }}
799    fprintf(fTxtOut, "\n");
800    TFltStrPrPrV WgtUnitPrPrV;
801    UnitPrToWgtH.GetDatKeyPrV(WgtUnitPrPrV);
802    WgtUnitPrPrV.Sort(false);
803    fprintf(fTxtOut, "*** Weighted-Number Of Organizations In Two Units\n");
804    {for (int UnitPrN=0; UnitPrN<WgtUnitPrPrV.Len(); UnitPrN++){
805      TStr UnitNm1=WgtUnitPrPrV[UnitPrN].Val2.Val1;
806      TStr UnitNm2=WgtUnitPrPrV[UnitPrN].Val2.Val2;
807      double ClbWgt=WgtUnitPrPrV[UnitPrN].Val1;
808      if (UnitNm1<=UnitNm2){continue;}
809      fprintf(fTxtOut, "%6.0f: %s - %s (%s - %s)\n", ClbWgt,
810       UnitNm1.CStr(), UnitNm2.CStr(),
811       GetUnitDNm(UnitNm1).CStr(), GetUnitDNm(UnitNm2).CStr());
812    }}
813    fprintf(fTxtOut, "\n");
814    PGraph Graph=TGraph::New();
815    {for (int UnitN=0; UnitN<GetUnits(); UnitN++){
816      TStr UnitNm=GetUnit(UnitN)->GetUnitNm();
817      Graph->AddVrtx(TGVrtx::New(UnitN, UnitNm+"/"+GetUnitDNm(UnitNm)));
818    }}
819    double SumGraphClbOrgs=0;
820    {for (int UnitPrN=0; UnitPrN<OrgsUnitPrPrV.Len(); UnitPrN++){
821      TStr UnitNm1=OrgsUnitPrPrV[UnitPrN].Val2.Val1;
822      TStr UnitNm2=OrgsUnitPrPrV[UnitPrN].Val2.Val2;
823      double ClbOrgs=OrgsUnitPrPrV[UnitPrN].Val1;
824      if (UnitNm1<=UnitNm2){continue;}
825      SumGraphClbOrgs+=ClbOrgs;
826    }}
827    double MnGraphClbOrgs=TFlt::Mx; double MxGraphClbOrgs=TFlt::Mn;
828    double SumGraphClbOrgsSF=0; int MxUnitPrN=0;
829    {for (int UnitPrN=0; UnitPrN<OrgsUnitPrPrV.Len(); UnitPrN++){
830      TStr UnitNm1=OrgsUnitPrPrV[UnitPrN].Val2.Val1;
831      TStr UnitNm2=OrgsUnitPrPrV[UnitPrN].Val2.Val2;
832      double ClbOrgs=OrgsUnitPrPrV[UnitPrN].Val1;
833      if (UnitNm1<=UnitNm2){continue;}
834      SumGraphClbOrgsSF+=ClbOrgs;
835      if (SumGraphClbOrgsSF>SumGraphClbOrgs*0.2){break;}
836      MnGraphClbOrgs=TFlt::GetMn(MnGraphClbOrgs, ClbOrgs);
837      MxGraphClbOrgs=TFlt::GetMx(MxGraphClbOrgs, ClbOrgs);
838      MxUnitPrN=UnitPrN;
839    }}
840    for (int UnitPrN=0; UnitPrN<=MxUnitPrN; UnitPrN++){
841      TStr UnitNm1=OrgsUnitPrPrV[UnitPrN].Val2.Val1;
842      TStr UnitNm2=OrgsUnitPrPrV[UnitPrN].Val2.Val2;
843      double ClbOrgs=OrgsUnitPrPrV[UnitPrN].Val1;
844      if (UnitNm1<=UnitNm2){continue;}
845      PVrtx Vrtx1=Graph->GetVrtx(UnitNm1+"/"+GetUnitDNm(UnitNm1));
846      PVrtx Vrtx2=Graph->GetVrtx(UnitNm2+"/"+GetUnitDNm(UnitNm2));
847      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(ClbOrgs, "%.0f"), false);
848      Edge->PutWgt(ClbOrgs);
849      int Width=1+10*((ClbOrgs-MnGraphClbOrgs)/(MxGraphClbOrgs-MnGraphClbOrgs+1));
850      Edge->PutWidth(Width);
851      Graph->AddEdge(Edge);
852    }
853    Graph->SaveTxt(GraphFNm);
854    printf("Done.\n");
855  }
856  void TEpBs::SaveTxtOrgHub(const TStr& CountryHubFNm, const TStr& DomainHubFNm,
857   const TStr& UnitHubFNm) const {
858    printf("Save Organization Hubs to %s/%s/%s ...\n",
859     CountryHubFNm.CStr(), DomainHubFNm.CStr(), UnitHubFNm.CStr());
860    TStrStrIntKdVH OrgNmToCountryFqKdVH;
861    TStrStrIntKdVH OrgNmToDomainFqKdVH;
862    TStrStrIntKdVH OrgNmToUnitFqKdVH;
863    for (int OrgN=0; OrgN<GetOrgs(); OrgN++){
864      PEpOrg Org=GetOrg(OrgN);
865      TStr OrgNm=Org->GetOrgNm();
866      for (int ClbOrgN=0; ClbOrgN<Org->GetClbOrgs(); ClbOrgN++){
867        TStr ClbOrgNm=Org->GetClbOrgNm(ClbOrgN, this);
868        int ClbOrgFq=Org->GetClbOrgFq(ClbOrgN);
869        TStr ClbCountryNm=GetOrg(ClbOrgNm)->GetCountryNm();
870        TStrIntKdV& CountryFqKdV=OrgNmToCountryFqKdVH.AddDat(OrgNm);
871        CountryFqKdV.GetAddDat(TStrIntKd(ClbCountryNm)).Dat+=ClbOrgFq;
872      }
873      for (int ProjN=0; ProjN<Org->GetProjs(); ProjN++){
874        TStr ProjNm=Org->GetProjNm(ProjN);
875        PEpProj Proj=GetProj(ProjNm);
876        TStr DomainNm=Proj->GetDomainNm();
877        TStrIntKdV& DomainFqKdV=OrgNmToDomainFqKdVH.AddDat(OrgNm);
878        DomainFqKdV.GetAddDat(TStrIntKd(DomainNm)).Dat++;
879        TStr UnitNm=Proj->GetUnitNm();
880        TStrIntKdV& UnitFqKdV=OrgNmToUnitFqKdVH.AddDat(OrgNm);
881        UnitFqKdV.GetAddDat(TStrIntKd(UnitNm)).Dat++;
882      }
883    }
884    TFltStrPrV CountryWgtOrgPrV;
885    TFltStrPrV DomainWgtOrgPrV;
886    TFltStrPrV UnitWgtOrgPrV;
887    {for (int OrgN=0; OrgN<GetOrgs(); OrgN++){
888      PEpOrg Org=GetOrg(OrgN);
889      TStr OrgNm=Org->GetOrgNm();
890      if (OrgNmToCountryFqKdVH.IsKey(OrgNm)){
891        TStrIntKdV& CountryFqKdV=OrgNmToCountryFqKdVH.GetDat(OrgNm);
892        double Wgt=0;
893        for (int CountryN=0; CountryN<CountryFqKdV.Len(); CountryN++){
894          int Fq=CountryFqKdV[CountryN].Dat;
895          if (Fq>0){Wgt+=1+log(Fq);}
896        }
897        CountryWgtOrgPrV.Add(TFltStrPr(Wgt, OrgNm));
898      }
899      if (OrgNmToDomainFqKdVH.IsKey(OrgNm)){
900        TStrIntKdV& DomainFqKdV=OrgNmToDomainFqKdVH.GetDat(OrgNm);
901        double Wgt=0;
902        for (int DomainN=0; DomainN<DomainFqKdV.Len(); DomainN++){
903          int Fq=DomainFqKdV[DomainN].Dat;
904          if (Fq>0){Wgt+=1+log(Fq);}
905        }
906        DomainWgtOrgPrV.Add(TFltStrPr(Wgt, OrgNm));
907      }
908      if (OrgNmToUnitFqKdVH.IsKey(OrgNm)){
909        TStrIntKdV& UnitFqKdV=OrgNmToUnitFqKdVH.GetDat(OrgNm);
910        double Wgt=0;
911        for (int UnitN=0; UnitN<UnitFqKdV.Len(); UnitN++){
912          int Fq=UnitFqKdV[UnitN].Dat;
913          if (Fq>0){Wgt+=1+log(Fq);}
914        }
915        UnitWgtOrgPrV.Add(TFltStrPr(Wgt, OrgNm));
916      }
917    }}
918    CountryWgtOrgPrV.Sort(false);
919    DomainWgtOrgPrV.Sort(false);
920    UnitWgtOrgPrV.Sort(false);
921    {TFOut FOut(CountryHubFNm); FILE* fOut=FOut.GetFileId();
922    fprintf(fOut, "*** Country Hubs\n");
923    fprintf(fOut, "[Rank] [Score] [#Countries] [Organization] [Distribution]\n");
924    for (int OrgN=0; OrgN<CountryWgtOrgPrV.Len(); OrgN++){
925      double Wgt=CountryWgtOrgPrV[OrgN].Val1;
926      TStr OrgNm=CountryWgtOrgPrV[OrgN].Val2;
927      PEpOrg Org=GetOrg(OrgNm);
928      TStrIntKdV& CountryFqKdV=OrgNmToCountryFqKdVH.GetDat(OrgNm);
929      fprintf(fOut, "%5d. %6.2f (%2d): '%s'/%s   [",
930       1+OrgN, Wgt, CountryFqKdV.Len(), OrgNm.CStr(), Org->GetCountryNm().CStr());
931      TIntStrPrV FqCountryPrV;
932      for (int CountryN=0; CountryN<CountryFqKdV.Len(); CountryN++){
933        FqCountryPrV.Add(TIntStrPr(CountryFqKdV[CountryN].Dat, CountryFqKdV[CountryN].Key));}
934      FqCountryPrV.Sort(false);
935      {for (int CountryN=0; CountryN<CountryFqKdV.Len(); CountryN++){
936        TStr CountryNm=FqCountryPrV[CountryN].Val2;
937        int Fq=FqCountryPrV[CountryN].Val1;
938        fprintf(fOut, "'%s':%d ", CountryNm.CStr(), Fq);
939      }}
940      fprintf(fOut, "]\n");
941    }}
942    {TFOut FOut(DomainHubFNm); FILE* fOut=FOut.GetFileId();
943    fprintf(fOut, "*** Domain Hubs\n");
944    fprintf(fOut, "[Rank] [Score] [#Domains] [Organization] [Distribution]\n");
945    for (int OrgN=0; OrgN<DomainWgtOrgPrV.Len(); OrgN++){
946      double Wgt=DomainWgtOrgPrV[OrgN].Val1;
947      TStr OrgNm=DomainWgtOrgPrV[OrgN].Val2;
948      PEpOrg Org=GetOrg(OrgNm);
949      TStrIntKdV& DomainFqKdV=OrgNmToDomainFqKdVH.GetDat(OrgNm);
950      fprintf(fOut, "%5d. %6.2f (%2d): '%s'/%s   [",
951       1+OrgN, Wgt, DomainFqKdV.Len(), OrgNm.CStr(), Org->GetCountryNm().CStr());
952      TIntStrPrV FqDomainPrV;
953      for (int DomainN=0; DomainN<DomainFqKdV.Len(); DomainN++){
954        FqDomainPrV.Add(TIntStrPr(DomainFqKdV[DomainN].Dat, DomainFqKdV[DomainN].Key));}
955      FqDomainPrV.Sort(false);
956      {for (int DomainN=0; DomainN<DomainFqKdV.Len(); DomainN++){
957        TStr DomainNm=FqDomainPrV[DomainN].Val2;
958        int Fq=FqDomainPrV[DomainN].Val1;
959        fprintf(fOut, "'%s':%d ", DomainNm.CStr(), Fq);
960      }}
961      fprintf(fOut, "]\n");
962    }}
963    {TFOut FOut(UnitHubFNm); FILE* fOut=FOut.GetFileId();
964    fprintf(fOut, "*** Unit Hubs\n");
965    fprintf(fOut, "[Rank] [Score] [#Units] [Organization] [Distribution]\n");
966    for (int OrgN=0; OrgN<UnitWgtOrgPrV.Len(); OrgN++){
967      double Wgt=UnitWgtOrgPrV[OrgN].Val1;
968      TStr OrgNm=UnitWgtOrgPrV[OrgN].Val2;
969      PEpOrg Org=GetOrg(OrgNm);
970      TStrIntKdV& UnitFqKdV=OrgNmToUnitFqKdVH.GetDat(OrgNm);
971      fprintf(fOut, "%5d. %6.2f (%2d): '%s'/%s   [",
972       1+OrgN, Wgt, UnitFqKdV.Len(), OrgNm.CStr(), Org->GetCountryNm().CStr());
973      TIntStrPrV FqUnitPrV;
974      for (int UnitN=0; UnitN<UnitFqKdV.Len(); UnitN++){
975        FqUnitPrV.Add(TIntStrPr(UnitFqKdV[UnitN].Dat, UnitFqKdV[UnitN].Key));}
976      FqUnitPrV.Sort(false);
977      {for (int UnitN=0; UnitN<UnitFqKdV.Len(); UnitN++){
978        TStr UnitNm=FqUnitPrV[UnitN].Val2;
979        int Fq=FqUnitPrV[UnitN].Val1;
980        fprintf(fOut, "'%s'(%s):%d ",
981         UnitNm.CStr(), TEpBs::GetUnitDNm(UnitNm).CStr(), Fq);
982      }}
983      fprintf(fOut, "]\n");
984    }}
985    printf("Done.\n");
986  }
987  void TEpBs::SaveOrgConnectivity(const TStr& TxtFNm, const TStr& GraphFNm,
988   const int& MnClbOrgFq) const {
989    int Orgs=GetOrgs();
990    printf("Save Organization Connectivity %s/%s ...\n", TxtFNm.CStr(), GraphFNm.CStr());
991    TIntV OrgMarkV(Orgs); OrgMarkV.PutAll(-1);
992    int ConnComps=0; int NonSingleConnComps=0; TIntV ConnCompLenV;
993    forever{
994      int StartOrgId=OrgMarkV.SearchForw(-1);
995      if (StartOrgId==-1){break;}
996      int ConnCompN=ConnComps; ConnComps++; ConnCompLenV.Add(0);
997      TIntQ OpenOrgIdQ; OpenOrgIdQ.Push(StartOrgId);
998      while (!OpenOrgIdQ.Empty()){
999        int OrgId=OpenOrgIdQ.Top(); OpenOrgIdQ.Pop();
1000        PEpOrg Org=GetOrg(OrgId);
1001        IAssert((OrgMarkV[OrgId]==-1)||(OrgMarkV[OrgId]==ConnCompN));
1002        if (OrgMarkV[OrgId]==-1){
1003          OrgMarkV[OrgId]=ConnCompN;
1004          ConnCompLenV[ConnCompN]++;
1005          int ClbOrgs=Org->GetClbOrgs();
1006          for (int ClbOrgN=0; ClbOrgN<ClbOrgs; ClbOrgN++){
1007            TStr ClbOrgNm=Org->GetClbOrgNm(ClbOrgN, this);
1008            int ClbOrgFq=Org->GetClbOrgFq(ClbOrgN);
1009            int ClbOrgId=GetOrgId(ClbOrgNm);
1010            if (ClbOrgFq>=MnClbOrgFq){
1011              IAssert((OrgMarkV[ClbOrgId]==-1)||(OrgMarkV[ClbOrgId]==ConnCompN));
1012              if (OrgMarkV[ClbOrgId]==-1){
1013                OpenOrgIdQ.Push(ClbOrgId);
1014              }
1015            }
1016          }
1017        }
1018      }
1019      if (ConnCompLenV[ConnCompN]>1){
1020        NonSingleConnComps++;}
1021    }
1022    TIntStrVH ConnCompNToOrgNmVH;
1023    for (int OrgId=0; OrgId<Orgs; OrgId++){
1024      int ConnCompN=OrgMarkV[OrgId];
1025      int ConnCompLen=ConnCompLenV[ConnCompN];
1026      if (ConnCompLen>1){
1027        PEpOrg Org=GetOrg(OrgId);
1028        ConnCompNToOrgNmVH.AddDat(ConnCompN).Add(Org->GetOrgNm());}
1029    }
1030    TFOut FOut(TxtFNm); FILE* fOut=FOut.GetFileId();
1031    fprintf(fOut, "*** All Connected-Components: %d\n", ConnComps);
1032    fprintf(fOut, "*** Non-Single Connected-Components: %d\n", NonSingleConnComps);
1033    fprintf(fOut, "*** Minimal Collaboration-Frequency: %d\n", MnClbOrgFq);
1034    fprintf(fOut, "\n");
1035    for (int ConnCompP=0; ConnCompP<ConnCompNToOrgNmVH.Len(); ConnCompP++){
1036      int ConnCompN=ConnCompNToOrgNmVH.GetKey(ConnCompP);
1037      int ConnCompLen=ConnCompLenV[ConnCompN];
1038      TStrV& OrgNmV=ConnCompNToOrgNmVH[ConnCompP];
1039      OrgNmV.Sort();
1040      fprintf(fOut, "*** Connected component %d (%d organizations)\n",
1041       1+ConnCompP, ConnCompLen);
1042      for (int OrgNmN=0; OrgNmN<OrgNmV.Len(); OrgNmN++){
1043        PEpOrg Org=GetOrg(OrgNmV[OrgNmN]);
1044        fprintf(fOut, "'%s'/%s\n",
1045         Org->GetOrgNm().CStr(), Org->GetCountryNm().CStr());
1046      }
1047      fprintf(fOut, "\n");
1048    }
1049    PGraph Graph=TGraph::New();
1050    TIntV VrtxOrgIdV;
1051    int Vrtxs=0;
1052    {for (int OrgId=0; OrgId<Orgs; OrgId++){
1053      int ConnCompN=OrgMarkV[OrgId];
1054      int ConnCompLen=ConnCompLenV[ConnCompN];
1055      if (ConnCompLen>1){
1056        PEpOrg Org=GetOrg(OrgId);
1057        TStr MLOrgNm=TEpOrg::GetMultiLnOrgNm(Org->GetOrgNm());
1058        VrtxOrgIdV.Add(OrgId);
1059        Graph->AddVrtx(TGVrtx::New(OrgId, MLOrgNm));
1060        Vrtxs++;
1061      }
1062    }}
1063    int Edges=0;
1064    for (int OrgIdN1=0; OrgIdN1<VrtxOrgIdV.Len(); OrgIdN1++){
1065      int OrgId1=VrtxOrgIdV[OrgIdN1];
1066      PEpOrg Org1=GetOrg(OrgId1);
1067      for (int OrgIdN2=OrgIdN1+1; OrgIdN2<VrtxOrgIdV.Len(); OrgIdN2++){
1068        int OrgId2=VrtxOrgIdV[OrgIdN2];
1069        PEpOrg Org2=GetOrg(OrgId2);
1070        int ClbFq=Org1->GetClbOrgFq(Org2->GetOrgNm(), this);
1071        if (ClbFq>=MnClbOrgFq){
1072          PVrtx Vrtx1=Graph->GetVrtx(OrgId1);
1073          PVrtx Vrtx2=Graph->GetVrtx(OrgId2);
1074          PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TInt::GetStr(ClbFq), false);
1075          Edge->PutWidth(ClbFq-MnClbOrgFq+1);
1076          Graph->AddEdge(Edge);
1077          Edges++;
1078        }
1079      }
1080    }
1081    if (Edges>0){
1082      Graph->SaveTxt(GraphFNm);}
1083    printf("Done.\n");
1084  }
1085  void TEpBs::SaveOrgConnectivity(const TStr& TxtFNm, const TStr& GraphFNm,
1086   const int& MnClbOrgFq, const int& MxClbOrgFq) const {
1087    for (int ClbOrgFq=MnClbOrgFq; ClbOrgFq<=MxClbOrgFq; ClbOrgFq++){
1088      TStr SubTxtFNm=TxtFNm.GetFPath()+
1089       TxtFNm.GetFMid()+TInt::GetStr(ClbOrgFq)+TxtFNm.GetFExt();
1090      TStr SubGraphFNm=GraphFNm.GetFPath()+
1091       GraphFNm.GetFMid()+TInt::GetStr(ClbOrgFq)+GraphFNm.GetFExt();
1092      SaveOrgConnectivity(SubTxtFNm, SubGraphFNm, ClbOrgFq);
1093    }
1094  }
1095  void TEpBs::SaveOrgSmallWorld(const TStr& TxtFNm, const TStr& TreeFNm) const {
1096    printf("Save Organization Small World to %s/%s ...\n", TxtFNm.CStr(), TreeFNm.CStr());
1097    int Orgs=GetOrgs();
1098    typedef TTriple<PMom, TFlt, TInt> TMomDistOrgIdTr;
1099    TVec<TMomDistOrgIdTr> MomDistOrgIdV(Orgs, 0);
1100    for (int OrgId=0; OrgId<Orgs; OrgId++){
1101      printf("%d/%d\r", 1+OrgId, Orgs);
1102      PEpOrg Org=GetOrg(OrgId);
1103      PMom OrgDistMom=GetDistMom(OrgId);
1104      double OrgDistMean=OrgDistMom->GetMean();
1105      MomDistOrgIdV.Add(TMomDistOrgIdTr(OrgDistMom, -OrgDistMean, OrgId));
1106    }
1107    printf("\n");
1108    MomDistOrgIdV.Sort(false);
1109    TFOut TxtFOut(TxtFNm); FILE* fTxtOut=TxtFOut.GetFileId();
1110    fprintf(fTxtOut, "*** Organizations by average distance to the rest of the graph\n");
1111    for (int OrgIdN=0; OrgIdN<MomDistOrgIdV.Len(); OrgIdN++){
1112      PMom OrgDistMom=MomDistOrgIdV[OrgIdN].Val1;
1113      double OrgMeanDist=-MomDistOrgIdV[OrgIdN].Val2;
1114      int OrgId=MomDistOrgIdV[OrgIdN].Val3;
1115      PEpOrg Org=GetOrg(OrgId);
1116      fprintf(fTxtOut, "%4d. %4.2f avg.dist. '%s'/%s (%d projects)\n",
1117       1+OrgIdN, OrgMeanDist, Org->GetOrgNm().CStr(), Org->GetCountryNm().CStr(),
1118       Org->GetProjs());
1119    }
1120    fprintf(fTxtOut, "\n");
1121    fprintf(fTxtOut, "*** Full listing\n");
1122    {for (int OrgIdN=0; OrgIdN<MomDistOrgIdV.Len(); OrgIdN++){
1123      PMom OrgDistMom=MomDistOrgIdV[OrgIdN].Val1;
1124      double OrgMeanDist=-MomDistOrgIdV[OrgIdN].Val2;
1125      int OrgId=MomDistOrgIdV[OrgIdN].Val3;
1126      PEpOrg Org=GetOrg(OrgId);
1127      fprintf(fTxtOut, "%4d. %4.2f avg.dist. '%s'/%s (%d projects):\n\t%s\n",
1128       1+OrgIdN, OrgMeanDist, Org->GetOrgNm().CStr(), Org->GetCountryNm().CStr(),
1129       Org->GetProjs(), OrgDistMom->GetStr(' ', ':', true, "%.2f").CStr());
1130    }}
1131    fprintf(fTxtOut, "\n");
1132    if (MomDistOrgIdV.Len()>0){
1133      int BestOrgId=MomDistOrgIdV[0].Val3;
1134      PEpOrg BestOrg=GetOrg(BestOrgId);
1135      SaveOrgDistTree(TreeFNm, BestOrg->GetOrgNm());
1136    }
1137    printf("Done.\n");
1138  }
1139  void TEpBs::SaveOfficerStat(const TStr& FNm, const PBowDocBs& EpBowDocBs) const {
1140    printf("Save Officer Statistics to %s ...\n", FNm.CStr());
1141    int Offs=GetOfficers();
1142    TIntKdV FqOffIdKdV(Offs, 0);
1143    for (int OffId=0; OffId<Offs; OffId++){
1144      PEpOfficer Officer=GetOfficer(OffId);
1145      FqOffIdKdV.Add(TIntKd(Officer->GetProjs(), OffId));
1146    }
1147    FqOffIdKdV.Sort(false);
1148    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1149    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1150    for (int OffIdN=0; OffIdN<FqOffIdKdV.Len(); OffIdN++){
1151      int OffId=FqOffIdKdV[OffIdN].Dat;
1152      PEpOfficer Officer=GetOfficer(OffId);
1153      TStrIntH OrgNmToFqH;
1154      for (int ProjN=0; ProjN<Officer->GetProjs(); ProjN++){
1155        TStr ProjNm=Officer->GetProjNm(ProjN);
1156        PEpProj Proj=GetProj(ProjNm);
1157        for (int OrgN=0; OrgN<Proj->GetOrgs(); OrgN++){
1158          TStr OrgNm=Proj->GetOrgNm(OrgN, this);
1159          OrgNmToFqH.AddDat(OrgNm)++;
1160        }
1161      }
1162      fprintf(fOut, "*** %4d. '%s' (%d projects):\n",
1163       1+OffIdN, Officer->GetOfficerNm().CStr(), Officer->GetProjs());
1164      fprintf(fOut, "Projects(%d):", Officer->GetProjs());
1165      {for (int ProjN=0; ProjN<Officer->GetProjs(); ProjN++){
1166        if ((ProjN)%4==0){fprintf(fOut, "\n  ");}
1167        TStr ProjNm=Officer->GetProjNm(ProjN);
1168        PEpProj Proj=GetProj(ProjNm);
1169        fprintf(fOut, " '%s'", Proj->GetProjNm().CStr());
1170      }}
1171      fprintf(fOut, "\n");
1172      TIntStrPrV FqCountryPrV; Officer->GetFqCountryPrV(FqCountryPrV);
1173      FqCountryPrV.Sort(false);
1174      fprintf(fOut, "Countries(all:%d)\n", FqCountryPrV.Len());
1175      int SumOrgFq=0;
1176      for (int CountryN=0; CountryN<FqCountryPrV.Len(); CountryN++){
1177        SumOrgFq+=FqCountryPrV[CountryN].Val1;}
1178      fprintf(fOut, "Organizations-Per-Country(all:%d):", SumOrgFq);
1179      {for (int CountryN=0; CountryN<FqCountryPrV.Len(); CountryN++){
1180        int Fq=FqCountryPrV[CountryN].Val1;
1181        TStr CountryNm=FqCountryPrV[CountryN].Val2;
1182        if ((CountryN)%4==0){fprintf(fOut, "\n  ");}
1183        fprintf(fOut, " %s(%.1f%%/%d)",
1184         CountryNm.CStr(), 100*Fq/double(SumOrgFq), Fq);
1185      }}
1186      fprintf(fOut, "\n");
1187      TIntStrPrV FqOrgNmPrV; OrgNmToFqH.GetDatKeyPrV(FqOrgNmPrV);
1188      FqOrgNmPrV.Sort(false);
1189      fprintf(fOut, "Organizations(all:%d):\n", FqOrgNmPrV.Len());
1190      for (int OrgN=0; OrgN<FqOrgNmPrV.Len(); OrgN++){
1191        int Fq=FqOrgNmPrV[OrgN].Val1;
1192        TStr OrgNm=FqOrgNmPrV[OrgN].Val2;
1193        if (Fq>2){fprintf(fOut, "   '%s':%d\n", OrgNm.CStr(), Fq);}
1194        else {break;}
1195      }
1196      TIntV DIdV; int DId;
1197      {for (int ProjN=0; ProjN<Officer->GetProjs(); ProjN++){
1198        TStr ProjNm=Officer->GetProjNm(ProjN);
1199        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1200      }}
1201      PBowSpV ConceptSpV;
1202      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1203      TStrFltPrV WordStrWgtPrV;
1204      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, 25, 0.66, WordStrWgtPrV);
1205      fprintf(fOut, "Keywords:");
1206      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1207        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1208        double WordWgt=WordStrWgtPrV[WordN].Val2;
1209        if ((WordN)%4==0){fprintf(fOut, "\n  ");}
1210        fprintf(fOut, " [%s:%.2f]", WordStr.CStr(), WordWgt);
1211      }
1212      fprintf(fOut, "\n");
1213      fprintf(fOut, "\n");
1214    }
1215    printf("Done.\n");
1216  }
1217  void TEpBs::SaveOrgStat(const TStr& FNm, const PBowDocBs& EpBowDocBs) const {
1218    printf("Save Organization Statistics to %s ...\n", FNm.CStr());
1219    int Orgs=GetOrgs();
1220    TIntKdV FqOrgIdKdV(Orgs, 0);
1221    for (int OrgId=0; OrgId<Orgs; OrgId++){
1222      PEpOrg Org=GetOrg(OrgId);
1223      FqOrgIdKdV.Add(TIntKd(Org->GetProjs(), OrgId));
1224    }
1225    FqOrgIdKdV.Sort(false);
1226    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1227    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1228    for (int OrgIdN=0; OrgIdN<FqOrgIdKdV.Len(); OrgIdN++){
1229      printf("%d/%d\r", OrgIdN, FqOrgIdKdV.Len());
1230      int OrgId=FqOrgIdKdV[OrgIdN].Dat;
1231      PEpOrg Org=GetOrg(OrgId);
1232      fprintf(fOut, "*** %4d. '%s'/%s (%d projects):\n",
1233       1+OrgIdN, Org->GetOrgNm().CStr(), Org->GetCountryNm().CStr(),
1234       Org->GetProjs());
1235      fprintf(fOut, "Projects(%d):", Org->GetProjs());
1236      for (int ProjN=0; ProjN<Org->GetProjs(); ProjN++){
1237        if ((ProjN)%5==0){fprintf(fOut, "\n  ");}
1238        fprintf(fOut, " '%s'", Org->GetProjNm(ProjN).CStr());
1239      }
1240      fprintf(fOut, "\n");
1241      TStrIntH RoleNmToFqH;
1242      {for (int ProjN=0; ProjN<Org->GetProjs(); ProjN++){
1243        PEpProj Proj=GetProj(Org->GetProjNm(ProjN));
1244        TStr RoleNm=Proj->GetRole(Org->GetOrgNm(), this);
1245        RoleNmToFqH.AddDat(RoleNm)++;
1246      }}
1247      TIntStrPrV FqRoleNmPrV; RoleNmToFqH.GetDatKeyPrV(FqRoleNmPrV);
1248      FqRoleNmPrV.Sort(false);
1249      fprintf(fOut, "Project-Roles:\n");
1250      for (int RoleN=0; RoleN<FqRoleNmPrV.Len(); RoleN++){
1251        int RoleFq=FqRoleNmPrV[RoleN].Val1;
1252        TStr RoleNm=FqRoleNmPrV[RoleN].Val2;
1253        fprintf(fOut, " '%s':%.2f%% (%d/%d)", RoleNm.CStr(),
1254         100*RoleFq/double(Org->GetProjs()), RoleFq, Org->GetProjs());
1255      }
1256      fprintf(fOut, "\n");
1257      TIntV DIdV; int DId;
1258      {for (int ProjN=0; ProjN<Org->GetProjs(); ProjN++){
1259        TStr ProjNm=Org->GetProjNm(ProjN);
1260        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1261      }}
1262      PBowSpV ConceptSpV;
1263      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1264      TStrFltPrV WordStrWgtPrV;
1265      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, 25, 0.66, WordStrWgtPrV);
1266      fprintf(fOut, "Keywords:");
1267      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1268        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1269        double WordWgt=WordStrWgtPrV[WordN].Val2;
1270        if ((WordN)%4==0){fprintf(fOut, "\n  ");}
1271        fprintf(fOut, " [%s:%.2f]", WordStr.CStr(), WordWgt);
1272      }
1273      fprintf(fOut, "\n");
1274      fprintf(fOut, "\n");
1275    }
1276    printf("\nDone.\n");
1277  }
1278  void TEpBs::SaveDomainStat(const TStr& FNm, const PBowDocBs& EpBowDocBs) const {
1279    printf("Save Domain Statistics to %s ...\n", FNm.CStr());
1280    TIntKdV FqDomainIdKdV(GetDomains(), 0);
1281    for (int DomainId=0; DomainId<GetDomains(); DomainId++){
1282      PEpDomain Domain=GetDomain(DomainId);
1283      FqDomainIdKdV.Add(TIntKd(Domain->GetProjs(), DomainId));
1284    }
1285    FqDomainIdKdV.Sort(false);
1286    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1287    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1288    for (int DomainIdN=0; DomainIdN<FqDomainIdKdV.Len(); DomainIdN++){
1289      int DomainId=FqDomainIdKdV[DomainIdN].Dat;
1290      PEpDomain Domain=GetDomain(DomainId);
1291      fprintf(fOut, "*** %4d. '%s' (%d projects):\n",
1292       1+DomainIdN, Domain->GetDomainNm().CStr(), Domain->GetProjs());
1293      TStrIntH OrgTypeToFqH; TStrIntH CountryToFqH; int OrgFqSum=0;
1294      for (int OrgN=0; OrgN<Domain->GetOrgs(); OrgN++){
1295        int OrgId=Domain->GetOrgId(OrgN);
1296        int OrgFq=Domain->GetOrgFq(OrgN);
1297        PEpOrg Org=GetOrg(OrgId);
1298        OrgTypeToFqH.AddDat(Org->GetOrgTypeNm())+=OrgFq;
1299        CountryToFqH.AddDat(Org->GetCountryNm())+=OrgFq;
1300        OrgFqSum+=OrgFq;
1301      }
1302      TIntStrPrV FqOrgTypePrV; OrgTypeToFqH.GetDatKeyPrV(FqOrgTypePrV);
1303      TIntStrPrV FqCountryPrV; CountryToFqH.GetDatKeyPrV(FqCountryPrV);
1304      FqOrgTypePrV.Sort(false); FqCountryPrV.Sort(false);
1305      fprintf(fOut, "Organization-Types:\n");
1306      for (int OrgTypeN=0; OrgTypeN<FqOrgTypePrV.Len(); OrgTypeN++){
1307        int OrgTypeFq=FqOrgTypePrV[OrgTypeN].Val1;
1308        TStr OrgTypeNm=FqOrgTypePrV[OrgTypeN].Val2;
1309        fprintf(fOut, "   '%s': %.0f%% (%d/%d)\n", OrgTypeNm.CStr(),
1310         100*OrgTypeFq/double(OrgFqSum), OrgTypeFq, OrgFqSum);
1311      }
1312      fprintf(fOut, "Countries:");
1313      for (int CountryN=0; CountryN<FqCountryPrV.Len(); CountryN++){
1314        int CountryFq=FqCountryPrV[CountryN].Val1;
1315        double CountryPrc=CountryFq/double(OrgFqSum);
1316        if (CountryPrc<0.05){break;}
1317        TStr CountryNm=FqCountryPrV[CountryN].Val2;
1318        if ((CountryN)%2==0){fprintf(fOut, "\n  ");}
1319        fprintf(fOut, " ['%s' %.0f%% (%d/%d)]", CountryNm.CStr(),
1320         100*CountryPrc, CountryFq, OrgFqSum);
1321      }
1322      fprintf(fOut, "\n");
1323      TIntV DIdV; int DId;
1324      {for (int ProjN=0; ProjN<Domain->GetProjs(); ProjN++){
1325        TStr ProjNm=Domain->GetProjNm(ProjN);
1326        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1327      }}
1328      PBowSpV ConceptSpV;
1329      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1330      TStrFltPrV WordStrWgtPrV;
1331      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, 50, 0.5, WordStrWgtPrV);
1332      fprintf(fOut, "Keywords:");
1333      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1334        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1335        double WordWgt=WordStrWgtPrV[WordN].Val2;
1336        if ((WordN)%4==0){fprintf(fOut, "\n  ");}
1337        fprintf(fOut, " [%s:%.2f]", WordStr.CStr(), WordWgt);
1338      }
1339      fprintf(fOut, "\n");
1340      fprintf(fOut, "Projects(%d):", Domain->GetProjs());
1341      for (int ProjN=0; ProjN<Domain->GetProjs(); ProjN++){
1342        if ((ProjN)%5==0){fprintf(fOut, "\n  ");}
1343        fprintf(fOut, " '%s'", Domain->GetProjNm(ProjN).CStr());
1344      }
1345      fprintf(fOut, "\n");
1346      fprintf(fOut, "\n");
1347    }
1348    printf("Done.\n");
1349  }
1350  void TEpBs::SaveUnitStat(const TStr& FNm, const PBowDocBs& EpBowDocBs) const {
1351    printf("Save Unit Statistics to %s ...\n", FNm.CStr());
1352    int Units=GetUnits();
1353    TIntKdV FqUnitIdKdV(Units, 0);
1354    for (int UnitId=0; UnitId<Units; UnitId++){
1355      PEpUnit Unit=GetUnit(UnitId);
1356      FqUnitIdKdV.Add(TIntKd(Unit->GetProjs(), UnitId));
1357    }
1358    FqUnitIdKdV.Sort(false);
1359    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1360    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1361    for (int UnitIdN=0; UnitIdN<FqUnitIdKdV.Len(); UnitIdN++){
1362      int UnitId=FqUnitIdKdV[UnitIdN].Dat;
1363      PEpUnit Unit=GetUnit(UnitId);
1364      fprintf(fOut, "*** %4d. '%s' [%s] (%d projects):\n",
1365       1+UnitIdN, Unit->GetUnitNm().CStr(), GetUnitDNm(Unit->GetUnitNm()).CStr(),
1366       Unit->GetProjs());
1367      TStrIntH OrgTypeToFqH; TStrIntH CountryToFqH; int OrgFqSum=0;
1368      for (int OrgN=0; OrgN<Unit->GetOrgs(); OrgN++){
1369        int OrgId=Unit->GetOrgId(OrgN);
1370        int OrgFq=Unit->GetOrgFq(OrgN);
1371        PEpOrg Org=GetOrg(OrgId);
1372        OrgTypeToFqH.AddDat(Org->GetOrgTypeNm())+=OrgFq;
1373        CountryToFqH.AddDat(Org->GetCountryNm())+=OrgFq;
1374        OrgFqSum+=OrgFq;
1375      }
1376      TIntStrPrV FqOrgTypePrV; OrgTypeToFqH.GetDatKeyPrV(FqOrgTypePrV);
1377      TIntStrPrV FqCountryPrV; CountryToFqH.GetDatKeyPrV(FqCountryPrV);
1378      FqOrgTypePrV.Sort(false); FqCountryPrV.Sort(false);
1379      fprintf(fOut, "Organization-Types:\n");
1380      for (int OrgTypeN=0; OrgTypeN<FqOrgTypePrV.Len(); OrgTypeN++){
1381        int OrgTypeFq=FqOrgTypePrV[OrgTypeN].Val1;
1382        TStr OrgTypeNm=FqOrgTypePrV[OrgTypeN].Val2;
1383        fprintf(fOut, "   '%s': %.0f%% (%d/%d)\n", OrgTypeNm.CStr(),
1384         100*OrgTypeFq/double(OrgFqSum), OrgTypeFq, OrgFqSum);
1385      }
1386      fprintf(fOut, "Countries:");
1387      for (int CountryN=0; CountryN<FqCountryPrV.Len(); CountryN++){
1388        int CountryFq=FqCountryPrV[CountryN].Val1;
1389        double CountryPrc=CountryFq/double(OrgFqSum);
1390        if (CountryPrc<0.03){break;}
1391        TStr CountryNm=FqCountryPrV[CountryN].Val2;
1392        if ((CountryN)%2==0){fprintf(fOut, "\n  ");}
1393        fprintf(fOut, " ['%s' %.0f%% (%d/%d)]", CountryNm.CStr(),
1394         100*CountryPrc, CountryFq, OrgFqSum);
1395      }
1396      fprintf(fOut, "\n");
1397      TIntV DIdV; int DId;
1398      {for (int ProjN=0; ProjN<Unit->GetProjs(); ProjN++){
1399        TStr ProjNm=Unit->GetProjNm(ProjN);
1400        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1401      }}
1402      PBowSpV ConceptSpV;
1403      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1404      TStrFltPrV WordStrWgtPrV;
1405      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, 50, 0.5, WordStrWgtPrV);
1406      fprintf(fOut, "Keywords:");
1407      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1408        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1409        double WordWgt=WordStrWgtPrV[WordN].Val2;
1410        if ((WordN)%4==0){fprintf(fOut, "\n  ");}
1411        fprintf(fOut, " [%s:%.2f]", WordStr.CStr(), WordWgt);
1412      }
1413      fprintf(fOut, "\n");
1414      fprintf(fOut, "Projects(%d):", Unit->GetProjs());
1415      for (int ProjN=0; ProjN<Unit->GetProjs(); ProjN++){
1416        if ((ProjN)%5==0){fprintf(fOut, "\n  ");}
1417        fprintf(fOut, " '%s'", Unit->GetProjNm(ProjN).CStr());
1418      }
1419      fprintf(fOut, "\n");
1420      fprintf(fOut, "\n");
1421    }
1422    printf("Done.\n");
1423  }
1424  void TEpBs::SaveCountryStat(const TStr& FNm, const PBowDocBs& EpBowDocBs) const {
1425    printf("Save Country Statistics to %s ...\n", FNm.CStr());
1426    int Countries=GetCountries();
1427    TIntKdV FqCountryIdKdV(Countries, 0);
1428    for (int CountryId=0; CountryId<Countries; CountryId++){
1429      PEpCountry Country=GetCountry(CountryId);
1430      FqCountryIdKdV.Add(TIntKd(Country->GetProjs(), CountryId));
1431    }
1432    FqCountryIdKdV.Sort(false);
1433    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1434    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1435    for (int CountryIdN=0; CountryIdN<FqCountryIdKdV.Len(); CountryIdN++){
1436      int CountryId=FqCountryIdKdV[CountryIdN].Dat;
1437      PEpCountry Country=GetCountry(CountryId);
1438      fprintf(fOut, "*** %4d. '%s':\n", 1+CountryIdN, Country->GetCountryNm().CStr());
1439      fprintf(fOut, "Projects: %d\n", Country->GetProjs());
1440      fprintf(fOut, "Organizations: %d\n", Country->GetOrgs());
1441      fprintf(fOut, "Project-Participations: %d\n", Country->GetOrgFqSum());
1442      TStrIntH OrgTypeToFqH; TStrIntH OrgToFqH; int OrgFqSum=0;
1443      for (int OrgN=0; OrgN<Country->GetOrgs(); OrgN++){
1444        int OrgId=Country->GetOrgId(OrgN);
1445        int OrgFq=Country->GetOrgFq(OrgN);
1446        PEpOrg Org=GetOrg(OrgId);
1447        OrgTypeToFqH.AddDat(Org->GetOrgTypeNm())+=OrgFq;
1448        OrgToFqH.AddDat(Org->GetOrgNm())+=OrgFq;
1449        OrgFqSum+=OrgFq;
1450      }
1451      TIntStrPrV FqOrgTypePrV; OrgTypeToFqH.GetDatKeyPrV(FqOrgTypePrV);
1452      TIntStrPrV FqOrgPrV; OrgToFqH.GetDatKeyPrV(FqOrgPrV);
1453      FqOrgTypePrV.Sort(false); FqOrgPrV.Sort(false);
1454      fprintf(fOut, "Organization-Types:\n");
1455      for (int OrgTypeN=0; OrgTypeN<FqOrgTypePrV.Len(); OrgTypeN++){
1456        int OrgTypeFq=FqOrgTypePrV[OrgTypeN].Val1;
1457        TStr OrgTypeNm=FqOrgTypePrV[OrgTypeN].Val2;
1458        fprintf(fOut, "   '%s': %.0f%% (%d/%d)\n", OrgTypeNm.CStr(),
1459         100*OrgTypeFq/double(OrgFqSum), OrgTypeFq, OrgFqSum);
1460      }
1461      fprintf(fOut, "Projects Participations Per Organization:\n");
1462      for (int CountryN=0; CountryN<FqOrgPrV.Len(); CountryN++){
1463        int OrgFq=FqOrgPrV[CountryN].Val1;
1464        double OrgPrc=OrgFq/double(OrgFqSum);
1465        if (CountryN>=10){break;}
1466        TStr OrgNm=FqOrgPrV[CountryN].Val2;
1467        fprintf(fOut, "   %2d. %5.2f%% (%d/%d) '%s'\n",
1468         1+CountryN, 100*OrgPrc, OrgFq, OrgFqSum, OrgNm.CStr());
1469      }
1470      TIntV DIdV; int DId;
1471      {for (int ProjN=0; ProjN<Country->GetProjs(); ProjN++){
1472        TStr ProjNm=Country->GetProjNm(ProjN);
1473        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1474      }}
1475      PBowSpV ConceptSpV;
1476      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1477      TStrFltPrV WordStrWgtPrV;
1478      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, 50, 0.5, WordStrWgtPrV);
1479      fprintf(fOut, "Keywords:");
1480      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1481        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1482        double WordWgt=WordStrWgtPrV[WordN].Val2;
1483        if ((WordN)%4==0){fprintf(fOut, "\n  ");}
1484        fprintf(fOut, " [%s:%.2f]", WordStr.CStr(), WordWgt);
1485      }
1486      fprintf(fOut, "\n");
1487      fprintf(fOut, "Projects(%d):", Country->GetProjs());
1488      for (int ProjN=0; ProjN<Country->GetProjs(); ProjN++){
1489        if ((ProjN)%5==0){fprintf(fOut, "\n  ");}
1490        fprintf(fOut, " '%s'", Country->GetProjNm(ProjN).CStr());
1491      }
1492      fprintf(fOut, "\n");
1493      fprintf(fOut, "\n");
1494    }
1495    printf("Done.\n");
1496  }
1497  void TEpBs::SaveOrgDistTree(const TStr& FNm, const TStr& OrgNmWc) const {
1498    printf("Save Organization Distance Graph to %s ...\n", FNm.CStr());
1499    int Orgs=GetOrgs();
1500    int StartOrgId=-1;
1501    TIntKdV FqOrgIdKdV(Orgs, 0);
1502    for (int OrgId=0; OrgId<Orgs; OrgId++){
1503      PEpOrg Org=GetOrg(OrgId);
1504      TStr OrgNm=Org->GetOrgNm();
1505      if ((!OrgNmWc.Empty())&&(OrgNm.IsWcMatch(OrgNmWc))){
1506        StartOrgId=OrgId;}
1507      FqOrgIdKdV.Add(TIntKd(Org->GetProjs(), OrgId));
1508    }
1509    FqOrgIdKdV.Sort(false);
1510    int MnFullOrgNmProjs;
1511    if (FqOrgIdKdV.Len()<15){MnFullOrgNmProjs=FqOrgIdKdV.Last().Key;}
1512    else {MnFullOrgNmProjs=FqOrgIdKdV[15].Key;}
1513    if (OrgNmWc.Empty()){
1514      StartOrgId=FqOrgIdKdV[0].Dat;
1515    } else
1516    if (StartOrgId==-1){
1517      printf("No match for wild-card '%s'.\n", OrgNmWc.CStr());
1518      return;
1519    }
1520    PEpOrg StartOrg=GetOrg(StartOrgId);
1521    TStr StartOrgNm=StartOrg->GetOrgNm();
1522    printf("Creating distance graph for organization '%s'.\n", StartOrgNm.CStr());
1523    PGraph Graph=TGraph::New();
1524    Graph->AddVrtx(TGVrtx::New(StartOrgId, TEpOrg::GetMultiLnOrgNm(
1525     StartOrgNm+"("+TInt::GetStr(StartOrg->GetProjs())+")")));
1526    TIntV OrgDistV(GetOrgs()); OrgDistV.PutAll(-1);
1527    TIntPrQ OpenOrgIdQ; OpenOrgIdQ.Push(TIntPr(StartOrgId, 0));
1528    OrgDistV[StartOrgId]=0;
1529    while (!OpenOrgIdQ.Empty()){
1530      int OrgId=OpenOrgIdQ.Top().Val1;
1531      int OrgDist=OpenOrgIdQ.Top().Val2;
1532      OpenOrgIdQ.Pop();
1533      IAssert(OrgDistV[OrgId]==OrgDist);
1534      PEpOrg Org=GetOrg(OrgId);
1535      TStr OrgNm=Org->GetOrgNm();
1536      PVrtx SrcVrtx=Graph->GetVrtx(OrgId);
1537      int ClbOrgs=Org->GetClbOrgs();
1538      for (int ClbOrgN=0; ClbOrgN<ClbOrgs; ClbOrgN++){
1539        TStr ClbOrgNm=Org->GetClbOrgNm(ClbOrgN, this);
1540        int ClbOrgId=GetOrgId(ClbOrgNm);
1541        PEpOrg ClbOrg=GetOrg(ClbOrgId);
1542        if (OrgDistV[ClbOrgId]==-1){
1543          OpenOrgIdQ.Push(TIntPr(ClbOrgId, OrgDist+1));
1544          OrgDistV[ClbOrgId]=OrgDist+1;
1545          TStr VNm=ClbOrg->GetBriefOrgNm();
1546          if (ClbOrg->GetProjs()<=MnFullOrgNmProjs){VNm=TStr("_")+VNm;}
1547          VNm=VNm+"("+TInt::GetStr(ClbOrg->GetProjs())+")";
1548          VNm=TEpOrg::GetMultiLnOrgNm(VNm);
1549          PVrtx DstVrtx=TGVrtx::New(ClbOrgId, VNm);
1550          Graph->AddVrtx(DstVrtx);
1551          TStr ENm=TInt::GetStr(OrgId)+"-"+TInt::GetStr(ClbOrgId);
1552          PEdge Edge=TGEdge::New(SrcVrtx, DstVrtx, TStr("_")+ENm);
1553          Graph->AddEdge(Edge);
1554        }
1555      }
1556    }
1557    Graph->SaveTxt(FNm);
1558    printf("Done.\n");
1559  }
1560  void TEpBs::SaveDomainSim(
1561   const TStr& FNm, const PBowDocBs& EpBowDocBs,
1562   const double& SimSumPrc, const int& MxKws) const {
1563    printf("Save Domain Graph to %s ...\n", FNm.CStr());
1564    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1565    TStrStrH DomainNmToDescH;
1566    THash<TStr, PBowSpV> DomainNmToConceptSpV;
1567    for (int DomainId=0; DomainId<GetDomains(); DomainId++){
1568      PEpDomain Domain=GetDomain(DomainId);
1569      TStr DomainNm=Domain->GetDomainNm();
1570      if (DomainNm=="#EMPTY"){continue;}
1571      TIntV DIdV; int DId;
1572      for (int ProjN=0; ProjN<Domain->GetProjs(); ProjN++){
1573        TStr ProjNm=Domain->GetProjNm(ProjN);
1574        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1575      }
1576      PBowSpV ConceptSpV;
1577      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1578      TStrFltPrV WordStrWgtPrV;
1579      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, MxKws, 0.5, WordStrWgtPrV);
1580      DomainNmToConceptSpV.AddDat(DomainNm, ConceptSpV);
1581      TChA DomainDescChA;
1582      DomainDescChA+=TStr("*** ")+DomainNm+" ***";
1583      DomainDescChA+=TStr("\\")+TInt::GetStr(Domain->GetProjs())+ " projects";
1584      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1585        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1586        double WordWgt=WordStrWgtPrV[WordN].Val2;
1587        DomainDescChA+=TStr("\\")+WordStr+":"+TFlt::GetStr(WordWgt, "%.2f");
1588      }
1589      DomainNmToDescH.AddDat(DomainNm, DomainDescChA);
1590    }
1591    PBowSim BowSim=TBowSim::New(bstCos); 
1592    TFltVV DomainSimVV;
1593    double SimSum=0; TFltIntIntTrV SimN1N2TrV;
1594    for (int DomainN1=0; DomainN1<DomainNmToConceptSpV.Len(); DomainN1++){
1595      PBowSpV ConceptSpV1=DomainNmToConceptSpV[DomainN1];
1596      for (int DomainN2=DomainN1+1; DomainN2<DomainNmToConceptSpV.Len(); DomainN2++){
1597        PBowSpV ConceptSpV2=DomainNmToConceptSpV[DomainN2];
1598        double Sim=BowSim->GetSim(ConceptSpV1, ConceptSpV2);
1599        SimSum+=Sim;
1600        SimN1N2TrV.Add(TFltIntIntTr(Sim, DomainN1, DomainN2));
1601      }
1602    }
1603    SimN1N2TrV.Sort(false);
1604    PGraph Graph=TGraph::New();
1605    for (int DomainN=0; DomainN<DomainNmToConceptSpV.Len(); DomainN++){
1606      TStr DomainNm=DomainNmToConceptSpV.GetKey(DomainN);
1607      TStr DomainDescStr=DomainNmToDescH.GetDat(DomainNm);
1608      Graph->AddVrtx(TGVrtx::New(DomainN, DomainDescStr));
1609    }
1610    double SimSumSF=0;
1611    for (int SimTrN=0; SimTrN<SimN1N2TrV.Len(); SimTrN++){
1612      double Sim=SimN1N2TrV[SimTrN].Val1;
1613      double DomainN1=SimN1N2TrV[SimTrN].Val2;
1614      double DomainN2=SimN1N2TrV[SimTrN].Val3;
1615      if (SimSumSF>SimSumPrc*SimSum){continue;}
1616      PVrtx Vrtx1=Graph->GetVrtx(DomainN1);
1617      PVrtx Vrtx2=Graph->GetVrtx(DomainN2);
1618      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(Sim, "%.2f"), false);
1619      Edge->PutWgt(Sim);
1620      Graph->AddEdge(Edge);
1621      SimSumSF+=Sim;
1622    }
1623    Graph->SetEdgeWidth(5);
1624    Graph->SaveTxt(FNm);
1625    printf("Done.\n");
1626  }
1627  void TEpBs::SaveUnitSim(
1628   const TStr& FNm, const PBowDocBs& EpBowDocBs,
1629   const double& SimSumPrc, const int& MxKws) const {
1630    printf("Save Unit Graph to %s ...\n", FNm.CStr());
1631    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1632    TStrStrH UnitNmToDescH;
1633    THash<TStr, PBowSpV> UnitNmToConceptSpV;
1634    for (int UnitId=0; UnitId<GetUnits(); UnitId++){
1635      PEpUnit Unit=GetUnit(UnitId);
1636      TStr UnitNm=Unit->GetUnitNm();
1637      if (UnitNm=="#EMPTY"){continue;}
1638      TIntV DIdV; int DId;
1639      for (int ProjN=0; ProjN<Unit->GetProjs(); ProjN++){
1640        TStr ProjNm=Unit->GetProjNm(ProjN);
1641        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1642      }
1643      PBowSpV ConceptSpV;
1644      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1645      TStrFltPrV WordStrWgtPrV;
1646      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, MxKws, 0.5, WordStrWgtPrV);
1647      UnitNmToConceptSpV.AddDat(UnitNm, ConceptSpV);
1648      TChA UnitDescChA;
1649      if (UnitNm==TEpBs::GetUnitDNm(UnitNm)){
1650        UnitDescChA+=UnitNm+"("+TInt::GetStr(Unit->GetProjs())+")";
1651      } else {
1652        UnitDescChA+=UnitNm+"/"+TEpBs::GetUnitDNm(UnitNm)+"("+TInt::GetStr(Unit->GetProjs())+")";
1653      }
1654      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1655        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1656        double WordWgt=WordStrWgtPrV[WordN].Val2;
1657        UnitDescChA+=TStr("\\")+WordStr+":"+TFlt::GetStr(WordWgt, "%.2f");
1658      }
1659      UnitNmToDescH.AddDat(UnitNm, UnitDescChA);
1660    }
1661    PBowSim BowSim=TBowSim::New(bstCos); 
1662    TFltVV UnitSimVV;
1663    double SimSum=0; TFltIntIntTrV SimN1N2TrV;
1664    for (int UnitN1=0; UnitN1<UnitNmToConceptSpV.Len(); UnitN1++){
1665      PBowSpV ConceptSpV1=UnitNmToConceptSpV[UnitN1];
1666      for (int UnitN2=UnitN1+1; UnitN2<UnitNmToConceptSpV.Len(); UnitN2++){
1667        PBowSpV ConceptSpV2=UnitNmToConceptSpV[UnitN2];
1668        double Sim=BowSim->GetSim(ConceptSpV1, ConceptSpV2);
1669        SimSum+=Sim;
1670        SimN1N2TrV.Add(TFltIntIntTr(Sim, UnitN1, UnitN2));
1671      }
1672    }
1673    SimN1N2TrV.Sort(false);
1674    PGraph Graph=TGraph::New();
1675    for (int UnitN=0; UnitN<UnitNmToConceptSpV.Len(); UnitN++){
1676      TStr UnitNm=UnitNmToConceptSpV.GetKey(UnitN);
1677      TStr UnitDescStr=UnitNmToDescH.GetDat(UnitNm);
1678      Graph->AddVrtx(TGVrtx::New(UnitN, UnitDescStr));
1679    }
1680    double SimSumSF=0;
1681    for (int SimTrN=0; SimTrN<SimN1N2TrV.Len(); SimTrN++){
1682      double Sim=SimN1N2TrV[SimTrN].Val1;
1683      double UnitN1=SimN1N2TrV[SimTrN].Val2;
1684      double UnitN2=SimN1N2TrV[SimTrN].Val3;
1685      if (SimSumSF>SimSumPrc*SimSum){continue;}
1686      PVrtx Vrtx1=Graph->GetVrtx(UnitN1);
1687      PVrtx Vrtx2=Graph->GetVrtx(UnitN2);
1688      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(Sim, "%.2f"), false);
1689      Edge->PutWgt(Sim);
1690      Graph->AddEdge(Edge);
1691      SimSumSF+=Sim;
1692    }
1693    Graph->SetEdgeWidth(5);
1694    Graph->SaveTxt(FNm);
1695    printf("Done.\n");
1696  }
1697  void TEpBs::SaveOfficerSim(
1698   const TStr& GraphFNm, const PBowDocBs& EpBowDocBs,
1699   const double& SimSumPrc, const int& MxKws) const {
1700    printf("Save Officer Graph to %s ...\n", GraphFNm.CStr());
1701    PBowDocWgtBs EpBowDocWgtBs=TBowDocWgtBs::New(EpBowDocBs, bwwtNrmTFIDF, 0, 3);
1702    TStrStrH OfficerNmToDescH;
1703    THash<TStr, PBowSpV> OfficerNmToConceptSpV;
1704    for (int OfficerId=0; OfficerId<GetOfficers(); OfficerId++){
1705      PEpOfficer Officer=GetOfficer(OfficerId);
1706      TStr OfficerNm=Officer->GetOfficerNm();
1707      if (OfficerNm=="#EMPTY"){continue;}
1708      if (OfficerNm.GetTrunc().Empty()){continue;}
1709      TIntV DIdV; int DId;
1710      for (int ProjN=0; ProjN<Officer->GetProjs(); ProjN++){
1711        TStr ProjNm=Officer->GetProjNm(ProjN);
1712        if (EpBowDocBs->IsDocNm(ProjNm, DId)){DIdV.Add(DId);}
1713      }
1714      PBowSpV ConceptSpV;
1715      TBowClust::GetConceptSpV(EpBowDocWgtBs, NULL, DIdV, ConceptSpV);
1716      TStrFltPrV WordStrWgtPrV;
1717      ConceptSpV->GetWordStrWgtPrV(EpBowDocBs, MxKws, 0.5, WordStrWgtPrV);
1718      OfficerNmToConceptSpV.AddDat(OfficerNm, ConceptSpV);
1719      TChA OfficerDescChA;
1720      OfficerDescChA+=OfficerNm+"("+TInt::GetStr(Officer->GetProjs())+")";
1721      for (int WordN=0; WordN<WordStrWgtPrV.Len(); WordN++){
1722        TStr WordStr=WordStrWgtPrV[WordN].Val1;
1723        double WordWgt=WordStrWgtPrV[WordN].Val2;
1724        OfficerDescChA+=TStr("\\")+WordStr+":"+TFlt::GetStr(WordWgt, "%.2f");
1725      }
1726      OfficerNmToDescH.AddDat(OfficerNm, OfficerDescChA);
1727    }
1728    PBowSim BowSim=TBowSim::New(bstCos); 
1729    TFltVV OfficerSimVV;
1730    double SimSum=0; TFltIntIntTrV SimN1N2TrV;
1731    for (int OfficerN1=0; OfficerN1<OfficerNmToConceptSpV.Len(); OfficerN1++){
1732      PBowSpV ConceptSpV1=OfficerNmToConceptSpV[OfficerN1];
1733      for (int OfficerN2=OfficerN1+1; OfficerN2<OfficerNmToConceptSpV.Len(); OfficerN2++){
1734        PBowSpV ConceptSpV2=OfficerNmToConceptSpV[OfficerN2];
1735        double Sim=BowSim->GetSim(ConceptSpV1, ConceptSpV2);
1736        SimSum+=Sim;
1737        SimN1N2TrV.Add(TFltIntIntTr(Sim, OfficerN1, OfficerN2));
1738      }
1739    }
1740    SimN1N2TrV.Sort(false);
1741    PGraph Graph=TGraph::New();
1742    for (int OfficerN=0; OfficerN<OfficerNmToConceptSpV.Len(); OfficerN++){
1743      TStr OfficerNm=OfficerNmToConceptSpV.GetKey(OfficerN);
1744      TStr OfficerDescStr=OfficerNmToDescH.GetDat(OfficerNm);
1745      Graph->AddVrtx(TGVrtx::New(OfficerN, OfficerDescStr));
1746    }
1747    double SimSumSF=0;
1748    for (int SimTrN=0; SimTrN<SimN1N2TrV.Len(); SimTrN++){
1749      double Sim=SimN1N2TrV[SimTrN].Val1;
1750      double OfficerN1=SimN1N2TrV[SimTrN].Val2;
1751      double OfficerN2=SimN1N2TrV[SimTrN].Val3;
1752      if (SimSumSF>SimSumPrc*SimSum){continue;}
1753      PVrtx Vrtx1=Graph->GetVrtx(OfficerN1);
1754      PVrtx Vrtx2=Graph->GetVrtx(OfficerN2);
1755      PEdge Edge=TGEdge::New(Vrtx1, Vrtx2, TFlt::GetStr(Sim, "%.2f"), false);
1756      Edge->PutWgt(Sim);
1757      Graph->AddEdge(Edge);
1758      SimSumSF+=Sim;
1759    }
1760    Graph->SetEdgeWidth(5);
1761    Graph->SaveTxt(GraphFNm);
1762    printf("Done.\n");
1763  }
1764  void TEpBs::SaveOrgPowerDist(const TStr& FNm) const {
1765    int Orgs=GetOrgs();
1766    TIntPrV ClbOrgsOrgIdPrV; TIntIntH ClbOrgsToFqH;
1767    for (int OrgId=0; OrgId<Orgs; OrgId++){
1768      PEpOrg Org=GetOrg(OrgId);
1769      ClbOrgsOrgIdPrV.Add(TIntPr(Org->GetClbOrgs(), OrgId));
1770      ClbOrgsToFqH.AddDat(Org->GetClbOrgs())++;
1771    }
1772    ClbOrgsOrgIdPrV.Sort(false);
1773    TIntPrV FqClbOrgsPrV; ClbOrgsToFqH.GetDatKeyPrV(FqClbOrgsPrV);
1774    FqClbOrgsPrV.Sort(false);
1775    TFOut FOut(FNm);
1776    ClbOrgsOrgIdPrV.Save(FOut);
1777    FqClbOrgsPrV.Save(FOut);
1778  }
1779  void TEpBs::SaveCountryProjects(const TStr& FNm,
1780   const PCordisEuProjBs& EuProjBs, const TStr& CountryNm) const {
1781    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
1782    PEpCountry Country=GetCountry(CountryNm);
1783    for (int ProjN=0; ProjN<Country->GetProjs(); ProjN++){
1784      TStr ProjNm=Country->GetProjNm(ProjN);
1785      PCordisEuProj EuProj; if (EuProjBs->IsEuProj(ProjNm, EuProj)){}
1786      PEpProj Proj=GetProj(ProjNm);
1787      fprintf(fOut, "*** %s/%s-%s\n", Proj->GetProjNm().CStr(),
1788       Proj->GetDomainNm().CStr(), Proj->GetUnitNm().CStr());
1789      if (!EuProj.Empty()){
1790        fprintf(fOut, "Title: %s\n", EuProj->GetTitleStr().CStr());}
1791      fprintf(fOut, "Officer: %s\n", Proj->GetOfficerNm().CStr());
1792      fprintf(fOut, "Organizations (%d):\n", Proj->GetOrgs());
1793      for (int OrgN=0; OrgN<Proj->GetOrgs(); OrgN++){
1794        fprintf(fOut, "   %s/%s\n", Proj->GetOrgNm(OrgN, this).CStr(),
1795         GetOrg(Proj->GetOrgNm(OrgN, this))->GetCountryNm().CStr());
1796      }
1797      fprintf(fOut, "\n");
1798    }
1799  }
1800  void TEpBs::GetClbWgtProjNmPrV(
1801   TFltStrPrV& ClbWgtProjNmPrV, const int& DumpTopProjs) const {
1802    ClbWgtProjNmPrV.Clr();
1803    for (int ProjN=0; ProjN<GetProjs(); ProjN++){
1804      PEpProj Proj=GetProj(ProjN);
1805      double ClbWgt=0;
1806      for (int OrgN=0; OrgN<Proj->GetOrgs(); OrgN++){
1807        TStr OrgNm=Proj->GetOrgNm(OrgN, this);
1808        ClbWgt+=log(1+GetOrg(OrgNm)->GetClbOrgs());
1809      }
1810      ClbWgtProjNmPrV.Add(TFltStrPr(ClbWgt, Proj->GetProjNm()));
1811    }
1812    ClbWgtProjNmPrV.Sort(false);
1813    int DumpProjs=(DumpTopProjs==-1) ? GetProjs() : DumpTopProjs;
1814    {for (int ProjN=0; ProjN<DumpProjs; ProjN++){
1815      double ClbWgt=ClbWgtProjNmPrV[ProjN].Val1;
1816      TStr ProjNm=ClbWgtProjNmPrV[ProjN].Val2;
1817      PEpProj Proj=GetProj(ProjNm);
1818      printf("%d. [%.1f] %s:\n", 1+ProjN, ClbWgt, ProjNm.CStr());
1819    }}
1820  }
1821  void TEpBs::GetBestClbWgtProjNmV(const int& BestProjs, TStrV& BestProjNmV){
1822    TFltStrPrV ClbWgtProjNmPrV; GetClbWgtProjNmPrV(ClbWgtProjNmPrV);
1823    int Projs=GetProjs(); BestProjNmV.Clr();
1824    for (int ProjN=0; ProjN<BestProjs; ProjN++){
1825      if (ProjN>=Projs){break;}
1826      BestProjNmV.Add(ClbWgtProjNmPrV[ProjN].Val2);
1827    }
1828  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-xml.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-euproj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>49    TStr ValStr;
50    if (XmlTok->IsArg(Nm, ValStr)){
51      bool Val;
</pre></code></div>
                <div class="column column_space"><pre><code>513      PCiaWFBCountry CiaWFBCountry;
514      if (CiaWFBBs->IsCountry(CountryNm, CiaWFBCountry)){
515        double Population=CiaWFBCountry->GetFldValNum("Population");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    