
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.67870868562644%, Tokens: 14</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp-exp.h</h3>
            <pre><code>1  #ifdef GCC_ATOMIC
2  class TUNGraphMP;
3  typedef TPt<TUNGraphMP> PUNGraphMP;
4  class TUNGraphMP {
5  public:
6    class TNode {
7    private:
8      TInt Id;
9      TIntV NIdV;
10    public:
11      TNode() : Id(-1), NIdV() {}
12      TNode(const int& NId) : Id(NId), NIdV() { }
13      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV) { }
14      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn) { }
15      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); }
16      int GetId() const { return Id; }
17      int GetDeg() const { return NIdV.Len(); }
18      int GetInDeg() const { return GetDeg();}
<span onclick='openModal()' class='match'>19      int GetOutDeg() const { return GetDeg(); }
20      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
21      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
</span>22      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
23      bool IsInNId(const int& NId) const { return IsNbrNId(NId);}
24      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
25      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId) != -1;}
26      void PackOutNIdV() { NIdV.Pack(); }
27      void PackNIdV() { NIdV.Pack(); }
28      void SortNIdV() { NIdV.Sort(); }
29      friend class TUNGraphMP;
30    };
31    class TNodeI {
32    private:
33      typedef THashMP<TInt, TNode>::TIter THashIter;
34      THashIter NodeHI;
35    public:
36      TNodeI() : NodeHI() { }
37      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
38      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
39      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
40      TNodeI& operator++ (int) { NodeHI++; return *this; }
41      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
42      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
43      int GetId() const { return NodeHI.GetDat().GetId(); }
44      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
45      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
46      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
47      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
48      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
49      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
50      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
51      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
52      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
53      bool IsNbrNId(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
54      friend class TUNGraphMP;
55    };
56    class TEdgeI {
57    private:
58      TNodeI CurNode, EndNode;
59      int CurEdge;
60    public:
61      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
62      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
63      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
64      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
65      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
66        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
67      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
68      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
69      int GetId() const { return -1; }
70      int GetSrcNId() const { return CurNode.GetId(); }
71      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
72      friend class TUNGraphMP;
73    };
74  private:
75    TCRef CRef;
76    TInt MxNId, NEdges;
77    THashMP<TInt, TNode> NodeH;
78  private:
79    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
80    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
81  public:
82    TUNGraphMP() : CRef(), MxNId(0), NEdges(0), NodeH() { }
83    explicit TUNGraphMP(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0) { Reserve(Nodes, Edges); }
84    TUNGraphMP(const TUNGraphMP& Graph) : MxNId(Graph.MxNId), NEdges(Graph.NEdges), NodeH(Graph.NodeH) { }
85    TUNGraphMP(TSIn& SIn) : MxNId(SIn), NEdges(SIn), NodeH(SIn) { }
86    void Save(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut); }
87    static PUNGraphMP New() { return new TUNGraphMP(); }
88    static PUNGraphMP New(const int& Nodes, const int& Edges) { return new TUNGraphMP(Nodes, Edges); }
89    static PUNGraphMP Load(TSIn& SIn) { return PUNGraphMP(new TUNGraphMP(SIn)); }
90    bool HasFlag(const TGraphFlag& Flag) const;
91    TUNGraphMP& operator = (const TUNGraphMP& Graph) {
92      if (this!=&Graph) { MxNId=Graph.MxNId; NEdges=Graph.NEdges; NodeH=Graph.NodeH; }  return *this; }
93    int GetNodes() const { return NodeH.Len(); }
94    void SetNodes(const int& Length) { NodeH.SetLen(Length); }
95    int AddNode(int NId = -1);
96    int AddNodeUnchecked(int NId = -1);
97    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
98    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
99    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
100    void DelNode(const int& NId);
101    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
102    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
103    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
104    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
105    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
106    int GetMxNId() const { return MxNId; }
107    int Reserved() const {return NodeH.GetReservedKeyIds();}
108    int GetEdges() const;
109    int AddEdge(const int& SrcNId, const int& DstNId);
110    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
111    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
112    int AddOutEdge1(int& SrcIdx, const int& SrcNId, const int& DstNId);
113    int AddInEdge1(int& DstIdx, const int& SrcNId, const int& DstNId);
114    void AddOutEdge2(const int& SrcNId, const int& DstNId);
115    void AddInEdge2(const int& SrcNId, const int& DstNId);
116    void AddNodeWithEdges(const TInt& NId, TIntV& InNIdV, TIntV& OutNIdV);
117    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
118    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
119    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
120    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
121    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
122    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
123    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
124    void GetNIdV(TIntV& NIdV) const;
125    bool Empty() const { return GetNodes()==0; }
126    void Clr() { MxNId=0; NodeH.Clr(); }
127    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes); } }
128    void ReserveNIdDeg(const int& NId, const int& Deg) { GetNode(NId).NIdV.Reserve(Deg); }
129    void SortEdges(const int& Idx, const int& Deg) { if (Deg > 0) NodeH[Idx].NIdV.Sort(); }
130    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
131    void Defrag(const bool& OnlyNodeLinks=false);
132    bool IsOk(const bool& ThrowExcept=true) const;
133    void Dump(FILE *OutF=stdout) const;
134    static PUNGraphMP GetSmallGraph();
135    friend class TPt<TUNGraphMP>;
136    friend class TUNGraphMPMtx;
137  };
138  namespace TSnap {
139  template <> struct IsDirected<TUNGraphMP> { enum { Val = 1 }; };
140  }
141  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.h</h3>
            <pre><code>1  #ifndef YahooBs_h
2  #define YahooBs_h
3  #include "base.h"
4  #include "dmdata.h"
5  #include "stopword.h"
6  #include "webold.h"
7  #include "webmb.h"
8  #include "hldoc.h"
9  class TYBs;
10  class TYWord{
11  private:
12    TYBs* YBs;
13    TInt FirstChN;
14  public:
15    TYWord(): YBs(NULL), FirstChN(-1){}
16    TYWord(const TYWord& YWord): YBs(YWord.YBs), FirstChN(YWord.FirstChN){}
17    TYWord(TYBs* _YBs, const TStr& Str);
18    ~TYWord(){}
19    TYWord(TSIn& SIn): YBs(NULL), FirstChN(SIn){}
20    void Save(TSOut& SOut){FirstChN.Save(SOut);}
21    TYWord& operator=(const TYWord& YWord){
22      if (this!=&YWord){YBs=YWord.YBs; FirstChN=YWord.FirstChN;}
23      return *this;}
24    bool operator==(const TYWord& YWord) const {
25      return (GetStr()==YWord.GetStr());}
26    bool operator<(const TYWord& YWord) const {
27      return GetStr()<YWord.GetStr();}
28    TStr GetStr() const;
29    int GetSegs() const;
30    int GetPrimHashCd() const {return GetStr().GetPrimHashCd();}
31    int GetSecHashCd() const {return GetStr().GetSecHashCd();}
32    friend TYBs;
33  };
34  class TYDoc{
35  private:
36    TCRef CRef;
37  private:
38    TInt FirstPathCtgIdN;
39    TInt FirstCtgIdN;
40    TInt FirstReftoDocIdN;
41    TInt FirstRefbyDocIdN;
42    TInt FirstWordIdN;
43    TInt Sects;
44    TInt AbsSects;
45  public:
46    TYDoc():
47      FirstPathCtgIdN(-1), FirstCtgIdN(-1),
48      FirstReftoDocIdN(-1), FirstRefbyDocIdN(-1),
49      FirstWordIdN(-1), Sects(-1), AbsSects(-1){}
50    ~TYDoc(){}
51    TYDoc(TSIn& SIn):
52      FirstPathCtgIdN(SIn), FirstCtgIdN(SIn),
53      FirstReftoDocIdN(SIn), FirstRefbyDocIdN(SIn),
54      FirstWordIdN(SIn), Sects(SIn), AbsSects(SIn){}
55    static TPt<TYDoc> Load(TSIn& SIn){return new TYDoc(SIn);}
56    void Save(TSOut& SOut){
57      FirstPathCtgIdN.Save(SOut); FirstCtgIdN.Save(SOut);
58      FirstReftoDocIdN.Save(SOut); FirstRefbyDocIdN.Save(SOut);
59      FirstWordIdN.Save(SOut); Sects.Save(SOut); AbsSects.Save(SOut);}
60    TYDoc& operator=(const TYDoc&){Fail; return *this;}
61    friend TYBs;
62    friend TPt<TYDoc>;
63  };
64  typedef TPt<TYDoc> PYDoc;
65  class TYWordDs;
66  typedef TPt<TYWordDs> PYWordDs;
67  class TYWordDs{
68  private:
69    TCRef CRef;
70  public:
71    TInt Docs;
72    TInt Sects;
73    TFlt SumWordFq;
74    TIntFltKdV WordIdFqKdV;
75  public:
76    TYWordDs(const int& _Docs=0, const int& _Sects=0, const int& MxWordIds=100):
77      Docs(_Docs), Sects(_Sects), SumWordFq(0), WordIdFqKdV(MxWordIds, 0){}
78    ~TYWordDs(){}
79    TYWordDs(TSIn& SIn):
80      Docs(SIn),
81      Sects(SIn),
82      SumWordFq(SIn),
83      WordIdFqKdV(SIn){}
84    static PYWordDs Load(TSIn& SIn){return new TYWordDs(SIn);}
85    void Save(TSOut& SOut){
86      Docs.Save(SOut); Sects.Save(SOut); SumWordFq.Save(SOut);
87      WordIdFqKdV.Save(SOut);}
88    TYWordDs& operator=(const TYWordDs& YWordDs){
89      if (this!=&YWordDs){
90        Docs=YWordDs.Docs; Sects=YWordDs.Sects; SumWordFq=YWordDs.SumWordFq;
91        WordIdFqKdV=YWordDs.WordIdFqKdV;}
92      return *this;}
93    int GetDocs() const {return Docs;}
94    void AddSect(){Sects++;}
95    void PutSects(const int& _Sects){Sects=_Sects;}
96    int GetSects() const {return Sects;}
97    void AddWordIdFq(const TIntFltKd& WordIdFqKd);
98    void AddWordIdFq(const int& WordId, const double& WordFq){
99      AddWordIdFq(TIntFltKd(WordId, WordFq));}
100    bool IsWordId(const int& WordId, double& WordFq) const {
101      int WordIdFqKdN=WordIdFqKdV.SearchBin(TInt(WordId));
102      if (WordIdFqKdN==-1){return false;}
103      else {WordFq=WordIdFqKdV[WordIdFqKdN].Dat; return true;}}
104    bool IsWordId(const int& WordId) const {double WordFq;
<span onclick='openModal()' class='match'>105      return IsWordId(WordId, WordFq);}
106    double GetWordFq(const int& WordId) const {
107      return WordIdFqKdV[WordIdFqKdV.SearchBin(TInt(WordId))].Dat;}
108    double GetWordPrb(const int& WordId) const {double WordFq;
</span>109      if (IsWordId(WordId, WordFq)){return WordFq/SumWordFq;} else {return 0;}}
110    int GetWordIds() const {return WordIdFqKdV.Len();}
111    double GetSumWordFq(){return SumWordFq;}
112    int FFirstWordId() const {return 0-1;}
113    bool FNextWordId(
114     int& WordIdN, int& WordId, double& WordFq, double& WordPrb) const;
115    bool FNextWordId(int& WordIdN, int& WordId, double& WordFq) const {
116      double WordPrb; return FNextWordId(WordIdN, WordId, WordFq, WordPrb);}
117    bool FNextWordId(int& WordIdN, int& WordId) const {
118      double WordFq; double WordPrb;
119      return FNextWordId(WordIdN, WordId, WordFq, WordPrb);}
120    void NrToSumWordFq(const double& NrSumWordFq);
121    void PowWordFq(const double& Exp);
122    void SaveTxt(const PSOut& SOut, const TYBs* YBs=NULL, const int& DocId=-1);
123    static PYWordDs GetMerged(const PYWordDs& LWordDs,
124     const PYWordDs& RWordDs, const double& LWgt, const double& RWgt);
125    static PYWordDs GetTruncByMnWordPrb(
126     const PYWordDs& WordDs, const double& MnWordPrb);
127    static PYWordDs GetTruncBySumWordPrb(
128     const PYWordDs& WordDs, const double& SumWordPrb);
129    friend PYWordDs;
130  };
131  class TYSect;
132  typedef TPt<TYSect> PYSect;
133  typedef TVec<PYSect> TYSectV;
134  class TYSect{
135  private:
136    TCRef CRef;
137  private:
138    TStr RefUrlStr;
139    TStr UrlStr;
140    PYWordDs WordDs;
141    TStr TxtStr;
142  public:
143    TYSect(const TStr& _RefUrlStr, const TStr& _UrlStr,
144     const PYWordDs& _WordDs, const TStr& _TxtStr):
145      RefUrlStr(_RefUrlStr), UrlStr(_UrlStr),
146      WordDs(_WordDs), TxtStr(_TxtStr){}
147    ~TYSect(){}
148    TYSect(TSIn& SIn):
149      RefUrlStr(SIn), UrlStr(SIn), WordDs(SIn), TxtStr(SIn){}
150    static PYSect Load(TSIn& SIn){return new TYSect(SIn);}
151    void Save(TSOut& SOut){
152      RefUrlStr.Save(SOut); UrlStr.Save(SOut);
153      WordDs.Save(SOut); TxtStr.Save(SOut);}
154    TYSect& operator=(const TYSect&){Fail; return *this;}
155    TStr GetRefUrlStr(){return RefUrlStr;}
156    TStr GetUrlStr(){return UrlStr;}
157    PYWordDs GetWordDs(){return WordDs;}
158    TStr GetTxtStr(){return TxtStr;}
159    friend PYSect;
160  };
161  class TYBs{
162  private:
163    TCRef CRef;
164  private:
165    static const TStr ParWordStr;
166    PNotify Notify;
167    TInt MxNGram;
168    TInt MnWordFq;
169    TInt ParWordId;
170    TInt RootDocId;
171    TStr RootUrlStr;
172    TInt Sects;
173    TInt AbsSects;
174    PSwSet SwSet;
175    TStrIntH CtgStrToFqH;
176    THash<TYWord, TInt> WordToFqH;
177    TChA WordChAHeap;
178    THash<TStr, PYDoc> UrlStrToDocH;
179    TIntV PathCtgIdVHeap;
180    TIntV CtgIdVHeap;
181    TIntV ReftoDocIdVHeap;
182    TIntV RefbyDocIdVHeap;
183    TIntV WordIdVHeap;
184    void PutThisToWord();
185    TStr GetStrQStr(const TStrQ& StrQ, const int& Strs=-1);
186  public:
187    TYBs(const PXWebBs& WebBs,
188     const int& _MxNGram=1, const int& _MnWordFq=4,
189     const TSwSetTy& SwSetTy=swstNone, const TStrV& ExclUrlStrV=TStrV(),
190     const PNotify& _Notify=NULL);
191    ~TYBs(){}
192    TYBs(TSIn& SIn, const PNotify& _Notify=NULL):
193      Notify(_Notify),
194      MxNGram(SIn), MnWordFq(SIn), ParWordId(SIn),
195      RootDocId(SIn), RootUrlStr(SIn),
196      Sects(SIn), AbsSects(SIn),
197      SwSet(SIn), CtgStrToFqH(SIn),
198      WordToFqH(SIn), WordChAHeap(SIn),
199      UrlStrToDocH(SIn),
200      PathCtgIdVHeap(SIn), CtgIdVHeap(SIn),
201      ReftoDocIdVHeap(SIn), RefbyDocIdVHeap(SIn),
202      WordIdVHeap(SIn){SIn.LoadCs(); PutThisToWord();}
203    static TPt<TYBs> Load(TSIn& SIn){return new TYBs(SIn);}
204    void Save(TSOut& SOut){
205      MxNGram.Save(SOut); MnWordFq.Save(SOut); ParWordId.Save(SOut);
206      RootDocId.Save(SOut); RootUrlStr.Save(SOut);
207      Sects.Save(SOut); AbsSects.Save(SOut);
208      SwSet.Save(SOut); CtgStrToFqH.Save(SOut);
209      WordToFqH.Save(SOut); WordChAHeap.Save(SOut);
210      UrlStrToDocH.Save(SOut);
211      PathCtgIdVHeap.Save(SOut); CtgIdVHeap.Save(SOut);
212      ReftoDocIdVHeap.Save(SOut); RefbyDocIdVHeap.Save(SOut);
213      WordIdVHeap.Save(SOut); SOut.SaveCs();}
214    void Save(const TStr& FNm){PSOut SOut=TFOut::New(FNm); Save(*SOut);}
215    TYBs& operator=(const TYBs&){Fail; return *this;}
216    bool IsIdEqN(){
217      return CtgStrToFqH.IsKeyIdEqKeyN()&&
218       WordToFqH.IsKeyIdEqKeyN()&&
219       UrlStrToDocH.IsKeyIdEqKeyN();}
220    void AddCtgStrWords(const TStr& CtgStr, TIntV& DocWordIdV);
221    void AddDoc(
222     const PXWebPg& WebPg, const bool& DoGenDoc,
223     const int& NGram, const TStrV& ExclUrlStrV,
224     TIntPrV& DocIdRefbyDocIdPrV);
225    int GetCtgs(){return CtgStrToFqH.Len();}
226    int GetCtgId(const TStr& CtgStr){return CtgStrToFqH.GetKeyId(CtgStr);}
227    TStr GetCtgStr(const int& CtgId){return CtgStrToFqH.GetKey(CtgId);}
228    int GetCtgFq(const int& CtgId){return CtgStrToFqH[CtgId];}
229    TStr GetCtgIdVStr(const TIntV& CtgIdV);
230    void GetCtgStrV(const TIntV& CtgIdV, TStrV& CtgStrV);
231    TStr GetCtgIdToWFqHStr(const TIntFltH& CtgIdToWFqH, const double& SumPrb=1);
232    int FFirstCtg(){return CtgStrToFqH.FFirstKeyId();}
233    bool FNextCtg(int& CtgId){return CtgStrToFqH.FNextKeyId(CtgId);}
234    int GetWords(){return WordToFqH.Len();}
235    int GetMxWordIds(){return WordToFqH.GetMxKeyIds();}
236    TInt& AddWord(const TStr& WordStr);
237    int GetWordId(const TStr& WordStr);
238    TStr GetWordStr(const int& WordId) const {
239      return WordToFqH.GetKey(WordId).GetStr();}
240    int GetWordFq(const int& WordId){return WordToFqH[WordId];}
241    int GetWordSegs(const int& WordId){return WordToFqH.GetKey(WordId).GetSegs();}
242    int GetParWordId(){return ParWordId;}
243    int FFirstWordId(){return WordToFqH.FFirstKeyId();}
244    bool FNextWordId(int& WordId){return WordToFqH.FNextKeyId(WordId);}
245    int GetDocs(){return UrlStrToDocH.Len();}
246    int GetMxDocIds(){return UrlStrToDocH.GetMxKeyIds();}
247    int GetDocId(const TStr& UrlStr){return UrlStrToDocH.GetKeyId(UrlStr);}
248    TStr GetDocUrlStr(const int& DocId) const {return UrlStrToDocH.GetKey(DocId);}
249    PYDoc GetDoc(const int& DocId){return UrlStrToDocH[DocId];}
250    int GetSects(){return Sects;}
251    int GetAbsSects(){return AbsSects;}
252    int GetDocSects(const int& DocId){return UrlStrToDocH[DocId]->Sects;}
253    int GetDocAbsSects(const int& DocId){return UrlStrToDocH[DocId]->AbsSects;}
254    int GetRootDocId(){return RootDocId;}
255    TStr GetRootUrlStr(){return RootUrlStr;}
256    void GetLevDocIdV(const int& Lev, TIntV& DocIdV);
257    void GetCtgIdV(const int& DocId, TIntV& CtgIdV);
258    void GetParentDocIdV(const int& DocId, TIntV& DocIdV);
259    int GetDocDist(const int& LDocId, const int& RDocId);
260    int FFirstDocId(){return UrlStrToDocH.FFirstKeyId();}
261    bool FNextDocId(int& DocId){return UrlStrToDocH.FNextKeyId(DocId);}
262    int FFirstDocPathCtgId(const int& DocId){
263      return GetDoc(DocId)->FirstPathCtgIdN;}
264    bool FNextDocPathCtgId(int& CtgIdN, int& CtgId){
265      if (CtgIdN==-1){return false;}
266      else {CtgId=PathCtgIdVHeap[CtgIdN++]; return CtgId!=-1;}}
267    int FFirstDocCtgId(const int& DocId){
268      return GetDoc(DocId)->FirstCtgIdN;}
269    bool FNextDocCtgId(int& CtgIdN, int& CtgId){
270      if (CtgIdN==-1){return false;}
271      else {CtgId=CtgIdVHeap[CtgIdN++]; return CtgId!=-1;}}
272    int FFirstDocWordId(const int& DocId){
273      return GetDoc(DocId)->FirstWordIdN;}
274    bool FNextDocWordId(int& WordIdN, int& WordId){
275      if (WordIdN==-1){return false;}
276      else {WordId=WordIdVHeap[WordIdN++]; return WordId!=-1;}}
277    int GetDocReftos(const int& DocId);
278    int FFirstDocReftoDocId(const int& DocId){
279      return GetDoc(DocId)->FirstReftoDocIdN;}
280    bool FNextDocReftoDocId(int& ReftoDocIdN, int& ReftoDocId){
281      if (ReftoDocIdN==-1){return false;}
282      else {ReftoDocId=ReftoDocIdVHeap[ReftoDocIdN++]; return ReftoDocId!=-1;}}
283    int GetDocRefbys(const int& DocId);
284    int FFirstDocRefbyDocId(const int& DocId){
285      return GetDoc(DocId)->FirstRefbyDocIdN;}
286    bool FNextDocRefbyDocId(int& RefbyDocIdN, int& RefbyDocId){
287      if (RefbyDocIdN==-1){return false;}
288      else {RefbyDocId=RefbyDocIdVHeap[RefbyDocIdN++]; return RefbyDocId!=-1;}}
289    PYWordDs GetWordDs(const PSIn& SIn);
290    PYWordDs GetWordDs(const TStr& Str){
291      PSIn SIn=TStrIn::New(Str);
292      return GetWordDs(SIn);}
293    PYWordDs GetWordDs(const PXWebPg& WebPg){
294      PSIn SIn=TStrIn::New(WebPg->GetHttpResp()->GetBodyAsStr());
295      return GetWordDs(SIn);}
296    void GetAbsSectV(
297     const TStr& RefUrlStr, const PXWebPg& WebPg, TYSectV& YSectV);
298    static void GetAbsSectUrlStrV(const PXWebPg& WebPg, TStrV& UrlStrV);
299    void SaveTxt(const PSOut& SOut);
300    void SaveTxt(const TStr& FNm){SaveTxt(PSOut(new TFOut(FNm)));}
301    void SaveTxtWords(const TStr& FNm);
302    void SaveTxtCtgs(const TStr& FNm);
303    friend TYWord;
304    friend TYDoc;
305    friend TPt<TYBs>;
306  };
307  typedef TPt<TYBs> PYBs;
308  typedef enum {ydnConst, ydnWords, ydnLnWords, ydnSects, ydnLnSects,
309   ydnDocs, ydnLnDocs} TYDsBsNrType;
310  class TYDsBs{
311  private:
312    TCRef CRef;
313  private:
314    PYWordDs AllWordDs;
315    THash<TInt, PYWordDs> DocIdToWordDsH;
316    PNotify Notify;
317    int GetMissDss(const PYBs& YBs, const int& DocId);
318    double GetNrWgt(const TYDsBsNrType& NrType, const PYWordDs& WordDs);
319  public:
320    TYDsBs(const TYDsBsNrType& NrType, const double& WordFqExp,
321     const double& MnWordPrb, const double& MnAllWordPrb,
322     const PYBs& YBs, const PNotify& _Notify);
323    ~TYDsBs(){}
324    TYDsBs(TSIn& SIn, const PNotify& _Notify=NULL):
325      AllWordDs(SIn), DocIdToWordDsH(SIn), Notify(_Notify){SIn.LoadCs();}
326    static TPt<TYDsBs> Load(TSIn& SIn){return new TYDsBs(SIn);}
327    void Save(TSOut& SOut){
328      AllWordDs.Save(SOut); DocIdToWordDsH.Save(SOut); SOut.SaveCs();}
329    void Save(const TStr& FNm){PSOut SOut=TFOut::New(FNm); Save(*SOut);}
330    TYDsBs& operator=(const TYDsBs&){Fail; return *this;}
331    PYWordDs GetAllWordDs(){return AllWordDs;}
332    PYWordDs GetWordDs(const int& DocId){return DocIdToWordDsH.GetDat(DocId);}
333    void SaveTxt(const PSOut& SOut, const PYBs& YBs);
334    static TStr GetNrTypeStr(const TYDsBsNrType& NrType);
335    friend TPt<TYDsBs>;
336  };
337  typedef TPt<TYDsBs> PYDsBs;
338  class TYTsBs{
339  private:
340    TCRef CRef;
341  private:
342    TStrStrH TsRefUrlStrH;
343    PXWebBs WebBs;
344    PXWebTravel WebTravel;
345  public:
346    TYTsBs(
347     const double& AllDocsPrb, const double& SectPrb, const TStr& TsWebBsFPath,
348     const PXWebBs& RefWebBs, const PYBs& RefYBs,
349     const PXWebTravelEvent& WebTravelEvent, const PNotify& Notify);
350    ~TYTsBs();
351    TYTsBs(TSIn& SIn){SIn.LoadCs();}
352    static TPt<TYTsBs> Load(TSIn& SIn){return new TYTsBs(SIn);}
353    void Save(TSOut& SOut){SOut.SaveCs();}
354    TYTsBs& operator=(const TYTsBs&){Fail; return *this;}
355    void SaveTxt(const PSOut& SOut, const PYBs& YBs);
356    friend TPt<TYTsBs>;
357  };
358  typedef TPt<TYTsBs> PYTsBs;
359  class TYHlCtx{
360  private:
361    TCRef CRef;
362  private:
363    TStrV HlCtxStrV;
364  public:
365    TYHlCtx(
366     const PXWebBs& RefWebBs, const PYBs& RefYBs, const PXWebBs& DocWebBs,
367     const PNotify& Notify);
368    ~TYHlCtx(){}
369    TYHlCtx(TSIn& SIn){SIn.LoadCs();}
370    static TPt<TYHlCtx> Load(TSIn& SIn){return new TYHlCtx(SIn);}
371    void Save(TSOut& SOut){SOut.SaveCs();}
372    TYHlCtx& operator=(const TYHlCtx&){Fail; return *this;}
373    TStrV& GetHlCtxStrV(){return HlCtxStrV;}
374    friend TPt<TYHlCtx>;
375  };
376  typedef TPt<TYHlCtx> PYHlCtx;
377  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graphmp-exp.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoobs.h</div>
                <div class="column column_space"><pre><code>19      int GetOutDeg() const { return GetDeg(); }
20      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
21      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
</pre></code></div>
                <div class="column column_space"><pre><code>105      return IsWordId(WordId, WordFq);}
106    double GetWordFq(const int& WordId) const {
107      return WordIdFqKdV[WordIdFqKdV.SearchBin(TInt(WordId))].Dat;}
108    double GetWordPrb(const int& WordId) const {double WordFq;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    