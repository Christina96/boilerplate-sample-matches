
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <cmath>
3  #include <numeric>
4  #include <random>
5  #include <tuple>
6  #include <utility>
7  #include <vector>
8  #include "absl/base/internal/raw_logging.h"
9  #include "absl/container/internal/hash_function_defaults.h"
10  #include "absl/container/internal/raw_hash_set.h"
11  #include "absl/strings/str_format.h"
12  #include "benchmark/benchmark.h"
13  namespace absl {
14  ABSL_NAMESPACE_BEGIN
15  namespace container_internal {
16  struct RawHashSetTestOnlyAccess {
17    template <typename C>
18    static auto GetSlots(const C& c) -> decltype(c.slots_) {
19      return c.slots_;
20    }
21  };
22  namespace {
23  struct IntPolicy {
24    using slot_type = int64_t;
25    using key_type = int64_t;
26    using init_type = int64_t;
27    static void construct(void*, int64_t* slot, int64_t v) { *slot = v; }
28    static void destroy(void*, int64_t*) {}
29    static void transfer(void*, int64_t* new_slot, int64_t* old_slot) {
30      *new_slot = *old_slot;
31    }
32    static int64_t& element(slot_type* slot) { return *slot; }
33    template <class F>
34    static auto apply(F&& f, int64_t x) -> decltype(std::forward<F>(f)(x, x)) {
35      return std::forward<F>(f)(x, x);
36    }
37  };
38  class StringPolicy {
39    template <class F, class K, class V,
40              class = typename std::enable_if<
41                  std::is_convertible<const K&, absl::string_view>::value>::type>
42    decltype(std::declval<F>()(
43        std::declval<const absl::string_view&>(), std::piecewise_construct,
44        std::declval<std::tuple<K>>(),
45        std::declval<V>())) static apply_impl(F&& f,
46                                              std::pair<std::tuple<K>, V> p) {
47      const absl::string_view& key = std::get<0>(p.first);
48      return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),
49                                std::move(p.second));
50    }
51   public:
52    struct slot_type {
53      struct ctor {};
54      template <class... Ts>
55      slot_type(ctor, Ts&&... ts) : pair(std::forward<Ts>(ts)...) {}
56      std::pair<std::string, std::string> pair;
57    };
58    using key_type = std::string;
59    using init_type = std::pair<std::string, std::string>;
60    template <class allocator_type, class... Args>
61    static void construct(allocator_type* alloc, slot_type* slot, Args... args) {
62      std::allocator_traits<allocator_type>::construct(
63          *alloc, slot, typename slot_type::ctor(), std::forward<Args>(args)...);
64    }
65    template <class allocator_type>
66    static void destroy(allocator_type* alloc, slot_type* slot) {
67      std::allocator_traits<allocator_type>::destroy(*alloc, slot);
68    }
69    template <class allocator_type>
70    static void transfer(allocator_type* alloc, slot_type* new_slot,
71                         slot_type* old_slot) {
72      construct(alloc, new_slot, std::move(old_slot->pair));
73      destroy(alloc, old_slot);
74    }
75    static std::pair<std::string, std::string>& element(slot_type* slot) {
76      return slot->pair;
77    }
78    template <class F, class... Args>
79    static auto apply(F&& f, Args&&... args)
80        -> decltype(apply_impl(std::forward<F>(f),
81                               PairArgs(std::forward<Args>(args)...))) {
82      return apply_impl(std::forward<F>(f),
83                        PairArgs(std::forward<Args>(args)...));
84    }
85  };
86  struct StringHash : container_internal::hash_default_hash<absl::string_view> {
87    using is_transparent = void;
88  };
89  struct StringEq : std::equal_to<absl::string_view> {
90    using is_transparent = void;
91  };
92  struct StringTable
93      : raw_hash_set<StringPolicy, StringHash, StringEq, std::allocator<int>> {
94    using Base = typename StringTable::raw_hash_set;
95    StringTable() {}
96    using Base::Base;
97  };
98  struct IntTable
99      : raw_hash_set<IntPolicy, container_internal::hash_default_hash<int64_t>,
100                     std::equal_to<int64_t>, std::allocator<int64_t>> {
101    using Base = typename IntTable::raw_hash_set;
102    IntTable() {}
103    using Base::Base;
104  };
105  struct string_generator {
106    template <class RNG>
107    std::string operator()(RNG& rng) const {
108      std::string res;
109      res.resize(12);
110      std::uniform_int_distribution<uint32_t> printable_ascii(0x20, 0x7E);
111      std::generate(res.begin(), res.end(), [&] { return printable_ascii(rng); });
112      return res;
113    }
114    size_t size;
115  };
116  void BM_CacheInSteadyState(benchmark::State& state) {
117    std::random_device rd;
<span onclick='openModal()' class='match'>118    std::mt19937 rng(rd());
119    string_generator gen{12};
120    StringTable t;
121    std::deque<std::string> keys;
</span>122    while (t.size() < state.range(0)) {
123      auto x = t.emplace(gen(rng), gen(rng));
124      if (x.second) keys.push_back(x.first->first);
125    }
126    ABSL_RAW_CHECK(state.range(0) >= 10, "");
127    while (state.KeepRunning()) {
128      std::deque<std::string>::const_iterator it;
129      for (int i = 0; i != 90; ++i) {
130        if (i % 10 == 0) it = keys.end();
131        ::benchmark::DoNotOptimize(t.find(*--it));
132      }
133      for (int i = 0; i != 10; ++i) ::benchmark::DoNotOptimize(t.find(gen(rng)));
134      ABSL_RAW_CHECK(t.erase(keys.front()), keys.front().c_str());
135      keys.pop_front();
136      while (true) {
137        auto x = t.emplace(gen(rng), gen(rng));
138        if (x.second) {
139          keys.push_back(x.first->first);
140          break;
141        }
142      }
143    }
144    state.SetItemsProcessed(state.iterations());
145    state.SetLabel(absl::StrFormat("load_factor=%.2f", t.load_factor()));
146  }
147  template <typename Benchmark>
148  void CacheInSteadyStateArgs(Benchmark* bm) {
149    const float max_load_factor = 0.875;
150    const size_t capacity = 1 << 10;
151    const size_t kNumPoints = 10;
152    for (size_t i = 0; i != kNumPoints; ++i)
153      bm->Arg(std::ceil(
154          capacity * (max_load_factor + i * max_load_factor / kNumPoints) / 2));
155  }
156  BENCHMARK(BM_CacheInSteadyState)->Apply(CacheInSteadyStateArgs);
157  void BM_EndComparison(benchmark::State& state) {
158    StringTable t = {{"a", "a"}, {"b", "b"}};
159    auto it = t.begin();
160    for (auto i : state) {
161      benchmark::DoNotOptimize(t);
162      benchmark::DoNotOptimize(it);
163      benchmark::DoNotOptimize(it != t.end());
164    }
165  }
166  BENCHMARK(BM_EndComparison);
167  void BM_Iteration(benchmark::State& state) {
168    std::random_device rd;
169    std::mt19937 rng(rd());
170    string_generator gen{12};
171    StringTable t;
172    size_t capacity = state.range(0);
173    size_t size = state.range(1);
174    t.reserve(capacity);
175    while (t.size() < size) {
176      t.emplace(gen(rng), gen(rng));
177    }
178    for (auto i : state) {
179      benchmark::DoNotOptimize(t);
180      for (auto it = t.begin(); it != t.end(); ++it) {
181        benchmark::DoNotOptimize(*it);
182      }
183    }
184  }
185  BENCHMARK(BM_Iteration)
186      ->ArgPair(1, 1)
187      ->ArgPair(2, 2)
188      ->ArgPair(4, 4)
189      ->ArgPair(7, 7)
190      ->ArgPair(10, 10)
191      ->ArgPair(15, 15)
192      ->ArgPair(16, 16)
193      ->ArgPair(54, 54)
194      ->ArgPair(100, 100)
195      ->ArgPair(400, 400)
196      ->ArgPair(0, 0)
197      ->ArgPair(10, 0)
198      ->ArgPair(100, 0)
199      ->ArgPair(1000, 0)
200      ->ArgPair(10000, 0)
201      ->ArgPair(100, 1)
202      ->ArgPair(1000, 10);
203  void BM_CopyCtorSparseInt(benchmark::State& state) {
204    std::random_device rd;
205    std::mt19937 rng(rd());
206    IntTable t;
207    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
208    size_t size = state.range(0);
209    t.reserve(size * 10);
210    while (t.size() < size) {
211      t.emplace(dist(rng));
212    }
213    for (auto i : state) {
214      IntTable t2 = t;
215      benchmark::DoNotOptimize(t2);
216    }
217  }
218  BENCHMARK(BM_CopyCtorSparseInt)->Range(128, 4096);
219  void BM_CopyCtorInt(benchmark::State& state) {
220    std::random_device rd;
221    std::mt19937 rng(rd());
222    IntTable t;
223    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
224    size_t size = state.range(0);
225    while (t.size() < size) {
226      t.emplace(dist(rng));
227    }
228    for (auto i : state) {
229      IntTable t2 = t;
230      benchmark::DoNotOptimize(t2);
231    }
232  }
233  BENCHMARK(BM_CopyCtorInt)->Range(128, 4096);
234  void BM_CopyCtorString(benchmark::State& state) {
235    std::random_device rd;
236    std::mt19937 rng(rd());
237    StringTable t;
238    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
239    size_t size = state.range(0);
240    while (t.size() < size) {
241      t.emplace(std::to_string(dist(rng)), std::to_string(dist(rng)));
242    }
243    for (auto i : state) {
244      StringTable t2 = t;
245      benchmark::DoNotOptimize(t2);
246    }
247  }
248  BENCHMARK(BM_CopyCtorString)->Range(128, 4096);
249  void BM_CopyAssign(benchmark::State& state) {
250    std::random_device rd;
251    std::mt19937 rng(rd());
252    IntTable t;
253    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
254    while (t.size() < state.range(0)) {
255      t.emplace(dist(rng));
256    }
257    IntTable t2;
258    for (auto _ : state) {
259      t2 = t;
260      benchmark::DoNotOptimize(t2);
261    }
262  }
263  BENCHMARK(BM_CopyAssign)->Range(128, 4096);
264  void BM_RangeCtor(benchmark::State& state) {
265    std::random_device rd;
266    std::mt19937 rng(rd());
267    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
268    std::vector<int> values;
269    const size_t desired_size = state.range(0);
270    while (values.size() < desired_size) {
271      values.emplace_back(dist(rng));
272    }
273    for (auto unused : state) {
274      IntTable t{values.begin(), values.end()};
275      benchmark::DoNotOptimize(t);
276    }
277  }
278  BENCHMARK(BM_RangeCtor)->Range(128, 65536);
279  void BM_NoOpReserveIntTable(benchmark::State& state) {
280    IntTable t;
281    t.reserve(100000);
282    for (auto _ : state) {
283      benchmark::DoNotOptimize(t);
284      t.reserve(100000);
285    }
286  }
287  BENCHMARK(BM_NoOpReserveIntTable);
288  void BM_NoOpReserveStringTable(benchmark::State& state) {
289    StringTable t;
290    t.reserve(100000);
291    for (auto _ : state) {
292      benchmark::DoNotOptimize(t);
293      t.reserve(100000);
294    }
295  }
296  BENCHMARK(BM_NoOpReserveStringTable);
297  void BM_ReserveIntTable(benchmark::State& state) {
298    int reserve_size = state.range(0);
299    for (auto _ : state) {
300      state.PauseTiming();
301      IntTable t;
302      state.ResumeTiming();
303      benchmark::DoNotOptimize(t);
304      t.reserve(reserve_size);
305    }
306  }
307  BENCHMARK(BM_ReserveIntTable)->Range(128, 4096);
308  void BM_ReserveStringTable(benchmark::State& state) {
309    int reserve_size = state.range(0);
310    for (auto _ : state) {
311      state.PauseTiming();
312      StringTable t;
313      state.ResumeTiming();
314      benchmark::DoNotOptimize(t);
315      t.reserve(reserve_size);
316    }
317  }
318  BENCHMARK(BM_ReserveStringTable)->Range(128, 4096);
319  template <typename CtrlIter>
320  void Iota(CtrlIter begin, CtrlIter end, int value) {
321    for (; begin != end; ++begin, ++value) {
322      *begin = static_cast<ctrl_t>(value);
323    }
324  }
325  void BM_Group_Match(benchmark::State& state) {
326    std::array<ctrl_t, Group::kWidth> group;
327    Iota(group.begin(), group.end(), -4);
328    Group g{group.data()};
329    h2_t h = 1;
330    for (auto _ : state) {
331      ::benchmark::DoNotOptimize(h);
332      ::benchmark::DoNotOptimize(g);
333      ::benchmark::DoNotOptimize(g.Match(h));
334    }
335  }
336  BENCHMARK(BM_Group_Match);
337  void BM_Group_MaskEmpty(benchmark::State& state) {
338    std::array<ctrl_t, Group::kWidth> group;
339    Iota(group.begin(), group.end(), -4);
340    Group g{group.data()};
341    for (auto _ : state) {
342      ::benchmark::DoNotOptimize(g);
343      ::benchmark::DoNotOptimize(g.MaskEmpty());
344    }
345  }
346  BENCHMARK(BM_Group_MaskEmpty);
347  void BM_Group_MaskEmptyOrDeleted(benchmark::State& state) {
348    std::array<ctrl_t, Group::kWidth> group;
349    Iota(group.begin(), group.end(), -4);
350    Group g{group.data()};
351    for (auto _ : state) {
352      ::benchmark::DoNotOptimize(g);
353      ::benchmark::DoNotOptimize(g.MaskEmptyOrDeleted());
354    }
355  }
356  BENCHMARK(BM_Group_MaskEmptyOrDeleted);
357  void BM_Group_CountLeadingEmptyOrDeleted(benchmark::State& state) {
358    std::array<ctrl_t, Group::kWidth> group;
359    Iota(group.begin(), group.end(), -2);
360    Group g{group.data()};
361    for (auto _ : state) {
362      ::benchmark::DoNotOptimize(g);
363      ::benchmark::DoNotOptimize(g.CountLeadingEmptyOrDeleted());
364    }
365  }
366  BENCHMARK(BM_Group_CountLeadingEmptyOrDeleted);
367  void BM_Group_MatchFirstEmptyOrDeleted(benchmark::State& state) {
368    std::array<ctrl_t, Group::kWidth> group;
369    Iota(group.begin(), group.end(), -2);
370    Group g{group.data()};
371    for (auto _ : state) {
372      ::benchmark::DoNotOptimize(g);
373      ::benchmark::DoNotOptimize(g.MaskEmptyOrDeleted().LowestBitSet());
374    }
375  }
376  BENCHMARK(BM_Group_MatchFirstEmptyOrDeleted);
377  void BM_DropDeletes(benchmark::State& state) {
378    constexpr size_t capacity = (1 << 20) - 1;
379    std::vector<ctrl_t> ctrl(capacity + 1 + Group::kWidth);
380    ctrl[capacity] = ctrl_t::kSentinel;
381    std::vector<ctrl_t> pattern = {ctrl_t::kEmpty,   static_cast<ctrl_t>(2),
382                                   ctrl_t::kDeleted, static_cast<ctrl_t>(2),
383                                   ctrl_t::kEmpty,   static_cast<ctrl_t>(1),
384                                   ctrl_t::kDeleted};
385    for (size_t i = 0; i != capacity; ++i) {
386      ctrl[i] = pattern[i % pattern.size()];
387    }
388    while (state.KeepRunning()) {
389      state.PauseTiming();
390      std::vector<ctrl_t> ctrl_copy = ctrl;
391      state.ResumeTiming();
392      ConvertDeletedToEmptyAndFullToDeleted(ctrl_copy.data(), capacity);
393      ::benchmark::DoNotOptimize(ctrl_copy[capacity]);
394    }
395  }
396  BENCHMARK(BM_DropDeletes);
397  void BM_Resize(benchmark::State& state) {
398    constexpr int kElements = 64;
399    const int kCapacity = kElements * 2;
400    IntTable table;
401    for (int i = 0; i < kElements; i++) {
402      table.insert(i);
403    }
404    for (auto unused : state) {
405      table.rehash(0);
406      table.rehash(kCapacity);
407    }
408  }
409  BENCHMARK(BM_Resize);
410  }  
411  }  
412  ABSL_NAMESPACE_END
413  }  
414  auto CodegenAbslRawHashSetInt64Find(absl::container_internal::IntTable* table,
415                                      int64_t key) -> decltype(table->find(key)) {
416    return table->find(key);
417  }
418  bool CodegenAbslRawHashSetInt64FindNeEnd(
419      absl::container_internal::IntTable* table, int64_t key) {
420    return table->find(key) != table->end();
421  }
422  bool CodegenAbslRawHashSetStringFindNeEnd(
423      absl::container_internal::StringTable* table, const std::string& key) {
424    return table->find(key) != table->end();
425  }
426  auto CodegenAbslRawHashSetInt64Insert(absl::container_internal::IntTable* table,
427                                        int64_t key)
428      -> decltype(table->insert(key)) {
429    return table->insert(key);
430  }
431  bool CodegenAbslRawHashSetInt64Contains(
432      absl::container_internal::IntTable* table, int64_t key) {
433    return table->contains(key);
434  }
435  void CodegenAbslRawHashSetInt64Iterate(
436      absl::container_internal::IntTable* table) {
437    for (auto x : *table) benchmark::DoNotOptimize(x);
438  }
439  int odr =
440      (::benchmark::DoNotOptimize(std::make_tuple(
441           &CodegenAbslRawHashSetInt64Find, &CodegenAbslRawHashSetInt64FindNeEnd,
442           &CodegenAbslRawHashSetStringFindNeEnd,
443           &CodegenAbslRawHashSetInt64Insert, &CodegenAbslRawHashSetInt64Contains,
444           &CodegenAbslRawHashSetInt64Iterate)),
445       1);
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <cmath>
3  #include <numeric>
4  #include <random>
5  #include <tuple>
6  #include <utility>
7  #include <vector>
8  #include "absl/base/internal/raw_logging.h"
9  #include "absl/container/internal/hash_function_defaults.h"
10  #include "absl/container/internal/raw_hash_set.h"
11  #include "absl/strings/str_format.h"
12  #include "benchmark/benchmark.h"
13  namespace absl {
14  ABSL_NAMESPACE_BEGIN
15  namespace container_internal {
16  struct RawHashSetTestOnlyAccess {
17    template <typename C>
18    static auto GetSlots(const C& c) -> decltype(c.slots_) {
19      return c.slots_;
20    }
21  };
22  namespace {
23  struct IntPolicy {
24    using slot_type = int64_t;
25    using key_type = int64_t;
26    using init_type = int64_t;
27    static void construct(void*, int64_t* slot, int64_t v) { *slot = v; }
28    static void destroy(void*, int64_t*) {}
29    static void transfer(void*, int64_t* new_slot, int64_t* old_slot) {
30      *new_slot = *old_slot;
31    }
32    static int64_t& element(slot_type* slot) { return *slot; }
33    template <class F>
34    static auto apply(F&& f, int64_t x) -> decltype(std::forward<F>(f)(x, x)) {
35      return std::forward<F>(f)(x, x);
36    }
37  };
38  class StringPolicy {
39    template <class F, class K, class V,
40              class = typename std::enable_if<
41                  std::is_convertible<const K&, absl::string_view>::value>::type>
42    decltype(std::declval<F>()(
43        std::declval<const absl::string_view&>(), std::piecewise_construct,
44        std::declval<std::tuple<K>>(),
45        std::declval<V>())) static apply_impl(F&& f,
46                                              std::pair<std::tuple<K>, V> p) {
47      const absl::string_view& key = std::get<0>(p.first);
48      return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),
49                                std::move(p.second));
50    }
51   public:
52    struct slot_type {
53      struct ctor {};
54      template <class... Ts>
55      slot_type(ctor, Ts&&... ts) : pair(std::forward<Ts>(ts)...) {}
56      std::pair<std::string, std::string> pair;
57    };
58    using key_type = std::string;
59    using init_type = std::pair<std::string, std::string>;
60    template <class allocator_type, class... Args>
61    static void construct(allocator_type* alloc, slot_type* slot, Args... args) {
62      std::allocator_traits<allocator_type>::construct(
63          *alloc, slot, typename slot_type::ctor(), std::forward<Args>(args)...);
64    }
65    template <class allocator_type>
66    static void destroy(allocator_type* alloc, slot_type* slot) {
67      std::allocator_traits<allocator_type>::destroy(*alloc, slot);
68    }
69    template <class allocator_type>
70    static void transfer(allocator_type* alloc, slot_type* new_slot,
71                         slot_type* old_slot) {
72      construct(alloc, new_slot, std::move(old_slot->pair));
73      destroy(alloc, old_slot);
74    }
75    static std::pair<std::string, std::string>& element(slot_type* slot) {
76      return slot->pair;
77    }
78    template <class F, class... Args>
79    static auto apply(F&& f, Args&&... args)
80        -> decltype(apply_impl(std::forward<F>(f),
81                               PairArgs(std::forward<Args>(args)...))) {
82      return apply_impl(std::forward<F>(f),
83                        PairArgs(std::forward<Args>(args)...));
84    }
85  };
86  struct StringHash : container_internal::hash_default_hash<absl::string_view> {
87    using is_transparent = void;
88  };
89  struct StringEq : std::equal_to<absl::string_view> {
90    using is_transparent = void;
91  };
92  struct StringTable
93      : raw_hash_set<StringPolicy, StringHash, StringEq, std::allocator<int>> {
94    using Base = typename StringTable::raw_hash_set;
95    StringTable() {}
96    using Base::Base;
97  };
98  struct IntTable
99      : raw_hash_set<IntPolicy, container_internal::hash_default_hash<int64_t>,
100                     std::equal_to<int64_t>, std::allocator<int64_t>> {
101    using Base = typename IntTable::raw_hash_set;
102    IntTable() {}
103    using Base::Base;
104  };
105  struct string_generator {
106    template <class RNG>
107    std::string operator()(RNG& rng) const {
108      std::string res;
109      res.resize(12);
110      std::uniform_int_distribution<uint32_t> printable_ascii(0x20, 0x7E);
111      std::generate(res.begin(), res.end(), [&] { return printable_ascii(rng); });
112      return res;
113    }
114    size_t size;
115  };
116  void BM_CacheInSteadyState(benchmark::State& state) {
117    std::random_device rd;
<span onclick='openModal()' class='match'>118    std::mt19937 rng(rd());
119    string_generator gen{12};
120    StringTable t;
121    std::deque<std::string> keys;
</span>122    while (t.size() < state.range(0)) {
123      auto x = t.emplace(gen(rng), gen(rng));
124      if (x.second) keys.push_back(x.first->first);
125    }
126    ABSL_RAW_CHECK(state.range(0) >= 10, "");
127    while (state.KeepRunning()) {
128      std::deque<std::string>::const_iterator it;
129      for (int i = 0; i != 90; ++i) {
130        if (i % 10 == 0) it = keys.end();
131        ::benchmark::DoNotOptimize(t.find(*--it));
132      }
133      for (int i = 0; i != 10; ++i) ::benchmark::DoNotOptimize(t.find(gen(rng)));
134      ABSL_RAW_CHECK(t.erase(keys.front()), keys.front().c_str());
135      keys.pop_front();
136      while (true) {
137        auto x = t.emplace(gen(rng), gen(rng));
138        if (x.second) {
139          keys.push_back(x.first->first);
140          break;
141        }
142      }
143    }
144    state.SetItemsProcessed(state.iterations());
145    state.SetLabel(absl::StrFormat("load_factor=%.2f", t.load_factor()));
146  }
147  template <typename Benchmark>
148  void CacheInSteadyStateArgs(Benchmark* bm) {
149    const float max_load_factor = 0.875;
150    const size_t capacity = 1 << 10;
151    const size_t kNumPoints = 10;
152    for (size_t i = 0; i != kNumPoints; ++i)
153      bm->Arg(std::ceil(
154          capacity * (max_load_factor + i * max_load_factor / kNumPoints) / 2));
155  }
156  BENCHMARK(BM_CacheInSteadyState)->Apply(CacheInSteadyStateArgs);
157  void BM_EndComparison(benchmark::State& state) {
158    StringTable t = {{"a", "a"}, {"b", "b"}};
159    auto it = t.begin();
160    for (auto i : state) {
161      benchmark::DoNotOptimize(t);
162      benchmark::DoNotOptimize(it);
163      benchmark::DoNotOptimize(it != t.end());
164    }
165  }
166  BENCHMARK(BM_EndComparison);
167  void BM_Iteration(benchmark::State& state) {
168    std::random_device rd;
169    std::mt19937 rng(rd());
170    string_generator gen{12};
171    StringTable t;
172    size_t capacity = state.range(0);
173    size_t size = state.range(1);
174    t.reserve(capacity);
175    while (t.size() < size) {
176      t.emplace(gen(rng), gen(rng));
177    }
178    for (auto i : state) {
179      benchmark::DoNotOptimize(t);
180      for (auto it = t.begin(); it != t.end(); ++it) {
181        benchmark::DoNotOptimize(*it);
182      }
183    }
184  }
185  BENCHMARK(BM_Iteration)
186      ->ArgPair(1, 1)
187      ->ArgPair(2, 2)
188      ->ArgPair(4, 4)
189      ->ArgPair(7, 7)
190      ->ArgPair(10, 10)
191      ->ArgPair(15, 15)
192      ->ArgPair(16, 16)
193      ->ArgPair(54, 54)
194      ->ArgPair(100, 100)
195      ->ArgPair(400, 400)
196      ->ArgPair(0, 0)
197      ->ArgPair(10, 0)
198      ->ArgPair(100, 0)
199      ->ArgPair(1000, 0)
200      ->ArgPair(10000, 0)
201      ->ArgPair(100, 1)
202      ->ArgPair(1000, 10);
203  void BM_CopyCtorSparseInt(benchmark::State& state) {
204    std::random_device rd;
205    std::mt19937 rng(rd());
206    IntTable t;
207    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
208    size_t size = state.range(0);
209    t.reserve(size * 10);
210    while (t.size() < size) {
211      t.emplace(dist(rng));
212    }
213    for (auto i : state) {
214      IntTable t2 = t;
215      benchmark::DoNotOptimize(t2);
216    }
217  }
218  BENCHMARK(BM_CopyCtorSparseInt)->Range(128, 4096);
219  void BM_CopyCtorInt(benchmark::State& state) {
220    std::random_device rd;
221    std::mt19937 rng(rd());
222    IntTable t;
223    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
224    size_t size = state.range(0);
225    while (t.size() < size) {
226      t.emplace(dist(rng));
227    }
228    for (auto i : state) {
229      IntTable t2 = t;
230      benchmark::DoNotOptimize(t2);
231    }
232  }
233  BENCHMARK(BM_CopyCtorInt)->Range(128, 4096);
234  void BM_CopyCtorString(benchmark::State& state) {
235    std::random_device rd;
236    std::mt19937 rng(rd());
237    StringTable t;
238    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
239    size_t size = state.range(0);
240    while (t.size() < size) {
241      t.emplace(std::to_string(dist(rng)), std::to_string(dist(rng)));
242    }
243    for (auto i : state) {
244      StringTable t2 = t;
245      benchmark::DoNotOptimize(t2);
246    }
247  }
248  BENCHMARK(BM_CopyCtorString)->Range(128, 4096);
249  void BM_CopyAssign(benchmark::State& state) {
250    std::random_device rd;
251    std::mt19937 rng(rd());
252    IntTable t;
253    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
254    while (t.size() < state.range(0)) {
255      t.emplace(dist(rng));
256    }
257    IntTable t2;
258    for (auto _ : state) {
259      t2 = t;
260      benchmark::DoNotOptimize(t2);
261    }
262  }
263  BENCHMARK(BM_CopyAssign)->Range(128, 4096);
264  void BM_RangeCtor(benchmark::State& state) {
265    std::random_device rd;
266    std::mt19937 rng(rd());
267    std::uniform_int_distribution<uint64_t> dist(0, ~uint64_t{});
268    std::vector<int> values;
269    const size_t desired_size = state.range(0);
270    while (values.size() < desired_size) {
271      values.emplace_back(dist(rng));
272    }
273    for (auto unused : state) {
274      IntTable t{values.begin(), values.end()};
275      benchmark::DoNotOptimize(t);
276    }
277  }
278  BENCHMARK(BM_RangeCtor)->Range(128, 65536);
279  void BM_NoOpReserveIntTable(benchmark::State& state) {
280    IntTable t;
281    t.reserve(100000);
282    for (auto _ : state) {
283      benchmark::DoNotOptimize(t);
284      t.reserve(100000);
285    }
286  }
287  BENCHMARK(BM_NoOpReserveIntTable);
288  void BM_NoOpReserveStringTable(benchmark::State& state) {
289    StringTable t;
290    t.reserve(100000);
291    for (auto _ : state) {
292      benchmark::DoNotOptimize(t);
293      t.reserve(100000);
294    }
295  }
296  BENCHMARK(BM_NoOpReserveStringTable);
297  void BM_ReserveIntTable(benchmark::State& state) {
298    int reserve_size = state.range(0);
299    for (auto _ : state) {
300      state.PauseTiming();
301      IntTable t;
302      state.ResumeTiming();
303      benchmark::DoNotOptimize(t);
304      t.reserve(reserve_size);
305    }
306  }
307  BENCHMARK(BM_ReserveIntTable)->Range(128, 4096);
308  void BM_ReserveStringTable(benchmark::State& state) {
309    int reserve_size = state.range(0);
310    for (auto _ : state) {
311      state.PauseTiming();
312      StringTable t;
313      state.ResumeTiming();
314      benchmark::DoNotOptimize(t);
315      t.reserve(reserve_size);
316    }
317  }
318  BENCHMARK(BM_ReserveStringTable)->Range(128, 4096);
319  template <typename CtrlIter>
320  void Iota(CtrlIter begin, CtrlIter end, int value) {
321    for (; begin != end; ++begin, ++value) {
322      *begin = static_cast<ctrl_t>(value);
323    }
324  }
325  void BM_Group_Match(benchmark::State& state) {
326    std::array<ctrl_t, Group::kWidth> group;
327    Iota(group.begin(), group.end(), -4);
328    Group g{group.data()};
329    h2_t h = 1;
330    for (auto _ : state) {
331      ::benchmark::DoNotOptimize(h);
332      ::benchmark::DoNotOptimize(g);
333      ::benchmark::DoNotOptimize(g.Match(h));
334    }
335  }
336  BENCHMARK(BM_Group_Match);
337  void BM_Group_MaskEmpty(benchmark::State& state) {
338    std::array<ctrl_t, Group::kWidth> group;
339    Iota(group.begin(), group.end(), -4);
340    Group g{group.data()};
341    for (auto _ : state) {
342      ::benchmark::DoNotOptimize(g);
343      ::benchmark::DoNotOptimize(g.MaskEmpty());
344    }
345  }
346  BENCHMARK(BM_Group_MaskEmpty);
347  void BM_Group_MaskEmptyOrDeleted(benchmark::State& state) {
348    std::array<ctrl_t, Group::kWidth> group;
349    Iota(group.begin(), group.end(), -4);
350    Group g{group.data()};
351    for (auto _ : state) {
352      ::benchmark::DoNotOptimize(g);
353      ::benchmark::DoNotOptimize(g.MaskEmptyOrDeleted());
354    }
355  }
356  BENCHMARK(BM_Group_MaskEmptyOrDeleted);
357  void BM_Group_CountLeadingEmptyOrDeleted(benchmark::State& state) {
358    std::array<ctrl_t, Group::kWidth> group;
359    Iota(group.begin(), group.end(), -2);
360    Group g{group.data()};
361    for (auto _ : state) {
362      ::benchmark::DoNotOptimize(g);
363      ::benchmark::DoNotOptimize(g.CountLeadingEmptyOrDeleted());
364    }
365  }
366  BENCHMARK(BM_Group_CountLeadingEmptyOrDeleted);
367  void BM_Group_MatchFirstEmptyOrDeleted(benchmark::State& state) {
368    std::array<ctrl_t, Group::kWidth> group;
369    Iota(group.begin(), group.end(), -2);
370    Group g{group.data()};
371    for (auto _ : state) {
372      ::benchmark::DoNotOptimize(g);
373      ::benchmark::DoNotOptimize(g.MaskEmptyOrDeleted().LowestBitSet());
374    }
375  }
376  BENCHMARK(BM_Group_MatchFirstEmptyOrDeleted);
377  void BM_DropDeletes(benchmark::State& state) {
378    constexpr size_t capacity = (1 << 20) - 1;
379    std::vector<ctrl_t> ctrl(capacity + 1 + Group::kWidth);
380    ctrl[capacity] = ctrl_t::kSentinel;
381    std::vector<ctrl_t> pattern = {ctrl_t::kEmpty,   static_cast<ctrl_t>(2),
382                                   ctrl_t::kDeleted, static_cast<ctrl_t>(2),
383                                   ctrl_t::kEmpty,   static_cast<ctrl_t>(1),
384                                   ctrl_t::kDeleted};
385    for (size_t i = 0; i != capacity; ++i) {
386      ctrl[i] = pattern[i % pattern.size()];
387    }
388    while (state.KeepRunning()) {
389      state.PauseTiming();
390      std::vector<ctrl_t> ctrl_copy = ctrl;
391      state.ResumeTiming();
392      ConvertDeletedToEmptyAndFullToDeleted(ctrl_copy.data(), capacity);
393      ::benchmark::DoNotOptimize(ctrl_copy[capacity]);
394    }
395  }
396  BENCHMARK(BM_DropDeletes);
397  void BM_Resize(benchmark::State& state) {
398    constexpr int kElements = 64;
399    const int kCapacity = kElements * 2;
400    IntTable table;
401    for (int i = 0; i < kElements; i++) {
402      table.insert(i);
403    }
404    for (auto unused : state) {
405      table.rehash(0);
406      table.rehash(kCapacity);
407    }
408  }
409  BENCHMARK(BM_Resize);
410  }  
411  }  
412  ABSL_NAMESPACE_END
413  }  
414  auto CodegenAbslRawHashSetInt64Find(absl::container_internal::IntTable* table,
415                                      int64_t key) -> decltype(table->find(key)) {
416    return table->find(key);
417  }
418  bool CodegenAbslRawHashSetInt64FindNeEnd(
419      absl::container_internal::IntTable* table, int64_t key) {
420    return table->find(key) != table->end();
421  }
422  bool CodegenAbslRawHashSetStringFindNeEnd(
423      absl::container_internal::StringTable* table, const std::string& key) {
424    return table->find(key) != table->end();
425  }
426  auto CodegenAbslRawHashSetInt64Insert(absl::container_internal::IntTable* table,
427                                        int64_t key)
428      -> decltype(table->insert(key)) {
429    return table->insert(key);
430  }
431  bool CodegenAbslRawHashSetInt64Contains(
432      absl::container_internal::IntTable* table, int64_t key) {
433    return table->contains(key);
434  }
435  void CodegenAbslRawHashSetInt64Iterate(
436      absl::container_internal::IntTable* table) {
437    for (auto x : *table) benchmark::DoNotOptimize(x);
438  }
439  int odr =
440      (::benchmark::DoNotOptimize(std::make_tuple(
441           &CodegenAbslRawHashSetInt64Find, &CodegenAbslRawHashSetInt64FindNeEnd,
442           &CodegenAbslRawHashSetStringFindNeEnd,
443           &CodegenAbslRawHashSetInt64Insert, &CodegenAbslRawHashSetInt64Contains,
444           &CodegenAbslRawHashSetInt64Iterate)),
445       1);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>118    std::mt19937 rng(rd());
119    string_generator gen{12};
120    StringTable t;
121    std::deque<std::string> keys;
</pre></code></div>
                <div class="column column_space"><pre><code>118    std::mt19937 rng(rd());
119    string_generator gen{12};
120    StringTable t;
121    std::deque<std::string> keys;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    