
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_HPP
3  #include <vector>
4  namespace boost{
5  #ifdef BOOST_REGEX_MSVC
6  #pragma warning(push)
7  #pragma warning(disable : 4251)
8  #if BOOST_REGEX_MSVC < 1700
9  #     pragma warning(disable : 4231)
10  #endif
11  #if BOOST_REGEX_MSVC < 1600
12  #pragma warning(disable : 4660)
13  #endif
14  #if BOOST_REGEX_MSVC < 1910
15  #pragma warning(disable:4800)
16  #endif
17  #endif
18  namespace BOOST_REGEX_DETAIL_NS{
19  template <class charT, class traits>
20  class basic_regex_parser;
21  template <class I>
22  void bubble_down_one(I first, I last)
23  {
24     if(first != last)
25     {
26        I next = last - 1;
27        while((next != first) && (*next < *(next-1)))
28        {
29           (next-1)->swap(*next);
30           --next;
31        }
32     }
33  }
34  static const int hash_value_mask = 1 << (std::numeric_limits<int>::digits - 1);
35  template <class Iterator>
36  inline int hash_value_from_capture_name(Iterator i, Iterator j)
37  {
38     std::size_t r = 0;
39     while (i != j)
40     {
41        r ^= *i + 0x9e3779b9 + (r << 6) + (r >> 2);
42        ++i;
43     }
44     r %= ((std::numeric_limits<int>::max)());
45     return static_cast<int>(r) | hash_value_mask;
46  }
47  class named_subexpressions
48  {
49  public:
50     struct name
51     {
52        template <class charT>
53        name(const charT* i, const charT* j, int idx)
54           : index(idx) 
55        { 
56           hash = hash_value_from_capture_name(i, j); 
57        }
58        name(int h, int idx)
59           : index(idx), hash(h)
60        { 
61        }
62        int index;
63        int hash;
64        bool operator < (const name& other)const
65        {
66           return hash < other.hash;
67        }
68        bool operator == (const name& other)const
69        {
70           return hash == other.hash; 
71        }
72        void swap(name& other)
73        {
74           std::swap(index, other.index);
75           std::swap(hash, other.hash);
76        }
77     };
78     typedef std::vector<name>::const_iterator const_iterator;
79     typedef std::pair<const_iterator, const_iterator> range_type;
80     named_subexpressions(){}
81     template <class charT>
82     void set_name(const charT* i, const charT* j, int index)
83     {
84        m_sub_names.push_back(name(i, j, index));
85        bubble_down_one(m_sub_names.begin(), m_sub_names.end());
86     }
87     template <class charT>
88     int get_id(const charT* i, const charT* j)const
89     {
90        name t(i, j, 0);
91        typename std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
92        if((pos != m_sub_names.end()) && (*pos == t))
93        {
94           return pos->index;
95        }
96        return -1;
97     }
98     template <class charT>
99     range_type equal_range(const charT* i, const charT* j)const
100     {
101        name t(i, j, 0);
102        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
103     }
104     int get_id(int h)const
105     {
106        name t(h, 0);
107        std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
108        if((pos != m_sub_names.end()) && (*pos == t))
109        {
110           return pos->index;
111        }
112        return -1;
113     }
114     range_type equal_range(int h)const
115     {
116        name t(h, 0);
117        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
118     }
119  private:
120     std::vector<name> m_sub_names;
121  };
122  template <class charT, class traits>
123  struct regex_data : public named_subexpressions
124  {
125     typedef regex_constants::syntax_option_type   flag_type;
126     typedef std::size_t                           size_type;  
127     regex_data(const ::std::shared_ptr<
128        ::boost::regex_traits_wrapper<traits> >& t) 
129        : m_ptraits(t), m_flags(0), m_status(0), m_expression(0), m_expression_len(0),
130           m_mark_count(0), m_first_state(0), m_restart_type(0),
131           m_startmap{ 0 },
132           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
133     regex_data() 
134        : m_ptraits(new ::boost::regex_traits_wrapper<traits>()), m_flags(0), m_status(0), m_expression(0), m_expression_len(0), 
135           m_mark_count(0), m_first_state(0), m_restart_type(0), 
136        m_startmap{ 0 },
137           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
138     ::std::shared_ptr<
139        ::boost::regex_traits_wrapper<traits>
140        >                        m_ptraits;                 
141     flag_type                   m_flags;                   
142     int                         m_status;                  
143     const charT*                m_expression;              
144     std::ptrdiff_t              m_expression_len;          
145     size_type                   m_mark_count;              
146     BOOST_REGEX_DETAIL_NS::re_syntax_base*  m_first_state;             
147     unsigned                    m_restart_type;            
148     unsigned char               m_startmap[1 << CHAR_BIT]; 
149     unsigned int                m_can_be_null;             
150     BOOST_REGEX_DETAIL_NS::raw_storage      m_data;                    
151     typename traits::char_class_type    m_word_mask;       
152     std::vector<
153        std::pair<
154        std::size_t, std::size_t> > m_subs;                 
155     bool                        m_has_recursions;          
156     bool                        m_disable_match_any;       
157  };
<span onclick='openModal()' class='match'>158  template <class charT, class traits>
159  class basic_regex_implementation
160     : public regex_data<charT, traits>
161  {
162  public:
163     typedef regex_constants::syntax_option_type   flag_type;
</span>164     typedef std::ptrdiff_t                        difference_type;
165     typedef std::size_t                           size_type; 
166     typedef typename traits::locale_type          locale_type;
167     typedef const charT*                          const_iterator;
168     basic_regex_implementation(){}
169     basic_regex_implementation(const ::std::shared_ptr<
170        ::boost::regex_traits_wrapper<traits> >& t)
171        : regex_data<charT, traits>(t) {}
172     void assign(const charT* arg_first,
173                            const charT* arg_last,
174                            flag_type f)
175     {
176        regex_data<charT, traits>* pdat = this;
177        basic_regex_parser<charT, traits> parser(pdat);
178        parser.parse(arg_first, arg_last, f);
179     }
180     locale_type  imbue(locale_type l)
181     { 
182        return this->m_ptraits->imbue(l); 
183     }
184     locale_type  getloc()const
185     { 
186        return this->m_ptraits->getloc(); 
187     }
188     std::basic_string<charT>  str()const
189     {
190        std::basic_string<charT> result;
191        if(this->m_status == 0)
192           result = std::basic_string<charT>(this->m_expression, this->m_expression_len);
193        return result;
194     }
195     const_iterator  expression()const
196     {
197        return this->m_expression;
198     }
199     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
200     {
201        const std::pair<std::size_t, std::size_t>& pi = this->m_subs.at(n);
202        std::pair<const_iterator, const_iterator> p(expression() + pi.first, expression() + pi.second);
203        return p;
204     }
205     const_iterator  begin()const
206     { 
207        return (this->m_status ? 0 : this->m_expression); 
208     }
209     const_iterator  end()const
210     { 
211        return (this->m_status ? 0 : this->m_expression + this->m_expression_len); 
212     }
213     flag_type  flags()const
214     {
215        return this->m_flags;
216     }
217     size_type  size()const
218     {
219        return this->m_expression_len;
220     }
221     int  status()const
222     {
223        return this->m_status;
224     }
225     size_type  mark_count()const
226     {
227        return this->m_mark_count - 1;
228     }
229     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
230     {
231        return this->m_first_state;
232     }
233     unsigned get_restart_type()const
234     {
235        return this->m_restart_type;
236     }
237     const unsigned char* get_map()const
238     {
239        return this->m_startmap;
240     }
241     const ::boost::regex_traits_wrapper<traits>& get_traits()const
242     {
243        return *(this->m_ptraits);
244     }
245     bool can_be_null()const
246     {
247        return this->m_can_be_null;
248     }
249     const regex_data<charT, traits>& get_data()const
250     {
251        basic_regex_implementation<charT, traits> const* p = this;
252        return *static_cast<const regex_data<charT, traits>*>(p);
253     }
254  };
255  } 
256  #ifdef BOOST_REGEX_NO_FWD
257  template <class charT, class traits = regex_traits<charT> >
258  #else
259  template <class charT, class traits >
260  #endif
261  class basic_regex : public regbase
262  {
263  public:
264     typedef std::size_t                           traits_size_type;
265     typedef typename traits::string_type          traits_string_type;
266     typedef charT                                 char_type;
267     typedef traits                                traits_type;
268     typedef charT                                 value_type;
269     typedef charT&                                reference;
270     typedef const charT&                          const_reference;
271     typedef const charT*                          const_iterator;
272     typedef const_iterator                        iterator;
273     typedef std::ptrdiff_t                        difference_type;
274     typedef std::size_t                           size_type;   
275     typedef regex_constants::syntax_option_type   flag_type;
276     typedef typename traits::locale_type          locale_type;
277  public:
278     explicit basic_regex(){}
279     explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)
280     {
281        assign(p, f);
282     }
283     basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
284     {
285        assign(p1, p2, f);
286     }
287     basic_regex(const charT* p, size_type len, flag_type f)
288     {
289        assign(p, len, f);
290     }
291     basic_regex(const basic_regex& that)
292        : m_pimpl(that.m_pimpl) {}
293     ~basic_regex(){}
294     basic_regex&  operator=(const basic_regex& that)
295     {
296        return assign(that);
297     }
298     basic_regex&  operator=(const charT* ptr)
299     {
300        return assign(ptr);
301     }
302     basic_regex& assign(const basic_regex& that)
303     { 
304        m_pimpl = that.m_pimpl;
305        return *this; 
306     }
307     basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)
308     {
309        return assign(p, p + traits::length(p), f);
310     }
311     basic_regex& assign(const charT* p, size_type len, flag_type f)
312     {
313        return assign(p, p + len, f);
314     }
315  private:
316     basic_regex& do_assign(const charT* p1,
317                            const charT* p2,
318                            flag_type f);
319  public:
320     basic_regex& assign(const charT* p1,
321                            const charT* p2,
322                            flag_type f = regex_constants::normal)
323     {
324        return do_assign(p1, p2, f);
325     }
326     template <class ST, class SA>
327     unsigned int  set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
328     { 
329        return set_expression(p.data(), p.data() + p.size(), f); 
330     }
331     template <class ST, class SA>
332     explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
333     { 
334        assign(p, f); 
335     }
336     template <class InputIterator>
337     basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
338     {
339        typedef typename traits::string_type seq_type;
340        seq_type a(arg_first, arg_last);
341        if(!a.empty())
342           assign(static_cast<const charT*>(&*a.begin()), static_cast<const charT*>(&*a.begin() + a.size()), f);
343        else
344           assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
345     }
346     template <class ST, class SA>
347     basic_regex&  operator=(const std::basic_string<charT, ST, SA>& p)
348     {
349        return assign(p.data(), p.data() + p.size(), regex_constants::normal);
350     }
351     template <class string_traits, class A>
352     basic_regex&  assign(
353         const std::basic_string<charT, string_traits, A>& s,
354         flag_type f = regex_constants::normal)
355     {
356        return assign(s.data(), s.data() + s.size(), f);
357     }
358     template <class InputIterator>
359     basic_regex&  assign(InputIterator arg_first,
360                            InputIterator arg_last,
361                            flag_type f = regex_constants::normal)
362     {
363        typedef typename traits::string_type seq_type;
364        seq_type a(arg_first, arg_last);
365        if(a.size())
366        {
367           const charT* p1 = &*a.begin();
368           const charT* p2 = &*a.begin() + a.size();
369           return assign(p1, p2, f);
370        }
371        return assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
372     }
373     locale_type  imbue(locale_type l);
374     locale_type  getloc()const
375     { 
376        return m_pimpl.get() ? m_pimpl->getloc() : locale_type(); 
377     }
378     flag_type  getflags()const
379     { 
380        return flags();
381     }
382     flag_type  flags()const
383     { 
384        return m_pimpl.get() ? m_pimpl->flags() : 0;
385     }
386     std::basic_string<charT>  str()const
387     {
388        return m_pimpl.get() ? m_pimpl->str() : std::basic_string<charT>();
389     }
390     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
391     {
392  #ifdef BOOST_REGEX_STANDALONE
393        if (!m_pimpl.get())
394           throw std::logic_error("Can't access subexpressions in an invalid regex.");
395  #else
396        if(!m_pimpl.get())
397           boost::throw_exception(std::logic_error("Can't access subexpressions in an invalid regex."));
398  #endif
399        return m_pimpl->subexpression(n);
400     }
401     const_iterator  begin()const
402     { 
403        return (m_pimpl.get() ? m_pimpl->begin() : 0); 
404     }
405     const_iterator  end()const
406     { 
407        return (m_pimpl.get() ? m_pimpl->end() : 0); 
408     }
409     void  swap(basic_regex& that)throw()
410     {
411        m_pimpl.swap(that.m_pimpl);
412     }
413     size_type  size()const
414     { 
415        return (m_pimpl.get() ? m_pimpl->size() : 0); 
416     }
417     size_type  max_size()const
418     { 
419        return UINT_MAX; 
420     }
421     bool  empty()const
422     { 
423        return (m_pimpl.get() ? 0 != m_pimpl->status() : true); 
424     }
425     size_type  mark_count()const 
426     { 
427        return (m_pimpl.get() ? m_pimpl->mark_count() : 0); 
428     }
429     int status()const
430     {
431        return (m_pimpl.get() ? m_pimpl->status() : regex_constants::error_empty);
432     }
433     int  compare(const basic_regex& that) const
434     {
435        if(m_pimpl.get() == that.m_pimpl.get())
436           return 0;
437        if(!m_pimpl.get())
438           return -1;
439        if(!that.m_pimpl.get())
440           return 1;
441        if(status() != that.status())
442           return status() - that.status();
443        if(flags() != that.flags())
444           return flags() - that.flags();
445        return str().compare(that.str());
446     }
447     bool  operator==(const basic_regex& e)const
448     { 
449        return compare(e) == 0; 
450     }
451     bool  operator != (const basic_regex& e)const
452     { 
453        return compare(e) != 0; 
454     }
455     bool  operator<(const basic_regex& e)const
456     { 
457        return compare(e) < 0; 
458     }
459     bool  operator>(const basic_regex& e)const
460     { 
461        return compare(e) > 0; 
462     }
463     bool  operator<=(const basic_regex& e)const
464     { 
465        return compare(e) <= 0; 
466     }
467     bool  operator>=(const basic_regex& e)const
468     { 
469        return compare(e) >= 0; 
470     }
471     const charT*  expression()const 
472     { 
473        return (m_pimpl.get() && !m_pimpl->status() ? m_pimpl->expression() : 0); 
474     }
475     unsigned int  set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
476     {
477        assign(p1, p2, f | regex_constants::no_except);
478        return status();
479     }
480     unsigned int  set_expression(const charT* p, flag_type f = regex_constants::normal) 
481     { 
482        assign(p, f | regex_constants::no_except); 
483        return status();
484     }
485     unsigned int  error_code()const
486     {
487        return status();
488     }
489     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
490     {
491        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
492        return m_pimpl->get_first_state();
493     }
494     unsigned get_restart_type()const
495     {
496        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
497        return m_pimpl->get_restart_type();
498     }
499     const unsigned char* get_map()const
500     {
501        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
502        return m_pimpl->get_map();
503     }
504     const ::boost::regex_traits_wrapper<traits>& get_traits()const
505     {
506        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
507        return m_pimpl->get_traits();
508     }
509     bool can_be_null()const
510     {
511        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
512        return m_pimpl->can_be_null();
513     }
514     const BOOST_REGEX_DETAIL_NS::regex_data<charT, traits>& get_data()const
515     {
516        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
517        return m_pimpl->get_data();
518     }
519     std::shared_ptr<BOOST_REGEX_DETAIL_NS::named_subexpressions > get_named_subs()const
520     {
521        return m_pimpl;
522     }
523  private:
524     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > m_pimpl;
525  };
526  template <class charT, class traits>
527  basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,
528                          const charT* p2,
529                          flag_type f)
530  {
531     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp;
532     if(!m_pimpl.get())
533     {
534        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
535     }
536     else
537     {
538        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>(m_pimpl->m_ptraits));
539     }
540     temp->assign(p1, p2, f);
541     temp.swap(m_pimpl);
542     return *this;
543  }
544  template <class charT, class traits>
545  typename basic_regex<charT, traits>::locale_type  basic_regex<charT, traits>::imbue(locale_type l)
546  { 
547     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
548     locale_type result = temp->imbue(l);
549     temp.swap(m_pimpl);
550     return result;
551  }
552  template <class charT, class traits>
553  void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
554  {
555     e1.swap(e2);
556  }
557  template <class charT, class traits, class traits2>
558  std::basic_ostream<charT, traits>& 
559     operator << (std::basic_ostream<charT, traits>& os, 
560                  const basic_regex<charT, traits2>& e)
561  {
562     return (os << e.str());
563  }
564  #ifdef BOOST_REGEX_NO_FWD
565  template <class charT, class traits = regex_traits<charT> >
566  #else
567  template <class charT, class traits >
568  #endif
569  class reg_expression : public basic_regex<charT, traits>
570  {
571  public:
572     typedef typename basic_regex<charT, traits>::flag_type flag_type;
573     typedef typename basic_regex<charT, traits>::size_type size_type;
574     explicit reg_expression(){}
575     explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)
576        : basic_regex<charT, traits>(p, f){}
577     reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
578        : basic_regex<charT, traits>(p1, p2, f){}
579     reg_expression(const charT* p, size_type len, flag_type f)
580        : basic_regex<charT, traits>(p, len, f){}
581     reg_expression(const reg_expression& that)
582        : basic_regex<charT, traits>(that) {}
583     ~reg_expression(){}
584     reg_expression&  operator=(const reg_expression& that)
585     {
586        return this->assign(that);
587     }
588     template <class ST, class SA>
589     explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
590     : basic_regex<charT, traits>(p, f)
591     { 
592     }
593     template <class InputIterator>
594     reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
595     : basic_regex<charT, traits>(arg_first, arg_last, f)
596     {
597     }
598     template <class ST, class SA>
599     reg_expression&  operator=(const std::basic_string<charT, ST, SA>& p)
600     {
601        this->assign(p);
602        return *this;
603     }
604  };
605  #ifdef BOOST_REGEX_MSVC
606  #pragma warning (pop)
607  #endif
608  } 
609  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_BASIC_REGEX_HPP
2  #define BOOST_REGEX_V5_BASIC_REGEX_HPP
3  #include <vector>
4  namespace boost{
5  #ifdef BOOST_REGEX_MSVC
6  #pragma warning(push)
7  #pragma warning(disable : 4251)
8  #if BOOST_REGEX_MSVC < 1700
9  #     pragma warning(disable : 4231)
10  #endif
11  #if BOOST_REGEX_MSVC < 1600
12  #pragma warning(disable : 4660)
13  #endif
14  #if BOOST_REGEX_MSVC < 1910
15  #pragma warning(disable:4800)
16  #endif
17  #endif
18  namespace BOOST_REGEX_DETAIL_NS{
19  template <class charT, class traits>
20  class basic_regex_parser;
21  template <class I>
22  void bubble_down_one(I first, I last)
23  {
24     if(first != last)
25     {
26        I next = last - 1;
27        while((next != first) && (*next < *(next-1)))
28        {
29           (next-1)->swap(*next);
30           --next;
31        }
32     }
33  }
34  static const int hash_value_mask = 1 << (std::numeric_limits<int>::digits - 1);
35  template <class Iterator>
36  inline int hash_value_from_capture_name(Iterator i, Iterator j)
37  {
38     std::size_t r = 0;
39     while (i != j)
40     {
41        r ^= *i + 0x9e3779b9 + (r << 6) + (r >> 2);
42        ++i;
43     }
44     r %= ((std::numeric_limits<int>::max)());
45     return static_cast<int>(r) | hash_value_mask;
46  }
47  class named_subexpressions
48  {
49  public:
50     struct name
51     {
52        template <class charT>
53        name(const charT* i, const charT* j, int idx)
54           : index(idx) 
55        { 
56           hash = hash_value_from_capture_name(i, j); 
57        }
58        name(int h, int idx)
59           : index(idx), hash(h)
60        { 
61        }
62        int index;
63        int hash;
64        bool operator < (const name& other)const
65        {
66           return hash < other.hash;
67        }
68        bool operator == (const name& other)const
69        {
70           return hash == other.hash; 
71        }
72        void swap(name& other)
73        {
74           std::swap(index, other.index);
75           std::swap(hash, other.hash);
76        }
77     };
78     typedef std::vector<name>::const_iterator const_iterator;
79     typedef std::pair<const_iterator, const_iterator> range_type;
80     named_subexpressions(){}
81     template <class charT>
82     void set_name(const charT* i, const charT* j, int index)
83     {
84        m_sub_names.push_back(name(i, j, index));
85        bubble_down_one(m_sub_names.begin(), m_sub_names.end());
86     }
87     template <class charT>
88     int get_id(const charT* i, const charT* j)const
89     {
90        name t(i, j, 0);
91        typename std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
92        if((pos != m_sub_names.end()) && (*pos == t))
93        {
94           return pos->index;
95        }
96        return -1;
97     }
98     template <class charT>
99     range_type equal_range(const charT* i, const charT* j)const
100     {
101        name t(i, j, 0);
102        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
103     }
104     int get_id(int h)const
105     {
106        name t(h, 0);
107        std::vector<name>::const_iterator pos = std::lower_bound(m_sub_names.begin(), m_sub_names.end(), t);
108        if((pos != m_sub_names.end()) && (*pos == t))
109        {
110           return pos->index;
111        }
112        return -1;
113     }
114     range_type equal_range(int h)const
115     {
116        name t(h, 0);
117        return std::equal_range(m_sub_names.begin(), m_sub_names.end(), t);
118     }
119  private:
120     std::vector<name> m_sub_names;
121  };
122  template <class charT, class traits>
123  struct regex_data : public named_subexpressions
124  {
125     typedef regex_constants::syntax_option_type   flag_type;
126     typedef std::size_t                           size_type;  
127     regex_data(const ::std::shared_ptr<
128        ::boost::regex_traits_wrapper<traits> >& t) 
129        : m_ptraits(t), m_flags(0), m_status(0), m_expression(0), m_expression_len(0),
130           m_mark_count(0), m_first_state(0), m_restart_type(0),
131           m_startmap{ 0 },
132           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
133     regex_data() 
134        : m_ptraits(new ::boost::regex_traits_wrapper<traits>()), m_flags(0), m_status(0), m_expression(0), m_expression_len(0), 
135           m_mark_count(0), m_first_state(0), m_restart_type(0), 
136        m_startmap{ 0 },
137           m_can_be_null(0), m_word_mask(0), m_has_recursions(false), m_disable_match_any(false) {}
138     ::std::shared_ptr<
139        ::boost::regex_traits_wrapper<traits>
140        >                        m_ptraits;                 
141     flag_type                   m_flags;                   
142     int                         m_status;                  
143     const charT*                m_expression;              
144     std::ptrdiff_t              m_expression_len;          
145     size_type                   m_mark_count;              
146     BOOST_REGEX_DETAIL_NS::re_syntax_base*  m_first_state;             
147     unsigned                    m_restart_type;            
148     unsigned char               m_startmap[1 << CHAR_BIT]; 
149     unsigned int                m_can_be_null;             
150     BOOST_REGEX_DETAIL_NS::raw_storage      m_data;                    
151     typename traits::char_class_type    m_word_mask;       
152     std::vector<
153        std::pair<
154        std::size_t, std::size_t> > m_subs;                 
155     bool                        m_has_recursions;          
156     bool                        m_disable_match_any;       
157  };
<span onclick='openModal()' class='match'>158  template <class charT, class traits>
159  class basic_regex_implementation
160     : public regex_data<charT, traits>
161  {
162  public:
163     typedef regex_constants::syntax_option_type   flag_type;
</span>164     typedef std::ptrdiff_t                        difference_type;
165     typedef std::size_t                           size_type; 
166     typedef typename traits::locale_type          locale_type;
167     typedef const charT*                          const_iterator;
168     basic_regex_implementation(){}
169     basic_regex_implementation(const ::std::shared_ptr<
170        ::boost::regex_traits_wrapper<traits> >& t)
171        : regex_data<charT, traits>(t) {}
172     void assign(const charT* arg_first,
173                            const charT* arg_last,
174                            flag_type f)
175     {
176        regex_data<charT, traits>* pdat = this;
177        basic_regex_parser<charT, traits> parser(pdat);
178        parser.parse(arg_first, arg_last, f);
179     }
180     locale_type  imbue(locale_type l)
181     { 
182        return this->m_ptraits->imbue(l); 
183     }
184     locale_type  getloc()const
185     { 
186        return this->m_ptraits->getloc(); 
187     }
188     std::basic_string<charT>  str()const
189     {
190        std::basic_string<charT> result;
191        if(this->m_status == 0)
192           result = std::basic_string<charT>(this->m_expression, this->m_expression_len);
193        return result;
194     }
195     const_iterator  expression()const
196     {
197        return this->m_expression;
198     }
199     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
200     {
201        const std::pair<std::size_t, std::size_t>& pi = this->m_subs.at(n);
202        std::pair<const_iterator, const_iterator> p(expression() + pi.first, expression() + pi.second);
203        return p;
204     }
205     const_iterator  begin()const
206     { 
207        return (this->m_status ? 0 : this->m_expression); 
208     }
209     const_iterator  end()const
210     { 
211        return (this->m_status ? 0 : this->m_expression + this->m_expression_len); 
212     }
213     flag_type  flags()const
214     {
215        return this->m_flags;
216     }
217     size_type  size()const
218     {
219        return this->m_expression_len;
220     }
221     int  status()const
222     {
223        return this->m_status;
224     }
225     size_type  mark_count()const
226     {
227        return this->m_mark_count - 1;
228     }
229     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
230     {
231        return this->m_first_state;
232     }
233     unsigned get_restart_type()const
234     {
235        return this->m_restart_type;
236     }
237     const unsigned char* get_map()const
238     {
239        return this->m_startmap;
240     }
241     const ::boost::regex_traits_wrapper<traits>& get_traits()const
242     {
243        return *(this->m_ptraits);
244     }
245     bool can_be_null()const
246     {
247        return this->m_can_be_null;
248     }
249     const regex_data<charT, traits>& get_data()const
250     {
251        basic_regex_implementation<charT, traits> const* p = this;
252        return *static_cast<const regex_data<charT, traits>*>(p);
253     }
254  };
255  } 
256  #ifdef BOOST_REGEX_NO_FWD
257  template <class charT, class traits = regex_traits<charT> >
258  #else
259  template <class charT, class traits >
260  #endif
261  class basic_regex : public regbase
262  {
263  public:
264     typedef std::size_t                           traits_size_type;
265     typedef typename traits::string_type          traits_string_type;
266     typedef charT                                 char_type;
267     typedef traits                                traits_type;
268     typedef charT                                 value_type;
269     typedef charT&                                reference;
270     typedef const charT&                          const_reference;
271     typedef const charT*                          const_iterator;
272     typedef const_iterator                        iterator;
273     typedef std::ptrdiff_t                        difference_type;
274     typedef std::size_t                           size_type;   
275     typedef regex_constants::syntax_option_type   flag_type;
276     typedef typename traits::locale_type          locale_type;
277  public:
278     explicit basic_regex(){}
279     explicit basic_regex(const charT* p, flag_type f = regex_constants::normal)
280     {
281        assign(p, f);
282     }
283     basic_regex(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
284     {
285        assign(p1, p2, f);
286     }
287     basic_regex(const charT* p, size_type len, flag_type f)
288     {
289        assign(p, len, f);
290     }
291     basic_regex(const basic_regex& that)
292        : m_pimpl(that.m_pimpl) {}
293     ~basic_regex(){}
294     basic_regex&  operator=(const basic_regex& that)
295     {
296        return assign(that);
297     }
298     basic_regex&  operator=(const charT* ptr)
299     {
300        return assign(ptr);
301     }
302     basic_regex& assign(const basic_regex& that)
303     { 
304        m_pimpl = that.m_pimpl;
305        return *this; 
306     }
307     basic_regex& assign(const charT* p, flag_type f = regex_constants::normal)
308     {
309        return assign(p, p + traits::length(p), f);
310     }
311     basic_regex& assign(const charT* p, size_type len, flag_type f)
312     {
313        return assign(p, p + len, f);
314     }
315  private:
316     basic_regex& do_assign(const charT* p1,
317                            const charT* p2,
318                            flag_type f);
319  public:
320     basic_regex& assign(const charT* p1,
321                            const charT* p2,
322                            flag_type f = regex_constants::normal)
323     {
324        return do_assign(p1, p2, f);
325     }
326     template <class ST, class SA>
327     unsigned int  set_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
328     { 
329        return set_expression(p.data(), p.data() + p.size(), f); 
330     }
331     template <class ST, class SA>
332     explicit basic_regex(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
333     { 
334        assign(p, f); 
335     }
336     template <class InputIterator>
337     basic_regex(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
338     {
339        typedef typename traits::string_type seq_type;
340        seq_type a(arg_first, arg_last);
341        if(!a.empty())
342           assign(static_cast<const charT*>(&*a.begin()), static_cast<const charT*>(&*a.begin() + a.size()), f);
343        else
344           assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
345     }
346     template <class ST, class SA>
347     basic_regex&  operator=(const std::basic_string<charT, ST, SA>& p)
348     {
349        return assign(p.data(), p.data() + p.size(), regex_constants::normal);
350     }
351     template <class string_traits, class A>
352     basic_regex&  assign(
353         const std::basic_string<charT, string_traits, A>& s,
354         flag_type f = regex_constants::normal)
355     {
356        return assign(s.data(), s.data() + s.size(), f);
357     }
358     template <class InputIterator>
359     basic_regex&  assign(InputIterator arg_first,
360                            InputIterator arg_last,
361                            flag_type f = regex_constants::normal)
362     {
363        typedef typename traits::string_type seq_type;
364        seq_type a(arg_first, arg_last);
365        if(a.size())
366        {
367           const charT* p1 = &*a.begin();
368           const charT* p2 = &*a.begin() + a.size();
369           return assign(p1, p2, f);
370        }
371        return assign(static_cast<const charT*>(0), static_cast<const charT*>(0), f);
372     }
373     locale_type  imbue(locale_type l);
374     locale_type  getloc()const
375     { 
376        return m_pimpl.get() ? m_pimpl->getloc() : locale_type(); 
377     }
378     flag_type  getflags()const
379     { 
380        return flags();
381     }
382     flag_type  flags()const
383     { 
384        return m_pimpl.get() ? m_pimpl->flags() : 0;
385     }
386     std::basic_string<charT>  str()const
387     {
388        return m_pimpl.get() ? m_pimpl->str() : std::basic_string<charT>();
389     }
390     std::pair<const_iterator, const_iterator>  subexpression(std::size_t n)const
391     {
392  #ifdef BOOST_REGEX_STANDALONE
393        if (!m_pimpl.get())
394           throw std::logic_error("Can't access subexpressions in an invalid regex.");
395  #else
396        if(!m_pimpl.get())
397           boost::throw_exception(std::logic_error("Can't access subexpressions in an invalid regex."));
398  #endif
399        return m_pimpl->subexpression(n);
400     }
401     const_iterator  begin()const
402     { 
403        return (m_pimpl.get() ? m_pimpl->begin() : 0); 
404     }
405     const_iterator  end()const
406     { 
407        return (m_pimpl.get() ? m_pimpl->end() : 0); 
408     }
409     void  swap(basic_regex& that)throw()
410     {
411        m_pimpl.swap(that.m_pimpl);
412     }
413     size_type  size()const
414     { 
415        return (m_pimpl.get() ? m_pimpl->size() : 0); 
416     }
417     size_type  max_size()const
418     { 
419        return UINT_MAX; 
420     }
421     bool  empty()const
422     { 
423        return (m_pimpl.get() ? 0 != m_pimpl->status() : true); 
424     }
425     size_type  mark_count()const 
426     { 
427        return (m_pimpl.get() ? m_pimpl->mark_count() : 0); 
428     }
429     int status()const
430     {
431        return (m_pimpl.get() ? m_pimpl->status() : regex_constants::error_empty);
432     }
433     int  compare(const basic_regex& that) const
434     {
435        if(m_pimpl.get() == that.m_pimpl.get())
436           return 0;
437        if(!m_pimpl.get())
438           return -1;
439        if(!that.m_pimpl.get())
440           return 1;
441        if(status() != that.status())
442           return status() - that.status();
443        if(flags() != that.flags())
444           return flags() - that.flags();
445        return str().compare(that.str());
446     }
447     bool  operator==(const basic_regex& e)const
448     { 
449        return compare(e) == 0; 
450     }
451     bool  operator != (const basic_regex& e)const
452     { 
453        return compare(e) != 0; 
454     }
455     bool  operator<(const basic_regex& e)const
456     { 
457        return compare(e) < 0; 
458     }
459     bool  operator>(const basic_regex& e)const
460     { 
461        return compare(e) > 0; 
462     }
463     bool  operator<=(const basic_regex& e)const
464     { 
465        return compare(e) <= 0; 
466     }
467     bool  operator>=(const basic_regex& e)const
468     { 
469        return compare(e) >= 0; 
470     }
471     const charT*  expression()const 
472     { 
473        return (m_pimpl.get() && !m_pimpl->status() ? m_pimpl->expression() : 0); 
474     }
475     unsigned int  set_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
476     {
477        assign(p1, p2, f | regex_constants::no_except);
478        return status();
479     }
480     unsigned int  set_expression(const charT* p, flag_type f = regex_constants::normal) 
481     { 
482        assign(p, f | regex_constants::no_except); 
483        return status();
484     }
485     unsigned int  error_code()const
486     {
487        return status();
488     }
489     const BOOST_REGEX_DETAIL_NS::re_syntax_base* get_first_state()const
490     {
491        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
492        return m_pimpl->get_first_state();
493     }
494     unsigned get_restart_type()const
495     {
496        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
497        return m_pimpl->get_restart_type();
498     }
499     const unsigned char* get_map()const
500     {
501        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
502        return m_pimpl->get_map();
503     }
504     const ::boost::regex_traits_wrapper<traits>& get_traits()const
505     {
506        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
507        return m_pimpl->get_traits();
508     }
509     bool can_be_null()const
510     {
511        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
512        return m_pimpl->can_be_null();
513     }
514     const BOOST_REGEX_DETAIL_NS::regex_data<charT, traits>& get_data()const
515     {
516        BOOST_REGEX_ASSERT(0 != m_pimpl.get());
517        return m_pimpl->get_data();
518     }
519     std::shared_ptr<BOOST_REGEX_DETAIL_NS::named_subexpressions > get_named_subs()const
520     {
521        return m_pimpl;
522     }
523  private:
524     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > m_pimpl;
525  };
526  template <class charT, class traits>
527  basic_regex<charT, traits>& basic_regex<charT, traits>::do_assign(const charT* p1,
528                          const charT* p2,
529                          flag_type f)
530  {
531     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp;
532     if(!m_pimpl.get())
533     {
534        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
535     }
536     else
537     {
538        temp = std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> >(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>(m_pimpl->m_ptraits));
539     }
540     temp->assign(p1, p2, f);
541     temp.swap(m_pimpl);
542     return *this;
543  }
544  template <class charT, class traits>
545  typename basic_regex<charT, traits>::locale_type  basic_regex<charT, traits>::imbue(locale_type l)
546  { 
547     std::shared_ptr<BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits> > temp(new BOOST_REGEX_DETAIL_NS::basic_regex_implementation<charT, traits>());
548     locale_type result = temp->imbue(l);
549     temp.swap(m_pimpl);
550     return result;
551  }
552  template <class charT, class traits>
553  void swap(basic_regex<charT, traits>& e1, basic_regex<charT, traits>& e2)
554  {
555     e1.swap(e2);
556  }
557  template <class charT, class traits, class traits2>
558  std::basic_ostream<charT, traits>& 
559     operator << (std::basic_ostream<charT, traits>& os, 
560                  const basic_regex<charT, traits2>& e)
561  {
562     return (os << e.str());
563  }
564  #ifdef BOOST_REGEX_NO_FWD
565  template <class charT, class traits = regex_traits<charT> >
566  #else
567  template <class charT, class traits >
568  #endif
569  class reg_expression : public basic_regex<charT, traits>
570  {
571  public:
572     typedef typename basic_regex<charT, traits>::flag_type flag_type;
573     typedef typename basic_regex<charT, traits>::size_type size_type;
574     explicit reg_expression(){}
575     explicit reg_expression(const charT* p, flag_type f = regex_constants::normal)
576        : basic_regex<charT, traits>(p, f){}
577     reg_expression(const charT* p1, const charT* p2, flag_type f = regex_constants::normal)
578        : basic_regex<charT, traits>(p1, p2, f){}
579     reg_expression(const charT* p, size_type len, flag_type f)
580        : basic_regex<charT, traits>(p, len, f){}
581     reg_expression(const reg_expression& that)
582        : basic_regex<charT, traits>(that) {}
583     ~reg_expression(){}
584     reg_expression&  operator=(const reg_expression& that)
585     {
586        return this->assign(that);
587     }
588     template <class ST, class SA>
589     explicit reg_expression(const std::basic_string<charT, ST, SA>& p, flag_type f = regex_constants::normal)
590     : basic_regex<charT, traits>(p, f)
591     { 
592     }
593     template <class InputIterator>
594     reg_expression(InputIterator arg_first, InputIterator arg_last, flag_type f = regex_constants::normal)
595     : basic_regex<charT, traits>(arg_first, arg_last, f)
596     {
597     }
598     template <class ST, class SA>
599     reg_expression&  operator=(const std::basic_string<charT, ST, SA>& p)
600     {
601        this->assign(p);
602        return *this;
603     }
604  };
605  #ifdef BOOST_REGEX_MSVC
606  #pragma warning (pop)
607  #endif
608  } 
609  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-basic_regex.hpp</div>
                </div>
                <div class="column column_space"><pre><code>158  template <class charT, class traits>
159  class basic_regex_implementation
160     : public regex_data<charT, traits>
161  {
162  public:
163     typedef regex_constants::syntax_option_type   flag_type;
</pre></code></div>
                <div class="column column_space"><pre><code>158  template <class charT, class traits>
159  class basic_regex_implementation
160     : public regex_data<charT, traits>
161  {
162  public:
163     typedef regex_constants::syntax_option_type   flag_type;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    