
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.2521246458923505%, Tokens: 9</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</h3>
            <pre><code>1  #include "Notepad_plus_Window.h"
2  #include "Processus.h"
3  #include "Win32Exception.h"	
4  #include "MiniDumper.h"			
5  #include "verifySignedfile.h"
6  #include "NppDarkMode.h"
7  #include <memory>
8  typedef std::vector<generic_string> ParamVector;
9  namespace
10  {
11  void allowPrivilegeMessages(const Notepad_plus_Window& notepad_plus_plus, winVer winVer)
12  {
13  	#ifndef MSGFLT_ADD
14  	const DWORD MSGFLT_ADD = 1;
15  	#endif
16  	#ifndef MSGFLT_ALLOW
17  	const DWORD MSGFLT_ALLOW = 1;
18  	#endif
19  	if (winVer >= WV_VISTA || winVer == WV_UNKNOWN)
20  	{
21  		HMODULE hDll = GetModuleHandle(TEXT("user32.dll"));
22  		if (hDll)
23  		{
24  			if (winVer == WV_VISTA)
25  			{
26  				typedef BOOL (WINAPI *MESSAGEFILTERFUNC)(UINT message,DWORD dwFlag);
27  				MESSAGEFILTERFUNC func = (MESSAGEFILTERFUNC)::GetProcAddress( hDll, "ChangeWindowMessageFilter" );
28  				if (func)
29  				{
30  					func(WM_COPYDATA, MSGFLT_ADD);
31  					func(NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ADD);
32  				}
33  			}
34  			else
35  			{
36  				typedef BOOL (WINAPI *MESSAGEFILTERFUNCEX)(HWND hWnd,UINT message,DWORD action,VOID* pChangeFilterStruct);
37  				MESSAGEFILTERFUNCEX funcEx = (MESSAGEFILTERFUNCEX)::GetProcAddress( hDll, "ChangeWindowMessageFilterEx" );
38  				if (funcEx)
39  				{
40  					funcEx(notepad_plus_plus.getHSelf(), WM_COPYDATA, MSGFLT_ALLOW, NULL);
41  					funcEx(notepad_plus_plus.getHSelf(), NPPM_INTERNAL_RESTOREFROMTRAY, MSGFLT_ALLOW, NULL);
42  				}
43  			}
44  		}
45  	}
46  }
47  void parseCommandLine(const TCHAR* commandLine, ParamVector& paramVector)
48  {
49  	if (!commandLine)
50  		return;
51  	TCHAR* cmdLine = new TCHAR[lstrlen(commandLine) + 1];
52  	lstrcpy(cmdLine, commandLine);
53  	TCHAR* cmdLinePtr = cmdLine;
54  	bool isInFile = false;
55  	bool isStringInArg = false;
56  	bool isInWhiteSpace = true;
57  	int zArg = 0; 
58  	bool shouldBeTerminated = false; 
59  	size_t commandLength = lstrlen(cmdLinePtr);
60  	std::vector<TCHAR *> args;
61  	for (size_t i = 0; i < commandLength && !shouldBeTerminated; ++i)
62  	{
63  		switch (cmdLinePtr[i])
64  		{
65  			case '\"': 
66  			{
67  				if (!isStringInArg && i > 0 && cmdLinePtr[i-1] == '=')
68  				{
69  					isStringInArg = true;
70  				}
71  				else if (isStringInArg)
72  				{
73  					isStringInArg = false;
74  				}
75  				else if (!isInFile)	
76  				{
77  					args.push_back(cmdLinePtr + i + 1);	
78  					isInFile = true;
79  					cmdLinePtr[i] = 0;
80  					if (zArg == 1)
81  					{
82  						++zArg; 
83  					}
84  				}
85  				else if (isInFile)
86  				{
87  					isInFile = false;
88  					cmdLinePtr[i] = 0;
89  				}
90  				isInWhiteSpace = false;
91  			}
92  			break;
93  			case '\t': 
94  			case ' ':
95  			{
96  				isInWhiteSpace = true;
97  				if (!isInFile && !isStringInArg)
98  				{
99  					cmdLinePtr[i] = 0;		
100  					size_t argsLen = args.size();
101  					if (argsLen > 0 && lstrcmp(args[argsLen-1], L"-z") == 0)
102  						++zArg; 
103  				}
104  			}
105  			break;
106  			default: 
107  			{
108  				if (!isInFile && !isStringInArg && isInWhiteSpace)
109  				{
110  					args.push_back(cmdLinePtr + i);	
111  					if (zArg == 2)
112  					{
113  						shouldBeTerminated = true; 
114  					}
115  					isInWhiteSpace = false;
116  				}
117  			}
118  		}
119  	}
120  	paramVector.assign(args.begin(), args.end());
121  	delete[] cmdLine;
122  }
123  void convertParamsToNotepadStyle(ParamVector& params)
124  {
125  	for (auto it = params.begin(); it != params.end(); ++it)
126  	{
127  		if (lstrcmp(it->c_str(), TEXT("/p")) == 0 || lstrcmp(it->c_str(), TEXT("/P")) == 0)
128  		{
129  			it->assign(TEXT("-quickPrint"));
130  		}
131  	}
132  }
133  bool isInList(const TCHAR *token2Find, ParamVector& params, bool eraseArg = true)
134  {
135  	for (auto it = params.begin(); it != params.end(); ++it)
136  	{
137  		if (lstrcmp(token2Find, it->c_str()) == 0)
138  		{
139  			if (eraseArg) params.erase(it);
140  			return true;
141  		}
142  	}
143  	return false;
144  }
145  bool getParamVal(TCHAR c, ParamVector & params, generic_string & value)
146  {
147  	value = TEXT("");
148  	size_t nbItems = params.size();
149  	for (size_t i = 0; i < nbItems; ++i)
150  	{
151  		const TCHAR * token = params.at(i).c_str();
152  		if (token[0] == '-' && lstrlen(token) >= 2 && token[1] == c) 
153  		{
154  			value = (token+2);
155  			params.erase(params.begin() + i);
156  			return true;
157  		}
158  	}
159  	return false;
160  }
161  bool getParamValFromString(const TCHAR *str, ParamVector & params, generic_string & value)
162  {
163  	value = TEXT("");
164  	size_t nbItems = params.size();
165  	for (size_t i = 0; i < nbItems; ++i)
166  	{
167  		const TCHAR * token = params.at(i).c_str();
168  		generic_string tokenStr = token;
169  		size_t pos = tokenStr.find(str);
170  		if (pos != generic_string::npos && pos == 0)
171  		{
172  			value = (token + lstrlen(str));
173  			params.erase(params.begin() + i);
174  			return true;
175  		}
176  	}
177  	return false;
178  }
179  LangType getLangTypeFromParam(ParamVector & params)
180  {
181  	generic_string langStr;
182  	if (!getParamVal('l', params, langStr))
183  		return L_EXTERNAL;
184  	return NppParameters::getLangIDFromStr(langStr.c_str());
185  }
186  generic_string getLocalizationPathFromParam(ParamVector & params)
187  {
188  	generic_string locStr;
189  	if (!getParamVal('L', params, locStr))
190  		return TEXT("");
191  	locStr = stringToLower(stringReplace(locStr, TEXT("_"), TEXT("-"))); 
192  	return NppParameters::getLocPathFromStr(locStr.c_str());
193  }
194  intptr_t getNumberFromParam(char paramName, ParamVector & params, bool & isParamePresent)
195  {
196  	generic_string numStr;
197  	if (!getParamVal(paramName, params, numStr))
198  	{
199  		isParamePresent = false;
200  		return -1;
201  	}
202  	isParamePresent = true;
203  	return static_cast<intptr_t>(_ttoi64(numStr.c_str()));
204  }
205  generic_string getEasterEggNameFromParam(ParamVector & params, unsigned char & type)
206  {
207  	generic_string EasterEggName;
208  	if (!getParamValFromString(TEXT("-qn="), params, EasterEggName))  
209  	{
210  		if (!getParamValFromString(TEXT("-qt="), params, EasterEggName)) 
211  		{
212  			if (!getParamValFromString(TEXT("-qf="), params, EasterEggName)) 
213  				return TEXT("");
214  			else
215  			{
216  				type = 2; 
217  			}
218  		}
219  		else
220  			type = 1; 
221  	}
222  	else
223  		type = 0; 
224  	if (EasterEggName.c_str()[0] == '"' && EasterEggName.c_str()[EasterEggName.length() - 1] == '"')
225  	{
226  		EasterEggName = EasterEggName.substr(1, EasterEggName.length() - 2);
227  	}
228  	if (type == 2)
229  		EasterEggName = relativeFilePathToFullFilePath(EasterEggName.c_str());
230  	return EasterEggName;
231  }
232  int getGhostTypingSpeedFromParam(ParamVector & params)
233  {
234  	generic_string speedStr;
235  	if (!getParamValFromString(TEXT("-qSpeed"), params, speedStr))
236  		return -1;
237  	int speed = std::stoi(speedStr, 0);
238  	if (speed <= 0 || speed > 3)
239  		return -1;
240  	return speed;
241  }
242  const TCHAR FLAG_MULTI_INSTANCE[] = TEXT("-multiInst");
243  const TCHAR FLAG_NO_PLUGIN[] = TEXT("-noPlugin");
244  const TCHAR FLAG_READONLY[] = TEXT("-ro");
245  const TCHAR FLAG_NOSESSION[] = TEXT("-nosession");
246  const TCHAR FLAG_NOTABBAR[] = TEXT("-notabbar");
247  const TCHAR FLAG_SYSTRAY[] = TEXT("-systemtray");
248  const TCHAR FLAG_LOADINGTIME[] = TEXT("-loadingTime");
249  const TCHAR FLAG_HELP[] = TEXT("--help");
250  const TCHAR FLAG_ALWAYS_ON_TOP[] = TEXT("-alwaysOnTop");
251  const TCHAR FLAG_OPENSESSIONFILE[] = TEXT("-openSession");
252  const TCHAR FLAG_RECURSIVE[] = TEXT("-r");
253  const TCHAR FLAG_FUNCLSTEXPORT[] = TEXT("-export=functionList");
254  const TCHAR FLAG_PRINTANDQUIT[] = TEXT("-quickPrint");
255  const TCHAR FLAG_NOTEPAD_COMPATIBILITY[] = TEXT("-notepadStyleCmdline");
256  const TCHAR FLAG_OPEN_FOLDERS_AS_WORKSPACE[] = TEXT("-openFoldersAsWorkspace");
257  const TCHAR FLAG_SETTINGS_DIR[] = TEXT("-settingsDir=");
258  const TCHAR FLAG_TITLEBAR_ADD[] = TEXT("-titleAdd=");
259  const TCHAR FLAG_APPLY_UDL[] = TEXT("-udl=");
260  const TCHAR FLAG_PLUGIN_MESSAGE[] = TEXT("-pluginMessage=");
261  const TCHAR FLAG_MONITOR_FILES[] = TEXT("-monitor");
262  void doException(Notepad_plus_Window & notepad_plus_plus)
263  {
264  	Win32Exception::removeHandler();	
265  	::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Notepad++ will attempt to save any unsaved data. However, dataloss is very likely."), TEXT("Recovery initiating"), MB_OK | MB_ICONINFORMATION);
266  	TCHAR tmpDir[1024];
267  	GetTempPath(1024, tmpDir);
268  	generic_string emergencySavedDir = tmpDir;
269  	emergencySavedDir += TEXT("\\Notepad++ RECOV");
270  	bool res = notepad_plus_plus.emergency(emergencySavedDir);
271  	if (res)
272  	{
273  		generic_string displayText = TEXT("Notepad++ was able to successfully recover some unsaved documents, or nothing to be saved could be found.\r\nYou can find the results at :\r\n");
274  		displayText += emergencySavedDir;
275  		::MessageBox(Notepad_plus_Window::gNppHWND, displayText.c_str(), TEXT("Recovery success"), MB_OK | MB_ICONINFORMATION);
276  	}
277  	else
278  		::MessageBox(Notepad_plus_Window::gNppHWND, TEXT("Unfortunatly, Notepad++ was not able to save your work. We are sorry for any lost data."), TEXT("Recovery failure"), MB_OK | MB_ICONERROR);
279  }
280  void stripIgnoredParams(ParamVector & params)
281  {
282  	for (auto it = params.begin(); it != params.end(); )
283  	{
284  		if (lstrcmp(it->c_str(), TEXT("-z")) == 0)
285  		{
286  			auto nextIt = std::next(it);
287  			if ( nextIt != params.end() )
288  			{
289  				params.erase(nextIt);
290  			}
291  			it = params.erase(it);
292  		}
293  		else
294  		{
295  			++it;
296  		}
297  	}
298  }
299  } 
300  int WINAPI wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE &bsol;*hPrevInstance*/, _In_ PWSTR pCmdLine, _In_ int &bsol;*nShowCmd*/)
301  {
302  	bool TheFirstOne = true;
303  	::SetLastError(NO_ERROR);
304  	::CreateMutex(NULL, false, TEXT("nppInstance"));
305  	if (::GetLastError() == ERROR_ALREADY_EXISTS)
306  		TheFirstOne = false;
307  	generic_string cmdLineString = pCmdLine ? pCmdLine : _T("");
308  	ParamVector params;
309  	parseCommandLine(pCmdLine, params);
310  	stripIgnoredParams(params);
311  	if ( isInList(FLAG_NOTEPAD_COMPATIBILITY, params) )
312  	{
313  		convertParamsToNotepadStyle(params);
314  	}
315  	bool isParamePresent;
316  	bool showHelp = isInList(FLAG_HELP, params);
317  	bool isMultiInst = isInList(FLAG_MULTI_INSTANCE, params);
318  	bool doFunctionListExport = isInList(FLAG_FUNCLSTEXPORT, params);
319  	bool doPrintAndQuit = isInList(FLAG_PRINTANDQUIT, params);
320  	CmdLineParams cmdLineParams;
321  	cmdLineParams._isNoTab = isInList(FLAG_NOTABBAR, params);
322  	cmdLineParams._isNoPlugin = isInList(FLAG_NO_PLUGIN, params);
323  	cmdLineParams._isReadOnly = isInList(FLAG_READONLY, params);
324  	cmdLineParams._isNoSession = isInList(FLAG_NOSESSION, params);
325  	cmdLineParams._isPreLaunch = isInList(FLAG_SYSTRAY, params);
326  	cmdLineParams._alwaysOnTop = isInList(FLAG_ALWAYS_ON_TOP, params);
327  	cmdLineParams._showLoadingTime = isInList(FLAG_LOADINGTIME, params);
328  	cmdLineParams._isSessionFile = isInList(FLAG_OPENSESSIONFILE, params);
329  	cmdLineParams._isRecursive = isInList(FLAG_RECURSIVE, params);
330  	cmdLineParams._openFoldersAsWorkspace = isInList(FLAG_OPEN_FOLDERS_AS_WORKSPACE, params);
331  	cmdLineParams._monitorFiles = isInList(FLAG_MONITOR_FILES, params);
332  	cmdLineParams._langType = getLangTypeFromParam(params);
333  	cmdLineParams._localizationPath = getLocalizationPathFromParam(params);
334  	cmdLineParams._easterEggName = getEasterEggNameFromParam(params, cmdLineParams._quoteType);
335  	cmdLineParams._ghostTypingSpeed = getGhostTypingSpeedFromParam(params);
336  	generic_string pluginMessage;
337  	if (getParamValFromString(FLAG_PLUGIN_MESSAGE, params, pluginMessage))
338  	{
339  		if (pluginMessage.length() >= 2)
340  		{
341  			if (pluginMessage.front() == '"' && pluginMessage.back() == '"')
342  			{
343  				pluginMessage = pluginMessage.substr(1, pluginMessage.length() - 2);
344  			}
345  		}
346  		cmdLineParams._pluginMessage = pluginMessage;
347  	}
348  	cmdLineParams._line2go = getNumberFromParam('n', params, isParamePresent);
349      cmdLineParams._column2go = getNumberFromParam('c', params, isParamePresent);
350      cmdLineParams._pos2go = getNumberFromParam('p', params, isParamePresent);
351  	cmdLineParams._point.x = static_cast<LONG>(getNumberFromParam('x', params, cmdLineParams._isPointXValid));
352  	cmdLineParams._point.y = static_cast<LONG>(getNumberFromParam('y', params, cmdLineParams._isPointYValid));
353  	NppParameters& nppParameters = NppParameters::getInstance();
354  	nppParameters.setCmdLineString(cmdLineString);
355  	generic_string path;
356  	if (getParamValFromString(FLAG_SETTINGS_DIR, params, path))
357  	{
358  		if (path.c_str()[0] == '"' && path.c_str()[path.length() - 1] == '"')
359  		{
360  			path = path.substr(1, path.length() - 2);
361  		}
362  		nppParameters.setCmdSettingsDir(path);
363  	}
364  	generic_string titleBarAdditional;
365  	if (getParamValFromString(FLAG_TITLEBAR_ADD, params, titleBarAdditional))
366  	{
367  		if (titleBarAdditional.length() >= 2)
368  		{
369  			if (titleBarAdditional.front() == '"' && titleBarAdditional.back() == '"')
370  			{
371  				titleBarAdditional = titleBarAdditional.substr(1, titleBarAdditional.length() - 2);
372  			}
373  		}
374  		nppParameters.setTitleBarAdd(titleBarAdditional);
375  	}
376  	generic_string udlName;
377  	if (getParamValFromString(FLAG_APPLY_UDL, params, udlName))
378  	{
379  		if (udlName.length() >= 2)
380  		{
381  			if (udlName.front() == '"' && udlName.back() == '"')
382  			{
383  				udlName = udlName.substr(1, udlName.length() - 2);
384  			}
385  		}
386  		cmdLineParams._udlName = udlName;
387  	}
388  	if (showHelp)
389  		::MessageBox(NULL, COMMAND_ARG_HELP, TEXT("Notepad++ Command Argument Help"), MB_OK);
390  	if (cmdLineParams._localizationPath != TEXT(""))
391  	{
392  		nppParameters.setStartWithLocFileName(cmdLineParams._localizationPath);
393  	}
394  	nppParameters.load();
395  	NppGUI & nppGui = nppParameters.getNppGUI();
396  	NppDarkMode::initDarkMode();
397  	bool doUpdateNpp = nppGui._autoUpdateOpt._doAutoUpdate;
398  	bool doUpdatePluginList = nppGui._autoUpdateOpt._doAutoUpdate;
399  	if (doFunctionListExport || doPrintAndQuit) 
400  	{
401  		isMultiInst = true;
402  		doUpdateNpp = doUpdatePluginList = false;
403  		cmdLineParams._isNoSession = true;
404  	}
405  	nppParameters.setFunctionListExportBoolean(doFunctionListExport);
406  	nppParameters.setPrintAndExitBoolean(doPrintAndQuit);
407  	if (nppParameters.asNotepadStyle())
408  	{
409  		isMultiInst = true;
410  		cmdLineParams._isNoTab = true;
411  		cmdLineParams._isNoSession = true;
412  	}
413  	const NppGUI & nppGUI = nppParameters.getNppGUI();
414  	if (nppGUI._multiInstSetting == multiInst)
415  	{
416  		isMultiInst = true;
417  		if (!TheFirstOne)
418  			cmdLineParams._isNoSession = true;
419  	}
420  	generic_string quotFileName = TEXT("");
421  	size_t nbFilesToOpen = params.size();
422  	for (size_t i = 0; i < nbFilesToOpen; ++i)
423  	{
424  		const TCHAR * currentFile = params.at(i).c_str();
425  		if (currentFile[0])
426  		{
427  			quotFileName += TEXT("\"");
428  			quotFileName += relativeFilePathToFullFilePath(currentFile);
429  			quotFileName += TEXT("\" ");
430  		}
431  	}
432  	::SetCurrentDirectory(NppParameters::getInstance().getNppPath().c_str());	
433  	if ((!isMultiInst) && (!TheFirstOne))
434  	{
435  		HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
436  		for (int i = 0 ;!hNotepad_plus && i < 5 ; ++i)
437  		{
438  			Sleep(100);
439  			hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), NULL);
440  		}
441          if (hNotepad_plus)
442          {
443  			nppParameters.destroyInstance();
444  			bool isInSystemTray = ::SendMessage(hNotepad_plus, NPPM_INTERNAL_RESTOREFROMTRAY, 0, 0);
445  			if (!isInSystemTray)
446  			{
447  				int sw = 0;
448  				if (::IsZoomed(hNotepad_plus))
449  					sw = SW_MAXIMIZE;
450  				else if (::IsIconic(hNotepad_plus))
451  					sw = SW_RESTORE;
452  				if (sw != 0)
453  					::ShowWindow(hNotepad_plus, sw);
454  			}
455  			::SetForegroundWindow(hNotepad_plus);
456  			if (params.size() > 0)	
457  			{
458  				CmdLineParamsDTO dto = CmdLineParamsDTO::FromCmdLineParams(cmdLineParams);
459  				COPYDATASTRUCT paramData{};
460  				paramData.dwData = COPYDATA_PARAMS;
461  				paramData.lpData = &dto;
462  				paramData.cbData = sizeof(dto);
463  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&paramData));
464  				COPYDATASTRUCT cmdLineData{};
465  				cmdLineData.dwData = COPYDATA_FULL_CMDLINE;
466  				cmdLineData.lpData = (void*)cmdLineString.c_str();
467  				cmdLineData.cbData = static_cast<DWORD>((cmdLineString.length() + 1) * sizeof(TCHAR));
468  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&cmdLineData));
469  				COPYDATASTRUCT fileNamesData{};
470  				fileNamesData.dwData = COPYDATA_FILENAMESW;
471  				fileNamesData.lpData = (void *)quotFileName.c_str();
472  				fileNamesData.cbData = static_cast<DWORD>((quotFileName.length() + 1) * sizeof(TCHAR));
473  				::SendMessage(hNotepad_plus, WM_COPYDATA, reinterpret_cast<WPARAM>(hInstance), reinterpret_cast<LPARAM>(&fileNamesData));
474  			}
475  			return 0;
476          }
477  	}
<span onclick='openModal()' class='match'>478  	auto upNotepadWindow = std::make_unique<Notepad_plus_Window>();
479  	Notepad_plus_Window & notepad_plus_plus = *upNotepadWindow.get();
480  	generic_string updaterDir = nppParameters.getNppPath();
481  	updaterDir += TEXT("\\updater\\");
482  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
483  	generic_string updaterParams = TEXT("-v");
484  	updaterParams += VERSION_VALUE;
485  	bool isUpExist = nppGui._doesExistUpdater = (::PathFileExists(updaterFullPath.c_str()) == TRUE);
</span>486      if (doUpdateNpp) 
487      {
488          Date today(0);
489          if (today < nppGui._autoUpdateOpt._nextUpdateDate)
490              doUpdateNpp = false;
491      }
492  	if (doUpdatePluginList)
493  	{
494  	}
495  	winVer ver = nppParameters.getWinVersion();
496  	bool isGtXP = ver > WV_XP;
497  	SecurityGuard securityGuard;
498  	bool isSignatureOK = securityGuard.checkModule(updaterFullPath, nm_gup);
499  	if (TheFirstOne && isUpExist && isGtXP && isSignatureOK)
500  	{
501  		if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
502  		{
503  			updaterParams += TEXT(" -px64");
504  		}
505  		else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
506  		{
507  			updaterParams += TEXT(" -parm64");
508  		}
509  		if (doUpdateNpp)
510  		{
511  			Process updater(updaterFullPath.c_str(), updaterParams.c_str(), updaterDir.c_str());
512  			updater.run();
513  			if (nppGui._autoUpdateOpt._intervalDays < 0) 
514  				nppGui._autoUpdateOpt._intervalDays = 0 - nppGui._autoUpdateOpt._intervalDays;
515  			nppGui._autoUpdateOpt._nextUpdateDate = Date(nppGui._autoUpdateOpt._intervalDays);
516  		}
517  		doUpdatePluginList = false;
518  		if (doUpdatePluginList)
519  		{
520  			generic_string upPlParams = TEXT("-v"); 
521  			upPlParams += notepad_plus_plus.getPluginListVerStr();
522  			if (nppParameters.archType() == IMAGE_FILE_MACHINE_AMD64)
523  			{
524  				upPlParams += TEXT(" -px64");
525  			}
526  			else if (nppParameters.archType() == IMAGE_FILE_MACHINE_ARM64)
527  			{
528  				upPlParams += TEXT(" -parm64");
529  			}
530  			upPlParams += TEXT(" -upZip");
531  			upPlParams += TEXT(" https:&bsol;&bsol;notepad-plus-plus.org/update/pluginListDownloadUrl.php");
532  			upPlParams += nppParameters.getPluginConfDir();
533  			Process updater(updaterFullPath.c_str(), upPlParams.c_str(), updaterDir.c_str());
534  			updater.run();
535  		}
536  	}
537  	MSG msg{};
538  	msg.wParam = 0;
539  	Win32Exception::installHandler();
540  	MiniDumper mdump;	
541  	try
542  	{
543  		notepad_plus_plus.init(hInstance, NULL, quotFileName.c_str(), &cmdLineParams);
544  		allowPrivilegeMessages(notepad_plus_plus, ver);
545  		bool going = true;
546  		while (going)
547  		{
548  			going = ::GetMessageW(&msg, NULL, 0, 0) != 0;
549  			if (going)
550  			{
551  				if (!notepad_plus_plus.isDlgsMsg(&msg))
552  				{
553  					if (::TranslateAccelerator(notepad_plus_plus.getHSelf(), notepad_plus_plus.getAccTable(), &msg) == 0)
554  					{
555  						::TranslateMessage(&msg);
556  						::DispatchMessageW(&msg);
557  					}
558  				}
559  			}
560  		}
561  	}
562  	catch (int i)
563  	{
564  		TCHAR str[50] = TEXT("God Damned Exception : ");
565  		TCHAR code[10];
566  		wsprintf(code, TEXT("%d"), i);
567  		wcscat_s(str, code);
568  		::MessageBox(Notepad_plus_Window::gNppHWND, str, TEXT("Int Exception"), MB_OK);
569  		doException(notepad_plus_plus);
570  	}
571  	catch (std::runtime_error & ex)
572  	{
573  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "Runtime Exception", MB_OK);
574  		doException(notepad_plus_plus);
575  	}
576  	catch (const Win32Exception & ex)
577  	{
578  		TCHAR message[1024];	
579  		wsprintf(message, TEXT("An exception occured. Notepad++ cannot recover and must be shut down.\r\nThe exception details are as follows:\r\n")
580  			TEXT("Code:\t0x%08X\r\nType:\t%S\r\nException address: 0x%p"), ex.code(), ex.what(), ex.where());
581  		::MessageBox(Notepad_plus_Window::gNppHWND, message, TEXT("Win32Exception"), MB_OK | MB_ICONERROR);
582  		mdump.writeDump(ex.info());
583  		doException(notepad_plus_plus);
584  	}
585  	catch (std::exception & ex)
586  	{
587  		::MessageBoxA(Notepad_plus_Window::gNppHWND, ex.what(), "General Exception", MB_OK);
588  		doException(notepad_plus_plus);
589  	}
590  	catch (...) 
591  	{
592  		::MessageBoxA(Notepad_plus_Window::gNppHWND, "An exception that we did not yet found its name is just caught", "Unknown Exception", MB_OK);
593  		doException(notepad_plus_plus);
594  	}
595  	return static_cast<int>(msg.wParam);
596  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</h3>
            <pre><code>1  TStr TAppCS::A_Result="Result";
2  TStr TAppCS::A_Msg="Msg";
3  TStr TAppCS::A_MsgType="MsgType";
4  TStr TAppCS::A_Continue="Continue";
5  TStr TAppCS::A_Browse="Browse";
6  TStr TAppCS::A_SesId="SesId";
7  TStr TAppCS::A_FetchId="FetchId";
8  TStr TAppCS::A_Redir="Redir";
9  TStr TAppCS::A_Agent="Agent";
10  TStr TAppCS::A_HostNm="HostNm";
11  TStr TAppCS::A_PortN="PortN";
12  TStr TAppCS::A_UsrNm="UsrNm";
13  TStr TAppCS::A_PwdStr="PwdStr";
14  TStr TAppCS::A_PrivNm="PrivNm";
15  TStr TAppCS::A_PrivId="PrivId";
16  TStr TAppCS::A_CltNm="CltNm";
17  TStr TAppCS::A_CltType="CltType";
18  TStr TAppCS::A_State="State";
19  TStr TAppCS::A_PrevState="PrevState";
<span onclick='openModal()' class='match'>20  TStr TAppCS::A_OldState="OldState";
21  TStr TAppCS::A_NewState="NewState";
22  TStr TAppCS::A_AbortState="AbortState";
23  TStr TAppCS::A_SetStateTm="SetStateTm";
24  TStr TAppCS::A_LogNm="LogNm";
25  TStr TAppCS::F_Info="Info";
26  TStr TAppCS::F_GetStateInfo="GetStateInfo";
27  TStr TAppCS::F_GetCltList="GetCltList";
28  TStr TAppCS::F_GetCltInfo="GetCltInfo";
</span>29  TStr TAppCS::F_GetCltDesc="GetCltDesc";
30  TStr TAppCS::F_IsAlive="IsAlive";
31  TStr TAppCS::F_IsConn="IsConn";
32  TStr TAppCS::F_Log="Log";
33  TStr TAppCS::F_Connect="Connect";
34  TStr TAppCS::F_Disconnect="Disconnect";
35  TStr TAppCS::F_DelayTimer="DelayTimer";
36  TStr TAppCS::F_RegAgent="RegAgent";
37  TStr TAppCS::F_Confirm="Confirm";
38  TStr TAppCS::F_Cancel="Cancel";
39  TStr TAppCS::F_Notify="Notify";
40  TStr TAppCS::F_NotifyStateChange="NotifyStateChange";
41  TStr TAppCS::F_Abort="Abort";
42  TStr TAppCS::F_HBeatTimer="HBeatTimer";
43  TStr TAppCS::TmA_TimerId="TimerId";
44  TStr TAppCS::TmA_CtxNm="CtxNm";
45  TStr TAppCS::TmA_Ticks="Ticks";
46  TStr TAppCS::F_Broadcast="Broadcast";
47  TStr TAppCS::BcA_Cm="Cm";
48  TStr TAppCS::BcA_FldNm="FldNm";
49  TStr TAppCS::BcA_FldVal="FldVal";
50  TStr TAppCS::BcA_Msg="Msg";
51  TStr TAppCS::F_NotifyEvent="Log::NotifyEvent";
52  TStr TAppCS::F_NotifyRawEvent="Log::NotifyRawEvent";
53  TStr TAppCS::LogA_EventTypeNm="EventTypeNm";
54  TStr TAppCS::LogA_TestMode="TestMode";
55  TStr TAppCS::LogA_CreatorNm="CreatorNm";
56  TStr TAppCS::LogA_CreatorTime="CreatorTime";
57  int TAppCS::DTmrA_DelayTimerTout=2*1000;
58  TStr TAppCS::S_Start="Start";
59  TStr TAppCS::S_End="End";
60  TStr TAppCS::S_ConnectRq="ConnectRq";
61  TStr TAppCS::S_ConnectResp="ConnectResp";
62  TStr TAppCS::S_Connected="Connected";
63  TStr TAppCS::S_Server="Server";
64  TAppCSLog::TAppCSLog(
65  const TStr& _LogFNm, const int64& _MxFLen, const PNotify& _Notify):
66    Notify(_Notify),
67    LogFNm(_LogFNm), LogSOut(), fLog(NULL), MxFLen(_MxFLen){
68    if (LogFNm.Empty()){
69      TNotify::OnNotify(Notify, ntInfo, "Log-File Not Generated.");
70    } else {
71      if (LogFNm.GetFPath().Empty()){
72        LogFNm=GetHomeNrFPath()+LogFNm;}
73      if (false&&TFile::Exists(LogFNm)){
74        LogSOut=TFOut::New(LogFNm, true); fLog=LogSOut->GetFileId();
75        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
76      } else {
77        LogSOut=TFOut::New(LogFNm); fLog=LogSOut->GetFileId();
78        TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" created.");
79      }
80      PutLogHd();
81    }
82  }
83  void TAppCSLog::ResetLogIfTooBig(){
84    if ((fLog!=NULL)&&(MxFLen!=-1)){
85      int64 FLen=ftell(fLog);
86      if (FLen>MxFLen){
87        LogSOut=NULL; 
88        try {
89          TStr OldLogFNm=LogFNm+".Old";
90          TFile::Del(OldLogFNm, false);
91          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+OldLogFNm+" deleted.");
92          TFile::Rename(LogFNm, OldLogFNm);
93          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" renamed.");
94          LogSOut=TFOut::New(LogFNm, true);
95          TNotify::OnNotify(Notify, ntInfo, TStr("Log-File ")+LogFNm+" opened.");
96          PutLogHd();
97        } catch (PExcept Except){
98          TNotify::OnNotify(Notify, ntErr, Except->GetMsgStr());
99        }
100      }
101    }
102  }
103  void TAppCSLog::PutLogHd(){
104    TTm CurTm=TTm::GetCurUniTm();
105    if (fLog!=NULL){
106      fprintf(fLog, "#Software: Quintelligence Application-Web-Server 1.0\n");
107      fprintf(fLog, "#Version: 1.0\n");
108      fprintf(fLog, "#Date: %s %s\n",
109       CurTm.GetWebLogDateStr().CStr(), CurTm.GetWebLogTimeStr().CStr());
110      fprintf(fLog, "#Fields: date time c-ip cs-method cs-uri sc-status\n");
111      fflush(fLog);
112    }
113    ResetLogIfTooBig();
114  }
115  void TAppCSLog::PutLogRec(
116   const PHttpRq& HttpRq, const PHttpResp& HttpResp, const TStr& PeerHostNm){
117    TTm CurTm=TTm::GetCurUniTm();
118    if (fLog!=NULL){
119      fprintf(fLog, "%s %s %s %s %s %s\n",
120       CurTm.GetWebLogDateStr().CStr(),
121       CurTm.GetWebLogTimeStr().CStr(),
122       PeerHostNm.CStr(),
123       HttpRq->GetMethodNm().CStr(),
124       HttpRq->GetUrl()->GetUrlStr().CStr(),
125       TInt::GetStr(HttpResp->GetStatusCd()).CStr());
126      fflush(fLog);
127    }
128    TStr MsgStr=TStr("Http: ")+
129     PeerHostNm+" requested "+HttpRq->GetUrl()->GetUrlStr()+
130     " responding "+THttp::GetReasonPhrase(HttpResp->GetStatusCd())
131     +" ["+CurTm.GetStr()+"]";
132    TNotify::OnNotify(Notify, ntInfo, MsgStr);
133    ResetLogIfTooBig();
134  }
135  void TAppCSLog::PutLogMsg(const TStr& MsgType, const TStr& MsgStr){
136    TTm CurTm=TTm::GetCurUniTm();
137    if (fLog!=NULL){
138      fprintf(fLog, "#%s: %s\n",
139       MsgType.CStr(),
140       MsgStr.CStr());
141      fflush(fLog);
142    }
143    TNotify::OnNotify(
144     Notify, ntInfo, MsgType+": "+MsgStr&bsol;*+" ["+CurTm.GetStr()+"]"*/);
145    ResetLogIfTooBig();
146  }
147  void TAppCSLog::PutLogMsg(
148   const TStr& MsgType, const TStr& MsgStr, const TStr& MsgArg){
149    PutLogMsg(MsgType, MsgStr+" ("+MsgArg+").");
150  }
151  TAppCSTimer::TAppCSTimer(
152   const TStr& _TimerNm, const TStr& _CtxNm,
153   const int& TimerTout, const bool& _RepeatP, TWebNetSrv* _WebNetSrv):
154    TTTimer(TimerTout), WebNetSrv(_WebNetSrv),
155    TimerNm(_TimerNm), RepeatP(_RepeatP), CtxNm(_CtxNm){
156    IAssertR(TXmlLx::IsTagNm(TimerNm),
157     TStr("Timer-name is not XML-Tag-Name (")+TimerNm+").");
158  }
159  void TAppCSTimer::OnTimeOut(){
160    if (!RepeatP){
161      StopTimer();}
162    PSoapRq SoapRq=TSoapRq::New(TimerNm,
163     TAppCS::TmA_TimerId, TInt::GetStr(GetTimerId()),
164     TAppCS::TmA_CtxNm, CtxNm,
165     TAppCS::TmA_Ticks, TInt::GetStr(GetTicks()));
166    PUrl Url=SoapRq->GetAsUrl("localhost");
167    PHttpRq HttpRq=THttpRq::New(Url);
168    WebNetSrv->OnHttpRq(-1, HttpRq);
169  }
170  TAppCSState::TAppCSState(const PAppCSLog& _Log):
171    StateId(), Log(_Log){
172    PrepState();
173  }
174  void TAppCSState::PrepState(){
175    SoapEnv=TSoapEnv::New();
176    SetState(TAppCS::S_Start);
177  }
178  void TAppCSState::SetState(const TStr& _StateId){
179    TStr PrevStateId=StateId;
180    StateId=_StateId;
181    if (!Log.Empty()){
182      Log->PutLogMsg("SetState", "From '"+PrevStateId+"' to '"+StateId+"'");
183    }
184  }
185  TAppSrv::TAppSrv(
186   const int& PortN, const TStr& LogFNm, const int& HBeatTimerTout,
187   const PNotify& Notify):
188    TWebNetSrv(PortN, true), 
189    TWebNetCltV(), 
190    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
191    SesIdToCltDescH(), 
192    CltNmToSesIdH(), 
193    HBeatTimer(), 
194    ActConnBs(TAppCSActConnBs::New()), 
195    NmToLogH(),
196    Proxy(new TWebNetProxy(PortN+11,TStr("http:&bsol;&bsol;127.0.0.1:")+TInt::GetStr(PortN))) {
197    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
198     "Srv", HBeatTimerTout, true, this);
199  }
200  TAppSrv::~TAppSrv(){
201    HBeatTimer->StopTimer();
202  }
203  bool TAppSrv::IsLogSoapFuncNm(const TStr& SoapFuncNm){
204    return
205     (!SoapFuncNm.IsPrefix(TAppCS::F_Log))&&
206     (SoapFuncNm!=TAppCS::F_HBeatTimer)&&
207     (SoapFuncNm!=TAppCS::F_IsAlive);
208  }
209  TStr TAppSrv::GetNewSesId(){
210    TStr SesId;
211    do {
212      SesId=TTm::GetCurUniTm().GetIdStr();
213    } while (SesIdToCltDescH.IsKey(SesId));
214    return SesId;
215  }
216  bool TAppSrv::IsGetCltDescBySesId(
217   const TStr& SesId, PAppCltDesc& CltDesc) const {
218    return SesIdToCltDescH.IsKeyGetDat(SesId, CltDesc);
219  }
220  bool TAppSrv::IsGetCltDescBySockId(
221   const int& SockId, PAppCltDesc& CltDesc) const {
222    int SesIdToCltDescP=SesIdToCltDescH.FFirstKeyId();
223    while (SesIdToCltDescH.FNextKeyId(SesIdToCltDescP)){
224      CltDesc=SesIdToCltDescH[SesIdToCltDescP];
225      if (CltDesc->SockId==SockId){
226        return true;}
227    }
228    CltDesc=NULL;
229    return false;
230  }
231  bool TAppSrv::IsGetCltDescByCltNm(
232   const TStr& CltNm, PAppCltDesc& CltDesc) const {
233    TStr SesId;
234    if (CltNmToSesIdH.IsKeyGetDat(CltNm, SesId)){
235      return IsGetCltDescBySesId(SesId, CltDesc);
236    } else {
237      return false;
238    }
239  }
240  PAppCltDesc TAppSrv::AddNewCltDesc(
241   const TStr& HostNm, const int& PortN, const int& SockId,
242   const TStr& CltNm, const TStr& CltType){
243    TStr SesId=GetNewSesId();
244    PAppCltDesc CltDesc=TAppCltDesc::New(SesId, HostNm, PortN);
245    CltDesc->SockId=SockId;
246    CltDesc->CltNm=CltNm;
247    CltDesc->CltType=CltType;
248    SesIdToCltDescH.AddDat(SesId, CltDesc);
249    TStr PrevSesId;
250    if (CltNmToSesIdH.IsKeyGetDat(CltNm, PrevSesId)){
251      DelIfCltDesc(PrevSesId);}
252    CltNmToSesIdH.AddDat(CltNm, SesId);
253    CltDesc->CltType=CltType;
254    return CltDesc;
255  }
256  void TAppSrv::DelIfCltDesc(const TStr& SesId){
257    PAppCltDesc CltDesc; TStr CltNm;
258    if (IsGetCltDescBySesId(SesId, CltDesc)){
259      CltNm=CltDesc->CltNm;
260      CltNmToSesIdH.DelIfKey(CltDesc->CltNm);
261    }
262    SesIdToCltDescH.DelIfKey(SesId);
263    Log->PutLogMsg("Info",
264     TStr::Fmt("Delete client '%s' with session '%s'.", CltNm.CStr(), SesId.CStr()));
265  }
266  void TAppSrv::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
267    TTm CurTm=TTm::GetCurUniTm(); 
268    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm); 
269    PUrl Url=HttpRq->GetUrl(); 
270    TStr UrlStr=Url->GetUrlStr(); 
271    TStr PeerHostNm=GetPeerHostNm(SockId); 
272    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
273    TStr SoapFuncNm=SoapRq->GetFuncNm();
274    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
275    if (IsLogSoapFuncNm(SoapFuncNm)){
276      Log->PutLogMsg("SoapRequest", SoapRqMsgStr);}
277    PHttpResp HttpResp;
278    if (SoapRq->IsOk()){
279      if (SoapFuncNm==TAppCS::F_Info){
280        HttpResp=OnHttpRq_Info();
281      } else
282      if (SoapFuncNm==TAppCS::F_GetCltList){
283        HttpResp=OnHttpRq_GetCltList(SoapRq);
284      } else
285      if ((SoapFuncNm==TAppCS::F_GetCltInfo)||(SoapFuncNm==TAppCS::F_GetCltDesc)){
286        HttpResp=OnHttpRq_GetCltInfo(SoapRq);
287      } else
288      if (SoapFuncNm==TAppCS::F_Connect){
289        HttpResp=OnHttpRq_Connect(SoapRq, PeerHostNm, SockId);
290      } else
291      if (SoapFuncNm==TAppCS::F_Disconnect){
292        HttpResp=OnHttpRq_Disconnect(SoapRq, PeerHostNm);
293      } else
294      if (SoapFuncNm==TAppCS::F_Log){
295        HttpResp=OnHttpRq_OnLog(SoapRq);
296      } else
297      if (SoapFuncNm==TAppCS::F_HBeatTimer){
298        OnHttpRq_OnHBeatTimer();
299      } else
300      if (IsCltOk(SoapRq, PeerHostNm)){
301        if (SoapFuncNm==TAppCS::F_IsAlive){
302          HttpResp=TSoapResp::GetHttpResp(TAppCS::F_IsAlive);
303        } else
304        if (SoapFuncNm==TAppCS::F_Broadcast){
305          HttpResp=OnHttpRq_Broadcast(SoapRq);
306        } else {
307          HttpResp=OnFuncRq(SockId, SoapRq, Url);
308        }
309      } else {
310        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
311         "Client admin info mismatch.");
312      }
313    } else {
314      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
315       "Invalid SOAP HTTP Request.");
316    }
317    if (SockId!=-1){
318      if (HttpResp.Empty()){
319        Log->PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr);
320        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
321      }
322      if (!FetchIdStr.Empty()){
323        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
324      SendHttpResp(SockId, HttpResp);
325      if (IsLogSoapFuncNm(SoapFuncNm)){
326        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
327        PSoapResp SoapResp=TSoapResp::New(HttpResp);
328        if (SoapResp->IsOk()){
329          Log->PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr());
330        }
331      }
332    }
333  }
334  void TAppSrv::OnHttpRqError(const int& SockId, const TStr& MsgStr){
335    Log->PutLogMsg("HttpRqError", MsgStr);
336    PAppCltDesc CltDesc;
337    if (IsGetCltDescBySockId(SockId, CltDesc)){
338      DelIfCltDesc(CltDesc->SesId);
339    }
340  }
341  TStr TAppSrv::GetPeerHostNm(const int& SockId) const {
342    if (SockId==-1){
343      return "internal";
344    } else {
345      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
346  #if 0
347      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
348        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
349        if (LocalSockHost->IsOk()){
350          return LocalSockHost->GetIpNum();
351        }
352      }
353  #else
354      if (PeerHostNm.GetLc()=="localhost") PeerHostNm="127.0.0.1";
355  #endif
356      return PeerHostNm;
357    }
358  }
359  void TAppSrv::ResolveCltIP(const PAppCltDesc CltDesc, int SockId, TStr &DestHost, TStr &DestProxy) {
360    static const TStr LoopbackIP("127.0.0.1");
361    static const TStr LocalhostNm("localhost");
362    if (SockId==-1) {
363      DestHost=LoopbackIP;
364    } else {
365      PSockHost Localhost=TSockHost::GetLocalSockHost();
366      PSock Sock=GetCltSock(SockId);
367      TStr PeerIP=Sock->GetPeerIpNum();
368      TStr AdapterIP=Sock->GetLocalIpNum();
369      TStr CltHostNm = CltDesc->HostNm;
370      bool LocalPeerP = (Localhost->HasIpNum(PeerIP)||(PeerIP==LoopbackIP)||(PeerIP==LocalhostNm));
371      bool LocalRedirP = (Localhost->HasIpNum(CltHostNm)||(CltHostNm==LoopbackIP)||(CltHostNm==LocalhostNm));
372      if (LocalRedirP) { 
373        DestHost=LocalPeerP?LoopbackIP:AdapterIP;
374        IAssert(LocalPeerP||(AdapterIP!=LoopbackIP));
375      } else { 
376        DestHost=CltHostNm;
377        if (!LocalPeerP) {
378          unsigned long PeerAddr = ntohl(inet_addr(PeerIP.CStr()));
379          unsigned long DestAddr = ntohl(inet_addr(DestHost.CStr()));
380          if (((PeerAddr^DestAddr) & 0xFFFFFF00) != 0) {
381            DestProxy=AdapterIP;
382          }
383        }
384      }
385    }
386  }
387  bool TAppSrv::IsCltOk(const PSoapRq& SoapRq, const TStr& PeerHostNm) const {
388    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
389    PAppCltDesc CltDesc;
390    if (IsGetCltDescBySesId(SesId, CltDesc)){
391  #if 0
392      if (PeerHostNm==CltDesc->HostNm) {
393        return true;
394      }
395  #else
396      return true;
397  #endif
398    }
399    return false;
400  }
401  PHttpResp TAppSrv::OnHttpRq_Info() const {
402    TTm CurTm=TTm::GetCurUniTm();
403    TChA HtmlChA;
404    HtmlChA+="<html><head><title>Application Server Status</title></head>";
405    HtmlChA+="<body>";
406    HtmlChA+="<h1>Application Server Status</h1>";
407    HtmlChA+="GMT-Time: ";
408    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
409    HtmlChA+="<br>";
410    HtmlChA+="Active Clients: "; HtmlChA+=TInt::GetStr(GetClts());
411    HtmlChA+="<br>";
412    HtmlChA+="Server Port: ";
413    HtmlChA+=TInt::GetStr(GetPortN());
414    HtmlChA+="<br>";
415    HtmlChA+="Server Up-Time (secs): ";
416    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
417    HtmlChA+="<br>";
418    HtmlChA+="Log-File-Name: ";
419    HtmlChA+=GetLog()->GetLogFNm();
420    HtmlChA+="<br>";
421    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
422    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
423    HtmlChA+="<br>";
424    HtmlChA+="Heart-Beat-Ticks: ";
425    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
426    HtmlChA+="<br>";
427    HtmlChA+="</body>";
428    HtmlChA+="</html>";
429    PHttpResp HttpResp=THttpResp::New(
430     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
431    return HttpResp;
432  }
433  PHttpResp TAppSrv::OnHttpRq_GetCltList(const PSoapRq& SoapRq){
434    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
435    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
436    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
437      PAppCltDesc CltDesc=CltDescV[CltDescN];
438      if (!CltDesc->CltNm.Empty()){
439        SoapResp->AddFldNmVal(CltDesc->CltNm,
440         CltDesc->HostNm+"/"+TInt::GetStr(CltDesc->PortN));
441      }
442    }
443    return SoapResp->GetHttpResp();
444  }
445  PHttpResp TAppSrv::OnHttpRq_GetCltInfo(const PSoapRq& SoapRq){
446    PHttpResp HttpResp;
447    TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
448    PAppCltDesc CltDesc;
449    if (IsGetCltDescByCltNm(CltNm, CltDesc)){
450      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
451       TAppCS::A_Result, "T",
452       TAppCS::A_HostNm, CltDesc->HostNm,
453       TAppCS::A_PortN, TInt::GetStr(CltDesc->PortN),
454       TAppCS::A_CltNm, CltDesc->CltNm,
455       TAppCS::A_CltType, CltDesc->CltType);
456    } else {
457      HttpResp=TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
458       TAppCS::A_Result, "F",
459       TAppCS::A_Msg, TStr::Fmt("Client '%s' not registered.", CltNm.CStr()));
460    }
461    return HttpResp;
462  }
463  PHttpResp TAppSrv::OnHttpRq_Connect(
464   const PSoapRq& SoapRq, const TStr& PeerHostNm, const int& SockId){
465    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Connect);
466    int CltPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(-1);
467    if (CltPortN==-1){
468      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
469       "Port parameter missing in Login function call.");
470    } else {
471      TStr CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
472      TStr CltType=SoapRq->GetFldVal(TAppCS::A_CltType);
473      if (!IsCltByCltNm(CltNm)){
474        PAppCltDesc CltDesc=AddNewCltDesc(PeerHostNm, CltPortN, SockId, CltNm, CltType);
475        return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(),
476         TAppCS::A_SesId, CltDesc->SesId);
477      } else {
478        return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
479         TStr::Fmt("Client '%s' already registered.", CltNm.CStr()));
480      }
481    }
482  }
483  PHttpResp TAppSrv::OnHttpRq_Disconnect( 
484   const PSoapRq& SoapRq, const TStr& PeerHostNm){
485    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Disconnect);
486    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId); PAppCltDesc CltDesc;
487    if (!SesId.Empty()&&IsGetCltDescBySesId(SesId, CltDesc)){
488      DelIfCltDesc(CltDesc->SesId);
489      return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
490    } else {
491      return TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
492       "Invalid disconnect request.");
493    }
494  }
495  PHttpResp TAppSrv::OnHttpRq_OnLog(const PSoapRq& SoapRq){
496    IAssert(SoapRq->GetFuncNm()==TAppCS::F_Log);
497    PAppCSLog CltLog;
498    TStr LogNm=SoapRq->GetFldVal(TAppCS::A_LogNm);
499    if (!NmToLogH.IsKeyGetDat(LogNm, CltLog)){
500      CltLog=TAppCSLog::New(LogNm+".Log", -1, NULL);
501      NmToLogH.AddDat(LogNm, CltLog);
502    }
503    TStr MsgTypeNm=SoapRq->GetFldVal(TAppCS::A_MsgType);
504    TStr MsgStr=SoapRq->GetFldVal(TAppCS::A_Msg);
505    CltLog->PutLogMsg(MsgTypeNm, MsgStr);
506    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
507  }
508  void TAppSrv::OnHttpRq_OnHBeatTimer(){
509    TTm CurTm=TTm::GetCurUniTm();
510    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
511    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
512      PAppCltDesc CltDesc=CltDescV[CltDescN];
513      TTm LastHBeatTm=CltDesc->LastHBeatTm;
514      if (TTm::GetDiffMSecs(CurTm, LastHBeatTm)>HBeatTimer->GetTimeOut()){
515        if (CltDesc->ActiveHBeatRqP){
516          DelIfCltDesc(CltDesc->SesId);
517        } else {
518          CltDesc->ActiveHBeatRqP=true;
519          FetchSoapRq(CltDesc, TSoapRq::New(TAppCS::F_IsAlive));
520        }
521      }
522    }
523  }
524  PHttpResp TAppSrv::OnHttpRq_Broadcast(const PSoapRq& SoapRq){
525    IAssert(SoapRq->GetFuncNm()=="Broadcast");
526    TStr BcCmNm=SoapRq->GetFldVal("Cm");
527    TStr BcFldNm=SoapRq->GetFldVal("FldNm");
528    TStr BcFldVal=SoapRq->GetFldVal("FldVal");
529    TStr BcMsgStr=SoapRq->GetFldVal("Msg");
530    TAppCltDescV CltDescV; GetCltDescV(CltDescV);
531    for (int CltDescN=0; CltDescN<CltDescV.Len(); CltDescN++){
532      PAppCltDesc CltDesc=CltDescV[CltDescN];
533      FetchSoapRq(CltDesc, TSoapRq::New("Broadcast",
534       "Cm", BcCmNm, "FldNm", BcFldNm, "FldVal", BcFldVal, "Msg", BcMsgStr));
535    }
536    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm());
537  }
538  PHttpResp TAppSrv::OnFuncRq(const int &SockId, const PSoapRq& SoapRq, const PUrl& Url){
539    TStr FuncNm=SoapRq->GetFuncNm();
540    TStr CltNm;
541    if (SoapRq->IsFldNm(TAppCS::A_CltNm)){
542      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
543    }
544    if (CltNm.Empty()){
545      TStr _CltFuncNm; FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
546    }
547    PHttpResp HttpResp;
548    if (!CltNm.Empty()){
549      PAppCltDesc CltDesc;
550      if (IsGetCltDescByCltNm(CltNm, CltDesc)){
551        {TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
552        PAppCltDesc SoapRqCltDesc;
553        if (IsGetCltDescBySesId(SesId, SoapRqCltDesc)){
554          SoapRq->AddFldNmVal(TAppCS::LogA_CreatorNm, SoapRqCltDesc->CltNm);
555        }}
556        SoapRq->AddFldNmVal(TAppCS::A_Redir, "T");
557  #if 0
558        TStr RedirUrlStr=TStr()+
559         "http:&bsol;&bsol;"+CltDesc->HostNm+":"+TInt::GetStr(CltDesc->PortN)+"/"+
560         SoapRq->GetAsUrlPathStr();
561        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
562  #else
563        TStr DestHost, DestProxy, RedirHost;
564        ResolveCltIP(CltDesc,SockId,DestHost,DestProxy);
565        DestHost += ":"+TInt::GetStr(CltDesc->PortN);
566        if (!DestProxy.Empty()) {
567          DestProxy += ":"+TInt::GetStr(Proxy->GetPortN());
568          RedirHost=DestProxy;
569        } else {
570          RedirHost=DestHost;
571        }
572        TStr RedirUrlStr=TStr()+"http:&bsol;&bsol;"+RedirHost+"/"+SoapRq->GetAsUrlPathStr();
573        Log->PutLogMsg("Redirect", TStr()+GetPeerHostNm(SockId)+" -> "+RedirUrlStr);
574        HttpResp=THttpResp::New(300, "", false, NULL, RedirUrlStr);
575        if (!DestProxy.Empty()) HttpResp->AddFldVal(THttp::HostFldNm,DestHost);
576  #endif
577      } else {
578        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
579         TStr()+"Client for function call not active: "+CltNm, FuncNm);
580      }
581    } else {
582      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
583       "Unknown SOAP function call", FuncNm);
584    }
585    return HttpResp;
586  }
587  int TAppSrv::FetchSoapRq(const PAppCltDesc& CltDesc, const PSoapRq& SoapRq){
588    SoapRq->AddFldNmVal(TAppCS::A_SesId, CltDesc->SesId);
589    PUrl SoapRqUrl=SoapRq->GetAsUrl(CltDesc->HostNm, CltDesc->PortN);
590    int FetchId=FetchUrl(SoapRqUrl);
591    ActConnBs->AddActConn(FetchId,
592     TAppCSActConn::New(SoapRq, CltDesc->HostNm, CltDesc->PortN,1));
593    Log->PutLogMsg("FetchSoapRq",
594     TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr());
595    return FetchId;
596  }
597  void TAppSrv::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
598    PSoapResp SoapResp=TSoapResp::New(HttpResp);
599    if (SoapResp->IsOk()){
600      if (SoapResp->IsResult()){
601        TStr SoapRespFuncNm=SoapResp->GetFuncNm();
602        TStr SoapRespResultVal=SoapResp->GetFldVal(TAppCS::A_Result);
603        PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
604        TStr SoapRqFuncNm=SoapRq->GetFuncNm();
605        IAssert(SoapRqFuncNm==SoapRespFuncNm);
606        ActConnBs->DelActConn(FetchId);
607        if (SoapRespFuncNm==TAppCS::F_IsAlive){
608          TStr SoapRqSesId=SoapRq->GetFldVal(TAppCS::A_SesId); 
609          TStr SoapRespSesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
610          if (SoapRqSesId==SoapRespSesId){
611            PAppCltDesc CltDesc;
612            if (IsGetCltDescBySesId(SoapRespSesId, CltDesc)){ 
613              CltDesc->LastHBeatTm=TTm::GetCurUniTm(); 
614              CltDesc->ActiveHBeatRqP=false; 
615            }
616          } else {
617            Log->PutLogMsg("Warning",
618             "Session numbers (request & response) for IsAlive don't match.");
619          }
620        } else {
621          Log->PutLogMsg("Warning",
622           "Unhandled Soap-Response", SoapResp->GetAsUrlPathStr());
623        }
624      } else {
625        IAssert(SoapResp->IsFault());
626        OnHttpRespError(FetchId, TStr("SoapFault: ")+SoapResp->GetFaultReasonStr());
627      }
628    } else {
629      PSoapResp SoapResp=TSoapResp::New(HttpResp);
630      OnHttpRespError(FetchId, "Invalid SOAP Response");
631    }
632  }
633  void TAppSrv::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
634    PSoapRq SoapRq=ActConnBs->GetActConn(FetchId)->GetSoapRq();
635    Log->PutLogMsg("Error", MsgStr, SoapRq->GetAsUrlPathStr());
636    ActConnBs->DelActConn(FetchId);
637    TStr SesId=SoapRq->GetFldVal(TAppCS::A_SesId);
638    DelIfCltDesc(SesId);
639  }
640  const int TAppSrv::DfPortN=8888;
641  TAppClt::TAppClt(
642   const TStr& LogFNm,
643   const TStr& _CltNm,
644   const TStr& _CltType,
645   const int& HBeatTimerTout,
646   const bool& _AgentP,
647   const TStr& _SrvHostNm,
648   const int& _SrvPortN,
649   const int& CltPortN,
650   const PNotify& Notify):
651    TWebNetSrv(CltPortN, false), 
652    TWebNetCltV(), 
653    Log(TAppCSLog::New(LogFNm, -1, Notify)), 
654    CltNm(_CltNm), 
655    CltType(_CltType), 
656    SrvHostNm(_SrvHostNm), SrvPortN(_SrvPortN), 
657    AgentP(_AgentP), 
658    AgentHostNmPortNPrV(), 
659    HBeatTimer(), 
660    LastHBeatTm(TTm::GetCurUniTm()), 
661    ActiveIsAliveFId(-1), 
662    ActConnBs(TAppCSActConnBs::New()), 
663    SesId(), 
664    State(TAppCSState::New(Log)), 
665    DelayTimer(), 
666    FuncFetchIdH(){ 
667    HBeatTimer=TAppCSTimer::New(TAppCS::F_HBeatTimer,
668     CltNm, HBeatTimerTout, true, this);
669    DelayTimer=TAppCSTimer::New(TAppCS::F_DelayTimer, CltNm, 0, false, this);
670  }
671  TAppClt::~TAppClt(){
672    HBeatTimer->StopTimer();
673  }
674  const int TAppClt::DfPortN=TAppSrv::DfPortN+1;
675  void TAppClt::OnHttpRq(const int& SockId, const PHttpRq& HttpRq){
676    TTm CurTm=TTm::GetCurUniTm(); 
677    TStr FetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm);
678    PUrl Url=HttpRq->GetUrl(); 
679    TStr UrlStr=Url->GetUrlStr(); 
680    TStr PeerHostNm=GetPeerHostNm(SockId); 
681    PSoapRq SoapRq=TSoapRq::New(HttpRq); 
682    TStr SoapFuncNm=SoapRq->GetFuncNm();
683    TStr SoapRqMsgStr=UrlStr+" from "+PeerHostNm; 
684    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
685      PutLogMsg("SoapRequest", SoapRqMsgStr, true);}
686    PHttpResp HttpResp;
687    if (SoapRq->IsOk()){
688      if (SoapFuncNm==TAppCS::F_Info){
689        HttpResp=OnHttpRq_Info();
690      } else
691      if (SoapFuncNm==TAppCS::F_GetStateInfo){
692        HttpResp=OnHttpRq_GetStateInfo(SoapRq);
693      } else
694      if (SoapFuncNm==TAppCS::F_HBeatTimer){
695        OnHttpRq_OnHBeatTimer();
696      } else
697      if ((SoapFuncNm==TAppCS::F_IsAlive)||(SoapFuncNm==TAppCS::F_IsConn)){
698        HttpResp=TSoapResp::GetHttpResp(SoapFuncNm, TAppCS::A_SesId, SesId);
699      } else
700      if (SoapFuncNm==TAppCS::F_RegAgent){
701        HttpResp=OnHttpRq_RegAgent(SoapRq, PeerHostNm);
702      } else {
703        bool RedirP=SoapRq->GetFldVal(TAppCS::A_Redir)=="T";
704        bool AgentP=SoapRq->GetFldVal(TAppCS::A_Agent)=="T";
705        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&(!IsSesId())){
706          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
707           "Session not defined.");
708        } else
709        if ((SockId!=-1)&&(!RedirP)&&(!AgentP)&&
710         (GetSesId()!=SoapRq->GetFldVal(TAppCS::A_SesId))){
711          TStr SesId1=GetSesId();
712          TStr SesId2=SoapRq->GetFldVal(TAppCS::A_SesId);
713          HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
714           "Session-ids don't match.");
715        } else {
716          HttpResp=OnFuncRq(SoapRq);
717        }
718      }
719    } else {
720      HttpResp=TSoapResp::GetFaultHttpResp(TSoap::DataEncodingUnknownCodeNm,
721       "Invalid SOAP HTTP Request.");
722    }
723    if (SockId!=-1){
724      if (HttpResp.Empty()){
725        PutLogMsg("Warning", TStr("Empty Http-Response for ")+SoapRqMsgStr, true);
726        HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, "Empty Response.");
727      }
728      if (!FetchIdStr.Empty()){
729        HttpResp->AddFldVal(THttp::FetchIdFldNm, FetchIdStr);}
730      SendHttpResp(SockId, HttpResp);
731      if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
732        Log->PutLogRec(HttpRq, HttpResp, PeerHostNm);
733        PSoapResp SoapResp=TSoapResp::New(HttpResp);
734        if (SoapResp->IsOk()){
735          PutLogMsg("SoapResponse", SoapResp->GetAsUrlPathStr(), true);
736        }
737      }
738    }
739  }
740  void TAppClt::OnHttpRqError(const int& SockId, const TStr& MsgStr){
741  }
742  TStr TAppClt::GetPeerHostNm(const int& SockId) const {
743    if (SockId==-1){
744      return "internal";
745    } else {
746      TStr PeerHostNm=GetCltSock(SockId)->GetPeerIpNum();
747      if ((PeerHostNm.GetLc()=="localhost")||(PeerHostNm=="127.0.0.1")){
748        PSockHost LocalSockHost=TSockHost::GetLocalSockHost();
749        if (LocalSockHost->IsOk()){
750          return LocalSockHost->GetIpNum();
751        } else {
752          return PeerHostNm;
753        }
754      } else {
755        return PeerHostNm;
756      }
757    }
758  }
759  PHttpResp TAppClt::OnHttpRq_Info() const {
760    TTm CurTm=TTm::GetCurUniTm();
761    TChA HtmlChA;
762    HtmlChA+="<html><head><title>Application Client Status</title></head>";
763    HtmlChA+="<body>";
764    HtmlChA+="<h1>Application Client Status</h1>";
765    HtmlChA+="GMT-Time: ";
766    HtmlChA+=CurTm.GetWebLogDateStr()+" "+CurTm.GetWebLogTimeStr();
767    HtmlChA+="<br>";
768    HtmlChA+="Client Port: ";
769    HtmlChA+=TInt::GetStr(GetPortN());
770    HtmlChA+="<br>";
771    HtmlChA+="Client Up-Time (secs): ";
772    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetSecs());
773    HtmlChA+="<br>";
774    HtmlChA+="Server-Host-Name: ";
775    HtmlChA+=GetSrvHostNm();
776    HtmlChA+="<br>";
777    HtmlChA+="Server-Host-Name: ";
778    HtmlChA+=TInt::GetStr(SrvPortN);
779    HtmlChA+="<br>";
780    HtmlChA+="Log-File-Name: ";
781    HtmlChA+=GetLog()->GetLogFNm();
782    HtmlChA+="<br>";
783    HtmlChA+="Heart-Beat-TimeOut (msecs): ";
784    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTimeOut());
785    HtmlChA+="<br>";
786    HtmlChA+="Heart-Beat-Ticks: ";
787    HtmlChA+=TInt::GetStr(GetHBeatTimer()->GetTicks());
788    HtmlChA+="<br>";
789    HtmlChA+="</body>";
790    HtmlChA+="</html>";
791    PHttpResp HttpResp=THttpResp::New(
792     THttp::OkStatusCd, THttp::TextHtmlFldVal, false, TStrIn::New(HtmlChA));
793    return HttpResp;
794  }
795  PHttpResp TAppClt::OnHttpRq_GetStateInfo(const PSoapRq& SoapRq) const {
796    PSoapResp SoapResp=TSoapResp::New(SoapRq->GetFuncNm());
797    SoapResp->AddFldNmVal("StateId", State->GetStateId());
798    return SoapResp->GetHttpResp();
799  }
800  void TAppClt::OnHttpRq_OnHBeatTimer(){
801    if (IsSesId()){
802      if (ActiveIsAliveFId==-1){
803        ActiveIsAliveFId=FetchSoapRq(TSoapRq::New(TAppCS::F_IsAlive));
804      }
805    }
806  }
807  PHttpResp TAppClt::OnHttpRq_RegAgent(
808   const PSoapRq& SoapRq, const TStr& PeerHostNm){
809    TStr AgentHostNm=PeerHostNm;
810    int AgentPortN=SoapRq->GetFldVal(TAppCS::A_PortN).GetInt(0);
811    AgentHostNmPortNPrV.AddUnique(TStrIntPr(AgentHostNm, AgentPortN));
812    return TSoapResp::GetHttpResp(SoapRq->GetFuncNm(), TAppCS::A_Result, "T");
813  }
814  void TAppClt::OnHttpResp(const int& FetchId, const PHttpResp& HttpResp){
815    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
816    PSoapRq SoapRq=ActConn->GetSoapRq();
817    TStr SoapFuncNm=SoapRq->GetFuncNm();
818    PSoapResp SoapResp=TSoapResp::New(HttpResp);
819    ActConnBs->DelActConn(FetchId);
820    if (ActConn->GetRetryCnt()!=3) {
821      PutLogMsg("OnFetch",
822       TStr::Fmt("[FetchId:%d] %s", FetchId,
823        (TStr()+"SoapRq retry count="+TInt::GetStr(3-ActConn->GetRetryCnt())).CStr()), false);
824    }
825    if (TAppSrv::IsLogSoapFuncNm(SoapFuncNm)){
826      PutLogMsg("OnFetch",
827       TStr::Fmt("[FetchId:%d] %s", FetchId, SoapResp->GetAsUrlPathStr().CStr()), false);
828    }
829    if (!SoapResp->IsOk()){
830      PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm,
831       "Invalid SOAP Response format.");
832      SoapResp=TSoapResp::New(HttpResp);
833    }
834    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
835      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
836      if (SoapRespFuncNm==TAppCS::F_IsAlive){
837        LastHBeatTm=TTm::GetCurUniTm(); 
838        ActiveIsAliveFId=-1; 
839      } else {
840        SesId=""; 
841        ActiveIsAliveFId=-1; 
842        SetState(TAppCS::S_Start); 
843      }
844    }
845    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
846    OnFetchSoapResp(SoapRq, SoapResp);
847  }
848  void TAppClt::OnHttpRespError(const int& FetchId, const TStr& MsgStr){
849    PAppCSActConn ActConn=ActConnBs->GetActConn(FetchId);
850    PSoapRq SoapRq=ActConn->GetSoapRq();
851    int RetryCnt=ActConn->GetRetryCnt();
852    if (--RetryCnt>0) {
853      ActConnBs->DelActConn(FetchId);
854      IAssert(FetchId==FetchSoapRq(SoapRq,ActConn->GetHostNm(),ActConn->GetPortN(),RetryCnt,FetchId));
855      return;
856    }
857    PHttpResp HttpResp=TSoapResp::GetFaultHttpResp(TSoap::SenderCodeNm, MsgStr);
858    PSoapResp SoapResp=TSoapResp::New(HttpResp);
859    PutLogMsg("OnFetchError",
860     TStr::Fmt("[FetchId:%d] %s", FetchId, MsgStr.CStr()), false);
861    if ((ActiveIsAliveFId!=-1)&&(FetchId==ActiveIsAliveFId)){
862      SesId=""; 
863      ActiveIsAliveFId=-1; 
864      SetState(TAppCS::S_Start); 
865    }
866    ActConnBs->DelActConn(FetchId);
867    SoapResp->AddFldNmVal(TAppCS::A_FetchId, TInt::GetStr(FetchId));
868    OnFetchSoapResp(SoapRq, SoapResp);
869  }
870  int TAppClt::FetchSoapRq(
871   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN, const int &RetryCnt, const int &_FetchId){
872    if (IsSesId()){
873      SoapRq->AddFldNmVal(TAppCS::A_SesId, GetSesId());}
874    if (IsAgent()){
875      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");}
876    PUrl SoapRqUrl;
877    if (HostNm.Empty()){
878      SoapRqUrl=SoapRq->GetAsUrl(SrvHostNm, SrvPortN);
879    } else {
880      SoapRqUrl=SoapRq->GetAsUrl(HostNm, PortN);
881    }
882  #if 0
883    TStr CltNm, FuncNm=SoapRq->GetFuncNm();
884    if ((FuncNm!=TAppCS::F_Connect)&&SoapRq->IsFldNm(TAppCS::A_CltNm)){
885      CltNm=SoapRq->GetFldVal(TAppCS::A_CltNm);
886    }
887    if (CltNm.Empty()){
888      TStr _CltFuncNm;
889      FuncNm.SplitOnStr(CltNm, "::", _CltFuncNm);
890      if (_CltFuncNm.Empty()) CltNm.Clr();
891    }
892    int FetchId=FetchUrl(SoapRqUrl,_FetchId,CltNm);
893  #else
894    int FetchId=FetchUrl(SoapRqUrl,_FetchId);
895  #endif  
896    if (TAppSrv::IsLogSoapFuncNm(SoapRq->GetFuncNm())){
897      PutLogMsg("FetchSoapRq",
898       TInt::GetStr(FetchId, "[FetchId:%d]")+SoapRq->GetAsUrlPathStr(), false);
899    }
900    ActConnBs->AddActConn(FetchId,
901     TAppCSActConn::New(SoapRq, SoapRqUrl->GetHostNm(), SoapRqUrl->GetPortN(), RetryCnt));
902    return FetchId;
903  }
904  void TAppClt::OnFetchSoapResp(const PSoapRq& SoapRq, const PSoapResp& SoapResp){
905    IAssert(SoapRq->IsOk());
906    IAssert(SoapResp->IsOk());
907    if (SoapResp->IsResult()){
908      TStr SoapRespFuncNm=SoapResp->GetFuncNm();
909      if (SoapRespFuncNm==TAppCS::F_Connect){
910        SesId=SoapResp->GetFldVal(TAppCS::A_SesId); 
911        OnStateExe(setSoapResp, SoapRq, SoapResp); 
912      } else
913      if (SoapRespFuncNm==TAppCS::F_IsAlive){
914      } else
915      if (SoapRespFuncNm==TAppCS::F_NotifyStateChange){
916      } else
917      if (SoapRespFuncNm==TAppCS::F_NotifyEvent){
918      } else
919      if (SoapRespFuncNm==TAppCS::F_Log){
920      } else {
921        OnFuncResp(SoapRq, SoapResp);
922      }
923    } else {
924      IAssert(SoapResp->IsFault());
925      OnStateExe(setSoapResp, SoapRq, SoapResp); 
926    }
927  }
928  void TAppClt::PutLogMsg(
929   const TStr& MsgType, const TStr& MsgStr, const bool& SendToSrvP){
930    Log->PutLogMsg(MsgType, MsgStr);
931    if ((false)&&(SendToSrvP)){
932      FetchSoapRq(TSoapRq::New(TAppCS::F_Log,
933       TAppCS::A_LogNm, CltNm,
934       TAppCS::A_MsgType, MsgType,
935       TAppCS::A_Msg, MsgStr));
936    }
937  }
938  PHttpResp TAppClt::OnConnectRqAndResp(
939   const TStr& NextSId,
940   const TAppCsSET& ExeType, const PSoapRq& SoapRq, const PSoapResp& SoapResp,
941   bool& BreakLoopP){
942    PAppCSLog Log; PAppCSState State; TStr StateId;
943    TStr RqFuncNm; TStr RespFuncNm; TStr RespFetchId; bool RespResultP;
944    GetStateExeShortcuts(Log, State, StateId,
945     SoapRq, RqFuncNm, SoapResp, RespFuncNm, RespFetchId, RespResultP);
946    BreakLoopP=true;
947    if (StateId==TAppCS::S_ConnectRq){
948      if (IsSesId()){
949        SesId="";
950      }
951      FetchSoapRqSaveFId(TSoapRq::New(TAppCS::F_Connect,
952       TAppCS::A_PortN, TInt::GetStr(GetPortN()),
953       TAppCS::A_CltNm, GetCltNm()));
954      SetState(TAppCS::S_ConnectResp);
955      return NULL;
956    } else
957    if (StateId==TAppCS::S_ConnectResp){
958      if ((GetFId(TAppCS::F_Connect)==RespFetchId)&&(RespResultP)){
959        SetState(NextSId);
960      } else {
961        StartDelayTimer();
962        SetState(TAppCS::S_ConnectRq);
963        return NULL;
964      }
965    }
966    BreakLoopP=false;
967    return NULL;
968  }
969  void TAppClt::StartDelayTimer(const int& DelayTout){
970    if (DelayTout==-1){
971      DelayTimer->StartTimer(TAppCS::DTmrA_DelayTimerTout);
972    } else {
973      DelayTimer->StartTimer(DelayTout);
974    }
975  }
976  void TAppClt::StopDelayTimer(){
977    DelayTimer->StopTimer();
978  }
979  int TAppClt::FetchSoapRqSaveFId(
980   const PSoapRq& SoapRq, const TStr& HostNm, const int& PortN){
981    int FetchId=FetchSoapRq(SoapRq, HostNm, PortN);
982    PutFId(SoapRq->GetFuncNm(), TInt::GetStr(FetchId));
983    return FetchId;
984  }
985  void TAppClt::GetStateExeShortcuts(
986   PAppCSLog& Log,
987   PAppCSState& State, TStr& StateId,
988   const PSoapRq& SoapRq, TStr& SoapRqFuncNm,
989   const PSoapResp& SoapResp, TStr& SoapRespFuncNm, TStr& SoapRespFetchId,
990   bool& SoapRespResultP){
991    Log=GetLog();
992    State=GetState();
993    StateId=State->GetStateId();
994    if (SoapRq.Empty()){
995      SoapRqFuncNm="";
996    } else {
997      SoapRqFuncNm=SoapRq->GetFuncNm();
998    }
999    if (SoapResp.Empty()){
1000      SoapRespFuncNm="";
1001      SoapRespFetchId="";
1002      SoapRespResultP=false;
1003    } else {
1004      SoapRespFuncNm=SoapResp->GetFuncNm();
1005      SoapRespFetchId=SoapResp->GetFldVal(TAppCS::A_FetchId);
1006      SoapRespResultP=SoapResp->IsResult();
1007    }
1008  }
1009  void TAppClt::BroadcastToAgents(const PSoapRq& SoapRq){
1010    if (GetAgents()>0){
1011      SoapRq->AddFldNmVal(TAppCS::A_Agent, "T");
1012      for (int AgentN=0; AgentN<GetAgents(); AgentN++){
1013        TStr HostNm; int PortN; GetAgentHostNmPortN(AgentN, HostNm, PortN);
1014        FetchSoapRq(SoapRq, HostNm, PortN);
1015      }
1016    }
1017  }
1018  void TAppClt::SetState(const TStr& StateId, const TStr& MsgStr,
1019   const TStr& TbNm1, const PSoapTb& Tb1,
1020   const TStr& TbNm2, const PSoapTb& Tb2){
1021    TStr OldStateId=State->GetStateId();
1022    State->SetState(StateId);
1023    TStr NewStateId=State->GetStateId();
1024    if (GetAgents()>0){
1025    }
1026  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-winmain.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-appsrv.cpp</div>
                <div class="column column_space"><pre><code>478  	auto upNotepadWindow = std::make_unique<Notepad_plus_Window>();
479  	Notepad_plus_Window & notepad_plus_plus = *upNotepadWindow.get();
480  	generic_string updaterDir = nppParameters.getNppPath();
481  	updaterDir += TEXT("\\updater\\");
482  	generic_string updaterFullPath = updaterDir + TEXT("gup.exe");
483  	generic_string updaterParams = TEXT("-v");
484  	updaterParams += VERSION_VALUE;
485  	bool isUpExist = nppGui._doesExistUpdater = (::PathFileExists(updaterFullPath.c_str()) == TRUE);
</pre></code></div>
                <div class="column column_space"><pre><code>20  TStr TAppCS::A_OldState="OldState";
21  TStr TAppCS::A_NewState="NewState";
22  TStr TAppCS::A_AbortState="AbortState";
23  TStr TAppCS::A_SetStateTm="SetStateTm";
24  TStr TAppCS::A_LogNm="LogNm";
25  TStr TAppCS::F_Info="Info";
26  TStr TAppCS::F_GetStateInfo="GetStateInfo";
27  TStr TAppCS::F_GetCltList="GetCltList";
28  TStr TAppCS::F_GetCltInfo="GetCltInfo";
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    