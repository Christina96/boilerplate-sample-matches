
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 41, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCSS.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsAWordChar(const unsigned int ch) {
20  	return ch >= 0x80 || isalnum(ch) || ch == '-' || ch == '_';
21  }
22  inline bool IsCssOperator(const int ch) {
23  	if (!((ch < 0x80) && isalnum(ch)) &&
24  		(ch == '{' || ch == '}' || ch == ':' || ch == ',' || ch == ';' ||
25  		 ch == '.' || ch == '#' || ch == '!' || ch == '@' ||
26  		 ch == '*' || ch == '>' || ch == '+' || ch == '=' || ch == '~' || ch == '|' ||
27  		 ch == '[' || ch == ']' || ch == '(' || ch == ')')) {
28  		return true;
29  	}
30  	return false;
31  }
32  inline int NestingLevelLookBehind(Sci_PositionU startPos, Accessor &styler) {
33  	int ch;
34  	int nestingLevel = 0;
35  	for (Sci_PositionU i = 0; i < startPos; i++) {
36  		ch = styler.SafeGetCharAt(i);
37  		if (ch == '{')
38  			nestingLevel++;
39  		else if (ch == '}')
40  			nestingLevel--;
41  	}
42  	return nestingLevel;
43  }
44  static void ColouriseCssDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[], Accessor &styler) {
45  	WordList &css1Props = *keywordlists[0];
46  	WordList &pseudoClasses = *keywordlists[1];
47  	WordList &css2Props = *keywordlists[2];
48  	WordList &css3Props = *keywordlists[3];
49  	WordList &pseudoElements = *keywordlists[4];
50  	WordList &exProps = *keywordlists[5];
51  	WordList &exPseudoClasses = *keywordlists[6];
52  	WordList &exPseudoElements = *keywordlists[7];
53  	StyleContext sc(startPos, length, initStyle, styler);
54  	int lastState = -1; 
55  	int lastStateC = -1; 
56  	int lastStateS = -1; 
57  	int lastStateVar = -1; 
58  	int lastStateVal = -1; 
59  	int op = ' '; 
60  	int opPrev = ' '; 
61  	bool insideParentheses = false; 
62  	bool isScssDocument = styler.GetPropertyInt("lexer.css.scss.language") != 0;
63  	bool isLessDocument = styler.GetPropertyInt("lexer.css.less.language") != 0;
64  	bool isHssDocument = styler.GetPropertyInt("lexer.css.hss.language") != 0;
65  	bool hasVariables = isScssDocument || isLessDocument || isHssDocument;
66  	char varPrefix = 0;
67  	if (hasVariables)
68  		varPrefix = isLessDocument ? '@' : '$';
69  	typedef enum _CommentModes { eCommentBlock = 0, eCommentLine = 1} CommentMode;
70  	CommentMode comment_mode = eCommentBlock;
71  	bool hasSingleLineComments = isScssDocument || isLessDocument || isHssDocument;
72  	bool hasNesting = false;
73  	int nestingLevel = 0;
74  	if (isScssDocument || isLessDocument || isHssDocument) {
75  		hasNesting = true;
76  		nestingLevel = NestingLevelLookBehind(startPos, styler);
77  	}
78  	for (; sc.More(); sc.Forward()) {
79  		if (sc.state == SCE_CSS_COMMENT && ((comment_mode == eCommentBlock && sc.Match('*', '/')) || (comment_mode == eCommentLine && sc.atLineEnd))) {
80  			if (lastStateC == -1) {
81  				Sci_PositionU i = startPos;
82  				for (; i > 0; i--) {
83  					if ((lastStateC = styler.StyleAt(i-1)) != SCE_CSS_COMMENT) {
84  						if (lastStateC == SCE_CSS_OPERATOR) {
85  							op = styler.SafeGetCharAt(i-1);
86  							opPrev = styler.SafeGetCharAt(i-2);
87  							while (--i) {
88  								lastState = styler.StyleAt(i-1);
89  								if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
90  									break;
91  							}
92  							if (i == 0)
93  								lastState = SCE_CSS_DEFAULT;
94  						}
95  						break;
96  					}
97  				}
98  				if (i == 0)
99  					lastStateC = SCE_CSS_DEFAULT;
100  			}
101  			if (comment_mode == eCommentBlock) {
102  				sc.Forward();
103  				sc.ForwardSetState(lastStateC);
104  			} else &bsol;* eCommentLine */ {
105  				sc.SetState(lastStateC);
106  			}
107  		}
108  		if (sc.state == SCE_CSS_COMMENT)
109  			continue;
110  		if (sc.state == SCE_CSS_DOUBLESTRING || sc.state == SCE_CSS_SINGLESTRING) {
111  			if (sc.ch != (sc.state == SCE_CSS_DOUBLESTRING ? '\"' : '\''))
112  				continue;
113  			Sci_PositionU i = sc.currentPos;
114  			while (i && styler[i-1] == '\\')
115  				i--;
116  			if ((sc.currentPos - i) % 2 == 1)
117  				continue;
118  			sc.ForwardSetState(lastStateS);
119  		}
120  		if (sc.state == SCE_CSS_OPERATOR) {
121  			if (op == ' ') {
122  				Sci_PositionU i = startPos;
123  				op = styler.SafeGetCharAt(i-1);
<span onclick='openModal()' class='match'>124  				opPrev = styler.SafeGetCharAt(i-2);
125  				while (--i) {
126  					lastState = styler.StyleAt(i-1);
127  					if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
128  						break;
129  				}
130  			}
</span>131  			switch (op) {
132  			case '@':
133  				if (lastState == SCE_CSS_DEFAULT || hasNesting)
134  					sc.SetState(SCE_CSS_DIRECTIVE);
135  				break;
136  			case '>':
137  			case '+':
138  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
139  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
140  					sc.SetState(SCE_CSS_DEFAULT);
141  				break;
142  			case '[':
143  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
144  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
145  					sc.SetState(SCE_CSS_ATTRIBUTE);
146  				break;
147  			case ']':
148  				if (lastState == SCE_CSS_ATTRIBUTE)
149  					sc.SetState(SCE_CSS_TAG);
150  				break;
151  			case '{':
152  				nestingLevel++;
153  				switch (lastState) {
154  				case SCE_CSS_GROUP_RULE:
155  					sc.SetState(SCE_CSS_DEFAULT);
156  					break;
157  				case SCE_CSS_TAG:
158  				case SCE_CSS_DIRECTIVE:
159  					sc.SetState(SCE_CSS_IDENTIFIER);
160  					break;
161  				}
162  				break;
163  			case '}':
164  				if (--nestingLevel < 0)
165  					nestingLevel = 0;
166  				switch (lastState) {
167  				case SCE_CSS_DEFAULT:
168  				case SCE_CSS_VALUE:
169  				case SCE_CSS_IMPORTANT:
170  				case SCE_CSS_IDENTIFIER:
171  				case SCE_CSS_IDENTIFIER2:
172  				case SCE_CSS_IDENTIFIER3:
173  					if (hasNesting)
174  						sc.SetState(nestingLevel > 0 ? SCE_CSS_IDENTIFIER : SCE_CSS_DEFAULT);
175  					else
176  						sc.SetState(SCE_CSS_DEFAULT);
177  					break;
178  				}
179  				break;
180  			case '(':
181  				if (lastState == SCE_CSS_PSEUDOCLASS)
182  					sc.SetState(SCE_CSS_TAG);
183  				else if (lastState == SCE_CSS_EXTENDED_PSEUDOCLASS)
184  					sc.SetState(SCE_CSS_EXTENDED_PSEUDOCLASS);
185  				break;
186  			case ')':
187  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
188  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS ||
189  					lastState == SCE_CSS_PSEUDOELEMENT || lastState == SCE_CSS_EXTENDED_PSEUDOELEMENT)
190  					sc.SetState(SCE_CSS_TAG);
191  				break;
192  			case ':':
193  				switch (lastState) {
194  				case SCE_CSS_TAG:
195  				case SCE_CSS_DEFAULT:
196  				case SCE_CSS_CLASS:
197  				case SCE_CSS_ID:
198  				case SCE_CSS_PSEUDOCLASS:
199  				case SCE_CSS_EXTENDED_PSEUDOCLASS:
200  				case SCE_CSS_UNKNOWN_PSEUDOCLASS:
201  				case SCE_CSS_PSEUDOELEMENT:
202  				case SCE_CSS_EXTENDED_PSEUDOELEMENT:
203  					sc.SetState(SCE_CSS_PSEUDOCLASS);
204  					break;
205  				case SCE_CSS_IDENTIFIER:
206  				case SCE_CSS_IDENTIFIER2:
207  				case SCE_CSS_IDENTIFIER3:
208  				case SCE_CSS_EXTENDED_IDENTIFIER:
209  				case SCE_CSS_UNKNOWN_IDENTIFIER:
210  				case SCE_CSS_VARIABLE:
211  					sc.SetState(SCE_CSS_VALUE);
212  					lastStateVal = lastState;
213  					break;
214  				}
215  				break;
216  			case '.':
217  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
218  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
219  					sc.SetState(SCE_CSS_CLASS);
220  				break;
221  			case '#':
222  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
223  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
224  					sc.SetState(SCE_CSS_ID);
225  				break;
226  			case ',':
227  			case '|':
228  			case '~':
229  				if (lastState == SCE_CSS_TAG)
230  					sc.SetState(SCE_CSS_DEFAULT);
231  				break;
232  			case ';':
233  				switch (lastState) {
234  				case SCE_CSS_DIRECTIVE:
235  					if (hasNesting) {
236  						sc.SetState(nestingLevel > 0 ? SCE_CSS_IDENTIFIER : SCE_CSS_DEFAULT);
237  					} else {
238  						sc.SetState(SCE_CSS_DEFAULT);
239  					}
240  					break;
241  				case SCE_CSS_VALUE:
242  				case SCE_CSS_IMPORTANT:
243  					if (insideParentheses) {
244  						sc.SetState(lastState);
245  					} else {
246  						if (lastStateVal == SCE_CSS_VARIABLE) {
247  							sc.SetState(SCE_CSS_DEFAULT);
248  						} else {
249  							sc.SetState(SCE_CSS_IDENTIFIER);
250  						}
251  					}
252  					break;
253  				case SCE_CSS_VARIABLE:
254  					if (lastStateVar == SCE_CSS_VALUE) {
255  						if (insideParentheses) {
256  							sc.SetState(SCE_CSS_VALUE);
257  						} else {
258  							sc.SetState(SCE_CSS_IDENTIFIER);
259  						}
260  					} else {
261  						sc.SetState(SCE_CSS_DEFAULT);
262  					}
263  					break;
264  				}
265  				break;
266  			case '!':
267  				if (lastState == SCE_CSS_VALUE)
268  					sc.SetState(SCE_CSS_IMPORTANT);
269  				break;
270  			}
271  		}
272  		if (sc.ch == '*' && sc.state == SCE_CSS_DEFAULT) {
273  			sc.SetState(SCE_CSS_TAG);
274  			continue;
275  		}
276  		if (sc.ch == '(')
277  			insideParentheses = true;
278  		else if (sc.ch == ')')
279  			insideParentheses = false;
280  		if (hasVariables) {
281  			if (sc.ch == varPrefix) {
282  				switch (sc.state) {
283  				case SCE_CSS_DEFAULT:
284  					if (isLessDocument) 
285  						break;
286  				case SCE_CSS_VALUE:
287  					lastStateVar = sc.state;
288  					sc.SetState(SCE_CSS_VARIABLE);
289  					continue;
290  				}
291  			}
292  			if (sc.state == SCE_CSS_VARIABLE) {
293  				if (IsAWordChar(sc.ch)) {
294  					continue;
295  				}
296  				if (lastStateVar == SCE_CSS_VALUE) {
297  					sc.SetState(SCE_CSS_VALUE);
298  				}
299  			}
300  			if (sc.ch == '&') {
301  				switch (sc.state) {
302  				case SCE_CSS_DEFAULT:
303  				case SCE_CSS_IDENTIFIER:
304  					sc.SetState(SCE_CSS_TAG);
305  					continue;
306  				}
307  			}
308  		}
309  		if (hasNesting) {
310  			if (sc.state == SCE_CSS_IDENTIFIER && (IsAWordChar(sc.ch) || sc.ch == ':' || sc.ch == '.' || sc.ch == '#')) {
311  				Sci_PositionU endPos = startPos + length;
312  				int ch;
313  				for (Sci_PositionU i = sc.currentPos; i < endPos; i++) {
314  					ch = styler.SafeGetCharAt(i);
315  					if (ch == ';' || ch == '}')
316  						break;
317  					if (ch == '{') {
318  						sc.SetState(SCE_CSS_DEFAULT);
319  						continue;
320  					}
321  				}
322  			}
323  		}
324  		if (IsAWordChar(sc.ch)) {
325  			if (sc.state == SCE_CSS_DEFAULT)
326  				sc.SetState(SCE_CSS_TAG);
327  			continue;
328  		}
329  		if (IsAWordChar(sc.chPrev) && (
330  			sc.state == SCE_CSS_IDENTIFIER || sc.state == SCE_CSS_IDENTIFIER2 ||
331  			sc.state == SCE_CSS_IDENTIFIER3 || sc.state == SCE_CSS_EXTENDED_IDENTIFIER ||
332  			sc.state == SCE_CSS_UNKNOWN_IDENTIFIER ||
333  			sc.state == SCE_CSS_PSEUDOCLASS || sc.state == SCE_CSS_PSEUDOELEMENT ||
334  			sc.state == SCE_CSS_EXTENDED_PSEUDOCLASS || sc.state == SCE_CSS_EXTENDED_PSEUDOELEMENT ||
335  			sc.state == SCE_CSS_UNKNOWN_PSEUDOCLASS ||
336  			sc.state == SCE_CSS_IMPORTANT ||
337  			sc.state == SCE_CSS_DIRECTIVE
338  		)) {
339  			char s[100];
340  			sc.GetCurrentLowered(s, sizeof(s));
341  			char *s2 = s;
342  			while (*s2 && !IsAWordChar(*s2))
343  				s2++;
344  			switch (sc.state) {
345  			case SCE_CSS_IDENTIFIER:
346  			case SCE_CSS_IDENTIFIER2:
347  			case SCE_CSS_IDENTIFIER3:
348  			case SCE_CSS_EXTENDED_IDENTIFIER:
349  			case SCE_CSS_UNKNOWN_IDENTIFIER:
350  				if (css1Props.InList(s2))
351  					sc.ChangeState(SCE_CSS_IDENTIFIER);
352  				else if (css2Props.InList(s2))
353  					sc.ChangeState(SCE_CSS_IDENTIFIER2);
354  				else if (css3Props.InList(s2))
355  					sc.ChangeState(SCE_CSS_IDENTIFIER3);
356  				else if (exProps.InList(s2))
357  					sc.ChangeState(SCE_CSS_EXTENDED_IDENTIFIER);
358  				else
359  					sc.ChangeState(SCE_CSS_UNKNOWN_IDENTIFIER);
360  				break;
361  			case SCE_CSS_PSEUDOCLASS:
362  			case SCE_CSS_PSEUDOELEMENT:
363  			case SCE_CSS_EXTENDED_PSEUDOCLASS:
364  			case SCE_CSS_EXTENDED_PSEUDOELEMENT:
365  			case SCE_CSS_UNKNOWN_PSEUDOCLASS:
366  				if (op == ':' && opPrev != ':' && pseudoClasses.InList(s2))
367  					sc.ChangeState(SCE_CSS_PSEUDOCLASS);
368  				else if (opPrev == ':' && pseudoElements.InList(s2))
369  					sc.ChangeState(SCE_CSS_PSEUDOELEMENT);
370  				else if ((op == ':' || (op == '(' && lastState == SCE_CSS_EXTENDED_PSEUDOCLASS)) && opPrev != ':' && exPseudoClasses.InList(s2))
371  					sc.ChangeState(SCE_CSS_EXTENDED_PSEUDOCLASS);
372  				else if (opPrev == ':' && exPseudoElements.InList(s2))
373  					sc.ChangeState(SCE_CSS_EXTENDED_PSEUDOELEMENT);
374  				else
375  					sc.ChangeState(SCE_CSS_UNKNOWN_PSEUDOCLASS);
376  				break;
377  			case SCE_CSS_IMPORTANT:
378  				if (strcmp(s2, "important") != 0)
379  					sc.ChangeState(SCE_CSS_VALUE);
380  				break;
381  			case SCE_CSS_DIRECTIVE:
382  				if (op == '@' && (strcmp(s2, "media") == 0 || strcmp(s2, "supports") == 0 || strcmp(s2, "document") == 0 || strcmp(s2, "-moz-document") == 0))
383  					sc.ChangeState(SCE_CSS_GROUP_RULE);
384  				break;
385  			}
386  		}
387  		if (sc.ch != '.' && sc.ch != ':' && sc.ch != '#' && (
388  			sc.state == SCE_CSS_CLASS || sc.state == SCE_CSS_ID ||
389  			(sc.ch != '(' && sc.ch != ')' && ( &bsol;* This line of the condition makes it possible to extend pseudo-classes with parentheses */
390  				sc.state == SCE_CSS_PSEUDOCLASS || sc.state == SCE_CSS_PSEUDOELEMENT ||
391  				sc.state == SCE_CSS_EXTENDED_PSEUDOCLASS || sc.state == SCE_CSS_EXTENDED_PSEUDOELEMENT ||
392  				sc.state == SCE_CSS_UNKNOWN_PSEUDOCLASS
393  			))
394  		))
395  			sc.SetState(SCE_CSS_TAG);
396  		if (sc.Match('/', '*')) {
397  			lastStateC = sc.state;
398  			comment_mode = eCommentBlock;
399  			sc.SetState(SCE_CSS_COMMENT);
400  			sc.Forward();
401  		} else if (hasSingleLineComments && sc.Match('/', '/') && !insideParentheses) {
402  			lastStateC = sc.state;
403  			comment_mode = eCommentLine;
404  			sc.SetState(SCE_CSS_COMMENT);
405  			sc.Forward();
406  		} else if ((sc.state == SCE_CSS_VALUE || sc.state == SCE_CSS_ATTRIBUTE)
407  			&& (sc.ch == '\"' || sc.ch == '\'')) {
408  			lastStateS = sc.state;
409  			sc.SetState((sc.ch == '\"' ? SCE_CSS_DOUBLESTRING : SCE_CSS_SINGLESTRING));
410  		} else if (IsCssOperator(sc.ch)
411  			&& (sc.state != SCE_CSS_ATTRIBUTE || sc.ch == ']')
412  			&& (sc.state != SCE_CSS_VALUE || sc.ch == ';' || sc.ch == '}' || sc.ch == '!')
413  			&& ((sc.state != SCE_CSS_DIRECTIVE && sc.state != SCE_CSS_GROUP_RULE) || sc.ch == ';' || sc.ch == '{')
414  		) {
415  			if (sc.state != SCE_CSS_OPERATOR)
416  				lastState = sc.state;
417  			sc.SetState(SCE_CSS_OPERATOR);
418  			op = sc.ch;
419  			opPrev = sc.chPrev;
420  		}
421  	}
422  	sc.Complete();
423  }
424  static void FoldCSSDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler) {
425  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
426  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
427  	Sci_PositionU endPos = startPos + length;
428  	int visibleChars = 0;
429  	Sci_Position lineCurrent = styler.GetLine(startPos);
430  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
431  	int levelCurrent = levelPrev;
432  	char chNext = styler[startPos];
433  	bool inComment = (styler.StyleAt(startPos-1) == SCE_CSS_COMMENT);
434  	for (Sci_PositionU i = startPos; i < endPos; i++) {
435  		char ch = chNext;
436  		chNext = styler.SafeGetCharAt(i + 1);
437  		int style = styler.StyleAt(i);
438  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
439  		if (foldComment) {
440  			if (!inComment && (style == SCE_CSS_COMMENT))
441  				levelCurrent++;
442  			else if (inComment && (style != SCE_CSS_COMMENT))
443  				levelCurrent--;
444  			inComment = (style == SCE_CSS_COMMENT);
445  		}
446  		if (style == SCE_CSS_OPERATOR) {
447  			if (ch == '{') {
448  				levelCurrent++;
449  			} else if (ch == '}') {
450  				levelCurrent--;
451  			}
452  		}
453  		if (atEOL) {
454  			int lev = levelPrev;
455  			if (visibleChars == 0 && foldCompact)
456  				lev |= SC_FOLDLEVELWHITEFLAG;
457  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
458  				lev |= SC_FOLDLEVELHEADERFLAG;
459  			if (lev != styler.LevelAt(lineCurrent)) {
460  				styler.SetLevel(lineCurrent, lev);
461  			}
462  			lineCurrent++;
463  			levelPrev = levelCurrent;
464  			visibleChars = 0;
465  		}
466  		if (!isspacechar(ch))
467  			visibleChars++;
468  	}
469  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
470  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
471  }
472  static const char * const cssWordListDesc[] = {
473  	"CSS1 Properties",
474  	"Pseudo-classes",
475  	"CSS2 Properties",
476  	"CSS3 Properties",
477  	"Pseudo-elements",
478  	"Browser-Specific CSS Properties",
479  	"Browser-Specific Pseudo-classes",
480  	"Browser-Specific Pseudo-elements",
481  	0
482  };
483  LexerModule lmCss(SCLEX_CSS, ColouriseCssDoc, "css", FoldCSSDoc, cssWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCSS.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static inline bool IsAWordChar(const unsigned int ch) {
20  	return ch >= 0x80 || isalnum(ch) || ch == '-' || ch == '_';
21  }
22  inline bool IsCssOperator(const int ch) {
23  	if (!((ch < 0x80) && isalnum(ch)) &&
24  		(ch == '{' || ch == '}' || ch == ':' || ch == ',' || ch == ';' ||
25  		 ch == '.' || ch == '#' || ch == '!' || ch == '@' ||
26  		 ch == '*' || ch == '>' || ch == '+' || ch == '=' || ch == '~' || ch == '|' ||
27  		 ch == '[' || ch == ']' || ch == '(' || ch == ')')) {
28  		return true;
29  	}
30  	return false;
31  }
32  inline int NestingLevelLookBehind(Sci_PositionU startPos, Accessor &styler) {
33  	int ch;
34  	int nestingLevel = 0;
35  	for (Sci_PositionU i = 0; i < startPos; i++) {
36  		ch = styler.SafeGetCharAt(i);
37  		if (ch == '{')
38  			nestingLevel++;
39  		else if (ch == '}')
40  			nestingLevel--;
41  	}
42  	return nestingLevel;
43  }
44  static void ColouriseCssDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[], Accessor &styler) {
45  	WordList &css1Props = *keywordlists[0];
46  	WordList &pseudoClasses = *keywordlists[1];
47  	WordList &css2Props = *keywordlists[2];
48  	WordList &css3Props = *keywordlists[3];
49  	WordList &pseudoElements = *keywordlists[4];
50  	WordList &exProps = *keywordlists[5];
51  	WordList &exPseudoClasses = *keywordlists[6];
52  	WordList &exPseudoElements = *keywordlists[7];
53  	StyleContext sc(startPos, length, initStyle, styler);
54  	int lastState = -1; 
55  	int lastStateC = -1; 
56  	int lastStateS = -1; 
57  	int lastStateVar = -1; 
58  	int lastStateVal = -1; 
59  	int op = ' '; 
60  	int opPrev = ' '; 
61  	bool insideParentheses = false; 
62  	bool isScssDocument = styler.GetPropertyInt("lexer.css.scss.language") != 0;
63  	bool isLessDocument = styler.GetPropertyInt("lexer.css.less.language") != 0;
64  	bool isHssDocument = styler.GetPropertyInt("lexer.css.hss.language") != 0;
65  	bool hasVariables = isScssDocument || isLessDocument || isHssDocument;
66  	char varPrefix = 0;
67  	if (hasVariables)
68  		varPrefix = isLessDocument ? '@' : '$';
69  	typedef enum _CommentModes { eCommentBlock = 0, eCommentLine = 1} CommentMode;
70  	CommentMode comment_mode = eCommentBlock;
71  	bool hasSingleLineComments = isScssDocument || isLessDocument || isHssDocument;
72  	bool hasNesting = false;
73  	int nestingLevel = 0;
74  	if (isScssDocument || isLessDocument || isHssDocument) {
75  		hasNesting = true;
76  		nestingLevel = NestingLevelLookBehind(startPos, styler);
77  	}
78  	for (; sc.More(); sc.Forward()) {
79  		if (sc.state == SCE_CSS_COMMENT && ((comment_mode == eCommentBlock && sc.Match('*', '/')) || (comment_mode == eCommentLine && sc.atLineEnd))) {
80  			if (lastStateC == -1) {
81  				Sci_PositionU i = startPos;
82  				for (; i > 0; i--) {
83  					if ((lastStateC = styler.StyleAt(i-1)) != SCE_CSS_COMMENT) {
84  						if (lastStateC == SCE_CSS_OPERATOR) {
85  							op = styler.SafeGetCharAt(i-1);
86  							opPrev = styler.SafeGetCharAt(i-2);
87  							while (--i) {
88  								lastState = styler.StyleAt(i-1);
89  								if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
90  									break;
91  							}
92  							if (i == 0)
93  								lastState = SCE_CSS_DEFAULT;
94  						}
95  						break;
96  					}
97  				}
98  				if (i == 0)
99  					lastStateC = SCE_CSS_DEFAULT;
100  			}
101  			if (comment_mode == eCommentBlock) {
102  				sc.Forward();
103  				sc.ForwardSetState(lastStateC);
104  			} else &bsol;* eCommentLine */ {
105  				sc.SetState(lastStateC);
106  			}
107  		}
108  		if (sc.state == SCE_CSS_COMMENT)
109  			continue;
110  		if (sc.state == SCE_CSS_DOUBLESTRING || sc.state == SCE_CSS_SINGLESTRING) {
111  			if (sc.ch != (sc.state == SCE_CSS_DOUBLESTRING ? '\"' : '\''))
112  				continue;
113  			Sci_PositionU i = sc.currentPos;
114  			while (i && styler[i-1] == '\\')
115  				i--;
116  			if ((sc.currentPos - i) % 2 == 1)
117  				continue;
118  			sc.ForwardSetState(lastStateS);
119  		}
120  		if (sc.state == SCE_CSS_OPERATOR) {
121  			if (op == ' ') {
122  				Sci_PositionU i = startPos;
123  				op = styler.SafeGetCharAt(i-1);
<span onclick='openModal()' class='match'>124  				opPrev = styler.SafeGetCharAt(i-2);
125  				while (--i) {
126  					lastState = styler.StyleAt(i-1);
127  					if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
128  						break;
129  				}
130  			}
</span>131  			switch (op) {
132  			case '@':
133  				if (lastState == SCE_CSS_DEFAULT || hasNesting)
134  					sc.SetState(SCE_CSS_DIRECTIVE);
135  				break;
136  			case '>':
137  			case '+':
138  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
139  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
140  					sc.SetState(SCE_CSS_DEFAULT);
141  				break;
142  			case '[':
143  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
144  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
145  					sc.SetState(SCE_CSS_ATTRIBUTE);
146  				break;
147  			case ']':
148  				if (lastState == SCE_CSS_ATTRIBUTE)
149  					sc.SetState(SCE_CSS_TAG);
150  				break;
151  			case '{':
152  				nestingLevel++;
153  				switch (lastState) {
154  				case SCE_CSS_GROUP_RULE:
155  					sc.SetState(SCE_CSS_DEFAULT);
156  					break;
157  				case SCE_CSS_TAG:
158  				case SCE_CSS_DIRECTIVE:
159  					sc.SetState(SCE_CSS_IDENTIFIER);
160  					break;
161  				}
162  				break;
163  			case '}':
164  				if (--nestingLevel < 0)
165  					nestingLevel = 0;
166  				switch (lastState) {
167  				case SCE_CSS_DEFAULT:
168  				case SCE_CSS_VALUE:
169  				case SCE_CSS_IMPORTANT:
170  				case SCE_CSS_IDENTIFIER:
171  				case SCE_CSS_IDENTIFIER2:
172  				case SCE_CSS_IDENTIFIER3:
173  					if (hasNesting)
174  						sc.SetState(nestingLevel > 0 ? SCE_CSS_IDENTIFIER : SCE_CSS_DEFAULT);
175  					else
176  						sc.SetState(SCE_CSS_DEFAULT);
177  					break;
178  				}
179  				break;
180  			case '(':
181  				if (lastState == SCE_CSS_PSEUDOCLASS)
182  					sc.SetState(SCE_CSS_TAG);
183  				else if (lastState == SCE_CSS_EXTENDED_PSEUDOCLASS)
184  					sc.SetState(SCE_CSS_EXTENDED_PSEUDOCLASS);
185  				break;
186  			case ')':
187  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
188  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS ||
189  					lastState == SCE_CSS_PSEUDOELEMENT || lastState == SCE_CSS_EXTENDED_PSEUDOELEMENT)
190  					sc.SetState(SCE_CSS_TAG);
191  				break;
192  			case ':':
193  				switch (lastState) {
194  				case SCE_CSS_TAG:
195  				case SCE_CSS_DEFAULT:
196  				case SCE_CSS_CLASS:
197  				case SCE_CSS_ID:
198  				case SCE_CSS_PSEUDOCLASS:
199  				case SCE_CSS_EXTENDED_PSEUDOCLASS:
200  				case SCE_CSS_UNKNOWN_PSEUDOCLASS:
201  				case SCE_CSS_PSEUDOELEMENT:
202  				case SCE_CSS_EXTENDED_PSEUDOELEMENT:
203  					sc.SetState(SCE_CSS_PSEUDOCLASS);
204  					break;
205  				case SCE_CSS_IDENTIFIER:
206  				case SCE_CSS_IDENTIFIER2:
207  				case SCE_CSS_IDENTIFIER3:
208  				case SCE_CSS_EXTENDED_IDENTIFIER:
209  				case SCE_CSS_UNKNOWN_IDENTIFIER:
210  				case SCE_CSS_VARIABLE:
211  					sc.SetState(SCE_CSS_VALUE);
212  					lastStateVal = lastState;
213  					break;
214  				}
215  				break;
216  			case '.':
217  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
218  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
219  					sc.SetState(SCE_CSS_CLASS);
220  				break;
221  			case '#':
222  				if (lastState == SCE_CSS_TAG || lastState == SCE_CSS_DEFAULT || lastState == SCE_CSS_CLASS || lastState == SCE_CSS_ID ||
223  					lastState == SCE_CSS_PSEUDOCLASS || lastState == SCE_CSS_EXTENDED_PSEUDOCLASS || lastState == SCE_CSS_UNKNOWN_PSEUDOCLASS)
224  					sc.SetState(SCE_CSS_ID);
225  				break;
226  			case ',':
227  			case '|':
228  			case '~':
229  				if (lastState == SCE_CSS_TAG)
230  					sc.SetState(SCE_CSS_DEFAULT);
231  				break;
232  			case ';':
233  				switch (lastState) {
234  				case SCE_CSS_DIRECTIVE:
235  					if (hasNesting) {
236  						sc.SetState(nestingLevel > 0 ? SCE_CSS_IDENTIFIER : SCE_CSS_DEFAULT);
237  					} else {
238  						sc.SetState(SCE_CSS_DEFAULT);
239  					}
240  					break;
241  				case SCE_CSS_VALUE:
242  				case SCE_CSS_IMPORTANT:
243  					if (insideParentheses) {
244  						sc.SetState(lastState);
245  					} else {
246  						if (lastStateVal == SCE_CSS_VARIABLE) {
247  							sc.SetState(SCE_CSS_DEFAULT);
248  						} else {
249  							sc.SetState(SCE_CSS_IDENTIFIER);
250  						}
251  					}
252  					break;
253  				case SCE_CSS_VARIABLE:
254  					if (lastStateVar == SCE_CSS_VALUE) {
255  						if (insideParentheses) {
256  							sc.SetState(SCE_CSS_VALUE);
257  						} else {
258  							sc.SetState(SCE_CSS_IDENTIFIER);
259  						}
260  					} else {
261  						sc.SetState(SCE_CSS_DEFAULT);
262  					}
263  					break;
264  				}
265  				break;
266  			case '!':
267  				if (lastState == SCE_CSS_VALUE)
268  					sc.SetState(SCE_CSS_IMPORTANT);
269  				break;
270  			}
271  		}
272  		if (sc.ch == '*' && sc.state == SCE_CSS_DEFAULT) {
273  			sc.SetState(SCE_CSS_TAG);
274  			continue;
275  		}
276  		if (sc.ch == '(')
277  			insideParentheses = true;
278  		else if (sc.ch == ')')
279  			insideParentheses = false;
280  		if (hasVariables) {
281  			if (sc.ch == varPrefix) {
282  				switch (sc.state) {
283  				case SCE_CSS_DEFAULT:
284  					if (isLessDocument) 
285  						break;
286  				case SCE_CSS_VALUE:
287  					lastStateVar = sc.state;
288  					sc.SetState(SCE_CSS_VARIABLE);
289  					continue;
290  				}
291  			}
292  			if (sc.state == SCE_CSS_VARIABLE) {
293  				if (IsAWordChar(sc.ch)) {
294  					continue;
295  				}
296  				if (lastStateVar == SCE_CSS_VALUE) {
297  					sc.SetState(SCE_CSS_VALUE);
298  				}
299  			}
300  			if (sc.ch == '&') {
301  				switch (sc.state) {
302  				case SCE_CSS_DEFAULT:
303  				case SCE_CSS_IDENTIFIER:
304  					sc.SetState(SCE_CSS_TAG);
305  					continue;
306  				}
307  			}
308  		}
309  		if (hasNesting) {
310  			if (sc.state == SCE_CSS_IDENTIFIER && (IsAWordChar(sc.ch) || sc.ch == ':' || sc.ch == '.' || sc.ch == '#')) {
311  				Sci_PositionU endPos = startPos + length;
312  				int ch;
313  				for (Sci_PositionU i = sc.currentPos; i < endPos; i++) {
314  					ch = styler.SafeGetCharAt(i);
315  					if (ch == ';' || ch == '}')
316  						break;
317  					if (ch == '{') {
318  						sc.SetState(SCE_CSS_DEFAULT);
319  						continue;
320  					}
321  				}
322  			}
323  		}
324  		if (IsAWordChar(sc.ch)) {
325  			if (sc.state == SCE_CSS_DEFAULT)
326  				sc.SetState(SCE_CSS_TAG);
327  			continue;
328  		}
329  		if (IsAWordChar(sc.chPrev) && (
330  			sc.state == SCE_CSS_IDENTIFIER || sc.state == SCE_CSS_IDENTIFIER2 ||
331  			sc.state == SCE_CSS_IDENTIFIER3 || sc.state == SCE_CSS_EXTENDED_IDENTIFIER ||
332  			sc.state == SCE_CSS_UNKNOWN_IDENTIFIER ||
333  			sc.state == SCE_CSS_PSEUDOCLASS || sc.state == SCE_CSS_PSEUDOELEMENT ||
334  			sc.state == SCE_CSS_EXTENDED_PSEUDOCLASS || sc.state == SCE_CSS_EXTENDED_PSEUDOELEMENT ||
335  			sc.state == SCE_CSS_UNKNOWN_PSEUDOCLASS ||
336  			sc.state == SCE_CSS_IMPORTANT ||
337  			sc.state == SCE_CSS_DIRECTIVE
338  		)) {
339  			char s[100];
340  			sc.GetCurrentLowered(s, sizeof(s));
341  			char *s2 = s;
342  			while (*s2 && !IsAWordChar(*s2))
343  				s2++;
344  			switch (sc.state) {
345  			case SCE_CSS_IDENTIFIER:
346  			case SCE_CSS_IDENTIFIER2:
347  			case SCE_CSS_IDENTIFIER3:
348  			case SCE_CSS_EXTENDED_IDENTIFIER:
349  			case SCE_CSS_UNKNOWN_IDENTIFIER:
350  				if (css1Props.InList(s2))
351  					sc.ChangeState(SCE_CSS_IDENTIFIER);
352  				else if (css2Props.InList(s2))
353  					sc.ChangeState(SCE_CSS_IDENTIFIER2);
354  				else if (css3Props.InList(s2))
355  					sc.ChangeState(SCE_CSS_IDENTIFIER3);
356  				else if (exProps.InList(s2))
357  					sc.ChangeState(SCE_CSS_EXTENDED_IDENTIFIER);
358  				else
359  					sc.ChangeState(SCE_CSS_UNKNOWN_IDENTIFIER);
360  				break;
361  			case SCE_CSS_PSEUDOCLASS:
362  			case SCE_CSS_PSEUDOELEMENT:
363  			case SCE_CSS_EXTENDED_PSEUDOCLASS:
364  			case SCE_CSS_EXTENDED_PSEUDOELEMENT:
365  			case SCE_CSS_UNKNOWN_PSEUDOCLASS:
366  				if (op == ':' && opPrev != ':' && pseudoClasses.InList(s2))
367  					sc.ChangeState(SCE_CSS_PSEUDOCLASS);
368  				else if (opPrev == ':' && pseudoElements.InList(s2))
369  					sc.ChangeState(SCE_CSS_PSEUDOELEMENT);
370  				else if ((op == ':' || (op == '(' && lastState == SCE_CSS_EXTENDED_PSEUDOCLASS)) && opPrev != ':' && exPseudoClasses.InList(s2))
371  					sc.ChangeState(SCE_CSS_EXTENDED_PSEUDOCLASS);
372  				else if (opPrev == ':' && exPseudoElements.InList(s2))
373  					sc.ChangeState(SCE_CSS_EXTENDED_PSEUDOELEMENT);
374  				else
375  					sc.ChangeState(SCE_CSS_UNKNOWN_PSEUDOCLASS);
376  				break;
377  			case SCE_CSS_IMPORTANT:
378  				if (strcmp(s2, "important") != 0)
379  					sc.ChangeState(SCE_CSS_VALUE);
380  				break;
381  			case SCE_CSS_DIRECTIVE:
382  				if (op == '@' && (strcmp(s2, "media") == 0 || strcmp(s2, "supports") == 0 || strcmp(s2, "document") == 0 || strcmp(s2, "-moz-document") == 0))
383  					sc.ChangeState(SCE_CSS_GROUP_RULE);
384  				break;
385  			}
386  		}
387  		if (sc.ch != '.' && sc.ch != ':' && sc.ch != '#' && (
388  			sc.state == SCE_CSS_CLASS || sc.state == SCE_CSS_ID ||
389  			(sc.ch != '(' && sc.ch != ')' && ( &bsol;* This line of the condition makes it possible to extend pseudo-classes with parentheses */
390  				sc.state == SCE_CSS_PSEUDOCLASS || sc.state == SCE_CSS_PSEUDOELEMENT ||
391  				sc.state == SCE_CSS_EXTENDED_PSEUDOCLASS || sc.state == SCE_CSS_EXTENDED_PSEUDOELEMENT ||
392  				sc.state == SCE_CSS_UNKNOWN_PSEUDOCLASS
393  			))
394  		))
395  			sc.SetState(SCE_CSS_TAG);
396  		if (sc.Match('/', '*')) {
397  			lastStateC = sc.state;
398  			comment_mode = eCommentBlock;
399  			sc.SetState(SCE_CSS_COMMENT);
400  			sc.Forward();
401  		} else if (hasSingleLineComments && sc.Match('/', '/') && !insideParentheses) {
402  			lastStateC = sc.state;
403  			comment_mode = eCommentLine;
404  			sc.SetState(SCE_CSS_COMMENT);
405  			sc.Forward();
406  		} else if ((sc.state == SCE_CSS_VALUE || sc.state == SCE_CSS_ATTRIBUTE)
407  			&& (sc.ch == '\"' || sc.ch == '\'')) {
408  			lastStateS = sc.state;
409  			sc.SetState((sc.ch == '\"' ? SCE_CSS_DOUBLESTRING : SCE_CSS_SINGLESTRING));
410  		} else if (IsCssOperator(sc.ch)
411  			&& (sc.state != SCE_CSS_ATTRIBUTE || sc.ch == ']')
412  			&& (sc.state != SCE_CSS_VALUE || sc.ch == ';' || sc.ch == '}' || sc.ch == '!')
413  			&& ((sc.state != SCE_CSS_DIRECTIVE && sc.state != SCE_CSS_GROUP_RULE) || sc.ch == ';' || sc.ch == '{')
414  		) {
415  			if (sc.state != SCE_CSS_OPERATOR)
416  				lastState = sc.state;
417  			sc.SetState(SCE_CSS_OPERATOR);
418  			op = sc.ch;
419  			opPrev = sc.chPrev;
420  		}
421  	}
422  	sc.Complete();
423  }
424  static void FoldCSSDoc(Sci_PositionU startPos, Sci_Position length, int, WordList *[], Accessor &styler) {
425  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
426  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
427  	Sci_PositionU endPos = startPos + length;
428  	int visibleChars = 0;
429  	Sci_Position lineCurrent = styler.GetLine(startPos);
430  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
431  	int levelCurrent = levelPrev;
432  	char chNext = styler[startPos];
433  	bool inComment = (styler.StyleAt(startPos-1) == SCE_CSS_COMMENT);
434  	for (Sci_PositionU i = startPos; i < endPos; i++) {
435  		char ch = chNext;
436  		chNext = styler.SafeGetCharAt(i + 1);
437  		int style = styler.StyleAt(i);
438  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
439  		if (foldComment) {
440  			if (!inComment && (style == SCE_CSS_COMMENT))
441  				levelCurrent++;
442  			else if (inComment && (style != SCE_CSS_COMMENT))
443  				levelCurrent--;
444  			inComment = (style == SCE_CSS_COMMENT);
445  		}
446  		if (style == SCE_CSS_OPERATOR) {
447  			if (ch == '{') {
448  				levelCurrent++;
449  			} else if (ch == '}') {
450  				levelCurrent--;
451  			}
452  		}
453  		if (atEOL) {
454  			int lev = levelPrev;
455  			if (visibleChars == 0 && foldCompact)
456  				lev |= SC_FOLDLEVELWHITEFLAG;
457  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
458  				lev |= SC_FOLDLEVELHEADERFLAG;
459  			if (lev != styler.LevelAt(lineCurrent)) {
460  				styler.SetLevel(lineCurrent, lev);
461  			}
462  			lineCurrent++;
463  			levelPrev = levelCurrent;
464  			visibleChars = 0;
465  		}
466  		if (!isspacechar(ch))
467  			visibleChars++;
468  	}
469  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
470  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
471  }
472  static const char * const cssWordListDesc[] = {
473  	"CSS1 Properties",
474  	"Pseudo-classes",
475  	"CSS2 Properties",
476  	"CSS3 Properties",
477  	"Pseudo-elements",
478  	"Browser-Specific CSS Properties",
479  	"Browser-Specific Pseudo-classes",
480  	"Browser-Specific Pseudo-elements",
481  	0
482  };
483  LexerModule lmCss(SCLEX_CSS, ColouriseCssDoc, "css", FoldCSSDoc, cssWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCSS.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexCSS.cxx</div>
                </div>
                <div class="column column_space"><pre><code>124  				opPrev = styler.SafeGetCharAt(i-2);
125  				while (--i) {
126  					lastState = styler.StyleAt(i-1);
127  					if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
128  						break;
129  				}
130  			}
</pre></code></div>
                <div class="column column_space"><pre><code>124  				opPrev = styler.SafeGetCharAt(i-2);
125  				while (--i) {
126  					lastState = styler.StyleAt(i-1);
127  					if (lastState != SCE_CSS_OPERATOR && lastState != SCE_CSS_COMMENT)
128  						break;
129  				}
130  			}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    